environment. 
This divergence of opinions  escalated as time  went on. 
Java  security  features  inside  Netscape’s  browser  releases 
were  becoming  more  and  more  different  from  where  JDK 
1.2  was  heading.  The  longer  the  dispute  dragged  on,  the 
harder  it  was  to  resolve  the  differences.  This  debate  with 
Netscape  was  not  a  question  of  whose  work  is  right  or 
whose  is  wrong.  No  doubt  the  Netscape  team  knew  the 
browser better and wanted to do the best for that. Rather, the 
key question is what to build into the platform, what should 
be done as (optional) extensions, and what should be left to 
application  developers.  To  answer  this  question  requires 
betting  the  future  direction  of  Java.  We  obviously  thought 
that the browser, albeit very important, was just one of the 
many  types  of  applications  Java  should  support,  and 
browser-specific  security  support  should  not  override  or 
replace general systems security support. 
In order to build better relationships, Jim Roskind and I 
were  told  (by  our  respective  management)  to  visit  each 
other’s  office  on  alternate  weeks,  which  we  did.  But  we 
could not patch up the work difference. Then one day, very 
late into the JDK 1.2 project, news came that Jim Barksdale 
(CEO of Netscape) and Alan Baratz (President of JavaSoft) 
made  a  deal  in  a  New  York  hotel  room  that  we  would 
submit  this  dispute  to  arbitration,  by  IBM.  IBM  quickly 
assembled a task force led by Bob Blakley and consisted of 
security  experts.  They  asked  for  and  received  design 
documents,  code,  test  cases  --  everything  that  would  help 
them evaluate the two different systems. After a few months 
of high  suspense, the Sun and Netscape teams  were called 
into a conference room at IBM’s Java building in Cupertino, 
a block away from JavaSoft. Bob led off their presentation 
and rated the systems à la Consumer Reports amid a ton of 
charts  and  stars.  Then  he  simply  announced  that  the 
JavaSoft’s design won. And that was the abrupt end of this 
exhausting conflict. 
V.  SAFE CODING 
David  Wagner  at  UC  Berkeley  recently  asked  me  how 
extensively  the  fine-grained  access  control  mechanism, 
which is central to the JDK 1.2 security architecture, is used 
today.  I  have  not  done  a  survey  and  thus  have  no  answer. 
However, I should emphasize that in addition to providing 
an implementation of the principle of least privilege, another 
important  goal  of  this  architecture  was  to  make  safe  code 
easier to write. 
For  example,  with  a  seemingly  trivial  binary  security 
model, the implementation in JDK 1.0/1.1 was very fragile. 
Consider the case of a file system API being called to open 
a  file.  According  to  the  model,  if  this  request  originated 
from an applet, it should be denied. Otherwise, it is allowed. 
One problem was how to differentiate the two situations.  
Without a generalized security architecture in place, the 
JRE  was  reduced  to  counting  how  many  call  frames  there 
are on a particular stretch of the system execution stack at 
that moment, trying to determine if there is an applet on the 
call stack. It was figured out that, in most cases, if the stack 
count is 2 (or maybe 3, depending on a number of factors), 
then the call must have come from an applet and therefore 
must be disallowed. There were exceptions to this rule, and 
the  whole  system  was  patched  together  through  trial  and 
error. Any change to the system, such as adding a layer of 
indirection  by  adding  a  new  class,  may  change  the  system 
behavior  in  an  undesirable  way.  Adding  a  new  package  to 
the  system  would  require  a  fresh  look  at  all  the  existing 
assumptions.  Thus  it  is  not  difficult  to  see  that  basing 
security  decisions  on  semi-blind  stack  counting  is  not  the 
best idea and why it was the source of a number of security 
bugs. 
JDK  1.2  introduced  a  uniform  way  to  make  access 
control decisions, based on the classic concept of protection 
domains  and  the  well-known  but  rarely  implemented 
principle  of 
removes 
least  privilege. 
It  completely 
397
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:13:50 UTC from IEEE Xplore.  Restrictions apply. 
guesswork  in  security  enforcement.  A  critical  action  is 
allowed  if  and  only  if  all  individual  classes  in  the  calling 
chain have privileges for the action. 
In conjunction with the principle of least privilege, JDK 
1.2  introduced  a  “trusted”  mode,  where  a  programmer  can 
specifically invoke all the privileges the code has, rather like 
the  setuid  feature  in  Unix.  This  is  very  useful  for  writing 
system code. However, unlike UNIX where setuid is turned 
on for an entire program, in Java the special privilege lasts 
only  during  that  one  part  of  the  code. 
  Moreover, 
programmers who have not used this special feature in their 
code  can  rest  assured  that  the  code  will  not  accidentally 
cause  undue  harm,  since  it  is  prevented  from  violating  the 
least privilege principle. 
For whatever reason, my Java security book did not go 
into  any  of  these  details  on  why  the  JDK  system  security 
was so fragile in earlier versions. I guess it was considered 
sensitive information at the time. 
VI.  ARCHIMEDES’S FULCRUM 
An  often  repeated  adage  is  that  security  for  a  system 
must  be  designed  in;  otherwise  it  would  be  almost 
impossible to retrofit. We were lucky with Java. Thanks to 
the  foresight  of  the  initial  Java  designers,  they  defined  the 
SecurityManager  class  and  made  it  clear  that  classes 
controlling access to critical resources should check with the 
SecurityManager  for  a  decision  to  either  grant  to  deny 
access.  It  does  not  matter  that  in  JDK  1.2  we  completely 
rewrote  the  SecurityManager  class.  It  also  does  not  matter 
that  we  practically  changed  everything  related  to  security 
from what was originally released. What matters is that the 
early designers made it acceptable, and indeed necessary, to 
query the SecurityManager at critical junctures.  
I  believe  that  this  acceptance  singled-handedly  enabled 
us  to  retrofit  a  much  more  stylized  security  architecture 
without causing too many troubles at the code level and the 
culture 
level.  The  continued  use  of  SecurityManager 
minimized  backward  compatibility  problems.  The  request 
that  all  classes 
its  security 
implications was easier to accept because security was there 
in the first place. This is why I chose to quote Archimedes 
in the preface of my Java security book – “Give me a lever 
and a fulcrum, and I can move the globe.” SecurityManager 
was that fulcrum. 
in  JDK  must  consider 
Nevertheless, retrofitting was not easy. For example, one 
technique used by JIT (just-in-time) compilers to speed up 
code execution was to try to combine a consecutive number 
of execution instructions into a single instruction. Under the 
JDK 1.2 security model, each instruction might come from a 
different  piece  of  code,  associated  with  a  unique  set  of 
privileges.  The  JVM  folks  had  to  do  things  differently  so 
that  security  properties  are  not  broken  during  code 
optimizations. 
Here  is  one  more  story,  on  the  lighter  side.  Remember 
that  the  principle  of  least  privilege  effectively  lowers  the 
privilege  of  systems  code  so  that,  when  they  need  to 
exercise  their  special  power,  the  programmer  needs  to 
explicitly  enable  the  special  power  for  that  part  of  the 
program.  This  principle  broke  a  bunch  of  existing  code  – 
code  that  was  perhaps  dangerously  exercising  too  much 
privilege.  Instead  of  dealing  with 
the  new  security 
architecture,  an  engineer  at  JavaSoft  duplicated  system 
classes but modified them to bypass security checks, for the 
sole purpose to let his existing code continue to function as 
before.  Fortunately,  this  misdeed  was  caught  during  our 
internal security code audit. 
VII.  SECOND THOUGHTS AND AFTERTHOUGHT 
I  am  sometimes  asked  if  I  have  any  regrets  or  second 
thoughts.  Would  I  have  done  things  differently  with 
hindsight?  Did  we  do  too  little,  too  much,  or  just  about 
right? 
In retrospective, it is truly amazing how far we managed 
to go. My final job interview at JavaSoft (with a very senior 
figure) was centered on the question of whether security for  
the  Java  platform  was  merely  about  finding  bugs  and 
providing fixes; and whether the whole thing would “blow 
over” in a few months. However, once inside JavaSoft, my 
team  was  given  much  green  light  and  priority,  and  was 
granted a lot of freedom (e.g., to require changes to various 
parts of the system, to delay releases until all security tests 
were passed) that would be rare in other places. 
Broadly speaking, our first major achievement was that 
we  largely  “settled”  the  Java  security  debate,  in  the  sense 
that  we  mapped  out  the  landscape  (of  security  for  such  a 
complex language plus development platform), developed a 
general security model, and produced an implementation of 
the  least-privilege  principle.  Of  course,  security  work  in 
general and Java security in particular continue to this day; 
but the discussion has matured. 
The second major achievement is that we raised the bar 
for  everybody  else.  Security  for  any  new  system  is  now 
required, not optional. 
The  third  major  achievement  is  that  we  made  a  strong 
impact,  with  regard  to  secure  programming,  on  not  only 
those engineers (at Sun and elsewhere) who were involved 
in the development of the Java platform itself, but also the 
very large number of Java programmers. These developers 
in  turn  bring  their  security  awareness  and  influence  into 
their next projects. 
Looking back, we probably did all we could during that 
relatively short period of time, under all the constraints we 
had. Nonetheless, there were a few ideas that I would have 
loved to investigate a bit more. For example, it would have 
been  much  cleaner  for  the  programmer  if  the  privileged 
operation  was  specified  via  a  new  method  modifier 
“privileged”;  however,  such  a  language  extension  would 
have  required  major  changes  to  the  system  and  compilers, 
involving not only Sun but also many other parties. 
As  another  example,  GuardedObject  potentially  can  be 
used  to  express  security  requirements  more  elegantly  and 
accurately, especially when objects are accessed in a context 
(or  system)  that  is  different  from  the  one  in  which  the 
objects  were created. However, we simply  had to continue 
with the SecurityManager centric design because it was both 
backward compatible with JDK 1.1 and a better understood 
solution. 
398
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:13:50 UTC from IEEE Xplore.  Restrictions apply. 
In late 1990s, researchers came up with many interesting 
ideas to approach security from fresh angles. For example, 
Fred  Schneider,  a  key  member  of  the  Java  Security 
Advisory Council, together with his PhD student at Cornell, 
Ulfar  Erlingsson,  proposed  Inline  Reference  Monitors, 
which  promised  not  only  a  mechanism  to  completely 
separate  security  policy  from  enforcement  (via  bytecode 
rewriting) but also a theoretical proof that the solution was 
extremely  expressive  –  it  is  able  to  encode  all  enforceable 
policies. Despite the very attractive attributes of those ideas, 
we simply could not afford to try going down those paths, 
timing being just one of the many obstacles. 
JDK  1.2  turned  out  to  be  the  single  shot  we  got  to 
overhaul security for the Java platform. 
VIII.  NEVER FORGET CLASS STRUGGLE 
I  was  very  fortunate  to  have  had  the  opportunity  to 
participate  in  the  shaping  of  the  Java  platform,  which  has 
succeeded beyond expectations to become a major force in 
the  software  world.  In  this  effort,  I  have  had  tremendous 
help and advice from  friends and colleagues too numerous 
to  name  them  all  in  this  paper.  Any  and  all  omissions  of 
names here are not intentional. I have chosen to recall a few 
stories along this journey, which I hope are interesting to the 
readers.  
As time flies by, memories start to fade. And I did not 
have  the  time  to  double  check  events  with  all  the 
participants. I stand corrected, and apologize in advance, for 
any 
inaccuracies  or  errors.  A  more  comprehensive 
bibliographical  reference  to  prior  work  that  influenced  the 
Java security architecture can be found in my Java security 
book.  
So what is Java security, after all? Well, the answers are 
in  the  book,  but  probably  not  where  you  would  look  for 
them. The book cover, which I designed to depict the Duke 
wielding a sword standing on the Great Wall of China, was 
meant  to  be  ironic  (especially  if  you  can  read  the  Chinese 
slogans  on  the  two  flags)  –  the  Wall  was  built  to  defend 
against  barbarians  but  the  invaders  simply  broke  through 
elsewhere. My favorite quote in the book is Mao Ze-Dong’s 
well-known  utterance,  “Never  Forget  Class  Struggle,” 
which is basically what Java security is all about. 
IX.  ACKNOWLEDGEMENTS 
Jeremy  Epstein  invited  me  to  write  this  retrospect  and 
helped  me  with  editorial  matters.  Peter  Neumann  tracked 
down old meeting notes and provided detailed comments on 
a draft of this paper. Drew Dean reminded me of some of the 
early Java security bugs. I am very grateful for their time and 
effort.  
REFERENCES 
[1]  The  ACM  RISKS  Forum.  Moderated  by  P.G.  Neumann.  Online  at   
www.risks.org. 
[2]  L. Gong, "New Security Architectural Directions for Java (Extended 
Abstract)". In Proceedings of IEEE COMPCON, San Jose, California, 
February, 1997,  pp.97--102. 
[3]  L.  Gong.  Java  Security:  Present  and  Near  Future.,  IEEE  Micro, 
17(3):14--19, May/June 1997.  
[4]  L.  Gong,  M.  Mueller,  H.  Prafullchandra, and R.  Schemers.,  "Going 
Beyond the Sandbox: An Overview of the New Security Architecture 
in  the  Java  Development  Kit  1.2".    In  Proceedings  of  the  USENIX 
Symposium  on  Internet  Technologies  and  Systems,  Monterey, 
California, December, 1997, pp.103--112. 
[5]  L.  Gong.  Inside  Java  2  Platform  Security,  First  Edition,  Addison 
Wesley, 1999. 
[6]  L.  Gong,  G.  Ellison,  and  M.  Dageforde.  Inside  Java  2  Platform 
Security, Second Edition, Addison Wesley, 2003. 
399
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:13:50 UTC from IEEE Xplore.  Restrictions apply. 
JAVA SECURITY: PRESENT
AND NEAR FUTURE
Li Gong
JavaSoft
The global system
infrastructure is
evolving rapidly.
Java’s security model
must keep pace.
Since the inception of Java,1,2 there has
been strong and growing interest in
Java’s security as well as in new secu-
rity issues raised by this technology’s deploy-
ment.  These  concerns  have  reached  the
mainstream—the New York Times, the Wall
Street Journal, and others have run stories
on Java security. However, we must exam-
ine Java’s trustworthiness comprehensively,
from a broad dependability perspective,3-6
not simply from the journalistic view.
A simplistic statement such as “Java is [or is
not] secure” doesn’t come close to capturing
the complexity of the issues involved. To pass
judgment on whether Java is a trustworthy
language  or  platform,  we  must  precisely