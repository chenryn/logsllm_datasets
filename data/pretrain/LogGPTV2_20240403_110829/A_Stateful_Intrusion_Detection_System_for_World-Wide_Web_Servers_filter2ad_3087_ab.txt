domain. The response functions in the library can be dy-
namically associated with the states modeled in the attack
scenarios.
4 An Intrusion Detection System for Web
Servers
The WebSTAT intrusion detection system was developed
by following the process outlined above. WebSTAT was
built by developing new modules and reusing other mod-
ules developed for other sensors. More precisely, a lan-
guage extension module that deﬁnes web-speciﬁc events
was developed and an event provider that parses web server
logs and generates the corresponding events was also de-
veloped. In addition, pre-existing language extensions and
event providers that manage operating system-level and
network-level events were included in the system. These
modules were originally developed to build network-based
and host-based intrusion sensors [21] but could be re-used
in WebSTAT without modiﬁcation, thanks to the modular
nature of the STAT framework. As a last step, a num-
ber of STATL scenarios were developed to detect attacks
against web servers. These attacks rely on one or more
event streams to identify the evidence of an attack. The
resulting system is shown in Figure 1.
The web language extension contains the deﬁnition of
the basic client request event, auxiliary types, and web-
speciﬁc predicates. Figure 2 shows a simpliﬁed version
of the class for the Request event, which is an abstrac-
tion of an entry in the application log generated by a web
server. Note that the class Request is a subclass of
STAT Event, which is the root event class of the STAT
framework. Every new event introduced by a language ex-
tension must be a subclass of STAT Event.
class Request : public STAT_Event
{
public:
string request;
string userAgent;
string encodedRequest; // Decoded string
bool isRequestEncoded; // Encoding flag
// Client request
// User agent
[...]
}
Figure 2. The Request event deﬁned in the
web language extension.
The log-based event provider reads the events stored
in the server application log ﬁle as they are generated.
The event provider parses the Common/Extended Log For-
mat representation of the events and creates corresponding
Request objects. These events are then inserted in the
STAT Core event queue. The STAT Core extracts the events
from the event queue and passes them to active attack sce-
narios for analysis (see Figure 1).
Attacks are represented by using STATL to specify state-
transition models over the stream of events generated by the
event providers. A number of attack scenarios have been
developed; the following sections describe a subset of the
existing scenarios.
A common pattern used by many of the WebSTAT sce-
narios is the “counting scenario” pattern. Each scenario that
conforms to this pattern requires the following integer pa-
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:46:17 UTC from IEEE Xplore.  Restrictions apply. 
4
Web Server
WebSTAT
TCP/IP
Extension
OS−level
Extension
Web
Extension
Response
Module
STAT
Core
Attack Scenarios
Event queue
Server Log
Event Provider Event Provider Event Provider
Network
OS
Server Log
Auditing
System
Network
Driver
Server host
Network
Figure 1. The WebSTAT component-based architecture. WebSTAT is obtained by composing the
domain-independent STAT runtime with a number of language extensions, event providers, attack
scenarios, and response functions.
rameters to be supplied: threshold, alert freq, and
inactivity timeout. The ﬁrst parameter speciﬁes the
number of occurrences of the event that need to appear in
the event stream before an alert is raised. The second pa-
rameter indicates the frequency at which intermediate alerts
are to be produced after the threshold has been overcome
and before the attack is terminated. The attack is consid-
ered terminated when the attacker is inactive for the time
speciﬁed by the inactivity timeout parameter.
The web crawler, pattern matching, and repeated failed
access scenarios presented in the following sections are
examples of this generic counting scenario. The state-
transition diagram of the counting scenario is shown in Fig-
ure 3. The reader should recall from section 3 that transi-
tions can be nonconsuming, consuming, or unwinding. In a
state-transition diagram the three types of transition are rep-
resented graphically using single headed, double-headed, or
dashed-line arrows, respectively, and the initial state of a
scenario is represented as state S0.
The STAT framework also provides a number of generic
response modules that scenarios can use to generate alerts.
By default, WebSTAT uses the IDMEF response module,
which generates alerts in IDMEF format [5]. However,
WebSTAT can be extended dynamically with other response
modules. Examples of possible response modules include
the resetting of TCP connections and the dynamic reconﬁg-
uration of web servers in response to a detected attack.
4.1 Malicious Web Crawler Scenario
Web servers use a special ﬁle, robots.txt, to indicate
what the acceptable behavior for robots (spiders/crawlers)
visiting the site is. The web crawler scenario checks
if robots indexing the contents of the web site hosted
by the server adhere to the instructions speciﬁed in the
robots.txt ﬁle. An alarm is raised if any web crawler
violates the speciﬁed instructions. For this scenario to func-
tion, WebSTAT requires the User-Agent ﬁeld to be logged;
therefore, the server must be conﬁgured to log the requests
in the Extended Log Format (ELF).
The robots.txt ﬁle is formatted according to the
Robots Exclusion Protocol
[13]. This ﬁle consists of a
set of records in the form : . The
record starts with one or more User-agent lines, spec-
ifying which robots the record applies to, followed by
Disallow and Allow instructions to that robot. For ex-
ample, consider the following records:
User-agent: *
Disallow: /cyberworld/map/
User-agent: cybermapper
Disallow:
This example speciﬁes that no robots should visit any
URL starting with “/cyberworld/map/”, except for the
robot called cybermapper. All robots must obey the ﬁrst
record in /robots.txt that contains a User-agent
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:46:17 UTC from IEEE Xplore.  Restrictions apply. 
5
RESPONSE
Start of attack
alert_freq
 timeout
Event and threshold == 0:
  count += 1,
  start inactivity timer
Event and count == threshold:
  count += 1,
  restart inactivity timer
Event and threshold != 0:
  count = 1,
  start inactivity timer
Threshold:
start
alert_freq
timer 
Event:
  count +=1,
  restart inactivity timer
Event:
  count += 1,
  restart inactivity timer
alert_freq
 timeout
S0
Event
occurred
Inactivity
 timeout
Attacked
Inactivity
 timeout
Inactivity
 timeout
RESPONSE
Attack in progress
Report:
restart 
alert_freq 
timer
Event and count 
.*default\.ida
.+phf.+\%0a
[...]
4.3 Repeated Failed Access Scenario
The repeated failed access scenario checks if there are
multiple client errors, including failed authentication at-
6
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:46:17 UTC from IEEE Xplore.  Restrictions apply. 
tempts, from a particular client or subnet. This type of activ-
ity is a strong indication that a malicious entity is attempting
to probe the website to gain information for future attacks.
An internal counter records the number of times a failed
request originated from a certain subnet.
If this counter
exceeds the event threshold parameter, an alarm is raised.
This scenario is another instance of the generic counting
scenario.
4.4 Cookie Stealing Scenario
Cookies are a state management mechanism for HTTP
(deﬁned in RFC 2965) that is often used by web applica-
tion developers to implement session tracking. The cookie
stealing scenario detects if a cookie used as a session ID is
improperly utilized by multiple users. This is often a mani-
festation of a malicious user attempting to hijack the session
of a legitimate user to gain unauthorized access to protected
web resources.
The scenario begins by recording the issuance or initial
use of a session cookie by a remote client by mapping the
cookie to an IP address. In addition, an inactivity timer is
simultaneously set. Subsequent use of the session cookie
by the same client results in a reset of the timer, while a
cookie expiration or session timeout results in the removal
of the mapping for that cookie. If, however, a client uses
the valid session cookie of another client, then an attack
is assumed to be underway and an alarm is raised. The
cookie stealing scenario takes two parameters: timeout
and cookie name. The ﬁrst parameter speciﬁes a time-
out that corresponds to the session timeout in seconds for
the protected web application, while the second parameter
speciﬁes the name of the cookie used for session tracking by
the protected web application. An additional requirement is
that the web server has been conﬁgured to enable cookie
logging. The state-transition diagram for this scenario is
shown in Figure 4.
New cookie issued
or used
Cookie used by
different IP
s0
Cookie
in use
Cookie
stolen
Session timeout
or cookie expiration
Cookie used by
same IP
Figure 4. State-transition diagram for the
cookie stealing scenario.
4.5 Buffer Overﬂow Scenario
Buffer overﬂows have historically been a popular attack
against web servers. Aside from missing boundary checks
within the web server itself, vulnerabilities within system
libraries as well as third-party modules can allow remote at-
tackers to gain illicit access to a host with the privileges of
the web server process. The presence of binary data in a re-
quest or an extremely long request are strong indications of
an attempt to exploit a buffer overﬂow. WebSTAT includes
a scenario to detect these conditions. The buffer overﬂow
scenario requires one parameter, length, which deﬁnes a
request length threshold that must be exceeded for an alert
to be raised. The state-transition diagram for this scenario
is shown in Figure 5.
Figure 5. State-transition diagram to detect
buffer overﬂow attacks.
Note that if a buffer overﬂow exploits a vulnerability in
the web server code, it is possible that a log entry would
never be created and the attack would go undetected.
4.6 Combining Network and Application-Level
Buffer Overﬂow Detection
The STAT framework makes cross-domain intrusion de-
tection scenarios possible by providing a comprehensive set
of extension and provider modules to describe and exam-
ine various event sources. With multiple event providers
loaded from different domains, attack scenarios can exam-