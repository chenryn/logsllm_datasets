级汉字3008个，再加上非汉字（拉丁字母、希腊字母等）字符682个，一共有7445个字符，基本上与上述JIS
编码中非汉字加第一～第三水准汉字的容量相当。——译者注
② 这一段是不是有点看不懂呢？其实以前的编码表示方法更加简单一些。例如，“あ”（注：日文平假名，读作“啊”）
这个字符的编码为0x2422，“川”的编码为0x406e，这种方法比较简单吧，因为每一个字符都有它对应的一个编号。
但现在我们所使用的表示方法和以前不同，按照现在的方法，“あ”的字符编码为1面04区02点，“川”的字符编
码为1面32区78点。
其实将以前的编码转换为现在的编码也不难，只要将二进制的4位数字编码中前两位和后两位拆开，再各自减掉
0x20就可以了。例如“あ”是0x2422，转换后得到0x04、0x02，将这两个数字转换为10进制就分别对应了区号和
点号。“川”也一样，将0x406e拆开并各自减掉0x20，得到0x20和0x4e，因此是32区78点。
图灵社区会员 metorm 专享 尊重版权
5 日文文字显示（1）（harib25e） …… 617
01区～13区：非汉字
1
14区～15区：第三水准汉字
16区～47区：第一水准汉字
18
48区～84区：第二水准汉字
84区～94区：第三水准汉字①
3
这次我们为了节省容量，准备只将01区～47区装入nihongo.fnt中，这样的话就只需要47×94×
32＝141376字节，也就是之前的差不多一半大小，启动时间也应该不会很长了。如果大家觉得这样
20
不好，想要把第二、第三水准汉字也全部显示出来的话，不要客气，欢迎大胆改造哦。②
在GB2312中，字符编码的分类如下：
21
01区～09区：非汉字
10区～15区：空白
22
16区～55区：一级汉字
56区～87区：二级汉字
88区～94区：空白 7
如果为了节省容量，我们可以只使用非汉字和一级汉字的部分，即01区～55区的部分，一共
8
需要55×94×32＝165440字节。
9
■■■■■
接下来我们需要考虑的就是字库的字模数据。即便我们只选用01区～47区，其中也包括了
26
47×94＝4418个字符。如果要一个一个字符去设计字模的话，那比编写一个操作系统还要花时间。
因此这次我们还是和当初的半角字库一样，直接从笔者正在开发的OSASK中借用字模吧（OSASK
27
的日文字库版权属于泊何水和圣人[Kiyoto]）。
SASK中的字库文件为jpn16v00.fnt，大小为304KB。不过OSASK和“纸娃娃系统”一样，都
28
是以安装在软盘上使用为前提而设计的，304KB对于软盘来说负担重了些，因此在OSASK中将这
28
——————————
① 有人可能会问，84区不是已经包含在第二水准汉字中了吗？这里再补充说明一下，根据定义，84区前面为第二水
14
准汉字，后面为第三水准汉字。——译者注
② 在GB2312汉字标准中，字符的定位也是采用类似日文“点区面”的方式，不过GB2312中没有面的概念（或
者可以说，GB2312的字符集只有1个面），而区和点我们称为“区位”，和日文一样，每个区包含94个位（即
15
94个字符），例如“啊”字位于16区1位。GB2312中的字符也可以采用二进制编码的方式来表示，相对于日
文JIS标准中将区和点的编号加上0x20的做法，GB2312中是将区和位的编号加上0xa0，例如“啊”字区位编
码加上0xa0后为：0x10（16）＋0xa0＝0xb0，0x01（1）＋0xa0＝0xa1，因此“啊”字的二进制字符编码为 16
0xb0a1。——译者注
图灵社区会员 metorm 专享 尊重版权
618 …… 第28天：文件操作与文字显示
个文件进行了压缩，大小变成了56.7KB①。于是我们首先需要对字库文件进行解压缩（否则我们
无法拿到里面的数据）。
笔者编写的大多数工具程序中都内置了解压缩的功能，随便使用任何一个工具都可以完成解
压缩的操作，这次我们以edimg为例。
提示符> edimg copy nocmp: from:jpn16v00.fnt to:jpn16v00.bin
（这里没有考虑文件路径，请大家根据需要自行加上路径）
好，这样我们就得到了304KB的jpn16v00.bin文件。
下面我们将01区～47区的字模数据提取出来，只要将jpn16v00.bin从开头算起的前141376字
节提取出来就可以了，用二进制编辑器可以轻松搞定。
说起日文显示，我们还需要半角片假名的字库。可能有人会说，我从来不用半角片假名。不
过，能显示总比不能显示要好吧，所以我们还需要提取半角片假名的字模数据。在jpn16v00.bin
中已经包含了显示日文用的半角片假名字模，总共256个字符，位于04A000～04AFFF，共4096
字节。
最终nihongo.fnt的内容如下。
000000～000FFF：显示日文用半角字模，共256个字符（4096字节）
001000～02383F：显示日文用全角字模，共4418个字符（141376字节）
至于提取数据的方法嘛，其实笔者就是用二进制编辑器复制粘贴的（笑）。虽然可能有更棒
的工具来做这件事，不过笔者认为没必要在这种事情上面花太多心思。
（5分钟之后）完工啦，不错不错。②
■■■■■
接下来，我们需要修改bootpack.c，使操作系统可以自动装载字库。
——————————
① jpn16v00.fnt分为两个版本，一个只包含第一水准汉字，另一个包含从第一到第三水准的全部汉字，56.7KB的是只
包含第一水准汉字的版本，48区～94区的内容是空白的。
② 由于作者开发的OSASK系统中并不包含中文字库，各位读者如果需要改造源代码以实现中文显示的支持，则需要
获取一个符合GB2312标准的中文点阵字库文件（例如UCDOS中包含的HZK16），并提取前165440字节制作成一个
仅包含一级汉字的子集。由于汉字显示不需要涉及半角片假名的问题，因此最终在“纸娃娃系统”中所使用的.fnt
文件中000000～000FFF的256个半角字符部分，我们可以直接使用5.5节中生成的字模数据（即“纸娃娃系统”的
内置英文字库）。综上所述，要实现中文显示，所需的.fnt文件结构可以是下面这样：
000000～000FFF：英文半角字模，共256个字符（4096字节），来自系统内置字库数据
001000～02963F：中文全角字模，共5170个字符（165440字节），来自HZK16或其他符合GB2312标准的汉字点阵
字库
图灵社区会员 metorm 专享 尊重版权
5 日文文字显示（1）（harib25e） …… 619
本次的bootpack.c节选
1
void HariMain(void)
{
（中略） 18
int *fat;
unsigned char *nihongo;
struct FILEINFO *finfo; 3
extern char hankaku[4096];
（中略）
20
/*载入nihongo.fnt */
nihongo = (unsigned char *) memman_alloc_4k(memman, 16 * 256 + 32 * 94 * 47);
fat = (int *) memman_alloc_4k(memman, 4 * 2880); 21
file_readfat(fat, (unsigned char *) (ADR_DISKIMG + 0x000200));
finfo = file_search("nihongo.fnt", (struct FILEINFO *) (ADR_DISKIMG + 0x002600), 224);
if (finfo != 0) { 22
file_loadfile(finfo->clustno, finfo->size, nihongo, fat, (char *) (ADR_DISKIMG +
0x003e00));
} else {
7
for (i = 0; i langmode == 0) {
for (; *s != 0x00; s++) { /*从这里起没有修改*/
putfont8(vram, xsize, x, y, c, hankaku + *s * 16);
x += 8;
} /*到这里为止没有修改*/
}
if (task->langmode == 1) {
for (; *s != 0x00; s++) {
putfont8(vram, xsize, x, y, c, nihongo + *s * 16);
x += 8;
}
}
return; /*这里没有修改*/
}
我们在struct TASK里添加了一个langmode（即language mode，语言模式）变量，用于指定一
个任务是使用内置的英文字库还是使用nihongo.fnt的日文字库。通过在struct TASK中添加这个变
量，我们可以对每个任务单独设置语言模式，例如为某个应用程序设置日文模式，而为另一个应
用程序设置英文模式。
■■■■■
既然我们设计了这个语言模式的变量，那么就需要一个命令来对模式进行设定。
本次的console.c节选
void cons_runcmd(char *cmdline, struct CONSOLE *cons, int *fat, int memtotal)
{
（中略）
} else if (strncmp(cmdline, "langmode ", 9) == 0) {
cmd_langmode(cons, cmdline);
} else if (cmdline[0] != 0) {
（中略）
}
void cmd_langmode(struct CONSOLE *cons, char *cmdline)
{
struct TASK *task = task_now();
图灵社区会员 metorm 专享 尊重版权
5 日文文字显示（1）（harib25e） …… 621
unsigned char mode = cmdline[9] - '0'; 1
if (mode langmode = mode;
} else {
18
cons_putstr0(cons, "mode number error.\n");
}
cons_newline(cons);
return; 3
}
20
完工了，现在只要输入“langmode 0”就代表设定为英文模式，输入“langmode 1”就代表
设定为日文模式。
21
■■■■■
不过，在命令行窗口启动时没有设定langmode，这有点不方便，我们来设定一个默认值。 22
本次的console.c节选
7
void console_task(struct SHEET *sheet, int memtotal)
{
（中略） 8
unsigned char *nihongo = (char *) *((int *) 0x0fe8);
（中略）
9
if (nihongo[4096] != 0xff) { /*是否载入了日文字库？*/
task->langmode = 1;
} else {
26
task->langmode = 0;
}
（中略） 27
}
28
这样一来，当成功载入日文字库时，默认值为日文模式，否则默认为英文模式。要想知道是
否成功载入了日文字库，只要判断01区01点的内容就可以了。如果没有载入字库，这里应该是填
充了0xff，如果载入了字库，那么由于01区01点所对应的字符是全角空格，因此这里应该是0x00。 28
到这，我们就差不多大功告成了，不过task_a的langmode还没设定，因此我们再稍微修改一
下HariMain。 14
本次的bootpack.c节选
15
void HariMain(void)
{
（中略）
16
图灵社区会员 metorm 专享 尊重版权
622 …… 第28天：文件操作与文字显示
init_palette();
shtctl = shtctl_init(memman, binfo->vram, binfo->scrnx, binfo->scrny);
task_a = task_init(memman);
fifo.task = task_a;
task_run(task_a, 1, 2);
*((int *) 0x0fe4) = (int) shtctl;
task_a->langmode = 0; /*这里！*/
（中略）
}
这样task_a就设定为英文模式了。
■■■■■
下面我们可以开始编写用来测试的应用程序了，只是现在我们还无法显示全角字符，只能显
示半角字符。不过即便如此，我们也可以测试出是否能成功载入nihongo.fnt（全角字符的显示在
下一节实现）。
由于只能显示半角字符，因此我们来显示几个半角片假名“イロハニホヘト”（注：读作I RO
HA HI HO HE TO，是日本平安时代诗歌《伊吕波歌》的第一句）吧。
iroha.c
#include "apilib.h"
void HariMain(void)
{