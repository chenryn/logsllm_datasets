getKeys method with one that copies and stores the credentials on
the side. It then loads the http module, and posts the credentials
to a remote server, before returning the results to the caller method.
The desired client-observable behavior of flatmap-stream maps
a function over a stream. Removing flatmap-stream therefore
breaks the client. The attack succeeds by performing effects—loading
account, overwriting getKeys, importing http, and calling post—
that do not interfere with the client-observable behavior. The attack
is not detectable by static analysis, because the attacker employed a
series of dynamic encryption passes, nor dynamic analysis because
the malicious code activates selectively far from development and
testing: only when event-stream was part of Copay’s dependency
tree, only when run on the “live” bitcoin network, and only on
users that had a balance of 100 bitcoin or more [52]. When run in
any other context, the compromised version of flatmap-stream
exhibits identical behavior as the correct version.
Applying Harp: Harp can directly target a specific dependency
or a library that integrates multiple dependencies. The following
line applies ALR directly to flatmap-stream:
harp -ft js flatmap - stream
Harp first loads flatmap-stream in an isolated container envi-
ronment and applies lightweight program transformations to in-
strument its execution ( 1○, Fig. 2). This instrumentation records
operations such as library imports, file-system reads, and global
variable accesses that flatmap-stream performs. Harp also ex-
tracts information about the library interface ( 2○). This information
includes the number of returned methods and fields and the number
of arguments for each method. Harp then runs flatmap-stream
on synthesized inputs, to extract information about the types of
each argument.
Regen/tedLibraryDSLInterfaceExtractionLoading &Instr/ion✘InputGeneration✔1342Isolated Environment✘✘✘✔LL✔✔✔✘✔Synthesis✔✔✔5L'6OriginalLibraryLSession 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1757Module
Statement
m := s | m . s
s
toggle p o | map π | fold b | split σ s σ
:= add c l | del l | at l b | repeat n s
|
:= i | /p/
:= n | start | end
:= not p | or p p | and p p | k
:= π . π | b | squash n | o
:= α | n | σ | regex r | capt k
:= o . o | c | ⊥ | b ⊥
:= k . k | p | p ⊥
:= + | − | × | % | Math.* | String.*
:= r | α | n | σ | * | +
∈
Σ1
∈
Σ2
∈ N
Location
Index
Predicate
Pipeline
Char. Class
Output
Capture
Built-ins
Regex
Special
Alpha
Num
Fig. 3: The Harp library DSL. The domain-specific language (DSL) cap-
tures the space of inferrable program libraries.
l
i
p
π
c
o
k
b
r
σ
α
n
For ALR to regenerate a successful replacement, the library must
exhibit the correct behavior during testing and this correct behavior
must conform to the ALR DSL. We anticipate that our target class
of vulnerabilities will typically satisfy these two requirements—the
goal is typically to provide the client with the correct functionality
while either (1) stealthily opening up a remotely exploitable vul-
nerability or (2) silently exfiltrating data or modifying the system
on which it runs. To avoid exploitation during learning, ALR runs
the target library in a controlled isolated environment.
An attacker may also simply remove the library from the ecosys-
tem, disabling any application that depends on the library. By replac-
ing the library with a regenerated local version before the original
library is removed, ALR eliminates the dependence and enables
applications to continue to operate successfully even in the absence
of the original library.
The language’s runtime environment, bindings for locating and
loading libraries, a small compiler offered by Harp and the as-
sociated lib-harp.js runtime-support library are all part of the
trusted computing base (TCB). To capture possible interactions
between libraries, we assume Harp is loaded before other libraries.
We also assume that other libraries do not cooperate with the target
library to attack the system.
4 ACTIVE LEARNING & REGENERATION
Harp combines three components: a DSL for specifying string-
processing computations (§4.1), an algorithm for inferring com-
putations in the DSL (§4.2), and an input generation component
that produces the inputs for the inference algorithm (§4.3). The
three components work in tandem, aided by lightweight runtime
interposition for mapping the interface of a library (§4.4).
4.1 Domain-specific Language
Fig. 3 presents the Harp DSL. The DSL specifies the set of all
programs that can be constructed by Harp, broken down into
a few broad classes: (1) computational primitives, which apply
transformations on their input, (2) built-in primitives for number
and string manipulation commonly offered by high-level languages,
(3) input ranges, over which these primitives are applied, and (4)
character classes, used for pattern ranges and primitives. More
complex classes often combine less complex ones.
Computational primitives: Computational primitives are either
statements or pipelines. Statements include add and del primitives
for introducing and deleting characters and higher-order map and
fold primitives for applying a first-order primitive over a range.
Pipelines apply a series of operators to a collection of elements in an
input stream—optionally recursively to elements of their elements.
These primitives are Harp’s primary building blocks. Fig. 4
presents the operational semantics. The transition function =⇒
maps a computational primitive within our DSL to its output value.
For example, the primitive add accepts a character c, a location
l, and a string s, and returns a string that is the result of adding
the character c at location l in s. All primitives accept a string s on
which to operate as their final argument. Strings are encoded as
lists of characters, list concatenation is encoded as ·, and operations
encoded in sans − serif are built into Harp—for example, match
accepts a predicate p and a string s and returns three character lists:
(1) a string s1 up to (but not including) the match, (2) the matching
string s2, and (3) the rest of the string s3 following s2 in s.
Built-in primitives: This class contains primitives offered com-
monly by the standard libraries of different high-level programming
languages, including operations for arithmetic—e.g., log, sqrt, etc.—
and string manipulation—e.g., toUpper, toAsciiCode. The class of
built-in primitives reimplements these operators from scratch to
address two challenges. The first challenge is that different lan-
guages offer different operators under different names; the Harp
DSL unifies a common subset under a common set of identifiers.
The second challenge is that the invocation patterns of such primi-
tives are different for different languages—for example, JavaScript’s
n.toString is invoked directly on a number n, whereas Python
str(n) takes n directly as an argument. Harp DSL introduces these
operators as functions whose first argument is the input string.
Input ranges: Computational primitives often take as arguments
a location within the string. In their simplest form, locations are
indices relative to the start of an input segment, which can be a
string or a substring within that. For example, the index start in
the expression (at start String.toUpper) matches the beginning
of the string.
Locations can also be predicates that pattern-match on the form
of the string. Predicates are formed by the composition of a simpler
set of base predicates. Composition operators include negation,
disjunction, and conjunction. Base predicates are centered around
a simple pattern-matching language that includes characters, num-
bers, “*” (Kleene-star superscript), and “+” (Kleene-plus superscript).
For example, the predicate /a+/ in at (/a+/) (String.toUpper)
matches one or more a characters.
Character Classes: The DSL includes three sets of characters.
Two of these sets come pre-configured and built into the DSL:
(1) the set of integer numbers and (2) the set of alphanumerics—
including number characters “0” to “9”, lowercase letters “a” to “z”,
uppercase letters “A” to “Z”, and punctuation symbols. The third
set contains characters that are special to a particular computation.
The members of this set are discovered during the learning phase
via input generation (§4.3).
Session 6B: Web Vulnerabilities CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1758l = index 0
add l c s =⇒ [c] · s
Add1
l = index 0
s = [s0] · s1−n
del l s =⇒ s1−n
Del1
l = /p/ (s1, s2, s3) = match p s
2
= b s2 s′
s′
at l b s =⇒ s1 · s′
= at l b s3
2 · s′
3
3
l = index i l′ = index i − 1
s = [s0] · s1−n s′
1−n
= add l′ c s1−n
add l c s =⇒ [s0] · s′
1−n
l = index i l′ = index i − 1
s = [s0] · s1−n s′
1−n
= del l′ s1−n
del l s =⇒ [s0] · s′
1−n
AddI
DelI
l = /p/ (s1, s2, s3) = match p s
s′
3
= add l c s3
add l c s =⇒ s1 · c · s2 · s′
l = /p/ (s1, s2, s3) = match p s
3
s′
3
= del l s3
del l s =⇒ s1 · s′
3
AddP
DelP
At
n (cid:44) 0 s′ = f s
repeat n f s =⇒ repeat (n − 1) f s′
RepeatN
n = 0 s′ = f s
repeat n f s =⇒ s′
Repeat0
l = /p/ (s1, s2, s3) = match p s
toggle l f s =⇒ s1 · (f s2) · s3
Toggle
s = []
map f s =⇒ [] MapE
(s1, [], []) = match /c/ s s′
split c f c′ s =⇒ s′
1
1
= f s1
SplitS
s = [s0] · s1−n s′
= f s0
s = [s0] · s1−n s′
s′
1−n
map f s =⇒ [s′
= map f s1−n
0] · s′
0
1−n
= fold f r s1−n s′
1−n
fold f r s =⇒ s′
0
0
MapF
s = []
fold f r s =⇒ r
FoldE
= f s0 s′
1−n
FoldF
s = []
split c f c′ s =⇒ []
SplitE
(s1, s2, s3) = match /c/ s s′
1
split c f c′ s =⇒ s′
= split c f c′ s3
= f s1 s′
1 · [c′] · s′
3
3
SplitM
Fig. 4: DSL Semantics. A subset of Harp’s DSL semantics, describing Harp’s computational primitives.
Capture and output expressions: Two examples of how simple
elements like character classes and built-in primitives are used
to construct more powerful primitives are capture and output
expressions. toggle’s second argument is an output expression,
which can be thought of as a format string that one would pass
into a function like C’s printf, describing the formatting of the
function’s output. It can contain literal characters, as well as special
identifiers, which are bound to strings that were matched as part
of toggle’s first argument, its predicate, and captured using a
capture expression. For instance, whenever toggle encounters any
character preceding an uppercase character in the program:
toggle f ' {/./( a) }{/[ A -Z ]/( b)} ' '{( a)}- {
(cid:44)→ to_lower (b)} '
it will output the first character it matched—which it assigned to
variable a in the capture expression—followed by a dash, followed
by the captured uppercase character (assigned to b) converted into
lowercase.
4.2 Synthesis Algorithm
Alg. 1 outlines the Harp program inference algorithm. The algo-
rithm takes as input a black-box reference implementation r and
produces as output a DSL program with identical behavior as r on
the generated inputs I. Given a reference library R, Harp invokes
Alg. 1 on all functions r in R.
As Alg. 1 runs, it maintains an iteratively increasing size n of
DSL programs and list of generated inputs I to consider. At each