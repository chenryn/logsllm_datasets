## 1. while(true) 总不让人省心《14 \|Lock&Condition（上）：隐藏在并发包中的管程》](https://time.geekbang.org/column/article/87779)的思考题，本意是通过破坏不可抢占条件来避免死锁问题，但是它的实现中有一个致命的问题，那就是：while(true) 没有 break条件，从而导致了死循环。除此之外，这个实现虽然不存在死锁问题，但还是存在活锁问题的，解决活锁问题很简单，只需要随机等待一小段时间就可以了。``{=html}修复后的代码如下所示，我仅仅修改了两个地方，一处是转账成功之后break，另一处是在 while 循环体结束前增加了`Thread.sleep(随机时间)`。    class Account {  private int balance;  private final Lock lock          = new ReentrantLock();  // 转账  void transfer(Account tar, int amt){    while (true) {      if(this.lock.tryLock()) {        try {          if (tar.lock.tryLock()) {            try {              this.balance -= amt;              tar.balance += amt;              // 新增：退出循环              break;            } finally {              tar.lock.unlock();            }          }//if        } finally {          this.lock.unlock();        }      }//if      // 新增：sleep 一个随机时间避免活锁      Thread.sleep(随机时间);    }//while  }//transfer}这个思考题里面的 while(true) 问题还是比较容易看出来的，**但不是所有的while(true) 问题都这么显而易见的**，很多都隐藏得比较深。例如，[《21 \|原子类：无锁工具类的典范》](https://time.geekbang.org/column/article/90515)的思考题本质上也是一个while(true)，不过它隐藏得就比较深了。看上去`while(!rf.compareAndSet(or, nr))`是有终止条件的，而且跑单线程测试一直都没有问题。实际上却存在严重的并发问题，问题就出在对or 的赋值在 while 循环之外，这样每次循环 or的值都不会发生变化，所以一旦有一次循环 rf.compareAndSet(or, nr) 的值等于false，那之后无论循环多少次，都会等于false。也就是说在特定场景下，变成了 while(true)问题。既然找到了原因，修改就很简单了，只要把对 or 的赋值移到 while循环之内就可以了，修改后的代码如下所示：    public class SafeWM {  class WMRange{    final int upper;    final int lower;    WMRange(int upper,int lower){    // 省略构造函数实现    }  }  final AtomicReference    rf = new AtomicReference<>(      new WMRange(0,0)    );  // 设置库存上限  void setUpper(int v){    WMRange nr;    WMRange or;    // 原代码在这里    //WMRange or=rf.get();    do{      // 移动到此处      // 每个回合都需要重新获取旧值      or = rf.get();      // 检查参数合法性      if(v  cf =   CompletableFuture.supplyAsync(()->{    // 在数据库中查询规则    return findRuleByJdbc();  }).thenApply(r -> {    // 规则校验    return check(po, r);});Boolean isOk = cf.join();利用共享，往往能让我们快速实现功能，所谓是有福同享，但是代价就是有难要同当。在强调高可用的今天，大多数人更倾向于使用隔离的方案。
## 7. 线上问题定位的利器：线程栈 dump《17 \|ReadWriteLock：如何快速实现一个完备的缓存？》](https://time.geekbang.org/column/article/88909)和[《20\|并发容器：都有哪些"坑"需要我们填？》](https://time.geekbang.org/column/article/90201)的思考题，本质上都是定位线上并发问题，方案很简单，就是通过查看线程栈来定位问题。重点是查看线程状态，分析线程进入该状态的原因是否合理，你可以参考[《09\| Java 线程（上）：Java线程的生命周期》](https://time.geekbang.org/column/article/86366)来加深理解。为了便于分析定位线程问题，你需要给线程赋予一个有意义的名字，对于线程池可以通过自定义ThreadFactory 来给线程池中的线程赋予有意义的名字，也可以在执行 run()方法时通过`Thread.currentThread().setName();`来给线程赋予一个更贴近业务的名字。
## 总结Java并发工具类到今天为止，就告一段落了，由于篇幅原因，不能每个工具类都详细介绍。Java并发工具类内容繁杂，熟练使用是需要一个过程的，而且需要多加实践。希望你学完这个模块之后，遇到并发问题时最起码能知道用哪些工具可以解决。至于工具使用的细节和最佳实践，我总结的也只是我认为重要的。由于每个人的思维方式和编码习惯不同，也许我认为不重要的，恰恰是你的短板，所以这部分内容更多地还是需要你去实践，在实践中养成良好的编码习惯，不断纠正错误的思维方式。欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/f2ae29f2a91a0266d9d86db774df526d.png){savepage-src="https://static001.geekbang.org/resource/image/cf/aa/cf393cd748a4f0e6451807c4b61843aa.jpg"}
# 28 \| Immutability模式：如何利用不变性解决并发问题？我们曾经说过，"多个线程同时读写同一共享变量存在并发问题"，这里的必要条件之一是读写，如果只有读，而没有写，是没有并发问题的。解决并发问题，其实最简单的办法就是让共享变量只有读操作，而没有写操作。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：**不变性（Immutability）模式**。所谓**不变性，简单来讲，就是对象一旦被创建之后，状态就不再发生变化**。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。
## 快速实现具备不可变性的类实现一个具备不可变性的类，还是挺简单的。**将一个类所有的属性都设置成final的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了**。更严格的做法是**这个类本身也是final的**，也就是不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性，所以推荐你在实际工作中，使用这种更严格的做法。Java SDK里很多类都具备不可变性，只是由于它们的使用太简单，最后反而被忽略了。例如经常用到的String 和 Long、Integer、Double等基础类型的包装类都具备不可变性，这些对象的线程安全性都是靠不可变性来保证的。如果你仔细翻看这些类的声明、属性和方法，你会发现它们都严格遵守不可变类的三点要求：**类和属性都是final 的，所有方法均是只读的**。``{=html}看到这里你可能会疑惑，Java 的 String方法也有类似字符替换操作，怎么能说所有方法都是只读的呢？我们结合 String的源代码来解释一下这个问题，下面的示例代码源自 Java 1.8SDK，我略做了修改，仅保留了关键属性 value\[\] 和 replace()方法，你会发现：String 这个类以及它的属性 value\[\] 都是 final 的；而replace() 方法的实现，就的确没有修改value\[\]，而是将替换后的字符串作为返回值返回了。    public final class String {  private final char value[];  // 字符替换  String replace(char oldChar,       char newChar) {    // 无需替换，直接返回 this      if (oldChar == newChar){      return this;    }     int len = value.length;    int i = -1;    /* avoid getfield opcode */    char[] val = value;     // 定位到需要替换的字符位置    while (++i = len) {      return this;    }     // 创建一个 buf[]，这是关键    // 用来保存替换后的字符串    char buf[] = new char[len];    for (int j = 0; j = -128 && l     rf = new AtomicReference<>(      new WMRange(0,0)    );  // 设置库存上限  void setUpper(int v){    while(true){      WMRange or = rf.get();      // 检查参数合法性      if(v `{=html}我第一次接触 Copy-on-Write 其实就是在操作系统领域。类 Unix的操作系统中创建进程的 API 是 fork()，传统的 fork()函数会创建父进程的一个完整副本，例如父进程的地址空间现在用到了 1G的内存，那么 fork() 子进程的时候要复制父进程整个进程的地址空间（占有 1G内存）给子进程，这个过程是很耗时的。而 Linux 中的 fork()函数就聪明得多了，fork()子进程的时候，并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间；只用在父进程或者子进程需要写入的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。本质上来讲，父子进程的地址空间以及数据都是要隔离的，使用 Copy-on-Write更多地体现的是一种**延时策略，只有在真正需要复制的时候才复制，而不是提前复制好**，同时Copy-on-Write 还支持按需复制，所以 Copy-on-Write在操作系统领域是能够提升性能的。相比较而言，Java 提供的 Copy-on-Write容器，由于在修改的同时会复制整个容器，所以在提升读操作性能的同时，是以内存复制为代价的。这里你会发现，同样是应用Copy-on-Write，不同的场景，对性能的影响是不同的。在操作系统领域，除了创建进程用到了Copy-on-Write，很多文件系统也同样用到了，例如 Btrfs (B-Tree FileSystem)、aufs（advanced multi-layered unification filesystem）等。除了上面我们说的 Java 领域、操作系统领域，很多其他领域也都能看到Copy-on-Write 的身影：Docker 容器镜像的设计是Copy-on-Write，甚至分布式源码管理系统 Git 背后的设计思想都有Copy-on-Write......不过，**Copy-on-Write最大的应用领域还是在函数式编程领域**。函数式编程的基础是不可变性（Immutability），所以函数式编程里面所有的修改操作都需要Copy-on-Write来解决。你或许会有疑问，"所有数据的修改都需要复制一份，性能是不是会成为瓶颈呢？"你的担忧是有道理的，之所以函数式编程早年间没有兴起，性能绝对拖了后腿。但是随着硬件性能的提升，性能问题已经慢慢变得可以接受了。而且，Copy-on-Write也远不像 Java 里的 CopyOnWriteArrayList那样笨：整个数组都复制一遍。Copy-on-Write也是可以按需复制的，如果你感兴趣可以参考[Purely Functional DataStructures]{.orange}这本书，里面描述了各种具备不变性的数据结构的实现。CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个 Copy-on-Write容器在修改的时候会复制整个数组，所以如果容器经常被修改或者这个数组本身就非常大的时候，是不建议使用的。反之，如果是修改非常少、数组数量也不大，并且对读性能要求苛刻的场景，使用Copy-on-Write 容器效果就非常好了。下面我们结合一个真实的案例来讲解一下。
## 一个真实案例我曾经写过一个 RPC 框架，有点类似Dubbo，服务提供方是多实例分布式部署的，所以服务的客户端在调用 RPC的时候，会选定一个服务实例来调用，这个选定的过程本质上就是在做负载均衡，而做负载均衡的前提是客户端要有全部的路由信息。例如在下图中，A服务的提供方有 3 个实例，分别是 192.168.1.1、192.168.1.2 和192.168.1.3，客户端在调用目标服务 A前，首先需要做的是负载均衡，也就是从这 3 个实例中选出 1 个来，然后再通过RPC 把请求发送选中的目标实例。![](Images/42e5276fe9654cb99311a124876f71e6.png){savepage-src="https://static001.geekbang.org/resource/image/71/1e/713c0fb87154ee6fbb58f71b274b661e.png"}```{=html}```RPC 路由关系图]{.reference}```{=html}```RPC框架的一个核心任务就是维护服务的路由关系，我们可以把服务的路由关系简化成下图所示的路由表。当服务提供方上线或者下线的时候，就需要更新客户端的这张路由表。![](Images/d1e9b9471432d3ae4bc1e2909aa3fb47.png){savepage-src="https://static001.geekbang.org/resource/image/dc/60/dca6c365d689f2316ca34de613b3fd60.png"}我们首先来分析一下如何用程序来实现。每次 RPC调用都需要通过负载均衡器来计算目标服务的 IP和端口号，而负载均衡器需要通过路由表获取接口的所有路由信息，也就是说，每次RPC调用都需要访问路由表，所以访问路由表这个操作的性能要求是很高的。不过路由表对数据的一致性要求并不高，一个服务提供方从上线到反馈到客户端的路由表里，即便有5 秒钟，很多时候也都是能接受的（5 秒钟，对于以纳秒作为时钟周期的 CPU来说，那何止是一万年，所以路由表对一致性的要求并不高）。而且路由表是典型的读多写少类问题，写操作的量相比于读操作，可谓是沧海一粟，少得可怜。通过以上分析，你会发现一些关键词：对读的性能要求很高，读多写少，弱一致性。它们综合在一起，你会想到什么呢？CopyOnWriteArrayList和 CopyOnWriteArraySet天生就适用这种场景啊。所以下面的示例代码中，RouteTable这个类内部我们通过`ConcurrentHashMap>`这个数据结构来描述路由表，ConcurrentHashMap的 Key 是接口名，Value 是路由集合，这个路由集合我们用是CopyOnWriteArraySet。下面我们再来思考 Router该如何设计，服务提供方的每一次上线、下线都会更新路由信息，这时候你有两种选择。一种是通过更新Router的一个状态位来标识，如果这样做，那么所有访问该状态位的地方都需要同步访问，这样很影响性能。另外一种就是采用Immutability 模式，每次上线、下线都创建新的 Router 对象或者删除对应的Router 对象。由于上线、下线的频率很低，所以后者是最好的选择。Router 的实现代码如下所示，是一种典型 Immutability模式的实现，需要你注意的是我们重写了 equals 方法，这样CopyOnWriteArraySet 的 add() 和 remove() 方法才能正常工作。    // 路由信息public final class Router{  private final String  ip;  private final Integer port;  private final String  iface;  // 构造函数  public Router(String ip,       Integer port, String iface){    this.ip = ip;    this.port = port;    this.iface = iface;  }  // 重写 equals 方法  public boolean equals(Object obj){    if (obj instanceof Router) {      Router r = (Router)obj;      return iface.equals(r.iface) &&             ip.equals(r.ip) &&             port.equals(r.port);    }    return false;  }  public int hashCode() {    // 省略 hashCode 相关代码  }}// 路由表信息public class RouterTable {  //Key: 接口名  //Value: 路由集合  ConcurrentHashMap>     rt = new ConcurrentHashMap<>();  // 根据接口名获取路由表  public Set get(String iface){    return rt.get(iface);  }  // 删除路由  public void remove(Router router) {    Set set=rt.get(router.iface);    if (set != null) {      set.remove(router);    }  }  // 增加路由  public void add(Router router) {    Set set = rt.computeIfAbsent(      route.iface, r ->         new CopyOnWriteArraySet<>());    set.add(router);  }}
## 总结目前 Copy-on-Write 在 Java并发编程领域知名度不是很高，很多人都在无意中把它忽视了，但其实Copy-on-Write 才是最简单的并发解决方案。它是如此简单，以至于 Java中的基本数据类型 String、Integer、Long 等都是基于 Copy-on-Write方案实现的。Copy-on-Write是一项非常通用的技术方案，在很多领域都有着广泛的应用。不过，它也有缺点的，那就是消耗内存，每次修改都需要复制一个新的对象出来，好在随着自动垃圾回收（GC）算法的成熟以及硬件的发展，这种内存消耗已经渐渐可以接受了。所以在实际工作中，如果写操作非常少，那你就可以尝试用一下Copy-on-Write，效果还是不错的。