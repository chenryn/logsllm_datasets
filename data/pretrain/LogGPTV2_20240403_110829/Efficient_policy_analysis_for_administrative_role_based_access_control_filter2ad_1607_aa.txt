title:Efficient policy analysis for administrative role based access control
author:Scott D. Stoller and
Ping Yang and
C. R. Ramakrishnan and
Mikhail I. Gofman
Efﬁcient Policy Analysis for Administrative Role Based
Access Control∗
Scott D. Stoller, Ping Yang†, C.R. Ramakrishnan, and Mikhail I. Gofman†
Computer Science Dept.
Stony Brook University
{stoller,cram}@cs.stonybrook.edu
ABSTRACT
Administrative RBAC (ARBAC) policies specify how Role-Based
Access Control (RBAC) policies may be changed by each admin-
istrator. It is often difﬁcult to fully understand the effect of an AR-
BAC policy by simple inspection, because sequences of changes by
different administrators may interact in unexpected ways. ARBAC
policy analysis algorithms can help by answering questions, such
as user-role reachability, which asks whether a given user can be
assigned to given roles by given administrators. This problem is
intractable in general. This paper identiﬁes classes of policies of
practical interest, develops analysis algorithms for them, and ana-
lyzes their parameterized complexity, showing that the algorithms
may have high complexity with respect to some parameter k char-
acterizing the hardness of the input (such that k is often small in
practice) but have polynomial complexity in terms of the overall
input size when the value of k is ﬁxed.
Categories and Subject Descriptors: K.6.5 [Management of Com-
puting and Information Systems]: Security; D.4.6 [Operating
Systems]: Security and Protection—Access Controls
General Terms: Security
1.
INTRODUCTION
Role Based Access Control (RBAC) is a widely used framework
for access control [26]. RBAC simpliﬁes access control by de-
composing the association of permissions with users into two re-
lations: the user-role assignment speciﬁes the roles of each user,
and the role-permission assignment speciﬁes the permissions asso-
ciated with each role. Inheritance relationships may also be speci-
ﬁed, in the form of a role hierarchy.
Administrative RBAC (ARBAC) policies specify how RBAC poli-
cies may be changed by each administrator. ARBAC policies are
important for security in organizations with multiple administra-
tors. Several ARBAC models have been proposed [25, 23, 5, 18].
In this paper, we focus on the classic ARBAC97 model [25], al-
∗This work was supported in part by NSF under grant CCR-
0205376 and by ONR under grants N00014-04-1-0722 and
N00014-07-1-0928.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’07, October 29–November 2, 2007, Alexandria, Virginia, USA.
Copyright 2007 ACM 978-1-59593-703-2/07/0010 ...$5.00.
†Dept. of Computer Science
Binghamton University
{pyang,mgofman1}@binghamton.edu
though many of our results can be adapted to other ARBAC mod-
els, as discussed in Section 2.2. ARBAC97 decomposes the ad-
ministration problem into three simpler sub-problems, for control-
ling changes to the user-role assignment, role-permission assign-
ment, and role hierarchy. Administrative operations on the user-
role assignment include adding users to roles, and removing users
from roles. Permission to perform these administrative operations
is speciﬁed by the can_assign and can_revoke relations, respec-
tively. A can_assign rule has the form “administrators in role ra
can add users satisfying precondition c to role r”. The precondition
may contain positive preconditions (roles the user must already be
in) and negative preconditions (roles the user must not be in). For
example, assignment of the Dean role may require that the user is
in the Faculty role and not in the DepartmentChair role. In short, an
ARBAC policy deﬁnes a transition relation that describes allowed
(possible) changes to the RBAC policy.
Correct understanding of a system’s current RBAC policy and
the implications of its ARBAC policy are critical to assure system
security. Although ARBAC policies are speciﬁed using relatively
simple rule languages, it is often difﬁcult to understand the effect of
an ARBAC policy by simple inspection, largely because (without
help) people often fail to see the full effects of multiple-step (tran-
sitive) relations and their interactions. The transitive relations here
are the RBAC policy reachability relation (i.e., the transitive clo-
sure of the ARBAC policy’s transition relation) and the inheritance
relation (i.e., the role hierarchy). Policy analysis helps system de-
signers and administrators understand RBAC and ARBAC policies
by answering questions (queries) about them. For example, user-
role reachability analysis answers questions of the form: given an
initial RBAC policy state, an ARBAC policy, a set of administra-
tors, a target user, and a set of roles (called the “goal”), is it possible
for those administrators to modify the RBAC state so that the target
user is a member of those roles? Unfortunately, many policy anal-
ysis problems, including user-role reachability, are intractable even
under various restrictions on the ARBAC policy [20, 27]. Those
papers give polynomial algorithms for some special cases, but the
restrictions signiﬁcantly limit the practical applicability of the al-
gorithms.
Can practical algorithms be devised to analyze useful classes of
ARBAC policies, despite the intractability results? We tackle this
question by identifying classes of policies of practical interest, de-
veloping analysis algorithms for them, and analyzing their param-
eterized complexity [6]. The key idea of parameterized complexity
is to identify an aspect of the input that make the problem compu-
tationally difﬁcult, introduce a parameter k to measure that aspect
of the input, and develop a solution algorithm that may have high
complexity in terms of k, but has polynomial complexity in terms
of the overall input size when the value of k is ﬁxed. If such an al-
445gorithm exists, the problem is said to be ﬁxed parameter tractable
(FPT) with respect to k. Even if the problem is NP-hard or worse,
the FPT algorithm is efﬁcient for problem instances with relatively
small values of k.
Main Contributions. We consider a variant of ARBAC97 called
miniARBAC.
1. We give a general algorithm for user-role reachability analy-
sis of general miniARBAC policies (see Section 3), and show
that it is ﬁxed-parameter tractable with respect to the number
of mixed roles (roles that appear both negatively and posi-
tively in the policy). The algorithm uses forward search op-
timized using a reduction that exploits left-commutativity of
transitions. We describe how to slice a policy with respect to
a goal, to help avoid exploration of irrelevant states.
2. We give an efﬁcient backward-search algorithm for user-role
reachability analysis for miniARBAC policies with at most
one positive precondition per rule. The algorithm is ﬁxed-
parameter tractable with respect to the number of irrevocable
roles and has a similar tractability property with respect to
the size of the goal (see Section 4). We also present a partial-
order reduction to optimize the backward search.
3. The above algorithms rely on an aspect of ARBAC97 that
we call separate administration, which requires that admin-
istrative roles and regular roles are disjoint. Prior work on
ARBAC policy analysis [29, 20, 27] generally makes this as-
sumption, but it is unrealistic in many cases. We lift this re-
striction and explore two approaches to policy analysis in this
more general setting, by identifying conditions under which
the general problem can be reduced to policy analysis with
separate administration, and by extending our forward anal-
ysis algorithm to handle the general problem (see Section 5).
4. We describe two case studies: ARBAC policies for a univer-
sity and a health-care institution (see Section 7). We observe
several structural properties of them, and relate them to the
assumptions and complexity parameters of our algorithms.
5. We measure the performance of our analysis algorithms on
families of synthetic (randomly generated) policies, in order
to validate our parameterized complexity results, determine
whether the worst-case complexity manifests itself, and com-
pare the performance of the forward and backward analysis
algorithms when both apply (see Section 8).
6. We also consider other analysis problems, including role con-
tainment (is every member of role r1 also a member of a role
r2 in all reachable policy states?) [20] and weakest precon-
ditions (what are minimal sets of initial roles for a user, in
order for that user to get added to roles in the goal?) (see
Section 6).
2. PRELIMINARIES
2.1 Role Based Access Control (RBAC)
The central notion of RBAC is that users are assigned to appro-
priate roles, and roles are assigned appropriate permissions. In this
paper, we study policy analysis for models of RBAC based on [1].
Following Sasturkar et al. [27], we adopt a simpliﬁed model, called
miniRBAC, that does not support sessions, because the policy anal-
ysis queries we consider are independent of sessions.
miniRBAC. A miniRBAC policy γ is a tuple (cid:104)U, R, P, UA, PA(cid:105)
where
• U, R and P are ﬁnite sets of users, roles, and permissions,
respectively. A permission represents authorization to invoke
a particular operation on a particular resource.
• UA ⊆ U × R is the user-role assignment relation. (cid:104)u, r(cid:105) ∈
UA means that user u is a member of role r.
• PA ⊆ P × R is the permission-role assignment relation.
(cid:104)p, r(cid:105) ∈ PA means that members of role r are granted the
permission p.
The miniHRBAC model based on Hierarchical RBAC [1] ex-
tends the miniRBAC model with role hierarchies, which are a nat-
ural means for structuring roles to reﬂect an organization’s lines of
authority and responsibility.
miniHRBAC. A miniHRBAC policy γh is a tuple (cid:104)U, R, P, UA,
PA,(cid:23)(cid:105) where U, R, P , UA and PA are as in miniRBAC, and
(cid:23) ⊆ R × R is a partial order on the set R of roles.
r1 (cid:23) r2 means r1 is senior to r2, i.e., every member of r1 is
also a member of r2, and every permission assigned to r2 is also
available to members of r1. Thus, r2 inherits all the users of r1 and
r1 inherits all the permissions of r2. A user u is an explicit member
of a role r if (cid:104)u, r(cid:105) ∈ UA. A user u is an implicit member of a role
r if (cid:104)u, r(cid:48)(cid:105) ∈ UA for some r(cid:48) such that r(cid:48) (cid:23) r and r(cid:48) (cid:54)= r.
2.2 Administrative Role Based Access Control
(ARBAC)
ARBAC97 is a classic model for decentralized administration
of RBAC policies [25]. ARBAC97 has three components:
(1)
user-role administration (URA), (2) permission-role administration
(PRA), and (3) role-role administration (RRA) for administration
of the role hierarchy. We consider a modiﬁed version of ARBAC97
called miniARBAC similar to [27]. miniARBAC includes only the
URA component; the permission assignment and role hierarchy
are considered ﬁxed. Extending our analysis techniques to han-
dle changes to them is discussed at the end of this section. Since
we do not consider changes to the role hierarchy, we adopt a sim-
ple ARBAC model without authority ranges [25], scopes [17, 5],
or administrative domains [18]; policies using those features can
be expressed without them when the role hierarchy is ﬁxed.
The URA policy controls changes to the user-role assignment
UA. Permission to assign users to roles is speciﬁed by the relation
can_assign ⊆ R × C × R, where C is the set of all preconditions
(called prerequisite conditions in [25]) over R. The precondition
is a conjunction of literals, where each literal is either r or ¬r for
some role r in R. Given a miniRBAC policy γ and a user u, u
satisﬁes a precondition ∧ili, denoted u |=γ ∧ili, iff for all i, ei-
ther li is a role r and u is a member of r in γ, or li is a negated
role ¬r and u is not a member of r in γ. A UserAssign(ra, u, r)
action speciﬁes that an administrator who is a member of the ad-
ministrative role ra adds user u to role r. This action is enabled in
state γ = (cid:104)U, P, R, UA, PA(cid:105) iff there exists a precondition c such
that (cid:104)ra, c, r(cid:105) ∈ can_assign and u |=γ c. Execution of this action
transforms γ to the state γ(cid:48) = (cid:104)U, P, R, UA ∪ {(cid:104)u, r(cid:105)}, PA(cid:105).
Permission to revoke users from roles is speciﬁed by the rela-
tion can_revoke ⊆ R × R. This is analogous to can_assign,
except that it does not allow preconditions, because there is little
evidence that preconditions for revocation are useful [25]. The ac-
tion UserRevoke(ra, u, r) is deﬁned similarly to UserAssign.
miniARBAC policy. A miniARBAC policy is represented as ψ =
(cid:104)can_assign, can_revoke(cid:105). We often refer to tuples in these two
relations as rules. The role r to which users or permissions are
being assigned or removed (i.e., the third component of the tuple)
is called the target of the rule. A miniARBAC policy speciﬁes
a transition relation between miniRBAC (or miniHRBAC) poli-
cies, which we often refer to as states. A transition is denoted by
γ a→ψ γ(cid:48), where a is one of the four administrative actions deﬁned
above. When we do not care about the action a, we omit it from
the transition, and when the miniARBAC policy ψ is clear from
context, we omit it from the transition.
SMER Constraints. A Static Mutually Exclusive Roles (SMER)
constraint is an unordered pair of roles (cid:104)r1, r2(cid:105) whose member-
ships must be disjoint. SMER constraints help enforce separation
of duty. We treat SMER constraints as an abbreviation for negative
preconditions that enforce this disjointness. Speciﬁcally, a SMER
constraint (cid:104)r1, r2(cid:105) is an abbreviation for conjoining ¬r1 to the pre-
condition of each can_assign tuple with target r2, and vice versa.
Separate Administration. A role r is an administrative role if
it has an administrative permission, i.e., there is a can_assign tu-
ple with r in the ﬁrst component. A role r is a regular role if it
has a regular permission, i.e., there is a PA tuple with r in the ﬁrst
component. Our framework, like SARBAC [5], UARBAC [18],
and Oracle, allows a role to be both a regular role and an admin-
istrative role. This ﬂexibility allows many policies to be expressed
more naturally. For example, in a university, a department chair
has both regular permissions (e.g., authorize expenses from the de-
partment’s accounts) and administrative permissions (e.g., appoint
faculty to committees).
Earlier work on ARBAC, such as ARBAC97 and ARBAC02 [25,
23], requires that (1) regular roles and administrative roles are sepa-
rate (i.e., no role is in both categories), and (2) in every can_assign
tuple, the ﬁrst component is an administrative role, the condition
mentions only regular roles, and the target is a regular role. We
call this the separate administration restriction. Work on ARBAC
policy analysis [29, 27, 20] generally adopts this restriction, with
the exception of analysis for the AATU model in [20].1 This helps
simplify a difﬁcult problem, enabling steps towards more general
solutions. The AATU model in [20] does not adopt this restric-
tion, but adopts two other big restrictions instead (no revocation;
no negative preconditions or SMER constraints).
The analysis algorithms in Sections 3 and 4 take advantage of the
separate administration restriction. Section 5 tackles policy analy-
sis without this restriction.
Other ARBAC Frameworks. Our focus on ARBAC97-like user-
role administration model is not a fundamental limitation of our
work. The proposals for user-role administration, permission-role
administration, and role-hierarchy administration in [25, 23, 17, 5,
18] differ from each other in important ways, but the aspects most
relevant to our algorithms—primarily the form of preconditions
of administrative operations—are generally not more complicated
than in the URA policies we analyze, so the ideas underlying our
algorithms can be adapted to analyze them. Handling RHA’s con-
ditions for scope preservation [5] would require some extensions.
UARBACP [18] is a schematic framework that allows arbitrary