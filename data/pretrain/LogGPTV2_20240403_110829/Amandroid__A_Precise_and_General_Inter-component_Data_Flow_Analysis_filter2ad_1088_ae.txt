context-sensitive points-to information (including that for
string objects) already computed in the IDFG, without the
need for a separate data ﬂow analysis just for ICC. Aman-
droid also uses the ICC call parameter information to link
ICC call sites to call targets, resulting in an IDFG that in-
cludes data ﬂow paths both within and across components.
Lu et al. [23] uses a static-analysis scheme called CHEX
to detect component hijacking problem in Android, which is
reduced to ﬁnding information ﬂows. CHEX ﬁrst constructs
app-splits, each of which is a code segment reachable from
an entry point. It then computes the data-ﬂow summary for
each split using Wala [16]. The split summaries are linked
in all permutations that do not violate the Android sys-
tem call sequences and could result in transitive information
ﬂow. Amandroid computes information ﬂow in a diﬀerent
way – through the usage of an environment method for each
component that calls the relevant callbacks in the right or-
der (per Android system speciﬁcation), and by building the
IDFG and DDG for the complete app. CHEX does not have
the provision to track data ﬂow through the ICC channel,
which Amandroid does.
Chin et al. [8] ﬁrst systematically studied the attack sur-
face related to ICC. In particular, they identiﬁed problems
such as unauthorized intent receipt and intent spooﬁng. They
also developed a static analysis tool which can raise warn-
ings for the above problems in an over-conservative manner.
ComDroid performs ﬂow-sensitive, intraprocedural static anal-
ysis, and the paper states that there is a limited interproce-
dural analysis that “follows method invocations to a depth of
one method call.” Amandroid performs a full-ﬂedged inter-
procedural data-ﬂow analysis in a ﬂow- and context-sensitive
way, and also tracks the data ﬂows over the ICC channels.
While we would like to conduct comparison study between
ComDroid and Amandroid, the link to the ComDroid tool
(http://www.comdroid.org) is not working. We contacted
the authors for obtaining a copy of the tool and dataset used
for evaluation, but have yet to receive the information.
There has been a large body of work reporting Android
app security issues [36, 37], some of which use static analysis
techniques [11, 14, 18, 19]. Those works focus on ﬁnding spe-
ciﬁc security problems, and the static analyses used do not
seem to address some key issues such as the inter-component
nature of Android app’s execution and the precise modeling
of Android’s callback sequences. In contrast, Amandroid is
a precise and general inter-component static analysis frame-
work which can address a large range of security issues in
Android apps.
Multiple prior works [9, 26, 35] investigated the root se-
curity problems in the Android system and proposed aug-
mented infrastructures to enforce the given security policy.
Recently, SEAndroid [30] has been proposed which enforces
Mandatory Access Control (MAC) both in the kernel layer
and in the middleware. This system provides a better mech-
anism for sand-boxing the apps. However, MAC will not
stop the security problems which happen within an app or
through the legitimate ICC channels. In this paper, we as-
sume the sand-boxing (and isolation) of apps by the Android
system is not compromised; thus, our approach is comple-
mentary to those prior works.
TaintDroid [12] is a dynamic (runtime) taint-tracking and
analysis system to ﬁnd potential misuse of the user’s pri-
vate information. All dynamic analyses are subject to eva-
sion attacks. For example, researchers have shown [27] that
Google’s Bouncer [3] can be ﬁngerprinted and hence evaded
by a well-crafted app. On the other hand, static analysis
investigates the code of the app (along with the app’s man-
ifest, etc.), which determines the runtime behaviors of the
app; this makes it attractive for security vetting. Recently
Sounthiraraj et al. [31] showed that static and dynamic anal-
ysis can be combined to achieve more eﬀective detection/-
conﬁrmation of security problems. Our approach provides a
precise and general static analysis framework that can com-
plement dynamic analyses.
7. CONCLUSION
We presented Amandroid – a general static analysis frame-
work for security analysis of Android applications. Aman-
droid can precisely track the control and data ﬂow of an app
across multiple components, and can compute an abstrac-
tion of the app’s behavior in the forms of an inter-component
data-ﬂow graph and data dependence graph. As a general
framework, Amandroid can be easily extended to achieve
a number of specialized security analyses. Our experiment
results showed that Amandroid scales well and can be read-
ily applied to eﬀectively address those specialized security
problems, and out-performs existing static analysis tools for
Android apps.
Acknowledgment
We express our gratitude to Eric Bodden and Steven Arzt for
helping us understand the FlowDroid work, to Patrick Mc-
Daniel and Damien Octeau for sharing with us the dataset
used in Epicc, and helping us better understand the work,
and to Marc Eisenbarth and Arbor Networks for sharing
with us the Android malware samples. We also thank
Gang Tan who provided valuable feedback for our wrok.
Venkatesh Prasad Ranganath contributed many ideas in the
discussions we had together. This work was partially sup-
ported by the U.S. National Science Foundation under grant
no. 0644288, 0954138 and 1018703, and the U.S. Air Force
Oﬃce of Scientiﬁc Research under award no. FA9550-09-1-
0138. Any opinions, ﬁndings and conclusions or recommen-
dations expressed in this material are those of the authors
and do not necessarily reﬂect the views of the above agen-
cies.
8. REFERENCES
[1] Android documentation: Activity. http://developer.
android.com/reference/android/app/Activity.html.
[2] Android documentation: Intent and Intent Filter.
http://developer.android.com/guide/components/intents-
ﬁlters.html.
[3] Google Bouncer. http://googlemobile.blogspot.com
/2012/02/android-and-security.html.
[4] WALA documentation: CallGraph. http://wala.
sourceforge.net/wiki/index.php/UserGuide:CallGraph.
[5] A. W. Appel. Modern Compiler Implementation in
Java. Cambridge University Press, 1998.
[6] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel,
J. Klein, Y. l. Traon, D. Octeau, and P. McDaniel.
FlowDroid: Precise context, ﬂow, ﬁeld,
object-sensitive and lifecycle-aware taint analysis for
Android apps. In Proceedings of the ACM PLDI, 2014.
[7] K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie.
PScout: Analyzing the Android permission
speciﬁcation. In Proceedings of the ACM CCS, 2012.
[8] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner.
Analyzing inter-application communication in
Android. In Proceedings of the ACM Mobisys, 2011.
hijacking vulnerabilities. In Proceedings of the ACM
CCS, 2012.
[24] F. Nielson, H. R. Nielson, and C. Hankin. Principles
[9] M. Conti, B. Crispo, E. Fernandes, and
of program analysis. Springer, 1999.
Y. Zhauniarovich. CRePE: A system for enforcing
ﬁne-grained context-related policies on Android.
Information Forensics and Security, IEEE
Transactions on, 7(5):1426–1438, 2012.
[10] M. B. Dwyer, J. Hatcliﬀ, M. Hoosier, V. Ranganath,
Robby, and T. Wallentine. Evaluating the eﬀectiveness
of slicing for model reduction of concurrent
object-oriented programs. In Proceedings of the
TACAS, 2006.
[11] M. Egele, D. Brumley, Y. Fratantonio, and
C. Kruegel. An empirical study of cryptographic
misuse in Android applications. In Proceedings of the
ACM CCS, 2013.
[12] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. Sheth. TaintDroid: An
information-ﬂow tracking system for realtime privacy
monitoring on smartphones. In Proceedings of the
USENIX OSDI, 2010.
[13] ENISA. Smartphone secure development guidelines.
http://www.enisa.europa.eu/activities/Resilience-and-
CIIP/critical-applications/smartphone-security-
1/smartphone-secure-development-guidelines,
2011.
[14] S. Fahl, M. Harbach, T. Muders, L. Baumg¨artner,
B. Freisleben, and M. Smith. Why Eve and Mallory
love Android: An analysis of Android SSL (in)
security. In Proceedings of the ACM CCS, 2012.
[15] A. P. Felt, M. Finifter, E. Chin, S. Hanna, and
D. Wagner. A survey of mobile malware in the wild.
In Proceedings of the ACM Workshop on Security and
Privacy in Smartphones and Mobile Devices, 2011.
[16] S. Fink and J. Dolby. WALA–The TJ Watson
Libraries for Analysis. http://wala.sf.net/, 2012.
[17] C. Fritz, S. Arzt, S. Rasthofer, E. Bodden, A. Bartel,
J. Klein, Y. le Traon, D. Octeau, and P. McDaniel.
Highly precise taint analysis for Android application.
Technical report, EC SPRIDE, 2013.
[18] C. Gibler, J. Crussell, J. Erickson, and H. Chen.
AndroidLeaks: Automatically detecting potential
privacy leaks in Android applications on a large scale.
In Proceedings of the International Conference on
Trust and Trustworthy Computing, 2012.
[19] M. Grace, Y. Zhou, Z. Wang, and X. Jiang. Systematic
detection of capability leaks in stock Android
smartphones. In Proceedings of the NDSS, 2012.
[20] M. C. Grace, W. Zhou, X. Jiang, and A. R. Sadeghi.
Unsafe exposure analysis of mobile in-app
advertisements. In Proceedings of the ACM Conference
on Security and Privacy in Wireless and Mobile
Networks, 2012.
[21] D. Hardt. The OAuth 2.0 authorization framework.
2012.
[22] O. Lhot´ak and L. Hendren. Scaling Java points-to
analysis using Spark. In Proceedings of the Compiler
Construction, 2003.
[23] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. CHEX:
Statically vetting Android apps for component
[25] D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden,
J. Klein, and Y. Le Traon. Eﬀective inter-component
communication mapping in Android with Epicc: An
essential step towards holistic security analysis. In
Proceedings of the USENIX Security Symposium, 2013.
[26] M. Ongtang, S. McLaughlin, W. Enck, and
P. McDaniel. Semantically rich application-centric
security in Android. Security and Communication
Networks, 5(6):658–673, 2012.
[27] N. J. Percoco and S. Schulte. Adventures in
Bouncerland. Black Hat USA, 2012.
[28] T. Reps, S. Horwitz, and M. Sagiv. Precise
interprocedural dataﬂow analysis via graph
reachability. In Proceedings of the ACM Symposium on
Principles of Programming Languages, 1995.
[29] M. Sagiv, T. Reps, and S. Horwitz. Precise
interprocedural dataﬂow analysis with applications to
constant propagation. Theoretical Computer Science,
167(1):131–170, 1996.
[30] S. Smalley and R. Craig. Security enhanced (SE)
Android: Bringing ﬂexible MAC to Android. In
Proceedings of the NDSS, 2013.
[31] D. Sounthiraraj, J. Sahs, G. Greenwood, Z. Lin, and
L. Khan. SMV-HUNTER: Large scale, automated
detection of SSL/TLS man-in-the-middle
vulnerabilities in Android apps. In Proceedings of the
NDSS, 2014.
[32] R. Vall´ee-Rai, E. Gagnon, L. Hendren, P. Lam,
P. Pominville, and V. Sundaresan. Optimizing Java
bytecode using the Soot framework: Is it feasible? In
Proceedings of the Compiler Construction, 2000.
[33] N. Viennot, E. Garcia, and J. Nieh. A measurement
study of Google Play. In Proceedings of the ACM
SIGMETRICS, 2014.
[34] R. Wang, L. Xing, X. Wang, and S. Chen.
Unauthorized origin crossing on mobile platforms:
Threats and mitigation. In Proceedings of the 2013
ACM CCS, 2013.
[35] R. Xu, H. Sa¨ıdi, and R. Anderson. Aurasium:
Practical policy enforcement for Android applications.
In Proceedings of the USENIX Security Symposium,
2012.
[36] Y. Zhou and X. Jiang. Dissecting Android malware:
Characterization and evolution. In Proceedings of the
IEEE SP, 2012.
[37] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, you,
get oﬀ of my market: Detecting malicious apps in
oﬃcial and alternative Android markets. In
Proceedings of the NDSS, 2012.
9. APPENDIX
The Basic IDFG Building Process: A static analyzer
simulates the program and keeps track of the fact sets, until
a ﬁxed point is reached. The convergence to a ﬁxed point
(analysis termination) is guaranteed as long as the ﬂow equa-
tions are monotone, and the number of facts is ﬁnite, which
hold for Amandroid’s analysis. For a given app, it contains
Figure 5: Building the IDFG for foo: The intra-procedural CFG of foo is extended to a callee, bar.
a ﬁnite number of object creation sites and variables/ﬁelds
(and as typically done, elements of an array are summarized
as one); moreover, we keep tracks of calling contexts up to
a ﬁnite number k.
Amandroid builds the IDFG by ﬂowing the points-to facts
from the program’s entry points. Here the program is the
IR of the app’s dex code augmented with the environment
methods as discussed in Section 3.2. Unlike Java applica-
tions, there is no “main” method in an Android app; ev-
ery component could be the starting point of an app. Our
component-based environment model captures the full life
cycle of a component and all of its possible execution paths,
including those due to interacting with other components.
Thus, if we assume one particular execution path starts from
component C, we can use C’s environment method EC as
the program’s entry point. To include all possible execu-
tion paths from all possible components, we do this for ev-
ery component in the app, yielding multiple IDFGs. For-
mally, let C be a component, the IDFG from C is denoted
IDFG(EC ) where EC is the environment method of C, and
is a tuple deﬁned as the following.
IDFG(EC ) ≡ ((N, E),{entry(n)| n ∈ N}) ,
where N and E are the nodes and edges of the inter-procedural
control ﬂow graph starting from EC (denoted ICFG(EC )).
entry(n) is the entry set of the statement associated with
node n. Each IDFG(EC ) captures the execution that starts
from component C, and may involve other components due
to ICC. Each statement node is annotated with the state-
ment entry set (the exit set is not shown for presentation
sake). In this example, Amandroid starts building the IDFG
from the entry point method foo with an empty fact set.
Amandroid then simulates the program statically based on
each statement’s semantics and transforms the fact sets along
the way based on the ﬂow equation (1).
At a control-ﬂow join point, the exit fact sets from all in-
coming edges are unioned (e.g., at L7 ); facts such as (cid:104)v2, 2(cid:105)
and (cid:104)v2, 5(cid:105) coming from the diﬀerent branches accumulate
in entry(7). Similarly, one can compute entry(8). At this
point, Amandroid needs to resolve the target for L8 ’s virtual
method invocation with static type A0. The ﬁrst argument
of the call instruction, v2, is the receiver object. Since we
now have calculated the possible points-to values of v2 —
instance 2 or instance 5, we can resolve the possible call tar-
gets precisely: A1.bar for instance 2 and A2.bar for instance
5 (because both A1 and A2 override A0.bar ). This shows
the advantage of doing a precise points-to analysis concur-
rently with ICFG building — not only can we have more
precise information on the call targets, but also it allows us
to ﬂow more accurate facts to the diﬀerent call targets. All
of these increase the precision and can potentially reduce
the number of false alarms in the analysis results.
As shown in Figure 5, a call statement contributes a pair of
CallNode and ReturnNode to the ICFG. The CallNode con-
nects to the callee’s EntryNode while the callee’s ExitNode
connects to the ReturnNode. In transferring facts between
the caller and the callee, the variable-facts need to be remapped
to the formal parameters of the callee (e.g., v2 in the caller
maps to v4 in the callee). This should be restored when the
control returns to the caller. Only heap-facts reachable from
the call parameters are passed to the callee. The unreachable
heap-facts as well as unrelated variable-facts are transferred
to the ReturnNode directly to improve eﬃciency. In the ex-
ample of L8 ’s method invocation, there is one variable-fact
(cid:104)v9, 6(cid:105) which is unrelated to both arguments v2 and v3. The
ﬂow of such fact (which is unrelated to any callee) is rep-
resented as a double-head arrow from the CallNode to the
ReturnNode. Similarly, there can be some facts at the callee
side that are unrelated to the caller (e.g., callee’s local vari-
ables and temporary objects), and we ﬁlter them out at the
callee’s ExitNode to improve eﬃciency.
Consider the dataﬂow analysis for A1.bar or A2.bar, which
is a callee for L8 ’s method invocation. Amandroid tracks the
entry of each statement of A1.bar (or A2.bar ). We observe
that entry(Return 8 ) contains heap-facts which show that
ﬁeld f2 of Instance 2 points to the String “abc”. This is the
eﬀect of L10. It is interesting to see that this is not true for
the same ﬁeld (i.e., f2 ) of Instance 5 because no assignment
like L10 happens inside A2.bar.
Now, we can get entry(9), and continue to process the
next call similarly. The process is similar to what we did
for L8, except that we have to handle the possibility of a
null receiver (because there is no fact associated with v2.f1
for (cid:104)v2, 5(cid:105)). For a virtual method statement, if the facts
show that the receiver variable maybe null , then we do not
process this particular instance; instead, we only propagate
the non-null receiver instances (if any) to the callee and ﬂag
the call site as a possible runtime error.