RBAC state, let r be a role in R and p be a role in P , and let (cid:195) denote the stan-
dard privilege inheritance, reported in Deﬁnition 3.2. We say that the extended
privilege inheritance r (cid:195)∗ p holds iﬀ
r (cid:195) p(cid:48) and p(cid:48) → p, for some p(cid:48) ∈ P .
The extended privilege inheritance relation is useful because it allows users, with
administrative privileges, to be implicitly authorized for weaker administrative
privileges. Thereby, it gives administrative users the possibility to perform
safer administrative operations than the ones originally allowed. We now give
a practical example of its usage.
Example 3.5 (Visiting Researcher) Charlie, the security administrator, gives
the staﬀ the privilege to add visiting researchers to the staﬀ role. There is also
a role below staﬀ called wiﬁ, with the privilege to use the wireless network. Alice
is a visiting researcher and Bob is a member of the staﬀ. Alice only needs access
to the wiﬁ network, so Bob would like Alice to use the wiﬁ role. Charlie (who
6
Figure 3: A practical example of the use of the extended inheritance relation.
just left) did not provide this privilege explicitly to the staﬀ. This scenario is
illustrated in Figure 3.
In the standard RBAC model, Bob can only assign Alice to the staﬀ role.
Given the fact that Alice only needs wiﬁ access, Bob urges Alice to apply the
principle of least privilege, and to activate only the wiﬁ role. However, Bob can
only hope that Alice does so. With the extended privilege inheritance relation
Bob can assign Alice to the wiﬁ role because of his privilege to add users to the
staﬀ role. In a way, instead of preaching the principle of least privilege to Alice,
Bob applies it for her.
3.2 Tractability
Now we address a practical issue. We prove that the extended privilege inher-
itance relation (Deﬁnition 3.4) is tractable. Since the full set P of privileges
is inﬁnite, this result is not immediate. For instance, a naive forward search
does not necessarily terminate (see below). The proof also indicates how a de-
cision algorithm, deciding which privileges are to be given to which roles, can
be implemented at an RBAC security monitor.
First notice that since RH and PA are ﬁnite sets, the standard privilege
inheritance (cid:195) is decidable. To show how to decide whether r (cid:195)∗ p, we ﬁrst
prove that there is an algorithm that can decide, whether p → q, for any p, q in
P .
Lemma 3.6 (Decidability of the Ordering Relation) Given an
RBAC state S, and two privileges p, q, it is decidable whether p → q.
Proof 1 The proof is by structural induction over q.
that for the three base cases p → q is decidable:
The base cases are when q is not of the form addPrivilege(., .). We show
• Either q is a user privilege from Q. In this case p → q holds only when
p = q (see rule (1) in Deﬁnition 3.4).
• Or q is of the form addUser(., .) in which case only rule (2) needs to be
checked, which has ﬁnite premises.
• Or q is of the form addEdge(., .), in which case the rules (2) and (3) of
Deﬁnition 3.3 need to be checked. Both have ﬁnite premises.
7
For the induction step, suppose that q is addPrivilege(r(cid:48), q(cid:48)), for some role r(cid:48)
and privilege q(cid:48). Now, p → q can only hold if either p is of the form addEdge(., .)
and the premises of rule (5) holds, or p is of the form addPrivilege(., .) and the
premises of rule (6) holds.
In both cases, the premises are decidable, either
because they are ﬁnite, or because the induction hypothesis is applicable (in
p(cid:48) → q(cid:48), q(cid:48) is structurally smaller than q, regardless of p(cid:48)).
Theorem 3.7 (Decidability of Extended Privilege Inheritance)
Given an RBAC state, a role r and a privilege p in P , there is an algorithm to
determine whether r (cid:195)∗ p.
Proof 2 The standard privilege inheritance (cid:195) is decidable, yielding a ﬁnite set
of privileges p(cid:48) inherited by r. Now for each privilege p(cid:48) we need to check whether
p(cid:48) → p. This was shown to be decidable in the previous lemma.
We now give an example of how the above described procedure can be used
in practice.
Example 3.8 Consider Example 3.5 again.
Can Bob assign Alice to the wiﬁ role? We have to check that the role staﬀ
inherits the privilege addUser(alice, wiﬁ). Using the ﬁrst part of Deﬁnition 3.4,
one ﬁnds that the staﬀ role has the privilege addUser(alice, staﬀ ). Now we
should decide whether
addUser(alice, staﬀ ) → addUser(alice, wiﬁ).
This follows trivially from the ﬁrst rule of Deﬁnition 3.3.
To give a more involved example, suppose that the system administrator
Charlie has the privilege addPrivilege(staﬀ , addUser(alice, staﬀ )). Can Charlie
also give the staﬀ role the privilege addUser(alice, wiﬁ)? We have to check
whether
addPrivilege(staﬀ , addUser(alice, staﬀ )) →
addPrivilege(staﬀ , addUser(alice, wiﬁ)).
This is indeed the case by using rule (6) ﬁrst, and then rule (2).
Now, for the sake of exposition, let us remove the edge between the staﬀ
and the wiﬁ role. Let us show how to determine that the previous relation
does not hold: Only rule (6) applies, in which case we must decide whether
addUser(alice, staﬀ ) → addUser(alice, wiﬁ). This is a base case of the induction
described in the proof of Lemma 3.6: Only rule (2) remains to be checked and
than we can conclude that it does not hold.
It could be useful to ﬁnd all the privileges p(cid:48) weaker than a given p. However,
in some cases the set of all privileges p(cid:48) weaker than a given privilege p, is inﬁnite.
For the interested reader, we give an example of this in the appendix.
8
4 Related Work
The problem of administration of an RBAC system was ﬁrst addressed by
Sandhu et al. [11]. Later, numerous articles have been published extending or
improving the administration model proposed there [2, 3, 4, 5, 10, 13, 14, 15].
We discuss some of them.
Barka et al. [2] distinguish between original and delegated user role assign-
ments. Delegations are modeled using special sets, and diﬀerent sets are used
for single step and double step delegations (which must remain disjoint). A
function is used to verify if membership to a role can be delegated. Privileges
can also be delegated, provided they are in the special set of delegatable privi-
leges belonging to the role. In their work, each level of delegation requires the
deﬁnition of tens of sets and functions, whereas in our model administrative
privileges, of an arbitrary complexity, are simply assigned to roles, just like the
ordinary privileges. The PDBM model [15] deﬁnes a cascaded delegation. This
form of delegation is also expressible in our grammar. In the PDBM model,
however, each delegation requires the addition of a separate role, whereas, in
our model the privileges for delegations are assigned to roles just as the ordinary
privileges. It is not required to add any additional roles.
A number of proposals deﬁne general constraints on the administrative priv-
ileges. For example, the constraint that a user must ﬁrst have a privilege, before
being allowed to delegate it to other users. Note that, as mentioned earlier, in
this paper no particular choice is made with respect to such constraints. Zhang
et al. [14] implement rule based constraints on delegations. They demonstrate
their model using a Prolog program. Basically, they analyze the properties of
a centralized RBAC system, focussing on so-called separation of duty policies.
Crampton [4] deﬁnes the concept of administrative scope. Basically a role r is
in the scope of a role r(cid:48) if there is no role above r(cid:48) that is not below r. They
show how administrative scope can be used to constrain delegations to evolve in
a natural progression in the role hierarchy. Bandman et al. [1] use a general con-
straint language to specify constraints on who can receive certain delegations. A
more complex issue (another type of constraint) is the transfer of delegations [3].
Here the delegator looses the right it is delegating. Such delegations may be
useful in practice, and we are interested to see how they can be implemented in
our model.
Role-based trust management systems [6, 7, 8, 12] and distributed certiﬁ-
cate systems, such as SDSI [9], are related lines of research. In these systems, a
number of agents exchange security statements. Speciﬁcally, agents may make
hierarchies similar to those in RBAC, simply by uttering certain security state-
ments. In such models it is often assumed that users are free to utter security
statements, while the focus is on wether to trust such statements (typically
by some trust calculation by the receiver). In the RBAC setting however this
assumption is very inappropriate. Statements changing the RBAC hierarchy
should not be uttered by users, unless they have the explicit privilege to do so.
Despite this diﬀerence, our result does apply also to role-based trust manage-
ment models. The extended privilege inheritance relation would then correspond
9
to the notion of reﬁnement of policies or trust statements.
5 Conclusion
With this work we make a contribution to the design of ﬂexible administration
models for RBAC. Flexible administration is important to cut the cost of main-
tenance and to enable the RBAC system to adapt to changing circumstances.
Concretely, our contribution is an extension of the standard RBAC privilege
inheritance relation. We deﬁned an ordering on administrative privileges, that
enabled us to extend the standard privilege inheritance relation in the natural
way. This means that if a user has a particular administrative privilege, then
she is also implicitly authorized for weaker administrative privileges. We showed
that this relation is tractable. Our extension can be seen as an application of
the principle of least privilege at the level of administration.
Flexibility of management is an important requisite when deploying access
control systems in practice. For example, discretionary access control systems
are widely used because they are so ﬂexible. RBAC on the other hand is less
ﬂexible, but it can be used to implement also mandatory security policy (for
instance like in the Bell LaPadula model). To allow for a more ﬂexible man-
agement, we extend the standard RBAC privilege inheritance. Basically, users
with administrative privileges can also use lesser administrative privileges. Our
extension can be seen as an application of the principle of least privilege to
administration.
Of course, the deﬁnitions of the RBAC state can be chosen such that the
extended and the standard inheritance relation yield the same result. In most
cases however this is cumbersome. For example, the dotted edge in Figure 3
could also be explicitly added as an administrative privilege for the staﬀ role.
However, when the edge between the staﬀ role and the wiﬁ role is removed,
then this makes no sense anymore. This kind of dependencies may complicate
changing the role-hierarchy. Such repetitive deﬁnitions are not needed, when
using the extended privilege inheritance.
Finally, a number of improvements and additions can be made. We do not
express privileges such as ∀r.addEdge(r(cid:48), r)), which may be useful in practice,
but we believe that special care is needed to deal with quantiﬁers. Finally, as
we do not make a particular choice regarding constraints on the administrative
privileges, it would be interesting to investigate how our results can be combined
with, for example, the work by Crampton and Loizou [4] or that of Bandmann
et al. [1].
Acknowledgements
Marnix Dekker was funded by TNO and SenterNovem through the Dutch IOP
Gencom project PAW. Jan Cederquist was funded by the Dutch NWO Account
10
project and partially, while at SQIG-IT IST TU Lisbon, supported by the Por-
tugese FEDER/FCT project QuantLog POCI/MAT/55796/2004.
References
[1] O. L. Bandmann, B. Sadighi Firozabadi, and M. Dam. Constrained del-
egation. In M. Abadi and S. M. Bellovin, editors, Proc. of the Symp. on
Security and Privacy (S&P), pages 131–140. IEEE Computer Society Press,
2002.
[2] E. Barka and R. S. Sandhu. Framework for role-based delegation models.
In J. Epstein, L. Notargiacomo, and R. Anderson, editors, Annual Com-
puter Security Applications Conference (ACSAC), pages 168–176. IEEE
Computer Society Press, 2000.
[3] J. Crampton and H. Khambhammettu. Delegation in role-based access
control. In D. Gollmann and A. Sabelfeld, editors, Proc. of the European
Symp. on Research in Computer Security (ESORICS), LNCS, pages 174–
191. Springer, Berlin, 2006.
[4] J. Crampton and G. Loizou. Administrative scope: A foundation for role-
based administrative models. Transactions on Information System Security
(TISSEC), 6(2):201–231, 2003.
[5] D. F. Ferraiolo, D. R. Kuhn, and R. Chandramouli. Role-based Access
Control. Computer Security Series. Artech House, 2003.
[6] T. Jim. SD3: A trust management system with certiﬁed evaluation. In
R. Needham and M. Abadi, editors, Proc. of the Symp. on Security and
Privacy (S&P), pages 106–115. IEEE Computer Society Press, 2001.
[7] N. Li, J. Mitchell, and W. Winsborough. Design of a role-based trust-
management framework. In M. Abadi and S. M. Bellovin, editors, Proc. of
the Symp. on Security and Privacy (S&P), pages 114–130. IEEE Computer
Society Press, 2002.
[8] N. Li, W. H. Winsborough, and J. C. Mitchell. Distributed credential chain
discovery in trust management: extended abstract. In P. Samarati, edi-
tor, Proc. of the Conf. on Computer and Communications Security (CCS),
pages 156–165. ACM Press, 2001.
[9] R. L. Rivest and B. Lampson. SDSI – A simple distributed security infras-
tructure. Presented at CRYPTO’96 Rump session, 1996.
[10] R. S. Sandhu, V. Bhamidipati, and Q. Munawer. The ARBAC97 model
for role-based administration of roles. Transactions on Information and
System Security (TISSEC), 2(1):105–135, 1999.
11
View publication stats
View publication stats
[11] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E. Youman. Role-based
access control models. IEEE Computer, 29(2):38–47, 1996.
[12] R. Tamassia, D. Yao, and W. H. Winsborough. Role-based cascaded dele-
gation. In T. Jaeger and E. Ferrari, editors, Proc. of the Symp. on Access
Control Models and Technologies (SACMAT), pages 146–155. ACM Press,
2004.
[13] J. Wainer and A. Kumar. A ﬁne-grained, controllable, user-to-user del-
egation method in RBAC.
In E. Ferrari and G. Ahn, editors, Proc. of
the Symp. on Access Control Models and Technologies (SACMAT), pages
59–66. ACM Press, 2005.
[14] L. Zhang, G. Ahn, and B. Chu. A rule-based framework for role-based del-
egation and revocation. Transactions on Information and System Security
(TISSEC), 6(3):404–441, 2003.
[15] X. Zhang, S. Oh, and R. S. Sandhu. PBDM: a ﬂexible delegation model
in RBAC. In D. Ferraiolo, editor, Proc. of the Symp. on Access Control
Models and Technologies (SACMAT), pages 149–157. ACM Press, 2003.
A Inﬁnitely many weaker privileges
Consider a state where (r2, addEdge(r1, r2)) ∈ PA. Suppose now we are inter-
ested in ﬁnding all the privileges weaker than addEdge(r1, r2). The ﬁrst weaker
privilege we discover by applying rule (5) in deﬁnition 3.3:
addPrivilege(r1, addEdge(r1, r2)).
Using this result in rule (6), we ﬁnd another weaker privilege,
addPrivilege(r1, addPrivilege(r1, addEdge(r1, r2))),
and we can use this again in rule (6), and so on.
Note that the outer nesting in the last term is in a sense redundant. Instead
of assigning the privilege addEdge(r1, r2) to r1, one assigns the privilege to do so,
to r1. This only requires the users in role r1 to perform another administrative
step: The extra nesting is useless. It seems that we can stop after n applications
of rule (6), where n is the length of the longest chain in RH , but we do not
make this observation more formal here.
12