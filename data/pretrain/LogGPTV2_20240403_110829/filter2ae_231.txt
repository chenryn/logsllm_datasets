# 从一题看C++逆向与机制
##### 译文声明
本文为翻译文章，译文仅供参考。具体内容表达及含义以原文为准。

最近CTF比赛中出现了许多C++逆向题目。本文将以“看雪CTF”中的一道题——“半加器”为例，探讨C++全局类对象的机制，并借此机会进行学习和练习。

## 定位main函数

首先使用`PEID`检查程序是否有壳，发现该程序是由VC++系列编译器编写的，且未经过加壳处理。接着运行程序，发现有用户交互提示`Please Input:`。在IDA Pro中搜索该字符串，并通过交叉引用定位到关键代码。

### 另一种方法

如果程序没有提供用户交互字符串，如何定位`main`函数？特别是在本题中，很多函数信息已被移除的情况下。

在IDA Pro中，可以从`start`函数开始连续跟进，最终会到达一大段代码。此时仍然不清楚关键代码的位置。为了进一步分析，可以使用Visual Studio编写一个简单的x86程序，并用IDA Pro打开。同样地，在IDA Pro中跟进到相应位置，会发现注释`Code`。继续跟进`sub_413C10`，找到`main`函数。

对于本题，`v4`相当于`Code`。跟进`v4`后，可以找到关键函数`sub_4A2890`，即`main`函数。

## 输入部分

回到`Please input:`这一行。在调试过程中，即使按下P键也会报出堆栈溢出错误（sp错误）。简单修复`alt+k`后，即可愉快地按F5继续调试。

> 尝试将`retn`指令直接替换为`nop`也可以继续调试，但在后续调试中可能会出现错误。

`if (v2 = 10)`这行代码看起来是对输入长度的限制。通过动态调试验证，确实是对输入字符串长度的检查（`strlen`的结果）。

接下来，从`sub_4917A4`继续跟进。注意第二个参数是30，正好是上面提到的最大字符串长度。一直跟踪到`sub_54B010`，会发现一些看似复杂的代码。结合动态调试，可以发现这些代码实际上是`strcpy`系列函数的变体。

也就是说，函数`sub_4917A4(dword_5FD088, 30, (int)&unk_5FD068);`用于复制输入的字符串。而`sub_490507`则对复制后的字符串每个字符都进行了异或0x1F的操作。

唯一明确的要求是第八个字符必须是`A`，之后会被替换为`#`。到此为止，思路有些中断，下一步需要验证输入。

## 验证部分

再次利用IDA Pro的交叉引用功能，查看输入字符串的所有引用。然后查找复制后的字符串，发现又有对字符串的异或操作。`pause`字符串也提示我们，flag验证可能就在附近，因为`system("pause")`常用来防止输入后黑框一闪而过。

猜测`sub_490CD7`可能是普通的`strcmp`函数。在`if(!xxx)`处设置断点，用IDA Pro进行调试。获取到`a1`的地址后，在内存区可以看到字符串。

类似于gdb调试，将返回值`eax`设置为0，程序输出`ok`，表明已经找到了验证逻辑。

解题时，依次将字符串`urj}pux`进行处理。尝试使用angr来自动化解决，但遇到了一些问题，未能成功。

## 一些思考

至此，题目已基本完成，但作者是如何实现的呢？在`main`函数中并未找到验证部分。参考其他人的解析，发现在类的**析构函数**中实现了验证，且该类为**全局对象**。析构函数在`main`函数结束后调用。

在《C++反汇编与逆向分析技术揭秘》中有详细讨论：

- **局部对象**：作用域结束前调用析构函数。
- **堆对象**：释放堆空间前调用析构函数。
- **参数对象**：退出函数前调用参数对象的析构函数。
- **返回对象**：如无对象引用定义，退出函数后调用返回对象的析构函数；否则与对象引用的作用域一致。
- **全局对象**：`main`函数退出后调用析构函数。
- **静态对象**：`main`函数退出后调用析构函数。

在`main`函数结束后，会由`exit`函数终止程序。全局对象的析构也在其中，包括**构造代理函数**和**析构代理函数**，后者负责所有全局对象的析构。因此，在`main`函数中无法直接看到验证过程。

此外，通过以下实验代码进一步验证：
```cpp
#include <iostream>
using namespace std;

class Test {
public:
    int num;
    Test(int num) : num(num) {}
    ~Test() {
        printf("%d: Test destructed\n", num);
        cout << num << ": Test destructed" << endl;
    }
};

Test globalObj(1);
static Test staticObj(2);

int main() {
    return 0;
}
```

发现**全局对象**后声明，先析构；而**静态对象**先声明，后析构。交换声明顺序后，输出结果正好相反。

这种现象并不是语言层面的特性，而是与编译器的具体实现有关。在全局对象或静态对象析构时，使用`printf`代替`cout`进行输出的情况并不多见，但在某些调试场景下可能会用到。这也算是C++的一个小坑。

[@vct](https://github.com/vct "@vct")师傅友情赞助。