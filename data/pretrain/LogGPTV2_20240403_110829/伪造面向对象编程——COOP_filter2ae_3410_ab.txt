其中各个数字代表执行顺序。而为了实现不同的操作，就需要以上几类vfgadgets的协同，这就是接下来要介绍的。
（4）不同操作的实现
正如前述所讨论的那样，通过主循环函数ML-G ,任意数目的虚函数可以被执行。而通过不同vfgadgets的配合，可以实现以下操作：
  1. 任意写。
考虑如下Examl类：
其各个元素在内存中排布如下：
可以看到，SimpleString::set（object1）的buffer指针和Exam（object0）的score是重叠的。而buffer指针是字符串复制的目标地址，在此基础上，通过操纵score的值，实际上buffer的值也就能够控制，进而任意写的地址任意性就达成了，接下来就要解决源数据（此处的字符串s）。而注意到此处的字符串是传入的参数，那么接下来要解决的就是传参问题了。以上在内存中构造重叠的对象是COOP很常用的手法。
  2. 传递参数。
参数传递和具体的系统有关，主要有：
（A）windows x64
windows
x64平台下函数的前四个参数由rcx,rdx,r8和r9四个寄存器来传递，更多的参数则通过栈来传递。特别的，对于C++程序来说，this指针通过rcx寄存器来传递。其他三个寄存器通常会作为临时寄存器使用。考虑下列64位下读取参数寄存器vfgadget：
其对应汇编指令如下：
相当于进行了如下操作：
因此，只要攻击者合理地选取对应偏移量为10h和18h的数据，就能对应的改变相应寄存器的值，进而通过这些寄存器为某个目标函数传参。
（B）Linux x64
Linux x64使用了6个寄存器来传递前六个参数，利用原理与windows x64是相同的，但因为有更多寄存器，所以更加简单。
（C）windows x86
windows x86下，this指针通过ecx寄存器传递，其他参数通过栈来传递。这个时候就要以下列带参数的主循环函数ML-ARG-G来传递参数。
其对应汇编指令为：
其中第9-22行进行了如下操作：
使用下列写入第一个对参数指针指向地址的vfgadget，就可以实现对以上arg0的控制，进而执行传参操作。
或者也可以借由内存写vfgadget来进行。
（D）Linux x86
该平台下的传参均通过栈来进行，所以使用带参数的主循环函数ML-ARG-G来传递参数。
以上均是只同时传递一个参数，要想同时传递多个参数，就有必要做栈平衡。下图展示了不同参数个数的栈情形：
栈平衡操作可以使用MOVE-SP-G类型的vfgadget来完成，最终达到的效果就是参数被逐个堆积到栈上，如下图所示：
  3. 调用API函数
要调用API函数，攻击者可以直接将伪造对象的vptr指针指向已加载模块的IAT表或者是EAT表，这二者均存有API函数信息。如果遇到权限问题，则可以用this指针作为参数调用VirtualProtect()函数设置即可。
又或者攻击者可以使用调用函数指针的vfgadget——INV-G来调用API函数。
  4. 实现条件分支和循环
如果选定的变量没有存储在栈上，那么下列条件写vfgadget——W-COND-G就能实现条件分支。
如果变量在栈上，MOVE-SP-G类型的vfgadget也可以被用作分支。
循环的实现也是类似的。
## 工具框架
为了完成COOP攻击，就要完成以下两个任务：
  1. 寻找目标vfgadgets
为了识别应用程序中有用的vfgadget，搜索时仅依赖于二进制代码以及可选的调试符号。使用IDA将目标C++模块反汇编，C
++模块中的每个虚函数都被视为潜在的vfgadget。使用调试符号来静态标识C
++模块中的所有虚函数表。如果没有该符号以标识虚函数表，就使用启发式的方法：把所有带有地址信息的函数指针数组作为一个潜在的虚函数表。检查所有已识别的虚函数，通常只将具有一个或三个基本块的虚函数作为潜在vfgadget。唯一的例外是ML-G和ML-ARG-G，由于带有循环，它们通常由更多基本块组成。
搜索时，每一个基本块用静态单赋值形式（static single assignment form，通常简写为SSA
form或是SSA，是中间表示IR的特性，每个变数仅被赋值一次）进行总结以反映其I/O行为特征。依赖于METASM二进制代码分析工具包的backtracking功能，在基本块级别进行符号执行（symbolic
execution）操作。接下来就是对潜在vfgadgets基本块的SSA表示应用过滤器。例如
“赋值的左侧不能引用任何参数寄存器；右侧不能引用this指针”能识别64位系统下的内存写vfgadget——W-G。
  2. 构造重叠的伪造对象
正如前述所说的，构造重叠的伪造对象对于COOP很重要。具体实现时，攻击者定义伪造的对象和标签。可以将标签分配给伪造对象内的任何字节。当为不同对象中的字节分配相同的标签时，应确保将这些字节映射到最终缓冲区中的相同位置，同时确保具有不同标签的字节被映射到不同的位置。这些约束通常可以满足，因为伪造对象中的实际数据通常很少。
比如，伪造的对象A仅仅在内部偏移+0处有vptr指针，偏移+16处有个整数，偏移+136处有标签X。伪造对象B只有vptr指针，内部偏移+8处有相同标签X。那么，B+8就可以映射到A+136处。
## 实际攻击
COOP进行了以下几个POC：
### 1.64位IE 10
攻击64位IE
10使用了21个伪造对象，其中8个是重叠的。另外使用了mshtml.dll中8个不同的vfgadgets。攻击有两条执行路径:a.弹出计算器和b.打开画图。以下是攻击使用的vfgadgets：
### 2.32位IE 10
攻击32位IE
10使用了22个伪造对象，其中6个是重叠的。另外使用了mshtml.dll、ieframe.dll、Jscript.dll等三个动态链接库中11个不同的vfgadgets。攻击调用了WinExec()弹出了计算器。以下是攻击使用的vfgadgets：
### 3.64位 Firefox 36.0a1
攻击使用了9个伪造对象，其中2个是重叠的。另外使用了libxul.so中5个不同的vfgadgets。攻击执行了system(“/bin/sh”)。以下是攻击使用的vfgadgets：
### 4.其他人进行的COOP攻击
链接为翻译，原文在链接都有相应链接。
使用最新的代码重用攻击绕过执行流保护（）
## 防御COOP
由于COOP主要针对C++语言特性，所以较好考虑了C++语言特性的防御措施都能比较好的地防御
COOP攻击。COOP提出者在后续论文里也提出了表随机化(Table Randomization)来对抗COOP。