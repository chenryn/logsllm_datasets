[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Password1
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Password2
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Password3
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Password1!
(Incorrect: No authentication types available: Your connection has been 
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Password2!
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Password3!
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :capsulecorp
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Capsulecorp1
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Capsulecorp2
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Capsulecorp3
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Capsulecorp1!
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Capsulecorp2!
(Incorrect: No authentication types available: Your connection has been
rejected.)
[-] 10.0.10.206:5900   - 10.0.10.206:5900 - LOGIN FAILED: :Capsulecorp3!
(Incorrect: No authentication types available: Your connection has been
rejected.)
[*] Scanned 2 of 2 hosts (100% complete)
[*] Auxiliary module execution completed
  msf5 auxiliary(scanner/vnc/vnc_login) > 
Exercise 4.3: Discovering weak passwords
Use your preferred password-guessing tool (CrackMapExec, Medusa, and Metasploit
are three examples introduced in this chapter) to identify weak passwords in your
engagement scope. The protocol-specific lists can be used to organize your testing
and help you use the right tool to check all the web servers, then all the database
servers, then the Windows servers, and so on for all the network services that present
authentication. Record any set of credentials you uncover in your engagement notes
as an authentication vulnerability, along with the IP address and network service.
75
Discovering configuration vulnerabilities
4.4
Discovering configuration vulnerabilities
A network service has a configuration vulnerability when one of the service’s configura-
tion settings enables an attack vector. My favorite example is the Apache Tomcat web
server. Often, it is configured to allow the deployment of arbitrary web application
archive (WAR) files via the web GUI. This allows an attacker who gains access to the
web console to deploy a malicious WAR file and gain remote access to the host operat-
ing system, usually with administrator-level privileges on the target.
 Web servers in general are usually a great path to code execution on an INPT. The
reason is that large engagements often involve hundreds or even thousands of HTTP
servers with all sorts of various web applications running on them. Many times, when
an IT/systems administrator installs something, it comes with a web interface listening
on an arbitrary port, and the admin doesn’t even know it’s there. The web service
ships with a default password, and the IT/systems administrator may forget to change
it—or not even know they need to do so. This presents a golden opportunity for an
attacker to gain remote entry into restricted systems.
 The first thing you’ll want to do is see what’s within your scope. You’re welcome to
open a web browser and start typing in IP_ADDRESS:PORT_NUMBER for every service you
discovered, but that can take a lot of time, especially on a decent size network with a
few thousand hosts. 
 Instead, for this purpose, I have created a handy little Ruby tool called Webshot
that takes the XML output from an nmap scan as input and produces a screenshot of
every HTTP server it finds. After it’s finished, you are left with a folder containing
viewable thumbnail screenshots; you can quickly sort through this sea of web servers
and easily drill down to targets you recognize to have known attack vectors. 
4.4.1
Setting up Webshot
Webshot is open source and available for free on GitHub. Run the following six com-
mands sequentially to download and install Webshot on your system:
1
Check out the source code from my GitHub page:
~$ git clone https://github.com/R3dy/webshot.git
2
Change into the webshot directory:
~$ cd webshot
3
Run both of these commands to install all the necessary Ruby gems:
~$ bundle install
~$ gem install thread
76
CHAPTER 4
Discovering network vulnerabilities
4
You need to download a legacy .deb (Debian) package from Ubuntu for lib-
png12 (which no longer ships with Ubuntu) because Webshot uses the wkhtml-
toimage binary package, which is no longer maintained:
~$ wget http://security.ubuntu.com/ubuntu/pool/main/libp/libpng/
➥ libpng12-0_1.2.54-1ubuntu1.1_amd64.deb
5
Install this package using the dpkg command:
~$ sudo dpkg -i libpng12-0_1.2.54-1ubuntu1.1_amd64.deb
Now you are set and ready to use Webshot. Take a look at the Help menu to familiarize
yourself with the proper usage syntax. You really only need to give it two options: -t,
which points to your target XML file from nmap; and -o, which points to the directory
where you want Webshot to output the screenshots it takes. You can see the Help file by
running the script with the -h flag, as shown in the next listing.
~$ ./webshot.rb -h               
Webshot.rb VERSION: 1.1 - UPDATED: 7/16/2019
References:
    https://github.com/R3dy/webshot
Usage: ./webshot.rb [options] [target list]
  -t, --targets [nmap XML File]  XML Output From nmap Scan
  -c, --css [CSS File]       File containing css to apply… 
  -u, --url [Single URL]      Single URL to take a screens…
  -U, --url-file [URL File]    Text file containing URLs
  -o, --output [Output Directory] Path to file where screens…
  -T, --threads [Thread Count]   Integer value between 1-20…
  -v, --verbose          Enables verbose output
Let’s see what it looks like when Webshot is run against my target list that was generated
by nmap during service discovery. In this case, the command is run from the capsulecorp
directory, so I have to type out the full path to Webshot relative to my home directory:
~/git/webshot/webshot.rb -t discovery/services/web.xml -o documentation/
screenshots. Here is the output—you can see screenshots appear in real time if you’re
watching the output directory:
Listing 4.9
Webshot usage and help menu
Can’t find the .deb package?
It’s possible that the URL used for wget will change. It isn’t likely, because Ubuntu
is based on Debian, which has been running smoothly and maintaining package
repositories since 1993. That said, if for some reason the wget command errors out
on you, you should be able to find the current download link at http://mng.bz/OvmK.
This command displays 
the usage and help menu.
77
Discovering configuration vulnerabilities
~$ ~/git/webshot/webshot.rb -t discovery/services/web.xml 
➥ -o documentation/screenshots
Extracting URLs from nmap scan
Configuring IMGKit options
Capturing 18 screenshots using 10 threads
4.4.2
Analyzing output from Webshot
Open a file browser and navigate to the screenshots directory, and you can see a
thumbnail image for every website that Webshot took a screenshot of (figure 4.4).
This is useful because it provides a quick picture of what’s in use on this network. To a
skilled attacker, this directory contains a wealth of information. For example, we now
know that a default Microsoft IIS 10 server is running. An Apache Tomcat server is
running on the same IP address as an XAMPP server. There is also a Jenkins server, as
well as what appears to be an HP printer page.
Equally as important, we can see that 12 of these pages are returning an error or a
blank page. Either way, they are letting us know that we don’t need to concentrate on
them. As an attacker, you should be particularly interested in the Apache Tomcat and
Jenkins servers because they both contain remote code execution vectors if you can
guess or otherwise obtain the admin password.
Jenkins
Apache
Tomcat
Microsoft IIS 10
Figure 4.4
Browsing web server screenshot thumbnails taken by Webshot
78
CHAPTER 4
Discovering network vulnerabilities
4.4.3
Manually guessing web server passwords
Your mileage will most certainly vary—possibly quite drastically from what I have
shown here. This is because different companies use an endless number of web appli-
cations to manage various parts of their business. On almost every engagement, I find
something I’ve never heard of before. However, anything you see that has a login
prompt should be worth testing with at least three or four commonly used default
passwords. You would not believe how many times admin/admin has gotten me into a
production web application that was later used for remote code execution.
 If you Google “Apache Tomcat default password,” you’ll see that admin/tomcat is
the default set of credentials for this application (figure 4.5). It doesn’t take a lot of
time to manually test four or five passwords on a couple of different web servers, so I’ll
quickly do that now, beginning with the Apache Tomcat server on 10.0.10.203:8080.
Apache Tomcat uses HTTP Basic Authentication, which prompts for a username and
password if you navigate to the /manager/html directory or click the Manager App
Jenkins, Tomcat, XAMPP—what do they mean?
Early in your career as a pentester, you will discover all sorts of applications you’ve
never seen before running on client networks. This still happens to me regularly because
software vendors come out with new applications almost daily. When this happens,
you should spend some time Googling the application to see whether someone has
already written up an attack scenario. Something like “Attacking XYZ” or “Hacking XYZ”
is a great place to start. For example, if you type “Hacking Jenkins Servers” into Google,
you’ll come across one of my old blog posts that explains step-by-step how to turn
Jenkins server access into remote code execution: http://mng.bz/YxVo.
HTTP basic authentication prompt
Figure 4.5
Manually guessing the admin password on Apache Tomcat
79
Discovering configuration vulnerabilities
button from the main page. In this server’s case, admin/tomcat did not work. However,
admin/admin did (figure 4.6), so I can add this server to my list of vulnerable attack
vectors in my notes and move on. 
 The next server I’m interested in targeting is the Jenkins server running on
10.0.10.202:8080. Manually trying a few different passwords reveals that the Jenkins
server credentials are admin/password (figure 4.7).
 It’s possible, perhaps even likely, that your target network doesn’t have any Jenkins
or Tomcat servers, and that’s fine. I’m only using these specific applications to illustrate
the concept of identifying web applications in your environment and trying a few default
credentials on all of them. I chose them for this book because they are commonly used
and often configured with default credentials. If you do enough engagements, you will
Logged in to the Tomcat Web Application Manager
Figure 4.6
Logged in to the Apache Tomcat application manager
Logged in to the Jenkins web console
Figure 4.7
Logged in to the Jenkins admin portal
80
CHAPTER 4
Discovering network vulnerabilities
probably see them. That said, you should feel comfortable testing default credentials on
any web application, even one you’ve never seen before. 
TIP
You should always, always, always try one or two sets of default creden-
tials (mainly admin/admin and admin/password) on every authentication
prompt you uncover during a pentest. You will be amazed how often this gets
you into a system.
No matter what the application is, somebody has presumably set it up on their net-
work before and then forgotten how to log in. They, of course, went to a web forum or
Yahoo user group or Stack Overflow and asked the support community a question
about that software, and somebody responded, telling them to try the default creden-
tials. You’ll also find PDF manuals that go through the setup and installation instruc-
tions, if you Google hard enough. These are great places to find default credentials
and maybe even possible attack vectors: for instance, whether the software contains a
place for administrators to upload arbitrary files or execute code snippets.
4.4.4
Preparing for focused penetration 
Now that our Hollywood movie heist crew has finished mapping out their target, iden-
tifying all the entry points, and determining which ones are susceptible to attack, it’s
time to plan how they’re going to proceed. In the movies, the crew often comes up
with the most over-the-top, outlandish scheme possible. This makes for a more enter-
taining movie, but it isn’t what we’re going to do. 
 In our case, there is no one to entertain, and there are no dancing laser beams to
dodge or attack dogs to bribe with deli meats. We simply need to worry about maxi-
mizing our chance of success by following the path of least resistance and targeting
the identified vulnerabilities with controlled attack vectors. Most important, we can’t
break anything. In the next chapter, we’ll use the vulnerabilities we’ve discovered to
safely penetrate into the affected hosts, gaining an initial foothold in the Capsulecorp
network.
Why not use an automated tool?
Web servers often rely on form-based authentication, which means brute-forcing the
login page is a bit trickier. It’s completely doable, but you have to spend a little time
reversing the login page so you know what information has to be sent in the HTTP
POST request. You also need to know what a valid response looks like, versus an
invalid response; then you can write your own script to do the brute-forcing. 
I have a repository on GitHub called ciscobruter (Ciscobruter source code: https://
github.com/r3dy/ciscobruter), which you can look at for reference. You can also use
an interception proxy such as Burp Suite to capture an authentication request and
replay it to the web server, changing the password each time. Both of these solutions
are slightly more advanced than what we cover in this book. 
81
Summary
Summary
 Follow the path of least resistance by first checking for LHF vulnerabilities and
attack vectors. A pentest is scope- and time-limited, so speed counts.
 Create a simple password list tailored to the company for which you are per-
forming an engagement.
 Be aware of account lockouts, and step lightly. If possible, only test credentials
against local user accounts on Windows networks.
 Web servers are often configured with default credentials. Use Webshot to take
bulk screenshots of all the web servers in your target environment so you can
quickly spot interesting targets.
 Every time you find a new service you’ve never seen, head to Google and learn
about it. Before you know it, you’ll be able to pick out easy attack vectors from a
crowd of application services.
Phase 2
Focused penetration
Now that you’ve identified your target network’s attack surface, it’s time to
begin compromising vulnerable hosts. This part of the book starts with chapter 5,
which walks you through various methods of compromising vulnerable web appli-
cations such as Jenkins and Apache Tomcat. You’ll learn how to deploy custom-
built backdoor web shells and upgrade them to fully interactive reverse command
shell access to compromised targets. 
 Chapter 6 introduces you to the process of attacking an unsecured database
server. In this chapter, you’ll also learn about Windows account password hashes,
why they are useful to you as an attacker, and how to obtain them from a com-
promised system. Finally, this chapter covers some interesting methods for
retrieving loot from compromised Windows hosts, which can be particularly use-
ful when you’re limited to a non-interactive shell.
 In chapter 7, you get your first taste of the coveted exploitation process and
achieve push-button remote access to a vulnerable server that’s missing a Micro-
soft Security Update. It doesn’t get much easier than this in terms of penetrating
network systems and gaining access to otherwise restricted targets.
 At the end of this part of the book, you will have a strong foothold in your tar-
get network environment. You will have successfully compromised multiple
level-one systems and will be ready to begin the next phase of your engagement:
privilege escalation.
85
Attacking
 vulnerable web services
The first phase of an internal network penetration test (INPT) was all about gather-
ing as much information as possible about the target environment. You began by
discovering live hosts and then enumerated which network services those hosts
were offering. Finally, you discovered vulnerable attack vectors in the authentica-
tion, configuration, and patching of those network services.
 Phase 2 is all about compromising vulnerable hosts. You may recall that in chap-
ter 1, we referred to the initial systems we gain access to as level-one hosts. Level-one
hosts are targets that have a direct access vulnerability that we can take advantage of
This chapter covers
 Phase 2: focused penetration
 Deploying a malicious web application archive file
 Using Sticky Keys as a backdoor
 Differences between interactive and non-
interactive shells
 Operating system command execution with 
Groovy script
86
CHAPTER 5
Attacking vulnerable web services
in a way that gives us some form of remote control over the target. This could be a
reverse shell, a non-interactive command prompt, or even just logging directly into a
typical remote management interface (RMI) service, such as remote desktop (RDP)
or secure shell (SSH). Regardless of the method of remote control, the motivation
and key focus throughout this entire phase of an INPT is to gain an initial foothold in
our target environment and access as many restricted areas of the network as we can.
 Figure 5.1 shows a graphical representation of the focused-penetration phase. The
inputs to this phase are the list of vulnerabilities discovered during the last phase. The
overall workflow is to move through the list, gaining access to each vulnerable host.
5.1
Understanding phase 2: Focused penetration
When you think about this phase from a big-picture perspective, you should start by
visualizing the goal: taking complete control of the entire network. That’s what an
attacker would want to do if for no other reason than to have unrestricted access to
any system on the network. Your job as a penetration tester is to play the role of an
attacker. I understand from years of experience that to do this, I’m going to have to
access a lot of different servers until I’m fortunate enough to stumble on one that has
what I need—usually, an active session from a domain administrator, or some other
Deploy backdoor web shells
Authentication,
configuration, and patching
vulnerabilities