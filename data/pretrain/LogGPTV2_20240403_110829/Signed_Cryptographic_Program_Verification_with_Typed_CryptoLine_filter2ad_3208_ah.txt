6.9
7.9
6.4
7.8
28.4
28.2
48.4
6.0
7.2
187.0
95.5
0.20
0.21
0.18
0.24
0.14
0.15
0.14
0.14
0.29
0.22
0.21
0.33
18.39
1.12
10.59
0.51
470.68
0.14
0.21
0.20
0.26
0.19
120.33
45
72
27
155
27
27
27
36
54
188
111
20
108
43
85
25
1073
5.3
452.9
18.4
278.7
5.9
1489.0
0
9
9
9
0
161
0
22
14
22
0
212
TRM2 MRM2
11.4
0.26
119.89
1472
TAM2 MAM2
8.9
0.13
145.12
5511
0.32
0.33
0.65
3.11
0.55
0.88
0.24
0.43
1.81
0.26
0.46
0.70
0.35
0.31
0.95
2.29
0.25
0.24
1.22
0.27
0.85
0.48
0.47
0.48
2.06
0.36
0.35
0.41
0.29
0.68
3.13
0.99
0.20
5.11
0.62
3.11
0.28
118.95
10.7
10.4
88
322.5
11.1
17.3
28.9
47.6
198.8
10.0
10.6
88.3
11.7
48.8
17.1
123.2
10.2
10.3
95.4
9.7
55.5
11.4
11.9
10.0
10.8
29.0
28.9
48.8
10.0
11.4
182.5
103.9
10.0
473.9
21.2
293.0
10.4
1579
0.14
0.11
0.09
0.13
0.12
0.13
0.09
0.10
0.13
0.10
0.12
0.10
0.12
0.10
0.13
0.14
0.10
0.09
0.11
0.12
0.10
0.13
0.12
0.12
0.14
0.09
0.09
0.09
0.10
0.15
0.13
0.13
8.6
8.8
8.2
9.1
8.7
9.3
8.1
8.2
9.2
8.3
8.7
8.4
8.6
8.2
9.3
9.8
8.4
8.2
9.4
8.6
9.2
9.3
9.2
8.6
9.6
8.3
8.3
8.4
8.3
8.7
9.5
9.3
0.10
0.13
0.11
0.12
0.11
91.99
8.2
9.2
8.6
9.2
8.8
5766
1Only an iteration of Montgomery Ladder step is verified.
2https://github.com/openssl/openssl commit 13fbce1
Session 7D: Formal Analysis IIICCS ’19, November 11–15, 2019, London, United Kingdom1604To illustrate the usability of our tools, the experiments are car-
ried out on two machines: a Macbook Pro and a dedicated Linux
server. Table 5 in Table 5 lists experimental results. We extract GCC
8.1.0 gimple code of C functions in NaCl 20110221, wolfSSL 3.15.5,
bitcoin 0.17.0.1, OpenSSL 1.1.1, and BoringSSL master branch with
git commit hash f36c3ad. Machine M1 is a Macbook Pro running
OS X 10.11.6 with a dual-core 2.7GHz CPU and 16GB RAM. M2
is a Linux server running Ubuntu 16.04.5 LTS with two octa-core
3.20GHz CPU and 1024GB RAM. The SMT solvers Boolector 3.0.0
and MathSAT 5.5.4 are used. We also use the computer algebra
system Singular 4.1.1. Columns LIR and LCL are the numbers
of gimple statements and CryptoLine instructions respectively.
Columns D and P are the numbers of manually translated Cryp-
toLine and annotated assert and assume instructions respectively.
TR and MR are the time (in seconds) and the peak memory usage
(in MB) when checking safety and range properties. TA and MA
are for the algebraic properties. Subscripts of TR, MR, TA, and MA
denote the machine used. OOM means out of memory and OOT
means out of time (greater than 86400 seconds).
Our experiments show that almost all functions can be verified
on a laptop in 15 minutes. Particularly, the C implementations of
the Montgomery ladder step for Curve25519 in OpenSSL and Bor-
ingSSL are verified in 13 and 10 minutes respectively. If a dedicated
server is used, the verification time shortens to 5 and 4 minutes
respectively. 25 functions can be checked without manual transla-
tion nor annotation; 39 (=25 + 14) functions require less than 10%
of manual translation (column D). Although our technique is not
fully automatic, it does not require much human intervention.
We have verified 82 C functions implementing field and group
operations for cryptographic primitives in 5 cryptography libraries:
NaCl [23], wolfSSL [26], bitcoin [19], OpenSSL [24], and BoringSSL [9,
11]. The 32-bit C implementations in wolfSSL’s Curve25519 is found
in OpenSSL and LibreSSL [21] as well. The secp256k1 cryptography
library in bitcoin is also used by other cryptocurrency including
Ethereum [20], Zcash [27], Ripple [25], and Litecoin [22].
The elliptic curve Curve25519 is defined over the field Z2255−19
and implemented in NaCl, wolfSSL, OpenSSL, and BoringSSL. Our
verification exposes a potential missing carry in NaCl 20110221.
We have reported our finding. The BoringSSL implementation is
synthesized by Fiat-Crypto [9]. The synthesized 64-bit unsigned C
implementation is verifiably correct at the C source level. We extract
its gimple representation after machine-independent optimization.
Interestingly, vector statements are used in the optimized sequential
implementation of Montgomery ladder step. Our result shows that
the implementation is still correct after vectorization. Due to errors
in the computer algebra system Singular, the 32-bit signed imple-
mentation in wolfSSL is almost verified except one algebraic prop-
erty. We are exploring other means to solve the corresponding ideal
membership problem. The bitcoin secp256k1 cryptography library
uses a Koblitz curve over the field Z2256−232−29−28−27−26−24−1. 24 C
functions for various field and group operations in the curve are
verified. We also verify field operations in 3 NIST curves (P224, P256,
and P521) over different fields (Z2224−296+1, Z2256−2224+2192+296−1, and
Z2521−1 respectively) from OpenSSL. To the best of our knowledge,
this is the first verification result of cryptographic programs in
NaCl, wolfSSL, and bitcoin.
ACKNOWLEDGMENTS
The authors would like to thank the anonymous referees for their
valuable comments and suggestions. This work is supported by
Academia Sinica under the Grant Numbers AS-IA-104-M01 and
AS-TP-106-M06; the Ministry of Science and Technology of Taiwan
under Grant Numbers 105-2221-E-001-014-MY3, 107-2221-E-001-
004, 108-2221-E-001-009-MY2, 108-2221-E-001-010-MY3; and the
National Natural Science Foundation of China under the Grant
Numbers 61802259 and 61836005.
REFERENCES
[1] Reynald Affeldt. 2013. On construction of a library of formally verified low-level
arithmetic functions. Innovations in Systems and Software Engineering 9, 2 (2013),
59–77.
[2] Reynald Affeldt and Nicolas Marti. 2007. An Approach to Formal Verification
of Arithmetic Functions in Assembly. In Advances in Computer Science (LNCS),
Mitsu Okada and Ichiro Satoh (Eds.), Vol. 4435. Springer, Heidelberg Dordrecht
London New York, 346–360.
[3] Reynald Affeldt, David Nowak, and Kiyoshi Yamada. 2012. Certifying assembly
with formal security proofs: The case of BBS. Science of Computer Programming
77, 10–11 (2012), 1058–1074.
[4] José Bacelar Almeida, Manuel Barbosa, Gilles Barthe, Arthur Blot, Benjamin
Grégoire, Vincent Laporte, Tiago Oliveira, Hugo Pacheco, Benedikt Schmidt,
and Pierre-Yves Strub. 2017. Jasmin: High-Assurance and High-Speed Cryp-
tography. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security. ACM, New York, NY, USA, 1807–1823.
[5] Andrew W. Appel. 2015. Verification of a Cryptographic Primitive: SHA-256.
ACM Transactions on Programming Languages and Systems 37, 2 (2015), 7:1–7:31.
[6] Lennart Beringer, Adam Petcher, Katherine Q. Ye, and Andrew W. Appel. 2015.
Verified Correctness and Security of OpenSSL HMAC. In USENIX Security Sym-
posium 2015. USENIX Association, 207–221.
[7] B. Bond, C. Hawblitzel, M. Kapritsos, K. R. M. Leino, J. R. Lorch, B. Parno, A. Rane,
S. Setty, and L. Thompson. 2017. Vale: Verifying High-Performance Cryptographic
Assembly Code. In USENIX Security Symposium 2017. USENIX Association, 917–
934.
[8] Yu-Fang Chen, Chang-Hong Hsu, Hsin-Hung Lin, Peter Schwabe, Ming-Hsien
Tsai, Bow-Yaw Wang, Bo-Yin Yang, and Shang-Yi Yang. 2014. Verifying
Curve25519 Software. In Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security, Gail-Joon Ahn, Moti Yung, and Ninghui
Li (Eds.). ACM, New York, NY, USA, 299–309.
[9] A. Erbsen, J. Philipoom, J. Gross, R. Sloan, and A. Chlipala. 2019. Simple High-
Level Code for Cryptographic Arithmetic - With Proofs, Without Compromises.
In 2019 IEEE Symposium on Security and Privacy. IEEE Computer Society, Los
Alamitos, CA, USA.
[10] Aymeric Fromherz, Nick Giannarakis, Chris Hawblitzel, Bryan Parno, Aseem
Rastogi, and Nikhil Swamy. 2019. A Verified, Efficient Embedding of a Veri-
fiable Assembly Language. In 46th ACM SIGPLAN Symposium on Principles of
Programming Languages. ACM, New York, NY, USA, 63:1–63:30.
[11] Google. 2019. BoringSSL. https://boringssl.googlesource.com/boringssl/.
[12] Carl A. Gunter. 1993. Semantics of Programming Languages: Structures and
Techniques. The MIT Press, Cambridge, MA, USA.
[13] Charles Antony Richard Hoare. 1969. An axiomatic basis for computer program-
ming. Commun. ACM 12, 10 (1969), 576–580.
[14] Jiaxiang Liu, Xiaomu Shi, Ming-Hsien Tsai, Bow-Yaw Wang, and Bo-Yin Yang.
2019. Verifying Arithmetic in Cryptographic C Programs. In 34th IEEE/ACM
International Conference on Automated Software Engineering, Julia Lawall and
Darko Marinov (Eds.). IEEE, San Diego, CA, USA.
[15] John C. Mitchell. 1996. Foudations for Programming Languages. The MIT Press,
Cambridge, MA, USA.
[16] Magnus O. Myreen and Gregorio Curello. 2013. Proof Pearl: A Verified Bignum
Implementation in x86-64 Machine Code. In Certified Programs and Proofs (LNCS),
Vol. 8307. Springer, Heidelberg Dordrecht London New York, 66–81.
[17] Magnus O. Myreen and Michael J. C. Gordon. 2007. Hoare Logic for Realistically
Modelled Machine Code. In International Conference on Tools and Algorithms for
the Construction and Analysis of Systems (LNCS), Orna Grumberg and Michael
Huth (Eds.), Vol. 4424. Springer, Heidelberg Dordrecht London New York, 568–
582.
[18] Andy Polyakov, Ming-Hsien Tsai, Bow-Yaw Wang, and Bo-Yin Yang. 2018. Veri-
fying Arithmetic Assembly Programs in Cryptographic Primitives (Invited Talk).
In 29th International Conference on Concurrency Theory (LIPIcs), Sven Schewe and
Lijun Zhang (Eds.), Vol. 118. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik,
Beijing, China, 4:1–4:16.
Session 7D: Formal Analysis IIICCS ’19, November 11–15, 2019, London, United Kingdom1605[19] The Bitcoin Developers. 2019. Bitcoin Source Code. https://github.com/bitcoin/
[20] The Ethereum Developers. 2019. Ethereum Source Code. https://github.com/
bitcoin.
ethereum/go-ethereum.
project/litecoin.
//nacl.cr.yp.to/.
rippled.
wolfSSL/wolfssl.
[21] The LibreSSL Developers. 2019. LibreSSL. https://www.libressl.org/.
[22] The Litecoin Developers. 2019. Litecoin Source Code. https://github.com/litecoin-
[23] The NaCl Developers. 2011. NaCl: Networking and Cryptography library. https:
[24] The OpenSSL Developers. 2019. OpenSSL. https://www.openssl.org/.
[25] The Ripple Developers. 2019. Ripple Source Code. https://github.com/ripple/
[26] The wolfSSL Developers. 2019. wolfSSL Source Code.
https://github.com/
[27] The Zcash Developers. 2019. Zcash Source Code. https://github.com/zcash/zcash.
[28] Ming-Hsien Tsai, Bow-Yaw Wang, and Bo-Yin Yang. 2017. Certified Verification
of Algebraic Properties on Low-Level Mathematical Constructs in Cryptographic
Programs. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and
Communications Security, David Evans, Tal Malkin, and Dongyan Xu (Eds.). ACM,
New York, NY, USA, 1973–1987.
[29] Katherine Q. Ye, Matthew Green, Naphat Sanguansin, Lennart Beringer, Adam
Petcher, and Andrew W. Appel. 2017. Verified Correctness and Security of
mbedTLS HMAC-DRBG. In Proceedings of the 2017 ACM SIGSAC Conference on
Computer and Communications Security. ACM, New York, NY, USA, 2007–2020.
[30] Jean Karim Zinzindohoué, Karthikeyan Bhargavan, Jonathan Protzenko, and Ben-
jamin Beurdouche. 2017. HACL*: A Verified Modern Cryptographic Library. In
Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security. ACM, New York, NY, USA, 1789–1806.
Session 7D: Formal Analysis IIICCS ’19, November 11–15, 2019, London, United Kingdom1606