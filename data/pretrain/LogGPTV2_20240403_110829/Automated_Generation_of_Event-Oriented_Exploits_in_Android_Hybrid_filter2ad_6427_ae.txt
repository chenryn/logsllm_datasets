32:
33:
34:
35: end function
end for
end for
return SUCCESS
Algorithm 2 Exploit Code Generation
Input:
1: EO : the event handler execution order, which is the set of the pair ;
2: get_input(eh, p) : return eh’s input that can guide the app to execute p;
3: get_web_trigger_code(eh, parameter): return web code that can trigger eh
and pass parameter to eh
4: get_js(eh, p) : return required JavaScript code
5:
Output: the exploit code X
1: function GENERATE_EXPLOIT_CODE(eh, p)
2:
3:
4:
5:
6:
7: end function
for  in EO do
X += gen_js(ehi, pi)
input ← get_input(ehi, (pi)
X += gen_event_trigger_code(ehi, input)
end for
by applying a JavaScript interpreter engine (such as Mozilla
Rhino 1.6) in I +J, AST is generated. After that, I’s semantics
can be understood by checking AST’s semantics and locating I
in AST. Finally, concrete JavaScript code of I can be generated.
Figure 6: AST of I + J
We use the code in Figure 3 to illustrate how this sub-
module works. In the event handler shouldOverrideUrlLoad-
ing(), I is passed to getId() and executed to receive sensitive
information. To automatically generate concrete JavaScript code
of I, loadUrl()’s parameter is ﬁrstly dumped. Suppose the
device ID is “1234”. The parameter’s symbolic expression
is then ‘‘javascript: + Uri.(InputUrl).getHost().split("
.")[2] + ("1234")’’. By replacing the symbolic data with a
concrete string (such as “x”), a concrete example code of
I + J may be ‘‘javascript:x(1234)’’. Next, AST (Figure 6)
can be generated by applying Rhino in the JavaScript code
“x(1234)”. By locating x in AST, we can ﬁnd that x is a function
name, and the function has only one string parameter. Hence,
a JavaScript function (such as steal_device_id() in Listing
2) that satisﬁes the requirement can be deﬁned in advance,
and then the function name is passed to the event handler
shouldOverrideUrlLoading().
VI. EVALUATION
To evaluate EOEDroid, we implemented it on Android 4.3,
and deployed it in a Nexus 10 smartphone. Given apps, we
started the random UI exploration tool Android Monkey [9] to
trigger as many WebView components as possible.
Note that it is challenging to automatically trigger a UI
component. To mitigate the problem, We run Monkey to
simulate users’ behaviors. Furthermore, we also use Monkey
as the ﬁrst-layer ﬁlter. The intuition is that if WebView is an
important part of the app, it will be likely triggered in this way.
Thus we reduce our workload by only considering the apps
whose WebView components are successfully triggered in our
dataset (Section VI-A).
Once a WebView complement is triggered, complete fuzzing
code is injected to trigger all event handlers. More speciﬁcally,
when WebView is going to connect to a web server, we start
a crawler to check whether an HTTP link is involved in the
connection. We limit the crawling depth in three levels. If
there is an HTTP link, man-in-the-middle attacks is performed
(Section III-B). The proxy tool “mitmproxy” [6] is used to inject
web event trigger (fuzzing) code, which is generated based
on the study result (Section V-A). Hence, once the injected
code is loaded and executed in WebView, all event handlers
are triggered, and then, EOEDroid is started to analyze them.
A. Dataset
In our evaluation, we collected apps as our evaluation dataset
from two different app groups based on whether the WebView
11
&ƵŶĐƚŝŽŶĂůůdĂƌŐĞƚdǇƉĞ͗EĂŵĞƌŐƵŵĞŶƚƐdǇƉĞ͗>ŝƐƚфEŽĚĞх^ƚƌŝŶŐsĂůƵĞ͗ϭϮϯϰEĂŵĞsĂůƵĞ͗ǆcomponent could be triggered at run time. Both these two
groups were collected from the Android ofﬁcial store Google
Play. The ﬁrst app group consists of 13,000 popular apps that
we crawled from 26 categories, and extracted 500 most popular
free apps for each category. The other app group contains 220
browser apps, which were collected by searching the key word
‘web browser’ in Google Play.
Finally, 3,652 apps were totally collected as our dataset,
with 3,552 apps from the ﬁrst app group and 212 apps from
the second app group.
B. Findings
Our experiment casts light on the usage of event handlers
in real-world hybrid apps. It also reveals interesting facts about
EOE in hybrid apps.
1) Usage Of Event Handlers: Figure 7 shows the
distribution of the usage of top 20 event handlers. shoul-
dOverrideUrlLoading() and onPageFinished() are the two most
frequently used event handlers.
Vulnerability Type
Cross-Frame DOM Manipulation
Phishing
Sensitive Information Leakage
Local Resource Access
Intent Abuse
Number
2
53
30
1
11
Table II: Vulnerabilities Found By EOEDroid
Distribution of vulnerable Event Handlers. We found that
most vulnerabilities (96/97) existed in the event handler shoul-
dOverrideUrlLoading(). The remaining two vulnerabilities were
found in onCreateWindow() and onReceivedHttpAuthRequest().
Phishing. We found the usage of the API loadUrl() to
load new content in WebView likely introduced this type of
vulnerabilities. It is mainly because developers wrongly assume
the code loaded in WebView is trustable, and do not set up
security checks before the sensitive API is called. In some apps,
even though security checks were provided, these checks were
incompetent to protect the critical functionalities and could be
evaded. Take the following code as the example. Adversaries
could still hit the sensitive API by feeding the input ‘http://att
acker.com/malicious/code?from=developer.com’.
String url) {
...
else if (url.contains("developer.com")) {
public boolean shouldOverrideUrlLoading(WebView view,
view.loadUrl(url);
return true;
Figure 7: Usage Of Event Handlers
We also found most hybrid apps deﬁne their own event
handlers. In our dataset (Section VI-A), 3,440 of 3,652 (94.2%)
hybrid apps implemented their event handlers. It is clear that
event handlers are in widespread use in real-world apps. Next
we discuss the typical scenarios in which event handlers are
used in apps.
Access Control. Event handlers can be applied to perform
access control on the communication to be accessed, and the
content to be loaded in WebView. For instance, shouldInter-
ceptRequest() can check the content requested by web code.
If the content is not expected, the event handler can directly
return null to reject the access.
Customized URL Scheme. Event handlers can be used to
support customized URLs. For instance, the link “tel:xx” and
“smsto:xx” can be supported to make a phone call and send a
text message.
Event Driven Authentication. Using customized URL
schemes, event handlers can also be applied to perform
authentication. Consider that shouldOverrideUrlLoading() sup-
ports a customized URL scheme “sdk”. When the URL
“sdk://auth_request” is received, the event handler redirects
WebView to the authentication web site, while specifying the
redirection URL as “sdk://auth_success”. Hence, when the URL
“sdk://auth_success” is received by the event handler, the event
handler can learn the authentication is successfully done.
2) EOE In Event Handlers: By applying EOEDroid
on the 3,652 hybrid apps, we successfully identiﬁed 97
vulnerabilities in 58 hybrid apps, as brieﬂy shown in Table II.
12
Cross-Frame DOM Manipulation. As shown in Table II,
different from phishing, there were only a few cross-frame
DOM manipulation vulnerabilities, even though loadU rl()’s
parameter was totally controlled by adversaries. This is because
that it is challenging to transfer the preﬁx string “javascript:”
from the web code to the native code. Typically, in the web
context,
the preﬁx string “javascript:” is directly handled
by JavaScript engine, rather than triggering any web events.
However, using tricks it is still possible to deliver the preﬁx
string. EOEDroid successfully discovered two vulnerable event
handlers that could be leveraged to pass JavaScript code to the
native context and execute the code. More details are discussed
in our case studies in Section VI-C1.
Sensitive Information Leakage. In this category, EOEDroid
successfully caught 26 vulnerable event handlers that could be
utilized to steal Android ID. The further study showed that all of
them were caused by an ad lib. The remaining 4 vulnerabilities
were found in high proﬁle browser apps. The ﬁrst vulnerable
event handler (from “com.webroot.xxx”) could be leveraged
to leak the phone number to a public log ﬁle, which could
be accessed by any app. The second vulnerable event handler
(from “com.kiddoware.xxx”) could be triggered to leak IMEI.
The third event handler (from “reactivephone.xxx”) could be
exploited to steal GPS location information using the input in
a speciﬁc format. More speciﬁcally, if the URL to be accessed
contained the string “latitude,longitude”, the real GPS location
data were retrieved to replace the string.
The last vulnerable event handler (from “com.mx.xxx”)
was interesting, which contained a potential backdoor that
could be used to steal sensitive information, such as IMEI.
Although developers had attempted to close the backdoor,
EOEDroid found that it was still possible for adversaries to
leverage the backdoor by changing the program state through
the manipulation of execution orders of gadgets. More details
are shown in our case study in Section VI-C2.
Local Resource Access. One vulnerable app was found that it
could allow adversaries to access local database. Even though
this app checked the origin information of web code that was
going to access the database, it could still be bypassed by
containing the developer website name.
Intent Abuse. One of the vulnerabilities was found in the
event handler of the Korean Air app, which was allowed to
send arbitrary intent message. Furthermore, the event handler
also suffered from phishing attacks and cross-frame DOM
manipulation.
Other ten vulnerabilities were found in browser apps. It
was mainly because browser apps aimed to support the popular
scheme “intent://”. However, these apps did not check the origin
information, and specify the action or destination class, which
might cause serious problems, as demonstrated by Wang et al.
[36].
C. Case Studies
App
Input Format
com.exsoul.xxx
com.fevdev.xxx
“exsoul://id=[0-9]{8}&url=”
“intent://...fallback_url=”
Table III: The Input Format Of The Two Vulnerable Apps
Shown In Case 1
1) Case 1: Cross-Frame DOM Manipulation: This section
presents two vulnerable apps that suffer from cross-frame
manipulation attacks. To transfer the preﬁx string “javascript:”,
the input is crafted following the input format shown in Table
III. When the input is received and parsed by the event
handler shouldOverrideUrlLoading(), the content l of “url”
and “fallback_url”is extracted and then fed into a sensitive
API loadUrl(). Hence, if l is in the format “javascript:...”, the
JavaScript code can be then executed in the main frame.
2) Case 2 : Leveraging A Closed Backdoor: This
high proﬁle app has been downloaded more than 10 million
times. The Listing 3 shows a code snippet of the vulnerable
event handler. In this app, the variable ﬂag (Line 1) is initially
false. When the event handler shouldOverrideUrlLoading() is
triggered, several conditional statements are determined relying
on the ﬂag (Line 12) and the URL. In Line 24, the URL is
saved to a local variable, and then “%IMEI%” is replaced with
real IMEI.
String url) {
...
flag = true;
...
...
url = url.toLowerCase();
if (!flag)
...
else {
1 flag = false;
2
3 public void onPageFinished(WebView view, String url) {
4
5
6
7 }
8
9 public boolean shouldOverrideUrlLoading(WebView view,
10
11
12
13
14
15
16
17
18
19
20
21
22
23
...
String tmpstr = url;
// read imei from shared preference
String i = PreferenceManager.
content://")) ...
else if (url.startsWith("mx")) ...
else {
if (url.contains("app_name")) {
if (url.startsWith("http://") || url.startsWith("https
://"))
...
else if (url.startsWith("file://")||url.startsWith("
24
25
26
27
getDefaultSharedPreferences(this).getString("
imei", "");
tmpstr = tmpstr.replaceAll("%IMEI%", i)
...
// send a Intent message containing tmpstr
Intent intent = new ...;
28
29
30
...
intent.setData(Uri.parse(tmpstr));
startActivity(intent)
Listing 3: Code snippet extracted from the example in case
By applying EOEDroid on this app, the vulnerable event
handler’s path constraints are collected, which are shown as
follows.
(1) InputUrl.startsWith("http://") == 0