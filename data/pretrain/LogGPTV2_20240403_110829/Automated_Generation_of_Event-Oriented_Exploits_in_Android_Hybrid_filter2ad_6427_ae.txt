### Algorithm 2: Exploit Code Generation

**Input:**
1. **EO**: The event handler execution order, which is a set of pairs.
2. **get_input(eh, p)**: Returns the input for `eh` that can guide the app to execute `p`.
3. **get_web_trigger_code(eh, parameter)**: Returns the web code that can trigger `eh` and pass `parameter` to `eh`.
4. **get_js(eh, p)**: Returns the required JavaScript code.

**Output:**
- **X**: The exploit code

**Function: GENERATE_EXPLOIT_CODE(eh, p)**
```python
def GENERATE_EXPLOIT_CODE(eh, p):
    X = ""
    for (ehi, pi) in EO:
        X += gen_js(ehi, pi)
        input = get_input(ehi, pi)
        X += gen_event_trigger_code(ehi, input)
    return X
```

**Explanation:**
- The function iterates over each pair `(ehi, pi)` in the execution order `EO`.
- For each pair, it generates the necessary JavaScript code using `gen_js(ehi, pi)`.
- It then retrieves the input for the event handler using `get_input(ehi, pi)`.
- Finally, it generates the event trigger code using `gen_event_trigger_code(ehi, input)` and appends it to `X`.

**JavaScript Interpretation:**
- By applying a JavaScript interpreter engine (e.g., Mozilla Rhino 1.6) to the generated code `I + J`, an Abstract Syntax Tree (AST) is generated.
- The semantics of `I` can be understood by checking the AST's semantics and locating `I` in the AST.
- Concrete JavaScript code for `I` can then be generated.

**Example:**
- Consider the event handler `shouldOverrideUrlLoading()`. If `I` is passed to `getId()` and executed to receive sensitive information, the `loadUrl()` parameter is first dumped.
- Suppose the device ID is "1234". The parameter's symbolic expression might be `'javascript: + Uri.(InputUrl).getHost().split(".")[2] + ("1234")'`.
- Replacing the symbolic data with a concrete string (e.g., "x"), the concrete example code of `I + J` might be `'javascript:x(1234)'`.
- Applying Rhino to the JavaScript code `"x(1234)"` generates the AST. By locating `x` in the AST, we can determine that `x` is a function name with one string parameter.
- A JavaScript function (e.g., `steal_device_id()`) can be defined in advance, and the function name is passed to the event handler `shouldOverrideUrlLoading()`.

### Evaluation

**Implementation and Deployment:**
- EOEDroid was implemented on Android 4.3 and deployed on a Nexus 10 smartphone.
- To trigger as many WebView components as possible, the random UI exploration tool Android Monkey [9] was used.

**Challenges and Mitigation:**
- Automatically triggering a UI component is challenging. To mitigate this, Monkey was run to simulate user behaviors.
- Monkey also served as the first-layer filter. If WebView is an important part of the app, it is likely to be triggered, reducing the workload by focusing only on apps where WebView components were successfully triggered.

**Fuzzing and Analysis:**
- Once a WebView component is triggered, complete fuzzing code is injected to trigger all event handlers.
- When WebView connects to a web server, a crawler checks for HTTP links, with a crawling depth limited to three levels.
- If an HTTP link is found, a man-in-the-middle attack is performed using the proxy tool "mitmproxy" [6].
- The injected code, generated based on the study results, is loaded and executed in WebView, triggering all event handlers for analysis by EOEDroid.

### Dataset

**Collection:**
- Apps were collected from two groups: those with WebView components that could be triggered at runtime and those without.
- The first group consisted of 13,000 popular apps from 26 categories, with 500 most popular free apps per category.
- The second group contained 220 browser apps, collected by searching for 'web browser' in Google Play.
- In total, 3,652 apps were collected: 3,552 from the first group and 212 from the second group.

### Findings

**Usage of Event Handlers:**
- Figure 7 shows the distribution of the top 20 event handlers. `shouldOverrideUrlLoading()` and `onPageFinished()` are the most frequently used.
- Most hybrid apps (94.2%) define their own event handlers, indicating widespread use in real-world apps.

**Vulnerabilities Found:**
- **Cross-Frame DOM Manipulation**: Only a few vulnerabilities, even though `loadUrl()`'s parameter was controlled by adversaries.
- **Phishing**: Caused by the misuse of `loadUrl()` without proper security checks.
- **Sensitive Information Leakage**: 26 vulnerable event handlers for stealing Android IDs, caused by an ad lib. Other vulnerabilities include leaking phone numbers, IMEI, and GPS location.
- **Local Resource Access**: One app allowed access to local databases, bypassing origin checks.
- **Intent Abuse**: Vulnerabilities in browser apps due to improper handling of the "intent://" scheme.

### Case Studies

**Case 1: Cross-Frame DOM Manipulation**
- Two vulnerable apps with crafted inputs to transfer the "javascript:" prefix.
- Input formats: "exsoul://id=[0-9]{8}&url=" and "intent://...fallback_url=".
- When received, the content of "url" and "fallback_url" is extracted and fed into `loadUrl()`, allowing JavaScript execution in the main frame.

**Case 2: Leveraging a Closed Backdoor**
- A high-profile app downloaded over 10 million times.
- The variable `flag` is initially false. When `shouldOverrideUrlLoading()` is triggered, several conditional statements are determined based on `flag` and the URL.
- The URL is saved to a local variable, and "%IMEI%" is replaced with the real IMEI.
- EOEDroid identified path constraints, showing potential backdoor exploitation through manipulation of execution orders.

**Code Snippet:**
```java
public boolean shouldOverrideUrlLoading(WebView view, String url) {
    flag = true;
    url = url.toLowerCase();
    if (!flag) {
        // ...
    } else {
        String tmpstr = url;
        String i = PreferenceManager.getDefaultSharedPreferences(this).getString("imei", "");
        tmpstr = tmpstr.replaceAll("%IMEI%", i);
        Intent intent = new Intent();
        intent.setData(Uri.parse(tmpstr));
        startActivity(intent);
    }
    return true;
}
```

**Path Constraints:**
- (1) `InputUrl.startsWith("http://") == 0`

This structured and optimized text provides a clear and professional overview of the algorithm, evaluation, and findings, along with detailed case studies.