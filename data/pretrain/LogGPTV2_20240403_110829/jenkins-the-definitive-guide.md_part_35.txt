in its history. You can configure this by ticking the Discard Old Builds checkbox at the top of the project
configuration page (see Figure 13.1, “Discarding old builds”). If you tell Jenkins to only keep the last
20 builds, it will start discarding (and deleting) older build jobs once it reaches this number. You can
limit them by number (i.e., no more than 20 builds) or by date (i.e., builds no older than 30 days). It does
this intelligently, though: if there has ever been a successful build, Jenkins will always keep at least the
latest successful build as part of its build history, so you will never loose your last successful build.
Figure 13.1. Discarding old builds
The problem with discarding old builds is that you loose the build history at the same time. Jenkins uses
the build records to produce graphs of test results and build metrics. If you limit the number of builds to
be kept to twenty, for example, Jenkins will only display graphs containing the last twenty data points,
which can be a bit limited. This sort of information can be very useful to the developers, but it is often
good to be able to see how the project metrics are doing throughout the whole life of the project, not
just over the last week or two.
Fortunately, Jenkins has a work-around that can keep both developers and system administrators happy.
In general, the items that take up the most disk space are the build artifacts: JAR files, WAR files, and
so on. The build history itself is mostly XML log files, which don’t take up too much space. If you
click on the “Advanced...” button, Jenkins will let you discard the artifacts, but not the build data. In
Figure 13.2, “Discarding old builds—advanced options”, for example, we have configured Jenkins to
keep artifacts for a maximum of 7 days. This is a great option if you need to put a cap on disk usage,
but still want to provide a full scope of build metrics for the development teams.
Figure 13.2. Discarding old builds—advanced options
Don’t hesitate to be ruthless, keeping the maximum number of builds with artifacts quite low.
Remember, Jenkins will always keep the last stable and the last successful builds, no matter what you
tell it, so you will always have at least one working artifact (unless of course the project has yet to
successfully build). Jenkins also lets you mark an individual build as “Keep this log forever”, to exclude
certain important builds from being discarded automatically.
13.2.1. Using the Disk Usage Plugin
One of the most useful tools in the Jenkins administrator’s tool box is the Disk Usage plugin. This plugin
records and reports on the amount of disk space used by your projects. It lets you isolate and fix projects
that are using too much disk space.
You can install the Disk Usage plugin in the usual way, from the Plugin Manager screen. Once you have
installed the plugin and restarted Jenkins, the Disk Usage plugin will record the amount of disk space
used by each project. It will also add a Disk Usage link on the Manage Jenkins screen, which you can
use to display the overall disk usage for your projects (see Figure 13.3, “Viewing disk usage”).
346
Figure 13.3. Viewing disk usage
This list is sorted by overall disk usage, so the projects using the most disk space are at the top. The list
provides two values for each project—the Builds column indicates the total amount of space used by
all of the project’s build history, whereas the Workspace column is the amount of space used to build
the project. For ongoing projects, the Workspace value tends to be relatively stable (a project needs
what it needs to build correctly), whereas the Builds column will increase over time, sometimes at a
dramatic rate, unless you do something about it. You can keep the space needed by a project’s history
under control by limiting the number of builds being kept for a project, and by being careful about what
artifacts are being stored.
To get an idea of how fast the disk space is being used up, you can also display the amount of disk space
used in each project over time. To do this, you need to activate the plugin in the System Configuration
screen (see Figure 13.4, “Displaying disk usage for a project”).
Figure 13.4. Displaying disk usage for a project
This will record and display how much space your projects are using over time. The Disk Usage plugin
displays a graph of disk usage over time (see Figure 13.5, “Displaying project disk usage over time”),
which can give you a great view of how fast your project is filling up the disk, or, on the contrary, if
the disk usage is stable over time.
347
Figure 13.5. Displaying project disk usage over time
13.2.2. Disk Usage and the Jenkins Maven Project Type
If you are using the Jenkins Maven build jobs, there are some additional details you should know about.
In Jenkins, Maven build jobs will automatically archive your build artifacts by default. This may not
be what you intend.
The problem is that these SNAPSHOT artifacts take up space—a lot of it. On an active project, Jenkins
might be running several builds per hour, so permanently storing the generated JAR files for each build
can be very costly. The problem is accentuated if you have multimodule projects, as Jenkins will archive
the artifacts generated for each module.
In fact, if you need to archive your Maven SNAPSHOT artifacts, it is probably a better idea to deploy
them directly to your local Maven repository manager. Nexus Pro, for example, can be configured to
do this and Artifactory can be configured to delete old snapshot artifacts.
Fortunately, you can configure Jenkins to this, go to the “Build” section of your build job configuration
screen and click on the Advanced button. This will display some extra fields, as shown in Figure 13.6,
“Maven build jobs—advanced options”.
Figure 13.6. Maven build jobs—advanced options
348
If you tick the “Disable automatic artifact archiving” checkbox here, Jenkins will refrain from storing the
jar files your project build generates. This is a good way of making your friendly system administrator
happy.
Note that sometimes you do need to store the Maven artifacts. For example, they often come in handy
when implementing a build pipeline (see Section 10.7, “Build Pipelines and Promotions”). In this case,
you can always choose to archive the artifacts you need manually, and then use the “Discard old builds”
option to refine how long you keep them for.
13.3. Monitoring the Server Load
Jenkins provides build-in monitoring of server activity. On the Manage Jenkins screen, click on the
Load Statistics icon. This will display a graph of the server load over time for the master node (see
Figure 13.7, “Jenkins Load Statistics”). This graph keeps track of three metrics: the total number of
executors, the number of busy executors, and queue length.
The total number of executors (the blue line) includes the executors on the master and on the
slave nodes. This can vary when slaves are brought on and offline, and can be a useful indicator of how
well your dynamic provisioning of slave nodes is working.
The number of busy executors (the red line) indicates how many of your executors are occupied
executing builds. You should make sure you have enough spare capacity here to absorb spikes in
build jobs. If all of your executors are permanently occupied running build jobs, you should add more
executors and/or slave nodes.
The queue length (the gray line) is the number of build jobs awaiting executing. Build jobs are queued
when all of the executors are occupied. This metric does not include jobs that are waiting for an upstream
build job to finish, so it gives a reasonable idea of when your server could benefit from extra capacity.
349
Figure 13.7. Jenkins Load Statistics
You can get a similar graph for slave nodes, using the Load Statistics icon in the slave node details page.
Another option is to install the Monitoring plugin. This plugin uses JavaMelody to produce
comprehensive HTML reports about the state of your build server, including CPU and system load,
average response time, and memory usage (see Figure 13.8, “The Jenkins Monitoring plugin”). Once
you have installed this plugin, you can access the JavaMelody graphs from the Manage Jenkins screen,
using the “Monitoring of Jenkins/Jenkins master” or “Jenkins/Jenkins nodes” menu entries.
350
Figure 13.8. The Jenkins Monitoring plugin
13.4. Backing Up Your Configuration
Backing up your data is a universally recommended practice, and your Jenkins server should be no
exception. Fortunately, backing up Jenkins is relatively easy. In this section, we will look at a few ways
to do this.
13.4.1. Fundamentals of Jenkins Backups
In the simplest of configurations, all you need to do is to periodically back up your JENKINS_HOME
directory. This contains all of your build jobs configurations, your slave node configurations, and your
build history. This will also work fine while Jenkins is running—there is no need to shut down your
server while doing your backup.
The downside of this approach is that the JENKINS_HOME directory can contain a very large amount
of data (see Section 3.13, “What’s in the Jenkins Home Directory”). If this becomes an issue, you can
save a little by not backing up the following directories, which contain data that can be easily recreated
on-the-fly by Jenkins:
$JENKINS_HOME/war
The exploded WAR file
351
$JENKINS_HOME/cache
Downloaded tools
$JENKINS_HOME/tools
Extracted tools
You can also be selective about what you back up in your build jobs data. The $JENKINS_HOME/jobs
directory contains job configuration, build history and archived files for each of your build jobs. The
structure of a build job directory is illustrated in Figure 13.9, “The builds directory”.
Figure 13.9. The builds directory
To understand how to optimize your Jenkins backups, you need to understand how the build job
directories are organized. Within the jobs directory there is a subdirectory for each build job. This
subdirectory contains two subdirectories of its own: builds and workspace. There is no need to
backup the workspace directory, as it will simply be restored with a clean checkout if Jenkins finds
it missing.
The builds directory, on the other hand, needs more attention. This directory contains the history of
your build results and previously-generated artifacts, with a time-stamped directory for each previous
352
build. If you are not interested in restoring build history or past artifacts, you don’t need to store this
directory. If you are, read on! In each of these directories, you will find the build history (stored in the
form of XML files such as JUnit test results) and archived artifacts. Jenkins uses the XML and text
files to produce the graphs it displays on the build job dashboard, so if these are important to you, you
should store these files. The archive directory contains binary files that were generated and stored by
previous builds. These binaries may or may not be important to you, but they can take up a lot of space,
so if you exclude them from your backups, you may be able to save a considerable amount of space.
Just as it is wise to make frequent backups, it is also wise to test your backup procedure. With Jenkins,
this is easy to do. Jenkins home directories are totally portable, so all you need to do to test your backup is
to extract your backup into a temporary directory and run an instance of Jenkins against it. For example,
imagine we have extracted our backup into a temporary directory called /tmp/jenkins-backup. To
test this backup, first set the JENKINS_HOME directory to this temporary directory:
$ export JENKINS_HOME=/tmp/jenkins-backup
Then simply start Jenkins on a different port and see if it works:
$ java -jar jenkins.war --httpPort=8888
You can now view Jenkins running on this port and make sure that your backup worked correctly.
13.4.2. Using the Backup Plugin
The approach described in the previous section is simple enough to integrate into your normal backup
procedures, but you may prefer something more Jenkins-specific. The Backup plugin (see Figure 13.10,
“The Jenkins Backup Manager Plugin”) provides a simple user interface that you can use to back up
and restore your Jenkins configurations and data.
Figure 13.10. The Jenkins Backup Manager Plugin
353
This plugin lets you configure and run backups of both your build job configurations and your build
history. The Setup screen gives you a large degree of control over exactly what you want backed up
(see Figure 13.11, “Configuring the Jenkins Backup Manager”). You can opt to only back up the XML
configuration files, or back up both the configuration files and the build history. You can also choose
to backup (or not to backup) the automatically-generated Maven artifacts (in many build processes,
these will be available on your local Enterprise Repository Manager). You can also back up the job
workspaces (typically unnecessary, as we discussed above) and any generated fingerprints.
Figure 13.11. Configuring the Jenkins Backup Manager
You can trigger a backup manually from the Backup Manager screen (which you can access from the
Manage Jenkins screen). The backup takes some time, and will shut down Jenkins during the process
(unless you deactivate this option in the backup configuration).
At the time of writing, there is no way to schedule this operation from within Jenkins, but you can start
the backup operation externally by invoking the corresponding URL (e.g., http://localhost:8080/backup/
backup if your Jenkins instance is running locally on port 8080). In a unix environment, for example,
this would typically be scheduled as a cron job using a tool like wget or curl to start the backup.
13.4.3. More Lightweight Automated Backups
If all you want to back up is your build job configuration, the Backup Manager plugin might be
considered overkill. Another option is to use the Thin Backup plugin, which lets you schedule full and
incremental backups of your configuration files. Because they don’t save your build history or artifacts,
these backups are very fast, and there is no need to shut down the server to do them.
Like the Backup plugin, this plugin adds an icon to the Jenkins System Configuration page. From here,
you can configure and schedule your configuration backups, force an immediate backup, or restore your
354
configuration files to a previous state. Configuration is straightforward (see Figure 13.12, “Configuring
the Thin Backup plugin”), and simply involves scheduling full and incremental backups using a cron
job syntax, and providing a directory in which to store the backups.
Figure 13.12. Configuring the Thin Backup plugin
To restore a previous configuration, just go to the Restore page and choose the date of the configuration
you wish to reinstate (see Figure 13.13, “Restoring a previous configuration”). Once the configuration
has been restored to the previous state, you need to reload the Jenkins configuration from disk or restart
Jenkins.
Figure 13.13. Restoring a previous configuration
13.5. Archiving Build Jobs
Another way to address disk space issues is to delete or archive projects that are no longer active.
Archiving a project allows you to easily restore it later if you need to consult the project data or artifacts.
Archiving a project is simple: just move the build project directory out of the job directory. Of course,
typically, you would compress it into a ZIP file or a tarball first.
In the following example, we want to archive the tweeter-default project. So first we go to the Jenkins
jobs directory and create a tarball (compressed archive) of the tweeter-default build job directory:
$ cd $JENKINS_HOME/jobs
$ ls
355
gameoflife-default tweeter-default
$ tar czf tweeter-default.tgz tweeter-default
$ ls
gameoflife-default tweeter-default tweeter-default.tgz
As long as the project you want to archive is not running, you can now safely delete the project directory
and move the archive into storage:
$ rm -Rf tweeter-default
$ mv tweeter-default.tgz /data/archives/jenkins
Once you have done this, you can simply reload the configuration from the disk in the Manage Jenkins
screen (see Figure 13.14, “Reloading the configuration from disk”). The archived project will promptly
disappear from your dashboard.
Figure 13.14. Reloading the configuration from disk
On a Windows machine, you can do exactly the same thing by creating a ZIP file of the project directory.
13.6. Migrating Build Jobs
There are times when you need to move or copy Jenkins build jobs from one Jenkins instance to another,
without copying the entire Jenkins configuration. For example, you might be migrating your build jobs
to a Jenkins instance on a brand new box, with system configuration details that vary from the original
machine. Or you might be restoring an old build job that you have archived.
As we have seen, Jenkins stores all of the data it needs for a project in a subdirectory of the jobs
directory in your Jenkins home directory. This subdirectory is easy to identify—it has the same name
as your project. Incidentally, this is one reason why your project names really shouldn’t contain spaces,
particularly if Jenkins is running under Unix or Linux—it makes maintenance and admin tasks a lot
easier if the project names are also well-behaved Unix filenames.
You can copy or move build jobs between instances of projects simply enough by copying or moving the
build job directories to the new Jenkins instance. The project job directory is self-contained—it contains
both the full project configuration and all the build history. It is even safe enough to copy build job
356
directories to a running Jenkins instance, though if you are also deleting them from the original server,
you should shut this one down first. You don’t even need to restart the new Jenkins instance to see the
results of your import—just go to the Manage Jenkins screen and click on Reload Configuration From
Disk. This will load the new jobs and make them immediately visible on the Jenkins dashboard.
There are a few gotchas, however. If you are migrating your jobs to a brand new Jenkins configuration,
remember to install, or migrate, the plugins from your original server. The plugins can be found in
the plugins directory, so you can simply copy everything from this directory to the corresponding
directory in your new instance.
Of course, you might be migrating the build jobs to a new instance precisely because the plugin
configuration on the original box is a mess. Some Jenkins plugins can be a bit buggy sometimes, and
you may want to move to a clean installation with a well-known, well-defined set of vetted plugins. In
this case, you may need to rework some of your project configurations once they have been imported.
The reason for this is straightforward. When you use a plugin in a project, the project’s config.xml
will be updated with plugin-specific configuration fields. If for some reason you need to migrate projects
selectively to a Jenkins installation without these plugins installed, Jenkins will no longer understand
these parts of the project configuration. The same thing can also sometimes happen if the plugin versions
are very different on the machines, and the data format used by the plugin has changed.
If you are migrating jobs to a Jenkins instance with a different configuration, it also pays to keep an
eye on the system logs. Invalid plugin configurations will usually let you know through warnings or
exceptions. While not always fatal, these error messages often mean that the plugin will not work as
expected, or at all.
Jenkins provides some useful features to help you migrate your project configurations. If Jenkins finds
data that it thinks is out of date or invalid, it will tell you so. On the Manage Jenkins screen, you will
get a message like the one in Figure 13.15, “Jenkins will inform you if your data is not compatible with
the current version”.
Figure 13.15. Jenkins will inform you if your data is not compatible with the current version
From here, you can choose to either leave the configuration as it is (just in case you roll back to a
previous version of your Jenkins instance, for example), or let Jenkins discard the fields it cannot read.
If you choose this option, Jenkins will bring up a screen containing more details about the error, and
357
can even help tidy up your project configuration files if you wish (see Figure 13.16, “Managing out-
of-date build jobs data”).
Figure 13.16. Managing out-of-date build jobs data
This screen gives you more details about the project containing the dodgy data, as well as the exact error
message. This gives you several options. If you are sure that you no longer need the plugin that originally
created the data, you can safely remove the redundant fields by clicking on the Discard Unreadable