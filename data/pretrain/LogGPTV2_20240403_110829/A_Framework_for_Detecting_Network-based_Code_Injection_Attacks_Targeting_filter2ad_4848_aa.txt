title:A Framework for Detecting Network-based Code Injection Attacks Targeting
Windows and UNIX
author:Stig Andersson and
Andrew J. Clark and
George M. Mohay and
Bradley L. Schatz and
Jacob Zimmermann
A Framework for Detecting Network-based Code Injection Attacks Targeting
Windows and UNIX
Stig Andersson, Andrew Clark, George Mohay, Bradley Schatz and Jacob Zimmermann
Information Security Institute, Queensland University of Technology
GPO Box 2434, Brisbane 4000, Australia
{sa.andersson, a.clark, g.mohay, b.schatz, j.zimmermann}@qut.edu.au
Abstract
Code injection vulnerabilities continue to prevail. At-
tacks of this kind such as stack buffer overﬂows and heap
buffer overﬂows account for roughly half of the vulnerabil-
ities discovered in software every year. The research pre-
sented in this paper extends earlier work in the area of
code injection attack detection in UNIX environments.
It
presents a framework for detecting new or previously un-
seen code injection attacks in a heterogeneous networking
environment and compares code injection attack and de-
tection strategies used in the UNIX and Windows environ-
ments. The approach presented is capable of detecting both
obfuscated and clear text attacks, and is suitable for imple-
mentation in the Windows environment. A prototype intru-
sion detection system (IDS) capable of detecting code injec-
tion attacks, both clear text attacks and obfuscated attacks,
which targets Windows systems is presented.
1. Introduction
Code injection vulnerabilities continue to prevail despite
increasing efforts to secure applications, by methods such
as secure programming practices and patch distribution. It
has been estimated that roughly half of the vulnerabilities
discovered in software every year are code injection vul-
nerabilities. Code injection attacks operate by injecting
executable code of the attacker’s choice into a vulnerable
process. The executable code consists of machine instruc-
tions for the targeted architecture. This code is referred to
throughout this paper as shellcode, as historically the in-
jected code was constructed to spawn a shell on the target
system. The consequence of this type of attack is that the at-
tacker can potentially run arbitrary code with the privileges
of the vulnerable process.
A code injection attack injects some executable code
through an injection vector manifesting itself as a vulnera-
bility in the targeted process. Examples of attack strategies
that utilise different injection vectors are the stack buffer
overﬂow, heap buffer overﬂow and format string bugs. The
aim of this process is to inject the attacker’s executable code
and gain control of the instruction pointer of the targeted
process so that it points to, and thus transfers execution to
the attacker’s injected code.
In this paper we present a new network-based intrusion
detection system (NIDS) approach for detecting new or pre-
viously unseen code injection attacks. The research pre-
sented in this paper extends earlier work [2] in the area of
obfuscated code injection attack detection for the UNIX en-
vironment by presenting a framework for detecting both ob-
fuscated and clear text code injection attacks in a heteroge-
neous environment. The requirements for detecting attacks
targeting the Windows platform are described by compar-
ing with the previous UNIX detection work. (We are col-
lectively referring to Windows 2000, XP and 2003 as the
Windows platform).
Section 2 discusses existing approaches for detecting
code injection attacks. Sections 3 and 4 examine code
injection attack strategies, and approaches for monitoring
executable code in the Windows environment. Section 5
presents our framework for detecting the relevant attacks in
a heterogeneous environment. Sections 6 and 7 presents
our implementation of the Windows monitoring environ-
ment and test results for detecting attacks targeting Win-
dows respectively. Finally conclusions and future work are
presented in Section 8.
2. Related Work
This section examines a taxonomy of intrusion detection
systems and existing approaches to detecting code injection
attacks. The examined systems are discussed with regards
to desirable properties identiﬁed in the taxonomy.
The goal of an intrusion detection system is to detect at-
tacks against computer systems and networks. This func-
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:07:54 UTC from IEEE Xplore.  Restrictions apply. 
tionality is needed because of the difﬁculty in creating com-
puter systems that are provably secure for all intended uses.
Debar et al. have created a taxonomy of intrusion detec-
tion systems [6], by which they identify several measures
of IDS efﬁciency. Primary measures are accuracy and com-
pleteness. These terms will be used throughout the paper as
deﬁned by Debar et al.
Accuracy provides an indication of the IDS’s ability to
identify malicious activity. An erroneous alert generated
by an IDS is referred to as a false positive. Completeness
refers to the proportion of all attacks an IDS is capable of
detecting. The failure of an IDS to generate an alert in the
presence of malicious activity is referred to as a false nega-
tive. The rest of this section reviews existing approaches to
detect code injection attacks with focus on the accuracy and
completeness properties of each approach.
Signature based IDSes operate by comparing network
trafﬁc to a database of signatures describing known attacks.
If a signature matches the pattern of a sequence of bytes
in the packet the packet is considered to represent mali-
cious activity and an alert is generated. Signature based
IDSes can have good accuracy characteristics and generate
very few false positives provided that the signatures used are
well formulated. However, in practise, attaining complete-
ness is hampered by the following issues. Resent research
in the area of IDS avoidance [9] has shown that producing
exploits that avoid detection is trivial provided the signature
describes the exploit rather than the vulnerability. The com-
pleteness property of a signature based system is also lim-
ited to known attacks since the system must have a signature
for all malicious activity to provide complete coverage. De-
spite obvious shortcomings, signature based systems are the
most commonly deployed intrusion detection systems and
popular open source detectors such as Snort [5] are freely
available.
The NOP detection approach programmatically identi-
ﬁes in network trafﬁc a sequence of executable instructions
which, when executed by a processor, have the effect of in-
creasing the instruction pointer while producing negligible
side effects on the state of the program. Examples of in-
structions searched for in this approach are the NOP, POP,
INC, DEC and JMP instructions. The NOP detection ap-
proach provides an excellent completeness property for the
UNIX environment since most UNIX code injection attacks
rely on the presence of a NOP sledge. This is due to the dif-
ﬁculty in determining the location at which the exploit code
will be injected in memory of target UNIX hosts (this is
discussed in more detail in Section 3).
This detection approach does not however perform as
well in the Windows environment as the NOP sledge tech-
nique is not typically needed. This is due to the more de-
terministic nature of memory layout on this platform. Win-
dows is distributed as binary ﬁles, which in turn are pro-
duced by a smaller number of variants of compiler or pro-
gramming environment, leading to predictable and repro-
ducible determination of the location of instructions needed
to seize control of the instruction pointer. Furthermore
the accuracy of the NOP detection approach is poor be-
cause signatures matching NOP instructions also match
amounts of normal trafﬁc and therefore this approach gen-
erates scores of false positives.
The abstract payload execution detection approach [12]
operates by searching for consecutive correct and valid ma-
chine instructions in network trafﬁc. Correctness refers to
bytes identiﬁed in the network stream that represent valid
machine instructions and validity refers to valid memory
references for instructions that operate on memory. This ap-
proach has been implemented with good completeness and
accuracy properties for DNS and HTTP requests. We spec-
ulate that this approach is better suited for text based proto-
cols utilising lower case ASCII characters than it would be
for protocols that transmit binary data or protocols transmit-
ting a large number of consecutive upper case ASCII char-
acters since their hex value all represent valid single byte
machine instructions.
Speciﬁcation based systems provide excellent accuracy
and completeness properties because they explicitly model
all of the aspects of the protocols and application IO used
on the network they protect. A speciﬁcation based system
may know that the input buffer an application or a ﬁeld in
a protocol should be 256 bytes long and therefore reject all
data that exceeds the length of this input buffer. Overﬂow-
ing a buffer in an application is therefore impossible with-
out being detected and the system would never detect an
attack without the presence of malicious trafﬁc. This ap-
proach does however require that all protected applications
and protocols be analysed with regard to the size of their in-
put buffers and structure of protocols. This exercise may be
impractical especially for applications whose source is not
freely available.
The system call detection approach [1] operates by
analysing network trafﬁc searching for evidence of system
call usage in the packet payloads. Code injection attacks
that exploit UNIX hosts usually carry payloads with fre-
quent use of system calls. This approach provides good
completeness and accuracy properties for UNIX attacks that
carry the payload in clear text. The approach is however
vulnerable to attacks that carry obfuscated payloads. It is
also not suited to Windows attack detection, as the major-
ity of exploits operate by calling functions in Dynamic Link
Libraries (DLLs) instead of interacting directly with the op-
erating system (as discussed in Section 3).
The following section gives a background to code injec-
tion attack strategies.
It examines how control is gained
over the instruction pointer for Windows and UNIX envi-
ronments and how the payload of the attack must be crafted
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:07:54 UTC from IEEE Xplore.  Restrictions apply. 
differently depending on the platform that is targeted for the
attack.
3. Code Injection Attack Strategies
This section examines code injection attacks, the steps
required to gain control of the instruction pointer by mod-
ifying the instruction pointer register (EIP) and the con-
struction of the payload used in the attack. The approach
favoured in the Windows environment is compared to that
favoured in the UNIX environment.
3.1. Seizing Control of the Instruction Pointer
Code injection attacks represent a group of attacks that
attempt to break the execution path of a process by seizing
control of the instruction pointer so that the attacker’s in-
jected code is executed. This is achieved by inserting some
executable code through an injection vector. The stack over-
ﬂow, heap overﬂow and format string bugs all represent in-
jection vectors for code injection attacks. By employing an
attack of this type the attacker may potentially execute arbi-
trary code with the privileges of the vulnerable process. The
injected code may consist of machine instructions produced
by compiling a program for the operating system and archi-
tecture of the attacked system or it may contain addresses of
instructions on the system the attacker wishes to execute. In
the latter case the attack is referred to as a return-into-libc
style attack.
The stack overﬂow is the simplest code injection vector.
The attacker’s code is injected into a buffer on the stack and
the return address of the vulnerable function is overwritten
to execute the attack’s payload. The difﬁculty in performing
an attack of this type is to identify the new address to over-
write the vulnerable function’s return address with. There
are two solutions to this problem:
• A NOP sledge may be employed to increase the ad-
dress space of the entry point of the executable code.
• The exact location of an instruction that returns execu-
tion to the injected code must be used.
In the Windows environment, the latter of the two solutions
is the favoured approach since it minimises the size of the
injected code and therefore also the required buffer space.
This approach does however require that the exact address
of the needed instruction be known, which is in the case of
Linux not reliably determined, due to the following. Linux
systems come in many ﬂavours. There are different dis-
tributions and versions of software and libraries used and
they have been compiled using different compilers and dif-
ferent versions of compilers. Resultantly, it is nearly im-
possible to exactly determine both what the absolute layout
of the binary image of a process loaded in memory is, and
where the individual instructions are absolutely located, in a
widely applicable way. The NOP sledge approach is there-
fore favoured in most UNIX environments. By supplying a
long sequence of operations that logically perform no oper-
ations before the payload and an equally long sequence of
return addresses after the payload, it is sufﬁcient to guess