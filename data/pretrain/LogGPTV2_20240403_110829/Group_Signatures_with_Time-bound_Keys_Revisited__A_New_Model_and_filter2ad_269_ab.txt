tity. Hence, as in [20, 37], a signer is allowed to completely
(i.e., in the sense of zero-knowledge proofs) hide his/her ex-
piry time in our scheme.
The ﬁrst VLR group signature scheme was proposed by
Boneh and Shacham [12], and Nakanishi and Funabiki [42]
considered the notion called backward unlinkability. A sig-
nature contains a target group (i.e., GT ) element in their
scheme. Later, they proposed a more eﬃcient VLR group
signature scheme [43] whose signature contains base group
(or Zp) elements only. Hence, we employ the Nakanishi-
Funabiki scheme proposed in [43] with a slight modiﬁcation
due to the curve selection since they employed (type 2) MNT
curves [40] whereas we employ (type 3) BN curves.
2. PRELIMINARIES
In this section, we deﬁne the Complete Subtree algorithm
for time-bound keys (CS-TBK), complexity assumptions, and
the BBS+ signature scheme [6]. First, we give the deﬁnition
of the CS-TBK algorithm which implements (a special case
of) the CS method [45]. Let BT be a binary tree that has
T leaf nodes where T is the maximum size of time. The
algorithm ﬁnds subtrees that cover all non-revoked nodes.
Note that, in the Ohara et al. revocable group signature
scheme, each user is assigned to a leaf whereas each time is
sequentially assigned to a leaf node in the algorithm.
Deﬁnition 2.1
(The CS-TBK Algorithm). This algo-
rithm takes as input a binary tree BT and the current time t,
and outputs a set of nodes. If η is a non-leaf node, then ηleft
and ηright denote the left and right child of η, respectively.
Each time is sequentially assigned to a leaf node. Path(η)
denotes the set of nodes on the path from η to the root node.
The description of the algorithm is given below.
CS-TBK(BT, t) :
X, Y ← ∅;
∀1 ≤ i < t
Add Path(η) to X where i is assigned to η
∀x ∈ X
If xleft 6∈ X then add xleft to Y
If xright 6∈ X then add xright to Y
If Y = ∅ then add root to Y
Return Y
In our GS-TBK scheme, each time t is assigned to a leaf
node, and an expiry time τ is also assigned to a leaf node.
That is, one leaf node is shared by multi signers if their
expiry times are the same. If τ is assigned to a leaf node η,
the group manager generates signatures of nodes contained
in Path(η), and then these signatures are issued to signers
whose expiry time is τ . Remark that randomnesses of these
signatures are diﬀerent for signers even they share the same
leaf node. At the current time t, all leaf nodes of past time,
i.e., all left-side leaves of the leaf node assigned to t are
revoked.2 Next, the group manager generates signatures of
nodes generated by the CS-TBK algorithm, and publishes
signatures as expiration information eit at time t. If t < τ ,
then the corresponding signers have a signature of a node
such that eit contains a signature of the same node.
We give an example in the case of T = 8 as follows. We
show a case that τ has not passed in Fig 1, and also show a
case that τ has passed in Fig 2. Let τ be assigned to the node
11. Then, signers whose expiry time is τ have signatures of
nodes 1, 2, 5, and 11. In Fig 1, nodes 8 and 9 are revoked.
Then, nodes 3 and 5 are selected as roots of subtrees. Thus,
2In the usual CS method, a user is associated to a leaf node,
and who will be revoked is not predictable. So, the size of
Y is O(r log(N/r)) where N is the number of users (leaves),
and r is the number of revoked signers. On the other hand,
in our usage, though a time is associated to a leaf node as
usual, leaves are “sequentially” revoked. So, the size of Y is
at most log T . This is essentially the same as the encoding
for attribute-based encryption with range membership [5].
779Time has 
passed
Time has 
passed
Figure 1: τ has not passed
Figure 2: τ has passed
eit contains signatures of nodes 3 and 5. Then, the signers
can prove that they have a signature of the node 5 (without
revealing the node itself). In Fig 2, eit contains a signature
of the node 3 only. Since τ has passed, signatures of 1, 2, 5,
and 11 are not contained in eit.
Next, we deﬁne complexity assumptions. Let p be a λ-bit
prime, G1, G2 and GT are groups of order p, e : G1 × G2 →
GT is a bilinear map, and g,bg are generators of G1 and G2,
respectively. We use the asymmetric setting (type 3 curves),
i.e., G1 6= G2, and no eﬃcient isomorphism between G1 and
G2 is known.
Next, we deﬁne decision Diﬃe-Hellman assumption on G1
(DDH1) as follows.
Deﬁnition 2.2
G2, GT , e, g,bg), a, b $← Z∗
(DDH1 Assumption). Let D := (G1,
p and Z $← G1 \ {gab}. We say that
the DDH1 assumption holds if for any probabilistic polyno-
mial time (PPT) adversary A, the advantage AdvDDH1(λ) :=
| Pr[A(D, ga, gb, gab) → true] − Pr[A(D, ga, gb, Z) → true]|
is negligible.
Next, we deﬁne the decision linear (DLIN) assumption. Here,
we use an asymmetric variant [27].
Deﬁnition 2.3
(DLIN Assumption). Let D := (G1,
assumption holds if for any PPT adversary A, the advantage
G2, GT , e,eg,bg), a, b, c, d $← Z∗
p, g′ := egc, bg′ := bgc, h := egd,
bh := bgd, and Z $← G1 \ {ha+b}. We say that the DLIN
AdvDLIN(λ) := | Pr[A(D, g′,bg′, h,bh,ega, g′b, ha+b) → true] −
Pr[A(D, g′,bg′, h,bh,ega, g′b, Z) → true]| is negligible.
Next, we deﬁne the q-Strong Diﬃe-Hellman (q-SDH) as-
sumption as follows. Here, we use an asymmetric vari-
ant [16].
Deﬁnition 2.4
G2, GT , e, g,bg) and x $← Z∗
(q-SDH Assumption). Let D := (G1,
p. We say that the q-SDH as-
sumption holds if for any PPT adversary A, the advantage
Advq-SDH(λ) := Pr[A(D, gx, gx2
∈ Zp \ {−x} × G1] is negligible.
, . . . , gxq
,bgx) → (c, g1/(x+c))
Next, we deﬁne the discrete logarithm (DL) assumption (on
G1) as follows.
Deﬁnition 2.5
(DL Assumption). Let D := (G1, G2,
p. We say that the DL assumption
GT , e, g,bg) and x $← Z∗
holds if for any PPT adversary A, the advantage AdvDL(λ) :=
Pr[A(D, gx) → x] is negligible.
Next, we introduce the BBS+ signature scheme [6], espe-
cially, the BBS+ signature scheme over a type 3 curve [16].
This scheme allows to sign L messages, and is existential
unforgeable against chosen message attack under the q-SDH
assumption. Let g, h0, h1, . . . , gL be generators of G1, bg be
a generator of G2, and e : G1 × G2 → GT be a bilinear map.
The BBS+ signature scheme [6]
Key Generation: Choose γ $← Z∗
veriﬁcation key is vk = w, and the secret key is sk = γ.
p, and let w = bgγ. The
p , choose ξ, ζ $←
Sign: For the messages (m1, . . . , mL) ∈ ZL
· · · hmL
L )
ξ+γ . Output
Zp and compute A = (ghζ
the signature σ = (A, ξ, ζ).
0hm1
1
1
Verify: For a signature σ = (A, ξ, ζ) and messages (m1, . . . ,
mL), if e(A,bgξvk) = e(ghζ
output 1, and otherwise output 0.
0hm1
1
· · · hmL
L ,bg) holds, then
3. DEFINITION OF GROUP SIGNATURES
WITH TIME-BOUND KEYS
In this section, we give the deﬁnition of GS-TBK. We
mainly follow the deﬁnition of Chu et al. [20, 37]. We ad-
ditionally introduce unforgeability of expiry time of signing
keys, backward unlinkability, and non-frameability against
malicious group manager. Moreover, our model introduces
expiration information eit.
In contrast to the model of group signatures [8, 9, 13,
52], a revocation token grti is generated when a signer i
joins the group. Revocation tokens are modiﬁed according
to the current time period t. We denote it grti,t, and grti,t is
contained in the revocation list RLt if the signer i is revoked
at t, and is used for the revocation check. We emphasize
that if τi < t, then grti,t does not have to be contained in
RLt since expiry time has passed. On the other hand, in the
case of VLR group signatures, all grti,t, . . . , grti,T need to
be contained in RLt. So, the size of revocation list can be
reduced due to time-bound keys. Moreover, in the model,
a signing key gski is associated with an expiry time τi, and
the signing algorithm takes as input the current time t.
A GS-TBK scheme GS-T BK consists of six algorithms:
(GKeyGen, Join/Issue, Revoke, Sign, Verify, Open) which are
deﬁned as follows.
Deﬁnition 3.1
(Syntax of GS-TBK).
GKeyGen: The group key generation algorithm takes as input
a security parameter λ ∈ N, and outputs a group public
780key gpk and a master secret key msk. Set a registration
table reg := ∅. We assume that the maximum size of
expiry time T also contained in gpk.
Join/Issue: This is the pair of interactive algorithms which
implement the joining protocol run by a user i and the
group manager. The joining algorithm Join takes as
input gpk, whereas the issuing algorithm Issue takes as
input msk, reg, and an expiry time τi. Upon successful
completion of the protocol, the Join algorithm outputs
a signing key gski, τi, and a user secret key uski, and
the Issue algorithm outputs reg where reg[i] stores a
revocation token grti and τi.
Revoke: The revocation algorithm takes as input gpk, msk,
t, reg, and a set of signers to be revoked at t RUt. Let a
set of their revocation tokens grti and its expiry time τi
be {reg[i] := (grti, τi)} which are contained in reg. Set
RLt := ∅. For each i, the algorithm computes grti,t if
τi has not passed, i.e., t < τi, and stores grti,t to RLt.
Moreover, the algorithm computes expiration informa-
tion eit. Finally, the algorithm outputs (eit, RLt).
Sign: The signing algorithm takes as input gpk, gski, uski,
a message to be signed m, the current time t, and eit,
and outputs a signature σ.
Verify: The veriﬁcation algorithm takes as input gpk, t, σ,
m, and RLt, and outputs either valid or invalid.
Open: The opening algorithm takes as input gpk, msk, t,
reg, σ, m, and RLt, and outputs the identity of the
signer i or ⊥.
The correctness is deﬁned as follows. This guarantees that
a group signature generated by a signing key with τi at time
t∗, where t∗ < τi and the signer i is not revoked at time t∗,
is valid, and the opening result correctly indicates i.
Deﬁnition 3.2
(Correctness). For any PPT adver-
sary A and the security parameter λ ∈ N, we deﬁne the
experiment Expcorr
GS-TBK,A(λ) as follows.
Expcorr
GS-TBK,A(λ) :
(gpk, msk, reg) ← GKeyGen(λ); HU := ∅
(i, m, t∗) ← AAddU,RReg,Revoke(gpk); i ∈ HU \ RUt∗ ; t∗ < τi
σ ← Sign(gpk, gski, uski, m, t∗, eit∗ )
j ← Open(gpk, msk, t∗, reg, σ, m, RLt)
Return 1 if the following holds :
Verify(gpk, t∗, σ, m, RLt∗ ) = invalid ∨ i 6= j
Otherwise return 0
• AddU: The add user oracle allows an adversary A to
add honest users to the group. On input an identity
i and τi, this oracle computes (gski, τi) by running
Join/Issue. i is added to HU.
• RReg: On input i, the read-registration-table oracle re-
veals the content of the registration table reg[i].
• Revoke: Let t − 1 be the time that the oracle is called.
The revocation oracle allows A to revoke honest users.
On input identities RUt, this oracle runs RLt ← Revoke
(gpk, msk, t, reg, RUt), and outputs (eit, RLt).
We say that GS-T BK is correct if the advantage
Advcorr
GS,A(λ) := Pr[Expcorr
GS-TBK,A(λ) = 1]
is negligible for any PPT adversary A.
The anonymity with backward unlinkability (BU-anonymity)
is deﬁned as follows. This guarantees that no signer identity
is revealed from signatures even the corresponding signer
has been revoked. We follow selﬂess CPA anonymity [20,
37] where an adversary is allowed to obtain signing keys ex-
cept the challenge users’ keys,3 and is not allowed to access
the open oracle.
Deﬁnition 3.3
(BU-Anonymity). For any PPT ad-
versary A and a security parameter λ ∈ N, we deﬁne the
experiment Expbu-anon
GS-TBK,A(λ) as follows.
Expbu-anon
GS-TBK,A(λ) :
b $← {0, 1}
(gpk, msk, reg) ← GKeyGen(λ)
HU := ∅; CU := ∅; RU := ∅
b′ ← AAddU,WReg,USK,Revoke,GSign,Chb (gpk)
Return 1 if b′ = b, and 0 otherwise
• AddU: The add user oracle allows an adversary A to
add honest users to the group. On input an identity
i and τi, this oracle computes (gski, τi) by running
Join/Issue. i is added to HU.
• WReg: On input i and M , the write-registration-table
oracle updates reg[i] to M .
• USK: On input i, the user-secret-keys oracle reveals
(gski, uski) and adds i to CU.
• Revoke: Let t − 1 be the time that the oracle is called.
The revocation oracle allows A to revoke honest users.
On input identities RUt, this oracle runs RLt ← Revoke
(gpk, msk, t, reg, RUt), outputs (eit, RLt), adds RUt to
RU. Remark that i0 and i1 can be revoked if t∗ < t.
• GSign: On input i and m where i ∈ HU, the signing or-
acle computes σ ← Sign(gpk, gski, uski, m, t, eit) and
returns σ. Here, t is the current time that the oracle
called.
• Chb: On input i0, i1, where i0, i1 ∈ HU, and m∗,
the challenge oracle computes σ∗ ← Sign(gpk, gskib ,
uskib , m∗, t∗, eit∗ ) and returns σ∗. Here, i0, i1 6∈ CU,
i0, i1 6∈ RU, t∗ < τi0 , and t∗ < τi1 must hold.
We say that GS-T BK is BU-anonymous if the advantage
Advbu-anon
GS-TDL,A(λ) := |Pr[Expbu-anon
GS-TBK,A(λ) = 1] − 1/2|
is negligible for any PPT adversary A.
3We call anonymity full anonymity if the adversary is al-
lowed to obtain all signing keys. As a theoretical result,
selﬂess anonymity is weaker than full anonymity since the
former can be constructed from one-way functions and NIZK
arguments [17] whereas the latter implies pubic key encryp-
tion [1, 24, 48]. We employ the selﬂess anonymity in this
paper, as in the previous works [20, 37] and VLR group sig-
nature schemes since a revocation token can be computed
by a signing key.
781The traceability is deﬁned as follows. We mainly follow the
deﬁnition of [20, 37] except that we additionally consider
unforgeability of expiry time of signing keys (the winning
condition (4) in the experiment). Traceability guarantees
that no adversary who does not have a signing key can com-