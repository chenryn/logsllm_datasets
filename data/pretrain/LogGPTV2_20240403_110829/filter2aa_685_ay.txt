echo("All tests finished successfully!")
This test is very large. It tests the database module as a whole, which is necessary to
test it fully. Try to compile it yourself, and you should see the two messages displayed
on your screen followed by “All tests finished successfully!”
 That’s it for this section. The database module is complete, and it can store infor-
mation about users including who they’re following and the messages they post. The
module can also read that data back. All of this is exposed in an API that abstracts the
database away and defines only the procedures needed to build the Tweeter web
application. 
7.4
Developing the web application’s view
Now that the database module is complete, it’s time to start developing the web com-
ponent of this application.
 The database module provides the data needed by the application. It’s the equiva-
lent of the model component in the MVC architectural pattern. The two components
that are left are the view and the controller. The controller acts as a link joining the
view and model components together, so it’s best to implement the view first.
 In Tweeter’s case, the view will contain multiple modules, each defining one or
more procedures that will take data as input and return HTML as output. The HTML
will represent the data in a way that can be rendered by a web browser and displayed
appropriately to the user.
 One of the view procedures will be called renderUser. It will take a User object and
generate HTML, which will be returned as a string. Figure 7.12 is a simplified illustra-
tion of how this procedure, together with the database module and the controller,
will display the information about a user to the person accessing the web application.
Tests the findUser procedure. It should 
return true in both cases because the d0m96 
and nim_lang users have been created.
Tests the follow procedure
Rereads the user information for 
d0m96 to ensure that the 
“following” information is correct
Tests the findMessages procedure
Licensed to   
201
Developing the web application’s view
There are many ways to implement procedures that convert information into HTML,
like the renderUser procedure. One way is to use the % string formatting operator to
build up a string based on the data:
import strutils
proc renderUser(user: User): string =
return "$1Following: $2" %
[user.username, $user.following.len]
Unfortunately, this is very error prone, and it doesn’t ensure that special characters
such as ampersands or 
  d0m96 
  Following: 2 
Stored in user variable
Stored in html variable
Figure 7.12
The process of displaying information about a user in the web browser
Licensed to   
202
CHAPTER 7
Building a Twitter clone
Nim supports two methods of generating HTML that are more intuitive. The first is
defined in the htmlgen module. This module defines a DSL for generating HTML.
Here’s how it can be used:
import htmlgen
proc renderUser(user: User): string =
return `div`(
h1(user.username),
span("Following: ", $user.following.len)
)
This method of generating HTML is great when the generated HTML is small. But
there’s another more powerful method of generating HTML called filters. The follow-
ing listing shows filters in action.
#? stdtmpl(subsChar = '$', metaChar = '#')
#import "../database"
#
#proc renderUser*(user: User): string =
#
result = ""
${user.username}
${$user.following.len}
#end proc
#
#when isMainModule:
#
echo renderUser(User(username: "d0m96", following: @[]))
#end when
Filters allow you to mix Nim code together with any other code. This way, HTML can
be written verbatim and Nim code can still be used. Create a new folder called views in
the src directory of Tweeter, and then save the contents of listing 7.18 into
views/user.nim. Then, compile the file. You should see the following output:
d0m96
0
Filters are very powerful and can be customized extensively.
Listing 7.18
Using a Nim filter to generate HTML
The backticks (`) around the div are 
needed because “div” is a keyword.
The username passed to h1 
becomes the  tag’s content.
Only strings are accepted, so the
length must be explicitly converted
to a string using the $ operator.
This line, the filter definition, 
allows you to customize the 
behavior of the filter.
This file assumes that it’s placed in a 
views subdirectory. This is why the “..” 
is necessary to import "database".
In the filter, an ordinary procedure is created, and 
in it you need to initialize the result variable.
In filters, it’s important to ensure 
that all lines are prefixed with #.
Each line that doesn’t begin with # is 
converted to result.add by the compiler.
Keywords delimit 
where the 
procedure ends 
because 
indentation 
doesn’t work well 
in templates such 
as these.
Licensed to   
203
Developing the web application’s view
WARNING: AN IMPORTANT FILTER GOTCHA
When writing filters, be sure that all
the empty lines are prefixed with #. If you forget to do so, you’ll get errors
such as “undeclared identifier: result” in your code.
Figure 7.13 shows the view that the renderUser procedure will create.
The code shown in listing 7.18 still suffers from the same problems as the first exam-
ple in this section: it doesn’t escape special characters. But thanks to the filter’s flexi-
bility, this can easily be repaired, as follows.
#? stdtmpl(subsChar = '$', metaChar = '#', toString = "xmltree.escape")
#import "../database"
#import xmltree
#
#proc renderUser*(user: User): string =
#
result = ""
${user.username}
Following: ${$user.following.len}
#end proc
#
#when isMainModule:
#
echo renderUser(User(username: "d0m96<>", following: @[]))
#end when
FILTER DEFINITIONS
You can learn more about how to customize filters by tak-
ing a look at their documentation: http://nim-lang.org/docs/filters.html.
Save this file in views/user.nim and note the new output. Everything should be as
before, except for the  tag, which should read d0m96&lt;&gt;. Note
how the <> is escaped as &lt;&gt;.
Listing 7.19
Escaping special characters in views/user.nim
${user.username}
${$user.following.len}
Figure 7.13
The view created by listing 7.18
This parameter specifies the
operation applied to each
expression, such as
${user.username}. Here, the
toString parameter is overwritten
with a new xmltree.escape string
to escape the expression.
The xmltree module that defines 
escape needs to be imported.
The username of the user is now
d0m96<> to test the escape mechanism.
Licensed to   
204
CHAPTER 7
Building a Twitter clone
7.4.1
Developing the user view
The vast majority of the user view is already implemented in the view/user.nim file. The
procedures defined in this view will be used whenever a specific user’s page is accessed.
 The user’s page will display some basic information about the user and all of the
user’s messages. Basic information about the user is already presented in the form of
HTML by the renderUser procedure.
 The renderUser procedure needs to include Follow and Unfollow buttons. Instead
of making the renderUser procedure more complicated, let’s overload it with a new
renderUser procedure that takes an additional parameter called currentUser. The
following listing shows its implementation. Add it to the view/user.nim file.
#proc renderUser*(user: User, currentUser: User): string =
#
result = ""
${user.username}
Following: ${$user.following.len}
#if user.username notin currentUser.following:
#end if
#
#end proc
Figure 7.14 shows what the follow button will look like once its rendered.
Listing 7.20
The second renderUser procedure
This procedure definition is almost identical 
to the previous renderUser procedure. The 
difference is in the parameters, in this case 
the addition of the currentUser parameter.
Checks to see if the currently
logged-in user is already
following the specified user. If
not, creates a Follow button.
Adds a form that 
contains a Follow 
or Unfollow 
button. The form 
is submitted to 
the /follow route.
Hidden fields are used to pass
information to the /follow route.
Figure 7.14
The Follow button constructed by renderUser in listing 7.20
Licensed to   
205
Developing the web application’s view
Now, let’s implement a renderMessages procedure. The next listing shows the full
implementation of the renderMessages procedure, together with the renderUser
procedures implemented in the previous section.
#? stdtmpl(subsChar = '$', metaChar = '#', toString = "xmltree.escape")
#import "../database"
#import xmltree
#import times
#
#proc renderUser*(user: User): string =
#
result = ""
${user.username}
Following: ${$user.following.len}
#end proc
#
#proc renderUser*(user: User, currentUser: User): string =
#
result = ""
${user.username}
Following: ${$user.following.len}
#if user.username notin currentUser.following:
#end if
#
#end proc
#
#proc renderMessages*(messages: seq[Message]): string =
#
result = ""
#for message in messages:
${message.username}
${message.time.getGMTime().format("HH:mm MMMM d',' yyyy")}
${message.msg}
#end for
#end proc
Listing 7.21
Final views/user.nim with the new renderMessages procedure
The times module is imported 
so that the time can be 
formatted.
The new renderMessages
procedure takes a list of messages
and returns a single string.
Iterates through all messages. All the following HTML 
code will be added verbatim in each iteration.
The procedure will first emit a new  tag.
Adds the username to the HTML first.
The for loop is explicitly finished
by the “end for” keywords.
Message text is added last.
The time when the message was created is
formatted and added to the HTML.
As before, result is initialized so that 
text can be appended to it by the filter.
Licensed to   
206
CHAPTER 7
Building a Twitter clone
#
#when isMainModule:
#
echo renderUser(User(username: "d0m96<>", following: @[]))
#
echo renderMessages(@[
#
Message(username: "d0m96", time: getTime(), msg: "Hello World!"),
#
Message(username: "d0m96", time: getTime(), msg: "Testing")
#
])
#end when
Replace the contents of your views/user.nim file with the contents of listing 7.21.
Then compile and run it. You should see something similar to the following:
d0m96&lt;&gt;
Following: 0
d0m96
12:37 March 2, 2016
Hello World!
d0m96
12:37 March 2, 2016
Testing
Figure 7.15 shows what the rendered message will look like.
 And that’s it for the user view. All you need to do now is build the remaining views. 
The renderMessages procedure
is tested with some messages.
Figure 7.15
A message produced by renderMessages
Licensed to   
207
Developing the web application’s view
7.4.2
Developing the general view
The user view will be used for a specific user’s page. All that remains to be created is
the front page. The front page will either show a login form or, if the user has logged
in, it will show the messages posted by the people that the user follows.
 This general view will be used as the front page of Tweeter, so for simplicity we’ll
implement the procedures in a new file called general.nim. Create this file in the
views directory now.
 One important procedure that we haven’t implemented yet is one that will gener-
ate the main body of the HTML page. Let’s implement this now as a renderMain pro-
cedure and add it to the new general.nim file. The following listing shows the
implementation of renderMain.
#? stdtmpl(subsChar = '$', metaChar = '#')
#import xmltree
#
#proc `$!`(text: string): string = escape(text)
#end proc
#
#proc renderMain*(body: string): string =
#
result = ""
Tweeter written in Nim
${body}
#end proc
The code is fairly straightforward. The renderMain procedure takes a parameter
called body containing the HTML code that should be inserted into the body of the
HTML page. In comparison to listing 7.21, the toString parameter is no longer used
to ensure that the body isn’t escaped. Instead, a new operator called $! has been intro-
duced. This operator is simply an alias for the escape procedure. This means that you
can easily decide which of the strings you’re embedding will be escaped and which
won’t be.
 Now that the renderMain procedure has been implemented, it’s time to move on
to implementing the remaining two procedures: renderLogin and renderTimeline.
The first procedure will show a simple login form, and the second will show the user
their timeline. The timeline is the messages posted by people that the user is following.
Listing 7.22
Implementing the renderMain procedure
The toString parameter is no 
longer set in the filter definition.
Defines a new operator that can 
be used to escape text easily
Defines the renderMain procedure, 
which simply generates a new HTML 
document and inserts the body of 
the page inside the  tag
Licensed to   
208
CHAPTER 7
Building a Twitter clone
 Let’s start with renderLogin. The following listing shows how it can be implemented.
#proc renderLogin*(): string =
#
result = ""
Login
Please type in your username...
#end proc
This procedure is very simple because it doesn’t take any arguments. It simply returns
a piece of static HTML representing a login form. Figure 7.16 shows what this looks
like when rendered in a web browser. Add this procedure to the bottom of the general