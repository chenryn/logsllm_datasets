into 34 categories. Thus, at least 34 roles are set of initialization in 
our model and users can assign one or more roles to an application 
after the installation, besides, a role can be assigned to one or more 
applications  after  the  definition.    A  role  named  SYSTEM  is 
assigned to all the system applications by default. Any other new 
roles can be defined or delete by users. Consider two applications A 
and B, A is the caller in an ICC or it is to access a file created by 
application B. Case1: Application A with the SYSTEM role. There 
is no need to deal with anything.  Case 2: Application A and B are 
third-party applications. In this case further inspection of the roles is 
needed.  
2.2.5  Policy creation and management 
We  propose  a  model  named  ARBAC  to  create  and  manage  the 
security policies by combining Role-Based Access Control (RBAC) 
with  Attribute-Based  Access  Control  (ABAC).    In  ARBAC,  the 
privileges  of  accessing  to  resources  (files,  applications,  etc.)  are 
dynamically assigned to the applications depending on the attribute 
values  (permissions,  roles  etc.)  at  the  kernel.  And  in  the 
middleware,  privileges  to  perform  operations  (establishing  ICCs 
etc.)  and  the  resources  (the  content  of  ICCs  etc.)  are  also 
dynamically  assigned  to  applications  depending  on  their  attribute 
values(permissions, roles etc.).  
Each policy is encapsulated as an independent atom policy to ensure 
the compatibility and scalability of ARBAC. The final decision is 
made of the combination of all these atom policies. What is more, 
the policies have different priorities for access control. With all the 
defined entities and their attributes, single policy can be described 
as below: 
                  Policyi ::={ Rule1, Rule2…Rulei…Rulen, prii}.        (1) 
Where  n>0,  Rulei  is  an  expression  which  composed  of  attribute 
value with logical operators. prii is the priority of this policy. The 
final decision is made by the combine function: 
              Decision ← fcombine (Policy1, Policy2…Policyn).      (2) 
2.3  Component Interaction 
The  architecture  is  presented  in  Figure  2.  In  the  following 
paragraphs, we will introduce the interactions among each module 
of the framework. The main analysis involves two processes: ICC 
call handling (step 1-10), creating or writing a file (step a-d) and file 
read access (steps ⅰ-ⅴ). 
Figure 1. Privacy Type Based Access Control. 
As shown in Fig. 1, when App A writes data to a file, the privacy 
check  model  will  confirm  whether  the  data  contains  confidential 
information. When App B is to access the file, PTBAC will check 
whether the file is tainted and enforce access control. 
Figure 2. Interactions among the components. 
1412it 
the 
call. 
invokes 
Further, 
ICC  call, 
the  DecisionEngine 
ICC  calls  handling. All the ICC calls shall  be intercepted by the 
ReferenceMonitor (step 1). It calls the PackageManager (step 2) to 
query the database for validating permission assignments about the 
caller and callee. The PackageManager then calculates Pescalation of 
the  two  intercepting  components  and  records  it  to  the  Android 
permission  database  (step  3).  This  will  result  in  the  callee  with  a 
reduced  permission  set  during  the  first  life  cycle.  Then  the 
PackageManager  returns  the  validated  results  (step  4-5).  If  the 
ReferenceMonitor  allows 
the 
DecisionEngine (step 6) to ensure the communication complies with 
other  security  policies.  Next,  the DecisionEngine  intercepts  to  the 
PrivacyChecker (step 7). The PrivacyChecker will tackle the Intent 
parcel to obtain the tainted tag at the message level provided by the 
TaintDroid  project.  If  the  Intent  parcel  contains  tainted  data,  the 
DecisionEngine  then  requests  for  a  policy  corresponding  to  this 
particular type of ICC calls from the policy database (step 8). If a 
matching  policy  is  found,  it  means  that  the  user  allows  for  this 
particular 
informs 
ReferenceMonitor  about  decisions  it  has  made  (step  9),  and 
ReferenceMonitor either allows (step 10) or denies the call. 
Operation on files. Files and sockets are most usually made use of 
to  establish  various  channels  for  colluding  applications  to  interact 
with  each  other.  The  PTBAC  involves  when  an  application 
performs operations on a file or socket. When a file (step a) is to be 
written,  the  PrivacyChecker  is  performing  runtime  monitoring  all 
the  time.  If  the  taint  tracking  system  becomes  aware  of  that 
particular type of privacy data are written to the file(step b), the file 
becomes  tainted,  then  the  taint  information  will  be  analyzed  and 
stored to the policy database (step c). When another application is to 
access the file,  or  make a connection to the local socket  (stepⅰ), 
PTBAC mechanism will check the application what permissions it 
have,  and  query  the  policy  database  (stepⅱ-ⅲ).  If  a  matching 
policy  is  found,  it  means  that  this  particular  access  request  is 
allowed  by  the  user.  Further,  the  DecisionEngine  informs  the 
mandatory access control (MAC) module in the Linux kernel about 
the decision it has made (stepⅳ), and MAC module either allows 
(stepⅴ) or denies the access request. 
3.  EVALUATION 
We  ran  a  series  of  tests  to  evaluate  our  framework  which  was 
installed  on  a  HUAWEI  T8808D  with  a  modified  version  4.1. 
Firstly  we  evaluate  the  default  case  without  any  security  settings. 
Attacks  published  in  [7,  9,  10]  can  all  be  prevented  by  the 
framework,  but  some  third-party  applications  that  need  working 
together to perform didn’t work. Secondly, we assign a role to these 
applications and then they work normally. Thirdly, some collusion 
attacks  were  tested  using  covert  channels  with  Single  Setting, 
Multiple Settings and Automatic Intents, and these attacks can all be 
detected.  However,  the  channels  using  /proc/stat  and  Threads 
Enumeration  cannot  be  blocked  until  we  enforce  extra  policies. 
Finally we compared our framework to the previous shown in Table 
1. 
Table 1. Prevention effect of the countermeasures 
Privilege Escalation Attack 
Confused Deputy 
Attacks(50 samples) 
Effective and flexible 
Ineffective 
Collusion Attacks 
(7 samples) 
High false positives 
Tracking privacy flow 
Effective and flexible 
No false positives 
Framework 
XManDroid 
TaintDroid 
Our Design 
We haven’t run tests on the performance overhead of quantitative, 
but it is below human perception in our test and we didn’t notice 
any  performance  delays.  The  performance  overhead  is  mainly 
caused by the dynamic taint tracking. 
4.  CONCLUSION 
We presented a new extension to the Android in order to prevent 
privilege  escalation  attacks.  It  is  an  improvement  of  XManDroid 
and  also  is  policy-centered.  The  framework  analyzes  application 
communication in permission and content to ensure it complies with 
the two design principles. In contrast to XManDroid, a role-based 
management model is embedded in our framework which enables 
the user to set a white-list, maintaining the call-chains or accesses 
that  can  be  allowed  by  the  system.  In  this  architecture,  the 
advantages of policy-centered framework are preserved and we can 
reduce the false positives of preventing the collusion attacks. Test 
result show it is efficient. Besides, our framework does not rely on 
the application developers to perform extra work. 
ACKNOWLEDGMENTS 
Our  work  was  supported  by  the  Google’s  Academic  Cooperation 
Program and the Natural Science Foundation of China under Grant 
No.61272481. 
5.  REFERENCES 
[1]  Google Android. http://www.android.com/. 
[2]  W. Enck, P. Gilbert, B.-G. Chun et al., TaintDroid: an 
information-flow tracking system for real-time privacy 
monitoring on smart phones. In Proc. of the 9th USENIX 
conference on Operating systems design and implementation, 
Vancouver, British Columbia, Canada, pages 1–6. USENIX 
Association, October 2010. 
[3]  S. Bugiel, L. Davi, A. Dmitrienko et al. Towards taming 
[4]  N. Husted, H. Sa ̈di et al., Smartphone security limitations: 
privilege escalation attacks on android. In Proc. of the 19th 
Annual Network & Distributed System Security Symposium 
(NDSS’12), San Diego, CA, USA, February 2012. 
conflicting traditions. In Proc. of the 2011 Workshop on 
Governance of Technology, Information, and Policies 
(GTIP’11), New York, USA, pages 5–12. ACM, Dec. 2011. 
[5]  Y. Zhou and X. Jiang. Dissecting android malware: 
Characterization and evolution. In Proc. of the 33rd IEEE 
Symposium on the Security and Privacy, San Francisco, 
California, USA, pages 95–109. IEEE, May 2012. 
[6]  Claudio Marforio et al. Application Collusion Attack on the 
Permission-Based Security Model and its Implications for 
Modern Smartphone Systems. Tech. Report 724, Apr. 2011. 
[7]  Roman Schlegel et al. Soundcomber: A Stealthy and Context-
Aware Sound Trojan for smart phones. In Proceedings of the 
18th Annual Network and Distributed System Security 
Symposium (NDSS), Feb. 2011. 
[8]  S. Bugiel, L. Davi et al. XManDroid: A new android evolution 
to mitigate privilege escalation attacks. Technical Report 04, 
Technische University at Darmstadt, 2011. 
[9]  W. Enck, M. Ongtang, and P. McDaniel. Mitigating Android 
software misuse before it happens. Technical Report NAS-TR-
0094-2008, Penn. State University, 2008. 
[10] L. Davi, A. Dmitrienko, A.-R. Sadeghi, and M. Winandy. 
Privilege escalation attacks on Android. In Proceedings of the 
13th Information Security Conference (ISC), 2010. 
[11] M. Dietz et al. Quire: Lightweight provenance for smart phone 
operating systems. In Proc. of the 20th USENIX Security 
Symposium (USENIX Security’11), San Francisco, California, 
USA, pages 51–58, August 2011.
1413