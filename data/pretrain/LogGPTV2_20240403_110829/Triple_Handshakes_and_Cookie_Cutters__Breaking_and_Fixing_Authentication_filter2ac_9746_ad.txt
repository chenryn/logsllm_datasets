on a new connection, A simply forwards the request to S, and
forwards S’s response to C unchanged. C and S complete
the handshake through A, re-using the master secret known
to C, S, and A, as shown in the top half of Connection 2 in
Figure 3. The resulting epochs on the two connections have the
same keys, also shared with A. The new epochs are, in fact,
more synchronized than the epochs on the original connection:
the client and server verify data on these epochs are also the
same. Hence, after resumption, the only noticeable difference
between the two connections is that the C-A connection has
a session with server identity cert A while the A-S connection
has a session with server identity cert S. All other differences
have been erased. This is important for the attacks in §VI.
The ease with which resumed sessions can be synchronized
exposes the weak authentication guarantees of the abbreviated
handshake. It only ensures that the client and server share
the same master secret, whereas applications may (and do)
assume that they share the same session, which we show is not
the case. To obtain stronger guarantees from this handshake,
in §VII we propose a TLS extension, similar to [49], that links
the resumption handshake to the original session.
VI. ATTACKS ON CLIENT AUTHENTICATION OVER TLS
TLS is most commonly used in the anonymous-client mode,
where only the server is authenticated. Consequently, appli-
cations often deploy their own mechanisms and protocols to
authenticate users after the TLS handshake has ﬁnished.
Previous work shows that layering a client authentication
protocol within a server-authenticated secure channel is vul-
nerable to generic man-in-the-middle attacks [8, 41]; Ray’s
renegotiation attack [45] is also an instance of this pattern.
If an attacker A can see application-level protocol messages
between C and S, it can tunnel these messages through its
own connection with S, thereby impersonating C at S.
This attack is possible in three scenarios. First,
if the
client C uses the same application-level credentials on en-
crypted and unencrypted channels. Second,
if C uses the
same credentials on different servers, one of which could be
malicious. Third, if C fails to correctly validate the server
identity and confuses a malicious server A with an honest
server S. In all
the application-level protocol
should guarantee that the credentials released by C to A cannot
be used by A at S.
these cases,
A common pattern to enforce this guarantee is to crypto-
graphically bind the (inner) application authentication to the
(outer) underlying TLS channel [8, 6, 49]. This binding helps
only inasmuch as the inner protocol employs strong keys (pub-
lic or secret) or a passphrase-based challenge-response scheme
106
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:56 UTC from IEEE Xplore.  Restrictions apply. 
resistant to dictionary attacks. Conversely, bearer tokens cannot
be protected. In this section, we discuss four such binding
mechanisms, and show how to break their guarantees using
the synchronizing TLS proxy of §V.
VI-A THE TRIPLE HANDSHAKE ATTACK. Suppose the at-
tacker A has an anonymous-client TLS connection to server S.
When A tries to access a user-protected resource, S triggers
a renegotiation to require A to authenticate as a valid user,
with a client certiﬁcate or some other credential (PSK, SRP,
etc.). This pattern is enabled, for example, on the Apache web
server, when a client tries to access a protected directory.
A wants to authenticate to S as C (without C’s credentials).
More generally, even if A has previously authenticated to S,
it wants to change its authenticated identity to C.
to recall
is useful
Before explaining our attack,
the
2009 renegotiation attack [45] and countermeasure [49], which
cryptographically binds each handshake on a connection to
the preceding one, by passing the verify data of the previous
handshake (if there was one) in the client and server hellos of
the new handshake. Therefore, if A initiates a full handshake
with S, but later tries to forward C’s handshake to S as a
renegotiation, the verify data in C’s hello would not match A’s
handshake, prompting the server to reject the renegotiation.
What if a session is resumed on a new connection? The
it only
ﬁrst handshake now is an abbreviated handshake;
authenticates the session master secret, not the whole session.
Thus, the renegotiation countermeasure does nothing to bind
the new connection to the old session. This re-enables the man-
in-the-middle impersonation attack it was meant to ﬁx.
it
Assume the adversary A has set up synchronized sessions
and connections with C and S. If C resumes the session on a
new connection, A can resume the same session on a new
connection to S. As discussed in §V-C, at the end of the
abbreviated handshake, the verify data on both connections is
the same. Now, if C or S initiates a client-authenticated TLS
renegotiation, A can simply forward all messages from C to S
and back, making no changes. The client and server hellos will
refer to the verify data from the abbreviated handshake and
thus be accepted by both parties. This triple handshake across
two connections is depicted in Figure 3.
At the end of the renegotiation, from TLS’s viewpoint, C
and S share a new mutually-authenticated session. A does not
have the keys to this new session, but it may have injected
data in both directions before the renegotiation, and this data
may now be mistakenly attributed by C to S, and vice versa.
In other words, the TLS peer on the connection has changed,
and the application may not realize it, defeating the purpose
of the secure renegotiation extension.
Preconditions and Variations The attack above works re-
gardless of whether the renegotiation uses client certiﬁcates,
PSK, or SRP to authenticate the client, and even if the initial
handshake also used client authentication.
The main precondition is that the client be willing to use the
same authentication credentials on A and S. This is reasonable
for public-key certiﬁcates, which are often used as universal
identity assertions when issued by trusted CAs. For SRP or
PSK credentials, this may not seem as likely, but these key
exchanges are typically used to provide both server and client
authentication, and hence, they both offer several ciphersuites
that do not use server certiﬁcates at all.
The second precondition is that the client and server should
be willing to accept new mutual identities during renegotiation.
Accepting a change of client identity (or client authentication
on an anonymous session) is one of the purposes of renegoti-
ation, but accepting a change of server may seem unusual. We
experimentally tested a wide variety of TLS client applications,
including mainstream browsers, popular HTTPS libraries such
as CURL, serf, and neon, version control systems, VPN clients,
mail clients, etc. We found that a vast majority of them silently
accept a change of server identity during renegotiation, and
thus are vulnerable to our impersonation attack.
Why does this not contradict proofs of the TLS handshake?
Most proofs [e.g. 35, 32] ignore renegotiation and resumption;
[14] supports resumption but not renegotiation; [29] considers
renegotiation but not resumption; [15] supports both but relies
on the application to correctly handle epoch changes.
Web Exploit and Mitigation As a concrete example, we
implemented the above attack as a web server acting as a
synchronizing proxy between a browser C and an honest
website S. After proxying the initial handshake and session
resumption, A can tamper with the connection in many ways,
before instigating renegotiation:
• A can send a POST message to S which will get
• A can send a page with JavaScript to C, so that the script
gets executed later, in the client-authenticated session.
• A can source a client-authenticated page from S in one
frame at C while reading its contents from another frame
sourced at A, bypassing the same origin policy (XSS).
All of these attacks can be used to subvert both user authentica-
tion on the server and same-origin protections on the browser.
Protections like CSRF tokens and Content Security Policy do
not help since the page’s origin is no longer reliable.
subsequently attributed to C after renegotiation.
We have disclosed this vulnerability to a number of browser
vendors. The easiest mitigation is for web browsers to refuse
a change of server identity during renegotiation (since their
UI can hardly convey a HTTPS mashup of several origins);
some of them have already made this change in response to
our report. For web servers and other HTTPS applications,
we believe that restricting peer certiﬁcate changes would be a
good default as well, with a careful review of the UI and API
design in the cases when the identity is expected to change.
VI-B BREAKING COMPOUND AUTHENTICATION IN TUN-
NELED PROTOCOLS. Wireless authentication protocols such
as EAP-TLS [51], PEAP [42] and EAP-TTLS [27] are par-
ticularly susceptible to man-in-the-middle attacks even over
TLS [8] because of the ease with which other wireless
devices and rogue access points can fool naive clients into
connecting to them [19]. To protect against such attacks,
some of these protocols adopted new compound authentication
mechanisms [44] that cryptographically bind the inner EAP
authentication protocol with the outer TLS tunnel.
In PEAP, when the inner protocol is MSChapv2 [1] for
example, the inner protocol generates a session key (ISK)
107
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:56 UTC from IEEE Xplore.  Restrictions apply. 
that is combined with a tunnel key (TK) generated from the
outer TLS connection’s master secret (and client and server
randoms) to derive a compound authentication key (CMK) and
encryption key (CSK) for subsequent use between the wireless
device and access point. The idea is that these keys will only
be known to devices that participated both in the outer TLS
handshake and the inner EAP authentication.
TK = prf(ms, “client EAP encryption”, cr|sr)
(cid:3)(TK, ISK)
CMK|CSK = prf
PEAP also features fast reconnect, an API for TLS session
resumption: as it moves from one wireless access point to
another and needs to reconnect, the client simply resumes its
TLS session and skips the inner authentication protocol. In
this case, ISK is set to 0s so the compound authentication
and encryption keys depend only on TK. This mechanism
presumes that the tunnel key is unique on every connection;
our synchronizing TLS proxy breaks this assumption and leads
to a new attack.
As usual, A sets up synchronized connections with C and S
and forwards the untampered MSChapv2 exchange to let C
authenticate to S, negotiate ISK, combine it with TK, and derive
CMK and CSK. Since A only knows TK, he cannot read or tamper
with any messages after the authentication. Nonetheless, if A
uses fast reconnect to resume the TLS session with S, the inner
EAP authentication is skipped, and the new compound keys
are only derived from TK. Yet, S still associates the connection
with C, resulting in a complete impersonation by A, without
any involvement from C.
Preconditions and Mitigations To make the attack work,
the malicious access point must convince the user to trust its
certiﬁcate, which can be achieved in a number of cases [19].
The mitigation for tunneled protocols is not straightforward.
At the TLS level, a more general mitigation would be to
change the master secret computation, as we discuss in §VII. In
PEAP, one possibility is to change the tunnel key computation
to include the server’s identity, represented by the server’s
certiﬁcate or its hash:
TK = prf(ms, “client EAP encryption”, cr|sr|cert S)
VI-C BREAKING TLS CHANNEL BINDINGS. Channel bind-
ings [56] are a generic protocol composition mechanism,
whereby a transport-level cryptographic protocol such as IPsec,
SSH, or TLS can expose speciﬁc session and connection
parameters to applications, most notably to bind authentication
mechanisms to the underlying secure channel. Their stated
goal is to establish that “no man-in-the-middle exists between
two end-points that have been authenticated at one network
layer but are using a secure channel at a lower network
layer”. TLS implementations expose three channel bindings to
applications [6]; we consider one of them here and another
(tls-server-end-point) in the online material. The
‘tls-unique’ channel binding for a given TLS connection
is deﬁned as the ﬁrst ﬁnished message in the most recent
handshake on the connection. If the most recent handshake
is a full handshake, this value is the client verify data cvd; if
it is an abbreviated handshake, it is the server verify data svd.
The intent is that tls-unique be a unique representative of
the current epoch, shared only between the two peers who
established the epoch. Our synchronized session resumption
breaks it by establishing different connections with honest
peers that have the same tls-unique value.
To see how this can be concretely exploited, consider the
SCRAM-SHA-1-PLUS protocol [39] used in the SASL and
GSS-API families of authentication mechanisms in a variety
of applications like messaging (XMPP), mail (SMTP, IMAP),
and directory services (LDAP). SCRAM is a challenge-
response protocol where the client and server store different
keys (CKp, SKp) derived from a user’s password (p), and use
them to authenticate one another. When used over TLS,
the ﬁrst two messages contain client and server nonces and
the tls-unique value for the underlying TLS connection.
The last two messages contain MACs over these values, for
authentication and channel binding:
1. C → S :
2. S → C :
3. C → S :
4. C → S :
In our attack, C establishes, then resumes a session with A,
who synchronizes a connection with S to have the same
tls-unique value. A then forwards the SCRAM messages
between C and S. Since the server identity is not part of
the exchange and the tls-unique values match, the SCRAM
authentication succeeds, enabling A to impersonate C at S.
u, cn, tls-unique
cn, sn, s, i
cn, sn, ClientProof(CKp, log1,2,3)
cn, sn, ServerSignature(SKp, log1,2,3)
A precondition for the attack is that C be willing to accept
A’s certiﬁcate, and this is already considered a security risk
for SCRAM-like protocols, since they then become vulnerable
to dictionary attacks. However, the tls-unique protection is
meant to protect users from impersonation even if the TLS
protocol uses an anonymous key exchange [39, §9]. Our attack
shows that this is not the case.
To prevent this attack without impacting TLS, we recom-
mend signiﬁcant changes to the speciﬁcation of tls-unique
in §VII. With such modiﬁcations, tls-unique may possibly
become truly unique across connections.
VI-D BREAKING CHANNEL-BOUND TOKENS ON THE
WEB. Channel ID is a TLS extension [10], implemented by
Chrome and all Google servers, that aims to bind web au-
thentication tokens such as cookies to a cryptographic channel
between a client and a server, without the need for client
certiﬁcates. A channel can be long-lived (at least as long as
cookies) and consists of many TLS sessions and connections.
Channel ID is a follow-up to the previously published origin-
bound certiﬁcates proposal of Dietz et al. [24], which was
considered impractical to implement and deploy.
A TLS client
that supports Channel ID generates and
stores a public-private elliptic curve key pair (pk cid,S, sk cid,S)
associated to each domain name S that it connects to. The TLS
handshake is modiﬁed so that, instead of a client certiﬁcate
and certiﬁcate verify message, the client sends a Channel ID
authentication message that contains the public key (a point
on the P-256 elliptic curve) and an ECDSA signature of the
handshake log using the private key. To protect the privacy
108
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:57:56 UTC from IEEE Xplore.  Restrictions apply. 
of the client’s public key from passive eavesdroppers, the
authentication message is sent encrypted after the client’s CCS
message, but this does not affect its authentication properties.
The main protocol goal is that, unlike bearer tokens, the
client’s Channel ID cannot be used by a malicious server A
to impersonate the client on a different server S, even if C
accidentally connects to A using its Channel ID for S. In
fact, this should be impossible even if A obtains the private
key of a certiﬁcate valid for S, provided Channel ID is only
enabled with forward-secret ciphersuites such as DHE [10,
§6]. Consequently, an application that binds its tokens to the
Channel ID make them unusable on a different TLS client
without the associated private key. A typical example is for S
to create a cookie by signing the session identiﬁer with the
Channel ID public key:
c = signed(sk S, [sid , pk cid])
S would then only accept this cookie over a TLS connection
authenticated by sk cid, so stealing the cookie is of no use.
Attack and Mitigation The security of Channel ID relies on
the uniqueness of the handshake log (log c). If the attacker A
can create a session to S with the same log, it can reuse C’s
Channel ID signature to impersonate C at S. Our synchroniz-
ing proxy achieves exactly this feat after resumption.
Suppose C establishes, then resumes a TLS session with A.
A can synchronize a connection to S such that
the log
in the resumption handshake is identical between C-A and
A-S. Hence,
the Channel ID signature on the resumption
handshake can be replayed to S, allowing A to successfully
impersonate C. Henceforth, A can obtain S’s channel-bound
cookies meant for C and freely use them on this connection.
This attack is well within the threat model of Channel ID. The
Channel ID authors promptly responded to our report and in
response, the protocol speciﬁcation is being revised to include
the hash of the original handshake in the Channel ID signature
of abbreviated handshakes.
VII. COUNTERMEASURES