前几天某师傅给我发来一个逆向题，拿来分析发现竟是AES决赛算法之一的TwoFish算法，之前网上对此算法的逆向分析竟然一个都没有，对算法的介绍也只有寥寥数语，于是想准备在这里与大家分享对该算法的逆向分析以及CTF中此算法的变体。
## 算法流程
官方有一个68页的pdf，有兴趣可以看一下  
### 流程图
TwoFish的意思应该就是这样交叉运算的形状吧
### 算法分析
TwoFish加密需要明文(plain)和密钥(key)  
总的来说进行一次加解密可分为三个环节
  1. Input whitening
  2. 16次循环
  3. Output whitening
#### Input whitening
>   1. 拓展密钥
>
在Twofish 算法中，规定密钥的长度 N = 128, N = 192, N = 256三种。也就是说密钥的长度可以在128-bit ~
256-bit之间变化。
我们需要产生40个与密钥相关的K(i)，这里的K(i)是根据密钥算出来的32-bit数据  
除此以外，我们还需要4个与密钥相关的S-box，也就是s(i)()。
为计算K和S，定义MDS矩阵
且对于MDS 矩阵，有限域GF的定义如下：  
`GF(2^8) ≡ GF(2)(x)/v(x)，其中v(x) = x^8 + x^6 + x^5 + x^3 + 1`
此外还需要h函数
    y(k,j) = x(j)                     j = 0, ... ,3
         如果：k == 4
             y(3,0) = q1[y(4,0)] xor l(3,0)
             y(3,1) = q0[y(4,1)] xor l(3,1)
             y(3,2) = q0[y(4,2)] xor l(3,2)
             y(3,3) = q1[y(4,3)] xor l(3,3)
         如果：k >= 3
             y(2,0) = q1[y(3,0)] xor l(2,0)
             y(2,1) = q1[y(3,1)] xor l(2,1)
             y(2,2) = q0[y(3,2)] xor l(2,2)
             y(2,3) = q0[y(3,3)] xor l(3,3)
         对于所有情况：
             y0 = q1[q0[q0[y(2,0)] xor l(1,0)] xor l(0,0)]
             y1 = q0[q0[q1[y(2,1)] xor l(1,1)] xor l(0,1)]
             y2 = q1[q1[q0[y(2,2)] xor l(1,2)] xor l(0,2)]
             y3 = q0[q1[q1[y(2,3)] xor l(1,3)] xor l(0,3)]
实现代码稍后来说
>   1. 输入白化
>
因为加密前的plain text是128 bits，也就是16 bytes。假设这16 bytes分别是p0, ... ,p15。将p0, ...
,p15分为4组：  
`P(i) = ∑p(4i+j)2^(8j)，其中i,j = 0, ... ,3`
然后进行运算`R(0,i) = P(i) xor K(i)，其中i = 0, ... ,3`
#### 16次运算
将以下公式循环16次
    (F(r,0), F(r,1)) = F(R(r,0), R(r,1), r)
       R(r+1,0) = ROR(R(r,2) xor F(r,0), 1)
       R(r+1,1) = ROL(R(r,3), 1) xor F(r,1)
       R(r+1,2) = R(r,0)
       R(r+1,3) = R(r,1)
其中，F函数为以下操作
    t0 = g(r0)
    t1 = rol(r1, 8)
    t1 = g(t1)
    o = 2*r
    F0 = (T0 +  T1 + K(2r+8)) mod 2^32
    F1 = (T0 + 2T1 + K(2r+9)) mod 2^32
其中g函数为核心函数
    x(i) = [X/2^(8i)] mod 2^8  其中i = 0, ... ,3
         y(i) = s(i)(x(i))       其中i = 0, ... ,3
    Z = ∑z(i)2^(8i)，其中i = 0, ... ,3
#### 输出白化
    C(i) = R(16,(i+2) mod 4) xor K(i+4)，其中i = 0, ... ,3
最后计算组成密文
    c(i) = [C(i/4) / 2^(8(i mod 4))] mod 2^8，其中i = 0, ... ,15
下面来逆向分析看一下实际实现吧
## 逆向分析
拿到题后PEID分析  
分析到了TwoFish算法
IDA分析一下，进入主函数看到流程  
发现有五个选项，选项名字在sub_402FDA中
    int sub_402FDA()
    {
      puts("welcome to jiami jiemi game go.go.go.");
      puts("1._jiemi_(admin only)");
      puts("2._jiami_");
      puts("3._jiemi__flag(admin only)");
      puts("4.exit");
      return puts("5._yanzheng__");
    }
只有选项2和5可用，即加密和验证flag
进入验证函数sub_40302B查看  
这里我已经注释出密文和key，因此我们只需要解密即可，但只用标准解密算法就可以吗？我们来验证一下
很明显加密函数为sub_402E5D(&key, plain, &v3); 参数v3传出密钥
    _BYTE *__cdecl sub_402E5D(int a1, int a2, int a3)
    {
      _DWORD *v3; // ST1C_4
      v3 = sub_401570(a1, 128u);                    // a1 = key   密钥生成k和s
      sub_401626(v3, a2, a3);                          //输入白化，循环，输出白化
      return sub_401626(v3, (a2 + 16), a3 + 16);
    }
下面来结合标准实现分析
    int __cdecl sub_401570(int a1, unsigned int a2)
    {
      _DWORD *v2; // ST1C_4
      _BYTE *v3; // ST18_4
      void *v4; // eax
      int v5; // eax
      int v6; // ST14_4
      v2 = sub_402D53(a1, a2 >> 3);                 // key_t* tf_key = expand_key(s, len/8);  拓展密钥
      v3 = sub_4025C6(v2);                          // subkey_t *tf_subkey = Twofish_generate_subkey(tf_key);  生成密钥
      v4 = malloc(4260u);
      v5 = sub_401B7A(v4, v3, 0x1010101, *v2 >> 3); // tf_twofish = Twofish_generate_ext_k_keys(tf_twofish,tf_subkey,0x01010101,(tf_key->len/8));  生成k
      v6 = sub_401CF8(v5, v3, *v2 >> 3);            // tf_twofish = Twofish_generate_ext_s_keys(tf_twofish,tf_subkey,(tf_key->len/8));  生成s
      free(v2[1]);
      free(v2);
      free(v3);
      return v6;
    }
> 拓展密钥
可以看到题中对位数分析的判定进行了修改
> 生成密钥
c实现
rsm函数定义为
    #define rsm(i,a,b,c,d,e,f,g,h)  \
            gf(nxt(tf_key->k,r*8),a,0x14d)^gf(nxt(tf_key->k,r*8+1),b,0x14d)^\
            gf(nxt(tf_key->k,r*8+2),c,0x14d)^gf(nxt(tf_key->k,r*8+3),d,0x14d)^\
            gf(nxt(tf_key->k,r*8+4),e,0x14d)^gf(nxt(tf_key->k,r*8+5),f,0x14d)^\
            gf(nxt(tf_key->k,r*8+6),g,0x14d)^gf(nxt(tf_key->k,r*8+7),h,0x14d)
> k生成
h函数内部，可以看出，IDA将二维数组直接一维化  
q0,q1都是256大小的数组  
标准
    uint8_t q[2][256] =
    {
        /* q0 */
        {   0xa9,0x67,0xb3,0xe8,0x4,0xfd,0xa3,0x76,0x9a,0x92,0x80,0x78,0xe4,0xdd,0xd1,0x38,
    0xd,0xc6,0x35,0x98,0x18,0xf7,0xec,0x6c,0x43,0x75,0x37,0x26,0xfa,0x13,0x94,0x48,
    0xf2,0xd0,0x8b,0x30,0x84,0x54,0xdf,0x23,0x19,0x5b,0x3d,0x59,0xf3,0xae,0xa2,0x82,
    0x63,0x1,0x83,0x2e,0xd9,0x51,0x9b,0x7c,0xa6,0xeb,0xa5,0xbe,0x16,0xc,0xe3,0x61,
    0xc0,0x8c,0x3a,0xf5,0x73,0x2c,0x25,0xb,0xbb,0x4e,0x89,0x6b,0x53,0x6a,0xb4,0xf1,
    0xe1,0xe6,0xbd,0x45,0xe2,0xf4,0xb6,0x66,0xcc,0x95,0x3,0x56,0xd4,0x1c,0x1e,0xd7,
    0xfb,0xc3,0x8e,0xb5,0xe9,0xcf,0xbf,0xba,0xea,0x77,0x39,0xaf,0x33,0xc9,0x62,0x71,
    0x81,0x79,0x9,0xad,0x24,0xcd,0xf9,0xd8,0xe5,0xc5,0xb9,0x4d,0x44,0x8,0x86,0xe7,
    0xa1,0x1d,0xaa,0xed,0x6,0x70,0xb2,0xd2,0x41,0x7b,0xa0,0x11,0x31,0xc2,0x27,0x90,
    0x20,0xf6,0x60,0xff,0x96,0x5c,0xb1,0xab,0x9e,0x9c,0x52,0x1b,0x5f,0x93,0xa,0xef,
    0x91,0x85,0x49,0xee,0x2d,0x4f,0x8f,0x3b,0x47,0x87,0x6d,0x46,0xd6,0x3e,0x69,0x64,
    0x2a,0xce,0xcb,0x2f,0xfc,0x97,0x5,0x7a,0xac,0x7f,0xd5,0x1a,0x4b,0xe,0xa7,0x5a,
    0x28,0x14,0x3f,0x29,0x88,0x3c,0x4c,0x2,0xb8,0xda,0xb0,0x17,0x55,0x1f,0x8a,0x7d,
    0x57,0xc7,0x8d,0x74,0xb7,0xc4,0x9f,0x72,0x7e,0x15,0x22,0x12,0x58,0x7,0x99,0x34,
    0x6e,0x50,0xde,0x68,0x65,0xbc,0xdb,0xf8,0xc8,0xa8,0x2b,0x40,0xdc,0xfe,0x32,0xa4,
    0xca,0x10,0x21,0xf0,0xd3,0x5d,0xf,0x0,0x6f,0x9d,0x36,0x42,0x4a,0x5e,0xc1,0xe0
        },
        /* q1 */
        {
    0x75,0xf3,0xc6,0xf4,0xdb,0x7b,0xfb,0xc8,0x4a,0xd3,0xe6,0x6b,0x45,0x7d,0xe8,0x4b,
    0xd6,0x32,0xd8,0xfd,0x37,0x71,0xf1,0xe1,0x30,0xf,0xf8,0x1b,0x87,0xfa,0x6,0x3f,
    0x5e,0xba,0xae,0x5b,0x8a,0x0,0xbc,0x9d,0x6d,0xc1,0xb1,0xe,0x80,0x5d,0xd2,0xd5,
    0xa0,0x84,0x7,0x14,0xb5,0x90,0x2c,0xa3,0xb2,0x73,0x4c,0x54,0x92,0x74,0x36,0x51,
    0x38,0xb0,0xbd,0x5a,0xfc,0x60,0x62,0x96,0x6c,0x42,0xf7,0x10,0x7c,0x28,0x27,0x8c,
    0x13,0x95,0x9c,0xc7,0x24,0x46,0x3b,0x70,0xca,0xe3,0x85,0xcb,0x11,0xd0,0x93,0xb8,
    0xa6,0x83,0x20,0xff,0x9f,0x77,0xc3,0xcc,0x3,0x6f,0x8,0xbf,0x40,0xe7,0x2b,0xe2,
    0x79,0xc,0xaa,0x82,0x41,0x3a,0xea,0xb9,0xe4,0x9a,0xa4,0x97,0x7e,0xda,0x7a,0x17,
    0x66,0x94,0xa1,0x1d,0x3d,0xf0,0xde,0xb3,0xb,0x72,0xa7,0x1c,0xef,0xd1,0x53,0x3e,
    0x8f,0x33,0x26,0x5f,0xec,0x76,0x2a,0x49,0x81,0x88,0xee,0x21,0xc4,0x1a,0xeb,0xd9,
    0xc5,0x39,0x99,0xcd,0xad,0x31,0x8b,0x1,0x18,0x23,0xdd,0x1f,0x4e,0x2d,0xf9,0x48,
    0x4f,0xf2,0x65,0x8e,0x78,0x5c,0x58,0x19,0x8d,0xe5,0x98,0x57,0x67,0x7f,0x5,0x64,
    0xaf,0x63,0xb6,0xfe,0xf5,0xb7,0x3c,0xa5,0xce,0xe9,0x68,0x44,0xe0,0x4d,0x43,0x69,
    0x29,0x2e,0xac,0x15,0x59,0xa8,0xa,0x9e,0x6e,0x47,0xdf,0x34,0x35,0x6a,0xcf,0xdc,
    0x22,0xc9,0xc0,0x9b,0x89,0xd4,0xed,0xab,0x12,0xa2,0xd,0x52,0xbb,0x2,0x2f,0xa9,
    0xd7,0x61,0x1e,0xb4,0x50,0x4,0xf6,0xc2,0x16,0x25,0x86,0x56,0x55,0x9,0xbe,0x91
        }
    };
MDS矩阵运算  
> S-box生成
> 输入白化，循环，输出白化 sub_401626
c实现  
f函数  
## 算法解密
解密函数如下
    void Twofish_decryt(twofish_t* tf_twofish, uint8_t *cypher, uint8_t *data)
    {