information (S4).
8.2 Structure of the RSM
The RSM specification has three major modules (shown
in Figure 3): GEOM, which computes basic geometric func-
tions; IZ, which sets up the geometry specific to the RSM;
and  ALG,  which  analyzes  incoming  data  with  respect  to
those structures. GEOM is protected by a layer that checks
its outputs to give them strong correctness arguments. There
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:36:41 UTC from IEEE Xplore.  Restrictions apply. 
are two sets of persistent state: the incursion zone structure
(belonging  to  IZ),  and  the  data  structures  for  the  system
interface (belonging to ALG). 
Any failure of a check will trigger a reconfiguration sig-
nal.  As  the  signal  is  propagated  through  IZ,  IZ  causes  the
incursion zone structure to meet its postcondition. The same
is true for ALG, of the system data structures. The monitor-
ing layer takes care of periodic function initiation and also
reconfiguration,  when  necessary.  RM.choose  calls  the
appropriate  module  functions  to  meet  Pretransj:  it  reinitial-
izes the incursion zone structure.
The  overall  reconfiguration  process  is  required  to  finish
within one update data cycle, which in real time lasts 2000
ms. In order to facilitate a proof of the timing requirement,
each function in the module interface and in the reconfigura-
tion  mechanism  interface  has  an  associated  variable  repre-
senting  a  timing  bound.  This  variable  will  be  instantiated
after  an  implementation  is  created.  Addressing  timing  this
way gives an implementer freedom to partition the allowed
time in a manner most useful to the implementation, while
enabling detailed timing theorems of the specification to be
created whose proof over an implementation will ensure the
overall timing requirement is met.
8.3 Assuring Properties of the RSM
A full proof of every design-level property for the RSM
specification cannot be shown here. In order to indicate how
all  of  the  high-level  reconfiguration  properties  can  be
proved, we choose three representative design-level proper-
ties,  one  from  each  major  structural  element.  We  then
explain how each can be shown for the RSM specification.
The  representative  module  property  we  use  is  M1:  If
none  of  a  module’s  functions  is  currently  executing,  that
module’s  postcondition  is  met.  While  this  property  might
seem difficult to assure overall, it can be simplified signifi-
cantly  by  disallowing  data  structure  access  through  any
function outside the module interface; and that is statically
checkable. In the RSM specification, only IZ can access the
incursion  zone  structure  and  only  ALG  can  access  the
shared  data  structures.  Each  module  interface  function
ensures that the postconditions are not violated. 
The representative application property we use is App1:
If  App  is  not  reconfiguring,  it  will  function  in  accordance
with  the  specification  represented  by  config’s  value.  The
monitoring  layer  calls  ALG,  passing  it  a  parameter  repre-
senting  the  current  operational  specification.  ALG  then
determines the service level of IZ that is appropriate for the
specification,  and  for  the  function  it  is  calculating.  For
instance,  IZ  has  a  function  to  check  whether  an  input  data
target is in an incursion zone. If S2 is the operational specifi-
cation, then ALG will always call this function with service
level  parameter  a2,  asking  it  to  check  only  the  runway
proper. If S1 is the operational specification, then ALG will
call  this  function  with  service  level  parameter  a1  or  a2,
depending  on  various  conditions  of  the  monitoring  aircraft
and target. Each overall functional level Si can be assessed
independently  by  setting  the  specification  parameter  of
ALG  equal  to  i,  and  then  determining  what  function
sequences  will  be  called  for  each  function  in  ALG’s  inter-
face.
The  representative  reconfiguration  mechanism  property
we use is RM7: Invi   Ù Invix  Ù Invij  . The reconfiguration invariants for the RSM are
over  the  shared  data  structure,  as  this  is  the  only  way  the
RSM can affect the larger system. The transition invariant in
general  is  that  the  reconfiguration  process  must  not  affect
any  of  the  elements  of  the  shared  data  structure:  it  cannot
begin or end a pilot alert, output possible collision targets, or
instruct the aircraft to do anything other than remain on the
course set by the operational specification. Such an invari-
ant  is  a  subset  of  the  invariant  of  Si  because  it  is  in  fact
determined  by  Si,  and  it  is  the  same  for  all  possible  target
transitions Sj. It can be shown for the RSM by ensuring that
no  element  of  the  reconfiguration  mechanism  accesses
ALG’s  data  structures,  which  is  true  because  ALG’s  prep
function does not access those structures.
The  discussion  above  is  an  outline  of  a  complete  set  of
proofs  that  establish  the  high-level  reconfiguration  proper-
M
o
n
i
t
o
r
i
n
g
L
a
y
e
r
Application 
Inputs and 
Outputs 
Through 
Shared Data 
Structure
Overall
Algorithm 
(ALG)
Reconfigu-
ration 
Mechanism
Incursion Zone Functions 
(IZ):
• Create zone structure
• Check for inclusion in 
a zone
• Ensure postcondition
• Ensure transition con-
dition
Figure 3. RSM Architecture
C
h
e
c
k
i
n
g
L
a
y
e
r
Geometry 
Functions 
(GEOM):
• Build Shapes
• Check for 
inclusion in a 
shape
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:36:41 UTC from IEEE Xplore.  Restrictions apply. 
ties  for  the  RSM  part  of  RIPS.  The  level  of  assurance  we
can achieve by structuring the specification this way would
be  very  difficult  or  impossible  to  reach  using  a  standard
approach using a single monolithic software design. Such a
design would have to show that the entire system will func-
tion correctly, rather than that it can transition to a very sim-
ple set of functions that will achieve safety. Such a level of
assurance would also be difficult to achieve if reconfigura-
tion were employed, but with an ad hoc approach. All of the
different circumstances under which a transition could occur
would have to be analyzed separately. Our approach makes
the assurance argument simpler, clearer, and more convinc-
ing.
9. Tool Support
Assurance arguments about complex software properties
are not simple and cannot be made with the push of a button.
Their  construction  and  management  can,  however,  be
greatly simplified with appropriate tool support. Our frame-
work  facilitates  this  by  defining  the  various  architectural
elements of a reconfigurable system and defining what those
elements’ properties should be. A variety of current theorem
proving  systems  could  be  extended  to  allow  developers  to
categorize the elements of a specification within this frame-
work.  For  each  of  these  elements,  the  system  could  then
generate automatically (and in some cases, attempt to prove)
the properties associated with that category of element.
10. Conclusion
increasing 
requirements  are 
The  complexity  of  many  current  safety-critical  applica-
tions and the strictures placed on them by their dependabil-
ity 
the  prominence  of
reconfigurable  system  designs  because  of  the  opportunity
those  designs  present  to  meet  system  dependability  goals.
Reconfiguration can in its own right introduce questions of
correctness and assurance of correctness, however. We have
presented a rigorous definition of reconfiguration assurance
and  an  architectural  framework  through  which  an  applica-
tion might be constructed to meet the properties of that defi-
nition.  This  framework carries  with  it a  set  of  design-level
properties  that,  when  shown  of  the  application,  mean  the
definition’s properties have been met. We have listed these
properties  that  are  necessary  to  assure  reconfiguration  cor-
rectness  and  have  outlined  a  strategy  through  which  they
might be met in practice.
Acknowledgments
It is a pleasure to thank Phil Koopman for technical dis-
cussion on the subject of this paper.  Martin Hiller also gave
us  a  number  of  helpful  comments  and  suggestions.  This
work was sponsored, in part, by NASA under grant number
NAG1-02103.
References
[1] Anderson,  T.,  and  R.  W.  Witty.  “Safe  programming.”  BIT,
18:1-8, 1978.
[2] Bateman, A., D. Ward, and J. Monaco. “Stability Analysis for
Reconfigurable  Systems  with  Actuator  Saturation.”  Proc.
American Control Conf., Anchorage, AK, May 8-10, 2002.
[3] Cailliau, D., and R. Bellenger. “The Corot Instruments Soft-
ware:  Towards 
Intrinsically  Reconfigurable  Real-time
Embedded Processing Software in Space-borne Instruments.”
Proc. 4th IEEE International Symposium on High-Assurance
Systems Engineering, Nov. 1999.
[4] Green, D.F. Jr. “Runway Safety Monitor Algorithm for Run-
way  Incursion  Detection  and  Alerting.”  NASA/CR-2002-
211416, National Aeronautics and Space Administration, Jan-
uary 2002.
Jahanian, F., and A.K. Mok. “Safety Analysis of Timing Prop-
erties in Real-Time Systems.” IEEE Trans. on Software Engi-
neering, 12(9):890-904.
[5]
[6] Karsai  G.,  A.  Ledeczi,  J.  Sztipanovits,  G.  Peceli,  G.  Simon,
and T. Kovacshazy. “An Approach to Self-Adaptive Software
based on Supervisory Control.” Self-Adaptive Software, Lec-
ture Notes in Computer Science, 2002.
[7] Lions, J. “Ariane V Flight 501 Failure: Report by the Inquiry
Board.” http://ravel.esrin.esa.it/docs/esa-x-1819eng.pdf.
[8] Neema S.,  T. Bapty, and  J. Scott. “Adaptive Computing  and
Run-time  Reconfiguration.”  Proc.  Military  Applications  of
Programmable Logic Devices, Laurel, MD, September 1999.
[9] Seeling,  K.  “Reconfiguration  in  an  Integrated  Avionics
Design.” 15th AIAA/IEEE Digital Avionics Systems Confer-
ence, Oct. 1996.
[10] Sha,  Lui.  “Using  Simplicity  to  Control  Complexity.”  IEEE
Software 18(4):20-28.
[11] Schlichting, R. D., and F. B. Schneider. “Fail-stop processors:
An approach to designing fault-tolerant computing systems.”
ACM Transactions on Computing Systems 1(3):222-238.
[12] Shelton,  C.,  P.  Koopman,  and  W.  Nace.  “A  framework  for
scalable analysis and design of system-wide graceful degrada-
tion in distributed embedded systems.” Eighth IEEE Interna-
tional  Workshop  on  Object-oriented  Real-time  Dependable
Systems (WORDS 2003), Guadelajara, Mexico, Jan. 2003.
[13] Stewart,  D.B.,  and  G.  Arora.  “Dynamically  Reconfigurable
Embedded  Software-Does  It  Make  Sense?”  Proc.  Second
IEEE  International  Conference  on  Engineering  of  Complex
Computer Systems, Oct. 1996.
[14] Strunk, E. A., and J. C. Knight. “Functionality/Dependability
Co-design in Real-Time Embedded Software.” Workshop on
Co-design for Embedded Real-time Systems, July 2003.
[15] Wika, K.G. and J.C. Knight. “On the Enforcement of Software
Safety  Policies.”  10th  Annual  IEEE  Conf.  on  Computer
Assurance (COMPASS `95), June 1995. 
[16] Yeh, Y. C. “Triple-Triple Redundant 777 Primary Flight Com-
puter.” Proc. 1996 IEEE Aerospace Applications Conference,
vol. 1, New York, N.Y., February 1996.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:36:41 UTC from IEEE Xplore.  Restrictions apply.