Studio can be identiﬁed using this feature. Neither Eclipse
ADT nor application generators apps we analyzed exhibited
this behaviour. In contrast, we could not ﬁnd any reliable
identiﬁcation feature for Eclipse ADT apps. To avoid false
positives, we limited our analyses to application generators
apps and Android Studio apps we could reliably identify.
C. Market Penetration
Our app corpus currently consists of 2,291,898 free apps
from Google Play. We managed to successfully classify
255,216 (11.14%) of these apps using our feature detection
as generated by OAGs. This is a lower bound based on the
OAGs we could reliably identify, since OAGs not considered
6http://developer.android.com/tools/help/adt.html
7http://developer.android.com/tools/studio/index.html
8https://androidbycode.wordpress.com/2015/02/14/goodbye-launcher-
drawables-hello-mipmaps/
Figure 2: Distribution OAG generated apps by Google Play
store categories. The Unknown category is for apps that are
not classiﬁed by the Google Play store
in our classiﬁcation might be responsible for additional apps.
Based on meta data from Google Play, these generated apps
account for more than 1.14 bn downloads. Detailed app counts
per online service can be found in the market column of
Table 1. The numbers suggest that the majority of OAGs is
responsible only for a small fraction of the set of generated
apps. In contrast, the ﬁve most popular OAGs account for
73% of all generated apps, i.e., 8.12% of our corpus. While
the many OAG-generated apps have a small user base, there
is also a larger number (>17k apps) with a signiﬁcant number
of at least 10,000 downloads (see Figure 1). Reasons for
this distribution of download counts originate in the limited
set of functionality offered by these services as opposed to
traditional app development. In the following, we characterize
OAG-generated apps based on the offered functionality.
D. OAG App Characterization
To better understand the potential complexity of the applica-
tion logic that can be implemented with OAGs, we inspected
online services’ development IDEs to count the number and
types of app components that can be connected to implement
the indented logic. We call component an app element with
a UI and that implements a speciﬁc task or functionality.
For example, components can be simple UI elements (e.g.,
buttons, forms, views) or complex modules/plugins (e.g., QR
scanners, calendar views, and login forms). The number of
components varies across OAGs and it ranges from 12 of
AppYet to 128 components of Seattle Cloud. This variety
indicates the level of customization that each OAG offers. We
also observed a great variety of components. For example,
Biznessapps offers 48 components all suitable for business
apps, e.g., membership management, mortgage calculator, and
loyalty program management components. Another interesting
example is Seattle Cloud which provides general-purpose
components including simple UI elements such as menu items
638
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:30:14 UTC from IEEE Xplore.  Restrictions apply. 
and image areas, as well as complex ones such as complete
PDF readers and barcode scanners.
This variety is also reﬂected in the different app categories
on Google Play. The app category is a string value in the app
metadata retrieved by our crawlers that identify the type of
app9. The ten most popular categories of OAG-generated apps
are shown in Figure 2. These categories cover apps with non-
trivial logic such as Business (e.g., document editor/reader,
email management, or job search apps), Entertainment (e.g.,
streaming video apps), and Games. These categories contain
all of the top nine OAG apps with 5M+ downloads. An
interesting aspect is that different OAG dominate different
app categories,
thus suggesting product specialization. For
example, the most popular category of Seattle Cloud is Enter-
tainment with 11,073 apps, whereas the most popular category
for Biznessapps is Business with 9,030 apps.
IV. ANALYSIS METHODOLOGY
We now focus on the security of apps generated with OAGs.
The naive approach to analyze the security of our dataset
is to test all apps systematically. However, we observe that
OAG apps are produced in a streamlined process in which
app developers do not contribute with source code. We thus
hypothesize that the apps share an OAG-speciﬁc boilerplate
code and, as a consequence, either all generated apps share
a vulnerability or none. Accordingly, we ﬁrst identify the
app generation model for each OAG, before we analyze the
security of the boilerplate code on both self-generated apps
and apps from Google Play.
A. Boilerplate App Model
To identify boilerplate apps, we ﬁrst build the ground truth
with self-generated apps for different OAG. To this end, we
select the thirteen most popular OAGs based on their market
penetration in Table 1 and register as a customer. Among these,
six online services (Appmachine, Apps Builder, Biznessapps,
Como, Seattle Cloud, and GoodBarber) required us to pay
a subscription fee to be able to generate apps and to rent
backend resources, such as user management. For each online
service we create the same three custom apps to test whether
targeted code is generated depending on the selected modules
or whether boilerplate code with an app-speciﬁc conﬁguration
ﬁle is output. We create the three custom apps as follows:
● App1: The ﬁrst app constitutes the minimal app, i.e. the
smallest app that can be generated in terms of functional-
ity. In most cases, this app just displays a “Hello World”
message to the user.
● App2: Builds on the minimal app but additionally per-
forms web requests to a web server we control. We
perform both HTTP and HTTPS requests to analyze the
transferred plaintext data and to test whether we can inject
malicious code and emulate web-to-app attacks [22], [13],
[32].
9A complete list of categories and descriptions can be found https://support.
google.com/googleplay/android-developer/answer/113475?hl=en
Table 2: Online services grouped by generation model: Mono-
lithic boilerplate apps with static/dynamic conﬁguration ﬁles
and module-dependent boilerplate apps.
A. Monolithic Boilerplate Code
A.1 Native application
A.2 HTML + Native app
Apps Builder
Appmachine
Biznessapps
GoodBarber
Mobincube
Apps Geyser
Appy Pie
AppYet
Como
Seattle Cloud
Tobit Chayns
Static conﬁg
Dynamic conﬁg
—
—
—
—
—
B. Module-dependent Boilerplate Code
Andromo
Appinventor
= static conﬁg in plain / dyn. conﬁg loaded via HTTP
= static conﬁg decryptable / HTTPS downgrade
= static conﬁg encrypted / dyn. conﬁg loaded via HTTPS
● App3: The third app implements either a user login or a
form to submit user data to our server (if the application
generator provides modules for such functionality). We
chose such common functionality as it is supported by
the majority of AppGens and because handling user data
usually requires special care in terms of security. In our
test set, Appinventor, Biznessapps, and Como did not offer
such additional modules.
To test whether an AppGen generates boilerplate code or
module-dependent code we analyze the bytecode ﬁle(s) of
App1–App3 as well as 10 randomly selected apps from Google
Play for each service. In the majority of cases, it is sufﬁcient to
compare the hash value of the classes.dex bytecode ﬁle to show
that different apps have the exact same code. If the ﬁle hash
differs we compute a Merkle hash tree over the class hierarchy
including package, class and method instruction information to
quickly estimate the code overlap (thereby following a similar
approach to the one to detect third-party libraries in [6]). The
results conﬁrm our observation in which apps generated with
OAG are based on a common boilerplate code. In particular,
we can derive two distinct generation techniques: monolithic
boilerplate apps with conﬁguration ﬁles and module-dependent
boilerplate code (see Table 2).
1) Monolithic Boilerplate Code: All but two online services
generate apps with the exact same application bytecode, i.e.
apps include code for all supported modules with additional
logic for layout
the app
developer has selected. Apps only differ in a conﬁguration ﬁle
that is either statically included in the apk ﬁle or dynamically
loaded at runtime. Some OAGs support both options, e.g. to
deliver app updates as conﬁg ﬁle updates without the need
transitions independent of what
639
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:30:14 UTC from IEEE Xplore.  Restrictions apply. 
to change the apk ﬁle. Further this allows to bind the app to
the service providers’ backend servers. In this scenario, apks
only need to be updated when the online service changes its
boilerplate code. Boilerplate apps can be sub-categorized into
pure native applications, i.e., these apps include dex bytecode
and optionally libraries written in C/C++ (see category A.1),
and hybrid applications combining bytecode with HTML/JS
(A.2). For HTML/JS apps, bridge code is generated to interact
with the Android middleware, while HTML and Javascript is
used to render the apps’ user interface in a WebView.
2) Module-dependent Boilerplate Code: Two online ser-
vices, Andromo and Appinventor, generate module-dependent
boilerplate code for apps, i.e., only the boilerplate code for
modules enabled/added by the app developer is stored within
the apk ﬁle. Hence, apps share the same code for individual
modules, but the set of enabled modules might differ. Module-
dependent code requires a more complex app generation
process for the online service provider, however, the generated
apk is tailored to the conﬁgured modules and the chosen
layout. The app semantics are not controlled by a pre-deﬁned
conﬁguration ﬁle. While Andromo’s app assembly is close to
those of the other AppGens, Appinventor builds on GNU Kawa
and offers, besides modules, a kind of visual programming
to give the app developer the choice to implement if-then-
else conditions and loops on a high-level. This gives the app
developer a bit more freedom in customizing the application
but has a slightly steeper learning curve for citizen developers.
B. Security Audit
Following the initial analysis of the app generation model,
we then conduct a security audit on the generated boilerplate
code. To this end, we follow a dynamic-static approach. We
leverage dynamic testing to monitor the test apps’ runtime
behavior, e.g., obtain traces of the contacted domains dur-
ing execution and check the possibility of eavesdropping
or modifying those connections. We complement our tests
with static analysis (e.g., control-ﬂow graphs, program slicing,
backtracking) to overcome the limitations of dynamic analysis,
e.g., code coverage. Similar to the analysis of the boilerplate
app model, we start our analysis with the self-generated
apps of Section IV-A. To remove any bias from our set of
self-generated apps, we cross-validate our ﬁndings with 10
randomly selected apps of the same OAG (=130 apps in
total), drawn from our Google Play app corpus. Finally, as the
conﬁguration of apps can be provided dynamically by OAG’s
service, we extend our analysis to the OAG backend servers
and the client-server communication.
Our analysis identiﬁes two new attack vectors which are
speciﬁc to the OAG generated apps, speciﬁcally reconﬁg-
uration and infrastructure attacks. We present these attacks
in Section V. We then test the boilerplate apps for well-
known security issues such as code injection vulnerabilities
and insecure WebViews. The results of this analysis are
presented in Section VI.
V. OAG-SPECIFIC ATTACK VECTORS
Given the inherently different generation model as com-
pared to traditional app creation, we now describe new OAG-
speciﬁc attack vectors—Application infrastructure attacks that
apply to all OAGs and app reconﬁguration attacks that apply
to OAGs with monolithic boilerplate code only—and illustrate
weaknesses that we found during our security audit.
A. Application Reconﬁguration Attacks
In our set of tested OAGs (see Table 2), 5/11 services use
either static or dynamically loaded conﬁg ﬁles exclusively,
while the remaining six OAGs use an hybrid approach. Dy-
namically loaded conﬁgs have the advantage that apps can
be updated on-the-ﬂy without having to download an updated
apk ﬁle from an app store. Changes are instantly pushed onto
the end-users’ devices on startup. However, two AppGens—
Tobit Chayns and Biznessapps—do not persist their conﬁg
locally and thus require a permanent Internet connection to
work. As an example, Biznessapps—a paid service—uses this
as a license enforcement mechanism, i.e., app functionality
is disabled via the conﬁg ﬁle as soon as the app developer
no longer holds a valid license. In general, we found that
these conﬁguration ﬁles carry any app-speciﬁc data, potentially
including the entire business logic of the app and secret
credentials. Hence, there is a strong incentive to carefully
protect this ﬁle in terms of integrity and conﬁdentiality.
1) Static conﬁg ﬁles: In our test set, 7/9 static conﬁg ﬁles
are stored in plain and can be read and modiﬁed without
effort. Only AppYet encrypts its conﬁg ﬁle, however, at the
same time, the passphrase is hard-coded in the bytecode and
is identical for every AppYet app. This allows us to write
a simple encryption/decryption tool to read and modify the
AppYet conﬁg ﬁles. The Appmachine conﬁg was the only one
where we are not able to extract information. Appmachine is
built on top of Mono for Android, thus, most of the app code
is compiled to native code, including the classes that process
the non-human-readable conﬁg ﬁle10. As for the integrity
protection, we found that in the majority of cases standard
Android APIs are used to read these ﬁles directly from assets
or the raw directory. By inspecting the disassembled app code
we can, however, not ﬁnd any additional integrity checks or
obfuscation logic for these conﬁg ﬁles. This allows, in all
but one case, to trivially extract the conﬁg ﬁle from an apk.
Cloning or repackaging apps becomes an easy task, since
no code has to be reverse engineered, only the app features
and properties within the conﬁg ﬁle–typically a .xml or .
json ﬁle—have to be understood once for each application
generator.
2) Dynamically loaded conﬁg ﬁles: Further, we found
that eight out of eleven OAGs (A.1+A.2) load conﬁg data
dynamically at runtime. All but Biznessapps and Tobit Chayns
use a hybrid model of static and dynamic conﬁg loading. In
ﬁve cases, the conﬁg is requested via HTTP and transmitted
10While we abstain from reversing this conﬁg ﬁle, we assume that, with
enough effort, it should be similarly possible to extract information.
640
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:30:14 UTC from IEEE Xplore.  Restrictions apply. 
in plain without any protection. Only three OAGs load the
conﬁg via SSL by default. For Mobincube, however, it is
possible to downgrade the request to HTTP. Moreover, none of
these AppGens uses public key pinning to prevent man-in-the-
middle attacks. Similar to static conﬁgs, the complete absence
of integrity checks and content encryption allows tampering
with the app’s business logic and data. This is fatal, since
in our tests we could on-the-ﬂy re-conﬁgure app modules
(enabling, disabling, modiﬁcation), disable advertisements (for
free AppGens), compromise app data (localized strings, about
information) or modify the application’s sync URL (AppYet).
Only few settings cannot be compromised when app content is
no longer retrievable from the server due to license expiration
(e.g. we found that 5,137 out of 27,130 Biznessapps in our
app set already expired).
Having the full control over the app’s data and business
logic as a network attacker allows a range of different attacks
to be mounted with moderate effort. Targeted phishing attacks
may allow stealing user data/credentials. On-the-ﬂy replace-
ment of API keys for advertisement may allow an attacker
to steal ad revenue. Or an attacker may simply try to deface
the application which in turn affects the reputation of the app
developer.
B. Application Infrastructure Attacks
A large fraction of app generators bind their customers
to their web services, e.g., for user management or license
validation. Particularly, hybrid apps that make use of web
technology, like WebViews, to deliver the app’s logic, bind
the generated app to the generator service’s web infrastructure.
For instance, in our set of AppGens, Seattle Cloud, Bizness-
apps, and Como bind both their clients and end-users to their
service’s infrastructure, e.g., by managing the client’s user