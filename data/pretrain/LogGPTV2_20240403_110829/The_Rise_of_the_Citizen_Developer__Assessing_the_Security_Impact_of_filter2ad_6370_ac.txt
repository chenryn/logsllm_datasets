### Identification of Apps Generated by Different Tools

Android Studio can be identified using a specific feature. In contrast, neither Eclipse ADT nor the application generators we analyzed exhibited this behavior. Additionally, no reliable identification feature was found for Eclipse ADT apps. To avoid false positives, our analysis was limited to application generators and Android Studio apps that could be reliably identified.

### Market Penetration

Our app corpus currently consists of 2,291,898 free apps from Google Play. We successfully classified 255,216 (11.14%) of these apps as being generated by Online Application Generators (OAGs). This is a lower bound based on the OAGs we could reliably identify, as there may be other OAGs not considered in our classification. Based on metadata from Google Play, these generated apps account for more than 1.14 billion downloads. Detailed app counts per online service can be found in the market column of Table 1. The numbers suggest that while the majority of OAGs are responsible for a small fraction of the generated apps, the five most popular OAGs account for 73% of all generated apps, or 8.12% of our corpus. While many OAG-generated apps have a small user base, a significant number (over 17,000) have at least 10,000 downloads (see Figure 1). This distribution of download counts can be attributed to the limited set of functionalities offered by these services compared to traditional app development.

### Characterization of OAG-Generated Apps

To better understand the potential complexity of the application logic that can be implemented with OAGs, we inspected the development IDEs of various online services to count the number and types of app components. We define a component as an app element with a UI that implements a specific task or functionality. For example, components can range from simple UI elements (e.g., buttons, forms, views) to complex modules/plugins (e.g., QR scanners, calendar views, and login forms). The number of components varies across OAGs, ranging from 12 in AppYet to 128 in Seattle Cloud, indicating the level of customization each OAG offers. 

For instance, Biznessapps provides 48 components suitable for business apps, such as membership management, mortgage calculators, and loyalty program management. Another example is Seattle Cloud, which offers general-purpose components, including simple UI elements like menu items and image areas, as well as complex ones like PDF readers and barcode scanners.

This variety is also reflected in the different app categories on Google Play. The app category is a string value in the app metadata retrieved by our crawlers. The ten most popular categories of OAG-generated apps are shown in Figure 2. These categories include apps with non-trivial logic, such as Business (e.g., document editors/readers, email management, job search apps), Entertainment (e.g., streaming video apps), and Games. These categories contain all of the top nine OAG apps with over 5 million downloads. An interesting aspect is that different OAGs dominate different app categories, suggesting product specialization. For example, the most popular category for Seattle Cloud is Entertainment with 11,073 apps, whereas for Biznessapps, it is Business with 9,030 apps.

### Analysis Methodology

We now focus on the security of apps generated with OAGs. A naive approach would be to systematically test all apps, but we observe that OAG apps are produced in a streamlined process where developers do not contribute source code. We hypothesize that these apps share OAG-specific boilerplate code, meaning either all generated apps share a vulnerability or none. Therefore, we first identify the app generation model for each OAG before analyzing the security of the boilerplate code on both self-generated apps and apps from Google Play.

#### Boilerplate App Model

To identify boilerplate apps, we built a ground truth with self-generated apps for different OAGs. We selected the thirteen most popular OAGs based on their market penetration in Table 1 and registered as a customer. Six online services (Appmachine, Apps Builder, Biznessapps, Como, Seattle Cloud, and GoodBarber) required a subscription fee to generate apps and rent backend resources. For each online service, we created three custom apps to test whether targeted code is generated based on the selected modules or whether boilerplate code with an app-specific configuration file is output.

- **App1**: The minimal app, displaying a "Hello World" message.
- **App2**: Builds on the minimal app, performing web requests to a controlled server to analyze transferred plaintext data and test for code injection and web-to-app attacks.
- **App3**: Implements a user login or form to submit user data to our server, if the application generator provides such modules.

To determine whether an OAG generates boilerplate code or module-dependent code, we analyzed the bytecode files of App1–App3 and 10 randomly selected apps from Google Play for each service. Our results confirm that OAG-generated apps are based on common boilerplate code, with two distinct generation techniques: monolithic boilerplate apps with configuration files and module-dependent boilerplate code (see Table 2).

1. **Monolithic Boilerplate Code**: Most OAGs generate apps with the same application bytecode, including code for all supported modules. Apps differ only in a configuration file, which can be statically included in the APK or dynamically loaded at runtime. Some OAGs support both options, allowing app updates via configuration file updates without changing the APK. Monolithic boilerplate apps can be categorized into pure native applications (category A.1) and hybrid applications combining bytecode with HTML/JS (category A.2).

2. **Module-dependent Boilerplate Code**: Two OAGs, Andromo and Appinventor, generate module-dependent boilerplate code, storing only the code for enabled modules within the APK. This requires a more complex app generation process but allows for tailored APKs. Appinventor, in particular, offers visual programming for high-level customization.

#### Security Audit

Following the initial analysis of the app generation model, we conducted a security audit on the generated boilerplate code using a dynamic-static approach. We monitored the test apps' runtime behavior and complemented our tests with static analysis. We cross-validated our findings with 10 randomly selected apps from each OAG, drawn from our Google Play app corpus. Finally, we extended our analysis to the OAG backend servers and client-server communication.

Our analysis identified two new attack vectors specific to OAG-generated apps: reconfiguration and infrastructure attacks. We present these attacks in Section V and test the boilerplate apps for well-known security issues such as code injection vulnerabilities and insecure WebViews.

### OAG-Specific Attack Vectors

Given the inherently different generation model compared to traditional app creation, we describe new OAG-specific attack vectors—application infrastructure attacks that apply to all OAGs and app reconfiguration attacks that apply to OAGs with monolithic boilerplate code—and illustrate weaknesses found during our security audit.

#### Application Reconfiguration Attacks

In our tested OAGs, 5 out of 11 use either static or dynamically loaded configuration files exclusively, while the remaining six use a hybrid approach. Dynamically loaded configurations allow for on-the-fly app updates without downloading a new APK. However, two OAGs, Tobit Chayns and Biznessapps, require a permanent internet connection to work, using it as a license enforcement mechanism. Configuration files often carry app-specific data, including business logic and secret credentials, necessitating careful protection.

1. **Static Configuration Files**: In our test set, 7 out of 9 static configuration files are stored in plain text and can be easily read and modified. Only AppYet encrypts its configuration file, but the passphrase is hard-coded in the bytecode and identical for every AppYet app. Appmachine's configuration file was the only one we could not extract, as it is built on Mono for Android, compiling most of the app code to native code.

2. **Dynamically Loaded Configuration Files**: Eight out of eleven OAGs load configuration data dynamically at runtime. In five cases, the configuration is requested via HTTP and transmitted in plain text. Only three OAGs load the configuration via SSL by default, and Mobincube can be downgraded to HTTP. None of these OAGs uses public key pinning to prevent man-in-the-middle attacks. The lack of integrity checks and content encryption allows tampering with the app’s business logic and data.

#### Application Infrastructure Attacks

Many OAGs bind their customers to their web services for user management or license validation. Hybrid apps that use web technology, like WebViews, bind the generated app to the generator service’s web infrastructure. For example, Seattle Cloud, Biznessapps, and Como bind both their clients and end-users to their service’s infrastructure, managing the client’s user data and providing backend services.

Having full control over the app’s data and business logic as a network attacker allows for a range of attacks, including targeted phishing, stealing ad revenue, and defacing the application, which can affect the reputation of the app developer.