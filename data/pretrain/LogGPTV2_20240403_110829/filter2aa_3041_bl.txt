 t.Error("\tShould have a Name.", ballotX, u.Name) 
55 
 } 
56 
57 
 if u.Email == "PI:EMAIL" { 
58 
    t.Log("\tShould have an Email.", checkMark) 
59 
 } else { 
60 
 t.Error("\tShould have an Email.", ballotX, u.Email) 
61 
 } 
62 
 } 
63 } 
代码清单 9-25 展示了对收到的两个值的检测。在第 51 行，我们检测 Name 字段的值是否为
"Bill"，之后在第 57 行，检查 Email 字段的值是否为"PI:EMAIL"。如果
这些值都匹配，单元测试通过；否则，单元测试失败。这两个检测使用 Error 方法来报告失败，
所以不管检测结果如何，两个字段都会被检测。 
9.2  示例 
Go 语言很重视给代码编写合适的文档。专门内置了 godoc 工具来从代码直接生成文档。在
第 3 章中，我们已经学过如何使用 godoc 工具来生成包的文档。这个工具的另一个特性是示例
代码。示例代码给文档和测试都增加了一个可以扩展的维度。 
如果使用浏览器来浏览 json 包的 Go 文档，会看到类似图 9-8 所示的文档。
图 9-8  包 json 的示例代码列表
包 json 含有 5 个示例，这些示例都会在这个包的 Go 文档里有展示。如果选中第一个示例，
会看到一段示例代码，如图 9-9 所示。 
图 9-9  Go 文档里显示的 Decoder 示例视图 
开发人员可以创建自己的示例，并且在包的 Go 文档里展示。让我们看一个来自前一节例子
的 SendJSON 函数的示例，如代码清单 9-26 所示。
代码清单 9-26  handlers_example_test.go 
01 // 这个示例程序展示如何编写基础示例 
02 package handlers_test 
03 
04 import ( 
05 
 "encoding/json" 
06 
 "fmt" 
07 
 "log" 
08 
 "net/http" 
09 
 "net/http/httptest" 
10 ) 
11 
12 // ExampleSendJSON 提供了基础示例 
13 func ExampleSendJSON() { 
14 
 r, _ := http.NewRequest("GET", "/sendjson", nil) 
15 
 rw := httptest.NewRecorder() 
16 
 http.DefaultServeMux.ServeHTTP(rw, r) 
17 
18 
 var u struct { 
19 
 Name  string 
20 
 Email string 
21 
 } 
22 
23 
 if err := json.NewDecoder(w.Body).Decode(&u); err != nil { 
24 
 log.Println("ERROR:", err) 
25 
 } 
26 
27 
 // 使用 fmt 将结果写到 stdout 来检测输出 
28 
 fmt.Println(u) 
29 
 // Output: 
30 
 // {Bill PI:EMAIL} 
31 } 
示例基于已经存在的函数或者方法。我们需要使用 Example 代替 Test 作为函数名的开始。
在代码清单 9-26 的第 13 行中，示例代码的名字是 ExampleSendJSON。
对于示例代码，需要遵守一个规则。示例代码的函数名字必须基于已经存在的公开的函数或
者方法。我们的示例的名字基于 handlers 包里公开的 SendJSON 函数。如果没有使用已经存
在的函数或者方法，这个示例就不会显示在包的 Go 文档里。 
写示例代码的目的是展示某个函数或者方法的特定使用方法。为了判断测试是成功还是失
败，需要将程序最终的输出和示例函数底部列出的输出做比较，如代码清单 9-27 所示。 
代码清单 9-27  handlers_example_test.go：第 27 行到第 31 行 
27 
 // 使用 fmt 将结果写到 stdout 来检测输出 
28 
 fmt.Println(u) 
29 
 // Output: 
30 
 // {Bill PI:EMAIL} 
31 } 
在代码清单 9-27 的第 28 行，代码使用 fmt.Println 输出变量 u 的值到标准输出。变量 u
的值在调用/sendjson 服务端点之前使用零值初始化。在第 29 行中，有一段带有 Output:的
注释。 
这个 Output:标记用来在文档中标记出示例函数运行后期望的输出。Go 的测试框架知道如
何比较注释里的期望输出和标准输出的最终输出。如果两者匹配，这个示例作为测试就会通过，
并加入到包的 Go 文档里。如果输出不匹配，这个示例作为测试就会失败。 
如果启动一个本地的 godoc 服务器（godoc -http=":3000"），并找到 handlers 包，
就能看到包含示例的文档，如图 9-10 所示。 
在图 9-10 里可以看到 handlers 包的文档里展示了 SendJSON 函数的示例。如果选中这个
SendJSON 链接，文档就会展示这段代码，如图 9-11 所示。
图 9-11 展示了示例的一组完整文档，包括代码和期望的输出。由于这个示例也是测试的一
部分，可以使用 go test 工具来运行这个示例函数，如图 9-12 所示。
图 9-10  handlers 包的 godoc 视图
 图 9-11  在 godoc 里显示完整的示例代码 
图 9-12  运行示例代码 
运行测试后，可以看到测试通过了。这次运行测试时，使用-run 选项指定了特定的函数
ExampleSendJSON。-run 选项接受任意的正则表达式，来过滤要运行的测试函数。这个选项
既支持单元测试，也支持示例函数。如果示例运行失败，输出会与图 9-13 所示的样子类似。 
图 9-13  示例运行失败 
如果示例运行失败，go test 会同时展示出生成的输出，以及期望的输出。
9.3  基准测试 
基准测试是一种测试代码性能的方法。想要测试解决同一问题的不同方案的性能，以及查看
哪种解决方案的性能更好时，基准测试就会很有用。基准测试也可以用来识别某段代码的 CPU
或者内存效率问题，而这段代码的效率可能会严重影响整个应用程序的性能。许多开发人员会用
基准测试来测试不同的并发模式，或者用基准测试来辅助配置工作池的数量，以保证能最大化系
统的吞吐量。 
让我们看一组基准测试的函数，找出将整数值转为字符串的最快方法。在标准库里，有 3 种
方法可以将一个整数值转为字符串。 
代码清单 9-28 展示了 listing28_test.go 基准测试开始的几行代码。 
代码清单 9-28  listing28_test.go：第 01 行到第 10 行 
01 // 用来检测要将整数值转为字符串，使用哪个函数会更好的基准 
02 // 测试示例。先使用 fmt.Sprintf 函数，然后使用 
03 // strconv.FormatInt 函数，最后使用 strconv.Itoa 
04 package listing28_test 
05 
06 import ( 
07 
 "fmt" 
08 
 "strconv" 
09 
 "testing" 
10 ) 
和单元测试文件一样，基准测试的文件名也必须以_test.go 结尾。同时也必须导入
testing 包。接下来，让我们看一下其中一个基准测试函数，如代码清单 9-29 所示。
代码清单 9-29  listing28_test.go：第 12 行到第 22 行 
12 // BenchmarkSprintf 对 fmt.Sprintf 函数 
13 // 进行基准测试 
14 func BenchmarkSprintf(b *testing.B) { 
15 
 number := 10 
16 
17 
 b.ResetTimer() 
18 
19 
 for i := 0; i < b.N; i++ { 
20 
 fmt.Sprintf("%d", number) 
21 
 } 
22 } 
在代码清单 9-29 的第 14 行，可以看到第一个基准测试函数，名为 BenchmarkSprintf。
基准测试函数必须以 Benchmark 开头，接受一个指向 testing.B 类型的指针作为唯一参数。
为了让基准测试框架能准确测试性能，它必须在一段时间内反复运行这段代码，所以这里使用了
for 循环，如代码清单 9-30 所示。
代码清单 9-30  listing28_test.go：第 19 行到第 22 行 
19 
 for i := 0; i < b.N; i++ { 
20 
 fmt.Sprintf("%d", number) 
21 
 } 
22 } 
代码清单 9-30 第 19 行的 for 循环展示了如何使用 b.N 的值。在第 20 行，调用了 fmt 包
里的 Sprintf 函数。这个函数是将要测试的将整数值转为字符串的函数。
基准测试框架默认会在持续 1 秒的时间内，反复调用需要测试的函数。测试框架每次调用测
试函数时，都会增加 b.N 的值。第一次调用时，b.N 的值为 1。需要注意，一定要将所有要进
行基准测试的代码都放到循环里，并且循环要使用 b.N 的值。否则，测试的结果是不可靠的。
如果我们只希望运行基准测试函数，需要加入-bench 选项，如代码清单 9-31 所示。
代码清单 9-31  运行基准测试 
go test -v -run="none" -bench="BenchmarkSprintf" 
在这次 go test 调用里，我们给-run 选项传递了字符串"none"，来保证在运行制订的基
准测试函数之前没有单元测试会被运行。这两个选项都可以接受正则表达式，来决定需要运行哪
些测试。由于例子里没有单元测试函数的名字中有 none，所以使用 none 可以排除所有的单元
测试。发出这个命令后，得到图 9-14 所示的输出。 
图 9-14  运行单个基准测试 
这个输出一开始明确了没有单元测试被运行，之后开始运行 BenchmarkSprintf 基准测
试。在输出 PASS 之后，可以看到运行这个基准测试函数的结果。第一个数字 5000000 表示在
循环中的代码被执行的次数。在这个例子里，一共执行了 500 万次。之后的数字表示代码的性能，
单位为每次操作消耗的纳秒（ns）数。这个数字展示了这次测试，使用 Sprintf 函数平均每次
花费了 258 纳秒。 
最后，运行基准测试输出了 ok，表明基准测试正常结束。之后显示的是被执行的代码文件的名字。
最后，输出运行基准测试总共消耗的时间。默认情况下，基准测试的最小运行时间是 1 秒。你会看到
这个测试框架持续运行了大约 1.5 秒。如果想让运行时间更长，可以使用另一个名为-benchtime 的
选项来更改测试执行的最短时间。让我们再次运行这个测试，这次持续执行 3 秒（见图 9-15）。 
图 9-15  使用-benchtime 选项来运行基准测试 
这次 Sprintf 函数运行了 2000 万次，持续了 5.384 秒。这个函数的执行性能并没有太大的
变化，这次的性能是每次操作消耗 256 纳秒。有时候，增加基准测试的时间，会得到更加精确的
性能结果。对大多数测试来说，超过 3 秒的基准测试并不会改变测试的精确度。只是每次基准测
试的结果会稍有不同。 
让我们看另外两个基准测试函数，并一起运行这 3 个基准测试，看看哪种将整数值转换为字
符串的方法最快，如代码清单 9-32 所示。 
代码清单 9-32  listing28_test.go：第 24 行到第 46 行 
24 // BenchmarkFormat 对 strconv.FormatInt 函数 
25 // 进行基准测试 
26 func BenchmarkFormat(b *testing.B) { 
27 
 number := int64(10) 
28 
29 
 b.ResetTimer() 
30 
31 
 for i := 0; i < b.N; i++ { 
32 
 strconv.FormatInt(number, 10) 
33 
 } 
34 } 
35 
36 // BenchmarkItoa 对 strconv.Itoa 函数 
37 // 进行基准测试 
38 func BenchmarkItoa(b *testing.B) { 
39 
 number := 10 
40 
41 
 b.ResetTimer() 
42 
43 
 for i := 0; i < b.N; i++ { 
44 
 strconv.Itoa(number) 
45 
 } 
46 } 
代码清单 9-32 展示了另外两个基准测试函数。函数 BenchmarkFormat 测试了 strconv
包里的 FormatInt 函数，而函数 BenchmarkItoa 测试了同样来自 strconv 包的 Itoa 函数。
这两个基准测试函数的模式和 BenchmarkSprintf 函数的模式很类似。函数内部的 for 循环
使用 b.N 来控制每次调用时迭代的次数。
我们之前一直没有提到这 3 个基准测试里面调用 b.ResetTimer 的作用。在代码开始执行循环之
前需要进行初始化时，这个方法用来重置计时器，保证测试代码执行前的初始化代码，不会干扰计时
器的结果。为了保证得到的测试结果尽量精确，需要使用这个函数来跳过初始化代码的执行时间。 
让这 3 个函数至少运行 3 秒后，我们得到图 9-16 所示的结果。 
图 9-16  运行所有 3 个基准测试 
这个结果展示了 BenchmarkFormat 测试函数运行的速度最快，每次操作耗时 45.9 纳秒。紧随其
后的是 BenchmarkItoa，每次操作耗时 49.4 ns。这两个函数的性能都比 Sprintf 函数快得多。
运行基准测试时，另一个很有用的选项是-benchmem 选项。这个选项可以提供每次操作分
配内存的次数，以及总共分配内存的字节数。让我们看一下如何使用这个选项（见图 9-17）。 
图 9-17  使用-benchmem 选项来运行基准测试 
这次输出的结果会多出两组新的数值：一组数值的单位是 B/op，另一组的单位是
allocs/op。单位为 allocs/op 的值表示每次操作从堆上分配内存的次数。你可以看到
Sprintf 函数每次操作都会从堆上分配两个值，而另外两个函数每次操作只会分配一个值。单
位为 B/op 的值表示每次操作分配的字节数。你可以看到 Sprintf 函数两次分配总共消耗了 16
字节的内存，而另外两个函数每次操作只会分配 2 字节的内存。 
在运行单元测试和基准测试时，还有很多选项可以用。建议读者查看一遍所有选项，以便在
编写自己的包和工程时，充分利用测试框架。社区希望包的作者在正式发布包的时候提供足够的
测试。 
9.4  小结 
测试功能被内置到 Go 语言中，Go 语言提供了必要的测试工具。
go test 工具用来运行测试。
测试文件总是以_test.go 作为文件名的结尾。
表组测试是利用一个测试函数测试多组值的好办法。
包中的示例代码，既能用于测试，也能用于文档。
基准测试提供了探查代码性能的机制。