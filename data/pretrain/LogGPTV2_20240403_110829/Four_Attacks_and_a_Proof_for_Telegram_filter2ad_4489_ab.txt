were included. In particular, an adversary who also has control
over the randomness can break stateful IND-CPA security with
2 encryption queries, while an attacker without that control
could do so with about 264 encryption queries. We use these
more theoretical attacks to motivate our decision not to allow
re-encryption with ï¬xed metadata in our formal model of
MTProto, i.e. we insist that the state is evolving.
Proof of security: We then claim in Section V that our slight
variant of MTProto achieves channel conï¬dentiality and integ-
rity in our model, under certain assumptions on the components
used in its construction. As described in Section I-B, Telegram
has implemented our proposed alterations so that there can be
some assurances about MTProto as currently deployed.1
We use code-based game hopping proofs in which the
analysis is modularised into a sequence of small steps that can
be individually veriï¬ed. As well as providing all details of the
proofs (in the full version), we also give high-level intuitions.
Signiï¬cant complexity arises in the proofs from two sources:
the entanglement of keys used in the two channel directions,
and the detailed nature of the model of MTProto that we use
(so that our proof rules out as many attacks as possible).
We eschew an asymptotic approach in favour of concrete
security analysis. This results in security theorems that quantit-
atively relate the conï¬dentiality and integrity of MTProto as a
secure channel to the security of its underlying cryptographic
components. Our main security results, Theorems 1 and 2
and Corollaries 1 and 2, provide conï¬dentiality and integrity
bounds containing terms equivalent to â‰ˆ ğ‘/264 where ğ‘ is the
number of queries an attacker makes. We discuss this further
in Section V.
However, our security proofs rely on several assumptions
about cryptographic primitives that, while plausible, have not
been considered in the literature. In more detail, due to the
way Telegram makes use of SHA-256 as a MAC algorithm and
as a KDF, we have to rely on the novel assumption that the
block cipher SHACAL-2 underlying the SHA-256 compression
function is a leakage-resilient PRF under related-key attacks,
where â€œleakage-resilientâ€ means that the adversary can choose
a part of the key. Our proofs rely on two distinct variants of
such an assumption. These assumptions hold in the ideal cipher
model, but further cryptanalysis is needed to validate them for
SHACAL-2. For similar reasons, we also require a dual-PRF
assumption of SHACAL-2. We stress that such assumptions are
likely necessary for our or any other computational security
proofs for MTProto. This is due to the speciï¬cs of how
MTProto uses SHA-256 and how it constructs keys and tags
from public inputs and overlapping key bits of a master secret.
Given the importance of Telegram, these assumptions provide
new, signiï¬cant cryptanalysis targets as well as motivate further
research on related-key attacks. Our proofs side-step concerns
about length-extension attacks by relying on the MTProto
plaintext encoding format which mandates the presence of
certain metadata in the ï¬rst block of the encrypted payload.
Attacks: We present further implementation attacks against
Telegram in Section VI and Appendix A. These attacks
highlight the limits of our formal modelling and the fragility
of MTProto implementations. The ï¬rst of these, a timing
attack against Telegramâ€™s use of IGE mode encryption, can
be avoided by careful implementation, but we found multiple
vulnerable clients.2 The attack takes inspiration from an attack
on SSH [12]. It exploits that Telegram encrypts a length ï¬eld
and checks integrity of plaintexts rather than ciphertexts. If this
process is not implemented whilst taking care to avoid a timing
side channel, it can be turned into an attack recovering up to 32
1Clients still differ in their implementation of the protocol and in particular
in payload validation, which our model does not capture.
2We note that Telegramâ€™s TDLib [10] library manages to avoid this leak [11].
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
88
bits of plaintext. We give an example from the ofï¬cial Desktop
Telegram client in Section VI and treat the Android and iOS
clients in the full version of this work. However, we stress that
the conditions of this attack are difï¬cult to meet in practice. In
particular, to recover bits from a plaintext message block ğ‘šğ‘–
we assume knowledge of message block ğ‘šğ‘–âˆ’1 (we consider this
a relatively mild assumption) and, critically, message block ğ‘š1
which contains two 64-bit random values negotiated between
client and server. Thus, conï¬dentiality hinges on the secrecy of
two random strings â€“ a salt and an id. Notably, these ï¬elds were
not designated for this purpose in the Telegram documentation.
In order to recover ğ‘š1 and thereby enable our plaintext-
recovery attack, in Appendix A we chain it with another attack
on the server-side implementation of Telegramâ€™s key exchange
protocol. This attack exploits how Telegram servers process
RSA ciphertexts. While the exploited behaviour was conï¬rmed
by the Telegram developers, we did not verify it with an
experiment.3 This attack actually breaks server authentication â€“
allowing a MiTM attack â€“ assuming the attack can be completed
before a session times out. But, more germanely, it also allows
us to recover the id ï¬eld. This essentially reduces the overall
security of Telegram to guessing the 64-bit salt ï¬eld. We give a
sketch in Appendix A and details in the full version. We stress,
though, that even if all assumptions we make are met, our
exploit chain â€“ while being considerably cheaper than breaking
the underlying AES-256 encryption â€“ is far from practical.
Yet, it demonstrates the fragility of MTProto, which could be
avoided â€“ along with unstudied assumptions â€“ by relying on
standard authenticated encryption or, indeed, just using TLS.
We conclude with a broader discussion of Telegram security
and with our recommendations in Section VII.
B. Disclosure
We notiï¬ed Telegramâ€™s developers about the vulnerabilities
we found in MTProto on 16 April 2021. They acknowledged
receipt soon after and the behaviours we describe on 8 June
2021. They awarded a bug bounty for the timing side channel
and for the overall analysis. We were informed by the Telegram
developers that they do not do security or bugï¬x releases
except for immediate post-release crash ï¬xes. The development
team also informed us that they did not wish to issue security
advisories at the time of patching nor commit to release dates
for speciï¬c ï¬xes. Therefore, the ï¬xes were rolled out as part of
regular Telegram updates. The Telegram developers informed
us that as of version 7.8.1 for Android, 7.8.3 for iOS and 2.8.8
for Telegram Desktop all vulnerabilities reported here were
addressed. When we write â€œthe current version of MTProtoâ€
or â€œcurrent implementationsâ€, we refer to the versions prior to
those version numbers, i.e. the versions we analysed.
II. Preliminaries
A. Notational conventions
1) Basic notation: Let N = {1, 2, . . .}. For ğ‘– âˆˆ N let [ğ‘–] be
the set {1, . . . , ğ‘–}. We denote the empty string by ğœ€, the empty
3Veriï¬cation would require sending a signiï¬cant number of requests to the
Telegram servers from a geographically close host.
set by âˆ…, and the empty tuple by (). We let ğ‘¥1 â† ğ‘¥2 â† ğ‘£
denote assigning the value ğ‘£ to both ğ‘¥1 and ğ‘¥2. Let ğ‘¥ âˆˆ {0, 1}âˆ—
be any string; then |ğ‘¥| denotes its bit-length, ğ‘¥[ğ‘–] denotes its
ğ‘–-th bit for 0 â‰¤ ğ‘– < |ğ‘¥|, and ğ‘¥[ğ‘ : ğ‘] = ğ‘¥[ğ‘] . . . ğ‘¥[ğ‘ âˆ’ 1] for
0 â‰¤ ğ‘ < ğ‘ â‰¤ |ğ‘¥|. For any ğ‘¥ âˆˆ {0, 1}âˆ— and â„“ âˆˆ N such that
|ğ‘¥| â‰¤ â„“, we write (cid:104)ğ‘¥(cid:105)â„“ to denote the bit-string of length â„“ that
is built by padding ğ‘¥ with leading zeros. For any two strings
ğ‘¥, ğ‘¦ âˆˆ {0, 1}âˆ—, ğ‘¥ (cid:107) ğ‘¦ denotes their concatenation. If ğ‘‹ is a ï¬nite
set, we let ğ‘¥ â†$ ğ‘‹ denote picking an element of ğ‘‹ uniformly
at random and assigning it to ğ‘¥. If T is a table, T[ğ‘–] denotes
the element of the table that is indexed by ğ‘–. We use int64
as a shorthand for a 64-bit integer data type. We use 0x to
preï¬x a hexadecimal string in big-endian order. All variables
are represented in big-endian unless speciï¬ed otherwise. The
symbol âŠ¥âˆ‰ {0, 1}âˆ— denotes an empty table position or an
error code that indicates rejection, such as invalid input to an
algorithm. Uninitialised integers are assumed to be initialised
to 0, Booleans to false, strings to ğœ€, sets to âˆ…, tuples to (), and
tables are initially empty.
2) Algorithms and adversaries: Algorithms may be random-
ised unless otherwise indicated. Running time is worst case.
If ğ´ is an algorithm, ğ‘¦ â† ğ´(ğ‘¥1, . . . ; ğ‘Ÿ) denotes running ğ´ with
random coins ğ‘Ÿ on inputs ğ‘¥1, . . . and assigning the output to ğ‘¦.
If any of inputs taken by ğ´ is âŠ¥, then all of its outputs are âŠ¥.
We let ğ‘¦ â†$ ğ´(ğ‘¥1, . . .) be the result of picking ğ‘Ÿ at random and
letting ğ‘¦ â† ğ´(ğ‘¥1, . . . ; ğ‘Ÿ). We let [ ğ´(ğ‘¥1, . . .)] denote the set
of all possible outputs of ğ´ when invoked with inputs ğ‘¥1, . . ..
Adversaries are algorithms. We require that adversaries never
pass âŠ¥ as input to their oracles.
3) Security games and reductions: We use the code-based
game-playing framework of [13]. Pr[G] denotes the probability
that game G returns true. Variables in each game are shared
with its oracles. In the security reductions, we omit specifying
the running times of the constructed adversaries when they are
roughly the same as the running time of the initial adversary.
B. Standard deï¬nitions
ğ‘“ : D ğ‘“ â†’ R ğ‘“ be a
1) Collision-resistant functions: Let
function. Consider game Gcr of Fig. 1, deï¬ned for ğ‘“ and an
adversary F . The advantage of F in breaking the CR-security
ğ‘“ ,F]. To win the game,
of ğ‘“
adversary F has to ï¬nd two distinct inputs ğ‘¥0, ğ‘¥1 âˆˆ D ğ‘“ such
is unkeyed, so there exists
ğ‘“
that
a trivial adversary F with Advcr
ğ‘“ (F) = 1 whenever ğ‘“ is not
injective. We will use this notion in a constructive way, to build
a speciï¬c collision-resistance adversary F (for ğ‘“ = SHA-256
with a truncated output) in a security reduction.
is deï¬ned as Advcr
ğ‘“ (ğ‘¥0) = ğ‘“ (ğ‘¥1). Note that
ğ‘“ (F) = Pr[Gcr
ğ‘“ ,F
Game Gcr
(ğ‘¥0, ğ‘¥1) â†$ F ; Return (ğ‘¥0 â‰  ğ‘¥1) âˆ§ ( ğ‘“ (ğ‘¥0) = ğ‘“ (ğ‘¥1))
Figure 1: Collision-resistance of function ğ‘“ .
2) Function families: A family of functions F speciï¬es a
deterministic algorithm F.Ev, a key set F.Keys, an input set
F.In and an output length F.ol âˆˆ N. F.Ev takes a function
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:21:42 UTC from IEEE Xplore.  Restrictions apply. 
89
key fk âˆˆ F.Keys and an input ğ‘¥ âˆˆ F.In to return an output
ğ‘¦ âˆˆ {0, 1}F.ol. We write ğ‘¦ â† F.Ev(fk, ğ‘¥). The key length of F
is F.kl âˆˆ N if F.Keys = {0, 1}F.kl.
3) Block ciphers: Let E be a function family. We say that
E is a block cipher if E.In = {0, 1}E.ol, and if E speciï¬es (in
addition to E.Ev) an inverse algorithm E.Inv: {0, 1}E.ol â†’ E.In
such that E.Inv(ek, E.Ev(ek, ğ‘¥)) = ğ‘¥ for all ek âˆˆ E.Keys and all
ğ‘¥ âˆˆ E.In. We refer to E.ol as the block length of E. Our pictures
ğ¾ as a shorthand for E.Ev(ek, Â·) and
and attacks use ğ¸ğ¾ and ğ¸âˆ’1
E.Inv(ek, Â·) respectively.
4) One-time PRF-security of function family: Consider
game Gotprf
F,D of Fig. 2, deï¬ned for a function family F and an
adversary D. The advantage of D in breaking the OTPRF-
F,D ] âˆ’ 1. The
security of F is deï¬ned as Advotprf
game samples a uniformly random challenge bit ğ‘ and runs
adversary D, providing it with access to oracle RoR. The
oracle takes ğ‘¥ âˆˆ F.In as input, and the adversary is allowed
to query the oracle arbitrarily many times. Each time RoR is
queried on any ğ‘¥, it samples a uniformly random key fk from
F.Keys and returns either F.Ev(fk, ğ‘¥) (if ğ‘ = 1) or a uniformly
random element from {0, 1}F.ol (if ğ‘ = 0). D wins if it returns
a bit ğ‘(cid:48) that is equal to the challenge bit.
(D) = 2Â· Pr[Gotprf
F
Game Gotprf
F,D
ğ‘ â†$ {0, 1} ; ğ‘(cid:48) â†$ DRoR
Return ğ‘(cid:48) = ğ‘
Figure 2: One-time PRF-security of function family F.
RoR(ğ‘¥)
fk â†$ F.Keys ; ğ‘¦1 â† F.Ev(fk, ğ‘¥)
ğ‘¦0 â†$ {0, 1}F.ol ; Return ğ‘¦ğ‘
// ğ‘¥ âˆˆ F.In
5) Symmetric encryption schemes: A symmetric encryption
scheme SE speciï¬es algorithms SE.Enc and SE.Dec, where
SE.Dec is deterministic. Associated to SE is a key length
SE.kl âˆˆ N, a message space SE.MS âŠ† {0, 1}âˆ— \ {ğœ€}, and a
ciphertext length function SE.cl: N â†’ N. The encryption
algorithm SE.Enc takes a key ğ‘˜ âˆˆ {0, 1}SE.kl and a message
ğ‘š âˆˆ SE.MS to return a ciphertext ğ‘ âˆˆ {0, 1}SE.cl(|ğ‘š|). We
write ğ‘ â†$ SE.Enc(ğ‘˜, ğ‘š). The decryption algorithm SE.Dec
takes ğ‘˜, ğ‘ to return message ğ‘š âˆˆ SE.MS âˆª {âŠ¥}, where âŠ¥
denotes incorrect decryption. We write ğ‘š â† SE.Dec(ğ‘˜, ğ‘).
Decryption correctness requires that SE.Dec(ğ‘˜, ğ‘) = ğ‘š for all
ğ‘˜ âˆˆ {0, 1}SE.kl, all ğ‘š âˆˆ SE.MS, and all ğ‘ âˆˆ [SE.Enc(ğ‘˜, ğ‘š)]. We
say that SE is deterministic if SE.Enc is deterministic.
6) One-time indistinguishability of SE: Consider game
Gotind$ of Fig. 3, deï¬ned for a deterministic symmetric
encryption scheme SE and an adversary D. We deï¬ne the
advantage of D in breaking the OTIND$-security of SE as
SE,D ] âˆ’ 1. The game proceeds as the
Advotind$
OTPRF game.
7) IGE block cipher mode of operation: Let E be a
block cipher. Deï¬ne the Inï¬nite Garble Extension (IGE)
mode of operation as SE = IGE[E] as in Fig. 4, where
key length is SE.kl = E.kl + 2 Â· E.ol, the message space
SE.MS =ğ‘¡âˆˆN{0, 1}E.olÂ·ğ‘¡ consists of messages whose lengths
(D) = 2 Â· Pr[Gotind$
are multiples of the block length, and the ciphertext length
function SE.cl is the identity function. IGE was ï¬rst deï¬ned
SE
// ğ‘š âˆˆ SE.MS
Game Gotind$
SE,D
ğ‘ â†$ {0, 1} ; ğ‘(cid:48) â†$ DRoR
Return ğ‘(cid:48) = ğ‘
Figure 3: One-time real-or-random indistinguishability of
deterministic symmetric encryption scheme SE.
RoR(ğ‘š)
ğ‘˜ â†$ {0, 1}SE.kl; ğ‘1 â† SE.Enc(ğ‘˜, ğ‘š)
ğ‘0 â†$ {0, 1}SE.cl(|ğ‘š|) ; Return ğ‘ğ‘