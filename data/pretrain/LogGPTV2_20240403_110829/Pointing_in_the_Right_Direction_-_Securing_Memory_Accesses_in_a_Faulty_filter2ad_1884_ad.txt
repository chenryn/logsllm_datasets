tions on the target architecture. Finally, we analyze the software
Figure 4: Modified processor pipeline. The instruction de-
code stage is extended with a 12-bit residue encoder, the ex-
ecution stage with a residue ALU, and the write-back stage
with a pointer-reduction data-linking unit.
Figure 5: Residue ALU with a 41-bit adder and a shared
residue encoder. The addition result
is automatically
checked after the operation by re-encoding the result and
comparing it with the computed residues and generating a
redundant error signal.
The new residue ALU is shown in detail in Figure 5. The ALU
supports encoding and decoding of values to/from the multi-residue
domain as well as adding and subtracting two encoded values. The
design of the ALU is optimized to require only one residue adder
and one encoder in the execution stage of the processor. Decoding
is for free since it only requires rewiring, where the upper bits are
set to zero. After performing an addition, the functional value of the
adder result is re-encoded and compared with the independently
computed residues in order to perform error-checking after each
residue instruction. If the computed residues and the newly re-
encoded residues mismatch, a redundant error signal is generated
to force the processor into a safe state. Since this adder is also used
for computing the final pointer address during a memory access
(the encoded immediate value is added to the encoded base pointer),
every pointer is also checked before performing a memory access.
With frequent checks for every result, we minimize the probability
that error masking occurs and errors are not detectable anymore.
Currently, the residue encoder uses special algorithms from [22]
to encode data. However, the residue adder is implemented without
any further optimizations. By using optimized arithmetic opera-
tions, e.g., the one from [36], the hardware overhead can be further
reduced.
PtrReduceResALUResEncModReduceResEncodeCmprs2644123rs1rs1isRencisRenc4123ResError5ResALUPointing in the Right Direction - Securing Memory Accesses in a Faulty World
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Table 1: Code and runtime overhead for different bench-
mark programs from an HDL simulation.
Code Overhead
Baseline Overhead
Runtime Overhead
Baseline Overhead
[kCycles]
Benchmark
fir
fft
keccak
ipm
aes_cbc
conv2d
Average
[kB]
4.26
6.52
4.79
4.84
7.25
3.26
[%]
8.54
6.57
10.11
12.81
8.77
13.12
9.99
39.22
58.01
255.55
10.80
60.91
5.92
[%]
6.35
4.65
11.31
3.94
9.10
2.70
6.34
overhead, discuss the overhead sources, and describe future opti-
mization possibilities.
To quantify the hardware overhead, we synthesize the hardware
architecture for a Xilinx Artix-7 series FPGA. By adding the new
instructions, a dedicated ALU for multi-residue operations, and
a modified load-and-store unit, the required number of lookup-
tables (LUTs) increases by less than 5 %, and the number of flip-
flops increases by less than 1 %. However, this prototype design
is implemented without optimizations leaving space to further
improve the design.
The custom LLVM toolchain based on LLVM 6.0 is used to com-
pile different benchmark applications for the RISC-V-based target
architecture. The benchmarks were taken from the PULPino reposi-
tory [32], which were used to originally evaluate the performance
of the RI5CY core. Simulation is performed using a cycle accurate
HDL simulation of the target processor. As baseline, we simulate
the benchmark applications solely with enabled CFI protection [35]
but without an application-specific data protection scheme. On
top of that baseline, we determine the exclusive overhead of our
countermeasure in terms of code size and runtime.
As shown in Table 1, on overage, the code overhead is 10 % and
the runtime overhead is less than 7 %. This is a comparable bet-
ter performance to ANB-codes, which have an average runtime
overhead of 90 % compared to AN-codes solely to provide memory
access protection. Instead, our countermeasure has a considerable
lower overhead, making it attractive for many real-world applica-
tions.
6.1 Future Work
The overhead numbers are already competitive for practical usage.
Still, some improvements regarding code size or performance have
not been performed yet.
For example, pointer comparisons in the encoded domain are
currently only implemented for equal and not equal. Although sel-
domly used, comparisons with other predicates are still performed
on the functional value. Similarly, in are rare cases, when pointer
arithmetic uses unsupported logical operations, the operations is
performed on the functional value only. Adding support for these
operations further reduces the overhead and slightly increases the
protection domain.
Furthermore, our current toolchain has not been highly opti-
mized for our prototype architecture yet. We expect that, with a
more optimized compiler, even better results can be achieved in the
future.
7 CONCLUSION
Memory accesses are frequently used operations, and many differ-
ent security policies, as well as safety mechanisms, rely on their
correct execution. However, when dealing with faults, a correct-
ness of a memory access cannot be guaranteed. While there are
dedicated methods to protect the control-flow of a program and to
protect the data in memory and registers, there is no efficient pro-
tection mechanism to protect the memory access against address
tampering.
In this work, we closed this gap and presented a new mechanism
to protect memory accesses inside a program. The countermea-
sure is employed in two steps. First, all pointers including pointer
arithmetic are protected by employing a multi-residue code. The
redundancy is hereby directly stored inside the unused upper bits
of the pointer, which does not add any memory overhead. The sec-
ond step links the redundant pointer with the data. Subsequently,
addressing errors manifest as data errors and get detectable as soon
the data is loaded into the register. This linking approach is uni-
versally applicable and can be used on top of any data protection
scheme.
To demonstrate the practicability of our countermeasure, we
integrated the concept of protected memory accesses into a RISC-
V processor. We extended the instruction set to deal with multi-
residue encoded pointers and added new memory operations which
perform the linking and unlinking step. Furthermore, we extended
the LLVM compiler to automatically transform all pointers of a
program to the encoded domain. Our evaluation showed an average
code overhead of 10 % and an average runtime overhead of less
than 7 %, which makes this countermeasure practical for real-life
applications.
8 ACKNOWLEDGMENT
This project has received funding from the European Research
Council (ERC) under the European Union’s Horizon 2020 research
and innovation programme (grant agreement No 681402) and by
the Austrian Research Promotion Agency (FFG) via the competence
center Know-Center (grant number 844595), which is funded in the
context of COMET - Competence Centers for Excellent Technolo-
gies by BMVIT, BMWFW, and Styria.
REFERENCES
[1] Subidh Ali, Debdeep Mukhopadhyay, and Michael Tunstall. 2013. Differential
fault analysis of AES: towards reaching its limits. J. Cryptographic Engineering 3
(2013), 73–97. https://doi.org/10.1007/s13389-012-0046-y
[2] Hagai Bar-El, Hamid Choukri, David Naccache, Michael Tunstall, and Claire
Whelan. 2006. The Sorcerer’s Apprentice Guide to Fault Attacks. Proc. IEEE 94
(2006), 370–382. https://doi.org/10.1109/JPROC.2005.862424
[3] Alessandro Barenghi, Luca Breveglieri, Israel Koren, Gerardo Pelosi, and
Francesco Regazzoni. 2010. Countermeasures against fault attacks on software
implemented AES: effectiveness and cost. In Workshop on Embedded Systems
Security – WESS 2010. ACM, 7. https://doi.org/10.1145/1873548.1873555
[4] Robert C Baumann. 2005. Radiation-induced soft errors in advanced semicon-
ductor technologies. IEEE Transactions on Device and materials reliability 5, 3
(2005), 305–316.
ACSAC ’18, December 3–7, 2018, San Juan, PR, USA
Robert Schilling, Mario Werner, Pascal Nasahl, and Stefan Mangard
[5] Dan Boneh, Richard A. DeMillo, and Richard J. Lipton. 2001. On the Importance
of Eliminating Errors in Cryptographic Computations. J. Cryptology 14 (2001),
101–119. https://doi.org/10.1007/s001450010016
[6] Jakub Breier, Dirmanto Jap, and Chien-Ning Chen. 2015. Laser Profiling for the
Back-Side Fault Attacks: With a Practical Laser Skip Instruction Attack on AES. In
Conference on Computer and Communications Security – CCS 2015, Jianying Zhou
and Douglas Jones (Eds.). ACM, 99–103. https://doi.org/10.1145/2732198.2732206
[7] David T. Brown. 1960. Error Detecting and Correcting Binary Codes for
IRE Trans. Electronic Computers 9 (1960), 333–337.
Arithmetic Operations.
https://doi.org/10.1109/TEC.1960.5219855
[8] Ruan de Clercq, Johannes Götzfried, David Übler, Pieter Maene, and Ingrid Ver-
bauwhede. 2017. SOFIA: Software and control flow integrity architecture. Com-
puters & Security 68 (2017), 16–35. https://doi.org/10.1016/j.cose.2017.03.013
[9] Odile Derouet. 2007. Secure smartcard design against laser fault injection. In 2007
Workshop on Fault Diagnosis and Tolerance in Cryptography, FDTC 2007, Vienna,
Austria, 10 September 2007. 87.
[10] Philippe Forin. 1990. Vital coded microprocessor principles and application for
various transit systems. In Control, Computers, Communications in Transportation.
Elsevier, 79–84.
[11] Christophe Giraud and Hugues Thiebeauld. 2004. A Survey on Fault Attacks. In
Smart Card Research and Advanced Applications – CARDIS 2004 (IFIP), Jean-Jacques
Quisquater, Pierre Paradinas, Yves Deswarte, and Anas Abou El Kalam (Eds.),
Vol. 153. Kluwer/Springer, 159–176. https://doi.org/10.1007/1-4020-8147-2_11
[12] Daniel Gruss, Clémentine Maurice, and Stefan Mangard. 2016. Rowhammer.js: A
Remote Software-Induced Fault Attack in JavaScript. In Detection of Intrusions
and Malware & Vulnerability Assessment – DIMVA 2016 (LNCS), Juan Caballero,
Urko Zurutuza, and Ricardo J. Rodríguez (Eds.), Vol. 9721. Springer, 300–321.
https://doi.org/10.1007/978-3-319-40667-1_15
[13] Richard W Hamming. 1950. Error detecting and error correcting codes. Bell Labs
Technical Journal 29, 2 (1950), 147–160.
[14] Martin Hoffmann, Peter Ulbrich, Christian Dietrich, Horst Schirmeier, Daniel
Lohmann, and Wolfgang Schröder-Preikschat. 2014. A Practitioner’s Guide to
Software-Based Soft-Error Mitigation Using AN-Codes. In IEEE International
Symposium on High-Assurance Systems Engineering – HASE 2014. IEEE Computer
Society, 33–40. https://doi.org/10.1109/HASE.2014.14
[15] Douglas W. Jones. 2001. Modulus without Division, a tutorial. http://homepage.
divms.uiowa.edu/~jones/bcd/mod.shtml. (2001). Accessed: 2018-05-15.
[16] Yoongu Kim, Ross Daly, Jeremie Kim, Chris Fallin, Ji-Hye Lee, Donghyuk Lee,
Chris Wilkerson, Konrad Lai, and Onur Mutlu. 2014. Flipping bits in memory
without accessing them: An experimental study of DRAM disturbance errors. In
International Symposium on Computer Architecture – ISCA 2014. IEEE Computer
Society, 361–372. https://doi.org/10.1109/ISCA.2014.6853210
[17] Chris Lattner and Vikram S. Adve. 2004. LLVM: A Compilation Framework
for Lifelong Program Analysis & Transformation. In IEEE / ACM International
Symposium on Code Generation and Optimization – CGO 2004. IEEE Computer
Society, 75–88. https://doi.org/10.1109/CGO.2004.1281665
[18] Moritz Lipp, Misiker Tadesse Aga, Michael Schwarz, Daniel Gruss, Clémentine
Maurice, Lukas Raab, and Lukas Lamster. 2018. Nethammer: Inducing Rowham-
mer Faults through Network Requests. arXiv preprint arXiv:1805.04956 (2018).
[19] James L Massey. 1964. Survey of residue coding for arithmetic errors. International
Computation Center Bulletin 3, 4 (1964), 3–17.
[20] Marcel Medwed and Stefan Mangard. 2011. Arithmetic logic units with high
error detection rates to counteract fault attacks. In Design, Automation & Test in
Europe Conference & Exhibition – DATE 2011. IEEE, 1644–1649. https://doi.org/10.
1109/DATE.2011.5763261
[21] Marcel Medwed and Jörn-Marc Schmidt. 2009. Coding Schemes for Arithmetic
and Logic Operations - How Robust Are They?. In Information Security Appli-
cations – WISA 2009 (LNCS), Heung Youl Youm and Moti Yung (Eds.), Vol. 5932.
Springer, 51–65. https://doi.org/10.1007/978-3-642-10838-9_5
[22] Andreas Persson and Lars Bengtsson. 2009. Forward and Reverse Converters and
Moduli Set Selection in Signed-Digit Residue Number Systems. Signal Processing
Systems 56 (2009), 1–15. https://doi.org/10.1007/s11265-008-0249-8
[23] William W. Peterson. 1961. Error-correcting codes. M.I.T. Press [u.a.], Cambridge,
Mass. [u.a.].
2017.
(2017).
[24] Inc. Qualcomm Technologies.
ARMv8.3.
whitepaper-pointer-authentication-on-armv8-3.pdf.
2018-05-15.
Pointer Authentication on
https://www.qualcomm.com/media/documents/files/
Accessed:
[25] Thammavarapu R. N. Rao. 1970. Biresidue Error-Correcting Codes for Computer
Arithmetic. IEEE Trans. Computers 19 (1970), 398–402. https://doi.org/10.1109/
T-C.1970.222937
[26] Thammavarapu R. N. Rao and Oscar N. Garcia. 1971. Cyclic and multiresidue
codes for arithmetic operations. IEEE Trans. Information Theory 17 (1971), 85–91.
https://doi.org/10.1109/TIT.1971.1054579
[27] Pablo Rauzy and Sylvain Guilley. 2014. Countermeasures against High-Order
Fault-Injection Attacks on CRT-RSA. In Fault Diagnosis and Tolerance in Cryptog-
raphy – FDTC 2014, Assia Tria and Dooho Choi (Eds.). IEEE Computer Society,
68–82. https://doi.org/10.1109/FDTC.2014.17
[28] Ute Schiffel, André Schmitt, Martin Süßkraut, and Christof Fetzer. 2010. ANB-
and ANBDmem-Encoding: Detecting Hardware Errors in Software. In Computer
Safety, Reliability and Security – SAFECOMP 2010 (LNCS), Erwin Schoitsch (Ed.),
Vol. 6351. Springer, 169–182. https://doi.org/10.1007/978-3-642-15651-9_13
[29] Robert Schilling, Mario Werner, and Stefan Mangard. 2018. Securing Conditional
Branches in the Presence of Fault Attacks. CoRR abs/1803.08359 (2018). http:
//arxiv.org/abs/1803.08359
[30] Bodo Selmke, Stefan Brummer, Johann Heyszl, and Georg Sigl. 2015. Precise Laser
Fault Injections into 90 nm and 45 nm SRAM-cells. In Smart Card Research and Ad-
vanced Applications – CARDIS 2015 (LNCS), Naofumi Homma and Marcel Medwed
(Eds.), Vol. 9514. Springer, 193–205. https://doi.org/10.1007/978-3-319-31271-2_12
[31] Andrei Tatar, Radhesh Krishnan, Elias Athanasopoulos, Cristiano Giuffrida, Her-
bert Bos, and Kaveh Razavi. 2018. Throwhammer: Rowhammer Attacks over the
Network and Defenses. In USENIX ATC.
[32] PULP Team. 2018. PULPino: An open-source single-core microcontroller system.
https://github.com/pulp-platform/pulpino. (2018). Accessed: 2018-05-15.
[33] PULP Team. 2018. RI5CY: RISC-V Core. https://github.com/pulp-platform/riscv.
(2018). Accessed: 2018-05-15.
[34] Andrew Waterman, Yunsup Lee, David A. Patterson, Krste Asanovic, Volume
I User level Isa, Andrew Waterman, Yunsup Lee, and David Patterson. 2014. The
RISC-V Instruction Set Manual. (2014).
[35] Mario Werner, Thomas Unterluggauer, David Schaffenrath, and Stefan Man-
gard. 2018. Sponge-Based Control-Flow Protection for IoT Devices. CoRR
abs/1802.06691 (2018). http://arxiv.org/abs/1802.06691
[36] Reto Zimmermann. 1999. Efficient VLSI Implementation of Modulo (2ˆn=B11)
Addition and Multiplication. In Symposium on Computer Arithmetic – ARITH 1999.
IEEE Computer Society, 158–167. https://doi.org/10.1109/ARITH.1999.762841