title:Enhanced Certificate Transparency and End-to-End Encrypted Mail
author:Mark Dermot Ryan
Enhanced Certiﬁcate Transparency and
End-to-end Encrypted Mail
Mark D. Ryan
University of Birmingham, UK
CloudTomo Ltd.
Abstract—The certiﬁcate authority model for authenticating
public keys of websites has been attacked in recent years, and
several proposals have been made to reinforce it. We develop
and extend certiﬁcate transparency, a proposal in this direction,
so that it efﬁciently handles certiﬁcate revocation. We show
how this extension can be used to build a secure end-to-end
email or messaging system using PKI with no requirement
to trust certiﬁcate authorities, or to rely on complex peer-to-
peer key-signing arrangements such as PGP. This makes end-
to-end encrypted mail possible, with apparently few additional
usability issues compared to unencrypted mail (speciﬁcally, users
do not need to understand or concern themselves with keys
or certiﬁcates). Underlying these ideas is a new attacker model
appropriate for cloud computing, which we call “malicious-but-
cautious”.
1
Introduction
1.1 Background and motivation
Public-key cryptography relies on entities being able to
obtain authentic copies of other entities’ public keys. For
example, suppose a user wishes to log in to their bank account
through their web browser. The web session will be secured by
the public key of the bank. If the user’s web browser accepts
the wrong public key for the bank, then the trafﬁc (including
login credentials) can be intercepted and manipulated by an
attacker.
In order to avoid such attacks, certiﬁcate authorities (CAs)
are used assure an entity about the public key of another one. In
the example given, the browser is presented with a public key
certiﬁcate for the bank, which is intended to be unforgeable
evidence that the given public key is the correct one for the
bank. The certiﬁcate is digitally signed by a CA. The browser
is pre-conﬁgured to accept certiﬁcates from certain known
Permission(cid:1) to(cid:1) freely(cid:1) reproduce(cid:1) all(cid:1) or(cid:1) part(cid:1) of(cid:1) this(cid:1) paper(cid:1) for(cid:1) noncommercial(cid:1)
purposes(cid:1)is(cid:1)granted(cid:1)provided(cid:1)that(cid:1)copies(cid:1)bear(cid:1)this(cid:1)notice(cid:1)and(cid:1)the(cid:1)full(cid:1)citation(cid:1)
on(cid:1)the(cid:1)ﬁrst(cid:1)page.(cid:1)Reproduction(cid:1)for(cid:1)commercial(cid:1)purposes(cid:1)is(cid:1)strictly(cid:1)prohibited(cid:1)
without(cid:1)the(cid:1)prior(cid:1)written(cid:1)consent(cid:1)of(cid:1)the(cid:1)Internet(cid:1)Society,(cid:1)the(cid:1)ﬁrst-named(cid:1)author(cid:1)
(for(cid:1) reproduction(cid:1) of(cid:1) an(cid:1) entire(cid:1) paper(cid:1) only),(cid:1) and(cid:1) the(cid:1) author’s(cid:1) employer(cid:1) if(cid:1) the(cid:1)
paper(cid:1)was(cid:1)prepared(cid:1)within(cid:1)the(cid:1)scope(cid:1)of(cid:1)employment.
NDSS(cid:1)’14,(cid:1)23-26(cid:1)February(cid:1)2014,(cid:1)San(cid:1)Diego,(cid:1)CA,(cid:1)USA
Copyright(cid:1)2014(cid:1)Internet(cid:1)Society,(cid:1)ISBN(cid:1)1-891562-35-5
http://dx.doi.org/10.14722/ndss.2014.23379
CAs. A typical installation of Firefox has about 100 CAs in
its database.
Aside from cryptography issues [1], [2], [3], there are
two big problems with the CA model. Firstly, CAs must be
assumed to be trustworthy. If a CA is dishonest or compro-
mised, it may issue certiﬁcates asserting the authenticity of
fake keys; those keys could be created by an attacker or by the
CA itself. Unfortunately, the assumption of honesty does not
scale up very well. As already mentioned, a browser typically
has hundreds of CAs registered in it, and the user cannot
be expected to have evaluated the trustworthiness of all of
them. This fact has been exploited by attackers. If an attacker
manages to insert a malicious CA into the user’s browser, the
attacker can get the browser to accept fake keys for standard
services (such as bank web sites and webmail sites). Then
the attacker can intercept and manipulate the user’s trafﬁc
with those sites. Many attacks based on these ideas have been
reported [4], [5], [6], [7], [8], [9]. In 2011, two CAs were
compromised: Comodo [10] and DigiNotar [11]. In both cases,
certiﬁcates for high-proﬁle sites were illegitimately obtained,
and in the second case, reportedly used in an MITM attack
[12].
A second problem with the CA model is key revocation.
If a certiﬁcate owner loses control of its private key, it needs
to revoke the certiﬁcate before its expiration date. Currently,
web browsers attempt to check revocation on the ﬂy: the
browser queries the CA to verify that a certiﬁcate hasn’t been
revoked. Unfortunately, that solution doesn’t work well; it
poses a large burden on CAs to respond to such requests; it
can be defeated by attackers that block such requests; and it
has privacy implications for web users.
Several interesting solutions have been proposed to address
these problems. (For a good survey, see [13].) Certiﬁcate
pinning addresses the problem of untrustworthy CAs, by
restricting in the client browser parameters concerning the set
of CAs that are considered entitled to certify the key for a
given domain [14], [15]. Crowd-sourcing techniques have been
proposed in order to detect untrustworthy CAs, by enabling a
browser to obtain warnings if the certiﬁcates it is offered are
out of line with those that other people are being offered [16],
[17], [18], [19]. In another direction, certiﬁcate transparency
[20] is an approach which aims to prevent certiﬁcate authorities
from issuing public key certiﬁcates for a domain without
being visible to the owner of the domain. The core idea is
that a public append-only log is maintained, showing all the
certiﬁcates that have been issued. A certiﬁcate is accepted only
if it is accompanied by a proof that it has been inserted into
the log.
Solutions for revocation management have also been pro-
posed; they mostly involve periodically pushing revocation
lists to browsers, in order to remove the need for on-the-ﬂy
revocation checking [21], [22]. However, this solution creates
a window during which the browser’s revocation lists are out
of date until the next push. Revocation transparency [23] is
an extension of certiﬁcate transparency that aims to deal with
revocation, although (as we later explain) we believe it does
not scale up, since it requires space and time for each relying
party that is linear in the number of revocations.
1.2 Extending certiﬁcate transparency
Certiﬁcate transparency solves the problem that CAs are
required to be trusted. It uses public logs and optionally gossip
protocols to ensure that CAs leave persistent evidence of all
the certiﬁcates they issue. In that way, the activities of a CA
are visible (“transparent”) to its users and to observers. Users
accept a certiﬁcate only if it is accompanied by a proof that
it is included in the log. The proofs are short and efﬁciently
veriﬁable by browsers. Even if there are 109 certiﬁcates, the
proofs amount to 1KB or 2KB of data.
Unfortunately, certiﬁcate transparency does not handle
revocation efﬁciently. The core proposal in the IETF draft
[20] does not specify any revocation mechanism. An informal
proposal for handling revocation exists [23], but adopting it
has the side-effect of dramatically reducing the efﬁciency of
certiﬁcate transparency. Roughly speaking, the size of proofs
grows from 1KB or 2KB to tens or hundreds of GB.
We extend certiﬁcate transparency to handle revocation
efﬁciently. In our extension, proofs that a key is current (i.e.,
issued and not revoked) are as efﬁcient as proofs of issuance
in certiﬁcate transparency. Proofs of absence (i.e., proofs that
a CA has not issued any certiﬁcates for a subject) are also as
efﬁcient. Thus, all the proofs that browsers request are efﬁcient
in our extension.
Certiﬁcate transparency was developed for web certiﬁcates,
but we demonstrate in this paper that, once extended to handle
revocation efﬁciently, it can be applied to address the problem
of end-to-end encrypted email too. As mentioned, the core
property of certiﬁcate transparency is that it allows CAs to be
untrusted. By using (our extension of) certiﬁcate transparency
as a foundation, we detail a method in which an untrusted
provider can act both as a CA and as a provider of the email
service. This allows users to send encrypted mail without
having to understand anything about keys or certiﬁcates, and
without having to rely on any trusted parties.
1.4 Our contribution
We develop and extend the idea of certiﬁcate transparency,
and we apply it to email encryption. In particular,
• We rework certiﬁcate transparency so that it properly
handles revocation, in space/time which is logarithmic
in the number of revocations.
• We show how it can be used to build a secure email or
messaging service using PKI with no trusted parties.
• We develop a new attacker model appropriate for
cloud computing, which we call “malicious-but-
cautious”.
Structure of paper: In section 2, we review some background
material on which the paper relies. Section 3 details our
extension to certiﬁcate transparency, which we call certiﬁcate
issuance and revocation transparency (CIRT) to emphasise
that
it efﬁciently handles certiﬁcate revocation as well as
issuance. In section 4, we describe the application of CIRT
to email, and show that it enables end-to-end encrypted email
without requiring any trusted parties (such as CAs), and
without requiring any additional understanding or effort from
users. Discussion of our attacker model, called the “malicious
but cautious” attacker, is made in section 5.
2 Background
1.3 End-to-end encrypted mail
We review some of the background material on which the
paper relies.
Public-key cryptography was invented to allow users to
send encrypted mail1; nevertheless, 35 years later, in practice
it is rather hard for users to encrypt their mail in a systematic
way. S/MIME and PGP exist but have failed to take off [24].
This failure of adoption of encryption for mail is in marked
contrast with the encryption for the web, where encrypted
browsing is routinely done by billions of users each day.
Numerous efforts to improve this situation have been made (a
brief review is in §2.4), but none of them simultaneously satisfy
the requirements of usability (there should be no confusing
warning messages about keys and certiﬁcates) and security
(encryption should be end-to-end, and there should be no
trusted parties).
1Indeed, the ﬁrst line of the 1978 RSA paper is: The era of “electronic
mail” may soon be upon us; we must ensure that [. . . ] messages are private.
2.1 Merkle trees
A Merkle tree is a tree in which every node is labelled
with the hash of the labels of its children nodes, and possibly
some other values. Suppose a node has n children labelled with
hash values v1, . . . , vn, and has data d. Then the hash value
label of the node is the hash of v1, . . . , vn, d. Merkle trees
allow efﬁcient proofs that they contain certain data. To prove
that a certain data item d is part of a Merkle tree requires an
amount of data proportional to the log of the number of nodes
of the tree. (This contrasts with hash lists, where the amount
is proportional to the number of nodes.)
Example: Figure 1 shows a Merkle tree containing data
items c1, . . . , c6 stored at the leaf nodes (in this tree, there
2
h(h(h(c1, c2), h(c3, c4)), h(c5, c6))
in the log, and the proof of extension of the log), can be done
in time/space O(log n).
h(h(c1, c2), h(c3, c4))
h(c5, c6)
h(c1, c2)
h(c3, c4)
c5
c6
c1
c2
c3
c4
Fig. 1. A Merkle tree containing items c1, . . . , c6.
are no data items stored at non-leaf nodes). Figure 2 shows
a larger Merkle tree containing data items c1, . . . , c32 (again
in this case stored only at leaves). To demonstrate that c11 is
present in the tree, it is sufﬁcient to provide the additional data
c12, h5, h14, h16, h20, i.e. one data item per layer of the tree.
The recipient of this data can then verify the correctness of the
root hash h21. Proving that one Merkle tree extends another
can also be done in logarithmic space and time, by providing
at most one hash value per layer. For example, to demonstrate
that the tree of Figure 2 is an extension of the one in Figure 1,
it is sufﬁcient to provide the data h4, h17, h20. The hash value
at the root of the tree is called the root hash (or simply the
hash) of the tree.
2.2 Certiﬁcate transparency
Certiﬁcate transparency [20], [25], [26] is a technique
invented by Google that aims to prevent TLS [27], [28], [29]
certiﬁcate authorities from issuing public key certiﬁcates for a
domain without being visible to the owner of the domain. It is
aimed at website certiﬁcates, and the technology is being built
into Google Chrome.
The core idea is that a public log is maintained, showing
all the certiﬁcates that have been issued. The log is append-
only. Anyone can append a certiﬁcate to the log. Auditors can
obtain two types of proofs: (a) a proof that the log contains
a given certiﬁcate, and (b) a proof that a snapshot of the log
is an extension of another snapshot (i.e., only appends have
taken place between the two snapshot).
Abstractly, we may consider a certiﬁcate as a signed
pair (subj , pk subj ), asserting that a subject subj ’s public key
is pk subj . In certiﬁcate transparency, the CA’s database of
certiﬁcates is maintained as a Merkle tree in which these pairs
are stored left-to-right in chronological order at the leaves of
the tree (Figures 1 and 2). Items are added chronologically, by
extending the tree to the right. A certiﬁcate is accepted by a
browser only if it is accompanied by a proof that the subject-
key pair has been inserted into the log. Observers can check
that the log is maintained as append-only. To perform such a
check, the observer submits to the CA the hash value of the
log at two different times. The CA returns a proof that the log
corresponding to the later hash value is an extension of the log
at the earlier time. The properties of Merkle trees ensure that
insertion into the log, and both proofs (the proof of presence
Linearity: It is vital that the log is a single linear record. If the
log maintainer can create different versions of the log to show
to different users, the security is lost. Linearity is maintained
in two ways. Firstly, whenever a user interacts with the log,
it requests proof that the current snapshot is an extension
of the previously cached snapshot. This is best done before
authentication, to avoid the possibility that a version specially
constructed for a particular user is being used. Second, gossip
protocols [30] can be used to disseminate values of the log.
This means that users of the log (that is, client browsers) need
to have a way to exchange with other users the value of the
hash of the log that they have received. At any time, a user
can request proof that the snapshot currently offered by the
log is an extension of a previous snapshot received through
direct communication with other users.
2.2.1 Revocation transparency: In certiﬁcate transparency,
one can prove that a certiﬁcate is in the log, but there is no
notion of whether it is still current. Revocation transparency
[23] is an extension of certiﬁcate transparency that aims to
deal with revocation. Two alternative methods for revocation
transparency are proposed. The ﬁrst method stores revocations
in a data structure called a sparse Merkle tree, which is a
Merkle tree in which most of the leaves are zero. A path in this
tree has length 256, and represents the hash of a certiﬁcate. The
path ends in a 1 or 0 leaf according to whether the certiﬁcate
is revoked or not. The tree is thus a binary tree with 2256
leaves, but because it is sparse, these leaves do not have to be
stored individually. To revoke a certiﬁcate, one alters the sparse
Merkle tree so that the relevant path terminates in a 1, and one
enters a record of this action in the certiﬁcate-transparency
append-only log. Unfortunately, checking whether a certiﬁcate
has been revoked is inefﬁcient. One method is to track the
revocations by a separate mechanism, an action which is
linear in the number of revocations, which in turn can be
assumed proportional
to the number of issued certiﬁcates.