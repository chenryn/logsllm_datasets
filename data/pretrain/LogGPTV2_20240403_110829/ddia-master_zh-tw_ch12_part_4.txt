### 组合使用资料储存技术
在本书的过程中，我们讨论了资料库提供的各种功能及其工作原理，其中包括：
* 次级索引，使你可以根据栏位的值有效地搜寻记录（请参阅 “[其他索引结构](ch3.md#其他索引结构)”）
* 物化检视，这是一种预计算的查询结果快取（请参阅 “[聚合：资料立方体和物化检视](ch3.md#聚合：资料立方体和物化检视)”）
* 复制日志，保持其他节点上资料的副本最新（请参阅 “[复制日志的实现](ch5.md#复制日志的实现)”）
* 全文搜寻索引，允许在文字中进行关键字搜寻（请参阅 “[全文搜寻和模糊索引](ch3.md#全文搜寻和模糊索引)”），也内置于某些关系资料库【1】
在 [第十章](ch10.md) 和 [第十一章](ch11.md) 中，出现了类似的主题。我们讨论了如何构建全文搜寻索引（请参阅 “[批处理工作流的输出](ch10.md#批处理工作流的输出)”），了解了如何维护物化检视（请参阅 “[维护物化检视](ch11.md#维护物化检视)”）以及如何将变更从资料库复制到衍生资料系统（请参阅 “[变更资料捕获](ch11.md#变更资料捕获)”）。
资料库中内建的功能与人们用批处理和流处理器构建的衍生资料系统似乎有相似之处。
#### 建立索引
想想当你执行 `CREATE INDEX` 在关系资料库中建立一个新的索引时会发生什么。资料库必须扫描表的一致性快照，挑选出所有被索引的栏位值，对它们进行排序，然后写出索引。然后它必须处理自一致快照以来所做的写入操作（假设表在建立索引时未被锁定，所以写操作可能会继续）。一旦完成，只要事务写入表中，资料库就必须继续保持索引最新。
此过程非常类似于设定新的从库副本（请参阅 “[设定新从库](ch5.md#设定新从库)”），也非常类似于流处理系统中的 **引导（bootstrap）** 变更资料捕获（请参阅 “[初始快照](ch11.md#初始快照)”）。
无论何时执行 `CREATE INDEX`，资料库都会重新处理现有资料集（如 “[应用演化后重新处理资料](#应用演化后重新处理资料)” 中所述），并将该索引作为新检视汇出到现有资料上。现有资料可能是状态的快照，而不是所有发生变化的日志，但两者密切相关（请参阅 “[状态、流和不变性](ch11.md#状态、流和不变性)”）。
#### 一切的元资料库
有鉴于此，我认为整个组织的资料流开始像一个巨大的资料库【7】。每当批处理、流或 ETL 过程将资料从一个地方传输到另一个地方并组装时，它表现地就像资料库子系统一样，使索引或物化检视保持最新。
从这种角度来看，批处理和流处理器就像精心实现的触发器、储存过程和物化检视维护例程。它们维护的衍生资料系统就像不同的索引型别。例如，关系资料库可能支援 B 树索引、杂凑索引、空间索引（请参阅 “[多列索引](ch3.md#多列索引)”）以及其他型别的索引。在新兴的衍生资料系统架构中，不是将这些设施作为单个整合资料库产品的功能实现，而是由各种不同的软体提供，执行在不同的机器上，由不同的团队管理。
这些发展在未来将会把我们带到哪里？如果我们从没有适合所有访问模式的单一资料模型或储存格式的前提出发，我推测有两种途径可以将不同的储存和处理工具组合成一个有凝聚力的系统：
**联合资料库：统一读取**
可以为各种各样的底层储存引擎和处理方法提供一个统一的查询介面 —— 一种称为 **联合资料库（federated database）** 或 **多型储存（polystore）** 的方法【18,19】。例如，PostgreSQL 的 **外部资料包装器（foreign data wrapper）** 功能符合这种模式【20】。需要专用资料模型或查询介面的应用程式仍然可以直接访问底层储存引擎，而想要组合来自不同位置的资料的使用者可以透过联合介面轻松完成操作。
联合查询介面遵循著单一整合系统的关系型传统，带有高阶查询语言和优雅的语义，但实现起来非常复杂。
**分拆资料库：统一写入**
虽然联合能解决跨多个不同系统的只读查询问题，但它并没有很好的解决跨系统 **同步** 写入的问题。我们说过，在单个数据库中，建立一致的索引是一项内建功能。当我们构建多个储存系统时，我们同样需要确保所有资料变更都会在所有正确的位置结束，即使在出现故障时也是如此。想要更容易地将储存系统可靠地插接在一起（例如，透过变更资料捕获和事件日志），就像将资料库的索引维护功能以可以跨不同技术同步写入的方式分开【7,21】。
分拆方法遵循 Unix 传统的小型工具，它可以很好地完成一件事【22】，透过统一的低层级 API（管道）进行通讯，并且可以使用更高层级的语言进行组合（shell）【16】 。
#### 开展分拆工作
联合和分拆是一个硬币的两面：用不同的元件构成可靠、 可伸缩和可维护的系统。联合只读查询需要将一个数据模型对映到另一个数据模型，这需要一些思考，但最终还是一个可解决的问题。而我认为同步写入到几个储存系统是更困难的工程问题，所以我将重点关注它。
传统的同步写入方法需要跨异构储存系统的分散式事务【18】，我认为这是错误的解决方案（请参阅 “[衍生资料与分散式事务](#衍生资料与分散式事务)”）。单个储存或流处理系统内的事务是可行的，但是当资料跨越不同技术之间的边界时，我认为具有幂等写入的非同步事件日志是一种更加健壮和实用的方法。
例如，分散式事务在某些流处理元件内部使用，以匹配 **恰好一次（exactly-once）** 语义（请参阅 “[原子提交再现](ch11.md#原子提交再现)”），这可以很好地工作。然而，当事务需要涉及由不同人群编写的系统时（例如，当资料从流处理元件写入分散式键值储存或搜寻索引时），缺乏标准化的事务协议会使整合更难。有幂等消费者的有序事件日志（请参阅 “[幂等性](ch11.md#幂等性)”）是一种更简单的抽象，因此在异构系统中实现更加可行【7】。
基于日志的整合的一大优势是各个元件之间的 **松散耦合（loose coupling）**，这体现在两个方面：
1. 在系统级别，非同步事件流使整个系统在个别元件的中断或效能下降时更加稳健。如果消费者执行缓慢或失败，那么事件日志可以缓冲讯息（请参阅 “[磁碟空间使用](ch11.md#磁碟空间使用)”），以便生产者和任何其他消费者可以继续不受影响地执行。有问题的消费者可以在问题修复后赶上，因此不会错过任何资料，并且包含故障。相比之下，分散式事务的同步互动往往会将本地故障升级为大规模故障（请参阅 “[分散式事务的限制](ch9.md#分散式事务的限制)”）。
2. 在人力方面，分拆资料系统允许不同的团队独立开发，改进和维护不同的软体元件和服务。专业化使得每个团队都可以专注于做好一件事，并与其他团队的系统以明确的介面互动。事件日志提供了一个足够强大的介面，以捕获相当强的一致性属性（由于永续性和事件的顺序），但也足够普适于几乎任何型别的资料。
#### 分拆系统vs整合系统