本。这样做之后，只需向应用系统传送一个文件句柄，以便其在内
存中建立指向该文件的映射。无论如何，这样做不会影响健壮性、
一致性、安全性以及API约束，整个架构的运转仍然和原来一样。
另一种思路是使用MySQL中针对blob数据流的扩展插件，它承诺可
以在保留通过关系型数据库API能获得的好处，同时实现与裸文件
系统访问相似的性能。
虽然服务器和KDE客户端程序库会随着KDE4.1同时发布，但其目
标仍然是希望能够尽可能地实现并源软件领域的共享。最终，创建
了一个放在Freedesktop.org上的新项目，在开发完成时服务器也就
迁移到了这里。其DBUS接口的命名就已经采用了桌面环境无关的
风格：该服务器唯一依赖的就是Qt程序库的4.0版本，它是Linux
StandardBase（Linux标准基础）规范的一部分，它在Linux、
Windows、OSX及嵌入式系统（包括WindowsCE）中均采用了GNU
GPL版权协议。下一个主要阶段将实现第二个访问程序库，例如用
Python编写，将会引入许多能够引入有价值效果的基础设施，也可
能使用Java语言来编写。
12.4ThreadWeaver
ThreadWeaver现在是KDE4.0中的一个核心程序库。在此谈及它的主
要原因是其起源在很多方面与Akonadi项目形成了鲜明的对照，可以
提供一些有趣的比较。ThreadWeaver是负责并行操作调度的。该项
目的提出时间就是大家觉得基于KDE所使用的程序库（也就是Qt）
在技术上已经能够实现它的时候。看起来有许多并发人员具有这方
面的需求，但只到Qt4.0逐步成熟和逐渐变成主流时才出现。现
在，在Kofice、Kdevelop等主要应用程序中都在使用它。它通常应
用在高伸缩性、高复杂性的软件系统中，在这些系统中对并发性、
带外（out-of-band）处理的需求越来越明显。
ThreadWeaver是一个并发作业调度程序。其目标是在多线程软件系
统中管理和分配资源的使用。其第二个目标是为应用程序开发人员
用的方法类似。这些目标都是高层次的，还有一些第二层次的、规
模更小的目标：避免过强的同步，为协作的数据串行存取提供手
段：充分利用现代C++程序库的功能，如线程安全、隐式共享以及
线程之间的信号/槽连接（signal-slot-connections）等：将处理器元
素和UI中相应展现的委托进行分离，以集成应用程序的图形用户界
1213
---
## Page 1215
面：实现运行时的工作队列节流，以适应当前系统负载；使问题得
以简化；等等。
ThreadWeaver程序库最初是针对那些开发事件驱动的GUI程序的开
发人员而并发的，而后来变得越来越通用。由于GU程序是由一个
核心事件循环驱动的，因此无法在主线程中处理耗时的操作。如果
这样做，那么在操作完成之前将会冻结用户界面。在某些窗口环境
中，用户界面只能通过主线程绘制，或者窗口系统本身就是单线程
的。因此要想实现反应迅速的、跨平台的GUI应用程序，最自然的
方法就是在工作线程中执行所有操作，而在必要时通过主线程更新
用户界面。令人惊讶的是，在用户界面上对并发性的要求远比直观
感觉少得多，虽然在OS/2、WindowsNT和Solaris操作系统都曾经强
调过。多线程编程更加复杂，需要对编写的代码的实际运行过程有
更深入的理解。多线程看起来是软件架构师、设计师已经良好理解
的主题，但对软件维护人员和经验不足的程序员则并不容易理解。
另外，有些并发人员认为对绝大多数操作而言，同步执行已经能够
满足其执行速度需要，即使是那些从已挂载的文件系统中读取信息
之类的操作，它要比CPU中进行处理的操作慢几个数量级。这些误
解只是在特殊的环境下产生的，那时文件系统经常处于休眠状态以
节约电力，但当文件系统位于网络中时一切都发生了改变。
在接下来的几个小节中，我们从基础概念开始，逐渐介绍该程序库
的架构。在本章的末尾，还将说明它是如何找到进入KDE4.0方法
的。
12.4.1ThreadWeaver简介：当其载入一个文件时有多复杂
要说服并发人员使用并发机制，就需要为其提供便利。以下是在
GU程序中执行一个操作的典型例子，将一个文件载入到内存缓冲
区中，然后对其进行处理并显示相应的结果。在命令式程序中，每
个操作步骤都是阻塞型的，其复杂较低：
1.检查文件是否存在、可读。
2.打开该文件读取。
3.将文件内容读取到内存中。
4.对它们进行处理。
1214
---
## Page 1216
5.显示处理结果。
要提高用户友好性，可以在每一步骤之后在命令行中显示一条进度
消息（如果用户选择了verbose模式）。
在GUI程序中，各种操作将以不同形式体现，因为在这些操作步骤
中都需要能够更新屏幕，用户也希望提供一种取消操作的方法。尽
管这听起来有点难以置信，甚至在最近的一些关于GUI工具箱的文
档中还提出“减少事件检查"的方法。其观点是在执行上述步骤时周
期性地检查事件，以完成必要的更新或取消操作。在这种场景下需
要十分仔细，因为应用程序状态可能会出现意外的改变。例如，用
户可能决定关闭程序，而不会注意到程序正在操作的调用栈中检查
某个事件。简单来说，这种轮询方法从来没有良好地运行过，而且
也是超常规的做法。
当然更好的方法是使用线程。但如何没有可用的框架来支持，通常
会产生不可思议的实现。由于GUI程序是基于事件的，每一步骤都
是由事件列出的，并且会有一个事件来说明该步骤已经完成。在
C++中，通常会使用信号作为通知机制。有些程序会采用以下方
法：
1.用户发出载入某文件的请求，它将通过一个信号或事件来触发一
个处理者方法。
2.此时将执行打开并载入文件的操作，然后会链接上一个通知操作
已完成的方法。
3.在这个方法中将开始对数据进行处理，并链接上第三个方法。
4.这最后一个方法将完成结果的显示工作。
这组层级式的句柄方法无法很好地跟踪操作的状态，并且通常会有
错误的倾向。这同时也暴露了将操作和视图分离的缺点。不过，在
许多GUI应用程序中仍然经常看到它的身影。这种情况就是
ThreadWeaver能够发挥作用的地方。使用了作业机制之后，其实现
将采用如下所示的步骤：
1.用户发出载入某文件的请求，它将通过一个信号或事件来触发一
个处理者方法。
1215
---
## Page 1217
2.在这个句柄方法中，用户将创建一个作业序列（该序列是一个作
业容器，它将根据添加作业的顺序来执行各个作业）。他将添加一
个载入文件的作业，以及一个处理文件内容的作业。序列对象本身
也是一个作业，当其包含的作业完成时将会发出一个信号。直到此
时，还没有并始执行任何操作；程序员只声明了需要按顺序执行哪
些作业。当整个序列设置完成时，用户将其放到应用程序的全局作
业队列（一个惰性初始化的单例对象）中。这时将通过工作线程自
动执行整个序列。
3.当收到序列发出的done（）信号时，就表示数据做好了显示的准
备。
这里揭示了两个方面的信息。首先，我们将一次性地声明所有要执
行的每个步骤，然后再执行它。这将大大减轻GUI程序员的工作
方法来执行。同步模式所带来的主要问题将在很大程度上被解决，
而这是通常一个简单的约定实现的，那就是只有当队列化的线程准
备好之后才会接触作业数据。由于工作线程都将访问作业数据，因
此对数据的访问将是事行的，不过是以合作模式的。如果程序员想
向用户展示进度信息，通过该序列在每个作业完成时产生的信号就
可以解决（信号在Qt中可以跨线程发送）。执行过程中GUI仍然可
以响应用户的其他操作，能够将作业从队列中删除，也可以取消所
有操作。
由于采用这种方法实现I/O操作十分简单，因此程序员很快就采用了
ThreadWeaver。它以一种很漂亮、便利的方法解决了这个问题。
12.4.2核心概念与功能
在前一个示例中，我们提及了作业序列。接下来，我们来看看该程
序库中提供的其他构造。序列是作业集合的一种特定形式。作业集
合是一个容器，其中排队了一组由原子性操作构成的作业，对于程
序而言它们是一个整体。作业集合是复合体，也就是它本身也可以
实现为一个作业类。在ThreadWeaver中只实现了一个队列操作，也
就是获取某个作业的指针。复合的作业有助于使队列AP最小化。
作业队列将可以确保其包含的作业以正确的顺序执行。如果声明两
个作业之间有依赖关系，那么就意味着依赖作业只能在被依赖作业
执行完成后才能执行。由于我们可以用m：n格式来声明依赖性，在
1216
---
## Page 1218
这种声明格式中，可以建模相当多针对依赖操作所预期的控制流
（它们都是有向图，无法定义作业循环）。只要执行路线是有向
的，那么就可以完成作业甚至是作业队列的执行。呈现一个Web页
面就是一个典型的实例，在处理HTML文档本身时，锚元素只会被
识别一次。然后为获取和准备每个链接元素添加一个作业，而负责
显示的最后一个作业将取决于这些准备性作业。此外，在此无需互
厅机制。
这种依赖关系和诸如ThreadWeaver之类的调度系统相比，其区别在
于它只是并行处理的一个工具而已。它有效地减轻了程序员关于如
何最好地将每个子操作分配到线程中的压力。即使是采用如Future
模式！之类的现代概念，程序员仍然需要决定操作执行的顺序。基
于ThreadWeaver，工作线程会尽快地执行所有可能的作业，其中并
不存在未确定的依赖关系。由于并发流的执行具有天生的不确定
性，因此通过手动定义执行顺序，其灵活性是不可能很高的。在此
可以应用更好的调度程序，计算机科学通常倾向于避免这一方式，
而在经济学领域却经常使用随机系统分析来支持它。
你也可以通过优先级来控制执行顺序。它使用的优先级系统十分简
单：队列中的每个作业都指定了一个整型的优先级，工作线程会首
先执行优先级最高的那个。由于作业基类的实现应用了装饰器模式
的，因此修改作业的优先级可以通过编写一个装饰器类来实现，这
样既修改了其优先级文不用触及作业的实现。优先级和依赖关系的
组合使用会产生有趣的结果，这在稍后就会提及。
ThreadWeaver并不直接依赖于队列行为的实现，而是使用了队列策
略。当在执行一个特定的作业时，队列策略不会马上对其产生影
响。相反，它影响的是作业的执行顺序，决定了工作线程会从队列
中取出哪个作业。ThreadWeaver提供了两个标准实现。第一个就是
前面提及的依赖关系。另一个就是资源约束。通过资源约束，可以
声明所有已创建的作业中的某个特定的子集（例如，并销很大的本
地文件系统I/O操作）在某一时间段内，只能执行一个特定的总量。
没有这样的工具，很容易出现某些子系统出现过载现象。资源限制
扮演的角色与传统线程机制中的信号机制类似，只不过它不会阻塞
正在调用的线程，而只是简单地让某个作业不能执行。线程将检查
某个作业是否可以执行，如果不行将会尝试执行另一个作业。
队列机制是为作业指定的，相同的策略对象可以指定给多个作业。
同样，它们也是复合的，每个作业可能受限于多个可用策略的组
1217
---
## Page 1219
合。从特定的策略驱动的作业基类中继承无法提供这样的灵活性。
同样，采用这种方法的作业对象无需任何额外的策略，而且无法通
过策略来影响其性能。
[L].Future在金融行业叫期权，市场上有看跌期权和看涨期权，你可
以在现在（比如9月）购买年底（12月）的石油，假如你买的是看
涨期权，那么如果石油真的涨了，你也可以在12月依照9月商定的
价格购买。Future就是你可以获得未来的结果。对于多线程，如果
线程A要等待线程B的结果，那么线程A没必要等待B，直到B有结
果，可以先拿到一个未来的Future，等B有结果时再取真实的结果。
其实这个模式用得很多，比如浏览器下载图片的时候，刚并始通过
模糊的图片来代替最后的图片，等下载图片的线程下载完图片后再