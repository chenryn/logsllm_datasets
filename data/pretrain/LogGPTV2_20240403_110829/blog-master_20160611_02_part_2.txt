postgres=#   
select *,  
  case when rn=1 or (pos_distance>100 and ts_distance>interval '20 sec') then 'split' else '' end   
from v1 limit 100;  
 id |   pos_e   |            ts_e            | rn  |   pos_distance   | ts_distance | case    
----+-----------+----------------------------+-----+------------------+-------------+-------  
  0 | (571,395) | 2016-06-10 23:50:21.433406 |   1 |                0 | 00:00:00    | split  
  0 | (548,943) | 2016-06-10 23:50:37.433406 |   2 | 548.482451861498 | 00:00:16    |   
  0 | (638,497) | 2016-06-10 23:50:57.433406 |   3 | 454.990109782619 | 00:00:20    |   
  0 | (5,214)   | 2016-06-10 23:50:57.433406 |   4 | 693.381568834938 | 00:00:00    |   
  0 | (355,720) | 2016-06-10 23:51:00.433406 |   5 | 615.252793573503 | 00:00:03    |   
  0 | (472,670) | 2016-06-10 23:51:10.433406 |   6 |  127.23600119463 | 00:00:10    |   
  0 | (930,952) | 2016-06-10 23:51:29.433406 |   7 | 537.854999047141 | 00:00:19    |   
  0 | (893,145) | 2016-06-10 23:51:31.433406 |   8 | 807.847757934625 | 00:00:02    |   
  0 | (700,91)  | 2016-06-10 23:51:45.433406 |   9 | 200.412075484488 | 00:00:14    |   
  0 | (465,697) | 2016-06-10 23:51:52.433406 |  10 |  649.96999930766 | 00:00:07    |   
  0 | (890,202) | 2016-06-10 23:51:58.433406 |  11 | 652.418577295282 | 00:00:06    |   
  0 | (271,425) | 2016-06-10 23:52:22.433406 |  12 | 657.943766594076 | 00:00:24    | split  
  0 | (771,898) | 2016-06-10 23:52:27.433406 |  13 | 688.279739640795 | 00:00:05    |   
  0 | (392,348) | 2016-06-10 23:52:28.433406 |  14 |   667.9378713623 | 00:00:01    |   
  0 | (705,388) | 2016-06-10 23:52:30.433406 |  15 | 315.545559309587 | 00:00:02    |   
  0 | (393,176) | 2016-06-10 23:52:39.433406 |  16 | 377.210816387866 | 00:00:09    |   
  0 | (134,690) | 2016-06-10 23:52:39.433406 |  17 | 575.566677284222 | 00:00:00    |   
  0 | (232,108) | 2016-06-10 23:52:42.433406 |  18 | 590.193188710273 | 00:00:03    |   
  0 | (106,401) | 2016-06-10 23:53:05.433406 |  19 | 318.943568676341 | 00:00:23    | split  
  0 | (217,665) | 2016-06-10 23:53:19.433406 |  20 | 286.386103014794 | 00:00:14    |   
  0 | (348,467) | 2016-06-10 23:53:41.433406 |  21 | 237.413142011979 | 00:00:22    | split  
  0 | (424,654) | 2016-06-10 23:53:50.433406 |  22 | 201.853907566834 | 00:00:09    |   
  0 | (389,515) | 2016-06-10 23:54:06.433406 |  23 |  143.33875958721 | 00:00:16    |   
  0 | (238,834) | 2016-06-10 23:54:06.433406 |  24 | 352.933421483429 | 00:00:00    |   
  0 | (219,85)  | 2016-06-10 23:54:17.433406 |  25 |  749.24094922795 | 00:00:11    |   
  0 | (4,561)   | 2016-06-10 23:54:25.433406 |  26 | 522.303551586623 | 00:00:08    |   
  0 | (815,512) | 2016-06-10 23:54:39.433406 |  27 |  812.47892280354 | 00:00:14    |   
  0 | (756,592) | 2016-06-10 23:54:41.433406 |  28 | 99.4032192637643 | 00:00:02    |   
  0 | (820,732) | 2016-06-10 23:54:58.433406 |  29 | 153.935051239151 | 00:00:17    |   
  0 | (439,749) | 2016-06-10 23:55:04.433406 |  30 | 381.379076510498 | 00:00:06    |   
  0 | (260,64)  | 2016-06-10 23:55:07.433406 |  31 |  708.00141242797 | 00:00:03    |   
  0 | (386,535) | 2016-06-10 23:55:18.433406 |  32 | 487.562303711023 | 00:00:11    |   
  0 | (414,226) | 2016-06-10 23:55:32.433406 |  33 | 310.266014896895 | 00:00:14    |   
  0 | (425,533) | 2016-06-10 23:55:56.433406 |  34 | 307.197005193736 | 00:00:24    | split  
  0 | (970,845) | 2016-06-10 23:55:58.433406 |  35 | 627.988057211282 | 00:00:02    |   
```  
写成函数，处理轨迹的合并和切分。  
每条轨迹以数组的形式返回。  
(如果你要返回带有经纬度和时间属性的GIS类型轨迹，改一下这个函数内容即可)。  
```  
create or replace function path_agg(  
  i_pos_distance int,  --  距离  
  i_ts_distance interval  -- 时间差  
) returns setof test[] as   
$$  
declare  
  tmp_id int;  
  i_id int;  
  i_pos point;  
  i_ts timestamp;  
  i_split boolean;  
  res test[];  
begin  
  for i_id,i_pos,i_ts,i_split in select id, pos_e, ts_e, case when (pos_distance > i_pos_distance and ts_distance > i_ts_distance) or rn=1 then true else false end from v1 LOOP  
    if tmp_id is null or res is null then  
      -- 第一行, 生成初始 res  
      res := array[(i_id, i_pos, i_ts)::test];  
    elsif tmp_id <> i_id then  
      -- 换ID, 输出next, 生成初始res  
      return next res;  
      res := array[(i_id, i_pos, i_ts)::test];  
    elsif i_split then  
      -- 切分, 输出next, 生成初始res  
      return next res;  
      res := array[(i_id, i_pos, i_ts)::test];  
    else  
      -- 合并  
      res := array_append(res, (i_id, i_pos, i_ts)::test);  
    end if;  
    tmp_id := i_id;  
  end loop;  
    -- 输出最后一个res  
    return next res;  
    -- 返回  
    return;  
end;  
$$  
 language plpgsql strict;  
```  
验证  
```  
postgres=# select * from path_agg(100, interval '20 second');  
 {"(0,\"(571,395)\",\"2016-06-10 23:50:21.433406\")","(0,\"(548,943)\",\"2016-06-10 23:50:37.433406\")","(0,\"(638,497)\",\"2016-06-10 23:50:57.433406\")","(0,\"(5,214)\",\"2016-06-10 23:50:57.433406\")","(0,\"(355,720)\",\"2016-06-10 23  
:51:00.433406\")","(0,\"(472,670)\",\"2016-06-10 23:51:10.433406\")","(0,\"(930,952)\",\"2016-06-10 23:51:29.433406\")","(0,\"(893,145)\",\"2016-06-10 23:51:31.433406\")","(0,\"(700,91)\",\"2016-06-10 23:51:45.433406\")","(0,\"(465,697)\  
",\"2016-06-10 23:51:52.433406\")","(0,\"(890,202)\",\"2016-06-10 23:51:58.433406\")"}  
 {"(0,\"(271,425)\",\"2016-06-10 23:52:22.433406\")","(0,\"(771,898)\",\"2016-06-10 23:52:27.433406\")","(0,\"(392,348)\",\"2016-06-10 23:52:28.433406\")","(0,\"(705,388)\",\"2016-06-10 23:52:30.433406\")","(0,\"(393,176)\",\"2016-06-10   
23:52:39.433406\")","(0,\"(134,690)\",\"2016-06-10 23:52:39.433406\")","(0,\"(232,108)\",\"2016-06-10 23:52:42.433406\")"}  
 {"(0,\"(106,401)\",\"2016-06-10 23:53:05.433406\")","(0,\"(217,665)\",\"2016-06-10 23:53:19.433406\")"}  
......  
```  
## 小结  
本文主要用到了PostgreSQL的几个功能特性。  
地理位置信息管理，窗口函数，plpgsql函数语言，复合类型，数组类型，返回多行的函数。  
#### [PostgreSQL 许愿链接](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216")
您的愿望将传达给PG kernel hacker、数据库厂商等, 帮助提高数据库产品质量和功能, 说不定下一个PG版本就有您提出的功能点. 针对非常好的提议，奖励限量版PG文化衫、纪念品、贴纸、PG热门书籍等，奖品丰富，快来许愿。[开不开森](https://github.com/digoal/blog/issues/76 "269ac3d1c492e938c0191101c7238216").  
#### [9.9元购买3个月阿里云RDS PostgreSQL实例](https://www.aliyun.com/database/postgresqlactivity "57258f76c37864c6e6d23383d05714ea")
#### [PostgreSQL 解决方案集合](https://yq.aliyun.com/topic/118 "40cff096e9ed7122c512b35d8561d9c8")
#### [德哥 / digoal's github - 公益是一辈子的事.](https://github.com/digoal/blog/blob/master/README.md "22709685feb7cab07d30f30387f0a9ae")
![digoal's wechat](../pic/digoal_weixin.jpg "f7ad92eeba24523fd47a6e1a0e691b59")
#### [PolarDB 学习图谱: 训练营、培训认证、在线互动实验、解决方案、生态合作、写心得拿奖品](https://www.aliyun.com/database/openpolardb/activity "8642f60e04ed0c814bf9cb9677976bd4")
#### [购买PolarDB云服务折扣活动进行中, 55元起](https://www.aliyun.com/activity/new/polardb-yunparter?userCode=bsb3t4al "e0495c413bedacabb75ff1e880be465a")
#### [About 德哥](https://github.com/digoal/blog/blob/master/me/readme.md "a37735981e7704886ffd590565582dd0")