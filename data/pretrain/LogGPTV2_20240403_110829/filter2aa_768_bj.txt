鸣叫 8 声 
显卡不存在，或者显卡上的显存失败 
鸣叫 9 声 
固件存储器中内容的校验和与固件中记录的不一样 
鸣叫 10 声 
读写 CMOS 中的数据失败或者其内容有误 
鸣叫 11 声 
高速缓存失败 
通常，在固件厂商的网站或者产品手册中可以查找到蜂鸣代码的含义。例如通过以下
链 接 可 以 访 问 到 英 特 尔 主 板 / 固 件 的 蜂 鸣 代 码 含 义 ： http://www.intel.com/support/ 
motherboards/desktop/sb/cs-010249.htm 
在以下网页中列出了其它几种常见固件的蜂鸣代码定义：http://www.computerhope. 
com/beep.htm  
关于 PC 喇叭，还有两点需要说明。第一点是，有些固件在正常完成基本的启动动作
后会鸣叫一声，这并不是报告错误，而是报告好消息。第二点是台式机的 PC 喇叭通常是
不受静音控制的，而笔记本电脑的 PC 喇叭是受静音控制的，因此在诊断笔记本电脑时应
该调整音量按钮取消静音，这样才可能听到蜂鸣代码。 
《软件调试》补编 
- 149 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
下面再谈一下闻的另一种含义——“嗅”，也就是闻味道。当出现显示器无法点亮这
样的故障时，确实可能是某些硬件损坏了，比如电容被击穿和短路等。因此在每次开机和
调试时，不妨用鼻子闻一闻，如果闻到烧焦味道，那么应该立刻切断电源；如果有其它事
情需要离开，那么也该先给系统断电。 
问
问
问
问——
——
——
——黑暗中交谈
黑暗中交谈
黑暗中交谈
黑暗中交谈 
在显示器被点亮前，系统通常还不能接收键盘和鼠标输入，这时该如何询问它呢？一
种简单的方法是改变系统的配置或者调换系统的部件，然后通过聆听蜂鸣代码或者观察它
的其它反应来感知计算机的“回答”，以便收集更多的信息。举例来说，有一个故障系统，
按下电源后很久，显示器仍不亮，也听不到任何蜂鸣声音。这时，可以先切断电源，拔下
所有内存条，然后再上电开机，如果听到三声鸣叫，那么便说明系统已经执行到内存检查
部分，这可以初步证明 CPU 是正常的，系统的主板也是可以工作的。 
切
切
切
切——
——
——
——接收自举码
接收自举码
接收自举码
接收自举码 
中医中的切是指把脉，也就是通过感受患者的脉搏来了解健康状况。那么如何能感受
计算机系统的脉搏并从中提取出它的生命信息呢？PC 系统的开拓者们真的设计出了一种
方法。简单来说，就是将一种名为“上电自检卡（POST Card）”的标准 PC 卡插到系统的
扩展槽中，让这块卡“切”入到目标系统中来监听系统总线上的活动，接收上面的数据。
上电自检卡通常是 PCI 接口的，也有 ISA 接口的。图 4 中的照片便是一个 PCI 接口的上
电自检卡。 
图 4  PCI 接口的上电自检卡 
为了支持调试，POST 程序在执行的过程中，会将代表一定含义的 POST 代码发送到
0x80 端口。系统硬件会将发送到这个端口的数据发送到 PCI 总线上，于是上电自检卡便
可以从总线上读取到 POST 代码，然后显示出来。POST 程序会使用不同的 POST 代码代
表不同的含义，有些代表错误号，有些代表进展到了哪个阶段。通常可以在产品的技术文
档中查找到 POST 代码的含义，然后根据这个含义来了解故障的原因。 
《软件调试》补编 
- 150 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
透视和跟踪
透视和跟踪
透视和跟踪
透视和跟踪 
使用上面介绍的四类方法，通常可以定位出导致故障的部件或者粗略的原因，对于普
通的测试或者维修目的，做到这一步也就可以满足要求了。那么对于需要修正故障或者想
深入研究的开发人员该如何进一步分析出精确的故障位置呢？如果是软件错误，那么能不
能分析出是哪段程序或者哪条指令出错了呢？ 
要做到这一点，比较有效的方法是使用调试器。因为这个时候系统还在初始化阶段，
纯软件的调试器还不能工作，所以这时需要硬件调试器，也就是《软件调试》第 7 章介绍
的基于 JTAG 技术的 ITP/XDP 调试器或者同类的硬件工具。 
使用硬件调试器可以单步跟踪执行 POST 程序；可以设置断点，包括代码断点（执行
到指定地址的代码时中断）、内存访问断点（访问指定的内存地址时中断）和 IO 访问断点
（访问指定的 IO 地址时中断）；也可以在发生重要事件时中断下来，比如进入或者退出系
统管理模式（SMM）时中断、进入或者退出低功耗状态时中断、或者系统复位后立刻中
断等。举例来说，在将系统复位事件的处理方式设置为中断（break）并重启系统后，CPU
复位后一开始执行便会中断到调试器中。观察此时的寄存器值（图 5），代码段寄存器
cs=f000，程序指针寄存器 eip=0000fff0。因为这时 CPU 工作在实模式下，所以目前要执行
代码的物理地址是 0xf000 x 16 + 0xfff0 = 0xffff0，这正是 PC 标准中定义的 CPU 复位后开
始执行的程序地址，PC 系统的硬件保证这个地址会指向位于主板上的 POST 程序。因此
可以毫不夸张的说，以这种方式中断到调试器中可以得到“最早的”调试机会，从 CPU
复位后执行的第一条指令开始跟踪调试。 
图 5 CPU 复位后的寄存器值 
接下来，使用断点功能对端口 0x80 设置一个 IO 断点，然后恢复 CPU 执行： 
[P0]>go 
结果，这个断点很快便命中了，调试器显示： 
[ Debug Register break at 0x0010:00000000fffffeca in task 00000 ] 
[[P1] BreakAll break at 0xf000:0000000000000000 ] 
因为系统中的 CPU 是双核的，所以第 1 行显示的是 0 号 CPU（P0）的中断位置，第
2 行显示的是 1 号 CPU 的中断位置，其程序指针寄存器的值为 0，还没有开始工作。使用
反汇编指令可以观察断点附近的指令： 
[P0]>asm $-2 length 10 
0x0010:00000000fffffec8   e680         out 0x80, al 
0x0010:00000000fffffeca   e971f9ffff   jmp $-0x0000068a  ;a=fffff840 
《软件调试》补编 
- 151 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
0x0010:00000000fffffecf   680000e4ff   push 0xffe40000 
0x0010:00000000fffffed4   68c4faffff   push 0xfffffac4 
… 
可见，中断前执行的正是向 0x80 号端口输出的指令。观察一下 al 寄存器，它的值为
1，看一下上电自检卡上显示的数字也是 1，正好吻合。 
归纳
归纳
归纳
归纳 
今天，我们介绍了一种比较特殊的调试任务。之所以介绍这个内容，除了让大家了解
上面介绍的调试方法外，还有两个目的。一是学习 PC 系统的设计者们以不同方式支持调
试的聪明才智和重视调试的职业精神，他们在打印信息或者显示文字等方法不可行的情况
下，设计出了蜂鸣代码和 POST 代码这样的调试机制，这些机制看似简陋，但是却可以传
递出来自系统第一线的直接信息，实践证明这些信息可以大大提高调试的效率。二是希望
能提高大家对计算机硬件和整个系统的兴趣，程序员的主要目标是编写软件，但是对硬件
和系统的深刻理解对于程序员的长远发展是有非常有意义的。 
下一期的问题： 
一台安装 Windows 的计算机系统开机后显示因为系统文件丢失而无法进入系统，对
于这样的问题有哪些方法来调试和解决？ 
《软件调试》补编 
- 152 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
权利移交——如何调试引导过程中的故
障 
上一期我们讨论了如何调试显示器点亮前的故障，在文章中我们提到，CPU 复位
（Reset）后，首先执行的是固化在主板上的 POST 程序（图 1）。POST 程序的核心任务是
检测系统中的硬件设备，并对它们做基本的检查和初始化，并根据需要给它们分配系统资
源（中断、内存和 IO 空间等）。POST 程序成功执行后，系统接下来要做的一个重要任务
便是寻找和加载操作系统（OS）。对于不同的计算机系统和不同的使用需求，需要加载的
操作系统可能位于不同的地点。最常见的情况是操作系统位于硬盘（Hard Disk）上，但是
也可能位于光盘、优盘、软盘或者网络上。 
图 1 计算机的启动过程 
通常把寻找和加载操作系统的过程叫做引导（Boot 或者 Bootstrap），也就是图一中的
黄色方框。本期我们就谈谈引导有关的问题，介绍如何分析和调试的这个过程中可能发生
的故障。 
BBS——
——
——
——BIOS 引导规约
引导规约
引导规约
引导规约 
考虑到引导过程涉及到来自不同厂商生产的不同部件之间的协作，因此需要一个标准
来定义每个部件的职责和各个部件之间交互的的方法，在这种背景下，英特尔、Phoenix
和康柏公司在 1996 年联合发布了 BIOS 引导规约（BIOS Boot Specification），简称 BBS（图
2）。尽管十几年已经过去了，但是这个规约中的大多数内容至今仍被使用着。本文中使用
的很多术语和数据结构都来自这个规约。在互联网上搜索 BIOS Boot Specification，可以
下载到 BSS 的电子版本。 
《软件调试》补编 
- 153 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 2 BIOS 引导规约 
IPL 表格
表格
表格
表格 
BBS 把系统中可以引导和加载 OS 的设备成为初始程序加载设备（Initial Program Load 
Device），简称 IPL 设备。BIOS 会在内存中维护一个 IPL 表格，每一行（表项）描述一个
IPL 设备。表 1 列出了 IPL 表的各个列（表项的字段）的用途和详细情况。 
表 1  IPL 表项的各个字段 
名称 
偏移 
长度（字节） 
描述 
deviceType 
00h 
2 
设备标号，参见下文 
statusFlags 
02h 
2 
状态标志 
bootHandler 
04h 
4 
发起引导的代码的地址 
descString 
08h 
4 
指向一个以零结束的 ASC 字符串 
expansion 
0ch 
4 
保留，等于 0 
其中的 deviceType 字段用来记录代表引导设备编号的数字，01h 代表软盘，02h 代表
硬盘，03h 代表光盘，04h 代表 PCMCIA 设备，05h 代表 USB 设备，06h 代表网络，07h..7fh
和 81..feh 保留，80h 代表以 BEV 方式启动的设备（我们稍后详细讨论）。接下来的 statusFlags
字段用来记录它所描述的引导设备的状态信息，使用不同的二进制位代表不同的状态，图
2 画出了各个位域，Old Position 位域（bit 3..0）代表上次引导时这个表项在 IPL 表中的索
引，Enabled 位域（位 8）用来启用（1）或禁止（0）这个表项，Failed 位域（位 9）为 1
代表已经尝试过使用该表项而且得到了失败的结果，Media Present 位域（位 11..10）的典
型用途是描述驱动器是否有可引导的媒介（光盘、磁盘），0 代表没有，1 代表未知，2 代
表有媒介，而且看起来可以引导。 
图 3 IPL 表的状态标志字段（statusFlag）的位定义  
《软件调试》补编 
- 154 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
从编程的角度来看，可以使用下面的数据结构来描述 IPL 表的表项： 
struct ipl_entry { 
  Bit16u deviceType; 
  Bit16u statusFlags; 
  Bit32u bootHandler; 
  Bit32u descString; 
  Bit32u expansion; 
}; 
在 EFI（Extensible Firmware Interface）中，使用 BBS_TABLE 结构来描述 IPL 设备，
希望了解其具体定义的读者可以到 http://www.uefi.org/下载详细文档。 
引导设备分类
引导设备分类
引导设备分类
引导设备分类 
BBS 将引导设备划分为以下三种类型： 
BAID – 即 BIOS 知道的 IPL 设备（BIOS Aware IPL Device），也就是说 BIOS 中已经
为这样的设备准备了支持引导的代码。第一个软驱、第一个硬盘、ATAPI 接口的光驱
等都属于这一类型。 
传统设备 – 是指带有 Option ROM（见下文）但没有 PnP 扩展头的标准 ISA 设备。例
如已经过时的通过 ISA 卡连接到系统中的 SCSI 硬盘控制器。 
PnP 设备 – 是指符合 PnP BIOS 规约（Plug and Play BIOS Specification）的即插即用
设备。 
因为第二类设备已经很少见，所以我们重点介绍一下从另两类设备引导的方法。 
从即插即用
从即插即用
从即插即用
从即插即用（
（
（
（PnP）
）
）
）设备引导
设备引导
设备引导