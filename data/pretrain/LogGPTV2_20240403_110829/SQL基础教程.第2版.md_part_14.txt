通过排序处理来实现的。 但其实这个问题本身就是本末倒置的，我们应该考虑的是该SELECT语句是否
满足需求。选择的标准其实非常简单，在“想要删除选择结果中的重复记录”时
使用DISTINCT，在“想要计算汇总结果”时使用GROUP BY。
不使用COUNT等聚合函数，而只使用GROUP BY子句的SELECT语句，会让人
觉得非常奇怪，使人产生“到底为什么要对表进行分组呢？这样做有必要吗？”等
疑问。
SQL语句的语法与英语十分相似，理解起来非常容易，如果大家浪费了这一
优势，编写出一些难以理解的SQL语句，那就太可惜了。
3-3 为聚合结果指定条件 101 ●
第3章 聚合与排序
3-3
为聚合结果指定条件
● 使用COUNT函数等对表中数据进行汇总操作时，为其指定条件的不是
学习重点
WHERE子句，而是HAVING子句。
● 聚合函数可以在SELECT子句、HAVING子句和ORDER BY子句中使用。
● HAVING子句要写在GROUP BY子句之后。
● WHERE子句用来指定数据行的条件，HAVING子句用来指定分组的条件。
子句
HAVING
使用前一节学过的GROUP BY子句，可以得到将表分组后的结果。
在此，我们来思考一下通过指定条件来选取特定组的方法。例如，如何才
能取出“聚合结果正好为2行的组”呢（图3-8） ？
图3-8 取出符合指定条件的组
[厨房用具]组
菜刀
高压锅
叉子
擦菜板
[办公用品]组 [衣服]组
打孔器 T恤衫
圆珠笔 运动T恤
只想取出这两个组
说到指定条件，估计大家都会首先想到WHERE子句。但是，WHERE
子句只能指定记录（行）的条件，而不能用来指定组的条件（例如，“数
据行数为2行”或者“平均值为500”等）。
● 102 第3章 聚合与排序
因此，对集合指定条件就需要使用其他的子句了，此时便可以用
KEYWORD HAVING子句A。
●HAVING子句
HAVING子句的语法如下所示。
注A
语法3-3 HAVING子句
HAVING是HAVE（拥有）的现在分
词，并不是通常使用的英语单词。
SELECT , , , ……
FROM 
GROUP BY , , , ……
HAVING 
HAVING子句必须写在GROUP BY子句之后，其在DBMS内部的
执行顺序也排在GROUP BY子句之后。
使用HAVING子句时SELECT语句的顺序 ▲
SELECT → FROM → WHERE → GROUP BY → HAVING
法则3-13
HAVING子句要写在GROUP BY子句之后。
接下来就让我们练习一下HAVING子句吧。例如，针对按照商品种
类进行分组后的结果，指定“包含的数据行数为2行”这一条件的
SELECT语句，请参见代码清单3-20。
代码清单3-20 从 按照商品种类进行分组后的结果中，取出“包含的数据行数为2
行”的组
SELECT product_type, COUNT(*)
FROM Product
GROUP BY product_type
HAVING COUNT(*) = 2;
执行结果
product_type | count
--------------+------
衣服 | 2
办公用品 | 2
我们可以看到执行结果中并没有包含数据行数为4行的“ 厨房用具”。
未使用HAVING子句时的执行结果中包含“厨房用具”，但是通过设置
3-3 为聚合结果指定条件 103 ●
HAVING子句的条件，就可以选取出只包含2行数据的组了（代码清单
3-21）。
代码清单3-21 不使用HAVING子句的情况
SELECT product_type, COUNT(*)
FROM Product
GROUP BY product_type;
执行结果
product_type | count
---------------+------
衣服 | 2
办公用品 | 2
厨房用具 | 4 行数不是2的组也显示出来了
下面我们再来看一个使用HAVING子句的例子。这次我们还是按照
商品种类对表进行分组，但是条件变成了“销售单价的平均值大于等于
2500日元”。
首先来看一下不使用HAVING子句的情况，请参见代码清单3-22。
代码清单3-22 不使用HAVING子句的情况
SELECT product_type, AVG(sale_price)
FROM Product
GROUP BY product_type;
执行结果
product_type | avg
--------------+----------------------
衣服 | 2500.0000000000000000
办公用品 | 300.0000000000000000
厨房用具 | 2795.0000000000000000
按照商品种类进行切分的3组数据都显示出来了。下面我们使用
HAVING子句来设定条件，请参见代码清单3-23。
代码清单3-23 使用HAVING子句设定条件的情况
SELECT product_type, AVG(sale_price)
FROM Product
GROUP BY product_type
HAVING AVG(sale_price) >= 2500;
● 104 第3章 聚合与排序
执行结果
product_type | avg
--------------+----------------------
衣服 |2 500.0000000000000000
厨房用具 |2 795.0000000000000000
销售单价的平均值为300日元的“办公用品”在结果中消失了。
子句的构成要素
HAVING
HAVING子句和包含GROUP BY子句时的SELECT子句一样，能
够使用的要素有一定的限制，限制内容也是完全相同的。HAVING子句中
能够使用的3种要素如下所示。
● 常数
● 聚合函数
● GROUP BY子句中指定的列名（即聚合键）
代码清单3-20中的例文指定了HAVING COUNT（ *）= 2这样的条
件，其中COUNT（*）是聚合函数，2是常数，全都满足上述要求。反之，
如果写成了下面这个样子就会发生错误（代码清单3-24）。
代码清单3-24 HAVING子句的不正确使用方法
SELECT product_type, COUNT(*)
FROM Product
GROUP BY product_type
HAVING product_name = '圆珠笔';
执行结果
ERROR: 列"product,product_name"必须包含在GROUP BY子句当中，或者必须在 
聚合函数中使用
行 4: HAVING product_name = '圆珠笔';
表示下一行接续本行，只是由于版面所限而换行。
product_name列并不包含在GROUP BY子句之中，因此不允许
写在HAVING子句里。在思考HAVING子句的使用方法时，把一次汇
总后的结果（类似表3-2的表）作为HAVING子句起始点的话更容易理解。
3-3 为聚合结果指定条件 105 ●
表3-2 按照商品种类分组后的结果
product_type COUNT(*)
厨房用具 4
衣服 2
办公用品 2
可以把这种情况想象为使用GROUP BY子句时的SELECT子句。
汇总之后得到的表中并不存在product_name这个列，SQL当然无
法为表中不存在的列设定条件了。
相对于 子句，
HAVING
更适合写在 子句中的条件
WHERE
也许有的读者已经发现了，有些条件既可以写在HAVING子句当中，
又可以写在WHERE子句当中。这些条件就是聚合键所对应的条件。原表
中作为聚合键的列也可以在HAVING子句中使用。因此，代码清单3-25
中的SELECT语句也是正确的。
代码清单3-25 将条件书写在HAVING子句中的情况
SELECT product_type, COUNT(*)
FROM Product
GROUP BY product_type
HAVING product_type = '衣服';
执行结果
product_type | count
--------------+------
衣服 | 2
上述SELECT语句的返回结果与代码清单3-26中SELECT语句的
返回结果是相同的。
代码清单3-26 将条件书写在WHERE子句中的情况
SELECT product_type, COUNT(*)
FROM Product
WHERE product_type = '衣服'
GROUP BY product_type;
● 106 第3章 聚合与排序
执行结果
product_type | count
--------------+------
衣服 | 2
虽然条件分别写在WHERE子句和HAVING子句当中，但是条件的
内容以及返回的结果都完全相同。因此，大家可能会觉得两种书写方式都
没问题。
如果仅从结果来看的话，确实如此。但笔者却认为，聚合键所对应的
条件还是应该书写在WHERE子句之中。
理由有两个。
首先，根本原因是WHERE子句和HAVING子句的作用不同。如前
所述，HAVING子句是用来指定“组”的条件的。因此，“行”所对应的
条件还是应该写在WHERE子句当中。这样一来，书写出的SELECT语
句不但可以分清两者各自的功能，理解起来也更加容易。
WHERE子句 = 指定行所对应的条件
HAVING子句 = 指定组所对应的条件
其次，对初学者来说，研究DBMS的内部实现这一话题有些深奥，
这里就不做介绍了，感兴趣的读者可以参考随后的专栏——WHERE子句
和HAVING子句的执行速度。
法则3-14
聚合键所对应的条件不应该书写在HAVING子句当中，而应该书写在WHERE子句
当中。
3-3 为聚合结果指定条件 107 ●
专 栏
子句和 子句的执行速度
WHERE HAVING
在WHERE子句和HAVING子句中都可以使用的条件，最好写在WHERE子
句中的另一个理由与性能即执行速度有关系。由于性能不在本书介绍的范围之内，
因此暂不进行说明。通常情况下，为了得到相同的结果，将条件写在WHERE子句
中要比写在HAVING子句中的处理速度更快，返回结果所需的时间更短。
为了理解其中原因，就要从DBMS的内部运行机制来考虑。使用COUNT函
数等对表中的数据进行聚合操作时，DBMS内部就会进行排序处理。排序处理是
注A 会大大增加机器负担的高负荷的处理A。因此，只有尽可能减少排序的行数，才能
虽然Oracle等数据库会使用散列 提高处理速度。
（hash）处理来代替排序，但那同样 通过WHERE子句指定条件时，由于排序之前就对数据进行了过滤，因此能够
也是加重机器负担的处理。
减少排序的数据量。但HAVING子句是在排序之后才对数据进行分组的，因此与
在WHERE子句中指定条件比起来，需要排序的数据量就会多得多。虽然DBMS
的内部处理不尽相同，但是对于排序处理来说，基本上都是一样的。
此外，WHERE子句更具速度优势的另一个理由是，可以对WHERE子句指定条
KEYWORD 件所对应的列创建索引，这样也可以大幅提高处理速度。创建索引是一种非常普遍
●索引（index） 的提高DBMS性能的方法，效果也十分明显，这对WHERE子句来说也十分有利。
● 108 第3章 聚合与排序
第3章 聚合与排序
3-4
对查询结果进行排序
● 使用ORDER BY子句对查询结果进行排序。
学习重点
● 在ORDER BY子句中列名的后面使用关键字ASC可以进行升序排序，使
用DESC关键字可以进行降序排序。
● ORDER BY子句中可以指定多个排序键。
● 排序健中包含NULL时，会在开头或末尾进行汇总。
● ORDER BY子句中可以使用SELECT子句中定义的列的别名。
● ORDER BY子句中可以使用SELECT子句中未出现的列或者聚合函数。
● ORDER BY子句中不能使用列的编号。
子句
ORDER BY
截至目前，我们使用了各种各样的条件对表中的数据进行查询。本节
让我们再来回顾一下简单的SELECT语句（代码清单3-27）。
代码清单3-27 显示商品编号、商品名称、销售单价和进货单价的SELECT语句
SELECT product_id, product_name, sale_price, purchase_price
FROM Product;
执行结果
product_id | product_name | sale_price | purchase_price
-----------+---------------+--------------+----------------
0001 | T恤衫 | 1000 | 500
0002 | 打孔器 | 500 | 320
0003 | 运动T恤 | 4000 | 2800
0004 | 菜刀 | 3000 | 2800
0005 | 高压锅 | 6800 | 5000
0006 | 叉子 | 500 |
0007 | 擦菜板 | 880 | 790
0008 | 圆珠笔 | 100 |
对于上述结果，在此无需特别说明，本节要为大家介绍的不是查询结
果，而是查询结果的排列顺序。
那么，结果中的8行记录到底是按照什么顺序排列的呢？乍一看，貌
KEYWORD
●升序 似是按照商品编号从小到大的顺序（升序）排列的。其实，排列顺序是随
3-4 对查询结果进行排序 109 ●
机的，这只是个偶然。因此，再次执行同一条SELECT语句时，顺序可
能大为不同。
通常，从表中抽取数据时，如果没有特别指定顺序，最终排列顺序便无
从得知。即使是同一条SELECT语句，每次执行时排列顺序很可能发生改变。
但是不进行排序，很可能出现结果混乱的情况。这时，便需要通过在
KEYWORD SELECT语句末尾添加ORDER BY子句来明确指定排列顺序。
●ORDER BY子句
ORDER BY子句的语法如下所示。