title:A Dynamic Replica Selection Algorithm for Tolerating Timing Faults
author:Sudha Krishnamurthy and
William H. Sanders and
Michel Cukier
A Dynamic Replica Selection Algorithm for Tolerating Timing Faults* 
Sudha Krishnamurthy, William H. Sanders, and Michel Cukier 
Center for Reliable and High-Performance Computing 
University of Illinois at Urbana-Champaign, Urbana, Illinois 61 801 
E-mail:{krishnam,whs,cukier}@crhc.uiuc.edu 
Abstract 
Server replication is commonly used to improve the fault 
tolerance and response’tinze of distributed services.  An im- 
portant problem when  executing  time-critical  applications 
in a replicated environment is that of preventing timing fail- 
ures by dynamically selecting  the  replicas that can satisjy 
a client’s timing requirement, even when the quality of ser- 
vice is degraded due to replica failures and excess load on 
the server  In this paper; we describe the approach we have 
used to solve  this problem in AQUA, a  CORBA-based mid- 
dleware that transparently replicates objects across a local 
area network.  The approach  we  use estimates a  replica’s 
response time distribution  based on perforniance measure- 
ments regularly broadcast by the replica.  An online model 
uses  these  measurements  to predict  the probability  with 
which a  replica  can prevent a  timing failure for a  client. 
A  selection  algorithm then  uses  this prediction to choose 
a subset of replicas that can together meet the client’s tim- 
ing constraints with at least the probability requested by the 
client.  We conclude with experiniental results based on our 
implementation. 
1. Introduction. 
Server  replication  is  a  popular  approach  for  building 
fault-tolerant distributed  services (e.g.,  [ 1, 7, 12, 3, 14, 61). 
Replication  is also  a commonly used  solution  for improv- 
ing  the  scalability  of  a  distributed  service, i.e.,  to  ensure 
that  the  response time  of  a  service does  not  significantly 
degrade with an increase in the number of clients accessing 
the service (e.g., [ 10, 13,4]). Achieving both fault tolerance 
and scalability  at the same time,  however, is a challenging 
goal,  especially  when  the  number of  available  replicas  is 
constrained.  We can achieve good fault  tolerance by  allo- 
cating  all  the  available  replicas  to  service a  single client. 
*This research  has been supported  by the DARPA Quorum Integration 
contract F30602-98-C-0187 
However, such an approach is not scalable as it increases the 
load on all the replicas and results in higher response times 
for the  remaining clients.  On  the  other hand, assigning a 
single replica  to service each client allows multiple  clients 
to  be serviced  in  parallel.  However, should a  replica  fail 
while servicing a request, the failure could result  in an un- 
acceptable delay for the client being serviced.  Hence, nei- 
ther approach is suitable when a client has  specific timing 
constraints and when failure to meet the constraints results 
in a penalty for the client. Thus, in order to build a depend- 
able service, we need a method that attempts to prevent the 
occurrence of such timing failures for a client by  selecting 
replicas from the available replica pool, based on an under- 
standing of the client’s timing requirements and the respon- 
siveness of the replicas.  The research described in this papcr 
presents the approach we have used to realize this goal. 
Several other replica selection algorithms have been for- 
mulated  with  the objective of choosing the replica  that can 
deliver the lowest possible response time. These algorithms 
often target clients of stateless, distributed services, such as 
the World Wide Web, in which the servers do not maintain 
any records of ongoing client transactions.  Some of these 
algorithms choose the  nearest  replica based  on  a  distance 
metric [9], and some choose the replica with the best histor- 
ical  average response time  [ 191.  Some predict  the  time  to 
propagate a message to  different replicas  using  regression 
analysis of previously collected data [2] and pick the replica 
that has the lowest future propagation time. Finally, some of 
them actively monitor both replica load and network delays, 
use these to estimate the response times of the replicas, and 
select  the  replica that  has  the  smallest estimated  response 
time [ 5 ] .  All of these efforts assign a single replica to each 
client and do not consider the case in  which a replica  may 
fail  while servicing a request.  As such, it  is the  responsi- 
bility  of  the  client to retransmit its request  upon  failure to 
receive a response.  Such a simple retransmission  strategy, 
however, may not be suitable for clients with  specific time 
constraints. 
In contrast, our work targets clients that have specific re- 
sponse time requirements and require that these be met with 
0-7695-1101-5/01 $10.00 0 2001 IEEE 
107 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:03:31 UTC from IEEE Xplore.  Restrictions apply. 
for distributed  applications.  Fault tolerance is provided by 
transparently  replicating  objects using  active  and passive 
replication.  The Proteus dependability  manager  manages 
the replication  level for different applications based on their 
dependability  requirements.  Replicas  offering  the  same 
service  are  organized  into  a  group.  Communication  be- 
tween members of a group takes place through the Maestro- 
Ensemble protocol stack [20,8], above which AQuA is lay- 
ered. Maestro-Ensemble also detects and notifies the mem- 
bers of changes to the group membership. The use of group 
communication  in  AQuA  is  transparent to  the end appli- 
cations.  Hence each of the clients, which are all CORBA 
objects,  is  given  the  perception  that  it  is  communicating 
with a single server object using CORBA's  IIOP [ 151. This 
is  achieved using  an  AQuA  gateway,  which  transparently 
intercepts a  local  application's  CORBA message and  for- 
wards it to the destination replica group through Maestro- 
Ensemble, as shown in Figure 1. For the sake of clarity, in 
this figure  we  have illustrated a server replica  group hav- 
ing only  a single member.  In  reality, this group may  have 
multiple replica members. 
The different replication schemes supported by  AQuA 
are implemented as protocol  handlers  within  the gateway. 
An  AQuA client uses  different gateway  handlers to  com- 
municate with different server groups.  These handlers are 
responsible for tolerating different kinds  of  faults.  Previ- 
ous  work  in  AQuA  has  addressed  the  issue  of  tolerating 
crash  failures using the  active  [ 181 and  passive  [ 171 han- 
dlers.  [ 161 also discusses how AQuA simultaneously toler- 
ates value faults and crash failures using an active handler. 
In this paper, we describe the approach we have used to tol- 
erate timing faults, which  has resulted in  the development 
of the timing fault handler. 
3. System Model 
Given this overview of AQuA, we now describe the sys- 
tem  for  which  we  want  to  solve  the  dynamic replica  se- 
lection  problem.  The machines hosting replicated services 
in  this  system are distributed across  a  local  area network 
(LAN). A machine may host multiple replicas. The services 
in  this  system  are  frequently  accessed  by  several  clients 
concurrently.  Clients requesting the use  of  these services 
demand specific  response  time guarantees that  have  to be 
met with a certain probability. Failure to receive a response 
for a request within the specified  time results  in  a  timing 
failure for the client. 
We assume that the load on a replica may  fluctuate and 
that periods of high  load may make it less responsive.  We 
also  assume  that  while  the  links  in  the  LAN  connecting 
the  system do not experience frequent fluctuations in  traf- 
fic, they  may experience occasional periods of high traffic, 
which  may  result  in  large delays  in  the  message  delivery 
108 
Figure 1. Communication using AQuA  gate- 
way handlers 
certain probabilities. As in the above efforts, our work also 
targets  clients of  stateless applications such  as  search en- 
gines and  radar-tracking applications.  However, the repli- 
cas in  our case are distributed across a  local  area network 
(LAN). The approach we use  first estimates a replica's re- 
sponse  time  distribution  based  on  performance  measure- 
ments  regularly  disseminated  by  the  replica.  An  online 
model  uses  these  measurements  to  estimate  the  probabil- 
ity with which  the replica can prevent a timing failure for a 
client. A selection algorithm uses this estimate to choose a 
subset of available replicas that can together meet a client's 
timing constraints with at least the probability  requested by 
the  client.  Each  replica in  the  selected set independently 
processes the request and sends its response. However, only 
the earliest reply is delivered to the client. The selected sub- 
set  is  chosen  in  such  a  way  that the  client's  probabilistic 
timing requirement can be met even when one of the mem- 
bers in the selected subset crashes before responding to the 
request.  We have implemented our algorithm in  AQuA, a 
CORBA-based middleware that supports transparent repli- 
cation. 
The rest of this paper is organized as follows. Section 2 
presents an overview of AQuA. Section 3 describes our as- 
sumptions and our system model. In Section 4 we describe 
the replica the selection problem.  In  Section 5  we present 
the dynamic replica selection algorithm that we have devel- 
oped to tolerate timing faults in  AQuA. We present exper- 
imental  results based  on  our implementation in  Section 6. 
In Section 7 we compare our work with some of the related 
efforts, and finally, in Section 8 we present our conclusions. 
2. Overview of AQUA 
Figure  1 presents an overview of the AQuA middleware. 
Proteus,  a  component  of  AQuA  [3],  enhances  the  capa- 
bilities  of  CORBA  [I51 objects to  provide fault tolerance 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:03:31 UTC from IEEE Xplore.  Restrictions apply. 
time. Finally, a replica may crash, making it unresponsive. 
Any of these factors may contribute to a timing fault. 
4. Problem Description 
Given the above sources of timing faults, the problem we 
address is that of finding a way to reduce the occurrence of 
timing failures by servicing as many requests as possible  in 
a timely manner.  We  achieve this by devising an approach 
that  will  allocate  the  replicas to  the  clients based  on their 
response time requirements. We now state how a client ex- 
presses its timing constraints and then outline the decisions 
that have to be made when allocating the replicas. 
A client which requires that  a service respond  to its re- 
quest within a specific time, expresses its requirements as a 
quality of service (QoS) specification.  The client may either 
specify its QoS requirement at start-up time, or negotiate it 
at runtime as often as it wants.  This specification includes 
the  name of a service, the  time  by  which  the  client  wants 
to  receive  a  response  after  it  transmits  its  request  to  this 
service, and  the minimum probability  with  which  it wants 
this time constraint  to be met.  If a response  does not meet 
this time constraint then it results in a timing failure for the 
client. If the frequency of timing failures is so high that the 
system is unable to deliver timely responses with at least the 
minimum probability  that the client has specified, then  the 
client receives a notification through a callback. 
Our research objective is to reduce the occurrence of tim- 
ing failures under normal conditions as well as when the re- 
sponsiveness of a service is reduced, either due to failure of 
its replicas or due to the load induced when multiple clients 
with different QoS requirements access a service over a pe- 
riod  of time.  We  achieve this  objective  by  designing a re- 
quest scheduler that  transparently  intercepts  a  client’s re- 
quest, estimates  the response time of the different replicas 
offering the service that the client has requested, and selects 
a subset of  available  replicas  that  can meet  the client’s re- 
sponse time requirements with a probability  at least as high 
as that requested  by  the client.  The scheduler uses histori- 
cal performance data collected at runtime as inputs to solve 
a probabilistic model, which estimates the probability that a 
response  will be received on time.  The scheduler then for- 
wards the request  to  the  selected  replicas.  Each  of the se- 
lected replicas independently services the request and sends 
back  its  response.  However,  only  the  earliest  response  is 
delivered  to  the  client.  In  this  paper, we  describe the  de- 
sign  of  a  distributed  scheduling system within  the  AQuA 
middleware, in which  each client is associated  with  a local 
scheduling agent that makes the replica selection decisions 
on the client’s behalf. 
In  a  system  in  which  a  replica’s  responsiveness  may 
change unpredictably  due to either load or crashes,  like the 
system we have described in Section  3, it is impossible for 
the  scheduler to  predict  with  certainty whether any  single 
replica can meet a client’s timing constraint. In order to sat- 
isfy  our goals of providing a scalable service while at the 
same time providing a reasonable level  of  fault  tolerance, 
an  important decision  our scheduler has to make is that of 
choosing the redundancy  level with  which a request  has to 
be serviced. The scheduler we have designed makes its de- 
cisions adaptively  based  on the probability  with  which  the 
individual  replicas  will  meet  the client’s timing constraint. 
The higher the probability that the chosen replicas will meet 
the constraints, the lower is the redundancy level. 
5. Dynamic Replica Selection in AQuA 
We now describe a dynamic replica selection  algorithm 
that  we have developed to address the timing failure prob- 
lem in AQuA. We first discuss the performance parameters 
we  use  to guide the replica  selection.  We then discuss the 
design  of  the  information  repository that  stores  the  mea- 
sured  values  of  these  parameters.  We  next  describe  our 
selection  algorithm, which uses these  experimentally mea- 
sured  parameters to build  a  model  that  guides the  replica 
selection.  We  conclude this  section  with  a  description  of 
the design  and implementation  of  the  timing  fault  handler 
that  tries  to  meet  a client’s timing requirements using  this 