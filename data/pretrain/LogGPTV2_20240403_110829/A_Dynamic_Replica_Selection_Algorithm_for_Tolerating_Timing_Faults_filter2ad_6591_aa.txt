# A Dynamic Replica Selection Algorithm for Tolerating Timing Faults

**Authors:**
Sudha Krishnamurthy, William H. Sanders, and Michel Cukier  
Center for Reliable and High-Performance Computing  
University of Illinois at Urbana-Champaign, Urbana, Illinois 61801  
Email: {krishnam, whs, cukier}@crhc.uiuc.edu

## Abstract
Server replication is a common technique to enhance the fault tolerance and response time of distributed services. When executing time-critical applications in a replicated environment, a significant challenge is to prevent timing failures by dynamically selecting replicas that can meet a client's timing requirements, even under degraded service quality due to replica failures or excessive load. In this paper, we present our approach to addressing this problem within AQUA, a CORBA-based middleware that transparently replicates objects across a local area network (LAN). Our approach involves estimating a replica's response time distribution based on performance measurements regularly broadcast by the replica. An online model uses these measurements to predict the probability that a replica can prevent a timing failure for a client. A selection algorithm then uses this prediction to choose a subset of replicas that collectively meet the client's timing constraints with at least the specified probability. We conclude with experimental results from our implementation.

## 1. Introduction
Server replication is a popular method for building fault-tolerant distributed services (e.g., [1, 7, 12, 3, 14, 6]). Replication also improves the scalability of a distributed service, ensuring that the response time does not significantly degrade as the number of clients increases (e.g., [10, 13, 4]). Achieving both fault tolerance and scalability simultaneously, however, is challenging, especially when the number of available replicas is limited.

Allocating all available replicas to a single client can provide good fault tolerance but is not scalable, as it increases the load on all replicas and results in higher response times for other clients. Conversely, assigning a single replica to each client allows multiple clients to be serviced in parallel, but a replica failure could cause an unacceptable delay for the client being serviced. Therefore, neither approach is suitable when a client has specific timing constraints, and failing to meet these constraints incurs penalties.

To build a dependable service, we need a method that prevents timing failures by selecting replicas based on the client's timing requirements and the responsiveness of the replicas. This paper presents our approach to achieving this goal.

Several existing replica selection algorithms aim to choose the replica with the lowest possible response time, often targeting stateless, distributed services like the World Wide Web, where servers do not maintain records of ongoing client transactions. Some algorithms select the nearest replica based on a distance metric [9], while others choose the replica with the best historical average response time [19]. Some predict the message propagation time using regression analysis [2], and some actively monitor replica load and network delays to estimate response times and select the replica with the smallest estimated response time [5]. These methods assign a single replica to each client and do not consider the case where a replica may fail during request processing. In such cases, the client must retransmit the request, which may not be suitable for clients with strict timing constraints.

In contrast, our work targets clients with specific response time requirements, ensuring these are met with certain probabilities. Our approach estimates a replica's response time distribution based on performance measurements, uses an online model to predict the probability of preventing a timing failure, and selects a subset of replicas that can meet the client's timing constraints with the requested probability. Each selected replica processes the request independently, and only the earliest response is delivered to the client. The selected subset is chosen to ensure the client's probabilistic timing requirement is met even if one of the selected replicas crashes. We have implemented our algorithm in AQUA, a CORBA-based middleware that supports transparent replication.

The rest of this paper is organized as follows: Section 2 provides an overview of AQUA. Section 3 describes our assumptions and system model. Section 4 outlines the problem of dynamic replica selection. Section 5 presents our dynamic replica selection algorithm. Section 6 details the experimental results. Section 7 compares our work with related efforts, and Section 8 concludes the paper.

## 2. Overview of AQUA
Figure 1 provides an overview of the AQUA middleware. Proteus, a component of AQUA [3], enhances the capabilities of CORBA [15] objects to provide fault tolerance for distributed applications. Fault tolerance is achieved through transparent object replication using active and passive replication. The Proteus dependability manager manages the replication level for different applications based on their dependability requirements. Replicas offering the same service are organized into a group, and communication between group members occurs via the Maestro-Ensemble protocol stack [20, 8], above which AQUA is layered. Maestro-Ensemble also detects and notifies members of changes in group membership. Group communication in AQUA is transparent to end applications, giving each client the perception that it is communicating with a single server object using CORBA's IIOP [15]. This is achieved using an AQUA gateway, which intercepts a local application's CORBA message and forwards it to the destination replica group through Maestro-Ensemble, as shown in Figure 1. For clarity, the figure illustrates a server replica group with a single member, though in reality, the group may have multiple replicas.

AQUA supports different replication schemes implemented as protocol handlers within the gateway. AQUA clients use different gateway handlers to communicate with different server groups. These handlers are responsible for tolerating various types of faults. Previous work in AQUA has addressed crash failures using active [18] and passive [17] handlers, and [16] discusses how AQUA simultaneously tolerates value faults and crash failures using an active handler. In this paper, we describe our approach to tolerating timing faults, resulting in the development of the timing fault handler.

## 3. System Model
Given this overview of AQUA, we now describe the system for which we solve the dynamic replica selection problem. The machines hosting replicated services are distributed across a local area network (LAN), and a machine may host multiple replicas. The services are frequently accessed by several clients concurrently, and clients requesting these services demand specific response time guarantees that must be met with a certain probability. Failing to receive a response within the specified time results in a timing failure for the client.

We assume that the load on a replica may fluctuate, making it less responsive during periods of high load. We also assume that while the LAN links do not experience frequent traffic fluctuations, they may occasionally experience high traffic, leading to large delays in message delivery. Additionally, a replica may crash, making it unresponsive. Any of these factors can contribute to a timing fault.

## 4. Problem Description
Given the sources of timing faults, the problem we address is to reduce the occurrence of timing failures by servicing as many requests as possible in a timely manner. We achieve this by allocating replicas to clients based on their response time requirements.

A client requiring a service to respond within a specific time expresses its requirements as a quality of service (QoS) specification. The client can specify its QoS requirement at startup or negotiate it at runtime. The QoS specification includes the name of the service, the desired response time after transmitting the request, and the minimum probability with which the time constraint should be met. If a response does not meet this time constraint, it results in a timing failure for the client. If the frequency of timing failures is so high that the system cannot deliver timely responses with the specified minimum probability, the client receives a notification through a callback.

Our research objective is to reduce the occurrence of timing failures under normal conditions and when the responsiveness of a service is reduced due to replica failures or load from multiple clients with different QoS requirements. We achieve this by designing a request scheduler that intercepts a client's request, estimates the response time of different replicas, and selects a subset of available replicas that can meet the client's response time requirements with at least the requested probability. The scheduler uses historical performance data collected at runtime to solve a probabilistic model, which estimates the probability of receiving a response on time. The scheduler then forwards the request to the selected replicas. Each selected replica independently processes the request and sends back its response, but only the earliest response is delivered to the client. In this paper, we describe the design of a distributed scheduling system within AQUA, where each client is associated with a local scheduling agent that makes the replica selection decisions on the client's behalf.

In a system where a replica's responsiveness can change unpredictably due to load or crashes, it is impossible for the scheduler to predict with certainty whether any single replica can meet a client's timing constraint. To provide a scalable service while maintaining a reasonable level of fault tolerance, the scheduler must decide the redundancy level with which a request should be serviced. Our scheduler makes adaptive decisions based on the probability that individual replicas will meet the client's timing constraint. The higher the probability that the chosen replicas will meet the constraints, the lower the redundancy level.

## 5. Dynamic Replica Selection in AQUA
We now describe the dynamic replica selection algorithm we developed to address the timing failure problem in AQUA. We first discuss the performance parameters used to guide the replica selection, then the design of the information repository that stores the measured values of these parameters. Next, we describe our selection algorithm, which uses these experimentally measured parameters to build a model that guides the replica selection. We conclude this section with a description of the design and implementation of the timing fault handler that tries to meet a client's timing requirements using this approach.