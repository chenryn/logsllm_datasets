# 独角兽暑期训练营 | 嵌入式固件自动化漏洞扫描方法研究
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
> 该课题由独角兽安全夏令营第二届学员黄瑞同学完成
## 独角兽暑期训练营
360无线电安全研究院每年暑假都会面向在校学生举办一次暑期训练营，申请者投递简历并提交自己想做的课题介绍后，若入选，会在360技术专家的指导下完成课题。
本系列文章会发布今年5位学员在训练营中的成果。文章相关代码后续会在[训练营github代码仓库](https://github.com/UnicornTeam/summer-camp)发布 。
## 引言
从骨干路由器、交通信号灯到家用调制解调器和智能冰箱，嵌入式设备在现代生活中的应用越来越多。嵌入式设备固件的数量也增长到难以计量。安全人员曾经在这类设备上发现很多高危安全漏洞。相比挖掘新漏洞，在这些固件中扫描出已经在其他设备上发现或者是开源代码中发现过的漏洞，也非常重要。
因此，我们需要一种有效的解决方案来搜索固件中的漏洞。
由于各种设备供应商使用了各种不同的处理器架构和独特的工具链，以及固件的高度定制特性，在固件搜索漏洞代码片段极具挑战性。
我们尝试解决的问题是：检测采用不同指令集的二进制固件中，是否使用过包含有特定漏洞的代码片段。我们阅读了一些二进制搜索的学术论文，并实现了验证平台，针对这个目标做了一些改进，识别准确性取得了提高。
## 主要工作
本文总结了在阅读分析两篇静态二进制代码搜索的文章后，对文章中的思路和算法进行复现并评估效果，在效果并不理想的情况下进行了一点改进并再次评估的过程。
文章分别是：
  1. Yaniv David, Nimrod Partush, and Eran Yahav. 2018. FirmUp: Precise Static Detection of Common Vulnerabilities in Firmware. (ASPLOS ’18). ACM, New York, NY, USA, 392-404.
  2. Yaniv David, Nimrod Partush, and Eran Yahav. 2017. Similarity of binaries through re-optimization. SIGPLAN Not. 52, 6 (June 2017), 79-94.
## 问题定义
给定程序集F={T1, T2, …, Tn} 和一个查询程序Q， Q中包含一个(有漏洞的)函数q，我们的目标是判断 Ti (∈ F)
是否包含一个与q相似的函数。
首先是我们想要解决的问题，比较严谨的问题定义如上，给定T1,T2，T3还有查询程序Q，这些都是二进制程序，其中Q中包含了一个函数q，我们的目标就是搜索这些T中是否有函数与q是相似或者相同的。直观来讲就是在F里面搜索q这个函数。
## 应用场景
下面来是解决如上所述问题的意义、解决后可以应用在哪些场景：
跨平台、跨工具链、跨优化等级程序中的代码搜索：最广泛的应用场景是目前IOT的设备越来越多，但是设备的固件都是经过编译、去掉符号表、打包好的，相同功能设备上面的程序可能是跨平台、跨工具链、跨优化等级的，这个时候我们只能从二进制层面去尝试大规模的自动化分析。
闭源软件分析：因为windows上的大多数软件都是闭源的，也只能从二进制层面进行分析搜索。
## 两种解决思路
在阅读了一些文章后总结解决上述问题大致有两种思路：
利用图论：
CFG(control-flow-graph)本质是图，节点是代码片段，边是跳转关系。利用图算法，通过寻找两个CFG间的同构或子图同构来进行相似度匹配
生成特征：
利用一个函数的某些或所有的basic-block的内容以及CFG的结构，执行相应的算法生成属于这个函数的特征，随后通过比较两个代码片段的特征来判断二者的相似度。
## Firmup
Firmup是作者这一系列论文中最新的一篇里的解决方案，也是准确率最高的。Firmup方案中使用的是上面的第二种思路，也就是分别生成属于两段代码的特征，然后对比两个特征得出相似度。下面介绍Firmup方案里的特征提取算法以及特征匹配算法。
###  特征提取算法
第一步：生成CFG
CFG控制流图中每个节点代表一个基本块(basic-block)，跳跃目标以一个块开始，和以一个块结束。生成CFG有很多成熟工具可以完成,同时也允许编程，比如IDApython，和angr 二进制分析框架。
第二步：统一为Vex-IR
VEX-IR是为了方便二进制自动化分析而创造的跨平台间差异的中间表达式。第二步是将CFG的每个节点也就是basicblock的内容以Vex-IR的形式来储存，IR是一种语言的中间形式，类似于clang编译器前端将c语言翻译为IR，编译器后端再将IR编译成具体平台的代码。但是Vex-IR比较特殊，是由二进制代码提升为IR，是反向的，专门用于跨平台二进制分析，能把不同平台的指令统一为同一种形式。比如上图第一张是两条汇编指令，第二张是翻译成的Vex-IR，以IMark指令为分割，将每条汇编指令都翻译成了多条Vex-IR，比如0x404ee这条pop指令翻译之后，包括了读取rsp当前指向内容、缩小栈再到赋值给rbp、为pc赋值将指令指针指向下一条，可以看出Vex-IR是将一条汇编指令的所有功能翻译为多条简单指令(load以及put)来实现跨平台统一的。这是Firmup的思路中起到跨平台的主要工具。
第三步：数据流分片
这一步运用数据流分片，将Basic-Block分为更细的粒度:strand，strand是一个BB中的一个Use-Define链，每个strand只包含用来计算同一输出的多条指令。具体分片操作是由下向上的，比如先使用第5条指令cmp，在里面使用了寄存器r13,接着上找到第四条sub修改了r13的值，同时又读取了r15,再向上找第2条指令为r15赋值，同时也读取了rax，至此上面也没有指令为rax赋值，一个strand就分割完成了。再经过类似的过程，可以将一块BB分割为多个strand，每一个strand都是一个完整的“赋值-使用”的链条。
第四步：Vex-IR to LLVM-IR