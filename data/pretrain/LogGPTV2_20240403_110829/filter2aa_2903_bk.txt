在对Debug和8086 Monitor的基本情况有所了解后，我们来看它们的
主要功能是如何实现的。
8086 Monitor是完全使用汇编语言编写的。整个程序的机器码大约
有2000多个字节，可谓是非常精炼。在Tim Paterson先生目前公司的网
站上有8086 Monitor程序的汇编代码清单，以下讨论将结合这份清单中
的代码，为了节约篇幅，我们只引用关键的代码段，并在括号中标出页
码，建议读者自行下载并对照阅读。
因为在实模式下的系统中只有一个任务在运行，所以调试器和被调
试程序的代码和数据都是在一个内存空间中的，而且这个空间中的地址
就是物理地址。为了避免冲突，调试器和被调试程序各自使用不同的内
存区域。以8086 Monitor为例，它使用从0xFF80开始的较高端内存空
间，把低端留给被调试程序。
调试器和被调试程序在一个内存空间中为实现很多调试功能提供了
很大的便利。例如，对于所有与内存有关的命令，内存地址不需要做任
何转换就可以直接访问。当设置断点时，也可以直接把断点指令写到被
调试程序的代码中。这与多任务操作系统下的情况完全不同，在多任务
操作系统中，调试器和被调试程序各自属于不同的内存空间，调试器需
要借助操作系统的支持来访问被调试程序的空间。
为了响应调试异常，8086 Monitor会改写中断向量表的表项1（地址
4～7）、3（地址0xC～0xF）和19H（地址0x64～0x67）——分别对应
于INT 1、INT 3和INT 19H。INT 1用于处理单步执行时的异常，INT 3
用于处理断点异常，INT 19H用于串行口通信接收命令。
下面以断点为例介绍调试器的工作过程。当CPU执行到断点指令
（INT 3）时，会转去执行中断向量表中3号表项所指向的代码。当8086
Monitor初始化时，已经将其指向标号BREAKFIX所开始的代码
（Mon_86_1.4a.pdf 的第27页），即：
BREAKFIX:
   XCHG SP, BP
   DEC [BP]
   XCHG SP, BP
在跳转到异常处理的代码前，CPU把当时的程序指针寄存器的值保
存在栈中，因此以上3条指令的作用是将放在栈顶的程序指针寄存器的
值减1后再放回去，减1的目的是使其恢复为INT 3指令指向前的值，也
就是执行INT 3指令，同时也就是设置断点的位置。
以上3行的下面便是标号REENTER开始的代码（也是
Mon_86_1.4a.pdf 的第27页），这也是INT 1和INT 19H的处理器入口。
这样便很自然地实现了3个异常处理代码的共享。
REENTER代码块首先将当前寄存器的值保存到变量中。调试时R命
令显示的寄存器值都是从这些变量中读取的。也就是说，这些变量的作
用与Windows系统中的CONTEXT结构的作用是一样的。
接下来，调用CRLF开始一个新的行，调用DISPREG显示寄存器的
值，然后对变量TCOUNT递减1。TCOUNT用于记录T命令的参数，即
单步执行的指令条数，如果TCOUNT不等于0，那么就跳到
STEP1（Mon_86_1.4a.pdf 的第27页）去再单步执行一次。否则，判断
BRKCNT变量，检查当前的断点个数，如果大于0，那么就自然向下执
行清除断点的代码（标号CLEANBP），也就是说，将设置断点用的断
点指令恢复成原来的指令内容。当恢复断点时，或者当BRKCNT等于0
时，便跳转到标号COMMAND（Mon_86_1.4a.pdf 的第13页），等待用
户输入命令，开始交互式调试。
当用户输入命令后，调试器（8086 Monitor）会根据一个命令表来
跳转到处理该命令的代码。执行完一个命令并显示结果后，调试器会等
待下一个命令，直至接收到恢复程序执行的命令T或G。以G命令为例，
它最多可以跟10个地址参数，最多可以用来定义10个断点。调试器会依
次解析每个地址，然后将其保存到内部的断点表中，而后将断点地址处
的一个字节保存起来，并替换成0xCC（即INT 3指令）。设置断点后
（或G命令没有带参数，不需要设置断点），调试器会将TCOUNT命令
设置为1，然后跳转到EXIT标号（Mon_86_1.4a.pdf 的第26页）所代表的
用于异常返回的代码。
EXIT代码会先设置异常向量，然后把保存在变量中的寄存器内容
恢复到物理寄存器中，最后把变量FSAVE、CSSAVE和IPSAVE的值压
入到栈中，然后执行中断返回指令IRET。
MOV SP, [SPSAVE]
PUSH [FSAVE]
PUSH [CSSAVE]
PUSH [IPSAVE]
MOV DS,[DSSAVE]
IRET
FSAVE变量用于保存标志寄存器的值，CSSAVE和IPSAVE变量分
别用于保存段寄存器和程序指针寄存器的值。当产生异常时，CPU便会
把这3个寄存器的值压入到栈中，当异常返回时，CPU是从栈中读取这3
个寄存器的值，赋给CPU中的对应寄存器，然后从CS和IP（程序指针）
寄存器指定的地址开始执行。因为标志寄存器和IP寄存器的特殊作用，
8086架构没有设计直接对标志寄存器和程序指针寄存器赋值的指令，修
改它们的最主要方式就是当中断返回时通过栈来间接修改。因为在调试
器中可以修改FSAVE、CSSAVE和IPSAVE变量，所以可在调试器中通
过修改这3个变量来影响恢复执行时它们的值。单步执行命令就是通过
设置FSAVE的TF标志实现的。通过修改IPSAVE变量可以达到改变执行
位置的目的，让程序“飞跃”到任意的地址恢复执行。
本节简要介绍了实模式下的调试器的实现方法。因为是单任务环
境，所以实现比较简单。在保护模式和Windows这样的多任务操作系统
下，因为涉及任务之间的界限和用户态及内核态的界限，所以要实现调
试变得复杂很多，调试器必须与操作系统相互配合。我们将在后面的章
节中逐步介绍相关内容。
4.5 反调试示例
出于某些理由，有些软件是不希望被调试的，于是便有了五花八门
的反调试技术。与调试技术类似，很多反调试技术也是与CPU的硬件支
持密不可分的。反调试技术千变万化，最常用的就是回避调试器。一旦
检测到调试器存在，示例就拒绝运行（见图4-8）或者不再走“寻常
路”，故意跳来跳去，或者干脆跳入一个死循环，让调试者无法跟踪到
它的真实轨迹。下面通过一个真实的例子略作阐述。
图4-8 回避调试器
 老雷评点  
某年在深圳腾讯，有书友建议老雷写一本反调试技术的书，
婉言谢绝，原因主要是深刻理解了调试，举一反三即可知反调
试，再深挖一下，便可知化解之法，本节证之。（评于珠海石景
山顶之渔女故事浮雕前）
本章4.3节介绍的跟踪标志（TF）是单步跟踪功能的基础，是大多
数调试器所依赖的一个硬件基础。正因如此，它也被用来检测调试器的
存在和实现反调试，清单4-10所示的这段汇编指令就是这样的。
清单4-10 第24行的汇编代码
1      xor     eax,eax
2      push    dword ptr fs:[eax]
3      mov     dword ptr fs:[eax],esp
4      pushfd
5      or      byte ptr [esp+1],1
6      popfd
7      nop
8      nop
9      ret
短短9条汇编指令，是如何实现反调试的呢？可不要小看这9条指
令，可以把它分成三部分。前 3 条是在当前线程的异常处理器链表
（FS：0链条，详见卷2）上注册了一个结构化异常处理器。中间3条是
设置TF标志，先将标志寄存器压入栈，然后修改栈上的值，设置TF位
（Bit 8，即字节1的Bit 0），然后再弹到标志寄存器中，这样便做好了
单步跟踪的准备。接下来的空操作指令（nop）是要真的走一步，促发
单步异常，用来检测是否有调试器存在。如果有调试器存在，那么调试
器会收到异常，并处理掉这个异常，然后继续执行接下来的nop和ret，
返回到父函数。如果没有调试器呢？那么前3条指令所设置的异常处理
函数后便收到异常，得到执行权。如此看来，这个函数的执行逻辑在有
无调试器的情况下就可能不同，有调试器的情况下，它会返回到父函
数，没有调试器时会执行参数指定的异常处理函数（前3条指令恰好是
把压在栈上的参数当作异常处理函数），这就是它检测调试器的原理。
不妨给这一小段函数取个名字叫ExecuteWhenNoDebugger，以下伪代码
演示了它的用法。
ExecuteWhenNoDebugger (FunctionSecret);
DeadLoopOrAcessViolationShamelessly (); // debugger is on, escape
也就是说，没有调试器时，ExecuteWhenNoDebugger便一去不返，
去执行保密逻辑了。如果函数“顺利返回”便说明有调试器在，赶紧使出
浑身解数“撒野耍赖”。
对于这样的反调试方法，有什么办法可以破解呢？其实只要了解了
它的工作处理和异常处理的规则，就很容易化解它。假设在用WinDBG
调试这个软件，那么在收到这样的单步异常时，WinDBG会给出如下提
示：
(c54.2fe4): Single step exception - code 80000004 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
给出这个提示的原因是WinDBG觉得这个单步异常有些突然，并不
是自己埋伏的。此时如果继续单步或者执行G命令，那么WinDBG便会
处理掉这个异常，便露出“马脚”了。但如果执行Gn命令，告诉WinDBG
向系统回复“不处理”这个异常，那么系统便会继续分发这个异常，让这
个软件的异常处理器收到，让它觉得没有调试器存在。简言之，只要执
行命令n，就将其化解了。
 格物致知
下面便通过调试一个做过“加壳保护”的小程序来让大家感受一下调
试与反调试的激烈博弈。
① 启动WinDBG，选择File→Open Executable，指定
c:\swdbg2e\bin\hiheapa.exe，开始调试。
② 执行g命令运行小程序，但很快会中断下来，显示上文提到的消
息，提示有单步异常发生。
③ 选择View→Disassembly，打开反汇编窗口，可以看到清单4-9所
示的指令。
④ 我们先尝试不懂“化解”方法的情况，按F10快捷键单步跟踪执
行，执行ret指令后，立刻返回到预先埋伏的“铁丝网”，看到下面这样的
无效指令：
0018ffc4 ff              ???
0018ffc5 ff              ???
0018ffc6 ff              ???
⑤ 继续单步执行，就会触发访问违例异常，无法继续了：
(14b4.10cc): Access violation - code c0000005 (first chance)
⑥ 执行.restart /f重新调试这个程序，重复步骤2和步骤3。这一次，
执行Gn命令将其化解。
⑦ 通常一个反调试软件会设置“层层壁垒”，因此化解掉一个之后，
还会有后续的——接下来会收到一个断点异常。在反汇编窗口中会看到
下面这些指令：
004847de 50              push    eax
004847df 33c0            xor     eax,eax
004847e1 64ff30          push    dword ptr fs:[eax]
004847e4 648920          mov     dword ptr fs:[eax],esp
004847e7 bdd3f10e30      mov     ebp,300EF1D3h
004847ec 81c578563412    add     ebp,12345678h
004847f2 66b81700        mov     ax,17h
004847f6 6683e813        sub     ax,13h
004847fa cc              int     3
004847fb 90              nop
与清单4-9颇为类似，只不过这里触发的是断点异常。
⑧ 再执行Gn命令化解，还会再收到异常。至此，实验目的已经达
到，直接关闭调试器，结束实验。
反调试技术的热门从侧面证明了调试技术的强大。对于那些编写不
良代码的人来说，调试技术会让他们心生畏惧。当然，有些情况下，人
们使用反调试技术实现软件保护等合理用途，这是反调试技术的正面应
用。
4.6 ARM架构的断点支持
在竞争激烈的芯片领域，有些公司逐渐没落，有些公司迅速崛起。
在最近十几年中，ARM迅猛发展，走出了一条非常独特的道路。ARM
的迅速崛起有多方面原因，从技术角度来看，ARM平台的强大调试支
持功不可没。翻看ARM手册，关于调试设施的信息俯拾即是。以
ARMv7的架构参考手册为例，正文分A、B、C三大部分，其中C部分就
是专门介绍调试设施的《调试架构》，与应用层架构（部分A）和系统
编程（部分B）三足鼎立。阅读长达300多页的《调试架构》部分，其设
施之丰富，其灵活性之高，其定义之详细，在不少地方都超过了x86，
真可谓是后来者居上。
 老雷评点  
老雷曾提议扩展x86之调试寄存器，结果不被采纳，与一职
位甚高的同事聊起此事时，得知“对经典x86的改进很难推得动，
不要去想”，听罢哑然。
ARM架构把所有调试设施分为入侵式调试（invasive debug）和非
入侵式（non-invasive debug）两大类。所谓入侵式调试，是指与被调试
目标建立深度的调试关系，不仅可以观察调试目标，还可以改变调试目
标，比如改变运行状态（如中断再恢复执行），或者修改调试目标的代