同的 I/O 然。
3.13 结论
 I/O  C 提的。的方
的方。 C 程实上 I/O对
的。然对 I/O理的 I/O 
的的方。调 write（出写
 I/O（
. 能调调
。
. 性能的的 I/O 以小进能
对。
. 的式或的实
进的调。
. 相的 Linux 调更喜的。
然的能的 Linux 调。我们将
式的 I/O 相的调。
– 88 –
 4 
文件 I/O
第 4 章
高级文件 I/O
我们 Linux 的 I/O 调。调文件
I/O 的 Linux 方式的。我们
I/O 调上空间空间的
方即 C 的 I/O 。我们将 Linux 提的更 I/O 
调
散布 / 聚集 I/O I/O 单调同时对读或写操
作聚集同进的 I/O 操作。
epoll
poll()  select() 的进程处理文件
的时。
内存映射 I/O
将文件映射内存以单的内存理方式处理文件;
的 I/O。
文件 I/O 提示
进程将文件 I/O 上的提示提给内; 能提
I/O 性能。
异步 I/O
进程出 I/O ; 
程的处理 I/O 操作。
将性能内的 I/O 子。
4.1 散布 / 聚集 I/O
散布聚集 I/O 以单调操作的 I/O 方
以将单的内写或单读
。散布或聚
集。方的 I/O。相对的提的读写调
以作性 I/O。
散布 / 聚集 I/O 性 I/O 相:
更自然的处理方式 的段的（处理的文件段
I/O 提的处理方式。
效率
单 I/O 操作能性 I/O 操作。
– 89 –
 4 
文件 I/O
性能
调的内 I/O 性
I/O 提更的性能。
原子性
同性 I/O 操作进程以单 I/O
操作进程操作的。
我们以散布 / 聚集 I/O 更自然的 I/O 方操作
原子性。进程以写散的写以读
的散即工实空间的散布
聚集。处理效的。
4.1.1 readv() 和 writev()
Linux 实 POSIX 1003.1-2001 的散布 / 聚集的调
。 Linux 实上的性。
readv()  fd 读 count  segment  iov 的∗
#include 
ssize_t readv (int fd, const struct iovec *iov,
int count);
writev()  iov 的读 count  segment 的写 fd 
#include 
ssize_t writev (int fd, const struct iovec *iov,
int count);
操作 readv()  writev() 的 read() write() 。
 iovec 的我们段 (segment)
#include 
struct iovec {
void *iov_base;
size_t iov_len;
};
∗处的 segment  iov 
– 90 –
 4 
文件 I/O
 segment 的集 (vector)。段读写的的
。 readv() 处理满的 iov len 
。 writev() 处理 iov len 
出。 iov[0]  iov[1] iov[count-1] 处理段。
4.1.1.1 返回值
操作时 readv()  writev() 读写的。
 iov len 的。出时 -1设 errno。调能
何 read()  write() 能的相同时 errno 设同的
。的。
 ssize t iov len 的 SSIZE MAX
处理 -1 errno 设 EINVAL。
 POSIX  count  0小 IOV MAX（
 。 Linux  IOV MAX  1024。 count  0
调 0。† count  IOV MAX处理 -1 errno 设
EINVAL。
 count
   I/O 操 作 内      内        示   段 (seg-
ment)。 count 的小进的。出的的
count 小的内上段内存
性能上的提。 8以 count 小 8 时
I/O 操作以效的内存方式。
 I/O 段。
小的时 8 或更小的性能的提。
4.1.1.2 writev() 示例
我们单的子 3 段段同的
的写。程以示 writev() 的能同时以
作段的段
†的 Unix  count  0 时能将 errno 设 EINVAL。
的 count  0以设 EINVAL 或处理。
– 91 –
 4 
文件 I/O
#include 
#include 
#include 
#include 
#include 
#include 
int main ()
{
struct iovec iov[3];
ssize_t nr;
int fd, i;
char *buf[] = {”The term buccaneer comes from
the word boucan.\n”, ”A boucan is a wooden
frame used for cooking meat.\n”, ”Buccaneer
is the West Indies name for a pirate.\n” };
fd = open (”buccaneer.txt”, O_WRONLY | O_CREAT
| O_TRUNC);
if (fd == -1) {
perror (”open”);
return 1;
}
/* fill out three iovec structures */
for (i = 0; i 
#include 
#include 
#include 
#include 
int main ()
{
char foo[48], bar[51], baz[49];
struct iovec iov[3];
ssize_t nr;
– 93 –
 4 
文件 I/O
int fd, i;
fd = open (”buccaneer.txt”, O_RDONLY);
if (fd == -1) {
perror (”open”);
return 1;
}
/* set up our iovec structures */
iov[0].iov_base = foo;
iov[0].iov_len = sizeof (foo);
iov[1].iov_base = bar;
iov[1].iov_len = sizeof (bar);
iov[2].iov_base = baz;
iov[2].iov_len = sizeof (baz);
/* read into the structures with a single call
*/
nr = readv (fd, iov, 3);
if (nr == -1) {
perror (”readv”);
return 1;
}
for (i = 0; i 
#include 
ssize_t naive_writev (int fd, const struct iovec
*iov, int count)
{
ssize_t ret = 0;
int i;
for (i = 0; i 
int epoll_create (int size)
调 epoll create()  epoll 实实的文件
。文件真的文件调
epoll 的。 size 内的文件
。的性能的提给出的。出
时 -1设 errno 
EINVAL
size 。
ENFILE
文件的上。
ENOMEN 的内存操作。
的调
int epfd;
epfd = epoll_create (100); /* plan to watch ˜100
fds */
if (epfd 
int epoll_ctl (int epfd, int op, int fd, struct
epoll_event *event);
文件   epoll event 
struct epoll_event {
__u32 events; /* events */
union {
void *ptr;
int fd;
__u32 u32;
__u64 u64;
} data;
};
epoll ctl() 调将 epoll 实 epfd。 op 对 fd 进的操
作。 event  epoll 更的。
以 op 的效:
EPOLL CTL ADD  fd 的文件 epfd 的 epoll 实集
 event 的件。
EPOLL CTL DEL
 fd 的文件 epfd 的 epoll 集。
EPOLL CTL MOD  event  fd 上的。
epoll events 的 events 出给文件上的
件。件以或同时。以效
EPOLLERR
文件出。即设件的。
– 97 –
 4 
文件 I/O
EPOLLET
文件上。 (” 
件”)。。
EPOLLHUP
文件。即设件的。
EPOLLIN
文件读。
EPOLLONESHOT 件处理文件。
EPOLL CTL MOD 新的件以新文件。
EPOLLOUT
文件写。
EPOLLPRI
的读。
event poll 的 data 段。件 data 给
。将 event.data.fd 设 fd以文件件。
 epoll ctl()  0。 -1设 errno 
EBADF
epfd 效 epoll 实或 fd 效文件。
EEXIST
op  EPOLL CTL ADD fd  epfd 。
EINVAL
epfd  epoll 实 epfd  fd 相同或 op 效。
ENOENT op  EPOLL CTL MOD或 EPOLL CTL DEL fd  epfd
。
ENOMEN 内存进程的。
EPERM
fd  epoll。
 epfd 实 fd 的文件以
struct epoll_event event;
int ret;
event.data.fd = fd; /* return the fd to us later
*/
event.events = EPOLLIN | EPOLLOUT;
ret = epoll_ctl (epfd, EPOLL_CTL_ADD, fd, &event);
if (ret)
perror (”epoll_ctl”);
 epfd 实的 fd 上的件以
struct epoll_event event;
– 98 –
 4 
文件 I/O
int ret;
event.data.fd = fd; /* return the fd to us
later */
event.events = EPOLLIN;
ret = epoll_ctl (epfd, EPOLL_CTL_MOD, fd,
&event);
if (ret)
perror (”epoll_ctl”);
相的 epfd  fd 上的件以
struct epoll_event event;
int ret;
event.data.fd = fd; /* return the fd to us later
*/
event.events = EPOLLIN;
ret = epoll_ctl (epfd, EPOLL_CTL_MOD, fd, &event);
if (ret)
perror (”epoll_ctl”);
的 op  EPOLL CTL DEL 时设件 event
以 NULL。 2.6.9 以的内空。
内效的 non-NULL  2.6.9 
 bug。
4.2.3 等待 Epoll 事件
epoll wait() 给 epoll 实的文件上的件
#include 
int epoll_wait (int epfd, struct epoll_event
*events, int maxevents, int timeout);
对 epoll wait() 的调 epoll 实 epfd 的文件 fd 上的件时
timeout 。 events  epoll event  (
件) 的内存以 maxevents 件。件出
– 99 –
 4 
文件 I/O
-1将 errno 设以
EBADF
epfd 效文件。
EFAULT 进程对 events 的内存写。
EINTR
调。
EINVAL epfd 效 epoll 实或 maxevents 小 0。
 timeout  0即件调即时调
0。 timeout  -1调将件。
调 epoll event 的 events 段的件。 data
段调 epoll ctl() 的设。
的 epoll wait() 子
#define MAX_EVENTS
64
struct epoll_event *events;
int nr_events, i, epfd;
events = malloc (sizeof (struct epoll_event) *
MAX_EVENTS);
if (!events) {
perror (”malloc”);
return 1;
}
nr_events = epoll_wait (epfd, events, MAX_EVENTS,
-1);
if (nr_events < 0) {