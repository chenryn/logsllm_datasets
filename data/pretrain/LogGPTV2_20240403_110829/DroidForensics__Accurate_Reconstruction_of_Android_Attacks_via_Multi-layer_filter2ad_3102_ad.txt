Android.Exprespam
FakeInstragram
unknown
HGSpy
FBI.Locker
Android.Fakeplay
Android.Fakenotify B wap.syst
Android.Fakeinstaller
Android.Fakedaum
Android.Fakebank B
crafted
imauyfxuhxd.qhlsrdb
com.tmvlove
com.example.adt
com.nativeCode
API Binder
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Full
Full
Full
Full
Full
Full
Full
Full
Full
Partial
Full
Full
Full
Full
Full
Full
Full
Full
Full
Full
Full
Full
Full
Full
Partial
Full
Full
Full
Full
Full
Full
Table 2: The reconstruction of Android attacks with DroidForensics. Mark ((cid:88)) means that the log from
that layer is needed to reconstruct an attack. “Full” means DroidForensics discover full attack behaviors, and
“Partial” means DroidForensics misses part of malicious behaviors.
Test
pakages
Access
Device
Core
Graphic
Native
Media
Contents
Other
Total
Nexus 6
Nexus 9
# of fails
Ori. Our
# of tests
# of fails
Ori. Our
# of tests
7
4
0
0
0
0
0
0
7
4
0
0
0
0
0
0
11
11
316
53
2,917
1,393
1,060
1,776
619
1,127
9,261
7
4
0
0
0
0
0
0
7
4
0
0
0
0
0
0
11
11
316
53
2,914
1,390
1,060
1,776
619
1,127
9,254
Table 3: Compatibility Tests. “Ori.” shows a num-
ber of failed tests with original Android and “Our”
shows a number of failed tests with DroidForensics.
Both failed the same set of test cases.
4.3 Compatibility
One may think that DroidForensics can cause compat-
ibility issues because it requires a modiﬁcation of Android
framework and an additional kernel module. To identify this
concern, we evaluate the compatibility of DroidForensics us-
ing Android Compatibility Test Suite (CTS) [2]. We use
the CTS-public-small plan which contains around 9,200 test
cases. The summarized results are in Table 3. In all tests,
DroidForensics and original Android failed on the same set
of test cases. We believe the failed cases are caused by device
environments, for instance both Nexus 6 and 9 do not have
external SD card and tests that try to access the external
storage failed. The results show that DroidForensics main-
tains the same compatibility-level to compare with original
Android.
5. DISCUSSION
In this section, we discuss limitations and future work of
DroidForensics. First, a kernel-level attacks could disable
DroidForensics. Although we periodically (e.g., every 10
minutes) transfer the log to the outer server, the attacker
can tamper with logs remained in the device. We believe
this is an on-going research area [51, 24] that is orthogonal
to the main focus of DroidForensics.
Second, our prototype uses openat() system calls to trans-
fer API and binder logs (see the section 3.1). If a malicious
application invokes openat() to trick DroidForensics, it can
introduce bogus causal relations (e.g., bogus binder edges in
the output graph), and it will make the investigation diﬃ-
cult. However, it only introduces false positives but cannot
hide true positives (i.e., malicious behaviors).
We also plan to mitigate this problem as following. We
will add a user-deﬁned system call with three arguments
9
674and use the ﬁrst argument as a secret session keys between
higher-level loggers and system call logger. We plan to build
a simple module that randomly assigns the key at boot-up
time to mitigate the vulnerability.
Third, our binder logger intercepts IPC/RPC in the native
binder library, libbinder.so. Both Java and native codes use
this library to invoke binder calls. However, native compo-
nents can directly invoke ioctl system calls to send binder
message to the binder driver in the kernel. We never observe
that in practice, but it is theoretically possible. Our binder
logger cannot capture them. To address this limitaion, we
can port the binder logger to the binder driver in kernel-
space, then we can capture all binder communications.
Finally, DroidForensics requires manual instrumentation
to Android API functions. In the future, we plan to develop
more automated techniques to determine instrumentation
points including important call-back functions and handlers.
For example, we can leverage DroidAPIMiner [16] to auto-
matically identify instrumentation locations from important
Android APIs, call-backs, and event handlers.
6. RELATED WORK
Forensic Logging: Tracking system-level dependence is a
popular technique for attack analysis in desktop and server
environments [43, 41, 18, 35, 44, 42, 53, 27]. They record
system events (e.g., system calls) during the execution and
interpret them to analyze causal dependences between sys-
tem subjects (e.g., process) and system objects (e.g., net-
work socket or ﬁle) to reconstruct an attack. Recently,
BEEP [45], ProTracer [49] and WinLog [48] propose tech-
niques that pro-actively analyze and instrument application
binaries to improve an accuracy of attack reconstruction.
They focus on logging system-level event in desktop or server
systems, however, it is not eﬀective in Android framework
due to it’s unique execution environment, Android Runtime
(ART), and binder IPC protocol. DroidForensics enables
logging in multi-layer to capture accurate information from
diﬀerent layers, and we provide easy-to-use user interface to
query them.
LogGC [46] proposes a garbage collection techniques for
forensic logs. It removes redundant or unnecessary events
from the log (e.g., accessing temporary ﬁles). In the future,
we plan to develop a similar technique for Android to fun-
damentally reduce the size of log.
Recently, Android attack reconstruction techniques have
been proposed. CopperDroid [63] proposes system-call log-
ging and analysis technique for Android attack reconstruc-
tion. CopperDroid is a VMI-based approach and it is built
on top of QEMU [22]. It provide a smart way to analyze
ioctl system call to understand semantics of binder pro-
tocol, but it requires buﬀer contents of each ioctl and it
might causes too much runtime and space overhead for real
devices. Furthermore, it could miss important events that
can be observed only in higher-layer (e.g., API).
DroidScope [66] is a QEMU-based malware analysis en-
gine that provides the uniﬁed view of hardware, kernel and
Android virtual machine (Dalvik). Unfortunately, Droid-
Scope’s analysis engine for Dalvik bytecode is infeasible for
recent Android ART environments. Furthermore, both Droid-
Scope and CopperDroid were build on top of QEMU [22] em-
ulator and it generally incurs high overhead. DroidForensics
supports ART environments, and does not rely emulated en-
vironments but directly works on real devices.
Quire [30] monitors Android binder calls to detect con-
fused deputy problem. It track privileges across inter-process
boundaries. Grover et al. [38] propose an application-level