原文链接：
# 仅用一个字节攻击 Titan M
继我们在 Black Hat USA 上的演讲之后，在这篇博文中，我们将介绍 CVE-2022-20233 的一些详细信息，这是我们在 Titan M
上发现的最新漏洞，并且探究如何利用它在芯片上执行代码。
## 介绍
在过去一年半的时间里，我们（Damiano Melotti、Maxime Rossi Bellom 和 Philippe Teuwen）研究了 Titan
M，这是谷歌从 Pixel 3 开始在其 Pixel 智能手机中引入的一种安全芯片。我们在 [Black Hat EU
2021](https://www.youtube.com/watch?v=UNPblJup5ko)
上展示了研究成果，以及包含本研究第一部分中获得的所有背景知识的[白皮书](https://github.com/quarkslab/titanm/blob/master/BHEU_2021/EU-21-Rossi_Bellom-2021_A_Titan_M_Odyssey-wp.pdf)。在这篇博文中，我们将深入探讨
[CVE-2022-20233](https://nvd.nist.gov/vuln/detail/CVE-2022-20233)，这是在该芯片固件中发现的最新漏洞。首先，我们将展示如何使用
AFL++ 在 Unicorn 模式下基于仿真模拟进行模糊测试，来找到此漏洞。然后，我们将展示漏洞利用及其固有的挑战，最终我们在芯片上获得了代码执行。
## 背景
Titan M 于 2018 年由谷歌在其 Pixel
设备中推出。主要目标是减少攻击者可用的攻击面，减轻硬件篡改和侧信道攻击。事实上，该芯片位于设备中独立的片上系统 (SoC) 上，运行自己的固件，并通过
SPI 总线与应用处理器 (AP) 通信。它实现了多个 API，为智能手机最安全敏感的功能提供更高级别的保护，例如安全启动或带有 StrongBox
的硬件支持的 Keystore。
在这项研究的第一步中，我们专注于对 Titan M 固件进行逆向工程，该固件基于[嵌入式控制器
(EC)](https://chromium.googlesource.com/chromiumos/platform/ec/)，这是一种用于微控制器的轻量级开源操作系统。这个操作系统相当简单，并且是围绕任务（tasks）的概念构建的，具有固定的堆栈大小并且没有堆（因此没有复杂的动态分配）。这是重要的一点，稍后会证明是有用的：Titan
M 芯片本质上具有静态内存布局，因此我们可以假设某些对象始终位于同一地址。
保持操作系统的简单在安全方面也有帮助，特别是通过完全消除与动态分配相关的一些临时内存安全漏洞。此外，得益于其内存保护单元
(MPU)，芯片的内存不会同时对同一区域赋予写入和执行权限。另外，还通过在加载固件之前执行一些签名检查来实现安全启动。尽管具有这些特性，但除了在任务堆栈末尾放置硬编码的
canary 用于检测错误之外，在芯片上找不到其他常见的漏洞利用缓解技术。这使得 Titan M
相当容易受到内存损坏漏洞的影响，因此我们决定探索如何对其进行模糊测试以发现漏洞。
## 对 Titan M 进行模糊测试
众所周知，模糊测试常用于在不安全语言（例如
C）编写的代码库中查找内存损坏漏洞，是一种极其有效的方法。但是，在无法访问源代码且具有大量硬件相关代码的情况下，对安全芯片进行模糊测试非常有挑战。我们决定探索两种不同的技术，即黑盒模糊测试和基于仿真的模糊测试。
### 黑盒模糊测试
我们已经在之前的演示中展示了如何执行黑盒模糊测试，这里简要回顾一下，有助于理解它与其他方法的区别。通常，对 Titan M
这样的目标进行黑盒模糊测试非常简单：我们只需要一个与待测目标进行交互的渠道，以及一种判断它是否崩溃或达到意外状态的方法。在本研究开始之前，我们开发了一个自定义客户端
[nosclient](https://github.com/quarkslab/titanm/tree/master/nugget_toolkit/)，在
Android 上本地运行，并直接与负责与芯片通信的内核驱动程序进行通信。其发送任意消息的能力让我们可以与 Titan M
进行通信，并且通过库函数的返回码推断处理它们时发生了什么信号。
大多数与 Android 通信的任务使用 [Protobuf](https://github.com/protocolbuffers/protobuf)
来序列化消息。因此，我们可以利用开源项目
[AOSP](https://android.googlesource.com/platform/external/nos/host/generic/+/refs/tags/android-platform-12.1.0_r1/nugget/proto/nugget/app/) 中的语法定义，通过 [libprotobuf-mutator](https://github.com/google/libprotobuf-mutator) 来变异这些消息。对于 Android
N，其中一项没有使用 Protobuf 的任务，我们使用 [Radamsa](https://gitlab.com/akihe/radamsa/)
来生成测试用例。
这种方法确实带来了一些有趣的结果，就模糊测试而言，可以用漏洞数量来衡量。我们在对旧版本固件进行模糊测试时发现了几个已知的漏洞，包括去年研究期间利用过的缓冲区溢出漏洞。此外，在当时最新版本的固件中，我们还发现了两个崩溃问题，尽管两者都是由同一个空指针引用导致的，并未被认为严重到足以作为漏洞列入
Android 安全公告中。
尽管设置相对简单，并且具有在真实环境中进行测试的优势，但黑盒模糊测试也有许多缺点。首先，检测漏洞非常困难，因为我们只能发现导致崩溃或错误返回码的漏洞。但最重要的是，黑盒模糊测试往往只对目标的表面状态进行测试，因为无法看到它们的内部结构。因此，我们可能只触及了
Titan M 固件的表面，这也可以解释为什么所有检测到的崩溃都发生在模糊测试几分钟之后。
### 基于仿真的模糊测试
我们关注的另一种方法是基于仿真的模糊测试。简而言之，既然固件是公开可用的，为什么不尝试在笔记本电脑上模拟执行呢？根据我们从数小时的逆向工程中对其工作原理的了解，我们可以建立一个仿真框架来逐条运行固件指令，并分析其行为。对于覆盖率引导的
fuzzer 来说，这是一个很好的反馈，它可以对输入进行优先排序，从而到达新的指令，并相应地调整变异器。
有许多不同的方法可以实现此类解决方案。我们尝试了几种，但最终还是选择了 Unicorn 仿真器引擎和 AFL++ 作为模糊测试框架。Unicorn
是一个基于 QEMU 的项目，只支持 CPU
仿真，不支持全系统仿真。在我们的案例这是一个优势，因为我们可以非常容易地开发脚本，实现一些特定调整以提高漏洞检测或解决某些问题。此外，Unicorn 与
AFL++ 的集成非常好，这要归功于它的 unicorn 模式，基本上可以对所有可以用 Unicorn 模拟的东西进行模糊测试。唯一需要做的是定义
`place_input_callback` 函数，在每次交互时将输入写入目标内存中。
因此，我们还可以测试 Titan M 固件中的其他功能，同时也不忘合理的攻击场景。然而，对 SPI
功能进行了几次模糊测试都没有得到显著结果，我们决定再次关注 tasks，复制在黑盒环境中所做的类似实验。AFL++ 允许自定义变异器，因此我们再次插入
libprotobuf-mutator 并分别模拟固件的三个任务：`Keymaster`、`Identity` 和 `Weaver`。我们决定忽略
AVB，因为它暴露的攻击面很有限，且大部分交互都发生在设备处于引导加载程序模式时。
首先，我们需要再次找到已知漏洞，以证明这个新解决方案的有效性。幸运的是，答案是肯定的，只漏掉了一个漏洞，这也让我们意识到基于仿真的模糊测试的局限性。众所周知，天下没有免费的午餐，这种做法也带来了一些弊端。
  * 多个硬件相关的函数：这​​些代码部分不容易被模拟，因此我们不得不 hook 它们，这不可避免地降低了测试覆盖率。
  * 检测能力仍然有限：在改进纯黑盒方案的同时，我们仍然只能检测到导致 Unicorn 错误的漏洞，因此遗漏了各种页内溢出、off-by-one 等。
  * 缺乏完整的系统仿真：这种选择本身也会导致忽略某些功能，这意味着必然会遗漏一些漏洞。这就是为什么我们没有成功复现刚才提到的漏洞的原因。
为了解决第二个问题，Unicorn 允许设置一些自定义钩子来监视某些内存访问或特定的代码片段。我们实现了一些启发式方法来捕获某些错误模式，例如对
`memcpy` 的中断调用最终从 Boot ROM（映射到地址
`0x0`）中读取数据。然而，这是有代价的：钩子会影响性能，并且在识别这些模式所花费的时间与让 fuzzer 自由运行之间总是存在权衡。
## 漏洞分析
现在，让我们进入关键部分。在对 Keymaster 任务进行模糊测试时，我们发现了一个有趣的崩溃，该崩溃是由 `UC_ERR_WRITE_UNMAPPED`
在处理 `ImportKey` 请求时引起的。这个崩溃发生在 `strb` 指令中，意味着固件试图在未映射的内存区域中写入 1
个字节。请注意，易受攻击的固件是由谷歌 2022 年 5 月的 Pixel 安全更新引入的。
触发该漏洞的消息很简单，如下所示：
    ImportKeyRequest
    params {
      params {
        tag: ALGORITHM
        integer: 4
      }
      params {
        tag: DIGEST
        integer: 40706
      }
    }
    symmetric_key {
      material: "tag == 0x20005) {