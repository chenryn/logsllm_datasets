a CSRF token. It assumes that the attacker cannot extract
the session ID, so this ID can act as a random CSRF token.
However, with the assistance of screen sharing, the attacker
can easily read the page source. In such cases, using the
double submit cookies technique will not only break the CSRF
defense but also result in a session hijacking attack.
3) Best Practices for Users: There are a few ways for
users to mitigate screen sharing attacks, such as only using
trusted screen sharing websites with trusted users or logging
out of important accounts, although the latter may sacriﬁce the
usability of screen sharing. For example, the users need to log
out of their bank accounts before sharing the screen, and log
in again after the screen sharing session is terminated. These
repeated activities are usually not preferable. Therefore, this
approach is not as effective as browser-based or website-based
solutions because it heavily depends on user actions.
VI. RELATED WORK
CSRF Attacks and Defenses. Basic CSRF attacks have been
known to the community for several years. For these sites that
are already vulnerable to basic CSRF attacks, the screen sharing
API is not required to compromise the account. These sites
are out of scope for our paper. Our CSRF attack focuses on
the websites that implement the most popular CSRF defenses.
Past studies show various techniques of stealing the CSRF
tokens; however, these methods have limitations. E. Vela [19]
demonstrates a heavy-load CSS-only attribute reader by using
attribute-selectors. However, it is not practical to read CSRF
tokens with high entropy within a short period. Heiderich et
al. [20] propose another CSS attack by using features such as
web-fonts based on SVG and WOFF, CSS-based animations
and the CSS content property to extract CSRF tokens. This
attack requires around 100 HTTP requests, whereas screen
sharing attacks can steal CSRF tokens easily. In addition, their
attack focuses on CSRF token protected links, so the attack will
not work in the scenario where the CSRF token is not attached
to the links. In contrast, the attack using the screen sharing
API can extract any CSRF tokens, irrespective of whether the
X-Frame-Options are set or not by the target page. A recent
work on CSRF is implemented against Facebook [21]. The
author proposes to frame the Facebook pages not protected by
X-Frame-Options such as plugins, and then generate a captcha
from the CSRF token. The attacker has to trick the user to
input the captcha to get the CSRF token. The attack needs to
interact with the user multiple times such as requesting user
permission for the plugin and asking the user to input the CSRF
token. Note that the screen sharing attack does not need such
information.
There have been multiple proposals for CSRF defenses.
SOMA [22] and App Isolation [23] provide CSRF defenses
by deﬁning valid entry points for the website. This can protect
against the CSRF attacks using the screen sharing API, but
46
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:26 UTC from IEEE Xplore.  Restrictions apply. 
it is infeasible to whitelist every entry point. Moreover, the
web relies heavily on interlinks, so these solutions were not
widely adopted. Gazelle [24] and Tahoma [25] provide cookie
isolation between different apps, which also protect them from
CSRF attacks. However, the strict isolation has some usability
issues. et al. [14] investigate current CSRF defense methods
such as CSRF tokens, Referer header validation, and custom
header, and also propose an approach of checking the origin
of request. According to their study, the CSRF token, which
is the most popular defense, is reliable if well implemented.
However, we ﬁnd that the CSRF token defense does not work
during screen sharing because the attacker can read the CSRF
token directly. Mao et al. [26] propose a defense by inferring
if a request reﬂects a user’s intentions. To judge the intentions,
Mao et al. suggest checking Source-set of a request, which
includes its referer and all web pages hosted in ancestor
frames of the referer. However, referer information can be
manipulated by the attacker and sending referer information
also raises privacy concerns.
Frame Busting. Rydstedt et al. [15] propose best practices
for writing frame busting code in JavaScript, which was
used widely before the X-Frame-Options were adopted. A
survey about frame busting techniques show that most of
these techniques are not reliable and can be bypassed. We
ﬁnd that around 55 percent of the Alexa top 100 websites
are using X-Frame-Options, but it is tricky to add the option
to all the sensitive web pages within a domain. For screen
sharing attacks, even if proper frame busting techniques and
X-Frame-Options are used, we can still use pop-up windows
to open target sites and steal sensitive information.
XSS. XSS is a common approach to stealing a user’s sensitive
information [27]. If malicious JavaScript is allowed to be
executed within target sites, the attacker can access content
from those sites. Many XSS defenses [28] [29] [30] are
adopted to defend against XSS. However, the defenses are
still vulnerable in the context of screen sharing. The defenses
would not hinder the attacker from accessing the user’s
information because the attacker can directly see the user’s
information from the screen.
History Snifﬁng. History snifﬁng attacks discovered in
the past were based on reading the difference between the
rendered color of the visited and unvisited links using CSS and
JavaScript [20] [31] [32] [33]. However, the vulnerabilities
that allowed such attacks were ﬁxed by browser vendors
because of the prevalence of the attack vectors. David Baron
from Mozilla [34] proposed a defense such that the true status
of the link, whether it is visited or not, is never revealed to
JavaScript. However, the links are still rendered with different
colors on the screen. It was assumed that this differentiation is
only visible to the user but the screen sharing API enables the
attacker to capture the screen directly to observe the color of
the links.
Screen-Capture Attack. To the best of our knowledge,
previous work related to attacks that steal the user’s screen are
limited to only stealing credentials. For example, [35] talks
about stealing the password while it is being entered through
the virtual on-screen keyboard. However, their assumption
for user is stronger than us. We assume that the user will
not input any sensitive information while his screen is being
shared, which is more reasonable.
Vulnerabilities of other HTML5 APIs Apart from the screen
sharing API, there are other HTML5 APIs utilized to perform
web attacks. One of such vulnerable APIs is the fullscreen API
that allows developers to trigger the web page to be displayed
in a full screen. By using the API, malicious web applications
are able to launch phishing attacks with fake UI of target
sites [36]. Another example is the postMessage API which
aims to provide authenticity and conﬁdentiality for cross-origin
communication. The API is broken because developers fail to
follow its complicated practices [37].
VII. CONCLUSION
The new screen sharing API enables developers to create
rich web applications that can share media in real-time.
However, the new API affects the fundamental browser security
principle of the same-origin policy by creating a feedback loop
from the user to the server. We have analyzed the security
concerns raised this new screen sharing API. We discussed
how it allows viewing cross-origin content and how attackers
can exploit it. As a result, the integrity and conﬁdentiality of
user’s information is at risk since attackers can manipulate
the victim’s session state with a trusted website, and view the
victim’s sensitive information. The browser vendors should
analyze the possible impact on user’s security before releasing
this API in stable versions. Users need to be aware of the
various security and privacy concerns raised by this new API
so that they can protect themselves from leaking information to
malicious screen sharing services. In summary, the capabilities
of the new HTML5 screen sharing API have rendered existing
security methods vulnerable. To counter those vulnerabilities,
this paper provides a new paradigm for understanding screen
sharing attacks. We envision that our study will encourage
further research to ﬁnd solutions for browser vendors, web
developers, and users to defend against screening sharing attack.
ACKNOWLEDGMENTS
We thank the Google Chrome team members, Adam Barth,
Justin Schuh, Adrienne Porter Felt, Mustafa Emre Acer, James
Weatherall, Victoria Kirst and Sergey Ulanov for their guidance
on this topic. We also thank Sid Stamm and Daniel Veditz
from Mozilla for their feedback. We also thank our colleagues
and friends, Eric Y. Chen, David Liu, Emmanuel Owusu, Brian
Ricks and Mike Xie for their suggestions.
REFERENCES
[1] Google Inc, “Google voice and video chat,” 2013, https://www.google.
com/chat/video.
[2] WebRTC, “Web real-time communications working group,” 2013, http:
//www.w3.org/2011/04/webrtc/.
47
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:26 UTC from IEEE Xplore.  Restrictions apply. 
[26] Z. Mao, N. Li, and I. Molloy, “Defeating cross-site request forgery
attacks with browser-enforced authenticity protection,” in Financial
Cryptography and Data Security. Springer, 2009, pp. 238–255.
[27] M. Jakobsson and S. Stamm, “Invasive browser snifﬁng and countermea-
sures,” in Proceedings of the 15th international conference on World
Wide Web. ACM, 2006, pp. 523–532.
[28] P. Saxena, D. Molnar, and B. Livshits, “Scriptgard: Preventing script
injection attacks in legacy web applications with automatic sanitization,”
Citeseer, Tech. Rep., 2010.
[30]
[29] S. Stamm, B. Sterne, and G. Markham, “Reining in the web with content
security policy,” in Proceedings of the 19th international conference on
World wide web. ACM, 2010, pp. 921–930.
J. Weinberger, P. Saxena, D. Akhawe, M. Finifter, R. Shin, and D. Song,
“A systematic analysis of xss sanitization in web application frameworks,”
in Computer Security–ESORICS 2011. Springer, 2011, pp. 150–171.
[31] C. Jackson, A. Bortz, D. Boneh, and J. C. Mitchell, “Protecting browser
state from web privacy attacks,” in Proceedings of the 15th international
conference on World Wide Web. ACM, 2006, pp. 737–744.
[32] D. Jang, R. Jhala, S. Lerner, and H. Shacham, “An empirical study of
privacy-violating information ﬂows in javascript web applications,” in
Proceedings of the 17th ACM conference on Computer and Communi-
cations Security. ACM, 2010, pp. 270–283.
[33] A. Janc and L. Olejnik, “Web browser history detection as a real-world
privacy threat,” in Computer Security–ESORICS 2010. Springer, 2010,
pp. 215–231.
[34] L. D. Baron, “Preventing attacks on a user’s history through css :visited
selectors,” 2010, http://dbaron.org/mozilla/visited-privacy/.
[35] A. Parekh, A. Pawar, P. Munot, and P. Mantri, “Secure authentication us-
ing anti-screenshot virtual keyboard,” International Journal of Computer
Science Issues(IJCSI), vol. 8, no. 5, 2011.
[36] Feross Aboukhadijeh, “Using the html5 fullscreen api for phishing
attacks,” 2012, http://feross.org/html5-fullscreen-api-attack/.
[37] S. Hanna, R. Shin, D. Akhawe, A. Boehm, P. Saxena, and D. Song,
“The emperor’s new apis: On the (in) secure usage of new client-side
primitives,” in Proceedings of the Web 2.0 Security and Privacy.
IEEE,
2010.
[3] WebRTC, “Webrtc general overview,” 2013, http://www.webrtc.org/
reference/architecture.
[4] WebRTC, “Webrtc interop notes,” 2013, http://www.webrtc.org/interop.
[5] V. Roth, K. Richter, and R. Freidinger, “A pin-entry method resilient
against shoulder surﬁng,” in Proceedings of the 11th ACM conference
on Computer and communications security. ACM, 2004, pp. 25–29.
[6] Google Chrome, “Chrome autoﬁll forms,” 2013, http://support.google.
com/chrome/bin/answer.py?hl=en&answer=142893.
[7] Google Inc, “Stable channel update,” 2013, http://googlechromereleases.
blogspot.com/2013/07/stable-channel-update.html.
[8] E. Bidelman, “Chrome extension api with binary websocket,”
2012, http://www.html5rocks.com/en/tutorials/streaming/screenshare/
#toc-method3.
[9] E. Bidelman, “Screensharing a browser tab in html5?” 2012, http://www.
html5rocks.com/en/tutorials/streaming/screenshare.
[10] E. Bidelman, “Capturing audio & video in html5,” 2012, http://www.
[11]
html5rocks.com/en/tutorials/getusermedia/intro/.
J. Grossman,
2010,
breaking-browsers-hacking-auto-complete.html.
“Breaking
browsers: Hacking
auto-complete,”
http://jeremiahgrossman.blogspot.com/2010/08/
[12] A. M. Lits,
“Apple-sa-2010-07-28-1 safari 5.0.1 and safari
4.1.1,” 2010, http://lists.apple.com/archives/security-announce/2010//Jul/
msg00001.html.
[13] Bugs@Mozilla, “Bug 527935 - (cve-2011-0067) untrusted events should
not trigger autocomplete popup,” 2009, https://bugzilla.mozilla.org/show
bug.cgi?id=527935.
[14] A. Barth, C. Jackson, and J. C. Mitchell, “Robust defenses for cross-
site request forgery,” in Proceedings of the 15th ACM Conference on
Computer and Communications Security, 2008.
[15] G. Rydstedt, E. Bursztein, D. Boneh, and C. Jackson, “Busting frame
busting: a study of clickjacking vulnerabilities on popular sites,” in Web
2.0 Security and Privacy, 2010.
[16] Bugzilla@Mozilla, “Bug 624883- iframe with src=”view-source...”
should be treated as an unknown scheme,” 2014, https://bugzilla.mozilla.
org/show bug.cgi?id=624883.
J. Grossman, “Proof-of-concept: Safari autoﬁll attack,” 2010, http://ha.
ckers.org/weird/safari autoﬁll.html.
[17]
[18] OWASP, “HTTP csrf cheat sheet,” 2013, https://www.owasp.org/index.
php/Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet.
[19] E. Vela, “Css attribute reader proof of concept,” 2011, http://eaea.
sirdarckcat.net/cssar/v2/.
[20] M. Heiderich, M. Niemietz, F. Schuster, T. Holz, and J. Schwenk, “Script-
less attacks: stealing the pie without touching the sill,” in Proceedings of
the 2012 ACM Conference on Computer and Communications Security.
ACM, 2012, pp. 760–771.
[21] Crazyﬂx,
“Own
friends walls
facebook
of
silently
wall
your
to
http://www.blackhatworld.com/blackhat-seo/facebook/
597969-own-facebook-exploit-silently-post-wall-friends-walls-visitors-your-site.
html.
exploit
visitors
post
site,”
to
the
2013,
-
[22] T. Oda, G. Wurster, P. C. van Oorschot, and A. Somayaji, “SOMA:
mutual approval for included content in web pages,” in Proceedings of
the 15th ACM conference on Computer and Communications Security,
2008.
[23] E. Y. Chen, J. Bau, C. Reis, A. Barth, and C. Jackson, “App isolation:
get the security of multiple browsers with just one,” in Proceedings of
the 18th ACM Conference on Computer and Communications Security.
ACM, 2011, pp. 227–238.
[24] H. J. Wang, C. Grier, A. Moshchuk, S. T. King, P. Choudhury, and
H. Venter, “The multi-principal os construction of the gazelle web
browser,” in USENIX Security Symposium, 2009, pp. 417–432.
[25] R. S. Cox, J. G. Hansen, S. D. Gribble, and H. M. Levy, “A safety-
oriented platform for web applications,” in Security and Privacy, 2006
IEEE Symposium on.
IEEE, 2006, pp. 15–pp.
48
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:01:26 UTC from IEEE Xplore.  Restrictions apply.