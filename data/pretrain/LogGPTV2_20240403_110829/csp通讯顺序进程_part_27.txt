(Xsat(T(n,x)→R))>((Q;X)sat(b=→(r(n+1,x)
(≥) *(q:=q +1,r:=r-y) sat(y>0>DIVL00P)
(bQ) sat ((n.T(n,x))>R)
Qsat(P(x)Atr≠<>→tr=AR(x,x))
Axu>1=(u)L
(u)L'uE
y>0
，第二部分也是更困难的部分
>R)))
（1)
口
---
## Page 208
由第一个运算对象完成第一个动作
终止。若终止，则其终止状态传于第二运算对象。若不终止，则
赋值稍微复杂些。
不讨论e在状态s中无定义的情形。这里，只实施单个赋值，多重
而eval（e,s)是在状态8r，计算表达式e所得结果。
其中 update(s,x,e)=Ay.if y=x then eval(e,s) else s(y)
而将初始状态作为终止状态，故
为它的变元的终止值，而不是另一个进程。
原子动作"SUCCESS。终止的进程就接受这个符号；并将它映象
顺序进程则是由初始状态至后续行为的函数。成功终止则表示为
5.5.3
处理通信顺序进程时，更易接受这种记法了。
使得记法较笨拙。但这种额外负担是必要的，把这种方法扩充到
法，数学上是等价的，但是用了“tr=<>”和“tr=”，这就
这里wp是Dijkstra的最弱前置条件。
初值x，断言（1)就等价于
sequence(P,Q) =
assign(x,e)=As.Ay.if y≠"SUCCESS then "BLEEP
在实施顺序组合时，必须先检验第一个运算对象，看其是否
进程SKIP以初始状态为参数，以"SUCCESS为仅有的动作
As.if P(s)("SUCCESS)-≠"BLEEP then Q(P(s)
赋值进程与其相似，但需改变终止状态值，有
SKIP =As.Ay.if y≠"SUCCESS then "BLEEP else s
顺序进程的初始和终比状态可用变元名至其值的函数表示。
考虑非通信程序时，本章中的证明方法和已经熟知的一些方
实施
P(x)→wp(Q,R(x))
else update(s,x,e)
("SUCCESS))
185
---
## Page 209
之用以前介绍过的概念来定义程序变元，会更合理些。
应考虑效率；引人可赋值的程序变元作为一个新的基本概念，比
机存取存储，其效率大为降低。除了考虑数学处理的方便外，还
些。简单的方法是用附庸进程来模拟变元；但比之使用传统的随
量值。前面章中各算子的定义都应作相应修改，变得更为复杂
状态s作为第一个参量，而且它还需向它的运算对象提供状态：
循环进程(b*Q)的实施留作练习。
186
上选的sequence 的定义比之5.3.3节中的定义更复杂，它以
condition(P,b,Q) = As.if eval(b,s) then P(s) jise Q(s)
条件进程的实施为
else Ay.if P(s)(y)= "BLEEP then"BLEEP
else sequence(P(s)(y),Q)
---
## Page 210
个进程独立地使用（m:R)，它们和（m：R）的交互作用是穿插进行
不是它们三者的同时参予。（m：R）就象是P和Q的共享资源：每
递相同的消息，而这和所要的效用相距甚远（参见4.5节X6）。我
使用同样的通道和(m:R)通信；因为由I的定义，P和Q使用它
假设S包含了或者恰好是两个并发进程（PIQ)，而且P和Q两者
务就是满足单个主进程S的需求；为此，我们使用记法
共享进程的个数和名称的资源共享技术。解释这一技术的例子都
多个并发子进程组成的。本章中要介绍一种适用于事先不必知道
进程的名字，也不适用于附庸进程，因为其主进程可能是由任意
通信动作可任意穿插进行。但这种方法也要求事先知道所有共享
的不同通道，用于共享进程和资源的独立通信。沿着这些通道的
的共享方法是用多重标记（见2.6.4节），它可有效地产生足够多
缓存，一个只使用它的左通道，而另一个只使用其右通道。一般
五人共享。4.5节X6也是一个这样的例子，出两个进程共享一个
这种技术：每把叉子由其相邻的两个哲学家共享，而男仆由他们
使用不同的通道和资源通信。就登哲学家的故事（2.5节）就使用
们所要的是，P与（m:R）及Q与（m：R）间的某种穿插式通信，而
们字母表中的公共通道和（m:R)通信时，要求P和Q两者同时传
都要求同一个附进程（m：R）为它们服务。那末，P和Q就不可能
的
如果事先知道哪些是共享进程，那就可以安排每个共享进程
在4,5节中我们介绍了带有名字的附庸进程（m:R)，它的任
第六章
6,1 
(m:R/S)
资源共享
 引 
信
187
---
## Page 211
得到的是应该另一个得到的回答。因为，为保证能免除这种危
此处的P和Q都可调用附庸进程，如包含有
间接通信，可以通过设计适当的共享的附进程来实现，见4.5
来自操作系统。
的。为方便起见，我们使用下列简写，在主进程中
现，但一个进程的一对通信是不会被另-一个进程的通信分割开
进程同时使用共享的子程序时，匹配的通信对以任意次序穿插出
调用记号很相象，只是值参数前冠以！，而结果参数前冠以？，即合
的记号，以保证遵从这个规则。这种记号和高级语言中传统的过程
信，都已严格地遵循交替出现的规则。看来，值得引进一种特殊
险，主进程中各子进程和共享的附庸进程在左，右通道上的通
尽管P及Q与附庸进程的通信可以任意穿插，但不会使其中一个
X1.
节X6和下面的X2。
插的。当然，这个算子不允许P和Q间的直接通信；-但它们间的
有相同的字母表，它们和外部（共享的）进程的通信则是任意穿
避免这个问题，可使用穿插式的并发性(P川Q)。其中的P和Q
188
子程序共享
6.1节中的问题出自使用组合子’表示进程的并发行为；为
下面的一系列代数变换解释穿插式共享的效果。当两个共享
举例
doubix?y=(doub,left!x--doub.right?y-SKIP)
(doub.left!v->doub.right?x-=SKIP)
doub: DOUBLE /(P IlQ)
dju表示d.leftiu
6.2 
x1p
表示
穿插式共享
d.right?x
---
## Page 212
而 P HQ=(d13→((d?y-→P(y)) I Q)
在附庸进程中
这代表
每个CLERK每为一名乘客订一张票，就调用一次
为简化了的例子，可用4.5节X8中实施的集合，作为共享的附庸
乘客，并且能告诉本乘客是否已经订过票，以免重订。对这个大
调用共享的子程序过程中，输出和输入动作必须严格地交替出现。
在等待输出，只有提供参量的进程才准备接收结果。从而可见，在
果提供给已准备接收结果的共享进程。由于两个共享进程之一仍
上逃推理用到4.5.1节L1,3.5.1节L5等。共享的进程将计算结
择动作后，就出现了非确定性
由共享的进程决定。由于它原意接受两者之任一，故屏蔽这一选
X2
每个共享进程都向共享的进程输出消息。
进程，并冠以航班号为进程名。
的订票工作穿插进行。每订一张票，就在航班旅客表中增加一名
(d:D/(PQ))=((d:(13+3-→D))/((dy→P(y))Q)）
R=(d:D/(PIQ))
Q=d!4-d?z-+Q(z)
P=d!3-→d?y-→P(y)
在预订机票系统中，订票工作是由很多售票员承担的，他们
数据结构共享
AG109:SET /(-(CLERK II CLERK I).)
[d!4-→(P(d?z→Q(z))))
= (d: D/(P(6) Q))(d: D/(PI Q(8)))
((((<)0+21p)d)/((q++1):p))L
7x
AG1091pass no?x
表示
表示
left?x
rightjv
至于接受哪个消息，则
由3.6,1节L7
（同于X1)
681
---
## Page 213
避免混淆，文件中不允许有整行的星号。故合
文件的最后一页的页末，和第一页的页头，都打印··行星号。为
开；打印机的硬件可执行操作走页（throw），这个操作使打印纸
打印纸按文件裁开。为此，打印纸以页计，页间用一行透纸孔隔
X4X3的一种改进
起来
在P或Q中，组成同一文件的各行以lp.acquire 和lp.release 括
资源，可出现于
号就恢复到最初的状态，再为其它进程服务。进程LP用作共享
进程·LP不断地从左通道向硬件成行地拷贝数据，但遇到释放信
此处，是将LP连至行式打印机硬件的通道。在获取事件后，
X3行式打印机共享
释放资源。
占用资源的权利；完成输出后，为使资源可供他人再使用，必须
为此，在输出一个文件前，必须先实现一个获取事件，由此得到
个多行组成的文件，在输出中，不会夹杂另一个进程输出的行。
共享一台非常昂贵的打印机。而每次使用时，要求连续地输出一
一系列通信，不希望第三个进程干预。例如，在很多并发进程间
可为两个进程中任一进程服务。我们有时要求两个进程间能实现
次发送参数，一次接收结果；在每对通信后，附庸进程又恢复为
区分不同文件的输出，文件应从页头开始，结束于页末，而且在
快速前进到当前页的页末一一打印纸的下·条外向折缝。为帮助
190
当行式打印机出多个用后共享时，在输出文件后，要将整条
在这两个例子中，使用一次共享资源恰好包括两次通信，
LP=acquire→μX.(left?s-→his-→X↓release→LP)
(AG109.left1pass n0-AG109.right?x-→SK1P)
lp.acquire-.ip.left!"A.JONES"..
Ip.left!nextline-..lp.release--..
Ip: LP...(P HlQ)...
---
## Page 214
安妮按某种菜谱做菜，先用锅，后用勺，而玛丽则先用勺后用
pot:UTENSIL/ pan:UTENSIL/ (ANN  MARY)
个妙勺，在她们需要时，就获取、使用和释放它们。
时，这种方式的共享可能会有死锁的危险。
的任意穿插，同时也不会引致死锁。但当共享的资源多于一-种
使用这个LP的方法同于上例。
抵达这些区城，只能沿着垂直边向上，或者沿着水平边向右。这
合用锅，故折线也不能通过有左上至右下影线的区域。折线一且
的区域，两个厨师要合用炒勺，故不可通过。类似地，由于不能
因此折线无法通过某些长方形地区。例如，在有右上至左下影线
图形的右上角，两位厨师都可享用她们的饭荣。
上的一条折线表示安妮和玛丽的一系列穿插动作。这条折线直达
系统向上移一-步。玛丽每完成一个动作，系统则向右移一步。图
角为起点，即作为她们的活动的开始处。安妮每完成一个动作，
的活动由纵坐标表示，而玛丽的活动由横坐标表示。系统以左下
但当她们需用第二个用具时，都没法得到，因为各被对方占用着。
不幸的是，她们决定同时做饭。她们都先获取各自的第一个用具；
锅，即
X5
安妮和玛丽的故事可用二维图形表示（见图6.1），图中安妮
上面的最后两例中使用了acquire 和release来防止不同行间
但不总是那样幸运的。她们不能同时使用同一个共享用具，
安妮和玛丽是好朋友，也都是好厨师；她们合用一口锅和一
死锁
LP=(h1throw-→hlasterisks-→aoquire-→hlasterisks-s
MARY = ...pan,acquire...pot,acquire-+..
μX.(left?s→if s≠asterisks then (his-X) else X
|release-→LP))
191
口
---
## Page 215
锁。用户还应在用完资源后立即释放，释放的次序是无关紧要
要规定所有用卢都按固定的相同次序获取资源，就可以避免死
的厨师，必须先获取炒勺。本例出自E.W.Dijkstra。
家共享四个就座权。另一种更简单的方法是，规定使用两种用具
节）中设置男仆的想法；可将就座权设想为一种资源，五个哲学
是一-种免除死锁的方法，这种方法类似于哲学家就餐故事（2.5.3
获取这--资源；而在两个用具都释放后，才能释放这一资源。这
性成为凸图。增加一种人为的资源，在获取任一用具前，必须先
发生的唯一可靠的方法是扩大禁区，使其包含危险区，即消除凹
的凹性造成的，而且是面向原点的凹性才会造成死锁。阻止死锁
避兔地要在区域的右上角处死锁。这个图形说明，死锁是由禁区
表示，其中的一位厨师等待另一位释放用具。
．·现在考察带有小点的区域。
192
上例中提出的简单方法，可推广到多用卢和多资源情形。只
potacquire -
pan.acquire
ANN
por.release +
pan.release f
pan.usr 4
F am'uod
MARY
mix
ServE
ca
+
1
It
acquire acquire
par.
1
por.
图6.1
一旦折线进人这一区域，就不可
1
. cur