might receive highly variable information, even though the underlying activ-
ity has remained constant — such a situation may make it diﬃcult to train
an anomaly detector or specify a complete signature.
– The converse of the previous point may also occur: Diﬀerent activities may
appear the same to a third party — consider a task such as reading a line
from a ﬁle, computing its hash and sending the hash to a remote system.
Leaving out the hashing step might not alter the audit trail recorded by the
operating system.
– Applications may provide their own protection subdomains and execution
environments. Security violations internal to an application may not be vis-
ible to a third party — for example attempts to escalate rights within a
database server may not generate any distinctive system calls, while a macro
virus attack might not generate any system calls at all.
We believe that instrumenting applications directly for the purpose of de-
tecting subversions has not yet been explored fully, and this is the motivation
for introducing the IDS/A interface.
1 The recommendation made by [16] suggests that individual audit records should be
selfcontained. Recording the ﬁle name (as well as ﬁle descriptor) to which a write()
is made would be in the spirit of that recommendation.
Interfacing Trusted Applications with Intrusion Detection Systems
43
5 Intrusion Response
One of the diﬃculties confronting the designers of intrusion detection systems is
the matter of responding automatically to suspected intrusions.
On the one hand it is desirable to have the IDS respond automatically to
limit, isolate or even prevent an intrusion. On the other hand many alerts are
false alarms and responding in error may have undesirable consequences. For
example, it may provide an opportunity for an attacker to mount denial of
service attacks.
Unfortunately it appears that false positives are diﬃcult to eliminate entirely
from anomaly detection systems [2]. However, it should be possible to reduce the
costs of erroneous responses: Current intrusion responses are quite coarse and
crude — typically intercepting NIDS are limited to inserting ﬁrewall rules or
resetting open network connections.
We suggest using a direct interface between application and IDS to make re-
sponses more ﬁne-grained and less vulnerable to subversion — we aim to achieve
this by merging the functionality of reference monitor and IDS, making it pos-
sible for access control policies and availability requirements to modulate IDS
responses.
6 A Direct IDS to Application Interface
We propose a direct interface between IDS and application. The interface is in-
tended to provide an online IDS with direct access to the application (monitoring
by direct instrumentation, see Fig. 2).
Like the interface of the conventional Unix syslog or XDAS [23], our interface
is visible to the application programmer as a set of library calls. The library
functions are used by the application programmer to report security relevant
events.
However, unlike a logging interface which merely records past events, our
interface is a bi-directional interface designed to let applications submit pending
events or actions to the IDS for approval. The interface can thus be viewed as
an additional, external, voluntary reference monitor available to applications.
We believe that the bi-directional property has a number of signiﬁcant ad-
vantages:
– As the application awaits a reply from the IDS, it is no longer feasible to
overload the IDS in the hope of having it discard events still visible to the
target.
– It becomes possible to institute a fail-closed policy — when the IDS is un-
available, requests made by the application are simply denied.
– As pending, instead of past, activity is reported it becomes possible to pre-
vent intrusions by simply disallowing unauthorized actions. This allows for
highly speciﬁc responses to attempted intrusions which are diﬃcult to bypass
or subvert.
44
M. Welz and A. Hutchison
Initially it may seem counterintuitive to make an IDS an active component
visible to applications. In particular, concerns may be raised about the perfor-
mance implications of such an approach. However, with the exception of hard
real-time applications,2 we believe that the costs of including an IDS can be jus-
tiﬁed: A “fair-weather” IDS which is too slow to keep up with worst case traﬃc
is of limited use as an attacker may simply generate spurious traﬃc to overload
and so blind the IDS.
Real protection requires that every event be viewed by the IDS — integrating
the IDS into the infrastructure (and slowing the rest of the system down to the
speed of the IDS, if required) makes it possible to guarantee this.
The direct coupling of IDS to application may actually have lower overall
resource demands than a conventional intercepting IDS. A directly coupled IDS:
– uses the state information reported by the application, doing away with the
– does not need to perform message decoding/decryption, as this is done by
need to duplicate state
the application
– has to ﬁlter out less extraneous information as it is only consulted by an
application when necessary
The reference monitor characteristics of the interface make intrusion preven-
tion possible — a suspicious action is simply disallowed. This response is simple,
yet highly speciﬁc and diﬃcult to circumvent. Where the IDS is insuﬃciently
competent to act as reference monitor, it may simply allow all requests, turning
the interface into a synchronous logging subsystem.
6.1 Event Reporting
Our approach relies on the application to provide information to the IDS. We
deﬁne three types of information which the application should provide:
1. Credentials: The application needs to identify itself to the IDS in order
to have the IDS distinguish between diﬀerent applications and application
domains.
2. Domain speciﬁc information: This information and its semantics depend on
the domain which in which the application operates — a database server
would have a diﬀerent vocabulary to a mailer.
3. Domain independent information: This information remains unchanged
across application domains. It provides a fallback in case a given IDS lacks
the knowledge for a particular application domain.
We believe that a separation between domain dependent and independent
information is a reasonable approach to managing complexity. Designing a se-
mantics which covers all conceivable applications would be an enormous task,
2 Even if real-time response times are required, it may be possible to involve an IDS:
A pending action can be submitted to the IDS — if no response is received within a
ﬁxed period of time, the action is denied (if a fail-closed policy is active) or allowed
(in the case of a fail-open policy).
Interfacing Trusted Applications with Intrusion Detection Systems
45
and if ever completed would inevitably result in poor ﬁts, requiring application
designers to shoehorn the events reported into an awkward scheme. Instead we
have decided on a two tiered approach, leaving the domain dependent part en-
tirely to the individual application,3 and designing a simpler (yet still interesting)
domain independent security rating.
Requiring that an IDS have knowledge of the internals of an application is
a reasonable demand as this is how current misuse detection systems operate
— misuse detectors make use of deep domain knowledge to construct signatures
which are triggered by known attacks.
The domain independent security rating which we propose is an attempt to
have applications describe the security implications of their actions to an IDS. We
suggest that actions be rated according to their estimated impact on availability,
conﬁdentiality and integrity. The estimate consists of a severity and a conﬁdence
value. Additionally it may be possible to include information describing which
assets are aﬀected by such actions.
For example, a request made by an ftp server to process a NOOP instruction
sent by a client might be designated a low risk rating in all three categories,
while a DELE request to remove a ﬁle might carry a signiﬁcant risk to availability.
Such assessments should be reasonably straightforward and a good number of
application programmers should be able to rate the actions of their applications
on such a scale. It may also be possible to involve the security designations or
labels associated with the entities aﬀected by such actions. For example, allowing
the transfer of a Unix ﬁle not globally readable might carry a greater risk of
breaching conﬁdentially than one accessible to all local users.
Such a security rating provided by those who design and implement trusted
applications may be useful in a number of tasks:
– Anomaly detection systems may be able to use the ratings to guide their
feature selection or data reduction components.
– Automated response policies can include availability costs, and base their
decisions on the tradeoﬀ between availability and integrity or conﬁdentiality.
– The ratings themselves may be useful to an IDS — for example an increase
in the number of events with higher than usual threats to conﬁdentiality
might indicate that the system is under reconnaissance by an attacker.
While the rating system has been kept simple deliberately in order to make
it accessible to application programmers, it is suﬃciently powerful to express the
tradeoﬀs between availability on the one hand, and conﬁdentiality and integrity
on the other which underlie the ﬁeld of computer security. The rating system
makes it possible to specify this tradeoﬀ for individual applications — some, like
mail, are essential and need to be available despite large risks, others, such as
anonymous ftp, can be suspended by the IDS at the ﬁrst sign of intruder activity.
3 We do provide a means whereby related applications can use a common event sub-
space or scheme with agreed upon structure and semantics.
46
M. Welz and A. Hutchison
7 IDS/A: Implementation
We have built an experimental platform which implements some of the concepts
set out in the previous section. While the implementation is still volatile and
likely to be reworked, parts of it have been running on a number of workstations
and servers in operational use for about a year.
Architecturally our implementation resembles the conventional Unix system
logger. Like syslog our system consists of a set of library functions linked to
applications and a central daemon idsad which collects events from applications.
Like syslogd, idsad communicates with applications via a Unix domain socket,
and messages consist of a set of label value pairs similar those proposed by [4,1].
Unlike syslog, our interface is bi-directional, allowing idsad to act as reference
monitor for applications.
passwd,
login
pam
idsa
native 
applications
apache
mod
idsa
idsasyslogd
idsarlogd
idsad.conf
idsad
idsa modules
in.somed
idsatcpd
inetd
idsatcplogd
IDS/A interface
idsaguile
log file
idsaexec
idsapipe
idsapipe
ogg123 Klaxon.ogg
smbclient −M deskpc
mail −s logs root
Fig. 3. Selected IDS/A Components
idsad, in its current version, is primarily a misuse detector — signatures
are speciﬁed using a simple rule language resembling that of a stateful ﬁrewall.
However, we do provide a plugin interface which can be used to load additional
detection modules at runtime, including anomaly detectors.
7.1 Performance Issues
Interprocess communication between idsad and application imposes a perfor-
mance penalty — we have attempted to reduce this impact by shifting the in-
trusion detection components into the application context/process space when
Interfacing Trusted Applications with Intrusion Detection Systems
47
appropriate. This approach bears some resemblance to the one used by [10] to
manage distributed applications.
The detection components running inside the application may either be used
as a ﬁlter to select only interesting events to forward to idsad, or may be used
to have the application perform its own autonomous intrusion detection, access
control and logging — see Fig. 4. The modules performing these tasks in the
application context are the same shared objects which are used by idsad. As all
this activity occurs inside IDS/A library calls, it is transparent to the application
and an application may be instructed to switch from reporting to idsad to
operating autonomously on the ﬂy.
application
libidsa
Thin library
libidsa
idsa plugins
idsad
application
libidsa
idsa plugins
libidsa
idsa plugins
idsad
Library prefilter
application
libidsa
idsa plugins
Autonomous library
unused idsad
Fig. 4. Shifting Intruder Detection into the Application Context
Using a simple, synchronous API implemented as a shared library also makes
it possible to substitute alternative implementations without needing to mod-
ify an already instrumented application. Such substitutions could be made to
implement future extensions, for example it might be interesting to support dis-
tributed detection and policy management across diﬀerent hosts or architectures
(scaling up) or implement a lightweight highly-speciﬁc library for an embedded
appliance system (scaling down).
8 Example Applications
We have directly instrumented a number of applications to use idsad as reference
monitor. Amongst others:
48
M. Welz and A. Hutchison
– Apache using a module mod idsa to request permission to process HTTP
– Two experimental ftp servers which allow idsad to monitor and block indi-
requests.
vidual ftp requests.
– Applications performing access control such as login, xdm or xlock using a
pluggable authentication module [21] which reports authentication requests
to idsad for approval.