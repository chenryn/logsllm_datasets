The second use case of CSP is to ensure that no content
is loaded via HTTP on HTTPS sites. In this section, we ﬁrst
report on how the different means of achieving that goal have
evolved over the course of time, and then report speciﬁcally
on how they were successfully used for TLS migration.
A. Evolution of TLS Enforcement
Figure 8 reports on the trend of deployed CSPs for TLS
enforcement. As we ﬁrst saw policies speciﬁcally tailored to-
8
01002003004005002016201720182019# of sitesTLS EnforcementUpgrade Insecure RequestsHSTSBlock Mixed ContentWhitelist HTTPS schemawards TLS enforcement in 2016, we omit the data before 2016.
We observe a steady increase in the usage of CSP for TLS
enforcement from December 2016 onwards. Most notably, the
enforcement is not pushed forward by exclusively whitelist-
ing HTTPS sites, but rather by the upgrade-insecure-
requests directive. Full support for this CSP feature ﬁrst
landed in browsers around March 2015 (with Chrome 43 [52]),
meaning site operators did not deploy the directive until about
1.5 years after it became available. The related directive to
block all mixed content has also increased in usage, but only
sees adoption on a fraction of sites compared to upgrade-
insecure-requests. Notably, we found that 51 sites
make use of both directives in December 2018, even though
in modern browsers block-all-mixed-content in the
presence of upgrade-insecure-requests is effectively
a no-op because the upgrade to HTTPS happens ﬁrst. We ﬁnd
the decreasing number of sites deploying CSP for TLS en-
forcement in December 2018 is not a downward trend; a brief
check for January 2019 shows that usage keeps increasing.
Figure 8 also compares the usage of a policy aimed at
ensuring that no content can be loaded over HTTP with the
usage of the HTTP Strict Transport Security (HSTS) header
on those sites. The HSTS header is set to ensure that once a
site has been visited over HTTPS, it cannot be loaded over
HTTP until a speciﬁed timeout occured [16]. In contrast, the
CSP directives ensure that any resources that are included
by the original site will be loaded over HTTPS. We ob-
serve that alongside the increasing deployment of upgrade-
insecure-requests, the fraction of sites using HSTS also
rises. Notably, of the 450 sites that enforced transport security
with CSP in December 2018, 267 made use of HSTS (59%).
This uptake in HSTS adoption is a positive trend in line with
the more widespread use of HTTPS on the Web [35].
Considering the 347 of those sites enforcing TLS explic-
itly via upgrade-insecure-requests, 194 made use
of HSTS. This provides us with an interesting insight: the
upgrade-insecure-requests directive is deployed to
ensure that once the connection has been securely established,
no resources or other URLs can be accidentally loaded via
HTTP. HSTS, in contrast, is used to ensure that the site cannot
be loaded via HTTP in the ﬁrst place. While for a secure setup,
both mechanisms are desirable, deploying HSTS comes with a
loss of control for the operator. Once a client has observed the
HSTS header, it will refuse to connect to the site via HTTP for
a set amount of time controlled by the received HSTS header.
Given that activating HSTS is no more complex than shipping
upgrade-insecure-requests we posit that its absence
by half of the sites using the directive has more to do with the
developers being uncomfortable fully giving up HTTP than
with issues regarding HSTS setup and deployment.
B. Leveraging CSP for TLS Migration
While one of the goals of CSP is to enforce TLS, it also
provides a meaningful aid for developers when migrating to
HTTPS. When mixed active content is detected by the browser
while visiting an HTTPS site, it is automatically blocked.
However, upgrade-insecure-requests instructs the
browser to gracefully upgrade the connection, rather than
blocking all HTTP resources, which is particularly useful if
an HTTPS site still contains references to HTTP-based active
Fig. 9: Evolution of X-Frame-Options and frame-ancestors
content (like scripts). To understand which sites leveraged
this added beneﬁt of CSP, for each of the 347 sites that
deployed upgrade-insecure-requests within the last
month of our analysis, we determined when each started to
use the directive. Subsequently, we downloaded the snapshots
for those site’s main pages from the IA for 31 days after the
ﬁrst upgrade-insecure-requests deployment.
Based on the snapshots we collected before upgrade-
insecure-requests was deployed, we ﬁnd that 251
(72.3%) sites deployed the directive as part of a transition
to HTTPS. We base this observation on the archived URL,
which indicates if the site had been loaded via HTTPS by the
Archive’s crawlers. For those sites, we parsed the HTML of all
collected snapshots once upgrade-insecure-requests
was deployed and extracted the URLs of external scripts, im-
ages, frames, and stylesheets. On 77 sites, we found that within
a month from originally deploying upgrade-insecure-
requests, resources were still linked via HTTP. Among
these sites, we found high-proﬁle pages such as wired.com,
airasia.com, and aol.com. For those three sites, we
further investigated how much longer they linked to HTTP
resources, downloading all snapshots until December 31, 2018.
For Air Asia and AOL, on the last day of our experiment,
there was still one HTTP resource on their main page, even
though both sites moved to HTTPS in 2017. Wired, which
started deploying HTTPS in June 2016, removed the last HTTP
resource from the start page only in September 2017.
Overall, these results strongly indicate that upgrade-
insecure-requests is a useful mechanism and therefore
widely used when a site migrates to HTTPS, highlighted by
the fact that more than 70% of sites deploying upgrade-
insecure-requests for the ﬁrst
time did so as part
of their move to HTTPS. In addition, 77 sites still made
use of HTTP-linked resources after their move to HTTPS:
upgrade-insecure-requests allowed these sites to
function correctly due to the graceful upgrade to HTTPS.
VII. CSP FOR FRAMING CONTROL
This section presents our historical ﬁndings for the third use
case of CSP, i.e., framing control. In particular, we investigate
to what extent CSP’s frame-ancestors has achieved its
goal of deprecating the underspeciﬁed XFO header, by ana-
lyzing sites that leverage its ﬂexibility, sites that deploy both
headers, and highlighting numerous cases in which frame-
ancestors would be required to achieve proper protection.
A. Evolution of CSP for Framing Control
As discussed in Section II, XFO was not standardized
before it was put into browsers, leading to inconsistent en-
forcement, which in turn enabled double-framing attacks. This
is why CSP removes any ambiguity and checks all of a frame’s
9
01000200030002012201420162018# of sitesX−Frame−OptionsCSP frame−ancestorsBothancestors. The high-level overview of our analysis on the use
of CSP for framing control against XFO is shown in Figure 9.
We observe a steady increase in the usage of XFO until the
end of our analysis in December 2018. In that month, 3,253
sites made use of XFO, whereas only 409 used frame-
ancestors. Moreover, out of the sites that use CSP for
framing control, 270 do so in combination with XFO. In the
following, we ﬁrst analyze to what extent the ﬂexibility of
frame-ancestors is used by sites, i.e., we determine if the
same whitelist could also be expressed with XFO. Second, for
those sites that make use of both CSP and XFO for framing
control, we analyze how the goals of the deployed headers
differ. Finally, we report on how many sites would have to
move to CSP to achieve universal protection.
1) Leveraging the Flexibility of CSP: The protection of-
fered by XFO is coarse-grained both because of the small
number of conﬁguration options, but also because of Google
Chrome’s decision (shared by all Chrome-based browsers) to
not support the ALLOW-FROM directive. As part of our analy-
sis, we wanted to determine which sites needed the additional
ﬂexibility offered by CSP’s frame-ancestors directive.
We aggregate these by year, as this shows a clearer trend
compared to monthly analyses. The result is shown in Table IV.
We ﬁnd that starting from 2015 when a meaningful number
of sites adopted frame-ancestors (shown as CSP-FA), at
least 50% of them required the ﬂexibility of CSP. For those, we
ﬁnd that the most common pattern is whitelisting all origins
from the same site (104 of 321 in 2018). Moreover, manual
investigation of the remaining cases showed that CSP was
often used to whitelist sites from the same company (e.g.,
icloud.com allows to be framed from *.icloud.com
and *.apple.com). Hence, apart from delivering different
XFO headers depending on the Referer or Origin header, these
sites could not run uninhibited without frame-ancestors.
2) Combining XFO and CSP frame-ancestors: When an
XFO header and a CSP frame-ancestors directive are
both set, CSP-compatible browsers are supposed to ignore
XFO. However, in older browser versions, XFO was the only
mechanism to protect users from clickjacking. Based on this
insight, we compared the semantics of XFO and frame-
ancestors (CSP-FA) in cases where both were present,
so as to understand how site operators dealt with different
browsers. Over the whole period of time, 394 Web sites made
use of both XFO and frame-ancestors at
least once
on the same day. Out of those, 290 did so inconsistently
at
i.e., XFO and CSP were not semantically
equivalent (e.g., did not combine SAMEORIGIN and self).
On 70 sites, frame-ancestors was used to relax the
security boundary from the same origin to the same site, e.g.,
https://site.com https://*.site.com, while the
XFO header was set to SAMEORIGIN. 185 sites used CSP (at
least once) to relax the security boundary even further than
the same site, leveraging SAMEORIGIN for older browsers.
Notably, these sites made the best of a bad situation, given
that browsers without support for frame-ancestors are at
least more secure than when XFO is absent. Only twice was
CSP used to deploy a more restrictive policy; speciﬁcally going
from the invalid XFO value ALLOWALL (essentially disabling
XFO) to whitelisting the site and all of its subdomains.
Here, the site operators opted for an insecure solution for
IE users, which is the only current browser that does not
least once,
Year
2014
2015
2016
2017
2018
Used CSP-FA
Required CSP-FA
13
60
133
260
460
3 (23%)
32 (53%)
92 (69%)
182 (70%)
321 (70%)
TABLE IV: Number of sites per year that set a frame-ancestors
directive, as well as number and fraction of sites that set policies not
expressible by X-Frame-Options
support CSP framing control. Finally, 65 sites deployed an
invalid XFO header alongside CSP at least once, e.g., by
using contradicting values like SAMEORIGIN, DENY, whose
semantics on legacy browsers is unclear.
3) Replacing XFO with CSP-FA: It is worth noting that
even though the double-framing attack is mitigated in most
browsers since 2017 [26], using directives that are not sup-
ported by all browsers (e.g., ALLOW-FROM for Chrome and
Safari) can have dangerous consequences. For those, setting
an ALLOW-FROM directive in XFO results in the header being
ignored completely (failing insecurely [18]). We found that
in December 2018, 116 sites in our dataset made use of a
non-universally supported directive, meaning the developers
would have to deploy CSP’s frame-ancestors to properly
secure their sites. Notably, of the 3,253 sites that use XFO in
December 2018, but not frame-ancestors, 362 already
deploy a CSP. Hence, even though these sites would merely
have to add a CSP directive to make use of a more ﬁne-
grained and consistent framing control, they still only resort
to the deprecated security header. While one could argue that
this might originate from old, outdated CSP policies, we ﬁnd
that 120 of these sites made use of upgrade-insecure-
requests: a directive that was only added after support for
frame-ancestors was enabled.
VIII.
IN-DEPTH ANALYSIS OF DEPLOYED CSPS
We now attempt to shed light on the main reasons which
may affect a successful adoption of CSP. First, we focus on
sites that gave up CSP and aim to attribute this choice to its
cause. Second, we highlight characteristics of sites which kept
running trivially insecure policies for content restriction, before
ﬁnally investigating sites which deployed effective policies.
A. Reasons for Giving Up on CSP
We start by investigating whether we can attribute changes
in the deployed CSPs to violations of said policies. Specif-
ically, we focus on those sites which tried out CSP in en-
forcement mode for at least one month, but gave up. We
deﬁne “giving up” as not having had a policy for a speciﬁc
use case in all of December 2018. This way, we lower the
risk of incorrectly ﬂagging a site for having given up just
because it did not have CSP for the last few days of 2018.
For each domain, we investigate the ﬁnal policy snapshot for
each use case, namely content restriction, TLS enforcement,
and framing control. Out aim is to understand why a given
domain stopped using CSP in a particular capacity.
1) Content Violations: CSP’s initial purpose was to restrict
the inclusion of content into a page. Hence, our ﬁrst analysis
focuses on sites that gave up this use case as per our earlier
deﬁnition. For each site, we determined the exact timeframe
10
for which the last policy was deployed. We then visited the
start page on the last day of policy deployment, following all
links to the same site that were archived in the timeframe of
the last deployed CSP. While all of our previous analyses relied
on downloading and statically parsing HTML documents, for
this experiment we relied on an instrumented Chrome browser.
This allowed us to not only determine if the resources statically
linked in the document caused violations, but also observe if
dynamically-added content interfered with CSP. We limited the
analysis to the ﬁrst level of links (in total, 3,347 URLs), as
this already required us to make an additional 421,684 requests
through loaded scripts, images, fonts, etc.
Overall, we found 63 domains which attempted content
restriction, but eventually gave up. For 15, we found violations
of the deployed CSP through dynamic analysis. When purely
relying on the resources statically linked in the HTML docu-
ment, only 7 sites indicated a violated CSP, which shows the
beneﬁts of the dynamic analysis. Unfortunately, the Archive
does not always manage to correctly rewrite URLs to included
resources, as shown by Lerner et al. [20]. Hence, it is likely that
even the more accurate dynamic analysis missed at least a few
violations, merely due to the fact that third-party code was not
even executed. Of the 15 sites with violations, we analyzed
which party included the violating resources. On 9 pages,
the violation was caused by third-party code, whereas on 8
they were caused by ﬁrst-party code, with an overlap of two
domains having both ﬁrst- and third-party-caused violations.
On the remaining 48 sites for which we could not ﬁnd
violations, we performed two analyses. First, since we cannot
reason about violations that are deeply hidden in the appli-
cation, we performed a live experiment on September 24,
2019, in which we crawled the live versions of all websites
in our data set. For sites with a CSP on the start page, we
randomly sampled 10 same-site subpages and checked their
CSPs. In doing so, we found that of the 1,202 sites with CSP
on the start page, 1,024 (85%) appear to have a site-wide
deployment of the same policy. Hence, assuming a similar
distribution of site-wide policy deployment for the archived
versions, the abandoning of site-wide policies may very well
be due to violations on pages other than the ones we crawled.
Eventually, we resorted to manually checking the deployed
policies to classify them, so as to provide an educated guess
about the reason for dropping CSP. For 25 sites, we found that
their policies showed increasing numbers of third-party entries
(e.g., milanoo.com and snai.it). For those, it is likely
that the overhead of keeping a whitelist of their dependencies
was too burdensome for the operators. For another 9 sites, the
policies were trivially insecure (e.g., raspberrypi.org)
before they were dropped. Here, we argue that deploying
insecure CSPs can eventually lead to their removal.
Summing up, though our archival analysis can only provide
glimpses of the reasons why site operators gave up CSP, we
ﬁnd that more than half of the sites for which we could
ﬁnd violations had these caused by third parties. For the
rest, even though we could not ﬁnd speciﬁc violations, a
signiﬁcant fraction had large whitelists with tens of third
parties, indicating that reliance on third parties could well be
the major reason behind the sites’ decision to abandon CSP.