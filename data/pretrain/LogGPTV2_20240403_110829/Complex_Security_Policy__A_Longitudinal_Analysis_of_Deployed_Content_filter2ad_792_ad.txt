### The Second Use Case of CSP: Ensuring HTTPS Content Loading

The second use case of Content Security Policy (CSP) is to ensure that no content is loaded via HTTP on HTTPS sites. In this section, we first examine the evolution of different methods used to achieve this goal over time and then discuss how these methods were successfully employed during TLS migration.

#### A. Evolution of TLS Enforcement

**Figure 8** illustrates the trend of deployed CSPs for TLS enforcement. We first observed policies specifically tailored for TLS enforcement in 2016, so we omit data prior to that year. From December 2016 onwards, there has been a steady increase in the usage of CSP for TLS enforcement. Notably, this enforcement is primarily driven by the `upgrade-insecure-requests` directive rather than exclusively whitelisting HTTPS sites. Full support for this CSP feature was introduced in browsers around March 2015 (with Chrome 43 [52]), but site operators did not widely adopt it until about 1.5 years later.

The related directive, `block-all-mixed-content`, has also seen increased usage, though its adoption remains lower compared to `upgrade-insecure-requests`. Interestingly, 51 sites used both directives in December 2018, even though in modern browsers, `block-all-mixed-content` is effectively redundant when `upgrade-insecure-requests` is present because the upgrade to HTTPS happens first. Despite a slight decrease in the number of sites deploying CSP for TLS enforcement in December 2018, a brief check for January 2019 indicates that usage continues to increase.

**Figure 8** also compares the usage of a policy aimed at ensuring that no content can be loaded over HTTP with the usage of the HTTP Strict Transport Security (HSTS) header. HSTS ensures that once a site has been visited over HTTPS, it cannot be loaded over HTTP until a specified timeout occurs [16]. In contrast, CSP directives ensure that any resources included by the original site will be loaded over HTTPS. Alongside the increasing deployment of `upgrade-insecure-requests`, the fraction of sites using HSTS also rises. Of the 450 sites that enforced transport security with CSP in December 2018, 267 (59%) made use of HSTS. This trend aligns with the broader adoption of HTTPS on the web [35].

For the 347 sites enforcing TLS explicitly via `upgrade-insecure-requests`, 194 (56%) also used HSTS. This provides insight into the complementary nature of these mechanisms: `upgrade-insecure-requests` ensures that once a secure connection is established, no resources or URLs are accidentally loaded via HTTP, while HSTS prevents the site from being loaded via HTTP in the first place. Although both mechanisms are desirable for a secure setup, HSTS involves a loss of control for the operator. Once a client observes the HSTS header, it will refuse to connect to the site via HTTP for a set amount of time controlled by the received HSTS header. Given that activating HSTS is no more complex than implementing `upgrade-insecure-requests`, we posit that its absence in half of the sites using the directive is more likely due to developers' reluctance to fully give up HTTP rather than issues with HSTS setup and deployment.

#### B. Leveraging CSP for TLS Migration

While one of the goals of CSP is to enforce TLS, it also provides significant assistance to developers during the transition to HTTPS. When mixed active content is detected by the browser while visiting an HTTPS site, it is automatically blocked. However, `upgrade-insecure-requests` instructs the browser to gracefully upgrade the connection rather than blocking all HTTP resources, which is particularly useful if an HTTPS site still contains references to HTTP-based active content (like scripts).

To understand which sites leveraged this benefit, we analyzed the 347 sites that deployed `upgrade-insecure-requests` within the last month of our analysis. For each site, we determined when they started using the directive and downloaded snapshots of their main pages from the Internet Archive (IA) for 31 days after the initial deployment.

Based on the snapshots collected before the deployment of `upgrade-insecure-requests`, we found that 251 (72.3%) sites deployed the directive as part of a transition to HTTPS. We based this observation on the archived URL, which indicates if the site had been loaded via HTTPS by the Archive’s crawlers. For these sites, we parsed the HTML of all collected snapshots and extracted the URLs of external scripts, images, frames, and stylesheets. On 77 sites, we found that within a month from the initial deployment, resources were still linked via HTTP. Among these sites, high-profile pages such as wired.com, airasia.com, and aol.com were identified. For these three sites, we further investigated the duration of their reliance on HTTP resources, downloading all snapshots until December 31, 2018.

For Air Asia and AOL, on the last day of our experiment, there was still one HTTP resource on their main page, even though both sites moved to HTTPS in 2017. Wired, which started deploying HTTPS in June 2016, removed the last HTTP resource from the start page only in September 2017.

Overall, these results strongly indicate that `upgrade-insecure-requests` is a useful mechanism and is widely used when a site migrates to HTTPS. More than 70% of sites deploying `upgrade-insecure-requests` for the first time did so as part of their move to HTTPS. Additionally, 77 sites continued to use HTTP-linked resources after their move to HTTPS, and `upgrade-insecure-requests` allowed these sites to function correctly due to the graceful upgrade to HTTPS.

### CSP for Framing Control

This section presents our historical findings for the third use case of CSP, i.e., framing control. Specifically, we investigate the extent to which CSP's `frame-ancestors` directive has achieved its goal of deprecating the underspecified X-Frame-Options (XFO) header.

#### A. Evolution of CSP for Framing Control

As discussed in Section II, XFO was not standardized before it was implemented in browsers, leading to inconsistent enforcement and enabling double-framing attacks. CSP removes this ambiguity by checking all of a frame’s ancestors. **Figure 9** provides a high-level overview of our analysis on the use of CSP for framing control against XFO.

We observe a steady increase in the usage of XFO until the end of our analysis in December 2018. In that month, 3,253 sites used XFO, while only 409 used `frame-ancestors`. Moreover, out of the sites that use CSP for framing control, 270 do so in combination with XFO. We first analyze the extent to which the flexibility of `frame-ancestors` is used, determining if the same whitelist could also be expressed with XFO. Second, for sites that use both CSP and XFO, we analyze how the goals of the deployed headers differ. Finally, we report on how many sites would need to move to CSP to achieve universal protection.

1. **Leveraging the Flexibility of CSP:**
   XFO offers coarse-grained protection due to its limited configuration options and the decision by Google Chrome (and other Chrome-based browsers) not to support the `ALLOW-FROM` directive. Our analysis aimed to determine which sites needed the additional flexibility offered by CSP's `frame-ancestors` directive. We aggregated these by year, as this shows a clearer trend compared to monthly analyses. The results are shown in Table IV.

   Starting from 2015, when a meaningful number of sites adopted `frame-ancestors` (shown as CSP-FA), at least 50% required the flexibility of CSP. The most common pattern was whitelisting all origins from the same site (104 of 321 in 2018). Manual investigation of the remaining cases showed that CSP was often used to whitelist sites from the same company (e.g., icloud.com allows framing from *.icloud.com and *.apple.com). Thus, apart from delivering different XFO headers based on the Referer or Origin header, these sites could not operate without `frame-ancestors`.

2. **Combining XFO and CSP `frame-ancestors`:**
   When both an XFO header and a CSP `frame-ancestors` directive are set, CSP-compatible browsers are supposed to ignore XFO. However, in older browser versions, XFO was the only mechanism to protect users from clickjacking. Based on this, we compared the semantics of XFO and `frame-ancestors` (CSP-FA) in cases where both were present, to understand how site operators dealt with different browsers. Over the entire period, 394 websites used both XFO and `frame-ancestors` at least once on the same day. Out of these, 290 did so inconsistently, with XFO and CSP not being semantically equivalent (e.g., not combining `SAMEORIGIN` and `self`). On 70 sites, `frame-ancestors` was used to relax the security boundary from the same origin to the same site, while the XFO header was set to `SAMEORIGIN`. 185 sites used CSP to relax the security boundary even further, leveraging `SAMEORIGIN` for older browsers. Only twice was CSP used to deploy a more restrictive policy, specifically going from the invalid XFO value `ALLOWALL` (essentially disabling XFO) to whitelisting the site and all of its subdomains. Here, the site operators opted for an insecure solution for IE users, the only current browser that does not support CSP framing control. Finally, 65 sites deployed an invalid XFO header alongside CSP at least once, e.g., using contradicting values like `SAMEORIGIN, DENY`, whose semantics on legacy browsers are unclear.

3. **Replacing XFO with CSP-FA:**
   Even though the double-framing attack is mitigated in most browsers since 2017 [26], using directives not supported by all browsers (e.g., `ALLOW-FROM` for Chrome and Safari) can have dangerous consequences. Setting an `ALLOW-FROM` directive in XFO results in the header being ignored completely (failing insecurely [18]). In December 2018, 116 sites in our dataset used a non-universally supported directive, meaning the developers would need to deploy CSP's `frame-ancestors` to properly secure their sites. Of the 3,253 sites that used XFO in December 2018 but not `frame-ancestors`, 362 already deployed a CSP. Thus, even though these sites could add a CSP directive to achieve more fine-grained and consistent framing control, they still relied on the deprecated security header. While one might argue that this could be due to old, outdated CSP policies, we found that 120 of these sites used `upgrade-insecure-requests`, a directive added after support for `frame-ancestors` was enabled.

### In-Depth Analysis of Deployed CSPs

We now shed light on the main reasons affecting the successful adoption of CSP. First, we focus on sites that gave up CSP and aim to attribute this choice to its cause. Second, we highlight characteristics of sites that kept running trivially insecure policies for content restriction, and finally, we investigate sites that deployed effective policies.

#### A. Reasons for Giving Up on CSP

We start by investigating whether changes in deployed CSPs can be attributed to violations of said policies. Specifically, we focus on sites that tried CSP in enforcement mode for at least one month but gave up. We define "giving up" as not having a policy for a specific use case throughout December 2018, reducing the risk of incorrectly flagging a site for having given up just because it did not have CSP for the last few days of 2018.

For each domain, we examined the final policy snapshot for each use case: content restriction, TLS enforcement, and framing control. Our aim is to understand why a given domain stopped using CSP in a particular capacity.

1. **Content Violations:**
   CSP's initial purpose was to restrict the inclusion of content into a page. Hence, our first analysis focuses on sites that gave up this use case. For each site, we determined the exact timeframe for which the last policy was deployed. We then visited the start page on the last day of policy deployment, following all links to the same site archived in the timeframe of the last deployed CSP. Unlike previous analyses, which relied on static parsing of HTML documents, we used an instrumented Chrome browser for this experiment. This allowed us to observe if dynamically-added content interfered with CSP. We limited the analysis to the first level of links (in total, 3,347 URLs), which required making an additional 421,684 requests through loaded scripts, images, fonts, etc.

   Overall, we found 63 domains that attempted content restriction but eventually gave up. For 15, we found violations of the deployed CSP through dynamic analysis. When relying solely on the resources statically linked in the HTML document, only 7 sites indicated a violated CSP, highlighting the benefits of dynamic analysis. Unfortunately, the Archive does not always correctly rewrite URLs to included resources, as shown by Lerner et al. [20]. Therefore, even the more accurate dynamic analysis may have missed some violations due to third-party code not being executed. Of the 15 sites with violations, 9 were caused by third-party code, and 8 by first-party code, with two domains having both first- and third-party-caused violations.

   For the remaining 48 sites for which we could not find violations, we performed two analyses. First, we conducted a live experiment on September 24, 2019, crawling the live versions of all websites in our dataset. For sites with a CSP on the start page, we randomly sampled 10 same-site subpages and checked their CSPs. We found that of the 1,202 sites with CSP on the start page, 1,024 (85%) appeared to have a site-wide deployment of the same policy. Assuming a similar distribution for the archived versions, the abandonment of site-wide policies may be due to violations on pages other than those we crawled.

   Eventually, we manually checked the deployed policies to classify them, providing an educated guess about the reason for dropping CSP. For 25 sites, we found that their policies showed increasing numbers of third-party entries (e.g., milanoo.com and snai.it). For these, the overhead of maintaining a whitelist of dependencies was likely too burdensome for the operators. For another 9 sites, the policies were trivially insecure (e.g., raspberrypi.org) before they were dropped. We argue that deploying insecure CSPs can lead to their removal.

   In summary, though our archival analysis can only provide glimpses of the reasons why site operators gave up CSP, we find that more than half of the sites for which we could find violations had these caused by third parties. For the rest, a significant fraction had large whitelists with tens of third parties, indicating that reliance on third parties could be a major reason behind the sites' decision to abandon CSP.