Windows运行库。这是一个本地运行库，看起来像是使用语言投射的.NET。许多WPF控
件都为新的运行库重写了，.NET Framework的一个子集可以使用这样的应用程序。
System.AddIn框架过于复杂、缓慢，所以用.NET 
4.5创建了一个新的合成框架：
Managed Extensibility Framework和名称空间System.Composition。
独立于平台的通信的新版本是由ASP.NET Web API提供的。WCF提供有状态和无状
态的服务，以及许多不同的网络协议，而ASP.NET 
Web 
API则简单得多，它是基于
Representational State Transfer（REST）软件架构风格的。
  注意： C# 5的async和await关键字在第15章中详细讨论。其中也介绍.NET在
不同时期使用的不同异步模式。
MEF参见第26章。Windows应用程序参见第29～33章，ASP.NET Web API参见第
42章。
1.2.7 C# 6和.NET Core
C# 6没有由泛型、LINQ和异步带来的巨大改进，但有许多小而实用的语言增强，可
以在几个地方减少代码的长度。很多改进都通过新的编译器引擎Roslyn来实现。
  注意： Roslyn参见第18章。
完整的.NET Framework并不是近年来使用的唯一.NET Framework。有些场景需要较
小的框架。2007年，发布了Microsoft Silverlight的第一个版本（代码名为WPF/E，即WPF
Everywhere）。Silverlight是一个Web浏览器插件，支持动态内容。Silverlight的第一个版
本只支持通过JavaScript编程。第2个版本包含.NET Framework的子集。当然，不需要服务
器端库，因为Silverlight总是在客户端运行，但附带Silverlight的框架Framework也删除了
核心特性中的类和方法，使其更简洁，便于移植到其他平台。用于桌面的Silverlight最新
版本（第5版）在2011年12月发布。Silverlight也用于Windows 
Phone的编程。Silverlight
8.1进入Windows Phone 8.1，但这个版本的Silverlight也不同于桌面版本。
在Windows桌面上，有如此巨大的.NET框架，需要更快的开发节奏，也需要较大的
改进。在DevOps中，开发人员和操作员一起工作，甚至是同一个人不断地给用户提供应
用程序和新特性，需要使新特性快速可用。由于框架巨大，且有许多依赖关系，创建新的
特性或修复缺陷是一项不容易完成的任务。
有了几个较小的.NET 
Framework（如Silverlight、用于Windows 
Phone的
Silverlight），在.NET的桌面版本和较小版本之间共享代码就很重要。在不同.NET版本之
间共享代码的一项技术是可移植库。随着时间的推移，有了许多不同的.NET 
Framework
和版本，可移植库的管理已成为一场噩梦。
为了解决所有这些问题，需要.NET的新版本（是的，的确需要解决这些问题）。
Framework的新版本命名为.NET Core。.NET Core较小，带有模块化的NuGet包以及分布
给每个应用程序的运行库是开源的，不仅可用于Windows的桌面版，也可用于许多不同的
Windows设备，以及Linux和OS X。
为了创建Web应用程序，完全重写了ASP.NET Core 1.0。这个版本不完全向后兼容老
版本，需要对现有的ASP.NET MVC（和ASP.NET MVC 6）代码进行一些修改。然而，与
旧版本相比，它也有很多优点，例如每一个网络请求的开销较低，性能更好，也可以在
Linux上运行。ASP.NET Web Forms不包含在这个版本中，因为ASP.NET Web Forms不是
专为最佳性能而设计的，它基于Windows Forms应用程序开发人员熟悉的模式来提高开发
人员的友好性。
当然，并不是所有的应用程序都很容易改为使用.NET Core。所以这个巨大的框架也
会进行改进——即使这些改进的完成速度没有.NET 
Core那么快，也是要改进的。.NET
Framework完整的新版本是4.6。ASP.NET Web Forms的小更新包在完整的.NET上可用。
  注意： Roslyn参见第18章。C#语言的变化参见第I部分中所有的语言章节，
例如，只读属性参见第3章，nameof运算符和空值传播参见第8章，字符串插值参见第
10章，异常过滤器参见第14章。本书尽可能使用.NET Core。.NET Core和NuGet包的更
多信息参见本章后面的内容。
1.2.8 选择技术，继续前进
知道框架内技术相互竞争的原因后，就更容易选择用于编写应用程序的技术。例如，
如果创建新的Windows应用程序，使用Windows Forms就不好。而应该使用基于XAML的
技术，例如Windows应用程序，或者使用WPF的Windows桌面应用程序。
如果创建Web应用程序，肯定应使用ASP.NET Core与ASP.NET MVC 6。做这个选择
时要排除ASP.NET Web Forms。如果访问数据库，就应该使用Entity Framework而不是
LINQ to SQL，应该选择Managed Extensibility Framework而不是System.AddIn。
旧应用程序仍在使用Windows Forms、ASP.NET Web Forms和其他一些旧技术。只为
改变现有的应用程序而使用新技术是没有意义的。进行修改必须有巨大的优势，例如，维
护代码已经是一个噩梦，需要大量的重构以缩短客户要求的发布周期，或者使用一项新技
术可以减少更新包的编码时间。根据旧有应用程序的类型，使用新技术可能不值得。可以
允许应用程序仍使用旧技术，因为在未来的许多年仍将支持Windows 
Forms和ASP.NET
Web Forms。
本书的内容以新技术为基础，展示创建新应用程序的最佳技术。如果仍然需要维护旧
应用程序，可以参考本书的老版本，其中介绍了ASP.NET Web Forms、Windows Forms、
System.AddIn和其他仍然在.NET Framework中可用的旧技术。
1.3 .NET 2015
.NET 
2015是所有.NET技术的总称。图1-1给出了这些技术的总图。左边代表.NET
Framework 4.6技术，如WPF和ASP.NET 4。ASP.NET Core 1.0也可以在.NET Framework
4.6上运行。右边代表新的.NET Core技术。ASP.NET Core 1.0和UWP运行在.NET Core上。
还可以创建在.NET Core上运行的控制台应用程序。
图1-1
.NET Core的一个组成部分是一个新的运行库CoreCLR。这个运行库从ASP.NET Core
1.0开始使用。不使用CoreCLR运行库，.NET也可以编译为本地代码。UWP自动利用这个
特性，这些.NET应用程序编译为本地代码之后，在Windows 
Store中提供。也可以把其
他.NET Core应用程序以及运行在Linux上的应用程序编译为本地代码。
在图1-1的下方，.NET Framework 4.6和.NET Core 1.0之间还有一些共享的内容。运行
库组件是共享的，如垃圾回收器的代码和RyuJIT（这是一个新的JIT编译器，把IL代码编
译为本地代码）。垃圾回收器由CLR、CoreCLR和.NET Native使用。RyuJIT即时编译器由
CLR和CoreCLR使用。库可以在基于.NET Framework 4.6和.NET Core 1.0的应用程序之间
共享。NuGet包的概念帮助把这些库放在一个在所有.NET平台上都可用的公共包上。当
然，所有这些技术都使用新的.NET编译器平台。
1.3.1 .NET Framework 4.6
.NET Framework 4.6是.NET Framework在过去10年不断增强的结果。1.2节讨论的许多
技术都基于这个框架。这个框架用于创建Windows 
Forms和WPF应用程序。此外，
ASP.NET 5可以在.NET Core上运行，也可以在.NET Framework 4.6上运行。
如果希望继续使用ASP.NET Web Forms，就应选择ASP.NET 4.6和.NET Framework
4.6。ASP.NET 4.6与4.5版本相比，也有新特性，比如支持HTTP2（HTTP协议的一个新版
本，参见第25章），用Roslyn编译器编译，以及异步模型绑定。然而，不能把ASP.NET
Web Forms切换到.NET Core。
在目录%windows%\Microsoft.NET\Framework\v4.0.30319下可以找到框架的库以及
CLR。
可用于.NET Framework的类组织在System名称空间中。表1-2描述的名称空间提供了
层次结构的思路。
表1-2
名称空间
说明
System.Collections
System.Collections. Generic这是集合的根名称空间。子名称
空间也包含集合，如System.Collections.Concurrent和
System.Data
这是访问数据库的名称空间。System.Data.SqlClient包含访
问SQL Server的类
System.Diagnostics
这是诊断信息的根名称空间，如事件记录和跟踪（在
System.Diagnostics.Tracing名称空间中）
System.Globalization
该名称空间包含的类用于全球化和本地化应用程序
System.IO
这是文件IO的名称空间，其中的类访问文件和目录，包括
读取器、写入器和流
System.Net
这是核心网络的名称空间，比如访问DNS服务器，用
System.Net.Sockets创建套接字
System.Threading
这是线程和任务的根名称空间。任务在
System.Threading.Tasks中定义
System.Web
这是ASP.NET的根名称空间。在这个名称空间下面定义了
许多子名称空间，如System.Web.UI、
System.Web.UI.WebControls和System.Web.Hosting
System.Windows
这是用于带有WPF的Windows桌面应用程序的根名称空间。
子名称空间有System.Windows.Shapes、
System.Windows.Data和System.Windows.Documents
  注意： 一些新的.NET类使用以Microsoft开头而不是以System开头的名称空
间，比如用于Entity 
Framework的Microsoft.Data.Entity，用于新的依赖关系注入框架的
Microsoft.Extensions.DependencyInjection。
1.3.2 .NET Core 1.0
.NET Core 1.0是新的.NET，所有新技术都使用它，是本书的一大关注点。这个框架
是开源的，可以在http://www.github.com/dotnet上找到它。运行库是CoreCLR库；包含集合
类的框架、文件系统访问、控制台和XML等都在CoreFX库中。
.NET Framework要求必须在系统上安装应用程序需要的特定版本，而在.NET Core 1.0
中，框架（包括运行库）是与应用程序一起交付的。以前，把ASP.NET Web应用程序部
署到共享服务器上有时可能有问题，因为提供程序安装了旧版本的.NET。这种情况已经
一去不复返了。现在可以同时提交应用程序和运行库，而不依赖服务器上安装的版本。
.NET Core 1.0以模块化的方式设计。该框架分成数量很多的NuGet包。根据应用程序
决定需要什么包。添加新功能时，.NET 
Framework就变得越来越大。删除不再需要的旧
功能是不可能的，比如添加了泛型集合类，旧的集合类就是不必要的。.NET Remoting被
新的通信技术取代，或LINQ to SQL已经更新为Entity Framework。删除某个功能，会破坏
应用程序。这不适用于.NET Core，因为应用程序会发布它需要的部分框架。
目前.NET Core的框架与.NET Framework 4.6一样庞大。然而，这可以改变，它可以变
得更大，但因为模块化，其增长潜力不是问题。.NET Core已经如此之大，本书不可能包
括每个类型。在http://www.github.com/dotnet /corefx中可以看到所有的源代码。例如，旧
的非泛型集合类已被包含在.NET Core中，使旧代码更容易进入新平台。
.NET Core可以很快更新。即使更新运行库，也不影响现有的应用程序，因为运行库
与应用程序一起安装。现在，微软公司可以增强.NET 
Core，包括运行库，发布周期更
短。
  注意： 为了使用.NET Core开发应用程序，微软公司创建了新的命令行实用
程序.NET Core Command Line （CLI）。
1.3.3 程序集
.NET程序的库和可执行文件称为程序集（assembly）。程序集是包含编译好的、面
向.NET Framework的代码的逻辑单元。
程序集是完全自描述性的，它是一个逻辑单元而不是物理单元，这意味着它可以存储
在多个文件中（动态程序集存储在内存中，而不是存储在文件中）。如果一个程序集存储
在多个文件中，其中就会有一个包含入口点的主文件，该文件描述了程序集中的其他文
件。
可执行代码和库代码使用相同的程序集结构。唯一的区别是可执行的程序集包含一个
主程序入口点，而库程序集不包含。
程序集的一个重要特征是它们包含的元数据描述了对应代码中定义的类型和方法。程
序集也包含描述程序集本身的程序集元数据，这种程序集元数据包含在一个称为“清单
（manifest）”的区域中，可以检查程序集的版本及其完整性。
由于程序集包含程序的元数据，因此调用给定程序集中的代码的应用程序或其他程序
集不需要引用注册表或其他数据源就能确定如何使用该程序集。
在.NET Framework 4.6中，程序集有两种类型：私有程序集和共享程序集。共享程序
集不适用于UWP，因为所有代码都编译到一个本机映像中。
1．私有程序集
私有程序集一般附带在某个软件上，且只能用于该软件。附带私有程序集的常见情况
是，以可执行文件或许多库的方式提供应用程序，这些库包含的代码只能用于该应用程
序。
系统可以保证私有程序集不被其他软件使用，因为应用程序只能加载位于主执行文件
所在文件夹或其子文件夹中的私有程序集。
用户一般会希望把商用软件安装在它自己的目录下，这样软件包不存在覆盖、修改或
在无意间加载另一个软件包的私有程序集的风险。私有程序集只能用于自己的软件包，这
样，用户对什么软件使用它们就有了更大的控制权。因此，不需要采取安全措施，因为这
没有其他商用软件用某个新版本的程序集覆盖原来私有程序集的风险（但软件专门执行怀
有恶意的损害性操作的情况除外）。名称也不会有冲突。如果私有程序集中的类正巧与另
一个人的私有程序集中的类同名，是不会有问题的，因为给定的应用程序只能使用它自己
的一组私有程序集。
因为私有程序集是完全自包含的，所以部署它的过程就很简单。只需要把相应的文件
放在文件系统的对应文件夹中即可（不需要注册表项），这个过程称为“0影响（xcopy）
安装”。
2．共享程序集
共享程序集是其他应用程序可以使用的公共库。因为其他软件可以访问共享程序集，
所以需要采取一定的保护措施来防止以下风险：
● 名称冲突，指另一个公司的共享程序集实现的类型与自己的共享程序集中的类型同
名。因为客户端代码理论上可以同时访问这些程序集，所以这是一个严重的问
题。
● 
程序集被同一个程序集的不同版本覆盖——新版本与某些已有的客户端代码不兼
容。
这些问题的解决方法是把共享程序集放在文件系统的特定子目录树中，称为全局程序
集缓存（Global Assembly Cache, GAC）。与私有程序集不同，不能简单地把共享程序集
复制到对应的文件夹中，而需要专门安装到缓存中。有许多.NET工具可以完成这个过
程，并要求对程序集进行检查，在程序集缓存中设置一个小的文件夹层次结构，以确保程
序集的完整性。
为了避免名称冲突，应根据私钥加密法为共享程序集指定一个名称（而对于私有程序
集，只需要指定与其主文件名相同的名称即可）。该名称称为强名（strong name），并保
证其唯一性，它必须由要引用共享程序集的应用程序来引用。
与覆盖程序集的风险相关的问题，可以通过在程序集清单中指定版本信息来解决，也
可以通过同时安装来解决。
1.3.4 NuGet包
在早期，程序集是应用程序的可重用单元。添加对程序集的一个引用，以使用自己代
码中的公共类型和方法，此时，仍可以这样使用（一些程序集必须这样使用）。然而，使
用库可能不仅意味着添加一个引用并使用它。使用库也意味着一些配置更改，或者可以通
过脚本来利用的一些特性。这是在NuGet包中打包程序集的一个原因。
NuGet包是一个zip文件，其中包含程序集（或多个程序集）、配置信息和PowerShell
脚本。
使用NuGet包的另一个原因是，它们很容易找到，它们不仅可以从微软公司找到，也
可以从第三方找到。NuGet包很容易在NuGet服务器http://www.nuget.org上获得。
在Visual Studio项目的引用中，可以打开NuGet包管理器（NuGet Package Manager，
见图1-2），在该管理器中可以搜索包，并将其添加到应用程序中。这个工具允许搜索还
没有发布的包（包括预发布选项），定义应该在哪个NuGet服务器中搜索包。
图1-2
  注意： 使用NuGet服务器中的第三方包时，如果一个包以后才能使用，就总
是有风险。还需要检查包的支持可用性。使用包之前，总要检查项目的链接信息。对
于包的来源，可以选择Microsoft and .NET，只获得微软公司支持的包。第三方包也包
括在Microsoft and .NET部分中，但它们是微软公司支持的第三方包。
也可以让开发团队使用自己的NuGet服务器。可以定义开发团队只允许使用自己服
务器中的包。
因为.NET Core是模块化的，所以所有应用程序（除了最简单的应用程序）都需要额
外的NuGet包。为了更容易找到包，本书使用.NET 
Core构建的每个示例应用程序都显示
了一个表格，列出需要添加的包和名称空间。
  注意： NuGet包管理器的更多信息参见第17章。
1.3.5 公共语言运行库
UWP（通用Windows平台）利用Native 
.NET把IL编译成本地代码。在所有其他场景
中，使用.NET 
Framework 
4.6的应用程序和使用.NET 
Core 
1.0的应用程序都需要
CLR（Common Language Runtime，公共语言运行库）。然而，.NET Core使用CoreCLR，
而.NET Framework使用CLR。
在CLR执行应用程序之前，编写好的源代码（使用C#或其他语言编写的代码）都需
要编译。在.NET中，编译分为两个阶段：
（1）将源代码编译为Microsoft中间语言（Intermediate Language, IL）。
（2）CLR把IL编译为平台专用的本地代码。
IL代码在.NET程序集中可用。在运行时，JIT编译器编译IL代码，创建特定于平台的
本地代码。
新的CLR和CoreCLR包括一个新的JIT编译器RyuJIT。新的JIT编译器不仅比以前的版
本快，还在用Visual Studio调试时更好地支持Edit & Continue特性。Edit & Continue特性允
许在调试时编辑代码，可以继续调试会话，而不需要停止并重新启动过程。
CLR还包括一个带有类型加载器的类型系统，类型加载器负责从程序集中加载类型。
类型系统中的安全基础设施验证是否允许使用某些类型系统结构，如继承。
创建类型的实例后，实例还需要销毁，内存也需要回收。CLR的另一个功能是垃圾回
收器。垃圾回收器从托管堆中清除不再引用的内存。第5章解释其工作原理和执行的时
间。
CLR还负责线程的处理。在C#中创建托管的线程不一定来自底层操作系统。线程的
虚拟化和管理由CLR负责。
  注意： 如何在C#中创建和管理线程参见第21章和第22章。
1.3.6 .NET Native
.NET 
Native是.NET 
2015的一个新特性，它将托管程序编译成本地代码。对于
Windows应用程序，这会生成优化的代码，其启动时间可以缩短60%，内存的使用减少
15%～20%。
最初，.NET 
Native把UWP应用编译为本地代码，以部署到Windows 
Store。现
在，.NET Native将来也可以用于其他.NET Core应用程序，不过它目前还不能用于.NET
Core 
1.0版本中，但可用于.NET 
Core的将来版本中。可以把运行在Windows和Linux上
的.NET Core应用程序编译为本地代码。当然，在每一个平台上需要不同的本地映像。在
后台.NET Native共享C++优化器，以生成本地代码。
1.3.7 Windows运行库
从Windows 
8开始，Windows操作系统提供了另一种框架：Windows运行库
（Windows Runtime）。这个运行库由WUP（Windows Universal Platform, Windows通用平
台）使用，Windows 8使用第1版，Windows 8.1使用第2版，Windows 10使用第3版。
与.NET Framework不同，这个框架是使用本地代码创建的。当它用于.NET应用程序
时，所包含的类型和.NET类似。在语言投射的帮助下，Windows运行库可以用于