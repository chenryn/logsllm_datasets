cuits. In Thorsten Holz and Stefan Savage, editors, USENIX Security 2016, pages 1069–1083. USENIX
Association, August 2016.
Shaﬁ Goldwasser, Silvio Micali, and Charles Rackoﬀ. The knowledge complexity of interactive proof
systems. SIAM Journal on Computing, 18(1):186–208, 1989.
GMO16.
GMR89.
GKS17.
GMW87. Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or A completeness
theorem for protocols with honest majority. In Alfred Aho, editor, 19th ACM STOC, pages 218–229.
ACM Press, May 1987.
46
Gro09.
Gro10.
Gro16.
GW11.
IKO07.
IKOS07.
Kil89.
Kil92.
In Shai Halevi, editor,
Linear algebra with sub-linear zero-knowledge arguments.
Jens Groth.
CRYPTO 2009, volume 5677 of LNCS, pages 192–208. Springer, Heidelberg, August 2009.
Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor,
ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340. Springer, Heidelberg, December 2010.
Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien
Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg,
May 2016.
Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsiﬁable as-
sumptions. In Lance Fortnow and Salil P. Vadhan, editors, 43rd ACM STOC, pages 99–108. ACM Press,
June 2011.
Yuval Ishai, Eyal Kushilevitz, and Rafail Ostrovsky. Eﬃcient arguments without short pcps. In Pro-
ceedings of the Twenty-Second Annual IEEE Conference on Computational Complexity, CCC ’07, pages
278–291, Washington, DC, USA, 2007. IEEE Computer Society.
Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge from secure multiparty
computation. In David S. Johnson and Uriel Feige, editors, 39th ACM STOC, pages 21–30. ACM Press,
June 2007.
J. Kilian. Uses of randomness in algorithms and protocols. PhD Thesis. Massachusetts Institute of
Technology, 1989.
Joe Kilian. A note on eﬃcient zero-knowledge proofs and arguments (extended abstract). In 24th ACM
STOC, pages 723–732. ACM Press, May 1992.
KPP+14. Ahmed E. Kosba, Dimitrios Papadopoulos, Charalampos Papamanthou, Mahmoud F. Sayed, Elaine Shi,
and Nikos Triandopoulos. TRUESET: Faster veriﬁable set computations. In Kevin Fu and Jaeyeon Jung,
editors, USENIX Security 2014, pages 765–780. USENIX Association, August 2014.
Eike Kiltz and Hoeteck Wee. Quasi-adaptive NIZK for linear subspaces revisited. In Elisabeth Oswald
and Marc Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 101–128. Springer,
Heidelberg, April 2015.
KW15.
LFKN92. Carsten Lund, Lance Fortnow, Howard Karloﬀ, and Noam Nisan. Algebraic methods for interactive proof
librk.
Lip12.
Lip16.
Mer88.
Mic94.
Mic00.
NY90.
Par15.
Ped92.
systems. J. ACM, 39(4):859–868, October 1992.
https://github.com/scipr-lab/libsnark, libsnark.
Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge argu-
ments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 169–189. Springer, Heidelberg,
March 2012.
Helger Lipmaa. Prover-eﬃcient commit-and-prove zero-knowledge SNARKs. In David Pointcheval, Ab-
derrahmane Nitaj, and Tajjeeddine Rachidi, editors, AFRICACRYPT 16, volume 9646 of LNCS, pages
185–206. Springer, Heidelberg, April 2016.
Ralph C. Merkle. A digital signature based on a conventional encryption function. In Carl Pomerance,
editor, CRYPTO’87, volume 293 of LNCS, pages 369–378. Springer, Heidelberg, August 1988.
Silvio Micali. CS proofs (extended abstracts). In 35th FOCS, pages 436–453. IEEE Computer Society
Press, November 1994.
Silvio Micali. Computationally sound proofs. SIAM Journal on Computing, 30(4):1253–1298, 2000.
Moni Naor and Moti Yung. Public-key cryptosystems provably secure against chosen ciphertext attacks.
In 22nd ACM STOC, pages 427–437. ACM Press, May 1990.
Bryan Parno. A note on the unsoundness of vnTinyRAM’s SNARK. Cryptology ePrint Archive, Report
2015/437, 2015. http://eprint.iacr.org/2015/437.
Torben P. Pedersen. Non-interactive and information-theoretic secure veriﬁable secret sharing. In Joan
Feigenbaum, editor, CRYPTO’91, volume 576 of LNCS, pages 129–140. Springer, Heidelberg, August
1992.
pypPy.
Rot09.
RRR16.
PHGR13. Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical veriﬁable
computation. In 2013 IEEE Symposium on Security and Privacy, pages 238–252. IEEE Computer Society
Press, May 2013.
https://pypy.org, PyPy.
Guy Rothblum. Delegating computation reliably: paradigms and constructions, 2009. PhD thesis.
Omer Reingold, Guy N. Rothblum, and Ron D. Rothblum. Constant-round interactive proofs for dele-
gating computation. In Daniel Wichs and Yishay Mansour, editors, 48th ACM STOC, pages 49–62. ACM
Press, June 2016.
Claus-Peter Schnorr. Eﬃcient signature generation by smart cards. Journal of Cryptology, 4(3):161–174,
January 1991.
Sch91.
47
Tha13.
Val76.
Vee17.
Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In Ran Canetti and Juan A. Garay,
editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 71–89. Springer, Heidelberg, August 2013.
Leslie G. Valiant. Universal circuits (preliminary report). In STOC, pages 196–203. ACM, 1976.
Meilof Veeningen. Pinocchio-based adaptive zk-SNARKs and secure/correct adaptive function evaluation.
In Marc Joye and Abderrahmane Nitaj, editors, AFRICACRYPT 17, volume 10239 of LNCS, pages 21–39.
Springer, Heidelberg, May 2017.
WJB+17. Riad S. Wahby, Ye Ji, Andrew J. Blumberg, abhi shelat, Justin Thaler, Michael Walﬁsh, and Thomas
Wies. Full accounting for veriﬁable outsourcing. In Bhavani M. Thuraisingham, David Evans, Tal Malkin,
and Dongyan Xu, editors, ACM CCS 2017, pages 2071–2086. ACM Press, October / November 2017.
WSR+15. Riad S. Wahby, Srinath T. V. Setty, Zuocheng Ren, Andrew J. Blumberg, and Michael Walﬁsh. Eﬃ-
cient RAM and control ﬂow in veriﬁable outsourced computation. In NDSS 2015. The Internet Society,
February 2015.
WTas+17. Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walﬁsh. Doubly-eﬃcient zksnarks
without trusted setup. Cryptology ePrint Archive, Report 2017/1132, 2017. https://eprint.iacr.org/
2017/1132.
WTs+18. Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walﬁsh. Doubly-eﬃcient zk-
In 2018 IEEE Symposium on Security and Privacy, pages 926–943.
SNARKs without trusted setup.
IEEE Computer Society Press, May 2018.
ZGK+17a. Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou.
vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In 2017 IEEE Symposium
on Security and Privacy, pages 863–880. IEEE Computer Society Press, May 2017.
ZGK+17b. Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou.
A zero-knowledge version of vsql. Cryptology ePrint Archive, Report 2017/1146, 2017. https://eprint.
iacr.org/2017/1146.
A Security proof of CP-SNARK composition
In this section we provide a proof of Theorem 3.1. We ﬁrst deﬁne relation generators and auxiliary
input generators for this construction.
R )b∈{0,1} ← Aux
RG
(1λ)
R := (R1−b, (aux(b)
R )b∈{0,1})
AuxRG(1λ) :
R ) ← RG0(1λ)
(R0, aux(0)
R ) ← RG1(1λ)
(R1, aux(1)
return (Rb, aux(b)
R )b∈{0,1}
AuxZ (ck, (crsb, Rb, aux(b)
aux(0)
aux(1)
return (aux(b)
Z ← Z0(ck, R0, crs0, aux(0)
R )
Z ← Z1(ck, R1, crs1, aux(1)
R )
Z )b∈{0,1}
R )b∈{0,1}) :
RGb(1λ) :
(Rb, aux(b)
aux(b)
return (Rb, aux(b)
R )
RG∗(1λ) :
(Rb, aux(b)
R )b∈{0,1} ← Aux
∧
R0,R1 , (aux(b)
R )b∈{0,1})
RG
(1λ)
return (R
R0,R1 ), (ek∗, vk∗), (auxR, aux(cid:48)
R)) :
Z∗((ck, R∧
(aux(b)
return (aux(b)
Z )b∈{0,1} ← Aux
Z
Z )b∈{0,1}
(ck, (crsb, Rb, aux(b)
R )b∈{0,1})
R ) :
Z b(ck, Rb, crsb, aux(b)
Parse auxR as (R1−b, (aux(b)
crs1−b ← CP1−b.KeyGen(ck, R1−b)
{aux(b)
Z ← Aux
Z
(ck, (crsb, Rb, aux(b)
return aux(b)
Z := (crs1−b, (aux(b)
R )b∈{0,1})
R )b∈{0,1})}
Z )b∈{0,1})
Figure 10: Relation and Auxiliary Input Generators for AND Composition Construction
A.1 Proof of Knowledge Soundness
We state the following lemma.
48
Lemma A.1. If Com is computationally binding, and if CPb is KSND(RGb,Z b) (where RGb,Z b
are deﬁned in terms of RGb,Zb in Figure 10) for b ∈ {0, 1}, then the scheme CP∧ in Figure 1 is
KSND(RG∗,Z∗) where RG∗,Z∗ are as deﬁned in Figure 10.
Let A∗ be an adversary against the soundness of CP∧ with respect to RG∗ and Z∗. Now for
Proof
b ∈ {0, 1} consider adversary Ab (deﬁned in Figure 11) against CPb with respect to RGb and Z b. By
the fact that CPb is KSND(RGb,Z b) there exists an extractor Eb such that Pr[GameKSNDRGb,Z b,Ab,Eb
= 1]
is negligible.
We deﬁne an extractor E∗ for CP∧ in Figure 11, and we claim is such that Pr[GameKSNDRG∗,Z∗,A∗,E∗ = 1].
2 in E∗ are equal, conditioned
First observe that with overwhelming probability the values u2 and u(cid:48)
to the openings being all correct for their respective commitments (i.e., conditioned to VerCommit
returning 1 on each of them). In fact, if it were otherwise, we could then break the binding of Com
(as done in the proof of Theorem B.1).
We now deﬁne the following notations:
(cid:8)GdCom(cb, ub, ob) := Com.VerCommit(ck, cb, ub, ob) = 1(cid:9)
b∈{0,1}
GdCom(c2, u2, o2) := Com.VerCommit(ck, c2, u2, o2) = 1
GdCom(c2, u(cid:48)
2) = 1
2) := Com.VerCommit(ck, c2, u(cid:48)
2, o(cid:48)
2, o(cid:48)
For b ∈ {0, 1}, by the soundness properties of CPb and the deﬁnition of Eb,E∗ we have that pb, as
deﬁned below, is negligible.
pb := Pr[b(b)
ok ∧ (¬GdCom(cb, ub, ob) ∨ ¬GdCom(c2, u2, o2) ∨ Rb(xb, ub, u2, ωb) = 0)]
where all the symbols above are as deﬁned in the construction of E∗. Now we can observe that
= Pr(cid:2)b(0)
Pr[GameKSNDRG∗,Z∗,A∗,E∗ = 1] = . . .
≤ Pr(cid:2)b(0)
ok ∧ (¬GdCom(c0, u0, o0) ∨ ¬GdCom(c2, u2, o2) ∨ R0(u0, u2, ω0) = 0)(cid:3) +
∨ R0(x0, u0, u2; ω0) = 0 ∨ R1(x1, u1, u2; ω1) = 0)(cid:3)
ok ∧ (¬GdCom(c0, u0, o0) ∨ ¬GdCom(c1, u1, o1) ∨ ¬GdCom(c2, u2, o2)
ok ∧ b(1)
Pr[b(1)
ok ∧ (¬GdCom(c1, u1, o1) ∨ ¬GdCom(c2, u
(cid:48)
2, o
2) ∨ R1(u1, u
(cid:48)
2, ω1) = 0)] + negl(λ) ≤ p0 + p1 + negl(λ) ≤ negl(λ)
(cid:48)
where in the last two inequalities we used our earlier observations on the openings of u2 and u(cid:48)
being negligible respectively.
2 and p0 and p1
(cid:3)
Ab(ck, (crsb, Rb), aux(b)
R , aux(b)
Z ) :
R as (R1−b, (aux(b)
Z as (crs1−b, (aux(b)
Parse aux(b)
Parse aux(b)
(x0, x1, (cj)j∈[:3], π
← A∗(cid:0)ck, (crs0, crs1, R