cation Attack
Memcached
DDoS Attack
HTTP
HTTP Flood
SlowLoris
Attack
The attacker generates elephant ﬂows to overwhelm the
bandwidth of the victim servers
The victim servers receive a large rate of fake UDP packets
from a wide range of IP addresses
The victim DNS servers are bombarded with a ﬂood of
requests from a wide range of IP addresses
The attacker requests data about a domain from public DNS
servers, and directs the reply to the victim servers
The attacker spoofs discovery packets with the victim
servers’ IP address to each plug-and-play device, to request
for as much data as possible by setting certain ﬂags
By spooﬁng the victims’ IP address and sending a ”hello”
message to QUIC servers, the attacker tricks the servers into
sending large amounts of unwanted data to the victim servers
The attacker sends numerous NTP requests providing the
victim servers’ IP address
The attacker spoofs requests to a vulnerable UDP mem-
cached server, which then ﬂoods a targeted victims with
large amount of trafﬁc
The attacker generates large numbers of HTTP requests and
sends them to the victim servers
The victim servers are bombarded with too many open
connections
TABLE V: Lines of code to implement different defense
intents in POSEIDON, P4, and C/C++ (using DPDK).
Policy
1
2
3
4
5
6
Attack
SYN ﬂood
DNS ampliﬁcation
HTTP ﬂood
Slowloris
UDP ﬂood
Elephant ﬂow
POSEIDON
9
7
6
8
6
6
P4
939
255
354
513
376
373
DPDK
1070
898
1184
995
911
903
count primitive to track whether the SYN-ACK packets or
ACK packets have been generated by protected servers within
a period, and only allow legitimate packets to enter the
protected network. For FIN/RST ﬂood attacks, we can ﬁrst
use the count primitive to track the connections between the
protected servers and the external network, and only allow
FIN or RST packets in the active connections. Furthermore,
for these remaining FIN or ACK packets, we use the count
primitive again to count the number of FIN/RST packets in
each connection and use the rlimit primitive for rate limiting.
UDP Protocol. UDP-based DDoS attacks (especially UDP-
based ampliﬁcation attacks) are one of the most popular
DDoS attacks today [64]. We have already discussed the
corresponding defenses with POSEIDON primitives for UDP
11
ﬂood attacks and DNS ampliﬁcation attacks in §IV-B. For DNS
ﬂood attacks, we can use a similar approach as UDP ﬂood
attacks, rate-limiting the DNS request packets from the same
address or subnet. For the other four UDP-based ampliﬁcation
attacks (SSDP DDoS attacks, QUIC Reﬂection attacks, NTP
ampliﬁcation attacks, and Memcached DDoS attacks), we can
use a similar defense as in DNS ampliﬁcation attacks, ﬁltering
replies that are not triggered by the victim servers.
HTTP Protocol. We have already discussed the corresponding
defense solutions in POSEIDON for HTTP ﬂood attacks and
SlowLoris attacks in detail in §IV-B.
From the discussions on each categorization above, we can
see that although the attacks require different defense solutions,
almost all these DDoS defenses require monitoring primitives
to identify the malicious packet groups, as well as a reusable
set of defense actions for packet processing. Regarding this
point, our monitor primitives provide a useful abstraction to
aggregate certain packets and collect statistics, and our action
primitives offer a powerful packet processing abstraction for
DDoS defenses. From TABLE IV, we can also see the current
set of primitives are expressive enough to cover a wide range
of state-of-the-art DDoS defense mechanisms.
We have provided six policy examples in §IV-B to demon-
D. Dynamic DDoS Attacks
To evaluate the effectiveness of runtime state replication
against attack dynamics, we mix normal workload traces with
attack traces and replay them from the packet generator. At
runtime, we change the attack from #1 to #2, and adapt the
defense policy accordingly. As we can see in Fig. 11 and
Fig. 12, POSEIDON ensures that legitimate trafﬁc goes through
the scrubbing center normally without broken connections,
even without packet loss. In contrast, without runtime state
replication, connections will be broken and packets will be
dropped, since no state can be found on the servers. This
would interrupt the legitimate ﬂows and lead to signiﬁcant
performance degradation. In addition, from the trends of the
three traces, we can conclude that the more elephant ﬂows the
trace contains, the worse the ﬂow interruption and packet loss
will be.
To evaluate the overhead of runtime state replication, we
replay three attack trafﬁc traces at an increased rate. As shown
in Fig. 13,
the ratio between control message trafﬁc and
workload trafﬁc is constant even when the attack trafﬁc is
multiplied. This is because POSEIDON only replicates runtime
states for legitimate trafﬁc. In this ﬁgure, the control message
ratio for Enterprise trafﬁc is a bit higher than other two
traces. This is because the Enterprise trace contains a large
number of mouse ﬂows (about 9 packets per ﬂow), and for
each ﬂow, we have to generate a state replication packet. Even
in this case, the overhead is still very low (less than 4%),
which indicates that our runtime management scheme incurs
negligible overheads.
Fig. 10: Trafﬁc arriving at servers.
strate the the expressiveness of our POSEIDON policy lan-
guage. We further summarize the number of lines of code in
POSEIDON, in P4, and in C/C++ when implementing these six
policy examples, as shown in TABLE V. From this table, we
can see that POSEIDON allows concise speciﬁcations of the
defense policies, without having to burden network operators
with the task of writing low-level code. Moreover, POSEIDON
also shields the complexities of the underlying hardware.
Policies #1, #2, #4, #5, and #6 can be fully implemented in the
switches, whereas #3 requires the assistance of the servers. But
a programmer does not have to be aware of the implementation
details. In particular, programming in P4 is akin to “assembly-
level” programming and usually requires hand optimizations.
We have also included sample code in P4 for implementing
policy #1 in Appendix B as a concrete example.
C. Policy Placement Mechanism
E. Overall Effectiveness
To demonstrate the efﬁciency of POSEIDON policy place-
ment mechanism, we compare it with a strawman solution,
which simply places the programs using their policy IDs,
the smallest ID ﬁrst. We assume that attackers launch three
attacks simultaneously, 10 Mpps SYN ﬂood, 20 Mpps DNS
ampliﬁcation and 15Mpps HTTP ﬂood. The corresponding
resource utilization for each primitive could be obtained from
TABLE II. We assume that a switch has 12 stages, each with
5Mb register array and 4 stateful actions; these constraints are
much more strict than most Barefoot Toﬁno switches. We use
the rate of packets arriving at servers as the metric to evaluate
the effectiveness of our policy placement mechanism.
As we can see from Fig. 10, the more switches there are,
the more trafﬁc is ﬁltered at the switch and the fewer packets
are sent to the servers. Comparing with the strawman place-
ment mechanism, the placement of POSEIDON can mitigate
larger attacks with the same number of switches. Note that the
curves for both approaches would ﬁnally converge to the same
points. This is because when there are enough programmable
switches, all primitives that can run on the switches have been
ofﬂoaded; the rest of the primitives need to run on the servers,
and this leads to a constant number of packets to be sent to
the servers for processing. In our scenario, it is impossible for
attackers to launch tens of DDoS attacks simultaneously. As a
result, our ILP problem has a relatively small size, and it can
be solved within seconds. This also indicates that our system
is able to orchestrate the defense resources in a pretty fast
manner, which can accommodate to policy changes quickly.
To demonstrate the effectiveness of POSEIDON during
attacks, we measure the bandwidth of legitimate TCP ﬂows
under the six types of DDoS attacks, and count the number of
sent/received packets at the trafﬁc generator. We use a simple
time series anomaly detection tool nfdump for the coarse-
grained detection; the detection results would further trigger
the loading of different defense policies, and the allocation
of switch resources. Fig. 14 shows the defense effect for
legitimate TCP ﬂows during the UDP ﬂood attack. The defense
effect for the other types of DDoS attacks is similar, since most
attack trafﬁc is ﬁltered by POSEIDON before it reaches the
trafﬁc generator3. As we can see from the ﬁgure, POSEIDON
can respond to the attack rapidly and restore the throughput
of legitimate ﬂows quickly, which indicates the effectiveness
of POSEIDON in coping with DDoS attacks. Note that there
is a small time gap between the attack onset and the defense
taking effect (in seconds), which mainly results from the DDoS
detection time, the execution time of our resource orchestration
module and the program loading time of the Toﬁno switch.
To demonstrate the performance of POSEIDON, we measure
the end-to-end latency for workload trafﬁc at the trafﬁc gen-
erator, based on these six typical DDoS attacks, and compare
it with an NSFOCUS ADS 4020 middlebox [57] and an NFV
system similar to Bohatei [22]. As we can see from Fig. 15, for
3A closer look into our experiments also shows that the IP addresses of
these real-world traces are not very dispersed; the switching ASICs has enough
memory to support the monitor modules. We discuss further on this issue in
Discussion(§IX).
12
01234Number of Switches61218243036Packet Rate (Mpps)PoseidonID firstFig. 11: Received packets before/after
policy transition.
Fig. 12: Broken connections before/after
policy transition.
Fig. 13: Control trafﬁc/workload trafﬁc
ratio.
switch is guaranteed to run at terabit line rate; otherwise it
would already be rejected by the compiler at the compilation
stage [10], [78]. For terabit DDoS attacks, the other two ap-
proaches would require an extremely large number of devices.
In contrast, POSEIDON can achieve this with much lower
device count and much lower cost.
To show the cost reduction of POSEIDON compared with
the other two solutions, TABLE I serves as a good starting
point. As we can see, programmable switches can reduce the
equipment cost by nearly two orders of magnitude, and reduce
the power consumption by nearly three orders of magnitude.
Although POSEIDON requires a small number of servers to
assist programmable switches, the order of magnitude will
not change drastically. Similar results also been obtained by
a recent project that evaluates the power consumption of in-
network computing [78], which shows that switching ASICs
can reduce power consumption by 1000x compared with
commodity CPU.
IX. DISCUSSION
Security of POSEIDON. POSEIDON shares a similar two-
layer architecture as classic SDN, a control
layer and an
infrastructure layer. However, it is resilient to attack vectors
in classic SDNs that target the control channel [71], [33],
[91], [12], because it does not adopt the reactive event pro-
cessing paradigm in OpenFlow-based SDN. However, there
are still several potential vulnerabilities. First, attackers may
use spoofed trafﬁc to mislead monitor modules to invoke the
wrong action modules, or overwhelm the stateful memory
in switching ASICs (e.g., hash table in count and aggr
primitives). This may further lead to statistical inaccuracy and
unexpected hash collisions. Actually, spoofed IP trafﬁc is a
challenge that is not speciﬁc to POSEIDON; it also affects a
number of other switch-based systems as listed in §X. We
observe that a recent research effort, NetHCF [6], [44], tries
to ﬁlter spoofed IP trafﬁc with programmable switches, which
can be a good starting point
to prevent statistic pollution
and reduce unnecessary false positive. It should be easy to
integrate such mechanisms into POSEIDON. Without spoofed
trafﬁc, the monitor modules in POSEIDON (5∼10 MB SRAM
per stage in the latest programmable switch) can guarantee a
very low false positive (e.g., less than 1%) for a few million
buckets. This could potentially accommodate millions of IPs
and billions of packets per second. This has also been validated
by several other recent research projects [49], [86], which have
developed various sketches with programmable switches to
Fig. 14: Throughput restoration for legitimate ﬂows.
Fig. 15: Latency in trafﬁc scrubbing center.
most types of attacks, POSEIDON reduces packet processing
latency in scrubbing centers by two orders of magnitude com-
pared with the middlebox and the NFV system. In particular,
POSEIDON processes packets within hundreds of nanoseconds
while the middlebox or the NFV system requires tens of
microseconds. This demonstrates a signiﬁcant performance
improvement, which is crucial for the requirements of latency-
sensitive services in today’s datacenters. For HTTP ﬂood, we
use puzzle, which can only be implemented on the servers;
so the latency beneﬁt of POSEIDON is not as obvious and
latency results are comparable. Since we do not have access
to terabit-level trafﬁc generators at this moment, we are not
able to evaluate the throughput of our prototype using extreme
pressure tests. However, in principle, POSEIDON can defend
against ∼Tbps attack trafﬁc with a small number of devices
(including programmable switches and commodity servers).
This is because a compiled P4 program on a programmable
13
0123456Time (s)020406080100Received Packets Ratio (%)T1 PoseidonT2 PoseidonT3 PoseidonT1 w/o PoseidonT2 w/o PoseidonT3 w/o Poseidon0123456Time (s)020406080Broken Connection Ratio (%)T1 PoseidonT2 PoseidonT3 PoseidonT1 w/o PoseidonT2 w/o PoseidonT3 w/o Poseidon0102030405060708090Attack Packets / Normal Packets (%)01234Control Message Ratio (%)T1T2T3   0  10  20  30Speed (Gbps)Attack StartsAttack StopsSender SideAttack UDP PacketsLegitimate TCP Flows010203040Time (s)   0  10  20  30Speed (Gbps)Defense Takes EffectReceiver SideSYNFloodDNSAmplicationHTTPFloodSlowlorisUDPFloodElephantFlow 100101102103104105106Latency(ns)MiddleboxBohateiPoseidonconduct network monitoring under terabit trafﬁc. In addition,
we can also leverage external DRAM in servers to alleviate the
memory pressure [42] in programmable switches. This would
make much more memory available for sketches and achieve
much lower hash collision rates (or false positives).
Second, attackers may change the attack composition dy-
namically within seconds so that POSEIDON cannot respond
in a timely manner. A potential solution is to further optimize
the performance of our orchestration component using more
powerful servers, and to leverage more advanced heuristics
to solve the ILP problem. In addition, we can also use the
switch-only primitives for long-lived attacks, and only involve
the servers for short-lived attacks. In this way, defenses against
short-lived attacks will not need to recompile the switch
programs, avoiding the need to trigger frequent policy changes.
We leave the detailed exploration of these security problems
to our future work.
Extensibility of POSEIDON. POSEIDON has a set of mod-
ular primitives for monitoring, analysis, and attack response.
Operators could easily develop more defense primitives in this
framework. To integrate a new defense primitive into the exist-
ing defense library, operators should deﬁne the new primitive,
analyze its implementation with respect to switching ASICs
constraints, calculate its resource usage, and extend the defense
library with this new primitive. Then, the new primitive could
be loaded into our POSEIDON framework and used with other
primitives. Note that although POSEIDON cannot handle zero-
day DDoS attacks directly, the programmability and modular-
ity properties of POSEIDON would accelerate the deployment
of new defense mechanisms signiﬁcantly. This beneﬁt cannot
be achieved with traditional proprietary middleboxes, even
NFV-based defense systems.
Automation of POSEIDON. Current POSEIDON requires some
human intervention for writing the defense policies. This can
be further automated if there are no zero-day DDoS attacks.
Operators can set a defense policy for each DDoS attack
beforehand, and POSEIDON would load the corresponding
policies when DDoS attacks are detected. Nevertheless, for
zero-day DDoS attacks, human intervention is unavoidable.
Operators need to analyze the characteristics of the new DDoS
attacks, and may potentially need to extend the POSEIDON
primitives with more defense strategies.
X. RELATED WORK
There is a long body of works on DDoS attacks and
defenses, for which comprehensive surveys exist [90], [52].
Here, we brieﬂy discuss the other most related topics.
SDN/NFV-based DDoS Defense. Some works have been de-
voted to defending against DDoS attacks with SDN/NFV from
various perspectives. Bohatei [22] leverages NFV and SDN
to achieve ﬂexible and elastic DDoS defense. Xu et al. [85]
propose an adaptive approach using limited switch TCAM to
balance the coverage and granularity of DDoS detection. Afek
et al. [1] propose to ﬁlter the spooﬁng trafﬁc with OpenFlow
switches. By contrast, POSEIDON proposes a cost-efﬁcient