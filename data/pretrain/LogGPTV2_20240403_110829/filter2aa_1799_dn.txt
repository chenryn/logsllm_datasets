Note that in this case, the module name is empty because the syscall provider does not specify 
any name (all the syscalls are implicitly provided by the NT kernel).
The PID and FBT providers instead dynamically generate probes based on the process or 
kernel image to which they are applied (and based on the currently available symbols). For ex-
ample, to correctly list the PID probes of a process, you should first get the process ID (PID) of the 
process that you want to analyze (by simply opening the Task Manager and selecting the Details 
property sheet; in this example, we are using Notepad, which in the test system has PID equal to 
8020). Then execute DTrace with the following command:
dtrace -ln pid8020:::entry > pid_notepad.txt
This lists all the probes on function entries generated by the PID provider for the Notepad 
process. The output will contain a lot of entries. Note that if you do not have the symbol store 
path set, the output will not contain any probes generated by private functions. To restrict the 
output, you can add the name of the module:
dtrace.exe -ln pid8020:kernelbase::entry >pid_kernelbase_notepad.txt
This yields all the PID probes generated for function entries of the kernelbase.dll module 
mapped in Notepad. If you repeat the previous two commands after having set the symbol store 
path with the following command,
set _NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/download/symbols
you will find that the output is much different (and also probes on private functions). 
As explained in the “The Function Boundary Tracing (FBT) and Process (PID) providers” section 
later in this chapter, the PID and FBT provider can be applied to any offset in a function’s code. 
The following command returns all the offsets (always located at instruction boundary) in which 
the PID provider can generate probes on the SetComputerNameW function of Kernelbase.dll:
SetComputerNameW function of Kernelbase.dll:
SetComputerNameW
dtrace.exe -ln pid8020:kernelbase:SetComputerNameW: 
528 
CHAPTER 10 Management, diagnostics, and tracing
Internal architecture
As explained in the “Enabling DTrace and listing the installed providers” experiment earlier in this chap-
ter, in Windows 10 May 2020 Update (20H1), some components of DTrace should be installed through 
an external package. Future versions of Windows may integrate DTrace completely in the OS image. 
Even though DTrace is deeply integrated in the operating system, it requires three external compo-
nents to work properly. These include both the NT-specific implementation and the original DTrace 
code released under the free Common Development and Distribution License (CDDL), which is down-
loadable from https://github.com/microsoft/DTrace-on-Windows/tree/windows.
As shown in Figure 10-37, DTrace in Windows is composed of the following components:
I 
DTrace.sys The DTrace extension driver is the main component that executes the actions as-
sociated with the probes and stores the results in a circular buffer that the user-mode applica-
tion obtains via IOCTLs.
I 
DTrace.dll The module encapsulates LibDTrace, which is the DTrace user-mode engine.
It implements the Compiler for the D scripts, sends the IOCTLs to the DTrace driver, and is the
main consumer of the circular DTrace buffer (where the DTrace driver stores the output of
the actions).
I 
DTrace.exe The entry point executable that dispatches all the possible commands (specified
through the command line) to the LibDTrace.
.d
DTrace.exe
Dbghelp.dll
Symbol
Store
LibDTrace
(DTrace.dll)
User Mode
Kernel Mode
Windload
NT Kernel
FBT
PID
SYSCALL
ETW
DTrace.sys
FIGURE 10-37 DTrace internal architecture.
To start the dynamic trace of the Windows kernel, a driver, or a user-mode application, the user 
just invokes the DTrace.exe main executable specifying a command or an external D script. In both 
cases, the command or the file contain one or more probes and additional actions expressed in the D 
programming language. DTrace.exe parses the input command line and forwards the proper request 
CHAPTER 10 Management, diagnostics, and tracing
529
to the LibDTrace (which is implemented in DTrace.dll). For example, when started for enabling one or 
more probes, the DTrace executable calls the internal dtrace_program_fcompile function implemented 
in LibDTrace, which compiles the D script and produces the DTrace Intermediate Format (DIF) bytecode 
in an output buffer. 
Note Describing the details of the DIF bytecode and how a D script (or D commands) is 
compiled is outside the scope of this book. Interested readers can find detailed documenta-
tion in the OpenDTrace Specification book (released by the University of Cambridge), which 
is available at https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-924.pdf.
While the D compiler is entirely implemented in user-mode in LibDTrace, to execute the compiled DIF 
bytecode, the LibDtrace module just sends the DTRACEIOC_ENABLE IOCTL to the DTrace driver, which 
implements the DIF virtual machine. The DIF virtual machine is able to evaluate each D clause expressed 
in the bytecode and to execute optional actions associated with them. A limited set of actions are avail-
able, which are executed through native code and not interpreted via the D virtual machine.
As shown earlier in Figure 10-37, the DTrace extension driver implements all the providers. Before 
discussing how the main providers work, it is necessary to present an introduction of the DTrace initial-
ization in the Windows OS.
DTrace initialization
The DTrace initialization starts in early boot stages, when the Windows loader is loading all the mod-
ules needed for the kernel to correctly start. One important part to load and validate is the API set file 
(apisetschema.dll), which is a key component of the Windows system. (API Sets are described in Chapter 
3 of part 1.) If the DTRACE_ENABLED BCD element is set in the boot entry (value 0x26000145, which 
can be set through the dtrace readable name; see Chapter 12 for more details about BCD objects), 
the Windows loader checks whether the dtrace.sys driver is present in the %SystemRoot%\System32\
Drivers path. If so, it builds a new API Set schema extension named ext-ms-win-ntos-trace-l1-1-0. The 
schema targets the Dtrace.sys driver and is merged into the system API set schema (OslApiSetSchema). 
Later in the boot process, when the NT kernel is starting its phase 1 of initialization, the TraceInitSystem 
function is called to initialize the Dynamic Tracing subsystem. The API is imported in the NT kernel 
through the ext-ms-win-ntos-trace-l1-1-0.dll API set schema. This implies that if DTrace is not enabled by 
the Windows loader, the name resolution would fail, and the function will be basically a no op.
The TraceInitSystem has the important duty of calculating the content of the trace callouts array, 
which contains the functions that will be called by the NT kernel when a trace probe fires. The array is 
stored in the KiDynamicTraceCallouts global symbol, which will be later protected by Patchguard to 
prevent malicious drivers from illegally redirecting the flow of execution of system routines. Finally, 
through the TraceInitSystem function, the NT kernel sends to the DTrace driver another important ar-
ray, which contains private system interfaces used by the DTrace driver to apply the probes. (The array 
is exposed in a trace extension context data structure.) This kind of initialization, where both the DTrace 
driver and the NT kernel exchange private interfaces, is the main motivation why the DTrace driver is 
called an extension driver.
530 
CHAPTER 10 Management, diagnostics, and tracing
The Pnp manager later starts the DTrace driver, which is installed in the system as boot driver, and 
calls its main entry point (DriverEntry). The routine registers the \Device\DTrace control device and its 
symbolic link (\GLOBAL??\DTrace). It then initializes the internal DTrace state, creating the first DTrace 
built-in provider. It finally registers all the available providers by calling the initialization function of 
each of them. The initialization method depends on each provider and usually ends up calling the 
internal dtrace_register function, which registers the provider with the DTrace framework. Another 
common action in the provider initialization is to register a handler for the control device. User-mode 
applications can communicate with DTrace and with a provider through the DTrace control device, 
which exposes virtual files (handlers) to providers. For example, the user-mode LibDTrace communi-
cates directly with the PID provider by opening a handle to the \\.\DTrace\Fasttrap virtual file (handler).
The syscall provider
When the syscall provider gets activated, DTrace ends up calling the KeSetSystemServiceCallback 
routine, with the goal of activating a callback for the system call specified in the probe. The routine is 
exposed to the DTrace driver thanks to the NT system interfaces array. The latter is compiled by the 
NT kernel at DTrace initialization time (see the previous section for more details) and encapsulated in 
an extension context data structure internally called KiDynamicTraceContext. The first time that the 
KeSetSystemServiceCallback is called, the routine has the important task of building the global service 
trace table (KiSystemServiceTraceCallbackTable), which is an RB (red-black) tree containing descrip-
tors of all the available syscalls. Each descriptor includes a hash of the syscall’s name, its address, and 
number of parameters and flags indicating whether the callback is enabled on entry or on exit. The NT 
kernel includes a static list of syscalls exposed through the KiServicesTab internal array.
After the global service trace table has been filled, the KeSetSystemServiceCallback calculates the 
hash of the syscall’s name specified by the probe and searches the hash in the RB tree. If there are 
no matches, the probe has specified a wrong syscall name (so the function exits signaling an error). 
Otherwise, the function modifies the enablement flags located in the found syscall’s descriptor and 
increases the number of the enabled trace callbacks (which is stored in an internal variable). 
When the first DTrace syscall callback is enabled, the NT kernel sets the syscall bit in the global 
KiDynamicTraceMask bitmask. This is very important because it enables the system call handler 
(KiSystemCall64) to invoke the global trace handlers. (System calls and system service dispatching have 
been discussed extensively in Chapter 8.)
This design allows DTrace to coexist with the system call handling mechanism without having any 
sort of performance penalty. If no DTrace syscall probe is active, the trace handlers are not invoked. A 
trace handler can be called on entry and on exit of a system call. Its functionality is simple. It just scans 
the global service trace table looking for the descriptor of the system call. When it finds the descrip-
tor, it checks whether the enablement flag is set and, if so, invokes the correct callout (contained in the 
global dynamic trace callout array, KiDynamicTraceCallouts, as specified in the previous section). The 
callout, which is implemented in the DTrace driver, uses the generic internal dtrace_probe function to 
fire the syscall probe and execute the actions associated with it.
CHAPTER 10 Management, diagnostics, and tracing
531
The Function Boundary Tracing (FBT) and Process (PID) providers
Both the FBT and PID providers are similar because they allow a probe to be enabled on any function 
entry and exit points (not necessarily a syscall). The target function can reside in the NT kernel or as 
part of a driver (for these cases, the FBT provider is used), or it can reside in a user-mode module, which 
should be executed by a process. (The PID provider can trace user-mode applications.) An FBT or PID 
probe is activated in the system through breakpoint opcodes (INT 3 in x86, BRK in ARM64) that are 
written directly in the target function’s code. This has the following important implications:
I 
When a PID or FBT probe raises, DTrace should be able to re-execute the replaced instruction
before calling back the target function. To do this, DTrace uses an instruction emulator, which,
at the time of this writing, is compatible with the AMD64 and ARM64 architecture. The emula-
tor is implemented in the NT kernel and is normally invoked by the system exception handler
while dealing with a breakpoint exception.
I 
DTrace needs a way to identify functions by name. The name of a function is never compiled in
the final binary (except for exported functions). DTrace uses multiple techniques to achieve this,
which will be discussed in the “DTrace type library” section later in this chapter.
I 
A single function can exit (return) in multiple ways from different code branches. To identify the
exit points, a function graph analyzer is required to disassemble the function’s instructions and
find each exit point. Even though the original function graph analyzer was part of the Solaris
code, the Windows implementation of DTrace uses a new optimized version of it, which still lives
in the LibDTrace library (DTrace.dll). While user-mode functions are analyzed by the function
graph analyzer, DTrace uses the PDATA v2 unwind information to reliably find kernel-mode
function exit points (more information on function unwinds and exception dispatching is avail-
able in Chapter 8). If the kernel-mode module does not make use of PDATA v2 unwind informa-
tion, the FBT provider will not create any probes on function returns for it.
DTrace installs FBT or PID probes by calling the KeSetTracepoint function of the NT kernel exposed 
through the NT System interfaces array. The function validates the parameters (the callback pointer 
in particular) and, for kernel targets, verifies that the target function is located in an executable code 
section of a known kernel-mode module. Similar to the syscall provider, a KI_TRACEPOINT_ENTRY data 
structure is built and used for keeping track of the activated trace points. The data structure contains 
the owning process, access mode, and target function address. It is inserted in a global hash table, 
KiTpHashTable, which is allocated at the first time an FBT or PID probe gets activated. Finally, the single 
instruction located in the target code is parsed (imported in the emulator) and replaced with a break-
point opcode. The trap bit in the global KiDynamicTraceMask bitmask is set.
For kernel-mode targets, the breakpoint replacement can happen only when VBS (Virtualization 
Based Security) is enabled. The MmWriteSystemImageTracepoint routine locates the loader data table 
entry associated with the target function and invokes the SECURESERVICE_SET_TRACEPOINT secure 
call. The Secure Kernel is the only entity able to collaborate with HyperGuard and thus to render the 
breakpoint application a legit code modification. As explained in Chapter 7 of Part 1, Kernel Patch 
protection (also known as Patchguard) prevents any code modification from being performed on the 
NT kernel and some essential kernel drivers. If VBS is not enabled on the system, and a debugger is not 
attached, an error code is returned, and the probe application fails. If a kernel debugger is attached, 
532 
CHAPTER 10 Management, diagnostics, and tracing
the breakpoint opcode is applied by the NT kernel through the MmDbgCopyMemory function. 
(Patchguard is not enabled on debugged systems.)
When called for debugger exceptions, which may be caused by a DTrace’s FTB or PID probe firing, 
the system exception handler (KiDispatchException) checks whether the “trap” bit is set in the global 
KiDynamicTraceMask bitmask. If it is, the exception handler calls the KiTpHandleTrap function, which 
searches into the KiTpHashTable to determine whether the exception occurred thanks to a registered 
FTB or PID probe firing. For user-mode probes, the function checks whether the process context is 
the expected one. If it is, or if the probe is a kernel-mode one, the function directly invokes the DTrace 
callback, FbtpCallback, which executes the actions associated with the probe. When the callback 
completes, the handler invokes the emulator, which emulates the original first instruction of the target 
function before transferring the execution context to it.
EXPERIMENT: Tracing dynamic memory
In this experiment, you dynamically trace the dynamic memory applied to a VM. Using Hyper-V 
Manager, you need to create a generation 2 Virtual Machine and apply a minimum of 768 MB 
and an unlimited maximum amount of dynamic memory (more information on dynamic memory 
and Hyper-V is available in Chapter 9). The VM should have the May 2019 (19H1) or May 2020 
(20H1) Update of Windows 10 or later installed as well as the DTrace package (which should be 
enabled as explained in the “Enabling DTrace and listing the installed providers” experiment from 
earlier in this chapter).
The dynamic_memory.d script, which can be found in this book’s downloadable resources, 
needs to be copied in the DTrace directory and started by typing the following commands in an 
administrative command prompt window:
cd /d "c:\Program Files\DTrace" 
dtrace.exe -s dynamic_memory.d
With only the preceding commands, DTrace will refuse to compile the script because of an 
error similar to the following:
dtrace: failed to compile script dynamic_memory.d: line 62: probe description fbt:nt:MiRem
ovePhysicalMemory:entry does not match any probes
This is because, in standard configurations, the path of the symbols store is not set. The script 
attaches the FBT provider on two OS functions: MmAddPhysicalMemory, which is exported from 
the NT kernel binary, and MiRemovePhysicalMemory, which is not exported or published in the 
public WDK. For the latter, the FBT provider has no way to calculate its address in the system. 
DTrace can obtain types and symbol information from different sources, as explained in the 
“DTrace type library” section later in this chapter. To allow the FBT provider to correctly work with 
internal OS functions, you should set the Symbol Store’s path to point to the Microsoft public 
symbol server, using the following command:
set _NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/download/symbols
EXPERIMENT: Tracing dynamic memory
In this experiment, you dynamically trace the dynamic memory applied to a VM. Using Hyper-V 
Manager, you need to create a generation 2 Virtual Machine and apply a minimum of 768 MB 
and an unlimited maximum amount of dynamic memory (more information on dynamic memory 
and Hyper-V is available in Chapter 9). The VM should have the May 2019 (19H1) or May 2020 
(20H1) Update of Windows 10 or later installed as well as the DTrace package (which should be 
enabled as explained in the “Enabling DTrace and listing the installed providers” experiment from 
earlier in this chapter).
The dynamic_memory.d script, which can be found in this book’s downloadable resources, 
needs to be copied in the DTrace directory and started by typing the following commands in an 
administrative command prompt window:
cd /d "c:\Program Files\DTrace"
dtrace.exe -s dynamic_memory.d
With only the preceding commands, DTrace will refuse to compile the script because of an 
error similar to the following:
dtrace: failed to compile script dynamic_memory.d: line 62: probe description fbt:nt:MiRem
ovePhysicalMemory:entry does not match any probes
This is because, in standard configurations, the path of the symbols store is not set. The script 
attaches the FBT provider on two OS functions: MmAddPhysicalMemory, which is exported from 
MmAddPhysicalMemory, which is exported from 
MmAddPhysicalMemory
the NT kernel binary, and MiRemovePhysicalMemory, which is not exported or published in the 
MiRemovePhysicalMemory, which is not exported or published in the 
MiRemovePhysicalMemory
public WDK. For the latter, the FBT provider has no way to calculate its address in the system. 
DTrace can obtain types and symbol information from different sources, as explained in the 
“DTrace type library” section later in this chapter. To allow the FBT provider to correctly work with 
internal OS functions, you should set the Symbol Store’s path to point to the Microsoft public 
symbol server, using the following command:
set _NT_SYMBOL_PATH=srv*C:\symbols*http://msdl.microsoft.com/download/symbols
CHAPTER 10 Management, diagnostics, and tracing
533
After the symbol store’s path is set, if you restart DTrace targeting the dynamic_memory.d 
script, it should be able to correctly compile it and show the following output:
The Dynamic Memory script has begun.
Now you should simulate a high-memory pressure scenario. You can do this in multiple 
ways—for example, by starting your favorite browser and opening a lot of tabs, by starting a 3D 
game, or by simply using the TestLimit tool with the -d command switch, which forces the system 
to contiguously allocate memory and write to it until all the resources are exhausted. The VM 
worker process in the root partition should detect the scenario and inject new memory in the 
child VM. This would be detected by DTrace:
Physical memory addition request intercepted. Start physical address 0x00112C00, Number of 
pages: 0x00000400. 
   Addition of 1024 memory pages starting at PFN 0x00112C00 succeeded!
In a similar way, if you close all the applications in the guest VM and you recreate a high-
memory pressure scenario in your host system, the script would be able to intercept dynamic 
memory’s removal requests:
Physical memory removal request intercepted. Start physical address 0x00132000, Number of 
pages: 0x00000200. 
   Removal of 512 memory pages starting at PFN 0x00132000 succeeded!
After interrupting DTrace using Ctrl+C, the script prints out some statistics information:
Dynamic Memory script ended. 
Numbers of Hot Additions: 217 
Numbers of Hot Removals: 1602 
Since starts the system has gained 0x00017A00 pages (378 MB).
If you open the dynamic_memory.d script using Notepad, you will find that it installs a total of 
six probes (four FBT and two built-in) and performs logging and counting actions. For example, 
fbt:nt:MmAddPhysicalMemory:return 
/ self->pStartingAddress != 0 /
installs a probe on the exit points of the MmAddPhysicalMemory function only if the starting 
physical address obtained at function entry point is not 0. More information on the D program-
ming language applied to DTrace is available in the The illumos Dynamic Tracing Guide book, 