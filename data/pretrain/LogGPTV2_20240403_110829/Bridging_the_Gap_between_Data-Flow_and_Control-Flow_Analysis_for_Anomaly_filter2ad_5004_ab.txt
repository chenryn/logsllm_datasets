of system call open is a long, which is a ﬁle descriptor;
while ﬁle descriptors in system calls read and write are
deﬁned as unsigned int. This suggests that some con-
solidation of the 111 data types is required. For this purpose
and to simplify our analysis, we group the large number
of data types into a small number of “Macro-Types”. Any
attributes with the same Macro-Type are considered com-
parable and their relations are candidate rules to be learned.
Table 2 shows the 5 Macro-Types we deﬁne, as well as some
of their members (originally deﬁned data types).
Macro-Type
Data types deﬁned in Linux kernel 2.6.22
Integer
Integer*
String*
Struct*
Others
long, int, unsigned int, unsigned long, size t, pid t, etc.
int user *, time t user *, old sigset t user *, etc.
char user *, const char user *, etc.
struct old kernel stat user *, struct tms user *, etc.
struct pt regs, void user *,
sighandler t, etc.
Table 2. Five Macro-Types in our system
Table 3 show the same system call pattern as shown in
Table 1 before and after the consolidation of data types, re-
spectively. Note that each system call has 6 attributes as-
sociated, out of which one is used to represent the return
address (attr0) and the other 5 are used to represent the ﬁrst
5 arguments of the system call1. We ﬁll an unused attributes
with “null” if there are less than 5 arguments.
3.3.2 Expressions, operators, and statements
A simple example of the relations that we want to learn
could be of the form “The ﬁrst attribute of one system call
in a particular system call pattern equals to the second at-
tribute of another system call in another pattern”. We call
this simple relation a statement. Within a statement, we call
1Of the 324 system calls deﬁned in the Linux kernel 2.6.22, only 8 of
them have more than 5 arguments yet are rarely seen in our training data.
We do not examine these additional system call arguments in this project
since the small number of appearances does not sufﬁce to reveal any rule.
the attributes expressions and the relation (e.g., “equal”) an
operator. To show the expressiveness of the relations our
system is able to learn, we describe what expressions, oper-
ators, and statements are in this subsection.
An expression (denoted e) could be either an attribute
(denoted a) or a constant (denoted c). A statement (denoted
s) deﬁnes the relation between two expressions, where the
relation is deﬁned by an operator (denoted o). Simple oper-
ators include equal to, not equal to, greater than, less than
and etc. Note that a statement can only be formed by two
expressions that are comparable using a corresponding op-
erator. Two expressions are comparable if they are of the
same Macro-Type (Section 3.3.1), and in order to simplify
our system, we only deﬁne 5 Macro-Types as shown in Ta-
ble 2. Two statements and a logical operator could be used
to form another statement, e.g., “the ﬁrst attribute equals 1
AND the second attribute equals 2”. In summary,
a ::= attribute
::= constant
c
::= a|c
e
::= equal|greater than|AND|GIVEN|etc.
::= e o e|s o s
o
s
We also allow functions to be deﬁned. A function takes
in an expression as input and outputs another expression.
E.g., a function can be used to ﬁnd the substring, which,
in turn, can help to form a statement that two string ex-
pressions share the same preﬁx. Another very important
use of functions is to dereference a pointer. In many cases
it will make more sense to compare the data that the at-
tributes point to instead of comparing the attributes them-
selves. E.g., a function can be deﬁned to dereference a par-
ticular member in a structure.
Functions are very ﬂexible and can help describe a wide
variety of relations, although here we do not discuss further
on other possible formats a function can take.
3.3.3 Three Rule Sets
System call patterns provide the context information for us
to differentiate the same system call in different execution
context (different patterns). Attributes in a statement may
belong to system calls in the same pattern, in the repeated
occurrences of one pattern, or in different patterns. We clas-
sify statements into three different Rule Sets that represent
different types of relations among system calls.
Relations in different Rule Sets may play different roles
in detecting intrusions. For example, in a particular pro-
gram, training may reveal that attributes of system calls
within the same pattern are closely related, whereas in an-
other program, attributes of system calls from repeating pat-
terns may have stronger relations. By classifying relations
395395
syscall Number
syscall name
attr0
attr1
attr2
attr3
attr4
attr5
Before Consolication
After Consolication
168
poll
long
003
read
size t
struct pollfd user*
unsigned int
unsigned int
long
null
null
char*
size t
null
null
078
gettimeofday
long
struct timeval user*
struct timezone user*
null
null
null
168
poll
Integer
Struct*
Integer
Integer
null
null
003
read
Integer
Integer
String*
Integer
null
null
078
gettimeofday
Integer
Struct*
Struct*
null
null
null
Table 3. System call arguments and return values before and after data type consolidation
into different Rule Sets, we may assign different weights to
them for online monitoring, though we leave it as our future
work and in the implementation in Section 4, we assign the
same weights to simplify our system.
Rule Set A contains statements in which attributes be-
long to system calls in the same pattern. Recall that a sys-
tem call pattern corresponds to the performance of a single
task by the application. System call made within one pattern
are closely related to one another as they are steps in per-
forming the same task. Statements in Rule Set A represent
the relations among these system calls. A typical example
of such statement could be
P [i].S[j].A[k] = P [i].S[j(cid:2)].A[k(cid:2)]
where P [i] denotes a particular pattern we extract from sys-
tem call sequences (i is just an index to denote different pat-
terns), P [i].S[j] denotes the jth system call of pattern P [i],
and P [i].S[j].A[k] denotes the kth attribute of P [i].S[j]
(A[0] represents the return value).
Rule Set B contains statements in which attributes be-
long to system calls in repeated occurrences of a pattern. It
is very common that the same system call pattern is used
repeatedly to perform a long task. E.g., a system call pat-
tern may be used to read a small portion of data, and such
pattern needs to be used repeatedly in order to read data
from a large ﬁle. In these cases, there is also close relations
among the attributes of system calls from repeated patterns.
A typical example of statements in Rule Set B could be
P [i].S[j].A[k] = c2
P [i].S[j].A[k] = c1 GIVEN Occm−1
Occm
where Occm
P [i].S[j].A[k] denotes the mth occurrence of
P [i].S[j].A[k]. This statement says that if the kth attribute
of the system call P [i].S[j] equals to c2, then the same at-
tribute of the same system call in the next occurrence of the
pattern must equal to c1.
Rule Set C contains statements in which attributes be-
long to system calls in different patterns. These statements
are used to govern system calls from different patterns that
are closely related.
Intuitively, although one system call
pattern corresponds to a particular task to be performed, in
many cases a complicated task has to be done by a sequence
396396
of patterns. Attributes in these patterns could be highly cor-
related, and we use Rule Set C to represent them. A typical
example of statements in Rule Set C could be
P [i].S[j].A[k] dist= P [i(cid:2)].S[j(cid:2)].A[k(cid:2)](dist < maxdist)
where dist represents the number of patterns between P [i]
and P [i(cid:2)] in the system call sequence, and maxdist is a
threshold denoting the maximum distance between the two
patterns where the statement is valid.
3.3.4 Minimum support and conﬁdence level
Many statements can be found from a small size of train-
ing data. However, many of them may not be reliable and
may cause false positives and false negatives. We deﬁne two
thresholds to ﬁlter out statements that are not very reliable.
As in association rule mining process, two measure-
ments support and conﬁdence are calculated for each rule.
In our system, the support of a statement is the number of
times a statement is found valid in the training data. We
deﬁne a threshold minsup to specify the lower bound of the
support for a statement to be accepted in our Rule Sets. The
conﬁdence of a statement is (conditional) probability that
the statement is found valid in the training data.
The values of minsup and minconf play an important
role in tuning the intrusion detection system to have the
right trade-off between false positives and false negatives.
It is not our objective to propose comprehensive techniques
for ﬁnding the right values for these two thresholds in this
paper. However, we provide our evaluation results in Sec-
tion 4 with our choice of the thresholds to demonstrate the
detection capability of our system.
For our rule generation, we ﬁrst match the attributes in
pairs when two system calls are from a single pattern, from
repeating occurrences of a pattern, or from two different
patterns. A pair of attributes can form a simple statement
with a speciﬁc operator. We calculate the support and con-
ﬁdence level by checking the relation between the values of
the two attributes involved in the statement. We accept a
statement with support and conﬁdence over the thresholds
minsup and minconf as a rule in our model and add it to
the corresponding Rule Set. These simple statements are
then further extended to form more complicated statements
following the format s o s, and the support and conﬁdence
level are measured similarly to decide if the newly formed
statements should be accepted or not. The iterative process
of forming more and more complicated statements will stop
when these two levels drop below the thresholds.
3.4 Online monitoring
Relations learned can be used for online monitoring. The
online monitor intercepts system calls made by the process
in real time, and analyzes the system call along with its ar-
guments and return value. Once our detection system rec-
ognizes one pattern from the system call sequence, we test
the arguments and return values on all the rules with this
pattern involved in three Rule Sets we constructed during
the training. An alarm will be raised when the cumulative
number of abnormal behavior reaches a previously deﬁned
threshold. We present the experimental results for measur-
ing the online monitoring overhead in Section 4.6.
4 Evaluation
In this section, we ﬁrst present our experimental setup
and some examples of relations learned in each Rule Set
(Section 4.1). In Section 4.2, we show that our system is
capable of detecting real attacks with a couple of examples.
The advantages of our technique when compared with prior
ones are shown in Section 4.3. In particular, we show that
our technique is able to learn data-ﬂow properties that can-
not be learned by previous data-ﬂow analysis techniques.
The performance of our system, including the false alarm
rate, speed of convergence, as well as the overhead in on-
line monitoring are presented in the last three subsections.
4.1 Experimental
learned
setup and relations
4.1.1 Experimental setup
Our system was implemented on a desktop computer with
Linux kernel 2.6.22 that has 324 system calls deﬁned. We
used Apache2 to host an http server to simulate the
web server of Singapore Management University. We mod-
iﬁed the Linux kernel to intercept system calls made by
the Apache2 web server to obtain real-time system call
information including the system call numbers, arguments
and return values. The static web pages on the Singapore
Management University web server were downloaded and
hosted on our web server. We then made use of the web logs
from the real server to replay requests from August 2007 to
December 2007.
In this part of the evaluation, we replayed 3 days (typi-
cal weekdays) of logs that contain 372, 940 http requests,
and extracted 89 system call patterns which can cover all
the system call sequences in the training data. We group
the 111 data types for the system call arguments and return
values into 5 Macro-Types as shown in Table 2. One of the
simplest form of expressions and statements is used in this
evaluation to show the effectiveness of our system. State-
ments we use are of the form
s ::= f(a1) = f(a2)
That is, we try to ﬁnd rules that govern the equality of
(some property, deﬁned by function f(), of) two system call
attributes. Function f() does simple dereferencing when
the attributes being examined are either integer pointers or
string pointers.
We are interested in ﬁnding statements in all the three
Rule Sets, and let maxdist = 10 in ﬁnding rules in Rule Set
C. Different settings of minsup and minconf are used in our
evaluation to shed light on the settings of the thresholds.
4.1.2 Number of statements in each Rule Set
Figure 2 shows the number of rules learned in each Rule Set
for a number of different settings of minsup and minconf.
104
10 3
102
101
0
0
s
t
n
e
m
e
t
a
t
S
f
o
r
e