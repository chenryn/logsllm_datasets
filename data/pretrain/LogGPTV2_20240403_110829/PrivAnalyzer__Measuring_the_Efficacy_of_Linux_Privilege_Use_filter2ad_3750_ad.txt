   
each instrumented program created by ChronoPriv with the
sample inputs described in Section VII-B and recorded the
number of LLVM instructions executed with each privilege
set and IDs. Table III records the results in the Dynamic
Instruction Count column. The results in Table III show that
solely reducing the available Linux privileges helps reduce
vulnerability to attacks which bind to a privileged port (Attack
3). However, it often fails to mitigate the other attacks.
ping is not vulnerable to any attack we modeled for all
its executed instructions. It needs CAP_NET_RAW to call
socket with SOCK_RAW to create a raw socket. It does
this only once at the very beginning of the program, allow-
ing ping to drop CAP_NET_RAW early in its execution. It
also needs CAP_NET_ADMIN to use the SO_DEBUG and
SO_MARK options in setsockopt in case the -d or -m
ﬂags are speciﬁed on the command line. This is done in a
setup function also executed early during program execution.
Therefore, ping can drop all its privileges very early.
Similar to ping, thttpd also uses privileges early in its
execution (e.g., to bind to a privileged port and to set the
server’s root directory). After all the conﬁguration work is
done, thttpd drops all its privileges.
sshd is vulnerable to attacks 1, 2, and 4 for its entire
execution. It drops CAP_NET_BIND_SERVICE after binding
to a privileged port but retains all its other privileges. The
problem is twofold. First, some of sshd’s signal handlers use
privileges. As signal handlers can be called at any time, any
privileges they use remain live during execution [11]. Second,
we believe that implementation limitations within the AutoPriv
compiler are also responsible. AutoPriv [11] uses a conserva-
tively correct call graph when propagating information about
privilege use inter-procedurally. When sshd creates a child
process to handle a client connection, the child process enters a
loop that continually reads and processes data from the client.
The privileges remain live during this loop. We have found an
indirect function call within this loop. Since AutoPriv creates
an over-approximation of the targets of the indirect function
call [11], it probably thinks that all the functions which raise
privileges are targets of this indirect call and, consequently,
keeps these privileges alive during the loop. The privileges are
dead after the loop, but sshd doesn’t exit the loop until the
client connection closes. A more accurate call graph analysis
may improve AutoPriv’s ability to identify when privileges
can be safely removed using priv_remove().
599
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:55 UTC from IEEE Xplore.  Restrictions apply. 
TABLE IV: Lines of Code Changed for Refactored Programs
Added
Deleted
shadow library code
7
76
passwd.c
23
13
su.c
35
6
The passwd program is vulnerable to attacks on /de-
v/mem and our denial of service attack (attacks 1, 2, and
4) for 63% of its execution. passwd needs CAP_DAC_-
READ_SEARCH to retrieve the user’s password entry from
the /etc/shadow password database using getspnam().
It also uses CAP_SETUID to call setuid(0) to set its real
and saved user ID to root to ignore unexpected signals (Linux
requires a process’s effective or real UID to match either
the real or saved UID of a target process when sending a
signal [2]). The passwd program then needs CAP_DAC_-
OVERRIDE so that it can replace the old shadow database
with a new one and to lock a lock ﬁle, preventing concurrent
executions of the passwd program from interfering with each
other. It needs this privilege because, as written, the passwd
program makes minimal assumptions about which user owns
the /etc directory and the /etc/shadow ﬁle (it explicitly
uses stat() to ﬁnd the owner of /etc/shadow and then
uses chown() to ensure the new /etc/shadow ﬁle it
creates is owned by the same user). CAP SETUID is kept for
63% of passwd’s execution and CAP DAC OVERRIDE is
used near the end of the program, so the program is vulnerable
to attacks 1, 2, and 4 for over half its execution.
Similar to passwd, su also needs CAP_DAC_READ_-
SEARCH to call getspnam() to read passwords from the
/etc/shadow shadow password database. If the operating
system has a sulog ﬁle, su then needs CAP_SETGID to
change the effective group ID to the group ID of sulog so
that su can write to the sulog ﬁle. The su program then
needs CAP_SETUID and CAP_SETGID to change the current
process’s user IDs, groups IDs, and supplementary group list
to the IDs of the target user to which it is switching. These two
operations occur very late in execution, and this is why su is
vulnerable to attacks 1, 2, and 4 for 88% of its execution.
D. Security Refactoring Process
The results in Table III show that simply dropping Linux
privileges when no longer needed may not sufﬁce. While
ping is invulnerable to all
the attacks we modeled and
thttpd is invulnerable to all attacks for more than 90% of its
execution, passwd, su and sshd remain vulnerable to most
of the attacks for most of their execution time. PrivAnalyzer
reveals the similarity among these programs; they retain pow-
erful privileges until late in their execution. This observation
led us to investigate whether we could improve their resistance
to privilege escalation by refactoring their code. We chose
two of the programs, passwd and su, and we re-evaluated
their privilege use and vulnerability under our attack model
with our tool. We chose these two programs because they are
relatively small but still use powerful Linux privileges, such
as CAP_SETUID and CAP_CHOWN. We describe our results
for each program below. We refactored the versions of the two
programs that use priv_raise and priv_lower (not the
original versions that run as root). Our refactoring requires
very minor source code changes. Table IV shows the amount
of source code we changed.
1) Refactored passwd: As Table III shows, CAP_SE-
TUID is available for 63% of passwd’s execution, and
CAP_OWNER, CAP_FOWNER, and CAP_DAC_OVERRIDE are
available for more than 99% of executed instructions. These
four privileges are extremely powerful. With CAP_SETUID,
a process can change its effective user ID to match the owner
of any ﬁle. It can then change the ﬁle’s permission bits and,
subsequently, open the ﬁle for reading and writing without
using any other privileges [2]. CAP_SETUID also allows a
process to change its real or effective user ID to match the
real or saved user ID of a victim process, allowing it to send
a SIG_KILL signal to the victim [2]. With CAP_OWNER,
a process can change a ﬁle’s owner to be any user. With
CAP_FOWNER, a process can change the permission bits of
any ﬁle. With CAP_DAC_OVERRIDE, a process can gain read,
write, and execute access to any ﬁle. We aimed to reduced the
number of instructions executed with these four privileges.
We devised two changes to passwd to permit it to remove
privileges earlier in execution. First, we noticed that, when
using privileges, passwd can call setuid() much earlier
in its execution (namely, after it has determined the real UID
of the user that executed it). Moving the setuid() call to an
earlier point allows the process to drop CAP_SETUID earlier.
Second, allowing passwd to execute with an effective
UID of zero still allows it to open /dev/mem as the root
user owns many system ﬁles, including device ﬁles and the
shadow database ﬁles, on Ubuntu. This allows passwd to
read and write /dev/mem even though we have reduced its
privilege use. However, there is no reason for root to own the
shadow database. As Section VII-C states, the shadow suite
source code does not assume that root owns the password
database. Since these shadow-related ﬁles are located in the
/etc directory, we can create a new special user named etc
(UID number 998 in our case) and set the owner of the /etc
directory and the shadow password ﬁle to be etc. By doing
so, passwd can change its effective UID to etc and effective
GID to shadow (the group owner of the shadow ﬁle on Ubuntu
16.04) to eliminate the use of CAP_OWNER, CAP_FOWNER,
and CAP_DAC_OVERRIDE, which are responsible for up-
dating the password database. To ignore unexpected signals,
passwd can set its real and saved user IDs to etc as well.
We ran PrivAnalyzer on the refactored passwd program
with these changes. Our results in Table V show that passwd
is invulnerable to all of our modeled attacks for 96% of
its execution. Going back to the results in Table III, we
see that using passwd_priv4 instead of passwd_priv3
decreases the vulnerability of passwd. In particular, Priv-
Analyzer determines that dropping CAP_SETUID,
the
only privilege that makes the two sets differ as shown in
Table III, makes one of the four attacks infeasible. We believe
that highlighting these changes in privilege sets would help
i.e.
600
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 11:13:55 UTC from IEEE Xplore.  Restrictions apply. 
TABLE V: Results for Refactored Programs.  denotes vulnerability to an attack,  denotes invulnerability to the attack, and
(cid:2) denotes that ROSA timed out for the attack/privilege set combination.
Program Name
passwd
su
passwdRef priv1
passwdRef priv2
passwdRef priv3
passwdRef priv4
passwdRef priv5
suRef priv1
suRef priv2
suRef priv3
suRef priv4
suRef priv5
suRef priv6
suRef priv7
Privileges
CapSetuid,CapSetgid
CapSetuid,CapSetgid
CapSetgid
CapSetgid
empty
CapSetuid,CapSetgid
CapSetuid,CapSetgid
CapSetgid
CapSetgid
empty
empty
empty
UID
ruid, euid, suid
1000,1000,1000
998,998,1000
998,998,1000
998,998,1000
998,998,1000
1000,1000,1000
1000,998,1001
1000,998,1001
1000,998,1001
1001,1001,1001
1000,998,1001
1000,998,1001
GID
rgid, egid, sgid
1000,1000,1000
1000,1000,1000
1000,1000,1000
1000,42,1000
1000,42,1000
1000,1000,1000
1000,1000,1000
1000,1000,1000
1000,998,1001
1001,1001,1001
1000 998,1001
1001,1001,1001
Dynamic Instruction
Count
2,633 (3.82%)
42 (0.06)
49 (0.07%)
42 (0.06%)
66,165 (95.99%)
264 (0.56%)
42 (0.09%)
42 (0.09%)
126 (0.27%)
5,766 (12.21%)
40,951 (86.69%)
43 (0.09%)
2



 (cid:2) 
Vulnerability
1
4
3
   
   
 




   
   





 (cid:2) 
 (cid:2) 
(cid:2) (cid:2) 
(cid:2) (cid:2) 



developers identify powerful privileges and help guide them
in refactoring their programs to reduce privilege use.
2) Refactored su: su is vulnerable also because CAP_-
SETUID is live for too long. We observed that the process
determines the target user early during execution. Therefore,
we can modify su to change the supplementary group ID list
much earlier and to use CAP_SETUID and CAP_SETGID to
set the saved user ID and saved group ID to the target user
ID and group ID, respectively. When su needs to switch user
IDs and group IDs, it can call setresuid() and setres-
gid() to change the effective user ID and group ID to the
saved user ID and group ID without using privileges [2]. For
the sulog ﬁle, we can change its owner to etc and set the
effective group ID to etc when CAP_SETGID is available.
In this way, su can drop these two privileges much earlier.
We can also eliminate CAP_DAC_READ_SEARCH by setting
the effective user ID to the owner of /etc/shadow when
CAP_SETUID is available. The change of the effective user
ID and saved user ID doesn’t affect the ﬂow of the program
because all the identiﬁcation work is done by checking the
real user ID, which remains unchanged.
We used PrivAnalyzer to measure the refactored su’s secu-