式为931-3*+。然后将当前这个符号“进栈。也就是说，前6张图的栈
底的“+”是指中级表达式中开头的9后面那个“+”，而图4-9-9左图中的栈
底（也是栈顶）的“+”是指“9+（3-1）×3+”中的最后一个“+”。
8.紧接着数字10，输出，总表达式变为931-3*+10。后是符号“÷”，所以
/”进栈。如图4-9-9的右图所示。
1op
+
输出：931-3*+
输出：931-3*+10
图4-9-9
9.最后一个数字2，输出，总的表达式为931-3*+102。如图4-9-10的左图
所示。
10.因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后级表达式结果
为931-3*+102/+。如图4-9-10的右图所示。
top
输出：931-3*+102
输出：931-3*+102/+
图 4-9-10
从刚才的推导中你会发现，要想让计算机具有处理我们通常的标准（中级）表达
式的能力，最重要的就是两步：
1.将中级表达式转化为后级表达式（栈用来进出运算的符号）。
2.将后级表达式进行运算得出结果（栈用来进出运算的数字）。
110
---
## Page 135
第4章栈与队列
整个过程，都充分利用了栈的后进先出特性来处理，理解好它其实也就理解好了
栈这个数据结构。
好了，休息一下，一会儿我们继续，接下来会讲队列。
4.10队列的定义
你们在用电脑时有没有经历过，机器有时会处于疑似死机的状态，鼠标点什么似
乎都没用，双击任何快捷方式都不动弹。就当你失去耐心，打算reset时。突然它像
酒醒了一样，把你刚才点击的所有操作全部都按顺序执行了一遍。这其实是因为操作
系统中的多个程序因需要通过一个通道输出，而按先后次序排队等待造成的。
再比如像移动、联通、电信等客服电话，客服人员与客户相比总是少数，在所有
的客服人员都占线的情况下，客户会被要求等待，直到有某个客服人员空下来，才能
让最先等待的客户接通电话。这里也是将所有当前拨打客服电话的客户进行了排队处
理。
操作系统和客服系统中，都是应用了一种数据结构来实现刚才提到的先进先出的
排队功能，这就是队列。
队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操
作的线性表。
队列是一种先进先出（FirstInFirstOut）的线性表，简称FIFO。允许插入的一
端称为队尾，允许删除的一端称为队头。假设队列是q=（a1，az，，an），那么
a就是队头元素，面a是队尾元素。这样我们就可以删除时，总是从a开始，而插
入时，列在最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最
后来的当然排在队伍最后，如图4-10-1所示。
队头
队尾
入队列
a1
a2
a3
an
图4-10-1
队列在程序设计中用得非常频繁。前面我们已经举了两个例子，再比如用键盘进
行各种字母或数字的输入，到显示器上如记事本软件上的输出，其实就是队列的典型
111
---
## Page 136
大适数据结构
应用，假如你本来和女友聊天，想表达你是我的上帝，输入的是god，而屏幕上却显
示出了dog发了出去，这真是要气死人了。
4.11队列的抽象数据类型
同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队
尾进行，删除数据只能在队头进行。
ADT队列（Queue）
Data
同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
InitQueue（*Q）：初始化操作，建立一个空队列Q
DestroyQueue（·Q）：若队列Q存在，则销毁它。
ClearQueue（*Q）：将队列Q清空。
QueueEmpty（Q）：若队列Q为空，返回true，否则返回false
GetHead（Q，*e）：若队列Q存在且非空，用e通团队列Q的队头元素。
EnQueue（*Q，e）：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
DeQueue（*Q，*e）：删除队列Q中队头元素，并用e适团其值。
QueueLength（Q）：返回队列Q的元素个数
4.12循环队列
线性表有顺序存储和链式存储，栈是线性表，所以有这两种存储方式。同样，队
列作为一种特殊的线性表，也同样存在这两种存储方式。我们先来看队列的顺序存储
结构。
4.12.1队列顺序存储的不足
我们假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，并
把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的
入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度
112
---
## Page 137
第4章栈与队列
为0（1），如图4-12-1所示。
队尾
队尾
小称：0
图4-12-1
与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着，
队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为
空，此时时间复杂度为0（n），如图4-12-2所示。
队尾
队尾
下标：0
下标：0
图4-12-2
这里的实现和线性表的顺序存储结构完全相同，不再详述。
在现实中也是如此，一群人在排队买票，前面的人买好了离开，后面的人就要全
部向前一步，补上空位，似乎这也没什么不好。
可有时想想，为什么出队列时一定要全部移动呢，如果不去限制队列的元素必须
存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头不需
要一定在下标为0的位置，如图4-12-3所示。
队头
队尾
队头
队尾
出队列
下标：0
下标：0
图4-12-3
为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指
针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等
于rear时，此队列不是还剩一个元素，而是空队列。
113
---
## Page 138
大语数据结构
假设是长度为5的数组，初始状态，空队列如图4-12-4的左图所示，front与
rear指针均指向下标为0的位置。然后入队a、a2、a3、a4，front指针依然指向下标
为0位置，而rear指针指向下标为4的位置，如图4-12-4的右图所示。
front rear
front
rear
a
a
a
下标：0
2
下标：0
2
E
4
图4-12-4
出队at、az，则front指针指向下标为2的位置，rear不变，如图4-12-5的左图
所示，再入队as，此时front指针不变，rear指针移动到数组之外。嗯？数组之外，
那将是哪里？如图4-12-5的右图所示。
front
rear
front
rear
、
1
下标：0
下标：0
3
图4-12-5
问题还不止于此。假设这个队列的总个数不超过5个，但目前如果接着入队的
话，因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我
现实当中，你上了公交车，发现前排有两个空座位，而后排所有座位都已经坐
满，你会怎么做？立马下车，并对自已说，后面没座了，我等下一辆？
没有这么笨的人，前面有座位，当然也是可以坐的，除非坐满了，才会考虑下一
辆。
4.12.2循环队列定义
所以解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。
我们把队列的这种头尾相接的顺序存储结构称为循环队列。
刚才的例子继续，图4-12-5的rear可以改为指向下标为0的位置，这样就不会
造成指针指向不明的问题了，如图4-12-6所示。
114
---
## Page 139
第4章栈与队列
下标：0
图4-12-6
接着入队ab，将它放置于下标为0处，rear指针指向下标为1处，如图4-12-7
的左图所示。若再入队a，则rear指针就与front指针重合，同时指向下标为2的位
置，如图4-12-7的右图所示。
rear
rear front
1
下标：0
下标：0
图4-12-7
此时问题又出来了，我们刚才说，空队列时，front等于rear，现在当队列满
时，也是front等于rear，那么如何判断此时的队列究竞是空还是满呢？
办法一是设置一个标志变量fag，当front==rear，且flag=0时为队列空，
当front==rear，且flag=1时为队列满。
办法二是当队列空时，条件就是front=rear，当队列满时，我们修改其条
件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。
例如图4-12-8所示，我们就认为此队列已经满了，也就是说，我们不允许图
4-12-7的右图情况出现。
front
下标：0
下标：0
图4-12-8
我们重点来讨论第二种方法，由于rear可能比front大，也可能比front小，所以
尽管它们只相差一个位置时就是满的情况，但也可能是相差整整一圈。所以若队列的
115
---
## Page 140
大话数据结构
最大尺寸为QueueSize，那么队列满的条件是（rear+1）%QueueSize==front（取
模“%”的目的就是为了整合rear与front大小为一个问题）。比如上面这个例子，
QueueSize=5，图4-12-8的左图中front=0，而rear=4，（4+1）%5=0，所以此时队
列满。再比如图4-12-8中的右图，front=2而rear=1。（1+1）%5=2，所以此时
队列也是满的。面对于图4-12-6，front=2而rear=0，（0+1）%5=1，1≠2，所以
此时队列并没有满。
另外，当rear>front时，即图4-12-4的右图和4-12-5的左图，此时队列的长度
为rear-front，但当rearfront=0;
Q->rear-0;
returnOK;
循环队列求队列长度代码如下：
/退回的元素个数，也就是队列的当前长度/
int QueueLength（SqQueue Q）
116
---
## Page 141
第4章栈与队列
return
（Q.rear-Q.front+MAXSIZE）sMAXSIZE;
循环队列的入队列操作代码如下：
1若队列未满，则插入元素e为Q新的队尾元素·/
Status EnQueue（SqQueue*Q,QElemType e)
if（（Q->rear+1）aMAxSIZE--Q->front）/·B列满的判断*/
return ERROR;
Q->data{Q->rear]-e;
/将元素e赋值给队尾*/
Q->rear=（Q->rear+1）MAxSIzE;/*rear指针向后移一位置，*/
/*若到最后则特到数组头部*/
return OK;
循环队列的出队列操作代码如下：
/若队列不空，则副除0中队头元素，用e返回其值·/
Status DeQueue（SqQueue*Q,QElemType*e)
1
if（Q->front==Q->rear）
·队列空的判新
return ERROR;
[x<-0]eep<-0=,
/将队头元素赋值给e*/