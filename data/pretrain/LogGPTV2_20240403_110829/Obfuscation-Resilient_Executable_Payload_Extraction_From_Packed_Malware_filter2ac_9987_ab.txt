required DLLs into the memory address space of the appli-
cation, and then it ﬁlls each IAT entry with the API address
according to the item order of INT ( 3 ). After that, the IAT
begins to take effect as an address lookup table for calling
Windows APIs. An API callsite in the PE ﬁle refers to the
IAT via an indirect control ﬂow instruction (e.g., call [ f1]):
it reads the API address from an IAT entry and then jumps
to the target ( 4 ). This design ensures the compatibility with
different Windows OS versions and address space layout rand-
omization, in which each imported API is very likely to have
a different address at every execution [64].
Delete Import Tables. The metadata of imported APIs is
detailed enough to allow a security analyst to estimate whet-
her a particular sample is malicious [70]. Therefore, when
packing malware code, a binary packer erases both INT and
IAT entries and makes these two tables unreachable from the
malware’s header. At the same time, the packer maintains a
list of removed APIs in the attached unpacking routine. When
the packed malware starts running, the unpacking routine,
which runs an unpacking algorithm to recover the original
code, has to rebuild a new IAT before the execution of the ori-
ginal code; otherwise, it will lead to an execution crash. The
most convenient way is to use “LoadLibrary” and “GetProc-
Address” APIs [63]: calling these two functions can explicitly
load a DLL and obtain an API address at run time.
Hide Invoked API Names. In addition to the removal and
deference of import tables, advanced packers also adopt other
methods to obfuscate the use of API calls and the control ﬂow
4 in Figure 1. The purpose is to disconnect API callsites
from corresponding target API names. Symantec security re-
sponse [70] makes the ﬁrst study of API obfuscation used
in the wild. They ﬁnd that some packers generate the target
address of API via sophisticated instructions such as “push-
calc-ret” and “Structured Exception Handler” to impede static
analysis. Kawakoya et al. [42] and their follow-up work [41]
formally deﬁne the concept of API obfuscation and introduce
several speciﬁc patterns of API obfuscation, such as IAT redi-
rection and stolen code. In §3, we will present our in-depth
study to inspect the multiple types of API obfuscation that
mislead the control ﬂow 4 , including new API obfuscation
schemes that have been swept under the carpet.
Anti-Static Analysis. API obfuscation combines the re-
moval of import tables and the methods of hiding invoked API
names, with the purpose of concealing a program’s functiona-
lity. Even though security analysts obtain the OEP memory,
USENIX Association
30th USENIX Security Symposium    3453
Figure 1: The example of standard API resolution. The “00000000” in the disk view represents a placeholder; Windows loader
will replace it with an API address (e.g., “7C805D86”) at program loading time according to the INT.
further malware analysis would still be difﬁcult, if not impos-
sible. As addresses stored in the IAT do not directly point to
correct API entry points, a disassembler is unable to recognize
API names. Therefore, when analyzing a new unpacked mal-
ware sample, the only available resource for security analysts
is low-level assembly code, lacking semantic abstractions
represented by API calls.
Anti-Dynamic Execution. Besides, API obfuscation im-
pedes the reconstruction of a fully executable PE ﬁle—this is
the ultimate goal of generic binary unpacking. Advanced pac-
kers have embedded various heuristics to detect the existence
of malware dynamic analysis environments (e.g., debugging,
hooking, and sandbox). The state-of-the-art unpacking tool,
such as BinUnpack [15], is immune to these anti-dynamic-
analysis methods and can quickly produce a memory dump as
the unpacked program. However, if the removed INT cannot
be recovered, Windows PE loader has no idea about which
API addresses should be ﬁlled in the IAT, and thus security
analysts cannot independently run the unpacked malware to
observe its intended malicious behavior.
2.2 Limitations of Existing Work
To facilitate malware analysis, a complete binary unpacking
solution has to restore the original code as well as reconstruct
import tables. Typically, an import table reconstruction starts
after the unpacking tool captures the OEP memory, and it con-
tains three major steps [41]: 1) identify possible API callsites
from the process memory; 2) resolve API names according
to API callsites, and 3) restore both INT and IAT in the PE
header (just like 1 & 2 in Figure 1). Among them, the
most challenging step is API name resolution, as IAT entries
may not directly point to target APIs, and all of the existing
approaches fail to resolve API names completely. Table 1
summarizes different import table reconstruction approaches
in terms of memory static analysis, dynamic analysis, and
hybrid analysis.
Memory Static Analysis. The approaches in this category
perform static scanning on OEP memory to identify indirect
call (e.g., call [ f1]) and indirect jump (e.g., jmp [ f2]) instructi-
Table 1: Different import table reconstruction approaches.
§5.1 compares API-Xray with the three approaches in bold.
Class
Memory Static Analysis
Approach
BinUnpack [15], Scylla [2],
Eureka [69], RePEF [81],
PinDemonium [50], Arancino [60]
Dynamic Analysis
Ugarte-Pedrero et al. [73], API Chaser [42],
API Deobfuscator [17], QuietRIATT [62],
tf_impscan [41], Secure Unpacker [40]
Hybrid Analysis
RePEconstruct [44], API-Xray
ons. Each target address of these instructions is considered
as an entry of the IAT. Then, they relate all addresses in the
IAT with corresponding API names in the INT. In particular,
they match IAT entries with the address calculated from a
DLL’s base address and the offset of each export API in the
DLL’s export address table. In this way, they resolve the API
name for each IAT entry. The latest generic unpacking work in
CCS’18 [15] also adopts a similar style to reconstruct import
tables. However, all of these static methods suffer from the
same limitation: they can only recognize statically identiﬁable
targets; the different API obfuscation methods that we will
present in §3 can easily nullify them.
Dynamic Analysis. Another direction reconstructs import
tables at run time. S&P’15 paper [73] achieves this by instru-
menting indirect calls/jumps and grouping the memory ad-
dresses used in these instructions. Both Secure Unpacker [40]
and QuietRIATT [62] use hooking-based methods to identify
target API. They assume no matter what API obfuscation
techniques the packer used, the control ﬂow will be trans-
ferred to the API code eventually. Therefore, they set hooks
at the entries of APIs that the packed sample is very likely
to call. Once the control ﬂow arrives at the hooked API’s
entry point, they can determine the target API’s name. Un-
fortunately, stolen code, which we will further discuss in §3,
deﬁes the assumption embodied by hooking-based methods.
To overcome this limitation, both Kawakoya et al. [41, 42]
and Seokwoo et al. [17] use taint analysis to trace the code
copy operation, which is necessary to complete the stolen
code obfuscation. As the stolen code shares the same taint
3454    30th USENIX Security Symposium
USENIX Association
 …  5D86: (offset)    CreateFile Code  6000: (offset) WriteFile Code  … PE File(memory view)  Code: … call [f1] …kernel32.dll INT: CreateFile WriteFile  …  IAT: f1: 00000000 f2: 00000000 …  Code: … call [f1] …PE File(disk view)  INT: CreateFile WriteFile  …  IAT: f1: 7C805D86 f2: 7C806000 … Windows PE Loader7C800000:1234Table 2: The comparison of hardware control ﬂow tracing
mechanisms. “Yes” in the “Completeness” column means it
can monitor all kinds of control ﬂow deviation instructions,
including jmp, cjmp, call, ret, and exception.
Mechanism Completeness
LBR
BTS
IPT
Yes
Yes
No
Size Limit Overhead Online/Ofﬂine
Yes
No
No
Low
High
High
Online
Online
Ofﬂine
tag with the source API code, when the program executes the
stolen code, the attached taint tag can decide which API code
is actually executed. The disadvantage of dynamic-based met-
hods is also apparent—they can only resolve API names in
a single execution path each time. Single-path API coverage
cannot guarantee the executability of malware in a new Win-
dows OS, because non-identical environments are likely to
trigger a different execution path. Furthermore, as most of the
dynamic analysis environments are not transparent, malware
can counter them via anti-sandbox and anti-debug heuristics.
Hybrid Analysis. RePEconstruct [44] takes a weak hy-
brid analysis style to resolve API names. Like S&P’15 pa-
per [73], RePEconstruct leverages dynamic binary instrumen-
tation (DBI) to record the branch instructions that jump to
dynamically loaded modules. In addition, it also takes ano-
ther round of memory static scanning to recognize the APIs
that are not executed at run time. However, its memory sta-
tic scanning does not consider API obfuscation. By contrast,
API-Xray weaves static and transparent dynamic analyses in
a compatible manner that ampliﬁes each other’s beneﬁt.
2.3 Control Flow Monitoring via Hardware
Multiple software security tasks require control ﬂow moni-
toring to block anomaly intrusions, such as defending ROP
attacks [59, 89] and preventing kernel malware [46, 79]. The
software-based monitoring typically relies on a DBI platform
(e.g., Pin [48] or DynamoRIO [10]) to record control ﬂow
transfers. However, DBI tools do not keep the code under
execution intact, and thus their instrumentation environments
are easy to be detected [25]. In contrast, hardware-based mo-
nitoring overcomes the limitation of lacking transparency;
it leverages modern CPU features to record control ﬂow, re-
quiring no code injection. For modern Intel processors, the
mechanisms to trace branch instructions include Last Branch
Record (LBR), Branch Trace Store (BTS), and Intel Processor
Trace (IPT). We will further evaluate these three mechanisms
in §5.1, but for now, we would like to remind readers that
BTS is the only option for import table reconstruction. Ta-
ble 2 shows the different features of these three hardware
tracing mechanisms.
LBR. LBR can record 16 or 32 most recent branch pairs
(source and target) into a register.‡ LBR is very fast since
it directly accesses CPU registers, but LBR is also limited
by the maximum number of branches that it can record at
one time [82]. kBouncer [59] is the ﬁrst work to use LBR to
prevent ROP attack. At each system API invocation, kBoun-
cer checks the proposed control-ﬂow integrity (CFI) policy
against LBR stack. Later, ROPecker [16], CFIGuard [88], and
PathArmor [75] extend kBouncer [59]’s idea to prevent ROP
attacks with the help of LBR. However, due to the limited
size of LBR stack (16 or 32), an attacker can still circumvent
LBR’s monitoring [12, 24, 34].
BTS. BTS is more ﬂexible than LBR. BTS records all
kinds of branch pairs (source and target) into a memory buf-
fer, and users can determine the memory buffer’s size and
location. Unlike LBR that overwrites the data when LBR
stack is full, BTS can be conﬁgured to halt the application
when the recording buffer is full, or when a predeﬁned excep-
tion is triggered. Then, the user saves BTS buffer’s record,
resets it, and then resumes BTS’s monitoring. In this way,
BTS is able to record complete control ﬂow transfers, but at
the cost of higher overhead than LBR. To prevent ROP at-
tacks, CFIMon [83] and Eunomia [87] leverage BTS to detect
illegitimate branch pairs. Recent work [9] proposes a general
BTS-based control ﬂow monitoring framework, which can be
extended to perform different analysis tasks, such as control
ﬂow graph reconstruction and ROP detection.
IPT. Different from both LBR and BTS, IPT is initially
designed for ofﬂine performance analysis and software debug-
ging. IPT efﬁciently captures control ﬂow traces online, but it
is at the cost of the orders-of-magnitude slowdown in ofﬂine
decoding. In addition, IPT does not trace all types of cont-
rol ﬂow transfer instructions—unconditional direct branches
(e.g., direct jump and direct call) are not logged [20]. Both
GRIFFIN [31] and FlowGuard [47] transparently enforce
ﬁne-grained CFI policy using IPT.
3 Deep Inspection of API Obfuscation
In this section, we conduct an in-depth study to demystify API
obfuscation schemes that can hide the names of invoked APIs.
We manually analyzed all of the 29 prevalent packers tested in
BinUnpack’s paper [15]. Upon further investigation, we ﬁnd
that 12 out of 29 packers obfuscate the control ﬂow between
API callsites and target API entry points (i.e., the control ﬂow
1 in Figure 2(a)). These 12 packers (e.g., Themida [57],
Enigma [72], and Obsidium [54]) represent advanced packers
that incorporate multiple anti-analysis methods. Note that,
for Themida, we enable its packing and partial code revea-
ling models. For other pure code virtualization tools, such as
Code Virtualizer [56] and VMProtect [77], researchers rely
‡For the Intel Haswell microarchitecture CPU, it can record 16 most recent
branch pairs. For the Intel Skylake microarchitecture CPU, the recording
number increases to 32 [20].
USENIX Association
30th USENIX Security Symposium    3455
Figure 2: The examples of different API obfuscation schemes (Figure 2(b)∼ Figure 2(f)). The unpacking routine allocates and
maintains a “trampoline” code area (labeled as red color boxes) to complicate the standard API call chain.
Table 3: The summary of various API obfuscation techniques. The branches involved in the complicated control ﬂow between
the original code and the target API (Column 2) could be a very large number.
Obfuscation Type
Normal API Call
IAT Redirection
Rewrite API Callsite
Anti-debugging Routine Original Code ⇒ Trampoline ⇒ Anti-debugging API ⇒ Trampoline ⇒ TargetAPI
Original Code ⇒ Trampoline ⇒ End of TempAPI ⇒ Trampoline ⇒ TargetAPI
ROP Redirection
Stolen Code
Original Code ⇒ Trampoline ⇒ TargetAPI
Original Code ⇒ Trampoline ⇒ TargetAPI
Original Code ⇒ Trampoline ⇒ TargetAPI+n
Control Flow
Original Code ⇒ TargetAPI
Cited Work
—
[43, 63, 70]
[41, 43, 63, 70]
[63]
API-Xray
API-Xray
on totally different approaches [19, 68, 84, 85] to recover vir-