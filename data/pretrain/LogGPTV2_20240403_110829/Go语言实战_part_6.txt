func (m *defaultMatcher) Search(feed *Feed, searchTerm string)
// 声明一个defaultMatcher类型的值
var dm defaultMatch
// 编译器会自动生成指针引用dm值，使用指针调用方法
dm.Search(feed, "test")
因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法
的接收者声明为指针。对于 defaultMatcher 类型来说，使用值作为接收者是因为创建一个
defaultMatcher类型的值不需要分配内存。由于defaultMatcher不需要维护状态，所以
不需要指针形式的接收者。
与直接通过值或者指针调用方法不同，如果通过接口类型的值调用方法，规则有很大不同，
如代码清单 2-38 所示。使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时
候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。
代码清单2-38 接口方法调用所受限制的例子
// 方法声明为使用指向defaultMatcher类型值的指针作为接收者
func (m *defaultMatcher) Search(feed *Feed, searchTerm string)
// 通过interface类型的值来调用方法
var dm defaultMatcher
var matcher Matcher = dm // 将值赋值给接口类型
matcher.Search(feed, "test") // 使用值来调用接口方法
> go build
cannot use dm (type defaultMatcher) as type Matcher in assignment
// 方法声明为使用defaultMatcher类型的值作为接收者
func (m defaultMatcher) Search(feed *Feed, searchTerm string)
// 通过interface类型的值来调用方法
var dm defaultMatcher
var matcher Matcher = &dm // 将指针赋值给接口类型
matcher.Search(feed, "test") // 使用指针来调用接口方法
> go build
Build Successful
除了Search方法，defaultMatcher类型不需要为实现接口做更多的事情了。从这段代
码之后，不论是 defaultMatcher 类型的值还是指针，都满足 Matcher 接口，都可以作为
Matcher类型的值使用。这是代码可以工作的关键。defaultMatcher类型的值和指针现在还
可以作为Matcher的值，赋值或者传递给接受Matcher类型值的函数。
让我们看看match.go代码文件里实现Match函数的代码，如代码清单2-39所示。这个函数
在search.go代码文件的第39行中由Run函数调用。
代码清单2-39 search/match.go：第19行到第33行
19 // Match函数，为每个数据源单独启动goroutine来执行这个函数
20 // 并发地执行搜索
21 func Match(matcher Matcher, feed *Feed, searchTerm string, results chan
News
...
...
en
Copyright 2014 NPR - For Personal Use
...
Putin Says He'll Respect Ukraine Vote But U.S.
The White House and State Department have called on the
如果用浏览器打开代码清单2-47中的任意一个链接，就能看到期望的RSS文档的完整内容。RSS
匹配器的实现会下载这些 RSS 文档，使用搜索项来搜索标题和描述域，并将结果发送给 results
通道。让我们先看看rss.go代码文件的前12行代码，如代码清单2-48所示。
代码清单2-48 matchers/rss.go：第01行到第12行
01 package matchers
02
03 import (
04 "encoding/xml"
05 "errors"
06 "fmt"
07 "log"
08 "net/http"
09 "regexp"
10
11 "github.com/goinaction/code/chapter2/sample/search"
12 )
和其他代码文件一样，第1行定义了包名。这个代码文件处于名叫matchers的文件夹中，
所以包名也叫matchers。之后，我们从标准库中导入了6个库，还导入了search包。再一次，
我们看到有些标准库的包是从标准库所在的子文件夹导入的，如xml和http。就像json包一
样，路径里最后一个文件夹的名字代表包的名字。
为了让程序可以使用文档里的数据，解码 RSS 文档的时候需要用到 4 个结构类型，如代码
清单2-49所示。
代码清单2-49 matchers/rss.go：第14行到第58行
14 type (
15 // item根据item字段的标签，将定义的字段
16 // 与rss文档的字段关联起来
17 item struct {
18 XMLName xml.Name `xml:"item"`
19 PubDate string `xml:"pubDate"`
20 Title string `xml:"title"`
21 Description string `xml:"description"`
22 Link string `xml:"link"`
23 GUID string `xml:"guid"`
24 GeoRssPoint string `xml:"georss:point"`
25 }
26
27 // image根据image字段的标签，将定义的字段
28 // 与rss文档的字段关联起来
29 image struct {
30 XMLName xml.Name `xml:"image"`
31 URL string `xml:"url"`
32 Title string `xml:"title"`
33 Link string `xml:"link"`
34 }
35
36 // channel根据channel字段的标签，将定义的字段
37 // 与rss文档的字段关联起来
38 channel struct {
39 XMLName xml.Name `xml:"channel"`
40 Title string `xml:"title"`
41 Description string `xml:"description"`
42 Link string `xml:"link"`
43 PubDate string `xml:"pubDate"`
44 LastBuildDate string `xml:"lastBuildDate"`
45 TTL string `xml:"ttl"`
46 Language string `xml:"language"`
47 ManagingEditor string `xml:"managingEditor"`
48 WebMaster string `xml:"webMaster"`
49 Image image `xml:"image"`
50 Item []item `xml:"item"`
51 }
52
53 // rssDocument定义了与rss文档关联的字段
54 rssDocument struct {
55 XMLName xml.Name `xml:"rss"`
56 Channel channel `xml:"channel"`
57 }
58 )
如果把这些结构与任意一个数据源的RSS文档对比，就能发现它们的对应关系。解码XML
的方法与我们在feed.go代码文件里解码JSON文档一样。接下来我们可以看看rssMatcher类
型的声明，如代码清单2-50所示。
代码清单2-50 matchers/rss.go：第60行到第61行
60 // rssMatcher 实现了Matcher接口
61 type rssMatcher struct{}
再说明一次，这个声明与defaultMatcher类型的声明很像。因为不需要维护任何状态，