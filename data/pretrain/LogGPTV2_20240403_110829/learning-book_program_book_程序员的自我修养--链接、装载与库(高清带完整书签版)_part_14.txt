64
第3章目标文件里有什么
3.3.1
代码段
挖掘各个段的内容，我们还是离不开objdump这个利器。objdump的“-s”参数可以将
所有段的内容以十六进制的方式打印出来，“-d”参数可以将所有包含指令的段反汇编。我
们将objdump输出中关于代码段的内容提取出来，分析一下关于代码段的内容（省略号表示
略去无关内容）：
$ objduep -s -d SimpleSection.0
Contents of section ,text:
0000 5589e583 ec088b45 08894424 04c70424
0010 00000000 e8fcffff ffc9c38d 4c240483
U......E..DS...$
0020 e4f0ff71 fc5589e5 5183ec14 c745f401
·..q.U..Q....B..
0030 0000008b 15040000 00a10000 00008d04
0040 020345f4 0345f889 0424e8fc ffffff8b
..E..E...S......
0050 45f483c4 14595d8d 61fcc3
E....Yl.a..
00000000 :
*+++**
0：
1 :
89 e5
55
push
$ebp
3 :
83 ec 08
mov
$esp, tebp
sub
s0x8,esp
6 :
8b 45 08
9 :
89 44 24 04
mov
xeag * (dqeg) gx0
d :
c7 042400 00 00 00 mov1
mOV
$0x0, (tesp)
$eax, 0x4 ($e8p)
14 :
e8 fc ff ff ff
ca11
15 
La :
1.9 :
c3
c9
leave
ret
0000001b
8d 4c 24 04
:
1b:
lea
0x4(te8p), $ecx
1f :
83 e4 f0
and
soxfffffffo,eesp
22 :
ff
71 fc
25 :
push1
- 0x4 ($ecx)
55
push
ebp
26 1
68
5 1
push
mov
tesp, tebp
28:
$0x14,esp
teCX
29 :
8
45 f4 01 00 00 00 mov1
ec 14
2c 1
7
sub
8b 15 04 00 00 00
$0x1,-0xc($ebp)
33 :
00 00 00 00
nov
0x4, tedx
:6E
8d 04 02
al
1ea
AOW
0x0.8eax
41 :
3e :
03 45 f4
add
(edx, $eax, 1) , $eax
0x8 ($ebp) , eax
-0xc (kebp) , teax
44 :
2 068
03 45 f8
add
47 :
mov
$eax,(tesp)
Ga:
e8 fc ff ff ff
8b 45 f4
ca11
mov
4b 
4 f :
$0x14,e8p
-0xc($ebp) , eax
5.2 :
83 c4 14
add
56 :
55 1
59
5d
pop
tecx
pop
tebp
57 :
8d 61  fc
Lea
-0x4($ecx) , $esp
5a :
C3
ret
“Contents of sectiontext”就是.text的数据以十六进制方式打印出来的内容，总共0x5b
程序员的自我修养一链接、装载与库
---
## Page 88
3.3挖掘 SimpleSection.o
65
字节，跟前面我们了解到的“.text”段长度相符合，最左面一列是偏移量，中间4列是十六
进制内容，最右面一列是texI 段的ASCII码形式。对照下面的反汇编结果，可以很明显地
看到，text段里所包含的正是 SimpleSection.c里两个函数 func1O和 mainO的指令，Jext 段
x
3.3.2数据段和只读数据段
data段保存的是那些已经初始化了的全局静态变量和局部静态变量。前面的
SimpleSection.c 代码里面一其有两个这样的变量，分别是 global_init_varabal与 static_var.
“88
是一种只读数据，所以它被放到了“.rodata”段，我们可以从输出结果看到“rodata”这个
段的4个字节刚好是这个字符串常量的ASCII字节序，最后以vO结尾。
“.rodata”段存放的是只读数据，一般是程序里面的只读变量（如const修饰的变量）
和字符串常量。单独设立“.rodata”段有很多好处，不光是在语义上支持了C++的const关
键字，而且操作系统在加载的时候可以将“rodata”段的属性映射成只读，这样对于这个段
的任何修改操作都会作为非法操作处理，保证了程序的安全性。另外在某些嵌入式平台下，
以保证程序访问存储器的正确性。
另外值得一提的是，有时候编译器会把字符申常最放到“data”段，面不会单独放在
“rodata”段。有兴趣的读者可以试若把 SimpleSection.c的文件名改成 SimpleSection.cpp
然后用各种MSVC编译器编译一下看看字符串常量的存放情况。
Sections:
Idx Name
Size
00000008
VMA
0000000000000090
LMA
File off
1,Gata
00000000
A1gn
2**2
3.rodata
CONTENTS,
00000004
ALLOC,
00000000
00000000
LOAD,
00000098
DATA
CONTENTS, ALLOC,
2**0
LOAD,
READONLY,DATA
Contents of section .data:
0000 54000000 55000000
T...U...
Contents of section .rodata:
0000 25640a00
$d..
我们看到“.data”段里的前4个字节，从低到高分别为0x54、0x00、0x00、0x00。这
程序员的自我修养一链接、装载与库
---
## Page 89
66
第3章目标文件里有什么
个值刚好是 global_init_varabal，即十进制的 84。global_init_varabal 是个 4 字节长度的 int
类型，为什么存放的次序为0x54、0x00、0x00、0x00面不是0x00、0x00、0x00、0x54？这
涉及CPU 的字节序（Byte Order）的问题，也就是所谓的大端（Big-endian）和小端
（Litle-endian）的问题，关于字节序的问题本书的附录有详细的介绍。而最后4个字节刚
好是 static_init_var 的值，即 85。
3.3.3BSS段
.bss段存放的是未初始化的全局变量和局部静态变量，如上述代码中global_unini_var
和 startic_var2就是被存放在.bss 段，其实更准确的说法是.bss 段为它们预留了空间。但是我
们可以看到该段的大小只有4个字节，这与 global_uninit_var 和 static_var2的大小的 8 个字节
不符。
其实我们可以通过符号表（Symbol Table）（后面章节介绍符号表）看到，只有static_var2
被存放在了.bss 段，而 global_unini_var 却没有被存放在任何段，只是一个未定义的
“COMMON符号”。这其实是跟不同的语言与不同的编译器实现有关，有些编译器会将全
局的未初始化变量存放在目标文件.bss段，有些则不存放，只是预留一个未定义的全局变量
符号，等到最终链接成可执行文件的时候再在.bss段分配空间，我们将在“弱符号与强符号”
和“COMMON块”这两个章节深入分析这个问题。原则上讲，我们可以简单地把它当作全
局未初始化变量存放在.bss段。值得一提的是编译单元内部可见的静态变量（比如给
global_uninit_var 加上 static 修饰）的确是存放在.bss 段的，这一点很容易理解。
$ objdump -x -8 -d SimpleSection.o
+***t
Sections:
Idx Nane
2,b8s
28600000000000000000000000000000
VMA
LRA
File off
A1gn
*
ALLOC
Quiz变量存放位置
现在让我们来做个小的测试，请看以下代码：
static int x1  0;
static int x2 - 1;
x1和x2会被放在什么段中呢？
x1会被放在.bss中，x2会被放在.data中。为什么一个在.bss 段，一个在.data 段？因为
x1为0，可以认为是未初始化的，因为未初始化的都是0.所以被优化掉了可以放在.bss，
这样可以节省磁盘空间，因为.bss不占磁盘空间。另外一个变量x2初始化值为1，是初始化
程序员的自我修养一链接、装载与库
---
## Page 90
3.3挖据SimpleSection.o
67
的，所以放在data 段中。
注