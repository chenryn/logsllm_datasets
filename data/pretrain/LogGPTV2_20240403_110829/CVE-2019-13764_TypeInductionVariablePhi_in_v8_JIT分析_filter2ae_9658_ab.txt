    0x118a80d82e72    52  41ffd2               call r10
    0x118a80d82e75    55  cc                   int3l
    ---------------------------------------- Main Code ------------------------------------------------    0x118a80d82e76    56  4883ec08             REX.W subq rsp,0x8
    0x118a80d82e7a    5a  488975b0             REX.W movq [rbp-0x50],rsi
    0x118a80d82e7e    5e  488b55d8             REX.W movq rdx,[rbp-0x28]
    0x118a80d82e82    62  f6c201               testb rdx,0x1
    0x118a80d82e85    65  0f859a000000         jnz 0x118a80d82f25  
    0x118a80d82e8b    6b  48b90000000010270000 REX.W movq rcx,0x271000000000
    0x118a80d82e95    75  483bd1               REX.W cmpq rdx,rcx
    0x118a80d82e98    78  0f8c0b000000         jl 0x118a80d82ea9  
    0x118a80d82e9e    7e  498b4520             REX.W movq rax,[r13+0x20] (root (undefined_value))
    0x118a80d82ea2    82  488be5               REX.W movq rsp,rbp
    0x118a80d82ea5    85  5d                   pop rbp
    0x118a80d82ea6    86  c20800               ret 0x8
    ---------------------------------------- Deopt Code ---------------------------------------------    0x118a80d82ea9    89  493b65e0             REX.W cmpq rsp,[r13-0x20] (external value (StackGuard::address_of_jslimit()))
    0x118a80d82ead    8d  0f8629000000         jna 0x118a80d82edc  
    0x118a80d82eb3    93  48b979fa19a6632d0000 REX.W movq rcx,0x2d63a619fa79    ;; object: 0x2d63a619fa79  从此处开始进入循环
    0x118a80d82ebd    9d  48bf39d619a6632d0000 REX.W movq rdi,0x2d63a619d639    ;; object: 0x2d63a619d639  value=0x2d63a619fa79 >
    0x118a80d82ec7    a7  48394f17             REX.W cmpq [rdi+0x17],rcx
    0x118a80d82ecb    ab  0f8560000000         jnz 0x118a80d82f31  
    0x118a80d82ed1    b1  493b65e0             REX.W cmpq rsp,[r13-0x20] (external value (StackGuard::address_of_jslimit()))
    0x118a80d82ed5    b5  0f862a000000         jna 0x118a80d82f05  
    0x118a80d82edb    bb  cc                   int3l                            ;; 由于始终无法满足当前代码段的各个跳出循环的条件，因此将频繁触发此处的断点
    0x118a80d82edc    bc  48bb307ba501157f0000 REX.W movq rbx,0x7f1501a57b30    ;; external reference (Runtime::StackGuard)
    0x118a80d82ee6    c6  33c0                 xorl rax,rax
    0x118a80d82ee8    c8  48be311818a6632d0000 REX.W movq rsi,0x2d63a6181831    ;; object: 0x2d63a6181831 
    0x118a80d82ef2    d2  49baa0de7302157f0000 REX.W movq r10,0x7f150273dea0  (CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit)    ;; off heap target
    0x118a80d82efc    dc  41ffd2               call r10
    0x118a80d82eff    df  488b55d8             REX.W movq rdx,[rbp-0x28]
    0x118a80d82f03    e3  ebae                 jmp 0x118a80d82eb3        ;; 跳转回上面的代码
    0x118a80d82f05    e5  488b1dd2ffffff       REX.W movq rbx,[rip+0xffffffd2]
    0x118a80d82f0c    ec  33c0                 xorl rax,rax
    0x118a80d82f0e    ee  48be311818a6632d0000 REX.W movq rsi,0x2d63a6181831    ;; object: 0x2d63a6181831 
    0x118a80d82f18    f8  4c8b15d5ffffff REX.W movq r10,[rip+0xffffffd5]
    0x118a80d82f1f    ff  41ffd2               call r10
    0x118a80d82f22   102  ebb7                 jmp 0x118a80d82edb  
    0x118a80d82f24   104  90                   nop
    0x118a80d82f25   105  49c7c500000000       REX.W movq r13,0x0      ;; debug: deopt position, script offset '170'
                                                                       ;; debug: deopt position, inlining id '-1'
                                                                       ;; debug: deopt reason 'not a Smi'
                                                                       ;; debug: deopt index 0
    0x118a80d82f2c   10c  e80ff10300           call 0x118a80dc2040     ;; eager deoptimization bailout
    0x118a80d82f31   111  49c7c501000000       REX.W movq r13,0x1      ;; debug: deopt position, script offset '190'
                                                                       ;; debug: deopt position, inlining id '-1'
                                                                       ;; debug: deopt reason 'wrong call target'
                                                                       ;; debug: deopt index 1
    0x118a80d82f38   118  e803f10300           call 0x118a80dc2040     ;; eager deoptimization bailout
    0x118a80d82f3d   11d  49c7c502000000       REX.W movq r13,0x2      ;; debug: deopt position, script offset '152'
                                                                       ;; debug: deopt position, inlining id '-1'
                                                                       ;; debug: deopt reason '(unknown)'
                                                                       ;; debug: deopt index 2
    0x118a80d82f44   124  e8f7f00700           call 0x118a80e02040     ;; lazy deoptimization bailout
    0x118a80d82f49   129  49c7c503000000       REX.W movq r13,0x3      ;; debug: deopt position, script offset '37'
                                                                       ;; debug: deopt position, inlining id '0'
                                                                       ;; debug: deopt reason '(unknown)'
                                                                       ;; debug: deopt index 3
    0x118a80d82f50   130  e8ebf00700           call 0x118a80e02040     ;; lazy deoptimization bailout
    0x118a80d82f55   135  0f1f00               nop
  * Issue 中给出的 Regress 单元测试文件如下（也可以称为PoC）： 
        function write(begin, end, step) {
      for (var i = begin; i >= end; i += step) {
        step = end - begin;
        begin >>>= 805306382;
      }
    }
    function bar() {
      for (let i = 0; i  一个循环内部会有多个 Phi 结点，以PoC为例，由于变量begin、i、step的值分别从循环内部和循环外部的数据流流入，因此是 Phi 类型的结点。
详细输出如下。可以看到 bound_type、initial_type 以及 increment_type 的范围与我们所预期的相符，因为 bound
value 和 initial value 分别是传入 write 函数的 `1` 和 `Infinity`，而 increment value 为 $1
– inf = -inf$。但归纳变量 `i` 的范围却错误的设置为 `-inf ~ inf`，而不是 `inf ~ inf`。
同时我们还可以注意到此时的 `initial_type value + increment_type value = inf + (-inf) = NaN`
> 以下部分输出，是打patch后的输出结果。
  * 理解完上面的漏洞原理后，我们便可以略微修改一下Poc，更加进一步的理解到其中的细节： 
        function write(step) {
      step = -Infinity;
      /*
        initial_type   range => inf ~ inf
        bounds_type    range => 1 ~ 1
        increment_type range => -inf ~ inf
        => i           range => -inf ~ inf
      */
      for (var i = Infinity; i >= 1; i += -Infinity) {}
    }
    function bar() {
      for (let i = 0; i  需要注意的是，该补丁仍然没有包含所有可能的 NaN 情况。具体请看 [Issue 1051017: Security: Type inference
> issue in
> Typer::Visitor::TypeInductionVariablePhi](https://bugs.chromium.org/p/chromium/issues/detail?id=1051017)
        @@ -847,13 +847,30 @@
       DCHECK_EQ(IrOpcode::kLoop, NodeProperties::GetControlInput(node)->opcode());
       DCHECK_EQ(2, NodeProperties::GetControlInput(node)->InputCount());
    +  auto res = induction_vars_->induction_variables().find(node->id());
    +  DCHECK(res != induction_vars_->induction_variables().end());
    +  InductionVariable* induction_var = res->second;
    +  InductionVariable::ArithmeticType arithmetic_type = induction_var->Type();
       Type initial_type = Operand(node, 0);
       Type increment_type = Operand(node, 2);
    +  const bool both_types_integer = initial_type.Is(typer_->cache_->kInteger) &&
    +                                  increment_type.Is(typer_->cache_->kInteger);
       // 增加了对 NaN 的判断
    +  bool maybe_nan = false;
    +  // The addition or subtraction could still produce a NaN, if the integer
    +  // ranges touch infinity.
    +  if (both_types_integer) {
    +    Type resultant_type =
    +        (arithmetic_type == InductionVariable::ArithmeticType::kAddition)
    +            ? typer_->operation_typer()->NumberAdd(initial_type, increment_type)
    +            : typer_->operation_typer()->NumberSubtract(initial_type,
    +                                                        increment_type);
    +    maybe_nan = resultant_type.Maybe(Type::NaN());
    +  }
    +
       // We only handle integer induction variables (otherwise ranges
       // do not apply and we cannot do anything).
    -  if (!initial_type.Is(typer_->cache_->kInteger) ||
    -      !increment_type.Is(typer_->cache_->kInteger)) {
       // 增加了对 NaN 的处理，对于 NaN 这种情况，使用保守方式进行处理。
    +  if (!both_types_integer || maybe_nan) {
         // Fallback to normal phi typing, but ensure monotonicity.
         // (Unfortunately, without baking in the previous type, monotonicity might
         // be violated because we might not yet have retyped the incrementing
    @@ -874,12 +891,6 @@
       }
       // Now process the bounds.
    -  auto res = induction_vars_->induction_variables().find(node->id());
    -  DCHECK(res != induction_vars_->induction_variables().end());
    -  InductionVariable* induction_var = res->second;
    -    -  InductionVariable::ArithmeticType arithmetic_type = induction_var->Type();
    -       double min = -V8_INFINITY;
       double max = V8_INFINITY;
## 六、参考
  * [Issue 1028863: v8: Wrong JIT code that triggers SIGTRAP at runtime](https://bugs.chromium.org/p/chromium/issues/detail?id=1028863)
  * [Issue 1051017: Security: Type inference issue in Typer::Visitor::TypeInductionVariablePhi](https://bugs.chromium.org/p/chromium/issues/detail?id=1051017)