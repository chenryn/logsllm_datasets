    +                 if(!run_init_process("/etc/preinit")||
                        !run_init_process("/sbin/init")||
                        !run_init_process("/etc/init")||
                        !run_init_process("/bin/preinit")||
                        !run_init_process("/bin/sh")
通过UART Log 信息 ，在初始化/preinit 脚本之后，接着会执行procd 模块，当然设备UART 输出的启动log
远不止我上面讲述的这些，这就需要安全人员的仔细分析。
    [    6.188804] kmodloader: done loading kernel modules from /etc/modules-boot.d/*
    [    6.200760] init: - preinit -    ubimkvol: error!: UBI is not present in the system
    ls: /lib/modules/4.9.206/ltq_atm*: No such file or directory
    [    7.505491] mount_root: switching to jffs2 overlay
    [    7.554060] urandom-seed: Seeding with /etc/urandom.seed
    nanddump: error!: Unable to write to output
              error 32 (Broken pipe)
    chown: unknown user/group nwk:nwk
    [    8.856209] procd: - early -    [    8.857722] procd: - watchdog -    [    9.594215] procd: - watchdog -    [    9.596328] procd: - ubus -    [    9.656987] procd: - init -    Please press Enter to activate this console.
## 0x03 procd 模块的作用
在OpenWrt
嵌入式系统中，有一些通用的基础内核模块，如：基础库libubox、系统总线ubus、网络接口总线ubus、网络接口管理模块netifd、核心工具模块ubox、服务管理模块procd。
在Tenda AX12 设备中的进程信息如下：
      1 root        1656 S    /sbin/procd
      752 root      1252 S    /sbin/ubusd
     2009 root      1840 S    /sbin/netifd
由于嵌入式设备存在漏洞风险点多与服务有关，因此这里我们来了解一下procd 服务。
在了解procd
服务之前，我们先讲述续一下守护进程，通常嵌入式系统中有一个守护进程，该守护进程监控系统进程的状态，如果某些系统进程异常退出，将再次启动这些进程。Procd就是这样的进程。我这里讲述以下我为什么会关注procd
模块。
我在Tenda AX12 设备上的httpd
组件服务上发现了一个缓冲区栈溢出的漏洞，当我兴致勃勃的构造好简单的poc，并且打算触发漏洞造成设备httpd服务拒绝服务效果的时候，我的每次漏洞触发都是无效的，因为我看到设备的httpd服务从外界依旧可以访问和请求，为此，我甚至一度怀疑漏洞的有效性了，于是我从设备的另一个漏洞获取shell
之后，看到设备的httpd 进程Pid
每次在我发送缓冲区栈溢出POC之后，都会更改，于是我猜测设备上有一个守护进程，会在httpd进程异常退出之后将起再次启动。
为此我做了一个简单的测试，我在Tenda AX12 设备中kill 掉httpd 服务的进程，随后httpd服务又重新启动。
这里我们来查看一下设备正在运行的程序。
    root@AX12:~# ps
      PID USER       VSZ STAT COMMAND
        1 root      1656 S    /sbin/procd
      752 root      1252 S    /sbin/ubusd
      753 root       940 S    /sbin/askfirst /bin/login.sh
     1715 root      1596 S    /opt/intel/bin/dump_handler -i 0 -f /opt/intel/wave/
     1755 root      2544 S    /usr/sbin/dwpal_cli -iDriver -vwlan0 -lFW_DUMP_READY
     1760 root      1288 S    /sbin/logd -S 64
     1969 root      1952 S    sys_cli eth -F /tmp/ppa_cfg.conf
     2009 root      1840 S    /sbin/netifd
     2063 root      3296 S    /usr/bin/td_netlink_recv_online
     2094 root      3780 S    /usr/bin/td_ol_srv
     2139 root      3300 S    /bin/td_flow_statistic_ctl -w
     2201 root      1092 S    /bin/td_wan_speed
     2293 root      1396 S    /usr/sbin/crond -f -c /etc/crontabs -l 5
     2728 root      3616 S    /bin/td_serverd
     2971 root      1392 S procd_set_param：设置服务实例的参数值。通常会有以下几种类型的参数：（每次只能使用一种类型参数，其后是这个类型参数的值）。  
>  command：服务的启动命令行。  
>  respawn：进程意外退出的重启机制及策略，它需要有 3 个设置值。第一个设置为 判断异常失败边界值（threshold），默认为 3600
> 秒，如果小于这个时间退出，则 会累加重新启动次数，如果大于这个临界值，则将重启次数置 0。第二个设置为
> 重启延迟时间（timeout），将在多少秒后启动进程，默认为 5 秒。第三个设置是总
> 的失败重启次数（retry），是进程永久退出之前的重新启动次数，超过这个次数进 程退出之后将不会再启动。默认为 5
> 次。也可以不带任何设置，那这些设置都是 默认值。  
>  env：进程的环境变量。  
>  file：配置文件名，比较其文件内容是否改变。  
>  netdev：绑定的网络设备（探测 ifindex 更改）。  
>  limits：进程资源限制。
procd.sh 中封装的函数远不止这些，还有以下几个
  * procd_open_trigger
  * procd_close_trigger
  * procd_add_reload_trigger
  * procd_open_validate
  * procd_close_validate
  * procd_kill
  * procd_close_service
  * procd_open_service(name, [script])
  * uci_validate_section
在前面我们调用stop命令可以停止进程的运行，但是使用kill 命令无法停止进程，是因为procd 的作用。
可是上面的 /etc/init.d/httpd 脚本内容并没有 stop 函数内容，那是因为脚本调用了 /etc/rc.common
文件内的函数，而在rc.common 中的stop函数内容中调用了procd.sh 中的procd_kill 函数。
procd_kill 函数的内容如下，会调用ubus delete 删除指定的进程，从而结束对进程的调用。
> procd_kill 函数
>
> 杀掉服务实例（或所有的服务实例）。至少需要一个参数，第一个参 数是服务名称，通常为进程名，第二个是可选参数，是进程实例名称，因为可能有多个进
> 程示例，如果不指定所有的实例将被关闭。该函数在 rc.common 中调用，用户从命令行调 用 stop 函数时会使用该函数杀掉进程。
在/etc/init.d/httpd 脚本中自定义了start_service()
函数，这个函数在rc.common中也有，那么对于httpd而言，重写了这个函数，在/etc/init.d/httpd 中还定义了USE_PROCD
变量，这个变量的作用除了使用procd来管理httpd进程，还能调用procd预定义的函数，procd预定义的函数有以下几个函数：
  * start_service 向 procd 注册并启动服务，是将在 services 所管理对象里面增加了一项
  * stop_service 让 procd 解除注册，并关闭服务, 是将在 services 中的管理对象删除
  * service_triggers 配置文件或网络接口改变之后触发服务重新读取配置
  * service_running 查询服务的状态
  * reload_service 重启服务，如果定义了该函数，在 reload 时将调用该函数，否则再次调用 start 函数
  * service_started 用于判断进程是否启动成功
另外，我使用kill 命令尝试结束procd 进程的时候，procd 进程的pid号是1。这是因为在内核参数启动调用的初始化进程preint后，procd
会继承preint 的进程号pid 1。并且在kill 1 的时候，Tenda AX12 设备会进行重启。
procd 启动的顺序为：
## 0x04 httpd 启动
对于httpd 进程的启动，结合OpenWrt 系统的启动流程，和对procd 模块的了解。设备在上电的之后，uboot 会自己启动，在uboot
启动之后，调用Kernel ，Kernel 会调用/etc/preinit 脚本，并且设备在自启动的时候，根据linux
的特性，会启动/etc/init.d目录下的脚本。httpd 脚本会自启动，调用procd.h 中定义的预函数，使用ubus模块向procd
模块注册httpd进程的实例信息。httpd 启动的流程如下图所示：
## 0x05 总结
本文通过Tenda AX12 Wi-Fi6 路由器 UART log 信息和OpenWrt 的特性对设备的启动流程进程梳理和分析，另外，还介绍了procd
守护进程的作用和procd 守护进程对系统做是如何进行对设备内的进程进行管理。当掌握这些之后，对设备的研究会更加熟练。
## 0x06 参考