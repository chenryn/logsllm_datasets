versions. Attackers could leverage the found ROP gadgets in them to launch the
ROP attack.
Blender: Self-randomizing Address Space Layout for Android Apps
463
Table 1. Number of unique ROP gad-
gets of loaded libraries in the zygote
process.
)
e
t
y
B
(
n
o
i
t
c
e
S
t
x
e
t
.
f
o
e
z
i
S
7
10
6
10
5
10
4
10
3
10
2
10
boot.oat (22.9 MB)
libLLVM.so (7.4 MB)
libart.so (3.2 MB)
libc.so (301.1 KB)
Android 2.2
Android 2.3.3
Android 4.0.3
Android 4.2.2
Android 4.3.1
Android 5.1.1
M Preview
16 MB
1 MB
512 KB
128 KB
1 KB
0
20
40
60
80
100
Shared Libraries Loaded in Zygote (Sorted By Size)
Fig. 3. Increasing .text section sizes of
loaded shared libraries in zygote for diﬀer-
ent Android major versions.
How to Exploit? To further understand the way to launch the ROP attack on
Android, we use an example to illustrate the whole process. Figure 4 shows the
ﬂow of this attack. The attack scenario involves two apps. The objective of the
ﬁrst app (App A) is to obtain the current memory layout. This app can be a sim-
ple trojan app installed beforehand. Note that one app can access its own mem-
ory layout without any privileged permission. By reading the /proc/self/maps
ﬁle, attackers can easily obtain the memory mapping information including
library names, base addresses, and protect permissions, etc. The second app (App
B) is the target app for an ROP attack, which has a buﬀer overﬂow vulnerability
(e.g., popular apps like VLC [13] and Adobe Flash [1] have such vulnerability).
Attackers ﬁrst induce users to install the ﬁrst app (App A) (step 1) to obtain the
current memory layout (step 2). Secondly, attackers can craft a chain of gadgets
using common libraries such as libc.so and libart.so, then determine the
absolute addresses according to the current memory layout obtained previously.
At last, attackers exploit the buﬀer overﬂow vulnerability of the legitimate app
(App B) to initiate an ROP attack (step 3). By jumping and chaining executable
gadgets, attackers can execute arbitrary privileged code for further attacks.
Even though the proposed attack in Fig. 4 leverages the ﬁrst app (App A)
to obtain the memory layout information, this information could be obtained
through exploiting vulnerabilities in legitimate apps. For example, several known
vulnerabilities of the Chrome Browser [4,5] and Samsung KNOX browser [8] can
leak part of the memory information. That means the proposed attack could
be launched remotely without the need to install the ﬁrst app (App A). This
conclusion has been demonstrated in the previous research [32] and we will not
discuss its details in this paper.
464
M. Sun et al.
Fig. 4. ROP attack on Android (return-to-library attack and return-to-art attack).
3.2 The New Return-to-ART Attack (ret2art)
When launching the ROP attack, the most complicated part is to design a valu-
able gadget chain and execute malicious payloads. Traditionally, attackers could
leverage particular system calls (e.g., execve()) or existing functions in common
libraries (e.g., system() and strcpy() in libc library) for this purpose. How-
ever, in the context of the Android system, it is hard for attackers to construct
meaningful payloads. For instance, if attackers want to send a text message to
subscribe to a premium service to make money, or to steal private information
from a local database, they have to bridge the semantic gap between the mali-
cious operations and low level APIs. Though the Android framework provides
many useful APIs, it is hard for attackers to invoke them since these APIs are in
the format of the Dalvik bytecode and cannot be executed directly. Therefore,
it is a non-trivial task to construct malicious payloads on Android.
The ART runtime was introduced since the latest Android version 5.0. We
found that the design and implementation of the ART runtime exposes a new
attack surface, which is called return-to-ART (ret2art) attack. It eases the con-
struction of malicious payloads and attackers could initiate more powerful and
damaging attacks.
What Went Wrong? Due to the introduction of the ART runtime, the
addresses of the pre-compiled native code of the system framework APIs are
predictable. First, boot.oat and boot.art ﬁles contain the compiled native
code and related metadata of Android framework APIs. These two ﬁles are
generated by phone vendors before shipping the devices to users, and will not
change unless there is a new OTA update image. Therefore, these ﬁles are same
across all devices using the same ﬁrmware image. Second, the base address of
boot.art is ﬁxed (0x70000000 for the 32-bit ARM architecture) in the AOSP
source code (in the /build/core/dex preopt libart.mk ﬁle [11]). The exact
mapping address of the boot.oat ﬁle is patched when the device is ﬁrst booted,
and will not change unless a system update is performed. The patch oﬀset
Blender: Self-randomizing Address Space Layout for Android Apps
465
1
2
3
4
5
6
7
8
9
10
11
12
13
$ adb shell oatdump -oat-file=/system/framework/arm/boot.oat
...
IMAGE PATCH DELTA: -724992 (0xfff4f000)
...
40: Landroid/telephony/SmsManager; (offset=0x015d849c) (type_idx=198) (StatusVerified) (
(cid:2)→ OatClassSomeCompiled)
...
37: void android.telephony.SmsManager.sendTextMessage(java.lang.String, java.lang.String,
(cid:2)→ java.lang.String, android.app.PendingIntent, android.app.PendingIntent)} (
(cid:2)→ dex_method_idx=844)
OatMethodOffsets (offset=0x015d853c)
code_offset: 0x02ca944d
...
CODE: (code offset=0x02ca944d size_offset=0x02ca9448 size=324)...
0x02ca944c: f5bd5c00 subs
...
r12, sp, #8192
Code Snippet 1.1. Example of oatdump for boot.oat ﬁle.
of the boot.oat ﬁle is ﬁxed between -0x01000000 and 0x01000000 as indi-
cated in /art/build/Android.common build.mk. For instance, if the patch oﬀ-
set of boot.oat is 0x8000, then boot.oat will be mapped to the ﬁxed address
0x70008000 every time for every app running on the device, until the device
updates its ﬁrmware image.
The predictable nature of the addresses of loaded oat and art ﬁles exposes a
new attack surface (the ret2art attack). First, boot.oat is loaded by the zygote
process and inherited by all other apps. Therefore, the base address of the
boot.oat ﬁle is ﬁxed for every app in each execution. Second, the boot.oat
ﬁle is mapped as an executable region in memory. It contains abundant number
of compiled native code of all methods in the Android framework, and provides
a fertile ground for ROP gadgets. According to Fig. 3, the size of the executable
code in this ﬁle is around 22.9 MB. Third, the code oﬀsets for each method are
ﬁxed and can be easily located from the structured metadata from either the
boot.art ﬁle or the boot.oat ﬁle. Therefore, attackers can craft gadgets and
jump to the native code oﬀset of a method in the boot.oat ﬁle. Figure 4 illus-
trates the basic ﬂow of the re2art attack. Similar with the conventional ROP
attack, attackers can hijack the control ﬂow to the ART executable code. This
way, attackers can invoke framework APIs in the ART runtime, which facili-
tates the construction of malicious payloads. For instance, attackers can use the
getLastKnowLocation() API to obtain any recent geographical location infor-
mation.
How to Exploit? Suppose attackers want to send a text message to achieve an
unauthorized premium services subscription. First, attackers need to get the oﬀ-
set of the sendTextMessage method in the boot.oat ﬁle. This can be achieved
by reading the boot.oat of the ﬁrmware using the oatdump tool. Note that,
since this oﬀset is only related to particular ﬁrmware, attackers could get this
knowledge in advance by downloading ﬁrmwares from Internet and obtain a
mapping table of oﬀsets of interested APIs to the ﬁrmware ﬁngerprint. The base
466
M. Sun et al.
Table 2. Parameter description of
“Invocation Stub”.
address of the boot.oat ﬁle is ﬁxed after the system is ﬁrst powered, and could
be obtained through another trojan app or information leak vulnerabilities in
other apps, and even guessed since the base address is around a ﬁxed loca-
tion 0x70000000. Code snippet 1.1 shows an example of the dumped boot.oat
ﬁle. We can ﬁnd that the code oﬀset of the sendTextMessage method is ﬁxed
in the boot.oat ﬁle at 0x02ca944d (line 11). Second, similar to the previous
ROP attack, attackers can obtain the base address of boot.oat ﬁle locally or
remotely. Combing the obtained oﬀset and the base address, attackers now have
the absolute address of the method. Third, attackers exploit existing or zero-day
buﬀer overﬂow vulnerabilities of the target app to hijack the control ﬂow for initi-
ating a ret2art attack. Note that attackers cannot directly jump to this address
and execute the code, because the framework code should be executed with
the support of the ART runtime. Speciﬁcally, the ART runtime executes native
methods through an invocation stub code, i.e., the art quick invoke stub func-
tion deﬁned in the quick entrypoints arm.S assembly ﬁle [12] for the ARM
platform. Before invoking this code, attackers have to prepare several registers
for related parameters as shown in Table 2. After passing these registers to the
art quick invoke stub function, the function will ﬁnally load the compiled code
to a register as a branch address. As shown in Code Snippet 1.2, the address is
calculated by summing up r0 with an oﬀset METHOD QUICK CODE OFFSET 32 in
line 8, that is, the address of entry point from quick compiled code ﬁeld in
the ArtMethod class. Moreover, r1-r3 are copied from the stack controlled by
attackers, which makes the ret2art attack even easier. Therefore, to initiate a
ret2art attack, the attacker can branch (e.g., blx reg) to this stub function and
invoke the sendTextMessage framework API. If the target app has declared the
“SEND SMS” permission, attackers can use this technique to subscribe to some
premium services, or to spread the trojan app via messages.
4 Blender
In this section, we present the design and implementation of Blender, a user-
level solution to mitigate threats caused by the weakened ASLR implementation
on Android and the new ret2art attack.
Blender: Self-randomizing Address Space Layout for Android Apps
467
4.1 High Level System Design
Design Requirements. Our goal is to provide a user-level solution. Accord-
ingly, we follow several design requirements to balance protection strength, per-
formance, and practical system deployment.
Complete Protection: Our system needs to mitigate the threats introduced by
both the zygote application creation process and the new ART runtime. This
means that our system has to eliminate the predictability of the memory layout
for loaded system libraries, and the pre-compiled native code of the framework
APIs (the boot.oat ﬁle).
Lightweight Protection:
It naturally requires that our system should be memory-
and energy-eﬃcient. The performance overhead should not aﬀect user experi-
ence. Moreover, the overhead introduced should not aﬀect the apps without our
protection.
Easy Deployment: Our system should maintain the compatibility of existing
apps, and not require any change to the Android framework nor the Linux kernel.
Also, the changes made to apps for deploying our system should be minimum.
Threat and Trust Model. As our purpose is to provide a user-level solution
to mitigate the threat of weakened ASLR protection on Android, we assume app
developers are trusted. However, their apps or libraries that apps are depending
on may have security vulnerabilities and could be exploited by attackers both
locally and remotely to arbitrarily read, write, and execute code in app’s memory.
Their apps have higher security requirements, and they want to provide the self-
protection capability to their apps. By deploying our solution, the empowered
self-protection capability makes the exploitation of the vulnerabilities in their
apps much harder.
Design Overview. Blender provides protection in two diﬀerent aspects.
First, Blender randomizes the addresses of loaded system libraries for apps
using our system. This eliminates the possibility that the memory layout of
these libraries are predictable. From this perspective, our system provides similar
security guarantees as previous work [32], by solely in user space, without making
changes to the Android framework. Second, Blender deals with the new ret2art
attack by randomizing the executable code of the pre-compiled framework APIs
(i.e., boot.art and boot.oat ﬁles) in the ART runtime. This is a new security
guarantee which is not covered by previous research.
Accordingly, Blender contains three components: (1) the bootstrap module,
(2) Blender library randomization module (short for BlenderLRM), and (3)
Blender ART randomization module (short for BlenderART). The bootstrap
module takes over the startup stage of an app, and prepares the running environ-