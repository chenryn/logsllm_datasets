[10] DEVELOPERS, S.
SELinux Kernel ToDo.
https:
//github.com/SELinuxProject/selinux/wiki/
Kernel-Todo, 2015.
[11] DEVRIESE, D., AND PIESSENS, F. Noninterference through se-
cure multi-execution. In 31st IEEE Symposium on Security and
Privacy (May 2010).
1134  25th USENIX Security Symposium 
USENIX Association
[12] DIETZ, M., SHEKHAR, S., PISETSKY, Y., SHU, A., AND WAL-
LACH, D. S. Quire: Lightweight Provenance for Smart Phone
Operating Systems. In Proceedings of the USENIX Security Sym-
posium (2011).
[28] NADKARNI, A., AND ENCK, W. Preventing Accidental Data
Disclosure in Modern Operating Systems.
In Proceedings of
the ACM Conference on Computer and Communications Secu-
rity (CCS) (2013).
[13] ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG,
TaintDroid: An
J., MCDANIEL, P., AND SHETH, A. N.
Information-Flow Tracking System for Realtime Privacy Mon-
itoring on Smartphones.
In Proceedings of the 9th USENIX
Symposium on Operating Systems Design and Implementation
(OSDI) (2010).
[14] FELT, A. P., WANG, H. J., MOSHCHUK, A., HANNA, S., AND
CHIN, E. Permission Re-Delegation: Attacks and Defenses. In
Proceedings of the USENIX Security Symposium (2011).
[15] GIFFIN, D. B., LEVY, A., STEFAN, D., TEREI, D., MAZI `ERES,
D., MITCHELL, J. C., AND RUSSO, A. Hails: Protecting Data
Privacy in Untrusted Web Applications. In Presented as part of
the 10th USENIX Symposium on Operating Systems Design and
Implementation (OSDI 12) (2012).
[16] GRACE, M., ZHOU, Y., WANG, Z., AND JIANG, X. Systematic
Detection of Capability Leaks in Stock Android Smartphones. In
Proceedings of the ISCO Network and Distributed System Secu-
rity Symposium (2012).
[17] HORNYACK, P., HAN, S., JUNG, J., SCHECHTER, S., AND
WETHERALL, D. These Aren’t the Droids You’re Looking For:
Retroﬁtting Android to Protect Data from Imperious Applica-
tions. In Proceedings of the ACM Conference on Computer and
Communications Security (CCS) (2011).
EDER.
Scalability
[18] JEREMY
Storage
developerblog.redhat.com/2014/09/30/
overview-storage-scalability-docker/.
Comprehensive
Docker.
in
Overview
of
https://
[19] JIA, L., ALJURAIDAN,
J., FRAGKAKI, E., BAUER, L.,
STROUCKEN, M., FUKUSHIMA, K., KIYOMOTO, S., AND
MIYAKE, Y. Run-Time Enforcement of Information-Flow Prop-
erties on Android (Extended Abstract).
In Proceedings of the
European Symposium on Research in Computer Security (ES-
ORICS) (2013).
[20] KROHN, M., AND TROMER, E. Noninterference for a Practi-
cal DIFC-Based Operating System. In Proceedings of the IEEE
Symposium on Security and Privacy (2009).
[21] KROHN, M., YIP, A., BRODSKY, M., CLIFFER, N.,
KAASHOEK, M. F., KOHLER, E., AND MORRIS, R. Informa-
tion Flow Control for Standard OS Abstractions. In Proceedings
of ACM Symposium on Operating Systems Principles (SOSP)
(2007).
[22] LAGEMAN, M., AND SOLUTIONS, S. C. Solaris Containers-
What They Are and How to Use Them.
[23] MCILROY, M. D., AND REEDS, J. A. Multilevel security in the
UNIX tradition. Software: Practice and Experience (1992).
[24] MERKEL, D. Docker: lightweight linux containers for consistent
development and deployment. Linux Journal (2014).
[25] MYERS, A. C. JFlow: Practical Mostly-Static Information Flow
Control. In Proceedings of the ACM Symposium on Principles of
Programming Languages (POPL) (1999).
[26] MYERS, A. C., AND LISKOV, B. A Decentralized Model for In-
formation Flow Control. In Proceedings of the ACM Symposium
on Operating Systems Principles (SOSP) (1997).
[27] MYERS, A. C., AND LISKOV, B. Protecting Privacy Using the
Decentralized Label Model. ACM Transactions on Software En-
gineering and Methodology (2000).
[29] NEIL BROWN.
Overlay Filesystem.
https://www.
kernel.org/doc/Documentation/filesystems/
overlayfs.txt.
[30] PORTER, D. E., BOND, M. D., ROY, I., MCKINLEY, K. S.,
AND WITCHEL, E. Practical Fine-Grained Information Flow
Control Using Laminar. ACM Trans. Program. Lang. Syst. (Nov.
2014).
[31] REPS, T. W. Program Analysis via Graph Reachability. Infor-
mation & Software Technology 40, 11-12 (1998).
[32] RODEH, O., BACIK, J., AND MASON, C. BTRFS: The Linux
B-Tree Filesystem. ACM Transactions on Storage (TOS) (Aug.
2013).
[33] ROY, I., PORTER, D. E., BOND, M. D., MCKINLEY, K. S.,
AND WITCHEL, E. Laminar: Practical Fine-Grained Decentral-
ized Information Flow Control. In Proceedings of the Conference
on Programming Language Design and Implementation (PLDI)
(2009).
[34] SAMSUNG ELECTRONICS. An Overview of Samsung Knox.
http://www.samsung.com/global/business/
business-images/resource/white-paper/2014/
02/Samsung_KNOX_whitepaper_June-0-0.pdf,
2013.
[35] SCHAUFLER, C. LSM: Multiple concurrent LSMs. https:
//lkml.org/lkml/2013/7/25/482, 2013.
[36] SHARIR, M., AND PNUELI, A. Two Approaches to Interproce-
dural Data Flow Analysis. In Program Flow Analysis: Theory
and Applications. 1981.
[37] SHIVERS, O. Control-Flow Analysis of Higher-Order Lan-
guages. PhD thesis, Carnegie Mellon University Pittsburgh, PA,
1991.
[38] SPAHN, R., BELL, J., LEE, M., BHAMIDIPATI, S., GEAM-
BASU, R., AND KAISER, G. Pebbles: Fine-Grained Data Man-
agement Abstractions for Modern Operating Systems.
In Pro-
ceedings of the USENIX Operating Systems Design and Imple-
mentation (OSDI) (2014).
[39] STATISTA.
Number of
in the
Google Play Store from December 2009 to February 2016.
http://www.statista.com/statistics/266210/
number-of-available-applications-in-the-google-play-store/.
applications
available
[40] STEFAN, D., RUSSO, A., MITCHELL, J. C., AND MAZI `ERES,
D.
Flexible Dynamic Information Flow Control in Haskell.
In Proceedings of the 4th ACM Symposium on Haskell (2011),
Haskell ’11.
[41] STEFAN, D., YANG, E. Z., MARCHENKO, P., RUSSO, A., HER-
MAN, D., KARP, B., AND MAZI `ERES, D. Protecting Users
by Conﬁning JavaScript with COWL. In 11th USENIX Sympo-
sium on Operating Systems Design and Implementation (OSDI
14) (Oct. 2014).
[42] STEFAN, H., STEFAN, D., YANG, E. Z., RUSSO, A., AND
MITCHELL, J. C. IFC Inside: Retroﬁtting Languages with Dy-
namic Information Flow Control. In Proceedings of the 4th Con-
ference on Principles of Security and Trust (POST 2015) (2015).
[43] TANG, Y., AMES, P., BHAMIDIPATI, S., BIJLANI, A., GEAM-
BASU, R., AND SARDA, N. CleanOS: Limiting Mobile Data Ex-
posiure with Idle Eviction. In Proceedings of the USENIX Sympo-
sium on Operating Systems Design and Implementation (OSDI)
(2012).
USENIX Association  
25th USENIX Security Symposium  1135
Call 
(Component C)
callerLabel = 
label(caller's process)
Resolve Target 
component 
name (C)
Yes
No
Is C 
running?
No
Create a new 
instance of C
P = 
match_Weir
_Proc(P, 
callerLabel)
Resolve target 
process P for 
C.processName
 label (C's 
process) == 
callerLabel ?
Yes
Yes
Is P 
running?
No
Start new 
process P for 
C
Set callerLabel 
as label (P)
Deliver the call 
to C
match_Weir_Proc
(Process P, Label 
callerLabel)
Yes
callerLabel 
== label (P)?
No
pList = 
weirProcessList 
(P.processName)
Yes
pList.next()!= 
P = 
null?
No
No
Yes
callerLabel 
== label 
(P)?
Yes
Allocate new 
Process P'
P = P'
pList.add (P')
Return 
P
Figure 8: Flow of the Activity Manager starting a com-
ponent. The areas modiﬁed or added by Weir are shaded.
[44] VANDEBOGART, S., EFSTATHOPOULOS, P., KOHLER, E.,
KROHN, M., FREY, C., ZIEGLER, D., KAASHOEK, F., MOR-
RIS, R., AND MAZI `ERES, D. Labels and Event Processes in
the Asbestos Operating System. ACM Transactions on Computer
Systems (TOCS) (2007).
[45] WALSH,
D.
SELinux/OverlayFS
integration.
https://twitter.com/rhatdan/status/
588338475084029953, 2015.
[46] XU, Y., AND WITCHEL, E. Maxoid:
transparently conﬁning
mobile applications with custom views of state. In Proceedings
of the Tenth European Conference on Computer Systems (2015),
ACM.
[47] YANG, J., HANCE, T., AUSTIN, T. H., SOLAR-LEZAMA,
A., FLANAGAN, C., AND CHONG, S. End-To-End Policy-
Agnostic Security for Database-Backed Applications.
arXiv
preprint arXiv:1507.03513 (2015).
[48] YANG, J., YESSENOV, K., AND SOLAR-LEZAMA, A. A Lan-
guage for Automatically Enforcing Privacy Policies. In Proceed-
ings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on
Principles of Programming Languages (2012).
[49] ZELDOVICH, N., BOYD-WICKIZER, S., KOHLER, E., AND
MAZI `ERES, D. Making Information Flow Explicit in HiStar. In
Proceedings of the 7th symposium on Operating Systems Design
and Implementation (2006).
[50] ZELDOVICH, N., BOYD-WICKIZER, S., AND MAZIERES, D.
Securing Distributed Systems with Information Flow Control. In
Proceedings of the USENIX Symposium on Networked Systems
Design and Implementation (2008).
A Component Polyinstantiation Logic
In this section, we describe Weir’s changes to the Ac-
tivity Manager service’s component and process assign-
ment logic. Figure 8 shows the workﬂow inside the
Activity Manager when a component C is called. The
shaded blocks form Weir’s label checks and polyinstan-
tiation logic. Note that the ﬁgure portrays the high level
steps followed by the Activity Manager, common to all
components. When a call arrives, Weir ﬁrst gets the la-
bel for the caller’s process from the kernel and stores it
in callerLabel. The Activity Manager then resolves the
target component C using the information in the call. At
this point the Activity Manager only knows the name and
type of the target component (e.g., the content provider
C). The Activity Manager then checks if there is a run-
time instance of C in its records. If a runtime instance
exists and is executing in a process with a matching la-
bel, the call is delivered to the running instance. Other-
wise, Weir forces the Activity Manager to create another
runtime instance, for this new callerLabel.
Without Weir, the Activity Manager would always de-
liver the call to the existing instance.5 Weir modiﬁes the
Activity Manager’s internal bookkeeping structures to be
consistent with its polyinstantiation; i.e., it enables the
Activity Manager to manage multiple runtime records
for the same component. For example, the ActivityMan-
ager uses a direct mapping between a service’s name and
its runtime instance, to store records of running services.
Weir modiﬁes this mapping to one between the name and
a set of services.
At this stage, the system has a new component in-
stance that needs to be executed in a process. The Ac-
tivity Manager selects the process based on the pro-
cessName extracted from the “android:process” mani-
fest attribute. A runtime record of the resolved pro-
cess P is then sent to Weir for process matching (i.e.,
the Match Weir Proc (P, callerLabel) subroutine). Weir
ﬁrst checks the label of the existing process P, and if it
matches, returns P itself. If not, Weir retrieves its internal
list of processes associated with P. This list constitutes
the processes that were created in the past to be assigned
instead of P for speciﬁc caller labels. Weir checks if the
list contains a process with a label matching the current
callerLabel; this step ensures that components with the
same processName as well as callerLabel are executed in
the same process. If Weir fails to ﬁnd a matching process
in the list, it allocates a new process for the callerLabel,
and adds it to the list of existing processes mapped to the
speciﬁc processName. This process is then returned as
P to the Activity Manager. The Activity Manager then
starts P, if it is not already started, and Weir sets its label
in the kernel. Note that if the process is already started
(i.e., the original P was matching, or a matching process
was found in Weir’s pList (P.processName), the Activity
Manager does not restart it. Finally, the component in-
stance is executed in the assigned process, and the call is
delivered to it.
5Except in the case of standard and multi-process activities.
1136  25th USENIX Security Symposium 
USENIX Association