title:Diglossia: detecting code injection attacks with precision and efficiency
author:Sooel Son and
Kathryn S. McKinley and
Vitaly Shmatikov
Diglossia: Detecting Code Injection Attacks
with Precision and Efﬁciency
Sooel Son
The University of Texas at
PI:EMAIL
Austin
Kathryn S. McKinley
Microsoft Research
The University of Texas at
Austin
PI:EMAIL
Vitaly Shmatikov
The University of Texas at
PI:EMAIL
Austin
ABSTRACT
Code injection attacks continue to plague applications that incor-
porate user input into executable programs. For example, SQL in-
jection vulnerabilities rank fourth among all bugs reported in CVE,
yet all previously proposed methods for detecting SQL injection
attacks suffer from false positives and false negatives.
This paper describes the design and implementation of DIGLOS-
SIA, a new tool that precisely and efﬁciently detects code injec-
tion attacks on server-side Web applications generating SQL and
NoSQL queries. The main problems in detecting injected code
are (1) recognizing code in the generated query, and (2) determin-
ing which parts of the query are tainted by user input. To recog-
nize code, DIGLOSSIA relies on the precise deﬁnition due to Ray
and Ligatti. To identify tainted characters, DIGLOSSIA dynami-
cally maps all application-generated characters to shadow charac-
ters that do not occur in user input and computes shadow values for
all input-dependent strings. Any original characters in a shadow
value are thus exactly the taint from user input.
Our key technical innovation is dual parsing. To detect injected
code in a generated query, DIGLOSSIA parses the query in tandem
with its shadow and checks that (1) the two parse trees are syntacti-
cally isomorphic, and (2) all code in the shadow query is in shadow
characters and, therefore, originated from the application itself, as
opposed to user input.
We demonstrate that DIGLOSSIA accurately detects both SQL
and NoSQL code injection attacks while avoiding the false posi-
tives and false negatives of prior methods. By recasting the prob-
lem of detecting injected code as a string propagation and parsing
problem, we gain substantial improvements in efﬁciency and pre-
cision over prior work. Our approach does not require any changes
to the databases, Web servers, or Web browsers, adds virtually un-
noticeable performance overhead, and is deployable today.
Categories and Subject Descriptors Security and
privacy — Intrusion/anomaly detection and malware mitigation —
Intrusion detection systems
Keywords Web application security; Dynamic analysis; Code
injection; SQL injection; NoSQL injection; Taint tracking
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516696.
1.
INTRODUCTION
Diglossia /d¯I" glˆos¯e@/ noun
A situation in which two languages (or two varieties of the same
language) are used under different conditions within a community,
often by the same speakers.
Oxford Dictionaries
Modern Web applications accept input from users and incorporate
it into dynamically generated code. For example, a Web application
may invite the user to ﬁll a form, post a comment, or submit a user-
name and password for authentication. The application then takes
this user-provided input and inserts it into a dynamically gener-
ated program in another language—for example, a new client-side
script, or an SQL or JavaScript query to a back-end database.
A code injection attack occurs when a malicious user manages
to inject his own code into the program generated by the applica-
tion. Injected code may steal data, compromise database integrity,
and/or bypass authentication and access control, violating system
correctness, security, and privacy properties.
Database queries generated by server-side Web applications are
a classic target of code injection. For example, SQL injection at-
tacks on retail stores owned by TJX Companies compromised more
than 45 million credit and debit numbers in 2005-2007 [23]. SQL
injection vulnerabilities still rank fourth among all reported CVE
bugs [4], and, according to the 2012 WhiteHat security report, SQL
injection attacks are the eighth most prevalent attack type [25].
The recent trend towards NoSQL databases [14] is not improv-
ing the situation. Many NoSQL databases, including MongoDB,
CouchDB, and DynamoDB, use JSON and/or JavaScript as query
languages, but this does not help protect NoSQL-based applica-
tions from code injection attacks. In 2010, Diaspora reported a se-
rious NoSQL injection vulnerability in its social community frame-
work [15]. Code injection attacks on JavaScript queries for Mon-
goDB were demonstrated at Black Hat 2011 [21].
By deﬁnition, a code injection attack on a Web application in-
volves tainted code: the application generates a string that is inter-
preted as an executable program (e.g., an SQL or NoSQL query),
and the string contains user input that is interpreted as code when
the program executes. Preventing code injection attacks therefore
requires precisely determining (1) which parts of the generated
string are code, and (2) which parts of the generated string are
tainted by user input.
All prior approaches to runtime detection of code injection at-
tacks suffer from two types of problems. They either fail to pre-
cisely deﬁne what constitutes code, or their taint analysis algo-
rithm does not identify exactly which characters in the application-
generated string originate from user input and which originate from
1181the application itself. Errors of both types lead to false positives
(benign queries rejected) and false negatives (code injection attacks
accepted as valid queries).
Our contributions. We design, implement, and evaluate DIGLOS-
SIA, a new runtime tool that precisely and efﬁciently detects code
injection attacks. The key idea behind our approach is to transform
the problem of detecting injected code into a string propagation and
parsing problem.
In tandem with the application computing its output string,
DIGLOSSIA computes a shadow of this string. The purpose of
the shadow is to identify user input in the application-generated
string. In the shadow string, all characters introduced by the ap-
plication itself are remapped to a shadow character set, which is
disjoint from all characters in user input; the shadow value thus pre-
cisely encodes which characters came from user input and which
came from the application. To precisely identify code, DIGLOSSIA
relies on the deﬁnitions by Ray and Ligatti [17]. DIGLOSSIA uses
a novel dual parsing technique to compare the shadow string with
the actual string generated by the application and ensure that the
actual string does not contain any code tainted by user input.
Our basic approach is language-agnostic and does not depend
on the details of the language used to implement the application,
nor the target language of the generated string. For concreteness,
our DIGLOSSIA prototype works with server-side PHP applications
generating database queries in SQL, JSON, or JavaScript. Conse-
quently, we use the term query for the generated string.
Deﬁning code injection attacks.
Ray and Ligatti show that
deﬁning code simply as pre-speciﬁed keywords and operators does
not provide a clear distinction between code and non-code.
In-
stead, precisely identifying code and non-code requires parsing the
query [17].
Following Ray and Ligatti, only values (numeric and string liter-
als) and reserved values (NULL, TRUE, etc.) are non-code. Code
comprises all reserved keywords, operators, and method calls, as
well as all uses of bound identiﬁers (variables, types, and method
names). Note that this deﬁnition forbids the dangerous program-
ming practice where certain user inputs are intended by a developer
to be interpreted as code in the query. In the absence of strict access
control on database operations, this practice may lead to arbitrary
code execution and should be deprecated.
With their deﬁnition of code and non-code in hand, Ray and Lig-
atti show that all prior approaches for detecting code injection suf-
fer from false negatives and false positives. They illustrate these
inaccuracies with 11 SQL injection attacks and non-attacks, which
are explained in detail in Section 3.1 and summarized in Table 1.
For example, the attack in Case 5 injects a call to a bound method.
All prior approaches miss this attack, but DIGLOSSIA detects it.
On the other hand, Case 7 shows how a use of a reserved literal
(TRUE) causes at least one prior tool to report a false positive
whereas DIGLOSSIA correctly classiﬁes this case.
Value shadowing. To identify taints efﬁciently, DIGLOSSIA dy-
namically creates a shadow string for each query issued by the ap-
plication P . In the shadow query, all application-generated parts
use shadow characters, while all tainted parts—i.e., substrings orig-
inating from user input—use original characters.
When P is invoked, DIGLOSSIA dynamically generates a set of
shadow characters that occur in neither user input, nor the query
language. DIGLOSSIA then creates a one-to-one map from each
character used by the query language to a unique shadow character.
As P executes, DIGLOSSIA computes shadow values for all
strings computed by P that depend on user input. DIGLOSSIA
follows the control ﬂow of P ’s execution and performs shadow
operations only on input-dependent string and character array op-
erations. In a shadow string, all characters c originating from P
are remapped to shadow characters sc where sc = map(c), while
all characters originating from user input remain intact. Value
shadowing is a precise, lightweight way to propagate character-
level taint information. We implement this functionality as a PHP
interpreter extension that dynamically remaps characters and com-
putes shadow values in tandem with the string and character array
operations performed by P .
Dual parsing. To guarantee that the query issued by the applica-
tion P does not contain injected code, it is sufﬁcient to ensure the
following two properties. First, the shadow query must not contain
injected code (technically, the code in the shadow query must not
be tainted by user input). Second, the actual query must be syntac-
tically isomorphic to the shadow query.
When P issues a query, DIGLOSSIA examines this query and its
shadow using a dual parser. Dual parsing is the key technical inno-
vation in DIGLOSSIA. For any string accepted by the original query
language, the dual parser accepts the same string, as well as strings
in which the original characters are replaced with their correspond-
ing shadow characters. DIGLOSSIA examines the parse trees of
the actual query and its shadow and establishes the following two
conditions:
1. There is a one-to-one mapping between the parse tree of the ac-
tual query and the parse tree of the shadow query. In particular,
all code in the actual query maps exactly to equivalent code in
the shadow query.
2. The shadow query does not contain any code in the original
language L.
If either condition does not hold, DIGLOSSIA reports a code injec-
tion attack. Intuitively, the presence of any original-language code
in the shadow query and/or any syntactic difference between the
actual query and its shadow indicate a code injection attack.
Evaluation and deployability. We demonstrate the precision
and efﬁciency of DIGLOSSIA on 10 open-source PHP Web ap-
plications that issue queries to relational MySQL and MongoDB
NoSQL back-end databases. DIGLOSSIA detects all 25 code in-
jection attacks we attempted against these applications with no
perceptible performance overhead.
Unlike prior tools, DIGLOSSIA correctly classiﬁes 10 out of 11
challenging cases described by Ray and Ligatti [17]—see Table 1.
The sole exception is the case where user input is a number speci-
fying how many objects of a certain type to allocate. Even though
Ray and Ligatti classify this case as code injection, this is a matter
of opinion. We instead classify all integer literals in SQL type def-
initions as values—for example, 64 in CHAR(64) [22]. Therefore,
DIGLOSSIA does not report Case 10 in Table 1 as a code injection.
By recasting the problem of detecting code injection attacks as
a string propagation and parsing problem, we gain substantial im-
provements in efﬁciency and precision over prior work. DIGLOS-
SIA uses shadow values only to detect injected code and does not
actually submit shadow queries to the database. Therefore, in con-
trast to SQL keyword randomization [2] and complementary en-
coding [11], DIGLOSSIA does not require any changes to Web ap-
plications, databases, query parsers, Web servers, or Web browsers.
Unlike these tools, DIGLOSSIA can be deployed today.
2. RELATED WORK
This section compares our approach with prior techniques for stat-
ically detecting SQL injection vulnerabilities in Web applications
11823
Ray and Ligatti’s deﬁnition of code injection [17] Yes Yes Yes
Halfond et al. [5], Nguyen-Tuong et al. [13] Yes Yes Yes
Xu et al. [26] Yes Yes Yes
1
2
Tools
9
8
7
5
4
10
6
No Yes Yes Yes
No Yes Yes
No
No
No
No
No
No
No
No Yes
No
No
No Yes
No Yes Yes
No
No
No
No
No Yes Yes
11
No
No Yes
No Yes
No
No
No Yes
No
No
No
No
No
No
No
No
No
No
SQLCHECK [20] Yes
No
CANDID [1] Yes Yes Yes
DIGLOSSIA Yes Yes Yes
1
2
3
4
5
6
SELECT bal FROM acct WHERE pwd=‘’ OR 1=1 - -’
SELECT balance FROM acct WHERE pin= exit()
...WHERE ﬂag=1000 > GLOBAL
SELECT * FROM properties WHERE ﬁlename=‘f.e’
...pin=exit()
...pin=aaaa()
7
8
9
10
11
SELECT * FROM t WHERE ﬂag=TRUE
SELECT * FROM t WHERE ﬂag=aaaa
SELECT * FROM t WHERE ﬂag=password
CREATE TABLE t (name CHAR(40))
SELECT * FROM t WHERE name=‘x’
Table 1: Canonical code injection attacks and non-attacks misclassiﬁed by prior methods. Underlined terms are user input.
and dynamically detecting attacks exploiting these vulnerabilities.
In Section 3, we explain Ray and Ligatti’s examples shown in Ta-
ble 1 and why prior methods misclassify between 5 and 8 of these
11 examples.
Static methods. Static methods use pointer and taint analysis to
ﬁnd unsanitized data ﬂows from user input to database queries [6,9,
19]. These methods can verify that a sanitization routine is always