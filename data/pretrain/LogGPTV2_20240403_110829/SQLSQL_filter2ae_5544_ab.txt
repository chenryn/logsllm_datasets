接着讲成员属性sql赋值给成员属性SQL，然后删除成员属性中的sql，order，limit变量，然后使用mysqli中的fetch_all方法将查询到的所有结果返回。代码分析到这里，我们可以很明显的看到indexmoel中的index方法存在SQL注入，因为从外到内过滤的东西只有那么一点点，最主要的是这个index控制器中的index方法获取值的时候使用的过滤方式不正确
这里我们来看看这个注入。。。。
访问：[http://localhost/?s=index/index/index/id/3’](http://localhost/?s=index/index/index/id/3%E2%80%99)
可以从它返回的信息看出来这是一个数字型的SQL注入，注入原因呢！是因为未按照正确的获取方式来接收外部数据导致的，我们将/c改为/d
这样就确确实实的将这个SQL注入给过滤掉了，接着我们往下看看字符型的sql注入，当然如果是字符型的注入的情况下并且程序自身有将危险字符转义的时候，那么必须满足先遣条件数据库编码为GBK，这样就存在一个款字节注入，我们将数据库编码改改
我们来看看我们的字符型的注入
这里呢！还是可以很明显的看到这里存在字符型并且是宽字节的注入，访问下
[http://localhost/?s=index/index/String/title/a%df%27](http://localhost/?s=index/index/String/title/a%25df%2527)
只不过现在在代码审计中很难在框架中看到宽字节注入，这里要修复的话直接用/s就好了
可以看到这个宽字节已经被我们给修复了，我们接着往下走，我们来看看验证登陆函数中的注入
我们来简单的分析一下这个函数的作用，首先进入函数中将外部获取到的logintoken并将base64字符串解码并且以制表符分割为数组并且用$uid、$password分别接收这个这个数组中的两个元素，然后将$uid传入到get_user这个模型函数中，可见这里对加密字符串很友好，几乎没有过滤，我们来看看get_user方法是否对$uid进行了过滤
可见都很有善，没有过滤我们构造下payload：
Cookie:logintoken=MScJNjU0ZHM2NWE=
其实这里验证登陆并非一定是一个SQL注入，当程序没有返回值没有错误信息返回的时候，不管是人乃至工具都不可能测试出SQL注入，所以我们大概的估计一个用户id，随后会将返回的users中的password和我们传入的password进行对比，所以这里还可以进行用户密码的爆破，并且还是无限制爆破，从这个案例我们得知不能对即将解密的加密字符串太过友善，否则反受其害。。。。
我们接着来
这里由于获取的参数id会传入url解码函数中，所以这也造成了一个注入，只需要对某一个字符或者字符串进行双重url编码即可
访问：[http://localhost/?s=index/index/articles/id/3%2527](http://localhost/?s=index/index/articles/id/3%252527)
这里的%25%27是双重编码来着，所以说浏览器请求的时候会将%27编码后的结果解码为%27，然后传入程序中程序再将这%27解析为单引号，所以造成了一些意料之外的漏洞。
我们再来看看预编译中的漏洞，为各位解答一下疑问，预编译这东西存在的SQL注入是由于开发者对于sql语句嵌入了用户所输入的值，预编译这东西只能将用户输入的传到数据中，比如id=?那么这个问号就是应该嵌入用户所输入的值，再来看看select
* from $table where
id=?那么这条语句呢就出现了一个致命的弱点，也就造成了SQL注入，那么这个$table就不会只将它当作数据来处理而是当作语句来处理，这是这个致命的关键，我们一起来看看
这里从外部分别获取了key和id，分别将这两个元素传入$where数组中，并传入模型data函数中，我们看看data函数
这里将传入的值预编译了，我们在这里看看最后执行的SQL语句，使用get_last_sql()函数进行查看
我们看看页面中的SQL语句
操作一下这个id看看有没有反应，访问：[http://localhost/?s=index/index/data&id=3%27](http://localhost/?s=index/index/data&id=3%2527)
当然在我们获取值的时候就已经将这玩意定义好了，我们改改吧！改成/c
我们再来访问看看
还是无法操作这个id，那么我们来看看这个key，访问：[http://localhost/?s=index/index/data&id=3%27&key=a](http://localhost/?s=index/index/data&id=3%2527&key=a)
可以看到用户所输入的值不应该用来嵌入到语句中，而是由开发者来定义这些字段等等的，好了，我们再来看看每一个注入点所适用的注入类型，比如这些注入都有返回值和错误信息
所以我们可以用两种最简单的形式来注入一下分别是报错注入和联合查询注入
报错注入：
这里我们使用updatexml函数进行报错注入
访问：[http://localhost/?s=index/index/data&id=3&key=id=3%20and%20(updatexml(1,concat(0x7e,(select%20user()),0x7e),1))%23](http://localhost/?s=index/index/data&id=3&key=id=3%2520and%2520\(updatexml\(1,concat\(0x7e,\(select%2520user\(\)\),0x7e\),1\)\)%2523)
[http://localhost/?s=index/index/data&id=3&key=id=3%20and%20(updatexml(1,concat(0x7e,(select%20table_name%20from%20information_schema.tables%20where%20table_schema=database()%20limit%200,1),0x7e),1))%23](http://localhost/?s=index/index/data&id=3&key=id=3%2520and%2520\(updatexml\(1,concat\(0x7e,\(select%2520table_name%2520from%2520information_schema.tables%2520where%2520table_schema=database\(\)%2520limit%25200,1\),0x7e\),1\)\)%2523)
这样依次改变limit中的值就好了
再来看看联合查询注入：
[http://localhost/?s=index/index/data&id=3&key=id=-3%20union%20select%201,group_concat(table_name),3,4,5,6,7,8,9,10,11%20from%20information_schema.tables%20where%20table_schema=database()%23](http://localhost/?s=index/index/data&id=3&key=id=-3%2520union%2520select%25201,group_concat\(table_name\),3,4,5,6,7,8,9,10,11%2520from%2520information_schema.tables%2520where%2520table_schema=database\(\)%2523)
好了，本篇文章就到此了，SQL注入是个奇妙的东西，出现的类型也不止上述中的注入，还有二次注入
关注本团队公众号，获取最新文章