08:41 0:00 /usr/sbin/httpd
This output shows, among other things, the amount of CPU and memory consump-
tion for all processes named “httpd.” By monitoring this output between fuzzed
inputs, those inputs that elicit large memory changes or CPU consumption can be
detected. Again, in this example, it probably would make more sense to not allow
the httpd server to fork.
6.2.3
Remote Monitoring
One problem with using system monitoring is that it can be hard to tie the informa-
tion from the monitor back to the fuzzer, which is typically running on a different
system, to help determine which test case caused a fault. However, in some cases,
it may be possible to access this system information remotely.
For example, with the use of SNMP, some information about the environment
in which the target program is running can be obtained remotely. The following
command can be issued against the target system between each test case,
charlie-millers-computer:~ cmiller$ snmpget -v 1 -c public
192.168.1.101 .1.3.6.1.4.1.2021.11.3.0 .1.3.6.1.4.1.2021.11.11.0
.1.3.6.1.4.1.2021.4.6.0
UCD-SNMP-MIB::ssSwapIn.0 = INTEGER: 0 kB
6.2
Methods of Monitoring
175
Figure 6.4
The properties window from Process Explorer reveals detailed statistics about the
process in question.
UCD-SNMP-MIB::ssCpuIdle.0 = INTEGER: 81
UCD-SNMP-MIB::memAvailReal.0 = INTEGER: 967468 kB
The results of this command show that there is no memory swapping occurring,
that the CPU is currently 81% idle, and that there is currently 967MB of available
memory. These numbers can indicate when the target program has received inputs
and is having difficulty processing it, which could indicate a denial of service con-
dition. In addition, SNMP allows for process monitoring with the PROC directive
in the snmpd.conf configuration file. The following command checks that there is
a process running with the name given in the configuration file,
charlie-millers-computer:~ cmiller$ snmpget -v 1 -c public
192.168.1.101 1.3.6.1.4.1.2021.2.1.5.1
UCD-SNMP-MIB::prCount.1 = INTEGER: 1
Additionally, SNMP can be configured to restart an application or service if it has
encountered an error. This is done with the PROCFIX directive. In fact, SNMP can
be configured to run arbitrary commands when instructed to do so. Finally, SNMP
can also be used to monitor log files for the occurrences of certain words or phrases
using the LOGMATCH directive.
Another way to monitor logging remotely is via syslogd in Unix environments.
By setting the syslog.conf file to contain only the line
*.*
@hostname
all syslog messages will be forwarded to the machine hostname. In this way the
fuzzer can get an idea of any problems that may be occurring on the remote system.
It may also be possible to remotely monitor system information over the X11 or
VNC protocols or through custom-written programs or scripts.
6.2.4
Commercial Fuzzer Monitoring Solutions
Expanding on the last section regarding remote monitoring of target systems and
applications, many commercial fuzzers offer proprietary monitoring solutions. For
example, the Mu-4000 from Mu Security has many monitoring capabilities. It can
ssh or telnet into the target system and monitor logs, run scripts, restart the target
application, and perform other functions. Using this information, the Mu-4000 can
figure out exactly which fuzzed input (or sequence of inputs) caused a particular
fault. Likewise, the beSTORM fuzzer comes with a Windows and Linux executable
that can monitor the target application (Figure 6.5).
This monitor watches for exceptions in the application and reports them back
to the fuzzer. When it finds one, the fuzzer can report which test case caused it (Fig-
ure 6.6).
6.2.5
Application Monitoring
More advanced methods of monitoring include more intrusive forms of monitoring
applications. Typically, this is done by attaching a debugger to the process. We’ve
already done this a bit by using strace in an earlier section, which uses the ptrace
176
Target Monitoring
debugging facilities. Likewise, this is how the beSTORM monitor functions. The
reason it is useful to attach a debugger to the target process is that debuggers get a
first opportunity to handle faults, exceptions, or interrupts generated by the appli-
cation. Now, some of these events are perfectly normal for an application to
encounter. For example, when a memory page is accessed that is currently paged
to disk, a page fault occurs, but this is entirely fine and expected. Likewise, the
program may register exception handling functions and intend for these functions
6.2
Methods of Monitoring
177
Figure 6.5
The proprietary beSTORM monitoring tool in action.
Figure 6.6
The beSTORM monitor reveals that it has detected a vulnerability.
to be activated in situations such as when an innocuous error occurs. Again, this
may be completely typical of the application’s behavior and may not represent a
vulnerability at all.
However, sometimes an exception is not intended. For example, reading, writ-
ing, or executing from unmapped memory will trigger an exception. Executing invalid
code or dividing by zero will also trigger an exception. These types of exceptions are
typical of those found when an application has had its memory corrupted when pro-
cessing unexpected inputs. An attached debugger will get a chance to view these
exceptions and take some kind of action, such as logging the result. This type of appli-
cation monitoring is useful for finding memory corruption vulnerabilities, although
there are still problems in cases when memory corruption occurs but no exception is
thrown. These will be addressed by the more advanced methods in the next section.
So what are some of the best ways to use the debugging mechanisms of the oper-
ating system for fuzz testing? The most trivial is to simply attach a debugger to the
process, such as OllyDbg or WinDbg. In this case, when an exception is thrown, the
debugger will receive it and the process will be frozen. Then, the methods used to
check for service availability can be used to detect that the process is no longer
responding to requests. Be warned that OllyDbg consumes a great deal of CPU, so
detecting a memory consumption DOS may be more difficult when using a debugger.
Also, don’t forget to only register for the “important” exceptions.
There are better ways to do this. One example is crash.exe, which is part of the
FileFuzz utility developed by Michael Sutton. This process starts an application and
monitors it for exceptions. If it detects one, it prints out the program’s context at the
time of the exception. When wrapped by another program (for example FileFuzz),
this is a great method of detecting when errors have occurred.
C:\Program Files\FileFuzz>crash.exe "C:\Program
Files\QuickTime\QuickTimePlayer.exe" 5000 C:\bad.m4v
[*] crash.exe "C:\Program Files\QuickTime\QuickTimePlayer.exe" 5000
C:\bad.m4v
[*] Access Violation
[*] Exception caught at 6828e4fe mov edx,[edx+0x4]
[*] EAX:00005af4 EBX:00000000 ECX:00000004 EDX:00142ffc
[*] ESI:00142ffc EDI:00116704 ESP:001160fc EBP:00000000
A more customized approach is to use something like PyDbg, a pure Python
Win32 debugger developed by Pedram Amini. A PyDbg script, which attaches to a
process and logs when exceptions occur, can be written in a few lines of Python
such as
import sys
from pydbg import *
from pydbg.defines import *
def handler_crash (pydbg):
print pydbg.dump_context()
return DBG_EXCEPTION_NOT_HANDLED
178
Target Monitoring
dbg = pydbg()
for (pid, name) in dbg.enumerate_processes():
if name == sys.argv[1]:
break
dbg.attach(pid)
dbg.set_callback(EXCEPTION_ACCESS_VIOLATION, handler_breakpoint)
dbg.debug_event_loop()
This script first defines what action to take when an access violation occurs. The
script then instantiates a pydbg instance. Next, it obtains the pid from the name of
the process as passed to the script as the first argument. Finally, it attaches to the
process, registers a callback that should be called when an access violation occurs,
and then continues the process. In practice, more exceptions should be handled and
more could be done when one occurs, but in just a few lines we have a basic fuzz
monitor. For more information on using PyDbg to monitor a target application,
please consult the fuzzing book by Sutton, Greene, and Amini.2
One final note on this type of monitoring solution regards fuzz testing on the
Mac OS X platform. This operating system has a feature called CrashReporter.
This is a system process that monitors all applications for crashes. When an appli-
cation crashes, it presents a dialogue similar to the one shown in Figure 6.7
and logs to the file /var/log/system.log
Dec 10 12:13:25 charlie-millers-computer ReportCrash[285]: Formulating
crash report for process iTunes[283]
Dec 10 12:13:26 charlie-millers-computer com.apple.launchd[70] ([0x0-
0x2b02b].com.apple.iTunes[283]): Exited abnormally: Bus error
Dec 10 12:13:27 charlie-millers-computer ReportCrash[285]: Saved
6.2
Methods of Monitoring
179
Figure 6.7
CrashReporter reveals that the iTunes application has crashed.
2M. Sutton, A. Greene, P. Amini. (2007). Fuzzing: Brute Force Vulnerability Discovery. Boston:
Addison Wesley.
crashreport to /Users/cmiller/Library/Logs/CrashReporter/iTunes_2007-
12-10-121320_charlie-millers-computer.crash using uid: 501 gid: 501,
euid: 501 egid: 501
It also records a crash report into a local file, in this case ~/Library/Logs/Crash
Reporter/iTunes_2007-12-10-121320_charlie-millers-computer.crash. This file con-
tains information like a stack backtrace, register contents, and a list of libraries,
which are loaded in memory along with their addresses. Such helpful logging and
monitoring comes by default on Mac OS X and helps explain why it is a common
choice for many security researchers.
6.3
Advanced Methods
So far, we have discussed methods to monitor how a system is behaving from a
remote perspective, as well as how an application interacts with its environment
and efficient ways to monitor an application for exceptions. However, none of
these methods attempts to analyze what is happening within the application. This
section will show ways in which the execution of the application itself can be
changed to help better monitor its internal state. The use of the tools discussed here
will all be demonstrated in great detail in the last two sections of this chapter.
6.3.1
Library Interception
For applications that are dynamically linked, the easiest way to change the behav-
ior of the program is to change the code in the libraries that are linked to the appli-
cation. This can be done by creating a new library that exports the same symbols
as libraries used by the application. All that needs to be done is to ensure that this
new library’s code is the one that is used by the target.
This is exactly what is done by tools such as Electric Fence for Linux and Guard
Malloc for BSD/Mac OS X. We will discuss Guard Malloc in detail, although both
of these tools work in a very similar fashion. Guard Malloc supplies its own version
of the functions malloc() and free(), as well as some other related functions.
The malloc() function in the Guard Malloc library is different than a standard
malloc() implementation. It is designed in such a way to find buffer overflows and
other memory corruptions and terminate the program as soon as one is discovered.
It does this by utilizing the virtual memory system of the operating system. Every
time a buffer is allocated in the target program using malloc(), the Guard Malloc
implementation is called. This version of malloc() places each allocation on its own
virtual memory page and places the end of the buffer at the end of this page. The
next virtual memory page is purposefully left unallocated. The result is that if a
buffer is overflown, the read or write to the bytes beyond the buffer will take place
on an unallocated virtual memory page, which will result in a bus error—a signal
easily caught by a debugger. This is true for wild memory reads or writes that occur
after or, to a lesser extent, before allocated buffers. When the program wants to
free its allocated memory, the page that held the buffer is deallocated. Therefore,
any reference to the freed buffer will again result in a bus error. This will find vul-
nerabilities that read from freed memory as well as double free bugs.
180
Target Monitoring
The Guard Malloc library is used in place of the memory manipulation func-
tions from the system library by using the DYLD_INSERT_LIBRARIES environ-
ment variable as such:
DYLD_INSERT_LIBRARIES=/usr/lib/libgmalloc.dylib ./testprogram
The way that Guard Malloc works is also governed by environment variables.
Some of the more interesting ones involving fuzz testing include:
• MALLOC_FILL_SPACE: This environment variable tells Guard Malloc to
fill new memory allocations with the byte 0x55. This can help find references
to uninitialized memory.
• MALLOC_ALLOW_READS: This variable causes the page following the
allocated buffer to be readable but not writable. Thus, wild reads will not
cause an error, but wild writes still cause a bus error. This is useful when
security researchers are looking for exploitable vulnerabilities but don’t care
about information leaks.
• MALLOC_STRICT_SIZE: Normally, Guard Malloc will align memory allo-
cations on 16 byte boundaries. In this scenario it is possible for small buffer
overflows to be missed for allocations whose size is not a multiple of 16. This
environment variable forces the end of the allocation to be adjacent to the
last byte of the page, which will catch even a single byte overflow. Please note
that this will cause memory allocations to possibly be unaligned. This may
cause programs that assume allocations are at least word aligned to fail.
Guard Malloc is a great tool to use when fuzzing because it will force most
heap memory corruptions to result in a program crash. (Of course, this will not
help find stack overflows since stack buffers are not created via malloc(). How-
ever, stack overflows often cause a crash by default.) Using Guard Malloc avoids
problems in which memory is read or corrupted by an input but not enough to
cause a full program crash.
There are significant drawbacks to the use of this tool, however. First, each
memory allocation made by the program requires two full pages of virtual memory.
Large programs that make a lot of memory allocations may run out of virtual mem-
ory when using this tool. Second, in addition to the fact that this allocation routine
is less efficient than the standard one, it can cause excessive swapping, which can
slow down the target program’s execution time by a factor of 100 or more. There-
fore, fewer inputs can be sent to the target in the same amount of time. This illus-
trates the tradeoff between monitoring and testing time.
It should be noted that open BSD has many of the features of Guard Malloc
built into the operating system. That is, when fuzzing on open BSD, you get Guard
Malloc for free.
6.3.2
Binary Simulation
Using library interception provides a quick and easy way to get a handle on the
memory allocation occurring in the target application. However, there is more we
would like to monitor. Doing this requires even further intrusion into the target.
6.3
Advanced Methods
181
One such approach is to use a synthetic CPU. This is the technique used when a
target program is run under Valgrind for Linux. Valgrind is a framework in which
a binary is run on a synthetic processor and various instructions and commands
can be run on the code as it is processed on this synthetic processor. One such set
of auxiliary instructions is called Memcheck and monitors every memory alloca-
tion/deallocation as well as every memory access. This is exactly the type of infor-
mation we care about when fuzzing.
Valgrind works by loading its initialization routines when the target binary begins
using the dynamic loader (the same mechanism used by Guard Malloc). At that point,
Valgrind takes over execution of the application until it exits. None of the actual
instructions from the application are run on the real processor; they are all run on the
synthetic CPU. Each basic block is read by Valgrind, instrumented by the associated
tool, and then executed on the synthetic CPU. The tool can add whatever code it likes
to the instructions from the binary. As we mentioned, there is a tool that comes with
Valgrind that adds code that checks for memory accesses. It could also check for
memory consumption, file handles, or whatever else we wanted. Of course, running
an application on a synthetic CPU has some performance issues. Typically, the pro-
gram code will be increased by a factor 12 and there will be a slowdown of 25 to 50
times. Again, because the binary is being run, the source code isn’t needed and no
changes have to be made to the development process.
Now let’s take a closer look at exactly how the Memcheck tool works. Since
Memcheck has the opportunity to run code between each instruction of the target
binary, it can monitor and take action with every memory usage. Memcheck adds
two bits of information to every bit in the computer’s virtual memory and to the vir-
tual hardware registers. One bit is called the valid-value (V) bit and the other is the
valid-address (A) bit. The V-bit basically indicates whether that bit has been initial-
ized by the program. This V-bit follows the corresponding bit of memory wherever
it goes. For example, suppose you had the following source code
int x,y;
x = 4;
y = x;
Initially, the 32 V-bits associated with both x and y would be set to 0, as they
are uninitialized. When the synthetic processor executed the instruction responsible
for making the assignment in the second line, it would set the 32 corresponding V-
bit’s for the variable x to 1, as x is now initialized. The third line would set the V-
bits associated with the variable y. By tracking this, the use of uninitialized variables
can be detected. 
Likewise, the A-bit tracks whether the program has the right to access a given
bit of data. It sets the A-bit when memory is allocated or deallocated and also for
global and stack variables. At each memory access, Memcheck validates that the
corresponding A-bit is set. Between these two pieces of information, many different
types of vulnerabilities can be detected including use of uninitialized variables, read-
ing/writing memory after free, heap overflows and wild pointer read/writes, mem-
ory leaks, and double frees.
182
Target Monitoring
Due to this level of preciseness, this method has some advantages over Guard
Malloc. For example, Guard Malloc only detects writing past the end of a buffer
(and even then can miss one byte overflows depending on the allocation). It will
miss most buffer underflows. Guard Malloc also does not usually find errors with
uninitialized variables and can miss wild pointer writes (illegal array indexes).
Finally, due to the way Guard Malloc causes a bus error when it detects some-
thing, Guard Malloc can only find a single bug at a time, while Valgrind can find
many bugs.
6.3.3
Source Code Transformation
Guard Malloc and Valgrind work on binaries by using tricks with the dynamic
linker. They make changes to the way the program executes by intercepting calls to
library functions. Both work on binaries and neither requires source code. When
source code is available, even more complex changes to the way the target executes
can be made. An open source tool that rewrites C source code to add security
checks (among other things) is called CCured. We’ll look at an easier to use and
more robust commercial solution from Parasoft called Insure++. Insure++ works in
Windows or Linux by replacing the compiler by a custom tool written by Parasoft.
This tool preprocesses the existing source code and adds additional code to it that
makes note of each memory allocation/deallocation and each memory read or
write. In this way, it can find any memory corruption at run-time. This transformed
source code is then compiled with the standard system compiler. This tool is
designed to be easily integrated into the development process. When the modified
binary is executed, a GUI appears that outlines any problems found and directs the
tester to the line of source code that caused the problem.
All these changes to the source code are important but do not change the actual
functioning of the application. By making these changes to the execution of the tar-
get application, many types of vulnerabilities can be quickly identified. Insure++
also has the advantage that it can continue to execute after some bugs have been
identified, whereas tools like Guard Malloc immediately halt the program. The exe-
cution slowdown is also greatly reduced since the code is running at native speed,
but can still be significant. The main disadvantage is it is a commercial tool and can
be quite expensive.
6.3.4
Virtualization