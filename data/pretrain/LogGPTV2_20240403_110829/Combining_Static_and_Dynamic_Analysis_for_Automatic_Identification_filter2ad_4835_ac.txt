634 sec
Table 1. Static-Analysis Statistics
This section does not detail the time required to perform
the dynamic analysis part since that is an interactive pro-
298298
Name
Static
Authorization Requirements
Dynamic Reﬁnement
Aamfetch
Crypto
Ganymed
Gnu
JavaSign
JPassword
False
5
7
6
15
4
3
49
24
45
51
19
27
Imprecise
40
2
38
17
10
19
Actual
Precise Minimized
6
12
3
11
6
6
4
15
1
19
5
5
Privilege-Assertion Requirements
Static
Dynamic Reﬁnement
False
Actual
Imprecise
5
40
16
78
25
55
Precise
3
24
12
66
7
21
Total
8
64
28
144
32
76
20
14
9
43
0
37
28
78
37
187
32
113
Table 2. ACE Authorization and Privileged-Code Requirement Findings
cess, and its duration strictly depends on the experience of
the analyst in using ACE. In our experience, it takes in aver-
age 1 minute to evaluate each statically-detected authoriza-
tion requirement.
Table 2 focuses on the security results. Speciﬁcally, for
each application, it shows the following:
1. The number s of authorization requirements detected
using only static analysis.
2. The number f of false alarms among those authoriza-
tion requirements. f is detected by reﬁning the static
analysis results using the dynamic analyzer of ACE.
3. The number a of the actual requirements found—
meaning that these requirements are real. This cate-
gory includes the following:
(a) The number i of the actual, but imprecise, au-
thorization requirements (for example, an actual
FilePermission requirement for which the
static analysis was not able to disambiguate the
ﬁle name due to its inability to perform String
computations, as observed in Section 1).
(b) The number p of the actual and precise authoriza-
tion requirements.
(c) The number m of the actual permission require-
ments after policy minimization, as discussed in
Section 4.5.
Notice that s = f +i+p since an authorization require-
ment found by the static analysis can only be false or
actual, and if it is actual it can only be imprecise or pre-
cise. Also, in general, m ≤ s. Table 2 shows the use-
fulness of this automatic combined approach since it
allows detecting authorization requirements (though in
a conservative manner) and then using the dynamic an-
alyzer to signiﬁcantly reduce the requirements found.
Next, Table 2 shows the results obtained by using ACE
to detect the privilege-assertion requirements, as follows:
1. The number s of privilege-assertion requirements de-
tected using only static analysis.
2. The number f of false alarms among those privilege-
assertion requirements.
3. The number a of the actual requirements found. This
category includes:
299299
(a) The number i of the actual privilege-assertion
requirements that are, however, imprecise since
the Permission objects associated with the
privilege-assertion requirement could not be
uniquely disambiguated.
(b) The number p of the actual and precise privilege-
assertion requirements.
(c) The total number t of the actual privilege-
assertion requirements.
In this case, s = f + i + p and also t = i + p since,
unlike authorization requirements, privilege-assertion
requirements cannot be minimized.
As shown, the combined static and dynamic analysis ap-
proach dramatically improves a process that, if done manu-
ally, would become impractical. With the exhaustive model
for native methods included in the static analyzer of ACE,
no false negative was observed.
6 Conclusion and Future Work
This paper described a combination of static and dy-
namic analysis for precise identiﬁcation of access-control
policies. The algorithms presented in this paper have
been implemented as part of a tool called Access-Control
Explorer (ACE), which has been used on a number of
production-level applications.
Future areas of investigation will involve improving the
precision of the static analyzer of ACE to reduce the num-
ber of false alarms it generates and simplify the dynamic
analysis. Currently, the static analyzer of ACE employs a
very expensive context-sensitivity policy, which adds preci-
sion indiscriminately, even where it is not needed, thereby
reducing scalability. It would be desirable to automatically
increase the precision of the static analyzer when model-
ing security-sensitive calls, while reducing the precision of
the analyzer where security is not needed. In particular, the
context-sensitivity policy used by ACE disambiguates dif-
ferent calls to the same method based on the receiver and
parameters. If a method is static and takes no parameters,
then all the calls to it will be represented by only one node in
the call graph, which creates a pollution point when model-
ing stack inspection through that node. A research direction
will involve a more precise and selective context-sensitivity
policy that eliminates this problem. Furthermore, integrat-
ing static authorization analysis with an analysis for string
computations will help in eliminating many false alarms.
7 Related Work
The need for integration of static and dynamic analysis
has been known for a long time. Orso, et al. [23] have com-
bined static and dynamic analysis for networking model-
ing, discovery, and analysis. Our work distinguishes itself
from that work because it precisely addresses the need for a
precise authorization and privilege-assertion analysis. Ernst
[12] discusses synergies and similarities of static and dy-
namic analysis, and how these two approaches can be inte-
grated to achieve optimal results in a wide range of prob-
lems.
Felten, et al. study a number of security problems related
to mobile code [34, 8, 36, 5, 35, 7, 6] and present a formal-
ization of stack introspection that examines authorization
based on the principals currently active in a thread stack
at run time (security state). An authorization optimization
technique, called Security-Passing Style (SPS), encodes the
security state of an application while the application is ex-
ecuting [36]. Each method is modiﬁed to pass a security
token as part of each invocation. The token represents an
encoding of the security state at each stack frame, as well
as the result of any authorization test encountered. With
this mechanism, the SPS explores subgraphs of the compa-
rable invocation graph and discovers the associated security
states and authorizations. Their goal is to optimize the au-
thorization performance, while one of the purposes of this
paper is to discover authorization requirements by analyz-
ing all possible paths through the program, even those that
may not be discovered by a limited number of test cases.
Pottier, et al. [29] extend and formalize the SPS via type
theory using a λ-calculus, called λsec. However, their work
does not address incomplete-program analysis [30]. Jensen,
et al. [18] focus on proving that code is secure with respect
to a global security policy. Their model uses operational
semantics to prove the properties, using a two-level tempo-
ral logic, and shows how to detect redundant authorization
tests. They assume all of the code is available for analysis,
and that a call graph can be constructed for the code, though
they do not do so themselves. Bartoletti, et al. [3] are inter-
ested in optimizing performance of run-time authorization
testing by eliminating redundant tests and relocating others
as is needed. The reported results apply operational seman-
tics to model the run-time stack.
Rather than analyzing security policies as embodied by
existing code, Erlingsson and Schneider [11] describe a sys-
tem that inlines reference monitors into the code to enforce
300300
speciﬁc security policies. The objective is to deﬁne a secu-
rity policy and then inject authorization points into the code.
This approach can reduce or eliminate redundant authoriza-
tion tests. Conversely, this paper examines the authorization
issue from the perspective of an existing system containing
authorization test points. Through static analysis, the math-
ematical framework of this paper can be used to discover
how the security policy needs to be modiﬁed or updated to
enable the code to execute.
Hajime and Forrest [17] present a dynamic permission
analysis. Their solution is not interactive, does not deal with
security side effects, is not integrated with a static-analysis
solution, and does not deal with privilege-asserting code,
and does not prevent a malicious program from harming the
underlying system; all the permissions requested by a pro-
gram are automatically granted, with the risk of compro-
mising the underlying system.
Privileged code has historic roots in the 1970’s. The
Digitial Equipment Corporation (DEC) Virtual Address
eXtension/Virtual Memory System (VAX/VMS) operating
system had a feature similar to privilege assertion, called
privileged images. Those images were similar to UNIX
setuid programs [4], except that they ran in the same
process as all the user’s other unprivileged programs. As
such, they were considerably easier to attack than UNIX
setuid programs because they lacked the usual separate
process/separate address space protections, as shown by
Koegel, et al. [19]. Koved, et al. [20] and Pistoia, et al. [26]
automate static security analysis for Java authorization and
privilege assertion. Zhang, et al. [37] enhance those works
with an automated native-code model generator to reduce
the number of false negatives. This paper extends those
works with a more precise static analysis and a novel dy-
namic analysis for elimination of false alarms.
8 Acknowledgments
The authors would like to thank the reviewers of
the Twenty-Third Annual Computer Security Applications
Conference (ACSAC 2007) for their precious suggestions.
References
[1] A. V. Aho, R. Sethi, and J. D. Ullman. Compilers: Prin-
ciples, Techniques, and Tools. Addison-Wesley, Reading,
MA, USA, Jan. 1986.
[2] L. O. Andersen. Program Analysis and Specialization for
the C Programming Language. PhD thesis, University of
Copenhagen, May 1994.
[3] M. Bartoletti, P. Degano, and G. L. Ferrari. Static Analysis
for Stack Inspection. In Proceedings of International Work-
shop on Concurrency and Coordination, Electronic Notes in
Theoretical Computer Science, volume 54, Amsterdam, The
Netherlands, 2001. Elsevier.
[4] H. Chen, D. Wagner, and D. Dean. Setuid Demystiﬁed. In
Proceedings of the 11th USENIX Security Symposium, pages
171–190, Berkeley, CA, USA, August 2002. USENIX As-
sociation.
[5] D. Dean. The Security of Static Typing with Dynamic Link-
In Proceedings of the 4th ACM conference on Com-
ing.
puter and Communications Security, pages 18–27, Zurich,
Switzerland, 1997. ACM Press.
[6] D. Dean, E. W. Felten, and D. S. Wallach. Java Security:
From HotJava to Netscape and beyond. In Proceedings of
the 1996 IEEE Symposium on Security and Privacy, pages
190–200, Silver Spring, MD, USA, 1996. IEEE Computer
Society Press.
[7] D. Dean, E. W. Felten, D. S. Wallach, and D. Balfanz. Java
Security: Web Browsers and Beyond. Technical Report 566-
597, Princeton University, Princeton, NJ, USA, February
1997.
[8] R. D. Dean. Formal Aspects of Mobile Code Security. PhD
thesis, Princeton University, Princeton, NJ, USA, Jan. 1999.
[9] Eclipse Project, http://www.eclipse.org.
[10] Equinox
http://www.eclipse.org/
Project,
equinox.
[11] U. Erlingsson and F. B. Schneider. IRM Enforcement of Java
Stack Inspection. In Proceedings of the 2000 IEEE Sympo-
sium on Security and Privacy, pages 246–255, Oakland, CA,
USA, May 2000. IEEE Computer Society.
[12] M. D. Ernst. Static and Dynamic Analysis: Synergy and Du-
ality. In Proceedings of the Program Analysis for Software
Tools and Engineering (PASTE 2004) Workshop, pages 24–
27, June 2004.
[13] A. Freeman and A. Jones. Programming .NET Security.
O’Reilly & Associates, Inc., Sebastopol, CA, USA, June
2003.
[14] L. Gong, G. Ellison, and M. Dageforde. Inside Java 2 Plat-
form Security: Architecture, API Design, and Implementa-
tion. Addison-Wesley, Reading, MA, USA, second edition,
May 2003.
[15] G. Gr¨atzer. General Lattice Theory. Birkh¨auser, Boston,
MA, USA, second edition, January 2003.
[16] D. Grove and C. Chambers. A Framework for Call Graph
Construction Algorithms. ACM Trans. Program. Lang. Syst.,
23(6):685–746, November 2001.
[17] H. Inoue and S. Forrest.
Inferring Java Security Policies
Through Dynamic Sandboxing. In International Conference
on Programming Languages and Compilers, Las Vegas, NE,
USA, June 2005.
[18] T. P. Jensen, D. L. M´etayer, and T. Thorn. Veriﬁcation of
Control Flow Based Security Properties. In Proceedings of
the 1999 IEEE Symposium on Security and Privacy, pages
89–103, Oakland, CA, USA, May 1999.
[19] J. F. Koegel, R. M. Koegel, Z. Li, and D. T. Miruke. A Secu-
rity Analysis of VAX VMS. In ACM ’85: Proceedings of the
1985 ACM Annual Conference on the Range of Computing:
Mid-80’s Perspective, pages 381–386. ACM Press, 1985.
[20] L. Koved, M. Pistoia, and A. Kershenbaum. Access Rights
Analysis for Java.
In Proceedings of the 17th ACM SIG-
PLAN Conference on Object-Oriented Programming, Sys-
tems, Languages, and Applications, pages 359–372, Seattle,
WA, USA, November 2002. ACM Press.
301301
[21] B. Livshits, J. Whaley, and M. S. Lam. Reﬂection Analysis
for Java.
In Proceedings of the 3rd Asian Symposium on
Programming Languages and Systems, pages 139–160, Nov.
2005.
[22] S. S. Muchnick. Advanced Compiler Design and Implemen-
tation. Morgan Kaufmann Publishers Inc., San Francisco,
CA, USA, June 1997.
[23] A. Orso, M. J. Harrold, and G. Vigna. MASSA: Mobile
Agents Security through Static/Dynamic Analysis. In Pro-
ceedings of the First ICSE Workshop on Software Engineer-
ing and Mobility (WSEM 2001), Toronto, Canada, April
2001.
[24] OSGi Speciﬁcation, http://www.osgi.org.
[25] M. Pistoia, A. Banerjee, and D. A. Naumann. Beyond Stack
Inspection: A Uniﬁed Access Control and Information Flow
Security Model. In 28th IEEE Symposium on Security and
Privacy, pages 149–163, Oakland, CA, USA, May 2007.
[26] M. Pistoia, R. J. Flynn, L. Koved, and V. C. Sreedhar. In-
terprocedural Analysis for Privileged Code Placement and
Tainted Variable Detection. In Proceedings of the 19th Euro-
pean Conference on Object-Oriented Programming, pages
362–386, Glasgow, Scotland, UK, July 2005. Springer-
Verlag.
[27] M. Pistoia, N. Nagaratnam, L. Koved, and A. Nadalin. En-
terprise Java Security. Addison-Wesley, Reading, MA,
USA, February 2004.
[28] M. Pistoia, D. Reller, D. Gupta, M. Nagnur, and A. K. Ra-
mani. Java 2 Network Security. Prentice Hall PTR, Upper
Saddle River, NJ, USA, second edition, August 1999.
[29] F. Pottier, C. Skalka, and S. F. Smith. A Systematic Ap-
proach to Static Access Control. In Proceedings of the 10th
European Symposium on Programming Languages and Sys-
tems, pages 30–45. Springer-Verlag, 2001.
[30] B. G. Ryder. Dimensions of Precision in Reference Analysis
of Object-Oriented Languages. In Proceedings of the 12th
International Conference on Compiler Construction, pages
126–137, Warsaw, Poland, April 2003. Invited Paper.
[31] J. H. Saltzer and M. D. Schroeder. The Protection of Infor-
mation in Computer Systems. In Proceedings of the IEEE,
volume 63, pages 1278–1308, Sept. 1975.
[32] SourceForge.net, http://www.sourceforge.net.
[33] Sun Microsystems, JavaTM Technology, http://java.
sun.com.
[34] D. S. Wallach. A New Approach to Mobile-Code Security.
PhD thesis, Princeton University, Princeton, NJ, USA, Jan.
1999.
[35] D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten. Ex-
tensible Security Architectures for Java. In Proceedings of
the 16th ACM Symposium on Operating Systems Principles,
pages 116–128, Saint Malo, France, 1997. ACM Press.
[36] D. S. Wallach and E. W. Felten. Understanding Java Stack
Inspection.
In Proceedings of the 1998 IEEE Symposium
on Security and Privacy, pages 52–63, Oakland, CA, USA,
May 1998.
[37] X. Zhang, L. Koved, M. Pistoia, S. Weber, T. Jaeger,
G. Marceau, and L. Zeng. The Case for Analysis Preserv-
ing Language Transformation. In Proceedings of the ACM
SIGSOFT 2006 International Symposium on Software Test-
ing and Analysis (ISSTA). ACM Press, July 2006.