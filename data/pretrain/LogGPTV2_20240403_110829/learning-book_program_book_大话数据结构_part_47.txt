inti;
inta[10]-(62,88,58,47,35,73,51,99,37,93}
BiTree T=NULL;
for（i=0:idata）/·找到关键字等于key的数据元素/
8
return Delete（T）;
9
elseif（keydata）
10
return DeleteBST（s（*T）->lchild,key）;
11
else
12
return DeleteBsr（s（*T）->rchild,key）;
13
14
15
323
---
## Page 348
大调数据结构
这段代码和前面的二叉排序树查找几乎完全相同，唯一的区别就在于第8行，此
时执行的是Delete方法，对当前结点进行删除操作。我们来看Delete的代码。
1从二叉换序树中则除结点D，并童接它的左或右子树。/
1
BiTree q,s:
4
.（Plchi1d--NULL）/只营重接它的右子树·/
9
10
（b）oxptuoxrchild）
1转左，然后向右到尽头（我待则结点的前驱）*/
16
17
q-s;s=s->rchild;
18
19
prchild=s->lchild;/童接q的右子树*/
22
else
23
q->lchild=s->1child;/重接q的左子树·/
24
free（s）;
25
）
26
return TRUE;
27
1.程序开始执行，代码第4~7行目的是为了删除没有右子树只有左子树的结
点。此时只需将此结点的左孩子替换它自己，然后释放此结点内存，就等于删
除了。
2.代码第8~11行是同样的道理处理只有右子树没有左子树的结点删除问题。
3.第12~25行处理复杂的左右子树均存在的问题。
324
---
## Page 349
第8章查找
4.第14行，将要删除的结点p赋值给临时的变量q，再将p的左孩子p->khid
赋值给临时的变量s。此时q指向47结点，s指向35结点，如图8-6-13所
示。
62
58
73
1
93
图8-6-13
5.第15~18行，循环找到左子树的右结点，直到右侧尽头。就当前例子来说
就是让q指向35，而s指向了37这个再没有右子树的结点，如图8-6-14
所示。
62
58
73
93
37
56
36
图8-6-14
6.第19行，此时让要删除的结点p的位置的数据被赋值为s->data，即让
p->data=37，如图8-6-15所示。
325
---
## Page 350
大调数据结构
58
37
73
图8-6-15
7.第20~23行，如果p和q指向不同，则将s->khild赋值给q->rchild，否则就
是将s->khild赋值给q->khild。显然这个例子p不等于q，将s->khild指向的
36赋值给q->rchild，也就是让q->rchild指向36结点，如图8-6-16所示。
62
58
37
73
51
93
56
图8-6-16
8.第24行，free（s），就非常好理解了，将37结点删除，如图8-6-17所示。
326
---
## Page 351
第8章查找
52
50
图 8-6-17
从这段代码也可以看出，我们其实是在找删除结点的前驱结点替换的方法，对于
用后继结点来替换，方法上是一样的。
8.6.4二叉排序树总结
总之，二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除
操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针
即可，插入删除的时间性能比较好。面对于二叉排序树的查找，走的就是从根结点到
要查找的结点的路径，其比较次数等于给定值的结点在二义排序树的层数。极端情
况，最少为1次，即根结点就是要找的结点，最多也不会超过树的深度。也就是说，
二叉排序树的查找性能取决于二叉排序树的形状。可间题就在于，二叉排序树的形状
是不确定的。
例如{62,88,58,47,35,73,51,99,37,93}这样的数组，我们可以构建如图8-6-18左图
的二叉排序树。但如果数组元素的次序是从小到大有序，如{35,37，47,51,58.62.73.88，
93,99，则二叉排序树就成了极端的右斜树，注意它依然是一棵二叉排序树，如图
8-6-18的右图。此时，同样是查找结点99，左图只需要两次比较，而右图就需要10
次比较才可以得到结果，二者差异很大。
327
---
## Page 352
大话数据结构
(37