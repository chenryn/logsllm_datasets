结果样例:  
```  
select * from t_vec_80 limit 3;  
-[ RECORD 1 ]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
id  | 1  
c1  | 99  
c2  | 7428  
c3  | 9b74e40ab38ed4f41b5d50b8eedf8b72  
c4  | 2020-02-27 15:36:56.895773  
vec | {6469,3787,5852,1642,2798,7728,1527,6990,7399,3460,7802,7682,8102,6499,3428,7687,567,8894,8144,1685,6139,9549,3613,1714,721,9099,4218,1930,9031,4961,3966,5501,8748,9818,7143,1546,7547,8671,8536,4946,2132,6338,2629,234,2838,6057,7922,3405,4951,6066,5091,1091,5615,8704,2805,6336,7804,7024,8266,6836,1985,2233,2337,733,2051,9481,2280,9598,8152,816,4545,285,7155,7174,519,9993,3232,8441,3399,8183}  
-[ RECORD 2 ]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
id  | 2  
c1  | 45  
c2  | 84908  
c3  | a48d421b772486121ef520eb3e285f95  
c4  | 2020-02-27 15:36:56.896329  
vec | {123,7195,2080,6460,5000,9104,4727,1836,1089,6960,4174,1823,9012,3656,4103,8611,1808,4920,3157,2094,2076,332,2613,2070,3564,1055,5469,1748,5563,3960,1023,5686,1156,3103,2147,6156,2208,6874,7993,3298,3834,2167,5121,2847,5823,9225,1458,7632,4145,4615,9726,6222,4947,2340,8292,8511,3395,3762,259,8958,7722,1282,4644,8878,4386,6792,5035,6594,3666,3028,9892,7501,5196,5014,348,1019,4239,1806,8652,8384}  
-[ RECORD 3 ]------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------  
id  | 3  
c1  | 64  
c2  | 83785  
c3  | ea856c452399648fd29b0e0383a169a5  
c4  | 2020-02-27 15:36:56.896395  
vec | {1369,718,2899,9880,4113,6661,140,3071,4383,1422,7716,3262,5808,4509,8298,2403,8175,1326,2295,5676,6523,7309,6024,7542,1549,7831,6194,9934,4253,4573,4541,5622,5291,7440,5503,9405,4101,5643,2477,8485,7066,194,1748,2875,4703,46,5278,2878,1373,7574,8555,7896,4884,4580,5439,6433,2411,1633,6367,6664,6207,909,2286,1498,8349,7789,903,2451,3433,3381,936,499,3575,2685,3374,8278,2731,8653,1157,4105}  
```  
表占用空间:  
```  
 public | t_vec_80              | table | digoal | 411 MB     |   
```  
4、查询出100万条记录返回给客户端  
```  
time psql -h xxx.xxx.xxx.xxx -p 3433 -U digoal postgres -c "select * from t_vec_80" >/dev/null  
```  
结果:  
```  
real    1m1.450s  
user    0m21.891s  
sys     0m2.399s  
```  
5、并发能力测试  
```  
vi test.sql  
select * from t_vec_80;  
pgbench -M prepared -n -r -f ./test.sql -c 4 -j 4 -T 600 -h xxx.xxx.xxx.xxx -p 3433 -U digoal postgres  
```  
结果:  
```  
transaction type: ./test.sql  
scaling factor: 1  
query mode: prepared  
number of clients: 4  
number of threads: 4  
duration: 600 s  
number of transactions actually processed: 36  
latency average = 72293.794 ms  
tps = 0.055330 (including connections establishing)  
tps = 0.055330 (excluding connections establishing)  
statement latencies in milliseconds:  
     72204.857  select * from t_vec_80;  
```  
#### 方案2 demo  
1、创建 pase 向量索引插件  
```  
create extension pase;   
```  
2、创建测试表  
```  
create table if not exists t_vec_80(    
    id serial PRIMARY KEY,  -- 主键  
    c1 int,   -- 其他属性字段  
    c2 int,  
    c3 text,  
    c4 timestamp,  
    vec float4[]    -- 图像特征值向量  
);    
```  
3、创建生成随机向量的函数(用于模拟图像特征值, 实际场景请使用实际图片特征值存入)  
```  
-- 创建生成随机向量的函数  
create or replace function gen_float4_arr1(int,int) returns float4[] as $$    
  select array_agg(trunc(random()*$1)::float4) from generate_series(1,$2);    
$$ language sql strict volatile;    
-- 创建基于数组生成随机附近数组的函数  
create or replace function gen_float4_arr(float4[], int) returns float4[] as $$    
  select array_agg( (u + (u*$2/2.0/100) - u*$2/100*random())::float4 ) from unnest($1) u;  
$$ language sql strict volatile;   
```  
4、写入100万随机向量  
```  
do language plpgsql $$  
declare  
  v_cent float4[];  
begin  
  for i in 1..100 loop  -- 100个中心点  
    v_cent := gen_float4_arr1(10000,80);   -- 取值范围10000, 80个维度  
    insert into t_vec_80 (vec)   
    select   
      gen_float4_arr(v_cent, 20)   
    from generate_series(1,10000);   -- 1万个点围绕一个中心点, 每个维度的值随机加减20%   
  end loop;  
end;  
$$;  
```  
5、创建向量索引(使用hnsw算法索引, 目前pase插件支持两种索引ivfflat和hnsw), 请实际使用时定要参考RDS PG pase文档, 索引参数需要正确的被设置(特别是维度需要和实际维度一致).  
```  
CREATE INDEX idx_t_vec_80_1 ON t_vec_80      
USING      
  pase_hnsw(vec)      
WITH      
  (dim = 80, base_nb_num = 16, ef_build = 40, ef_search = 200, base64_encoded = 0);    
```  
创建索引耗时:  
```  
CREATE INDEX  
Time: 1282997.955 ms (21:22.998)  