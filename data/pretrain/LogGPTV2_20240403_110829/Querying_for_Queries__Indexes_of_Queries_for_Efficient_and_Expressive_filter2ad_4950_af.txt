tations support SpMV multiplication in the binary fields GF(28)
and GF(216) and in Zq for arbitrary multi-precision prime moduli
11
q.9 We use lookup tables and exclusive-ORs for fast binary field
arithmetic; for prime-order field arithmetic, our GPU code uses a
hand-optimized PTX implementation of “schoolbook” multiplica-
tion/addition together with Barrett reduction [1], while our CPU
implementation outsources arithmetic to NTL [26] and GMP [11].
Our implementations are licensed under version 2 of the GNU
9Numerous efficient CUDA-based SpMV multiplication implementations already exist,
yet essentially all implementations we found assume that the entries are floating-point
numbers. Modifying any of these implementations to do integer arithmetic modulo
a 32-bit word-size prime would be relatively straightforward; however, in order to
obtain good PIR performance, we need support for SpMV multiplication over small
binary fields and/or over prime-order fields with multiple-precision prime moduli.
Indeed, benchmarks we ran on Percy++, an open-source implementation of Goldberg’s
PIR protocols, indicate that the PIR over small binary fields is fastest, followed by PIR
over prime order fields with moduli ≥ 128 bits long. For instance, we observe about a
3.5× speedup switching from a 32-bit modulus to a 1024-bit modulus.
General Public License (GPLv2), and we are presently working to
integrate both versions into Percy++ [14], an open-source imple-
mentation of Goldberg’s IT-PIR protocol.
We conducted two sets of experiments. The first set of exper-
iments consists of microbenchmarks designed to measure the la-
tency imposed by routing PIR queries through an index of que-
ries prior to conducting a positional query against the actual data-
base. The second set of experiments evaluates the feasibility of
deploying our techniques over a real-world dataset; specifically, we
constructed several batch indexes of queries through which users
can fetch academic articles posted to the IACR Cryptology ePrint
archive [19].
7.1 SpMV microbenchmarks
For the first set of experiments, we generated a large number of
random u-batch indexes of queries for various choices of u, index
dimensions, and finite fields, and then we measured the number of
SpMV operations we could evaluate per second, either as a mas-
sively parallel computation on our Nvidia K20 GPU Accelerator or
as a single-threaded computation on our Intel Core i5-2500 CPU.
The results of this experiment are unsurprising—our SpMV multi-
plications consistently run extremely fast, even when the indexes
of queries have quite large dimensions.
In line with expectations, we observed that varying the height
of the index (p) and the batching parameter (u) had very little im-
pact on throughput for our GPU implementation,10 whereas the
throughput decreased linearly with pu for our CPU implementa-
tion.
Figure 2 plots the measurements we obtained from one arbitrary-
yet-representative set of parameters; specifically, it shows the re-
sults for a sequence of indexes of 4-batch queries having p = 214
rows and mapping to databases D having between r = 214 and
r = 220 blocks. In all cases, our GPU implementation was able to
process well over a thousand requests per second (indeed, we found
that memory bandwidth to and from the GPU was consistently the
bottleneck); our CPU implementation was able to process between
a few hundred (for r = 220) and a few thousand (for r = 214) re-
quests per second in the binary fields and on the order of a few
dozen requests per second (for all r ) in large prime-order fields. In
all cases, increasing r yielded a roughly linear decrease in through-
put, with a slope inversely proportional to the cost of a single field
operation.
For comparison, we found that it took just over 1.4 second per
GiB of database (using a single thread) to process a single positional
query using fast arithmetic in GF(28), with every other field we
measured taking notably longer. Thus, we conclude that, even in the
worst conceivable cases, indexes of queries introduce no significant
latency to PIR requests (and, when p ≪ r , they may significantly
speed up the subsequent PIR processing by producing positional
queries with small support).
10We ran experiments for various choices of u ∈ [1. . 16] and power-of-two heights
and widths, with dimensions ranging from extremely short-and-fat to perfectly square
(but never tall-and-skinny); hence, our indexes were consistently extremely sparse (at
most about 0.1% of entries were nonzero), causing most GPU threads to sit idle most
of the time, regardless of how we set u and p.
12
7.2 IACR Cryptology ePrint Archive
For the second set of experiments, we created a dataset by scraping
the IACR Cryptology ePrint Archive [19], an open-access reposi-
tory that provides rapid access to recent research in cryptology. In
particular, we scraped metadata (paper id, paper title, author list,
submission date, keywords, and file size) for 10,181 papers (which
was the entire dataset as of midday on February 10, 2017, excluding
60 papers that our scraper skipped over because of inconsistently
formatted metadata). We also scraped citation counts for each paper
in the dataset from Google Scholar [15].
Using this data, we constructed a “synthetic ePrint” database, in
which the i th row holds a random bitstring whose length equals the
file size of the i th paper in the actual ePrint dataset (padded with 0s
to the length of the largest paper).11 The largest paper in the dataset
was 19.3 MiB, but only 56 out of the 10,181 papers exceeded 4.69 MiB;
therefore, we pruned those 56 papers to obtain a dataset comprising
10,125 papers (the discarded manuscripts were predominantly older
PostScript files). This resulted in a 46.35 GiB database (including
the 0-padding) of chronologically sorted “synthetic ePrint papers”
that user can fetch using IT-PIR queries.
We also constructed histograms to determine (i) the total number
of papers associated with each keyword, and (ii) the total number
of papers by each author. We identified 1,005 unique keywords that
were associated with five or more distinct papers each, and 1,750
unique authors that were each associated with four or more distinct
papers each, within the pruned dataset. From here, we constructed
four different indexes of 4-batch queries over GF(28); namely, we
created indexes of 4-batch queries supporting requests for the “4
most highly cited” and the “4 most recently posted” ePrint papers
for each keyword (associated with at least 5 papers) and for each
author (associated with at least 4 papers).
We performed two kinds of experiments for each of the four
indexes of queries. Table 1 summarizes the results of these experi-
ments, as well as some statistics about the time required to generate,
and the storage requirements for, each index of queries. First, we
measured the total number of requests through each of the four
indexes of queries that both our Nvidia Tesla K20 GPU Accelerator
and our Intel Core i5-2550 CPU could process per second; given
their small dimensions and the choice of working over GF(28), in
all cases we managed a whopping 49,000+ queries per second on
the GPU and over 20,000 queries per second on a single core of
the CPU. Second, we measured the total time required to retrieve
a random paper from the dataset using a positional query output
by each of the four indexes of queries. Because each of these in-
dexes of queries contains a relatively large number of all-0 columns,
the cost of the latter PIR step was substantially lower than that
of a standard positional query. In particular, queries by keyword
took around 19 seconds, on average, whereas queries by author
took around 33 seconds, on average; by contrast, positional PIR
queries over the entire database took nearly 70 seconds, on average.
These measurements suggest that indexes of queries can indeed be
a useful building block in the construction of practical PIR-based
systems for datasets on the order of tens of GiB.
11We refrained from downloading all ePrint papers and instead opted for random
data purely to avoid unduly burdening ePrint with a high volume of unnecessary
downloads.
Table 1: Experimental results obtained for the IACR Cryptology ePrint Archive [19] dataset. The dataset consists of 10,181
academic papers and associated metadata. All timing experiments were repeated for 100 trials to obtain a standard deviation
to one significant figure, and are reported to that precision (± the standard deviation).
Search
criteria
Sort
criteria
Keyword
(p = 1005)
Author
(p = 1750)
Recency
Citations
Recency
Citations
Simple
index
generation
1.5 ± 0.1 s
1.3 ± 0.1 s
3.1 ± 0.1 s
3.1 ± 0.2 s
Bucket
(interp. + eval.)
generation
54 ± 9 ms
52 ±10 ms
63 ± 6 ms
63 ± 8 ms
Bucket
size
71.76 KiB
70.17 KiB
92.38 KiB
91.69 KiB
# of
nonempty
columns
2692
2645
4548
4546
(queries/sec)
GPU index
throughput
49100 ± 100
49100 ± 100
49100 ± 100
49000 ± 100
(queries/sec)
CPU index
throughput
32800 ± 400
30700 ± 600
22700 ± 400
20100 ± 300
PIR
(secs/query)
throughput
19.1 ± 0.7 s
18.8 ± 0.6 s
32.6 ± 0.8 s
32.4 ± 0.9 s
8 CONCLUSION AND FUTURE WORK
We proposed indexes of queries, a novel mechanism for supporting
efficient and expressive, single-round queries over multi-server PIR
databases. Our approach decouples the way users construct their
queries from the physical layout of the database, thereby enabling
users to retrieve information using contextual queries that specify
which data they seek, as opposed to position-based queries that
specify where in the database those data happen to reside. We
demonstrated the feasibility of at least one promising applications
of our indexes-of-queries approach, and proposed several other
compelling possibilities, which we believe present several exciting
opportunities for future work.
Another potential avenue for future work is to explore the in-
dex of queries approach as it applies to other vector-matrix PIR
protocols, which may lead to additional useful instantiations (e.g.,
eliminating non-collusion assumptions and compressing queries
by settling for computational privacy). Likewise, it would be in-
teresting to explore how other families of batch codes might yield
alternative constructions for batch indexes of queries and indexes of
batch queries, which may offer different tradeoffs or compatability
with a wider range of PIR protocols.
Acknowledgements. This material is based upon work supported
in part by the National Science Foundation under Grant No. 1718475,
by Lilly Endowment, Inc., through its support for the Indiana Uni-
versity Pervasive Technology Institute, and by the Indiana META-
Cyt Initiative. The Indiana METACyt Initiative at IU is also sup-
ported in part by Lilly Endowment, Inc.
REFERENCES
[1] Paul Barrett. Implementing the Rivest Shamir and Adleman public key encryption
algorithm on a standard digital signal processor. In Advances in Cryptology:
Proceedings of CRYPTO 1986, volume 263 of LNCS, pages 311–323, Santa Barbara,
CA, USA (August 1987).
[2] Simon Blackburn and Tuvi Etzion. PIR array codes with optimal PIR rate.
arXiv:CoRR, abs/1607.00235 (July 2016).
[3] Elette Boyle, Niv Gilboa, and Yuval Ishai. Function secret sharing. In Advances
in Cryptology: Proceedings of EUROCRYPT 2015 (Part II), volume 9057 of LNCS,
pages 337–367, Sofia, Bulgaria (April 2015).
[4] Elette Boyle, Niv Gilboa, and Yuval Ishai. Breaking the circuit size barrier for
secure computation under DDH.
In Advances in Cryptology: Proceedings of
CRYPTO 2016 (Part I), volume 9814 of LNCS, pages 509–539, Santa Barbara, CA,
USA (August 2016).
[5] Elette Boyle, Niv Gilboa, and Yuval Ishai. Function secret sharing: Improvements
and extensions. In Proceedings of CCS 2016, pages 1292–1303, Vienna, Austria
(October 2016).
13
[14]
[13]
[6] Terence H. Chan, Siu-Wai Ho, and Hirosuke Yamamoto. Private information
retrieval for coded storage. In Proceedings of ISIT 2015, pages 2842–2846, Hong
Kong (June 2015).
[7] Benny Chor, Niv Gilboa, and Moni Naor. Private information retrieval by key-
words. Technical Report CS 0917, Technion-Israel Institute of Technology, Haifa,
Israel (February 1997).
[8] Henry Cohn and Nadia Heninger. Approximate common divisors via lattices. In
Proceedings of ANTS X (2012), volume 1, number 1 of The Open Book Series, pages
271–293, San Diego, CA, USA (July 2012).
[9] Nvidia Corporation. Tesla® Keplertm GPU Accelerators. http://www.nvidia.com/
content/tesla/pdf/Tesla-KSeries-Overview-LR.pdf. (Accessed: February 16, 2017).
[10] Casey Devet, Ian Goldberg, and Nadia Heninger. Optimally robust private
information retrieval. In Proceedings of USENIX Security 2012, pages 269–283,
Bellevue, WA, USA (August 2012).
[11] Torbjörn Granlund et al. GNU multiple precision arithmetic library; version
6.1.2 [computer software]. Available from: https://gmplib.org/ (December 2016).
[12] Arman Fazeli, Alexander Vardy, and Eitan Yaakobi. Codes for distributed PIR
with low storage overhead. In Proceedings of ISIT 2015, pages 2852–2856 (June
2015).
Ian Goldberg. Improving the robustness of private information retrieval. In
Proceedings of IEEE S&P 2007, pages 131–148, Oakland, CA, USA (May 2007).
Ian Goldberg, Casey Devet, Wouter Lueks, Ann Yang, Paul Hendry, and Ryan
Henry. Percy++ / PIR in C++; version 1.0 [computer software]. Available from:
git://git-crysp.uwaterloo.ca/percy (October 2014).
[15] Google Scholar. https://scholar.google.com/. (Accessed: February 16, 2017).
[16] Ryan Henry. Polynomial batch codes for efficient IT-PIR. In Proceedings on Privacy
Enhancing Technologies (PoPETS), volume 2016(4), pages 202–218, Darmstadt,
Germany (July 2016).
[17] Ryan Henry, Kevin Henry, and Ian Goldberg. Making a Nymbler Nymble using
VERBS. In Proceedings of PETS 2010, volume 6205 of LNCS, pages 111–129, Berlin,
Germany (July 2010).
[18] Ryan Henry, Yizhou Huang, and Ian Goldberg. One (block) size fits all: PIR
and SPIR with variable-length records via multi-block queries. In Proceedings of
NDSS 2013, San Diego, CA, USA (February 2013).
IACR Cryptology ePrint Archive. https://eprint.iacr.org/. (Accessed: February 10,
2017).
[20] Arvind Narayanan and Vitaly Shmatikov. Myths and fallacies of “personally
identifiable information”. Communications of the ACM (CACM), 53(6):24–26
(June 2010).
[21] Femi G. Olumofin and Ian Goldberg. Privacy-preserving queries over relational
databases. In Proceedings of PETS 2010, volume 6205 of LNCS, pages 75–92, Berlin,
Germany (July 2010).
Joel Reardon, Jeffrey Pound, and Ian Goldberg. Relational-complete private
information retrieval. Technical Report CACR 2007-34, University of Waterloo,
Waterloo, ON, Canada (December 2007).
Irving S. Reed and Gustav Solomon. Polynomial codes over certain finite fields.
Journal of the Society for Industrial and Applied Mathematics (SIAM), 8(2):300–304
(June 1960).
[24] Len Sassaman, Bram Cohen, and Nick Mathewson. The Pynchon Gate: A secure
method of pseudonymous mail retrieval. In Proceedings of WPES 2005, pages 1–9,
Alexandria, VA, USA (November 2005).
[25] Adi Shamir. How to share a secret. Communications of the ACM (CACM),
[26] Victor Shoup. NTL: A library for doing number theory; version 10.5.0 [computer
22(11):612–613 (November 1979).
software]. Available from: http://www.shoup.net/ntl (July 2017).
[27] Frank Wang, Catherine Yun, Shafi Goldwasser, Vinod Vaikuntanathan, and Matei
Zaharia. Splinter: Practical private queries on public data. In Proceedings of
NSDI 2017, pages 299–313, Boston, MA, USA (March 2017).
[19]
[22]
[23]