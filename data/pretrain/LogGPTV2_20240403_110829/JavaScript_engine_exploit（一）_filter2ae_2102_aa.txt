# JavaScript engine exploit（一）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
写这篇文章的目的主要是希望记录下自己学习的过程，也将自己的学习经历分享给希望学习JS引擎漏洞利用的初学者。
我刚开始学习的是JSC（JavaScriptCore），这是Safari浏览器所使用的内核WebKit的JS引擎。我选择这个目标入手的原因主要是这个比较简单，很多大佬给出的JS引擎的研究难度基本都是：
V8（Chrome）> Spidermonkey（Firefox）> JacaScriptCore（Safari）> Chakra（Edge）
因为Chakra快被微软抛弃了，所以我还是选择了JSC。
## 0x01 JS引擎的一些基础知识
在学习JS引擎的漏洞利用之前，对JS引擎的一些内部运行原理做一个了解肯定是必要的。当然，也不必把所有原理都了解，由于我是通过调试特定的漏洞来进行学习（大部分初学者都是如此），所以我们只需要了解到与这个漏洞相关的一些知识就足够了。推荐去看saelo在2016年发的paper：[Attacking
javascript
engines](http://phrack.org/papers/attacking_javascript_engines.html)
我在下面也引述文章中的部分内容。
###  JavaScript engine overview
总体来看，JavaScript引擎包括了三个部分：
  * 一个基础的编译器，至少需要包含一个JIT（Just-in-time）。
  * 一个JavaScript VM，用来运行JavaScript代码。
  * 一个JavaScript Runtime，用来提供一些内置Objects和Functions。
我们不需要关心编译器的内部原理，因为跟我们的漏洞利用关系不大（至少看起来关系不大），我们只需要把编译器看作一个 “输入源码，输出字节码”的黑盒就行了。
###  The VM, Values, and NaN-boxing
VM通常都包含一个可以直接执行字节码的解释器。VM被实现为`stack-based`的机器（相对于`register-based`来讲），从而可以通过栈来对值进行操作。对于具体的操作码的实现可能看起来和下面一样：
    CASE(JSOP_ADD)
    {
      MutableHandleValue lval = REGS.stackHandleAt(-2);
      MutableHandleValue rval = REGS.stackHandleAt(-1);
      MutableHandleValue res = REGS.stackHandleAt(-2);
      if (!AddOperation(cx, lval, rval, res))
        goto error;
      REGS.sp--;
    }
    END_CASE(JSOP_ADD)
这段代码截取自Firefox的JS引擎Spidermonkey，而JSC使用汇编实现的类似功能，看起来就没有上面这么直观。对JSC的实现感兴趣的可以去看这个文件`Webkit/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm`。
通常初级JIT（first stage JIT or called baseline JIT）负责减轻一些解释器的调度开销，而高级JIT（higher
stage JIT）则会做一些比较复杂的优化操作。有点类似于我们平常所使用的AOT（ahead-of-time）编译器，就比如gcc。优化型JIT（也就是前面提到的高级JIT）通常都是推测型的，意思就是它们会基于一些推测来进行优化，比如它会认为一个变量是而且一直是数字类型。当然这种推测也可能出错，当遇到出错的时候JIT就会回退到推测之前的状态。
JavaScript是动态类型语言，因此类型信息与运行时的变量有关，而不是编译时的变量。JavaScript类型系统定义了几个元类型（number,
string, boolean, null, undefined, symbol）和对象（array,
function）。需要注意的是JavaScript没有像其他语言一样包含‘类’的概念。取而代之的是JavaScript使用了所谓“基于原型的继承（prototype-based-inheritance）”，每个对象都有一个指向`prototype`对象的引用，这个prototype对象包含了指向它的对象的属性。
出于性能考虑（快速拷贝，适应64位的寄存器架构等），所有主流的JavaScript引擎在表示一个Value的时候都不超过八字节。一些JS引擎，比如v8，会使用`tagged
pointers`来表示值，它会使用最低有效位来标识一个值是指针还是立即数。JSC和Spidermonkey则使用了另一种叫做`NaN-boxing`的概念。在`NaN-boxing`中使用了多种位模式来表示NaN（Not-a-Number），所以可以将这些位模式来编码其他的值，以下是IEEE 754的规则总结：
形式 | 指数 | 小数部分  
---|---|---  
零 | 0 | 0  
非规约形式 | 0 | 大于0小于1  
规约形式 |  到 | 大于等于1小于2  
无穷 |  | 0  
NaN |  | 非0  
这些多余的位模式足够用来编码整型和指针了，也因为使用了NaN-boxing，对于64位平台而言，目前只有48位用于寻址。
JSC使用的这个方案在`Webkit/Source/JavaScriptCore/runtime/JSCJSValue.h`中有很好的解释，引用如下：
                /*
          ...
          * The top 16-bits denote the type of the encoded JSValue:
          *
          *     Pointer {  0000:PPPP:PPPP:PPPP
          *              / 0001:****:****:****
          *     Double  {         ...
          *               FFFE:****:****:****
          *     Integer {  FFFF:0000:IIII:IIII
          *
          * The scheme we have implemented encodes double precision values by
          * performing a 64-bit integer addition of the value 2^48 to the number.
          * After this manipulation no encoded double-precision value will begin
          * with the pattern 0x0000 or 0xFFFF. Values must be decoded by
          * reversing this operation before subsequent floating point operations
          * may be performed.
          *
          * 32-bit signed integers are marked with the 16-bit tag 0xFFFF.
          *
          * The tag 0x0000 denotes a pointer, or another form of tagged
          * immediate. Boolean, null and undefined values are represented by
          * specific, invalid pointer values:
          *
          *     False:     0x06
          *     True:      0x07
          *     Undefined: 0x0a
          *     Null:      0x02
          *
          ...
          */
总结：
  * Pointer： [0000][xxxx:xxxx:xxxx]（前两个字节为0，后六个字节寻址）
  * Double： [0001～FFFE][xxxx:xxxx:xxxx]
  * Intger： [FFFF][0000:xxxx:xxxx]（只有低四个字节表示数字）
  * False： [0000:0000:0000:0006]
  * True： [0000:0000:0000:0007]
  * Undefined： [0000:0000:0000:000a]
  * Null： [0000:0000:0000:0002]
有意思的是0x0不是一个合法的JSValue，它会在在引擎中导致崩溃。
###  Objects and Arrays
JavaScript中的对象实际上就是属性的集合，这些属性都可用（key,
value）的键值对来表示。可以使用点（foo.bar）或者方括号（foo[‘bar’]）来访问属性。至少在理论上，在使用键来查找值之前都需要先将键转化为字符串的形式。
数组被描述为特殊的(“exotic”)对象，如果属性名称由32位整数来表示的话，这些属性也被称为元素。如今的大多数引擎都将这个概念扩展到了所有对象。然后，数组就是拥有`length`属性的特殊对象，它的值始终等于最高元素的索引加一。这些规定的结果就是，每个对象都具有通过字符串或者符号键访问的属性，以及通过整数索引访问的属性。
在内部，JSC将属性和元素存储在同一片内存区域中，并且在对象内部存放指向这块内存的指针。这个指针指向这片内存的中间位置，左边存放对象的属性值，右边存放对象的元素值，而在左边最近的那个内存单元存放了一个header，这个header里包含了`length`的值。这样的内存表现形式被称为`Butterfly`，在下文我们都将这种内存和指向它的指针都称为`Butterfly`，这样会使文章理解起来轻松一些。
    --------------------------------------------------------    .. | propY | propX | length | elem0 | elem1 | elem2 | ..
    --------------------------------------------------------                                ^
                                |
                +---------------+
                |
      +-------------+
      | Some Object |
      +-------------+
实际上使用Butterfly来存储数据只是一个可选项（Optional），如果对象属性不多（不大于6个）而且不是数组的时候，对象的属性值将不会申请Butterfly，而是存储在对象内部，内存结构如下：
    object            :    objectHeader    butterfly(Null)
    object+0x10    :    prop_1                prop_2
    object+0x20    :    prop_3                prop_4
    object+0x30    :    prop_5                prop_6
虽然通常来讲，元素不需要线性地存储在内存中，但特别地：
    a = [];
    a[0] = 42;
    a[10000] = 42;
这段代码可能会导致数组以某种分散的模式来存储，这种模式会根据给定的索引额外在数组的后备存储内存中映射一个索引出来。这样的话，这个数组就不需要请求10001个元素所需要的内存了。除了不同的数组存储模式，数组也拥有不同的表现形式来表示存储的数据。举个例子，一个32位的整型数组可能会以原生形式（native
form）存储来避免NaN-boxing的解包和重打包操作，这样也节约了内存。因此JSC也在`Webkit/Source/JavaScriptCore/runtime/IndexingType.h`中定义了一组不同的索引类型。最重要的部分有：
        ArrayWithInt32      = IsArray | Int32Shape;
        ArrayWithDouble     = IsArray | DoubleShape;
        ArrayWithContiguous = IsArray | ContiguousShape;
第三种存储的是JSValue，前两种存储的都是它们的原生类型。
到这里可能有读者会好奇在这种模式下，对象的属性是如何被索引到的，这点将会在后面深入讨论，简单来讲，有一种被称为`structure`的特殊元对象通过给定的属性名，将每个对象的属性映射到对应内存位置。
###  Functions
Functions在Javascript十分重要，因此它也值得我们对它进行特别的讨论。
当执行一个函数体时，两个特殊的变量将可以访问。一个是`arguments`，它提供对参数和调用者的访问，从而使得可以创建具有参数的Function。另一个就是`this`，根据Function的调用情况，`this`可以指向不同的对象：
  * 如果调用的Function作为构造函数（ new func(…) ），`this`指向新创建的对象，在Function定义期间，构造函数就已经为新对象设置了`.prototype`属性。
  * 如果Function作为某个对象的方法被调用（obj.func(…)），`this`将指向这个对象。
  * 否则`this`只是指向当前的全局对象，因为它在Function之外使用。
因为Functions是JavaScript中十分重要的对象，它们同样具有属性。根据刚才的描述我们知道了`.prototype`属性，另外每个Function（实际上是Function
prototype）还有两个比较有趣的属性，`.call`和`.apply`函数，允许使用给定的`this`和一些参数来调用Function。例如，可以使用它们来完成装饰器的功能：
    function decorate(func) {
        return function() {
            for (var i = 0; i argument(0).toNumber(exec);
       double arg2 = exec->argument(1).toNumber(exec);
       return JSValue::encode(JSValue(operationMathPow(arg, arg2)));
     }
我们可以看到：
  1. Native JavaScript Function的签名。
  2. 如何使用`argument`提取参数（如果参数不够就返回undefine）。
  3. 如何将参数转化为需要的类型，有一组特定的转换规则，这一点将在之后详细讨论。
  4. 如何对本地数据类型进行实际操作。
  5. 如何将结果返回给调用者，这里简单地将结果编码为了JSValue。
这里还有一个显而易见的部分，各种核心的操作(`operationMathPow(arg,
arg2)`)都是用单独的函数，这样它们可以直接被JIT编译了的代码调用。
###  The Structures
这个部分属于JavaScript对象模型的内容，关系到JavaScript引擎如何去访问对象的属性。因为访问属性在JavaScript中是一个十分频繁的操作，为了提高访问速度，每个主流的JavaScript引擎都对此做了优化，在不同的引擎中对这种技术的称呼也各不相同：
  * 在学术论文中被称为 _Hidden Classes_
  * 在V8中是 _Maps_
  * 在Chakra中是 _Types_