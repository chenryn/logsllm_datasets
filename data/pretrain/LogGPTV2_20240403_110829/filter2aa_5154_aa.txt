# 数组类
---
- https://www.kancloud.cn/imxieke/ruby-base/107301
---
# 数组
数组是带索引的对象的集合。
数组有以下特征：
- 可以从数组中获取某个索引的元素（对象）
    例：`print name[2]`
- 可以将任意的值（对象）保存到数组的某个索引的元素中
    例：`name[0] = " 测试 "`
- 使用迭代器可以逐个取出数组中的元素
    例：`names.each{|name| puts name}`
# 数组的创建方法
```
nums = [1, 2, 3, 4, 5]
strs = ["a", "b", "c", "d"]
```
**使用 Array.new**
创建类的实例时使用的 `new` 方法，创建数组时也同样可以使用。
```ruby
a = Array.new
p a                    #=> []
a = Array.new(5)
p a                    #=> [nil, nil, nil, nil, nil]
a = Array.new(5, 0)
p a                    #=> [0, 0, 0, 0, 0]
```
`Array` 类的情况下，若 `new` 方法没有参数，则会创建元素个数为 0 的数组；若 `new` 方法只有 1 个参数，则会创建元素个数为该参数个数，且各元素初始值都为 `nil` 的数组；若 `new` 方法有两个参数，则第 1 个参数代表元素的个数，第 2 个参数代表元素值的初始值。
当希望创建元素值相同的数组时，建议使用这个方法。
**使用 %w 与 %i**
创建不包含空白的字符串数组时，可以使用 `%w`。
```
lang = %w(Ruby Perl Python Scheme Pike REBOL)
p lang #=> ["Ruby", "Perl", "Python", "Scheme", "Pike",
       #    "REBOL"]
```
虽然给人的感觉只是节省了书写 `" "` 和 `,` 的时间，但是如果能掌握这种字符串数组的创建方法，就会使程序更加简洁。此外，Ruby2.0 还提供了创建符号（Symbol）数组的 `%i`。
```
lang = %i(Ruby Perl Python Scheme Pike REBOL)
p lang   #=> [:Ruby, :Perl, :Python, :Scheme, :Pike, :REBOL]
```
在本例中，创建数组时使用了 `()` 将数组元素括了起来，但实际上还可以使用如 `<>`、`||`、`!!`、`@@`、`AA` 这样的任意字符。
虽然 Ruby 允许我们使用任意字符，但若用一些不常用的字符来创建数组的话，可能就会使程序不便于阅读。在选择表示字符串数组元素的字符时，还要注意该字符不能在要创建的字符串中出现，因此建议使用 `()`、`<>`、`||`。
**使用 to_a 方法**
到现在为止，我们已经介绍了三种传统的创建数组的方法，下面我们就来看看如何将其他对象转换为数组。
很多类都定义了 `to_a` 方法，该方法能把该类的对象转换为数组。
```ruby
color_table = {black: "#000000", white: "#FFFFFF"}
p color_table.to_a  #=> [[:black, "#000000"],
                    #   [:white, "#FFFFFF"]]
```
对散列对象使用 `to_a` 方法，结果就会得到相应的数组的数组。具体来说就是，将散列中的各键、值作为一个数组，然后再把这样的数组放到一个大数组中。
**使用字符串的 split 方法**
我们再来介绍一个将对象转换为数组的方法。对用逗号或者空白间隔的字符串使用 `split` 方法，也可以创建数组。
```ruby
column = "2013/05/30 22:33 foo.html proxy.example.jp".split()
p column
#=> ["2013/05/30", "22:33", "foo.html", "proxy.example.jp"]
```
# 索引的使用方法
在了解了如何创建数组之后，下面我们就来看看如何操作数组。
**获取元素**
对数组指定索引值，就可以获取相应的元素。我们可以逐个获取元素，也可以一次获取多个元素。
通过 `[]` 指定索引，获取元素。`[]` 有以下 3 种用法：
- a [n]
- a [n..m] 或者 a [n...m]
- a [n, len]
用法（a）是我们在第 2 章中使用过的获取索引值为 n 的元素的方法。例如，通过 `alpha[0]` 获取数组 `alpha` 的首个元素。这里要注意，数组的索引值是从 0 开始的。
索引值为负数时，不是从数组的开头，而是从数组的末尾开始获取元素。如果指定的索引值大于元素个数，则返回 `nil`。
用法（b）的 a [n..m] 表示获取从 a [n] 到 a [m] 的元素，然后用它们创建新数组并返回。a [n..m] 表示获取从 a [n] 到 a [m-1] 的元素，并用它们创建新数组返回。虽然下面的例子中只讨论 [n..m] 的形式，但能用 [n..m] 的地方同样能用 [n...m]。
如果 `m` 的值比数组长度大，则返回的结果与指定数组最后一个元素时是一样的
用法（c）[n, len] 表示从 a [n] 开始，获取之后的 len 个元素，用它们创建新数组并返回。
另外，我们还可以用普通的方法代替 `[]`。
- `a.at(n)`       ……与 a[n] 等价
- `a.slice(n)`        ……与 a[n] 等价
- `a.slice(n..m)`     ……与 a[n..m] 等价
- `a.slice(n, len)`   ……与 a[n, len] 等价
不过一般情况下我们很少会使用上述方法。
**元素赋值**
使用 `[]`、`at`、`slice` 方法除了可以获取元素外，还可以对元素赋值。
- `a[n] = item`
    这是将 a [n] 的元素值变更为 item。在下面的例子中，我们来尝试把 B 赋值给第 2 个元素，把 E 赋值给第 5 个元素。
    上面的例子介绍的是对一个元素赋值，实际上 Ruby 还可以一次对多个元素赋值。指定多个元素的方法与获取多个元素的方法是一样的。
    在下面的例子中，我们来尝试对数组的第 3 个元素到第 5 个元素赋值。下面是使用 `[n, len]` 的形式进行赋值的例子。
    ```ruby
    alpha = ["a", "b", "c", "d", "e", "f"]
    alpha[2, 3] = ["C", "D", "E"]
    p alpha  #=> ["a", "b", "C", "D", "E", "f"]
    ```
**插入元素**
我们还可以在保持当前元素不变的情况下，对数组插入新的元素。
插入元素其实也可以被认为是对 0 个元素进行赋值。因此，指定 `[n, 0]` 后，就会在索引值为 n 的元素前插入新元素。
**通过多个索引创建数组**
使用 `values_at` 方法，就可以利用多个索引来分散获取多个元素，并用它们创建新数组。
- `a.values_at (n1, n2, …)`
    用这个方法，我们就可以每隔一个元素获取一次
# 作为集合的数组
到目前为止的数组操作都是通过索引完成的。也就是说，从哪里获取元素、给哪个元素赋值、在哪里插入元素这些操作都是直接指定数组索引后进行的。
的确，数组、`Array` 类本来就是带有索引的对象，使用索引也是理所当然。不过有些时候我们会希望不通过索引而直接操作数组元素。
例如，我们可以把数组当成集合，这样一来，Array 类中的各元素就变了集合里的元素。
然而，由于集合没有顺序的概念，因此 `["a", "b", "c"]`、`["b", "c", "a"]`、`["c", "b", "a"]` 就都可以被认为是同一个集合。
这样操作数组时，如果我们还关心“这个对象是数组的第几个元素”之类的问题，就可能会造成混乱。这是因为，索引操作实际上只是数组封装的一个功能而已。
接下来，我们就来看看如何把数组当作集合使用。而在下一节中，我们会再讨论把数组当作列使用时的方法。
集合的基本运算分为交集和并集。
- 取出同时属于两个集合的元素，并创建新的集合
- 取出两个集合中的所有元素，并创建新的集合
我们把第 1 种集合称为交集，第 2 种集合成为并集。
- 交集……ary = ary1 & ary2
- 并集……ary = ary1 | ary2
集合还有另外一种运算——补集，即获取某个集合中不属于另外一个集合的元素。但是 Array 类的情况下，由于没有全集的概念，因此也就没有补集。不过 Array 类有把某个集合中属于另外一个集合的元素删除的差运算。
- 集合的差……ary = ary1 - ary2
由于数组 `ary2` 中包含的字符串 `"d"` 在数组 `ary1` 中并没有，因此不会被保留在执行结果中。
**“|”与“+”的不同点**
连接数组除了可以使用 `|` 外还可以使用 `+`。这两种方法看起来比较相似，但是有相同元素时它们的效果就不一样了。
```ruby
num = [1, 2,3]
even = [2, 4, 6]
p (num + even)    #=> [1, 2, 3, 2, 4, 6]
p (num | even)    #=> [1, 2, 3, 4, 6]
```
数组 `num` 与数组 `even` 都有元素 `2`。使用 `+` 时元素 `2` 会有两个，使用 `|` 时相同的元素只会有一个。
# 作为列的数组
下面，我们来看看把数组对象当作列来看待时的情况。
数据结构的队列（queue）和栈（stack）都是典型的列结构。这两个相对的数据结构都有以下两种操作数据的方式。
- 追加元素
- 获取元素
    队列是一种按元素被追加时的顺序来获取元素的数据结构。这样的做法称为 FIFO（First-in First-out），也就是“先进先出”的意思。这与人们为等待某件事而排成一列时的情况一样，因此有时候也称为等待队列。
    而栈则是一种按照与元素被追加时的顺序相反的顺序来获取元素的数据结构。这样的做法称为 LIFO（Last-in First-out），是一种“先进后出”的数据结构。也就是说，在末尾追加元素，并从末尾开始获取元素。
简单地说就是，按 A、B、C 的顺序保存数据时，按照 A、B、C 的顺序取得数据的数据结构就是队列，按照 C、B、A 的顺序取得数据的数据结构就是栈。
队列与栈都是比较复杂的数据结构，同时也是提高程序运行效率所不可欠缺的工具。
在数组的开头或末尾插入元素，或者从数组的开头或末尾获取元素等操作，是实现队列、栈等数据结构所必须的前提条件。Ruby 的数组封装了如表 13.1 所示的方法，因此可以很轻松地实现这些前提条件。
操作数组开头与末尾的元素的方法
方法 	    | 对数组开头的元素的操作	   | 对数组末尾的元素的操作
- | - | -
追加元素	| unshift	                | push
删除元素	| shift	                    | pop
引用元素	| first	                    | last
利用图所示的 push 方法和 shift 方法可以实现队列
利用图所示的 push 方法和 pop 方法可以实现栈。
要注意的是，`shift` 方法和 `pop` 方法不只是获取数组元素，而且还会把该元素从数组中删除。如果只是单纯地希望引用元素，则应该使用 `first` 方法和 `last` 方法。
```ruby
a = [1, 2, 3, 4, 5]
p a.first    #=> 1
p a.last     #=> 5
p a          #=> [1, 2, 3, 4, 5]
```
# 主要的数组方法