computed based on └─┴─┴──────┘ states using ⨁ to
current cell generation find next generation
Working Around the Linear Recursion Restriction
Once we unfold the black boxes: the CA SQL template reads
table cells twice, leading to non-linear recursion. ⭍
Work around10 linearity restriction for recursive table /:
➊ read rows of / once to form an array of rows,
➋ unnest() this array as often as needed.
SELECT ⋯
FROM (SELECT DISTINCT array_agg(row) OVER () AS / -- ➊
̅
FROM / AS row) AS /,
̅
⋯ LATERAL unnest(/./) AS t1 ⋯ -- ➋
̅
⋯ LATERAL unnest(/./) AS t2 ⋯ -- ➋
10 This is closer to a hack than conceptual beauty. Also, recall that LATERAL may have negative
performance implications.
#
Liquid Flow (SQL Code)
WITH RECURSIVE
sim(iter,x,ground,water,kinetic) AS (
SELECT 0 AS iter, f.x, f.ground, f.water, 0.0 AS kinetic
FROM fluid AS f
UNION ALL
SELECT s0.iter + 1 AS iter, s0.x, s0.ground,
s0.water + COALESCE(agg.Δwater , 0) AS water,
s0.kinetic + COALESCE(agg.Δkinetic, 0) AS kinetic
FROM (SELECT DISTINCT array_agg(row) OVER () AS sim FROM sim AS row) AS _,
LATERAL unnest(sim) AS s0(iter int, x int, ground int, water numeric, kinetic numeric)
LEFT OUTER JOIN
LATERAL (SELECT infs.x, SUM(infs.Δwater) AS Δwater, SUM(infs.Δkinetic) AS Δkinetic
FROM (SELECT (-- flow to the left -- ⎫ ┌──────────────────────────────────────────────────┐
CASE WHEN ‹‹₁› -- ⎮ │ │
THEN array[ROW(s1.x-1, ‹Δwater›, ‹Δkinetic›), -- ⎮ │ Specific rules for the Liquid Flow CA, │
ROW(s1.x , ‹Δwater›, ‹Δkinetic›), -- ⎮ │ the enclosing SQL code is generic. │
ROW(s1.x-1, ‹Δwater›, ‹Δkinetic›) -- ⎮ │ │
] -- ⎮ │ • Use )9'% ⋯ &G%6 ⋯ !G%6 ⋯ %6$ to implement │
END -- ⎮ │ conditional rules. │
|| -- ⎬ │ │
-- flow to the right -- ⎮ │ • Use windows to access cell neighborhood. │
CASE WHEN ‹‹₂› -- ⎮ │ │
THEN array[ROW(s1.x+1, ‹Δwater›, ‹Δkinetic›), -- ⎮ │ • Use array concatenation (||) to implement │
ROW(s1.x , ‹Δwater›, ‹Δkinetic›), -- ⎮ │ sequences of rules. │
ROW(s1.x+1, ‹Δwater›, ‹Δkinetic›) -- ⎮ │ │
] -- ⎮ │ │
END -- ⎭ └──────────────────────────────────────────────────┘
) AS influence
FROM unnest(sim) AS s1(iter int, x int, ground int, water numeric, kinetic numeric)
WINDOW horizontal AS (ORDER BY s1.x)
) AS inf(influence),
LATERAL unnest(inf.influence) AS infs(x int, Δwater numeric, Δkinetic numeric)
GROUP BY infs.x
) AS agg(x, Δwater, Δkinetic)
ON (s0.x = agg.x)
WHERE s0.iter  +.
3 3
èVè-\öUW‘èõ’ \öUW‘èõ’
#
Chomsky Normal Form and Parse Trees
Consider grammars in Chomsky Normal Form only: rules read
’,µ → \öUW‘èõ’ or ’,µ → èVè-\öUW‘èõ’ èVè-\öUW‘èõ’.
╎ Parse tree for input 1＋1×1:
╎ 
Expr → Expr Sum ╎ Expr
Expr → Term Prod ╎ ╱ 
Expr → '1' ╎ ╱ Sum
Term → Term Prod ╎ ╱ ╱ 
Term → '1' ╎  ╱ Term
Sum → Plus Term ╎ |  ╱ 
Prod → Mult Fact ╎ │ │  Prod
Fact → '1' ╎ | | │  
Plus → '＋' ╎ Expr Plus Term Mult Fact
Mult → '×' ╎ | | | | |
╎ 1 ＋ 1 × 1
#
A Tabular Encoding of Chomsky Grammars
Simple encoding of the sample arithmetic expression grammar:
lhs sym rhs₁ rhs₂ start?
Expr □ Expr Sum true
Expr □ Term Prod true
Expr 1 □ □ true
Term □ Term Prod false
Term 1 □ □ false
Sum □ Plus Term false
Prod □ Mult Fact false
Fact 1 □ □ false
Plus + □ □ false
Mult × □ □ false
Exploits that rules can have one of two forms only.
Embedded FD lhs → start? identifies one non-terminal as
the grammar's start symbol.
#
Building a Parse Tree, Bottom Up
Invariant: Keep track of which part of the input (index from
to to) can be generated by the lhs of a rule:
┌────┬────┬──┐
Expr │lhs │from│to|
╱  ├────┼────┼──┤
╱ Sum │Expr│ 1 │ 1│
╱ ╱  │Plus│ 2 │ 2│
 ╱ Term │Term│ 3 │ 3│
|  ╱  │Mult│ 4 │ 4│
│ │  Prod │Fact│ 5 │ 5│
| | │   │Prod│ 4 │ 5│
Expr Plus Term Mult Fact │Term│ 3 │ 5│
| | | | | │Sum │ 2 │ 5│
1 ＋ 1 × 1 │%R9L│ ( │ S│ U indicates parse
input index k ₁ ₂ ₃ ₄ ₅ └─ ──┴── ─┴─ ┘ successful
start symbol spans entire input
Building a Tree in Layers Requires Access to the Past
Table 9CLQI
┌────┬────┬──┐
:C˘IL T ┈┈┈┈┈┈┈┈┈Expr┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ │lhs │from│to|
╱  ├────┼────┼──┤
:C˘IL U ┈┈┈┈┈┈┈╱┈┈┈┈┈Sum┈┈┈┈┈┈┈┈┈┈┈┈┈ │Expr│ 1 │ 5│ U iteration #4
╱ ╱  │Sum │ 2 │ 5│ U iteration #3
:C˘IL V ┈┈┈┈┈┈┈┈┈┈╱┈┈┈┈┈Term┈┈┈┈┈┈┈┈ │Term│ 3 │ 5│ U iteration #2
|  ╱  │Prod│ 4 │ 5│ U iteration #1
:C˘IL ( ┈┈┈┈┈│┈┈┈┈│┈┈┈┈┈┈┈┈ Prod┈┈┈┈ │Expr│ 1 │ 1│ ⎫
| | │   │Plus│ 2 │ 2│ ⎮ found in
:C˘IL W ┈┈┈┈Expr┈Plus┈Term┈Mult┈Fact┈ │Term│ 3 │ 3│ ⎬ iteration #0
| | | | | │Mult│ 4 │ 4│ ⎮
1 ＋ 1 × 1 │Fact│ 5 │ 5│ ⎭
₁ ₂ ₃ ₄ ₅ └────┴────┴──┘
To establish Term at lmnop q (iteration #2), we need Prod
(lmnop r, iter #1 ✔) and Term (lmnop t, iter #0 ⭍).
WITH RECURSIVE's Short-Term Memory
ˇëOQ seen in table 9CLQI by…
1×1⥁ 2×1⥁ 3×1⥁
┌────┬────┬──┐ ┌────┬────┬──┐ ┌────┬────┬──┐
│lhs │from|to| │lhs │from|to| │lhs │from|to|
├────┼────┼──┤ ├────┼────┼──┤ ├────┼────┼──┤
│Expr│ 1 │ 1│ ╭────⯈|Prod│ 4 │ 5───⋈───⯈|Term│ 3 │ 5│
│Plus│ 2 │ 2│╭⋈╮ └────┴────┴──┘ │ └────┴────┴──┘
│Term│ 3 │ 3││ │ ╳──╯┈┈┈Term → Term Prod ✗
│Mult│ 4 │ 4─╯ │
│Fact│ 5 │ 5───╯┈┈┈Prod → Mult Fact ✔
└────┴────┴──┘
Parsing fact (Term,3,3) has been discovered by 1₀ — more
than one iteration ago — and is not available to 2×1⥁.
Re-Injecting Early Iteration Results (SQL Template)
WITH RECURSIVE
/(iter, 0₁, …, 0ₙ) AS (
SELECT 0 AS iter, t.* -- ⎱ add column CGIL (= 0) to
FROM (1₀) AS t -- ⎰ result of 1₀
UNION ALL
SELECT t.iter + 1 AS iter, t.*
FROM (SELECT DISTINCT array_agg(row) OVER () AS / -- ⎱ multiple reads
̅
FROM / AS row) AS /), -- ⎰ of / needed
LATERAL (
SELECT known.* -- ⎫ to the result of 1⥁ add already
̅
FROM unnest(/./) AS known -- ⎬ discovered rows (will be kept
UNION -- ⎭ since column CGIL advances)
̅
1⥁ -- 1⥁ (access / via unnest(/./))
) AS t
WHERE ‹ -- stop condition
)
WITH RECURSIVE With Long-Term Memory
ˇëOQ seen in table 9CLQI by…
1×1⥁ 2×1⥁ 3×1⥁
┌────┬────┬────┬──┐ ┌────┬────┬────┬──┐ ┌────┬────┬────┬──┐
│iter│lhs │from|to| │iter│lhs │from|to| │iter│lhs │from|to|
├────┼────┼────┼──┤ ├────┼────┼────┼──┤ ├────┼────┼────┼──┤
│ 0 │Expr│ 1 │ 1│ ╭────⯈│ 1 │Prod│ 4 │ 5───⋈───⯈│ 2 │Term│ 3 │ 5│
│ 0 │Plus│ 2 │ 2│╭⋈╮ │␥␥1␥│Expr│␥␥1␥│␥1│ │ │␥␥2␥│Prod│␥␥4␥│␥5│
│ 0 │Term│ 3 │ 3││ │ │␥␥1␥│Plus│␥␥2␥│␥2│ │ │␥␥2␥│Expr│␥␥1␥│␥1│
│ 0 │Mult│ 4 │ 4─╯ │ │␥␥1␥│Term│␥␥3␥│␥3───╯ │␥␥2␥│Plus│␥␥2␥│␥2│
│ 0 │Fact│ 5 │ 5───╯ │␥␥1␥│Mult│␥␥4␥│␥4│ │␥␥2␥│Term│␥␥3␥│␥3│
└────┴────┴────┴──┘ │␥␥1␥│Fact│␥␥5␥│␥5│ │␥␥2␥│Mult│␥␥4␥│␥4│
└────┴────┴────┴──┘ │␥␥2␥│Fact│␥␥5␥│␥5│
␥ ≡ row added by reinjection └────┴────┴────┴──┘
#
Parsing: Cocke–Younger–Kasami Algorithm (CYK)
The CYK algorithm builds parse trees bottom up, relying on
formerly discovered partial parses (dynamic programming):
Iteratively populate table parse(lhs,from,to):
[1₀]: For each ’,µ → \öUW‘èõ’: if \öUW‘èõ’ is found at
index TUVW…\V in input, add (’,µ,TUVW,\V) to parse.
[1⥁]: For each pair (’,µ₁,TUVW₁,\V₁), (’,µ₂,TUVW₂,\V₂)
in parse × parse:11 add (’,µ₃,TUVW₁,\V₂) if
1. \V₁ + 1 = TUVW₂ and
2. ’,µ₃ → ’,µ₁ ’,µ₂.
11 Implies a self-join of parse, leading to non-linear recursion.
#
Parsing Using CYK (Core SQL Code) ✎
WITH RECURSIVE
parse(…, lhs, "from", "to") AS (
SELECT …, g.lhs, i AS "from", i + length(g.sym) - 1 AS "to"
FROM grammar AS g,
generate_series(1, length(‘è‹÷\)) AS i,
WHERE g.sym IS NOT NULL
AND substr(‘è‹÷\, i, length(g.sym)) = g.sym
UNION ALL
⋮ -- ⚠ re-injection code omitted
SELECT …, g.lhs, l."from", r."to"
FROM grammar AS g,
parse AS l, parse AS r -- ⚠ need 2 × unnest() here
WHERE l."to" + 1 = r."from"
AND (g.rhs1, g.rhs2) = (l.lhs, r.lhs)
⋮
)