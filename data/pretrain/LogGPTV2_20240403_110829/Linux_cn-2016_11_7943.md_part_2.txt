* 实现一个字节流接口的 字符   （    Character    ） 设备。
* 用于存放文件系统和处理多字节数据块 IO 的 块   （    Block    ） 设备。
* 用于通过网络传输数据包的 网络   （    Network    ） 接口。
Linux 也有一个硬件抽象层（HAL），它实际扮演了物理硬件的设备驱动接口。
### 2. 设备驱动 API
Linux 和 Windows 驱动 API 都属于事件驱动类型：只有当某些事件发生的时候，驱动代码才执行——当用户的应用程序希望从设备获取一些东西，或者当设备有某些请求需要告知操作系统。
#### 2.1. 初始化
在 Windows 上，驱动被表示为 `DriverObject` 结构，它在 `DriverEntry` 函数的执行过程中被初始化。这些入口点也注册一些回调函数，用来响应设备的添加和移除、驱动卸载和处理新进入的 IRP。当一个设备连接的时候，Windows 创建一个设备对象，这个设备对象在设备驱动后面处理所有应用请求。
相比于 Windows，Linux 设备驱动生命周期由内核模块的 `module_init` 和 `module_exit` 函数负责管理，它们分别用于模块的加载和卸载。它们负责注册模块来通过使用内核接口来处理设备的请求。这个模块需要创建一个设备文件（或者一个网络接口），为其所希望管理的设备指定一个数字识别号，并注册一些当用户与设备文件交互的时候所使用的回调函数。
#### 2.2. 命名和声明设备
##### 在 Windows 上注册设备
Windows 设备驱动在新连接设备时是由回调函数 `AddDevice` 通知的。它接下来就去创建一个 设备对象   （    device object    ） ，用于识别该设备的特定的驱动实例。取决于驱动的类型，设备对象可以是 物理设备对象   （    Physical Device Object    ） （PDO）， 功能设备对象   （    Function Device Object    ） （FDO），或者 过滤设备对象   （    Filter Device Object    ） （FIDO）。设备对象能够堆叠，PDO 在底层。
设备对象在这个设备连接在计算机期间一直存在。`DeviceExtension` 结构能够被用于关联到一个设备对象的全局数据。
设备对象可以有如下形式的名字 `\Device\DeviceName`，这被系统用来识别和定位它们。应用可以使用 `CreateFile` API 函数来打开一个有上述名字的文件，获得一个可以用于和设备交互的句柄。
然而，通常只有 PDO 有自己的名字。未命名的设备能够通过设备级接口来访问。设备驱动注册一个或多个接口，以 128 位全局唯一标识符（GUID）来标示它们。用户应用能够使用已知的 GUID 来获取一个设备的句柄。
##### 在 Linux 上注册设备
在 Linux 平台上，用户应用通过文件系统入口访问设备，它通常位于 `/dev` 目录。在模块初始化的时候，它通过调用内核函数 `register_chrdev` 创建了所有需要的入口。应用可以发起 `open` 系统调用来获取一个文件描述符来与设备进行交互。这个调用后来被发送到回调函数，这个调用（以及将来对该返回的文件描述符的进一步调用，例如 `read`、`write` 或`close`）会被分配到由该模块安装到 `file_operations` 或者 `block_device_operations`这样的数据结构中的回调函数。
设备驱动模块负责分配和保持任何需要用于操作的数据结构。传送进文件系统回调函数的 `file` 结构有一个 `private_data` 字段，它可以被用来存放指向具体驱动数据的指针。块设备和网络接口 API 也提供类似的字段。
虽然应用使用文件系统的节点来定位设备，但是 Linux 在内部使用一个 主设备号   （    major numbers    ） 和 次设备号   （    minor numbers    ） 的概念来识别设备及其驱动。主设备号被用来识别设备驱动，而次设备号由驱动使用来识别它所管理的设备。驱动为了去管理一个或多个固定的主设备号，必须首先注册自己或者让系统来分配未使用的设备号给它。
目前，Linux 为 主次设备对   （    major-minor pairs    ） 使用一个 32 位的值，其中 12 位分配主设备号，并允许多达 4096 个不同的设备。主次设备对对于字符设备和块设备是不同的，所以一个字符设备和一个块设备能使用相同的设备对而不导致冲突。网络接口是通过像 eth0 的符号名来识别，这些又是区别于主次设备的字符设备和块设备的。
#### 2.3. 交换数据
Linux 和 Windows 都支持在用户级应用程序和内核级驱动程序之间传输数据的三种方式：
*  缓冲型输入输出   （    Buffered Input-Output    ） 它使用由内核管理的缓冲区。对于写操作，内核从用户空间缓冲区中拷贝数据到内核分配的缓冲区，并且把它传送到设备驱动中。读操作也一样，由内核将数据从内核缓冲区中拷贝到应用提供的缓冲区中。
*  直接型输入输出   （    Direct Input-Output    ）  它不使用拷贝功能。代替它的是，内核在物理内存中钉死一块用户分配的缓冲区以便它可以一直留在那里，以便在数据传输过程中不被交换出去。
*  内存映射   （    Memory mapping    ）  它也能够由内核管理，这样内核和用户空间应用就能够通过不同的地址访问同样的内存页。
##### Windows 上的驱动程序 I/O 模式
支持缓冲型 I/O 是 WDM 的内置功能。缓冲区能够被设备驱动通过在 IRP 结构中的 `AssociatedIrp.SystemBuffer` 字段访问。当需要和用户空间通讯的时候，驱动只需从这个缓冲区中进行读写操作。
Windows 上的直接 I/O 由 内存描述符列表   （    memory descriptor lists    ） （MDL）介导。这种半透明的结构是通过在 IRP 中的 `MdlAddress` 字段来访问的。它们被用来定位由用户应用程序分配的缓冲区的物理地址，并在 I/O 请求期间钉死不动。
在 Windows 上进行数据传输的第三个选项称为 `METHOD_NEITHER`。 在这种情况下，内核需要传送用户空间的输入输出缓冲区的虚拟地址给驱动，而不需要确定它们有效或者保证它们映射到一个可以由设备驱动访问的物理内存地址。设备驱动负责处理这些数据传输的细节。
##### Linux 上的驱动程序 I/O 模式
Linux 提供许多函数例如，`clear_user`、`copy_to_user`、`strncpy_from_user` 和一些其它的用来在内核和用户内存之间进行缓冲区数据传输的函数。这些函数保证了指向数据缓存区指针的有效，并且通过在内存区域之间安全地拷贝数据缓冲区来处理数据传输的所有细节。
然而，块设备的驱动对已知大小的整个数据块进行操作，它可以在内核和用户地址区域之间被快速移动而不需要拷贝它们。这种情况是由 Linux 内核来自动处理所有的块设备驱动。块请求队列处理传送数据块而不用多余的拷贝，而 Linux 系统调用接口来转换文件系统请求到块请求中。
最终，设备驱动能够从内核地址区域分配一些存储页面（不可交换的）并且使用 `remap_pfn_range` 函数来直接映射这些页面到用户进程的地址空间。然后应用能获取这些缓冲区的虚拟地址并且使用它来和设备驱动交流。
### 3. 设备驱动开发环境
#### 3.1. 设备驱动框架
##### Windows 驱动程序工具包
Windows 是一个闭源操作系统。Microsoft 提供 Windows 驱动程序工具包以方便非 Microsoft 供应商开发 Windows 设备驱动。工具包中包含开发、调试、检验和打包 Windows 设备驱动等所需的所有内容。
 Windows 驱动模型   （    Windows Driver Model    ） （WDM）为设备驱动定义了一个干净的接口框架。Windows 保持这些接口的源代码和二进制的兼容性。编译好的 WDM 驱动通常是前向兼容性：也就是说，一个较旧的驱动能够在没有重新编译的情况下在较新的系统上运行，但是它当然不能够访问系统提供的新功能。但是，驱动不保证后向兼容性。