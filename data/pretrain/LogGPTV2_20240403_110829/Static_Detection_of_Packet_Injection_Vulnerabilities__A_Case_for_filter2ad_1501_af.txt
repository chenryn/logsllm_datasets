We run the leakage path analysis and ﬁnd no high-entropy leaks.
From the analysis log we ﬁnd that all leakage paths start with
my_vtag check, and thus are low-entropy leaks. One of them can
be used to tell whether the attack packet has the correct my_vtag
by looking at sink SctpInPktDiscards. This needs 232 packets in
the worst case, but it can still be helpful to lower the Npkt from
232 × 2
rem_win to 232 + 2
rem_win .
With the knowledge of my_vtag, we still needs to have a
tsn that can fall into the window speciﬁed by base_tsn and
cumulative_tsn_ack_point. We use them as leak sources
and ﬁnd 3 leaks but all are low-entropy ones.
32
32
For the close-channel accept paths, the protocol states they rely
on are my_vtag and peer_vtag. In the taint summary, the sinks
are also only tainted by implicit ﬂows, but our tool outputs no high-
entropy leaks for both of the sources.
7.3.4 DCCP-Kernel
Accept path analysis. In DCCP, the checks for copying payload
and resetting connection are the same. In this analysis, our tool out-
puts 1 path and it is a TP. In this path, the DCCP sequence number
seqno needs to fall into a sequence window seqno_win around
a protocol state dccps_gsr as long as 48 bits, and the higher
and lower bounds of this window are another two protocol states
dccps_swh and dccps_swl. Thus, the Npkt is
seqno_win .
Note that the initial size of this seq_win is only 100, making it im-
practical to inject. In normal cases there should be another check
for the DCCP acknowledge sequence number ackno, but as shown
in our analysis output, attacker can send a DATA type DCCP mes-
sage without acknowledge sequence number to avoid that check.
Protocol state leakage. We use all 3 protocol states as sources in
this analysis. For sinks, currently DCCP does not create a proc ﬁle
to store global statistics yet, but it does have a structure for SNMP
statistics like TCP-Kernel and SCTP-Kernel, which has same leak-
age potential if enabled in the future. Thus, we use these vari-
ables as leakage sinks. Our tool outputs 5 leaks and 4 of them
are TPs. The 1 FP path requires (1) the attack packet is a SYNC
48
2
398or SYNCACK packet having the right ackno, (2) seqno is larger
than dccps_swl, and (3) it fails the seqno_win check. However,
when (1) and (2) happen, dccps_gsr is updated with seqno and
it won’t fail the seqno_win check. In our analysis, we can know
that dccps_gsr is updated, but cannot be sure that seqno can
pass the seqno_win check. The 4 TPs all require seqno to fall
into seqno_win, and thus are all low-entropy leaks.
8. LIMITATION AND FUTURE WORK
Possible FNs due to implementation simpliﬁcation. We design
and implement a high precision data ﬂow analysis with implicit
ﬂow tainting and pointer analysis to avoid FNs as much as possi-
ble. However, there may still be cases causing FNs due to simpli-
ﬁed implementation. For example, as described in §5.1, we add an
iteration limit of loops to avoid adding recursive ﬁelds and this may
lead to FN cases if the leakage sinks have recursive ﬁelds.
Failure to identify semantically-conﬂicting and low-entropy
constraints. As discussed in §7.3, the majority of the FPs are
caused by conﬂicting constraints that are tricky to identify. In the
future, we plan to use a SMT solver [13] commonly employed by
symbolic execution as tool improvement.
Limited scope of storage channel. As described in §6.3, our tool
is designed with the capability to cover a range of leakage channels
such as storage channels, data timing channels, and public events
like sending packets. However, in our experiments we only use
storage channels in proc ﬁle system as leakage sinks, and may miss
practical vulnerabilities leaked through other channels. In the fu-
ture, we plan to incorporate other sinks in the leakage path analysis.
9. RELATED WORK
Network protocol analysis. To detect protocol design vulnerabil-
ities, prior work has used formal methods such as model checking
and speciﬁcation languages to perform rigorous protocol speciﬁca-
tion testing [6, 7]. However, these cannot prevent vulnerabilities
due to weak implementations. For implementation vulnerabilities,
static analysis has been applied to identify system DoS vulnerabil-
ities [8], protocol manipulation attacks [30], and interoperability
problems [36]. However, none focused on packet injection vulner-
ability causing payload injection or network DoS.
Static analysis for taint-style vulnerability. For taint-style vul-
nerabilities, static analysis tools have been designed to detect buffer
overﬂow [12], format string vulnerabilities [45], and SQL injection
and XSS [25, 27, 48]. Recently, Yamaguchi et al. [53] propose to
use code property graph to effectively mine such vulnerabilities in
large amounts of code. Different from them, our analysis targets
packet injection instead of code injection, which requires handling
much more and also diverse checks due to header ﬁeld semantics.
Moreover, we have a follow-up leakage analysis which is not in-
cluded in previous tools.
Static taint analysis are also used to detect information leakage
vulnerabilities in recent years, especially for privacy leakage in An-
droid system [4, 16, 17, 21]. However, these tools exclude implicit
ﬂow tainting due to its low-entropy in leakage and the problem
of high FPs [28].
In comparison, our tool taints implicit ﬂows
as required by our analysis goal, and proposes to target attacker-
controlled implicit information leaks to mitigate the FP problem
while maintaining high accuracy.
Side-channel attack and detection. Recently years witness a rise
in side-channel attack discoveries. For storage channels, proc ﬁle
systems have been abused as side-channels to infer keystrokes [56],
webpage [24], and system state [10].
In particular, Qian et
al. [37, 38] used proc ﬁle packet counters to infer TCP sequence
number. Another popular channel is timing channel, including
code path [29], data [3], and cache-access timing channel [22, 54].
In network protocol attacks, some header ﬁelds are also found to be
useful for inferring sequence number [18]. In comparison, our goal
is not to report new side-channel attack but focuses on designing an
automated tool to systematically detect side channels.
In contrast to side channel discovery, side channel detection has
been less explored. Dynamic analysis such as black-box testing
has been used to ﬁnd side channels in web application [9], and
timing side channels in SSL/TLS implementation [33]. To over-
come the drawback of analysis completeness in dynamic analysis,
static analysis tools are also developed to detect web application
and cache side channels [14, 55]. Compared to them, our tool can
detect storage side channels, which has not been covered in exist-
ing tools, and moreover, our target is protocol state leakage, which
is different from previous work.
10. CONCLUSION
In this paper, we design and implement an effective and scalable
static program analysis tool, PacketGuardian to systematically an-
alyze the security properties of network protocol implementations
against off-path packet injection attacks. PacketGuardian uses a
context-, ﬂow-, and ﬁeld-sensitive taint analysis with pointer anal-
ysis to achieve high precision, and also targets attacker-controlled
implicit information leaks. The solution signiﬁcantly eases the
classic problem of false positives of implicit ﬂow tracking while
still yields high detection accuracy of practical exploits. By ap-
plying our tool on 6 real network protocol implementations, we
are able to discover new and realistic vulnerabilities conﬁrmed by
proof-of-concept attacks for both Linux kernel TCP and 2 out of 3
RTP implementations.
Acknowledgments
We would like to thank Danfeng Zhang, Rajiv Gupta, Jia Chen,
Sanae Rosen, Jason Jong Kyu Park, Lingjia Tang, and the anony-
mous reviewers for providing valuable feedback on our work. This
research was supported in part by the National Science Foundation
under grants CNS-1318306 and CNS-1464410, as well as by the
Ofﬁce of Naval Research under grant N00014-14-1-0440.
11. REFERENCES
[1] Analysis result website. http://tinyurl.com/
PacketInjectionVulnerability.
[2] STAC - Static Taint Analysis for C.
http://code.google.com/p/tanalysis/.
[3] M. Andrysco, D. Kohlbrenner, K. Mowery, R. Jhala, S. Lerner, and
H. Shacham. On Subnormal Floating Point and Abnormal Timing. In
IEEE Symposium on Security and Privacy, 2015.
[4] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y. Le Traon, D. Octeau, and P. McDaniel. Flowdroid: Precise
Context, Flow, Field, Object-sensitive and Lifecycle-aware Taint
Analysis for Android Apps. In PLDI, 2014.
[5] T. Bao, Y. Zheng, Z. Lin, X. Zhang, and D. Xu. Strict Control
Dependence and its Effect on Dynamic Information Flow Analyses.
In ACM ISSTA, 2010.
[6] K. Bhargavan, D. Obradovic, and C. A. Gunter. Formal Veriﬁcation
of Standards for Distance Vector Routing Protocols. Journal of the
ACM, 2002.
[7] S. Bishop, M. Fairbairn, M. Norrish, P. Sewell, M. Smith, and
K. Wansbrough. Rigorous Speciﬁcation and Conformance Testing
Techniques for Network Protocols, as Applied to TCP, UDP, and
Sockets. SIGCOMM, 2005.
[8] R. Chang, G. Jiang, F. Ivancic, S. Sankaranarayanan, and
V. Shmatikov. Inputs of Coma: Static Detection of Denial-of-Service
Vulnerabilities. In CSF, 2009.
399[9] P. Chapman and D. Evans. Automated Black-box Detection of
[35] G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer. CIL:
Side-channel Vulnerabilities in Web Applications. In CCS, 2011.
[10] Q. A. Chen, Z. Qian, and Z. M. Mao. Peeking into Your App without
Actually Seeing It: UI State Inference and Novel Android Attacks. In
USENIX Security, 2014.
[11] S. Chen, R. Wang, X. Wang, and K. Zhang. Side-channel Leaks in
Web Applications: A Reality Today, a Challenge Tomorrow. In IEEE
Symposium on Security and Privacy, 2010.
[12] C. Cowan, C. Pu, D. Maier, J. Walpole, and P. Bakke. StackGuard:
Automatic Adaptive Detection and Prevention of Buffer-Overﬂow
Attacks. In USENIX Security, 1998.
[13] L. De Moura and N. Bjørner. Z3: An Efﬁcient SMT Solver. In
TACAS, 2008.
[14] G. Doychev, D. Feld, B. Köpf, L. Mauborgne, and J. Reineke.
CacheAudit: A Tool for the Static Analysis of Cache Side Channels.
In Usenix Security, 2013.
[15] E. Dumazet. Kernel discussion on ACK ﬂag. http://comments.
Intermediate Language and Tools for Analysis and Transformation of
C programs. In CC, 2002.
[36] L. Pedrosa, A. Fogel, N. Kothari, R. Govindan, R. Mahajan, and
T. Millstein. Analyzing protocol implementations for interoperability.
In NSDI, 2015.
[37] Z. Qian and Z. M. Mao. Off-Path TCP Sequence Number Inference
Attack – How Firewall Middleboxes Reduce Security. In IEEE
Symposium on Security and Privacy, 2012.
[38] Z. Qian, Z. M. Mao, and Y. Xie. Collaborative tcp sequence number
inference attack: how to crack sequence number under a second. In
CCS, 2012.
[39] Ramaiah, Anantha and Stewart, R and Dalal, Mitesh. Improving
TCP’s Robustness to Blind In-Window Attacks. rfc5961, 2010.
[40] A. Rane, C. Lin, and M. Tiwari. Raccoon: Closing Digital
Side-Channels through Obfuscated Execution. In USENIX Security,
2015.
gmane.org/gmane.linux.network/253369, 2012.
[41] S. Rasthofer, S. Arzt, and E. Bodden. A machine-learning Approach
[16] K. O. Elish, X. Shu, D. D. Yao, B. G. Ryder, and X. Jiang. Proﬁling
User-trigger Dependence for Android Malware Detection.
Computers & Security, 49:255–273, 2015.
[17] C. Gibler, J. Crussell, J. Erickson, and H. Chen. AndroidLeaks:
Automatically Detecting Potential Privacy Leaks in Android
Applications on a Large Scale. In TRUST, 2012.
for Classifying and Categorizing Android Sources and Sinks. In
NDSS, 2014.
[42] T. Reps, S. Horwitz, and M. Sagiv. Precise Interprocedural Dataﬂow
Analysis via Graph Reachability. In POPL, 1995.
[43] A. Rountev, M. Sharp, and G. Xu. IDE Dataﬂow Analysis in the
Presence of Large Object-oriented Libraries. In CC, 2008.
[18] Y. Gilad and A. Herzberg. Off-Path Attacking the Web. In USENIX
[44] M. Sagiv, T. Reps, and S. Horwitz. Precise Interprocedural Dataﬂow
WOOT, 2012.
[19] Y. Gilad and A. Herzberg. When tolerance causes weakness: the case
Analysis with Applications to Constant Propagation. Theoretical
Computer Science, 167(1):131–170, 1996.
of injection-friendly browsers. In WWW, 2013.
[45] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. Detecting Format
[20] J. A. Goguen and J. Meseguer. Security Policies and Security
Models. In IEEE Symposium on Security and Privacy, 1982.
[21] M. I. Gordon, D. Kim, J. Perkins, L. Gilham, N. Nguyen, and
M. Rinard. Information-ﬂow Analysis of Android Applications in
DroidSafe. In NDSS, 2015.
[22] D. Gullasch, E. Bangerter, and S. Krenn. Cache Games–Bringing
Access-based Cache Attacks on AES to Practice. In IEEE
Symposium on Security and Privacy, 2011.
[23] M. Hind, M. Burke, P. Carini, and J.-D. Choi. Interprocedural Pointer
Alias Analysis. TOPLAS, 21(4):848–894, 1999.
[24] S. Jana and V. Shmatikov. Memento: Learning Secrets from Process
Footprints. In IEEE Symposium on Security and Privacy, 2012.
[25] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A Static Analysis Tool
for Detecting Web Application Vulnerabilities. In IEEE Symposium
on Security and Privacy (SP), 2006.
[26] M. G. Kang, S. McCamant, P. Poosankam, and D. Song. DTA++:
Dynamic Taint Analysis with Targeted Control-Flow Propagation. In
NDSS, 2011.
[27] A. Kieyzun, P. J. Guo, K. Jayaraman, and M. D. Ernst. Automatic
creation of SQL injection and cross-site scripting attacks. In ICSE,
2009.
[28] D. King, B. Hicks, M. Hicks, and T. Jaeger. Implicit ﬂows: Can’t
String Vulnerabilities with Type Qualiﬁers. In USENIX Security,
2001.
[46] K. Smith-Strickland. We’re Closer to an Encrypted Internet than You
Think. http://gizmodo.com/
two/-thirds-of-internet-traffic-could-be
-encrypted-by-ne-1702659626#, May 2015.
[47] S. Son and V. Shmatikov. The Hitchhiker’s Guide to DNS Cache
Poisoning. In Security and Privacy in Communication Networks,
pages 466–483. Springer, 2010.
[48] O. Tripp, M. Pistoia, S. J. Fink, M. Sridharan, and O. Weisman. TAJ:
Effective Taint Analysis of Web Applications. In PLDI, 2009.
[49] A. V. Aho, R. Sethi, and J. D. Ullman. Compilers: Principles,
Techniques, And Tools (2nd Edition). Addison Wesley, 2006.
[50] V. Varadarajan, T. Ristenpart, and M. Swift. Scheduler-based
defenses against cross-vm side-channels. In Usenix Security, 2014.
[51] R. P. Wilson and M. S. Lam. Efﬁcient Context-sensitive Pointer
Analysis for C Programs. In PLDI, 1995.
[52] Y. Xie and A. Aiken. Saturn: A Scalable Framework for Error
Detection using Boolean Satisﬁability. TOPLAS, 2007.
[53] F. Yamaguchi, N. Golde, D. Arp, and K. Rieck. Modeling and
Discovering Vulnerabilities with Code Property Graphs. In IEEE
Symposium on Security and Privacy (SP), 2014.
Live with ’em, Can’t Live Without ’em. Information Systems
Security, Lecture Notes in Computer Science, 5352:56–70, 2008.
[54] Y. Yarom and K. E. Falkner. FLUSH+RELOAD: A High Resolution,
Low Noise, L3 Cache Side-Channel Attack. USENIX Security, 2014.
[29] P. C. Kocher. Timing Attacks on Implementations of Difﬁe-Hellman,
[55] K. Zhang, Z. Li, R. Wang, X. Wang, and S. Chen. Sidebuster:
RSA, DSS, and Other Systems. In CRYPTO, 1996.
[30] N. Kothari, R. Mahajan, T. Millstein, R. Govindan, and
M. Musuvathi. Finding Protocol Manipulation Attacks. In
SIGCOMM, 2011.
[31] F. Liu, Y. Yarom, Q. Ge, G. Heiser, and R. B. Lee. Last-Level Cache
Side-Channel Attacks are Practical. In IEEE Symposium on Security
and Privacy, 2015.
[32] X. Luo, P. Zhou, E. W. Chan, W. Lee, R. K. Chang, and R. Perdisci.
Automated Detection and Quantiﬁcation of Side-channel Leaks in
Web Application Development. In CCS, 2010.
[56] K. Zhang and X. Wang. Peeping Tom in the Neighborhood:
Keystroke Eavesdropping on Multi-User Systems. In USENIX
Security, 2009.
[57] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart. Cross-VM side
channels and their use to extract private keys. In CCS, 2012.
[58] Y. Zhang and M. K. Reiter. Düppel: Retroﬁtting commodity
HTTPOS: Sealing Information Leaks with Browser-side Obfuscation
of Encrypted Flows. In NDSS, 2011.
operating systems to mitigate cache side channels in the cloud. In
ACM CCS, 2013.
[33] C. Meyer, J. Somorovsky, E. Weiss, J. Schwenk, S. Schinzel, and
[59] Y. Zheng and X. Zhang. Path Sensitive Static Analysis of Web
E. Tews. Revisiting SSL/TLS Implementations: New Bleichenbacher
Side Channels and Attacks. In USENIX Security, 2014.
Applications for Remote Code Execution Vulnerability Detection. In
ICSE, 2013.
[34] B. Muller. Whitepaper: Improved DNS Spooﬁng Using Node
[60] X. Zhou, S. Demetriou, D. He, M. Naveed, X. Pan, X. Wang, C. A.
Re-delegation. https://www.sec-consult.com/
fxdata/seccons/prod/downloads/whitepaper
-dns-node-redelegation.pdf.
Gunter, and K. Nahrstedt. Identity, Location, Disease and More:
Inferring Your Secrets from Android Public Resources. In CCS,
2013.
400