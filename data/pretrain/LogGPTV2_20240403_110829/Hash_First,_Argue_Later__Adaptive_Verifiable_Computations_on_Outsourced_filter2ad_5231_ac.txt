pp = (k, EKpp, VKpp);
HashE (pp, x) computes σx ← hashk(x); Π ← VC.Prove(EKpp, σx ; x) and returns σ = (σx, Π).
Check(pp, σ) parses σ as (σx, Π) and returns VC.Verify(VKpp, σx, v, Π).
Theorem 3.3. If VC is knowledge-sound, then HPE is hash extractable (Deﬁnition 3.2).
The proof of Theorem 3.3 follows from the existence of the VC extractor.
By using a separate VC scheme on a new relation Rk, rather than re-using a VC scheme on one
of the relations R(cid:48), we can use knowledge soundness in a completely standard manner, taking only
the key k as ‘benign’ auxiliary input.
10
(cid:81)
form (x, cx) : cx =(cid:81)
i Fi
xi.
Discussion. The HPinn construction is simple, and can be extended to Merkle trees [16] to provide
logarithmic random access in data structures.
Its main practical drawback is that the relation
to be veriﬁed now includes a hash computation, which adds tens of thousands of cryptographic
operations to the prover’s workload for each block of input when using standard algorithms such
as SHA2 (Section 6). To lower this considerable cost for the prover, one pragmatically chooses
custom, algebraic hash functions, which in turn increases the cost for the veriﬁer that computes
the digest. In the following sections we present constructions that are eﬃcient for both the prover
and the veriﬁer.
4 Hash & Prove Constructions
In this section we present our main technical contribution: two eﬃcient multi-relation hash & prove
schemes for families of relations Rλ. We let R(x, v ; w) range over these relations.
Our two schemes are obtained via a generic hash & prove construction that relies on two main
building blocks: (i) any SNARK scheme that has oﬄine/online veriﬁcation algorithms (cf. Sec-
tion 2.1) and where the oﬄine veriﬁcation consists of a multi-exponentiation in a group G1; (ii)
any HP scheme that allows to prove the correctness of such multi-exponentiations.
i Fi
Before presenting our generic construction in full detail, we provide some intuition. We start
from the observation that in oﬄine/online SNARKs the veriﬁer already computes an element cx =
xi. Although cx can be seen as a hash of the input x, such hash is relation-speciﬁc because
the elements Fi depend on the relation R that was used in the SNARK’s KeyGen. Our main idea
is to outsource the computation of cx to the prover in order to obtain an HP scheme where x can
be hashed in a relation-independent manner. Then, we ask the prover to show the correctness of cx
using an HP scheme (where hashes are indeed relation-independent) that supports relations of the
Building an HP scheme from another HP scheme may look silly at ﬁrst, however the key point is
that we require an HP that supports a speciﬁc class of relations: only multi-exponentiations. Con-
versely, our method can be seen as a way to bootstrap, via SNARKs, an HP scheme that supports
one speciﬁc class of computations into another one that can support arbitrary computations.
Following the generic HP construction from a hash & prove scheme for multi-exponentiation,
we propose new constructions to instantiate the latter. The ﬁrst, called XP1, is publicly veriﬁable,
whereas the second one, called XP2, is in the designated veriﬁer model but enjoys better eﬃciency.
The two new schemes are signiﬁcantly more eﬃcient than what could be obtained using known
techniques (e.g., the construction based on inner encoding in Section 3.3).
As a result, the instantiation of our generic construction with state-of-the-art SNARKs and our
new HP for multi-exponentiation yields an HP system that, compared to the solution in Section 3.3,
is at least 1, 400× times faster for the prover and the key generator (cf. Section 6).
The rest of the section is organized as follows.
In Section 4.1 we describe the generic con-
struction; in Section 4.2 we give our publicly veriﬁable HP scheme for multi-exponentiation, and
in Section 4.3 we give the designated veriﬁer one. Finally, in Section 4.4 we outline additional
properties of our constructions, including data updates and extension of HP to accumulators.
4.1 Generic Hash & Prove Scheme (HPgen)
Let VC = (KeyGen, Prove, Verify) be a SNARG scheme that supports a sequence of relations {Rλ}λ
and that has oﬄine/online veriﬁcation, as described in Section 2.1: we assume that every veriﬁca-
xi
tion key VK of VC includes group elements F1, . . . , Fn ∈ G1 and that Oﬄine(VK, x) = (cid:81)n
i=1 Fi
computes a commitment cx.
11
Let XP = (Setup, Hash, KeyGen, Prove, Verify) be an HP scheme that supports relations F ⊂ U×∅
1 , and a pair
p × G1, every F ∈ F is deﬁned by a vector F = (F1, . . . , Fn) ∈ Gn
where u is Zn
(x, cx) ∈ Zn
p × G1 is in F iﬀ(cid:81)n
i=1 Fi
xi = cx.
We use XP and VC to construct a scheme HPgen that supports any combination of relations
R(x, v ; w) supported by VC. The only requirement is that both schemes have compatible (or
identical) public parameters. Namely, they share the same bilinear group setting, and the number
of inputs in x, n, should be the same as in XP.
HPgen is deﬁned as follows:
Setup(1λ) runs XP.Setup(1λ) and returns its public parameters pp.
Hash(pp, x) returns σx := XP.Hash(pp, x).
KeyGen(pp, R) takes a relation R and runs
EK, VK ← VC.KeyGen(1λ, R);
Let F := (F1, F2, . . . , Fn) be the ‘oﬄine’ elements in VK;
EKF , VKF ← XP.KeyGen(pp, F );
return EKR := (EK, VK, EKF ), VKR := (VK, VKF ).
Prove(EKR, x, v ; w) parses EKR as (EK, VK, EKF ) then runs
cx ← VC.Oﬄine(VK, x);
Π ← VC.Prove(EK, (x, v) ; w);
Φx ← XP.Prove(EKF , x, cx);
return ΠR := (cx, Π, Φx).
Verify(VKR, σx, v, ΠR) parses VKR as (VK, VKF ) and ΠR as (cx, Π, Φx), and returns
VC.Online(VK, cx, v, Π) ∧ XP.Verify(VKF , σx, cx, Φx).
Hence, proofs ΠR in HPgen carry three representations of x: its portable hash σx; its oﬄine relation-
speciﬁc commitment cx; and a multi-exponentiation proof Φx that binds the two. Compared with
VC proofs, and using our instantiations of XP described later in this section, the communication
overhead for HPgen proofs is two group elements (or three if we want hash extractability).
The following theorem states the security of HPgen.
Theorem 4.1. If XP is adaptively sound in the publicly veriﬁable (resp. designated veriﬁer) setting,
and VC is sound, then the HPgen construction in Section 4.1 is adaptively sound in the publicly
veriﬁable (resp. designated veriﬁer) setting.
The full proof appears in Appendix D.3.
The idea is rather simple: any adversary which breaks HPgen has to either break the security
of the underlying VC scheme, or cheat on the value of cx, thus breaking the security of XP. Our
proof shows a reduction for each case.
We also give a corollary that essentially says that, by instantiating our generic construction
with a hash extractable XP scheme, we can handle arguments with untrusted hashes. It follows by
construction of HPgen, observing that this scheme uses the hashing algorithm of XP.
Corollary 4.1. If XP is hash extractable, then the HPgen construction in Section 4.1 is also hash
extractable.
12
xi.
i∈[1,n] Hi
Setup(1λ) samples Hi
Hash(pp, (x1, . . . , xn)) returns σx ←(cid:81)
Prove(EKF , (x1, . . . , xn), cx) computes Tx ←(cid:81)
(Implicitly we require that cx =(cid:81)
(Tx, Rx).
in the computation of the proof.)
$←− G1
p and computes U ← g2
KeyGen(pp, F ) samples u, v, w $←− Z∗
w for i ∈ [1, n]; and returns EKF = (F, T, R) and VKF =
vFi
and computes Ti ← Hi
(U, V, W ) where R = (R1, . . . , Rn) and T = (T1, . . . , Tn).
v, W ← g2
u, V ← g2
w; samples Ri
uRi
xi and Rx ←(cid:81)
i∈[1,n] Ti
i∈[1,n] Ri
xi; and returns Φx =
4.2 Our Publicly Veriﬁable HP Scheme for Multi-Exponentiation (XP1)
We present our second key technical contribution: a hash & prove scheme, called XP1, for the class
of multi-exponentiation relations F described above.
For clarity, we write Φ instead of Π for restricted proofs.
$←− G1 for i ∈ [1, n] and returns pp = (Gλ, H) where H = (H1, . . . , Hn).
i∈[1,n] Fi
xi, though the cx part of the instance is not used
Verify(VKF , σx, cx, Φx) parses Φx = (Tx, Rx) and returns
e(Tx, g2) ?= e(σx, U ) e(Rx, V ) e(cx, W ).
The following theorem states that XP1 scheme is secure. Correctness follows by inspection.
Theorem 4.2 (Adaptive Soundness of XP1). If the Strong External DDH Assumption holds, then
the XP1 scheme above is adaptively sound (Deﬁnition 3.1 for multiple relations).
Proof Outline. The proof works by considering the case of a single relation as the extension to
multiple relations is obtained by applying Theorem 3.1.
Below we provide the outline of the security proof via a sequence of game hops.
Game 0: this is the adaptive soundness game of Deﬁnition 3.1 restricted to a single relation.
Game 1: this is a modiﬁcation of Game 0 as follows. When answering the (single) KEYGEN(F )
$←− Zp (instead of sampling
oracle query, the challenger sets w = γv + δ for random γ, δ
w $←− Zp). Next, when the adversary returns the proof (x∗, c∗, Φ∗), with Φ∗ = (T ∗, R∗), the
x∗
i . Then, if (T ∗/ ˆT )(ˆc/c∗)δ = 1 the
challenger computes ˆT ←(cid:81)
i and ˆc ←(cid:81)
x∗
i∈[1,n] Ti
i∈[1,n] Fi
outcome of the game is changed so that the adversary does not win.
We claim that Game 0 and Game 1 are statistically indistinguishable. The intuition is that
δ is information theoretically hidden from the adversary, which implies that the only event
which changes the game’s outcome happens with negligible probability.
Game 2: this is a modiﬁcation of Game 1 as follows. When answering the (single) KEYGEN(F )
oracle query, the challenger sets u = αv + β for random α, β $←− Zp (instead of sampling
u $←− Zp). Second, the challenger computes Ri ← H−α
i F
This game is essentially changing the distribution of the evaluation keys returned to the
adversary. The distribution in this game however is computationally indistinguishable from
the one in Game 1 under the Strong External DDH (SXDH) assumption. Finally, once
accounted for this game diﬀerence it is possible to show that any p.p.t. adversary has negligible
probability of winning in Game 2, under the Flexible co-CDH assumption (which in turn
reduces to SXDH).
and Ti ← H β
i F δ
i .
−γ
i
13
Detailed proofs for the indistinguishability of the three games as well as a reduction from winning
in Game 2 to breaking Flexible co-CDH are in Appendix D.4.
We can make the XP1 construction hash extractable by adding a knowledge component. The re-
sulting scheme, XPE , consists of algorithms KeyGen and Prove from XP1 together with the following
additional algorithms.
SetupE (1λ,F) samples Hi
$←− G1 for i ∈ [1, n] and ω $←− Zp and returns pp = (Gλ, gω
2 ,{Hi,
i }i∈[1,n]).
H ω
HashE (pp, (x1, . . . xn)) computes Ax ← (cid:81)
xi and Bx ← (cid:81)
i∈[1,n] Hi
i∈[1,n](Hi
ω)xi. Returns σx =
(Ax, Bx).
Check(pp, σx) takes g2 and gω
VerifyE (VKF , σx, cx, Φx) returns Check(pp, σx) ?= 1
∧ e(Tx, g2) ?= e(Ax, U ) e(Rx, V ) e(cx, W ).
2 from pp; parses σx as (Ax, Bx); and checks that e(Ax, gω
2 ) ?= e(Bx, g2).
Lemma 4.1 (Hash Extractability of XPE ). If the Bilinear n-Knowledge of Exponent Assumption
holds, then the XPE scheme above is hash extractable.
Proof. The existence of an extractor for the Bilinear n-Knowledge of Exponent Assumption implies
the existence of an extractor for the XPE construction.
4.3 Our Designated Veriﬁer HP Scheme for Multi-Exponentiation (XP2)
We present another hash & prove scheme for multi-exponentiation, called XP2, which works in the
designated veriﬁer setting. XP2 is similar to XP1 but requires one less element in the proof and one
less multi-exponentiation for the prover.
The XP2 scheme works for the same class of relations F supported by XP1, and the construction
is obtained by adapting a multi-function veriﬁable computation scheme by Fiore and Gennaro [23],
which works for a similar restricted class of functions, (f1, . . . , fn) ∈ Zn
p . In Appendix C we deﬁne
XP2 more generically based on homomorphic weak pseudorandom functions [23]. For simplicity,
we describe below the instantiation of the scheme based on the SXDH assumption.
$←− G1 for i ∈ [1, n] and returns pp = (Gλ, H) where H = (H1, . . . , Hn).
p; computes Ti ← Fi
k for i ∈ [1, n]; and returns EKF =
δHi
xi; and returns Φx. (Implicitly we require
xi, though the cx part of the instance is not used in the computation of
i∈[1,n] Ti
i∈[1,n] Fi
The scheme XP2 works as follows:
Setup(1λ) samples Hi
Hash(pp, (x1, . . . , xn)) returns σx ←(cid:81)
Prove(EKF , (x1, . . . , xn), cx) computes Φx ←(cid:81)
KeyGen(pp, F ) generates δ, k $←− Z∗
(F, T ), VKF = (δ, k) where T = (T1, . . . , Tn).
i∈[1,n] Hi
xi.
that cx =(cid:81)
the proof.)
Verify(VKF , σx, cx, Φx) returns Φx
?= cx