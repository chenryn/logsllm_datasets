搭建IP子网时，如何划分子网与主机数是最重要的问题之一。子网所占位取决于整个网络中的物理子网数，每一子网中的主机数不能超过子网划分所允许的最大数量。
**IP子网掩码，表示法以及子网计算:**
在没有子网的网络环境下，路由器通过IP地址的前八位来决定是哪一类型的网络，从而它们知道哪些是网络ID哪些是主机ID。划分子网时，路由器也需要知道主机ID是如何划分成子网ID与主机ID的，但是划分方法可以是任意组合，也没有办法从IP地址看出来。因此，必须有额外的信息告知解析IP地址的设备，这一信息称为子网掩码，以32比特数的形式呈现。
掩码位的1和0结合布尔函数与和或的功能对于地址中的比特位进行选择或清除。子网掩码中的32位对应于IP地址相同位置上的数字。掩码位为1时，则地址中该位作为网络ID或子网ID，而掩码位为0时，则地址中该位表示主机ID。
**子网掩码为1**：将IP地址中的0或1与1进行与操作，即：当子网掩码位为1，IP地址保持不变。
**子网掩码为0**：任何数和0做与操作都是0，即：当子网掩码位为0，IP地址清零。
因此，将子网掩码应用于IP地址，网络ID和子网ID保持不变，移除主机ID。执行此功能的路由器由此获得子网地址，因为它知道网络类型，因此能够区分网络位与子网地址位。
举例来说，假设将B类网络154.71.0.0划分5位为子网ID，11位为主机ID。因此，子网掩码有16个1代表网络部分（B类网络），接下来5个1作为子网部分，11个0用作主机ID。二进制数表示为11111111
11111111 **11111**000 00000000，十进制数表示为255.255.248.0。
[![image003.jpg](1c9f5e5b.jpg){.calibre9}](https://community.emc.com/servlet/JiveServlet/showImage/2-838932-95195/image003.jpg){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
**举例：**
假设有一台主机IP地址154.71.150.42，路由器需要找出该主机位于哪一子网，则它的掩码操作如下图所示：
[![image004.png](eaa05d1f.png){.calibre9}](https://community.emc.com/servlet/JiveServlet/showImage/2-838932-95196/image004.png){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
[![image005.jpg](72b16f56.jpg){.calibre9}](https://community.emc.com/servlet/JiveServlet/showImage/2-838932-95197/image005.jpg){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
结果，154.71.150.42所属的子网为154.71.144.0。另一台路由器能够从中区分出网络ID与子网ID，因为地址的前两个比特位是10，是一个B类网络。所以网络ID占16位，子网ID一定是17至21。这里，子网是10010，或子网18。
提一个问题：既然子网掩码只是将网络地址划分出网络部分与子网部分，那为什么还要使用另外的32位比特数255.255.248.0，而不直接将IP地址第21位指定为分界线呢？这是有历史原因的：因为需要考虑不连续的掩码情况。同时，它也能够让路由器进行快速的掩码操作来找出子网地址。
除了将16位划分为5位子网ID与11位主机ID，标准也允许前2位用作子网ID，4位用作主机ID，之后3位用作子网ID，7位用作主机ID。因此子网掩码为11000011
10000000。当然，这会造成混淆，是不推荐的，实际中也没有人会这么做。
鉴于非连续掩码实际不会应用，以及现今的计算机速度大幅提升，新的表达法为154.71.150.42/21。
**IP子网掩码设定:**
假设B类网络154.71.0.0，没有子网的话一共有65,534台主机。划分子网时，按照以下方法：
-   1位用作子网ID，15位用作主机ID：那幺子网数为2\^1，第一个子网是0，第二个子网是1。每一个子网的主机数是2\^15-2，或32，766。
-   2位用作子网ID，14位用作主机ID：那幺子网数为2\^2，四个子网0，1，2，3。每一个子网的主机数是2\^14-2，或16，382。
子网与主机ID位的划分取决于子网数与子网中最大主机数。假设一个B类网络中有10个子网，需要4位表示子网（2\^4=16，2\^3=8），12位用作主机ID，每一子网最多4，094台主机。
如果你有20个子网，每一子网3，000台主机，那么就会碰到问题。需要5位表示20个子网，而3，000台主机需要12位。这时需要重新组织物理网络，如果无法做到，就需要第二个B类网络。
自定义子网掩码的方法是：从指定网络类型的默认子网掩码中，从最左边的0位开始，按照需要的子网数将0改为1。假设C类网络200.13.94.0，最后8位可供划分子网与主机，则有6种不同的划分方法。假如使用3位作为子网ID，5位作为主机ID，那么：
默认C类网络子网掩码：11111111 11111111 11111111 00000000
将最左边的3位0改为1：11111111 11111111 11111111 **111**00000
即子网掩码为：255.255.255.224。
通常情况下，所有子网大小必须相同。因此，最大一个子网的主机数决定了需要多少位比特用作主机ID。因此前例中，前19个子网每个子网最多100台主机，而第20个子网需要3000个主机，就会碰到问题。这种情况下，需要将最后一个过大的子网拆成若干个小的子网。
[![image006.jpg](6385a170.jpg){.calibre9}](https://community.emc.com/servlet/JiveServlet/showImage/2-838932-95198/image006.jpg){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
:::
:::
[]{#7.html}
::: page
# 网络基本功（八）：细说TCP滑动窗口 {#7.html#calibre_toc_9 .book-chapter}
::: {#7.html#section- .section}
# 网络基本功（八）：细说TCP滑动窗口 {#7.html#网络基本功（八）：细说tcp滑动窗口 .calibre4}
**转载请在文首保留原文出处：EMC中文支持论坛**[https://community.emc.com/go/chinese](https://community.emc.com/go/chinese){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
[![image001.gif](a09e83f1.gif){.calibre9}](http://service.weibo.com/share/share.php?title=%23ECN%e4%b8%ad%e6%96%87%e6%94%af%e6%8c%81%e8%ae%ba%e5%9d%9b%23%20%e7%bd%91%e7%bb%9c%e5%9f%ba%e6%9c%ac%e5%8a%9f%ef%bc%88%e5%85%ab%ef%bc%89%ef%bc%9a%e7%bb%86%e8%af%b4TCP%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%20@EMC%e6%98%93%e5%ae%89%e4%bf%a1%e4%b8%ad%e5%9b%bd%e6%8a%80%e6%9c%af%e7%a4%be%e5%8c%ba&url=%20https://community.emc.com/message/840427#840427){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
## 介绍 {#7.html#介绍 .calibre10}
将TCP与UDP这样的简单传输协议区分开来的是它传输数据的质量。TCP对于发送数据进行跟踪，这种数据管理需要协议有以下两大关键功能：
**可靠性**：保证数据确实到达目的地。如果未到达，能够发现并重传。
**数据流控**：管理数据的发送速率，以使接收设备不致于过载。
要完成这些任务，整个协议操作是围绕**滑动窗口确认机制**来进行的。因此，理解了滑动窗口，也就是理解了TCP。
## 更多信息 {#7.html#更多信息 .calibre10}
**TCP面向流的滑动窗口确认机制:**
TCP将独立的字节数据当作流来处理。一次发送一个字节并接收一次确认显然是不可行的。即使重叠传输（即不等待确认就发送下一个数据），速度也还是会非常缓慢。
[![image002.jpg](662c593c.jpg){.calibre9}](https://community.emc.com/servlet/JiveServlet/showImage/2-840427-95924/image002.jpg){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
TCP消息确认机制如上图所示，首先，每一条消息都有一个识别编号，每一条消息都能够被独立地确认，因此同一时刻可以发送多条信息。设备B定期发送给A一条发送限制参数，制约设备A一次能发送的消息最大数量。设备B可以对该参数进行调整，以控制设备A的数据流。
为了提高速度，TCP并没有按照字节单个发送而是将数据流划分为片段。片段内所有字节都是一起发送和接收的，因此也是一起确认的。确认机制没有采用message
ID字段，而是使用的片段内最后一个字节的sequence
number。因此一次可以处理不同的字节数，这一数量即为片段内的sequence
number。
**TCP数据流的概念划分类别**
假设A和B之间新建立了一条TCP连接。设备A需要传送一长串数据流，但设备B无法一次全部接收，所以它限制设备A每次发送分段指定数量的字节数，直到分段中已发送的字节数得到确认。之后，设备A可以继续发送更多字节。每一个设备都对发送，接收及确认数据进行追踪。
如果我们在任一时间点对于这一过程做一个"快照"，那么我们可以将TCP
buffer中的数据分为以下四类，并把它们看作一个时间轴：
**1.** **已发送已确认**
数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。如下图所示，31个字节已经发送并确认。
**2.** **已发送但尚未确认**
已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。下图所示14字节为第2类。
**3.** **未发送而接收方已Ready**
设备尚未将数据发出，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。如图，第3类有6字节。
**4.** **未发送而接收方Not Ready** 由于接收方not
ready，还不允许将这部分数据发出。
[![image003.jpg](55937b82.jpg){.calibre9}](https://community.emc.com/servlet/JiveServlet/showImage/2-840427-95961/image003.jpg){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
接收方采用类似的机制来区分已接收并已确认，尚未接受但准备好接收，以及尚未接收并尚未准备好接收的数据。实际上，收发双方各自维护一套独立的变量，来监控发送和接收的数据流落在哪一类。
**Sequence Number设定与同步：**
发送方和接收方必须就它们将要为数据流中的字节指定的sequence
number达成一致。这一过程称为同步，在TCP连接建立时完成。为了简化假设第一个字节sequence
number是1，按照上图示例，四类字节如下：
1\. 已发送已确认字节1至31。
2\. 已发送但尚未确认字节32至45。
3\. 未发送而接收方已Ready字节46至51。
4\. 未发送而接收方Not Ready字节52至95。
**发送窗口与可用窗口：**
整个过程关键的操作在于接收方允许发送方一次能容纳的未确认的字节数。这称为发送窗口，有时也称为窗口。该窗口决定了发送方允许传送的字节数，也是2类和3类的字节数之和。因此，最后两类（接收方准备好而尚未发送，接收方未准备好）的分界线在于添加了从第一个未确认字节开始的窗口。本例中，第一个未确认字节是32，整个窗口大小是20。
可用窗口的定义是：考虑到正在传输的数据量，发送方仍被允许发送的数据量。实际上等于第3类的大小。左边界就是窗口中的第一个字节（字节32），右边界是窗口中最后一个字节（字节51）。概念的详细解释看下图。
[![image004.jpg](9bd28249.jpg){.calibre9}](https://community.emc.com/servlet/JiveServlet/showImage/2-840427-95962/image004.jpg){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
**可用窗口字节发送后TCP类目与窗口大小的改变：**
当上图中第三类的6字节立即发送之后，这6字节从第3类转移到第2类。字节变为如下：
1\. 已发送已确认字节1至31。
2\. 已发送但尚未确认字节32至51。
3\. 未发送而接收方已Ready字节为0。
4\. 未发送而接收方Not Ready字节52至95。
[![image005.jpg](3bbd4a8f.jpg){.calibre9}](https://community.emc.com/servlet/JiveServlet/showImage/2-840427-95963/image005.jpg){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
**确认处理以及窗口缩放：**
过了一段时间，目标设备向发送方传回确认信息。目标设备不会特别列出它已经确认的字节，因为这会导致效率低下。**目标设备会发送自上一次成功接收后的最长字节数**。
例如，假设已发送未确认字节（32至45）分为4段传输：32-34，35-36，37-41，42-45。第1，2，4已经到达，而3段没有收到。接收方只会发回32-36的确认信息。接收方会保留42-45但不会确认，因为这会表示接收方已经收到了37-41。这是很必要的，因为TCP的确认机制是累计的，只使用一个数字来确认数据。这一数字是自上一次成功接收后的最长字节数。假设目标设备同样将窗口设为20字节。
当发送设备接收到确认信息，则会将一部分第2类字节转移到第1类，因为它们已经得到了确认。由于5个字节已被确认，窗口大小没有改变，允许发送方多发5个字节。结果，窗口向右滑动5个字节。同时5个字节从第二类移动到第1类，5个字节从第4类移动至第3类，为接下来的传输创建了新的可用窗口。因此，在接收到确认信息以后，看起来如下图所示。字节变为如下：
1\. 已发送已确认字节1至36。
2\. 已发送但尚未确认字节37至51。
3\. 未发送而接收方已Ready字节为52至56。
4\. 未发送而接收方Not Ready字节57至95。
[![image006.jpg](19d09a9f.jpg){.calibre9}](https://community.emc.com/servlet/JiveServlet/showImage/2-840427-95964/image006.jpg){.pcalibre2
.pcalibre .calibre7 .pcalibre1 target="_blank"}
每一次确认接收以后，这一过程都会发生，从而让窗口滑动过整个数据流以供传输。
**处理丢失确认信息：**
但是丢失的42-45如何处理呢？在接收到第3段（37-41）之前，接收设备不会发送确认信息，也不会发送这一段之后字节的确认信息。发送设备可以将新的字节添加到第3类之后，即52-56。发送设备之后会停止发送，窗口停留在37-41。