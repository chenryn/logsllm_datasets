现在，我们使用DOS/Windows的FC程序来比较两个存档文件的差别：
.,> FC /b 2200save.1.v1 2200SAVE.1.V2
Comparing fi1es 2200save.1.v1 arid 2200SAVE.1.V2
00000016: 0D 04
00000017: 03 04
10146: 27 38
01C:
1F 1E
0000
OBDA:
: 0E 16
100
BDC
BDE:
0E 16
66
99
BE0: 0E 16
0888: 99 E8
BE7 :
0001
0BEC: A1 F3
000
BEE:
BFB:
E8
AB28
C7
8FD: 98 18
0000
BFF: A8 28
00000C07: DB 58
000
C01: A8 28
00000C09: E4 A4
89 83 130000000
88C100000000
上述内容是比对结果的部分内容。两个文件的不同之处还有很多，但是其余内容不如这些信息那样富
有代表性。
在第一次存盘时，我持有14个单位的hydrogcn和102个单位的oxygcn.在第二次存盘时，相应的持
有量变为22和155个单位。如果程序把这两个值存储在存档文件中，那么我们应当可以在存档里找到它。
实际情况正是如此。在存档文件的0xBDA处，第一个存档文件的值为0x0E（14），在第二个存档文件的值
为0x16（22）。地址0xBDA 存储的应当是hygrogen的量。然后，在文件的0xBDC处，两个值分别为 0x66
（102）和0x9B（155）。地址0xBDC存储的应当是oxygen的值。
您可以自己把玩一下这个游戏，分析存档文件的具体格式，您还可以下载我用的游戏存档：
http://beginners.re/examples/millenium_DOS_game/。
使用Hiew打开第二次存档的存档文件，可以看到有关矿石的持有量。如图85.3所示。
Hiew2200save.v2
C:\tmp12220save.1.v2
00 83102-00000000-0090091-008600080
BERO..
00 00 F3 00-C7 00 00 00-00 00 00 00-000000 00
L2
00000A:
00000SFA:
)a)aed)
1 B8-98 68 88
Ph
EX
e 088
图85.3Hiew：状态1
这个值无疑是16位数值：在DOS时代的16位软件程序里，imt型数据就是16位数据，这并不意外。
验证一下我们的推测是否正确。把这个地址的值（hydrogen）改为1234（0x4D2），如图85.4所示。
Hiw:2200save.L2
C:\tnp12209save.l.v2
0093100-00000000-0090091-0096020
EFWO_EDITMOOE
00000
BOX
D0BEA:
08DA:
00 00F300-C70000 00-0000 0000-00 0000 00
ef
00000BFA:
EX
Pn
00000000-000008°63-20600000-00006060
图 85.4Hiew;把数值修改为 1234(0x04D2)
---
## Page 357
第85章Millenium游戏的存格文件
833
然后打开游戏、加载存档中的进度，看看矿产持有量，如图85.5所示。
INSTALLATION:MoOn
RESOURCE
NERIAL
an
D口En
LHm
以上信息表明，我们的推测是正确的。
为了快速通关，我们把所有矿产的持有量都改成最大值，如图85.6所示
EFF
FF FF-FF
00 03 88 88-90 680080-83882080-83 00 00 80
10 28 78 18-10 28 10 28-03
84-08eaee
EXAA
DA:
88 80 00
P
图85.6Hiew：把各项都修改为最大值
0xFFFF是65535。改动之后，我们就是资源大亨了，如图85.7所示。
INSTALLATIONEMoON
MATERIBL
KD4
GEn
On
TER
BHHE
ILICS
图85.7所有资源都变为65535
---
## Page 358
834
逆向工程权威指南（下册)
在进行了儿个游戏日的奋斗之后—哎？部分资源变少了。如图85.8所示。
INSTALLATIONiMoON
RESOURCE
MATERIAL
HOOLS
KB4
28
an
SULPHOR
TLTMnnUUm
SILICA
655
528
邮 85.8 Reseurce variables overflow
这就发生了数值溢出。游戏开发人员可能没有想到玩家会持有这么多的矿产，所以未做溢出检测。但
是挖矿就会增加矿产，超过数据最大值之后、数据溢出了。这样看来，要是我当初没那么贪心就好了，或
许吧。
这款游戏的存档文件里还有很多数值，本文不再一一分析。
这属于一种简单的游戏作整方法。只要玩家略微改动一下存档文件，他们就可以获得很高的游戏分值。
本书63.4节详细介绍了各种文件及内存快照的比较方法。
---
## Page 359
第86章
Oracle的.SYM文件
在程序前溃的时候，Oracle RDBMS会把大量信息写到日志文件（log）里。日志文件会记录数据栈的
使用情况，如下所示。
***- Cal1 Stack Trace -*
calling
ca11
entry
arqument values in bex
Locat1on
type
po1nt
(? means dubious valve)
_kqvrow()
00000000
_oplfch2() +2729
CALLptr
00000000
EB1C8A8 1
2304B914 E47F264 1F19AE2
_kpoa18 () +2832
CALLre1
_op1fch2()
89 5 E810C74
_oplodr () +1248
CALLreg
CALLreg
00000000
5E 1C EB1F0A0
_ttcpip()▪1051
00000000
58 1C EB1F0A0 0
_opitsk () +1404
CALL???
00000000
E81F1CC 53852E 0 EB1F1F8
C96C040 5E 8B1P0A0 0 281E030
_oplLino () +980
CALLre1
()x$do
CALLreg
00
oplodr () +1248
00000000
3C 4 EB1FBF4
102+.21do
CALLre1
_opiodr()
3C 4 EB1FBF4 0
SS+ ()ognoe"
CALLrel
_opidrv()
3C 4 EB1F9F4
_opinai_real () +124
CALLre1
_sou2o ()
EB1FC04 3C 4 E81rBF4
_oplna1 () +125
OracleThreadStart8
CALLre1
_opisal_rea1()
2 EB1FC2C
CALLre1
_oplnal ()
2 EB1FF6C 7C8BA774 EB1FC34 0
4()+830
CALLreg
E41FF9C 0 0 E41rr9C 0 E81PFC4
EB1FD04
00000000
PT8+93LL
CALL???
00000000
00000000
既然是编译器生成的程序，那么Oracle的可执行程序里必定会有调试信息、带有符号（symbol）信息
的映射文件、或者是相似的信息。
在Windows NT版的OracleRDBMS 中，其可执行文件里存在着与.SYM文件有关的符号信息。可情，
官方不会公开.SYM文件的文件格式。固然Oracle可以使用纯文本文件，但是如此一来还要对其进行多次
转换，性能必然大打折扣。
我们从最短的文件orawtc8.sym入手，试者分析这种格式的文件。Omacle 8.1.7的动态库文件orawc8.dll之中，
存在着这个.SYM文件的符号信息，对于oracle数据库的程序来说，版本越旧、功能模块的文件就越小。
使用Hiew打开上述文件，可以看到如图 86.1所示的界面。
图86.1使用Hiew打开整个文件
---
## Page 360
836
逆向工程权威指南（下册）
参照其他.SYM文件，可知这种格式的文件头（及文件尼部）都有OSYM字样。据此判断，这个字符
串可能是某种文件签名。
大体来说，这种文件的格式是“OSYM+某些二进制数据+以0做结束符的字符串+OSYM”。很明显。
这些文件中的字符串应当是函数名和全局变量名。
如图86.2所示，字符串OSYM的位置较为同定
 86.2 OSYM signuture and txt string
接下来，我把这个文件中的整个字符串部分（不包含尾部的OSYM签名字符串）复制了出来，并单独
存储为一个文件 strings_block。然后使用UNIX 的 strings 和 wc 工具统计它字符串的数量：
steings atrings_block I wc -1
6
可见它包含66个文本字符串。我们先把这个数字记下来。
通常来说，无论它是字符串、还是其他什么类型的数据，数据的总数往往会出现在二进制文件的其他
部分。这次的分析过程再次印证了这个规律，我们可以在文件的开始部分、OSYM之后看到66（0x42）：
|..*.**8xSO101 00 OT 08 0T 00 Ot 0000 00 00 Z> P> 6S ES 3# 0000000
s hexdunp -C oravtc8.sym
00000010  f0 10 00 10 50 11 00 10
0T00 CIOL0T 0O TTOP0Z000000
60 11 00 10 c0 11 00 10
40 15 00 10 50 15 00 10
I...-P- --
00000030 60 15 00 10 80 15 00 10 a0 15 00 10 a6 15 00 10 1'.**s
..............
+ + 
当然，0x42不是一个byte型数据，很可能是个以小编字节序存储的32位数据。正因如此，0x42之后
排列着3个以上的零字节。
判断它是32位数据的依据是什么？OracleRDBMS的符号文件可能非常大。以版本号为10.2.0.4的
Oracle主程序为例，它的oracle.sym包含有0x3A38E（即238478）个符号。16位的数据类型不足以表达这
个数字。
分析过其他.SYM文件之后，我更加确定了上述猜测：在32位的OSYM签名之后的数据，就是反映
文本字符串数量的数据。
这也是多数二进制文件的常规格式：文件头通常包含程序签名和文件中的某种信息。
接下来，我们分析一下文件中的二进制部分。我把文件中第8字节（字符串计数器之后）到字符串之
间的内容存储为另外一个文件（binary_block）。然后再使用Hiew打开这个新文件，如图86.3所示。
这个文件的模式逐渐清晰了起来。为了便于理解，我在图中添加了儿条分割线，如图86.4所示。
---
## Page 361
第86章Oracle的.SYM文件
837
[ 86.3Binary block
邯 86.4Binary block
多数的hex编辑器每行都显示16个字节，Hiew也不例外。所以，在Hiew的窗口里，每行信息对应
着4个32位数据。
文件中的数据凸显了它的这种特征：在地址0x104之前的数据都是0x1000xx形式的数据（请注意小
端字节序），数据都以0x10、0x00字节开头：以0x108开始的数据，都是0x0000xxx型的数据，都以两个
零字节开头。
我们把这些数据整理为32位的数组，代码如下所示，
指令清单86.1第一列是地址
$ od -v -t x4 binary_block
OSTT000T 0701000T 080T000T 000T000T0000000
0000020 10001160 100011c0 100011d0 10001370
000060 100015a0 100015a6 100015ac 100015b2
0009040 10001540 10001550 10001560 10001580
OS10001510001905100010950001000000
0099120 100015d0 100015e0 100016b0 10001760
9T8T000T 0t8T000T Q9C1000T 0PLt000T 09T0000
000014010001766 1000176c
10001780100017bG
---
## Page 362
838
逆向工程权威指南（下册）
0000240 10002020 10002024 10002028 1000202c
000000000920000
000030010002040
10002034 10002038 1000203c
10002044
10002048 1000204c
0000340 1000210c 10002120 10003000 10003004
0000360 10003008
0000400 100030a0
1000399c
10003098
1000309c
0000420 000000120
100030a4
00000000
00000 S2000000
0000460 0000005a
00006040
064
8F000000
0000006e
00000051
0000500 00000088(
99000000 $e000000 96050000
174
99000000 0250000
000000c0 000000d2 000000e2
0000560 00000121
0000012a
00000107
0TT00000
00000132
00000116
0000600 00000146 0
0000640 000001fb
69100000 0290000
000001e1
epT00000
0000021b
00000led
000070000000287
0000660 00000234
02000009020000006000000
D000024e
22200000 69200000
29200000 0Z.0000
0000740 0000033e
D0000210
PSE00000
TZE0O000 P0E000D0
0000037a 00000395
0000760 000003ae 000003b6 000003be 000003c6
0001000 000003ce 000003dc 000003e9 000003f8
0001020
这里有132个值，是66×2的阵列。字符串的总量正好是66。那么，到底是每个字符串符号对应了2
个32位数据，还是说这2个32位数据完全就是两个互不相干数组呢？我们继续分析。
以0x1000开头的值可能是某种地址。毕竞SYM文件是为.DLL文件服务的，而且Win32DLL文件的
默认基址是0x10000000，代码的起始地址通常是0x10001000。
使用IDA工具打开orawtc8.dl文件，可以看到它的基址不是默认地址。尽管如此，我们可以看到它的
第一个函数的对应代码为：
-text:60351000 sub_60351000
-text : 60351000
proc near
-text:60351000 arg_0
= dvord ptr 8
text : 60351000
text : 60351000
arg_4
UDT2nd pzoxp =
= dvord ptr
OCh
0001S009:3x81*
TOOTSC09:3X93*
text : 60351000
push
ebp
BoV
mov
ebp, esp
text: 60351003
eax,
dvord_60353014
text : 60351008
text:6035100B
op
Jnz
short 1oc_6035104F
eax, OFFFFFFFFh
text:60351000
x01
mov
ecx, hModu1e
-text:60351015
cmp
oax, 9ax
ecx, crrrrrs
-text: 60351010
text : 60351018
jnz
AOu
dvord_60353014, eax
short 1oc_60351031
-text: 6035101F
cal1
sub_603510F0
-text: 60351024
mov
eax, dvord,60353014
ecx, eax
-text: 60351028
mov
.text: 60351031
mov
hModsle, ecx
-text:60351031 1oc_60351031:
 C00E XRET: aub_60351000+1D
.text: 60351031
test
.text:60351033
jbe
eCx, ecx
.text: 60351035
push
offset Pzocame : "ax_reg*
-text: 6035103A
push
text:6035103B
cal1
ds:GetProcAddress
ecx
;bModule
整，我们好像见过字符串“ax_reg”！它不就是在.SYM文件的字符中区里的第一个字符串嘛！可见，
---
## Page 363
第86章Oracle的.SYM文件
839
这个函数的名字应该就是“ax_reg”。
上述DLL文件的第二个函数是：
-text:60351080 sub_60351080
-text: 60351080
proc near
-text:60351080 arg_4
-text:60351080 arg_.0
834d p3oxp =
-text:60351080
"0031d p3oxp -
-text : 60351080