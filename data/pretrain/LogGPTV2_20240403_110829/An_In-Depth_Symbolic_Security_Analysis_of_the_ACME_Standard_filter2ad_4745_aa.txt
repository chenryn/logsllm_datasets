title:An In-Depth Symbolic Security Analysis of the ACME Standard
author:Karthikeyan Bhargavan and
Abhishek Bichhawat and
Quoc Huy Do and
Pedram Hosseyni and
Ralf K&quot;usters and
Guido Schmitz and
Tim W&quot;urtele
An In-Depth Symbolic Security Analysis of the ACME Standard
Karthikeyan Bhargavan
PI:EMAIL
INRIA
Paris, France
Abhishek Bichhawat
PI:EMAIL
IIT Gandhinagar
Gandhinagar, Gujarat, India
Quoc Huy Do∗
PI:EMAIL
University of Stuttgart
Stuttgart, Germany
Guido Schmitz†
University of Stuttgart
Stuttgart, Germany
Pedram Hosseyni
pedram.hosseyni@sec.uni-
stuttgart.de
University of Stuttgart
Stuttgart, Germany
Ralf Küsters
University of Stuttgart
Stuttgart, Germany
PI:EMAIL
PI:EMAIL
Tim Würtele
PI:EMAIL
University of Stuttgart
Stuttgart, Germany
ABSTRACT
The ACME certificate issuance and management protocol, standard-
ized as IETF RFC 8555, is an essential element of the web public key
infrastructure (PKI). It has been used by Let’s Encrypt and other
certification authorities to issue over a billion certificates, and a
majority of HTTPS connections are now secured with certificates
issued through ACME. Despite its importance, however, the secu-
rity of ACME has not been studied at the same level of depth as
other protocol standards like TLS 1.3 or OAuth. Prior formal analy-
ses of ACME only considered the cryptographic core of early draft
versions of ACME, ignoring many security-critical low-level details
that play a major role in the 100 page RFC, such as recursive data
structures, long-running sessions with asynchronous sub-protocols,
and the issuance for certificates that cover multiple domains.
We present the first in-depth formal security analysis of the
ACME standard. Our model of ACME is executable and comprehen-
sive, with a level of detail that lets our ACME client interoperate
with other ACME servers. We prove the security of this model using
a recent symbolic protocol analysis framework called DY★, which
in turn is based on the F★ programming language. Our analysis
accounts for all prior attacks on ACME in the literature, includ-
ing both cryptographic attacks and low-level attacks on stateful
protocol execution. To analyze ACME, we extend DY★ with authen-
ticated channels, key substitution attacks, and a concrete execution
framework, which are of independent interest. Our security analy-
sis of ACME totaling over 16,000 lines of code is one of the largest
∗Also with GLIWA GmbH.
†Also with Royal Holloway University of London.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea.
© 2021 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3484588
proof developments for a cryptographic protocol standard in the
literature, and it serves to provide formal security assurances for a
crucial component of web security.
CCS CONCEPTS
• Security and privacy → Formal security models; Security
protocols; Web protocol security; Digital signatures; Formal secu-
rity models; Logic and verification; Security protocols; Web
protocol security; • Networks → Protocol testing and ver-
ification; Protocol testing and verification; Formal specifi-
cations; • Theory of computation → Cryptographic protocols;
Cryptographic protocols.
KEYWORDS
formal protocol analysis and verification; public-key-infrastructure;
certificate issuance
ACM Reference Format:
Karthikeyan Bhargavan, Abhishek Bichhawat, Quoc Huy Do, Pedram Hoss-
eyni, Ralf Küsters, Guido Schmitz, and Tim Würtele. 2021. An In-Depth
Symbolic Security Analysis of the ACME Standard. In Proceedings of the
2021 ACM SIGSAC Conference on Computer and Communications Security
(CCS ’21), November 15–19, 2021, Virtual Event, Republic of Korea. ACM, New
York, NY, USA, 17 pages. https://doi.org/10.1145/3460120.3484588
1 INTRODUCTION
The management of certificates for web servers used to be a very
tedious and manual task. To relieve administrators from this burden,
the Internet Security Research Group (ISRG) developed the Automatic
Certificate Management Environment (ACME), which provides a
protocol to automate the process of domain ownership verification
and certificate issuance. ACME was standardized by the Internet
Engineering Task Force (IETF) as RFC 8555 [5] and is now supported
by a wide range of certification authorities (CAs) (e.g., [21, 25, 33, 43,
57]) and many different web server tools (see [41] for a detailed list).
In particular, Let’s Encrypt [43], launched by the ISRG in 2015, was
the first CA to implement ACME and has provided its service to all
users for free (see also their CCS paper on the history of ACME [1]).
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2601By now, Let’s Encrypt and ACME have become extremely popular
and are widely used and trusted, with more than 1 billion certificates
issued so far by Let’s Encrypt alone [40], accounting for about 57%
of certificates in active use on the web [1].
Since ACME is so widely used, a design flaw in ACME can have
disastrous consequences. For example, a critical cryptographic flaw
in an early draft of ACME [2] allowed an adversary to obtain cer-
tificates for domains not owned by the adversary (see Section 5
for details). This flaw was fixed in the published standard, but to
ensure no such protocol flaws remain, it is important to formally
verify the security of the ACME standard.
Formally Analyzing ACME. Two prior works analyzed early
drafts of the ACME protocol using the symbolic protocol analyzers
ProVerif and Tamarin [15, 36]. These analyses were able to automat-
ically identify protocol weaknesses in early ACME drafts and verify
their fixes. However, they only considered the core cryptographic
mechanisms in the basic certificate issuance message flow for a
single domain, resulting in high-level models of a few hundred lines
that leave out many of the details of the 100-page ACME standard.
ACME relies on recursive control flows, unbounded data struc-
tures, and careful state management for long-running sessions
that involve multiple asynchronous sub-protocols. For example, an
ACME client can ask the ACME server for a certificate that covers
a list of domains. The server has to iteratively go through this list
and for each domain therein create a URL, which is an individual
endpoint the client later has to connect to. For each such URL, client
and server then asynchronously run a subprotocol consisting of
several further message rounds in order to verify that the client
owns the domain. In particular, the runs of these different subproto-
cols can interleave arbitrarily. When the ownership of all domains
has been validated, the client can finally ask the server to issue a
new certificate for the domain list and a given public key.
This complex set of interactions raises many open security ques-
tions that remained unanswered by prior formal analyses. For ex-
ample, can an attacker participate in a series of asynchronous sub-
protocols with an ACME server and drive the server into a state
where it would be willing to issue the attacker a certificate covering
a domain that it does not own? Such questions have practical, real-
world consequences. Recently, a severe flaw in the ACME server
implementation Boulder (used, e.g., by Let’s Encrypt) was discov-
ered. This flaw was rooted in the incorrect processing of domain
lists and allowed an attacker to obtain certificates for domains it
does not own. As a consequence of this flaw, Let’s Encrypt had to
revoke more than 3 million certificates [35].
The goal of this work is to carry out an in-depth security analysis
of the ACME standard that accounts for all these low-level protocol
details, so that we can formally prove that an ACME implementation
that faithfully follows the standard has strong security guarantees.
A Detailed Executable ACME Model in F★. Writing a detailed
formal model for a large protocol standard like ACME is a chal-
lenging task. The protocol uses flexible message formats like JSON,
unbounded data structures like domain lists, recursive control flows,
and mutable session states, all of which are challenging (and some-
times impossible) to handle for automated symbolic provers like
ProVerif and Tamarin. Furthermore, as the model grows to encom-
pass the entire standard, it can be difficult to check that the model
itself is correct. For example, the model of TLS 1.3 in Tamarin [22]
was over 2,000 lines, even though it did not cover some key protocol
features like message formats and ciphersuite negotiation. For a
model of this size, it is important to be able to execute and test it
for specification errors, and to ensure that all the corner cases of
the protocol are correctly exercised.
Hence, we write a detailed model of the ACME protocol in the F★
programming language [53] which takes care of all the mentioned
details. The full model is over 5,500 lines of F★ and can be tested to
generate symbolic traces for debugging. Given the level of detail
in our model, it can be seen as a reference implementation of the
ACME standard. Indeed, we show how our verified ACME client
can be concretely executed to interoperate with real-world ACME
servers, including those run by Let’s Encrypt.
Symbolic Security Proofs for ACME in DY★. To formally prove
security properties for our ACME model, we rely on a recent verifi-
cation framework called DY★ [11], a new approach for the symbolic
security analysis of protocol code written in the F★ programming
language [53]. DY★ is the latest in a line of works that uses depen-
dent types to verify cryptographic protocols [3, 6, 8, 16–18, 32, 53].
The key difference with these prior works is that DY★ explicitly
encodes the global run-time semantics of distributed protocol exe-
cutions in terms of a global trace, and the symbolic security analysis
is proved sound with respect to this semantics within the verifica-
tion framework itself. Using the global trace, it becomes possible
to explicitly model protocol state, random number generation, and
fine-grained compromise in a sound way without relying on exter-
nal pen-and-paper proofs. This, in turn, allows for the verification
of sophisticated security properties like forward secrecy and post-
compromise security for cryptographic protocols like Signal [11].
Unlike automated symbolic provers like ProVerif or Tamarin that
analyze abstract protocol models, the aim of DY★ is to help pro-
grammers write and formally verify executable code that accounts
for both the high-level design and the low-level implementation
details of a cryptographic protocol and the application code that
uses it. In particular, DY★ supports the verification of recursive
and stateful protocols with unbounded data structures like lists
and trees, which are typically hard to reason about with automated
provers that lack general induction. Conversely, unlike automated
provers, proofs in DY★ require manual annotation. For example,
our 5,500 line ACME model requires a further 5,200 lines of proof,
whereas the Tamarin and ProVerif analyses for 100-300 line models
of small subsets of ACME are mostly automatic. However, the level
of proof effort in our work is commensurate with other in-depth
protocol analyses. For example, the mentioned 2,000 line TLS 1.3
model in Tamarin [22] required about 1,000 lines of lemmas, even
for a high-level protocol model.
Importantly, the type-based methodology of DY★ is modular
and scales better than the whole-protocol analysis of automated
provers. The verification of large protocols like TLS 1.3 in Tamarin
and ProVerif can take tens of hours or even days of verification
time, whereas in DY★, each module can be implemented and ver-
ified separately. For ACME we have 37 modules with an average
verification time of about 1.5 minutes per module, totaling about
60 (single-core) minutes on a standard desktop.
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2602DY★’s approach to enable such modularity is based on a com-
bination of local and global reasoning: predicates on the global
trace capture the inter-dependencies between different states and
different components of the protocol while local invariants ensure
that every component preserves these predicates. In our analy-
sis, we state and mechanically verify the local invariants for each
component, and then we prove that these local invariants, when
combined with predicates on the global trace, yield the desired pro-
tocol security goals. Hence, our proof includes the composition of
the protocol with every component, and if there were a composition
flaw, the overall proof would fail.
Extensions to DY★. In principle, DY★ is a suitable framework
for the in-depth analysis of a large protocol standard like ACME.
However, being a very recent analysis framework, DY★ still has to
demonstrate what it is really capable of. So far, DY★ has not been
used for such a large analysis, and we still needed to extend the
DY★ approach in three ways to model and verify ACME.
First, DY★ assumes a standard symbolic equational theory for
signatures, but as illustrated by an attack on an early draft of ACME
presented in [2], many signature schemes are vulnerable to so-
called key substitution attacks in which the adversary crafts a new
verification key for a new message and the given signature. We
therefore extend the model of signatures in DY★ to account for such
attacks (see Section 3.2) and use the resulting weaker assumptions
on signatures when verifying our model of ACME.
Second, the domain authentication sub-protocol in ACME relies
on a trusted channel between the domain owner and the ACME
server. For example, the domain owner is expected to write a file to
a web server that only she has access to, and we assume that the
ACME server can securely read this file. A natural way to model
such communication is via an authenticated channel, which is not
currently supported by DY★. We extend the communication model
of DY★ to include an authenticated channel for each principal that
only the principal can write to but anyone can read. This extension
is completely generic, and hence, of independent interest.
Third, DY★ has not been used to create interoperable imple-
mentations so far. We propose a novel approach to transform a
DY★ model into a concrete implementation that can successfully
run protocol roles with real-world counterparts, and we use this
methodology to test interoperability between our ACME client and
other ACME servers.
Contributions. We present the first comprehensive formal model
of the ACME standard (Section 6). Our 5,500 line model of ACME
is written in the F★ programming language and is executable. We
illustrate its level of detail by demonstrating that our client code
is, in fact, interoperable with real-world ACME servers, including
Let’s Encrypt (Section 8). We present symbolic security theorems of
this model using the DY★ framework: in particular, we prove that
certificates are only issued to the rightful owner of the domains
included in the certificate and that the overall protocol flow pro-
vides integrity guarantees to clients and servers (Section 7). Our
proofs rely on novel extensions to the DY★ framework that are of
independent interest (Section 3). Our full proof development totals