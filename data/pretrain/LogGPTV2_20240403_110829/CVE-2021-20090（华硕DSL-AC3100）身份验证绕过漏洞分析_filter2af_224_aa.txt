# CVE-2021-20090（华硕DSL-AC3100）身份验证绕过漏洞分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x01 前言
最近Tenable 披露了Arcadyna 网络设备身份验证绕过漏洞，并且很多的厂商都采用产生漏洞的组件，由于Arcadyan
设备固件厂商并没有开源出来，在官网支持里面下载的文件是window和linux
下和设备连接的客户端软件，无法对漏洞点开展分析，这里我们使用同样受影响的华硕产品DSL-AC3100
的固件来进行设备分析。并且复现在网络设备中网络检测ping 功能的远程命令执行漏洞，从而开启设备telentd。
## 0x02 华硕DSL-AC3100 固件
我们从华硕的官网中下载固件。  
设备名称： DSL-AC3100  
固件版本： DSL-AC3100_v1.10.05_build503
## 0x03 身份验证绕过漏洞分析
###  提取固件包
从华硕的官网下载到固件包DSL-AC3100_v1.10.05_build503.w ，这是一个是用.w 为后缀的固件文件，使用binwalk
可以提取出来。根据漏洞信息，可以确定这是一个在http服务中存在的漏洞，可以确定到httpd 文件，本固件的httpd 文件在
/usr/sbin/httpd 中。
###  httpd 二进制文件分析
在ghidra 导入httpd 文件，自动对文件进行分析，识别文件的各种函数。
由于漏洞是身份认证绕过漏洞，因此首先要确定设备的身份验证相关的函数有哪些，在ghidra对httpd文件中的字符串进行搜寻，根据字符串
“check_auth” ，定位到函数 FUN_0001d0c0()，
    undefined4 FUN_0001d0c0(int iParm1)
    {
      int iVar1;
      undefined4 uVar2;
      int iVar3;
      undefined4 local_52c;
      undefined4 local_528;
      undefined4 local_524;
      undefined4 uStack1312;
      undefined4 local_51c;
      char acStack1304 [1024];
      char acStack280 [260];
      memset(acStack280,0,0x100);
      memset(acStack1304,0,0x400);
      local_52c = 0;
      local_528 = 0;
      local_524 = 0;
      uStack1312 = 0;
      local_51c = 0;
      iVar1 = FUN_00017df0();
      if (iVar1 == -1) {
        uVar2 = 1;
      }
      else {
        iVar3 = mapi_ccfg_match_str(iVar1,"ARC_SYS_LogEnable",&DAT_00046b48);
        iVar1 = mapi_ccfg_match_str(iVar1,"ARC_SYS_MPTEST",&DAT_00046b48);
        if (iVar1 == 0) {
          if (iVar3 != 0) {
            iVar3 = 1;
          }
          if (iVar3 != 0) {
            FUN_00017738(iParm1 + 0x76f0,&local_52c);
          }
          if (*(int *)(iParm1 + 0x774c) == 0) {
            uVar2 = FUN_0001b6f4(iParm1 + 0x771e,*(undefined4 *)(iParm1 + 0x76ec));
            FUN_0001b8c8(iParm1,uVar2);
          }
          iVar1 = FUN_0001ce8c(*(undefined4 *)(iParm1 + 0x774c),*(undefined4 *)(iParm1 + 0x76b0),
                               *(undefined4 *)(iParm1 + 0x76b4),*(undefined4 *)(iParm1 + 0x76b8),
                               *(undefined4 *)(iParm1 + 0x76bc),*(undefined4 *)(iParm1 + 0x76c0),
                               *(undefined4 *)(iParm1 + 0x76c4),*(undefined4 *)(iParm1 + 0x76c8),
                               *(undefined4 *)(iParm1 + 0x7b34));
          if (iVar1 == 1) {
            printf("[%s] %s login time out, reauth\n","check_auth",iParm1 + 0x76f0);
            FUN_00039088(1);
            snprintf(acStack1304,0x400,"Location: /relogin.htm\n\n");
          }
          else {
            if (iVar1 == 2) {
              printf("[%s] new user %s(%s) comes to login, check user and auth\n","check_auth",
                     iParm1 + 0x76f0,iParm1 + 0x4c);
              snprintf(acStack1304,0x400,"Location: /relogin.htm\n\n");
            }
            else {
              if (iVar1 == 0) {
                printf("[%s] %s has already granted, pass\n","check_auth",iParm1 + 0x76f0);
                return 0;
              }
            }
          }
          if (iVar3 != 0) {
            snprintf(acStack280,0x100,"User from %s(%s) authentication fail.",&local_52c,iParm1 +0x76f0
                    );
            append_to_file("/tmp/security_log.txt",acStack280);
          }
          FUN_00015338(iParm1,acStack1304);
          uVar2 = 1;
        }
        else {
          uVar2 = 0;
        }
      }
      return uVar2;
    }
根据函数代码的一些细节，可以看出这个函数检查认认证是否符合的功能函数，其中FUN_0001ce8c 函数的返回值iVar1，在函数中 iVar1 的值为2
时，说明是新用户登录，需要检查用户名和验证。iVar1 的值为 0 的时候，则显示验证通过。iVar1 的值为 1
的时候，则表示说明验证超时，并且重新返回到登录界面。
接下来，查看FUN_0001d0c0() 函数在FUN_0001d578() 中被引用。而FUN_0001d0c0()
函数就是漏洞的evaluate_access() 函数。
    // evaluate_access()
    undefined4 FUN_0001d578(undefined4 uParm1,undefined4 uParm2,int iParm3)
    {
      int iVar1;
      undefined4 uVar2;
      if (iParm3 == 0) {
        return 0;
      }
      iVar1 = FUN_0001d2e0(iParm3);
      if (iVar1 != 0) {
        if (*(int *)(iParm3 + 0x76a8) != 0) {
          return 0;
        }
        uVar2 = FUN_0001d0c0(iParm3); 
        return uVar2;
      }
      FUN_00014510(iParm3,0x193,"Unauthorized.");
      return 1;
    }
FUN_0001d578() 函数中的 FUN_0001d2e0()
是使用正则表达式来校验URL中的IP，端口是否符合规范。以及FUN_0001d0c0() 函数也在其中，因此这个函数是httpd
中来做身份验证的函数，也就是漏洞分析中的evaluate_access()。
接下来我们来查看调用evaluate_access()
函数的地方，真正的漏洞点在这个函数，我们来看漏洞点是如何绕过身份验证的。我们来到了FUN_00015058函数，这就是process_request
的函数。
    void FUN_00015058(int iParm1)
    {
      undefined4 uVar1;
      char *pcVar2;
      char *__src;
      int iVar3;
      char *__dest;
      iVar3 = iParm1 + 0xd5;
      uVar1 = FUN_00016a84(iVar3,0xd);
      *(undefined4 *)(iParm1 + 0x27f0) = uVar1;
      *(undefined4 *)(iParm1 + 0x76a4) = 0xffffffff;
      *(undefined4 *)(iParm1 + 0x76ac) = 0xffffffff;
      __src = (char *)FUN_00016a84(iVar3,0x20);
      *(int *)(iParm1 + 0x7b18) = iVar3;
      pcVar2 = (char *)FUN_00016a84(__src,0x20);
      uVar1 = FUN_00016a84(__src,0x3f);
      *(undefined4 *)(iParm1 + 0x7b14) = uVar1;
      __dest = (char *)(iParm1 + 0x7994);
      strncpy(__dest,__src,0xff);
      *(undefined *)(iParm1 + 0x7a93) = 0;
      FUN_00016e3c(__dest);
      printf("[%s] url=[%s], args=[%s], method=[%s]\n","process_request",__dest,
             *(undefined4 *)(iParm1 + 0x7b14),*(undefined4 *)(iParm1 + 0x7b18));