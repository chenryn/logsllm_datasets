* 出于性能原因，TCP 不会为收到的每个数据包生成新的确认。它等待的时间非常短：如果有更多的数据段到达，则可以通过单个 ACK 数据包确认其接收。这称为 “累积确认”   cumulative ACK 。
* 往返时间并不恒定。这是有多种因素造成的。例如，客户端可能是一部移动电话，随其移动而切换到不同的基站。也可能是当链路或 CPU 的利用率提高时，数据包交换花费了更长的时间。
* 必须重新发送的数据包在计算过程中必须被忽略。这是因为发送方无法判断重传数据段的 ACK 是在确认原来的传输数据（毕竟已到达）还是在确认重传数据。
最后一点很重要：当 TCP 忙于从丢失中恢复时，它可能仅接收到重传段的 ACK。这样，它就无法在此恢复阶段测量（更新）RTT。所以，它无法调整重传超时，然后超时将以指数级增长。那是一种非常具体的情况（它假设其他机制，如快速重传或 SACK 不起作用）。但是，使用 TCP 时间戳，即使在这种情况下也会进行 RTT 评估。
如果使用了扩展，则对等方将从 TCP 段的扩展空间中读取时间戳值并将其存储在本地。然后，它将该值作为 “回显时间戳” 放入发回的所有数据段中。
因此，该选项带有两个时间戳：它的发送方自己的时间戳和它从对等方收到的最新时间戳。原始发送方使用 “回显时间戳” 来计算 RTT。它是当前时间戳时钟与 “回显时间戳” 中所反映的值之间的增量。
**时间戳的其他用途**
TCP 时间戳甚至还有除 PAWS（ 防止序列号回绕   Protection Against Wrapped Sequences ） 和 RTT 测量以外的其他用途。例如，可以检测是否不需要重发。如果该确认携带较旧的回显时间戳，则该确认针对的是初始数据包，而不是重新发送的数据包。
TCP 时间戳的另一个更晦涩的用例与 TCP [syn cookie](https://en.wikipedia.org/wiki/SYN_cookies) 功能有关。
**在服务器端建立 TCP 连接**
当连接请求到达的速度快于服务器应用程序可以接受新的传入连接的速度时，连接积压最终将达到其极限。这可能是由于系统配置错误或应用程序中的错误引起的。当一个或多个客户端发送连接请求而不对 “SYN ACK” 响应做出反应时，也会发生这种情况。这将用不完整的连接填充连接队列。这些条目需要几秒钟才会超时。这被称为 “同步泛洪攻击”   syn flood attack 。
**TCP 时间戳和 TCP Syn Cookie**
即使队列已满，某些 TCP 协议栈也允许继续接受新连接。发生这种情况时，Linux 内核将在系统日志中打印一条突出的消息：
> 
> 端口 P 上可能发生 SYN 泛洪。正在发送 Cookie。检查 SNMP 计数器。
> 
> 
> 
此机制将完全绕过连接队列。通常存储在连接队列中的信息被编码到 SYN/ACK 响应 TCP 序列号中。当 ACK 返回时，可以根据序列号重建队列条目。
序列号只有有限的空间来存储信息。因此，使用 “TCP Syn Cookie” 机制建立的连接不能支持 TCP 选项。
但是，对两个对等点都通用的 TCP 选项可以存储在时间戳中。ACK 数据包在回显时间戳字段中反映了该值，这也允许恢复已达成共识的 TCP 选项。否则，cookie 连接受标准的 64KB 接收窗口限制。
**常见误区 —— 时间戳不利于性能**
不幸的是，一些指南建议禁用 TCP 时间戳，以减少内核访问时间戳时钟来获取当前时间所需的次数。这是不正确的。如前所述，RTT 估算是 TCP 的必要部分。因此，内核在接收/发送数据包时总是采用微秒级的时间戳。
在包处理步骤的其余部分中，Linux 会重用 RTT 估算所需的时钟时间戳。这还避免了将时间戳添加到传出 TCP 数据包的额外时钟访问。
整个时间戳选项在每个数据包中仅需要 10 个字节的 TCP 选项空间，这不会显著减少可用于数据包有效负载的空间。
**常见误区 —— 时间戳是个安全问题**
一些安全审计工具和（较旧的）博客文章建议禁用 TCP 时间戳，因为据称它们泄露了系统正常运行时间：这样一来，便可以估算系统/内核的补丁级别。这在过去是正确的：时间戳时钟基于不断增加的值，该值在每次系统引导时都以固定值开始。时间戳值可以估计机器已经运行了多长时间（正常运行时间 `uptime`）。
从 Linux 4.12 开始，TCP 时间戳不再显示正常运行时间。发送的所有时间戳值都使用对等设备特定的偏移量。时间戳值也每 49 天回绕一次。
换句话说，从地址 “A” 出发，或者终到地址 “A” 的连接看到的时间戳与到远程地址 “B” 的连接看到的时间戳不同。
运行 `sysctl net.ipv4.tcp_timeamp=2` 以禁用随机化偏移。这使得分析由诸如 `wireshark` 或 `tcpdump` 之类的工具记录的数据包跟踪变得更容易 —— 从主机发送的数据包在其 TCP 选项时间戳中都具有相同的时钟基准。因此，对于正常操作，默认设置应保持不变。
### 选择性确认
如果同一数据窗口中的多个数据包丢失了，TCP 将会出现问题。这是因为 TCP 确认是累积的，但仅适用于按顺序到达的数据包。例如：
* 发送方发送段 s\_1、s\_2、s\_3、... s\_n
* 发送方收到 s\_2 的 ACK
* 这意味着 s\_1 和 s\_2 都已收到，并且发送方不再需要保留这些段。
* s\_3 是否应该重新发送？ s\_4 呢？ s\_n？
发送方等待 “重传超时” 或 “重复 ACK” 以使 s\_2 到达。如果发生重传超时或到达了 s\_2 的多个重复 ACK，则发送方再次发送 s\_3。
如果发送方收到对 s\_n 的确认，则 s\_3 是唯一丢失的数据包。这是理想的情况。仅发送单个丢失的数据包。
如果发送方收到的确认段小于 s\_n，例如 s\_4，则意味着丢失了多个数据包。发送方也需要重传下一个数据段。
**重传策略**
可能只是重复相同的序列：重新发送下一个数据包，直到接收方指示它已处理了直至 s\_n 的所有数据包为止。这种方法的问题在于，它需要一个 RTT，直到发送方知道接下来必须重新发送的数据包为止。尽管这种策略可以避免不必要的重传，但要等到 TCP 重新发送整个数据窗口后，它可能要花几秒钟甚至更长的时间。
另一种方法是一次重新发送几个数据包。当丢失了几个数据包时，此方法可使 TCP 恢复更快。在上面的示例中，TCP 重新发送了 s\_3、s\_4、s\_5、...，但是只能确保已丢失 s\_3。
从延迟的角度来看，这两种策略都不是最佳的。如果只有一个数据包需要重新发送，第一种策略是快速的，但是当多个数据包丢失时，它花费的时间太长。
即使必须重新发送多个数据包，第二个也是快速的，但是以浪费带宽为代价。此外，这样的 TCP 发送方在进行不必要的重传时可能已经发送了新数据。
通过可用信息，TCP 无法知道丢失了哪些数据包。这就是 TCP [选择性确认](https://www.rfc-editor.org/info/rfc2018)（SACK）的用武之地了。就像窗口缩放和时间戳一样，它是另一个可选的但非常有用的 TCP 特性。
**SACK 选项**
```
   TCP Sack-Permitted Option: Kind: 4, Length 2
   +---------+---------+
   | Kind=4  | Length=2|
   +---------+---------+
```
支持此扩展的发送方在连接请求中包括 “允许 SACK” 选项。如果两个端点都支持该扩展，则检测到数据流中丢失数据包的对等方可以将此信息通知发送方。
```
   TCP SACK Option: Kind: 5, Length: Variable
                     +--------+--------+
                     | Kind=5 | Length |
   +--------+--------+--------+--------+
   |      Left Edge of 1st Block       |
   +--------+--------+--------+--------+
   |      Right Edge of 1st Block      |
   +--------+--------+--------+--------+
   |                                   |
   /            . . .                  /
   |                                   |
   +--------+--------+--------+--------+
   |      Left Edge of nth Block       |
   +--------+--------+--------+--------+
   |      Right Edge of nth Block      |
   +--------+--------+--------+--------+
```
接收方遇到 s\_2 后跟 s\_5 ... s\_n，则在发送对 s\_2 的确认时将包括一个 SACK 块：
```
                +--------+-------+
                | Kind=5 |   10  |
+--------+------+--------+-------+
| Left edge: s_5                 |
+--------+--------+-------+------+
| Right edge: s_n                |
+--------+-------+-------+-------+
```
这告诉发送方到 s\_2 的段都是按顺序到达的，但也让发送方知道段 s\_5 至 s\_n 也已收到。然后，发送方可以重新发送那两个数据包（s\_3、s\_4），并继续发送新数据。
**神话般的无损网络**
从理论上讲，如果连接不会丢包，那么 SACK 就没有任何优势。或者连接具有如此低的延迟，甚至等待一个完整的 RTT 都无关紧要。
在实践中，无损行为几乎是不可能保证的。即使网络及其所有交换机和路由器具有足够的带宽和缓冲区空间，数据包仍然可能丢失：
* 主机操作系统可能面临内存压力并丢弃数据包。请记住，一台主机可能同时处理数万个数据包流。
* CPU 可能无法足够快地消耗掉来自网络接口的传入数据包。这会导致网络适配器本身中的数据包丢失。
* 如果 TCP 时间戳不可用，即使一个非常小的 RTT 的连接也可能在丢失恢复期间暂时停止。
使用 SACK 不会增加 TCP 数据包的大小，除非连接遇到数据包丢失。因此，几乎没有理由禁用此功能。几乎所有的 TCP 协议栈都支持 SACK —— 它通常只在不进行 TCP 批量数据传输的低功耗 IOT 类的设备上才不存在。
当 Linux 系统接受来自此类设备的连接时，TCP 会自动为受影响的连接禁用 SACK。
### 总结
本文中研究的三个 TCP 扩展都与 TCP 性能有关，最好都保留其默认设置：启用。
TCP 握手可确保仅使用双方都可以理解的扩展，因此，永远不需因为对等方可能不支持而全局禁用该扩展。
关闭这些扩展会导致严重的性能损失，尤其是 TCP 窗口缩放和 SACK。可以禁用 TCP 时间戳而不会立即造成不利影响，但是现在没有令人信服的理由这样做了。启用它们还可以支持 TCP 选项，即使在 SYN cookie 生效时也是如此。
---
via: 
作者：[Florian Westphal](https://fedoramagazine.org/author/strlen/) 选题：[lujun9972](https://github.com/lujun9972) 译者：[gxlct008](https://github.com/gxlct008) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出