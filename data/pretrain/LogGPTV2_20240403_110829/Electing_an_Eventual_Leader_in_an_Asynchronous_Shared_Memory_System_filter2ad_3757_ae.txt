task T :
(13) when timeri expires:
(14)
(15)
(16.R1) progress ki (cid:2) PROGRESS (cid:5)k(cid:3) i(cid:6);
if (progress ki (cid:3) LAST (cid:5)k(cid:3) i(cid:6)) then
(17.R1)
(18)
(19.R1)
(20)
(21)
(22)
(23)
(24)
(25)
(26)
(27)
else if (k  candidatesi (cid:2) then
else if (stop k i) then
candidatesi (cid:2) candidatesi n fkg
end if
end for;
set timeri to max(cid:1)fSUSPICIONS (cid:5)i(cid:3) k(cid:6)g(cid:1)k(cid:1)n(cid:2)
SUSPICIONS (cid:5)i(cid:3) k(cid:6) (cid:2) SUSPICIONS (cid:5)i(cid:3) k(cid:6) (cid:9) ;
candidatesi
(cid:2) candidatesi n fkg
Figure 3. All variables are 1WMR and bounded
(code for pi)
The same reasoning as the one done in the proof
of
the Theorem 2 shows that each shared variable
SUSPICIONS(cid:6)j(cid:4) k(cid:7), (cid:3) j(cid:4) k (cid:3) n, is bounded. Com-
bined with the fact that the variables PROGRESS (cid:6)j(cid:4) k(cid:7) and
LAST (cid:6)j(cid:4) k(cid:7) are boolean, we obtain the following theorem.
Theorem 6 All the variables used in the algorithm de-
scribed in Figure 3 are bounded.
The following theorem is the counterpart of Theorem 3.
Theorem 7 Let p(cid:0) be the process elected as the eventual
common leader, and pi, i (cid:4) (cid:6), any correct process. There is
a time after which the only variables that may be written are
PROGRESS(cid:6)(cid:6)(cid:4) i(cid:7) (written by p(cid:0)) and LAST (cid:6)(cid:6)(cid:4) i(cid:7) (written
by pi).
Proof The proof that the variables PROGRESS (cid:6)(cid:6)(cid:4) j(cid:7),  (cid:3)
j (cid:3) n, are inﬁnitely often written, and the proof that there
The
is a time after which the variables STOP (cid:6)j(cid:7),  (cid:3) j (cid:3) n,
and the variables SUSPICIONS (cid:6)j(cid:4) k(cid:7),  (cid:3) j(cid:4) k (cid:3) n, are no
longer written is the same as the proof done in Theorem 3.
after which
PROGRESS (cid:6)x(cid:4) j(cid:7),  (cid:3) x(cid:4) j (cid:3) n, x (cid:4) (cid:6), are no
longer written follows from the fact that, after p(cid:0) has been
elected, no process px executes the body of the while loop
of task T .
there
time
that
fact
is
a
Let us now consider any variable LAST (cid:6)x(cid:4) y(cid:7), x (cid:4)
(cid:6). As, after p(cid:0) has been elected, no correct process px,
x (cid:4) (cid:6), updates PROGRESS (cid:6)x(cid:4) y(cid:7) (at line 08.R2),
it
follows that there is a time after which LAST (cid:6)x(cid:4) y(cid:7) (cid:4)
PROGRESS (cid:6)x(cid:4) y(cid:7) remains forever true for  (cid:3) x(cid:4) y (cid:3) n
and x (cid:4) (cid:6). Consequently, after a ﬁnite time, the test of line
17.R1 is always false for px, x (cid:4) (cid:6), and LAST (cid:6)x(cid:4) y(cid:7) is no
longer written.
T heorem 
Finally, the next theorem follows directly from Corollary 1.
Theorem 8 The (cid:0) algorithm described in Figure 3 is op-
timal with respect to the number of processes that have to
write the shared memory.
5 Conclusion
This paper has addressed the problem of electing an
eventual leader in an asynchronous shared memory system.
It has three main contributions.
(cid:1) The ﬁrst contribution is the statement of an assump-
tion (a property denoted AWB) that allows electing
a leader in the shared memory asynchronous systems
that satisfy that assumption. This assumption requires
that after some time (1) there is a process whose write
accesses to some shared variables are timely, and (2)
the other processes have asymptotically well-behaved
timers. The notion of asymptotically well-behaved
timer is weaker than the usual notion of timer where
the timer durations have to monotonically increase
when the values to which they are set increase. This
means that AWB is a particular weak assumption.
(cid:1) The second contribution is the design of two al-
gorithms that elect an eventual leader in any asyn-
chronous shared memory system that satisﬁes the as-
sumption AWB.
In addition of being independent
of t (the maximum number of processes allowed to
crash), and being based only on one-writer/multi-
readers atomic shared variables, these algorithms en-
joy noteworthy properties. The ﬁrst algorithm guaran-
tees that (1) there is a (ﬁnite) time after which a sin-
gle process writes forever the shared memory, and (2)
all but one shared variables have a bounded domain.
The second algorithm uses (1) a bounded memory but
(2) requires that each process forever writes the shared
memory.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:55 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007(cid:1) The third contribution shows that the previous trade-
off (bounded/unbounded memory vs number of pro-
cesses that have to write) is inherent to the leader elec-
tion problem in asynchronous shared memory systems
equipped with AWB. It follows that both algorithms
are optimal, the ﬁrst with respect to the number of
processes that have to forever write the shared mem-
ory, the second with respect to the boundedness of the
memory.
Several questions remain open. One concerns the ﬁrst al-
gorithm. Is it possible to design a leader algorithm in which
there is a time after which the eventual leader is not required
to read the shared memory? Another question is the fol-
lowing: is the second algorithm optimal with respect to the
size of the control information (bit arrays) it uses to have a
bounded memory implementation?
References
[1] Aguilera M.K., Delporte-Gallet C., Fauconnier H. and
Toueg S., Communication-Efﬁcient Leader Election and
Consensus with Limited Link Synchrony. Proc. 23th PODC
pp. 328-337, 2004.
[2] Boichat R., Dutta P., Frølund S. and Guerraoui R., Decon-
structing Paxos. ACM Sigact News, Distributed Computing
Column, 34(1):47-67, 2003.
[3] Chandra T. and Toueg S., unreliable Failure Detectors
for Resilient Distributed Systems. Journal of the ACM,
43(2):225-267, 1996.
[4] Chandra T., Hadzilacos V. and Toueg S., The Weakest Fail-
ure Detector for Solving Consensus. Journal of the ACM,
43(4):685-722, 1996.
[5] Dwork C., Lynch N. and Stockmeyer L., Consensus in
the Presence of Partial Synchrony. Journal of the ACM,
35(2):288-323, 1988.
[6] Fern´andez A., Jim´enez E. and Raynal M., Electing an Even-
tual Leader in an Asynchronous Shared Memory System.
Tech Report #1821, 18 pages, Universit´e de Rennes, France,
November 2006.
[7] Fischer M.J., Lynch N. and Paterson M.S., Impossibility of
Distributed Consensus with One Faulty Process. Journal of
the ACM, 32(2):374-382, 1985.
[8] Gafni E. and Lamport L., Disk Paxos. Distributed Comput-
ing, 16(1):1-20, 2003.
[9] Gibson G.A. et al., A Cost-effective High-bandwidth Stor-
age Architecture. Proc. 8th Int’l Conference on Architec-
tural Support for Programming Languages and Operating
Systems (ASPLOS’98), ACM Press, pp. 92-103, 1998.
[10] Guerraoui R., Kapalka M. and Kouznetsov P., The Weakest
failure Detectors to Boost Obstruction-Freedom. Proc. 20th
Symposium on Distributed Computing (DISC’06), Springer-
Verlag LNCS #4167, pp. 376-390, 2006.
[11] Guerraoui R. and Raynal M., The Information Structure
of Indulgent Consensus. IEEE Transactions on Computers,
53(4):453-466, 2004.
[12] Guerraoui R. and Raynal M., The Alpha of Asynchronous
Consensus. The Computer Journal, To appear, 2007.
[13] Guerraoui R. and Raynal M., A Leader Election Protocol
for Eventually Synchronous Shared Memory Systems. 4th
Int’l IEEE Workshop on Software Technologies for Future
Embedded and Ubiquitous Systems (SEUS’06), IEEE Com-
puter Society Press, pp. 75-80, 2006.
[14] H´elary J.-M., Hurﬁn M., Mostefaoui A., Raynal M. and
Tronel F., Computing Global Functions in Asynchronous
Distributed Systems with Perfect Failure Detectors. IEEE
TPDS, 11(9):897-909, 2000.
[15] Herlihy M.P., Luchangco V. and Moir M., Obstruction-
free Synchronization: Double-ended Queues as an Example.
Proc. 23th IEEE Int’l Conference on Distributed Computing
Systems (ICDCS’03), pp. 522-529, 2003.
[16] Herlihy M.P., Luchangco V., Moir M. and Scherer III W.N.,
Software Transactional Memory for Dynamic Sized Data
Structure. Proc. 21th ACM Symposium on Principles of Dis-
tributed Computing (PODC’03), pp. 92-101, 2003.
[17] Herlihy M.P. and Wing J.M, Linearizability: a Correctness
Condition for Concurrent Objects. ACM Transactions on
Progr. Languages and Systems, 12(3):463-492, 1990.
[18] Lamport L., The Part-Time Parliament. ACM Transactions
on Computer Systems, 16(2):133-169, 1998.
[19] Larrea M., Fern´andez A. and Ar´evalo S., Optimal Imple-
mentation of the Weakest Failure Detector for Solving Con-
sensus. Proc. 19th Symposium on Resilient Distributed Sys-
tems (SRDS’00), pp. 52-60, 2000.
[20] Lo W.-K. and Hadzilacos V., Using failure Detectors to solve
Consensus in Asynchronous Shared Memory Systems. Proc.
8th Int’l Workshop on Distributed Computing (WDAG’94),
Springer Verlag LNCS #857, pp. 280-295, 1994.
[21] Malkhi D., Oprea F. and Zhou L., (cid:8) Meets Paxos: Leader
Election and Stability without Eventual Timley Links. Proc.
19th Int’l Symposium on DIStributed Computing (DISC’05),
Springer Verlag LNCS #3724, pp. 199-213, 2005.
[22] Mostefaoui A., Mourgaya E., and Raynal M., Asynchronous
Implementation of Failure Detectors. Proc. Int’l IEEE Con-
ference on Dependable Systems and Networks (DSN’03),
IEEE Computer Society Press, pp. 351-360, 2003.
[23] Mostefaoui A. and Raynal M., Leader-Based Consensus.
Parallel Processing Letters, 11(1):95-107, 2001.
[24] Most´efaoui A., Raynal M. and Travers C., Crash Resilient
Time-Free Eventual Leadership. Proc. 23th IEEE Sympo-
sium on Reliable Dists. Systems, pp. 208-218, 2004.
[25] Most´efaoui A., Raynal M. and Travers C., Time-free and
Timeliness Assumptions can be Combined to Get Eventual
Leadership. IEEE Transactions on Parallel and Distributed
Systems, 17(7):656-666, 2006.
[26] Powell D., Failure Mode Assumptions and Assumption
Coverage. Proc. of the 22nd Int’l Symposium on Fault-
Tolerant Computing (FTCS-22), pp.386-395, 1992.
[27] Raynal M., A Short Introduction to Failure Detectors for
Asynchronous Distributed Systems. ACM SIGACT News,
Distributed Computing Column, 36(1):53-70, 2005.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:55 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007