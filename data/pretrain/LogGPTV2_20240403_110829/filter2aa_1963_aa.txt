Bluehat Shanghai 2019 |
David “dwizzzle” Weston |
Microsoft OS Security Group Manager
不断增强的 Windows 安全性
早上好 上海！
PC 上的 Windows
熟悉的桌面体验
庞大的硬件生态
桌面应用兼容性
One Core OS 
基础操作系统
应用和设备平台
运行时和框架
Xbox 上的 Windows
Windows 10 界面体验
独特的安全模型
共享的游戏体验
IoT 中的 Windows
基础操作系统
应用和设备平台
运行时和框架
还有更多地方……
适配不同形态设备
界面体验
支持不同设备场景
Windows 正在不断进化……
恶意代码无法在设备
上存留。
违反承诺的举措会被
立即发现。
所有应用和系统组件
仅具备必须的特权。
所有代码执行均可保
证完整性。
用户标识无法被攻陷、
嗅探或盗窃。
随意通过物理方式访
问的攻击者，无法修
改设备上的数据或代
码。
增强的安全性
Windows 10 S
10 S
统
2
1
强制代码签名
无需密码即可登录
“Admin Less”用户帐户
4
3
阻止来自互联网的脚本和宏
1
以管理员身份运行
2
执行不带签名的代码
3
使用密码
4
缓解措施并不总能生效
10 S：安装数上百万，尚未检测到广泛传播的恶意软件
所有代码执行均可保证完整性。
代码完整性的改进
CI 策略移除了大部分“代理的”二进制文件
仅提供带有应用商店签名的应用（UWP 或 Centennial）
支持危险操作的“远程”文件扩展已被阻止
远程 Office 宏默认已被阻止
Windows 10 S
所有二进制文件
带有微软签名的
代理的二进制文件
危险的句柄
远程的危险
文件
第一重代码完整性保护
“第一重”CI 绕过，使得远程攻击者能够触发未签名代
码的初始执行
10 S 侧重于防止“第一重”绕过
“第二重”绕过，使得在执行完初始代码 之后，可以进
一步执行更多未签名代码
10 S 为“第二重”绕过提供了持久的保证
Windows 10 S
Network
Physical Machine
Trigger 
Handler
No
Yes
10 S restricts “dual 
use” non-PE with 
cloud service
漏洞利用缓解策略
提高被利用的成
本
控制流完整性
仅限签名代码
只读数据
消除不同类型的漏洞
控制流面临的挑战
危险的调用目
标
不受保护的栈
数据流破坏
1
2
3
((void(*)(int, int)) funcptr)(0, 1);
obj->method1();
void function_A(int, int) { ... }
int function_B(int, int) { ... }
void function_C(Object*) { ... }
void Object::method1()
{ ... }
void Object::method1(int, int) { ... }
void Object::method2()
{ ... }
void Object2::method1()
{ ... }
调用站点
调用目标
CFG
Windows 中的第一代 CFI，出于兼容性和性能方面的考虑，粒度较大
使用“导出限制”减小特定进程（如 Microsoft Edge）中合法调用点的数量
改善控制流完整性
隆重介绍：XFG
目标：通过高效、兼容性高的方式提供更细化的 CFI
概念：通过类型签名检查保证合法的间接跳转
((void(*)(int, int)) funcptr)(0, 1);
obj->method1();
void function_A(int, int) { ... }
int function_B(int, int) { ... }
void function_C(Object*) { ... }
void Object::method1()
{ ... }
void Object::method1(int, int) { ... }
void Object::method2()
{ ... }
void Object2::method1()
{ ... }
调用站点
调用目标
改善控制流完整性
XFG 的设计：基础
为每个获取地址的函数分配一个基于类型签名的标志
对于 C 风格的函数，可能为：
hash(type(return_value), type(arg1), type(arg2), ...)
对于 C++ 虚拟方法，可能为：
hash(method_name, type(retval), highest_parent_with_method(type(this), method_name), type(arg1), type(arg2), ...)
在执行每个函数之前紧接着嵌入该标志，使其可通过函数指针访问
为调用点添加标志检查：如果遇到任何标签不匹配的情况则快速退出
改善控制流完整性
mov rax, [rsi+0x98]
; load target address 
call [__guard_dispatch_icall_fptr]
.align 0x10
function:
push rbp
push rbx
push rsi
...
mov rax, [rsi+0x98]
; load target address 
mov r10, 0xdeadbeefdeadbeef
; load function tag
call [__guard_dispatch_icall_fptr_xfg] ; will check tag
.align 0x10
dq 0xcccccccccccccccc ; just alignment
dq 0xdeadbeefdeadbeef ; function tag
function:
push rbp
push rbx
push rsi
...
CFG 指令：调用站点
xFG 指令：调用站点
目标
目标
XFG 的安全性
C 风格的函数指针只能调用具备相同类型签名的地址获取函数
调用点和调用目标具有相同数量的参数，参数与返回值类型相同
C++ 虚拟方法只能调用在自己的类层次结构中具备相同名称和类型的方法
无法调用错误类型的重载方法
无法调用来自其他类层次结构的方法
无法调用同一层次结构中类型相同但名称不同的方法
这已经不仅仅是近似 CFG，而是比它更强大
但是要注意：哈希函数的使用意味着技术上来看，有存在碰撞的可能，但对于大约 55 位哈希来说，可能性微乎其微（从实用性的角度来看尤其如此）
改善控制流完整性
控制流面临的挑战
危险的调用目
标
不受保护的栈
数据流破坏
1
2
3
影子栈保护
最初曾尝试以软件形式实现栈保护但失败了
OSR 以软件形式设计的影子栈（RFG）未能通过内部的攻击研究
控制流实施技术（CET）
可通过影子栈返回地址保护
通过硬件协助缓解控制流劫持和 ROP
在我们的威胁模型中体现出健壮性（在任意地址读写的前提下）
反向控制流
CET 影子栈流程：
函数调用时同时把返回地址压到两个栈里
Ret/ret_imm
同时弹出在两个栈上的返回地址
如果返回地址不匹配则抛出异常
无需为影子栈传递参数
Return EIPn-1
Param 1
Param 2
Return EIPn
Return EIPn-1
Return EIPn
调用前后对栈的使用
调用
后的
ESP
调用
后的
SSP
+0
+4
控制流面临的挑战
危险的调用目
标
不受保护的栈
数据流破坏
1
2
3
隆重介绍：内核数据保护
问题：对 Windows 内核的利用可通过损坏的数据
获得特权提升
目前状态：基于 Hypervisor 的代码完整性，可防
止动态代码注入并强制实施签名策略
仅仅阻止代码还不够，内核还包含了很多敏感数据
结构
内核数据保护（KDP）使用安全内核使敏感数据无
法被修改
数据损坏保护
CVE-2016-7256 利用：利用Open type 字体进行权限提升
破坏代码完整性相关的全局变量（来源：FuzzySec）
数据损坏保护
管理员
静态数据
动态数据
VBOX
Capcom
CPU-Z
攻击者进程
NTSTATUS MmProtectDriver (
_In_ PVOID 
AddressWithinSection,
_In_ ULONG Size,
_In_opt_ ULONG Flags);
内核数据保护：
用于执行只读池分配的机制
启用 VBS 后可获得只读页表项的 Hypervisor 保护