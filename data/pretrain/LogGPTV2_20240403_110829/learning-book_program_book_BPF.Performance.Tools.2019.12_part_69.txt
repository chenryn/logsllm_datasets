tool does it. eperm(8) uses a different technique: the kernel system call table (sys_call_table) is
convert this to a name, a lookup table of syscalls can be used, which is how the BCC syscount(8)
read, finding the function that handles the syscall and then it converts that function addres to
the kernel symbol name.
11.2.9 tcpconnect and tcpaccept
tcpconnect(8) and tcpaccept(8) were introduced in Chapter 10: they are BCC and bpftrace tools to
trace new TCP connections, and can be used to identify suspicious network activity. Many types
of attacks involve connecting to a system at least once. Example output from BCC tcpconnect(8):
 tepconnect
PID
COMM
IP SADDR
DACOR
DFORT
22411
a,out
10.0.0.1
B0B0
[..]
The tcpconnect(8) output shows an a.out process making a connection to 10.0.0.1 port 8080,
which sounds suspicious. (a.out is a default filename from some compilers and is not normally
used by any installed software.)
---
## Page 543
909
Chapter 11 Security
 tepaccept -t
71M(s)
PID
COMM
IP RADDR
LACOR
LFORT
0.000
1440
sshd
4
10.10.1.201
10.43.1.178
22
0,201
1440
pqas
410.10.1.201
10, 43.1.178
22
0, 408
1440
sshd
4
10.10.1.201
10.43.1.178
22
0, 612
1440
pq2s
410.10.1.201
10,43.1.178
22
[..-]
This output shows multiple connections from 10.10.1.201 to port 22, served by shd(8). These are
happening about every 200 milliseconds (from the *TIME(s)* column), which could be a brute-
force attack.
A key feature of these tools is that, for efficiency, they instrument only TCP session events. Other
tools trace every network packet, which can incur high overhead on busy systems.
See Chapter 10 for more about tcpconnect(8) and tcpaccept(8).
11.2.10 tcpreset
tcpreset(8) is a bpftrace tool to trace when TCP sends reset (RST) packets. This can be used for the
detection of TCP port scanning, which sends packets to a range of ports, including closed ones,
triggering RSTs in response. For example:
 tcpreset.bt
Attach.ing 2 probes...
Tracing TCP reseta. Hit Ctel-C to end.
TIME
LACOR
LPORT
RADDR
RPORT
20:50:24 100.66.115.238 80
100,65.2.196
45195
20 :50 : 24 100 . 66.115.238 443
100.65.2.196
45195
20:50:24 100.66.115.238 995
100,65.2,196
45451
20:50:24 100.66.115.238 5900
100.65.2,196
45451
20 :50 :24 100 . 66.115.238 443
100,65.2,196
45451
20:50:24 100.66.115.238 110
100.65.2.196
45451
20:50:24 100.66.115.238 135
100,65.2.196
45451
20:50:24 100.66.115.238 256
100.65.2.196
45451
20 :50:24 100 . 66.115.238 21
100,65.2,196
45451
20:50:24 100.66.115.238 993
100.65.2.196
45451
20:50:24 100.66.115.238 3306
100.65.2,196
45451
20 :50 :24 100 . 66.115.238 25
100.65.2,196
45451
20:50:24 100.66.115.238 113
100.65.2,196
45451
20:50:24 100.66.115.238 1025
100.65.2,196
45451
11 0rigin: I created it for this book on 26-Feb-2019
---
## Page 544
11.2 BPF Tools 507
20 :50:24 100.66.115.238 18581 100.65.2.196
45451
20 :50 :24 100. 66.115.238 199
100,65.2,196
45451
20 :50 :24 100.66.115.238 56666 100.65.2.196
45451
20 :50 :24 100 .66.115.238 8080
961**59*001 
45451
20:50:24 100. 66.115.238 53
100.65.2.196
45451
20 :50 :24 100, 66.115.238 587
100.65.2,196
[. ..]
This shows many TCP RSTs were sent for different local ports within the same second: this looks
like a port scan. It works by tracing the kernel function that sends resets, and the overhead should
therefore be negligible, as this occurs infrequently in normal operation.
Note that there are different types of TCP port scans, and TCP/IP stacks can respond to them
m popuodsau u pue sauuess μod (1)deuu au Susn paua st xnur e paqsa I 4uaagp
RSTs to SYN, FIN, NULL, and Xmas scans, making them all visible using tcpreset(8).
The columns are:
TIME: Time in HH:MM:SS format
 LADDR: Local address
• LPORT: Local TCP port
• RADDR: Remote IP address
• RPORT: Remote TCP port
The source to tcpreset(8) is:
1/usz/local/bin/bpftrace
include 
#include 
include 
BEGIN
printf (*Tracing TCP resets. Hit Ctrl-C to end.\n*);
printf(*s=8s 1=14s 1=6a 14s =6sn*, *TINE*,
kprobe:tcp_v4_send_reset
6xe (+ Fgngxs 1on.x1s) = qxs$
 [xapeaqodsue3 >  qsap>samosdaddr) , $dport,
ntop (AF_INET, $1p=>saddz) , $sport) ;
This traces the tcp_v4_send_reset( kernel function, which only traces IPv4 traffic. The tool can be
enhanced to trace IPv6 as well if desired.
This tool is also an example of reading IP and TCP headers from a socket buffer: the lines that set
Stcp and Sip. This logic is based on the kernel’s ip_hdr() and tcp_hdr() functions, and will need
updates if the kernel changes this logic.
11.2.11
capable
siao Supopq po juapu au sm suogeotdde 6q saqede panbau o sistatm Suonnstuo
to improve security.
capable
TIME
UID
PID
COMM
CAP
NAME
AUDIT
22 :52 : 11
D
20007
capab1e
21
CAP_SYS_ADHIN
20007
21
1
22 :52 : 11
 0
capable
CAP_SYS_ADMIN
1
22 : 52 : 11
D
2000T
capab1e
CAP_SYS_ADHIN
1
22:52:11
20007
capab1e
21
CAP_SYS_ADMIN
1
22 :52 : 11
D
20007
capab1e
21
CAP_SYS_ADNIN
1
22 :52: 11
0
20007
capable
21
CAP_SYS_ADMIN
22 : 52 : 12
1000
20108
s.sh
7
CAP_SETUID
01513Sa
T
22 :52 : 12
0
20109
sshd
6
1
22 :52 : 12
D
20109
sshd
6
CAP_SETGID
22 :52 : 12
0
20110
sshd
18
CAP_SYS_CHROOT
1
22 :52 : 12
D
20110
sshd
6
CAP_SETGID
20110
1
22 :52 : 12
0
sshd
CAP_SETGID
1
22 :52 : 12
D
20110
s.shd
7
CAP_SETUID
1
22:52:12
122
20110
sshd
CAP_SETGID
22 :52 : 12
122
20110
sshd
CAP_SETGID
1
1
22 :52 : 12
122
20110
sshd
CAP_SETUID
1
[..-]
 on 8-Sep-2018. 1 created it after
a discussion with Michael Wsrdrop from the Netflix platform security team, who wanted this kind of visibility
---
## Page 546
11.2  BPF Tools
509
This output shows the capable(8) tool checking for the CAP_SYS_ADMIN capability (super
user), and then ssh(1) checking CAP_SETUID, and then sshd(8) checking various capabilities.
Documentation for these capabilities can be found in the capabilities(7) man page.
Columns include:
• CAP: Capability number
 NAME: Code name for the capability (see capabilities(7))
• AUDIT: Whether this capability check writes to the audit log
This works by tracing the kernel cap_capable() function, which determines whether the current
a pnoqs peaqao au req mo os Aieord s su jo ouanban au iqedeo uaatg e seq gse
negligible.
There are options to show user- and kernel-stack traces. For example, including both:
 capable -RU
[..]
TIME
UID
PIDCOMH
CAPNXE
AUDIT
12:00: 37 0
26069 bash
2
CAP_DAC_READ_SEARCH 1
cap_capable+0x1 [kerne1]
n.s_capable_conmon+0×x68 [kecne1]
capable_vxt_Inode_uldgld+0x33 [kernel]
generic_permission+0xfe [kernel]
_inode_permlssion+0x36 [keznel]
inode_pernission+0x14 [kernel]
nay_open+Ox5a [kernel]
path_openat+0x4b5 [kernel]
do_f11p_open+0x9b [kerne1]
do_sys_open+0x1bb [kermel]
sys_openat+0x14 [kernel]
do_sysca11_64+0x73 [kernel]
entxy_SYscALl_64_aftez_hxfrane+0x3d [kerne1]
open+0x4e (1ibe=2.27,so)
read_hlstory+0x22 [bash]
load_history+0x8c [bash]
nain+0x955 [bash]
_libc_start_nsin+0xe? [1ibe-2 .27,so]
[unknoxn]
[...]
This includes the kernel stack showing the openat(2) syscall and the user stack showing the bash
process calling read_history().
---
## Page 547
510
Chapter 11 Security
BCC
Command line usage:
[zuotdo]  =[qedeo
Options include:
v: Include non-audit checks (verbose)
uo ssaooud su aunseay :aId d-
R: Include kernel stack traces
U: Include user-level stack traces
Some checks are considered *non-audit° and don’t write a message to the audit log. These are
excluded by default unless v is used.
bpftrace
The following is the code for the bpftrace version, which summarizes its core functionality. This
version does not support options and traces all capability checks, included non-audit.
+1/usr/local/bin/bpftrace
BEGIN
printf (*Tracing cap_capable syscalls... Hit Ctel~C to end.\n*:
printf(*s=§s 1=6s =s s-16s 1=4s I20s AUDIr',n*, *7IME*, *UID*, "PID*,
*COHM”, “CAP*, *KAME”)
fμxoedvo - [01deog
Bcsp[1] - *CAF_DAC_0VERRIDs*;
rux3wo.a"av, - [c]deog
Bcap[4] - *CAP_FSETID";
7T1xav, - [s]deog
8cap[6] - *CAP_SETGID";
rμIasav - []deog
Bcap[B] - *CAP_SETPCAP";
Bcsp[9] - *CAF_LINUX_IMMUTABLE*;
Bcap[10] - *CAP_NET_BIND_SERVICE*;
Bcsp[11] - *CAP_NET_BROACCAST*;
KIWYL3naYO。 - Izt1de>8
fNVIaN aYo。 = IetldeoB
rxo"oavo。 - [t]deog
HaNxooa1axo。 - [st1deo8
---
## Page 548
11.2 BPF Tools
511
Bcap[16] - *CAP_SYS_M00ULE*;
μora"sxsaxo。 = [ct]deog
IO8HsxsaYO. - [et]deog
3ra1d"sxs"dx。 - 16t1deo8
Iova"sxs"avo。 - [oz]deg
μKIWoY"sxs"dxo。 - 1tz1deo8
L00esxsax。 - [2]deg
cap[23] - *CAP_SYs_NICE";
Bcap[24] - *cAr_sYs_REsoURcE*;
f3KIz"sxs"aYo。 - Isz]deo8