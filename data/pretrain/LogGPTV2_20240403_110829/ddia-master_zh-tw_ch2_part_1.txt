# 第二章：资料模型与查询语言
![](../img/ch2.png)
> 语言的边界就是思想的边界。
>
> —— 路德维奇・维特根斯坦，《逻辑哲学》（1922）
>
-------------------
[TOC]
资料模型可能是软体开发中最重要的部分了，因为它们的影响如此深远：不仅仅影响著软体的编写方式，而且影响著我们的 **解题思路**。
多数应用使用层层叠加的资料模型构建。对于每层资料模型的关键问题是：它是如何用低一层资料模型来 **表示** 的？例如：
1. 作为一名应用开发人员，你观察现实世界（里面有人员、组织、货物、行为、资金流向、感测器等），并采用物件或资料结构，以及操控那些资料结构的 API 来进行建模。那些结构通常是特定于应用程式的。
2. 当要储存那些资料结构时，你可以利用通用资料模型来表示它们，如 JSON 或 XML 文件、关系资料库中的表或图模型。
3. 资料库软体的工程师选定如何以记忆体、磁碟或网路上的位元组来表示 JSON / XML/ 关系 / 图资料。这类表示形式使资料有可能以各种方式来查询，搜寻，操纵和处理。
4. 在更低的层次上，硬体工程师已经想出了使用电流、光脉冲、磁场或者其他东西来表示位元组的方法。
一个复杂的应用程式可能会有更多的中间层次，比如基于 API 的 API，不过基本思想仍然是一样的：每个层都透过提供一个明确的资料模型来隐藏更低层次中的复杂性。这些抽象允许不同的人群有效地协作（例如资料库厂商的工程师和使用资料库的应用程式开发人员）。
资料模型种类繁多，每个资料模型都带有如何使用的设想。有些用法很容易，有些则不支援如此；有些操作执行很快，有些则表现很差；有些资料转换非常自然，有些则很麻烦。
掌握一个数据模型需要花费很多精力（想想关系资料建模有多少本书）。即便只使用一个数据模型，不用操心其内部工作机制，构建软体也是非常困难的。然而，因为资料模型对上层软体的功能（能做什么，不能做什么）有著至深的影响，所以选择一个适合的资料模型是非常重要的。
在本章中，我们将研究一系列用于资料储存和查询的通用资料模型（前面列表中的第 2 点）。特别地，我们将比较关系模型，文件模型和少量基于图形的资料模型。我们还将检视各种查询语言并比较它们的用例。在 [第三章](ch3.md) 中，我们将讨论储存引擎是如何工作的。也就是说，这些资料模型实际上是如何实现的（列表中的第 3 点）。
## 关系模型与文件模型
现在最著名的资料模型可能是 SQL。它基于 Edgar Codd 在 1970 年提出的关系模型【1】：资料被组织成 **关系**（SQL 中称作 **表**），其中每个关系是 **元组**（SQL 中称作 **行**) 的无序集合。
关系模型曾是一个理论性的提议，当时很多人都怀疑是否能够有效实现它。然而到了 20 世纪 80 年代中期，关系资料库管理系统（RDBMSes）和 SQL 已成为大多数人们储存和查询某些常规结构的资料的首选工具。关系资料库已经持续称霸了大约 25~30 年 —— 这对计算机史来说是极其漫长的时间。
关系资料库起源于商业资料处理，在 20 世纪 60 年代和 70 年代用大型计算机来执行。从今天的角度来看，那些用例显得很平常：典型的 **事务处理**（将销售或银行交易，航空公司预订，库存管理资讯记录在库）和 **批处理**（客户发票，工资单，报告）。
当时的其他资料库迫使应用程式开发人员必须考虑资料库内部的资料表示形式。关系模型致力于将上述实现细节隐藏在更简洁的介面之后。
多年来，在资料储存和查询方面存在著许多相互竞争的方法。在 20 世纪 70 年代和 80 年代初，网状模型（network model）和层次模型（hierarchical model）曾是主要的选择，但关系模型（relational model）随后占据了主导地位。物件资料库在 20 世纪 80 年代末和 90 年代初来了又去。XML 资料库在二十一世纪初出现，但只有小众采用过。关系模型的每个竞争者都在其时代产生了大量的炒作，但从来没有持续【2】。
随著电脑越来越强大和互联，它们开始用于日益多样化的目的。关系资料库非常成功地被推广到业务资料处理的原始范围之外更为广泛的用例上。你今天在网上看到的大部分内容依旧是由关系资料库来提供支援，无论是线上释出、讨论、社交网路、电子商务、游戏、软体即服务生产力应用程式等内容。
### NoSQL 的诞生
现在 - 2010 年代，NoSQL 开始了最新一轮尝试，试图推翻关系模型的统治地位。“NoSQL” 这个名字让人遗憾，因为实际上它并没有涉及到任何特定的技术。最初它只是作为一个醒目的 Twitter 标签，用在 2009 年一个关于分散式，非关系资料库上的开源聚会上。无论如何，这个术语触动了某些神经，并迅速在网路创业社群内外传播开来。好些有趣的资料库系统现在都与 *#NoSQL* 标签相关联，并且 NoSQL 被追溯性地重新解释为 **不仅是 SQL（Not Only SQL）** 【4】。
采用 NoSQL 资料库的背后有几个驱动因素，其中包括：
* 需要比关系资料库更好的可伸缩性，包括非常大的资料集或非常高的写入吞吐量
* 相比商业资料库产品，免费和开源软体更受偏爱
* 关系模型不能很好地支援一些特殊的查询操作
* 受挫于关系模型的限制性，渴望一种更具多动态性与表现力的资料模型【5】
不同的应用程式有不同的需求，一个用例的最佳技术选择可能不同于另一个用例的最佳技术选择。因此，在可预见的未来，关系资料库似乎可能会继续与各种非关系资料库一起使用 - 这种想法有时也被称为 **混合持久化（polyglot persistence）**。
### 物件关系不匹配
目前大多数应用程式开发都使用面向物件的程式语言来开发，这导致了对 SQL 资料模型的普遍批评：如果资料储存在关系表中，那么需要一个笨拙的转换层，处于应用程式程式码中的物件和表，行，列的资料库模型之间。模型之间的不连贯有时被称为 **阻抗不匹配（impedance mismatch）**[^i]。
[^i]: 一个从电子学借用的术语。每个电路的输入和输出都有一定的阻抗（交流电阻）。当你将一个电路的输出连线到另一个电路的输入时，如果两个电路的输出和输入阻抗匹配，则连线上的功率传输将被最大化。阻抗不匹配会导致讯号反射及其他问题。
像 ActiveRecord 和 Hibernate 这样的 **物件关系对映（ORM object-relational mapping）** 框架可以减少这个转换层所需的样板程式码的数量，但是它们不能完全隐藏这两个模型之间的差异。
![](../img/fig2-1.png)
**图 2-1 使用关系型模式来表示领英简介**
例如，[图 2-1](../img/fig2-1.png) 展示了如何在关系模式中表示简历（一个 LinkedIn 简介）。整个简介可以透过一个唯一的识别符号 `user_id` 来标识。像 `first_name` 和 `last_name` 这样的栏位每个使用者只出现一次，所以可以在 User 表上将其建模为列。但是，大多数人在职业生涯中拥有多于一份的工作，人们可能有不同样的教育阶段和任意数量的联络资讯。从使用者到这些专案之间存在一对多的关系，可以用多种方式来表示：
* 传统 SQL 模型（SQL：1999 之前）中，最常见的规范化表示形式是将职位，教育和联络资讯放在单独的表中，对 User 表提供外来键引用，如 [图 2-1](../img/fig2-1.png) 所示。
* 后续的 SQL 标准增加了对结构化资料型别和 XML 资料的支援；这允许将多值资料储存在单行内，并支援在这些文件内查询和索引。这些功能在 Oracle，IBM DB2，MS SQL Server 和 PostgreSQL 中都有不同程度的支援【6,7】。JSON 资料型别也得到多个数据库的支援，包括 IBM DB2，MySQL 和 PostgreSQL 【8】。
* 第三种选择是将职业，教育和联络资讯编码为 JSON 或 XML 文件，将其储存在资料库的文字列中，并让应用程式解析其结构和内容。这种配置下，通常不能使用资料库来查询该编码列中的值。
对于一个像简历这样自包含文件的资料结构而言，JSON 表示是非常合适的：请参阅 [例 2-1]()。JSON 比 XML 更简单。面向文件的资料库（如 MongoDB 【9】，RethinkDB 【10】，CouchDB 【11】和 Espresso【12】）支援这种资料模型。
**例 2-1. 用 JSON 文件表示一个 LinkedIn 简介**
```json
{
  "user_id": 251,
  "first_name": "Bill",
  "last_name": "Gates",
  "summary": "Co-chair of the Bill & Melinda Gates... Active blogger.",
  "region_id": "us:91",
  "industry_id": 131,
  "photo_url": "/p/7/000/253/05b/308dd6e.jpg",
  "positions": [
    {
      "job_title": "Co-chair",
      "organization": "Bill & Melinda Gates Foundation"
    },
    {
      "job_title": "Co-founder, Chairman",
      "organization": "Microsoft"
    }
  ],
  "education": [
    {
      "school_name": "Harvard University",
      "start": 1973,
      "end": 1975
    },
    {
      "school_name": "Lakeside School, Seattle",
      "start": null,
      "end": null