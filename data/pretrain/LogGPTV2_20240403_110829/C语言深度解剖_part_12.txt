#pragma warning(disable:4507 34) // 不显示4507 和34 号警告信息
#pragma warning(once:4385) // 4385 号警告信息仅报告一次
#pragma warning(error:164) // 把164 号警告信息作为一个错误。同时这个
pragma warning 也支持如下格式：
#pragma warning( push [ ,n ] )
#pragma warning( pop )
这里n 代表一个警告等级(1---4)。
#pragma warning( push )保存所有警告信息的现有的警告状态。
#pragma warning( push, n)保存所有警告信息的现有的警告状态，并且把全局警告
等级设定为n。
#pragma warning( pop )向栈中弹出最后一个警告信息，在入栈和出栈之间所作的
- 62 -
一切改动取消。例如：
#pragma warning( push )
#pragma warning( disable : 4705 )
#pragma warning( disable : 4706 )
#pragma warning( disable : 4707 )
//.......
#pragma warning( pop )
在这段代码的最后，重新保存所有的警告信息(包括4705，4706 和4707)。
3.6.7 #pragma comment
#pragma comment(...)
该指令将一个注释记录放入一个对象文件或可执行文件中。
常用的lib 关键字，可以帮我们连入一个库文件。比如：
#pragma comment(lib, "user32.lib")
该指令用来将user32.lib 库文件加入到本工程中。
linker:将一个链接选项放入目标文件中,你可以使用这个指令来代替由命令行传入的
或者在开发环境中设置的链接选项,你可以指定/include 选项来强制包含某个对象,例如:
#pragma comment(linker, "/include:__mySymbol")
3.6.8 #pragma pack
这里重点讨论内存对齐的问题和#pragma pack（）的使用方法。
什么是内存对齐？
先看下面的结构：
struct TestStruct1
{
char c1;
short s;
char c2;
int i;
};
假设这个结构的成员在内存中是紧凑排列的，假设c1 的地址是0，那么s 的地址就应
该是1，c2 的地址就是3，i 的地址就是4。也就是c1 地址为00000000, s 地址为00000001,
c2地址为00000003, i 地址为00000004。
可是，我们在Visual C++6.0 中写一个简单的程序：
struct TestStruct1 a;
printf("c1 %p, s %p, c2 %p, i %p\n",
(unsigned int)(void*)&a.c1 - (unsigned int)(void*)&a,
(unsigned int)(void*)&a.s - (unsigned int)(void*)&a,
(unsigned int)(void*)&a.c2 - (unsigned int)(void*)&a,
(unsigned int)(void*)&a.i - (unsigned int)(void*)&a);
运行，输出：
- 63 -
c1 00000000, s 00000002, c2 00000004, i 00000008。
为什么会这样？这就是内存对齐而导致的问题。
3.6.8.1 为什么会有内存对齐？
字，双字，和四字在自然边界上不需要在内存中对齐。（对字、双字、四字来说，自然
边界分别是偶数地址、可以被4 整除的地址、可以被8 整除的地址。）无论如何，为了提
高程序的性能，数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访
问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。
一个字或双字操作数跨越了4 字节边界，或者一个四字操作数跨越了8 字节边界，被
认为是未对齐的，从而需要两次总线周期来访问内存。一个字起始地址是奇数但却没有跨越
字边界被认为是对齐的，能够在一个总线周期中被访问。某些操作双四字的指令需要内存操
作数在自然边界上对齐。如果操作数没有对齐，这些指令将会产生一个通用保护异常。双四
字的自然边界是能够被16 整除的地址。其他的操作双四字的指令允许未对齐的访问（不会
产生通用保护异常），然而，需要额外的内存总线周期来访问内存中未对齐的数据。
缺省情况下，编译器默认将结构、栈中的成员数据进行内存对齐。因此，上面的程序输
出就变成了：c1 00000000, s 00000002, c2 00000004, i 00000008。编译器将未对
齐的成员向后移，将每一个都成员对齐到自然边界上，从而也导致了整个结构的尺寸变大。
尽管会牺牲一点空间（成员之间有部分内存空闲），但提高了性能。也正是这个原因，我们
不可以断言sizeof(TestStruct1)的结果为8。在这个例子中，sizeof(TestStruct1)的
结果为12。
3.6.8.2 如何避免内存对齐的影响
那么，能不能既达到提高性能的目的，又能节约一点空间呢？有一点小技巧可以使用。
比如我们可以将上面的结构改成：
struct TestStruct2
{
char c1;
char c2;
short s;
int i;
};
这样一来，每个成员都对齐在其自然边界上，从而避免了编译器自动对齐。在这个例子
中，sizeof(TestStruct2)的值为8。这个技巧有一个重要的作用，尤其是这个结构作为API
的一部分提供给第三方开发使用的时候。第三方开发者可能将编译器的默认对齐选项改变，
从而造成这个结构在你的发行的DLL 中使用某种对齐方式，而在第三方开发者哪里却使用
另外一种对齐方式。这将会导致重大问题。比如，TestStruct1 结构，我们的DLL 使用默
认对齐选项，对齐为
c1 00000000, s 00000002, c2 00000004, i 00000008，同时sizeof(TestStruct1)
的值为12。
而第三方将对齐选项关闭，导致
c1 00000000, s 00000001, c2 00000003, i 00000004，同时sizeof(TestStruct1)
- 64 -
的值为8。
除此之外我们还可以利用#pragma pack（）来改变编译器的默认对齐方式（当然一般
编译器也提供了一些改变对齐方式的选项，这里不讨论）。
使用指令#pragma pack (n)，编译器将按照n 个字节对齐。
使用指令#pragma pack ()，编译器将取消自定义字节对齐方式。
在#pragma pack (n)和#pragma pack ()之间的代码按n 个字节对齐。
但是，成员对齐有一个重要的条件,即每个成员按自己的方式对齐。也就是说虽然指定
了按n 字节对齐，但并不是所有的成员都是以n 字节对齐。其对齐的规则是，每个成员按
其类型的对齐参数(通常是这个类型的大小)和指定对齐参数(这里是n 字节)中较小的一个
对齐，即：min( n, sizeof( item )) 。并且结构的长度必须为所用过的所有对齐参数
的整数倍,不够就补空字节。看如下例子：
#pragma pack(8)
struct TestStruct4
{
char a;
long b;
};
struct TestStruct5
{
char c;
TestStruct4 d;
long long e;
};
#pragma pack()
问题：
A),sizeof(TestStruct5) = ?
B), TestStruct5 的c 后面空了几个字节接着是d?
TestStruct4 中,成员a 是1 字节默认按1 字节对齐,指定对齐参数为8,这两个值中
取1,a
按1 字节对齐;成员b 是4 个字节,默认是按4 字节对齐,这时就按4 字节对齐,所以
sizeof(TestStruct4)应该为8;
TestStruct5 中,c 和TestStruct4 中的a 一样,按1 字节对齐,而d 是个结构,它是
8 个字节,它按什么对齐呢?对于结构来说,它的默认对齐方式就是它的所有成员使用的对
齐参数中最大的一个, TestStruct4 的就是4.所以,成员d 就是按4 字节对齐.成员e 是8
个字节,它是默认按8字节对齐,和指定的一样,所以它对到8 字节的边界上,这时,已经使用
了12 个字节了,所以又添加了4 个字节的空,从第16 个字节开始放置成员e.这时,长度为
24,已经可以被8(成员e 按8字节对齐)整除.这样,一共使用了24 个字节.内存布局如下（*
表示空闲内存，1 表示使用内存。单位为1byete）：
a b
TestStruct4 的内存布局：1***,1111,
c TestStruct4.a TestStruct4.b d
TestStruct5 的内存布局： 1***, 1***, 1111, ****，11111111
这里有三点很重要:
首先，每个成员分别按自己的方式对齐,并能最小化长度。
- 65 -
其次，复杂类型(如结构)的默认对齐方式是它最长的成员的对齐方式,这样在成员是复
杂类型时,可以最小化长度。
然后，对齐后的长度必须是成员中最大的对齐参数的整数倍,这样在处理数组时可以保
证每一项都边界对齐。
补充一下,对于数组,比如:char a[3];它的对齐方式和分别写3 个char 是一样的.也就是
说它还是按 1 个字节对齐.如果写: typedef char Array3[3];Array3 这种类型的对齐
方式还是按1个字节对齐,而不是按它的长度。
但是不论类型是什么,对齐的边界一定是1,2,4,8,16,32,64....中的一个。
另外，注意别的#pragma pack 的其他用法：
#pragma pack(push) //保存当前对其方式到packing stack
#pragma pack(push,n) 等效于
#pragma pack(push)
#pragma pack(n) //n=1,2,4,8,16 保存当前对齐方式，设置按n 字节对齐
#pragma pack(pop) //packing stack 出栈，并将对其方式设置为出栈的对齐方
3.7 #运算符
#也是预处理？是的，你可以这么认为。那怎么用它呢? 别急，先看下面例子：
#define SQR(x) printf("The square of x is %d.\n", ((x)*(x)));
如果这样使用宏：
SQR(8);
则输出为：
The square of x is 64.
注意到没有，引号中的字符x 被当作普通文本来处理，而不是被当作一个可以被替换的
语言符号。
假如你确实希望在字符串中包含宏参数，那我们就可以使用“#”，它可以把语言符号
转化为字符串。上面的例子改一改：
#define SQR(x) printf("The square of "#x" is %d.\n", ((x)*(x)));
再使用：
SQR(8);
则输出的是：
The square of 8 is 64.
很简单吧？相信你现在已经明白#号的使用方法了。
3.8 ##预算符
和#运算符一样，##运算符可以用于宏函数的替换部分。这个运算符把两个语言符号组
合成单个语言符号。看例子：
#define XNAME(n) x ## n
如果这样使用宏：
XNAME(8)
则会被展开成这样：
x8
- 66 -
看明白了没？##就是个粘合剂，将前后两部分粘合起来。
第四章 挃针和数组
几乎每次讲课讲到指针和数组时，我总会反复不停的问学生：到底什么是指针？什么是
数组？他们之间到底是什么样的关系。从几乎没人能回答明白到几乎都能回答明白，需要经
历一段“惨绝人寰”的痛。
指针是C/C++的精华，如果未能很好地掌握指针，那C/C++也基本等于没学。可惜，对
于刚毕业的计算机系的学生，几乎没有人真正完全掌握了指针和数组、以及内存管理，甚至
有的学生告诉我说：他们老师认为指针与数组太难，工作又少用，所以没有讲解。对于这样
的学校与老师，我是彻底的无语。我没有资格去谴责或是鄙视谁，只是窃以为，这个老师恐
怕自己都未掌握指针。大学里很多老师并未真正写过多少代码，不掌握指针的老师肯定存在，
这样的老师教出来的学生如何能找到工作？而目前市面上的书对指针和数组的区别也是几
乎避而不谈，这就更加加深了学生掌握的难度。
我平时上课总是非常细致而又小心的向学生讲解这些知识，生怕一不小心就讲错或是误
导了学生。还好，至少到目前为止，我教过的学生几乎都能掌握指针和数组及内存管理的要
点，当然要到能运用自如的程度还远远不够，这需要大量的写代码才能达到。另外需要说明
的是，讲课时为了让学生深刻的掌握这些知识，我举了很多各式各样的例子来帮助学生理解。
所以，我也希望读者朋友能好好体味这些例子。
三个问题：