(cid:8)(cid:2)
(cid:8)(cid:2)(cid:4)(cid:3)(cid:5)(cid:6)(cid:7)(cid:9)(cid:1)
(cid:5)(cid:3)(cid:3)(cid:1)
(cid:5)(cid:15)(cid:18)(cid:19)(cid:24)(cid:8)(cid:15)(cid:13)(cid:16)(cid:17)(cid:15)(cid:13)(cid:11)(cid:18)(cid:10)(cid:1)(cid:16)(cid:10)(cid:17)(cid:11)(cid:15)(cid:9)(cid:1)
Fig. 2. PillarBox across compromise phases: (A) The host has not yet been attacked. (B) The SAS
detects in-progress compromise and places an alert in PBB. (C) The host is under the attacker’s
full control, but PBB securely stores and transmits the alert.
We ﬁrst explain why buffering is important to secure the SAS chain of custody in
PillarBox and then how we address the technical challenges it introduces.
Why Buffering Is Necessary. The approach of most SAS systems today, e.g., syslog
and HIDSs, is to push alerts to a remote server in real time, and thus secure them at the
server during the critical window. But there are many important cases, both adversarial
and benign, in which SAS messages cannot be pushed reliably, for two main reasons:
– Imperfect connectivity: Many host SAS systems lack continuous connectivity to the
server (e.g., laptops shuttling between an ofﬁce and home have limited connection
PillarBox: Combating Next-Generation Malware
51
with corporate security servers but are open to infection in the home). Lightweight
embedded devices often cannot ensure or even verify delivery of transmitted mes-
sages (e.g., wireless sensor networks often experience transmission failures).
– Network attacks: An attacker can actively suppress on-the-ﬂy SAS transmissions
by causing malicious network failures. It can selectively disrupt network trafﬁc,
via, e.g., ARP stack smashing (e.g., see CVE-2007-1531 and CVE-2010-2979), or
ﬂood target hosts to achieve denial-of-service (DoS) during a compromise, causing
message delay or suppression. The result is complete occlusion of server visibility
into the critical window—potentially appearing to be a benign network failure. (We
describe our own implementation of such an alert-suppression attack below.)
But even if reliable, immediate SAS message-pushing were generally feasible, it
would still have an undesirable effect:
– SAS intelligence leakage: If a host pushes alerts instantaneously, then its outbound
trafﬁc reveals SAS activity to an attacker monitoring its output. An attacker can then
probe a host to learn SAS detection rules and/or determine after the fact whether its
intrusion into a host was detected. Note that encryption does not solve this problem:
Trafﬁc analysis alone can reveal SAS rule-triggering. (As noted above, PillarBox
overcomes this problem via regular alert-buffer transmission.)
Thus, message buffering, as opposed to on-the-ﬂy event-triggered transmission, is
of key importance in a SAS chain of custody and the cornerstone of PillarBox. Such
buffering, though, poses new security challenges. If an attacker completely compro-
mises a host, there is no way of course to prevent it from disabling a SAS or tampering
with its future outputs. But there is a separate problem after host compromise: Inad-
equately protected buffered SAS messages are vulnerable to modiﬁcation/suppression
and intelligence leakage. We next elaborate on how PillarBox solves these problems.
Achieving Integrity. A main challenge in creating a secure chain of custody in PillarBox
is the need to secure alert messages after compromise, while they are still buffered and
exposed to an attacker. Log-scrubbing malware can attempt to modify buffered alerts
(e.g., replace the strong alert “Privilege Escalation” with the more benign “Port Scan
Observed”) or just purge alerts. Post-compromise integrity protection for buffered SAS
messages is thus crucial in PillarBox—but at ﬁrst glance, this might seem unachievable.
Indeed, a digital signature or message authentication code (MAC) alone, as pro-
posed, e.g., for syslog [12], does not protect against tampering: After host compromise
an attacker learns the signing key and can forge messages. Message encryption simi-
larly does not protect messages against deletion, nor does tagging them with sequence
numbers, as an attacker with control of a host can forge its own sequence numbers.
Fortunately, post-compromise alert integrity is achievable using the well-known
cryptographic technique of forward-secure integrity protection. The main idea is to
generate new (signing) keys on the host after every alert generation and delete keys
immediately after use. This technique is commonly used for forward-secure logging
(e.g., [14, 19, 25, 26]),3 an application closely related to SAS protection. Similarly,
3 Such systems are designed mainly for forensic purposes rather than detection (e.g., to protect
against administrator tampering after the fact), thus they often “close” logs only periodically.
52
K.D. Bowers et al.
PillarBox uses forward-secure pseudorandom number generation (FS-PRNG) to create
MAC keys. Each key is used to secure a single message and then deleted. An FS-PRNG
has the property that past keys cannot be inferred from a current key, preventing tam-
pering of messages that have already been secured. The server runs this FS-PRNG to
compute the (same) shared keys with the host, allowing it to detect tampering or erasure.
What is new in the use of forward security in PillarBox is primarily its application for
self-protecting alerting: Indeed, the main aspect of integrity here is securing alerts in the
PBB as fast as possible during a compromise, i.e., in the critical window. Effectively,
PillarBox engages in a race to secure alerts before the attacker intercepts them, and
winning this race is not a matter of cryptography, but of system design, including the
design choice of host-side buffering! An important contribution of our work is an ex-
perimental validation (in Section 5) that winning this race, and thus the whole PillarBox
approach to securing alerts, is feasible. This is shown to hold even against a fast, local,
PillarBox-aware attacker that kills PillarBox processes as quickly as possible.
Achieving Stealth. Stealth, as we deﬁne it, requires concealment of the entire alert-
ing behavior of a SAS, including detection rules, alert message contents, alert genera-
tion times, and alert message existence in compromised hosts. Stealth is a key defense
against sophisticated attackers. (One example: Host contact with “hot” IP addresses can
help ﬂag an APT, but an attacker that learns these addresses can just avoid them [15].)
Straightforward encryption alone does not achieve stealth: If buffer alerts are en-
crypted on a host, an attacker can infer alert generation simply by counting buffer ci-
phertexts upon host compromise. Similarly, encrypted host-to-server trafﬁc leaks infor-
mation: An attacker can determine via trafﬁc analysis when a host has triggered an alert
or even perform black-box probing against a host to test attacks and infer which are or
are not detectable. Instead, stealth in PillarBox requires a combination of several ideas.
In particular, PillarBox employs a buffer size T , and buffer transmission-time in-
terval μ, that are ﬁxed, i.e., invariant. Each message is also of ﬁxed size (or padded
to that size). When PillarBox transmits, it re-encrypts and sends the entire ﬁxed-size
buffer, not just fresh (encrypted) alerts. Such ﬁxed-length transmissions prevent an at-
tacker from determining when new alerts have accumulated in the host buffer, while its
ﬁxed communication patterns defeat trafﬁc analysis. As the host buffer is of ﬁxed size
T , PillarBox writes messages to it in a round-robin fashion. Thus, messages persist in
the buffer until overwritten.4 This feature creates a need for careful parameterization:
T must be large enough to hold all alert messages generated under benign conditions
within a time interval μ; this condition ensures that if round-robin overwriting occurs,
PillarBox implicitly signals to the server a “buffer-stufﬁng” attempt by an attacker.5
PillarBox generates encryption keys in a forward-secure way to protect against de-
cryption attacks after an attacker compromises a host’s keys. To protect against an at-
tacker that controls the network and eventually the host as well, encryption is applied in
two layers: (1) To buffered messages, to ensure conﬁdentiality after host compromise,
and (2) to host-to-server buffer transmissions to ensure against discovery of alert data
4 Thus messages may be transmitted multiple times. Such persistent transmission consumes
bandwidth but it may allow temporarily suppressed messages to eventually reach the server.
5 Below we develop a framework for parameterization of T and μ and then explore practical
settings by analyzing real-world alert transmission patterns in a large enterprise.
PillarBox: Combating Next-Generation Malware
53
from buffer ciphertext changes.6 Finally, as these two encryption layers ensure conﬁ-
dentiality in the buffer and over the network, but not in the SAS alerting engine itself, a
key complement to stealth in PillarBox is concealment of detection rules in hosts: Our
experiments show the viability of instrumenting the SAS with vanishing rules.
Complete stealth in PillarBox carries an unavoidable cost: Periodic rather than im-
mediate transmissions can delay server detection of intrusions. But we note that stealth
is an optional feature in PillarBox: It can be removed or weakened for limited attackers.
3 Architecture
We next describe PillarBox’s general architecture, main software components and oper-
ating conﬁguration, used to secure the host-to-server chain of custody in a SAS system.
3.1 Interface with SAS
Being agnostic to message content, PillarBox works with any SAS. It can serve as the
main channel for SAS alerts or can deliver SAS alerts selectively and work in parallel
with an existing transport layer. Exactly how SAS messages are produced at the host or
consumed at the receiving server depends on SAS instrumentation and alert-consuming
processes. (As such, it’s outside the scope of our work.) Similarly, our architecture ab-
stracts away the communication path between the host and server, which can be com-
plicated in practice. In modern enterprises, networks carry many SAS-based security
controls that alert upon malfeasance. Typically, alerts are sent via unprotected TCP/IP
transmission mechanisms, such as the syslog protocol (which actually uses UDP by
default), the Simple Network Messaging Protocol (SNMP), or the Internet Control and
Messaging Protocol (ICMP). These alerts are typically generated by endpoint software
on host systems (such as anti-virus, anti-malware, or HIDS) or by networked security
control devices. These devices are commonly managed by a SIEM system, which may
be monitored by human operators. For the purposes of our architecture, though, we
simply consider a generic SAS-instrumented host communicating with a server.
Alerter. We refer generically to the SAS component that generates alert messages as
an alerter module.7 This module monitors the host environment to identify events that
match one of a set of speciﬁed alert rules. When an event triggers a rule, the alerter
outputs a distinct alert message. An alert template may either be static (predeﬁned at
some setup time for the host) or dynamic (updated regularly or on-demand through
communication with the server). Rules may take any form. They may test individual
state variables (speciﬁed as what is generally called a signature) or they may correlate
more than one event via a complicated predicate or classiﬁer. As mentioned before, the
SAS may tag select rules as “vanishing.” When such a rule is triggered, it is erased from
the current rule set to further enhance the stealth properties provided by PillarBox.
6 Buffer encryption alone is insufﬁcient: If identical buffer ciphertexts leave a host twice, the
attacker learns that no new alert has been generated in between. Semantically secure public-
key encryption would enable use of just one layer, but with impractically high cost overheads.
7 Of course, a SAS includes other components, e.g., a transport layer, update functionality, etc.
54
K.D. Bowers et al.
(cid:4)(cid:2)(cid:4)(cid:1)(cid:6)(cid:7)(cid:9)(cid:13)(cid:12)(cid:11)(cid:1)
(cid:2)(cid:12)(cid:6)(cid:16)(cid:18)(cid:6)(cid:16)(cid:1)
(cid:6)(cid:16)(cid:18)(cid:6)(cid:16)
(cid:3)(cid:19)(cid:7)(cid:7)(cid:6)(cid:16)(cid:6)(cid:16)(cid:1)
(cid:3)(cid:8)(cid:11)(cid:12)(cid:1)
(cid:3)(cid:8)(cid:11)(cid:12)(cid:1)
(cid:18)(cid:16)
(cid:18)(cid:16)(cid:2)(cid:14)(cid:17)(cid:28)
(cid:13)
(cid:13)(cid:10)(cid:18)(cid:18)(cid:6)(cid:16)(cid:1)
(cid:4)(cid:5)(cid:10)(cid:14)(cid:5)(cid:10)(cid:1)
(cid:14)(cid:22)(cid:26)(cid:27)(cid:24)(cid:25)(cid:23)(cid:1)
(cid:16)(cid:6)(cid:4)(cid:6)(cid:10)(cid:20)(cid:6)(cid:16)(cid:1)
(cid:5)(cid:6)(cid:4)(cid:16)(cid:21)(cid:15)(cid:18)(cid:6)(cid:16)(cid:1)
(cid:5)
(cid:8)(cid:2)(cid:15)(cid:28)
(cid:8)(cid:2)(cid:15)
(cid:4)(cid:9)
(cid:4)(cid:9)(cid:6)(cid:4)(cid:11)(cid:6)(cid:16)(cid:1)
Fig. 3. PillarBox architecture and data ﬂow. Shaded areas show the PillarBox components; striped
ones comprise PillarBox’s crypto-assisted core reliable channel.
In our basic architecture, the alerter’s interface with PillarBox is unidirectional. The
alerter outputs alert messages, and PillarBox consumes them. Although many archi-
tectures are possible, given PillarBox’s emphasis on critical alerts, in our canonical
operational setting, the SAS may send only high severity messages (e.g., those that
seem to indicate impending compromise) to PillarBox, and relay regular logs through
its ordinary low-priority transport layer.
3.2 PillarBox Components
The general message ﬂow in PillarBox is fairly simple. Most of the complexity is hidden
by the PBB “lockbox.” PillarBox consists of ﬁve modules, shown in Figure 3.
Bufferer. This module controls the core message buffer, the PBB (which is detailed in
Section 4). It accepts two calls: A Write call from the alerter to insert a message into
the PBB (in encrypted form) and a Wrap call from the transmitter—described below—
requesting export of the current buffer contents (also in a securely encapsulated form).
This module is also responsible for maintaining the secret state of the PBB and up-
dating the cryptographic (MAC and encryption) keys, which are effectively used to
securely label messages and buffers with sequence numbers. The bufferer does not dis-
card messages from the buffer when they are transmitted: A message is encapsulated
and transmitted until overwritten, offering the extra feature of persistence.8
Transmitter. This module schedules and executes buffer transmissions from the host
to the server. Transmissions may be scheduled every μ seconds, for parameter μ, like a
“heartbeat.” The module sends Wrap requests to the bufferer and transmits encapsulated
buffers to the server over the network using any suitable protocol.
Receiver. This module receives encapsulated-buffer transmissions on the server from
the host-based transmitter over the network. When it receives a transmission pushed
from the host, it relays it with a Read instruction to the decrypter.
Decrypter. In response to a Read request from the receiver, the decrypter decrypts and
processes an encapsulated buffer. It veriﬁes the buffer’s integrity and outputs either its
constituent messages, or else a ⊥ symbol indicating a buffer corruption. It also labels
the buffer and its messages with their corresponding (veriﬁed) sequence numbers.
Gap-checker. The gap-checker’s main task is to look for lost messages in the SAS
message stream, which cause it to output an alert that we call a gap alert. These may
be caused by one of two things: (1) A ﬂood of alerts on the host (typically signalling an
intrusion) or (2) Overwriting of alerts in the buffer by malicious buffer-stufﬁng on the
8 This byproduct of stealth can be leveraged to accommodate lossy networks, as explained later.
PillarBox: Combating Next-Generation Malware
55
compromised host (see also Section 4). As messages are labeled with veriﬁed sequence
numbers, gap checking requires veriﬁcation that no sequence numbers go missing in
the message stream. Because messages continue to be transmitted until overwritten,
note that in normal operation sequence numbers will generally overlap between buffers.
The gap-checker can optionally ﬁlter out redundant messages. To detect an attacker that
suppresses buffer transmission completely, the gap-checker also issues an alert if buffers
have stopped arriving for an extended period of time, as we discuss below.
3.3 Parameterizing PillarBox
The gap-checker always detects when a true gap occurs, i.e., there are no false-negatives
in its gap-alert output. To ensure a low false-positive rate, i.e., to prevent spurious de-
tection of maliciously created gaps, it is important to calibrate PillarBox appropriately.
The size T of the PBB dictates a tradeoff between the speed at which alerts can be
written to the buffer and the rate at which they must be sent to the server. Let τ denote
an estimate of the maximum number of alerts written by the host per second under
normal (non-adversarial) conditions. Then provided that the encapsulation interval μ
(the time between “snapshots” of buffers sent by the host) is at most T /τ seconds, a
normal host will not trigger a false gap alert. We characterize τ, the maximum SAS
message-generation rate of normal hosts, in Section 5. Using a moderate buffer size
T we are able to achieve extremely low false-positive gap-alert rate in most cases. In
networks vulnerable to message loss, the persistence feature of PillarBox can be useful:
The larger T , the more repeated transmissions of every message.
Also, if an attacker suppresses buffer transmission completely, the gap-checker will
cease to receive buffers. The gap-checker issues a transmission-failure alert if more than
β seconds have elapsed without the receipt of a buffer, for parameter setting β > T /τ.
PillarBox cannot itself distinguish benign from adversarial transmission failures (al-
though network liveness checks can help). While there are many possible policies for
transmission-failure alerts, in reliable networks, PillarBox is best coupled with an ac-