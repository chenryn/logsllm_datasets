4.4 Analysis of Patch Code Patterns
In this subsection, we first give a statistical overview of our clus-
tering results to demonstrate their good quality. We then describe
and analyze clustered patch code patterns in detail.
By running our clustering algorithm over a set of 940 short
code fragments, we obtain 83 initial clusters, out of which we can
quickly filter out 50 small-size clusters as they contain only fewer
than 10 code fragments each and actually do not exhibit evident
security-oriented patterns. The remaining 33 clusters contain code
fragments ranging from 10 to 56 fragments each, with an average
of 21 fragments. We found that these clusters are in good qual-
ity, with only five clusters not exhibiting clear patterns. In other
words, 84.8% (28/33) clusters are associated with certain patterns,
with 19 clusters for security-oriented patterns and 9 clusters for
non-security-related patterns (e.g., declaring variables and using
#ifdef). Out of the 19 security-oriented clusters, we obtain a total
of 16 patterns with the majority corresponding to distinct ones.
Table 4 lists the detailed pattern results, sorted according to the
size of the clusters. As shown in the last column of detailed cluster
ID, only two clusters (cluster 21 and 1) are mapped to multiple
patterns, which indicate that we can easily abstract patterns from
01020304050# Lines of Code Change0.00.20.40.60.81.0CDFSession 4A: Mobile SecurityAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand302Use-after-free and double free issues
Kernel address leakage due to using %p
Table 4: Clustered 16 patch code patterns for Android system vulnerabilities (some examples can be referred to Table 1).
ID Description
P1
P2 Mis-retrieving Android service by reference
P3
Inconsistent Android Parcelable serialization
P4 Mis-exported component in system apps
P5 Missing or mis-setting IF check condition
P6
P7 Missing Android permission/UID checking
P8 Overflow due to inappropriate #define value
P9
P10 Uninitialized data due to missing memset()
P11 Uninitialized data due to unassigned variable
P12 Missing certain parameter, causing logic flaws
P13 Overflow due to missing error case checking
P14
P15
P16 Data race due to missing lock/unlock
Pattern (using diff code’s essential change format) Example Known? Cluster ID
%p --> %pK
sp& --> sp
writeLong --> writeInt OR + writeInt();
exported=‘true’ --> exported=‘false’
if [OLD_CONDITION] --> if NEW_CONDITION
+/- XXX_free();
+ checkXXXPermission()/checkCallerXXX();
#define INT1 --> #define INT2
+ virtual void onReset();
+ memset();
VARIABLE --> VARIABLE = INIT_VALUE
--> , PARAMETER
+ if (CONDITION) + { return ERROR; }
--> const / transient
uint8_t|int --> uint16|32_t|long|size_t
+ XXX_lock(); + XXX_unlock();
Forgetting to set certain variable const/transient
Integer overflow due to inappropriate INT type
C5
C4
C1
–
C9
–
–
C10
–
–
C6
C7
–
–
Incomplete C++ destruction
✔ [33]
(cid:72)(cid:35) [19]
(cid:72)(cid:35) [60]
✔ [19]
52
31
58
7, 12
69
✗
(cid:72)(cid:35) [19]
✔ [65]
✔ [26]
21, 81
21
63, 2
50, 36
32, 4, 15
C2, C3
–
✔ [53]
✔ [53]
✗
✗
73
21
1
1
74
14
✗
✗
✗
✔ [70]
type qualifiers, where marking a variable const or transient can
prevent it from being modified or initialized, respectively. For ex-
ample, in CVE-2015-8967, const is needed to stop the system-call
table being modified. In CVE-2015-3837, transient is used to hide
the OpenSSLX509Certificate context variable and prevents it from
participating in the serialization process.
P4 & P7: Two more Android-specific patterns. Besides P2
and P3, pattern P4 and P7 are also Android specific. P4 is a common
vulnerability pattern in Android apps which also appears in sys-
tem apps. It mistakenly exports sensitive Android components to
other (potentially malicious) apps. On the other hand, P7 is about
missing permission or UID (i.e., app user ID) checking, and this
pattern appears in 26 vulnerabilities of our dataset, demonstrating
its pervasiveness. A prior work, Kratos [60], was designed for this
problem, but it can detect only inconsistent permission checking
and only at framework layer.
P5 & P8 & P13 & P15: Overflow-related patterns. Now we
present some traditional patterns. Hundreds of vulnerabilities in our
dataset are covered by overflow-related patterns, as in pattern P5,
P8, P13, and P15. The first three are about buffer or stack overflow,
while P15 is on integer overflow. Most of buffer overflows are due
to missing appropriate bounds checking, which could either miss
or mis-set a check condition in the IF statements (see code C9 in
pattern P5) or forget to handle a certain error branch (i.e., pattern
P13). In the case of pattern P8, the buffer itself needs to be enlarged.
Regarding integer overflow, the root cause is that inappropriate
integer types are used and the fix is to replace a smaller integer
type (e.g., uint8_t) with a larger one (e.g., uint32_t).
P10 & P11: Vulnerabilities due to uninitialized data. Unini-
tialized data is another traditional vulnerability [19], and pattern
P10 and P11 cover its two scenarios. The first scenario misses using
memset() to initialize memory buffer, and the second forgets to
assign an initial value (e.g., 0 and NULL) to a certain data variable.
These uninitialized data might be exploited to leak information
about memory layout.
P6: Use-after-free and double free issues. This type of vul-
nerabilities is due to incorrect use of memory free functions (e.g.,
osi_free() and kfree()). In some vulnerabilities, such as CVE-
2017-13257, a memory free function was placed at a location where
the data was still in use, causing an use-after-free issue. In other
cases, such as CVE-2018-9356, a memory buffer was freed two times
under a certain control-flow branch, resulting in a double free issue.
P16: Data race due to missing lock/unlock. The last tradi-
tional vulnerability pattern we clustered is about data race, where
lock/unlock functions (e.g., spin_lock/unlock() and mutex_lock/
unlock()) are not placed to prevent race conditions in a multi-
thread system such as Android.
Key Takeaway: Our clustering algorithm automatically generates
good-quality clusters of patch code fragments, with 84.8% clusters
associated with certain patterns. We thus can extract 16 vulnerability
patterns from 19 security-oriented clusters, including six new ones
not known in the literature and four specific to Android. We further
analyze the characteristics of these patterns via case studies.
4.5 Implications of Our Analysis Results
In this subsection, we further discuss four implications of our anal-
ysis results presented earlier.
Implication 1: Our analysis quantitatively points out the seri-
ousness of system-level vulnerabilities in Android. By analyzing the
severity of all 2,179 vulnerabilities in §4.1, we found that 81% of
them are rated as high or critical severity. This suggests that de-
tecting system-level issues is equally, if not more, important than
app-level vulnerabilities. Indeed, a considerable portion of Android
malware in the wild leveraged system vulnerabilities for root ex-
ploits [32, 55, 78]. Therefore, it is especially important for security
researchers to detect and patch zero-day Android vulnerabilities
ahead of hackers.
Implication 2: The results of vulnerable modules can help system
developers avoid making similar mistakes in the same module or code.
This is a further usage of our vulnerable module results beyond
the statistical data presented in §4.2. Specifically, when an Android
system developer or a third-party ROM maker starts to work on a
particular Android module, he/she can first go through previously
Session 4A: Mobile SecurityAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand303reported vulnerable code examples in the same module. In particu-
lar, our module results contain detailed code file paths (e.g., Table 3
in §4.2) and their associated patches. To help developers easily re-
trieve such information, we are on the way of implementing a web
portal to make our results browsable and searchable.
Implication 3: Since implementation bugs are an important source
of Android system vulnerabilities, it is necessary for future defense
systems to adopt them into threat models. Existing research efforts on
securing Android OS have proposed mandatory access control (e.g.,
SEAndroid [62] and ASM [36]) and information flow control (e.g.,
Weir [56] and Aquifer [57]). These defense systems typically assume
no implementation vulnerabilities in Android platform components.
For example, SEAndroid [62] admits that it cannot mitigate kernel
vulnerabilities or address threats from other platform components,
while Weir [56] explicitly includes Android OS as its trusted com-
puting base. However, as revealed by our analysis of patch code
complexity in §4.3, a significant portion of Android vulnerabilities
are likely implementation bugs. These implementation weaknesses
could then turn down an originally secure system design.
Implication 4: Our patch code patterns can be leveraged for au-
tomatic vulnerability detection using program analysis techniques.
A key problem in using static program analysis for vulnerability
detection is to determine patterns, and our analysis in §4.4 can serve
for this purpose. Specifically, extracted vulnerability patterns can be
utilized in two ways. First, some patterns are context-independent
(e.g., P1 and P2) or can be tracked using data/control flows (e.g., P3,
P6, P10, P11, and P15), and thus can be directly inputted to a static
analysis tool. For other patterns that are fully related to program
contexts, learning-based methods (e.g., VulDeePecker [51]) can be
further employed to distinguish different contexts.
5 RELATED WORK
In this section, we present the research related to Android system
vulnerabilities, vulnerability report analysis, and similar or cloned
code detection.
Research on Android system vulnerabilities. While most
prior work was concerned about app-level vulnerabilities (e.g., [22,
24, 25, 27, 30, 34, 42, 48, 54, 58, 66–69, 72, 79, 80]), there are some
recent studies specialized for Android system vulnerability detec-
tion. Notably, ADDICTED [77] made a first attempt in analyzing
the (in)security of Android device drivers and they found that a
large number of device drivers customized by vendors are under-
protected with downgraded permissions. Following this direction,
several studies of mobile device drivers were further performed, on
a new dynamic analysis [63], on the ION driver insecurity [74], and
on an Android-specific kernel driver called Binder [18, 28]. Com-
pared to drivers, Android framework received more security re-
search. For example, Kratos [60], Kywe et al. [46], Gu et al. [35], Ace-
Droid [16], and ACMiner [38] discovered inconsistent security pol-
icy enforcement in the Android framework, while ASVHunter [37]
and KMHunter [64] examined denial-of-service attack issues. Dif-
ferent from these studies on detecting unknown vulnerability in-
stances, we aim to obtain insights from reported vulnerabilities.
Analysis of vulnerability reports. Our paper belongs to the
general research category of analyzing vulnerability reports. The
most related are two works [41, 52] that also analyzed Android
vulnerability reports. Compared with our large-scale study via an
automatic analysis framework, these two studies relied on signif-
icant manual efforts and used only a small set of vulnerabilities
for analysis. Moreover, they did not present in-depth analysis, e.g.,
clustering patch code patterns as we did in this paper.
In the research of other vulnerability reports, Chen et al. [20]
made a pioneer work on using a finite-state machine (FSM) to model
and analyze memory corruption vulnerabilities in 2006. In 2011,
Chen et al. [19] performed a high-impact study on analyzing 141
Linux kernel vulnerability reports. In 2017, Li and Paxson [47] con-
ducted a generic measurement study of all kinds of security patches.
There were also some studies surveying vulnerability reports as part
of their research. For example, UniSan [53] surveyed the root causes
of kernel information leaks reported after 2013, and InstaGuard [21]
measured the patch delays of 12 vulnerabilities in Android system
programs and also evaluated their patch solution in 30 selected
Android vulnerabilities. Furthermore, a recent work, SemFuzz [73],
leveraged vulnerability-related text from CVE reports and Linux
git logs to guide automatic generation of proof-of-concept exploits.