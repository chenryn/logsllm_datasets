Initialize communication channel (two steps)
InsertNode( syncId, index, model )
Insert node described by model as child index of element
identiﬁed by syncId.
ModifyAttribute( syncId, name, value )
Set attribute name to value on element identiﬁed by syncid.
ModifyStyle( syncId, name, value, priority )
Set CSS property name to value and priority on element
identiﬁed by syncId.
ModifyText( syncId, index, data )
Set text content to data on index child of element identiﬁed by
syncId.
RemoveNode( syncId, index )
Remove node index child node of element identiﬁed by syncId.
ReplaceChildren( syncId, models )
Replace child nodes of element identiﬁed by syncId with
children described in models.
WatchEvent( syncId, type, phase )
Register a listener for event type and phase (bubble / capture)
on element identiﬁed by syncId.
Table 2:
shadow pages via DOM postMessage() API.
Synchronization messages sent between real and
work instructed the browser (via Cache-Control HTTP
headers) not to cache a resource, or per-origin cache par-
titioning [19] is in effect.
Impressions will be generated when the ad is rendered
on the real page. Therefore, when ad content is initially
rendered on the shadow page, we must prevent the brow-
ser from submitting HTTP requests for external resources,
as that would cause superﬂuous impressions. Our imple-
mentation supports conserving impression counts for the
following elements in our whitelist: , 
and  (Flash). Additionally we conserve im-
pression counts for background image CSS properties
in our whitelist: background, background- image,
list-style and list-style-image.
To prevent ad impressions on the shadow page, we in-
terpose on the common interfaces ad scripts use to cre-
ate content. First, we hook DOM object prototype in-
terfaces [25] to prevent ad scripts from setting URI at-
tributes. For instance, we interpose on the src property
of HTMLImageElement objects, and getAttribute()
and setAttribute() DOM methods.
We also
hook other interfaces that access URI attributes, such
as document.write(), document.writeln(), and
element.innerHTML,
to increase completeness and
transparency of the interposition.
When ad script writes a URI attribute using one of these
APIs, we substitute the real URI value with a placeholder
value. For write(), writeln(), and innerHTML, this
substitution requires a character search and replace in
HTML source code. Our current implementation of this
operation makes use of regular expression based textual
transformation, which works well in practice, but may not
be very precise under all circumstances. As the purpose
of this substitution is to conserve ad impressions, a loss
in precision here may affect compatibility with ads, but
not security. If more precision is required, works on in-
browser source-to-source HTML transformation [14, 34]
can be leveraged, at the cost of additional overhead.
One exception we make to the above scheme is for
 elements. Our interposition does not block the
setting of src attributes for scripts, because our goal is to
enable ad scripts to execute in the shadow page. Thus
scripts are the only source of ad impressions from the
shadow page. Since our policy enforcement mechanism
prevents ad scripts in the real page, each script is created
only once, thereby conserving the number of ad impres-
sions.
4.3.2 Content mirroring
We mirror ad content from the shadow page to the real
page using a 5-step process: (1) monitoring the shadow
page for modiﬁcations by the ad script, (2) modeling the
detected modiﬁcations, (3) sending the model to the real
page, (4) enforcing policies on the model, and (5) modi-
fying the real page to reﬂect the model.
1. Monitoring the shadow page for modiﬁcations
We monitor the shadow page for dynamic modiﬁcations
using DOM interposition logic (introduced in §4.3.1).
In addition to APIs that affect element attributes, we
also hook APIs that modify the document, such as
element.appendChild(). Whenever ad script attaches
a new DOM node using appendChild(), our monitoring
code is invoked before the actual modiﬁcation takes place.
Alternatively, DOM mutation events [51] can be leveraged
to perform the same monitoring function with lower com-
plexity than DOM interposition. However, Internet Ex-
plorer does not yet support mutation events, which would
result in decreased compatibility.
2. Modeling the detected modiﬁcations When modiﬁ-
cations to the shadow page are detected, we encode those
10
into the real page during this process, we leverage
the techniques we developed in BLUEPRINT [46] to
enforce a no-script policy over all merged changes.
This entails protecting several script injection vectors,
including  elements, event handler attributes,
javascript: URI schemes, CSS expressions, and
more.
Mirroring ad content on the real page has the side-effect
of modifying the real page script execution environment.
For instance, elements such as  can pollute the namespace by creating properties
such as document.elements.query. A straightfor-
ward solution to this problem is disallowing name and id
attributes on mirrored ad content; however, this may re-
duce compatibility with some ads.
4.3.3 Event forwarding
To prevent code injection attacks during content mirror-
ing, our whitelist intentionally omits event handlers such
as onclick and onmouseover that have been attached to
ad content. In order to preserve event handler functional-
ity in spite of this restriction, we perform event forward-
ing.
Event forwarding leverages our DOM interposition
framework. We interpose on script operations used to
register event handlers such as handler attributes and
object properties (e.g., onclick, onload, etc.), us-
ing the same mechanism used for URI attributes and
properties described in §4.3.1. Additionally, browser-
speciﬁc APIs such as element.addEventListener()
and element.attachEvent() are detected and inter-
posed on when present.
When ad script uses any of these APIs to register an
event handler on an element, and that element is also mir-
rored on the real page, we register our own handler for
the same event on the mirrored element. Event handlers
are registered on the real page when speciﬁed in con-
tent models (InsertNode() and ReplaceChildren()
messages), or by sending the WatchEvent() message of
Table 2. Whenever the event occurs on the real page, our
handler is invoked and sends details of the event to the
shadow page using the DispatchEvent() message (in-
on Figure 3). On the shadow page we
dicated by path
establish the appropriate JavaScript scope, then dispatch
the event to the target element. This in turn invokes the
ad script’s original event handler. Effects caused by the ad
script’s handler are detected and mirrored back to the real
page using the mechanism described in §4.3.2.
Ad clicks Unlike other user interface events, we do not
forward click events on  (link) elements. Instead we
click (i.e., activate) links on the real page, subject to en-
forcement of the link-target permission. This has
the effect of bypassing any click event handlers the ad
script may have registered on the activated link. There-
fore there can be a compatibility trade-off in enforcing the
11
Figure 6: Rendering an ad image only on the real page so that
just one impression is generated.
changes using the same model format described in §4.2
and depicted in Figure 5. However, when we ﬁnd content
that was substituted by our interposition (ref. §4.3.1), we
model the ad script’s intended content instead of the sub-
stituted content. Models are passed to the real page, where
the modiﬁcations will be reﬂected to the extent allowed by
policies.
3. Sending models to the real page The process of send-
ing a model of an image element is depicted in Figure 6.
In the shadow page, we serialize the model data structure
to a JSON string. We send the serialized model from the
shadow page to the real page using the InsertNode()
message from Table 2b. (Other types of modiﬁcations use
the additional postMessage() notiﬁcations listed in Ta-
ble 2b.) On the receiving end (i.e., the real page), we de-
serialize the string to recover the model data structure.
4. Enforcing policies on the models Our policy enforce-
ment code in the real page receives the model from the
shadow page. The model is then checked for any content
that violates the real page policy annotations. We trim
all policy-violating content from the model. For instance,
if the model describes an image to be added to the page
where the enable-images permission is denied, then we
remove the image from the model. If the model describes
an ad that is 1000 pixels wide and the policy only allows
the ad to be 600 px, we allow the ad but restrict its maxi-
mum width to 600 px.
5. Modifying the real page to reﬂect the mod-
eled changes
changes
represented by the model
into the real page. We
create or modify constructs using DOM APIs, such
as
element
.setAttribute(). To ensure scripts are not injected
document.createElement()
Finally we merge
and
the
SALEShadow Page(hidden)Ad Image (valid src)Mirrored AdContent ModelImage Node(invalid src)AdpostMessage()ChannelReal Page3link-target permission if the ad script depends on such
event handlers.
4.3.4 Position and style synchronization
Some ads mimic the appearance of a pop-up window by
temporarily overlaying parts of the web page. Although
the pop-up window can appear at variable locations on the
page, typically it is positioned such that it is visible (given
the portion of the page that is scrolled into view) and rela-
tive to some other content (such as a contextual keyword).
The ad script contains logic to compute the pop-up loca-
tion based on the above criteria. However, if content ap-
pears at a different location on the real page than it does on
the shadow page, the pop-up will be positioned incorrectly
when mirrored. For this reason we support synchroniz-
ing the visual aspect of both real and shadow pages, even
though the shadow page remains hidden.
First, we keep the window sizes of each page synchro-
nized by setting the shadow page size to 100% of the real
page size. Second, we sync the scroll position of both
pages by registering an event handler for the real page’s
onscroll event. Whenever the event ﬁres, we send a
SetScrollPos() message to the shadow page. Our code
running in the shadow page receives this message and ad-
justs the shadow page vertical and horizontal scroll offsets
to match the real page.
Next we have to ensure content on the shadow page oc-
cupies the same location and extent as the corresponding
content on the real page. For example, consider the in-
line text ad (Figure 1, #3), which highlights keywords and
makes a pop-up appear near a keyword when the user’s
mouse hovers over it. The precise location of the key-
word depends on many things, such as the absolute co-
ordinates of the element containing the text, height and
width of the container element, font size of the text, di-
mensions / layout of other content in the container, and
more. We synchronize these details by sending the abso-
lute position, size and computed style of each mirrored el-
ement to the shadow page via the SetStyle() message.
On the shadow page we apply these properties to content
elements, while keeping record that these are not “authen-
tic” properties that should be synchronized back to the real
page during any future content mirroring operations.
This strategy works very well in practice but is not per-
fect. For instance, there may be text in the real page that
ﬂows around an image. If the policy in effect for the text
content allows read access, and the image is not readable,
then the image will not appear on the shadow page and
thus the text will not ﬂow in the same way. To resolve
issues due to the layout becoming out of sync, the pub-
lisher can either make the image readable or customize
the shadow page to more accurately reﬂect the real page.
5 Evaluation
We evaluated ADJAIL to assess performance in three ma-
jor areas. In §5.1 we investigate the compatibility of our
architecture with six popular ad networks, each of which
serve a variety of ads. The security of our approach is
tested in §5.2. We then measure ad display latencies in
§5.3. Although many ad networks exist which were not
tested, we believe the relatively small sample we evalu-
ated offer good insights into the compatibility and perfor-
mance of ADJAIL.
5.1 Compatibility
To evaluate how well ADJAIL works with existing ad
scripts, we tested it on six popular ad networks: Yahoo!
Network, Google AdSense, Microsoft Media Network,
Federated Media Publishing, AdBrite and Clicksor. The
ﬁrst four used banner ads, while the latter two employed
more complicated inline text ads. Yahoo!, Google and Mi-
crosoft were three of the top ten ad networks in terms of
U.S. market reach in April 2009. With a total audience
size of 192.8 million, Yahoo! reached 86.6% of the mar-
ket, Google reached 85.3%, and Microsoft reached 72.4%
[3].
Federated Media, AdBrite and Clicksor rank lower in
terms of U.S. market reach (e.g., AdBrite ranked #21
with a reach of 47.2%), but were chosen as they repre-
sent the small publisher market and demonstrate unique
functionality. They are not as pervasive, therefore they
are more likely to exhibit compatibility problems and less
tested features. In our experiments we focused on the fol-
lowing observations: whether the ad functioned correctly,
the minimum permissions required to support the ad, and
whether click and impression counts were affected by our
approach.
Our prototype ADJAIL implementation is a sufﬁcient
proof-of-concept to demonstrate the feasibility of our ap-
proach. The prototype is designed and tested to work on
recent releases of the Chrome, Firefox, Internet Explorer,
Opera and Safari web browsers. It does not yet have the
level of reﬁnement that would be present in a production
system, which exposes some compatibility limitations we
describe below.
Correct functionality To evaluate correct functionality
we embedded ad scripts from each ad network in a series
of ADJAIL test pages, then compared the user experience
to the same ad scripts when used without sandboxing. The
four banner ad scripts (Yahoo!, Google, Microsoft and
Federated) all made use of the default ad zone feature. In
this experiment we observed two main types of ad banner:
animated image and Flash.
All of the banner ads rendered on the real page with-
out any noticeable differences from rendering the ad with-
out ADJAIL.
Interacting with Flash ads via the mouse
and clicking on banners worked exactly the same as the
12
non-sandboxed ads. One minor issue we are aware of
is that the contextual targeting approach used by Google
AdSense does not work with our current implementation.
This is because AdSense performs contextual targeting
on the server, using an ofﬂine cached copy of the pub-
lisher’s page. This limitation can be overcome by pro-
viding pre-computed shadow pages to ad networks who
perform server-side contextual targeting, like AdSense.
For each of the inline text ad scripts (AdBrite and Click-
sor), we annotated a news article with a full read and
write access policy. The ad scripts identiﬁed keywords in