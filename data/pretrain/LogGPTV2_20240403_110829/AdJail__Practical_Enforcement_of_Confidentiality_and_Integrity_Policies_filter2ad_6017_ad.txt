### 4.3.1 初始化通信通道（两步）

#### 插入节点
- **函数**: `InsertNode(syncId, index, model)`
- **描述**: 根据`model`描述，将节点插入到`syncId`标识的元素的子节点`index`位置。

#### 修改属性
- **函数**: `ModifyAttribute(syncId, name, value)`
- **描述**: 将`syncId`标识的元素的属性`name`设置为`value`。

#### 修改样式
- **函数**: `ModifyStyle(syncId, name, value, priority)`
- **描述**: 将`syncId`标识的元素的CSS属性`name`设置为`value`，并设置优先级`priority`。

#### 修改文本
- **函数**: `ModifyText(syncId, index, data)`
- **描述**: 将`syncId`标识的元素的子节点`index`的文本内容设置为`data`。

#### 移除节点
- **函数**: `RemoveNode(syncId, index)`
- **描述**: 移除`syncId`标识的元素的子节点`index`。

#### 替换子节点
- **函数**: `ReplaceChildren(syncId, models)`
- **描述**: 用`models`描述的新子节点替换`syncId`标识的元素的所有子节点。

#### 监听事件
- **函数**: `WatchEvent(syncId, type, phase)`
- **描述**: 在`syncId`标识的元素上注册一个监听器，用于监听类型为`type`、阶段为`bubble`或`capture`的事件。

### 表2: 通过DOM postMessage() API实现阴影页面和真实页面之间的同步消息传递

为了确保浏览器不会对资源进行缓存，我们通过`Cache-Control` HTTP头指示浏览器不要缓存资源，或者使用每个源的缓存分区。当广告内容在阴影页面上初次渲染时，我们必须防止浏览器发送HTTP请求以获取外部资源，从而避免不必要的展示次数。我们的实现支持保存以下白名单中元素的展示次数：`<img>`、`<iframe>` 和 `<object>` (Flash)。此外，我们还保存了背景图片CSS属性的展示次数，包括：`background`、`background-image`、`list-style` 和 `list-style-image`。

为了防止在阴影页面上产生广告展示次数，我们拦截了广告脚本常用的创建内容接口。首先，我们钩住了DOM对象原型接口，以防止广告脚本设置URI属性。例如，我们拦截了`HTMLImageElement`对象的`src`属性以及`getAttribute()`和`setAttribute()`方法。我们还拦截了其他访问URI属性的接口，如`document.write()`、`document.writeln()` 和 `element.innerHTML`，以提高拦截的完整性和透明度。

当广告脚本使用这些API之一写入URI属性时，我们将真实的URI值替换为占位符值。对于`write()`、`writeln()` 和 `innerHTML`，这种替换需要在HTML源代码中进行字符搜索和替换。我们当前的实现使用基于正则表达式的文本转换，这在实践中效果良好，但在某些情况下可能不够精确。由于这种替换的目的是节省广告展示次数，精度损失可能会影响广告的兼容性，但不会影响安全性。如果需要更高的精度，可以利用浏览器中的源到源HTML转换技术 [14, 34]，但这会增加额外的开销。

我们对上述方案的一个例外是`<script>`元素。我们的拦截不阻止设置`<script>`元素的`src`属性，因为我们的目标是使广告脚本在阴影页面上执行。因此，脚本是阴影页面上唯一产生广告展示次数的来源。由于我们的策略执行机制防止了真实页面上的广告脚本，每个脚本只创建一次，从而节省了广告展示次数。

### 4.3.2 内容镜像

我们通过以下五步过程将广告内容从阴影页面镜像到真实页面：
1. **监控阴影页面的修改**：我们使用DOM拦截逻辑（见§4.3.1）监控阴影页面的动态修改。除了影响元素属性的API外，我们还钩住了修改文档的API，如`element.appendChild()`。每当广告脚本使用`appendChild()`附加一个新的DOM节点时，我们的监控代码会在实际修改发生之前被调用。
2. **建模检测到的修改**：当检测到阴影页面的修改时，我们将这些修改编码为模型。在这个过程中，我们利用BLUEPRINT [46]中开发的技术来强制执行无脚本策略。这包括保护多个脚本注入向量，如`<script>`元素、事件处理程序属性、`javascript:` URI方案、CSS表达式等。
3. **将模型发送到真实页面**：我们将模型数据结构序列化为JSON字符串，并使用`InsertNode()`消息从阴影页面发送到真实页面。接收端（即真实页面）反序列化字符串以恢复模型数据结构。
4. **在模型上执行策略**：真实页面中的策略执行代码接收到模型后，检查是否有违反策略的内容。我们删除所有违反策略的内容。例如，如果模型描述了一个要在页面上添加的图像，而`enable-images`权限被拒绝，则我们从模型中移除该图像。
5. **修改真实页面以反映模型更改**：最后，我们将模型表示的更改合并到真实页面中。我们使用DOM API创建或修改元素，如`element.setAttribute()`和`document.createElement()`，以确保不会注入脚本。

### 4.3.3 事件转发

为了避免在内容镜像过程中发生代码注入攻击，我们的白名单故意省略了附着在广告内容上的事件处理程序，如`onclick`和`onmouseover`。为了在这一限制下保留事件处理程序的功能，我们进行了事件转发。

事件转发利用了我们的DOM拦截框架。我们拦截了用于注册事件处理程序的脚本操作，如处理程序属性和对象属性（例如`onclick`、`onload`等），使用与URI属性和属性相同的机制。此外，我们还检测并拦截了特定于浏览器的API，如`element.addEventListener()`和`element.attachEvent()`。

当广告脚本使用这些API之一在某个元素上注册事件处理程序，并且该元素也在真实页面上被镜像时，我们在镜像元素上注册自己的处理程序。事件处理程序在指定内容模型（`InsertNode()`和`ReplaceChildren()`消息）时在真实页面上注册，或者通过发送表2中的`WatchEvent()`消息注册。每当真实页面上发生事件时，我们的处理程序被调用，并将事件详情发送到阴影页面。在阴影页面上，我们建立适当的JavaScript作用域，然后将事件分派给目标元素，从而调用广告脚本的原始事件处理程序。由广告脚本处理程序引起的效果通过§4.3.2中描述的机制检测并镜像回真实页面。

**广告点击**：与其他用户界面事件不同，我们不会转发`<a>`（链接）元素上的点击事件。相反，我们在真实页面上点击（即激活）链接，受链接目标权限的约束。这会绕过广告脚本在激活链接上可能注册的任何点击事件处理程序。因此，在执行链接目标权限时可能会有兼容性权衡。

### 4.3.4 位置和样式同步

一些广告通过临时覆盖网页的部分内容来模仿弹出窗口的外观。尽管弹出窗口可以在页面的不同位置出现，但它通常会被定位在可见区域（根据滚动到视图中的部分）并且相对于某些其他内容（如上下文关键字）。广告脚本包含计算弹出位置的逻辑。然而，如果内容在真实页面和阴影页面上的位置不同，镜像后的弹出窗口将会被错误定位。因此，我们支持同步真实页面和阴影页面的视觉方面，即使阴影页面保持隐藏状态。

首先，我们通过将阴影页面的大小设置为真实页面大小的100%来保持两个页面的窗口大小同步。其次，我们通过注册真实页面的`onscroll`事件处理程序来同步两个页面的滚动位置。每当事件触发时，我们发送`SetScrollPos()`消息到阴影页面。运行在阴影页面上的代码接收到该消息后，调整阴影页面的垂直和水平滚动偏移量以匹配真实页面。

接下来，我们必须确保阴影页面上的内容占据与真实页面上相应内容相同的位置和范围。例如，考虑内联文本广告（图1，#3），它高亮显示关键词并在用户鼠标悬停在关键词上时显示弹出窗口。关键词的确切位置取决于许多因素，如包含文本的元素的绝对坐标、容器元素的高度和宽度、文本的字体大小、容器中其他内容的尺寸/布局等。我们通过发送每个镜像元素的绝对位置、大小和计算样式到阴影页面来同步这些细节。在阴影页面上，我们将这些属性应用于内容元素，并记录这些不是应该在未来的内容镜像操作中同步回真实页面的“真实”属性。

这种方法在实践中效果很好，但并不完美。例如，真实页面中可能存在环绕图像的文本。如果对文本内容的策略允许读取访问，而图像不可读，则图像不会出现在阴影页面上，因此文本不会以相同的方式流动。为了解决布局不同步的问题，发布者可以要么使图像可读，要么自定义阴影页面以更准确地反映真实页面。

### 5 评估

我们评估了ADJAIL在三个主要方面的性能。在§5.1中，我们调查了我们的架构与六个流行广告网络的兼容性，每个广告网络都提供各种广告。在§5.2中，我们测试了我们的方法的安全性。然后在§5.3中测量了广告显示延迟。虽然存在许多未测试的广告网络，但我们相信我们评估的小样本提供了对ADJAIL兼容性和性能的良好见解。

### 5.1 兼容性

为了评估ADJAIL与现有广告脚本的兼容性，我们在六个流行的广告网络上进行了测试：雅虎网络、Google AdSense、微软媒体网络、联合媒体出版、AdBrite和Clicksor。前四个使用横幅广告，而后两个使用更复杂的内联文本广告。雅虎、谷歌和微软是2009年4月美国市场覆盖率前十的广告网络。雅虎的总受众规模为1.928亿，覆盖了86.6%的市场，谷歌覆盖了85.3%，微软覆盖了72.4% [3]。

联合媒体、AdBrite和Clicksor在美国市场的覆盖率较低（例如，AdBrite排名第21位，覆盖率为47.2%），但它们代表了小型发布商市场，并展示了独特的功能。它们不如前三大广告网络普及，因此更容易出现兼容性问题和较少测试的功能。在实验中，我们重点关注以下观察结果：广告是否正常工作，支持广告所需的最小权限，以及我们的方法是否影响点击和展示次数。

我们的ADJAIL原型实现是一个充分的概念验证，证明了我们方法的可行性。该原型设计并测试了在最新版本的Chrome、Firefox、Internet Explorer、Opera和Safari Web浏览器上工作。它还没有达到生产系统应有的精细程度，这暴露了一些我们在下面描述的兼容性限制。

**正确功能**：为了评估正确功能，我们在一系列ADJAIL测试页面中嵌入了每个广告网络的广告脚本，然后将其用户体验与没有沙箱化的同一广告脚本进行比较。四个横幅广告脚本（雅虎、谷歌、微软和联合媒体）都使用了默认广告区域功能。在这个实验中，我们观察到了两种主要类型的广告横幅：动画图像和Flash。

所有的横幅广告在真实页面上渲染，没有任何明显的差异。通过鼠标与Flash广告交互并点击横幅的行为与非沙箱化广告完全相同。我们注意到的一个小问题是，谷歌AdSense使用的上下文定位方法在我们当前的实现中不起作用。这是因为AdSense在服务器端使用离线缓存的发布者页面进行上下文定位。这个限制可以通过为执行服务器端上下文定位的广告网络（如AdSense）提供预先计算的阴影页面来克服。

对于每个内联文本广告脚本（AdBrite和Clicksor），我们将一篇新闻文章注释为具有完整的读写访问权限。广告脚本识别了文章中的关键词，并在关键词周围插入了广告链接。