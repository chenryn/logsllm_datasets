âˆ™ ğ¶â€² = ğ¶, or
âˆ™ ğ¶ = ğ¶0 â‹™ ğ¶1 and ğ¶â€² is a sub-circuit of ğ¶0 or ğ¶1, or
âˆ™ ğ¶ = ğ…ğ¢ğ«ğ¬ğ­(ğ¶0) and ğ¶â€² is a sub-circuit of ğ¶0.
Example 1. To illustrate our circuit notation, consider the
function ğ‘“((ğ‘¥, ğ‘¦), ğ‘§) = (ğ‘¥âˆ§ ğ‘¦, ğ‘¦ â†’ ğ‘§), where ğ‘¦ â†’ ğ‘§ â‰¡ Â¬ğ‘¦âˆ¨ ğ‘§ is
the logical implication operation. First we deï¬ne an operation
153
ğ‘¥
ğ‘¦
ğ‘§
A
D
U
â†‘ D
â†‘
ğ€ğ§ğ
(ğ‘¥ âˆ§ ğ‘¦)
âˆ™ ğ™¶ğ™´ğšŸğšŠğš•( Ìƒğ¶, Ìƒğ‘¥) = ğ‘¦: The garbled circuit evaluation algo-
rithm takes a garbled circuit Ìƒğ¶ and a garbled input Ìƒğ‘¥ as
input, and it produces a boolean vector ğ‘¦ as output.
D â†‘
â†‘
(ğ‘¦ â†’ ğ‘§)
ğˆğ¦ğ©
Deï¬nition 6 (Correctness and security). For a garbling
scheme (ğ™¶ğšŠğš›ğš‹ğš•ğš, ğ™¶ğ™´ğšŸğšŠğš•), we say that
Fig. 5. The circuit that computes the function ğ‘“((ğ‘¥, ğ‘¦), ğ‘§) = (ğ‘¥ âˆ§ ğ‘¦, ğ‘¦ â†’ ğ‘§).
ğ’ğğœğ¨ğ§ğ on circuits such that ğ’ğğœğ¨ğ§ğ(ğ¶) is a circuit that takes
as input a wire bundle (ğ‘¢, ğ‘£) and produces as output a bundle
(ğ‘¢, ğ‘¤), where ğ‘£ is the input of ğ¶ and ğ‘¤ is the output of ğ¶:
ğ’ğğœğ¨ğ§ğ(ğ¶) = ğ’ğ°ğšğ© â‹™ ğ…ğ¢ğ«ğ¬ğ­(ğ¶) â‹™ ğ’ğ°ğšğ©
Since ğ‘¥ â†‘ ğ‘¥ = Â¬ğ‘¥,
the circuit ğğ¨ğ­ = ğƒğ®ğ© â‹™ ğğ€ğ§ğ
computes the negation of an input bit, and the circuit ğ€ğ§ğ =
ğğ€ğ§ğ â‹™ ğğ¨ğ­ = ğğ€ğ§ğ â‹™ ğƒğ®ğ© â‹™ ğğ€ğ§ğ computes the
function (ğ‘¥, ğ‘¦) â†¦ (ğ‘¥âˆ§ğ‘¦). Since ğ‘¦ â†’ ğ‘§ = (Â¬ğ‘¦)âˆ¨ğ‘§ = ğ‘¦â†‘(Â¬ğ‘§), the
circuit ğˆğ¦ğ© = ğ’ğğœğ¨ğ§ğ(ğğ¨ğ­) â‹™ ğğ€ğ§ğ computes the function
(ğ‘¦, ğ‘§) â†¦ (ğ‘¦ â†’ ğ‘§). Putting them together, we obtain a circuit
ğ¶ = ğ…ğ¢ğ«ğ¬ğ­(ğ’ğğœğ¨ğ§ğ(ğƒğ®ğ©) â‹™ ğ€ğ¬ğ¬ğ¨ğœ) â‹™ ğ”ğ§ğšğ¬ğ¬ğ¨ğœ
â‹™ ğ…ğ¢ğ«ğ¬ğ­(ğ€ğ§ğ) â‹™ ğ’ğğœğ¨ğ§ğ(ğˆğ¦ğ©)
for the function ğ‘“((ğ‘¥, ğ‘¦), ğ‘§) = (ğ‘¥ âˆ§ ğ‘¦, ğ‘¦ â†’ ğ‘§), illustrated graph-
ically in Fig. 5. Notice how the ï¬rst part of the computation
consisting of the ğƒğ®ğ©, ğ€ğ¬ğ¬ğ¨ğœ and ğ”ğ§ğšğ¬ğ¬ğ¨ğœ gates is used to
route the input wires to the appropriate subcircuit.
Remark 1. With our circuit notation, a circuit with ğ‘ gates and
ğ‘ wires can be represented using a string of size ğ‘‚(ğ‘ğ‘‘ log ğ‘),
where ğ‘‘ is the depth of the circuit. We can convert
the
traditional DAG-like circuit notation to our inductive circuit
representation by organizing gates into layers according to
their depth. For a layer with ğ‘ğ‘– gates, the computation of
these gates can be described using ğ‘ğ‘– log ğ‘ğ‘– many ğ…ğ¢ğ«ğ¬ğ­ and
ğ’ğğœğ¨ğ§ğ operations together with ğ‘ğ‘– basic circuits. To rearrange
wires after a layer of ğ‘ğ‘– gates, we can add ğ‘‚(ğ‘ğ‘– log ğ‘ğ‘–) many
ğ’ğ°ğšğ©, ğ€ğ¬ğ¬ğ¨ğœ, and ğ”ğ§ğšğ¬ğ¬ğ¨ğœ gates. The entire circuit can be
concatenated from layers using â‹™ operations. So the size of
such representation is ğ‘‚(ğ‘ğ‘‘ log ğ‘).
âˆ™
âˆ™
is correct
if ğ™¶ğ™´ğšŸğšŠğš•(ğ™¶ğšŠğš›ğš‹ğš•ğš(ğ¶, ğ‘¥)) = ğ¶(ğ‘¥) for all
it
circuits ğ¶ and boolean vectors ğ‘¥;
it is (selectively) secure if there exists a PPT simulator
ğš‚ğš’ğš–ğšğš•ğšŠğšğš(â‹…, â‹…) such that for any circuit ğ¶ and input ğ‘¥, the
distributions ğš‚ğš’ğš–ğšğš•ğšŠğšğš(ğ¶, ğ¶(ğ‘¥)) and ğ™¶ğšŠğš›ğš‹ğš•ğš(ğ¶, ğ‘¥) are
computationally indistinguishable.
Strictly speaking, a simulator should not gain access to a
circuit, and instead, it should take the topology of a circuit
as input. To simplify discussion, we use the actual circuit
as its topology representation rather than introducing new
notations. This can be justiï¬ed by the facts that 1) there is only
one primitive gate in our circuit notation, namely the NAND
gate, and 2) our simulator (deï¬ned later) does not exploit the
function computed by the NAND gate.
i) Symbolic garbled circuit: We consider garbling
schemes where the output of all algorithms ğ™¶ğšŠğš›ğš‹ğš•ğš, ğ™¶ğ™´ğšŸğšŠğš•,
and ğš‚ğš’ğš–ğšğš•ğšŠğšğš are expressions in our symbolic language
ğ„ğ±ğ©. This will allow us to analyze both the correctness
and security properties of the scheme in a purely symbolic
manner, without resorting to the power (and complications)
of the full computational model of cryptography. The circuit
garbling construction described here is essentially the one with
the point-and-permute technique as described in [36]. In this
section we present ğ™¶ğšŠğš›ğš‹ğš•ğš and ğ™¶ğ™´ğšŸğšŠğš•, and we will deï¬ne
ğš‚ğš’ğš–ğšğš•ğšŠğšğš and prove security in the next section.
Let ğœ– denote a special symbolic expression whose compu-
tational evaluation is the empty string. We slightly change the
notation of atomic key symbols by using both subscripts and
superscripts to index them: an atomic key is a symbol ğ–ªğ‘—
ğ‘–
where ğ‘– âˆˆ {1, 2, â€¦} and ğ‘— âˆˆ {0, 1}. With this notation, the
set of atomic keys is now ğŠ = {ğ–ª0
, â€¦}. To hide
1
the input of a circuit, the garbling algorithm encodes values
carried on wires using labels of shape â¦‡ğ”¹, â¦‡ğ•‚, ğ•‚â¦ˆâ¦ˆ, one for
each wire. We call a bundle of labels a label expression.
Formally, we ï¬rst deï¬ne a function ğ™»ğšŠğš‹ğšğš• that on input a
, ğ–ª0
2
, ğ–ª1
1
, ğ–ª1
2
IV. SYMBOLIC GARBLING
bundle shape ğ‘ , outputs a collection of wire labels:
Let us ï¬rst recall the deï¬nition of circuit garbling schemes
in the computational setting [9], [24].
Deï¬nition 5 (Syntax). A garbling scheme is deï¬ned by a pair
of PPT algorithms (ğ™¶ğšŠğš›ğš‹ğš•ğš, ğ™¶ğ™´ğšŸğšŠğš•)3 where
âˆ™ ğ™¶ğšŠğš›ğš‹ğš•ğš(ğ¶, ğ‘¥) = ( Ìƒğ¶, Ìƒğ‘¥): The circuit garbling algorithm
takes a circuit ğ¶ and a boolean vector ğ‘¥ as input, and it
produces a garbled circuit Ìƒğ¶ and a garbled input Ìƒğ‘¥.
3Usually
a
scheme
consists
algorithms
garbling
(ğ™¶ğ™²ğš’ğš›ğšŒğšğš’ğš, ğ™¶ğ™¸ğš—ğš™ğšğš, ğ™¶ğ™´ğšŸğšŠğš•) such that ğ™¶ğ™²ğš’ğš›ğšŒğšğš’ğš(ğ¶) = ( Ìƒğ¶, ğ¿) produces
Ìƒğ¶ and labels ğ¿ for the input wires, and ğ™¶ğ™¸ğš—ğš™ğšğš(ğ¿, ğ‘¥) = Ìƒğ‘¥
a garbled circuit
produces garbled input Ìƒğ‘¥ using the labels. Such a syntax is useful to deï¬ne
adaptive security. However, we choose a simpliï¬ed syntax of two algorithms
that is suï¬ƒcient to deï¬ne selective security and convenient for our analysis.
three
of
ğ™»ğšŠğš‹ğšğš•(â—¦) = (ğ–¡â„, (ğ–ª0
, ğ–ª1
â„)) where
â„
â„ â† new
ğ™»ğšŠğš‹ğšğš•((ğ‘ , ğ‘¡)) = (ğ™»ğšŠğš‹ğšğš•(ğ‘ ), ğ™»ğšŠğš‹ğšğš•(ğ‘¡))
The instruction â„ â† new picks a fresh index â„ (e.g., using a
counter), used to deï¬ne a new symbolic label (ğ–¡â„, (ğ–ª0
â„)).
A garbled input has two parts: an encoded input expression
that is a bundle of shape (ğ”¹, ğ•‚), and an output mask expression
that is a bundle of bits. The function ğ™¶ğ™´ğš—ğšŒ encodes a boolean
vector using bits and keys in a label expression:
, ğ–ª1
â„
ğ™¶ğ™´ğš—ğšŒ((ğ–¡, (ğ–ª0, ğ–ª1)), 0) = (ğ–¡, ğ–ª0)
ğ™¶ğ™´ğš—ğšŒ((ğ–¡, (ğ–ª0, ğ–ª1)), 1) = (Â¬ğ–¡, ğ–ª1)
ğ™¶ğ™´ğš—ğšŒ((ğ¿0, ğ¿1), (ğ‘¥0, ğ‘¥1)) = (ğ™¶ğ™´ğš—ğšŒ(ğ¿0, ğ‘¥0), ğ™¶ğ™´ğš—ğšŒ(ğ¿1, ğ‘¥1))
154
The output masks are used to decode an encoded expression.
It is formed by the bits in a label expression:
ğ™¶ğ™¼ğšŠğšœğš”((ğ–¡, (ğ–ª0, ğ–ª1))) = ğ–¡
ğ™¶ğ™¼ğšŠğšœğš”((ğ¿0, ğ¿1)) = (ğ™¶ğ™¼ğšŠğšœğš”(ğ¿0), ğ™¶ğ™¼ğšŠğšœğš”(ğ¿1))
The core of the garbling algorithm is a recursive function
ğ™¶ğš‹, which takes as input a circuit and a label expression for the
input wires, and outputs a symbolic expression of the garbled
circuit and a label expression for the output wires.
ğ™¶ğš‹ :: Circuit(ğ‘ , ğ‘¡) Ã— ğ„ğ±ğ© â†’ ğ„ğ±ğ© Ã— ğ„ğ±ğ©
ğ™¶ğš‹(ğ’ğ°ğšğ©, (ğ‘¢, ğ‘£)) = ğœ–, (ğ‘£, ğ‘¢)
ğ™¶ğš‹(ğ€ğ¬ğ¬ğ¨ğœ, (ğ‘¢, (ğ‘£, ğ‘¤))) = ğœ–, ((ğ‘¢, ğ‘£), ğ‘¤)
ğ™¶ğš‹(ğ”ğ§ğšğ¬ğ¬ğ¨ğœ, ((ğ‘¢, ğ‘£), ğ‘¤)) = ğœ–, (ğ‘¢, (ğ‘£, ğ‘¤))
ğ™¶ğš‹(ğ¶0 â‹™ ğ¶1, ğ‘¢) = ( Ìƒğ¶0, Ìƒğ¶1), ğ‘£ where
Ìƒğ¶0, ğ‘¤ = ğ™¶ğš‹(ğ¶0, ğ‘¢)
Ìƒğ¶1, ğ‘£ = ğ™¶ğš‹(ğ¶1, ğ‘¤)
ğ™¶ğš‹(ğ…ğ¢ğ«ğ¬ğ­(ğ¶), (ğ‘¢, ğ‘¤)) = Ìƒğ¶, (ğ‘£, ğ‘¤) where
Ìƒğ¶, ğ‘£ = ğ™¶ğš‹(ğ¶, ğ‘¢)
ğ™¶ğš‹(ğƒğ®ğ©, (ğ‘, (ğ‘˜0, ğ‘˜1))) = ğœ–, ğ‘¤ where
ğ‘¤ = ((ğ‘, ğ–¦0(ğ‘˜0), ğ–¦0(ğ‘˜1)), (ğ‘, ğ–¦1(ğ‘˜0), ğ–¦1(ğ‘˜1)))
ğ™¶ğš‹(ğğ€ğ§ğ, ((ğ‘ğ‘–, (ğ‘˜0
, ğ‘˜1
ğ‘– )), (ğ‘ğ‘—, (ğ‘˜0
ğ‘—
, ğ‘˜1
ğ‘—)))) = Ìƒğ¶, ğ‘¤ where
ğ‘–
â„ â† new
Ìƒğ¶ = ğœ‹[ğ‘ğ‘–](ğœ‹[ğ‘ğ‘—](â¦ƒâ¦ƒ(Â¬ğ–¡â„, ğ–ª1
â„)â¦„ğ‘˜0
ğœ‹[ğ‘ğ‘—](â¦ƒâ¦ƒ(Â¬ğ–¡â„, ğ–ª1
â„)â¦„ğ‘˜0
ğ‘—
â¦„ğ‘˜0
â¦„ğ‘˜1
ğ‘–
ğ‘–
ğ‘—
â„)â¦„ğ‘˜1
,â¦ƒâ¦ƒ(Â¬ğ–¡â„, ğ–ª1
â¦„ğ‘˜0
â¦„ğ‘˜1
,â¦ƒâ¦ƒ(ğ–¡â„, ğ–ª0
â„)â¦„ğ‘˜1
ğ‘—
ğ‘–
),
))
ğ‘—
ğ‘–
ğ‘¤ = (ğ–¡â„, (ğ–ª0
â„
, ğ–ª1