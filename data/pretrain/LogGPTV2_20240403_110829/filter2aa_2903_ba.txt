3.5.2 保护模式
保护模式下，中断和异常处理的核心数据结构是中断描述符表
（Interrupt Descriptor Table，IDT）。IDT的性质与IVT类似，但是格式
和特征有很多不同。
首先，与IVT的位置固定不同，IDT的位置是变化的。保护模式
中，CPU专门增加了一个名为IDTR寄存器来描述的IDT的位置和长度。
IDTR寄存器共有48位，高32位是IDT的基地址，低16位是IDT的长度
（limit）。为了访问IDTR寄存器，还增加了两条专用的指令：LIDT和
SIDT。LIDT（Load IDT）指令用于将操作数指定的基地址和长度加载
到IDTR寄存器中，也就是改写IDTR寄存器的内容。SIDT（Store IDT）
指令用于将IDTR寄存器的内容写到内存变量中，也就是将IDTR寄存器
的内容写到内存中去。LIDT和SIDT指令只能在实模式或保护模式的高
特权级（Ring 0）下执行。这是为了防止IDT被低权限的用户态程序所
破坏。在内核调试时，可以使用rigtr和rigtl命令观察IDTR寄存器的内
容。
通常，系统软件（操作系统或BIOS固件）在系统初始化阶段就准
备好中断处理例程和IDT，然后把IDT的位置通过IDTR（IDT Register）
告诉CPU。
在Windows操作系统中，IDT的初始化过程大致是这样的。IDT的最
初建立和初始化工作是由Windows系统的加载程序（NTLDR或
WinLoad）在实模式下完成的。在准备好一个内存块后，加载程序先执
行CLI指令关闭中断处理，然后执行LIDT指令将IDT的位置和长度信息
加载到CPU中，而后加载程序将CPU从实模式切换到保护模式，并将执
行权移交给NT内核的入口函数KiSystemStartup。接下来，内核中的处理
器初始化函数会通过SIDT指令取得IDT的信息，对其进行必要的调整，
然后以参数形式传递给KiInitializePcr函数，后者将其记录到描述处理器
的基本数据区PCR（Processor Control Region）和PRCB（Processor
Control Block）中。
以上介绍的过程都是发生在0号处理器中的，也就是所谓的
Bootstrap Processor，简称为BSP。因为即使是多CPU的系统，在把
NTLDR或WinLoad及执行权移交给内核的阶段都只有BSP在运行。在
BSP完成了内核初始化和执行体的阶段0初始化后，在阶段1初始化时，
BSP才会执行KeStartAllProcessors函数来初始化其他CPU，称为
AP（Application Processor）。对于每个AP，KeStartAllProcessors函数会
为其建立一个单独的处理器状态区，包括它的IDT，然后调用
KiInitProcessor函数，后者会根据启动CPU的IDT为要初始化的AP复制一
份，并做必要的修改。
在内核调试会话中，可以使用!pcr命令观察CPU的PCR内容，清单
3-2显示了Windows Vista系统中0号CPU的PCR内容。
清单3-2 观察处理器的控制区（PCR）
    kd> !pcr
KPCR for Processor 0 at 81969a00:      // KPCR结构的线性内存地址
   Major 1 Minor 1                     // KPCR结构的主版本号和子版本号
   NtTib.ExceptionList: 9f1d9644       // 异常处理注册链表
[…]                                    // 省略数行关于NTTIB的信息
          SelfPcr: 81969a00            // 本结构的起始地址
             Prcb: 81969b20            // KPRCB结构的地址
             Irql: 0000001f            // CPU的中断请求级别（IRQL）
              IRR: 00000000            //
              IDR: ffff20f0            //
    InterruptMode: 00000000            //
              IDT: 834da400            // IDT的基地址
              GDT: 834da000            // GDT的基地址
              TSS: 8013e000            // 任务状态段（TSS）的地址
    CurrentThread: 84af6270            // 当前在执行的线程，ETHREAD地址
       NextThread: 00000000            // 下一个准备执行的线程
       IdleThread: 8196cdc0            // IDLE线程的ETHREAD结构地址
内核数据结构KPCR描述了PCR内存区的布局，因此也可以使用dt
命令来观察PCR，例如kd> dt nt!_KPCR 81969a00。
虽然理论上IDT的长度是可变化的，但通常都将其设计为可以容纳
256个表项的固定长度。在32位模式下，每个IDT表项的长度是8个字
节，IDT的总长度是2048字节（2KB）。
IDT的每个表项是一个所谓的门描述符（Gate Descriptor）结构。之
所以这样称呼，是因为IDT表项的基本用途就是引领CPU从一个空间到
另一个空间去执行，每个表项好像是一个从一个空间进入到另一个空间
的大门（Gate）。在穿越这扇门时CPU会做必要的安全检查和准备工
作。
IDT可以包含以下3种门描述符。
任务门（task-gate）描述符：用于任务切换，里面包含用于选择任
务状态段（TSS）的段选择子。可以使用JMP或CALL指令通过任务
门来切换到任务门所指向的任务，当CPU因为中断或异常转移到任
务门时，也会切换到指定的任务。
中断门（interrupt-gate）描述符：用于描述中断处理例程的入口。
陷阱门（trap-gate）描述符：用于描述异常处理例程的入口。
图3-4描述了以上3种门描述的内容布局。
从图3-4中可以看出，3种描述符的格式非常相似，有很多共同的字
段。其中DPL代表描述符优先级（Descriptor Previlege Level），用于优
先级控制，P是段存在标志。段选择子用于选择一个段描述符（位于
LDT或GDT中，选择子的格式参见2.6.3节），偏移部分用来指定段中的
偏移，二者共同定义一个准确的内存位置，对于中断门和陷阱门，它们
指定的就是中断或异常处理例程的地址，对于任务门，它们指定的就是
任务状态段的内存地址。
图3-4 IDT中的3种门描述符
系统通过门描述符的类型字段，即高4字节的8～12位（共5位），
来区分一个描述符的种类。例如任务门的类型是0y00101（y代表二进制
数），中断门的类型是0y0D110，其中D位用来表示描述的是16位门
（0）还是32位门（1），陷阱门的类型是0y0D111。
有了以上基础后，下面我们看看当有中断或异常发生时，CPU是如
何通过IDT寻找和执行处理函数的。首先，CPU会根据其向量号码和
IDTR寄存器中的IDT基地址信息找到对应的门描述符。然后判断门描述
符的类型，如果是任务描述符，那么CPU会执行硬件方式的任务切换，
切换到这个描述符所定义的线程，如果是陷阱描述符或中断描述符，那
么CPU会在当前任务上下文中调用描述符所描述的处理例程。下面分别
加以讨论。
我们先来看任务门的情况。简单来说，任务门描述的是一个TSS
段，CPU要做的是切换到这个TSS段所代表的线程，然后开始执行这个
线程。TSS段是用来保存任务信息的一段内存区，其格式是CPU所定义
的。图3-5给出了IA-32 CPU的TSS段格式。从中我们看到TSS段中包含
了一个任务的关键上下文信息，如段寄存器、通用寄存器和控制寄存
器，其中特别值得注意的是靠下方的SS0～SS2和ESP0～ESP2字段，它
们记录着一项任务在不同优先级执行时所应使用的栈，SSx用来选择栈
所在的段，ESPx是栈指针值。
CPU在通过任务门的段选择子找到TSS段描述符后，会执行一系列
的检查动作，比如确保TSS段描述符中的存在标志是1，边界值应该大
于0x67，B（Busy）标志不为1等。所有检查都通过后，CPU会将当前任
务的状态保存到当前任务的TSS段中，然后把TSS段描述符中的B标志设
置为1。接下来，CPU要把新任务的段选择子（与门描述符中的段选择
子等值）加载到TR寄存器，然后把新任务的寄存器信息加载到物理寄
存器中。最后，CPU开始执行新的任务。
图3-5 32位的任务状态段（TSS）
下面通过一个小实验来加深大家的理解。首先，在一个调试
Windows Vista的内核调试会话中，通过r idtr命令得到系统IDT表的基地
址：
kd> r idtr
idtr=834da400
因为双误异常（Double Fault，#DF）通常是用任务门来处理的，所
以我们观察这个异常对应的IDT表项，因为#DF异常的向量号是8，每个
IDT表项的长度是8，所以我们可以使用如下命令显示出8号IDT表项的
内容：
kd> db 834da400+8*8 l8
834da440  00 00 50 00 00 85 00 00                          ..P.....
其中第2和第3两个字节（0数起，下同）组成的WORD是段选择
子，即0x0050。第5个字节（0x85）是P标志（为1）、DPL（0b00）和
类型（0b00101）。
接下来使用dg命令显示段选择子所指向的段描述符：
kd> dg 50
                                  P  Si Gr Pr Lo
Sel    Base     Limit      Type   l  ze an es ng  Flags
---- -------- -------- ---------- - -- -- -- -- -----------
0050 81967000 00000068 TSS32 Avl  0  Nb By P  Nl  00000089
也就是说，TSS段的基地址是0x81967000，长度是0x68个字节
（Gran位指示By即Byte）。Type字段显示这个段的类型是32位的TSS段
（TSS32），它的状态为可用（Available），并非Busy。
至此，我们知道了#DF异常对应的门描述符所指向的TSS段，是位
于内存地址0x81967000开始的0x68个字节。使用内存观察命令便可以显
示这个TSS的内容了，见清单3-3。
清单3-3 观察#DF门描述符所指向的TSS段
    kd> dd 81967000
81967000  00000000 81964000 00000010 00000000
81967010  00000000 00000000 00000000 00122000
81967020  8193f0a0 00000000 00000000 00000000
81967030  00000000 00000000 81964000 00000000
81967040  00000000 00000000 00000023 00000008
81967050  00000010 00000023 00000030 00000000
81967060  00000000 20ac0000 00000000 81964000
81967070  00000010 00000000 00000000 00000000
参考清单3-3，从上至下，81964000是在优先级0执行时的栈指针，
00000010是优先级0执行时的栈选择子，00122000是这个任务的页目录
基地址寄存器（PDBR，即CR3）的值，8193f0a0是程序指针寄存器
（EIP）的值，当CPU切换到这个任务时便是从这里开始执行的。接下
来，依次是标志寄存器（EFLAGS）和通用寄存器的值。偏移0x48处的
0x23是ES寄存器的值，相邻的00000008是CS寄存器的值，即这个任务
的代码段的选择子。而后是SS寄存器的值，即栈段的选择子，再往后是
DS、FS和GS寄存器的值（0x23、0x30和0）。偏移0x64处的20ac0000是
TSS的最后4个字节，它的最低位是T标志（0），即我们在第4章介绍过
的TSS段中的陷阱标志。高16字节是用来定位IO映射区基地址的偏移地
址，它是相对于TSS的基地址的。
使用ln（list nearest）命令搜索与EIP值接近的符号，结果就是内核
函数KiTrap08：
kd> ln 8193f0a0 
(8193f0a0)   nt!KiTrap08   |  (8193f118)   nt!Dr_kit9_a
Exact matches:
   nt!KiTrap08 = 
也就是说，当有#DF异常发生时，CPU便会切换到以上TSS所描述
的线程，然后在这个线程环境中执行KiTrap08函数。之所以要切换到一
个新的线程，而不是像其他异常那样在原来的线程中处理，是因为#DF
异常指的是在处理一个异常时又发生了异常，这可能意味着本来的线程
环境已经不可靠了，所以有必要切换到一个新的线程来执行。
类似地，代表紧急任务的不可屏蔽中断（NMI）以及代表严重硬件
错误的机器检查异常（MCE）也是使用任务门机制来处理的。而除了这
3个向量之外，其他大多数中断和异常都是利用中断门或陷阱门来处理
的，下面我们看看这两种情况。
首先，CPU会根据门描述符中的段选择子定位到段描述符，然后再
进行一系列检查，如果检查通过后，CPU就判断是否需要切换栈。如果
目标代码段的特权级别比当前特权级别高（级别的数值小），那么CPU
需要切换栈，其方法是从当前任务的任务状态段（TSS）中读取新堆栈
的段选择子（SS）和堆栈指针（ESP），并将其加载到SS和ESP寄存
器。然后，CPU会把被中断过程（旧的）的堆栈段选择子（SS）和堆栈
指针（ESP）压入新的堆栈。接下来，CPU会执行如下两项操作。
把EFLAGS、CS和EIP的指针压入堆栈。CS和EIP指针代表了转到
处理例程前CPU正在执行代码的位置。
如果发生的是异常，而且该异常具有错误代码（见3.3.2节），那么
把该错误代码也压入堆栈。
如果处理例程所在代码段的特权级别与当前特权级别相同，那么
CPU便不需要进行堆栈切换，但仍要执行上面的两项操作。
TR寄存器中存放着指向当前任务TSS段的段选择子，使用WinDBG
可以观察TSS段的内容。
kd> r tr
tr=00000028
kd> dg 28
                                   P Si Gr Pr Lo
Sel    Base    Limit     Type      l ze an es ng Flags
---- -------- -------- ---------- - -- -- -- -- ---------
0028 8013e000 000020ab TSS32 Busy  0 Nb By P  Nl 0000008b
经常做内核调试的读者可能会发现，TR寄存器的值大多时候是固
定的，也就是说，并不随着应用程序的线程切换而变化。事实上，
Windows系统中的TSS个数并不是与系统中的线程个数相关的，而是与
CPU个数相关的。在启动期间，Windows会为每个CPU创建3～4个
TSS，一个用于处理NMI，一个用于处理#DF异常，一个处理机器检查