by monitoring runtime behaviors of the apps. Specif-
ically, it keeps track of apps’ access to device-speciﬁc
identiﬁers (IMEI, Android ID, MAC), user-speciﬁc iden-
tiﬁers (Phone Number, Accounts, Subscriber ID, ICC Se-
rial Number), and context-based information (IP, Nearby
APs, Location). It also monitors explicit IPC channels
(Intent, Service Binding) and implicit IPC channel (In-
direct RW, i.e., reading and writing the same ﬁle or
database). This is not an exhaustive list but covers most
standard and widely-used aggregating channels. Table 2
presents a list of all the contributing sources we consider
and the details of each source will be elaborated in Sec-
tion 3.4.
The criterion of two apps being linkable differs de-
pending on the linkability source. For consistent iden-
tiﬁers that are obviously unique — Android ID, IMEI,
Phone Number, MAC, Subscriber ID, Account, ICC Se-
rial Number — two apps are linkable if they both ac-
cessed the same type of identiﬁer. For pair-wise IPCs
— intents, service bindings, and indirect RW — the two
communicating parties involved are linkable. For im-
plicit and fuzzy information, such as location, nearby
APs, and IP, there are well-known ways to establish link-
ability as well. User-speciﬁc location clusters (Points of
Interests, or PoIs) is already known to be able to uniquely
identify a user [11, 15, 29]. Therefore, an adversary can
link different apps by checking whether the location in-
formation they collected reveal the same PoIs. Here,
the PoIs are extracted using a lightweight algorithm as
used in [5, 10]. We select the top 2 PoIs as the link-
ing standard, which typically correspond to home and
work addresses. Similarly, the consistency and persis-
tence of a user’s PoIs are also reﬂected on its AP clusters
and frequently-used IP addresses. This property allows
us to establish linkability across apps using these fuzzy
contextual information.
3.4 DLG: A Mobile OS Extension
DLG gives us the capability to construct cross-app link-
ability from runtime behaviors of the apps. Here, we in-
troduce how it can be implemented as an extension to
Category
Type
Source
IMEI
Device
Android ID
OS-level Info.
Personal
MAC
Phone #
Account
Subscriber ID
ICC Serial #
IP
Contextual
Nearby APs
Explicit
Location (PoIs)
Intent
Service Binding
Implicit
Indirect RW
IPC Channel
Table 2: DLG considers the linkability introduced by 10 types
of OS-level information and 3 IPC channels.
current mobile operating systems, using Android as an
illustrative example. We also considered other imple-
mentation options, such as user-level interception (Aura-
sium [28]) or dynamic OS instrumentation (Xposed
Framework [27]). The former is insecure since the exten-
sion resides in the attacker’s address space and the latter
is not comprehensive because it cannot handle the native
code of an app. However, the developer can always im-
plement a useful subset of DLG using one of these more
deployable techniques.
Android Basics Android is a Linux-based mobile OS
developed by Google. By default, each app is assigned a
different Linux uid and lives in its own sandbox. Inter-
Process Communications (IPCs) are provided across dif-
ferent sandboxes, based on the Binder protocol which is
inherently a lightweight RPC (Remote Procedure Call)
mechanism. There are four different types of compo-
nents in an Android app: Activity, Service, Content
Provider, and Broadcast Receiver. Each component rep-
resents a different way to interact with the underlying
system: Activity corresponds to a single screen support-
ing user interactions; Service runs in the background to
perform long-running operations and processing; Con-
tent Provider is responsible for managing and querying
of persistent data such as database; and Broadcast Re-
ceiver listens to system-wide broadcasts and ﬁlters those
it is interested in. Next, we describe how we instru-
ment the Android framework to monitor app’s interac-
tions with the system and each other via these compo-
nents.
Implementation Details
In order to construct a DLG
in Android, we need to track apps’ access to various OS-
USENIX Association  
24th USENIX Security Symposium  773
Figure 3: We extend the centralized intent ﬁlter in Android (com.android.server.firewall.IntentFirewall) to intercept
all the intents across apps.
Figure 2: We instrument system services (red shaded region)
to record which app accessed which identiﬁer using Wi-Fi ser-
vice as an example.
level information as well as IPCs between apps. Next, we
describe how we achieve this by instrumenting different
components of the Android framework.
Apps access most identifying information, such as
IMEI and MAC, by interacting with different system ser-
vices. These system services are parts of the Android
framework and have clear interfaces deﬁned in AIDL
(Android Interface Deﬁnition Language). By instru-
menting the public functions in each service that return
persistent identiﬁers, we can have a timestamped record
of which app accessed what type of identifying informa-
tion via which service. Fig. 2 gives a detailed view of
where to instrument using the Wi-Fi service as an exam-
ple.
On the other hand, apps access some identifying in-
formation, such as Android ID, by querying system con-
tent providers. Android framework has a universal choke
point for all access to remote content providers — the
server-side stub class ContentProvider.Transport.
By instrumenting this class, we know which database
(uri) an app is accessing and with what parameters and
actions. Fig. 4 illustrates how an app accesses remote
Content Provider and explains which part to modify in
order to log the information we need.
Figure 4: We instrument Content Provider (shaded region) to
record which app accessed which database with what parame-
ters.
Apps can launch IPCs explicitly, using Intents.
is an abstract description of an operation to
Intent
to a speciﬁc
be performed.
It can either be sent
target (app component), or broadcast
to the entire
system. Android has a centralized ﬁlter which enforces
system-wide policies for all Intents. We extend this ﬁlter
(com.android.server.firewall.IntentFirewall)
to record and intercept all Intent communications across
apps (see Fig. 3). In addition to Intents, Android also
allows an app to communicate explicitly with another
app by binding to one of the services it exports. Once
the binding is established, the two apps can commu-
nicate under a client-server model. We instrument
com.android.server.am.ActiveServices in the
Activity Manager to monitor all the attempts to establish
service bindings across apps.
Apps can also conduct IPCs implicitly by exploiting
shared persistent storage. For example, two apps can
write and read the same ﬁle in the SD card to exchange
identifying information. Therefore, we need to monitor
read and write access to persistent storage. External stor-
age in Android are wrapped by a FUSE (Filesystem in
774  24th USENIX Security Symposium 
USENIX Association
d
e
l
l
a
t
s
n
i
s
p
p
a
f
o
#
 25
 20
 15
 10
 5
 0
 0
average
 10
 30
# of days from deployment
 20
d
e
s
s
e
c
c
a
s
e
c
r
u
o
s
f
o
#
 6
 5
 4
 3
 2
 1
 0
 0
average
 5
 15
# of days since installed
 10
Figure 5: We customize the FUSE daemon under
/system/core/sdcard/sdcard.c to intercept apps’ access
to shared external storage.
Userspace) daemon which enables user-level permission
control. By modifying this daemon, we can track which
app reads or writes which ﬁles (see Fig. 5). This allows
us to implement a Read-Write monitor which captures
implicit communications via reading a ﬁle which has pre-
viously been written by another app. Besides external
storage, our Read-Write monitor also considers similar
indirect communications via system Content Providers.
We described how to monitor all formal ways an app
can interact with system components (Services, Content
Providers) and other apps (Intents, service bindings, and
indirect RW). This methodology is fundamental and can
be extended to cover other potential linkability sources
(beyond our list) as long as a clear deﬁnition is given.
By placing hooks at the aforementioned locations in the
system framework, we get all the information needed to
construct a DLG. For our measurement study, we sim-
ply log and upload these statistics to a remote server for
analysis. In our countermeasure solutions, these are used
locally to derive dynamic defense decisions.
4 Linkability in Real World
In this section, we study app-level linkability in the real
world. We ﬁrst present an overview of linkability, show-
ing the current threats we’re facing. Then, we go through
the linkability sources and analyze to what extent each of
the sources is contributing to the linkability. Finally, we
shed light on how these sources can be or have been ex-
ploited for reasons unrelated to app functionalities. This
paves the way for us to develop a practical countermea-
sure.
4.1 Deployment and Settings
We prototyped DLG on Cyanogenmod 11 (based on An-
droid 4.4.1) and installed the extended OS on 7 Samsung
Galaxy IV devices and 6 Nexus V devices. We recruited
Figure 6: For an average user, more than 80% of the apps
are installed in the ﬁrst two weeks after deployment; each app
accesses most of the linkability sources it’s interested in during
the ﬁrst day of its installation.
13 participants from the students and staff in our insti-
tution, spanning over 8 different academic departments.
Of the 13 participants, 6 of the participants are females
and 7 are males. Before using our experimental devices,
7 of them were Android users and 6 were iPhone users.
Participants are asked to operate their devices normally
without any extra requirement. They are given the op-
tion to temporarily turn off our extension if they want
more privacy when performing certain tasks. Logs are
uploaded once per hour when the device is connected to
Wi-Fi. We exclude built-in system apps (since the mobile
OS is assumed to be benign in our threat model) and con-
sider only third-party apps that are installed by the users
themselves. Note that our study is limited in its size and
the results may not generalize.
4.2 Data and Findings
We observed a total of 215 unique apps during a 47-
day period for 13 users. On average, each user installed
26 apps and each app accessed 4.8 different linkability
sources. We noticed that more than 80% of the apps are
installed within the ﬁrst two weeks after deployment, and
apps would access most of the linkability sources they
are interested in during the ﬁrst day of their installation
(see Fig. 6). This suggests that a relative short-term (a
few weeks) measurement would be enough to capture a
representative view of the problem.
Overview: Our measurement indicates an alarming
view of the threat: two random apps are linkable with
a probability of 0.81, and an adversary only needs to
control 2.2 apps (0.2 additional app), on average, to link
them. This means that an adversary in the current ecosys-
tem can aggregate information from most apps without
additional efforts (i.e., controlling a third app). Specif-
ically, we found that 86% of the apps a user installed
on his device are directly linkable to the Facebook app,
namely, his real identity. This means almost all the activ-
USENIX Association  
24th USENIX Security Symposium  775
 1
 0.8
 0.6
 0.4
 0.2
 0
I
P
A
n
Linking Ratio (LR)
% of apps accessing each source
)
E
L
(
t
r
o
f
f
 1.2
 1
 0.8
 0.6
 0.4
 0.2
 0
I
P
I
c
M
A
E
g
n
k
n
L
i
i
L
i
n
I
c
c
B
i
n
e
S
1
e
d
i
n
g
ri
a
l
y
N
A
u
P
m
N
b
u
I
n
t
e
I
n
A
c
c
I
M
d
ir
e
n
t
o
u
c
t
R
n
t
d
r
o
i
d
I
E
I
A
C
o
c
u
e
b
s
a
r
b
a
ti
o
n
c
ri
b
M
L
S
N
D
W