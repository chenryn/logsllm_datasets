# 11 \| Context：信息穿透上下文你好，我是鸟窝。在这节课正式开始之前，我想先带你看一个工作中的场景。假设有一天你进入办公室，突然同事们都围住你，然后大喊"小王小王你最帅"，此时你可能一头雾水，只能尴尬地笑笑。为啥呢？因为你缺少上下文的信息，不知道之前发生了什么。但是，如果同事告诉你，由于你业绩突出，一天之内就把云服务化的主要架构写好了，因此被评为9 月份的工作之星，总经理还特意给你发 1万元的奖金，那么，你心里就很清楚了，原来同事恭喜你，是因为你的工作被表扬了，还获得了奖金。同事告诉你的这些前因后果，就是上下文信息，他把上下文传递给你，你接收后，就可以获取之前不了解的信息。你看，上下文（Context）就是这么重要。在我们的开发场景中，上下文也是不可或缺的，缺少了它，我们就不能获取完整的程序信息。那到底啥是上下文呢？其实，这就是指，在API之间或者方法调用之间，所传递的除了业务参数之外的额外信息。比如，服务端接收到客户端的 HTTP 请求之后，可以把客户端的 IP地址和端口、客户端的身份信息、请求接收的时间、Trace ID等信息放入到上下文中，这个上下文可以在后端的方法调用中传递，后端的业务方法除了利用正常的参数做一些业务处理（如订单处理）之外，还可以从上下文读取到消息请求的时间、TraceID 等信息，把服务处理的时间推送到 Trace 服务中。Trace 服务可以把同一Trace ID的不同方法的调用顺序和调用时间展示成流程图，方便跟踪。不过，Go 标准库中的 Context功能还不止于此，它还提供了超时（Timeout）和取消（Cancel）的机制，下面就让我一一道来。Context 的来历在学习 Context的功能之前呢，我先带你了解下它的来历。毕竟，知道了它的来龙去脉，我们才能应用得更加得心应手一些。Go 在 1.7 的版本中才正式把 Context 加入到标准库中。在这之前，很多 Web框架在定义自己的 handler 时，都会传递一个自定义的Context，把客户端的信息和客户端的请求信息放入到 Context 中。Go最初提供了 golang.org/x/net/context 库用来提供上下文信息，最终还是在Go1.7 中把此库提升到标准库 context包中。 为啥呢？这是因为，在 Go1.7 之前，有很多库都依赖golang.org/x/net/context 中的 Context 实现，这就导致 Go 1.7发布之后，出现了标准库 Context 和 golang.org/x/net/context并存的状况。新的代码使用标准库 Context 的时候，没有办法使用这个标准库的Context 去调用旧有的使用 x/net/context实现的方法。所以，在 Go1.9 中，还专门实现了一个叫做 type alias 的新特性，然后把x/net/context 中的 Context 定义成标准库 Context 的别名，以解决新旧Context类型冲突问题，你可以看一下下面这段代码：        // +build go1.9      package context            import "context"            type Context = context.Context      type CancelFunc = context.CancelFuncGo 标准库的 Context 不仅提供了上下文传递的信息，还提供了cancel、timeout 等其它信息，这些信息貌似和 context这个包名没关系，但是还是得到了广泛的应用。所以，你看，context 包中的Context 不仅仅传递上下文信息，还有 timeout等其它功能，是不是"名不副实"呢？其实啊，这也是这个 Context 的一个问题，比较容易误导人，Go 布道师 DaveCheney还专门写了一篇文章讲述这个问题：Context isn't forcancellationslate-object="inline"。同时，也有一些批评者针对 Context提出了批评：Context should go away for Go2  slate-object="inline"，这篇文章把 Context比作病毒，病毒会传染，结果把所有的方法都传染上了病毒（加上 Context参数），绝对是视觉污染。Go 的开发者也注意到了"关于 Context，存在一些争议"这件事儿，所以，Go核心开发者 Ian Lance Taylor专门开了一个issue 28342，用来记录当前的 Context的问题： 1.  Context 包名导致使用的时候重复 ctx    context.Context；        2.  Context.WithValue    可以接受任何类型的值，非类型安全；        3.  Context 包名容易误导人，实际上，Context 最主要的功能是取消    goroutine 的执行；        4.  Context    漫天飞，函数污染。        尽管有很多的争议，但是，在很多场景下，使用 Context其实会很方便，所以现在它已经在 Go 生态圈中传播开来了，包括很多的 Web应用框架，都切换成了标准库的 Context。标准库中的database/sql、os/exec、net、net/http 等包中都使用到了Context。而且，如果我们遇到了下面的一些场景，也可以考虑使用Context： 1.  上下文信息传递 （request-scoped），比如处理 http    请求、在请求处理链路上传递信息；        2.  控制子 goroutine    的运行；        3.  超时控制的方法调用；        4.  可以取消的方法调用。        所以，我们需要掌握 Context的具体用法，这样才能在不影响主要业务流程实现的时候，实现一些通用的信息传递，或者是能够和其它goroutine 协同工作，提供 timeout、cancel等机制。 Context 基本使用方法首先，我们来学习一下 Context接口包含哪些方法，这些方法都是干什么用的。包 context 定义了 Context 接口，Context 的具体实现包括 4个方法，分别是 Deadline、Done、Err 和Value，如下所示：    type Context interface {        Deadline() (deadline time.Time, ok bool)        Done()   > Don't communicate by sharing memory, share memory by> communicating.> > >>  > Go Proverbs by Rob Pike> > >这是 Rob Pike 在 2015 年的一次 Gopher会议中提到的一句话，虽然有一点绕，但也指出了使用 Go语言的哲学，我尝试着来翻译一下："**执行业务处理的 goroutine不要通过共享内存的方式通信，而是要通过 Channel通信的方式分享数据。**""communicate by sharing memory"和"share memory bycommunicating"是两种不同的并发处理模式。"communicate by sharingmemory"是传统的并发编程处理方式，就是指，共享的数据需要用锁进行保护，goroutine需要获取到锁，才能并发访问数据。"share memory by communicating"则是类似于 CSP模型的方式，通过通信的方式，一个 goroutine可以把数据的"所有权"交给另外一个 goroutine（虽然 Go中没有"所有权"的概念，但是从逻辑上说，你可以把它理解为是所有权的转移）。从 Channel 的历史和设计哲学上，我们就可以了解到，Channel类型和基本并发原语是有竞争关系的，它应用于并发场景，涉及到 goroutine之间的通讯，可以提供并发的保护，等等。综合起来，我把 Channel的应用场景分为五种类型。这里你先有个印象，这样你可以有目的地去学习Channel的基本原理。下节课我会借助具体的例子，来带你掌握这几种类型。1.       **数据交流**        ：当作并发的 buffer 或者 queue，解决生产者 -    消费者问题。多个 goroutine    可以并发当作生产者（Producer）和消费者（Consumer）。        2.       **数据传递**        ：一个 goroutine 将数据交给另一个    goroutine，相当于把数据的拥有权 (引用)    托付出去。        3.       **信号通知**        ：一个 goroutine 可以将信号 (closing、closed、data    ready 等) 传递给另一个或者另一组 goroutine    。    4.       **任务编排**        ：可以让一组 goroutine    按照一定的顺序并发或者串行的执行，这就是编排的功能。        5.       **锁**        ：利用 Channel    也可以实现互斥锁的机制。        下面，我们来具体学习下 Channel的基本用法。Channel 基本用法你可以往 Channel 中发送数据，也可以从 Channel中接收数据，所以，Channel 类型（为了说起来方便，我们下面都把 Channel叫做 chan）分为**只能接收**、**只能发送**、**既可以接收又可以发送**三种类型。下面是它的语法定义：    ChannelType = ( "chan" | "chan" " 0 {          qp := chanbuf(c, c.recvx)          if ep != nil {            typedmemmove(c.elemtype, ep, qp)          }          typedmemclr(c.elemtype, qp)          c.recvx++          if c.recvx == c.dataqsiz {            c.recvx = 0          }          c.qcount--          unlock(&c.lock)          return true, true        }        if !block {          unlock(&c.lock)          return false, false        }            // 第六部分， buf中没有元素，阻塞            ......第五部分是处理没有等待的 sender 的情况。这个是和 chansend共用一把大锁，所以不会有并发的问题。如果 buf 有元素，就取出一个元素给receiver。 第六部分是处理 buf 中没有元素的情况。如果没有元素，那么当前的receiver 就会被阻塞，直到它从 sender 中接收了数据，或者是 chan 被close，才返回。close通过 close 函数，可以把 chan 关闭，编译器会替换成 closechan方法的调用。下面的代码是 close chan 的主要逻辑。如果 chan 为 nil，close 会panic；如果 chan 已经 closed，再次 close 也会 panic。否则的话，如果 chan不为 nil，chan 也没有 closed，就把等待队列中的 sender（writer）和receiver（reader）从队列中全部移除并唤醒。下面的代码就是 close chan的逻辑:         func closechan(c *hchan) {        if c == nil { // chan为nil, panic          panic(plainError("close of nil channel"))        }              lock(&c.lock)        if c.closed != 0 {// chan已经closed, panic          unlock(&c.lock)          panic(plainError("close of closed channel"))        }        c.closed = 1          var glist gList        // 释放所有的reader        for {          sg := c.recvq.dequeue()          ......          gp := sg.g          ......          glist.push(gp)        }              // 释放所有的writer (它们会panic)        for {          sg := c.sendq.dequeue()          ......          gp := sg.g          ......          glist.push(gp)        }        unlock(&c.lock)              for !glist.empty() {          gp := glist.pop()          gp.schedlink = 0          goready(gp, 3)        }      }掌握了 Channel的基本用法和实现原理，下面我再来给你讲一讲容易犯的错误。你一定要认真看，毕竟，这些可都是帮助你避坑的。使用 Channel 容易犯的错误根据 2019 年第一篇全面分析 Go 并发 Bug的论文，那些知名的 Go 项目中使用 Channel所犯的 Bug 反而比传统的并发原语的 Bug还要多。主要有两个原因：一个是，Channel的概念还比较新，程序员还不能很好地掌握相应的使用方法和最佳实践；第二个是，Channel有时候比传统的并发原语更复杂，使用起来很容易顾此失彼。**使用 Channel 最常见的错误是 panic 和 goroutine泄漏**。首先，我们来总结下会 panic 的情况，总共有 3种： 1.       close 为 nil 的 chan；        2.       send 已经 close 的    chan；    3.       close 已经 close 的    chan。    goroutine泄漏的问题也很常见，下面的代码也是一个实际项目中的例子：    func process(timeout time.Duration) bool {        ch := make(chan bool)        go func() {            // 模拟处理耗时的业务            time.Sleep((timeout + time.Second))            ch   > 有 4 个 goroutine，编号为 1、2、3、4。每秒钟会有一个 goroutine> 打印出它自己的编号，要求你编写程序，让输出的编号总是按照> 1、2、3、4、1、2、3、4......这个顺序打印出来。> > >为了实现顺序的数据传递，我们可以定义一个令牌的变量，谁得到令牌，谁就可以打印一次自己的编号，同时将令牌**传递**给下一个 goroutine，我们尝试使用 chan来实现，可以看下下面的代码。     type Token struct{}    func newWorker(id int, ch chan Token, nextCh chan Token) {        for {            token :=  0 {                i, v, ok := reflect.Select(cases)                if !ok { // 此channel已经close                    cases = append(cases[:i], cases[i+1:]...)                    continue                }                out   > Within a single goroutine, the happens-before order is the order> expressed by the program.> > >我来解释下这句话。它的意思是，在单个的 goroutine 内部，happens-before的关系和代码编写的顺序是一致的。其实，在这一章的开头我已经用橙色把这句话标注出来了。我再具体解释下。在 goroutine 内部对一个局部变量 v的读，一定能观察到最近一次对这个局部变量 v 的写。如果要保证多个goroutine 之间对一个共享变量的读写顺序，在 Go语言中，可以使用并发原语为读写操作建立 happens-before关系，这样就可以保证顺序了。说到这儿，我想先给你补充三个 Go语言中和内存模型有关的小知识，掌握了这些，你就能更好地理解下面的内容。1.       在 Go    语言中，对变量进行零值的初始化就是一个写操作。        2.       如果对超过机器 word（64bit、32bit    或者其它）大小的值进行读写，那么，就可以看作是对拆成 word    大小的几个读写无序进行。        3.       Go 并不提供直接的 CPU 屏障（CPU fence）来提示编译器或者 CPU    保证顺序性，而是使用不同架构的内存屏障指令来实现统一的并发原语。        接下来，我就带你学习下 Go 语言中提供的 happens-before关系保证。 Go 语言中保证的 happens-before 关系除了单个 goroutine 内部提供的 happens-before 保证，Go语言中还提供了一些其它的 happens-before关系的保证，下面我来一个一个介绍下。init 函数应用程序的初始化是在单一的 goroutine 执行的。如果包 p 导入了包q，那么，q 的 init 函数的执行一定 happens before p的任何初始化代码。这里有一个特殊情况需要你记住：**main 函数一定在导入的包的 init函数之后执行**。包级别的变量在同一个文件中是按照声明顺序逐个初始化的，除非初始化它的时候依赖其它的变量。同一个包下的多个文件，会按照文件名的排列顺序进行初始化。这个顺序被定义在Go 语言规范中，而不是 Go的内存模型规范中。你可以看看下面的例子中各个变量的值：    var (      a = c + b  // == 9      b = f()    // == 4      c = f()    // == 5      d = 3      // == 5 全部初始化完成后    )    func f() int {      d++      return d    }具体怎么对这些变量进行初始化呢？Go采用的是依赖分析技术。不过，依赖分析技术保证的顺序只是针对同一包下的变量，而且，只有引用关系是本包变量、函数和非接口的方法，才能保证它们的顺序性。同一个包下可以有多个 init 函数，但是每个文件最多只能有一个 init函数，多个 init函数按照它们的文件名顺序逐个初始化。刚刚讲的这些都是不同包的 init函数执行顺序，下面我举一个具体的例子，把这些内容串起来，你一看就明白了。这个例子是一个 **main** 程序，它依赖包 p1，包 p1 依赖包 p2，包 p2 依赖p3。 ![](Images/d9b82a017b88d00ffbe2e644b03d3e97.png)savepage-src="https://static001.geekbang.org/resource/image/d5/2a/d5059fab1977602934339e18f9eddb2a.jpg"}为了追踪初始化过程，并输出有意义的日志，我定义了一个辅助方法，打印出日志并返回一个用来初始化的整数值：    func Trace(t string, v int) int {        fmt.Println(t, ":", v)        return v    }包 **p3** 包含两个文件，分别定义了一个 init函数。第一个文件中定义了两个变量，这两个变量的值还会在 init函数中进行修改。我们来分别看下包 p3的这两个文件：    // lib1.go in p3    var V1_p3 = trace.Trace("init v1_p3", 3)    var V2_p3 = trace.Trace("init v2_p3", 3)    func init() {        fmt.Println("init func in p3")        V1_p3 = 300        V2_p3 = 300    }    // lib2.go in p3    func init() {        fmt.Println("another init func in p3")    }下面再来看看包 p2。包 p2 定义了变量和 init 函数。第一个变量初始化为2，并在 init 函数中更改为 200。第二个变量是复制的p3.V2_p3。     var V1_p2 = trace.Trace("init v1_p2", 2)    var V2_p2 = trace.Trace("init v2_p2", p3.V2_p3)    func init() {        fmt.Println("init func in p2")        V1_p2 = 200    }包 **p1** 定义了变量和 init 函数。它的两个变量的值是复制的 p2对应的两个变量值。    var V1_p1 = trace.Trace("init v1_p1", p2.V1_p2)    var V2_p1 = trace.Trace("init v2_p1", p2.V2_p2)    func init() {        fmt.Println("init func in p1")    }**main**  定义了 init函数和 main 函数。    func init() {        fmt.Println("init func in main")    }    func main() {        fmt.Println("V1_p1:", p1.V1_p1)        fmt.Println("V2_p1:", p1.V2_p1)    }运行 main 函数会依次输出 p3、p2、p1、main的初始化变量时的日志（变量初始化时的日志和 init函数调用时的日志）：    // 包p3的变量初始化    init v1_p3 : 3    init v2_p3 : 3    // p3的init函数    init func in p3    // p3的另一个init函数     another init func in p3    // 包p2的变量初始化    init v1_p2 : 2    init v2_p2 : 300    // 包p2的init函数    init func in p2    // 包p1的变量初始化    init v1_p1 : 200    init v2_p1 : 300    // 包p1的init函数    init func in p1    // 包main的init函数    init func in main    // main函数    V1_p1: 200    V2_p1: 300下面，我们再来看看 goroutine 对 happens-before关系的保证情况。goroutine首先，我们需要明确一个规则：**启动 goroutine 的 go 语句的执行，一定 happens before 此goroutine 内的代码执行。**根据这个规则，我们就可以知道，如果 go语句传入的参数是一个函数执行的结果，那么，这个函数一定先于 goroutine内部的代码被执行。我们来看一个例子。在下面的代码中，第 8 行 a 的赋值和第 9 行的 go语句是在同一个 goroutine 中执行的，所以，在主 goroutine 看来，第 8行肯定 happens before 第 9 行，又由于刚才的保证，第 9 行子 goroutine的启动 happens before 第 4 行的变量输出，那么，我们就可以推断出，第 8 行happens before 第 4 行。也就是说，在第 4 行打印 a的值的时候，肯定会打印出"helloworld"。     var a string    func f() {      print(a)    }    func hello() {      a = "hello, world"      go f()    }刚刚说的是启动 goroutine 的情况，goroutine 退出的时候，是没有任何happens-before 保证的。所以，如果你想观察某个 goroutine的执行效果，你需要使用同步机制建立 happens-before 关系，比如 Mutex 或者Channel。接下来，我会讲 Channel 的 happens-before的关系保证。ChannelChannel 是 goroutine 同步交流的主要方法。往一个 Channel中发送一条数据，通常对应着另一个 goroutine 从这个 Channel中接收一条数据。通用的 Channel happens-before 关系保证有 4条规则，我分别来介绍下。**第 1 条规则是**，往 Channel 中的发送操作，happens before 从该 Channel接收相应数据的动作完成之前，即第 n 个 send 一定 happens before 第 n 个receive 的完成。    var ch = make(chan struct{}, 10) // buffered或者unbuffered    var s string    func f() {      s = "hello, world"      ch 0），那么，第 n 个 receive一定 happens before 第 n+m 个 send的完成。 前一条规则是针对 unbuffered channel 的，这里给出了更广泛的针对buffered channel的保证。利用这个规则，我们可以实现信号量（Semaphore）的并发原语。Channel的容量相当于可用的资源，发送一条数据相当于请求信号量，接收一条数据相当于释放信号。关于信号量这个并发原语，我会在下一讲专门给你介绍一下，这里你只需要知道它可以控制多个资源的并发访问，就可以了。Mutex/RWMutex对于互斥锁 Mutex m 或者读写锁 RWMutex m，有 3 条 happens-before关系的保证。1.       第 n 次的 m.Unlock 一定 happens before 第 n+1 m.Lock    方法的返回；        2.       对于读写锁 RWMutex m，如果它的第 n 个 m.Lock    方法的调用已返回，那么它的第 n 个 m.Unlock 的方法调用一定 happens    before 任何一个 m.RLock 方法调用的返回，只要这些 m.RLock 方法调用    happens after 第 n 次 m.Lock    的调用的返回。这就可以保证，只有释放了持有的写锁，那些等待的读请求才能请求到读锁。        3.       对于读写锁 RWMutex m，如果它的第 n 个 m.RLock    方法的调用已返回，那么它的第 k （k\  > 对于读写锁 l 的 l.RLock 方法调用，如果存在一个> >> **n**> > ，这次的 l.RLock 调用 happens after 第 n 次的> l.Unlock，那么，和这个 RLock 相对应的 l.RUnlock 一定 happens before 第> n+1 次 l.Lock。意思是，读写锁的 Lock> 必须等待既有的读锁释放后才能获取到。> > >我再举个例子。在下面的代码中，第 6 行第一次的 Unlock 一定 happensbefore 第二次的 Lock（第 12 行），所以这也能保证正确地打印出"helloworld"。     var mu sync.Mutex    var s string    func foo() {      s = "hello, world"      mu.Unlock()    }    func main() {      mu.Lock()      go foo()      mu.Lock()      print(s)WaitGroup接下来是 WaitGroup 的保证。对于一个 WaitGroup 实例 wg，在某个时刻 t0时，它的计数值已经不是零了，假如 t0 时刻之后调用了一系列的 wg.Add(n)或者 wg.Done()，并且只有最后一次调用 wg 的计数值变为了0，那么，可以保证这些 wg.Add 或者 wg.Done() 一定 happens before t0时刻之后调用的 wg.Wait方法的返回。这个保证的通俗说法，就是 **Wait方法等到计数值归零之后才返回**。Once我们在 [第 8讲  学过Once了，相信你已经很熟悉它的功能了。它提供的保证是：**对于 once.Do(f) 调用，f 函数的那个单次调用一定 happensbefore 任何 once.Do(f)调用的返回**。换句话说，就是函数 f 一定会在 Do方法返回之前执行。还是以 hello world 的例子为例，这次我们使用 Once并发原语实现，可以看下下面的代码：    var s string    var once sync.Once    func foo() {      s = "hello, world"    }    func twoprint() {      once.Do(foo)      print(s)    }第 5 行的执行一定 happens before 第 9 行的返回，所以执行到第 10行的时候，sd 已经初始化了，所以会正确地打印"helloworld"。 最后，我再来说说 atomic的保证。 atomic其实，Go 内存模型的官方文档并没有明确给出 atomic 的保证，有一个相关的issue  [go#5045  slate-object="inline"记录了相关的讨论。光看 issue号，就知道这个讨论由来已久了。Russ Cox 想让 atomic有一个弱保证，这样可以为以后留下充足的可扩展空间，所以，Go内存模型规范上并没有严格的定义。对于 Go 1.15 的官方实现来说，可以保证使用 atomic 的 Load/Store的变量之间的顺序性。在下面的例子中，打印出的 a 的结果总是1，但是官方并没有做任何文档上的说明和保证。依照 Ian Lance Taylor 的说法，Go核心开发组的成员几乎没有关注这个方向上的研究，因为这个问题太复杂，有很多问题需要去研究，所以，现阶段还是不要使用atomic 来保证顺序性。    func main() {      var a, b int32 = 0, 0      go func() {        atomic.StoreInt32(&a, 1)        atomic.StoreInt32(&b, 1)      }()      for atomic.LoadInt32(&b) == 0{        runtime.Gosched()      }        fmt.Println(atomic.LoadInt32(&a))    }总结Go 的内存模型规范中，一开始有这么一段话：>  > If you must read the rest of this document to understand the> behavior of your program, you are being too> clever.> >>  > Don't be clever.> > >我来说说我对这句话的理解：你通过学习这节课来理解你的程序的行为是聪明的，但是，不要自作聪明。谨慎地使用这些保证，能够让你的程序按照设想的 happens-before关系执行，但是不要以为完全理解这些概念和保证，就可以随意地制造所谓的各种技巧，否则就很容易掉进"坑"里，而且会给代码埋下了很多的"定时炸弹"。比如，Go 里面已经有值得信赖的互斥锁了，如果没有额外的需求，就不要使用Channel 创造出自己的互斥锁。当然，我也不希望你畏手畏脚地把思想局限住，我还是建议你去做一些有意义的尝试，比如使用Channel实现信号量等扩展并发原语。![](Images/0895e09b3c740f6feb527cdd34cbafab.png)savepage-src="https://static001.geekbang.org/resource/image/dc/4d/dc68fc5f93a4af96c8f4d45d6282104d.jpg"}思考题我们知道，Channel可以实现互斥锁，那么，我想请你思考一下，它是如何利用 happens-before关系保证锁的请求和释放的呢？欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。