18
0000000O 0 NOTYPE
GLOBAL DEFAULT
UND shared
“GLOBAL”类型的符号，除了“main”函数是定义在代码段之外，其他两个“shared”
文件中有关于它们的重定位项。所以在链接器扫描完所有的输入目标文件之后，所有这些未
定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误。
程序员的自我修养一链接、装载与库
---
## Page 132
4.2符号解析与重定位
109
4.2.4指令修正方式
不同的处理器指令对于地址的格式和方式都不一样。比如对于32位Intelx86处理器
来说，转移跳转指令（jmp指令）、子程序调用指令（call指令）和数据传送指令（mov指
令）寻址方式千差万别。直至2006年为止，Intelx86系列CPU的jmp指令有11种寻址
模式：call指令有10种：mov指令则有多达34种寻址模式！这些寻址方式有如下几方面
的区别：
·近址寻址或远址寻址。
绝对寻址或相对寻址。
·寻址长度为8位、16位、32位或64位。
但是对于32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种：
·绝对近址32位寻址。
相对近址32位寻址。
这两种重定位方式指令修正方式每个被修正的位置的长度都为32位，即4个字节，面
且都是近址寻址，不用考虑Intel的段间远址寻址。唯一的区别就是绝对寻址和相对寻址。
前面我们提到过，重定位入口的r_info成员低8位表示重定位入口类型，如表42所示。
表4-2
宏定义
值
重定位修正方法
R_386_32
绝对寻址修正S+A
R_386_PC322相对寻址修正S+A-P
A=保存在被修正位置的值
P=被修正的位置（相对于段开始的偏移量或者虚拟地址）注意，该值可通过r_ofset计算得到
S=符号的实际地址，即由r_info的高24位指定的符号的实际地址
对照前面a.o的重定位信息，我们可以看到第一个重定位入口是对swap符号的引用，
类型为R_386_PC32，查阅Intel指令手册，它的确是一条相对位移调用指令：面shared是
R_386_32类型的，它修正的是一条传输指令的源，该传输指令的源是一个立即数，即shared
的绝对地址。所以这两个重定位入口很具有代表性，分别代表了两种不间的重定位地址修正
方式。
现在让我们假设在将a.o和b.o链接成最终可执行文件后，main函数的虚拟地址为
0x1000，swap函数的虚拟地址为0x2000：shared变量的虚拟地址为0x3000，那么我们的链
程序员的自我修养一链接、装载与库
---
## Page 133
110
第4章静态链接
接器将如何修正ao里面这两个重定位入口呢？
的修正，它的修正方式是R_386_32，即绝对地址修正。对于这个重定位入口，它修正后的
结果应该是S+A
·S是符号shared的实际地址，即0x3000。
·A是被修正位置的值，即0x00000000。
所以最后这个重定位入口修正后地址为：0x3000+0x00000000=0x3000。即指令修
正后应该是：
1011 :
c7 45 f8 64 00 00 00
1018 :
mOV↓
(dss)x0*0000x05
$0x64,0xfffffff8 (#ebp)
101f :
c7 442404003000
00
mov1
1020 :
8d 45 f8
lea 0xfffffff8($ebp), $eax
相对寻址修正让我们再来看看a.o的第二个重定位入口，即偏移为0x26的这条call
指令的修正，它的指令修正方式是R_386_PC32，即相对寻址修正。对于这个重定位入口，
它修正后的结果应该是S+A-P。
·S是符号swap的实际地址.即0x2000；
·A是被修正位置的值，即0xFFFFFFFC（-4）；
·P为被修正的位置，当链接成可执行文件时，这个值应该是被修正位置的虚拟地址，即
0x1000 + 0x27。
所以最后这个重定位入口修正后地址为：0x2000+（-4)-（0x1000+0x27)=0xFD5。即指
令修正后应该是：
1023:
8d 45 t8
lea Oxfffffff8 (tebp), teax
1026 :
e8 d5 0f 00 00
cal1
0xfd5
102b: 89 04 24
AOW
teax, ($esp)
2000:
 + 
这条相对位移调用指令调用的地址是该指令下一条指令的起始地址加上偏移量，即：
0x102b+0xfd5=0x2000，刚好是swap函数的地址。
从这两个例子可以看出来，绝对寻址修正和相对寻址修正的区别就是绝对寻址修正后的
地址为该符号的实际地址：相对寻址修正后的地址为符号距离被修正位置的地址差。
程序员的自我修养一链接、装载与库
---
## Page 134
4.3COMMON块
111
4.3COMMON块
正如前面提到过的，由于弱符号机制允许同一个符号的定义存在于多个文件中，所以可
能会导致的一个问题是：如果一个弱符号定文在多个日标文件中，而它们的类型又不同，怎
么办？目前的链接器本身并不支持符号的类型，即变量类型对于链接器来说是透明的，它只
知道个符号的名字，并不知道类型是否一致，那么当我们定义的多个符号定义类型不一致
时，链接器该如何处理呢？让我们米分析一下多个符号定义类型不一致的儿种情况，主要分
三种情况：
·两个或两个以上强符号类型不一致：
·有个强符号，其他都是弱符号，出现类型不一致：
·
两个或两个以上弱符号类型不一致。
对于上述三种情况，第一种情况是无须额外处理的，因为多个强符号定义本身就是非法
的，链接器会报符号多重定义错误：链接器要处理的就是后两种情况。
事实上，现在的编译器和链接器都支持一种叫COMMON块（Common Block）的机制，
这种机制最早米源于Fortran，早期的Fortran没有动态分配空间的机制，程序员必须事先声
明它所需要的临时使用空间的大小.Fortran把这种空间叫COMMON块，当不同的目标文
件需要的COMMON块空间大小不一致时，以最大的那块为准。
现代的链接机制在处理弱符号的时候，采用的就是与COMMON块一样的机制。前面
我们在SimpleSection.c这个例子中已经看到，编译器将来初始化的全局变量定义作为弱符
号处理。比如符号global_uninit_var，它在符号表中的各个值为（使用readelf-s）：
st_nane - *global_uninit_var*
st_value = 4
st_info = 0x11 STB_GLOBAL STT_OBJECT
st_si2e = 4
st_other = 0
st_shndx = 0xEEf2 SHN_COMMON
可以看到它是一个全局的数据对象，它的类型为SHN_COMMON类型，这是一个典型
的病符号。那么如果我们在另外一个文件中也定义了global_uninit_var变量，且未初始化，
它的类型为double，占8个字节，情况会怎么样呢？按照COMMON类型的链接规则，原
则上讲最终链接后输出文件中，global_uninit_var的大小以输入文件中最大的那个为准。即
这两个文件链接后输出文件中global_uninit_var所占的空间为8个字节。
当然COMMON类型的链接规则是针对符号都是病符号的情况，如果其中有一个符号
为强符号，那么最终输出结果中的符号所占空间与强符号相同。值得注意的是，如果链接过
程序员的自我修养一链接、装载与库
---
## Page 135
112
第4章静态链接
程中有弱符号大小大于强符号，那么d链接器会报如下警告：
1d: warning: alignment 4 of symbo1 globa1* in a.o 1s snaller than 8 in b.o
COMMON机制的原因是编译器和链接器允许不同类型的弱符号存在，但最本质的原因还是
链接器不支持符号类型，即键接器无法判断各个符号的类型是否一致。
现在我们再回头总结性地思考关于未初始化的全局变量的问题：在目标文件中，编译器
为什么不直接把未初始化的全局变量也当作未初始化的局部静态变量一样处理，为它在BSS
段分配空间，面是将其标记为一个COMMON类型的变量？
通过了解链接器处理多个弱符号的过程，我们可以想到，当编译器将一个编译单元编译
成目标文件的时候，如果该编译单元包含了弱符号（未初始化的全局变量就是典型的弱符
号），那么该弱符号最终所占空间的大小在此时是未知的，因为有可能其他编译单元中该符
号所占的空间比本编译单元该符号所占的空间要大，所以编译器此时无法为该新符号在BSS
段分配空间，因为所须要空间的大小未知。但是链接器在链接过程中可以确定弱符号的大小，
它可以在最终输出文件的BSS段为其分配空间。所以总体来看，未初始化全局变量最终还
是被放在BSS 段的。
关于多个文件中出现同一个变量的多个定义的原因，还有一种说法是由于早期C语言
程序员粗心大意，经常忘记在声明变量时在前面加上“extern”关键字，使得编译器
会在多个目标文件中产生同一个变量的定义。为了解决这个问题，编译器和链接器干
脆就把未初始化的变量都当作COMMON类型的处理。
GCC的“-fno-common”也允许我们把所有未初始化的全局变量不以COMMON块的形
式处理，或者使用“_atribute_”扩展：
int global _attribute_( (nocommon) ) ;
一旦一个未初始化的全局变量不是以COMMON块的形式存在，那么它就相当于一个
强符号，如果其他目标文件中还有同一个变量的强符号定义，链接时就会发生符号重复定义
错误。
4.4C++相关问题
C++的一些语言特性使之必须由编译器和髓接器共同支持才能完成工作，最主要的有两
个方面，一个是C++的重复代码消除，还有一个就是全局构造与析构。另外由于C++语言
程序员的自我修养一链接、装载与库
---
## Page 136
4.4C++相关问题
113
的各种特性，比如虚拟函数、函数重裁、继承、异常等，使得它背后的数据结构异常复杂，
这些数据结构往往在不同的编译器和链接器之间相互不能通用，使得C++程序的二进制兼容
性成了一个很大的间题，我们在这一节还将讨论C++程序的二进制兼容性问题。
4.4.1重复代码消除
C++编译器在很多时候会产生重复的代码，比如模板（Templates）、外部内联函数（Extem
Inline Function）和虚函数表（Virtual Function Table）都有可能在不同的编译单元里生成相
同的代码。最简单的情况就拿模板来说，模板从本质上来讲很像宏，当模板在个编译单元
里被实例化时，它并不知道自己是否在别的编译单元也被实例化了。所以当一个模板在多个
编译单元同时实例化成相同的类型的时候，必然会生成重复的代码，当然，最简单的方案就
是不管这些，将这些重复的代码都保留下来。不过这样做的主要问题有以下几方面。
·空间浪费。可以想象一个有儿百个编译单元的工程网时实例化了许多个模板，最后链
接的时候必须将这些重复的代码消除掉，否则最终程序的大小肯定会膨胀得很厉害。
·地址较易出错。有可能两个指向同一个函数的指针会不相等。
指令运行效率较低。因为现代的CPU都会对指令和数据进行缓存，如果同样一份指令
有多份副本，那么指令Cache的命中率就会降低。
含一个模板实例。比如有个模板函数是add)，某个编译单元以int类型和float类型实例
化了该模板函数，那么该编译单元的目标文件中就包含了两个该模板实例的段。为了简单起
见，我们假设这两个段的名字分别叫.temp.add和temp.add<floaD。这样，当别的编译
单元也以int或foat类型实例化该模板函数后，也会生成同样的名字，这样链接器在最终链
接的时候可以区分这些相同的模板实例段，然后将它们合并入最后的代码段。
这种做法的确被目前主流的编译器所采用，GNUGCC编译器和VISUALC++编译器都
采用了类似的方法。GCC把这种类似的须要在最终链接时合并的段叫“LinkOnce”，它的做
后名称。VISUALC++编译器做法稍有不同，它把这种类型的段叫做“COMDAT”，这种
“COMDAT”段的属性字段（PE文件的段表结构里面的IMAGE_SECTION_HEADER的
Characteristics 成员）都有IMAGE_SCN_LNK_COMDAT（0x00001000）这个标记，在链接
器看到这个标记后，它就认为该段是COMDAT类型的，在链接时会将重复的段丢弃。
这种重复代码消除对于模板来说是这样的，对于外部内联函数和虚函数表的做法也类
似。比如对于个有虚函数的类来说，有一个与之相对应的虚函数表（Virtual FunctionTable，
一般简称vtbl），编译器会在用到该类的多个编译单元生成函数表，造成代码重复：外部
程序员的自我修养一链接、装载与库
---
## Page 137
114
第4章静态链接
内联函数、默认构造函数、默认拷贝构造函数和赋值操作符也有类似的问题。它们的解决方
式基本跟模板的重复代码消除类似。
这种方法虽然能够基本上解决代码重复的问题，但还是存在一些问题。比如相同名称的
段可能拥有不同的内容，这可能由于不同的编译单元使用了不同的编译器版本或者编译优化
选项，导致同一个函数编译出来的实际代码有所不同。那么这种情况下链接器可能会做出一
个选择，那就是随意选择其中任何一个副本作为链接的输入，然后同时提供一个警告信息。
函数级别键接
由于现在的程序和库通常来讲都非常庞大，一个目标文件可能包含成千上百个函数或变
量。当我们须要用到某个目标文件中的任意一个函数或变量时，就须要把它整个地链接进来，
也就是说那些没有用到的函数也被一起链接了进来。这样的后果是链接输出文件会变得很
大，所有用到的没用到的变量和函数都一起塞到了输出文件中。
VISUALC++编译器提供了—个编译选项叫函数级别链接（Functional-Level Linking
/Gy），这个选项的作用就是让所有的函数都像前面模板函数一样，单独保存到一个段单面。
当链接器须要用到某个函数时，它就将它合并到输出文件中，对于那些没有用的函数则将它
们撤弃。这种做法可以很大程度上减小输出文件的长度，减少空间浪费。但是这个优化选项
会减慢编译和链接过程，因为链接器须要计算各个函数之间的依赖关系，并且所有函数都保
持到独立的段中，目标函数的段的数量大大增加，重定位过程也会因为段的数目的增加面变
得复杂。目标文件随着段数目的增加也会变得相对较大。
“-fdata-sections”，这两个选项的作用就是将每个函数或变量分别保持到独立的段中。
4.4.2全局构造与析构
我们知道一般的一个C/C++程序是从main开始执行的，随着main函数的结束而结束。
然而，其实在main函数被调用之前，为了程序能够顺利执行，要先初始化进程执行环境，比
如堆分配初始化（malloc、free）、线程子系统等，关于main之前所执行的部分，我们将在本
书的第4部分详细介绍。C++的全局对象构造函数也是在这-时期被执行的，我们知道C++
的全局对象的构造函数在main之前被执行，C++全局对象的析构函数在main之后被执行。
Linux系统下一般程序的入口是“_stan”，这个函数是Linux系统库（Glibc）的一部分。
当我们的程序与Glibc库链接在一起形成最终可执行文件以后，这个函数就是程序的初始化
部分的入口，程序初始化部分完成一系列初始化过程之后，会调用main函数来执行程序的
主体，在main函数执行完成以后，返回到初始化部分，它进行一些清理工作，然后结束进
程。对于有些场合，程序的一些特定的操作必须在main函数之前被执行，还有一些操作必
程序员的自我修养一一链接、装载与库
---
## Page 138