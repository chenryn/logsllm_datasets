never exceeded 1 GB). We use “h” for hours, “m” for minutes, and “s” for seconds.
in the Cryptol language into matrix branching programs, a representation widely used in mmap-
based constructions. 5Gen includes a library of mmaps available through a common API; we
currently support the GGHLite and CLT mmaps, but our library can be easily extended with
new candidates. Leveraging the capabilities of our compiler and mmap libraries, we implemented
applications from two computing paradigms based on mmaps: multi-input functional encryption
(MIFE) and obfuscation.
We measured the eﬃciency of our MIFE and obfuscation applications with various parameter
settings using both the GGHLite and CLT mmaps. While the results show eﬃciency that is clearly
not usable in practice, they provide a useful benchmark for the current eﬃciency of these techniques.
Constructing multilinear maps is an active and rapidly-evolving area of research. Our 5Gen
framework provides an easy-to-use testbed to evaluate new mmap candidates for various applica-
tions and is open-source and freely available at https://github.com/5GenCrypto.
Acknowledgments
The work of Dan Boneh and Kevin Lewi was supported by NSF, DARPA, a grant from ONR, and
the Simons Foundation. The work of Daniel Apon, Jonathan Katz, and Alex J. Malozemoﬀ was
supported in part by NSF awards #1111599 and #1223623. The work of Alex J. Malozemoﬀ was
conducted in part with Government support through the National Defense Science and Engineering
Graduate (NDSEG) Fellowship, 32 CFG 168a, awarded by DoD, Air Force Oﬃce of Scientiﬁc
Research. The work of Brent Carmer and Mariana Raykova was supported by NSF grants CNS-
1633282, 1562888, 1565208, and DARPA SafeWare W911NF-15-C-0236.
This material is based upon work supported by the ARO and DARPA under Contract No.
W911NF-15-C-0227. Any opinions, ﬁndings and conclusions or recommendations expressed in this
material are those of the authors and do not necessarily reﬂect the views of the ARO and DARPA.
References
[AB15]
Benny Applebaum and Zvika Brakerski. Obfuscating circuits via composite-order
graded encoding. In TCC, 2015.
21
[ABD16] Martin Albrecht, Shi Bai, and L´eo Ducas. A subﬁeld lattice attack on overstretched
NTRU assumptions: Cryptanalysis of some FHE and graded encoding schemes. 2016.
[ACLL15] Martin R. Albrecht, Catalin Cocis, Fabien Laguillaumie, and Adeline Langlois. Imple-
menting candidate graded encoding schemes from ideal lattices. In Asiacrypt, 2015.
Prabhanjan Vijendra Ananth, Divya Gupta, Yuval Ishai, and Amit Sahai. Optimizing
obfuscation: Avoiding Barrington’s theorem. In CCS, 2014.
[AGIS14]
[AHKM14] Daniel Apon, Yan Huang, Jonathan Katz, and Alex J. Malozemoﬀ.
Implementing
cryptographic program obfuscation. Cryptology ePrint Archive, Report 2014/779,
2014.
Martin R. Albrecht, Rachel Player, and Sam Scott. On the concrete hardness of
learning with errors. Cryptology ePrint Archive, Report 2015/046, 2015. http://
eprint.iacr.org/2015/046.
Boaz Barak, Oded Goldreich, Russell Impagliazzo, Steven Rudich, Amit Sahai, Salil P.
Vadhan, and Ke Yang. On the (im)possibility of obfuscating programs. In Crypto,
2001.
[APS15]
[BGI+01]
[BGK+14] Boaz Barak, Sanjam Garg, Yael Tauman Kalai, Omer Paneth, and Amit Sahai. Pro-
tecting obfuscation against algebraic attacks. In Eurocrypt, 2014.
[BHLN15] Daniel J. Bernstein, Andreas H¨ulsing, Tanja Lange, and Ruben Niederhagen. Bad
directions in cryptographic hash functions. In ACISP, 2015.
[BMSZ15]
[BLR+15] Dan Boneh, Kevin Lewi, Mariana Raykova, Amit Sahai, Mark Zhandry, and Joe
Zimmerman. Semantically secure order-revealing encryption: Multi-input functional
encryption without obfuscation. In Eurocrypt, 2015.
Saikrishna Badrinarayanan, Eric Miles, Amit Sahai, and Mark Zhandry. Post-zeroizing
obfuscation: The case of evasive circuits. Cryptology ePrint Archive, Report 2015/167,
2015.
Zvika Brakerski and Guy N. Rothblum. Virtual black-box obfuscation for all circuits
via generic graded encoding. In TCC, 2014.
Dan Boneh and Alice Silverberg. Applications of multilinear forms to cryptography.
Cryptology ePrint Archive, Report 2002/080, 2002.
Dan Boneh, Amit Sahai, and Brent Waters. Functional encryption: Deﬁnitions and
challenges. In TCC, 2011.
[BSW11]
[BR14]
[BS02]
[BWZ14a] Dan Boneh, Brent Waters, and Mark Zhandry. Low overhead broadcast encryption
from multilinear maps. Cryptology ePrint Archive, Report 2014/195, 2014.
[BWZ14b] Dan Boneh, David J. Wu, and Joe Zimmerman. Immunizing multilinear maps against
zeroizing attacks. Cryptology ePrint Archive, Report 2014/930, 2014.
22
[CGH+15]
[CHL+15]
[CJL16]
[CLT13]
[CLT15]
Jean-S´ebastien Coron, Craig Gentry, Shai Halevi, Tancr`ede Lepoint, Hemanta K. Maji,
Eric Miles, Mariana Raykova, Amit Sahai, and Mehdi Tibouchi. Zeroizing without
low-level zeroes: New MMAP attacks and their limitations. In Crypto, 2015.
Jung Hee Cheon, Kyoohyung Han, Changmin Lee, Hansol Ryu, and Damien Stehl´e.
Cryptanalysis of the multilinear map over the integers. In Eurocrypt, 2015.
Jung Hee Cheon, Jinhyuck Jeong, and Changmin Lee. An algorithm for NTRU prob-
lems and cryptanalysis of the GGH multilinear map without an encoding of zero.
Cryptology ePrint Archive, Report 2016/139, 2016.
Jean-S´ebastien Coron, Tancr`ede Lepoint, and Mehdi Tibouchi. Practical multilinear
maps over the integers. In Crypto, 2013.
Jean-S´ebastien Coron, Tancr`ede Lepoint, and Mehdi Tibouchi. New multilinear maps
over the integers. In Crypto, 2015.
Cryptol. http://cryptol.net/. Accessed: 2016-05-02.
[Cry]
[DGG+16] Nico D¨ottling, Sanjam Garg, Divya Gupta, Peihan Miao, and Pratyay Mukherjee.
Obfuscation from low noise multilinear maps. Cryptology ePrint Archive, Report
2016/599, 2016.
[GGG+14] Shaﬁ Goldwasser, S. Dov Gordon, Vipul Goyal, Abhishek Jain, Jonathan Katz, Feng-
Hao Liu, Amit Sahai, Elaine Shi, and Hong-Sheng Zhou. Multi-input functional en-
cryption. In Eurocrypt, 2014.
Sanjam Garg, Craig Gentry, and Shai Halevi. Candidate multilinear maps from ideal
lattices. In Eurocrypt, 2013.
[GGH13a]
[GGH+13b] Sanjam Garg, Craig Gentry, Shai Halevi, Mariana Raykova, Amit Sahai, and Brent
Waters. Candidate indistinguishability obfuscation and functional encryption for all
circuits. In FOCS, 2013.
Craig Gentry, Sergey Gorbunov, and Shai Halevi. Graph-induced multilinear maps
from lattices. In TCC, 2015.
[GGH15]
[GGHZ14] Sanjam Garg, Craig Gentry, Shai Halevi, and Mark Zhandry. Fully secure attribute
based encryption from multilinear maps. Cryptology ePrint Archive, Report 2014/622,
2014.
[GGSW13] Sanjam Garg, Craig Gentry, Amit Sahai, and Brent Waters. Witness encryption and
its applications. In STOC, 2013.
[GLSW15] Craig Gentry, Allison Bishop Lewko, Amit Sahai, and Brent Waters. Indistinguisha-
bility obfuscation from the multilinear subgroup elimination assumption. In FOCS,
2015.
Craig Gentry, Allison B. Lewko, and Brent Waters. Witness encryption from instance
independent assumptions. In Crypto, 2014.
[GLW14]
23
[GMS16]
[HJ16]
[Lep14]
[Lin16]
Sanjam Garg, Pratyay Mukherjee, and Akshayaram Srinivasan. Obfuscation without
the vulnerabilities of multilinear maps. Cryptology ePrint Archive, Report 2016/390,
2016.
Yupu Hu and Huiwen Jia. Cryptanalysis of GGH map. In Eurocrypt, 2016.
Tancr`ede Lepoint. Design and Implementation of Lattice-based Cryptography. PhD
thesis, Universit´e du Luxembourg, May 2014.
Huijia Lin.
schemes. In Eurocrypt, 2016.
Indistinguishability obfuscation from constant-degree graded encoding
[LPST16] Huijia Lin, Rafael Pass, Karn Seth, and Sidharth Telang. Indistinguishability obfus-
cation with non-trivial eﬃciency. In PKC, 2016.
Hyung Tae Lee and Jae Hong Seo. Security analysis of multilinear maps over the
integers. In Crypto, 2014.
Adeline Langlois, Damien Stehl´e, and Ron Steinfeld. GGHLite: More eﬃcient multi-
linear maps from ideal lattices. In Eurocrypt, 2014.
Kevin Lewi and David J. Wu. Order-revealing encryption: New constructions, appli-
cations, and lower bounds. In CCS, 2016.
Eric Miles, Amit Sahai, and Mark Zhandry. Annihilation attacks for multilinear maps:
Cryptanalysis of indistinguishability obfuscation over GGH13. In Crypto, 2016.
Eric Miles, Amit Sahai, and Mark Zhandry. Secure obfuscation in a weak multilinear
map model: A simple construction secure against all known attacks. Cryptology ePrint
Archive, Report 2016/588, 2016.
Rafael Pass, Karn Seth, and Sidharth Telang.
Indistinguishability obfuscation
from semantically-secure multi-linear encodings. Cryptology ePrint Archive, Report
2013/781, 2013.
Amit Sahai and Mark Zhandry. Obfuscating low-rank matrix branching programs.
Cryptology ePrint Archive, Report 2014/773, 2014.
Joe Zimmerman. How to obfuscate programs directly. In Eurocrypt, 2015.
[LS14]
[LSS14]
[LW16]
[MSZ16a]
[MSZ16b]
[PST13]
[SZ14]
[Zim15]
A Parameter Selection
In this section, we discuss the parameter selection for both the GGHLite and CLT mmaps that we
consider in this work. Throughout, we use λ as the security parameter and κ as the multilinearity
parameter.
24
A.1 GGHLite
We now discuss the parameter selection used for the GGHLite mmap discussed in §5.1. We discuss
the various parameters, and where applicable, the values we set them to and why. As we build oﬀ
of the code from Albrecht et al. [ACLL15], many of these parameter settings come directly from
that work; we simply document them explicitly here.
• n: The dimension of the lattice. We set n by iteratively producing the below parameters and
then checking whether they satisfy the security parameter according to [APS15], increasing
n by a power of two each iteration (cf. [ACLL15, §4.4]).
• σ: The Gaussian parameter. We set σ = 4πnpe ln(8n)/π according to [LSS14, Eq. (4)].
g : The upper bound on the size of kg−1k. We set ‘−1
Eq. (4)].
√
eπn/σ according to [LSS14,
g = 4
• ‘−1
• ‘: The number of bits to extract from the level-κ encoding. We set ‘ = dlog2(8σn)e according
)
to the discussion in [ACLL15, §4.2].
(2n1.5σpe log(8n)/π
• σ0: The Gaussian parameter for encoding values. We set σ0 = max
according to the discussion in [LSS14, §6].
• q: The modulus. Selected according to [ACLL15, §4.2, pg. 10].
7n2.5 ln1.5(n)σ
A.2 CLT
We now discuss the parameter selection used for the CLT mmap discussed in §5.2. As above, we
discuss the various parameters, and where applicable, the values we set them to and why.
• ρ: The bitlength of the randomness used for encodings. We set ρ = λ to avoid the attack of
Lee and Seo [LS14].
• α: The bitlength of the message slots gi. We set α = λ as suggested by [CLT13].
• β: The bitlength of the random hi values. We set β = λ to avoid a GCD attack similar
to [CLT13, §5.2].
• ρf: The maximum bitlength of the randomness in a level-κ encoding. For the speciﬁc usecase
of obfuscation we can set ρf = κ(ρ + α).
• n: The number of secret primes pi. In Appendix B we show how to adapt the lattice attack
on encodings by Coron et al. [CLT13, §5.1] to the “general” setting where no 0-level encodings
of zero are available, and thus we need to set n = ω(η log λ). However, rather than setting n
to match some asymptotic, such as ηλ, we consider the concrete costs of the various attacks
to give an accurate estimate of n. We use the approach detailed by Tancr`ede Lepoint [Lep14,
§7.2] using the more conservative estimate for the running time of the LLL algorithm [Lep14,
§7.2.5].
• η: The bitlength of the secret primes pi. We set η = ρf + α + β + log2(n) + 9 according
to [CLT13, Lemma 8].
25
• ν: The bitlength of the image of the mmap. We set ν = η−β−ρf −λ−3 according to [CLT13,
Lemma 8].
Note that n, η, and ν depend on each other. Thus, to compute these values we simply loop until
we reach a ﬁxed point, using the requirement that β + α + ρf + log2(n) ≤ η − 9 and ν ≥ α + 6, as
detailed in [CLT13, Lemma 8].
Let x0 =Qn
B Lattice Attack on Encodings
In this section we describe how to adapt the lattice attack on encodings by Coron et al. [CLT13,
§5.1] to our particular use of the CLT mmap.7 In particular, we consider the case where an attacker
has access to t > n level-1 encodings. Without loss of generality, we assume a single z.
j = xj/z mod x0 of secret message
mj = (mij)i, where xj ∈ Zx0 is such that xj mod pi = rijgi + mij. Note that xj mod pi is of size
ρ + α bits and can be considered as a level-0 encoding of mj. Let x0 = (x0
As detailed by Coron et al., we want to use x0 to relate the lattice of vectors u orthogonal to
x0 mod x0 to the lattice of vectors orthogonal to each “plaintext” vector si = (sij)j = (rijgi+mij)j.
We do so as follows.
i=1 pi. For j ∈ [t] consider the level-1 encoding x0
j)j and let x = (xj)j.
By construction we have that
u · x0 ≡ 0
⇐⇒ z(u · x0) ≡ 0
⇐⇒ u · x ≡ 0
(mod x0)
(mod x0)
(mod x0),
where the last equivalence comes from the fact that z and x0 are coprime with high probability.
We can thus apply the attack detailed by Coron et al. [CLT13, §5.1] on vector x0 to directly recover
the vectors si.
Now, given these vectors, we can recover pi for i ∈ [n] with high probability as follows [CHL+15].
Note that
x0
≡ x0
1
2
si1
si2
2si1 ≡ 0
(mod pi)
(mod pi).
⇐⇒ x0
1si2 − x0
1si2 − x0
2si1, x0) to learn pi.
Thus, we can compute gcd(x0
7We thank Tancr`ede Lepoint for detailing this adaptation.
26
Changelog
• Version 2.1 (November 15, 2016):
– Removed erroneous reference to 128-core machine in Table 8.3.
• Version 2.0 (October 26, 2016):
– Updated tables and graphs.
– Added appendices.
– Edits throughout.
• Version 1.0 (June 14, 2016): First release.
27