contents, data sources extend tables with commitments
and sign them. For instance, here is the code for the
provider of the table of cities for the blur query.
Di (cid:31)= χ,sk,X →
let X(cid:26) = map (x: int →Commit x) X in
let H = fold (H,x,ox,Cx →extend H Cx) H0 X(cid:26) in
X(cid:26), sign sk H
This code ﬁrst uses map to extend each source inte-
ger with a fresh opening and commitment, using the
Commit abbreviation; this yield the extended table X(cid:26)
It then uses fold to compute the
passed to the prover.
joint hash of these commitments, and ﬁnally signs the re-
sult. (In the hash computation, H0 is some ﬁxed tag, and
we omit a conversion from eltG to hash). As outlined
at the end of this section, both the prover and the veri-
ﬁer perform some initial processing for these extended
tables: the prover must show his knowledge of the repre-
sentation for these commitments, and the veriﬁer must
verify the signature and the representation proofs for
these commitments.
We illustrate the translation of the map iterator (5) on
the blur query from §2. The translation of fold (6) is
similar. The map expression of blur is translated to an-
other map expression, in a translated environment that
provides the extended input X : [[x : int]] table:
[[Γ (cid:27) map(c → lookup c F) X]] =
map (c,oc,Cc → [[Γ,c : int (cid:27) lookup c F]]) X
and the translation continues with the lookup expression,
as explained above.
Prover Translation Continuing from the result of the
shared translation, the prover translation uniformly turns
its assertions into a custom non-interactive Σ-protocol, in
two passes, written [[ ]]1 and [[ ]]2, that produce code ﬁrst
for the message randomness, then for the responses.
Figure 6 deﬁnes these two passes, as well as the top-
level query translation [[ ]]PROVER that combines [[ ]]1
and [[ ]]2 with additional glue. Overall, the prover for a
source query θ → e is thus deﬁned using this translation
after the shared translation: P (cid:31)= [[ [[θ (cid:27) e]] ]]PROVER.
First-message translation In the ﬁrst pass, H is the pub-
lic hash incrementally computing the global challenge;
a is the accumulated cryptographic evidence that will be
sent to the veriﬁer; and every private variable x is re-
placed with a pair x,tx where tx is the proof random-
ness for x. (Openings are treated as any other secrets.)
In combination with the shared translation, every private
source expression becomes a tuple of the form [[[[e]]]]1 :
(x,tx,ox,tox,Cx) where x is the value of e, tx is the ran-
domness for x, ox is an opening for x, tox is the random-
ness for ox, and Cx is a commitment to x. For efﬁciency,
all these additional values are optional in our compiler.
the type translation [[ρ]]1 maps
shared environments to environments extended with an
entry for each proof randomness, and leaves the other en-
tries unchanged; the expression translation [[ ]]1 takes H
and a as free variables and returns their updated values of
the form extend . . . (extend H E1) ... En, with one exponen-
tial expression Ei for each assertion in e, and a, a1, . . .a m
for each additional evidence a j produced by e.
Compositionally,
We explain the main cases of the ﬁrst-pass translation.
Public expressions are (still) unaffected. Note that they
may includes public expressions generated by the shared
translation, such as products of commitments. Afﬁne pri-
vate expressions are translated homomorphically, adding
a corresponding linear expression on the proof random-
ness. Private exponential computations yields evidence
that must be communicated to the veriﬁer; we add their
results to a. More complex private expression are supple-
mented with the sampling of a fresh message randomness
USENIX Association  
22nd USENIX Security Symposium  171
9
for their result—we rely on the assertions introduced by
the shared translation to prove those expressions.
Assertions of equations of the form eP = ex are trans-
formed into extensions of the global-challenge compu-
tation. The left-hand-side must be a public expression,
and is discarded. The right-hand-side must be an ex-
pression on private variables. Let et be the expressions
obtained by replacing each of theses variables x with tx.
The translation computes it, and extends H with the re-
sult. Declassiﬁcations are similarly translated: the de-
classiﬁed value x is added to a, and the hash is extended
with gtx to link it to its proof randomness (as if we were
translating assert gx=gx). Continuing with our example,
we give below the expression e1, obtained by translating
the shared-translation of the discriminant query, after re-
moving the unnecessary commitment Cd. (This code has
been rearranged for simplicity; the full code produced by
the translation rules appears in the full paper.)
let p = z∗z in
let tp = random() in
let o(cid:31) = oz ∗ z in
let to(cid:31) = random() in
let H = extend H ((Cz)tz ∗G g−tp ∗G h−to(cid:31) ) in
let op = sample() in
let top = random() in
let Cp = gp ∗G hop in
let H = extend (extend H Cp) (gtp ∗G htop ) in
let d = p− 4∗ x∗ y in
let td = tp − 4 ∗ x ∗ ty in
let H = extend (extend H gd) gtd in
let a = a, (p,tp), (o(cid:31),to(cid:31)), (op, top), Cp, d in
(H, a, d)
Response Translation In the second pass, after complet-
ing the computation of the global challenge c, we revisit
the collected evidence a, and we replace every pair of a
private value x and associated proof randomness tx with
the response rx = tx−c∗x. This pass is deﬁned by induc-
tion on the type of a, produced by the ﬁrst-message trans-
lation, which indicates where those pairs are. (Techni-
cally, this pass also needs to re-balance nested tuples, as
the prover produces (. . .(a 0,a1),a2, . . . ,a n) whereas the
veriﬁer consumes (a0, (a1, (. . .a n) . . .)); we omit those
details.) Continuing with the discriminant prover, the re-
sulting evidence a : δ binds the series of variables
(z, tz), (oz, toz), (p,tp), (o(cid:31),to(cid:31)), (op, top), Cp, d
and thus [[δ ]]2 simply computes the responses for the ﬁve
pairs of secret and associated proof randomness:
[[δ ]]2
(cid:28)= let (z,tz), (oz,toz), (p,tp), (o(cid:31),to(cid:31)), (op, top), Cp, d = a
let rz = tz − c∗ z
let roz = toz − c∗ oz
let rp = tp − c∗ p
let r(cid:31)o = to(cid:31) − c∗ o(cid:31)
let rop = top − c∗ op
(rz, roz, rp, ro(cid:31), rop, Cp, d)
Top-Level Prover Translation (P) We arrive at the fol-
lowing code for the prover, given here for the discrim-
inant query. (See Figure 6 for the general case.) This
prover relies on data sources extending both private
source inputs y and z with an opening, a commitment,
and a signature on that commitment
x, (y, oy, Cy, σy), (z, oz, Cz, σz) →
let H = extend (extend H0 Cy) Cz
let tz = random()
let toz = random()
let a = (z,tz), (oz,toz)
let H = extend H (gtz ∗G htoz )
let H, a: δ , d = [[[[θ ]] (cid:26) [[e]]]]1 // phase 1 detailed above
let c = ﬁnalize H in
let a = [[δ ]]2
// phase 2 detailed above
(x, (Cy, σy), (Cz, σz), a, c)
In this code, H0 is the hash of all public values used as
bases in the Σ-protocol, [[θ ]]D is the tuple type of the
(extended) provided data, and [[θ ]]pub is an expression
that extracts their public parts (including the plain signa-
tures, excluding lookup tables). The type δ of the ad-
ditional evidence depends on the ﬁrst-pass of the transla-
tion, and is used to drive the second part. In-between, the
ﬁnal value H : hash is ﬁnalized into the global challenge
c : num. The last line assembles the message passed from
the prover to the veriﬁer, which consists of (1) the public
parts of the input data and of the result; (2) the additional
evidence for proving this result; and (3) the global chal-
lenge for verifying this proof.
Veriﬁer Translation Also following the shared trans-
lation, the prover translation leaves the public parts of
the query unchanged, and it incrementally re-computes
the challenge using the responses and additional evi-
dence prepared by the prover for the private parts of the
query. Figure 7 gives the compositional translation ap-
plied to the result of the shared translation, and the top-
level translation [[ ]]VERIFIER. In combination, the veriﬁer
is deﬁned as V (cid:28)= [[ [[θ (cid:26) e]] ]]VERIFIER.
Compositional translation [[ ]]v In the veriﬁcation pass,
H is the public hash incrementally re-computing the
global challenge, a is the received evidence consumed
by the veriﬁer, and every private variable x is replaced
with a (public) response variable rx—the type translation
[[ρ]]v performs this replacement. In combination with the
shared translation, every private source expression now
yields a tuple of the form rx,rox,Cx where rx and rox are
(presumably) responses associated with the exponents
committed to Cx.
(Again, all these values are actually
optional in the compiler.)
The veriﬁer expression [[e]]v takes free variables H
and a, and additionally returns the updated H and the rest
of a. Public expressions are unchanged. Private expres-
sions are discarded, and replaced with response expres-
sions, either computed (for afﬁne expressions) or read
172  22nd USENIX Security Symposium 
USENIX Association
10
off the evidence a (for more complex expressions). Note
that the translation of afﬁne expressions includes a term
−c∗ a0 for the constant, to ensure that, given correct re-
sponses for its free variables, the translation of an expres-
sion also produces a correct response.
Assertions of equations of the form eP = ex are trans-
lated to hash computations, by computing the expression
(eP)c ∗ er, where er is obtained from ex by replacing ev-
ery variable x with rx, and by extending H with the result.
Declassiﬁcations ↓ x are similarly translated by reading x
off the evidence a and extending the hash with gx+c∗rx.
For instance, continuing with the discriminant query,
the (simpliﬁed) veriﬁer translation [[[[ρ]] (cid:28) [[ed]]]]v is
let rp,ro(cid:27),rop, Cp, d, a = a in
let H = extend H ((Cz)rz ∗G g−rp ∗G h−ro(cid:27) ) in
let H = extend (extend H Cp) ((Cp)c∗G grp ∗G hrop ) in
let rd = rp − 4 ∗ x ∗ ry in
let H = extend (extend H gd) ((gd)c ∗G grd ) in
(H, a ,d)
Top-Level Veriﬁer We ﬁnally give below the top-level
veriﬁer translation, also for our sample discriminant
query; see Figure 7 for additional details.
x, Cy, σy, Cz, σz, a, c →
verify vky Cy σy;
verify vkz Cz σz;
let H = extend (extend H0 Cy) Cz
let rz, roz, a = a in
let H = extend H Cc
let H, a, d = [[[[θ ]] (cid:28) [[e]]]]v in // translation detailed above
check c = ﬁnalize H;
d
z ∗G hroz in
z ∗G gr
The prover ﬁrst veriﬁes the signatures on the two re-
ceived commitments for y and z; it starts the challenge
re-computation on the representation equation for input z
(since we need a response for z an oz to check the proof
of the square z2), then proceeds with the veriﬁcation for
the query expression; it checks that the received and re-
computed challenges match; it ﬁnally returns the public
result d (unless of course verify or check raised an error.)
6 Security Theorems
Consider a well-typed ZQL source query Q (cid:25)= θ →↓ e,
with (cid:31) input variables θ = (xi : τi)i=0..(cid:31)−1, that declassi-
ﬁes only its result and its translation (S, (Ki, Di)i=0..(cid:31)−1,
P, V). We give our main results based on the deﬁnitions
of §3. We refer to the full paper for the proof outlines,
and for a discussion of automated, type-based veriﬁca-
tion for the compiled protocols. For functional correct-
ness and soundness, we also suppose that there is no
source-program overﬂow—formally, integers and their
operations are computed modulo q.
Theorem 1 (Functional Correctness)
(S, (Ki, Di)i=0..(cid:31)−1, P, V) is correct.
Theorem 2 (Perfect Privacy)
(S, (Ki, Di)i=0..(cid:31)−1, P, V) is (t,0)-private.
Our soundness theorem below is in the random-oracle
model, requiring that extend and ﬁnalize are indepen-
dent random oracles. It assumes that the Discrete Loga-
rithm (DL) and Strong Difﬁe Hellman (SDH) assump-
tions hold—to guarantee the security of commitments
and CL signatures, respectively—and assuming that the
(cid:31)CMA conventional signatures primitives of data-sources
are chosen message attack secure (CMA).
is
Theorem 3 (Computational Soundness)
(t,ε)-sound, where the
(S, (Ki, Di)i=0..(cid:31)−1, P, V)
execution time t and success probability ε are respec-
tively lower- and upper-bounded by the corresponding
parameters of the assumptions.
Concretely, let tDL, tSDH, tCMA and εDL, εSDH, εCMA
be those parameters, for large enough bounds on the
number of calls to their primitives. If t < tCMA − tred1,
t < (tDL − tred2)/2, and t < (tSDH − tred3)/2, where the
then ε < (cid:31)CMA · εCMA + Q ·
tredi are small constants,
(cid:31)εDL + ((cid:31)− (cid:31)CMA)· εSDH + Q2/q, where Q is the num-
ber of random oracle queries made by A and q is the
order of G and thus also the size of the challenge.
In contrast with our privacy theorem, which is
information-theoretic, our concrete-security soundness
theorem is somewhat more cumbersome than the asymp-
totic security theorems often found in theoretical cryp-
tography, but it remains closer to reality, in which cryp-
tographic primitives come with concrete security bounds,
and thus provides guidance for conﬁguring these primi-
tives to achieve adequate security.
7 ZQL applications
The expressivity of ZQL stems from the ease with which
the primitive operators can be composed to build larger
queries. We illustrate this by providing queries for appli-
cations in prior literature.
In the setting of smart metering, a meter issues signed
private readings, and a household needs to compute their
bill on the basis of a public tariff policy that maps each
reading to a fee over time. A number of custom privacy
protocols have been proposed to do this [55, 48]. One
such billing policy takes a table of public times and pri-
vate readings, as well as a lookup table from readings to
prices to be summed:
let smart meter bill