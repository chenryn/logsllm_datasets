本章将带领你进入 Docker 的世界。
什么是 Docker？
用它会带来什么样的好处？
好吧，让我们带着问题开始这神奇之旅。
14
什么是 Docker
什么是 Docker
Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司
内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3
月以 Apache 2.0 授权协议开源)，主要项目代码在 GitHub 上进行维护。Docker 项
目后来还加入了 Linux 基金会，并成立推动开放容器联盟。
Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 3 万 6 千个
星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公
司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则
从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用
Docker。
Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的
cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，
属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进
程，因此也称其为容器。最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使
用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和
containerd。
Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔
离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻
便、快捷。
下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟
出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；
而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有
进行硬件虚拟。因此容器要比传统虚拟机更为轻便。
15
什么是 Docker
图 1.4.1.1 - 传统虚拟化
图 1.4.1.2 - Docker
16
为什么要用 Docker
为什么要使用 Docker？
作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。
更高效的利用系统资源
由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统
资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传
统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运
行更多数量的应用。
更快速的启动时间
传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接
运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启
动时间。大大的节约了开发、测试、部署的时间。
一致的运行环境
开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环
境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内
核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码
在我机器上没问题啊” 这类问题。
持续交付和部署
对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意
地方正常运行。
使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员
可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系
统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合
持续部署(Continuous Delivery/Deployment) 系统进行自动部署。
17
为什么要用 Docker
而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环
境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。
更轻松的迁移
由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在
很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运
行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一
个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。
更轻松的维护和扩展
Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也
使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此
外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可
以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜
像制作成本。
对比传统虚拟机总结
特性 容器 虚拟机
启动 秒级 分钟级
硬盘使用 一般为 MB 一般为 GB
性能 接近原生 弱于
系统支持量 单机支持上千个容器 一般几十个
18
基本概念
基本概念
Docker 包括三个基本概念
镜像（Image）
容器（Container）
仓库（Repository）
理解了这三个概念，就理解了 Docker 的整个生命周期。
19
镜像
Docker 镜像
我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂
载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于
是一个 root 文件系统。比如官方镜像 ubuntu:14.04 就包含了完整的一套
Ubuntu 14.04 最小系统的 root 文件系统。
Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资
源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境
变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。
分层存储
因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在
Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以
严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其
实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系
统联合组成。
镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生
改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，
实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容
器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因
此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，
任何额外的东西应该在该层构建结束前清理掉。
分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的
镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜
像。
关于镜像构建，将会在后续相关章节中做进一步的讲解。
20
容器
Docker 容器
镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中
的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被
创建、启动、停止、删除、暂停等。
容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的
独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、
自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环
境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容
器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学
Docker 时常常会把容器和虚拟机搞混。
前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为
基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而
准备的存储层为容器存储层。
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，
任何保存于容器存储层的信息都会随容器删除而丢失。
按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储
层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者
绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发
生读写，其性能和稳定性更高。
数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷
后，容器可以随意删除、重新 run ，数据却不会丢失。
21
仓库
Docker Registry
镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器
上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry
就是这样的服务。
一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多
个标签（Tag）；每个标签对应一个镜像。
通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的
各个版本。我们可以通过 : 的格式来指定具体是这个软件哪个版
本的镜像。如果不给出标签，将以 latest 作为默认标签。
以 Ubuntu 镜像 为例， ubuntu 是仓库的名字，其内包含有不同的版本标签，
如， 14.04 , 16.04 。我们可以通过 ubuntu:14.04 ，或者 ubuntu:16.04
来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu ，那将视为
ubuntu:latest 。
仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy ，前者往往意
味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这
并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。
Docker Registry 公开服务
Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服
务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务
供用户管理私有镜像。
最常使用的 Registry 公开服务是官方的 Docker Hub，这也是默认的 Registry，并
拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相
关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像
使用的就是这个服务。
由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针
对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见
的有 阿里云加速器、DaoCloud 加速器、灵雀云加速器等。使用加速器会直接从国
22
仓库
内的地址下载 Docker Hub 的镜像，比直接从官方网站下载速度会提高很多。在后
面的章节中会有进一步如何配置加速器的讲解。
国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓
库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库等。
私有 Docker Registry
除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方
提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在后续的相
关章节中，会有进一步的搭建私有 Registry 服务的讲解。
开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支
持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、
访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这
些高级功能。
除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚
至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype
Nexus。
23
安装 Docker
安装 Docker
官方网站上有各种环境下的 安装指南，这里主要介绍下 Ubuntu、Debian 和
CentOS 系列的安装。
24
Ubuntu、Debian
Ubuntu、Debian 系列安装 Docker
系统要求
Docker 支持以下版本的 Ubuntu 和 Debian 操作系统：
Ubuntu Xenial 16.04 (LTS)
Ubuntu Trusty 14.04 (LTS)
Ubuntu Precise 12.04 (LTS)
Debian testing stretch (64-bit)
Debian 8 Jessie (64-bit)
Debian 7 Wheezy (64-bit)（必须启用 backports)
Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级
维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。
Docker 目前支持的 Ubuntu 版本最低为 12.04 LTS，但从稳定性上考虑，推荐使用
14.04 LTS 或更高的版本。
Docker 需要安装在 64 位的 x86 平台或 ARM 平台上（如树莓派），并且要求内核
版本不低于 3.10。但实际上内核越新越好，过低的内核版本可能会出现部分功能无
法使用，或者不稳定。
用户可以通过如下命令检查自己的内核版本详细信息：
$ uname -a
Linux device 4.4.0-45-generic #66~14.04.1-Ubuntu SMP Wed Oct 19
15:05:38 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux
升级内核
如果内核版本过低，可以用下面的命令升级系统内核。
Ubuntu 12.04 LTS
sudo apt-get install -y --install-recommends linux-generic-lts-t
rusty
25
Ubuntu、Debian
Ubuntu 14.04 LTS
sudo apt-get install -y --install-recommends linux-generic-lts-x
enial
Debian 7 Wheezy
Debian 7 的内核默认为 3.2，为了满足 Docker 的需求，应该安装 backports 的
内核。
执行下面的命令添加 backports 源：
$ echo "deb http://http.debian.net/debian wheezy-backports main"
| sudo tee /etc/apt/sources.list.d/backports.list
升级到 backports 内核：
$ sudo apt-get update
$ sudo apt-get -t wheezy-backports install linux-image-amd64
Debian 8 Jessie
Debian 8 的内核默认为 3.16，满足基本的 Docker 运行条件。但是如果打算使用
overlay2 存储层驱动，或某些功能不够稳定希望升级到较新版本的内核，可以
添加 backports 源，升级到新版本的内核。
执行下面的命令添加 backports 源：
$ echo "deb http://http.debian.net/debian jessie-backports main"
| sudo tee /etc/apt/sources.list.d/backports.list
升级到 backports 内核：
$ sudo apt-get update
$ sudo apt-get -t jessie-backports install linux-image-amd64
26
Ubuntu、Debian
需要注意的是，升级到 backports 的内核之后，会因为 AUFS 内核模块不可
用，而使用默认的 devicemapper 驱动，并且配置为 loop-lvm ，这是不推荐
的。因此，不要忘记安装 Docker 后，配置 overlay2 存储层驱动。
配置 GRUB 引导参数
在 Docker 使用期间，或者在 docker info 信息中，可能会看到下面的警告信
息：
WARNING: Your kernel does not support cgroup swap limit. WARNING
: Your
kernel does not support swap limit capabilities. Limitation disc
arded.
或者
WARNING: No memory limit support
WARNING: No swap limit support
WARNING: No oom kill disable support
如果需要这些功能，就需要修改 GRUB 的配置文件 /etc/default/grub ，在
GRUB_CMDLINE_LINUX 中添加内核引导参数 cgroup_enable=memory
swapaccount=1 。
然后不要忘记了更新 GRUB：
$ sudo update-grub
$ sudo reboot
使用脚本自动安装
Docker 官方为了简化安装流程，提供了一套安装脚本，Ubuntu 和 Debian 系统可
以使用这套脚本安装：
curl -sSL https://get.docker.com/ | sh
27
Ubuntu、Debian
执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 安装在系