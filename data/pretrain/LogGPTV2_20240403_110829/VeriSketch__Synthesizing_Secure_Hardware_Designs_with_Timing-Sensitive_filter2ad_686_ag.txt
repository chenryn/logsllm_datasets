automatic instrumentation. In Proceedings of the 17th ACM conference on Computer
and communications security. ACM, 284–296.
[24] William R Harris, Somesh Jha, Thomas W Reps, and Sanjit A Seshia. 2017. Pro-
gram synthesis for interactive-security systems. Formal Methods in System Design
51, 2 (2017), 362–394.
[25] Stefan Heule, Eric Schkufza, Rahul Sharma, and Alex Aiken. 2016. Stratified
synthesis: automatically learning the x86-64 instruction set. In ACM SIGPLAN
Notices, Vol. 51. ACM, 237–250.
[26] Wei Hu, Andrew Becker, Armita Ardeshiricham, Yu Tai, Paolo Ienne, Dejun Mu,
and Ryan Kastner. 2016. Imprecise security: quality and complexity tradeoffs for
hardware information flow tracking. In Computer-Aided Design (ICCAD), 2016
IEEE/ACM International Conference on. IEEE, 1–8.
[27] Susmit Jha, Sumit Gulwani, Sanjit A Seshia, and Ashish Tiwari. 2010. Oracle-
guided component-based program synthesis. In Proceedings of the 32nd ACM/IEEE
International Conference on Software Engineering-Volume 1. ACM, 215–224.
[28] Paul Kocher, Daniel Genkin, Daniel Gruss, Werner Haas, Mike Hamburg, Moritz
Lipp, Stefan Mangard, Thomas Prescher, Michael Schwarz, and Yuval Yarom. 2018.
Spectre attacks: Exploiting speculative execution. arXiv preprint arXiv:1801.01203
(2018).
[29] Xun Li, Vineeth Kashyap, Jason K Oberg, Mohit Tiwari, Vasanth Ram Rajarathi-
nam, Ryan Kastner, Timothy Sherwood, Ben Hardekopf, and Frederic T Chong.
2014. Sapper: A language for hardware-level security policy enforcement. ACM
SIGARCH Computer Architecture News 42, 1 (2014), 97–112.
[30] Xun Li, Mohit Tiwari, Jason K Oberg, Vineeth Kashyap, Frederic T Chong, Tim-
othy Sherwood, and Ben Hardekopf. 2011. Caisson: a hardware description
language for secure information flow. In ACM SIGPLAN Notices, Vol. 46. ACM,
109–120.
[31] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner Haas,
Stefan Mangard, Paul Kocher, Daniel Genkin, Yuval Yarom, and Mike Hamburg.
2018. Meltdown. arXiv preprint arXiv:1801.01207 (2018).
[32] Milica Mitić and Mile Stojčev. 2006. A survey of three system-on-chip buses:
AMBA, coreconnect and wishbone. In Proc. 41st Int. Conf. Inform. Commun.
Energy Syst. Technol.(ICEST). Citeseer, 282–285.
[33] Jason Oberg, Wei Hu, Ali Irturk, Mohit Tiwari, Timothy Sherwood, and Ryan
Kastner. 2011. Information flow isolation in I2C and USB. In Proceedings of the
48th Design Automation Conference. ACM, 254–259.
[34] J. Oberg, S. Meiklejohn, T. Sherwood, and R. Kastner. 2014. Leveraging gate-
level properties to identify hardware timing channels. Computer-Aided Design of
Integrated Circuits and Systems, IEEE Transactions on 33, 9 (2014), 1288–1301.
[35] Jason Oberg, Timothy Sherwood, and Ryan Kastner. 2013. Eliminating timing
information flows in a mix-trusted system-on-chip. IEEE Design & Test 30, 2
(2013), 55–62.
[36] Colin Percival. 2005. Cache missing for fun and profit. (2005).
[37] Nadia Polikarpova, Ivan Kuraj, and Armando Solar-Lezama. 2016. Program
synthesis from polymorphic refinement types. ACM SIGPLAN Notices 51, 6
(2016), 522–538.
[38] Nadia Polikarpova, Jean Yang, Shachar Itzhaky, and Armando Solar-Lezama. 2016.
Type-Driven Repair for Information Flow Security. CoRR abs/1607.03445 (2016).
arXiv:1607.03445 http://arxiv.org/abs/1607.03445
[39] Leonid Ryzhyk, Peter Chubb, Ihor Kuz, Etienne Le Sueur, and Gernot Heiser. [n.
d.]. Automatic device driver synthesis with Termite. In Proceedings of the ACM
SIGOPS 22nd symposium on Operating systems principles, 2009.
[40] Leonid Ryzhyk, Adam Walker, John Keys, Alexander Legg, Arun Raghunath,
Michael Stumm, and Mona Vij. 2014. User-Guided Device Driver Synthesis.. In
OSDI. 661–676.
[41] Calvin Smith and Aws Albarghouthi. 2016. MapReduce program synthesis. ACM
SIGPLAN Notices 51, 6 (2016), 326–340.
[42] Armando Solar-Lezama. 2013. Program sketching.
Software Tools for Technology Transfer 15, 5-6 (2013), 475–495.
International Journal on
[43] Armando Solar-Lezama, Liviu Tancau, Rastislav Bodik, Sanjit Seshia, and Vijay
Saraswat. 2006. Combinatorial sketching for finite programs. ACM SIGOPS
Operating Systems Review 40, 5 (2006), 404–415.
[44] Sooel Son, Kathryn S McKinley, and Vitaly Shmatikov. 2013. Fix Me Up: Repairing
Access-Control Bugs in Web Applications.. In NDSS.
[45] Pramod Subramanyan, Bo-Yuan Huang, Yakir Vizel, Aarti Gupta, and Sharad
Malik. 2017. Template-based Parameterized Synthesis of Uniform Instruction-
Level Abstractions for SoC Verification. IEEE Transactions on Computer-Aided
Design of Integrated Circuits and Systems (2017).
[46] Mohit Tiwari, Hassan M.G. Wassel, Bita Mazloom, Shashidhar Mysore, Frederic T.
Chong, and Timothy Sherwood. 2009. Complete Information Flow Tracking from
the Gates Up. In International Conference on Architectural Support for Programming
Languages and Operating Systems. 109–120. https://doi.org/10.1145/1508244.
1508258
[47] Xinyu Wang, Isil Dillig, and Rishabh Singh. 2017. Synthesis of data completion
scripts using finite tree automata. Proceedings of the ACM on Programming
Languages 1, OOPSLA (2017), 62.
[48] Zhenghong Wang and Ruby B Lee. 2007. New cache designs for thwarting soft-
ware cache-based side channel attacks. In ACM SIGARCH Computer Architecture
News.
[49] Clifford Wolf. [n. d.]. Yosys Open SYnthesis Suite. http://www.clifford.at/yosys/.
[50] Bo-Han Wu, Chun-Ju Yang, Chung-Yang Ric Huang, and Jie-Hong Roland Jiang.
[n. d.]. A robust functional ECO engine by SAT proof minimization and interpola-
tion techniques. In Proceedings of the International Conference on Computer-Aided
Design, 2010.
[51] Navid Yaghmazadeh, Christian Klinger, Isil Dillig, and Swarat Chaudhuri. 2016.
Synthesizing transformations on hierarchically structured data. In ACM SIGPLAN
Notices, Vol. 51. ACM, 508–521.
[52] Navid Yaghmazadeh, Yuepeng Wang, Isil Dillig, and Thomas Dillig. 2017. Sqlizer:
Query synthesis from natural language. Proceedings of the ACM on Programming
Languages 1, OOPSLA (2017), 63.
[53] Danfeng Zhang, Yao Wang, G Edward Suh, and Andrew C Myers. 2015. A
hardware design language for timing-sensitive information-flow security. In
([n. d.]).
ACM SIGARCH Computer Architecture News, Vol. 43. ACM, 503–516.
[54] Sai Zhang and Yuyin Sun. 2013. Automatically synthesizing sql queries from input-
output examples. In Proceedings of the 28th IEEE/ACM International Conference
on Automated Software Engineering. IEEE Press, 224–234.
[55] Michael Zimmer, David Broman, Chris Shaver, and Edward A Lee. 2014. FlexPRET:
A processor platform for mixed-criticality systems. In Real-Time and Embedded
Technology and Applications Symposium (RTAS), 2014 IEEE 20th. IEEE, 101–110.
APPENDIX
A SECURITY ANALYSIS OF SKETCH CACHE
VS. PLCACHE
Results of simulating PLCache and the sketch cache with traces that
represent the extended Percival attack on LRU bits are shown in
Fig. 8. Fig. 8(a) and (b) show the results of simulating PLCache and
are identical to Fig. 6(a) and (b). Fig. 8(c) and (d) show the results of
simulating the sketch cache. Fig. 8(a) and (c) show the case where
the victim process (pid=1) accesses its locked data at stage 3 (case
A). Fig. 8(b) and (d) represent the case where the victim does not
access its locked data and accesses a different cache set (case B). In
this simple example we use the 4 lowest bits as index; hence, all
addresses except for 0x802 map to the same cache set.
The extended Percival attack on the LRU bits of a partition locked
cache comprises five stages. In the first stage the victim process
preloads and locks its sensitive data. Next, the attacker fills the
cache set but is not able to evict the cache block which contains
the locked data. At this point, the cache set includes the victim’s
locked data as well as the attacker’s data. Furthermore, the attacker
knows that its data is the most recently used data as it was just
accessed. Now, consider case A where the victim process accesses
its locked data at stage 3. This access results in a cache hit. In
PLCache (Fig. 8(a)) this access changes the LRU bits by making
the locked data the most recently used block and consequently
making the attacker’s data the least recently used block. In the
sketch cache (Fig. 8(c)) this access does not modify the LRU bits
and the locked block remains the least recently used. In case B,
the LRU bits remain unmodified in both PLCache and the sketch
cache (Fig. 8(b) and (d)). In stage 4, the attacker aims to observe
the potential changes in the LRU bits. This is done by the attacker
trying to bring new data to the cache in order to force an eviction
in the set. In PLCache, the attacker is able to evict its own data
in case A since it had become the least recently used. However, it
cannot evict its data in case B because the locked data is the least
recently used block which cannot be evicted. In the synthesized
cache, the attacker is not able to force an eviction in any of the
cases. In stage 5, the attacker accesses the data which was brought
to the cache in stage 2. In PLCache, this results in a cache miss in
case A and a cache hit in case B. Hence, the attacker can observe
the difference between the two cases through the timing variation.
In our simulations, this timing variation manifests itself through
the value of the stall signal and the timing label of the data which
is read by the processor rd_data_proc_t (Fig. 8(a) vs. Fig. 8(b)). In
the synthesized cache, the adversary observes a cache hit in both
cases (Fig. 8(c) vs. Fig. 8(d)).
B PROPERTIES FOR SYNTHESIZING THREAD
SCHEDULERS AND SOC ARBITERS
Figure 8: Simulating PLCache and the synthesized cache with traces representing the extended Pecival attack.
Table 6: Summary of properties used for synthesizing thread schedulers.
Synopsis
(V) Valid thread id
(C) Confidentiality of sensitive threads
(P) Predictability of hard real-time threads
(G) Guaranteed frequencies
(E) Scheduling available threads
(F) Fairness for soft real-time threads
Formal Representation
valid (cid:55)→ assert(thread_id < n)
∀i.(i.sensitive) (cid:55)→ assume (i.actives = Hiдh)assert (thread_idt = Low)
∀i. (i.hardRT) (cid:55)→ assert (i.f req + i.sleep = i.count)
∀i. assert (i.f req + i.sleep ≤ i.count)
∀i. ¬i.active (cid:55)→ try (thread_id (cid:44) i)
∀i, j.(¬i.hardRT ∧ ¬j.hardRT)) (cid:55)→ try ((i.count − i.f req) = (j.count − j.f req))
//Sketch Cache — Case A //(1) Victim preloading sensitive addresses pid=1, lock=1, addr=0x801, addr_s=0x0,stall=1, rd_proc_t=0
pid=1, lock=1, addr=0x801, addr_s=0x0, stall=0, rd_proc_t=0
//(2) Adversary ﬁlling the cache block pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=0, rd_proc_t=0
//(3) Victim accessing preloaded data pid=1, lock=1, addr=0x801, addr_s=0xFFFF, stall=0, rd_proc_t= 0xFFFF
//(4) Adversary actions exposing the eﬀect of the LRU bits  pid=0, lock=0, addr=0xF81, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF81, addr_s=0x0,  stall=0, rd_proc_t=0
//(5) Adversary getting a cache hit pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0x0Sketch Cache — Case B //(1) Victim preloading sensitive addresses pid=1, lock=1, addr=0x801, addr_s=0x0, stall=1, rd_proc_t=0
pid=1, lock=1, addr=0x801, addr_s=0x0, stall=0, rd_proc_t=0
//(2) Adversary ﬁlling the cache block pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=0, rd_proc_t=0
//(3) Victim accessing another cache set pid=1, lock=0, addr=0x802, addr_s= 0x0, stall=0,rd_proc_t= 0x0
//(4) Adversary actions exposing the eﬀect of the LRU bits pid=0, lock=0, addr=0xF81, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF81, addr_s=0x0, stall=0, rd_proc_t=0
//(5) Adversary getting a cache hit pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0x0(c)(d)//PLCache — Case A //(1) Victim preloading sensitive addresses pid=1, lock=1, addr=0x801, addr_s=0x0,stall=1, rd_proc_t=0
pid=1, lock=1, addr=0x801, addr_s=0x0, stall=0, rd_proc_t=0
//(2) Adversary ﬁlling the cache block pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=0, rd_proc_t=0
//(3) Victim accessing preloaded data pid=1, lock=1, addr=0x801, addr_s=0xFFFF, stall=0, rd_proc_t= 0xFFFF
//(4) Adversary actions exposing the eﬀect of the LRU bits  pid=0, lock=0, addr=0xF81, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF81, addr_s=0x0,  stall=0, rd_proc_t=0
//(5) Adversary getting a cache miss pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=1, rd_proc_t=0x0
pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t= 0xFFFF//PLCache — Case B //(1) Victim preloading sensitive addresses pid=1, lock=1, addr=0x801, addr_s=0x0, stall=1, rd_proc_t=0
pid=1, lock=1, addr=0x801, addr_s=0x0, stall=0, rd_proc_t=0
//(2) Adversary ﬁlling the cache block pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xE01, addr_s=0x0, stall=0, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF01, addr_s=0x0, stall=0, rd_proc_t=0
//(3) Victim accessing another cache set pid=1, lock=0, addr=0x802, addr_s= 0x0, stall=0,rd_proc_t= 0x0
//(4) Adversary actions exposing the eﬀect of the LRU bits pid=0, lock=0, addr=0xF81, addr_s=0x0, stall=1, rd_proc_t=0
pid=0, lock=0, addr=0xF81, addr_s=0x0, stall=0, rd_proc_t=0
//(5) Adversary getting a cache hit pid=0, lock=0, addr=0xC01, addr_s=0x0, stall=0, rd_proc_t=0x0(a)(b)Table 7: Summary of properties used for synthesizing SoC arbiters.
Synopsis
Grant given to at most n cores
Grant given to a core which requested
Stabilizing the grant while a core is using
Equal share
Denying access to core #i
Prioritizing core #i
Priority-based access
Non-interference between all cores
Non-interference between cores #i, j
assert(n−1
i =0
( n−2
assert(i−1
j=i +1
j=0
assert(reqs ↛t ¬дrants)
assert((reqs[i] ↛t ¬дrants[j]) ∧ (reqs[j] ↛t ¬дrants[i]))
Formal Representation
assert(Countones(дrant) ≤ n)
assert(Past(req) (cid:55)→ (∀i. дrant[i] (cid:55)→ Past(req[i])))
assert((дrant[i] ∧ Past(req[i])) (cid:55)→ Stable(дrant))
(Past(дrant, period ∗ i) = Past(дrant, period ∗ j))))
assert(¬дrant[i])
assert(Past(req[i]) (cid:55)→ дrant[i])
¬Past(req[j]) ∧ (Past(req[i]) (cid:55)→ дrant[i]))