### Exploit Kits and Their Evolution: A Case Study

#### Introduction
In September 2014, three exploit kits used identical code to check for the presence of certain system files associated with antivirus (AV) solutions. If these solutions were detected, the kits would halt the attack to avoid detection. Notably, some kits included Java exploits without conducting version checks, making it challenging to identify specific Common Vulnerabilities and Exposures (CVEs).

#### Exploit Kit Structure
Exploit kits are composed of several layers, typically including an unpacker, a plugin and AV detector, an eval/execution trigger, and at least one malicious payload.

- **Unpackers**: The outermost layer is designed to obfuscate the kit's inner workings, often through packing or encoding techniques.
- **Malicious Payload**: This targets known vulnerabilities in browsers or plugins. Typically, each kit includes 5-7 CVEs.
- **Eval Trigger**: A short script that initiates the execution of the exploit kit.

#### Evolution of Exploit Kits
To understand the evolution of exploit kits, we analyzed the Nuclear kit over three months. Our findings include:

- **Changing the Packer**: Frequent syntactic changes were made to the packer to evade AV detection. For example, between June 1 and June 14, the `eval` function was modified from `ev#FFFFFFal` to `e#FFFFFFFval`.
- **Appending New Exploits**: Less frequent changes were observed in the plugin detection and payload. On July 29, AV detection was added to the plugin detector, and on August 27, a new CVE was introduced.
- **Code Borrowing**: In June, the Nuclear kit did not use code to detect AV software. However, by August, it had adopted the exact code from the RIG kit, indicating code borrowing.

#### Adversarial Cycle
Exploit kit authors are in a constant arms race with antivirus companies and other kit authors. The cycle involves:

1. **Initial Undetected State**: The kit is not detected by AV, presenting a challenge for analysts who must create new signatures.
2. **Signature Deployment**: Once a signature is created and deployed, the attacker modifies the kit to evade detection.
3. **Continuous Adaptation**: Attackers make small, frequent changes to the packer, while larger, less frequent changes are made to the payload and plugin detection.

#### Example: Angler Exploit Kit
In August 2014, the Angler kit underwent a change that temporarily rendered it undetectable by a commercial AV engine. By modifying the unique string used in the signature, the kit remained undetected from August 13 to around August 19.

#### Techniques: Kizzle
Kizzle is a system designed to detect and cluster exploit kits. The process involves:

1. **Clustering Samples**: Tokenizing and clustering samples based on abstract JavaScript tokens to eliminate noise.
2. **Labeling Clusters**: Selecting a prototype sample from each cluster, unpacking it, and labeling it as benign or malicious.
3. **Generating Signatures**: Creating new signatures for malicious clusters.

The input to Kizzle includes new samples and existing unpacked malware samples. The system uses a hierarchical clustering algorithm, such as DBSCAN, with a threshold of 0.10 to generate clusters.

#### Conclusion
Exploit kits evolve through frequent changes to their outer layers and occasional updates to their payloads. Understanding this evolution is crucial for developing effective detection and mitigation strategies. Systems like Kizzle can help in automating the detection and clustering of these kits, providing a more robust defense against evolving threats.