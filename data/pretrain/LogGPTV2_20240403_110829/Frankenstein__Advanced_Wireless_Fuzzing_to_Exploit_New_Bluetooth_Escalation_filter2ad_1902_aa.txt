title:Frankenstein: Advanced Wireless Fuzzing to Exploit New Bluetooth Escalation
Targets
author:Jan Ruge and
Jiska Classen and
Francesco Gringoli and
Matthias Hollick
Frankenstein: Advanced Wireless Fuzzing to 
Exploit New Bluetooth Escalation Targets
Jan Ruge and Jiska Classen, Secure Mobile Networking Lab, TU Darmstadt; 
Francesco Gringoli, Dept. of Information Engineering, University of Brescia; 
Matthias Hollick, Secure Mobile Networking Lab, TU Darmstadt
https://www.usenix.org/conference/usenixsecurity20/presentation/ruge
This paper is included in the Proceedings of the 29th USENIX Security Symposium.August 12–14, 2020978-1-939133-17-5Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.Frankenstein: Advanced Wireless Fuzzing to
Exploit New Bluetooth Escalation Targets
Secure Mobile Networking Lab
Secure Mobile Networking Lab
Dept. of Information Engineering
Secure Mobile Networking Lab
Jan Ruge
TU Darmstadt
Francesco Gringoli
University of Brescia
Jiska Classen
TU Darmstadt
Matthias Hollick
TU Darmstadt
Abstract
Wireless communication standards and implementations have
a troubled history regarding security. Since most implemen-
tations and ﬁrmwares are closed-source, fuzzing remains
one of the main methods to uncover Remote Code Execu-
tion (RCE) vulnerabilities in deployed systems. Generic over-
the-air fuzzing suffers from several shortcomings, such as
constrained speed, limited repeatability, and restricted ability
to debug. In this paper, we present Frankenstein, a fuzzing
framework based on advanced ﬁrmware emulation, which
addresses these shortcomings. Frankenstein brings ﬁrmware
dumps “back to life”, and provides fuzzed input to the chip’s
virtual modem. The speed-up of our new fuzzing method
is sufﬁcient to maintain interoperability with the attached
operating system, hence triggering realistic full-stack behav-
ior. We demonstrate the potential of Frankenstein by ﬁnding
three zero-click vulnerabilities in the Broadcom and Cypress
Bluetooth stack, which is used in most Apple devices, many
Samsung smartphones, the Raspberry Pis, and many others.
Given RCE on a Bluetooth chip, attackers may escalate
their privileges beyond the chip’s boundary. We uncover a
Wi-Fi/Bluetooth coexistence issue that crashes multiple oper-
ating system kernels and a design ﬂaw in the Bluetooth 5.2
speciﬁcation that allows link key extraction from the host.
Turning off Bluetooth will not fully disable the chip, making
it hard to defend against RCE attacks. Moreover, when test-
ing our chip-based vulnerabilities on those devices, we ﬁnd
BlueFrag, a chip-independent Android RCE.
1 Introduction
Bluetooth is present in a lot of privacy-sensitive applications.
These include headsets that we share contacts with, smart-
watches, cars, medical devices, and all kinds of Internet of
Things (IoT) products. Around 4.4 billion Bluetooth-enabled
devices will be presumably shipped in 2020 alone, and annual
device shipments are growing [11].
The overall zero-click attack surface is comparably large.
For example, all Apple devices publicly expose connectable
Bluetooth Low Energy (BLE) Generic Attribute (GATT) ser-
vices whenever Bluetooth is enabled—even without prior
pairing. Many devices have Bluetooth enabled by default, and
quite a number of them advertise their identity [46]. Despite
these identities being anonymous, an attacker might ﬁnd inter-
esting targets near airports or ofﬁce buildings. Vulnerabilities
are wormable, as most devices can initiate new connections.
In this work, we evaluate various attack vectors based on
RCE. We consider attacks that are either compliant with the
Bluetooth 5.2 speciﬁcation [12], propagate into components
outside of the Bluetooth chip, or brick the Bluetooth hardware.
On Broadcom combo chips, Wi-Fi and Bluetooth run on sep-
arate Advanced RISC Machine (ARM) cores. As they share
the 2.4 GHz antenna, they need to agree on access through
coexistence mechanisms. Using coexistence, we escalate from
Bluetooth into Wi-Fi components, block these, and then force
reboot various devices, including the iPhone 11.
We gain Bluetooth zero-click RCE by systematically
fuzzing those parts of the Broadcom ﬁrmware that can be
reached prior to pairing. Cypress acquired parts of Broad-
com’s Bluetooth implementation in 2016 [17], and while both
stacks diverged since then, they remain fuzzable and vulner-
able using similar techniques. Emulation and fuzzing pro-
vide insights into an otherwise undocumented, proprietary
ﬁrmware. We provide a C programming environment to inter-
act with the ﬁrmware image that can test hypotheses on the
ﬁrmware and narrow down the relevant code paths. Our main
contributions are as follows:
• We design and implement the emulation framework
Frankenstein to execute large portions of the ﬁrmware,
including injection of raw wireless frames and interac-
tion with the host,
• ﬁnd three zero-click chip vulnerabilities, two for classic
Bluetooth and one for BLE,
• ﬁnd the BlueFrag RCE in Android,
• break the coexistence mechanism in Wi-Fi/Bluetooth
combo chips requiring a full device reboot to restore
functionality, with some devices kernel panicing,
USENIX Association
29th USENIX Security Symposium    19
• uncover a design ﬂaw in the Bluetooth 5.2 speciﬁca-
tion [12] that allows attackers to extract link keys includ-
ing inactive connections, and
While vulnerabilities in the operating system are the most
severe, they are the easiest to patch. All they require is an
operating system update, as they are hardware-independent.
• showcase that users cannot turn off Bluetooth as a de-
fense on recent mobile operating systems, as the chip
reset is not speciﬁed properly.
Frankenstein is publicly available on GitHub. The provided
fuzzing examples for two Common Vulnerabilities and Ex-
posures (CVEs) ﬁnd these in a matter of seconds to a few
minutes. Firmware dumps of other popular wireless systems
are also good candidates to be analyzed with our solution. We
were able to conﬁrm portability of Frankenstein by porting
it to another ﬁrmware, however, we cannot present further
examples due to non-disclosure agreements.
This paper is structured as follows. Section 2 introduces
attacks within Bluetooth stacks and clariﬁes the difference be-
tween the full-stack Frankenstein approach and existing wire-
less fuzzers. Section 3 showcases broader vulnerabilities and
attack concepts that apply to Bluetooth chips of all manufac-
turers, including new exploitation techniques we found. Sec-
tion 4 gives an overview of ﬁrmware and Bluetooth-speciﬁc
internals. Based on this, we explain how Frankenstein works
in Section 5. The identiﬁed RCEs are described in Section 6.
Applicability to other ﬁrmware and vulnerability patching are
discussed in Section 7. An overview of related work is given
in Section 8. Section 9 concludes our ﬁndings.
2 Motivation for Frankenstein
In the following, we put the motivation for Frankenstein in
a broader context. Thus, we explain the general attack paths
within Bluetooth stacks in Section 2.1. Then, we outline how
Frankenstein integrates into these stacks, how its full-stack
capability differentiates it from other fuzzers, as well as its
applicability to other ﬁrmware in Section 2.2.
More details about how to perform these attacks follow in
Section 3. A technical description of Frankenstein is provided
in Section 5. However, we recommend reading this motivation
to those who are not familiar with Bluetooth and wireless
fuzzing.
2.1 Bluetooth Attack Paths
Figure 1 shows the attacks uncovered with Frankenstein.
While all attacks can be launched over-the-air, their capa-
bilities and escalation strategies differ.
Operating System RCE The most severe attacks allow di-
rect access to the operating system. Depending on the operat-
ing system, the Bluetooth daemon runs with limited privileges;
thus, the attacker needs to escalate further. However, on most
operating systems, these limited privileges include accessing
ﬁles and contacts.
On-Chip RCE The ﬁrmware running on the Bluetooth
chip can be vulnerable as well. In general, it is easier to
exploit—the protection mechanisms of the Real-Time Oper-
ating System (RTOS) running on it and the chip’s hardware
are rudimentary compared to what modern operating systems
and architectures provide. An attacker with control over the
ﬁrmware can access data processed within the chip and per-
form speciﬁcation-compliant requests to the operating system.
However, to also gain code execution on the operating system,
further vulnerabilities on the host stack are required.
Thus, despite high exploitability, full system compromise
requires additional escalation. Nonetheless, on-chip vulner-
abilities are a security risk that often remains unpatched as
security ﬁxes require patches provided by the hardware ven-
dor that, in turn, are shipped with an operating system update.
Inter-Chip Escalation An attack path that excludes miti-
gation by the operating system is inter-chip escalation. On
Broadcom chips, Bluetooth and Wi-Fi run on two separate
ARM cores. However, to coordinate spectrum access by
means of coexistence mechanisms, they directly communicate
with each other without the operating system being involved
into this. Using inter-chip escalation, a Bluetooth RCE can
then escalate into Wi-Fi components.
Depending on the type of inter-chip escalation, this
communication channel exists in hardware and might be
unpatchable. Thus, the ﬁrmware running on both cores must
mitigate against this type of attack, and the operating system
drivers should take action where possible.
Within our work on Frankenstein, we uncover all these vulner-
ability types, as shown in Figure 1. The focus of Frankenstein
is to ﬁnd on-chip RCE. We show that on-chip RCE can be
used to break conﬁdentiality in a speciﬁcation-compliant man-
ner by extracting the link keys used by Bluetooth encryption.
During attempts to trigger the Frankenstein vulnerabilities
over-the-air, one of our Proofs of Concept (PoCs) triggers
BlueFrag, an Android operating system RCE. Moreover, we
explore inter-chip escalations and ﬁnd that we can crash the
Wi-Fi ﬁrmware, which, in turn, produces kernel panics on
Android and iOS.
2.2 Frankenstein
Frankenstein creates a physical device snapshot and then em-
ulates it in Quick Emulator (QEMU) to fuzz the full stack:
over-the-air data is provided by a virtual modem, the emulated
ﬁrmware implements thread and task switches to fuzz mul-
tiple handlers, and it attaches to a real Linux host. It utilizes
QEMU in user mode without further customizations.
20    29th USENIX Security Symposium
USENIX Association
Wi-Fi Chip
Coexistence DoS
CVE-2019-15063
Operating System
Driver Timeout
Kernel Panic
Frankenstein
Virtual Modem
Extended Inquiry Response
BLE PDU
ACL Data
LMP Fuzzing
Virtual Bluetooth Chip
RCE CVE-2019-11516
RCE CVE-2019-13916
RCE CVE-2019-18614
Follow-up Request
Link Key Extraction
Undetermined Issues
Fuzzing Input
Emulation & Patching
Pseudo Terminal
Physical Bluetooth Chip
State Snapshots
Heap Sanitizer
PoCs
L2CAP
BlueFrag RCE
CVE-2020-0022
Figure 1: Bluetooth attacker model and Frankenstein integration, vulnerabilities discovered by us marked with .
Chip Integration and Emulation Firmware running on
a physical chip is difﬁcult to access, monitor, and modify.
Broadcom provides vendor-speciﬁc commands that can be
used to extract ﬁrmware from the ROM. Moreover, the ROM
can be temporarily patched with breakpoints, the so-called
Patchram mechanism. The InternalBlue experimentation
framework enables ROM extraction and patching [35].
The Patchram mechanism and monitoring on the hardware
itself are very limited. Even with an over-the-air Software-
Deﬁned Radio (SDR) fuzzer, which would require to re-
implement all the logic and formats deﬁned in the 3256 pages
of the Bluetooth speciﬁcation, analyzing the results would be
infeasible. Thus, Frankenstein fuzzes the ﬁrmware in emula-
tion. This provides higher speed than over-the-air fuzzing and
enables coverage feedback through QEMU.
Emulating a ﬁrmware dump comes with various challenges.
These include memory map generation, chip state extraction
including hardware registers, and working with only partial
symbols. The common approach to handle these challenges
is to reverse-engineer ﬁrmware in order to identify protocol
parsers that pose a potential zero-click attack surface. Then,
these speciﬁc protocol handlers can be manually analyzed or
automatically fuzzed. However, Frankenstein emulates and
fuzzes the ﬁrmware as a whole—including a virtual modem
for input generation and the ability to attach it to the Linux
BlueZ Bluetooth stack. Internally, this requires the implemen-
tation of interrupt handling and thread switches.
Instead of using the emulator for most of these tasks,
Frankenstein applies these features as C hooks within the
ﬁrmware. This enables running a selection of these hooks on
the physical chip, such as Frankenstein heap sanitizer.
Full-Stack Approach The virtual modem and the ability to
interact with an operating system mean that Frankenstein trig-
gers realistic full-stack behavior. For example, Frankenstein
generates various pairing dialogs on an Ubuntu desktop instal-
lation when fuzzing the Link Management Protocol (LMP).
In fact, we uncover one complex vulnerability during device
scanning, where the host asks for an Extended Inquiry Re-
sponse (EIR), and the over-the-air reply triggers the bug. The
EIR issue is triggered by a speciﬁcation-compliant message
ﬂow, meaning that it works on both Android and Linux hosts.
Frankenstein is not only faster than over-the-air fuzzing,
but our measurements show that it also provides signiﬁcantly
higher hooking performance than the state-of-the-art Unicorn
engine [48]. This speedup is required for the full-stack ca-
pability. If the fuzzer is too slow and runs into timeouts of
the operating system driver or cannot handle interrupts and
thread switches properly, attaching it to a host is impossible.
In principle, Frankenstein could also be attached to other
operating systems that support running QEMU locally. As
of June 2020, we are working on adding further operating
systems.
Another, more complex application would be to replace the
USENIX Association
29th USENIX Security Symposium    21
virtual modem with an SDR. While this would only be pos-
sible with a high-speed variant that supports at least 80 MHz
bandwidth, this would result in a fully software-controllable
Bluetooth stack starting at the physical layer. Current SDR-
based Bluetooth implementations primarily support physical-
layer decoding but do not provide a full stack.
Portability The main focus of this paper is the emulation
of the CYW20735 Bluetooth evaluation board. This board
runs on an ARM Cortex M4 [19]. The underling RTOS is
ThreadX [22]. A more technical description of similar plat-
forms is provided in Section 7.1.
Frankenstein requires custom hooks inside the ﬁrmware.
Not accounting for Bluetooth-speciﬁc hooks, supporting in-
terrupts and thread switches on ARM with ThreadX are ap-
proximately 100 custom hooks.
As of June 2020, Frankenstein also partially supports the
CYW20819 evaluation board as well as the Samsung Galaxy
S10/S20 ﬁrmware. For the latter, no symbols are available at
all. However, symbols are required only for the hooks. The
emulation itself runs without symbols as it simply interprets
and executes binary code based on an initial state—thus, iden-
tifying all relevant functions is sufﬁcient. Moreover, we used
Frankenstein for a non-public project that is not a Broadcom
or Cypress Bluetooth chip. Although this additional project
is non-public, we pushed all code changes that enable easier
integration of new projects to GitHub.
3 RCE-enabled Bluetooth Attacks
In this section, we present various novel attack scenarios en-
abled by on-chip Remote Code Execution (RCE). Details on
how we found and exploited on-chip RCE in the ﬁrst place
are provided in Section 6. Our attacks are practical and apply
to the speciﬁcation, a wide variety of operating systems, or
also affect the chips other than Broadcom.
A speciﬁcation-compliant attack to extract link keys is de-
scribed in Section 3.1. Bluetooth capabilities are typically
combined with Wi-Fi within one chip, and with LTE on the
same smartphone. We exploit this fact to escalate into the
Wi-Fi chip component and cause kernel panics across various
smartphone models and outline how to lower LTE perfor-
mance in Section 3.2. An attacker might be able to brick
Bluetooth chips forever, as shown in Section 3.3. In general,
it is hard to defend against RCE, as turning off Bluetooth is
not guaranteed to reset the chip’s memory (see Section 3.4).
This section only discusses on-chip attacks and inter-chip
escalations, as these attacks have a potential lifetime of mul-
tiple operating system major releases. Escalations into the
operating system are highly platform-dependent and rather
short-lived. Nonetheless, such escalations pose a signiﬁcant
threat, which has already been demonstrated as an attack
for the Broadcom Wi-Fi implementation [1, 5, 6]. Since the
iPhone XS, the Host Controller Interface (HCI) is attached via
Peripheral Component Interconnect Express (PCIe), exposing
similar escalation targets.
3.1 Link Key Extraction
During initial pairing between two devices, a link key is nego-
tiated. It will ensure the security of all follow-up connections
between the two paired devices. If the link key of a user’s
headset leaks, an attacker can listen to calls and access the
user’s phone book. Paired keyboards and mice can generate
arbitrary input or be eavesdropped. Smart Lock, introduced in
Android 5 and still present in Android 10 [30], enables users
to unlock their smartphone with nearby paired devices.
A Bluetooth implementation can either hold the link keys
within the controller or on the host. The Broadcom chip has
no permanent storage except the ROM. Thus, the host stores
link keys for all connections. According to the Bluetooth spec-
iﬁcation [12, p. 1948], the controller can ask the host for a link
key associated with a Media Access Control (MAC) address.
The host will send back different message types depending
on whether it has a link key for a requested MAC address.
This separation into two message types simpliﬁes exploitation.