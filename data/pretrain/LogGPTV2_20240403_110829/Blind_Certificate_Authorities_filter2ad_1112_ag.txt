In Cryptology
[54] R. L. Rivest, A. Shamir, and Y. Tauman. How to leak a secret. In
ASIACRYPT, 2001.
[55] Sobuno. Zkboo. https://github.com/Sobuno/ZKBoo, 2016.
[56] R. Tonicelli, A. C. A. Nascimento, R. Dowsley, J. M¨uller-Quade,
H. Imai, G. Hanaoka, and A. Otsuka.
Information-theoretically
secure oblivious polynomial evaluation in the commodity-based
model. Int. J. Inf. Sec., 14(1):73–84, 2015.
[57] Trevp. Tls lite version 0.4.9. https://github.com/trevp/tlslite, 2016.
[58] X. Wang, S. Ranellucci, and J. Katz. Authenticated garbling and
efﬁcient maliciously secure two-party computation. In ACM CCS,
2017.
[59] Wikipedia. Open mail relay. https://en.wikipedia.org/wiki/Open
mail relay, 2016.
[60] A. Yao. How to generate and exchange secrets. In 27th Annual
Symposium on Foundations of Computer Science, 1986.
[61] H. Zhu and F. Bao. Augmented oblivious polynomial evaluation
protocol and its applications. In ESORICS, 2005.
(cid:18)(cid:17)(cid:19)(cid:25)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply. 
APPENDIX
A. Using Generic MPC
We give a preliminary analysis of the potential per-
formance impact of using generic MPC to build our
applications.
In the anonymous PAOs, using naive implementation
to compute the TLS record directly for a message of
size 512 bytes would result in a circuit of 0.94 M+ AND
gates (6,800 for one AES operation and 90,825 for one
SHA-256 operation; 32 AES and 8 SHA-256 operations
in total). In contrast, our protocol only performs MPC
for 4 AES operations (27,200 AND gates) as opposed to
32 AES operations in generic MPC. That is, if using the
same MPC technique, computing a TLS record directly
would introduce more than 8x overhead than our protocol.
Moreover, our 2P-HMAC protocol does not need MPC at
all and only transfers 512-bit of data regardless of the size
of the inputs. On the contrary, it already takes the state-of-
the-art MPC techniques 10 ms (9 KB data transferred) in
the online phase to compute SHA-256 with 256-bit inputs
from both parties in the LAN setting, not to mention
HMAC requires two rounds of SHA-256 and 512-byte
input in our application [46, 58].
Recall that during certiﬁcate generation one needs to do
at least 6 AES and 8 SHA-256 operations for reconstruct-
ing the commitment and generating the certiﬁcate hash.
With naive implementation, such process would result in
a circuit of (roughly) 0.95 M+ AND gates. And, using
the technique from [58], the total data (including all the
phases) that needs to sent from the prover to the veriﬁer
will be more than 460 MB, which is much more than the
data (i.e., the 85 MB CA proof) sent in our protocol. Even
though it might be tolerable for the client as certiﬁcate
generation is a one-time process, such overhead would
cause heavier burden on the CA in practice. Note that
our estimations here are simpliﬁed, which underestimate
the cost of generic MPC. The circuit generated by generic
MPC will be more complicated and the actual overhead
will be higher on commodity hardware.
B. TLS with AES-GCM
To broaden the usage of SCI, we implemented SCI
atop AES-GCM, which is another widely-supported TLS
ciphersuite and gradually gains more users [45].
In order to obtain higher efﬁciency, we allow the cor-
rupted client to “shift” the message of the proxy. In partic-
ular, we modify Functionality 1 and deﬁne the following
“weaker” SCI functionality, such that it allows a corrupted
client to send some message Δ to the functionality (in
addition to M p
t ), and the output of the server is
t , M∗+Δ, M s
M p
t . Moreover, in order to formalize that the
input of the proxy is taken from a high-entropy source, we
let the trusted party (in case of an honest proxy) to choose
t and M s
the input for it. The functionality is formally described
in Functionality 6. In this section, when we relate to
secure channel injection, we refer to it with respect to
Functionality 6. We adopt Deﬁnition 2 similarly, and refer
to it with respect to this functionality.
t |))
t ). The
, sufﬁx M s
.
and sufﬁx M s
t |,|M∗|,|M s
t ∈ {0, 1}|M s
t |
t ∈ {0, 1}|M s
t |
t ∈ {0, 1}|M p
t |
Functionality 6: Weak Message Injection (parameterized
with a message template: Mt = (|M p
t ∈
• Input: The client holds some input preﬁx message M p
{0, 1}|M p
t |
. The server has
no input. We assume that the message template is known
to the client and the proxy.
• Honest proxy (and corrupted client): The proxy has
no input. The functionality chooses M∗ ∈ {0, 1}|M∗|
uniformly at random. The corrupted client inputs some
and Δ ∈
M p
{0, 1}|M∗|
• Corrupted proxy (and honest client): The proxy sends
some M∗ ∈ {0, 1}|M∗|
to the functionality. The client
t ∈ {0, 1}|M s
t |
sends some M p
, sufﬁx M s
and the functionality deﬁnes Δ = 0|M∗|
.
t , M∗ + Δ, M s
• Output: The server outputs (M p
proxy outputs M∗
Note that this functionality is weaker than Function-
ality 1, however, it sufﬁces for our applications. More
speciﬁcally, as the client is later responsible for “reveal-
ing” the challenge M∗
, it can extracts it from M∗ + Δ as
it knows Δ.
and the client has no output.
t ∈ {0, 1}|M p
t |
1) 2P-CTR and 2P-GMAC
2P-CTR. We now turn to show how to compute a counter
t ||M∗||M s
mode encryption over M p
t given a secret key
K. The client holds K, messages M p
t = (M1, . . . , Mq),
t = (Mq+r+1, . . . , Mt), the proxy holds M∗ =
and M s
(Mq+1, . . . , Mq+r), where each Mi ∈ {0, 1}n.
The counter mode on message M = (M1, . . . , Mt)
is deﬁned as follows. IV is chosen uniformly at random
from {0, 1}96, and we set the counter J0 = IV ||031||1.
We deﬁne incs(X) to be the function that increments the
right-most s bits of the string X, mod 2s; the left-most
|X|−s bits remain unchanged, and deﬁne inci
s(X) =
incs(inci−1
(X), and incs(X)1 = incs(X). We deﬁne
32(J0) Then, each message Ci = AESK(Ji) ⊕
s
Ji = inci
Mi for i = 1, . . . , t.
The 2P-CTR protocol
(Cq+r+1, . . . , Ct)
is very simple. The client
sends the proxy the IV together with the ciphertexts
(C1, . . . , Cq)
corresponding
to its messages. Moreover,
the client computes also
the “key stream” for the proxy, consisting of all keys
AESK(Jq+1), . . . , AESK(Jq+r). The proxy can then
compute the ciphertexts Cq+1, . . . , Cq+r using its own
messages. The output of the proxy is all cipheretexts
(C1, . . . , Ct). We denote this protocol as
2P-CTR((IV, M p
(1)
= (((C1, . . . , Cq), (Cq+r+1, . . . , Ct)), (Cq+1, . . . , Cq+r))
t ), M∗)
t , M s
and
(cid:18)(cid:17)(cid:19)(cid:26)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:40:08 UTC from IEEE Xplore.  Restrictions apply. 
We remark that this protocol allows the client to ma-
nipulate the ciphertexts of M∗
, and to add to it some
Δ. However, as we will see below, this addition can be
extracted, and the client knows the “shift” it adds to the
proxy’s message, which sufﬁces for our applications.
2P-GMAC.
IV ,
X = (X1, . . . , Xt) where each Xi
bits, we deﬁne the function
blocks
and
is of size n
key K,
For
GHASHH (X) = Yt+1
where Yt+1 is deﬁned as follows. For i = 0, we deﬁne
Y0 = 0, and for i = 1, . . . , t+1, we deﬁned Yi recursively
as:
Yi = (Yi−1 ⊕ Xi) · H .
(2)
Note that in fact, this is equivalent to evaluating the
polynomial p(x) on the point H, where the polynomial
i=1 Xi · xt−i+1. The summation
is deﬁned as p(x) =
and multiplications are performed in GF(2128).
(cid:2)t
t , M∗, M s
t ):
In our case, we are interested in evaluating this
the point H,
polynomial where the client holds
X p = (X1, . . . , Xq) and X s = (Xq+r+1, . . . , Xt),
and the proxy holds X∗ = (Xq+1, . . . , Xq+r). We can
write the polynomial p(x) as a sum of the following
three polynomials,
representing the different parts
(M p
(1) pp(x) = X1 · xt + . . . + Xq · xt−q+1.
(2) p∗(x) = Xq+1 · xt−q + . . . + Xq+r · xt−q−r+1.
(3) ps(x) = Xq+r+1 · xt−q−r + . . . + Xt · x.
Thus, p(x) = pp(x) + p∗(x) + ps(x). The client knows
pp(·), ps(·) and the point H, whereas the proxy knows
only p∗(·). Therefore, we can reduce this computation to
oblivious polynomial evaluation. Formally, let
FObvPoly(H, p∗) := (p∗(H), λ) ,
⊕
be the two party functionality in which the client holds a
point H, the proxy holds a polynomial p∗(·) and the client
receives the evaluation of p∗(H).
AESK(IV ||031||1),
Using GHASH, we deﬁne GMAC(K, IV, X) =
GHASHH (X)
where
H = AESK(0128). We describe now the two party
protocol that computes GMAC. The protocol 2P-GMAC
(Protocol 7) is described in the FObvPoly-hybrid model,
the FObvPoly-
and we discuss how to implement
functionality after.
the proxy we
In the protocol,
will add a random constant term to the polynomial p∗(·),
in order to mask the result p∗(H).
Implementing FObvPoly. In order to implement the obliv-
ious polynomial evaluation protocol, we use the protocol
of Ghosh, Nielsen and Nilges [26]. This protocol is se-
cure in the malicious setting assuming the existence of
an oblivious transfer and noisy encodings, and requires
2P-GMAC ((K, IV, X p, X s), Y ∗) in the
Protocol 7:
FObvPoly-hybrid model
Input: The client holds K, IV , and the blocks X p =
(X1, . . . , Xq), and X s = (Xq+r+1, . . . , Xt); the proxy
holds X∗ = (Xq+1, . . . , Xq+r), where each Xi ∈ {0, 1}n.
The protocol:
j=1 Xq+j·
(1) The proxy deﬁnes the polynomial p∗(x) =
xr−j+1. It then chooses a random ﬁeld element α and
deﬁnes p(cid:3)(x) = p∗(x) + α.
functionality
FObvPoly(H, p(cid:3)) = (p(cid:3)(H), λ) where the client inputs
the point H = AESK (0128), and the proxy inputs
the polynomial p(cid:3)(x). The client receives the point
p(cid:3)(H) = p∗(H) + α.
(2) The
parties
invoke
(cid:2)r
two
the
(3) Using the values H, X1, . . . , Xq, the client computes
pp(H). Using the values H, Xq+r+1, . . . , Xt, the client
computes ps(H).
(4) The client sends the proxy the tag T (cid:3) = pp(H) +
p(cid:3)(H) + ps(H) + AESK (IV ||031||1) = p(H) + α +
AESK (IV ||031||1). The proxy removes the mask α and
obtain the tag T = p(H) + AESK (IV ||031||1).
Output: The proxy outputs T .
O(t) OTs (or, exponentiations), where t is the degree
of the polynomial (in our case, the number of blocks).
In anonymous PAOs, the number of OTs is at most 32,
which can be done efﬁciently. We refer also to [29,30,43]
for additional oblivious polynomial evaluation protocols
based on other assumptions in the malicious setting, and
for [15, 36, 56, 61] for protocols in the semi-honest set-
tings. As opposed to our TLS with CBC and HMAC in
which the proxy must inject at least two blocks, here there
is no such restriction, and we can allow injection of a
single block. In that case, the functionality FObvPoly is in
fact oblivious linear evaluation (OLE), that can be realized
using highly efﬁcient protocols (see [26]).
The SCI Protocol. We are now in position to describe
our solution for SCI with TLS where the proxy wants
to inject a message at some designated point into the
stream of encrypted client-to-server message data. Let
Q1, . . . , Q∗
u, . . . , Qv be the sequence of TLS plaintext
fragments sent from the client to the server in sepa-
rate record layer encryptions, with Q∗
u representing the