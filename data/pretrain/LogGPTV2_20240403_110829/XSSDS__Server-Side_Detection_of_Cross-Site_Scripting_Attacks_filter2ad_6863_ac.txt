10 pages. Thus, this detector is (without adjusting it to the
341341
application) only useful for about 80-85% of the web appli-
cations.
6.4. Reﬂected XSS detector evaluation
Since the reﬂected XSS detector does not need to be
trained, evaluation is relatively straightforward.
Detection evaluation (manual script injection): Our
evaluation of the reﬂected XSS detector is again based on
the collected dataset described earlier; our set of malicious
scripts discussed above was also used in this case. We ran-
domly selected 100 request/response-pairs from each web
application. For each pair, a randomly picked malicious
script was encoded using a randomly selected encoding;
then it was injected into one of the parameters while the un-
encoded version was injected into a randomly picked (but
suitable) location on the corresponding webpage.
Afterwards,
the reﬂected detector was used on that
request-response pair and every injected script not raising
an alarm was counted as a false-negative. This procedure
was repeated 10 times for each request/response-pair.
Detection evaluation (real-world vulnerabilities):
Disclosed reﬂected XSS vulnerabilities can be found on
the net in large numbers. Since we needed the complete
request/response-pair, we used 10 different vulnerabilities
disclosed on [4] with malicious payloads from our list and
we recorded the required HTTP-trafﬁc. The detector was in
turn applied to each request/response pair and every injected
script not causing an alarm counted as a false-negative.
False-positives: For measuring the false-positive-rate,
we applied the detector to every request/response-pair of ev-
ery web application in our dataset. We again assumed that
there are no attacks in the data, so we assumed each alarm
to be a false-positive and reviewed these afterwards. The
false-positive-rate was here divided by the total number of
pages.
Results: As with the generic XSS detector, the detector
was able to ﬁnd each and every given malicious script, so we
encountered zero false-negatives. With the reﬂected XSS
detector, about 95% of the web applications did not cause
any false-positives at all; the worst case (which is only en-
countered in approximately 1% of the cases), lies at about 5
alarms per 100 pages. The results of our measurements are
depicted in Figure 7.
7. Discussion
7.1. Combination of the detectors
While exposing excellent abilities in attack detection and
a promising ”noise level”, both proposed detectors have
certain, individual advantages and disadvantages: The ap-
proach to identify reﬂected XSS (see Sec. 3) is immedi-
342342
Figure 7. False-positives of the detectors.
ately usable without any training overhead and exposes very
few false positives. However, due to its incomplete ca-
pabilities in the detection of stored XSS, potential protec-
tion holes remain when solely relying on this detection ap-
proach. The generic detector (Section 4) exhibits a slightly
higher number of false positives and requires a training
phase. Our experiments also suggest that there could be
a fraction of web applications that employ methods of dy-
namic JavaScript generation which is incompatible with our
proposed method. However, its ability to reliably detect
stored XSS makes the approach a suitable companion for
the reﬂected detector. Thus, a combined usage of both de-
tectors is advisable. More precisely: We suggest to imple-
ment the generic detector as primary sensor, while the re-
ﬂected detector can, due to its low false positive rate, aid
prioritizing alarms for manual review; even more signiﬁ-
cantly, it will also help to ensure that the generic’s list of
known scripts remains attack-free during retraining phases.
7.2. Capabilities of the adversary
In this section we discuss a few possible attack vectors
against our approach.
Reﬂected XSS detector: Due to the nature of our
matching algorithm, an adversary is able to reliably cre-
ate a large number of false positives: The trick is to create
HTTP requests which contain parameters ﬁlled with sub-
strings of the application’s legitimate JavaScripts. As these
parameters can be found within the response’s scripts, the
reﬂected XSS detector triggers an alarm. However, such at-
tempts can easily be identiﬁed by a quick inspection of the
 0 10 20 30 40 50 60 70 80 90 100 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8% of webappsfalse-positives/pagedetector performance - distributiongeneric XSS detector 0 10 20 30 40 50 60 70 80 90 100 0 0.01 0.02 0.03 0.04 0.05 0.06% of webappsfalse-positives/pagedetector performance - distributionreflected XSS detectoroffending HTTP parameters; thus, notifying the site’s oper-
ator that somebody deliberately tries to cause false alarms
is easily possible. Furthermore, as the JavaScripts are legit-
imate, they should be contained in the generic detector’s list
of known scripts. Therefore, in a combined usage scenario
such false alarms could be suppressed.
Generic XSS detector:
It should be noted, that the
generic detector’s algorithm allows an adversary to re-inject
any known script already existing in the web application
with altered constants. Therefore, it is possible to construct
a scenario in which a sophisticated combination of several
legitimate scripts enables the adversary to fulﬁll his objec-
tives. We have not yet encountered an application with a
script-set that would allow such an attack and consider this
case to be highly unlikely and rather contrived – however, it
remains as a possible attack.
8. Related work
Server-side approaches: Cross-site Scripting is essen-
tially an input ﬁltering failure. Consequently, methods have
been developed to target malicious inputs even before they
reach the web server. Traditionally, web application ﬁre-
walls (WAFs) are either scanning for attack signatures in the
parameters passed on to the web application [11] (including
POST-parameters, cookies, etc.), or require an administra-
tor to manually specify a ruleset to match requests against
[21]. Both ways can be regarded as an external second in-
put ﬁltering layer. A ﬁrst anomaly-based intrusion detec-
tion system for web applications was proposed by Kruegel
and Vigna in [14]. Their system derives a number of statis-
tical characteristics from observed HTTP requests, regard-
ing the parameter’s length, character distribution, structure,
presence and order. However, unlike our methods, both ap-
proaches concentrate solely on the incoming query param-
eters while ignoring the respective HTTP response, thus ei-
ther causing unnecessary false positives or missing certain
attacks.
Ismail et al. [9] describe an XSS detection mechanism
which follows an approach similar to our reﬂected detector
(see Sec. 3). Using a server-side proxy incoming parame-
ters are checked for contained HTML markup. If such a pa-
rameter could be identiﬁed, the respective HTTP response is
examined if the same HTML markup can be found in the re-
sponse’s HTML content. In comparison to our approach the
proposed technique has several shortcomings. The HTML-
based matching approach is inaccurate, as it fails to iden-
tify in-script- and attribute-injections. Furthermore, unlike
our technique, the proposed detector also does not consider
transformation-processes, such as character-encoding or re-
moval ﬁlters, that may alter the incoming parameters before
their reﬂection on the outgoing HTML.
Taint analysis has been proven to be a powerful tool
343343
for detecting code injection vulnerabilities. Taint analysis
tracks the ﬂow of untrusted data through the application.
All user-provided data is “tainted” until its state is explic-
itly set to be “untainted”. This allows the detection if un-
trusted data is used in a security sensible context. Taint
analysis was ﬁrst introduced by Perl’s taint mode. More
recent work describes ﬁner grained approaches towards dy-
namic taint propagation. These techniques allow the track-
ing of untrusted input on the basis of single characters. In
independent concurrent works Nguyen-Tuong et al [17] and
Pietraszek and Vanden Berghe [18] proposed ﬁne grained
taint propagation to counter various classes of injection at-
tacks. Halfond et al. [6] describe a related approach (“posi-
tive tainting”) which, unlike other proposals, is based on the
tracking of trusted data. Xu et al [24] propose a ﬁne grained
taint mechanism that is implemented using a C-to-C source
code translation technique. Their method detects a wide
range of injection attacks in C programs and in languages
which use interpreters that were written in C. To protect an
interpreted application against injection attacks the applica-
tion has to be executed by a recompiled interpreter. How-
ever, in any case dynamic taint tracking requires profound
changes to either the monitored application or the applica-
tion server/run-time. Thus, access to the source code of one
of these components is required. Also, a taint tracking based
solution is necessarily always speciﬁc for a certain tech-
nology (programming language, application server), while
real-life web applications are often composed of heteroge-
neous systems. Finally, real-time data-tracking always in-
troduces certain performance penalties. In comparison, our
approach is applicable with all languages and application
servers, does not require any changes to the executed code,
and is able to monitor highly heterogeneous set-ups. Also,
as we propose a passive ofﬂine detector, no performance
penalties are introduced.
Client-side approaches: We are proposing detection
methods that are positioned exclusively at the server-side.
For the sake of completeness, this section lists related ap-
proaches that incorporate the client-side web browser:
In concurrent and independent work an XSS ﬁlter for the
Internet Explorer browser [20] was implemented which fol-
lows an approach that is closely related to our reﬂected de-
tector: Based on an analysis of outgoing HTTP parameters,
signatures are generated which are then checked against the
corresponding HTTP response. Furthermore, the NoScript-
plugin for Firefox [15] provides a simple protection mech-
anism against reﬂected XSS: Outgoing HTTP parameters
are checked if they potentially contain JavaScript code. If
such parameters are detected, the plugin warns the user be-
fore sending the respective HTTP request. As the incoming
HTTP response is ignored, the plugin produces unnecessary
false positives. Both browser-based approaches are unable
to detect stored XSS.
With Browser-Enforced Embedded Policies (BEEP)
[10], the web server includes a whitelist-like policy into
each page, allowing the browser to detect and ﬁlter un-
wanted scripts. As the policy itself is a JavaScript, this
method is very ﬂexible and for instance allows the deﬁ-
nition of regions, where scripts are disallowed. BEEP re-
quires the usage of a modiﬁed web browser. [10] does not
elaborate how the list of legitimate scripts is supposed to be
compiled. Instead this step is left to the application’s de-
velopers. As our generic detector is speciﬁcally designed to
establish the list of legitimate scripts, a combination of the
two approaches appears to be promising.
Finally, Hallaraker and Vigna in [7] modiﬁed Mozilla’s
SpiderMonkey Engine to track the behaviour of client-
side JavaScript. The activity proﬁle of each script then is
matched against a set of high-level policies for detecting
malicious behaviour.
9. Conclusion
We described XSSDS a server-side Cross-site Scripting
detection system. The systems uses two novel detection-
approaches that are based on generic observations of XSS
attacks and web applications. A prototypical implementa-
tion demonstrated our approach’s capabilities to reliably de-
tect XSS attacks while maintaining a tolerable false positive
rate. As our approach is completely passive and solely re-
quires reading access to the application’s HTTP trafﬁc, it is
applicable to a wide range of scenarios and works together
with all existing web technologies.
References
[1] R. A. Baeza-Yates and G. H. Gonnet. Fast text searching for
regular expressions or automaton searching on tries. Journal
of the ACM, 43(6):915 – 936, November 1996.
[2] Blwood. Multiple xss vulnerabilities in tikiwiki 1.9.x.
mailing list Bugtraq, http://www.securityfocus.
com/archive/1/435127/30/120/threaded, May
2006.
[3] S. Christey and R. A. Martin. Vulnerability type distribu-
tions in cve, version 1.1. [online], http://cwe.mitre.
org/documents/vuln-trends/index.html,
(09/11/07), May 2007.
[4] K. Fernandez and D. Pagkalos. Xssed.com - xss (cross-site
scripting) information and vulnerabile websites archive. [on-
line], http://xssed.com (03/20/08).
[5] D. Gusﬁeld. Algorithms on Strings, Trees, and Sequences:
Cam-
ISBN
Computer Science and Computational Biology.
bridge University Press, New York, USA, 1997.
0521585198.
[6] W. G. Halfond, A. Orso, and P. Manolios. Using positive
tainting and syntax-aware evaluation to counter sql injection
attacks. In 14th ACM Symposium on the Foundations of Soft-
ware Engineering (FSE), 2006.
[7] O. Hallaraker and G. Vigna. Detecting malicious javascript
code in mozilla. In Proceedings of the IEEE International
Conference on Engineering of Complex Computer Systems
(ICECCS), pages 85–94, June 2005.
[8] R. Hansen. XSS (cross-site scripting) cheat sheet - esp: for
ﬁlter evasion. [online], http://ha.ckers.org/xss.
html, (05/05/07).
[9] O. Ismail, M. Eto, Y. Kadobayashi, and S. Yamaguchi. A
proposal and implementation of automatic detection/collec-
tion system for cross-site scripting vulnerability. In 8th In-
ternational Conference on Advanced Information Network-
ing and Applications (AINA04), March 2004.
[10] T. Jim, N. Swamy, and M. Hicks. Defeating script injection
attacks with browser-enforced embedded policies. In 16th
International World Wide Web Conference (WWW2007),
May 2007.
[11] A. Klein. Cross site scripting explained. White Paper, Sanc-
tum Security Group, http://crypto.stanford.
edu/cs155/CSS.pdf, June 2002.
[12] A. Klein. Dom based cross site scripting or xss of the
[online], http://www.webappsec.org/
(05/05/07),
third kind.
projects/articles/071105.shtml,
Sebtember 2005.
[13] J. Kratzer.
Jspwiki multiple vulnerabilitie.
Posting
to the Bugtraq mailinglist, http://seclists.org/
bugtraq/2007/Sep/0324.html, September 2007.
[14] C. Kruegel and G. Vigna. Anomaly detection of web-based
In Proceedings of the 10th ACM Conference on
attacks.
Computer and Communication Security (CCS ’03), pages
251–261. ACM Press, October 2003.
[15] G. Maone. Noscript ﬁrefox extension. Software, http:
//www.noscript.net/whats, 2006.
[16] Misc.
New xss vectors/unusual
[on-
line], http://sla.ckers.org/forum/read.php?
2,15812 (04/01/08), 2007.
javascript.
[17] A. Nguyen-Tuong, S. Guarnieri, D. Greene, J. Shirley, and
D. Evans. Automatically hardening web applications using
precise tainting. In 20th IFIP International Information Se-
curity Conference, May 2005.
[18] T. Pietraszek and C. V. Berghe. Defending against injec-
tion attacks through context-sensitive string evaluation. In
Recent Advances in Intrusion Detection (RAID2005), 2005.
Xss in nested tag in phpbb 2.0.16.
mailing list Bugtraq, http://www.securityfocus.
com/archive/1/404300, July 2005.
[19] A. Pigrelax.
[20] D.
8
Ross.
IE
chitecture/implementation.
http://blogs.technet.com/swi/archive/2008
/08/18/ie-8-xss-filter-architecture-
implementation.aspx (09/09/08), August 2008.
ar-
[online],
ﬁlter
XSS
[21] D. Scott and R. Sharp. Abstracting application-level web
security. In WWW 2002, pages 396 – 407. ACM Press New
York, NY, USA, 2002.
[22] P. Sowden.
rbnarcissus.
Software, http://code.
google.com/p/rbnarcissus/ (04/01/08), 2008.
[23] E. Ukkonen. On-line construction of sufﬁx trees. Algorith-
mica, 14:249 – 260, 1995.
[24] W. Xu, S. Bhatkar, and R. Sekar. Taint-enhanced policy en-
forcement: A practical approach to defeat a wide range of
attacks. In 15th USENIX Security Symposium, August 2006.
344344