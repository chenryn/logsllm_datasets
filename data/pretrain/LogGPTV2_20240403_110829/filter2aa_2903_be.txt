804df8d1 8b442404       mov    eax,[esp+0x4]
804df8d5 cc             int    3
其中[esp+0x4]代表DbgBreakPointWithStatus函数的第一个参数。
4.1.7 系统对INT 3的优待
关于INT 3指令还有一点要说明的是，INT 3指令与当n=3时的INT n
指令（通常所说的软件中断）并不同。INT n指令对应的机器码是0xCD
后跟1字节n值，比如INT 23H 会被编译为0xCD23。与此不同的是，INT
3指令具有独特的单字节机器码0xCC。而且系统会给予INT 3指令一些
特殊的待遇，比如在虚拟8086模式下免受IOPL检查等。
因此，当编译器看见INT 3时会特别将其编译为0xCC，而不是
0xCD03。尽管没有哪个编译器会将INT 3编译成0xCD03，但是可以通过
某些方法直接在程序中插入0xCD03，比如可以使用如下嵌入式汇编，
利用_EMIT伪指令直接嵌入机器码：
__asm _emit 0xcd __asm _emit 0x03
将前面的HiInt3小程序略作修改，使用_EMIT伪指令插入机器码
0xCD03，并在其前后再加入一两行用作“参照物”的其他指令，如清单4-
2所示。
清单4-2 HiInt3程序的源代码
7    int main(int argc, char* argv[])
8    {
9       // 手工断点
10      _asm INT 3;
11      printf("Hello INT 3!\n");
12    
13      _asm
14      {
15         mov eax,eax
16         __asm _emit 0xcd __asm _emit 0x03 
17         nop 
18         nop
19      }
20      //或者使用Windows API 
21      DebugBreak();
22      //
23      return 0;
24   }
在VC6下编译以上代码，然后执行，先会得到两次图4-1所示的对
话框，第二次是我们用EMIT方法插入的0xCD03所导致的，但是再执行
会反复得到访问违例异常，无法继续。
为了一探究竟，我们使用比VC6集成调试器更强大的WinDBG调试
器。启动WinDBG后通过File→Open Executable打开可执行程序
（\bin\debug\HiInt3.exe）。然后使用反汇编命令u
hiint3!HiInt3.cpp:11观察源代码从第11行起的汇编代码（见清单4-
3）。
清单4-3 HiInt3程序的汇编代码（第11行起）
0:000> u `hiint3!HiInt3.cpp:11`
HiInt3!main+0x19 [C:\dig\dbg\author\code\chap04\HiInt3\HiInt3.cpp @ 11]:
00401029 681c204200     push   offset HiInt3!`string' (0042201c)
0040102e e82d000000     call   HiInt3!printf (00401060)
00401033 83c404         add    esp,4
00401036 8bc0           mov    eax,eax
00401038 cd03           int    3
0040103a 90             nop
0040103b 90             nop
0040103c 8bf4           mov    esi,esp
可以看到，我们使用EMIT伪指令向可执行文件中成功地插入了机
器码0xCD03，而且反汇编程序也将其反汇编成INT 3指令。0xCD03的地
址是00401038。它后面是两个NOP指令，机器码为0x90。
按F5快捷键让程序执行，先会遇到main函数开头的INT 3。按F5快
捷键再执行，WinDBG会接收到断点异常事件，并显示如下信息：
(cf8.f28): Break instruction exception - code 80000003 (first chance)
eax=0000000d ebx=7ffdc000 ecx=00424a60 edx=00424a60 esi=0151f764 edi=0012f
f80
eip=00401039 esp=0012ff34 ebp=0012ff80 iopl=0         nv up ei pl nz na po
 nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000
202
HiInt3!main+0x29:
00401039 0390908bf4ff    add     edx,dword ptr [eax-0B7470h] ds:0023:fff48
b9d=????????
其中80000003是Windows操作系统定义的断点异常代码。注意，此
时的程序指针寄存器的值等于00401039，这指向的是0xCD03的第二个
字节。观察最后一行的汇编指令，看来已经出了问题，EIP指针已经指
向了一条指令的中间字节而不是起始处，接下来的指令都“错位”了，本
来不属于同一指令的两个NOP指令的机器码（0x90）以及它后面的
MOV指令被强行组合成一条虚假的ADD指令，新的指令已经和以前的
大相径庭了。根据规定，EIP指针应该总是指向即将要执行的下一条指
令的第一个字节。现在由于EIP指向错位了，因此当前的指令变成了一
个ADD指令，它引用的地址是fff48b9d，这是指向内核空间的一个地
址，是不允许用户代码直接访问的，这正是继续执行会产生访问违例的
原因。
0:000> g
(1374.d28): Access violation - code c0000005 (first chance)
…
那么是什么原因导致EIP指针错位的呢？正如前面介绍的，
Windows的断点异常处理函数KiTrap03在分发这个异常前总是会将程序
指针减1，对于单字节的INT 3指令，这样做减法后，刚好指向INT 3指
令（或者原来指令的起始处）。但对于双字节的0xCD03指令，执行这
条指令后的EIP指针的值是这个指令的下一指令的地址，即0040103a，
因此减1后等于00401039，即指向0xCD03的第二个字节了。
此时，可以通过WinDBG的寄存器修改命令将EIP寄存器的值手工
调整到下一指令（nop）位置：
r eip=0040103a
这样调整后，程序便可以继续顺利执行了。
4.1.8 观察调试器写入的INT 3指令
可以通过两种方法来观察调试器所插入的断点指令（0xCC，INT
3）。第一种方法是使用WinDBG调试器的Noninvasive调试功能。举例
来说，在VC6中启动调试，并在第11行（printf("Hello INT 3!\n")）设置
一个断点。然后启动WinDBG，选择File→Attach to a Process，在对话框
的进程列表中选择HiInt3进程，并选中下面的Noninvasive复选框，而后
单击OK按钮等待WinDBG附加到HiInt3进程显示命令提示符后，输入以
下命令，对第11行源代码所对应的位置进行反汇编：
0:000> u `hiint3!HiInt3.cpp:11`
HiInt3!main+0x19 [C:\dig\dbg\author\code\chap04\HiInt3\HiInt3.cpp @ 11]:
00401029 cc             int       3
0040102a 1c20           sbb        al,20h
0040102c 42              inc        edx
0040102d 00e8            add       al,ch
…
其中，地址00401029处的0xCC就是VC6调试器插入的断点指令。
由于插入了这条指令，导致WinDBG的反汇编程序以为0040102a是下一
条指令的开始而继续反汇编，得到了完全错误的结果。与清单4-3所示
的正确汇编结果相比较，我们知道，事实上从00401029 开始的5个字节
0x681c204200都是一条指令，即push offset HiInt3!'string'（0042201c），
目的是将printf的字符串参数压入栈。当插入断点时，push指令的第一个
字节0x68被替换为0xCC（INT 3），反汇编程序把push指令的其余字节
当作新的指令了。第二种方法是通过内核调试会话来观察用户态调试器
所插入的断点指令。
4.1.9 归纳和提示
因为使用INT 3指令产生的断点是依靠插入指令和软件中断机制工
作的，所以人们习惯把这类断点称为软件断点。软件断点具有如下局限
性。
属于代码类断点，即可以让CPU执行到代码段内的某个地址时停下
来，不适用于数据段和I/O空间。
对于在只读存储器（ROM）中执行的程序（比如BIOS或其他固件
程序），无法动态增加软件断点。因为目标内存是只读的，无法动
态写入断点指令。这时就要使用我们后面要介绍的硬件断点。
在中断向量表或中断描述表（IDT）没有准备好或遭到破坏的情况
下，这类断点是无法或不能正常工作的，比如系统刚刚启动时或
IDT被病毒篡改后，这时只能使用硬件级的调试工具。
虽然软件断点存在以上不足，但因为它使用方便，而且没有数量限
制（硬件断点需要寄存器记录断点地址，有数量限制），所以目前仍被
广泛应用。
关于软件断点的使用，还有以下两点特别值得注意。第一个值得特
别注意的地方是，不可以把软件断点设置在某条指令的中间位置。以下
面这个NtReadFile函数为例，可以把断点设置在每一条指令的开始处，
但切勿设置在指令的某个中间字节上：
0:001> u 7c90d9b0
ntdll!NtReadFile:
7c90d9b0 b8b7000000  mov     eax,0B7h
7c90d9b5 ba0003fe7f  mov edx,offset SharedUserData!SystemCallStub (7ffe030
0)
7c90d9ba ff12        call    dword ptr [edx]
7c90d9bc c22400      ret     24h
7c90d9bf 90          nop
假设执行bp ntdll!NtReadFile+1，把断点设置在第一条指令的第二个
字节处，那么调试器不会给出任何警告，而且这个意外也很难被察觉。
使用前面提到的Noninvasive方法附加到同一个进程观察，这个函数
的第一条指令变为：
0:000> u ntdll!NtReadFile
ntdll!NtReadFile:
7c90d9b0 b8cc000000      mov     eax,0CCh
可见，函数的内容被篡改了。这样的断点不仅永远不会命中，还会
导致非常怪异的结果。在本例中，原来指令中的0x0B7代表NtReadFile
的系统服务编号（卷2详细介绍）。设置断点后，服务编号被意外修改
成了0xCC，代表了完全不同的另一个系统服务。于是，进入内核态
后，内核会调用另一个系统服务，真是阴差阳错。
第二个值得特别注意的地方是，切勿把软件断点设置到变量上。这
样就会导致调试器把变量的值修改掉，替换成0xCC，后果也非常严重
而且不易察觉。例如，在WinDBG中调试BadBoy小程序时，如果执行bp
g_boy命令以全局变量g_Boy的地址作为参数，那么WinDBG不会给出任
何警告。观察断点设置前的地址值：
0:001> dd g_Boy L1
00417888  00416890
设置断点并恢复执行后，再用第二个调试器观察：
0:000> dd g_Boy
00417888  004168cc
可见，变量的值已经被修改。
软件断点是应用最广泛的调试功能之一，在后面的内容中，我们还
会分别从操作系统、编译器和调试器的角度进一步介绍软件断点。
4.2 硬件断点
1985年10月，英特尔在推出286三年半之后推出了386。这是PC历
史上又一个具有划时代意义的产品，作为IA-32架构的鼻祖，它真正将
个人计算机带入了32位时代。在调试方面，386也引入了很多新的功
能，其中最重要的就是调试寄存器和硬件断点。
4.2.1 调试寄存器概览
IA-32处理器定义了8个调试寄存器，分别称为DR0～DR7。在32位
模式下，它们都是32位的；在64位模式下，它们都是64位的。本节将以
32位的情况为例进行讨论（见图4-4）。
首先，DR4和DR5是保留的，当调试扩展（debug extension）功能
被启用（CR4寄存器的DE位设为1）时，任何对DR4和DR5的引用都会
导致一个非法指令异常（#UD），当此功能被禁止时，DR4和DR5分别
是DR6和DR7的别名寄存器，即等价于访问后者。
图4-4 调试寄存器DR0～DR7
其他6个寄存器分别如下。
4个32位的调试地址寄存器（DR0～DR3），64位下是64位的。
1个32位的调试控制寄存器（DR7），64位时，高32位保留未用。
1个32位的调试状态寄存器（DR6），64位时，高32位保留未用。
通过以上寄存器最多可以设置4个断点，其基本分工是DR0～DR3
用来指定断点的内存（线性地址）或I/O地址。DR7用来进一步定义断
点的中断条件。DR6的作用是当调试事件发生时，向调试器报告事件的
详细信息，以供调试器判断发生的是何种事件。
4.2.2 调试地址寄存器
调试地址寄存器（DR0～DR3）用来指定断点的地址。对于设置在
内存空间中的断点，这个地址应该是断点的线性地址而不是物理地址，
因为CPU是在线性地址被翻译为物理地址之前来做断点匹配工作的。这
意味着，在保护模式下，我们不能使用调试寄存器来针对一个物理内存
地址设置断点。
4.2.3 调试控制寄存器