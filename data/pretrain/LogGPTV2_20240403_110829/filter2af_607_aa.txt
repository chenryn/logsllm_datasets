原文：
# **导言**
* * *
首先，我知道关于缓冲区溢出和二进制代码漏洞利用的教程已经是汗牛充栋了，但是，我仍然决定写这篇文章，为何呢？因为大部分的相关教程和文章并没有真正全面介绍掌握缓冲区溢出漏洞利用所需的基本知识。例如，有些教程只解释了什么是缓冲区溢出，却没有为读者介绍什么是缓冲区，什么是堆栈，什么是内存地址等基础知识，所以，我决定写一篇详尽的文章，为读者提供一篇一站式的教程。为此，我将在本文中讨论什么是缓冲区，什么是堆栈，什么是内存地址，以及应用程序的内存结构，什么是缓冲区溢出，以及为什么会发生缓冲区溢出。最后，我将通过一个非常基本和简单的示例代码(ProtoStar
Stack0)来展示利用缓冲区溢出漏洞的过程。
# **缓冲区**
* * *
那么，什么是缓冲区呢？简单来说，缓冲区就是程序运行时所使用的内存空间或场所。这些内存空间用于存储程序当前使用的临时数据。因此，如果我们有一个简单的程序，它要求用户输入自己的名字，并将其存放到一个名为username的变量中，然后，该程序会输出“Hello
username”形式的消息。这样，如果我们运行该程序，并输入用户名“Rick”，那么，“Rick”一词会首先存放到缓冲区中，直到程序执行print命令的时候，该程序才会从缓冲区中取出给定的用户名“Rick”，并输出结果：“Hello
Rick”。
我们的示例代码是用c语言编写，具体如下所示：
    #include 
    int main () {
       char username[20];
       printf("Enter your name: ");
       scanf("%s", username);
       printf("Hello %s\n", username);
       return(0);
    }
**示例代码详解**
* * *
int main() 定义主函数  
char username [20] 这里是为变量规定名称的地方，但这一行最重要的是char ....
[20]，其作用是为该变量指定了相应的缓冲区，具体大小为存放20个字符所需内存空间
其余代码的作用是接收用户的输入，然后将其打印输出。
    printf("Enter your name: "); 
    scanf("%s", username); 
    printf("Hello %s\n, username");
那么，当我们编译并运行这个程序时，能否得到预期的输出结果呢？
在讨论缓冲区溢出之前，我们需要先来了解一下应用程序的内存是如何工作的。
# **应用程序的内存、栈以及内存地址**
* * *
那么，应用程序的内存到底长啥样呢？堆栈又是什么呢？实际上，堆栈就是一个内存缓冲区，用来存储程序的函数和局部变量。为了便于演示，我们为读者画了一个示意图，具体如下所示。
首先，最下面部分存放的是代码，即程序的源代码编译后的代码，它们是程序的主要指令。
其次，从下往上数第二部分是用于存储全局变量的缓冲区，
局部变量和全局变量之间的区别在于，局部变量被限定在一个特定的函数中：如果在一个函数中定义了一个局部变量，那么，该变量就只能在这个函数中调用。但是，全局变量既可以在主函数中定义，也可以在函数外部定义，并且，这种类型的变量可以在任何地方调用。
然后，再往上就是栈（stack）了，这是内存的重要组成部分，因为缓冲区溢出就是在这里发生的。这是存储局部变量和函数调用的地方。
最后，也是最上面的一部分，即堆（Heap），这是动态内存分配区。
现在，我们已经知道了应用程序的内存是什么样子，以及什么是栈，但是，内存地址又是什么呢？  
基本上，当程序被编译和执行时，程序的所有指令位于应用程序对应的内存空间中，并且，并为它们分配一个地址。该地址通常采用十六进制字节的格式。
因此，当我们反汇编一个程序，并查看其代码时，就会看到内存地址，类似这样：
# **为什么会发生缓冲区溢出呢？**
* * *
现在，我们已经知道什么是缓冲区，同时，对内存构造也进行了深入探索。接下来，您很可能想要知道问什么会发生缓冲区溢出，以及什么时候会发生溢出。简单来说，当输入的数据的长度超过缓冲区的上限时，就会发生缓冲区溢出，这会导致程序在为其分配的缓冲区之外写入数据，这样，就可能会覆盖程序用来保存数据的某些内存空间，从而使数据不可用，并最终导致程序崩溃。为了演示这一点，让我们回顾一下第一个例子。
    #include 
    int main () {
       char username[20];
       printf("Enter your name: ");
       scanf("%s", username);
       printf("Hello %s\n", username);
       printf("Program exited normally");
       return(0);
    }
处于演示的目的，这里又添加了一行代码，用来输出“program exited noramlly”。
现在，程序运行时会询问我们的用户名，接着打印“Hello username”，然后输出“program exited
noramlly”并退出。其中，用于保存变量username的值的缓冲区的长度被设置为20个字符，所以，用户名的长度最好小于20个字符。但是，如果输入的数据的长度超过了20个字符，程序将会崩溃，因为缓冲区外面的某些数据将被覆盖，致使程序的某些部分被破坏掉了。在我们的例子中，被破坏的部分将是打印“program
exited noramlly”的那一部分。
首先，让我们运行程序，并输入Rick。
这时，该程序将正常退出。
现在，让我们再次运行它，并输入30个字母A，来为变量username赋值。
这时，我们看到程序会打印“Hello
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa”，但是，之后并没有看到它输出“program exited
normally”，相反，我们看到的是一个段错误。这是因为我们额外输入了10个字符，而程序只需要20个字符，或更少。这些额外的字符，即“aaaaaaaaa”超过了20个字符的缓冲区的容量，会写入缓冲区边界之外的内存中，并覆盖其他数据（即打印“Program
exit normal”的打印指令），从而引发段错误，因为程序已被破坏。
# **借助GDB考察缓冲区溢出**
* * *
下面，让我们借助GDB（GNU调试器）来更加深入地考察溢出是如何发生的。  
我们将编写另一个程序，该程序会创建一个名为“whatever”的变量，然后，它会拷贝我们提供的内容，并将其放入该变量中。我们将该变量的缓冲区的长度设置为20个字节。
    #include 
    #include 
    int main(int argc, char** argv)
    {
        char whatever[20];
        strcpy(whatever, argv[1]);
        return 0;
    }
**代码详解**
* * *
`int main（int argc，char ** argv）` 定义main函数及其参数
`char whatever[20];` 创建变量，为其指定名称“whatever”，并将其缓冲区长度指定为20个字节
`strcpy(whatever, argv[1]);` 将我们输入的字符拷贝到变量“whatever”中
`return 0;` 这是我们的返回地址
现在，让我们利用gdb运行该程序，以进行相应的测试。
上面输入的内容为aaaaa，长度小于20个字符，所以，程序会正常退出，说明一切正常。
现在，让我们输入20个以上的字符。
我们将看到段错误，这时因为我们的返回地址被覆盖了，程序无法继续运行。
为了说明这些地址是如何被覆盖的，让我们输入一个任意十六进制值，例如\x12，并连续输入50次。然后，让我们来看看寄存器的情况。
我们看到，大多数内存地址都被12覆盖了。
# **为什么缓冲区溢出如此危险？**
* * *
现在，您可能会问，这会带来多大的危害呢？
当易受攻击的二进制文件或程序是具有setuid访问权限的二进制文件时，缓冲区溢出问题可能带来巨大的危害。如果您不知道具有setuid权限二进制文件是什么的话，建议阅读提供的链接文章的详细介绍，但简单来说，让执行该程序的用户以该程序拥有者（通常是root）的权限去执行它们，但是当该程序容易受到缓冲区溢出的影响时，这就不太妙了。由于我们可以向缓冲区中传递数据并覆盖程序，因此，我们可以使用执行系统调用的payload覆盖程序，从而得到一个具有root权限的shell。
将来，我将撰写更多有关缓冲区溢出和其他二进制代码利用技术的文章，不过，现在让我们先从Protostar开始吧。
实际上，Hack The
box网站上的确有许多需要利用缓冲区溢出漏洞和二进制漏洞利用技术来获得root权限的实验，但它们现在还处于active状态，不过，只要它们退出该状态，我们便会在第一时间发布关于这些实验的文章。在此期间，您可以阅读本人撰写
[Hack The Box write-ups](https://0xrick.github.io/ "Hack The Box write-ups")！
# **Protostar Stack0**
* * *
现在，让我们从一个简单的实际例子开始下手。
您可以从[这里](https://www.vulnhub.com/entry/exploit-exercises-protostar-v2,32/
"这里")下载protostar。
在这篇文章中，将解决第一个层次的挑战，也就是stack0层次，然后我将在其他文章中解决其余层次的问题。
下面，我们先来看看相关的源代码：
    #include 
    #include 
    #include 
    int main(int argc, char **argv)
    {
     volatile int modified;
     char buffer[64];
     modified = 0;
     gets(buffer);
     if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
     } else {
      printf("Try again?\n");
     }
    }
我们可以看出，该程序有一个名为“buffer”的变量，并为其分配64个字符的缓冲区。此外，该程序还有一个变量，即Modified，其值为0。同时，借助于函数gets(buffer)
，我们可以为“buffer”变量赋值，此后，还有一个if语句，其作用是检查“modified”变量的值是否不等于0。如果该值不等于0，它将打印“you
have changed the'modified'variable”，然而，如果它仍然等于0的话，将打印“try
again？”。所以，我们的任务其实就是改变这个名为“modified”的变量的值。
只要输入的数据少于64个字符，就会一切正常。然而，一旦输入的内容超过了缓冲区的长度，就会将覆盖"modified"变量的值。
我们已经知道缓冲区的长度为64个字符，所以，只需要输入65个或更多的字符，这个变量的值就会被改变。下面，让我们来测试一下。
我们执行stack0的二进制代码，并看到输出为“try again？”。
下面，让我们扔给它65个字符“A”，看看它有什么反应。
    python -c "print ('A' * 65)" | ./stack0
看，我们成功地覆盖了该变量的值！