server does not repeat the DH public keys and strictly uses
ephemeral keys in DHE-PSK.
4.3 Dangerous TLS Modulus Sizes
Since the server chooses the modulus size and the attacker
has no variable-size inputs to the PRF (except for DHE-PSK
cipher suites), the attacker cannot inﬂuence the block borders
of the hash function and thus optimize their usability as a
side channel. Usually servers choose moduli whose lengths
are of the form 2n, like 210 = 1024, 211 = 2048 or 212 =
4096. The server is free to deviate from these and move to
arbitrary sizes. For common bit lengths 2n, the block border
will never realistically reach a critical block border as the
PMS would require too many leading zero bits. However,
if a server deviates from these common modulus sizes, it
can become possible for an attacker to hit the critical block
borders. For example, LibTomCrypt6 used to create 1036 bit
6https://github.com/libtom/libtomcrypt
220    30th USENIX Security Symposium
USENIX Association
moduli, which would make OH feasible. A list of dangerous
modulus sizes is given in an extended version of this paper.7
5 Raccoon Premaster Secret Recovery Attack
Until now, we have discussed a distinguishing attack on TLS,
which allows an attacker to determine leading zero bytes
of the premaster secret. If the server reuses the DH values
for multiple connections (cf. [61]), the distinguishing attack
can be turned into a full premaster secret recovery attack.
This is the case for TLS-DH and for TLS-DHE if the server
disregards best practices and reuses ephemeral keys. Our
attack is based on the well-known Hidden Number Problem
described by Boneh and Venkatesan [17].
We use the attack scenario Raccoons from Subsection 4.1
which leaks the top k bits of the PMS. We assume the server
reuses the same secret DH exponent b; this reuse does usually
not depend on the TLS version or cipher suite (except for
export cipher suites not considered here), so our Raccoons
attacker can choose a beneﬁcial TLS version and cipher suite
for the attack, as long as they are supported by the server. The
attack proceeds in four phases:
Phase 1: Passive MitM. In this phase, the attacker records
a complete TLS-DH(E) session and extracts ga from the
ClientKeyExchange message as well as gb, g and p from
the ServerKeyExchange or Certificate message.
Phase 2: Active web attacker. In this phase, the attacker
interacts as a client with the server. However, instead of
choosing a secret ephemeral DH value a(cid:48) and sending ga(cid:48)
in the ClientKeyExchange message, the attacker chooses
random values ri ∈ Zq and sends the value xi = gagri in
the ClientKeyExchange message (cf. Figure 3). To ﬁn-
ish this part of the TLS handshake, the attacker sends a
ChangeCipherSpec and the client’s Finished message, where
the content of the Finished message is chosen randomly be-
cause the attacker lacks the keys (master secret and the sym-
metric keys) to compute a valid Finished message correctly.
After sending ClientKeyExchange, the attacker starts mea-
suring a chosen length distinguishing oracle OH, OC, OP, or
OD, until some Alert message arrives from the server. The
attacker may repeat the measurement by sending the same
value ri to the server until some statistical test (e.g., Mann-
Whitney [44]) indicates that a sufﬁciently high probability
level has been reached. If the measurement indicates that the
leading k bits have been stripped, we have found a candidate
ri for an HNP equation. If the measured time indicates that
less than k bits have been stripped, a new random value ri+1
is chosen by the attacker and phase 2 is repeated.
Phase 3: Constructing an instance of HNP. Now that the
attacker has learned that for the candidate ri the oracle
b mod p =
Ok,b(ri) is True, the attacker knows that 0 < ri
gabgbri mod p < 2n−k. Subtracting 2n−k−1, we obtain the
7https://eprint.iacr.org/2020/1151
centered equation
(cid:12)(cid:12)α·ti mod p− yi
(cid:12)(cid:12) < 2n−k−1 = p/2(cid:96)+1 ,
(6)
where α := gab mod p is unknown (the hidden number) and
ti := (gb)ri mod p, yi := 2n−k−1 are known to the attacker.
Equation 6 corresponds to the randomized version of HNP
as deﬁned by Boneh and Venkatesan [17], except that in our
case the oracle does not reveal the MSBs directly, but only
whether they are zero or not. Moreover, we center the equation
around zero and take the bias of p into account, as in [50].
Phase 4: Computing the premaster secret. Phase 2 and
3 are repeated until the attacker has obtained a sufﬁcient
number of equations to solve the HNP instance and recovers
the hidden number gab, which is the premaster secret of the
connection the attacker observed in phase 1 of the attack.
We will show in Subsection 6.2 that this is indeed possible.
With the premaster secret the attacker can then derive the
master secret; with the master secret the attacker can proceed
to compute the symmetric keys and decrypt the connection.
6 Evaluation
In this section, we will analyze if the requirements of the Rac-
coon attack can actually be fulﬁlled by a real-world attacker,
namely, measuring the timing difference by the created side
channel and solving the HNP for real modulus sizes with
realistic leak sizes.
6.1 Timing Measurements
As demonstrated by the Lucky 13 attack [6], applying a hash
function to inputs of varying lengths results in a measurable
difference in processing times. We now shortly revisit this
ﬁnding by evaluating the OpenSSL library (version 1.1.1),
before putting it in the context of our attack.
Figure 3 shows a plot of the processing time (in cycles)
to compute HMAC with SHA-256 and SHA-384 for keys
of varying lengths, on 1024-byte messages. To simplify the
presentation, we report the median processing time across
10,000 experiments per input length. The step-like increase in
processing time as the key size increases can clearly be seen.
The ﬁrst step in the increase of processing time leads to oracle
OH, the hash function invocation oracle. The subsequent,
slightly smaller steps lead to oracle OC, the compression
function invocation oracle. The smallest visible steps (for
SHA-256, when the input length is 128· k− i,1 ≤ i ≤ 8, and
similarly for SHA-384) lead to oracle OP; we analyze the cost
of exploiting this side channel in Appendix A.
Is the difference in processing times measurable in a re-
mote setting? To measure if the side channel is big enough
for a remote attacker, we created a test setup consisting of
two (non-virtual) machines, one simulating the attacker ma-
chine and one simulating a victim server. The machines are
directly connected with a 1 Gbit/s connection. The attacker
USENIX Association
30th USENIX Security Symposium    221
and a 10% false positive rate, the false negative rate was
10.4% (we also empirically conﬁrmed that the false positive
rate is 10%). To estimate these false-reporting rates, we con-
ducted 200,000 experiments, where in each experiment the
samples for each set were randomly selected from the pool of
100,000 collected samples. Increasing the number of samples
to 1,000 (2,000 measurements overall) allowed us to achieve
a false positive rate of 0.009200% and a false negative rate of
0.000795%.8
An attacker would have to account for the false reporting
rates when performing the attack. In order to deal with false
positives, the attacker re-measures timings for any reported
positive. That is, the attacker ﬁrst performs 200 measure-
ments for each x value. For values where the classiﬁer outputs
OH(x) = True, the attacker re-measures the processing time
for x, obtaining 2,000 more measurements, and re-runs the
classiﬁer.
Iterating over a total of m DH values, in expectation at
most m · 255/256 values are true negatives,9 of which m ·
255/256 · 10% · 0.009200% = m · 9.1 · 10−6 will be falsely
labeled as positives in both classiﬁcation rounds. Similarly,
m/256 are true positives, of which m/256· (1−10.4%)· (1−
0.000795%) = m·0.35% will be correctly labeled as positives
in both classiﬁcation rounds.
The attacker needs to collect roughly 180 true positive
values to solve the HNP problem for a 1024 bit modulus (see
Section 6.2). Choosing m = 55,000 results in 192 correctly
identiﬁed positives in expectation, and 0.5 false positives. The
overall required number of timing samples is therefore 22.34
million. These numbers are not necessarily optimal.
Other classiﬁcation methods and scenarios. Estimating the
cost of performing the attack over the public Internet is an in-
teresting challenge, but outside the scope of this work. Crosby
et al. have examined the feasibility of performing such timing
attacks and found signiﬁcant variability that depends on the
attacker and victim hosts and the distance between them [22].
They have also suggested a different classiﬁer than the one we
use, the “Box Test”. We have in fact, initially used this test as
our classiﬁer, but it signiﬁcantly underperformed the Mann-
Whitney test. Surprisingly, Crosby et al. have also considered
the Mann-Whitney test, but reported that it underperformed
their Box Test [22] (their test setup includes measurements
on the same LAN, similarly to ours, as well as measurements
over the Internet). The reason for this discrepancy is unclear
to us. At any rate, providing a comprehensive comparison of
classiﬁers is again an interesting task, but also out of scope
for this work.
8To estimate these lower rates, we ran our classiﬁer on 20 million sets of
randomly-sampled 2,000 measurements.
9If we denote the most signiﬁcant byte of the modulus as v, then v−1/256
shared secrets are true negatives. It is common for v to be smaller than 256,
slightly lowering the attack cost, but we prefer to give a worst-case analysis.
Figure 3: Processing time to compute HMAC-SHA-256 and
HMAC-SHA-384 with keys of varying lengths for inputs
1KB in length, measured in CPU cycles. Reported values are
medians across 10,000 experiments per key length, performed
with OpenSSL version 1.1.1.
machine used an Exablaze ExaNIC HPT network adapter.
This network card is speciﬁcally built to generate high preci-
sion hardware timestamps.
For the evaluation, a tool on the attacker machine repeatedly
performed handshakes with the victim TLS server. The tool
generated a DH private value and computed the resulting
DH shared secret, alternating between handshakes where
the DH secret starts with a single leading zero byte or no
leading zero bytes. For each handshake, the tool recorded
the fact if the MSBs of the DH secret are zero, as well as the
server’s response time. To analyze whether the side channel
is measurable we used a modulus size of 1032 bits, as this
creates the hash function invocation side channel OH (see
Subsection 3.1). We collected 100,000 measurements each
for premaster secrets with a leading zero byte and without a
leading zero byte.
In broad terms, the attacker would use a classiﬁer to ap-
proximate the oracle’s response. That is, the attacker collects
server response times from handshakes using DH share ga+r,
and attempts to deduce from these measurements the oracle
response OH(ga+r). Any classiﬁer will exhibit some proba-
bility of false classiﬁcation. False negatives occur when the
classiﬁer concludes that OH(x) = False when OH(x) = True.
Similarly, false positives occur when the classiﬁer wrongly
concludes OH(x) = True when OH(x) = False.
In our experiments, the Mann-Whitney test [44] performed
very well for distinguishing between the two cases. This test
can be conﬁgured with a desired false positive probability,
which then determines the (empirical) false negative proba-
bility. With 100 samples per case (200 measurements overall)
222    30th USENIX Security Symposium
USENIX Association
6.2 Solving the HNP
We simulated and solved the HNP problem for DH groups G
with 1024, 1036, 2048, 3072 and 4096 bits and varying oracle
sizes k = 8,12,16,20,24.
i < 2n−k, which we interpret as a value y(cid:48)
To reduce the number of exponentiations we do not sim-
ulate querying the oracle, because the oracle for larger bit
leaks only has a very low success probability. In order to
avoid a large number of false guesses, we choose values
0 < y(cid:48)
i = gabgbri with
MSBk(gabgbri mod p) = 0 for some unknown ri. We then
i = gbri mod p, 1 ≤ i ≤ d, and assume
calculate ti := (gab)−1y(cid:48)
that we could have guessed a corresponding ri with probability
1/2(cid:96) in the ﬁrst place. We take y1 = y2 = . . . = yd = 2n−k−1 and
get d equations |gabti mod p− yi| < p/2(cid:96)+1, where (cid:96) = k− ε
is the effective number of bits leaked (see Section 5). To solve
this instance of the HNP, we consider the lattice L(B) in Zd+2
generated by the column vectors of
1
(cid:100)2(cid:96)(cid:101)t1
(cid:100)2(cid:96)(cid:101)t2
...
B =
 .
(cid:100)p/2(cid:101)
(cid:100)2(cid:96)(cid:101)y1
(cid:100)2(cid:96)(cid:101)y2
...
(cid:100)2(cid:96)(cid:101)td
(cid:100)2(cid:96)(cid:101)yd
(cid:100)2(cid:96)(cid:101)p
(cid:100)2(cid:96)(cid:101)p
...
(cid:100)2(cid:96)(cid:101)p
The expected length of the hidden vector v2 is approxi-
This lattice contains the vector v1 = (p,0, . . . ,0)(cid:62), which is
usually a shortest non-zero vector. More importantly, the
lattice contains the hidden vector v2 = (α,∗, . . . ,∗)(cid:62), where
α = min{gab mod p, p− gab mod p}. The ﬁrst component
of that vector reveals the secret gab.
mately(cid:112)(d + 2)/12· p. But also, by the Gaussian heuris-
proximately (cid:112)(d + 2)/(2πe)(detB)1/(d+2), where detB ≈
tic, the length of a “typical” shortest vector in L(B) is ap-
2(cid:96)d−1 pd+1. If the number d of equations is sufﬁciently large
and (cid:96) is not too small, v2 is expected to be smaller than typical
shortest vectors in L(B) and we may hope to recover ±v2 as
the second vector (after ±v1) in a reduced basis of L(B).
For our experiments we used the BKZ 2.0 [21] version
of the Block-Korkine-Zolotareff [58] lattice basis reduction
algorithm with two block sizes β = 40,60. We used the imple-
mentation of the fplll/fpylll library [25] in the SageMath [63]
computer algebra system. The results are shown in Table 3.
6.3 Putting It All Together
As we have shown in Subsection 6.1, it generally is possible to
measure the timing difference from the presented side channel.
Depending on the modulus size, the supported version and
cipher suites, an attacker might be able to measure the timing
difference in a remote setup. An attacker can then use the
measurements to solve an instance of the HNP, as described
in Subsection 6.2. We showed that for real modulus sizes