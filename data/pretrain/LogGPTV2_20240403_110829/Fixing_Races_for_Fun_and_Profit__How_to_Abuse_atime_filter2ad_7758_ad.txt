performing permission checks using the effective user
ID, and then restoring the effective user ID to its original
value. Every process’s real and effective user IDs can be
read from /proc/pid/status on FreeBSD, so an at-
for i = 1 to 2k + 1
save atime(activemaze/sentry)
while atime(activemaze/sentry) unchanged
sleep
distinguish victim’s current system call
toggle target symlink between secret and
public to match victim’s system call
link activemaze to mazei
Figure 10: Attacker’s algorithm to defeat
the k-
Race scheme after setting up the directory structure
depicted in Figure 9.
The victim opens the ﬁle
activemaze/sentry/lnk/lnk/.../lnk.
tacker can determine whether the victim is currently call-
ing access(2) or open(2) by simply checking the victim’s
user IDs: if the victim’s effective and real user IDs are
equal, then it is calling access(2), otherwise it is calling
open(2). Linux implements access(2) in a similar way,
but Linux has a notion of a process “ﬁlesystem user ID”
(fsuid) that is used in all ﬁlesystem-related permission
checks. The Linux access(2) system call copies the pro-
cess’s real user ID to its ﬁlesystem user ID instead of its
effective user ID, but the attacker can still use the same
idea. She simply checks whether the victim’s ﬁlesystem
ID is equal to its real user ID. We have tested these ac-
cess(2)/open(2) distinguishers on Solaris 9, Linux 2.6,
and FreeBSD, and they all work. Based on our reading
of OpenBSD’s source code, its access(2) implementation
behaves just like FreeBSD’s, so this attack should work
on OpenBSD, as well.
Once the adversary has determined which system call
the victim is executing, she must change the symbolic
links in the maze to ensure the victim’s system call suc-
ceeds. Toggling activemaze will not work because,
by the time the attacker gets to run, the victim has al-
ready resolved that symbolic link. The attacker needs to
switch a symbolic link that the victim has not processed
yet. To support this operation, we set up the mazes as
shown in Figure 9, and the attacker toggles the sym-
bolic link, target, between the public and protected
ﬁles based on the victim’s current system call. Figure 10
shows the attacker’s new algorithm. When the victim
makes a system call, it is forced to sleep on I/O while re-
solving the ﬁlename. The attacker then wakes up, deter-
mines the victim’s current system call, switches target
so the victim’s system call will succeed, and advances
activemaze to point to the next maze. When the vic-
tim resumes, it ﬁnishes resolving the ﬁlename using the
new value for target, so the system call succeeds.
We tested this attack on Linux, Solaris, and FreeBSD.
Table 3 shows our results. Against the randomized k-
Race algorithm using k = 100 our attack won at least
USENIX Association
14th USENIX Security Symposium
311
Linux 2.6 FreeBSD 4.10-PR2
access(2)/open(2)
k-Race, k = 7
k-Race, k = 100
Fork-Open
1.7 GHz Athlon
3 µ sec
30 µ sec
393 µ sec
135 µ sec
Solaris 9
1.3GHZ P-IV 450MHZ Ultra
253 µ sec
2210 µ sec
27600 µ sec
5750 µ sec
8 µ sec
91 µ sec
1190 µ sec
582 µ sec
Table 4: Running times for different access(2)/open(2) techniques on different operating systems. We measured the
elapsed cycle count for each call and repeated each measurement 1000 times to compute the average speed. The
measurements for the k-Race algorithm do not include randomized waits, so these results are a lower bound on the
running time of k-Race.
19% of the trials and up to 88%. From this, we conclude
that the randomized k-Race algorithm is not secure. Note
also that by using system call distinguishers our attack on
the randomized algorithm performs about as well as the
attack on the deterministic algorithm.
The three techniques we have developed in this paper
— mazes, synchronization primitives, and system call
distinguishers — are general tools that adversaries can
use to exploit a variety of Unix ﬁlesystem races. For
this reason, we believe that race condition exploits are
real threats that should be treated with the same level
of care as other software vulnerabilities, such as buffer
overﬂows and format string bugs.
8 Other Defenses
Fork. As mentioned by Dean and Hu, there is at least
one secure, cross-platform option to solve this problem.
A program can eschew the use of the access(2) system
call and rely on the operating system to enforce the per-
mission checks when it opens the ﬁle. When the program
needs to open an invoker-accessible ﬁle, it can fork a new
process that then uses the setuid(2) call to drop the setuid
privilege and run only with the rights of the invoker. The
new process can then call open(2) and the operating sys-
tem will enforce that the program’s invoker has rights
to open the ﬁle. Once the forked process successfully
obtains a ﬁle descriptor, it can use standard Unix IPC
mechanisms to pass the ﬁle descriptor back to its parent
process. The parent process can use the ﬁle descriptor as
normal.
2.6, Solaris 9.1,
We have implemented this forking technique and
tested it on Linux 2.4,
and
FreeBSD 4.10-PR2 [11]. Our fork(2)/open(2) function
has the same interface as open(2), taking a string path-
name and a ﬂags parameter. It returns a ﬁle descriptor
but ensures that the program’s invoker (determined by
getuid(2)) can access the ﬁle. We envision that the code
can be placed in a library, such as libc.
One drawback with this technique is that it is much
slower than the k-Race scheme using the recommended
parameter k = 7, as can be seen in Table 4. However,
we have shown that k-Race is insecure even up to k =
100, and our experiments show that the fork(2)/open(2)
solution is faster than k-Race with k = 100.
Kernel solutions. Forking a process to open a ﬁle is a
heavy-weight solution, and a little help from the kernel
could go a long way. For example, if temporarily drop-
ping privileges were portable across different versions of
Unix, then a setuid-root program could simply temporar-
ily drop privileges, open the ﬁle, and restore privileges.
Privilege management in Unix is a notorious mess [2],
but any progress on that problem would translate into im-
mediate improvements here. Alternatively, OS kernels
can add a new ﬂag, O RUID, to the set of ﬂags for the
open call, as suggested by Dean and Hu.
Until privilege management or the O RUID ﬂag be-
come standardized, the C library can emulate these fea-
tures to create a simple portable interface. For exam-
ple, the C library could introduce a new set of user id
management interfaces that hide all the non-portable de-
tails of each OS implementation. Similarly, the C library
could emulate O RUID by temporarily dropping privi-
leges while performing the open(2) call.
Any solution like these would enable setuid-root pro-
grams to open ﬁles with the same security guarantees as
the fork(2)/open(2) solution, but with the performance
of a simple call to open(2). This would be a signiﬁcant
performance beneﬁt, as shown in Table 4, and would be
clearly superior to Dean and Hu’s defense in both secu-
rity and speed.
9 Related Work
A number of projects use static analysis techniques to
ﬁnd race conditions in C source code. Bishop and Dilger
gave one of the earliest formal descriptions of the ac-
cess(2)/open(2) race condition and used this formalism
to characterize when the race condition occurs [1]. Us-
ing this characterization, they developed a static analysis
tool that ﬁnds TOCTTOU races by looking for sequences
312
14th USENIX Security Symposium
USENIX Association
of ﬁle system operations that use lexically identical argu-
ments. Because their tool performs no data ﬂow analy-
sis, it may fail to report some real vulnerabilities. Chen
et al. used software model checking to check temporal
safety properties in eight common Unix applications [3].
Their tool, MOPS, is able to detect stat(2)/open(2) races.
Later work with MOPS by Schwarz et al. checked all of
Red Hat 9 and found 41 ﬁlesystem TOCTTOU bugs [10].
MOPS has similar limitations to Bishop and Dilger’s tool
because it also doesn’t perform data ﬂow analysis.
Static analysis techniques may generate many false
positives, requiring the developer to sift through numer-
ous warnings to ﬁnd the actual bugs. Dynamic tech-
niques aim to reduce the number of false positives by
observing runtime program behavior and looking for
TOCTTOU race conditions. Tsyrklevich and Yee de-
tected races by looking for “pseudo-transactions”, i.e.
pairs of system calls that are prone to TOCTTOU ﬁle
race vulnerabilities [12]. Upon detecting a race in a run-
ning system, their tool asks the user for a course of ac-
tion. Ko and Redmond used a similar approach to look
for dangerous sequences of system calls [7]. They wrote
a kernel extension that looks for interfering system calls,
i.e. system calls that changes the outcome of another
group of system calls. For example, their scheme would
detect our attack because the attacker’s unlink(2) calls in-
terfere with the victim’s calls to open(2) and access(2).
Cowan et al developed RaceGuard, a kernel enhance-
ment that prevents temporary ﬁle creation race condi-
tions by detecting changes to the ﬁle system between
calls to stat(2) and open(2). Related to Tsyrklevich and
Yee’s pseudo-transaction notion, the QuickSilver operat-
ing system adds support for ﬁlesystem transactions [9].
A process could prevent TOCTTOU races by enclosing
dependent system calls in one transaction. Mazi`eres and
Kaashoek give principles for designing an operating sys-
tem to avoid TOCTTOU bugs [5]. They note that an at-
tacker can create many ﬁles in a directory so that name
resolution slows down and hence easily win TOCTTOU
ﬁle races. Their solution encompasses a richer OS in-
terface to enable ﬁner grain access controls and greater
control over name resolution.
10 Conclusion
We described a practical attack on the k-Race algorithm,
developed a randomized version of k-Race, and broke
that scheme, too. The latter attack shows that our system
call distinguishers are a powerful attack tool and that our
attack is insensitive to the exact sequence of system calls
performed by the victim. We therefore reafﬁrm the con-
ventional wisdom that access(2) should never be used in
secure programs. The tools we created as part of this
attack — mazes, system call synchronizers, and system
call distinguishers — are applicable to a wide variety of
Unix ﬁlesystem races. We discussed several alternative
solutions to access(2)/open(2) races that offer determin-
istic security guarantees.
Availability
The source code for our k-Race implementation and at-
tack software is available at http://nikita.ca/
research/races.tar.gz.
Acknowledgements
We would like to thank David Molnar and the anony-
mous reviewers for their insightful comments and our
shepherd, Eu-Jin Goh, for his help in preparing the ﬁnal
version of this paper. This work was supported in part by
the NSF under grants CCR-0093337 and CCF-0430585
and by the US Postal Service.
References
[1] Matt Bishop and Michael Dilger. Checking for race
conditions in ﬁle accesses. Computing Systems,
9(2):131–152, Spring 1996.
[2] Hao Chen, Drew Dean, and David Wagner. Setuid
demystiﬁed. In Proceedings of the 11th Usenix Se-
curity Symposium, pages 171–190, August 2002.
[3] Hao Chen, Drew Dean, and David Wagner. Model
checking one million lines of C code. In Proceed-
ings of the 11th Annual Network and Distributed
System Security Symposium (NDSS), pages 171–
185, February 2004.
[4] Drew Dean and Alan Hu. Fixing races for fun and
In Proceedings of
proﬁt: How to use access(2).
13th Usenix Security Symposium, pages 195 – 206,
August 2004.
[5] David Mazi`eres and M. Frans Kaashoek. Secure
applications need ﬂexible operating systems.
In
Proceedings of the 6th Workshop on Hot Topics in
Operating Systems (HotOS-VI), pages 56–61, 1997.
[6] Norm Hardy. The confused deputy: (or why capa-
bilities might have been invented). ACM SIGOPS
Operating Systems Review, 22(4):36–38, October
1988.
[7] Calvin Ko and Timothy Redmond. Noninterference
and intrusion detection. In Proceedings of the 2002
IEEE Symposium on Security and Privacy, pages
177–187, May 2002.
USENIX Association
14th USENIX Security Symposium
313
[8] W. S. McPhee. Operating system integrity in
IBM Systems Journal, 13(3):230–252,
OS/VS2.
1974.
[9] Frank Schmuck and Jim Wyllie. Experience with
transactions in QuickSilver. In Proceedings of the
13th ACM Symposium on Operating System Princi-
ples, pages 239–253, October 1991.
[10] Benjamin Schwarz, Hao Chen, David Wagner, Ge-
off Morrison, Jacob West, Jeremy Lin, and Wei Tu.
Model checking an entire Linux distribution for se-
curity violations. Technical Report UCB//CSD-05-
1384, UC Berkeley, April 2005.
[11] W. Richard Stevens. Unix Network Programming,
chapter 14.7: Passing Descriptors. Prentice Hall
PTR, 1997.
[12] Eugene Tsyrklevich and Bennet Yee. Dynamic de-
tection and prevention of race conditions in ﬁle ac-
cesses. In Proceedings of the 12th Usenix Security
Symposium, pages 243–255, August 2003.
314
14th USENIX Security Symposium
USENIX Association