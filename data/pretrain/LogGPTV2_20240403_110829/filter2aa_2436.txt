macOS/iOS Kernel Debugging and Heap Feng Shui
Min(Spark) Zheng @ Alibaba Mobile Security
Outline
Alibaba Security
• Introduction
• macOS Two Machine Debugging
• iOS Kernel Debugging
• Debugging Mach_voucher Heap Overflow
• Traditional Heap Feng Shui
• Port Feng Shui
• Conclusion
Whoami
•
Min(Spark) Zheng @ Twitter，蒸米spark @ Weibo
•
Security Expert @ Alibaba
•
CUHK PhD, Blue-lotus and Insight-labs
•
Worked in FireEye, Baidu and Tencent
•
Focus on Android / iOS system security
Alibaba Security
•
Co-author: Xiangyu Liu, Security Engineer @ Alibaba
•
Special thanks to: yang dian, aimin pan, jingle, 
qwertyoruiop, windknown, liangchen, qoobee, etc.
Introduction of macOS/iOS Kernel
•
XNU is the computer operating system kernel developed at Apple Inc. for use in the iOS/macOS
operating system and released as free and open-source software as part of the Darwin operating 
system. XNU is an abbreviation of X is Not Unix.
•
XNU for macOS is open source. It can be compiled and debugged.
•
XNU for iOS is not open source. It can not be compiled and debugged (officially). But most of 
implementation is same as macOS.
Alibaba Security
Outline
Alibaba Security
• Introduction
• macOS Two Machine Debugging
• iOS Kernel Debugging
• Debugging Mach_voucher Heap Overflow
• Traditional Heap Feng Shui
• Port Feng Shui
• Conclusion
Two-machine Debugging of macOS
•
To do a good job, one must first sharpen one's tools.
•
Machine: two MacBook or one MacBook with VM (The system versions can be different).
•
Equipments for two-machine debugging: 
Thunderbolt to FireWire * 2, Belkin FireWire 800 9/9-Pin cable * 1, Thunderbolt 3 (USB-C) to
Thunderbolt 2 * 2 for new 2016 MacBook.
Alibaba Security
Two-machine Debugging of macOS
•
Two MacBook needs to install KDK (Kernel Debug Kit).
•
After connection with FireWare cable, execute “fwkdp” on the host MacBook.
•
Copy the kernel.development of KDK to the “System/Library/Kernels/” folder on the debug 
MacBook and then execute the following command:
sudo nvram boot-args =“debug=0x147 kdp_match_name=firewire fwkdp=0x8000 
kcsuffix=development pmuflags=1 -v keepsyms=1”
sudo kextcache -invalidate /
sudo reboot
Alibaba Security
Two-machine Debugging of macOS
•
After the debugger MacBook reboot，the host MacBook can start debug with “lldb，kdp-remote 
localhost” command.
•
We could use “image list” command to get the kernel addresses of partial kexts:
Alibaba Security
Two-machine Debugging of macOS
Alibaba Security
•
We could use “x/nx” command to get the data in the kernel：
•
1. Comparing with kernelCache + kslide, we could use b *address to set a break point in the kernel. 
kernel:
Two-machine Debugging of macOS
Alibaba Security
•
2. We could pause the debugging machine immediately through: 
•
3. We could set breakpoints in the XNU source code through (“int $3”) and print kernel information 
through printf(). 
command+alt+control+shift+esc (all at once)
XNU Source Code
Console
Two-machine Debugging of macOS
Alibaba Security
•
Using “command script import” command, we could load python script of lldb to get more useful 
information.
Two-machine Debugging of macOS
Alibaba Security
•
Using “showallkexts” command, we could get the kernel addresses of all kexts:
•
Other lldb python commands and implementations could be found at: 
/Library/Developer/KDKs/XXX/System/Library/Kernels/kernel.development.dSYM/Contents/ 
Resources/Python/.
Outline
Alibaba Security
• Introduction
• macOS Two Machine Debugging
• iOS Kernel Debugging
• Debugging Mach_voucher Heap Overflow
• Traditional Heap Feng Shui
• Port Feng Shui
• Conclusion
iOS Kernel Debugging – Kernelcache
Alibaba Security
•
Before iOS 10, the kernelcaches were encrypted. Some keys could be found at: 
https://www.theiphonewiki.com/wiki/Firmware_Keys/9.x
•
After iOS 10, there is no encryption for kernelcaches. We could unzip and decode the kernel using 
img4tool:
•
And extract kernel information through joker and ida:
iOS Kernel Debugging – Task_for_pid
Alibaba Security
•
Although iOS doesn’t have KDK，we could use task_for_pid() to do arbitrary kernel memory read/write：
•
If there is no jailbreak or no task_for_pid () patch, what should we do?
iOS Kernel Debugging – Kernel Slide
Alibaba Security
•
After getting kernel task, we could figure out the kernel text base and slide, in arm32 it’s easy:
•
In arm64, it’s non-trivial. First, we need to create an OSObjects in the kernel. Then, we found its 
vtable pointer which points to the kernel's base region. Last but not least, we search backwards 
from the vtable address until we find the kernel header (code refers to Siguza’s ios-kern-utils):
iOS Kernel Debugging – Root and Port Address
Alibaba Security
•
After getting the kslide, we can read and write kernel data to get root privilege (refers to luca’s yalu):
•
Using offset + kernel slide, we could find the kernel objects addresses of related ports in the memory 
(port -> kernel address) (refers to ianbeer’s mach_portal):
Outline
Alibaba Security
• Introduction
• macOS Two Machine Debugging
• iOS Kernel Debugging
• Debugging Mach_voucher Heap Overflow
• Traditional Heap Feng Shui
• Port Feng Shui
• Conclusion
Mach_voucher Heap Overflow
Alibaba Security
Vulnerable code
Fixed code
•
Mach_voucher_extract_attr_recipe_trap() is a mach trap which can be called inside the sandbox. 
It's a new function added in iOS 10 and macOS 10.12. But, it has a terrible vulnerability.
•
The function then uses the sz value to allocate a memory block on the kernel heap. However, the 
developer forgot args->recipe_size was a user mode pointer and then used it as a size value in 
copyin(). We know that user mode pointer could be larger than the sz value which will cause a 
buffer overflow in kernel heap.
Mach_voucher Heap Overflow Debugging
Alibaba Security
•
If we want to debug the heap overflow scene, we could set the breakpoint at 0xffffff8014631540 
and 0xffffff8014631545 (before and after copyio).
Mach_voucher Heap Overflow Debugging
Alibaba Security
•
Before heap overflow 
•
After heap overflow
Outline
• Introduction
• macOS Two Machine Debugging
• iOS Kernel Debugging
• Debugging Mach_voucher Heap Overflow
• Traditional Heap Feng Shui
• Port Feng Shui
• Conclusion
Alibaba Security
iOS 10 Traditional Heap Feng Shui
Alibaba Security
•
In iOS 10 and macOS 10.12, Apple added a new mitigation mechanism to check the freeing into the 
wrong zone attack, so we cannot use the classic vm_map_copy (changing vm_map_size) technique 
to do heap feng shui. 
•
Ian Beer from GP0 proposed a new kind of heap feng shui using prealloc mach_port. The basic idea 
is using mach_port_allocate_full() to alloc ipc_kmsg objects in the kernel memory. This object 
contains a size field which can be corrupted without having to fully corrupt any pointers.
iOS 10 Traditional Heap Feng Shui
Alibaba Security
•
Using exception port, we could send and receive data to the kernel memory. The data will not be 
freed after receiving.
•
The data used to send and receive is the register values of the crashed thread. Therefore, the 
attacker needs to create a thread and set the register values to the data he wants to send. Then 
he triggers the crash of the thread. The data will be sent to: 
address of ipc_kmsg object + ikm_size – 0x104
iOS 10 Kernel Debugging
Alibaba Security
•
So why the number is 0x104?
•
Using iOS kernel debugging we could get the address of prealloc_port_buffer in the 
memory. Then, we trigger the exception and send the user mode data to the kernel.  
After that, we can use kernel debugging again to inspect the data of the buffer:
•
We can find the location of the data in the buffer is 0xd3c, and because we set the value 
of ikm_size to 0xe40, so we can get: 0xe40 – 0xd3c = 0x104.
iOS 10 Traditional Heap Feng Shui
•
The attacker first allocates 2000 prealloc ports (each port is 0x900 size) to insure 
the following ports (holder, first_port, second_port) are continuous.
•
Then the attacker could get the following layout (page size 0x1000):
kalloc.4096
kalloc.4096
kalloc.4096
holder
first_port
second_port
Alibaba Security
iOS 10 Traditional Heap Feng Shui
•
The attacker frees the holder，and then uses the vulnerability to overflow the first 0x40 
bytes of the first_port. It contains the ikm_size and other fields of ipc_kmsg object.
•
Note that，if the attacker uses expction msg，the data sent to the prealloc port will be 
located at: the kernel address of ipc_kmsg object + ikm_size - 0x104. With simple 
calculation, we can get:
first_port_addr + 0x1104 – 0x104 = second_port_addr
Therefore, we could use the first_port to read and write the content of the second_port.
kalloc.4096
kalloc.4096
kalloc.4096
holder
first_port
second_port
0x40
Alibaba Security
iOS 10 Traditional Heap Feng Shui
•
For the heap information leak, the attacker uses the exception msg to change the 
header of the second_port through the first_port. The data only gets the second_port
a valid header.
•
The second_port has a valid header. So after sending the message to the second port, 
ikm_next and ikm_prev will be set to point to itself. After that, the attacker can receive 
the content of the first port to get the address of the second_port:
kalloc.4096
kalloc.4096
kalloc.4096
holder
first_port
second_port
0x40
0x40
Debug info
Alibaba Security
iOS 10 Traditional Heap Feng Shui
kalloc.4096
kalloc.4096
kalloc.4096
holder
first_port
second_port
0x40
0x40
kalloc.4096
kalloc.4096
kalloc.4096
holder
first_port
userclient
0x40
0x100
read
free
•
After getting the heap address, the attacker should use the first_port to reset the 
second port. Then, he can safely free the second port. After freeing the 
second_port, the attacker can alloc an AGXCommandQueue UserClient(0xdb8 
size) to hold the spot of the second_port.
Alibaba Security
Leak Kslide Using Heap Feng Shui
•
After getting the message of the first_port，the attacker could get the data of 
AGXCommandQueue UserClient. The first 8 bytes of data is the vtable of UserClient. 
Comparing the dynamic vtable address with the vtable in the kernelcache，the 
attacker can figure out the kslide.
•
kslide = 0xFFFFFFF022b9B450 – 0xFFFFFFF006F9B450 = 0x1BC00000
Alibaba Security
Arbitrary Kernel Memory Read and Write
•
The attacker first uses OSSerialize to create a ROP which invokes uuid_copy. In this way, 
the attacker could copy the data at arbitrary address to the address at  kernel_buffer_base + 
0x48 and then use the first_port to get the data back to user mode.
•
If the attacker reverse X0 and X1, he could get arbitrary kernel memory write.  
X0=[X0,#0x10] 
= kernel_buffer_base+0x48
X1=address
X3=kernel_uuid_copy
BR X3
Alibaba Security
Arbitrary Kernel Memory Read and Write
•
If the attacker calls IOConnectGetService(Client_port) method, the method will invoke 
getMetaClass(),retain() and release() method of the Client. 
•
Therefore, the attacker can send a fake vtable data of AGXCommandQueue UserClient
to the kernel through the first_port and then use IOConnectGetService() to trigger the 
ROP chain.
•
After getting arbitrary kernel memory read and write, the next step is kernel patch. 
The latest kernel patch technique could be referred to yalu 102.
•
Note that traditional heap feng shui only has a 50% successful rate.
Alibaba Security
Outline
• Introduction
• macOS Two Machine Debugging
• iOS Kernel Debugging
• Debugging Mach_voucher Heap Overflow
• Traditional Heap Feng Shui
• Port Feng Shui
• Conclusion
Alibaba Security
iOS 10 Port Feng Shui
• Mach msg is the most frequently used IPC mechanism in XNU. Through the 
“complicated message” of MACH_MSG_OOL_PORTS_DESCRIPTOR msg_type, 
we can transmit out-of-line ports to the kernel. 
MACH_PORT_DEAD = 0xffffffffffffffff
Alibaba Security
iOS 10 Port Feng Shui
•
The ool ports saved in mach msg are ipc_object pointers and the pointer can point to a user 
mode address. 
•
we can overflow those pointers and modify one ipc_object pointer to point to a fake 
ipc_object in user mode. We could create a fake task in user mode for the fake port as well.
0x100
fake ipc_object (port)
fake_task
0x100
0x100
ports
ports
User mode
Kernel mode
0x8
HID heap overflow
Alibaba Security
iOS 10 Port Feng Shui
•
We send lots of ool ports messages to the kernel to insure the new allocated blocks 
are continuous. 
•
We receive some messages in the middle to dig some slots. 
•
We send some messages again to make the overflow point at the middle of the slots. 
•
We use HID vulnerability to trigger the heap overflow at the overflow point.
Alibaba Security
iOS 10 Port Feng Shui
•
Then we set io_bits of the fake ipc_object to IKOT_TASK and craft a fake task for the 
fake port. By setting the value at the faketask+0x360, we could read arbitrary 32 bits 
kernel memory through pid_for_task(). 
fake port
faketask
Alibaba Security
iOS 10 Port Feng Shui
•
That’s amazing because the function doesn’t check the validity 
of the task, and just return the value of *(*(faketask + 0x380) + 
0x10). 
Alibaba Security
iOS 10 Port Feng Shui
•
We dump kernel ipc_object and kernel task to our fake ipc_object and fake task. 
•
By using task_get_special_port() to our fake ipc_object and task, we could get the 
kernel task port. 
•
Kernel task port can be used to do arbitrary kernel memory read and write.
fake ipc_object
faketask
kernel ipc_object
kernel task
pid=0
DUMP
kernel task port
task_get_special_port()
mach_vm_ 
read()
mach_vm_ 
write()
Alibaba Security
Outline
• Introduction
• macOS Two Machine Debugging
• iOS Kernel Debugging
• Debugging Mach_voucher Heap Overflow
• Traditional Heap Feng Shui
• Port Feng Shui
• Conclusion
Alibaba Security
Conclusion
•
macOS/iOS kernel debugging: it is very useful for kernel exploit development. 
•
Traditional heap feng shui: it needs ROP chains to do kernel memory read and 
write. It’s not stable and needs multiple feng shui.
•
Port heap feng shui: it does not need ROP and only uses data structure. It’s 
stable with a high successful rate. But it’s easy for apple to fix it.
•
Reference:
1.
Yalu 102: https://github.com/kpwn/yalu102
2. Mach_voucher bug report: https://bugs.chromium.org/p/project-
zero/issues/detail?id=1004
3. iOS Kernel Utilities: https://github.com/Siguza/ios-kern-utils
Alibaba Security
Thanks