x00
x4c
0087x08x00 xdd xc1 x05 xbex00 x56
x08 x00 xc3 xa9 x05 xbe x00 x1a
0081x08x00x88x42
x05xbe x00x50
0058 x08 x00 xb0 x42 x05 xbe x00 x39
0013 x08 x00 x3e x38 x05 xbe x00
0067 x08 x00 x99 x36 x05 xbe x00 x42
http//en.wikipedia.org/wiki/Intermet_Control_Message_Protocol
---
## Page 320
第22章自动化协议解析305
0055x08x00 x0fx56x05 xbe x00x36
0004 x08x00 xe6xdax05 xbe x00 x03
0028 x08 x00 x83 xd9 x05 xbe x00 x1b
0095 x08 x00 xc1 xd9 x05 xbe x00 x5e
[output trimmed for sake of brevity]
00X80XE600
xb6 x05xbe x00 x5c
0010x08x00xd1 xb6x05xbe x00
0024 x08 x00 x11 x8f x05 xbe x00x17
0063x08x00x11x04x05xbe x00x3e
0038x08 x00 x37x3b x05xbe x00
888ZZZ8B8B8888B888ZZZ AAA
x25
10
MT
000 000 081 089000 000 000 100
Ungapped Consensus:
C0NS x08 x00x3f x18x05 xbe x00???
DT
MT
000.000 081 089 000 000 000 100
Step 3: Analyze Consensus Sequence
Pay attention to datatype conposition and mutatfon rate.
offset 0: Binary data, 0% mutation rate
offset 1:Zeroed data, 0% mutation rate
Offset 3: Binary data, 89% mutation rate
offset 2:Binary data, 81x mutation rate
offset 4:Binary data,0% mutation rate
Offset 5:Binary data,0% mutation rate
offset 7:ASCII data, 100% mutation rate
Offset 6: Zeroed data,0% mutation rate
尽管不是立刻很明显地就可以观察到，但所生成的分析结果被转换成了如下的协议结构：
[ 1 byte][ 1 byte ][ 2byte ][ 2byte ][ 1 byte ][ 1 byte ]
[1 byte ][1 byte][ 2 byte ][ 2 byte][ 2 byte ]
识别最后一个字段时所发生的错误是由于被捕获以用于分析的ICMP包的受限制的编号所
致。这个被错误识别的字段实际上是一个16位的序列号，由于只有100个包被使用，因此该字
段的最重要的字节从未被增加过。当更多的数据被传递到PI时，该字段的大小将被正确地确定。
将生物信息学应用于自动化的协议解析是一个非常有趣并且技巧性很强的方法。该方法的
应用结果在当前受到了一些限制，并且有许多研究者对应用这些技术所带来的整体收益产生了
怀疑。然而，由于PI框架已经为我们提供了成功的案例，因此我们可以期望看到该方法的进
一步发展。
22.4遗传算法
化过程。为了在后续种群中保存优秀的遗传特性，遗传算法对初始种群实施变异。它应用自然
选择的规则来选择所生成的那些更加适合于环境的个体，然后，将所选择的个体进行配对和变
http://www.matasano.com/log/294/protocol-informatics
---
## Page 321
306第三部分高级模期测试技术
异，接着整个处理过程再继续进行，为了定义一个遗传算法，典型地需要下面这些组成部分：
·针对所生成个体的一种表示方法。
·评价一个单独个体的优劣程度的适应性函数。
·对单个个体实施变异，以及对两个个体实施交叉操作的一个紫殖函数。
为了更好地说明这些概念，让我们考虑一个简单的问题及其相应的遗传算法解决方案。我
们将要解决的基本问题是在一个长度为10的二进制字符串中，使其中1的数量最大化。针对该
问题的个体表示方法和适应性函数都是非常显而易见的。可能的个体被表示为一个由二进制数
字所构成的字符串，面适应性函数则被定义为计算该字符串中1的个数的函数。对于我们的繁
殖和配对函数，我们任意选择在两个字符串的位置3和位置6处交换相应的数字，并且在所生成
的子代中随机改变一个位上的数字。该配对函数可能并不是最有效的配对函数，但是它能够满
足我们的需求。所采用的交换规则允许父代向子代传递遗传信息，并且位值的改变也说明了随
机变异操作。然后，遗传算法就依据如下步骤进行进化：
1.首先，随机生成一个初始种群。
2.对种群中的每个个体应用适应性函数，并且选择适应度最高的个体。
3.对所选择的个体应用配对函数。
4.用所生成的后代替换初始种群，然后再重复执行上述操作。
为了查看该算法的实际执行过程，让我们首先随机生成由4个二进制字符串所构成的初始
种群，并且计算每个个体的适应度：
UUUUULOOLO
1000001010
3
1110100111
7
3Y
0000001000
1
经过计算，中间的一对个体（用黑体高亮显示的）的适应度最高，因此选择这两个个体进
行配对（它们是非常幸运的）。在位置3处将两个字符串进行交换，就生成了一对后代个体，在
位置6处再将两个字符串进行交换，又可以得到另外一对后代个体，如下所示：
1000001010
3
100+01001111000100111
0T0T000TTT1110101010
100000+0111>1000000111
1110100111
2
然后，对所生成的后代个体实施一个随机的变异操作（用黑体高亮显示），并且再次应用
适应性函数：
1000100111
1010100111
1110000010
6
1110001010
4
1000000111->
1000001111
5
1110101010->
1110101110
7
我们可以看到遗传算法的执行获得了成功，因为新生成种群的平均适应度得到了提高。在
这个特定的例子中，我们使用了一个静态的变异率。而在一个更加高级的例子中，如果所生成
---
## Page 322
第22章自动化协议解析307
的后代在一定的时间限制内没有完成进化，我们可能将会选择自动化来提高变异率。注意，遗
传算法被认为是一种随机的全局最优化算法。换句话说，在该算法中存在着一定的随机因素，
因此它所输出的结果经常会发生变化。然面，尽管遗传算法将会持续执行以找到最佳的个体，
但是无论执行多少时间，它都可能不会找到最佳的可能个体（在我们的例子中就是一个全1的
字符串）。
应用遗传算法以提高模糊测试的性能，是佛罗里达中央大学（UCF）的一个团队近期所研
究的一个课题，相关的研究成果被发表在2006年的美国安全会议BlackHat上°。UCF团队发布
了一个名为Sidewinder的概念验证工具，该工具能够自动生成输入以强制执行一个设计好的执
行路径。在这种情形下，遗传算法的作用是生成被表示为上下文无关文法的模糊数据。一个
非传统的模糊测试方法被应用以定义一个适应性函数。该工具井不是首先生成数据并监视错误
的发生，而是静态地定位潜在的漏洞代码位置如不安全的API调用（例如strcpy）。此过程中的
这一步骤类似于前面章节所讨论的Autodafé定位代码点以将增加的权重应用于标记的过程。
接下来，对整个目标二进制代码的控制流程图（CFG，不要同上下文无关的文法相混淆）进行
检查，并且抽取出包数据入口点（对recv的调用）和潜在的漏洞代码位置之间的子流程图。图
22-5描述了一个包含所有这些点的CFG示例。关于CFG更加详细的定义和解释，请参见第23章
“模糊器跟踪”。
recy
图22-5包含潜在漏洞的控制流程图
在下一步骤中，必须要识别出连接入口点和目标漏洞代码的所有路径上的节点。图22-6显
示了相同的CFG，并且用黑色框突出显示了连接路径上的节点。
接下来，同一个CFG中的退出节点被确定。一个退出节点被定义为在连接路径外面的边界
http:/www.blackhat.com/html/bh-usa-06/bh-asa-06-speakers.html/Embleton
http:/en.wikipedia.org/wiki/Context-free_grammar
---
## Page 323
308
第三部分高级模糊测试技术
节点。如果到达了一个退出节点，那么执行就会从任何可能的路径转向漏洞代码。图22-7显示
了同前面相同的一个CFG，用黑色框突出显示了连接路径上的节点，另外，用白色框突出显示
了退出节点。
图22-6突出显示连接路径的控制流程图
图22-7突出显示退出节点的控制流程图
根据目前突出显示的CFG，我们就可以定义一个适应性函数。UCF研究团队对所生成的
CFG应用了一个马尔可夫过程，以基于遍历特定路径的概率来计算适应度，在实际应用以及
更加简单的一些条件下，可以采用如下的步骤，使用一个调试器关联到目标进程并且在入口
节点、目标节点、退出节点以及连接路径上所有的节点上设置断点。当到达这些断点时对它
们进行监视，以评估针对一个给定输入（个体）的运行时执行路径的进度。然后跟踪执行过
---
## Page 324
第22章自动化协议解析309
程，直到到达一个退出节点。模糊器将生成输入，井且将其提供给目标进程。选择那些适应
度最高的输人来进行繁殖，然后继续执行整个过程，直到成功到达一个目标节点，即表明一
个潜在漏洞的节点。
将Sidewinder与静态分析技术、图论理论以及调试器运行时的分析方法相结合，就能够从
本质上强制提供一个输入从而可以到达目标进程中的任意位置。尽管这是一个功能非常强大的
概念，但是目前仍然存在着许多局限性使其还不是一个很完美的解决方案。首先，并不是所有
的CFG结构都适合于采用遗传算法来进行处理。特别的，在图形结构和数据解析之间必须要存
在某些依赖关系。其次，通过静态分析的方法来抽取出准确的CFG并不总是可行的。一个不准
确抽取出的CFG可能会导致整个处理过程执行失败，最后，对于包含TVL类型字段的协议而言，
该方法将会花费过长的时间来生成有效的数据。例如，当对一个包含所计算的CRC值的协议进
行模糊测试时，在遗传算法生成任何有用的结果之前，我们的太阳将可能会成为超新星。
总而言之，对该技术进行研究是非常有趣的，并且在某些情况下也会给我们带来一些帮助。
如果需要的话，Sidewinder的最佳使用场合可能就是帮助一个模糊器来对输人进行变异，以遍
历一个小的子路径来增加代码覆盖率，而不是发现一个能够对从入口到目标节点的整个连接路
径进行遍历的输入。
22.5小结
在本章的开始部分，首先说明了模糊测试最困难的方面就是要克服对目标协议或文件格式
进行理解和建模的一些人门障碍。本章提出了三种常规的万法，以有助于手上或者自动化进行
协议解析。分别描述了启发式技术、生物信息学方法以及遗传算法，并将它们作为了可能的解
决方案。本章中所提出的这些概念是模糊测试研究领域的前沿问题，并且每天都会有一些新的
发展。为了得到更多的新信息和资源，可以访问hup://www.fuzzing.org站点。
---