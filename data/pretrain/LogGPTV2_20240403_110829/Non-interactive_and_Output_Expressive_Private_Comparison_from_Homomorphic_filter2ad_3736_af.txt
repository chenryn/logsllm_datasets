### The Concept of Ciphertext Capacity

The opposite of the notion of ciphertext noise is the concept of ciphertext capacity, which is also determined by \( L \) and estimates the capacity of a ciphertext to be used in homomorphic operations. In Figures 13 and 14, we report the remaining capacity of a ciphertext after a series of consecutive additions or multiplications, starting from the values of \( L \) in Table IV. These figures show that the capacity is only slightly reduced after addition but significantly diminished after multiplication. It is important to note that the encryption operation itself already impacts \( L \).

Figure 15 illustrates that performing multiplication with logarithmic depth (as described in Lemma 6.2) reduces the capacity sublinearly rather than linearly, as seen in Figure 14. The sublinear complexity is further demonstrated in Figure 16 for the comparison circuit, which also has a logarithmic multiplicative depth [12]–[14]. Figure 17 shows the runtimes (best and average) for addition and multiplication in HElib over 100 runs, highlighting that homomorphic addition is much faster compared to multiplication. Figure 18 compares the runtime for the comparison circuit between HElib and TFHE, showing that while both have linear runtime in terms of bitlength, the runtime for HElib increases very quickly.

### Performance of PDT-BIN

In this section, we present our experimental results with PDT-BIN on complete trees. For FHE supporting SIMD, we can use attribute value packing to evaluate multiple attribute vectors simultaneously. We focus on attribute packing to demonstrate the advantage of SIMD. Figure 19 illustrates the amortized runtime of PDT-BIN with HElib, which is the time of one PDTE evaluation divided by the number of slots provided by the homomorphic context. As expected, the runtime depends on the bitlength of the attribute values and the depth of the tree. The results show a clear advantage of HElib when classifying large datasets.

For path aggregation, we proposed EVALPATHSE (Algorithm 5) and EVALPATHSP (Algorithm 9). Figure 20 illustrates the runtime of PDT-BIN using these algorithms in a multi-threaded environment, demonstrating a clear advantage of EVALPATHSP, which will be used in the remaining experiments with PDT-BIN. Figure 21 shows the runtime of PDT-BIN with HElibmed, indicating that the computation cost is dominated by the computation of decision bits, which involves homomorphic evaluation of comparison circuits. Figure 22 reports the evaluation of PDT-BIN using TFHE, which shows a clear advantage over HElib. For the same experiment with 72 threads, TFHE evaluates a complete tree of depth 10 and 64-bit input in less than 80 seconds, while HElib takes about 400 seconds for 16-bit input. A CUDA implementation [22], [23] of TFHE can further improve the time of PDT-BIN using TFHE.

### Performance on Real Datasets

We also conducted experiments on real datasets from the UCI repository [51]. We performed experiments for both PDT-BIN and PDT-INT for the datasets illustrated in Table VII (parameters \( n \), \( d \), and \( m \) are defined in Table I). For PDT-BIN, we reported the costs for HElib (single and amortized) and the costs for TFHE. Since TFHE evaluates only boolean circuits, we only have an implementation and evaluation of PDT-INT with HElib. Table VII also includes the costs of two best previous works that rely solely on homomorphic encryption, with figures taken from the respective papers [41], [48].

For one protocol run, PDT-BIN with TFHE is much faster than PDT-BIN with HElib, which is still faster than PDT-INT with HElib. However, due to the large number of slots, the amortized cost of PDT-BIN with HElib is better. For 16-bit inputs, our amortized time with HElib and our time with TFHE outperform XCMP [41], which used 12-bit inputs. For the same input bitlength, XCMP is still much faster than our one-run using HElib, as the multiplicative depth is just 3. However, our schemes still have better communication and PDT-BIN has no leakage. While the scheme of Tai et al. [48] in the semi-honest model has a better time for 64-bit inputs than our schemes for 16-bit inputs, it requires fast network communication and at least double the cost in the malicious model. The efficiency of Tai et al. is partly due to their ECC implementation of the lifted ElGamal [27], which allows for fast runtime and smaller ciphertexts but is not secure against a quantum attacker, unlike lattice-based FHE used in our schemes.

### Conclusion

While most existing PDTE protocols require extensive interaction between the client and the server, we designed and implemented novel client-server protocols that delegate the complete evaluation to the server while preserving privacy and keeping the overhead low. Our solutions rely on SHE/FHE and evaluate the tree on ciphertexts encrypted under the client’s public key. Given the high overhead of current SHE/FHE schemes, we combine efficient data representations with various algorithmic optimizations to minimize computational overhead and communication cost.