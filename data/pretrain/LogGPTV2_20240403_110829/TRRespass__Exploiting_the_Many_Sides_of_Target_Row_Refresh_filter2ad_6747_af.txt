implement a simpliﬁed version of TRRespass for ARMv8
to test LPDDR4 [40] and LPDDR4X [43] chips on mobile
phones. Due to the fragmented nature of the Android ecosys-
tem and the limited privileges (and resources) available on
some of these devices, we drop one of the two fundamental
parameters used in our previous design: location. In other
words, we simply map a big chunk of memory and ﬁnd a
pool of addresses that belong to the same bank [76]. Van der
Veen et al. [91], [92] rely on uncached memory due to the
lack of cache ﬂushing instructions on ARMv7. This restriction
does not apply any longer on ARMv8, and thus we do not use
uncached memory. In our experiments, TRRespass discovers
effective hammering patterns on 5 of the 13 devices, proving
that TRR-protected mobile platforms are also still vulnerable
to RowHammer (data is shown in Table III). Not all mobile
platforms report information about the memory manufacturer
and we do not have ﬁne grained control over the memory
allocations. As a result, we cannot draw any conclusion with
regard to the extent of the vulnerability on LPDDR4(X).
Furthermore, phones from the same model can use DRAM
chips from different manufacturers. This means that even if
TRRespass ﬁnds RowHammer bit ﬂips on a certain phone from
a speciﬁc model, another phone from the same model may not
exhibit these bit ﬂips. Similarly, the opposite can also be true.
VII. EVALUATION
In this section, we systematically evaluate our 42 DDR4
DRAM modules against
the optimal RowHammer access
pattern (i.e., the one that yields the most bit ﬂips) identiﬁed
by TRRespass for each module.
A. Results
We test each of the 42 modules using the most-bit-ﬂip-
incurring RowHammer pattern that we discover for each
module in Section VI-B. For every module, we perform a
sweep over 256 MB of contiguous physical memory.5 We
5We avoid testing the entire capacity of the DRAM modules and instead
test 256 MB of each module to reduce testing time. We note that this could
potentially cause TRRespass to miss the most RowHammer-prone portions of
a module. Thus, we believe TRRespass is likely to be more effective than
what we report in this paper.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
757
same RowHammer experiment using the aggressor rows that
we know can cause bit ﬂips, we observe a varying number
of bit ﬂips in the victim row(s) across different iterations.
Figure 14 shows the number of bit ﬂips that we can trigger on
a speciﬁc row, using 3 aggressors in module B0. We observe
from the ﬁgure that different iterations (i.e., samples) of the
same test reveal a different number of bit ﬂips in the same
victim row. Second, when hammering the same module in a
multi-DIMM conﬁguration (i.e., two identical modules on the
same system), we often observe more bit ﬂips. These results
hint at the presence of a parameter TRRespass cannot (yet)
bypass. The fact that we occasionally observe a large number
of bit ﬂips suggests that these modules are quite susceptible
to RowHammer, and causing more bit ﬂips may be only a
matter of improving our fuzzing strategy.
Fig. 14: Bit ﬂips vs. Test iterations. Module B0: Number of bit
ﬂips over test iterations. In each iteration, the aggressor rows are
hammered for three refresh intervals.
Vendor C. TRRespass identiﬁes effective patterns on 2 of 14
C modules. However, we see a steep drop in the number of
bit ﬂips on modules from newer generations. Module C12,
produced before 2015,
is the oldest and most vulnerable
module in our test set (Table II). Modules of newer gener-
ations are less vulnerable (if at all) to the patterns identi-
ﬁed by TRRespass. This suggests that the in-DRAM TRR
implementation has evolved over time. We perform further
experiments on C13 to conﬁrm this hypothesis. We discover
that, instead of performing a single targeted refresh during
each regular refresh operation, the TRR mitigation employed
by C13 performs multiple targeted refreshes during each regular
refresh operation. While we can conﬁrm that recent DRAM
chips are still vulnerable to RowHammer, further research is
required to better understand newer TRR mitigations and to
ﬁnd more effective fuzzing strategies against them.
B. Increasing the Refresh Rate
As mentioned in Section V-A, the memory controller issues
a REFRESH command to the memory device every 7.8 μs,
to ensure that all cells are refreshed within a 64 ms interval.
Doubling (or even quadrupling) the refresh rate (i.e., double-
refresh) was proposed in the past [6], [7], [46], [51], [64] as an
immediate countermeasure against RowHammer attacks, since
doing so reduces the amount of time required for hammering.
As discussed in Section IV, some server platforms employ
double-refresh as default behavior or enable it when a non-
TRR-compliant DRAM module is in use. This is usually
not the case on consumer platforms.6 However, tREFI can
(sometimes) be set in the BIOS. Although double-refresh was
demonstrated in the past to not fully eliminate the RowHam-
mer vulnerability [7], [51], the introduction of in-DRAM TRR
may have changed the situation. In fact, since TRR acts mainly
at refresh time, doubling the refresh operations could improve
TRR’s security guarantees, enforcing the inhibitor operations
more frequently. To test
this hypothesis, we evaluate our
modules against TRRespass when running them with double
refresh.
Our experiment reveals the presence of new hammering
patterns that are still able to trigger bit ﬂips in three modules
(as indicated in the rightmost column in Table II). This result
further undermines the efﬁcacy of double refresh as a stopgap
solution against RowHammer even when in-DRAM TRR is
deployed.
C. Repeatability of the Bit Flips
Repeatability is a fundamental factor in RowHammer ex-
ploitation. The ability to reliably trigger a bit ﬂip repeat-
edly [51] is what made RowHammer so popular in adversarial
scenarios [14], [25], [28], [71], [72], [79], [81], [89], [91], [96].
We study the repeatability of these many-sided RowHam-
mer bit ﬂips to better understand their properties. We pick
one DRAM module per DRAM vendor (A14, B1, C13) and
we run the best pattern for each module. When a bit ﬂip
occurs, we try to repeat it. Our experiment conﬁrms that bit
ﬂips are repeatable in a reliable way for all the modules.
However, it may require multiple attempts before obtaining
the same bit ﬂip again and sometimes we may observe many
other spurious bit ﬂips generated by the same pattern (see our
analysis of Vendor B modules in Section VII-A). We discuss
the implications of this phenomenon for the exploitation of
these bit ﬂips in Section VIII.
VIII. EXPLOITATION WITH TRRespass
TRRespass generates many-sided RowHammer patterns to
bypass TRR on modern DDR4 modules. While such access
patterns are more sophisticated than standard RowHammer
access patterns [27], [51], [88], we now show that
their
practical exploitability is not only possible, but also similar,
in spirit,
to existing state-of-the-art RowHammer attacks.
For
this purpose, we show how we craft many-sided
RowHammer
exploits using the general RowHammer
exploitation framework used by prior work in the area [79].
The exploitability investigated by the framework revolves
around three fundamental steps:
(i) Memory templating,
(ii) Memory massaging, and (iii) Exploitation.
Memory Templating. In this step, the attacker scans memory
with RowHammer access patterns,
looking for vulnerable
memory pages (or templates) where one or more bits can be
ﬂipped at a speciﬁc offset. For templating to be successful,
an attacker needs to use the desired patterns when accessing
DRAM. Prior work has already demonstrated the feasibility
of using double-sided RowHammer patterns using either huge
(2MB) pages [79] or a variety of side channels to identify
6As we report in Table II, we occasionally detect double-refresh behavior
on particular DRAM modules. This suggests that the memory controller may
employ module-dependent mechanisms for RowHammer mitigation.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
758
[25],
[37],
vulnerable
physically contiguous memory ranges
[54],
[91]. For many-sided RowHammer, we can use the former
mechanism as long as we can ﬁt all the aggressor rows in a
single huge page (similar to double-sided RowHammer). This
is possible for simple variants such as 3-sided RowHammer,
but not for complex variants such as 19-sided (which may
require two or more consecutive huge pages). However,
many of these modules vulnerable to lengthy patterns are
also vulnerable to a series of different other patterns (often
shorter). Moreover, the results on LPDDR4(X), where we
simply hammer random addresses belonging to the same
bank, demonstrate that the location of the aggressors is not
always a fundamental parameter—relaxing the assumptions
for the attacker. In the case where only extended patterns
(e.g., 19-sided) are effective or in the absence of huge pages
in the system, we can still use a variety of page allocator side
channels [25], [54], [91] or speculative side channels [37],
[93] to locate a sufﬁciently large contiguous memory chunk
to ﬁt our many-sided RowHammer patterns and template
memory.
Memory Massaging. Once
are
available,
the attacker needs to implement some form of
memory massaging to lure the victim into mapping the target
data onto one of the available templates. Any of the memory
massaging techniques described in prior work still apply
with no modiﬁcations to many-sided RowHammer, given that
memory massaging is pattern-agnostic [14], [25], [27], [28],
[79], [91], [92].
Exploitation. Once the target data is mapped onto the target
template, the attacker needs to trigger the same RowHammer
bit ﬂips using the previously templated access patterns to com-
plete the ﬁnal exploitation step. For this step to be successful,
the attacker needs to ensure that, with high probability, (i) the
templated bit ﬂips are repeatable, and (ii) there are no spurious
(non-templated) bit ﬂips in the victim page. Prior work has
shown that these assumptions hold in practice for state-of-the-
art attacks based on standard access patterns. Compared to
such patterns, many-sided patterns incur similar (albeit lower)
repeatability, as discussed in Section VII-C. In practice, this
means the attacker may have to perform the access patterns
multiple times for reliable exploitation. Moreover, to ensure
there are no spurious bit ﬂips across runs, the attacker can
trivially mask irrelevant columns in the aggressor rows as
shown in previous work [23], [33], [54] or otherwise use these
bit ﬂips as part of a compatible attack vector (e.g., corrupting
multiple bits of a cryptographic key [79]).
templates
Overall, TRRespass-based exploitation is very similar to
existing RowHammer attacks. As shown in the next section,
once effective many-sided access patterns are available, an
attacker can reliably mount real-world RowHammer attacks
on modern DDR4 systems in a matter of minutes.
A. Exploitation on DDR4
Armed with (repeatable) templates, we now study the effec-
tiveness of different RowHammer exploits on modern DDR4
systems. To this end, we implement three example attacks:
(i) the original RowHammer exploit targeting PTEs (Page
Table Entries) to obtain kernel privileges from Seaborn and
Dullien [81], (ii) the RSA exploit from Razavi et al. [79] that
corrupts public keys to gain access to a co-hosted VM, and (iii)
the opcode ﬂipping exploit on the sudo binary from Gruss et
al. [27]. The PTE exploit [81] takes advantage of bit ﬂips on
the Page Frame Number (PFN) to probabilistically redirect the
virtual to physical mapping of an attacker-controlled page to
another page table page. This relies on page table spraying to
increase the probability of referencing another page table page
with the corrupted PFN. The exploit from Gruss et al. [27]
shows that it is possible to target code pages in the page cache
to compromise opcodes and bypass permission checks on the
sudo binary. Gruss et al. [27] report 29 vulnerable opcodes
to use for this purpose. Razavi et al. [79] propose an attack
to compromise an RSA public key stored in the page cache.
They prove that causing a bit ﬂip in the modulus of a 1024-bit
or 2048-bit RSA public key makes the modulus factorizable
with a probability of 12-22%. For our analysis, we target a
2048-bit RSA public key.
We assume an attacker capable of performing memory
massaging—placing an exploitable target on one of the vul-
nerable memory pages—using any well-known technique [14],
[25], [27], [28], [79], [91], [92]. Table IV presents our results
for two sample modules for each vendor—the most and
least vulnerable from the same manufacturer. As part of our
analysis, we also record τ (i.e., time to template a single row),
since many-sided RowHammer requires more time to carry
out templating compared to previous RowHammer variants.
As expected, we see a large discrepancy across the different
modules, which matches the largely different number of bit
ﬂips reported in Table II. In the case of B modules, where
TRRespass is able to generate very few bit ﬂips, we are
unable to reproduce any attack. On the other hand, on the
other 4 modules from vendors A and C we can (overall)
ﬁnd templates to reproduce all the attacks. On C12, we can
reproduce the PTE attack [81] in as little as 2.3 s, while
the RSA-2048 exploit [79], when successful, can take up
to 39 m 48 s (A4). Bypassing sudo permission checks [27]
turned out to be possible only on C12 in 54 m 16 s. Note that
we assume existing templating strategies as is: we did not
attempt to craft more sophisticated attacks, since our goal
is solely to test existing RowHammer variants. Overall, our
results show that RowHammer still presents a signiﬁcant threat
to the security of modern DDR4 systems, even in the presence
of in-DRAM TRR mitigations.
TABLE IV: Time to exploit. Time to ﬁnd the ﬁrst exploitable
template on two sample modules from each DRAM vendor.
Module τ (ms)
A14
A4
B1
B2
C12
C13
188.7
180.8
360.7
331.2
300.0
180.9
PTE [81] RSA-2048 [79]
sudo [27]
4.9s
38.8s
6m 27s
39m 28s
2.3s
3h 15m
74.6s
54m16s
τ: Time to template a single row: time to ﬁll the victim and aggressor rows + hammer
time + time to scan the row.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:42:55 UTC from IEEE Xplore.  Restrictions apply. 
759
IX. RELATED WORK
X. CONCLUSION
RowHammer. In their seminal work, Kim et al. [51] are the
ﬁrst to rigorously introduce and characterize the RowHam-
mer vulnerability. Following this work, a large number of
of attacks compromising a variety of different systems [5],
[12], [13], [17], [24], [25], [28], [39], [77], [79], [81], [89],
[91], [92], [96], [98] and characterization studies [22], [23],
[27], [78], [88] emerged, as described in a recent retrospec-
tive article [72]. Prior works rely on three main classes of
RowHammer patterns to induce bit ﬂips: (i) single-sided, (ii)
double-sided, and (iii) one-location RowHammer. None of
these techniques are effective against modern DDR4 modules
with in-DRAM RowHammer mitigations. Lanteigne [55], [56]
proposes a technique (called regional RowHammer), where
a small 2 MB region (e.g., a Linux hugepage) is hammered
using multiple software threads to increase the DRAM row
activation rate. In fact, we are not the ﬁrst to use the term
n-sided RowHammer for n = 4, as Lanteigne refers to his
technique as quad-sided [55]. However, his technique does
not provide a clear or methodical way of picking aggressor
rows that are close to each other in a bank, and instead aims
to maximize the number of row activations. We show that
merely maximizing the number of activations is not sufﬁcient
to bypass in-DRAM RowHammer mitigations.
Software-based mitigations. Herath and Fogh [32] and
Aweke et al. [7] suggested “hybrid” mitigations based on hard-
ware performance counters to detect suspicious hammering-
like activity. Other mitigations, such as CATT [16] and
GuardION [92], try to enforce DRAM-based data isolation to
prevent RowHammer attacks from corrupting sensitive data.
Nevertheless, recent work has shown how these mitigations
cannot stop more sophisticated attacks [25], [27]. With the
correct DRAM mapping functions, ZebRAM [53] can protect
the entire system by extending isolation to the entire DRAM.
Unfortunately, ZebRAM becomes expensive when the active
working set of an application is larger than half of DRAM
capacity.
Hardware-based mitigations. Although doubling the refresh
rate or using ECC memory are immediately-deployable solu-
tions, they have proven insufﬁcient to stop RowHammer [7],
[23], [51]. Other hardware-based mitigation techniques have
been proposed [62], [86], [87] but, to our knowledge, these
have not been deployed in real systems. Kim et al. propose
Probabilistic Adjacent Row Activation (PARA) [51], which
is a low overhead mechanism to prevent RowHammer bit
ﬂips. When a row is activated, with a very small probability,
PARA refreshes rows adjacent to the activated row. A variant
of PARA, Hardware RHP, appears to be employed by some
Intel memory controllers [36], [73], [90], [94]. This is a
new RowHammer measure in the memory controller and its
robustness is yet to be independently validated. In recent years,
TRR has become the hardware-based RowHammer mitigation
of choice, ﬁrst deployed in the MC on DDR3 systems and then
in-DRAM on DDR4. While DDR3 systems have been widely
studied, only a few studies have reported RowHammer bit ﬂips
on DDR4 [27], [56], [66]. Compared to our analysis, such
studies have induced bit ﬂips on selected earlier-generation
DDR4 modules. In contrast, we study several generations
of DDR4 modules (including the most-recent off-the-shelf