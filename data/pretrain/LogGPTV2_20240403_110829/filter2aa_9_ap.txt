### 优化后的文本

**引言：**

Jon Postel在1977年的IEN 2中指出，我们在互联网协议的设计上违背了分层原则。具体来说，我们试图使用TCP同时作为主机级别的端到端协议和网络的分组与路由协议。他认为，这两种功能应通过分层和模块化的方式实现。Postel建议设计一个新的独立的互联网协议，并将TCP严格限制为主机级别的端到端协议。这一建议在一年后被采纳，第三版协议决定将TCP和IP分离，这种设计一直沿用至今。

有趣的是，Jon Postel不仅是Vinton Cerf的高中同学，也是ARPANET项目的同事。Postel于1998年因病去世时，Cerf为他撰写了一篇感人至深的讣告，并以RFC 2468的形式发布。据我所知，这是唯一一篇无关技术的RFC文档，对一位计算机科学家而言，这也许是最有意义的纪念方式。今天，我们仍可以通过http://tools.ietf.org/html/rfc2468阅读这篇讣告。

**TCP/IP的成功：**

TCP/IP的设计非常成功。30多年来，尽管底层的带宽、延迟和传输介质发生了巨大变化，顶层的应用也不断增加，但TCP/IP依然稳定可靠。它不仅战胜了国际标准化组织（ISO）的OSI七层模型，而且目前还没有其他方案能够取代它。第一代从事TCP/IP工作的工程师，即使到了退休年龄，仍然在这个朝阳产业中发挥着重要作用。

**OSI模型的困境：**

令人费解的是，现在的大学课程仍在介绍OSI七层模型。该模型与TCP/IP模型的对应关系如图2所示。由于OSI模型层数较多，许多学生难以理解，甚至记不住各层的顺序。因此，老师们常用"All People Seem To Need Data Processing"这个助记词来帮助记忆，因为这七个单词的首字母与OSI模型每一层的首字母相同。这反映了大学教育中的应试倾向。更奇怪的是，学生们毕业后会发现，这个复杂的七层模型在市场上已经没有太多应用价值。尽管历史上得到了官方的大力支持，但市场显然更青睐TCP/IP的四层模型。

**OSI模型的批评：**

按理说，作为权威组织设计的OSI模型应该是科学的。然而，为什么它反而不受欢迎呢？许多专家对此进行了评论，其中普渡大学特聘教授Douglas Comer的批评最为激烈。他在一篇文章中提到：

“最近有一些惊人的发现：虽然我们知道OSI七层模型是由一个小组完成的，但大家不知道的是，这个小组有一天深夜在酒吧里谈论美国娱乐八卦。他们在餐巾纸上写下了迪士尼电影中七个矮人的名字，有人开玩笑说七对于网络分层是个好数字。第二天上午，在标准化委员会的会议上，他们传阅了那张餐巾纸，并一致同意昨晚喝醉时的重大发现。当天结束时，他们给七个层次重新起了听起来更科学的名字，于是模型就诞生了。”

这个故事告诉我们：如果你是标准委员会中的工程师，请不要和同事喝酒——深夜在酒吧里的一个拙劣玩笑，可能会成为业界几十年挥之不去的噩梦。

Douglas Comer在网络界享有很高的声望，他曾是思科公司的研究副总裁，同时也是著名的技术作家。他的观点具有代表性，而当时业界普遍对OSI模型的抵触态度也是一个有力的佐证。幸运的是，如今OSI模型几乎名存实亡，其影响仅限于那些尚未更新的教科书中。

**NFS挂载过程：**

以下是NFS挂载过程中的一些步骤及其解释：

1. **查询NFS进程端口号**：
   客户端首先找到服务器的`portmap`进程，向其查询NFS进程的端口号。`portmap`进程维护一张进程与端口号的对应关系表，其自身的端口号111是众所周知的。这个角色类似于公司前台，她知道每个员工的分机号。当我们需要联系公司里的某个人（比如NFS）时，可以先拨前台（111），查询到其分机号（2049），然后直接拨打分机号即可。大多数文件服务器都使用2049作为NFS端口号，因此即便不先咨询`portmap`，直接连接2049端口也不会出问题。

2. **测试NFS服务是否可用**：
   客户端尝试连接服务器的NFS进程，以此判断2049端口是否被防火墙拦截，以及NFS服务是否已启动。

3. **查询`mount`进程端口号**：
   客户端再次联系服务器的`portmap`，询问`mount`进程的端口号。与NFS不同，`mount`的端口号较为随机，因此这一步询问是不能跳过的。

4. **测试`mount`服务是否可用**：
   客户端尝试连接服务器的`mount`进程，以此判断1234端口是否被防火墙拦截，以及`mount`进程是否已启动。

5. **实际挂载目录**：
   在这一步，客户端真正挂载了`/code`目录。挂载成功后，服务器将该目录的文件句柄告诉客户端（需查看详细信息才能看到文件句柄）。

6. **重复测试NFS服务**：
   这一步在我看来是多余的，因为在之前已经测试过NFS服务。可能是开发人员不小心重复调用了同一函数，但由于没有抓包，测试人员也没有发现这个问题。

7. **获取文件系统属性**：
   客户端获得了该文件系统的大小和空间使用率等属性。这些信息可以在客户端上执行`df`命令查看。

8. **重复操作**：
   这一步又是重复操作，进一步证实了开发人员可能的疏忽。这个例子也说明了Wireshark在辅助开发中的作用。

9. **获取文件句柄**：
   文件句柄需要从包的详细信息中查看。正如之前提到的，NFS操作文件时使用的是文件句柄，而不是直接读取文件名。如果一个目录中文件数量巨大，获取文件句柄可能会比较耗时，因此建议不要在一个目录中存放过多文件。

10. **检查同名文件**：
    在创建文件之前，要先检查是否有同名文件存在。如果没有，则继续写入；如果有，则询问用户是否覆盖原文件。

11. **COMMIT操作**：
    这是COMMIT操作。对于异步方式的WRITE调用，服务器在真正存盘前就会回复WRITE Reply，以提高写性能。那么，客户端如何知道哪些WRITE调用已经真正存盘了呢？COMMIT操作就是为此而设计的。只有经过COMMIT的数据才算真正写好。

**案例分析：**

“一小时内给你答复”

在武侠小说中有一段话，大意是练习歪门邪道的功夫，很快便能小有成就，但永远成不了高手。而名门正派的武功虽然入门艰辛，进步缓慢，却是成为一代宗师的必由之路。这段话深得我心，学习网络也只能老老实实地去参透各个协议，才能达到最高境界。研究协议的过程虽然枯燥缓慢，但不可或缺。

有些技术人员喜欢通过重启或乱试一通来碰运气，虽然有时也能成功，但概率很低。如果一个人经常有这样的好运气，那去赌场上班也许更加合适。我最近处理的一个案例很好地说明了这一点。

事情是这样的：现场工程师搭建了一台文件服务器来提供NFS共享，但客户端一直无法挂载，每次尝试都会收到同样的错误“access denied by server while mounting…”，如图1所示。

图1

现场工程师检查了服务器和客户端的所有配置，但找不到原因，这个问题拖延了好几天。当他焦急地打电话给我时，据说客户已经在机房里咆哮，“I am going to throw the box out of the window”。我只好安慰他说，“放心吧，帮我抓一个网络包，一小时内给你答复。”

之所以敢承诺这么短的时间，是因为我已经处理过上百个类似的问题。自从用Wireshark学习了NFS的协议细节后，我可以用它很快地解决任何挂载问题，至今没有失手过。其实一小时还是保守估计，一般5分钟就够了。

现场工程师很快就把配置信息和网络包传了过来：

- 服务器IP: 10.32.106.77
- NFS共享的访问控制:
  - `/paddynmfs 192.168.26.139 (rw)`（只允许192.168.26.139读写，其他客户端不能挂载）
- 客户端IP（见图2）:

图2

现场工程师的排查过程如下：

```bash
[root@localhost ~]# telnet 10.32.106.77 111
Trying 10.32.106.77...
Connected to 10.32.106.77 (10.32.106.77).

[root@localhost ~]# telnet 10.32.106.77 1234
Trying 10.32.106.77...
Connected to 10.32.106.77 (10.32.106.77).

[root@localhost ~]# telnet 10.32.106.77 2049
Trying 10.32.106.77...
Connected to 10.32.106.77 (10.32.106.77).

[root@localhost ~]# showmount -e 10.32.106.77
/paddynmfs 192.168.26.139
```

作为“碰运气”步骤，现场工程师重启了客户端和服务器，但结果还是一样。

我仔细检查完以上信息，结论和现场工程师一样——服务器和客户端的配置都没有问题。而且从排查过程还可以知道：

- 从telnet的输出结果可见，`portmap`（111）、`mount`（1234）以及NFS（2049）进程所对应的端口都是可达的；这说明网络是通的，没有防火墙之类的设备拦截了挂载请求。
- 从`showmount`的结果可以看到，挂载时指定的共享路径也是正确的。

到这里我也有些困惑，一时想不出问题出在哪里。阅读以下内容之前，建议你停下来思考一下，还有什么因素可能导致了挂载失败？

幸好我还有杀手锏，我用Wireshark打开在服务器上抓到的包，然后用192.168.26.139过滤了一下，如图3所示。

图3