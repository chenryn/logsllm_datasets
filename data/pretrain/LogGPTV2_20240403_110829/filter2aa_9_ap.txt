“We are screwing up in our design of internet protocols by violating the principle of layering. Specifically we are trying to use TCP to do two things: serve as a host level end to end protocol, and to serve as an internet packaging and routing protocol. These two things should be provided in a layered and modular way. I suggest that a new distinct internetwork protocol is needed, and that TCP be used strictly as a host level end to end protocol.”（我们违背了分层原则，从而搞砸了网络协议的设计。具体来说，我们正在尝试使用TCP来做两件事：作为一个主机级别的端到端协议；同时也作为网络的分组和路由协议。这两件事本应该用分层和模块化的形式来实现。我建议设计一个新的网络互联协议，并且把TCP严格限制为主机级别的端到端协议。）
—Jon Postel, IEN 2, 1977
这个建议一年后被采纳了，第三版的协议决定把TCP和IP分离开来，并且延续至今。无巧不成书，Jon Postel恰好是Vinton的高中同学，也是阿帕网项目的同事。他在1998年因病去世时，Vinton为他写了一篇感人至深的讣告，并且作为RFC 2468发布。据我所知，这是唯一一篇无关技术的RFC。对一位计算机科学家来说，这也许是最有意义的纪念方式。我们今天还可以通过http://tools.ietf.org/html/rfc2468阅读它。
TCP/IP的设计非常成功。30年来，底层的带宽、延时，还有介质都发生了翻
 天覆地的变化，顶层也多了不少应用，但TCP/IP却安如泰山。它不但战胜了国际标准化组织的OSI七层模型，而且目前还看不到被其他方案取代的可能。第一代从事TCP/IP工作的工程师，到了退休年龄也在做着朝阳产业。
令人费解的是，现在的大学课程还在介绍OSI七层模型。它和TCP/IP模型的对应关系如图2所示。因为OSI模型的层数太多，很多学生根本理解不了，甚至连顺序都记不住。于是老师们就用“All People Seem To Need Data Processing”来帮助记忆，因为这7个单词的首字母和OSI模型每一层的首字母是一样的。大学的应试教育由此可见一斑。更奇怪的是学生们走出校园后，会发现这个笨重的七层模型已经没有市场。虽然历史上它得到过官方的大力支持，但是市场明显更青睐TCP/IP四层模型。
图2
按理说OSI是权威组织，它所设计的模型应该是科学的。为什么反而会不受欢迎呢？很多专家都对此有过评论，其中以普度大学特聘教授Douglas Comer的批评最为激烈。他曾经在一篇文章里这样写过：
“最近有了一些惊人的发现：我们都知道这个七层模型是由一个小组（见图3）完成的，但大家不知道的是，这个小组有一天深夜在酒吧里谈论美国的娱乐八卦。他们把迪斯尼电影里7个小矮人的名字写在餐巾纸上，有个人开玩笑说7对于网络分层是个好数字。第二天上午在标准化委员会的会议上，他们传阅了那张餐巾纸，然后一致同意昨晚喝醉时的重大发现。那天结束时，他们又给七个层次重新起了听上去更科学的名字，于是模型就诞生了。
图3
这个故事告诉我们：如果你是标准委员会中的工程师，请不要和同事喝酒—深夜在酒吧里开的一个拙劣玩笑，却可能成为业界几十年挥之不去的噩梦。”
Douglas是网络界德高望重的前辈，他回到普度大学之前曾是Cisco的Vice President of Research，同时也是久负盛名的技术作家，所以他的观点很有代表性。而当时业界普遍对待OSI模型的抵触态度，更是一个有力的佐证。幸好到了今天，OSI模型几乎名存实亡了，它对我们的影响只停留在还没来得及更新的教科书上。
(1)
 在这一步，客户端找到服务器的portmap进程，向它查询NFS进程的端口号。然后服务器的portmap进程回复了2049。portmap的功能是维护一张进程与端口号的对应关系表，而它自己的端口号111是众所周知的，其他进程都能找到它。这个角色类似很多公司的前台，她知道每个员工的分机号。当我们需要联系公司里的某个人（比如NFS）时，可以先拨前台(111)，查询到其分机号(2049)，然后就可以拨这个分机号了。其实大多数文件服务器都会使用2049作为NFS端口号，所以即便不先咨询portmap，直接连2049端口也不会出问题。
(2)
 客户端尝试连接服务器的NFS进程，由此判断2049端口是否被防火墙拦截，还有NFS服务是否已经启动。
(3)
 客户端再次联系服务器的portmap，询问mount进程的端口号。与NFS不同的是，mount的端口号比较随机，所以这步询问是不能跳过的。
(4)
 客户端尝试连接服务器的mount进程，由此判断1234端口是否被防火墙拦截，还有mount进程是否已经启动。
(5)
 这一步真正挂载了/code目录。挂载成功后，服务器把该目录的file handle告诉客户端（要点开详细信息才能看到File handle）。
(6)
 在我看来这一步没有必要，因为之前已经试连过NFS了，再测试一次有何意义？我猜是开发人员不小心重复调用了同一函数，但因为没有抓包，所以测试人员也没有发现这个问题。
(7)
 客户端获得了该文件系统的大小和空间使用率等属性。我们在客户端上执行df就能看到这些信息。
(8)
 这一步又是重复操作，更让我怀疑是开发人员的疏忽。这个例子也说明了Wireshark在辅助开发中的作用。
(9)
 这个file handle也需要从包的详细信息里才能看到。就如之前提到过的，NFS操作文件时使用的是file handle, 所以要先通过文件名找到其file handle，而不是直接读其文件名。如果一个目录里文件数量巨大，获取file handle可能会比较费时，所以建议不要在一个目录里存放太多文件。
(10)
 在创建一个文件之前，要先检查一下是否有同名文件存在。如果没有才能继续写，如果有，要询问用户是否覆盖原文件。
(11)
 这是COMMIT操作。对于async方式的WRITE Call，服务器收到Call之后会在真正存盘前就回复WRITE Reply，这样做是为了提高写性能。那么，客户端怎么知道哪些WRITE Call已经真正存盘了呢？COMMIT操作就是为此而设计的。只有COMMIT过的数据才算真正写好。
举重若轻
“一小时内给你答复”
在武侠小说里看到过一段话，大意是练习歪门邪道的功夫，很快便能小有成就，但永远成不了高手。而名门正派的武功虽然入门艰辛，进步缓慢，却是成为一代宗师的必由之路。这段话深得我心，学习网络也只能老老实实地去参透各个协议，才能达到最高境界。研究协议的过程虽然枯燥缓慢，但是不可或缺。
有的技术人员喜欢重启一下或者乱试一通来碰运气，虽然也有成功的时候，但是概率很低。如果一个人经常有这样的好运气，那去赌场上班也许更加合适。我最近处理过的一个案例就很好地说明了这一点。
事情是这样的：现场工程师搭建了一台文件服务器来提供NFS共享，可是客户端一直挂载不上，每次尝试都收到同一个报错“access denied by server while mounting…”，如图1所示。
图1
现场工程师检查了服务器和客户端的所有配置，但实在找不出原因，于是这个问题就拖了好几天。当他焦急地打我电话时，据说客户已经彻底失去耐心了，在机房里咆哮，“I am going to throw the box out of the window”。我只好安慰他说，“放心吧，帮我抓一个网络包，一小时内给你答复。”
之所以敢承诺这么短的时间，是因为我已经处理过上百个类似的问题。自从用Wireshark学习了NFS的协议细节后，我可以用它很快地解决任何挂载问题，至今没有失手过。其实一小时还是保守估计，一般5分钟就够了。
现场工程师很快就把配置信息和网络包传过来了：
 服务器IP：
10.32.106.77
NFS共享的访问控制：
/paddynmfs 192.168.26.139（rw）
##只允许192.168.26.139读写，其他客户端不能挂载
客户端IP（见图2）：
图2
现场工程师的排查过程如下所示。
[root@localhost ~]#telnet 10.32.106.77 111
Trying 10.32.106.77...
Connected to 10.32.106.77 (10.32.106.77).
[root@localhost ~]#telnet 10.32.106.77 1234
Trying 10.32.106.77...
Connected to 10.32.106.77 (10.32.106.77).
[root@localhost ~]#telnet 10.32.106.77 2049
Trying 10.32.106.77...
Connected to 10.32.106.77 (10.32.106.77).
[root@localhost ~]# showmount -e 10.32.106.77
/paddynmfs 192.168.26.139
作为“碰运气”步骤，现场工程师把客户端和服务器都重启过了，但结果还是一样。
 我仔细检查完以上信息，结论和现场工程师一样——服务器和客户端的配置都没问题。而且从排查过程还可以知道：
• 从telnet的输出结果可见portmap（111）、mount（1234）以及NFS（2049）进程所对应的端口都是可达的；这说明网络是通的，没有防火墙之类的设备拦截了挂载请求；
• 从showmount的结果可以看到，挂载时指定的共享路径也是正确的。
到这里我也有点迷惑，一时想不出问题出在哪里。阅读以下内容之前，建议你停下来思考一下，还有什么因素可能导致了挂载失败？
幸好杀手锏没有出，我用Wireshark打开在服务器上抓到的包，然后用192.168.26.139过滤了一下，如图3所示。