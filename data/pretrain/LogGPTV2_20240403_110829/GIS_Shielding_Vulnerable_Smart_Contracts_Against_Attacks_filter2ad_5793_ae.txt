# 6.1 Comparison to Reentrancy Detection Tools

Rodler et al.'s tool, Sereum, flagged 16 contracts as potential victims of reentrancy attacks. However, upon manual investigation, only 2 out of the 16 contracts were actually found to be victims of such attacks. To evaluate the performance of ÆGIS, we analyzed these 16 contracts and compared our results with those obtained by Sereum.

We contacted the authors of Sereum and obtained the list of contract addresses. We then ran ÆGIS on all transactions related to these contract addresses up to block number 4,500,000. Table 1 summarizes our findings and provides a comparison to the results from Sereum.

From Table 1, it is evident that ÆGIS successfully detected the reentrancy attacks on the DAO contract and the DSEthToken contract. Additionally, ÆGIS correctly flagged the remaining 14 contracts as not vulnerable. In contrast to Sereum, ÆGIS did not produce any false positives for these 16 contracts.

Upon analyzing the false positives generated by Sereum, we concluded that ÆGIS avoids these errors because:
1. It does not use taint analysis in its pattern, thereby avoiding over-tainting issues.
2. It does not rely on dynamic write locks to detect reentrancy.

## 6.1.1 Reentrancy with Locks

In addition to evaluating Sereum on the set of 16 real-world smart contracts, Rodler et al. also compared Sereum to ECFChecker using self-created smart contracts as a benchmark [30]. The goal of this benchmark is to assess the quality of reentrancy detection tools. The benchmark consists of three functionally equivalent contracts:
- **VulnBankNoLock**: No locking mechanism to guard against reentry.
- **VulnBankBuggyLock**: Partial implementation of a locking mechanism.
- **VulnBankSecureLock**: Full implementation of a locking mechanism.

As a result, VulnBankNoLock is vulnerable to both same-function and cross-function reentrancy. VulnBankBuggyLock is vulnerable to cross-function reentrancy but not to same-function reentrancy. Finally, VulnBankSecureLock is secure against both types of reentrancy.

We deployed these three contracts on the Ethereum test network (Ropsten) and ran them against ÆGIS. Table 2 presents our results and compares ÆGIS to ECFChecker and Sereum. We observed that ECFChecker has difficulty detecting cross-function reentrancy, while Sereum struggles to distinguish between reentrancy and manually introduced locks. This is likely because the locking mechanism exhibits the same pattern as a reentrancy attack, and Sereum cannot differentiate between the two. In contrast, ÆGIS correctly classified each contract as either vulnerable or not vulnerable in all test cases.

## 6.1.2 Unconditional Reentrancy

Calls that send ether are usually protected by checks in the form of `if`, `require`, or `assert` statements. Reentrancy attacks typically aim to bypass these checks. However, it is possible to write a contract that does not perform any check before sending ether. Rodler et al. present an example of such a vulnerability, termed "unconditional reentrancy" (see Appendix B). They also found an example of such a contract deployed on the Ethereum blockchain [7].

When Sereum was first published, it could not detect this type of reentrancy because the authors assumed that every call leading to a reentrancy would be guarded by a condition. The authors claim to have fixed this issue by extending Sereum to track data flows from storage to the parameters of calls. However, we cannot verify this since the source code of Sereum is not publicly available.

We ran ÆGIS on both examples: the manually created example by Rodler et al. and the contract deployed on the Ethereum blockchain. ÆGIS correctly identified the unconditional reentrancy in both examples without modifying the existing patterns. This is expected because, unlike Sereum's initial method, ÆGIS's reentrancy patterns do not rely on the detection of conditions (e.g., JUMPI) to identify reentrancy.

## 6.2 Large-Scale Blockchain Analysis

In this experiment, we analyzed the first 4.5 million blocks of the Ethereum blockchain and compared our findings to those of Rodler et al. We started by scanning the Ethereum blockchain for smart contracts deployed up to block 4,500,000. We found 675,444 successfully deployed contracts, with deployment timestamps ranging from August 7, 2015, to November 6, 2017.

Next, we replayed the execution history of these 675,444 contracts. We found that only 12 contracts in our dataset had more than 10,000 transactions. To reduce execution time, we limited our analysis to the first 10,000 transactions of each contract. Similar to Rodler et al., we skipped transactions involved in denial-of-service attacks to avoid high execution times [8].

We ran ÆGIS on our set of 675,444 contracts using a 6-core Intel Core i7-8700 CPU @ 3.20GHz and 64 GB RAM. On average, ÆGIS took 108 milliseconds to analyze a transaction, with a median of 24 milliseconds per transaction. In total, we re-executed 4,960,424 transactions, with an average of 8 transactions per contract.

Table 3 summarizes our results. ÆGIS found a total of 1,118 malicious transactions and 248 unique contracts that had been exploited through either a reentrancy or an access control vulnerability. Specifically, ÆGIS found that 7 contracts were victims of same-function reentrancy, 5 contracts of cross-function reentrancy, 3 contracts of the first Parity wallet hack, and 236 contracts of the second Parity wallet hack. Similar to the results of Rodler et al., we did not find any contracts that had become victims of delegated reentrancy or create-based reentrancy. We validated all our results by manually analyzing the source code (whenever it was publicly available) and/or the execution traces of the flagged contracts. Our validation did not reveal any false positives.

Table 4 lists all the contract addresses that ÆGIS detected as victims of same-function reentrancy. The block range defines the block heights where ÆGIS detected the malicious transactions. The first and second contract addresses in Table 4 are the same as reported by Sereum and belong to the DSEthToken and DAO contracts, respectively. The rows highlighted in gray mark 5 contracts that were flagged by ÆGIS but not by Sereum. After investigating the transactions of these 5 contracts, we found that the contract addresses 0x26b8af052895080148dabbc1007b3045f023916e and 0xbf78025535c98f4c605fbe9eaf672999abf19dc1 became victims of same-function reentrancy but seem to be contracts deployed for studying the DAO hack. The other three contract addresses appear to be true victims of reentrancy attacks.

# 7 Discussion

In this section, we discuss alternatives for determining eligible voters, highlight some current limitations, and outline future research directions for this work.

## 7.1 Determining Eligible Voters

The introduction of new patterns in ÆGIS depends on achieving consensus within a predetermined group of voters. While it might seem intuitive to let miners vote, they may not be the best fit. Their interests may differ from those of smart contract users. For example, depending on a pattern's complexity, it might introduce an overhead in terms of execution time. Miners are incentivized to prefer simpler patterns that are evaluated more quickly, whereas smart contract users would prefer more secure patterns.

Alternatively, a group of trusted security experts could act as eligible voters. Security experts, by definition, are capable of properly evaluating patterns and have a vested interest in doing so. The voting contract would be controlled by a group of trusted experts, decided off-chain by a group of admins. For transparency, the identity of admins and experts would be exposed to the public by mapping every identity to an Ethereum account. Changes to the list of voters, the deposit, or the commit and reveal windows would be visible to anyone via the blockchain. Through this setup, security experts would be able to organize themselves, with the voter list comprising a curated group of knowledgeable individuals. Such groups already exist, for example, the members of the Smart Contract Weakness Classification registry (SWC) [9, 10].

Although this approach allows for scalability and control, it introduces managing third parties, which runs counter to the decentralized concept of Ethereum.

Another option is to select voters while preserving the decentralized concept of Ethereum. This can be achieved by removing the role of admins and following a self-organizing strategy similar to Proof-of-Stake. In this case, anyone can become a voter by purchasing (not prohibitively priced) voting power. This could be achieved by depositing a fixed amount of ether into the voting smart contract as collateral.

## 7.2 Adoption and Participation Incentives

Deploying ÆGIS would require a modification of the Ethereum consensus protocol, necessitating updates to existing Ethereum clients. This could be easily achieved through a major release, including this one-time modification as part of a scheduled hard fork. Another issue concerns the incentives to propose and vote on patterns. While prestige or a sense of contributing to Ethereum's security may be sufficient for some, additional incentives may be needed to ensure that the protective capabilities of ÆGIS are fully utilized. A monetary incentive could address this. ÆGIS could be extended to enable bug bounties. The smart contract could be modified such that owners of smart contracts can register their contract address by sending a transaction to ÆGIS's voting smart contract and depositing a bounty in the form of ether. Proposers of patterns would then be automatically rewarded with the bounty if their proposed pattern is accepted by the group of voters. Moreover, owners could replenish the bounty for their contract by making new deposits to ÆGIS's smart contract.

## 7.3 Limitations and Future Work

A current limitation of our tool is that proposed attack patterns are submitted in plain text to the smart contract. Potential attackers can view these patterns and use them to find vulnerable smart contracts. To mitigate this, we propose using encryption so that only the voters can view the patterns. However, this would break the current capability of the smart contract being self-tallying. Designing an encrypted and practical self-tallying solution is left for future work. Additionally, we intend to use parallel execution inside the extractors and the checking of patterns to improve the time required to analyze transactions.

# 8 Conclusion

While academia has proposed several tools to detect vulnerabilities in smart contracts, they all fail to protect already deployed vulnerable smart contracts. One proposed solution is to modify Ethereum clients to detect and revert transactions that try to exploit vulnerable smart contracts. However, these solutions require all Ethereum clients to be updated every time a new type of vulnerability is discovered. In this work, we introduced ÆGIS, a system that detects and reverts attacks via attack patterns. These patterns describe malicious control and data flows using a novel domain-specific language. We also presented a novel mechanism for security updates that allows these attack patterns to be updated quickly and transparently via the blockchain, using a smart contract to store them. Finally, we compared ÆGIS to two state-of-the-art online reentrancy detection tools. Our results show that ÆGIS not only detects more attacks but also has no false positives compared to current state-of-the-art tools.

# Acknowledgments

We would like to thank the Sereum authors, especially Michael Rodler, for sharing their data with us. We also thank the reviewers for their valuable comments and Daniel Xiapu Luo for his valuable help. The experiments presented in this paper were conducted on the Ropsten test network.