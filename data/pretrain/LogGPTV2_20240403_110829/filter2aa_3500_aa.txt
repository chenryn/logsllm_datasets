云虚拟化安全：QEMU的安全探索
和防御
0 1
钱文祥
(@leonwxqian) Tencent Blade Team高级安全研究员
•
云虚拟化、IoT、浏览器等安全研究
•
发现NVIDIA vGPU等逃逸漏洞、Amazon Echo、Google Home音箱、浏览器中“麦哲伦”
（SQLite）、Curl的多个远程代码执行漏洞等
•
多次在著名会议上参讲
0 2
n
Tencent Blade Team由腾讯安全平台部在2017年底成立
n
专注于AIoT，移动互联网，云虚拟化技术，可信计算等前沿领域的安全技术研究
n
向Google、Microsoft、 Apple、Amazon、Huawei等诸多国际知名公司报告过200+安全漏洞
n
研究成果多次入选BlackHat、DEFCON、CanSecWest、HITB、POC、Xcon等顶级安全大会
n
团队官网：https://blade.tencent.com
云虚拟化
0 3
•
许多种云服务需要从一个物理硬件系统创建多个模拟环境
•
实现这个技术的核心便是虚拟化，具体则是Hypervisor层
•
Hypervisor是一种运行在基础物理服务器和操作系统之间的中间
软件层，可允许多个guest操作系统和应用共享硬件
•
典型的代表有：QEMU-KVM，Xen，VMware，Hyper-V等等
Hypervisor的位置
0 4
•
Hypervisor是用户（Guest）和云服务提供商的
“边缘”
•
Host是总管理员，上面可运行大量虚拟化机器
•
用户看来，Guest就是一台电脑，用户可以完全
控制Guest
•
但是如果有漏洞允许用户从Guest中穿透到Host上，则会对主机的隐私性、安全性造成
极大危害
QEMU中的存储
0 5
•
存储一直是各虚拟机/容器的重要的攻击面
•
常见的存储模式有PATA/SATA/virtio-blk/virtio-sata……
•
Virtio方式是QEMU默认支持功能中性能最高的存储使用方式
•
若不可使用virtio驱动程序，则x86一般可以使用AHCI (SATA)以提高效率
•
QEMU的AHCI模块中发现了一个任意长度越界读写的问题
•
CVE-2020-29443
https://qemu.org/2021/01/19/virtio-blk-scsi-configuration/
AHCI（高级主机控制接口）设备简介
0 6
•
AHCIV(AdvanceVHostVControllerVInterface)由 IntelV开发，用于提速 SATAV设备的数据处理
•
AHCI是SATA的技术，SATA是PATA（原称ATA）演变而来的接口
•
从QEMU源码树上看，PATA/SATA/AHCI都共享一部分源码
•
AHCI可使用MMIO直接地访问磁盘，而无需像IDE那样使用复杂的PMIO命令序列
•
AHCI控制器是具有总线主控能力的 PCIV设备
•
AHCIV控制器是系统内存和 SATAV设备之间的数据传输引擎
•
但AHCI的文档很少，常用的参考资料是 IntelVAHCIV规范和Linux源码
0 7
按此顺序
1 FIS
2 ATAPI
3 PRDT
FIS （帧信息结构）
0 8
•
SATA使用FIS(FrameV InformationVStructure)包在主机和设备之间传输数据
•
SATA使用与PATA相同的命令集，SATA/PATA控制上最明显的区别就是FIS。
•
可以将FIS视为传统任务文件的数据集，或ATA命令的封装
•
共有下列几种FIS指令
•
RegisterVFISV- hostVtoVdeviceV
•
RegisterVFISV- deviceVtoVhost
•
DMAVactivateVFISV- deviceVtoVhostVV
•
DMAVsetupVFISV– bidirectional
•
DataVFISV– bidirectional
•
BISTVactivateVFISV– bidirectional
•
PIOVsetupVFISV- deviceVtoVhost
•
SetVdeviceVbitsVFISV- deviceVtoVhost
ATAPI Command
0 9
•
ATAPIV是一种向连接到 ATAV总线的光驱或磁带驱动器发出SCSI命令的方法
•
最重要的是 PACKET 命令 (0xA0)V和 IDENTIFYVPACKETVDEVICEV(0xA1)命令
•
PACKET由1个字节SCSI命令，后跟 11个字节的数据组成
•
QEMU中名为“WIN_PACKETCMD（0xA0）”
PRDT
1 0
•
全称为物理区域描述表（PhysicalVRegionVDescriptorVTable）
•
PRDT的每一项为16字节，分别有下列含义：
•
DBA是一个物理地址，它是读操作的目标地址，或者写操作的源地址
•
DBC则用于指示每次操作的字节长度
•
PRDT按链表的形式组织，一项连着一项，最多可以由65535个项目组成
12-15
7-11
4-7
0-3
DBCVV- 字节计数
保留不用
DBAUV- DBA地址（高位）
DBAV– 数据基地址（低位）
漏洞的发现
触发漏洞的位置
1 2
•
IO密集型代码注重性能，底层设计理念理应是“无必要，不检查”，检查应在代码早期阶段进行
•
IO操作的最底层代码是假想的污点最终会到达的地方
•
从这里自底向上进行审计，我们发现了一个可疑的位置，它很像是一个在循环中的memcpy
•
它拷贝的对象是s->io_buffer，这是一个预先分配的，固定长度的Buffer
•
Source是客户机提供的输入，size也是客户机提供的输入，它的参数看起来并不安全
污点的追踪——ide_atapi_cmd_read_pio
1 3
•
显然应当将source和size作为污点向上溯源
•
向上一层，控制复制总大小的packet_transfer_size由nb_sectors 和 sector_size计算而来（右图）
•
引入的新污点nb_sectors，则是从某个buf中读取出来的（左图）
调用顺序
如果进一步回溯……
1 4
•
向上回溯三层，我们获得了这样一个调用链条：
•
(hw/ide/atapi.c)Vcmd_read 或 cmd_read_cdà
ide_atapi_cmd_read à
ide_atapi_cmd_read_pio
•
到此还比较明晰，但如果重复这个步骤，问题就来了：
•
污点的源头越来越多，很多变量都参与了这个链条
•
IDE/AHCI共用代码分支，分支岔路很多，很难确定数据通过哪条路径走过来
•
让我们从AHCI规范开始，定位代码的安全问题在哪里
理解AHCI的核心——CommandVTable
FIS指令结构体的布局
1 6
•
整个CommandVTable是一体的，但是为了方便介绍，这里先只提FIS部分
•
一个AHCI由6个port构成，设备使用的port是固定的，FIS等和port绑定
•
找到一块内存放置cmd_fis结构体，低地址物理内存如0x20000似乎是一个不错的选择
•
MMIO写操作回调ahci_mem_write中也为PMIO预留了一部分内存区域
•
因此MMIO/PMIO读写其实都可以通过MMIO来完成
FIS指令结构体的内存布局
1 7
•
通过MMIOàPMIO写回调设置lst的地址为0x20000，这是整个CommandVTable的地址
•
通过AHCI_PORT_REG_CMD_ISSUE触发FIS指令处理器
•
在lst开头，例如0x20000处，按FIS格式设置好状态信息，包括最重要的 feature字段