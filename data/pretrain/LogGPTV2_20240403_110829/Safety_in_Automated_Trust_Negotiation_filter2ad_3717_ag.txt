4.4.3 Node Processing State Initialization. When a new node is added to a
TTG, its processing state should be initialized as follows:
r A trivial target is fully processed.
r For a attribute target, (cid:4)K V : K .r ?(cid:2) K S(cid:5), if K .r is a dummy attribute, the tar-
get is opponent-processed, which means that the opponent cannot process it;
otherwise, it is veriﬁerprocessed.
r An intersection target is initially opponent-processed.
4.4.4 Veriﬁer-Side Processing. We now deﬁne the candidate update oper-
ations a negotiator K V using conﬁguration G can perform on nodes for which
K V is the node’s veriﬁer. These rules apply to nodes that are not yet marked
veriﬁerprocessed.
1. Processing T = (cid:4)K V : K .r ?(cid:2) K S(cid:5)
(a) For each locally available policy statement K .r ←− K1.r1 in which K .r is a
dummy attribute (the negotiator controlling), K V can add an implication
edge T (cid:3)(cid:4)K V : K1.r1
?(cid:2) K S(cid:5).
(b) K V can mark T as veriﬁerprocessed only after (a) is done, meaning that
all edges that can be added according to (a) have been added.
2. Processing T = (cid:4)K V : K1.r1 ∩ ··· ∩ Kn.rn
(a) K V can add the n intersection edges, T (cid:3)(cid:4)K V : K j .r j
(b) K V can mark T veriﬁer-processed only after (a) is done.
?(cid:2) K S(cid:5)
?(cid:2) K S(cid:5), 1 ≤ j ≤ n
ACM Transactions on Information and System Security, Vol. 9, No. 3, August 2006.
380
•
W. H. Winsborough and N. Li
4.4.5 Opponent-Side Processing. We now deﬁne the candidate update op-
erations a negotiator K S using conﬁguration G can perform on nodes for which
K S is the subject. These rules apply to nodes that are not yet marked opponent-
processed.
1. Processing T = (cid:4)K V : K .r ?(cid:2) K S(cid:5) when AckG(K .r) is trivially satisﬁed (i.e.,
K .r is not sensitive and does not reach any sensitive attribute in the delegation
credential graph)
(a) If K .r ←− K S ∈ EG, K S can add an implication edge T (cid:3)(cid:4)K V : K S
?(cid:2) K S(cid:5).
(b) If K .r ←− K1.r1 ∈ LG, K S can add an implication edge T (cid:3) (cid:4)K V :
K1.r1
?(cid:2) K S(cid:5).
(c) K S can mark T as opponent-processed if T is satisﬁed, or if (a) and (b)
are done.
2. Processing T = (cid:4)K V : K .r ?(cid:2) K S(cid:5) when AckG(K .r) is not trivially satisﬁed
(a) K S can add a control edge T (cid:3)(cid:4)K S :eAck
(b) After (a) is done and (cid:4)K S :eAck
?(cid:2) K V(cid:5), where eAck = AckG[K .r].
?(cid:2) K V(cid:5) is satisﬁed, if K S has the credential
K .r ←− K S ∈ EG, K S can add the implication edge T (cid:3)(cid:4)K V : K S
?(cid:2) K S(cid:5).
if K S has the
credential K .r ←− K1.r1 ∈ LG, K S can add the implication edge
T (cid:3)(cid:4)K V : K1.r1
(c) After (a)
is done and (cid:4)K S :eAck
?(cid:2) K V(cid:5) is satisﬁed,
?(cid:2) K S(cid:5).
(d) K S can mark T as opponent-processed if T is satisﬁed, or all of the above
steps are done.
The above processing rules defend against the backward positive- and
negative-inference attacks discussed in Section 2. For instance, if K S should
have K .r ←− K1.r1, and K V should establish the target, (cid:4)K V : K .r ?(cid:2) K S(cid:5), K S
does not mark this target processed until it has added the implication child,
(cid:4)K V : K1.r1
?(cid:2) K S(cid:5). K S will then add a control child to the latter target using
K S’s ack policy for K1.r1. Consequently, the satisfaction state of (cid:4)K V : K .r ?(cid:2) K S(cid:5)
will not become either satisﬁed or failed until the ack policy for K1.r1 has been
satisﬁed.
4.5 Safety of TTG Strategies
THEOREM 4.2. For each choice operation meeting, the requirements dis-
cussed in Section 4.4, the induced TTG strategy TTGstrat is credential–
combination hiding.
The proof is found in Appendix D.
5. SAFETY OF ACCESS-CONTROL POLICY ENFORCEMENT
In this paper, we use ack policies, but not AC policies, for protecting credentials
and their attribute-information content. Recall that the primary distinction
between AC policies and ack policies is that AC policies are deﬁned only for
resources the negotiator actually has, while ack policies can be deﬁned for an
attribute whether the negotiator has the attribute or not. This means that
when a credential’s AC policy is used during negotiation, the fact that the
ACM Transactions on Information and System Security, Vol. 9, No. 3, August 2006.
Safety in Automated Trust Negotiation
•
381
negotiator has the credential may be disclosed. By contrast, ack policies can
be used without this information leakage. We emphasize that we believe AC
policies cannot be used to safely protect the attribute information contained
in credentials according to any notion of safety along the lines discussed in
Section 3. However, the use of AC policies for protecting credentials has a
longer history [Winsborough et al. 2000] than the use of ack policies [Winsbor-
ough and Li 2002b], and may serve a complementary purpose in a system, for
instance, if the signed credential is considered more sensitive than its unsigned
content.
It is straightforward to add AC policies to our formal model of ATN for addi-
tional protection of credentials. We now discuss the deﬁciencies in prior work
of the traditional deﬁnition of safety for AC policies and present a deﬁnition
following the spirit of providing meaningful notions of safety.
The existing safety deﬁnition of AC policies is inadequate even when not con-
sidering the leaking of attribute information. The requirement that “credentials
should not be disclosed until AC policies for them are satisﬁed” is acceptable
only for ATN systems of certain kinds, i.e., those that use credentials only by
directly transmitting them. It is inadequate for ATN systems which takes ad-
vantage of the fact that credentials are structured objects, e.g., by using the
signatures to compute messages in a protocol without transmitting the signa-
tures themselves [Li et al. 2003; Holt et al. 2003].
There are two parts of the requirement that are imprecise. First, “credential
is disclosed” is undeﬁned. What does it mean? Clearly, sending the exact bit-
string of a credential should be viewed as the credential ﬂowing. What if one
does not send the exact bit-string, but sends something (presumably derived
from the bit-string) that enables everyone to verify that the credential exists?
For example, if σ is the signature, then one could send the content (but not the
signature) of the credential and θ = 2σ ; the receiver can recover the signature
easily. One may argue that, in this case, the receiver recovers the complete
credential, and thus the credential is disclosed. Now consider the case that
some value derived from the signature is sent to the opponent, enabling the
opponent to verify that the signature exists but not to recover the signature.
(Such a value is easily constructed for RSA signatures [Rivest et al. 1978].)
Whether this constitutes a disclosure of a credential is not so clear. This be-
comes even less clear in the case that one uses a zero-knowledge protocol to
convince the opponent that one holds the credential, but the opponent cannot
use the communication transcript to convince any other party of this. We be-
lieve that a suitable notion of AC-policy enforcement should not permit any
of these forms of credential disclosure to unauthorized recipients. To capture
all such forms of credential disclosure, the precise deﬁnition of “a credential
is not disclosed” should be “the same communication transcripts can be gener-
ated efﬁciently without having access to the credential.” Note that we do not
require such transcripts be generated by negotiators during trust negotiation;
we only require that there exists an algorithm that can generate such tran-
scripts efﬁciently. Since the transcripts can be generated without access to the
credential, clearly the credential is not disclosed. This is similar to the notion
of simulations and zero-knowledge proofs used in the cryptography literature.
ACM Transactions on Information and System Security, Vol. 9, No. 3, August 2006.
382
•
W. H. Winsborough and N. Li
The second part of the requirement that is imprecise is “until AC policies are
satisﬁed.” This is related to the discussion above; how are AC policy satisﬁed?
Does one have to see credential bit-strings, or is it sufﬁcient to be convinced
that the credential exists? We argue that a straightforward deﬁnition is that
“credentials are not disclosed to parties who do not satisfy the corresponding
AC policies.” The disclosure of a credential does not violate security so long
as the opponent holds the necessary credentials to satisfy the credential’s AC
policy.
To summarize, the AC safety requirement should be as follows.
Deﬁnition 5.1 (Safety of Access-Control Policies). A negotiation strategy is
AC safe if for every conﬁguration G, for every adversary M , and for every
feasible attack sequence seq, the response sequence induced from G by seq can
be efﬁciently computed without credentials whose AC policies are not satisﬁed
by M .
The notion of credentials not being disclosed is formalized here by saying that
it is not necessary to have access to the credentials to efﬁciently play the nego-
tiator’s part in the negotiation. Also note that, instead of making requirements
on the order of events, we simply require that to receive credentials governed by
an AC policy, an opponent must possess credentials satisfying that AC policy.
6. RELATED WORK
Automated trust negotiation was introduced by Winsborough et al. [2000], who
presented two negotiation strategies, an eager strategy in which negotiators
disclose each credential as soon as its access-control policy is satisﬁed, as well
as a “parsimonious” strategy in which negotiators disclose credentials only af-
ter exchanging sufﬁcient policy content to ensure that a successful outcome is
ensured. The former strategy has the problem that many irrelevant credentials
may be disclosed; the latter, that negotiators reveal implicitly, and in an uncon-
trolled way, which credentials they hold, by transmitting access-control policy
content for them. The length of negotiations in both strategies is, at most, lin-
ear in the number credentials the two parties hold. Yu et al. [2000] introduced
the quadratic “prunes” strategy, which requires negotiators to explicitly reveal
arbitrary attributes with no protection.
Yu et al. [2003] developed families of strategies called disclosure tree pro-
tocols that can interoperate in the sense that negotiators can use different
strategies within the same family. Seamons et al. [2001] and Yu and Winslett
[2003b] studied the problem of protecting contents of policies as well as creden-
tials. These previous works did not address the leaking of sensitive attribute
information.
On the aspect of system architecture for trust negotiation, Hess et al. [2002]
proposed the Trust Negotiation in TLS (TNT) protocol, which is an extension to
the SSL/TLS handshake protocol by adding trust negotiation features. Winslett
et al. [2002] introduced the TrustBuilder architecture for trust negotiation sys-
tems.
The problem of leaking attribute information was recognized by Seamons
et al. [2002] and Winsborough and Li [2002b]. Winsborough and Li [2002a,
ACM Transactions on Information and System Security, Vol. 9, No. 3, August 2006.
Safety in Automated Trust Negotiation
•
383
2002b] introduced the notion of ack policies to protect this information and
studied various inferencing attacks that can be carried out. However, precise
notion of safety was not provided in this work.
Yu and Winslett [2003a] have introduced a technique called policy migration
that seeks to make it more difﬁcult for the adversary to infer information about
a negotiators attributes based on AC policies. In the versions of credential AC
policies disclosed during ATN, the technique moves requirements from policies
governing credentials deﬁning sensitive attributes to those of other credentials
that are also required by the ATN. This approach obscures the information car-
ried in the ATN about the negotiator’s sensitive attributes, but it does not hide
it entirely. For instance, by observing multiple negotiations, an adversary can
observe that the AC policies presented for a given credential are not always the
same and then infer that the negotiator has another credential that the adver-
sary has requested. Moreover, the technique can sometimes cause negotiation
to fail when success is possible. For these reasons, it seems clear that policy
migration is not an adequate solution to the problem.
The notion of credential–combination hiding is similar to the notion of non-
interference [Goguen and Meseguer 1982], which considers a system that has
inputs and outputs of different sensitivity levels. A system can be deﬁned as
noninterference secure if low-level outputs do not depend upon high-level in-
puts. The deﬁnition for credential–combination-hiding safety says that the be-
havior the adversary can observe (i.e., low-level outputs) does not depend on
credentials proving unacknowledgeable attributes (i.e., high-level inputs). The
notion of attribute-combination hiding is similar to the notion of nondeducibil-
ity [Sutherland 1986], which requires that low-level outputs be compatible with
arbitrary high-level inputs. Our deﬁnitions deal with a system that involves
communication between the two parties and we want to ensure that one party
cannot tell the state of another party. Our notions of indistinguishable conﬁgu-
rations are also reminiscent of security deﬁnitions for cryptographic protocols.
Inference control has received a lot of attention, particularly in the context
of multilevel databases [Staddon 2003], statistical databases [Domingo-Ferrer
2002; Wang et al. 2003] and, to a lesser extent, in deductive databases [Bonatti
et al. 1995]. Most of this work focuses on limiting the information that can be
deduced from answers to multiple queries. Such schemes require that history
information be maintained, allowing multiple interactions with the same party
to be correlated, which is a very strong assumption in our context of open sys-
tems, an assumption that we do not make. As a result, our approach is quite
different.
7. CONCLUSION
Although many ATN schemes have previously been proposed, precise security