Proposition 5.1. The Î ğ‘“ protocol derived from Î CompressedMC
is correct, (ğ‘ƒğ‘…, ğ‘› âˆ’ 1)-private, (ğ‘ƒğ‘†, 0)-robust with robustness error
ğ‘–=0
,
and a client-server ğœŒ-phase protocol, with ğœŒ = âŒŠlogğ‘˜(ğ‘š)âŒ‹.
The proof is given in the full version.
Putting Everything Together. We describe our MPCitH ZK-IOP for
arithmetic and Boolean circuit in Figure 5. The protocol Î Int_ZKP is
derived directly from the parallel execution variant of Î ğœŒâˆ’ZKIOP, in-
stantiating Î ğœ
with the MPC protocol described above. Combining
ğ‘“
results from previous sections, we obtain the following theorem.
Theorem 5.2. Let ğ‘›, ğ‘š, ğ‘˜ be integers and F âŠ† G finite fields. Let ğ¶
be a circuit over F of multiplicative size ğ‘š and |G| > ğ‘š. The protocol
Î Int_ZKP satisfies completeness, soundness and (honest-verifier) zero-
knowledge as in Definition 2.4 with soundness error ğœ– = 1/ğ‘›ğœ + (1 âˆ’
1/ğ‘›ğœ) Â· ğ›¿ğ‘˜ and round complexity âŒŠlogğ‘˜(ğ‘š)âŒ‹ + 2.
From ZK-Interactive MPCitH Proof to ZK Arguments. We can com-
pile the interactive ZK proof described in Figure 5 to an interactive
argument, with standard techniques using collision-resistant hash
functions. In particular, as described [30], we can achieve better
efficiency using collision-resistant hash functions based on Merkle
trees [35].
Setting the Parameters. Notice the parameters of our zero-knowledge
argument protocol greatly depends on the size of the base field F
and extension field G, other than the compression factor ğ‘˜. In gen-
eral, for small values of ğ‘˜ we have smaller proof size, but larger
running times. In Table 2 we show the number of repetitions and
estimated proof when the base field F = F2 with ğ‘˜ = 8. Notice that
since we choose a big extension filed, G = F264, the number of rep-
etitions is the same for different circuit size, but it varies depending
on the number of parties.
6 NON-INTERACTIVE ZERO-KNOWLEDGE
ARGUMENTS
Using the Fiat-Shamir paradigm [23, 38], we can transform our
public coin interactive protocol to a corresponding non-interactive
zero-knowledge protocol. Roughly, the prover will compute the
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3029Inputs: Public circuit ğ¶ over F with ğ‘š MULT gates. Extension field G. Public input ğ‘¥. Private input ğ‘¤ for ğ’«.
Outputs: Public proof oracles (ğœ‹1, . . . , ğœ‹ğœŒ) from ğ’«. Private output ğ‘ âˆˆ {0, 1} from ğ’±.
First Oracle ğœ‹1
Prover Execute phase 1 of Î CompressedMC.
Î Int_ZKP
- Client party ğ‘ƒğ‘† executes the following for each evaluation ğ‘¡ âˆˆ [ğœ]:
(1) Generate a sharing of the witness âŸ¨ğ‘¤ğ‘¡ âŸ© $â† Fğ‘› and add âŸ¨ğ‘¤ğ‘¡ âŸ©ğ‘– to (mğ‘¡,1)ğ‘–.
(2) For each multiplication gate â„“ âˆˆ [ğ‘š]:
(a) Compute the multiplication result: ğ‘§ğ‘¡,â„“ â† ğ‘¥ğ‘¡,â„“ Â· ğ‘¦ğ‘¡,â„“ .
(b) Generate a sharing of the result âŸ¨ğ‘§ğ‘¡,â„“ âŸ© $â† Fğ‘› and add âŸ¨ğ‘§ğ‘¡,â„“ âŸ©ğ‘– to (mğ‘¡,1)ğ‘–.
(3) Send (mğ‘¡,1)ğ‘– to ğ‘ƒğ‘–.
- The server parties execute the following, also for each evaluation ğ‘¡ âˆˆ [ğœ]:
(1) Append (mğ‘¡,1)ğ‘– to viewğ‘–
(2) Compute the input shares âŸ¨ğ‘¥ğ‘¡,â„“ âŸ©ğ‘– and âŸ¨ğ‘¦ğ‘¡,â„“ âŸ©ğ‘– for each multiplication gate â„“ âˆˆ [ğ‘š] using the shares from (mğ‘¡,1)ğ‘–.
Set (ğœ‹1)ğ‘¡,ğ‘– = view1
ğ‘¡,ğ‘–.
ğ‘¡,1.
Interactive Protocolâ€”First Round.
Verifier Sample a random challenge ğ‘…
Prover Continue the ğœ executions of Î CompressedMC by running ğ‘ƒğ‘† and the servers {ğ‘ƒğ‘– } on input ğ‘… as follows:
$â† G and send it to ğ’« as the output of RandomCoin.
(1) Each server ğ‘ƒğ‘– lifts âŸ¨ğ‘¥ğ‘¡,â„“ âŸ©ğ‘–, âŸ¨ğ‘¦ğ‘¡,â„“ âŸ©ğ‘–, âŸ¨ğ‘§ğ‘¡,â„“ âŸ©ğ‘– from F to G.
(2) Each server computes their share of âŸ¨x0
ğ‘¡ âŸ© and âŸ¨ğ‘§0
ğ‘¡ âŸ©, âŸ¨y0
ğ‘¡)â„“ âŸ© = âŸ¨ğ‘¦ğ‘¡,â„“ âŸ©, and âŸ¨ğ‘§0
âŸ¨(x0
ğ‘¡)â„“ âŸ© = ğ‘…â„“âˆ’1âŸ¨ğ‘¥ğ‘¡,â„“ âŸ©, âŸ¨(y0
ğ‘¡ âŸ© =â„“âˆˆ[ğ‘š] ğ‘…â„“âˆ’1âŸ¨ğ‘§ğ‘¡,â„“ âŸ©.
ğ‘¡ âŸ© such that:
Interactive Protocolâ€”Compression Rounds. For each compression round ğ‘— âˆˆ [âŒŠlogğ‘˜ (ğ‘š)âŒ‹]:
Prover Before creating the next oracle, emulate the following computation.
ğ‘¡,1, . . . , ağ‘—
ğ‘¡ â†’ (ağ‘—
ğ‘¡,ğ‘˜) and yğ‘—âˆ’1
- For the client ğ‘ƒğ‘†, for each ğ‘¡ âˆˆ [ğœ]:
(1) Parse xğ‘—âˆ’1
(2) For each ğ‘¢ âˆˆ [ğ‘˜ âˆ’ 1]: Compute inner-products: ğ‘ ğ‘—
(3) Compute last inner-product: ğ‘ ğ‘—
(4) Construct f ğ‘—
(5) For each ğ‘¢ âˆˆ [ğ‘˜ + 1, 2ğ‘˜ âˆ’ 1] if ğ‘— â‰  âŒŠlogğ‘˜ (ğ‘š)âŒ‹, or ğ‘¢ âˆˆ [ğ‘˜ + 1, 2ğ‘˜ + 1] otherwise: Compute inner-product â„ ğ‘—
ğ‘¡ âˆˆ (G[ğ‘‹ ])ğ‘š/ğ‘˜ as in Î Compress if ğ‘— â‰  âŒŠlogğ‘˜ (ğ‘š)âŒ‹, or as in Î CompressRand otherwise.
ğ‘¡ âˆ’ğ‘¢âˆˆ[ğ‘˜âˆ’1] ğ‘ ğ‘—
ğ‘¡,ğ‘˜).
ğ‘¡,ğ‘¢ âˆ— bğ‘—
ğ‘¡,ğ‘¢ â† ağ‘—
ğ‘¡,ğ‘¢.
ğ‘¡,ğ‘¢, generate sharing âŸ¨ğ‘ ğ‘—
ğ‘¡,ğ‘¢ â† ğ‘§ ğ‘—âˆ’1
ğ‘¡ â†’ (bğ‘—
ğ‘¡,1, . . . , bğ‘—
ğ‘¡,ğ‘¢âŸ© $â† Gğ‘› and add âŸ¨ğ‘ ğ‘—
ğ‘¡ , gğ‘—
ğ‘¡,ğ‘¢âŸ©ğ‘– to (mğ‘¡,ğ‘—+1)ğ‘–.
ğ‘¡ (ğ‘¢) = f ğ‘—
ğ‘¡ (ğ‘¢) âˆ— gğ‘—
ğ‘¡ (ğ‘¢), generate
sharing âŸ¨â„ ğ‘—
ğ‘¡ (ğ‘¢)âŸ© $â† Gğ‘› and add âŸ¨â„ ğ‘—
ğ‘¡ (ğ‘¢)âŸ©ğ‘– to (mğ‘¡,ğ‘—+1)ğ‘–.
(6) Send (mğ‘¡,ğ‘—+1)ğ‘– to ğ‘ƒğ‘–.
- For each server party ğ‘ƒğ‘–, for each evaluation ğ‘¡ âˆˆ [ğœ]:
(1) Append (mğ‘¡,ğ‘—+1)ğ‘– to viewğ‘—+1
Set (ğœ‹ ğ‘—+1)ğ‘¡,ğ‘– = viewğ‘—+1
ğ‘¡,ğ‘– .
ğ‘¡,ğ‘– . and compute âŸ¨f ğ‘—
ğ‘¡ âŸ©ğ‘–, âŸ¨gğ‘—
ğ‘¡ âŸ©ğ‘–, âŸ¨â„ ğ‘—
ğ‘¡ âŸ©ğ‘– using the shares from (mğ‘¡,ğ‘—+1)ğ‘–.
Verifier Sample a random challenge ğ‘  ğ‘—
Prover Continue the ğœ executions of Î CompressedMC by running ğ‘ƒğ‘† and the servers {ğ‘ƒğ‘– } on input ğ‘  ğ‘— as follows:
ğ‘¡ âŸ©, âŸ¨yğ‘—
$â† G \ [ğ‘˜] and send it to ğ’« as the output of RandomCoin.
ğ‘¡ (ğ‘  ğ‘—)âŸ© and labels them as âŸ¨xğ‘—
ğ‘¡ (ğ‘  ğ‘—)âŸ© and âŸ¨â„ ğ‘—
(1) Each server computes their own share of âŸ¨f ğ‘—
(2) The sender ğ‘ƒğ‘† computes xğ‘—
ğ‘¡ (ğ‘  ğ‘—)âŸ©, âŸ¨gğ‘—
ğ‘¡ in the same way.
ğ‘¡ and ğ‘§ ğ‘—
ğ‘¡ , yğ‘—
ğ‘¡ âŸ© and âŸ¨ğ‘§ ğ‘—
ğ‘¡ âŸ©.
Interactive Protocolâ€”Final Rounds.
Prover After computation of the final compressed tuple, for each ğ‘¡ âˆˆ [ğœ] the server parties {ğ‘ƒğ‘– } each send their shares âŸ¨f ğ‘—
ğ‘¡ (ğ‘  ğ‘—)âŸ©ğ‘–,
with ğ‘— = âŒŠlogğ‘˜ (ğ‘š)âŒ‹, to ğ‘ƒğ‘…, together with their shares âŸ¨ğ‘œâŸ©ğ‘– of the values of the output wires of ğ¶; all of these form viewğ‘¡,ğ‘…, which ğ’« sends to ğ’±
in full.
ğ‘¡ (ğ‘  ğ‘—), with ğ‘— = âŒŠlogğ‘˜ (ğ‘š)âŒ‹, and check
that the output of the circuit is valid, i.e. thatğ‘– âŸ¨ğ‘œâŸ©ğ‘– = 1. If one of these fails, reject.
Verifier Upon receiving viewğ‘¡,ğ‘…, for each ğ‘¡ âˆˆ [ğœ], check that the tuple is correct, i.e. that â„ ğ‘—
Oracle query The verifier picks a subset ğ‘„ğ‘¡ âŠ‚ [ğ‘›] of size ğ‘› âˆ’ 1 uniformly at random for each ğ‘¡ âˆˆ [ğœ] and queries {ğ‘„ğ‘¡ }.
Verifier Upon receiving {viewğ‘¡,ğ‘ }ğ‘âˆˆğ‘„ğ‘¡ for each ğ‘¡ âˆˆ [ğœ] (where viewğ‘¡,ğ‘– = view1
ğ‘¡,ğ‘–), recompute the operations of each opened server ğ‘ƒğ‘
ğ‘¡,ğ‘– âˆ¥ . . . âˆ¥viewğœŒ
ğ‘¡ (ğ‘  ğ‘—)âŸ©ğ‘–, âŸ¨gğ‘—
ğ‘¡ (ğ‘  ğ‘—)âŸ©ğ‘–, âŸ¨â„ ğ‘—
ğ‘¡ (ğ‘  ğ‘—) = f ğ‘—
ğ‘¡ (ğ‘  ğ‘—) âˆ— gğ‘—
to check for inconsistencies with viewğ‘¡,ğ‘…. If an inconsistency is found, reject. If not, accept.
Figure 5: Interactive (Zero-knowledge) proof (of knowledge) protocol
first-round message as in the interactive variant and then continue
the protocol by setting the verifierâ€™s next message to be the output
of a hash function ğ» modelled as a random oracle on input the
transcript of previous messages.
While the zero-knowledge property directly follows from the
corresponding property of the interactive variant, soundness re-
quires more careful analysis. In [9], the authors prove that for IOP
systems the soundness of the transformed non-interactive protocol
can be derived form the soundness of the IOP verifier against â€œstate
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3030Circuit size
103
104
105
106
(ğ‘› = 16, ğœ = 11)
4.9
18.5
143
1382
(ğ‘› = 64, ğœ = 7)
3.5
11.7
91
879.5
(ğ‘› = 128, ğœ = 6)
2.5
10
78
753.8
Table 2: Proof size (in kB) needed for interactive proof soundness of
2âˆ’40 with compression ğ‘˜ = 8 and extension field G = F264, depending
on number ğ‘› of parties, number ğœ of repetitions and circuit size.
restoration attacksâ€. This section presents a better estimation of
the soundness of our non-interactive protocol.
6.1 Soundness with independent challenges
This first analysis applies to the non-optimised variant of the
protocol where each of the ğœ parallel executions receives a random
challenge from RandomCoin, independently of the other execu-
tions. When producing a non-interactive proof, before proceeding
to the next round, the prover can re-randomize the commitments
they make to the random oracle in order to sample different public
coins for the checks. Here the best cheating strategy is to attack
different executions at each round of interaction so that, by the end
of the protocol, all executions will cause the verifier to accept.
Assuming that the final ZK protocol has ğ‘Ÿ rounds of interaction
between prover ğ’« and verifier ğ’±, we let ğ‘‹ğ‘–, for ğ‘– âˆˆ [ğ‘Ÿ], be the
random variable of the maximum number (out of the remaining
incorrect executions) of â€œgoodâ€ challenges received by the prover
during all its queries to the ğ‘–-th random oracle. (By â€œgoodâ€ chal-
lenge we mean one which corrects and â€œhidesâ€ any cheating in that
execution.)
As demonstrated in previous work on this kind of non-interactive
protocol [3, 10], the number of â€œgoodâ€ challenges received for each
call to the random oracle follows a binomial distribution with pa-
rameters (ğœğ‘–, ğ‘ğ‘–), where ğœğ‘– denotes the number of parallel executions
for which this challenge is â€œgoodâ€ and ğ‘ğ‘– denotes the probability
that a random challenge is â€œgoodâ€ for one execution.
The proverâ€™s goal is to receive a â€œgoodâ€ challenge in one of
the interaction rounds for each of the ğœ parallel executions. This
means that the soundness error is the probability that this strategy
succeeds, namely Pr(cid:2)ğ‘Ÿ
ğ‘–=1 ğ‘‹ğ‘– = ğœ(cid:3) .
Specifically to our protocol Î Int_ZKP, we identify the following
interactions between the prover and the verifier in the interactive
variant:
with challenge ğ‘… âˆˆ G.
(1) ğ’« commits to the injections of the ğ‘š values; ğ’± responds
(2) For each ğ‘— âˆˆ [âŒŠlogğ‘˜ ğ‘šâŒ‹]: the prover commits to the ğ‘ ğ‘—
ğ‘– in-
jections (i.e. to the values ğ‘ƒğ‘† sends to the server parties ğ‘ƒğ‘–),
for ğ‘– âˆˆ [ğ‘˜ âˆ’ 1], and the âŸ¨â„(ğ‘–)âŸ© injections (in Î Compress), for
ğ‘– âˆˆ [ğ‘˜ + 1, 2ğ‘˜ âˆ’ 1]; ğ’± responds with challenge ğ‘  ğ‘— âˆˆ G.
(3) At step ğ‘— = âŒŠlogğ‘˜ ğ‘šâŒ‹, the prover also commits to the addi-
tional points required by Î CompressRand.
In the non-interactive setting, we therefore have the following
probabilities of obtaining a â€œgoodâ€ challenge correctly for each of
the interaction rounds:
First round. Probability that ğ‘… makes the tuple correct: ğ‘ğ‘… = ğ‘šâˆ’1
|G| .
Intermediary rounds. For ğ‘— âˆˆ [âŒŠlogğ‘˜ ğ‘šâŒ‹ âˆ’ 1] (last round is spe-
cial as it has polynomials of different degrees), probability
that the Schwartzâ€“Zippel test fails to catch a non-zero poly-
2(ğ‘˜âˆ’1)
nomial, i.e. Î Compress outputs a correct tuple: ğ‘int =
|G|âˆ’ğ‘˜
Final round. Probability that the last Schwartzâ€“Zippel test fails,
2ğ‘˜|G|âˆ’ğ‘˜ .
The soundness of the non-interactive protocol, with the inde-
i.e. that Î CompressRand outputs a correct tuple: ğ‘fin =
pendent challenges variant, is therefore given by
(cid:20)
ğ‘Š +âˆ‘ï¸âŒŠlogğ‘˜ ğ‘šâŒ‹âˆ’1
ğ‘—=1
(cid:21)
ğ‘‹ ğ‘— + ğ‘Œ + ğ‘ = ğœ
,
ğœ–indep
ni
= Pr
where
ğ‘Š = max
ğ‘1
ğ‘‹ ğ‘— = max
ğ‘ ğ‘—,2
ğ‘Œ = max
ğ‘3
ğ‘ = max
ğ‘4
{ğ‘Šğ‘1 }
{ğ‘‹ğ‘ ğ‘—,2 }
{ğ‘Œğ‘3 }
{ğ‘ğ‘4 }
ğ‘Šğ‘1 âˆ¼ ğ”… (ğœ, ğ‘ğ‘…)
ğ‘‹ ğ‘—,ğ‘2 âˆ¼ ğ”…
(cid:17)
(cid:16)ğœ âˆ’ ğ‘Š âˆ’âˆ‘ï¸ğ‘—âˆ’1
(cid:18)
ğœ âˆ’ ğ‘Š âˆ’âˆ‘ï¸âŒŠlogğ‘˜ ğ‘šâŒ‹âˆ’1
(cid:18)
ğœ âˆ’ ğ‘Š âˆ’âˆ‘ï¸âŒŠlogğ‘˜ ğ‘šâŒ‹âˆ’1
ğ‘–=1 ğ‘‹ğ‘–, ğ‘int
ğ‘–=1
ğ‘–=1
ğ‘Œğ‘3 âˆ¼ ğ”…
ğ‘ğ‘4 âˆ¼ ğ”…
(cid:19)
(cid:19)
1
ğ‘
ğ‘‹ğ‘–, ğ‘fin
ğ‘‹ğ‘– âˆ’ ğ‘Œ ,
with ğ‘ğ‘– denoting the queries to the ğ‘–-th random oracle and ğ”…
denoting the binomial mass function.
6.2 Soundness with identical challenges
The optimised protocol presented in Section 5, where the chal-
lenges output by RandomCoin are shared across the ğœ executions,
has a different distribution of â€œgoodâ€ challenges.
Considering the first round, a malicious prover can commit to
ğœ cheating strategies each represented by the values of {mğ‘¡}ğ‘¡ âˆˆ[ğœ];
these are namely the sharings of the witness ğ‘¤ğ‘¡ and of each multi-
plication output ğ‘§ğ‘¡,â„“, for â„“ âˆˆ [ğ‘š]. Using the notation of the proof
of Lemma 4.1, each of these strategies defines a polynomial ğ» (ğ‘¡)
whose zeroes define a â€œgoodâ€ first-round challenge. Indeed, recall
from Lemma 4.1 that a challenge ğ‘… âˆˆ G corrects a set of incorrect
multiplication triples if and only if ğ» (ğ‘¡)(ğ‘…) = 0 when ğ» (ğ‘¡) is not
the zero polynomial (due to the error in at least one of the triples).
Denote by â„‹(ğ‘¡) the set {ğ‘Ÿ âˆˆ G : ğ» (ğ‘¡)(ğ‘Ÿ) = 0} of â€œgoodâ€ challenges.
As the first round challenge ğ‘… is shared across executions, if the
malicious prover wishes to correct ğœ1 out of ğœ executions, then the
probability of this happening is highest when at least ğœ1 of the zero
sets â„‹(ğ‘¡) are identical. In this case, the probability that ğ‘… is a â€œgoodâ€
challenge for these ğœ1 executions is exactly ğ‘šâˆ’1
|G| , independently of
ğœ1. This implies that, here, the distribution ğ‘Š of ğœ–indep
can take
any value between 1 and ğœ with this probability, depending on the
proverâ€™s strategy, and is 0 otherwise.
Following the same reasoning, we have that the probability of
sampling a â€œgoodâ€ challenge for ğœâ€² executions in the intermedi-
ary rounds or the final rounds can be as high as 2(ğ‘˜âˆ’1)
2ğ‘˜|G|âˆ’ğ‘˜ ,
respectively, when the prover cheats identically across these ğœâ€²
executions. Indeed, even in the final round when the â„ polynomial
is randomised, since the prover also controls Î Rand,the sets of zeros
can still be made identical. Similarly, this implies that the ğ‘‹ ğ‘— and ğ‘Œ
distributions can here also take any value between 1 and ğœ with the
above fixed probabilities.
|G|âˆ’ğ‘˜ or
ni
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3031ni
Only the ğ‘ distribution of ğœ–indep
remains the same due to the
independent sampling of the ğœ challenges for the opening of the
views of ğ‘› âˆ’ 1 parties in each execution. Putting this all together