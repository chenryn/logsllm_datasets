 ﬂ∞
 ﬂ∞
 ﬂ∞
 ﬂ∞
 ﬂ∞


ﬂ∞
‡£àEEJ
trace equivalence.
THEOREM 2. Let     and     be two
concrete processes. They are in trace equivalence if, and only if,
they are in symbolic trace equivalence.
Now, since the symbolic transition system is Ô¨Ånite, we only have
to show that symbolic trace equivalence is decidable. However,
for processes with non-trivial branchings, the sets of constraints in
DeÔ¨Ånition 8 are not reduced to singletons: we have to consider sets
(disjunctions) of contraints.
EXAMPLE 6. Actually, the system  (see Example 5) is one of
the constraint systems obtained by applying our symbolic rules on
 ‡¢ù‡¢ù and considering JH  E    KJ =N &. The
other one (for the same sequence JH) is          where
   ,
‡¢´     √û =N &  =A? FK>, and
‡¢´    FH =@A? 
‡¢ß FK>.
For the same sequence JH, similar constraint systems, denoted ﬂ∞
 , can be derived for the process  ﬂ∞ . The oc-
and ﬂ∞
currences of  will be replaced by ﬂ∞.
To establish symbolic trace equivalence between the processes
   and  ﬂ∞ , we will need in particular
to check that   ‡£àEEJ ﬂ∞
4. FRAMEWORK
ﬂ∞
 .
Our procedure for deciding symbolic equivalence between sets
of constraint systems requires a slightly different setting from the
one introduced in Section 3. Therefore, we adapt and generalize
In particular, our algorithm (see
several notions and deÔ¨Ånitions.
Section 5) considers constructor terms only.
In this section, we
show how to get rid of destructor symbols and of some recipes, and
we prove that our new notion of symbolic equivalence coincides
with the one introduced in Section 3 on sets of initial constraint
systems.
4.1 Frames
The purpose of a frame is to record the sequence of messages (or
terms in a symbolic execution) that have been sent by the partici-
pants of the protocol. We extend this notion to record some addi-
tional information on attacker‚Äôs deductions. Typically the element
I@A?     records that, using a decryption with the recipe ,
on top of a recipe , allows one to get  (at stage ). After record-
ing this information in the frame, we may forbid the attacker to use
a decryption on top of , forcing him to use this ‚Äúdirect access‚Äù
from the frame.
DEFINITION 9
(FRAME). A (ground) frame  is a sequence
              where:
‡¢´       are (ground) recipes;
‡¢´       are integers; and
‡¢´       are (ground) constructor terms.
The domain of the frame  is @   ‡¢µ      . It
must be equal to =N      =N  for some  that is called the size
of . Such a frame  deÔ¨Ånes a substitution on @.
Ô¨Ä
In order to restrict the set of recipes we have to work with, we
deÔ¨Åne the following set H:
H 
 ‡¢† 
C      ‡¢† IJ for some C ‡¢† ‡°ì
 6F ‡¢ß‡¢† ‡°ì
where 6F denotes the root symbol of .
For instance, I@A?IA?=N  =N  =N   is not in H. When
checking static equivalence (resp. symbolic equivalence) between
frames (constraint systems) that only contain constructor terms, we
can restrict ourselves to consider only recipes that are in H. Thus,
in the remainder, we will only consider recipes in H.
4.2 Constraint systems
We slightly generalize the constraint systems introduced in Sec-
tion 3. Let us explain how and why. According to Section 3, we
need to decide symbolic equivalence of sets (disjunctions) of con-
straint systems, e.g.   ‡£à ﬂ∞
ﬂ∞
 . We cannot split these
sets and consider instead sets of pairs, because the solutions of, say,
 and ﬂ∞
 might be covered by both ﬂ∞
  and, conversely, some so-
 might correspond to solutions of  . Now, if we wish
lutions of ﬂ∞
to apply a transformation rule, to one of the component, say ,
our choice must be consistent with the transformation performed
on the other components  ﬂ∞
 . For instance if we guess that a
key is deducible in  using a recipe , we must consistently use 
in the constraints ﬂ∞
 , and in turn in  . In summary, we need
to make this choice for the whole pair of sets. Now, if the key is
assumed to be non-deducible in , this must also be recorded in
the other components. In short, we need to split the solutions into
disjoint sets for every component. This yields negative constraints,
typically a constraint that states that a key is not deducible.
ﬂ∞
ﬂ∞
In summary, we extend the constraints, adding some negative
information.
DEFINITION 10
(CONSTRAINT SYSTEM). It is either  or a
tuple     , where:
 
3.   V
4.  V
5. , V
 ﬂ∞
symbols.
 ‡¢ò   W
 ‡¢≥V
‡¢ß ﬂ∞
  ‡¢≥V
 ‡¢≥V
‡¢ß  ‡¢¥W
 
terms    and  are constructor terms.
 
,  ﬂ∞
‡¢ß B where
 ﬂ∞
,  are recipes in H and B are constructor
 6F
1.  is a frame, whose size is some ;
2.  is a sequence  
       
  where
‡¢´       are distinct
second-order variables,
      are constructor terms, and we have that
 ‡£ò  ‡£ò    ‡£ò  ‡£ò .
‡¢´ for every     in , L=HI  ‡£ÆS
  L=HI ;
‡¢ß  where the
 
 ‡¢ò
  ‡¢ß   where   
are constructor terms and  ‡£ò  ‡£ò .
In Section 2, we deÔ¨Åne L=HI  as the set of all Ô¨Årst order vari-
ables that occur in . With this extended deÔ¨Ånition of a constraint
system, the set L=HI  will denote the free variables that occur
in , i.e. those that do not occur explicitly under a forall quantiÔ¨Å-
cation.
In order to deÔ¨Åne the notion of solution for such a constraint sys-
tem, we have Ô¨Årst to give the semantics of the formulas , and .
The formulas , and  are logic formulas built upon elemen-
tary formulas using classical connectives. The semantics for the
elementary formulas are given below and is extended as expected
to general formulas. Let  be a substitution mapping L=HI  
to ground recipes, and  be a substitution mapping L=HI  to
ground constructor terms. We have that:
‡¢´    ‡¢ß   iff ‡¢ë ‡¢ß ‡¢ë for any ground recipe  ‡¢† H
with F=H= ‡£Æ =N      =N ;
‡¢ß , iff  ‡¢ß ;
‡¢´   
‡¢´   
   (resp.   
‡¢ß  ) iff     (resp.
‡¢ß B iff 6F ‡¢ß B.
 ‡¢ß  );
‡¢´   6F
DEFINITION 11. A solution of       , con-
sists of a substitution  mapping L=HI  to ground constructor
terms and a substitution  mapping L=HI   to ground recipes
in H, such that:
1. for every  
and F=H= ‡£Æ =N      =N ;
  in , we have that ‡¢ë  ‡¢ë
2.   , ‡¢≥  and   .
We denote by 5 the set of solutions of . By convention,
5  ‡¢ù.
The structure of a system       , is given by
,   ‡¢Ø  
  ‡¢† , and   ‡¢Ø     ‡¢† . Two con-
straint systems  and ﬂ∞ have the same structure if their underlying
structure are equal.
For this generalized notion of constraint systems, we can deÔ¨Åne
the notion of symbolic equivalence accordingly.
DEFINITION 12. Let  and ﬂ∞ be two sets of constraint sys-
tems having the same structure. We have that  ‡£à ﬂ∞ if for all
 ‡¢† , for all   ‡¢† 5, there exists ﬂ∞ ‡¢† ﬂ∞ and a sub-
stitution ﬂ∞ such that ﬂ∞  ‡¢† 5ﬂ∞ and ‡¢ë √ü ﬂ∞ﬂ∞‡¢ë where
      ,, and ﬂ∞  ﬂ∞ ﬂ∞ ﬂ∞ ﬂ∞
 ,ﬂ∞ (and
conversely).
Note also that given an initial constraint system     
that may contain some destructors, we can transform it into an
‚Äúequivalent‚Äù constraint system       , (without
destructors) in the sense that:
‡¢´ for every   ‡¢† 5EEJ with recipes in H, there exists
  ‡¢† 5 such that ‡¢ë  ‡¢ë; and
‡¢´ for every   ‡¢† 5, there exists   ‡¢† 5EEJ
such that ‡¢ë  ‡¢ë.
Roughly, the transformation consists in guessing the possible re-
ductions, in the spirit of [13]. We write 6H to denote the result
of applying the transformation to .
EXAMPLE 7. Going back to the initial constraint system 
(resp.  ) described in Example 5 (resp. Example 6), the constraint
system 6H is obtained from  by applying the substitution
 7‡¢ê =A?ﬂ∞ FK>  (and normalizing the re-
sult) whereas 6H  is obtained from   by replacing its disequa-
tion with ‡¢òﬂ∞  
‡¢ß =A?ﬂ∞ FK> FK>. Note that in
both cases, we get rid of all the destructors.
PROPOSITION 1. Let       , ﬂ∞  ﬂ∞
‡°Å
    ﬂ∞
be two Ô¨Ånite sets of initial constraint systems. We have that:
 ‡¢† 
ﬂ∞  6H ‡¢Ø  ‡¢†  ‡£à 6Hﬂ∞
 ‡£àEEJ 
 ‡¢Ø ﬂ∞
ﬂ∞
5. ALGORITHM
The main result of this section is a decision procedure for sym-
bolic equivalence between sets of constraint systems obtained by
applying our transformation 6H on sets of initial constraint sys-
tems.
THEOREM 3. Given two sets , ﬂ∞ of initial constraint systems,
it is decidable whether 6H ‡¢Ø  ‡¢†  ‡£à 6Hﬂ∞ ‡¢Ø ﬂ∞ ‡¢† ﬂ∞.
Our decision algorithm works by rewriting pairs of sets of con-
straint systems, until a trivial failure or a trivial success is found.
These rules are branching: they rewrite a pair of sets of constraint
systems into two pairs of sets of constraint systems. Transform-
ing the pairs of constraints therefore builds a binary tree. Termi-
nation requires to follow a particular strategy that is explained in
Section 5.3. The transformation rules are sound: if all leaves are
success leaves, then the original pair of sets of constraint systems
is equivalent. They are Ô¨Ånally complete: if the two original sets
of constraint systems are equivalent then all the leaves are success
leaves.
5.1 Transformation rules
The transformation rules are displayed in Figure 3 for a single