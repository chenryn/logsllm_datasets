988,216,830
1,152,751,967
1,726,737,312
2,132,197,567
71.7%
64.84%
65.8%
71.28%
45.1%
41.6%
4.55
7.28
6.84
7.89
5.11
6.93
Latency (ms)
680
623
812
726
456.4
367.5
856
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:19:59 UTC from IEEE Xplore.  Restrictions apply. 
Microbenchmarks. Microbenchmarking of the faster pro-
tocol can be seen in Figure 4. In order to understand this,
see Figure 5 for a description of the different elements in
the implementation. The run_BTG thread generates multi-
plication (Beaver) triples. Each triple is generated by ﬁrst
generating two random sharings and then running a semi-
honest multiplication. After two arrays of triples are prepared
(since we use buckets of size B = 2), they are veriﬁed using
the _verifyAll_shuffleindices procedure; this pro-
cedure carries out shufﬂing and veriﬁcation. The second thread
runs MPC computation to compute the circuit, followed by
verifying all of the multiplications in the verifyOutput2
procedure.
V. THE COMBINATORICS OF CUT-AND-CHOOSE
In the previous sections, we have seen that tight combinato-
rial analyses are crucial for practical performance. As pointed
out in [11], the combinatorial analysis from [6] mandates
a bucket-size of B = 4 for 220 triples and security level
−40. In [11], a tighter combinatorial analysis enabled
s = 2
them to obtain the same level of security while reducing the
bucket-size from B = 4 to B = 3. Utilizing a different
method, we were further able to reduce the bucket size to
B = 2. (Combinatorics also played an important role in
achieving a cache-efﬁcient shufﬂe and an on-demand version
of the protocol.) With this understanding of the importance of
combinatorics to cut-and-choose, in this section we ask some
combinatorial questions that are of independent interest for
cut-and-choose protocols.
A. The Potential of Different-Sized Buckets
We begin by studying whether the use of different-sized
buckets can help to increase security. Since our Game1 (from
Section III-A) is speciﬁcally designed for the case where all
buckets are of the same size, we go back to the more general
game of [11] and [6] and redeﬁne it so that buckets may have
different sizes. Intuitively, since the adversary does not know
in advance how many bad balls to choose so that there will
be only fully bad buckets, using buckets of different sizes
makes it more difﬁcult for him to succeed in cheating. If this is
indeed the case, then the winning probability of the adversary
can be further decreased, and it may be possible to generate
less triples to start with, further improving efﬁciency. In [11,
Theorem 5.3] it was shown that the optimal strategy for the
adversary is to make the number of bad balls equal to the size
of a single bucket. In this section, we show that even when the
buckets sizes are different, the best strategy for the adversary
Fig. 5. Architecture of implementation
B. Experimental Results
We ran our implementations on a cluster of three mid-
level servers connected by a 10Gbps LAN. Each server has
two Intel Xeon E5-2650 v3 2.3GHz CPUs with a total of
20 cores. The results appear in Table II. Observe that each of
the protocol improvements presented here provides a dramatic
improvement:
• Section III-A: Replacing the naive Fisher-Yates shufﬂe on
an array of size 220 with our cache-efﬁcient shufﬂe yields
an increase of about 50% in throughput;
• Section III-C: Reducing the communication (in addition
to the cache-efﬁcient shufﬂe) by reducing the bucket-size
from B = 3 to B = 2 and randomly choosing triples to
verify the circuit multiplications yields a further increase
of about 30%. (This is as expected since the reduction in
communication is exactly 30%.)
• Section III-D: Replacing the use of SHA256 with the
increase of
GMAC computations yielded an additional
over 15%.
Our best protocol version has a throughput of about 2.3 times
that of baseline version. This result unequivocally demon-
strates that it is possible today to achieve secure computation
with malicious adversaries at rates of well over 1-billion
gates per second (using mid-level servers).
It is highly informative to also consider the results of the
online-only experiments (where triples are prepared previously
in an ofﬂine phase). As expected, the protocol version with
bucket-size B = 3 is better in the online phase since no
random choice of triples is needed. The throughput of the best
version exceeds 2 billion AND gates per second. Importantly,
latency is also signiﬁcantly reduced to 367.5ms; this can be
important in some applications.
Fig. 4. Microbenchmarking of best protocol variant, using the CxxProf C++ proﬁler (run on a local host)
857
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:19:59 UTC from IEEE Xplore.  Restrictions apply. 
is to make the number of bad balls equal to the size of the
smallest bucket. We then use this fact to show that given any
set of bucket sizes, changing the sizes so that the bucket sizes
of any two buckets differ by at most 1, does not improve the
probability that the adversary wins. This makes sense since
the adversary’s best strategy is to make the number of bad
balls equal the size of the smallest bucket, and its hope is
that the bad balls will fall into such a bucket. By reducing
the gap between buckets (by moving balls from larger buckets
to smaller ones) we actually reduce the number of buckets of
the smallest size, thereby reducing the probability that all bad
balls will be in a bucket of minimal size.
We deﬁne a combinatorial game with buckets of different
sizes as follows. Let (cid:2)B = {B1, . . . , BN} denote the multiset
of bucket sizes where Bi is the size of the ith bucket. As
(cid:10)N
C balls are opened before dividing the balls into buckets, it
follows that the overall number of balls generated is M =
Game4(A, N, (cid:2)B, C):
1) The adversary A prepares M balls. Each ball can be
2) C random balls are chosen and opened. If one of the C
balls is bad then output 0. Otherwise, the game proceeds
to the next step.
N buckets of sizes (cid:2)B = {B1, . . . , BN}.
4) The output of the game is 1 if and only if there exists
a bucket Bi that is fully bad, and all other buckets are
either fully bad or fully good.
i=1 Bi balls are randomly thrown into
either bad or good.
3) The remaining
i=1 Bi + C.
(cid:10)N
(cid:10)
For our analysis we need some more notation. Let Bmin
be the minimal bucket size. We use [N ] to denote the set
{1, . . . , N}. Let S ⊆ [N ] be a subset of bucket indices, and let
{i|i∈S} Bi be the total number of balls in the buckets
tS =
indexed by S. Finally, let n(t) = |{S ⊆ [N ] | tS = t}| be the
number of different subsets of buckets such that the number
of balls in all buckets in the subset equal exactly t.
We start by computing the winning probability of the
adversary. First, we prove that a necessary and sufﬁcient
condition for A having any chance to win in the game, is
that n(t) > 0.
Claim 5.1: Let At be an adversary who chooses t bad
balls. Then, Pr[Game4(At, N, (cid:2)B, C) = 1] > 0 if and only
if n(t) > 0.
Proof: If n(t) = 0 then there is no subset of buckets
which contain exactly t balls. Thus, every permutation of the
balls will result in the existence of a mixed bucket containing
good and bad balls, and the output of the game will be 0
with probability 1. In contrast, if n(t) > 0 then there exists a
subset S ⊆ (cid:2)B such that tS = t and therefore with non-zero
probability, the bad balls will fall only in the buckets of S,
and the game’s output will be 1.
Intuitively, for A to win, the bad balls must ﬁll some subset
(cid:2)
of buckets (since otherwise there will be a bucket with good
and bad balls). Since there are n(t) such subsets, and there
ways to choose t balls out of M balls, it follows that
are
the winning probability of the adversary is n(t)
as stated in
(M
t )
the next lemma.
(cid:3)
M
t
M
t
n(t)(cid:2)
(cid:3) .
(cid:2)
(cid:3)
Lemma 5.2: For every adversary At who chooses t bad balls
it holds that
Pr[Game4(At, N, (cid:2)B, C) = 1] =
M
C
(cid:3)
(cid:2)
, since there are
M−t
C
Proof: First, the probability that A does not lose when
C balls are opened is (M−t
C )
ways to
(M
C )
choose C balls overall, and
ways to choose C good
balls. Then, there are (M − C)! ways to permute the balls,
from which only n(t)·t!·(M−C−t)! will result in A winning
the game. This holds since n(t) equals the number of subsets
of buckets which contain exactly t balls, there are t! ways to
permute the bad balls inside the buckets in such a subset and
there are (M − C − t)! ways to permute the remaining balls.
Therefore, we obtain that
Pr[Game4(At, N, (cid:2)B, C) = 1]
(cid:2)
M−t
C
M
C
(cid:3)
(cid:3) · n(t) · t!(M − C − t)!
(cid:2)
=
(M − t)!
= n(t) ·
= n(t) · t!(M − t)!
(M − C)!
· C!(M − C)!
C!(M − t − C)!
n(t)(cid:2)
(cid:3)
M !
=
M !
M
t
· t!(M − C − t)!
(M − C)!
The next
theorem proves that
the best strategy for the
adversary is to corrupt a single bucket of minimal size. The
intuition behind this, is that in order for a subset of buckets
to be ﬁlled with t bad balls, the smallest bucket in this subset
must be ﬁlled with bad balls. Thus, it is better for the adversary
to choose bad balls for this bucket only, instead for the entire
subset.
Theorem 5.3: If C ≥ Bmin then for every S ⊆ [N ], for
every adversary AtS who chooses tS bad balls and for every
adversary ABmin who chooses Bmin bad balls, it holds that
Pr[Game4(AtS
, N, (cid:2)B, C) = 1]
≤ Pr[Game4(ABmin
, N, (cid:2)B, C) = 1].
We begin by proving a simple property of n(t) that will be
used later in the proof of Theorem 5.3.
every 0 < t < M − C it holds that n(t) = n(M − C − t).
Claim 5.4: For every M, C as deﬁned in Game4 and for
Proof: This follows directly from the deﬁnition. Specif-
ically, for every subset of buckets S such that tS = t, the
(cid:2)B \ S is such that tS = M − C − t.
complement subset S =
Thus, the number of subsets is the same.
Next, we prove a bound on the winning probability of the
adversary.
Lemma 5.5: For every S ⊆ [N ] such that tS ≤ M
r ∈(cid:11)
2 and for
every adversary AtS who chooses tS bad balls, there exists
for which it holds that
(cid:12)
N
2
, N, (cid:2)B, C) = 1] ≤ n(tS)
r·Bmin
M
(cid:2)
(cid:3)
Pr[Game4(AtS
858
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:19:59 UTC from IEEE Xplore.  Restrictions apply. 
Proof: From Lemma 5.2, it follows that it is sufﬁcient to
which is equivalent to proving that
for which it holds that
n(tS) ·
(r · Bmin)!
Bmin!(r · Bmin − Bmin)!
≤
(r · Bmin − Bmin)!(M − r · Bmin)!
(cid:7)
(M − Bmin)!
(cid:7)
.
Since C ≥ Bmin, it holds that M − Bmin ≥ M − C and
.
(cid:6)
M − Bmin
(r − 1) · Bmin
(cid:7)
M − C
(cid:3)
(r − 1) · Bmin
M−C
.
so
(cid:6)
n(tS)
Thus, we need to prove that
r · Bmin
(cid:6)
(r − 1) · Bmin
(cid:7)
≤
(cid:6)
In addition, note that n(tS) ≤ (cid:2)
(cid:6)
M − Bmin
(r − 1) · Bmin
(cid:6)
≥
r · Bmin
(r − 1) · Bmin
(cid:7)(cid:6)
n(tS)
(cid:6)
≤
M − C
tS
ts
(r − 1) · Bmin
(this holds since by
deﬁnition n(tS) equals the number of ways to choose tS balls
out of M − C balls under a speciﬁc restriction), and note that
(cid:7)
r · Bmin ≤ tS (see Lemma 5.5). Thus it follows that
(cid:7)(cid:6)
(cid:7)
tS
tS
M − C
(cid:7)
(cid:6)
≤
.
tS
(r − 1) · Bmin