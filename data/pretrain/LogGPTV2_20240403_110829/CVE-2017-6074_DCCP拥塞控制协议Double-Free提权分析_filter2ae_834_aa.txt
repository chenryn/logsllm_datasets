# CVE-2017-6074 DCCP拥塞控制协议Double-Free提权分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
**影响版本** ：Linux v2.6.14 – v4.9.13。 v4.9.13已修补，v4.9.12未修补。 评分7.8分。
隐藏时间超过10年，从2005年10月的v2.6.14开始。
**测试版本** ：Linux-v4.9.12 [exploit及测试环境下载地址](https://github.com/bsauce/kernel-exploit-factory)—
**编译选项** ： **CONFIG_IP_DCCP=y** **CONFIG_INET_DCCP_DIAG=y** 以及与`DCCP`相关的选项。
在编译时将`.config`中的`CONFIG_E1000`和`CONFIG_E1000E`，变更为=y。[参考](https://blog.csdn.net/qq_16097611/article/details/104965045)
    $ wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-4.9.12.tar.xz
    $ tar -xvf linux-4.9.12.tar.xz
    # KASAN: 设置 make menuconfig 设置"Kernel hacking" ->"Memory Debugging" -> "KASan: runtime memory debugger"。
    $ make -j32
    $ make all
    $ make modules
    # 编译出的bzImage目录：/arch/x86/boot/bzImage。
**漏洞描述** ：Linux内核IP V6协议簇的DCCP（数据报拥塞控制协议），`net/dccp/input.c`中的
[dccp_rcv_state_process()](https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/input.c#L574)
函数，在`LISTEN`状态下错误处理 `DCCP_PKT_REQUEST`
包数据结构，用户采用`IPV6_RECVPKTINFO`选项调用`setsockopt()`时会触发`sk_buff`结构的 **Double-Free**
。
**补丁** ：[patch
](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4)
调用[consume_skb()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L748)继续占用skb，以避免跳到`discard`中`kfree_skb()`释放skb。`consume_skb()`
表示 skb是正常释放，`kfree_skb()` 表示因为某种错误报文被丢弃。
    diff --git a/net/dccp/input.c b/net/dccp/input.c
    index ba347184bda9b..8fedc2d497709 100644
    --- a/net/dccp/input.c
    +++ b/net/dccp/input.c
    @@ -606,7 +606,8 @@ int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
                 if (inet_csk(sk)->icsk_af_ops->conn_request(sk,
                                         skb) dccph_type == DCCP_PKT_RESET)
                 goto discard;
**保护机制** ：开启SMEP/SMAP，未开启KASLR。
**利用总结**
：利用方式类似CVE-2016-8655。第一次触发漏洞，堆喷伪造`po->rx_ring->prb_bdqc->retire_blk_timer`结构，执行`native_write_cr4(0x406e0)`来关闭SMEP/SMAP；第二次触发漏洞，堆喷伪造`skb->
... ->destructor_arg`结构，执行`commit_creds(prepare_kernel_cred(0))`来提权。
* * *
## 1\. 漏洞分析
**漏洞流程** ：
  * （1）[dccp_rcv_state_process()](https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/input.c#L574) 处理请求包，如果DCCP协议栈socket状态为`DCCP_LISTEN`，且请求类型为`DCCP_PKT_REQUEST`，则调用 [dccp_v6_conn_request()](https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/ipv6.c#L303) — `[1]`处；
  * （2）[dccp_v6_conn_request()](https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/ipv6.c#L303) 中`[3]`处，只要满足条件，就将skb引用计数加1，且将skb指针保存到 `ireq->pktopts`——`[4][5]`；用户可通过调用 `setsockopt()` 和 `IPV6_RECVPKTINFO` 选项来设置 `np->rxopt.bits.rxinfo`，使之满足条件`[3]`。
  * （3）[dccp_v6_conn_request()](https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/ipv6.c#L303) 返回成功，却跳至`[2]`处，该skb被`__kfree_skb()`强制释放。之后skb再次释放时即触发Double-Free。
**调用链**
：[dccp_rcv_state_process()](https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/input.c#L574)
->
[dccp_v6_conn_request()](https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/ipv6.c#L303)
    int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
                   struct dccp_hdr *dh, unsigned int len)
    {
        struct dccp_sock *dp = dccp_sk(sk);
        struct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);
        const int old_state = sk->sk_state;
        int queued = 0;
        ... ...
        if (sk->sk_state == DCCP_LISTEN) {
            if (dh->dccph_type == DCCP_PKT_REQUEST) {
                if (inet_csk(sk)->icsk_af_ops->conn_request(sk,        // [1]    实际调用 dccp_v6_conn_request() 函数
                                        skb) dccph_type == DCCP_PKT_RESET)
                goto discard;
            /* Caller (dccp_v4_do_rcv) will send Reset */
            dcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;
            return 1;
        } else if (sk->sk_state == DCCP_CLOSED) {
            dcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;
            return 1;
        }
        ... ...
        if (!queued) {
    discard:
            __kfree_skb(skb);                                        // [2] 错误释放 skb
        }
        return 0;
    }
    // [1] dccp_v6_conn_request()
    static int dccp_v6_conn_request(struct sock *sk, struct sk_buff *skb)
    {
        struct request_sock *req;
        struct dccp_request_sock *dreq;
        struct inet_request_sock *ireq;
        struct ipv6_pinfo *np = inet6_sk(sk);
        const __be32 service = dccp_hdr_request(skb)->dccph_req_service;
        struct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);
        ... ...
        ireq = inet_rsk(req);
        ireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;
        ireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;
        ireq->ireq_family = AF_INET6;
        if (ipv6_opt_accepted(sk, skb, IP6CB(skb)) ||
            np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo ||        // [3] 可通过 setsockopt() 和 IPV6_RECVPKTINFO 选项来设置 np->rxopt.bits.rxinfo
            np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim) {
            atomic_inc(&skb->users);                                // [4] 只要满足其中一个条件，就会将skb的引用计数加1
            ireq->pktopts = skb;                                    // [5] 且将skb指针保存到 ireq->pktopts 中。
        }
        ireq->ir_iif = sk->sk_bound_dev_if;
        ... ...
    }
* * *
## 2\. 漏洞利用
####  2-1. 触发漏洞
**触发步骤** ：
  * （1）创建s1 = socket(PF_INET6, SOCK_DCCP, …)，并且监听该socket；
  * （2）设置该socket的属性值`IPV6_RECVPKTINFO`，使函数`dccp_v6_conn_request()`通过if条件`[3]`，触发释放skb；
  * （3）skb释放后，进行堆喷，伪造`skb-> ... ->destructor_arg->callback`函数，触发二次释放skb，执行伪造的回调函数。
**结构链**
（伪造`ubuf_info`结构）：[sk_buff](https://elixir.bootlin.com/linux/v4.9.12/source/include/linux/skbuff.h#L633)
->
[skb_shared_info](https://elixir.bootlin.com/linux/v4.9.12/source/include/linux/skbuff.h#L414)
->
[ubuf_info](https://elixir.bootlin.com/linux/v4.9.12/source/include/linux/skbuff.h#L405)
-> `callback`
    struct sk_buff {
        union {
            struct {
                /* These two members must be first. */
                struct sk_buff        *next;
                struct sk_buff        *prev;
                union {
                    ktime_t        tstamp;
                    struct skb_mstamp skb_mstamp;
                };
            };
            struct rb_node    rbnode; /* used in netem & tcp stack */
        };
        struct sock        *sk;
        struct net_device    *dev;
      ... ... 
      /* These elements must be at the end, see alloc_skb() for details.  */
        sk_buff_data_t        tail;
        sk_buff_data_t        end;
        unsigned char        *head,
                    *data;                                                        // 
[inet_csk_destroy_sock()](https://elixir.bootlin.com/linux/v4.9.12/source/net/ipv4/inet_connection_sock.c#L691)
->
[dccp_v6_destroy_sock()](https://elixir.bootlin.com/linux/v4.9.12/source/net/dccp/ipv6.c#L988)
->