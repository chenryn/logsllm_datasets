### 2
The security bound for the protocol is given by:
\[ \gamma(nPnSnT) + \gamma \left( \Delta_{\text{PRF-ODH}} + \frac{1}{q} \right) + \text{negl}(\lambda) \]
where \(\Delta_{\text{PRF-ODH}}\) bounds the advantage of a probabilistic polynomial-time (PPT) adversary against the PRF-ODH game. This bound depends only on \(\Delta_{\text{PRF-ODH}}\) and not on the KeyExchange because it is unauthenticated.

### Proof Sketch (Full proof in Appendix C)
Our proof employs the standard game-hopping technique. We start with the original security game and consider similar games, bounding the success probability of the adversary at each step, until we reach a game where the adversary cannot win with a non-negligible probability over \(1/2\). Since the probabilities of all games are related, we can bound the original success probability of the adversary.

For technical reasons, we make one modification to the protocol: as specified, ART has agents authenticate group creation messages with a signature under the identity key and update messages with a MAC on a key derived from the stage key. Because these keys are also used in the key exchange protocol, we cannot achieve key indistinguishability. In the computational proof, we will therefore drop the explicit authenticators from the protocol and enforce authentication through the freshness condition instead.

### Overall Structure of the Proof
1. **Administrative Game Hops**: We first perform some administrative game hops to avoid DH key collisions.
2. **Guessing Indices**: We guess the indices \((u, i, t)\) of the session ID (sid) of the Test session and stage. If it is not fresh, the adversary loses. If it is fresh, we perform a case distinction based on which clause of the freshness predicate it satisfies: either the current copath or a previous stage was fresh.
3. **Indistinguishability by Induction**: In the latter case, indistinguishability holds by induction. In the former case, by definition, we know that all the leaf keys used to generate the current stage are honestly generated and unrevealed. The secret key at a node with child public keys \(g^x\) and \(g^y\) is defined to be \(\iota(g^{xy})\). By the hardness of the PRF-ODH problem, we can indistinguishably replace it with \(\iota()\) of a uniformly randomly chosen group element.
4. **Replacement and Probability Bounding**: We perform this replacement for each non-leaf node in the tree, bounding the probability difference at each game hop with the PRF-ODH advantage. After all non-leaves have been replaced, the tree key (and hence the stage key) is replaced with a random group element. The success probability of the adversary against this final game is no better than \(1/2\). By summing probabilities throughout the various cases, we derive our overall probability bound.

### Tightness of the Security Reduction
As noted in [2], a limitation of conventional game-hopping proofs for AKE-like protocols is that they do not provide tight reductions. The underlying reason is that the reductions depend on guessing the specific party and session under attack. For protocols with potentially large numbers of sessions and users, this leads to an extremely non-tight reduction. While [2] develops new protocols with tight reductions, their protocols are non-standard in setup and assumptions. There is currently no known technique for constructing a tight reduction applicable to the ART protocol. Nevertheless, even loose bounds are generally considered useful to increase confidence in the security mechanisms [17, 24].

### 6.3 Analysis: Authenticated Protocol
Deriving the leaf keys \(\lambda_j\) from a one-round authenticated key exchange protocol allows for the authentication of the initial group key, ensuring that only an agent whose public key was used for setup can derive the group key. We now provide an example of such a construction and analyze its authentication property using Tamarin.

We use X3DH extended with the static-static DH key as our one-round key exchange protocol: agents \(A\) and \(B\) with long-term keys \(g^a\) and \(g^b\) and ephemeral keys \(g^x\) and \(g^y\) derive a shared key \(K = H(g^{ay}, g^{bx}, g^{xy}, g^{ab})\). Including \(g^{ab}\) means that knowing \(y\) is not sufficient to impersonate any party to \(B\); an adversary must also know \(b\). To model the authentication property, we abstract out the tree construction and replace it with a symbolic "oracle" that assigns a fresh term representing the group key to any set of public keys. Anyone may query this oracle if they know one of the corresponding secret keys.

We use Tamarin for mechanized verification. Roughly, we model a protocol role Alice who accepts initial key exchange messages representing new group members, adding the derived keys to her state. At any point, she may stop accepting new members and derive a group key via our abstract oracle.

Although using a more advanced authenticated key exchange protocol for the leaves is a relatively small change, the resulting security property does not follow trivially. In an earlier design, we considered a protocol without authentication of the initial messages. Tamarin found an attack where Alice correctly fetches prekeys, computes a group key, and sends the resulting (abstract) copath to Bob, but the adversary modifies this message to add a malicious leaf key. Knowing a leaf key for Bob's tree, the adversary can then derive the resulting key even though it is accepted by Bob. The Tamarin analysis made it clear that for the group key to be authenticated, not just the \(\lambda_j\) but also the copath of public keys needs to be authenticated, and we improved our design accordingly.

We will release the Tamarin models shortly. The model verifies that the initial group key an agent derives is secret, provided none of the agents they believe to be in the group have been compromised. The verification is unbounded, allowing an arbitrary number of parties, instances, and group members. The verification of this security property proceeds automatically using several helper lemmas and takes approximately 15 minutes on a modern desktop.

### 7 ART Implementation
We implemented the ART protocol described in Section 5 in Java, with source code available at the URL [41]. Our goal is to demonstrate that ART is practical and efficient for groups of a realistic size. Implementation details are in Appendix D.

We compare directly to DH ratcheting with pairwise connections, noting that hash ratcheting could be added to ART for a full comparison against Signal’s Double Ratchet. We do not benchmark against the sender key design, as it does not achieve PCS.

For our benchmarks, we construct a simple protocol in two phases around both approaches. The first "setup" phase constructs a group, such that at its conclusion, any member can send a message. The second "encryption" phase performs an asymmetric update and then encrypts a random message to the entire group. The ART instantiation of the encryption phase comprises an update message and then a single encryption under the group key. The pairwise-channel instantiation follows the Double Ratchet algorithm, sending an update over each channel if the messaging direction changes, and encrypting the message with the latest message key for that channel. We use 32-byte messages, as this is enough space to store an AES-256 data encapsulation key.

We measure wall-clock time and network bandwidth consumption in various scenarios, but our primary metric is the per-person time/bandwidth cost to send a message. This is the main cost directly and repeatedly visible to users: setup costs, while important, are only incurred once, while this cost is incurred each time a user sends a message. All data are from a 2016 MacBook Pro with a 3.3 GHz Intel Core i7 and 16 GB of RAM.

### 7.1 Evaluation
Our results demonstrate that ART is practical for reasonably-sized groups, with setup and sending both taking a few milliseconds for groups of size ten and on the order of one second for groups of size 1000. ART’s performance compares favorably to that of pairwise DH ratcheting, as seen in Figure 7a. This is due to server-side fanout: ART allows for broadcasting the same (logarithmic) quantity of data to all peers, while pairwise channels require sending different constant-sized data to everyone.

Depending on how the broadcast is implemented, this yields slightly different benefits. In practice, for the messaging context, broadcast is typically offloaded to server-side fanout. In this case, the total number of bytes transmitted in a system using ART is actually larger than for pairwise connections, and recipients must perform a logarithmic instead of constant-size computation. However, in the messaging context, the total amount of data sent is often less important than the message sending latency, which is directly proportional to the amount of data each agent needs to send. Because ART allows for server-side fanout, distributing the sending cost across all parties, it thus allows for significantly lower sending latency than pairwise.

As seen in Figure 7b, the setup costs of ART and pairwise channels are comparable, with the former consistently slightly slower than the latter but with the same asymptotic trend. However, we do remark that pairwise channels spread a quadratic computational effort evenly across all group members, while ART requires the creator to perform a linear amount of work and the responders to perform a logarithmic amount. Although this overhead is minimal for the group sizes normally seen in messaging applications, for large-scale use cases, the shared quadratic effort may be a significant performance constraint.

### 8 Extensions
We here remark on various possible extensions to our ART design. In general, because we use standard tree-DH techniques, much of the existing literature is directly applicable. This means that we can directly apply well-studied techniques that do not require interactive communication rounds.

**Sender-Specific Authentication**: As early as 1999, Wallner, Harder, and Agee [54] pointed out the issue of "sender-specific authentication": in a system that derives a shared group key known to all members, there is no cryptographic proof of which group member sent a particular message. Various works have discussed such proofs; the most common design is to assign each group member a signature key with which they sign all their messages. We remark that it is easy to extend our design with such a system; in particular, by rotating and chaining signature keys, we conjecture that it is possible to achieve this authentication post-compromise.

**Dynamic Groups**: We refer the reader to e.g., [28] for a summary of previous work on dynamic groups. In general, since we build on tree-based ideas, our design can support join and leave operations using standard techniques. These operations can be done asynchronously using a design similar to the setup keys in Section 5.1. Specifically, Alice can add Ted as a sibling to her own node in the tree by performing an operation similar to the initial tree setup, generating an ephemeral key, and performing a key update that replaces Alice’s leaf with an intermediate node whose children are Alice and Ted. With the cooperation of other users in the tree, Alice can add Ted anywhere, allowing her to keep the tree balanced.

**Multiple Devices**: One important motivation for supporting group messaging is to enable users to communicate using more than one of their own devices. By treating each device as a separate group member, our design of course supports this use case. However, the tree structure can be optimized for this particular scenario: all of Alice’s devices can be stored in a single subtree, so that the "leaves" of the group tree are themselves roots of device-specific trees. Using "subtrees" in this way allows a user to publish the public key of their subtree as an ephemeral prekey, enabling all their devices to be added to new groups as a single unit. Moreover, users do not need to reveal which device in a subtree triggers an update, thus improving their privacy guarantees.

**Chain Keys**: Signal introduced the concept of chain keys to support out-of-order message receipt and a fine-grained form of forward secrecy. Instead of using a shared secret to encrypt messages directly, Signal derives a new encryption key for each message from a hash chain. The shared secret derived by our GKE can be directly used in the same way, for the same benefits.

### 9 Conclusion
In this paper, we combined techniques from synchronous group messaging with strong modern security guarantees from asynchronous messaging. Our resulting Asynchronous Ratcheting Trees (ART) design combines the bandwidth benefits of group messaging with the strong security guarantees of modern point-to-point protocols. Our design is the first to show that post-compromise security is efficiently achievable for group messaging as well as pairwise. This paves the way for modern messaging applications to offer the same type of security for groups that they are currently only offering for two-party communications.

ART has seen widespread interest from industry and forms the basis of two draft RFCs as well as the IETF’s MLS working group, which has adopted it as a starting point. We hope that it will lead to designs for secure messaging systems that can improve the guarantees provided to users everywhere.

Our construction is of independent interest, as it provides a blueprint for generically applying insights from synchronous group messaging in the asynchronous setting. We expect this to lead to many more alternative designs in future works.

### Acknowledgements
The authors would like to thank Richard Barnes for pointing out an error in a previous version of the algorithm and MLS’s many contributors for helpful discussions and insights.

### References
[1] Michel Abdalla, Céline Chevalier, Mark Manulis, and David Pointcheval. 2010. Flexible group key exchange with on-demand computation of subgroup keys. In AFRICACRYPT 10 (LNCS). Daniel J. Bernstein and Tanja Lange, editors. Volume 6055. Springer, Heidelberg, (May 2010), 351–368.

[2] Christoph Bader, Dennis Hofheinz, Tibor Jager, Eike Kiltz, and Yong Li. 2015. Tightly-secure authenticated key exchange. In TCC 2015, Part I (LNCS). Yevgeniy Dodis and Jesper Buus Nielsen, editors. Volume 9014. Springer, Heidelberg, (March 2015), 629–658. doi: 10.1007/978-3-662-46494-6_26.

[3] Daniel J. Bernstein. 2006. Curve25519: new Diffie-Hellman speed records. In PKC 2006 (LNCS). Moti Yung, Yevgeniy Dodis, Aggelos Kiayias, and Tal Malkin, editors. Volume 3958. Springer, Heidelberg, (April 2006), 207–228. doi: 10.1007/11745853_14.

[4] Dan Boneh and Alice Silverberg. 2003. Applications of multilinear forms to cryptography. In Topics