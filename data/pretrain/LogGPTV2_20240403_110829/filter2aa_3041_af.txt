13 // Matcher 定义了要实现的 
14 // 新搜索类型的行为 
15 type Matcher interface { 
16 
 Search(feed *Feed, searchTerm string) ([]*Result, error) 
17 } 
让我们看一下第 15 行到第 17 行，这里声明了一个名为 Matcher 的接口类型。之前，我们
只见过声明结构类型，而现在看到如何声明一个 interface（接口）类型。我们会在第 5 章介
绍接口的更多细节，现在只需要知道，interface 关键字声明了一个接口，这个接口声明了结构
类型或者具名类型需要实现的行为。一个接口的行为最终由在这个接口类型中声明的方法决定。 
对于 Matcher 这个接口来说，只声明了一个 Search 方法，这个方法输入一个指向 Feed
类型值的指针和一个 string 类型的搜索项。这个方法返回两个值：一个指向 Result 类型值
的指针的切片，另一个是错误值。Result 类型的声明在第 08 行到第 11 行。
命名接口的时候，也需要遵守 Go 语言的命名惯例。如果接口类型只包含一个方法，那么这
个类型的名字以 er 结尾。我们的例子里就是这么做的，所以这个接口的名字叫作 Matcher。如
果接口类型内部声明了多个方法，其名字需要与其行为关联。 
如果要让一个用户定义的类型实现一个接口，这个用户定义的类型要实现接口类型里声明的
所有方法。让我们切换到 default.go 代码文件，看看默认匹配器是如何实现 Matcher 接口的，
如代码清单 2-35 所示。 
代码清单 2-35 search/default.go：第 01 行到第 15 行 
01 package search 
02 
03 // defaultMatcher 实现了默认匹配器 
04 type defaultMatcher struct{} 
05 
06 // init 函数将默认匹配器注册到程序里 
07 func init() { 
08 
 var matcher defaultMatcher 
09 
 Register("default", matcher) 
10 } 
11 
12 // Search 实现了默认匹配器的行为 
13 func (m defaultMatcher) Search(feed *Feed, searchTerm string) ([]*Result, error) { 
14 
 return nil, nil 
15 } 
在第 04 行，我们使用一个空结构声明了一个名叫 defaultMatcher 的结构类型。空结构
在创建实例时，不会分配任何内存。这种结构很适合创建没有任何状态的类型。对于默认匹配器
来说，不需要维护任何状态，所以我们只要实现对应的接口就行。 
在第 13 行到第 15 行，可以看到 defaultMatcher 类型实现 Matcher 接口的代码。实现
接口的方法 Search 只返回两个 nil 值。其他的实现，如 RSS 匹配器的实现，会在这个方法里
使用特定的业务逻辑规则来处理搜索。 
Search 方法的声明也声明了 defaultMatcher 类型的值的接收者，如代码清单 2-36 所示。 
代码清单 2-36 search/default.go：第 13 行 
13 func (m defaultMatcher) Search 
如果声明函数的时候带有接收者，则意味着声明了一个方法。这个方法会和指定的接收者的
类型绑在一起。在我们的例子里，Search 方法与 defaultMatcher 类型的值绑在一起。这意
味着我们可以使用 defaultMatcher 类型的值或者指向这个类型值的指针来调用 Search 方
法。无论我们是使用接收者类型的值来调用这个方，还是使用接收者类型值的指针来调用这个
方法，编译器都会正确地引用或者解引用对应的值，作为接收者传递给 Search 方法，如代码清
单 2-37 所示。 
代码清单 2-37 调用方法的例子 
// 方法声明为使用 defaultMatcher 类型的值作为接收者 
func (m defaultMatcher) Search(feed *Feed, searchTerm string) 
// 声明一个指向 defaultMatcher 类型值的指针 
dm := new(defaultMatch) 
// 编译器会解开 dm 指针的引用，使用对应的值调用方法 
dm.Search(feed, "test") 
// 方法声明为使用指向 defaultMatcher 类型值的指针作为接收者 
func (m *defaultMatcher) Search(feed *Feed, searchTerm string) 
// 声明一个 defaultMatcher 类型的值 
var dm defaultMatch 
// 编译器会自动生成指针引用 dm 值，使用指针调用方法 
dm.Search(feed, "test") 
因为大部分方法在被调用后都需要维护接收者的值的状态，所以，一个最佳实践是，将方法
的接收者声明为指针。对于 defaultMatcher 类型来说，使用值作为接收者是因为创建一个
defaultMatcher 类型的值不需要分配内存。由于 defaultMatcher 不需要维护状态，所以
不需要指针形式的接收者。 
与直接通过值或者指针调用方法不同，如果通过接口类型的值调用方法，规则有很大不同，
如代码清单 2-38 所示。使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时
候被调用。使用值作为接收者声明的方法，在接口类型的值为值或者指针时，都可以被调用。 
代码清单 2-38 接口方法调用所受限制的例子 
// 方法声明为使用指向 defaultMatcher 类型值的指针作为接收者 
func (m *defaultMatcher) Search(feed *Feed, searchTerm string) 
// 通过 interface 类型的值来调用方法 
var dm defaultMatcher 
var matcher Matcher = dm     // 将值赋值给接口类型 
matcher.Search(feed, "test") // 使用值来调用接口方法 
> go build 
cannot use dm (type defaultMatcher) as type Matcher in assignment 
// 方法声明为使用 defaultMatcher 类型的值作为接收者 
func (m defaultMatcher) Search(feed *Feed, searchTerm string) 
// 通过 interface 类型的值来调用方法 
var dm defaultMatcher 
var matcher Matcher = &dm    // 将指针赋值给接口类型 
matcher.Search(feed, "test") // 使用指针来调用接口方法 
> go build 
Build Successful 
除了 Search 方法，defaultMatcher 类型不需要为实现接口做更多的事情了。从这段代
码之后，不论是 defaultMatcher 类型的值还是指针，都满足 Matcher 接口，都可以作为
Matcher 类型的值使用。这是代码可以工作的关键。defaultMatcher 类型的值和指针现在还
可以作为 Matcher 的值，赋值或者传递给接受 Matcher 类型值的函数。
让我们看看 match.go 代码文件里实现 Match 函数的代码，如代码清单 2-39 所示。这个函数
在 search.go 代码文件的第 39 行中由 Run 函数调用。
代码清单 2-39 search/match.go：第 19 行到第 33 行 
19 // Match 函数，为每个数据源单独启动 goroutine 来执行这个函数 
20 // 并发地执行搜索 
21 func Match(matcher Matcher, feed *Feed, searchTerm string, results chan 
 News 
 ... 
 ... 
 en 
 Copyright 2014 NPR - For Personal Use 
 ... 
    Putin Says He'll Respect Ukraine Vote But U.S. 
    The White House and State Department have called on the 
如果用浏览器打开代码清单 2-47 中的任意一个链接，就能看到期望的 RSS 文档的完整内容。RSS
匹配器的实现会下载这些 RSS 文档，使用搜索项来搜索标题和描述域，并将结果发送给 results
通道。让我们先看看 rss.go 代码文件的前 12 行代码，如代码清单 2-48 所示。 
代码清单 2-48 matchers/rss.go：第 01 行到第 12 行 
01 package matchers 
02 
03 import ( 
04 
 "encoding/xml" 
05 
 "errors" 
06 
 "fmt" 
07 