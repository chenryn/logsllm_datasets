provide rich features for extensions to access sensitive infor-
mation, including bookmarks, history, and cookies. Each such
Chrome API call will be subject to label checks. The label
assignment and checking involves both the extension process
and the browser main process.
API calls originate from the V8 instance within the renderer
in which an extension core resides. An extension’s label is
initialized when it is loaded into Chrome. When the extension,
running within V8, makes an API call, a copy of the label of
the extension is propagated from V8 to the IPC layer. The
IPC layer then relays the extension’s request to use an API
function to the browser process. The browser checks whether
the caller’s label allows the speciﬁc API call and hands off
the request to the appropriate API function. The response is
returned over IPC, and before the V8 runtime receives any
information, the label of the data is checked against the label
of the target script. If this check passes, the result is released.
the same process occurs, except
When the API call adds to an API’s information store
(e.g., history),
the check
before executing the call occurs within the API implementation
instead of in the IPC layer. Speciﬁcally, before information is
released to an information store, we check that the store’s label
permits it to receive the information.
Labels are assigned to scripts when they are loaded into the
V8 runtime environment. The run-time context of the script is
labeled with respect to the manifest provided by the extension.
The DOM is labeled at the time of conception, with the each
child in the DOM inheriting its label from its parent.
When a call is made from a script to interact with a DOM
node (e.g., getElementById), V8 dispatches a call to WebKit
over the binding layer. In order to track information ﬂow,
requests to WebKit contain a reference to the context of the
requesting script. On such a call, a check is performed in the
binding layer to determine whether the call should be allowed.
The checks take into account whether the call is for getting or
setting DOM data. If the check fails, the call never returns.
D. Implementation Status, Experience, and Performance
Our prototype implementation is fully functional and in-
struments all ﬂows between the pairs of entities that we con-
sider. Several data structures are not currently instrumented:
Cascading Style Sheets, Scalable Vector Graphics, and Media.
For event handling APIs, we only instrumented those that are
used by our case studies. We also have not yet implemented
multi-level bookmarks (see Section IV-C). To obtain broad
coverage of Web IDL functions, we modiﬁed the generator
that emits the binding code to include appropriate checks in
autogenerated code.
Our implementation comprises ∼ 10, 200 lines of code
(mostly additions). The browser component with the most ad-
ditions and modiﬁcations is WebKit, with ∼ 3, 100 lines added
or changed. The additions to WebKit included changing the
Web IDL binding code generator, causing it to add ∼ 26, 700
lines of instrumentation to auto-generated binding code.
Our prototype assigns labels to web pages based on their
CSPs. Many pages don’t have CSPs; in most cases, this causes
them to fail to fully load in our browser. This is because in the
absence of a CSP a web page is given a label that does not let
it de- or reclassify sufﬁciently to load content from any site but
its own; this prevents the common practice of using third-party
content on a page. To allow for more interesting exploration,
we manually generated CSPs for Alexa’s global top-100 sites
to allow them to fully load. Automatic generation of these
enhanced CSPs is outside the scope of this work; in many
cases, it is not feasible, since a goal of our effort was to allow
more ﬂexible policies than are currently used or speciﬁed.
Similarly, extension labels are based on the permissions
in extensions’ manifests. However, as our approach allows
interesting, richer policies, we manually speciﬁed labels of
interest for several popular extensions (including Google mail
checker [23] and Facebook for Chrome [1]), as well as
our own password manager and password-stealing extensions.
Expressing desired policies directly via our labels rather than
instantiating labels based on legacy or implicit policies enables
a range of policies that are more powerful or more precise than
those normally implemented by browsers.
JavaScript reads or modiﬁes a DOM node Scripts operating
in the context of a web page can normally modify any piece of
the page’s DOM. Our approach introduces more stringent, per-
DOM-node checks. To implement them we modify WebKit,
the renderer and the binding between V8 and WebKit.
This allowed us to conﬁrm with a small set of experiments,
including the example from Section III-D, that our approach
was generally able to enforce interesting policies that would
prevent some misbehaviors allowed by current browsers, while
allowing pages and extensions to function normally. Next,
12
website
Google.com
Facebook.com
Youtube.com
Yahoo.com
Baidu.com
Amazon.com
Wikipedia.org
Taobao.com
Twitter.com
Qq.com
base load time (ms)
average
411
655
3801
2117
1452
2530
561
2748
807
6942
std. dev. median
398
622
3876
2091
1384
2219
552
2683
796
5798
51
64
205
122
276
996
52
290
34
2210
load time (ms)
std. dev. median
522
813
7160
3679
1185
3665
1118
5017
1025
9190
89
95
528
576
168
1023
110
749
31
1955
average
547
845
6995
3784
1236
3736
1098
4999
1027
9465
ovhd
num.
% checks
31
29
29
31
344
85
518
76
252
-14
65
386
190
103
681
87
15
29
59
2639
num.
requests
6
21
267
180
10
181
72
213
10
271
TABLE II: Performance for page loads of the main pages of the top 10 Alexa global top-500 web sites, with GCSP’s conﬁgured
to allow all content to load. The “base” columns report load time for unmodiﬁed Chromium; the next three columns report load
time for our instrumented browser. The remaining columns report the overhead of our mechanism (computed by comparing the
median load times achieved by the instrumented and uninstrumented browsers), the number of label checks incurred during page
load, and the number of network requests made by the browser while loading the page. Reported load times are over 40 runs,
with outliers due to network errors removed. Performance was measured on a Dell Optiplex 9020 with a Core i7–4770 CPU and
32 GB memory, running Linux 3.14.12. Web sites often varied the content they served from run to run, introducing signiﬁcant
variability and imprecision into the measurements.
in Section VI, we discuss how common high-level browser
policies mapped onto our approach, and the current limitations
of this mapping.
Our focus was on experimenting with functionality rather
than on attempting to minimize overhead.
With our unoptimized implementation, the overhead added
by our system to page load time averaged 55%.2 Performance
for a sampling of Alexa top-20 sites is shown in Table II. The
page load time is measured in similar fashion as Chromium’s
PageLoadHistograms :: LogPageLoadTime method. We start
the timer when the document loading begins and stop the timer
when the document ﬁnishes loading. Surprising is the relatively
large number of label checks that takes place as a page is
loaded. A large portion of the checks occurs during page
loading. These checks are caused by DOM tree construction
when contents arrive at
the browser and deciding which
cookies to send to the server. The rest of the checks are due to
page scripts trying to either read DOM elements or changing
their attributes. We believe that an optimized implementation
could easily be very efﬁcient.
VI. APPROXIMATING EXISTING BROWSER SECURITY
MECHANISMS
As discussed throughout, browsers currently implement
many security policies. Some of these policies are clearly about
information ﬂow and map cleanly to our labels; for others the
mapping is less clear. We next revisit several such policies,
examining to what extent they map into a policy language like
ours, as well as whether the policy language’s expressiveness
allows richer or more powerful variants of the policies to be
stated and enforced.
Same-origin policy
Browsers use the same-origin policy
(SOP) to manage access to different origins. Origins are
2Note that web sites regularly varied the content they served during the sets
of runs on which we computed performance, leading to our implementation
sometimes appearing to outperform stock Chromium.
usually deﬁned as the tuple (scheme,host,port). Scripts from
one origin cannot read content from another origin (e.g., via
XMLHttpRequest), nor can they locally read data from tabs
from other origins. The precise implementation of the SOP
is slightly more nuanced: outgoing requests to other origins
are allowed, but data that they return to the browser is not
forwarded to the entity that initiated the request.
As mentioned in Section III-D, this policy can be eas-
ily implemented using our labels. When an entity makes
a network request,
the label for the network controller is
instantiated using the outgoing (scheme,host,port) tuple.3 For
an attempted access to cnn.com,
this results in the label
(cid:96)network = (cid:0)C({cnn.∗}),{network},{}(cid:1). For an entity with
label (cid:96)e to be allowed to send data on the network, label checks
would have to permit a ﬂow from (cid:96)e to (cid:96)network . To return data
from the network, label checks would have to allow the ﬂow
from (cid:96)network to (cid:96)e. This will succeed only if the secrecy label
of (cid:96)e contains cnn.∗.
In the absence of additional restrictions, the calling page
or script could have a sufﬁciently ﬂexible label (cid:96)e to enable
either the outgoing or the incoming path. Hence, to enforce
the SOP on an entity, the browser needs only to prohibit that
entity from having a label that allows it gather secrecy tags
other than those conveying its origin. If we wished to also
disallow outgoing cross-origin requests, the browser would
need to prevent the entity’s label from being able to declassify
the tags that describe its origin.
In practice, a strict SOP prevents many commonly used
web idioms, and our prototype does not attempt to enforce it.
Domain relaxation A page can set its document.domain
value to a sufﬁx of its current domain, allowing pages with
different preﬁxes of the same hostname to communicate. E.g.,
a page from login.a.com and a page from proﬁle.a.com can both
set their domain to a.com, at which point their origins will be
3All our hostname-based tags include the scheme and port, though we
generally elide this for clarity.