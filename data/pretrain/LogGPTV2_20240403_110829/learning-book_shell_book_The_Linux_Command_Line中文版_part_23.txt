## Page 181
15.17查找安装了某个文件的软件包
确定哪个软件包对所安装的某个特殊文件负责，使用下表中的命令：
风格
命令
Debian
dpkg --search file_name
Red Hat
rpm -qf file_name
表15-12：包文件识别命令
例如：在RedHat系统中，查看哪个软件包安装了/usr/bin/vim这个文件
rpn -qf /usr/bin/vin
15.18
总结归纳
在随后的章节里面，我们将探讨许多不同的程序，这些程序涵盖了广泛的应用程序领域。虽然
大多数程序一般是默认安装的，但是若所需程序没有安装在系统中，那么我们可能需要安装额
外的软件包。通过我们新学到的（和了解的）软件包管理知识，我们应该能够安装和管理所需
程序。
Linux软件安装谣言
从其它平台迁移过来的用户有时会成为谣言的受害者，说是在Linux系统中，安
装软件有些困难，并且不同系统发行版所使用的各种各样的打包方案是一个障碍。
喉，它是一个障碍，但只是针对于那些希望把他们的秘密软件只以二进制版本发行
的专有软件供应商。
Linux软件生态系统是基于开放源代码理念。如果一个程序开发人员发布了一款
产品的源码，那么与系统发行版相关联的开发人员可能就会把这款产品打包，并把
它包含在他们的资源库中。这种方法保证了这款产品能很好地与系统发行版整合在
一起，同时为用户“一站式采购”软件提供了方便，从而用户不必去搜索每个产品
的网站。
设备驱动差不多也以同样的方式来处理，但它们不是系统发行版资源库中单独的
项目，它们本身是Linux系统内核的一部分。一般来说，在Linux当中没有一个类
180
---
## Page 182
似于“驱动盘”的东西。Linux内核要么支持一个设备，要不就不支持。Linux内核
支持很多设备，事实上，Linux支持的设备数目多于Windows所支持的。当然，万
一你需要的特定设备不被Linux支持，也于事无补。当那种情况发生时，你需要查
找一下原因。缺少驱动程序支持通常是由以下三种情况之一导致：
1.设备太新。因为许多硬件供应商没有积极地支持Linux的发展，那么编写内核
驱动代码的任务就由一些Linux社区来承担，而这需要花费时间。
2.设备太奇异。不是所有的发行版都包含每个可能的设备驱动。每个发行版会建
立它们自己的内核，因为内核是可以配置的（这使得从手表到主机的每台设备
上运行Linux成为可能），这样它们可能会忽略某个特殊设备。通过定位和下
载驱动程序的源码，可能需要你自己（是的，由你）来编译和安装驱动。这个
过程不是很难，而是需要参与的。我们将在随后的章节里来讨论编译软件。
3.硬件供应商隐藏信息。他们既不发布应用于Linux系统的驱动程序代码，也不
发布技术文档来让某人创建它。这意味着硬件供应商试图保密此设备的程序接
口。因为我们不想在计算机中使用保密的设备，所以我建议删除这令人厌恶的
硬件，把它和其它无用的东西都扔到垃圾桶里。
15.19拓展阅读
花些时间来了解你所用发行版中的软件包管理系统。每个发行版都提供了关于自带软件包管理
工具的文档。另外，这里有一些更普遍的资源：
·DebianGNU/LinuxFAQ关于软件包管理一章对软件包管理进行了概远：
http:/www.debian.org/doc/FAQ/ch-pkgtools.en.html
·RPM工程的主页：
http://www.rpm.org
·杜克大学YUM工程的主页：
http://linux.duke.edu/projects/yum/
·了解一点儿背景知识，Wikipedia上有一篇关于metadata的文章：
http:/en.wikipedia.org/wiki/Metadata
181
---
## Page 183
167
存储媒介
在前面章节中，我们已经在文件级别上见识了数据的操作。在这章里，我们将从设备级别来考
虑数据。Linux有着令人惊奇的能力来处理存储设备，不管是物理设备，比如说硬盘，还是网
络设备，或者是虚拟存储设备，像RAID（独立磁盘余阵列）和LVM（逻辑卷管理器）。
然而，这不是一本关于系统管理的书籍，我们不会试图深入地覆盖整个主题。我们将努力做
的就是介绍一些概念和用来管理存储设备的重要命令。
为了做这一章的练习，我们将会使用USB闪存，CD-RW光盘（如果系统配备了CD-ROM
烧录器）和一张软盘（如果系统有这样配备的话）。
我们将看看以下命令：
·mount一挂载一个文件系统
·umount一卸载一个文件系统
·fsck一检查和修复一个文件系统
·fdisk一分区表控制器
·mkfs一创建文件系统
·fdformat一格式化一张软盘
·dd一把面向块的数据直接写入设备
·genisoimage(mkisofs)一创建一个 ISO 9660的映像文件
·wodim（cdrecord）一把数据写入光存储媒介
·md5sum一计算MD5检验码
182
---
## Page 184
16.1
挂载和卸载存储设备
Linux桌面系统的最新进展已经使存储设备管理对于桌面用户来说极其容易。大多数情况下
我们只要把设备连接到系统中，它就能工作。在过去（比如说，2004年），这个工作必须手动
完成。在非桌面系统中（例如，服务器中），这仍然是一个主要地手动过程，因为服务器经常有
极端的存储需求和复杂的配置要求。
管理存储设备的第一步是把设备连接到文件系统树中。这个叫做“挂载”的过程允许设备连
接到操作系统中。回想一下第三章，类Unix的操作系统，比如Linux在单一文件系统树中维
护连接在各个节点的各种设备。这与其它操作系统形成对照，比如说MS-DOS和Windows系
统中，每个设备（例如C：\.D：\，等）保持着单独的文件系统树。
有一个叫做/etc/fstab的文件可以列出系统启动时要挂载的设备（典型地，硬盘分区）。下
面是来自于Fedora7系统的/etc/fstab文件实例：
LABEL=/12
ext3
defaults
1
LABEL=/hose
/hone
ext3
defaults
1
2
LABEL=/boot
/boot
defaults
√
2
tnpfs
/dev/shn
tapfs
defaults
0
0
devpts
/dev/pts
devpts
gid=5,mode=620
0
0
sysfs
/sys
sysfs
defaults
0
0
proc
/proc
proc
defaults
0
0
LABEL=SWAP-sda3
/svap
svap
defaults
0
0
在这个实例中所列出的大多数文件系统是虚拟的，并不适用于我们的讨论。就我们的目的
而言，前三个是我们感兴趣的：
LABEL=/12
/
ext3
defaults
1
LABEL=/hose
 /home
ext3
defaults
1
LABEL=/boot
/boot
ext3
defaults
1
2
这些是硬盘分区。每行由六个字段组成，如下所示：
字段
内容
说明
183
---
## Page 185
1
设备名
传统上，这个字段包含与物理设备相关联的设备文件
的实际名字，比如说/dev/hda1（第一个IDE通道上
第一个主设备分区）。然而今天的计算机，有很多热插
拔设备（像USB驱动设备），许多现代的Linux发行
版用一个文本标签和设备相关联。当这个设备连接到
系统中时，这个标签（当储存媒介格式化时，这个标
签会被添加到存储媒介中）会被操作系统读取。那样
的话，不管赋给实际物理设备哪个设备文件，这个设
备仍然能被系统正确地识别。
2
挂载点
设备所连接到的文件系统树的目录。
3
文件系统类型
Linux允许挂载许多文件系统类型。大多数本地的
Linux文件系统是ext3，但是也支持很多其它的，
比方说 FAT16 (msdos), FAT32 (vfat). NTFS (ntfs),
CD-ROM(iso9660).等等。
4
选项
文件系统可以通过各种各样的选项来挂载。有可能，
例如，挂载只读的文件系统，或者挂载阻止执行任何
程序的文件系统（一个有用的安全特性，避免删除媒
介
5
频率
一位数字，指定是否和在什么时间用dump命令来备
份一个文件系统。
9
次序
一位数字，指定fsck命令按照什么次序来检查文件系
统。
表16-1:/etc/fstab字段
16.2查看挂载的文件系统列表
这个mount命令被用来挂载文件系统。执行这个不带参数的命令，将会显示一系列当前挂载的
文件系统：
[ne@linuxbox -]$ mount
/dev/sda2 on / type ext3 (rv)
proc on /proc type proc (rv)
184
---
## Page 186
sysfs on /sys type sysfs (rv)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
/dev/sda5 on /home type ext3 (z)
/dev/sda1 on /boot type ext3 (zv)
tnpfs on /dev/shm type tmpfs (rv)
none on /proc/sys/fs/binfnt_nisc type binfnt_nisc (ru)
sunrpc on /var/lib/nfs/zpc_pipefs type rpc_pipefs (rv)
fusectl on /sys/fs/fuse/connections type fusect1 (zv)
/dev/sdd1 on /nedia/disk type vfat (rw,nosuid,nodev,noatime,
uhelper=hal,uid=500,utf8,shortnane=1ower)
tvin4:/musicbox on /misc/musicbox type nfs4 (rv,addr=192.168.1.4)
这个列表的格式是：设备on挂载点type文件系统类型（选项）。例如，第一行所示设备/
dev/sda2作为根文件系统被挂载，文件系统类型是ext3，并且可读可写（这个“rw”选项）
在这个列表的底部有两个有趣的条目。倒数第二行显示了在读卡器中的一张2G的SD内存卡，
挂载到了/media/disk上。最后一行是一个网络设备，挂载到了/misc/musicbox上。
第一次实验，我们将使用一张CD-ROM。首先，在插入CD-ROM之前，我们将看一下系
统：
[ne@linuxbox -]$ moust
/dev/napper/Vo1Group00-LogVo100 on / type ext3 (rv)
proc on /proc type proc (rv)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
/dev/hda1 on /boot type ext3 (zv)
tnpfs on /dev/shs type tapfs (rv)
none on /proc/sys/fs/binfnt_nisc type binfnt_nisc (rv)
sunrpc on /var/lib/nfs/xpc_pipefs type rpc_pipefs (rv)
这个列表来自于CentOS5系统，使用LVM（逻辑卷管理器）来创建它的根文件系统。正
如许多现在的Linux发行版一样，这个系统试图自动挂载插入的CD-ROM。当我们插入光盘
后，我们看看下面的输出：
[ne@linuxbox -]$ mount
185
---
## Page 187
/dev/napper/Vo1Group00-LogVo100 on / type ext3 (rv)
proc on /proc type proc (rv)
sysfs on /sys type sysfs (rv)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
/dev/hda1 on /boot type ext3 (rv)
tnpfs on /dev/shm type tmpfs (rv)
none on /proc/sys/fs/binfnt_nisc type binfnt_nisc (ru)
sunrpc on /var/lib/nfs/zpc_pipefs type rpc_pipefs (rv)
/dev/hdc on /media/1ive-1.0.10-8 type iso9660 (ro,noexec,nosuid,
nodev,uid=500)
当我们插入光盘后，除了额外的一行之外，我们看到和原来一样的列表。在列表的末尾，我
们看到CD-ROM已经挂载到了/media/live-1.0.10-8上，它的文件类型是iso9660（CD-ROM）。
就我们的实验目的而言，我们对这个设备的名字感兴趣。当你自已进行这个实验时，这个设备
名字是最有可能不同的。
警告：在随后的实例中，至关重要的是你要密切注意用在你系统中的实际设备名，并且不要
使用此文本中使用的名字！
还要注意音频CD和CD-ROM不一样。音频CD不包含文件系统，这样在通常意义上，它
就不能被挂载了。
现在我们拥有CD-ROM光盘的设备名字，让我们卸载这张光盘，并把它重新挂载到文件
系统树的另一个位置。我们需要超级用户身份（使用系统相应的命令）来进行操作，并且用
umount（注意这个命令的拼写）来卸载光盘：
[ne@linuxbox -]$ su -
Passvord:
[rootQlinuxbox ~]# umount /dev/hdc
下一步是创建一个新的光盘挂载点。简单地说，一个挂载点就是文件系统树中的一个目录。
它没有什么特殊的。它甚至不必是一个空目录，如果你把设备挂载到了一个非空目录上，你将
不能看到这个目录中原来的内容，直到你卸载这个设备。就我们的目的而言，我们将创建一个
新目录：