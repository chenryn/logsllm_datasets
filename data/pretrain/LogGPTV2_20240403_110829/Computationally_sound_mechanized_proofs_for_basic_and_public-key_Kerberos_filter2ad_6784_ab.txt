C encrypted under SK . The
last line of the Ô¨Ågure shows the optional reply by S, which
consists of the timestamp from the authenticator encrypted
under SK .
Although not shown in Figure 1, the CS exchange allows
C and S to agree on a key for use in future communications
between them [34]. The client may send a proposed key in
the authenticator she sends to S (encrypted under AK ), and
S may send a proposed key in the reply to C (encrypted
under AK ).
In our analysis of this key, we assume that
exactly one of C and S proposes a key this way.
2.2 The PKINIT Extension
The PKINIT extension [23] to Kerberos replaces the ba-
sic AS exchange, allowing the use of a PKI in place of a
long-term key shared between the client C and the KAS
K. Here we focus exclusively on PKINIT‚Äôs ‚Äòpublic-key
mode,‚Äô but PKINIT may also be used in ‚ÄòDiÔ¨Ée-Hellman
(DH) mode‚Äô [23]; DH mode, which has recently be stud-
ied in [37], appears to have limited implementation, while
public-key mode has been implemented for all major oper-
ating systems. PKINIT does not change either of the later
rounds in the Kerberos protocol. Figure 2 shows the AS ex-
change when PKINIT is used. In addition to the data sent
in the Ô¨Årst message of basic Kerberos, C also sends to K her
signature over a timestamp t(cid:48)(cid:48)
C and a second nonce n2, along
with certiÔ¨Åcates for C‚Äôs public key. K now generates a key
k in addition to AK and tK as in basic Kerberos. The fresh
key k is used in place of kC to communicate AK to C. k
is sent to C encrypted under C‚Äôs public key pkC along with
certiÔ¨Åcates for K‚Äôs public key and a checksum ck taken over
C‚Äôs request; this checksum consists of a keyed hash function
(HMAC) using a key derived from k (more precisely, the
key is the output of a key derivation function whose input
includes k). Furthermore, k and ck are signed by K. (Note
that in both of these messages, the signatures [ ] are imple-
mented in Kerberos by sending the signed data alongside a
signature over the data.)
C
‚Ä¢
n1,
n2, t(cid:48)(cid:48)
C
‚Ä¢ 
Cert C , [t(cid:48)(cid:48)
C , n2]skC
, C, T, n1
{{Cert K , [k, ck]skK
}}pkC , C,
TGT ,{AK, n1, tK , T}k
KAS
‚Ä¢-
k, AK
tK
‚Ä¢?
Figure 2: Message Ô¨Çow in the Ô¨Åxed version of
PKINIT, where TGT = {AK, tK , C}kT .
2.3 Security Properties
We now informally state security properties of Kerberos
concerning entity authentication and key secrecy.
In Sec-
tion 4 we will formalize these security properties in the lan-
guage of CryptoVerif and present the results in the compu-
tational model.
Property 1 (Authentication properties)
a. [Authentication of KAS to client] If a client receives
what appears to be a valid reply from the KAS, then
the KAS generated a reply for the client.
b. [Authentication of request for ST] If a TGS receives a
valid request for a service ticket, then the ticket in the
request was generated by the KAS. Furthermore, the
authenticator included in the request was generated by
the client.
c. [Authentication of TGS to client] If a client receives
what appears to be a valid reply to a request for a ser-
vice ticket for server S from a TGS, then the TGS
generated a reply for the client.
d. [Authentication of request to server] If S receives a
valid request, ostensibly from C, containing a service
ticket and the session key SK , then some TGS gener-
ated the session key SK for C to use with S and also
created the service ticket. Furthermore, C created the
authenticator.
e. [Authentication of server to client] If a client receives a
valid reply from server S then this reply was generated
by S.
We consider two diÔ¨Äerent notions of key secrecy. One is
the standard notion of cryptographic key secrecy, and the
other is the notion of key usability [21] (see below in Sec-
tion 4.3). We note that the latter notion had not been con-
sidered in [4].
Property 2 (Secrecy properties)
a. [Secrecy of AK ] If a client Ô¨Ånishes an AS exchange
with the KAS, then the authentication key AK is cryp-
tographically secret until the client initiates the TS ex-
change, i.e., the second round.
b. [Secrecy of SK ] If a client Ô¨Ånishes an TG exchange
with a TGS, then the session key SK is cryptographi-
cally secret until the client initiates the CS exchange,
i.e., the third round.
c. [Usability of AK ] If a client Ô¨Ånishes a TG exchange
with a TGS, or if the TGS Ô¨Ånishes an exchange with
the client, then the authentication key is usable for
IND-CCA2-secure encryption.
89
d. [Usability of SK ] If a client Ô¨Ånishes a CS exchange
with a server or if the server Ô¨Ånishes an CS exchange
with the client, then the session key is usable for IND-
CCA2-secure encryption.
3. CRYPTOVERIF
In this section we give a brief overview of CryptoVerif, for-
malize Kerberos using it, and summarize the authentication
and secrecy properties proved by CryptoVerif.
3.1 CryptoVerif Basics
The prover CryptoVerif [11, 13, 14, 15], available at
http://www.cryptoverif.ens.fr, can directly prove secu-
rity properties of cryptographic protocols in the computa-
tional model. Protocols are formalized using a probabilistic
polynomial-time process calculus which is inspired by the pi-
calculus and the calculi introduced in [25] and [32]. In this
calculus, messages are bitstrings and cryptographic primi-
tives are functions operating on bitstrings. This calculus is
illustrated below on a portion of code coming from Kerberos.
A more detailed description of the process calculus is given
in [11].
The process calculus represents games, and proofs are
represented as sequences of games, where the initial game
formalizes the protocol for which one wants to prove cer-
tain security properties. In a proof sequence, two consecu-
tive games Q and Q(cid:48) are observationally equivalent, mean-
ing that they are computationally indistinguishable for the
adversary. CryptoVerif transforms one game into another
by applying, e.g., the security deÔ¨Ånition of a cryptographic
primitive or by applying syntactic transformations. In the
last game of a proof sequence the desired security properties
should be obvious. Given a security parameter Œ∑, Cryp-
toVerif proofs are valid for a number of protocol sessions
polynomial in Œ∑, in the presence of an active adversary.
CryptoVerif operates in two modes: a fully automatic and
an interactive mode. The interactive mode, which is best
suited for protocols using asymmetric cryptographic primi-
tives, requires a CryptoVerif user to input commands that
indicate the main game transformations the tool should per-
form. CryptoVerif is sound with respect to the security prop-
erties it shows in a proof, but properties it cannot prove are
not necessarily invalid.
3.2 Modeling Kerberos in CryptoVerif
As an example, we present the client role of the Ô¨Årst round
of basic Kerberos (AS Exchange) from Figure 1 in the pro-
cess calculus. (The full CryptoVerif scripts are available at
http://www.cryptoverif.ens.fr/kerberos/.)
QC = !iC‚â§N c2[iC ](hostT : tgs); new n1 : nonce;
c3[iC ](cid:104)C, hostT , n1(cid:105);
c4[iC ](= C, TGT : bitstring, m2 : bitstring);
let injbot(concat1(AK , = n1, tK , = hostT ))
= dec(m2, kC ) in
event fullCK (hostT , n1, TGT , m2)
Figure 3: CryptoVerif formalization of client‚Äôs ac-
tions in AS exchange.
The replicated process !iC‚â§N P represents N copies of P ,
available simultaneously, where N is assumed to be polyno-
mial in the security parameter Œ∑. These copies are indexed
by the integer value iC ‚àà [1, N ]. Each copy starts with an in-
put c2[iC ](hostT : tgs). This input receives a message hostT
on channel c2[iC ]. The channel is indexed by iC , so that, by
sending a message on channel c2[i] for a certain value of i,
the adversary can choose which copy of the process receives
the message and is then executed. The message hostT is
the name of the ticket granting server (TGS) to which the
client is going to send his request. The type tgs is a set
of bitstrings that contains the representation of all possible
names of ticket granting servers. The message is received
only if it belongs to this type.
Next, the process chooses a random nonce n1 uniformly
in the type nonce, by the construct new n1 : nonce.
(A
probabilistic Turing machine can choose a number uniformly
at random only from sets whose size is a power of 2; to make
sure that the choice above is possible, we assume that nonce
consists of all bitstrings of a certain length.) The process
then sends the Ô¨Årst message of the protocol C, hostT , n1
on channel c3[iC ]. This message will be received by the
adversary; the adversary can do whatever he wants with
it, but in order to run a normal session of the protocol,
he should send this message to the Kerberos authentication
server (KAS).
After sending the message on channel c3[iC ], the control
is returned to the adversary and the process c4[iC ](. . .); . . .
is made available. This process waits for the second mes-
sage of the protocol and will be executed when a mes-
sage is sent on channel c4[iC ]. The expected message
is C, T GT, m2 = C,{AK , tK , C}kT ,{AK , n1, tK , hostT}kC .
The message received on channel c4[iC ] then consists of three
parts: the client name C, the TGT TGT , and the message
m2 = {AK , n1, hostT}kC . The process checks that the Ô¨Årst
component of this message is C by using the pattern = C;
the two other parts are stored in variables.
The process QC cannot check the TGT, which is en-
crypted under a key the client does not have. On the
other hand, QC can decrypt and check m2.
It decrypts
m2 by dec(m2, kC ) and checks that the resulting plain-
text matches the expected nonce and tgs.
If the decryp-
tion fails, it returns the special symbol ‚ä•. The function
injbot is the natural injection from plaintexts to bitstrings
and ‚ä•, so that, when injbot(x) = dec(m2, kC ), the de-
cryption succeeded and x is the plaintext. Furthermore,
the expected plaintext is the concatenation of AK , n1, tK ,
and hostT , concat1(AK , n1, tK , hostT ). The concatenation
function concat1 is assumed to be injective, with inverses
computable in polynomial time, so that AK , n1, tK , and
hostT can be recovered from the plaintext in polynomial
time. This assumption is justiÔ¨Åable in view of the Kerberos
data structures involved. The let construct in QC checks
that the plaintext is of the required form, with the already
known values of n1 and hostT , and binds the variables AK
and tK to the received values.
When a check fails, the control is returned to the ad-
versary. When all checks succeed, QC executes the event
fullCK (hostT , n1, TGT , m2). Executing this event does not
aÔ¨Äect the execution of the protocol; it just records that a cer-
tain program point is reached with certain values of the vari-
ables. Events are used for specifying authentication proper-
ties, as explained in Section 3.3. After executing the event,
the control is returned to the adversary.
In this calculus, all variables deÔ¨Åned under replications are
90
implicitly arrays, indexed by the indices of these replications.
For instance, the variable hostT deÔ¨Åned under !iC‚â§N is in
fact hostT [iC ], so that each copy of the replicated process
stores the value of hostT in a distinct cell of the array. The
arrays allow us to keep track of the whole state of the system.
In the cryptographic proofs, the arrays used in the calculus
of CryptoVerif replace lists often used by cryptographers.
As an example of the use of lists, suppose that symmetric
encryption satisÔ¨Åes ciphertext integrity (INT-CTXT). This
assumption means that, when decryption succeeds, the con-
sidered ciphertext has been generated by calling the encryp-
tion function with the same secret key (provided the key is
not leaked). Then, one usually stores the computed cipher-
texts in a list, and upon decryption, one can additionally
check that the ciphertext is in the list. In our calculus, the
computed ciphertexts are always automatically stored in an
array, instead of a list, which avoids having to add explicit
list insertion instructions. The calculus provides an array
lookup construct, detailed in [11].
3.3 Authentication using CryptoVerif
Authentication in CryptoVerif is modeled by correspon-
dence properties [14]. Events e(M1, . . . , Mm) are used in or-
der to record that a certain program point has been reached,
with certain values of M1, . . . , Mm, and the correspondence
properties are properties of the form ‚Äúif some event has been
executed, then some other events also have been executed,
with overwhelming probability‚Äù.
More precisely, we distinguish two kinds of correspon-
dences.
dence event(e(M1, . . . , Mm)) ‚áí(cid:86)k
‚Ä¢ A process Q satisÔ¨Åes the non-injective correspon-
i=1 event(ei(Mi1, . . . ,
Mimi )) if and only if, with overwhelming probability,
for all values of the variables in M1, . . . , Mm,
if the
event e(M1, . . . , Mm) has been executed, then the events
ei(Mi1, . . . , Mimi ) for i ‚â§ k have also been executed for
some values of the variables of Mij (i ‚â§ k, j ‚â§ mi) not
in M1, . . . , Mm.
‚Ä¢ A process Q satisÔ¨Åes the injective correspondence
i=1 inj-event(ei(Mi1, . . . ,
Mimi )) if and only if, with overwhelming probability,
for all values of the variables in M1, . . . , Mm, for each
execution of the event e(M1, . . . , Mm), there exist dis-
tinct corresponding executions of the events ei(Mi1, . . . ,
Mimi ) for i ‚â§ k for some values of the variables of Mij
(i ‚â§ k, j ‚â§ mi) not in M1, . . . , Mm.
inj-event(e(M1, . . . , Mm)) ‚áí (cid:86)k
(Formal deÔ¨Ånitions can be found in [14]. CryptoVerif can
prove more general correspondences [14], but the correspon-
dences above were suÔ¨Écient for our study of Kerberos.)
3.4 Secrecy using CryptoVerif