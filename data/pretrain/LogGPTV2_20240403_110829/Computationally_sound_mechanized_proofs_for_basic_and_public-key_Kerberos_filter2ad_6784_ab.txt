### C 加密在 SK 下

图的最后一行显示了 S 的可选回复，该回复包括由认证器生成的时间戳，并使用 SK 进行加密。

尽管图 1 中未显示，CS 交换允许 C 和 S 协商一个用于未来通信的密钥 [34]。客户端可以在发送给 S 的认证器中（使用 AK 加密）提出一个密钥建议，而 S 可以在其回复给 C 的消息中（同样使用 AK 加密）提出一个密钥建议。在我们的分析中，我们假设 C 和 S 之间恰好有一个实体会以这种方式提议密钥。

### 2.2 PKINIT 扩展

PKINIT 扩展 [23] 替代了 Kerberos 基本的 AS 交换，允许使用公钥基础设施 (PKI) 来代替客户端 C 和 KAS K 之间的长期共享密钥。在这里，我们仅关注 PKINIT 的“公钥模式”，但 PKINIT 也可以在“Diffie-Hellman (DH) 模式”[23]下使用；最近的研究 [37] 表明 DH 模式的实现有限，而公钥模式已被所有主要操作系统实现。PKINIT 不改变 Kerberos 协议中的后续轮次。图 2 显示了当使用 PKINIT 时的 AS 交换过程。除了基本 Kerberos 第一条消息中发送的数据外，C 还向 K 发送她对时间戳 t''_C 和第二个随机数 n2 的签名，以及 C 的公钥证书。K 现在除了生成 AK 和 tK 外，还生成了一个新密钥 k。这个新密钥 k 代替了 kC 用来将 AK 传递给 C。k 被用 C 的公钥 pkC 加密后与 K 的公钥证书及一个基于 k 导出的密钥进行哈希运算得到的校验和 ck 一起发送给 C。此外，k 和 ck 都被 K 签名。（请注意，在这两条消息中，签名 [ ] 是通过在数据旁边发送签名数据来实现的。）

```
C
•
n1, n2, t''_C
• 
Cert_C, [t''_C, n2]skC, C, T, n1
{{Cert_K, [k, ck]skK}}pkC, C,
TGT, {AK, n1, tK, T}k
KAS
•-
k, AK
tK
•?
```

**图 2：修正版 PKINIT 中的消息流，其中 TGT = {AK, tK, C}kT。**

### 2.3 安全属性

我们现在非正式地陈述 Kerberos 的安全属性，涉及实体认证和密钥保密性。在第 4 节中，我们将使用 CryptoVerif 语言正式化这些安全属性，并在计算模型中呈现结果。

**属性 1（认证属性）**
a. **KAS 对客户端的认证**：如果客户端收到看似有效的来自 KAS 的响应，则该响应确实是由 KAS 为客户端生成的。
b. **请求 ST 的认证**：如果 TGS 收到一个有效的服务票证请求，则请求中的票证是由 KAS 生成的。此外，请求中包含的认证器是由客户端生成的。
c. **TGS 对客户端的认证**：如果客户端收到看似有效的来自 TGS 的服务票证请求响应，则该响应确实是由 TGS 为客户端生成的。
d. **对服务器的请求认证**：如果 S 收到一个有效的请求，声称来自 C，包含服务票证和会话密钥 SK，则某个 TGS 为 C 与 S 使用生成了会话密钥 SK 并创建了服务票证。此外，认证器是由 C 创建的。
e. **服务器对客户端的认证**：如果客户端收到看似有效的来自服务器 S 的响应，则该响应确实是由 S 生成的。

我们考虑两种不同的密钥保密性概念。一种是标准的密码学密钥保密性概念，另一种是密钥可用性概念 [21]（详见第 4.3 节）。需要注意的是，后者在 [4] 中未曾被考虑过。

**属性 2（保密属性）**
a. **AK 的保密性**：如果客户端完成与 KAS 的 AS 交换，则认证密钥 AK 在客户端发起 TS 交换（即第二轮）之前是密码学上保密的。
b. **SK 的保密性**：如果客户端完成与 TGS 的 TG 交换，则会话密钥 SK 在客户端发起 CS 交换（即第三轮）之前是密码学上保密的。
c. **AK 的可用性**：如果客户端完成与 TGS 的 TG 交换，或者 TGS 完成与客户端的交换，则认证密钥对于 IND-CCA2 安全加密是可用的。
d. **SK 的可用性**：如果客户端完成与服务器的 CS 交换，或者服务器完成与客户端的 CS 交换，则会话密钥对于 IND-CCA2 安全加密是可用的。

### 3. CryptoVerif

在本节中，我们简要概述 CryptoVerif，使用它形式化 Kerberos，并总结由 CryptoVerif 证明的认证和保密属性。

#### 3.1 CryptoVerif 基础

CryptoVerif 证明器 [11, 13, 14, 15] 可直接在计算模型中证明密码协议的安全属性。协议通过概率多项式时间进程演算来形式化，该演算受 pi 演算和 [25]、[32] 中引入的演算启发。在这个演算中，消息是位串，密码原语是对位串操作的函数。下面以 Kerberos 中的一段代码为例说明此演算。关于进程演算的更详细描述，请参见 [11]。

进程演算表示游戏，证明则表示为一系列游戏，其中初始游戏形式化了希望证明某些安全属性的协议。在一个证明序列中，两个连续的游戏 Q 和 Q' 是观察等价的，意味着它们对对手来说是计算不可区分的。CryptoVerif 通过应用密码原语的安全定义或语法转换将一个游戏转换为另一个游戏。在证明序列的最后一个游戏中，期望的安全属性应该是显而易见的。给定安全参数 η，CryptoVerif 证明在存在主动对手的情况下对多项式数量的协议会话有效。

CryptoVerif 有两种工作模式：全自动模式和交互模式。交互模式最适合使用不对称密码原语的协议，需要用户输入指示工具应执行的主要游戏转换的命令。CryptoVerif 对其证明中显示的安全属性是可靠的，但它无法证明的属性并不一定无效。

#### 3.2 在 CryptoVerif 中建模 Kerberos

作为示例，我们在进程演算中展示基本 Kerberos（AS 交换）第一轮中客户端角色的代码（完整的 CryptoVerif 脚本可在 http://www.cryptoverif.ens.fr/kerberos/ 获取）。

```
QC = !iC≤N c2[iC](hostT : tgs); new n1 : nonce;
c3[iC](<C, hostT, n1>);
c4[iC](= C, TGT : bitstring, m2 : bitstring);
let injbot(concat1(AK, = n1, tK, = hostT)) = dec(m2, kC) in
event fullCK(hostT, n1, TGT, m2)
```

**图 3：AS 交换中客户端动作的 CryptoVerif 形式化。**

复制过程 `!iC≤N P` 表示 N 个 P 的副本同时可用，其中 N 假设是安全参数 η 的多项式。这些副本由整数值 iC ∈ [1, N] 索引。每个副本从输入 `c2[iC](hostT : tgs)` 开始。该输入在通道 `c2[iC]` 上接收消息 `hostT`。通道由 iC 索引，因此，通过在特定值 i 的通道 `c2[i]` 上发送消息，对手可以选择哪个进程副本接收消息并随后执行。消息 `hostT` 是客户端将发送请求的票据授予服务器 (TGS) 的名称。类型 `tgs` 是一个包含所有可能的票据授予服务器名称表示的位串集合。只有当消息属于该类型时才会被接收。

接下来，进程通过构造 `new n1 : nonce` 从类型 `nonce` 中均匀选择一个随机数 n1。然后，进程在通道 `c3[iC]` 上发送协议的第一条消息 `<C, hostT, n1>`。这条消息将被对手接收；对手可以对其做任何事情，但在正常运行协议会话时，他应该将这条消息发送给 Kerberos 认证服务器 (KAS)。

在通道 `c3[iC]` 上发送消息后，控制权返回给对手，进程 `c4[iC](...); ...` 变得可用。该进程等待协议的第二条消息，并在通道 `c4[iC]` 上发送消息时执行。预期的消息是 `<C, TGT, m2> = <C, {AK, tK, C}kT, {AK, n1, tK, hostT}kC>`。在通道 `c4[iC]` 上接收到的消息由三部分组成：客户端名称 C、TGT 和消息 `m2 = {AK, n1, hostT}kC`。进程通过使用模式 `= C` 检查消息的第一部分是否为 C；其余两部分存储在变量中。

进程 QC 无法检查 TGT，因为它是在客户端没有的密钥下加密的。另一方面，QC 可以解密并检查 m2。它通过 `dec(m2, kC)` 解密 m2，并检查解密后的明文是否符合预期的随机数和 tgs。如果解密失败，它返回特殊符号 ⊥。函数 `injbot` 是从明文到位串和 ⊥ 的自然注入，因此，当 `injbot(x) = dec(m2, kC)` 时，解密成功且 x 是明文。进一步，预期的明文是 AK、n1、tK 和 hostT 的连接 `concat1(AK, n1, tK, hostT)`。假设连接函数 `concat1` 是可逆的，且其逆函数可在多项式时间内计算，以便 AK、n1、tK 和 hostT 可在多项式时间内从明文中恢复。这一假设在考虑到 Kerberos 数据结构时是合理的。QC 中的 `let` 构造检查明文是否具有所需的形式，并已知 n1 和 hostT 的值，将变量 AK 和 tK 绑定到接收到的值。

当检查失败时，控制权返回给对手。当所有检查都成功时，QC 执行事件 `fullCK(hostT, n1, TGT, m2)`。执行此事件不会影响协议的执行；它只是记录在某些变量值下达到某个程序点。事件用于指定认证属性，如第 3.3 节所述。执行事件后，控制权返回给对手。

在此演算中，所有在复制下定义的变量隐含为数组，由这些复制的索引索引。例如，由 `!iC≤N` 定义的变量 `hostT` 实际上是 `hostT[iC]`，因此每个复制的进程将其 `hostT` 值存储在数组的不同单元中。数组允许我们跟踪整个系统状态。在密码证明中，CryptoVerif 演算中使用的数组替换了密码学家常用的列表。

作为列表使用的一个例子，假设对称加密满足密文完整性 (INT-CTXT)。这意味着，当解密成功时，所考虑的密文是通过使用相同的密钥调用加密函数生成的（前提是密钥未泄露）。通常情况下，计算出的密文会被存储在一个列表中，在解密时可以额外检查密文是否在列表中。在我们的演算中，计算出的密文总是自动存储在一个数组中，而不是列表中，从而避免了添加显式的列表插入指令。演算提供了一个数组查找构造，详细信息见 [11]。

#### 3.3 使用 CryptoVerif 进行认证

CryptoVerif 中的认证通过对应属性 [14] 来建模。事件 `e(M1, ..., Mm)` 用于记录在某些变量值下达到某个程序点，而对应属性是形如“如果某个事件被执行，则其他某些事件也几乎肯定被执行”的属性。

更准确地说，我们区分两种类型的对应关系：
- **非注入对应**：过程 Q 满足非注入对应 `event(e(M1, ..., Mm)) => ∑(i=1 to k) event(ei(Mi1, ..., Mim))` 当且仅当，对于 M1, ..., Mm 的所有值，如果事件 `e(M1, ..., Mm)` 已被执行，则对于 i ≤ k 的事件 `ei(Mi1, ..., Mim)` 也几乎肯定已经执行，其中 Mi1, ..., Mim 的变量值不在 M1, ..., Mm 中。
- **注入对应**：过程 Q 满足注入对应 `inj-event(e(M1, ..., Mm)) => ∑(i=1 to k) inj-event(ei(Mi1, ..., Mim))` 当且仅当，对于 M1, ..., Mm 的所有值，对于每次 `e(M1, ..., Mm)` 的执行，存在唯一的对应执行 `ei(Mi1, ..., Mim)` 对于 i ≤ k 的 Mi1, ..., Mim 的变量值不在 M1, ..., Mm 中。

（正式定义请参见 [14]。CryptoVerif 可以证明更一般的对应关系 [14]，但对于我们的 Kerberos 研究而言，上述对应关系已经足够。）

#### 3.4 使用 CryptoVerif 的保密性