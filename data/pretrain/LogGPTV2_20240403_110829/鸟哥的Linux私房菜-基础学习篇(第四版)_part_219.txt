为了避免使用者自行编译的困扰，开发商自行在特定的硬件与操作系统平台上面预先编译好软件， 并将软件以特殊格式封包成文件，提
供终端用户直接安装到固定的操作系统上，并提供简单的查询/安装/移除等流程。 此称为软件管理员。常见的软件管理员有 RPM 与
DPKG 两大主流。
RPM 的全名是 RedHat Package Manager，原本是由 Red Hat 公司所发展的，流传甚广；
RPM 类型的软件中，所含有的软件是经过编译后的 binary program ，所以可以直接安装在使用者端的系统上， 不过，也由于如此，所以
RPM 对于安装者的环境要求相当严格；
RPM 除了将软件安装至使用者的系统上之外，还会将该软件的版本、名称、文件与目录配置、系统需求等等均记录于数据库
（/var/lib/rpm） 当中，方便未来的查询与升级、移除；
RPM 可针对不同的硬件等级来加以编译，制作出来的文件可于扩展名 （i386, i586, i686, x86_64, noarch） 来分辨；
RPM 最大的问题为软件之间的相依性问题；
SRPM 为 Source RPM ，内含的文件为 Source code 而非为 binary file ，所以安装 SRPM 时还需要经过 compile ，不过，SRPM 最大的
优点就是可以让使用者自行修改设置参数 （makefile/configure 的参数） ，以符合使用者自己的 Linux 环境；
RPM 软件的属性相依问题，已经可以借由 yum 或者是 APT 等方式加以克服。 CentOS 使用的就是 yum 机制。
yum 服务器提供多个不同的软件库放置个别的软件，以提供用户端分别管理软件类别。
情境仿真题：通过 EPEL 安装 NTFS 文件系统所需要的软件
目标：利用 EPEL 提供的软件来搜寻是否有 NTFS 所需要的各项模块！；
目标：你的 Linux 必须要已经接上 Internet 才行；
需求：最好了解磁盘容量是否够用，以及如何启动服务等。
其实这个任务非常简单！因为我们在前面各小节的说明当中已经说明了如何设置 EPEL 的 yum 配置文件，此时你只要通过下面的方式来处理
即可：
使用 yum --enablerepo=epel search ntfs 找出所需要的软件名称
再使用 yum --enablerepo=epel install ntfs-3g ntfsprogs 来安装即可！
简答题部分：
如果你曾经修改过 yum 配置文件内的软件库设置 （/etc/yum.repos.d/*.repo） ，导致下次使用 yum 进行安装时老是发现错误， 此时你该
如何是好？
先确认你的配置文件确实是正确的，如果没问题，可以将 yum 的高速缓存清除，使用“yum clean all”即可。 事实上， yum 的所有高速缓存、下载软
件、下载软件的表头数据，都放置于 /var/cache/yum/ 目录下。
简单说明 RPM 与 SRPM 的异同？
RPM 文件是由程序打包者 （通常是由 distribution 的开发商） 借由程序的源代码，在特定的平台上面所编译成功的 binary program 的数据，并将该数
据制作成为 RPM 的格式，以方便相同软、硬件平台的使用者之安装使用。 在安装时显的很简单，因为程序打包者的平台与使用者所使用的平台默认为相
同。
至于 SRPM 则是借由与 RPM 相同的配置文件数据，不过将源代码直接包在 SRPM 文件当中，而不经过编译。 因为 SRPM 所内含的数据为源代码，所以安装
时必须要再经过编译的行为才能成为 RPM 并提供使用者安装。
假设我想要安装一个软件，例如 pkgname.i386.rpm ，但却老是发生无法安装的问题，请问我可以加入哪些参数来强制安装他？
可以加入 --nodeps 等参数。例如 rpm -ivh --nodeps pkgname.i386.rpm
承上题，你认为强制安装之后，该软件是否可以正常执行？为什么？
一般来说，应该是“不能执行”的，因为该软件具有相依属性的问题， 某些时刻该软件的程序可能需要调用外部的函数库，但函数库可能未安装，因此当
然无法执行成功。
有些人使用 CentOS 7.x 安装在自己的 Atom CPU 上面，却发现无法安装，在查询了该原版光盘的内容，发现里面的文件名称为
***.x86_64.rpm 。请问，无法安装的可能原因为何？
Atom 虽然也是属于 x86 的架构，但是某些 atom 是属于 32 位的系统。但是 CentOS 7 已经仅释出 64 位的版本，所以当然无法安装了！
请问我使用 rpm -Fvh *.rpm 及 rpm -Uvh *.rpm 来升级时，两者有何不同？
-Uvh 后面接的软件，如果原本未安装，则直接安装，原本已安装时，则直接升级；
-Fvh 后面接的软件，如果原本未安装，则不安装，原本已安装时，则直接升级；
假设有一个厂商推出软件时，自行处理了数码签章，你想要安装他们的软件所以需要使用数码签章，假设数码签章的文件名为 signe，
那你该如何安装？
rpm --import signe
承上，假设该软件厂商提供了 yum 的安装网址为： http://their.server.name/path/ ，那你该如何处理 yum 的配置文件？
可以自行取个文件名，在此例中我们使用“ vim /etc/yum.repos.d/their.repo ”，扩展名要正确！ 内容有点像这样即可：
[their]
name=their server name
baseurl=http://their.server.name/path/
enable=1
gpgcheck=0
然后使用 yum 去安装该软件看看。
[1]GNU Privacy Guard （GPG） 官方网站的介绍：http://www.gnupg.org/
RPM 包装文件管理程序：http://www.study-area.org/tips/rpm.htm
中文 RPM HOW-TO：http://www.linux.org.tw/CLDP/RPM-HOWTO.html
RPM 的使用：http://linux.tnc.edu.tw/techdoc/rpm-howto.htm
大家来作 RPM ：http://freebsd.ntu.edu.tw/bsd/4/3/2/29.html
一本 RPM 的原文书：http://linux.tnc.edu.tw/techdoc/maximum-rpm/rpmbook/
台湾网络危机处理小组：http://www.cert.org.tw/
2002/08/21：第一次完成
2003/02/11：重新编排与加入 FAQ
2004/04/11：已经完成了 Source code 与 Tarball ，开始进行 RPM 与 SRPM 的介绍！（需要耗时多日啊！因为又要进兵营去了！）
2004/04/20：终于给他熬出来啦！又是过了两个休假期间～啊！给我退伍令、其余免谈！
2005/10/02：旧版的 SRPM 数据已经移动到 此处 。
2005/10/03：旧版的针对 Red Hat 与 Mandriva 的版本移动到 此处。
2005/10/03：将原本去年的版本改为 FC4 为范例的模样！
2009/06/20：原本的针对 FC4 写的旧版文章移动到此处。
2009/09/18：加入了简单的情境仿真，也加入了一些关于 yum 的习题喔！
2015/10/16：加入了 ELRepo 这个专门提供核心给 CentOS 使用的软件库功能介绍！
第第第第二二二二十十十十三三三三章章章章、、、、XX WWiinnddooww 设设设设置置置置介介介介绍绍绍绍
最近更新日期：2015/09/19
苏 Linux ­ 垒瘨嚢弆捉厇憵亐禔ÿ ã X Window System，笤禔ã X 憺 X11 唔！ ã 仹禔ÿ ã 粟纃吆？载旓嚄ã X 稻厇粟纃卬幂ã X server ³ X client
，敩烚旓 Server/Client （ä 乲杚木） 载寕蠌磞儚孂 X 稻厇粟纃旓厓争趌绵纀º 趌帗厔瘨！X 稻厇粟纃宝串 Linux 有讘乩旓 Ð 挽亚， 厎旓载Ð 挽亚斉贯酱褥念！
嚄ã Linux 旓及股壃苏柰霆瓙肵­ 霆泥蟰，³ 载Ð X 稻厇粟纃暭儗唊！ 夡苏，皒凯瘨 X 稻厇粟纃攘厬凔 Linux 嶖缴霂巜亼祤个，羰º 七股壃儛暭 3D 刭迃瘨剃股，
厎旓，憵亐轼旓弻褥个霸 ® X 稻厇粟纃懱夡，载柛夦杀冞闲赖，憵亐懱暭剂汹墨玪哮！
Unix Like 操作系统不是只能进行服务器的架设而已，在美编、排版、制图、多媒体应用上也是有其需要的。 这些需求都需要用到图形
接口 （Graphical User Interface, GUI） 的操作的， 所以后来才有所谓的 X Window System 这玩意儿。那么为啥图形窗口接口要称为 X 呢？因
为就英文字母来看 X 是在 W（indow） 后面，因此，人们就戏称这一版的窗口接口为 X 啰 （有下一版的新窗口之意）！
事实上， X Window System 是个非常大的架构，他还用到网络功能呢！也就是说，其实 X 窗口系统是能够跨网络与跨操作系统平台
的！ 而鸟哥这个基础篇是还没有谈到服务器与网络主从式架构，因此 X 在这里并不容易理解的。不过，没关系！ 我们还是谈谈 X 怎么来的，
然后再来谈谈这 X 窗口系统的元件有哪些，慢慢来，应该还是能够理解 X 的啦！
X Window 系统最早是由 MIT （Massachusetts Institute of Technology, 麻省理工学院） 在 1984 年发展出来的， 当初 X 就是在 Unix 的
System V 这个操作系统版本上面开发出来的。在开发 X 时，开发者就希望这个窗口接口不要与硬件有强烈的相关性，这是因为如果与硬件的
相关性高，那就等于是一个操作系统了， 如此一来的应用性会比较局限。因此 X 在当初就是以应用程序的概念来开发的，而非以操作系统来
开发。
由于这个 X 希望能够通过网络进行图形接口的存取，因此发展出许多的 X 通讯协定，这些网络架构非常的有趣， 所以吸引了很多厂商
加入研发，因此 X 的功能一直持续在加强！一直到 1987 年更改 X 版本到 X11 ，这一版 X 取得了明显的进步， 后来的窗口接口改良都是架构
于此一版本，因此后来 X 窗口也被称为 X11 。这个版本持续在进步当中，到了 1994 年发布了新版的 X11R6 ，后来的架构都是沿用此一释出
版本，所以后来的版本定义就变成了类似 1995 年的 X11R6.3 之类的样式。 [1]
1992 年 XFree86 （http://www.xfree86.org/） 计划顺利展开， 该计划持续在维护 X11R6 的功能性，包括对新硬件的支持以及更多新增
的功能等等。当初定名为 XFree86 其实是根据“ X + Free software + x86 硬件 ”而来的呢。早期 Linux 所使用的 X Window 的主要核心都是由
XFree86 这个计划所提供的，因此，我们常常将 X 系统与 XFree86 挂上等号的说。
不过由于一些授权的问题导致 XFree86 无法继续提供类似 GPL 的自由软件，后来 Xorg 基金会就接手 X11R6 的维护！ Xorg
（http://www.x.org/） 利用当初 MIT 发布的类似自由软件的授权， 将 X11R6 拿来进行维护，并且在 2004 年发布了 X11R6.8 版本，更在 2005
年后发表了 X11R7.x 版。 现在我们 CentOS 7.x 使用的 X 就是 Xorg 提供的 X11R7.X 喔！ 而这个 X11R6/X11R7 的版本是自由软件，因此很
多组织都利用这个架构去设计他们的图形接口喔！包括 Mac OS X v10.3 也曾利用过这个架构来设计他们的窗口呢！我们的 CentOS 也是利用
Xorg 提供的 X11 啦！
从上面的说明，我们可以知道的是：
在 Unix Like 上面的图形使用者接口 （GUI） 被称为 X 或 X11；
X11 是一个“软件”而不是一个操作系统；
X11 是利用网络架构来进行图形接口的执行与绘制；
较著名的 X 版本为 X11R6 这一版，目前大部分的 X 都是这一版演化出来的 （包括 X11R7）；
现在大部分的 distribution 使用的 X 都是由 Xorg 基金会所提供的 X11 软件；
X11 使用的是 MIT 授权，为类似 GPL 的开放源代码授权方式。
如同前面谈到的，X Window system 是个利用网络架构的图形使用者接口软件，那到底这个架构可以分成多少个元件呢？ 基本上是分成
X Server 与 X Client 两个元件而已喔！其中 X Server 在管理硬件，而 X Client 则是应用程序。 在运行上，X Client 应用程序会将所想要呈现的
画面告知 X Server ，最终由 X server 来将结果通过他所管理的硬件绘制出来！ 整体的架构我们大约可以使用如下的图示来作个介绍：[2]
图23.1.1、X Window System 的架构
上面的图示非常有趣喔！我们在用户端想要取得来自服务器的图形数据时，我们用户端使用的当然是用户端的硬件设备啊， 所以，X
Server 的重点就是在管理用户端的硬件，包括接受键盘/鼠标等设备的输入信息， 并且将图形绘制到屏幕上 （请注意上图的所有元件之间的箭
头指示）。但是到底要绘制个啥东西呢？ 绘图总是需要一些数据才能绘制吧？此时 X Client （就是 X 应用程序） 就很重要啦！他主要提供的
就是告知 X Server 要绘制啥东西。那照这样的想法来思考，我们是想要取得远端服务器的绘图数据来我们的计算机上面显示嘛！ 所以啰，远
端服务器提供的是 X client 软件啊！
下面就让我们来更深入的聊一聊这两个元件吧！
X Server：：硬硬件件管管理理、、屏屏幕幕绘绘制制与与提提供供字字体体功功能能：：
既然 X Window System 是要显示图形接口，因此理所当然的需要一个元件来管理我主机上面的所有硬件设备才行！ 这个任务就是 X
Server 所负责的。而我们在 X 发展简史当中提到的 XFree86 计划及 Xorg 基金会，主要提供的就是这个 X Server 啦！那么 X Server 管理的设
备主要有哪些呢？其实与输入/输出有关喔！包括键盘、鼠标、手写板、显示器 （monitor） 、屏幕分辨率与色彩深度、显卡 （包含驱动程序）
与显示的字体等等，都是 X Server 管理的。
咦！显卡、屏幕以及键盘鼠标的设置，不是在开机的时候 Linux 系统以 systemd 的相关设置处理好了吗？ 为何 X Server 还要重新设置
啊？这是因为 X Window 在 Linux 里面仅能算是“一套很棒的软件”， 所以 X Window 有自己的配置文件，你必须要针对他的配置文件设置妥当
才行。也就是说， Linux 的设置与 X Server 的设置不一定要相同的！因此，你在 CentOS 7 的 multi-user.target 想要玩图形接口时，就得要载入
X Window 需要的驱动程序才行～总之， X Server 的主要功能就是在管理“主机”上面的显示硬件与驱动程序。
既然 X Window System 是以通过网络取得图形接口的一个架构，那么用户端是如何取得服务器端提供的图形画面呢？ 由于服务器与用
户端的硬件不可能完全相同，因此我们用户端当然不可能使用到服务器端的硬件显示功能！ 举例来说，你的用户端计算机并没有 3D 影像加速