Keystone. Keystone [21] is an open-source research framework
for developing customized TEEs in RISC-V processors. Keystone
adopts a “secure world” view similar to ARM TrustZone [34] where
a privileged security monitor software layer separates enclaves in
their own address spaces, potentially including explicit shared mem-
ory regions. Keystone enclaves feature a trusted runtime which in-
tercepts system calls and transparently tunnels all untrusted world
interactions through the underlying security monitor.
Sancus. The Sancus research TEE [32] offers lightweight en-
clave isolation and attestation on an embedded 16-bit TI MSP430
processor featuring a plain single-address-space without virtual
memory. A dedicated C compiler automates enclave creation and in-
cludes a small trusted runtime library that is transparently invoked
on enclave entry/exit. Trusted software may additionally provide
code confidentiality [14] or authentic execution [31] guarantees.
2.3 Related work
Microsoft Open Enclave SDK. Microsoft developed the open-
source Open Enclave (OE) SDK with the purpose of facilitating
TEE-agnostic production enclave development [29]. Currently, OE
OS system call interface. During the last decade, significant
research efforts have been made to discover and mitigate vulnera-
bilities in OS kernels, such as missing pointer checks, uninitialized
OSHardwareSecurity monitorHardwareOSAppSharedmemoryURTSHost application (shared memory)TRTSEnclaved	binarySSAEnclaved	binaryTRTSSecure worldNormal worlddata leakage, or buffer and integer overflows [6]. By exploiting
a single vulnerability in a kernel, unprivileged adversaries may
read or write arbitrary memory and gain root access. While these
vulnerabilities continue to be relevant in modern kernels, they are
generally well understood by the OS security community. However,
they have received less attention in the context of TEEs.
Checkoway et al. [4] first demonstrated that an untrusted OS can
perform so called Iago attacks to compromise legacy applications
by supplying maliciously crafted pointers or lengths as the return
value of a traditionally trusted system call like malloc(). These
attacks are closely related to a small subset of the vulnerabilities
described in this work, specifically attack vector #9, which exploits
that pointers or buffer sizes returned by untrusted ocalls may
not be properly sanitized (cf. Section 5.5). Our work generalizes
Iago attacks from the OS system call interface to ocalls in general,
and more broadly shows that Iago attacks are but one instance
of adversarial OS interactions. We show for instance that legacy
applications may also make implicit assumptions on the validity of
argv and envp pointers, which are not the result of system calls.
Memory corruption attacks on ARM TrustZone. ARM Trust-
Zone [34] was one of the first widely deployed TEEs, particularly
in mobile devices, and hence received considerable attention from
security researchers. The code running in the secure world largely
depends on the device manufacturer, with widely used runtimes
including Trustonic Kinibi, Qualcomm’s QSEE, Google’s Trusty,
and the open-source project OP-TEE. Over the past years, several
vulnerabilities [33, 34] have been discovered in TrustZone runtimes
caused by e.g., missing or incorrect pointer range or length checks,
or incorrect handling of integer arithmetic. Often, these vulnera-
bilities rely on the existence of a shared memory region for data
exchange between the normal and secure worlds: if an adversary
passes a pointer into trusted memory where a pointer to shared
memory is expected, memory corruption or disclosure may occur
when the pointer is not properly validated by the trusted runtime.
Machiry et al. [27] presented a related class of Boomerang attacks,
which leverage the fact that TrustZone’s secure world OS has full
access to untrusted memory, including the regions used by the
untrusted OS. Boomerang exploits that trusted pointer sanitization
logic may only validate that pointers lie outside of secure memory,
allowing unprivileged code executing in the normal world to read
or write memory locations belonging to other applications or the
untrusted OS. In a sense, Boomerang vulnerabilities are orthogonal
to a subset of the vulnerabilities described in this paper: both target
incorrect pointer checks within trusted code, but while Boomerang
attacks relate to checks of pointers into untrusted memory, we focus
on pointers into trusted memory.
Memory corruption attacks on Intel SGX. Lee et al. [22] were
the first to execute a completely blind memory corruption attack
against SGX by augmenting code reuse attack techniques [41] with
several side-channel oracles. To successfully mount this attack, ad-
versaries require kernel privileges and a static enclave memory lay-
out. Recently, these techniques were improved by Biondo et al. [3]
to allow even non-privileged adversaries to hijack vulnerable en-
claves in the presence of fine-grained address space randomiza-
tion [40]. Their approach is furthermore made application-agnostic
by leveraging gadgets found in the trusted runtime library of the
official Intel SGX-SDK. In a perpendicular line of research, Schwarz
et al. [38] criticized SGX’s design choice of providing enclaves with
unlimited access to untrusted memory outside the enclave. They
demonstrated that malware code executing inside an SGX enclave
can mount stealthy code reuse attacks to hijack control flow in the
untrusted host application.
Importantly, all previous SGX memory safety research focused
on contributing novel exploitation techniques while assuming the
prior presence of a vulnerability in the enclave code itself. Hence,
those results are complementary to the vulnerabilities described in
this work. We have indeed demonstrated control flow hijacking for
some of the pointer sanitization issues below, and these may further
benefit from exploitation techniques developed in prior work.
3 METHODOLOGY AND ADVERSARY MODEL
3.1 Attacker model
We consider systems with hardware support for a TEE and where
a trusted runtime supports the secure, shielded execution of an en-
claved binary produced by the application developer. With enclaved
binary, we specifically mean that the binary is the output of a stan-
dard compiler, which is not aware of the TEE. It is the responsibility
of the shielding runtime to preserve intended program semantics
in a hostile environment. We focus exclusively on vulnerabilities
in the TEE runtime and assume that there are no application-level
memory safety vulnerabilities in the enclaved binary.
We assume the standard TEE attacker model [28], where ad-
versaries have full control over all software executing outside the
hardware-protected memory region. This is a powerful attacker
model, allowing the adversary to, for instance, modify page table
entries [47, 54], or precisely execute the victim enclave one instruc-
tion at a time [45]; yet, this is the attacker that TEEs are designed
to defend against. It is important to note that some of the attacks
we discuss can also be launched by significantly less privileged
attackers, i.e., with just user-level privileges to invoke the enclave.
3.2 Research methodology
Our objective is to pinpoint enclave shielding responsibilities, and to
find vulnerabilities where real-world TEE runtimes fail to safeguard
implicit interface assumptions made by the enclaved binary.
TEE runtime code review. We base our research on manual
code review, and hence limited our study to open-source TEE run-
times. After reviewing the literature and code repositories, we
selected 8 popular runtimes to be audited. Our resulting selection
allows to compare tendencies in (i) production vs. research code
bases; (ii) SDK vs. libOS-based shielding abstractions; (iii) unsafe
C/C++ vs. safe Rust programming languages; and (iv) underly-
ing TEE design dependencies. Note that we opted not to include
baidu-rust-sgx, as it is merely a layer on top of Intel SGX-SDK (and
hence inherits all vulnerabilities of the latter). After reviewing prior
research [33] and relevant code, we found that sanitization in the
TrustZone runtime OP-TEE has already been thoroughly vetted
and we hence decided not to systematically audit this runtime. For
each of the selected TEE runtime implementations, we then re-
viewed the sanitizations and defensive checks implemented by the
trusted runtime between entering the TEE and transferring control
Table 1: Enclave runtime vulnerability assessment (our contribution, highlighted) and comparison to related work on OSs and
TEEs. Symbols indicate whether a vulnerability was successfully exploited (⋆); acknowledged but without proof-of-concept
((cid:32)); or not found to apply ((cid:35)). Half-filled symbols (⋆,(cid:71)(cid:35)) indicate that improper sanitization only leads to side-channel leakage.
Vulnerability
Runtime
n cla v e
K
O
E
p e n
h e n e
S
G
S
D
X - S
⋆
K
L
R
G
X - L
(cid:32)
(cid:32)
⋆
⋆
⋆
⋆
G r a p
(cid:71)(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:32)
(cid:35)
⋆
(cid:35)
(cid:35)
⋆
⋆
Tier1
(ABI)
⋆
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
[23]
#1 Entry status flags sanitization
#2 Entry stack pointer restore
#3 Exit register leakage
#4 Missing pointer range check
#5 Null-terminated string handling
#6 Integer overflow in range check
#7 Incorrect pointer range check
#8 Double fetch untrusted pointer
#9 Ocall return value not checked
#10 Uninitialized padding leakage
⋆
⋆
(cid:35)
(cid:35)
(cid:35)
⋆
⋆
Tier2
(API)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
to the enclaved binary, and the symmetrical path when exiting the
TEE. We found new vulnerabilities in all studied runtimes. Table 1
summarizes our findings, structured according to the respective
vulnerability classes, and relating to similar vulnerabilities in the
Linux kernel and prior TEE research. Our systematization revealed
10 distinct attack vectors across 2 subsequent tiers of TEE shielding
responsibilities, explored in Sections 4 and 5, respectively.
In our code review, we focus our attention on the assumptions
that an enclaved binary makes about two key interfaces, and we
consider both integrity and confidentiality concerns. A first level of
interface sanitization we inspect is the ABI, which unambiguously
specifies function calling conventions regarding the low-level ma-
chine state expected by the compiler [10]. We manually locate the
trusted runtime entry point, and review how the compact assembly
routine establishes a trustworthy ABI state on entry, and similarly
scrubs residual CPU state on exit. The second key interface, that
we refer to as the API, is the functional interface of the enclaved
binary. We review how the TEE runtime validates different kinds
of arguments passed in through an ecall or as the return value
of an ocall. We focus in particular on the handling of pointers
and strings, where it is the TEE runtime’s responsibility to ensure
that variable-sized buffers lie entirely outside the enclave before
copying them inside and transferring execution to the enclaved
binary. For confidentiality, we check again that all memory copied
outside the TEE only contains explicit return values, and that no
avoidable side-channel leakage is introduced.
TEE design considerations. The communication between en-
clave and untrusted code for all TEE runtimes considered in this
paper relies on some form of “world-shared memory”, i.e., a mem-
ory region that is accessible to both trusted and untrusted code.
Depending on the specific TEE design (cf. Fig. 1), this can be re-
alized by either embedding the enclave in the address space of
a surrounding host process, as in Intel SGX [8] or Sancus [32],
or by explicitly mapping a dedicated virtual memory region into
both worlds as in ARM TrustZone [34] and Keystone [21]. Prior
research has mainly explored interface sanitization vulnerabilities
in ARM TrustZone TEEs (cf. Section 2.3). Given the prevalence of
SGX in contemporary Intel processors, our study focuses largely
u st- E
(cid:71)(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
P
D
A s ylo
(cid:32)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:32)
(cid:32)
K
e y st o
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
⋆
⋆
⋆
n e
S a n c u s
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:35)
(cid:35)
⋆
⋆
x
u
L i n
[9]
(cid:35)
(cid:35)
[6]
[6]
[6]
(cid:35)
[37, 53]
–
[7]
Prior TEE attack research
SGX Dark-ROP exploitation [3, 22]
TrustZone exploits [33, 34]
TrustZone exploits [33, 34]
SGX AsyncShock framework [50]
Iago attacks (Linux system call interface) [4]
SGX-SDK edger8r struct leakage [23]
on SGX-style single-address-space TEE designs as used in 7 out of 8