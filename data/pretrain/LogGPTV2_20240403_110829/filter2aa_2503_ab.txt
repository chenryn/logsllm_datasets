        sprintf(tmp,"PIN correct\r\n");
    } else {
        sprintf(tmp,"PIN %s is 
                     incorrect\r\
n",pin);
    }
    printf(tmp);
    return result;
}
// Authenticate PIN. 
// Return true if incorrect
bool pinAuthentication() {
    char pin[80];
    char tmp[80];
    bool result=false;
    printf("Please, introduce PIN\r\n");
    gets(pin);
    result = comparePIN(pin);
    if (result == false) {
        sprintf(tmp,"PIN correct\r\n");
    } else {
        sprintf(tmp,"PIN %s is 
                     incorrect\r\
n",pin);
    }
    printf(tmp);
    return result;
}
Bypassing authentications
Unified Diagnostic Services
Unified
Diagnostic
Services
UDS authentication
FI
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
/ /  
Gl i t ch
el se 
aut hent i cat ed( ) ;  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
/ /  
Gl i t ch
el se 
aut hent i cat ed( ) ;  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;  
Bypassing UDS auth with FI
Bypassing Secure Boot
Secure Boot
Internal
Boot ROM
2nd Stage
Boot Loader
Nth Stage
Boot Loader
OS loader
Application
Loader
Verify signature
& decrypt
Verify signature
& decrypt
Verify signature
& decrypt
Verify signature
& decrypt
Less privileges
Bypassing Secure Boot
Bypassing Secure Boot
//Verify image. Returns true is correct
bool verifyImage(uint8_t *image,
       uint32_t len, uint8_t *sign, rsaKey) {
    char *hash1, *hash2;
    ...
    // Calculate Hash
    calculateHash(image,len,hash1)
    // Verify signature
    verifySignature(sign, rsaKey, hash2)
    // Compare hashes
    if (memcmp(hash1, hash2, HASH_LEN) != 0)
        return false;
    else
        return true; 
}
//Verify image. Returns true is correct
bool verifyImage(uint8_t *image,
       uint32_t len, uint8_t *sign, rsaKey) {
    char *hash1, *hash2;
    ...
    // Calculate Hash
    calculateHash(image,len,hash1)
    // Verify signature
    verifySignature(sign, rsaKey, hash2)
    // Compare hashes
    if (memcmp(hash1, hash2, HASH_LEN) != 0)
        return false;
    else
        return true; 
}
void boot() {
void (*entryPoint)(void);
...
// Load image to buffer
uint32_t len = loadFlashImage(imgBuf)
// Verify image
if (verifyImage(imgBuf, len, sign,
  rsaKey) == false) {
goto reset; // Auth failed
}
// Jump to image
entryPoint = imgbuf;
(*entryPoint)();
...
}
void boot() {
void (*entryPoint)(void);
...
// Load image to buffer
uint32_t len = loadFlashImage(imgBuf)
// Verify image
if (verifyImage(imgBuf, len, sign,
  rsaKey) == false) {
goto reset; // Auth failed
}
// Jump to image
entryPoint = imgbuf;
(*entryPoint)();
...
}
Do you remember the FI rule #2?
Protecting a Secure Boot can be a nightmare!
FISim Demo
Escalating privileges
Escalating privileges
User space
Kernel 
space
REE
TEE
REE-TEE separation
REE
CPU
TEE
CPU
REE memory
Shared memory
(mailbox)
TEE memory
Wild Jungle Jump Attack
REE
CPU
TEE
CPU
Mailbox
Payload
Payload Address
Payload Address
Payload Address
Payload Address
…
Write message
Read message
Wild Jungle Jump Attack
REE
CPU
Write message
TEE
CPU
Mailbox
Payload
Payload Address
Payload Address
Payload Address
Payload Address
…
Read message
Wild Jungle Jump Attack
TEE
CPU
Mailbox
Payload
Payload Address
Payload Address
Payload Address
Payload Address
…
Read message
 memcpy(dst,src,len);
 memcpy(dst,src,len);
...
loop:
  ldr r0, [r3], #4
  str r0, [r4], #4
...
...
loop:
  ldr r0, [r3], #4
  str r0, [r4], #4
...
11100100101100110000000000000100
11100100101100110000000000000100
11100100101100111111000000000100
11100100101100111111000000000100
Wild Jungle Jump Attack
TEE
CPU
Mailbox
Payload
Payload Address
Payload Address
Payload Address
Payload Address
…
Read message
 memcpy(dst,src,len);
 memcpy(dst,src,len);
...
loop:
  ldr r0, [r3], #4
  str r0, [r4], #4
...
...
loop:
  ldr r0, [r3], #4
  str r0, [r4], #4
...
11100100101100110000000000000100
11100100101100110000000000000100
...
loop:
  ldr pc, [r3], #4
  str r0, [r4], #4
...
...
loop:
  ldr pc, [r3], #4
  str r0, [r4], #4
...
  Payload();
  Payload();
Escalating privileges
Recovering crypto keys
Recovering crypto keys
FAULT ANALYSIS
DFA
Differential Fault Analysis
CFA
Collision Fault Analysis
SFA
Statistical Fault Analysis
DFIA
Differential Fault 
Intensity Analysis
IFA
Ineffective Fault Analysis
SIFA
Statistical Ineffective 
Fault Analysis 
b0,0
b0,1
b0,2
b0,3
b1,0
b1,1
b1,2
b1,3
b2,0
b2,1
b2,2
b2,3
b3,0
b3,1
b3,2
b3,3
b0,0
b0,1
b0,2
b0,3
b1,0
b1,1
b1,2
b1,3
b2,0
b2,1
c2,2
b2,3
b3,0
b3,1
b3,2
b3,3
AES Fault Analysis
FI on key attributes
Key
Attributes
Key 1
AES
ENC
Key 2
3DES
DEC
Key 3
AES/3DES
ENC/DEC
…
…
…
Crypto engine
3DES
DES
AES
Key
Attributes
Key 1
AES
ENC
Key 2
3DES
DEC
Key 3
AES/3DES
ENC/DEC
…
…
…
Keyslot
Key
Attributes
Key 1
AES
ENC
Key 2
3DES
DEC
Key 3
AES/3DES
ENC/DEC
…
…
…
FI on key attributes
Key
Attributes
Key 1
DES
ENC
Key 2
3DES
DEC
Key 3
AES/3DES
ENC/DEC
…
…
…
Crypto engine
3DES
DES
AES
Keyslot
Recovering crypto keys
Modifying security 
configuration
Preventing the configuration
// Read fuses and configure security modules
bool disableJtag = readFuse(DISABLE_JTAG);
bool enableMemoryScrambler = 
 readFuse(ENABLE_MEM_SCRAMBLER);
bool enableTEE = readFuse(ENABLE_TEE);
if (disableJtag==true)
    closeJtag();
if (enableMemoryScrambler==true)
    configureMemoryScrambler();
if (enableTEE==true)
    configureTEE();
// Read fuses and configure security modules
bool disableJtag = readFuse(DISABLE_JTAG);
bool enableMemoryScrambler = 
 readFuse(ENABLE_MEM_SCRAMBLER);
bool enableTEE = readFuse(ENABLE_TEE);
if (disableJtag==true)
    closeJtag();
if (enableMemoryScrambler==true)
    configureMemoryScrambler();
if (enableTEE==true)
    configureTEE();
void boot() {
void (*entryPoint)(void);
...
// Load image to buffer
uint32_t len = loadFlashImage(imgBuf)
// Verify image
if (verifyImage(imgBuf, len, sign,
  rsaKey) == false) {
goto reset; // Auth failed
}
// Jump to image
entryPoint = imgbuf;
(*entryPoint)();
...
}
void boot() {
void (*entryPoint)(void);
...
// Load image to buffer
uint32_t len = loadFlashImage(imgBuf)
// Verify image
if (verifyImage(imgBuf, len, sign,
  rsaKey) == false) {
goto reset; // Auth failed
}
// Jump to image
entryPoint = imgbuf;
(*entryPoint)();
...
}
Localized Fault Injection
Electro-Magnetic FI
Laser FI
Laser Fault Injection
EM Fault Injection
Preventing FI
FI countermeasures
VS
HW
SW
Fault Injection Rule #3
HW countermeasures
1.8V
Glitch Sensors
Redundancy
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
/ /  
Gl i t ch
el se 
aut hent i cat ed( ) ;  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
/ /  
Gl i t ch
el se 
aut hent i cat ed( ) ;  
SW countermeasure #1
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
   / /  
Gl i t ched
. . .
/ /  Do somet hi ng el se
. . .  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
   / /  
Gl i t ched
. . .
/ /  Do somet hi ng el se
. . .  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
. . .
/ /  Do somet hi ng el se
. . .  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
. . .
/ /  Do somet hi ng el se
. . .  
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;
SW countermeasure #1
sl eep( r and( ) ) ;
/ /  Random del ay
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;  
sl eep( r and( ) ) ;
/ /  Random del ay
i f  ( r ecei vedKey ! = expect edKey)
not _aut hent i cat ed( ) ;
el se 
aut hent i cat ed( ) ;  
SW countermeasure #2
Conclusions
Remember the rules!
More information:
Protecting software against FI
https://www.riscure.com/uploads/2018/11/201708_Riscure_Whitepaper_Side_Channel_Patterns.pdf
FI on UDS:
https://www.riscure.com/uploads/2018/06/
Riscure_Whitepaper_Fault_injection_on_automotive_diagnostic_protocols.pdf
Bypassing secure boot
https://www.riscure.com/uploads/2017/10/eu-16-Timmers-Bypassing-Secure-Boot-Using-Fault-
Injection.pdf
Linux privileges escalation:
https://www.riscure.com/uploads/2017/10/
Riscure_Whitepaper_Escalating_Privileges_in_Linux_using_Fault_Injection.pdf
Optical FI
https://www.riscure.com/uploads/2017/09/Practical-optical-fault-injection-on-secure-
microcontrollers.pdf
Wild Jungle Jump attack
https://www.riscure.com/uploads/2017/09/Controlling-PC-on-ARM-using-Fault-Injection.pdf
Practical DFA
https://www.slideshare.net/secret/K8jlDL4os1evrW
WE ARE HIRING!
Shanghai
Delf t 
(Netherlands)
San 
Riscure North America 
550 Kearny St. 
Suite 330 
San Francisco, CA 94108 
+1 (650) 646 9979
PI:EMAIL 
Riscure B.V. 
Frontier Building, Delftechpark 49 
2628 XJ  Delft 
The Netherlands 
Phone: +31 15 251 40 90 
www.riscure.com
Contact:
Riscure China 
2081, No.989, Changle Road
200031 Shanghai
China
Phone: +86 21 5117 5440
Wechat: RiscureChina
Ramiro Pareja
PI:EMAIL