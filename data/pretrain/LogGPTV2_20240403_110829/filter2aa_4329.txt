### 64位程序格式化字符串漏洞原理
其实 64 位的偏移计算和 32 位类似，都是算对应的参数。只不过 64 位函数的前 6 个参数是存储在相应的寄存器中的。那么在格式化字符串漏洞中呢？虽然我们并没有向相应寄存器中放入数据，但是程序依旧会按照格式化字符串的相应格式对其进行解析。
### hijack GOT原理
在目前的 C 程序中，libc 中的函数都是通过 GOT 表来跳转的。此外，在没有开启 RELRO 保护的前提下，每个 libc 的函数对应的 GOT 表项是可以被修改的。因此，我们可以修改某个 libc 函数的 GOT 表内容为另一个 libc 函数的地址来实现对程序的控制。比如说我们可以修改 printf 的 got 表项内容为 system 函数的地址。从而，程序在执行 printf 的时候实际执行的是 system 函数。
假设我们将函数 A 的地址覆盖为函数 B 的地址，那么这一攻击技巧可以分为以下步骤
-   确定函数 A 的 GOT 表地址。
    -   这一步我们利用的函数 A 一般在程序中已有，所以可以采用简单的寻找地址的方法来找。
-   确定函数 B 的内存地址
    -   这一步通常来说，需要我们自己想办法来泄露对应函数 B 的地址。
-   将函数B的内存地址写入到函数 A 的 GOT 表地址处。
    -   这一步一般来说需要我们利用函数的漏洞来进行触发。一般利用方法有如下两种
        -   写入函数：write 函数。
        -   ROP
        ```text
        pop eax; ret; 			# printf@got -> eax
        pop ebx; ret; 			# (addr_offset = system_addr - printf_addr) -> ebx
        add [eax] ebx; ret; 	# [printf@got] = [printf@got] + addr_offset
        ```
        -   格式化字符串任意地址写
### 堆上的格式化字符串漏洞原理
所谓堆上的格式化字符串指的是格式化字符串本身存储在堆上，这个主要增加了我们获取对应偏移的难度，而一般来说，该格式化字符串都是很有可能被复制到栈上的。
### 格式化字符串盲打原理
所谓格式化字符串盲打指的是只给出可交互的 ip 地址与端口，不给出对应的 binary 文件来让我们进行 pwn，其实这个和 BROP 差不多，不过 BROP 利用的是栈溢出，而这里我们利用的是格式化字符串漏洞。一般来说，我们按照如下步骤进行
- 确定程序的位数
- 确定漏洞位置 
- 利用