java program
perl script
php script
php script
python script
python script
python script
python script
python script
CLI execution
Table 2: Libraries and wrappers that were manually con-
ﬁrmed to be supported by CertShim.
5.1.2 Less Dangerous Code?
We next consider CertShim’s safe default features, and
how they protect against the SSL vulnerabilities presented
by Georgiev et al.
[19]. Through manual testing, we con-
ﬁrmed that CertShim would secure the SSL communica-
tions in 100% of the SSL libraries, 89% of the data-transport
libraries, and 71% applications mentioned in this work:
• SSL Libraries. Error-prone aspects of the SSL API
are identiﬁed in OpenSSL, GnuTLS, and JSSE. Cert-
Shim enforces proper certiﬁcate handling for OpenSSL
and GnuTLS, even when the application fails to call
the veriﬁcation function. We provide partial support
to JSSE, which we instrumented to ensure that host-
name veriﬁcation is always performed, regardless of
how the API is invoked.
• Data-transport Libraries. Georgiev et al. discuss 9
data-transport frameworks that wrap the major SSL li-
braries. We provide full support to cURL, php’s fsock-
open, urllib, urllib2, httplib, python ssl, and par-
tial support to the Java libraries Apache HttpClient
and Weberknect. The only library that CertShim
does not support is php_curl due to static linking.
• SSL Applications. We obtained the vulnerable ver-
sions of several of the applications explored, including
Lynx, Apache HttpClient, and Apache Axis. Based on
review of these applications combined with our man-
ual tests, we conclude that CertShim secures the SSL
communications of 12 of the 17 applications mentioned
that could be run on Linux systems. All 5 of the un-
supported applications were payment services that had
a vulnerable php_curl dependency.
These ﬁndings demonstrate the power of the CertShim
methodology. It also serves to show that, so long as the API
remains the same, CertShim can protect against presently
undiscovered vulnerabilities and misconﬁgurations in SSL
APIs and wrapper libraries.
5.1.3 Large-Scale Coverage Survey
On a general computing platform such as Linux, auto-
mated dynamic analysis of SSL proved diﬃcult due to the
great variety of SSL implementations, languages, and usage
scenarios. During manual testing, we found that a thorough
knowledge of an application’s purpose and behaviors was
Program Test Cmd
curl
sslscan
lynx
ncat
fdm
fetchmail
ﬁrefox
mpop
perl
pycurl
pyOpenSSL Socket established SSL session
urllib
w3m
wget
gnutls-cli
Success
Yes
curl https://google.com
sslscan google.com:443
Yes
lynx -dump https://google.com Yes
Yes
ncat –ssl-verify google.com 443
Yes
Checked gmail.com over SSL
Yes
Checked gmail.com over SSL
No
Visited gmail.com (w/o plugin)
Checked gmail.com over SSL
Yes
Yes
Perl’s IO::Socket::SSL
Yes
cUrl established SSL session
Yes
urllib made HTTPS request
Yes
w3m https://google.com -dump Yes
wget https://google.com
Yes
Performed handshake procedure Yes
Table 3: Programs and libraries that were manually tested
to conﬁrm CertShim support
(a) Total Packages Supported (b) Packages supported by SSL
library/wrapper
Figure 5: Estimated CertShim support of SSL usage found
in Ubuntu Popularity Contest.
required in order to trigger SSL connections. As a result,
we were unable to perform large-scale dynamic analysis of
CertShim. Fortunately, based on the supported libraries
shown in Table 2, we were able to use a mix of static analy-
sis and manual inspection in order to arrive at a CertShim
coverage estimate for a large corpus of applications.
As a source for real world SSL usage, we selected the
Ubuntu Popularity Contest [34], a service that tracks the
most commonly installed packages on Ubuntu. Starting with
the top 10,000 packages, we ran apt-rdepends, a tool for re-
cursively ﬁnding library dependencies for a given package,
on each package. Of these packages, we were able to recover
library dependency information for 7,789 packages due to
the fact that some packages were not present in the main
apt repositories for Ubuntu 12.04. From this list we discov-
ered 2,949 packages that had dependencies to known SSL li-
braries (i.e., the packages left out could not have been using
SSL). We then gathered the corresponding source ﬁles us-
ing apt-get source. This methodology yielded 1,809 code-
bases, with the reduction in total packages being accounted
for by the fact that one codebase can be responsible for mul-
tiple packages. With the available source, we proceeded to
check the ﬁles against a list of keywords related to network-
ing, SSL, and HTTPS. After narrowing the ﬁeld to source
packages containing keywords, we manually inspected the
remaining packages to conﬁrm that the package made SSL
connections. As CertShim only partially supports Java,
these packages that were removed from the survey.
401Dependency
urllib/httplib
OpenSSL
GnuTLS
cURL/libcurl
Misc SSL Wrappers
Total Supported
Total Unsupported
Support? Pkg. Count
123
92
51
48
56
370
26
Yes
Yes
Yes
Yes
Yes
Module
OpenSSL w/o CertShim
CertShim Baseline
Convergence Baseline
Key Pinning, First Use
Key Pinning, Revisit
DANE
Real Time
88 ms [ 84, 92]
108 ms [107, 109]
108 ms [107, 110]
130 ms [120, 139]
119 ms [118, 119]
7 sec
Table 4: Details of estimated CertShim support and SSL
usage in the Ubuntu Popularity Contest.
Table 5: Benchmarks for CertShim usage. 95% conﬁdence
intervals are included in brackets.
Because CertShim cannot support static linking, we also
wished to determine if this was a common practice. To do so,
we installed the 395 packages that contained SSL activity,
then ran ldd, a tool that prints shared library dependencies,
against each of the resulting ﬁles that were placed in bin
or lib directories. ldd lists packages that are dynamically
linked, and can also detect static linking. We did not ﬁnd
widespread use of static linking, of 10,707 ﬁles checked by
ldd, we found only 12 that were statically linked.
As illustrated in Figure 5a, we found that CertShim sup-
ported 370 of the 395 packages found to be making SSL
connections, for a coverage ratio of 94%. Our use of the
word “support” can be interpreted as follows – this applica-
tion may make an SSL connection in execution, and if it does
CertShimwill hook it. A stronger assurance about applica-
tion behavior would have required dynamic analysis, which
was not feasible. A summary of our results can be found in
Table 4 and Figure 5b. The miscellaneous SSL wrappers in-
cluded QSSL, Pidgin’s Purple SSL, URLGrabber, Serf, and
Neon; for each, we inspect the source code to conﬁrm that
they wrapped OpenSSL or GnuTLS and used one of Cert-
Shim’s function hooks. The unsupported packages included
previously discovered coverage gaps such as NSS, as well as
other wrappers such as KSSL and QCA, for which we were
unable to conﬁrm support. We note that this coverage result
is an estimate; without dynamic analysis, it was impossible
to deﬁnitively conﬁrm that these applications attempted to
make SSL connections. However, we did conﬁrm that each
of the applications had code paths that made web requests
with SSL-ready libraries.
5.2 Performance
We generated several benchmarks for the baseline perfor-
mance of CertShim, performing tests on a Dell PC run-
ning a Linux 3.5 kernel with 2 GB of RAM and a Pentium
3Ghz dual-core processor. We measured the time it took the
wget utility to retrieve a small, 9 KB ﬁle over HTTPS from
a nearby web server. This call triggers the SSL_get_ver-
ify_result() function, which is supported by CertShim.
The throughput of the connection to the server was approxi-
mately 80 MB per second. The server was using a CA-signed
certiﬁcate, which was validated by wget during the course
of the download. Each of these results were averaged over
500 measurements. When CertShim was not loaded, wget
returned in 88 ms. When CertShim was loaded without a
veriﬁcation module, the operation completed in 108 ms, im-
posing just 20 ms base overhead on OpenSSL. This overhead
is largely due to the CertShim hooks for the connect() and
getaddrinfo() functions, which collect contextual data that
is required by the hooked OpenSSL and GnuTLS functions
and write it to a SQLite database. The policy engine demon-
strated an average run time of just 0.061 ms while parsing
the sample conﬁguration ﬁle and initializing the policies.
When using an 86 kilobyte conﬁguration ﬁle consisting of
392 policies, the policy engine required an average run time
of 3.075 ms. Each average was based on 1,000 iterations.
We then repeated these trials with the diﬀerent veriﬁca-
tion modules enabled. The results are summarized in Table
5. The minimum time required for Convergence veriﬁcation
was 108 ms, corresponding to the case in which the client
already possesses a locally cached copy of the certiﬁcate ﬁn-
gerprint. We benchmarked Key Pinning under two use cases:
veriﬁcation took 130 ms when visiting a domain for the ﬁrst
time, and 119 ms when checking a previously visited domain.
The time required to use the DANE module was 7 seconds.
We attribute this exorbitant cost to the fact that our DANE
measurements used https://www.torproject.org instead
of a local server. Tor has 9 IP addresses associated with
this domain, each of which was sequentially veriﬁed by the
SWEDE library within our module.
Initially, we observed that the base cost of CertShim was
900 ms. Upon further investigation, we realized that this
was due to our SQLite conﬁguration; each attempt to open
a write transaction to the database cost approximately 100
ms. To improve performance, we disabled journaling on
the database. We note that this also disabled protections
against database corruption due to hardware failures or un-
expected interrupts. In a future iteration of CertShim, we
intend to restore these protections while imposing minimal
additional performance cost by implementing an in-memory
database that ﬂushes to disk during idle periods.
6. LIMITATIONS & FUTURE WORK
We now discuss several potential gaps in CertShim’s cov-
erage, as well as possible solutions:
Root Processes. For security reasons, LD_PRELOAD is not
permitted by default for processes running as root; however,
support for root can be provided by symbolically linking a
root-owned copy of CertShim to the /lib directory.
Alternative Libraries. CertShim supports modern ver-
sions of two of the most popular open source SSL libraries,
libssl1.0.0 and gnutls26. There are many other imple-
mentations available, such as PolarSSL and NSS; we have
inspected these libraries and believe that CertShim can be
extended to support them with only modest additional work.
CertShim provides a blueprint for interposing on function
calls in any C-based SSL library. Our approach could be
deployed on Windows’ SChannel library as an AppInit_DLL.
SSL in Java. Linux dynamic linking cannot be used to
interpose on Java libraries. However,
in Section 3.5 we
demonstrate that our approach is applicable in Java through
instrumentation objects.
402Static Linking. As our methodology is based on dynamic
linking, CertShim cannot interpose on statically linked ex-
ecutables. In our evaluation, we encountered one instance
of static linking in PHP’s cURL wrapper. As a stop-gap so-
lution to this problem, we are investigating the use of Conti
et al.’s approach of correlating SSL traﬃc to applications
[11]; if a ﬂow’s network context is not already present in
the CertShim database (Section 3.3.1), CertShim can in-
fer that the ﬂow is from a statically linked application and
warn the user. This limitation could be more fully addressed
via static binary instrumentation through use of tools like
PEBIL [25] and DynInst [6, 8].
Usability. CertShim already has a complete logging sys-
tem, making it easy to develop a graphical user interface
layer and other utilities. We envision a notiﬁcation system
similar to Red Hat’s setroubleshootd daemon, which sim-
pliﬁes selinux usage by alerting users to new AVC log mes-
sages. Because CertShim logs a template policy entry upon
veriﬁcation failure, an audit2allow-like application could be
developed to dramatically simplify policy debugging.
Policy Engine. We intend to extend the policy mechanism
to support pattern matching on command line arguments.
Some applications’ certiﬁcate veriﬁcation behaviors should
change based on these arguments; for example, CertShim
should take no action when wget is invoked with the -no-
check-certificate. We also intend to release additional
veriﬁcation modules.
7. RELATED WORK
A large body of recent work has sought to better un-
derstand and ultimately prevent SSL vulnerabilities in non-
browser software. Georgiev et al. manually survey diﬀerent
layers of the SSL stack, discovering pervasive misconﬁgu-
rations of certiﬁcate validation routines, as well as usage