# 13 \| 临时表：复杂查询，如何保存中间结果？你好，我是朱晓峰。今天，我来和你聊一聊临时表。当我们遇到一些复杂查询的时候，经常无法一步到位，或者是一步到位会导致查询语句太过复杂，开发和维护的成本过高。这个时候，就可以使用临时表。下面，我就结合实际的项目来讲解一下，怎么拆解一个复杂的查询，通过临时表来保存中间结果，从而把一个复杂查询变得简单而且容易实现。临时表是什么？临时表是一种特殊的表，用来存储查询的中间结果，并且会随着当前连接的结束而自动删除。**MySQL 中有 2种临时表，分别是内部临时表和外部临时表**：1.  内部临时表主要用于性能优化，由系统自动产生，我们无法看到；        2.  外部临时表通过 SQL    语句创建，我们可以使用。        因为我们不能使用内部临时表，所以我就不多讲了。今天，我来重点讲一讲我们可以创建和使用的外部临时表。首先，你要知道临时表的创建语法结构：    CREATE TEMPORARY TABLE 表名    (    字段名 字段类型,    ...    );跟普通表相比，临时表有 3个不同的特征：1.       临时表的创建语法需要用到关键字    TEMPORARY；        2.       临时表创建完成之后，只有当前连接可见，其他连接是看不到的，具有连接隔离性；        3.       临时表在当前连接结束之后，会被自动删除。        因为临时表有连接隔离性，不同连接创建相同名称的临时表也不会产生冲突，适合并发程序的运行。而且，连接结束之后，临时表会自动删除，也不用担心大量无用的中间数据会残留在数据库中。因此，我们就可以利用这些特点，用临时表来存储SQL 查询的中间结果。如何用临时表简化复杂查询？刚刚提到，临时表可以简化复杂查询，具体是怎么实现的呢？我来介绍一下。举个例子，超市经营者想要查询 2020 年 12月的一些特定商品销售数量、进货数量、返厂数量，那么，我们就要先把销售、进货、返厂这3个模块分开计算，用临时表来存储中间计算的结果，最后合并在一起，形成超市经营者想要的结果集。首先，我们统计一下在 2020 年 12月的商品销售数据。假设我们的销售流水表（mysales）如下所示：![](Images/b0226fec5dd593228248f9e472fd6116.png)savepage-src="https://static001.geekbang.org/resource/image/ay/f5/ayy269bb7dd210a1f1716ebd2947e9f5.jpeg"}我们可以用下面的 SQL语句，查询出每个单品的销售数量和销售金额，并存入临时表：    mysql> CREATE TEMPORARY TABLE demo.mysales    -> SELECT                        -- 用查询的结果直接生成临时表    -> itemnumber,    -> SUM(quantity) AS QUANTITY,    -> SUM(salesvalue) AS salesvalue    -> FROM    -> demo.transactiondetails    -> GROUP BY itemnumber    -> ORDER BY itemnumber;    Query OK, 2 rows affected (0.01 sec)    Records: 2 Duplicates: 0 Warnings: 0         mysql> SELECT * FROM demo.mysales;    +------------+----------+------------+    | itemnumber | QUANTITY | salesvalue |    +------------+----------+------------+    | 1 | 5.000 | 411.18 |    | 2 | 5.000 | 24.75 |    +------------+----------+------------+    2 rows in set (0.01 sec)需要注意的是，这里我是直接用查询结果来创建的临时表。因为创建临时表就是为了存放某个查询的中间结果。直接用查询语句创建临时表比较快捷，而且连接结束后临时表就会被自动删除，不需要过多考虑表的结构设计问题（比如冗余、效率等）。到这里，我们就有了一个存储单品销售统计的临时表。接下来，我们计算一下2020 年 12 月的进货信息。我们的进货数据包括进货单头表（importhead）和进货单明细表（importdetails）。进货单头表包括进货单编号、供货商编号、仓库编号、操作员编号和验收日期：![](Images/9928690f1089032fc6a6e9321b6953a6.png)savepage-src="https://static001.geekbang.org/resource/image/0a/80/0acf5b6ee4f154414fefd543b33f7180.jpeg"}进货单明细表包括进货单编号、商品编号、进货数量、进货价格和进货金额：![](Images/995e833a524bc1cc1fcfc0ae0892ccb0.png)savepage-src="https://static001.geekbang.org/resource/image/36/36/368d0f558d497be064d264baaf99e636.jpeg"}我们用下面的 SQL语句计算进货数据，并且保存在临时表里面：    mysql> CREATE TEMPORARY TABLE demo.myimport    -> SELECT b.itemnumber,SUM(b.quantity) AS quantity,SUM(b.importvalue) AS importvalue    -> FROM demo.importhead a JOIN demo.importdetails b    -> ON (a.listnumber=b.listnumber)    -> GROUP BY b.itemnumber;    Query OK, 3 rows affected (0.01 sec)    Records: 3 Duplicates: 0 Warnings: 0         mysql> SELECT * FROM demo.myimport;    +------------+----------+-------------+    | itemnumber | quantity | importvalue |    +------------+----------+-------------+    | 1 | 5.000 | 290.00 |    | 2 | 5.000 | 15.00 |    | 3 | 8.000 | 40.00 |    +------------+----------+-------------+    3 rows in set (0.00 sec)这样，我们又得到了一个临时表demo.myimport，里面保存了我们需要的进货数据。接着，我们来查询单品返厂数据，并且保存到临时表。我们的返厂数据表有 2个，分别是返厂单头表（returnhead）和返厂单明细表（returndetails）。返厂单头表包括返厂单编号、供货商编号、仓库编号、操作员编号和验收日期：![](Images/8d308393310493b7de36fcb9ec6ef2d6.png)savepage-src="https://static001.geekbang.org/resource/image/20/3e/206c5ba8bdcb13c55c78a1ec1f4aab3e.jpeg"}返厂单明细表包括返厂单编号、商品编号、返厂数量、返厂价格和返厂金额：![](Images/3059563af6473c836d340ddf1e2b5031.png)savepage-src="https://static001.geekbang.org/resource/image/a9/4b/a9bda457d8f15e8f87fc5d0f4e2ee24b.jpeg"}我们可以使用下面的 SQL语句计算返厂信息，并且保存到临时表中。    mysql> CREATE TEMPORARY TABLE demo.myreturn    -> SELECT b.itemnumber,SUM(b.quantity) AS quantity,SUM(b.returnvalue) AS returnvalue    -> FROM demo.returnhead a JOIN demo.returndetails b    -> ON (a.listnumber=b.listnumber)    -> GROUP BY b.itemnumber;    Query OK, 3 rows affected (0.01 sec)    Records: 3 Duplicates: 0 Warnings: 0         mysql> SELECT * FROM demo.myreturn;    +------------+----------+-------------+    | itemnumber | quantity | returnvalue |    +------------+----------+-------------+    | 1 | 2.000 | 115.00 |    | 2 | 1.000 | 3.00 |    | 3 | 1.000 | 5.00 |    +------------+----------+-------------+    3 rows in set (0.00 sec)这样，我们就获得了单品的返厂信息。有了前面计算出来的数据，现在，我们就可以把单品的销售信息、进货信息和返厂信息汇总到一起了。如果你跟着实际操作的话，你可能会有这样一个问题：我们现在有 3个临时表，分别存储单品的销售信息、进货信息和返厂信息。那么，能不能把这 3个表相互关联起来，把这些信息都汇总到对应的单品呢？答案是不行，不管是用内连接、还是用外连接，都不可以。因为无论是销售信息、进货信息，还是返厂信息，都存在商品信息缺失的情况。换句话说，就是在指定时间段内，某些商品可能没有销售，某些商品可能没有进货，某些商品可能没有返厂。如果仅仅通过这3个表之间的连接进行查询，我们可能会丢失某些数据。为了解决这个问题，我们可以引入商品信息表。因为商品信息表包含所有的商品，因此，把商品信息表放在左边，与其他的表进行左连接，就可以确保所有的商品都包含在结果集中。凡是不存在的数值，都设置为0，然后再筛选一下，把销售、进货、返厂都是 0的商品去掉，这样就能得到我们最终希望的查询结果：2020 年 12月的商品销售数量、进货数量和返厂数量。代码如下所示：    mysql> SELECT    -> a.itemnumber,    -> a.goodsname,    -> ifnull(b.quantity,0) as salesquantity,    -- 如果没有销售记录，销售数量设置为0    -> ifnull(c.quantity,0) as importquantity,   -- 如果没有进货，进货数量设为0    -> ifnull(d.quantity,0) as returnquantity    -- 如果没有返厂，返厂数量设为0    -> FROM    -> demo.goodsmaster a               -- 商品信息表放在左边进行左连接，确保所有的商品都包含在结果集中    -> LEFT JOIN demo.mysales b    -> ON (a.itemnumber=b.itemnumber)    -> LEFT JOIN demo.myimport c    -> ON (a.itemnumber=c.itemnumber)    -> LEFT JOIN demo.myreturn d    -> ON (a.itemnumber=d.itemnumber)    -> HAVING salesquantity>0 OR importquantity>0 OR returnquantity>0; -- 在结果集中剔除没有销售，没有进货，也没有返厂的商品    +------------+-----------+---------------+----------------+----------------+    | itemnumber | goodsname | salesquantity | importquantity | returnquantity |    +------------+-----------+---------------+----------------+----------------+    | 1 | 书 | 5.000 | 5.000 | 2.000 |    | 2 | 笔 | 5.000 | 5.000 | 1.000 |    | 3 | 橡皮 | 0.000 | 8.000 | 1.000 |    +------------+-----------+---------------+----------------+----------------+    3 rows in set (0.00 sec)总之，通过临时表，我们就可以把一个复杂的问题拆分成很多个前后关联的步骤，把中间的运行结果存储起来，用于之后的查询。这样一来，就把面向集合的SQL查询变成了面向过程的编程模式，大大降低了难度。内存临时表和磁盘临时表由于采用的存储方式不同，临时表也可分为内存临时表和磁盘临时表，它们有着各自的优缺点，下面我来解释下。关于内存临时表，有一点你要注意的是，你可以通过指定引擎类型（比如ENGINE=MEMORY），来告诉 MySQL临时表存储在内存中。好了，现在我们先来创建一个内存中的临时表：    mysql> CREATE TEMPORARY TABLE demo.mytrans    -> (    -> itemnumber int,    -> groupnumber int,    -> branchnumber int    -> ) ENGINE = MEMORY; （临时表数据存在内存中）    Query OK, 0 rows affected (0.00 sec)接下来，我们在磁盘上创建一个同样结构的临时表。在磁盘上创建临时表时，只要我们不指定存储引擎，MySQL会默认存储引擎是InnoDB，并且把表存放在磁盘上。    mysql> CREATE TEMPORARY TABLE demo.mytransdisk    -> (    -> itemnumber int,    -> groupnumber int,    -> branchnumber int    -> );    Query OK, 0 rows affected (0.00 sec)现在，我们向刚刚的两张表里都插入同样数量的记录，然后再分别做一个查询：    mysql> SELECT COUNT(*) FROM demo.mytrans;    +----------+    | count(*) |    +----------+    | 4355 |    +----------+    1 row in set (0.00 sec)         mysql> SELECT COUNT(*) FROM demo.mytransdisk;    +----------+    | count(*) |    +----------+    | 4355 |    +----------+    1 row in set (0.21 sec)可以看到，区别是比较明显的。对于同一条查询，内存中的临时表执行时间不到10 毫秒，而磁盘上的表却用掉了 210毫秒。显然，内存中的临时表查询速度更快。不过，内存中的临时表也有缺陷。因为数据完全在内存中，所以，一旦断电，数据就消失了，无法找回。不过临时表只保存中间结果，所以还是可以用的。我画了一张图，汇总了内存临时表和磁盘临时表的优缺点：![](Images/f145dd5c70e63ba9810ae1d059d352f3.png)savepage-src="https://static001.geekbang.org/resource/image/c5/bf/c5f3d549f5f0fd72e74ec9c5441467bf.jpeg"}总结这节课，我们学习了临时表的概念，以及使用临时表来存储中间结果以拆分复杂查询的方法。临时表可以存储在磁盘中，也可以通过指定引擎的办法存储在内存中，以加快存取速度。其实，临时表有很多好处，除了可以帮助我们把复杂的 SQL查询拆分成多个简单的 SQL查询，而且，因为临时表是连接隔离的，不同的连接可以使用相同的临时表名称，相互之间不会受到影响。除此之外，临时表会在连接结束的时候自动删除，不会占用磁盘空间。当然，临时表也有不足，比如会挤占空间。我建议你，**在使用临时表的时候，要从简化查询和挤占资源两个方面综合考虑，既不能过度加重系统的负担，同时又能够通过存储中间结果，最大限度地简化查询**。思考题我们有这样的一个销售流水表：![](Images/42239569495b3bce827e32f9b6193cc5.png)savepage-src="https://static001.geekbang.org/resource/image/a9/b6/a970618a3807cyyeeaf28ac57fa034b6.jpeg"}假设有多个门店，每个门店有多台收款机，每台收款机销售多种商品，请问如何查询每个门店、每台收款机的销售金额占所属门店的销售金额的比率呢？欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，欢迎你把它分享给你的朋友或同事，我们下节课见。
# 14 \| 视图：如何简化查询？你好，我是朱晓峰。今天，我们来聊一聊视图。视图是一种虚拟表，我们可以把一段查询语句作为视图存储在数据库中，在需要的时候，可以把视图看做一个表，对里面的数据进行查询。举个小例子，在学校的信息系统里面，为了减少冗余数据，学生档案（包括姓名、年龄等）和考试成绩（包括考试时间、科目、分数等）是分别存放在不同的数据表里面的，但是，我们经常需要查询学生的考试成绩（包括学生姓名、科目、分数）。这个时候，我们就可以把查询学生考试成绩的这个关联查询，用视图的形式保存起来。这样一来，我们不仅可以从视图中直接查询学生考试成绩，让查询变得简单，而且，视图没有实际存储数据，还避免了数据存储过程中可能产生的冗余，提高了存储的效率。今天，我就结合超市的项目，来具体讲解一下怎么创建和操作视图，来帮助你提高查询效率。视图的创建及其好处首先，我们来学习下创建视图的方法，以及使用视图的一些好处。创建视图的语法结构：    CREATE [OR REPLACE    VIEW 视图名称 [(字段列表)    AS 查询语句现在，假设我们要查询一下商品的每日销售明细，这就要从销售流水表（demo.trans）和商品信息表（demo.goodsmaster）中获取到销售数据和对应的商品信息数据。销售流水表包含流水单号、商品编号、销售数量、销售金额和交易时间等信息：![](Images/c11266ceb43514efe3e8b0f2fd5c9ab3.png)savepage-src="https://static001.geekbang.org/resource/image/65/56/65168f6e248fcc848e8b9968a712c956.jpeg"}商品信息表包含商品编号、条码、名称和售价等信息：![](Images/2e7ef950c60cef2e76ce3f8e40648e47.png)savepage-src="https://static001.geekbang.org/resource/image/73/4b/73836142bbfd6cc0f69de418acb7444b.jpeg"}在不使用视图的情况下，我们可以通过对销售流水表和商品信息表进行关联查询，得到每天商品销售统计的结果，包括销售日期、商品名称、每天销售数量的合计和每天销售金额的合计，如下所示：    mysql> SELECT    -> a.transdate,    -> a.itemnumber,    -> b.goodsname,    -> SUM(a.quantity) AS quantity,   -- 统计销售数量    -> SUM(a.salesvalue) AS salesvalue -- 统计销售金额    -> FROM    -> demo.trans AS a    -> LEFT JOIN                 -- 连接查询    -> demo.goodsmaster AS b ON (a.itemnumber = b.itemnumber)    -> GROUP BY a.transdate , a.itemnumber;    +---------------------+------------+-----------+----------+------------+    | transdate | itemnumber | goodsname | quantity | salesvalue |    +---------------------+------------+-----------+----------+------------+    | 2020-12-01 00:00:00 | 1 | 本 | 1.000 | 89.00 |    | 2020-12-01 00:00:00 | 2 | 笔 | 1.000 | 5.00 |    | 2020-12-02 00:00:00 | 3 | 胶水 | 2.000 | 20.00 |    +---------------------+------------+-----------+----------+------------+    3 rows in set (0.00 sec)在实际项目中，我们发现，每日商品销售查询使用的频次很高，而且经常需要以这个查询的结果为基础，进行更进一步的统计。举个例子，超市经营者要查一下"每天商品的销售数量和当天库存数量的对比"，如果用一个SQL语句查询，就会比较复杂。历史库存表（demo.inventoryhist）如下所示：![](Images/f6b5d804df220e44abee2c6746e2a8de.png)savepage-src="https://static001.geekbang.org/resource/image/ac/bc/ac3f59ba59e460bb4962391b20a8c1bc.jpeg"}接下来我们的查询步骤会使用到子查询和派生表，很容易理解，你知道含义就行了。1.  子查询：就是嵌套在另一个查询中的查询。        2.  派生表：如果我们在查询中把子查询的结果作为一个表来使用，这个表就是派生表。        这个查询的具体步骤是：1.       通过子查询获得单品销售统计的查询结果；        2.       把第一步中的查询结果作为一个派生表，跟历史库存表进行连接，查询获得包括销售日期、商品名称、销售数量和历史库存数量在内的最终结果。        ```{=html}```    mysql> SELECT    -> a.transdate,    -> a.itemnumber,    -> a.goodsname,    -> a.quantity,       -- 获取单品销售数量    -> b.invquantity     -- 获取历史库存数量    -> FROM    -> (SELECT           -- 子查询，统计单品销售             -> a.transdate,    -> a.itemnumber,    -> b.goodsname,    -> SUM(a.quantity) AS quantity,    -> SUM(a.salesvalue) AS salesvalue    -> FROM    -> demo.trans AS a    -> LEFT JOIN demo.goodsmaster AS b ON (a.itemnumber = b.itemnumber)    -> GROUP BY a.transdate , a.itemnumber    -> ) AS a -- 派生表，与历史库存进行连接    -> LEFT JOIN    -> demo.inventoryhist AS b    -> ON (a.transdate = b.invdate    -> AND a.itemnumber = b.itemnumber);    +---------------------+------------+-----------+----------+-------------+    | transdate | itemnumber | goodsname | quantity | invquantity |    +---------------------+------------+-----------+----------+-------------+    | 2020-12-01 00:00:00 | 1 | 本 | 1.000 | 100.000 |    | 2020-12-01 00:00:00 | 2 | 笔 | 1.000 | 99.000 |    | 2020-12-02 00:00:00 | 3 | 胶水 | 2.000 | 200.000 |    +---------------------+------------+-----------+----------+-------------+    3 rows in set (0.00 sec)可以看到，这个查询语句是比较复杂的，可读性和可维护性都比较差。那该怎么办呢？其实，针对这种情况，我们就可以使用视图。我们可以把商品的每日销售统计查询做成一个视图，存储在数据库里，代码如下所示：     mysql> CREATE VIEW demo.trans_goodsmaster AS  -- 创建视图    -> SELECT    -> a.transdate,    -> a.itemnumber,    -> b.goodsname,                           -- 从商品信息表中获取名称    -> SUM(a.quantity) AS quantity,           -- 统计销售数量    -> SUM(a.salesvalue) AS salesvalue        -- 统计销售金额    -> FROM    -> demo.trans AS a    -> LEFT JOIN    -> demo.goodsmaster AS b ON (a.itemnumber = b.itemnumber) -- 与商品信息表关联    -> GROUP BY a.transdate , a.itemnumber;   -- 按照销售日期和商品编号分组    Query OK, 0 rows affected (0.01 sec)这样一来，我们每次需要查询每日商品销售数据的时候，就可以直接查询视图，不需要再写一个复杂的关联查询语句了。我们来试试用一个查询语句直接从视图中进行查询：    mysql> SELECT *                 -- 直接查询    -> FROM demo.trans_goodsmaster; -- 视图    +---------------------+------------+-----------+----------+------------+    | transdate | itemnumber | goodsname | quantity | salesvalue |    +---------------------+------------+-----------+----------+------------+    | 2020-12-01 00:00:00 | 1 | 本 | 1.000 | 89.00 |    | 2020-12-01 00:00:00 | 2 | 笔 | 1.000 | 5.00 |    | 2020-12-02 00:00:00 | 3 | 胶水 | 2.000 | 20.00 |    +---------------------+------------+-----------+----------+------------+    3 rows in set (0.01 sec)结果显示，这两种查询方式得到的结果是一样的。如果我们要进一步查询"每日单品销售的数量与当日的库存数量的对比"，就可以把刚刚定义的视图作为一个数据表来使用。我们把它跟历史库存表连接起来，来获取销售数量和历史库存数量。就像下面的代码这样，查询就简单多了：    mysql> SELECT    -> a.transdate,               -- 从视图中获取销售日期    -> a.itemnumber,              -- 从视图中获取商品编号    -> a.goodsname,               -- 从视图中获取商品名称    -> a.quantity,                -- 从视图中获取销售数量    -> b.invquantity              -- 从历史库存表中获取历史库存数量    -> FROM    -> demo.trans_goodsmaster AS a -- 视图    -> LEFT JOIN    -> demo.inventoryhist AS b ON (a.transdate = b.invdate    -> AND a.itemnumber = b.itemnumber);  -- 直接连接库存历史表    +---------------------+------------+-----------+----------+-------------+    | transdate | itemnumber | goodsname | quantity | invquantity |    +---------------------+------------+-----------+----------+-------------+    | 2020-12-01 00:00:00 | 1 | 本 | 1.000 | 100.000 |    | 2020-12-01 00:00:00 | 2 | 笔 | 1.000 | 99.000 |    | 2020-12-02 00:00:00 | 3 | 胶水 | 2.000 | 200.000 |    +---------------------+------------+-----------+----------+-------------+    3 rows in set (0.00 sec)结果显示，这里的查询结果和我们刚刚使用派生表的查询结果是一样的。但是，**使用视图的查询语句明显简单多了，可读性更好，也更容易维护**。如何操作视图和视图中的数据？创建完了视图，我们还经常需要对视图进行一些操作，比如修改、查看和删除视图。同时，我们可能还需要修改视图中的数据。具体咋操作呢？我来介绍下。如何操作视图？修改、查看、删除视图的操作比较简单，你只要掌握具体的语法就行了。修改视图的语法如下所示：    ALTER VIEW 视图名    AS 查询语句;查看视图的语法是：    查看视图：    DESCRIBE 视图名；删除视图要使用 DROP关键词，具体方法如下：    删除视图：    DROP VIEW 视图名;好了，到这里，对视图的操作我就介绍完了，下面我再讲讲怎么操作视图中的数据。如何操作视图中的数据？刚刚说过，视图本身是一个虚拟表，所以，对视图中的数据进行插入、修改和删除操作，实际都是通过对实际数据表的操作来实现的。**1. 在视图中插入数据**我借用刚刚的视图 demo.view_goodsmaster来给你解释下。假设商品信息表中的规格字段（specification）被删除了，当我们尝试用INSERT INTO语句向视图中插入一条记录的时候，就会提示错误了：    mysql> INSERT INTO demo.view_goodsmaster    -> (itemnumber,barcode,goodsname,salesprice)    -> VALUES    -> (5,'0005','测试',100);    ERROR 1471 (HY000): The target table view_goodsmaster of the INSERT is not insertable-into这是因为，**只有视图中的字段跟实际数据表中的字段完全一样，MySQL才允许通过视图插入数据**。刚刚的视图中包含了实际数据表所没有的字段"specification"，所以在插入数据时，系统就会提示错误。为了解决这个问题，我们来修改一下视图，让它只包含实际数据表中有的字段，也就是商品编号、条码、名称和售价。代码如下：    mysql> ALTER VIEW demo.view_goodsmaster    -> AS    -> SELECT itemnumber,barcode,goodsname,salesprice -- 只包含实际表中存在的字段    -> FROM demo.goodsmaster    -> WHERE salesprice > 50;    Query OK, 0 rows affected (0.01 sec)对视图进行修改之后，我们重新尝试向视图中插入一条记录：    mysql> INSERT INTO demo.view_goodsmaster    -> (itemnumber,barcode,goodsname,salesprice)    -> VALUES    -> (5,'0005','测试',100);    Query OK, 1 row affected (0.02 sec)结果显示，插入成功了。现在我们来查看一下视图中的数据：    mysql> SELECT *    -> FROM demo.view_goodsmaster;    +------------+---------+-----------+------------+    | itemnumber | barcode | goodsname | salesprice |    +------------+---------+-----------+------------+    | 1 | 0001 | 本 | 89.00 |    | 5 | 0005 | 测试 | 100.00 |                        -- 通过视图插入的数据    +------------+---------+-----------+------------+    2 rows in set (0.01 sec)结果显示，表中确实包含了我们插入的商品编号是 5的商品信息。现在，视图中已经包括了刚才插入的数据，那么，实际数据表中的数据情况又是怎样的呢？我们再来看一下：    mysql> SELECT *    -> FROM demo.goodsmaster;    +------------+---------+-----------+------------+    | itemnumber | barcode | goodsname | salesprice |    +------------+---------+-----------+------------+    | 1 | 0001 | 本 | 89.00 |    | 2 | 0002 | 笔 | 5.00 |    | 3 | 0003 | 胶水 | 10.00 |    | 5 | 0005 | 测试 | 100.00 |                      -- 通过视图插入的数据    +------------+---------+-----------+------------+    4 rows in set (0.00 sec)可以看到，实际数据表 demo.goodsmaster中，也已经包含通过视图插入的商品编号是 5的商品数据了。**2. 删除视图中的数据**我们可以通过 DELETE语句，删除视图中的数据：    mysql> DELETE FROM demo.view_goodsmaster   -- 直接在视图中删除数据    -> WHERE itemnumber = 5;    Query OK, 1 row affected (0.02 sec)现在我们来查看视图和实际数据表的内容，会发现商品编号是 5的商品都已经被删除了。    mysql> SELECT *    -> FROM demo.view_goodsmaster;    +------------+---------+-----------+------------+    | itemnumber | barcode | goodsname | salesprice |    +------------+---------+-----------+------------+    | 1 | 0001 | 本 | 89.00 |                         -- 视图中已经没有商品编号是5的商品了    +------------+---------+-----------+------------+    1 row in set (0.00 sec)    mysql> SELECT *    -> FROM demo.goodsmaster;    +------------+---------+-----------+------------+    | itemnumber | barcode | goodsname | salesprice |    +------------+---------+-----------+------------+    | 1 | 0001 | 本 | 89.00 |    | 2 | 0002 | 笔 | 5.00 |    | 3 | 0003 | 胶水 | 10.00 |                        -- 实际表中也已经没有商品编号是5的商品了    +------------+---------+-----------+------------+    3 rows in set (0.00 sec)**3. 修改视图中的数据**我们可以通过 UPDATE语句对视图中的数据进行修改：    mysql> UPDATE demo.view_goodsmaster             -- 更新视图中的数据    -> SET salesprice = 100    -> WHERE itemnumber = 1;    Query OK, 1 row affected (0.01 sec)    Rows matched: 1 Changed: 1 Warnings: 0结果显示，更新成功了。现在我们来查看一下视图和实际数据表，代码如下所示：    mysql> SELECT *    -> FROM demo.view_goodsmaster;    +------------+---------+-----------+------------+    | itemnumber | barcode | goodsname | salesprice |    +------------+---------+-----------+------------+    | 1 | 0001 | 本 | 100.00 |                        -- 视图中的售价改过了    +------------+---------+-----------+------------+    1 row in set (0.01 sec)    mysql> SELECT *    -> FROM demo.goodsmaster;    +------------+---------+-----------+------------+    | itemnumber | barcode | goodsname | salesprice |    +------------+---------+-----------+------------+    | 1 | 0001 | 本 | 100.00 |                        -- 实际数据表中的售价也改过了    | 2 | 0002 | 笔 | 5.00 |    | 3 | 0003 | 胶水 | 10.00 |    +------------+---------+-----------+------------+    3 rows in set (0.00 sec)可以发现，视图和原来的数据表都已经改过来了。需要注意的是，**我不建议你对视图的数据进行更新操作**，因为 MySQL 允许用比较复杂的 SQL 查询语句来创建视图（比如SQL 查询语句中使用了分组和聚合函数，或者是 UION 和 DISTINCT关键字），所以，要通过对这个结果集的更新来更新实际数据表，有可能不被允许，因为MySQL没办法精确定位实际数据表中的记录。就比如刚刚讲到的那个"每日销售统计查询"视图就没办法更改，因为创建视图的SQL 语句是一个包含了分组函数（GROUPBY）的查询。视图有哪些优缺点？到这里，视图的操作我就讲完了，现在我们把视线拔高一点，来看看视图都有哪些优缺点。只有全面掌握视图的特点，我们才能充分享受它的高效，避免踩坑。首先，我来介绍下视图的优点。第一，因为我们可以把视图看成一张表来进行查询，所以在使用视图的时候，我们不用考虑视图本身是如何获取数据的，里面有什么逻辑，包括了多少个表，有哪些关联操作，而是可以直接使用。这样一来，实际上就把查询模块化了，查询变得更加简单，提高了开发和维护的效率。所以，你可以把那些经常会用到的查询和复杂查询的子查询定义成视图，存储到数据库中，这样可以为你以后的使用提供方便。第二，视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源。第三，视图具有隔离性。视图相当于在用户和实际的数据表之间加了一层虚拟表。也就是说，**用户不需要查询数据表，可以直接通过视图获取数据表中的信息**。这样既提高了数据表的安全性，同时也通过视图把用户实际需要的信息汇总在了一起，查询起来很轻松。![](Images/a96aebde8adbc232ffdf097015f0f550.png)savepage-src="https://static001.geekbang.org/resource/image/a2/45/a2ca36c520ed6a6fee5f788d5dcb2845.jpg"}第四，**视图的数据结构相对独立，即便实际数据表的结构发生变化，我们也可以通过修改定义视图的查询语句，让查询结果集里的字段保持不变**。这样一来，针对视图的查询就不受实际数据表结构变化的影响了。这一点不容易理解，我举个小例子来说明一下。假设我们有一个实际的数据表（demo.goodsmaster），包括商品编号、条码、名称、规格和售价等信息：![](Images/9b786c607a4ce89c3d96b310a2bd9acc.png)savepage-src="https://static001.geekbang.org/resource/image/63/8f/63f46f64a5007278b97235a00633d58f.jpeg"}在这个表的基础上，我们建一个视图，查询所有价格超过 50元的商品：     mysql> CREATE VIEW demo.view_goodsmaster AS    -> SELECT *    -> FROM demo.goodsmaster    -> WHERE salesprice > 50;    Query OK, 0 rows affected (0.03 sec)接着，我们在这个视图的基础上做一个查询，来验证一下视图的内容：    mysql> SELECT barcode,goodsname,specification    -> FROM demo.view_goodsmaster;    +---------+-----------+---------------+    | barcode | goodsname | specification |    +---------+-----------+---------------+    | 0001 | 本 | 16开 |    +---------+-----------+---------------+    1 row in set (0.00 sec)结果显示，我们得到了商品信息表中售价大于 50 元的商品：本（16开）。 假设现在我们需要把数据表 demo.goodsmaster中的字段"specification"删掉，就可以用下面的代码：    mysql> ALTER TABLE demo.goodsmaster DROP COLUMN specification;    Query OK, 0 rows affected (0.13 sec)    Records: 0 Duplicates: 0 Warnings: 0这样一来，因为少了一个字段，而我们的语句又是直接查询数据表的，代码就会提示错误：    mysql> SELECT barcode,goodsname,specification    -> FROM demo.goodsmaster;    ERROR 1054 (42S22): Unknown column 'specification' in 'field list'你看，代码提示字段"specification"不存在。但是，如果查询的是视图，就可以通过修改视图来规避这个问题。我们可以用下面的代码把刚才的视图修改一下：    mysql> ALTER VIEW demo.view_goodsmaster    -> AS    -> SELECT    -> itemnumber,    -> barcode,    -> goodsname,    -> '' as specification, -- 由于字段不存在，插入一个长度是0的空字符串作为这个字段的值    -> salesprice    -> FROM demo.goodsmaster    -> WHERE salesprice > 50;    Query OK, 0 rows affected (0.02 sec)你看，虽然实际数据表中已经没有字段"specification"了，但是视图中却保留了这个字段，而且字段值始终是空字符串。所以，我们不用修改原有视图的查询语句，它也会正常运行。下面的代码查询的结果中，就包括了实际数据表没有的字段"specification"。    mysql> SELECT barcode,goodsname,specification    -> FROM demo.view_goodsmaster;    +---------+-----------+---------------+    | barcode | goodsname | specification |    +---------+-----------+---------------+    | 0001 | 本 | |    +---------+-----------+---------------+    1 row in set (0.00 sec)结果显示，运行成功了。这个视图查询，就没有受到实际数据表中删除字段的影响。看到这儿，你可能会说，视图有这么多好处，那我以后都用视图可以吗？其实不是的，视图也有自身的不足。如果我们在实际数据表的基础上创建了视图，那么，**如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护**。特别是当视图是由视图生成的时候，维护会变得比较复杂。因为创建视图的SQL查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。为了方便你掌握，我用一张图来汇总下视图的优缺点：![](Images/0dc5bae4c32ee0841822a713ec41f033.png)savepage-src="https://static001.geekbang.org/resource/image/d4/12/d4cb502799c8328d22774907d7b97212.jpeg"}总结今天，我给你介绍了简化查询的工具：视图，我们学习了创建视图、操作视图和视图中的数据的方法以及视图的优缺点。你要重点掌握操作的语法结构。最后，我还是想提醒你一下，虽然可以更新视图数据，但总的来说，视图作为虚拟表，主要用于方便查询。我不建议你更新视图的数据，因为对视图数据的更改，都是通过对实际数据表里数据的操作来完成的，而且有很多限制条件。视图虽然有很多优点。但是在创建视图、简化查询的同时，也要考虑到视图太多而导致的数据库维护成本的问题。视图不是越多越好，特别是嵌套的视图（就是在视图的基础上创建视图），我不建议你使用，因为逻辑复杂，可读性不好，容易变成系统的潜在隐患。思考题假设某公园售票系统包括门票信息表和类别信息表，这两个表之间通过类别编号相关联。门票信息表包含门票编号、名称、类别编号和剩余数量等信息。![](Images/2871a5aa2a720b128f279f9402590741.png)savepage-src="https://static001.geekbang.org/resource/image/e1/6a/e1d07bcc301ec2929ff50d601b3c5a6a.jpeg"}类别信息表包含类别编号、开门时间和闭馆时间。![](Images/1aa70366166ffcc8724ede8a7ca7427c.png)savepage-src="https://static001.geekbang.org/resource/image/8f/42/8f21b2f64c2bb51ab7719f27d40ed942.jpeg"}请编写一个视图，视图返回的结果集包括：当前时间可以卖的门票名称和剩余数量（说明：开门前30 分钟开始售票，结束前 30分钟停止售票）。欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你把它分享给你的朋友或同事，我们下节课见。