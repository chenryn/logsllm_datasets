# SUDO漏洞提权实战（CVE-2021-3156 POC）
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 引言
​
最近刷公众号看到了一个sudo的漏洞，看漏洞介绍是个堆缓冲区溢出的漏洞，出于手痒想跟进一下这个漏洞。经过一番折腾，发现这个漏洞还挺典型的，于是总结了一些想法。接下来我会在漏洞分析、提权原理、利用方案、实战分析等方面表达一些自己的观点。
## 漏洞分析
​ 这几天网上对这个漏洞分析已经挺多的了，这里我再简略分析一下，详情可以参考一下 **Qualys** 团队的研究记录。 **Qualys**
团队统计的漏洞影响范围是1.8.2 – 1.8.31p2 以及 1.9.0 -1.9.5p1，使用默认编译选项发行的版本。可以在
下载sudo的源代码（我使用的是1_9_5p1版本的源码）。接下来我们一起看一下源码中set_cmnd方法：
    // plugins/sudoers/sudoers.c
    913 /*
    914  * Fill in user_cmnd, user_args, user_base and user_stat variables
    915  * and apply any command-specific defaults entries.
    916  */
    917 static int
    918 set_cmnd(void)
    919 {
    ...
    957         /* Alloc and build up user_args. */
    958         for (size = 0, av = NewArgv + 1; *av; av++)
    959         size += strlen(*av) + 1;
    960         if (size == 0 || (user_args = malloc(size)) == NULL) {
    961         sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
    962         debug_return_int(NOT_FOUND_ERROR);
    963         }
    964         if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
    965         /*
    966          * When running a command via a shell, the sudo front-end
    967          * escapes potential meta chars.  We unescape non-spaces
    968          * for sudoers matching and logging purposes.
    969          */
    970         for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
    971             while (*from) {
    972             if (from[0] == '\\' && !isspace((unsigned char)from[1]))
    973                 from++;
    974             *to++ = *from++;
    975             }
    976             *to++ = ' ';
    977         }
    978         *--to = '\0';
    979         } else {
    ···
漏洞发生在如下逻辑中：
  1. 在958~963行会计算输入参数字符串长度，分配对等大小的堆内存。
  2. 在970~978会把参数逐字节拷贝到已分配好的内存中。
  3. 在972 判断了 {‘\‘, ‘\0’} 这种情况，作者的本意应该是处理转义字符，结果造成了其他漏洞。
当遇到 -s ‘param\‘’ 这种参数时：
  1. 分配内存长度为: size = strlen(“param\“) 。
  2. 当970~978判断参数 {‘\‘, ‘\0’} 时执行 from++，参数的结束符 {‘\0’} 被跳过。
  3. 最终导致参数以后的内存会继续向user_args中拷贝，直到遇到{‘\0’} 才结束。
  4. linux 命令行程序参数后边的内存空间存放的是当前命令行的环境变量。因而可以继续构造包含{‘\‘, ‘\0’} 的环境变量，实现内存任意溢出。
接下让我们看一下sudo程序的运行内存，验证上诉的第4点。
    # env -i HOME=/root PATH=/usr/bin/ '11=b\' '22=c\' '33=dddddddddddddddddd' gdb --args /tmp/sudo/bin/sudoedit
    pwndbg> show env
    HOME=/root
    PATH=/usr/bin/
    11=b\
    22=c\
    33=ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd
    pwndbg> b sudoers.c:1014    
    Breakpoint 3 at 0x7fa8a7fcf19d: sudoers.c:1014. (2 locations)
    pwndbg> r -s 'aaaaaaaaaaaaaaaaaaaaaaaaa\'
    ...
    pwndbg> p sudo_user.cmnd_args
    $1 = 0x555c71019e70 'a' 
    pwndbg> hexdump sudo_user.cmnd_args 128
    +0000 0x555c71019e70  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│
    +0010 0x555c71019e80  61 61 61 61  61 61 61 61  61 00 31 31  3d 62 00 32  │aaaa│aaaa│a.11│=b.2│
    +0020 0x555c71019e90  32 3d 63 00  33 33 3d 64  64 64 64 64  64 64 64 64  │2=c.│33=d│dddd│dddd│
    +0030 0x555c71019ea0  64 64 64 64  64 64 64 64  64 64 64 64  64 64 64 64  │dddd│dddd│dddd│dddd│
    ...
    +0060 0x555c71019ed0  64 64 64 64  64 64 64 64  64 64 64 64  64 64 00 65  │dddd│dddd│dddd│dd.e│
    +0070 0x555c71019ee0  20 6d 6f 64  65 73 2e 0a  23 20 53 65  65 20 74 68  │.mod│es..│#.Se│e.th
我们发现sudo_user.cmnd_args内存以后的内存已经被环境变量覆盖了。
## 提权原理分析
​ 说到sudo类程序的提权原理，我们需要复习一下linux文件权限表，日常开发中我们常用的文件配置权限如下：
    -rw------- (600)    只有拥有者有读写权限。
    -rw-r--r-- (644)    只有拥有者有读写权限；而属组用户和其他用户只有读权限。
    -rwx------ (700)    只有拥有者有读、写、执行权限。
    -rwxr-xr-x (755)    拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。
    -rwx--x--x (711)    拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。
    -rw-rw-rw- (666)    所有用户都有文件读、写权限。
    -rwxrwxrwx (777)    所有用户都有读、写、执行权限。
我们在分别查看一下普通程序（/usr/bin/ls）和sudo类程序（/usr/bin/sudo）的文件权限配置：
    -> % stat -c '%04a %U %G %n' /usr/bin/ls  
    0755 root root /usr/bin/ls
    -> % stat -c '%a %U %G %n' /usr/bin/sudo
    4755 root root /usr/bin/sudo
sudo程序的不难发现多最高位权限码是4，这个文件权限码涉及的linux文件的SUID、SGID、Sticky权限配置，这三个具体作用如下：
  * SUID: 作用于二进制文件，使用者将继承此程序的所有者权限
  * SGID: 作用于二进制文件和目录 
    * 对于二进制文件: 使用者将继承此程序的所属组权限
    * 对于目录: 此文件夹下所有用户新建文件都自动继承此目录的用户组
  * Sticky:作用于目录，目录中每个用户仅能删除、移动或改名自己的文件或目录
sudo程序具备SUID权限，同时sudo的所有者是root，因此普通用户执行sudo程序是可以以root身份去执行的，我们可以实现个简版的sudo.min
程序测试一下:
    -> % cat  1 && execvp(argv[1], argv + 1);
    }
    EOF
    -> % sudo chmod 4755 sudo.min
    -> % stat -c '%04a %U %G %n' sudo.min
    4755 root root sudo.min
    -> % ./sudo.min id -u
    0
    -> % ./sudo.min sh
    sh-5.0# id -u
    0
上诉简版的sudo程序中我们不难发现带有SUID权限的sudo程序具备了所有者（root）的权限。然而真正的sudo程序会在执行输入命令前鉴定执行者的权限，只有通过了，才会继续执行输入的命令。CVE-2021-3156漏洞在发生在方法set_cnmd，此方法是权限鉴定前的逻辑，因此会造成任意用户提全的风险。
## 利用方案
​ 根据前文的漏洞分析我们已经知道，可以通过输入特殊的参数和环境变量，实现任意大小的堆内存溢出， **Qualys**
团队给出了三种利用这个漏洞的思路，我发现这三种漏洞利用思路属于比较经典的堆溢出利用方案，接下来我会将详细剖析一下这三种利用思路。
###  重写函数指针
​ 函数指针在CPU执行过程中会经历间接寻址、执行的过程，因此替换函数指针的值便可以实现任意代码执行， **Qualys**
团队通过crash日志分析找到了struct sudo_hook_entry，修改struct
sudo_hook_entry实例可以实现任意代码执行的目的，接下来我们根据源码探究一下这个方案的可行性。
    // src/hooks.c
    ...
     34 /* Singly linked hook list. */
     35 struct sudo_hook_entry {
     36     SLIST_ENTRY(sudo_hook_entry) entries;
     37     union {
     38     sudo_hook_fn_t generic_fn;
     39     sudo_hook_fn_setenv_t setenv_fn;
     40     sudo_hook_fn_unsetenv_t unsetenv_fn;
     41     sudo_hook_fn_getenv_t getenv_fn;
     42     sudo_hook_fn_putenv_t putenv_fn;
     43     } u;
     44     void *closure;
     45 };
     46 SLIST_HEAD(sudo_hook_list, sudo_hook_entry);
     47 
     48 /* Each hook type gets own hook list. */
     49 static struct sudo_hook_list sudo_hook_setenv_list =
     50     SLIST_HEAD_INITIALIZER(sudo_hook_setenv_list);
     51 static struct sudo_hook_list sudo_hook_unsetenv_list =
     52     SLIST_HEAD_INITIALIZER(sudo_hook_unsetenv_list);
     53 static struct sudo_hook_list sudo_hook_getenv_list =
     54     SLIST_HEAD_INITIALIZER(sudo_hook_getenv_list);
     55 static struct sudo_hook_list sudo_hook_putenv_list =
     56     SLIST_HEAD_INITIALIZER(sudo_hook_putenv_list);
    ...
    125 /* Hook registration internals. */
    126 static int
    127 register_hook_internal(struct sudo_hook_list *head,
    128     int (*hook_fn)(), void *closure)
    129 {
    130     struct sudo_hook_entry *hook;
    131     debug_decl(register_hook_internal, SUDO_DEBUG_HOOKS);
    132 
    133     if ((hook = calloc(1, sizeof(*hook))) == NULL) {
    134     sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,
    135         "unable to allocate memory");
    136     debug_return_int(-1);
    137     }
    138     hook->u.generic_fn = hook_fn;
    139     hook->closure = closure;
    140     SLIST_INSERT_HEAD(head, hook, entries);
    141 
    142     debug_return_int(0);
    143 }
    ...
​ 分析struct sudo_hook_entry
的定义中我们不难发现，sudo_hook_entry中包含一个函数指针，而且这个指针还是一个union类型的指针。（猜测作者应该是想作为智能指针使用，智能指针详情，请了解
c++
的auto指针）。因为这个漏洞是堆溢出类型的漏洞，如果想通过溢出直接修改sudo_hook_entry的实例，sudo_hook_entry的实例最好是在堆空间的实例（由malloc、calloc、……申请的内存是堆空间，如果是静态区就比较麻烦了）。分析register_hook_internal函数的133行我们不难发现，sudo_hook_entry的实例是由calloc申请的内存。因此只要sudo_hook_entry实例的函数指针在sudo程序中有被执行，修改sudo_hook_entry实例的函数指针的确能够实现任意任意代码执行的目的。
​ 上述我们分析论证了重写sudo_hook_entry实例的理论可行性，不过想要真正的实现任意代码执行，对于这个程序还要满足其他条件，我总结为以下几点：
  * 能够加载自定义的代码，修改实例函数指针，让其执行自定义代码。
  * 能够执行自定义代码，修改实力函数指针为execv、dlopen等加载额外代码的接口地址，再配合有效的参数，实现执行自定义代码模块。
​ **Qualys** 团队通过构造参数满足第二个条件来实现任意代码执行的。让我们继续分析源码，探求一下其中原理。
    // src/hooks.c 
    ...
     90 /* NOTE: must not anything that might call getenv() */
     91 int
     92 process_hooks_getenv(const char *name, char **value)
     93 {
     94     struct sudo_hook_entry *hook;