ğ‘§âˆˆ{0,1}log ğ‘€
ğ‘§âˆˆ{0,1}log ğ‘€
Ëœğ›½(ğ‘¢, ğ‘§)ğœ”XZ
Ëœğ›½(ğ‘¢, ğ‘§)ğœ”X(ğ‘§0Â·2log ğ‘€âˆ’1+ğ‘§1Â·2log ğ‘€âˆ’2+Â·Â·Â·+ğ‘§log ğ‘€âˆ’1) ,
(6)


=
=
Algorithm 1 Sumcheck( Ëœğ‘, Ağ‘, Ëœğ¹, Ağ¹ , ğ‘Ÿ1, . . . , ğ‘Ÿlog ğ‘)
Input: Arrays Ağ‘ and Ağ¹ storing Ëœğ‘(ğ‘¥) and Ëœğ¹(ğ‘¢, ğ‘¥) on all
ğ‘¥ âˆˆ {0, 1}log ğ‘ , random ğ‘Ÿ1, . . . , ğ‘Ÿlog ğ‘ ;
Output: log ğ‘ sumcheck messages forğ‘¥âˆˆ{0,1}log ğ‘€ Ëœğ‘(ğ‘¥) Ëœğ¹(ğ‘¢, ğ‘¥).
Each message consists of 3 elements;
1: for ğ‘– = 1, . . . , log ğ‘ do
for ğ‘ âˆˆ {0, 1}â„“âˆ’ğ‘– do
2:
for ğ‘¡ = 0, 1, 2 do
3:
4:
5:
6:
7:
// ğµ is the number represented by ğ‘.
Ëœğ‘(ğ‘Ÿ1, . . . , ğ‘Ÿğ‘–âˆ’1, ğ‘¡, ğ‘) = Ağ‘[ğµ] Â·(1âˆ’ğ‘¡)+Ağ‘[ğµ+2â„“âˆ’ğ‘–] Â·ğ‘¡
Ëœğ¹(ğ‘Ÿ1, . . . , ğ‘Ÿğ‘–âˆ’1, ğ‘¡, ğ‘) = Ağ¹ [ğµ]Â·(1âˆ’ğ‘¡)+Ağ¹ [ğµ+2â„“âˆ’ğ‘–]Â·ğ‘¡
// Aggregate messages in round ğ‘–.
Sendğ‘âˆˆ{0,1}â„“âˆ’ğ‘– Ëœğ‘(ğ‘Ÿ1, . . . , ğ‘Ÿğ‘–âˆ’1, ğ‘¡, ğ‘) Â· Ëœğ¹(ğ‘Ÿ1, . . . , ğ‘Ÿğ‘–âˆ’1, ğ‘¡, ğ‘)
for ğ‘¡ âˆˆ {0, 1, 2} do
for ğ‘ âˆˆ {0, 1}â„“âˆ’ğ‘– do
// Update the arrays.
Ağ‘[ğµ] = Ağ‘[ğµ] Â· (1 âˆ’ ğ‘Ÿğ‘–) + Ağ‘[ğµ + 2â„“âˆ’ğ‘–] Â· ğ‘Ÿğ‘–
Ağ¹ [ğµ] = Ağ¹ [ğµ] Â· (1 âˆ’ ğ‘Ÿğ‘–) + Ağ¹ [ğµ + 2â„“âˆ’ğ‘–] Â· ğ‘Ÿğ‘–
8:
9:
10:
where Z = ğ‘§0 Â· 2log ğ‘€âˆ’1 +ğ‘§1 Â· 2log ğ‘€âˆ’2 +Â· Â· Â·+ğ‘§log ğ‘€âˆ’1 is the number
represented by the binary string ğ‘§ with ğ‘§0 being the most significant
bit. By the closed-form of Ëœğ›½ given in Section 2.2.1, the equation
ğ‘§âˆˆ{0,1}log ğ‘€
above is equal to


=
=
ğ‘§âˆˆ{0,1}log ğ‘€
ğ‘§âˆˆ{0,1}log ğ‘€
ğ‘–=0
log ğ‘€âˆ’1
Â· ğœ”XÂ·log ğ‘€âˆ’1
log ğ‘€âˆ’1
log ğ‘€âˆ’1
log ğ‘€âˆ’1
Â·log ğ‘€âˆ’1
Â· ğœ”
ğ‘–=0
ğ‘–=0
ğ‘—=0
ğ‘—=0
((1 âˆ’ ğ‘¢ğ‘–)(1 âˆ’ ğ‘§ğ‘–) + ğ‘¢ğ‘–ğ‘§ğ‘–)
2log ğ‘€âˆ’1âˆ’ğ‘— ğ‘§ ğ‘—
ğ‘—=0
((1 âˆ’ ğ‘¢ğ‘–)(1 âˆ’ ğ‘§ğ‘–) + ğ‘¢ğ‘–ğ‘§ğ‘–)
2log ğ‘€âˆ’1âˆ’ğ‘— Â·(XÂ·ğ‘§ ğ‘—)
((1 âˆ’ ğ‘¢ğ‘–)(1 âˆ’ ğ‘§ğ‘–) + ğ‘¢ğ‘–ğ‘§ğ‘–)
(ğœ”2log ğ‘€âˆ’1âˆ’ğ‘—)XÂ·ğ‘§ ğ‘— .
(7)
ğœ”XÂ·ğ‘§ ğ‘—
2ğ‘—+1
2ğ‘—+1 above is the 2ğ‘—+1-th root of unity. We
Note that ğœ”2log ğ‘€âˆ’1âˆ’ğ‘—
use the same notation as in [19] to denote it as ğœ”2ğ‘—+1. Then the
equation above is
= ğœ”
ğ‘€
ğ‘§âˆˆ{0,1}log ğ‘€


log ğ‘€âˆ’1
log ğ‘€âˆ’1
ğ‘–=0
ğ‘–=0
log ğ‘€âˆ’1
((1 âˆ’ ğ‘¢ğ‘–)(1 âˆ’ ğ‘§ğ‘–) + ğ‘¢ğ‘–ğ‘§ğ‘–) Â·
log ğ‘€âˆ’1
log ğ‘€âˆ’1

(cid:16)(1 âˆ’ ğ‘¢ğ‘–) + ğ‘¢ğ‘– Â· ğœ”X
ğ‘§ğ‘– âˆˆ{0,1} ((1 âˆ’ ğ‘¢ğ‘–)(1 âˆ’ ğ‘§ğ‘–) + ğ‘¢ğ‘–ğ‘§ğ‘–) Â· ğœ”XÂ·ğ‘§ğ‘–
((1 âˆ’ ğ‘¢ğ‘–)(1 âˆ’ ğ‘§ğ‘–) + ğ‘¢ğ‘–ğ‘§ğ‘–) Â· ğœ”XÂ·ğ‘§ğ‘–
2ğ‘–+1
(cid:17) .
2ğ‘–+1
ğ‘—=0
ğ‘–=0
ğ‘§âˆˆ{0,1}log ğ‘€
=
=
=
=
ğ‘–=0
2ğ‘–+1
(8)
An easy way to check the correctness of the equation above is that
both Ëœğ¹(ğ‘¢, ğ‘¥) and Equation 8 are multilinear extensions of matrix ğ¹.
By the uniqueness of multilinear extensions, they must be equal as
long as they agree on all binary inputs. Therefore, by substituting ğ‘¢
with any binary string, it is not hard to see that they are the same,
because ğ‘¢ğ‘– is a selector to choose the right ğœ”X
2ğ‘–+1 to multiply together
in Equation 8. Moreover, if we take a closer look at each parenthesis,
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2973Algorithm 2 Ağ¹ â† Initialize(ğœ”, ğ‘¢, ğ‘)
Input: ğ‘€-th root of unity ğœ”, random point ğ‘¢ âˆˆ Flog ğ‘€ and the
degree ğ‘ ;
Output: Ağ¹ storing Ëœğ¹(ğ‘¢, ğ‘¥) for all ğ‘¥ âˆˆ {0, 1}log ğ‘ .
1: Ağ¹ [0] = 1;
2: for ğ‘– = 0, . . . , log ğ‘ âˆ’ 1 do
3:
4:
Ağ¹ [ ğ‘—] = Ağ¹ [ ğ‘— mod 2ğ‘–] Â·(cid:16)(1 âˆ’ ğ‘¢ğ‘–) + ğ‘¢ğ‘– Â· ğœ” ğ‘—
for ğ‘— = 2ğ‘–+1 âˆ’ 1, . . . , 0 do
(cid:17)
2ğ‘–+1
// In round ğ‘–, (ğœ”2ğ‘–+1)X has 2ğ‘–+1 possible values âˆ€X âˆˆ [ğ‘ ], indexed by
ğ‘— = X mod 2ğ‘–+1.
5: return Ağ¹ ;
ğœ”2ğ‘–+1 is the 2ğ‘–+1-th root of unity, and ğœ”X
2ğ‘–+1 only has 2ğ‘–+1 distinct
values for all X âˆˆ [ğ‘], which is exactly the property used in the
standard FFT algorithm. Therefore, instead of computing Ëœğ¹(ğ‘¢, ğ‘¥)
for every ğ‘¥ âˆˆ {0, 1}log ğ‘ one by one, we divide the computation in
log ğ‘€ iterations. In each iteration ğ‘–, the prover computes a running
product for each ğ‘¥ with the first ğ‘–-th parenthesis in Equation 8 from
the last iteration. Specifically, the prover precomputes all ğ‘€ distinct
2ğ‘–+1 for 0 â‰¤ ğ‘– < log ğ‘ âˆ’ 1, 0 â‰¤ ğ‘— < 2ğ‘–+1 (which are the
values of ğœ” ğ‘—
points to evaluate anyway), calculates all 2ğ‘–+1 different values of
((1 âˆ’ ğ‘¢ğ‘–) + ğ‘¢ğ‘–ğœ” ğ‘—
2ğ‘–+1) in iteration ğ‘– and multiplies them to 2ğ‘– distinct
running products in iteration ğ‘–âˆ’1. In the last iteration, the algorithm
outputs ğ‘ values for Ëœğ¹(ğ‘¢, ğ‘¥) âˆ€ğ‘¥ âˆˆ {0, 1}log ğ‘ , and the total running
time is ğ‘‚(ğ‘€ + ğ‘). The algorithm is presented in Algorithm 2.
Together with Algorithm 1, we are able to construct an algorithm
for the prover to generate all proofs in the sumcheck protocol on
Equation 5 in time ğ‘‚(ğ‘€ + ğ‘). The proof size is ğ‘‚(log ğ‘) and the
verifier time is ğ‘‚(log ğ‘), given oracle accesses of Ëœğ‘(Â·) and Ëœğ¹(Â·).
Reducing the verifier time. Though our new protocol has op-
timal prover time and good proof size, it introduces an overhead
on the verifier time. In particular, the oracle accesses of Ëœğ‘(Â·) and
Ëœğ‘(Â·) are usually provided by the prover or computed on verifierâ€™s
input as in existing approaches mentioned above, but our proto-
col requires an additional evaluation of Ëœğ¹(Â·) at a random point. It
takes linear time if the verifier evaluates it on her own using a
similar algorithm as the prover in Algorithm 2. We further show
an approach to delegate this computation through a sequence of
sumcheck protocols.
Our approach follows exactly the same algorithm to compute
Ağ¹ , the bookkeeping table, in Algorithm 2. Recall that Ağ¹ stores
Ëœğ¹(ğ‘¢, ğ‘¥) âˆ€ğ‘¥ âˆˆ {0, 1}log ğ‘ , thus Ëœğ¹(ğ‘¢, ğ‘£) is the multilinear extension of
Ağ¹ evaluated at ğ‘£. Moreover, in Algorithm 2, the values in Ağ¹ in
the ğ‘–-th round are computed from the values in the (ğ‘– âˆ’ 1)-th round
by the equation in Step 4. Therefore, we abuse the notation and use
ğ´(ğ‘–)
ğ¹ (Â·) : {0, 1}ğ‘–+1 â†’ F to denote the array Ağ¹ in the ğ‘–-th round for
ğ‘– = 0, . . . , log ğ‘ âˆ’1, and Ëœğ´(ğ‘–)
ğ¹ (Â·) : Fğ‘–+1 â†’ F to denote its multilinear
extension. Then Ëœğ¹(ğ‘¢, ğ‘£) = Ëœğ´(log ğ‘âˆ’1)
ğ¹ (Â·)
as an equation of ğ´(ğ‘–âˆ’1)
(ğ‘£), and we can write ğ´(ğ‘–)
ğ¹
ğ¹
(Â·):
ğ´(ğ‘–)
ğ¹ (ğ‘¥, ğ‘) = ğ´(ğ‘–âˆ’1)
ğ¹
(ğ‘¥)((1 âˆ’ ğ‘¢ğ‘–) + ğ‘¢ğ‘– Â· ğœ”ğ‘–+1(ğ‘¥, ğ‘)),
(9)
Â¯ğ‘ˆ ğ‘— =
Â¯ğ‘‹ ğ‘—âˆ’ğ‘– Â¯ğ‘Šğ‘–
ğ‘–=0
ğ‘–
for all ğ‘¥ âˆˆ {0, 1}ğ‘–, ğ‘ âˆˆ {0, 1}, where ğœ”ğ‘–+1(ğ‘¥, ğ‘) = ğœ” ğ‘—
2ğ‘–+1 for ğ‘— =
ğ‘˜=0 ğ‘¥ğ‘˜2ğ‘˜+1 + ğ‘, the number in F represented by (ğ‘¥, ğ‘) in binary.
Equation 9 is exactly the same as Step 4 in Algorithm 2 with binary
indices. Then by Definition 2.3,
Ëœğ´(ğ‘–)
ğ¹ (ğ‘¥, ğ‘) =
(ğ‘§)((1âˆ’ğ‘¢ğ‘–)+ğ‘¢ğ‘–Â· Ëœğœ”ğ‘–+1(ğ‘§, ğ‘)), (10)
Ëœğ›½(ğ‘¥, ğ‘§) Ëœğ´(ğ‘–âˆ’1)

ğ¹
ğ‘§âˆˆ{0,1}ğ‘–
ğ¹
for all ğ‘¥ âˆˆ Fğ‘–, ğ‘ âˆˆ F, as both sides agree on the Boolean hypercube
by Equation 9, and are both multilinear in ğ‘¥ and ğ‘.
Starting from Ëœğ¹(ğ‘¢, ğ‘£) = Ëœğ´(log ğ‘âˆ’1)
(ğ‘£), the verifier and the prover
can reduce its correctness to the evaluation of Ëœğ´(ğ‘–)
ğ¹ (Â·) at a random
point through a sumcheck protocol on Equation 10 for ğ‘– = log ğ‘ âˆ’
1, . . . , 0. In the last round, as defined in Step 1 of Algorithm 2, Ëœğ´(0)
ğ¹ (Â·)
is simply the constant 1. As the size of Ëœğ›½(Â·), Ëœğ´(ğ‘–)
ğ¹ (Â·) and Ëœğœ”ğ‘–+1Â· in
the ğ‘–-th sumcheck are ğ‘‚(2ğ‘–), the prover time is ğ‘‚(2ğ‘–) using the
dynamic programming technique in Algorithm 1. The proof size in
the ğ‘–-th sumcheck is ğ‘‚(ğ‘–). It remains to show that the verifier time is
also logarithmic. The verifier time during the ğ‘–-th sumcheck is ğ‘‚(ğ‘–).