### Target Real-Time System

A real-time system is driven by **interrupts**. Even the notion of time is built from interrupts. A hardware clock periodically interrupts the system to indicate the passage of time. Interrupts can be categorized into **internal interrupts** and **external interrupts**. Internal interrupts, such as those generated by the clock, are activated within the target system. External interrupts, on the other hand, are triggered by external devices, such as sensors.

Interrupts drive the **progress** of a real-time system. Periodic tasks are released at regular intervals following a specified number of clock interrupts. Conversely, sporadic and aperiodic tasks are typically activated by external interrupts. In the absence of interrupts, the system cannot evolve; in other words, it is **stalled**.

### Emulation Approach

The emulation approach involves properly **stopping** both internal and external devices to prevent them from triggering interrupts while the tool executes, and then **resuming** them at the end of the tool execution.

#### Internal Devices
The primary internal device in a real-time system is the **hardware clock**. This device periodically interrupts the software executive to inform of the passage of time. The hardware clock usually consists of an interval counter that triggers an interrupt when it reaches zero (e.g., the Intel 8254 interval timer). Such a device can be managed by software to disable and resume its counting. For example, the **interrupt on terminal count** mode of the Intel 8254 interval timer provides this feature.

#### External Devices
When testing a real-time system, external devices can be emulated by software. For instance, the behavior of a temperature sensor can be emulated by a program that models a virtual environment where the temperature fluctuates, and triggers an interrupt whenever the temperature exceeds a predetermined threshold. When external devices are emulated by software, stopping and resuming their progression involves stopping and resuming the execution of the emulation program.

Emulation software can run either on a distant machine or on the target machine. If it runs on a distant machine, the tool can stop and resume its execution by disabling or activating a signal of a communication port connected to the distant machine.

### Execution Steps of MAFALDA-RT

Each execution of the tool follows the steps shown in Figure 2:

1. **Stop the hardware clock.**
2. **Disable the communication port** (if applicable) to halt the execution of the emulator.
3. **Inject a fault** and/or observe the system behavior.
4. **Enable the communication port** (if applicable).
5. **Resume the hardware clock.**

If external devices are emulated on the target machine, the tool also activates a step of the emulation program. In this case, the emulator program runs within the tool context, eliminating overhead.

### Advantages and Drawbacks

The main advantage of this approach is the elimination of temporal intrusiveness of the SWIFI tool. Unlike previous approaches, our method can test real-time systems without modifying the real-time application or the tool to fit temporal constraints. However, the main drawback is that the real physical environment cannot be used. At a given abstraction level, an emulator of the real environment must be provided. It is worth noting that emulating external devices by software (e.g., sensors and actuators) is a common practice during the testing phase.

### Characterization of Real-Time Systems in the Presence of Faults

This section describes typical fault manifestations in a real-time system and the strategies for analyzing them. Analyses are automatically performed by the **Analysis Scripts** of MAFALDA-RT.

Let \( I \) be the set of experiments in a fault injection campaign, and \( D \) the set of experiments where the injected fault is activated. Let \( F \) and \( E \) be the sets of experiments where a failure or an error detection is observed, respectively. Figure 3 illustrates these sets.

- **Failures (F)**: These are caused by errors that propagate to the application, leading to failures in the time or value domain. In the timing domain, we distinguish **deadline misses**, **application hangs**, and **system hangs**. In the value domain, the delivery of **incorrect results** is the most critical failure.
- **Error Detections (E)**: The most common error detection mechanisms (EDMs) provided by a microkernel include **alarms** (used to detect deadline misses), **error status** (notifying abnormal termination of a system call), and **exceptions** (low-level errors detected by the hardware, such as segmentation faults).

Our objective is to establish a disjoint classification of experiments based on the fault manifestations observed in a campaign. The key classifications are:

- **No fault manifestation**: If the corrupted memory cell is not used by the processor, the fault is **not activated** (partition D). If the application results are correct despite the fault activation (due to high error latency or masking), the error is **intrinsically tolerated** (partition E).
- **Single manifestation**: If a single manifestation is observed, the system has either **failed** (partition F) or an EDM has signaled an error (partition H).
- **Both failure and error detection**: Statistics about failure occurrence and error detection coverage can vary significantly depending on the analysis strategy (partition G).

### Distribution of Fault Manifestations

Figure 4 shows the distribution of fault manifestations for different scenarios, highlighting the percentage of each type of fault and the total number of experiments.

In general, it is of little interest to signal an error after a failure.