target real-time system.
A real-time system is driven by LQWHUUXSWV. Even the notion of
time  is  built  from  interrupts.  Indeed,  a  hardware  clock
periodically interrupts the system to inform of the pass of time.
Interrupts  can  be  divided  into  LQWHUQDO LQWHUUXSWV  and  H[WHUQDO
LQWHUUXSWV. Internal interrupts are those activated within the target
system (e.g., the clock interrupts), whereas external interrupts are
those triggered by the external devices (e.g., sensors).
Actually,  interrupts  make  the  real-time  system  SURJUHVV.
Periodic  tasks  are  released  at  regular  intervals  after  the
occurrence of a given number of clock interrupts. Conversely,
sporadic  and  aperiodic  tasks  are  usually  activated  by  the
occurrence of an external interrupt. Therefore, in the absence of
interrupts the system cannot evolve, in other words, it is IUR]HQ.
The  emulation  approach  consists  thus  in  properly  VWRSSLQJ
both internal and external GHYLFHV  so as  to prevent them from
triggering interrupts while the tool executes, and then UHVXPLQJ
them at the end of the tool execution.
The  main  internal  device  of  a  real-time  system  is  the
hardware clock. This device periodically interrupts the software
executive  to  inform  of  the  pass  of  time.  The  hardware  clock
usually consists of an interval counter that triggers an interrupt
whenever  it  reaches  value  zero  (e.g.,  the  Intel  8254  interval
timer). Such a device can be usually managed by software so as
to disable and resume its counting.  For  instance, the LQWHUUXSW
RQ WHUPLQDO FRXQW  mode  of  the  Intel  8254  interval  timer
provides such a feature.
Conversely, when testing a real-time system, external devices
can be emulated by software. As an example, the behavior of a
temperature sensor can be emulated by a program that models a
virtual  environment  where  the  temperature  fluctuates,  and  that
triggers an LQWHUUXSW whenever the temperature increases above a
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:25:17 UTC from IEEE Xplore.  Restrictions apply. 
 6WRSWKHKDUGZDUHFORFN
 'LVDEOHWKHFRPPXQLFDWLRQSRUWHPXODWRULQDGLVWDQWPDFKLQH
RUSHUIRUPDQHPXODWLRQVWHSHPXODWRULQWKHWDUJHWPDFKLQH
,QMHFWDIDXOWDQGRUREVHUYHWKHV\VWHPEHKDYLRU

 (QDEOHWKHFRPPXQLFDWLRQSRUWHPXODWRULQDGLVWDQWPDFKLQH
 5HVXPHWKHKDUGZDUHFORFN
Figure 2. Execution steps of MAFALDA-RT
predetermined threshold. When external devices are emulated by
software,  stopping  and  resuming  their  progression  consists  in
stopping and resuming the execution of the emulation program.
Emulation software can run either in a distant machine or in the
target machine. When it runs in a distant machine, the tool can
stop and resume its execution by disabling or activating a signal
of a communication port connected to the distant machine.
Basically,  each  execution  of  the  tool  consists  of  the  steps
shown in Figure 2. Whenever the tool is activated, the 'HYLFH
FRQWUROOHU stops the hardware clock. If external devices are
emulated by a program running on a distant machine, it also
disables  the  line  of  the  communication  port  connected  to
this machine, which will halt the execution of the emulator.
Conversely,  if  external  devices  are  emulated  in  the  target
machine,  the  'HYLFH FRQWUROOHU  allows  a  step  of  the
emulation program to be executed. Note that in this case the
emulator  program  runs  within  the  tool  context,  so  its
overhead  is  eliminated.  Next,  the  ,QMHFWRU  injects  a  fault
and/or the 2EVHUYHU observes the system behavior. Then, the
'HYLFH FRQWUROOHU  enables  the  communication  port  (if
applicable) and resumes the hardware clock. Therefore, the
tool  is  released  whenever  a  fault  must  be  injected  or  an
event must be observed. In addition, if external devices are
emulated  in  the  target  machine,  the  tool  is  also  activated
whenever  a  step  of  the  emulation  program  has  to  be
performed.
This  approach  has  been  successfully  applied  to  the
assessment  by  fault  injection  of  a  uniprocessor-based  real-
time  system,  as  described  in  Section  5.  However,  we  have
not investigated to what extend this approach can be applied
to distributed real-time systems.
The main advantage of this approach is that the temporal
intrusiveness  of  the  SWIFI  tool  is  eliminated.  Therefore,
unlike  previous  approaches  (e.g.,  see  [7,  8]),  our  approach
can be used for testing real-time systems without having to
modify  neither  the  real-time  application  nor  the  tool  to  fit
temporal  constraints.  The  main  drawback,  however,  is  that
the  real  physical  environment  cannot  be  used.  At  a  given
abstraction level, an emulator of the real environment must
be provided. Thus, when the external devices of the system
under test consist of physical devices, an emulation program
for  such  devices  has  to  be  provided  instead.  It  is  worth
noting,  however, 
that  emulating  external  devices  by
software (e.g., sensors and actuators) is a common practice
during the testing phase (e.g., see [9]).
&KDUDFWHUL]DWLRQRIUHDOWLPHV\VWHPV
LQWKHSUHVHQFHRIIDXOWV
This section describes the typical fault manifestations that can
occur in a real-time system, and the different strategies that can
I
A
F
c
a
b
d
D
e
Not activated faults
No error observed
(correct experiments)
Failure observed
Error detection observed
Failure and error detection observed
Figure 3. Fault manifestations
be used to analyze them. Analyses are automatically performed
by the $QDO\VLVVFULSWV of MAFALDA-RT.
Let  ,  be  the  set  of  experiments  of  a  fault  injection
campaign, and $ the  set of  experiments  where  the  injected
fault  is  activated.  Let  )  and  '  be  the  sets  of  experiments
where  a  failure  or  an  error  detection  are  respectively
observed. Figure 3 illustrates these sets.
)DLOXUHV()) are provoked by errors that propagate to the
application, making it fail either in the time or in the value
domain.  In  the  timing  domain,  we  distinguish  the  GHDGOLQH
PLVVHV,  the  DSSOLFDWLRQ KDQJV  and  the  V\VWHP KDQJV.
Conversely, the delivery of LQFRUUHFWUHVXOWV constitutes the
most critical failure in the value domain.
Regarding  HUURUGHWHFWLRQV('),  the  most  common  error
detection mechanisms (EDM) provided by a microkernel are
the $ODUPV (used to detect deadline misses), the (UURUVWDWXV
(notify  an  abnormal  termination  of  a  system  call)  and  the
([FHSWLRQV  (low  level  errors  detected  by  the  hardware,  as
the segmentation faults).
Our  objective  here  is  to  establish  a  disjoint  classification
of  the  experiments  according  to  the  fault  manifestations
observed in a campaign. The experiments most amenable to
classification are the following:
• No  fault  manifestation  is  observed  during  the  fault
injection  experiment.  If 
that  was
corrupted  by  the  fault  is  not  used  by  the  processor,  the
fault is said to be QRWDFWLYDWHG (partition D). Conversely, if
in spite of the activation of the fault the results issued by
the application are correct (i.e., no error is observed,  due
to a high error latency or because the error was masked),
we  conclude  that  the  corresponding  error  has  been
intrinsically tolerated by the system (partition E).
the  memory  cell 
• A  single  manifestation  is  observed  during  the  fault
injection experiment. As a consequence, we conclude that
the  system  has  failed  (partition  F)  or  that  an  EDM  has
signaled an error (partition H).
Let  us  consider  experiments  where  both  a  failure  and  an
error  detection  are  observed,  that  is,  partition  G.  Statistics
about  failure  occurrence  and  error  detection  coverage  can
significantly vary depending on the strategy used to analyze
this partition.
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:25:17 UTC from IEEE Xplore.  Restrictions apply. 
Incorrect
Results
1.6%
Deadline
Missed
0.1%
Application
Hang
4.8%
System
Hang
0.1%
Alarm
0.5%
Correct
31.6%
1282
Exp.
Error
Status
0.2%
Exception
61.1%
Incorrect
Results
3.3%
Application
Hang
1.6%
Alarm
0.4%
Deadline
Missed
0.1%
Correct
40.2%
1347
Exp.
Error
Status
3.9%
Exception
50.5%
a) mSCH
Figure 4. Distribution of fault manifestations
b) mTIM
Application
Incorrect
Results
1.6%
Hang
3.2%
System 
Hang
0.3%
Alarm
3.5%
Error
Status
19.3%
1484
Exp.
Correct
72.0%
c) pTIM
• In general, it is of little interest to signal an error after a failure