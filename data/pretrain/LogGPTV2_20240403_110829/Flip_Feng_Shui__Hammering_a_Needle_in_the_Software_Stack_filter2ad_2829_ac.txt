mer. Apart from additional speed for achieving bit ﬂips,
it provides additional reliability by isolating the location
of most bit ﬂips to a certain (victim) row.
To perform double-sided Rowhammer inside KVM,
we need to know the host physical addresses inside the
VM. This information is, however, not available in the
guest: guest physical addresses are mapped to host vir-
tual addresses which can be mapped to any physical page
by the Linux kernel. Similar to [30], we rely on transpar-
ent huge pages [5] (THP). THP is a Linux kernel feature
6  25th USENIX Security Symposium 
USENIX Association
6
that runs in the background and merges virtually contigu-
ous normal pages (i.e., 4 kB pages) into huge pages (i.e.,
2 MB pages) that rely on contiguous pieces of physical
memory. THP greatly reduces the number of page-table
entries in suitable processes, resulting in fewer TLB3 en-
tries. This improves performance for some workloads.
THP is another (weak) form of memory massaging:
it transparently allows the attacker control over how the
system maps guest physical memory to host physical
memory. Once the VM is started and a certain amount of
time has passed, THP will transform most of the VM’s
memory into huge pages. Our current implementation of
dFFS runs entirely in the userspace of the guest and re-
lies on the default-on THP feature of both the host and
the guest. As soon as the guest boots, dFFS allocates a
large buffer with (almost) the same size as the available
memory in the guest. The THP in the host then converts
guest physical addresses into huge pages and the THP
in the guest turns the guest virtual pages backing dFFS’s
buffer into huge pages as well. As a result, dFFS’s buffer
will largely be backed by huge pages all the way down
to host physical memory.
To make sure that the dFFS’s buffer is backed by huge
pages, we request the guest kernel to align the buffer at a
2 MB boundary. This ensures that if the buffer is backed
by huge pages, it starts with one: on the x86_64 architec-
ture, the virtual and physical huge pages share the lowest
20 bits, which are zero. The same applies when transi-
tioning from the guest physical addresses to host phys-
ical addresses. With this knowledge, dFFS can assume
that the start of the allocated buffer is the start of a mem-
ory row, and since multiple rows ﬁt into a huge page, it
can successively perform double-sided Rowhammer on
these rows. To speed up our search for bit ﬂips during
double-sided Rowhammer on each two rows, we rely on
the row-conﬂict side channel for picking the hammering
addresses within each row [44]. We further employed
multiple threads to amplify the Rowhammer effect.
While THP provides us with the ability to efﬁciently
and reliably induce Rowhammer bit ﬂips, it has unex-
pected interactions with KSM that we will explore in the
next section.
4.3 Memory Massaging with KSM
In Section 2.2, we discussed the operational semantics
of KSM. Here we detail some of its implementation fea-
tures that are important for dFFS.
3TLB or translation lookaside buffer is a general term for processor
caches for page-table entries to speed up the virtual to physical memory
translation
4.3.1
Interaction with THP
As we discussed earlier, KSM deduplicates memory
pages with the same contents as soon as it ﬁnds them.
KSM currently does not support deduplication of huge
pages, but what happens when KSM ﬁnds matching con-
tents within huge pages?
A careful study of the KSM shows that KSM al-
ways prefers reducing memory footprint over reducing
TLB entries; that is, KSM breaks down huge pages into
smaller pages if there is a small page inside with similar
contents to another page.
This speciﬁc feature is important for an efﬁcient and
reliable implementation of dFFS, but has to be treated
with care. More speciﬁcally, we can use huge pages as
we discussed in the previous section for efﬁcient and re-
liable double-sided Rowhammer, while retaining control
over which victim page we should map in the middle of
our target (vulnerable) huge page.
KSM, however, can have undesired interactions with
THP from dFFS’s point of view. If KSM ﬁnds pages in
the attacker VM’s memory that have matching contents,
it merges them with each other or with a page from a
previously started VM. In these situations, KSM breaks
THP by releasing one of its smaller pages to the sys-
tem. To avoid this, dFFS uses a technique to avoid KSM
during its templating phase. KSM takes a few tens of
seconds to mark the pages of dFFS’s VM as candidates
for deduplication. This gives dFFS enough time to allo-
cate a large buffer with the same size as VM’s available
memory (as mentioned earlier) and write unique integers
at a pre-determined location within each (small) page of
this buffer as soon as its VM boots. The entropy present
within dFFS’s pages then prohibits KSM to merge these
pages which in turn avoids breaking THP.
4.3.2 On dFFS Chaining
Initially, we planned on chaining memory massaging
primitive and FFS to induce an arbitrary number of bit
ﬂips at many desired locations of the victim’s memory
page. After using the ﬁrst template for the ﬁrst bit ﬂip,
the attacker can write to the merged memory page to trig-
ger a copy-on-write event that ultimately unmerges the
two pages (i.e., the attacker page from the victim page).
At this stage, the attacker can use dFFS again with a new
template to induce another bit ﬂip.
However, the implementation of KSM does not allow
this to happen. During the copy-on-write event, the vic-
tim’s page remains in the stable tree, even if it is the only
remaining page. This means that subsequent attempts for
memory massaging results in the victim page to control
the location of physical memory, disabling the attacker’s
ability for chaining FFS attacks.
USENIX Association  
25th USENIX Security Symposium  7
7
Even so, based on our single bit ﬂip cryptanalysis on
public keys and our evaluation in Section 5, chaining is
not necessary for performing successful end-to-end at-
tacks with dFFS.
We now describe our end-to-end attacks that put all
the pieces of dFFS together using two target applications:
OpenSSH and GPG.
4.4 Attacking Weakened RSA
For the two attacks in this paper, we generate RSA pri-
vate keys, i.e., the private exponents d(cid:31) corresponding to
corrupted moduli n(cid:31) (as described in Section 3). We use
d(cid:31) to compromise two applications: OpenSSH and GPG.
Although the speciﬁcs of the applications are very dif-
ferent, the pattern to demonstrate each attack is the same
and as follows:
1. Obtain the ﬁle containing the RSA public key (n,e).
This is application-speciﬁc, but due to the nature
of public key cryptosystems, generally unprotected.
We call this the input ﬁle.
2. Using the memory templating step of Section 2.1
we obtain a list of templates that we are able to ﬂip
within a physical page. We ﬂip bits according to the
target templates to obtain corrupted keys. For ev-
ery single bitﬂip, we save a new ﬁle. We call these
ﬁles the corrupted ﬁles. According to the templat-
ing step, dFFS has the ability to create any of these
corrupted ﬁles in the victim by ﬂipping a bit in the
page cache.
3. One by one, we now read the (corrupted) public
keys for each corrupted ﬁle.
If the corrupted ﬁle
is parsed correctly and the public key has a changed
modulus n(cid:31) (cid:30)= n and the same e, this n(cid:31) is a candidate
for factorization.
4. We start factorizations of all n(cid:31) candidates found in
the previous step. As we described in Section 3,
the best known algorithm for our scenario is ECM
that ﬁnds increasingly large factor in an iterative
fashion. We use the Sage [19] implementation of
ECM for factorizing n(cid:31). We invoke an instance of
ECM per available core for each corrupted key with
a 1 hour timeout (all available implementations of
ECM run with a single thread).
5. For all successful factorizations, we compute the
private exponent d(cid:31) corresponding to (n(cid:31),e) and
generate the corresponding private key to the cor-
rupted public key. How to compute d(cid:31) based on the
factorization of n(cid:31) is described in Section 3. We can
then use the private key with the unmodiﬁed appli-
cation. This step is application-speciﬁc and we will
discuss it for our case studies shortly.
4.5 End-to-end Attacks
Attacker model. The attacker owns a VM co-hosted
with a victim VM on a host with DIMMs susceptible
to Rowhammer. We further assume that memory dedu-
plication is turned on—as is common practice in public
cloud settings [8]. The attacker has the ability to use the
memory deduplication side-channel to ﬁngerprint low-
entropy information, such as the IP address of the victim
VM, OS/library versions, and the usernames on the sys-
tem (e.g., through /etc/passwd ﬁle in the page cache)
as shown by previous work [32, 43, 56]. The attacker’s
goal is to compromise the victim VM without relying on
any software vulnerability. We now describe how this
model applies with dFFS in two important and widely
popular applications.
4.5.1 OpenSSH
One of the most commonly used authentication mecha-
nisms allowed by the OpenSSH daemon is an RSA pub-
lic key. By adding a user’s RSA public key to the SSH
authorized_keys ﬁle, the corresponding private key
will allow login of that user without any other authentica-
tion (such as a password) in a default setting. The public
key by default includes a 2048 bit modulus n. The com-
plete key is a 372-byte long base64 encoding of (n,e).
The attacker can initiate an SSH connection to the vic-
tim with a correct victim username and an arbitrary pri-
vate key. This interaction forces OpenSSH to read the
authorized_keys ﬁle, resulting in this ﬁle’s contents
getting copied into the page cache at the right time as we
discussed in Section 4.1. Public key cryptosystems by
deﬁnition do not require public keys to be secret, there-
fore we assume an attacker can obtain a victim public
key. For instance, GitHub makes the users’ submitted
SSH public keys publicly available [27].
With the victim’s public key known and in the page
cache, we can initiate dFFS for inducing a bit ﬂip. We
cannot ﬂip just any bit in the memory page caching
the authorized_keys; some templates will break the
base64 encoding,
resulting in a corrupted ﬁle that
OpenSSH does not recognize. Some ﬂips, however, de-
code to a valid (n(cid:31),e) key that we can factorize. We re-
port in Section 5 how many templates are available on
average for a target public key.
Next, we use a script with the PyCrypto RSA cryp-
tographic library [39] to operate on the corrupted public
keys. This library is able to read and parse OpenSSH
public key ﬁles, and extract the RSA parameters (n,e).
8  25th USENIX Security Symposium 
USENIX Association
8
It can also generate RSA keys with speciﬁc parameters
and export them as OpenSSH public (n(cid:31),e) and private
(n(cid:31),d(cid:31)) keys again. All the attacker needs to do is factor-
ize n(cid:31) as we discussed in Section 4.4.
Once we know the factors of n(cid:31), we generate the pri-
vate key (n(cid:31),d(cid:31)) that can be used to login to the victim
VM using an unmodiﬁed OpenSSH client.
4.5.2 GPG
The GNU Privacy Guard, or GPG, is a sophisticated im-
plementation of, among others, the RSA cryptosystem.
It has many applications in security, one of which is the
veriﬁcation of software distributions by verifying signa-
tures using trusted public keys. This is the larger appli-
cation we intend to subvert with this attack.
Speciﬁcally, we target the apt package distribution
system employed by Debian and Ubuntu distribution for
software installation and updates. apt veriﬁes package
signatures after download using GPG and trusted pub-
lic keys stored in trusted.gpg. It fetches the package
index from sources in sources.list.
Our attack ﬁrst steers the victim to our malicious
repository.
The attacker can use dFFS to achieve
this goal by inducing a bit ﬂip in the sources.list
ﬁle that is present in the page cache after an update.
sources.list holds the URL of the repositories that
are used for package installation and update. By using
a correct template, the attacker can ﬂip a bit that results
in a URL that she controls. Now, the victim will seek
the package index and packages at an attacker-controlled
repository.
Next, we use our exploit to target the GPG trusted keys
database. As this ﬁle is part of the software distribu-
tion, the stock contents of this ﬁle is well-known and we
assume this ﬁle is unchanged or we can guess the new
changes. (Only the pages containing the keys we depend
on need be either unchanged or guessed.) This ﬁle re-
sides in the page cache every time the system tries to
update as a result of a daily cron job, so in this attack, no
direct interaction with the victim is necessary for bring-
ing the ﬁle in the page cache. Our implicit assumption is
that this ﬁle remains in the page cache for the next update
iteration.
Similar to OpenSSH, we apply bit ﬂip mutations in lo-
cations where we can induce bit ﬂips according to the
memory templating step. As a result, we obtain the cor-
rupted versions of this ﬁle, and each time check whether
GPG will still accept this ﬁle as a valid keyring and that
one of the RSA key moduli has changed as a result of
our bit ﬂip. Extracting the key data is done with the GPG
--list-keys --with-key-data options.
For every bitﬂip location corresponding to a corrupted
modulus that we can factorize, we pick one of these
mutations and generate the corresponding (n(cid:31),d(cid:31)) RSA
private key, again using PyCrypto. We export this pri-
vate key using PyCrypto as PEM formatted key and use
pem2openpgp [26] to convert this PEM private key to
the GPG format. Here we specify the usage ﬂags to in-
clude signing and the same generation timestamp as the
original public key. We can then import this private key
for use for signing using an unmodiﬁed GPG.
It is important that the Key ID in the private keyring
match with the Key ID in the trusted.gpg ﬁle. This
Key ID is not static but is based on a hash computed from
the public key data, a key generation timestamp, and sev-
eral other ﬁelds. In order for the Key ID in the private
keyring to match with the Key ID in the public keyring,
these ﬁelds have to be identical and so the setting of the
creation timestamp is signiﬁcant.
One signiﬁcant remark about the Key ID changing (as
a result of a bit ﬂip) is that this caused the self-signature
on the public keyring to be ignored by GPG! The signa-
ture contains the original Key ID, but it is now attached
to a key with a different ID due to the public key mu-
tation. As a result, GPG ignores the attached signature
as an integrity check of the bit-ﬂipped public key and the
self-signing mechanism fails to catch our bit ﬂip. The
only side-effect is harmless to our attack – GPG reports
that the trusted key is not signed. apt ignores this with-
out even showing a warning. After factorizing the cor-
rupted public key modulus, we successfully veriﬁed that
the corresponding private key can generate a signature