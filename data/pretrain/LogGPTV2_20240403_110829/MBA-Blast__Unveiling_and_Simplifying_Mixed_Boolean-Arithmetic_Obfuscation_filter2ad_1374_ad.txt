features, which are calculated and saved as the meta data M
in every sample.
• Length of variables. The dataset covers different vari-
able length, including 8 bits, 16 bits, 32 bits, and 64 bits.
Each category contains 2, 500 MBA expressions.
• Number of variables. The number of input variables
ranges from 1 to 10.
• Number of terms. Since new MBA expressions can be
generated by linear combination, the number of terms is
another feature for controlling complexity. Number of
terms in this dataset ranges from 3 to 80.
In the ﬁrst experiment, we run MBA-Blast and other peer tools
on Dataset 1, which contains all MBA expressions collected
from existing works. The simpliﬁcation result is evaluated
from two aspects, correctness and effectiveness.
Correctness means the expressions before and after sim-
pliﬁcation must be semantically equivalent. We use Z3
solver [52] to perform equivalence checking. The challenge
here is most of the MBA expressions before simpliﬁcation
are too complex for Z3 to solve. Since we have the initially
un-obfuscated expressions as the ground truth, our alternative
is to check equivalence between the simpliﬁed result and the
ground truth. Note that even a correctly simpliﬁed result may
have different syntax with its ground truth (see the example
in Table 4), so the equivalence checking step is indispensable.
The other aspect, effectiveness, reﬂects how much complex-
ity is reduced by the simpliﬁcation method, so we measure
and compare the expression complexity before and after sim-
pliﬁcation. Eyrolles [39] introduces three metrics to measure
MBA complexity: number of nodes, MBA alternation, and
average bit-vector size. Because SSPAM, Syntia, and MBA-
Blast do not change bit-vector size and Arybo always reduces
USENIX Association
30th USENIX Security Symposium    1709
Expression SubstitutionArithmeticReductionDynamic AnalyzerStaticDisassemblerSource Code EditorMBA-BlastFront-endInterfaceBack-endInterfaceParserFormula GenerationIRIRASTASTIRTraceAssembly CodeSource CodeHuman-readable FormulaSolver Input FormulaC, Java, Python, ...SMT SolverHuman ReaderTable 3: Comparative evaluation results using Dataset 1. In “# of Correctness” column, “Yes” means equivalent, “No” means not
equivalent, and “T.O.” means time out (Z3 fails to return a result in ﬁve hours), and “Ratio” indicates the ratio of outputs passing
equivalence checking. “Average # of Nodes”, “Average # of MBA Alternation”, and “Average Processing Time” report the result
on correctly simpliﬁed results. “Before” represents obfuscated MBA expressions to be simpliﬁed, and “After” represents the
simpliﬁed expressions delivered by different deobfuscation tools. “Average Processing Time” reports the average time that each
tool takes to process one MBA sample.
Method
Arybo
SSPAM
Syntia
MBA-Blast
# of Correctness
Average # of Nodes
Yes No T.O Ratio (%) Before After A/B (%) Before After
0.0
1.5
0.5
0.5
300.0
84.0
48.9
50.0
59.7
100.0
95.2
100.0
Average # of MBA Alternation Average Processing Time
(Seconds/Sample)
30.2
4.6
8.9
0.009
A/B (%)
0.0
65.2
26.1
21.7
2.1
2.3
2.3
2.3
9.1
9.4
9.4
9.4
27.3
7.9
4.6
4.7
37
62
59
62
0
0
3
0
25
0
0
0
Table 4: Correct simpliﬁcation result appears different, but it
is semantically equivalent to the ground truth.
Ground Truth Before
−3(x ∧ ¬y)
4(¬x ∧ y) − (x ⊕ y) + 3¬(x ∨
y) + ¬(x ⊕ y) − ¬y − ¬x −
(¬x ∨ y) − ¬(x ∧ y)
After
3(x ∧ y) − 3x
any length variable to 1-bit variable, so measuring bit-vector
size is trivial in this experiment. We use the rest two quantita-
tive metrics to measure MBA complexity.
1. Number of DAG nodes. An MBA expression is trans-
lated to a Directed Acyclic Graph (DAG), where the
nodes are operators, variables, and constants. The num-
ber of nodes in the DAG is a metric for describing the
expression complexity.
2. MBA Alternation. A key source of MBA complexity
comes from mixing integer arithmetic operations and
bitwise operations. We adopt “MBA alternation” to mea-
sure the number of operations that connect different
types of operations. For example, in x ∧ y + 2z, the +
represents an MBA alternation, because its left operand
is a bit-vector generated by x ∧ y, and its right operand
is an integer arithmetic 2z.
For these complexity metrics, a larger value indicates a
more complex MBA expression. We expect the metrics’ val-
ues will decrease after simpliﬁcation. Table 3 shows the eval-
uation result on Dataset 1. For this and the following exper-
iment, we set ﬁve hours as a practical timeout threshold for
Z3 solving.
Compared to the existing tools, all MBA-Blast’s outputs
pass correctness testing, and their complexity measurement
values are considerably reduced. We observe that Arybo per-
forms well on simple MBA expressions. However, when han-
dling complex expressions, Arybo’s simpliﬁcation result is
even more complex than the original expression. For over 1/3
(25 out of 62) of the samples, it generates very complex formu-
las that cannot be solved by Z3 within the time threshold. The
reason is that Arybo breaks all integers to 1-bit variables caus-
ing the result size to increase drastically. The simpliﬁcation
result from Arybo does not have MBA alternation, because
it reduces all arithmetic operators to bitwise operators. SS-
PAM successfully simpliﬁes majority of the samples as they
are included in SSPAM’s pattern matching library. The core
technique of Syntia is stochastic program synthesis, which
approximates program semantics using Monte Carlo Tree
Search (MCTS). Syntia’s simpliﬁcation largely relies on the
quality of sampling input-output pairs. When the sampling
points perfectly represent the MBA expression, it can achieve
a correct, simpliﬁed form, and its complexity reduction is on
a par with MBA-Blast. Because the samples in Dataset 1 are
not very complex, Syntia can correctly synthesize majority
of them (59/62). The last column shows MBA-Blast only in-
troduces negligible processing overhead compare to the peer
tools.
7.3 Dataset 2: Comprehensive MBA Dataset
As the second experiment, we run MBA-Blast and other base-
line tools on Dataset 2. The result in Table 5 presents an ob-
vious gap between other tools and MBA-Blast}. Only MBA-
Blast successfully generates veriﬁable simpliﬁcation results
for all MBA samples. The average processing time for each
case is less than 0.1 second, signiﬁcantly faster than existing
tools.
Because the MBA samples in Dataset 2 are diverse and
well-labeled, this experiment reveals more detailed ﬁndings.
Arybo can handle 431 MBA samples in Dataset 2, all of which
are small-size, 8-bit MBA (average number of DAG nodes is
13.4). For the rest of cases, Arybo generates size-explosion
results (over 20, 000 DAG nodes) that exceed Z3 solver’s pro-
cessing capacity. SSPAM can process more complex MBA
samples using its pattern library, and the average number of
DAG nodes is 32.1. For other MBA samples, SSPAM either
returns an incorrect result or crashes with a segmentation er-
ror. Syntia can output a simpliﬁed expression for every MBA
sample in Dataset 2, but up to 85.6% of them are not correct
result due to the imprecise “guess” in program synthesis. On
1710    30th USENIX Security Symposium
USENIX Association
Table 5: Comparative evaluation results using Dataset 2. In “# of Correctness” column, “Yes” means equivalent, “No” means not
equivalent, and “T.O.” means time out (Z3 fails to return a result in ﬁve hours), and “Ratio” indicates the ratio of outputs passing
equivalence checking. “Average # of Nodes”, “Average # of MBA Alternation”, and “Average Processing Time” report the results
on correctly simpliﬁed results. “Before” represents obfuscated MBA expressions to be simpliﬁed, and “After” represents the
simpliﬁed expressions delivered by different deobfuscation tools. “Average Processing Time” reports the average time that each
tool takes to process one MBA sample.
Method
Arybo
SSPAM
Syntia
MBA-Blast
Yes
431
2,550
1,438
10,000
No
0
0
8,562
0
9,569
7,450
0
0
# of Correctness
Average # of Nodes
T.O Ratio (%) Before After A/B (%) Before After
0.0
5.4
0.5
0.9
190.3
78.3
4.0
17.2
4.3
25.5
14.4
100.0
Average # of MBA Alternation Average Processing Time
(Seconds/Sample)
640.7
438.2
9.3
0.053
A/B (%)
0.0
63.5
1.6
2.9
3.4
8.5
6.4
30.8
13.4
32.1
26.4
113.2
25.5
25.1
4.6
19.5
The ﬁgures zoom in two complexity metrics (Number of DAG
nodes and MBA alternation) and plot the distribution. Syn-
tia’s dots are very close to MBA-Blast’s dots, indicating that
they compete with each other in terms of complexity reduc-
tion; however, MBA-Blast can correctly simplify considerably
more MBA expressions.
Moreover, Figure 6 presents Z3’s solving time when per-
forming correctness testing for different length variables in
Dataset 2. For simplicity, we only present 8-bit and 64-bit
graphs and the complete result is shown in Appendix B. The
curve density represents how many expressions are veriﬁed
as correct. The black curve represents MBA samples before
simpliﬁcation. When the length of variable increases from
8-bit to 64-bit, the density of black curve becomes sparser.
It is because when variable length growths, the searching
space becomes larger and Z3 has more difﬁculty to solve the
formula. Compared to that, the density of blue curve, repre-
senting MBA-Blast’s result, does not change and it covers
all samples in the Dataset 2. That means, considerable MBA
samples were not solvable before MBA-Blast’s simpliﬁcation,
but they can be solved very quickly after MBA-Blast’s simpli-
ﬁcation. Before simpliﬁcation, only 1, 542 MBA expressions
in Dataset 2 pass correctness testing. After MBA-Blast’s sim-
pliﬁcation, Z3 can solve 6.5X more expressions.
The trend and slope of these curves represent the change
of expression complexity before and after simpliﬁcation. For
those variables with short length, the majority of blue curve
has a small slope, which means most of the simpliﬁed result
can be solved quickly. As the length of variables increase
from 8-bit to 16-bit, more part of the curve has a large slope.
That means, due to the increasing search space, Z3 spends
more time to verify the simpliﬁcation result when the vari-
able length is large. The simpliﬁcation results from SSPAM
are more complex than MBA-Blast and Syntia’s results are
competent, but both of them fail to generate correct results
for majority of samples in the dataset.
In addition, we observe that the number of input variables
also affects Z3’s veriﬁcation time. Overall, the solving time
increases with the number of inputs. For MBA samples in-
volving more than 8 input variables, Z3 spends considerable
(a) Number of DAG Nodes.
(b) Number of MBA Alternation.
Figure 5: The distribution of two complexity metrics on
Dataset 2. We compare the MBA expression before simpliﬁ-
cation with the simpliﬁed results from SSPAM, Syntia, and
MBA-Blast. We do not plot Arybo’s results because they
increase the complexity metrics’ values.
the samples that Syntia synthesizes the correct result, its per-
formance rivals MBA-Blast, as shown in Figure 5a and 5b.
USENIX Association
30th USENIX Security Symposium    1711
0200040006000800010000MBA expressions in Dataset 2050100150200250Number of DAG NodesOriginalSSPAMSyntiaMBA-Blast0200040006000800010000MBA expressions in Dataset 2010203040506070Number of AlternationOriginalSSPAMSyntiaMBA-Blast(a) 8-bit result.
(b) 64-bit result.
Figure 6: Z3 solving time when handling different data length in Dataset 2.
time to verify it, although MBA-Blast correctly generates the
simpliﬁcation result.
x + y = x ∨ y + x ∧ y
x − y = x ∧ ¬y − ¬x ∧ y
(a) MBA obfuscation rules in Tigress.
x − y + z = (x − y) + z
= ((x − y) ∨ z) + ((x − y) ∧ z)
= ((x ∧ ¬y − ¬x ∧ y) ∨ z)+
((x ∧ ¬y − ¬x ∧ y) ∧ z)
(b) Tigress recursively generates a complex MBA expression.
((x ∧ ¬y − ¬x ∧ y) ∨ z) + ((x ∧ ¬y − ¬x ∧ y) ∧ z)
= ((x − x ∧ y − y + x ∧ y) ∨ z) + ((x − x ∧ y
− y + x ∧ y) ∧ z)
= ((x − y) ∨ z) + ((x − y) ∧ z)
= (t ∨ z) + (t ∧ z)
= (t + z − t ∧ z) + t ∧ z
(x − y → t)
= t + z
= x − y + z
(t → x − y)
(c) MBA-Blast simpliﬁcation steps.
Figure 7: Tigress’s complex MBA expression and MBA-
Blast’s simpliﬁcation.
7.4 Defeating Tigress MBA Obfuscation
We are interested in applying MBA-Blast in real-world obfus-
cation scenario to check its practicability. Tigress [41] is an
automated software obfuscation tool with MBA obfuscation
embedded. We ﬁrst randomly generate 1,000 C functions as