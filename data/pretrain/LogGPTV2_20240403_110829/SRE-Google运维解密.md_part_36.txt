Newer Older
153
6
---
## Page 196
180
154
时候在考虑过滤掉虚假报警以及漏报报警的危险性时，可能无法完全避免。
而同时触发多项报警。试图减少同一个故障造成的报警信息总数量是值得做的，但是有
样的，有时候一个更小的，仅仅影响某个单独服务的故障也可能同时满足多种错误状态
也包括运维后端服务器的人。同时网络运维中心（NOC）也会收到自己的报警信息。同
时和无法连接后端服务器，所以每个受影响的团队都会收到自己服务的报警。同时，这
某一个单独的故障，可能（经常会）触发多个报警。例如，网络问题导致所有服务都超
聚合
图16-2：Outalator针对某项故障的视图
通和Dashboard更新。这些是接入一个类似Outalator系统的好地方。
很多组织都在使用即时消息系统，比如Slack、HiPchat，甚至使用IRC进行内部沟
OUTALATOR!
第16章跟踪故障
Content:
打造你自己的Outalator
nekesaearfroanyht
cause
mpactactionsnviceoflea
deploy
new bulld to
agooglerSetingsAboutFeecibackSignout
品品
---
## Page 197
分析。举例来说，通过找到基础设施中造成故障最多的一部分，可以更好地知道如果提
数据分析的下一步是找到影响更广泛的问题，不仅仅是简单的计数，而是需要一些语义
团队的数据来判断某项报警是否“太吵了”。
通过查找“上次我们做了什么”作为起点处理本次故障。但是历史数据对分析系统性的、
SRE当然不仅仅是响应和处理故障。历史数据对响应某个故障来说也很有用。我们可以
分析
却是整个Outalator中最有用的特殊功能。
不做详细分析的情况下快速看到服务的一些问题。虽然这个功能看起来并不起眼，但它
有用（“problem-went-away”）。通过不预先提供标准列表而是允许用户自己制定标准使
当然，有时候一些标签是拼写错误造成的（如“cause:netwrrk”），同时有些标签没那么
接）。其他一些常见的标签都是单独的词语，例如“Bogus”常常被用来标记虚假报警。
“cause:network:cable”。有些团队经常使用“customer:123456”这类的标签，以标记某个
可能对某些团队来说已经足够了，其他的团队可能需要“cause:network:switch”和
和“action”等作为命名空间，但是每个团队都可以自己定义。比如“cause：network”
命名空间体制，以及一些自动化处理。Outalator使用一些建议的前缀，类似“cause”
词”。冒号（：），被认为是语义性分隔符，所以这实际上隐含提倡了一种层级结构的
标签机制，以允许对报警增加元数据信息。标签基本上没有格式要求，都是独立的“单
的报警和发错的邮件信息。Outalator本身并不区分这些信息，但是提供了一种通用的
当然，不是每个报警信息都代表一次故障。虚假报警有时候会发生，同时也有测试产生
加标签
功能能更好地消除重复报警，避免重复性工作。
个报警和其他报警一样，是同一个故障造成的”电子邮件可能能够解决问题，但是聚合
队/服务以及按时间分析趋势和模式。这一层分析允许团队使用自己的历史数据和其他
周/每月/每季度的故障数量和每次故障的报警数量。下一层分析更重要一些：对比团
底层的分析包括计数和基本的汇总统计报告。报告细节每个团队不同，但是一般包括每
是使用户可以进行这类分析。
周期性的，以及更广范围内的系统问题也很有帮助。故障跟踪工具最重要的功能之一就
得整个工具更有用，数据也更有用。总体来说，标签机制对团队来说非常有用，可以在
客户。
“这是本周的第三次报警了”怎么理解都可以
Outalator
155
<181
---
## Page 198
129
注2
另外一个例子是记录某些非幂等周期性任务的执行，比如自动利用代码库中新的版本更
是这里必须说，这里提供的功能仅仅是基础的、技术性的，而非法律意义上的审核使用）。
有些团队甚至设立了一些虚设的Escalator队列：这些队列并没有真人接受报警，但是这
团队可见，可能在问题处理过程中提供巨大帮助，至少不会帮倒忙。
Bigtable貌似还没有报警产生，那么手工创建一条报警可能是个好主意。让故障信息跨
明显的好处。用Bigtable举例来说，如果某项服务故障由明显的Bigtable故障造成，而
查速度和通过确认目前的确有某项故障以降低其他团队的压力。同时也有一些不那么
未预料到的好处
评论都内嵌在列表中展开，以提供更好的视图。
性的生产服务评审（大部分团队每周进行一次）提供帮助。在这个模式下，所有“重要的”
156
新数据库结构。
些报警仍然会出现在Outalator中，并且可以打标签、评论分析以及复审。例如，“记录
能够将某条报警，或者某系列报警跟某个其他故障链接起来有明显的好处：可以加快检
列表）。这样可以很容易地进行交接工作。Outalator同时支持一种“报告模式”，为周期
“重要的”记录信息用邮件格式发送给下一个on-call工程师（也可以CC其他人或邮件
Outalator中对一线SRE更有用的功能是可以选择一系列故障，将它们的标题、标签和
报告和公告
常稳定的假象。某些团队选择定期制造人为岩机时间，以避免用户过于依赖该服务）。
务设计的架构已经决定发生故障会耗时很久才能解决，但是经常由于运气因素而造成非
时候，我们需要人为制造一些岩机时间，以免给内部用户造成某种假象（通常指某些服
团队收集这些信息，可以从中找出系统性的问题，同时提供正确的解决方案。甚至有的
它们可能是符合设计的服务质量目标的（SLO），只是无法满足用户的期望而已。通过跨
或者“延迟过高”等。这两种报警都可能由网络阻塞问题造成数据复制延后导致。或者，
高该部分的稳定性或性能会带来多大帮助。注2当然，这需要建立在故障记录中已经提供
影响有多大。
一方面来说，
第16章跟踪故障
“造成了很多服务问题”可能是提高服务质量和降低报警数量的起始点。
造成的。
这些监控常常是由一
小撮
另一方面来说
准
---
## Page 199
通过的测试降低了分析系统可靠性变化中的不确定性。完善的测试可以提供足够的细节
测试，是一个用来证明变更前后系统的某些领域相等性的手段。
条件中之一：
后者可以用基于历史数据的预测来量化。为了让这些预测信息足够准确，必须满足下列
统可靠度和未来的系统可靠度来衡量。前者可以通过抓取和分析历史性监控信息来获得，
软件测试技术应用在分布式系统上！来做到这一点。对服务质量的自信可以用过去的系
SRE的一项关键职责就是要定量地分析我们维护的某项服务的质量。SRE采用将经典的
testing.
·在这段时间内，该系统完全没有改变。包括没有任何软件更新以及服务器数量变
样），这里不再赘述。
试的二进制文件），这两个基础设施组件可以分别作为普通的SRE支持的服务（就像集群存储系统一
测试，
性进行分析。
你可以充分描述整个系统的所有改变，这样可以针对每个系统变化引入的不确定
化，这意味着未来的行为方式应该与过去的行为方式类似。
如果你还没有亲自试过某件东西，那么就假设它是坏的。
一旦一个工程师针对某个系统制定了一个标准的、合理的
作者：AlexPerry、MaxLuebbe
测试可靠性
、注2每个在变更前后都能
编辑：DianeBates
第
这项基础架构包
17章
157
测
183
184
---
## Page 200
85
来评估一个已经部署的软件系统工作是否正常。
主要用来在开发过程中离线评估软件的正确性。生产测试在生产Web服务器上进行，用
软件测试基本分为两大类：传统测试和生产测试。传统测试在软件开发过程中很常见，
软件测试的类型
来的一节主要讲述与软件测试相关的术语在本章中的应用。
阶段中对测试重要性的认知上。有关Google内部测试的资料请参看文献[Whi12]。接]
有关测试的文章基本大同小异。分歧主要发生在不同措辞上，以及对不同软件生命周期
这些统计数据指出了需要完善和调整测试的区域。
可以用来证实新的代码执行路径的可靠程度。假设该服务的客户端是随机分布的（参见
停止引入新的改动，等待监控数据再累积一段时间。累积的监控数据和测试的覆盖数据
间内做了大量改动，那么预测的系统可靠性就会趋近于可接受的极限。这时，我们应该
对系统做出更多的改动，而不会使系统可靠度下降到可接受水平之下。如果我们在短时
动的不确定性和降低系统可靠度的可能性都降低了。足够的代码测试覆盖度可以让我们
测试的数量直接取决于所服务系统的可靠性要求。随着代码的测试覆盖度上升，每次改
信息，以帮助我们有效地预测某个系统未来的可靠度。
158
当然会包含Bug。新的Bug的发现和解决会同时导致变更发布速率的下降。
随着测试的优化，MTBF会上升，开发者就可以更快地上线新功能。有些新功能
均失败时间（MTBF）就越长。
法修复MTTR为O的Bug是很高效的。你发现的O MTTRBug越多，你服务的平
入生产环境（虽然这个Bug可能还是需要从源代码级别修复）。通过阻止发布的方
Bug。那么这项测试可以被用来阻挡这个Bug的发布，使得这个Bug根本不会进
级别的测试应用在某个子系统上，并且测试检测到了监控系统也会检测到的一个
一个测试系统可以检测出一个MTTR为O的Bug。这种情况出现在当一个系统
修复某个Bug的时间。
规则的间隔等）。平均修复时间（MTTR）是衡量运维团队通过回滚或者其他动作
一个监控系统也可以发现系统中的Bug，但是仅限于汇报机制的速度（例如报警
试通常证明了系统不可靠。
系统通过某项测试或者一系列测试并不一定能证明系统是稳定的，但是失败的测
第17章测试可靠性
测试和平均修复时间的关系
---
## Page 201
注3参见http://google.github.io/dagger/。
注入来用轻便的mock替换一个有状态的数据库，同时保持一模一样的行为特征。
替代真实逻辑的伪组件），用以方便地测试某个系统组件。
injection），利用类似Dagger准这样的工具，我们可以创建出复杂依赖的mock（测试中
一个集成测试（integration test）来检验该组件的功能的正确性。依赖注入（dependency
通过独立的单元测试的软件组件被组装成大的系统组件。工程师通过在这个组件中运行
集成测试
统对其的行为要求。单元测试经常被用来引入测试驱动开发的概念。
体系统的正确性。单元测试同时也是一种规范，用来保证某个函数或者模块完全符合系
软件单元，比如一个类，或者一个函数的正确性。这些测试不考虑包含该软件单元的整
单元测试（unit test）是最小、最简单的软件测试形式。这些测试用来评估某一个独立的
单元测试
图17-1：传统测试的层级模型