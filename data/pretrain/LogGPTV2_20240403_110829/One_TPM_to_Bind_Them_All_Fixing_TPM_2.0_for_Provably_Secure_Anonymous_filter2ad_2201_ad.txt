Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
values must be ï¬xed (e.g., Î³ always equals 1) or extractable
from some proof of knowledge for this lemma to be applicable.
Lemma 2 (Unforgeability of SPKs with a TPM). The sig-
nature proofs of knowledge generated by Prove as deï¬ned
in Fig. 1, are unforgeable w.r.t. mt. More precisely, the host
cannot forge a signature proof of knowledge with the structure
of (1) with a witness Î³ Â· (tsk + hsk ) for known Î³, hsk if the
TPM never signed mt, under the DL assumption in the random
oracle model.
Proof (sketch). We show that if an adversary A that has access
to the TPM interfaces can forge SPKâ€™s, we can derive an
adversary B that can solve the discrete logarithm problem.
Note that it is crucial that we allow the adversary A to get
full, unconstrained access to the TPM interfaces instead of
giving him only indirect access via the Prove protocol, as this
correctly models the power a corrupt host will have.
Our reduction B receives a DL instance tpk = Â¯gtsk and is
challenged to ï¬nd tsk. To do so, we simulate the TPM and
the hash function towards A based on tpk , Â¯g as follows:
Hash queries: For queries bsn i to HG1, take ri â†$ Zp and
(bsn i), ri).
i) â†$
(cid:3)
If bsn E (cid:4)= âŠ¥, compute HG1
Z2
(bsn E),
p.
look up
the record (hash, HG1 (bsn E), rE), and set E â† Â¯gs Â·
iÂ·rE . If bsn E = âŠ¥, set E â† Â¯gs Â· tpk
âˆ’c(cid:2)
âˆ’c(cid:2)
i.
tpk
If bsn L (cid:4)= âŠ¥, compute HG1
(bsn L),
look up the
rL =
record (hash, HG1
(bsn L)tsk , and L â† Â¯gs Â· tpk
iÂ·rL. If bsn L = âŠ¥, set
âˆ’c(cid:2)
HG1
K â† âŠ¥ and L â† âŠ¥.
Pick
(cid:3)
i),
(commitId , Â¯nt, si, c
output (commitId , Â¯nt, E, K, L).
return HG1
Queries to H and TPM.Hash are handled normally.
Commit query TPM.Commit(bsn E, bsn L): Take (si, c
(bsn L), rL), and set K â† tpk
(bsn i) = Â¯gri and store (hash, HG1
of H,
commitId,
store
and
Â¯nt
uniform in
the
range
increment
Sign query TPM.Sign(commitId , c, nh): Look up and re-
(cid:3)
i), and output an error
move record (commitId , Â¯nt, si, c
if no such record was found. Check that c was marked
safe-to-sign in a TPM.Hash query. Pick nt â†$ {0, 1}ln and
program the random oracle such that H(â€œnonceâ€, nt) =
Â¯nt. Program the random oracle such that H(â€œFS â€, nt âŠ•
(cid:3)
nh, c) = c
i. Since the nonce nt is fresh and gets only used
once, the probability that the random oracle is already
deï¬ned on that input is negligible. Finally, we output
(nt, si).
When A, after having interacted with these oracles, outputs
a SPK forgery, i.e., a valid proof with TPM message mt that
the TPM never agreed to sign in TPM.Hash, along with values
Î³, hsk such that the proof uses Î³ Â· (tsk + hsk ) as witness,
we either have a collision in H which occurs with negligible
probability, or we can rewind to extract Î³Â·(tsk +hsk ), allowing
us to compute tsk. B then outputs tsk, solving the DL problem.
Device Boundedness of SPKs with an Honest TPM. Finally,
we show that proofs generated via Prove are device bound,
i.e., the host cannot create more SPKs than the amount of
908
sign queries the TPM answered. Again, the TPM holds tsk
with tpk = Â¯gtsk created by TPM.Create.
Lemma 3 (Device Boundedness of SPKs with a TPM). The
signature proofs of knowledge generated by Prove as deï¬ned
in Fig. 1, are device bound. That is, the host cannot create
more signature proofs of knowledge with the structure of (1)
with a witnesses Î³ Â· (tsk + hsk ), where tsk is protected by the
TPM and the host knows Î³ and hsk, than the amount of sign
queries the TPM answered, under the DL assumption in the
random oracle model.
Proof (sketch). Our reduction receives a DL instance tpk =
Â¯gtsk and must compute tsk. The simulation works exactly as
in the proof of Lemma 2. If the host made n sign queries and
outputs n + 1 SPKs and corresponding values Î³ and hsk, we
(cid:3) value of the proofs. If there are two distinct
look at every c
(cid:3) value, there must be a collision in H,
SPKs with the same c
(cid:3) values are
which occurs with negligible probability. If all c
(cid:3) values as
distinct, one of them must be different from the c
created by the TPM. That means the random oracle is not
programmed here and we can rewind that proof to extract
Î³Â· (tsk + hsk ). Since we also have hsk and Î³ we can compute
tsk, which solves the DL problem.
4.1.2 Proofs Without TPM Contribution
To be able to prove security of our DAA schemes, we must
distinguish proofs to which the TPM contributed and proofs
that the host created by itself. One way to achieve this is by
using different preï¬xes in the Fiat-Shamir hash computation.
(cid:3) â†
Proofs with TPM contribution have a Fiat-Shamir hash c
H(â€œFS â€, n, H(â€œTPM â€, mt, mh)). Proofs without TPM con-
(cid:3) â† H(â€œFS â€, n, H(â€œNoTPM â€, mt, mh)).
tribution will use c
âˆ—
We denote TPM contributed proofs by SPK
, and proofs
without TPM contribution SPK.
5. PROVABLY SECURE DAA SCHEMES
We now show how to use the proposed TPM interfaces to
build provably secure direct anonymous attestation protocols.
We start by describing the desired functional and security
properties (Sec. 5.1) and then present two DAA protocols,
based on the q-SDH assumption and the LRSW assumption
(Sec. 5.2), and argue their security (Sec. 5.3). We refer to
Appendix A for the formal deï¬nition of DAA in the form of
an ideal functionality and to the full version of this paper for
the detailed security proof.
5.1 Deï¬nition & Security Model
In a DAA scheme, we have four main entities: a number
of TPMs, a number of hosts, an issuer, and a number of
veriï¬ers. The scheme comprises a JOIN and SIGN protocol,
and VERIFY and LINK algorithms.
JOIN: A TPM and a host together form a platform which
performs the join protocol with the issuer who decides if the
platform is allowed to become a member. The membership
credential of the platform then also certiï¬es a number of
attributes attrs = (a1, . . . , aL) given by the issuer. These
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
attributes might include more information about the platform,
such as the vendor or model, or other information, such as an
expiration date of the credential.
SIGN: Once being a member, the TPM and host together can
sign messages m with respect to basename bsn resulting in
a signature Ïƒ. If a platform signs with a fresh basename,
the signature must be anonymous and unlinkable to previous
signatures. When signing, the platform can also selectively
disclose attributes from its membership credential. For in-
stance, reveal that the signature was created by a TPM of
a certain manufacturer, or the expiration date of the creden-
tial. We describe the disclosure using a tuple (D, I) where
D âŠ† {1, . . . , L} indicates which attributes are disclosed, and
I = (a1, . . . , aL) speciï¬es the desired attribute values.
VERIFY: Any veriï¬er can check that a signature Ïƒ on message
m stems from a legitimate platform via a deterministic verify
algorithm. More precisely, veriï¬cation gets as input a tuple
(m, bsn, Ïƒ, (D, I), RL, SRL) and outputs 1 if Ïƒ is a valid
signatures on message m w.r.t. basename bsn and stems from
a platform that has a membership credential satisfying the
predicate deï¬ned via (D, I), and 0 otherwise.
The inputs RL and SRL are revocation lists and we support
two types of revocation, private-key-based revocation and
signature-based revocation. The ï¬rst is based on the exposure
of a corrupt platformâ€™s secret key (or private key) and allows
one to recognize and thus reject all signatures generated with
this key. That is, the revocation list RL contains the secret
keys of the revoked TPMs. The second type, signature-based
revocation, has been proposed by Brickell and Li [28], [29]
in their Enhanced Privacy ID (EPID) protocol. It allows one
to revoke a platform based on a previous signature from
that platform, i.e., here the revocation list SRL contains the
signatures of the revoked TPMs.
LINK: By default, signatures created by an DAA scheme do
not leak any information about the identity of the signer. Only
when the platform signs repeatedly with the same basename
bsn, it will be clear that the resulting signatures were created
by the same platform, which can be publicly tested via the
deterministic LINK algorithm. More precisely, on input two
(cid:3)), and a
signatures (Ïƒ, m, (D, I), SRL), (Ïƒ
basename bsn, the algorithm outputs 1 if both signatures are
valid and were created by the same platform, and 0 otherwise.
(cid:3)), SRL
, (D
(cid:3)
(cid:3)
, m
(cid:3)
, I
We now describe the desired security properties of DAA
schemes in an informal manner. The detailed deï¬nition in
form of an ideal functionality in the Universal Composability
framework [30] is given in Appendix A, and closely follows
the recent formal models of Camenisch et al. [9], [24].
Unforgeability. The adversary can only sign in the name of
corrupt TPMs. More precisely, if n corrupt and unrevoked
TPMs joined with attributes fulï¬lling attribute disclosure
(D, I), the adversary can create at most n unlinkable sig-
natures for the same basename bsn and attribute disclosure
(D, I). In particular, this means that when the issuer and all
909
unrevoked TPMs are honest, no adversary can create a valid
signature on a message m w.r.t. basename bsn and attribute
disclosure (D, I) when no platform that joined with those
attributes signed m w.r.t. bsn and (D, I).
Non-Frameability. No adversary can create a signature on a
message m w.r.t. basename bsn that links to a signature created
by an honest platform, when this honest platform never signed
m w.r.t. bsn. We require this property to hold even when the
issuer is corrupt.
(Strong) Privacy. An adversary that is given two signatures
two different basenames bsn 1 (cid:4)= bsn 2,
Ïƒ1 and Ïƒ2 w.r.t.
respectively, cannot distinguish whether both signatures were
created by one honest platform, or whether two different
honest platforms created the signatures. This property must
also hold when the issuer is corrupt.
So far, privacy was conditioned on the honesty of the entire
platform, i.e., both the TPM and the host have to be honest.
In fact,
the previous DAA schemes crucially rely on the
honesty of the TPM, and the newly revised TPM interfaces
even introduced a subliminal channel that allows a malicious
TPM to always encode some identifying information into his
signature contribution (see Sec. 3.1). The latter forestalls any
privacy in the presence of a corrupt TPM, even if the DAA
protocol built on top of the TPM interfaces would allow for
better privacy.
In this work we have proposed TPM interfaces that
avoid such subliminal channels and we consequently aim
for stronger privacy guarantees for DAA as well. That is,
the aforementioned indistinguishability of two signatures Ïƒ1
and Ïƒ2 must hold whenever the host is honest, regardless
of the corruption state of the TPM. Our notion of strong
privacy lies between the classical privacy notion (relying also
on the honesty of the TPM) and optimal privacy that was
recently introduced by Camenisch et al. [24]. We discuss the
differences between these notions, and to [24] in particular, in
Appendix A.
5.2 DAA Protocols
We start by presenting the high-level idea of both DAA
protocols using our revised TPM 2.0 interfaces, and then
describe the concrete instantiations based on the q-SDH and
the LRSW assumption.
Both protocols roughly follow the common structure of
previous DAA protocols: the platform, consisting of a TPM
and a host, generates a secret key gsk that gets blindly certiï¬ed
by a trusted issuer in a membership credential cred. When
attributes attrs = a1, . . . aL are used,
the credential also
certiï¬es attrs. After that join procedure, the platform can use
the key gsk to sign attestations and basenames and prove that
it has a valid credential on the underlying key, which certiï¬es
the trusted origin of the attestation. The overview of the DAA
protocol is depicted in Fig. 4.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
JOIN :
TPM
(cid:2)
HOST(ipk )
(cid:2)
ISSUER(isk , attrs = (a1, . . . , aL))
tsk â†$ Zp, tpk â† Â¯gtsk
Store tsk
TPM.Create
Request TPM key
JOIN
 n
-
n â†$ {0, 1}Ï„
tpk
-
Orchestrate generation of proof Ï€tpk by
the TPM using the Prove protocol
TPM.Commit/TPM.Sign, n
tpk
Ï€tpk â† SPK
(cid:3) â† Ëœgtsk (optional bridging to a different generator Ëœg)
âˆ—{tsk : tpk = Â¯gtsk âˆ§ tpk
(cid:3) = Ëœgtsk}(â€œjoinâ€, n)
, Ï€tpk
-
tpk
(cid:3)
Choose host key and generate gpk:
(cid:3) Â· Ëœghsk
hsk â†$ Zp, gpk â† tpk
Ï€gpk â† SPK{hsk : gpk /tpk
(cid:3) = Ëœghsk}(â€œjoinâ€, n)
tpk , tpk
(cid:3)
-
, gpk , Ï€tpk , Ï€gpk
Verify Ï€tpk , Ï€gpk , and sign gpk together
with attributes attrs = (a1, . . . , aL):
cred â† PBSign(isk , (gpk , attrs))
Verify cred w.r.t. gpk , attrs, ipk
Store (hsk , cred , attrs)
cred , attrs
SIGN : TPM(tsk ) (cid:2) HOST((hsk , cred , attrs),
(ipk , m, bsn, (D, I), RL, SRL))
â€¢ The host veriï¬es that its attributes attrs fulï¬ll the predi-
(cid:3)
L) and attrs as
(cid:3)
cate (D, I), i.e., it parses I as (a
1, . . . , a
i for every i âˆˆ D.
(cid:3)
(a1, . . . , aL) and checks that ai = a
â€¢ The host
the pseudonym
nym â† HG(1||bsn)gsk and proof Ï€cred of a membership
credential on gsk = tsk + hsk and attrs:
Ï€cred â† NIZK
âˆ—{(gsk , cred ) : nym = HG1
and TPM jointly generate
(1||bsn)gsk âˆ§
(cid:3)
, gsk , attrs)}(â€œsignâ€, (D, I), m, SRL)
the host and TPM
â€¢ For each tuple (bsn i, nymi) âˆˆ SRL,
jointly create non-revocation proofs Ï€SRL,i:
Ï€SRL,i â† SPK
âˆ—{gsk : HG1 (1||bsn i)gsk (cid:4)= nymi âˆ§
1 = PBVf(ipk , cred
â€¢ The host outputs Ïƒ â† (nym, Ï€cred ,{Ï€SRL,i}).
nym = HG1