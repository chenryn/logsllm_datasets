Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
values must be ﬁxed (e.g., γ always equals 1) or extractable
from some proof of knowledge for this lemma to be applicable.
Lemma 2 (Unforgeability of SPKs with a TPM). The sig-
nature proofs of knowledge generated by Prove as deﬁned
in Fig. 1, are unforgeable w.r.t. mt. More precisely, the host
cannot forge a signature proof of knowledge with the structure
of (1) with a witness γ · (tsk + hsk ) for known γ, hsk if the
TPM never signed mt, under the DL assumption in the random
oracle model.
Proof (sketch). We show that if an adversary A that has access
to the TPM interfaces can forge SPK’s, we can derive an
adversary B that can solve the discrete logarithm problem.
Note that it is crucial that we allow the adversary A to get
full, unconstrained access to the TPM interfaces instead of
giving him only indirect access via the Prove protocol, as this
correctly models the power a corrupt host will have.
Our reduction B receives a DL instance tpk = ¯gtsk and is
challenged to ﬁnd tsk. To do so, we simulate the TPM and
the hash function towards A based on tpk , ¯g as follows:
Hash queries: For queries bsn i to HG1, take ri ←$ Zp and
(bsn i), ri).
i) ←$
(cid:3)
If bsn E (cid:4)= ⊥, compute HG1
Z2
(bsn E),
p.
look up
the record (hash, HG1 (bsn E), rE), and set E ← ¯gs ·
i·rE . If bsn E = ⊥, set E ← ¯gs · tpk
−c(cid:2)
−c(cid:2)
i.
tpk
If bsn L (cid:4)= ⊥, compute HG1
(bsn L),
look up the
rL =
record (hash, HG1
(bsn L)tsk , and L ← ¯gs · tpk
i·rL. If bsn L = ⊥, set
−c(cid:2)
HG1
K ← ⊥ and L ← ⊥.
Pick
(cid:3)
i),
(commitId , ¯nt, si, c
output (commitId , ¯nt, E, K, L).
return HG1
Queries to H and TPM.Hash are handled normally.
Commit query TPM.Commit(bsn E, bsn L): Take (si, c
(bsn L), rL), and set K ← tpk
(bsn i) = ¯gri and store (hash, HG1
of H,
commitId,
store
and
¯nt
uniform in
the
range
increment
Sign query TPM.Sign(commitId , c, nh): Look up and re-
(cid:3)
i), and output an error
move record (commitId , ¯nt, si, c
if no such record was found. Check that c was marked
safe-to-sign in a TPM.Hash query. Pick nt ←$ {0, 1}ln and
program the random oracle such that H(“nonce”, nt) =
¯nt. Program the random oracle such that H(“FS ”, nt ⊕
(cid:3)
nh, c) = c
i. Since the nonce nt is fresh and gets only used
once, the probability that the random oracle is already
deﬁned on that input is negligible. Finally, we output
(nt, si).
When A, after having interacted with these oracles, outputs
a SPK forgery, i.e., a valid proof with TPM message mt that
the TPM never agreed to sign in TPM.Hash, along with values
γ, hsk such that the proof uses γ · (tsk + hsk ) as witness,
we either have a collision in H which occurs with negligible
probability, or we can rewind to extract γ·(tsk +hsk ), allowing
us to compute tsk. B then outputs tsk, solving the DL problem.
Device Boundedness of SPKs with an Honest TPM. Finally,
we show that proofs generated via Prove are device bound,
i.e., the host cannot create more SPKs than the amount of
908
sign queries the TPM answered. Again, the TPM holds tsk
with tpk = ¯gtsk created by TPM.Create.
Lemma 3 (Device Boundedness of SPKs with a TPM). The
signature proofs of knowledge generated by Prove as deﬁned
in Fig. 1, are device bound. That is, the host cannot create
more signature proofs of knowledge with the structure of (1)
with a witnesses γ · (tsk + hsk ), where tsk is protected by the
TPM and the host knows γ and hsk, than the amount of sign
queries the TPM answered, under the DL assumption in the
random oracle model.
Proof (sketch). Our reduction receives a DL instance tpk =
¯gtsk and must compute tsk. The simulation works exactly as
in the proof of Lemma 2. If the host made n sign queries and
outputs n + 1 SPKs and corresponding values γ and hsk, we
(cid:3) value of the proofs. If there are two distinct
look at every c
(cid:3) value, there must be a collision in H,
SPKs with the same c
(cid:3) values are
which occurs with negligible probability. If all c
(cid:3) values as
distinct, one of them must be different from the c
created by the TPM. That means the random oracle is not
programmed here and we can rewind that proof to extract
γ· (tsk + hsk ). Since we also have hsk and γ we can compute
tsk, which solves the DL problem.
4.1.2 Proofs Without TPM Contribution
To be able to prove security of our DAA schemes, we must
distinguish proofs to which the TPM contributed and proofs
that the host created by itself. One way to achieve this is by
using different preﬁxes in the Fiat-Shamir hash computation.
(cid:3) ←
Proofs with TPM contribution have a Fiat-Shamir hash c
H(“FS ”, n, H(“TPM ”, mt, mh)). Proofs without TPM con-
(cid:3) ← H(“FS ”, n, H(“NoTPM ”, mt, mh)).
tribution will use c
∗
We denote TPM contributed proofs by SPK
, and proofs
without TPM contribution SPK.
5. PROVABLY SECURE DAA SCHEMES
We now show how to use the proposed TPM interfaces to
build provably secure direct anonymous attestation protocols.
We start by describing the desired functional and security
properties (Sec. 5.1) and then present two DAA protocols,
based on the q-SDH assumption and the LRSW assumption
(Sec. 5.2), and argue their security (Sec. 5.3). We refer to
Appendix A for the formal deﬁnition of DAA in the form of
an ideal functionality and to the full version of this paper for
the detailed security proof.
5.1 Deﬁnition & Security Model
In a DAA scheme, we have four main entities: a number
of TPMs, a number of hosts, an issuer, and a number of
veriﬁers. The scheme comprises a JOIN and SIGN protocol,
and VERIFY and LINK algorithms.
JOIN: A TPM and a host together form a platform which
performs the join protocol with the issuer who decides if the
platform is allowed to become a member. The membership
credential of the platform then also certiﬁes a number of
attributes attrs = (a1, . . . , aL) given by the issuer. These
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
attributes might include more information about the platform,
such as the vendor or model, or other information, such as an
expiration date of the credential.
SIGN: Once being a member, the TPM and host together can
sign messages m with respect to basename bsn resulting in
a signature σ. If a platform signs with a fresh basename,
the signature must be anonymous and unlinkable to previous
signatures. When signing, the platform can also selectively
disclose attributes from its membership credential. For in-
stance, reveal that the signature was created by a TPM of
a certain manufacturer, or the expiration date of the creden-
tial. We describe the disclosure using a tuple (D, I) where
D ⊆ {1, . . . , L} indicates which attributes are disclosed, and
I = (a1, . . . , aL) speciﬁes the desired attribute values.
VERIFY: Any veriﬁer can check that a signature σ on message
m stems from a legitimate platform via a deterministic verify
algorithm. More precisely, veriﬁcation gets as input a tuple
(m, bsn, σ, (D, I), RL, SRL) and outputs 1 if σ is a valid
signatures on message m w.r.t. basename bsn and stems from
a platform that has a membership credential satisfying the
predicate deﬁned via (D, I), and 0 otherwise.
The inputs RL and SRL are revocation lists and we support
two types of revocation, private-key-based revocation and
signature-based revocation. The ﬁrst is based on the exposure
of a corrupt platform’s secret key (or private key) and allows
one to recognize and thus reject all signatures generated with
this key. That is, the revocation list RL contains the secret
keys of the revoked TPMs. The second type, signature-based
revocation, has been proposed by Brickell and Li [28], [29]
in their Enhanced Privacy ID (EPID) protocol. It allows one
to revoke a platform based on a previous signature from
that platform, i.e., here the revocation list SRL contains the
signatures of the revoked TPMs.
LINK: By default, signatures created by an DAA scheme do
not leak any information about the identity of the signer. Only
when the platform signs repeatedly with the same basename
bsn, it will be clear that the resulting signatures were created
by the same platform, which can be publicly tested via the
deterministic LINK algorithm. More precisely, on input two
(cid:3)), and a
signatures (σ, m, (D, I), SRL), (σ
basename bsn, the algorithm outputs 1 if both signatures are
valid and were created by the same platform, and 0 otherwise.
(cid:3)), SRL
, (D
(cid:3)
(cid:3)
, m
(cid:3)
, I
We now describe the desired security properties of DAA
schemes in an informal manner. The detailed deﬁnition in
form of an ideal functionality in the Universal Composability
framework [30] is given in Appendix A, and closely follows
the recent formal models of Camenisch et al. [9], [24].
Unforgeability. The adversary can only sign in the name of
corrupt TPMs. More precisely, if n corrupt and unrevoked
TPMs joined with attributes fulﬁlling attribute disclosure
(D, I), the adversary can create at most n unlinkable sig-
natures for the same basename bsn and attribute disclosure
(D, I). In particular, this means that when the issuer and all
909
unrevoked TPMs are honest, no adversary can create a valid
signature on a message m w.r.t. basename bsn and attribute
disclosure (D, I) when no platform that joined with those
attributes signed m w.r.t. bsn and (D, I).
Non-Frameability. No adversary can create a signature on a
message m w.r.t. basename bsn that links to a signature created
by an honest platform, when this honest platform never signed
m w.r.t. bsn. We require this property to hold even when the
issuer is corrupt.
(Strong) Privacy. An adversary that is given two signatures
two different basenames bsn 1 (cid:4)= bsn 2,
σ1 and σ2 w.r.t.
respectively, cannot distinguish whether both signatures were
created by one honest platform, or whether two different
honest platforms created the signatures. This property must
also hold when the issuer is corrupt.
So far, privacy was conditioned on the honesty of the entire
platform, i.e., both the TPM and the host have to be honest.
In fact,
the previous DAA schemes crucially rely on the
honesty of the TPM, and the newly revised TPM interfaces
even introduced a subliminal channel that allows a malicious
TPM to always encode some identifying information into his
signature contribution (see Sec. 3.1). The latter forestalls any
privacy in the presence of a corrupt TPM, even if the DAA
protocol built on top of the TPM interfaces would allow for
better privacy.
In this work we have proposed TPM interfaces that
avoid such subliminal channels and we consequently aim
for stronger privacy guarantees for DAA as well. That is,
the aforementioned indistinguishability of two signatures σ1
and σ2 must hold whenever the host is honest, regardless
of the corruption state of the TPM. Our notion of strong
privacy lies between the classical privacy notion (relying also
on the honesty of the TPM) and optimal privacy that was
recently introduced by Camenisch et al. [24]. We discuss the
differences between these notions, and to [24] in particular, in
Appendix A.
5.2 DAA Protocols
We start by presenting the high-level idea of both DAA
protocols using our revised TPM 2.0 interfaces, and then
describe the concrete instantiations based on the q-SDH and
the LRSW assumption.
Both protocols roughly follow the common structure of
previous DAA protocols: the platform, consisting of a TPM
and a host, generates a secret key gsk that gets blindly certiﬁed
by a trusted issuer in a membership credential cred. When
attributes attrs = a1, . . . aL are used,
the credential also
certiﬁes attrs. After that join procedure, the platform can use
the key gsk to sign attestations and basenames and prove that
it has a valid credential on the underlying key, which certiﬁes
the trusted origin of the attestation. The overview of the DAA
protocol is depicted in Fig. 4.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:27:02 UTC from IEEE Xplore.  Restrictions apply. 
JOIN :
TPM
(cid:2)
HOST(ipk )
(cid:2)
ISSUER(isk , attrs = (a1, . . . , aL))
tsk ←$ Zp, tpk ← ¯gtsk
Store tsk
TPM.Create
Request TPM key
JOIN
 n
-
n ←$ {0, 1}τ
tpk
-
Orchestrate generation of proof πtpk by
the TPM using the Prove protocol
TPM.Commit/TPM.Sign, n
tpk
πtpk ← SPK
(cid:3) ← ˜gtsk (optional bridging to a different generator ˜g)
∗{tsk : tpk = ¯gtsk ∧ tpk
(cid:3) = ˜gtsk}(“join”, n)
, πtpk
-
tpk
(cid:3)
Choose host key and generate gpk:
(cid:3) · ˜ghsk
hsk ←$ Zp, gpk ← tpk
πgpk ← SPK{hsk : gpk /tpk
(cid:3) = ˜ghsk}(“join”, n)
tpk , tpk
(cid:3)
-
, gpk , πtpk , πgpk
Verify πtpk , πgpk , and sign gpk together
with attributes attrs = (a1, . . . , aL):
cred ← PBSign(isk , (gpk , attrs))
Verify cred w.r.t. gpk , attrs, ipk
Store (hsk , cred , attrs)
cred , attrs
SIGN : TPM(tsk ) (cid:2) HOST((hsk , cred , attrs),
(ipk , m, bsn, (D, I), RL, SRL))
• The host veriﬁes that its attributes attrs fulﬁll the predi-
(cid:3)
L) and attrs as
(cid:3)
cate (D, I), i.e., it parses I as (a
1, . . . , a
i for every i ∈ D.
(cid:3)
(a1, . . . , aL) and checks that ai = a
• The host
the pseudonym
nym ← HG(1||bsn)gsk and proof πcred of a membership
credential on gsk = tsk + hsk and attrs:
πcred ← NIZK
∗{(gsk , cred ) : nym = HG1
and TPM jointly generate
(1||bsn)gsk ∧
(cid:3)
, gsk , attrs)}(“sign”, (D, I), m, SRL)
the host and TPM
• For each tuple (bsn i, nymi) ∈ SRL,
jointly create non-revocation proofs πSRL,i:
πSRL,i ← SPK
∗{gsk : HG1 (1||bsn i)gsk (cid:4)= nymi ∧
1 = PBVf(ipk , cred
• The host outputs σ ← (nym, πcred ,{πSRL,i}).
nym = HG1