blame. This honest node, say ğ‘ğ‘– has all the shares for every honest
node that does not have a share. Therefore, all honest nodes together
have ğ‘¡ + 1 shares, which guarantees reconstruction to the unique
secret ğ‘  that was committed except with negl(ğœ…) probability. If no
ack certificate is formed, then all the honest nodes, agree on âŠ¥, thus
satisfying the Commitment requirement with high probability of
1 âˆ’ negl(ğœ…), where the probability is over forging digital signatures
and the adversary generating incorrect witnesses.
â–¡
Lemma B.17.
If an honest node sends an ack for a sharing block
ğ‘†ğµ in epoch ğ‘’, then (i) all honest nodes receive the sharing block ğ‘†ğµ
in epoch ğ‘’, (ii) all honest nodes receive their respective secret shares
corresponding to sharing block ğ‘†ğµ within Î” time of entering epoch
ğ‘’ + 1.
Proof. Suppose an honest node ğ‘ğ‘– sends an ack for sharing
block ğ‘†ğµ := âŸ¨Commitment, VSS. (cid:174)ğ¶, ğ‘’, ğ‘§ğ‘ ğ‘’âŸ©ğ¿ğ‘’ at time ğœ in epoch ğ‘’.
19
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3520Node ğ‘ğ‘– must have received up to ğ‘¡ blame messages. This im-
plies at least one honest node ğ‘ ğ‘— received a valid share VSS.sğ‘–
and sharing block ğ‘†ğµ within 3Î” time in epoch ğ‘’ and invoked
Deliver(Commitment, ğ‘†ğµ, ğ‘§ğ‘ ğ‘’, ğ‘’). Let ğœâ€² be the time when node ğ‘ ğ‘—
invoked Deliver(Commitment, ğ‘†ğµ, ğ‘§ğ‘ ğ‘’, ğ‘’). The earliest node ğ‘ğ‘– sends
an ack for ğ‘†ğµ is when it waits until epoch-timerğ‘’ â‰¥ 5Î” (i.e., 6Î”
in epoch ğ‘’) and does not detect any equivocation by ğ¿ğ‘’ or any
blame messages. Due to Î” delay between honest nodes entering
into epoch ğ‘’, this time corresponds to ğœâ€² + 2Î” in the worst case.
This implies no honest node received an epoch ğ‘’ equivocation by
time ğœâ€² + Î”. By Fact B.1, all honest nodes receives the sharing block
ğ‘†ğµ. This proves part (i) of the Lemma.
For part (ii), node ğ‘ğ‘– can send ack on two occasions: (a) when it
does not detect any equivocation or blame until its epoch-timerğ‘’ â‰¥
5Î”, and (b) when leader ğ¿ğ‘’+1 sent valid secret shares for every
blame message it forwarded and does not detect any equivocation
by time ğœ.
In case (a), node ğ‘ğ‘– did not detect any equivocation or blame
messages until its epoch-timerğ‘’ > 5Î” at time ğœ. Observe that all
honest nodes must have received valid shares corresponding to the
sharing block ğ‘†ğµ within 3Î” time in epoch ğ‘’; otherwise node ğ‘ğ‘– must
have received blame message by time ğœ (since honest nodes may
enter epoch ğ‘’ with Î” time difference and send blame message if no
valid secret shares received within 3Î” time in epoch ğ‘’). In addition,
no honest node received an equivocating sharing block ğ‘†ğµâ€² within
3Î” time in epoch ğ‘’; otherwise, node ğ‘ğ‘– must have received a share
for ğ‘†ğµâ€² (via Deliver) by time ğœ. Thus, all honest nodes receive their
respective secret shares corresponding to sharing block ğ‘†ğµ in epoch
ğ‘’ (i.e., within Î” time of entering epoch ğ‘’ + 1).
In case (b), node ğ‘ğ‘– receives valid secret shares from leader ğ¿ğ‘’+1
for every blame (up to ğ‘¡ blame) messages it forwarded and detected
no equivocation by time ğœ. Observe that node ğ‘ğ‘– received ğ‘“ â‰¤ ğ‘¡
blame messages and received valid shares for every blame message
it forwarded. This implies at least ğ‘› âˆ’ ğ‘¡ âˆ’ ğ‘“ honest nodes have
received valid shares for sharing block ğ‘†ğµ from leader ğ¿ğ‘’+1 within
3Î” in epoch ğ‘’; otherwise, node ğ‘ğ‘– would have received more than
ğ‘“ blame message by the time its epoch-timerğ‘’ = 5Î”. Since, node
ğ‘ğ‘– forwards ğ‘“ received secret shares corresponding to ğ‘“ received
blame message in epoch ğ‘’ and honest nodes enter epoch ğ‘’ + 1
within Î” time, all honest nodes receive their respective secret shares
corresponding to sharing block ğ‘†ğµ within Î” time of entering epoch
ğ‘’ + 1.
â–¡
Theorem B.18 (Consistent Beacon). For any epoch ğ‘’, all honest
nodes reconstruct the same randomness ğ‘…ğ‘’ and output the same beacon
Oğ‘’.
Proof. Honest nodes output the same randomness ğ‘…ğ‘’ and out-
put the same beacon Oğ‘’ in epoch ğ‘’ if all honest nodes receive
ğ‘¡ + 1 valid homomorphic shares for the same set of secrets. This
condition is satisfied if all honest nodes (i) have consistent Q(ğ‘ğ‘–),
âˆ€ğ‘ğ‘– âˆˆ P and consistent Pğ‘Ÿ in each epoch, (ii) {Dequeue(Q(ğ‘ğ‘–)) â‰ 
âŠ¥,âˆ€ğ‘ğ‘– âˆˆ P \ Pğ‘Ÿ} in each epoch, and (iii) share valid homomorphic
shares corresponding to dequeued secret shares.
For part(i), we show all honest nodes have consistent Q(ğ‘ğ‘–),
âˆ€ğ‘ğ‘– âˆˆ P and consistent Pğ‘Ÿ in every epoch.
20
We prove part (i) by induction on epochs. Consider the base
case for epochs 1 to ğ‘¡. During setup phase, each node is assigned
ğ‘š = ğ‘›+ğ‘¡ tuples (with each tuple containing secret shares, witnesses
and commitments) for each Q(ğ‘ğ‘–), âˆ€ğ‘ğ‘– âˆˆ P (i.e., ğ‘š âˆ— ğ‘› secrets in
total). Since, removing a Byzantine node requires ğ‘¡ + 1 epochs, all
honest nodes have Pğ‘Ÿ = âˆ… for epochs 1 to ğ‘¡. In addition, no honest
node update Q(ğ‘ğ‘–) during epochs 1 to ğ‘¡. Thus, for epochs 1 to ğ‘¡, all
honest nodes have consistent Q(ğ‘ğ‘–), âˆ€ğ‘ğ‘– âˆˆ P and Pğ‘Ÿ .
We assume part(i) holds until epoch ğ‘’ âˆ’ 1.
Consider an epoch ğ‘’ > ğ‘¡. In epoch ğ‘’, all honest nodes up-
date only Q(ğ¿ğ‘’âˆ’ğ‘¡). If ğ¿ğ‘’âˆ’ğ‘¡ proposed a valid block ğµğ‘™ (with ğ‘ğ‘™ =
(ğ»(ğ‘†ğµ), ack-cert(ğ‘†ğµ)) for some commitment ğ‘†ğµ and ğµğ‘™ is commit-
ted by epoch ğ‘’, all honest nodes update Q(ğ¿ğ‘’âˆ’ğ‘¡) with ğ‘› tuples
containing secret shares, witnesses and commitments in ğ‘†ğµ (by
Lemma B.17, all honest nodes receive commitments and secret
shares in ğ‘†ğµ before epoch ğ‘’). Otherwise, all honest nodes update
Pğ‘Ÿ to exclude ğ¿ğ‘’âˆ’ğ‘¡ i.e., Pğ‘Ÿ â† Pğ‘Ÿ âˆª {ğ¿ğ‘’âˆ’ğ‘¡}. Thus, all honest nodes
should have consistent Q(ğ¿ğ‘’âˆ’ğ‘¡) by epoch ğ‘’. Since honest nodes
do not update Q(ğ‘ğ‘– â‰  ğ¿ğ‘’âˆ’ğ‘¡) and do not add ğ‘ğ‘– into Pğ‘Ÿ in epoch ğ‘’,
by induction hypothesis, all honest nodes should have consistent
Q(ğ‘ğ‘–) âˆ€ğ‘ğ‘– âˆˆ P and consistent Pğ‘Ÿ in epoch ğ‘’. This proves part(i).
Since, all honest nodes have a consistent Q(ğ‘ğ‘–) âˆ€ğ‘ğ‘– âˆˆ P and consis-
tent Pğ‘Ÿ , all honest nodes perform {Dequeue(Q(ğ‘ğ‘–))âˆ€ğ‘ğ‘– âˆˆ P \ Pğ‘Ÿ}
for common secrets.
Next, we show {Dequeue(Q(ğ‘ğ‘–)) â‰  âŠ¥âˆ€ğ‘ğ‘– âˆˆ P \ Pğ‘Ÿ} in epoch ğ‘’.
Suppose for the sake of contradiction, Dequeue(Q(ğ‘ğ‘–)) = âŠ¥ and
ğ‘ğ‘– âˆ‰ Pğ‘Ÿ in epoch ğ‘’. Observe that, honest nodes update Q(ğ‘ğ‘–) or
include ğ‘ğ‘– in Pğ‘Ÿ ğ‘¡ + 1 epochs after node ğ‘ğ‘– becomes an epoch
leader. Let ğ‘’â€² be the last epoch in which node ğ‘ğ‘– last proposed with
ğ‘’â€² â‰¤ ğ‘’ âˆ’ ğ‘¡. However, if node ğ‘ğ‘– did not propose in ğ‘’â€², all honest
nodes would have removed ğ‘ğ‘– by epoch ğ‘’â€² + ğ‘¡ â‰¤ ğ‘’ and ğ‘ğ‘– âˆˆ Pğ‘Ÿ in
epoch ğ‘’. A contradiction.
Finally, we show all honest nodes send valid homomorphic shares
for the dequeued secret shares. Observe that honest nodes only
dequeue secret shares corresponding to a committed block that
contains a valid ack certificate. By Lemma B.17 part(ii), all honest
nodes receive valid secret shares before honest nodes update their
queues. Thus, all nodes will dequeue common secret shares and
will receive at least ğ‘¡ + 1 valid homomorphic shares for a common
secrets and reconstruct the same randomness ğ‘…ğ‘’ and output the
same beacon Oğ‘’.
â–¡
Lemma B.19 (Liveness).
If the leader ğ¿ğ‘’ of an epoch ğ‘’ is honest,
then (i) an ack certificate for its sharing block ğ‘†ğµ will form in epoch
ğ‘’ âˆ’ 1, and (ii) all honest nodes commit (ğ»(ğ‘†ğµ), ACğ‘’(ğ‘†ğµ)) in epoch
ğ‘’.
Proof. Consider an honest leader ğ¿ğ‘’ for an epoch ğ‘’. Let ğœ be the
time when leader ğ¿ğ‘’ enters epoch ğ‘’ âˆ’ 1. Leader ğ¿ğ‘’ waits for Î” time
after entering epoch ğ‘’ âˆ’ 1 and must have sent valid shares VSS.sğ‘–
and sharing block ğ‘†ğµ containing commitments to node ğ‘ğ‘– âˆ€ğ‘ğ‘– âˆˆ P
at time ğœ + Î”.
Since honest nodes enter epoch ğ‘’ âˆ’ 1 within Î” time, all honest
nodes must have entered epoch ğ‘’ âˆ’ 1 by time ğœ + Î”. Leader ğ¿ğ‘’ could
have entered epoch ğ‘’âˆ’1 Î” time before some honest nodes or Leader
ğ¿ğ‘’ could have entered epoch ğ‘’ âˆ’ 1 Î” time after some honest nodes.
In any case, all honest nodes must have received valid secret shares
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3521and sharing block ğ‘†ğµ within 3Î” after entering epoch ğ‘’ âˆ’1. Thus, no
honest nodes send blame in epoch ğ‘’ âˆ’ 1 and will receive no blame
messages from honest nodes within 6Î” time in epoch ğ‘’ âˆ’ 1 (i.e.,
until epoch-timerğ‘’âˆ’1 > 5Î”).
Consider an honest node ğ‘ğ‘–. If node ğ‘ğ‘– receives no blame mes-
sages from Byzantine nodes, it will send an ack for sharing block ğ‘†ğµ
to ğ¿ğ‘’. On the other hand, if node ğ‘ğ‘– receives up to ğ‘¡ blame messages
from Byzantine nodes, it forwards blame messages to ğ¿ğ‘’. Honest
Leader ğ¿ğ‘’ sends the shares corresponding to the blame messages to
node ğ‘ğ‘– which node ğ‘ğ‘– receives within 8Î” in epoch ğ‘’ âˆ’ 1. Moreover,
there is no equivocation from leader ğ¿ğ‘’. Thus, node ğ‘ğ‘– sends an ack
for sharing block ğ‘†ğµ to ğ¿ğ‘’.
Thus, all honest nodes send ack for sharing block ğ‘†ğµ and leader
ğ¿ğ‘’ receives ğ‘¡ + 1 ack message for sharing block ğ‘†ğµ within 10Î” (ğ¿ğ‘’
may start epoch ğ‘’ âˆ’ 1 Î” time before node ğ‘ğ‘–) in epoch ğ‘’ âˆ’ 1. This
proves part (i) of the Lemma.
Since leader ğ¿ğ‘’ proposes a valid proposal (ğ»(ğ‘†ğµ), ACğ‘’(ğ‘†ğµ)) in
epoch ğ‘’, part(ii) follows immediately from Fact B.6.
â–¡
Lemma B.20 (Guaranteed Beacon Output). For any epoch ğ‘’ â‰¥ 1,
all the honest nodes output a new beacon output Oğ‘’.
Proof. Due to the round-robin leader selection, the honest nodes
propose in at least ğ‘› âˆ’ ğ‘¡ epochs out of ğ‘› epochs. By Lemma B.19, all
honest nodes commit ğ‘› new secret shares in every honest epoch and
updates their queues after ğ‘¡ + 1 epochs. Thus, Dequeue(Q(ğ‘ğ‘–)) â‰ 
âŠ¥âˆ€ğ‘ğ‘– âˆˆ P \ Pğ‘Ÿ . where ğ‘ğ‘– is an honest node. From the proof of
Theorem B.18, all honest nodes have consistent queues and Pğ‘Ÿ in
each epoch. At the end of each epoch, all honest nodes dequeue
common secret shares and send homomorphic sums to all other
nodes. Thus, honest nodes will have ğ‘¡ + 1 valid homomorphic sums
and will output new beacon outputs in every epochs.
â–¡
Lemma B.21 (Communication Complexity). Let ğ‘“ â‰¤ ğ‘¡ be the
number of actual Byzantine faults, ğœ… be the size of accumulator and
ğ‘¤ be the size of witness. The amortized communication complexity of
the protocol is ğ‘‚(ğœ… ğ‘“ ğ‘›2 + (ğœ… + ğ‘¤)ğ‘›2) bits per epoch.
Proof. In the Block validation protocol, distributing ğ‘‚(ğœ…ğ‘›)-
sized commitment costs ğ‘‚(ğœ…ğ‘›2) bits in communication. Sending
corresponding ğ‘‚(ğœ…ğ‘›)-sized secret shares and ğ‘‚(ğ‘¤ğ‘›)-sized witness
incur ğ‘‚((ğœ… + ğ‘¤)ğ‘›2) communication. Up to ğ‘“ Byzantine nodes can
always blame even if the epoch leader is honest. Thus, an epoch
leader needs to send ğ‘‚(ğœ… ğ‘“ ğ‘›)-sized secret shares while privately
opening the secret shares. The nodes also forward privately opened
secret secrets to nodes that blamed. This step costs ğ‘‚(ğœ… ğ‘“ ğ‘›2) com-
munication in an honest epoch. When the leader is Byzantine, it
can create a scenario when up to ğ‘¡ nodes send blame and hence,
this step has ğ‘‚(ğœ…ğ‘¡ğ‘›2) cost. Out of ğ‘› consecutive epochs, there can
be at most ğ‘“ Byzantine epochs and ğ‘› âˆ’ ğ‘“ honest epochs. Hence,
this step has amortized complexity of ğ‘‚(ğœ… ğ‘“ ğ‘›2).
By Lemma B.8, the SMR protocol has a cost of ğ‘‚((ğœ… + ğ‘¤)ğ‘›2) bits
for input of size ğ‘‚(ğœ…ğ‘›). The homomorphic sum of secret shares is
ğœ… and homomorphic sum of witness is ğ‘¤. Thus, all-to-all broadcast
of homomorphic sums incurs ğ‘‚((ğœ… + ğ‘¤)ğ‘›2). Thus, the amortized
communication complexity is ğ‘‚(ğœ… ğ‘“ ğ‘›2 + (ğœ… + ğ‘¤)ğ‘›2) bits per epoch.
â–¡
21
Theorem B.22 (Secure VSS). Assuming a secure VSS scheme VSS,
the BRandPiper protocol is a secure verifiable secret sharing protocol
with the dealer as the leader of an epoch, and the rest of the nodes as
the verifiers.
Formally, we prove the security of VSS by proving the individual
Proof Sketch. The view of an adversary A in BRandPiper is
the same as the view of an adversary running one instance of iVSS
assuming a bulletin board. Therefore, an adversary that can break
the secrecy property in BRandPiper protocol can also break the
secrecy in iVSS, which in turn can break the secrecy property from
VSS (Theorem B.16). The commitment property has an additional
failure probability arising from the case where the adversary can
forge ğ‘¡ + 1 signatures which occurs with negl(ğœ…) probability.
properties:
Secrecy: For an honest leader ğ¿ğ‘’ of epoch ğ‘’, no honest node will
blame, and therefore an adversary A will only learn the ğ‘¡ shares
of its own corruption, and not learn any new share by blaming.
Therefore the probability of A of violating the secrecy property
is negl(ğœ…) from the underlying VSS scheme, since the views are
identical to that of iVSS.
Correctness: For an honest leader ğ¿ğ‘’ of epoch ğ‘’, from Lemma B.19,
all the honest nodes commit the ğ‘†ğµ with shares for the secret.
During the reconstruction for the beacon, every honest node ğ‘ğ‘– âˆˆ P
use the same share for ğ‘†ğ‘‰ğ¿ğ‘’,ğ‘– with a high probability of 1 âˆ’ negl(ğœ…).
A Byzantine node ğ‘ ğ‘— âˆˆ P cannot provide a valid witness VSS.ğœ‹ğ¿ğ‘’,ğ‘—
for an incorrect share with probability better than negl(ğœ…), thereby
ensuring that the correctness property is maintained.
Commitment: If an honest node commits a valid block ğ‘†ğµ from a