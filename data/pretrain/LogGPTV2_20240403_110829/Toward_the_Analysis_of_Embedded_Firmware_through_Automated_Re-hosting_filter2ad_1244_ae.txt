of Honeywell International Inc., for the U.S. Department of
Energy’s National Nuclear Security Administration under
contract DE-NA0003525.
This material is based upon work supported by the National
Science Foundation under Award No. CNS-1704253, and
by the Ofﬁce of Naval Research under Award # N00014-
17-1-2011. Any opinions, ﬁndings, and conclusions or
recommendations expressed in this publication are those of
the author(s) and do not necessarily reﬂect the views of the
National Science Foundation or the Ofﬁce of Naval Research.
Additionally, this work was in part funded by a research
contract with Siemens AG.
References
[1] A. Beckus, “Qemu with an stm32 microcontroller imple-
mentation,” 2012, http://beckus.github.io/qemu_stm32/.
146          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association[2] F. Bellard, “Qemu, a fast and portable dynamic
translator.” in USENIX Annual Technical Conference,
FREENIX Track, vol. 41, 2005, p. 46.
[13] L. Ionescu, “Gnu mcu eclipse. a family of eclipse cdt
extensions and tools for gnu arm & risc-v development,”
2015, https://gnu-mcu-eclipse.github.io/.
[3] D. D. Chen, M. Egele, M. Woo, and D. Brumley,
“Towards automated dynamic analysis for linux-based
embedded ﬁrmware,” in ISOC Network and Distributed
System Security Symposium (NDSS), 2016.
[4] V. Chipounov, V. Kuznetsov, and G. Candea, “S2e: A
platform for in-vivo multi-path analysis of software
systems,” Acm Sigplan Notices, vol. 46, no. 3, pp.
265–278, 2011.
[5] Comsecuris,
“Luaqemu,”
comsecuris/luaqemu.
https://github.com/
[6] J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili,
S. Hao, C. Kruegel, and G. Vigna, “Difuze: Interface
aware fuzzing for kernel drivers,” in Proceedings of the
2017 ACM SIGSAC Conference on Computer and Com-
munications Security, ser. CCS ’17. New York, NY,
USA: ACM, 2017, pp. 2123–2138. [Online]. Available:
http://doi.acm.org/10.1145/3133956.3134069
[7] N. Corteggiani, G. Camurati, and A. Francillon,
“Inception: System-wide security testing of real-world
embedded systems software,” in 27th USENIX Security
Symposium (USENIX Security 18). Baltimore, MD:
USENIX Association, 2018.
[Online]. Available:
https://www.usenix.org/conference/usenixsecurity18/
presentation/corteggiani
[8] A. Costin, A. Zarras, and A. Francillon, “Automated
dynamic ﬁrmware analysis at scale: a case study on
embedded web interfaces,” in Proceedings of the
11th ACM on Asia Conference on Computer and
Communications Security. ACM, 2016, pp. 437–448.
[9] D. Davidson, B. Moench, T. Ristenpart, and S. Jha,
“Fie on ﬁrmware: Finding vulnerabilities in embedded
systems using symbolic execution.” in USENIX Security,
2013, pp. 463–478.
[10] B. Dolan-Gavitt, J. Hodosh, P. Hulin, T. Leek, and
R. Whelan, “Repeatable reverse engineering with
panda,” in Proceedings of the 5th Program Protection
and Reverse Engineering Workshop. ACM, 2015, p. 4.
[11] M. Ester, H.-P. Kriegel, J. Sander, X. Xu et al., “A
density-based algorithm for discovering clusters in
large spatial databases with noise.” in Conference on
Knowledge Discovery and Data Mining, 1996.
[12] G. Hernandez, F. Fowze, D. J. Tian, T. Yavuz, and K. R.
Butler, “Firmusb: Vetting usb device ﬁrmware using
domain informed symbolic execution,” in Proceedings
of the 2017 ACM SIGSAC Conference on Computer and
Communications Security. ACM, 2017, pp. 2245–2262.
[14] M. Kammerstetter, D. Burian, and W. Kastner, “Embed-
ded security testing with peripheral device caching and
runtime program state approximation,” in 10th Inter-
national Conference on Emerging Security Information,
Systems and Technologies (SECUWARE), 2016.
[15] M. Kammerstetter, C. Platzer, and W. Kastner,
“Prospect: peripheral proxying supported embedded
code testing,” in Proceedings of the 9th ACM symposium
on Information, computer and communications security.
ACM, 2014, pp. 329–340.
[16] K. Koscher, T. Kohno, and D. Molnar, “Surrogates:
Enabling near-real-time dynamic analyses of embedded
systems.” in WOOT, 2015.
[17] P. S. Magnusson, M. Christensson, J. Eskilson, D. Fors-
gren, G. Hallberg, J. Hogberg, F. Larsson, A. Moestedt,
and B. Werner, “Simics: A full system simulation
platform,” Computer, vol. 35, no. 2, pp. 50–58, 2002.
[18] Maxim Integrated, “MAX32600MBED ARM mbed
Enabled Development Platform for MAX32600,”
2018, https://www.maximintegrated.com/en/products/
microcontrollers/MAX32600MBED.html.
[19] M. Muench, D. Nisi, A. Francillon, and D. Balzarotti,
“Avatar2: A Multi-target Orchestration Platform,” in
Workshop on Binary Analysis Research (colocated with
NDSS Symposium), ser. BAR 18, February 2018.
[20] M. Muench, J. Stijohann, F. Kargl, A. Francillon, and
D. Balzarotti, “What You Corrupt Is Not What You
Crash: Challenges in Fuzzing Embedded Devices,”
in Network and Distributed System Security (NDSS)
Symposium, ser. NDSS 18, February 2018.
[21] Osbourne, Paul, “Cmsis-svd repository and parsers,”
https://github.com/posborne/cmsis-svd.
[22] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and
G. Vigna, “Firmalice-automatic detection of authen-
tication bypass vulnerabilities in binary ﬁrmware.” in
NDSS, 2015.
[23] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens,
M. Polino, A. Dutcher, J. Grosen, S. Feng, C. Hauser,
C. Kruegel, and G. Vigna, “SoK: (State of) The Art
of War: Offensive Techniques in Binary Analysis,” in
IEEE Symposium on Security and Privacy, 2016.
[24] STMicroelectronics, “STM32F072RB,” 2018, https:
//www.st.com/en/microcontrollers/stm32f072rb.html.
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 147[25] R. Toulson and T. Wilmshurst, Fast and effective
embedded systems design: applying the ARM mbed.
Newnes, 2016.
[26] J. Zaddach, L. Bruno, A. Francillon, and D. Balzarotti,
“Avatar: A framework to support dynamic security anal-
ysis of embedded systems’ ﬁrmwares.” in NDSS, 2014.
[27] M.
Zalewski., “American
http://lcamtuf.coredump.cx/aﬂ/technical_details.txt.
fuzzy
lop,”
2017,
Appendices
A Recording Rationale
While we describe our means of recording in Section 3.1, our
approach may seem overly complicated. In the following, we
point out the rationale behind the design decisions for the
recording subcomponent of PRETENDER.
Recording MMIO. The natural ﬁrst step in building models
of hardware is recording a trace of the IO activity that
occurred during execution. As we outline in Section 2, the
ﬁrmware depends on both internal “on-chip” peripherals, and
external “off-chip” peripherals, both of which are needed for
the ﬁrmware to operate as expected. However, the ﬁrmware
only communicates with off-chip peripherals through its
interactions with on-chip peripherals, so in order to have a
complete recording, we must capture all memory accesses
that constitute MMIO.
Peripherals are considered “memory-mapped” because
they are attached to, and addressed via, one of the CPU’s
internal memory buses. Unlike external buses, which can
be physically probed and monitored, these interactions only
occur within the CPU’s die, and cannot be directly monitored.
While some debugging facilities used in the development of
new chips offer a data trace of the memory bus, such as ARM’s
ETM/HTM Data Trace, these features are seldom available on
production chips, and are entirely absent in the low-cost, low-
pin-count chips of commercial embedded devices. Typical
CPUs found in the wild include, at best, a debugger capable
of simple execution control, and memory/register access.
On top of this, MMIO behaves differently from a normal
region of memory; instead of just storing data, these locations
instead control or represent aspects of on-chip peripherals.
Their value or function may change based on external factors,
without any interaction with the ﬁrmware.
One possible alternative approach to MMIO recording
would be to instrument the ﬁrmware to record IO interactions.
This requires us to understand, from the binary ﬁrmware
itself, where this IO takes place. This could be done on
architectures where explicit in and out instructions are used
for peripherals. On ARM, however, this is not a straight-
forward operation, as peripherals are accessed via normal
memory handling instructions (LDR/STR), and it is often
difﬁcult to tell statically whether an instruction is addressing
a peripheral or normal memory. Inserting this instrumentation
code non-destructively, and collecting the cumbersome
volumes of data it generates, are both hard problems, and
may even be impossible if the code is present on a Read-Only
Memory (ROM). As a result of these complications, our
approach involves virtually extending the internal memory
bus of the device, by emulating the ﬁrmware, and forwarding
and recording only the hardware-related accesses to the
original physical device (as detailed in Section 3).
Recording Interrupts. Interrupts play an important role in
most peripherals, and are a particularly difﬁcult aspect to
record and model correctly. Interrupts are triggered by some
event, whether it is an explicit MMIO operation, or an event
in the physical world, and cause the execution of Interrupt Ser-
vice Routines (ISRs) as a result. These ISRs typically contain
MMIO operations associated with the peripheral that triggered
the interrupt (e.g., reading data that arrives at a serial port or
counting the number of times a counter overﬂows). Without
the peripherals’ ISRs executing at the correct times, the periph-
erals may not function, or the system may crash. This behavior
is a property of the hardware itself; the internal logic of the pe-
ripheral decides when and how often to trigger its associated
interrupts. Many peripherals allow this behavior to be adjusted
at runtime, through their conﬁguration registers. For example,
many peripherals have a single bit in their conﬁguration reg-
ister controlling whether interrupt events are generated at all.
Hardware features exist on many chips for providing a
log of the interrupts, such as ARM’s Instrumentation Trace
Macrocell (ITM), but these features are not universal, and
are difﬁcult to coordinate with simultaneous peripheral
recording or even basic hardware-in-the-loop emulation.
Hence, previous solutions, such as the ﬁrst version of the
Avatar framework [26] or SURROGATES [16] tried to tackle
interrupt forwarding with custom stubs injected onto the
device under analysis. However, both of these solutions
forward interrupts in a “ﬁre-and-forget” manner. This results
in inconsistencies between hardware and emulated ﬁrmware,
as incoming interrupts on the hardware could easily be missed
when the emulator serves a previous interrupt. Although those
inconsistencies are a negligible problem for manual analysis,
they dramatically complicate automated modeling, and must
be avoided. A more recent approach, presented by Corteggiani
et al. [7], uses a custom tailored protocol to keep hardware
and emulator synchronized during interrupt forwarding. Un-
fortunately, this method requires custom debugging hardware
that would greatly reduce the generality of PRETENDER.
Hence, we heavily extended avatar2 to support the notion
of forwarding and recording interrupts, while carefully
keeping the two systems synchronized without the need of spe-
cialized debugging hardware. The current published version
of avatar2 retains the hardware in a “debug-halt” state while
forwarding memory accesses, in order to avoid side-effects
from the resident code. Unfortunately, this debug-halt state
148          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Associationinhibits all interrupts, and thus cannot be used as-is. However,
we cannot simply keep the CPU running and forward all of the
generated interrupts into the emulator; if too many un-handled
interrupts arrive, or spurious, unwanted interrupts occur, the
hardware or emulator can experience an unrecoverable fault.
The current version of avatar2 also does not support writing
to memory while the CPU is running. To make matters worse,
halting the CPU during interrupt routines is problematic,
as we noticed that some peripherals, particularly those that
control future interrupts, will not work properly in this
halted state because they are bound to the CPU’s instruction
pipeline. As a ﬁnal complication, we must ensure that we
return from these interrupts properly, both in the emulator
and on the hardware to ensure that the hardware continues
to function, even though it is not executing any code.
B State Approximation Details
Our state approximation model is used when a MMIO
location does not ﬁt any other model. According to our obser-
vations, these tend to be the locations in a peripheral directly
affected by external events, such as the data register of a
serial port, a bus controller, or a status and event ﬂag register.
These locations are the most challenging to model and em-
ulate. For example, in the case of an I2C bus controller, there
are many sources of state, and numerous causes for the state
to change, many of which are not observable. From the soft-
ware’s perspective, the I2C bus controller presents an MMIO
interface, which speciﬁes how the bus protocol is spoken
(baud rate, master/slave), whether queuing is enabled or in-
terrupt are ﬁred, and so on. At another layer, the hardware be-
tween the MMIO and the pins has a state, containing the data
queue, bus-related timers, and other condition ﬂags not visible
directly through MMIO. Both of these portions also occur in
the device on the other side of the bus. Finally, the two devices
share a protocol spoken on the I2C bus itself, which speciﬁes
an ordering of events (start symbol, address, data with ac-
knowledgment, etc.). The result of this is a series of composed,
inter-related state machines, which also rely somewhat on the
physical world’s events, and can only be observed through
the rather limited window of MMIO memory accesses.
Unfortunately, this means that we fail the requirements of
state machine recovery techniques, which are typically used
to infer states and transitions from an activity trace. We do not
know the number of possible states, we cannot tell when two
states are equivalent, and it is challenging to know concretely
if we have even changed the state of the peripheral. We also
cannot easily distinguish data registers, which may contain
data respecting some protocol, from others containing status
ﬂags, error codes, and conﬁguration data. However, it is
also not sufﬁcient to simply replay values verbatim from the
recorded trace. This is because our models need to be able to
function even when we observe deviation from the recording
caused by new input, timing-related deviations caused by
differences between the hardware and emulator, as well as to
tolerate the asynchronous and non-deterministic occurrence
of interrupts. In avoiding these limitations, we created the
State Approximation algorithm we describe in Section 3.
State Approximation Example. As an example, consider a
hypothetical device that uses a serial port to act as a client
for the thermostat we model in Section 4. This device’s
ﬁrmware will query the thermostat, with ‘t’ and ‘h’, and
expect a properly formatted temperature or humidity in return.
Furthermore, the ﬁrmware reacts to this data, for instance
by sending the information across a network, or raising an
alarm. The device ﬁrmware must receive a response from the
thermostat when expected, and the response must make sense
for the given command, for the ﬁrmware to behave correctly.
An illustration of what this model might look like can be
seen in Figure B.1. Note that, in a real-world scenario, there
will be many peripherals needed to operate the ﬁrmware,
but here we focus on just one to better explain its behavior.
The client device’s serial controller contains many registers,
including a conﬁguration register, a status register, a data reg-
ister, as well as assorted registers governing physical hardware
details, like baud rate. Each of these is addressed by its own
MMIO location, in a contiguous memory region we identiﬁed
during clustering. We notice, from our traces and previous
Memory Model Training, that the conﬁguration register is
a simple storage location, and the baud rate control register
is only ever written to. The contents of the status register
follow a pattern, alternating between the values 0x1 and 0x3,
which we will interpret as whether data is ready to receive or
not. The data register, on the other hand, will change without
respecting any pattern or direct stimulation from the ﬁrmware.
Therefore, this location is handled by State Approximation.
When emulation begins, we start in the peripheral’s initial
state; during boot-up, the ﬁrmware conﬁgures the serial port,
writing to the conﬁguration register to enable the serial port,
and set the baud rate to 9600, advancing the peripheral’s
state pointer to the point at which these actions occurred.
The ﬁrmware then begins its main loop, and requests a
temperature, by writing a ‘t’ into the data register. Naturally,
the next thing that happens chronologically is for the status
register to indicate that bytes are ready to read, and the
ﬁrmware will read a temperature value out of the data register
one byte at a time (e.g., “24.24C”). Similar actions occur if an
‘h’ is written to the data register by the ﬁrmware; the status
register indicates new data, and the ﬁrmware reads it back
(e.g., “50.35%”). However, when emulating with new input,
interrupts, or after the duration of the original peripheral’s
chronologically observed states, we must make a decision
about what state the peripheral is in. In these cases, following
the simple rules in Section 3, we will enter the state where
a ‘t’ or an ‘h’ was written to the data register, and subsequent
reads will return a temperature or a humidity. In this simple
example, the serial port will, after some time, return only the
last valid temperature and humidity values, but it will continue
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 149Figure B.1: Illustration of State Approximation in action, on a simpliﬁed serial port peripheral
to return only temperatures or humidities when asked for, and
respect whatever formatting or encoding for these responses
the thermostat uses, which may be checked by the ﬁrmware.
0x0 (CONFIG): Storage0x4 (BAUD): Write-only0x8 (STATUS): Pattern Model0xC (DATA): State Approx.......Serial Port MMIO LayoutRecorded MMIO TraceREAD0x00x4000WRITE0x00x4040WRITE0x49600READ0x80x1READ0x80x3WRITE0xC0x74 (‘t’)READ0x80x1READ0x80x3READ0xC0x32 (‘2’).........READ0x80x3READ0xC0x43 (‘C’)READ0x80x1WRITE0xC0x68 (‘h’)READ0x80x3 READ0xC0x35 (‘5’).........READ0x80x3READ0xC0x35 (‘%’).........Response: “2.24C”Response: “50.35%”Action       Address  ValueWRITE 0x0 0x4040Example State TransitionsREAD 0x8READ 0xCWRITE 0xC 0x74READ 0xCCommand: ‘t’Command: ‘h’150          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Association