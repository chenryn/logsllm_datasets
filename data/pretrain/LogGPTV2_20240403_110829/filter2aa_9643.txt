### Race Condition概述
条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现 bug。这个术语最初来自于两个电信号互相竞争来影响输出结果。
条件竞争主要出现在如下领域
- 电子系统，尤其是逻辑电路
- 计算机，尤其是多线程程序和分布式程序。
由于目前的系统中大量采用并发编程，经常对资源进行共享，往往会产生条件竞争漏洞。
这里我们主要考虑计算机程序方面的条件竞争。当一个软件的运行结果依赖于进程或者线程的顺序时，就可能会出现条件竞争。简单考虑一下，可以知道条件竞争需要如下的**条件**：
- 并发，即至少存在两个并发执行流。这里的执行流包括线程，进程，任务等级别的执行流。
- 共享对象，即多个并发流会访问同一对象。**常见的共享对象有共享内存，文件系统，信号。一般来说，这些共享对象是用来使得多个程序执行流相互交流。**此外，我们称访问共享对象的代码为**临界区**。在正常写代码时，这部分应该加锁。
- 改变对象，即至少有一个控制流会改变竞争对象的状态。因为如果程序只是对对象进行读操作，那么并不会产生条件竞争。
由于在并发时，执行流的不确定性很大，条件竞争相对**难察觉**，并且在**复现和调试方面会比较困难**。这给修复条件竞争也带来了不小的困难。
条件竞争造成的影响也是多样的，轻则程序异常执行，重则程序崩溃。如果条件竞争漏洞被攻击者利用的话，很有可能会使得攻击者获得相应系统的特权。
这里举一个简单的例子。
```c
#include 
#include 
int counter;
void *IncreaseCounter(void *args) {
  counter += 1;
  sleep(0.1);
  printf("Thread %d has counter value %d\n", (unsigned int)pthread_self(),
         counter);
}
int main() {
  pthread_t p[10];
  for (int i = 0; i  out.gz &
# 给管道传输数据
cat file > my_pipe
```
### 死锁概述
当同步原语使用的不恰当的时候，进程就可能会出现死锁。当两个或两个以上的执行流互相阻塞导致都不能继续执行，死锁就会发生。其实，死锁主要是因为在冲突的执行流中，出现了循环等待的执行流，即循环等待中的每一个执行流都获得一个资源，同时试图获得下一个资源。下图所示，P1、P2 两个进程都需要资源才能继续运行。P1 拥有资源 R2、还需要额外资源 R1 才能运行；P2 拥有资源 R1、还需要额外资源 R2 才能运行，两边都在互相等待而没有任何一个可运行。
一般来说，死锁有以下四个必要条件
- 互斥，资源是互斥的。
- 持有和等待，持有已有的资源，同时等待使用下一个资源。
- 不可抢占，进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。
- 循环等待，循环等待资源。
而如果想要消除死锁，也就是打破上面的四个必要条件。
此外，死锁可能来源于以下的原因
- 处理器速度
- 进程或者线程调度算法的变动
- 在执行的过程中，不同内存的限制。
- 任何能够中断程序执行的异步事件。
#### 影响
死锁一般情况下会造成拒绝服务攻击。
### 死锁静态检测
目前已知的静态检测工具有
-   [Flawfinder](http://www.dwheeler.com/flawfinder/)
    -   目标：C/C++源码
    -   步骤
        -   建立漏洞数据库
        -   进行简单的文本模式匹配，没有任何的数据流或控制流分析
-   [ThreadSanitizer](https://github.com/google/sanitizers)
    -   目标：C++和GO
    -   实现：LLVM
### 死锁动态检测
参考如下：
- [Intel Inspector](https://en.wikipedia.org/wiki/Intel_Inspector)
- [Valgrind](https://en.wikipedia.org/wiki/Valgrind)