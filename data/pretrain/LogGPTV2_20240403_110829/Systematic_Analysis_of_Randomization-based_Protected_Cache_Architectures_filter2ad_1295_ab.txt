1
1
1
2-4
nw
R
slice + bits
HashRP / RM
LLBC
LLBC
QARMA [1]
with a per-process key, SCATTERCACHE via additional input
to the mapping, and CEASER-S mentions it without implemen-
tation details. Traditional unprotected caches, CEASER, and
TSC all have one single partition. In SCATTERCACHE, P = nw
(the maximum), whereas CEASER-S recommends 2≤ P ≤ 4.
The rekeying condition T can use, e.g., the wall-clock time,
the number of accesses to the cache, or more complex policies.
3) Software Simulator: We implement our model as a C++
randomized LLC simulator, which we parametrize and use to
obtain all experimental results in this work. For simulation
purposes, many well-analyzed cryptographic primitives can be
used for RK. We use AES because of its hardware support.
B. Attacker Models
We now systematically cover the attack surface of random-
ized caches and deﬁne relevant attacker models in such caches.
Leveraging a provable security methodology from cryptog-
raphy, we propose to analyze the randomized mapping R ( 4 )
separately from how it is used. On the one hand, we consider
black-box attacks, which assume that R behaves ideally. In this
case, processes cannot efﬁciently recover K, ﬁnd inputs to RK
that produce output collisions, or infer any information about
cache set indices in one partition based on observations in
another. On the other hand, we also consider shortcut attacks
that exploit R directly. Physical side-channel attacks on R (e.g.,
using power consumption) are out of scope for this work but
can be addressed orthogonally with established approaches [7].
We further assume full attacker control over input address
a ( 1 ) as the mapping R should dissolve any attacker control
regardless of the input. The key K ( 2 ) is considered full
entropy (e.g., generated by a TRNG). If security domains ( 3 )
are supported, we assume that an attacker cannot obtain the
same identiﬁer s as the victim. The attacker cannot observe the
output of R ( 5 ) directly, but only gather metadata about it by
measuring cache contention. Finally, the attacker cannot modify
the rekeying condition ( 7 ) (e.g., it is enforced in hardware).
In line with Figure 1, we consider the following three attacks:
Aideal
In an ideal black-box attack, the mapping R is consid-
ered to behave ideally, and the system is completely noise-free.
The victim performs only a single memory access, exactly the
one the attacker wants to observe later (cf. Sections V and VI).
Anonid
In a non-ideal black-box attack, Aideal is extended
with aggravating system assumptions, and serves to study the
increase in attack complexity with respect to Aideal, e.g., noise
and multiple victim accesses (cf. Section VII).
Ashort
In a shortcut attack, internals of the mapping R are
exploited to ﬁnd eviction sets much faster than in the black-box
case, i.e., a shortcut is found (cf. Section VIII).
Existing analyses [39], [53] study attacker Aideal, as it
describes the transfer of security properties from the mapping
Fig. 3: Generalized eviction sets are based on partial congruence
(nw = 6, P = 3, b = log2 8 = 3)
RK to the cache architecture (cf. Figure 1). It allows selecting
a conservative rekeying condition for a speciﬁc design. Besides
its general applicability, it also covers some practical settings.
For instance, trusted execution environments like Intel SGX
are subject to precise control over victim execution [31], i.e.,
precisely stepping to a single instruction (e.g., a memory access)
and even repeating it an arbitrary number of times [48], [43].
IV. EXPLOITING CONTENTION ON RANDOMIZED CACHES
This section introduces generalized eviction to overcome
the challenges introduced by randomized caches. Next, it
generalizes traditional attacker objectives to randomized caches.
A. Generalizing Eviction
1) Full congruence: In an eviction set for a traditional cache,
every address ai in this set is fully congruent with x. Hence,
if x is currently cached, each ai has the potential to evict it.
In a randomized cache, an attacker can theoretically still
ﬁnd a set of addresses that collide with the target address x
in every partition. However, the probability for a randomly
selected address to be fully congruent with x is 2−bP , i.e., it
plummets exponentially with P . Already for P ≥ 2, relying on
full congruence to construct eviction sets is highly impractical.
2) Partial congruence: To overcome the full congruence
problem, one can also try to evict a target address x based
on partial congruence. This approach, introduced by Werner
et al. [53] for special case P = nw, constructs an eviction set
using addresses congruent with the target in one partition only.
To understand eviction with partial congruence in general,
consider Figure 3, where the attacker wants to evict a target x
in a toy randomized cache with 6 ways (nw = 6), 8 sets (b = 3)
and 3 partitions (P = 3). Assume the attacker has found sets of
addresses G1, G2, G3, satisfying that all elements in Gi are
congruent with x in partition i but not in the other partitions.
Eviction based on partial congruence is probabilistic. If
x is allocated to partition i, it could be evicted by Gi. An
element in Gi can only contribute to evicting x when it is
also assigned to partition i; this assignment is truly random
(i.e., not pseudorandom). In what follows, we let a generalized
eviction set G for a target address x denote the superset of
i=1 Gi.
addresses that collide with x in one partition: G =(cid:83)P
TABLE II: Generalized eviction set size for several instances.
RP
RAND
LRU
pe
[%]
50
90
95
50
90
95
nw = 4
P = 2
P = 4
P = 2
nw = 8
P = 4
P = 8
P = 2
nw = 16
P = 4
P = 16
6
18
22
6
14
16
12
36
44
12
36
44
12
36
46
14
24
26
24
72
92
28
60
72
48
144
184
48
144
184
22
72
94
30
42
46
44
144
188
60
100
116
176
576
752
176
576
752
3) Eviction probability: Given a target x to evict, we now
derive the eviction probability pe as a function of the size |G|
of the generalized eviction set G. We assume that G contains
|G|
an equal share for every partition, i.e., |Gi| =
P , (1 ≤ i ≤ P ).
This assumption holds probabilistically in practice, and we will
show how it can be met deterministically in Section VI-B.
For replacement policy RAND,
the eviction probability
generalizes the expression by Werner et al. [53]. Regardless
of the partition in which x resides, |G|
P addresses in G could
evict it, each with probability n−1
(cid:18)
w . Consequently, we have:
(cid:19) |G|
pe,RAND (|G|) = 1 −
1 − 1
nw
P
For LRU, evicting x requires the attacker to evict the full set
in the partition in which x currently resides. This corresponds
to the event that at least nw
P addresses for the
designated partition are actually mapped to this partition. It is
described by the complement of the cumulative binomial with
|G|
p
P out of the |G|
P −1 successes and success probability 1
P :
(cid:19) |G|
pe,LRU (|G|) = 1 − binom
(cid:18)|G|
(cid:16) |G|
trials, nw
,
nw
P
(cid:17)(cid:18) 1
1
P
(cid:18)
−1(cid:88)
nw
P
(cid:19)
−i
P
= 1 −
Conversely, selecting the eviction probability pe ﬁxes |G|,
presented in Table II for different cache conﬁgurations and pe.
i=0
−1,
(cid:19)i ·
P
P
P
i
1 − 1
P
B. Generalizing Attacker Objectives
We now generalize eviction set objectives from traditional
to randomized caches and evaluate their utility.
A targeted eviction set for an address x is a set of addresses
that, when accessed, evicts x from the cache with high
probability. The complexity and utility of this objective depends
on the capability of the attacker to access the target address x.
The attacker can access x if it is an in-process address
or resides in memory shared between attacker and victim. By
accessing x directly, the attacker can measure its access latency.
This objective is useful even in randomized caches, e.g., for
EVICT+RELOAD side- and covert channels or to trigger direct
DRAM accesses for eviction-based Rowhammer [2], [10].
In the other case, the attacker does not learn the access
latency of x, and victim accesses to x are needed for construct-
ing eviction sets. It is the primary attack vector for randomized
caches, as it represents the general scenario where x is not
accessible by the attacker (unshared memory), or accessible to
the attacker but decoupled in the cache for different security
domains. In addition to the previous objectives, generalized
eviction sets in this setting are useful, e.g., for PRIME+PROBE
side- and covert channels, or to extend transient execution
windows by evicting branch condition values from the cache.
An arbitrary eviction set (normally the easiest to con-
struct [49]) is a set of memory addresses that, when accessed,
has a high probability that at least one of its elements is
evicted from the cache. Although this objective has proven to
be useful in traditional caches, e.g., for covert channels [30], its
generalization to randomized caches with P > 1 and security
domains does not seem to map to any known adversarial goals.
Takeaway: Generalize eviction to avoid full congruence.
Rely on partially congruent addresses to efﬁciently (but
probabilistically) measure contention in randomized caches.
V. CONSTRUCTING GENERALIZED EVICTION SETS
The generalized eviction set G is the primitive at hand for
attacking randomized caches. Once G has been constructed,
contention-based attacks like PRIME+PROBE are also possible
in randomized caches, although with a larger set and lower
success probability (cf. Section IV-A). The major hurdle is the
proﬁling attack stage, i.e., constructing G itself. Purnal and
Verbauwhede [37] performed an initial study of this problem.
This section is concerned with the construction of G for a
target address x, using the capabilities of the black-box attack
Aideal (cf. Section III-B). We focus on the general case of a
target x that is not attacker-accessible (cf. Section IV-B), as the
security domain separator s lifts most attack objectives from
the accessible to the non-accessible case. We will later show the
optimizations that can be applied should they be accessible. Our
novel proﬁling approach is generically applicable and efﬁcient,
improving state-of-the-art methods by orders of magnitude.
Conventionally, eviction sets are constructed by reducing
a large set of addresses to a smaller set while maintaining a
high eviction rate. This traditional top-down approach is highly
effective for P = 1, but both the size of its initial set and its
reduction step are strongly hindered by partitioning the cache
(P > 1). We cope with the sheer infeasibility of reducing the
initial set by adopting a new bottom-up approach: The attacker
starts from an empty set and incrementally adds addresses for
which cache contention with the target address was observed.
When measuring contention with a target x that is not
attacker-accessible, the only available procedure is to prepare
the cache state, wait for victim execution, and observe changes
in the cache state. Finding a generalized eviction set G then
comprises several iterations of this procedure. A successful
iteration is one that catches an access to x, and the success
probability of an iteration is the catching probability pc.
Takeaway: Adopt a bottom-up strategy to construct G.
In partitioned randomized caches, detecting contention is
much more efﬁcient than detecting absence of contention.
A. Generic Prime+Prune+Probe
To maximize the probability of catching a victim access to x
in a given iteration, we develop a specialized PRIME+PROBE,
tailored for ﬁnding eviction sets in randomized caches.
TABLE III: Catching probability pc as a function of cache and attack
instance, and whether the target address is cached or not.
RP
RAND
LRU
pc,n (not cached)
k(cid:48)
N
≈ 1−binom(k, nw
P −1,
1
P·2b )
Catching probability
pc,c (cached)
(cid:1) i2·k(cid:48)i·(N−k(cid:48))nw−i
(cid:0)nw
nw(cid:80)
w·N nw
n2
≈ pc,n · pc,n(P−1)+1