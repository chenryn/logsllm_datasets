title:From Trash to Treasure: Timing-Sensitive Garbage Collection
author:Mathias V. Pedersen and
Aslan Askarov
2017 IEEE Symposium on Security and Privacy
From trash to treasure: timing-sensitive garbage
collection
Mathias V. Pedersen
Aslan Askarov
Department of Computer Science
Aarhus University
{mvp,aslan}@cs.au.dk
Abstract—This paper studies information ﬂows via timing
channels in the presence of automatic memory management. We
construct a series of example attacks that illustrate that garbage
collectors form a shared resource that can be used to reliably
leak sensitive information at a rate of up to 1 byte/sec on a
contemporary general-purpose computer. The created channel is
also observable across a network connection in a datacenter-like
setting. We subsequently present a design of automatic memory
management that is provably resilient against such attacks.
I. INTRODUCTION
When a computer system allows third-party code to access
sensitive information, it is necessary to ensure conﬁdentiality
of the sensitive information handled by the code. Language-
based information ﬂow control is a popular approach to solve
this problem [33]. This approach uses programming language
techniques to analyze information ﬂows in the untrusted
programs before and/or during the execution in a way that
prevents potentially insecure code. The advantage of this
approach is that it is allows ﬁne-grained control, compared
to coarse-grained systems approaches. The disadvantage is
that source-code analysis is limited to ﬂows that only have
control graph representation, and that allows malicious code
to still leak sensitive data using runtime side-channels such as
CPU caches [28], schedulers [43], or programming-languages
features such as lazy evaluation [8].
This paper studies another important aspect of program
runtime – automatic memory management. We show that
memory management represents a vulnerable shared resource
through which an attacker can launder sensitive information.
We present a series of simple attacks on modern runtimes, in
particular Java sequential and parallel garbage collections and
V8 default garbage collector, that illustrate the potential of
the attack.
Attack model. We consider a threat model where an
attacker-provided program operates on conﬁdential information.
The attacker observes the public input and output of the
program, but does not observe either the secret input or the
output. Furthermore, the attacker code is subjected to a number
of syntactic and runtime checks that prevent it from directly
leaking the secret input.
We assume that the attacker program consists of secret-
dependent (high) and secret-independent (low) computations.
High computations can access sensitive data, but cannot
directly communicate with the attacker. Low computations
The low computation can do its timing observations using
a number of ways. Our initial set of attacks uses the system
clock. However, access to the local clock is not essential. Local
time measurements can be substituted by external ones if the
low computation has network access and can send dummy
messages.
We further demonstrate that
the observed channel can
be ampliﬁed to leak arbitrary amount of information. Our
experiments achieve the rate of nearly 1 byte/sec on a modern
general-purpose laptop.
may communicate with the attacker or affect the public output,
but their execution cannot immediately depend on secrets.
Figure 1 illustrates the high-level idea behind the attacks. The
attacks are designed so that the high computation inﬂuences the
amount of allocated and reclaimable memory, which in its turn,
inﬂuences the timing of allocations in the low computations,
via the garbage collector. If there is no free space at the time
of an allocation in the low computation, invocation of the
garbage collector introduces observable delays. This delay is
observed by two timing observations, before and after the the
allocation in the low computation. The attacks do not rely on
measuring the timing of the high computations – these in fact
are considered to be secret-independent.
The attacks may not be surprising in hindsight, but their
consequences are important. Automatic memory management
is crucial in the implementation of modern object-oriented
or functional programming languages. For strong-information
security, a secure runtime is a must. Existing prototypes rely
on source-to-source compilation [26, 34] or language-based
monitoring [16, 35], yet they reuse commodity runtimes that are
vulnerable to the types of attacks we describe here. We note that
while there have been remarks in the literature about the danger
of memory management in information ﬂow settings [29], we
are not aware of previously published attacks or proposals that
focus on the timing channels through memory management.
To address the problem of leaks via garbage collection, we
study a model of a programming language that uses abstract
secure runtime and security types to enforce security. Our
programming language includes a command for obtaining the
current time, which allows us to cover a wide range of attacker
models, because internal timing differences in a program can
be converted into publicly observable output. Note the formal
semantics of the language is designed so that it isolates leaks via
garbage collection from other timing channels by using a non-
© 2017, Mathias V. Pedersen. Under license to IEEE.
DOI 10.1109/SP.2017.64
693
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:19:35 UTC from IEEE Xplore.  Restrictions apply. 
e
m
i
r
o
v
a
h
e
b
i
t
t
n
e
d
n
e
p
e
d
n
i
-
t
e
r
c
e
s
e
m
i
r
o
v
a
h
e
b
i
t
t
n
e
d
n
e
p
e
d
-
C
G
secret-dependent 
heap operations
timing observation 1
secret-independent 
heap operation
timing observation 2
i
r
o
v
a
h
e
b
i
t
t
n
e
d
n
e
p
e
d
n
i
-
t
e
r
c
e
s
e
m
i
r
o
v
a
h
e
b
i
t
t
n
e
d
n
e
p
e
d
-
C
G
secret-dependent 
heap operations
timing observation 1
secret-independent 
heap operation
timing observation 2
GC
GC
Fig. 1: Attack scenario – high computations are marked in
gray; low computations are marked in white; both low and high
computations share the memory management component (GC).
Heap manipulation by the high process affects the state of the
GC in a way that is later observable by the low computation.
standard prmitive at (cid:2) with bound e do c. This primitive pads
the execution time of command c by the value of expression e.
We observe that garbage collection creates a bi-directional
information ﬂow channel. Securing garbage collection requires
that high allocations cannot be collected in low computations
and vice versa. We prove that the combination of these runtime
restrictions with standard information ﬂow type system is
sufﬁcient to close leaks via memory management.
In summary, the contributions of this paper are the following:
1) We develop the ﬁrst ampliﬁable covert channel via
automatic memory management. We show that the channel
can be observed locally and over a network.
2) We observe that garbage collection creates a bi-directional
information channel, which severely restricts the design
space of securing automatic memory management. We
present formal requirements that secure garbage collectors
must satisfy.
3) We demonstrate that a secure garbage collector can be
incorporated with traditional information ﬂow analysis to
provably establish a noninterference property.
The rest of the paper is structured as follows. Section II
provides a background on timing channels and garbage
collection. Section III explains our attacks and their results.
Sections IV–V develop a formal language model for a small
imperative language with allocatable arrays and garbage
collection. Section VI designs a type system necessary for
secure coordination with the runtime. Section VII studies
the resulting security guarantees. Section VIII discusses the
applicability of real-time garbage collectors in the light of the
discovered attacks. Sections IX and X discuss the related work
and conclude.
The proofs of the formal statements and the experimental
artifacts can be found in the supplementary technical docu-
secret bit = 1
secret bit = 0
ment 1.
e
m
II. BACKGROUND
Programming languages that focus on information ﬂow
security statically reject programs that contain information
ﬂow violations, such as explicit and implicit ﬂows. A common
approach is to add security labels to types, corresponding to
the conﬁdentiality of the information stored in a variable of the
given type. A natural consequence of security labels on types
is the notion of a program counter label pc that determines the
security context of the execution.
However, many such approaches ignore other potential
sources of information leakage. A particularly dangerous source
of information leaks is time.
Timing dependencies in programs may be direct or indi-
rect [45].
skip
}
else {
if (h > 0) {
/* long computation */
An example of a direct
timing dependency is the
program on the left, where
the decision to take one
branch or the other depends
on a conﬁdential guard h.
While direct timing attacks
are difﬁcult to close, they
have control-ﬂow representation, and thus are amenable to
language-based mitigation [1, 45].
}
Indirect timing channel attacks are caused by interaction
with the runtime system of the programming language, or the
hardware upon which the program is running on. As such,
they are much harder to close, because that requires careful
interaction between the programming languages technology
and the underlying runtime, often including the OS and the
CPUs.
The focus of this paper is on indirect timing channel created
by one aspect of language runtime system, speciﬁcally the
automatic memory management.
We start with a brief overview of basic garbage collection
concepts.
A. Garbage collection techniques
A garbage collector discovers which parts of the heap contain
objects that will deﬁnitely not be accessed in the future, and
then reclaims the memory occupied by these objects, allowing
that memory to be reused.
Objects stored in the heap can point to other objects, and
the heap objects thus form a directed graph. The root nodes
of this object graph are the variables in the program, which
provides “entry points” into the graph.
Determining whether an object will be accessed in the future
is an undecidable problem [22], and thus garbage collection
schemes conservatively approximate this property by assuming
that every object reachable from the root nodes of the object
graph will be accessed in the future.
The two garbage collection strategies attacked in this paper
are mark-and-sweep collectors, and copy collectors.
1http://users-cs.au.dk/askarov/gc-timing/
694
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:19:35 UTC from IEEE Xplore.  Restrictions apply. 
a) Mark-and-sweep: A mark-and-sweep garbage collector
operates in two phases: A marking phase, where all reachable
objects are marked as “live”, and a sweep phase, where
unmarked objects in the heap are reclaimed. Note that the
cost of a mark-and-sweep collection is the sum of the cost
of marking, and the cost of sweeping. The cost of marking
is linear in the size of the reachable objects, and the cost of
sweeping is linear in the size of the entire heap.
One way to avoid having the cost be linear in the size of
the entire heap is to use a copy collecting algorithm.
b) Copy collection: A copy collecting garbage collector
partitions the heap in two partitions of equal size. These
partitions are called from-space and to-space. An invariant
of this algorithm is that at any point during the execution of
the program, only the from-space is modiﬁed.
When the from-space partition is ﬁlled, the collector builds
a copy of the object graph in the to-space partition. This is
known as the evacuation phase. Afterwards all of the memory
in the from-space is reclaimed, and the to-space becomes the
new from-space, and vice versa.
c) Generational collection: Efﬁcient garbage collectors
avoid traversing the entire object graph by assuming the weak