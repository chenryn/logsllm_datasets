Because of this structure some ﬁelds are duplicated, once for each
certiﬁcate in the MSC. However, we can decrease this overhead by
compressing the certiﬁcates during transmission.
Our results show that PoliCert introduces a small overhead in
logs, around 9 ms per proof request (the most common request
sent to logs). This means that even on standard hardware the log
can handle about 111 proof requests per second. However, we ex-
pect that servers will only infrequently query logs (e.g., every few
hours), since log proofs can be stored and reused for some time.
Notice that in interactions between the client browser and the do-
main, the overhead is 3.3 ms on average, which is short enough to
be unnoticeable by users [29].
8. POSSIBLE ENHANCEMENTS
We now present an overview of a possible security enhancement
to PoliCert which combines our architecture with another proposal
called ARPKI [4].
In ARPKI, a domain interacts with the PKI,
Figure 6: Overview of architecture of PoliCert in combination
with ARPKI.
As in PoliCert, the ﬁrst step for a domain is is policy creation
and registration. We introduce new SCP’s parameter AUDITOR_LIST,
which deﬁnes at least n − 1 auditors trusted by the domain. The do-
main creates an SCP and a registration request along with a list of
auditors to conﬁrm that registration. The request, however, is sent
ﬁrst to the ﬁrst auditor in the list, who then passes it to the log. The
log performs the same checks and synchronizations as in §6.1, but
the registration receipt is then returned to the second auditor, who
checks that the registration was carried out correctly. This auditor
then signs the receipt and passes it to the next auditor. Each of
n − 1 auditors performs similar checks and veriﬁes whether the log
indeed appended the SCP in the next update period. Finally, the
domain receives a receipt conﬁrmed by n − 1 trusted auditors. For
SCP updates the message ﬂow is identical, and the auditors verify
whether or not the log correctly updated policy (e.g. if a potential
cool-off period was satisﬁed).
For certiﬁcate registration the message ﬂow is the same as pre-
viously. The log operates as presented in §6.2, and the only dif-
ference is that log sends the receipt to an auditor instead of to the
domain. At the end the domain obtains a registration receipt con-
ﬁrmed by auditors, and the auditors again checks log’s content after
the next update for the registered MSC. In the case of a certiﬁcate
revocation, auditors similarly conﬁrm that the certiﬁcate was re-
voked in the log.
As in PoliCert, domains periodically send proof requests and re-
ceive from the log proofs of their SCP and MSC’s presence. How-
ever, these proofs are additionally conﬁrmed by n − 1 auditors.
Browser-based validation is almost the same as presented in §6.3.
The only extra step is that the browser also checks if the proofs (or
receipts) are conﬁrmed by n − 1 auditors from the domain’s AUDI-
TOR_LIST.
9. SECURITY ANALYSIS
We now conduct an informal security analysis of PoliCert. In
this analysis we assume that a domain A has correctly registered its
policy and MSCs at the logs. We consider an adversary who is able
to capture trusted elements of the system (logs, CAs, and domains
private keys) and whose goal is to impersonate A’s website.
3In ARPKI CAs take the auditor’s role.
Our ﬁrst claim is that an adversary without A’s policy private key
cannot create a valid MSC for A. Constructing a multi-signature
certiﬁcate (Equation 1) requires a policy binding which combines
a set of X.509 certiﬁcates into one logical MSC. Because the pol-
icy binding must be signed by A’s policy private key, an adversary
without that key cannot create any valid MSC.
Even if we assume that the adversary has access to the policy’s
private key, then we can show that the adversary cannot imperson-
ate A without compromising at least CERT_TH of A’s trusted CAs
(from CA_LIST). This is due to the MSC validation process (Algo-
rithm 2), which requires a valid MSC to contain at least CERT_TH
valid X.509 certiﬁcates. This threshold is also a lower bound, since
the domain may inherit a higher threshold from its parent domain’s
SCP.
An adversary who has compromised the required number of A’s
trusted CAs and A’s policy private key can impersonate A by cre-
ating a malicious MSC and serving it to the clients. However, to
mount this MitM attack the adversary must receive conﬁrmations
(a registration receipt or log proof) from the log. This requires ﬁrst
registering the malicious MSC, which would make the fraudulent
certiﬁcate publicly visible. The adversary could also attempt to up-
date the SCP itself, but this would require compromising at least
UP_CA_MIN CAs, which may be more than CERT_TH.
If we assume that logs are not malicious, then all of the above
attacks can be detected since all of the adversary’s actions would
become publicly visible. If we assume a worst-case scenario where
the adversary has compromised at least CERT_TH of A’s trusted
CAs, A’s policy private key, and one or more of A’s trusted logs,
then the adversary could forge an MSC, and the necessary log proofs
or registration receipts. However, even in this case the MSC would
have to comply with A’s SCP, constraining the malicious MSC.
Additionally, while the adversary could send the client registration
receipts and never add the fraudulent MSC to the log, this action
would also be detectable after some time, as eventually the regis-
tration receipts would expire and anyone querying the log after the
receipts’ expiration would ﬁnd that the MSC was not in the log.
Security level can be increased by contacting number of auditors,
that could conﬁrm log’s actions.
In §8, we propose such archi-
tecture. The achieved property is that with successfully registered
SCP, an adversary even with n − 1 parties compromised, cannot
launch impersonation attack undetectably, as n parties are actively
involved in asserting correctness of SCPs and MSCs.
10.
INCREMENTAL DEPLOYMENT
The PoliCert infrastructure is designed to be interoperable with,
and incrementally deployable alongside, the current TLS PKI. One
important feature of our architecture is that CAs act no differently
than they currently do, allowing them to preserve their existing
business model. Because an MSC is mostly made up of a series
of X.509 certiﬁcates, it can be implemented and validated using
currently available tools and methods, and served in the standard
TLS handshake. Moreover, PoliCert even works with legacy soft-
ware, since all major browsers only validate the ﬁrst certiﬁcate they
receive from a domain. Thus for a legacy browser, only the ﬁrst cer-
tiﬁcate in the MSC needs to be valid, and the rest of the MSC will
be ignored.
During incremental deployment of PoliCert there is the possibil-
ity that an adversary may attempt a downgrading attack. In this
attack, the adversary impersonates a domain and claims that it has
not yet deployed PoliCert and hence has no proofs for its certiﬁcate
or policy. In this situation a PoliCert-enabled client browser can ob-
tain a proof of absence for the domain’s SCP as discussed in §6.4.
Because the logs synchronise SCPs globally, any log should be able
to return a proof of presence or absence for the domain’s policy. In
fact, a proof of absence for a domain’s SCP allows a client to es-
tablish a TLS connection with a legacy domain, further illustrating
the interoperability of PoliCert with the current PKI.
The hierarchical structure of SCPs also allows legacy domains
to beneﬁt from the protection of PoliCert. For clients deploying
PoliCert, validating a legacy domain’s certiﬁcate will require fetch-
ing a proof of absence for the domain’s SCP. However, this proof
will also contain all SCPs of parent domains, if they exist. With
wisely chosen SCP parameters, a parent domain can protect all of
its subdomains by, for example, forbidding wildcard certiﬁcates or
limiting the lifetime of a certiﬁcate. These parameters constrain
any certiﬁcates that an attacker might try to craft for the domain,
providing resilience against malicious certiﬁcates even for legacy
domains.
Additionally, parent domains can leverage the hierarchical struc-
ture of SCPs to incentivise the adoption of PoliCert or higher secu-
rity levels. For example, by setting CERT_TH to 2 and making the
parameter inheritable, a parent domain can force the adoption of
PoliCert for all of its subdomains. A parent domain could also set
MAX_LIFETIME and make it inheritable to ensure that their subdo-
mains regularly renew their certiﬁcates. From security perspective
it may be worth to consider minimum/maximum values e.g. for up-
date parameters. It requires debate however it is reasonable, espe-
cially for top level domains, whose policies may inﬂuence millions
of subdomains.
A domain also has incentives to deploy PoliCert due to privacy
and efﬁciency reasons. For a legacy domain the client must fetch
a proof of absence for the domain’s SCP, incurring extra latency
when establishing a TLS connection to these domains and leaking
privacy if the client directly contacts a log server for such a proof.
Deploying PoliCert would cause the domain to staple log proofs of
its SCP, saving extra round trips and preserving the client’s privacy.
Moreover, PoliCert can be built upon currently deployed system
like CT. That is caused by a fact that both systems employ similar
data structure (consistency tree) as a core element.
11. CONCLUSION
In this work, we presented PoliCert, a comprehensive solution
that addresses a range of problems with the current TLS ecosys-
tem. PoliCert secures domains’ certiﬁcates and allows domains to
create policies for their certiﬁcates as well as their subdomains’ cer-
tiﬁcates. Additionally, PoliCert handles all operations over a cer-
tiﬁcate’s lifetime (creation, registration, validation, and revocation)
in a secure and transparent manner.
By introducing long-term policies, we make a domain’s security
statements stable and transparent, and narrow the range of mali-
cious certiﬁcates that an attacker can forge. These policies can be
created by IT/security departments and applied to subdomains, al-
lowing experts to easily coordinate certiﬁcate policies for their net-
works. Additionally, the hierarchical enforcement of SCPs allow
domains to protect subdomains from human errors such as miscon-
ﬁguration.
In order to evaluate the feasibility of our system, we fully im-
plemented it and sketched an incremental deployment plan. Our
implementation results show that such a system can be successfully
deployed without signiﬁcant inﬂuence on standard client-server con-
nection. Additionally, we showed that PoliCert is interoperable
alongside the current TLS infrastructure and can be deployed using
well-known tools without breaking legacy software or protocols.
However, several challenges still remain. Global synchroniza-
tion among logs is required for some actions, however infrequent
they may be. In future work we plan to investigate whether or not
this requirement can be relaxed while maintaining efﬁciency. We
also plan to explore other parameters that can be speciﬁed in SCPs,
and what beneﬁts can be realized through more detailed speciﬁ-
cations of certiﬁcate policy. However, through PoliCert we have
provided an infrastructure which provides domains with more con-
trol over the security of their own TLS connections, and provided
initial steps towards improving today’s TLS ecosystem.
Acknowledgments
This work was supported by a Google gift. We would like to thank
Lorenzo Baesso and Lin Chen for programming assistance, and
Raphael Reischuk, Ralf Sasse for providing us with valuable feed-
back in ﬁnalizing the paper.
References
[1] Convergence. http://convergence.io/.
[2] Devdatta Akhawe and Adrienne Porter Felt. Alice in warn-
ingland: A large-scale ﬁeld study of browser security warn-
ing effectiveness. In Proceedings of the 22Nd USENIX Con-
ference on Security, SEC’13, pages 257–272, Berkeley, CA,
USA, 2013. USENIX Association.
[3] Yousef J Al-Houmaily and George Samaras. Two-phase com-
mit. In Encyclopedia of Database Systems, pages 3204–3209.
Springer, 2009.
[4] David Basin, Cas Cremers, Tiffany Hyun-Jin Kim, Adrian
Perrig, Ralf Sasse, and Pawel Szalachowski. ARPKI: At-
tack Resilient Public-key Infrastructure. In Proceedings of the
ACM Conference on Computer and Communications Security
(CCS), November 2014.
[5] Daniel J. Bernstein, Anna Krasnova, and Tanja Lange. El-
ligator: Elliptic-curve points indistinguishable from uniform
random strings. IACR Cryptology ePrint Archive, 2013:325,
2013.
[6] S. Blake-Wilson, M. Nystrom, D. Hopwood, J. Mikkelsen,
and T. Wright. Transport Layer Security (TLS) Extensions.
RFC 4366 (Proposed Standard), April 2006. Obsoleted by
RFC 5246.
[7] Joppe W. Bos, Craig Costello, Patrick Longa, and Michael
Selecting elliptic curves for cryptography: An
IACR Cryptology ePrint
Naehrig.
efﬁciency and security analysis.
Archive, 2014:130, 2014.
[8] Jeremy Clark and Paul C. van Oorschot.
Sok: Ssl and
https: Revisiting past challenges and evaluating certiﬁcate
trust model enhancements. In IEEE Symposium on Security
and Privacy, pages 511–525. IEEE Computer Society, 2013.
[9] D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley,
and W. Polk. Internet X.509 Public Key Infrastructure Cer-
tiﬁcate and Certiﬁcate Revocation List (CRL) Proﬁle. RFC
5280 (Proposed Standard), May 2008.
[10] Scott A. Crosby and Dan S. Wallach. Efﬁcient data structures
for tamper-evident logging. In USENIX Security Symposium,
pages 317–334. USENIX Association, 2009.
[11] II Ecrypt. Ecrypt ii yearly report on algorithms and keysizes
(2011-2012). Available on http://www. ecrypt. eu. org, 2012.
[12] Electronic Frontier Foundation. SSL Observatory. https:
//www.eff.org/observatory.
[13] Chris Evans and Chris Palmer. Public key pinning extension
for HTTP. November 2011.
[14] Adrienne Porter Felt, Robert W. Reeder, Hazim Almuhimedi,
and Sunny Consolvo. Experimenting at scale with google
chrome’s ssl warning.
In Proceedings of the SIGCHI Con-
ference on Human Factors in Computing Systems, CHI ’14,
pages 2667–2670, New York, NY, USA, 2014. ACM.
[15] Alexandra C Grant. Search for trust: An analysis and com-
parison of CA system alternatives and enhancements. 2012.
[17] ISO/IEC.
[16] Phillip Hallam-Baker and Rob Stradling. DNS certiﬁcation
authority authorization (CAA) resource record. January 2013.
ISO/IEC JTC 1/SC 27. Standing Document 12
– Assessment of cryptographic algorithms and key lengths.
ISO/IEC, 2012.
[18] Emilia Kasper. Fast elliptic curve cryptography in openssl.
In George Danezis, Sven Dietrich, and Kazue Sako, editors,
Financial Cryptography Workshops, volume 7126 of Lecture
Notes in Computer Science, pages 27–39. Springer, 2011.
[19] James Kasten, Eric Wustrow, and J Alex Halderman. Cage:
Taming certiﬁcate authorities by inferring restricted scopes.
[20] Tiffany Hyun-Jin Kim, Lin-Shung Huang, Adrian Perrig,
Collin Jackson, and Virgil Gligor. Accountable Key Infras-
tructure (AKI): A Proposal for a Public-Key Validation In-
frastructure. In Proceedings of the International World Wide
Web Conference (WWW), May 2013.
[21] Qualys SSL Lab. Ssl server test. https://www.ssllabs.
com/ssltest/index.html, 2014.
[22] Adam Langley.
Revocation checking and Chrome’s
CRL. https://www.imperialviolet.org/2012/02/05/
crlsets.html, February 2012.
[23] Ben Laurie and Emilia Kasper. Revocation transparency.
Google Research, September, 2012.
[24] Ben Laurie, Adam Langley, and E Kasper. Certiﬁcate trans-
parency. Available: ietf. org-Certiﬁcate Transparency (06.01.
2013), 2013.
[25] Ralph C. Merkle. A digital signature based on a conventional
encryption function. In CRYPTO ’87: A Conference on the
Theory and Applications of Cryptographic Techniques on Ad-
vances in Cryptology, pages 369–378, London, UK, 1988.
Springer-Verlag.
[26] Mozilla. Revocation plan (draft). https://wiki.mozilla.
org/CA:RevocationPlan, 2014.
[27] Mark D. Ryan.
Enhanced certiﬁcate transparency (how
johnny could encrypt). Cryptology ePrint Archive, Report
2013/595, 2013. http://eprint.iacr.org/.
[28] Christopher Soghoian and Sid Stamm. Certiﬁed lies: Detect-
ing and defeating government interception attacks against ssl
(short paper). In Financial Cryptography and Data Security,
pages 250–259. Springer, 2012.
[29] Niraj Tolia, David G. Andersen, and Mahadev Satya-
narayanan. Quantifying interactive user experience on thin
clients. IEEE Computer, 39(3):46–52, 2006.
[30] H. Tschofenig and E. Lear.
Evolving the web pub-
lic key infrastructure.
http://tools.ietf.org/id/
draft-tschofenig-iab-webpki-evolution-01.html,
2013.
[31] VeriSign
Inc.
industry
https://www.verisigninc.com/assets/
brief.
domain-name-report-april2014.pdf, April 2014.
name
The
domain
[32] Dan Wendlandt, David G. Andersen, and Adrian Perrig. Per-
spectives: Improving ssh-style host authentication with multi-
path probing.
In Rebecca Isaacs and Yuanyuan Zhou, edi-
tors, USENIX Annual Technical Conference, pages 321–334.
USENIX Association, 2008.