# 07 \| 分布式锁：关键重地，非请勿入你好，我是聂鹏程。今天，我来继续带你打卡分布式核心技术。我在[第 3篇文章](https://time.geekbang.org/column/article/141772)中，与你一起学习了分布式互斥，领悟了其"有你没我，有我没你"的精髓，为你解释了同一临界资源同一时刻只能被一个程序访问的问题，并介绍了解决分布式互斥的算法。不知道你有没有发现一个细节，在之前介绍的算法中，我主要讲了如何协调多个进程获取权限和根据权限有序访问共享资源，"获得访问权限的进程可以访问共享资源，其他进程必须等待拥有该权限的进程释放权限"。但是，我并没有介绍在访问共享资源时，这个权限是如何设置或产生的，以及设置或产生这个权限的工作原理是什么。那么，在本讲，我就将带你一起打卡分布式锁，去学习分布式锁是如何解决这个问题的。
## 为什么要使用分布锁？首先，我先带你认识一下什么是锁。在单机多线程环境中，我们经常遇到多个线程访问同一个共享资源（这里需要注意的是：在很多地方，这种资源会称为临界资源，但在今天这篇文章中，我们统一称之为共享资源）的情况。为了维护数据的一致性，我们需要某种机制来保证只有满足某个条件的线程才能访问资源，不满足条件的线程只能等待，在下一轮竞争中重新满足条件时才能访问资源。这个机制指的是，为了实现分布式互斥，在某个地方做个**标记**，这个标记每个线程都能看到，到标记不存在时可以设置该标记，当标记被设置后，其他线程只能等待拥有该标记的线程执行完成，并释放该标记后，才能去设置该标记和访问共享资源。这里的标记，就是我们常说的**锁**。``{=html}也就是说，**锁是实现多线程同时访问同一共享资源，保证同一时刻只有一个线程可访问共享资源所做的一种标记。**与普通锁不同的是，**分布式锁**是指分布式环境下，系统部署在多个机器中，实现多进程分布式互斥的一种锁。为了保证多个进程能看到锁，锁被存在公共存储（比如Redis、Memcache、数据库等三方存储中），以实现多个进程并发访问同一个临界资源，同一时刻只有一个进程可访问共享资源，确保数据的一致性。那什么场景下需要使用分布式锁呢？比如，现在某电商要售卖某大牌吹风机（以下简称"吹风机"），库存只有 2个，但有 5 个来自不同地区的用户{A,B,C,D,E}几乎同时下单，那么这 2个吹风机到底会花落谁家呢？你可能会想，这还不简单，谁先提交订单请求，谁就购买成功呗。但实际业务中，为了高并发地接受大量用户订单请求，很少有电商网站真正实施这么简单的措施。此外，对于订单的优先级，不同电商往往采取不同的策略，比如有些电商根据下单时间判断谁可以购买成功，而有些电商则是根据付款时间来判断。但，无论采用什么样的规则去判断谁能购买成功，都必须要保证吹风机售出时，数据库中更新的库存是正确的。为了便于理解，我在下面的讲述中，以下单时间作为购买成功的判断依据。我们能想到的最简单方案就是，给吹风机的库存数加一个锁。当有一个用户提交订单后，后台服务器给库存数加一个锁，根据该用户的订单修改库存。而其他用户必须等到锁释放以后，才能重新获取库存数，继续购买。在这里，吹风机的库存就是共享资源，不同的购买者对应着多个进程，后台服务器对共享资源加的锁就是告诉其他进程"**关键重地，非请勿入**"。但问题就这样解决了吗？当然没这么简单。想象一下，用户 A 想买 1 个吹风机，用户 B 想买 2个吹风机。在理想状态下，用户 A 网速好先买走了 1 个，库存还剩下 1个，此时应该提示用户 B 库存不足，用户 B 购买失败。但实际情况是，用户 A和用户 B 同时获取到商品库存还剩 2 个，用户 A 买走 1 个，在用户 A更新库存之前，用户 B 又买走了 2 个，此时用户 B 更新库存，商品还剩 0个。这时，电商就头大了，总共 2 个吹风机，却卖出去了 3 个。不难看出，如果只使用单机锁将会出现不可预知的后果。因此，在高并发场景下，为了保证临界资源同一时间只能被一个进程使用，从而确保数据的一致性，我们就需要引入分布式锁了。此外，在大规模分布式系统中，单个机器的线程锁无法管控多个机器对同一资源的访问，这时使用分布式锁，就可以把整个集群当作一个应用一样去处理，实用性和扩展性更好。
## 分布式锁的三种实现方法及对比接下来，我带你看看实现分布式锁的 3 种主流方法，即：-   基于数据库实现分布式锁，这里的数据库指的是关系型数据库；-   基于缓存实现分布式锁；-   基于 ZooKeeper 实现分布式锁。
### 基于数据库实现分布式锁要实现分布式锁，最简单的方式就是创建一张锁表，然后通过操作该表中的数据来实现。当我们要锁住某个资源时，就在该表中增加一条记录，想要释放锁的时候就删除这条记录。数据库对共享资源做了唯一性约束，如果有多个请求被同时提交到数据库的话，数据库会保证只有一个操作可以成功，操作成功的那个线程就获得了访问共享资源的锁，可以进行操作。基于数据库实现的分布式锁，是最容易理解的。但是，因为数据库需要落到硬盘上，频繁读取数据库会导致IO开销大，因此这种分布式锁**适用于并发量低，对性能要求低的场景**。对于双11、双 12等需求量激增的场景，数据库锁是无法满足其性能要求的。而在平日的购物中，我们可以在局部场景中使用数据库锁实现对资源的互斥访问。下面，我们还是以电商售卖吹风机的场景为例。吹风机库存是 2 个，有 5个来自不同地区的用户{A,B,C,D,E}想要购买，其中用户 A 想买 1 个，用户 B想买 2 个，用户 C 想买 1 个。用户 A 和用户 B 几乎同时下单，但用户 A的下单请求最先到达服务器。因此，该商家的产品数据库中增加了一条关于用户 A的记录，用户 A获得了锁，他的订单请求被处理，服务器修改吹风机库存数，减去 1 后还剩下 1个。当用户 A 的订单请求处理完成后，有关用户 A的记录被删除，服务器开始处理用户 B 的订单请求。这时，库存只有 1个了，无法满足用户 B 的订单需求，因此用户 B 购买失败。从数据库中，删除用户 B 的记录，服务器开始处理用户 C 的订单请求，库存中 1个吹风机满足用户 C 的订单需求。所以，数据库中增加了一条关于用户 C的记录，用户 C 获得了锁，他的订单请求被处理，服务器修改吹风机数量，减去1 后还剩下 0 个。![](Images/3b8319f8ff898957488b7dbf118756f1.png){savepage-src="https://static001.geekbang.org/resource/image/f5/aa/f58d1ef2d7896a9da85dbbe98f8de9aa.png"}可以看出，**基于数据库实现分布式锁比较简单，绝招在于创建一张锁表，为申请者在锁表里建立一条记录，记录建立成功则获得锁，消除记录则释放锁。**该方法依赖于数据库，主要有两个缺点：-   **单点故障问题**。一旦数据库不可用，会导致整个系统崩溃。-   **死锁问题**。数据库锁没有失效时间，未获得锁的进程只能一直等待已获得锁的进程主动释放锁。一旦已获得锁的进程挂掉或者解锁操作失败，会导致锁记录一直存在数据库中，其他进程无法获得锁。