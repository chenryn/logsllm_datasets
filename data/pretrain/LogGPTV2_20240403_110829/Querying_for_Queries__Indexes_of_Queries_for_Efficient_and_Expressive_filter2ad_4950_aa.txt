title:Querying for Queries: Indexes of Queries for Efficient and Expressive
IT-PIR
author:Syed Mahbub Hafiz and
Ryan Henry
Querying for Queries
Indexes of Queries for Efficient and Expressive IT-PIR
Syed Mahbub Hafiz
Indiana University
Computer Science Department
Bloomington, IN 47405, USA
PI:EMAIL
Ryan Henry
Indiana University
Computer Science Department
Bloomington, IN 47405, USA
PI:EMAIL
ABSTRACT
We propose indexes of queries, a novel mechanism for supporting
efficient, expressive, and information-theoretically private single-
round queries over multi-server PIR databases. Our approach de-
couples the way that users construct their requests for data from
the physical layout of the remote data store, thereby enabling users
to fetch data using “contextual” queries that specify which data
they seek, as opposed to “positional” queries that specify where
those data happen to reside. For example, an open-access eprint
repository could employ indexes of queries to let researchers fetch
academic articles via PIR queries such as for “this year’s 5 most
cited papers about PIR” or “the 3 most recently posted papers about
PIR”. Our basic approach is compatible with any PIR protocol in
the ubiquitous “vector-matrix” model for PIR, though the most
sophisticated and useful of our constructions rely on some nice
algebraic properties of Goldberg’s IT-PIR protocol (Oakland 2007).
We have implemented our techniques as an extension to Percy++,
an open-source implementation of Goldberg’s IT-PIR protocol. Our
experiments indicate that the new techniques can greatly improve
not only utility for private information retrievers but also efficiency
for private information retrievers and servers alike.
KEYWORDS
Private information retrieval; expressive queries; batch codes; batch
queries; ramp schemes; efficiency
1 INTRODUCTION
Private information retrieval (PIR) is a cryptographic technique
that enables users to fetch records from untrusted and remote
database servers without revealing to those servers which particular
records are being fetched. This paper proposes a new technique
for conducting efficient, expressive, and information-theoretically
private PIR queries over structured or semi-structured (i.e., tagged)
data. Conceptually, the new approach involves building a layer of
indirection (realized using a special kind of sparse “database” we
call an index of queries) atop existing PIR protocols.
With only a few exceptions, existing PIR constructions require
users to indicate which records they wish to fetch via the indices
of those records—that is, via the physical locations of those records
relative to others in the data store. Our indexes of queries decouple
1
the way that users construct their requests for data from the physi-
cal layout of the remote data store, thereby enabling users to fetch
data using “contextual” PIR queries that specify which data they
seek, as opposed to “positional” PIR queries that specify where in
the database those data happen to reside.
Database operators can construct many distinct indexes of que-
ries for a given data set, thus providing many distinct views through
which users can interact with the underlying data. Abstractly, each
index of queries facilitates requests for “the best k matches for z”,
where the precise meaning of ‘best’, an upper bound on the number
of matches to return k, and a domain of possible search criteria z are
all determined by the database operator and fixed for the particular
index of queries under consideration. Queries of the above form
arise naturally in a plethora of online and mobile applications. In
many such applications, the query term z reveals a great deal of
identifiable and potentially sensitive information about the habits,
interests, and affiliations of the querier [20]. The index-of-queries
approach we propose herein provides significant improvements to
both the efficiency and expressiveness of the most performant and
well studied PIR techniques in the literature, exposing intuitive APIs
through which applications can safely, easily, and efficiently inter-
act with the underlying PIR. We therefore believe (and certainly
hope) that indexes of queries will prove to be a useful building block
in the construction of efficient, privacy-preserving alternatives to
many widely deployed products and services.
Relationship with prior work. The research literature on PIR is
vast; for over two decades, the cryptography, privacy, and theory re-
search communities have studied PIR intensively and from a variety
of perspectives. However, this considerable attention notwithstand-
ing, apart from a few notable exceptions, existing work focuses
exclusively on an oversimplified model in which users request fixed-
length blocks—or even individual bits!—of data by specifying the
physical locations of those data within the database.
A small body of existing work constructs PIR queries whose
expressiveness extends beyond the ability to fetch records by index,
including techniques that enable keyword-based [3–5, 7] and sim-
ple SQL-based [21, 22, 27] PIR queries. Although our techniques
bare a superficial resemblance to these prior efforts, the precise
problem we solve and the technical machinery we use to solve it are
fundamentally new. Indeed, our approach offers several distinct ad-
vantages (and a few limitations) compared with existing techniques,
and we therefore view indexes of queries as being complementary
to—as opposed to an alternative to—existing techniques for expres-
sive PIR. A later section compares and contrasts indexes of queries
with competing approaches.
Motivation. The primary objective of this paper is to introduce
and analyze indexes of queries as a new PIR technique in the cryp-
tographic engineers’ toolkit, rather than to explore the nuances
of any particular system that one might use indexes of queries
to build. Nevertheless, to both motivate and ground our proposal,
we briefly consider three natural use cases that showcase the im-
mediate applicability of indexes of queries to the construction of
privacy-respecting technologies. We reiterate that these use cases
are merely intended to illustrate a high-level idea; indeed, it is
beyond the scope of this paper to present the full architecture of—
let alone to treat all the minutiae of implementing full, workable
systems from—any of these motivating examples.
Use case 1: Maps and location-based recommendation systems. A
mapping service like Google Maps or a recommendation service
like Yelp could instantiate indexes of queries over a Points of
Interest (POI) database to satisfy PIR requests such as for “the 10
cafés nearest my current location” or “the 5 highest rated Italian
restaurants in Manhattan”.
Use case 2: Social networks and microblogging platforms. A Twitter-
like microblogging service could instantiate indexes of queries
over its database of tweets to satisfy PIR requests such as for
“the 10 most recent tweets by @realDonaldTrump” or “the 15 top
trending tweets for hashtag #ccs17”.
Use case 3: Streaming audio and video services. Streaming media ser-
vices like Youtube or Spotify could instantiate indexes of queries
over their respective media catalogs to satisfy PIR requests such
as for “the most recent episode of Last Week Tonight with John
Oliver” or “the 10 songs topping the latest Billboard Hot 100”.
Countless use cases beyond those just listed are possible; e.g.,
throughout our technical discussions we will use the running exam-
ple of privately fetching emails from a remote inbox. One could use
this idea to, say, hide users’ email access patterns from a web mail
service like Gmail or, more interestingly, to build a next-generation
Pynchon Gate [24] for pseudonymous mail retrieval.
Outline. The remainder of the paper is structured as follows.
Section 2 describes the abstract PIR framework in which all of
the indexes-of-queries constructions reside. Section 3 introduces
simple indexes of queries, the most basic (and least interesting) form
of our construction, while Section 4 describes a more sophisticated
construction for batch indexes of queries, which leverage ideas from
coding theory to reduce costs and improve privacy compared to
simple indexes of queries. Section 5 further extends this idea to con-
struct indexes of batch queries, which allow users to fetch a batch of
several related blocks using a single, fixed-length query. (The latter
‘indexes of batch queries’ are what is needed to realize the queries
arising in the above motivating examples.) Section 6 reviews prior
work on expressive PIR queries—SQL- and keyword-based PIR que-
ries and PIR from function secret sharing—and comments on the
synergistic relationship between our work and those techniques.
We present some findings from our proof-of-concept implementa-
tion in Section 7 before concluding in Section 8.
2 THE “VECTOR-MATRIX” PIR MODEL
Our constructions are in the ubiquitous vector-matrix model for
PIR. Vector-matrix PIR is a special case of linear PIR where the
database is represented as an r × s matrix D over a finite field F
in which each of the r rows is a fetchable unit of data (called a
block in typical PIR parlance). Users encode requests for blocks as
vectors from the so-called standard basis for Fr : a user desiring
the i th block (i.e., the i th row of D) represents its request with the
length-r vector ⃗ei having a 1 in its i th coordinate and 0s elsewhere.
The response to request ⃗ei is defined as the vector-matrix product
⃗ei · D, which is easily seen to equal the desired i th row of D. We
refer to such vector-based requests as positional queries in order to
highlight the fact that they require queriers to know the physical
positions (i.e., the row numbers) within D of whatever blocks they
seek to fetch.
PIR protocols in the literature obtain privacy in the vector-matrix
model through a variety of different means. Of particular interest to
us is the information-theoretically private (IT-PIR) approach based
on linear secret sharing. Here, the user “shares” its query vector ⃗ei
component-wise using a linear secret sharing scheme, and then it
sends each of the resulting vectors of shares to a different server
from a pool of (non-colluding, but otherwise untrusted) servers
who each hold a replica of D. Upon receiving a share vector from
the user, each server independently computes and returns to the
user the product with D of the share vector it just received. As an
immediate consequence of linearity, the servers’ responses are each
component-wise secret sharings of the vector-matrix product ⃗ei · D.
Thus, to recover its requested block, the user performs a component-
wise secret reconstruction over the responses it collects from the
various servers.
Goldberg’s IT-PIR protocol. One natural and attractive choice
for the secret sharing scheme, the use of which for vector-matrix
IT-PIR was first advocated by Goldberg [13], is Shamir’s (t + 1, ℓ)-
threshold scheme [25]. To share a basis vector ⃗ei with Shamir’s
(t +1, ℓ)-threshold scheme, the user selects pairwise distinct scalars
x1, . . . , xℓ ∈ F \ {0} and a uniform random vector of polynomials
⃗F ∈ (F[x])r , subject to the conditions that (i) each polynomial in ⃗F
has degree at most t, and (ii) a component-wise evaluation of ⃗F at
x = 0 gives ⃗ei. The j th server receives (xj, ⃗Qj), where ⃗Qj = ⃗F(xj) is
a component-wise evaluation of ⃗F at xj = j. We refer to a sequence
(x1, ⃗Q1), . . . ,(xℓ, ⃗Qℓ) of ℓ > t such ordered pairs (computed from a
common ⃗F and pairwise distinct xi) as a component-wise (t + 1, ℓ)-
threshold sharing of ⃗ei.
Shamir’s threshold scheme provides the requisite linearity and
a useful Byzantine robustness property, owing to its relationship
with (indeed, equivalence to) Reed-Solomon codes [23] and related
multiple-polynomial error-correcting codes [8]. The protocol ob-
tained by using Shamir’s (t + 1, ℓ)-threshold scheme in the vector-
matrix model realizest -private(m, ℓ)-server IT-PIR for any m ≥ t +1:
the user retrieves its desired block provided m ≥ t + 1 out of ℓ
servers respond, yet no coalition oft or fewer malicious servers can
use the share vectors its members receive to learn any information
about which blocks the user has requested. (It is also v-Byzantine
robust for any v ≤ m−t −2: the user retrieves its desired block even
if up to m − t − 2 servers return incorrect responses [10].)
2
D (cid:66)
subject
Re: ccs2017 submission
definitely not a virus
UK-LOTTO sweepstake!
Fwd: Re: Fwd: roflmao
cash4gold!!!1
sender
Bob
Dave
Alice
Carol
Edward
date
2017-02-17
2017-02-1f1
2017-02-04
2017-01-07
2016-12-23
size
7.7KB
13.0KB
336KB
2.5KB
4.0KB
body
0x2ff1 e1a9...
0xb05f d7a1...
0x0365 ce00...
0x7e7a 36b7...
0xd96d faff...
Figure 1: Toy example of an email inbox database comprising five emails and associated metadata.
The above intuitive notion oft -privacy is formalized by requiring
statistical independence between the pair (I , Q) of random variables
respectively describing (i) which particular block the querier is
requesting, and (ii) the joint view of any coalition of up to t servers
involved in the request. We refer the reader to Henry [16, end of §2]
for a detailed formal definition fort -private k-batch (m, ℓ)-server IT-
PIR in the vector-matrix model. Our discussion of the Shamir-based
PIR protocol up to this point corresponds to Henry’s definition
with a fixed batching parameter of k = 1; looking forward, the
construction we present in Section 5 returns several related blocks
for each query and, therefore, corresponds to Henry’s definition
for some k > 1.
In their most basic form, our indexes of queries are compatible
with any PIR protocol in the vector-matrix model, although our
exposition assumes—and our more sophisticated and useful indexes-
of-queries constructions rely on some nice algebraic properties
of—(a scheme [16] that builds upon a scheme [18] that builds upon)
Goldberg’s Shamir-based IT-PIR; thus, although we have attempted
to make our exposition of the new constructions as self-contained
as possible, readers unfamiliar with the various building blocks may
wish to peruse Goldberg’s paper [13]—and the follow up papers by
Henry [16] and by Henry, Huang, and Goldberg [18]—for an initial
‘lay of the land’.
3 QUERYING FOR QUERIES
At the heart of our approach is a simple observation regarding the
use of (0,1)-matrices as PIR databases. We begin with the most
simplistic possible version of our idea, restricting our attention to
r × r permutation matrices and building up to more general and
interesting cases as the paper progresses.
Recall that an r × r permutation matrix is just an r × r matrix
having exactly one 1 in each row and each column, and 0s elsewhere
(equivalently, it is a matrix obtained by permuting the rows of
an r × r identity matrix). Each such matrix represents a specific
permutation on r elements: given a length-r vector ⃗v and an r × r
permutation matrix Π, the vector-matrix product ⃗v · Π yields a
length-r vector with the same components as ⃗v, but in a permuted
order.
For example, given ⃗v = ⟨a b c⟩ and a permutation matrix
 1 0 0
0 0 1
0 1 0
 ,
Π =
it is easy to check that⃗v·Π = ⟨a c b⟩; i.e., Π permutes⃗v by transposing
its second and third components.
(cid:8)
(cid:9)
The following observation is exceedingly obvious, and yet it
is sufficiently central to our approach as to nonetheless warrant
formal explication.
Observation 3.1. If ⃗e ∈ Fr is a standard basis vector and Π ∈
Fr ×r is a permutation matrix, then ⃗e · Π is a (possibly different)
standard basis vector.
For example, given the above-defined 3× 3 permutation matrix
for F3, we have that ⃗e1 · Π = ⃗e1,
Π and the standard basis
that ⃗e2 · Π = ⃗e3, and that ⃗e3 · Π = ⃗e2. In the context of IT-PIR,
we are actually interested in the following immediate corollary to
Observation 3.1.
⃗e1, ⃗e2, ⃗e3
Corollary 3.2. Let ⃗e ∈ Fr be a standard basic vector and let
Π ∈ Fr ×r be a permutation matrix. If (x1, ⃗Q1), . . . ,(xℓ, ⃗Qℓ) is a com-
ponent-wise (t + 1, ℓ)-threshold sharing of ⃗e, then (x1, ⃗Q1 · Π), . . .,
(xℓ, ⃗Qℓ · Π) is a component-wise (t + 1, ℓ)-threshold sharing of a