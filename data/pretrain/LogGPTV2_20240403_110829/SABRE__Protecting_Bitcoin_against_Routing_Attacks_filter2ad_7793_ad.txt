each of the 23 segment IDs. In the example, the client ﬁrst
requests the segment of ID:1 of the block with hash #5 then
the segment of ID:2 and so on. If either the GET SEG or the
SEG is lost the client will simply request the corresponding
segment again. As a protection mechanism, the switch bans
clients that request a block multiple times. To that end, all
requests traverse a heavy-hitter detector, namely SentLimit. For
efﬁciently implementing this component, one can reuse [49]
which can operate with just 80KB of memory.
VI. NETWORK ARCHITECTURE EVALUATION
In this section, we evaluate SABRE’s efﬁciency in protect-
ing Bitcoin against routing attacks. Speciﬁcally, we answer
the following questions: How effective is SABRE in prevent-
ing routing attacks targeted against the entire network and
individual clients? How does this effectiveness change with
the size and the connectivity of the SABRE network? How
does SABRE stand out against other relay networks and known
counter-measures?
We found that even a small deployment of 6 single-
connected SABRE nodes can prevent 94% of ASes in the
Internet from isolating more than 10% of the Bitcoin clients;
while larger deployments of 30 relays that are 5-connected can
prevent more than 99% of the ASes from isolating more than
20% of Bitcoin clients. In addition, we show that existing relay
networks, like Falcon [3] and FIBRE [2], offer no protection
against routing attacks. Finally, we show that SABRE provides
security level on-par with hosting all clients in /24, an effective
but clearly impractical countermeasure.
We start the section by describing our methodology (Sec-
tion VI-A) before presenting our results in detail.
A. Methodology
Datasets Our evaluation relies on a joint dataset combining
routing and Bitcoin information. Regarding routing informa-
tion, we rely on the AS-level topology and AS-level policies
provided by CAIDA [1], collected in May 2018. We use
the routing tree algorithm [31] to compute the forwarding
path followed between any two ASes. We assume that the
attacker’s advertisements are systematically picked at the tie-
breaking state of the BGP decision process (the worst-case for
SABRE) 4. Regarding Bitcoin information, we use the IPs of
Bitcoin clients from [8] along with the IPs of existing relay
nodes from [2], [3], both collected in May 2018. We merge
the two datasets by associating each Bitcoin IP to the AS
advertising the most-speciﬁc IP preﬁx covering it (using the
routes collected by RIPE BGP collectors [4]).
B. SABRE security efﬁciency
Fig. 8: Less than 2.5% of ASes are able to disconnect more
than 15% of clients (N: the number of deployed relays; k:
relay-graph connectivity; Tie breaks in favor of the attacker).
partition the Bitcoin network, we quantify how likely it is for
a random adversary to be able to disconnect multiple clients
from the relay network. The fraction of clients a particular AS
can disconnect from the relays is the maximum set of Bitcoin
clients she can isolate, as Bitcoin nodes connected to the relay
network cannot be partitioned.
Fig. 8 illustrates how protected the Bitcoin network is
depending on the size N and internal connectivity k of the
SABRE network. The graph shows, for each given fraction y
of Bitcoin nodes, the percentage of ASes that would be able to
independently disconnect it from SABRE. For N = 20, k = 1,
less than 3% of ASes are able to prevent a considerable fraction
of Bitcoin clients (15%) from connecting to the relay network.
In contrast, more than 90% of the clients can be isolated by
any AS in the current network [17].
The mapping between the number of possible attackers
and the partition sizes varies with the size and connectivity of
SABRE. In particular, increasing the number of deployed nodes
decreases the chances that adversaries can divert trafﬁc suc-
cessfully. On the other hand, decreasing the intra-connectivity
requirements (i.e., the value of k) allows our algorithm (Sec-
tion IV) to select from a larger set of relays and thus to form
a more effective SABRE. This creates an interesting trade-off
between how secure the intra-relay connectivity is and how
well the relay nodes cover the existing Bitcoin network. For
example, while a SABRE of 6 relays that are connected in full-
mesh (5-connected graph) is extremely hard to partition, as the
AS-level adversary would need to divert 5 peer-to-peer links, it
enables more AS-level adversaries to disconnect a larger part
of Bitcoin clients from SABRE. For example, 3% of ASes can
potentially create a partition including 22% of Bitcoin nodes.
In contrast, a 1-connected SABRE allows fewer attackers to
perform severe attacks—only 1% of ASes could create a 12%
partition—but the relay network itself can be partitioned by a
single link failure or a successful hijack from a direct peer.
SABRE protects against network-wide partitions To eval-
uate how effective SABRE is against adversaries that wish to
4Results for the opposite case, where tie-breaking systematically picks paths
originated by relay ASes, can be found in Appendix B
SABRE protects most individual clients To evaluate how
effectively SABRE protects individual clients, we look at how
likely it is for Bitcoin clients to be prevented by a random
AS-level adversary from reaching all relay nodes.
9
 0 5 10 15 20 25 30 0 5 10 15 20 25% of clients that can be isolated% of ASes that can disconnect at most y%N=20 k=5 N=20 k=3N=20 k=1N=6  k=5N=6  k=3N=6  k=1Fig. 9: 85% of the clients are protected against 96% of possible
attackers (Tie breaks in favor of the attacker)
Fig. 10: SABRE is far more secure than deployed relays and
very close to the unemployable alternative countermeasure of
hosting all clients in /24. (Tie breaks in favor of the attacker)
Fig. 10 shows, for each given percentage of ASes in the
Internet, the percentage of Bitcoin clients could be attacked
and disconnected from SABRE by this percentage of ASes.
We see that 80% of the clients are protected from 96% of the
AS-level adversaries even with a SABRE network of only 6
nodes that are 5-connected. There is again a trade-off between
secure intra-connectivity and the coverage of Bitcoin clients.
For example, a SABRE of 6 1-connected nodes protects 90% of
Bitcoin clients from 92.5% of ASes, while a fully connected 6-
node SABRE protects from only 89.5% of ASes. Interestingly,
increasing connectivity from k = 3 to k = 5 does not decrease
the protected clients signiﬁcantly while making disconnecting
the relay network almost impossible.
C. SABRE efﬁciency compared to existing relay networks
We compare SABRE to FIBRE [2] and Falcon [3] with
respect to their effectiveness against routing attacks. We found
that SABRE outperforms both, for three key reasons.
Existing relays are vulnerable to longer-preﬁx hijacks All
relay nodes of both FIBRE and Falcon are hosted in preﬁxes
that are shorter than /24. As such, any AS-level adversary
can cut connections among relays as well as from the Bitcoin
clients only by hijacking 6 more-speciﬁc preﬁxes for FIBRE
and 10 for Falcon.
Existing relay networks are poorly connected Even if
these relay networks were hosted in /24 preﬁxes, our analysis
revealed that their connections could still be diverted by same-
preﬁx advertisements. In particular, we found that FIBRE
relays would be disconnected by any of 652 ASes, and Falcon
by any of 3 ASes even if /24 preﬁxes were used.
Existing relays provide bad coverage Even ignoring their
poor relay-to-relay connectivity and again assuming that these
relay networks were hosted in /24 preﬁxes, their client-to-
relay connections would still have been more vulnerable than
those of SABRE allowing for more network-wide and targeted
attacks. We compare existing relay networks with SABRE with
respect to how well they protect against routing attacks using
the same graphs as in § VI-B. In particular, Fig. 10 shows
the percentage of ASes that are able to independently isolate
a fraction of the Bitcoin network as a function of this fraction
while Fig. 11 shows the cumulative percentage of clients as
a function of the number of AS-level adversaries that could
disconnect them from all relay nodes. While FIBRE is slightly
better than Falcon, SABRE outperforms both.
D. SABRE efﬁciency compared to hosting all clients in /24s
We now compare SABRE to the most effective counter-
measure against routing attacks: hosting all Bitcoin clients in
/24 preﬁxes [17]. While effective, this countermeasure is also
highly impractical as it requires ISP cooperation in addition
to an increase in the size of the routing tables Internet-wide.
We found that SABRE offers comparable level of protection
against network-wide and targeted attacks while being easily
deployable.
The comparison between the two approaches is not
straightforward as SABRE protects the network even if the at-
tacker has already partitioned the Bitcoin Peer-to-Peer network
while the other approach (hosting clients in /24) aims at secur-
ing the Peer-to-Peer network itself. We compare them against
the same metrics we used previously in Section VI-B, namely
offered protection against partition attacks and effectiveness in
protecting individual nodes. In the following we describe how
we calculated those metrics for the all-/24 approach, before
presenting our results.
First, we estimate the size of different partitions and
the number of AS-level adversaries that could achieve those
assuming all clients are hosted in /24 preﬁxes. In particular,
we ﬁnd the AS-level adversaries that would be able to isolate
a considerable fraction of Bitcoin clients using same-preﬁx
advertisements only. To that end, we run a search on the
AS-level topology graph staring from each AS with Bitcoin
clients X and following order of descending path preference
(as described in Section IV-C), namely more economically
preferred paths for X are visited ﬁrst. All ASes that are
traversed by the search before another AS with Bitcoin clients
are able to isolate X from the Bitcoin network. Indeed, this
calculation gives only a lower bound with respect
to the
possible partitions,
i.e. hosting all clients in /24 preﬁxes
might offer less security than what we computed. Finally we
10
 40 50 60 70 80 90 100 0 2 4 6 8 10 12 14% of clients that can be isolated% of possible attackersN=20 k=5 N=20 k=3N=20 k=1N=6  k=5N=6  k=3N=6  k=1 0 10 20 30 40 50 60 70 0 5 10 15 20 25 30 35 40 45% of clients that can be isolated% of ASes that can disconnect at most y%SABRE (40,5)SABRE (40,3)SABRE (10,5)SABRE (6,5)FIBREFALCONAll in \24 prefsFig. 11: Falcon does not protect many clients as it is centralized
to only two ASes. SABRE performs on-par with hosting all
clients in /24 while being deployable (Tie breaks in favor of
the attacker)
Second,
compare our ﬁndings to SABRE’s. Our results are summarized
in Fig. 10. Indeed, hosting all clients in /24 preﬁxes would
secure the Bitcoin Network better than SABRE, as partitions
larger than 20% would be possible for only 0.016% of ASes.
in order to calculate how many attackers can
successfully isolate individual Bitcoin clients assuming that
all clients are hosted in /24 preﬁxes, we looked at the ASes
that are able to divert trafﬁc from each of those clients to all
others in the network. We compare our ﬁndings to SABRE’s.
The results are included in Fig. 11. The two approaches show
similar protection levels with SABRE being slightly better at
times. This is because SABRE can place relays in any AS in
the Internet, while the alternative countermeasure is limited to
the actual distribution of Bitcoin clients.
VII. SOFTWARE/HARDWARE CO-DESIGN FEASIBILITY
We validated the feasibility of our co-design by testing
it in practice using regular and modiﬁed Bitcoin clients. In
this section, we showcase that: (i) a programmable switch
can seamlessly talk to a Bitcoin client without any software
interaction; and that (ii) the data-plane memory footprint is
low compared to the on-chip memory available in today’s
programmable switches.
Implementation and testbed Both the controller and the
clients are implemented as extensions of the default Bitcoin
client version 0.16. The former containing ∼650 added or
modiﬁed lines of C++ code and the latter ∼680 lines. The
switch is implemented in ∼900 lines of P4 code. Our prototype
runs on Mininet [40] and uses the publicly available P4
behavioral model (BMV2) [14] to emulate the switch. Our
testbed (see Fig. 12) is composed of three clients A, B, C
along with a relay node consisting of a switch and a controller.
Nodes B, C (shown in red) are modiﬁed and are connected
to SABRE, while node A (shown in green) is an unmodiﬁed
Bitcoin client.
Timing We walk through the life of a block that was mined
in the Bitcoin network and sent by the unmodiﬁed client A
to B. The latter will advertise the new block to the switch
11
Fig. 12: A block can be successfully transmitted from node A
to node C via the SABRE after it has been validated by the
controller.
which will allow node B to connect directly to the controller
and transmit it. The controller will then update the memory of
the switch and will advertise the block to the connected peers
(e.g., C). Next, node C will request and receive the block
in segments. The main steps of this procedure are listed in
Fig. 12 which describes each step and the time it required
in our prototype implementation. The most time-consuming
operations are updating the switch and transmitting the block,
taking ∼7s each. These high delays are due to the fact that
we relied on a software-based P4 switch. In practice, the only
actual bottleneck in a hardware implementation would be the
uplink of the relay nodes.
i.e.,
Memory requirements We analytically calculated the mem-
ory required for each of the components in the switch taking
into consideration the expected load. Table I summarizes
our results. It contains the name of the component and its
capacity,
the number of elements that can be added
such that the false positive rate listed in the third column is
not exceeded. We found that the cumulative memory needed
does not exceed 5MB which is well within the limitations of
today’s programmable switches. The most memory-demanding
component is the Blacklist for which we budget 1 million
entries. This is necessary to allow for mitigating DDoS attacks.
In contrast, the components devoted to benign operations are
less memory-demanding since the number of legitimate clients
is signiﬁcantly less. For instance, we only reserve space for
100k clients in the PeerList and 100 for the Whitelist; both
require less than 1MB. Observe that Bloom ﬁlters for regular
clients have a lower false positive rate than the Blacklist.
This enables to serve already connected clients even if the
switch is under such an extreme DDoS attack that the Blacklist
is ﬂooded. We do not list the requirement of the SentLimit
component as they are negligible [49]. Finally, the memory
needed for storing the latest block as well as for keeping all
known hashes takes about 1MB each.
VIII. DEPLOYABILITY & INCENTIVES
In this section, we show that SABRE is both practical and
partially deployable. While a full deployment of SABRE can
protect Bitcoin as a whole, partially deploying SABRE is less
expensive and offers gains to early adopters (even individuals).
A. Full deployment
A complete deployment of SABRE requires: (i) hosting
relays in particular ASes; (ii) equipping relay locations with
 0 20 40 60 80 100 0 5 10 15 20 25 30 35 40 45% of clients that can be isolated% of possible attackersSABRE (40, 5) SABRE (40, 3)SABRE (10, 5)SABRE (6, 5)FIBREFALCONAll in \24 prefsController12345ABC6t1=4.116747t2=4.123658t3=4.137560t4=11.141835t5=11.143454t6=18.365183TimeDescription10Node B gets block from node A269msNode B sends ADV to switch314msNode B connects to Controller 47sController updates the switch 51.6msController advertises block to C67.22sNode C gets block in segmentsUDPBitcoin  protocolComponent
Items
False Positive
Memory
BlackList: