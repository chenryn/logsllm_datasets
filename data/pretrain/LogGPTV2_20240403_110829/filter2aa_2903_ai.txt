这种分类方法（见下文）。
1.4.2 按目标代码的执行方式分类
脚本语言具有简单易学、不需要编译等优点，比如网页开发中广泛
使用的JavaScript和VBScript。脚本程序是由专门的解释程序解释执行
的，不需要产生目标代码，与编译执行的程序有很多不同。调试使用脚
本语言编写的脚本程序的过程称为脚本调试。所使用的调试器称为脚本
调试器。
编译执行的程序又主要分成两类：一类是先编译为中间代码，在运
行时再动态编译为当前CPU能够执行的目标代码，典型的代表便是使用
C#开发的.NET程序。另一类是直接编译和链接成目标代码的程序，比
如传统的C/C++程序。为了便于区分，针对前一类代码的调试一般称为
托管调试，针对后一类程序的调试称为本地调试（native debugging）。
如果希望在同一个调试会话中既调试托管代码又调试本地代码，那么这
种调试方式称为混合调试（inter-op debugging）。
图1-7归纳出了按照执行和编译方式来对软件调试进行分类的判断
方法和步骤。
图1-7 按照执行和编译方式对软件调试进行分类的判断方法和步骤
本书重点讨论本地调试。
1.4.3 按目标代码的执行模式分类
在Windows这样的多任务操作系统中，作为保证安全和秩序的一个
根本措施，系统定义了两种执行模式，即低特权级的用户模式（user
mode）和高特权级的内核模式（kernel mode）。应用程序代码是运行在
用户模式下的，操作系统的内核、执行体和大多数设备驱动程序则是运
行在内核模式的。因此，根据被调试程序的执行模式，我们可以把软件
调试分为用户态调试（user mode debugging）和内核态调试（kernel
mode debugging）。
因为运行在内核态的代码主要是本地代码以及很少量的脚本，例如
ASL语言编写的ACPI脚本，所以内核态调试主要是调试本地代码。而用
户态调试包括调试本地应用程序和调试托管应用程序等。
本书后面的章节将详细介绍Windows下的用户态调试和内核态调
试。
1.4.4 按软件所处的阶段分类
根据被调试软件所处的开发阶段，我们可以把软件调试分为开发期
调试和产品期调试。二者的分界线是产品的正式发布。
产品期调试旨在解决产品发布后才发现的问题，问题的来源主要是
客户通过电子邮件、电话等方式报告的，或者通过软件的自动错误报告
机制（见分卷）得到的。与开发期调试相比，产品期调试具有如下特
征。
因为产品期的问题没有被产品发布之前的测试过程所发现，所以它
们很可能与特定的使用环境和使用方式有关。有时可能无法在调试
者的环境中再现问题，这时可能要使用远程调试方法，或者到用户
的环境中去，或者使用在用户环境中产生的故障转储文件。
产品期调试通常是在一个更大的范围内分析问题，因此，一个基本
的思路就是逐渐缩小范围，逐步靠近问题根源。有时问题的根源不
属于产品本身，调试的过程只是要证明这一点。
处于产品期调试阶段时，被调试的模块大多是发布版本的，有些模
块可能是其他公司的，没有源代码和符号文件。因此，产品期调试
往往需要汇编级的分析和跟踪，或者分析堆栈中的原始数据。
如果是在客户的环境中进行调试，那么客户通常不愿意向他们的系
统安装大量的工具或其他文件。如果不得不这样做，就需要先征得
他们的同意。
产品期调试的时间要求往往更紧急，因为客户可能亟待使用这个产
品，或者无法理解为什么需要较长的时间。
总之，产品期调试的难度一般更大，对调试者的要求更高。
1.4.5 按调试器与调试目标的相对位置分类
如果被调试程序（调试目标）和调试器在同一个计算机系统中，那
么这种调试称为本机调试（local debugging）。这里的同一个计算机系
统是指在同一台计算机上的同一个操作系统中，不包括运行在同一个物
理计算机上的多个虚拟机。
如果调试器和被调试程序分别位于不同的计算机系统中，它们通过
以太网络或其他网络进行通信，那么这种调试方式称为远程调试
（remote debugging）。远程调试通常需要在被调试程序所在的系统中
运行一个调试服务器程序。这个服务器程序和远程的调试器相互联系，
向调试器报告调试事件，并执行调试器下达的命令。在本书后续分册讨
论调试器时，我们将进一步讨论远程调试的工作方式。
利用Windows内核调试引擎所做的活动内核调试需要使用两台机
器，两者之间通过串行接口、1394接口或USB 2.0进行连接。尽管这种
调试的调试器和调试目标也在两台机器中，但是通常不将其归入远程调
试的范畴。
1.4.6 按调试目标的活动性分类
软件调试的目标通常是当时在实际运行的程序，但也可以是转储文
件（dump file）。因此，根据调试目标的活动性，可以把软件调试分为
活动目标调试（live target debugging）和转储文件调试（dump file
debugging）。转储文件以文件的形式将调试目标的内存状态凝固下
来，包含了某一时刻的程序运行状态。转储文件调试是定位产品期问题
以及调试系统崩溃和应用程序崩溃的一种简便而有效的方法。
1.4.7 按调试工具分类
软件调试也可以根据所使用的工具进行分类。最简单的就是按照调
试时是否使用调试器分为使用调试器的软件调试和不使用调试器的软件
调试。使用调试器的调试可以使用断点、单步执行、跟踪执行等强大的
调试功能。不使用调试器的调试主要依靠调试信息输出、日志文件、观
察内存和文件等。后者具有简单的优点，适用于调试简单的问题或无法
使用调试器的情况。
以上介绍了软件调试的几种常见分类方法，目的是让读者对典型的
软件调试任务有概括性的了解。有些分类方法是有交叉性的，比如调试
浏览器中的JavaScript属于脚本调试，也属于用户态调试。
1.5 调试技术概览
深入介绍各种软件调试技术是本书的主题，本着循序渐进的原则，
在本节中，我们先概述各种常用的软件调试技术，帮助大家建立起一个
总体印象。在后面的各章中，我们还会从不同角度做更详细的讨论。
1.5.1 断点
断点（breakpoint）是使用调试器进行调试时最常用的调试技术之
一。其基本思想是在某一个位置设置一个“陷阱”，当CPU执行到这个位
置时便“跌入陷阱”，即停止执行被调试的程序，中断到调试器（break
into debugger）中，让调试者进行分析和调试。调试者分析结束后，可
以让被调试程序恢复执行。
根据断点的设置空间可以把断点分为如下几种。
代码断点：设置在内存空间中的断点，其地址通常为某一段代码的
起始处。当CPU执行指定内存地址的代码（指令）时断点命中
（hit），中断到调试器。使用调试器的图形界面或快捷键在某一行
源代码或汇编代码处设置的断点便是代码断点。
数据断点：设置在内存空间中的断点，其地址一般为所要监视变量
（数据）的起始地址。当被调试程序访问指定内存地址的数据时断
点命中。根据需要，测试人员可以定义触发断点的访问方式（读/
写）和宽度（字节、字、双字等）。
I/O断点：设置在I/O空间中的断点，其地址为某一I/O地址。当程序
访问指定I/O地址的端口时中断到调试器。与数据断点类似，测试
人员也可以根据需要设置断点被触发的访问宽度。
根据断点的设置方法，我们可以把断点分为软件断点和硬件断点。
软件断点通常是通过向指定的代码位置插入专用的断点指令来实现的，
比如IA32 CPU的INT 3指令（机器码为0xCC）就是断点指令。硬件断点
通常是通过设置CPU的调试寄存器来设置的。IA32 CPU定义了8个调试
寄存器：DR0～DR7，可以同时设置最多4个硬件断点（对于一个调试
会话）。通过调试寄存器可以设置以上3种断点中的任意一种，但是通
过断点指令只可以设置代码断点。
当中断到调试器时，系统或调试器会将被调试程序的状态保存到一
个数据结构中——通常称为执行上下文（CONTEXT）。中断到调试器
后，被调试程序是处于静止状态的，直到用户输入恢复执行命令。
追踪点（tracepoint）是断点的一种衍生形式。其基本思路是：当设
置一个追踪点时，调试器内部会当作特殊的断点来处理。当执行到追踪
点时，系统会向调试器报告断点事件，在调试器收到后，会检查内部维
护的断点列表，发现目前发生的是追踪点后，便执行这个追踪点所定义
的行为，通常是打印提示信息和变量值，然后便直接恢复被调试程序执
行。因为调试器是在执行追踪动作后立刻恢复被调试程序执行的，所以
调试者没有感觉到被调试程序中断到调试器的过程，尽管实际上是发生
的。
条件断点（conditional breakpoint）的工作方式也与此类似。当用户
设置一个条件断点时，调试器实际插入的还是一个无条件断点，在断点
命中、调试器收到调试事件后，它会检查这个断点的附加条件。如果条
件满足，便中断给用户，让用户开始交互式调试；如果不满足，那么便
立刻恢复被调试程序执行。
1.5.2 单步执行
单步执行（step by step）是最早的调试方式之一。简单来说，就是
让应用程序按照某一步骤单位一步一步执行。根据每次要执行的步骤单
位，又分为如下几种。
每次执行一条汇编指令，称为汇编语言一级的单步跟踪。其实现方
法一般是设置CPU的单步执行标志，以IA32 CPU为例，设置CPU标
志寄存器的陷阱标志（Trap Flag，TF）位，可以让CPU每执行完一
条指令便产生一个调试异常（INT 1），中断到调试器。
每次执行源代码（比汇编语言更高级的程序语言，如C/C++）的一
条语句，又称为源代码级的单步跟踪。高级语言的单步执行一般也
是通过多次汇编一级的单步执行实现的。当调试器每次收到调试事
件时，它会判断程序指针（IP）是否还属于当前的高级语言语句，
如果是，便再次设置单步执行标志并立刻恢复执行，让CPU再执行
一条汇编指令，直到程序指针指向的汇编指令已经属于其他语句。
调试器通常是通过符号文件中的源代码行信息来判断程序指针所属
于的源代码行的。
每次执行一个程序分支，又称为分支到分支单步跟踪。设置IA32
CPU的DbgCtl MSR寄存器的BTF（Branch Trap Flag）标志后，再设
置TF标志，便可以让CPU执行到下一个分支指令时触发调试异常。
WinDBG的tb命令用来执行到下一个分支。
每次执行一个任务（线程），即当指定任务被调度执行时中断到调
试器。当IA32 CPU切换到一个新的任务时，它会检查任务状态段
（TSS）的T标志。如果该标志为1，那么便产生调试异常。但目前
的调试器大多还没有提供对应的功能。
单步执行可以跟踪程序执行的每一个步骤，观察代码的执行路线和
数据的变化过程，是深入诊断软件动态特征的一种有效方法。但是随着
软件向大型化方向的发展，从头到尾跟踪执行一个软件乃至一个模块，
一般都不再可行了。一般的做法是先使用断点功能将程序中断到感兴趣
的位置，然后再单步执行关键的代码。我们将在第4章详细介绍CPU的
单步执行调试。
1.5.3 输出调试信息
打印和输出调试信息（debug output/print）是一种简单而“古老”的
软件调试方式。其基本思想就是在程序中编写专门用于输出调试信息的
语句，将程序运行的位置、状态和变量取值等信息以文本的形式输出到
某一个可以观察到的地方，可以是控制台、窗口、文件或者调试器。
比如，在Windows平台上，驱动程序可以使用DbgPrint/DbgPrintEx
来输出调试信息，应用程序可以调用OutputDebugString，控制台程序可
以直接使用printf系列函数打印信息。在Linux平台上，驱动程序可以使
用printk来输出调试信息，应用程序可以使用printf系列函数。
以上方法的优点是简单方便、不依赖于调试器和复杂的工具，因此
至今仍在很多场合广泛使用。
不过这种简单方式也有一些明显的缺点，比如需要在被调试程序中
加入代码，如果被调试程序的某个位置没有打印语句，那么便无法观察
到那里的信息，如果要增加打印语句，那么需要重新编译和更新程序。
另外，这种方法容易影响程序的执行效率，打印出的文字所包含的信息
有限，容易泄漏程序的技术细节，通常不可以动态开启、信息不是结构
化的、难以分析和整理等。我们将在16.5.5节介绍使用这种方法应该注
意的一些细节。
1.5.4 日志
与输出调试信息类似，写日志（log）是另一种被调试程序自发的
辅助调试手段。其基本思想是在编写程序时加入特定的代码将程序运行
的状态信息写到日志文件或数据库中。
日志文件通常自动按时间取文件名，每一条记录也有详细的时间信
息，因此适合长期保存以及事后检查与分析。因此很多需要连续长时间
在后台运行的服务器程序都有日志机制。
Windows操作系统提供了基本的日志记录、观察和管理（删除和备
份）功能。Windows Vista新引入了名为Common Log File
System（CLFS.SYS）的内核模块，用于进一步加强日志功能。Syslog是
Linux系统下常用的日志设施。我们将在第15章详细介绍这些调试支持
的内容。
1.5.5 事件追踪
打印调试信息和日志都是以文本形式来输出和记录信息的，因此不
适合处理数据量庞大且速度要求高的情况。事件追踪机制（Event
Trace）正是针对这一需求设计的，它使用结构化的二进制形式来记录
数据，观察时再根据格式文件将信息格式转化为文本形式，因此适用于
监视频繁且复杂的软件过程，比如监视文件访问和网络通信等。
ETW（Event Trace for Windows）是Windows操作系统内建的一种
事件追踪机制，Windows内核本身和很多Windows下的软件工具（如