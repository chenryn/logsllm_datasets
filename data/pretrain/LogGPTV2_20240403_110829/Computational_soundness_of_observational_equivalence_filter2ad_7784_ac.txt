or s ∈ N r n
σ ⊢ s
σ ⊢ s1 . . . φ ⊢ sℓ
σ ⊢ f (s1, . . . , sℓ)
f ∈ Σ
σ ⊢ s
σ ⊢ s′
M |= s = s′
Example 3.6. Consider the signature and equational the-
ory of example 3.2. Let φ = νn1, n2, n3, r1, r2, r3.σ with σ =
{x1
Then
νn1, n2, n3, r1, r2, r3.(σ ⊢ n3).
7→}.
k1 , x2
Deduction is not suﬃcient for expressing the attacker’s
knowledge. We have also to consider its distinguishing ca-
pabilities. Using the predicate symbols, we get the following
slight extension of static equivalence:
Definition 3
(static equivalence). Let φ be a frame,
p be a predicate and s1, . . . , sk be terms. We say that φ |=
p(s1, . . . , sk) if there exists n such that φ = νn.σ, fn(si) ∩ n = ∅
for any 1 ≤ i ≤ k and M |= p(s1, . . . , sk)σ. We say that
two frames φ1 = νn.σ1 and φ2 = νn′.σ2 are statically equiv-
alent, and write φ1 ∼ φ2 when dom(φ1) = dom(φ2), and
∀s1, . . . , sk ∈ T (N , X ), ∀p ∈ P.
φ1 |= p(s1, . . . , sk) ⇔ φ2 |= p(s1, . . . , sk).
Example 3.7. Consider (again for the theory of Example
n1 } and
If s has the same length as
3.2) the two frames φ1 = νn1, r1, r2.{x 7→ {{k}r1
φ2 = νn2, r3.{x 7→ {s}r3
{k}r1
n1 , then the two frames are statically equivalent
n1 }r2
n2 }.
4. COMPUTATIONAL INTERPRETATION
Given a security parameter η and a mapping τ from names
to actual bitstrings of the appropriate length, which de-
pends on η, the computational interpretation [[s]]τ
η of a term
s is deﬁned as a F-homomorphism: for each function sym-
bol f there is a polynomially computable function [[f ]] and
[[f (t1, . . . , tn)]]τ
η
def
= [[f ]]([[t1]]τ
η ).
In addition, for names,
def
= τ (n). Such an inter-
pretation must be compatible with the equational theory:
∀s, t, η, τ. s =E t ⇒ [[s]]τ
η = [[t]]τ
η .
η , . . . , [[tn]]τ
[[n]]τ
η
Similarly, each predicate symbol p gets a computational
interpretation [[p]] as a PPT that outputs a Boolean value.
This is extended to conditions, using the standard inter-
pretation of logical connectives. Given an interpretation
M of the predicates symbols in the symbolic model we as-
sume that [[p]] is an implementation of this interpretation
p ⊆ (T (N ))n, that is
Pr{(x1, . . . , xn) R←− [[t1, . . . , tn]]η : [[p]](x1, . . . , xn) = 1 − b}
is negligible for any t1, . . . , tn, where b = 1 whenever
M |= p(t1, . . . , tn) and 0 otherwise.
Example 4.1. Consider the predicate symbols of Exam-
ple 3.2. Assume that the decryption and projection functions
return an error message ⊥ when they fail. Then here are
possible interpretations of some predicates:
• [[M ]] is the set of bitstrings, which are distinct from
[[M ]] implements M if the encryption scheme is
⊥.
confusion-free (a consequence of INT-CTXT [31]).
• [[EQ]] is the set of pairs of identical bitstrings, which
are distinct from ⊥. It is an implementation of EQ as
soon as [[M ]] implements M .
Given a random tape τ and a security parameter η, a sim-
ple process P is implemented as expected. In particular, we
assume that shared names are distributed to the expected
machines in an initialization phase and random number are
computed according to the random tape. The implementa-
tion of P is denoted by [[P ]]τ
η .
5. MAIN RESULT
5.1 Assumptions and result
Encryption scheme.
We assume that it is IND-CPA (more precisely “type 3”-
secure of [4]) and INT-CTXT, as deﬁned in [13]. Moreover,
we assume that each time the adversary needs a new key,
it requests it to the protocol (e.g. using a corrupted party).
The parties are supposed to check that the keys they are
using have been properly generated.
Key hierarchy.
k2 }r1
A term u which occurs at least once in t at another po-
sition than a key or a random number (third argument in
encryption) is called a plaintext subterm of t. E.g. k1 and k3
occur in plaintext in  but not k2. We say
that k encrypts k′ in a set of terms S if S contains a subterm
{u}r
k such that k′ is a plaintext subterm of u. We assume a
key hierarchy, i.e. an ordering on private keys such that, for
any execution of the protocol no key encrypts a greater key.
If there is a key hierarchy, no key cycle can be created. Note
that, when comparing two processes, the two key hierarchies
do not need to be identical.
Parsing.
To ease parsing operations, we assume that the pairing,
key generation and encryption functions add a typing tag
(which can be changed by the attacker), which includes
which key is used in case of encryption. This can be eas-
ily achieved by assuming that a symmetric key k consists of
two parts (k1, k2), k1 being generated by some standard key
generation algorithm and k2 selected at random. Then one
encrypts with k1 and tags the ciphertext with k2.
We are now ready to state our main theorem: observa-
tional equivalence implies indistinguishability.
Theorem 4. Let P1 and P2 be two simple processes such
that each Pi admits a key hierarchy. Assume that the en-
cryption scheme is joint IND-CPA and INT-CTXT. Then
P1 ∼o P2 implies that [[P1]] ≈ [[P2]].
For example, anonymity of group signature as deﬁned in
section 2 is soundly abstracted by the property deﬁned in
Example 3.3. Computational secrecy as deﬁned in section 2
can be soundly abstracted by strong secrecy: a secret x is
strongly secret in P if P (s) ∼o P (s′) for any term s, s′.
5.2 Overview of the proof
The rest of the paper is devoted to the proof sketch of
Theorem 4.
A ﬁrst approach.
Let us ﬁrst show why the naive ideas do not work. Assume
we have proved that any computational trace is an interpre-
tation (for some sample input) of a symbolic trace. Assume
moreover that we have a soundness result showing that, if
s1, . . . , sn and u1, . . . , un are two equivalent sequences of
terms, then the distributions [[s1, . . . , sn]] and [[u1, . . . , un]]
are indistinguishable. Assume ﬁnally that the traces of P1
and the traces of P2 can be pairwise associated in statically
equivalent traces (as a consequence of observational equiva-
lence).
One could think that it is possible to conclude, pretending
that [[P2]] ≈ [[P1]] since [[t1]] ≈ [[t2]] for each trace t1 of P1 and
the corresponding trace t2 of P2. This is however incorrect.
Indeed, an attacker can choose his requests (hence the trace)
depending on the sample input. In the equivalence [[t1]] ≈
[[t2]], we use an average on the samples, while the choice of
t1 (and t2), may depend on this sample: there is a circular
dependency.
To be more concrete, here is a toy example. Assume that
an attacker, given a random input τ , ﬁrst gets [[s]]τ (in both
experiments) and then, schedules his requests depending on
the ith bit of [[s]]τ : at the ith step, he will get tj
i (resp. uj
i
in the second experiment), where j is the ith bit of [[s]]τ .
Assume that, for any sequence of bits j1, . . . , jn,
[[s, tj1
1 , . . . , ujn
n ]]
1 , . . . , tjn
n ]] ≈ [[s, uj1
1 , . . . , tjn
1 , . . . , ujn
but that, for the particular sample τ such that [[s]]τ = j1 · · · jn,
the attacker outputs 1 on input [[s, tj1
n ]]τ and out-
puts 0 on input [[s, uj1
n ]]τ . This may happen as the
distributions could be indistinguishable while distinguished
on one particular sample value. Note that, in the distribu-
tion equivalence, we draw again a sample, while the choice
of j1, ..., jn depended precisely of that sample. Then the
attacker always outputs 1 in the ﬁrst experiment since he
precisely chose from τ the sequence j1, ...jn. Similarly, he
always outputs 0 in the second experiment: he gets a signif-
icant advantage, distinguishing the two processes.
The example shows that we cannot simply use the sound-
ness of static equivalence on traces. The idea is to consider
trees labeled with terms, instead of sequences of terms. Then
we do not commit ﬁrst to a particular trace (as choosing
j1, ..., jn above). Considering such trees requires an exten-
sion of the results of Abadi and Rogaway, which are proved
for sequences of terms.
Proof sketch.
We associate a tree TP with each process P , which we
call process computation tree and deﬁne symbolic and com-
putational equivalences (denoted respectively ∼ and ≈) on
process computation trees (see the deﬁnitions in the section
6). Such trees record the possible behaviors of the symbolic
process, depending on the input they get from the environ-
ment: TP is a labeled transition system, whose initial state
is P . We use process computation trees as an intermediate
step and show the following implications:
P ∼o Q ⇒ TP ∼ TQ ⇒ TP ≈ TQ ⇒ [[P ]] ≈ [[Q]]
P ∼o Q ⇒ TP ∼ TQ : (Lemma 7) It holds for any term al-
gebra, relying however on the particular fragment of
process algebra (simple processes). This is similar to
the classical characterization of observational equiva-
lence as labeled bisimilarity.
TP ∼ TQ ⇒ TP ≈ TQ : (Lemma 11) It uses the (tree) sound-
ness in the ground case. This is a new concept, which
generalizes the soundness of static equivalence from se-
quences to trees. It is necessary for the preservation of
trace equivalences.
As a (very simple) example, consider the trees TP and TQ
whose edges are labeled with any possible pair of symbolic
messages. The path labeled , . . . , 
yields a node labeled with {u1}r1
in TP and
yields a node labeled with {v1}r1
k . This corre-
sponds to a Left-Right oracle of an IND-CPA game. The
tree soundness states in this case that the two trees are in-
distinguishable: even if the attacker adaptatively chooses
his requests (i.e. a path in the tree), he cannot make a dif-
ference between the two experiments. IND-CCA2 could be
also expressed in this way. Here we consider more general
experiments, speciﬁed by the two processes P, Q.
k , . . . , {un}rn
k , . . . , {vn}rn
k
TP ≈ TQ ⇒ [[P ]] ≈ [[Q]] (Lemma 13) It uses trace lifting: we
need to prove that a computational trace is, with an
overwhelming probability, an instance of a symbolic
trace.
For instance in the above IND-CPA game, we cheated a
little bit since the requests of the attacker were instances
of symbolic requests, while in a true IND-CPA game they
can be arbitrary bitstrings. This last step shows that it is
actually not cheating: it does not make a signiﬁcant diﬀer-
ence (actually it does not make any diﬀerence at all in an
IND-CPA game).
The two last implications are proved here in the context of
pairing and symmetric encryption only. However, we believe
that the use of computation trees and the way we get rid of
encryption, can be extended to other primitives.
6. COMPUTATION TREES
We ﬁrst deﬁne a general notion of trees that could serve to
design oracles: the main purpose is to lift static equivalence
(of frames) to trees, i.e.
in an adaptative setting. Trees
deﬁned by the protocols (processes) are special cases, as we
will see next. But we use the general deﬁnition in further
transformations of the oracles.
6.1 General Computation Trees
Let S = T (N ) be a set of labels, typically a pair 
of a pid and a term for a request u to the process i, or a
request to start a new process. For i = 1, 2, let φi = νnσi be
two frames. We write t ∈ φ1 if t = xσ1 for some x ∈ dom(σ1)
and φ1 ⊆ φ2 if xσ1 = xσ2 for all x ∈ dom(σ1).
Definition 5. A computation tree T is a mapping from
a preﬁx closed subset of S ∗ (Pos(T ), the positions of T ) to
pairs (P, φ) where P is a simple process and φ is a ground
frame over T (N ). If p ∈ Pos(T ) and T (p) = (P, φ), we write
φ(T, p) the frame φ. Moreover T must satisfy the following
conditions:
• for every positions p, q, if p > q, then φ(T, q) ⊆ φ(T, p)
• for every position p · t, t ∈ φ(T, p · t)
• for every positions p · t, p · u, if t =E u, then t = u.
This ensures that there is no two branches labeled with
the same (equivalent) message.
Such trees will be used in the next section to represent all
possible behaviors of the processes,
in a structured way.
Since we have unbounded replication, the trees need not
to be bounded in depth: there may be inﬁnite paths. They
may also be inﬁnitely branching, as, at any time, the possi-
ble attacker’s actions are unbounded
In this deﬁnition, positions need not to be closed lexico-
graphically. The deﬁnition of static equivalence ∼ is ex-
tended to computation trees. T |p is the sub-tree of T at
position p.
Definition 6. ∼ is the largest equivalence relation on
computation trees such that if T1 ∼ T2, then φ(T1, ǫ) ∼
φ(T2, ǫ) and there is an one-to-one mapping β from T (N )
to itself such that, for any length 1 position t of T1, T1|t ∼
T2|β(t).
Typically, requests sent by the adversary need not to be
identical, but must be equivalent. Then β is a mapping,
which depends on T1, T2, which associates the messages in
the labels of T1 with equivalent messages labeling T2.
6.2 Process computation trees
We organize all possible symbolic executions of a simple
process P in a tree TP . Each node of TP is labeled by (Q, φ)
where Q is the current state of the process and φ represents
the sequence of messages sent over the network by P so far.
Let P ≡ νn, νx. Q1kσ1k · · · kQN kσN kS be a simple pro-
cess where S = S1k · · · kSk is the composition of a ﬁnite
number of replicated processes Si and every Qi ∈ B(li, ni, xi)
is either 0 or a basic process cin(xi).Pi and σi is a ground
substitution whose domain contains only free variables of
Pi. Note that li is the pid of Qi. The process computation
tree TP is deﬁned as follows. The labeling and positions are
deﬁned by induction on the position length: TP (ǫ) = (P, id)
where id denotes the empty frame, and, for any p ∈ Pos(TP ),
let
TP (p) = (νnνx. Qp
1kσp
1 k · · · kQp
N kσp
N kS , νnσ)
where each Qp
Pos(TP ) if α =, Qp
j is either 0 or cin(xp
i 6≡ 0, νnσ ⊢ α and
j ).P p
j . Then q = p · α ∈
Qp
i
cin(α)
−−−→
cout(α1)···cout(αm)
−−−−−−−−−−−−→ Qq
i kσp
i k{xp
i 7→ α}
in which case
TP (p · α) = (νnνx.Qq
1kσq
1k · · · kQq