### 路由广播组件 BGP Speaker当 Felix配置了路由之后，接下来的问题就是，如何将路由信息，也即将"如何到达我这个节点，访问我这个节点上的容器"这些信息，广播出去。能想起来吗？这其实就是路由协议啊！路由协议就是将"我能到哪里，如何能到我"的信息广播给全网传出去，从而客户端可以一跳一跳地访问目标地址的。路由协议有很多种，Calico使用的是 BGP 协议。在 Calico 中，每个 Node 上运行一个软件 BIRD，作为 BGP 的客户端，或者叫作BGP Speaker，将"如何到达我这个 Node，访问我这个 Node上的容器"的路由信息广播出去。所有 Node 上的 BGP Speaker都互相建立连接，就形成了全互连的情况，这样每当路由有所变化的时候，所有节点就都能够收到了。
### 安全策略组件Calico 中还实现了灵活配置网络策略 NetworkPolicy，可以灵活配置两个容器通或者不通。这个怎么实现呢？![](Images/499b9f48d7130dabf33ffb02f85918c1.png){savepage-src="https://static001.geekbang.org/resource/image/1a/17/1a0ba797b9a0f0e32c9e561b97955917.jpg"}虚拟机中的安全组，是用 iptables 实现的。Calico 中也是用 iptables实现的。这个图里的内容是 iptables在内核处理网络包的过程中可以嵌入的处理点。Calico也是在这些点上设置相应的规则。![](Images/1b82608b577e84244bed39c03285034a.png){savepage-src="https://static001.geekbang.org/resource/image/d2/15/d27a1bf22f9b70696ca13abb6a655d15.jpg"}当网络包进入物理机上的时候，进入 PREOUTING 规则，这里面有一个规则是cali-fip-dnat，这是实现浮动 IP（Floating IP）的场景，主要将外网的 IP地址 dnat 为容器内的 IP 地址。在虚拟机场景下，路由器的网络 namespace里面有一个外网网卡上，也设置过这样一个 DNAT 规则。接下来可以根据路由判断，是到本地的，还是要转发出去的。如果是本地的，走 INPUT 规则，里面有个规则是 cali-wl-to-host，wl 的意思是workload，也即容器，也即这是用来判断从容器发到物理机的网络包是否符合规则的。这里面内嵌一个规则cali-from-wl-dispatch，也是匹配从容器来的包。如果有两个容器，则会有两个容器网卡，这里面内嵌有详细的规则"cali-fw-cali网卡 1"和"cali-fw-cali 网卡 2"，fw 就是 from workload，也就是匹配从容器1 来的网络包和从容器 2 来的网络包。如果是转发出去的，走 FORWARD 规则，里面有个规则cali-FORWARD。这里面分两种情况，一种是从容器里面发出来，转发到外面的；另一种是从外面发进来，转发到容器里面的。第一种情况匹配的规则仍然是 cali-from-wl-dispatch，也即 fromworkload。第二种情况匹配的规则是 cali-to-wl-dispatch，也即 toworkload。如果有两个容器，则会有两个容器网卡，在这里面内嵌有详细的规则"cali-tw-cali网卡 1"和"cali-tw-cali 网卡 2"，tw 就是 to workload，也就是匹配发往容器1 的网络包和发送到容器 2 的网络包。接下来是匹配 OUTPUT 规则，里面有 cali-OUTPUT。接下来是 POSTROUTING规则，里面有一个规则是 cali-fip-snat，也即发出去的时候，将容器网络 IP转换为浮动 IP 地址。在虚拟机场景下，路由器的网络 namespace里面有一个外网网卡上，也设置过这样一个 SNAT 规则。至此为止，Calico 的所有组件基本凑齐。来看看我汇总的图。![](Images/3c321352b149c27f97bc33b8185e8bc1.png){savepage-src="https://static001.geekbang.org/resource/image/df/b2/df8d92d84af55369055738283339d6b2.jpg"}
## 全连接复杂性与规模问题这里面还存在问题，就是 BGP 全连接的复杂性问题。你看刚才的例子里只有六个节点，BGP的互连已经如此复杂，如果节点数据再多，这种全互连的模式肯定不行，到时候都成蜘蛛网了。于是多出了一个组件BGP Route Reflector，它也是用 BIRD 实现的。有了它，BGP Speaker就不用全互连了，而是都直连它，它负责将全网的路由信息广播出去。可是问题来了，规模大了，大家都连它，它受得了吗？这个 BGP RouterReflector 会不会成为瓶颈呢？所以，肯定不能让一个 BGP Router Reflector管理所有的路由分发，而是应该有多个 BGP Router Reflector，每个 BGP RouterReflector 管一部分。多大算一部分呢？咱们讲述数据中心的时候，说服务器都是放在机架上的，每个机架上最顶端有个TOR交换机。那将机架上的机器连在一起，这样一个机架是不是可以作为一个单元，让一个BGP Router Reflector 来管理呢？如果要跨机架，如何进行通信呢？这就需要BGP Router Reflector也直接进行路由交换。它们之间的交换和一个机架之间的交换有什么关系吗？有没有觉得在这个场景下，一个机架就像一个数据中心，可以把它设置为一个AS，而 BGP Router Reflector 有点儿像数据中心的边界路由器。在一个 AS内部，也即服务器和 BGP Router Reflector之间使用的是数据中心内部的路由协议 iBGP，BGP Router Reflector之间使用的是数据中心之间的路由协议 eBGP。![](Images/efc9208a25ddf8d48669bfd63c9d3bd7.png){savepage-src="https://static001.geekbang.org/resource/image/f7/ff/f7e9467901ccb4b7e8039c53314244ff.jpg"}这个图中，一个机架上有多台机器，每台机器上面启动多个容器，每台机器上都有可以到达这些容器的路由。每台机器上都启动一个BGP Speaker，然后将这些路由规则上报到这个 Rack 上接入交换机的 BGP RouteReflector，将这些路由通过 iBGP 协议告知到接入交换机的三层路由功能。在接入交换机之间也建立 BGP 连接，相互告知路由，因而一个 Rack里面的路由可以告知另一个Rack。有多个核心或者汇聚交换机将接入交换机连接起来，如果核心和汇聚起二层互通的作用，则接入和接入之间之间交换路由即可。如果核心和汇聚交换机起三层路由的作用，则路由需要通过核心或者汇聚交换机进行告知。
## 跨网段访问问题上面的 Calico模式还有一个问题，就是跨网段问题，这里的跨网段是指物理机跨网段。前面我们说的那些逻辑成立的条件，是我们假设物理机可以作为路由器进行使用。例如物理机A 要告诉物理机 B，你要访问 172.17.8.0/24，下一跳是我192.168.100.100；同理，物理机 B 要告诉物理机 A，你要访问172.17.9.0/24，下一跳是我 192.168.100.101。之所以能够这样，是因为物理机 A 和物理机 B是同一个网段的，是连接在同一个交换机上的。那如果物理机 A 和物理机 B不是在同一个网段呢？![](Images/e776480f26e731cad6bf1e468e19cf76.png){savepage-src="https://static001.geekbang.org/resource/image/88/84/88a1817b32c3c364fbbdf50b05d49e84.jpg"}例如，物理机 A 的网段是 192.168.100.100/24，物理机 B 的网段是192.168.200.101/24，这样两台机器就不能通过二层交换机连接起来了，需要在中间放一台路由器，做一次路由转发，才能跨网段访问。本来物理机 A 要告诉物理机 B，你要访问 172.17.8.0/24，下一跳是我192.168.100.100的，但是中间多了一台路由器，下一跳不是我了，而是中间的这台路由器了，这台路由器的再下一跳，才是我。这样之前的逻辑就不成立了。我们看刚才那张图的下半部分。物理机 B 上的容器要访问物理机 A上的容器，第一跳就是物理机 B，IP 为192.168.200.101，第二跳是中间的物理路由器右面的网口，IP 为192.168.200.1，第三跳才是物理机 A，IP 为 192.168.100.100。这是咱们通过拓扑图看到的，关键问题是，在系统中物理机 A 如何告诉物理机B，怎么让它才能到我这里？物理机 A 根本不可能知道从物理机 B出来之后的下一跳是谁，况且现在只是中间隔着一个路由器这种简单的情况，如果隔着多个路由器呢？谁能把这一串的路径告诉物理机B 呢？我们能想到的第一种方式是，让中间所有的路由器都来适配Calico。本来它们互相告知路由，只互相告知物理机的，现在还要告知容器的网段。这在大部分情况下，是不可能的。第二种方式，还是在物理机 A 和物理机 B之间打一个隧道，这个隧道有两个端点，在端点上进行封装，将容器的 IP作为乘客协议放在隧道里面，而物理主机的 IP放在外面作为承载协议。这样不管外层的 IP通过传统的物理网络，走多少跳到达目标物理机，从隧道两端看起来，物理机 A的下一跳就是物理机 B，这样前面的逻辑才能成立。这就是 Calico 的**IPIP 模式**。使用了 IPIP 模式之后，在物理机 A上，我们能看到这样的路由表：    172.17.8.2 dev veth1 scope link 172.17.8.3 dev veth2 scope link 172.17.9.0/24 via 192.168.200.101 dev tun0 proto bird onlink这和原来模式的区别在于，下一跳不再是同一个网段的物理机 B 了，IP 为192.168.200.101，并且不是从 eth0 跳，而是建立一个隧道的端点tun0，从这里才是下一跳。如果我们在容器 A1 里面的 172.17.8.2，去 ping 容器 B1 里面的172.17.9.2，首先会到物理机 A。在物理机 A 上根据上面的规则，会转发给tun0，并在这里对包做封装：-   内层源 IP 为 172.17.8.2；-   内层目标 IP 为 172.17.9.2；-   外层源 IP 为 192.168.100.100；-   外层目标 IP 为 192.168.200.101。将这个包从 eth0 发出去，在物理网络上会使用外层的 IP进行路由，最终到达物理机 B。在物理机 B 上，tun0 会解封装，将内层的源 IP和目标 IP 拿出来，转发给相应的容器。
## 小结好了，这一节就到这里，我们来总结一下。-   Calico    推荐使用物理机作为路由器的模式，这种模式没有虚拟化开销，性能比较高。-   Calico 的主要组件包括路由、iptables 的配置组件 Felix、路由广播组件    BGP Speaker，以及大规模场景下的 BGP Route Reflector。-   为解决跨网段的问题，Calico 还有一种 IPIP    模式，也即通过打隧道的方式，从隧道端点来看，将本来不是邻居的两台机器，变成相邻的机器。最后，给你留两个思考题：1.  将 Calico 部署在公有云上的时候，经常会选择使用 IPIP    模式，你知道这是为什么吗？2.  容器是用来部署微服务的，微服务之间的通信，除了网络要互通，还需要高效的传输信息，例如下单的商品、价格、数量、支付的钱等等，这些要通过什么样的协议呢？我们的专栏更新到第 31讲，不知你掌握得如何？每节课后我留的思考题，你都有没有认真思考，并在留言区写下答案呢？我会从**已发布的文章中选出一批认真留言的同学**，赠送[学习奖励礼券]{.orange}和我整理的[独家网络协议知识图谱]{.orange}。欢迎你留言和我讨论。趣谈网络协议，我们下期见！![](Images/55417b60e9c8040807daf07e6bd9cb4b.png){savepage-src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg"}
# 第32讲 \| RPC协议综述：远在天边，近在眼前前面我们讲了容器网络如何实现跨主机互通，以及微服务之间的相互调用。![](Images/c78c1e13c551fa0acf298c23f9bcd3c1.png){savepage-src="https://static001.geekbang.org/resource/image/06/65/06ba300a78aef37b9d190aba61c37865.jpg"}网络是打通了，那服务之间的互相调用，该怎么实现呢？你可能说，咱不是学过Socket。服务之间分调用方和被调用方，我们就建立一个 TCP 或者 UDP的连接，不就可以通信了？![](Images/3b83886c578a5ce4b431739a53c66b6a.png){savepage-src="https://static001.geekbang.org/resource/image/77/92/77d5eeb659d5347874bda5e8f711f692.jpg"}你仔细想一下，这事儿没这么简单。我们就拿最简单的场景，客户端调用一个加法函数，将两个整数加起来，返回它们的和。如果放在本地调用，那是简单的不能再简单了，只要稍微学过一种编程语言，三下五除二就搞定了。但是一旦变成了远程调用，门槛一下子就上去了。首先你要会 Socket 编程，至少先要把咱们这门网络协议课学一下，然后再看 N本砖头厚的 Socket 程序设计的书，学会咱们学过的几种 Socket程序设计的模型。这就使得本来大学毕业就能干的一项工作，变成了一件五年工作经验都不一定干好的工作，而且，搞定了Socket 程序设计，才是万里长征的第一步。后面还有很多问题呢！