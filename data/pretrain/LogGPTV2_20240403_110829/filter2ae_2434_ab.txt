示例中在栈中伪造了一个0x20大小的堆（伪造堆头如下图选中部分，其中a=0x405000，&stack_var=0x00007fffffffdfb0），此时堆a的fd指向&stack_var，即fastbin:a->stack_var，此时第二次申请不超过0x18大小的堆（64位系统，跟申请堆时字节对齐有关，返回的堆的大小会被转化成满足条件的最小2*size_sz的倍数，最大0x10+8，8字节可占用下一个堆的prev_size）即可返回栈地址处的伪造堆。
#### 1.3 fastbin_dup_consolidate
fastbin
attack构成doublefree的一个示例。原理是利用申请一次largebin大小的堆会将fastbin的堆进行合并进入unsortedbin的处理流程，此时再次free
fastbin中的堆会绕过free时对fastbin链表头节点的检查进而构成一次doublefree。
从下图free的流程中我们可以看出free时只会检查释放fastbin大小的堆时被释放的堆是否和fastbin的头结点是否一致，而在申请0x400的largechunk时，fastbin链表非空，fastbin中的堆会进行合并并且进入unsortedbin的处理流程，在unsortedbin的处理流程中符合fastbin大小的堆会被放入smallbin，这样就绕过了free时对fastbin头结点的检查，从而可以构成一次对fastbin大小的堆的doublefree。
#### 1.4 unsafe_unlink
堆可以溢出到下一个堆的size域且存在一个指向堆的指针时堆溢出的一种利用方式。
Unsafe
unlink利用的前提是可以溢出到下一个堆的size域，利用的大致思路是在chunk0构造fakechunk且fakechunk可以绕过unlink双向链表断链的检查，修改chunk1的pre_size使之等于fakechunk的大小，修改chunk1中size域的prev
inuse位为0以便free(chunk1)时检查前后向堆是否空闲时（这里是后向堆，即物理低地址）触发unlink双向链表断链构成一次任意地址写。下面看一下unlink的具体细节和原理。
示例中首先申请了两个0x80大小的堆chunk0和chunk1（非fastbin大小，因为fastbin大小的堆为了避免合并pre_inuse总是为1），然后在chunk0中构造fake_chunk
需要注意的是，我们构造的fake chunk的起点是chunk0的数据部分即fd，fake chunk的prev
size和size域正常赋值即可（最新的libc加入了cur_chunk’size=next_chunk’s prev_size），fake
chunk中关键的部分是fake data，这一部分要绕过unlink双向链表断链的检查，即fd->bk=p&&bk->fd=p
chunk的结构体如下
所以由结构体的寻址方式可得
(fd->bk=fd+3* size_t)=p
(bk->fd=bk+2* size_t)=p
所以可得
fd=p-3* size_t
bk=p-2* size_t
即fakechunk中fd和bk域如上构造即可绕过unlink双向链表的断链检查。
构造完fakechunk还需要修改下chunk1的prevsize和size的数据，
首先是prevsize要修改成fakechunk的大小（包含堆头，原因是glibc寻找下一个堆的宏如下，即将当前堆偏移size的数据视为下一个堆）
chunk1
size部分的inuse位要置0，即标识物理相邻低地址堆为空闲状态（这也是unlink无法使用fastbin大小的堆的原因，fastbin大小的堆为了减少堆合并的次数inuse位总是置1）
最后构造的fakechunk+chunk1部分数据如下，chunk0堆头0x405000，fakechunk堆头0x405010，chunk1堆头0x405090，图中选中部分为fakechunk
其中fakechunk的fd要使用指向堆节点的指针（如指向该节点的全局变量，非堆地址）的原因是unlink源码中传入的第二个参数是struct
malloc_chunk * p。
下面分析下unsafeunlink是如何导致任意地址写的。阅读源码可以发现smallbin范围内非fastbin范围的堆在unlink时只检查了双向链表的完整性，然后执行了双向链表摘除节点的操作。
断链的过程
fd->bk=bk 即(fd->bk=p)=(bk=p-2* size_t)
bk->fd=fd 即(bk->fd=p)=(fd=p-3* size_t)
最终相当于
p=p-3* size_t
即获得了两个相等的指针（struct malloc_chunk *
p），试想如果此时我们可以修改一个指针指向的地址同时可以修改另一个指针指向的内容不就可以构成一次任意地址写了吗？巧的是(;p)我们恰好可以达到这样的效果。
此时我们修改fake_chunk[3]为要写的地址，修改fake_chunk[0]为要写的地址的内容即可。原因是fake_chunk[3]-3*size_t=fake_chunk，这里相当于给fake_chunk指向一个新的地址；fake_chunk[0]访问的是&fake_chunk[0]地址处的值，即上一步修改的地址处的内容。这样就构成了一次任意地址写^.^
#### 1.5 house_of_spirit
利用fastbin范围的堆释放时粗糙的检查可以在任意地址处伪造fastbin范围fakechunk进而返回fakechunk的一种利用方式。思路是在指定地址处伪造fastbin范围的fakechunk，释放掉伪造的fakechunk，再次申请释放掉的fakechunk大小的堆即可得到fakechunk。
其中fastbin范围的堆释放时的检查如下图所示，
我们构造的fakechunk只需要绕过free时的检查即可：
  1. 2*size_sz
由于glibc在返回用户申请的堆时不恰当的更新堆的presize域和错误的计算nextchunk的位置可以导致一次堆重叠。
方法是先申请堆然后释放掉中间位置的一个堆bchunk（假设堆的大小都如图所示），假设存在一个off by
null的漏洞，由于前一个堆是占用状态时prevsize域用来存储前一个堆的数据，这样我们可以从achunk溢出到bchunk的size域最低位将其置0。
此时申请一个0x100大小的堆会返回释放掉的bchunk位置的堆。原因是在申请一个smallbin且非fastbin范围的堆时会检查smallbin是否为空，本例中smallbin为空则执行smallbin的初始化过程，即将可能的fastbin中的堆进行合并进入unsortedbin的处理流程，申请的堆的大小是smallbin范围，此时会取largebin头结点的一个堆进行切割返回（同样地为了减少内存碎片，largebin的堆从大到小排序）。这里largebin中只含一个0x200大小的堆，则直接对其进行切割然后返回给用户。
然后再次申请一个0x80大小的堆。原因是0x100+0x80+两个堆头=0x200使之结束的位置正好落于cchunk
这时free(b1)、free(c)释放掉两个堆，由于nextchunk即cchunk的preinuse为0会触发前向合并（向物理高地址）过程。原因是fake了一个cchunk的presize，系统修改的是我们的fake
presize，即下图的0xf0，系统依然认为bchunk的位置有一个0x210的fakechunk。
此时再次申请一个0x300大小的堆，由于合并后bchunk和cchunk的大小为0x300，系统会返回合并后的bchunk。又由于此时b2chunk没有被释放处于占用态，b2chunk位于合并的bchunk内，此时构成一次堆重叠。
#### 1.7 house_of_lore
利用伪造smallbin链表来最终达到一次任意地址分配内存的效果。前提是可以在要分配的地址处伪造堆（修改结构体中fd、bk的指向），且可以修改victim堆（被释放的smallbin堆）的bk指针。
方法是在要分配的内存地址（如栈地址）处构造一个fake smallbin chunk链，使之如下图所示。
然后申请一个堆防止释放victim的时候合并到topchunk，释放掉victim，此例中victim会进入fastbin链表。
再次申请一个largechunk，触发fastbin的合并过程并使fastbin的堆进入unsortedbin的处理流程，victim处于smallbin的范围最终被链入smallbin头结点。而由于我们事先构造了如上的fake