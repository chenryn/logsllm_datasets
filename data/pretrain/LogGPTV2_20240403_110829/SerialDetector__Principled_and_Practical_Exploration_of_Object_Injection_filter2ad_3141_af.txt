5,647,128
4/
39,927
55/
8,329,428
10,742,006
326/
370/
9,863,890
0
1
-
0
0
2
2
1
TABLE II: Evaluation results for the real-world applications
CVE-2019-0604 in SharePoint Server has
two ex-
ploitable entry points in different assemblies [49]. SerialDe-
tector ﬁnds that both entry points and many others reach
XmlSerializer::Deserialize call. An outlier
is Mi-
crosoft.SharePoint.dll with 6,283 detected entry points. The
main cause of such high complexity is the tight coupling
of code in SharePoint Server and its main assembly Mi-
crosoft.SharePoint.dll, as well as our over-approximation of
virtual calls. For each vulnerable entry point, we followed
the approach described in Section V to generate and validate
the exploits. In our experiments, we changed the payload as
reported in Table II. We further clarify the practical details of
threat models and exploit changes in Section VII-A.
Performance. The analysis is quite fast for such a large
project as the .NET Framework. The average time of the
analysis for a single serializer is 47.4 sec. This shows the ad-
vantages of our modular inter-procedural analysis. We also ex-
perimented with a whole-program dataﬂow analysis algorithm
which did not terminate within a limit of hours. Our ﬂow-
insensitive approach reduces the size of the heap graph. This
enables SerialDetector to apply summaries and merge locations
faster, thus improving the overall analysis time. Another factor
improving scalability is the usage of the lightweight context-
sensitive analysis. Earlier versions of SerialDetector performed
the analysis of virtual calls in a conservative way, analyzing
all
implementations of a virtual method and applying the
summaries at call site. This approach generated correct patterns
for very few serializers (e.g., BinaryFormatter), but
it did
not terminate for many others. The implementation of the
type-sensitive analysis improved performance for all tested
serializers.
False Positives. We also ﬁnd attack triggers that are never
called for a tainted object. The root cause for these false
positives is ﬂow-insensitivity of the data ﬂow analysis. The
ﬂow-insensitive approach allows us to control the heap size at
the expense of the precision of analysis. On the other hand,
our results show that the number of patterns that should be
reviewed manually by a security analyst is not overwhelming.
VII.
IN-DEPTH ANALYSIS OF AZURE DEVOPS SERVER
We evaluate SerialDetector on production software to val-
idate its usefulness in practical scenarios. We choose Azure
DevOps Server as the main target for our investigations
mainly due to its complexity and diversity of threat models.
Section VII-A provides a brief summary of Azure DevOps
and Section VII-B provides a thorough overview of the threat
13
Fig. 9: First threat model
models that we explored. Section VII-C describes process of
using SerialDetector to discover unknown vulnerabilities.
A. Microsoft Azure DevOps
The Azure DevOps Server (ADS) is a Microsoft product
that provides version control, reporting, requirements manage-
ment, project management, automated builds, lab management,
testing, and release management capabilities. These features
require integration with various data formats and serializers,
thus making it an excellent target for ﬁnding OIVs. ADS
hosts multiple projects across different organizations. Projects
are grouped into isolated collections and the system provides
functionalities to set up a project and its collections, as
well as to manage users in a ﬂexible manner. Thereby, a
vulnerability that exposes high privileges in one project may
lead to information disclosure of another project. ADS stores
conﬁdential information that is intellectual property (e.g., the
source code of products), hence a disclosure has high impact.
ADS consists of many services exchanging information
with each other, for example, the main web app, crawler and
indexer services. Such system design implies complex threat
models in which even internal data can be untrusted. The server
has many entry points such as request handlers, documented
REST APIs, plugin APIs, and internal and undocumented API.
After analyzing different threat models, we use SerialDetector
to automatically determine attacker-controlled entry points
leading to OIVs. We then scrutinize these entry points to ﬁnd
RCE exploits using automated and manual analysis.
B. Threat models
We ﬁrst consider the simple threat model of a web applica-
tion running under an OS account. ADS uses the NETWORK
SERVICE account in Windows by default. The code executing
in the web application process has restrictions according to
the OS account permissions. The web application usually has
access to different services into the internal network, e.g.,
indexing or caching services that handle the application data.
The application may also have access to a database with
OS account permissions or speciﬁc credentials. Thereby, any
code that executes into the web application process may have
access to the database. Users communicate only with the web
application in the demilitarized zone (DMZ) and do not have
access to the internal network.
Figure 9 illustrates the expected information ﬂows between
services and users via black arrows. Any user can act as
Fig. 10: Second threat model
an attacker and send payloads to the web application. If the
application has an entry point that receives user data and
subsequently uses code that is subject to OIVs, we can access
any resources available to the OS account. This is depicted by
OS Account trust boundaries in Figure 9. The attacker may
send a payload to a vulnerable application directly (arrow
1) and get access to local ﬁles (arrow 2c), services into the
internal network (arrows 2a, 2b) or any data from the web
application memory. Example 1 illustrates this scenario.
Our second threat model addresses the question: Can an
OIV be exploited if it processes data from internal services or
ﬁles only? The answer depends on other components of the
system. Figure 10 presents the threat model for such cases.
An attacker may already be inside DMZ network and execute
code with very restricted privileges. For example, the attacker’s
process may have access only to the shared ﬁles originating
from the web application. If these ﬁles are processed by code
subject to OIVs, the attacker can transfer the payload through
ﬁles (arrow 1a), escalate privileges to the web application
account (arrow 2a), and ultimately gain access to all resources
inside the OS Account area in Figure 10.
Another scenario includes remote attacks through chains
of vulnerabilities in other services. A service that receives
untrusted user data may have vulnerabilities such as Server-
Side Request Forgery (SSRF) enabling an attacker to deceive
the server-side application to make requests to an arbitrary
server, including internal servers. A service may also have
insufﬁcient data validation and allow to store a payload to an
internal service that subsequently makes this data available to
code vulnerable to OIVs. For example, an attacker may abuse
a data validation vulnerability in the Agent service (arrow 1b)
and send the payload to the Internal Service (arrow 2b). The
Internal Service may index the data and send the payload to
an application with OIVs (arrow 3b). As a result, the attacker
will gain access to all resources inside the OS Account area.
Our third threat model (Figure 11) targets scenarios where
only a user with administrator privileges can get access to
code subject to OIVs. ADS exposes web applications with a
rich user management subsystem enabling the owner to create
isolated projects with their own administrator accounts. We
14
OS Account  UserWeb AppOIVDatabaseInternalService 2a  2b  2c LocalFilesDMZ NetworkInternal Network 1 OS AccountWeb AppAgentServiceOS Restricted Account 2b  3b SharedFilesV 1a  2a  1b OIV  UserDatabaseInternalServiceDMZ NetworkInternal NetworkSharedFilesinstantiate objects for a malicious gadget and execute a pay-
load. However, the BinaryFormatter handles data from local
storage which an attacker cannot control directly. Following
the threat model in Figure 10, SerialDetector found that one
of the methods that call BinaryFormatter is located in the
code of the Search Engine. The Search Engine computes
indexes of text data like source ﬁles and Wiki pages to enable
quick search of information. This service is a part of Web
App in the threat model and is not accessible from outside.
The indexes represent binary formatted data managed by the
Storage Service. The Storage Service allows to get indexes
from other components of the system and makes them available
to the Search Engine. This corresponds to Internal Service in
the threat model. A separate service Crawler tracks changes
in the Git repository, parses the changed text ﬁles according
to their format, and sends the resulting data to the Storage
Service. The data in the Git repository is untrusted because
users with minimal privileges usually have access to some
repositories. This user-controlled data corresponds to User
node in Figure 10. Hence, the security of the system relies on
proper validation of the data from Git to the Crawler Service.
We analyzed the validation algorithms of the Crawler
Service and identiﬁed the control ﬂow path from the method
that pulls updated Wiki pages from Git, parses the Markdown
format of Wiki pages, and stores the parsed data in indexes. To
exploit this path, we generated a payload with SerialDetector,
stored the payload to the Wiki page, and waited for the Crawler
to transfer the payload to indexes and for the Search Engine
to deserialize the data using BinaryFormatter. However, the
exploitation failed, hence we attached a debugger to the Agent
Service to identify the instructions that changed the payload.
The Crawler ﬁrst validates that the Wiki page is a text
document. It uploads the ﬁle as a byte array and veriﬁes that
the content uses Unicode encoding by checking the ﬁrst bytes.
The payload for BinaryFormatter always starts with the byte
0x00 and the next 4 bytes contain an integer value of the
ID of the root serialized object. The Crawler accepts the one
sequence of the ﬁrst bytes of the header that starts with 0x00 as
Unicode format, and it is 0x0000FEFF. Thereby, we changed
the root ID of the payload to get the header to correspond
to Unicode format, tested a new payload for BinaryFormatter
using SerialDetector, and managed to bypass this validation.
We run the exploit using the new payload and failed again.
Following our human-in-the-loop approach, we started a new
manual iteration of the “investigating, ﬁxing and testing” loop.
The debugger revealed that the Crawler Service parses the Wiki
page as Markdown document and stores the parsed data to
the index. Because we use the binary data instead of a valid
Markdown document, the parser rejected storing the document
to the indexes. However, when the parser throws an exception,
the Crawler Service stores the content of Wiki page to the
index as is. This allows us to transfer the payload to the
BinaryFormatter via the indexes. We found a bug in Markdown
parser which throws an exception for certain incorrect strings.
We then added the string to the original payload, created and
tested the second version of the payload with SerialDetector,
and run the exploit on ADS successfully. The attack propagates
the payload from the attacker-controlled Git repository to
the input of the BinaryFormatter using Crawler and Storage
services, as depicted by the path 1b, 2b, 3b in Figure 10.
Fig. 11: Third threat model
depict this setting via the trust boundaries Admin Project A and
Admin Project B. This is a typical scenario in cloud-based web
applications where a user can register a separate project and
become the administrator of that project. A single application
process often serves several isolated projects. In this case, an
attacker can register an administrator account for their own
project and exploit an OIV directly (arrow 1a) to gain access
to all resources of OS Account including the database and the
data of any other projects (arrow 2a).
If the attacker has access only to a subset of features, e.g.,
a user with minimal privileges, they can exploit a chain of a
client-side and object injection vulnerabilities to carry out the
attack. For example, the attacker can exploit an XSS vulnera-
bility to run malicious JavaScript code into the administrator’s
browser and use it to relay the malicious payload to OIV code
that is available only to the administrator (path 1b, 2b, 3b, 4b).
C. SerialDetector in action
We used SerialDetector to analyze the Azure DevOps
Server against OIVs. We described templates of OIV in inse-
cure serializers and run the exploitation phase of SerialDetector
to determine which insecure serializers ADS uses. The tool
analyzed the codebase of the application and built the Call
Graph from entry points to the given insecure methods. The
analyzer handled 422 assemblies that contain 630,251 methods
and 11,258,350 instructions. This analysis was completed
in 174 sec. Thereby, we detected an usage of 7 serializers
in the codebase of ADS: BinaryFormatter, DataContractSe-
rializer, JavaScriptSerializer, Newtonsoft.Json, XamlReader,
XmlSerializer, YamlDotNet. We have checked method calls of
DataContractSerializer, JavaScriptSerializer, Newtonsoft.Json,
XamlReader and XmlSerializer, and concluded that it is being
used in the safe mode for untrusted data.
RCE via BinaryFormatter. The BinaryFormatter matched
the patterns generated by SerialDetector, hence we could
15
 Web AppOS Account DatabaseAdmin Project BAdmin Project AUserFeaturesUserFeaturesUserFeaturesAdminFeatures 2b  1b Organization ADataUserData User AXSS 3b  4bUserDataAdminFeaturesOrganization BData Admin BUserData User BOIV 1a 2a Admin ADMZ NetworkOIVWe have reported the vulnerability to Microsoft following
the coordinated disclosure principles. Microsoft assigned CVE-
2019-1306 and released a patch to address the vulnerability.
The ﬁx uses a look-ahead approach [16] to control class
loading, depending on the type name. The .NET Framework
provides the class SerializationBinder that allows to use
the look-ahead approach by conﬁguring BinaryFormatter with
a custom implementation of the binder. Thereby, a developer
can create only safe types during deserialization and avoid
instantiating unsafe types. The ﬁxed version ﬁlters out the
types via a whitelist which prevents the OIV exploitation.
RCE via YamlDotNet. ADS uses the YAML format
for describing pipelines to automatically build and test the
code of projects. The YAML pipeline conﬁguration ﬁle may
be stored in the source code repository of a project. ADS
uploads the conﬁguration ﬁle from the repository, deserializes
it, and queues a build task to the Build Agent. The agent
performs building and testing of the code from the repository
following the YAML conﬁguration ﬁle. For security reasons,
the documentation recommends to run the agent in an isolated
environment. Thus, code execution vulnerabilities during the
build and test process are not directly exploitable in a typical
conﬁguration. However, the Web Application of ADS performs
deserialization of the YAML ﬁle before running the agent. This
boosts the impact of code execution in the Web Application to
affect the entire system. For instance, an attacker can escalate
to privileges of the OS Account running the Web Application.
We used SerialDetector to build the call graph of method
calls that reach the YamlDotNet deserialization methods. By
examining the entry points of the call graph, we found that the
public Web API allows to run a build process using the YAML
conﬁguration ﬁle. We generated a payload using SerialDetector
and ran the build process with our payload as the build
conﬁguration. Upon failure of our ﬁrst attempt, we started
the application debugging to identify a conditional statement
causing the failure. The build conﬁguration handler required
small changes in the payload to pass it to the serializer. We
just added the string --- as the ﬁrst and the last payload lines.
However, YAML-based pipelines were a new experimental
feature at the moment and they were disabled by default. The
feature can be enabled by the administrator locally on the
machine. We also found an undocumented Web API to enable
the feature remotely, but such request requires administrator
privileges in ADS. This scenario corresponds to the threat
model in Figure 11. One ADS instance supports few project
collections with different user roles. However, the administra-
tor of one collection may not have access to another collection.
If the user with administrator privileges exploits the OIV and
triggers an RCE, this user can get access to the resources and
data of all collections. The path 1a, 2a shows this attack.
We demonstrated higher impact of the YamlDotNet OIV
by looking for XSS vulnerabilities. We found two XSSs using
static and manual analysis. The ﬁrst one can be exploited when
the victim opens a PDF ﬁle from the source code repository
using the ADS web interface. We use a weakness of Internet
Explorer to execute scripts embedded into PDF ﬁles (now this
is also ﬁxed). Thereby, an attacker needs to prepare a malicious
PDF ﬁle, upload it to the repository, and craft the link to the
PDF ﬁle using the viewer of ADS. When the administrator
opens this link in Internet Explorer, the embedded script sends
requests with administrator privileges to ADS triggering the
deserialization of the malicious YAML ﬁle. Thus, the attacker
executes an RCE attack on the target ADS with minimal
privileges (i.e., only access to the source code repository).
The second XSS targets a victim that opens a page with
the test description. ADS uses the Test hub feature for tracking
the manual testing of applications. It provides three main types
of test management artifacts: test plans, test suites, and test
cases. The test case description ﬁeld had insufﬁcient validation
and sanitization of the input text. The attacker may inject
JavaScript in the description ﬁeld and get a stored XSS on
the Test Case page. When the administrator opens this page,
the JavaScript code is executed in the administrator’s browser
allowing for requests to Web API with administrator privileges.
We exploited the vulnerability similarly to the RCE on the
server. The path 1b, 2b, 3b, 4b illustrates the attack.
We reported these vulnerabilities to Microsoft following
the coordinated disclosure principles. Microsoft assigned CVE-
2019-0866 and CVE-2019-0872 for each vulnerable attack
chain and ﬁxed it. The XSS vulnerabilities were ﬁxed by
adding additional validation to the web page and by requiring
users to download the PDF document instead of opening it
in the browser. To prevent the OIV exploitation, Microsoft
implemented their own lightweight YAML serializer using a
parser from the YamlDotNet. This serializer does not allow
to instantiate an object based on the type of information from
the ﬁle. It deserializes only a small predeﬁned subset of types
which prevents the composition of a malicious gadget.
VIII. RELATED WORKS
This section discusses related works targeting object injec-
tion vulnerabilities and injection vulnerabilities.
Object Injection Vulnerabilities. The closest related re-
search is the work of Dahse et al. [11], [13], which implements
static analysis to systematically detect gadgets in common PHP
applications. Like us, they implement static taint analysis to
detect exploitable vulnerabilities. The key difference is that
SerialDetector’s analysis operates at
to
discover new OIV patterns, while Dahse et al. target PHP