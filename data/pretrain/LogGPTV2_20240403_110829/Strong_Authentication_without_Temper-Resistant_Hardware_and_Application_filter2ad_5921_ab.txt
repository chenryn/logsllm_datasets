the “randomize-then-prove” paradigm ﬁrstly randomizes a
credential and then presents it with zero-knowledge proofs,
and has been used for anonymous credential protocols [24],
[11], [19]. It does not reveal the knowledge of credential
and thus resists ofﬂine attacks.
Transform PBC to publicly-veriﬁable. Holder-of-key asser-
tion mechanisms require the user to prove its possession of
a secret to any RP, which is not a problem for asymmetric
primitives such as digital signature schemes since they are
publicly-veriﬁable. However, this seems to contradict the pro-
posed scheme, which is designated-veriﬁable. We solve this
dilemma as follows:
• We use the IdP (i.e., designated veriﬁer) as a “converter” that
transforms our scheme to be publicly-veriﬁable. It provides
RPs with information that is necessary for verifying the
authentication tokens generated by users. To prevent this
technique from being abused to perform off-line attacks, we
require that the IdP must authenticate the user ﬁrst, and limit
the effect of a transformation within one session.
We also consider a scenario that the user authenticates to
RPs using IdP-managed unrelated pseudonyms, for preventing
the user’s activities from tracking or proﬁling when these RPs
collude. However, the privacy goal is hard to be achieved when
holder-of-key assertions are adopted, since RPs can associate
the same user with the references of keys.
• We provide an option to convert the scheme to be public-
veriﬁable while preserving the privacy of users, which
enables the user to prove the possession of the credential to
the RP without revealing its identity. Any RP can verify the
holder-of-key assertions without knowing the references to
original credentials (i.e., user identiﬁers), which avoids the
user from being linked across multiple RPs through holder-
of-key assertions.
C. Related Work
A series of schemes have been proposed to address
the problem of large-scale credential leakage in centralized
storage of shared credentials. Several password hardening
schemes [27], [52], [42] have been proposed to strengthen the
username-password authentication for web service providers,
where an external crypto server is adopted to carry out cer-
tain cryptographic operations. Furthermore, hardware security
modules (e.g., Intel SGX) have also been utilized at server
side to harden the storage of credentials by protecting the salt
values or secret keys [41], [18].
To prevent phishing attacks, many Multi-Factor Authenti-
cation (MFA) mechanisms have been designed [59], [40], [35],
3
and deployed in practice (e.g., The FIDO Universal 2nd Factor
(U2F) Protocol [57]). These schemes use dedicated devices
such as mobile phones and FIDO U2F keys to perform the
2nd factor authentication, and their security and usability thus
rely on these devices. The 2nd authentication factor will lose
once the device is broken or lost, and may also be occupied
by the attacker once the device is stolen or breached.
Password hardening and MFA techniques improve the
username-password authentication, but do not change the
authentication mechanism itself (e.g., the credentials are still
transferred explicitly from claimer to veriﬁer) which makes
them different from the approaches for strong authentication.
Moreover, Pass2Sign [20] enables the user to sign mes-
sages with the help of a server using its password. A Pass2Sign
server stores salted hashed values of users’ passwords, and
the corresponding salt values are stored at user end devices.
For authentication, the user calculates the hash value of its
password, the salt and a global query identiﬁer, encrypts the
hashed value with the server’s public key and sends it to
the server. However, Pass2Sign does not consider the threat
scenario that attackers could get authentication tokens (e.g.,
through phishing attacks). That
is, an attacker could ﬁrst
capture the hashed values calculated by the users by disguising
as the server via providing the user with the public key of its
own, and then steal the salt value stored at user end device.
After that, it could obtain the password via ofﬂine attacks.
II. PRELIMINARIES
Notation. Throughout this paper, we use λ to denote the
security parameter, and [n] to denote the set {1, . . . , n}. The
$← S denotes that x is sampled uniformly at random
notation x
from a set S. For an algorithm A, y ← A(x) denotes the
process that runs A on input x and obtains y as output. We say
that a function f : N → [0, 1] is negligible if for any positive c,
we have f (λ) < 1/λc for sufﬁcient large λ. For simplicity, we
use negl to denote an unspeciﬁed negligible function. Let G be
a group of prime order p generated by g, and G∗ denote G\{1}
where 1 is the identity element of G. Finally, [M ]pw denotes
the ciphertext on a message M encrypted with a password pw.
A. Cryptographic Assumptions
We recall two intractability assumptions in G.
Deﬁnition 1: (q-SDH)
the q-Strong
Difﬁe-Hellman (q-SDH) assumption holds in group G, if for
all Probabilistic Polynomial Time (PPT) adversaries A such
that
[15] We say that
AdvSDHG
$← Z∗
p : A(g, gx, ..., gxq
def= Pr[x
< negl(λ), where c ∈ Zp\{−x}.
) = (c, g1/(x+c))]
We write AdvSDHG (t, q) = maxA{AdvSDHG (A)}, where the
maximum is taken over all adversaries of time complexity at
most t and obtaining q + 1 group elements.
Deﬁnition 2: (q-DDHI) [16] We say that the q-Decisional
Difﬁe-Hellman Inversion (q-DDHI) assumption holds in group
4
G, if for all PPT adversaries such that
AdvDDHIG
def=
p : A(g, gx, ..., gxq
p, U
$← G∗ : A(g, gx, ..., gxq
, g1/x) = 1]−
(cid:12)(cid:12)(cid:12)Pr[x
$← Z∗
$← Z∗
< negl(λ)
Pr[x
(cid:12)(cid:12)(cid:12)
, U ) = 1]
We write AdvDDHIG
(A)} where the
maximum is taken over all adversaries of time complexity at
most t and obtaining q + 2 group elements.
(t, q) = maxA{AdvDDHIG
B. Non-Interactive Zero-Knowledge Proofs
Non-Interactive Zero-Knowledge Proofs (NIZKs) enable a
prover to prove that a statement x is in a given NP language
L in a zero-knowledge way, where L is deﬁned by an NP
relation R, i.e., L = {x|∃w s.t. R(x, w) = 1} and w is
called a witness for x.
Signature proofs of knowledge (SPKs) [23] are NIZK
proofs constructed by using the Fiat-Shamir heuristic [28] to
transform Sigma protocols in the random oracle model [13].
When referring to the SPKs on proving knowledge of discrete
logarithms and statements about them, we will follow the nota-
tion introduced by Camenisch et al. [21] to abstract the SPKs.
For example, π ← SPK{(a) : ga = u}(m) denotes a signature
proof of knowledge on proving knowledge of a witness a
such that u = ga, which signs a message m and outputs a
proof π on statement x = (g, u). Let VerifySPK((g, u), m, π)
denote the veriﬁcation algorithm of SPK, which outputs 1 if
π is valid on m w.r.t. a statement (g, u) and 0 otherwise. The
signature proofs of knowledge are zero-knowledge, sound and
knowledge extractable in the random oracle model [49].
Security Deﬁnitions for NIZK. Informally, an NIZK system
Π is said to be unbounded zero-knowledge if there exists
a simulator Sim without knowing any witness can simulate
the proofs on unbounded number of statements such that no
adversary can distinguish the simulated proofs from the real
ones created with witnesses. In particular, the adversary has
access to an oracle Ozk which returns either the real proofs
produced by the prover having witnesses or the simulated
proofs generated by Sim. We use Advuzk
Π (t, qzk ) to denote the
maximum advantage of all adversaries against the unbounded
zero-knowledge of Π who run in time t and make at most qzk
queries to Ozk . The soundness of an NIZK system Π assures
that no adversary can prove a false statement (i.e., outside
L), where Advsound
(t) denotes the maximum advantage of
all adversaries who run in time t. We say that an NIZK
system Π satisﬁes the knowledge extractability if there exists
an extractor Ext which can extract a witness from the proof cre-
ated by the adversary, where Advext
Π (t) denotes the maximum
advantage of all adversaries who run in time t. Simulation-
sound extractability of an NIZK system Π guarantees that
the extractor Ext still works for the proof produced by the
adversary even if the adversary sees many simulated proofs
from a simulator oracle Osim and the extracted results on the
proofs created by itself from an extractor oracle Oext. We
denote by Advss-ext
Π (t, qsim , qext ) the maximum advantage of
all adversaries against the simulation-sound extractability of
Π who run in time t and make at most qsim and qext queries
to Osim and Oext respectively. We refer the reader to [32], [9]
for the formal deﬁnitions of the above security properties.
Π
III. PASSWORD-BASED CREDENTIAL
B. Security Deﬁnition of PBC
In this section, we propose a new cryptographic primitive
called Password-Based Credential (PBC), which protects a
user’s credential
issued by a server with a password and
uses both the password-protected credential and password to
generate authentication tokens to authenticate to the server
with a challenge-response procedure, and formalize its security
considering practical threats. Our model is game-based, and
inspired by the security model for PAKE protocols [12].
We deﬁne a security notion of Existential UnForgeability
under Chosen Message and chosen Veriﬁcation queries At-
tack (EUF-CMVA) for PBC schemes. Informally, EUF-CMVA
guarantees that no adversary can forge valid authentication
token on a fresh message for an honest user. A PBC scheme is
EUF-CMVA secure means that this scheme is secure as long as
at least one of the password-wrapped credential and password
of the user has not been revealed by the adversary, and even
if the password-wrapped credential is leaked, the attacker can
only guess the password by querying the server online. Note
that this notion implies unforgeability of credentials, as a valid
credential can always be used to create authentication tokens.
A. Syntax of PBC
Let U and D denote the spaces of usernames and passwords
respectively, and Reg be a set of usernames that have been
registered, the syntax of PBC scheme is deﬁned as follows:
Deﬁnition 3 (Password-Based Credential): A password-
based credential scheme PBC = (Setup, KeyGen, Issue, Sign,
Verify) with message space M is deﬁned as follows:
• Setup(1λ): On input a security parameter λ (in unary), the
setup algorithm outputs a set of public parameters pp, which
is an implicit input to the following algorithms except for
being explicitly described.
• KeyGen(pp): On input pp, a server runs the key generation
algorithm to create a secret key sk and a set of issuer
parameters isp associated with sk. Then the server initializes
Reg as empty. We also consider that isp is an implicit input
to the following algorithms unless explicitly describing.
• Issue(sk, Reg) (cid:10) (uid, pw) is an interactive registration
protocol executed between a user and the server over a
secure channel (e.g., established by TLS). The user runs the
protocol by inputting its username-password (uid, pw) ∈
U × D, and interacts with the server who takes inputs its
secret key sk and a set of registered usernames Reg. If either
party aborts, the protocol outputs ⊥. Otherwise, the server
issues a credential cre to the user and updates Reg to include
uid, and the user outputs a password-wrapped credential
[cre]pw which can be stored on a general-purpose device.
• Sign(uid, pw, [cre]pw , m): On input a username uid, a
password pw, a password-based credential [cre]pw and a
message m ∈ M, a user runs this algorithm to generate an
authentication token σ on message m.
• Verify(sk, uid , m, σ): On input a secret key sk, a username
uid ∈ U, a message m and a token σ, the server runs the
algorithm to check the validity of σ. This algorithm outputs
1 if σ is valid on uid and m under sk and 0 otherwise.
Next, we give the formal deﬁnition on the security of PBC,
which is the EUF-CMVA security. Our model is comprehen-
sive enough to cover a broad range of threat scenarios. We
provide an adversary with a series of oracles to capture its
attack abilities, which correspond to the abilities of real-world
attackers. In the following, we will ﬁrst describe these oracles
and the motivations behind them, then describe the goal of
adversary, and ﬁnally present the formal deﬁnition.
If i ∈ [n],
Oracles. All oracles and the experiment of EUF-CMVA main-
tain the following global sets: RUpw is the set of users whose
passwords were revealed; RUcred is the set of users whose
password-wrapped credentials were revealed; Q is the set of
queries made by the adversary to the SIGN oracle. Let n be
the number of users, the oracles are deﬁned as follows:
• REVEALCRED(i):
this oracle outputs the
password-wrapped credential [crei ]pwi of user i and adds
i to RUcred.
• REVEALPW(i): If i ∈ [n], this oracle outputs the password
pwi of user i and adds i to RUpw.
• SIGN(i, m): If i ∈ [n] and i /∈ RUpw ∩ RUcred, this oracle
returns σ ← Sign(uidi , pwi , [crei ]pwi , m) and adds (i, m)
to the set Q.
• VERIFY(uid, m, σ): this oracle returns the veriﬁcation result
on an authentication token σ and challenge message m by
running Verify(sk, uid, m, σ).
Each oracle represents a threat scenario that may occur in
practice. In the following, we describe the motivations behind
oracles, which also include the abilities and assumptions we
adopted for real-life attackers.
• REVEALCRED: We allow the adversary to obtain the
password-wrapped credentials of its chosen users via mak-
ing queries to the REVEALCRED oracle. In this oracle,
we model the case that the password-wrapped credentials
are stored as a ﬁle on a general purpose device, and may
be stolen by malwares [3], through the lost or stolen of