浮点指令通常是以字母“F”开始。尽管有一小部分程序会使用浮点数学运算，但大部分程序都不会使用。浮点指令在操作码范围中占有较大比例，所以在花指令中特别常见。在这里，代码设计的知识往往能够在逆向工程的尝试中派上用场。如果我们对一个3D图形程序进行逆向，就会发现其中存在大量的浮点指令，这是正常的。但如果我们对恶意软件进行逆向，浮点数学运算就不太可能会出现在其中。最后需要特别说明的一点是，Shellcode经常会使用一些浮点指令，用来得到指向其自身的指针。
    l  SAHF
    l  LAHF
SAHF的作用是将寄存器AH的值传送到标志寄存器PSW，LAHF则是反过来将PSW的值保存到AH。由于这一操作只能通过编程时明确的语句来实现，并不会从高级语言中翻译而来，所以编译器通常情况下不会输出这些指令。其实，即使是人工编写的汇编代码，也很少使用这两个指令。并且它们还是单操作码范围内的单字节指令，同样常常作为花指令。
ASCII调整指令
    l  AAA
    l  AAS
    l  AAM
    l  AAD
这一系列的“AA”指令，作用是在汇编语言中以十进制的形式来处理数据。同样，由于这些指令在早期比较流行，现在已经不被广泛使用，所以理论上不应该经常出现。它们同样也是单字节指令。
    l  SBB
SBB指令与SUB相似，只不过它将进位标志（Carry
Flag）添加到源操作数之中。该指令在合法的代码中，特别是在对大于机器字长的数字进行运算时也能见到。然而，SBB指令有9个以上的操作码，占比3.5%。尽管并不是单字节指令，但由于其拥有多种形式和众多操作码，所以会被用作花指令。
    l  XLAT
XLAT是汇编语言查表指令。由于它并不能直接翻译成某个特定的高级语言结构，所以编译器一般不会使用该指令。它同样也是一个单字节指令，因此它是花指令的概率，要比人工使用该指令的概率更大一些。
    l  CLC
    l  STC
    l  CLD
    l  STD
这些指令会清除/设置进位标志及目的标志（Destination
Flag）。这些指令可能会在流操作的附近出现，我们通常会在REP前缀的地方看到它们。同样，它们都是单字节指令，经常用作花指令。
#### (3) 远指针指令
    l  LDS
    l  LSS
    l  LES
    l  LFS
    l  LGS
在英特尔的架构中，远指针（Far
Pointer）不会存在于16位之中。但是，设置远指针的指令，仍然会占用两个单字节的操作码，还占用了双字节操作码中的3个值。因此，这些指令也会作为花指令出现。
### 2.3 频繁出现的指令前缀
x86中的指令可以带有前缀，我们将其称为指令前缀。指令前缀的作用是修改后面指令的行为，最常见的一种就是改变操作数的大小。例如，我们正在以32位的模式执行指令，但希望能使用16位寄存器或操作数执行计算，那么就可以在计算指令中添加一个前缀，以告知CPU，这是一个16位的指令，并不是32位。
这样的指令前缀有很多，但非常不巧的是，其中的一大部分都在ASCII的字母范围之内。这也就意味着，如果我们反汇编了一个ASCII的文本（比如之前的“乱数假文”），那就会出现特别多的指令前缀。
如果我们在对一个32位的代码进行反汇编，却发现它大量使用了16位的寄存器（比如使用了AX、BX、CX、DX、SP、BP，而不是EAX、EBX、ECX、EDX、ESP、EBP），此时就要意识到，现在在看的很有可能就是花指令。
反汇编器会在指令助记符（Instruction Mnemonic）前添加特定的符号来表示其他前缀。如果我们在代码中能看到下面这些关键词，很有可能会是花指令：
    l  LOCK
    l  BOUND
    l  WAIT
段选择器
    l  FS
    l  GS
    l  SS
    l  ES
在16位模式下，会使用段寄存器（CS、DS、FS、GS、SS、ES）进行寻址的存储。程序的代码通常是基于CS“代码段”寄存器来实现引用的，而程序处理的数据是从DS“数据段”寄存器引用的。ES、FS、GS是额外的数据段寄存器，用于32位代码。段选择器（Segment
Selector）的前缀字节，可以添加在指令之前，从而强制使其基于特定的段来引用内存，而不是基于其默认的段。由于上述这些都占用了单字节操作码空间，因此也会在花指令中频繁出现。在我的随机数据中，有一个反编译后的指令，是GS寄存器的段选择符前缀使其不指向地址存储器：
相比于普通代码来说，花指令会更加频繁地使用这些段寄存器，并且编译器不会产生输出。我们再看看另外一个例子：
该指令会从堆栈中弹出SS“堆栈段”寄存器。这是一个完全有效的指令，然而，由于这是反编译的32位代码，段寄存器并不会像16位那样进行改变。同样，如果只有上面几行代码，会出现另一个奇怪的指令：
32位的体系结构中，支持更多段寄存器的寻址。这条指令的作用是将一些数据移动到第七个段寄存器中，我的反编译器将其命名为“segr7”。
## 3\. 总结
由于花指令的存在，最好的情况是浪费分析人员的时间和精力，而最坏的情况恐怕是会误导我们的分析过程，让我们去分析错误的数据。通过本文，我们学会了识别常见的反汇编花指令，并对其频繁出现的原因做以详细地分析。
希望通过本文的阅读，可以让你在以后的工作中轻松识别出花指令，从而节约工作时间，确保分析的准确性。