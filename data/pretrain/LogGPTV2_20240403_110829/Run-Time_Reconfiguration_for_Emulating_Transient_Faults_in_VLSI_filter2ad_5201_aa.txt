title:Run-Time Reconfiguration for Emulating Transient Faults in VLSI
Systems
author:David de Andr&apos;es and
Juan-Carlos Ruiz-Garcia and
Daniel Gil and
Pedro J. Gil
Run-Time Reconfiguration for Emulating Transient Faults in VLSI Systems 
David de Andrés, Juan Carlos Ruiz, Daniel Gil, Pedro Gil 
Fault Tolerant Systems Research Group (GSTF), Technical University of Valencia (UPV) 
DISCA-ETS Informática Aplicada, Campus de Vera #14, E-46021, Valencia, Spain 
Phone: +34 96 3877007 Ext {75752, 85703, 75777, 79707}, Fax: +34 96 3877579 
{ddandres, jcruizg, dgil, pgil}@disca.upv.es 
Abstract 
In 
that 
context, 
techniques. 
Advances  in  circuitry  integration  increase  the 
probability  of  occurrence  of  transient  faults  in  VLSI 
systems. A confident use of these systems requires the 
study of their behaviour in the presence of such faults. 
This  study  can  be  conducted  using  model-based  fault 
injection 
field-
programmable  gate  arrays  (FPGAs)  offer  a  great 
promise  by  enabling  those  techniques  to  execute 
models  faster.  This  paper  focuses  on  how  run-time 
reconfiguration  techniques  can  be  used  for emulating 
the  occurrence  of  transient  faults  in  VLSI  models. 
Although the use of FPGAs for that purpose has been 
restricted so far to the well-known bit-flip fault model, 
recent studies in fault representativeness point out the 
need  of  considering  a  wider  set  of  faults  modelling 
aspects  like  delays,  indeterminations  and  pulses. 
Therefore, the main goal of this study is to analyse the 
different  alternatives 
the 
emulation of these faults while  greatly decreasing the 
time devoted to models execution. 
1. Introduction 
that  FPGAs  offer 
Nowadays, mission critical systems are widely used 
in  a  large  spectrum  of  solutions,  such  as  automotive, 
avionic and space systems. In these domains, a failure 
of the system could have disastrous consequences from 
both  economical  and  human  viewpoints.  For  this 
reason,  these  applications  need  a  high  degree  of 
dependability. 
Recent studies [1][2] point out that the likelihood of 
appearance  of  transient  faults  is  increasing  in  systems 
manufactured  using  deep  submicron 
technologies. 
Hence,  the  importance  of  studying  the  behaviour  of 
these systems in the presence of faults. 
Fault injection is nowadays a well-known technique 
to assess the dependability of VLSI systems. Basically, 
for 
its goal is to study whether or not the system is able to 
tolerate (or to handle in a safe manner) the occurrence 
of  a  fault  while  providing  its  service  correctly.  This 
study can be conducted by means of model-based fault 
injection  techniques  [3]  applied  to  system  models 
defined  using  hardware  description  languages  (HDL). 
Since  working  with  models,  these  techniques  can  be 
used early in the design cycle, thus decreasing the cost 
of fixing an error. 
SRAM-based  Field  Programmable  Gate  Arrays 
(FPGAs)  provide  solutions  for  implementing  HDL 
models of VLSI systems. Although FPGAs are mainly 
used for logic emulation (prototyping and verification) 
purposes, their reconfiguration capabilities can be also 
of  interest  to  emulate  the  behaviour  of  the  system  in 
presence of faults. The use of FPGAs with this purpose 
is  known  as  fault  emulation  [4].  Fault  emulation  not 
only  can  be  applied  early  in  the  system  development 
cycle  but  it  also  accelerates  the  simulation  of  HDL 
models. 
Fault  emulation  can  be  performed  using  compile- 
and run-time reconfiguration techniques. Compile-time 
reconfiguration (CTR) relies on the instrumentation of 
HDL  models  [5].  Run-time  reconfiguration  (RTR) 
exploits the reconfiguration capabilities of FPGAs [6]. 
In  this  case,  internal  resources  of  the  FPGA  are 
reconfigured on the fly to emulate the occurrence of a 
fault  in  the  targeted  system.  This  paper  focuses  on 
transient faults emulation using RTR techniques. 
The  possible  faults  a  system  can  suffer  during  its 
lifecycle are typically categorized into classes of faults, 
named fault models. As the integration density of VLSI 
circuits rises, so does the set of transient hardware fault 
models 
the 
importance  of  the  impact  of  all  these  new  faults  in 
current  systems,  fault  emulation  studies  have  only 
covered so far the well-known bit-flip fault model. This 
paper  addresses 
the 
reconfiguration  capabilities  of FPGAs for emulating a 
the  problem  of  exploiting 
into  account.  Despite 
to  be 
taken 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:11:40 UTC from IEEE Xplore.  Restrictions apply. 
wider set of transient faults in HDL models [7]: bit-flip, 
pulse, delay and indetermination. 
Section  2  describes  a  general  approach  to  apply 
these faults on HDL models using RTR techniques. A 
generic  FPGA  architecture  (Section  3)  will  help  the 
reader  to  understand  how  transient  faults  can  be 
emulated  by  means  of  FPGAs  (Section  4).  Section  5 
presents a prototype tool that implements the proposed 
approaches  for  transient  faults  emulation.  It  has  been 
used to validate the model of a microcontroller and the 
results  obtained  from  these  experiments  are  shown  in 
Section  6.  The  discussion  of  related  topics  of  interest 
appears  in  Section  7.  Finally,  Section  8  outlines  the 
main conclusions and future work. 
2.  Run-time  reconfiguration  for  transient 
fault injection 
RTR  is  a  methodology  for  the  development  of 
reconfigurable  applications  [8].  It  relies  on 
the 
reconfiguration  capabilities  of  programmable  devices 
to  change  the  behaviour  of  the  system  on-the-fly. 
Hence, the use of RTR  techniques for fault emulation 
involves  the  reconfiguration  of  the  system  to  emulate 
its behaviour in the presence of faults while executing a 
representative workload. Figure 1 provides a high-level 
view  of  this  process.  As  can  be  seen,  the  fault  is 
virtually injected in the HDL model, but in practice it is 
emulated using an FPGA. 
HDL model
Synthesis and implementation
Configuration file
Download
Workload execution
Experiment
start time
Fault injection
time reached
Target
location
FPGA reconfiguration with
fault injection purposes
Reset system
to initial state Workload execution
FPGA reconfiguration with
fault removal purposes
Observation
Fault duration
time expired
Workload execution
Observation
Experiment
New experiment
Figure 1. RTR for transient fault emulation 
Analysis of results
end time
and  variables.  After 
Each fault injection experiment involves three steps: 
– Fault  location process:  Typical elements targeted 
by  model-based  fault  injection  techniques  are  ports, 
signals 
and 
implementing  an  HDL  model  on  an  FPGA,  these 
elements  can  be  mapped  to  internal  resources  of  the 
device, but they can also be renamed, merged together 
or removed by optimisations. Therefore, it is necessary 
to  establish  a  mapping  between  HDL  model  elements 
synthesising 
and  FPGA  internal  resources.  This  mapping  requires 
the  analysis  of  the  targeted  HDL  model  and  the 
configuration file resulting from the implementation of 
this model for each particular FPGA. 
executing 
–  Fault  injection  process:  This  process  consists  in 
provoking  the  occurrence  of  a  fault  in  the  considered 
HDL model. Following the RTR methodology this can 
be  accomplished  by  reconfiguring  FPGA  internal 
resources  when 
the  model.  This 
reconfiguration  depends  on  the  type  of  the  injected 
fault,  the  location  of  such  fault  in  the  model,  and  the 
mapping  of  this  location  onto  the  FPGA.  All  this 
information  is  gathered  together  to  generate  a  new 
configuration file that is loaded into the device memory 
to  effectively  change  the  configuration  of  the  FPGA 
and,  therefore,  its  functionality.  Since  we  are  dealing 
with transient faults, the same process must be followed 
so  as  to  return  the  system  back  to  its  original 
configuration once the fault duration has expired. 
–  Observation  process:  It  is  necessary  to  observe 
how  the  system  reacts  in  the  presence  of  the  injected 
fault.  Usually,  a  trace  of  the  outputs  and  state  of  the 
system are stored for its ulterior analysis. 
The  following  sections  study  how  FPGA resources 
must  be  reconfigured  to  emulate  the  occurrence  of 
transient faults in the implemented HDL model. 
3. Generic FPGA architecture 
The use of RTR techniques is closely related to the 
architecture of the FPGA being considered. Therefore, 
a  generic  FPGA  architecture  must  be  first  defined  to 
make this study as comprehensive as possible. 
Although  somewhat  different,  the  internal  structure  of 
the  main  FPGAs  families  [9][10][11][12]  is  very 
similar.  From  an  abstract  viewpoint,  every  FPGA  (cf. 
Figure 2) integrates a grid of configurable blocks (CB) 
that are connected by means of programmable matrixes 
(PM). A number of memory blocks are also embedded 
into  the  FPGA  to  allow  for  the  implementation  of 
RAM/ROM memories. 
Figure 2. Basic structure of a generic FPGA 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:11:40 UTC from IEEE Xplore.  Restrictions apply. 
CBs  consist  of  a  function  generator,  a  D-type flip-
flop  and  a  number  of  multiplexers.  The  function 
generator,  usually  built  as  a  four-input  look-up  table 
(LUT),  implements  the  combinational  logic  of  the 
circuit. The flip-flop (FF) acts as a storage element that 
implements the sequential logic of the circuit. A set of 
multiplexers (denoted as Mux elements, like CLRMux 
or  PRMux, 
the  CB’s 
functionality  by  establishing  the  proper  connection 
among the CB’s inputs, outputs, LUT and FF. 
in  Figure  2)  determines 
PMs interconnect the CBs by linking lines that cross 
the device both in vertical and horizontal directions. As 
shown  in  Figure  2,  each  connection  is  established  by 
means of a pass transistor. 
The configuration of all these elements is controlled 
by a number of bits in the configuration memory of the 
FPGA.  Some  of  these bits fill the LUT  with the truth 
table  that represents the desired combinational circuit, 
other bits set the functionality of the storage element as 
a FF or a latch, and some others set the control inputs 
of the  multiplexers. Another bits turn on/off the PM’s 
pass transistors, allowing for the routing of all the lines 
of the circuit. Likewise, some other bits fill the content 
of the internal memory blocks in use. The configuration 
memory of the FPGA is loaded from the file resulting 
from the model synthesis and implementation process. 
4.  Emulation  of  transient  faults  in  HDL 
models using FPGAs 
the  circuitry  with 
According  to  [7],  transient  faults  appear  during  a 
short period of time as a result from the interference or 
interaction  of 
its  physical 
environment  (transients  in  power  supply,  crosstalk, 
electromagnetic interferences, temperature variation, α 
and cosmic radiation, etc.) This section describes how 
the run-time reconfiguration capabilities of FPGAs can 
be used for emulating the occurrence of these faults in 
HDL models. 
4.1. Bit-flip faults 
remains  unchanged  until 
This  model  involves  reversing  the  logic  state  of  a 
memory  element.  This  element  stores  the  resulting 
value  which 
rewritten. 
Memory  elements  are  usually  synthesised  as  registers 
and latches, which are implemented by means of FFs, 
or as ROM/RAM memory mapped to internal memory 
blocks.  Hence,  these  are  the  targets  of  the  fault 
injection process when the model executes in FPGAs. 
Although the injection of bit-flip faults into FFs was 
already  addressed  in  [13],  we  are  offering  a  brief 
summary here for completeness. One must understand 
the 
in  general, 
the  faults  occurrence 
that 
is  never 
synchronized  with  the  system  execution.  Usually,  the 
only way of asynchronously inverting the state of a FF 
is by means of its set/reset signals, which are driven by 
the  GSR  (Global  Set  Reset)  line  and  the  LSR  (Local 
Set Reset) line. 
The  GSR  line  (cf.  Figure  2)  can  be  triggered  to 
set/reset all the FFs in the FPGA [14]. Therefore, it is 
necessary  to  read  the  current  state  of  all  the  FFs  to 
configure the multiplexers that control its set/reset logic 
(PRMux  and  CLRMux)  to  invert  the  state  of  the 
targeted  FF  while  keeping  the  state  of  the  rest.  The 
main drawback of this approach lies in the high amount 
of information to be transferred to and from the FPGA 
which slows down the emulation process. 
On the other hand, the LSR line only affects the FF 
connected  to  it  which  minimises  the  amount  of 
information to be transferred. Although the line can not 
be  directly  pulsed, 
this  can  be  achieved  by 
reconfiguring 
(cf. 
Figure 2). We proposed this approach in [13] to speed 
up the fault injection process. 
InvertLSRMux  multiplexer 
Currently,  FPGAs  are  integrating  more  and  more 
resources  that  greatly  help  to  implement  large  and 
complex systems. Although the internal memory blocks 
of FPGAs are being used as cache memory or storage 
for  constant  values,  as  far  as  we  know,  they  have  not 
been addressed with fault injection purposes. This work 
defines  a  conceptually  simple  approach  for  emulating 
the occurrence of bit-flips into these memory blocks. 
The  contents  of  these  internal  memory  blocks  are 
directly controlled by the configuration memory of the 