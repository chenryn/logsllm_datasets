297
融
处
会
口
表
和
---
## Page 314
管理的复杂性：
查代码，因为这些优化器能够推导出相应的访问必然在区间之内。
代码，以保证该次访问在数组界限之内。一些编译器的优化器可以发现并删除那些不必要的检
多安全危害就是利用了这种类型的程序错误。其中，某个程序输人会导致意想不到的数据访问，
和访问一-个数组界限之外的元素。探测出这种错误要好过任由程序产生错误结果。实际上，很
不回收该变量。
带来难以调试的程序错误。因而，当程序员不能确定一个变量是否还会被引用时，他们更倾向于
可能被分配给另一个变量。新旧变量上的动作可能会相互冲突。
则可能不确定地改变新变量的值。回收一个悬空指针的存储空间意味着这个新变量的存储空
针试图使用该指针所指对象的所有操作称为对这个指针的“解引用”（dereferencing）。
何读、写或回收操作都可能产生看起来不可捉摸的结果。我们把诸如读、写、回收等沿着一个指
存储空间，然后又试图去引用这个已回收空间中的数据。指向已回收空间的指针称为悬空指
后者将在7.8.3节中讨论。
泄漏内存的大小和泄漏对象的位置。我们可以将 Purity 和一个“保守的垃圾回收器”相比较
我出所有可能的指针值。任何没有指针指向的对象都是一块泄漏的存储块。Purify 可以报告
和内存泄漏不一样，在释放的空间被重新分配之后再对相应的悬空指针进行解引用总是会
访问，前提是它们恰巧落在这些对象之后，由 Purify 插入的空间中。
上已经存在一一个有效对象时，这种方法就无能为力了。这种方法还可以找到一些越界的数组
为错误。通过这种方法可以找到一些悬空指针引用，但是当该内存已经被重新分配且该位置
298
现在我们给出几个最流行的编程规范和工具，开发它们的目的是帮助程序员来应对的存储
另一个相关的编程错误形式是访问非法地址。这种错误的常见例子包括对空指针的解引!用
 注意，通过一-个悬空指针读取数据可能会返回不确定的值。通过一个悬空指针进行写操作
过度热衷于删除对象可能引起比内存泄漏更严重的问题。第二个常见的错误是删除了某
编程规范和工具
Punity 也可以在程序运行结束时发现内存泄漏。它搜索所有的已分配的对象中的内容，
环数据结构，其中的一组对象不能再被访问，但是因为它们之间互相引用，导致它们的引
基本思想是给每个动态分配的对象附上一个计数。在指向这个对象的引用被创建时，
当一个对象的生命周期需要动态确定时，引用计数(reference counting)会有所帮助。它的
关系的指针访问一个已经被删除的对象。
除两次。然而，它对解决悬空指针引用问题没有帮助，因为有可能沿着一个不代表拥有
该通过它们进行删除操作。这个规范可以消除内存泄漏，同时也可以避免将同一对象删
个对象，但是这些指针不代表拥有关系。这些指针可在任何时刻被覆盖，但是绝对不应
责删除这个对象或者把这个对象传递给另一个所有者。可能会有其他的指针也指向同一
所有者是指向该对象的--个指针，通常属于某个函数调用。所有者(也就是这个函数)负
很有用的。它的基本思想是在任何时候都给每个对象关联上一个所有者(owner）。这
当-一个对象的生命周期能够被静态推导出来时，对象所有者（object ownership）的概念是
第7章
我
个
间
针
---
## Page 315
找到这些不可达对象，并将这些对象交给跟踪空闲空间的存储管理器，收回它们所占的空间。
达"某些对象时，这些对象就变成了垃圾。在7.5.2节中将给出“到达"的准确定义。垃圾回收器
但是有缺陷的自动垃圾回收方法：引用计数。它基于如下的思想：一旦一个程序失去了指向一个
1958 年的 Lisp 语言的初次实现中。其他提供垃圾回收机制的主要语言包括Java、Perl、ML、Mod-
7.5垃圾回收概述
理器处获取空间，创建对象，它还可以引人和消除对已有对象的引用。当增变者程序不能“到
以被很容易地识别。
的起始位置，而不会指向该对象中间的位置。因此，对同一个对象的所有引用具有相同的值，可
该对象的哪些分量包含指向其他对象的引用(指针)。我们还假定对对象的引用总是指向该对象
类型可以由垃圾回收器在运行时刻确定。基于这个类型信息，我们可以知道该对象有多大，以及
7.5.1垃圾回收器的设计目标
雄区中所有的其他存储块变成空闲空间。
对象的所有引用，它就不能并且也不会再引用该对象的存储空间。
是我们仍需要精确地定义，准确的规则将在7.5.2节中讨论。我们将在7.5.3节中讨论一种简单
ula-3、Prolog 和 Smalltalk。
数据的自动垃圾回收机制，从而解除了程序员进行手工存储管理的负担。垃圾回收最早出现在
之后的空闲空间列表是什么样子的？假设选择存储块的方法是：
个块的低端。如果我们按顺序为大小分别为32、64、48、16-的对象申请空间，在满足了这些请求
此如果一个对象和被选中的存储块差不多大，我们就把整个块分配给它，并将这个对象放置在这
7.4.67.4 节的练习
容
的大小分别是80，30，60，50，70，20，40个字节。当我们在-一个存储块中放人-个对象时，如果
易地把较小的块保存在空闲空间的链表中）。然而，我们不能使用小于8个字节的存储块，因
练习7.4.1：假设堆区从〇地址开始编址，由几个存储块组成。按照地址顺序，这些存储块
我们把一个用户程序称为增变者（mutator），它会修改堆区中的对象集合。增变者从存储管
运行时刻环境
垃圾回收是重新收回那些存放了不能再被程序访问的对象的存储块。我们假定这些对象的
7.6节将讨论基于跟踪的回收器。它包含多个算法，用以找出所有仍然有用的对象，然后将
在本节中，我们将介绍多个和垃圾回收相关的概念。对象“可达”这个概念是很直观的，但
不能被引用的数据通常称为垃圾(garbage）。很多高级程序设计语言提供了用以回收不可达
2）Best-fit
1）First-fit
因为该技术以成批的方式一-次性删除区域中的所有对象，而不是每次回收一个对象。
个区域。基于区域的分配方法有一定的局限性。然而当可以使用它时，它又非常高效
时，我们可以把这些对象分配在同一个区域中。一且这个计算步骤完成，我们就删除整
配（region-based allocation)方法。当被创建的对象只在一个计算过程的某个步骤中使用
对于其生命周期局限于计算过程中的某个特定阶段的一组对象，可以使用基于区域的分
指针的每次运算上增加了额外开销，因此引用计数的运行时刻代价很大。
除所有的悬空指针引用，因为不存在指向已删除对象的引用。因为引用计数在存储一个
用计数不为 0。在例子 7.11中可以看到这个问题的-个示例。引朋计数技术确实可以根
299
---
## Page 316
销。另-一-方面，考虑一下对可达对象进行重定位的垃圾回收器。在处理大对象时重新定位是非
来处理不同类型的对象。
出权衡。不同特性的对象可能适会使用不同的处理方式，这就要求垃圾回收器使用不同的技术
首先列举-一些在设计垃圾回收器时必须考虑的性能度量标准。
收方法被提出来，但是还没有一种无可争议的最好的垃圾回收算法。在讨论这些方法之前，我们
价是如此高昂，所以至今没有被很多主流的程序设计语言使用。在多年的研究中，很多不同的回
保守的垃圾回收技术。
正确，但是实践经验表明很有效的垃圾回收器。我们将在7.8.3 节中讨论用于C和C++语言的
不可访问的，也就无法安全地收回任何存储空间。
算
安全的，比如C和C++。在不安全语言中，存储地址可以进行任意操作：可以将任意的算术运
为动态类型(dynamically typed)语言。如果一个语言既不是静态类型安全的，也不是动态类型安
(typesafe)的。对于某些类型安全的语言，比如 ML，我们可以在编译时刻确定数据的类型。另外
指针。在一种语言中，如果任何数据分量的类型都是可确定的，那么这种语言就称为类型安
给定的数据元素或---个数据元素的分量是否为(或可否被用作)--个指向某块已分配存储空间的
说，一个程序可以在任何时候引用内存中的任何位置。这样，没有哪个内存位置可以被认为是
应用于指针，创建出一个新的指针，并且任何整数都可以被强制转化为指针。因此，从理论上
在实践中，大部分C和C++程序并没有随意地生成指针。因此人们开发了－-个在理论上不
的，它就被称为不安全的（unsafe）。
些类型安全语言，比如Java，其类型不能在编译时刻确定，但是可以在运行时刻确定。后者
类型不安全的语言不适合使用自动垃圾回收机制。遗憾的是，有些最重要语言却是类型不
300
考虑另一个例子。一般来说，在基于跟踪的回收器中，我们等待垃圾回收的时间越长，可回
例如，已分配的对象数量中小对象的数量很大比例，那么对小对象的分配不能产生大的开
这些设计目标中的某些目标可能互相冲突，设计者必须在认真考虑程序的典型行为之后作
性能度量
不是所有的语言都适合进行自动垃圾回收。为了使垃圾回收器能够工作，它必须知道任何
--个基本要求：类型安全
警的情况下突然启动，导致程序(即增变者)突然长时间停顿。因此，除了最小化总体运
停顿时间。简单的垃圾回收器有一个众所周知的问题，即垃圾回收过程会在没有任何预
空间使用。重要之处在于垃圾回收机制避免了内存碎片，并最大限度地利用了可用内存。
总体运行时间。垃圾回收的速度可能会很慢。使它不会显著增加一-个应用程序的总运行
管在几十年前就发明了垃圾回收机制，并且它能够完全防止内存泄漏，但是垃圾回收的代
一个高速缓存线或内存页上，从前改善程序的空间局部性。
该
控
程序局部性。我们不能只通过-个垃圾回收器的运行时间来评价它的速度。垃圾回收器
么限定最长停顿时间。因此，垃圾回收机制很少在实时应用中使用。
某些计算在一个时间界限内完成。我们要么在执行实时任务时压制住垃圾回收过程，要
行时间之外，人们还希望将最长停顿时间最小化。作为一个重要的特例，实时应用要求
能否充分利用存储子系统。
时间是很重要的。因为垃圾回收器必须要访问很多数据，它的性能很大程度上决定于它
亥空间来改善增变者程序的时间局部性；它也可以将那些一起使用的数据重新放置在同
空制了数据的放置，因此影响了增变者程序的数据局部性。它可以通过释放空间并复用
第7章
称
全
---
## Page 317
下面是一个增变者程序改变可达对象集合的四种基本操作：
得不可达时该集合就缩小。重要的是记住一-且某个对象变得不可达，它就不可能再次变得可达。
可以做如下的处理：
存器中的值上，计算得到一个合法地址。为了使得垃圾回收器能够找到正确的根集，优化编译器
码
员
在寄存器中。这些引用也必须被看做是根集的一部分。其次，尽管在一-个类型安全语言中，程序
在任何可达对象的字段成员或数组元素中，那么这个对象本身也是可达的。
在
如，在Java 中，一个程序的根集由所有的静态字段成员和栈中的所有变量组成。显然，程序可以
7.5. 2可达性
优化技术可以分析变量的生命周期，并尽可能地将它们分配到栈区。
计使得程序员不需要关注变量的生命周期，但是其代价是产生更多的垃圾。已经有---些编译器
使这些对象的生命周期被限制在一次函数调用的生命周期内，它们仍然被分到堆区中。这种设
比如，函数式(或者几乎函数式)的程序设计语言为了避免改变已存在的对象，会创建出更多的
构）。
减慢程序的整体运行速度。但是另一方面，引用计数技术不会产生长时间的停顿，并且能够有效
一方面，降低回收频率会增加程序的内存使用要求，降低数据局部性，并增加停顿时间。
马中的寄存器可能会指向--个对象或数组的中间位置，或者程序可能把--个偏移量加到这些
不能直接操作内存地址，但是编译器常常会为了提高代码速度而这么做。因此，编译得到的代
任何时候访问根集中的任何成员。递归地，对于任意--个对象，如果指向它的一-个引用被保存
象。在Java 中，除了整型和引用这样的基本类型，所有的对象都被分配在堆区而不是栈区。
语言的设计同样会影响内存使用的特性。有些语言提倡的程序设计风格会产生很多垃圾。
相比之下，-个使用引用计数的回收器给增变者的每次运算引人一个常量开销，从而明显地
运行时刻环境
当程序被编译器优化之后，可达性问题会变得更加复杂。首先，编译器可能会把引用变量放
我们把所有不需要对任何指针解引用就可以被程序直接访问的数据称为根集(root set）。
●对象分配。这些操作由存储管理器完成。它返回一个指向新创建的存储区域的引用。这
可达对象的集合随着程序的执行而变化。当新对象被创建时该集合会增长，当某些对象变
·编译器可以确保当垃圾回收器被激活时每个可达对象都有一个引用指向它的基地址。
●编译器可以限制垃圾回收机制只能在程序中的某些代码点上被激活。在这些点上没有
引用赋值。对于引用u和，形如u=的赋值语句有两个效果。首先，u现在是所指对
编译器可以写出一-些信息供垃圾回收器恢复所有的引用。比如，指出哪些寄存器中包含
“隐藏”的引用。
变成不可达的。
不可达的。当某个对象变得不可达时，所有只能通过这个对象中的引用到达的对象都会
引用丢失了。如果这个引用是指向某-一可达对象的最后-个引用，那么那个对象就变成
象的一个引用。只要u是可达的，那么它指向的对象当然也是可达的。其次，u中原来的
果传回给调用者。这些引用指向的对象仍然是可达的。
参数传递和返回值。对象引用从实在输人参数传递到相应的形式参数，也可以从返回结
个操作向可达对象集中添加成员。
了引用，或者如何根据给定的某个对象的内部地址来计算该对象的基地址。
301
寄
例
---
## Page 318
数据结构的出现都是有理由的：数据结构常常会指回到它们的父结点，也可能相互指向对方，从
所指向的每个对象的引用计数减1。
计数都要减1。
须减一。如果多个局部变量存放了指向同一对象的引用，那么对每个这样的引用，该对象的引用
向的原对象的引用计数减1。
引用计数可以按照下面的方法进行维护：
就
为不可达的时候，该回收器就可以将该对象确认为垃圾；当一个对象的引用计数为0时，该对象
7.5.3引用计数垃圾回收器
论这些可选算法。
象重新定位，从而减少碎片。有很多种不同的基于跟踪的算法，我们将在7.6节和7.7.1节中讨