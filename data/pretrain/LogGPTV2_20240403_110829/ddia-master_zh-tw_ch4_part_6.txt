#### 归档储存
也许你不时为资料库建立一个快照，例如备份或载入到资料仓库（请参阅 “[资料仓库](ch3.md#资料仓库)”）。在这种情况下，即使源资料库中的原始编码包含来自不同时代的模式版本的混合，资料转储通常也将使用最新模式进行编码。既然你不管怎样都要复制资料，那么你可以对这个资料复制进行一致的编码。
由于资料转储是一次写入的，而且以后是不可变的，所以 Avro 物件容器档案等格式非常适合。这也是一个很好的机会，可以将资料编码为面向分析的列式格式，例如 Parquet（请参阅 “[列压缩](ch3.md#列压缩)”）。
在 [第十章](ch10.md) 中，我们将详细讨论使用档案储存中的资料。
### 服务中的资料流：REST与RPC
当你需要透过网路进行程序间的通讯时，安排该通讯的方式有几种。最常见的安排是有两个角色：客户端和伺服器。伺服器透过网路公开 API，并且客户端可以连线到伺服器以向该 API 发出请求。伺服器公开的 API 被称为服务。
Web 以这种方式工作：客户（Web 浏览器）向 Web 伺服器发出请求，透过 GET 请求下载 HTML、CSS、JavaScript、影象等，并透过 POST 请求提交资料到伺服器。API 包含一组标准的协议和资料格式（HTTP、URL、SSL/TLS、HTML 等）。由于网路浏览器、网路伺服器和网站作者大多同意这些标准，你可以使用任何网路浏览器访问任何网站（至少在理论上！）。
Web 浏览器不是唯一的客户端型别。例如，在移动装置或桌面计算机上执行的本地应用程式也可以向伺服器发出网路请求，并且在 Web 浏览器内执行的客户端 JavaScript 应用程式可以使用 XMLHttpRequest 成为 HTTP 客户端（该技术被称为 Ajax 【30】）。在这种情况下，伺服器的响应通常不是用于显示给人的 HTML，而是便于客户端应用程式程式码进一步处理的编码资料（如 JSON）。尽管 HTTP 可能被用作传输协议，但顶层实现的 API 是特定于应用程式的，客户端和伺服器需要就该 API 的细节达成一致。
此外，伺服器本身可以是另一个服务的客户端（例如，典型的 Web 应用伺服器充当资料库的客户端）。这种方法通常用于将大型应用程式按照功能区域分解为较小的服务，这样当一个服务需要来自另一个服务的某些功能或资料时，就会向另一个服务发出请求。这种构建应用程式的方式传统上被称为 **面向服务的体系结构（service-oriented architecture，SOA）**，最近被改进和更名为 **微服务架构**【31,32】。
在某些方面，服务类似于资料库：它们通常允许客户端提交和查询资料。但是，虽然资料库允许使用我们在 [第二章](ch2.md) 中讨论的查询语言进行任意查询，但是服务公开了一个特定于应用程式的 API，它只允许由服务的业务逻辑（应用程式程式码）预定的输入和输出【33】。这种限制提供了一定程度的封装：服务能够对客户可以做什么和不可以做什么施加细粒度的限制。
面向服务 / 微服务架构的一个关键设计目标是透过使服务独立部署和演化来使应用程式更易于更改和维护。例如，每个服务应该由一个团队拥有，并且该团队应该能够经常释出新版本的服务，而不必与其他团队协调。换句话说，我们应该期望伺服器和客户端的旧版本和新版本同时执行，因此伺服器和客户端使用的资料编码必须在不同版本的服务 API 之间相容 —— 这正是我们在本章所一直在谈论的。
#### Web服务
**当服务使用 HTTP 作为底层通讯协议时，可称之为 Web 服务**。这可能是一个小错误，因为 Web 服务不仅在 Web 上使用，而且在几个不同的环境中使用。例如：
1. 执行在使用者装置上的客户端应用程式（例如，移动装置上的本地应用程式，或使用 Ajax 的 JavaScript web 应用程式）透过 HTTP 向服务发出请求。这些请求通常透过公共网际网路进行。
2. 一种服务向同一组织拥有的另一项服务提出请求，这些服务通常位于同一资料中心内，作为面向服务 / 微服务架构的一部分。（支援这种用例的软体有时被称为 **中介软体（middleware）** ）
3. 一种服务透过网际网路向不同组织所拥有的服务提出请求。这用于不同组织后端系统之间的资料交换。此类别包括由线上服务（如信用卡处理系统）提供的公共 API，或用于共享访问使用者资料的 OAuth。
有两种流行的 Web 服务方法：REST 和 SOAP。他们在哲学方面几乎是截然相反的，往往也是各自支持者之间的激烈辩论的主题 [^vi]。
[^vi]: 即使在每个阵营内也有很多争论。例如，**HATEOAS（超媒体作为应用程式状态的引擎）** 就经常引发讨论【35】。
REST 不是一个协议，而是一个基于 HTTP 原则的设计哲学【34,35】。它强调简单的资料格式，使用 URL 来标识资源，并使用 HTTP 功能进行快取控制，身份验证和内容型别协商。与 SOAP 相比，REST 已经越来越受欢迎，至少在跨组织服务整合的背景下【36】，并经常与微服务相关【31】。根据 REST 原则设计的 API 称为 RESTful。
相比之下，SOAP 是用于制作网路 API 请求的基于 XML 的协议 [^vii]。虽然它最常用于 HTTP，但其目的是独立于 HTTP，并避免使用大多数 HTTP 功能。相反，它带有庞大而复杂的多种相关标准（Web 服务框架，称为 `WS-*`），它们增加了各种功能【37】。
[^vii]: 尽管首字母缩写词相似，SOAP 并不是 SOA 的要求。SOAP 是一种特殊的技术，而 SOA 是构建系统的一般方法。
SOAP Web 服务的 API 使用称为 Web 服务描述语言（WSDL）的基于 XML 的语言来描述。WSDL 支援程式码生成，客户端可以使用本地类和方法呼叫（编码为 XML 讯息并由框架再次解码）访问远端服务。这在静态型别程式语言中非常有用，但在动态型别程式语言中很少（请参阅 “[程式码生成和动态型别的语言](#程式码生成和动态型别的语言)”）。
由于 WSDL 的设计不是人类可读的，而且由于 SOAP 讯息通常因为过于复杂而无法手动构建，所以 SOAP 的使用者在很大程度上依赖于工具支援，程式码生成和 IDE【38】。对于 SOAP 供应商不支援的程式语言的使用者来说，与 SOAP 服务的整合是困难的。
尽管 SOAP 及其各种扩充套件表面上是标准化的，但是不同厂商的实现之间的互操作性往往会造成问题【39】。由于所有这些原因，尽管许多大型企业仍然使用 SOAP，但在大多数小公司中已经不再受到青睐。
REST 风格的 API 倾向于更简单的方法，通常涉及较少的程式码生成和自动化工具。定义格式（如 OpenAPI，也称为 Swagger 【40】）可用于描述 RESTful API 并生成文件。
#### 远端过程呼叫（RPC）的问题
Web 服务仅仅是透过网路进行 API 请求的一系列技术的最新版本，其中许多技术受到了大量的炒作，但是存在严重的问题。Enterprise JavaBeans（EJB）和 Java 的 **远端方法呼叫（RMI）** 仅限于 Java。**分散式元件物件模型（DCOM）** 仅限于 Microsoft 平台。**公共物件请求代理体系结构（CORBA）** 过于复杂，不提供向后或向前相容性【41】。
所有这些都是基于 **远端过程呼叫（RPC）** 的思想，该过程呼叫自 20 世纪 70 年代以来一直存在【42】。RPC 模型试图向远端网路服务发出请求，看起来与在同一程序中呼叫程式语言中的函式或方法相同（这种抽象称为位置透明）。尽管 RPC 起初看起来很方便，但这种方法根本上是有缺陷的【43,44】。网路请求与本地函式呼叫非常不同：
* 本地函式呼叫是可预测的，并且成功或失败仅取决于受你控制的引数。网路请求是不可预测的：请求或响应可能由于网路问题会丢失，或者远端计算机可能很慢或不可用，这些问题完全不在你的控制范围之内。网路问题很常见，因此必须有所准备，例如重试失败的请求。
* 本地函式呼叫要么返回结果，要么丢掷异常，或者永远不返回（因为进入无限回圈或程序崩溃）。网路请求有另一个可能的结果：由于超时，它返回时可能没有结果。在这种情况下，你根本不知道发生了什么：如果你没有得到来自远端服务的响应，你无法知道请求是否透过（我们将在 [第八章](ch8.md) 更详细地讨论这个问题）。
* 如果你重试失败的网路请求，可能会发生请求实际上已经完成，只是响应丢失的情况。在这种情况下，重试将导致该操作被执行多次，除非你在协议中建立资料去重机制（**幂等性**，即 idempotence）。本地函式呼叫时没有这样的问题。（在 [第十一章](ch11.md) 更详细地讨论幂等性）
* 每次呼叫本地函式时，通常需要大致相同的时间来执行。网路请求比函式呼叫要慢得多，而且其延迟也是非常可变的：好的时候它可能会在不到一毫秒的时间内完成，但是当网路拥塞或者远端服务超载时，可能需要几秒钟的时间才能完成相同的操作。
* 呼叫本地函式时，可以高效地将引用（指标）传递给本地记忆体中的物件。当你发出一个网路请求时，所有这些引数都需要被编码成可以透过网路传送的一系列位元组。如果引数是像数字或字串这样的基本型别倒是没关系，但是对于较大的物件很快就会出现问题。
* 客户端和服务可以用不同的程式语言实现，所以 RPC 框架必须将资料型别从一种语言翻译成另一种语言。这可能会变得很丑陋，因为不是所有的语言都具有相同的型别 —— 例如回想一下 JavaScript 的数字大于 $2^{53}$ 的问题（请参阅 “[JSON、XML 和二进位制变体](#JSON、XML和二进位制变体)”）。用单一语言编写的单个程序中不存在此问题。
所有这些因素意味著尝试使远端服务看起来像程式语言中的本地物件一样毫无意义，因为这是一个根本不同的事情。REST 的部分吸引力在于，它并不试图隐藏它是一个网路协议的事实（尽管这似乎并没有阻止人们在 REST 之上构建 RPC 库）。
#### RPC的当前方向
尽管有这样那样的问题，RPC 不会消失。在本章提到的所有编码的基础上构建了各种 RPC 框架：例如，Thrift 和 Avro 带有 RPC 支援，gRPC 是使用 Protocol Buffers 的 RPC 实现，Finagle 也使用 Thrift，Rest.li 使用 JSON over HTTP。
这种新一代的 RPC 框架更加明确的是，远端请求与本地函式呼叫不同。例如，Finagle 和 Rest.li 使用 futures（promises）来封装可能失败的非同步操作。`Futures` 还可以简化需要并行发出多项服务并将其结果合并的情况【45】。gRPC 支援流，其中一个呼叫不仅包括一个请求和一个响应，还可以是随时间的一系列请求和响应【46】。
其中一些框架还提供服务发现，即允许客户端找出在哪个 IP 地址和埠号上可以找到特定的服务。我们将在 “[请求路由](ch6.md#请求路由)” 中回到这个主题。