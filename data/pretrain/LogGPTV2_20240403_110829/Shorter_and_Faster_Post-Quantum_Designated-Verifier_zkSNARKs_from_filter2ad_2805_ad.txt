based on vector encryption over the extension Fğ‘2 as well as over
the base field Fğ‘. For the latter setting, we need to first transform
a linear PCP over Fğ‘2 to a linear PCP over Fğ‘. We describe this
transformation in Appendix C.1.
3.2 Linear-Only Vector Encryption
We begin with the definition of a vector encryption scheme (adapted
from [31]), and then define the linear-only [30, 31] property we
rely on for our zkSNARK constructions.
Definition 3.1 (Vector Encryption). Let F be a finite field. A secret-
key additively-homomorphic vector encryption scheme over a
vector space Fâ„“ consists of a tuple of algorithms Î Enc = (Setup,
Encrypt, Decrypt, Add) with the following properties:
â€¢ Setup(1ğœ†, 1â„“) â†’ (pp, sk): On input the security parameter ğœ† and
the plaintext dimension â„“, the setup algorithm outputs public
parameters pp and a secret key sk.
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea217â€¢ Encrypt(sk, v) â†’ ct: On input the secret key sk and a vector
v âˆˆ Fâ„“, the encryption algorithm outputs a ciphertext ct.
â€¢ Decrypt(sk, ct) â†’ v/âŠ¥: On input the secret key sk and a cipher-
text ct, the decryption algorithm either outputs a vector v âˆˆ Fâ„“
or a special symbol âŠ¥.
â€¢ Add(pp, {ctğ‘–}ğ‘–âˆˆ[ğ‘›], {ğ‘ğ‘–}ğ‘–âˆˆ[ğ‘›]) â†’ ctâˆ—: On input the public param-
eters, a collection of ciphertexts ct1, . . . , ctğ‘› and scalars ğ‘1, . . . , ğ‘ğ‘› âˆˆ
F, the addition algorithm outputs a new ciphertext ctâˆ—.
Moreover, Î Enc should satisfy the following properties:
â€¢ Additive homomorphism: For all security parameters ğœ† âˆˆ N,
vectors v1, . . . , vğ‘˜ âˆˆ Fâ„“, and scalars ğ‘¦1, . . . , ğ‘¦ğ‘˜ âˆˆ F, where ğ‘˜ =
ğ‘˜(ğœ†),
(3.1)
Decrypt(sk, ctâˆ—) =

ğ‘–âˆˆ[ğ‘˜]
Pr
 = 1 âˆ’ negl(ğœ†),
ğ‘¦ğ‘–vğ‘–
where (pp, sk) â† Setup(1ğœ†, 1â„“), ctğ‘– â† Encrypt(sk, vğ‘–) for all ğ‘– âˆˆ
[ğ‘˜], and ctâˆ— â† Add(pp, {ctğ‘–}ğ‘–âˆˆ[ğ‘˜], {ğ‘¦ğ‘–}ğ‘–âˆˆ[ğ‘˜]). We say that Î Enc
is additively homomorphic with respect to a set ğ‘† âŠ† ğ‘…ğ‘˜
ğ‘ if Eq. (3.1)
holds for all (ğ‘¦1, . . . , ğ‘¦ğ‘˜) âˆˆ ğ‘†. Note that additive homomorphism
implies correctness of decryption.
â€¢ CPA security: For all security parameters ğœ† âˆˆ N and all efficient
adversaries A,
Pr(cid:104)AOğ‘ (sk,Â·,Â·)(1ğœ†, pp) = ğ‘(cid:105)
= 1/2 + negl(ğœ†),
(3.2)
râ† {0, 1}, and oracle Oğ‘ takes
where (pp, sk) â† Setup(1ğœ†, 1â„“), ğ‘
inputs (sk, v0, v1) and outputs ctğ‘ â† Encrypt(sk, vğ‘). If Eq. (3.2)
holds against all efficient adversaries A making at most ğ‘„ queries
to Oğ‘, then we say Î Enc is ğ‘„-query CPA secure.
Definition 3.2 (Linear-Only Vector Encryption [30, adapted]). A
vector encryption scheme Î Enc = (Setup, Encrypt, Decrypt, Add)
over Fâ„“ is strictly linear-only if for all polynomial-size adversaries
A, there is a polynomial-size extractor E such that for all secu-
rity parameters ğœ† âˆˆ N, auxiliary inputs ğ‘§ âˆˆ {0, 1}poly(ğœ†), and any
efficient plaintext generator M,
Pr[ExptLinearExtÎ Enc,A,M,E,ğ‘§(1ğœ†) = 1] = negl(ğœ†),
where the experiment ExptLinearExtÎ Enc,A,M,E,ğ‘§(1ğœ†) is defined as
follows:
(1) The challenger starts by sampling (pp, sk) â† Setup(1ğœ†, 1â„“) and
(v1, . . . , vğ‘š) â† M(1ğœ†, pp). It computes ctğ‘– â† Encrypt(sk, vğ‘–)
for each ğ‘– âˆˆ [ğ‘š] and runs A(pp, ct1, . . . , ctğ‘š; ğ‘§) to obtain a
tuple (ctâ€²
1, . . . , ctâ€²
ğ‘˜).
(2) The challenger computes ğš· â† E(pp, ct1, . . . , ctğ‘š; ğ‘§) and Vâ€² â†
| vğ‘š]T, where ğš· âˆˆ Fğ‘˜Ã—ğ‘š and Vâ€² âˆˆ Fğ‘˜Ã—â„“. The
ğš· Â· [v1 |
Â· Â· Â·
experiment outputs 1 if there exists an index ğ‘– âˆˆ [ğ‘˜] such that
ğ‘–, where vâ€²
ğ‘–) â‰  âŠ¥ and Decrypt(sk, ctâ€²
Decrypt(sk, ctâ€²
ğ‘– âˆˆ Fâ„“
is the ğ‘–th row of Vâ€². Otherwise, the experiments outputs 0.
We provide additional discussion of these definitions and com-
pare them to previous definitions [30, 31] in the full version of this
paper [78].
ğ‘–) â‰  vâ€²
Circuit privacy. In addition to the above properties, we addition-
ally require a circuit privacy property [66]. Circuit privacy says
that the ciphertext output by Add can be simulated given only
the underlying plaintext value, without knowledge of the linear
combination used to construct the ciphertext. This is important
for arguing zero knowledge (see Section 3.4). We give the formal
definition in Appendix C.2.
3.3 Candidate Linear-Only Vector Encryption
Our constructions work over the ring ğ‘… = Z[ğ‘¥]/(ğ‘¥ğ‘‘ + 1) where
ğ‘‘ is a power of 2. We specifically consider the cases where ğ‘‘ = 1
(ğ‘… = Z) and ğ‘‘ = 2 (ğ‘… = Z[ğ‘¥]/(ğ‘¥2 + 1)). For a positive integer ğ‘ âˆˆ N,
we write ğ‘…ğ‘ = ğ‘…/ğ‘ğ‘…. We represent elements of ğ‘… as a vector of
coefficients (i.e., as a vector Zğ‘‘). For an element ğ‘Ÿ âˆˆ ğ‘…, we write
âˆ¥ğ‘Ÿâˆ¥âˆ to denote the â„“âˆ norm of the vector of coefficients of ğ‘Ÿ. We
write ğ›¾ğ‘… to denote the expansion constant where for all ğ‘Ÿ, ğ‘  âˆˆ ğ‘…,
we have that âˆ¥ğ‘Ÿğ‘ âˆ¥âˆ â‰¤ ğ›¾ğ‘… âˆ¥ğ‘Ÿâˆ¥âˆ âˆ¥ğ‘ âˆ¥âˆ. In particular, ğ›¾ğ‘… = 1 when
ğ‘‘ = 1 and ğ›¾ğ‘… = 2 when ğ‘‘ = 2. Finally, for a vector v âˆˆ ğ‘…ğ‘›, we write
âˆ¥vâˆ¥ğ‘ to denote the â„“ğ‘ norm âˆ¥vâ€²âˆ¥ğ‘ of the vector vâ€² âˆˆ Zğ‘‘ğ‘› formed
by concatenating the vector of coefficients of each element in v.
(Module) learning with errors. Security of our construction relies
on the module learning with errors (MLWE) assumption [40, 80]
(in addition to our linear-only conjecture). We state the MLWE
assumption in â€œnormal formâ€ where the secret is sampled from the
error distribution. This form of the problem is as hard as the version
where the secret key is sampled uniformly at random [6].
Definition 3.3 (Module Learning With Errors (MLWE) [40, 80]).
Fix a security parameter ğœ†, integers ğ‘› = ğ‘›(ğœ†), ğ‘š = ğ‘š(ğœ†), ğ‘ =
ğ‘(ğœ†), ğ‘‘ = ğ‘‘(ğœ†) where ğ‘‘ is a power of two. Let ğ‘… = Z[ğ‘¥]/(ğ‘¥ğ‘‘ +
1), ğ‘…ğ‘ = ğ‘…/ğ‘ğ‘…, and ğœ’ = ğœ’(ğœ†) be an error distribution over ğ‘…ğ‘.
The (decisional) module learning with errors (MLWE) assumption
, s â† ğœ’ğ‘›, e â† ğœ’ğ‘š,
MLWEğ‘›,ğ‘š,ğ‘‘,ğ‘,ğœ’ states that for A
and u
ğ‘ , the following two distributions are computationally
indistinguishable:
râ† ğ‘…ğ‘›Ã—ğ‘š
râ† ğ‘…ğ‘š
ğ‘
(A, sTA + eT) and (A, uT)
Remark 3.4 (Relation to LWE and RLWE). The module LWE
assumption generalizes both the classic learning with errors (LWE)
assumption [91] as well as the ring learning with errors (RLWE)
assumption [82]. In particular, LWE is MLWE instantiated with
ğ‘‘ = 1 and RLWE is MLWE instantiated with ğ‘› = 1.
Vector encryption construction. We now describe our vector en-
cryption scheme. Our scheme is an adaptation of the Regev-based [91]
scheme of Peikert et al. [89], generalized to modules and with the
following additions/modifications:
â€¢ Secret-key encryption: Since a secret-key vector encryption
suffices for our designated-verifier zkSNARK,3 we consider a
secret-key version of the scheme. This reduces the concrete cost
for encryption (we can substitute a random vector in each ci-
phertext in place of a matrix-vector product with the public key).
Note that there are still public parameters in our scheme. These
3Using a public-key encryption scheme does not imply a publicly-verifiable zkSNARK
in this setting. There is no advantage to using a public-key encryption scheme to
instantiate the underlying encryption scheme.
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea218are used for re-randomization of homomorphically-evaluated
ciphertexts, and are not used for encryption.
â€¢ Message encoding: We encode the message in the least signifi-
cant bits of the ciphertext rather than the most significant bits.
When the plaintext modulus ğ‘ and ciphertext modulus ğ‘ are
coprime, these approaches are equivalent up to scaling [2]. In
our implementation, encoding a value ğ‘˜ in the least significant
bits of the ciphertext is more convenient since we avoid the need
to compute the value âŒŠğ‘˜ Â· ğ‘/ğ‘âŒ‰ mod ğ‘ (which if implemented
improperly, can overflow our integer representation).
â€¢ Ciphertext re-randomization: For zero knowledge, we require
an additional circuit privacy property. Ciphertexts in this scheme
consist of pairs of vectors ct = (a, c). Homomorphic operations
on ciphertexts correspond to computing component-wise linear
combinations. In our construction, we include a public MLWE ma-
trix as part of the public parameters to re-randomize the vector a,
and we use standard noise smudging techniques (see Lemma A.2)
to re-randomize the vector c. Previously, Gennaro et al. [65] sug-
gest that the first component a is already random by appealing
to the leftover hash lemma; unfortunately, this only applies in
the setting where the coefficients of the linear combination have
sufficient min-entropy (which is not necessarily the case in the
zkSNARK construction). We show that in our case and under the
MLWE assumption,4 our construction provably satisfies circuit
privacy without needing any additional assumption on the choice
of linear combination.
â€¢ Ciphertext sparsification. Our linear-only definition (Defini-
tion 3.2) essentially requires that the only way an efficient ad-
versary can generate a valid ciphertext is by taking linear com-
binations of valid ciphertexts. This means that the set of valid
ciphertexts must be sparse (to prevent oblivious sampling of a
valid ciphertext). Previous works [30, 31, 64] suggest double en-
cryption to realize this property. With double encryption, valid
ciphertexts ct = (ct1, ct2) are defined as pairs of ciphertexts that
both encrypt identical messages. While this approach is applica-
ble in our setting, it doubles the length of the ciphertexts.
We propose a similar, but more efficient, approach tailored for
vector encryption. Namely, if our goal is to encrypt elements
from a vector space Fâ„“, we enlarge the plaintext space to Fâ„“+ğœ,
where ğœ is a sparsification parameter. During setup, we sample a
râ† Fâ„“Ã—ğœ which is included as part of the secret
random matrix T
key. Then, to encrypt a vector v âˆˆ Fâ„“, we instead encrypt the
vector uT = [vT | (Tv)T]. During decryption, after recovering
uT = [uT1 | uT2], the decryption algorithm outputs âŠ¥ if u2 â‰  Tu1.
Semantic security of the vector encryption scheme ensures that
the secret transformation T is computationally hidden from the
view of the adversary. By setting the sparsification parameter
ğœ accordingly, we can ensure that for any fixed vector uT =
[uT1 | uT2], the probability that u2 = Tu1 is negligible (over the
randomness of T). We conjecture that our approach also yields
an encryption scheme that satisfies the linear-only assumption.
The advantage of this approach is that the ciphertext size in the
underlying vector encryption scheme grows additively with the
4We could make this step statistical by relying on the leftover hash lemma, but this
requires much larger parameters. Instead, we rely on MLWE and settle for computa-
tional circuit privacy (which translates to computational zero knowledge).
plaintext dimension (i.e., the resulting ciphertext size is ğ‘› + â„“ + ğœ
rather than 2(ğ‘› + â„“) as with â€œencrypting twiceâ€).
We now describe our vector encryption scheme:
Construction 3.5 (Vector Encryption). Let ğ‘‘ = ğ‘‘(ğœ†) be a power
of two and let ğ‘… = Z[ğ‘¥]/(ğ‘¥ğ‘‘ + 1). Fix lattice parameters ğ‘ = ğ‘(ğœ†),
ğ‘ = ğ‘(ğœ†), ğ‘› = ğ‘›(ğœ†) and an error distribution ğœ’ = ğœ’(ğœ†) over ğ‘…ğ‘. We
additionally define the following parameters:
â€¢ â„“: the plaintext dimension
â€¢ ğœ: the sparsification parameter
â€¢ ğµ: the noise smudging bound
Let â„“â€² = â„“ + ğœ. We construct a secret-key vector encryption scheme
Î Enc = (Setup, Encrypt, Decrypt, Add) over ğ‘…ğ‘ as follows:
râ†
â€¢ Setup(1ğœ†, 1â„“): Sample matrices A
ğ‘…ğœÃ—â„“
. Output
the secret key sk = (S, T) and the public parameters pp = (A, D).
â€¢ Encrypt(sk, v): On input the secret key sk = (S, T) and a vector
ğ‘, construct the concatenated vector uT = [vT | (Tv)T] âˆˆ
v âˆˆ ğ‘…â„“
ğ‘…â„“â€²
ğ‘ , e â† ğœ’â„“â€² and compute c â† STa+ğ‘e+u âˆˆ ğ‘…â„“â€²
ğ‘ . Sample a
ğ‘ .
Output the ciphertext ct = (a, c).
â€¢ Add(pp, {ctğ‘–}ğ‘–âˆˆ[ğ‘˜], {ğ‘¦ğ‘–}ğ‘–âˆˆ[ğ‘˜]): On input the public parameters
pp = (A, D), ciphertexts ctğ‘– = (ağ‘–, cğ‘–) for ğ‘– âˆˆ [ğ‘˜], and scalars
râ† [âˆ’ğµ, ğµ]ğ‘‘â„“â€² and output
ğ‘¦ğ‘– âˆˆ ğ‘…ğ‘, sample r â† ğœ’ğ‘›, eğ‘ â† ğœ’ğ‘›, eğ‘
the ciphertext
, and E â† ğœ’ğ‘›Ã—â„“â€². Compute D â† STA+ ğ‘ET âˆˆ ğ‘…â„“â€²Ã—ğ‘›
, S â† ğœ’ğ‘›Ã—â„“â€², T
râ† ğ‘…ğ‘›
râ† ğ‘…ğ‘›Ã—ğ‘›
ğ‘
ğ‘
ğ‘
(cid:16) 
ğ‘–âˆˆ[ğ‘˜]
ğ‘¦ğ‘–ağ‘– + Ar + ğ‘eğ‘, 
ğ‘–âˆˆ[ğ‘˜]
ctâˆ— =
(cid:17).
ğ‘¦ğ‘–cğ‘– + Dr + ğ‘eğ‘
(3.3)
ğ‘. Output v1 if v2 = Tv1 âˆˆ ğ‘…ğœ
â€¢ Decrypt(sk, ct): On input the secret key sk = (S, T) and a ci-
phertext ct = (a, c), compute z â† c âˆ’ STa âˆˆ ğ‘…â„“â€²
ğ‘ . Compute
u = z mod ğ‘, and parse uT = [vT1 | vT2] where v1 âˆˆ ğ‘…â„“