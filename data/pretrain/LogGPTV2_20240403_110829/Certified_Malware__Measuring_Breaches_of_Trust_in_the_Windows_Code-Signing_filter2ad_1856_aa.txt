# Title: Certified Malware: Measuring Breaches of Trust in the Windows Code-Signing PKI

## Authors
- Doowon Kim, University of Maryland, College Park, MD, USA (Email: [PI:EMAIL])
- Bum Jun Kwon, University of Maryland, College Park, MD, USA (Email: [PI:EMAIL])
- Tudor Dumitras, University of Maryland, College Park, MD, USA (Email: [PI:EMAIL])

## Abstract
Digitally signed malware can bypass system protection mechanisms that only allow programs with valid signatures to be installed or executed. It can also evade anti-virus software, which often skips scanning signed binaries. While known from advanced threats like Stuxnet and Flame, this type of abuse has not been systematically measured in the broader malware landscape. The methods, effectiveness, and security implications of code-signing PKI abuse are not well understood. We propose a threat model that highlights three types of weaknesses in the code-signing PKI. To address the challenges specific to measuring code-signing, we introduce techniques for prioritizing the collection of potentially abusive code-signing certificates and an algorithm for distinguishing different types of threats. Our findings reveal that digitally signed malware was prevalent even before Stuxnet, with the earliest sample in our dataset signed in 2003. We discuss actionable implications and propose concrete steps to improve the security of the code-signing ecosystem.

## CCS Concepts
- Security and Privacy → Systems Security; Operating Systems Security

## Keywords
Code signing, Windows Authenticode, Malware, PKI, Compromised Certificates

## 1. Introduction
Each time we use our computers, we trust the programs we execute, either deliberately or in the background, not to perform unwanted or harmful actions. Software that appears to come from reputable publishers but performs such actions breaches this trust. To establish trust in third-party software, we currently rely on the code-signing Public Key Infrastructure (PKI). This infrastructure includes Certification Authorities (CAs) that issue certificates to software publishers, vouching for their identity. Publishers use these certificates to sign the software they release, and users rely on these signatures to decide which software packages to trust. If adversaries can compromise code-signing certificates, it has severe implications for end-host security. Signed malware can bypass system protection mechanisms and evade anti-virus programs, which often neglect to scan signed binaries. 

In the past, compromised code-signing certificates have been associated with advanced threats, likely developed by nation-state adversaries. For example, the Stuxnet worm included device drivers digitally signed with keys stolen from two Taiwanese semiconductor companies. The Flame malware masqueraded as a file from Windows Update by conducting a chosen-prefix collision attack against the MD5 cryptographic hash. In both cases, the valid digital signatures allowed the malware to evade detection and bypass protections.

Anecdotal information suggests that a broader range of malicious programs may carry valid digital signatures, resulting from compromised certificates. However, this threat has not been measured systematically. The prior research on abuse in the code-signing ecosystem has focused on potentially unwanted programs (PUPs), such as adware, which are typically signed with certificates legitimately issued to the PUP publishers. While the signed PUPs substantiate the utility of valid signatures for abusive programs, the prior results do not distinguish between certificates issued to publishers of dubious software through a legitimate process and the abuse of the code-signing PKI.

In this paper, we conduct a systematic study of threats that breach the trust encoded in the Windows code-signing PKI. We focus on signed malware, which is more likely than PUPs to rely on abusive code-signing certificates as malware creators typically try to hide their identities. Unlike the prior studies on other certificate ecosystems, such as measurements of the Web’s PKI, we cannot rely on a comprehensive corpus of code-signing certificates. These certificates cannot be collected at scale by scanning the Internet, and there is no official list of code-signing certificates or the organizations that can issue them.

To overcome these challenges, we analyze a large dataset of anti-virus reports, corresponding to 1,053,114 malicious files that carry digital signatures. This dataset is made available by Symantec on the WINE platform. By querying the VirusTotal service, this analysis allows us to prioritize the collection of code-signing certificates that are likely abusive. We also utilize global corporate directories to identify publishers of benign software and develop novel heuristics for distinguishing among different types of abuse.

We find that digitally signed malware was prevalent in the wild before Stuxnet; the earliest sample in our dataset was signed in 2003. 88.8% of the malware families using abusive certificates rely on a single certificate, suggesting that, in most cases, these certificates are controlled by the malware authors rather than by third-party "signing" services. We also estimate that 80% of the abusive certificates remain a threat for over 5.6 years after they are first used to sign malware.

To characterize the real-world breaches of trust in the code-signing PKI, we propose a threat model with three classes of weaknesses that an adversary can exploit: inadequate client-side protections, publisher-side key mismanagement, and CA-side verification failures. We infer the prevalence and evolution of each weakness and analyze how long users are exposed to these threats. Then, we conservatively select a subset of abusive code-signing certificates for in-depth investigation. Below, we highlight some of our findings from this analysis:

- **Inadequate Client-Side Protections:** We find that simply copying an Authenticode signature from a legitimate file to a known malware sample may cause anti-virus products to stop detecting it, even though the signature is invalid. 34 anti-virus products are affected, and this type of abuse accounts for 31.1% of malware signatures in the wild. We notified the anti-virus companies of the issue. Two companies confirmed that their products fail to check signatures properly; one of them plans to fix the issue.
- **Publisher-Side Key Mismanagement:** We identify 72 certificates that were likely compromised and confirmed this with eight publishers; five of them were not previously aware of the abuse. We analyze a malware family that infects developer machines and copies malicious code into files compiled and signed on those machines. We find that, starting from 180 developer machines, variants of this malware can reach 93,016 machines—an amplification factor of 517×.
- **CA-Side Verification Failures:** We identify 27 certificates issued to malicious actors impersonating legitimate companies. We utilize our findings to draw lessons about the trust we can place in unknown software packages and discuss concrete proposals for improving the code-signing ecosystem. We make the information of the abusive certificates publicly available at https://signedmalware.org. The information includes publisher names, issuer names, serial numbers, hash values of malware signed with the certificates, etc.

## 2. Problem Statement
Code signing is a mechanism for authenticating the software publisher that released a given executable program. The publisher generates a pair of cryptographic keys (public and private), computes a cryptographic hash of the executable code, and signs the hash with the private key. To prove ownership of the signing key, the publisher requests a digital certificate from a Certificate Authority (CA). The certificate includes the name of the publisher, its public key, and a few other fields, and is signed with the CA’s key. A CA may itself have a certificate signed by another CA, resulting in a trust chain that must end in a root certificate trusted by the end-user. Like any authentication token, certificates must be revoked when they are compromised. Additionally, before signing, any field of the binary may be forged, including the compilation timestamp. To prove that the certificate was valid at the time of signing, the publisher may obtain an additional signature from a Time Stamping Authority (TSA). The code signature, the certificate, and the timestamp are distributed with the binary. The user who installs the software and runs the executables can then authenticate the publisher and verify that the binary has not been tampered with after signing.

The code-signing mechanism allows users to set policies on what executables to trust, such as all executables from a set of trusted publishers, all executables for which the publisher can be identified (i.e., they are signed with a valid certificate), or all executables signed with a certificate that was valid at the time of signing. Additionally, software updates may be validated and applied automatically if they are signed with the same certificate as the original program.

Code signing relies on a Public Key Infrastructure (PKI), composed of CAs that can vouch for the identity of software publishers. Users place their trust in an ecosystem of software publishers, root CAs, and root TSAs—a large trusted computing base (TCB) that provides many opportunities for miscreants to compromise security. Like in the TLS certificate ecosystem, every CA can sign certificates for any publisher, and there is no official list of code-signing certificates or even of the organizations that can issue such certificates. Unlike TLS, code signing is employed by many different platforms and operating systems, each with its own root certificate store: Windows and macOS executables and drivers, Firefox XPIs, Android/iOS apps, Java Jars, Visual Basic for Applications, Adobe Air apps, etc. This further expands the TCB for an end user.

The TLS PKI has been the subject of several measurement studies, which have illuminated vulnerabilities of the PKI and how it is abused in the wild. These findings have stimulated research on fixing these problems and have prompted several efforts for preventing abuse, such as certificate transparency, key pinning, and DANE. In contrast, little is known about the various code-signing ecosystems, including the opportunities for breaching the trust in various actors from these ecosystems, the prevalence of real-world abuse of the PKI, and the extent to which code signing prevents security threats.

As a first step in this direction, our goal in this paper is to measure breaches of trust in the Windows code-signing PKI. An adversary can breach trust relationships explicitly, e.g., by stealing the private keys associated with benign certificates and using them to sign malware, or implicitly, e.g., by impersonating legitimate companies that do not develop software and, hence, do not own code-signing certificates. We aim to analyze the prevalence of this threat in the real world and to illuminate the mechanisms for breaching the trust. We also aim to understand the security implications of these types of abuse and to examine the effectiveness of proposed PKI improvements in defending against this threat. Our non-goals include fully characterizing the code-signing ecosystems, analyzing certificates issued legitimately to real (but perhaps ill-intentioned) publishers, or developing new techniques for authenticating executable programs.

### 2.1 Overview of Code Signing
On Windows, the prevalent code-signing standard is Microsoft Authenticode. The standard is based on Public-Key Cryptography Standard (PKCS) #7 and is used to digitally sign Windows portable executables (PE). These include installers (.msi), cabinet (.cab) and catalog (.cat) files, ActiveX controls (.ctl, and .ocx), dynamically loaded libraries (.dll), and executables (.exe). PKCS #7-formatted content is called signed data. A signed data blob includes the signature, the hash value of a PE file, and the certificate chains. The chains should end in a trusted root certificate, but the signed data does not need to include the root certificate as long as the root certificate is present in the users’ root stores. Authenticode supports MD5, SHA-1, and SHA-256 hashes.

#### Protections That Rely on Code Signing
On Windows, User Account Control (UAC) verifies the signature and includes the publisher’s name in the notification presented to the user when a program requests elevated privileges. Microsoft SmartScreen checks executable files downloaded from the web and assesses the publisher’s reputation. A publisher may also obtain an Extended Validation (EV) certificate, which must undergo stricter vetting procedures. Because of the higher degree of trust in these certificates, they receive instant reputation in SmartScreen, while standard code-signing certificates must build up their reputation to bypass the SmartScreen Filter. Google Safe Browsing is another protection system similar to SmartScreen. Chrome trusts potentially dangerous file types that match URLs in the whitelist and also trusts files signed by a trusted authority. Starting with Vista, drivers should be signed by a trusted CA to be installed on a Windows machine. From Windows 10 (version 1607), a stricter requirement is set: EV certificates are necessary for any new kernel mode drivers.

Antivirus engines also utilize code-signing information. To reduce false positives, some AV engines use whitelisting based on code-signing certificates. For example, Symantec mentions on their whitelisting page: "To prevent false positive detections, we strongly recommend that you digitally sign your software with a class 3 digital certificate."

#### Revocation
Besides issuing new certificates, CAs must sometimes revoke existing certificates for various reasons. One of the most common cases is when a private key associated with the certificate is compromised. Certificates using weak cryptographic keys must also be revoked. In rare cases, CAs must also revoke erroneously issued certificates.

CAs use two mechanisms for informing users of certificate revocations: Certificate Revocation Lists (CRLs) and the Online Certificate Status Protocol (OCSP). A CRL includes multiple certificates that have been revoked and is made available at a link specified in the certificate. These lists are not comprehensive, and users must periodically download multiple CRLs to receive all the information about revoked certificates. With OCSP, users query a server maintained by the CA to receive the revocation status of a certificate on demand. Both the CRLs and the OCSP responses are signed by the CA to ensure their integrity.

### 2.2 Differences Between Code Signing and TLS
Code signing and the TLS protocols used to secure HTTP communications utilize X.509 v3 certificates for authentication and integrity. One type of certificate should not be used for another purpose (e.g., program code cannot be signed with a TLS certificate) because its purpose is indicated in the “Key Usage” and “Extended Key Usage” fields. The latter field must include “Code Signing” for code-signing certificates and “Server Authentication” for TLS certificates.