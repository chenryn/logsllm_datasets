根据是否有代理，浏览器对请求URI的解析会有所不同。没有代理时，浏览器会获
取你输入的URI，尝试着寻找相应的IP地址。如果找到了主机名，浏览器会尝试相
应的IP地址直到获得成功的连接为止。 147
但是，如果没有找到主机，很多浏览器都会尝试着提供某种主机名自动“扩展”机
制，以防用户输入的是主机“简短”的缩写形式（回顾一下2.3.2节）。11
• 很多浏览器会尝试着加入前缀www.和后缀.com，以防用户只输入了常见Web
站点名的中间部分（比如，人们可以输入yahoo而不是www.yahoo.com）。
• 有些浏览器甚至会将未解析出来的URI传递给第三方站点，这个站点会尝试着
校正拼写错误，并给出一些用户可能希望访问的URI建议。
• 而且，大多数系统中的DNS配置允许用户只输入主机名的前缀，然后DNS会自
动搜索域名。如果用户位于域名oreilly.com的范围之内，并输入了主机名host7，
DNS会自动尝试将其与host7.oreilly.com进行匹配。这并不是完整有效的主机名。
6.5.7 没有代理时URI的解析
图6-16显示了一个在没有代理的情况下，浏览器进行主机名自动扩展的例子。在第
(2a)～(3c)步中，浏览器会去查找各种主机名，直到找到一个有效主机名为止。
（2a）浏览器通过DNS搜索主机oreilly
（2b ）失败，未知主机名
（3b）浏览器通过DNS搜索主机“www.oreilly.com”
（3c）成功！取回IP地址
DNS服务器
（1）用户向浏览器的
URI地址窗口输入oreilly
（4a）浏览器尝试着连接到一个个IP地址上去，直到成功建立连接为止
（4b）成功；连接建立
（5a）浏览器发送HTTP请求
（5b）浏览器获取HTTP响应
客户端 www.oreilly.com
（3a）浏览器进行自动扩展，将
oreilly转换成www.oreilly.com
图6-16 没有提供显式的代理时，浏览器会对部分主机名进行自动扩展
注11： 当你输入yahoo时，大多数浏览器都会自动将其扩展为www.yahoo.com。类似地，浏览器允许用户
省略前缀http://，如果省略了浏览器会自行插入。
代 理 ｜ 155
图中发生的情况如下所示。
• 在第(1)步中，用户向浏览器的URI窗口中输入oreilly。浏览器用oreilly作为主
机名，并假定默认方案为http://，默认端口为80，默认路径为“/”。
148 • 在第(2a)步中，浏览器会去查找主机oreilly。查找失败了。
• 在第(3a)步中，浏览器对主机名进行自动扩展，请求DNS解析www.oreilly.
com。这次成功了。
• 然后，浏览器成功地连接www.oreilly.com。
6.5.8 有显式代理时URI的解析
使用显式代理时，用户的URI会被直接发送给代理，所以浏览器就不再执行所有这
些便捷的扩展功能了。
如图6-17所示，有显式代理时，浏览器没有对不完整的主机名进行自动扩展。因
此，当用户在浏览器的地址窗口中输入oreilly时，发送给代理的就是http://oreilly/
（浏览器添加了默认方案和路径，但主机名和输入的一样）。
（4a）中发送的请求报文
（2a）已经显式地配置了
代理，所以浏览器会用DNS GET http://oreilly/ HTTP/1.0
去搜索代理服务器的地址 P Ur so ex ry -- ac go en nn te :c t Mi oo zn i: l lK ae /e 4p .- 7A 2l [i ev ne ] (Win98:I)
Host: oreilly
（2b）成功！获取代 Accept: */*
理服务器的IP地址 Accept-encoding: gzip
Accept-language: en
Accept-charset: iso-8859-1,*,utf-8
DNS服务器
（1）用户在浏览器的 （4b）客户端没有进行自动扩展，所以代
URI地址窗口输入oreilly 理在请求中得到的是不完整主机名
（3a）浏览器试图连接代理
（3b）成功；连接建立起来了
（4a）浏览器发送HTTP请求
客户端 代理 www.oreilly.com
（3a）浏览器进行自动扩展，
将“oreilly”转换成www.oreilly.com
图6-17 有显式代理时，浏览器不会对不完整主机名进行自动扩展
因此，有些代理会尽力尝试着去模仿浏览器的便捷服务，包括www...com自动扩
展，以及添加本地域名后缀。12
注12： 但对得到广泛共享的代理来说，知道单个用户的正确域名后缀基本上是不可能的。
156 ｜ 第6章
6.5.9 有拦截代理时URI的解析
使用不可见的拦截代理时，对主机名的解析会略有不同，因为对客户端来说，是没
有代理的！这种情况下的行为与使用服务器的情形很类似，浏览器会自动扩展主机
名，直到DNS成功为止。但如图6-18所示，建立到服务器的连接时，有一个很重
要的区别。 149
(2a)
(2b)
(3b) (5b)
(3c)
代理
DNS服务器
(1)
(4a)
(4b)
(5a)
拦截器
客户端 www.oreilly.com
(3a)
图6-18 使用拦截代理时，浏览器无法检测出已停用服务器的IP地址
图6-18显示了下列事务处理过程。
• 在第(1)步中，用户在浏览器的URI地址窗口中输入oreilly。
• 在第(2a)步中，浏览器通过DNS查找主机oreilly，但DNS服务器失败了，并回
送响应说明主机未知，如第(2b)步所示。
• 在第(3a)步中，浏览器进行了自动扩展，将oreilly转换成www.oreilly.com。在
第(3b)步中，浏览器通过DNS来查找主机www.oreilly.com。这一次，如第(3c)
步所示，DNS服务器成功了，将IP地址返回给了浏览器。
• 在第(4a)步中，客户端已经成功解析了主机名，并有了一张IP地址列表。有些
IP地址可能已经停用了，所以，通常客户端会尝试着连接每个IP地址，直到成
功为止。但对拦截代理来说，第一次连接请求就会被代理服务器拦截成功，不会
连接到原始服务器上去。客户端认为它在与Web服务器进行成功的对话，但那
个Web服务器可能甚至都不处于活跃状态。
• 当代理最终准备好与真正的原始服务器进行交互时［第(5b)步］，代理可能会发
现那个IP地址实际指向的是一个已停用的服务器。为了提供与浏览器相同级别
的容错机制，代理可以通过解析Host首部的主机名，也可以通过对IP地址的反
代 理 ｜ 157
向DNS查找来尝试其他IP地址。将浏览器配置为使用显式代理时，它们会依赖
代理的容错机制，所以对拦截和显式的代理实现来说，在DNS解析到已停用服
务器时，提供容错机制是很重要的。
6.6 追踪报文
现在，在将Web请求从客户端传送到服务器的路径上，经过两个或多个代理是很
150 常见的（参见图6-19）。比如，出于安全和节省费用的考虑，很多公司都会用缓存
代理服务器来访问因特网， 而且很多大型ISP都会使用代理缓存来提高性能并实现
各种特性。现在，有相当比例的Web请求都是通过代理转发的。同时，出于性能原
因，把内容复制到遍布全球的替代物缓存库中的情形也越来越常见了。
替代物缓存库
因特网
客户端 ISP代理 Web服务器
图6-19 访问代理和CDN 代理构建了一个两级代理层次结构
代理是由不同厂商开发的。它们有不同的特性和缺陷，由各种不同的组织负责管理。
随着代理的逐渐流行，我们要能够追踪经过代理的报文流，以检测出各种问题，其
重要性就跟追踪经过不同交换机和路由器传输的IP分组流一样。
6.6.1 Via首部
Via首部字段列出了与报文途经的每个中间节点（代理或网关）有关的信息。报文
每经过一个节点，都必须将这个中间节点添加到Via列表的末尾。
下面的Via字符串告诉我们报文流经了两个代理。这个字符串说明第一个代理名
为 proxy-62.irenes-isp.net，它实现了 HTTP/1.1 协议，第二个代理被称为
cache.joes-hardware.com，实现了HTTP/1.0：
158 ｜ 第6章
Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com
Via首部字段用于记录报文的转发，诊断报文循环，标识请求/响应链上所有发送
者的协议能力（参见图6-20）。
代理也可以用Via首部来检测网络中的路由循环。代理应该在发送一条请求之前，
在Via首部插入一个与其自身有关的独特字符串，并在输入的请求中查找这个字符
串，以检测网络中是否存在路由循环。 151
请求报文（和服务器收到的一样）
GET /index.html HTTP/1.0
Accept: text/html
Host: www.joes-hardware.com
Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com
proxy-62.irenes-isp.net cache.joes-hardware.com
客户端 (HTTP/1.1) (HTTP/1.0) www.joes-hardware.com
图6-20 Via首部实例
1. Via的语法
Via首部字段包含一个由逗号分隔的路标（waypoint）。每个路标都表示一个独立的
代理服务器或网关，且包含与那个中间节点的协议和地址有关的信息。下面是一个
带有两个路标的Via首部实例：
Via = 1.1 cache.joes-hardware.com, 1.1 proxy.irenes-isp.net
Via首部的正规语法如下所示：
Via = "Via" ":" 1#( waypoint )
waypoint = ( received-protocol received-by [ comment ] )
received-protocol = [ protocol-name "/" ] protocol-version
received-by = ( host [ ":" port ] ) | pseudonym
注意，每个Via路标中最多包含4个组件：一个可选的协议名（默认为HTTP）、一
个必选的协议版本、一个必选的节点名和一个可选的描述性注释。
• 协议名
中间节点收到的协议。如果协议为HTTP的话，协议名就是可选的。否则，要
在版本之前加上协议名，中间用“/”分隔。网关将HTTP请求连接到其他协议
（HTTPS、FTP等）时，可能会使用非HTTP协议。
代 理 ｜ 159
• 协议版本
所收到的报文版本。版本的格式与协议有关。HTTP使用的是标准版本号（1.0、
1.1等）。版本包含在Via字段中，这样，之后的应用程序就会知道前面所有中
间节点的协议能力了。
• 节点名
中间节点的主机和可选端口号（如果没有包含端口号，可以假定使用的是协议的
默认端口号）。在某些情况下，出于隐私方面的考虑，某个组织可能不愿意给出
152 真实的主机名，在这种情况下可以用一个假名来代替。
• 节点注释
进一步描述这个中间节点的可选注释。通常会在这里包含厂商和版本信息，有些
代理服务器还会在注释字段中包含一些与此设备上所发生事件有关的诊断信息。13
2. Via的请求和响应路径
请求和响应报文都会经过代理进行传输，因此，请求和响应报文中都要有 Via
首部。
请求和响应通常都是通过同一条TCP连接传送的，所以响应报文会沿着与请求报文
相同的路径回传。如果一条请求报文经过了代理A、B和C，相应的响应报文就会
通过代理C、B、A进行传输。因此，响应的Via首部基本上总是与请求的Via首
部相反（参见图6-21）。
请求Via首部
via: 1.1 A ,1.1 B, 1.1 C
A B C
客户端 服务器
响应Via首部
via: 1.1 C ,1.1 B, 1.1 A
图6-21 响应Via通常与请求Via相反
注13： 比如，缓存代理服务器中可能会包含一些成功/失败信息。
160 ｜ 第6章
3. Via与网关
有些代理会为使用非HTTP协议的服务器提供网关的功能。Via首部记录了这些协
议转换，这样，HTTP应用程序就会了解代理链上各点的协议处理能力以及所做的
协议转换了。图6-22显示了一个通过HTTP/FTP网关请求某个FTP URI的HTTP
客户端。
客户端向网关proxy.irenes-isp.net发送了一条对ftp://http-guide.com/pub/welcome.tst
的HTTP请求。作为协议网关使用的代理会用FTP协议从FTP服务器获取预期的对
象。然后代理会用下面这个Via首部字段，在一条HTTP响应中将对象回送到客户
端上去：
Via: FTP/1.0 proxy.irenes-isp.net (Traffic-Server/5.0.1-17882 [cMs f ]) 153
注意，接收到的协议是FTP。可选注释中包含有代理服务器的品牌和版本号，以及
一些厂商的诊断信息。在第8章可以读到所有与网关有关的内容。
发送给代理的HTTP请求报文
GET ftp://http-guide.com/pub/welcome.txt HTTP/1.0
FTP请求
proxy.irenes-isp.net
客户端 (HTTP/1.0) FTP响应
http-guide.com
FTP服务器
HTTP响应报文