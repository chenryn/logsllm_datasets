### Group Element and Scheme Limitations
Previous work has focused on schemes that sample group elements [34] or two orthogonal vectors [43]. However, these limitations appear to be more a result of the constraints inherent in using Pairing Product Equations (PPEs) rather than a limitation of the specific tools used.

### Unbounded PPEs
Our current scheme is limited to constructions with fixed numbers of elements and parameters. A potential extension could involve adapting our approach to an unbounded setting, similar to the work done by Ambrona et al. [10] for the generic group assumption.

### Relaxing PPE Testability
Our automation tool outputs "unknown" for the Dodis Verifiable Random Function (VRF) [26], which might seem unexpected. The VRF's verification algorithm should form a PPE testing set, but it does not appear to be PPE testable. Specifically, Rule 1 does not apply because the PRF output \( F \in G_1 \) being verified must be paired with an element \( g^a_2 \) (as opposed to just \( g_2 \)) to be compared against other established values such as \( A \in G_T \). The equation checked is of the form \( e(F, g^a_2) = A \). If \( a = 0 \) and \( A = 1 \), then \( e(F, g^a_2) = A \) holds for any value of \( F \), thus verifying nothing about \( F \). In the scheme, \( a \) is chosen at random by a trusted party, making it zero with only negligible probability, which is not a security issue. However, our current definition of PPE challenges and testability (Definitions 3.2 and 3.3) requires that a testing set outputs the correct response for all challenges, including those where \( a = 0 \). This suggests that the VRF's verification equations are insufficient under our current definitions. An interesting direction for future work would be to relax our PPE testability notion to accommodate schemes like Dodis [26], where most, but not all, inputs can be tested.

### PPE Circuits
Finally, we examine the Boyen-Waters anonymous Identity-Based Encryption (IBE) [24] example, which falls into a gray area regarding PPE testability. Our tool, AutoPPE, outputs "unknown" for this case and quickly rejects it by finding that it cannot apply Rule 2. In Definition 3.3, we define testing sets as a conjunction of PPEs. To apply Rule 2, we restrict it to polynomials of the form \( f(·) = f_1(·) \cdot u^d + f_2(·) \), where \( f_1 \) is a non-zero constant. If \( f_1 \) is a non-constant polynomial on fixed variables, the untrusted polynomial \( f \) could be verified and moved to the trusted set if we include conditional logic such as \( (F_1 = I) \Rightarrow (F = F_2) \) in the testing set. Here, \( F \) is the formal challenge variable corresponding to the untrusted polynomial \( f \), \( I \) is an identity element, and \( F_1 \) and \( F_2 \) are expressions on formal variables corresponding to trusted polynomials which evaluate to \( g^{f_1}_\alpha \) and \( g^{f_2}_\alpha \) respectively. Essentially, the rule states that if \( f_1 \) evaluates to 0 for the given challenge, then \( f \) should evaluate to the value of \( f_2 \). To include such a rule, we need to modify the definition of a testing set to be a propositional logic on PPEs (or a PPE circuit, rather than a conjunction of PPEs). Extending the notion of PPE testability in this way would make the Boyen-Waters IBE scheme [24] PPE testable, as its private key contains two polynomials of the form \( f_1(·) \cdot u_i + f_2(·) \), where \( u_i \) is an unfixed variable and \( f_1 \) is a polynomial on fixed variables. After both \( u_i \) variables are fixed (via some extended Rule 2), all variables are fixed, and it seems feasible to test the remaining polynomials with respect to the trusted set. Developing the theory and logic for PPE circuits is an exciting future direction.

### Conclusion
The ability to verify the well-formedness of a group of pairing elements (e.g., a private key) with respect to a set of trusted parameters using Pairing Product Equations (PPEs) has numerous cryptographic applications. These include the design of basic and structure-preserving signature schemes, building oblivious transfer schemes from "blind" IBE, finding new verifiable random functions, and ensuring accountability of the IBE or ABE authority to the user. In this work, we provided original observations demonstrating that it is not always easy for a human to determine whether a public-private parameter pair can be verified using PPEs. Many IBE schemes (e.g., [22, 29, 20, 45]) have PPE-testable parameters, but some, such as those based on dual-system encryption [47], do not. To aid in the use of PPE testability in cryptographic design, we devised a set of rules for systematically searching for a PPE testing set. We proved the correctness of this algorithm in Section 4.3 and provided an implementation, AutoPPE, in Section 5. Tested on over two dozen schemes, the tool's correctness and performance were solid. This allows researchers to automate the discovery of PPE testing equations, contributing to the broader goal of improving the speed and accuracy of the cryptographic design process via computer automation.

### Acknowledgments
The authors are grateful to Brent Waters for valuable technical discussions and to the anonymous reviewers of CCS 2019 for their feedback, especially for pointing out the connection to the automated analysis of structure-preserving signatures in [14].

### References
[References remain unchanged]

### Appendix: Waters05 IBE Scheme
In this section, we recall the public parameters and private keys from the Waters05 IBE scheme with Naccache’s optimization [45, 42]. A part of the text has been taken verbatim from [42]. Let \( G_1 \) be a group of prime order \( p \), and \( g \) be a group generator for \( G_1 \). Let \( e \) be an admissible bilinear map \( e : G_1 \times G_1 \rightarrow G_T \). Identities will be represented as \( n \)-dimensional vectors \( v = (v_1, \ldots, v_n) \) where each \( v_i \) is an \( l \)-bit integer. The integers \( n \) and \( l \) are parameters unrelated to \( p \), and \( n' = n \cdot l \) is the output length of a collision-resistant hash function \( H : \{0, 1\}^* \rightarrow \{0, 1\}^{n'} \).

**Setup(1λ):** Sample \( \alpha, \beta, u \) and each element of an \( n \)-dimensional vector \( U = (u_i) \) uniformly at random from \( \mathbb{Z}_p \). Set \( g_1 = g^\alpha \), \( g_2 = g^\beta \), \( z = g^u \), and \( z_i = g^{u_i} \) for each \( i \in [n] \). The public parameters \( pk \) are \( g, g_1, g_2, z, \{z_i : i \in [n]\} \). The master secret key \( msk \) is \( g_2^\alpha \).

**KeyGen(msk, v):** Let \( v = (v_1, \ldots, v_n) \in (\{0, 1\}^l)^n \) be an identity. Sample \( r \) uniformly at random in \( \mathbb{Z}_p \). The private key \( sk_v \) for identity \( v \) is constructed as:
\[ sk_v = \left( g_2^\alpha \cdot \prod_{i=1}^n z_i^{v_i}, g^r, g_1^r \right) \]