APPCONTEXT [41].
XII. CONCLUSION
We have presented a new technique for automatically
inferring interpretable semantic malware signatures from a
small number of malware samples. Our technique signiﬁcantly
improves the usability of signature-based malware detectors
by eliminating the human effort required for writing malware
signatures. Furthermore, we show that ASTROID s signature
inference algorithm enables approximate signature matching,
which is useful both for zero-day malware detection and for
making our technique more resilient to behavioral obfuscation.
We implemented our technique in a tool called ASTROID,
which we evaluated both on malicious apps in the Android
Genome Malware Project as well as on benign apps from
Google Play. Our experiments show that (i) the signatures au-
tomatically synthesized by ASTROID are better than manually-
written signatures in terms of accuracy and false positives, and
(ii) the proposed approximate signature matching algorithm
allows detecting zero-day and behaviorally- obfuscated mal-
ware with a very low false positive rate. Our tool is publicly
available [42] and can be easily used by security analysts to
synthesize malware signatures from very few samples.
ACKNOWLEDGMENTS
We would like to thank Thomas Dillig, Martin Rinard,
Tao Xie, Eric Bodden, Wei Yang and Ashay Rane for their
insightful comments. We also thank the anonymous reviewers
for their helpful feedback.
This work was supported in part by NSF Award #1453386,
AFRL Awards #8750-14-2-0270 and #8750-15-2-0096, and a
Google Ph.D. Fellowship. The views, opinions, and ﬁndings
contained in this paper are those of the authors and should not
be interpreted as representing the ofﬁcial views or policies of
the Department of Defense or the U.S. Government.
REFERENCES
[1] Mobile malware report. https://public.gdatasoftware.com/Presse/
Publikationen/Malware Reports/G DATA MobileMWR Q1
2015 US.pdf, 2015.
[2] Yu Feng, Saswat Anand, Isil Dillig, and Alex Aiken. Ap-
poscopy: Semantics-based detection of android malware through
static analysis. In FSE, pages 576–587. ACM, 2014.
[3] Daniel Arp, Michael Spreitzenbarth, Malte Hubner, Hugo Gas-
con, and Konrad Rieck. DREBIN: Effective and Explainable
Detection of Android Malware in Your Pocket. In NDSS. The
Internet Society, 2014.
[4] Mu Zhang, Yue Duan, Heng Yin, and Zhiruo Zhao. Semantics-
aware android malware classiﬁcation using weighted contextual
API dependency graphs. In CSS, pages 1105–1116. ACM.
[5] Abhijit Bose, Xin Hu, Kang G. Shin, and Taejoon Park. Be-
havioral detection of malware on mobile handsets. In MobiSys,
pages 225–238. ACM, 2008.
[6] Matt Fredrikson, Somesh Jha, Mihai Christodorescu, Reiner
Sailer, and Xifeng Yan. Synthesizing Near-Optimal Malware
In Malware, pages
Speciﬁcations from Suspicious Behaviors.
41–50. IEEE Computer Society, 2010.
[7] Yajin Zhou, Zhi Wang, Wu Zhou, and Xuxian Jiang. Hey, you,
get off of my market: Detecting malicious apps in ofﬁcial and
In NDSS. The Internet Society,
alternative android markets.
2012.
[8] William Enck, Machigar Ongtang, and Patrick Drew McDaniel.
On lightweight mobile phone application certiﬁcation. In CSS,
pages 235–245. ACM, 2009.
[9] Kent Grifﬁn, Scott Schneider, Xin Hu, and Tzi-cker Chiueh.
Automatic generation of string signatures for malware detection.
In RAID, pages 101–120. Springer, 2009.
[10] Mihai Christodorescu, Somesh Jha, Sanjit A. Seshia, Dawn Xi-
aodong Song, and Randal E. Bryant. Semantics-aware malware
detection. In S&P, pages 32–46. IEEE Computer Society, 2005.
[11] Xin Hu, Tzi-cker Chiueh, and Kang G. Shin. Large-scale
In CSS, pages
malware indexing using function-call graphs.
611–620. ACM, 2009.
[12] Hugo Gascon, Fabian Yamaguchi, Daniel Arp, and Konrad
Rieck. Structural detection of android malware using embedded
call graphs. In AISEC, pages 45–54. ACM, 2013.
[13] Hao Peng, Christopher S. Gates, Bhaskar Pratim Sarma, Ninghui
Li, Yuan Qi, Rahul Potharaju, Cristina Nita-Rotaru, and Ian
Molloy. Using probabilistic generative models for ranking risks
of android apps. In CSS, pages 241–252. ACM, 2012.
[14] Chao Yang, Zhaoyan Xu, Guofei Gu, Vinod Yegneswaran,
and Phillip A. Porras. Droidminer: Automated mining and
characterization of ﬁne-grained malicious behaviors in android
applications. In ESORICS, pages 163–182. Springer, 2014.
[15] Kai Chen, Peng Wang, Yeonjoon Lee, XiaoFeng Wang, Nan
Zhang, Heqing Huang, Wei Zou, and Peng Liu.
Finding
Unknown Malice in 10 Seconds: Mass Vetting for New Threats
at the Google-Play Scale. In USENIX Security, pages 659–674.
USENIX Association, 2015.
[16] Xuxian Jiang.
Security alert: New Android malware –
GoldDream– found in alternative app markets. http://www.csc.
ncsu.edu/faculty/jiang/GoldDream/, 2011.
[17] Chu Min Li and Felip Many`a. MaxSAT, Hard and Soft
Constraints. In Handbook of Satisﬁability, volume 185, pages
613–631. IOS Press, 2009.
[18] Joao Marques-Silva, Josep Argelich, Ana Grac¸a, and Inˆes Lynce.
Boolean lexicographic optimization: algorithms & applications.
Annals of Mathematics and Artiﬁcial Intelligence, 62(3-4):317–
343, 2011.
[19] Ruben Martins, Vasco Manquinho, and Inˆes Lynce. Open-WBO:
A Modular MaxSAT Solver. In SAT, pages 438–445. Springer,
2014.
[20] George Kastrinis and Yannis Smaragdakis. Hybrid context-
In PLDI, pages 423–434.
sensitivity for points-to analysis.
ACM, 2013.
[21] Yu Feng, Xinyu Wang, Isil Dillig, and Calvin Lin. EXPLORER :
query- and demand-driven exploration of interprocedural control
ﬂow properties. In OOPSLA, pages 520–534. ACM, 2015.
[22] Michael I Gordon, Deokhwan Kim, Jeff H Perkins, Limei
Information
In NDSS.
Gilham, Nguyen Nguyen, and Martin C Rinard.
ﬂow analysis of android applications in droidsafe.
The Internet Society, 2015.
[23] Android malware
genome
project.
http://www.
malgenomeproject.org/, 2012.
[24] VirusTotal. https://www.virustotal.com/en/, 2016.
[25] Chih-Chung Chang and Chih-Jen Lin. LIBSVM: A library
for support vector machines. ACM Transactions on Intelligent
Systems and Technology, 2, 2011.
[26] MassVet. https://bdsec.soic.indiana.edu:8080/, 2016.
[27] Proguard. https://www.guardsquare.com/en/proguard, 2016.
[28] DroidSift. https://haven.syr.edu:3000/, 2016.
[29] Young Hee Park, Douglas S. Reeves, Vikram Mulukutla, and
Balaji Sundaravel. Fast malware classiﬁcation by automated
In CSIIRW, pages 45–48. ACM,
behavioral graph matching.
2010.
[30] Mihai Christodorescu, Somesh Jha, and Christopher Kruegel.
Mining speciﬁcations of malicious behavior. In FSE, pages 5–
14. ACM, 2007.
[31] Brian Chin, Daniel von Dincklage, Vuk Ercegovac, Peter
Hawkins, Mark S. Miller, Franz Josef Och, Christopher Olston,
and Fernando Pereira. Yedalog: Exploring Knowledge at Scale.
In SNAPL, pages 63–78. LIPICS, 2015.
[32] Michael C. Grace, Yajin Zhou, Qiang Zhang, Shihong Zou,
and Xuxian Jiang. Riskranker: scalable and accurate zero-day
android malware detection. In MobiSys, pages 281–294. ACM,
2012.
[33] Steven Arzt, Siegfried Rasthofer, Christian Fritz, Eric Bod-
den, Alexandre Bartel, Jacques Klein, Yves Le Traon, Damien
Octeau, and Patrick McDaniel. Precise context, ﬂow, ﬁeld,
object-sensitive and lifecycle-aware taint analysis for android
apps. In PLDI, pages 259–269. ACM, 2014.
[34] Zhemin Yang, Min Yang, Yuan Zhang, Guofei Gu, Peng Ning,
and Xiaoyang Sean Wang. AppIntent: analyzing sensitive data
transmission in android for privacy leakage detection. In CSS,
pages 1043–1054. ACM, 2013.
[35] Mingyuan Xia, Lu Gong, Yuanhao Lyu, Zhengwei Qi, and Xue
Liu. Effective real-time android application auditing. In S&P,
pages 899–914. IEEE Computer Society, 2015.
[36] William Enck, Peter Gilbert, Byung-Gon Chun, Landon P. Cox,
Jaeyeon Jung, Patrick McDaniel, and Anmol Sheth. Taintdroid:
An information-ﬂow tracking system for realtime privacy mon-
In OSDI, pages 393–407. USENIX
itoring on smartphones.
Association, 2010.
[37] Lok-Kwong Yan and Heng Yin. Seamlessly reconstructing the
OS and dalvik semantic views for dynamic android malware
analysis. In USENIX Security, pages 569–584. USENIX Asso-
ciation, 2012.
[38] Long Lu, Zhichun Li, Zhenyu Wu, Wenke Lee, and Guofei
Jiang. CHEX: statically vetting android apps for component
hijacking vulnerabilities. In CSS, pages 229–240. ACM, 2012.
[39] Damien Octeau, Patrick McDaniel, Somesh Jha, Alexandre
Bartel, Eric Bodden, Jacques Klein, and Yves Le Traon. Effec-
tive inter-component communication mapping in android: An
In USENIX
essential step towards holistic security analysis.
Security, pages 543–558. USENIX Association, 2013.
[40] Dan Caselden, Alex Bazhanyuk, Mathias Payer, Stephen McCa-
mant, and Dawn Song. HI-CFG: construction by binary analysis
In ESORICS, pages
and application to attack polymorphism.
164–181. Springer, 2013.
[41] Wei Yang, Xusheng Xiao, Benjamin Andow, Sihan Li, Tao Xie,
and William Enck. AppContext: Differentiating Malicious and
Benign Mobile App Behaviors Using Context. In ICSE, pages
303–313. IEEE Computer Society, 2015.
[42] Astroid. https://utopia-group.github.io/astroid/, 2016.
[43] Smart phone malware: The six worst offenders. http://tinyurl.
com/huaor8y, 2011.
[44] Fake android apps.
article, 2016.
http://us.norton.com/fake-android-apps/
APPENDIX
APPENDIX A: INTERPRETABILITY OF EXPLANATIONS
In this section, we describe the explanations for the Gold-
Dream malware family generated by ASTROID, DREBIN and
MASSVET, which are shown in Figure 7. In particular, we
14
V = {r : receiver, s : service}
X = {(SYSTEM, r), (r, s)}
Y =
(SYSTEM, r, IntentFilter(BOOT_COMPLETED)),
(SYSTEM, r, IntentFilter(SMS_RECEIVED)),
(SYSTEM, r, IntentFilter(PHONE_STATE)),
(SYSTEM, r, IntentFilter(NEW_OUTGOING_CALL)),
(s, s, SuspiciousAPI(sendTextMessage)),
(s, s, TaintFlow(DeviceID, Internet)),
(s, s, TaintFlow(SubscriberID, Internet)),
(s, s, TaintFlow(File, Internet)),
(s, s, TaintFlow(SimSerial, Internet))
ASTROID
SuspiciousAPI(sendSMS) (1.07)
NetworkAddress(lebar.gicp.net) (0.93)
Permission(DELETE_PACKAGES) (0.58)
IntentFilter(SMS_RECEIVED) (0.56)
SuspiciousAPI(getSubscriberID) (0.53)
onReceive → createFromPdu
onReceive → getOriginatingAddress
onReceive → getDisplayMessageBody
DREBIN
MASSVET
Fig. 7: Explanations produced by each tool for the GoldDream family.
discuss how a security analyst might use these explanations
to pinpoint and understand the malicious behaviors of Gold-
Dream malware.
The left-hand side of Figure 7 shows the signature synthe-
sized by ASTROID for the GoldDream malware family. This
signature conveys a wealth of information about the malware
family to the auditor:
Components. Simply by looking at
the vertices V in the
signature, the auditor sees that the malware consists of two
components: a receiver r and a service s. Furthermore, the
inter-component call relations X convey that r is called by
the Android framework (denoted by the vertex SYSTEM), and
s is subsequently called by r.
Triggers. The metadata Y encodes intent ﬁlters registered
by each receiver. For the GoldDream family,
the receiver
r can be triggered by a variety of common system events
including BOOT_COMPLETED (triggered when the app starts)
and SMS_RECEIVED (triggered when an SMS message is
received).
Malice. The metadata Y also encodes malicious behaviors
associated with the relevant components. For the GoldDream
family, this includes suspicious API calls (e.g., the service s
calls sendTextMessage) and information leaks (e.g., the
service s leaks the device ID to the Internet).
In summary, the signature inferred by ASTROID encodes
that members of the GoldDream family contain a receiver
triggered by common system events, and this receiver calls
a service that leaks sensitive information to the Internet.
Unlike ASTROID, DREBIN and MASSVET do not charac-
terize the malice corresponding to a particular malware family.
Instead, they produce explanations for why a speciﬁc app
might be malicious.
Comparison to Drebin. The explanation produced by DREBIN
consists of a list of the features most indicative of malicious
behavior together with weights indicating their relative signif-
icance. Figure 7 (middle) shows this list of top features and
corresponding weights for the GoldDream family (obtained by
averaging over all members of the family). The most signiﬁcant
feature is the call to the suspicious API sendSMS. Only
6.6% of benign apps in the Drebin dataset call sendSMS,
but 92.8% of GoldDream malware make this call. Therefore,
calling sendSMS is a good statistical signal that an app is
malicious, but it does not give conclusive evidence of malice.
Unlike ASTROID, DREBIN fails to pinpoint any malicious
components, intent ﬁlters, and information leaks, let alone the
complex relationships between these entities.
The presence of the network address lebar.gicp.net
might be a more conclusive signal of malice, but
if this
feature were used to ﬁlter apps on Google play, then malware
developers would quickly learn to obfuscate it. In contrast,
ASTROID solely relies on semantic features of apps that are
signiﬁcantly harder to obfuscate.
Comparison to MassVet. The explanation produced by
MASSVET consists of a set of method calls added as part of
the repackaging process. These method calls typically do not
pinpoint the malicious functionality in the app. For example,
the explanation produced by MASSVET for an instance of the
GoldDream family is shown in Figure 7 (right). It consists
of a list of calls to APIs that MASSVET considers suspicious.
While these API calls play a role in the malicious functionality
of this app, they are also commonly used by benign apps to
process SMS messages, and do not capture the overall malice
present in this app.
In addition, we believe the results produced by ASTROID
confer a number of other beneﬁts:
Malware family. Unlike DREBIN and MASSVET, which can
only identify whether an app is malicious or benign, ASTROID
determines which malware family the app belongs to. Since
some malware families are more malicious than others, the
ability to categorize different apps into malware families pro-
vides ﬁner-grained information about the threat level compared
binary classiﬁcation as malicious vs. benign. For instance,
some malware families merely affect user experience [43]
whereas others introduce ﬁnancial risks by stealing user’s
personal account or credit card information [44].
Disinfection. Since ASTROID pinpoints the malicious compo-
nents in the malicious app, it can be used to “disinfect” the
app by removing these malicious components.
15