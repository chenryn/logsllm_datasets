each of its components. For conditionals, the leakage is ifğ‘(â„“ğ‘’, â„“ğ‘ğ‘),
so it contains the leakage â„“ğ‘’ generated by the evaluation of the
condition, the value ğ‘ of the condition and the leakage â„“ğ‘ğ‘ generated
by the evaluation of the taken branch. We have two rules for the
evaluation of loop instructions. If the condition evaluates to false,
the loop exits and the leakage is whilef(â„“ğ‘’). Otherwise the leakage is
whilet(â„“ğ‘’, â„“ğ‘, â„“ğ‘¤), where â„“ğ‘ is the leakage generated by the body and
â„“ğ‘¤ is the leakage obtained by iterating the loop. The instrumented
semantics is deterministic, both with respect to states and with
respect to leakages.
5.2 Leakage transformers
In order to instrument all compilation passes of the Jasmin com-
piler from source to assembly, we have introduced three different
languages of leakage transformers. The one that is presented in
this paper covers all passes but two: the linearization and assembly
generation passes use dedicated languages of leakage transformers,
as the leakages for linear and assembly programs are fundamentally
different than the leakage of structured Jasmin programs.
The (partial) syntax of leakage transformers is shown in Figure 7.
Naturally, the syntax distinguishes between leakage transformers
for expressions (ğœğ‘’), instructions (ğœ) and accessed addresses (ğœğ‘ ).
Informally, leakage transformers are functions that take a source
leakage and return a target leakage. This intuition is made formal
using three interpretations âŸ¦ğœğ‘’âŸ§â„“ğ‘’
ğ‘’ (for expressions), âŸ¦ğœâŸ§â„“ (for in-
structions) and âŸ¦ğœğ‘ âŸ§ğ‘£sp
(for accessed addresses) where ğ‘£sp is the
value of stack pointer. Their formal definitions are provided Fig-
ure 8.
We start by explaining the syntax and semantics of leakage
transformers for instructions. First, observe that many (but not
all) compilation passes are structure-preserving and are defined
recursively on the structure of the program. For such passes, the
compilation of instructions consists of applying a transformation
on its sub-expressions and sub-instructions. In this case, the leakage
of the resulting instruction will also have the same structure as the
source leakage, and only its sub-components will be modified. To
account for these cases, the syntax of leakage transformer includes
ğ‘ 
ğ‘’
a constructor per instruction. This constructor will recursively tra-
verse leakage without modifying its structure and only applying
the transformation on the sub-leakages. The sub-transformations
are themselves described using leakage transformers. For example,
the leakage transformer ğœğ‘‘ := ğœğ‘’ will expect a leakage of the form
â„“ğ‘‘ := â„“ğ‘’ and will apply its sub-transformers to the sub-leakages
so that the resulting leakage will be of the form âŸ¦ğœğ‘‘âŸ§â„“ğ‘‘
:= âŸ¦ğœğ‘’âŸ§â„“ğ‘’
ğ‘’ .
For conditional instructions, the leakage transformer if(ğœğ‘’, ğœğ‘¡ğ‘¡ , ğœğ‘“ğ‘“ )
is built from leakage transformers for the condition and for each
branch. Notice that only ğœğ‘¡ğ‘¡ or ğœğ‘“ğ‘“ will be used to transform the leak-
age (depending on which branch will be taken, but this cannot be
known at compile-time). It is the interpretation of âŸ¦if(ğœğ‘’, ğœğ‘¡ğ‘¡ , ğœğ‘“ğ‘“ )âŸ§
that selects which leakage transformer should be used. The trans-
formers ğœ; ğœâ€² (sequence) and while(ğœğ‘’, ğœ) (loop) work similarly.
In addition, we have leakage transformers corresponding to a
change in the control flow of a program. The first transformer of
this kind is remove which is used when an instruction is removed,
e.g. in dead-code elimination. Assume that we have a program
of the form ğ‘–; ğ‘, let ğ‘â€² and ğœ be the code and leakage transformer
obtained by the compilation of ğ‘. Assume that the compiler is able
to statically prove that the instruction ğ‘– is redundant, then the
compiler will remove it and the compilation of ğ‘–; ğ‘ will be ğ‘â€². The
leakage of the ğ‘–; ğ‘ (resp. ğ‘â€²) is of the form â„“ğ‘–; â„“ğ‘ (resp. â„“ğ‘â€²). In this
case, the leakage transformer for ğ‘–; ğ‘ can be remove; ğœ. The remove
will throw away â„“ğ‘– and then ğœ will be used to transform â„“ğ‘ into â„“ğ‘â€².
The transformer cevalğ‘ is used when a conditional instruction
is replaced by one of its branches. This is typically used when the
compiler replaces an instruction if ğ‘’ then ğ‘ğ‘¡ğ‘¡ else ğ‘ ğ‘“ğ‘“ by ğ‘ğ‘ when
the value of ğ‘’ is statically known to be equal to ğ‘.
We also have leakage transformers corresponding to loop un-
rolling and inlining of function calls. They are not described here
for space reasons. Another kind of leakage transformer is when the
compiler replaces one instruction by a sequence of instructions, as
in the instruction-selection pass of the Jasmin compiler. We will
provide more explanation of them in section 5.4.
We now turn to leakage transformers for expressions. Broadly
speaking, these transformers work similarly. We have a leakage
transformer that is used for recursion (ğœ1
ğ‘’ ), â€¢ produces the
constant leakage â€¢, and id is used when the compiler does not
modify the expression, so its leakage remains the same. We also
use two other leakage transformers ğœ‹ğ‘– and ğœ1
ğ‘’ . The first allows
access to sub-leakage, and the second allows to compose leakage
transformers. The following table illustrates their usage with small
examples based on constant propagation on expressions:
ğ‘’ , . . . , ğœğ‘›
ğ‘’ â—¦ ğœ2
Expression
source
0 Ã— ğ‘’
0 + ğ‘’
ğ‘’1 + ğ‘’2
ğ‘’1 + ğ‘’2
target
0
ğ‘’
ğ‘’â€²
1 + ğ‘’â€²
2
ğ‘’â€²
2
Leakage
transformer
â€¢
ğœ‹2
(ğœ1
ğ‘’)
ğ‘’ , ğœ2
ğœ‹2 â—¦ ğœ2
ğ‘’
Leakage
source
(â€¢, â„“)
(â€¢, â„“)
(â„“1, â„“2)
(â„“1, â„“2)
target
â€¢
â„“
(â„“â€²
1, â„“â€²
2)
â„“â€²
2
In the second line, the sub-expression ğ‘’ is not modified, so the leak-
age transformer is a projection. In the third line, the addition is kept,
and both sub-expressions are transformed, so we use a structural
leakage transformer to combine the leakage transformers corre-
sponding to the sub-expressions. In the fourth line, the addition
Session 2B: Formal Analysis and Verification CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea467ğœğ‘’ ::= â€¢
|
id
| ğœğ‘’ â—¦ ğœğ‘’
| ğœ‹ğ‘–
| (ğœğ‘’, . . . , ğœğ‘’) map
| rev
| (ğœğ‘’; . . . ; ğœğ‘’)
| ğ¶(ğœğ‘ )
| ğ¼ (ğ‘¥ â†¦â†’ ğœğ‘ )
empty
identity
composition
projection
reverse
sequence
constant addr
indexed addr
ğœğ‘  ::= cst(ğ‘)
| sp
| ğœğ‘  + ğœğ‘ 
| ğœğ‘  Ã— ğœğ‘ 
| ğ‘¥
constant
stack pointer
addition
multiplication
variable
ğœ := ğœğ‘’ := ğœğ‘’
assign
if(ğœğ‘’, ğœ, ğœ)
|
cond
| while(ğœğ‘’, ğœ) while
| ğœ; ğœ
sequence
| remove
remove
| cevalğ‘ ğœ
cond-eval
|
...
. . .
Figure 7: Leakage Transformers
is removed (as in the second line), and the second sub-expression
is recursively transformed, so we compose a projection with the
leakage transformer for the sub-expression.
5.3 Formal statement
The correctness proof of leakage transformers is stated as follows.
For each source program ğ‘, if the compilation succeeds and pro-
duces target program ğ‘ and leakage transformer ğœ, then for every
instrumented execution of the source producing a leakage â„“ then
the instrumented execution of the target program is defined and
produces a target leakage, which is equal to the leakage obtained
by applying the leakage transformer to the source leakage.
Theorem 5.1 (Instrumented correctness).
ğ‘ : ğ‘  â‡“â„“ ğ‘ â€² =â‡’ ğ‘ : ğ‘  â‡“âŸ¦ğœâŸ§â„“ ğ‘ â€².
The Jasmin compiler and its correctness proof are structured as
a sequence of passes â€”depicted on Figure 1. Each pass is indepen-
dently verified and comes with its dedicated correctness theorem
and proof: we update them all to turn them into instrumented cor-
rectness. The modification boils down to proving that the function
âŸ¦.âŸ§.
ğ‘’ and âŸ¦.âŸ§. compute the correct leakage based on the source
leakage.
These passes modify the compiled program in various ways: they
may preserve its structure or change it; they may even completely
remove some instructions. The leakage transformers are designed
to cover all these kind of transformations. We concisely designed
the leak transformers so that a single leakage transformer can serve
the purpose of multiple compiler passes.
Most of the passes preserve or reduce the leakage; they can be
justified using the leakage transformers presented in Section 5.2.
Notable exceptions are the two final passes (linearization and as-
sembly generation); they produce unstructured programs (that do
not follow the syntax described in this paper) and therefore require
a specific set of leakage transformers. Nonetheless, even though
the correctness proofs of these passes are a bit tricky; extending
them to the instrumented semantics is relatively easier.
In the rest of this section, we put the emphasis on two special
cases: instruction selection3 and stack allocation.
3This pass is also referred to as lowering in the Jasmin literature.
Leakage transformers for expressions:
âŸ¦â€¢âŸ§â„“ğ‘’
ğ‘’ = â€¢
âŸ¦ğ‘–ğ‘‘âŸ§â„“ğ‘’
ğ‘’ = â„“ğ‘’
= (â„“ğ‘›, . . . , â„“1)
ğ‘’
âŸ¦ğœ‹ğ‘–âŸ§(â„“1,...,â„“ğ‘›)
âŸ¦ğœğ‘–âŸ§â„“ğ‘–
= â„“ğ‘–
ğ‘’ = â„“â€²
âŸ¦(ğœ1, . . . , ğœğ‘›)âŸ§(â„“1,...,â„“ğ‘›)
ğ‘–
ğ‘’
âŸ¦revâŸ§(â„“1,...,â„“ğ‘›)
ğ‘’ = â„“â€²
ğ‘’ = (â„“â€²
âŸ¦ğœğ‘–âŸ§â„“
âŸ¦(ğœ1; . . . ; ğœğ‘›)âŸ§â„“
ğ‘–
1, . . . , â„“â€²
ğ‘›)
ğ‘’ = â„“â€²
âŸ¦ğœ1âŸ§â„“ğ‘’
ğ‘’ = âŸ¦ğœ2âŸ§â„“â€²
âŸ¦ğœ1 â—¦ ğœ2âŸ§â„“ğ‘’
ğ‘’
ğ‘’
ğ‘’
ğ‘’
= (â„“â€²
1, . . . , â„“â€²
ğ‘›)
âŸ¦ğœğ‘  [ğ‘–/ğ‘¥]âŸ§ğ‘£sp
âŸ¦ğ¼ (ğ‘¥ â†¦â†’ ğœğ‘ )âŸ§[ğ‘–]
âŸ¦ğœğ‘ âŸ§ğ‘£sp
âŸ¦ğ¶(ğœğ‘ )âŸ§â„“ğ‘’
ğ‘  = ğ‘
ğ‘’ = âˆ—ğ‘
ğ‘  = ğ‘
ğ‘’ = âˆ—ğ‘
Transformers creating address leakage:
âŸ¦cst(ğ‘)âŸ§ğ‘£sp
ğ‘  = ğ‘
âŸ¦spâŸ§ğ‘£sp
ğ‘  = ğ‘£sp
âŸ¦ğœğ‘ 1 + ğœğ‘ 2âŸ§ğ‘£sp
ğ‘  = âŸ¦ğœğ‘ 1âŸ§ğ‘£sp
ğ‘  + âŸ¦ğœğ‘ 2âŸ§ğ‘£sp
ğ‘ 
âŸ¦ğœğ‘ 1 Ã— ğœğ‘ 2âŸ§ğ‘£sp
ğ‘  = âŸ¦ğœğ‘ 1âŸ§ğ‘£sp
ğ‘  Ã— âŸ¦ğœğ‘ 2âŸ§ğ‘£sp
ğ‘ 
Leakage transformers for instructions:
ğ‘’ = â„“â€²
âŸ¦ğœğ‘‘âŸ§â„“ğ‘‘
âŸ¦ğœğ‘’âŸ§â„“ğ‘’
âŸ¦ğœğ‘‘ := ğœğ‘’âŸ§â„“ğ‘‘ :=â„“ğ‘’ = â„“â€²
ğ‘’ = â„“â€²
ğ‘‘ := â„“â€²
ğ‘‘
ğ‘’
ğ‘’
âŸ¦removeâŸ§â„“ = {}
âŸ¦ğœğ‘’âŸ§â„“ğ‘’
ğ‘’ = â„“â€²
âŸ¦ğœğ‘âŸ§â„“ğ‘ = â„“â€²
âŸ¦if(ğœğ‘’, ğœğ‘¡ğ‘¡ , ğœğ‘“ğ‘“ )âŸ§ifğ‘ (â„“ğ‘’ ,â„“ğ‘) = ifğ‘ (â„“â€²
ğ‘
ğ‘’
ğ‘’, â„“â€²
ğ‘)
âŸ¦ğœğ‘’âŸ§â„“ğ‘’
âŸ¦ğœâŸ§â„“ğ‘ = â„“â€²
ğ‘’ = â„“â€²
âŸ¦while(ğœğ‘’, ğœ)âŸ§whilet(â„“ğ‘’ ,â„“ğ‘ ,â„“ğ‘¤) = whilet(â„“â€²
âŸ¦while(ğœğ‘’, ğœ)âŸ§â„“ğ‘¤ = â„“â€²
ğ‘, â„“â€²
ğ‘¤)
ğ‘’, â„“â€²
ğ‘’
ğ‘
ğ‘¤
âŸ¦ğœğ‘’âŸ§â„“ğ‘’
ğ‘’ = â„“â€²
ğ‘’
âŸ¦while(ğœğ‘’, ğœ)âŸ§whilef (â„“ğ‘’ ) = whilef (â„“â€²
ğ‘’)
âŸ¦ğœğ‘–âŸ§â„“ğ‘– = â„“â€²
ğ‘–
âŸ¦ğœâŸ§â„“ğ‘ = â„“â€²
ğ‘
âŸ¦ğœ1; . . . ; ğœğ‘›âŸ§â„“1;. . . ;â„“ğ‘› = â„“â€²
1; . . . ; â„“â€²
ğ‘›
âŸ¦cevalğ‘ ğœâŸ§ifğ‘ (â„“ğ‘’ ,â„“ğ‘) = â„“â€²
ğ‘
Figure 8: Semantics for leakage transformers
5.4 Focus on instruction selection
Instruction selection (a.k.a. lowering) replaces high-level construc-