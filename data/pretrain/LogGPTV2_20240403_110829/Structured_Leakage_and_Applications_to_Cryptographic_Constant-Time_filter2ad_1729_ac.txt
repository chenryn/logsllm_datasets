each of its components. For conditionals, the leakage is if𝑏(ℓ𝑒, ℓ𝑐𝑏),
so it contains the leakage ℓ𝑒 generated by the evaluation of the
condition, the value 𝑏 of the condition and the leakage ℓ𝑐𝑏 generated
by the evaluation of the taken branch. We have two rules for the
evaluation of loop instructions. If the condition evaluates to false,
the loop exits and the leakage is whilef(ℓ𝑒). Otherwise the leakage is
whilet(ℓ𝑒, ℓ𝑐, ℓ𝑤), where ℓ𝑐 is the leakage generated by the body and
ℓ𝑤 is the leakage obtained by iterating the loop. The instrumented
semantics is deterministic, both with respect to states and with
respect to leakages.
5.2 Leakage transformers
In order to instrument all compilation passes of the Jasmin com-
piler from source to assembly, we have introduced three different
languages of leakage transformers. The one that is presented in
this paper covers all passes but two: the linearization and assembly
generation passes use dedicated languages of leakage transformers,
as the leakages for linear and assembly programs are fundamentally
different than the leakage of structured Jasmin programs.
The (partial) syntax of leakage transformers is shown in Figure 7.
Naturally, the syntax distinguishes between leakage transformers
for expressions (𝜏𝑒), instructions (𝜏) and accessed addresses (𝜏𝑠).
Informally, leakage transformers are functions that take a source
leakage and return a target leakage. This intuition is made formal
using three interpretations ⟦𝜏𝑒⟧ℓ𝑒
𝑒 (for expressions), ⟦𝜏⟧ℓ (for in-
structions) and ⟦𝜏𝑠⟧𝑣sp
(for accessed addresses) where 𝑣sp is the
value of stack pointer. Their formal definitions are provided Fig-
ure 8.
We start by explaining the syntax and semantics of leakage
transformers for instructions. First, observe that many (but not
all) compilation passes are structure-preserving and are defined
recursively on the structure of the program. For such passes, the
compilation of instructions consists of applying a transformation
on its sub-expressions and sub-instructions. In this case, the leakage
of the resulting instruction will also have the same structure as the
source leakage, and only its sub-components will be modified. To
account for these cases, the syntax of leakage transformer includes
𝑠
𝑒
a constructor per instruction. This constructor will recursively tra-
verse leakage without modifying its structure and only applying
the transformation on the sub-leakages. The sub-transformations
are themselves described using leakage transformers. For example,
the leakage transformer 𝜏𝑑 := 𝜏𝑒 will expect a leakage of the form
ℓ𝑑 := ℓ𝑒 and will apply its sub-transformers to the sub-leakages
so that the resulting leakage will be of the form ⟦𝜏𝑑⟧ℓ𝑑
:= ⟦𝜏𝑒⟧ℓ𝑒
𝑒 .
For conditional instructions, the leakage transformer if(𝜏𝑒, 𝜏𝑡𝑡 , 𝜏𝑓𝑓 )
is built from leakage transformers for the condition and for each
branch. Notice that only 𝜏𝑡𝑡 or 𝜏𝑓𝑓 will be used to transform the leak-
age (depending on which branch will be taken, but this cannot be
known at compile-time). It is the interpretation of ⟦if(𝜏𝑒, 𝜏𝑡𝑡 , 𝜏𝑓𝑓 )⟧
that selects which leakage transformer should be used. The trans-
formers 𝜏; 𝜏′ (sequence) and while(𝜏𝑒, 𝜏) (loop) work similarly.
In addition, we have leakage transformers corresponding to a
change in the control flow of a program. The first transformer of
this kind is remove which is used when an instruction is removed,
e.g. in dead-code elimination. Assume that we have a program
of the form 𝑖; 𝑐, let 𝑐′ and 𝜏 be the code and leakage transformer
obtained by the compilation of 𝑐. Assume that the compiler is able
to statically prove that the instruction 𝑖 is redundant, then the
compiler will remove it and the compilation of 𝑖; 𝑐 will be 𝑐′. The
leakage of the 𝑖; 𝑐 (resp. 𝑐′) is of the form ℓ𝑖; ℓ𝑐 (resp. ℓ𝑐′). In this
case, the leakage transformer for 𝑖; 𝑐 can be remove; 𝜏. The remove
will throw away ℓ𝑖 and then 𝜏 will be used to transform ℓ𝑐 into ℓ𝑐′.
The transformer ceval𝑏 is used when a conditional instruction
is replaced by one of its branches. This is typically used when the
compiler replaces an instruction if 𝑒 then 𝑐𝑡𝑡 else 𝑐 𝑓𝑓 by 𝑐𝑏 when
the value of 𝑒 is statically known to be equal to 𝑏.
We also have leakage transformers corresponding to loop un-
rolling and inlining of function calls. They are not described here
for space reasons. Another kind of leakage transformer is when the
compiler replaces one instruction by a sequence of instructions, as
in the instruction-selection pass of the Jasmin compiler. We will
provide more explanation of them in section 5.4.
We now turn to leakage transformers for expressions. Broadly
speaking, these transformers work similarly. We have a leakage
transformer that is used for recursion (𝜏1
𝑒 ), • produces the
constant leakage •, and id is used when the compiler does not
modify the expression, so its leakage remains the same. We also
use two other leakage transformers 𝜋𝑖 and 𝜏1
𝑒 . The first allows
access to sub-leakage, and the second allows to compose leakage
transformers. The following table illustrates their usage with small
examples based on constant propagation on expressions:
𝑒 , . . . , 𝜏𝑛
𝑒 ◦ 𝜏2
Expression
source
0 × 𝑒
0 + 𝑒
𝑒1 + 𝑒2
𝑒1 + 𝑒2
target
0
𝑒
𝑒′
1 + 𝑒′
2
𝑒′
2
Leakage
transformer
•
𝜋2
(𝜏1
𝑒)
𝑒 , 𝜏2
𝜋2 ◦ 𝜏2
𝑒
Leakage
source
(•, ℓ)
(•, ℓ)
(ℓ1, ℓ2)
(ℓ1, ℓ2)
target
•
ℓ
(ℓ′
1, ℓ′
2)
ℓ′
2
In the second line, the sub-expression 𝑒 is not modified, so the leak-
age transformer is a projection. In the third line, the addition is kept,
and both sub-expressions are transformed, so we use a structural
leakage transformer to combine the leakage transformers corre-
sponding to the sub-expressions. In the fourth line, the addition
Session 2B: Formal Analysis and Verification CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea467𝜏𝑒 ::= •
|
id
| 𝜏𝑒 ◦ 𝜏𝑒
| 𝜋𝑖
| (𝜏𝑒, . . . , 𝜏𝑒) map
| rev
| (𝜏𝑒; . . . ; 𝜏𝑒)
| 𝐶(𝜏𝑠)
| 𝐼 (𝑥 ↦→ 𝜏𝑠)
empty
identity
composition
projection
reverse
sequence
constant addr
indexed addr
𝜏𝑠 ::= cst(𝑝)
| sp
| 𝜏𝑠 + 𝜏𝑠
| 𝜏𝑠 × 𝜏𝑠
| 𝑥
constant
stack pointer
addition
multiplication
variable
𝜏 := 𝜏𝑒 := 𝜏𝑒
assign
if(𝜏𝑒, 𝜏, 𝜏)
|
cond
| while(𝜏𝑒, 𝜏) while
| 𝜏; 𝜏
sequence
| remove
remove
| ceval𝑏 𝜏
cond-eval
|
...
. . .
Figure 7: Leakage Transformers
is removed (as in the second line), and the second sub-expression
is recursively transformed, so we compose a projection with the
leakage transformer for the sub-expression.
5.3 Formal statement
The correctness proof of leakage transformers is stated as follows.
For each source program 𝑝, if the compilation succeeds and pro-
duces target program 𝑝 and leakage transformer 𝜏, then for every
instrumented execution of the source producing a leakage ℓ then
the instrumented execution of the target program is defined and
produces a target leakage, which is equal to the leakage obtained
by applying the leakage transformer to the source leakage.
Theorem 5.1 (Instrumented correctness).
𝑝 : 𝑠 ⇓ℓ 𝑠′ =⇒ 𝑝 : 𝑠 ⇓⟦𝜏⟧ℓ 𝑠′.
The Jasmin compiler and its correctness proof are structured as
a sequence of passes —depicted on Figure 1. Each pass is indepen-
dently verified and comes with its dedicated correctness theorem
and proof: we update them all to turn them into instrumented cor-
rectness. The modification boils down to proving that the function
⟦.⟧.
𝑒 and ⟦.⟧. compute the correct leakage based on the source
leakage.
These passes modify the compiled program in various ways: they
may preserve its structure or change it; they may even completely
remove some instructions. The leakage transformers are designed
to cover all these kind of transformations. We concisely designed
the leak transformers so that a single leakage transformer can serve
the purpose of multiple compiler passes.
Most of the passes preserve or reduce the leakage; they can be
justified using the leakage transformers presented in Section 5.2.
Notable exceptions are the two final passes (linearization and as-
sembly generation); they produce unstructured programs (that do
not follow the syntax described in this paper) and therefore require
a specific set of leakage transformers. Nonetheless, even though
the correctness proofs of these passes are a bit tricky; extending
them to the instrumented semantics is relatively easier.
In the rest of this section, we put the emphasis on two special
cases: instruction selection3 and stack allocation.
3This pass is also referred to as lowering in the Jasmin literature.
Leakage transformers for expressions:
⟦•⟧ℓ𝑒
𝑒 = •
⟦𝑖𝑑⟧ℓ𝑒
𝑒 = ℓ𝑒
= (ℓ𝑛, . . . , ℓ1)
𝑒
⟦𝜋𝑖⟧(ℓ1,...,ℓ𝑛)
⟦𝜏𝑖⟧ℓ𝑖
= ℓ𝑖
𝑒 = ℓ′
⟦(𝜏1, . . . , 𝜏𝑛)⟧(ℓ1,...,ℓ𝑛)
𝑖
𝑒
⟦rev⟧(ℓ1,...,ℓ𝑛)
𝑒 = ℓ′
𝑒 = (ℓ′
⟦𝜏𝑖⟧ℓ
⟦(𝜏1; . . . ; 𝜏𝑛)⟧ℓ
𝑖
1, . . . , ℓ′
𝑛)
𝑒 = ℓ′
⟦𝜏1⟧ℓ𝑒
𝑒 = ⟦𝜏2⟧ℓ′
⟦𝜏1 ◦ 𝜏2⟧ℓ𝑒
𝑒
𝑒
𝑒
𝑒
= (ℓ′
1, . . . , ℓ′
𝑛)
⟦𝜏𝑠 [𝑖/𝑥]⟧𝑣sp
⟦𝐼 (𝑥 ↦→ 𝜏𝑠)⟧[𝑖]
⟦𝜏𝑠⟧𝑣sp
⟦𝐶(𝜏𝑠)⟧ℓ𝑒
𝑠 = 𝑝
𝑒 = ∗𝑝
𝑠 = 𝑝
𝑒 = ∗𝑝
Transformers creating address leakage:
⟦cst(𝑝)⟧𝑣sp
𝑠 = 𝑝
⟦sp⟧𝑣sp
𝑠 = 𝑣sp
⟦𝜏𝑠1 + 𝜏𝑠2⟧𝑣sp
𝑠 = ⟦𝜏𝑠1⟧𝑣sp
𝑠 + ⟦𝜏𝑠2⟧𝑣sp
𝑠
⟦𝜏𝑠1 × 𝜏𝑠2⟧𝑣sp
𝑠 = ⟦𝜏𝑠1⟧𝑣sp
𝑠 × ⟦𝜏𝑠2⟧𝑣sp
𝑠
Leakage transformers for instructions:
𝑒 = ℓ′
⟦𝜏𝑑⟧ℓ𝑑
⟦𝜏𝑒⟧ℓ𝑒
⟦𝜏𝑑 := 𝜏𝑒⟧ℓ𝑑 :=ℓ𝑒 = ℓ′
𝑒 = ℓ′
𝑑 := ℓ′
𝑑
𝑒
𝑒
⟦remove⟧ℓ = {}
⟦𝜏𝑒⟧ℓ𝑒
𝑒 = ℓ′
⟦𝜏𝑏⟧ℓ𝑏 = ℓ′
⟦if(𝜏𝑒, 𝜏𝑡𝑡 , 𝜏𝑓𝑓 )⟧if𝑏 (ℓ𝑒 ,ℓ𝑏) = if𝑏 (ℓ′
𝑏
𝑒
𝑒, ℓ′
𝑏)
⟦𝜏𝑒⟧ℓ𝑒
⟦𝜏⟧ℓ𝑐 = ℓ′
𝑒 = ℓ′
⟦while(𝜏𝑒, 𝜏)⟧whilet(ℓ𝑒 ,ℓ𝑐 ,ℓ𝑤) = whilet(ℓ′
⟦while(𝜏𝑒, 𝜏)⟧ℓ𝑤 = ℓ′
𝑐, ℓ′
𝑤)
𝑒, ℓ′
𝑒
𝑐
𝑤
⟦𝜏𝑒⟧ℓ𝑒
𝑒 = ℓ′
𝑒
⟦while(𝜏𝑒, 𝜏)⟧whilef (ℓ𝑒 ) = whilef (ℓ′
𝑒)
⟦𝜏𝑖⟧ℓ𝑖 = ℓ′
𝑖
⟦𝜏⟧ℓ𝑏 = ℓ′
𝑏
⟦𝜏1; . . . ; 𝜏𝑛⟧ℓ1;. . . ;ℓ𝑛 = ℓ′
1; . . . ; ℓ′
𝑛
⟦ceval𝑏 𝜏⟧if𝑏 (ℓ𝑒 ,ℓ𝑏) = ℓ′
𝑏
Figure 8: Semantics for leakage transformers
5.4 Focus on instruction selection
Instruction selection (a.k.a. lowering) replaces high-level construc-