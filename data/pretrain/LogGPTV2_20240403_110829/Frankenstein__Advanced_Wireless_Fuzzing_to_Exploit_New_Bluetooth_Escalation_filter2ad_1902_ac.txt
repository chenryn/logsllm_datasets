tached to a sophisticated operating system like Linux, but in
principle also to other operating systems that support UART
Bluetooth, such as macOS. All steps to revive the CYW20735
ﬁrmware are explained in the following.
5.1 Bringing Firmware Images Back to Life
Emulation either requires ﬁrmware initialization or a clean
memory snapshot containing all registers. Memory snapshots
simplify the process for complex ﬁrmware. Initially, it might
be undocumented how memory is mapped. Thus, Franken-
stein comes with a map_memory hook that overwrites the
ARM memory fault handler and sweeps through the whole
address range. Once the memory map is known, a snapshot of
the memory is obtained from a physical device by executing
an xmit_state hook, which can be placed within arbitrary
functions. The xmit_state hook pauses interrupts and dis-
ables the watchdog while copying all memory via HCI, which
takes several minutes. Since snapshot hooks are placed within
functions, the snapshot state is comparably deterministic. For
example, snapshots can be taken while the chip has an active
connection within a selected protocol handler.
UART Registers
interruptvector_PTU
BT Transport
H
C
I
Idle
Link Manager
L
M
C
o
m
m
a
n
d
L
M
P
/
L
C
P
A
C
L
/
S
C
O
BCS Tasks
Active Task (tb)
ACL
SCO
LE Conn
Inquiry
Paging
Advertising
T
a
s
k
s
C
r
e
a
t
e
/
D
e
l
e
t
e
B
C
S
K
e
r
n
e
l
RF Hardware
bluetoothCoreInt_C
U
A
R
T
T
h
r
e
a
d
X
B
l
u
e
t
o
o
t
h
C
o
r
e
S
c
h
e
d
u
l
e
r
R
F
Figure 2: Broadcom/Cypress Bluetooth ﬁrmware internals.
USENIX Association
29th USENIX Security Symposium    25
Physical Chip
Firmware
ROM
RAM
MMIO1
MMIO2
xmit_state
ROM.bin
RAM.bin
MMIO1.bin
MMIO2.bin
objcopy
ROM.o
RAM.o
MMIO1.o
MMIO2.o
patch.c
Compile
patch.o
segments.ld
symbols.ld
Virtual Chip
patch.elf
ROM
RAM
MMIO1
MMIO2
patch.c
_start()
2.
M
o
d
i
f
y
1.
Entry
Link
c
o
n
t
(
)
Figure 3: Reassembling the ﬁrmware image and live snapshot
to an executable ELF ﬁle.
We use an unmodiﬁed QEMU in user mode for emulation.
However, the snapshot is a raw binary without symbols. We re-
assemble it to an Executable and Linking Format (ELF) ﬁle,
as illustrated in Figure 3. User-deﬁned code is then compiled
and linked against the ﬁrmware image. The compiled code is
stored in a separate page and provides the initial entry point
_start for the emulation. It shares the same address space
as the ﬁrmware, hence it can call functions and parse data
structures within the image. The syntax is equivalent to any C
code written for the ﬁrmware. It also adds new features and
makes modiﬁcations to substitute missing physical hardware.
Frankenstein runs in Linux user mode, which does not
support interrupts. Thus, we disable functions responsible for
enabling and disabling interrupts. Timing-related functions,
such as delay, use special purpose hardware and are also
replaced. ThreadX uses a Supervisor Call (SVC) to perform
a context switch between threads. On ARM this is a software
interrupt, with a handler located at a known location. As an
SVC has special calling conventions that cannot be emulated
in user-mode, we re-implemented the handler.
After these modiﬁcations, the ﬁrmware is executed until
the idle thread returns from the interrupt.2 We replace that
return address on the stack with a pointer to our own function.
Within this function, we can invoke interrupt handlers like
a normal function call to preserve the threading behavior.
Thereby, we can inject HCI trafﬁc or Bluetooth frames, as
described in Section 5.4 and Section 5.5.
2On ARM, returning from exceptions is done by loading a special value
to the Program Counter (PC). The idle thread will return to 0xfffffffd,
showing that an interrupt invoked it.
5.2 Hooking for Portability
We implement a lightweight hooking mechanism that can be
used to modify the emulated ﬁrmware as well as the ﬁrmware
running on the device. Any code written in Frankenstein
can also be compiled for the ﬁrmware and injected like a
shellcode. Even though the ﬁrmware is in ROM, it can be
patched temporarily. Broadcom uses a Patchram mechanism
to do so [35]. Each Patchram slot contains a 4 B overlay in
ROM and can be used to branch to the actual patch. The
number of Patchram slots is very limited, but we use this
mechanism as it allows us to install patches on the virtual and
the physical ﬁrmware.
As the number of modiﬁcations to the ROM is limited
to 256 Patchram slots on the CYW20735 chip, we use a
trampoline-based approach, similar to the Nexmon hook patch
variant [41]. More advanced approaches like RetroWrite
that pose less overhead are completely infeasible, as they
rewrite the whole ﬁrmware and require position-independent
code [21]. Instead, we modify the prologue of the target func-
tion to branch to our code. Once our hook is executed, we
restore the original prologue and call the target function. On
return, we execute a post-hook function to reinstall the hook
and continue normal execution.
This hooking mechanism enables Frankenstein to trace
function calls and analyze interrupt handlers and the corre-
sponding status registers running on QEMU and the physical
device. It also supports writing PoCs for over-the-air ﬁrmware
vulnerabilities running on the physical hardware.
For example, a basic LMP protocol fuzzer requires the
following hooks:
1. context switches between threads,
2. Host Controller Interface (HCI) support,
3. hardware interrupt based timers, and
4. ∼100 hooks for debugging and implementation.
5.3 Heap Sanitizer Hook Performance
ThreadX has a custom implementation for dynamic memory
called BLOC buffer. Each BLOC is a continuous chunk of mem-
ory, divided into several chunks of equal size. Free chunks
are managed using a singly linked list.
The sanitizer iterates over the free list and validates that all
pointers are within the BLOC pool. Frankenstein hooks various
functions such as memcpy and dynamic_memory_Release
to integrate this check without further modiﬁcations to the
heap itself. Thus, the Frankenstein sanitizer can also be added
during runtime to the ﬁrmware running on the physical device.
Unicorn, which is the state-of-the-art ﬁrmware hooking
tool, allows setting callbacks for each executed basic block,
instruction, or memory access. It relies on external function
calls [48]. Since Frankenstein hooks are modiﬁcations to
26    29th USENIX Security Symposium
USENIX Association
the ﬁrmware itself, no external libraries are called. In addi-
tion, the Frankenstein hook payload is executed within the
instrumented ﬁrmware and implemented in C. Therefore, it
outperforms the Unicorn hooking mechanism.
We re-implement the same heap sanitizer with Unicorn
Python bindings for comparison and run it on a Thinkpad
T430 with an i5-3320M CPU. Figure 4 shows the results.
The baseline runtime of the instrumented ﬁrmware without
heap sanitizer is 24.8 ms on average. When sanitizing the
heap during LMP fuzzing, Frankenstein comes with a per-
formance overhead of 11.6 ms (46.8 %) on the mean average
compared to the baseline. The same implementation using
Unicorn increases the runtime by 145.2 ms (585.5 %) com-
pared to the baseline. Therefore, ﬁrmware instrumentation
using Frankenstein outperforms Unicorn by a factor of 12.5
in the heap sanitizer scenario. Performance of other use cases
varies depending on the number of hooks.
While the exact speedup depends on the scenario, it is
sufﬁcient to overcome the break-even point for the full-stack
fuzzing use case. Frankenstein emulates the ﬁrmware fast
enough to enable interaction with an unmodiﬁed Bluetooth
stack on the host and, thus, attaching it to Linux BlueZ [13].
5.4 Talking to an Operating System
Attaching Frankenstein to an operating system Bluetooth im-
plementation enables full-stack fuzzing. For example, CVE-
2019-11516 (see Section 6.2) is triggered by the host asking
for additional information. On the physical device, HCI trafﬁc
is sent to the host via UART. In the emulation, we connect
UART to a Linux host using a pseudo-terminal device [33].
Opening a Pseudo Terminal Master (PTM) creates a ﬁle de-
scriptor, used in the emulator via Linux read and write sys-
tem calls. The operating system then creates a corresponding
Pseudo Terminal Slave (PTS), which is similar to a virtual
serial interface. The PTS is then passed to btattach to attach
the emulator to the Linux BlueZ Bluetooth stack.
HCI events generated by the ﬁrmware are extracted by
hooking uart_SendAsynch. This function is a central com-
ponent of the transmit state machine and gets called for every
)
e
l
a
c
s
g
o
l
(
s
d
n
o
c
e
s
n
i
e
m
i
t
n
u
R
0.2
0.1
0.05
0.025
HCI event. Those events are sent to the host using the write
system call. The opposite direction, injecting HCI commands,
requires two steps. We replace functions that read data from
UART packet buffers with read system calls and analyze the
status registers triggering the UART interrupt handler. This
will invoke the UART receive state machine implemented in
the bttransport thread. Note that ACL and SCO data trafﬁc
is also passed over the UART interface.
5.5 Non-Wireless Wireless Packet Injection
The virtual modem calls the Bluetooth Core Scheduler (BCS)
interrupt handler and generates speciﬁc packets for these.
For most task types, the packets can be entirely random for
reaching maximum coverage. The Link Management Proto-
col (LMP) was fuzzed coverage-based due to the complexity
of the Link Manager (LM) state machine. The most interest-
ing fuzzing optimizations are as follows.
Paging This task accepts any connection attempt.
LMP The LM handles a lot of logic within the ﬁrmware and
is fuzzed coverage-based, as described in Section 5.6.
We have to analyze the calling convention of bluetooth
CoreInt_C to implement a virtual modem injecting custom
packets. On the device, it is important not to alter the 312.5 µs
timing at which bluetoothCoreInt_C is called. Hence, only
a limited number of debugging techniques can be used. We
hook this function on the physical device and dump the
hardware registers of interest to a ring buffer. Those are
mainly phy_status and sr_status, which control the BCS
kernel. phy_status controls which function is executed by
bluetoothCoreInt_C and depends on the Bluetooth clock.
An example of phy_status within an active ACL slave
connection is shown in Table 2. Prior to a reception in the
Slot11 interrupt, the receive buffer located in RAM is mapped
to the hardware receive buffer using DMA. This memory
overlay technique is used to prevent the use of memcpy and
therefore save CPU resources. Packet data is written to RAM
instead of writing it directly to the hardware receive buffer.