![](../img/fig7-3.png)
**图 7-3 原子性确保发生错误时，事务先前的任何写入都会被撤消，以避免状态不一致**
多物件事务需要某种方式来确定哪些读写操作属于同一个事务。在关系型资料库中，通常基于客户端与资料库伺服器的 TCP 连线：在任何特定连线上，`BEGIN TRANSACTION` 和 `COMMIT` 语句之间的所有内容，被认为是同一事务的一部分.[^iii]
[^iii]: 这并不完美。如果 TCP 连线中断，则事务必须中止。如果中断发生在客户端请求提交之后，但在伺服器确认提交发生之前，客户端并不知道事务是否已提交。为了解决这个问题，事务管理器可以透过一个唯一事务识别符号来对操作进行分组，这个识别符号并未系结到特定 TCP 连线。后续再 “[资料库的端到端原则](ch12.md#资料库的端到端原则)” 一节将回到这个主题。
另一方面，许多非关系资料库并没有将这些操作组合在一起的方法。即使存在多物件 API（例如，某键值储存可能具有在一个操作中更新几个键的 multi-put 操作），但这并不一定意味著它具有事务语义：该命令可能在一些键上成功，在其他的键上失败，使资料库处于部分更新的状态。
#### 单物件写入
当单个物件发生改变时，原子性和隔离性也是适用的。例如，假设你正在向资料库写入一个 20 KB 的 JSON 文件：
- 如果在传送第一个 10 KB 之后网路连线中断，资料库是否储存了不可解析的 10KB JSON 片段？
- 如果在资料库正在覆盖磁碟上的前一个值的过程中电源发生故障，是否最终将新旧值拼接在一起？
- 如果另一个客户端在写入过程中读取该文件，是否会看到部分更新的值？
这些问题非常让人头大，故储存引擎一个几乎普遍的目标是：对单节点上的单个物件（例如键值对）上提供原子性和隔离性。原子性可以透过使用日志来实现崩溃恢复（请参阅 “[让 B 树更可靠](ch3.md#让B树更可靠)”），并且可以使用每个物件上的锁来实现隔离（每次只允许一个执行绪访问物件） 。
一些资料库也提供更复杂的原子操作 [^iv]，例如自增操作，这样就不再需要像 [图 7-1](../img/fig7-1.png) 那样的读取 - 修改 - 写入序列了。同样流行的是 **[比较和设定（CAS, compare-and-set）](#比较并设定（CAS）)** 操作，仅当值没有被其他并发修改过时，才允许执行写操作。
[^iv]: 严格地说，**原子自增（atomic increment）** 这个术语在多执行绪程式设计的意义上使用了原子这个词。在 ACID 的情况下，它实际上应该被称为 **隔离的（isolated）** 的或 **可序列的（serializable）** 的增量。但这就太吹毛求疵了。
这些单物件操作很有用，因为它们可以防止在多个客户端尝试同时写入同一个物件时丢失更新（请参阅 “[防止丢失更新](#防止丢失更新)”）。但它们不是通常意义上的事务。CAS 以及其他单一物件操作被称为 “轻量级事务”，甚至出于营销目的被称为 “ACID”【20,21,22】，但是这个术语是误导性的。事务通常被理解为，**将多个物件上的多个操作合并为一个执行单元的机制**。
#### 多物件事务的需求
许多分散式资料储存已经放弃了多物件事务，因为多物件事务很难跨分割槽实现，而且在需要高可用性或高效能的情况下，它们可能会碍事。但说到底，在分散式资料库中实现事务，并没有什么根本性的障碍。[第九章](ch9.md) 将讨论分散式事务的实现。
但是我们是否需要多物件事务？**是否有可能只用键值资料模型和单物件操作来实现任何应用程式？**
有一些场景中，单物件插入，更新和删除是足够的。但是许多其他场景需要协调写入几个不同的物件：
* 在关系资料模型中，一个表中的行通常具有对另一个表中的行的外来键引用。（类似的是，在一个图资料模型中，一个顶点有著到其他顶点的边）。多物件事务使你确保这些引用始终有效：当插入几个相互引用的记录时，外来键必须是正确的和最新的，不然资料就没有意义。
* 在文件资料模型中，需要一起更新的栏位通常在同一个文件中，这被视为单个物件 —— 更新单个文件时不需要多物件事务。但是，缺乏连线功能的文件资料库会鼓励非规范化（请参阅 “[关系型资料库与文件资料库在今日的对比](ch2.md#关系型资料库与文件资料库在今日的对比)”）。当需要更新非规范化的资讯时，如 [图 7-2](../img/fig7-2.png) 所示，需要一次更新多个文件。事务在这种情况下非常有用，可以防止非规范化的资料不同步。
* 在具有次级索引的资料库中（除了纯粹的键值储存以外几乎都有），每次更改值时都需要更新索引。从事务角度来看，这些索引是不同的资料库物件：例如，如果没有事务隔离性，记录可能出现在一个索引中，但没有出现在另一个索引中，因为第二个索引的更新还没有发生。
这些应用仍然可以在没有事务的情况下实现。然而，**没有原子性，错误处理就要复杂得多，缺乏隔离性，就会导致并发问题**。我们将在 “[弱隔离级别](#弱隔离级别)” 中讨论这些问题，并在 [第十二章](ch12.md) 中探讨其他方法。
#### 处理错误和中止
事务的一个关键特性是，如果发生错误，它可以中止并安全地重试。ACID 资料库基于这样的哲学：如果资料库有违反其原子性，隔离性或永续性的危险，则宁愿完全放弃事务，而不是留下半成品。
然而并不是所有的系统都遵循这个哲学。特别是具有 [无主复制](ch5.md#无主复制) 的资料储存，主要是在 “尽力而为” 的基础上进行工作。可以概括为 “资料库将做尽可能多的事，执行遇到错误时，它不会撤消它已经完成的事情” —— 所以，从错误中恢复是应用程式的责任。
错误发生不可避免，但许多软体开发人员倾向于只考虑乐观情况，而不是错误处理的复杂性。例如，像 Rails 的 ActiveRecord 和 Django 这样的 **物件关系对映（ORM, object-relation Mapping）** 框架不会重试中断的事务 —— 这个错误通常会导致一个从堆叠向上传播的异常，所以任何使用者输入都会被丢弃，使用者拿到一个错误资讯。这实在是太耻辱了，因为中止的重点就是允许安全的重试。
尽管重试一个中止的事务是一个简单而有效的错误处理机制，但它并不完美：
- 如果事务实际上成功了，但是在伺服器试图向客户端确认提交成功时网路发生故障（所以客户端认为提交失败了），那么重试事务会导致事务被执行两次 —— 除非你有一个额外的应用级去重机制。
- 如果错误是由于负载过大造成的，则重试事务将使问题变得更糟，而不是更好。为了避免这种正反馈回圈，可以限制重试次数，使用指数退避演算法，并单独处理与过载相关的错误（如果允许）。
- 仅在临时性错误（例如，由于死锁，异常情况，临时性网路中断和故障切换）后才值得重试。在发生永久性错误（例如，违反约束）之后重试是毫无意义的。
- 如果事务在资料库之外也有副作用，即使事务被中止，也可能发生这些副作用。例如，如果你正在传送电子邮件，那你肯定不希望每次重试事务时都重新发送电子邮件。如果你想确保几个不同的系统一起提交或放弃，**两阶段提交（2PC, two-phase commit）** 可以提供帮助（“[原子提交与两阶段提交](ch9.md#原子提交与两阶段提交)” 中将讨论这个问题）。
- 如果客户端程序在重试中失效，任何试图写入资料库的资料都将丢失。
## 弱隔离级别
如果两个事务不触及相同的资料，它们可以安全地 **并行（parallel）** 执行，因为两者都不依赖于另一个。当一个事务读取由另一个事务同时修改的资料时，或者当两个事务试图同时修改相同的资料时，并发问题（竞争条件）才会出现。
并发 BUG 很难透过测试找到，因为这样的错误只有在特殊时序下才会触发。这样的时序问题可能非常少发生，通常很难重现 [^译注i]。并发性也很难推理，特别是在大型应用中，你不一定知道哪些其他程式码正在访问资料库。在一次只有一个使用者时，应用开发已经很麻烦了，有许多并发使用者使得它更加困难，因为任何一个数据都可能随时改变。
[^译注i]: 轶事：偶然出现的瞬时错误有时称为 ***Heisenbug***，而确定性的问题对应地称为 ***Bohrbugs***
出于这个原因，资料库一直试图透过提供 **事务隔离（transaction isolation）** 来隐藏应用程式开发者的并发问题。从理论上讲，隔离可以透过假装没有并发发生，让你的生活更加轻松：**可序列的（serializable）** 隔离等级意味著资料库保证事务的效果如同序列执行（即一次一个，没有任何并发）。
实际上不幸的是：隔离并没有那么简单。**可序列的隔离** 会有效能损失，许多资料库不愿意支付这个代价【8】。因此，系统通常使用较弱的隔离级别来防止一部分，而不是全部的并发问题。这些隔离级别难以理解，并且会导致微妙的错误，但是它们仍然在实践中被使用【23】。
弱事务隔离级别导致的并发性错误不仅仅是一个理论问题。它们造成了很多的资金损失【24,25】，耗费了财务审计人员的调查【26】，并导致客户资料被破坏【27】。关于这类问题的一个流行的评论是 “如果你正在处理财务资料，请使用 ACID 资料库！” —— 但是这一点没有提到。即使是很多流行的关系型资料库系统（通常被认为是 “ACID”）也使用弱隔离级别，所以它们也不一定能防止这些错误的发生。
比起盲目地依赖工具，我们需要对存在的各种并发问题，以及如何防止这些问题有深入的理解。然后就可以使用我们所掌握的工具来构建可靠和正确的应用程式。
在本节中，我们将看几个在实践中使用的弱（**非序列的**，即 nonserializable）隔离级别，并详细讨论哪种竞争条件可能发生也可能不发生，以便你可以决定什么级别适合你的应用程式。一旦我们完成了这个工作，我们将详细讨论可序列化（请参阅 “[可序列化](#可序列化)”）。我们讨论的隔离级别将是非正式的，透过示例来进行。如果你需要严格的定义和分析它们的属性，你可以在学术文献中找到它们【28,29,30】。
### 读已提交
最基本的事务隔离级别是 **读已提交（Read Committed）**[^v]，它提供了两个保证：