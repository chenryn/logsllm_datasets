its success number before reaching 2,250 cycles of Tx. Note
that membarrier and TLB shootdown also failed to maintain
the success number, implying that even if it can be applied to
da1b9564 (irrespective of the process/thread issue), it would
have failed to exploit. In probability model Figure 9-a-2, hard-
ware interrupt only success when Tx is about 2,250 cycles.
The rest sub-figures, from Figure 9-b-1 to d-1, also show
consistent results as Figure 9-a-1. In particular, when Ty is
{41, 130, 1135} cycles, {CVE-2017-15265, CVE-2019-1999,
CVE-2019-2025, 11eb85ec, 1a6084f8, 20f2e4c2, 4842e98f,
e20a2e9c} can be exploited by all EXPRACE’s methods, re-
spectively. However, the baseline method failed for all the
above eight, showing consistent results as the real-world ex-
ploitation results. For CVE-2019-1999, only TLB shootdown
and HW interrupt were successful, which is also consistent
with the real-world exploitation results.
Figure 10 shows the number of related events — Syscallx,
Syscally, the number of interrupts (including both hardware
interrupts and IPIs) — during the exploitation. During this
one minute, the number of Syscallx were similar for all ex-
ploitation methods (i.e., about 250M) because the handling
mechanism of Syscallx is not impacted by varying the ex-
ploitation method.
On the contrary, the number of Syscally varies. The base-
line method had the biggest number because Syscally han-
dling was not interfered by the interrupt. All other methods
have less because execution of Syscally stalls for a while
once receiving an interrupt.
In terms of the number of interrupts, there were no in-
terrupts while trying baseline. membarrier had the biggest
number of interrupts, which seems to be related to the fact
the membarrier IPI is the lightest compared to the others, so
it can be quickly delivered. HW interrupt had the smallest
among EXPRACE’s exploitation methods, implying that its
interrupt issue logic is the slowest.
Accuracy of Probability Model. Overall, both synthetic
evaluation results and probability model results decrease
sharply at a specific x-axis value. As shown in Figure 9-
d-1, the number of successes is sharply decreased after Tx is
bigger than 16,000 cycles. Similarly, as shown in Figure 9-
d-2, the number of success is sharply decreased after Tx is
bigger than 15,000 cycles. We note that the slight difference
between these two results seems to be due to the measurement
errors. While all the cycles are fixed values in the probability
model, measured cycles in the synthetic experiments can have
measurement errors due to the noise.
7.2.3 Length of Enlarged Race Windows
To clearly see how much a race window is enlarged, we mea-
sured cycles of Ty′ when exploiting the synthetic race. More
specifically, we fixed Tx and Ty as 539 and 25 cycles, respec-
tively. Then we instrumented rdtsc at two places to measure
Ty′: (i) right before line 23 in Figure A.4 (i.e., A in Figure 8)
and (ii) right after line 27 Figure A.4 (i.e., D in Figure 8).
Figure 11 shows the average of Ty′ for each exploitation
method. A filled circle denotes the average cycles when the
exploitation is successful, and a cross mark denotes when
failed. Here, the cycle difference between success and fail-
ure for each method indicates TE, because success means
the race window is extended (i.e., Ty′ = Ty + TE). Overall, all
exploitation methods show higher Ty′ when successful, and
each method shows a different enlargement. The hardware
interrupt is the largest (i.e., TE = 14,103 cycles), which ex-
plains why hardware interrupts have maintained the number
of success while varying Tx in Figure 9—for all Tx cycles,
Ty′ > Tx. The contrary example is Reschedule, which has
2374    30th USENIX Security Symposium
USENIX Association
Figure 9: Exploitation results on the synthetic race vulnerability in Linux
7.3 Exploiting Other OSes
In order to check the effectiveness of exploiting other OSes
using EXPRACE, we launched the exploitation against the
synthetic race vulnerability (as described in §7.2.1) devel-
oped as a kernel driver for Windows and OS X, respectively.
Figure 12 shows exploitation results, where we fixed Ty as 17
cycles and launched an exploitation for one minute. Overall,
Reschedule and TLB shootdown has shown far more success
numbers than baseline, demonstrating the exploitation ef-
fectiveness of EXPRACE. One thing to n ote is that in Linux
the success number quickly drops when Tx > 1,400, but in
Windows and OS X such a drop occurs when Tx > 2,000.
We suspect this suggests that the TLB flushing in Linux is
processed faster than Windows and OS X.
Unfortunately, we were not able to include the real-world
exploitation cases for Windows and Mac OS X, because no
Figure 10: The number of events while exploiting the synthetic race
vulnerability
shown 734 cycles of TE. Therefore, the number of success for
Reschedule always dropped earlier than other EXPRACE’s
methods in Figure 9.
USENIX Association
30th USENIX Security Symposium    2375
(a) Average cycles of TyTy is 17 cycles (TSyscallyTSyscally is about 675 cycles)(b) Average cycles of TyTy is 41 cycles (TSyscallyTSyscally is about 730 cycles)(c) Average cycles of TyTy is 130 cycles (TSyscallyTSyscally is about 829 cycles)(a-1) Plotted using exploitation results(a-2) Plotted using the probability model(b-1) Plotted using exploitation results(b-2) Plotted using the probability model(c-1) Plotted using exploitation results(c-2) Plotted using the probability modelCVE-2019-6974CVE-2019-697411eb85ecda1b9564da1b9564CVE-2017-15265CVE-2017-15265CVE-2019-2025CVE-2019-20254842e984842e9820f2e4c220f2e4c2CVE-2019-1999CVE-2019-19991a6084f81a6084f811eb85ec(d) Average cycles of TyTy is 1135 cycles (TSyscallyTSyscally is about 1793 cycles)(d-1) Plotted using exploitation results(d-2) Plotted using the probability modele20a2e9ce20a2e9cThe number of execution8.2 Mitigation
In order to mitigate new exploitation threats introduced by
EXPRACE, there can be two potential mitigation approaches:
1) identifying an abnormal frequency of interrupts and 2)
avoiding preemption by userspace-originated interrupts.
The first approach is based on the fact that EXPRACE im-
poses very frequent interrupts. Thus, exploitation attempts
with EXPRACE can be captured with the kernel-level moni-
tor, which checks if too many interrupts were raised within a
short period of time. While this approach would be simple to
implement and deploy, it may have false positives (i.e., some
benign behaviors may entail frequent interrupts), which needs
further investigation.
The second approach is to avoid any preemption of ker-
nel execution context if an interrupt is indirectly raised by
a user. With this avoidance, the user will not be able to en-
force the preemption within the race window, thereby mitigat-
ing EXPRACE’s exploitation technique. While this approach
would have more precise detection capability than the first
one, it requires heavy kernel modification to keep track of the
origins of all interrupt events, which may hinder its practical
adoption as well as imposing runtime tracking overheads.
To summarize, we expect adopting these two approaches
needs careful investigation so as not to break the original
semantics and backward compatibility of existing kernel ser-
vices. We further hope this paper provokes interesting dis-
cussions on the fundamental design of interrupt handling in
operating systems, particularly from security perspectives—
asking if the interrupt timing controls by unprivileged users
should be allowed or not.
9 Related work
Detecting Races. For the sake of detecting race condition,
many works attempted to use either a static analysis ap-
proach [5, 15, 17, 39, 58–60, 63] or a dynamic analysis ap-
proach [7, 9, 28, 30, 31, 40, 47, 49, 50], or both [27]. Most
race detectors using static analysis are based on lockset analy-
sis [5, 15, 17, 58, 59]. WHOOP [15] uses symbolic pairwise
lockset analysis for detecting race condition in the Linux
kernel driver. Deadline [63] uses static analysis to find multi-
reads in the kernel and employs symbolic checking to check
each multi-read satisfies the constraints to be a double-fetch
bug. Memory sampling techniques [7, 9, 18, 28, 40] selec-
tively monitor memory accesses to detect race conditions.
SNORLAX [30] utilizes a coarse interleaving hypothesis,
which relies on a dynamic-static interprocedural pointer and
type analysis, to diagnose the root causes of concurrency bugs.
Razzer [27] first extracts a set of race candidates through
the static analysis and then starts fuzzing while setting up
the breakpoints (fuzzing) to discover races in an efficient
way. Compared to EXPRACE, these studies were focusing
on automating the race condition detection, while EXPRACE
Figure 11: CPU cycles when exploiting the synthetic race vulnera-
bility. A blue filled circle denotes averaged CPU cycles of Ty when
the exploitation is successful; A orange cross denotes averaged CPU
cycles of Ty when failed. The cycle difference between success and
fail approximately shows an enlarged race window (i.e., TE).
(a) Microsoft Windows
(b) Mac OS X
Figure 12: Exploitation results against the synthetic race vulnerabil-
ity on Windows and OS X
public descriptions on non-inclusive race vulnerabilities on
these platforms were available. We further discuss this limita-
tion of EXPRACE on other OSes in §8.1.
8 Discussion
In this section, we first discuss the possibility of exploiting
other OSes using EXPRACE (§8.1). Then we discuss how the
new threats introduced by EXPRACE can be mitigated (§8.2).
8.1 Possibility of Exploiting Other OSes
Our evaluation in §7.3 suggests that it is possible to launch
exploitation with EXPRACE on synthetic race issues. How-
ever, as we were not able to perform the real-world case study,
it is very premature to confirm the exploitation possibility
using EXPRACE on other OSes. Thus it requires more studies
in the future. Nevertheless, because there are no significant
differences between Linux and Windows/Mac OS X from the
perspective of race issues, we believe the attacking method in-
troduced by EXPRACE may still be valid for these platforms
as well.
2376    30th USENIX Security Symposium
USENIX Association
 TETE =734.79734.79 TETE =913.85913.85 TETE = 1493.541493.54 TETE =14103.4414103.44Average cycles of Ty′Ty′ TxTx (cycles)#987393Fixing TyTy = 17 cycles (TSyscallyTSyscally = 2212 cycles)The number of successes#987393 TxTx (cycles)Fixing TyTy = 17 cycles (TSyscallyTSyscally = 3881 cycles)The number of successesfocuses on how to exploit the real-world race condition issues.
Avoiding Races. Previous works employ deterministic exe-
cution to avoid concurrency bugs [4, 6, 12, 13, 37]. Grace [6]
turns the multi-threaded program into a sequential program
using fork-join parallelism. DThread [37] keeps track of mem-
ory modification sites using virtual memory protection and
ensures deterministic update orders by each thread. PERE-
GRINE [12] proposed a hybrid scheduling mechanism, which
uses mem-schedule for the racy part and sync-schedule for
the non-racy part, thereby guaranteeing a deterministic multi-
threading system. Parrot [13] orders thread synchronization
in the well-defined round-robin order.
Automating Exploitation of Memory Corruptions.
APEG [8] identifies missing sanitization checks by compare
patched and unpatched binary using binary analysis and
generate an input to trigger the difference. AEG [54] and
mayhem [10] use symbolic execution (or hybrid symbolic
execution) to generate shell spawning exploit. FUZE [62]
and Revery [61] identify and further analyze the root
cause of vulnerabilities, and they automatically generate an
exploit. KOOBE [11] evaluates the exploitability of kernel’s
out-of-bound write vulnerabilities using capability-guided
fuzzing for automated exploit generation.
Performance Degradation. Many researchers leveraged per-
formance degradation factors (e.g., interrupt [22, 46, 55, 56]
or cache eviction [1, 21]) to launch or assist side-channel
attacks. While these and EXPRACE both degrade the per-
formance to launch attacks, the difference is that EXPRACE
focuses on attacking race issues where previous works cannot
be applied.
Nemesis [56] used interrupts to leak instruction timings
against Intel SGX. SGX-Step [55] used APIC timer interrupts
to track page table entries directly from user space. Hahnel et
al. [22] use timer interrupt to achieve higher temporal and
spatial resolution. Cachezoom [46] consecutively sends in-
terrupts to amplify the cache side channel. However, they
assume the attacker already had full control over the kernel.
This allows the attacker to generate interrupts as desired. On
the contrary, EXPRACE assumes that the attacker only has
user-level privileges, so the interrupt generation cannot di-
rectly be performed.
Thomas et al. [1] amplified the result of side-channel at-
tacks using cache eviction. Compared to EXPRACE, this
method does not slow down a specific target core but slows
down entire cores. Thus, this attack would increase both Tx
and Ty, which cannot be applied for EXPRACE.
10 Conclusion
This paper studies the exploitability of kernel data races. We
analyzed real-world kernel races and found an intrinsic con-
dition separating easy-to-exploit and hard-to-exploit races.
Then we developed EXPRACE, a generic race exploitation
technique for Linux, Windows, OS X. Through evaluating
with real-world race vulnerabilities, EXPRACE demonstrated
that it truly augments the exploitability of kernel races.
11 Acknowledgment
We sincerely thank anonymous reviewers and our shepherd,
Vasileios P. Kemerlis, for their insightful comments, which sig-
nificantly improved the final version of this paper. The authors
would like to thank Dae R. Jeong who provided the initial idea
and insights of this work. This work was supported by Na-
tional Research Foundation (NRF) of Korea grant funded by
the Korean government MSIT (NRF-2019R1C1C1006095),
Institute for Information & communications Technology Pro-
motion (IITP) grant funded by the Korea government (MSIP)
(No.2020-0-01840, Analysis on technique of accessing and
acquiring user data in smartphone), and US Office of Naval
Research under grants N00014-18-1-2022. The Institute of
Engineering Research (IOER) and Automation and Systems
Research Institute (ASRI) at Seoul National University pro-
vided research facilities for this work. The Institute of En-
gineering Research at Seoul National University provided
research facilities for this work.
References
[1] T. Allan, B. B. Brumley, K. Falkner, J. Van de Pol, and Y. Yarom.
Amplifying side channels through performance degradation. In Pro-
ceedings of the Annual Computer Security Applications Conference
(ACSAC), 2016.
[2] N. Amit. Optimizing the TLB Shootdown Algorithm with Page Access
In Proceedings of the 2017 USENIX Annual Technical
Tracking.
Conference (ATC), Santa Clara, CA, July 2017.
[3] Z. Anderson, D. Gay, R. Ennals, and E. Brewer. Sharc: Checking data
In Proceedings of the 2008
sharing strategies for multithreaded c.
ACM SIGPLAN Conference on Programming Language Design and
Implementation (PLDI), Tucson, Arizona, June 2008.
[4] A. Aviram, S.-C. Weng, S. Hu, and B. Ford. Efficient system-enforced
deterministic parallelism. Communications of the ACM, 55(5):111–119,
2012.
[5] J.-J. Bai, J. Lawall, Q.-L. Chen, and S.-M. Hu. Effective static analysis
In Pro-
of concurrency use-after-free bugs in linux device drivers.
ceedings of the 2019 USENIX Annual Technical Conference (ATC),
RENTON, WA, July 2019.
[6] E. D. Berger, T. Yang, T. Liu, and G. Novark. Grace: safe multithreaded
In Proceedings of the 24th Annual ACM
programming for c/c++.
Conference on Object-Oriented Programming, Systems, Languages,
and Applications (OOPSLA), Orlando Florida, Oct. 2009.
[7] M. D. Bond, K. E. Coons, and K. S. McKinley. Pacer: proportional
detection of data races. In Proceedings of the 2010 ACM SIGPLAN
Conference on Programming Language Design and Implementation
(PLDI), Toronto, Canada, June 2010.
[8] D. Brumley, P. Poosankam, D. Song, and J. Zheng. Automatic patch-
based exploit generation is possible: Techniques and implications. In
Proceedings of the 29th IEEE Symposium on Security and Privacy
(Oakland), Oakland, CA, May 2008.
[9] Y. Cai, J. Zhang, L. Cao, and J. Liu. A deployable sampling strategy
for data race detection. In Proceedings of the 24th ACM SIGSOFT
USENIX Association
30th USENIX Security Symposium    2377
Symposium on the Foundations of Software Engineering (FSE), Seattle,
WA, Nov. 2016.
[10] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing
mayhem on binary code. In Proceedings of the 33rd IEEE Symposium
on Security and Privacy (Oakland), San Francisco, CA, May 2012.
[11] W. Chen, X. Zou, G. Li, and Z. Qian. Koobe: Towards facilitating
exploit generation of kernel out-of-bounds write vulnerabilities. In Pro-
ceedings of the 28th USENIX Security Symposium (Security), BOSTON,
MA, Aug. 2020.
[12] H. Cui, J. Wu, J. Gallagher, H. Guo, and J. Yang. Efficient deterministic
multithreading through schedule relaxation. In Proceedings of the 23rd
ACM Symposium on Operating Systems Principles (SOSP), Cascais,
Portugal, Oct. 2011.
[13] H. Cui, J. Simsa, Y.-H. Lin, H. Li, B. Blum, X. Xu, J. Yang, G. A.
Gibson, and R. E. Bryant. Parrot: a practical runtime for deterministic,
stable, and reliable threads. In Proceedings of the 24th ACM Symposium
on Operating Systems Principles (SOSP), Farmington, PA, Nov. 2013.
[14] M. Daniel, J. Honoroff, and C. Miller. Engineering heap overflow
exploits with javascript. In Proceedings of the 2nd USENIX Workshop
on Offensive Technologies (WOOT), SAN JOSE, CA, July 2008.
[15] P. Deligiannis, A. F. Donaldson, and Z. Rakamaric. Fast and precise
symbolic analysis of concurrency bugs in device drivers (t). In Proceed-
ings of the 30rd IEEE/ACM International Conference on Automated
Software Engineering (ASE), Lincoln, Nebraska, Sept. 2015.
[16] F. Electrons. Realtime in embedded linux systems. 2004.
[17] D. Engler and K. Ashcraft. Racerx: effective, static detection of race
conditions and deadlocks. In Proceedings of the 19th ACM Symposium