转换为大写：
文本
We1come to my Homepage
Content is divided into two sections:
Infornation about Macronedia ColdFusion.
Co1dFus1on
Information about Bluetooth, 8e2.11, and more.
Wire1ess
This is not valid HTML
正则表达式
() ( . *7) ()
替换
$11U$21E$3
结果
Content is divided into two sections:
WELCOME TO MY HOMEPAGE
Information about Macromedia ColdFusion.
Co1dFusion
Wireless
This is not valid HTML
Information about Bluetooth, 8e2.11, and more.
---
## Page 89
8.4小结
79
分析
模式（）（.*?）（）把一级标题分成了3个子表达式：
开始标签、标题文字、结束标签。第2个模式再把文本重新组合起来：$1
包含着开始标签，\U$2\E把第2个子表达式（标题文字）转换为大写，$3
包含着结束标签，
8.4小结
子表达式用来定义字符或表达式的集合，除了可以用在重复匹配操
作中以外（详见第7章），子表达式还可以在模式的内部被引用。这种引
用被称为回溯引用。回溯引用的语法在不同的正则表达式实现里有很大
的差异。回溯引用在文本匹配和文本替换操作里非常有用。
---
## Page 90
第9章
前后查找
到目前为止，我们见过的正则表达式都是用来匹配文本的，但有时
我们还需要用正则表达式标记要匹配的文本的位置（而不仅仅是文本本
身）。这就引出了前后查找（lookaround，对某一位置的前、后内容进行
查找）的概念，我们将在这一章对此做专题讨论。
9.1前后查找
我们还是先来看一个例子：你要把一个Web页面的页面标题提取出
来。HTML页面标题是出现在和标签之间的文字，而这
对标签又必须嵌在HTML代码的部分里。下面就是这个例子：
文本
Ben Forta’s Honepage
正则表达式
, *
结果
分析
,*所  的]
是标签（大写、小写或大小写混用）、标签以及这两个
---
## Page 91
9.2向前查找81
标签之间的任何文字。这个模式的效果与我们的预期基本相符，但不够
理想。
为什么这么说呢？因为只有页面标题才是我们需要的，而找到的匹
配里还包含着和标签。能不能只返回页面标题的文字部
分呢？
办法之一是使用子表达式（参见第7章）。我们可以利用子表达式把
被匹配文本划分为3个部分：开始标签、标题文字、结束标签。把被匹配
文本划分为多个部分之后，从它们当中提取且只提取出我们需要的东西
就很容易了。
可是，明知是自己并不真正需要的东西（比如上例中的和
标签），还把它们检索出来岂不是毫无意义。“先想办法把它们
检索出来，再以手动方式排除它们”，这既浪费时间，又容易招致不必要
的后患。在遇到这类问题的时候，你真正需要的是这样一个模式，它包
含的匹配本身并不返回，面是用于确定正确的匹配位置，它并不是匹配
结果的一部分。换句话说，你需要进行“前后查找”。
都进行讨论。常见的正则表达式实现都支持前者，但支持后者
的就没那么多了。
Java、NET、PHP和Perl都支持向后查我（但有一些限制），
JavaSeript和ColdFusion不支持向后查找
9.2向前查找
向前查找指定了一个必须匹配但不在结果中返回的模式。向前查
找实际就是一个子表达式，而且从格式上看也确实如此，从语法上看，
一个向前查找模式其实就是一个以？=开头的子表达式，需要匹配的文
本跟在=的后面。
---
## Page 92
82
第9章前后查我
提示有些正则表达式文档使用术语“消费”（consume）来
表运“匹配和返回文本”的含义。在向前查找里，被匹配的文
本不包含在最终返回的匹配结果里，这被称为“不消费”
我们来看一个例子。例子里的原始文本是一些URL地址，而你的任
务是把它们的协议名部分提取出来（为下一步处理微准备）。下面就是这
个例子：
文本
http://www.forta.com/
https: //mai1. forta. com/
ftp://ftp.forta.com/
正则表达式
-+(?=:)
结果
http: //ww.forta.com/
https: //mai1.forta.com/
ftp://ftp.forta.com/
分析
在上面列出的URL地址里，协议名与主机名之间以一个：分隔。模
式.+匹配任意文本（第1个匹配是http），子表达式（？=：）匹配：。注意，
被匹配到的：并没有出现在最终的匹配结果里：我们用？-向正则表达式引
擎表明：只要找到：就行了，不要把它包括在最终的匹配结果里，用术语
来说，就是“不消费”它。
为了更好地理解？=的作用，我们再来看一个同样的例子，但这次不
使用向前查找元字符：
文本
http://www.forta.com/
ftp://ftp.forta.com/
https: / /mai1.forta, con/
正则表达式
- +(: )
---
## Page 93
9.3向后查找
83
结果
http://ww.forta.com/
https://mai1.forta.com/
ftp://ftp.forta.con/
分析
子表达式（：）正确地匹配到了：并消费了这个字符一：出现在了最
终的匹配结果里。
这两个例子的区别是前一个用来匹配：的模式是（?=：），后一个用来
匹配：的模式是（：），这两个模式所匹配的东西是一样的，都是紧跟在协
议名后面的那个：，它们之间的区别只是被匹配到的：字符有没有出现在
最终的匹配结果里而已。在使用向前查找的时候，正则表达式分析器将
向前查找并处理：匹配，但不会把它包括在最终的搜索结果里。模式.+（：）
查找到并且匹配结果包含：，模式.+（？=：）查找到但匹配结果不包含：。
注意向前查找（和向后查找）匹配本身其实是有返回结果的
只是这个结果的字节长度永选是0而已，国此，前后查找操作
有时也被称为零宽度（zero-width）匹配操作
提示任何一个子表达式都可以转换为一个向前查找表达
式，只要给它加上一个？=前级即可，在同一个搜索模式里可
以使用多个向前查找表达式，它们可以出现在模式里的任意
位置（而不仅仅是出现在整个模式的开头，就像你们在上面
看到的那样）。
9.3向后查找
正如你刚看到的那样，?=将向前查找（查找出现在被匹配文本之后
的字符，但不消费那个字符）。因此，？=被称为向前查找操作符，除了向
前查找，许多正则表达式实现还支持向后查找，也就是查找出现在被匹
配文本之前的字符（但不消费它），向后查找操作符是？)
结果
ABC01: $23.45
CFMX1:$899.00
HGG42:$5.31
XTC99:$69.96
Total itens found:4
分析
问题迎刃面解了。（？
c/HEAD>
正则表达式
(? *(?=)
结果
Ben Forta's Homepage
)是个向后查找操作，
（>（）