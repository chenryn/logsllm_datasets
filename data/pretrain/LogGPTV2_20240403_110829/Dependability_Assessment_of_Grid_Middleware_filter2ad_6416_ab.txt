decomposes  this  information  into  a  taxonomy  called 
the System Model (see Figure 3) which provides all the 
injection 
information  required 
to  construct  fault 
triggers as described above.  
faults 
rather 
than 
faults 
random 
By  using  this  taxonomy  and  creating  triggers  on 
specific elements, the FIT method can precisely inject 
specific 
into 
middleware  messages  as  in  standard  network  level 
fault injection techniques. The method will decode the 
middleware message and inject meaningful faults, such 
as  modifying  RPC  parameters  and  results,  adjusting 
element  attributes,  etc.  The  method  builds  on the  FIT 
framework to allow test cases to be written. These test 
cases can either be written manually, or automatically 
generated using the FIT Extended Fault Model (EFM), 
which is an extensible toolkit of Fault Models that can 
be applied to parameters and messages [5]. 
Since  FIT  can  perturb  individual  RPC  parameters 
within  middleware  messages,  it  is  particularly  well 
suited  to  assessing  systems  by  substituting  invalid 
values  in  place  of  valid  ones  and  thus  testing  such 
mechanisms as guard code at calling interfaces. Whilst 
it can be argued that the value of assessing interactions 
between  calling  interfaces  is  of  limited  use  in  normal 
non-distributed  programming,  since  these  APIs  will 
only  be  called  under  known  conditions  [9],  this  does 
not  necessarily  hold  for  distributed  systems  since  the 
interfaces are exposed and can be combined with other 
logic  in  unforeseen  ways.  Assessment  of  validation 
mechanisms  is  therefore  key  to  the  production  of 
robust services. FIT has been successfully used to not 
only  assess  service  interfaces  but  also  to  assess  third 
party dependability means [10]. 
Grid-FIT  decodes  incoming  middleware  messages 
via  a  SAX  parser.  Whilst  this  is  an  overhead  it  has 
been  found  to  be  acceptable  when  compared  to 
network transfer times commonly encountered in Grid 
applications,  and  the  method  has  been  successfully 
applied to latency injection test cases [11]. 
4. Case Study 
This case study applies the Grid-FIT tool to Globus 
Toolkit  in  order  to  demonstrate  how  dependable 
Apache  Axis  is  in  terms  of  integrity.  This  is  a  key 
concern  since  Apache  Axis  is  the  middleware  layer 
that  Globus  Toolkit  is  built  upon,  and  hence  has  a 
direct bearing on the amount of trust that can be placed 
on Globus Toolkit. The case study examines the Axis 
SOAP stack in terms of corruption of SOAP messages 
and compliance with the W3C specifications. 
4.1. Configuration 
The  case  study  examines  the  effect  of  fault 
injection  on  a  representative  sample  of  types  defined 
by  the  xsd  schema.  To  do  this  a  simple  service  was 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:38:26 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007written  which  included  a  method  for  each  xsd  type. 
Each routine received a specific xsd type and echoed it 
back  unchanged  as  the  return  value.  A  test  program 
was  written  which  called  each  service  method  in  turn 
with  a  valid  instance  of  the  type  and  compared  the 
return  result  with  the  original  data  sent.  In  each  case 
the  value  returned  should  be  identical  with  that  sent. 
The  combination  of  the  service  and  the  test  program 
provide a simple test bed to test xsd types. 
The  case  study  was  preformed  using  the  same 
version of Apache Axis as that included in Globus Java 
WS  Core  4.0.3,  namely  Apache  Axis  1.2RC2  1242 
April  28  2006.  Eclipse  3.2  was  used  to  execute  the 
Grid-FIT plug-in and all software was executed under 
Mac OS X 10.4.8 running on a PPC architecture. 
4.2. Baseline Experiment 
A baseline experiment was undertaken to determine 
the  normal  operating  conditions  of  the  test  program 
and service. The results of this experiment are given in 
Table  1  which  shows  two  criteria  for  each  xsd  type 
assessed: 1) the comparison of the returned value with 
the sent value; and 2) any exception that was generated 
as a result of the method call. 
In  general  the  middleware  behaved  as  expected, 
and from Table 1 it can be seen that none of the types 
tested generated an exception. An unexpected outcome 
of this experiment was the Date and DateTime returned 
values did not match the original values sent. 
Date and DateTime are implemented using the Java 
Standard  Library  Date  class.  Equality  between  two 
Date  instances  is  obtained  only  if  they  match  to  the 
millsecond.  Examination  of 
the  SOAP  messages 
exchanged  and  the  W3C  specifications  show  that  the 
ASCII  format  of  Date  passed  within  the  SOAP 
message  does  not  specify  Date  to  the  millisecond,  so 
when they are passed into the Java Date class a slight 
discrepancy is introduced, hence the returned instance 
will not match the one originally sent. 
The  xsd  types  defined  in  Table  1  can  be  grouped 
into  three  groupings:  1)  xsd  types  mapped  to  built-in 
Java types (dark grey in table) which comprise double, 
int,  boolean,  byte,  float,  long  and  short;  2)  xsd  types 
mapped to Java Standard Library classes (light grey in 
table)  which  comprise  String,  Date,  DateTime, 
Decimal, QName and AnySimpleType; and 3) xsd types 
that  require  specially  written  classes  within  Apache 
Axis  (white 
table)  which  comprise  AnyURI, 
Duration,  GDay,  GMonth,  GMonthDay,  GYear, 
GYearMonth, 
NCName, 
NegativeInteger,  NMTOKENS,  NonNegativeInteger, 
NonPositiveInteger,  NMToken,  NormalizedString, 
Token, 
NOTATION, 
UnsignedInt,  UnsignedByte,  UnsignedLong 
and 
PositiveInteger, 
Time, 
in 
Language, 
Name, 
UnsignedShort. 
Table 1: Baseline Experiment Results 
xsd:type 
Map to built-in Java 
type 
Map to Standard 
Java Library Class 
Date 
DateTime 
Map to Apache 
Axis Class 
Returned value equals 
sent value 
TRUE 
Exception 
Generated 
none 
TRUE 
FALSE 
FALSE 
TRUE 
none 
none 
none 
none 
4.3. Protocol Invalidation 
This  experiment  attempts  to  invalidate  the  SOAP 
protocol  whilst  retaining  syntactically  correct  XML. 
This  technique  can  be  used  to  determine  if  the 
implementation follows the protocol specification. 
Thompson et al [12] specify that “An element may 
be  valid  without  content  if  it  has  the  attribute  xsi:nil 
with  the  value  true.  An  element  so  labeled  must  be 
empty,  but  can  carry  attributes  if  permitted  by  the 
corresponding  complex  type”.  Since  the  test  program 
generates SOAP messages that contain data within the 
elements,  if  xsi:nil=“true”  is  added  as  an  attribute  to 
the  part  it  should  fail  the  scheme  validation.  By  this 
definition,  a  SOAP  message  exchanging  a  non-null 
parameter should not contain the xsi:nil attribute. 
A fault model was constructed to add xsi:nil=“true” 
to  an  element.  It  was  then  applied  to  each  request 
message  parameter  element.  This  generated  SOAP 
messages containing this attribute (see Figure 4). 
    0.0 
Figure 4: Modified SOAP message 
Table 2 shows the results from this experiment. The 
results  show  that  only  certain  types  generated  an 
exception, and these did not seem to be descriptive of 
the  schema  validation.  Of  the  types  that  returned  a 
value,  the  value  returned  was  null.  We  can  therefore 
conclude  that  setting  xsi:nil,  rather  than  causing  an 
XML  schema  violation, 
the 
middleware to infer that the element is empty and any 
implemented  by 
is 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 05:38:26 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007contents  should  be  silently  discarded.  This  causes  a 
null  object  to  be  passed  to  the  service  and  this  null 
object  is  passed  back  in  the  normal  way.  We  have 
encountered  this  type  of  behaviour  in  previous  case 
studies with previous versions of Apache SOAP [13]. 
The  exceptions  generated  can  be  explained  by  the 
xsd type implementations in Java being classified into 
two  distinct  groupings:  1)  mapping  to  built-in  types; 
and  2)  implemented  through  Java  classes,  either 
standard Java classes or specifically written. 
The groups that do not generate any exceptions are 
groups  of  xsd  types  that  map  to  Java  classes,  and 
therefore  the  null  parameter  can  be  passed  as  a  valid 
parameter. This indicates that no schema validation is 
explicitly  performed.  The  group 
that  generates 
exceptions  (the  dark  grey  shaded  group  in  Table  2) 
map to built-in types. These types cannot assume a null 
value  in  Java,  so  the  implementation  is  mapping  the 
null  value  to  a  generic  Java  Object  and  attempting  to 
match  to  method(Object)  which  does  not  exist  in  the 
service;  consequently  the  misleading  exception  is 
thrown.  It  can 
the 
exception  is  being  thrown  as  a  consequence  of 
executing an unexpected control pathway, rather than a 
deliberately  implemented  piece  of  guard  code  in  the 
middleware. 
therefore  be  concluded 
that 
Table 2: Protocol Invalidation Results 
xsd:type 
Map to built-in Java 
type 
Map to Standard 