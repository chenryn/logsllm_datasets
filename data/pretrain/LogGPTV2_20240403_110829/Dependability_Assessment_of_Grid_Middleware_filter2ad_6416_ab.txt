The information is decomposed into a taxonomy known as the System Model (refer to Figure 3). This model provides all the necessary details for constructing fault triggers, focusing on specific faults rather than random ones. By utilizing this taxonomy and creating triggers for specific elements, the FIT method can inject precise faults into middleware messages, similar to standard network-level fault injection techniques. The FIT method decodes the middleware message and injects meaningful faults, such as modifying RPC parameters and results, or adjusting element attributes. It builds upon the FIT framework, allowing for the creation of test cases, which can be written manually or automatically generated using the FIT Extended Fault Model (EFM), an extensible toolkit of fault models applicable to parameters and messages [5].

Since FIT can alter individual RPC parameters within middleware messages, it is particularly well-suited for assessing systems by substituting invalid values in place of valid ones, thereby testing mechanisms like guard code at calling interfaces. While it might be argued that evaluating interactions between calling interfaces has limited value in non-distributed programming, as these APIs are typically called under known conditions [9], this argument does not hold for distributed systems, where interfaces are exposed and can be combined with other logic in unpredictable ways. Therefore, assessing validation mechanisms is crucial for producing robust services. FIT has been successfully employed not only to evaluate service interfaces but also to assess third-party dependability measures [10].

Grid-FIT decodes incoming middleware messages using a SAX parser. Although this introduces some overhead, it is deemed acceptable when compared to the network transfer times commonly experienced in Grid applications. This method has been successfully applied to latency injection test cases [11].

### Case Study
This case study applies the Grid-FIT tool to the Globus Toolkit to demonstrate the dependability of Apache Axis in terms of integrity. This is a critical concern because Apache Axis forms the middleware layer upon which the Globus Toolkit is built, directly influencing the trust that can be placed in the Globus Toolkit. The study examines the Axis SOAP stack concerning the corruption of SOAP messages and compliance with W3C specifications.

#### 4.1 Configuration
The case study evaluates the impact of fault injection on a representative sample of types defined by the xsd schema. To achieve this, a simple service was developed, including a method for each xsd type. Each routine received a specific xsd type and returned it unchanged. A test program was written to call each service method sequentially with a valid instance of the type and compare the return result with the original data sent. In each case, the returned value should match the sent value. The combination of the service and the test program provides a straightforward test bed for xsd types.

The study used the same version of Apache Axis included in Globus Java WS Core 4.0.3, specifically Apache Axis 1.2RC2 1242 (April 28, 2006). Eclipse 3.2 was used to execute the Grid-FIT plug-in, and all software was run on Mac OS X 10.4.8 on a PPC architecture.

#### 4.2 Baseline Experiment
A baseline experiment was conducted to determine the normal operating conditions of the test program and service. The results, shown in Table 1, include two criteria for each xsd type: 1) the comparison of the returned value with the sent value, and 2) any exceptions generated by the method call.

In general, the middleware behaved as expected, and none of the tested types generated exceptions. An unexpected outcome was that the Date and DateTime returned values did not match the original values sent. Date and DateTime are implemented using the Java Standard Library Date class, where equality is achieved only if the instances match to the millisecond. The ASCII format of Date in the SOAP message does not specify Date to the millisecond, leading to a slight discrepancy when passed into the Java Date class.

The xsd types in Table 1 can be grouped into three categories: 1) xsd types mapped to built-in Java types (dark grey in the table); 2) xsd types mapped to Java Standard Library classes (light grey in the table); and 3) xsd types requiring specially written classes within Apache Axis (white in the table).

| **xsd:type** | **Map to built-in Java type** | **Map to Standard Java Library Class** | **Map to Apache Axis Class** | **Returned value equals sent value** | **Exception Generated** |
|-------------|-------------------------------|----------------------------------------|------------------------------|-------------------------------------|-------------------------|
| Date        |                               | TRUE                                   |                              | FALSE                               | none                    |
| DateTime    |                               | TRUE                                   |                              | FALSE                               | none                    |

#### 4.3 Protocol Invalidation
This experiment aims to invalidate the SOAP protocol while maintaining syntactically correct XML. This technique can be used to determine if the implementation adheres to the protocol specification. According to Thompson et al. [12], an element may be valid without content if it has the attribute `xsi:nil` with the value `true`. Such an element must be empty but can carry attributes if permitted by the corresponding complex type. Since the test program generates SOAP messages containing data within elements, adding `xsi:nil="true"` as an attribute to the part should fail the schema validation. By this definition, a SOAP message exchanging a non-null parameter should not contain the `xsi:nil` attribute.

A fault model was constructed to add `xsi:nil="true"` to an element and applied to each request message parameter element, generating SOAP messages with this attribute (see Figure 4).

| **xsd:type** | **Map to built-in Java type** | **Map to Standard Java Library Class** | **Map to Apache Axis Class** | **Returned value equals sent value** | **Exception Generated** |
|-------------|-------------------------------|----------------------------------------|------------------------------|-------------------------------------|-------------------------|
| ...         | ...                           | ...                                    | ...                          | ...                                 | ...                     |

The results show that only certain types generated exceptions, and these did not seem to be related to schema validation. For the types that returned a value, the returned value was null. Therefore, setting `xsi:nil` causes the middleware to infer that the element is empty and discard its contents silently, passing a null object to the service, which is then returned normally. This behavior has been observed in previous case studies with earlier versions of Apache SOAP [13].

The exceptions generated can be explained by the xsd type implementations in Java being classified into two groups: 1) mapping to built-in types; and 2) implemented through Java classes, either standard or specifically written. The groups that do not generate exceptions are those that map to Java classes, indicating no explicit schema validation. The group that generates exceptions (the dark grey shaded group in Table 2) maps to built-in types, which cannot assume a null value in Java. Consequently, the implementation attempts to match the null value to a generic Java Object, leading to a misleading exception. This suggests that the exception is thrown due to an unexpected control pathway rather than a deliberately implemented guard code in the middleware.