title:An educational networking framework for full layer implementation
and testing
author:Keunhong Lee and
Joongi Kim and
Sue B. Moon
An Educational Networking Framework
for Full Layer Implementation and Testing
Keunhong Lee, Joongi Kim, Sue Moon
Department of Computer Science, KAIST
{khlee, joongi}@an.kaist.ac.kr, PI:EMAIL
ABSTRACT
1 Introduction
We present the KENSv2 (KAIST Educational Network
System) framework for network protocol implementation.
The framework is event-driven to guarantee deterministic
behaviour and reproducibility, which in turn delivers ease of
debugging and evaluation. Our framework consists of four
components: the event generator, the virtual host, the TCP
driver and the IP driver. The two drivers are what students
have to implement, and we oﬀer to the students the drivers
in the binary format for paired testing and debugging. We
have developed a test suite that covers three categories of
test cases: speciﬁcation, paired, and logic tests. The frame-
work logs packet transmissions in the PCAP format to allow
use of widely available packet analysis tools. Those tools
help inspecting logical behaviour of student solutions, such
as congestion control. We have designed ﬁve step-by-step
assignments and evaluated student submissions. With our
automated test suite, we have cut down the number of TAs
by half for the doubled class size from the previous semester,
in total of 3 TAs and 49 students. We plan to continue us-
ing KENSv2 in our undergraduate networking course and
expand the test suite.
Categories and Subject Descriptors
C.2.2 [Computer-Communication Networks]: Net-
work Protocols—Protocol veriﬁcation; D.2.5 [Software En-
gineering]: Testing and Debugging—Testing tools; K.3.2
[Computers and Education]: Computer and Informa-
tion Science Education—Computer science education, self-
assessment
General Terms
Design; Veriﬁcation
Keywords
Educational Networking Framework; Full Layer Implemen-
tation; Automated Test Suite; Network protocols; TCP; IP
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
SIGCSE’15, March 4–7, 2015, Kansas City, MO, USA.
Copyright c(cid:13) 2015 ACM 978-1-4503-2966-8/15/03 ...$15.00.
http://dx.doi.org/10.1145/2676723.2677304.
In our computer science discipline, hands-on projects chal-
lenge students to build systems they learn in class. These
projects have always been an integral part of our curricula.
Kurose and Ross supplement their textbook on computer
networking with Wireshark1 labs and programming assign-
ments for network applications [1]. Wireshark labs help
students to grasp quickly the workings of today’s Internet
via packet trace analysis without writing code. MYSOCK/
STCP2 have been used in undergraduate networking courses
for students to implement the socket API and a simpliﬁed
TCP connection mechanism to work over simulated packet
losses and reordering. Clack [2] provides modular network
stack implementations including TCP, and students observe
TCP congestions in a graphical way.
The popular net-
work simulation tool, ns23, has accumulated an extensive
set of protocol implementations in the past two decades,
but its primary goal is to examine the protocol performance
against other competing traﬃc rather than to provide ab-
stractions for learning and implementation. While ns2 oper-
ates strictly in a simulated environment, emulab4 and ONL
(Open Network Laboratory) [3] oﬀer an emulated network-
ing environment with ease of access and conﬁgurability. VNS
[4] and its successor Mininet [5, 6] have empowered research-
ers with a container-based emulation environment that close-
ly matches the performance of a real testbed with high ﬁ-
delity.
For a complete learning experience, students should be
able to implement and test the full protocol stack in realis-
tic settings but focus on core networking features only. The
assignment should avoid including extra burdens such as ker-
nel programming or concurrency management. It is a com-
mon method to punch-hole a set of functions in educational
frameworks for systems and let the students ﬁll them as as-
signments. While it gives the instructor the power to choose
at will features for programming assignments, it burdens the
students with understanding of the entire framework and in-
teraction of their own code with the rest of the framework.
However, this punch-hole approach alone is not suitable for
network protocols because of their paired and asynchronous
nature—an implementation of a network protocol cannot
operate and be tested without a counterpart. Thus an ed-
ucational framework for network protocols should be able
1http://www.wireshark.org/
2http://www.stanford.edu/class/cs244a/hw3/hw3.html
3http://www.isi.edu/nsnam/ns/
4http://www.emulab.net
663Figure 1: Overview structure of KENSv2 framework
to launch multiple instances of diﬀerent protocol implemen-
tations for paired testing, in addition to punch-holed func-
tions for individual implementations. The framework needs
to work as a demonstration of protocol abstractions instead
of a simple code template. Moreover, asynchronous execu-
tions over multiple hosts make the system unpredictable.
The framework should be deterministic to ease tracking, de-
bugging, and evaluation of students’ solutions.
In this work we present KENSv2 (KAIST Educational
Network System), a framework for students to implement
TCP, IP, and routing protocols, and test against adversary
implementations. Our framework is event-driven for deter-
ministic behaviour and reproducibility. We have designed
KENSv2, implemented it and have used it in an undergrad-
uate computer networking course. In Section 2 we elaborate
on our design decisions and in Section 3 present the frame-
work overview. In Section 4 we describe our assignments,
and in Section 5 evaluation results. We summarize our ex-
perience and lay out future work in Section 6.
2 Design Decisions
KENSv2 is an educational framework, and our design de-
cisions are diﬀer from that of general-purpose frameworks.
2.1 Adversary Implementation
A unique requirement of an educational framework for
network programming is the need for adversary implemen-
tation. Most functionalities in network protocols are not
one-sided but require a responding counterpart. For a stu-
dent to have a working implementation of connect(), s/he
must have a matching implementation of accept(). We
provide these counterparts to allow students to use them
for running their code under development. Since this is an
educational framework, we should not expose the reference
solution. Thus, the counterparts are in the binary format to
hide the source code, while providing the required function-
ality.
Another motivation for adversary implementation is de-
coupling of the test code and implementation code for Test-
driven development (TDD).
For example in Pintos [7], testing thread functionalities,
running threads and checking the execution order are all in-
dependent from context switching and scheduling and can
be performed in separate units. The source code of the test-
ing suite is available with the framework and is independent
of the source code being tested. On the contrary, the test-
ing suite of network protocols follows the protocol logic and
are not independent from the target implementation. The
source code for the network logic should not be exposed to
the students, but testing logic itself should be available to
students.
2.2 Event-Driven Framework
Reproducibility is critical for an educational framework
since students should have a consistent view on how things
work [6]. Like other network simulation tools such as ns2,
our framework oﬀers a deterministic, reproducible environ-
ment that make evaluation straightforward.
To achieve this goal KENSv2 provides an event-driven
programming model for layers and a discrete virtual clock.
The event-driven model simpliﬁes execution of multiple lay-
ers and multiple instances of layer implementation by multi-
plexing them in a single process. To avoid function calls that
cross multiple layers from indeﬁnitely blocking other events,
we split a blocking call into two parts, raise and completion,
to simulate asynchronous function calls. The virtual clock
allows insertion of arbitrary network delay and losses while
we run the simulation. We constrain all layer modules to
register callback functions for network events. The event
generator provides inputs from their upper/lower layers and
and the timing information through the registered callback
functions.
To deploy KENSv2 on real netweorks, it needs to adapt
with existing userspace packet IO schemes such as netmap
Student’s TCP DriverStudent’s IP DriverKENS Event GeneratorPacket EventPacket EventNetwork EventsPCAP LogAdversary TCP DriverAdversary IP DriverPacket EventPacket EventNetwork EventsPCAP LogSystem Call EventKENS Virtual HostKENS Virtual HostSystem Call Event664Figure 2: Function prototypes of the KENSv2 TCP
driver
[8], psio [9], and Intel DPDK (Data-plane Development
Kit) [10]. The challenge here is to combine our event-driven
scheduler with the polling loops used in modern userspace
packet IO libraries for high-performance. We plane to add
an adaptor that runs in polling mode and translates input
packets to packet events.
3 KENSv2 Framework
3.1 Framework Overview
Our KENSv2 framework consists of the following four
components: an event generator, virtual hosts, IP drivers,
and TCP drivers. Figure 1 show the overall architecture of
KENSv2. We have implemented our framework in C.
KENSv2 Virtual Host acts as an application layer to
TCP and as the combined data link and physical layer to
IP. The virtual host encapsulates all the interfaces that the
student’s code has with the framework. It is also capable of
logging all network events in the PCAP5 format. Students
can easily visualize and evaluate the log by using Wireshark6
or other packet analysis tools. This approach is also used in
[11]. Like Web100[12], the virtual host pumps system call
events to its TCP driver.
KENSv2 Event Generator feeds events to the virtual
hosts. It functions both as a virtual application and the un-
derlying network. It keeps track of a virtual clock and drives
the simulation according to it. As the underlying network,
it introduces network latency and packet drops. As a virtual
application, it initiates system call events towards the TCP
layer and they propagate through the TCP and IP layers
back to the event generator. By running multiple virtual
hosts on top of a single event generator, the framework can
5MIME type vnd.tcpdump.pcap.
iana.org/assignments/media-types/application/vnd.
tcpdump.pcap
6https://www.wireshark.org/
See http://www.
Figure 3: System APIs. It shows the case for TCP
drivers, but the IP drivers share the similar interface
preﬁxed with “ip_” instead.
Figure 4: Context mapping between ﬁle descriptors
and KENSv2 TCP contexts
simulate a network of multiple hosts running a set of appli-
cations.
Students’ TCP and IP Drivers are the part that stu-
dents should actually implement. The structure of driver is
shown in Figure 2.
Adversary Drivers are binary counterparts for debugging
and testing.
3.2 Network Driver Abstraction
Our driver abstraction provides a uniﬁed interface for net-
work layer implementations. Drivers cannot access the sys-
tem or other drivers directly but only through a set of API
and utility functions. The API hides environment-speciﬁc
details from the drivers; students can run their implementa-
tions on both real and testing environments seamlessly with-
out modifying their codes. The TCP and IP drivers share
the similar abstraction with minor diﬀerences depending on
what their lower/upper layers are.
System API. Drivers have access to the system resources
via the following functions. Figure 3 illustrates them:
• retrieve system clock
• register/unregister timer
• wake up blocked applications
• send data to lower/upper network layer
Network/System Event Callbacks. To interact with
other layers and run timed operations, each driver registers
a few callback functions:
• initialization/destruction event of the driver
• system call requests
struct kens_tcp_driver_t{ //system call mapping void (*startup)(kens_system_lib*); void (*shutdown)(kens_tcp_driver*);  my_context (*open)(kens_tcp_driver*, int*); void (*close)(kens_tcp_driver*, my_context,int*); bool (*bind)(kens_tcp_driver*, my_context,    const struct sockaddr *, socklen_t, int*); bool (*listen)(kens_tcp_driver*, my_context, int, int*); bool (*connect)(kens_tcp_driver*, my_context,   const struct sockaddr *, socklen_t, int*); bool (*accept)(kens_tcp_driver*, my_context, int*); bool (*getsockname)(kens_tcp_driver*, my_context,   struct sockaddr *, socklen_t *, int*); bool (*getpeername)(kens_tcp_driver*, my_context,    struct sockaddr *, socklen_t *, int*); void (*timer)(kens_tcp_driver*, my_context, int); //automatically called by ip layer void (*ip_dispatch_tcp)(kens_tcp_driver*,    struct in_addr, struct in_addr, const void *, size_t); //application link int (*app_dispatch_tcp)(kens_tcp_driver*, my_context,    const void*, size_t);};typedef struct{ //access the local routing table uint32_t (*ip_host_address)(struct in_addr target); //send packet to lower layer int (*tcp_dispatch_ip)(struct in_addr src_addr,    struct in_addr dest_addr, void * data, size_t data_size); //send packet to upper layer int (*tcp_dispatch_app)(my_context handle,    const void* data, size_t data_size); //wake up sleeping 'accept' system call bool (*tcp_passive_open)(my_context server_handle,    my_context new_handle); //wake up sleeping 'connect' system call bool (*tcp_active_open)(my_context handle); //current time in milliseconds int (*tcp_get_mtime)();  bool (*tcp_register_timer)(my_context context, int mtime); void (*tcp_unregister_timer)(my_context context); //disconnect tcp-app linkage for a socket hanle void (*tcp_shutdown_app)(my_context handle);}kens_system_lib;LinuxKENSint fd = socket(...);bind(fd, ...);my_context* ctx = my_open(...);my_bind(ctx, ...);665• timer events
• data arrival from lower/upper network layer
Students receive a skeleton of a driver (either TCP or IP)
and are assigned to ﬁll the above callback functions. They
can use the system API as they need.
To reduce the burden of managing unique numbering for
process IDs and ﬁle descriptors, we also oﬀer a context map-
ping scheme as shown in Figure 4, which internally maps
each context data to individual TCP socket. The frame-
work translates each ﬁle descriptor into the pointer of its
context data. Drivers use this information to distinguish
each socket from the attached context data.
3.3 Test Suite
At the moment we have implemented only the TCP test
suite and are working on the IP test suite. The test suite