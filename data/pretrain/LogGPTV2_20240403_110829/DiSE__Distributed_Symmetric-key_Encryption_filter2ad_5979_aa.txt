title:DiSE: Distributed Symmetric-key Encryption
author:Shashank Agrawal and
Payman Mohassel and
Pratyay Mukherjee and
Peter Rindal
DiSE: Distributed Symmetric-key Encryption
Shashank Agrawal1, Payman Mohassel2, Pratyay Mukherjee3, and Peter Rindal∗4
1Visa Research, PI:EMAIL
2Visa Research, PI:EMAIL
3Visa Research, PI:EMAIL
4Oregon State University, PI:EMAIL
Abstract
Threshold cryptography provides a mechanism for protecting secret keys by sharing
them among multiple parties, who then jointly perform cryptographic operations. An
attacker who corrupts upto a threshold number of parties cannot recover the secrets
or violate security. Prior works in this space have mostly focused on deﬁnitions and
constructions for public-key cryptography and digital signatures, and thus do not capture
the security concerns and eﬃciency challenges of symmetric-key based applications which
commonly use long-term (unprotected) master keys to protect data at rest, authenticate
clients on enterprise networks, and secure data and payments on IoT devices.
We put forth the ﬁrst formal treatment for distributed symmetric-key encryption,
proposing new notions of correctness, privacy and authenticity in presence of malicious
attackers. We provide strong and intuitive game-based deﬁnitions that are easy to un-
derstand and yield eﬃcient constructions.
We propose a generic construction of threshold authenticated encryption based on
any distributed pseudorandom function (DPRF). When instantiated with the two diﬀer-
ent DPRF constructions proposed by Naor, Pinkas and Reingold (Eurocrypt 1999) and
our enhanced versions, we obtain several eﬃcient constructions meeting diﬀerent security
deﬁnitions. We implement these variants and provide extensive performance compar-
isons. Our most eﬃcient instantiation uses only symmetric-key primitives and achieves
a throughput of upto 1 million encryptions/decryptions per seconds, or alternatively a
sub-millisecond latency with upto 18 participating parties.
∗Work done as an intern at Visa Research.
1
Contents
1 Introduction
1.1 Technical Challenges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Our Contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2 Technical Overview
2.1 Security Requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Our Generic Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3 Related Work
4 Preliminaries
5 Distributed Pseudo-random Functions: Deﬁnitions
6 Threshold Symmetric-key Encryption: Deﬁnitions
6.1 Correctness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.2 Message privacy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6.3 Authenticity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7 Our Construction: DiSE
8 Instantiations of Distributed Pseudorandom Functions
8.1 DDH-based construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8.2 PRF-based construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9 Experimental Evaluation
10 Acknowledgment
A Cryptographic Primitives
A.1 Authenticated Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.2 Commitment
. . . . . . . . . . . . . . . . . . . . . . . . . .
A.3 Secret Sharing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.4 Non-interactive Zero-knowledge . . . . . . . . . . . . . . . . . . . . . . . . . .
A.2.1 Concrete instantiations.
B A few failed attempts in detail
. . . . .
B.1 Attempt 1: Distributed Encryption Scheme proposed by Naor et al.
B.2 Attempt 2: DPRF + Authenticated Encryption . . . . . . . . . . . . . . . . .
C Missing Proofs
C.1 Proof of Theorem 7.4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C.2 Proof of Theorem 7.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C.3 Proof of Theorem 7.6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C.4 Proof of Theorem 8.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C.5 Proof of Theorem 8.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C.6 Proof of Theorem 8.4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3
4
6
7
7
10
12
14
15
17
18
19
20
22
25
25
28
29
31
37
37
38
39
39
40
41
41
42
42
42
45
46
48
53
56
2
1
Introduction
A central advantage of using cryptographic primitives such as symmetric-key encryption is
that the safety of a large amount of sensitive data can be reduced to the safety of a very
small key. To get any real beneﬁt from this approach, however, the key must be protected
securely. One could encrypt the key with another key, protect it using secure hardware (e.g.
HSM, SGX or SE), or split it across multiple parties. Clearly, the ﬁrst approach only shifts
the problem to protecting another key. On the other hand secure hardware, co-processors
and the like provide reasonable security but are not always available, are expensive or not
scalable, lack programmability and are prone to side-channel attacks.
i.e. threshold cryptography,
Splitting the key among multiple parties,
is an eﬀective
general-purpose solution, that has recently emerged in practice as an alternative software-
only solution [dya, por, sep]. Surprisingly, prior to our work, there was no formal treatment
of distributed symmetric-key encryption. Prior formal treatments of threshold cryptography
typically focus on the asymmetric-key setting, namely public-key encryption and signature
schemes [DF90, DDFY94, GJKR96, CG99, DK01, AMN01, SG02, Bol03, BBH06, GHKR08,
BD10] where the signing/decryption key and algorithms are distributed among multiple par-
ties. This is despite the fact that a large fraction of applications that can beneﬁt from
stronger secret-key protection primarily use symmetric-key cryptographic primitives wherein
secret keys persist for a long time. We review three such examples below:
Secret Management Systems. An increasing number of tools and popular open source
software such as Keywhiz, Knox, and Hashicorp Vault (e.g. see [sec]) are designed to automate
the management and protection of secrets such as sensitive data and credentials in cloud-
based settings by encrypting data at rest and managing keys and authentication. These tools
provide a wide range of features such as interoperability between clouds and audit/compliance
support. By far, the most commonly adopted primitive for encrypting secrets in the stor-
age backend is authenticated encryption with a master data encryption key that encrypts a
large number of records. Some of these systems use secret sharing to provide limited key
protection in an initialization stage but once keys are reconstructed in memory they remain
unencrypted until the system is rebooted. Consider the following statement from Hashicorp
Vault’s architecture documentation [vaua]:
“Once started, the Vault is in a sealed state . . . When the Vault is initialized it generates an encryption
key which is used to protect all the data. That key is protected by a master key. By default, Vault uses a
technique known as Shamir’s secret sharing algorithm to split the master key into 5 shares, any 3 of which
are required to reconstruct the master key . . . Once Vault retrieves the encryption key, it is able to decrypt
the data in the storage backend, and enters the unsealed state.”
Enterprise Network Authentication. Network authentication protocols such as Ker-
beros [kerb] are widely used to provide a single-sign-on experience to users by enabling them
to authenticate periodically (e.g. once a day) to a ticket-granting service using their creden-
tials, to obtain a ticket-granting ticket (TGT) that they use to get access to various services
such as mail, printers and internal web. The recommended approach for generating the TGT
is authenticated encryption (e.g. see [kera]) using a master secret key in order to provide
both conﬁdentiality and integrity for the information contained in the ticket. This renders
the master secret key an important attack target, as it remains unprotected in memory over
a long period.
3
Multi-device IoT Authentication. The proliferation of a wide range of Internet of
Things (IoT) has provided users with new and convenient ways to interact with the world
around them. Such devices are increasingly used to store secrets that are used to authen-
ticate users or enable secure payments. Many IoT devices are not equipped with proper
environments to store secret keys, and even when they are, provide developers with little
programmability for their applications.
It is therefore desirable to leverage the fact that
many users own multiple devices (smart phone, smart watch, smart TV, etc.) to distribute
the key material among them (instead of keeping it entirely on any single device) to enable
multi-device cryptographic functionalities without making strong assumptions about a de-
vice’s security features. Given the limited computation and communication power of many
such IoT devices, such distributed primitives should require minimal interaction and limited
cryptographic capabilities (e.g. only block-ciphers).
1.1 Technical Challenges
Modeling security As discussed earlier, existing threshold cryptographic deﬁnitions and
constructions are primarily focused on public-key primitives such as digital signatures and
public-key encryption. In fact, to the best of our knowledge, there is no standard symmetric-
key security notions in the distributed setting.
To help highlight the challenges with deﬁning a robust security model, consider a software-
based encryption/authentication service wherein long-term secret keys are shared among
multiple servers who collectively perform symmetric encryption, decryption, and MAC oper-
ations to store data in the cloud in an encrypted form, or to generate authentication tokens
that are used to gain access to an external service. For example, the service can be used
by cloud storage customers to encrypt/decrypt data on the cloud using a key that is never
reconstructed after being distributed among the servers, or can be used to generate authen-
tication tokens for a single-sign-on access control system that provides access to multiple
services. A subset of these servers (below a threshold) are corrupted by an active adversary
and can behave arbitrarily malicious but a secure point-to-point channel is assumed between
the honest parties.
Observe that threshold authenticated encryption (TAE) is the appropriate and natural
notion here as it would simultaneously solve the conﬁdentiality and the authenticity prob-
lem, such that a ciphertext generated by the TAE scheme could be both an authentication
tickets and an encrypted message. Unfortunately, while deﬁnitions for threshold public-key
encryption are well-understood (e.g. see [SG98, CG99, DP08, BD10, BBH06]), they fail to
capture important subtleties that only arise in the symmetric-key setting when considering
standard AE notions of message privacy and ciphertext integrity [BN00, KY01, RS06].
First note that in the above scenario, servers or parties are simply workers and have no
special roles in the application that uses the service. In particular, a party who initiates the
ciphertext generation may not be the one initiating the decryption process, and for availability
reasons, we do not assume that the same encryptor is online/available during a decryption
call. This necessitates a consistency property where a ciphertext generated by any subset of
parties should be decryptable by any other subset that is larger than a threshold.
However, what truly separates TAE from threshold public-key encryption is that in TAE
a corrupted party should not be able to encrypt or decrypt messages on her own or even
generate valid ciphertexts, without “being online” (i.e. without interaction with the honest
parties in a distributed encryption/decryption protocol), and this should hold even if the
adversary engages in other distributed encryption and decryption protocols.
4
Capturing all legitimate adversarial interactions in our security games is quite critical and
subtle. For example, note that unlike the non-interactive setting, chosen plaintext attack
(CPA) security is not suﬃcient to capture message privacy in the distributed setting where
we need to guarantee message privacy not only in the presence of encryption queries but also
during decryption queries initiated by the honest parties. In other words, the transcripts of
such decryption queries should not reveal anything about the message being decrypted to the
adversary. Second, unlike the standard (non-interactive) ciphertext integrity notions where it
is shown that decryption queries cannot help the adversary and hence can be safely removed
from the security game (e.g. see [BGM04]), it is easy to observe that allowing for decryption
queries in the threshold setting makes the adversary strictly stronger. For instance, consider
a contrived threshold scheme where all parties contacted in the decryption protocol simply
return their secrets. Clearly, this scheme is not secure, but it would still satisfy a ciphertext
integrity notion that does not allow the adversary to invoke the decryption protocol.
Furthermore, adversarial encryption and decryption queries are of various diﬀerent ﬂavors.
Those where the adversary is the initiator (i.e. the encryptor/decryptor), and those where
an honest party initiates the query (indirect queries) but the adversary arbitrarily controls
the corrupted parties taking part in the protocol. In case of indirect encryption queries, in
the message privacy game, we let the adversary choose the message being encrypted and
learn the resulting ciphertext. This captures, for example, a scenario where a cloud storage
provider that uses the service is compromised and ciphertexts generated by honest encryptors
are revealed. On the other hand, in the ciphertext integrity game, it is crucial not to reveal
the ciphertext to the adversary in the indirect encryption queries and require that it cannot
learn the full ciphertext based on its interactions. Otherwise, an honest party’s call to the
encryption protocol provides the adversary with a valid ciphertext (token) that may give him
access to an external service. Similar subtleties arise for decryption queries which we discuss
in more detail in Section 2.
Finally, unlike the non-interactive case, deﬁning what constitutes a valid forgery in the ci-
phertext integrity game is non-trivial. First, note that standard AE requires that ciphertexts
produced via encryption queries are distinct from the forged ciphertext. In the interactive
setting where the adversary takes part in the encryption protocol, however, generated ci-
phertexts may not be well-deﬁned or valid. Moreover, there are two possible ways of testing
validity of a forged ciphertext in the integrity game: (i) decrypt the forgery using an honest
decryption (i.e. an execution of the decryption protocol that does not involve any corrup-
tion), or (ii) run the decryption protocol wherein adversary controls the corrupted parties.
This leads to two diﬀerent notions of authenticity.
Performance Challenges.
In addition to not meeting our security notions, existing thresh-
old public-key constructions are too expensive for symmetric-key use cases, as they are dom-
inated by more expensive public-key operations and/or require extensive interaction and
communication between the parties. Applications that use symmetric-key cryptography