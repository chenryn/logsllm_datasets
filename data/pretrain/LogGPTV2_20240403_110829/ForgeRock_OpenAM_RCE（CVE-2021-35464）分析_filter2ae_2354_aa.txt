# ForgeRock OpenAM RCE（CVE-2021-35464）分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x01 漏洞描述
2021年6月30日，国外安全研究人员披露了ForgeRock
AM远程代码执行漏洞，漏洞编号为CVE-2021-35464。攻击者可在无需认证的情况下，通过构造特殊的请求，触发反序列化，从而执行任意代码，接管运行ForgeRock
AM的服务器。本文从漏洞挖掘的角度分析其中的技术细节，也将公开一些其他的反序列化点。
## 0x02 环境搭建
###  0x1 Docker 搭建
直接使用官方提供的docker资源进行搭建，并开启调试环境
    docker run  -d -p 7080:8080 -p 5005:5005 --name openam openidentityplatform/openam:14.6.2
    docker run -d -p 1389:1389 -p 1636:1636 -p 4444:4444 --name ldap-01 openidentityplatform/opendj
###  0x2 添加依赖
向IDEA中添加依赖
###  0x2 开启调试
官方提供的Docker 容器不是root权限的用户，里面也没有sudo指令，我们要想办法把权限提升到root才能有机会开启调试配置
    openam@6eb4404f536b:/usr/local/tomcat$ cat /etc/passwd
    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    bin:x:2:2:bin:/bin:/usr/sbin/nologin
    sys:x:3:3:sys:/dev:/usr/sbin/nologin
    sync:x:4:65534:sync:/bin:/bin/sync
    games:x:5:60:games:/usr/games:/usr/sbin/nologin
    man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
    lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
    mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
    news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
    uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
    proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
    www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
    backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
    list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
    irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin
    gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin
    nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
    _apt:x:100:65534::/nonexistent:/usr/sbin/nologin
    openam:x:1001:0::/home/openam:/bin/sh
通过查看/etc/passwd文件得知openam用户的uid为1001，我们将其强制性修改成0，并利用docker
cp指令进行替换，效果如下安装一些必要的软件vim等
看目录像是tomcat起的，所以开启调试就很明确了，找打catalina.sh添加调试信息，添加此行配置
显示Connected则连接成功
## 0x03 漏洞挖掘
按照漏洞挖掘者的原话，分析web.xml中的每一个servlet，认真梳理其中的处理逻辑，跟着这个思路走，确实可以找到这个漏洞的路由，但是这样正向分析起来工作量巨大。但如果实现知道危险函数所在的文件及函数会更方便漏洞挖掘工作。针对这个漏洞来讲，我们只需要搜索readObject关键字就能找到这个漏洞点。
首先将WEB-INF/lib目录下的jar包全部解压
直接在命令行中搜索关键字readObject，会有搜索到很多相关的class文件
尝试打开其中的几个文件
openam-shared-14.6.3/org/forgerock/openam/utils/IOUtils.class
,该文件中存在deserialise函数，但是在反序列化的时候有白名单，因此寻找下一个类。
关于这个路由的分析统一放在漏洞路由分析中讲解。
下一个匹配到的class是 jato-14.6.3/com/iplanet/jato/util/Encoder.class
再次搜索关于Encoder类的调用，可以找到几个相关联的类，因为分析过以下几个代码，所以这里直接看ViewBeanBase代码中的逻辑。
ViewBeanBase.class代码如下
找到反序列化的入口后有两个问题需要我们解决
  * 如何找到触发漏洞的路由
  * 如何编写反序列化利用链
下面主要围绕这两个问题进行分析。
## 0x04 漏洞路由分析
如何才能通过前端访问触发该漏洞呢，这还是要结合着web.xml进行分析，在这个xml文件中定义了很多servlet，很多URL与之对应着。
###  0x1 xml分析
通过分析Servlet后，找到了感兴趣的Servlet，比如这里以TaskServlet为例
## 0x2 请求处理
TaskServlet继承ConsoleServletBase，对前端发送来的请求是父类的父类做的处理.
可以清楚的看到ConsoleServletBase继承ApplicationServletBase。
ApplicationServletBase中包含get和post请求方法的响应代码，最后都会调用processRequest进行统一处理。
至此我们分析到了第一层请求处理逻辑，剩下还有很多路要走，先来看一下openAM怎么对路由进行权限校验的。
###  0x3 权限校验
通过分析ApplicationServletBase的processRequest处理函数，该函数在处理请求期间调用了fireBeforeRequestEvent函数，并且这个函数最终会调用onBeforeRequest函数。
TaskServlet的父类ConsoleServletBase中有对onBeforeRequest的实现，并且在里面做了权限校验。validateSSOToken里校验了token的是否合法。
###  0x4 未认证路由