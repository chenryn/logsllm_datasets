pets and code execution path in firmware. This novel mutation
mechanism enables that Snipuzz does not need any syntax rules
to infer the hidden grammatical structure of the input through
the device responses. Compared with the actual syntax rules that
determine the input string format, the result of snippet determi-
nation proposed by Snipuzz has a similarity of 87.1%.
• More effective IoT fuzzing. When testing IoT devices, the num-
ber of response categories is positively correlated with the num-
ber of code execution paths in the firmware. In the experiment,
the number of response categories explored by Snipuzz far ex-
ceeded other methods on most devices, no matter how long the
analysis duration was (in 10 minutes or 24 hours).
• Implementation and vulnerability findings. We implemented
the prototype of Snipuzz.2 We used it to test 20 real-world
consumer-grade IoT devices while comparing with the state-
of-the-art fuzzing tools, i.e., IoTFuzzer, Doona, Boofuzz, and
Nemesys. In 5 out of 20 devices, Snipuzz successfully found 5
zero-day vulnerabilities, including null pointer exceptions, denial
of service, and unknown crashes, and 3 of them could be exposed
only by Snipuzz.
2 BACKGROUND
2.1 Fuzz Testing
Fuzzing is a powerful automatic testing tool to detect software
vulnerabilities. After decades of development, fuzzing has been
widely used as a base in several security testing domains, such as
the OS kernel [12, 36], servers [33], and the blockchain [3].
In general, fuzzing feeds the target programs with numerous
mutated inputs and monitors exceptions (e.g., crashes). If an execu-
tion reveals undesired behavior, a vulnerability could be detected.
To discover vulnerabilities more effectively, fuzzing algorithms op-
timize the mutation process based on feedback of executions (e.g.,
coverage knowledge), instead of using a purely random mutation
strategy. Moreover, fuzzers can judge from the feedback mechanism
whether each test case generated by seed mutation is “interesting”
(i.e., whether the test case has explored unseen execution states). If a
test case is interesting, it will be reserved as a new seed to participate
in future mutation. With the feedback, many fuzzers [4, 5, 29, 41, 49]
steer the computing resources towards the interesting test cases
and achieve higher possibility to discover vulnerabilities.
2.2 Generic Communication Architecture of
IoT Devices
To react with external inputs, most IoT devices implement a similar
high-level communication architecture. As per the pseudo code
example presented in Figure 1, a typical implementation of the
communication architecture may consist of four parts: 1) Sanitizer,
2) Function Switch, 3) Function Definitions, and 4) Replier.
When an IoT device receives an external input, Sanitizer starts
parsing the input and performs regular matching. If the input for-
mat breaches the syntactic requirements, or an exception occurs
2Publicly available at https://github.com/XtEsco/Snipuzz.
during the parsing process, Sanitizer will directly notify Replier by
sending a response message describing the input error and termi-
nate the processing of input. If the input is syntactically correct,
Function Switch transfers control to the corresponding Functions
according to the attribute, Key, and corresponding value, val, ex-
tracted from the input. If Key cannot be matched, the processing of
this input will be terminated, similarly as done by Replier. When
Functions completes the processing, such as setFlow(), with the
parameter val, it notifies Replier to generate the response message.
Note that, the implementation of Functions is specific to IoT devices.
As described above, Replier is responsible for sending responses
to the client (such as the user’s APP). Based on the calling situ-
ation (indicated by the parameter code in the example), Replier
determines the content of response message to be sent.
3 MOTIVATION
3.1 Response-Based Feedback Mechanism
The interactive capabilities of IoT devices make it possible to test se-
curity of device firmware through the network. However, there are
also some challenges when testing IoT devices using network-based
fuzzers. Since most network fuzzing methods cannot directly obtain
execution status of the device, it is hard to establish an effective
feedback mechanism to guide the fuzzing process. Without feed-
back mechanism, the fuzzing tests could be blind in the selection
of mutation targets, and may lean to a brute force random test.
As discussed previously, due to the lack of open-sourced firmware,
it is difficult or even impossible to instrument the IoT devices. There-
fore, the response messages returned by the firmware can be re-
garded as a valuable source of device status information at run-time.
The Replier in Figure 1 will use the value of the variable code to
determine the content of the response messages. The value of code
comes from many different function blocks in the firmware. Pa-
rameters are passed when Sanitizer fails to parse the input or some
exceptions are triggered; or when the Function Switch cannot match
the key command characters in the input; or after each input is
executed in the Functions. Therefore, through the content of the
response message, the code block that has been executed in the
firmware can be inferred. When the firmware source code is not
available, the correspondence between the firmware execution and
the response messages cannot be directly extracted. Moreover, the
firmware may return the same response messages even executing
different functions.
Although the response message cannot be equated to the exe-
cution path of the device, it can still play an important role in the
black-box fuzz testing for IoT devices. Although it is hard to link
the code execution path corresponding to each response message,
if the two inputs get different response messages, we can deduce
that the two inputs go to different firmware code execution paths.
Our approach. Snipuzz uses the response message to establish
a new feedback mechanism. Snipuzz will collect every response,
and when a new response is found, the input corresponding to the
response will be queued as a seed for subsequent mutation testing.
3.2 Message Snippet Inference
The firmware of the IoT device can be regarded as a software pro-
gram with strict syntax requirements for input. If the byte-based
Session 2A: Fuzzing and Bug Finding CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea339Figure 1: Interaction with IoT Firmware. Most implementations of IoT devices have a similar communication architecture, including Sanitizer,
Function Switch, Function Definitions, and Replier. If the Sanitizer and the Function Switch perform correctly, corresponding functionalities
will be executed. Except for crashes, the Replier will always send responses to clients.
the messages
𝑘
mutation strategies (such as mutating each byte in the input one
by one or randomly selecting bytes for mutation testing) are used
in the fuzz testing, the generated test cases could be rare to meet
the input syntax requirements. The grammar-based fuzzers utilize
detailed documents or a large training data set to learn the gram-
matical rules and use it to guide the generation of mutation [34, 40].
In many cases, the input syntax in IoT devices is diverse or non-
standard. Table 1 shows the communication format requirements
used in 20 IoT devices from different vendors. Some of them are
using well-known formats such as JSON and SOAP, but some use
Key-value pairs or even custom strings as communication format.
Therefore, it is difficult to provide grammar specifications or estab-
lish training data sets that cover communication formats on a large
scale for the grammar-based mutation strategy.
The best grammar guidance originates from the firmware itself.
Responses from IoT devices suggest the execution results of mes-
sages. If we mutate a valid message byte by byte (i.e., breaching the
format), we will get many different responses. If mutation of two
different positions in the valid message receives the same response,
these two positions have a high possibility that they are related to
the same functionality in firmware. Therefore, those consecutive
bytes with the same response can be merged into one snippet. This
method of inferring message snippets can clearly reflect the util-
ity of each byte after entering the firmware. In addition, mutation
based on message snippets can largely reduce the search space and
improve the efficiency of fuzzing.
Our approach. Snipuzz merges consecutive bytes with the same
response into one snippet. We also propose different mutation
operators performing on snippets.
4 METHODOLOGY
In order to clearly present our approach, we first introduce some
notations while explaining the fuzzing process of Snipuzz. At a high
level, Snipuzz performs as a client which sends a message sequence
𝑀 to request certain actions from IoT devices. Any message 𝑚 ∈ 𝑀
requests the IoT device to perform a certain functionality, and all
𝑚𝑘 = 𝑀 work together to request an action (or
actions). Similarly to the typical fuzzers, we initialize a seed 𝑆 with
an initial message sequence, and a seed corpus 𝐶 with all the
seeds (Section 4.1). Meanwhile, restoring message sequences are
collected for resetting the IoT device to a predefined status.
To establish an effective fuzzing, as depicted in Figure 2, Snipuzz
first conducts a snippet determination process. Concretely, Snipuzz
selects a message 𝑚 in a seed 𝑆 ⊂ 𝐶, from which a probe message
𝑝𝑖 and a corresponding sequence 𝑀𝑖 will be generated. Each mes-
sage in 𝑀𝑖 will trigger a response message 𝑟𝑖 (response for short)
containing the information about the execution output. Snipuzz
assigns each message 𝑚 a response pool 𝑅, which is utilized to de-
termine if a new response 𝑟𝑖 is unique. The uniqueness of a response
indicates that it does not belong to any category of responses ex-
isted in the response pool. If 𝑟𝑖 is unique, Snipuzz will add 𝑟𝑖 into
the pool 𝑅, and reserve the corresponding message sequence 𝑀𝑖
as a new seed. Snipuzz then divides the message 𝑚 into different
snippets based on the responses (Section 4.2). Upon the snippets are
obtained, Snipuzz performs mutation according to various strate-
gies, e.g., empty, bytes flip, data boundary, or havoc (detailed in
Section 4.3). Throughout the fuzzing process, Snipuzz sets up a net-
work monitor to detect crashes which may indicate vulnerabilities
(Section 4.4).
4.1 Message Sequence Acquisition
The quality of initial seeds could influence the fuzzing campaigns
significantly. Therefore, we consider to obtain high-quality initial
seeds conforming to highly-structured formats required by IoT
devices, as such inputs may exercise complex execution paths and
enlarge the opportunity of exposing vulnerabilities at deep code.
Generating seeds based on companion app reverse-engineering [9]
or accessible specifications (as mentioned in Section 3.2) could be
intuitive solutions. However, they either require heavy engineering
Session 2A: Fuzzing and Bug Finding CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea340Figure 2: Workflow of Snipuzz. With the valid message sequences (seeds), Snipuzz performs snippet determination on each individual mes-
sage. Then, Snipuzz mutates snippet(s) to generate new message sequences. By monitoring the network traffic, Snipuzz determines a crash
when no responses are received.
efforts or could be error-prone (e.g., seeds may violate the required
formats or have the wrong order of messages).
Initial seed acquisition. Snipuzz proposes a lightweight solution
to obtain initial valid seeds. Considering that many IoT devices have
first- or third-party API documents as well as the test suites, the
testing programs provided by both parties can effectively act as a
client, sending control commands to IoT devices or remote servers.
Most structural information (e.g., header, message content) and
protocols (e.g., HTTP, HNAP, MQTT) of communication packets
are defined in the API programs as message payloads. Therefore,
Snipuzz leverages these test suites to communicate with the target
devices, while at the same time, extracting the message sequences
as initial seeds. For example, when using an API program to turn
on a light bulb, the program first sends login information to the
server or to the IoT device, then sends a message to locate a specific
light bulb device, and finally sends a message to control the device
to turn on the light. Snipuzz captures such a message sequence
that triggers a functionality of IoT device as an initial seed.
Restoring message sequence acquisition. In order to replay a
test case for the crash triage, Snipuzz ensures that the device under
test has the same initial state in each round of testing. After sending
any message sequence to the device, Snipuzz will send a restoring
message sequence to reset the device to a predefined status.
Manual efforts. Although we try our best efforts to provide a
lightweight fuzzer, Snipuzz still requires some manual efforts to
obtain valid and usable initial seeds. First, we manually configure
the programs from the test suites, such as setting up the IP address
and the login information. Note that, we only need to configure
these programs once per device. Second, to capture the message
sequences dynamically, we need to manually define the specific
format and protocol in the network traffic monitor. Finally, we
filter out some message sequences that will mislead the fuzzing
process. For instance, some API programs provide operations that
can automatically update or restart the device. These operations will
halt the device and thus no response will be sent back. This leads to
false-positive crashes because we consider a no-response execution
as a crash. The manual work costs roughly 5 man-hours per device
and is only required during the message sequence acquisition phase
of Snipuzz.
4.2 Snippet Determination
The key idea of Snipuzz is to optimize fuzzing process based on
snippets determined by responses. Put differently, Snipuzz lever-
ages snippet mutation to reduce the search space of inputs, while
the snippets are automatically clustered via categorizing responses
from IoT devices. The major challenge is to correctly understand
the semantics of responses. For instance, due to the presence of
timestamp, two semantically identical responses will be classified
into different categories if utilizing a simple string comparison.
Therefore, Snipuzz utilizes a heuristic algorithm and a hierarchical
clustering approach to determine the snippets in each message.
Initial Determination. The essence of a message snippet is
4.2.1
the consecutive bytes in a message that enables the firmware to
execute a specific code segment. For experienced experts, it is not
difficult to segment message snippets according to the semantic
definition in official documents. However, for algorithms that lack
such knowledge, it is essential to apply some automatic approaches
to identify the meaning of each byte in the message.
Snipuzz first uses a heuristic algorithm to roughly divide each
message into initial snippets. The core idea of the heuristic algo-
rithm is to generate probe messages 𝑝𝑖 by deleting a certain byte
in the message 𝑚 (𝑚 ∈ 𝑠𝑒𝑒𝑑 𝑆). By categorizing the responses 𝑟𝑖 of
each probe message, Snipuzz preliminarily determines the snippets
in the message 𝑚.
For example, as shown in Table 2, to determine snippets in the
message 𝑚 = {"on":true}, Snipuzz generates probe messages by re-
moving the bytes in 𝑚 one by one. When the first byte ‘{’ in 𝑚 is
deleted, the corresponding probe message 𝑝1 is "on":true}. Similarly,
when the second byte is deleted, the corresponding probe message
𝑝2 is {on":true}. Therefore, the message 𝑚 with 11 bytes can gener-
ate 11 different probe messages (𝑝1 to 𝑝11). Snipuzz will send the
11 corresponding message sequences (𝑀1 to 𝑀11) containing the
probe messages to the device and collect responses.
Session 2A: Fuzzing and Bug Finding CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea341Table 2: Examples of probe messages and corresponding response messages.
Messages
Message 𝑚
Probe message 𝑝1
Probe message 𝑝2
Probe message 𝑝3
Probe message 𝑝4
Probe message 𝑝5
Probe message 𝑝11
Content
{"on":true}
"on":true}
{on":true}
{"n":true}
{"o":true}
{"on:true}
{"on":true
Responses
Response 𝑟0
Response 𝑟1
Response 𝑟2
Response 𝑟3
Response 𝑟4
Response 𝑟5
Response 𝑟11
Content
{"success":"/lights/1/state/on":true}
{"error":{"type":2,"address":"/lights/1/state","description":"body contains invalid json"}}
{"error":{"type":2,"address":"/lights/1/state","description":"body contains invalid json"}}
{"error":{"type":6,"address":"/lights/1/state/n","description":"parameter, n, not available"}}
{"error":{"type":6,"address":"/lights/1/state/o","description":"parameter, o, not available"}}
{"error":{"type":2,"address":"/lights/1/state","description":"body contains invalid json"}}
{"error":{"type":2,"address":"/lights/1/state","description":"body contains invalid json"}}
Category
0
1
1
2
3
1
1
Snipuzz then distinguishes the snippets in the message 𝑚 by cat-
egorizing the responses. Specifically, the consecutive bytes with the
same corresponding response type are merged into the same snip-
pet. According to the examples illustrated in Table 2, the Response
𝑟1, 𝑟2, and 𝑟5 are merged into one category that indicates an error
in JSON syntax, while Response 𝑟3 and 𝑟4 are merged into another
category which indicates an error of an invalid input parameter.
Therefore, the consecutive bytes whose corresponding responses
belong to the same category can form a message snippet. Through
this heuristic approach, Snipuzz can determine all initial snippets
in the message 𝑚.
A naive method to categorize responses is to utilize a string
comparison, i.e., comparing the content of responses byte by byte.
However, due to the existence of randomness in responses (e.g.,
timestamp and token), a simple string comparison may incorrectly
distinguish the responses with same semantic meaning into dif-
ferent categories. Therefore, a more advanced solution, Edit Dis-
tance [42], is introduced to determine the category of responses.
As shown in Equation (1), a similarity score, 𝑠𝑘𝑡 , between two re-
sponses 𝑟𝑘 and 𝑟𝑡 is calculated.
𝑠𝑘𝑡 = 1 − 𝑒𝑑𝑖𝑡_𝑑𝑖𝑠𝑡𝑎𝑛𝑐𝑒(𝑟𝑘, 𝑟𝑡)
𝑚𝑎𝑥_𝑙𝑒𝑛(𝑟𝑘, 𝑟𝑡)
,
(1)
where the 𝑚𝑎𝑥_𝑙𝑒𝑛() in the equation selects the longer string be-
tween the two responses and the 𝑒𝑑𝑖𝑡_𝑑𝑖𝑠𝑡𝑎𝑛𝑐𝑒() counts the mini-
mum number of operations, including insertion, deletion, and sub-
stitution, required to transform one string into the other. Therefore,
the more similar two responses are, the larger the value of 𝑠𝑘𝑡 is.
Snipuzz first calculates a self-similarity score 𝑠𝑖𝑖 for each probe
message 𝑝𝑖. Note that 𝑝𝑖 is generated by mutating the 𝑖-th byte in