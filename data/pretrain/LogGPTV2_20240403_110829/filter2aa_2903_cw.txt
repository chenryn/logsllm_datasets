被调试且运行在GPU上的算核函数来说，该模型并不是进程内调试模
型。图10-10画出了从CPU上调试GPU程序时的多方协作模型。
图10-10左侧是CPU和CPU端的软件，横线上方是用户空间，左边
是调试器进程，内部有针对GPU程序的特别逻辑，这些逻辑向调试器的
顶层模块报告一个GPU程序目标，并提供访问GPU程序的接口。在被调
试进程中，GPU程序的宿主代码在初始化HSA运行时库期间会触发加载
GPU调试主体（Debug Agent）模块，后者会加载GPU调试核心模块
（DBE），其过程如清单10-3所示。
图10-10 GPU调试模型
清单10-3 加载GPU调试核心模块
#0  HwDbgInit (pApiTable=0x7ffff7dd5f20) at 
    /home/jenkins/workspace/HwDebug-Linux-DBE/HWDebugger/Src/HwDbgHSA/HwDb
gHSA.cpp:154
#1  0x00007ffff3cdc037 in OnLoad (pTable=0x7ffff7dd5f20, runtimeVersion=1,
    failedToolCount=0, 
    pFailedToolNames=0x0) at HSADebugAgent.cpp:507
#2  0x00007ffff7b6dc23 in ?? () from /opt/rocm/hsa/lib/libhsa-runtime64.so
.1
#3  0x00007ffff7b6e425 in ?? () from /opt/rocm/hsa/lib/libhsa-runtime64.so
.1
#4  0x00007ffff7b54d2a in ?? () from /opt/rocm/hsa/lib/libhsa-runtime64.so
.1
#5  0x0000000000403635 in AMDT::HSAResourceManager::InitRuntime (verbosePr
int=true,
    gpuIndex=0) 
    at ../Common/HSAResourceManager.cpp:80
#6  0x000000000040df84 in RunTest (doVerify=false) at MatrixMul.cpp:76
#7  0x000000000040deeb in main (argc=1, argv=0x7fffffffdbf8) at MatrixMul.
cpp:65
在清单10-3中，栈帧#5实现在调试主体中的初始化函数，其内部会
调用hsa_init函数，进入HSA的运行模块libhsa-runtime64。
在准备调试时，应该将调试SDK和调试主体模块的路径放在
LD_LIBRARY_PATH环境变量中。在用于启动GDB调试器的rocm-gdb
脚本文件中，定义了另一个环境变量HSA_TOOLS_LIB，它指定了调试
主体的模块名和运行时工具模块的名字。下面是rocm-gdb脚本中的有关
命令。
export HSA_TOOLS_LIB="libhsa-runtime-tools64.so.1 libAMDHSADebugAgent-x64.
so"
被调试程序启动后，HSA运行时会根据上述环境变量加载调试主体
模块，后者调用HwDbgInit API初始化GPU调试核心模块（DBE）。
DBE模块内部会通过IOCTL接口与内核空间中的AMDKFD驱动建
立联系。后者通过MMIO和中断接口与GPU硬件通信。
在GPU的地址空间中，算核函数运行在低特权模式，遇到断点或者
发生异常后，会进入高特权的陷阱处理程序并执行。陷阱处理程序内部
集成了调试支持，会把GPU的异常信息报告给amdkfd驱动，后者再转给
用户空间的DBE模块。
调试器进程和调试主体之间的通信方式可以有多种，调试SDK中实
现了一种基于共享内存的双向通信设施，因为使用了先进先出的队列，
所以在代码中简称为FIFO。以下是两个FIFO文件的名字。
const char gs_AgentToGdbFifoName[]  = "fifo-agent-w-gdb-r";
const char gs_GdbToAgentFifoName[]  = "fifo-gdb-w-agent-r";
第一个FIFO供调试主体写，供调试器（GDB）读；后一个供调试
器写，供调试主体读。
10.12.3 面向事件的调试接口
AMD的GPU调试API与Windows操作系统的调试API有些相似，也
是面向调试事件的设计模式。用于等待调试事件的函数如下。
HwDbgStatus HwDbgWaitForEvent(HwDbgContextHandle hDebugContext,
                 const uint32_t         timeout,
                 HwDbgEventType*    pEventTypeOut);
第一个参数是调用HwDbgBeginDebugContext开始调试时得到的句
柄。第二个参数是最长等待时间（毫秒数）。第三个参数是等待到的事
件结果，其定义为如下枚举常量。
typedef enum
{
HWDBG_EVENT_INVALID  = 0x0, /** wi:命令。
此外，还有rocm-segment-loader.c，它用于维护GPU程序的加载情况和
段信息。
10.13.2 安装和编译
在使用ROCm-GDB前，需要先安装ROCm基础环境。这有两种方
法，一种是从AMD公开的软件仓库服务器下载编译好的二进制文件并
安装，另一种方法是下载源程序自己编译和安装。前一种方法比较简
单，但是如果使用的环境不匹配则可能失败。作者在Ubuntu 18.04环境
下安装时，在编译内核模块时出错，在Ubuntu 16.04环境下安装很顺
利。安装好的文件位于/opt/rocm目录下。
安装好ROCm基础环境后，接下来应该下载和编译GPU调试SDK，
然后再编译ROCm- GDB。GitHub站点上的构建指导写得还算详细，本
书不再详述。
为了能够在算核函数中设置断点，在编译算核函数时，应该使用如
下选项。
BUILD_WITH_LIB BRIGDWARF=1
其中，BRIG代表HSA中间语言的二进制格式，DWARF是Linux平
台上流行的符号格式，目前普遍为各种GPU程序所使用。
10.13.3 常用命令
表10-1列出了ROCm-GDB的新增命令。
表10-1 ROCm-GDB的新增命令
命  令
描  述
rocm thread 切换GPU线程和工作项，完整格式为rocm thread wg: wi:
break rocm
每次分发（dispatch）算核函数时都中断到调试器，也可以指定算核函
数名字（break rocm:），于是，当其开始执行时中断；或
者指定行号（break rocm:）设置算核程序的源代码断点
disassemble 反汇编当前的算核函数
print rocm:
输出算核函数中的变量，完整格式为：print rocm:
set rocm
trace
打开或者关闭（后跟on或者off）GPU分发算核函数时的追踪信息，也可
以指定文件名（set rocm trace ）将信息写入文件
set rocm
logging
打开或者关闭调试主体和DBE内部的日志，完整格式为set rocm logging
[on|off]，日志的输出目标可以是标准输出或者文件
set rocm
show-isa
控制是否把算核函数的指令（ISA）写入临时文件（temp_isa）
info rocm
devices
观察GPU设备信息
info rocm
kernels
输出当前的所有算核函数
info rocm
kernel
输出指定算核的信息
info rocm
wgs
显示当前所有工作组的信息
info rocm
wg
显示指定工作组的信息，完整格式为info rocm [work-group|wg]
[|]
info rocm
wis
显示当前所有工作项的信息
info rocm
wi
显示指定工作项的信息，完整格式为info rocm [work-item|wi] 
show rocm
显示以上通过set命令设置的各种配置选项的当前值
因为ROCm-GDB和调试主体都是开源的，所以结合源代码来学习
ROCm-GDB是一种很好的方法。
10.14 本章小结
本章从AMD显卡的简要历史讲起，前半部分介绍了AMD GPU的微
架构、指令集和编程模型。中间部分从AMD GPU的异常和陷阱机制入
手，介绍了AMD GPU的调试设施，包括波阵控制、地址监视、单步调
试、代码断点等。最后两节介绍了交叉调试模型、GPU调试SDK和
ROCm-GDB调试器。
AMD公司创建于1969年，比英特尔只晚一年。在X86 CPU辉煌的
时代，AMD一直扮演着小弟的角色，虽然偶尔有出色的表现，但是始
终难以扭转大局。随着GPU时代的到来，多年不变的局面开始改变。在
GPU领域，AMD显然走在了英特尔前头。这不但体现在硬件方面，而
且体现在软件和生态系统方面。经过多年的不懈努力，AMD主导的异
构系统架构（HSA）已从最初的构想，逐步成为标准和现实。最近几年
研发的ROCm软件栈也快速发展，有与CUDA争雄之势。
参考资料
[1] 2007 Hot Chips 19 AMD’s Radeon™ HD 2900.
[2] AMD GRAPHIC CORE NEXT Low Power High Performance
Graphics & Parallel Compute.
[3] HSA Programmer's Reference Manual: HSAIL Virtual ISA and
Programming Model, Compiler Writer, and Object Format (BRIG).
[4] AMD GRAPHICS CORES NEXT (GCN) ARCHITECTURE
White Paper.
[5] Developer Guides, Manuals & ISA Documents.
[6] AMD's Revolutionary Mantle Graphics API.
[7] Mantle Programming Guide and API Reference.
[8] HSA Foundation Members.
[9] HSA Foundation Launches New Era of Pervasive, Energy-
Efficient Computing with HSA 1.0 Specification Release.
[10] ROCm: Platform for GPU Enabled HPC and UltraScale
Computing.
[11] ROCm Developer Tools and Programing Languages.
[12] HSAFoundation项目中的AMD GPU调试SDK.
[13] ROCm项目中的AMD GPU调试SDK.
[14] ROCm-GDB项目.
[15] AMD GPU的在线讨论. 
第11章 英特尔GPU及其调试设施
本章首先简要介绍英特尔GPU的发展历史和硬件结构，然后详细讨
论GPU的多种编程接口，既有传统的MMIO寄存器接口、命令流和环形
缓冲区接口，也有新的通过GuC微处理器提交任务的接口，以及适合多
任务的状态模型接口。11.8节～11.10节重点介绍英特尔GPU的指令集、