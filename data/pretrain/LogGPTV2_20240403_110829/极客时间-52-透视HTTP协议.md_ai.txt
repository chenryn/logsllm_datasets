## 真实的网络世界通过上面两个在"最小化"环境里的实验，你是否已经对 HTTP协议的工作流程有了基本的认识呢？第一个实验是最简单的场景，只有两个角色：浏览器和服务器，浏览器可以直接用IP 地址找到服务器，两者直接建立 TCP 连接后发送 HTTP 报文通信。第二个实验在浏览器和服务器之外增加了一个 DNS的角色，浏览器不知道服务器的 IP 地址，所以必须要借助 DNS的域名解析功能得到服务器的 IP 地址，然后才能与服务器通信。真实的互联网世界要比这两个场景要复杂的多，我利用下面的这张图来做一个详细的说明。![](Images/18575ea3714437ecfc8b9fac5849a22d.png){savepage-src="https://static001.geekbang.org/resource/image/df/6d/df4696154fc8837e33117d8d6ab1776d.png"}如果你用的是电脑台式机，那么你可能会使用带水晶头的双绞线连上网口，由交换机接入固定网络。如果你用的是手机、平板电脑，那么你可能会通过蜂窝网络、WiFi，由电信基站、无线热点接入移动网络。接入网络的同时，网络运行商会给你的设备分配一个 IP地址，这个地址可能是静态分配的，也可能是动态分配的。静态 IP就始终不变，而动态 IP 可能你下次上网就变了。假设你要访问的是 Apple 网站，显然你是不知道它的真实 IP地址的，在浏览器里只能使用域名"www.apple.com"访问，那么接下来要做的必然是域名解析。这就要用DNS 协议开始从操作系统、本地 DNS、根 DNS、顶级 DNS、权威 DNS的层层解析，当然这中间有缓存，可能不会费太多时间就能拿到结果。别忘了互联网上还有另外一个重要的角色 CDN，它也会在 DNS的解析过程中"插上一脚"。DNS 解析可能会给出 CDN 服务器的 IP地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。由 PHP、Java 等后台服务动态生成的页面属于"动态资源"，CDN无法缓存，只能从目标网站获取。于是你发出的 HTTP请求就要开始在互联网上的"漫长跋涉"，经过无数的路由器、网关、代理，最后到达目的地。目标网站的服务器对外表现的是一个 IP地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如四层的LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和disk 级缓存 Varnish，它们的作用与 CDN类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如Java 的 Tomcat/Netty/Jetty，Python 的 Django，还有 PHP、Node.js、Golang等等。它们又会再访问后面的 MySQL、PostgreSQL、MongoDB等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。最后网站的响应数据回到了你的设备，它可能是HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。
## 小结今天我们在本机的环境里做了两个简单的实验，学习了 HTTP 协议请求 -应答的全过程，在这里做一个小结。1.  [HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP    地址建立连接；]{.orange}2.  [如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP    地址，否则就会连接失败；]{.orange}3.  [建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP    规范构建和解析报文；]{.orange}4.  [    为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现"短路"操作；]{.orange}5.  [虽然现实中的 HTTP    传输过程非常复杂，但理论上仍然可以简化成实验里的"两点"模型。]{.orange}
## 课下作业1.  你能试着解释一下在浏览器里点击页面链接后发生了哪些事情吗？2.  这一节课里讲的都是正常的请求处理流程，如果是一个不存在的域名，那么浏览器的工作流程会是怎么样的呢？欢迎你把自己的答案写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。![unpreview](Images/a842599c8f72db080e095e3ce3eed40a.png){savepage-src="https://static001.geekbang.org/resource/image/8e/56/8ef903c86d3ef548a9536bd4345f0156.png"}![unpreview](Images/4913a489805db29b38aefa585223c013.png){savepage-src="https://static001.geekbang.org/resource/image/56/63/56d766fc04654a31536f554b8bde7b63.jpg"}
# 09 \| HTTP报文是什么样子的？在上一讲里，我们在本机的最小化环境了做了两个 HTTP 协议的实验，使用Wireshark 抓包，弄清楚了 HTTP 协议基本工作流程，也就是"请求 -应答""一发一收"的模式。可以看到，HTTP 的工作模式是非常简单的，由于 TCP/IP协议负责底层的具体传输工作，HTTP协议基本上不用在这方面操心太多。单从这一点上来看，所谓的"超文本传输协议"其实并不怎么管"传输"的事情，有点"名不副实"。那么 HTTP 协议的核心部分是什么呢？答案就是它传输的报文内容。HTTP协议在规范文档里详细定义了报文的格式，规定了组成部分，解析规则，还有处理策略，所以可以在TCP/IP层之上实现更灵活丰富的功能，例如连接控制，缓存管理、数据编码、内容协商等等。
## 报文结构你也许对 TCP/UDP 的报文格式有所了解，拿 TCP报文来举例，它在实际要传输的数据之前附加了一个 20 字节的头部数据，存储TCP协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等等。有了这个附加的 TCP头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据。![](Images/f7294bf76621cd5fb79a53b62ca71a84.png){savepage-src="https://static001.geekbang.org/resource/image/17/95/174bb72bad50127ac84427a72327f095.png"}HTTP 协议也是与 TCP/UDP类似，同样也需要在实际传输的数据前附加一些头数据，不过与 TCP/UDP不同的是，它是一个"**纯文本**"的协议，所以头数据都是 ASCII码的文本，可以很容易地用肉眼阅读，不用借助程序解析也能够看懂。``{=html}HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：1.  起始行（start line）：描述请求或响应的基本信息；2.  头部字段集合（header）：使用 key-value 形式更详细地说明报文；3.  消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。这其中前两部分起始行和头部字段经常又合称为"**请求头**"或"**响应头**"，消息正文又称为"**实体**"，但与"**header**"对应，很多时候就直接称为"**body**"。HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header之后必须要有一个"空行"，也就是"CRLF"，十六进制的"0D0A"。所以，一个完整的 HTTP 报文就像是下图的这个样子，注意在 header 和 body之间有一个"空行"。![](Images/e9f04b899ad6e1b99e6b6a946a8dff69.png){savepage-src="https://static001.geekbang.org/resource/image/62/3c/62e061618977565c22c2cf09930e1d3c.png"}说到这里，我不由得想起了一部老动画片《大头儿子和小头爸爸》，你看，HTTP的报文结构像不像里面的"大头儿子"？报文里的 header 就是"大头儿子"的"大头"，空行就是他的"脖子"，而后面的body 部分就是他的身体了。看一下我们之前用 Wireshark 抓的包吧。![unpreview](Images/bc48e24058bf823748b2ad87c668e481.png){savepage-src="https://static001.geekbang.org/resource/image/b1/df/b191c8760c8ad33acd9bb005b251a2df.png"}在这个浏览器发出的请求报文里，第一行"GET /HTTP/1.1"就是请求行，而后面的"Host""Connection"等等都属于header，报文的最后是一个空白行结束，没有 body。在很多时候，特别是浏览器发送 GET 请求的时候都是这样，HTTP 报文经常是只有header 而没body，相当于只发了一个超级"大头"过来，你可以想象的出来：每时每刻网络上都会有数不清的"大头儿子"在跑来跑去。不过这个"大头"也不能太大，虽然 HTTP 协议对 header的大小没有做限制，但各个 Web服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。
## 请求行了解了 HTTP报文的基本结构后，我们来看看请求报文里的起始行也就是**请求行**（requestline），它简要地描述了**客户端想要如何操作服务器端的资源**。请求行由三部分构成：1.  请求方法：是一个动词，如 GET/POST，表示对资源的操作；2.  请求目标：通常是一个 URI，标记了请求方法要操作的资源；3.  版本号：表示报文使用的 HTTP 协议版本。这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。![](Images/c6a718d0de84c82dc2683869a574fb1c.png){savepage-src="https://static001.geekbang.org/resource/image/36/b9/36108959084392065f36dff3e12967b9.png"}还是用 Wireshark 抓包的数据来举例：    GET / HTTP/1.1在这个请求行里，"GET"是请求方法，"/"是请求目标，"HTTP/1.1"是版本号，把这三部分连起来，意思就是"服务器你好，我想获取网站根目录下的默认文件，我用的协议版本号是1.1，请不要用 1.0 或者 2.0 回复我。"别看请求行就一行，貌似很简单，其实这里面的"讲究"是非常多的，尤其是前面的请求方法和请求目标，组合起来变化多端，后面我还会详细介绍。
## 状态行看完了请求行，我们再看响应报文里的起始行，在这里它不叫"响应行"，而是叫"**状态行**"（statusline），意思是**服务器响应的状态**。比起请求行来说，状态行要简单一些，同样也是由三部分构成：1.  版本号：表示报文使用的 HTTP 协议版本；2.  状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500    是服务器错误；3.  原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。![](Images/ed4757c1ae592c1743f99a3c3b7c7ff4.png){savepage-src="https://static001.geekbang.org/resource/image/a1/00/a1477b903cd4d5a69686683c0dbc3300.png"}看一下上一讲里 Wireshark 抓包里的响应报文，状态行是：    HTTP/1.1 200 OK意思就是："浏览器你好，我已经处理完了你的请求，这个报文使用的协议版本号是1.1，状态码是 200，一切 OK。"而另一个"GET /favicon.ico HTTP/1.1"的响应报文状态行是：    HTTP/1.1 404 Not Found翻译成人话就是："抱歉啊浏览器，刚才你的请求收到了，但我没找到你要的资源，错误代码是404，接下来的事情你就看着办吧。"
## 头部字段请求行或状态行再加上头部字段集合就构成了 HTTP报文里完整的请求头或响应头，我画了两个示意图，你可以看一下。![](Images/5bdc323f552ce41b3e91e44f1e7c9329.png){savepage-src="https://static001.geekbang.org/resource/image/1f/ea/1fe4c1121c50abcf571cebd677a8bdea.png"}![](Images/1c4bc99a04eba9d7df055166abe6918e.png){savepage-src="https://static001.geekbang.org/resource/image/cb/75/cb0d1d2c56400fe9c9988ee32842b175.png"}请求头和响应头的结构是基本一样的，唯一的区别是起始行，所以我把请求头和响应头里的字段放在一起介绍。头部字段是 key-value 的形式，key 和 value 之间用":"分隔，最后用 CRLF换行表示字段结束。比如在"Host: 127.0.0.1"这一行里 key 就是"Host"，value就是"127.0.0.1"。HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。不过使用头字段需要注意下面几点：1.  字段名不区分大小写，例如"Host"也可以写成"host"，但首字母大写的可读性更好；2.  字段名里不允许出现空格，可以使用连字符"-"，但不能使用下划线"\_"。例如，"test-name"是合法的字段名，而"test    name""test_name"是不正确的字段名；3.  字段名后面必须紧接着":"，不能有空格，而":"后的字段值前可以有多个空格；4.  字段的顺序是没有意义的，可以任意排列不影响语义；5.  字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。我在实验环境里用 Lua 编写了一个小服务程序，URI是"/09-1"，效果是输出所有的请求头。你可以在实验环境里用 Telnet 连接 OpenResty 服务器试一下，手动发送 HTTP请求头，试验各种正确和错误的情况。先启动 OpenResty 服务器，然后用组合键"Win+R"运行 telnet，输入命令"openwww.chrono.com 80"，就连上了 Web 服务器。![](Images/aa8769d814fb2daaea6b22fb4ceb2147.png){savepage-src="https://static001.geekbang.org/resource/image/34/7b/34fb2b5899bdb87a3899dd133c0c457b.png"}连接上之后按组合键"CTRL+\]"，然后按回车键，就进入了编辑模式。在这个界面里，你可以直接用鼠标右键粘贴文本，敲两下回车后就会发送数据，也就是模拟了一次HTTP 请求。下面是两个最简单的 HTTP请求，第一个在":"后有多个空格，第二个在":"前有空格。    GET /09-1 HTTP/1.1Host:   www.chrono.com  GET /09-1 HTTP/1.1Host : www.chrono.com第一个可以正确获取服务器的响应报文，而第二个得到的会是一个"400 BadRequest"，表示请求报文格式有误，服务器无法正确处理：    HTTP/1.1 400 Bad RequestServer: openresty/1.15.8.1Connection: close