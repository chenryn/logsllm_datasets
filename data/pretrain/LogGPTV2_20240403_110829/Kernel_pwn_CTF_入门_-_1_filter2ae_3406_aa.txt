# Kernel pwn CTF 入门 - 1
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、简介
内核 CTF 入门，主要参考 [CTF-Wiki](https://wiki.x10sec.org/pwn/linux/kernel-mode/environment/readme/)。
## 二、环境配置
  * 调试内核需要一个优秀的 gdb 插件，这里选用 gef。  
> 根据其他师傅描述，peda 和 pwndbg 在调试内核时会有很多玄学问题。
        pip3 install capstone unicorn keystone-engine ropper
    git clone https://github.com/hugsy/gef.git
    echo source `pwd`/gef/gef.py >> ~/.gdbinit
  * 去[清华源](https://mirrors.tuna.tsinghua.edu.cn/kernel/)下载 Linux kernel 压缩包并解压： 
        curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.9.8.tar.xz
    unxz linux-5.9.8.tar.xz
    tar -xf linux-5.9.8.tar
  * 进入项目文件夹，进行 makefile 配置 
        cd linux-5.9.8
    make menuconfig
在其中勾选
    * `Kernel hacking -> Compile-time checks and compiler options -> Compile the kernel with debug info`
    * `Kernel hacking -> Generic Kernel Debugging Instruments -> KGDB: kernel debugger`
之后保存配置并退出
  * 开始编译内核（默认 32 位） 
        make -j 8 bzImage
> 不推荐直接 `make -j 8`，因为它会编译很多很多大概率用不上的东西。
这里有些小坑：
    * 缺失依赖项。解决方法：根据 make 的报错信息来安装依赖项。 
                sudo apt-get install libelf-dev
    * `make[1]: *** No rule to make target 'debian/certs/debian-uefi-certs.pem', needed by 'certs/x509_certificate_list'. Stop.`解决方法：将 `.config` 中的 `CONFIG_SYSTEM_TRUSTED_KEYS` 内容置空，然后重新 make。 
                #
        # Certificates for signature checking
        #
        CONFIG_SYSTEM_TRUSTED_KEYS="" # 置空, 不要删除当前条目
等出现了以下信息后则编译完成：
        Setup is 15420 bytes (padded to 15872 bytes).
    System is 5520 kB
    CRC 70701790
    Kernel: arch/x86/boot/bzImage is ready  (#2)
  * 最后在启动内核前，先构建一个文件系统，否则内核会因为没有文件系统而报错： 
        Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
首先下载一下 busybox 源代码：
        wget https://busybox.net/downloads/busybox-1.34.1.tar.bz2
    tar -jxf busybox-1.34.1.tar.bz2
之后配置 makefile：
        cd busybox-1.34.1
    make menuconfig
    make -j 8
在 menuconfig 页面中，
    * Setttings 选中 Build static binary (no shared libs), 使其编译成静态链接的文件（因为 kernel 不提供 libc)需要注意的是，静态编译与链接需要额外安装一个依赖项 `glibc-static`。使用以下命令安装： 
                # redhat/centos系列安装:
        sudo yum install glibc-static
        # debian/ubuntu系列安装
        sudo apt-get install libc6-dev
    * 在 Linux System Utilities 中取消选中 Support mounting NFS file systems on Linux  当前版本默认没有选中该项，因此可以跳过。
编译完成后，使用 `make install`命令，将生成文件夹`_install`，该目录将成为我们的 rootfs。
接下来在 `_install` 文件夹下执行以创建一系列文件：
        mkdir -p  proc sys dev etc/init.d
之后，在 rootfs 下（即 `_install` 文件夹下）编写以下 init 挂载脚本：
        #!/bin/sh
    echo "INIT SCRIPT"
    mkdir /tmp
    mount -t proc none /proc
    mount -t sysfs none /sys
    mount -t devtmpfs none /dev
    mount -t debugfs none /sys/kernel/debug
    mount -t tmpfs none /tmp
    echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
    setsid /bin/cttyhack setuidgid 1000 /bin/sh
最后设置 init 脚本的权限，并将 rootfs 打包：
        chmod +x ./init
    # 打包命令
    find . | cpio -o --format=newc > ../../rootfs.img
    # 解包命令
    # cpio -idmv  busybox的编译与安装在构建 rootfs 中不是必须的，但还是强烈建议构建 busybox，因为它提供了非常多的有用工具来辅助使用 kernel。
  * 使用 qemu 启动内核。以下是 CTF wiki 推荐的启动参数： 
        #!/bin/sh
    qemu-system-x86_64 \
        -m 64M \
        -nographic \
        -kernel ./arch/x86/boot/bzImage \
        -initrd  ./rootfs.img \
        -append "root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr" \
        -smp cores=2,threads=1 \
        -cpu kvm64
本着减少参数设置的目的，这是笔者的启动参数：
        qemu-system-x86_64 \
      -kernel ./arch/x86/boot/bzImage \
      -initrd ./rootfs.img \
      -append "nokaslr"
> 减少启动的参数个数，可以让我们在入门时，暂时屏蔽掉一些不必要的细节。
>
> 这里只设置了三个参数，其中：
>
>     * `-kernel` 指定内核镜像文件 bzImage 路径
>     * `-initrd` 设置内核启动的内存文件系统
>     * `-append "nokaslr"` 关闭 Kernel ALSR 以便于调试内核注意：`nokaslr` 可
> **千万千万千万别打成`nokalsr`** 了。就因为这个我调试了一个下午的 kernel……是的 CTF Wiki 上的 nokaslr
> 也是错的，它打成了 nokalsr （xs）
启动好后就可以使用内置的 shell 了。
## 三、内核驱动的编写与调试
###  1\. 构建过程
这里我们在 linux kernel 项目包下新建了一个文件夹：
    linux-5.9.8 $ mkdir mydrivers
之后在该文件夹下放入一个驱动代码`ko_test.c`，代码照搬的 CTF-wiki：
    #include 
    #include 
    #include 
    MODULE_LICENSE("Dual BSD/GPL");
    static int ko_test_init(void) 
    {
        printk("This is a test ko!\n");
        return 0;
    }
    static void ko_test_exit(void) 
    {
        printk("Bye Bye~\n");
    }
    module_init(ko_test_init);
    module_exit(ko_test_exit);
代码编写完成后，放入一个 `Makefile`文件：
    # 指定声称哪些 内核模块
    obj-m += ko_test.o
    # 指定内核项目路径
    KDIR =/usr/class/kernel_pwn/linux-5.9.8
    all:
            # -C 参数指定进入内核项目路径
            # -M 指定驱动源码的环境，使 Makefile 在构建模块之前返回到 驱动源码 目录，并在该目录中生成驱动模块
            $(MAKE) -C $(KDIR) M=$(PWD) modules
    clean:
            rm -rf *.o *.ko *.mod.* *.symvers *.order
> 注意点：
>
>   1. Makefile 文件名中的首字母 `M` 一定是大写，否则会报以下错误：
>  
>     >     scripts/Makefile.build:44:
> /usr/class/kernel_pwn/linux-5.9.8/mydrivers/Makefile: No such file or
> directory
>     make[2]: *** No rule to make target
> '/usr/class/kernel_pwn/linux-5.9.8/mydrivers/Makefile'.  Stop.
>  
>
>   2. Makefile 中 `obj-m` 要与刚刚的驱动代码文件名所对应，否则会报以下错误：
>  
>     >     make[2]: *** No rule to make target
> '/usr/class/kernel_pwn/linux-5.9.8/mydrivers/ko_test.o', needed by
> '/usr/class/kernel_pwn/linux-5.9.8/mydrivers/ko_test.mod'.  Stop.
>  
>
>   3. 如果make时遇到以下错误：
>  
>     >     makefile:6: *** missing separator.  Stop.
>  
>
> 则使用 vim 打开 Makefile，键入 `i` 以进入输入模式，然后替换掉 make 命令前的前导空格为 tab，最后键入 `:wq` 保存修改。
>
>
最后使用 `make` 即可编译驱动。完成后的目录内容如下所示：
> 这里我们只关注 `ko_test.ko`。
    $ tree                  
    .
    ├── ko_test.c
    ├── ko_test.ko
    ├── ko_test.mod
    ├── ko_test.mod.c
    ├── ko_test.mod.o
    ├── ko_test.o
    ├── Makefile
    ├── modules.order
    └── Module.symvers
    0 directories, 9 files
###  2\. 运行过程
将新编译出来的 `*.ko` 文件复制进 rootfs 文件夹（`busybox-1.34.1/_install`）下，
之后修改 `busybox-1.34.1/_install/init` 脚本中的内容：
> 这里需要提权 /bin/sh， 目的是为了使用 root 权限启动 /bin/sh，使得拥有执行 `dmesg` 命令的权限。
    #!/bin/sh
    echo "INIT SCRIPT"
    mkdir /tmp
    mount -t proc none /proc
    mount -t sysfs none /sys
    mount -t devtmpfs none /dev
    mount -t debugfs none /sys/kernel/debug
    mount -t tmpfs none /tmp
    + insmod /ko_test.ko # 挂载内核模块
    echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"
    - setsid /bin/cttyhack setuidgid 1000 /bin/sh
    + setsid /bin/cttyhack setuidgid 0 /bin/sh # 修改 uid gid 为 0 以提权 /bin/sh 至 root。
    + poweroff -f # 设置 shell 退出后则关闭机器
重新打包 rootfs 并运行 qemu，之后键入 `dmesg` 命令即可看到 ko_test 模块已被成功加载：
> 正常情况下，执行 qemu 会弹出一个小框 GUI。若想像上图一样将启动的界面变成当前终端，则需在 qemu 启动时额外指定参数：
>
>   * `-nographic`
>   * `-append "console=ttyS0"`