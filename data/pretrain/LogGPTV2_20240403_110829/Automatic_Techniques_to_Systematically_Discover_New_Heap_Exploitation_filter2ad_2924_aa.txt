title:Automatic Techniques to Systematically Discover New Heap Exploitation
Primitives
author:Insu Yun and
Dhaval Kapil and
Taesoo Kim
Automatic Techniques to Systematically Discover 
New Heap Exploitation Primitives
Insu Yun, Georgia Institute of Technology; Dhaval Kapil, Facebook; 
Taesoo Kim, Georgia Institute of Technology
https://www.usenix.org/conference/usenixsecurity20/presentation/yun
This paper is included in the Proceedings of the 29th USENIX Security Symposium.August 12–14, 2020978-1-939133-17-5Open access to the Proceedings of the 29th USENIX Security Symposium is sponsored by USENIX.Automatic Techniques to Systematically Discover
New Heap Exploitation Primitives
Insu Yun† Dhaval Kapil‡ Taesoo Kim†
† Georgia Institute of Technology ‡ Facebook
Abstract
Exploitation techniques to abuse metadata of heap allocators
have been widely studied because of their generality (i.e.,
application independence) and powerfulness (i.e., bypassing
modern mitigation). However, such techniques are commonly
considered arts, and thus the ways to discover them remain
ad-hoc, manual, and allocator-specific.
In this paper, we present an automatic tool, ARCHEAP,
to systematically discover the unexplored heap exploita-
tion primitives, regardless of their underlying implementa-
tions. The key idea of ARCHEAP is to let the computer au-
tonomously explore the spaces, similar in concept to fuzzing,
by specifying a set of common designs of modern heap allo-
cators and root causes of vulnerabilities as models, and by
providing heap operations and attack capabilities as actions.
During the exploration, ARCHEAP checks whether the com-
binations of these actions can be potentially used to construct
exploitation primitives, such as arbitrary write or overlapped
chunks. As a proof, ARCHEAP generates working PoC that
demonstrates the discovered exploitation technique.
We evaluated ARCHEAP with ptmalloc2 and 10 other allo-
cators, and discovered five previously unknown exploitation
techniques in ptmalloc2 as well as several techniques against
seven out of 10 allocators including the security-focused allo-
cator, DieHarder. To show the effectiveness of ARCHEAP’s
approach in other domains, we also studied how security fea-
tures and exploit primitives evolve across different versions
of ptmalloc2.
1 Introduction
Heap-related vulnerabilities have been the most common,
yet critical source of security problems in systems soft-
ware [42, 64, 65, 71]. According to Microsoft, heap vul-
nerabilities accounted for 53% of security problems in their
products in 2017 [48]. One way to exploit these vulnerabili-
ties is to use heap exploitation techniques [61], which abuse
underlying allocators. There are two properties that make
these techniques preferable for attacks. First, heap exploita-
tion techniques tend to be application-independent, making
it possible to write exploit without a deep understanding of
Target programs
Scriptable
Non-scriptable
(via heap exploit techs)
Before ASLR
After ASLR
02-04
0
9
12
05-07
12
7
12
Total
12
16
24
08-10
13
5
3
11-13
29
1
4
14-16
11
3
1
17-19
4
2
2
Total
57
11
10
Scriptable: Software accepting a script language
(e.g., web browsers or PDF readers).
Table 1: The number of exploitations that lead to code execu-
tion from heap vulnerabilities in exploit-db [50]. A heap exploit
technique is one of the popular methods used to compromise non-
scriptable programs—bugs in scriptable programs typically allow
much easier, simpler way for exploitation, requiring no use of the
heap exploitation technique.
application internals. Second, heap vulnerabilities are typi-
cally so powerful that attackers can bypass modern mitigation
schemes by abusing them. For example, a seemingly be-
nign bug that overwrites one NULL byte to the metadata of
ptmalloc2 leads to a privilege escalation on Chrome OS [2].
Heap exploitation techniques have steadily been used in
real-world exploits. To show that, we collected successful
exploits for heap vulnerabilities leading to arbitrary code exe-
cution from the well-known exploit database, exploit-db [50].
As shown in Table 1, heap exploitation techniques were one
of the favorable ways to compromise software when ASLR
was not implemented (24 / 52 exploits). Even after ASLR
is deployed, heap bugs in non-scriptable programs are fre-
quently exploited via heap exploitation techniques (10 / 21
exploits). Not to mention, popular software such as the Exim
mail server [47], WhatsApp [6] and VMware ESXi [77] are
all hijacked via the heap exploitation technique in 2019. Note
that scriptable programs provide much simpler, flexible ex-
ploitation techniques, so using heap exploitation techniques is
not yet preferred by an attacker: e.g., corrupting an array-like
structure to achieve arbitrary reads and writes.
Communities have been studying possible attack tech-
niques against heap vulnerabilities (see, Table 2), but finding
such techniques is often considered an art, and thus the ap-
proaches used to discover them remain ad-hoc, manual and
allocator-specific at best. Unfortunately, such a trend makes it
hard for communities to understand the security implications
of various heap allocators (or even across different versions).
USENIX Association
29th USENIX Security Symposium    1111
2001 • (1) Once upon a free()... [1]
2003 • (1) Advanced Doug lea’s malloc exploits [38]
2004 • (2) Exploiting the wilderness [55]
2007 • (2) The use of set_head to defeat the wilderness [25]
2007 • (3) Understanding the heap by breaking it [20]
2009 • (1) Yet another free() exploitation technique [36]
2009 • (6) Malloc Des-Maleficarum [7]
2010 • (2) The house of lore: Reloaded [8]
2014 • (1) The poisoned NUL byte, 2014 edition [18]
2015 • (2) Glibc adventures: The forgotten chunk [28]
2016 • (3) Ptmalloc fanzine [37]
2016 • (3) New exploit methods against Ptmalloc of Glibc [72]
2016 • (1) House of Einherjar [66]
2018 • (5) ARCHEAP
Table 2: Timeline for new heap exploitation techniques discov-
ered and their count in parentheses (e.g., ARCHEAP found five new
techniques in 2018).
For example, when tcache was recently introduced in ptmal-
loc2 to improve the performance with a per-thread cache, its
security was improperly evaluated (i.e., insufficient integrity
checks for allocation or free [17, 37]), enabling an easier
way for exploitation. Moreover, existing studies for heap
exploitation techniques are highly biased; only ptmalloc2 is
exhaustively considered (e.g., missing DieHarder [49]).
In this paper, we present an automatic tool, ARCHEAP,
to systematically discover the unexplored heap exploita-
tion primitives, regardless of their underlying implementa-
tions. The key idea of ARCHEAP is to let the computer au-
tonomously explore the spaces, similar in concept to fuzzing,
which is proven to be practical and effective in discovering
software bugs [29, 75].
However, it is non-trivial to apply classical fuzzing tech-
niques to discover new heap exploitation primitives for three
reasons. First, to successfully trigger a heap vulnerability,
it must generate a particular sequence of steps with exact
data, quickly rendering the problem intractable using fuzzing
approaches. Accordingly, researchers attempt to tackle this
problem using symbolic execution instead, but stumbled over
the well-known state explosion problem, thereby limiting its
scope to validating known exploitation techniques [17]. Sec-
ond, we need to devise a fast way to estimate the possibility
of heap exploitation, as fuzzing requires clear signals, such as
segmentation faults, to recognize interesting test cases. Third,
the test cases generated by fuzzers are typically redundant
and obscure, so users are required to spend non-negligible
time and effort analyzing the final results.
The key intuition to overcome these challenges (i.e., reduc-
ing search space) is to abstract the internals of heap allocators
and the root causes of heap vulnerabilities (see §3.1). In
particular, we observed that modern heap allocators share
three common design components, namely, binning, in-place
metadata, and cardinal data. On top of these models, we
directed ARCHEAP to mutate and synthesize heap operations
and attack capabilities. During the exploration, ARCHEAP
checks whether the generated test case can be potentially
used to construct exploitation primitives, such as arbitrary
Allocators
ptmalloc2
dlmalloc
jemalloc
tcmalloc
PartitionAlloc
libumem
B
✓
✓
✓
✓
✓
✓
I
✓
✓
✓
C
✓
✓
✓
✓
✓
✓
Description (applications)
A default allocator in Linux.
An allocator that ptmalloc2 is based on.
A default allocator in FreeBSD.
A high-performance allocator from Google.
A default allocator in Chromium.
A default allocator in Solaris.
B: Binning, I: In-place metadata, C: Cardinal data
Table 3: Common designs used in various memory allocators. This
table shows that even though their detailed implementations could
be different, heap allocators share common designs that can be
exploited for automatic testing.
writes or overlapped chunks—we devised shadow-memory-
based detection for efficient evaluation (see, §5.3). Whenever
ARCHEAP finds a new exploit primitive, it generates a work-
ing PoC code using delta-debugging [76] to reduce redundant
test cases to a minimal, equivalent class.
We evaluated ARCHEAP with ptmalloc2 and 10 other al-
locators. As a result, we discovered five new exploit tech-
niques against Linux’s default heap allocator, ptmalloc2.
ARCHEAP’s approach can be extended beyond ptmalloc2;
ARCHEAP found several exploit primitives against other pop-
ular heap allocators, such as tcmalloc and jemalloc. Moreover,
by disclosing unexpected exploit primitives, ARCHEAP iden-
tified three implementation bugs in DieHarder, Mesh [56],
and mimalloc, respectively.
The closest related work to ARCHEAP is HeapHopper [17],
which verifies existing heap exploit techniques using symbolic
execution. Compared with HeapHopper, ARCHEAP outper-
forms it in finding new techniques; none of the new techniques
from ARCHEAP are found by HeapHopper. Moreover, unlike
HeapHopper, ARCHEAP is independent on exploit-specific
information, which is unavailable in finding new techniques;
HeapHopper found only three out of eight known techniques
in ptmalloc2 without the prior knowledge, while ARCHEAP
found all eight. This shows that HeapHopper is ineffective for
this new task (i.e., finding new exploit techniques), justifying
the need for this new tool.
To show the effectiveness of the ARCHEAP’s approach in
other domains, we also studied how exploit primitives evolve
across different versions of ptmalloc2, demonstrating the need
for an automated method to evaluate the security of heap allo-
cators. To foster further research, we open-source ARCHEAP
at https://github.com/sslab-gatech/ArcHeap.
In summary, we make the following contributions:
• We show that heap allocators share common designs, and
we devise an efficient method to evaluate exploitation
techniques using shadow memory.
• We design, implement, and evaluate our prototype,
ARCHEAP, a tool that automatically discovers heap ex-
ploitation techniques. against various allocators.
• ARCHEAP found five new techniques in ptmalloc2 and
several techniques in various allocators, including tc-
malloc, jemalloc, and DieHarder, and it outperforms
a state-of-the-art tool, HeapHopper, in finding new ex-
ploitation techniques.
1112    29th USENIX Security Symposium
USENIX Association
2 Analysis of Heap Allocators
2.1 Modern Heap Allocators
Dynamic memory allocation [41] plays an essential role in
managing a program’s heap space. The C standard library
defines a set of APIs to manage dynamic memory allocations
such as malloc() and free() [24]. For example, malloc()
allocates the given number of bytes and returns a pointer
to the allocated memory, and free() reclaims the memory
specified by the given pointer.
A variety of heap allocators [19, 26, 41, 43, 45, 49, 56,
59, 64, 65] have been developed to meet the specific needs
of target programs. Heap allocators have two types of com-
mon goals: good performance and small memory footprint—
minimizing the memory usage as well as reducing fragmenta-
tion, which is the unused memory (i.e., hole) among in-use
memory blocks. Unfortunately, these two desirable properties
are fundamentally conflicting; an allocator should minimize
additional operations to achieve good performance, whereas
it requires additional operations to minimize fragmentation.
Therefore, the goal of an allocator is typically to find a good
balance between these two goals for its workloads.
Common designs.
In analyzing various heap allocators,
we found their common design principles shown in Table 3:
binning, in-place metadata, and cardinal data. Many allo-
cators use size-based classification, known as binning. In
particular, they partition a whole size range into multiple
groups to manage memory blocks deliberately according to
their size groups; small-size blocks focus on performance,
and large-size blocks focus on memory usage of the alloca-
tors. Moreover, by dividing size groups, when they try to find
the best-fit block, the smallest but sufficient block for given
request, they scan only blocks in the proper size group instead
of scanning all memory blocks.
Moreover, many dynamic memory allocators place meta-
data near the payload, called in-place metadata, even though
some allocators avoid this because of security problems from
corrupted metadata in the presence of memory corruption
bugs (see Table 3). To minimize memory fragmentation, a
memory allocator should maintain information about allo-
cated or freed memory in metadata. Even though the allocator
can place metadata and payload in distinct locations, many
allocators store the metadata near the payload (i.e., a head or
a tail of a chunk) to increase locality. In particular, by con-
necting metadata and payload, an allocator can get benefits
from the cache, resulting in performance improvement.
Further, memory allocators contain only cardinal data that
are not encoded and essential for fast lookup and memory
usage. In particular, metadata are mostly pointers or size-
related values that are used for their data structures. For
example, ptmalloc2 stores a raw pointer for a linked list that
is used to maintain freed memory blocks.
This observation has been leveraged to devise the universal
method to test various allocators regardless of their imple-
mentations (see §5.2). First, our approach should consider
A: alloced in a non-main arena
M: mmapped
P: "previous" in use (i.e., P=0 means freed)
1 struct malloc_chunk {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19 };
// size of "previous" chunk
// (only valid when the previous chunk is freed, P=0)
size_t prev_size;
// size in bytes (aligned by double words): lower bits
// indicate various states of the current/previous chunk
//
//
//
size_t size;
// double links for free chunks in small/large bins
// (only valid when this chunk is freed)
struct malloc_chunk* fd;
struct malloc_chunk* bk;
// double links for next larger/smaller size in largebins
// (only valid when this chunk is freed)
struct malloc_chunk* fd_nextsize;
struct malloc_chunk* bk_nextsize;
Figure 1: Metadata for a chunk in ptmalloc2 and memory layout