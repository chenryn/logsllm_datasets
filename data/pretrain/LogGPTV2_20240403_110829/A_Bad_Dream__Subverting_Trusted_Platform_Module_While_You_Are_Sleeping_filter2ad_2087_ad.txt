detailed process of the exploit for the DRTM vulnerabil-
ity using mutable function pointers.
According to Intel’s speciﬁcation [14], SINIT ACM
obtains a loaded address, a size, and the entry point of
an MLE by reading the MLE header. The header should
be placed inside the loaded MLE and measured by the
SINIT ACM so that unauthorized modiﬁcation of the
header is not allowed. In the latest version of the tboot
source code (1.9.6, at the time of this writing), the start
and the end of an MLE ( mle start and mle end) are de-
ﬁned in the link script (as shown in Figure 12) includ-
ing from the start of the code section (.text) to the end
of the read-only data section (.rodata). Therefore, any
alteration of those sections will be identiﬁed by the mea-
surement extended by SINIT ACM.
In contrast to the code and read-only data, the writable
data section (.data) and the uninitialized data segment
(the .bss section) are not measured. After careful investi-
gations, we found that some variables (g tpm, tpm 12 if,
and tpm 20 if, as shown in Figure 13) exist in the un-
measured sections and could affect the control ﬂow. The
mutable variables are function pointers left behind and
not measured. By hooking those pointers, we can hook
the control ﬂow and eventually forge the dynamic PCRs,
bypassing the protections provided by the SINIT ACM.
Similarly to the attack explained in Section 4.2, the
normal measurements extended by tboot are recorded in
the event logs that reside in the kernel’s memory area.
The txt-stat tool provided by tboot dumps the kernel
memory via /dev/mem and prints out the summary sta-
tus of TXT and event logs, as shown in Figure A.1 in
Appendix.
After obtaining the normal digests, we can forge ex-
tended values after tboot takes control by hooking the ex-
!"##!$
%&82$()*+,-.$$
JKLK4$MAN$
!"##!$
%&#’!$()*+,-.$
A#$U28+21$
/)’-$0)1*2’$3+$454$(#6’$
!"#$%&!’())%)*+,"""#
!"#$%-!’.)//"0&,"""#
!"#$%*!’0)-1"231"""#
"""#
9.$:;!8),!$+#8$$
$$$$$=*+,!3#+$?#3+!28’$3+$!"##!$
@.$A)1,*1)!2$-)’-2’$#=$!-2$$
$$$$$+#8;59:’
456785’59:;$!-2$+#8$&AC$D9G$)82$>3==282+!$3+$126),H$&AC$$&AC$D9E$3’$>3==282+!$3+$>2!)31’Q)*!-#83!32’$$U28+21$
6’(#5%!.’.#%
%J!311$,#$
"*!$4&N$’-#I’$!-2$+#8$7*+,!3#+$&#3+!28’$3+$!"##!$
456785’59:;;59:’
456785’59:;H+)$)$!"##!$-)’-$
C2?1)H$!-2$+#8$=*+,!3#+$?#3+!28’$
L#8<)1$&AC’$
+%,-.#
$%&’()*("""#
"""#
"""#
!"#$%&’
!"#$%-’
!"#$%*’
-3%&.%+*"""#
3+?1"2*&"""#
(22?(2-&"""#
"""#
"""#
+%,-’/#
........"""#
Figure 11: Detailed process of exploiting the DRTM vul-
nerability
posed function pointers. The hook functions reside in the
data section of tboot in shellcode form, and the hooking
has to be done before the platform enters the S3 sleeping
1238    27th USENIX Security Symposium
USENIX Association
S E C T I O N S
{
. = T B O O T _ B A S E _ A D D R ; /* 0 x 8 0 0 0 0 0 */
. text : {
*(. t b o o t _ m u l t i b o o t _ h e a d e r )
. = ALIGN (4096) ;
*(. mlept )
/* B e g i n n i n g of MLE */
_ m l e _ s t a r t = .;
*(. text )
*(. fixup )
*(. gnu . w a r n i n g )
} : text = 0 x9090
. rodata : { *(. rodata ) *(. rodata .*) }
. = ALIGN (4096) ;
_ m l e _ e n d = .;
/* End of MLE */
/* B e g i n n i n g of text s e c t i o n ( ready - only ) */
800000 t m u l t i b o o t _ h e a d e r
800010 t m u l t i b o o t 2 _ h e a d e r
800020 t m u l t i b o o t 2 _ h e a d e r _ e n d
801000 t g _ m l e _ p t
804000 T _ m l e _ s t a r t
804000 T _start
804000 T start
804010 T _ p o s t _ l a u n c h _ e n t r y
... o m i t t e d ...
83 b000 D _ m l e _ e n d
/* B e g i n n i n g of MLE */
/* End of MLE */
/* B e g i n n i n g of data s e c t i o n ( w r i t a b l e ) */
83 b000 D s 3 _ f l a g
... o m i t t e d ...
83 f234 D g_tpm
... o m i t t e d ...
83 f2c0 D t p m _ 1 2 _ i f
83 f460 D t p m _ 2 0 _ i f
/* C u r r e n t TPM i n t e r f a c e */
/* TPM i n t e r f a c e s in */
*/
/* data s e c t i o n for
/* TPM 1.2 and 2.0
*/
/* Data */
... o m i t t e d ...
. data : {
*(. data )
*(. t b o o t _ s h a r e d )
C O N S T R U C T O R S
}
... o m i t t e d ...
}
Figure 12: Sections in the link script (tboot.lds.x) of
tboot
state. The locations of g tpm, tpm 12 if, and tpm 20 if
are as shown in Figure 13. The offsets might differ ac-
cording to the versions of the implementation, but those
function pointers are exposed in the mutable section.
The last step of the attack, likewise, is to reset the TPM
state and replay the normal digests. The difference is
that, when the platform wakes up, tboot and SINIT ACM
are executed. SINIT ACM resets the dynamic PCRs,
measures tboot, and extends the measurements to PCR
#17. It starts tboot again, and tboot extends the PCRs
with the hook functions. The replay should be done by
extending the measurements in the designated order for
replacing the measurement of the customized kernel with
the normal one.
4.4 Evaluation
We tested our exploits on various Intel-based platforms
to determine how many devices are exposed to these vul-
nerabilities. The tested devices are listed in Table 4.
Ubuntu 16.04.03 was used as the host operating sys-
tem. The genuine kernel 4.13.0-21-generic of the op-
erating system was used for our customization, in which
we removed the TPM SaveState() or TPM2 Shutdown()
calls. For the SRTM attack mentioned in Section 4.2,
we used the source code of CoreOS GRUB 2.0 [5]. For
the DRTM attack, we used source code from the tboot
project [11]. The devices were UEFI booted from the ex-
Figure 13: tboot symbols. The TPM interfaces are in the
data section
ternal hard disk drive, where we installed the customized
system with exploits. To replace the normal bootloader
and kernel with our customized ones, we put the cus-
tomized ones under the /boot directory with the same
name.
TPM 2.0 supports multiple banks of PCRs, with
each bank implementing different hash algorithms. The
BIOS/UEFI ﬁrmware and the kernel are likely to be ex-
tended to separate banks. Although the reported vulner-
abilities do not depend on a speciﬁc hash algorithm, we
used SHA-1 in all evaluations only because the algorithm
is supported in both versions of the TPM.
The DRTM exploit requires devices to support Intel
TXT and tboot. However, some of them do not support
Intel TXT and some of the TXT-supporting devices do
not work with tboot, as a result, we could exploit only
a few of them. Table A.1 in Appendix shows the tested
devices.
4.4.1 SRTM Attack: Grey Area Vulnerability
Table 5 compares all normal PCR values and exploited
PCR values except for PCR #10, which is extended by
IMA in the kernel. Although the PCR #10 values of all
PCs are different, the value of PCR #10 can be extended
from PCR #0-PCR #7. We hence attach additional tables
in our GitHub repository [10], which lists the PCR values
obtained from the normal SRTM-based booting sequence
on our tested devices.
Because the static PCRs values are measurements of
the SRTM components, most of the values differ ac-
cording to the manufacturers and model, except for PCR
#4 and PCR #9, where the measurements of the boot-
USENIX Association
27th USENIX Security Symposium    1239
PC
No.
Vendor
1
2
3
4
5
6
7
8
9
10
11
Intel
Intel
Dell
GIGABYTE
GIGABYTE
ASUS
Lenovo
Lenovo
Dell
HP
GIGABYTE
CPU
(Intel)
Core
i5-5300U
Core
m5-6Y57
Core
i5-6500T
Core
i7-6700
Core
i7-6700
Core
i7-6700
Core
i7-6600U
Core
i5-4570T
Core
i5-6500T
Xeon
E5-2690 v4
Core
i7-6700
PC and mainboard
model
BIOS Ver. and
release date
TPM
Ver.
TPM vendor and
ﬁrmware Ver.
SRTM
attack
NUC5i5MYHE
Compute Stick
STK2mv64CC
Optiplex 7040
Q170M-MK
H170-D3HP
Q170M-C
MYBDEWi5v.86A,
2017.11.30
CCSKLm5v.86A.0054,
2017.12.26
1.8.1,
2018.01.09
F23c 2,
2018.01.11
F20e,
2018.01.10
3601,
2017.12.12
X1 Carbon 4th
N1FET59W (1.33),
Generation
ThinkCentre m93p
Optiplex 7040
z840
H170-D3HP
2017.12.19
FBKTCPA,
2017.12.29
1.8.1,
2018.01.09
M60 v02.38,
2017.11.08
F20e,
2018.01.10
2.0
2.0
2.0
2.0
2.0
2.0
1.2
1.2
1.2
1.2
1.2
Inﬁneon,
5.40
NTC,
1.3.0.1
NTC,
1.3.2.8
Inﬁneon,
5.51
Inﬁneon,
5.61
Inﬁneon,
5.51
Inﬁneon,
6.40
STMicroelectronics,
13.12
NTC,
5.81.2.1
Inﬁneon,
4.43
Inﬁneon,
3.19
Y
Y
Y
Y
Y
Y
N 3
N 3
N 4
N 3
N 3
Table 4: List of PC and mainboard models and results of the SRTM attack
PC