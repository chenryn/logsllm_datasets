u
b
i
r
t
s
D
i
100
90
80
70
60
50
40
30
20
10
0
0
1
2−10
11−50
> 50
cat
htzipd
lhttpd
gnatsd
s
e
a
t
t
s
g
n
o
m
a
s
e
u
a
v
t
l
u
o
−
n
a
f
f
o
n
o
i
t
u
b
i
r
t
s
D
i
100
90
80
70
60
50
40
30
20
10
0
0
1
2−10
11−50
> 50
cat
htzipd
lhttpd
gnatsd
e
a
t
l
t
s
r
e
p
s
o
b
m
y
s
n
o
i
t
i
s
n
a
r
t
e
u
q
n
u
i
d
n
a
t
u
o
(cid:239)
n
a
f
e
g
a
r
e
v
A
25
20
15
10
5
0
avg. fan(cid:239)out per state
avg. unique  transition symbols per state
cat
htzipd
lhttpd
gnatsd
Figure 7. Percentage dis-
tribution of
fan-out values
among automaton states af-
ter -reduction.
Figure 8. Percentage dis-
tribution of
fan-out values
among automaton states be-
fore -reduction.
Figure 9. Average fan-out
and average unique transi-
tion symbols per automaton
state.
s
e
a
t
t
s
r
o
s
s
e
c
c
u
s
a
t
l
e
d
g
n
s
u
i
d
e
v
a
s
y
r
o
m
e
m
%
20
15
10
5
0
(cid:239)5
cat
htzipd
lhttpd
gnatsd
e
z
s
i
n
o
t
a
m
o
t
u
a
d
n
a
t
u
o
(cid:239)
n
a
f
.
g
v
a
n
i
e
s
a
e
r
c
e
d
%
100
90
80
70
60
50
40
30
20
10
0
% decrease in avg. fan(cid:239)out
% decrease in automaton size
cat
htzipd
lhttpd
gnatsd
t
s
e
a
t
s
f
o
r
e
b
m
u
n
n
i
e
s
a
e
r
c
n
i
%
400
350
300
250
200
150
100
50
0
cat
htzipd
lhttpd
gnatsd
Figure 10. Percentage sav-
ings in memory if the model
uses delta successor au-
tomaton states.
Figure 11. Percentage de-
crease in fan-out and au-
tomaton size if the model in-
cludes -transitions.
Figure 12. Percentage in-
crease in number of states
includes -
if
transitions.
the model
and unique transition symbols per state. The number of suc-
cessors being much greater than the number of unique tran-
sition symbols per state (especially for gnatsd) illustrates
the potential for signiﬁcant space savings.
Maintaining Delta Successor States. States are distin-
guished by identiﬁers that are also offsets in the table rep-
resenting the model. In our example, the default size is 19
bits. Delta successors do not use identiﬁers for the succes-
sors of a state, instead offsets (in the model) of the succes-
sors relative to the current state. Such successor states are
delta successor states. Figure 10 shows the memory sav-
ings obtained by maintaining delta successor states in the
automaton. For cat and lhttpd, which are smaller pro-
grams compared to the other two, the extra information that
is needed to use delta successor states outweighs the mem-
ory savings and results in a net increase in memory needs.
For gnatsd however, we can obtain up to 16.49% decrease
in memory needs on using delta successor states.
Including -transitions.
Initially an IAM has entry, exit,
call, and return nodes for every function instance and call
site. Calls to library functions are represented using a sin-
gle call node because we do not analyze them. Of all these
nodes, only the call nodes to library functions are of interest
for intrusion detection. Once the basic IAM is constructed,
our implementation performs -reduction. We hypothesized
that this would not only yield a more compact representa-
tion but also better runtime performance by reducing the
search space to only library calls. The ﬁnal IAM thus in-
cludes a single entry node (that of main) and call nodes for
each library function. However, the compaction increases
the degree of non-determinism in the model by introducing
more transitions per state. Each automaton state now has a
Proceedings of the 2005 IEEE Symposium on Security and Privacy (S&P’05) 
1081-6011/05 $ 20.00 IEEE
greater fan-out than before. The maximum fan-outs in the
-free IAMs for cat, htzipd, lhttpd, and gnatsd are
35, 136, 33, and 10,028 respectively. In gnatsd particu-
larly, there is a high degree of non-determinism in the pro-
gram text itself. There are switch statements with about
80-115 cases in the lexical analyzer and parser subsystems.
Figure 12 shows the percentage increase in the number of
states if -transitions are included in the automaton. The
number of states almost quadruples in the case of htzipd
and gnatsd. But the average fan-out per state decreases
considerably for all programs (see Figure 11). In the case
of gnatsd, it drops from 23.3 to 1.5 (a 93.45% decrease).
The percentage distribution of fan-out values in this case is
shown in Figure 8. Including -transitions in the automaton
and using delta successor states reduces the automaton sizes
of these programs by as much as 74.8% for cat and 72.2%
for gnatsd (see Figure 11). Given that single-successor
states make up between 49.5% to 81.3% of all states in this
case (Figure 8), coalescing can lead to further compaction.
However, inclusion of -transitions may result in additional
runtime overhead caused by traversal of the additional states
(because, in effect, the monitoring algorithm would have to
do an -reduction at runtime). Our current model represen-
tation (the -free IAM) is highly optimized for time. We be-
lieve that in memory-constrained contexts, one can beneﬁt
from the above optimizations but expect additional runtime
overhead.
Hybrid Automata. Following [1], we discuss a hybrid
model that addresses two problems of IAMs: footprint and
accuracy. The idea of a hybrid model is to give users more
control over space/time tradeoffs. Although there is not nec-
essarily a direct correlation between program size and IAM
size (the size of the IAM is affected by issues such as the
number of library functions, the number of call sites, the
average fan-out), program size remains a good approxima-
tion. Very large programs as well as pathological cases will
occur and it is desirable to have a strategy to deal with those.
A hybrid automaton model hIAMk combines inlining with
the guarded calls proposed for the Dyck model. A hIAMk
is constructed bottom up starting with leaf functions, i.e.
functions that do not call other user functions. Inlining is
applied iteratively so that at each iteration, all functions that
only call leaf functions are selected for inlining. Modulo re-
cursion, this process will terminate when all functions have
been transformed to leaf functions. The main difference
with an IAM is that in hIAMk, the inlining is controlled by
a user deﬁned constant k which determines the maximum
size for an inlined function. Any function with a number of