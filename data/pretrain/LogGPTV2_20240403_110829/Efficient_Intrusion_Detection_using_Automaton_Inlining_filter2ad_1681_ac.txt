### 优化后的文本

#### 图表说明
- **图7**：展示在进行ε-约简后，自动机状态之间的扇出值分布百分比。
- **图8**：展示在进行ε-约简前，自动机状态之间的扇出值分布百分比。
- **图9**：展示每个自动机状态的平均扇出值和平均唯一转移符号数量。
- **图10**：展示使用delta后继状态时内存节省的百分比。
- **图11**：展示包含ε-转移后，扇出值和自动机大小减少的百分比。
- **图12**：展示如果模型包含ε-转移，状态数量增加的百分比。

#### 数据分析
- **图7 和 图8**：展示了在进行ε-约简前后，不同程序（cat, htzipd, lhttpd, gnatsd）中自动机状态的扇出值分布。特别是gnatsd，在约简后表现出显著的非确定性。
- **图9**：展示了每个自动机状态的平均扇出值和平均唯一转移符号数量。对于某些程序，如gnatsd，成功状态的数量远大于每状态的唯一转移符号数量，这表明有显著的空间节省潜力。
- **图10**：展示了通过维护delta后继状态所获得的内存节省。对于较小的程序（如cat和lhttpd），额外信息的需求超过了内存节省，导致总体内存需求增加；但对于较大的程序（如gnatsd），可以实现高达16.49%的内存节省。
- **图11 和 图12**：展示了包含ε-转移对自动机的影响。虽然状态数量显著增加（例如，htzipd和gnatsd几乎增加了四倍），但每个状态的平均扇出值大幅下降（gnatsd从23.3降至1.5，减少了93.45%）。同时，自动机大小也显著减小（cat减少74.8%，gnatsd减少72.2%）。

#### 维护Delta后继状态
- 状态由标识符区分，这些标识符也是模型表示表中的偏移量。默认情况下，标识符大小为19位。Delta后继状态不使用标识符来表示当前状态的后继者，而是使用相对于当前状态的偏移量。这种后继状态称为delta后继状态。图10展示了通过维护delta后继状态所获得的内存节省。

#### 包含ε-转移
- 初始IAM包含每个函数实例和调用站点的入口、出口、调用和返回节点。库函数调用使用单个调用节点表示，因为它们不在分析范围内。只有库函数调用节点对入侵检测感兴趣。构建基本IAM后，我们的实现进行了ε-约简。我们假设这不仅会产生更紧凑的表示形式，还能通过将搜索空间限制在库调用上提高运行时性能。最终的IAM包括一个单一入口节点（main）和每个库函数的调用节点。然而，这种压缩通过引入更多的状态转移增加了模型的非确定性程度。

#### 混合自动机
- 参考文献[1]，讨论了一种解决IAM足迹和准确性问题的混合模型。该模型允许用户更好地控制空间/时间权衡。尽管程序大小与IAM大小之间不一定有直接关联，但程序大小仍然是一个好的近似值。非常大的程序和病态情况会发生，因此需要一种策略来应对这些问题。混合自动机模型hIAMk结合了内联和Dyck模型中提出的受保护调用。hIAMk自底向上构建，从叶函数开始（即不调用其他用户函数的函数）。内联过程迭代进行，每次选择仅调用叶函数的所有函数进行内联。与IAM的主要区别在于，hIAMk中的内联由用户定义的常数k控制，该常数决定了内联函数的最大大小。

通过上述优化，可以在内存受限的情况下获益，但可能会增加运行时开销。目前的模型表示（ε-free IAM）高度优化了时间性能。