数据中心级别任务分发服务的独占性。如果缺少了这种独占性，旧的领头人进程可能会
进程必须立刻终止一切和数据中心任务分发系统之间的交互。领头人角色必须意味着对
另外一个作为领头人角色非常重要的功能是，当其由于各种原因失去领头人角色时，该
可用）。下文会提到如何处理发生在这项操作过程中的问题。
是否真正成功或者是否由于外部原因失败了（例如，如果数据中心任务分发系统当前不
我们这里仅仅记录了Cron服务在某个时间试图进行一次启动操作，并不关心这次启动
Cron任务启动过程的完成也需要通过Paxos协议同步通知给其他的副本。要注意的是
副本可能会重新进行这次启动，因为它们不知道这个任务已经被启动过一次了。
程都在领头人进程上完成，而没有通知到其他的副本。当故障切换的时候，新的领头人
换的时候决定正确的操作。如果这些操作是异步进行的，可能意味着整个任务的启动过
结束之前不会进行。Cron服务需要知道每个任务是否已经启动了，这样才能在领头人切
Paxos通信的同步性是很重要的，这样Cron任务的实际启动在得到Paxos法定仲裁过程
图24-2：以领头人视角画的Cron任务启动过程示意图
成的。
如那些每分钟运行一次的任务）。如图24-2所示，全部通信都是基于Paxos 协议之上完
time
开始启动eronjob=Ffo0，time=1.1.197012:34，
等待启动
启动结束
RPC#3
RPC#2
RPC#1
foo',
1.197012:34
GoogleCron系统的构建过程
Cluster
Paxos
Paxo
279
322
---
## Page 322
323
这里要注意的是，就像在Cron内部使用名字和预计启动时间唯一标识某个任务那样，
为了能够判断RPC是否成功发送，下列情况中的一个必须被满足：
280
动过程中崩溃，新的领头人副本可以通过预计算的任务名称来查询任务的状态。
副本（这样就可避免在数据中心调度器上进行任何的修改操作）。如果领头人副本在启
一种解决幂等性问题的方案是提前构建一致的任务名称，并且分发给所有的Cron服务
命名服务，使我们可以通过这些名字查找任务状态、停止任务，或者进行其他的维护操作。
正确地处理这些情况，可能会导致错过某些任务的执行，或者重复运行某些任务。
在大型分布式系统中应对单点或多点故障并准确运行一个Cron系统的前提。如果没有
这两个选项中的任意一个都是很大的挑战，可能很难实现。但是实现其中的至少一个是
是启动结束通知发送之前领头人进程就崩溃了的情况。
们怎么能够知道这个RPC是否已经发出了呢？这里还包括在标记启动已经执行之后，
这两个同步点使我们可以标记每一次具体的启动。就算启动过程仅仅需要一个RPC，
前文说过，每个任务启动都具有两个同步点：
RPC中间失败。
正如上文所述，
解决部分性失败情况
细讨论如何解决这种部分性失败情况。
的，通常需要Cron系统和数据中心基础服务的共同协作才能完成。下面这一小节会详
领头人被选举出来，所有的未完成状态的启动过程必须被结束。这个过程可能是很复杂
必须要在一分钟之内完成，这样可以避免大幅延迟或者跳过某个任务的执行。一旦一个
无法联系到其他的副本），某个追随者进程将会被选举为新的领头人进程。该选举过程
如果领头人进程崩溃，或者由于其他某个原因不再正常工作（例如，
系统中的状态是一致的。我们同时也会记录所有的未完成启动。
·所有需要在选举过后继续的，对外部系统的操作必须是幂等的（这样我们可以在
必须能够通过查询外部系统状态来无疑义地决定某项操作是否已经成功。
选举过后重新进行该操作）。
当启动执行之后
当启动执行之前
第24章分布式周期性任务系统
，我们的系统应该能处理这种状况。
，领头人进程和数据中心调度系统之间的单个任务启动的过程可能在多个
：由于网络分区问题
我
---
## Page 323
存储数据有两个方案：
比之下，丢失日志仅仅会将Cron系统重置回上次快照的时间。
信息一
在日志丢失的情况下，我们只会丢失上次快照之后的信息。快照也是我们最重要的状态
1000次选代之后，可以用一个“将计数器设置为1000”来替代1000条记录。
一个例子：如果我们的状态变化存储在日志中的时候是“将某个计数器加1”，那么在
这就意味着我们可以不再需要重新回放之前的所有状态改变来得到目前的状态。提供
为了避免Paxos日志的无限增长，可以简单地将目前的状态进行一次快照（snapshot）。
志，在每次状态变化后同步地新增。Paxos协议的这种特性意味着以下两个问题：
使用 Paxos 协议来达成共识只是状态问题的一部分。Paxos 基本上是一个只能新增的日
保存状态
现者可能要在双重启动的风险和错过启动的风险中进行执择。
的实现细节所决定的。然而，前面的描述适用于任何系统。取决于具体的基础设施，实
在实际的实现中，状态的查询由一个比较复杂的系统组成，这主要是由于底层基础设施
动情况的发生。
副本就可以准确地知道这个任务其实是任务的某个特定启动，于是就避免了这种双重启
成状态，于是尝试再次启动该任务。如果预期启动时间被包含在任务名中，新的领头人
足够这个任务已经结束了。新的领头人副本查询该任务的状态，发现该任务目前处于完
其他副本之前，领头人进程崩溃了。同时故障切换机制由于某种问题造成了延迟，迟到
频运行的，但是运行时间很短的任务。该任务成功启动，但是在启动成功的信息同步到
Cron服务与数据中心调度器的交互也使用预期启动时间唯一标识。例如，假设有一个高
上文说过，我们在副本之间同步信息的时候会记录预期启动时间。同样的，我们需要将
是也会有意外情况发生。
取的方式标记这个信息）。在常规操作中，Cron服务应该可以很快地完成故障迁移，但
我们也需要在数据中心调度器上的任务名称上包含该次启动时间（或者用某种其他可获
·外部可用的分布式存储。
·在系统内部存储少量的数据。
®
日志必须要存储在某个地方。
日志需要定期压缩，以防无限增长。
一如果丢失快照信息，我们就必须从零开始，因为已经丢失了全部内部状态。相
Google Cron系统的构建过程
324
---
## Page 324
325
的要求有关系。
隔自动产生的。当然，这些妥协可能根据基础设施的细节而不同，也与Cron系统本身
282
Cron系统可以根据需要自行选择一个时间。用户可以将任务分散在整个事件序列里（例
的每一天都会运行）。我们在这里增加了一个问号“？”，意味着任意一个值都可以接受，
会将crontab标记为“00***”（也就是0分0时，月内的每一天，每个月，以及周内
来标记某个任务应该运行的时间，或者使用“*”来标记任意值。每天在午夜时候运行
在普通crontab 格式中，用户用分钟、小时、月中的日期（或者周内的日期），以及月份
crontab格式上增加了一些扩展。
队也按照同样的配置在同一个数据中心来运行每日任务呢？为了解决这个问题，我们在
你的任务会产生数千个MapReduce工作进程的时候就不可行了。尤其是当其他30个团
时，他们通常会配置该任务在午夜时运行。这个配置可能在一台机器上还可行，但是当
一定要小心任何大型分布式系统都熟知的问题：惊群效应（thundering herd）。根据用户
运行Cron系统，系统的用量可能会大幅增加，同时可能会造成一定的问题。
常很小，最多可能由几十个任务组成。但是，如果我们在一个数千台机器的数据中心上
运维一个大型Cron系统同样有一些较小但是也很有趣的问题。传统的Cron系统规模通
运维大型Cron系统
外一台物理机器上（或者由于物理机器故障原因迁移）对服务稳定性来说没有影响。
程可以独立于本地物理机器的任何状态。因此，将系统的某个副本重启，重新调度到另
的副本可以从另外一个已经运行的副本上获得最新的快照和目志。这个能力使得启动过
除了在本地存储的日志和快照，以及分布式文件系统上的快照备份之外，
小部分日志信息：这些都是自从上次快照之后产生的。而快照是根据预先配置的时间间
而且如果的确同时发生故障了，我们会自动从快照中恢复。于是，我们仅仅只会丢失一
很严重的性能问题一由大量的小型写操作引起。三个机器同时出现故障是很罕见的，
分最近的状态改变是一个可以接受的危险。将日志保存在分布式文件系统上可能会造成
我们并不将日志直接存储在分布式文件系统上。我们认为丢失日志，也就是丢失一小部
题的情况提供保护。
息很重要，会同时将它们备份到一个分布式存储上去。这样可以为三个机器同时出现问
运行，也就是有三份日志。同时我们也将快照信息保存在本地磁盘上，然而因为这些信
我们将Paxos日志存储在服务副本运行的本地磁盘上。在标准情况下，我们有三个副本
当设计该系统时，我们采取了一个综合两个选项的方案。
第24章分布式周期性任务系统
一个刚刚启动
---
## Page 325
的Cron服务。
以及对大型、分布式环境中任务失败模式的分析使得Google可以构建出一个非常可靠
统的核心是Paxos协议，一个在分布式不可靠系统达成一致的算法。Paxos协议的使用，
的系统设计。这个解决方案需要分布式环境下的强一致性保障。因此，分布式Cron系
我们讨论了分布式系统环境下出现的新约束条件，以及一个基于Google解决方案的新
的。
也不例外。Google的新设计是建立在对该服务的必要属性以及相关任务的具体需求之上
据中心逐渐成为事实上最小的硬件单元，也就意味着技术栈中很多部分都要改变。Cron
Cron服务是UNIX系统十多年来的一个基础服务。随着行业向大型分布式系统迁移，数
小结
图24-3：全球Cron任务的启动数量
时依赖造成。
负载峰值，这是因为某些任务需要在特定时间启动一
聚合过的Google全球Cron任务启动数量图。这个图片集中展示了Cron任务经常性的
就算引入了这个改动，Cron任务带来的系统负载仍然是非常尖锐的。图24-3所示的是，
如0..23中的某个小时），因此可以将这些任务分散得更为均匀。
Cronjobslaunched
Time
一例如，由于对外部事件的某些临
小结
283
326
---
## Page 326
327
284
线”（simple，one-phase pipeline）。
对大数据进行周期性的或者是持续性的变形操作的程序通常被称为“简单的，单相流水
简单流水线设计模式与大数据
数据流水线（data pipeline）。数据流水线是一个由来已久的概念，与协程（coroutine，参
经典的数据处理方式是通过一个程序读取输入，执行某种模式变换，然后输出新的数据。
者模式，可以用来替代处理海量数据的周期性流水线模型。
流水线与持续运行永不停止的数据流水线面临的共同问题，也讨论了它们的不同点，这
本章关注数据处理流水线在实际应用中面临的复杂问题。这里讨论了周期性运行的数据
编辑：TimHarvey
作者：Dan Dennison
数据处理流水线
第25章
无法处理的特别巨大或者超级复杂的数据集”逐渐增多而流行起来。
见文献[Con63]）、DTSS通信文件（参见文献[Bul80]）和UNIX管道（参见文献[McI86]），
一般来说，这种程序由类似于Cron的某个周期性的调度程序控制。这种设计模式被称为
流水线设计模式的起源
往往是运维的痛点所在。本章提出了一个崭新的、更可靠的、更易扩展的领头人-追随