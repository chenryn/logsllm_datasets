# CVE-2020-9802 JSC CSE漏洞分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前言
编译器优化中有一项CSE（公共子表达式消除），如果JS引擎在执行时类型收集的不正确，将导致表达式被错误的消除引发类型混淆。
## 0x01 前置知识
###  CSE
公共子表达式消除即为了去掉那些相同的重复计算，使用代数变换将表达式替换，并删除多余的表达式，如
    let c = Math.sqrt(a*a + a*a);
将被优化为
    let tmp = a*a;
    let c = Math.sqrt(tmp + tmp);
这样就节省了一次乘法，现在我们来看下列代码
    let c = o.a;
    f();
    let d = o.a;
由于在两个表达式之间多了一个f()函数的调用，而函数中很有可能改变.a的值或者类型，因此这两个公共子表达式不能直接消除，编译器会收集o.a的类型信息，并跟踪f函数，收集信息，如果到f分析完毕，o.a的类型也没有改变，那么let
d = o.a;就可以不用再次检查o.a的类型。  
在JSC中，CSE优化需要考虑的信息在`Source/JavaScriptCore/dfg/DFGClobberize.h`中被定义，从文件路径可以知道，这是一个在DFG阶段的相关优化，文件中有一个`clobberize`函数，
    template
    void clobberize(Graph& graph, Node* node, const ReadFunctor& read, const WriteFunctor& write, const DefFunctor& def)
    {
    .............................................
        case CompareEqPtr:
            def(PureValue(node, node->cellOperand()->cell()));
            return;
    ..............................................
clobberize函数中的`def`操作定义了CSE优化时需要考虑的因素，例如上面的`def(PureValue(node,
node->cellOperand()->cell()));`，如果要对`CompareEqPtr`运算进行CSE优化，需要考虑的因素除了value本身的值，还需要的是Operand（操作数）的类型(cell)。
###  边界检查消除
与V8的checkbounds消除类似，当数组的下标分析确定在数组的大小范围之内，则可以消除边界检查，但如果编译器本身的检查方式出现溢出等问题，编译器认为idx在范围之内而实际则可能不在范围内，错误的消除边界检查将导致数组溢出。  
为了研究JSC在什么条件下可以消除边界检查，我们使用如下代码进行测试调试
    function foo(arr,idx) {
       idx = idx | 0;
       if (idx = 0) {
             return arr[idx];
          }
       }
    }
    var arr = [1.1,2.2,3.3,4.4,5.5,6.6];
    for (var i=0;i46)
    [  21] bitand             loc6, arg2, Int32: 3(const1)
    [  26] jfalse             loc6, 9(->35)
    [  29] add                arg2, arg2, Int32: -2(const2), OperandTypes(126, 3)
    [  35] jngreatereq        arg2, Int32: 0(const0), 11(->46)
    [  39] get_by_val         loc6, arg1, arg2
    [  44] ret                loc6
    [  46] ret                Undefined(const3)
其中`[ 39] get_by_val loc6, arg1, arg2`用于从数组中取出数据，在DFG JIT时，其展开的汇编代码为
              0x7fffaf101fa3: mov $0x7fffaef0bb48, %r11
              0x7fffaf101fad: mov (%r11), %r11
              0x7fffaf101fb0: test %r11, %r11
              0x7fffaf101fb3: jz 0x7fffaf101fc0
              0x7fffaf101fb9: mov $0x113, %r11d
              0x7fffaf101fbf: int3 
              0x7fffaf101fc0: mov $0x7fffaef000dc, %r11
              0x7fffaf101fca: mov $0x0, (%r11)
              0x7fffaf101fce: cmp -0x8(%rdx), %esi
              0x7fffaf101fd1: jae 0x7fffaf1024cb
              0x7fffaf101fd7: movsd (%rdx,%rsi,8), %xmm0
              0x7fffaf101fdc: ucomisd %xmm0, %xmm0
              0x7fffaf101fe0: jp 0x7fffaf1024f2
其中的
              0x7fffaf101fce: cmp -0x8(%rdx), %esi
              0x7fffaf101fd1: jae 0x7fffaf1024cb
用于检查下标是否越界，可见DFG JIT阶段并不会去除边界检查，尽管我们在代码中使用了if语句将idx限定在了数组的长度范围之内。边界检查去除表现在FTL
JIT的汇编代码中，从json文件中可以看到FTL JIT时，对字节码字节码`[ 39] get_by_val loc6, arg1, arg2`的展开如下
    D@86:    ExitOK(MustGen, W:SideState, bc#39, ExitValid)
    D@63:    CountExecution(MustGen, 0x7fffac9cf140, R:InternalState, W:InternalState, bc#39, ExitValid)
    D@66:    GetByVal(KnownCell:Kill:D@14, Int32:Kill:D@10, Check:Untyped:Kill:D@68, Check:Untyped:D@10, Double|MustGen|VarArgs|UseAsOther, AnyIntAsDouble|NonIntAsDouble, Double+OriginalCopyOnWriteArray+InBounds+AsIs+Read, R:Butterfly_publicLength,IndexedDoubleProperties, Exits, bc#39, ExitValid)  predicting NonIntAsDouble
    D@85:    KillStack(MustGen, loc6, W:Stack(loc6), ClobbersExit, bc#39, ExitInvalid)
    D@67:    MovHint(DoubleRep:D@66, MustGen, loc6, W:SideState, ClobbersExit, bc#39, ExitInvalid)
    ValueRep(DoubleRep:Kill:D@66, JS|PureInt, BytecodeDouble, bc#39, exit: bc#44, ExitValid)
从中可以看到`GetByVal`中传递的参数中含有`InBounds`标记，那么其汇编代码中将不会检查下标是否越界，因为前面已经确定下标在范围内。为了查看FTL
JIT生成的汇编代码，我们使用gdb调试，遇到print语句时会断点停下
此时，我们对`butterfly`中对应的位置下一个硬件读断点，然后继续运行
    pwndbg> rwatch *0x7ff803ee4018
    Hardware read watchpoint 79: *0x7ff803ee4018
    pwndbg> c
    Continuing.
然后断点断下
       0x7fffaf101b9c    movabs r11, 0x7fffaef000dc
       0x7fffaf101ba6    mov    byte ptr [r11], 0
       0x7fffaf101baa    cmp    esi, dword ptr [rdx - 8]
       0x7fffaf101bad    jae    0x7fffaf102071 
       0x7fffaf101bb3    movsd  xmm0, qword ptr [rdx + rsi*8]
     ► 0x7fffaf101bb8    ucomisd xmm0, xmm0
       0x7fffaf101bbc    jp     0x7fffaf102098 
我们发现这仍然存在`cmp esi, dword ptr [rdx - 8]`检查了下标，这是由于`FTL
JIT`是延迟优化的，可能还没优化过来，我们按照前面的步骤重新试一下
       0x7fffaf1039fa    mov    eax, 0xa
       0x7fffaf103a00    mov    rsp, rbp
       0x7fffaf103a03    pop    rbp
       0x7fffaf103a04    ret    
       0x7fffaf103a05    movsd  xmm0, qword ptr [rdx + rax*8]
     ► 0x7fffaf103a0a    ucomisd xmm0, xmm0
       0x7fffaf103a0e    jp     0x7fffaf103aeb 
发现这次，边界检查被去除了，为了查看更多的代码片段，我们使用gdb的dump命令将这段代码dump出来用IDA分析
    pwndbg> vmmap 0x7fffaf103a0a
    LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
        0x7fffaf0ff000     0x7fffaf104000 rwxp     5000 0       +0x4a0a
    pwndbg> dump memory ./2.bin 0x7fffaf0ff000 0x7fffaf104000
    pwndbg>
可以看到语句
          if (idx & 0x3) {
             idx += -2;
          }
执行完毕后，无需再一次检查`idx child1().useKind() == Int32Use || node->child1().useKind() == DoubleRepUse)
    -            def(PureValue(node));
    +            def(PureValue(node, node->arithMode()));
             else {
                 read(World);
                 write(Heap);
    @@ -248,7 +248,7 @@ void clobberize(Graph& graph, Node* node, const ReadFunctor& read, const WriteFu
             if (node->child1().useKind() == Int32Use
                 || node->child1().useKind() == DoubleRepUse
                 || node->child1().useKind() == Int52RepUse)
    -            def(PureValue(node));
    +            def(PureValue(node, node->arithMode()));
             else {
                 read(World);
                 write(Heap);
该patch修复了漏洞，从patch中可以知道，这原本是一个跟CSE优化有关的漏洞，patch中加入了`node->arithMode()`参数，那么在CSE优化时，不仅要考虑操作数的值，还要考虑算术运算中出现的溢出等因素，即使最终的值一样，如果其中一个表达式是溢出的，也不能进行CSE优化。
###  POC构造
首先从patch可以知道，修改的内容分别在`ArithAbs`和`ArithNegate`分支，它们分别对应了JS中的`Math.abs`和`-`运算。  
尝试构造如下代码
    function foo(n) {
       if (n < 0) {
          let a = -n;
          let b = Math.abs(n);
          debug(b);
       }
    }
    for (var i=0;i<0x30000;i++) {
       foo(-2);
    }
foo部分字节码如下
    [  17] negate             loc7, arg1, 126
    ..........
    [  48] call               loc6, loc8, 2, 18
分别代表了-n和Math.abs(n);，在DFG JIT阶段，其展开为如下
    [ 17]
    CountExecution
    GetLocal
    ArithNegate(Int32:D@39, Int32|PureInt, Int32, Unchecked, Exits, bc#17, ExitValid)
    MovHint
    [ 48]
    CountExecution
    FilterCallLinkStatus
    ArithAbs(Int32:D@39, Int32|UseAsOther, Int32, CheckOverflow, Exits, bc#48, ExitValid)
    Phantom
    Phantom
    MovHint
在FTL JIT阶段，代码变化如下
    [ 17]
    CountExecution
    ArithNegate(Int32:Kill:D@76, Int32|PureInt, Int32, Unchecked, Exits, bc#17, ExitValid)
    KillStack
    ZombieHint
    [ 48]
    CountExecution
    FilterCallLinkStatus
    KillStack
    ZombieHint
可以看到`ArithAbs`被去除了，这就是漏洞所在，`ArithAbs`与`ArithNegate`的不同点在于，`ArithNegate`不检查溢出，而`ArithAbs`会检查溢出，因此对于0x80000000这个值，`-0x80000000`值仍然为`-0x80000000`，是一个32位数据，而`Math.abs(-0x80000000)`将扩展位数，值为`0x80000000`。显然编译器没有察觉到这一点，将`ArithAbs`与`ArithNegate`认为是公共子表达式，于是便可以进行互相替换。  
因此构造的POC如下
    function foo(n) {