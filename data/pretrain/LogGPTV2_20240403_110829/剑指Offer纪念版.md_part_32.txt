return middleIndex;
I|middleIndex
middleIndex
==
0
-1）
第6章面试中的各项能力205
!=
k)
---
## Page 220
206
剑指Offer-
的总的时间复杂度也只有 O(logn)。
一个合乎要求的数字，它们的时间复杂度都是O(logn)，因此GetNumberOfK
int GetNumberOfK(int* data,int length,int k)
数组中出现的次数了。相应的代码如下：
本题完整的源代码详见38_NumberOfK项目。
源代码：
在上述代码中，GetFirstK和GetLastK都是用二分查找法在数组中查找
return number;
if（data !=NULL&& length>0)
int number=0;
测试用例：
在分别找到第一个k和最后一个k的下标之后，我们就能计算出k在
否则返回最后一个k在数组中的下标。
和函数GetFirstK类似，如果数组中不包含数字k，那么GetLastK返回
return GetLastK(data,
else
else if（middleData-1&&last>-1)
int first = GetFirstK(data,
end =middleIndex-1;
边界值测试(查找数组中的最大值、最小值，数组中只有一个数字)
的数字在数组中出现一次/多次)。
start
else
一名企面试官精讲典型编程题（纪念版）
number =last -first +1;
start
return middleIndex;
=middleIndex +1;
=GetLastK(data,
=middleIndex+1;
length,k，start，end);
length,
length,
k，
k,0，1ength-1）;
0，
length
1）；
---
## Page 221
图6.1深度为4的二叉树
路径包含4个结点（从根结点1开始，经过结点2和结点5，最终到达叶结
struct BinaryTreeNode
为树的深度。
点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度
面试题39：二叉树的深度
7)。
例如，图6.1中的二叉树的深度为4，因为它从根结点到叶结点最长的
BinaryTreeNode*
Bi
int
二叉树的结点定义如下：
题目一：输入一棵二叉树的根结点，求该树的深度。从根结点到叶结
本题考点：
naryTreeNode*
排序数组中查找一个数字。应聘者如果能够运用知识迁移能力，把
考查应聘者的知识迁移能力。我们都知道二分查找算法可以用来在
算法的加强版。只有对二分查找算法有着深刻的理解，应聘者才有
考查应聘者对二分查找算法的理解程度。这道题实际上是二分查找
特殊输入测试（表示数组的指针为NULL指针)。
可能解决这个问题。
么这个问题也就解决了一大半。
问题转换成用二分查找算法查找重复数字的第一个和最后一个，那
m_pRight;
m_nValue;
第6章面试中的各项能力207
---
## Page 222
208
剑指Offer-
可。
根结点为1的树的深度就是4。
根结点为2的左子树的深度为3，而根结点为3的右子树的深度为2，因此
根结点为1的树有左右两个子树，其左右子树的根结点分别为结点2和3。
的深度就是其左、右子树深度的较大值再加1。比如在图6.1的二叉树中，
树的深度应该是其右子树的深度加1。如果既有右子树又有左子树，那该树
该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么
点，它的深度为1。如果根结点只有左子树而没有右子树，那么树的深度应
思路的代码量比较大，我们可以尝试更加简洁的方法。
叉树中和为某一值的路径”中我们详细讨论了如何记录树中的路径。这种
去得到树的所有路径，也就能得到最长的路径及它的长度。在面试题25“二
int
只要应聘者对二叉树这一数据结构很熟悉，就能很快写出上面的代码。
测试用例：
本题完整的源代码详见39_1_TreeDepth 项目。
return (nLeft>nRight)？（nLeft+1):（nRight+1);
int nRight=TreeDepth(pRoot->m_pRight);
int nLeft= TreeDepth(pRoot->m_pLeft);
if(pRoot== NULL)
TreeDepth(BinaryTreeNode*pRoot)
参考代码如下：
这个思路用递归的方法很容易实现，只需对遍历的代码稍作修改即
我们还可以从另外一个角度来理解树的深度。如果一棵树只有一个结
在本题中面试官给出了一种树的深度的定义，我们可以根据这个定义
源代码：
return 0;
指针)。
特殊输入测试（二叉树只有一个结点，二叉树的头结点为NULL
树)。
功能测试（输入普通的二叉树，二叉树中所有结点都没有左/右子
一名企面试官精讲典型编程题（纪念版）
---
## Page 223
录它的深度（某一结点的深度等于它到叶节点的路径的长度），我们就可以
结点之前我们就已经遍历了它的左右子树。只要在遍历每个结点的时候记
每个结点只遍历一次的解法，正是面试官喜欢的
要重复遍历的算法。
5、7。毫无疑问，重复遍历同一个结点会影响性能。接下来我们寻找不需
下来判断以结点2为根结点的子树是不是平衡树的时候，仍然会遍历结点4、
TreeDepth 输入左子树的根结点（结点2）时，需要遍历结点4、5、7。接
二叉树，我们将首先判断根结点（结点1）是不是平衡的。此时我们往函数
多次，这种思路的时间效率不高。例如在函数IsBalance 中输入图6.1中的
bool IsBalanced(BinaryTreeNode*pRoot)
它就是一棵平衡的二叉树。这种思路对应的代码如下：
右子树的深度。如果每个结点的左右子树的深度相差都不超过1，按照定义
到一个思路：在遍历树的每个结点的时候，调用函数TreeDepth得到它的左
·需要重复遍历结点多次的解法，简单但不足以打动面试官
衡二叉树。例如，图6.1中的二叉树就是一棵平衡二叉树。
果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平
关但难度更大的问题。比如，在应聘者做完上面的问题之后，面试官追问：
如果公司对编程能力有较高的要求，面试官可能会追加一个与前面问题相
如果我们用后序遍历的方式遍历二叉树的每一个结点，在遍历到一个
return IsBalanced(pRoot->m_pLeft) && IsBalanced(pRoot->m_pRight);
if（pRoot == NULL)
题目二：输入一棵二叉树的根结点，判断该树是不是平衡二叉树。如
上面的代码固然简洁，但我们也要注意到由于一个结点会被重复遍历
int left=TreeDepth(pRoot->m_pLeft);
有了求二叉树的深度的经验之后再解决这个问题，我们很容易就能想
return false;
return true;
=left
第6章面试中的各项能力209
---
## Page 224
210
剑指Offer-
人
就判断了整棵二叉树是不是平衡二叉树。
是平衡的，并得到当前结点的深度。当最后遍历到树的根结点的时候，也
结点的左右子结点之后，我们可以根据它的左右子结点的深度判断它是不
bool IsBalanced(BinaryTreeNode* pRoot)
型变量即可：
bool IsBalanced(BinaryTreeNode*pRoot, int* pDepth)
一边遍历一边判断每个结点是不是平衡的。
测试用例：
本题完整的源代码详见39_2_BalancedBinaryTree 项目。
源代码
在上面的代码中，我们用后序遍历的方式遍历整棵二叉树。在遍历某
return IsBalanced(pRoot,&depth);
intdepth
我们只需给上面的函数传入二叉树的根结点及一个表示结点深度的整
return false;
if(pRoot == NULL)
都没有左/右子树)。
功能测试（平衡的二叉树，不是平衡的二叉树，二叉树中所有结点
return true;
*pDepth=0;
一名企面试官精讲典型编程题（纪念版）
return true;
*pDepth = 1 +(left >right ? left :right);
right;
0：
-1)
&left)
，下面是这种思路的参考代码：
---
## Page 225
不能运用相同的思路。我们试着把原数组分成两个子数组，使得每个子数
次的数字全部在异或中抵消了。
字，那么最终的结果刚好是那个只出现一次的数字，因为那些成对出现两
它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数
次。这有什么意义呢？我们想到异或运算的一个性质：任何一个数字异或
数字只出现一次，其他的都出现了两次，怎么找出这个数字？
给出一些提示。面试官很有可能会说：你可以先考虑这个数组中只有一个
想到最好的解决办法。一般当应聘者想了几分钟后还没有思路，面试官会
杂度是0（1)。
请写程序找出这两个只出现一次的数字。要求时间复杂度是O（n），空间复
一次，其他数字都出现了两次，所以输出4和6。
面试题40：数组中只出现一次的数字
想明白怎么解决这个简单问题之后，我们再回到原始的问题，看看能
这两个题目都在强调一个（或两个）数字只出现一次，其他的出现两
这是一个比较难的题目，很少有人能在面试的时候不需要提示一下子
例如输入数组{2,4,3,6,3,2,5,5}，因为只有4、6这两个数字只出现
题目：
本题考点：
考查对二叉树的理解及编程能力。这两个题的解法实际都只是树的
分析过程中得到启发，找到判断平衡二叉树的突破口。
如何判断一棵二叉树是不是平衡的，应聘者应该从求二叉树深度的
考查知识迁移的能力。如果面试官先问如何求二叉树的深度，再问
就是一种学习能力。
是一种常见的面试题型。能在较短时间内掌握、理解新概念的能力，
这就要求我们在较短的时间内理解这个概念并解决相关的问题。这
考查对新概念的学习能力。面试官提出一个新的概念即树的深度，
遍历算法的应用。
指针)。
特殊输入测试（二叉树中只有一个结点，二叉树的头结点为NULL
一个整型数组里除了两个数字之外，其他的数字都出现了两次。
第6章面试中的各项能力211
---
## Page 226
212
剑指Offer-
void FindNumsAppearOnce(int data[],int length, int*numl, int* num2)
二个子数组中只出现一次的数字是4。
两个子数组求异或，就能找出第一个子数组中只出现一次的数字是6，而第
二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别对这
个数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第
结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两
每一个数字做异或运算之后，得到的结果用二进制表示是0010。异或得到
数字，因此到此为止所有的问题都已经解决了。
数字都出现了两次。我们已经知道如何在数组中找出唯一一个只出现一次
组分成了两个子数组，每个子数组都包含一个只出现一次的数字，而其他
们不可能把两个相同的数字分配到两个子数组中去，于是我们已经把原数
被分配到同一个子数组。因为两个相同的数字的任意一位都是相同的，我
我们分组的标准是数字中的某一位是1还是0，那么出现了两次的数字肯定
个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。由于
位是不是1为标准把原数组中的数字分成两个子数组，第一个子数组中每
在结果数字中找到第一个为1的位的位置，记为第n位。现在我们以第