Fortunately, we do not encounter a Java patch that contains
only out-of-method changes in our evaluation. Besides, we
exclude code comments in the patch from the test scope.
Generally, all changes in source code can be represented as
addition and deletion. However, to fully represent the patching
behaviors, we further introduce modiﬁcation as a new kind of
USENIX Association
29th USENIX Security Symposium    1153
// Case AString msg = uri.getPath();EventLog.writeEvent(0x534e4554, msg);// Case B: compound statementEventLog.writeEvent(0x534e4554, uri.getPath());Sliding(cid:3)Window(cid:3)0(cid:3)Sliding(cid:3)Window(cid:3)1Source(cid:3)MethodSmali(cid:3)MethodMatching(cid:3)candidate(cid:3)scopefor(cid:3)first(cid:3)unmatched(cid:3)lineFirst(cid:3)Unmatched(cid:3)LineMatched(cid:3)(cid:3)PartsMatching(cid:3)Relationship(cid:3)Unmatched(cid:3)Partssource code and the target bytecode. If this line has a
higher matched similarity in the post-patch source code
map than in the pre-patch source code map, we think
this modiﬁcation is applied in the target bytecode.
At last, a ﬁnal result is given based on the presence status of
every patch-changed line. Since a patch may contain multiple
changed lines and we can not ﬁgure out which line is more
important than another, we take all of them into account
(except those ﬁltered by Patch Analyzer) to make a decision.
To reﬂect the signiﬁcance of each patch-changed line, we use
the number of the features extracted from each patch-changed
line as its weight. Overall speaking, we calculate the patch
presence ratio from the sum of the weights for all matched
patch-changed lines and use a threshold (TPatchPresenceRatio) to
decide whether a patch is present or not.
Algorithm 1 Patch Presence Test
Input: Ppre: pre-patch source code, Ppost: post-patch source code,
Psmali: smali code, Patch: patch-changed lines
if line is matched in Line2lineMappost then
f ound ← f ound + FeaturesIn(line)
end if
end if
end if
if isDeletion(line) then
total ← total + FeaturesIn(line)
if isAddition(line) then
Output: patch presence result
1: Line2lineMappre ← Match(Ppre,Psmali)
2: Line2lineMappost ← Match(Ppost ,Psmali)
f ound ← 0
3:
4: total ← 0
5: for each line ∈ Patch do
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24: end for
25:
26: if f ound/total > TPatchPresenceRatio then
27:
28: else
29:
30: end if
end if
if isModi f ication(line) then
return f alse
return true
end if
end if
if line is not matched in Line2lineMappre then
f ound ← f ound + FeaturesIn(line)
simpost ← sim_lookup(Line2lineMappost ,line)
simpre ← sim_lookup(Line2lineMappre,line)
if simpost > simpre then
f ound ← f ound + FeaturesIn(line)
code changes. Take line 12 and line 13 in Figure 1(a) as an
example, the two lines actually represent a ﬁne modiﬁcation
to line 12, while diff command generates a line to mark
the deletion of the old line (line 12) and another line to
mark the addition of the new line (line 13). Motivated by
the example above, we adopt a heuristic-based approach to
recognize modiﬁcation lines: we regard adjacent deletion and
addition line with similar features as a modiﬁcation line. To
be speciﬁc, when the similarity between two adjacent deletion
and addition line is larger than the threshold TLineSimilarity, we
view these two lines as a single modiﬁcation line. We also
further expand the scope from one line to several consecutive
lines to recognize a block of continuous modiﬁcations.
3.4 Patch Presence Checker
This module utilizes cross-layer line-level correlative analysis
and patch analysis results to make a ﬁnal judgment of patch
presence. Our key idea is inspired by the lessons learned from
patch presence test at the source-code level, i.e. checking
how many patch-changed lines can be found in the source
code. Similarly, we give patch presence test results on Java
executables by checking how many patch-changed lines can
be recognized in the target.
The challenge here is that there are several types of changes
in a patch, we could not simply adopt a uniform presence test
strategy for them. For example, to test whether an addition
line is present in the test target (see line 7 in Figure 1(a)), we
should compare the post-patch source code with the target
bytecode, while to test a modiﬁcation line (see line 12 and
line 13 in Figure 1(a)), we should leverage both the pre-
patch source and the post-patch source code to compare.
Therefore, according to the three types (addition, deletion,
and modiﬁcation) of patch-changed lines, different strategies
are used in the presence test.
The overall test strategy is shaped in Algorithm 1. We ﬁrst
use cross-layer line-level correlative analysis to construct two
line-to-line maps between the pre-patch/post-patch source
code and the target bytecode. Second, we use separate
presence test strategies for addition/deletion/modiﬁcation
lines in a patch.
• Line Addition. To test the presence of an addition line, we
query the line-to-line map between the post-patch source
code and the target bytecode. If this line is matched, we
think this line is present in the target bytecode.
• Line Deletion. Similarly, to test the presence of a deletion
line, we query the line-to-line map between the pre-patch
source code and the target bytecode. If this line is not
matched, we think the target has applied this deletion.
• Line Modiﬁcation. It is more complicated to test the
presence of a modiﬁcation line. We need to query both
the line-to-line maps between the pre-patch/post-patch
4 Evaluation
We implement a prototype of BSCOUT within 9,290 LOC
Java code. In detail, we utilize Spoon [39] as the front-end to
1154    29th USENIX Security Symposium
USENIX Association
parse Java source code, dexlib [7] to parse smali code, and
baksmali [15] to transform Java executables to smali format
for further analysis. To support traditional stack-based Java
bytecode [9], BSCOUT transforms it into DEX bytecode [6]
with the help of dx [3].
We evaluate BSCOUT with real-world programs and
security patches. Though FIBER [46] is the most relevant
work to BSCOUT, it only targets C/C++ binaries and it is
non-trivial to make it support Java executables. Thus, we
can not use it as our baseline. Actually, to the best of our
knowledge, BSCOUT is the ﬁrst patch presence testing tool
on Java executables. Nevertheless, to illustrate the necessity
of designing a dedicated tool on patch presence test for Java
executables such as BSCOUT, we conduct experiments to
report how two closely-related techniques behave when used
on patch presence testing: version pinning and function-level
similarity. It is worth noting that these techniques do not
claim they are effective in patch presence testing. Here, we
just want to show that the problem of patch presence testing
could not be easily solved by applying existing techniques.
4.1 Results of BSCOUT
We perform experiments on two versions of BSCOUT to
measure its effectiveness:
• BSCOUT which utilizes line number information (if
present) in Java executables;
• BSCOUT(cid:52) which does not consider the line number
information in Java executables (even when it is present).
This setting helps us to know the effectiveness of BSCOUT
in the worst case (i.e. all line number information is stripped
away). The evaluation is performed with two representative
CVE datasets: Android framework vulnerabilities and Java
library vulnerabilities.
4.1.1 Android Framework Vulnerabilities
Considering the popularity of Android and its severe fragmen-
tation issues, we ﬁrst use Android framework vulnerabilities
to evaluate BSCOUT. In total, we randomly select 150 CVEs
from Android Security Bulletin [2], ranging from August
2015 to July 2019. The patches of these CVEs are all written
in Java. The affected Android versions of these CVEs are
listed in in Appendix A.
Parameter Setting. Before evaluation, we need to set
two parameters for BSCOUT: TLineSimilarity in equivalence
oracle (see §3.2) and TPatchPresenceRatio in Patch Presence
Checker (see §3.4). For TLineSimilarity, we favor a low value
because our line-level equivalence oracle is built on feature-
based similarity, which is more coarse-grained than real
semantic equivalence testing. TPatchPresenceRatio can make a
trade-off between false positive rate (FPR) and false negative
rate(FNR). In the patch presence test, we favor low FPR. To
set an appropriate value for them, we build a set of ROMs from
AOSP (Android Open Source Project) and label the patch
status for them as ground truth. Speciﬁcally, we build all tags
for all branches in AOSP and, ﬁnally, get 215 unique images.
We designate this dataset as Dataset_ROM_Reference. By
carefully tuning TLineSimilarity and TPatchPresenceRatio, we can
determine the best value of them under which BSCOUT
achieves the best performance on Dataset_ROM_Reference.
Finally, we set TLineSimilarity to 0.7 and TPatchPresenceRatio to 0.6.
Ground Truth. We download 15 Android ROMs from 6
vendors (marked as Dataset_ROM_GT) to measure BSCOUT.
For each ROM, we unpack it and collect its affected CVEs,
and manually validate the patch status for each CVE. To avoid
mistakes in manual labeling, all the results are veriﬁed by two
security experts. This dataset is presented in Table 2.
Results. According to the results in Table 3, the accuracy
for either BSCOUT or BSCOUT(cid:52) is quite high, even though
the test is performed directly from source code to bytecode
instructions. In particular, BSCOUT achieves a remarkable
accuracy of 100%. It clearly demonstrates that BSCOUT can
effectively recognize ﬁne-grained code changes at the test
target by leveraging code features from both the Java source
code layer and the Java bytecode layer. Besides, we note that
both BSCOUT and BSCOUT(cid:52) exhibit no false positives. Since
there is no false-negative case for BSCOUT, we manually
inspect the 31 false-negative cases reported by BSCOUT(cid:52),
and ﬁnd that all these cases result in some wrong mappings
between Java source code lines and smali instructions. After
inspecting these mappings, we ﬁnd they might be corrected
by enhancing current learning-based instruction segmentation
(see § 3.2.2) with the control ﬂow-level features, and we leave
it as our future work.
Efﬁciency of BSCOUT. We measure the test time of
BSCOUT on Dataset_ROM_GT with a Windows 10 64-bit
desktop computer (Intel i3-4170, 3.70GHz CPU and 12 GB
memory). We run the tests one by one and collect the time
cost in performing a patch presence test for each ROM-CVE
pair. The detailed time cost for each ROM is presented in
Table 2. Note that although a whole ROM contains millions of
functions, the patches only affect a small number of functions.
Thus, it is very fast for BSCOUT to locate the patch-related
functions and check patch presence on them. In general, the
average test time for each CVE is 0.18 seconds. Some CVEs
cost more time than the average because their patches change
very large methods which need more time to perform the
line-to-line match. In the same way, BSCOUT(cid:52) is measured
to have an average time cost of 13.9 seconds for each test.
4.1.2
Java Library Vulnerabilities
Since Java libraries are widely used to build applications for
Android devices, desktops, servers, etc., it is also important to
check whether they have patched known vulnerabilities. Thus,
USENIX Association
29th USENIX Security Symposium    1155
# of
# of
# of
Table 2: Manually-labeled Patch Presence Status for 15 Collected Android ROMs (Dataset_ROM_GT) and The Test Time for
These ROMs by BSCOUT.
Android
Version
Unpatched CVEs
Affected CVEs1
Patched CVEs
ROM Name
Test Time
Model
Google Pixel XL
Google Pixel
Google Pixel 2 XL
Xiaomi MAX 2
Xiaomi MAX
Xiaomi Redmi 5
Meizu MX5
Meizu PRO 6
Vivo X9
Vivo X20
Vivo NEXS
Oppo R11s Plus
Oppo R9s Plus
Oppo R11s
Samsung Note 9
1 Note that the number of affected CVEs may be different for ROMs with the same Android version, because vendors may remove some unwanted modules
marlin-njh47d-factory-5ba1ef
sailﬁsh-nzh54d-factory-127f0583
taimen-opm4.171019.021.r1-factory-dc
miui_MIMAX2_7.9.14_5b67c71517_7.1
miui_MIMAX_7.9.8_5d955edf66_7.0
miui_HM5_V10.3.3.0.ODACNXM_c9b6
MX5_6.3.0.0_cn_20180129144322
PRO_6_6.3.0.2_cn_20180327102019
PD1616_D_7.12.7-update-full
PD1709_A_1.16.8-update-full
PD1805_A.1.23.5-update-full_15501
R11sPlus_11_OTA_0170_all_GfK0Zhg
R9sPlus_11_OTA_0090_all_2DQUWSz
R11s_11_OTA_0380_all_Q5Zf0LQ9SM
LRA-N960U1UES1ARH6-20180922125
7.1.2
7.1.2
8.1.0
7.1.1
7.0.0
8.1.0
5.1.0
7.1.1
7.1.1
7.1.1
8.1.0
7.1.1
6.0.1
8.1.0
8.1.0
25
25
29
31
50
32
9
30
27
27
33
33
62
34
27
7
8
13
15
33
32
7
13
12
17
24
24
49
26