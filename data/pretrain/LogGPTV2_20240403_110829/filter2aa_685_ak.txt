 The Server type holds information that’s directly related to the server, such as the
server socket and the clients that have connected to it. Similarly, the Client type rep-
resents a single client that connected to the server, and it includes fields that provide
useful information about each client. For example, the netAddr field will contain the
IP address of the client, and the id field will hold a generated identity for each client,
Listing 3.13
Standard library imports and type definitions
Imports the asyncdispatch and asyncnet 
modules, which contain the procedures and 
types needed to use asynchronous sockets
Starts a
new type
section
Defines the Client type as a reference type
Specifies the socket belonging to the client; the 
AsyncSocket type is an asynchronous socket
The field that stores the address from 
which this client has connected
A flag that determines whether 
this client is still connected
The identification 
number of this client
Defines the Server type 
as a reference type
The server socket for accepting 
new client connections
A list of Client objects 
that have connected
Licensed to   
81
Transferring data using sockets
allowing you to distinguish between them. The connected flag is important because it
tracks whether the client is still connected. The server needs to know this, because it
shouldn’t attempt to send messages to a disconnected client.
 All that’s left now is to create a constructor for the newly defined Server type.
 For a ref type, such as the Server type, the procedure should be named newServer:
proc newServer(): Server = Server(socket: newAsyncSocket(), clients: @[])
This will create a new instance of the Server type and initialize its socket and clients
sequence. You can now call this procedure and assign it to a new server variable.
var server = newServer()
Constructors in Nim
Constructors in Nim are simply procedures with a specific naming convention. Nim
doesn’t include any special syntax for defining constructors, but it does include some
simple syntax for constructing your custom types, which you may recall from chapter 2.
Tuples can be constructed by placing values in parentheses:
type
Point = tuple[x, y: int]
var point = (5, 10)
var point2 = (x: 5, y: 10)
Objects, including ref objects, can be constructed by calling the type—as if it were
a procedure—and then specifying each field name and value separated by a colon:
type
Human = object
name: string
age: int
var jeff = Human(name: "Jeff", age: 23)
var alex = Human(name: "Alex", age: 20)
There’s no way to override these, so if you need more-complex constructors, you’ll
need to define a procedure. There’s a convention in Nim for naming these constructor
procedures; this table shows these conventions and how they apply to different type
definitions.
Constructor naming conventions
Type definition
Name
MyType = object
initMyType
MyTypeRef = ref object
newMyTypeRef
MyTuple = tuple[x, y: int]
initMyTuple
Licensed to   
82
CHAPTER 3
Writing a chat application
Add the newServer procedure and server variable definitions below the types created
in listing 3.13. The resulting code gives you a good base to begin adding the network-
ing code to.
 But before we get into that, let’s look at how networking, particularly asynchro-
nous networking, works in Nim. We’ll begin by looking at the basic tool used to trans-
fer data over a network: a socket.
3.5.1
What is a socket?
In almost every programming language, transferring data over a network is done
using network sockets. In Nim, a network socket is represented using the Socket type.
This type is defined in the net module, and a new instance of it can be created using
the newSocket procedure.
 Sockets share some similarities with file descriptors in that they support operations
such as write, read, open, and close. But in practice, sockets differ enough to expose
a different interface. Table 3.1 shows some of the common socket procedures and
their file descriptor equivalents.
Sockets can be customized a great deal by specifying different options in the new-
Socket constructor. By default, the newSocket constructor will create a TCP socket,
which is handy because TCP is the protocol that the chat application will use.
 TCP is a connection-oriented transport protocol that allows the socket to be used
as a server or as a client. A newly created TCP socket is neither until the bindAddr or
connect procedure is called. The former transforms it into a server socket, and the lat-
ter a client socket. We’ll create a server socket first, as that’s what is needed for the
server component of this application.
 A server socket’s main purpose is to listen for new connections and accept them
with as little delay as possible. But before this can be done, the socket must first be
bound to an address and port. Figure 3.13 shows the procedures that need to be
called to successfully create and bind a server socket.
Table 3.1
Common socket procedures
Procedure
File equivalent
Description
recv
read
Allows incoming data to be read from the remote side. For TCP 
sockets, recv is used, and for UDP sockets, recvFrom is used.
send
write
Sends data to a socket, allowing data to be sent to the remote 
side. For TCP sockets, send is used, and for UDP sockets, 
sendTo is used.
connect
open
Connects a socket to a remote server. This is typically only used 
for TCP sockets.
bindAddr
None
Binds a socket to the specified address and port. When called, 
the socket becomes a server socket, and other sockets can con-
nect to it. This is typically only used for TCP sockets.
Licensed to   
83
Transferring data using sockets
First, every server socket needs to be explicitly bound to a specific port and address.
This can be done using the bindAddr procedure, which takes a port as the first argu-
ment and an address as the second. By default, the address is simply localhost, but
the port must always be specified. You can specify whatever port you wish, but there
are some ports that are often used by other applications, such as port 80, which is used
by HTTP servers. Also, binding to a port less than or equal to 1024 requires administra-
tor privileges.
 Second, before the socket can start accepting connections, you must call the listen
procedure on it. The listen procedure tells the socket to start listening for incoming
connections.
 New connections can then be accepted by using the accept procedure. This proce-
dure returns a new client socket, which corresponds to the socket that just connected
to the address and port specified in the call to bindAddr.
DETAILS ABOUT SOCKETS
Don’t worry about remembering all the details in
this section. Use it as a reference together with the next sections, which will
show you how to put this knowledge into practice.
Much like reading data from the standard input, the accept procedure blocks your
application until a new connection is made. This is a problem, but one that’s easy to
solve thanks to Nim’s support for asynchronous sockets. Asynchronous sockets don’t
block and can be used instead of synchronous sockets without much trouble. They’re
defined in the asyncnet module, and I’ll explain how they work in the next section. 
3.5.2
Asynchronous input/output
Nim supports many abstractions that make working with asynchronous I/O simple.
This is achieved in part by making asynchronous I/O very similar to synchronous I/O,
so your I/O code doesn’t need to be particularly complex.
Server socket 
bindAddr
listen
accept
Client socket
7687.Port
"localhost"
Thread
blocked  
Figure 3.13
The steps needed to 
start accepting new connections 
on a server socket
Licensed to   
84
CHAPTER 3
Writing a chat application
 Let’s first look at the accept procedure in more detail. This procedure takes one
parameter, a server socket, which is used to retrieve new clients that have connected to
the specified server socket.
 The fundamental difference between the synchronous and asynchronous versions
of the accept procedure is that the synchronous accept procedure blocks the thread
it’s called in until a new socket has connected to the server socket, whereas the asyn-
chronous accept procedure returns immediately after it’s called.
 But what does the asynchronous version return? It certainly can’t return the
accepted socket immediately, because a new client may not have connected yet.
Instead, it returns a Future[AsyncSocket] object. To understand asynchronous I/O,
you’ll need to understand what a future is, so let’s look at it in more detail.
THE FUTURE TYPE
A Future is a special type that goes by many names in other languages, including prom-
ise, delay, and deferred. This type acts as a proxy for a result that’s initially unknown, usu-
ally because the computation of its value is not yet complete.
 You can think of a future as a container; initially it’s empty, and while it remains
empty you can’t retrieve its value. At some unknown point in time, something is
placed in the container and it’s no longer empty. That’s where the name future comes
from.
 Every asynchronous operation in Nim returns a Future[T] object, where the T cor-
responds to the type of value that the Future promises to store in the future.
 The Future[T] type is defined in the asyncdispatch module, and you can easily
experiment with it without involving any asynchronous I/O operations. The next list-
ing shows the behavior of a simple Future[int] object.
import asyncdispatch
var future = newFuture[int]()
doAssert(not future.finished)
future.callback =
proc (future: Future[int]) =
echo("Future is no longer empty, ", future.read)
future.complete(42)
Listing 3.14
Simple Future[int] example
The asyncdispatch module 
needs to be imported because 
it defines the Future[T] type.
A new future can be 
initialized with the 
newFuture constructor.
A future starts out empty; when a future isn’t 
empty, the finished procedure will return true.
The callback is given the future 
whose value was set as a parameter.
A callback can be set, and it will be 
called when the future’s value is set.
The read procedure is used to
retrieve the value of the future.
A future’s value can be set by 
calling the complete procedure.
Licensed to   
85
Transferring data using sockets
Futures can also store an exception in case the computation of the value fails. Calling
read on a Future that contains an exception will result in an error.
 To demonstrate the effects of this, modify the last line of listing 3.14 to
future.fail(newException(ValueError, "The future failed")). Then compile
and run it.
 The application should crash with the following output:
Traceback (most recent call last)
system.nim(2510)
ch3_futures
asyncdispatch.nim(242)
fail
asyncdispatch.nim(267)
:anonymous
ch3_futures.nim(8)
:anonymous
asyncdispatch.nim(289)
read
Error: unhandled exception: The future failed
unspecified's lead up to read of failed Future:
Traceback (most recent call last)
system.nim(2510)
ch3_futures
asyncdispatch.nim(240)
fail [Exception]
As you can see, the error message attempts to include as much information as possi-
ble. But the way it’s presented isn’t ideal. The error messages produced by futures are
still being worked on and should improve with time. It’s a good idea to get to know
what they look like currently, as you’ll undoubtedly see them when writing asynchro-
nous applications in Nim.
 The preceding exception is caused by calling read on a future that had an excep-
tion stored inside it. To prevent that from occurring, you can use the failed proce-
dure, which returns a Boolean that indicates whether the future completed with an
exception.
 One important thing to keep in mind when working with futures is that unless
they’re explicitly read, any exceptions that they store may silently disappear when the
future is deallocated. As such, it’s important not to discard futures but to instead use
the asyncCheck procedure to ensure that any exceptions are reraised in your program. 
THE DIFFERENCE BETWEEN SYNCHRONOUS AND ASYNCHRONOUS EXECUTION
Hopefully, by now you understand how futures work. Let’s go back to learning a little
bit more about asynchronous execution in the context of the accept procedure. Fig-
ure 3.14 shows the difference between calling the synchronous version of accept and
the asynchronous version.
 As mentioned earlier, the asynchronous accept returns a Future object immedi-
ately, whereas the synchronous accept blocks the current thread. While the thread is
blocked in the synchronous version, it’s idle and performs no useful computational
work. The asynchronous version, on the other hand, can perform computational
work as long as this work doesn’t require the client socket. It may involve client sockets
that have connected previously, or it may involve calculating the 1025th decimal digit
of π. In figure 3.14, this work is masked beneath a doWork procedure, which could be
doing any of the tasks mentioned.
unspecified is the name of the 
Future. It’s called unspecified 
because the future is created with 
no name. You can name futures 
for better debugging by specifying 
a string in the newFuture 
constructor.
Licensed to   
86
CHAPTER 3
Writing a chat application
The asynchronous version performs many more calls to doWork() than the synchro-
nous version. It also retains the call to doWork(socket), leading to the same code
logic but very different performance characteristics.
 It’s important to note that the asynchronous execution described in figure 3.14 has
a problem. It demonstrates what’s known as busy waiting, which is repeatedly checking
whether the Future is empty or not. This technique is very inefficient because CPU
time is wasted on a useless activity.
 To solve this, each Future stores a callback that can be overridden with a custom
procedure. Whenever a Future is completed with a value or an exception, its callback
is called. Using a callback in this case would prevent the busy waiting. 
EXAMPLE OF ASYNCHRONOUS I/O USING CALLBACKS
The term callback provokes a feeling of horror in some people. But not to worry. You
won’t be forced to use callbacks in Nim. Although the most basic notification mecha-
nism Futures expose is a callback, Nim provides what’s known as async await, which
hides these callbacks from you. You’ll learn more about async await later.
 But although you’re not forced to use callbacks in Nim, I’ll first explain asynchro-
nous I/O by showing you how it works with callbacks. That’s because you’re likely
more familiar with callbacks than with async await. Let’s start with a comparison
between Node and Nim, and not a comparison involving sockets but something much
simpler: the reading of a file asynchronously.
var fs = require('fs');
fs.readFile('/etc/passwd', function (err, data) {
if (err) throw err;
console.log(data);
});
Listing 3.15
Reading files asynchronously in Node
Server socket 
accept
Client socket
Thread
blocked  
Synchronous
Server socket 
accept
Future
Future empty? 
true
false
Future.read
doWork(socket)
doWork()
Asynchronous
doWork()
doWork(socket)
Client socket
Figure 3.14
The difference between synchronous and asynchronous accept
Licensed to   
87
Transferring data using sockets
The code in the preceding listing is taken straight from Node’s documentation.2 It
simply reads the contents of the /etc/passwd file asynchronously. When this script is
executed, the readFile function tells the Node runtime to read the file specified by
the path in the first argument, and once it’s finished doing so, to call the function
specified in the second argument. The readFile function itself returns immediately,
and control is given back implicitly to the Node runtime.
 Now compare it to the Nim version.
import asyncdispatch, asyncfile
var file = openAsync("/etc/passwd")
let dataFut = file.readAll()
dataFut.callback =
proc (future: Future[string]) =
echo(future.read())
asyncdispatch.runForever()
The Nim version may seem more complex at first, but that’s because Nim’s standard
library doesn’t define a single readFile procedure, whereas Node’s standard library
does. Instead, you must first open the file using the openAsync procedure to get an
AsyncFile object, and then you can read data from that object.3
 Other than that difference in standard library APIs, the Nim version also differs in
one more important way: the readAll procedure doesn’t accept a callback. Instead, it
returns a new instance of the Future type. The callback is then stored in the Future
and is called once the future completes. 
THE EVENT LOOP
In a Node application, the runtime is a form of event loop—it uses native operating
system APIs to check for various events. One of these might be a file being successfully
read or a socket receiving data from the server that it’s connected to. The runtime dis-
patches these events to the appropriate callbacks.
 Nim’s event loop is defined in the asyncdispatch module. It’s similar to Node’s
runtime in many ways, except that it needs to be explicitly executed. One way to do
this is to call the runForever procedure. Figure 3.15 shows the behavior of the run-
Forever procedure.
2 See the Node.js fs.readFile documentation: https://nodejs.org/api/fs.html#fs_fs_readfile_file_options_
callback.
Listing 3.16
Reading files asynchronously in Nim
3 Creating a single readFile procedure would be a fairly trivial undertaking. I leave the challenge of creating
such a procedure to you.
Opens the "/etc/passwd" file 
asynchronously and binds it 
to the file variable
Asks for all of the contents of the file to be 
read, and assigns the resulting Future[string] 
type to the dataFut variable
Assigns a new callback to be called 
when the future completes
Inside the callback, reads the 
contents of the future that 
should now be present
Explicitly runs the event loop that’s 
defined in the asyncdispatch module
Licensed to   
88
CHAPTER 3
Writing a chat application
The Nim event loop puts you in control. The runForever procedure is simply a wrap-
per around the poll procedure, which the runForever procedure calls in an infinite
loop. You can call the poll procedure yourself, which will give you greater control
over the event loop. The poll procedure waits for events for a specified number of
milliseconds (500 ms by default), but it doesn’t always take 500 ms to finish because
events can occur much earlier than that. Once an event is created, the poll proce-
dure processes it and checks each of the currently pending Future objects to see if the
Future is waiting on that event. If it is, the Future’s callback is called, and any appro-
priate values that are stored inside the future are populated.
 In contrast to synchronous I/O, which can block for an unlimited amount of time,
the poll procedure also blocks, but only for a finite amount of time, which can be
freely specified. This allows you to commit a certain amount of time to I/O processing
and the rest to other tasks, such as drawing a GUI or performing a CPU-intensive calcu-
lation. I’ll show you how to utilize this procedure later in the client module, so that
async sockets can be mixed with the readLine procedure that reads the standard
input stream in another thread. 
ASYNC AWAIT
There’s a big problem with using callbacks for asynchronous I/O: for complex appli-
cation logic, they’re not flexible, leading to what’s aptly named callback hell. For exam-
ple, suppose you want to read another file after a first one has been read. To do so,
you’re forced to nest callbacks, and you end up with code that becomes ugly and
unmaintainable.
 Nim has a solution to this problem: the await keyword. It eliminates callback hell
completely and makes asynchronous code almost identical to synchronous code.
 The await keyword can only be used inside procedures marked with the {.async.}
pragma. The next listing shows how to read and write files using an async procedure.
runForever
poll
Read/write event 
Future.callback()
500 ms
asyncdispatch event loop
Blocked for
up to
500 ms
No events 
Figure 3.15
Nim’s asyncdispatch 
event loop
Licensed to   
89
Transferring data using sockets