/V至V。不需要求路径·/
1·开始主播环，每次求得v到某个v顶点的最短路径·/
13
for（v-1;v→V8
264
---
## Page 289
第7章图
图 7-7-11
其实最终返回的数组D和数组P，是可以得到vo到任意一个顶点的最短路径和路
径长度的。例如vo到v的最短路径并没有经过Vs，但我们已经知道v到vs的最短路
径了。由D[5]=8可知它的路径长度为8，由P[5]=4可知vs的前驱顶点是v4，所以vo
到vs的最短路径是vo→V1→V2→V4→Vs。
也就是说，我们通过迪杰斯特拉（Dijkstra）算法解决了从某个源点到其余各顶点
的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为0（n²)，尽管有
同学觉得，可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求
源点到其他所有顶点的最短路径一样复杂，时间复杂度依然是0(n²)。
这就好比，你吃了七个包子终于算是吃饱了，就感觉很不划算，前六个包子白吃
了，应该直接吃第七个包子，于是你就去寻找可以吃一个就能饱肚子的包子，能够满
足你的要求最终结果只能有一个，那就是用七个包子的面粉和馅做的一个大包子。这
种只关注结果而忽略过程的思想是非常不可取的。
可如果我们还需要知道如V到Vs、V到v这样的任一顶点到其余所有顶点的最
（Dijkstra）算法，等于在原有算法的基础上，再来一次循环，此时整个算法的时间复
杂度就成了0（n）。
对此，我们现在再来介绍另一个求最短路径的算法一一弗洛伊德（Foyd），它求
所有顶点到所有顶点的时间复杂度也是0（n3]，但其算法非常简洁优雅，能让人感觉
到智慧的无限魅力。好了，让我们就一同来欣赏和学习它吧。13
7.7.2弗洛伊德（Floyd）算法
为了能讲明白弗洛伊德（Floyd）算法的精妙所在，我们先来看最简单的案例。图
7-7-12的左图是一个最简单的3个顶点连通网图。
注：关子该算法详细讲解，请参考（算法导论）累六部分图翼法的242节。
265
---
## Page 290
大调数据结
[zllo],a+o1],az1l.a
0
5
2
1
D_
2
0
0
|1
3
10
所以D[1[2]D[1[0]+D[0][2}
0
0
1
01
2
0
0
2
所以P-1[1][2]P-[1][0]-
图7-7-12
我们先定义两个二维数组D[3][3]和P[3][3]，D代表顶点到顶点的最短路径权值和
的矩阵。P代表对应顶点的最小路径的前驱矩阵。在未分析任何顶点之前，我们将D
命名为D1，其实它就是初始的图的邻接矩阵。将P命名为P1，初始化为图中所示的
矩阵。
首先我们来分析，所有的顶点经过V后到达另一顶点的最短路径。因为只有三个
顶点，因此需要查看V→Vo→V2，得到D-1[1][0]+D-1[0][2]=2+1=3。D-1[1][2]表示的
是v1→v2的权值为5，我们发现D-1[1][2]>D1[1][0]+D-1[0][2]，通俗的话讲就是v1
→Vo→V2比直接V1→V2距离还要近。所以我们就让D-1[1][2]=D-1[1][0]+D-1
[0][2]=3，同样的D-1[2][1]=3，于是就有了D的矩阵。因为有变化，所以P矩阵对
应的P-1[1][2]和P-[2][1]也修改为当前中转的顶点ve的下标0，于是就有了P。也就
是说
D°[v][w]=min{D[M][w],D[M1o]+D[0][w]}
接下来，其实也就是在D和P的基础上继续处理所有顶点经过v和v2后到达另
一顶点的最短路径，得到D和P1、D2和P完成所有顶点到所有顶点的最短路径计算
工作。
如果我就用这么简单的图形来讲解代码，大家一定会觉得不能说明什么问题。所
以我们还是以前面的复杂网图为例，来讲解弗洛伊德（Floyd）算法。
首先我们针对图7-7-13的左网图准备两个矩阵D1和P-1，D-1就是网图的邻接矩
阵，P1初设为P[]U]=这样的矩阵，它主要用来存储路径。
266
---
## Page 291
第7章图
0
2
5
2
0
图7-7-13
代码如下，注意因为是求所有顶点到所有顶点的最短路径，因此Pathmatirx和
ShortPathTable都是二维数组。
typedefintPathmatirx[MAxVEX][MAxVEX];
typedefint ShortPathTable[MAxVEx)[MAxVEX];
/·Floyd算法，求网图G中各顶点v到其余项点w最短路径P[v][w]及带权长度D[v][w]*/
1void ShortestPath_Floyd（MGraph G,Pathmatirx *P,ShortPathTable *D)
2
3
intv,,k;
4
for（v=0;v<G.numVertexes;++v）
初始化D与P/
5
1
6
for（w=0;w<G.numVertexes;++）
7
8
（*D）[v][w]=G.matirx[v][w];
1D[V][w]值即为对应点间的权值/
9
（P）[v][W]-W;
/初始化P/
10
11
12
for（k-0;k<G.numVertexes;++k）
13
14
for（v=0;v<G.numVertexes;++v）
15
267
---
## Page 292
大语数据结构
16