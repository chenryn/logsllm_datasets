has an ALLOW READ setting for a ﬁle, but inherits a DENY
READ setting for that ﬁle, the user will be denied access to
read the ﬁle. Group inheritance and precedence rules lead to
the distinction between stated permissions, the permissions
contained in a user’s access control entry, and effective per-
missions, the actual access a user will be allowed.
The distinction between stated permissions and effec-
tive permissions can make setting ﬁle permissions a difﬁ-
cult task, because the low-level permission values on which
a user operates do not necessarily translate directly into
what access will be allowed to system data. Actual access
in NTFS is determined by a subtle formula accompanying
the precedence rules. However, users setting ﬁle permis-
sions are ultimately concerned with who can access what,
not with low-level values and nuanced formulas. Thus the
necessary information for users to evaluate goal status is
the effective permissions, which are the output of the nu-
anced formula, and which reﬂect the actual access that will
be granted to ﬁles.
Casual observation of the XPFP interface (see Figure
1) reveals that XPFP provides a poor external representa-
tion of the ﬁle-permissions task. For example, the XPFP
main window contains the checkboxes necessary for setting
the permission values that will be used to determine effec-
tive permissions, but effective permissions themselves are
nowhere to be seen.
In fact, XPFP can display effective
permissions, but they are two screens away. To see them,
users must click the Advanced button, then select an “Effec-
tive Permissions” tab. Even then, users must go through an
extra step to choose whose effective permissions they want
to see; viewing multiple entities’ effective permissions si-
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:08:40 UTC from IEEE Xplore.  Restrictions apply. 
multaneously is impossible. When users return to changing
permission values, the effective-permissions display disap-
pears. Users need to know the effective permissions to
check their work. Without an effective-permissions display
readily available, or even a cue to indicate their importance,
users are forced not only to maintain in their minds the in-
heritance and precedence rules, but also to compute the ef-
fective permissions mentally.
Figure 1: The XPFP interface. The interface contains in-
formation and functionality for setting permission values,
but effective permissions, group-inherited permissions, and
ADMINISTRATE permissions are not visible.
Besides the lack of an accessible effective-permissions
display, XPFP also hides the ADMINISTRATE permission
setting two screens away from the main window, behind the
Advanced button, and does not display information about
users’ group membership or their group-inherited permis-
sions anywhere. This makes it difﬁcult to track down the
source of an effective permission that was inherited from
a group. Furthermore, users must maintain group mem-
bership and permission settings information in their heads
while completing tasks – a situation that begs for error.
5 Anchor-based subgoaling
Anchor-based subgoaling (ABS) is a principle for ensur-
ing that a user interface provides all the information a user
will need to complete the tasks for which the interface is
intended, and provides such information in a clear and ac-
curate display that the user will notice. The XPFP interface
illustrates the problem of omitting or obscuring necessary
task information, the problem addressed by ABS.
5.1 Cognitive theory
Anchor-based subgoaling is rooted in the cognitive the-
ory of Pocock et al.’s Technique for Human Error Assess-
ment (THEA) [14], which is in turn based on Norman’s
well-known seven-stage execution-evaluation model of hu-
man information processing [13]. THEA condenses Nor-
man’s seven stages down to four stages of information pro-
cessing during which human error can occur. These four
stages are the combination of perception, interpretation, and
evaluation; goal formulation; plan formulation; and action
execution. According to the Norman/THEA models, human
information processing starts with a problem – the root goal
– and proceeds in the following loop:
1. Perceive and interpret information from the environ-
ment, and evaluate whether the problem is solved;
2. If the problem remains unsolved: formulate a subgoal,
according to perceived information, for solving all or
part of the problem. If problem is solved: exit loop;
3. Formulate a plan to achieve the subgoal;
4. Execute the actions in the plan.
Goal errors occur when the second step goes wrong. If
the perceived information consulted in the second step is in-
correct or misinterpreted, the wrong subgoal may be set. If
the wrong information is used to check whether the prob-
lem has been solved in the second step, either an unnec-
essary subgoal may be added (if the problem is assumed
unsolved when it is already solved) or a necessary subgoal
may be omitted (if the problem is assumed solved when it is
not). Thus the availability of information to check progress
toward the root goal is critical during correct subgoal se-
lection. If the salient information suggests an inappropriate
subgoal selection, then goal errors are likely to result.
The potential for goal errors can be seen in the XPFP in-
terface. Since effective permissions are hidden, most users
will not ﬁnd them, and will determine problem completion
based on either wrong, but visible, information in the in-
terface, or on their own error-prone mental computations.
Hidden group information may result in users not knowing
when a group permission is being inherited. Since the AD-
MINISTRATE permission is hidden, users may never realize
it exists. Lacking this information, users are prone to mak-
ing goal errors.
5.2 Anchor-based subgoaling design procedure
Anchor-based subgoaling bridges the gap between task
analysis and the creation of an external representation dur-
ing the interface design process. The ABS procedure en-
sures that the necessary information is represented. A care-
ful task analysis is a prerequisite for implementing ABS;
Kirwan [8] is an excellent reference on how to perform task
analyses. Kirwan describes the hierarchical task analysis
(HTA) method, which includes a convenient representation
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:08:40 UTC from IEEE Xplore.  Restrictions apply. 
for the results of a formal task analysis. An HTA represents
a task as a hierarchy of goals and the operations that are
needed to achieve them. At the root of an HTA hierarchy
is a primary goal to be accomplished. Beneath the root are
nodes that represent the subgoals necessary to achieve the
primary goal; each subgoal may have a tree of subgoals be-
neath it. At the leaves of the hierarchy are the actionable op-
erations necessary to achieve each of the lowest-level sub-
goals. A detailed example appears in Section 7.1.
After the task analysis is completed, the ABS design pro-
cedure can begin. It proceeds as follows:
• Phase 1: Identify the information that is required.
1. For each goal, starting with the primary goal
and proceeding through all subgoals in the HTA,
identify the information a user will need to:
(a) determine when the goal has been com-
pleted;
(b) set the subgoals beneath the goal.
2. For each operation at the leaves of the HTA, de-
termine what information will be needed to exe-
cute the operation. This is usually:
(a) procedural knowledge – information about
how to execute the operation;
will have to be supplied to the operation.
(b) declarative knowledge – any parameters that
• Phase 2: Provide the information in the interface. In-
corporate into the interface design an accurate, clear,
and salient representation of the necessary informa-
tion, as determined by the above steps. 3
5.3 Salmon interface
The Salmon interface (see Figure 2) was designed in ac-
cordance with anchor-based subgoaling. Anchor-based sub-
goaling identiﬁed the following information as necessary
for establishing the correct subgoals and executing the cor-
rect operations in a ﬁle-permissions interface:
1. The full list of 13 atomic permissions;
2. Stated permissions for all users & groups on the ACL;
3. Group membership data, and how it combines to a
user’s effective permissions;
4. Effective permissions for all users on the ACL.
The Salmon interface was designed to provide this in-
formation. Its main window comprises two panes. In the
upper pane are the checkboxes necessary for setting permis-
sion values. Each column of checkboxes has a label corre-
sponding to one of the 13 atomic permissions. These check-
boxes show the stated permissions.
In the lower pane is
3External representation design is a large topic and is not covered in de-
tail here; see Card et al. [4] or Woods and Roth [22] for more information
on this subject.
Figure 2: The Salmon interface. The upper pane of the
Salmon interface contains the same information and func-
tionality that is contained in the XPFP main window. The
lower pane contains an effective-permissions display.
an effective-permissions display that shows both the effec-
tive permissions and the group and individual permissions
that combine to the effective permissions. The effective-
permissions display is available at all times. When changes
are made in the upper pane, they are reﬂected in the lower
pane, and attention is drawn to the lower pane by highlight-
ing the areas that have changed. While effective permis-
sions for all users cannot be viewed on screen at the same
time, Salmon’s lower pane can be scrolled to access infor-
mation that does not ﬁt on the screen. The necessary infor-
mation is readily available in the Salmon interface, and can
be viewed as it is needed.
6 Methodology
A laboratory user study was conducted to observe and
document errors in permission-setting tasks. Two interfaces
were compared: XPFP, which lacks salient representations
of task-relevant information, and Salmon, which was de-
signed using the anchor-based subgoaling design procedure.
6.1 Participants
Twenty-four students and research staff at Carnegie Mel-
lon University voluntarily participated in the study. All par-
ticipants’ academic backgrounds were in science and en-
gineering disciplines, and all were daily computer users.
While a few usually used UNIX-based computer systems
in their daily work, all had at least some experience using
Windows, with 21 out of 24 claiming they used Windows
at least a few times a week. Nineteen reported having some
experience setting ﬁle permissions on Windows or another
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:08:40 UTC from IEEE Xplore.  Restrictions apply. 
operating system, while 5 reported having no experience
whatsoever in setting ﬁle permissions. All but 4 reported
setting ﬁle permissions a few times a month or less. Thus,
the participant pool was consistent with the assumption of
occasional users, who are likely to have to relearn the task,
at least partially, due to infrequent use of the interface.
6.2 Apparatus
All participants worked on the same computer, a system
running Windows XP, Version 2002, Service Pack 1. Using
a standard think-aloud experimental paradigm [6], partici-
pants were asked to think aloud as they worked, while their
voice was recorded. Screen video and mouse and keyboard
actions were recorded with a software tool developed for
user study data collection. Participants’ ﬁnal permissions
settings were saved after each task instance.
6.3 Task design
To simulate real permission-setting conditions, a hy-
pothetical scenario was designed in which the participant
worked in a generic “organization,” shared a computer with
other workers in the organization, and had to restrict access
to the ﬁles and folders on her computer. The hypothetical
organization’s computer environment – populated with in-
dividual users, groups containing users, ﬁles, and folders –
was created on the laboratory Windows XP machine. The
environment included 27 individual users, named for each
letter of the alphabet (ari, bill, catherine, dave, evelyn, etc.)
plus one user named ’tux’, which was to represent the par-
ticipant. The environment also included 6 groups named
ProjectA through ProjectF, each of which contained 6 mem-
bers drawn from the 27 users. No group contained another
group as a member. There were also ﬁles and folders on
which participants were to set permissions.
Participants were randomly assigned to one of the two
interfaces, Salmon or XPFP, and were each given seven
tasks to perform with the same interface. The ﬁrst of the
tasks was a simple training task to give participants a quick
introduction to the interface they were using. All partic-
ipants performed this task ﬁrst, and it was excluded from
analysis. The remaining 6 tasks consisted of a variety of
existing-permissions contexts, only two of which, called the
Wesley and Jack tasks, are discussed here. These two tasks
involved group inheritance, a feature of the NTFS permis-
sions model that is especially error-prone. Four tasks were
excluded from analysis: one had ﬂawed instructions; two
were too easy, providing no discrimination between inter-
faces; and one was not analyzed due to time constraints.
The Wesley and Jack tasks required participants to set
permissions on a text ﬁle so that the entities “Wesley” or
“Jack” could read the ﬁle, but could not change it. The task
statement presented to participants for each task was identi-
cal except for the names of speciﬁc ﬁles, users, and groups.
The task statement for the Wesley task read as follows:
The group ProjectF is working on projectF-
data.txt, so everyone in ProjectF can read, write,
or delete it. Wesley (username: wesley) has
just been reassigned to another project and must
not be allowed to change the ﬁle’s contents, but
should be allowed to read it. Make sure that ef-
fective now, Wesley can read the ﬁle projectF-
data.txt, but in no way change its contents.
The difference between the Wesley and Jack tasks was
the way in which permissions were initially set up. In each
task, there was one group (ProjectF or ProjectE, for the
Wesley and Jack tasks, respectively) that was already on the
access control list (ACL) for the ﬁle, and the operative in-