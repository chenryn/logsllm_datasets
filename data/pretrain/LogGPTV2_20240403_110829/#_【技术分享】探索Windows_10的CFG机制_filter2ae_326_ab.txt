b)
用来写私有的bits和读取校验间接调用的bits。通过这个映射写入的bits是私有的，意味着它只能被当前进程读取。这个映射的生存周期与进程的生命周期相同。这个映射发生子MiCfgInitializeProcess中，调用堆栈如下：
图12 – 调用堆栈
基于调用堆栈，我们知道它在一个正在初始化的进程中被映射。Build
10.0.9926和6.4.9841的映射大小是不一样的。对于6.4.9841，大小是基于用户模式空间大小计算的。表达式为size=User Mode
Sapce
Size>>6(>>X：右移X位)。对于10.0.9926，这个大小是0x3000000。映射的空间在进程生命周期内总是存在的。映射的基址和长度将被保存在类型为MI_CFG_BITMAP_INFO的结构体中，且地址被修改了（在6.4.9841中，基址是0xC0802144。在10.0.9926中，是0xC080214C）。我稍后将讨论怎么将私有的bits写入映射空间中。MI_CFG_BITMAP_INFO的结构如下：
4\. 一旦PE映像的RVA列表准备好了且CFGBitmap节也映射了，就可以将RVA列表翻译为CFGBitmap中的bits。
图13 – 更新CFGBitmap的bits
在几种不同的场景下这个过程不太一样：
在ReloadImage/ReloadImageAgain，通过 MiUpdateCfgSystemWideBitmap写入共享模块（如dll）的bits
在进程初始化阶段写入私有模块（如exe）的bits
写入VM（虚拟内存）操作的bits
写入映像和数据段的映射的bits
在深入每个场景之前，我们需要搞清楚一些背景信息。在每个进程中，包含CFGBitmap的空间被分为两部分：共享和私有。
MiCfgBitMapSection是一个共享内存对象，包含了CFGBitmap的共享的bitmap的内容。它与每个进程共享。当它在自己的虚拟内存空间中映射MiCfgBitMapSection时，每个进程看见的内容都相同。共享模块（dll等）的bitmap信息将通过3.a节描述的映射方法写入。
然而每个进程需要CFGBitmap的一部分不是被所有进程共享的。它需要私有写入一些模块的bitmap信息到CFGBitmap中。这个私有的部分将不和所有的进程共享。EXE模块的bitmap信息使用3.b节描述的方法写入。下图描述了一个通用的场景。
图14 – 在MiCfgBitMapSection中的共享部分的bitmap内容的3中过程和他们的私有节
a)
在ReloadImage/ReloadImageAgain中，通过MiUpdateCfgSystemWideBitmap写入共享模块（dll等）的bits。
如第2节所见，在得到压缩的函数的RVA列表并将它保存到Control_Area结构后(在build6.4.9841中: _Control_Area
->SeImageStub->[+4]->[+24h];在build10.0.9926中: _Control_Area
->SeImageStub->[+0]->[+24h])，它将调用MiSelectImageBase。这个函数是ASLR实现的核心。它返回最终选择的基址。选择的基地址对于写bit信息到CFGBitmap中非常重要。在得到基地址后，它将调用MiUpdateCfgSystemWideBitmap。
MiUpdateCfgSystemWideBitmap的主要任务是将压缩的RVA列表翻译为CFGBitmap中的“1”bit。通过这个函数写入的bitmap信息是共享的，且被操作系统所有的进程共享。这个函数只针对共享模块有效（dll文件等）。
MiUpdateCfgSystemWideBitmap有3个参数：
指向Control_Area结构的指针
映像的基址
指向压缩的RVA列表的指针
MiUpdateCfgSystemWideBitmap的主要逻辑如下：
图15 – MiUpdateCfgSystemWideBitmap的主要逻辑
在步骤B中，它映射CFGBitmap共享内存到系统进程空间中。它不映射所有共享内存的全部大小。它转化映像的基址为CFGBitmap的偏移，且使用转化的结果作为映射的起始地址。转为过程如下：
Bitmap的偏移=基地址>>6。按这个公式，映射大小是映像大小右移6位。这个方法在映像需要重定位（ReloadImageAgain函数）的时候也会被使用。
b)
在进程初始化阶段写私有模块（exe文件等）的bits。它将调用MiCommitVadCfgBits，其是一个派遣函数。你能使用图13作为参考。它在确定的场景被调用。这个函数的前置工作是在VAD描述的空间写入bits。主要逻辑如下：
图16 – MiMarkPrivateImageCfgBits函数处理写入私有模块的bits
MiMarkPrivateImageCfgBits函数实现向CFG
Bitmap中写入私有模块（exe等）的bit信息。当系统映射一个EXE的节或者启动一个进程时，这个函数被调用。
这个函数有2个参数：
1) Cfg信息的全局变量地址
2) 映像空间的VAD
VAD是用来描述虚拟内存空间范围的一个结构。
函数的前置工作是将输入的VAD的相关的压缩的RVA列表转化为bitmap信息，且在CFGBitmap中写入bits。主要逻辑如下：
图17 – MiMarkPrivateImageCfgBits的主要逻辑
在步骤A中，压缩的RVA列表能从输入的VAD关联的Control_Area结构中获得，在MiRelocateImage中保存（参见第二节）。
这个函数的主要步骤是步骤C。它实现私有写入映射的MiCfgBitMapSection32节（在3.b节有描述）。写入的私有的bits的映射是只读的。向映射的空间写入bits怎么实现？关键步骤如下：
i. 获得映射的空间地址的物理地址（PFN）
ii.
申请一个空的页表入口（PTE）并使用上步获得的物理地址填充PTE，新的PTE被映射到相同的物理页，其包含了映射的MiCfgBitMapSection32的虚拟地址。
iii. 复制结果缓冲区（图12）到新的PTE。物理页将包含结果缓冲区的内容
iv. 释放新的PTE
在上面步骤完成后，bitmap信息被拷贝到当前进程地址空间内。但是不会影响MiCfgBitMapSection。换句话说，MiCfgBitMapSection不知道bitmap改变了。其他进程也不会看到改变；新添加的bitmap信息对当前进程是私有的。
c)
写虚拟内存操作的bits。如果一个进程有虚拟内存操作，它可能会影响CFGBitmap中的bitmap的bits状态。从图13的场景看，它将调用MiMarkPrivateImageCfgBits。函数的前置工作是复制“1”或“0”页到CFGBitmap空间中。
i. 对于NtAllocVirtualMemory函数
如果一个进程调用NtAllocVirtualMemory函数来分配具有可执行属性的虚拟内存，NT内核将设置CFGBitmap中相关的位为“1”。但是如果分配的内存的保护属性有
SEC_WRITECOMBINE，NT内核将使用“0”设置bitmap。
ii. 对于MiProtectVirtualMemory函数
如果一个进程调用MiProtectVirtualMemory来改变虚拟内存的保护属性为“可执行”，NT内核将设置CFGBitmap相关位为“1”。
d) 写映像和数据段映射的bits
i.
对于映像（dll，EXE等）节的映射，如果映像不是共享的，处理过长如4.b节描述。如果是共享的，将由图13中的MiMarkPrivateImageCfgBits函数处理。它遍历映射空间中的每个页且将页地址转化为CFGBitmap中的偏移。
i. 如果CFGBitmap中的偏移不被PrototypePTE支持，相关的bits信息将被拷贝到CFGBitmap空间中。
ii. 如果CFGBitmap中的偏移已经有bitmap信息，CFGBitmap部分将改为只读。
ii. 对于数据段的映射，处理与4.c.i相同。
5\.
上面提到的步骤都发生在内核模式下。但是对于用户模式，CFGBitmap需要访问LdrpValidateUserCallTarget函数，它在上一部分已经描述了。用户模式下怎么知道CFGBitmap映射的地址？当创建一个进程，NT内核调用PspPrepareSystemDllInitBlock函数来写CFGBitmap映射的地址和全局变量的长度，其数据结构是PspSystemDllInitBlock结构。PspSystemDllInitBlock是修正过的地址并且从用户模式和内核模式都能访问。
图18 – 调用堆栈
用户模式可以访问硬编码的PspSystemDllInitBlock全局变量的CFGBitmap字段。
6\.
在图4中，_guard_check_icall函数指针将指向ntdll的LdrpValidateUserCallTarget。何时发生，如何发生？LdrpCfgProcessLoadConfig来完成这个工作。进程创建过程将在用户模式下调用LdrpCfgProcessLoadConfig。
图19 – 在这个函数中，它将修改_guard_check_icall的值指向LdrpValidateUserCallTarget
7\.
在所有的准备都完成后，如果间接调用的目标地址相关的位在CFGBitmap中不是“1”，将触发CFG。进程将采取行动处理这个异常。处理函数是RtlpHandleInvalidUserCallTarget。这个函数使用间接调用的目标为唯一的参数。函数的主要逻辑如下：
图20 – RtlpHandleInvalidUserCallTarget的主要逻辑
函数的主要流程是校验DEP状态和触发int 29中断，这个内核中断处理例程是KiRaiseSecurityCheckFailure。它的行为是结束进程。
如果一个间接调用的目标地址的CFGBitmap中的相关的位不能访问（如超出了CFGBitmap空间），意味着目标地址是不可靠的。系统将抛出访问异常。当这个异常回到用户模式的处理函数KiUserExceptionDispatcher时，它将调用RTLDispatchException。在RTLDispatchException中，它将校验异常发生的地址。如果指令的地址能访问CFGBitmap，它将继续调用RtlpHandleInvalidUserCallTarget。
8\.
如果一个进程需要自定义CFGBitmap，它能调用ntdll中的NtSetInformationVirtualMemory。在内核中函数MiCfgMarkValidEntries实现了这个功能。MiCfgMarkValidEntries以一个缓冲区和长度作为参数。缓冲区中的每个单位是8字节。头四个字节是目标地址，其想在CFGBitmap中设置相关的位，且后四个字节是设置“0”或“1”的标志。MiCfgMarkValidEntries自定义的CFGBitmap只在当前进程能看见。
9\.
如果一个攻击者需要改变用户模式下的CFGBitmap的内容，是不可能的。因为CFGBitmap被映射为只读（在3.b节讨论过）。不管改内存保护属性还是向空间中写值都将失败。
**0x02 CFG的弱点**
当然，这个机制不是没有弱点的。我们指出了一些弱点如下：
CFGBitmap空间地址存储在修正过的地址中，其能被用户模式代码获得。这在CFG实现中讨论过。这是很重要的安全问题，但是被简单的放过了。
如果主模块没有开启CFG，即使加载的启用了CFG的模块，进程也不会受保护。
基于图20，如果一个进程的主模块禁用了DEP（通过/NXCOMPAT:NO），能绕过CFG访问处理，即使间接调用的目标地址是不可靠的。
在CFGBitmap中的每个bit在进程空间中表示8个字节。因此如果一个不可靠的目标地址少于8个字节，CFG将认为是可靠的。
如果目标函数是动态生成的（类似JIT技术），CFG的实现不能保护。这是因为NtAllocVirtualMemory将在CFGBitmap中为所有分配的可执行的内存空间设置为“1”（4.c.i描述）。通过MiCfgMarkValidEntries自定义的CFGBitmap解决这个问题是可能的。