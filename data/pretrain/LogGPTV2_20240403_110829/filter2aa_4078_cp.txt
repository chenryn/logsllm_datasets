其状态会被保存， 同时开始处理下一个进程。 同一批中 的其他所有进程依次执行完成并在外围等待
219
CISSP 官方学习指南(第 7 版)
之前， 第一个程序并不返回进行处理。 对任何单个程序来说， 这种方法在完成某个任务时会导致显
著 的延迟。 不过， 对于同一批 中 的所有进程而言 ， 完成所有任务所需的总时间会减少。
多程序设计被认为是一种相对过时的技术， 除了在比较旧的系统中能够找到， 如今已经很少使
用了。 多程序设计和多任务处理技术之间存在下 列两个主要差异 :
• 多程序设计通常在大规模系统(例如， 大型机)中使用 ， 而多任务处理在个人计算机操作系统
(例如 ， Windows 和 Linux)中使用 。
• 多任务处理通常由操作系统协调使用 ， 而多程序设计则要求特别编写的软件， 这种软件通
过操作系统来协调 自 己的活动和执行。
多线程处理 多线程处理允许在单个进程中执行多个并发任务。 与 多个任务占用 多个进程的多
任务处理不同 ， 多线程处理允许在单个进程中执行多个任务。 线程是一个自包含的指令序列 ， 可 以
与作为同一父进程一部分的其他线程井行执行。 多线程处理常用于这样的应用幸自宇: 多个活动进程之
间频繁的上下文切换会带来过大的开销并且降低系统效率。 使用多线程处理技术， 线程之间转换的开
销会大大降低， 因此更有效率。 例如， 在现代 Windows 实现中 ， 在单个进程内 从一个线程转换到另一
个线程所涉及的开销大约为 40 到 50 条指令， 并且不需要转移大量内存空间。 相 比之下， 从一个进程
转换到另一个进程所涉及的开销大约 为 1000 条或更多条指令， 并且还需要转移大量内 存空间 。
使用多线程处理的一个优秀例子是在一个字处理程序中 同时打开多个文档 。 在这种情况下， 实
际上并没有运行字处理器的多个实例 ， 如果多个实例同时运行， 对系统的要求会很高。 相反， 每个
文档都被视为单个字处理器进程 的一个线程， 并且在任何给定时间 由软件选择要处理的线程。
事实上， 对称多处理系统在操作系统级别使用线程。 在刚才描述的字处理示例中， 操作系统还
包含许多控制所分配任务的线程。 在单处理器系统中 ， 操作系统每次向处理器发送一个线程进行处
理 。 SMP 系统向每一个处理器都发送一个线程井同 时加 以执行 。
220
3. 处理类型
许多安全要求较高的系统控制着被分配了不同安全级别的信息的处理任务， 例如， 美 国政府为
与国防相关的信息指派的分类级别 : 非保密、 敏感、 机密、 秘密和绝密。 设计计算机时一定要使用
这种方法， 这样就不会因疏忽把信 息泄漏给未经授权的接收方 。
计算机体系架构师和安全策略管理员从两个不同的方面抨击了 处理器级别存在的 问题。 一方面
是策略机制 ， 而另一方面则是硬件解决方案。 稍后两部分内 容将研究这两方面的问题。
单一状态 单一状态系统要求使用策略机制来管理不同安全级别的信息。 在这种类型的方案中 ，
安全管理员准许处理器和系统每次只 处理一个安全级别的问题。 例如， 某个系统可能被标记为只 处
理秘密级别的信息。 这样一来， 该系统的所有用户都被准许在秘密级别处理信息， 从而将保护系统
要 处理的信息的责任从硬件和操作系统转移到控制访问系统的系统管理员 的身上。
多态 多态系统能够实现更高的安全级别。 这些系统是被认证过的 ， 通过使用特定的安全机制
(如本章稍后讨论的 " 保护机制 " 一节中 的 内容)同时处理多个安全级别。 这些安全机制被设计用于
阻止信息跨越不同的安全级别。 某用 户可能正在使用多态系统处理秘密级别的信息， 同时， 另一个
用 户正在处理绝密级别的信思。 技术方面的机制能够阻止信息在这两个用户之间的交叉使用， 因此
也 阻止 了信息在不 同安全级别间的交叉 。
在实际应用 中 ， 因 为实现必要的技术性机制的费用较高， 所以多态系统的使用相对不太普遍。
实现必要技术性机制的费用在某些时候被证明是值得的。 无论如何， 处理非常昂贵的资源(例如， 大
规模并行系统)时， 获得多个系统的成本远远超出 了实施必要的额外安全控制以便在单个系统上支持
第 9 章 安全脆弱性、 威胁和对施
多态操作的成本。
4. 保护机制
如果计算机没有运行 ， 那么它就是一堆不能完成任何工作的塑料、 硅和金属材料。 计算机在运
行时管理着运行时环境， 运行时环境表示操作系统和活动的应用程序的组合。 在运行时， 计算机还
能够根据用户 的安全许可访问 文件和其他数据。 在运行时环境中 ， 必须集成安全信息和控制来保护
操作系统本身的完整性、 管理被允许访问特定数据项的用户 、 授权或拒绝对这些数据的操作请求等。
运行中 的计算机在运行时实现和处理安全性的方式可以被大体描述为一个保护机制的集合。 接下来
会介绍各种保护机制 ， 包括保护环、 操作状态和安全模式。
提示 :
因 为计算机实现和使用保护机制的方式对于维护和控制安全性来说十分重要， 所以读者应 当 理
解下面将知阔的三种保护机制(保护环、 操作状态和安全模式)的定义及表现。 因 为这些 内 容十分
重要， 所以考试中很可 能 出 现与 这三种保护机制相关的细节 问 题。
保护环 保护环是一种虽然陈 旧但却 良好的方案， 它使我们回想起使用 Multics 操作系统的时
代 。 这种实验性的操作系统是 由 Bell 实验室、 MIT 和通用 电气在 1 963 年到 1969 年之间合作设计和
构建的。 尽管只是在 Hon巳ywell 实现中得到了商业应用 ， 不过 Mu1tics 为计算领域带来了两个持久深
远的影响。 首先， Mu1tics 导致简单的、 复杂程度较低的 Unix 操作系统(针对 Multics 的文字游戏)的
出现; 其次， 引入了操作系统设计中 的保护环的概念。
从安全性的观点出发， 保护环将操作系统中的代码和组件(以及应用程序、 实用程序或由操作系
统控制运行的其他代码)组织在如 图 9. 1 所示的同 心环内。 越进入圆环的 内 部， 与 占据特定环的代码
相关联的特权级别就越高。 尽管最初的 Multics 实现最大允许 7 环(从0到6进行编号)， 然而现代操
作系统使用的是具有 4 环(从 o U 3 进行编号)的模型。
环 0: os 内核/内存(驻留组件)
环 1 : 其他 os 组件
环 2: 驱动程序、 协议等
环 3 : 用户级程序和应用程序
环 0-2 在监管或特权模式中运行
环 3 : 在用 户模式中运行
图 9. 1 保护环
221
CISSP 官方学习指南(第 7 版)
作为最内部的环， 环 0 具有最高的特权级别， 并且基本上可 以访问任何资源、 文件或内存位置。
操作系统始终驻留在内 存中 的部分(因此能够根据需要随时运行)被称为内核(kemel)。 内 核 占据着环
0 ， 并且优先 占有在其他环上运行的代码。 在请求各种任务、 执行操作、 切换进程时进出 内存的操作
系统的剩余部分 占据着环 l 。 环 2 在一定程度上也是特许的， 这个环驻留 了 vo 驱动程序和系统实
用程序， 它们能够访问应用程序和其他程序本身不能直接访 问 的外围设备、 特殊文件等。 应用程序
和 其他程序 占据着最外层的环 3 。
环模型的本质在于优先权、 特权和内 存分割。 希望执行的任何进程必须排队等待(进程暂挂队
列)。 与最小环号相关联的进程总是 比与较大环号相关联的进程先运行。 在较低编号的环中 的进程能
够 比较高编号的环中 的进程访问更多的资源， 并且能够更直接地与操作系统交互。 在较高编号的环
上运行的进程通常必须请求较低编号的环中 的处理程序或驱动程序来获得需要的服务， 有时这被称
为居间访问模型 。 在最严格的实现中， 每个环都具有 自 己关联的内存段。 因此， 较高编号的环中 的
进军D才较低编号的环 中 的任何地址请求， 都必须请求与该地址相关联的环中的某个辅助进程。 在实
践中， 许多现代操作系统只将内存分为两段: 一段用于系统级访问(环 0 到环 2)， 常常被称为内 核模
式或特权模式: 另一段则用于用 户 级程序和应用程序(环 3)， 常常被称为用户模式 。
从安全性的观点出发， 环模型使得操作系统能够将自 身与用户和应用程序隔离开并加以保护，
还允许在高特权操作系统组件(例如， 内 核)和低特权操作系统部分(例如， 操作系统的其他部分以及
驱动程序和实用程序)之间实施严格的界线。 在这种模型中 ， 对特定资源的直接访问 只能在特定的环
中进行; 同样， 特定的操作(例如， 进程的切换、 终止和调度)也只 被允许在特定的环 内 执行 。
某个进程所占据的环决定了该进程对系统资源的访问级别(并且决定了 必须从较低编号、 特权更
多的环内 的进程中请求何种资源)。 只 有当客体驻留在进程自 己的环内或驻留在当前边界外部的某些
环内时， 进程才可以直接访问这些客体(以数值方法为例 ， 这意味着位于环 l 的某个进程能够直接访
问自己环内的资源以及与环 2 和环 3 关联的任何资源， 但是不能访问 只与环 0 关联的任何资源)。 凭
借居间访问(也就是前面刚提到的驱动程序或处理程序请求)的机制常常被称为系统调用 ， 井且往往
涉及调用特定的系统或设计用于将服务请求传递至内部环的编程接口 。 然而， 在接受这样的请求之
前 ， 调用环必须检查并确认调用进程具有正确的凭证和授权， 从而能够访问数据和执行满足请求所
涉及的操作 。
进程状态 进程状态也被称为操作状态， 指 的是进程可能在其中运行的各种执行形式。 在任意
给定时刻， 操作系统都处于下列两种模式之一: 在特许的全部访问模式(也被称为监管状态)中运作 ;
在与用户模式相关联的 问题状态中运作， 此时特权最少， 并且所有访问请求在被授予或拒绝之前必
须检查授权凭证。 后者被称为问题状态的原因并非是一定会发生问题， 而是因为用户访问 的未许可
状态意味着会发生问题， 系统必 须采取适当的措施来保护安全性、 完整性和机密性。
222
在操作系统中 ， 进程排列在处理队列中依次执行， 此时某个处理器在可用时会调度这些进程的
执行。 许多操作系统只允许进程以固定的增量或数量占用处理器时间， 某个新进程被创建时首先会
进入处理队列 ， 如果 占用 了 整个处理时间量(称为时间片)仍未完成执行， 那么 这个进程就会返回 处
理队列并等待下一轮继续执行 。 此外， 进程调度程序常常会选择执行具有最高特权的进程， 因此排
在 最前面的进程并不保证能访 问 CPU( 因为具有较高优先权的进程会在最后时刻被抢先执行)。
根据进程是否运行 ， 进程可 以运作在下列几种状态之一:
就绪状态 在就绪状态中 ， 进程准备在被调度执行时立刻继续或开始处理。 在进程到达这个状
态时， 如果 CPU 可用 ， 那么进程就会直接转移到运行模式: 如果 CPU 不可用 ， 那么进程就停留在
就绪状态直至 CPU 可用 。 这个状态意 味着: 拥有立即开始执行所需的所有 内 存和其他资源。
第9章 安全脆弱性、 威胁和对施
等待状态 等待状态还可以被理解为 " 等待某种资源"， 也就是说， 进程准备继续执行， 但是在
能够继续处理之前需要等待某台设备或访问请求(某种中断)提供服务(例如， 要求从文件中读取记录
的某个数据库应用程序必须等待文件被定位和打开， 以及查找到正确的记录集)。 一些引用将此状态
标记为阻塞状态， 因为该状态可 以 阻止进一步的执行 ， 直到某个外部事件发生为止 。
运行状态 运行中 的进程在 CPU 中执行直至完成、 时 间片到期或由于某些原因而阻塞(通常是
由于生成访问 设备或网络的中断并且等待中断完成)。 如果进程在时间片结束时尚未完成， 那么进程
就会返回就绪状态并在队列中排队 ; 如果在等待资源变得可用时 阻塞进程， 进程便进入等待状态并
排队。
提示 :
运行状态也被称为 问题状态。 不过， 千万不要将术语 " 问题" 与街吴关联在→豆。 相反， 可以
将问题状态视为解决某个数学 问题以便寻求答案。 但需要记住的是， 运行状态被称为 问 题状态是因
为可能发生问题或4轩吴， 就像回答数学 问题可能出 错一样。 问题状态不 同 于监管状态 ， 因此在发生