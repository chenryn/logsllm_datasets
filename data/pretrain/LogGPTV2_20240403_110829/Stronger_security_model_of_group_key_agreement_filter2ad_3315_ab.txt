### 1. 安全性定义

**定义4（MA安全性）**：针对MA安全性的对手MM A可以进行上述所有查询。如果在协议运行过程中，存在一个未被破坏的实例 \( U \)，该实例接受了会话密钥 \( sk_i^U \)，并且另一个未被破坏的实例 \( U' \) 也接受了会话密钥 \( sk_j^{U'} \)，但满足以下条件之一，则MM A违反了GKA协议的相互认证属性：
1. 不存在实例 \( \prod \) 使得 \( (pid_j^{U'}, sid_j^{U'}) = (pid_i^U, sid_i^U) \)。
2. 存在一个实例 \( \prod \) 使得 \( (pid_j^{U'}, sid_j^{U'}) = (pid_i^U, sid_i^U) \)，但 \( sk_j^{U'} \neq sk_i^U \)。

在GBG模型中，不允许对手对测试会话进行RevealState查询。这意味着如果某个参与者的临时密钥泄露，GBG模型无法提供任何安全保障。为了避免这种临时密钥泄漏（EKL）攻击，GBG模型假设在实例接受后应擦除其内部状态。然而，这一限制阻止了对手在协议执行过程中揭示参与者的临时密钥。

### 2. EKL攻击示例：BGS协议

Bohli等人提出的BGS协议[5]已被证明满足外部和内部安全性的定义。我们简要回顾一下该协议：

#### 第一轮
1. 每个参与者 \( U_i \) 选择 \( k_i \leftarrow \{0, 1\}^k \) 和 \( x_i \leftarrow Z_q \)，并计算 \( y_i = g^{x_i} \)。参与者 \( U_n \) 还计算 \( H(k_n) \)。
2. 除了 \( U_n \) 外，每个参与者 \( U_i \) 设置 \( M_I^i = k_i \| y_i \)；\( U_n \) 设置 \( M_I^n = H(k_n) \| y_n \)。
3. 每个参与者 \( U_i \) 计算 \( M_I^i \) 的签名 \( \sigma_I^i \) 并广播 \( M_I^i \| \sigma_I^i \)。

#### 第二轮
1. 每个参与者 \( U_i \) 计算 \( t_L^i = H(y_i^{x_i}) \) 和 \( t_R^i = H(y_i^{x_{i+1}}) \)。参与者 \( U_n \) 还计算 \( mask_n = k_n \oplus t_R^n \)。
2. 除了 \( U_n \) 外，每个参与者 \( U_i \) 设置 \( M_{II}^i = T_i \| sid_i \)；\( U_n \) 设置 \( M_{II}^n = mask_n \| T_n \| sid_n \)。
3. 每个参与者 \( U_i \) 计算 \( M_{II}^i \) 的签名 \( \sigma_{II}^i \) 并广播 \( M_{II}^i \| \sigma_{II}^i \)。

#### 验证
1. 每个参与者 \( U_i \) 验证所有传入消息 \( M_{II}^j \| \sigma_{II}^j \) 的签名，并检查 \( T_1 \oplus T_2 \oplus \cdots \oplus T_n = 0 \)。
2. 每个参与者 \( U_i \) 提取 \( k_n = mask_n \oplus T_1 \oplus T_2 \oplus \cdots \oplus T_{i-1} \oplus t_L^i \) 并验证承诺 \( H(k_n) \)。

#### 密钥计算
每个参与者 \( U_i \) 计算会话密钥 \( sk = H(pid \| k_1 \| k_2 \| \cdots \| k_n) \)。

### 3. BGS协议的EKL攻击

假设 \( U_i \) 的临时密钥 \( x_i \) 泄露，对手M可以在第二轮计算 \( t_L^i \) 和 \( t_R^i \)。使用公开的 \( mask_n \)、\( T_1, T_2, \ldots, T_{i-1} \) 及其自身的 \( t_L^i \)，M可以提取 \( k_n = mask_n \oplus T_1 \oplus T_2 \oplus \cdots \oplus T_{i-1} \oplus t_L^i \) 并计算会话密钥 \( sk = H(pid \| k_1 \| k_2 \| \cdots \| k_n) \)。这样，M可以通过选择 \( U_i \) 作为测试会话来轻松赢得AKE游戏。

尽管BGS协议在GBG模型中是安全的，因为根据GBG模型，所有临时密钥将在相应会话完成后被擦除，但上述攻击不在GBG模型的覆盖范围内。

### 4. 扩展的GBG模型（eGBG）

我们提出扩展的GBG（eGBG）模型，以解决上述问题：

#### 参与者
GKA协议在网络中的多个互联参与者之间运行，每个参与者为自身及其同伴运行会话。我们用 \( U = \{U_1, U_2, \ldots, U_n\} \) 表示参与者集合，协议可能在这些参与者中的任意子集间运行。

#### 对手模型
通信网络完全由对手M控制，M可以窃听、延迟、篡改和插入消息。我们通过挑战者和对手M之间的游戏来定义GKA协议的安全性，对手必须解决挑战才能被视为成功。在这个游戏中，M可以按任意顺序发起以下查询：
- **Execute(\( \prod_i^U \))**：返回协议实例 \( \prod_i^U \) 在诚实执行过程中的交换消息。此查询模拟被动攻击。
- **Send(\( \prod_i^U \), m)**：返回实例 \( \prod_i^U \) 收到消息m后生成的消息。如果m为空消息，则会在U处启动第i个协议实例。
- **RevealKey(\( \prod_i^U \))**：对手通过此查询获取已接受会话的会话密钥。
- **Long-termKeyReveal(U)**：对手通过此查询获取参与者U的长期密钥。
- **EphemeralKeyReveal(\( \prod_i^U \))**：对手通过此查询获取U在第i次运行中的临时密钥。
- **Test(\( \prod_i^U \))**：对手只能对一个已接受会话发起一次此类查询。响应此查询时，随机选择一个比特b。如果b=1，则返回真实的会话密钥；否则，返回从会话密钥分布中均匀选择的随机值。

#### 新鲜度定义
**定义6（新鲜度）**：实例 \( \prod_i^U \) 是新鲜的，如果满足以下条件：
1. 实例 \( \prod_i^U \) 或其任何伙伴在接受后没有被询问过RevealKey查询。
2. 实例 \( \prod_i^U \) 或其任何伙伴在接受前没有同时被询问过Long-termKeyReveal和EphemeralKeyReveal查询。
3. 如果 \( \prod_j^{U'} \) 是 \( \prod_i^U \) 的伙伴，并且M代表 \( U' \) 发送消息给 \( \prod_j^{U'} \)，则这些消息必须来自 \( \prod_i^U \)。

与GBG模型相比，我们在eGBG模型中进行了以下修改：
1. 用EphemeralKeyReveal查询替换RevealState查询，允许对手获取实例的临时密钥，并移除一旦实例接受就擦除内部状态的限制。
2. 用Long-termKeyReveal查询替换Corrupt查询，赋予对手揭示长期密钥的能力。
3. 修改新鲜度定义中的条件2，扩大对手的攻击范围，允许对手揭示四个秘密信息（参与者及其伙伴的长期密钥和临时密钥）的任意子集，只要不包含同一方的长期密钥和临时密钥。

通过这些修改，eGBG模型能够更好地应对EKL攻击，并提供更全面的安全保障。