secure if AdvMAKE is negligible in the security parameter k.
; (2) the instance
∏
′
′
′
De(cid:12)nition 4 (MA security). An adversary MM A against
the MA security notion is allowed to make all the queries de-
(cid:12)ned above. MM A violates the mutual authentication prop-
erty of the GKA protocol if at some point during the proto-
i
col run, there exists an uncorrupted instance
U that has
′ ∈ pidi
accepted with a session key ski
U
that is uncorrupted at the time
U and another party U
i
U accepts such that
∏
∏
1. There is no instance
or
2. There is an instance
that has accepted with skj
j
∏
∏
U′ with (pidj
U′ ̸= ski
U .
U′ with (pidj
j
∏
GBG model. According to this condition, the GBG model
does not allow the adversary to make RevealState query
against the test session which it wants to attack.
In oth-
er words, the GBG model does not provide any security
guarantees for a session if the ephemeral key of a party has
been leaked. To avoid such ephemeral key leakage (EKL)
attack GBG model assumes that the internal state should
i
be erased after
U has accepted. However, this restriction
prevents the adversary from revealing the ephemeral keys of
participants during the protocol execution process, that is,
the GBG model restricts the adversary’s ability to attack
the objective GKA protocol using the revealed ephemeral
key during the protocol execution process. Next, we will
present a concrete EKL attack on the BGS protocol which
has been shown secure in the GBG model.
2.3 EKL attack on BGS protocol
The BGS protocol [5] proposed by Bohli et al. has been
shown to satisfy their de(cid:12)nitions of outsider and insider se-
curity. We brie(cid:13)y review the protocol here.
Round 1:
Computation
1. Each Ui chooses ki
R← {0; 1}k, xi
R← Zq and
computes yi = gxi . Un additionally computes H(kn).
i = ki∥yi, while Un
i ∥pidi.
2. Each Ui except Un sets M I
n = H(kn)∥yn.
3. Each Ui computes a signature (cid:27)I
i on M I
sets M I
U′ ; sidj
U′ ) = (pidi
U ; sidi
U )
Broadcast
Each Ui broadcasts M I
i ∥(cid:27)I
i .
U′ ; sidj
U′ ) = (pidi
U ; sidi
U )
Check
∏
∑
We de(cid:12)ne the probability of MM A in winning the MA
security game as AdvMM A . A protocol is said to provide
mutual authentication in the presence of insiders if AdvMM A
is negligible in k.
De(cid:12)nition 5 (Contributiveness [11]). An adversary MCon
against the contributiveness notion is allowed to make all
the queries de(cid:12)ned above. It operates in two stages prepare
and attack as follows:
∏
∑
∏
∑
prepare MCon queries the instance
and outputs some
state information (cid:16) along with a key ~k.
At the end of prepare stage, a set
that
been asked wither Execute and Send queries.
is built such
consist of uncorrupted instances which have
attack On input ((cid:16),
), MCon interacts with the instances
of
as in the prepare stage.
∏
i
U
̸∈∑
At the end of this stage MCon outputs (U; i) and wins
i
the games if an instance
U at an uncorrupted party U has
terminated accepting ~k with
.
We de(cid:12)ne the advantage of MCon, denoted by AdvMCon ,
as the success probability of MCon in winning the above
game. A protocol is said to provide contributiveness in the
presence of insiders if AdvMCon is negligible in k.
2.2 An attack not covered by the GBG model
We focus on Condition 2 in the de(cid:12)nition of \Freshness"
(De(cid:12)nition 2) and point out an attack which may compro-
mise the security of GKA protocols proven secure in the
Each Ui checks all signatures (cid:27)I
j of incoming
j ∥(cid:27)I
j for j ̸= i.
messages M I
Round 2:
Computation
1. Each Ui computes tL
i ⊕ tR
i−1), tR
Ti = tL
Un additionally computes maskn = kn ⊕ tR
n .
i = H(yxi
i and sid = H(pid∥k1∥···∥kn−1∥H(kn)).
i = H(yxi
i+1),
i = Ti∥sidi while Un
sets M II
2. Each Ui except Un sets M II
n = maskn∥Tn∥sidn.
3. Each Ui computes a signature (cid:27)II
i on M II
i
.
Broadcast
Each Ui broadcasts M II
i ∥(cid:27)II
i
.
Check
1. Each Ui veri(cid:12)es the incoming the signatures (cid:27)II
j
on the corresponding message M II
j
and j ̸= i also checks that T1 ⊕ ··· ⊕ Tn
2. Each Ui for i < n, extracts
kn = maskn ⊕ T1 ⊕ ··· ⊕ Ti−1 ⊕ tL
commitment H(kn) sent in Round 1.
for each j ∈ [1; n]
?= 0.
i and checks the
Key Computation
sk = H(pid∥k1∥···∥kn).
Each Ui computes the session key
Algorithm 1: BGS protocol
Let U = {U1; U2;··· ; Un} be the set of the parties who
want to establish the session key. Suppose that the group
members are ordered in a logical ring with Ui−1 and Ui+1
being the left and right neighbors of Ui for 1 ≤ i ≤ n,
U0 = Un and Un+1 = U1. During the initialization phase,
a cyclic group G of prime order q, an arbitrary generator g
of G and the description of a hash function H that maps to
437
{0; 1}k are chosen. Each party is assumed to have a long-
term key pair for public signature. Algorithm 1 shows the
execution process after initialization phase.
i = H(yxi
We show that BGS protocol is vulnerable to the EK-
L attack. Without loss of generality, we assume that the
ephemeral key of Ui is leaked, an adversary M can com-
pute tL
i+1) in Round 2. Us-
ing the public maskn, T1; T2;··· ; Ti−1 and its own tL
i , M
will extract kn = maskn ⊕ T1 ⊕ T2 ⊕ ··· ⊕ Ti−1 ⊕ tL
i and
sk = H(pid∥k1∥···∥kn). In this way, M can easily win the
AKE game by selecting the test session at Ui.
i−1) and tR
i = H(yxi
One might think that a straightforward solution would be
to delete xi of participant Ui during the protocol execution
process. However, it is infeasible. In more speci(cid:12)c terms, it
is impossible for Ui to delete xi after Round 1, since Ui has
to use xi in Round 2 to compute tL
i and tR
i .
Note: It is worth mentioning that BGS protocol is secure
in the GBG model since according to the GBG model, all the
ephemeral xis will be erased after the corresponding session
completed. Here we would like to reiterate that the attack
not covered in the GBG model.
3. EXTENDED GBG MODEL
We now present our extended GBG (eGBG) model.
Participants. A GKA protocol runs in a network of
multiple interconnected participants where each participan-
t is activated to run sessions for itself and its peers. As a
result, participants in such a session establish a session key.
We denote the participant set by U = {U1; U2;··· ; Un} and
the protocol may be run among any subset of these parties.
In a GKA protocol, each participant may execute a polyno-
mial number of protocol instances in parallel. We refer to
the i-th protocol instance at U ∈ U as
∏
Adversary model. The communication network is as-
sumed to be fully controlled by an adversary M , that is, it
may eavesdrop, delay, alter and insert messages during the
process of the protocol at will. We de(cid:12)ne the security of a
GKA protocol through a game between a challenger and the
adversary M (an outsider adversary or a malicious insider)
in which the adversary must solve a challenge to be consid-
ered successful. In this games, M is allowed to select the
identities of all honest participants and issue the following
queries in any sequence.
i
U .
∏
∏
∏
∏
Execute(
i
U ). It returns the messages that were exchanged
i
U of the protocol. This
during the honest execution
query models the passive attacks.
Send(
i
U ; m).
It returns the message that the instance
i
U would generate on receipt of the message m. If the
m is empty message, then i-th instance of the protocol
will be initiated at U .
∏
RevealKey(
tain the session key established at the accepted
i
U ). The adversary makes this query to ob-
i
U .
∏
Long-termKeyReveal(U ). The adversary makes this query
to obtain the long-term key of the participant U .
∏
EphemeralKeyReveal(
i
U ). The adversary makes this
query to obtain the ephemeral key of U in the i-th run.
Test(
i
U ). The adversary is allowed to issue only one
i
U . To
query of this form on an accepted session
∏
∏
respond to this query, a random bit b ∈ {0; 1} is se-
lected. If b = 1, then the real session key is returned.
Otherwise, a random value uniformly chosen from the
session key distribution is returned.
We now de(cid:12)ne the notion of freshness according to the
same de(cid:12)nition of partnership in the GBG model.
De(cid:12)nition 6 (Freshness). An instance
following conditions hold:
i
U is fresh if the
∏
1. The instance
i
U or any its partner has not been asked
a RevealKey query after their acceptance.
∏
∏
∏
2. The instance
i
U or any its partner has not been asked
a Long-termKeyReveal query and a EphemeralKeyRe-
veal query simultaneously before their acceptance.
∏
′
3. If
j
U′ is a partner of
i
U and M asked Long-termKeyR
eveal (U
behalf of
), then any message that M sends to
j
U′ intended to
j
U′ must come from
∏
∏
∏
i
U on
i
U .
∏
The description of the AKE security, MA security and
Contributiveness are the same as that in the GBG model
in Section 2.1. Compared to the GBG model, we
∏
1. Replace the RevealState query with the Ephemer-
∏
alKeyReveal by which the adversary can get the ephemer-
i
U . At the same time, we re-
al key of the instance
move the limitation of the original GBG model where
once (
i
U ) has accepted the internal state is erased.
2. Replace the Corrupt query with the Long-termKeyRe
veal to give the adversary the power to reveal the long-
term keys.
3. Modify the Condition 2 in the notion of \freshness"
to expand the attack scope of the adversary. That is,
the adversary is allowed to reveal any subset of four
pieces of secret information (the long-term keys and
the ephemeral keys of the participant and its part-
ner) which does not contain both the long-term and
ephemeral keys of one party.