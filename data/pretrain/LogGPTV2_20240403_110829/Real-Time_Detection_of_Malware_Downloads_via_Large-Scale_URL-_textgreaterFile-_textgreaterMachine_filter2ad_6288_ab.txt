be labeled as unknown. To calculate and assign the bad-
ness reputation score R to nodes in the tripartite graph, we
leverage a combination of public and private information for
ﬁles and URLs, such as ﬁles’ AV labels, URL blacklists and
list of top Alexa domains. A machine node’s R is calculated
based on its download history, system-level information, and
R of its neighbors in the graph, since no black or whitelist
of machines is available. In Section 4.1, we explain in de-
tails how ﬁle, URL, and machine nodes in each layer of the
graph receive their R scores and labels. Note that due to our
large-scale deployment and incompleteness of the black- and
whitelists, it is highly challenging to label all nodes, so the
majority of the nodes will remain unknown, and it will be
Mastino’s responsibility to accurately classify these nodes.
3.2 Behavioral Graph-based Classiﬁer
We use statistical classiﬁers that harness behavioral pat-
terns among the nodes in the graph as well as the partially
available ground truth from known nodes to detect malware
ﬁle downloads and malicious URLs. Speciﬁcally, Mastino’s
classiﬁcation system consists of two classiﬁers, one dedicated
to distinguishing between malicious and benign URLs, and
another dedicated to detecting malicious downloaded ﬁles.
The output of these two classiﬁers is then reconciled as fol-
lows: if either the URL or the downloaded ﬁle is classiﬁed
as malicious, then the entire download event is deemed as
a malware download. The classiﬁers in each layer receive as
input a statistical feature vector for a to-be-classiﬁed node,
n, and output a badness score. The badness score is checked
against an automatically learned detection threshold to la-
bel n. Each layer’s classiﬁer uses a set of statistical features
......To be classiﬁedBenignMalicious- Complete URL string- query string- effective 2LD- IP info- ...- File's SHA1- File size- Is the code likely obfuscated?- Does it carry a valid signature?- ...- Global unique ID (GUID) - Past download behavior- Process that downloaded ﬁle - Geo-location - ...UFMdownloadclassiﬁcationrequestﬁleupdatedownloadgraphclassify new downloadURL and ﬁleDIAclientdownload serverMDDclassiﬁcation resultsclassiﬁcationrequestsqueue785to enable the detection. The classiﬁer features in each layer
could be divided into two groups. A set of behavior-based
features and a set of intrinsic features. Behavioral-based
features are the ones that describe the goodness or badness
of related nodes connected to a to-be-classiﬁed node. These
features can only be computed by using the graph nodes and
edges. The intrinsic features, in contrast, are the features
that could be computed without the graph (e.g., a ﬁle’s size).
3.2.1 Intrinsic Features
For ﬁles, their node-speciﬁc information (see Section 2
and annotated nodes in Figure 2) in the tripartite down-
load graph is used as intrinsic features. For example, the
lifetime and prevalence of ﬁles are two of the intrinsic fea-
tures. Intuitively, ﬁles that have been downloaded by many
users and were constantly observed by DIA for long peri-
ods of times are most likely benign software. In contrast,
malwares usually have shorter lifetimes and are downloaded
by fewer users, especially, if one considers the impact of
packing/obfuscating malware binaries. Additionally, fea-
tures about if ﬁles are packed and if they have a valid sig-
nature are also useful. The intuition here is that malwares
are often packed to remain undetected by AVs.
For URLs, we consider the age or recency of the URL
itself and its FQD and e2LD as intrinsic features. Gener-
ally, newly registered domains or not-so-popular URLs and
domains are more likely associated with malicious content.
Table 1 reports the full list of intrinsic features for ﬁles and
URLs and the intuition behind them.
Note that we don’t have a classiﬁer for the machines layer;
however, we use machines as a support layer in our graph
to compute the behavior-based features for the other two
layers. In the following section, we describe the behavior-
based features and explain the role of machines in measuring
the features.
3.2.2 Behavior-based Features
The behavior-based features for nodes in a layer of the
download graph, e.g. URLs, are computed based on the
badness reputation, R, of nodes in the other two layers, e.g.
ﬁles and machines. This means that all the neighbors of an
unknown node n have some say in determining the reputa-
tion of n. Intuitively, if an unknown ﬁle f , for example, is
downloaded from domains where majority of them hosted
malware in the past, and/or from URLs with a speciﬁc path
component that is associated with malicious ﬁle downloads,
and/or by vulnerable machines with high R, then it is more
likely that f is itself malicious.
URLs Behavior-based Features.
To compute these
features for a URL, u, we ﬁrst ﬁnd the set of all ﬁles and
machines in the graph that are connected to u. Let Fu =
{f1, f2, . . . , fh} and Mu = {m1, m2, . . . , mk} be sets of ﬁles
and machines nodes connected to u, respectively. Then we
compute min, max, average, median, and standard devia-
tion of the following: 1) reputation, R, of all fi ∈ Fu, 2)
reputation, R, of all mi ∈ Mu, and 3) number of AVs that
labeled each fi ∈ Fu. These numbers are used as features
of u. In essence, these statistics highlight the true nature
of the neighbors of u. Intuitively, if u’s neighbors have high
badness reputation, it is more likely that u itself has a high
badness reputation as well. Conversely, if on average, neigh-
bors of u are benign nodes (i.e. clean machines and benign
ﬁles), then it is likely that u itself is a benign domain.
u, and machines, M(cid:48)
However direct neighbors of a single URL in the tripartite
graph, might not give us enough information. To gather
more evidence about u (the URL we want to compute its
features), we consider its components, such as FQD, e2LD,
path, etc. Then we ﬁnd a set of URLs, Cu, that have at least
a component in common with u. Finally, we gather larger
sets of ﬁles, F (cid:48)
u, that are connected to
URLs in Cu and use them to expand features of u in a similar
fashion as nodes in Fu and Mu. Figure 4(a) shows how
the mentioned behavior-based features are computed for a
sample URL u. Four ﬁles, Fu∪F (cid:48)
u, and three machines, Mu∪
M(cid:48)
u, are connected to u and Cu collectively. For simplicity,
u and Cu are shown as one node. Each ﬁle and machine
sends some information, shown on edges, to u for feature
computations.
Precisely, we consider FQD, e2LD, path, path pattern,
query string, query string pattern, IP, and IP/24 as com-
ponents of a URL. The path pattern is an advanced regular
expression for u’s path. To generate it, we identify sequences
of letters, digits, and hexadecimal numbers in a path, and
generalize them while keeping non-alphanumeric characters.
For example, if a URL’s path is /sample/123/DA10/foo.exe,
then the generated path pattern would be /S6/D3/H4/S3.S3,
which represents a path with sequences of 6 letters, 3 digits,
4 hexadecimal digits, 3 letters, a ’.’, and 3 letters. The query
string is deﬁned and generated in a similar fashion from the
query string. The IP and IP/24 are the sets of IPs and
IP/24 networks that u resolved to during the observation
time window.
Note that the features explained above help us to make
better classiﬁcation decisions. For example, consider u is
an unknown URL that all of its neighbors are unknown
nodes, so they cannot contribute meaningfully to classify-
ing u. Nonetheless, if u shares the same URL path with a
group of malicious URLs (because, for example, they were
generated by the same kit), and if there are some known
malware ﬁles or infected machines connected to this group
of URLs, they will have an impact on accurately labeling
u as malicious, since their R will be used to compute some
features of u. Consider another example when the path com-
ponent of some malicious URLs is generated by an algorithm
that randomizes the characters, so they might look diﬀerent.
However, it is likely that they share the same path pattern.
Now this group of malicious URLs will help classifying u,
the unknown URL, if u has the same path pattern.
These are computed
Files Behavior-based Features.
in a similar way as in URLs. For example, for a ﬁle, f , we
gather all the connected nodes from the URLs and machines
layers to compute the features of f . Figure 4(b) shows how
these features are computed. Note that the connected URLs
to f also send the R of their components, such as FQD,
path pattern, IP, etc., to f for feature computation. We
deﬁne the R of a URL’s component to be the average of R
of all URLs that share the same component. This helps in
correctly classifying unknown f nodes that their direct URL
neighbors are also unknown, but share some components
with known URLs.
4. EXPERIMENTAL SETUP
4.1 Calculating Badness Reputation and
Labeling Nodes
The following details how we label nodes of each layer
of the tripartite download graph by assigning them badness
786Feature
Size
Extension
Lifetime
Prevalence
Packed
Signed
Number of countries
Java or Acrobat Reader
Table 1: Files and URL layers intrinsic features
File Intrinsic Features
Explanation
The size of the ﬁles. Intuitively, large ﬁle sizes are less likely malware ﬁles and are mostly benign
softwares. However, ﬁle size by itself cannot distinguish benign and malware ﬁles, since many
benign ﬁles have small sizes, too.
This feature tries to capture malware binary downloads that have an unusual extension, such as
jpg, to deceive users. Note this feature will only be useful, if a ﬁle has other extensions than exe.
The time diﬀerence between the last time and ﬁrst time of seen date for a ﬁle by DIA. The
intuition here is that usually ﬁles with very short lifetime are malware. Also considering the
impact of packing and obfuscating, malwares can have very short lifetimes.
The number of downloads of a ﬁle by unique machines. Benign and popular softwares are down-
loaded by many machines around the world, but malwares, in contrast, usually are downloaded
by a very small number of machines. In some extreme cases, malware distributors install a unique
malware (with new and unseen-before SHA1 hash) to each machine.
This feature identiﬁes whether ﬁles are packed by a packer or not. As mentioned in the description
of other features, packing and obfuscation is a technique that is mostly used by malwares to avoid
detection.
This feature identiﬁes whether ﬁles are signed or not.
The number of unique countries that downloaded the ﬁle. Same as the lifetime or prevalence
features, this feature also tries to capture unpopular ﬁles.
If the downloading process of a ﬁle is Java (java.exe) or Acrobat Reader (acrord32.exe) and the
download URL is not oracle.com or acrobat.com, then this feature will be set to true. The reason
is that the downloads that are triggered by the Java or Acrobat Reader processes are possibly
suspicious.
URL Intrinsic Features
Feature
URL, FQD, and e2LD age These features determine how long ago the URL, FQD, and e2LD were ﬁrst seen in our data in
a time window. In general, new or not very popular URLs and domains are more likely to be
malicious than benign.
Explanation
(a) URL behavior-based features
(b) File behavior-based features
Figure 4: Computation of behavior-based features: (a) for URL, u, based on R and other information of neighbor ﬁles and
machines that are connected to either u or Cu; (b) for ﬁle, f , based on R of connected URLs and their components and
machines
reputation R. As discussed in section 3.1, R is a real number
in range [0, 1] that represents how much evidence exists to-
wards badness or goodness of nodes in the graph. Generally,
values closer to R = 1 mean high probability of badness, val-
ues closer to R = 0 indicate high goodness possibility, and
R = 0.5 means unknown, i.e. no evidence.
Files: Ground truth could be collected for some of the ﬁles
in the tripartite graph using various sources, such as Virus-
Total. If available, we use the assigned labels of reputable
and well-known antivirus companies to compute reputation
scores for ﬁles. We also use a proprietary list of known be-
nign ﬁles to further enhance the ﬁle reputation computation.
Empirically, we identiﬁed ten antivirus vendors that pro-
vide the most reliable results and are more well-known and
popular according to their market share, and we refer to this
list as trusted AVs1. Our conﬁdence of a ﬁle being bad de-
pends on the number of AVs from the trusted AVs list that
label the ﬁle as malicious, and, therefore, it determines the
R for the ﬁle. The more trusted AVs have a malicious label
for a ﬁle the higher the badness score will become. An R
1
Our list of trusted AVs: Trend Micro, Microsoft, Symantec, McAfee,
Kaspersky, AVG, Avast, ESET Nod32, BitDefender, and Sophos
above a certain threshold translates to a bad label. On the
other hand, if no AV, either trusted or not, have a malicious
label for a ﬁle, a low R and consequently a good label will
be given to the ﬁle. In addition, we utilize a proprietary list
of known benign ﬁles to reﬁne R.
URLs: We leverage black- and whitelists of URLs and do-
mains to gather ground truth regarding URLs. While some
of the sources that we use are private, the majority are pub-
licly available, such as list of popular domains according
to Alexa and a blacklist of malicious domains according to
Google Safe Browsing (GSB) [10]. We use a proprietary list
of benign URLs as our whitelist that is combined, conserva-
tively, with Alexa list of top 1 million domains to minimize
noise as follows. We keep track of domains that consis-
tently appeared in Alexa list for about a year. From this list
we also ﬁltered out known domains related to cloud storage
and those that allow their subdomains to be freely regis-
tered, such as web hosting or free blog services and dynamic
DNS providers, as these type of domains might be abused
by attackers. The ﬁnal list contains ∼450K domains which
are very unlikely to be malicious. Then from whitelist of
URLs, we remove those URLs that their e2LD does not ap-
u ⋃ Cufile1file2file3u behavior-basedfeatures = {files stats, machine stats}file4machine1machine3machine2compute min, max, med, avg, and stdcompute min, max, med, avg, and std Each file sends R and number of AV labels Each machines sends Rfurl1url2url3f behavior-basedfeatures = {URL stats, machine stats}url4machine1machine3machine2compute min, max, med, avg, and stdcompute min, max, med, avg, and std Each URL sends R of itself, plus R of its FQD, e2LD, path, path pattern, IP, etc. Each machines sends R787pear in our Alexa list. This conservatively ﬁltered whitelist
of URLs contains minimal noise (see Section 6 for possible
limitations). Now if a URL is found to be in our ﬁltered
whitelist, a low R, i.e. a score close to 0, will be assigned
and the URL will be labeled as good. Similarly, a conserva-
tive approach is followed to label malicious URLs. A URL
will be assigned an R close to 1 (maximum badness), if GSB
and our private blacklist have that URL as a malicious URL,
and so a bad label will be assigned. Note that to account for
possible noise in the black- and whitelists, we don’t set the
Rs to absolute 0 or 1. In all other cases, R will be a number
close to 0.5, and an unknown label will be assigned.
Machines: The reputation computation for machines is
somewhat diﬀerent in terms of meaning from ﬁles and URLs,
as benign and malicious labels for this group of nodes don’t
necessarily denote a good or a bad machine per se. Instead,
a malicious label for a machine represents a machine that
tends to be more vulnerable to infections, according to his-
toric evidence (e.g., past known infections on that host) and
a benign label represents a machine that seemed not associ-
ated with malicious content when looking at its activities in
the past.
In a novel approach, we combine the behavioral history of
the machines with some system level information collected
by DIA to compute R of machines as follows. For each
machine, in a time window, we consider the history of its
activities, including downloaded ﬁles and visited URLs, as
well as the list of client processes that initiated the down-
loads. Since all these entities in machine’s activity history
are assigned Rs, we can average their combined badness rep-
utations and use it as machine’s R score. The intuition is
that if a machine, during a time period, does not download
bad ﬁles, contact bad URLs, or run bad processes, it is likely