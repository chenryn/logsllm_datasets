(cid:5)
r, Î±1, Î±2 â†$ Zq
ti,1 â† gÎ±1
(cid:5)
1 hÎ±2
jâˆˆCi
1
ti,2 â† gÎ±1
2 hÎ±2
2 gr
(cid:5)
1
jâˆˆCi
PK i â† yi
PK j
jâˆˆCi
c â† H0(Â¯t1, Â¯t2, PK , m)
(cid:6)
jâˆˆCi
Î³j,1
{sj, Î³j,1, Î³j,2}jâˆˆCi- si â† r + c Â· sk i +
(cid:6)
(cid:6)
jâˆˆCi
jâˆˆCi
Î³i,1 â† Î±i,1 +
Î³i,2 â† Î±i,2 +
(Â¯t1, Â¯t2, PK )

tj,2
(ti,1, ti,2, PK i)-
(Â¯t1, Â¯t2, PK )

sj
Î³j,2
Î³i,1, Î³i,2, si-
Fig. 3: The mBCJ signing protocol for signer Si with se-
cret key sk i and public key pk = (yi, Ï€i). If Si
is the
leader then, instead of sending (ti,1, ti,2, PK i) to its parent,
it sends (Â¯t1, Â¯t2, PK ) = (ti,1, ti,2, PK i) to its children, and
instead of sending (si, Î³i,1, Î³i,2) to its parent,
it outputs
(Â¯t1, Â¯t2, s, Î³1, Î³2) = (Â¯t1, Â¯t2, si, Î³i,1, Î³i,2) as the signature.
schemes can exist at all. In this section we answer that question
in the positive by presenting a modiï¬cation of the BCJ scheme
that avoids the pitfalls exploited by the metareduction. Namely,
the metareduction exploits the fact that, when the reduction
rewinds the forger, the forger can extract the signing key
from the reduction, or some other information that can be
used to forge signatures. In the following scheme, we ensure
that the extracted information can only be used to create new
signatures on the same message as the one being signed, but
cannot be used to sign different messages.
5.1 The Modiï¬ed Scheme
the scheme uses three hash functions H0, H1
The mBCJ scheme uses the same homomorphic commit-
ment scheme to let signers commit to their ï¬rst rounds as
the BCJ scheme, but lets the parameters of the commitment
scheme be given by the message through a random oracle.
Namely,
:
{0, 1}âˆ— â†’ Zq and H2 : {0, 1}âˆ— â†’ G3
Parameters generation. Pg sets up a group G of order q
with generator g1, where q is a Îº-bit prime. Output par â†
(G, g1, q).
Key generation. Kg(par ) chooses sk â†$ Zq and sets y â† gsk
1 .
The proof-of-possession Ï€ = (c, s) is computed by choosing
r â†$ Zq and computing c â† H1(y, gr
1) and s â† r + cÂ· sk mod
q. Let pk â† (y, Ï€) and output (pk , sk ).
Signing. The
two-round signing protocol
in Figure
signer Si
Sign(par , (sk i, yi, Ï€i), m,T ) behaves as follows.
is the leader, then it sends a unique
Announcement. If Si
session identiï¬er ssid to its children. Otherwise, it waits for
this message and forwards it to its set of children Ci in T .
Commitment. Si waits to receive all values (tj,1, tj,2, PK j)
for j âˆˆ Ci. It then generates the commitment parameters
(g2, h1, h2) â† H2(m), chooses (ri, Î±i,1, Î±i,2) â†$ Z3
q, and
is depicted
running
3. More
precisely,
a
(cid:18)(cid:17)(cid:26)(cid:23)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
Â·(cid:5)
1
2
jâˆˆCi
1 hÎ±i,2
jâˆˆCi tj,1 and ti,2 â† gÎ±i,1
jâˆˆCi tj,2, and PK i â† yi Â· (cid:5)
Â· (cid:5)
Â·
computes ti,1 â† gÎ±i,1
2 hÎ±i,2
gri
PK j. If Si is not
1
the leader, it sends (ti,1, ti,2, PK i) to its parent, otherwise it
proceeds to the next phase.
Challenge. If Si is the leader, it sets Â¯t1 â† ti,1, Â¯t2 â† ti,2,
and PK â† PK i. It computes c â† H0(Â¯t1, Â¯t2, PK , m), and
sends (Â¯t1, Â¯t2, PK ) to its children. If Si
is not the leader,
it waits to receive a message (Â¯t1, Â¯t2, PK ), computes c â†
H0(Â¯t1, Â¯t2, PK , m), and sends (Â¯t1, Â¯t2, PK ) to its children.
Response. Si waits to receive all values (sj, Î³j,1, Î³j,2) for j âˆˆ
Ci (note that if Si is a leaf it will proceed immediately), and
(cid:6)
then computes si â† ri + c Â· sk i +
jâˆˆCi sj, Î³i,b â† Î±i,b +
jâˆˆCi Î³j,b for b âˆˆ {1, 2}. It sends (si, Î³i,1, Î³i,2) to its parent,
unless Si is the root, then Si sets s â† si, Î³1 â† Î³i,1, Î³2 â†
Î³i,2, and outputs Ïƒ â† (Â¯t1, Â¯t2, s, Î³1, Î³2).
Key Aggregation. KAg on input a set of public keys PK
âˆˆ PK as (yi, (ci, si)), and if this public key
parses every pk
Output aggregate public key PK â† (cid:5)
âˆ’ci
has not been validated before, check that ci = H1(yi, gsi
).
1 y
i
(cid:6)
yi.
i
Veriï¬cation. Vf on input aggregate public key PK , a sig-
nature Ïƒ = (Â¯t1, Â¯t2, s, Î³1, Î³2), and a message m, compute
(g2, h1, h2) â† H2(m), c â† H0(Â¯t1, Â¯t2, PK , m) and check that
Â¯t1
PK âˆ’c.
?= gÎ³1
?= gÎ³1
1 and Â¯t2
1 hÎ³2
2 hÎ³2
2 gs
1
5.2 Security
To prove security of the mBCJ scheme, we construct an
algorithm A around the forger F that simulates the random
oracle H3(m) either with commitment parameters with known
trapdoors, or with binding commitment parameters that are a
re-randomization of the challenge public key. It then hopes
that all signing queries are on messages with commitment
parameters of the ï¬rst type, so that it can use the trapdoor to
equivocate commitments and simulate signatures. If moreover
the forgery is on a message of the second type, then we show
that A can be used in a forking lemma to compute discrete
logarithms.
Theorem 3. mBCJ is a secure multi-signature scheme in the
key-veriï¬cation setting under the discrete-logarithm assump-
tion in the random-oracle model. More precisely, mBCJ is
(Ï„, qS, qC, qH, )-unforgeable in the random-oracle model if
q > 64e(N + 1)(qH + qS + 1)(qS + 1)/ and if the discrete-
logarithm problem is (Ï„ Â· 64e(N + 1)2(qH + qS + 1)(qS + 1)/Â·
ln(8e(N + 1)(qS + 1)/), /(8e(qS + 1)))-hard, where N is
the maximum number of signers involved in a single multi-
signature, e is the base of the natural logarithm, and Ï„exp is
the time of a multi-exponentiation in G.
Proof. Given a (Ï„, qS, qC, qH, ) forger F against the mBCJ
multi-signature scheme, consider an input generator IG that
âˆ— â†$ G and an algorithm A that on input y
and
outputs y
randomness f = (Ï, h1, . . . , hqH ) proceeds as follows.
Algorithm A simulates the self-signed certiï¬cate Ï€
âˆ—
=
âˆ— â†$ Zq and computing v
âˆ— â†
âˆ—
âˆ—
, w
(d
âˆ—âˆ’d
âˆ—
âˆ—
âˆ—
gd
)
, Ï€
1 y
with random tape Ï. It responds to Fâ€™s k-th random-oracle
query to H0 or H1 with hk, except when F makes a query
. Moreover, when F makes a
H1(y
) by picking d
. It then runs the forger F on input pkâˆ—
âˆ—
) it responds with d
= (y
, w
, v
âˆ—
âˆ—
âˆ—
âˆ—
âˆ—
1 , g2 â† gÏ‰2
1 , and h2 â† y
âˆ—Ï‰, stores (m, 1, Ï‰), and returns (h1, g2, h2).
query H0(Â¯t1, Â¯t2, PK , m), then A internally simulates a query
H3(m). We assume that A never makes the same random-
oracle query twice.
For each query H3(m), tosses a biased coin that comes
out heads with probability Î´ and tails with probability 1 âˆ’ Î´.
If the coin comes out heads, then it chooses Ï‰1, Ï‰2, Ï‰3 â†$
Zq, computes h1 â† gÏ‰1
âˆ—Ï‰3, stores
(m, 0, (Ï‰1, Ï‰2, Ï‰3)), and returns (h1, g2, h2). If it comes out
tails, then A chooses Ï‰ â†$ Zq and g2, h2 â†$ G, computes
h1 â† y
To answer signing queries for a message m as signer Si
in a tree T , A proceeds as follows. If F did not yet query
H3(m), then A internally simulates such a query. If A does not
have a record (m, 0, Ï‰1, Ï‰2, Ï‰3), then it aborts by outputting
(âˆ…,âˆ…). Otherwise, it receives all values (tj,1, tj,2, PK j) from
its children j âˆˆ Ci in T , chooses Ë†ri, Ë†si, Ë†c â†$ Zq and computes
ti,1 â† g Ë†ri
When the forger sends (Â¯t1, Â¯t2, PK ), A simulates a query
c â† H0(Â¯t1, Â¯t2, PK , m), then A waits for its children j âˆˆ Ci to
â† (c + Ë†c)/Ï‰3 mod q,
(cid:3)
send (sj, Î³j,1, Î³j,2) and computes Î³
â† Ë†si âˆ’ Ï‰2Î³
â† Ë†ri âˆ’ Ï‰1Î³
(cid:3)
(cid:3)
(cid:3)
(cid:3)
i,2
i,1 mod q. It
i,2 mod q, and s
Î³
(cid:6)
(cid:6)
then sends Î³i,1 â† Î³
(cid:3)
i
i,1
i,2 +
jâˆˆCi Î³j,2 mod q, and si â† s
(cid:3)
jâˆˆCi sj mod q to its
i +
parent. One can see that, if the co-signers behave honestly,
these values yield a valid signature because
(cid:2)
Î³
Î³
i,1
1 h
1
Ë†riâˆ’Ï‰1Î³
= g
1
(cid:12)
= g Ë†ri
1
jâˆˆCi
jâˆˆCi Î³j,1 mod q, Î³i,2 â† Î³
jâˆˆCi tj,1 and ti,2 â† gË†si
1 y
âˆ— Ë†c Â·(cid:5)
Î³i,1âˆ’(cid:2)
1
Î³i,2âˆ’(cid:2)
1
jâˆˆCi tj,2.
Â·(cid:5)
(cid:3)
i,1 +
= ti,1/
(cid:6)
Ï‰1Î³
1
= g
jâˆˆCi
jâˆˆCi
tj,1
(cid:2)
i,2
(cid:2)
i,2
(cid:2)
i,2
Î³j,2
Î³j,1
h
g
g
1
and
Î³i,1âˆ’(cid:2)
2
g
jâˆˆCi
Î³j,1
h
jâˆˆCi
âˆ—âˆ’c
sj
y
(cid:2)
i,1
y
âˆ—âˆ’c
siâˆ’(cid:2)
1
âˆ—âˆ’c
Ë†siâˆ’Ï‰2Î³
1
Î³
2
Î³j,2
= g
Î³i,2âˆ’(cid:2)
2
(cid:2)
Î³
i,1
2 h
(cid:2)
Ï‰2Î³
i,1
= g
1
= gË†si
1 y
= ti,2/
jâˆˆCi
(cid:2)
i,2
g
(cid:2)
gs
i
1 y
âˆ—c+Ë†cg
(cid:12)
âˆ— Ë†c
jâˆˆCi
tj,2
y
âˆ—
for a set of public keys PKâˆ—
as in the real signing protocol. Moreover, the responses are
correctly distributed due to the random choices of Ë†ri, Ë†si, and
Ë†c.
When F fails to output a successful forgery, then A outputs
fail. Otherwise, let Fâ€™s forgery is Ïƒ = (Â¯t1, Â¯t2, s, Î³1, Î³2) on
. Without loss of
message m
generality, we assume that F makes all hash queries involved
in verifying the forgery and the proofs of possession in PKâˆ—
.
, 1, Ï‰), then A aborts by
If there doesnâ€™t exist a record (m
outputting (âˆ…,âˆ…). Otherwise, let jf be the index of Aâ€™s random-
(cid:5)
âˆ—
oracle query H0(Â¯t1, Â¯t2, PK , m
(y,Ï€)âˆˆPKâˆ— y, and let out jf = (Â¯t1, Â¯t2, c, s, Î³1, Î³2,PK, Ï‰). For
each pk = (y, (d, w)) âˆˆ PKâˆ— \ {pkâˆ—}, let jy be the index of
Aâ€™s random-oracle query H1(y, v) = d where v = gw
âˆ’d, and
1 y
let out jy = (y, v, d, w). Algorithm A outputs (J,{out j}jâˆˆJ,
where J = {jy}(y,Ï€)âˆˆPKâˆ— âˆª {jf}.
) = hjf = c where PK âˆ—
=
âˆ—
(cid:18)(cid:17)(cid:26)(cid:24)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:45:54 UTC from IEEE Xplore.  Restrictions apply. 
(cid:18)qS Â·
Algorithm A runs in time at most Ï„ + (3qH + 5qS + N +
6) Â· Ï„exp + O(N qS + N ) and succeeds whenever F succeeds
and A doesnâ€™t abort prematurely, meaning that all Fâ€™s signing
queries were on messages m where the biased coin in H3(m)
âˆ—
) came out tails. The
came out heads, and the one in H3(m
success probability of A is therefore A â‰¥ Î´qS (1âˆ’Î´)Â·. Using