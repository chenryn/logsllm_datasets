title:Dynamic and efficient key management for access hierarchies
author:Mikhail J. Atallah and
Keith B. Frikken and
Marina Blanton
Dynamic and Efﬁcient Key Management for Access
Hierarchies∗
Mikhail J. Atallah, Keith B. Frikken, and Marina Blanton
Department of Computer Science
Purdue University
{mja,kbf,mbykova}@cs.purdue.edu
ABSTRACT
The problem of key management in an access hierarchy has
elicited much interest in the literature. The hierarchy is
modeled as a set of partially ordered classes (represented
as a directed graph), and a user who obtains access (i.e.,
a key) to a certain class can also obtain access to all de-
scendant classes of her class through key derivation. Our
solution to the above problem has the following properties:
(i) only hash functions are used for a node to derive a de-
scendant’s key from its own key; (ii) the space complexity
of the public information is the same as that of storing the
hierarchy; (iii) the private information at a class consists of
a single key associated with that class; (iv) updates (revo-
cations, additions, etc.) are handled locally in the hierarchy;
(v) the scheme is provably secure against collusion; and (vi)
key derivation by a node of its descendant’s key is bounded
by the number of bit operations linear in the length of the
path between the nodes. Whereas many previous schemes
had some of these properties, ours is the ﬁrst that satis-
ﬁes all of them. Moreover, for trees (and other “recursively
decomposable” hierarchies), we are the ﬁrst to achieve a
worst- and average-case number of bit operations for key
derivation that is exponentially better than the depth of a
balanced hierarchy (double-exponentially better if the hier-
archy is unbalanced, i.e., “tall and skinny”); this is achieved
with only a constant increase in the space for the hierarchy.
We also show how with simple modiﬁcations our scheme
can handle extensions proposed by Crampton of the stan-
dard hierarchies to “limited depth” and reverse inheritance
[13]. The security of our scheme relies only on the use of
pseudo-random functions.
∗Portions of this work were supported by Grants IIS-
0325345, IIS-0219560, IIS-0312357, and IIS-0242421 from
the National Science Foundation, Contract N00014-02-1-
0364 from the Oﬃce of Naval Research, by sponsors of
the Center for Education and Research in Information As-
surance and Security, and by Purdue Discovery Park’s e-
enterprise Center.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’05, November 7–11, 2005, Alexandria, Virginia, USA.
Copyright 2005 ACM 1-59593-226-7/05/0011 ...$5.00.
Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection; E.1 [Data Structures]:
[Graphs and networks]
General Terms
Security, Design, Algorithms.
Keywords
Hierarchical access control, key management, eﬃcient key
derivation.
1.
INTRODUCTION
Background. In this work, we address the problem of
access control and, more speciﬁcally, the key management
problem in an access hierarchy. Informally, the general model
is that there is a set of access classes ordered using partial or-
der. We use a directed graph G, where nodes correspond to
classes and edges indicate their ordering, to represent such
a hierarchy. Then a user who is entitled to have access to
a certain class obtains access to that class and its descen-
dants in the hierarchy. A key management scheme assigns
keys to the access classes and distributes a subset of the
keys to a user, which permit her to obtain access to objects
at her class(es) and all of the descendant classes. Such key
management schemes are usually evaluated by the number
of total keys the system must maintain, the number of keys
each user receives, the size of public information, the time
required to derive keys for access classes, and work needed
to perform when the hierarchy or the set of users change.
Hierarchies of access classes are used in many domains,
and in many cases they are more general than trees. The
most traditional example of such hierarchies is Role-Based
Access Control (RBAC) models [16, 41] that can be used for
many diﬀerent types of organizations. Other areas where hi-
erarchies are useful are content distribution (where the users
receive content of diﬀerent quality or resolution), cable TV
(where certain programs are included in subscription pack-
ages), project development (diﬀerent views of information
ﬂow and components at managerial, developers, etc. posi-
tions), defense in depth (at each stage of intrusion defense
there is a speciﬁc set of resources that can be accessed),
and others. Even more broadly, hierarchical access con-
trol is used in operating systems (see, e.g., [18]), databases
(e.g., [15]), and networking (e.g., [36, 33]).
A vital aspect of access control schemes is computational
and storage space requirements for key management and
processing. It is clear that low requirements allow a scheme
to be used in a much wider spectrum of devices and applica-
tions (e.g., inexpensive smartcards, small battery-operated
sensors, embedded processors, etc.)
than costly schemes.
Thus to make our scheme acceptable for use with weak
clients, we do not use powerful cryptography but instead
utilize only cryptographic hashes. Throughout this paper,
we use the word “smartcard” as a shorthand to refer to any
type of a weak client.
Security of access control models comes from their ability
to deny access to unauthorized data. Also, if a scheme is
collusion-resilient, then even if a number of users with access
to diﬀerent nodes conspire trying to derive additional keys,
they cannot get access to more nodes than what they can
already legally access. Even though we intend to use the
scheme with tamper-resistant smartcards, a number of prior
publications (e.g., [2, 3]) suggest that compromising cards is
easier than is commonly believed. In addition, the collusion-
resilience allows us to use the scheme with other devices that
do not have tamper-resistance.
One of the key eﬃciency measures for hierarchical access
control schemes is the number of operations needed to com-
pute the key for an access class lower in the hierarchy be-
cause this operation must be performed in real-time by pos-
sibly very weak clients. The best schemes (including ours)
require the number of bit operations linear in the depth of
the graph in the worst case, which for some graphs is O(n)
where n is the number of nodes in the access graph (see
the related work section for more detail). While the num-
ber of bit operations for key derivation is going to be small
on average and an organization’s role hierarchy tends to be
shallow rather than deep, deep hierarchies do arise in many
situations such as:
• Hierarchically organized hardware, where the hierar-
chy is based on functional and control issues but also
on how trusted the hardware components are;
• Hierarchically organized distributed control structures
such as physical plants or power grids (involving thou-
sands of possibly tiny networked devices such as sen-
sors, actuators, etc.);
cuits, etc.);
about descendant tasks.
• Hierarchical design structures (e.g., aircraft, VLSI cir-
• Task graphs where only an ancestor task should know
Also, deep access hierarchies can arise even in very simple
databases where the hierarchical complexity can come from
super-imposed classiﬁcations on the database that are based
on functional, structural, etc.
features of a database. See
also [35, 39] for other examples of deep hierarchies. This
is why a rather substantial part of this work is dedicated
to improving key derivation time, which, as we describe
below, can be decreased to a small number of operations
(O(log log n) or even only 3 hashes) with modest increase in
public storage space.
Our Results. Our scheme works for arbitrary access graphs,
even those that may contain cycles. In the scheme, only hash
functions are used for a node to derive a descendant’s key
from its own key. The space complexity of the public infor-
mation is the same as that of storing G and is asymptotically
optimal; the private information at a node consists of a sin-
gle key associated with that node. The derivation by a node
of a descendant node’s access key requires the number of bit
operations linear in the distance between the nodes. Up-
dates are handled locally in the hierarchy and do not “prop-
agate” to descendants or ancestors of the aﬀected part of
the graph, while many other schemes require re-keying of
other nodes following a deletion. Our scheme is resistant
to collusion in that no subset of nodes can conspire to gain
access to any node that is not already legally accessible. We
address key management at the levels of both access classes
and individual users, while other schemes manage keys only
at one of these levels.
In the scheme, we rely on the following assumptions: there
is a trusted central authority that can generate and dis-
tribute keys (e.g., an administrator within the organiza-
tion). The security of our scheme relies on the use of pseudo-
random functions.
We also show that the scheme can be easily extended to
cover access models that go beyond the traditional inheri-
tance of privilege. More precisely, we give extensions that
enable normal as well as reverse inheritance in the graph
(i.e., access to objects down or up in the hierarchy) and also
allow for ﬁxed-depth inheritance. Such extensions are use-
ful not only in the context of other standard models such
as Bell-LaPadula [4], but can also apply, for instance, to
RBAC (e.g., reverse limited-depth inheritance permits an
employee to have access to documents stored at the level of
the department of that employee), the model can cover a
much richer set of access control policies than that of other
schemes. These extensions are modeled after Crampton’s
work [13] and do not increase the space or computational
complexity of our scheme.
A substantial part of this work is dedicated to improving
eﬃciency of key derivation time for deep hierarchies. Our
technique is to insert additional (so called “shortcut”) edges
in the graph, that allow us to achieve somewhat surpris-
ing results:
for n-node trees our techniques enable us to
improve eﬃciency of key derivation to O(log log n) bit op-
erations in the worst case with constant increase in public
information, and to only 3 hashes with public space usage
of O(n log log n). We also describe how to apply our tech-
niques to more general hierarchies. These techniques allow
us to achieve the fastest key derivation known to date.
Organization. Section 2 provides an overview of related
literature. In section 3, we give a formal description of the
problem. Section 4 presents our base model along with its
security proof; then in section 5 we give description of dy-
namic versions of the model and extensions that permit the
scheme’s usage with other access models given in [13]. Sec-
tion 6 presents our techniques to improve eﬃciency of key
derivation for trees and also comments on more general hi-
erarchies. Finally, section 7 concludes the paper.
2. RELATED WORK
The ﬁrst work that addressed the problem of key manage-
ment in hierarchical access control was by Akl and Taylor [1]
in 1983. Since then a large number of publications ([5, 6,
7, 9, 10, 11, 12, 14, 17, 22, 23, 26, 25, 27, 29, 30, 31, 34,
37, 38, 40, 42, 43, 45, 46, 51, 52, 53, 54] and others) have
improved existing key assignment schemes, especially in the
recent years. All of these approaches assume existences of a
central authority (CA) that maintains the keys and related
information. Most of them (and our scheme as well) are also
based on the idea that a node in the hierarchy can derive
keys for its descendants. Due to the large number of pre-
vious publications, we only brieﬂy comment on their basic
ideas and eﬃciency in comparison to our scheme.
A relatively large number of schemes on this topic have
been shown to be either insecure with respect to the secu-
rity statements made in these works [50, 49, 44, 47, 24] or
incorrect [8]. Therefore, we do not take these schemes into
consideration in our further discussion.
A signiﬁcant number of schemes, e.g., [1, 34, 22, 6, 25,
23, 10, 37, 27, 38, 31, 43], operate large numbers computed
as a product of up to O(n) coprime numbers or, alterna-
tively, a product of up to O(n) large numbers, where n is
the number of nodes in the graph. Such numbers can grow
up to O(n log n) (respectively, O(n)) bits long and are pro-
hibitively large for most hierarchies (in case of [26] numbers
grow up to O(nd), where d is the number of immediate de-
scendants). While in many of these approaches key deriva-
tion might seem consisting of one division and one modular
exponentiation operation, in practice, division of two num-
bers even O(n) bits long involves O(n2) operations, in addi-
tion to the use of expensive public crypto operations. Our
key derivation, on the other hand, even in the base scheme
is bounded by the depth of the access hierarchy and is O(n)
hash operations in the worst case.
Work of [29, 40, 42] is limited to trees and thus is of lim-
ited use. Work of [5, 45, 51] is concerned with a slightly
diﬀerent model having a hierarchy of users and a hierarchy
of resources. The scheme of [5], however, is not dynamic;
and in [45, 51] there are high rekeying overheads for ad-
ditions/deletions (particularly because of slightly diﬀerent
requirements of the scheme) and the number of keys for a
class is large for large hierarchies.
The work of [17] gives an information-theoretic approach,
in which each user might have to store a large number of
keys (up to O(n)), and insertions/deletions result in many
changes. The scheme of [48] uses modular exponentiation,
and additions/deletions require rekeying of all descendants.
A number of schemes [14, 46, 7] are based on interpolating
polynomials and give reasonable performance. In [46, 14],
however, private storage at a node is up to O(n) and addi-
tions/deletions require rekeying of ancestors. As was already
mentioned above, we avoid rekeying on additions/deletions
and store only one key per node. In [7], key derivation is
less eﬃcient than in our scheme, also public storage space is
larger. Even though the authors speculate that schemes that
perform the key derivation process iteratively are ineﬃcient
(which is the case in our scheme), their key derivation is less
eﬃcient due to usage of expensive modular exponentiation
operations and interpolating polynomial evaluation.
Schemes that utilize sibling intractable function families
(SIFF) [52, 53] are the only eﬃcient approaches among early
schemes. In these schemes, there is only one secret key per
class, key derivation is a chain of SIFF function applications
which can be implemented using polynomials. However, ad-
ditions and deletions in [52] require rekeying of all descen-
dants and in [53] all descendants should be rekeyed when a
node is deleted.
A number of recent schemes [9, 11, 12, 30, 54] use overall
structure similar to ours and have performance comparable
to our base scheme.
[12], however, does not address dy-