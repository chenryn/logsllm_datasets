system is the TrustZone Address Space Controller (TZASC). Registers
of TZASC are mapped into the physical address of the SoC, and can
be accessed via normal memory operations. By configuring TZASC
in the secure world, the physical memory can be split into several
regions with different security levels. With these configurations,
secure world software can control whether a memory region can
be accessed in both the secure and normal worlds, or can only be
accessed in the secure world.
Newer Android systems comprise of two parts residing in two
worlds. The normal Android OS, including a customized Linux
kernel, framework libraries, and apps runs in the normal world.
A lightweight trusted OS runs in the secure world and provides
security-critical services to the normal Android OS. The secure-
world OS essentially constructs a Trusted Execution Environment
(TEE) for running trusted services. To request a security-critical
service, the normal Android OS issues an SMC instruction, which
traps the processor into the secure world. Based on the contents of
registers or shared memory, the trusted OS is able to identify the
intent of the request, and schedule a piece of trusted code (called
Trustlet) to perform the actual computation. Finally, the results are
sent back to the normal-world Android OS.
2.3 Flash-based Block Devices
Flash-based block devices (e.g., eMMC cards, SD cards, MicroSD
cards and SSD drives) have been widely used to replace the conven-
tional hard disk drives (HDD) due to their high I/O performance
and low energy consumption. Particularly, popular flash products
like eMMC cards and SD cards have dominated the storage media
of mobile devices (e.g., smart phones, tablets, smart watches).
Flash memory. Flash memory is a non-volatile storage medium
which can be electrically erased and reprogrammed. The flash mem-
ory family contains NOR-type and NAND-type flash. The NOR flash
allows one-byte random access, and is usually expensive with rela-
tively small capacity. Thus, it is commonly used to store executable
program (e.g., bootloader). The NAND flash, however, is cheaper
and has much larger capacity, thus it has been pervasively used in
flash storage media. NAND flash stores information in an array of
memory cells, which are grouped into blocks. The size of a block is
usually a few hundred Kilobytes. A flash block is further divided
into pages, each of which can be 512 bytes, 2 KB, or 4 KB. Note that
341(cid:7)(cid:22)(cid:16)(cid:18)(cid:12)(cid:10)(cid:19)(cid:1)(cid:23)(cid:10)(cid:16)(cid:14)
(cid:9)(cid:17)(cid:30)(cid:25)(cid:18)(cid:12)(cid:10)(cid:19)(cid:1)(cid:23)(cid:10)(cid:16)(cid:14)
(cid:6)(cid:21)(cid:28)(cid:10)(cid:19)(cid:18)(cid:13) (cid:23)(cid:17)(cid:30)(cid:25)(cid:18)(cid:12)(cid:10)(cid:19)(cid:1)(cid:23)(cid:10)(cid:16)(cid:14)
(cid:29)(cid:24)(cid:18)(cid:26)(cid:14)
(cid:22)(cid:28)(cid:14)(cid:24)(cid:29)(cid:24)(cid:18)(cid:26)(cid:14)
(cid:2)
(cid:3)
(cid:29)(cid:24)(cid:18)(cid:26)(cid:14)
(cid:2)
(cid:22)(cid:28)(cid:14)(cid:24)(cid:29)(cid:24)(cid:18)(cid:26)(cid:14)
(cid:2)
(cid:3)
(cid:2)
(cid:3)
Coordinator
Start Activity
BoltAgent
Request 
Commodity  Service
Serve
Commodity  Service
Is BoltAgent
No
Yes
Return
Return
Flash Snapshot
Memory Snapshot
Find Bound Service
(cid:2)
(cid:32)(cid:10)(cid:33)(cid:1)(cid:6)(cid:21)(cid:31)(cid:23)(cid:19)(cid:10)(cid:12)(cid:14)(cid:1)(cid:27)(cid:23)(cid:13)(cid:10)(cid:26)(cid:14)(cid:1)(cid:22)(cid:21)(cid:1)(cid:5)(cid:4)(cid:4)(cid:25)
(cid:3)
(cid:32)(cid:11)(cid:33)(cid:1)(cid:8)(cid:27)(cid:26)(cid:31)(cid:22)(cid:15)(cid:31)(cid:23)(cid:19)(cid:10)(cid:12)(cid:14)(cid:1)(cid:27)(cid:23)(cid:13)(cid:10)(cid:26)(cid:14) (cid:22)(cid:21)(cid:1)(cid:15)(cid:19)(cid:10)(cid:25)(cid:17)(cid:1)(cid:20)(cid:14)(cid:20)(cid:22)(cid:24)(cid:30)
BoltFTL
Yes
First 
Request
No
Return
Save
Save or 
Restore
Restore
BoltOS
Figure 1: Comparison of an overwrite operation between
HDD and flash memory.
Return
Flash Restoration
Memory Restoration
Figure 3: Bolt work-flow.
File System
I/O with LPA
Flash Translation Layer
I/O with PPA
NAND Flash Memory
Figure 2: The architecture of a flash-based storage system
using FTL. LPA: logical page addresses, PPA: physical page
addresses.
reading/writing flash is usually performed on the basis of pages,
and erasure can only be performed on a block basis.
Compared to conventional mechanical HDDs, flash memory has
completely different characteristics. First, a flash page cannot be
re-programmed before it has been erased. However, since erase
operations can only be performed on a block basis, overwriting a
small page requires erasing a large block. This in return, requires
copying out the valid data in the block, and writing them back after
the block has been erased, leading to significant write amplification.
To resolve such an issue, flash memory usually implements an out-
of-place update mechanism, in which when a page is overwritten,
it simply stores the new data to a new empty page, and marks the
old page as invalid. The invalid pages will be cleaned and the space
will be reclaimed later by garbage collection (GC). Figure 1 shows
a concrete example: For HDDs, when an over-write happens, the
same physical storage is directly updated with the newly written
data B. For flash memory however, to handle an overwrite, it places
the newly written data B on a new physical page, and marks the page
that previously stores A as invalid. GC is periodically performed to
reclaim space occupied by invalid pages following these steps [42]:
(1) select those blocks which satisfy certain reclaim criteria (e.g., the
number of invalid pages exceeds a threshold) as victim blocks; (2)
copy the valid data stored in the victim blocks to free blocks; (3)
erase the victim blocks.
Second, each flash block only has a limited number (e.g., 10K) of
program-erase (P/E) cycles before it is worn out and cannot reliably
store information. To prolong the service life of flash memory,
wear leveling is usually required, by which writes/erasures on flash
memory are distributed evenly across the entire flash such that no
single block will have significantly larger P/E cycles than others.
Flash translation layer. To be compatible with block-based file
systems (e.g., EXT4, FAT32), a flash storage medium is usually
used by emulating it as a block device (we call it a flash-based
block device). This can be achieved by introducing a special Flash
Translation Layer (FTL), which transparently manages the special
nature of raw flash and provides a block-based access interface. As
it is shown in Figure 2, FTL translates the logical page addresses
(LPA) from the upper layer (e.g., file systems) to the physical page
addresses (PPA) of the underlying raw flash. This requires a data
structure which can maintain the mappings between LPAs and
PPAs.
3 DESIGN
This section presents the design of Bolt. We start with describing
our threat model and assumptions. We then give an overview of
Bolt. Finally, we elaborate the design details of memory recovery
and flash recovery in Bolt, respectively.
3.1 Threat Model and Assumptions
In Bolt, we consider aggressive malware which can obtain ultimate
privilege in the normal-world Android system. That is, it can exe-
cute arbitrary code in all the privilege levels of the system, including
kernel. This can be achieved by exploiting kernel vulnerabilities to
escalate privileges. With kernel-level privilege, we assume the mal-
ware could further break protections enforced by SELinux policies.
In this way, it could obtain write permission to system partitions.
We assume that the guest system relies on TrustZone-based TEE
for security-critical services. In practice, almost all the smartphones
available in the market today are equipped with TrustZone, and
newer releases of Android have even standardized the interface be-
tween the TEE and the normal-world Android OS [18]. Bolt relies
on existing code in Android to invoke the snapshot services in the
secure world. Therefore, Bolt does not require any modifications
into the Android system. In addition, we assume that the light-
weight OS in the secure world, i.e., BoltOS, is resilient to attacks
from normal world. This is a widely acceptable assumption in the
domain of TrustZone-based security solutions, although we admit
that there are some real-world attacks that could compromise the
TrustZone secure world [27].
342Secure World
Normal World
System Apps
User Apps
S
a
v
e
R
e
s
t
o
r
e
.
.
.
l
C
a
e
n
d
a
r
E
m
a
i
l
C
l
i
e
n
t
A
D
B
.
.
.
B
o
l
t
A
g
e
n
t
l
M
a
w
a
r
e
.
.
.
Java API Framework
Native C/C++ Libraries
Android Runtime
D
r
i
v
e
r
i
F
n
g
e
r
p
r
i
n
t
M
o
n
i
t
o
r
.
.
.
Linux 
Kernel
i
B
n
d
e
r
D
i
s
p
a
y
l
D
r
i
v
e
r
T
Z
Flash
BoltFTL
Android 
Device
BUS
SCSI
ADB
RAM