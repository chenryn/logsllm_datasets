static void
my_ExecutorEnd(QueryDesc *queryDesc)
{
Assert(query != NULL);
if (superuser())
elog(LOG, "superuser %s fired this query %s",
GetUserNameFromId(GetUserId()),
query);
if (prev_ExecutorEnd)
prev_ExecutorEnd(queryDesc);
else
standard_ExecutorEnd(queryDesc);
}
28
This function first checks if the user is a superuser. If
he is, it calls elog() to log the query and the
username.
Then, it executes the previous ExecutorEnd_hook if
there was one.
superuser(), GetUserNameFromId, and GetUserId
are functions provided by PostgreSQL.
Writing an ExecutorEnd_hook
Finally, uninstall the hook
●
void _PG_fini(void)
{
ExecutorEnd_hook = prev_ExecutorEnd;
}
29
And this last function sets the hook with the previous
ExecutorEnd_hook.
check_password hook details
Get control
●
– When CREATE/ALTER USER is executed
– But before commiting
Usefull to
●
– Check the password according to some
enterprise rules
– Log change of passwords
– Disallow plain text passwords
Major issue
●
– Less effective with encrypted passwords :-/
30
The check_password hook enables an extension to
get control when a user executes a CREATE USER
or ALTER USER query. It gets control before the
statement is commited.
It's pretty usefull to check the password according to
some enterprise rules. It can be used to log
changes of passwords, and to deny using plain text
passwords in CREATE/ALTER USER statements.
It also has a major drawback: it's quite less effective
with encrypted passwords. It's much more difficult
and time consuming to check the password against
a plain text dictionary because you need to
compute the MD5 checksum for each word, and
compare the result to the encrypted password.
check_password hook use
Usefull to check password strength
●
Already used by
●
– passwordcheck
31
The main use of this hook is to check password
strength.
Hence, the only extension known now is
passwordcheck, which is a contrib module available
in the PostgreSQL distribution. It makes a few
checks to be sure the password is not too weak. If
you want to use it, make sure you read the source
to make the changes you want, so that it really stick
to your entreprise rules. Using Cracklib is quite
easy to, just a few lines to uncomment.
check_password_hook function
Five parameters
●
– const char *username, const char *password,
int password_type, Datum validuntil_time,
bool validuntil_null
password_type
●
– PASSWORD_TYPE_PLAINTEXT
– PASSWORD_TYPE_MD5
32
This hook function takes much more parameters than
the previous one.
Username and password are self explanatory.
password_type allows the hook function to know if it
is an encrypted password or a plain text one. An
encrypted password is always encrypted with MD5.
The validuntil_* parameters give informations on the
validity timestamp limit on the password.
Writing a check_password_hook
Example: disallow plain text passwords
●
Needs two functions
●
– One to install the hook
– One to check the password type
33
For this third example, we'll disallow the use of plain
text passwords. We need two functions: one to
install the hook, one to check the password type.
Writing a check_password_hook
First, install the hook
●
void _PG_init(void)
{
check_password_hook = my_check_password;
}
34
Installing the hook is really easy. We just need to
initialize the global function pointer to our function.
We could save the previous value, but don't show
this here as we already showed that before.
Writing a check_password_hook
The hook itself:
●
– check if the password is encrypted
static void
my_check_password(const char *username,
const char *password, int password_type,
Datum validuntil_time, bool validuntil_null)
{
if (password_type == PASSWORD_TYPE_PLAINTEXT)
{
ereport(ERROR,
(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
errmsg("password is not encrypted")));
}
}
35
The hook itself is here. It only checks the password
type, and calls the ereport() function if it is a
plaintext password.
Calling ereport with an ERROR log level will cancel
the query.
func_beg details
Get control
●
– Before BEGIN block of a PL/pgsql function
Usefull to
●
– Log start of each function
– Profile functions
– Debug functions
36
The func_beg hook helps a plugin to get control at
the BEGIN statement of a PL/pgsql stored function.
Therefore, the plugin can log the use of each
function, and can help profiling and debugging the
function.
func_beg use
Modules using this hook
●
– pldebugger
– plprofiler
– log_functions
(https://github.com/gleu/log_functions)
37
Three extensions already use this hook:
pldebugger provides a debugger for PL/pgsql
●
functions
plprofiler provides a profiler for PL/pgsql functions
●
log_functions, available on GitHub, allows to log the
●
use of each functions, its duration, and the
duration of each statement.
func_beg function
Two parameters
●
– f (PLpgSQL_execstate *estate,
PLpgSQL_function *func)
estate is a complete structure described in
●
src/pl/plpgsql/plpgsql.h
func is a complete structure described in
●
src/pl/plpgsql/plpgsql.h
– Name, OID, return type, ...
38
The func_beg hook function requires two parameters:
a PLpgSQL_execstate structure, and a
PLpgSQL_function structure.
The first one gives lots of informations on the
execution state of the function and the second one
gives informations on the function being executed
(name, oid, etc.).
Writing a func_beg
Example: log each function executed
●
Needs two functions
●
– One to install the hook
– Another one to log the function name
39
Here is an example of a new extension using the
func_beg hook.
Our example will log each function executed.
We need two functions:
The first one will install the hook ;
●
The second one will log the function name.
●
Writing a func_beg
First, initialize the hook
●
static PLpgSQL_plugin plugin_funcs = { my_func_beg };
void _PG_init(void)
{
PLpgSQL_plugin ** var_ptr = (PLpgSQL_plugin **)
find_rendezvous_variable("PLpgSQL_plugin");
*var_ptr = &plugin_funcs;
}
void load_plugin(PLpgSQL_plugin *hooks)
{
hooks->func_beg = my_func_beg;
}
40
The initialization of the hook must happen in the
_PG_init function. This function is called when
PostgreSQL loads the shared library.
It's a little bit more complicated than the rest of our
examples.
Writing a func_beg
Log function name
●
static void my_func_beg(PLpgSQL_execstate *estate,
PLpgSQL_function *func)
{
elog(LOG, "Execute function %s", func->fn_name);
}
41
Here is the function that does the actual work.
It simply calls elog to log the execution of the
function, and adds the name of the function (found
in the func structure).
Compiling hooks
Usual Makefile
●
MODULE_big = your_hook
OBJS = your_hook.o
ifdef USE_PGXS
PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
else
subdir = contrib/your_hook
top_builddir = ../..
include $(top_builddir)/src/Makefile.global
include $(top_srcdir)/contrib/contrib-global.mk
endif
42
Compiling hooks is really easy. You need this usual
Makefile for shared library.
You can compile the code outside of the PostgreSQL
source tree if you use PGXS. It relies on pg_config,
which may only be available if you install the -devel
package of PostgreSQL.
If you already has the source tree, you can simply put
the directory of the source in the contrib directory of
PostgreSQL. You don't need pg_config if you did
that.
Compiling hooks – example
Make is your friend (and so is pg_config)
●
$ make USE_PGXS=1
gcc -O2 -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-
statement -Wendif-labels -Wformat-security -fno-strict-aliasing -fwrapv
-fexcess-precision=standard -fpic -I. -I. -I/opt/postgresql-
9.1/include/server -I/opt/postgresql-9.1/include/internal -D_GNU_SOURCE
-c -o your_hook.o your_hook.c
gcc -O2 -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-
statement -Wendif-labels -Wformat-security -fno-strict-aliasing -fwrapv
-fexcess-precision=standard -fpic -shared -o your_hook.so
only_encrypted_passwords.o -L/opt/postgresql-9.1/lib -Wl,--as-needed -Wl,-
rpath,'/opt/postgresql-9.1/lib',--enable-new-dtags
Can't use PGXS with PL/pgsql plugins
●
– But will be possible in 9.2 (thanks to
Heikki for working on the patch)
43
To compile outside of the PostgreSQL source tree,
add USE_PGXS=1 to the make command.
Remember you need to have the pg_config tool in
your PATH.
You don't need to set this environment variable if you
had put the source code inside the contrib directory
of the PostgreSQL source tree.
Installing hooks – from source
Make is still your friend
●
$ make USE_PGXS=1 install
/bin/mkdir -p '/opt/postgresql-9.1/lib'
/bin/sh /opt/postgresql-9.1/lib/pgxs/src/makefiles/../../config/install-sh -c
-m 755 your_hook.so '/opt/postgresql-9.1/lib/your_hook.so'
44
You'll still use make to install the shared library.
PGXS
It's better to rely only on PGXS (if possible)
●
Makefile looks like this:
●
MODULE_big = your_hook
OBJS = your_hook.o
PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
So much simpler...
●
45
Using hooks with
shared_preload_libraries
Install the shared library
●
In postgresql.conf
●
– shared_preload_libraries
– And possibly other shared library GUCs
Restart PG
●
46
To use a hook, you first need to install the shared
library.
After that, you need to change the configuration in
the postgresql.conf file. There is at least one GUC
to change (shared_preload_libraries). It consists on
a list of library names, separated by commas. For
example shared_preload_libraries =
'pg_stat_statements,pg_log_userqueries'
Don't forget to uncomment the line if it's commented.
Then, the only remaining work is to restart
PostgreSQL.
Using hooks – example
Install the hook...
●
In postgresql.conf
●
shared_preload_libraries = 'only_encrypted_passwords'
Restart PostgreSQL
●
$ pg_ctl start
server starting
2012-01-28 16:01:32 CET LOG: loaded library "only_encrypted_passwords"
47
Here is example showing how to install the
only_encrypted_password shared library, that used
the checkpassword_hook.
Using hooks – example
Use the hook...
●
postgres=# CREATE USER u1 PASSWORD 'supersecret';
ERROR: password is not encrypted
postgres=# CREATE USER u1 PASSWORD 'md5f96c038c1bf28d837c32cc62fa97910a';
CREATE ROLE
postgres=# ALTER USER u1 PASSWORD 'f96c038c1bf28d837c32cc62fa97910a';
ERROR: password is not encrypted
postgres=# ALTER USER u1 PASSWORD 'md5f96c038c1bf28d837c32cc62fa97910a';
ALTER ROLE
48
And here is an example that shows its use.
Without an encrypted password, the CREATE or
ALTER USER statement will fail, and our error
message will appear.
With an encrypted password, everything work fine, as
usual.
Using hooks with LOAD statement
Install the shared library
●
LOAD the library
●
... and use it
●
49
You're not required to preload a library. You can load
it when you feel interested by its feature. It won't
work for all libraries because some require shared
memory which is only given at startup time.
To load a shared library, use the SQL statement
LOAD.
Using hooks – example
Install the hook...
●
Create the function, and use it:
●
postgres=# CREATE FUNCTION f1() RETURNS boolean LANGUAGE plpgsql AS $$
postgres$# BEGIN
postgres$# PERFORM pg_sleep(5);
postgres$# RETURN true;
postgres$# END
postgres$# $$;
CREATE FUNCTION
hooks=# SET client_min_messages TO log;
LOG: duration: 0.132 ms statement: SET client_min_messages TO log;
SET
hooks=# SELECT f1();
LOG: duration: 5003.180 ms statement: SELECT f1();
f1
----
t
(1 row)
50
In this example, we create a PL/pgsql function. Then
we set client_min_messages to the LOG level. And
finally we execute our function. Nothing special
here.
Using hooks – example
LOAD the shared library, and use it...
●
hooks=# LOAD 'logplpgsql';
LOG: duration: 0.373 ms statement: LOAD 'logplpgsql';
LOAD
hooks=# SELECT f1();
LOG: Execute function f1
LOG: duration: 5001.466 ms statement: SELECT f1();
[...]
hooks=# SELECT f1() FROM generate_series(1, 5);
LOG: Execute function f1
LOG: Execute function f1
LOG: Execute function f1
LOG: Execute function f1
LOG: Execute function f1
LOG: duration: 25006.701 ms statement: SELECT f1() FROM generate_series(1,
5);
[...]
51
Now, we load the shared library logplpgsql with the
LOAD statement.
We execute the PL/pgsql function, and we see new
LOG messages. The shared library did its work.
9.2 hooks
One old hook with enhanced capability
●
PGXS support for PL/pgsql hooks
●
Two new hooks
●
– A logging hook
– And another planer hook
52
9.2 – Enhanced
object_access_hook
DROP statement support for
●
object_access_hook
Used by sepgsql
●
53
9.2 hooks – the logging hook
Logging hook, by Martin Pihlak
●
– emit_log_hook
– Intercept messages before they are sent to the
server log
– Custom log filtering
– Used by pg_journal
(http://www.pgxn.org/dist/pg_journal/0.1.0/)
54
The logging hook was written by Martin Pihlak. The
main idea behind this hook is to send logs to
something else than PostgreSQL logging collector
or syslog. It allows filtering, and writing to different
log files.
9.2 hooks – the planner hook
Planner hook, by Peter Geoghegan
●
– post_parse_analyze_hook
– Get control at end of parse analysis
– Query normalisation within pg_stat_statements
55
The post_parse_analyze_hook was written by Peter
Geoghegan while he was working on a feature for
the pg_stat_statements contrib module.
This hook helps to get control at the end of the parse
analysis. It allows query normalisation with
pg_stat_statements.
Conclusion
Hooks are an interesting system to extend the
●
capabilities of PostgreSQL
Be cautious to avoid adding many of them
●
We need more of them :-)
●
Examples and slides available on:
●
– https://github.com/gleu/Hooks-in-PostgreSQL
56
|---|---|
| 0 | Hooks in PostgreSQL
Hooks in PostgreSQL   |
| 1 | 1 |