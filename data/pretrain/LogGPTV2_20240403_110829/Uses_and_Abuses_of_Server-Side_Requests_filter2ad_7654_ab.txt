reason, our classiﬁcation cannot be considered a taxonomy. Furthermore, our
classiﬁcation is based on the current knowledge of SSR abuse which may change.
However, while target and control dimensions covers all possible combinations,
ﬂaw and behavior dimensions are an enumeration and thus may be incomplete.
As the popularity of the SSR pattern increases, new types of vulnerabilities and
behaviors can be detected. Nevertheless, new discoveries can be used to extend
both ﬂaws and behaviors dimensions. In the rest of this section, we describe each
category in more detail.
*
*
*
*
*
+
+
+
+
+
Fig. 2. SSRs classiﬁcation
Uses and Abuses of Server-Side Requests
399
3.1 Flaw-Based Classiﬁcation
The ﬁrst classiﬁcation is based on the type of ﬂaw of S. A ﬂaw can occur when
S accepts and processes inputs from C, and when S accepts and processes the
resource resES. This classiﬁcation includes known vulnerabilities, i.e., forgery
and information disclosure vulnerabilities of the CWE database and OnSec clas-
siﬁcation. Additionally, we extend it with a new class of vulnerabilities called
insuﬃcient security policy enforcement.
Insuﬃcient Security Policy Enforcement—An HTTP conversation between
the browser of C and ES can involve diﬀerent security policies. For exam-
ple, C may use URL-based reputation lists to avoid visiting malicious pages.
Similarly, the server may restrict access to its resources, e.g., by using the
Access-Control-Allow-Origin header (ACAO, for short). The problems arise
when S acts as an intermediary and it fails to enforce the aforementioned poli-
cies. We distinguish two types of this ﬂaw, according to which side of the security
policy is not being enforced. However, as SSRs are used to bypass the SOP for
CORs, SSR services suﬀer by design from the server-side variant of this ﬂaw.
For this reason, we focus on client-side security policies. While this ﬂaw is not
a vulnerability per se, as we will see in Sect. 4.1, insuﬃcient client-side security
policy enforcement is the root cause of a class of attacks targeting C that we
call Web Origin Laundering attacks.
Forgery—SSR forgeries occur when S does not properly validate the user
input that is used to generate the SSR, e.g., XML documents, PDF ﬁles, and
URLs. SSR forgeries encompass all the currently known SSRF vulnerabilities.
More speciﬁcally, this regroups and reorganizes ﬂaws from Common Weak-
nesses Enumeration (CWE-113, CWE-661, CWE-829) [25], OnSec [16], and
Polyakov et al. [22] which were exploited in documented attacks, i.e., against
SAP NetWeaver [22], Google+ [1,27], and Facebook [27]. Our classiﬁcation also
includes the TCPDF bug1. Besides these vulnerabilities, our classiﬁcation intro-
duces the class of improper URL validation vulnerabilities, which supersedes the
improperly-called class of SSRF ﬂaws (CWE-918). This group of ﬂaws occurs
when S does not validate user-provided URLs, e.g., rejecting URLs with unex-
pected URL schemes (e.g., file://), blacklisted domains, or invalid characters.
Then, our classiﬁcation considers two special cases of improper URL validation,
i.e., improper enforcement of expected destination and improper neutralization
of CRLF in HTTP headers (CWE-113). Improper enforcement of expected des-
tination occurs when S does not suﬃciently validate that the URL refers to an
expected destination [25]. Improper neutralization of CRLF in HTTP headers
occurs when software fails to remove the CR and LF characters from input data,
such that an attacker can inject HTTP headers or smuggle HTTP requests.
Information Gathering—A service S can unintentionally disclose sensitive
information of ES to an attacker. This class of vulnerabilities includes SSR vul-
nerabilities of the 2xx group of the CWE catalog, i.e., (i) improper neutralization
1 See bug #1005, http://sourceforge.net/projects/tcpdf/ﬁles/CHANGELOG.TXT.
400
G. Pellegrino et al.
of error messages and (ii) side channels. The former type occurs when S reveals
information about exceptional behavior of ES in resS. For example, S may
return an error message to C detailing the reasons why ES is not reachable or
the target resource is not available. Side channels occur when S unwillingly leaks
information about ES. A typical side channel can be caused by a noticeable dif-
ference in the response time between req(urlES) and resS or by the variation in
the type and size of the responses.
3.2 Behavior-Based Classiﬁcation
SSRs can also be classiﬁed according to the behavior of S. We observed seven
distinct behaviors that capture the way a service can be abused. While some of
these may seem legitimate in isolation, we will show that their combination can
lead to sophisticated attacks.
Proxy—S acts as a proxy when it returns resES to C. We distinguish proxy
services as transparent (when resES is forwarded to C without any modiﬁcation)
or non-transparent (when, for example, resES is embedded inside resS).
Open Origin Policy—An open origin policy service (OOP) always returns the
least restrictive ACAO:* header, ignoring the actual value (if any) that is set by
ES. OOP services allow bypassing SOP for CORs (if ES did not include the
ACAO header) and any cross-origin resource sharing policy.
Storage—A storage service can be used to store and retrieve resources. That
is, S fetches resES from ES and stores the resource locally. Then, S returns an
ID to C for the resource that can be later used to retrieve resES.
Ampliﬁer—An ampliﬁer service can increase the number of SSRs and/or the
amount of data sent in SSRs as compared to CSRs. We designate ampliﬁers as
request ampliﬁers (when they increase the number of requests) or data ampliﬁers
(when they increase the size of each request or response).
Bridge—A bridge service connects diﬀerent layers of a protocol stack and allows
S to send packets to non-HTTP services. With reference to Fig. 1a, when S
processes a crafted URL, instead of generating an HTTP request, it opens a
TCP connection and sends raw data to ES. This behavior is often the result of
forgery vulnerabilities, e.g., improper URL validation.
Interpreter—An interpreter service uses HTTP clients capable of interpreting
JavaScript code. For instance, S can be used to control the diﬀerent parts of a
more complex attack, or to perform any computations on the attacker’s behalf.
Probe—A probe service can be used to collect information about an external
service ES. Information can be leaked to C over side channels. Depending on
the information leaked, probe services can be used to perform port scanning,
host discovery, or application ﬁngerprinting. This type of service is the result of
two ﬂaws: forgery, i.e., accepting custom TCP ports, and information gathering.
Uses and Abuses of Server-Side Requests
401
3.3 Control-Based Classiﬁcation
The third SSRs classiﬁcation is according to the control an attacker has on the
content of SSRs and responses generated by S. In particular, we distinguish the
control over the destination and the content of SSRs. The destination consists of
the domain or IP address of the server, the HTTP Host header, and the path of
the HTTP request, whereas the content of a request covers the request parame-
ters and the body. This classiﬁcation supersedes Polyakov’s classiﬁcation [22] as
we add control over the response. For the response, we consider only the content,
i.e., the body of the HTTP response resS.
3.4 Target-Based Classiﬁcation
Finally, we examine who can be the target of an SSR-based attack. We distin-
guish between attacks against the client C, the SSR service S, and the remote
service ES. Most of the vulnerabilities discovered by prior work target ES, such
as the vulnerabilities on Facebook and Google services [27], the XXE on SAP
NetWeaver [22], and the vulnerability of DB4Web (CVE-2002-1484) which all
allowed attacks against third-party services. We extend this threat model with
attacks against the client, such as the Web Origin Laundering attack. In addi-
tion, we deﬁne S as a potential target, e.g., of resource exhaustion attacks.
Table 1. Mapping between attacks and the four angles of our classiﬁcation: ﬂaw,
behavior, control, and target.
4 Attacks
We now instantiate our classiﬁcation and present seven attacks. Attacks are
divided into four categories: browser countermeasure evasions (Sect. 4.1), DoS
attacks (Sect. 4.2), reconnaissance (Sect. 4.3), and bridging attacks (Sect. 4.4).
Only the last two were previously known. The mapping between attacks and
our classiﬁcation (including the root cause ﬂaw) is shown in Table 1. As opposed
to the known exploitations of SSRF [12,15,16,22,27], two out of seven attacks
actually target C—an insight that should bring additional attention to SSR
abuse.
402
G. Pellegrino et al.
4.1 Web Origin Laundering
Fig. 3. The Web Origin Laundering attack.
Web browsers implement var-
ious URL-based defenses
to
protect users and data from
attacks, such as Google Safe
Browsing [9], NoScript
[13],
or AdBlock [6]. These mecha-
nisms make security decisions
based on requested URLs, e.g.,
limit the scope of JavaScript
programs or even deny the
JavaScript execution. Web origin laundering is an attack which hides resource
origins, thus bypassing URL-based defenses, leaving users exposed. With refer-
ence to our threat model, this is an attack against C, i.e., risk R3. First, C
requests a resource of ES via S. Note that the victim’s browser is not aware of
the fact that the request of step 1 contains the URL of a resource of ES. Then,
S fetches the resource from ES and returns it to C (steps 2–4). Finally, the web
browser veriﬁes the origin of the resource to enforce security mechanisms. Unfor-
tunately, the browser will falsely assume that S is the origin, possibly leading
to a wrong decision in the security checks. We now preset two instances of this
attack to bypass browser countermeasures.
Attack 1.1—With reference to Fig. 3, the attacker prepares a URL that is
distributed to C. For example, the URL refers to a proxy service to fetch mali-
cious content hosted by ES, e.g., http://ssr.com/?url=host.com/mal.html. The
attacker sends this URL to C, e.g., via phishing email, or linking it in forums
and social networks. The victim clicks on the URL and, as a result, her browser
veriﬁes whether the URL is blacklisted. As ssr.com is not blacklisted, C sends
message 1 to S. S extracts the URL from the parameter url, and fetches the
malicious content at host.com/mal.html. Finally, it returns the malicious con-
tent to C. We have successfully performed this attack, bypassing the Google
Safe Browsing mechanism as implemented by Google Chrome 43.0.2357.130 and
Mozilla Firefox 39.0. In these attacks, we have used two proxy services to relay
known phishing pages, drive-by download pages, and other malicious content
including malware binaries (i.e., EICAR Standard Anti-Virus Test File and
Virus.Win32.Virut).
Researchers have recently found criminals using a similar technique to dis-
tribute links to phishing pages. The attacker distributes a Google URL that
redirected to the malicious target2. However, browser countermeasures can dis-
cover the attempt to redirect the user to a malicious domain and then block the
attack. Furthermore, this attack is limited only to pages indexed by Google. Our
attack does not rely on redirect but instead on SSRs which hide the true origin
of the malicious content. Finally, an additional conﬁrmation of the severity of
2 See
https://isc.sans.edu/diary/How+Malware+Campaigns+Employ+Google+
Redirects+and+Analytics/19843.
Uses and Abuses of Server-Side Requests
403
this threat was provided in a recent NoScript bypass attack based on a SSRF
vulnerability in the content delivery network of Akamai3.
Attack 1.2 (Escaping Content Dispositions)—Attack 1.1 can be blocked
by the Content-Disposition response header of S. This header suggests to a
browser not to display the returned resource to the user. We will discuss the use
of this header in Sect. 6. However, even in presence of the content disposition
header, it is still possible to deliver and display malicious content to the user.
Consider the following JavaScript code embedded in a malicious web page hosted
by a third-party service:
1 var malware = " h t t p : / / h o s t . c o m / m a l . h t m l " ;
2 var c o r = new XMLHttpRequest ( ) ;
3 c o r . o n r e a d y s t a t e c h a n g e=function ( ) {
4 var c t = t h i s . g e t R e s p o n s e H e a d e r ( " c o n t e n t - t y p e " )
5 window . l o c a t i o n = " d a t a : " + c t " , " + encodeURIComponent ( c o r . r e s p o n s e T e x t ) ;
6 }
7 c o r . open ( " G E T " , " h t t p : / / s s r . c o m / ? u r l = " + encodeURIComponent ( malware ) ,
8 c o r . s e n d ( ) ;
f a l s e ) ;
The URL of the malicious resource, i.e., urlES, is in the variable malware (Line
1) which is retrieved with an asynchronous request (Lines 2 and 7–8). Note that
the URL used in the Ajax request is of the SSR service S (line 7). If the attacker
directly used the value in malware (line 8), the attempt to reach a malicious
server RE would be detected (e.g., by Google Safe Browsing). Then, once the
malicious resource is fetched, the JavaScript program transforms it into a data
URL. Such URL does not point to a resource, but instead contains the resource
within the URL itself. Finally, the browser is directed to the data URL (line 5)
and the malicious content is displayed to the user. We have developed proofs
of concept of these attacks and bypassed the Google Safe Browsing mechanism
of Chrome and Firefox. To this end, we used a proxy service which returned
the Content-Disposition response header. Similarly to the previous attack,
we used URLs of real phishing pages and binaries of actual malware.
4.2 Denial of Service
We now present three scenarios in which SSR is abused to perform DoS attacks
against S. We group these attacks into two categories: domain blacklisting and
resource exhaustion.
Attack 2.1 (DoS via Domain Blacklisting)— As discussed before, browsers
prevent users from visiting websites that are known to host malicious content.
An attacker may be able to poison these blacklists to block benign sites that
expose a proxy behavior by using the web origin laundering technique. To this
end, the attacker prepares a URL for the proxy service that contains the URL
of a malicious page, and submits it to the blacklist operator (e.g., to Google in
the case of Safe Browsing) to initiate a scan. Since the malicious content seems