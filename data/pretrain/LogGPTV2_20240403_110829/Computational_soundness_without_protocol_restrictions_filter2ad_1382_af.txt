Internationalisation Programme DoRa, by the European Re-
gional Development Fund through the Estonian Center of
Excellence in Computer Science, EXCS, by the European
Social Fund through the Estonian Doctoral School in In-
formation and Communication Technology. Michael Backes
was supported by CISPA (Center for IT-Security, Privacy
and Accountability), and by an ERC starting grant. Part
of the work was done while Ankit Malik was at MPI-SWS,
and while Dominique Unruh was at the Cluster of Excellence
“Multimodal Computing and Interaction”.
APPENDIX
A.
IMPLEMENTATION CONDITIONS
1. A is an implementation of M in the sense of [4] (in par-
ticular, all functions Af (f ∈ C ∪ D) are polynomial-
time computable).
2. There are disjoint and eﬃciently recognizable sets of
bitstrings representing the types nonces, ciphertexts,
encryption keys, decryption keys, signatures, veriﬁca-
tion keys, signing keys, pairs, and payload-strings. The
709set of all bitstrings of type nonce we denote Noncesk.13
(Here and in the following, k denotes the security pa-
rameter.)
3. The functions Aenc, Aek , Adk , Asig , Avk , Ask , and Apair
are length-regular. We call an n-ary function f length
regular if |mi| = |m′
i| for i = 1, . . . , n implies |f (m)| =
|f (m′)|. All m ∈ Noncesk have the same length.
4. AN for N ∈ N returns a uniformly random r ∈
Noncesk.
5. Every image of Aenc is of type ciphertext, every image
of Aek and Aekof is of type encryption key, every image
of Adk is of type decryption key, every image of Asig is
of type signature, every image of Avk and Avkof
is of
type veriﬁcation key, every image of Aempty , Astring 0 ,
and Astring 1 is of type payload-string.
{0, 1}∗
we
∈
all m1, m2
have
Afst (Apair (m1, m2)) = m1 and Asnd (Apair (m1, m2)) =
m2. Every m of type pair is in the range of Apair . If
m is not of type pair, Afst (m) = Asnd (m) = ⊥.
payload-string
type
all m of
that Aunstringi (Astringi (m))
we
have
= m and
Aunstringi (Astringj (m)) = ⊥ for i, j ∈ {0, 1}, i 6= j.
For m = empty or m not of type payload-string,
Aunstring0 (m) = Aunstring1 (m) = ⊥. Every m of type
payload-string is of the form m = Astring 0 (m′) or
m = Astring 1 (m′) or m = empty for some m′ of type
payload-string. For all m of type payload-string, we
have |Astring 0 (m)|, |Astring 1 (m)| > |m|.
6. For
7. For
8. Aekof (Aenc(p, x, y)) = p for all p of type encryption
key, x ∈ {0, 1}∗, y ∈ Noncesk. Aekof (e) 6= ⊥ for any e
of type ciphertext and Aekof (e) = ⊥ for any e that is
not of type ciphertext.
9. Avkof (Asig (Ask (x), y, z)) = Avk (x) for all y ∈ {0, 1}∗,
x, z ∈ Noncesk. Avkof (e) 6= ⊥ for any e of type sig-
nature and Avkof (e) = ⊥ for any e that is not of type
signature.
10. Aenc(p, m, y) = ⊥ if p is not of type encryption key.
11. Adec(Adk (r), m) = ⊥ if r ∈ Noncesk and Aekof (m) 6=
(This implies that the encryption key is
Aek (r).
uniquely determined by the decryption key.)
12. Adec(d, c) = ⊥ if Aekof (c) 6= Aekofdk (d) or Aekofdk (d) =
⊥.
13. Adec(d, Aenc(Aekofdk (e), m, r)) = m if r ∈ Noncesk and
d := Aekofdk (e) 6= ⊥.
14. Aekofdk (d) = ⊥ if d is not of type decryption key.
15. Aekofdk (Adk (r)) = Aek (r) for all r ∈ Noncesk.
16. Avkofsk (s) = ⊥ if s is not of type signing key.
17. Avkofsk (Ask (r)) = Avk (r) for all r ∈ Noncesk.
18. Adec(Adk (r), Aenc(Aek (r), m, r′)) = m for all r, r′ ∈
Noncesk.
19. Averify (Avk (r), Asig (Ask (r), m, r′)) = m for all r, r′ ∈
Noncesk.
20. For all p, s ∈ {0, 1}∗ we have that Averify (p, s) 6= ⊥
implies Avkof (s) = p.
21. Aisek (x) = x for any x of type encryption key.
Aisek (x) = ⊥ for any x not of type encryption key.
22. Aisvk (x) = x for any x of type veriﬁcation key.
Aisvk (x) = ⊥ for any x not of type veriﬁcation key.
23. Aisenc(x) = x for any x of type ciphertext. Aisenc(x) =
⊥ for any x not of type ciphertext.
13This would typically be the set of all k-bit strings with a
tag denoting nonces.
24. Aissig (x) = x for any x of type signature. Aissig (x) = ⊥
for any x not of type signature.
25. We deﬁne an encryption scheme (KeyGen, Enc, Dec) as
follows: KeyGen picks a random r ← Noncesk and re-
turns (Aek (r), Adk (r)). Enc(p, m) picks a random r ←
Noncesk and returns Aenc(p, m, r). Dec(k, c) returns
Adec(k, c). We require that then (KeyGen, Enc, Dec) is
PROG-KDM secure.
26. Additionally, we require that (KeyGen, Enc, Dec) is
malicious-key extractable.
27. We deﬁne a signature scheme (SKeyGen, Sig, Verify) as
follows: SKeyGen picks a random r ← Noncesk and
returns (Avk (r), Ask (r)).
Sig(p, m) picks a random
r ← Noncesk and returns Asig (p, m, r). Verify(p, s, m)
returns 1 iﬀ Averify (p, s) = m. We require that then
(SKeyGen, Sig, Verify) is strongly existentially unforge-
able.
28. For all e of type encryption key and all m, m′ ∈ {0, 1}∗,
the probability that Aenc(e, m, r) = Aenc(e, m′, r′) for
uniformly chosen r, r′ ∈ Noncesk is negligible.
29. For all rs ∈ Noncesk and all m ∈ {0, 1}∗, the probabil-
ity that Asig (Ask (rs), m, r) = Asig (Ask (rs), m, r′) for
uniformly chosen r, r′ ∈ Noncesk is negligible.
30. Aekofdk is injective. (I.e., the encryption key uniquely
determines the decryption key.)
31. Avkofsk is injective. (I.e., the veriﬁcation key uniquely
determines the signing key.)
B. REFERENCES
[1] M. Abadi and A. D. Gordon. A calculus for
cryptographic protocols: The spi calculus. In Proc. 4th
ACM Conference on Computer and Communications
Security, pages 36–47, 1997.
[2] M. Abadi and P. Rogaway. Reconciling two views of
cryptography: The computational soundness of formal
encryption. In Proc. 1st IFIP International
Conference on Theoretical Computer Science, volume
1872 of LNCS, pages 3–22. Springer, 2000.
[3] P. Ad˜ao, G. Bana, J. Herzog, and A. Scedrov.
Soundness and completeness of formal encryption:
The cases of key cycles and partial information
leakage. Journal of Computer Security, 17(5):737–797,
2009.
[4] M. Backes, D. Hofheinz, and D. Unruh. CoSP: A
general framework for computational soundness
proofs. In ACM CCS 2009, pages 66–78, November
2009.
[5] M. Backes, D. Hofheinz, and D. Unruh. CoSP: A
general framework for computational soundness
proofs. IACR Cryptology ePrint Archive 2009/080,
2009. Version from 2009-02-18.
[6] M. Backes, M. Maﬀei, and D. Unruh. Computationally
sound veriﬁcation of source code. In ACM CCS 2010,
pages 387–398. ACM Press, October 2010. Preprint on
IACR ePrint 2010/416.
[7] M. Backes, A. Malik, and D. Unruh. Computational
Soundness without Protocol Restrictions. IACR ePrint
archive, 2012. Full version of this paper.
[8] M. Backes and B. Pﬁtzmann. Symmetric encryption in
a simulatable Dolev-Yao style cryptographic library.
In Proc. 17th IEEE Computer Security Foundations
Workshop (CSFW), pages 204–218, 2004.
710[9] M. Backes, B. Pﬁtzmann, and A. Scedrov.
Key-dependent message security under active attacks -
brsim/uc-soundness of dolev-yao-style encryption with
key cycles. Journal of Computer Security,
16(5):497–530, 2008.
[10] M. Backes, B. Pﬁtzmann, and M. Waidner. A
composable cryptographic library with nested
operations (extended abstract). In Proc. 10th ACM
Conference on Computer and Communications
Security, pages 220–230, 2003. Full version in IACR
Cryptology ePrint Archive 2003/015, Jan. 2003,
http://eprint.iacr.org/2003/015.
[11] M. Backes and D. Unruh. Computational soundness of
symbolic zero-knowledge proofs. Journal of Computer
Security, 18(6):1077–1155, 2010. Preprint on IACR
ePrint 2008/152.
[12] G. Bana and H. Comon-Lundh. Towards
unconditional soundness: Computationally complete
symbolic attacker. In P. Degano and J. Guttman,
editors, Principles of Security and Trust, volume 7215
of Lecture Notes in Computer Science, pages 189–208.
Springer Berlin / Heidelberg, 2012.
[13] D. Basin, S. M¨odersheim, and L. Vigan`o. OFMC: A
symbolic model checker for security protocols.
International Journal of Information Security, 2004.
[14] M. Bellare, D. Hofheinz, and S. Yilek. Possibility and
impossibility results for encryption and commitment
secure under selective opening. In EUROCRYPT
2009, pages 1–35, 2009.
[15] M. Bellare and P. Rogaway. Random oracles are
practical: A paradigm for designing eﬃcient protocols.
In ACM Conference on Computer and
Communications Security, pages 62–73, 1993.
[16] M. Bellare and P. Rogaway. Optimal asymmetric
encryption. In Advances in Cryptology: EUROCRYPT
’94, volume 950 of LNCS, pages 92–111. Springer,
1994.
[17] F. B¨ohl, D. Hofheinz, and D. Kraschewski. On
deﬁnitions of selective opening security. In M. Fischlin,
J. Buchmann, and M. Manulis, editors, PKC 2012,
volume 7293 of LNCS, pages 522–539. Springer, 2012.
[18] J. Camenisch, N. Chandran, and V. Shoup. A public
key encryption scheme secure against key dependent
chosen plaintext and adaptive chosen ciphertext
attacks. In A. Joux, editor, Eurocrypt 2009, volume
5479 of LNCS, pages 351–368. Springer, 2009.
[19] R. Canetti and J. Herzog. Universally composable
symbolic analysis of mutual authentication and key
exchange protocols. In Proc. 3rd Theory of
Cryptography Conference (TCC), volume 3876 of
LNCS, pages 380–403. Springer, 2006.
[20] H. Comon-Lundh, V. Cortier, and G. Scerri. Security
proof with dishonest keys. In POST, pages 149–168,
2012.
[21] V. Cortier, S. Kremer, and B. Warinschi. A survey of
symbolic methods in computational analysis of
cryptographic systems. J. Autom. Reasoning,
46(3-4):225–259, 2011.
[22] V. Cortier and B. Warinschi. Computationally sound,
automated proofs for security protocols. In Proc. 14th
European Symposium on Programming (ESOP), pages
157–171, 2005.
[23] D. Dolev and A. C. Yao. On the security of public key
protocols. IEEE Transactions on Information Theory,
29(2):198–208, 1983.
[24] S. Even and O. Goldreich. On the security of
multi-party ping-pong protocols. In Proc. 24th IEEE
Symposium on Foundations of Computer Science
(FOCS), pages 34–39, 1983.
[25] R. Kemmerer, C. Meadows, and J. Millen. Three
systems for cryptographic protocol analysis. Journal
of Cryptology, 7(2):79–130, 1994.
[26] P. Laud. Semantics and program analysis of
computationally secure information ﬂow. In Proc. 10th
European Symposium on Programming (ESOP), pages
77–91, 2001.
[27] P. Laud. Symmetric encryption in automatic analyses
for conﬁdentiality against active adversaries. In Proc.
25th IEEE Symposium on Security & Privacy, pages
71–85, 2004.
[28] G. Lowe. Breaking and ﬁxing the Needham-Schroeder
public-key protocol using FDR. In Proc. 2nd
International Conference on Tools and Algorithms for
the Construction and Analysis of Systems (TACAS),
volume 1055 of LNCS, pages 147–166. Springer, 1996.
[29] L. Mazar´e and B. Warinschi. Separating trace
mapping and reactive simulatability soundness: The
case of adaptive corruption. In P. Degano and
L. Vigan`o, editors, ARSPA-WITS 2009, volume 5511
of LNCS, pages 193–210. Springer, 2009.
[30] M. Merritt. Cryptographic Protocols. PhD thesis,
Georgia Institute of Technology, 1983.
[31] D. Micciancio and B. Warinschi. Soundness of formal
encryption in the presence of active adversaries. In
Proc. 1st Theory of Cryptography Conference (TCC),
volume 2951 of LNCS, pages 133–151. Springer, 2004.
[32] J. B. Nielsen. Separating random oracle proofs from
complexity theoretic proofs: The non-committing
encryption case. In M. Yung, editor, Advances in
Cryptology, Proceedings of CRYPTO ’02, volume 2442
of Lecture Notes in Computer Science, pages 111–126.
Springer-Verlag, 2002.
[33] L. Paulson. The inductive approach to verifying
cryptographic protocols. Journal of Cryptology,
6(1):85–128, 1998.
[34] S. Schneider. Security properties and CSP. In Proc.
17th IEEE Symposium on Security & Privacy, pages
174–187, 1996.
[35] D. Unruh. Programmable encryption and
key-dependent messages. IACR ePrint archive
2012/423, 2012.
711