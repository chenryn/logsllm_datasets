0.69 ± 0.01
0.67 ± 0.01
0.62 ± 0.01
0.57 ± 0.01
Precision
0.68 ± 0.01
0.71 ± 0.01
0.71 ± 0.01
0.68 ± 0.01
0.68 ± 0.01
0.67 ± 0.01
0.71 ± 0.01
0.69 ± 0.01
0.63 ± 0.01
0.59 ± 0.01
(a) Firefox
Recall
0.61 ± 0.01
0.64 ± 0.01
0.64 ± 0.01
0.61 ± 0.01
0.60 ± 0.01
0.58 ± 0.01
0.66 ± 0.02
0.62 ± 0.01
0.55 ± 0.02
0.49 ± 0.02
Latency (ms)
0 ± 0
5 ± 1
5 ± 3
10 ± 1
10 ± 3
10 ± 5
30 ± 1
30 ± 3
30 ± 5
30 ± 10
Accuracy
0.96 ± 0.04
0.71 ± 0.08
0.66 ± 0.09
0.79 ± 0.08
0.70 ± 0.08
0.63 ± 0.09
0.86 ± 0.07
0.62 ± 0.09
0.62 ± 0.09
0.67 ± 0.08
Precision
0.97 ± 0.05
0.74 ± 0.11
0.69 ± 0.12
0.81 ± 0.09
0.73 ± 0.10
0.67 ± 0.12
0.90 ± 0.08
0.65 ± 0.12
0.65 ± 0.12
0.71 ± 0.11
(b) curl
Recall
0.95 ± 0.06
0.65 ± 0.13
0.58 ± 0.14
0.77 ± 0.12
0.64 ± 0.13
0.56 ± 0.14
0.82 ± 0.11
0.55 ± 0.14
0.55 ± 0.14
0.58 ± 0.13
Table 3: Accuracy, precision, and recall of classifying Balboa-generated trafﬁc versus baseline for various latency settings against
various web clients (curl and Firefox). Values are given in “mean ± standard deviation” format.
context-free grammars that can encode, e.g., common net-
work protocols like HTTP. The well-known “Parrot is Dead”
paper [16] argues that such approaches are doomed to fail
due to the difﬁculty of accurately mimicking a given proto-
col, although as discussed below (and in §1) even tunneling
approaches suffer the same challenges.
Tunneling. These approaches try to avoid the “weaknesses”
of the mimicry approach by running the actual application
under-the-hood. Such approaches include Freewave [17],
DeltaShaper [3], and Castle [15]. However, as several re-
searchers have shown [14, 25, 26], even these approaches
are susceptible to distinguishing attacks due the protocol dis-
tribution differences between the circumvention system itself
and the underlying application when run on its own. This
weakness appears inherent due to the inability to perfectly
mimic the real world application behavior, or let alone know
what such a “real world distribution” is in the ﬁrst place. Bal-
boa aims to minimize this gap by having such real world
application behavior be a parameter speciﬁed by the user of
the tool.
Concurrently with this work, Barradas et al. [5] introduced
Protozoa, a tunneling approach which uses WebRTC as its
communication medium. Protozoa shares several similari-
ties to Balboa, in that it uses a form of rewriting to replace
WebRTC trafﬁc with user data. However, Protozoa is speciﬁc
for WebRTC and requires modiﬁcations to the application
source code, reducing the ﬂexibility of the tool as application
versions change, an attack vector exploited in practice [13].
It also does not replace the original video on the receiver
side, potentially leaving the approach open to trafﬁc analysis
attacks.
Trafﬁc manipulation. These approaches manipulate trafﬁc
to circumvent known censors. Recent approaches, such as
Geneva [6], have proven successful at circumventing existing
nation-state censors in several countries. However, the secu-
rity model is fundamentally different (and weaker) than the
one considered by both Balboa and tools in the mimicry and
tunneling space: trafﬁc manipulation approaches generally
assume a weak censor that monitors trafﬁc using a ﬁrewall
or deep packet inspection device, whereas Balboa considers
a potentially active censor that can apply more powerful ca-
pabilities. (Whether this more powerful censor is a realistic
threat in practice is an orthogonal question.)
Destination obfuscation. These approaches, which include
Tor and refraction networking protocols [7, 20, 27], focus on
hiding the destination website from a censor, and borrow
from the mimicry and tunneling literature in how they obfus-
cate the channel itself (e.g., Tor uses a “pluggable transport”
infrastructure for link obfuscation).
Other related work. Several CRSs either require a speciﬁc
version of an application (such as meek [12]) or otherwise
need to mimic the TLS handshake in some way. However,
Frolov and Wustrow [13] showed that this mimickry is often
easily identiﬁable due to cleartext header information sent in
the initial Client Hello message of a TLS connection—that is,
this information must exactly match what an innocuous (and
popular) application would produce. With this in mind, the
authors introduce a tool, uTLS, for automatically mimicking
existing TLS implementations.
Balboa avoids the need for a tool like uTLS by running the
(unmodiﬁed) application under-the-hood and leaving the TLS
handshake untouched. As long as the underlying protocol
used by the application remains unchanged between versions,
the application can be updated without affecting Balboa. In
particular, unlike tools like meek [12], Balboa does not need
to come bundled with a particular version of an application.
USENIX Association
30th USENIX Security Symposium    3411
Acknowledgments
This material is based upon work supported by the United
States Air Force and DARPA under Contract No. FA8750-19-
C-0085. Any opinions, ﬁndings and conclusions or recommen-
dations expressed in this material are those of the author(s)
and do not necessarily reﬂect the views of the United States
Air Force and DARPA. Distribution Statement “A” (Approved
for Public Release, Distribution Unlimited).
References
[1] Freedom on the net. https://www.freedomonthenet.
org/explore-the-map?mapview=trend. Accessed
February 10, 2020.
[2] The ICSI certiﬁcate notary. https://notary.icsi.
berkeley.edu/. Accessed January 28, 2020.
[3] Diogo Barradas, Nuno Santos, and Luís Rodrigues.
DeltaShaper: Enabling unobservable
censorship-
resistant TCP tunneling over videoconferencing streams.
Privacy Enhancing Technologies, 2017(4):1–18, 2017.
[4] Diogo Barradas, Nuno Santos, and Luís Rodrigues. Ef-
fective detection of multimedia protocol tunneling using
In USENIX Security Symposium.
machine learning.
USENIX, 2018.
[5] Diogo Barradas, Nuno Santos, Luís Rodrigues, and Vítor
Nunes. Poking a hole in the wall: Efﬁcient censorship-
resistant internet communications by parasitizing on
WebRTC. In Computer and Communications Security.
ACM, 2020.
[6] Kevin Bock, George Hughey, Xiao Qiang, and Dave
Levin. Geneva: Evolving censorship evasion strate-
gies. In Computer and Communications Security. ACM,
2019.
[7] Cecylia Bocovich and Ian Goldberg. Slitheen: Perfectly
imitated decoy routing through trafﬁc replacement. In
Computer and Communications Security. ACM, 2016.
[8] Catalin Cimpanu. Kazakhstan government is now inter-
cepting all HTTPS trafﬁc. ZDNet, July 2019.
[9] Kevin P. Dyer, Scott E. Coull, Thomas Ristenpart, and
Thomas Shrimpton. Protocol misidentiﬁcation made
easy with Format-Transforming Encryption. In Com-
puter and Communications Security. ACM, 2013.
[10] Kevin P. Dyer, Scott E. Coull, and Thomas Shrimpton.
Marionette: A programmable network-trafﬁc obfusca-
tion system. In USENIX Security Symposium. USENIX,
2015.
[11] Daniel Ellard, Alden Jackson, Christine Jones, Victo-
ria Ursula Manfredi, Timothy Strayer, Bishal Thapa, and
Megan Van Welie. Rebound: Decoy routing on asym-
metric routes via error messages. In Local Computer
Networks. IEEE, 2015.
[12] David Fiﬁeld, Chang Lan, Rod Hynes, Percy Wegmann,
and Vern Paxson. Blocking-resistant communication
through domain fronting. Privacy Enhancing Technolo-
gies, 2015(2), 2015.
[13] Sergey Frolov and Eric Wustrow. The use of TLS in
censorship circumvention. In Network and Distributed
System Security. The Internet Society, 2019.
[14] John Geddes, Max Schuchard, and Nicholas Hopper.
Cover your ACKs: Pitfalls of covert channel censorship
circumvention. In Computer and Communications Se-
curity. ACM, 2013.
[15] Bridger Hahn, Rishab Nithyanand, Phillipa Gill, and
Rob Johnson. Games without frontiers: Investigating
video games as a covert channel. In European Sympo-
sium on Security & Privacy. IEEE, 2016.
[16] Amir Houmansadr, Chad Brubaker, and Vitaly
Shmatikov. The parrot is dead: Observing unobservable
network communications. In Symposium on Security &
Privacy. IEEE, 2013.
[17] Amir Houmansadr, Thomas Riedl, Nikita Borisov, and
Andrew Singer. I want my voice to be heard: IP over
voice-over-IP for unobservable censorship circumven-
tion. In Network and Distributed System Security. The
Internet Society, 2013.
[18] Sheharbano Khattak, Tariq Elahi, Laurent Simon,
Colleen M. Swanson, Steven J. Murdoch, and Ian Gold-
berg. SoK: Making sense of censorship resistance sys-
tems. Privacy Enhancing Technologies, 2016(4):37–61,
2016.
[19] Daniel Luchaup, Kevin P. Dyer, Somesh Jha, Thomas
Ristenpart, and Thomas Shrimpton. LibFTE: A toolkit
for constructing practical, format-abiding encryption
schemes. In USENIX Security Symposium. USENIX,
2014.
[20] Milad Nasr, Hadi Zolfaghari, and Amir Houmansadr.
The waterfall of liberty: Decoy routing circumvention
that resists routing attacks. In Computer and Communi-
cations Security. ACM, 2017.
[21] Shawn Ostermann. Tcptrace. https://tcptrace.org,
2005.
[22] F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel,
B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer,
3412    30th USENIX Security Symposium
USENIX Association
an HTTP request to denote that it is Application Data and not
a Handshake record. Balboa could then use this information
to determine whether to proceed with rewriting.
B Supporting CBC-mode Ciphers
While Balboa’s current implementation only supports stream
ciphers, it is possible for Balboa to intercept TLS trafﬁc en-
crypted with a CBC-mode cipher and still operate under the
restriction that incoming trafﬁc can be processed one byte
at-a-time. We leave the implementation of the below approach
as future work.
To avoid the numerous number of attacks on CBC-mode,
modern TLS libraries use a randomly generated initialization
vector (IV) for each TLS record. Balboa can take advantage
of this as follows. For outgoing trafﬁc, Balboa can replace
the TLS record IV with the encryption (under a stream ci-
pher, with an IV from the sequence number) of the ﬁrst block
of plaintext. It can then proceed in this fashion, replacing
each subsequent block of ciphertext with the stream-cipher-
encryption of the next block of plaintext. The last block of
CBC-encrypted ciphertext can be replaced with random bytes.
The MAC can be handled as in the case for stream ciphers.
On the incoming side, because the incoming plaintext is
encrypted with a stream cipher, Balboa can decrypt it one
byte at a time. To re-encrypt the trafﬁc with a CBC-mode
cipher for the application, Balboa can pick a new random IV
to encrypt the block with, and emit this random IV. Even with
the one byte at a time requirement, by the time Balboa emits
any encrypted bytes of the plaintext it would have already
observed a full block of plaintext, enabling it to generate the
encrypted bytes. Balboa can then rewrite the outgoing MAC,
in the same manner as it would for stream ciphers, to generate
a MAC that matches the ciphertext that it just outputted (if
the incoming MAC is valid).
R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cour-
napeau, M. Brucher, M. Perrot, and E. Duchesnay.
Scikit-learn: Machine learning in Python. Journal of
Machine Learning Research, 12:2825–2830, 2011.
[23] Michael Carl Tschantz, Sadia Afroz, Anonymous, and
Vern Paxson. SoK: Towards grounding censorship cir-
cumvention in empiricism. In Symposium on Security
& Privacy. IEEE, 2016.
[24] Paul Vines and Tadayoshi Kohno. Rook: Using video
games as a low-bandwidth censorship resistant com-
munication platform. In Workshop on Privacy in the
Electronic Society. ACM, 2015.
[25] Liang Wang, Kevin P. Dyer, Aditya Akella, Thomas
Ristenpart, and Thomas Shrimpton. Seeing through
network-protocol obfuscation. In Computer and Com-
munications Security. ACM, 2015.
[26] Charles V. Wright, Lucas Ballard, Scott E. Coull, Fabian
Monrose, and Gerald M. Masson. Uncovering spoken
phrases in encrypted voice over IP conversations. ACM
Transactions on Information and System Security (TIS-
SEC), 13(4):1–30, 2010.
[27] Eric Wustrow, Scott Wolchok, Ian Goldberg, and J. Alex
Halderman. Telex: Anticensorship in the network in-
frastructure. In USENIX Security Symposium. USENIX,
2011.
[28] Oliver Yang.
of
TSC
us-
https://oliveryang.net/2015/09/
Pitfalls
age.
pitfalls-of-TSC-usage/, 2017.
[29] Stephen Yang, Seo Jin Park, and John Ousterhout.
Nanolog: A nanosecond scale logging system. In 2018
USENIX Annual Technical Conference. USENIX, 2018.
A Supporting TLS 1.3
One nice feature of TLS 1.2 is that handshake records are
distinct from application records, and are distinguished by
early bytes in the record header. However, this is not the case
for TLS 1.3: handshakes may occur at any time during a given
connection and are distinguished by the last encrypted byte
of the encrypted payload. As a result, when operating on
incoming TLS 1.3 records, Balboa does not know whether
the record should be rewritten or not.
Our proposed solution to this problem is to add functional-
ity to the sender’s plaintext rewriter to let it rewrite the ﬁrst
byte of a TLS 1.3 handshake record (which contains the TLS
record handshake type) into a form that the receiver’s rewriter
can distinguish from the rewriting of the ﬁrst plaintext byte
of an Application Data record. As an example, the rewriter
could set the high-order bit of the ﬁrst byte of the record in
USENIX Association
30th USENIX Security Symposium    3413