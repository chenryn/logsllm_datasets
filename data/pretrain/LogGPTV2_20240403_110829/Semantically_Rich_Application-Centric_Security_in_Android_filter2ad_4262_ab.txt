on permission labels enforced in the middleware reference
monitor [5]. A permission label is simply a unique text
string that can be deﬁned by both the OS and third party
developers. Android deﬁnes many base permission labels.
From an OS-centric perspective, applications are statically
assigned permission labels indicating the sensitive inter-
faces and resources accessible at run time; the permission
set cannot grow after installation. Application developers
specify a list of permission labels the application requires
in its package manifest; however, requested permissions
are not always granted.
Permission label deﬁnitions are distributed across the
framework and package manifest ﬁles. Each deﬁnition
speciﬁes “protection level.” The protection level can be
“normal,” “dangerous,” “signature,” or “signature or sys-
tem.” Upon application installation, the protection level of
requested permissions is consulted. A permission with the
protection level of normal is always granted. A permission
with the protection level of dangerous is always granted
if the application is installed; however, the user must
conﬁrm all requested dangerous permissions together. Fi-
nally, the signature protection level inﬂuences permission
granting without user input. Each application package is
signed by a developer key (as is the framework package
containing OS deﬁned permission labels). A signature
protected permission is only granted if the application
requesting it is signed by the same developer key that
signed the package deﬁning the permission label. Many
OS deﬁned permissions use the signature protection level
to ensure only applications distributed by the OS vendor
are granted access. Finally, the “signature or system”
protection level operates the same as the signature level,
but additionally the permission is granted to applications
signed by key used for the system image.
The permission label policy model is also used to pro-
tect applications from each other. Most permission label
security policy is deﬁned in an application’s package man-
ifest. As mentioned, the package manifest speciﬁes the
permission labels corresponding to the application’s func-
tional requirements. The package manifest also speciﬁes
a permission label to protect each application component
(e.g., Activity, Service, etc). Put simply, an application
may initiate IPC with a component in another (or the
same) application if it has been assigned the permission
label speciﬁed to restrict access to the target component.
342
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply. 
Security Policy
(1.) Permission
Granting Policy
(Install-time)
(2.) Interaction Policy
(Run-time)
(1.1)Protection-level
based Policy
(1.2) Signature-
based Policy
(1.3) Application 
conﬁguration 
based Policy
(2.1) Permission-
based Access 
Control Policy
(2.2) Signature-
based Policy
(2.3) Application 
(2.4) Context-based
conﬁguration 
based Policy
Policy
- Normal
- Dangerous
- Signature
- Signature or 
system
Set of signatures on 
the application
- Default allow
- Default deny
Deﬁne set of except 
signatures
Set of conﬁguration
- Other requested 
permissions
- Application version
- etc.
Permission  that 
protects component 
VS those held by 
the accessing 
application
Set of signatures 
on the opponent 
application
- Default allow
- Default deny
Deﬁne set of 
except signatures
Set of conﬁguration 
of the opponent
- Held permissions
- Application Version
- etc.
Phone's context:
Location, time, 
Bluetooth state, 
connected devices, 
data connection, 
data/call state, 
battery, etc.
Figure 3. Policy tree illustrating the example policies required by applications. The double-stroke boxes indicate support by the existing platform.
Using this policy and permission protection levels, ap-
plication developers can specify how other applications
access its components. For a more complete description
of the Android application level security policy and it’s
subtleties, see Enck et al. [6].
The permission label-based security policy stems from
the nature of mobile phone development. Manually man-
aging access control policies of hundreds (thousands) of
potentially unknown applications is infeasible in many
regards. Hence, Android simpliﬁes access control policy
speciﬁcation by having developers deﬁne permission la-
bels to access their interfaces. The developer does not
need to know about all existing (and future) applications.
Instead,
the permission label allows the developer to
indirectly inﬂuence security decisions. However, herein
lies the limitations of Android’s security framework.
IV. APPLICATION POLICIES
We explored a myriad of applications as a means of
understanding the appropriate set of policy expressibility.
An initial policy taxonomy is presented in Figure 3.
The permission-granting policy (1.) regulates permis-
sion assignment. In addition to controlling permission
granting using Android’s protection level-based policy
(1.1), an application A may require signature-based pol-
icy (1.2) to control how the permissions it declares are
granted based on the signature of the requesting applica-
tion B (A and B may be signed by different developer
keys). Instead, the policy grants (or denies) the permission
by default with an exception list that denies (grants) the
applications signed by the listed keys. An application may
also require conﬁguration-based policy (1.3) to control
permission assignment based on the conﬁguration pa-
rameters of the requesting application, e.g., the set of
requested permissions and application version.
The interaction policy (2.) regulates runtime interaction
between an application and its opponent. An application
A’s opponent
is an application B that accesses A’s
resources or is the target of an action by A, depending on
the access control rule (i.e., B is A’s opponent for rules
deﬁned by A, and A is B’s opponent for rules deﬁned by
B). Android’s existing permission-based access control
policy (2.1) provides straightforward static policy protec-
343
tion, as described in Section III. However, this policy is
coarse-grained and insufﬁcient in many circumstances.
Applications may require signature-based policy (2.2)
to restrict
the set of the opponent applications based
on their signatures. Similar to above, the default-allow
and default-deny modes are needed. With conﬁguration-
based policy (2.3), the applications can deﬁne the de-
sirable conﬁgurations of the opponent applications; for
example, the minimum version and a set of permissions
that the opponent is allowed (or disallowed). Lastly, the
applications may wish to regulate the interactions based
on the transient state of the phone. The phone context-
based policy (2.4) governs runtime interactions based on
context such as location, time, Bluetooth connection and
connected devices, call state, data state, data connection
network, and battery level. Note that initially, policy types
2.2 and 2.3 may appear identical to 1.2 and 1.3; however,
the former types also place requirements on the target
application, which cannot be expressed with 1.2 and
1.3. However, 1.2 and 1.3 are desirable, because when
applicable, they have insigniﬁcant runtime overhead.
Install-time Policy Example:
We now present two example application policies re-
lated to our motivating example, PersonalShopper, which
interacts with checkout applications, password vaults,
location-based search applications, and personal ledgers.
In our PersonalShop-
per example,
the location-based search application
(com.abc.lbs) wants to protect against an unautho-
rized leak of
location information from its “Query-
ByLocation” service. Permission granting policy can
be applied when the PersonalShopper
the
permission com.abc.perm.getloc used to protect
“QueryByLocation”. It needs application conﬁguration-
based policy to specify that
the permission
com.abc.perm.getloc to be granted, the requester
must also have the “ACCESS LOCATION” permission.
Run-time Policy Example: To ensure that the checkout
application used for payment is trusted, their signatures
must be checked. The PersonalShopper needs signature-
based policy to specify that when the source “Personal
Shopper” (com.ok.shopper) starts an Activity with
action “ACTION PAY”, the policy ensures resolved ap-
plications are signed by keys in a given set.
requests
for
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply. 
a
policy 
ﬁle
apk
package
Application
Package
SAINT
Installer
App A
App B
b
c
1
SAINT
AppPolicy 
Provider
2
3
5
SAINT
Mediator
4
Applications
Android 
Middleware
Android's  Permission Check
Linux Kernel
Figure 4. Saint enforcement - Saint enhances the application installation
process (a-c) with additional permission granting policies and mediates
component IPC (1-5) to enforce interaction policies speciﬁed by both
the caller and callee applications.
V. SAINT POLICY
This section overviews the Saint policy primitives used
to describe the install time policies and the interaction
policies. Saint policies are those in gray boxes in Figure 3.
A. Install-Time Policy Enforcement
Saint’s install-time policy regulates granting of appli-
cation deﬁned permissions. More speciﬁcally, an applica-
tion declaring permission P deﬁnes the conditions under
which P is granted to other applications at install-time.
Conceptually, the an application requesting the permission
P can be installed only if the policy for acquiring P is sat-
isﬁed. Saint represents a substantial departure from exist-
ing Android permission assignment. The existing Android
model allows/disallows a permission assignment based on
application-independent rules, or where such rules pro-
vide insufﬁcient guidance, user input. Conversely, Saint
allows applications to exert control over the assignment
of permissions it declares through explicit policy.
Depicted in Figure 4, install-time policies are enforced
by the Saint installer based on decisions made by the
AppPolicy provider, which maintains a database of all
the install and run-time policies. Upon installing an appli-
cation, the Saint-enhanced Android installer retrieves the
requested permissions from the manifest ﬁle (step a). For
each permission, it queries the AppPolicy provider (step
b). The AppPolicy provider consults its policy database,
and returns a decision based on matching rules (step c).
If the policy conditions hold, the installation proceeds,
otherwise it is aborted. Finally, on successful installation,
the new application’s install-time and runtime polices are
appended to the AppPolicy provider’s policy database.
As shown in Table I, Saint install-time policy consists
of a permission label, an owner, and a set of conditions.
The permission label
identiﬁes the permission to be
regulated. The owner is always the application declaring
the permission. The conditions are a collection of checks
on the properties of the application requesting for it. All
checks must be true for the installation to be allowed.
The condition can check the signatures on the application
package or other permissions the application requests,
i.e., the permissions it would possess if installed. The
condition check is implicitly afﬁrmative in that it requires
the condition to be true, e.g., as the accepted developer
signatures or required set of permissions. Alternatively, it
can be negated e.g., as forbidden permissions. Only the
application declaring such permission is allowed to create
the policy for it. The install-time policy for requirement
(5) of our motivating example in Section II is provided
as policy (1) in Table I. Saint encodes it in XML as:
android.permission.ACCESS_FINE_LOCATION
B. Run-Time Policy Enforcement
Saint’s runtime policy regulates the interaction of soft-
ware components within Android’s middleware frame-
work. Any such interaction involves a caller application
that sends the IPC and callee (B) application that receives
that IPC. The IPC is allowed to continue only if all poli-
cies supplied by both the caller and callee are satisﬁed.
Depicted in Figure 4, the Saint policy enforcement
works as follows. The caller application A initiates the
IPC through the middleware framework (step 1). The
IPC is intercepted by the Saint policy enforcement code
before any Android permission checks. Saint queries the
AppPolicy provider for policies that match the IPC (step
2). The AppPolicy provider identiﬁes the appropriate
policies, checks that the policy conditions (application
state, phone conﬁguration, etc.) satisﬁed, and returns the
result (step 3). If the conditions are not satisﬁed, the IPC
is blocked; otherwise, the IPC is directed to the existing
Android permission check enforcement software (step 4).
Android will then allow (step 5) or disallow the IPC to
continue based on traditional Android policy.
Saint enforces two types of runtime policies: 1) access
policies identify the caller’s security requirements on the