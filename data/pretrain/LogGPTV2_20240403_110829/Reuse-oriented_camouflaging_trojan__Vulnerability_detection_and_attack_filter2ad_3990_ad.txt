### Case Study: Analyzing the Reuse-Oriented Camouflaging (ROC) Attack

#### 5.2 A Case Study

**ENTRY (Receive_Ping)**

```c
{
    get(&GUID);
    if (two consecutive messages with identical GUID)
        do_command_A();
}
```

In this case study, we introduce a covert Botnet communication and command-and-control (C&C) mechanism by reusing the Gnutella protocol in a stealthy manner. The goal is to make the network traffic appear normal while enabling malicious C&C operations.

**Gnutella Protocol Overview**

The Gnutella protocol is used for peer-to-peer (P2P) file sharing. In the Gnutella network, nodes use "PING" packets to announce their presence and notify other peers that they are reachable. Peers respond with "PONG" packets to confirm their availability. This protocol is designed to be robust and efficient, making it an attractive target for malicious reuse.

**Malicious Reuse of Gnutella Protocol**

1. **Covert Communication**: Malicious actors can leverage the "PING" and "PONG" messages to establish a covert C&C channel. By embedding commands within these seemingly benign messages, the attackers can communicate with infected nodes without raising suspicion.

2. **Implementation Details**:
   - **Send_Ping**: The "PING" message is modified to include a specific GUID (Globally Unique Identifier). If two consecutive messages with the same GUID are received, the `do_command_A()` function is executed.
   - **Receive_Ping**: The `get` function retrieves the GUID from the incoming "PING" message. If the GUID matches the expected pattern, the corresponding command is decoded and executed.

**Attack Logic Composition**

- **Command Encoding**: The command is encoded based on the number of consecutive "PING" messages with the same GUID. This encoding ensures that the command is only recognized by the intended recipient.
- **Execution**: The `Receive_Ping` function decodes the command and triggers the appropriate action. The command is translated into a memory access operation, which is then executed.

**Detection and Prevention**

- **Binary Integrity Check**: One approach to detect ROC attacks is to hash all legal binaries and periodically check their integrity. However, this method is challenging due to the large number of binaries and frequent software updates.
- **Control Flow Integrity (CFI)**: CFI can be used to enforce legal control flow transfers and detect deviations caused by ROC attacks. However, CFI enforcement may be bypassed if the attacker can manipulate the entry and exit points of the victim binary.
- **Behavioral Analysis**: Host-based Intrusion Detection Systems (IDS) and Network-based IDS (NIDS) can analyze the timing and sequencing of function invocations to detect anomalies. However, ROC attacks often preserve normal network behavior, making detection difficult.

**Related Work**

- **Return-Oriented Programming (ROP)**: ROP is a technique where short instruction sequences (gadgets) are reused to compose malicious logic. ROC attacks differ from ROP in that they reuse high-level functionalities rather than low-level instruction sequences.
- **Feature Extraction**: Prior work has focused on extracting features from binaries for malware analysis. Techniques such as dynamic program slicing and symbolic execution have been used to identify and extract reusable code segments.

**Conclusion**

The ROC attack poses a new threat by transforming legitimate binaries into stealthy, malicious ones. To defend against ROC attacks, integrated frameworks for detection and prevention are needed. Our experiments with real-world software binaries indicate that ROC attacks can be detected and confirmed using a systematic approach.

**Acknowledgment**

We thank the anonymous reviewers for their insightful comments and discussions. This research is supported in part by the Office of Naval Research (ONR) under grant N00014-09-1-0776 and by the National Science Foundation (NSF) under grants 0716444, 0720516, and 0845870. Any opinions, findings, and conclusions in this paper are those of the authors and do not necessarily reflect the views of the ONR or NSF.

**References**

[1] Bitdefender malware and spam survey. [Online]. Available: http://news.bitdefender.com/NWi094-en-BitDefender-Malware-and-Spam-Survey-finds-E-Threats-Adapting-to-Online-Behavioral-Trends.html

[2] Gnutella protocol spec. [Online]. Available: http://wiki.limewire.org/index.php?title=GDF

[3] National Software Reference Library. [Online]. Available: http://www.nsrl.nist.gov/

[4] Most abused infection vector. [Online]. Available: http://blog.trendmicro.com/most-abused-infection-vector/

[5] Virus collection (vx heavens). [Online]. Available: http://vx.netlux.org/vl.php, visited in Nov. 2009.

[6] Parasitic malware: The resurgence of an old threat. Network Security, 2008(3): IS-18, 2008.

[7] M. Abadi, M. Budiu, Ulfar Erlingsson, and J. Ligatti. Control-flow integrity. In ACM CCS'05, 2005.

[8] O. Agesen, D. Detlefs, and J. E. Moss. Garbage collection and local type-precision variable liveness in Java virtual machines. SIGPLAN Not., 33(5):269-279, 1998.

[9] H.-J. Boehm. Space efficient conservative garbage collection. In ACM PLDI'93, 1993.

[10] E. Buchanan, R. Roemer, H. Shacham, and S. Savage. When good instructions go bad: Generalizing return-oriented programming to RISC. In ACM CCS'08, 2008.

[11] J. Caballero, N. M. Johnson, S. McCamant, and D. Song. Binary code extraction and interface identification for security applications. In ISOC NDSS'10, 2010.

[12] J. Canto, M. Dacier, E. Kirda, and C. Leita. Large scale malware collection: lessons learned. In IEEE SRDS'08, 2008.

[13] J. Chow, B. Pfaff, T. Garfinkel, K. Christopher, and M. Rosenblum. Understanding data lifetime via whole system simulation. In 13th USENIX Security Symposium, 2004.

[14] C. Kolbitsch, P. K. Rogawski, T. Holz, and E. Kruegel. Automated extraction of "return-to-libc" gadgets from proprietary binaries. In IEEE Symposium on Security and Privacy, 2010.

[15] S. Designer. "Return-to-libc" attack. Bugtraq, August 1997.

[16] H. H. Feng, O. M. Kolesnikov, P. Fogla, W. Lee, and W. Gong. Anomaly detection using call stack information. In IEEE Symposium on Security and Privacy, 2003.

[17] O. Greevy and S. Ducasse. Correlating features and code using a compact two-sided trace analysis approach. In European Conference on Software Maintenance and Reengineering, 2005.

[18] S. A. Hofmeyr, S. Forrest, and A. Somayaji. Intrusion detection using sequences of system calls. Journal of Computer Security, 6(3):151-180, 1998.

[19] A. D. Keromytis. Randomized instruction sets and runtime environments: past research and future directions. IEEE Security and Privacy, 7(1):18-25, 2009.

[20] G. H. Kim and E. H. Spafford. The design and implementation of tripwire: a file system integrity checker. In ACM CCS'94, 1994.

[21] B. Korel and J. Laski. Dynamic program slicing. Information Processing Letters, 29(3):155-163, 1988.

[22] Z. Lin, X. Zhang, and D. Xu. Reuse-Oriented Camouflaging Attack: Vulnerability Detection and Attack Construction. Technical report, CERIAS TR 2009-29, Purdue University, 2009.

[23] Nergal. The advanced return-into-lib(c) exploits: Pax case study. Phrack, 10(58), 2001.

[24] N. Nethercote and J. Seward. Valgrind: A framework for heavyweight dynamic binary instrumentation. In ACM PLDI'07, 2007.

[25] J. Newsome and D. Song. Dynamic taint analysis for automatic detection, analysis, and signature generation of exploits on commodity software. In ISOC NDSS'05, 2005.

[26] K. Pattabiraman, N. Nakka, Z. Kalbarczyk, and R. Iyer. Discovering Insider Attacks Using Symbolic Execution. In IFIP SEC, 2009.

[27] H. Shacham. The geometry of innocent flesh on the bone: return-into-libc without function calls. In ACM CCS'07, 2007.

[28] K. Wang and S. J. Stolfo. Anomalous payload-based network intrusion detection. In Recent Advances in Intrusion Detection, 2004.

[29] W. E. Wong, S. S. Gokhale, and J. R. Horgan. Quantifying the closeness between program components. Journal of Systems and Software, 54(2):87-98, 2000.

[30] H. Yin, D. Song, E. Manuel, C. Kruegel, and E. Kirda. Panorama: Capturing system-wide information flow for malware detection and analysis. In ACM CCS'07, 2007.

[31] T. Zimmermann and A. Zeller. Visualizing memory graphs. In International Seminar on Software Visualization, Revised Lectures, 2002.