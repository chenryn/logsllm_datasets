indirect call-
s/jumps) [41], [43], [44], [10]. In particular, given the preva-
lence of virtual method calls in C++ programs (see Sec-
tion IV-A), researchers have proposed many defenses to protect
these dynamic calls. To evaluate how they are affected by
unsafe copy relocations, we come up with a simple exploitation
test as shown in Figure 12.
(i.e.,
The test program has two parts. The ﬁrst part is a library
which deﬁnes a class A with a virtual method (A.hpp and
A.cpp). The second part is an executable which allocates
an instance obj of the class and invokes the virtual method
(main.cpp). In the executable, we hard-code the symbol
name used for A’s vtable (_ZTV1A) and perform an emulated
memory corruption on the function pointer of the virtual
method A::a1 in A’s vtable and see if it is accepted by the
evaluated defense deployed on this program.
We evaluate a set of six CFI defenses and show the results
in Table III. We choose these defenses because they apply to
C++ programs on Linux. An effective defense must check the
pointer to the vtable to defend against COOP attacks [38] but
must also check the actual value of the function pointer in the
vtable to defend against COREV. Only defenses that check
both targets protect against COREV and COOP.
Among the defenses, three are vulnerable to unintended
copy relocations because they assume read-only protection for
vtables and only check if the vtable pointer points to a valid
vtable (see Section IV-A). Interleaving [10] does not currently
support dynamic linking so we evaluate its vulnerability based
on their proposed instrumentation. SafeDispatch [26] proposes
two different instrumentations where the ﬁrst checks the virtual
method target and the other checks the vtable pointer. It
claims the latter provides better security regarding COOP-style
attacks [38]. However, the latter is vulnerable to COREV-based
vtable corruption attacks.
E. Other Platforms
Dynamic linking is enabled by default on major operating
systems such as Windows and macOS. We evaluate COREV
implications on the dynamic linking implementations on both
Windows and macOS.
Recall that the cause of copy relocations is due to the
ambiguity in declaring external variables at source level (see
Fig. 11: An example of format string that is susceptible to
COREV in libow-3.1.
Fig. 12: A test program for vtable defenses.
4) Format String (libow): We identiﬁed a dynamic library
(libow-3.1 [1]) that exports a set of 22 format strings, causing
three different executables (owftpd – an ftp server, owserver –
a backend server for 1-wire control, and owexternal) to copy
them into writable memory at runtime. These format strings
are for debugging purposes, and we show one of them in Fig-
ure 11. The format string mutex_unlock_failed is de-
ﬁned in the libow-3.1 library and exported in a header ﬁle. As
a result, an executable that includes the header ﬁle and uses the
library-provided macro my_pthread_mutex_lock will
cause the format string to be relocated. If an adversary corrupts
the relocated format string and exploits a concurrency bug
to cause the mutex lock operation to fail, she can potentially
launch printf-oriented programming and achieve arbitrary code
execution.
D. Affected Defenses
In this section, we evaluate how unsafe copy relocations
affect current defenses.
12
const	char	mutex_unlock_failed[]	=													"mutex_unlock	failed	rc=%d	[%s]\n";libow-3.1: src/c/error.cextern	const	char	mutex_unlock_failed[];#define	my_pthread_mutex_lock(mutex)	\		do	{	\				/*	skip	some	code	here	*/				mrc	=	pthread_mutex_lock(mutex);	\				if	(mrc	!=	0)	{						vsprintf(buf,	mutex_unlock_failed,	...);	\				}	\		}	while	(0)libow-3.1: src/include/ow_mutex.hA.hppclass	A	{public:				virtual	int	a1();};A.cpp#include	"A.hpp"int	A::a1()	{				return	1;}#include	#include	"A.hpp"//	hardcoded	symbol	for	class	A’s	vtableextern	unsigned	long	_ZTV1A[];void	hijack(void)	{				printf("vulnerable!\n");}int	main()	{				//	corrupt	A’s	vtable	slot	for				//	method	a1	as	if	an	attack	happens				_ZTV1A[2]	=	(unsigned	long)	hijack;				//	allocate	an	object	and	make				//	the	virtual	call				A	*obj	=	new	A();				obj->a1();								return	0;}main.cppMakeﬁleall: main.cpp A.cpp  g++ -fPIC -shared \     A.cpp -o libA.so  g++ -L. -lA \     main.cppFigure 2). Compilers cannot know whether these variables are
deﬁned by another object ﬁle in the same binary or in a dy-
namic library. How compilers handle this ambiguity results in
performance or security implications. To understand COREV
on other platforms, we compile the program in Figure 2 and
examine the generated instructions that access the external
variable foo.
1) Windows: The MSVC linker on Windows refuses to
build the example program. This is because the MSVC com-
piler requires the program to explicitly specify an external
library variable using the __declspec(dllimport) at-
tribute in addition to the extern keyword. Otherwise, the
declared external variable is assumed to be deﬁned in another
object ﬁle that links to the same binary. If the linker cannot ﬁnd
the symbol deﬁnition when performing static linking, it will
report an error rather than creating a copy relocation. Thus,
Windows removes the ambiguity by forcing declarations to
be explicit, removing the need for copy relocations. Through
these annotations, the MSVC compiler can achieve high perfor-
mance for symbols in the same module and keep permissions
for symbols in other modules. Hence COREV does not affect
Windows.
2) macOS: macOS handles the ambiguity by making the
opposite assumption of Linux, trading performance for safety.
The compiler assumes all variables declared as external are
potentially from dynamic libraries, and generates instructions
in Figure 6 (a) for external variables. This is the mitigation
approach we proposed in Section V-B. Naturally, accesses to
library variables use the GOT indirection. Consequently, copy
relocations do not exist on macOS and COREV does not affect
macOS either.
However, memory corruption over “read-only” data is still
possible on macOS. Speciﬁcally, based on our observation,
the compiler allocates read-only data that potentially requires
runtime relocation from the __DATA.__const section. For
example, code pointers in vtables may require adding the
module loading base at runtime, and thus are allocated from
the __DATA.__const section. This supposedly read-only
section is, however, mapped as read-write at runtime. We
tested the example program in Figure 12 and examined several
system libraries such as libc++.dylib on macOS 10.12.
This design simpliﬁes the implementation of the dynamic
loader. If the relocated data (i.e., the code pointers) resides on
writable pages, the loader can freely patch relocations at any
time without worrying about page faults. Unfortunately, similar
to the security concerns raised by COREV, this design weakens
the security of applications by exposing memory corruption
targets to an adversary, enabling her to launch attacks and/or
bypass defenses.
VIII. CONCLUSION
Dynamic loading enables modularity and reduces the mem-
ory footprint of applications. Due to the incomplete mapping
between source level primitives (like extern const) and
imported and exported symbols on the ELF/binary level,
memory protection information is inadvertently lost. When
an executable references a read-only variable exported from a
library, the dynamic loader ld.so relocates this variable into
the writable .bss section of the executable, which effectively
strips the const attribute speciﬁed by the programmer. As
a result,
this enables an adversary to modify “read-only”
variables when exploiting a memory corruption vulnerability.
We call this attack COREV for Copy Relocation Violation.
This attack vector has existed for decades and, as we show
for Ubuntu 16.04, is widespread. The attack surface is broad
with 29,817 libraries exporting relocatable read-only variables.
The set of 6,399 programs with actual unsafe copy relocations
includes ftp servers, apt-get, and gettext out of 4,570 packages.
An attacker can use COREV to escalate her privileges,
leveraging a memory corruption vulnerability to modify format
strings, ﬁle names, vtables, code pointers, or other supposedly
read-only data. We discuss three possible mitigation strategies
that (i) detect the attack vector by analyzing binaries and
libraries – as a fast mitigation, (ii) mitigate the attack through
recompilation (if possible), or (iii) change the toolchain to
make the linker and loader aware of source level permissions
even for externally deﬁned variables.
ACKNOWLEDGEMENT
We thank our shepherd, Engin Kirda, and the anonymous
reviewers for their constructive feedback on this work. The
work was supported, in part, by the National Science Foun-
dation under grants number CNS-1408880, CNS-1513783,
and CNS-1657711. The research reported here was supported
in part by the Defense Advanced Research Projects Agency
(DARPA) under agreement number N66001-13-2-4040. The
views and conclusions contained herein are those of the authors
and should not be interpreted as necessarily representing the
ofﬁcial policies or endorsements, either expressed or implied,
of any of the above organizations or any person connected with
them.
REFERENCES
libow-3.1. http://packages.ubuntu.com/xenial/libow-3.1-1.
[1]
[2] RELRO - a memory corruption mitigation technique. http://tk-blog.
blogspot.com/2009/02/relro-not-so-well-known-memory.html.
[3] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-ﬂow
integrity,” in Proceedings of the 12th ACM conference on Computer
and communications security. ACM, 2005, pp. 340–353.
[4] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “A theory of secure
control ﬂow,” in Proceedings of the 7th International Conference on
Formal Methods and Software Engineering, ser. ICFEM’05, 2005.
[5] S. Andersen and V. Abella, “Data execution prevention. changes to
functionality in microsoft windows xp service pack 2, part 3: Memory
protection technologies,” 2004.
[6] S. V. Archives, “Wu-ftpd remote format string stack overwrite vulner-
ability,” 2008.
[7] M. Backes, T. Holz, B. Kollenda, P. Koppe, S. N¨urnberger, and J. Pewny,
“You can run but you can’t read: Preventing disclosure exploits in
executable code,” in Proceedings of the 2014 ACM SIGSAC Conference
on Computer and Communications Security. ACM, 2014, pp. 1342–
1353.
[8] D. Balzarotti, M. Cova, V. Felmetsger, N. Jovanovic, E. Kirda,
C. Kruegel, and G. Vigna, “Saner: Composing static and dynamic anal-
ysis to validate sanitization in web applications,” in IEEE Symposium
on Security and Privacy (Oakland 2008).
IEEE, 2008, pp. 387–401.
[9] M. Bishop and M. Digler, “Checking for race conditions in ﬁle
accesses,” Computer Systems, vol. 9, no. 2, Spring 1996.
[10] D. Bounov, R. Kici, and S. Lerner, “Protecting c++ dynamic dispatch
through vtable interleaving,” in Network and Distributed System Secu-
rity Symposium (NDSS), 2016.
13
[34] M. Payer, A. Barresi, and T. R. Gross, “Fine-grained control-ﬂow
integrity through binary hardening,” in Detection of Intrusions and
Malware, and Vulnerability Assessment. Springer, 2015, pp. 144–164.
[35] M. Payer and T. R. Gross, “Protecting Applications Against TOCTTOU
Races by User-Space Caching of File Metadata,” in VEE’12: Proc. 8th
Int’l Conf. Virtual Execution Environments, 2012.
[36] A. Prakash, X. Hu, and H. Yin, “vfGuard: Strict protection for virtual
function calls in cots c++ binaries.” in Network and Distributed System
Security Symposium (NDSS), 2015.
[37] R. Roemer, E. Buchanan, H. Shacham, and S. Savage, “Return-oriented
programming: Systems, languages, and applications,” ACM Transac-
tions on Information and System Security (TISSEC), vol. 15, no. 1,
p. 2, 2012.
[38] F. Schuster, T. Tendyck, C. Liebchen, L. Davi, A.-R. Sadeghi, and
T. Holz, “Counterfeit object-oriented programming: On the difﬁculty
of preventing code reuse attacks in C++ applications,” in 2015 IEEE
Symposium on Security and Privacy (Oakland).
IEEE, 2015, pp. 745–
762.
[39] A. Seshadri, M. Luk, N. Qu, and A. Perrig, “SecVisor: A tiny hypervisor
to provide lifetime kernel code integrity for commodity OSes,” ACM
SIGOPS Operating Systems Review, vol. 41, no. 6, pp. 335–350, 2007.
(2003) Address Space Layout Randomization (ASLR).
[40] P. Team.
http://pax.grsecurity.net/docs/aslr.txt.
[41] C. Tice, T. Roeder, P. Collingbourne, S. Checkoway,
´U. Erlingsson,
L. Lozano, and G. Pike, “Enforcing forward-edge control-ﬂow integrity
in gcc & llvm,” in USENIX Security Symposium, 2014.
[42] H. Vijayakumar, X. Ge, M. Payer, and T. Jaeger, “JIGSAW: Protecting
resource access by inferring programmer expectations,” in 23rd USENIX
Security Symposium (USENIX Security), 2014, pp. 973–988.
[43] C. Zhang, S. A. Carr, T. Li, Y. Ding, C. Song, M. Payer, and D. Song,
“VTrust: Regaining trust on virtual calls,” in Network and Distributed
System Security Symposium (NDSS), 2016.
[44] C. Zhang, C. Song, K. Z. Chen, Z. Chen, and D. Song, “VTint:
Protecting virtual function tables’ integrity.” in Network and Distributed
System Security Symposium (NDSS), 2015.
[11] N. Burow, S. A. Carr, J. Nash, P. Larsen, M. Franz, S. Brunthaler,
and M. Payer, “Control-Flow Integrity: Precision, Security, and Perfor-
mance,” ACM Computing Surveys, 2017.
[12] N. Carlini, A. Barresi, M. Payer, D. Wagner, and T. R. Gross, “Control-
ﬂow bending: On the effectiveness of control-ﬂow integrity,” in Pro-
ceedings of the 24th Usenix Security Symposium (USENIX Security),
2015.
[13] S. Chari, S. Halevi, and W. Venema, “Where do you want to go
today? escalating privileges by pathname manipulation.” in Network
and Distributed System Security Symposium (NDSS), 2010.
[14] C. Cowan, M. Barringer, S. Beattie, G. Kroah-Hartman, M. Frantzen,
and J. Lokier, “Formatguard: Automatic protection from printf format
string vulnerabilities.” in USENIX Security Symposium (USENIX Secu-
rity), vol. 91. Washington, DC, 2001.
[15] S. Crane, C. Liebchen, A. Homescu, L. Davi, P. Larsen, A.-R. Sadeghi,
S. Brunthaler, and M. Franz, “Readactor: Practical code randomization
resilient to memory disclosure,” in 2015 IEEE Symposium on Security
and Privacy (S&P 2015), 18-20 May 2015, San Jose, California, USA,
2015.
J. Criswell, N. Dautenhahn, and V. Adve, “KCoFI: Complete control-
ﬂow integrity for commodity operating system kernels,” in 2014 IEEE
Symposium on Security and Privacy (SP).
IEEE, 2014, pp. 292–307.
[17] CWE, “CWE-59: Improper Link Resolution Before File Access,” http:
[16]
//cwe.mitre.org/data/deﬁnitions/59.html.
[18] L. Davi, A.-R. Sadeghi, D. Lehmann, and F. Monrose, “Stitching the
gadgets: On the ineffectiveness of coarse-grained control-ﬂow integrity
protection,” in 23rd USENIX Security Symposium (USENIX Security).
San Diego, CA: USENIX Association, Aug. 2014, pp. 401–416.
[19] U. Drepper, “How to write shared libraries,” Retrieved Jul, vol. 16, p.
2009, 2006.
[20] X. Ge, W. Cui, and T. Jaeger, “GRIFFIN: Guarding control ﬂows
using intel processor trace,” in Proceedings of the 22nd International
Conference on Architectural Support for Programming Languages and
Operating Systems (ASPLOS). ACM, 2017.
[21] X. Ge, N. Talele, M. Payer, and T. Jaeger, “Fine-grained control-ﬂow
integrity for kernel software,” in IEEE European Symposium on Security
and Privacy (EuroSP).
IEEE, 2016.
[22] X. Ge, H. Vijayakumar, and T. Jaeger, “Sprobes: Enforcing kernel code
integrity on the trustzone architecture,” in Proceedings of the 3rd IEEE
Mobile Security Technologies Workshop (MoST 2014), May 2014.
[23] E. Goktas, E. Athanasopoulos, H. Bos, and G. Portokalidis, “Out of
control: Overcoming control-ﬂow integrity,” in Proceedings of the 35th
IEEE Symposium on Security and Privacy, May 2014.
[24] N. Hardy, “The confused deputy,” Operating Systems Review, vol. 22,
pp. 36–38, 1988.
[25] E. Hiroaki and Y. Kunikazu, “ProPolice: Improved stack-smashing
attack detection,” IPSJ SIG Notes, pp. 181–188, 2001.
[26] D. Jang, Z. Tatlock, and S. Lerner, “Safedispatch: Securing c++ virtual
calls from memory corruption attacks.” in Network and Distributed
System Security Symposium (NDSS), 2014.
J. Jelinek, “FORTIFY SOURCE,” https://gcc.gnu.org/ml/gcc-patches/
2004-09/msg02055.html, 2004.
[27]
[28] W. S. McPhee, “Operating system integrity in OS/VS2,” IBM Syst. J.,
1974.
[29] B. Niu and G. Tan, “Modular control-ﬂow integrity,” in Proceedings of
the 35th ACM SIGPLAN Conference on Programming Language Design
and Implementation. ACM, 2014, p. 58.
[30] B. Niu and G. Tan, “RockJIT: Securing just-in-time compilation using
modular control-ﬂow integrity,” in Proceedings of the 2014 ACM SIG-
PLAN Conference on Computer and Communications Security. ACM,
2014, p. 58.
[31] B. Niu and G. Tan, “Per-input control-ﬂow integrity,” in Proceedings of
the 22nd ACM SIGSAC Conference on Computer and Communications
Security. ACM, 2015, pp. 914–926.
[32] PaX Team, “Documentation for the PaX project - overall description,”
https://pax.grsecurity.net/docs/pax.txt, 2008.
[33] M. Payer, “Too much PIE is bad for performance,” ETH Zurich Tech-
nical Report http://nebelwelt.net/publications/ﬁles/12TRpie.pdf, 2012.
14