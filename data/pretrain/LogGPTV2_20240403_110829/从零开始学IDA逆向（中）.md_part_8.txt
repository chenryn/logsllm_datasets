从零开始学IDA逆向 41 堆栈中的字符串
图 41-27 全局变量
首先查看这个已经初始化过的全局变量。
对比源代码和反汇编，这个字符串的使用方式如图 41-28。
图 41-28 string变量
该处将字符串的地址压栈。
接下来观察到的内容令人疑惑。现在转到全局变量使用的data区段。
图 41-29 char string[18]
char string[18]这个定义是从符号文件中获取的。所以IDA 识别出这
个位置是一个相应长度的字符串，也就是“Donde se ubicara” 。按D键可
以查看每个字节，按A键可以再次显示ASII字符串。
128
从零开始学IDA逆向 41 堆栈中的字符串
图 41-30 字符串字节
一般，如果有第二种变量定义的话是因为某些 API 函数引用。IDA 从 API
函数识别出变量的类型，然后加上了第二种定义。
图 41-31 引用
转到引用的具体位置。
图 41-32 printf函数
可以发现变量是printf函数的第二个参数，而且是一个地址。而且右键单
击的话，可以选择显示字符串的地址值，如图 41-33。
图 41-33 地址值
129
从零开始学IDA逆向 41 堆栈中的字符串
右键单击之后，作者选择直接显示输出的字符串地址，替换掉字符串指针形
式。这两个全局变量字符串都在data区段。
图 41-34 string2[]
唯一的区别就是string2没有进行初始化，所以按D键展开后再按A键不
会返回字符串形式，因为它现在是 0 填充，也就是空值。只有单击右键选择 AR
RAY能够重新转换为数组。
char * string2 dw 0Ah dup(0)
意味着dw（2字节），值为0，重复0xA次，总共就是20。
图 41-35 重新转换为字符数组
如果将元素转换成字节，就更加明显。
图 41-36 元素转换为db
长度为0x14，或者说20个0。
接下来查看填充该字符串的引用。
130
从零开始学IDA逆向 41 堆栈中的字符串
图 41-37 查看引用
在字符串地址处右键单击选择offset * char，重新转换为初始的字符串
指针形式。然后按X键查看引用，第一处就是填充缓存区的引用。
图 41-38 填充字符串string2
rdata区段的“Donde se ubicara?”字符串通过复制写入了data区段
的缓存区，data区段是可写的所以能被修改。
显然，data区段可写而且有缓存区变量，那么就有可能发生溢出。如果字
符串的长度没有计算好的话，覆盖掉全局变量将会影响整个程序。
启动调试，尝试一下。
图 41-39 全局变量地址
string和string2变量的地址对应的是data区段。
131
从零开始学IDA逆向 41 堆栈中的字符串
图 41-40 string
图 41-41 string2
41.4 堆字符串
接下来观察堆（heap）上的字符串，在栈上的一个指针保存了它在堆上的
地址。
图 41-42 _strlen
图 41-42中读取“hola reverser en data”的地址，然后传给_str
len函数获取它的长度。
然后加上1，就和源代码中一致。
图 41-43 eax+1
图 41-44 长度+1
然后传给malloc函数在堆中申请空间，生成一个动态缓存区，长度为字符
串长度+1。
132
从零开始学IDA逆向 41 堆栈中的字符串
返回的地址是不固定的，但肯定是一个具有读写权限的区域，之后会将字符
串复制进去。
图 41-45 保存返回地址
图 41-45中将返回的指向缓存区的堆地址保存入栈中的指针变量mensaj
e_en_heap。
图 41-46 _strcpy
然后调用_strcpy 将 mensaje_en_data 指向的字符串内容复制到堆缓
存区中。
图 41-47 _memcpy
133
从零开始学IDA逆向 41 堆栈中的字符串
然后程序获取“hola reverser en ”字符串的长度，加到堆缓存区的起
点位置上。调用_memcpy将“data”替换为“heap”。因为程序通过_memcpy
函数进行了 4 个字节的复制，参数“heap”作为复制的源，而复制的目标则是
指向堆缓存区中“data”的位置。
在源代码中是这样的。
memcpy(mensaje_en_heap+strlen("hola reverser en "),"heap",4);
复制的目标就是mensaje_en_heap的地址再加上“hola reverser e
n ”字符串的长度。正好指向“data”这个单词，然后从复制的源“heap”复
制4个字节进行覆盖。
图 41-48 启动调试
接下来通过调试进行验证。
图 41-49 字符串长度
通过_strlen函数获取了“hola reverser en data”字符串的长度。
不算结尾的null一共是0x15字节。
134
从零开始学IDA逆向 41 堆栈中的字符串
图 41-50 malloc
然后加上1，并传给malloc函数申请0x16字节的空间。
图 41-51 返回堆地址
然后malloc函数返回堆地址，在作者这边是0x67D4F0。
135
从零开始学IDA逆向 41 堆栈中的字符串
图 41-52 0x67D4F0
如果从调试器运行，heap就是在debug区段，如果将数据类型改为dwor
d，很容易看出它是0x16也就是22字节。
图 41-53 转换类型
由于在debug区段，而且目前还没有写入，目前能看到的是BAAD F00D。
一个是 5 个 dword 或者说 20 字节的缓存区加上最后 2 个字节 0xFEEE，
所以申请的空间是0x16或者说22字节。
图 41-54 0x16
之后的章节会讨论堆的内容。但是目前还是将它视作充满BAAD F00D的缓
存区。
136
从零开始学IDA逆向 41 堆栈中的字符串
之后，程序将地址保存在栈中的指针变量中。
图 41-55 保存指针
然后调用_strcpy，将“hola reverser en data”字符串写入堆缓存
区。
图 41-56 _strcpy
按F8键追踪。
图 41-57 堆字符串
在堆缓存区中，能够看到写入的字节。同样按A键可以将它们转换为ASII
字符。
图 41-58 _strlen
然后程序调用_strlen函数，获取“hola reverser en”字符串的长
137
从零开始学IDA逆向 41 堆栈中的字符串
度。
图 41-59 hola reverser en的长度
结果是0x11，然后加上堆缓存区的起点地址。
图 41-60 长度+地址
如果将字符串拆成单独的字节。
图 41-61 字符串拆成字节
然后在该处按A键。
然后程序写入4个字节，将data替换为heap。
138
从零开始学IDA逆向 41 堆栈中的字符串
图 41-62 data
图 41-63 data指针
图 41-64 heap
139
从零开始学IDA逆向 41 堆栈中的字符串
然后拆开heap这个词，将整个字符串重新组合。
图 41-65 重组字符串
新的字符串在堆中创建完毕，最后就是输出它的地址。
图 41-66 命令行输出地址
图 41-67 字符串地址
以上就是本章的内容。希望读者通过练习熟悉并掌握字符串的处理方式。
140
从零开始学IDA逆向 42 函数指针利用
42 函数指针利用
42.1 main 函数
首先更新一下KeyPatch插件，因为需要一直使用这个插件。
图 42-1 KeyPatch插件
https://github.com/keystone-engine/keypatch
将原先的keypatch.py文件使用最新版本进行替换。
http://ricardo.crver.net/WEB/INTRODUCCION%20AL%20REVER
SING%20CON%20IDA%20PRO%20DESDE%20CERO/EJERCICIOS/
在IDA中打开本章的练习文件。
图 42-2 打开练习文件
141
从零开始学IDA逆向 42 函数指针利用
不需要加载符号文件，因为作者没有给出文件。同时作者也会按照没有符号
文件来进行分析。
在字符串选项卡中，发现了“Mypepe.dll”，也许需要将前面一些章节使
用的这个动态链接库复制到练习文件同一目录下。
图 42-3 Mypepe.dll
作者将它复制到练习文件目录下。
图 42-4 复制文件
在选项卡中双击该字符串，转到具体位置。
图 42-5 字符串位置
142
从零开始学IDA逆向 42 函数指针利用
按X键或者CTRL+X键查看引用，双击跳转到具体位置。
图 42-6 LoadLibrary
图 42-6中程序对Mypepe.dll进行了加载。所以作者的猜想是对的。看
上去这里应该是main函数。由于它是一个命令行程序，应该在调用函数之前传
递了一些类似argc、argv等参数。
图 42-7 函数引用
图 42-8 main函数参数
143
从零开始学IDA逆向 42 函数指针利用
图 42-7中是函数的引用，转到具体位置。如图 42-8，这就是对main函
数的调用方式，可以看到这些命令行的参数。
所以sub_401090就是main函数。对它进行重命名。
图 42-9 重命名main函数
由于main函数中没有需要保护的缓存区。所以编译器没有加上CANARY变
量，尽管编译的时候启用了这个选项。
42.2 函数指针
下面开始分析。
144
从零开始学IDA逆向 42 函数指针利用
图 42-10 读取api函数
图 42-10中首先读取idata区段IAT中的system API函数。然后将A
PI函数的地址传入EAX。
如果读者对IDA的语法不太适应，可以使用Keypatch插件显示一种更好
理解的方式，直到读者适应了IDA。
图 42-11 关键词extrn
图 42-11中API函数下方显示extrn，因为对于这个模块来说它是个外
部的函数，模块需要从外部导入才能使用这个函数。
图 42-12 导入函数选项卡
当然在导入函数选项卡中可以按照模块来查看导入函数，而这个 API 函数
的指针是0x4020A8，所以结果是匹配的。
图 42-13 dword_403088
然后API函数的地址会写入0x403088处的全局变量，根据IDA识别的结
果，它是一个DWORD。
145
从零开始学IDA逆向 42 函数指针利用
图 42-14 DWORD
读者应该知道，在 IDA 中，如果在地址的前面有一个数据类型的前缀，说
明这个地址的内容就是那种类型的数据。在这里它是一个 DWORD。至少是 4 个
字节的长度。除此以外，API的函数地址存入这个地址。
所以将这个全局变量命名为p_system。
由于变量是4个字节，而且存储的对象是一个地址，所以它应该是个指针。
作者会改变它的数据类型。
图 42-15 更改操作数类型
由于已经知道它是一个指向API函数的指针，可以设置成一个指针。
void * p_system
当然没有必要定义得太精确，因为存在类型转换。重要的是知道它是一个指
146
从零开始学IDA逆向 42 函数指针利用
针就行了。
图 42-16 void * p_system
现在p_system就是一个指针类型的变量，它保存了system这个API函
数的地址。
图 42-17 SetProcessDEPPolicy
下面有一个类似的全局变量保存了 SetProcessDEPPolicy 这个 API 函
数的地址。所以作者做了类似的处理。
按F5键使用HexRays反编译器，在这里的更改也会影响所有位置。
图 42-18 HexRays反编译器
图 42-19 变量注释
当然这里只是为了演示更多选项。
147
从零开始学IDA逆向 42 函数指针利用
42.3 指针复用
图 42-20 Size变量
然后 p_system 全局变量又被用于保存 Size 变量（DWORD）的指针（程
序使用LEA指令获取Size的地址）。当然在C++中需要进行类型转换，但是在
这里没有关系，都是指针。
通常来说，如果一个变量被重复利用，作者会使用长下划线，因为不能使用
斜线，然后再加上另一个变量名。