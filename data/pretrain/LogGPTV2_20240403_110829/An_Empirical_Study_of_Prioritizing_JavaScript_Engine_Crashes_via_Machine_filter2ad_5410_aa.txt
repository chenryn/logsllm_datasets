title:An Empirical Study of Prioritizing JavaScript Engine Crashes via Machine
Learning
author:Sunnyeo Park and
Dohyeok Kim and
Sooel Son
An Empirical Study of Prioritizing JavaScript
Engine Crashes via Machine Learning
Sunnyeo Park
KAIST
Dohyeok Kim
KAIST
Sooel Son
KAIST
ABSTRACT
The early discovery of security bugs in JavaScript (JS) engines
is crucial for protecting Internet users from adversaries abusing
zero-day vulnerabilities. Browser vendors, bug bounty hunters,
and security researchers have been eager to find such security
bugs by leveraging state-of-the-art fuzzers as well as their domain
expertise. They report a bug when observing a crash after executing
their JS test since a crash is an early indicator of a potential bug.
However, it is difficult to identify whether such a crash indeed
invokes security bugs in JS engines. Thus, unskilled bug reporters
are unable to assess the security severity of their new bugs with JS
engine crashes. Today, this classification of a reported security bug
is completely manual, depending on the verdicts from JS engine
vendors.
We investigated the feasibility of applying various machine learn-
ing classifiers to determine whether an observed crash triggers a
security bug. We designed and implemented CRScope, which clas-
sifies security and non-security bugs from given crash-dump files.
Our experimental results on 766 crash instances demonstrate that
CRScope achieved 0.85, 0.89, and 0.93 Area Under Curve (AUC)
for Chakra, V8, and SpiderMonkey crashes, respectively. CRScope
also achieved 0.84, 0.89, and 0.95 precision for Chakra, V8, and
SpiderMonkey crashes, respectively. This outperforms the previous
study and existing tools including Exploitable and AddressSanitizer.
CRScope is capable of learning domain-specific expertise from
the past verdicts on reported bugs and automatically classifying JS
engine security bugs, which helps improve the scalable classifica-
tion of security bugs.
CCS CONCEPTS
• Security and privacy → Domain-specific security and pri-
vacy architectures; Browser security; • Computing methodolo-
gies → Machine learning.
KEYWORDS
Crash analysis; Machine learning; Security bugs; JavaScript; Browser
security
ACM Reference Format:
Sunnyeo Park, Dohyeok Kim, and Sooel Son. 2019. An Empirical Study of
Prioritizing JavaScript Engine Crashes via Machine Learning. In ACM Asia
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
AsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand
© 2019 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-6752-3/19/07...$15.00
https://doi.org/10.1145/3321705.3329840
Conference on Computer and Communications Security (AsiaCCS ’19), July
9–12, 2019, Auckland, New Zealand. ACM, New York, NY, USA, 12 pages.
https://doi.org/10.1145/3321705.3329840
1 INTRODUCTION
A security bug in a popular web browser imposes a critical secu-
rity threat, affecting billions of Internet users [57]. A motivated
adversary who exploits zero- or one-day security vulnerabilities has
conducted exfiltrating sensitive information [15, 45], performing
remote code execution [11, 12, 44], and bypassing sandbox poli-
cies [13, 16, 43]. Unfortunately, today’s browsers are not safe from
zero- and one-day adversaries. According to 2018 statistics from
the Kaspersky Lab, web browsers are the second most frequently
exploited applications, accounting for one-fourth of all observed
attacks [33].
Among the components of web browsers, the JavaScript (JS) en-
gine is the core component most frequently targeted by adversaries.
The majority of users enable JS support in their browsers because
95.2% of all websites are in JavaScript [62]. The Turing-complete na-
ture of the JavaScript language also allows adversaries to compose
attack code to trigger unexpected or undefined behaviors. Further-
more, JS engines have become increasingly large and complex as
their browsers support more emerging HTML5 features. Security
bugs in such a complex and dominant application are certainly
attractive targets, which adversaries seek to exploit.
Thus, it is imperative for browser vendors to find these security
bugs as early as possible before adversaries abuse them. Today,
popular browser vendors depend on tech-savvy users, bug bounty
hunters [18, 38, 42], and security researchers [27, 61] to report
these security bugs. They also use state-of-the-art fuzzers and cloud
computing resources to find defects [20, 53].
Popular browser vendors have managed Bug Tracking Systems
(BTSs) to track reported bugs and reward bug reporters. Because the
prompt patch of a reported security bug is important, vendors ask
bug reporters to label whether their report is security-related [17,
35, 41]. Once a security bug is reported, a developer is assigned
to determine whether it is indeed a security bug. This procedure
requires domain expertise in the target browser and its engine, thus
making the procedure completely manual. If a bug reporter submits
a false positive, the engineering cost of a domain expert checking
the reported bug will be wasted. Even worse, a bug reporter may
post a security bug as a non-security bug, postponing the proper
patch and providing an opportunity for an attacker to exploit the
posted bug. Therefore, engine developers and bug reporters are in
dire need of an automated oracle that classifies security bugs.
Previous studies in the field have focused on pinpointing bug lo-
cations by analyzing crashes [5, 64, 65], determining the exploitabil-
ity of crashes [23, 60, 66], and performing natural language pro-
cessing of bug reports [2, 9, 31]. Tripathi et al. proposed training
Session 9: FuzzingAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand646a binary classifier to determine whether or not a given crash due
to bugs is exploitable. Their tool, called Exniffer, approximates the
oracle which determines the exploitability of a bug by analyzing
its associated crash [60]. Off-the-shelf tools also exist, including
Exploitable and AddressSanitizer, which determine the exploitability
of a bug when it causes a target binary to crash [8, 56]. However,
no previous study has explored classifying security bugs in JS en-
gines by analyzing their crashes. In this paper, we demonstrate that
Exploitable and AddressSanitizer are unfit for classifying security
bugs and that Exniffer does not achieve high accuracy or precision
for classifying security bugs in JS engines.
Contributions. We design and implement a tool, named CRash
Scope (CRScope). Given a JS engine crash, CRScope classifies whether
a security bug causes the crash. Consider a bug reporter with a
new JS test that causes a target engine to crash. CRScope provides
a verdict on whether this JS test has triggered a security or non-
security bug.
CRScope leverages a machine learning classifier trained on the
past verdicts of reported bugs causing the crashes of JS engines. To
train the classifier, we collected 165 JS PoCs triggering security bugs,
and 174 JS tests triggering non-security bugs from Chrome, Mozilla,
and Internet Explorer/Edge BTSs as well as GitHub repositories.
For each collected JS test, we compiled a JS engine binary, which
contained a past bug corresponding to the JS test. From the resulting
727 JS engine binaries, we prepared 766 crash instances on which
the classifier model of CRScope was trained and validated. To the
best of our knowledge, no previous study has built a ground truth
dataset for JS engine security bug classification. To support open
science and invite further research, we release our ground truth
dataset and CRScope.
We evaluated six different classifiers of CRScope, including the
Random Forest Classifier (RFC), Decision Tree Classifier (DTC),
Multinomial Naive Bayes (MNB), Logistic Regression (LR), Linear
Support Vector Classification (SVC), and Multi-layer Perceptron
Classifier (MLP) in scikit-learn [4]. For each model trained on the
crashes of Chakra, V8, and SpiderMonkey, CRScope achieved Area
Under Curves (AUCs) of 0.85, 0.89, and 0.93, respectively. We demon-
strated that CRScope outperforms Exniffer, the previous study that
addressed the classification of crash exploitability.
Prioritizing JS engine bugs is important in making sure the secu-
rity bugs get patched as soon as possible. Identifying security bugs
in the first place requires domain-specific knowledge, which often
causes false positive reports and hinders the scalable classification
of security bugs. No prior tool, however, has been able to classify
security bugs by analyzing JS engine crashes. CRScope leverages a
machine learning classifier, trained on the past verdicts made by
domain experts. CRScope is a new tool that can help bug reporters
and developers automatically classify security bugs, regardless of
whether they have domain expertise.
In summary, our contributions are as follows:
• We demonstrate that the current off-the-shelf tools, Exploitable
and AddressSanitizer are unfit for classifying security bugs
in JS engines.
• We build the first well-labeled dataset containing 165 security
and 174 non-security JS engine bugs with their JS test code
as well as their crashes. We release our dataset to support
further research at https://github.com/WSP-LAB/CRScope.
• We design, implement, and evaluate CRScope, the first tool
to classify JS engine security bugs via machine learning,
achieving AUCs of 0.85, 0.89, and 0.93 for Chakra, V8, and
SpiderMonkey crashes, respectively.
2 BACKGROUND AND MOTIVATION
2.1 Security and Non-security Bugs
A JS engine is an interpreter that executes a given JS code snip-
pet. All popular browser vendors have implemented and managed
their own JS engine: V8 for Google Chrome [22], JavaScriptCore
for Apple Safari [63], SpiderMonkey for Mozilla Firefox [48], and
Chakra for Microsoft Internet Explorer/Edge [37]. These JS en-
gines have increasingly become targets of adversaries abusing their
vulnerabilities. Vulture showed that the majority of vulnerability
fixes in Mozilla Firefox are due to JS engine components [51]. Con-
sidering the prevailing usage of JS code on the Internet and the
wide-adoption of browsers, zero-day or one-day vulnerabilities of
popular JS engines pose a critical threat. Adversaries often exploit
these vulnerabilities by luring victims to visit the webpage with
attack JS code, resulting in remote code execution.
These JS engines are lucrative targets to bug bounty hunters.
Google, Mozilla, and Microsoft offer rewards of $15,000 or even
more for the accurate reporting of these security bugs [18, 38, 42].
Furthermore, Zerodium pays ten times more for these security
bugs [67]. The monetary motives and research interests in finding
security bugs have spurred browser developers, tech-savvy users,
and intrigued researchers on to report 161 Chrome CVEs in 2018
alone [7].
To manage and track such reported bugs, each popular browser
vendor has developed a Bug Tracking System (BTS) [19, 36, 46].
These BTSs demand a specific bug report when a reporter files a new
bug. They also expect the reporter to label the found bug according
to the guidelines defined in each BTS. For instance, the Chrome
BTS requires a bug reporter to specify (1) which component a bug
belongs to, (2) whether the bug causes any crashes, and (3) whether
the bug is security-related.
This security label is important for browser vendors to prioritize
the reported security bug from other non-security bugs. It is ex-
pected that software vendors will patch any security-related bugs
within 90-days prior to public disclosure; this security label is the
sole indicator for prioritizing bug patches. However, it is possible
for a bug reporter to mislabel a security bug. Thus, browser vendors
should validate whether the filed bug is indeed a security-related
bug.
Today, this procedure is completely manual and unclear, and
it requires domain expertise, thus making the entire procedure
non-scalable and even erroneous. For instance, there were two
Chrome bug reports [10, 14] that were filed as non-security bugs.
However, it took ten months and five months, respectively to find
that they were, in fact, security related. CVE-2017-5132 was later
assigned to one of the bugs, which gave a significant time window
to exploit this publicly available vulnerability. If the bug reporters
had filed the reports as security bugs with some confidence, these
vulnerabilities would have been patched within several days.
To make the prioritizing procedure prompt and scalable, we pro-
pose CRScope, which classifies a given security bug by leveraging
Session 9: FuzzingAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand647machine learning models trained on past verdicts. Our goal is to
train a model capable of classifying security bugs without requiring
domain-specific expertise.
2.2 Crash-dump
Fuzzing is a common and prevailing technique for finding JS engine
bugs [20, 27, 53, 61]. It intentionally generates invalid or unexpected
input to a program, then monitors whether or not the target pro-
gram crashes. When a bug triggers a target JS engine to crash, the
underlying OS of the JS engine creates a file, termed a crash-dump.
A crash-dump, also referred to as a core-dump, retains a recorded
process state at the time of its termination. It contains a snapshot of
main memory and CPU registers, including a program counter and
stack pointer. It also has a process terminal signal such as SIGSEGV,
SIGABRT, SIGILL, SIGFPE, or SIGQUIT. Due to its context-rich
information, a core-dump file has been used for debugging a bug
and triaging its cause. Users do not require any purpose-built tool
to obtain a crash-dump, nor does it impose any performance over-
heads.
The idea of leveraging a crash-dump to predict whether a bug
causing a crash is exploitable was explored. Exploitable and Address-
Sanitizer are public tools that analyze a crash-dump and determine
whether the bug causing the crash is exploitable. A naive approach
for tech-savvy users without domain expertise is to use these off-
the-shelf tools that infer the exploitability of a bug causing a JS
engine to crash. Exploitable [8] is a gdb extension that inspects the
state of a Linux application that has crashed; it then classifies a bug
as to how difficult it might be for an attacker to exploit. Address-
Sanitizer [56] is another tool that assigns a memory corruption
label to a given crash. Mozilla uses this label to classify exploitable
crash reports [47] and ClusterFuzz from Google leverages this label
to rate the security severity of a found crash. When the label is
Bad-cast, or Heap-use-after-free, the found crash is classified as
a high severity bug [21]. Note that both Exploitable and Address-
Sanitizer are designed to gauge the exploitability of a given crash,
not to classify whether a given crash is security-related. We thus
conducted experiments to measure the efficacy of the two tools in
predicting security bugs. Section 3 and Section 6.1 describe in detail
our experiments on 339 bugs and their 766 crashes.
In Section 6.1, we demonstrate that Exploitable achieved 0.48
precision, producing 85% false positives. If a browser vendor uses
Exploitable to prioritize security bugs, the engineering cost of vet-
ting false positives would be unnecessarily wasted. Also, Address-
Sanitizer achieved 0.76 precision and 0.60 recall, producing an un-
acceptable number of false negatives. 190 crashes (42%) triggered
security bugs that AddressSanitizer was unable to detect. These
experimental results demonstrate that neither tool is fit to classify
security bugs in JS engines.
To address the shortcomings of these off-the-shelf tools, we de-
sign and implement CRScope leveraging machine learning models
to classify security bugs in JS engines. Anyone, including techni-
cally novice users who are motivated to find security bugs in JS
engines, can use state-of-the-art fuzzers, find a JS test causing a JS
engine crash, and claim the security bug with confidence by lever-
aging CRScope. Engine vendors also benefit from automatically
classifying reported bugs to filter spurious bug reports.
Table 1: Ground truth data for JS engines
JS engines
Security
Chakra
V8
SpiderMonkey
All
69
50
46
165
PoC code
Non-
Security All
104
91
144
339
35
41
98
174
Crash instances
Security
126
147
95
368
Non-
Security All
179
262
325
766
53
115
230
398
3 DATASET
CRScope is a binary classifier that assigns either a “security bug” or
“non-security bug” label to a given JS engine crash-dump. To train
this classifier, we built the ground truth dataset, a collection of JS
engine crash-dump files that were manually classified as security
and non-security bugs. We collected these past classification ver-
dicts from BTSs and GitHub repositories for V8, SpiderMonkey, and
Chakra.
Collecting PoCs. For security bugs, we collected CVEs with PoC
code reported between 2011 and 2018. From each Chakra release
note enlisted in the GitHub repository, we collected patched CVEs [58].
From the Chrome BTS, we also collected bug reports, each of which