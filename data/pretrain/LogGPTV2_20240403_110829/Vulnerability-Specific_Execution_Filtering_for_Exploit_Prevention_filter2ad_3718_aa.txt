title:Vulnerability-Specific Execution Filtering for Exploit Prevention
on Commodity Software
author:James Newsome and
David Brumley and
Dawn Xiaodong Song
Vulnerability-Speciﬁc Execution Filtering
for Exploit Prevention on Commodity Software
James Newsome
David Brumley
Dawn Song
Carnegie Mellon University
PI:EMAIL
Carnegie Mellon University
Carnegie Mellon University
PI:EMAIL
PI:EMAIL
Abstract
Exploits for new vulnerabilities, especially when incor-
porated within a fast spreading worm, can compromise
nearly all vulnerable hosts within a short amount of time.
This problem demonstrates the need for fast defenses which
can react to a new vulnerability quickly. In addition, a real-
istic defense system should (a) not require source code since
in practice most vulnerable systems do not have source code
access nor is there adequate time to involve the software
vendor, (b) be accurate, i.e., have a negligible false positive
rate and low false negative rate, and (c) be efﬁcient, i.e.,
add little overhead to normal program execution.
We propose vulnerability-speciﬁc execution-based ﬁlter-
ing (VSEF) – a new approach for automatic defense which
achieves a lower error rate and wider applicability than in-
put ﬁlters and has better performance than full execution
monitoring. VSEF is an execution-based ﬁlter which ﬁlters
out attacks on a speciﬁc vulnerability based on the vulnera-
ble program’s execution trace. We present VSEF, along with
a system for automatically creating VSEF ﬁlters and a hard-
ened program without access to source code. In our system,
the time it takes to create the ﬁlter and generate the hard-
ened program is negligible. The overhead of the hardened
program is only a few percent in most cases. The false pos-
itive rate is zero in most cases, and the hardened program
is resilient against polymorphic variants of exploits on the
same vulnerability. VSEF therefore achieves the required
performance, accuracy, and response speed requirements to
defend against current fast-spreading exploits.
1. Introduction
The number of new vulnerabilities reported each year
continues to grow. According to CERT/CC, in 1995 171
new vulnerabilities were reported, while less than a decade
later in 2004 over 3700 new vulnerabilities were discov-
ered [9]. A new exploit for a single vulnerability can readily
be turned into worms which compromise hundreds of thou-
sands of machines within only a few minutes [22, 35]. Thus,
after a vulnerability is discovered it is important to quickly
develop effective mechanisms to protect vulnerable hosts so
that (1) they will not be compromised by exploits of the vul-
nerability, and (2) provide service without disruption.
The speed at which new vulnerabilities are discovered
and exploits created necessitates new defenses that meet
several goals simultaneously: (1) Fast defense development
and deployment: there is often very little reaction time, es-
pecially when the exploit comes in the form of a fast prop-
agating worm. Thus, we need to be able to develop and
deploy defense mechanisms extremely quickly after the de-
tection of a vulnerability.
(2) No requirement for source
code: many vulnerable programs are commodity software
for which the source code is proprietary. To respond quickly
to new vulnerabilities, we need to be able to develop a de-
fense mechanism without access to source code, so we do
not rely on the cooperation of the software vendor. (3) High
accuracy and effectiveness: the defense mechanism should
protect against the vulnerability and should not have any un-
desirable side effect on normal execution. It should have a
low false positive rate (not blocking legitimate requests) and
a low false negative rate (even effective against polymorphic
attacks). (4) Low performance overhead: the defense mech-
anism should have low performance overhead, so a vulnera-
ble host deploying the defense mechanism can still provide
critical services with little performance degradation.
Many defense mechanisms have been proposed to pro-
tect a vulnerable host after a vulnerability has been discov-
ered. Previous work has various drawbacks and do not sat-
isfy all the above requirements. One popular approach is to
automatically generate network-based input ﬁlters to ﬁlter
out known exploits [16, 34, 18, 27, 26]. However, the accu-
racy and effectiveness of the network-based input ﬁltering
approach is fundamentally limited to syntactic properties of
the input string and cannot take into account application-
speciﬁc semantic and context information.
In particular,
there may be no syntax-based classiﬁer to correctly distin-
guish between malicious and innocuous trafﬁc for certain
applications or vulnerabilities due to polymorphic attacks;
and the lack of context information in network-based input
ﬁltering can have high false positive rate for certain applica-
tions. Input ﬁlters also have difﬁculty recognizing seman-
tically equivalent inputs, such as alternate URL encodings,
which leads to false negatives. In the extreme case where an
input ﬁlter is used on an encrypted protocol, it must some-
how be supplied with the decryption key, which is awkward
and application-speciﬁc. Costa et. al. propose automatically
generated host-based input ﬁlters [11], which has greater
accuracy than network-based input ﬁlters, and can correctly
recognize some semantically equivalent inputs. However,
the approach still suffers difﬁculty when the correct classiﬁ-
cation rule is complex and needs program state information,
or when input is encrypted. Therefore the input ﬁltering ap-
proach is not a complete solution.
On the other hand, various host-based approaches have
been proposed which are more accurate, but fail to meet
the other requirements. For example, previous approaches
have focused on: (1) Patching: patching a new vulnerabil-
ity can be a time-consuming task—generating high qual-
ity patches often require source code, manual effort, and
extensive testing. Applying patches to an existing system
also often requires extensive testing to ensure that the new
patches do not lead to any undesirable side effects on the
whole system. (2) Binary-based full execution monitoring:
many approaches have been proposed to add protection to
a binary program. However, these previous approaches are
either inaccurate and only defend against a small classes of
attacks [6, 31, 17, 23] or require hardware modiﬁcation or
incur high performance overhead when used to protect the
entire program execution [14, 27, 36, 11].
In this paper, we propose a new approach for auto-
matic defense: vulnerability-speciﬁc execution-based ﬁlter-
ing (VSEF). At a high-level, VSEF ﬁlters out exploits based
on the program’s execution, as opposed to ﬁltering based
solely upon the input string. However, instead of instru-
menting and monitoring the full execution, VSEF only mon-
itors and instruments the part of program execution which
is relevant to the speciﬁc vulnerability. VSEF therefore
takes the best of both input-based ﬁltering and full execu-
tion monitoring: it is much more accurate than input-based
ﬁltering and much more efﬁcient than full execution moni-
toring.
We also develop the ﬁrst system for automatically creat-
ing a VSEF ﬁlter for a known vulnerability given only a pro-
gram binary, and a sample input that exploits that vulnera-
bility. Our VSEF Filter Generator automatically generates
a VSEF ﬁlter which encodes the information needed to de-
tect future attacks against the vulnerability. Using the VSEF
ﬁlter, the vulnerable host can use our VSEF Binary Instru-
mentation Engine to automatically add instrumentation to
the vulnerable binary program to obtain a hardened binary
program. The hardened program introduces very little over-
head and for normal requests performs just as the original
program. On the other hand, the hardened program detects
and ﬁlters out attacks against the same vulnerability. Thus,
VSEF protects vulnerable hosts from attacks and allow the
vulnerable hosts to continue providing critical services.
Contributions. The central contribution of this paper is a
new approach for automatic defense against known vulnera-
bilities, called vulnerability-speciﬁc execution-based ﬁlter-
ing. Using the execution trace of an exploit of a vulner-
ability, our VSEF automatically generates a hardened pro-
gram which can defend against further (polymorphic) ex-
ploits of the same vulnerability. VSEF achieves three im-
portant goals: low performance overhead, fast generation,
and a low error rate. Speciﬁcally:
(cid:15) Our VSEF is an extremely fast defense. In general, it
takes a few milliseconds for our VSEF to generate the
hardened program from an exploit execution trace.
(cid:15) Our VSEF ﬁltering techniques provide a way of de-
tecting exploits of a vulnerability more accurately than
input-based ﬁlters and more efﬁciently than full execu-
tion monitoring.
(cid:15) Our techniques do not require access to source code,
and are thus applicable in realistic environments.
(cid:15) We provide two VSEF ﬁltering mechanisms for de-
tecting overwrite attacks, including buffer overﬂows,
double-free attacks, and format string vulnerabilities.
The ﬁrst mechanism, taint-based VSEF, is the most
accurate and requires potentially a longer ﬁlter. The
second mechanism, destination-based VSEF, is more
efﬁcient and is still highly accurate. Both mechanisms
have zero false positives in most cases, and are effec-
tive against polymorphic variants of the exploit of the
vulnerability. Note that our approach is general, and
could potentially be applied to other faults such as in-
teger overﬂow, divide-by-zero, etc.
(cid:15) Our experiments show that the performance overhead
of the hardened program is usually only a few percent.
These properties make VSEF an attractive approach to-
ward building an automatic worm defense system that can
react to extremely fast worms.
2.
Approach:
Vulnerability-Speciﬁc
Execution-based Filtering
Overview. We propose a new approach for automatically
defending against
just-discovered attacks, vulnerability-
speciﬁc execution-based ﬁltering (VSEF). VSEF is based on
the observation that for a speciﬁc vulnerability only the part
of the program execution that is relevant to the exploit of
the vulnerability need be monitored. VSEF monitoring has
full context and semantic information, as opposed to input-
based ﬁlters which are limited to syntactic properties. In-
strumenting the binary to perform the vulnerability-speciﬁc
execution ﬁltering results in a hardened binary. As a re-
sult, VSEF is much more accurate than network-based ﬁlter-
ing, and much more efﬁcient than full execution monitoring.
The combination of accuracy and low overhead makes the
VSEF approach very attractive for automatic deployment
schemes.
The main research questions for enabling VSEF include
(1) what part of the program should we monitor/instrument,
(2) how can we detect and ﬁlter out the attack when we only
monitor/instrument part of the program, and (3) how can we
minimize the overhead of the VSEF defense. In this paper
we address these questions.
In particular, we propose an
architecture that will automatically create VSEF ﬁlters and
harden the vulnerable program given an exploit execution
trace.
VSEF Architecture. Figure 1 shows the overall architec-
ture. Our architecture contains two main components: the
VSEF Filter Generator and the VSEF Binary Instrumenta-
tion Engine. To enable VSEF, we assume that a sample
exploit has been detected by some exploit detector which
outputs an exploit execution trace. The exploit execution
trace contains the information about the program execution
up to the detected exploit of the vulnerability. The exploit
execution trace can be a simple instruction trace dump of
the program execution or some more intelligent output from
the exploit detector. The VSEF Filter Generator uses the ex-
ploit execution trace to create a VSEF ﬁlter which encodes
the information needed for the monitoring to detect future
attacks on the vulnerability. The VSEF ﬁlter can then be
disseminated.
Vulnerable hosts use the VSEF Binary Instrumentation
Engine to apply a VSEF ﬁlter to a binary. The result is a
hardened binary program. The hardened program functions
like the original program for normal requests and introduces
very little overhead. The hardened program, however, de-
tects and ﬁlters out attacks against the same vulnerability.
Thus, VSEF protects vulnerable hosts from attacks and al-
lows the vulnerable hosts to continue to provide critical ser-
vices.
VSEF Requirements. The vulnerability-speciﬁc execution
ﬁltering architecture should have the following properties:
(cid:15) Robust VSEF ﬁlters.
A VSEF ﬁlter should be
vulnerability-speciﬁc but exploit agnostic. For exam-
ple, it should be able to detect the sample exploit even
when a polymorphic engine has been used to encrypt
the payload [37]. Note that input ﬁlters are particu-
larly vulnerable to polymorphism, as there may not be
enough syntactic information in the input to reliably
detect polymorphic variants.
(cid:15) Efﬁcient generation of VSEF ﬁlters. Once a vulner-
ability is discovered, it often takes days or months to
prepare a suitable patch. However, fast worms may be
able to infect the entire Internet in under a few minutes.
We should be able to generate ﬁlters quickly enough to
allow an effective response to such ﬂash events.
(cid:15) Efﬁcient detection. The vulnerability-speciﬁc execu-
tion ﬁltering should add as little overhead as possible
to program execution.
3. Taint-based and Stack-based VSEF
In this section, we present two concrete examples of our
VSEF system: the taint-based VSEF and the destination-
based VSEF. The taint-based VSEF is based on dynamic
taint analysis and has high accuracy. The destination-based
VSEF is an optimistic version of taint-based that usually
requires fewer instructions instrumented.
3.1. Taint-based VSEF
3.1.1. Overview
One effective method recently proposed to detect
memory-safety based attacks is dynamic taint analysis [14,
27, 36, 11]. Dynamic taint analysis marks data coming from
untrusted sources (such as the network) tainted, and then
keeps track of what data becomes tainted by untrusted input
data by inserting instrumentation instructions to propagate
the taint attribute. For example, it adds instrumentation to
each data movement instruction (mov, push, pop, etc.),
and data arithmetic instruction (add, sub, xor, etc.), so
that the result of the instruction will be marked tainted if and
only if any operand of the instruction is tainted. Dynamic
taint analysis also inserts extra instrumentation before every
point where data is used in a sensitive way (such as return
addresses, function pointers, and format strings) to ensure