tive libraries have been heavily used by apps and mal-
ware [19, 59]. At the runtime layer, although TaintDroid
can track taint propagation in DVM, it neither monitor the
runtime behaviors nor support ART. Though many stud-
ies [34, 62, 65, 68, 77, 89, 90] enhanced TaintDroid from
different aspects, they cannot achieve the same capability
as Malton. For example, AppsPlayground [62] combines
TaintDroid and fuzzing to conduct multi-path taint anal-
ysis. Mobile-Sandbox [68] uses TaintDroid to monitor
framework behaviors and employs ltrace [5] to capture
native behaviors.
To avoid modifying Android system (including the
framework, native libraries, Linux kernel etc.), a number
of studies [10, 12, 22, 23, 31, 32, 43, 60, 61, 67, 78, 81, 87]
propose inserting the logics of monitoring behaviors or
security policies into the Dalvik bytecode of the malware
under inspection and then repacking it into a new APK.
Those studies have three common drawbacks. First, they
can only monitor the framework layer behaviors by ma-
nipulating Dalvik bytecode. Second, those approaches
are invasive that can be detected by malware. Third,
malware may use packing techniques to prevent such ap-
proaches from repacking it [85, 88].
Based on QEMU, DroidScope [83] reconstructs the
USENIX Association
26th USENIX Security Symposium    301
Table 7: Comparison of Malton with the popular existing Android malware analysis tools.
Tool
On device
Non-invasive
TaintDroid [39]
TaintART [71]
ARTist [21]
DroidBox [34]
VetDroid [89]
DroidScope [83]
CopperDroid [73]
Dagger [84]
ARTDroid [30]
Boxify [20]
CRePE [29]
DroidTrace [91]
DroidTrack [64]
MADAM [35]
HARVESTER [61]
AppAudit [79]
GroddDroid [10]
ProﬁleDroid [76]
Malton
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
×
×
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
×
(cid:2)
(cid:2)
(cid:2)
(cid:2)
×
×
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
×
×
(cid:2)
(cid:2)
Support
ART
Cross-layer
Monitoring
Multi-path
analysis
In-memory
mechanism
Ofﬂoad
mechanism
Direct
execution
Without
modifying OS
×
(cid:2)
(cid:2)
×
×
×
(cid:2)
(cid:2)
(cid:2)
(cid:2)
×
(cid:2)
×
(cid:2)
(cid:2)
×
(cid:2)
(cid:2)
(cid:2)
×
×
×
×
×
×
×
×
×
×
×
×
×
×
(cid:2)
×
(cid:2)
×
(cid:2)
×
×
×
×
×
×
×
×
×
×
×
×
×
×
×
×
×
×
(cid:2)
×
×
×
×
×
×
×
×
×
×
×
×
×
×
×
×
×
×
(cid:2)
×
×
×
×
×
×
×
×
×
×
×
×
×
×
(cid:2)
×
(cid:2)
×
(cid:2)
×
×
×
×
×
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
×
(cid:2)
×
×
(cid:2)
×
(cid:2)
(cid:2)
(cid:2)
Type
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Dynamic
Hybrid
Hybrid
Hybrid
Hybrid
Dynamic
OS-level and Java-level semantics, and exports APIs for
building speciﬁc analysis tools, such as dynamic infor-
mation tracer. Hence, there is a semantic gap between
the VMI observations and the reconstructed Android spe-
ciﬁc behaviors. Since it monitors the Java-level behav-
iors by tracing the execution of Dalvik instructions, it
cannot monitor the Java methods that are compiled into
native code and running on ART (i.e, partial support of
framework layer). Moreover, DroidScope does not mon-
itor JNI and therefore it cannot capture the complete be-
haviors at runtime layer. CopperDroid [73] is also built
on top of Qemu and records system call invocations by
instrumenting Qemu. Since it performs binder analy-
sis to reconstruct the high-level Android-speciﬁc behav-
iors, only a limited number of behaviors can be mon-
itored. Moreover, it cannot identify the invocations of
framework methods. ANDRUBIS [50] and MARVIN [49]
(which is built on top of ANDRUBIS) monitor the behav-
iors at the framework layer by instrumenting DVM and
log system calls through VMI.
Monitoring system calls [17, 35, 46, 48, 54, 68, 75, 76,
84, 91] is widely used in Android malware analysis be-
cause considerable APIs in upper layers eventually in-
voke systems calls. For instance, Dagger [84] collect-
s system calls through strace [6], recodes binder trans-
actions via sysfs [7], and accesses process details from
/proc ﬁle system. One common drawback of system-
call-based techniques is the semantic gap between sys-
tem calls with the behaviors of upper layers, even though
several studies [54, 84, 91] try to reconstruct high-level
semantics from system calls. Besides tracing system
calls, MADAM [35] and ProﬁleDroid [76] monitor the in-
teractions between user and smartphone. However, they
cannot capture the behaviors in the runtime layer.
Both TaintART [71] and ARTist [21] are new frame-
works to propagate the taint information in ART. They
modify the tool dex2oat, which is provided along with
ART runtime to turn Dalvik bytecode into native code
during app’s installation. The taint propagation instruc-
tions will be inserted into the compiled code by the modi-
ﬁed dex2oat. However, they only propagate taint at the
runtime layer, and do not support the taint propagation
through JNI or in native codes. Moreover, they cannot
handle the packed malware, because such malware usu-
ally dynamically load the Dalvik bytecode into runtime
directly without triggering the invocation of dex2oat.
CRePE [29] and DroidTrack [64] track apps’ behaviors at
the framework layer by modifying Android framework.
Boxify [20] and NJAS [24] are app sandboxes that en-
capsulate untrusted apps in a restricted execution envi-
ronment within the context of another trusted sandbox
app. Since they behave as a proxy for all system call-
s and binder channels of the isolated apps, they support
the analysis of native code and could reconstruct partial
framework layer behaviors.
ARTDroid [30] traces framework methods by hooking
the virtual framework methods and supports ART. S-
ince the boot image boot.art contains both the vtable and
virtual methods arrays that store the pointers to virtual
methods, ARTDroid hijacks vtable and virtual methods
to monitor the APIs invoked by malware.
HARVESTER and GroddDroid [10, 61] support multi-
path analysis. The former [61] covers interested code
forcibly by replacing conditionals with simple Boolean
variables, while the latter [10] uses a similar method to
jump to interested code by replacing conditional jumps
with unconditional jumps. Different from Malton, they
need to modify the bytecode of malware.
302    26th USENIX Security Symposium
USENIX Association
6.2 Multi-path analysis for Android
There are a few studies about multi-path analysis for
Android. TriggerScope [40] is a static symbolic execu-
tor that handles Dalvik bytecode. Similar to other static
analysis tools, it may run into trouble when handling re-
ﬂections, native code, dynamic Dex loading etc. Anand
et al. [15] proposed ACTEve that uses concolic execution
to generate input events for testing apps and ofﬂoads con-
straint solving to the host. There are three major differ-
ences between ACTEve and the path exploration module
of Malton. First, since ACTEve instruments the analyzed
app and the SDK, this invasive approach may be detect-
ed by malware. Second, ACTEve does not support native
code. Third, it does not apply the in-memory optimiza-
tion. ConDroid [66] also depends on the static instru-
mentation, and therefore has the same limitations.
Two recent studies [52, 86] propose converting Dalvik
bytecode into Java bytecode and then using Java
PathFinder [16] to conduct symbolic execution in a cus-
tomized JVM. However, JVM cannot properly emulate
the real device. Moreover, they do not support the analy-
sis of native code.
To make concolic execution applicable for testing em-
bedded software, Chen et al. [28] and MAYHEM [26]
adopt similar ofﬂoading method. However, they do not
apply the in-memory optimization and cannot be used to
analyze Android malware. For example, Chen et al. co-
ordinates the part on device and the part on host through
the Wind River Tool Exchange protocol for VxWorks.
7 Conclusion
We propose a novel on-device non-invasive analysis sys-
tem named Malton for inspecting Android malware run-
ning on ART. Malton provides a comprehensive view
of the Android malware behaviors, by conducting multi-
layer monitoring and information ﬂow tracking and ef-
ﬁcient path exploration without the need of modifying
the malware. We have developed a prototype of Malton
and the evaluation with real-world sophisticated malware
samples demonstrated the effectiveness of our system.
Acknowledgements
We thank the anonymous reviewers for their helpful
comments. We appreciate the collaboration with mo-
bile malware research team at Palo Alto Networks. This