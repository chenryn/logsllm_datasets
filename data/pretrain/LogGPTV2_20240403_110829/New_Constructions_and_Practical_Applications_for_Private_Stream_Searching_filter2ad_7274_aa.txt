title:New Constructions and Practical Applications for Private Stream Searching
(Extended Abstract)
author:John Bethencourt and
Dawn Xiaodong Song and
Brent Waters
New Constructions and Practical Applications for
Private Stream Searching (Extended Abstract)
John Bethencourt
Dawn Song
Carnegie Mellon University
Carnegie Mellon University
PI:EMAIL
PI:EMAIL
Brent Waters
SRI International
PI:EMAIL
Abstract
A system for private stream searching allows a client
to retrieve documents matching some search criteria
from a remote server while the server evaluating the re-
quest remains provably oblivious to the search criteria.
In this extended abstract, we give a high level outline
of a new scheme for this problem and an experimental
analysis of its scalability. The new scheme is highly
eﬃcient in practice. We demonstrate the practical ap-
plicability of the scheme by considering its performance
in the demanding scenario of providing a privacy pre-
serving version of the Google News Alerts service.
1 Introduction
Sources of information on the Internet include con-
ventional websites, time sensitive web pages such as
news articles and blog posts, newsgroup posts, online
auctions, and web based forums or classiﬁed ads. To
make use of these resources we need search mechanisms
that distill the information relevant to each user. Nor-
mally, such mechanisms require the user to provide a
server with a query such as a textual keyword that
the server will compare against the documents in some
large data set. This model becomes problematic for
applications in which the user would like to hide the
search criteria. A user might want to protect the pri-
vacy of his search queries for a variety of reasons, in-
cluding protection of commercial interests and personal
privacy. Such privacy issues were brought into the
spotlight in 2005 when the U.S. Department of Jus-
tice subpoenaed records of search terms from popular
web search engines.
Trivially, search privacy may be obtained by down-
loading the entire remote resource to the client machine
and performing the search locally. However, this is typ-
ically infeasible due to the large size of the data to be
searched, the limited bandwidth between the client and
a remote entity, or the unwillingness of a remote entity
to disclose the entire resource to the client.
Many of the listed information sources may be con-
sidered streams of documents which are being contin-
ually generated and processed one-by-one by remote
servers.
In these cases, it would be advantageous to
allow clients to establish persistent searches with the
servers, where the data can be eﬃciently processed.
Content matching the search criteria can then be re-
turned to the clients. For example, the Google News
Alerts system [1] emails users whenever web news ar-
ticles crawled by Google match their registered search
keywords.
In this extended abstract, we present initial results
on an eﬃcient new cryptographic system which allows
services of this type while maintaining the secrecy of
the search criteria. The new scheme improves on both
the asymptotic complexity and practical performance
of the previous best solution, making realistic appli-
cations feasible.
In Section 4, we demonstrate this
through the concrete example of Google News Alerts,
providing a description of how to apply our scheme in
that context along with an analysis based on actual ap-
plication data. A full treatment of the proposed scheme
including detailed algorithms, complexity and correct-
ness analysis, security proofs, and several extensions is
now available in a technical report [2].
Related Work There are several problems related
to private searching, including searching on encrypted
data (in this case the data is encrypted and the query
is unencrypted) [3, 4], single-database private infor-
mation retrieval (PIR) [5, 6], and oblivious trans-
fer [7, 8, 9], with the most closely related problem be-
ing PIR. The recent work of Ostrovsky and Skeith [10]
was the ﬁrst to directly address the private searching
problem as deﬁned above and only requires commu-
nication dependent on the number of matching docu-
ments (unlike previous PIR schemes). A drawback of
their scheme is that it has steep resource requirements
that limit its practical application for many of the sce-
narios described above. Additionally, their scheme a
the keywords of each query to be selected from a pub-
lic, unencrypted dictionary. In many applications, in-
cluding a user’s search keywords in the public dictio-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:47:12 UTC from IEEE Xplore.  Restrictions apply. 
2ff
1
...
K priv
K
QueryConstruction
StreamSearch
Q
R
FileReconstruction
7f
Figure 1. Model for the private searching problem.
nary will already reveal too much information about
the client’s interests.
2 Problem Deﬁnition
In this section we review the problem of private
searching. In a private searching scheme a client will
create an encrypted query for the set of keywords
that he is interested in. The client will give this
encrypted query to the server. The server will then
run a search algorithm on a stream of ﬁles while
keeping an encrypted buﬀer
storing information
about ﬁles for which there is a keyword match. The
encrypted buﬀer will then be returned to the client
(periodically) to enable the client to reconstruct the
ﬁles that have matched his query keywords. We call a
ﬁle a matching ﬁle if it matches at least one keyword
in the set of keywords that the client is interested
in. The key aspect of a private searching scheme is
that a server is capable of conducting the search even
though it does not know which set of keywords the
client is interested in. We now formally describe a
private search scheme. A scheme for private stream
search consists of the following three algorithms; their
relationship is depicted in Figure 1.
QueryConstruction (λ, , m, K):
This algorithm
is run by a client to prepare an encrypted list of
keywords that he would like the server to search for.
The algorithm takes as input a security parameter
λ, a correctness parameter , an upper bound on
the number of ﬁles expected to match m, and an
unencrypted set of strings K that are to be used as
the search keywords. The algorithm outputs a public
key Kpub, a private key Kpriv, and an encrypted
query Q. The client then sends Kpub, Q to the server.
The correctness parameter  may be used to select
various algorithm parameters to ensure that up to m
ﬁles will be correctly retrieved with high probability.
These additional parameters are also sent to the server.
StreamSearch (Kpub,Q, f1, . . . , ft, W1, . . . , Wt): This
algorithm is run by a server to perform a private key-
word search on behalf of the client on a stream of ﬁles.
The algorithm takes as input an encrypted query Q,
a public key, Kpub, and a stream of ﬁles f1, f2, . . . , ft
and corresponding sets of keywords that describe each
ﬁle W1, W2, . . . , Wt. For each i ∈ {1, . . . , t}, the set Wi
is normally derived from the corresponding ﬁle fi as a
preprocessing step. The algorithm produces a buﬀer
of encrypted results R, which is sent back to the client.
Note that each pair (fi, Wi) is processed indepen-
dently when it becomes available, updating the buﬀer
R with the results so far. It is not necessary to have
the entire stream available before beginning processing.
FileReconstruction (Kpriv,R): This is used to ex-
tract the set of matching ﬁles from the returned en-
crypted buﬀer. The algorithm takes as input the pri-
vate key Kpriv and a buﬀer of encrypted results R. It
outputs the set of matching ﬁles { fi
(cid:2)(cid:2) |K ∩ Wi| > 0 }.
3 New Construction (Outline)
Here we provide an outline of the proposed construc-
tion; for the full description refer to [2]. The imple-
mentation is built around the homomorphism of the
Paillier cryptosystem [11, 12], namely, the fact that for
any plaintexts a, b, it is the case that D (E (a) · E (b)) =
a + b, where E denotes encryption and D denotes de-
cryption. That is, multiplying ciphertexts has the ef-
fect of adding the corresponding plaintexts. Our sys-
tem could use any other semantically secure, asymmet-
ric, additively homomorphic cryptosystem, but for con-
creteness we consider the use of Paillier in our perfor-
mance analysis.
First we describe the QueryConstruction algo-
rithm, which takes a set of strings K as search keywords
and produces an encrypted query Q. First, the client
produces an array of ciphertexts Q = (q1, q2, . . . , q(cid:2)Q)
of length (cid:4)Q initialized to encryptions of zero E (0).
Then for each w ∈ K, we replace qh(w) with E (1),
where h : {0, 1}∗ → {1, . . . , (cid:4)Q} is a hash function used
to map each keyword to a location in the array Q.
w∈Wi
(cid:3)
Now the server may use Q to process its ﬁle stream
according to the StreamSearch algorithm. To process
the ﬁle fi containing keywords Wi, the server computes
qh(w) = E (c), where c is deﬁned to be |Wi ∩K|.
The server then computes the modular exponentiation
fi = E (cfi). Note that if the ﬁle does not match
E (c)
the query c = 0, then E (cfi) is an encryption of zero.
We consider the possibility of “spurious matches” when
c (cid:5)= 0 for a non-matching ﬁle due to hash collisions
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:47:12 UTC from IEEE Xplore.  Restrictions apply. 
in Section 4.1. In order to accumulate ﬁles matching
the query, the server keeps a results buﬀer which is
an array of ciphertexts, all initialized to encryptions
of zero. The value E (cfi) is multiplied into random
locations in the array, eﬀectively adding the value cfi to
the plaintext already stored in each of the locations. If
the ﬁle does not match, this does not aﬀect the contents
of the buﬀer. In this way, the locations in the buﬀer
accumulate linear combinations of matching ﬁles. The
server also uses the value E (c) to update two small
auxiliary encrypted buﬀers containing metadata about
which ﬁles have matched. This process is described
in [2] and omitted from this high level overview. Upon
completing a period of searching, the server returns the
main data buﬀer and the auxiliary buﬀers to the client.
Possessing the private key, the client is able to use
the FileReconstruction algorithm to reconstruct the
ﬁles that matched their query. First, they decrypt the
main data buﬀer to obtain the plaintext of each entry,
which is a linear combination of some of the matching
ﬁles. With the help of some information from the two
metadata buﬀers, the client is then able to establish a
system of linear equations which may be be solved for
the content of the matching ﬁles. If the number of ﬁles
that matched the query exceeds the number of places
in the main data buﬀer, however, the buﬀer has “over-
ﬂowed” and the ﬁles cannot be recovered. Thus the
user must establish an upper bound m on the number
of ﬁles they expect to match and specify the size of the
main data buﬀer accordingly, perhaps allowing some
extra space if the number of ﬁles which will match is
uncertain. This is done in the QueryConstruction al-
gorithm, with the client passing the desired parameters
to the server for use in StreamSearch.
Apart from the possibility of too many ﬁles match-
ing the query, there are a couple of other scenarios in
which the ﬁles may be unrecoverable. In [2] we give
a detailed analysis of these cases, demonstrating that
their probability diminishes exponentially with linear
increases to the buﬀer size and giving upper bounds on
the buﬀer size necessary to bound the failure probabil-
ity below some . In practice the new system requires
near minimal overhead to achieve a high probability of
success. This is in contrast to the scheme of Ostrovsky
and Skeith, which is quite demanding; this is consid-
ered in Section 4. One additional diﬀerence between
our proposed scheme and that of Ostrovsky and Skeith
is the absence of a predetermined keyword dictionary
D.
In most situations, providing a dictionary of all
keywords one could possibly be searching for is a seri-
ous security limitation. Many of the strings a user may
want to search for are obscure (e.g., names of particu-
lar people or other proper nouns) and including them
r
0.1
0.01
0.001
sq
1.3 MB
13.1 MB
132.8 MB
optimized sq
0.3 MB
3.6 MB
36.6 MB
Table 1. Size of the encrypted query neces-
sary to achieve a given spurious match rate
before and after optimizations.
in D would already reveal too much information. Since
the size of encrypted queries is proportional to |D|, it
is not feasible to ﬁll D with, say, every person’s name,
much less all proper nouns.
4 Practical Performance Analysis
We now consider the case of making a private ver-
sion of Google’s News Alerts service [1] using the new
construction. According to the Google News website,
their web crawlers continuously monitor approximately
4,500 news websites. These include major news portals
such as CNN along with many websites of newspapers,
local television stations, and magazines. In this setting,
we analyze four aspects of the resources necessary for a
private search: the size of the query sent to the server
(sq), the size of the storage buﬀers kept by the server
while running the search and eventually transmitted
back to the client (sb), the time for the server to pro-
cess a single ﬁle in its stream (tp), and the time for the
client to decrypt and recover the original matching ﬁles
from the information he receives from the server (tr).
4.1 Query Space
∗
n2 is
n(cid:5)
If we assume a 1024-bit Paillier key, then the en-
crypted query Q is 256(cid:4)Q bytes, since each element
from the set of ciphertexts Z
bytes, where
n is the public modulus. The smaller (cid:4)Q is, the more
ﬁles will spuriously match the query. Speciﬁcally, we
obtain the following formula for the the probability r
that a non-matching ﬁle fi will nevertheless result in a
non-zero corresponding E (c) (rearranged on the right
to solve for (cid:4)Q).
(cid:4)log2
4
(cid:4)
(cid:5)|Wi|
|K|
(cid:4)Q
r = 1 −
1 −
(cid:4)Q =
|K|
1 − (1 − r)
1
|Wi |
We performed a sampling of the news articles linked
by Google News and found that the average distinct
word count is about 540 per article. This produces
the false positive rates for several query sizes listed in
Table 1. The ﬁrst column speciﬁes a rate of spurious
matches r and the second column gives the size sq of
the minimal Q necessary to achieve that rate for a sin-
gle keyword search. Additional keywords increase sq
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:47:12 UTC from IEEE Xplore.  Restrictions apply. 
B
M
n
i
e
z
i
s
 12
 10
 8
 6
 4
 2
 0
 0
original files
size in proposed system
 200
 100
expected number of matching documents
 300
 400
B
M
n
i
e
z
i
s
 120