在近期的 CTF 比赛里，频繁地遇到开启了 NX 保护的二进制程序，绕过 NX 保护最常用的方法就是 ROP。网络上关于 ROP 的原理和 CTF
这类题目的文章较多，但是这些文章要不就是给出了一堆代码，要不只是单纯地讲解 CTF 题目和 ROP 原理（写的还不详细），也缺乏系统性地讲解这类 CTF
题目的解题步骤，这通常会阻碍初学者的学习步伐和热情。
所以本文主要总结了 ROP 绕过 NX 涉及的多个知识点，并给出 ROP 绕过 NX 常见的步骤，从而形成一套完整可用的解题框架，最后结合最近二道 CTF
题目教会读者如何应用这套框架快速解决这类问题。
### 你需要具备的先验知识
这部分只总结你需要成功利用 ROP 绕过 NX 保护需要具备的基础知识。
（1） **linux_64 与 linux_86 的区别**
首先是内存地址的范围由 32 位变成了 64 位。但是可以使用的内存地址不能大于
0x00007fffffffffff，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86 中参数都是 **保存在栈上** , 但在 x64 中的
**前六个参数** 依次保存在 RDI, RSI, RDX, RCX, R8 和 R9 **寄存器中** ，如果还有更多的参数的话才会保存在栈上。
（2） **函数调用约定**
函数的调用约定就是描述参数是怎么传递和由谁平衡堆栈的，以及返回值的。常见的四种调用约定如下：
    _stdcall （windowsAPI 默认调用方式）
    _cdecl （c/c++默认调用方式）
    _fastcall
    _thiscall
每种约定的具体内容你可以自行去 Google 学习，但是在 CTF 中你只需要打开 IDA 阅读二进制的汇编代码就可以清晰地看懂程序的 **参数传参顺序**
、 **栈传参还是寄存器传参** 、 **函数内平衡堆栈还是函数外** 。用 IDA **直接阅读** 程序的 **汇编代码**
非常关键——第一，出题人很可能会在汇编中做些手脚；第二，国际大佬都是不用 F5 的。
（3） **CTF 的二进制题目有时候为什么要给一个 libc.so 文件**
告诉你程序具体使用了什么版本的 libc.so，在 ROP 绕过 NX 技术中也是告诉你 libc 的 **函数之间的偏移地址** 。libc
加载基地址一般会变化但是 libc 里面的函数相对地址和相对基地址的偏移是不会变的。
（4） **溢出覆盖 EIP 指向的位置为函数地址来触发函数的调用和在汇编中用 call 去调用函数地址去执行有什么区别？**
后者比前者多了一个下一条汇编指令地址入栈的操作，然后他们都会到函数的第一行汇编代码开始执行。
（5） **GDB 调试的时候我该如何输入不可见字符**
GDB 调试的程序如果开始等待用户输入，这时候 GDB 是处于等待状态的，没法帮助你输入内容。查找 Google。最佳的解决办法就是这样：
    # 千万别用 python -c "print '\x00\x61'" > input，\x00 不会被打印，不会写入文件
    # 编写 Py 脚本
    s = "\xa9\x06\x40\x00\x00\x00\x00\x00"
    with open("input", "wb") as f:
        f.write(s)
    # GDB 开始调试
    r 
图中地址 0x4007e3 就是我们需要的 gadget_addr。
（2）bin_sh_addr 指向的是字符串参数：/bin/sh\0。
首先你需要搜索一下程序是否有这样的字符串，但是通常情况下是没有的。这时候就需要我们在程序某处写入这样的字符串供我们利用。我们需要用 IDA
打开程序，看左边函数窗口程序加载了下面哪些函数：
    read、scanf、gets
通常我们将这个字符写入 .bss 段。.bss 段是用来保存全局变量的值的，地址固定，并且可以读可写。通过 `readelf -S pwnme`
这个命令就可以获取到 bss 段的地址了（ida 的 segements 也可以查看）。
（3）system_addr 则指向 libc 中的 system 函数 。
可以先查看一下程序本身有木有可以利用的子函数，这样可以大大减少 EXP 开发时间。因为从 libc 中使用函数，需要知道 libc 的基地址。通常得到
libc 基地址思路就是：
    泄露一个 libc 函数的真实地址 => 由于给了 libc.so 文件知道相对偏移地址 => libc 基地址 => 其他任何 libc 函数真实地址
泄露一个 libc 函数的地址需要使用一个能输出的函数，同样用 IDA 打开程序，看左边的函数窗口程序加载了哪些函数可以利用：
    write、printf、puts
特别注意：由于 libc 的延迟绑定机制，我们需要选择已经执行过的函数来进行泄露。你需要找到函数的 plt 地址，找到 jmp
指向的那个地址才是我们需要泄露的（参考后文 classic）。
### ROP 绕过 NX 实现框架
**总结上面的内容，一个基本的的 ROP 绕过 NX 利用的流程是** ：
  * 在同一次远程访问中，我们首先通过泄露一些函数真实地址结合相对偏移得到 system 函数的真实地址
  * 执行完上述步骤后，我们需要控制程序再次执行到缓冲区溢出漏洞点
  * 再利用缓冲区溢出漏洞，写入 "/bin/sh\0" 字符串到 .bss，并触发 system 执行
网上很多人会使用 pwntool 的 DynELF 作为泄露的工具，但是这种方法经常会遇到各种问题，尤其是只能利用 puts
函数泄露的时候。另外的做法是自己编写二个 payload 完成上述的利用流程，第一个 payload 去完成泄露并再次到漏洞函数执行，第二个 payload
执行写入 "/bin/sh\0" 字符串到 .bss 并让程序调用 system ，这样得到 shell。
我 **强烈推荐** 后面的 **双 payload** 做法，也是我去解决后文 classic 题目的做法。因为我最初明白 ROP
步骤中的泄露原理还是通过钻研网上的 DynELF leak 案例搞懂的，下文会先帮助读者分析明白 DynELF leak
函数编写的原理，再讨论我推荐的做法。（当然 pwntool 有 ROP 模块可以直接用，但是这种不是万能，处理一些不常规的题目时效果不好，也不利于学习
ROP 的原理）
##### DynELF leak 原理解析