macro was used to generate the correct symbol su(cid:14)x
for a policy being compiled for a host in one of the
four quads. (The correct quad was computed from the
hostname of the target host, but could be manually
(cid:12)xed for cross compilation). For example, the port
binding for the heartbeat service of the downstream
controller (DC), a DPASA component, was speci(cid:12)ed
with:
defport( dc_heartbeat_port_t, udp, \
Qx(dc_heartbeat_port__1) )
Finally, the make(cid:12)le for the SELinux policy was mod-
i(cid:12)ed to include a target to regenerate the m4 macros
from the correct master con(cid:12)guration source as needed.
The DPASA SELinux policies employ 5 roles, 500-
600 types and 32000-35000 rules, depending on the
jobs performed by the host. The number of rules re-
quired to address a given policy goal is reduced by us-
ing SELinux attributes to label equivalence classes of
objects such as hosts. For example, all of the hosts
in the client network are labeled as client node type
and policies that apply to any client node can refer
to client node type instead of each individual client.
For reference, a client node with only the baseline
SELinux policy (stock policy from Gentoo with stan-
dard extensions to handle X) contains 425 types and
30107 rules.
The SELinux policies were empirically validated
through the correct operation of the JBI. That is, our
(cid:12)rst priority was to ensure that the JBI worked as
expected. SELinux alerts observed during functional
testing were converted manually into additional pol-
icy rules, which granted the process the minimal per-
mission required for correct operation. Since permis-
sions were added only as required, we had con(cid:12)dence
that DPASA reasonably followed the principle of least
privilege. Unfortunately, the compressed development
schedule for this project left no time to explore any of
the analysis tools provided by the SELinux community;
employing a formal-model analysis tool ([5, 22, 12])
would have provided additional assurance that the
SELinux policies correctly protected the DPASA ap-
plications.
5.2. CSA Policy
Because they were complementary technologies at
the same defense layer, CSA and SELinux policies
should have been logically identical; however, the two
tools di(cid:11)ered vastly in their conceptual models. Also,
CSA lacked any facility (even an implicit one such as
SELinux’s text-based con(cid:12)guration (cid:12)les) to integrate
with other tools. As a result, we could not inte-
grate CSA either with SELinux or with the DPASA
properties infrastructure (see Section 3).
So while
the SELinux policies, which were integrated fully with
the properties infrastructure, were able to satisfy the
DPASA communication requirements (see Figure 3),
CSA, for reasons of concern about divergence with
SELinux, ADF and JVM (all of which were coordi-
nated by the properties infrastructure), satis(cid:12)ed only
a subset of those requirements.
To satisfy all requirements, we would have needed
to duplicate the properties infrastructure within CSA.
However, the system was still under development as
CSA policies were being written, so there was a real
risk of divergence. For each CSA-protected host, we
opted instead to specify the other hosts with which
it was permitted to communicate and to restrict that
communication to authorized protocols (i.e., TCP and
UDP). We did not specify the speci(cid:12)c network services
(e.g., Alerts or RmiReg). As the system development
stabilized more, those services could be added; how-
ever, on-going maintenance remained a big concern.
In all, eleven policies were de(cid:12)ned. There was one
policy for each Solaris or Windows host, except that the
ADF Policy Servers (Windows) shared a policy. The
typical Unix policy contained approximately 13 allow
rules, 8 deny rules and 8 monitoring rules (detection
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:13:22 UTC from IEEE Xplore.  Restrictions apply. 
only). The typical Windows policy contained approxi-
mately 24 allow rules, 18 deny rules and 7 monitoring
rules.
Like SELinux, CSA policies were validated through
the correct operation of the JBI. Unlike SELinux, CSA
o(cid:11)ered the ability to generate an easy-to-read sum-
mary of each host’s policy. CSA’s strategy of allow-
ing what is not explicitly denied made careful review
even more critical. We (cid:12)rst denied everything (e.g., all
network access), then we speci(cid:12)ed only authorized ac-
cesses (e.g., the remote hosts and protocols authorized
for communication).
6. Host Layer Policy
Initially, ADF policies were translated automatically
from JVM policies. For the few non-Java components,
either \fake" JVM policies were created or the compo-
nent’s ADF policy was speci(cid:12)ed directly. However, the
JVM policy could not support the translation without
annotation. For example, JVM policies do not distin-
guish between TCP and UDP protocols, and do not, by
default, identify the local host or the ephemeral port
(if any). This information was added as a comment to
each connect authorization in the JVM policy listings
and can be seen in the listing below which describes
a UDP connection from 192.168.4.162 on port 5701 to
192.168.4.170 on port 9901.
permission java.net.SocketPermission \
"192.168.4.170:9901", "connect"; \
// 192.168.4.162,Heartbeats,UDP,5701
The JVM policies were then processed to create a
single, intermediate speci(cid:12)cation containing entries of
the form
source IP, source port, destination IP, \
destination port, protocol, service
where source IP and destination IP are standard nu-
meric IPv4 host addresses, source port and destination
port represent TCP or UDP ports or port ranges, proto-
col is any valid Internet protocol, and service is a char-
acter string by which to identify the network service
implied by the other (cid:12)elds in this entry. These entries,
when combined with the non-JVM entries, constituted
the complete connection speci(cid:12)cation from which all
ADF policies were generated.
Unfortunately, there were two critical shortcomings
with translating ADF policy automatically from JVM
policy. First, the \fake" JVM policies were not vet-
ted adequately, since they were never actually used to
enforce Java process behavior, and we encountered nu-
merous errors when ADF enforced the incorrect rules
resulting from these policies. Second, we eventually
reached a point where the generated ADF policies vi-
olated design constraints for ADF. In particular, the
generated policies exceeded the maximum ADF policy
size, and they required more VPG keys to be assigned
to a host than its NIC could support. We considered
developing a tool to perform the required optimiza-
tions, we decided against doing so because its utility
would have been restricted to DPASA.
However, while we determined that the connection
speci(cid:12)cation should not be generated automatically
from the JVM policies, there was still much value in
creating it. The connection speci(cid:12)cation served many
useful purposes: (a) it was a single source from which
all ADF policies could be generated; (b) it was used
to generate a graphical depiction of each policy, in a
manner similar to Figure 3; and (cid:12)nally, (c) it was used
to validate authorized communications against inde-
pendent network scans. So we changed our strategy
to maintain a \permanent" connection speci(cid:12)cation so
that only valid ADF XML would be generated; how-
ever, we continued to perform an automatic translation
of JVM policy into the temporary speci(cid:12)cations for the
purpose of policy discovery. The remainder of this sec-
tion discusses each of the purposes described above.
ADF policy was generated per host. A connection
statement such as
host A, 1024-65535, host B, 80, TCP, web
really implies two ADF policies: one for host A and
one for host B. In this case, the ADF policy for host A
would allow it to send TCP 80 packets to host B en-
crypted using the VPG key for B and receive replies to
those requests encrypted with its own VPG key. The
ADF policy for host B would allow it to receive TCP 80
packets from host A encrypted with its own VPG key
and send responses to A encrypted with the VPG key
for A. By generating both policies from a single state-
ment, we ensured consistency between the two policies,
which is particularly critical for successful VPG com-
munication.
Once all VPG policy rules were generated, the rules
for a given host were collected, ordered for optimal eval-
uation (ingress (cid:12)ltering then egress (cid:12)ltering for better
performance against network attack), and then were
translated into XML, imported into the ADF Policy
Server, and distributed to the host. In all, 28 ADF poli-
cies were generated (some hosts were grouped under a
common policy) with an average of 21 rules per policy,
or just over 600 rules total. Because the translation
routines were demonstrated to be trustworthy enough
to generate correct ADF XML from a well-formed con-
nection statement, policy debugging was done mainly
by analyzing the connection speci(cid:12)cation itself, rather
than by examining the ADF XML output. This sim-
pli(cid:12)ed ADF VPG policy debugging for developers un-
familiar with ADF.
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:13:22 UTC from IEEE Xplore.  Restrictions apply. 
To further facilitate developer validation of the ADF
VPG policies, we developed scripts to convert the high-
level connection statements into dot 5 diagrams, such
as the one illustrated in Figure 3. The dot diagrams
provide no more information than the connection spec-
i(cid:12)cation itself, but the data is presented in a form that
is more visually pleasing.
Finally, we compared the permissions granted in
ADF’s connection speci(cid:12)cation against network scans
in order to detect policy miscon(cid:12)gurations, which are,
according to The CERT Guide to System and Network
Security Practices[4], the most common cause for (cid:12)re-
wall breaches. Typical policy audits for border (cid:12)rewalls
are performed with scanning hosts placed on each side
of the (cid:12)rewall under test. However, no clear boundary
exists for distributed (cid:12)rewalls. With them, the visi-
ble policy is the union of both the sender and receiver
rulesets, thus the communications allowed to/from a
host will be dependent on the network perspective. To
complete a full, thorough audit the network scan must
be initiated from each host to every other host. This
captures the combined e(cid:11)ect of the egress (cid:12)ltering on
the sending host and the ingress (cid:12)ltering on the receiv-
ing host. If desired, extra hosts with no egress (cid:12)ltering
could be added to the scan to (cid:12)nd errors masked by
egress (cid:12)lters.
The primary goal of our network scan tool was to 1)
detect unauthorized communication paths and 2) de-
tect unnecessary communication paths which exist in
the system. The scans were coordinated via ssh on
a separate DPASA control network (used for develop-
ment purposes only), so no recon(cid:12)guration of ADF it-
self was required to support the scan. Each scan was
performed by nmap, with the central controller receiv-
ing the results in standard nmap XML format. Each
(cid:12)le contained all live hosts that were found during the
scan and the state of the ports on those hosts. The
state of the ports were classi(cid:12)ed as: open (responded
with TCP SYN-ACK or UDP data), closed (responded
with TCP RST or ICMP Port Unreachable), or (cid:12)ltered
ports (No Response).
If there were no miscon(cid:12)gura-
tions, all ports should return (cid:12)ltered except those that
were explicitly allowed in the connection speci(cid:12)cation.
After all the host scans were performed, the re-
sults were combined to create the global network view.
This process was straight-forward and achieved with
a Python script. The (cid:12)nal result was an XML (cid:12)le
containing a list of each communication path that was
found in the system. Using XSLT to transform this
output, the results were compared automatically with
the ADF connection speci(cid:12)cation to discover miscon-
(cid:12)gurations and unnecessary communication paths.
5http://www.graphviz.org
The scan did detect extra communication paths that
were not authorized within the ADF connection speci(cid:12)-
cation, but further examination revealed that the ADF
policies themselves had been manually edited to autho-
rize these paths. This (cid:12)nding underscores the impor-
tance of independent testing, because the connection
speci(cid:12)cation did not re(cid:13)ect the true protection pro(cid:12)le.
7. Lessons Learned
Our hybrid policy construction approach worked
well because policies could be developed independently
and simultaneously by various authors, which was par-
ticularly important given DPASA’s compressed devel-
opment schedule. Since the policy authors were geo-
graphically dispersed, the coordination required for a
master policy speci(cid:12)cation would have been di(cid:14)cult.
Also, it was not necessary for all authors to develop
expertise on all technologies. The approach of starting
with a minimal policy and adding to it, as operational
failures (due to policy) were observed, helped to min-
imize concerns about unnecessary privileges, such as
was discussed at the end of Section 6. While it is pos-
sible that some functional behaviors could have been