∗ S chooses y ←R Zq and returns Y = yP to
∗ S looks in H list for entry (∗,∗,∗, X, Y, C, B,∗).
the adversary M .
If ﬁnds it, S computes
¯Z1 = ˆZ1/(e(Y, dC1 )e(X, yZ)e(QB1 , dC1 ))
¯Z2 = ˆZ2/(e(Y, dC2 )e(X, yZ)e(QB2 , dC2 ))
r ¯Z2
?= e(X, Z)s.
Then S checks if ˆZ1, ˆZ2 are correctly gener-
ated by checking (Theorem 1) ¯Z1
Also, note that the values ˆZ1, ˆZ2 are correctly
generated iﬀ ˆZi = e(Y + QBi , xZ + dCi ),
which is equivalent to ¯Zi = e(QBi , xZ) =
e(X, Z)wi (i=1,2). S also checks ˆZ3
?= yX.
· If both predicates evaluates to 1, S stores
the new tuple (X, Y, C, B, h) in Llist (The
value h is from H list).
· Otherwise, S chooses SK ∈ {0, 1}k at
random and stores the new tuple (X, Y, C,
B, SK) in Llist.
∗ Otherwise, chooses SK ∈ {0, 1}k at random
and stores the new tuple (X, Y, C, B, SK) in
Llist.
– Otherwise (IDi (cid:54)= B), the simulator S replies ac-
cording to the protocol speciﬁcation.
• SessionKeyReveal(Πs
i,j):
– If Πs
i,j is Test session, S aborts.
– Otherwise, S returns the stored value SK in Llist
to M .
• Test(Πs
i,j):
i,j is not Test session, S aborts.
– If Πs
– Otherwise, S randomly chooses ζ ∈ {0, 1}k and
returns it to the adversary M .
As the attack that adversary M mounts is Forging attack,
if M succeeds, it must have queried oracle H on the ﬁrst
two inputs of this form Z∗
1 = e(Y ∗ + QB1 , xZ + dA1 ) =
e(Y ∗ + QB1 , uZ + dA1 ), Z∗
2 = e(Y ∗ + QB2 , xZ + dA2 ) =
e(Y ∗+QB2 , uZ+dA2 ), where X = U is the outgoing message
of Test session by the simulator and Y ∗ is the incoming
message from the adversary M . To solve BDH(U, Z, W )
problem, for all entries in H list, S randomly chooses one
entry Z∗
2 and proceeds with following steps:
1 , Z∗
S computes
Z1 = Z
∗
1 /(e(Y
Z2 = Z
∗
2 /(e(Y
∗
∗
, dA1 )e(QB1 , dA1 )) = e(Y
, dA2 )e(QB1 , dA2 )) = e(Y
∗
∗
+ QB1 , xZ)
+ QB2 , xZ)
Then, S computes
¯Z =
Z2
Z1
= e(QB2 − QB1 , xZ) = e(sP − rW1 − W1, xZ)
Again, S computes
( ¯Z/e(X, Z)s)
−1
r+1 = e(X, Z)w1 = e(U, Z)w
This contradicts the BDH assumption.
The success probability of S is
P r[S] ≥
1
s(k)n(k)2t(k)
p1(k)
(3)
where p1(k) is the probability of the event that CASE 1.1.1
occurs and the adversary M succeeds in this case, t(k) is the
polynomial bound on the number of distinct H calls made
by the adversary M .
1
CASE 1.1.2:
In this case, given BDH problem instance (U = uP, Z =
zP, W = wP ), where u, z, w ∈ Zq and U, Z, W ∈ G. The
solver S’s task is to compute BDH(U, Z, W ) = e(P, P )uzw.
S sets KGC master public key to be Z. With probability at
least
n(k)2 , S guesses the adversary M will select one party
denoted by A as the owner of the session ˆs and the other
party denoted by B as the peer. With probability at least
1
s(k) , S guesses the adversary M will select the session ˆs as
Test session. The simulation performed by S is the same as
that of CASE 1.1.1. except that S assigns A(cid:48)s static public
key to be QA1 = U1 = U, QA2 = U2 = s∗P − r∗U , B(cid:48)s static
public key to be QB1 = W1 = W, QB2 = W2 = sP − rW
and the ephemeral public key of the Test session owned by
A to be X = gx, where x, s∗, r∗, s, r ∈R Zq. Furthermore, S
assigns random static key pairs for the remaining n(k) − 2
parties (except for A and B).
When the adversary M activates a party whose static key
S possesses, S follows the protocol description. The simu-
lation of A, B is similar to that of CASE 1.1.1 except that
the communications that the adversary activates happen be-
tween A and B (because S knows neither A’s static private
key nor B’s static private key).
Without loss of generality, we assume that B is the re-
sponder. We assume that the message X is generated by
the adversary M and Y by the simulator S being on behalf
of B. We claim that the probability that the adversary M
generates correctly these values ˆZ1 = e(X + QA1 , yZ + dB1 ),
ˆZ2 = e(X + QA2 , yZ + dB2 ) is negligible. The proof will be
presented in appendix A.
Now, having the conclusion above, S can answer the ad-
versary’s queries easily. Below we just describe S’s replies
which are diﬀerent from that of CASE 1.1.1.
• H1(IDi): S maintains an initially empty list H list
1 with
entries of the form (IDi, li1, QIDi1 ). S simulates the
oracle in the same way as that of CASE 1.1.1 except
for queries of the form H1(A).
– If IDi = A, S randomly chooses s∗, r∗ ∈ Zq,
computes QA1 = U, QA2 = s∗P − r∗U , then in-
serts (A, null, QA1) into the H list
responding (A, null, QA2) into the H list
tained in H2 query).
and inserts cor-
(main-
1
2
The H2(IDi) queries can be dealt with similarly.
• H( ˆZ1, ˆZ2, ˆZ3, X, Y, IDi, IDj): S maintains an initially
empty list H list with entries of the form ( ˆZ1, ˆZ2, ˆZ3,
X, Y, IDi, IDj, h). S simulates the oracle in the same
way as that of CASE 1.1.1 except for queries of the form
( ˆZ1, ˆZ2, ˆZ3, X, Y, A, B). The simulator S responds to
these queries in the following way:
responds with stored value h.
– If ( ˆZ1, ˆZ2, ˆZ3, X, Y, A, B) is already there, then S
– Otherwise, S chooses h ∈ {0, 1}k at random, sends
it to M and stores the new tuple ( ˆZ1, ˆZ2, ˆZ3, X, Y,
A, B, h) in H list.
• Send(Πs
i,j, m): S maintains an initially empty list
Llist with entries of the form (X, Y, IDi, IDj, SK).
– In the case that IDi = B and IDj = A (we set
X = m. The case that IDi = A and IDj = B
can be deal with similarly.)
∗ S chooses y ←R Zq and returns Y = yP to
∗ S chooses simply SK ∈ {0, 1}k at random
and stores the new tuple (X, Y, A, B, SK) in
Llist.
the adversary M .
– In the case that IDi = B and IDj = C, where S
knows C’s private key, The simulation action of
S is similar to that of CASE 1.1.1.
As the attack that adversary M mounts is Forging attack,
if M succeeds, it must have queried oracle H on the ﬁrst
two inputs of this form Z∗
2 =
e(Y ∗ + QB2 , xZ + dA2 ), where X is the outgoing message
chosen by the simulator S and Y ∗ by the adversary. To solve
BDH(U, Z, W ) problem, for all entries in H list, S randomly
chooses one entry Z∗
2 and proceeds with following steps:
1 = e(Y ∗ + QB1 , xZ + dA1 ), Z∗
1 , Z∗
∗
+QB1 , dA1 ) = e(Y
∗
+W, zU )
(e(Y ∗ + QB2 , xZ))e(Y ∗ + sP − rW, s∗Z)e(sZ,−r∗U )
S computes
Z∗
1
Z1 =
= e(Y
2
Z∗
e(Y ∗ + QB1 , xZ)
(cid:18)
(cid:18)
(cid:18) e(Y ∗ + sP − rW, z(s∗P − r∗U ))
(cid:19) −1
(cid:18) e(Y ∗ + sP − rW,−r∗zU )
e(Y ∗ + sP − rW, s∗Z)e(sZ,−r∗U )
e(Y ∗ + sP − rW, s∗Z)e(sZ,−r∗U )
e(Y ∗ + QB2 , dA2 )
r∗
r∗
(cid:19) −1
(cid:19) −1
r∗
Z2 =
=
=
=
e(sZ,−r∗U )
−1
r∗
zU )
=e(Y
∗ − rW,−r
∗
∗ − rW, zU )
Again, S computes
=e(Y
(cid:19) 1
r+1
(cid:18) Z1
Z2
(cid:18) e(Y ∗ + W, zU )
e(Y ∗ − rW, zU )
=
=e(W, zU ) = e(P, P )uzw
(cid:19) 1
r+1
= e(W + rW, zU )
1
r+1
This contradicts the BDH assumption.
The success probability of S is
P r[S] ≥
1
s(k)n(k)2t(k)
p2(k)
(4)
where p2(k) is the probability of the event that CASE 1.1.2
occurs and the adversary M succeeds in this case, t(k) is the
polynomial bound on the number of distinct H calls made
by the adversary M .
5.2 The Analysis of CASE 1.2
In this case, according to the freshness deﬁnition, the ad-
versary M has four ways to mount the attacks.
CASE 1.2.1. The adversary M makes ephemeral key query
to both the Test session and the matching session of the Test
session (The adversary does not reveal their corresponding
static private key).
CASE 1.2.2. The adversary learns the static private key
of both the owner of Test session and its peer.
CASE 1.2.3. The adversary makes queries to the static pri-
vate key of the owner of Test session and its peer’s ephemeral
static key.
1
CASE 1.2.4. The adversary makes queries to the ephemeral
private key of the owner of Test session and its peer’s static
private key.
For CASE 1.2.1, given the BDH instance (U = uP, Z =
zP, W = wP ), where U, Z, W ∈ G, the task of solver S is to
n(k)2 , S
solve the BDH problem. With probability at least
guesses the adversary M will select one party denoted by A
as the owner of the session ˆs and the other party denoted by
1
s(k) , S guesses the
B as the peer. With probability at least
adversary M will select the session ˆs as Test session. We as-
sume that the owner of Test session is A and owner of match-
ing session is B. S randomly chooses s, r, s∗, r∗ ∈R Zq and
sets A’s public key to be QA1 = U, QA2 = s∗P − r∗U , B’s
public key to be QB1 = W, QB2 = sP − rW . S assigns the
static public/private pairs for the remaining n(k)−2 parties.
S sets the KGC master public key to be Z. The simulation of
A and B is similar to that of CASE 1.1.2. If the adversary M
succeeds in Test session for which the exponents x, y is cho-
sen by S on behalf of A,B then M must have queried H ora-
cle with the values Z∗
2 = e(Y +
QB2 , xZ + dA2 ), where X, Y are generated by the simulator.
For all entries in H list, S randomly chooses one entry Z∗
1 , Z∗
2 .
From one of these values, say Z∗
1 , knowing x, y, S can com-
pute BDH(U, Z, W ) = Z∗
1 /(e(Y + QB1 , xZ)e(Z, yU )) =
e(QB1 , dA1 ) = e(W, zU ) = e(P, P )wuz. This contradicts the
BDH assumption.
1 = e(Y + QB1 , xZ + dA1 ), Z∗
The success probability of S in this case is
P r[S] ≥
2
s(k)n(k)2t(k)
p3(k)
(5)
where p3(k) is the probability of the event that CASE 1.2.1
occurs and the adversary M succeeds in this case. t(k) is the
polynomial bound on the number of distinct H calls made
by the adversary M .
For CASE 1.2.2, given the CDH instance U, V , where U, V ∈
G, we construct a solver F of CDH(U, V ) problem. With
s(k)2 , F guesses that the adversary M
probability at least
will select one of two sessions as Test session and other as
matching session. We assume that the owner of Test session
is A and owner of matching session is B. F sets ephemeral
2
(cid:19) −1
r∗
public key of Test session owned by A to be U and of its
matching session to be V . F sets KGC master private key
itself and assigns all static public/private key pairs for n(k)
parties. As F knows KGC master private key and all paries’
static private key, the simulation of all queries is easy. If the
adversary M succeeds in a Test session then M must have