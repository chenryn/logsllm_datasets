from the correctness of the functionalities F ğ‘,ğ‘›,ğ‘¡
Mod
the fact that(cid:106) (ğ‘âˆ’ğ‘˜)
(cid:107)
= 0 iff ğ‘ â‰¥ ğ‘˜.
2ğ›¾
Security. Let ğ¶ âŠ‚ [ğ‘›] be the set of corrupted parties (|ğ¶| = ğ‘¡ 
2ğœ…+ğ›¾ (where ğ›¾ = âŒˆlog ğ‘›âŒ‰ + 1) with ğ‘ mod 4 = 3 and proceeds
as follows: first, in an input-independent Pre-processing step, the
parties generate (ğ‘›, ğ‘¡)âˆ’ shares of a pair of random non-negative
integers (ğ‘ â€², ğ‘ â€²â€²), such that (2 Â· ğ‘ â€²â€² + ğ‘ â€²) is of ğ›¾ + ğœ… bits, which is
required for security reasons as discussed later. Then, they locally
compute and get the (ğ‘›, ğ‘¡)âˆ’ shares of ğ‘ = 2ğ›¾âˆ’1 + ğ‘ + 2ğ‘ â€²â€² + ğ‘ â€², which
is revealed to ğ‘ƒ1. ğ‘ƒ1 then computes ğ‘0 = ğ‘ mod 2 and sends it
to all parties. Finally, all parties locally compute and get (ğ‘›, ğ‘¡)âˆ’
shares of ğ‘‘ = ğ‘0 + ğ‘ â€² âˆ’ 2ğ‘0ğ‘ â€², which is the required output. A formal
description of the protocol is given in Figure 14.
Parameters: There are ğ‘› parties ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› with (ğ‘›, ğ‘¡)âˆ’
shares [ğ‘], of ğ‘ âˆˆ Fğ‘ and ğ‘  2ğœ…+ğ›¾ is a prime such that ğ‘ mod 4 = 3.
Input: For each ğ‘– âˆˆ [ğ‘›], ğ‘ƒğ‘– inputs its (ğ‘›, ğ‘¡)âˆ’ shares [ğ‘]ğ‘–.
Protocol:
(1) Pre-processing:
â€¢ For each ğ‘– âˆˆ [ğ‘›], ğ‘ƒğ‘– sets [ğ‘ â€²â€²]ğ‘– =ğœ…+ğ›¾âˆ’1
â€¢ For each ğ‘– = 1, Â· Â· Â· , ğœ… + ğ›¾, ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› use the RandBit()
sub-protocol (Figure 15) to get [ğ‘ğ‘–].
2ğ‘—âˆ’1 Â· [ğ‘ ğ‘—]ğ‘–
and [ğ‘ â€²]ğ‘– = [ğ‘ğœ…+ğ›¾]ğ‘–.
(2) For each ğ‘– âˆˆ [ğ‘›], ğ‘ƒğ‘– sets [ğ‘]ğ‘– = (2ğ›¾âˆ’1+[ğ‘]ğ‘–+2[ğ‘ â€²â€²]ğ‘–+[ğ‘ â€²]ğ‘–).
(3) ğ‘ â† Revealğ‘›,ğ‘¡ ([ğ‘]).
(4) ğ‘ƒ1 computes: ğ‘0 = ğ‘ mod 2 and sends to all parties.
(5) For each ğ‘– âˆˆ [ğ‘›], ğ‘ƒğ‘– sets [ğ‘‘]ğ‘– = ğ‘0 + [ğ‘ â€²]ğ‘– âˆ’ 2 Â· ğ‘0 Â· [ğ‘ â€²]ğ‘–.
Output: For each, ğ‘– âˆˆ [ğ‘›], ğ‘ƒğ‘– gets the output [ğ‘‘]ğ‘–.
ğ‘—=1
Figure 14: Mod2 PROTOCOL
We now describe the sub-protocol RandBit used in the pre-processing
step of the above protocol, which takes no input and outputs the
(ğ‘›, ğ‘¡)âˆ’ shares of a random bit ğ‘. The parameters of this sub-protocol
are as in the main Mod2 protocol of Figure 14.
Theorem E.4. The protocol given in Figure 14 securely realizes
F ğ‘,ğ‘›,ğ‘¡
Mod in the Fâˆ’ hybrid model, where F = (RandomFğ‘›,ğ‘¡ , MultFğ‘›,ğ‘¡ ,
Revealğ‘›,ğ‘¡ ), against a semi-honest adversary corrupting ğ‘¡ < ğ‘›/2 par-
ties.
Proof. Correctness. We begin by proving the correctness of
the RandBit sub-protocol, invoked in the first step. For this, it suf-
fices to show that ğ‘ âˆˆ {0, 1}. By the correctness of the functionali-
ties RandomFğ‘›,ğ‘¡ and MultFğ‘›,ğ‘¡ from [21], we know that ğ‘¢ = ğ‘Ÿ2. If
ğ‘¢ â‰  0, (ğ‘£ğ‘Ÿ + 1)2âˆ’1 mod ğ‘ = (ğ‘Ÿ (1âˆ’ğ‘)/2 + 1)2âˆ’1 mod ğ‘. We know
that for any prime order field element ğ‘Ÿ, ğ‘Ÿ (1âˆ’ğ‘)/2 = Â±1 mod ğ‘ and
hence ğ‘ âˆˆ {0, 1}. Now, the correctness of the Mod2 protocol follows
Input: No input taken.
Protocol:
(1) [ğ‘Ÿ] â† RandomFğ‘›,ğ‘¡ (1).
(2) Compute [ğ‘¢] â† MultFğ‘›,ğ‘¡ ([ğ‘Ÿ], [ğ‘Ÿ]).
(3) ğ‘¢ â† Revealğ‘›,ğ‘¡ ([ğ‘¢]). If ğ‘¢ = 0, discard ğ‘¢ and repeat step 1.
(4) For each ğ‘– âˆˆ [ğ‘›], ğ‘ƒğ‘– sets: ğ‘£ = ğ‘¢âˆ’(ğ‘+1)/4 mod ğ‘.
(5) For each ğ‘– âˆˆ [ğ‘›], ğ‘ƒğ‘– sets: [ğ‘]ğ‘– = (ğ‘£[ğ‘Ÿ]ğ‘– + 1)2âˆ’1 mod ğ‘.
Output: For each ğ‘– âˆˆ [ğ‘›], ğ‘ƒğ‘– gets the output [ğ‘]ğ‘–.
Figure 15: RandBit SUB-PROTOCOL
Else, ğ‘ƒ1 sends ğ‘¢ to all parties.
from the following observations: consider ğ‘ = 2ğ›¾âˆ’1 + ğ‘ + 2ğ‘ â€²â€² + ğ‘ â€²,
which implies that ğ‘0 = ğ‘ mod 2 = (ğ‘ + ğ‘ â€²) mod 2. Now, clearly,
ğ‘‘ = ğ‘0 + ğ‘ â€² âˆ’ 2ğ‘0ğ‘ â€² = ğ‘ mod 2 (recall that ğ‘ â€² is a single bit).
Security. Let ğ¶ âŠ‚ [ğ‘›] be the set of corrupted parties (|ğ¶| = ğ‘¡ < ğ‘›/2).
We show how to simulate the view of ğ¶ in the ideal world, given the
input shares {[ğ‘]ğ‘–}ğ‘–âˆˆğ¶ and the output shares {[ğ‘‘]}ğ‘–âˆˆğ¶ (for ğ‘‘ = ğ‘
mod 2). But note that the output is something the simulator can
set on its own (by the security of secret sharing). We consider two
cases based on party ğ‘ƒ1 being corrupt or not.
â€¢ Case 1 (ğ‘ƒ1 is honest): In the pre-processing step, to simulate
the view of the corrupted parties in the RandBit sub-protocol,
the simulator does the following: it picks the ğ‘¡ shares of ğ‘Ÿ as
shares of a random value. It picks a random ğ‘¢ and sends its ğ‘¡
shares to the corrupted parties. Further, it does local computa-
tions to get ğ‘£ and the ğ‘¡ shares of ğ‘. Then, the simulator does
local computations to get the ğ‘¡ shares of ğ‘ â€² and ğ‘ â€²â€². For step
2, the simulator does local computations to get the ğ‘¡ shares of
ğ‘. Finally, it picks ğ‘0 at random (this is because of the follow-
ing reason: for a random ğ‘Ÿ, ğ‘Ÿ (1âˆ’ğ‘)/2 = Â±1 mod ğ‘, with equal
probability and hence, ğ‘ is a random bit. Thus, ğ‘ â€² looks ran-
dom to the corrupted parties, by the security of secret sharing,
which implies that ğ‘0 = ğ‘ + ğ‘ â€² mod 2 looks random to the
corrupted parties) and sets the ğ‘¡ shares of [ğ‘‘] by doing the local
computation.
â€¢ Case 2 (ğ‘ƒ1 is corrupt): The simulation of the pre-processing
step and step 2 is exactly as in Case 1. The simulator picks both
ğ‘ and ğ‘0 at random (this is because of the following reason:
ğ‘ = 2ğ›¾âˆ’1 + ğ‘ + 2ğ‘Ÿâ€²â€² + ğ‘Ÿâ€² and ğ‘0 = ğ‘ mod 2. (2ğ‘ â€²â€² + ğ‘ â€²) mod ğ‘ is
a random field element (corresponding to a random integer of
length ğœ… + ğ›¾) and hence, ğ‘ looks random in the field Fğ‘, which
implies that ğ‘0 also looks random). Finally, the simulator does
the local computation to set the ğ‘¡ shares of [ğ‘‘].
â–¡
Complexity. The Mod2 protocol has an expected communica-
tion complexity of 19.3ğ‘›(âŒˆlog ğ‘âŒ‰)2 and an expected round complex-
ity of 10.
F CORRECTNESS, SECURITY AND
COMPLEXITY OF QUORUM PSI
F.1 Correctness and Security of Quorum PSI
We recall the Quorum PSI protocol from Section 5.1 in Figure 16.
We now give a complete proof of Theorem 5.1, by proving the
correctness and security of the protocol in Figure 16.
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1202Parameters: There are ğ‘› parties ğ‘ƒ1, . . . , ğ‘ƒğ‘› with private sets of size ğ‘š and 1 < ğ‘˜ â‰¤ ğ‘› âˆ’ 1 is quorum. Let ğ›½ = 1.28ğ‘š, ğœ = ğœ… + âŒˆlog ğ‘šâŒ‰ +
âŒˆlog ğ‘›âŒ‰ + 2. Additions and multiplications in the protocol are over Fğ‘, where ğ‘ is a prime (larger than ğ‘›) that depends on specific
instantiation of Fw-CMP
Input: Each party ğ‘ƒğ‘– has input set ğ‘‹ğ‘– = {ğ‘¥ğ‘–1, Â· Â· Â· , ğ‘¥ğ‘–ğ‘š}, where ğ‘¥ğ‘– ğ‘— âˆˆ {0, 1}ğœ. Note that element size can always be made ğœ bits by first
hashing the elements using an appropriate universal hash function.
Protocol:
(1) Hashing: Parties agree on hash functions â„1, â„2, â„3 : {0, 1}ğœ â†’ [ğ›½].
. Let ğ‘¡ < ğ‘›/2 denote the corruption threshold.
wPSM functionality: For each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} , ğ‘ƒ1 and ğ‘ƒğ‘– invoke the F ğ›½,ğœ,ğ‘
ğ‘ƒ1 does stash-less cuckoo hashing on ğ‘‹1 using â„1, â„2, â„3 to generate Table1 and inserts random elements into empty bins.
For ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘ƒğ‘– does simple hashing of ğ‘‹ğ‘– using â„1, â„2, â„3 into Tableğ‘–, i.e., stores each ğ‘¥ âˆˆ ğ‘‹ğ‘– at locations â„1(ğ‘¥), â„2(ğ‘¥) and
â„3(ğ‘¥). If the three locations are not distinct, random dummy values are inserted in bin with collision.
â€¢ ğ‘ƒğ‘– is the sender with inputs {Tableğ‘–[ ğ‘—]} ğ‘— âˆˆ[ğ›½] and ğ‘ƒ1 is the receiver with inputs {Table1[ ğ‘—]} ğ‘— âˆˆ[ğ›½].
â€¢ ğ‘ƒğ‘– receives the outputs {ğ‘¤ğ‘– ğ‘—} ğ‘— âˆˆ[ğ›½] and ğ‘ƒ1 receives {ğ‘¦ğ‘– ğ‘—} ğ‘— âˆˆ[ğ›½].
ğ‘ƒ1 and ğ‘ƒğ‘– send their inputs ğ‘¦ğ‘– ğ‘— and ğ‘¤ğ‘– ğ‘—, resp., and receive boolean shares âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ
EQ functionality: For each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} and for each ğ‘— âˆˆ [ğ›½], ğ‘ƒ1 and ğ‘ƒğ‘– invoke the F ğœ
B2A functionality: For each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} and for each ğ‘— âˆˆ [ğ›½], ğ‘ƒ1 and ğ‘ƒğ‘– invoke the F Fğ‘
functionality for ğ‘ = 3ğ‘š as follows:
ğ‘– resp., as outputs.
functionality as follows:
functionality as follows:
1 and âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ
wPSM
(2) Invoking the F ğ›½,ğœ,ğ‘
(3) Invoking the F ğœ
EQ
ğ‘– , resp., and receive the additive shares âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1 and âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘– resp., as outputs.
B2A
ğ‘ƒ1 and ğ‘ƒğ‘– send their inputs âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ
â€¢ ğ‘ƒ1 computes âŸ¨ğ‘ ğ‘—âŸ©1 =ğ‘›
(4) Invoking the F Fğ‘
(5) Invoking n-party functionalities: For each ğ‘— âˆˆ [ğ›½],
â€¢ ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› compute [ğ‘ ğ‘—] â† ConvertSharesğ‘›,ğ‘¡ (âŸ¨ğ‘ ğ‘—âŸ©).
â€¢ Parties invoke F ğ‘,ğ‘˜,ğ‘›,ğ‘¡
w-CMP
(6) Output: ğ‘ƒ1 computes the quorum intersection as ğ‘Œ =
1 and âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ

ğ‘–=2âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1 and for each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘ƒğ‘– sets âŸ¨ğ‘ ğ‘—âŸ©ğ‘– = âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘–.
with ğ‘ƒğ‘–â€™s input being [ğ‘ ğ‘—]ğ‘– for ğ‘– âˆˆ [ğ‘›] and ğ‘ƒ1 learns ğ‘ ğ‘— as output.
Table1[ ğ‘—].
ğ‘— âˆˆ[ğ›½]:ğ‘ ğ‘— =1
Figure 16: QUORUM PSI PROTOCOL
Correctness. For ğ‘¥ âˆˆ ğ‘‹1, define ğ‘ğ‘¥ = |{ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} : ğ‘¥ âˆˆ ğ‘‹ğ‘–}|.
Let ğ‘Œâˆ— = {ğ‘¥ âˆˆ ğ‘‹1 : ğ‘ğ‘¥ â‰¥ ğ‘˜} and the output of the protocol is de-
noted by ğ‘Œ. We now show that ğ‘Œ = ğ‘Œâˆ—, with all but negligible in
ğœ… probability. For the rest of the proof we assume that the cuckoo
hashing by ğ‘ƒ1 succeeds (i.e., all elements of ğ‘‹1 get inserted success-
fully in Table1), which happens with probability at least 1 âˆ’ 2âˆ’42
(see Section 2.2). Now, the following two lemmata complete the
proof of correctness.
Lemma F.1. ğ‘Œâˆ— âŠ† ğ‘Œ .
Proof. Let ğ‘’ = Table1[ ğ‘—] âˆˆ ğ‘Œâˆ— and E = {ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›} :
ğ‘’ âˆˆ ğ‘‹ğ‘–}. By the property of simple hashing, ğ‘’ âˆˆ Tableğ‘–[ ğ‘—] for all
ğ‘– âˆˆ E. By correctness of F ğ›½,ğœ,ğ‘
, we have ğ‘¦ğ‘– ğ‘— = ğ‘¤ğ‘– ğ‘—,
wPSM
ğ‘’ğ‘ğ‘– ğ‘— = 1 and ğ‘“ğ‘– ğ‘— = 1 respectively, for all ğ‘– âˆˆ E. For ğ‘– âˆ‰ E, since F ğœ
EQ
gives a boolean output, ğ‘’ğ‘ğ‘– ğ‘— âˆˆ {0, 1}, and by correctness of F Fğ‘
,
B2A
we have ğ‘“ğ‘– ğ‘— âˆˆ {0, 1}. By correctness of ConvertSharesğ‘›,ğ‘¡, we know
that [ğ‘ ğ‘—] corresponds to ğ‘ ğ‘— =ğ‘–âˆˆ{2,Â·Â·Â· ,ğ‘›} ğ‘“ğ‘– ğ‘— < ğ‘› < ğ‘. Since ğ‘’ âˆˆ ğ‘Œâˆ—,
we will get
â–¡
we get ğ‘ ğ‘— â‰¥ |E| â‰¥ ğ‘˜. Finally, by correctness of F ğ‘,ğ‘˜,ğ‘›,ğ‘¡
w-CMP
ğ‘ ğ‘— = 1 when invoked on shares of ğ‘ ğ‘— â‰¥ ğ‘˜. Therefore, ğ‘’ âˆˆ ğ‘Œ.
Lemma F.2. ğ‘Œ âŠ† ğ‘Œâˆ—, with probability at least 1 âˆ’ 2âˆ’ğœ…âˆ’1.
Proof. Suppose ğ‘Œ âŠˆ ğ‘Œâˆ—. Let ğ‘’ = Table1[ ğ‘—] âˆˆ ğ‘Œ\ğ‘Œâˆ—. First,