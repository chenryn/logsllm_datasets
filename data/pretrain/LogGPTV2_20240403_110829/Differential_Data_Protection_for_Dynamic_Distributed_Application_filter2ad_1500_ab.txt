### Channel Security and Stability

Channels can be targeted by attacks aimed at compromising the stability of applications. In practical terms, a handler containing an infinite loop, when installed on a channel, can effectively deny service to all clients using that channel.

### Security Policy Statements

The security policy statements suggested by Mr. X’s potential actions are straightforward:
- "Only authorized users are allowed to consume data."
- "No end user can install modifications on a channel."
- "Only modifications C and D are allowed on this channel."

Decoupling such policy statements from the application code is clearly preferable.

### Flexible Mechanism for Security Policy Implementation

A flexible mechanism for implementing security policies is necessary. For example, publish/subscribe systems have gained attention due to the anonymity they provide to users—a publisher generally has no knowledge of the number or identity of subscribers. However, systems like AVS need the ability to differentiate between degrees and types of access. Meaningful security policies for AVS must identify at least classes of subscribers. The dynamic nature of the application, where rapidly changing execution conditions (e.g., location of a mobile sensor, time of day) may dictate immediate security policy changes, complicates matters. A desirable mechanism should be able to implement general policy constraints (e.g., "User A lacks privilege to install the greyscale filter") without requiring these constraints to be expressed in the application code. This mechanism also provides dynamic data protection as application policies change.

### Object Descriptor
- **Object ID and Type ID**
- **Rights**
  - **General Credential Rights**
  - **Object-Specific Rights**

### 3. A Model for Differential Data Protection

#### Client Descriptor
- **Authenticated Client/Role Name or ID**

In this section, we present a model for a protection mechanism that allows us to provide application-specific protection actions on structured data. These protection actions can be differentiated based on the structure of the data or other application considerations.

#### 3.1 Foundations

We assume a system in which peered hosts exchange information using a publish/subscribe metaphor. Event channels transport information between hosts, and the information flow can be stream- or packet-based, depending on application requirements. Events are discrete packets of information, and a decentralized system of data types is applied to these packets. Hosts that do not recognize a particular type identifier can retrieve the definitions and any conversion information associated with that type either from a known location or from the sender. This allows us to assume a "global" type space without necessarily centralizing all type information.

We choose the event-based data exchange paradigm because of its importance to the class of applications targeted by this research. Event-based communications are widely used in operational information systems, such as those used by Delta Air Lines [26], large-scale information distribution systems like stock update notifications [35], and online collaborations in distributed engineering and science endeavors [28]. They are also useful for the distributed sensor applications used as an example in this paper [2, 37].

#### 3.2 Structure of Credentials

A credential can be viewed as an abstract data type containing information needed and/or generated by the protection mechanism (Figure 3 illustrates this). A credential contains an object descriptor (OD), which uniquely identifies the object to which the information in the credential applies. This descriptor might be made concrete in an implementation as an object unique identifier or, since we propose a system of types, as a combination of an instance UID with a type UID.

The other half of the classical capability format is a collection of rights. Rights govern operations that are possible for the object identified by the OD or on the credential itself. Certain special rights, such as the ability to transfer ownership of a credential, are indicated in the credential. Ownership of credentials implies a mapping between credentials and owners, represented by a client descriptor (CD) in the credential. The CD contains an authenticated (signed by a trusted entity) specific and unique client name. The entity named by the CD can take several forms: it may represent a real-world person in a security policy matrix, a security role for role-based access control, or a trust-level designation used by authenticating entities to propagate trust or reputation characteristics.

Credentials contain a signed hash of their contents to guard against forgery. The signature can come from a trusted third party or from an arbitrary host in the system. If an arbitrary host signs the credential, the trust designation helps in making decisions about the reliability of the contents.

The different object types to which credentials can refer include event channels themselves, source (submission) and sink (reception) handles to those channels, code segments (or references to them) used to extend or modify the behavior of event channels, and types and the conversions used to encode and decode data to and from transport format.

We are aware of the heavy reliance on cryptographic methods necessary to ensure the integrity of credentials. While highly-secure cryptography is expensive, our design minimizes the associated performance impact by keeping cryptographic operations out of the "critical path" of information exchange as much as possible. For example, our mechanism makes it unnecessary to verify the integrity of a credential on every event submission or reception. Where cryptographic operations are necessary, we offer unique approaches designed to minimize their cost.

#### 3.3 Routing

The publish/subscribe metaphor is anonymous, as event producers or sources do not necessarily know the identity, location, or number of event consumers. Overlays allow interested clients to route data streams to themselves by encapsulating the notion of subscription. Under the overlay mechanism, only authorized clients are permitted to subscribe to a channel. Credentials indicate this situation—an authorized client possesses a credential naming a particular channel in its object descriptor and the client in its client descriptor, and which has the route right indicated.

#### 3.4 Handlers

Previous research [8] has demonstrated the effectiveness of associating code with event channels. This code can perform actions on the events passing through the channel or on the channel itself. Through this activity, event transmission can be efficiently customized for heterogeneous endpoints, dynamically varying network conditions, or application-specific purposes.

We call such code associated with an event channel a handler. In this position, the handler can inspect each event passing through the channel. Since the events have specific types, the handler can perform a detailed, application-aware examination of the event, allowing it to perform actions based on the content of the event.

The event channel abstraction is designed to support anonymous subscription and data transfer. A motivating example for the development of AVS is the multiplexing of different levels of service across a single event submission from a source. This reduces complexity at event sources while preserving the anonymous nature of publish/subscribe systems, as sources need not know which sinks are entitled to which level of service. Flexibility in locating sources is also important, as low-power and -bandwidth constraints dictate that network transmission activity be kept to a minimum.

A typical AVS source is a webcam producing 640x480 color images. In this context, service level equates to stream quality—size, color depth, and frame rate are all axes along which AVS can differentiate service level. An obvious example where differentiation is desirable is an AVS instance where subscribers receive a basic level of service and must pay for higher service levels (or potentially special functionality). Other scenarios are equally valid, such as an instance where certain users are not allowed to view particular regions of the transmitted images.

A transformation is an overlay operation that allows applications like AVS to accomplish such tasks. Recall that the events exchanged by AVS are typed, with well-defined structure. Transforming handlers take events of one type and convert them to events of another type. For example, a transforming handler can scale a 640x480 image down to half the original size for clients who desire or are only entitled to such images. Other image transformations implemented in AVS include greyscale conversion, image mirroring, and advanced transformations such as edge detection.

At the data structure level, a transforming handler receives a data structure as input, performs some computation on the contained data, and produces a structure of a different type as output. In the greyscale conversion case, a 640x480x3 (for RGB color) image is converted to a 640x480x1 image, reducing the quantity of data output by the handler to one-third of the data it receives (Figure 4).

The overlay mechanism enforces the "assignment" of sink subscriptions to channels with appropriate transformation handlers. Since credentials contain unforgeable references to channels (among other object types), a subscription requiring a particular credential implicitly restricts access to the image stream on that channel.

The transformation operation implies several rights-based operations. With a quasi-global type system, we can make statements about whether a principal (really an entity identified by a client descriptor in a credential) can transform data to or from a type. Since channels are objects, we can also talk about whether a handler can be installed on the channel that performs transformations on the type of event being carried by the channel. A credential indicates these rights in its type-specific rights field.

#### 3.5 Other Infrastructure

The overlay mechanism relies on several other pieces of infrastructure:

- **Security Manager (SecMgr):** Overlays require a trusted third party for several reasons, most importantly to issue credentials and vouch for their integrity. How such credentials are obtained is an open problem; we refer to an outside agency called the Security Manager (SecMgr), which is the single point of contact for obtaining and revoking credentials. SecMgrs may choose to implement different security policies; credentials may be granted or denied based on challenge/response mechanisms like the UNIX login process. It is the job of SecMgr to determine whether or not credentials are granted and for what period(s) of time they are valid. The overlay mechanism, given properly obtained credentials, ensures that no access except that specified by those credentials is allowed. This separation of policy and mechanism is similar to systems such as Hydra.

- **Directory Service:** Client descriptors in credentials use globally unique names, implying a global namespace and the need for a tool to coordinate access to the namespace. We rely on a directory service for this task. Applications can query the directory service to find information on objects or principals in the system.

- **Code Repository:** To install a particular handler, the location of an appropriate repository is retrieved from the directory service. This location is provided to applications in the form of a credential, with the object descriptor naming the repository and the client descriptor naming the application. The repository validates this credential and (with the cooperation and assistance of SecMgr) replaces the credential with one naming a specific piece of code.

### 4. Applying the Model to AVS

We now describe how some of the concepts expressed in the overlay model have been realized in the AVS application. These concepts allow us to provide differential data protection to the AVS application, enabling it to conform to various security policies without embedding those policies in application code. We also present empirical results supporting our claims that the mechanism provides high-performance communication rates and the ability to perform differential data protection.

#### 4.1 Supporting Application-Specific Security Policies

A design goal of the overlay model is to support application-specific security policies without requiring application modification. We modified the AVS application to use a partial implementation of the overlay model. These modifications can be broken down into three parts:

- **Use of Application Policy Descriptions:** Our system uses XML [1] descriptions of security policies, with associated XML schemas to aid in policy definitions. These descriptions can be produced by graphical applications provided to end users, by automatic inspection of user databases and existing access control matrices, or by a local SecMgr instance in response to changing application or environmental conditions. XML provides a common, well-defined interchange format. We use HTTPS requests to retrieve them from standard web servers, providing both integrity of the policy descriptions and indirection to allow flexibility in policy deployment.

- **Implementing a Repository of Handlers Managed by Secure Infrastructure Components:** This involves setting up a secure repository for handlers and managing it with the help of secure infrastructure components.

- **Code Changes to the AVS Application to Use Overlay Credentials Instead of Direct References to the Underlying Middleware System:** This ensures that the AVS application uses overlay credentials for accessing and managing resources, rather than direct references to the middleware system.

#### 4.1.1 Application Policy Descriptions

For the AVS application, there are three types of policies:
- **Policies Applied to the Image Regardless of Filters:** Statements such as "the lower half of the image stream from camera A should be blurred" or "the lower half of all image streams viewed by user X should be blurred."
- **Access Control Policies for Streams:** Statements such as "user X cannot access camera Y under condition Z."
- **Policies Governing Access to Filters for a Particular Stream:** Statements such as "user X cannot install filter Y."

Policy files for an application are provided to the SecMgr (via Uniform Resource Locator (URL)) when requests for credentials are made. The SecMgr, as described earlier, is responsible for issuing and revoking credentials based on the provided policy descriptions.