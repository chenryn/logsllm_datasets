channel, including those designed to attack the stability of
the application. In practical terms, a handler containing an
inﬁnite loop that is installed on a channel would effectively
deny service to all clients of the channel.
The security policy statements suggested by Mr. X’s po-
tential actions are straightforward: “Only authorized users
are allowed to consume data”; “No end user can install
modiﬁcations on a channel”; “Only modiﬁcations C and D
are allowed on this channel”. Decoupling such policy state-
ments from application code is also clearly preferable.
A ﬂexible mechanism to implement security policy is
also necessary. For example, publish/subscribe systems
have attracted a great deal of attention due to the anonymity
they afford their users - a publisher generally has no
knowledge of the number or identity of subscribers. Pub-
lish/subscribe systems like AVS, however, clearly need the
ability to differentiate between degrees and types of access.
Meaningful security policy for AVS necessarily identiﬁes
at least classes of subscribers. Complicating matters is the
dynamic nature of the application, where rapidly changing
execution conditions (location of a mobile sensor, or time
of day, for example) may dictate immediate security policy
changes. A desirable mechanism should be able to imple-
ment general policy constraints (“User A lacks privilege to
4
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:41:19 UTC from IEEE Xplore.  Restrictions apply. 
install the greyscale ﬁlter”) without requiring the expres-
sion of those constraints in the application code. Also, such
a mechanism is able to provide dynamic data protection as
application policies change.
Object Descriptor
... object ID and type ID
Rights
... general credential rights
Object−specific rights
...rights specific to the object type
3 A model for differential data protection
Client Descriptor
..authenticated client/role name or ID
In this section, we present a model for a protection mech-
anism that allows us to provide application-speciﬁc protec-
tion actions on structured data. These protection actions can
be differentiated based on the structure of the data or other
application considerations.
3.1 Foundations
We assume a system in which peered hosts exchange in-
formation using a publish/subscribe metaphor. In this sys-
tem, event channels serve to transport information from host
to host. The information ﬂows between hosts can be stream-
or packet- based, depending on application requirements.
Events are discrete packets of information. A decentralized
system of data types is applied to these packets. Hosts that
do not recognize a particular type identiﬁer can retrieve the
deﬁnitions and any conversion information associated with
that type either from a known location or from the sender.
This allows us to assume a “global” type space without nec-
essarily centralizing all type information.
We choose the event-based data exchange paradigm be-
cause of its importance to the class of applications targeted
by this research. Event-based communications are widely
used in the operational information systems used by com-
panies like Delta Air Lines[26]. They are also the basis
for large-scale information distribution systems like stock
update notiﬁcation[35]. Finally, they have been shown use-
ful as a middleware basis for online collaborations in dis-
tributed engineering and science endeavors[28], and for the
distributed sensor applications used as an example in this
paper[2, 37].
3.2 Structure of credentials
A credential may be viewed as an abstract data type con-
taining information needed and/or generated by the protec-
tion mechanism (Figure3 illustrates this). A credential con-
tains an object descriptor (OD), which uniquely identiﬁes
the object to which the information in the credential applies.
This descriptor might be made concrete in an implementa-
tion as an object unique identiﬁer, or, since we propose a
system of types, as a combination of a instance UID with a
type UID.
The other half of the classical capability format is a col-
lection of rights. Rights govern operations that are possible
for the object identiﬁed by the OD or on the credential itself.
Update Channel
...event sink for revocations or other updates
Payload
...type−specific information
Crypto
... cryptographic protection against forgery or replay
Figure 3. Credential structure detail.
Certain other special rights are indicated in the credential,
like the ability to transfer ownership of a credential.
Ownership of credentials implies a mapping between
credentials and owners. This mapping is represented by
a client descriptor (CD) in the credential. The CD con-
tains an authenticated (signed by a trusted entity) speciﬁc
and unique client name. The entity named by the CD may
take several forms. It may be a principal in a security pol-
icy matrix that represents a real-world person. It could also
be the name of a security role, allowing role-based access
control. Finally, the CD contains a trust-level designation,
which may be used by authenticating entities to propagate
trust or reputation characteristics.
Credentials contain a signed hash of their contents to
guard against forgery. The signature can come from a
trusted third party (one such party is described later) or from
an arbitrary host in the system. In a case where an arbitrary
host has signed the credential, the trust designation can be
used to help make decisions about how reliable the contents
may be.
The different object types to which credentials can re-
fer are event channels themselves, source (submission) and
sink (reception) handles to those channels, code segments
(or references to them) used to extend or modify the behav-
ior of event channels, and types and the conversions used to
encode and decode data to and from transport format.
We are aware of the heavy reliance on cryptographic
methods necessary to ensure the integrity of credentials.
While highly-secure cryptography is expensive, our design
minimizes the associated performance impact in two ways.
We strive to keep cryptographic operations out of the “criti-
cal path” of information exchange as much as possible. For
example, our mechanism makes it unnecessary to verify the
integrity of a credential on every event submission or re-
5
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:41:19 UTC from IEEE Xplore.  Restrictions apply. 
ception. Where cryptographic operations are necessary, we
offer unique approaches designed to minimize their cost.
3.3 Routing
The publish/subscribe metaphor is anonymous in that
event producers or sources do not necessarily know the
identity, location, or number of event consumers. Over-
lays allow interested clients to route data streams to them-
selves by encapsulating the notion of subscription. Under
the overlay mechanism, only authorized clients are permit-
ted to subscribe to a channel. Credentials are used to in-
dicate this situation - an authorized client is one that pos-
sesses a credential naming a particular channel in its object
descriptor and the client in its client descriptor, and which
has the route right indicated.
3.4 Handlers
Previous research [8] has demonstrated the effectiveness
of associating code with event channels. This code can per-
form actions on the events passing through the channel or on
the channel itself. Through this activity, event transmission
can be efﬁciently customized for heterogeneous endpoints,
dynamically varying network conditions, or application-
speciﬁc purposes.
We call such code associated with an event channel a
handler. In this position the handler can inspect each event
passing through the channel. Since the events have speciﬁc
types, the handler can perform a detailed, application-aware
examination of the event. This allows the handler to per-
form actions based on the content of the event.
The event channel abstraction is designed to support
anonymous subscription and data transfer. A motivating
example for the development of AVS is the multiplexing
of different levels of service across a single event submis-
sion from a source. The ability to do this reduces com-
plexity at event sources. The anonymous nature of pub-
lish/subscribe systems is also preserved, as sources need not
know which sinks are entitled which level of service. Flex-
ibility in locating sources is also important, as low-power
and -bandwidth constraints dictate that network transmis-
sion activity be kept to a minimum.
A typical AVS source is a webcam producing 640x480
color images. In this context, service level equates to stream
quality - size, color depth, and frame rate are all axes along
which AVS can differentiate service level. An obvious ex-
ample where differentiation is desirable is an AVS instance
where subscribers receive a basic level of service and must
pay for higher service levels (or potentially special function-
ality). Other scenarios are equally valid, however - consider
an instance where certain users are not allowed to view par-
ticular regions of the transmitted images.
A transformation is an overlay operation that allows ap-
plications like AVS to accomplish such tasks. Recall that
the events exchanged by AVS are typed, with well-deﬁned
structure. Transforming handlers take events of one type
and convert them to events of another type. A transforming
handler, for example, can scale a 640x480 image down to
half the original size for clients who desire or are only en-
titled to such images. Other image transformations imple-
mented in AVS include greyscale conversion, image mirror-
ing, and advanced transformations such as edge detection.
At the data structure level, a transforming handler re-
ceives a data structure as input, performs some compu-
tation on the contained data, and produces a structure of
a different type as output.
In the greyscale conversion
case, a 640x480x3 (for RGB color) image is converted to
a 640x480x1 image. The practical consequence of this is
that the quantity of data output by the handler is one-third
of the data the handler receives. Figure 4 illustrates this.
The overlay mechanism enforces the “assignment” of
sink subscriptions to channels with appropriate transforma-
tion handlers (appropriate being an application-deﬁned term
here). Since credentials contain unforgeable references to
channels (among other object types), a subscription requir-
ing a particular credential implicitly restricts access to the
image stream on that channel.
The transformation operation implies several rights-
based operations. Since we have a quasi-global type sys-
tem, we can make statements about whether a principal (re-
ally an entity identiﬁed by a client descriptor in a credential)
can transform data to or from a type. Since channels are ob-
jects, we can also now talk about whether a handler can be
installed on the channel that performs transformations on
type of event being carried by the channel. A credential
indicates these rights in its type-speciﬁc rights ﬁeld.
3.5 Other infrastructure
The overlay mechanism relies on several other pieces of
infrastructure; we brieﬂy describe these here.
Security manager. Overlays require a trusted third party
for several reasons. Most important is to issue cre-
dentials and vouch for their integrity. How such cre-
dentials are obtained is an open problem; we will re-
fer to an outside agency called the Security Manager
(SecMgr) which is the single point of contact for ob-
taining and revocation of credentials (as stated be-
fore, credentials are cryptographically secured against
forgery). SecMgr’s may choose to implement differ-
ent security policies; credentials may be granted or
denied based on challenge/response mechanisms like
the UNIX login process, for example.
It is the job
of SecMgr to determine whether or not credentials are
granted and for what period(s) of time they are valid;
6
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:41:19 UTC from IEEE Xplore.  Restrictions apply. 
event
type A
transforming
handler
event
type B
{
int x;
char y;
int data[921600];
}
{
int x;
char y;
int data[307200];
}
Figure 4. Transforming handlers take one type of data as input and produce a different type as output.
In this example, the handler converts the image data in the data array of the input type to greyscale
from color, reducing its size by a factor of 3.
it is the job of the overlay mechanism, given properly
obtained credentials, to ensure that no access except
that speciﬁed by those credentials is allowed. This is
the essence of the separation of policy and mechanism
seen in systems such as Hydra that we apply to our
own work.
Directory service. Client descriptors in credentials use
globally unique names. This implies a global names-
pace and further that there needs to be some tool to
coordinate access to the namespace. We rely on a di-
rectory service for this task. Applications can query
the directory service to ﬁnd information on objects or
principals in the system.
Code repository. To install a particular handler, the loca-
tion of an appropriate repository is retrieved from the
directory service. This location is provided to appli-
cations in the form of a credential, with the object de-
scriptor naming the repository and the client descrip-
tor naming the application. The repository validates
this credential and (with the cooperation and assistance
of SecMgr) replaces the credential with one naming a
speciﬁc piece of code.
4 Applying the model to AVS
We now describe how some of the concepts expressed in
the overlay model have been realized in the AVS applica-
tion. These concepts allow us to provide differential data
protection to the AVS application.
In turn, this differen-
tial protection allows the application to conform to various
security policies without embedding those policies in appli-
cation code. We also present empirical results that support
our claims that the mechanism provides high-performance
communication rates as well as the ability to perform dif-
ferential data protection.
4.1 Supporting application-speciﬁc security pol-
icy
As stated earlier, a design goal of the overlay model
is to support application-speciﬁc security policies without
requiring application modiﬁcation. We modiﬁed the AVS
application to use a partial implementation of the overlay
model. These modiﬁcations can be broken down into three
parts: use of application policy descriptions, implementing
a repository of handlers managed by secure infrastructure
components, and code changes to the AVS application to
use overlay credentials instead of direct references to the
underlying middleware system.
4.1.1 Application policy descriptions
Our system uses XML [1] descriptions of security policies,
with associated XML schemas to aid in policy deﬁnitions.
We envision these descriptions being produced in several
different ways: by graphical applications provided to end
users, by automatic inspection of user databases and exist-
ing access control matrices, or by a local SecMgr instance
in response to changing application or environmental condi-
tions. XML provides a common, well-deﬁned interchange
format. We use HTTPS requests to retrieve them from stan-
dard web servers, providing both integrity of the policy de-
scriptions and indirection to allow ﬂexibility in policy de-
ployment.
Note that since we are primarily interested in deﬁning
a mechanism capable of implementing a wide range of se-
curity policies, we are not concerned with issues such as
reconciling conﬂicting policy statements, cached access to
policy statements, or implementation of a general constraint
engine. These issues are being addressed by others [11] and
we rely on the interchange capabilities of our XML inter-
face to provide interoperability.
For the AVS application, there are three types of policies:
7
Proceedings of the 19th Annual Computer Security Applications Conference (ACSAC 2003) 
1063-9527/03 $17.00 © 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:41:19 UTC from IEEE Xplore.  Restrictions apply. 
those applied to the image regardless of what ﬁlter(s) might
be installed, those governing access to image streams, and
those governing access to ﬁlters for a particular stream. The
ﬁrst type of policy includes statements such as “the lower
half of the image stream from camera A should be blurred”
or “the lower half of all image streams viewed by user X
should be blurred”. Access control policies for streams in-
corporate statements of the type “user X cannot access cam-
era Y under condition Z”. The ﬁnal type of policy statement
includes statements such as “user X cannot install ﬁlter Y”.
Policy ﬁles for an application are provided to the SecMgr
(via Uniform Resource Locator (URL)) when requests for
credentials are made. The SecMgr, as described earlier, is