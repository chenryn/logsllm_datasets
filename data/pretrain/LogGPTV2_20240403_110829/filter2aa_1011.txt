Trustedsec ELFLoader 原理简析
0x01 简介
各类的 elfloader 一般都是内存解析或读取 elf 文件而后执行。其中有简单的例如之前讲到的
Linux 无文件攻击姿势，但是缺点也很明显例如 proc 特征、无法保护 load 的文件。今天分析
一个另一种类型的 eldloader，简要分析一下是如何实现的。项目为 trustedsec 出品
（https://github.com/trustedsec/ELFLoader）。
0x02 Loader 技术细节
查看项目结构。
主要功能实现逻辑都在 ELFLoader.c 中，为了能跨平台运行可以看到做了一些适配性工作，
将大部分类如输出打印、字符处理等函数都放入了 beacon_compatibility.c 文件中。
值得一提的是或许为了 opsec 考虑，它将传参通过编码后传给 elfloader。编码方式位于
beacon_generate.py 脚本中，操作为对字符串先进行二进制格式打包后进行 hex 编码。
参数传入 elfloader 后，main 函数中读取 elf 文件，并由 unhexlify()函数 decode 传入参数，完
成后将 elf 文件及参数传入 ELFRunner()进行解析 elf 文件。
进入函数后首先定义了一个结构体如上，也是这个函数将要完成的主要功能，即解析 elf 后
将对应节区存入对应结构体。
而后判断传入的文件格式是否为 elf 格式，是否为可重定位文件及系统位数。之后即为两个
for 函数遍历节头表完成 elf 文件解析。
如上，在遍历过程中通过识别节区是否是存放符号表的节区，而后进入循环寻找指定函数入
口点，寻找方法是对比符号名，找到后将地址赋给指针函数 PTR。
最后，通过指针直接调用。
0x03 bof 插件细节
如上格式，其他的 bof 文件也相同，均以 go 函数作为入口，为了方便调试可以看到下面还
有条件编译预留的 main 入口。这里也可以不使用 go 作为入口，修改下源码也可以指定其他
函数进行指针调用。
0x04 集成方式
朋友提交了 issue，工具很快就支持共享库(.so)了，可方便的集成到自己的工具或马中。
0x05 最后
从功能角度看，该工具完成了 bof 思路在 linux 下的简单实现，可有效绕过 hids 的 execve 监
控，实现常见命令 bof 化。
但该方式在 linux 平台来说还不是很优雅，从使用角度看如果将这个 loader 改为远程加载，
流量方面又没有了优势，因为 bof 化本身大家都不想让文件落地而是在内存中执行，那么每
次执行命令都不落地远程加载的话流量会太明显。
如果从 execve 监控绕过方面看，有其他方式更为简便如 busybox shell 或其他类型的 elfloader
来实现。
最后，实现一个好用的 linux 马越来越重要，入口点的 shell 如果因为 hids 不小心掉了，还是
很伤心的，博取各种思路所长或改造或重写是更加好的选择。