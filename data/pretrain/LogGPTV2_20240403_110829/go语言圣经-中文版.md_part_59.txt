// func (time.Duration) Nanoseconds() int64
// func (time.Duration) Seconds() float64
// func (time.Duration) String() string
methods.Print(new(strings.Replacer))
// Output:
// type *strings.Replacer
// func (*strings.Replacer) Replace(string) string
// func (*strings.Replacer) WriteString(io.Writer, string) (int, error)
`
显示一个类型的方法集 454
gopl
显示一个类型的方法集 455
gopl
12.9. 几点忠告
虽然反射提供的API远多于我们讲到的，我们前面的例子主要是给出了一个方向，通过反射可
以实现哪些功能。反射是一个强大并富有表达力的工具，但是它应该被小心地使用，原因有
三。
第一个原因是，基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问
题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反
射则是在真正运行到的时候才会抛出panic异常，可能是写完代码很久之后了，而且程序也可
能运行了很长的时间。
以前面的readList函数（§12.6）为例，为了从输入读取字符串并填充int类型的变量而调用的
reflect.Value.SetString方法可能导致panic异常。绝大多数使用反射的程序都有类似的风险，
需要非常小心地检查每个reflect.Value的对于值的类型、是否可取地址，还有是否可以被修改
等。
避免这种因反射而导致的脆弱性的问题的最好方法是将所有的反射相关的使用控制在包的内
部，如果可能的话避免在包的API中直接暴露reflect.Value类型，这样可以限制一些非法输
入。如果无法做到这一点，在每个有风险的操作前指向额外的类型检查。以标准库中的代码
为例，当fmt.Printf收到一个非法的操作数是，它并不会抛出panic异常，而是打印相关的错误
信息。程序虽然还有BUG，但是会更加容易诊断。
fmt.Printf("%d %s\n", "hello", 42) // "%!d(string=hello) %!s(int=42)"
反射同样降低了程序的安全性，还影响了自动化重构和分析工具的准确性，因为它们无法识
别运行时才能确认的类型信息。
避免使用反射的第二个原因是，即使对应类型提供了相同文档，但是反射的操作不能做静态
类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其
它接受interface{}或reflect.Value类型参数的函数维护说明文档。
第三个原因，基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型
的项目，大部分函数的性能和程序的整体性能关系不大，所以使用反射可能会使程序更加清
晰。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关
键路径的函数，最好避免使用反射。
几点忠告 456
gopl
第十三章 底层编程
Go语言的设计包含了诸多安全策略，限制了可能导致程序运行出错的用法。编译时类型检查
可以发现大多数类型不匹配的操作，例如两个字符串做减法的错误。字符串、map、slice和
chan等所有的内置类型，都有严格的类型转换规则。
对于无法静态检测到的错误，例如数组访问越界或使用空指针，运行时动态检测可以保证程
序在遇到问题的时候立即终止并打印相关的错误信息。自动内存管理（垃圾内存自动回收）
可以消除大部分野指针和内存泄漏相关的问题。
Go语言的实现刻意隐藏了很多底层细节。我们无法知道一个结构体真实的内存布局，也无法
获取一个运行时函数对应的机器码，也无法知道当前的goroutine是运行在哪个操作系统线程
之上。事实上，Go语言的调度器会自己决定是否需要将某个goroutine从一个操作系统线程转
移到另一个操作系统线程。一个指向变量的指针也并没有展示变量真实的地址。因为垃圾回
收器可能会根据需要移动变量的内存位置，当然变量对应的地址也会被自动更新。
总的来说，Go语言的这些特性使得Go程序相比较低级的C语言来说更容易预测和理解，程序
也不容易崩溃。通过隐藏底层的实现细节，也使得Go语言编写的程序具有高度的可移植性，
因为语言的语义在很大程度上是独立于任何编译器实现、操作系统和CPU系统结构的（当然
也不是完全绝对独立：例如int等类型就依赖于CPU机器字的大小，某些表达式求值的具体顺
序，还有编译器实现的一些额外的限制等）。
有时候我们可能会放弃使用部分语言特性而优先选择具有更好性能的方法，例如需要与其他
语言编写的库进行互操作，或者用纯Go语言无法实现的某些函数。
在本章，我们将展示如何使用unsafe包来摆脱Go语言规则带来的限制，讲述如何创建C语言
函数库的绑定，以及如何进行系统调用。
本章提供的方法不应该轻易使用（译注：属于黑魔法，虽然功能很强大，但是也容易误伤到
自己）。如果没有处理好细节，它们可能导致各种不可预测的并且隐晦的错误，甚至连有经
验的C语言程序员也无法理解这些错误。使用unsafe包的同时也放弃了Go语言保证与未来版
本的兼容性的承诺，因为它必然会有意无意中使用很多非公开的实现细节，而这些实现的细
节在未来的Go语言中很可能会被改变。
要注意的是，unsafe包是一个采用特殊方式实现的包。虽然它可以和普通包一样的导入和使
用，但它实际上是由编译器实现的。它提供了一些访问语言内部特性的方法，特别是内存布
局相关的细节。将这些特性封装到一个独立的包中，是为在极少数情况下需要使用的时候，
同时引起人们的注意（译注：因为看包的名字就知道使用unsafe包是不安全的）。此外，有
一些环境因为安全的因素可能限制这个包的使用。
不过unsafe包被广泛地用于比较低级的包, 例如runtime、os、syscall还有net包等，因为它们
需要和操作系统密切配合，但是对于普通的程序一般是不需要使用unsafe包的。
底层编程 457
gopl
底层编程 458
gopl
13.1. unsafe.Sizeof, Alignof 和 Offsetof
unsafe.Sizeof函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它
并不会对表达式进行求值。一个Sizeof函数调用是一个对应uintptr类型的常量表达式，因此返
回的结果可以用作数组类型的长度大小，或者用作计算其他的常量。
import "unsafe"
fmt.Println(unsafe.Sizeof(float64(0))) // "8"
Sizeof函数返回的大小只包括数据结构中固定的部分，例如字符串对应结构体中的指针和字符
串长度部分，但是并不包含指针指向的字符串的内容。Go语言中非聚合类型通常有一个固定
的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型
或包含引用类型的大小在32位平台上是4个字节，在64位平台上是8个字节。
计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的
int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一
个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再
大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对
齐。
由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小
的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存
空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐
（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生
影响）。
类型 大小
bool 1个字节
intN, uintN, floatN, complexN N/8个字节(例如float64是8个字节)
int, uint, uintptr 1个机器字
*T 1个机器字
string 2个机器字(data,len)
[]T 3个机器字(data,len,cap)
map 1个机器字
func 1个机器字
chan 1个机器字
interface 2个机器字(type,value)
unsafe.Sizeof, Alignof 和 Offsetof 459
gopl
Go语言的规范并没有要求一个字段的声明顺序和内存中的顺序是一致的，所以理论上一个编
译器可以随意地重新排列每个字段的内存位置，虽然在写作本书的时候编译器还没有这么
做。下面的三个结构体虽然有着相同的字段，但是第一种写法比另外的两个需要多50%的内
存。
// 64-bit 32-bit
struct{ bool; float64; int16 } // 3 words 4words
struct{ float64; int16; bool } // 2 words 3words
struct{ bool; int16; float64 } // 2 words 3words
关于内存地址对齐算法的细节超出了本书的范围，也不是每一个结构体都需要担心这个问
题，不过有效的包装可以使数据结构更加紧凑（译注：未来的Go语言编译器应该会默认优化
结构体的顺序，当然应该也能够指定具体的内存布局，相同讨论请参考 Issue10014 ），内存
使用率和性能都可能会受益。
unsafe.Alignof 函数返回对应参数的类型需要对齐的倍数. 和 Sizeof 类似, Alignof 也是返回
一个常量表达式, 对应一个常量. 通常情况下布尔和数字类型需要对齐到它们本身的大小(最多
8个字节), 其它的类型对齐到机器字大小.
unsafe.Offsetof 函数的参数必须是一个字段 x.f , 然后返回 f 字段相对于 x 起始地址的
偏移量, 包括可能的空洞.
图 13.1 显示了一个结构体变量 x 以及其在32位和64位机器上的典型的内存. 灰色区域是空洞.
var x struct {
a bool
b int16
c []int
}
下面显示了对x和它的三个字段调用unsafe包相关函数的计算结果：
32位系统：
unsafe.Sizeof, Alignof 和 Offsetof 460
gopl
Sizeof(x) = 16 Alignof(x) = 4
Sizeof(x.a) = 1 Alignof(x.a) = 1 Offsetof(x.a) = 0
Sizeof(x.b) = 2 Alignof(x.b) = 2 Offsetof(x.b) = 2
Sizeof(x.c) = 12 Alignof(x.c) = 4 Offsetof(x.c) = 4
64位系统：
Sizeof(x) = 32 Alignof(x) = 8
Sizeof(x.a) = 1 Alignof(x.a) = 1 Offsetof(x.a) = 0
Sizeof(x.b) = 2 Alignof(x.b) = 2 Offsetof(x.b) = 2
Sizeof(x.c) = 24 Alignof(x.c) = 8 Offsetof(x.c) = 8
虽然这几个函数在不安全的unsafe包，但是这几个函数调用并不是真的不安全，特别在需要
优化内存空间时它们返回的结果对于理解原生的内存布局很有帮助。
unsafe.Sizeof, Alignof 和 Offsetof 461
gopl
13.2. unsafe.Pointer
大多数指针类型会写成 ，表示是“一个指向T类型变量的指针”。unsafe.Pointer是特别定义
*T
的一种指针类型（译注：类似C语言中的 类型的指针），它可以包含任意类型变量的地
void*
址。当然，我们不可以直接通过 来获取unsafe.Pointer指针指向的真实变量的值，因为我
*p
们并不知道变量的具体类型。和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支
持和nil常量比较判断是否为空指针。
一个普通的 类型指针可以被转化为unsafe.Pointer类型指针，并且一个unsafe.Pointer类型
*T
指针也可以被转回普通的指针，被转回普通的指针类型并不需要和原始的 类型相同。通过
*T
将 类型指针转化为 类型指针，我们可以查看一个浮点数变量的位模式。
*float64 *uint64
package math
func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(&f)) }
fmt.Printf("%#016x\n", Float64bits(1.0)) // "0x3ff0000000000000"
通过转为新类型指针，我们可以更新浮点数的位模式。通过位模式操作浮点数是可以的，但
是更重要的意义是指针转换语法让我们可以在不破坏类型系统的前提下向内存写入任意的
值。
一个unsafe.Pointer指针也可以被转化为uintptr类型，然后保存到指针型数值变量中（译注：
这只是和当前指针相同的一个数字值，并不是一个指针），然后用以做必要的指针数值运
算。（第三章内容，uintptr是一个无符号的整型数，足以保存一个地址）这种转换虽然也是可
逆的，但是将uintptr转为unsafe.Pointer指针可能会破坏类型系统，因为并不是所有的数字都
是有效的内存地址。
许多将unsafe.Pointer指针转为原生数字，然后再转回为unsafe.Pointer类型指针的操作也是不
安全的。比如下面的例子需要将变量x的地址加上b字段地址偏移量转化为 类型指针，
*int16
然后通过该指针更新x.b：
gopl.io/ch13/unsafeptr
unsafe.Pointer 462
gopl
var x struct {
a bool
b int16
c []int
}
// 和 pb := &x.b 等价
pb := (*int16)(unsafe.Pointer(
uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)))
*pb = 42
fmt.Println(x.b) // "42"
上面的写法尽管很繁琐，但在这里并不是一件坏事，因为这些功能应该很谨慎地使用。不要
试图引入一个uintptr类型的临时变量，因为它可能会破坏代码的安全性（译注：这是真正可以
体会unsafe包为何不安全的例子）。下面段代码是错误的：
// NOTE: subtly incorrect!
tmp := uintptr(unsafe.Pointer(&x)) + unsafe.Offsetof(x.b)
pb := (*int16)(unsafe.Pointer(tmp))
*pb = 42
产生错误的原因很微妙。有时候垃圾回收器会移动一些变量以降低内存碎片等问题。这类垃
圾回收器被称为移动GC。当一个变量被移动，所有的保存该变量旧地址的指针必须同时被更
新为变量移动后的新地址。从垃圾收集器的视角来看，一个unsafe.Pointer是一个指向变量的
指针，因此当变量被移动时对应的指针也必须被更新；但是uintptr类型的临时变量只是一个普
通的数字，所以其值不应该被改变。上面错误的代码因为引入一个非指针的临时变量tmp，导
致垃圾收集器无法正确识别这个是一个指向变量x的指针。当第二个语句执行时，变量x可能
已经被转移，这时候临时变量tmp也就不再是现在的 地址。第三个向之前无效地址空间
&x.b
的赋值语句将彻底摧毁整个程序！
还有很多类似原因导致的错误。例如这条语句：
pT := uintptr(unsafe.Pointer(new(T))) // 提示: 错误!
这里并没有指针引用 新创建的变量，因此该语句执行完成之后，垃圾收集器有权马上回
new
收其内存空间，所以返回的pT将是无效的地址。
虽然目前的Go语言实现还没有使用移动GC（译注：未来可能实现），但这不该是编写错误代
码侥幸的理由：当前的Go语言实现已经有移动变量的场景。在5.2节我们提到goroutine的栈是
根据需要动态增长的。当发生栈动态增长的时候，原来栈中的所有变量可能需要被移动到新
的更大的栈中，所以我们并不能确保变量的地址在整个使用周期内是不变的。
unsafe.Pointer 463
gopl
在编写本文时，还没有清晰的原则来指引Go程序员，什么样的unsafe.Pointer和uintptr的转换
是不安全的（参考 Issue7192 ）. 译注: 该问题已经关闭），因此我们强烈建议按照最坏的方
式处理。将所有包含变量地址的uintptr类型变量当作BUG处理，同时减少不必要的
unsafe.Pointer类型到uintptr类型的转换。在第一个例子中，有三个转换——字段偏移量到
uintptr的转换和转回unsafe.Pointer类型的操作——所有的转换全在一个表达式完成。
当调用一个库函数，并且返回的是uintptr类型地址时（译注：普通方法实现的函数尽量不要返
回该类型。下面例子是reflect包的函数，reflect包和unsafe包一样都是采用特殊技术实现的，
编译器可能给它们开了后门），比如下面反射包中的相关函数，返回的结果应该立即转换为
unsafe.Pointer以确保指针指向的是相同的变量。
package reflect
func (Value) Pointer() uintptr
func (Value) UnsafeAddr() uintptr