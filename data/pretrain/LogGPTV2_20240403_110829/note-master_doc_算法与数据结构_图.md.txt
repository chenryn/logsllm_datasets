# 图
## 一些概念
一个图（一般记作{\displaystyle G}G）由两类元素构成，分别称为**顶点**（或节点、结点）和**边**。每条边有两个顶点作为其端点，我们称这条边“连接”了它的两个端点
**分类**
- 有向图与无向图
- 有权图与无权图
## 表示方法
### 邻接矩阵
![批注 2020-02-12 093539](/assets/批注%202020-02-12%20093539.png)
```java
boolean[][] g;
// n代表顶点的数量，v代表边的数量
int n, m;
// 判断两个顶点是否存在边
boolean hasEdge(int v, int w) {
    return g[v][w];
}
// 给两个顶点增加一条边
void addEdge(int v, int w) {
    if (hasEdge(v, w)) {
        return;
    }
    g[v][w] = true;
    if (!directed) {
        g[w][v] = true;
    }
    m++;
}
// 
```
### 邻接表
![批注 2020-02-12 093727](/assets/批注%202020-02-12%20093727.png)
```java
List> g;
void addEdge(int v, int w) {
    g.get(v).add(w);
    if (!directed && v != w) {
        g.get(w).add(v);
    }
    m++;
}
boolean hasEdge(int v, int w) {
    for (int i = 0; i 无向图G的极大连通子图称为G的连通分量
## 有向图
### 表示
同样也是使用邻接表表示
### 可达性
DFS 与 BFS 同样适用于有向图
### 环
- 拓扑排序
将所有顶点排序，使得所有的有向边均从排在前面的元素指向后面的元素，在有循环依赖的图中，是没法进行拓扑排序的
#### Khan 算法
- 基于BFS
先把没有其他节点连接的节点加入可达节点，然后从剩下的节点中选出可以从可达节点到达的节点，按这样的顺序反复进行
#### 基于DFS
优先找出没有后继节点的节点，把它作为最终节点
### 强连通性
如果两个顶点互相可达，则称它们是强连通的
## 有权图
### 表示
- 邻接表
![批注 2020-02-13 113821](/assets/批注%202020-02-13%20113821.png)
- 邻接表
![批注 2020-02-13 113923](/assets/批注%202020-02-13%20113923.png)
一副连通加权无向图中一棵权值最小的生成树
## 最小生成树
- 贪心算法
>找到最小生成树的一条边，不断重复，直到找到所有最小生成树的所有边
### Prim算法
每次将一个与树节点连接但不在树中且权值最小的边加入树，直至边数达到节点数-1
![202002131423](/assets/202002131423.png)
### kruskal算法
每次将权值最小的且不会构成环的边加入生成树，直至边数达到节点数-1
![202002131458](/assets/202002131458.png)
![202002131459](/assets/202002131459.png)
- 如何判断环
当边加入之后，使用union find判断从某一节点是否连接它自己，如果是，则就是有环
## 最短路径
找到从一个顶点到另一个顶点成本最小的路径
### Dijkstra算法
用来求解单源最短路径
- 前提：图中不能存在负权边
引入了一种叫做最短路径树的构造方法。基于贪心的思想逐步找出距源点 s 最近、次近的点，就能得到一个 G 的子图，里面包含了 s 及所有从 s 出发能到达的节点，它们以 s 为根一起构成了一颗树，就是最短路径树
![202002140953](/assets/202002140953.jpg)