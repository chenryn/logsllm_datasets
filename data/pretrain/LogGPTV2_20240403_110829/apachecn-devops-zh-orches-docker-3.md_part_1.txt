# 三、配置 Docker 容器
在前一章中，我们看到了 Docker 中可用的所有不同命令。我们看了一些例子，涵盖了如何提取映像、运行容器、将映像附加到容器、提交以及将映像推送到存储库。我们还学习了如何编写 Dockerfiles，以使构建映像成为一个可重复的过程。
在本章中，我们将更深入地了解如何控制容器的运行。尽管 Docker 容器是沙箱化的，但这并不能防止其中一个容器中的一个不正常的流氓进程占用其他容器(包括主机)的可用资源。例如，小心这个命令(不要运行它):
```
$ docker run ubuntu /bin/bash -c ":(){ :|:& };:"
```
通过运行前面的命令，您可以对容器和运行它的主机进行分叉轰炸。
维基百科对*叉形炸弹*的定义如下:
> *“在计算中，分叉炸弹是一种拒绝服务攻击，在这种攻击中，进程不断复制自己以耗尽可用的系统资源，导致资源匮乏，并使系统变慢或崩溃。”*
由于 Docker 预计将在生产中使用，一个容器停止所有其他容器的可能性将是致命的。因此，有一些机制可以限制容器可以拥有的资源量，我们将在本章中讨论这些机制。
在前一章中，当我们谈到`docker`运行时，我们已经对卷进行了基本介绍。我们现在将更详细地探讨卷，并讨论它们为什么重要以及如何最好地使用它们。我们还将尝试更改`docker`守护程序正在使用的存储驱动程序。
另一个方面是网络。在检查正在运行的容器时，您可能已经注意到 Docker 随机选择了一个子网并分配了一个 IP 地址(默认值通常是 172.17.42.0/16)。我们将尝试通过设置我们自己的子网来覆盖这一点，并探索有助于管理网络方面的其他可用选项。在许多场景中，我们需要在容器之间进行通信(想象一个容器运行您的应用，另一个容器运行您的数据库)。由于 IP 地址在构建时不可用，我们需要一种机制来动态发现在其他容器中运行的服务。当容器在同一台主机上运行时，以及当它们在不同的主机上运行时，我们将寻找实现这一点的方法。
简而言之，在本章中，我们将涵盖以下主题:
*   限制资源
    *   中央处理器
    *   随机存取存储
    *   储存；储备
*   管理带有卷的容器中的数据
*   配置 Docker 以使用不同的存储驱动程序
*   配置网络
    *   端口转发
    *   自定义的 IP 地址范围
*   链接容器
    *   使用容器链接在同一主机内链接
    *   使用大使容器的跨主机链接
# 约束资源
任何承诺沙盒功能的工具都必须提供一种机制来约束资源分配。Docker 提供了限制容器启动时可以使用的 CPU 内存和 RAM 数量的机制。
## 设置 CPU 份额
使用`docker run`命令中的`-c`选项可以控制一个容器占用的中央处理器份额的数量:
```
$ docker run -c 10 -it ubuntu /bin/bash
```
值`10`是该容器相对于其他容器的相对优先级。默认情况下，所有容器都获得相同的优先级，因此 CPU 处理周期的比率也相同，您可以通过运行`$ cat /sys/fs/cgroup/cpu/docker/cpu.shares`来检查(如果您在 OS X 或 Windows 上，请在执行此操作之前将 SSH 添加到 boot2Docker 虚拟机中)。但是，您可以在运行容器时给出自己的优先级值。
当容器已经在运行时，是否可以设置 CPU 份额？是的。在`/sys/fs/cgroup/cpu/docker//cpu.shares`处编辑文件，并输入您想要赋予它的优先级。
### 注
如果提到的位置不存在，运行`$ grep -w cgroup /proc/mounts | grep -w cpu`命令，找出`cpu` `cgroup`安装的位置。
然而，这是一个黑客，如果 Docker 决定改变 CPU 共享的实现方式，未来可能会改变。关于这方面的更多信息可以在[https://groups.google.com/forum/#!找到主题/Docker-用户/-pP8-KgJJGg](https://groups.google.com/forum/#!topic/docker-user/-pP8-KgJJGg) 。
## 设置内存限制
同样，在启动容器时，也可以限制容器允许消耗的内存量:
```
$ docker run -m 
```
这里，`unit`可以是`b`、`k`、`m`或`g`，分别代表字节、千字节、兆字节和千兆字节)。
一个单元的例子可以表示如下:
```
$ docker run -m 1024m -dit ubuntu /bin/bash
```
这为容器设置了 1 GB 的内存限制。
与限制 CPU 份额的情况一样，您可以通过运行以下代码来检查默认内存限制:
```
$ cat /sys/fs/cgroup/memory/docker/memory.limit_in_bytes
18446744073709551615
```
如文件名所述，前面的代码以字节为单位打印限制。输出中显示的值对应于 1.8 x 1010 千兆字节，这实际上意味着没有限制。
当容器已经在运行时，是否可以设置内存限制？
与 CPU 份额一样，内存限制由`cgroup`文件强制执行，这意味着我们可以通过更改容器的`cgroup`内存文件的值来动态更改限制:
```
$ echo 1073741824 > \ /sys/fs/cgroup/memory/docker//memory.limit_in_bytes
```
### 注
如果`cgroup`文件的位置不存在，运行`$ grep -w cgroup /proc/mounts | grep -w memory`找出文件的挂载位置。
这也是一种黑客攻击，如果 Docker 决定改变内存限制在内部实现的方式，这种攻击在未来可能会改变。
更多关于这个的信息可以在 https://groups.google.com/forum/#!找到主题/Docker-用户/-pP8-KgJJGg 。
## 在虚拟文件系统(设备映射器)上设置存储限制
限制磁盘使用可能有点棘手。没有直接的方法来限制一个容器可以使用的磁盘空间量。默认的存储驱动程序 AUFS 不支持磁盘配额，至少不是没有黑客(困难是因为 AUFS 没有自己的块设备。访问[http://aufs.sourceforge.net/aufs.html](http://aufs.sourceforge.net/aufs.html)了解 AUFS 如何运作的深入信息。在写这本书的时候，需要磁盘配额的 Docker 用户选择`devicemapper`驱动，这将允许每个容器使用多达一定数量的磁盘空间。但是一种更通用的跨存储驱动程序的机制正在开发中，可能会在未来的版本中引入。
### 注
`devicemapper`驱动程序是一个 Linux 内核框架，用于将块设备映射到更高级别的虚拟块设备。
`devicemapper`驱动程序基于两个块设备(将它们视为虚拟磁盘)创建存储块的`thin`池，一个用于数据，另一个用于元数据。默认情况下，这些块设备是通过将稀疏文件装载为环回设备来创建的。
### 注
一个**稀疏文件**是一个包含大部分空白空间的文件。因此，一个 100 GB 的稀疏文件可能实际上只包含开头和结尾的几个字节(并且只占用磁盘上的这些字节)，但是作为一个 100 GB 的文件对应用是可见的。读取稀疏文件时，文件系统会在运行时透明地将空块转换为填充零字节的真实块。它通过文件的元数据跟踪已写块和空块的位置。在类似 UNIX 的操作系统中，环回设备是一种伪设备，它使文件可以作为块设备访问。
之所以称之为`thin`池，是因为当您实际上向块写入数据时，它只会将存储块标记为已使用(来自该池)。每个容器都配有一个特定大小的基本精简设备，并且不允许容器累积超过该大小限制的数据。
默认限制是什么？`thin`池的默认限制是 100 GB。但是，由于用于该池的环回设备是一个稀疏文件，它最初不会占用这么多空间。
为每个容器和映像创建的基本设备的默认大小限制是 10 GB。同样，由于这是稀疏的，它最初不会占用物理磁盘上这么多空间。但是，它占用的空间量会随着大小限制的增加而增加，因为块设备的大小越大，稀疏文件的(虚拟)大小就越大，它需要存储的元数据也就越多。
如何更改这些默认值？您可以使用`--storage-opts`选项更改这些选项，该选项在运行`docker`守护程序时可用，前缀为`dm`(表示`devicemapper`)。
### 注
在运行本节中的任何命令之前，用`docker save`备份所有映像，并停止`docker`守护程序。完全移除`/var/lib/docker`(Docker 存储映像数据的路径)可能也是明智的。
### 设备映射器配置
各种配置如下:
*   `dm.basesize`:这指定了基本设备的大小，由容器和映像使用。默认情况下，该值设置为 10 GB。创建的设备很稀疏，因此最初不会占用 10 GB。相反，它将在数据写入时填满，直到达到 10 GB 的限制:
    ```
    $ docker -d -s devicemapper --storage-opt dm.basesize=50G
    ```
*   `dm.loopdatasize`:这是`thin`池的大小。默认大小为 100 GB。需要注意的是这个文件比较稀疏，所以最初不会占用这个空间；相反，随着越来越多的数据被写入其中，它将逐渐填满:
    ```
    $ docker -d -s devicemapper --storage-opt dm.loopdatasize=1024G
    ```
*   `dm.loopmetadatasize`:如前所述，创建了两个块设备，一个用于数据，另一个用于元数据。此选项指定创建此块设备时要使用的大小限制。默认大小为 2 GB。该文件也很稀疏，因此最初不会占用整个大小。建议的最小大小为总池大小的 1%:
    ```
    $ docker -d -s devicemapper --storage-opt dm.loopmetadatasize=10G
    ```
*   `dm.fs`:这是用于基本设备的文件系统类型。支持`ext4`和`xfs`文件系统，不过`ext4`默认为:
    ```
    $ docker -d -s devicemapper --storage-opt dm.fs=xfs
    ```
*   `dm.datadev`:这个指定了一个自定义的块设备用于`thin`池(而不是环回)。如果使用此选项，建议为数据和元数据指定块设备，以完全避免使用回送设备:
    ```
    $ docker -d -s devicemapper --storage-opt dm.datadev=/dev/sdb1 \-storage-opt dm.metadatadev=/dev/sdc1
    ```
还有更多可用的选项，并在[https://github . com/docker/docker/tree/master/daemon/graph driver/dev mapper/readme . MD](https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper/README.md)上清晰地解释了所有这些是如何工作的。
另一个很棒的资源是 Docker 供稿人 jérme Petazzoni 在[发布的一篇关于调整容器大小的博文，网址为 http://jpetazzo . github . io/2014/01/29/Docker-device-mapper-resize/](http://jpetazzo.github.io/2014/01/29/docker-device-mapper-resize/)。
### 注
如果切换存储驱动程序，旧的容器和映像将不再可见。
在本节的开头，提到有可能有配额，并且仍然通过黑客攻击使用 AUFS。黑客攻击包括根据需求创建基于`ext4`文件系统的回送文件系统，并将其绑定为容器专用的卷:
```
$ DIR=$(mktemp -d)