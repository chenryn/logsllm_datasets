## 典型回答能通过编译。运行后打印出的内容是：    The block is inner.The block is function.
## 问题解析初看这道题，你可能会认为它无法通过编译，因为三处代码都声明了相同名称的变量。的确，声明重名的变量是无法通过编译的，用短变量声明对已有变量进行重声明除外，但这只是对于同一个代码块而言的。对于不同的代码块来说，其中的变量重名没什么大不了，照样可以通过编译。即使这些代码块有直接的嵌套关系也是如此，就像demo10.go 中的`main`包代码块、`main`函数代码块和那个最内层的代码块那样。这样规定显然很方便也很合理，否则我们会每天为了选择变量名而烦恼。但是这会导致另外一个问题，我引用变量时到底用的是哪一个？这也是这道题的第二个考点。这其实有一个很有画面感的查找过程。这个查找过程不只针对于变量，还适用于任何程序实体。如下面所示。-   首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的"当前代码块"仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。-   其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。-   一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么    Go 语言的编译器就会报错了。还记得吗？如果我们在当前源码文件中导入了其他代码包，那么引用其中的程序实体时，是需要以限定符为前缀的。所以程序在找代表变量未加限定符的名字（即标识符）的时候，是不会去被导入的代码包中查找的。> [但有个特殊情况，如果我们把代码包导入语句写成`import . XXX`的形式（注意中间的那个"."），那么就会让这个"XXX"包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体。]{.reference}>> [> 比如，如果有代码包导入语句`import . fmt`，那么我们在当前源码文件中引用`fmt.Printf`函数的时候直接用`Printf`就可以了。在这个特殊情况下，程序在查找当前源码文件后会先去查用这种方式导入的那些代码包。]{.reference}好了，当你明白了上述过程之后，再去看 demo10.go中的代码。是不是感觉清晰了很多？从作用域的角度也可以说，虽然通过`var block = "package"`声明的变量作用域是整个`main`代码包，但是在`main`函数中，它却被那两个同名的变量"屏蔽"了。相似的，虽然`main`函数首先声明的`block`的作用域，是整个`main`函数，但是在最内层的那个代码块中，它却是不可能被引用到的。反过来讲，最内层代码块中的`block`也不可能被该块之外的代码引用到，这也是打印内容的第二行是"Theblock is function."的另一半原因。你现在应该知道了，这道题看似简单，但是它考察以及可延展的范围并不窄。
## 知识扩展**不同代码块中的重名变量与变量重声明中的变量区别到底在哪儿？****为了方便描述，我就把不同代码块中的重名变量叫做"可重名变量"吧。**注意，在同一个代码块中不允许出现重名的变量，这违背了Go语言的语法。关于这两者的表象和机理，我们已经讨论得足够充分了。你现在可以说出几条区别？请想一想，然后再看下面的列表。1.  变量重声明中的变量一定是在某一个代码块内的。注意，这里的"某一个代码块内"并不包含它的任何子代码块，否则就变成了"多个代码块之间"。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。2.  变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。3.  不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而可重名变量之间不存在类似的限制，它们的类型可以是任意的。4.  如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在"屏蔽"的现象。但是这种现象绝对不会在变量重声明的场景下出现。![](Images/9af6e84533cbbabd9293725c8114722a.png){savepage-src="https://static001.geekbang.org/resource/image/5e/89/5e68210d5639f9e42738f21bd9eb1e89.png"}当然了，我们之前谈论过，对变量进行重声明还有一些前提条件，不过在这里并不是重点。我就不再赘述了。以上 4 大区别中的第 3条需要你再注意一下。既然可重名变量的类型可以是任意的，那么当它们之间存在"屏蔽"时你就更需要注意了。不同类型的值大都有着不同的特性和用法。当你在某一种类型的值上施加只有在其他类型值上才能做的操作时，Go语言编译器一定会告诉你："这不可以"。这种情况很好，甚至值得庆幸，因为你的程序存在的问题被提前发现了。如若不然，程序没准儿会在运行过程中由此引发很隐晦的问题，让你摸不着头脑。相比之下，那时候排查问题的成本可就太高了。所以，我们应该尽量利用 Go语言的语法、规范和命令来约束我们的程序。具体到不同类型的可重名变量的问题上，让我们先来看一下`puzzlers/article5/q2`包中的源码文件demo11.go。它是一个很典型的例子。    package main import "fmt" var container = []string{"zero", "one", "two"} func main() {container := map[int]string{0: "zero", 1: "one", 2: "two"}fmt.Printf("The element is %q.\n", container[1])}在 demo11.go中，有两个都叫做`container`的变量，分别位于`main`包代码块和`main`函数代码块。`main`包代码块中的变量是切片（slice）类型的，另一个是字典（map）类型的。在`main`函数的最后，我试图打印出`container`变量的值中索引为`1`的那个元素。如果你熟悉这两个类型肯定会知道，在它们的值上我们都可以施加索引表达式，比如`container[0]`。只要中括号里的整数在有效范围之内（这里是\[0, 2\]），它就可以把值中的某一个元素取出来。如果`container`的类型不是数组、切片或字典类型，那么索引表达式就会引发编译错误。这正是利用Go 语言语法，帮我们约束程序的一个例子；但是当我们想知道 container确切类型的时候，利用索引表达式的方式就不够了。当可重名变量的值被转换成某个接口类型值，或者它们的类型本身就是接口类型的时候，严格的类型检查就很有必要了。至于怎么检查，我们在下篇文章中再讨论。
## 总结我们先讨论了代码块，并且也谈到了它与程序实体的作用域，以及访问权限控制之间的巧妙关系。Go语言本身对程序实体提供了相对粗粒度的访问控制。但我们自己可以利用代码块和作用域精细化控制它们。如果在具有嵌套关系的不同代码块中存在重名的变量，那么我们应该特别小心，它们之间可能会发生"屏蔽"的现象。这样你在不同代码块中引用到变量很可能是不同的。具体的鉴别方式需要参考Go 语言查找（代表了程序实体的）标识符的过程。另外，请记住变量重声明与可重名变量之间的区别以及它们的重要特征。其中最容易产生隐晦问题的一点是，可重名变量可以各有各的类型。这时候我们往往应该在真正使用它们之前先对其类型进行检查。利用Go 语言的语法、规范和命令做辅助的检查是很好的办法，但有些时候并不充分。
## 思考题我们在讨论 Go语言查找标识符时的范围的时候，提到过`import . XXX`这种导入代码包的方式。这里有个思考题：如果通过这种方式导入的代码包中的变量与当前代码包中的变量重名了，那么 Go语言是会把它们当做"可重名变量"看待还是会报错呢？其实我们写个例子一试便知，但重点是为什么？请你尝试从代码块和作用域的角度解释试验得到的答案。戳此查看 Go语言专栏文章配套详细代码。](https://github.com/hyper0x/Golang_Puzzlers)![](Images/6d035e7ef07f11a615a16b7e601fabe9.png){savepage-src="https://static001.geekbang.org/resource/image/35/48/358e4e8578a706598e18a7dfed3ed648.jpg"}
# 06 \| 程序实体的那些事儿 （下）在上一篇文章，我们一直都在围绕着可重名变量，也就是不同代码块中的重名变量，进行了讨论。还记得吗？最后我强调，如果可重名变量的类型不同，那么就需要引起我们的特别关注了，它们之间可能会存在"屏蔽"的现象。必要时，我们需要严格地检查它们的类型，但是怎样检查呢？咱们现在就说。**我今天的问题是：怎样判断一个变量的类型？**我们依然以在上一篇文章中展示过的 demo11.go 为基础。    package main import "fmt" var container = []string{"zero", "one", "two"} func main() {container := map[int]string{0: "zero", 1: "one", 2: "two"}fmt.Printf("The element is %q.\n", container[1])}那么，怎样在打印其中元素之前，正确判断变量`container`的类型？
## 典型回答答案是使用"类型断言"表达式。具体怎么写呢？    value, ok := interface{}(container).([]string)这里有一条赋值语句。在赋值符号的右边，是一个类型断言表达式。它包括了用来把`container`变量的值转换为空接口值的`interface{}(container)`。以及一个用于判断前者的类型是否为切片类型 `[]string` 的 `.([]string)`。这个表达式的结果可以被赋给两个变量，在这里由`value`和`ok`代表。变量`ok`是布尔（bool）类型的，它将代表类型判断的结果，`true`或`false`。如果是`true`，那么被判断的值将会被自动转换为`[]string`类型的值，并赋给变量`value`，否则`value`将被赋予`nil`（即"空"）。``{=html}顺便提一下，这里的`ok`也可以没有。也就是说，类型断言表达式的结果，可以只被赋给一个变量，在这里是`value`。但是这样的话，当判断为否时就会引发异常。这种异常在 Go语言中被叫做`panic`，我把它翻译为运行时恐慌。因为它是一种在 Go程序运行期间才会被抛出的异常，而"恐慌"二字是英文 Panic 的中文直译。除非显式地"恢复"这种"恐慌"，否则它会使 Go程序崩溃并停止。所以，在一般情况下，我们还是应该使用带`ok`变量的写法。