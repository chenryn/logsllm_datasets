# 前言
原本并不打算详细解释这道题的解法，因为我的方法相对较为繁琐。然而，通过反思和总结，我认为在逆向调试和分析技巧上仍有提升空间，并且最后会提及如何在自己的程序中加入LLVM混淆。

## Strange Interpreter

通过`file`指令可以得知这是一个64位、Linux动态编译的程序。使用IDA加载后发现该程序被严重混淆。尽管如此，与某些其他混淆技术相比，这种混淆仍不算特别复杂。

查看字符串信息时，我们可以得知flag的长度为32字节，并找到一段明文。这段明文显然会在程序执行过程中被使用。交叉引用指向了`loc_412164`基本块。进一步检查字符串可以确定该程序是用`Obfuscator-LLVM 4.0.1`编译的。

尽管目前我们还不能直接理解代码逻辑，但敏锐地观察到`byte_613050`可能是最终校验的数据，而`ds:dword_6130D0`则是经过加密变换后的数据。在接下来的分析中，我们将重点关注`ds:dword_6130D0`。不过本文的主要目的是分享一些提高动态调试效率的技巧，因此我们将从`main`函数开始分析。

## 开始

IDA是一个强大的工具，我们应该充分利用它。IDA在完成对程序的初步分析后会生成一个控制流图（CFG），使得各个基本块之间的关系一目了然。浏览整个代码结构可以看到大量的花指令以及采用了控制流平坦化的混淆手段，这些都是常见的反逆向措施。

## 动态调试

假设大家对于LLVM混淆机制不太熟悉，那么可以从`loc_400655`基本块入手进行探索。我们需要密切关注输入的变化。通过连续按F8键单步执行，我们会到达`loc_400979`基本块，在这里主要只有`jmp`和`jz`两种跳转指令。这意味着中间过程不可更改，也没有任何影响流程的验证操作。基于这一点认识，我们可以在每个分支结束处设置断点，然后直接运行至下一个断点以节省时间。回到当前块内，其功能是从输入中提取第一个字符并存储到`ds:dword_6130D0`中，同时将`ecx`作为索引值（已重命名为`ds:index`）。可以推测后续步骤将继续读取剩余输入并将它们依次存入`ds:dword_6130D0`。此时按下F9继续执行直到下一个`loc_4009A9`基本块，此处显然是为了递增`ds:index`。

同样的方式前进到`loc_40095C`，在这里比较`ds:index`是否大于0x20。实际上，此时已经很明显了，但我们仍然需要验证一下。再次按下F9返回`loc_400979`，形成一个循环。现在我们可以取消之前设置的所有断点，再次按下F9并注意观察数据部分的变化，直到到达`loc_4009C6`。由于此代码块非常庞大，IDA无法完整显示其CFG图。

此时`ds:dword_6130D0`的状态如下：
```
...
```

`loc_4009C6`中的代码量极大，如果逐行调试可能耗时很久。因此，我们需要寻找重复模式。紧密关注`ds:dword_6130D0`这部分数据变化，这是关键切入点。前半段主要是复制操作，可以通过F4快速跳过这些重复部分。接下来是一系列增加`index`的操作，可以快速滚动略过直至到达`0x40F13D`位置，出现大量奇怪字符。

跟随一段时间后可以发现，程序将这些字符复制到了`ds:dword_6130D0`偏移`index*4`的位置。同样地，忽略掉重复代码之后会出现许多`index--`操作，紧接着又有一段数据被复制到`ds:dword_6130D0`偏移`0x1d0*4`处。最后来到`0x411A09`处有一个明显的异或运算。通过检查`eax`和`rcx`寄存器内容可以知道这是将输入与初始化数据进行异或处理。由于异或运算是可逆的，因此这部分代码也可以跳过。最终我们的输入变化如下：
```
...
```

只有前0x10个字节发生了改变，这样我们就得到了第一阶段的解密脚本。

## 总结

至此，我想表达的核心思想已经讲完了。在面对带有混淆保护的程序时，不可能全程单步调试，必须有选择性地跳过无用代码以提高效率。做逆向工程时，应该先大致有个方向再逐步验证想法，而不是盲目地一步步尝试。剩下的部分与前面类似，至少方法相同，所以不再赘述。希望以上分享能对大家有所帮助，并鼓励大家亲自尝试调试，体验逆向工程的魅力。文章末尾附上了我的IDB文件供参考！

### 解密脚本
```python
dic = '012345abcdefghijklmnopqrstuvwxyz'
dic_list=list(dic)
xor1=[0x68,0x1C,0x7C,0x66,0x77,0x74,0x1A,0x57,0x06,0x53,0x52,0x53,0x02,0x5D,0x0C,0x5D]
xor2=[0x04,0x74,0x46,0x0E,0x49,0x06,0x3D,0x72,0x73,0x76,0x27,0x74,0x25,0x78,0x79,0x30]
xor3=[0x68,0x1C,0x7C,0x66,0x77,0x74,0x1A,0x57,0x06,0x53,0x52,0x53,0x02,0x5D,0x0C,0x5D]
print(len(xor1))
flag1=""
for i in range(16):
    flag1+=chr(xor1[i]^ord(dic[i]))
print(flag1)
flag2=""
for i in range(16):
    j=i+16
    flag2+=chr(xor2[i]^ord(dic[j])^xor3[i]^ord(dic[i]))
print(flag2)
print(flag1+flag2)
```

### 使用LLVM混淆自己的程序
[obfuscator-llvm](https://github.com/obfuscator-llvm/obfuscator/wiki/Installation)

安装步骤如下：
```bash
$ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git
$ mkdir build
$ cd build
$ cmake -DCMAKE_BUILD_TYPE=Release ../obfuscator/
$ make -j7
```

Ubuntu系统下按照官方指南即可完成安装。编译命令如下：
```bash
$ path_to_the/build/bin/clang test.c -o test -mllvm -sub -mllvm -fla
```

这样就可以为自己创建一道基于LLVM混淆的题目了，是不是很有趣呢？

> 附件链接: 密码:kvs8