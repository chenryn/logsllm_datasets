21 https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecuteexa
39
a short powershell script which downloads a file ‘spy20.exe’ from ‘http://jblecsywt6925.cc/documents/’, save it
as ‘temp.exe’ and execute it.
FIGURE 37: X32DBG – STACK MEMORY EXAMINATION
Patching
Malware can contain defence mechanisms to prevent or impede reverse-engineering. These take
various forms: detection of the presence of a monitoring tool (a debugger, Wireshark, Process monitor, etc.),
testing whether malware is executed in a virtual machine, checking internet connectivity or user interaction, and
many others, including whether it is being examined, for instance, in a sandbox. If a malware detects any of the
above, it can terminate itself or change its behaviour intentionally in order not to reveal its real properties.
An analyst can eliminate these defence mechanisms by patching – i.e. modifying malicious code. This
requires the analyst to identify a defence mechanism in the code, adjust it and save it as a new executable which
can be analysed without the impact of the defence mechanism.
40
The following example shows a defensive mechanism performed by the ‘IsDebuggerPresent’ function
from the standard ‘kernel32.dll’ library. By calling the function, the malware tests if it is running in the presence
of a debugger. The following steps show how to disable the defensive mechanism:
1. Identify the location of ‘IsDebuggerPresent’ function among the intermodular calls (right-click > ‘Search
for’ > ’Current Module’ > ‘Intermodular calls’) and double-click on it.
Evaluate the code and identify how the defence mechanism works and how it can be excluded. In this
example, a function ‘exit’ (called at ‘0x0040112A’ address) terminates its process if the function
‘IsDebuggerPresent’ (located at ‘0x0040111E’ address) returns Boolean ‘true’ (this means the
executable is running in a debugger). To evade this security check, simply rewrite the ‘exit’ function call
and previous ‘PUSH 1’ instruction as ‘nop’, as detailed below. The purpose of the ‘nop’ instruction is
that the CPU does nothing (nop = no operation), which is very useful when removing an original code,
which cannot just be deleted but must be replaced by valid instructions.
2. Mark the line with instruction to be replaced and press the space bar (or right-click on the line >
‘Assemble’).
3. A window with the original instruction appears. Rewrite the original instruction by required instruction
(‘nop’ in this case) and click on OK.
4. Repeat steps 3 – 4 for all lines to be modified.
5. After all modifications are complete, press ‘CTRL + P’ (right-click > ‘Patches’ is an alternative).
6. A new window containing a summary of all changes appears. Click on ‘Patch File’ and save it as a new
file.
41
FIGURE 38: X32DBG - PATCHING
42
6. Network traffic analysis
Analysing network traffic is essential in malware analysis. Looking at the network traffic enables the
analyst to find out which files are being exfiltrated, C2 servers,22 how the malware is communicating, and much
more.
One of the most widely-used network protocol analysis programs is Wireshark, which is a useful tool for
capturing network packets from the specified interface or displaying the network traffic from a packet-captured
file previously recorded. It allows you to view the packet data in as much detail as possible.
NB: At the time of writing, Wireshark could be downloaded from the following link:
https://www.wireshark.org/download.html
Deploying Wireshark, or any other packet capture software locally on the victim VM where the malware
is run, is theoretically possible but has a significant drawback. The malware with self-protection mechanisms
(mentioned in Chapter 2) may be able to detect that it is being monitored and hide its behaviour. Running
Wireshark on the default gateway of the victim machine, therefore, provides a better solution. Also, a SPAN port
can be set up on the switch to send a copy of all network packets seen on the victim VM’s port.
FIGURE 39: WIRESHARK INTERFACE SELECTION
Wireshark starts with the list of available interfaces. The interface from which malware is
communicating can be selected and the traffic can be captured. Eliminating all noise from the specified interface
makes it easier to identify the malware behaviour through that interface.
22 C2 Server: Command and Control Servers are attackers’ machines that are used to control malware.
43
FIGURE 40: GETTING TRAFFIC STATISTICS
Wireshark also keeps useful statistics from the perspective of malware analysis. Connection endpoints
and conversations can be listed using the Statistics tab. While the endpoints list will allow the sorting of IP
endpoints using the number of transmitted packets, the conversations list can sort the conversations between
endpoints according to the number of bytes transferred between them and the duration of their data exchange.
This information can be used to analyse anomalous network behaviour with the IP addresses being contacted.
FIGURE 41: WIRESHARK ENDPOINTS LISTING
44
Using the ‘Resolved Addresses’ list, the domain names of these suspicious IP addresses can be easily
found with no extra effort, as seen in Figure 42.
FIGURE 42: RESOLVED ADDRESSES LIST
In addition to these features, setting up display filters in Wireshark helps to distinguish the packets of
interest. A variety of filtering options are available, ranging from simple protocol filters, such as HTTP, DNS, FTP,
etc., to more complex filters that can be combined by logical expressions according to need. The example in
Figure 43 shows the HTTP traffic of a suspected source IP address in which the packets contain the string ‘exe’.
Here, you can extract these two files simply by clicking on ‘File – Export Objects – HTTP’, which opens a dialog
box that allows these suspicious files to be saved, as shown in Figure 44. All the objects in the traffic can be
exported and saved using the object list.
FIGURE 43: FILTERING .EXE FILES FROM A SPECIFIC IP
45
FIGURE 44: EXPORTING OBJECTS FROM THE TRAFFIC
While Wireshark is a general-purpose network analysis tool for all needs, another network analysis tool,
Network Miner, is more useful and more comfortable from the perspective of forensics and malware.
NB: At the time of writing, Wireshark could be downloaded from the following link:
https://www.netresec.com/?page=NetworkMiner
It is convenient to view all the details gathered about hosts in a user-friendly interface. The files,
credentials, etc. transferred in the network traffic can be listed in different tabs. There are even separate lists of
DNS queries and the sessions which can all be filtered according to need.
46
FIGURE 45: NETWORK MINER INTERFACE
47
7. Packed executables/unpacking
Malware executables are very often packed by authors to prevent antivirus detection and reverse-
engineering examination. This packing is accomplished either by standard software packing tools (e.g. UPX,
EXEStealth, ASProtect, FastPack, EXELock) or custom packers. Both are generally capable of compressing,
encoding and encrypting the original malicious executables. A packer encrypts the original executable and stores
it as raw data into a new executable file that contains code for decryption. If the new file is executed, the original
code is decrypted in memory and executed.
Detection
There are several tips on how to distinguish whether an executable is packed: packed executables
comprise very few meaningful strings, few imports and functions and also have high entropy. This is because the
unpacking code is the only readable part (short code means few strings and little need for imports or functions)
and the data section (containing the original executable) is encrypted, which means no strings, no imports, no
functions and high entropy.
The figure below shows two histograms displaying occurrences of particular byte values in a packed
executable (above) and an unpacked executable (below). The important difference is that the packed executable
has a uniform distribution of byte values, in contrast with the unpacked executable which contains several peaks
caused by the most-used instructions (MOV, PUSH, CALL, etc.).
FIGURE 462: BYTE HISTOGRAM – PACKED EXECUTABLE (ABOVE) VS. UNPACKED EXECUTABLE (BELOW)
48
Several tools are available for recognition of a packed executable – PeStudio23 shows nonsensical strings
and calculates high entropy in the case of packed or encrypted executables; Detect It Easy24 can detect the type
of a packer (based on a database of known packers); function lists and imports are very poor when disassembling
packed executables in IDA.
FIGURE 47: PROPERTIES OF THE PACKED EXECUTABLE (A – STRINGS IN PESTUDIO, B – ENTROPY IN PESTUDIO, C – DETECT
IT EASY, D – FUNCTIONS & IMPORTS IN IDA)
Disassembler IDA and debugger OllyDbg can recognise packed executables or their particular sections.
These tools announce their findings during initial auto-analysis processing if a packed executable is opened.
Further analysis is still possible but results are very inaccurate.
23 See Chapter 3.2.6
24 https://www.ntinfo.biz/index.html#detect_it_easy
49
FIGURE 48: IDA (ON THE LEFT) & OLLYDBG (ON THE RIGHT) POINT OUT PACKED EXECUTABLES
Unpacking
If an executable was packed by a well-known standard packer, there is likely to be a functional unpacker
available, either an official one (e.g. UPX packer/unpacker) or one developed by malware analysts or a
community developed solution.
A different approach is required in the case of unknown custom-packing algorithms. A versatile
procedure is to dump the unpacked code from memory after the packed executable is run and several tools exist
for this purpose (PE tools, Scylla, OllyDumpEx/OllyDump, etc.). Steps on how to use Scylla for unpacking
executables are as follows.
1. Run a packed executable.
2. Open Scylla and attach it to the process of the executable (the code is unpacked at this point).
3. Click on ‘Dump’ and save the new unpacked executable (Scylla opens the dialog for saving a new file).
During the dump operation, some important information like Entry Point and Import Address Table (IAT)
is lost.
4. To identify IAT from the attached process, click on ‘IAT Autosearch’.
5. Click on ‘Get Imports’ to extract IAT from the process. Scylla sometimes has trouble extracting all IAT
entries. If this is the case and Scylla fails to extract some entries (indicated by a red cross instead of a
green checkmark), it may not influence the further analysis, as it is possible to delete failed entries from
the listing and continue to the next steps. If the number of entries not extracted is high, it is better to
repeat the whole procedure from the beginning (i.e. terminate both Scylla and the executable process
and delete the dumped file from step 3).
6. Click on ‘Fix Dump’ and choose the dumped file from step 3.
7. Scylla creates a new fixed file with the same name as the dumped file with the suffix ‘_SCY.exe’.
50
FIGURE 49: UNPACKING WITH SCYLLA
The final unpacked executable with correct IAT is ready for static analysis – code, strings, functions and
imports are visible. Scylla sometimes fails to extract the correct entry point which is an obstacle for further
dynamic analysis. The correct original entry point must be identified by debugging the packed executable and
fixed in the PE header of the unpacked executable.
51
8. Incident response collaboration (Misp & Yara)
Yara rules create descriptions based on textual or binary patterns. Each rule contains a set of strings and
a Boolean expression that determines its logic. In general, each Yara rule has two sections: a strings description
and a condition. While the section containing the strings description can be omitted in some cases, the section
where the conditions are declared is mandatory.
One example of a basic Yara rule is presented below:
rule FirstYaraRule In the example presented on the left, all the binary files that
{ have the text string ‘malwaredomaine.com’ or the following
strings: hexadecimal string ‘A2 24 ?? D8 23 FB’ embedded within a file,
$text_string = ‘malwaredomaine.com" will trigger the Yara rule named ‘FirstYaraRule’. The question
$hex_string = { A2 24 ?? D8 23 FB } mark inside the hexadecimal string represents wild-cards
(bytes that are unknown and could match anything).
condition:
The Yara rule will be triggered if one of the strings (text string
$text_string or $hex_string
or hex string) gives at least one match against the scanned files.
}
To perform Yara rules scanning, the investigator will need the set of rules he wants to use and the target
to be scanned (this can be a file, folder or running process). Since this handbook focuses only on malware that
runs under Windows OS, the executable that could be used to perform the scan can be downloaded from this
webpage: https://github.com/virustotal/yara/releases/tag/v4.0.0
The syntax used when performing the scanning is the following:
yara [OPTIONS] RULES_FILE TARGET
The entire list with all the available parameters that could be used during the scanning is available at this
webpage: https://yara.readthedocs.io/en/v3.4.0/commandline.html
Besides creating his own set of Yara rules, an analyst can also check one of the following Yara rules
resources from trusted third parties:
• Florian Roth repository: https://github.com/Neo23x0/signature-base/tree/master/yara
• Yara Rules group GNU-GPLv2: https://github.com/Yara-Rules/rules
• Github repository: https://github.com/InQuest/awesome-yara
All the findings, including the Yara Rules compiled, could be uploaded, used and then shared on the MISP
Platform (Malware Information Sharing Platform).
MISP is an open-source threat intelligence platform used by various organisations that run multiple
MISP instances for sharing IoCs. The investigator could add all the indicators into his own MISP instances and,
based on the data already stored in the database from other incidents, correlations could be made.
52
The image below presents an event, based on the attributes of which the MISP platform has made a
correlation with other events that were in the database prior to this incident.
FIGURE 50 MISP – WEB INTERFACE25
The facility to share information via the MISP platform is very important, because this enables
collaborative investigation, and prevents you from analysing the same sample as someone else has already
analysed before you.
More information regarding the MISP platform can be found at the following website:
https://www.misp-project.org/index.html
25 Picture from Misp Website: https://www.misp-project.org/index.html
53
9. Conclusion
This handbook covers many tools and their essential usage. It is important to take into account that it
does not aim to demonstrate all features of each tool or all cases in which they may be used. Some tools have
very similar, or overlapping, capabilities. It is up to the reader to evaluate which tool is most appropriate to
accomplish a particular analytical task. Other alternatives also exist that are not listed in the handbook.
Static assembly code analysis is a very time-consuming process. It is advisable to combine it with
dynamic code analysis using debuggers for greater efficiency. It is ideal to start with basic static and behavioural
analysis and then continue with combined (static and dynamic) code analysis using the knowledge gathered
during the first two phases. When performing reverse code engineering, it is important for the analyst to set up
a lab environment, physically separate from the enterprise network, to avoid security breaches or incidents.
The results from malware analysis (IoCs) can be used as an input for further forensic investigation of the
current security incidents but also as an input for security monitoring (Firewall, network or host IDS/IPS, SIEM,
etc.) to prevent the same or similar attacks occurring in the future.
54
10. References
1. Hex Rays SA. 2020. IDA Pro - Hex Rays. [https://www.hex-rays.com/products/ida/]. Accessed
May 2020.
2. Hex Rays SA. 2020. F.L.I.R.T. - Hex Rays. [https://www.hex-rays.com/products/ida/tech/flirt/].
Accessed May 2020.
3. Microsoft. 2020. InternetOpenA function (wininet.h) - Win32 apps | Microsoft Docs.
[https://docs.microsoft.com/en-us/windows/win32/api/wininet/nf-wininet-internetopena].
Accessed May 2020.
4. Hex Rays SA. 2020. IDA Technology: Open Plug-In Architecture - Hex Rays.
[https://www.hex-rays.com/products/ida/tech/plugin/]. Accessed May 2020.
5. National Security Agency. 2020. Ghidra. [https://ghidra-sre.org/]. Accessed May 2020.
6. Microsoft. 2020. Debugging Tools for Windows (WinDbg, KD, CDB, NTSD) - Windows drivers |
Microsoft Docs. [https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/].
Accessed May 2020.
7. x64dbg Community. 2020. x64dbg. [https://x64dbg.com/]. Accessed May 2020.
8. Immunity Inc. 2020. Immunity Debugger.
[https://www.immunityinc.com/products/debugger/index.html]. Accessed May 2020.
9. Oleh Yuschuk. 2014. OllyDbg v1.10. [http://www.ollydbg.de]. Accessed May 2020.
10. Microsoft. 2020. ShellExecuteExA function (shellapi.h) - Win32 apps | Microsoft Docs.
[https://docs.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-shellexecuteexa].
Accessed May 2020.
11. NTInfo. 2020. Detect It Easy. [https://www.ntinfo.biz/index.html#detect_it_easy]. Accessed May
2020.
12. FireEye Labs. Obfuscated String Solver. Github. [https://github.com/fireeye/flare-floss]. Accessed
May 2020.
13. Strings2. [https://github.com/glmcdona/strings2]. Accessed May 2020.
14. Practical Binary Analysis. 2018. Dennis Andriesse. No Starch Press (December 18, 2018)
15. Mastering Malware Analysis. 2019. Alexey Kleymenov. Packt Publishing; 1 edition (June 6, 2019)
16. Procmon [https://docs.microsoft.com/en-us/sysinternals/downloads/procmon]. Accessed May
2020.
17. Process Monitor for Dynamic Malware Analysis. [https://docs.microsoft.com/en-
us/archive/blogs/motiba/process-monitor-for-dynamic-malware-analysis]. Windows Sandbox
Hari Pulapaka. [https://techcommunity.microsoft.com/t5/windows-kernel-internals/windows-
sandbox/ba-p/301849]. Accessed May 2020.
18. Practical Malware Analysis. 2012. Michael Sikorski and Andrew Honig. No Starch Press; 1 edition
(February 1, 2012)
55
19. Mastering Reverse Engineering – Re-engineer your ethical hacking skills. 2018. Reginald
Wongs. Packt Publishing; 1 edition (October 31, 2018)
20. Hands-On Network Forensics: Investigate Network Attacks and Find Evidence Using Common
Network Forensic Tools. 2019. Nipun Jaswal. Packt Publishing; 1 edition (March 30, 2019)
21. Yaniv Assor. 2016. Anti-VM and Anti-Sandbox Explained.
[https://www.cyberbit.com/blog/endpoint-security/anti-vm-and-anti-sandbox-explained/].
Accessed May 2020.
22. Infosec Institute. 2016. How Malware Detects Virtualized Environment (and its
Countermeasures). [https://resources.infosecinstitute.com/how-malware-detects-virtualized-
environment-and-its-countermeasures-an-overview/]. Accessed May 2020
56