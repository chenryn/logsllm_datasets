Read"odd"newsathttp://dailynews.yahoo.com/h/od,and
maybe some techstuff athttp://www.slashdot.com!
---
## Page 101
使用正则表达式修改文本
75
现在正则表达式能够匹配标注出的文本了，当然末尾的标点显然不应该作为URL的一部分。
在匹配英文文本中的URL时，末尾的.，？!]是不应该作为URL的一部分的（这并不是
什么规定，而是我的经验，而且大多数时候都有效）。这很简单，只需要在表达式的末尾添
加一-个表示“除{..？！]之外的任何字符”的否定逆序环视，（？：#读入命令行中指定的第一个文件
$text =~ s/&/&amp:/g:
#转换基本的HTML.
$text =~ s/
Stext =~s/>/&gt;/g;
#进行HTML转义
$text=~s/^\s*$//mg;
#划分段落
将E-mai1地址转换为链接形式
$text =~ s{
\b
#把地址保存到S1
{w[-.\w]*
#username
1@
[-a-z0-9]+(\.[-a-z0-9]+)*\.(com|edu1info)
#hostname
）
\b
}{$1)gix;
#将HTTPURL转换为链接形式
Stext =~ s{
\b
#将URL保存至S1.
http://[-a-z0-9]+(\.[-a-z0-9]+)*\.(comledu1info)\b#hostname
（
/[-a-z0-9_:\@&?=+,.!/~*\$]*
#path不一定会出现
(?$1}gix;
print Stext：#最后，显示结果
---
## Page 102
76
第2章：入门示例拓展
构建正则表达式库
请注意，在这两个例子中，我们使用同样的正则表达式来匹配主机名，也就是说，如果要
修改匹配主机名的表达式，我们希望这种修改会同时对两个例子生效。我们可以在程序中
多次使用变量sHostnameRegex，而不是把这个表达式写在各处，杂乱无绪：
$HostnameRegex = qr/[-a-z0-9]+(\.[-a-z0-9]+) *\.(comledulinfo)/i;
#将E-mail地址转换为链接形式
$text =~ s{
\b
#将地址保存至S1.
（
\w[-.\w] *
#username
1@
SHostnameRegex
#hostname
\b
)(S1)gix;
#将HTTPURL转换为链接形式….
$text =~ s{
\b
#Capture the URL to $1…
http://$HostnameRegex\b
#hostname
/[-a-z0-9_:\@&?=+,.!/~*'\S] *
#path不一定会出现
([i'·]i>)
#不容许以[.，？！]结尾
（
}($1)gix;
第一行使用了Perl的qr操作符。它与m和s操作符类似，接收一个正则表达式（例如，使
用qr/./、类似使用m/./和s/././），但并不马上把这个正则表达式应用到某段文本中进
行匹配，而是由这个表达式生成为一个“regex对象（regexobject）”，作为变量保存。之
后我们就能使用这个对象。（在本例中，我们用变量sHostnameRegex来保存这个变量，供
后面两个正则表达式使用。）这样做非常方便，因为程序看起来非常清楚。此外，我们的匹
都可以直接使用它。第6章（277）还有关于构建这种“正则表达式库”的例子，具体讲
解见第7章（303）。
其他的语言也提供了创建正则表达式对象的方法，下一章我们会简要介绍若干语言，而Java
---
## Page 103
使用正则表达式修改文本
77
为什么有时候$和@需要转义
你可能注意到了，“S’符号既可以作为表示字符串结束的元字符，又可以用来标记变量。
通常，‘s”的意思是很明确的，但如果在字符组内部，情况就有些麻烦，因为此时它不能
用来表示字符串的结束位置，只能在转义之后，用来标记变量。在转义之后，“s’就只是
字符组的一部分。而这正是我们所要的，所以我们需要在URL匹配的正则表达式中对它进
行转义。
的情况与之类似。Perl用e表示数组名，而Perl中的字符串或正则表达式中也容许出现数
组变量。如果我们希望在正则表达式中使用e字符，就需要进行转义，避免把它作为数组名。
一些语言（Java、VB.NET、C、C#、Emacs、awk等）不支持变量插值（variableinterpolation）。
有些语言（例如Perl、PHP、Python、Ruby和Tcl）支持变量插值，但是方法各有不同。我
们会在下一章详细讲解（101)。
回到单词重复问题
That Doubled-VVord Thing
给出了一堆难懂的代码，将其作为解法之一：
$/=*.\n";
while(<>){
next if!s/\b([a-z]+)((?:\sl]+>)+)(\1\b)/\e[7m$1\e[mS2\e[7mS3\e[m/ig;
S/^（？：[^\e]*\n）+//mg：#删除所有未标记的行
S/^/$ARGV:/mg;
#在行首增加文件名
print;
）
对Perl有了些了解之后，我希望读者至少能够看懂常规的正则表达式应用一一其中的<>，
三个s/.././，以及print。不过，其他的部分仍然很难。如果你关于Perl的知识全部来自
不过，如果细致考察起来，我认为这个正则表达式并不复杂。在重读程序之前，我们不妨
回过头看看第1页的程序规格要求，并尝试运行一次：
perl-wPindDbl ch01.txt
ch01.txt:checkfor doubledwords（such asa），acommonproblemwith
ch01.txt:*Find doubled words despite capitalization differences,such as with*
ch01.txt:',as well as allow differingamounts of whitespace （space,tabs,
ch01.txt:/\）@
nextunlesSB（#（下面是正则表达式）
###匹配一个单词：
\b
#单词的开始位置….
（[a-2]+)
#把读取的单词存储至S1（和\1）
###下面是任意多的空白字符和/或tag
（
#把空白保存到S2
(? :
#（使用非捕获型括号）
\S
#空白宇符（包括换行符、这样非常方便）
1
#或者是
]+>
#形式的tag
) +
#至少需要出现一次，多次不受限制
###现在再次匹配第一个单词：
(\1\b)
#b保证用来避免嵌套单词的情况，保存到S3
#（正则表达式结束）
#上面是正则表达式.下面是replacement字符串，然后是修饰符、/i、/g和/x
{\e[7m$1\e[m$2\e[7m$3\e[m]igx;0
s/~(？:[~\e]*\n)+//mg;
#去掉所有未标记的行
8/~/SARGV:/mg;
#在每行开头加上文件名
print;
这小段程序中出现了许多我们没见过的东西。下面我会简要地介绍它们以及背后的逻辑，
不过我建议读者查看Perl的manpage了解细节（如果是正则表达式相关的细节，可以查阅
第7章）。在下面的描述中，“神奇”（magic）的意思是“这里用到了读者可能不熟悉的Per
的特性”。
0因为单词重复问题必须应付单词重复位于不同行的情况，我们不能延续在E-mail的例
子中使用的普通的按行处理的方式。在程序中使用特殊变量S/（没错，这确实是一个
变量）能使用一种神奇的方式，让<>不再返回单行文字，而返回或多或少的一段文字。
返回的数据仍然是一个字符串，只是这个字符串可能包含多个逻辑行。
---
## Page 105
使用正则表达式修改文本
79
你是否注意到，<>没有值赋给任何变量？作为while中的条件使用时，<>的神奇之处在
于，它能够把字符串的内容赋给一个特殊的默认变量（注6)。该变量保存了s/../.
和print作用的默认字符串。使用这些默认变量能够减少余代码，但Perl新手不容
易看明白，所以我还是推荐，在你习惯之前，把程序写得更清楚一些。
如果没有进行任何替换，那么替换命令之前的nextunleBB会导致Perl中断处理当前
字符串（转而开始下一个字符事）。如果在当前字符事中没有找到单词重复，也就不必
进行下一步的工作。
0replacement字符串包含的就是“s1$2S3”，加上插入的ANSI转义序列，把两个重叠的
词标记为高亮，中间的部分则不标记高亮。转义序列\e[7m用于标注高亮的开始，\e[m
用于标注高亮的结束（在Per的正则表达式和字符串中，\e用来表示ASCIl的转义字
符，该字符表示之后的字符为ANSI转义序列）。
仔细看看正则表达式中的那些括号，你会发现“$1$2S3”表示的完全就是匹配的文本。
所以，除了添加转义序列之外，整个替换命令并没有进行任何实质修改。
replacement中只用一个也是可以的。不过，因为这两个单词的大小写可能有区别，我
用了两个变量。
这个字符事可能包括多个逻辑行，不过在替换命令标记了所有的董复单词之后，我们希
望只保留那些包含转义字符的逻辑行。去掉不包含转义字符的逻辑行之后，留下的就是
字符串中我们需要处理的行。因为我们在替换中使用的是增强的行锚点匹配模式（/m
修饰符），正则表达式（[^\e]*\n）+能够找出不包含转义字符的逻辑行。用这个表达
式来替换掉所有不需要处理的行。结果留下的只是包含转义字符的逻辑行，也即那些包
含单词董复的行(注7)。
变量SARGV提供了输入文件的名字。结合/m和/g，这个替换命令会把输人文件名加到
留下的每一个逻辑行的开头。多酷！
注6：跌认变量是S_（是的，这也是一个变量）。它可以作为多个函数和操作符的跌认操作对象。
注7：在这里我们假设输入的文本中不包含转义字符。否则程序不能正常工作。
---
## Page 106
80
第2章：入门示例拓展
最后，print会输出字符串中留下的逻辑行以及转义字符。while循环对输入的所有字符串
重复处理(每次处理一段)。
更深入一点：运算符、函数和对蒙
我之前已经强调过，在本章我以Perl作为工具来讲解概念。Perl的确是一种有用的工具，
但我想要强调的是，这个问题利用其他语言的正则表达式解决起来也很容易。
同样，因为Perl具有与其他高级语言不同的独特风格，讲解这些概念更加容易。这种独特
风格就是，正则表达式是“基础级别（first-class）”的。也就是说，基本的运算符可以直接
作用于正则表达式，就好像+和-作用于数字一样。这样减轻了使用正则表达式的“语法包
状”(syntactic baggage)。
其他许多语言并没有这样的特性。因为第3章中提到的原因（93），许多现代语言坚持提
供专用的函数和对象来处理正则表达式。例如，可能有一个函数接收表示正则表达式的字
符事，以及用于搜索的文本，然后根据正则表达式能否匹配该文本，返回真值或假值。更
常见的情况是，这两个功能（首先对一个作为正则表达式的字符串进行解释（interpretion），
然后把它应用到文本当中）被分割为两个或更多分离的函数，就像下一页的Java代码一样。
这些代码使用Java1.4以后作为标准的java.util.regex包。
Pattern.compile程序。通过比较我们发现，Java版本的正则表达式包含了更多的反斜线，
原因是Java要求正则表达式必须以字符串方式提供。正则表达式中的反斜线必须转义，以
避免Java在解析字符事时按照自己的方式处理它们。
我们还应该注意到，正则表达式不是在程序处理文本的主体部分出现，而是在开头的初始
化部分出现的。Pattern.compile函数所作的仅仅是分析这些作为正则表达式的字符串，
然后，在处理文本的主体部分，已编译的版本通过regex1.matcher（text）应用到文本之
上，得到的结果用于替换。同样，我们会在下一章探究其中的细节，在这里我们只需要了
解，在学习任何一门支持正则表达式的语言时，我们需要注意两点：正则表达式的流派，
以及该语言运用正则表达式的方式。