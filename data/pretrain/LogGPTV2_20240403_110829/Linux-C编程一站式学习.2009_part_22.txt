void insertion_sort(void)
最坏情况是最常发生的情况，
a[i+l] = key;
key
，也不取决于输入长度n，而是取决于具体的输入数据。在最好情
 a[j];
100时，
C1g(n)
C2g(n)
，平均情况和最坏情况的时间复杂度都是输入长度n的二次函数。
f(n)
-n
后者的值就远远大于前者了。如果同一个问题可以用
：
另一种算法的时间复杂度为二次函数，
182
---
## Page 183
Bound）肯定是常数，我们这里假设语句的执行时间是常数只是一个粗略估计。
[23] 受内存管理机制的影响，指令的执行时间不一定是常数，
2.插入排序
于"类似。
起来在各种情况下插入排序的时间复杂度是O(n²)。⊙的含义和"等于"类似，而大O的含义和"小于等
最坏情况和平均情况下时间复杂度是⊙(n²)，在最好情况下是⊙(n)，数量级比⊙(n2)要小，那么总结
除了⊙-notation之外，表示算法的时间复杂度常用的还有一种Big-O notation。我们知道插入排序在
排序的时间复杂度分析，
是：⊙(lgn), (sqrt(n),
几种常见的时间复杂度函数按数量级从小到大的顺序依次
说bn+c的影响可以忽略，a可以通过选取合适的c1、C2来补偿。
明过程可以得出结论，当n足够大时任何an²+bn+c都夹在cin2和c2n2之间，相对于n2项来 
为0，n>6时该函数都大于0，可以取no=7，c1=1/14，这样当nzno时都有1/2-3/nzc。通过这个证
这样就很容易看出来，无论n取多少，
上一页
1/2-3/n
1/14
——————
 无非是循环体的执行时间乘以循环次数，
一
，该函数一定小于1/2，
全国嵌入式人才培训基地
起始页
上一级
，⊙(2),
，因此c2=1/2，
但执行时间的上界（Upper
只有加和乘运算，
，(n!)。其中，Ign通常表示
，当n=6时函数值
，怎么会出
4.归并排序
下一页
183
---
## Page 184
在描述归并排序的步骤时又调用了归并排序本身，可见这是一个递归的过程。
逐渐将整个数组排序完毕，
插入排序算法采取增量式（Incremental）的策略解决问题，每次添一个元素到已排序的子序列中，
4.归并排序 请点评
3．Combine:将两个排序好的子序列合并成一个最终的排序序列。
 2．Conquer:对这两个子序列分别采用归并排序。
上一页
1．Divide:把长度为n的输入序列分成两个长度为n/2的子序列。
，它采取分而治之（Divide-and-Conquer）的策略，
例11.2.归并排序
a[mid+1..end]
a[start..mid]
void merge(int start, int mid, int end)
#define LEN 8.
#include 
while (j1时：
然后分析sort函数的时间复杂度,
来理解。我们分析一
T(n）={
两
就
并排序的过程,
数递归调用了自己两次，
个⊙(n)再加上若干常数项，merge函数总的执行时间仍是(n)，其中n=end-start+1。
会在最终的排序序列中确定一个元素，
存储空间的执行时间都可以看作常数，
避免使用这一特性，
[(1)
读者在理解递归函数时一定不要全部展开来看，
一下归并排序的时间复杂度，
ifn=1
ifn=1
所以各函数之间的调用关系呈树状结构。画这个图只是为了清楚地展现归
，当输入长度n=1，也就是start==end时，if条件不成立，执行时
我们需要消去等号右侧的T(n),
 最终的排序序列共有n个元素，
也就是⊙(n),
与数组的长度无关，
S{52471326]
以下分析出自[算法导论]。
S{1326}-
后面三个for循环合在一起看，
}->{12234567}
，a[start..end]的总长度为n=n1+n2，
，常数用⊙-notation记作(1)。设子序
{1236}
 而是要抓住Base Case和递推关系
 把T(n)写成n的函数。其实符
 所以执行时间也是(n)。
7
/
M
/
，定义数组并分
每走一次循环
当然也可
186
2
---
## Page 187
但比归并排序有更小的时间常数。它的基本思想是这样的：
1、快速排序是另外一种采用分而治之策略的排序算法，
习题 请点评
是⊙(nlgn),
系数和低次项，
和插入排序的平均情况相比归并排序更快一些,
果也是⊙(nlgn)。既然T(n)的上下界都是(nlgn)，显然T(n)就是⊙(nlgn)。
如果先前取c,和c2中较小的一个设为c，
是(nlgn)。
有lgn+1层，因此总的执行时间是cnlgn+cn，相比nlgn来说，cn项可以忽略，因此T(n)的上界
把图(d)中所有的项加起来就是总的执行时间。这是一个树状结构，每一层的和都是cn，共
(n)
int partition(int start, int end)
，而插入排序的平均情况是⊙(n²),
，但是对于较大的输入长度n，
[b)
return mid;
在
(d)
Total: cn Ig n + cn
，计算出的结果应该是T(n)的下界，然而推导过程一样，结
，这就决定了归并排序是更快的算法。但是不是任何情
这些都不是主要因素，
虽然merge函数的步骤较多，
，在平均情况下的时间复杂度也是⊙(nlgn),
归并排序的时间复杂度 
成
引入了较大的常数、
---
## Page 188
3.算法的时间复杂度分析
杂
序在最好和最坏情况下的时间复杂度是多少？
，有兴趣的读者可以参考[算法导论]
void quicksort(int start, int end)
 这个函数有多种写法，
quicksort(mid+l, 
quicksort(start,
mid
 partition(start,
全国嵌入式人才培训基地
快速排序在平均情况下的时间复杂度分析起来比较复
起始页
 请选择时间常数尽可能小的实现方法。
 end);
 mid-1);
一级
 end);
想想快速排
5.线性查找
188
---
## Page 189
3、进一步泛化，在一组随机排列的数中找出第k小的，这个元素称为k-th Order Statistic。能想到
是⊙(n)的，想想有没有比(n)更快的算法？
习题 请点评
5.线性查找 请点评
是(nlgn)。这个问题虽然比前两个问题复杂，但它也有平均情况下时间复杂度是白(n)的算法，将
的最直观的算法肯定是先把这些数排序然后取第k个
1、实现一个算法，
个元素的位置－－有没有比O(n)更快的算法？比如O(Ign)？请读者思考一下。
容易想到，
这个实现是最直观和最容易想到的，但它是不是最快的算法呢？我们知道插入排序也比归并排序更
中找出某个字母的位置并返回这个位置，如果找不到就返回-1：
有些查找问题要用时间复杂度为O(n)的算法来解决。例如写一个indexof函数，从任意输入字符串
、在一组随机排列的数中找出第二小的，这个问题比上一个稍复杂，你能不能想出⊙(n)的算法?
-节习题1的快速排序算法稍加修改就可以解决这个问题：
例11.3.线性查找
但通常不如归并排序快。
int indexof(char letter)
char a[]="hello world";
#include 
int main(void)
，在一组随机排列的数中找出最小的一个。你能想到的最直观的算法一定
printf("%d %d\n", indexof('o'), indexof('z');
return 0;
return -l;
i++;
，那么现在这个问题－一给定一个随机排列的序列，找出其中某
“(a[i]
！=
全国嵌入式人才培训基地
第11章排序与查找
 return i;
"\o'）{
5.线性查找
 时间复杂度和排序算法相同，可以
189
下一页
---
## Page 190
4.归并排序
请编程实现这个算法。
else
用partition函数把序列分成两半，中间的pivot元素是序列中的第i个；
if
(k
“返回找到的元素；
从前半部分找出第k小的元素并返回；
全国嵌入式人才培训基地
起始页
级
6.折半查找
190
---
## Page 191
如果不是从一组随机的序列里查找，而是从一组排好序的序列里找出某个元素的位置，则可以有更
6.折半查找 请点评