unpacking and automated malware analysis environments there-
fore rely on hooking these API functions [5, 11] to detect the code
injections.
However, as observed in our motivating example, the malware
does not rely on WriteProcessMemory or similar API calls to estab-
lish the code injection. In fact, the malware relies on two rather
mundane API functions, SendNotifyMessage and SetWindowsLong.
Furthermore, the injection technique is application-speci(cid:128)c in that
it relies on constructs speci(cid:128)cally present in explorer.exe.
It is important to clarify that code injections are not necessarily
exploits, and many of them are not intended to escalate privileges
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1693from an OS point of view. Rather, these are injection techniques that
target OS-speci(cid:128)c constructs that allows the malware to execute
code in another process. (cid:140)e code injection is then used for achiev-
ing evasive behaviours, bypassing white-listed HIPS processes and
several other purposes [28]. E(cid:130)ectively, the number of potential
targets for these code injections is very large, because the malware
is not necessarily interested in a speci(cid:128)c set of privileged processes.
2.5 Observations and objectives
(cid:140)e combination of dynamically generated code, code-reuse a(cid:138)acks
and code injections allows for complex malicious propagations
that pose new challenges for malware analysis systems. Although
these techniques have been treated individually in the past, they
have signi(cid:128)cant overlap and malware o(cid:137)en use the techniques in
combination. Previous work su(cid:130)ers from focusing on one of the
techniques and are therefore incomplete when the techniques are
combined.
(cid:140)e objective with Tartarus is to construct a uni(cid:128)ed approach
for automatic analysis of malware that combines all of the three
techniques: (1) Dynamically generated code; (2) Code-reuse a(cid:138)acks
and (3) Code injections. We achieve this by dividing the objective
of Tartarus into two main goals:
(1) A novel approach to malware execution tracing that is
tailored analysis of malware propagations. (cid:140)is requires a
technique that is general enough to tracing malware even
in the context of code injections and code-reuse a(cid:138)acks.
(2) Techniques for raising the collected execution trace into
higher level semantics suitable for fully automatic analysis,
namely dynamically generated code and code injections.
Dynamically generated malicious code should be recog-
nized independent of who wrote the code and code injec-
tions must be identi(cid:128)ed even if the injection techniques
are unknown prior to analysis.
3 SYSTEM-WIDE MALWARE TRACING
In this section we present Tartarus’ (cid:128)rst goal of optimizing the
completeness and precision of malware execution tracers. We start
by presenting a model that allows us to reason precisely about mal-
ware execution tracers and then proceed to present our approach.
At the end of the section we give a brief discussion on limitations
as well as a comparison to previous work.
3.1 Abstract model of execution environment
We consider execution at the machine instruction level and our
model is extended from work done by Dinaburg et al [12]. Since
an instruction can access memory and CPU registers directly, we
consider a system state as the combination of memory contents
and CPU registers. Let M be the set of all memory states and C
be the set of all possible CPU register states. We then denote all
possible instructions as I, where each instruction can be considered
a machine recognizable combination of opcode and operands stored
at a particular place in memory.
A program P is modelled as a tuple (MP , P ) where MP is the
memory associated with the program and P is an instruction in
MP which de(cid:128)nes the entry point of the program. When a program
executes, there are o(cid:137)en many other programs executing on the
system as well, and each of these may communicate with each other
through the underlying OS. As such, we model the execution envi-
ronment E as the underlying OS and the other programs running
on the system.
We de(cid:128)ne a transition function δE : I ˆ M ˆ C Ñ I ˆ M ˆ C to
represent the execution of an instruction in the environment E. It
de(cid:128)nes how execution of an instruction updates the execution state
and determines the next instruction to be executed. (cid:140)e trace of
instructions obtained by executing program P in execution environ-
ment E is then de(cid:128)ned to be the ordered set TpP,Eq “ pi0, . . . ,ilq
where i0 “ P and δEpik ,Mk ,Ckq “ pik`1,Mk`1,Ck`1q for 0 ď
k ă l. We note here that the execution trace does not explicitly
capture what instructions are part of the program, with the excep-
tion of i0, but rather all the instructions executed on the system
including instructions in other processes etc.
3.2 Malware execution trace
We now introduce the concept of malware execution trace, which
describes what instructions of a whole-system execution is part
of the malware execution. Suppose P is a malware program and
PA is some malware tracer that aims to collect P’s execution trace.
Malware program P is interested in evading analysis and gaining
privilege escalation by using dynamically generated code, code-
reuse a(cid:138)acks and code injections. As such, the execution trace of
the malware may contain instructions that are not members of the
program’s memory MP .
To monitor the malware across the environment, the malware
monitor PA maintains a shadow memory that allows it to label the
memory and the CPU registers. (cid:140)is shadow memory is updated
for each instruction in the execution trace. Let S Ď M ˆ C be the
set of all possible shadow memories. We then de(cid:128)ne the function
δA : SˆI Ñ S to represent the updating of a shadow memory when
an instruction is executed. We call this the propagation function.
(cid:140)e list of shadow memories collected by the malware tracer is
now de(cid:128)ned as the ordered set: STApTpP,Eqq “ ps0, . . . ,slq where
δApsk ,ikq “ sk`1 for 0 ď k ă l.
(cid:140)e job of the analyser is to determine for each instruction in
the execution trace whether the instruction belongs to the malware
or not. To do this, the analyser uses the predicate ΛA : S ˆ I Ñ
ttrue, f alseu. (cid:140)e malware execution trace is now given as the
sequence of instructions for which ΛA is true and we call ΛA the
inclusion predicate. We de(cid:128)ne the malware execution trace formally
as follows:
De(cid:128)nition 1. Let TpP,Eq be an execution trace and PA a malware
tracer. (cid:138)e malware execution trace is the ordered set
ΠA “ pm0, . . . ,mdq where:
‚ ΠA Ď TpP,Eq;
‚ Dv | mj “ iv ^ ΛApsv ,ivq for 0 ď j ď d.
(cid:140)e above de(cid:128)nition gives us a starting point from which we
can reason about the properties of malware tracers. In particular,
for a given malware tracer it highlights the propagation function,
δA, together with the inclusion predicate, ΛA, to be the de(cid:128)ning
parts. Given two malware tracers that are targeted the same ex-
ecution environment, such as X86, we can then make a detailed
comparison about the instructions each analyser includes in its
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1694malware execution trace. We do this with Tartarus and previous
work [5, 40]. However, before this comparison is possible, we must
(cid:128)rst introduce our approach and we do this next.
3.3 Overview of malware execution tracing
Algorithm 1 gives an overview of our approach. For notation, let
irAs denote the address of an instruction and irOs the output of an
instruction. (cid:140)e (cid:128)rst step (line 2) is to taint the memory making up
the malware, and we describe this in Section 3.4. Next, we execute
the malware and continue execution until there is no more taint or
a user-de(cid:128)ned timeout occurs.
For each instruction we check if the memory making up the
instruction is tainted (line 8) and if so, include it in the malware
execution trace. If it is not tainted (line 10), we check if the instruc-
tion is part of a bu(cid:130)er that holds the code-reuse instructions we
need to monitor (line 13). If it is, then we set a temporal variable
indicating if the instruction should be included in the malware
execution trace, and also remove it from the set of code-reuse to
monitor. Next (line 17), we check if the instruction initiates any
code-reuse (Section 3.5). If it does, then we set the temporal vari-
able indicating the instruction must be appended to the malware
execution trace and also include the code being reused into our
code-reuse bu(cid:130)er (Section 3.5). Finally, we execute the instruction
and propagate taint (line 24).
Algorithm 1: Main algorithm
Data: Malware execution trace Π, gadgets G.
Result: (input) Malware sample B
1 // Initialisation;
2 T Ð init taintpBq; // Taint set
3 T G Ð H;
4 // Begin full system instrumentation;
5 i Ð f irst instrpq;
6 while T ‰ H do
// is the instruction tainted?;
if irAs P T then
Π Ð Π^xiy;
else
// code-reuse handling
// is it in the gadget bu(cid:130)er?
if i P T G then
append “ true;
T G Ð T Gztiu;
// does it initiate code-reuse?;
if initiates code r eusepi, Pq then
append “ true
T G Ð ❕et code r eusedpi, T Gq
G Ð T G Y G
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
if append “ true then
Π Ð Π^i
append “ f alse
pi, T q Ð updatepi, T q;
25 return pΠ, Gq
Address
I
I
I
I
I
Table 1: Conditions for identifying GI instructions.
Code-reuse conditions
A P T , rAs R T , I R T
r e❕ P T , rr e❕s R T , I R T
A P T , rAs R T , I R T
r e❕ P T , rr e❕s R T , I R T
esp P T , resps R T , I R T
Instruction
CALL [A]
CALL reg
JMP [A]
JMP reg
RET
GI





3.4 Initial setting
We consider malicious code execution on the basis of tainted mem-
ory. (cid:140)e only two ways we include instructions in the malware
execution trace is if memory that makes up an instruction is tainted
or the instruction is part of a code-reuse a(cid:138)ack. (cid:140)e only way new
taint is introduced in the system apart from the initial taint is by
instructions that are already tainted. (cid:140)e initial taint is therefore
seed for the rest of the analysis and will have a large impact on the
completeness and precision of the analysis.
To ensure completeness, the initial taint must cover all memory
that belongs to the malware codebase, and also memory from where
the malware can derive dynamically generated code. If we miss
any such memory, then there is a possibility the malware uses this
memory to dynamically generate code and our monitor will miss
out when this code is executed. On the basis that malware can
contain code anywhere in its module we taint the entire module
of the malware. (cid:140)e tainting occurs when the program has been
loaded into memory so as to ensure our tainting happens before
any of the malicious code is executed.
3.5 Code-reuse identi(cid:128)cation
In Section 2.3 we introduced the di(cid:130)erent types of code-reuse at-
tacks. (cid:140)e similarity between the techniques is that an indirect
branch instruction in benign code redirects execution to other be-
nign code, and the value that determines the destination is con-
trolled by the adversary. (cid:140)e di(cid:130)erence between the techniques is
then the instruction used i.e. whether it is a ret, jmp or call in-
struction. Because of this similarity, we consider code reuse a(cid:138)acks
on a more abstract level. Formally, we de(cid:128)ne code reuse a(cid:138)acks as
pairs pGI,GCq where GC is the reused code (gadget code) and GI
is the instruction that initiates the branch to the reused code (gadget
initiator). When malware reuses code as part of their control-(cid:131)ow,
GI is the trigger that allows the malware to use GC for its own
purposes.
We identify GI instructions as dynamic instructions made up of
non-tainted memory that branches to non-tainted memory, but the
memory that determines the destination of the branch is tainted.
(cid:140)e particular execution pa(cid:138)ern we capture with this de(cid:128)nition is
malware that creates a control-(cid:131)ow by chaining two benign code
regions (non-tainted code) together by overwriting the address
determining the branch destinations and not the code itself. Table
1 illustrates the speci(cid:128)c rules we use to determine if an instruction
is a GI.
When a GI instruction has been identi(cid:128)ed, we proceed to de-
termine GC. Previous literature on exploit mitigation has tested
several ways on how to de(cid:128)ne GC and there is no de(cid:128)nitive best
solution. (cid:140)e di(cid:129)culty occurs because GC can in practice include
Session H2:  Code Reuse AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1695an arbitrary number of instructions and arbitrary structure, and
can vary between small gadgets and entire functions. To this date,
we monitor if the destination of GI is a function, and if so, con-
sider the GI to be a function call inside the malware execution
trace. If the destination is not a function, then we include GI in the
execution trace as well as the instructions of the (cid:128)rst basic block at
GI’s destination.
When a pair pGI,GCq has been identi(cid:128)ed we must include
them in the malware execution trace. However, the gadget is only a
one-time execution so we can’t taint the instructions as we do with
regular malware code. Instead, we append the GI instruction to the
malware execution trace as we observe it, and all the instructions
of the GC basic block is put into a bu(cid:130)er. Instructions in the bu(cid:130)er
are then included in the execution trace only the (cid:128)rst time they are
executed right a(cid:137)er the GI instruction execution. In this way we
ensure only including the gadgets at the speci(cid:128)c instance where
the malware makes use of it.
We notice here that there is one exception to the rule, which
is when we observe a chain of code-reuse a(cid:138)acks where the last
hijacked indirect branch branches to tainted memory. (cid:140)is is seen
in code injection techniques where a chain of code-reuse a(cid:138)acks is
used by the malware to transfer execution to shellcode. In this case,
the last hijacked indirect branch will e(cid:130)ectively transfer execution
to tainted memory, which means it does not satisfy the conditions
for a code-reuse a(cid:138)ack. To circumvent not including this hijacked
indirect branch in the malware execution trace, if we observe a
chain of code-reuse a(cid:138)acks followed by another hijacked indirect
branch that transfers execution to tainted memory, then we also
include this hijacked indirect branch in the malware execution trace
as a code-reuse a(cid:138)ack.
3.6 Propagation function
In Section 3.2 we describe that one of the key aspects of a malware
execution tracer is the propagation function. (cid:140)e propagation func-
tion is in charge of updating the shadow memory. (cid:140)e core part
of our propagation function is de(cid:128)ned by our update algorithm,
shown in Algorithm 2. We (cid:128)rst apply taint propagation for a given
instruction, done by the propagate taint function. In practice, we
do this with a bitwise tainting and do not rely on pointer tainting.
Because our implementation is based on the DECAF [21] platform
we taint directly on the QEMU tcg instructions [3]. (cid:140)e taint prop-
agation rules and the soundness and precision of them are veri(cid:128)ed
by Lok et al. here [43].
When the taint propagation has been done, we continue to ex-
ecute (emulate) the instruction. If the instruction just executed is
part of the tainted memory then we also taint the output of the
instruction. We do this because some malware generates dynami-
cally generated code without the code explicitly originating from
its own memory. It is for example possible for malware to read
benign code and modify this to suit its own needs and our running
example of the Gapz malware employs this type of behaviour.
3.7 Comparison to previous work
(cid:140)e de(cid:128)nition of malware execution trace given in De(cid:128)nition 1
allows us to rigorously compare Tartarus to previous works [5, 40].
Algorithm 2: update
Data: Instruction i, taint set T .
Result: Taint set T
1 // Initialisation;
2 T Ð propa❕ate taintpi, T q;
3 inex t Ð exec instrpiq;
4 if irAs P T then
5