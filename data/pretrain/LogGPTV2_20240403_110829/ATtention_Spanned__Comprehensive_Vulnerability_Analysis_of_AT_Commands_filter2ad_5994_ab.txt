They may be provided as unsparse chunks, which need
to be reconstituted according to an instruction XML ﬁle
indicating start sector and number of partition sectors for
each chunk. They may otherwise be provided as sparse
Android data images (SDATs), which are converted into
EXT4 using sdat2img [8]. Sony ﬁlesystem images, in par-
ticular, may be given in SIN format, which are converted
into EXT4 using FlashTool [3].
Android ﬁlesystem partitions contain APK ﬁles, which
we decompile using dex2jar [2] and jd-cli [5] treating the
output as text ﬁles to pull AT commands from. Similarly,
we also decompile JAR ﬁles using jd-cli before extracting
AT commands from them. Any discovered ODEX ﬁles
are ﬁrst disassembled using baksmali [1], after which we
look for AT commands in the assembly output. We then
reconstruct the DEX ﬁle using the assembly output with
smali and decompile it using jadx [4] before looking for
AT commands in the resulting output.
3.2 Building an AT Command Database
After AT commands are extracted from each image, we
develop a script to parse the “AT” matches. This script ap-
plies additional ﬁltering with a more strict regular expres-
sion and uses a scoring heuristic to eliminate commands
that appear to be invalid.
For every command found, we record metadata such as
the vendor, image, and ﬁlename where it was discovered.
Additionally we ﬁnd any parameters to the AT command
and store the unique combinations with the command. To
organize the data, we use MongoDB with a single top-
level document for each vendor. Each vendor has an array
of images, which in turn have Android metadata, includ-
ing, but not limited to, Android version, phone model, and
build ID. Finally, each image has a list of AT commands.
276    27th USENIX Security Symposium
USENIX Association
build.propbuild.propatcmdsAT cmdsLGHTCinit.usbinit.usbSamsungImage1Image2ImageNImageunzipunpackdecryptgrep“AT”AT DBparseﬁlterassign2. Extract3. ImportMfg. SitesPublic Mirrors1. Download/CrawlSpeciﬁcation
Hayes [16, 17]
ITU-T V.250 [35]
ETSI GSM 07.05 [25]
ETSI TS 100 916 [26]
Total (unique)
Usage
Basic
SMS
GSM
Application
# of AT Commands
46
61
20
95
222
Table 2: Additional AT commands were manually col-
lected from several speciﬁcation documents, for a total of
222 unique AT commands.
Line 10 will match a read variant, line 12 a set variant with
a non-zero amount of numeric parameters, string param-
eters, and nested AT commands separated by semicolons
(e.g., AT+CMD=1,10,"var";+OTHER=1,2). Line 13 will
match the test variant and ﬁnally line 14 will match an
empty parameter.
Despite this more restrictive regular expression, certain
commands such as AT$L2f, AT+ baT, and AT^tAT com-
monly end up in the AT command database. Upon testing
and visual inspection, we deﬁne commands of this appear-
ance to be spurious matches. These false positive matches
polluted our analytics and cause a large increase in unique
commands, which in turn slows down our testing. By
observing the make-up of these invalid commands, we
developed a simple heuristic to score commands based
off of three features: the command length, the character
classes present, and the valid to invalid command ratio of
the ﬁle in which it was discovered. For more details on
this heuristic visit Section A.2.
In summary, the regular expression helped us discard
33.2% of all 1,392,871 processed lines across all images.
The heuristic eliminated an additional 2.4% of all pro-
cessed lines and brought the total unique AT command
count down from 4,654 to 3,500, a 24.8% reduction. With
less invalid commands matched, the signal to noise ratio
of database increased and our AT command testing was
faster.
Generating a DB Once we have ﬁltered and stored
every AT command along with any found parameters,
we generate plain-text DB ﬁles for input into our test-
ing framework. We create DB ﬁles containing ev-
ery unique command and parameter and vendor-speciﬁc
ATDB ﬁles. These give us different test proﬁles for phone
testing. In addition, we also manually collect AT com-
mands from multiple speciﬁcations, as shown in Table 2.
Many of these commands are not extended AT commands
(AT[symbol]) and would not be matched during our ﬁl-
tering step. Also, these AT commands may not be found
inside the Android ﬁrmware, but should be supported by
baseband processors meeting the public speciﬁcations.
Thus, we include these in our database.
Figure 3: A colorized representation of AT command syn-
tax.
# be a l e t t e r or n u m b e r
# C a p t u r e the m a t c h
# M a t c h AT [ s y m b o l ]
\?
|
AT [! @ # $ % ^ & * + ]
[ _A - Za - z0 -9]{3 ,} # M a t c h the name and
1 (?:[^ a - zA - Z0 -9]|^) # Left of the AT must NOT
2
3
4 (? P 
5
6
7 )
8
9 (? P 
10
11
12
13
14
15 ) ?
# Match AT + TEST =?
# Match a blank p a r a m e t e r
# Match AT + EXEC
=[ " ’+=;% ,? A - Za - z0 -9]+ |
=\? |
=
# C a p t u r e the m a t c h
# M a t c h AT + READ ?
# M a t c h AT + CSET =0 ,1 ," p a r a m "
Figure 4: The regular expression developed to match ex-
tended AT commands. The regular expression syntax is
from Python. All white space is ignored. Note that the
regex is matching both text ﬁles and binary data.
Filtering Lines containing AT commands as discovered
using strings and grep are what we call coarse-grained
matches. This means any matching lines may be invalid
or spurious. We deﬁne an invalid match to mean not con-
forming to the expected patterns of an AT command. Fig-
ure 3 shows the syntax of an AT command, with different
colors describing the modem attention string, command
delimiter, command name, and parameter string. It also
shows the four primary uses of AT commands: executing
an action, reading from a parameter, testing for allowed
parameters, and setting a parameter.
In practice, what
these types actually do is left up to the implementation.
Regardless, these four types are the standard syntax pat-
terns we aim to match.
To capture these four types, we develop a regular ex-
pression as shown in Figure 4 to match their syntax. Line
1 of the RE will ignore any matches that are not at the
beginning of the matched line and have a letter or num-
ber immediately to the left of the “AT” directive. Line
4-7 will capture and match the AT directive, the extended
command namespace symbol, and the command name,
which must be greater than or equal to three characters
and only contain letters, numbers and underscores. Lines
9-15 will capture any optional argument to the command.
USENIX Association
27th USENIX Security Symposium    277
AT + EXECAT + READ ?AT + TEST =?AT + CSET =0,1,“param”ModemAttentionExtended CommandNamespace (+, %, …)CommandNameOptional Parameters3.3 AT Command Testing Framework
After all command databases have been built, we are able
to send AT commands to phones with an exposed AT in-
terface. To achieve this, we developed a Python script run-
ning on Ubuntu 16.04 that uses PySerial to interact with
the phones. When a phone that exposes an AT interface is
plugged in, the Linux kernel will read its USB conﬁgura-
tion descriptor and load any necessary drivers. To Linux,
the modem interface appears as a Communication De-
vice Class (CDC) Abstract Control Model (ACM), which
causes the usbserial driver to be loaded. This driver
creates one or more /dev/ttyACM device nodes. PySe-
rial opens and interacts with these device nodes directly
and sets parameters such as the baud rate and bitwidth. In
practice, we were able to communicate with all modems
using a 115200 baud, 8-bit, no parity, 1 stop bit scheme.
For some manufacturers, the USB modem interface is
not included in the default USB conﬁguration.
In this
case, there may be a second hidden conﬁguration than can
be dynamically switched to using libusb directly. We
use a public tool called usbswitch [47] to select the alter-
native USB conﬁguration, enabling communication over
the modem interface. Once a modem is exposed, we send
a command, wait for a response or a timeout, and log both
sides of the conversation for future review. This logging
is crucial for understanding what unknown commands are
doing to a phone under test.
During our preliminary testing, we discovered com-
mands that reboot, reset, or cause instabilities in the
phone. We thus blacklist certain commands to allow
our framework to continue without human intervention.
These blacklisted commands are returned to for further
manual inspection. For suspicious commands, we man-
ually rerun them on the target phone couple of times to
narrow down on the exact functionality and behavior.
4 AT Command Analysis
To understand the prevalence and security impact of
AT commands on the Android ecosystem, we perform
ﬁrmware analysis and runtime vulnerability analysis, and
we launch attacks. In the ﬁrmware analysis, we ﬁrst ex-
amine the entire corpus of AT commands extracted from
ﬁrmware to discover trends in their occurrence across ven-
dors and Android versions. Our goal is to gain insight
into the general usage of AT commands from within the
Android ecosystem. We then take a closer look into the
native binaries and applications that contain the most AT
commands per vendor. This information advises which
binaries to put into IDA for further analysis. We also in-
spect the USB conﬁguration ﬁles inside these images and
provide an estimate of how many images may potentially
expose the USB modem interface.
In the runtime vulnerability analysis, we ﬁrst look at
14 Android devices to conﬁrm their exposure of a USB
modem interface. We launch our AT command testing
framework on 8 different Android devices that do expose
such an interface and collect command information based
on both response and observable effects on the physical
devices during our testing. We categorize these com-
mands and further show their security impact. We lever-
age the knowledge gained of AT commands from runtime
and IDA analysis to create new attacks using AT com-
mands, and we verify these attacks on off-the-shelf An-
droid phones.
4.1 Firmware Analysis
Distribution of AT Commands Across Vendors. We
look at the number of unique AT commands across se-
lect vendors, namely Google, Samsung, and LG. As
the base of all other Android variants, AOSP (Android
Open Source Project) keeps the number of AT commands
contained inside the factory images around 70 on aver-
age. Figure 5a shows the distribution of these commands
across AOSP ﬁrmwares. The average amount of AT com-
mands is fewer than 100 across all versions, and is under
75 starting from version 4.3. Version 4.2 has the largest
variance across different images. We correlate this with
the wide product line support of the Nexus series, which
later became the Pixel phone series.
New AT commands are constantly added into stock
ROMs due to vendor-speciﬁc customizations. Figure 5b
presents the number of AT commands found in Samsung
Android images. Our results show that the number of AT
commands generally increases across different versions
before Android 5.0. Although the average number stays
fairly stable after version 5.0, it is still above 400. This
means that given an image, Samsung has at least 300 addi-
tional AT commands compared to its AOSP counterpart.
This trend is even more apparent for LG, with the num-
ber of AT commands increasing monotonically as the An-
droid version grows, as shown in Figure 5c. The average
number of AT commands within LG Android version 7.0
images is over 375.
AT Command Top 10. Table 13 in the Appendix shows
the frequency of each of the top 10 most frequent AT com-
mands overall and per different major vendor. All of the
top 10 from the aggregation are standard GSM AT com-
mands, which manage modems and calls. Similarly, all
of the most frequent commands found in AOSP images
are also GSM-related.
In contrast, 3 non-standard AT
commands (“AT+DEVCONFINFO”3, “AT+PROF”4, and
“AT+SYNCML”5) are among the most common ones in
3Get the device conﬁguration information.
4Retrieve information, such as “AT+PROF=“Phonebook””.
5Synchronization Markup Language support for device syncing.
278    27th USENIX Security Symposium
USENIX Association
(a) ATcmd Distribution of Google.
(b) ATcmd Distribution of Samsung.
(c) ATcmd Distribution of LG.
Figure 5: AT Command distribution across three major Android smartphone manufacturers.
Google
/vendor/lib/libsec-ril lte.so
/lib/libxgold-ril.so
/lib/libreference-ril.so
/lib/hw/bluetooth.default.so
/lib/bluez-plugin/audio.so
Samsung
/bin/at distributor
/md1rom.img
/app/FactoryTest CAM.apk
/bin/sec atd
/bin/engpc
LG
/bin/atd
/lib/libreference-ril.so
/lib/hw/bluetooth.default.so
/app/LGATCMDService/arm/LGATCMDService.odex
/app/LGBluetooth4/arm/LGBluetooth4.odex
ATcmd#
183
73
37
23
19
331
226
145
142
140
354
37
27
19
15
Table 3: Top 5 binaries which contain the most AT com-
mands per Google, Samsung, and LG.
Samsung images besides the 7 GSM-related commands.
Surprisingly, 8 of the top 10 AT commands in LG are
non-standard (preﬁxed by “AT%”). Further investigation
shows them all to be vendor-speciﬁc. We extend our in-
spection to the top 20 AT commands and ﬁnd the trend to
be the same – the most frequent AT commands are stan-
dard for Google, a combination of standard and home-
made for Samsung, and mainly vendor-speciﬁc for LG.
AT Command Usage Per Binary. To see where these AT
commands come from, we summarize the source of these
commands and show the top 5 binaries that contribute the
most commands for Google, Samsung, and LG. As shown
in Table 3, most of the AT commands come from the RIL
in Google. Note that some Bluetooth modules also con-
tain AT commands. For Samsung, besides the modem im-
age (md1rom.img), we could ﬁnd Samsung-speciﬁc na-
tive daemons, such as at distributor. A factory test-
ing app is also listed. For LG, atd seems to be the sole
native daemon, taking care of the most AT commands.
Two LG-speciﬁc apps also appear to serve some AT com-
mands.
To gain deeper insight into how AT commands can
affect these systems, we analyzed the ﬂow of AT com-
mands starting from the gadget serial TTY device (usu-
ally /dev/ttyGS0) to any native daemons and ﬁnally to
other devices or system applications. We analyzed the LG
G4 and the Samsung S8+ images by reading the relevant
USB init scripts and any native daemons using IDA Pro
7.0. We paired this with manual testing using the AT in-
terface while monitoring the system with logcat.
Samsung S8+. Samsung’s heavy use of AT com-
mands was conﬁrmed through analysis of four key na-
tive daemons: ddexe, at distributor, smdexe, and
port-bridge. The “Data Distributor” ddexe opens the
primary /dev/ttyGS0 device, monitors USB for state
changes, creates a UNIX domain socket server, and routes
TTY data to clients.
at distributor connects via
UNIX socket (/data/.socket stream), receives com-
mands, and either handles them itself or dispatches them
to appropriate parts of the system.
As a result of previous work (CVE-2016-4030, CVE-
2016-4031, and CVE-2016-4032), Samsung has locked
down the exposed AT interface with a command whitelist.
This whitelist is active when the ro.product ship prop-
erty is set to true and limits the commands to information
gathering only. Any non-whitelisted command responds
with the generic reply of OK, even if it is invalid.
LG G4. LG follows a similar structure to handling AT
commands.
Its primary daemon atd reads and writes
to the gadget serial TTY device and handles or bypasses
AT commands. Some commands are handled by a static
dispatch table within atd and may propagate throughout
the system via UNIX domain socket /dev/socket/atd.
LGATCMDService is an Android background service that
listens for and handles any incoming commands before
sending back a response. At least 89 different commands
USENIX Association
27th USENIX Security Symposium    279
2.34.04.14.24.34.45.05.16.07.07.1Android Version5075100125150175200225ATcmd#Google2.22.34.04.14.24.34.45.05.16.07.07.1Android Version100200300400500600ATcmd#Samsung4.45.05.16.07.0Android Version200225250275300325350375ATcmd#LGVendor
ASUS
Google
HTC
Huawei
Lenovo
LG
LineageOS
Motorola
Samsung
Sony
ZTE
Total