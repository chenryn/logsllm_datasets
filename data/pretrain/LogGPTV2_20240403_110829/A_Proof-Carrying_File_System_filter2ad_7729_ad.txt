system. In order to bypass any access checks during the call to the ext3 ﬁle system, the
process server runs with superuser privileges. To prevent users from directly using the
ext3 ﬁle system to access data, we give ownership of the root directory on the ext3 ﬁle
system to the superuser, and turn oﬀ all access on it.2
Organization of the ﬁle system. For the purpose of illustration let us assume that
PCFS is mounted at /pcfs, and that it makes calls to the ext3 ﬁle system at /src. Then
/pcfs mirrors the ﬁle system structure rooted at /src, except that all calls within the
former are subject to procap based checks. A special directory /pcfs/#config contains
conﬁguration data for the ﬁle system, including procaps and the secret key used to
sign them. This directory is protected by the ﬁle system with strict rules that do not
use procaps. We list below some of the important ﬁles and directories in this special
directory, as well their contents and protections.
/pcfs/#config/config-file: File containing conﬁguration options, including
the user ids of the principals admin and pcfssystem. (Recall from Section 4 that
pcfssystem is the only user who has access to the secret key needed to sign procaps.)
Anyone can read this ﬁle, but only pcfssystem can change this ﬁle.
/pcfs/#config/shared-key: Contains the shared key used to sign procaps. Only
pcfssystem may read or write this ﬁle.
/pcfs/#config/ca-pubkey.pem: Contains the public key of the certifying author-
ity who signs associations between other public keys and users. Anyone may read
this ﬁle, but only pcfssystem may write to it.
2A more secure method to prevent access via the underlying ﬁle system is to keep data encrypted on
it, and to decrypt data in our process server. We have not implemented this design, since our objective
here is to evaluate the performance of access checks.
16
/pcfs/#config/procaps/: This directory contains the procaps. Its organization
is discussed next. pcfssystem has full access to this directory, and other users have
access to speciﬁc subdirectories only.
The procap giving the right (cid:104)k, f, η(cid:105), subject to access-time conditions as discussed
before, is stored in the ﬁle /pcfs/#config/procaps//.perm.. Here  is
the user id of the user k,  is the path of the ﬁle f (relative to the mount point),
and  is a textual representation of the permission. Thus each procap is stored in a
separate ﬁle, and further for each right (cid:104)k, f, η(cid:105), there can be at most one procap that
authorizes the right. While this may be restrictive, it makes look up extremely easy since
the exact path where a procap is to be found can be determined simply by knowing the
PCFS mount point and the right (cid:104)k, f, η(cid:105). To prevent denial of service attacks and to
protect user privacy, the PCFS server ensures that only user k can access (read, write,
or delete) ﬁles inside /pcfs/#config/procaps//.
Since pcfssystem has full access to all ﬁles and directories within /pcfs/#config/,
it is a very attractive target for attack. In particular, if an attacker gains control of
this user account, it can change the secret key used to sign and verify procaps, and
then inject fake procaps to access other ﬁles. To prevent this, the PCFS process server
denies pcfssystem all rights in other directories within the ﬁle system. Thus, to attack
PCFS through this mechanism, the attacker must break into at least one more account
in addition to pcfssystem.
Procap Cache. Since procaps are stored in ﬁles, and one or more of them must
be read for every ﬁle system operation, it is helpful to cache commonly used procaps
in memory to improve performance. To this end, PCFS uses a least recently used
(LRU) in-memory cache, whose size can be adjusted at mount time. The cache stores
parsed procaps, whose signatures have already been veriﬁed. The only cost involved in
using a cached procap is checking its conditions (lists (cid:126)C and (cid:126)i from Section 4). This is
extremely fast and usually takes only 10–100µs. As a result, PCFS obtains extremely
high performance when the number of ﬁles in use is small. We evaluate the eﬀect of the
cache in Section 6.
Permissions. PCFS uses ﬁve distinct permissions on any ﬁle or directory: read, write,
execute, identity, and govern. (In contrast, POSIX mandates only the ﬁrst three permis-
sions.) Permissions read and write are the obvious ones; they are needed to read and to
change the contents of a ﬁle/directory respectively. As usual, execute is the permission
to read the meta data of a ﬁle or directory. Permission identity is needed to delete a ﬁle
or directory, or to rename it. This permission is separated from others because in many
settings, administrators may not want to allow users to delete or rename shared ﬁles,
but perform other operations on them (and their parent directories). The govern permis-
sion is needed to change the owner of a ﬁle and to change extended attributes starting
with the preﬁx user.#pcfs. Because of this special protection, these attributes can be
used by administrators to give classiﬁcation or security labels to ﬁles, as in Example 1.
Figure 3 lists the permissions needed to perform some common ﬁle system operations.
During a ﬁle system call, procaps corresponding to the relevant entry in this table are
looked up and checked. By separating the identity and govern permissions from write, we
allow for the possibility of easily administering both mandatory and discretionary access
17
Permissions needed
Operation
execute on /foo
stat /foo
open /foo in read mode
read on /foo
open /foo in write mode write on /foo
create /bar/foo
write on /bar
delete /bar/foo
identity on /bar/foo
identity on /bar, write on /foo
rename /bar to /foo
execute on /foo
getxattr on /foo
setxattr on /foo
govern on /foo if attribute starts with
user.#pcfs., write otherwise
govern on /foo
chown on /foo
Figure 3: Permissions needed to perform some operations
control in PCFS. This is diﬃcult with POSIX permissions, where the owner always has
all permissions on a ﬁle.
Default Permissions. When a program ﬁrst creates a ﬁle, it cannot be assumed
that any policy rules apply to it, since that (usually) requires creation of certiﬁcates by
administrators. Yet, many programs create temporary ﬁles, to which they must have
access in order to complete their tasks. To allow such programs to execute correctly,
when a new ﬁle or directory is created, PCFS automatically creates and stores default
procaps that give the creator of the ﬁle read, write, execute, and identity permissions for
a ﬁxed period of time (this period can be adjusted at mount time). In addition the user
admin is given execute and govern rights on the new ﬁle. After this period elapses, the
default procaps expire and the administrators must create policy rules to control access
to the ﬁle.
6 Evaluation
We evaluate PCFS in two ways. First, we report the results of performance benchmarks
on the backend of the ﬁle system. Second, we comment on the expressiveness of the
framework through two case studies.
6.1 Performance of the Backend
Since we are primarily interested in measuring the overhead of access control checks
due to procaps, our baseline for comparing performance is a Fuse-based ﬁle system
that does not perform the corresponding checks, but is otherwise running a process
server and using an underlying ext3 ﬁle system, just as PCFS does. We call this ﬁle
system Fuse/Null. For macrobenchmarks we also compare with an ext3 ﬁle system. All
measurements reported here were made on a 2.4GHz Core Duo 2 machine with 3GB
RAM and a 7200RPM 100GB hard disk drive, running the Linux kernel 2.6.24-23.
Read and write throughput. By default, PCFS does not make any access checks
when read or write operations are performed on a previously opened ﬁle. Instead access
18
checks are made when the ﬁle is opened. As a result its read and write throughput
is very close to that of Fuse/Null. The following table summarizes the read and write
throughputs of PCFS and Fuse/Null based on reading and writing a 1GB ﬁle sequentially
using the Bonnie++ test suite [1].
Operation PCFS (MB/s) Fuse/Null (MB/s)
Read
Write
538.69
73.18
567.47
76.05
It is possible, through a mount time option, to force PCFS to check procaps that au-
thorize read and write access during read and write operations respectively. As long as
the procaps checked are cached in memory, this does not aﬀect performance at all since
the time taken to check a cached procap is only a few microseconds.
File stats. Besides read and write, two other very common ﬁle operations are open
and stat (reading a ﬁle’s meta data). In terms of access checks, both are similar, since
usually one procap must be checked in each case.3 The table below shows the speed of the
stat operation in PCFS with diﬀerent hit rates in the procap cache. All measurements
are reported in number of operations per second, as well as time taken per operation.
The title n% indicates a measurement with a cache hit rate of n%. For comparison,
performance of Fuse/Null is also shown. The ﬁgures are based on choosing a random
ﬁle 20,000 times in a directory containing exactly 20,000 ﬁles, and stating it. To get a
hit rate of n%, the cache size is set to n/100 × 20000, and the cache is warmed a priori
with random procaps. It is easy to prove that for an LRU cache this results in a hit
rate of exactly n% when subsequent ﬁles (procaps) are also chosen at random.
Cache hit rate → 0%
Stats per second
5774
173.2
Time per stat (µs)
50% 90% 95% 98% 100% Fuse/Null
7186
139.2
11879
84.2
23652
42.2
8871
112.7
9851
101.5
36042
27.7
As can be seen from this table, the procap cache is extremely helpful in attaining
eﬃciency. The diﬀerence of the times in the last two columns is an estimate of the time
it takes to check a cached procap (i.e., the time needed to check the conditions in a
procap). In this case, this time is 42.2 − 27.7 = 14.5µs. This estimate is rough, and the
actual time varies with the complexity of the conditions in the procap. The procaps used
here are default ones. In other experiments, we have found that this time varies from 10
to 100µs. By taking the diﬀerence of the times in ﬁrst and last columns, we obtain an
estimate of the time required to read a procap, check its signature, parse the procap, and
check its conditions. In this experiment, this time is 173.2− 27.7 = 145.5µs. Additional
time may be needed to seek to the procap on disk, which is not counted here. This
suggests that, in general, procap checking is dominated by reading and parsing times.
The signatures we use for procaps are message authentication codes or MACs, which
can be veriﬁed in 1 to 2µs.
3Two procaps must be checked when a ﬁle is opened in read and write modes simultaneously.
19
File creation and deletion. The table below lists the number of create and delete
operations per second that are supported by PCFS and Fuse/Null. These are measured
by creating and deleting 10,000 ﬁles in a single directory.
Operation PCFS (op/s) Fuse/Null (op/s)
Create
Delete
1386
1989
4738
15429
PCFS is approximately 3.5 times slower than FUSE/Null in creating ﬁles. This is
because PCFS also creates six default procaps for every ﬁle created. As a result, it
creates seven times as many ﬁles in three separate directories. Deletion in PCFS is
nearly 7.7 times slower than that in Fuse/Null. This is because when a ﬁle is deleted
in PCFS, one procap must be looked up, parsed, and checked, and all procaps related
to the ﬁle must later be deleted. This is done to avoid accumulating useless procaps; it
can be turned oﬀ using a mount time option. In this case, each ﬁle deletion corresponds
to seven ﬁle deletions on the ext3 ﬁle system in three diﬀerent directories. The eﬀect of
the procap cache is negligible during create and delete operations.
In summary, assuming a low rate of cache misses, the performance of PCFS on com-
mon ﬁle operations like read, write, stat, and open is comparable to that of Fuse/Null.
On the other hand, less common operations like create and delete are slower because
default procaps must be managed.
Macrobenchmarks. To understand the performance of PCFS in practice, we also ran
two simple macrobenchmarks. The ﬁrst (called OpenSSL in the table below), untars
the OpenSSL source code, compiles it and deletes it. The other (called Fuse in the table
below), performs similar operations for the source of the fuse kernel module ﬁve times in
sequence. As can be seen, the performance penalty for PCFS as compared to Fuse/Null
is approximately 10% for OpenSSL, and 2.5% for Fuse. The diﬀerence arises because
the OpenSSL benchmark depends more on ﬁle creation and deletion as compared to the
Fuse benchmark.
Benchmark PCFS (s) Fuse/Null (s) Ext3 (s)
OpenSSL
Fuse × 5
126
79
114
77
94
70
6.2 Case Studies
We have also completed two case studies using BL and PCFS. In each case, we expressed
the policy from the case study in BL, and considered whether it could be enforced in
PCFS.
Classiﬁed Information. Our ﬁrst case study formalizes rules for control and dissem-
ination of classiﬁed information among intelligence agencies in the U.S. (Examples 1
and 2 are based on this case study.) The enforcement of these rules was also the origi-
nal motivation for building PCFS. We obtained information on these rules from public
government documents, and through an industrial collaborator. This information was
distilled to 35 formulas in BL. The study is interesting because it uses almost all fea-
tures of BL. Extended attributes are used to represent the classiﬁcation status of ﬁles
20
(classiﬁed vs unclassiﬁed), and their classiﬁcation level as in Example 1. Attributes of
individuals are speciﬁed in certiﬁcates issued by administrators, many of which expire at
ﬁxed points of time. For example, some background checks expire every 5 years. These
expirations are represented using the @ connective in BL. Also, one of the rules requires
arithmetic over time – the owner of an unclassiﬁed ﬁle can access it for 90 days after its
creation. (BL supports linear arithmetic over time, but we have not discussed it in this
paper.)
Some of the proofs needed for access in this study are quite large; they contain as
many as 1100 proof steps, and depend on 70 certiﬁcates. It takes nearly 100ms to verify
these proofs. This strongly supports the case for performing proof veriﬁcation ahead of
access and using capabilities, as PCFS does. If such proof veriﬁcations were performed
during ﬁle access, the ﬁle system interface would be limited to less that 10 operations a
second.
In our second case study we formalize the rules for con-
Course administration.
trolling permissions on directories for storing class materials and assignments, based on
current workﬂows at our university. Although these rules are much simpler than those
in the previous study, we had to add support for a new kind of interpreted predicate:
member(f, d), which means that ﬁle f is contained in directory d. This eﬀort gave us
an idea about the diﬃculty involved in extending PCFS (and BL) with new interpreted
predicates. In all, it took us less than 10 minutes of programming eﬀort to add support
for this new predicate. (All parsers in our implementation already support parsing of
unknown predicates, so we only had to deﬁne a procedure for verifying the predicate.)