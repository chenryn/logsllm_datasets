title:Reducing Refresh Power in Mobile Devices with Morphable ECC
author:Chia-Chen Chou and
Prashant J. Nair and
Moinuddin K. Qureshi
2015 45th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
2015 45th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
Reducing Refresh Power in Mobile Devices with
Morphable ECC
Chiachen Chou
Prashant Nair
Moinuddin K. Qureshi
School of Electrical and Computer Engineering
Georgia Institute of Technology
Altanta GA,USA
{cc.chou, pnair6, moin}@ece.gatech.edu
Abstract—Energy consumption is a primary consideration
that determines the usability of emerging mobile computing
devices such as smartphones. Refresh operations for main mem-
ory account for a signiﬁcant fraction of the overall energy
consumption, especially during idle periods, when processor can
be switched off quickly; however, memory contents continue to
get refreshed to avoid data loss. Given that mobile devices are
idle most of the times, reducing refresh power in idle mode is
critical to maximize the duration for which the device remains
usable. The frequency of refresh operations in memory can be
reduced signiﬁcantly by using strong multi-bit error correction
codes (ECC). Unfortunately, strong ECC codes incur high latency,
which causes signiﬁcant performance degradation (as high as
21%, and on average 10%).
To obtain both low refresh power in idle periods and high
performance in active periods, this paper proposes Morphable
ECC (MECC). During idle periods, MECC keeps the memory
protected with 6-bit ECC (ECC-6) and employs a refresh period
of 1 second, instead of the typical refresh period of 64ms. During
active operation, MECC reduces the refresh interval to 64ms, and
converts memory from ECC-6 to weaker ECC (single-bit error
correction) on a demand-basis, thus avoiding the high latency of
ECC-6, except for the ﬁrst access during the active mode. Our
proposal reduces refresh operations during idle mode by 16x,
memory power in idle mode by 2X, while retaining performance
within 2% of a system that does not use any ECC.
Keywords—Mobile DRAM, DRAM Refresh Rate, Mobile Mem-
ory System, Error Correction Code, DRAM Power Consumption,
Memory Reliability
I.
INTRODUCTION
The past few years has seen a paradigm shift in computing
platforms. Emerging handheld devices such as Smartphones
and Tablets have become one of the most common devices for
computing in everyday use. Energy consumption is one of the
prime considerations that inﬂuence the development of mobile
hand-held devices, as it determines the duration for which the
device remains usable on battery power [1][2]. The usage pat-
terns for devices such as smartphones are quite different from
traditional computing devices such as workstations. These
devices are used in short bursts of few minutes, over extended
period of time, as shown in Figure 1. Recent studies [3] have
indicated that the idle periods account for 90%-95% for these
devices. Therefore, reducing the energy consumption during
idle mode of operation has become vital. However, users
expect these devices to provide instant response when they
are activated; it is also important to retain the application state
at the point where it was last used in order to reduce system
wake-up time.
Active Mode
Active Power
Background Power (w/o Refresh)
Refresh Power
1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
r
e
w
o
P
d
e
z
i
l
a
m
r
o
N
Idle Mode
Idle Mode
Idle Mode
time
Fig. 1.
The typical usage pattern of handheld devices is bursty with long
idle periods. During active mode memory consumes 9x more power than idle
mode. The contribution of refresh to overall power is small during active
mode, but signiﬁcant only during the idle periods.
One of the main sources of energy consumption during
idle periods is the main memory system [1, 4], which takes up
to 30% of the energy. The main memory system is typically
made of Dynamic Random-Access Memory (DRAM) devices,
which requires periodic refresh operations to retain data. When
the mobile device becomes idle, the processor can be switched
off in less than one millisecond [5] and the memory is put into
self refresh mode, where an internal circuitry performs refresh
operations. Thus, the memory continues to consume power
for retaining data even during idle mode and this is one of
the signiﬁcant source of idle power consumption that needs to
be reduced. One option is to restore the memory contents into
non-volatile storage (i.e., ﬂash or external SD card). This may
be feasible in systems where the memory capacity is small
and storage bandwidth is high. However, the memory capacity
on current smartphones is already in the 3GB range [6]. The
bandwidth on Flash storage in mobile devices is in the regime
of 32MB-64MB per second, which means saving and restoring
state of memory from storage would incur several seconds of
delay [7], resulting in large response time and degrading user
experience. Therefore, platforms such as Android try to retain
the state of recently accessed apps in the main memory to
reduce application loading times [8].
The refresh power of memory can be reduced by exploiting
the variability in retention times of DRAM cells. By using
978-1-4799-8629-3/15 $31.00 © 2015 IEEE
978-1-4799-8629-3/15 $31.00 © 2015 IEEE
DOI 10.1109/DSN.2015.33
DOI 10.1109/DSN.2015.33
355
355
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:13:39 UTC from IEEE Xplore.  Restrictions apply. 
multi-bit Error Correction Code (ECC), one can correct the few
bits that fail with slower refresh operations [5]. Our analysis
shows that correcting for up to six bits of errors per line (ECC-
6) can allow the system to reliably reduce the refresh interval
from 64ms to 1 second. Unfortunately, such multi-bit error
correction incurs several tens of cycles of delay for decoding
operations, which increases the memory latency and reduces
system performance. We found that for our baseline system,
the latency overhead of ECC-6 degrades performance by as
much as 21%, and on average by 10%. Ideally we want to
retain high performance of weak ECC (e.g., SECDED or No
ECC) and the refresh power savings of ECC-6.
To obtain high performance of weak-ECC codes and the
refresh saving of strong-ECC codes, this paper proposes Mor-
phable ECC (MECC). MECC is based on two key observa-
tions. First, the idle periods in mobile devices are long, in the
range of several minutes. Second, the contribution of refresh
power to overall memory power is small during active mode
and signiﬁcant during idle mode. Therefore, we can have the
best of both worlds by trying to optimize refresh power only
during idle mode (using strong ECC code) and optimize for
performance during active mode (using weak ECC code).
MECC appends each line with ECC-mode bits, which
indicates whether the line uses strong-ECC or weak-ECC code.
When the system becomes idle, MECC ensures that the entire
memory uses ECC-6, and reduces the refresh rate by 16x to 1
second. Thus, the refresh power and the memory idle power
are reduced signiﬁcantly. When the system becomes active,
and a line is accessed from memory, ECC-status is checked.
Given that for the ﬁrst access, the line would have ECC-6, it
is decoded with ECC-6 decoder and written back with weak-
ECC. We refer to this conversion form strong-ECC to weak-
ECC as an ECC-Downgrade. All subsequent access to the line
in the active period is decoded with the weak-ECC decoder,
which has much lower latency, and avoids the performance
degradation of the strong-ECC. Thus, with Morphable ECC,
the system pays the latency overhead of strong-ECC only on
the ﬁrst access, but not the subsequent access. When the active
mode ﬁnishes, the system becomes idle, MECC converts the
line to ECC-6 and marks the ECC-mode bits associated with
lines as such. We refer to this conversion from weak-ECC to
strong-ECC as an ECC-Upgrade.
MECC is a purely hardware proposal that does not require
changes to the source code and does not compromise appli-
cation reliability for power saving [7]. Our evaluations with
28 applications shows that MECC reduces refresh operation in
idle mode by 16x, while providing a performance that is within
2% of a system that does not incur any latency overhead from
error correction.
On entering idle mode, MECC tries to convert all the lines
in memory to ECC-6. This may be wasteful if majority of
the lines in memory were not accessed since the last idle
period, and therefore were already equipped with ECC-6. To
avoid such wasteful conversions, we propose a simple Mem-
ory Downgrade Tracking (MDT) scheme that tracks memory
regions that have been downgraded from ECC-6. When the
system goes to idle mode, only the memory regions indicated
by MDT are converted to ECC-6. We found that a simple MDT
with 128 bytes storage reduces the system upgrade latency
from approximately 400ms to 50 ms.
When a mobile device is not used, it may still get fre-
quently invoked by periodic operations such as interrupts
interrupts from I/O, network devices, bluetooth signal check
etc. Fortunately, such periodic operations tend to be quite
short (few milli seconds) and are typically not bounded by
memory peformance. Such periodic system activity willl incur
transitions of ECC-Downgrade and ECC-Upgrade frequently,
which may ruin the beneﬁts of MECC. To avoid this, we
propose Selective Memory Downgrade (SMD) which can avoid
the transitions between ECC-6 and ECC-1 for such processes.
SMD periodically checks the memory trafﬁc and starts ECC-
Downgrade only if the application has memory trafﬁc above
a certain threshold. We found that for minor degradation in
performance (< 2%), this extension of MECC does not enable
ECC-Downgrade in active mode for 7 out of 28 applications,
and all of these 7 applications have small memory footprint
and their performance is not sensitive to memory latency.
II. BACKGROUND AND MOTIVATION
is the main memory system that
Ideally users want the mobile devices to be energy pro-
portional, in that they consume power when used and do not
consume any power when idle. This is especially important
given that these devices are idle most of the time. One of
the major components that make mobile devices non-energy-
proportional
is made of
DRAM. DRAM relies on periodic refresh of data to maintain
data integrity. Even when the device is idle, refresh operations
are done to maintain the contents of main memory. The
energy overheads associated with refresh is proportional to
the capacity of the main memory system, as all lines must
be refreshed in a given time period. To enable mobile devices
to execute a large variety of applications and to reduce the load
times of applications, the memory capacity of smartphone is on
the rise. While the ﬁrst generation smartphones had 128MB-
256MB of DRAM, current smartphones (such as Samsung
Galaxy Note 3 [6]) already have 3GB of DRAM, and the next
generation devices are expected to have 4GB DRAM [9]. Thus,
the power consumption due to memory refresh is only going
to increase for future mobile platforms.
In this section, we ﬁrst discuss the various modes of doing
refresh in DRAM systems, then we explore the trade-off of
DRAM cell failure versus refresh rate, next we describe the
usage of strong Error Correction Codes (ECC) to mitigate the
failures due to refresh, and ﬁnally discuss the shortcomings of
always using strong ECC.
A. DRAM Refresh Modes
Refresh operations are performed by simply activating and
precharging the particular row. JEDEC speciﬁcation dictates
that the contents of the DRAM device must be refreshed every
64ms to maintain data integrity. Existing standards provide
several implementations to perform refresh in DRAM systems,
each geared for different system requirements. We describe the
refresh implementations below.
1)
Auto Refresh (AR). This is the typical mode of
refresh, where the memory controller sends a refresh
pulse every 64ms (burst mode) or 7.8μs (distributed
mode) to the DRAM device. In DRAM devices, there
356356
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:13:39 UTC from IEEE Xplore.  Restrictions apply. 
2)
3)
4)
is an internal register to keep track of the address of
the row(s) to be refreshed.
Self Refresh (SR). This mode of refresh is employed
in idle periods where the processor and the memory
controller are turned off. The responsibility of gen-
erating periodic refresh pulse is relinquished to the
DRAM device. DRAM array cannot be read while in
self refresh mode.
Partial Array Self Refresh (PASR). A type of self-
refresh mode where only a portion of memory is re-
freshed (other contents get lost). Thus, PASR reduces
the useful capacity of DRAM memory system.
Deep Power Down (DPD). An ultra low-power mode
where DRAM is not refreshed. The contents of
DRAM cells are lost. Before coming out of the Deep
Power Down mode, the DRAM cells are initialized.
Ideally we want to use the main memory capacity for
maintaining the working set of active applications, and to retain
the recently/frequently used applications in memory in order
to reduce the application loading time. Therefore, we want
the power savings close to PASR or DPD, and yet have a
usable capacity of Auto/Self Refresh. We can obtain the dual
goals of power savings and useful memory capacity if we
can signiﬁcantly reduce the refresh rate in Self Refresh Mode
without compromising data integrity.
B. Increasing DRAM Refresh Period
The time for which a DRAM cells retains its data is called
the retention time, which is typically 64ms speciﬁed by JEDEC
standards. This rate is determined such that even the weakest
bit in the memory array can get refreshed in time. Thus, the
refresh rate is inherently determined by the retention charac-
teristics of the weakest cell. On average, DRAM cells have a
retention time in the range of few (tens of) seconds. However,
there is variability in retention time which causes a few weak
bits in the DRAM array to determine the memory retention
time. There are several device level studies that characterize
the retention time of the DRAM cells. Figure 2 shows the bit
failure probability for DRAM cells as the retention time is
changed (data derived from [10]).
y
t
i
l
i
b
a
b
o
r
P
e
r
u
l
i
a
F
e
v
i
t
a
l
u
m
u
C
0
10
−1
10
−2
10
−3
10
−4
10
−5
10
−6
10
−7
10
−8
10
−9
10
−2
10
−1