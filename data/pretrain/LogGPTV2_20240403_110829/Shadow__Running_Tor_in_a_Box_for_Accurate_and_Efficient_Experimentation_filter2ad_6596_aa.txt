title:Shadow: Running Tor in a Box for Accurate and Efficient Experimentation
author:Rob Jansen and
Nicholas Hopper
Shadow: Running Tor in a Box for Accurate and Efﬁcient Experimentation
Rob Jansen∗
U.S. Naval Research Laboratory
PI:EMAIL
Abstract
Tor is a large and popular overlay network providing
both anonymity to its users and a platform for anonymous
communication research. New design proposals and at-
tacks on the system are challenging to test in the live net-
work because of deployment issues and the risk of invading
users’ privacy, while alternative Tor experimentation tech-
niques are limited in scale, are inaccurate, or create results
that are difﬁcult to reproduce or verify. We present the de-
sign and implementation of Shadow, an architecture for ef-
ﬁciently running accurate Tor experiments on a single ma-
chine. We validate Shadow’s accuracy with a private Tor
deployment on PlanetLab and a comparison to live network
performance statistics. To demonstrate Shadow’s powerful
capabilities, we investigate circuit scheduling and ﬁnd that
the EWMA circuit scheduler reduces aggregate client per-
formance under certain loads when deployed to the entire
Tor network. Our software runs without root privileges, is
open source, and is publicly available for download.
1
Introduction
[8]
Tor
is the most popular application providing
anonymity for privacy-conscious Internet users. To achieve
anonymity for its clients, Tor forwards communication be-
tween sources and destinations through a tunneled circuit
of several volunteer relays located around the world. Data
is encrypted using Onion Routing [11, 37] so that no single
relay in the circuit can learn both the true source and the
true destination of any forwarded message.
Tor’s goal
to provide low-latency anonymity for its
clients has led to an enormous amount of research on top-
ics including, but not limited to, anonymity attacks and de-
fenses [3, 9, 13, 24, 32], system design, performance, and
scalability improvements [2, 36, 40, 42, 47], and the eco-
nomics of volunteering relays to the Tor network [1, 15, 28].
Most Tor research – whether implementing a new design
∗Work partially performed at the University of Minnesota and the U.S.
Naval Research Laboratory
Nicholas Hopper
University of Minnesota
PI:EMAIL
approach or analyzing a potential attack – either requires
or would beneﬁt from access to the live Tor network and
the data it generates. However, such access might invade
clients’ privacy or be infeasible to provide – testing a small
design change in the real network requires propagating that
change either to hundreds of thousands of Tor clients or
to thousands of volunteer relays, and in some cases, both.
Therefore researchers often use alternative strategies to ex-
periment and test new research proposals.
Tor Experimentation. One approach for experimenting
with Tor outside of the live public network is to conﬁgure
a parallel private test network deployment [3, 42] either us-
ing machines at a university or a platform such as PlanetLab
[7]. Since live deployments run real software over real hard-
ware, the results are generally accepted. However, Planet-
Lab and other private deployments do not accurately reﬂect
the same network conditions of the public Tor network, are
difﬁcult to manage, and do not scale well – PlanetLab has
only around one thousand nodes of which roughly half are
usable at any time. Therefore researchers often experiment
through simulation [15, 25, 28, 33]. Simulating particular
Tor mechanisms may increase scalability, but also harms
accuracy: the Tor software and protocols are continuously
updated by several Tor developers, causing simulators to be-
come outdated and unmaintained. Moreover, since simula-
tors tend not to be reused, the results of one group may be
inconsistent with or can not be veriﬁed by other groups.
Tor in a Box. To increase consistency, accuracy, and scala-
bility of Tor experiments, we design and develop a new and
unique simulation architecture called Shadow. Shadow al-
lows us to run a private Tor network on a single machine
while controlling all aspects of an experiment. Results are
repeatable and easily veriﬁable through independent analy-
sis. Although Shadow simulates the network layer, it links
to and runs real Tor software, allowing us to experiment
with new designs by implementing them directly into the
Tor source code. This strategy expedites the process of in-
corporating proposals into Tor since software patches can be
submitted to the developers. Shadow is capable of simulat-
ing a large and diverse private Tor network, requiring little
to no modiﬁcation to the numerous supported Tor software
versions. Shadow’s focus on usability and commitment to
open source software1 improves accessibility and promotes
community adoption.
Shadow is a discrete-event simulator that utilizes tech-
niques allowing it to run real applications in a simulation en-
vironment. Real applications are encapsulated in a plug-in
wrapper that contains functions necessary to allow Shadow
to interact with the application. Although the application is
only loaded into memory once, the plug-in registers mem-
ory addresses for all variable application state and Shadow
manages a copy of these memory regions for each node in
the simulation. Similar to a kernel context switch, Shadow
swaps in the current node’s version of this state before pass-
ing control to the application, and swaps out the state when
control returns. Function interposition allows Shadow to
intercept function calls, e.g. socket and event library calls,
and redirect them to a simulated counterpart. As detailed
in Section 3, we run Tor using these techniques and symbol
table manipulations without modifying the source code.
Accurate Simulation. We validate Shadow’s accuracy
against a 402-node PlanetLab deployment, testing network
performance using HTTP ﬁle transfers both directly and
through a private Tor network deployment. Although pri-
vate Tor networks on PlanetLab do not consistently rep-
resent the live Tor network well, they allow us to test our
ability to model a real, diverse network (i.e. how well we
can “shadow” PlanetLab conditions). We ﬁnd that our re-
sults are within reason although PlanetLab exhibits highly
variable behaviors because of overloaded CPUs caused by
co-location and resource sharing.
To validate Shadow’s ability to accurately and consis-
tently represent the real, live Tor network, we simulate a
1051-node topology with bandwidth and relay characteris-
tics taken from a live Tor network consensus. We model the
Internet using network latency measurments taken between
all PlanetLab nodes. We ﬁnd that client performance in
Shadow closely matches live statistics gathered by the Tor
Project [45], with download time quartiles within 15 percent
of the live statistics for various download sizes. Our results
in Section 5 indicate that Shadow can accurately measure
Tor client performance.
Improving Client Performance. Tor’s popularity has lead
to network congestion and performance problems. Tor’s
hundreds of thousands of clients [20] send data over a few
thousand bandwidth limited relays, causing network bottle-
necks that impair client performance. Using Shadow, we in-
vestigate scheduling as a technique to improve client perfor-
mance. In Section 6 we explore the EWMA circuit sched-
uler [42] which prioritizes bursty circuits ahead of bulk cir-
cuits. We conﬁrm previous results by re-evaluating EWMA
when enabled on small bottleneck topologies consisting of
three relays – similar to those tested by Tang and Goldberg.
1Shadow source code is publicly available under the GPLv3 [38, 39].
However, our results from a network-wide deployment of
the scheduler in a scaled topology indicate that performance
beneﬁts are highly dependent on network load and a prop-
erly tuned half-life. We found that the scheduler reduces
performance for Tor clients under certain network loads, a
signiﬁcant result since the EWMA scheduler is currently
enabled by default for all sufﬁciently updated Tor relays.
2 Requirements
Accuracy. In order to produce results that are consistent
and representative of the live Tor network, Shadow should
run a minimally-modiﬁed version of the native Tor soft-
ware. Running the Tor software in our simulator will en-
sure that Tor’s behavior in our simulated Tor network will
closely represent the behavior of Tor running on a real ma-
chine in the live network.
In addition to running the Tor software, Shadow should
also have accurate models of system-level interactions. Tor
is mostly concerned with buffering, encrypting/decrypting
cells, and sending and receiving large amounts of net-
work trafﬁc with non-blocking I/O. Inaccurate models of
these mechanisms would lead to inaccurate results and mea-
surements of Tor’s behavior. Therefore, we are required
to model the system-level network stack of an operating
system by simulating TCP and UDP, correctly managing
network-level buffers and buffer sizes, and simulating non-
blocking event-driven I/O. Since a large amount of Tor’s
run-time is spent performing cryptography and processing
data, Shadow should avoid execution of expensive cryp-
tographic operations while instead modeling the CPU de-
lays that would have occurred had the cryptography actually
been performed.
Finally, accurate software and an accurate system will
not function correctly without an accurate network. First,
Shadow requires models for network characteristics includ-
ing latency and reliability of network links, complex AS-
level topologies, and upstream/downstream capacities for
end-hosts. Second, Shadow must accurately model the
network characteristics of Tor, including relay-contributed
bandwidth, faithful bandwidth distributions among entry,
middle, and exit relays, and geographical distribution of re-
lays. Shadow must also incorporate network trafﬁc from
Tor clients and model accurate distributions of that trafﬁc
from live Tor trafﬁc patterns.
Usability and Accessibility. A simulator that produces ac-
curate results characteristic of the live Tor network will be
of little use to the community without a usable simulation
framework. Shadow should therefore do the following to
increase usability and promote community adoption.
First, Shadow should be simple to obtain, build, and con-
ﬁgure to allow for rapid deployment. Users should be able
to run a simulation with minimal overhead and little or no
conﬁguration. However, advanced users should be able to
easily modify a simulation, generate new topologies, and
conﬁgure network and system parameters. Simulation re-
sults should be easy to gather and parse to produce visual-
izations that allow the analysis of the network state. Sec-
ond, Shadow should run completely as a user-level process
on a single machine with inexpensive hardware to minimize
overhead costs associated with obtaining, conﬁguring, and
managing multiple machines or clusters. Shadow should
be accessible to anyone worldwide so results can be easily
compared and veriﬁed.
3 Design
Shadow is a discrete event simulator that can run real
applications as plug-ins while requiring minimal modiﬁca-
tions to the application. Plug-ins containing applications
link to Shadow libraries and Shadow dynamically loads and
natively executes the application code while simulating the
network communication layer. Shadow was originally a
fork of Distributed Virtual Network (DVN) simulator [10],
adding roughly 18,000 lines of code (including example
plug-ins). An overview of Shadow’s design is depicted in
Figure 1 and details about Shadow’s core simulation engine
are given in Appendix A.
Shadow dynamically loads plug-ins and instantiates vir-
tual nodes as speciﬁed in a simulation script. Communi-
cation between Shadow and the plug-in is done through a
well-deﬁned callback interface implemented by the plug-in.
When the appropriate callback is executed, the plug-in may
instantiate and run its non-blocking application(s). The ap-
plication will cause events to be spooled to the scheduler by
executing a system call that is intercepted by Shadow and
redirected to a function in the node library. The intercep-
tions allow integration of the application into the simulation
environment without requiring modiﬁcation of application
code. Virtual nodes communicate with each other through a
virtual network which spools packet and other network re-
lated events to the scheduler. Each virtual node stores only
application-speciﬁc state and loads/unloads the state as nec-
essary during simulation execution. We now describe the
main architectural components that enable Shadow to re-
alize the above functionality and fulﬁll our design require-
ments discussed in the previous section.
3.1 Simulation Script
Each simulation is bootstrapped with a simulation script
written in a custom scripting language. This script gives
the user access to commands that allow Shadow to dynam-
ically load multiple plug-ins, create and connect networks,
and create nodes. Valid plug-ins are loaded by supplying
a ﬁlepath while parameters such as latency, upstream and
Figure 1: Shadow’s architectural design. Using a plug-in wrap-
per, real-world applications are integrated into Shadow as virtual
nodes while system and library calls are intercepted and replaced
with Shadow-speciﬁc implementations.
downstream bandwidth, and CPU speed are speciﬁed by ei-
ther loading a properly formatted CDF data ﬁle or generat-
ing a CDF using a built-in CDF generator. Hostnames may
be speciﬁed for each node and are otherwise automatically
generated to facilitate support for a Shadow name service.
The script also speciﬁes which plug-in to run and when to
start each node.
Events are extracted from a properly formatted simu-
lation script and spooled to the event scheduler using the
times speciﬁed with each command. After the script is
parsed, the simulation begins by executing the ﬁrst ex-
tracted event and runs until either there are no events re-
maining in the scheduler or the end time speciﬁed in the
script is reached. Each node creation event triggers the al-
location of a virtual node and its network and culminates in
a callback to a Shadow plug-in for application instantiation.
3.2 Shadow Plug-ins
A Shadow plug-in is an independent library that con-
tains applications the user wishes to simulate and a wrap-
per around these applications allowing integration with the
Shadow simulation environment. Each Shadow plug-in
wrapper implements the plug-in interface – a set of call-
backs that Shadow uses to communicate with the plug-in.
Plug-ins may also link to a special Shadow plug-in utility
libraries to, e.g. obtain an IP address or log messages.
Application. To run in Shadow, an application must be
asynchronous, i.e. non-blocking, to prevent simulator dead-
locks during the execution of application code. We note
that asynchronicity may be achieved with a small amount
of code in the plug-in wrapper that utilizes the built-
in Shadow callbacks or by writing the application using
the libevent-2.0 asynchronous event library [17], as
Shadow supports a subset of this library.
Next, the application must be run as a single process and
in a single thread. Child processes or threads forked or
spawned by an application will not be properly contained
in the simulation environment and are therefore currently
unsupported. In most cases forking or spawning children
will lead to undeﬁned behavior or undesirable results. We
note that most multi-threaded applications have a single-
threaded mode and the difﬁculty in porting those that do
not is application-speciﬁc.
Finally, the plug-in must register all variable applica-
tion state with Shadow to facilitate multiple virtual nodes
running the same application. Plug-ins fulﬁll this require-
ment by passing pointers to node-speciﬁc allocated memory
chunks and their sizes to a Shadow library function. There-
fore each variable must be globally visible during the reg-
istration process. However, we note that a plug-in may use