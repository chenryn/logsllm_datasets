messages. Software packages such as OpenSSH allow a user
to conﬁgure the ciphers used in the key exchange message,
even if these algorithms are not implemented in the library
itself. Inspection of the source code of for example the lib-
ssh2 library reveals that the versions strings announced by
the majority of the hosts matches with the one in the source
code. When we further analyze the design of available brute
2018-10-112018-10-122018-10-132018-10-142018-10-152018-10-162018-10-171000200030004000Number of honeypotsActive honeypots over time66          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationFigure 4: Evolution of the algorithms used by the libssh2 library to construct the SSH_MSG_KEXINIT message.
forcing tools, we can link common tools back to these li-
braries. Medusa [13], a tool for SSH brute forcing included
in Kali linux, builds on this library in this selected version.
The analysis of the 35 million compromisation attempts using
the SSH version and key exchange ﬁngerprinting leads to the
conclusion that the majority of attackers use readily available
tools to perform the brute forcing.
6.2 Fingerprints and libraries
Different tools generate different combinations in terms of
SSH version strings and key exchange ﬁngerprints. If two
tools use different libraries implementing the SSH protocol,
the announced SSH version string will likely be different. As
seen in the data, the name of the SSH library is often included
in the announced SSH version string.
Similarly, the ﬁngerprint retrieved from the key exchange
can also provide an indication of the tool used. Tools
building upon different libraries will announce different
algorithms during the key exchange. This is due to different
libraries supporting different algorithms and announcing
them in different order of preference. Therefore, due to slight
variations in used libraries and implementations, tools can be
linked to the ﬁngerprints generated by processing the SSH
version string and the key exchange initialization message.
In order to investigate the origin of the ﬁngerprints and
study user customization, we downloaded 10 commonly used
SSH brute forcing tools to inspect which library is linked to re-
alize the SSH protocol, and in addition mined the SSH version
strings from all received handshakes for mentions of libraries
or implementation stacks. This yielded a total of seven li-
braries that are utilized across SSH brute forcers we observed,
namely (1) Granados, (2) JSCH, (3) libssh, (4) libssh2, (5)
OpenSSH, (6) paramiko, and (7) the Erlang standard SSH
implementation. For all these libraries, we downloaded every
single release, as well as every intermediate version available
in the software repositories and manually identiﬁed the loca-
tion in the source code responsible for the SSH connection
and parameter selection. A program then identiﬁed every in-
termediate/release version when this code was modiﬁed over
the entire period of the softwares’ past development, and we
manually analyzed each changed code segment to extract how
this library would advertise itself as in this particular version.
This yielded a set of (banner, MD5 hash) tuples, which is on
the one hand dependent on the version of a library, on the
other hand also on certain options and taken branches in the
code, for example if certain other libraries or headers were
available on the system where it would be compiled and thus
activate ifdef blocks. Based on this, we generated a set of
possible 57 banner-hash tuples for the seven aforementioned
libraries, implemented in a particular software package at any
point in time.
Figure 4 shows this evolution for the libssh2 library with
respect to the construction of the SSH_MSG_KEXINIT mes-
sage. While libssh2 saw several intermediate releases between
version 0.9 and version 1.2.2, and the library advertises itself
differently in between these two releases, the cryptographic
routines remained unchanged during all of these updates lead-
ing to an identical ﬁngerprint. In 1.2.2, three options for the
data encryption using the AES cipher suite as well as the
option to encrypt using RC4 were added, while in 1.2.3 the
previously mandatory option to create a message authentica-
tion code using MD5 was removed. Later versions such as
1.2.8 only differed in the order they advertised the preference
of algorithms. Similar version graphs were created for the
other six libraries mentioned above, most of them appeared
in our data set announcing different release versions.
When libraries are compiled, the supported algorithms
might differ, depending on installed software packages that
are required by the algorithms. These dependencies can
greatly affect the number of supported algorithms during the
key exchange initialization, which is why we have identiﬁed
all different combinations possible. These also result in a
unique ﬁngerprint for a particular installation path and thus
allow a peek into the conﬁguration of the attack hosts.
Given the advertised library and version string we can then
cross validate whether the ﬁngerprint obtained from the hand-
shake is consistent with the default behavior of the library, or
whether some code changes or conﬁguration changes were in-
troduced. Interestingly, when we look at the 123 SSH version
strings and 49 ﬁngerprint hashes that we collected in our hon-
eypots, we ﬁnd that all 57 theoretically possible tuples from
the software libraries were present. When we match the ver-
sion string for a particular library and the ﬁngerprint hash that
should have been generated from the honeypot handshake,
0.91.2.21.2.31.2.81.4.31.7.0+3 AES+1 ARCFOUR-2 MANDATORY MD5 MACORDER CHANGECOMPRESSION+1 COMPRESSION+1 DH+2 MACMAC FACULTATIVEKEX ORDER CHANGELIBSSH2 Fingerprint EvolutionUSENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 67we ﬁnd that there is only a match for 26 out of the checked
57 library versions. This indicates that in 31 instances, more
than half, the announced version string is spoofed. We manu-
ally veriﬁed these instances of spooﬁng, and found that while
some of them are attempts to make the version string more
generic, others modify the version number of a library or
pretend to run a different software stack than the behavior
of the library would in practice indicate. For example, a par-
ticular brute forcing tool would announce OpenSSH version
4.3, but announces a cipher suite that was not implemented
in this particular version. Also, the order of algorithms for
some advertised versions of libssh and libssh2 do not match
the implementation of the library.
While spooﬁng of version string is common among attack-
ers, given our tracking of code changes, we were able to trace
back 26 out of the 31 spooﬁng instances to a library that is
consistent with the behavior of the brute forcing tool. Overall,
we ﬁnd that we were able to identify more than 91% of the
tools used to attack our honeynet using the ﬁngerprint.
6.3 Collaborating hosts
As we have shown in the previous part, the combination
of available key exchange algorithms, cipher suites, MAC
and compression options together with the advertised version
string does contain large amounts of entropy. As an addi-
tional veriﬁcation that this ﬁngerprint can serve as a measure
to ﬁngerprint the tooling itself, we look in this part into the
behavior of the hosts exhibiting a particular ﬁngerprint. If
this relationship holds, we would expect the following two
results: First, commonly available tools should see continuous
usage, but within this set there could be groups of hosts that
use the same tool in a speciﬁc way or with a similar behav-
ior that could be clustered together. Second, given that we
identiﬁed 31 mismatching version strings and ﬁngerprints, we
would expect some adversaries to have built custom tools for
SSH brute forcing. As these are not publicly available, they
should only be in used by a limited group of source hosts,
thus the tool ﬁngerprint could be used as a proxy to partially
ﬁngerprint the actor.
In the following, we will now investigate the different be-
haviors of the 49 different key exchange-cipher-MAC algo-
rithm hashes that we initially discovered in our dataset. Fig-
ure 5 shows the activity of the these ﬁngerprints over the
course of the experiment, for compactness of the ﬁgure and
the discussion, each ﬁngerprint has been assigned a numeric
ID from 0 through 48. The number of hosts using a tool with
a speciﬁc ﬁngerprint at a given time is represented by the size
of the marker in the plot, with the area of the markers being
proportional to the number of unique hosts using a ﬁngerprint
per hour. In the ﬁgure we can readily identify ﬁve distinct
behavioral patterns of ﬁngerprint usage:
• Popular, commonly available tools such as Ncrack (ﬁn-
gerprint 30 in cyan), or SSHtrix (ﬁngerprint 16 in red)
Figure 5: Scatter plot showing the number of hosts using a
certain key exchange ﬁngerprint over time. The number hosts
is indicated by the size of the markers.
or Hydra (ﬁngerprint 4 or 14 depending on the operat-
ing system it is installed on such as raspbian), see some
continuous usage by a diverse and signiﬁcant number of
origins. In the next section, we further show that these
groups can be separated by the password list conﬁgu-
ration of the brute forcer into distinct subgroups that
pursue a common strategy.
• Custom tools with a relatively uncommon or unique ﬁn-
gerprint are essentially only in use by distinct groups of
adversaries. Often these are rolled out to a large amount
of hosts, and from there explore remote hosts simultane-
ously with synchronized start and stop times. Consider
for example ﬁngerprint #23 indicated in green, which
performs a weekly recurring scan of the address space,
always using a similar amount of resources. Similar be-
haviors are shown by the groups of hosts using the tool
with ﬁngerprint #42 (orange) who scan every other day,
or by the groups scanning bi-hourly using the tool with
ﬁngerprint #46 (brown).
• Among these, some custom tools are run at low intensity
only by a select group of origins, which on average make
less than 4 login attempts per hour. All installations with
ﬁngerprint #36 (purple) operate in this way, and may be
classiﬁed as a slow brute forcing campaign following
the description by Javed and Paxson [10].
• Distributed hit & run campaigns only occasionally sur-
face, but then for a short period of time brute force many
remote hosts with a large number of resources. Interest-
ingly, we observe these hit & run campaigns to typically
exhibit a unique ﬁngerprint and thus employ custom
2018-10-302018-11-062018-11-132018-11-202018-11-27010203040Fingerprint IDNumber of IPs per fingerprint over time68          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX Associationtooling for their activities, which makes these attempts
and hosts participating in them easily identiﬁable by our
proposed method. Examples of such fast, concentrated
attempts are ﬁngerprints 39 (light green) or ﬁngerprint
29 (gray). The plot shows that both clusters become ac-
tive during the same time period, around November 20th,
and have approximately the same size. A closer inspec-
tion reveals that the hosts using the tool identiﬁed by
ﬁngerprint ID 29 are also using the tool identiﬁed by
ﬁngerprint ID 39. The IP addresses are located in 103
different /8 subnets indicating that the attacker has the
knowledge, resource and intention to spread his or her
infrastructure across the Internet, possibly in an attempt
to avoid detection.
6.4 Password combinations
After the completion of the key exchange and session nego-
tiation, the adversaries were presented a login prompt they
could interact with. Past work such as Nicomette et al. [15]
have used the entered user credentials to link individual lo-
gin attempts into related clusters, and for example identiﬁed
relationships between dictionaries but also noticed that only
few of them were reused across adversaries. As discussed
before, the economies of scale would imply that an attacker
is most likely going to deploy the same setup and tooling
on different hosts to launch attacks, thus the same tooling
would result in an identical ﬁngerprint, and thus help us gain
deeper insights into the activities of the attackers, for example
if they are splitting and distributing parts of dictionaries for
brute forcing across collaborating hosts. In this section, we
will discuss the relationship between groups found based on
an identical banner and key exchange, and their associated
password lists.
For each of the 49 ﬁngerprints detected earlier, we extracted
all SSH sessions from any host that exhibited this signature
and assembled the set of credentials (username + password)
during login attempts. Table 6.4 shows a selection of 8 ﬁn-
gerprints, which exemplarily shows the spectrum of different
key exchange - password list behaviors found throughout
the dataset. From the data we can distinguish three types of
groups: First, we see clusters where tools and the credential
list used are tightly linked together. Second, we clearly see
select ﬁngerprints in wide use, which focus on (subsets of)
ﬁxed password lists. Third, we observe groups of tooling,
where hosts pursue brute forcing with diverse and customized
password lists. We will discuss each of these three categories
in the following subsections.
6.4.1 High credential / tool correlation
For each group advertising the same banner and using the
same key exchange algorithm, the table lists the number of
IP addresses matching this ﬁngerprint and the number of
unique login credentials list used by an attacker belonging
to the cluster. To provide a better understanding of the login
credential lists used, the number of hosts using the 5 most
frequently used credential lists are shown.
All clusters in this category exhibit a tight link between the
ﬁngerprint and the utilized password list. For example, the ﬁn-
gerprint 0df0d56bb50c6b2426d8d40234bf1826 of cluster 1
is sent by 684 hosts, however within this group only 9 differ-
ent password lists are used. The vast majority of hosts in this
cluster, 672 or 98.2%, always send the exact set of credentials
to our honeypots, deviations of the cluster default occur only
very infrequently among all remote hosts having connected to
our honeypots. In addition to the strong link from a particular
ﬁngerprint to a credential list, also the reverse is true: no other
attackers have been using this credentials list in the dataset.
This would indicate that the proposed ﬁngerprinting method
can be used as a predictor for password usage.
6.4.2 Popular tool
The second category of behaviors we can distinguish in the
ﬁngerprint analysis are those tools which are widely deployed
but are run similarly conﬁgured. In this particular category,
we observe the presence of multiple common credential lists,
from which hosts pick a subset and brute force all of our
honeypots with the same credential set.
An example of this is cluster 5 with 86,805 IP addresses,
which employed a surprisingly low number of 625 login cre-
dentials lists. The top ﬁve groups all settle on a permutation
of (admin, admin), (admin, default), (admin, password) and
move horizontally throughout our ranges. Other groups of
hosts choose from lists geared towards speciﬁc type of de-
vices, for example credential lists associated with common
IoT devices or Raspberry Pi distributions.
6.4.3 Diverse credential lists
While both previously described clusters could also have be
discovered using password-based grouping as adversaries
shared signiﬁcant credentials, we found a third behavior of
brute forcing which would have remained undetected to es-
tablished methods. Clusters 6 through 8 belonged to a new
category characterized by a high number of credentials list
and a low number of IPs using identical credential lists.
Consider for example the case of group 6, where 557 dif-