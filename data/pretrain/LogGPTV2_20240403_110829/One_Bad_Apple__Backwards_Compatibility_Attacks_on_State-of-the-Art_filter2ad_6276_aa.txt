title:One Bad Apple: Backwards Compatibility Attacks on State-of-the-Art
Cryptography
author:Tibor Jager and
Kenneth G. Paterson and
Juraj Somorovsky
One Bad Apple: Backwards Compatibility Attacks on
State-of-the-Art Cryptography
Tibor Jager
Horst G¨ortz Institute for IT Security
Ruhr-University Bochum
PI:EMAIL
Kenneth G. Paterson∗
Information Security Group
Royal Holloway, University of London
PI:EMAIL
Juraj Somorovsky†
Horst G¨ortz Institute for IT Security
Ruhr-University Bochum
PI:EMAIL
Abstract
1
Introduction
Backwards compatibility attacks are based on the com-
mon practical scenario that a cryptographic standard of-
fers a choice between several algorithms to perform the
same cryptographic task. This often includes secure state-
of-the-art cryptosystems, as well as insecure legacy cryp-
tosystems with known vulnerabilities that are made avail-
able for backwards compatibility reasons.
Obviously using insecure legacy cryptosystems is dan-
gerous. However, we show the less obvious fact that even
if users have the best of intentions to use only the most up-
to-date, vulnerability-free version of a system, the mere ex-
istence of support for old versions can have a catastrophic
effect on security.
We demonstrate the practical relevance of our results by
describing attacks on current versions of important crypto-
graphic Web standards: W3C XML Encryption and XML
Signature, and JSON Web Encryption and Web Signature.
We furthermore propose practical and effective counter-
measures thwarting backwards compatibility attacks. These
can be applied in new versions of these standards as well as
in related speciﬁcations applying cryptographic primitives.
∗This author was supported by EPSRC Leadership Fellowship
†This author was supported by the Sec2 project of the German Federal
EP/H005455/1
Ministry of Education and Research (BMBF, FKZ: 01BY1030)
Complexity is often portrayed as being the enemy of se-
curity: the more complex a system is, the harder it is to anal-
yse, and the harder it is to eliminate all possible attack vec-
tors. One source of complexity in real world security sys-
tems stems from the desire to maintain backwards compat-
ibility between new and old versions of systems. This may
continue to be the case in spite of attacks against the old sys-
tems. In extreme cases, the legacy argument is sometimes
used: a certain system cannot be switched off despite hav-
ing known vulnerabilities because it runs a mission-critical
application that cannot be supported in any other way.
We have seen this kind of technology development path
being followed many times. For example, in the context of
secure protocols, it is by now well-known that “encryption-
only” conﬁgurations of IPsec are vulnerable to active at-
tacks which recover full plaintext [12, 59, 22]. Yet these
conﬁgurations are still allowed by the current third gener-
ation of IPsec RFCs and still supported by many vendors.
As another example, it has been known since 1995 [62]
that using chained initialization vectors (IVs) in CBC mode
undermines the security of protocols like SSL/TLS, in the
sense of allowing distinguishing attacks against the proto-
cols. TLS 1.1 [23], published in 2006, removed support for
chained IVs. Despite this distinguishing attack having been
turned into a full plaintext recovery attack [25], TLS 1.0 still
remains in widespread use.
It is obvious that introducing a new system whilst main-
taining backwards compatibility with old versions having
known weaknesses undermines security: if a system or a
protocol can be conﬁgured into an insecure state, then some
users will do so. In this paper, we show something a little
less obvious. Namely, that even if users have the best of in-
tentions to use only the most up-to-date, vulnerability-free
version of a system, the mere existence of support for old
versions can have a catastrophic effect on security. We show
this in the context of systems employing cryptography, in-
troducing what we term backwards compatibility (BC) at-
tacks. Like all good attacks, these are obvious in retrospect,
but they do not seem to have been fully explored before.
As we shall discuss in more detail below, they are closely
related to, but distinct from, version rollback attacks [71].
As a taster of our attacks to follow, consider a situation
where, for backwards compatibility reasons, a system still
allows the use of CBC mode encryption, but where Galois
Counter Mode (GCM) is the preferred secure encryption
scheme. The reason to switch to GCM may be that the CBC
mode is vulnerable to one of the several attacks that can,
under certain circumstances, recover plaintext when it is en-
crypted in this mode – these attacks exploit the malleability
of CBC-mode (i.e., an attacker is able to make meaning-
ful changes to an encrypted plaintext by making purposeful
changes to the ciphertext) in combination with the avail-
ability of an “oracle” telling the attacker whether modiﬁed
plaintexts are still valid. Such oracles can, for instance, be
based on error messages returned due to invalid padding
(“padding oracle attacks” [68, 24]) or other properties of
the plaintext, like malformed XML structure [38]. The de-
tailed description of these oracles is beyond the scope of this
paper – for us it is only important to know that in certain
scenarios an attacker is able to decrypt CBC-ciphertexts,
due to a weakness of CBC. Now what happens if users se-
lect GCM as their preferred mode? Then an attacker who
can modify messages so that they are decrypted using CBC
mode instead of GCM can use the old attack to decrypt the
ciphertexts as if they were CBC encrypted. Here we assume
that the same key is used, irrespective of the mode. Then,
as we explain in detail in Section 2, this CBC decryption
capability can be quickly and efﬁciently turned into a dis-
tinguishing attack against GCM.
This situation not purely hypothetical. As we will see,
this is exactly the evolutionary path that has been followed
in the XML Encryption standards. Very recently, the XML
Encryption Working Group published a new XML Encryp-
tion standard draft [27] to recommend the use of GCM in
preference to CBC mode in response to such an attack [38].
CBC mode is retained in the standard for backwards com-
patibility reasons. And the same key is used for both GCM
and CBC mode. Finally, a man-in-the-middle attacker can
easily manipulate XML document ﬁelds so that the use of
CBC mode for decryption is indicated instead of GCM. So
all the pre-conditions for our attack are met. Since CBC
mode is mandatory, any state-of-the-art, standard-compliant
implementation of XML Encryption will be vulnerable to
this BC attack, even if all honest users exclusively stick to
using GCM. We will demonstrate a practical distinguishing
attack against an implementation of XML Encryption using
this attack vector in Section 5.
class of attack?
which we attempt to answer in this paper:
This basic BC attack motivates the following questions,
• Which other encryption modes (and, more generally,
cryptographic schemes), can interact with one another
badly in this kind of scenario?
• To what extent do deployed systems fall victim to this
• What countermeasures are readily available?
The last question seems simplest to answer: use ap-
propriate key separation to ensure that the same keys are
not used in “weak” and “strong” cryptographic algorithms.
However, this apparent simplicity is deceptive. Our experi-
ence is that developers sometimes fail to appreciate this re-
quirement, or understand the requirement but fail to provide
key separation because they do not want to even invest the
small development effort needed to implement suitable key
derivation algorithms. Moreover, in the context of public
key cryptography, the most common data format for trans-
porting public keys, the X.509 certiﬁcate, does not by de-
fault contain a ﬁeld that limits the cryptographic algorithms
in which a public key and its corresponding private key can
be used. For example, a public key speciﬁed in an X.509
certiﬁcate as being an RSA encryption key could be used in
either the PKCS#1 v1.5 or the PKCS#1 v2.1 (RSA-OAEP)
encryption algorithms, with the former possibly being sub-
ject to Bleichenbacher-style [13] attacks. This lack of pre-
cision opens up the possibility of BC attacks in the public
key setting.
For the ﬁrst question, we do not attempt a systematic
analysis of all the possibilities, since even the number of
basic modes of operation of a block cipher precludes this.
Instead, we examine some particularly attractive (from the
attacker’s point of view) cases in the symmetric and asym-
metric settings. Speciﬁcally, we look at the interactions be-
tween CBC mode and GCM, this being particularly impor-
tant in the context of XML Encryption, and between CBC
mode and the AES Key Wrap algorithm. In both cases, we
are able to mount a BC attack to break what should be a
secure algorithm.
In the public key setting, we focus on
RSA encryption and signatures, showing a BC attack on
RSA-OAEP when it is used in conjunction with an imple-
mentation of PKCS#1v1.5 encryption that is vulnerable to
Bleichenbacher’s attack [13]. We also remark that a sig-
nature forgery attack is possible under the same circum-
stances; here we require the same RSA key to be allowed
for use in both encryption and signature algorithms, a situ-
ation promoted for instance by [31, 60].
To address the second question, we demonstrate work-
ing BC attacks against the most recent drafts of the W3C
XML Encryption [28] and XML Signature [29] standards,
as well as against the current draft of JSON Web Encryp-
tion [41] and Web Signature [40]. In the secret key setting,
we describe a practical BC attack that allows to break (i.e.,
to distinguish plaintexts of) GCM-based encryption in XML
Encryption, based on a weakness of CBC. The basic idea of
this generic attack is described in Section 2. Furthermore, in
Section 5.2 we apply a signiﬁcantly more efﬁcient variant of
this attack, which exploits speciﬁc weaknesses of XML En-
cryption, exemplarily to the widely-used Apache Web Ser-
vices Security for Java (WSS4J) library. In the public-key
setting, we show how the well-known attack of Bleichen-
bacher [13] gives rise to a BC attack that allows an attacker
to decrypt ciphertexts of PKCS#1 v2.0 encryption in both
XML Encryption [27] and JSON Web Encryption [41], and
to forge signatures for arbitrary messages in XML Signa-
ture [29] and JSON Web Signature [40]. The attack princi-
ple is described in Section 4. We furthermore report on our
experimental results, executed against the Java implemen-
tation of JSON Web Encryption and JSON Web Signature
Nimbus-JWT [52], in Section 5.3.
1.1 Related Work
Wagner and Schneier [71] described version rollback at-
tacks on Version 2.0 of the SSL protocol. Speaking gener-
ally, version rollback attacks target cryptographic protocols
where cryptographic algorithms and parameters are nego-
tiated interactively between communication partners at the
beginning of a protocol execution. The attacker modiﬁes
messages exchanged in this negotiation phase, in order to
lure both communication partners into using weak cryptog-
raphy, such as for instance legacy export-weakened algo-
rithms.
Backwards compatibility attacks can be seen as a vari-
ant of version rollback attacks that apply to non-interactive
protocols. An essential difference is that version rollback
attacks on two-party protocols can be prevented by either
party, if that party simply uses exclusively strong state-of-
the-art cryptography.1 In contrast, in this paper we describe
attacks that can not be prevented if one party is only pre-
pared to use strong cryptography:
the willingness of the
other party to use weak cryptography sufﬁces to foil secu-
rity.
Kelsey et al. [47] describe chosen-protocol attacks.
These consider a scenario where a victim executes a cryp-
tographic protocol Π, and an attacker is able to trick this
victim into executing an additional maliciously designed
cryptographic protocol Π(cid:48), too. This helps the attacker to
break the security of Π. Clearly such attacks require a very
strong attacker, and are only applicable if potential victims
can be seduced into executing malicious protocols. In con-
1In presence of an attacker the negotiation might then fail, which re-
duces the version rollback attack to a denial-of-service attack.
trast, in typical backwards compatibility attacks, no adver-
sarial control over the protocols executed by honest parties
is needed.2
The attack described by Kaliski Jr. [45] assumes an at-
tacker that is able to register new hash function identiﬁers,
and can thus be seen as a special case of chosen-protocol
attacks.
Gligoroski et al. [32] emphasise the need for key separa-
tion when using different modes of operation of a block ci-
pher, and criticise some ISO and NIST standards for failing
to make this point explicitly. However, they do not present
any concrete attacks against deployed protocols, and their
on-paper attacks do not seem to work as described (for ex-
ample, their Attack 4 which attempts to exploit the interac-
tion between CBC and CTR modes of operation seems to
require the occurrence of a highly unlikely event in Step 3
of the attack).
Barkan et al. [8] showed that the key separation prin-
ciple is violated in the GSM mobile telecommunications
system, and exploited this in what can be seen as a BC at-
tack on the GSM encryption mechanism: in their attack, an
active attacker fools the receiver into using a weak encryp-
tion algorithm (A5/2), extracts the key by cryptanalysis, and
then uses the same key to decrypt trafﬁc protected by the
stronger A5/1 algorithm. Thus the continued presence of a
weak algorithm enables the enhanced security provided by
a stronger algorithm to be bypassed. This is the only pre-
vious concrete example of a BC attack (of the speciﬁc type
we explore in this paper) that we know of.
A cryptographic primitive with the property that differ-
ent instantiations can securely share the same key is called
agile [1].
In a sense, the attacks presented in this paper
provide evidence that block-cipher modes of operation and
public-key schemes are not agile, and show how this prop-
erty leads to relatively efﬁcient practical attacks on impor-
tant Web standards. Another line of work, related to agility,
concerns joint security, wherein a single asymmetric key
pair is used for both signatures and encryption. An up-to-
date overview of work in this area is provided in [58].
1.2 Responsible Disclosure
We informed W3C (who are responsible for the XML
Encryption standard) of the attacks presented in this paper
in July 2012. They have acknowledged the attack and are
planning to extend the speciﬁcation with security consider-
ations addressing BC attacks. We informed the JOSE work-
ing group, which is in charge of JSON Web Encryption and
JSON Web Signature, of our BC attack on RSA-OAEP and
2Even worse, in the examples of BC attacks described in this paper hon-
est parties are forced to execute weak cryptographic algorithms, in order
to remain standards-compliant.
PKCS#1 v1.5 in April 2012. Their standards are still under
development at the time of writing.
We also communicated with several vendors applying
XML Signature and XML Encryption. We highlight the
steps they used to counter our attacks in Section 5.
2 Breaking GCM with a CBC Weakness
In this section we describe a BC attack on symmetric
encryption. We show how to break the expected security
of ciphertexts encrypted in Galois counter mode (GCM) by
exploiting a weakness of the cipher-block chaining (CBC)
mode.
This attack provides just one concrete example of a BC
attack. We have chosen to describe this particular case in
detail because we will show the practical applicability of
exactly this attack in Section 5.2.
2.1 Preliminaries
We ﬁrst describe the GCM and CBC modes of operation,
and give a high-level description of known attacks on CBC.
2.1.1 Galois Counter Mode
Galois counter mode (GCM) [51] is a block-cipher mode of
operation, which provides both high efﬁciency and strong
security in the sense of authenticated encryption [9].