基于这个前提（异构、无统一标准)，一些介入成本较小（不要求开发和运维人员改变技术
O
O
能自我标识（说明自己的来源，如业务线、服务等)。
格式要相对统一。
日志的内容要可理解（是指机器可理解)。
日志标准化
，需要付出一点成本，做一些标准化和规范化的工作是很有必要的。
，日志是第二容易做到标准化的（第一是接口)。日志标准化的含
第12章故障诊断和分析策略
209
---
## Page 236
工作更加容易。
带来了很大的困难。
服务就没有问题（5xx可能由多种因素导致)。由于两边标准不一致，给故障的及时排查、定位
供者，使用“响应时间”作为服务可用性指标，只要总体响应时间不超过对外承诺的 SLA约定，
来评估服务，一旦5xx 数量大于阈值，就会当作故障通报给B 部门。然而，B 部门作为服务提
歧义的SLA约定，你可以想象一下以下场景：
12.3
可以手工维护上下文关系，但是在大型系统中，这种上下文关系可能需要专门维护、自动关联。
套关系,有些系统使用字符串ID（0，0.1,0.1.1）来说明访问顺序。在业务场景不复杂的情况下，
到串联前后端、调用链的目的。
HTTP 环境变量 HTTP_REQUEST_ID即可获取，这样在记录相关日志时，即可使用此ID，达
proxy_set_header HTTP_REQUEST_ID $request_id;
令来完成标识：
多，甚至可以只针对容器级别进行统计，定位到调用链上的某个步骤，一般情况下应该够用了。
端还是有一定的改造成本的，还可能牵扯到跨部门合作。
Zipkin、阿里巴巴的鹰眼等)，具体实现到什么程度，主要看投入程度和协作能力，毕竟对前后
12.2
210
尤其是当你希望通过自动化、
A 部门调用B 部门提供的服务，为了监测服务的可用性，A 部门用返回错误码5xx的比例
在分布式系统中，尤其是当不同部门开发的业务系统需要相互协作时，如果没有统一、无
有了request_id，还不能绘制出一个完整的调用链路图，还缺少一个元素来指明上下文和嵌
可以将本次请求的 request_id 放在 Header 中传到后端，后面的 Web 容器、Web 应用等通过
在具体实践中，我们常常利用 Nginx 的$request_id 变量来唯一标识一次请求。通过以下指
相对于可能实现到函数级别追踪的 Trace 系统,基于 RequestID 的分布耗时统计成本要少很
一提到全链路追踪，大家一定会想到基于 Google Dapper 思想的各种系统（比如 Twitter 的
全链路追踪
智能运维：从O 搭建大规模分布式 AIOps 系统
SLA的统一
，智能化的方法来定位和排查故障时，SLA的统一可以让这些
---
## Page 237
一般的问题，通过这样的方式还能应付过来。图12-1展示了通过监控告警定位故障的流程。
到告警→查看 Dashboard→缩小范围→定位故障点。告警和Dashboard 组织得比较好的话，对于
12.4.1
降级等掩盖手段外，其恰恰还需要关心具体的故障点、故障原因，以便彻底优化和根除。
哪个点不正常、为什么不正常并不特别关心；但对于运维人员来说，除必要的快速恢复、止损、
一些细节信息，对于业务负责人来说，其只需关心现在服务是否正常、怎么恢复，而对具体是
12.4
理论上，只要监控做得足够全，所有问题都应该能被“发现”。发现问题的流程一般是：收
传统的故障定位手段有监控告警型和日志分析型等。
在前面的章节中，我们介绍了告警的收敛和聚合，告警信息经过收敛和概化，
〇非常依赖经验。随着人员的流动、系统的迭代，真正全面掌控每个细节的人越来越少，
这种方式虽然有效，但是有以下几个缺点。
唯
不够精确。
找齐就不容易了。
实时性不够。在上班时间还勉强能及时响应，而在非工作时间，能把了解情况的人都
大，但运维工程师的数量却是有限的。
系统规模越大，定位成本越高。系统规模大意味着数据量、Dashboard、告警量也会变
培养这样的人成本较高，新人上手困难。
传统的故障定位方法
监控告警型
，只能知道大概出问题的点，但是具体原因可能需要上服务器具体分析。
图12-1通过监控告警定位故障的流程图
411.7K
56bp
第12章故障诊断和分析策略
缩小范围
，必然会损失
得出结论
211
---
## Page 238
直观地反映问题出现的趋势，如图12-2和图12-3所示。
的链路访问过程展示出来，方便对问题进行定位。
好处就是包含了所有细节，问题出现过就会留下日志，所以相对要准确得多。通过一些离线分
12.4.2
212
另外，也可以对日志中的关键字、错误码/状态码进行一些实时的统计和汇总，这样能比较
前面介绍过日志标准化、增加 request_id 等内容，基于日志分析的问题定位技术，明显的
智能运维：从O搭建大规模分布式 AIOps系统
Rarch 31st 2017,12:49:13.00 37.57.128.140
March 31st 2017, 12:4916.000 180.76.5.52
Harh31st2017,12:49:19.00127.0.0.1
Rarch 31st 2017, 12:49:21.00 127.0.0.1
March 31st2017,12:49:22.008220.181.18.161
archt217,1:4923.05.63.11.
arch3st2817,12:49:23.0017.0.0.1
hullhu
日志分析型
图12-3Elasticsearch的链路日志分析
severity
5115
图12-2日志中的状态码统计
2
message
D
D
a
P
a
a
三
2.01
---
## Page 239
置信度（Minimum confidence）。
器学习算法。关联规则的度量（筛选和过滤）方法有：最小支持度（Minimum support）和最小
集中存在的强规则。也就是说，关联规则挖掘用于知识发现，而非预测，所以属于无监督的机
程。”[2]
的关系是否能为故障定位提供帮助？
通过聚类来处理告警（降低维度)，那么这些事件、错误、告警数据之间有没有联系？它们之间
12.5.1
人工智能就是通过算法和不断学习，实现隐含规则的自动学习以及更高知识粒度的学习推理。
识的规则显然是隐含的，只可意会不可言传，很难被人为地总结成基于显式规则的专家系统。
方面，经验的传承与积累受组织结构和人事变动的影响非常大；另一方面；这些代表经验或知
告警收敛等)，下面我们介绍故障定位相关技术。
12.5
关联规则挖掘是一种基于规则的机器学习算法，它的目的是利用一些度量指标来分辨数据
“关联规则挖掘是指从一个大型的数据集中发现有趣的关联或相关关系，即从数据集中识别
就像本章开头所介绍的，故障一般会通过事件、错误、症状表现出来，前面我们也介绍过
前面提到传统的故障定位技术（监控告警型和日志分析型）非常依赖人的经验，但是，一
〇极度依赖人的经验。
〇当系统规模比较大时，日志无法被全部收集。由于成本问题，日志分析作为辅助系统，
基于日志分析的问题定位技术的局限性也很明显，如下所示。
人工智能在故障定位领域的应用
不够及时。这类分析需要人工参与的部分比较多，一般用于事后追溯比较好。
集某一类日志（比如错误日志)，那么分析抽样日志得出的结论不一定能反映出真实的
状况。
规模一般大大小于线上业务系统，注定不可能收集线上所有的日志，只能采样或者收
基于关联规则的相关性分析
第12章故障诊断和分析策略
213
---
## Page 240
出现的次数/集合X出现的个数。例如：confidence({牛奶}-->{可乐}）=牛奶和可乐同时出现的
记录数=3/5=60%。
的次数/数据记录的个数。例如：support({牛奶}-->{可乐}）=牛奶和可乐同时出现的次数/数据
和置信度（confidence）来描述。
就一定会购买可乐，{牛奶}-->{可乐}就是一条关联规则。关联规则的强度用支持度（support)
X-->Y，就说X->Y是一条关联规则。举个例子，在图 12-5 所示的表中，我们发现购买了牛奶
点少，在实际应用中数据量会很大。
就是一条规则：{A,B}-->{C}。下面我们把购物篮变成数据集。
条，
214
置信度的定义：confidence(X->Y)=|X交 Y/IX=集合 X与集合 Y中的项在一条记录中同时
支持度的定义：support(X-->Y)=X交 Y/N=集合X与集合 Y中的项在一条记录中同时出现
关联规则就是有关联的规则，形式是这样定义的：两个不相交的非空集合X、Y，如果有
买牛奶的人同时会买可乐；第二条，买尿布和牛奶的人同时会买啤酒。当然，这个样本有
从图 12-5 可以看到，{Milk}-->{Coke}和{Diaper,Milk}-->{Beer}就是发现的两条规则：第一
图 12-5 展示的是超市购物篮的规则挖掘，买了 Item A 和 Item B 的人，也买了 Item C，这
智能运维：从O搭建大规模分布式AIOps系统
TID
Coke,Diaer,k
Beer,Brad,Diapr,Mik
Beer,Coke,Diaper,Milk
Bread,Coke,Milk
Items
Beer.Bread
图12-4啤酒与尿布的购物篮分析案例
98%ofpeoplewhopurchaseditemsAandB
图12-5
MARKETBASKETANALYSIS
also purchased itemC
关联规则发现示例
Rules Discovered
Milky
->
{Coke}
国
---
## Page 241
就需要扫描整个数据库一遍。Apriori 算法挖掘过程如图 12-6 所示。
出 L2，即频繁 2-项集；如此循环下去，直到无法发现更多的频繁 k-项集为止。每挖掘一层 Lk
果不加以优化，所需的时间是0(2")。
利用频繁项集生成规则也就不会花太多的时间；而生成频繁项集需要测试很多的候选项集，如
度的规则。
录数 N×support。支持度和置信度越高，说明规则越强，关联规则挖掘就是挖掘出满足一定强
牛奶出现的次数=3/4=75%。
次数/可乐出现的次数=3/3=100%；confidence({可乐}-->{牛奶}）=可乐和牛奶同时出现的次数/
这里定义的支持度和置信度都是相对的，不是绝对的，绝对的支持度 abs_support=数据记
首先找出频繁1-项集，记为L；然后利用L,产生候选项集C2，对C2中的项进行判定挖掘
具体做法如下：
〇利用频繁项集构造出满足用户最小置信度的规则。
关联规则的挖掘过程（Apriori算法）如下：
关联规则挖掘所花费的时间主要在生成频繁项集上，因为找出的频繁项集往往不会很多，
生成频繁项集。挖掘频繁项集，根据最小支持度阈值（min_sup）找出数据集 DB 中的
所有频繁项集，直到再没有满足 min_sup 条件的项集为止。
400
200
100
Database D
800
ID
Clitemset
itemsetsup
[235)
心
N
C
35
G
3
Scan D
图12-6
ScanD
4
C
(35)
itemsetsup.
(15)
(13)
N
(12)
Apriori算法挖掘过程
{5}
{3}
{2}
Litemsetsup
235
N
ScanD
C2
第12章故障诊断和分析策略
（2}
litemset
（35）
C
215
---
## Page 242
asaini/Apriori 。
可以被追踪到了（在实践中情况要复杂得多，这里仅仅是示例)：
“HBase负载高”（或许还有其他）的告警。当告警命中这两条规则后，一个简单的故障根源就
故障的根源，定位故障。
发生时，用关联规则进行匹配，可以判断是独立的告警/事件，还是关联的告警事件，从而确定
研究表明，它比 Apriori 算法大约快一个数量级。
描且不使用候选项集，直接将数据库压缩成一个频繁模式树，最后通过这棵树生成关联规则。
Jiawei Han 等人提出了基于 FP 树生成频繁项集的 FP-growth 算法。该算法只进行两次数据库扫
的 2-项子集是{B,C},{B,E},{C,E}，它的所有 2-项子集都是 L2的元素，因此保留这个选项。
{A,C,E}的2-项子集是{A,C},{A,E},{C,E},其中{A,E}不是L2的元素,所以删除这个选项;{B,C,E}
以删除其子集为非频繁的选项：