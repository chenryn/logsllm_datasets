for all
tested projects, and extracted more than 676,000
function declarations. Then it conducted the NLP-assisted
classification. Given the trained Siamese network and the
corresponding reference vectors, 90,069 functions were first
classified. By further considering whether the prototype of
a classified function contains a data pointer, 53,977 MM
function candidates were selected. Obviously, the candidate
set contains many non-MM functions only with a similar
prototype, and would introduce false positive to the subsequent
bug detection. Therefore, GOSHAWK continuously applied
data flow analysis based validation to filter irrelevant functions.
After applying data flow analysis based validation to cross-
check the candidates, GOSHAWK identified 13,868 (5,820
allocators and 8,048 deallocators) custom MM functions out
of 53,977 functions. For projects, OpenSSL, Redis, and
IoT SDKs, we manually verified all
the identified results
and confirmed that they were correctly identified. For the
Linux kernel and FreeBSD kernel, although we did not have
ground truth data and were not able to manually verify all
identified functions, we did check 300 functions randomly
and found no misidentified case. We also randomly chose
50 filtered functions to check whether they were reasonably
eliminated. Our manual inspection found that although the
names of those functions were similar to names of alloca-
tion and deallocation functions (e.g., percpu_alloc_setup,
nr_free_buffer_pages), they did not execute any memory
allocation or deallocation.
To systematically evaluate how NLP-assisted classification
and data flow analysis based validation affect the accuracy, we
manually chose 200 allocators, 200 deallocators, and 600 non-
MM functions to test the identification accuracy. As shown in
Table III, GOSHAWK tended to mis-label non-MM functions
when using only NLP-assisted classification (low precision).
When using both NLP-assisted classification and data flow
analysis based validation, the precision increased to 100%
but the recall decreased, which indicates that it would miss
more MM functions. To verify this at a larger scale, we
referred to K-MELD [6] and SinkFinder [5], two recent tools
which also labeled MM functions in Linux kernel. K-MELD and
SinkFinder respectively labeled 1,267 and 438 MM functions
in Linux kernel (version 5.2.13 and 4.19); thus we applied
GOSHAWK to these two versions of Linux kernel and compared
our results to them. GOSHAWK outperformed K-MELD and
EVALUATING ACCURACY OF MM FUNCTION IDENTIFICATION WITH A
TABLE III
GROUND TRUTH DATASET
Allocator
Precision
w/o DFA
w/ DFA
89.6%
100%
Recall
91.0%
84.5%
Deallocator
Precision
90.2%
100%
Recall
97.0%
89.5%
SinkFinder in finding more MM functions (Table IV), but
it missed 594/259 functions labeled by K-MELD/SinkFinder.
After manually reviewing all those functions, we found that
446/205 of them did not perform MM behaviors (they were
thus false positives of K-MELD and SinkFinder). We then re-
examined the rest 148/54 functions and found that our NLP-
assisted classification did label 129/46 of them. However,
the subsequent validation failed to return correct data flow
information due to analysis issues such as indirect calls and
sophisticated pointer arithmetic.
Answer to RQ1: GOSHAWK guarantees the soundness of
MM function identification but may miss a small portion of
MM functions due to imperfect NLP and data flow analysis.
COMPARISON OF MM FUNCTION IDENTIFICATION IN THE LINUX KERNEL
TABLE IV
Version
K-MELD
A
D
461
806
-
-
SinkFinder
A
D
-
-
256
182
Goshawk
D
A
MN MD
129
19
8
46
v5.2.13
v4.19
A : # of allocators; D : # of deallocators;
MN : # of MM functions missed by NLP-assisted classification;
MD : # of MM functions missed by DFA based validation.
4,571
4,396
4,847
4,704
D. Features of generated MOS
GOSHAWK successfully generated MOS for all 13,868
identified custom allocators/deallocators. Based on MOS infor-
mation, we can observe the distribution (primitive vs extended)
of custom MM functions in different projects. Table I lists the
number of each kind of MM functions, and the overall dis-
tributions. We found that there are more custom deallocators
(8,048) than custom allocators (5,820), and each project has
this characteristic. This implies that allocators and deallocators
are not always paired, so is their usage.
In all 5,820 custom allocators, GOSHAWK found that the
number of primitive ones (3,709, 63.7%) is larger than that of
the extended ones (2,111, 36.3%). In comparison, for the 8,048
custom deallocators the number of primitive ones (2,476,
30.7%) is smaller than that of extended ones (5,572, 69.3%).
This distribution shows that developers may be more likely to
allocate memory objects separately, but deallocate them in a
centralized way (refer to the motivating example in Figure 1).
The generated MOS reflected the widely existence of com-
plex memory object managements among the identified MM
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:43 UTC from IEEE Xplore.  Restrictions apply. 
2105
functions. For the 5,820 memory allocation functions, 4,311
(74.1%) functions return allocated memory objects via a return
value (548 functions return the allocated memory objects with
at least one sub-object allocated), and 1,509 (25.9%) functions
return the allocated memory objects via parameters. For the
8,048 memory deallocation functions, 2,504 (31.1%) functions
directly release a pointer, and 3,938 (48.9%) functions only
dereference the pointer to obtain the structure information to
release its sub-objects, while 1,608 (20%) first dereference
the pointer and then release both its sub-objects and the main
object its points to. The experimental results demonstrate that
modeling extended MM functions as primitive ones would
lead to a imprecise bug detection. In response, the generated
MOS preserved essential information to model MM functions
and the related memory objects, thus are expected to help the
following bug detection work precisely.
E. Bug Detection
1) Code Exploration Settings: To fully use of our hardware
resources (64-core AMD 3990x and 192GB RAM), we empiri-
cally set the analysis parameters of CSA as MAX-AD=5, MAX-
AB=225,000, and CTU-THR=100 (larger parameters would
exhaust the CPU/RAM and stop the analysis).
2) Detected Bugs: With the help of the generated MOS
information, GOSHAWK conducted use-after-free and double-
free bug detection against recent versions of Linux kernel,
FreeBSD kernel, OpenSSL, Redis and IoT SDKs. GOSHAWK
reported 145 potential bugs. Our manual audit, only taking
three days (8 hours per day) for one developer (who was not
responsible for the buggy code), confirmed that 92 (63.4%) of
the reported issues were real bugs and previously unknown
(a more detailed result is reported in Table VII in Appendix),
even though those projects were tested by many code analyzers
and checked by reviewers. Actually, we inspected these bugs
in the commit history of the tested projects and found that
many of them have been present for a long time. For instance,
in the Linux kernel we found that 12 bugs have been present
for more than 6 years3, and another 3 bugs have even been
present for 15 years4. Although the Linux kernel is periodically
tested by different static tools, we argue that the lack of
MM summarization still makes difficult for developers to
confirm those bugs, and MOS based bug descriptions help
them examine the issues more effectively. Except for few
special cases, our reported bugs received the confirmation of
kernel developers within 2 days on average.
3) Detection Accuracy: The bug detection of GOSHAWK
against the seven tested projects initially labeled 308 issues in
the source code. Among the 308 labeled issues, we first found
163 cases of infeasible path caused by insufficient contextual
information, complex logical calculations or conditional allo-
cation/deallocation. By using the Z3 SMT solver to re-analyze
the issue relevant paths, we excluded 30 false warnings. For
the other 133 cases, we found that even the Z3 solver could not
ANALYSIS TIME FOR MM FUNCTION IDENTIFICATION, MOS
GENERATION, AND BUG DETECTION (IN MINUTES)
TABLE V
Linux
FreeBSD
OpenSSL
Redis
Azure
QcloudE
QcloudH
MMFI MG
38
3
1
3
61
11
2
1.5
1.07
0.28
0.26
BD
328
20
3
1
Total
427
34
6.5
5.5
1.90
1.02
0.93
0.22
0.10
0.07
MMFI : MM function identification;
MG : MOS generation; BD : Bug detection
0.61
0.64
0.60
practically explore those paths, and we directly excluded the
infeasible path cases manually. After that, we then examined
the false positive and false negative cases.
False positives. For the 145 issues left for a manual bug
verification, we confirmed that GOSHAWK reported 33, 7,
0, 0 and 13 false warnings for Linux kernel, FreeBSD kernel,
OpenSSL, Redis and IoT SDKs, respectively. We found that
the root causes of those false positive cases are mainly due to
the weakness of the memory model [28] of CSA engine; CSA
sometimes incorrectly models two pointer variables (actually
pointing to two different addresses) with the same symbolic
values, thus causing false positives. We leave the enhancement
of alias analysis as a future effort. Considering that GOSHAWK
has analyzed millions of code and introduced more than
10,000 custom MM functions, such a precision is promising.
Also, the number of the reported bugs is manageable for a
manual audit.
False negatives. Since we did not have a ground truth to verify
the false negative rate against the seven tested projects, we
chose another bug list to evaluate GOSHAWK. The bug list
contained 31 use-after-free bugs in Linux kernel 4.19 found
by SinkFinder tool, which also utilized annotation-assisted
detection (we list the details of those bugs in Table VI in
Appendix5). GOSHAWK successfully detected 29 of those
31 bugs; also we found that GOSHAWK could not detect
the left two bugs because it failed to identify the related
deallocators cfg80211_put_bss and nfc_put_device due to
the issues mentioned in Section V-C. Actually, we manually
added cfg80211_put_bss and nfc_put_device into our custom
MM function set and generated MOS for them. This time
GOSHAWK detected the remaining two bugs successfully.
Answer to RQ2: GOSHAWK achieved a 63.4% of precision
for reported bugs, and found new bugs that other annotation-
based detection tools were not able to discover. Moreover,
the MOS based bug description is more concise for analysts
to understand.
F. Time and Performance Analysis
By utilizing MOS to simplify the code exploration,
GOSHAWK avoids scalability issues in bug detection and
3ID 5, 11, 13, 15, 27, 32, 35, 36, 37, 38, 39, 48 in Table VII
4ID 41, 44, 45 in Table VII
5Note that we excluded four reference count related bugs mentioned in
SinkFinder paper since this is out of the scope of this paper.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:43 UTC from IEEE Xplore.  Restrictions apply. 
2106
can efficiently analyze complex projects. Table V shows the
analysis time costs for GOSHAWK to check each of the seven
tested projects. For the most time-consuming bug detection
process against Linux kernel, GOSHAWK spent 427 minutes to
execute the whole analysis. Specifically, it took 61 minutes to
perform NLP-assisted classification and data flow analysis to
identify MM functions from source codes. Then, 38 minutes
were used to generate MOS for the identified MM functions.
With the generated MOS, GOSHAWK took 328 minutes to
detect bugs. In comparison, as we show in Section V-B, if
we did not restrict the exploration scope, the analysis would
have required unacceptable time even with a more powerful
hardware configuration. For other projects, GOSHAWK could
complete the bug detection in less than one hour. These results
show that we can deploy GOSHAWK to implement a daily bug
checking even for large projects such as the Linux kernel.
We further investigated the identified MM functions and
found 988 out of 4,721 allocators contain a long (>5) call chain
from the entry to the primitive allocators. For deallocation
functions, the results were similar. Since GOSHAWK identified
those MM functions and modeled them as MOS, it removed
the internal data flow of all identified MM functions and
thus reduced the length of data flow. On average, GOSHAWK
reduces the data flow length by removing 2.99 functions for
custom allocation and 2.54 functions for custom deallocation.
The use of NLP significantly boosts the entire MM function
identification. Taking the identification against Linux Kernel
as an example, we found that the NLP-assisted classification
takes 22 minutes to classify 549,187 functions, and the subse-
quent data flow analysis based validation only takes 39 minutes
to check all those functions. In fact, we ran a data flow analysis
to check all functions in Linux Kernel without applying the
NLP-assisted classification, and found that
the experiment
could not terminate and suffered from out-of-memory crash
on our server with 192G RAM.
Answer to RQ3: By using MOS to facilitate bug detection,
GOSHAWK avoids a large number of redundant explorations
and addresses the path explosion issue. The NLP-assisted
classification also boosts the MM function identification.
G. Comparison with Related Works
MM Function Identification. GOSHAWK significantly out-
performs K-MELD and SinkFinder in terms of the number
of identified MM functions (Table IV). Besides, the identi-
fication result of GOSHAWK is more extensive. K-MELD and
SinkFinder were only applicable to Linux kernel. GOSHAWK is
designed to broadly analyze source code with different scales
and is able to accurately find MM functions in both large and
small projects.
Bug Detection. We further compare GOSHAWK to K-MELD
and SinkFinder in bug detection. Since K-MELD and SinkFinder
were not specifically designed to detect use-after-free and
double-free bugs, we adopted an indirect comparison between
GOSHAWK and them. We applied the similar analysis process
but only utilized the MM functions labeled by K-MELD and
SinkFinder to help detect bugs in Linux kernel. We first added
those MM functions into GOSHAWK but only as primitive
allocators/deallocators (i.e., adopting a simple memory object
model), and examined the results. We found that the MM
function sets of both K-MELD and SinkFinder were inaccurate
and caused false alarm:
the number of bugs reported by
separately using MM function sets of K-MELD and SinkFinder
were 4,742 and 999, and GOSHAWK only re-detected 18 and
8 bugs among them. This shows that the bug detection models
of K-MELD and SinkFinder are imprecise. They cannot handle
nested allocation and unpaired uses of MM functions and thus
are expected to incur high false positives and false negatives.
Actually, even though SinkFinder has considered the custom
function issues and annotates several function (pairs), its pair-
based detection (against Linux kernel 4.19) still misses all 14
use-after-free bugs that are detected by GOSHAWK6.
Hence we further applied the same data flow analysis
validation and MOS generation procedures against their MM
function sets to refine the memory model, and only preserved
663/160 MM functions. By utilizing their MOS information,
the new detection results become much better: only 57/23 bugs
are reported and 20/10 of them are valid after manual inspec-
tion. This demonstrates that our structure-aware and object-
centric analysis improves the analysis precision effectively.
VI. DISCUSSION
Scalability Bottlenecks. Our evaluation has demonstrated
that the depth and breadth of code exploration are the main
factors impacting the analysis complexity: to enumerate more
execution paths, the complexity of exploration increases ex-
ponentially, which is the well-known path-explosion problem.
Hence our current analysis applies different thresholds to limit
the range of code exploration to ensure that the analysis time
and required hardware resources are practical (note that the
settings guarantee that at least every function is explored).
We identify two potential strategies to improve the scala-
bility and coverage. The first strategy is to reduce the number
of paths for symbolic execution. Path-based symbolic execu-
tion [29], [30], concolic execution [31], [32], and selective
symbolic execution [33] have shown to be highly scalable to
complex programs. To adopt such a strategy, one can first
apply static analysis or heuristics to select potentially buggy
paths and focus the symbolic execution on only them to
improve scalability. The second strategy is to improve the
performance of the symbolic execution engine. SymCC [34]
adopts a compilation-based approach (as opposed to the
traditional
interpretation-based approach [35]) to symbolic
execution and improves the performance by up to three orders
of magnitude. Path merging [36], [37], [38], on the other hand,
reduces the number of paths by merging paths at the same
program location that are similar. We believe that these two
strategies are orthogonal to GOSHAWK and, when adopted,
can further improve the scalability of GOSHAWK. Once the
6ID: 1, 5, 23, 32, 33, 35, 36, 37, 38, 39, 41, 45, 46, 48 in Table VII. These
bugs existed in both Linux kernel 4.19 and 5.12
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:56:43 UTC from IEEE Xplore.  Restrictions apply. 
2107
scalability is improved, we can then drop the thresholds to
also improve coverage.
Sources of False Positives/Negatives. Many inherent chal-
lenges of both control-flow and data-flow analysis (e.g., in-
direct call resolution, alias analysis, loop analysis) are still
not well addressed by state-of-the-art code analysis engines
and would lead to imprecise results. Such imprecision natu-