0-7803-8367-2/04/$20.00 ©2004 IEEE 
Abstract-- Techniques and methods currently exist to detect if 
a certain type of rootkit has exploited a computer systems.  
However, these current techniques and methods can only 
indicate that a system has been exploited by a rootkit.  We are 
currently developing a methodology to indicate if a rootkit is 
previously known or if it is a modified or entirely new rootkit.   
We present in this paper an application of our methodology 
against a previously unseen rootkit that was collected from the 
Georgia Tech Honeynet.  We conduct our analysis process 
against this rootkit and are able to identify specific 
characteristics for subsequent detections of this rootkit.  This 
ability will provide system administrators, researchers, and 
security personnel with the information necessary in order to 
take the best possible recovery actions. This may also help to 
detect and fingerprint additional instances and prevent 
further security instances involving rootkits.    
Index Terms-- forensics, Honeynet, rootkits, signatures 
I. INTRODUCTION 
Rootkits are a phenomenon that has recently drawn 
attention.  Prior to rootkits, system utilities could be trusted 
to 
provide 
a 
system 
administrator 
with 
accurate 
information.  Modern crackers have developed methods to 
conceal their activities and programs to assist in this 
concealment [1].  Rootkits are a serious threat to the 
security of a networked computer system. 
Modern operating systems are subject to a variety of 
exploits that allow hackers to gain root access on networked 
computer systems.  This in turn, provides hackers with the 
ability to install rootkits on these compromised systems.  
System administrators need to be aware of the threats that 
their computers face from rootkits as well as the ability to 
recognize if a particular rootkit has been installed on their 
computer system.   
Part of our efforts is the use of a Honeynet to collect new 
rootkit type exploits.  Rootkits are also available from other 
sources including the Internet.  The Honeynet, however,  
offers us an opportunity to collect rootkits that may not 
have been previously seen by other researchers [2].  These 
rootkits are targeted against actual live systems on the 
Honeynet that have been compromised by a hacker.  We 
believe that the Honeynet offers us an actual opportunity to 
collect existing, modification to existing, and entirely new 
rootkit exploits.   
On 1 June 2003 a system installed on the Georgia Tech 
Honeynet was compromised, allowing a hacker to gain root 
level access.  The hacker then installed  a rootkit on this 
system.  No traffic should have been going to or come from 
this system since it is a Honeynet machine [3].  By 
following the principles of data capture and data control we 
were able to capture the exploit that the hacker executed 
against this system and prevent this system from being used 
to compromise any other systems.   
A. Target System Description 
The target system that was employed on the Honeynet was 
a standard version of the Red Hat Linux 6.2 operating 
system running the Linux 2.2 kernel.  This system was 
configured to install all available packages and no special 
modifications were made to this system.  The install process 
was a default installation for this configuration.  No 
additional services besides those that were started by the 
default installation were enabled on the target system.  The 
following ports were opened on this system: 
21 ftp 
23 telnet  
25 smtp 
79 finger 
98 Linux conf 
111 sun rpc 
113 auth  
513 login 
514 shell 
515 printer 
954 unknown 
1024 kdm 
1025 listen 
1033 net info 
6000 x11   
B. Method of Compromise 
At 10:34 AM ZULU on June 1, 2003 an exploit was 
launched against the target system on port 21 (ftp daemon) 
to attempt to gain root level access.  The ftp server running 
on Red Hat Linux 6.2 is wu-ftpd2.6.0(1) ftp daemon, the 
default ftp server.  Exploits that allow a hacker to gain root 
level access have been published against this particular 
service and are available on the Internet.  This attack was 
successful and the hacker was able to gain root level access 
on the target system.  Figure 1 shows the start of the tcp 
stream that was extracted from the Honeynet data 
concerning this attack.    The string RNFR  ././  is a 
signature of the WU-FTP exploit for the ftp server that is 
running on this system [4]. 
Application of a Methodology to Characterize 
Rootkits Retrieved from Honeynets 
John Levine, Julian Grizzard, Henry Owen, Members, IEEE 
PI:EMAIL, PI:EMAIL, PI:EMAIL  
Figure 1: Start of Exploit 
  The hacker was successful utilizing this exploit to gain 
root level access on the target system.    This is indicated in 
Figure 2 where the hacker queries the system for his id and 
the user id (uid) of 0(root) is returned.  The hacker then adds 
a user andrey with a password of andrey to the system.  
Figure 2: System Compromise Indication 
The hacker, having gained root access, is now able to 
install a rootkit on the target system.   The rootkit that the 
hacker chooses to install in called ‘r.tgz’ which was 
downloaded through a telnet session using the wget 
command.   We do not believe that this particular rootkit has 
been publicly analyzed before.  There is an ssh rookit called 
‘r.tgz’ but the characteristics of that rootkit, including the 
file size, differ from the rootkit that was installed on the 
target system [5].  In any event, we were unable to find any 
detailed examination of a rootkit called ‘r.tgz’ with 
characteristics similar to the one that was installed on the 
target system.   
The hacker extracts the exploit code within the ‘r.tgz’ file 
and then runs the exploit on the target system.  Figure 3 
shows the actual Honeynet logs of the hacker’s session.  The 
‘r.tgz’ rootkit deletes all traces of itself on the target system 
after installation.  However, we were able to reconstruct 
what the hacker accomplished by utilizing the Honeynet 
logs for this exploit session.  
Figure 3: Installation of 'r.tgz' rookit 
II. METHODOLOGY TO CHARACTERIZE ROOTKIT EXPLOITS 
We are able to apply our methodology to the valid copy 
of the rootkit that we retrieved from the Georgia Tech 
Honeynet.  The following is a description of the 
methodology that we follow to identify the specific delta 
( ∇ ) of a rootkit exploit targeting the Linux operating 
system.    The concept of identifying a specific delta is 
described in our paper titled “A Methodology to Detect and 
Characterize Kernel Level Rootkit Exploits Involving 
Redirection of the System Call Table”  presented at the 
Second International Information Assurance Workshop [6].  
In this case we choose Linux as our operating system for 
this specific investigation but this methodology should 
apply to other UNIX type operating systems. 
1. Start with a clean installation of the specific kernel 
version of the operating system that was the intended 
target of the rootkit exploit.   
2. Install a kernel level debugger on this system.  The 
installation of the kernel level debugger will probably 
require the system to be recompiled with a custom 
kernel. 
3. Install and run a file integrity checker program on 
this system.  Select target directories based on an 
analysis of the installation that occurred when the 
rootkit was originally acquired. 
4. Install a rootkit detection program such as chkrootkit 
on the target system.  This will detect many existing 
system utility rootkit exploits and may help to 
identify modification to existing as well as entirely 
new rootkit exploits. 
5. Install a program such as kern_check [7] to check the 
integrity of the system call table within the kernel.    
Run this program on the target system to establish a 
baseline and ensure that the kernel integrity has not 
been compromised on this initial installation.   
6. Make a copy of the kernel text segment of memory 
via /dev/kmem for future comparison.  We have 
presented a method to do this in our paper titled “ A 
Methodology to Characterize Kernel Level Rootkit 
Exploits that Overwrite the System Call Table” to be  
present at SoutheastCon 2004 [8].  The kernel text 
segment of kernel memory should remain consistent 
for a particular kernel build.   Any deviation between 
this copy and a future copy could indicate that the 
kernel may have been compromised by a kernel level 
rootkit exploit.    A more detailed analysis of kernel 
space can then be conducted via the kernel debugger 
(kdb) program that has previously been installed. 
7. Run the file integrity checker program and the rootkit 
detection program on the target system prior to 
infecting the system with the rootkit to establish a 
baseline for comparison between a clean and infected 
system. 
8. Install the rootkit on the target system.  Follow the 
installation steps that were used when the rootkit was 
initially acquired for analysis. 
9. Run the file integrity checker program on the system 
and note the results.  The presence of certain types of 
rootkits should be indicated by the results of the file 
integrity checker program but other types of rootkits, 
specifically those that target the kernel, may not be 
detected by this type of program. 
10. Run the rootkit detection program (chkrootkit [9]) on 
the system that has been infected with the rootkit that 
is being analyzed.  If this is a previously known 
system utility rootkit then a program such as 
chkrootkit should be able to detect the presence of 
this rootkit.  If the file integrity checker program 
detected a change to a system utility binary program 
file but the rootkit detection program did not detect 
the presence of a rootkit then we can assume that we 
are dealing with either a modification to an existing 
system utility rootkit or an entirely new system utility 
rootkit.   
11. Run the kernel integrity check program on the target 
system.  If the system call table was modified or 
redirected, then this program should be able to detect 
what has been modified.  Make note of each system 
call that is indicated as being modified as well as a 
total count of the number of system calls that have 
been modified by this rootkit. The system calls that a 
rootkit modifies can establish a signature for a 
specific kernel level rootkit [10].  This program may 
not be able to detect some other modification to the 
kernel text code segment of the kernel. 
12. Make a copy of the kernel text code and compare it 
against the original copy of the kernel text code that 
was prepared before infecting this system with the 
rootkit.  A difference between these two files may 
indicate the presence of a kernel level rootkit.  This is 
especially significant if the existing kernel integrity 
checker programs failed to detect any modification to 
the kernel.  This would indicate that one is dealing 
with a new type of kernel level rootkit that does not 
target the system call table.  The system call table is 
the normal avenue of attack for hackers who are 
attempting to create a kernel level rootkit.  
The results of these steps can be used to classify a rootkit 
exploit as an existing, modification to an existing, or an 
entirely new rootkit.   
III.  ANALYSIS PROCESS 
The Georgia Tech Honeynet was able to capture the entire 
exploit session of a system compromise including the  
downloaded files as well as the remote machines that the 
hacker connected to from the compromised machine.  This 
provided us with the scripts and files that were used by the 
hacker to install the r.tgz rootkit.  Preliminary analysis of 
these files gave us an indication of how this rootkit could be 
installed on a target system similar to the system on the 
Honeynet.   We then set out to install the r.tgz  rootkit on a 
target system to analyze and classify it. 
We have initially set up a baseline system that consists of 
the same operating system as the system that was 
compromised on the Honeynet.  In this case it is Red Hat 
6.2 running the Linux 2.2.14 kernel.  Following the 
procedures outlined in Section II, we installed a kernel level 
debugger (kdb) on this system as well as a file integrity 
checker program (AIDE [11]) .  We then installed a known 
rootkit detection program (chkrootkit [9]) and made a copy 
of the kernel text segment via /dev/kmem.    Prior to 
infecting this system with the r.tgz rootkit  we ran the AIDE 
and chkrootkit program to establish a clean baseline for 
analysis and classification.  We then infected this system 
with the r.tgz rootkit.   
The first check that we ran on the infected system is the 
file integrity check to determine what files have been added, 
changed, or deleted.  Running the AIDE program on the 
infected system indicated that 2 files had been added to the 
infected system and 178 files had been changed by the r.tgz 
program.  This is a large number of files and initial analysis 
of the install scripts for this rootkit does not indicate that all 
of these files are being modified.   Follow on analysis was 
conducted on these modified files to determine the nature of 
these changes.  Figure 4 shows the results of running AIDE 
on the infected system. 
Figure 4: AIDE results on r.tgz infected system 
The next step was to run the known rootkit detection 
program (chkrootkit) on the target system.   Running this 
program  utilizing the binaries that are currently installed on 
the target system only results in the identification of one 
system binary as being infected.  The binary that is indicated 
as being infected is ifconfig.  The chkrootkit program also 
detects five suspicious files and possible infections by the 
“Showtee” and “Romanian” rootkits.   
The recommended method of using the chkrootkit 
program is to use known good binary files.  Known good 
binary files can be copied to a read-only disk and the files 
on this disk can be accessed by the chkrootkit program 
using the –p switch.  Using known good binary to check the 
system results in the identification of the same changes 
identified in the previous paragraph plus 5 additional 
binaries being identified as being infected on the target 
system.  These five binary files are:  du,  ifconfig, killall, ls, 
and pstree.  The check using known good binaries also 
indicates the following under the lkm check:   1 process 
hidden from readdir command, 15 processes hidden form ps 
command.  The differences between the output using known 
good binaries and the output using the binaries currently 
installed on the system indicate that the r.tgz rootkit 
modified some of the system binary files that are used by 
the chkrootkit program to check the system status.  As a 
result we can conclude that known good binaries should 
always be used while running the chkrootkit program.  The 
five files detected as being changed by the chkrootkit 
program are also detected as being changed by the AIDE 
file integrity checker program.  These results are used in our 