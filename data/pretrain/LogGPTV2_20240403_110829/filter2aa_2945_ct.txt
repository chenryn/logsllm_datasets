controls should still be evenly spaced and usable:
Download from finelybook PI:EMAIL
922
17. Click Rotate Counterclockwise to put the Simulator back to landscape
orientation, and then click Change Resolution and switch the resolution
of the Simulator to 2560 × 1400.
Notice that the controls remain evenly spaced on the form, although the
labels might be quite difficult to read unless you actually have a 27-inch
screen.
Download from finelybook PI:EMAIL
923
18. Click Change Resolution again and switch the resolution to 1024 × 768.
Again, notice how the spacing and size of the controls are adjusted to
maintain the even balance of the user interface:
19. In the Simulator, double-click the top edge of the form to restore the
view as a window, and then drag and resize the window so that the form
is displayed in the left half of the screen. Reduce the width of the
window to its minimum. This is how the app might appear on a device
such as a smartphone.
All the controls remain visible, but the text for the Phone label and the
title wrap, making them difficult to read, and the controls are not
particularly easy to use anymore:
Download from finelybook PI:EMAIL
924
20. In the Simulator, click the Start button, click Settings, click Power, and
then click Disconnect.
The Simulator closes, and you return to Visual Studio.
21. On the Visual Studio toolbar, in the Debug Target drop-down list box,
select Local Machine.
Adapting the layout by using the Visual State Manager
The user interface for the Customers app scales for different resolutions and
form factors, but it still does not work well if you reduce the width of the
view, and it probably would not look too good on a smartphone, which has an
even narrower width. If you think about it, the solution to the problem in
these cases is not so much a matter of scaling the controls as actually laying
them out in a different way. For example, it would make better sense if the
Customers form looked like this in a narrow view:
Download from finelybook PI:EMAIL
925
You can achieve this effect in several ways:
You can create several versions of the MainPage.xaml file, one for
each device family. Each of these XAML files can be linked to the
same code-behind (MainPage.xaml.cs) so that they all run the same
code. For example, to create an XAML file for a smartphone, add a
folder named DeviceFamily-Mobile (this name is important) to the
project and then add a new XAML view named MainPage.xaml to the
folder by using the Add New Item menu command. Lay out the
controls on this page folder as they should be displayed on a
smartphone. The XAML view will be linked automatically to the
existing MainPage.xaml.cs file. At runtime, the UWP will select the
appropriate view based on the type of device on which the app is
Download from finelybook PI:EMAIL
926
running.
You can use the Visual State Manager to modify the layout of the page
at runtime. All UWP apps implement a Visual State Manager that
tracks the visual state of an app. It can detect when the height and
width of the window changes, and you can add XAML markup that
positions controls depending on the size of the window. This markup
can move controls around or display and hide controls.
You can use the Visual State Manager to switch between views based
on the height and width of the window. This approach is a hybrid
combination of the first two options described here, but it is the least
messy (you don’t have to write lots of tricky code to calculate the best
position for each control) and is also the most flexible (it will work if
the window is narrowed on the same device).
You’ll follow the third of these approaches in the next exercises. The first
step is to define a layout for the customers’ data that should appear in a
narrow view.
Define a layout for the narrow view
1. In the XAML pane for the Customers app, add the x:Name and Visibility
properties shown below in bold to the nested Grid control:
Click here to view code image
    ...
This Grid control will hold the default view of the form. You will
reference this Grid control in other XAML markup later in this set of
exercises, hence the requirement to give it a name. The Visibility
property specifies whether the control is displayed (Visible) or hidden
(Collapsed). The default value is Visible, but for the time being, you will
hide this Grid while you define another for displaying the data in a
columnar format.
2. After the closing  tag for the customersTabularView Grid
Download from finelybook PI:EMAIL
927
control, add another Grid control. Set the x:Name property to
customersColumnarView, set the Margin property to 10,20,10,20, and
set the Visibility property to Visible.
Tip You can expand and contract elements in the XAML pane of
the Design View window and make the structure easier to read by
clicking the + and – signs that appear down the left edge of the
XAML markup.
Click here to view code image
    ...
This Grid control will hold the “narrow” view of the form. The fields in
this grid will be layed out in a columnar manner as described earlier.
3. In the customersColumnarView Grid control, add the following row
definitions:
Click here to view code image
You will use the top row to display the title and the second, much larger
row to display the controls in which users enter data.
Download from finelybook PI:EMAIL
928
4. Immediately after the row definitions, add the TextBlock control shown
below in bold. This control displays a truncated title, Customers, in the
first row of the Grid control. Set FontSize to 30.
Click here to view code image
    ...
5. Add another Grid control to row 1 of the customersColumnarView Grid
control, directly after the TextBlock control that contains the Customers
title. This Grid control will display the labels and data-entry controls in
two columns, so add the row and columns definitions shown in bold in
the following code example to this Grid.
Click here to view code image
Notice that if all the rows or columns in a set have the same height or
width, you do not need to specify their size.
6. Copy the XAML markup for the ID, Title, First Name, and Last Name
TextBlock controls from the customersTabularView Grid control to the
new Grid control, immediately after the row definitions that you just
added. Put the ID control in row 0, the Title control in row 1, the First
Download from finelybook PI:EMAIL
929
Name control in row 2, and the Last Name control in row 3. Place all
controls in column 0.
Click here to view code image
...
7. Copy the XAML markup for the id, title, firstName, and lastName
TextBox and ComboBox controls from the customersTabularView Grid
control to the new Grid control, immediately after the TextBox controls.
Put the id control in row 0, the title control in row 1, the firstName
control in row 2, and the lastName control in row 3. Place all four
controls in column 1. Also, change the names of the controls by
prefixing them with the letter c (for column). This final change is
necessary to avoid clashing with the names of the existing controls in
the customersTabularView Grid control.
Click here to view code image
Download from finelybook PI:EMAIL
930
8. Copy the TextBlock and TextBox controls for the email address and
telephone number from the customersTabularView Grid control to the
new Grid control, placing them after the cTitle ComboBox control. Place
the TextBlock controls in column 0, in rows 4 and 5, and the TextBox
controls in column 1, in rows 4 and 5. Change the name of the email
TextBox control to cEmail and the name of the phone TextBox control to
cPhone. Remove the Width properties of the cEmail and cPhone
controls, and set their HorizontalAlignment properties to Stretch.
Click here to view code image
...
The Design View window should display the columnar layout like this:
Download from finelybook PI:EMAIL
931
9. Return to the XAML markup for the customersTabularView Grid
control and set the Visibility property to Visible.
Click here to view code image
10. In the XAML markup for the customersColumnarView Grid control, set
the Visibility property to Collapsed.
Click here to view code image
The Design View window should display the original tabular layout of
the Customers form. This is the default view that will be used by the
app.
You have now defined the layout that will appear in the narrow view. You
might be concerned that in essence all you have done is duplicated many of
the controls and laid them out in a different manner. If you run the form and
switch between views, how will data in one view transfer to the other? For
Download from finelybook PI:EMAIL
932
example, if you enter the details for a customer when the app is running full
screen, and then you switch to the narrow view, the newly displayed controls
will not contain the same data that you just entered. UWP apps address this
problem by using data binding. This is a technique by which you can
associate the same piece of data to multiple controls, and as the data changes,
all controls display the updated information. You will see how this works in
Chapter 26. For the time being, you need to consider only how to use the
Visual State Manager to switch between layouts when the view changes.
You can use triggers that alert the Visual State Manager when some
aspect (such as the height or width) of the display changes. You can define
the visual state transitions performed by these triggers in the XAML markup
of your app. This is what you will do in the next exercise.
Use the Visual State Manager to modify the layout
1. In the XAML pane for the Customers app, after the closing  tag
for the customersColumnarView Grid control, add the following
markup:
Click here to view code image
    ...
You define the visual state transitions by implementing one or more
visual state groups. Each visual state group specifies the transitions that
should occur when the Visual State Manager switches to this state. Each
state should be given a meaningful name to help you identify its
purpose.
2. Add the following visual state trigger shown in bold to the visual state
group:
Click here to view code image
Download from finelybook PI:EMAIL
933
This trigger will fire whenever the width of the window drops below
660 pixels. This is the width at which the controls and labels on the
Customers form start to wrap and become difficult to use.
3. After the trigger definition, add the following code shown in bold to the
XAML markup:
Click here to view code image
This code specifies the actions that occur when the trigger is fired. In
this example, the actions are defined by using Setter elements. A Setter
element specifies a property to set and the value to which the property
should be set. For this view, the Setter commands change the values of
specified properties; the customersTabularView Grid control is made
visible and the customersColumnarView Grid control is collapsed (made
invisible).
4. After the TabularLayout visual state definition, add the following
markup which defines the equivalent functionality to switch to the
columnar view:
Click here to view code image
Download from finelybook PI:EMAIL
934
            ...
When the window width drops below 660 pixels, the app switches to the
ColumnarLayout state; the customersTabularView Grid control is
collapsed and the customersColumnarView Grid control is made visible.
5. In the toolbar, ensure that the Debug Target is set to Local Machine, and
then on the Debug menu, click Start Debugging.
The app starts and displays the Customer form full screen. The data is
displayed using the tabular layout.
Note If you are using a display with a resolution of less than 1366
× 768, start the app running in the Simulator as described earlier.
Configure the Simulator with a resolution of 1366 × 768.
6. Resize the Customer app window to display the form in a narrow view.
When the window width drops below 660 pixels, the display switches to
the columnar layout.
7. Resize the Customer app window to make it wider than 660 pixels (or
maximize it to full screen).
Download from finelybook PI:EMAIL
935
The Customer form reverts to the tabular layout.
8. Return to Visual Studio and stop debugging.
Applying styles to a UI
Now that you have the mechanics of the basic layout of the app resolved, the
next step is to apply some styling to make the UI look more attractive. The
controls in a UWP app have a varied range of properties that you can use to
change features such as the font, color, size, and other attributes of an
element. You can set these properties individually for each control, but this
approach can become cumbersome and repetitive if you need to apply the
same styling to a number of controls. Also, the best apps apply a consistent
styling across the UI, and it is difficult to maintain consistency if you have to
repeatedly set the same properties and values as you add or change controls.
The more times you have to do the same thing, the greater the chances are
that you will get it wrong at least once!
With UWP apps, you can define reusable styles. You can implement them
as app-wide resources by creating a resource dictionary, and then they are
available to all controls in all pages in an app. You can also define local
resources that apply to only a single page in the XAML markup for that page.
In the following exercise, you will define some simple styles for the
Customers app and apply these styles to the controls on the Customers form.
Define styles for the Customers form
1. In Solution Explorer, right-click the Customers project, point to Add,
and then click New Item.
2. In the Add New Item - Customers dialog box, click Resource
Dictionary. In the Name box, type AppStyles.xaml, and then click Add.
The AppStyles.xaml file appears in the Code and Text Editor window. A
resource dictionary is an XAML file that contains resources that the app
can use. The AppStyles.xaml file looks like this:
Click here to view code image
Styles are one example of a resource, but you can also add other items.
In fact, the first resource that you will add is not actually a style but an
ImageBrush that will be used to paint the background of the outermost
Grid control on the Customers form.
3. In Solution Explorer, right-click the Customers project, point to Add,