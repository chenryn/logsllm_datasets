adt/oracle_compat.c:    ret = (text *) palloc(VARHDRSZ + bytelen);  
adt/oracle_compat.c:    ret = (text *) palloc(VARHDRSZ + bytelen);  
adt/oracle_compat.c:                    stringchars = (const char **) palloc(stringlen * sizeof(char *));  
adt/oracle_compat.c:                    stringmblen = (int *) palloc(stringlen * sizeof(int));  
adt/oracle_compat.c:                    setchars = (const char **) palloc(setlen * sizeof(char *));  
adt/oracle_compat.c:                    setmblen = (int *) palloc(setlen * sizeof(int));  
adt/oracle_compat.c:    ret = (bytea *) palloc(VARHDRSZ + m);  
adt/oracle_compat.c:    result = (text *) palloc(worst_len + VARHDRSZ);  
adt/oracle_compat.c:            result = (text *) palloc(VARHDRSZ + bytes);  
adt/oracle_compat.c:            result = (text *) palloc(VARHDRSZ + 1);  
adt/oracle_compat.c:    result = (text *) palloc(tlen);  
...  
adt/tsvector.c:                                 repalloc(res->pos, newlen * sizeof(WordEntryPos));  
adt/tsvector.c: arr = (WordEntryIN *) palloc(sizeof(WordEntryIN) * arrlen);  
adt/tsvector.c: cur = tmpbuf = (char *) palloc(buflen);  
adt/tsvector.c:                         repalloc((void *) arr, sizeof(WordEntryIN) * arrlen);  
adt/tsvector.c:                 tmpbuf = (char *) repalloc((void *) tmpbuf, buflen);  
adt/tsvector.c: in = (TSVector) palloc0(totallen);  
adt/tsvector.c: curout = outbuf = (char *) palloc(lenbuf);  
adt/tsvector.c: vec = (TSVector) palloc0(len);  
adt/tsvector.c:                 vec = (TSVector) repalloc(vec, len);  
adt/tsvector.c:                  * Pad to 2-byte alignment if necessary. Though we used palloc0  
adt/tsvector.c:                  * for the initial allocation, subsequent repalloc'd memory areas  
...  
arrayfuncs.c:   dataPtr = (Datum *) palloc(nitems * sizeof(Datum));  
arrayfuncs.c:   nullsPtr = (bool *) palloc(nitems * sizeof(bool));  
arrayfuncs.c:   retval = (ArrayType *) palloc0(nbytes);  
...  
varlena.c:              sss = palloc(sizeof(VarStringSortSupport));  
varlena.c:              sss->buf1 = palloc(TEXTBUFLEN);  
varlena.c:              sss->buf2 = palloc(TEXTBUFLEN);  
varlena.c:                      sss->buf1 = palloc(sss->buflen1);  
varlena.c:                      sss->buf2 = palloc(sss->buflen2);  
varlena.c:      result = (bytea *) palloc(len);  
varlena.c:      res = (bytea *) palloc(VARSIZE(v));  
...  
-rw-r--r-- 1 digoal users 137344 Oct 25 04:08 acl.c  
-rw-r--r-- 1 digoal users   9269 Oct 25 04:08 amutils.c  
-rw-r--r-- 1 digoal users  13270 Oct 25 04:08 array_expanded.c  
-rw-r--r-- 1 digoal users 173266 Oct 25 04:08 arrayfuncs.c  
-rw-r--r-- 1 digoal users  33193 Oct 25 04:08 array_selfuncs.c  
-rw-r--r-- 1 digoal users  26170 Oct 25 04:08 array_typanalyze.c  
-rw-r--r-- 1 digoal users  25379 Oct 25 04:08 array_userfuncs.c  
-rw-r--r-- 1 digoal users   5742 Oct 25 04:08 arrayutils.c  
-rw-r--r-- 1 digoal users   4732 Oct 25 04:08 ascii.c  
-rw-r--r-- 1 digoal users   8139 Oct 25 04:08 bool.c  
-rw-r--r-- 1 digoal users  23931 Oct 25 04:08 cash.c  
-rw-r--r-- 1 digoal users   4442 Oct 25 04:08 char.c  
-rw-r--r-- 1 digoal users  64563 Oct 25 04:08 date.c  
-rw-r--r-- 1 digoal users 126062 Oct 25 04:08 datetime.c  
-rw-r--r-- 1 digoal users  10976 Oct 25 04:08 datum.c  
-rw-r--r-- 1 digoal users  23215 Oct 25 04:08 dbsize.c  
-rw-r--r-- 1 digoal users  10602 Oct 25 04:08 domains.c  
-rw-r--r-- 1 digoal users  10868 Oct 25 04:08 encode.c  
-rw-r--r-- 1 digoal users  12361 Oct 25 04:08 enum.c  
-rw-r--r-- 1 digoal users   3930 Oct 25 04:08 expandeddatum.c  
-rw-r--r-- 1 digoal users  82658 Oct 25 04:08 float.c  
-rw-r--r-- 1 digoal users 136395 Oct 25 04:08 formatting.c  
-rw-r--r-- 1 digoal users  11978 Oct 25 04:08 format_type.c  
-rw-r--r-- 1 digoal users  11402 Oct 25 04:08 genfile.c  
-rw-r--r-- 1 digoal users 124438 Oct 25 04:08 geo_ops.c  
-rw-r--r-- 1 digoal users   2316 Oct 25 04:08 geo_selfuncs.c  
-rw-r--r-- 1 digoal users  18718 Oct 25 04:08 geo_spgist.c  
-rw-r--r-- 1 digoal users   6491 Oct 25 04:08 inet_cidr_ntop.c  
-rw-r--r-- 1 digoal users  12305 Oct 25 04:08 inet_net_pton.c  
-rw-r--r-- 1 digoal users  32342 Oct 25 04:08 int8.c  
-rw-r--r-- 1 digoal users  30325 Oct 25 04:08 int.c  
-rw-r--r-- 1 digoal users  47499 Oct 25 04:08 jsonb.c  
-rw-r--r-- 1 digoal users  15766 Oct 25 04:08 jsonb_gin.c  
-rw-r--r-- 1 digoal users   6007 Oct 25 04:08 jsonb_op.c  
-rw-r--r-- 1 digoal users  50741 Oct 25 04:08 jsonb_util.c  
-rw-r--r-- 1 digoal users  64390 Oct 25 04:08 json.c  
-rw-r--r-- 1 digoal users 102478 Oct 25 04:08 jsonfuncs.c  
-rw-r--r-- 1 digoal users  12710 Oct 25 04:08 levenshtein.c  
-rw-r--r-- 1 digoal users  10743 Oct 25 04:08 like.c  
-rw-r--r-- 1 digoal users   9815 Oct 25 04:08 like_match.c  
-rw-r--r-- 1 digoal users  24444 Oct 25 04:08 lockfuncs.c  
-rw-r--r-- 1 digoal users   6792 Oct 25 04:08 mac.c  
-rw-r--r-- 1 digoal users  22403 Oct 25 04:08 misc.c  
-rw-r--r-- 1 digoal users  37550 Oct 25 04:08 nabstime.c  
-rw-r--r-- 1 digoal users   6947 Oct 25 04:08 name.c  
-rw-r--r-- 1 digoal users  31667 Oct 25 04:08 network.c  
-rw-r--r-- 1 digoal users  22779 Oct 25 04:08 network_gist.c  
-rw-r--r-- 1 digoal users  32861 Oct 25 04:08 network_selfuncs.c  
-rw-r--r-- 1 digoal users 213004 Oct 25 04:08 numeric.c  
-rw-r--r-- 1 digoal users   9498 Oct 25 04:08 numutils.c  
-rw-r--r-- 1 digoal users   9911 Oct 25 04:08 oid.c  
-rw-r--r-- 1 digoal users  22636 Oct 25 04:08 oracle_compat.c  
-rw-r--r-- 1 digoal users  38316 Oct 25 04:08 orderedsetaggs.c  
-rw-r--r-- 1 digoal users  41158 Oct 25 04:08 pg_locale.c  
-rw-r--r-- 1 digoal users   4446 Oct 25 04:08 pg_lsn.c  
-rw-r--r-- 1 digoal users  47784 Oct 25 04:08 pgstatfuncs.c  
-rw-r--r-- 1 digoal users   4902 Oct 25 04:08 pg_upgrade_support.c  
-rw-r--r-- 1 digoal users  14691 Oct 25 04:08 pseudotypes.c  
-rw-r--r-- 1 digoal users   2697 Oct 25 04:08 quote.c  
-rw-r--r-- 1 digoal users  61530 Oct 25 04:08 rangetypes.c  
-rw-r--r-- 1 digoal users  43048 Oct 25 04:08 rangetypes_gist.c  
-rw-r--r-- 1 digoal users  33892 Oct 25 04:08 rangetypes_selfuncs.c  
-rw-r--r-- 1 digoal users  29503 Oct 25 04:08 rangetypes_spgist.c  
-rw-r--r-- 1 digoal users  10402 Oct 25 04:08 rangetypes_typanalyze.c  
-rw-r--r-- 1 digoal users  34862 Oct 25 04:08 regexp.c  
-rw-r--r-- 1 digoal users  48615 Oct 25 04:08 regproc.c  
-rw-r--r-- 1 digoal users 105191 Oct 25 04:08 ri_triggers.c  
-rw-r--r-- 1 digoal users  48261 Oct 25 04:08 rowtypes.c  
-rw-r--r-- 1 digoal users 287720 Oct 25 04:08 ruleutils.c  
-rw-r--r-- 1 digoal users 225938 Oct 25 04:08 selfuncs.c  
-rw-r--r-- 1 digoal users   9692 Oct 25 04:08 tid.c  
-rw-r--r-- 1 digoal users 141798 Oct 25 04:08 timestamp.c  
-rw-r--r-- 1 digoal users   3152 Oct 25 04:08 trigfuncs.c  
-rw-r--r-- 1 digoal users  10077 Oct 25 04:08 tsginidx.c  
-rw-r--r-- 1 digoal users  18599 Oct 25 04:08 tsgistidx.c  
-rw-r--r-- 1 digoal users  25739 Oct 25 04:08 tsquery.c  
-rw-r--r-- 1 digoal users  14812 Oct 25 04:08 tsquery_cleanup.c  
-rw-r--r-- 1 digoal users   6232 Oct 25 04:08 tsquery_gist.c  
-rw-r--r-- 1 digoal users   7431 Oct 25 04:08 tsquery_op.c  
-rw-r--r-- 1 digoal users   8804 Oct 25 04:08 tsquery_rewrite.c  
-rw-r--r-- 1 digoal users   8621 Oct 25 04:08 tsquery_util.c  
-rw-r--r-- 1 digoal users  21322 Oct 25 04:08 tsrank.c  
-rw-r--r-- 1 digoal users  12304 Oct 25 04:08 tsvector.c  
-rw-r--r-- 1 digoal users  53573 Oct 25 04:08 tsvector_op.c  
-rw-r--r-- 1 digoal users   9259 Oct 25 04:08 tsvector_parser.c  
-rw-r--r-- 1 digoal users  13295 Oct 25 04:08 txid.c  
-rw-r--r-- 1 digoal users   9732 Oct 25 04:08 uuid.c  
-rw-r--r-- 1 digoal users  42245 Oct 25 04:08 varbit.c  
-rw-r--r-- 1 digoal users  24654 Oct 25 04:08 varchar.c  
-rw-r--r-- 1 digoal users 136176 Oct 25 04:08 varlena.c  
-rw-r--r-- 1 digoal users    491 Oct 25 04:08 version.c  
-rw-r--r-- 1 digoal users  10358 Oct 25 04:08 windowfuncs.c  
-rw-r--r-- 1 digoal users   4645 Oct 25 04:08 xid.c  
-rw-r--r-- 1 digoal users 104105 Oct 25 04:08 xml.c  
```  
比如字符串，数组，全文检索，这些属于变长类型，最长允许1GB，在申请内存时，根据被处理的值的实际的大小申请。  
## cgroup例子  
为了方便在一台物理机中启动多个实例，隔离资源，使用cgroup是一个很不错的方法。    
```  
# mount -t cgroup -o cpu,memory cpu_and_mem /cgroup/memory  
# cd /cgroup/memory  
# mkdir test  
# cd test  
# echo 102400000 > memory.limit_in_bytes  
# echo 102400000 > memory.memsw.limit_in_bytes  
```  
把实例进程号写入tasks即可。  
为了测试方便，我这里限制了100MB， 并且只将测试会话的backend process加入tasks  
```  
postgres=# select pg_backend_pid();  
 pg_backend_pid   
----------------  
          85938  
(1 row)  
```  
```  
# echo 85938 > tasks   
```  
查看当前状态  
```  
# cat memory.stat   
cache 204800  
rss 0  
mapped_file 0  
pgpgin 974906  
pgpgout 974856  
swap 0  
inactive_anon 155648  
active_anon 0  
inactive_file 49152  
active_file 0  
unevictable 0  
hierarchical_memory_limit 102400000  
hierarchical_memsw_limit 102400000  
total_cache 204800  
total_rss 0  
total_mapped_file 0  
total_pgpgin 974906  
total_pgpgout 974856  
total_swap 0  
total_inactive_anon 155648  
total_active_anon 0  
total_inactive_file 49152  
total_active_file 0  
total_unevictable 0  
```  
## 模拟数据库进程被OOM  
因为限制了100MB，所以这个数据库backend process需要申请超过100MB的内存，才会被OOM。  
根据前面讲的，排序、聚合、使用较大的列、使用很长的SQL（值SQL本身的内容长度），或者传入很大的变长类型值时，都可能使得单个连接就会消耗很大的内存。    