570 常见的，可以安全地放在HTTP首部字段中。这64个字符中包含大小写字母、数
字、+和/，还使用了特殊字符=。表E-1显示了Base-64的字母表。
注意，由于Base-64编码用了8位字符来表示信息中的6个位，所以Base-64编码
字符串大约比原始值扩大了33%。
表E-1 Base-64字母表
0 A 8 I 16 Q 24 Y 32 g 40 o 48 w 56 4
1 B 9 J 17 R 25 Z 33 h 41 p 49 x 57 5
2 C 10 K 18 S 26 a 34 i 42 q 50 y 58 6
3 D 11 L 19 T 27 b 35 j 43 r 51 z 59 7
4 E 12 M 20 U 28 c 36 k 44 s 52 0 60 8
5 F 13 N 21 V 29 d 37 l 45 t 53 1 61 9
6 G 14 O 22 W 30 e 38 m 46 u 54 2 62 +
7 H 15 P 23 X 31 f 39 n 47 v 55 3 63 /
注1： 有些邮件网关会悄悄地去除ASCII值在0～31之间的“非打印”字符。其他程序会将一些字节作为
流量控制字符或其他特殊控制字符来解释，或将回车符转换成换行符之类的字符。有些程序在收到带
有值大于127的国际字符时会出现致命的错误，因为其软件不是“8位干净”（8-bitclean）的。
604 ｜ 附录E
图E-1是一个简单的Base-64编码实例。在这里，三个字符组成的输入值“Ow!”
是Base-64编码的，得到的是4个字符的Base-64编码值“T3ch”。它是按以下方式
工作的。
（1）字符串“Ow!”被拆分成3个8位的字节（0x4F、0x77、0x21）。
（2）这3个字节构成了一个24位的二进制值010011110111011100100001。
（3）这些位被划分为一些6位的序列010011、110111、01110、100001。
（4） 每个6位值都表示了从0～63之间的一个数字，对应Base-64字母表中64个
字符之一。得到的Base-64编码字符串是个4字符的字符串“T3ch”，然后就可
以通过线路将这个字符串作为“安全的”8位字符传送出去，因为只用了一些
移植性最好的字符（字母、数字等）。
O w !
8位字符
$4F $77 $21
8位值（十六进制）
010011110111011100100001
8位值（二进制）
19 55 28 33
6位值（十进制）
T 3 c h
Base-64字符
图E-1 Base-64编码实例 571
E.3 Base-64填充
Base-64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进
制序列有时不能正好平均地分成6位的块，在这种情况下，就在序列末尾填充零位，
使二进制序列的长度成为24的倍数（6和8的最小公倍数）。
对已填充的二进制串进行编码时，任何完全填充（不包含原始数据中的位）的6位
组都由特殊的第65个符号“=”表示。如果6位组是部分填充的，就将填充位设置
为0。
表E-2显示了一些填充实例。初始输入字符串“a:a”为3字节（24位）。24是6和
8的倍数，因此无需填充，得到的Base-64编码字符串为“YTph”。
Base-64编码 ｜ 605
表E-2 Base-64填充实例
输入数据 二进制序列（填充位以x表示） 已编码数据
a:a 011000 010011 101001 100001 YTph
a:aa 011000 010011 101001 100001 011000 01xxxx xxxxxx xxxxxx YTphYQ==
a:aaa 011000 010011 101001 100001 011000 010110 0001xx xxxxxx YTphYWE=
a:aaaa 011000 010011 101001 100001 011000 010110 000101 100001 YTphYWFh
然而，再增加一个字符，输入字符串会变成32位长。而6和8的下一个公倍数是
48，因此要添加16位的填充码。填充的前4位是与数据位混合在一起的。得到的
6位组01xxxx，会被当作010000、十进制中的16，或者Base-64编码的Q来处理。
剩下的两个6位组都是填充码，用“=”表示。
E.4 Perl实现
MIME::Base64是Perl中的Base-64编/解码模块。可以在http://www.perldoc.com/
perl5.6.1/lib/MIME/Base64.html上看到有关这个模块的内容。
572 可以用MIME::Base64 encode_base64和decode_base64方法对字符串进行编解码：
use MIME::Base64;
$encoded = encode_base64('Aladdin:open sesame');
$decoded = decode_base64($encoded);
E.5 更多信息
更多有关Base-64编码的信息，参见以下信息。
http://www.ietf.org/rfc/rfc2045.txt
RFC 2045的第6.8节，“MIME Part 1: Format of Internet Message Bodies,”（MIME
的第一部分：因特网报文主体的格式），是Base-64编码的官方规范。
http://www.perldoc.com/perl5.6.1/lib/MIME/Base64.html
这个Web站点提供了对Base-64字符串进行编/解码的MIME::Base64 Perl模块的
573 文档。
606 ｜ 附录E
附录F
摘要认证
607
本附录包含了实现HTTP摘要认证功能所需的支撑数据和源代码。
F.1 摘要WWW-Authenticate指令
表F-1根据RFC 2617中的描述，对WWW-Authenticate指令进行了说明。与往常
一样，最新细节请参见官方规范。
表F-1 （来自RFC 2617的）摘要WWW-Authenticate首部指令
指 令 描 述
realm 显示给用户的字符串，这样用户就可以知道该使用哪个用户名和密码了。这个字符串中
至少应该包含执行认证功能的主机名字，此外可能还会说明可能拥有访问权的用户的集
合。例如，PI:EMAIL
nonce 服务器特有的数据字符串，每次产生一个401响应时都应该生成一个唯一的数据字符
串。建议这个字符串为Base-64或十六进制数据。需要特别说明的是，由于此字符串是
放在首部行中作为引用字符串传送的，所以不允许使用双引号。
nonce的内容是与实现有关的。实现的质量取决于选择是否合适。比如，可以将nonce
构造成以下内容的Base-64编码：
time-stamp H(time-stamp ":" ETag ":" private-key)
其中time-stamp是服务器生成的时间或其他不重复的数值，ETag是与所请求实体有
关的HTTP ETag首部的值，private-key是只有服务器知道的数据。使用这种形式
的nonce，服务器会在收到客户端的Authentication首部之后重新对散列部分进行
计算，如果与该首部的nonce不符，或者时间戳的值不够近，就可以拒绝请求。通过这
种方式，服务器可以限制nonce的有效时间。包含ETag可以防止对资源更新版本的重
放请求。（注意：在nonce中包含客户端的IP地址，看起来好像为服务器提供了限制最
初获得此nonce的客户端重用nonce的能力，但这样会破坏代理集群，来自单个用户的
请求通常都会经过集群中不同的代理进行传输。而且，IP地址欺骗也不是很难。）
实现可以选择不接受以前用过的nonce，或以前用过的摘要，以防止重放攻击，或者选
574 择为POST或PUT请求使用一次性nonce或摘要，为GET请求使用时间戳
domain 一个引用的、由空格分隔的URI列表（如RFC 2396，“Uniform Resource Identifiers:
GenericSyntax”所述），这些URI定义了保护空间。如果URI是个abs_path，它就是相
对于受访服务器的典型根URL的。这个列表中的绝对URI所指的服务器可能不是受访
服务器。
客户端可以用这个列表来判定应该将同样的认证信息发送给哪个URI集：可以假定所有
以此列表中的URI作为前缀的URI（在将两者都转换为绝对URI之后）都位于同一个
保护空间内。
如果省略了这条指令，或者其值为空，客户端就应该假定保护空间中包含了响应服务器
上的所有URI。
这条指令在Proxy-Authenticate首部是无意义的，此时，保护空间总是包括整个代
理；如果提供了这条指令，也应该将其忽略
608 ｜ 附录F
（续）
指 令 描 述
opaque 一个由服务器指定的数据串，应该由客户端不经修改地放在后继请求的Authorization
首部中返回，这些后继请求应使用同一保护空间内的URI。建议这个字符串采用Base-64
或十六进制的数据
stale 一个标志，用来说明由于nonce值太过陈旧，前一条来自客户端的请求被拒绝了。如
果stale为TRUE（不区分大小写），客户端可能希望以新加密的响应重试请求，而不用
再次提示用户输入新的用户名和密码。只有在服务器收到一条nonce无效，但摘要有效
的请求（说明客户端知道正确的用户名/密码）时，才应该将stale设置为TRUE。如果
stale为FALSE，或者除TRUE之外的其他值，或者没有提供stale指令，用户名和/或
密码就是无效的，需要获取新的值
algorithm 一个字符串，说明了一对儿用来生成摘要和校验码的算法。如果没有提供这个字符串，
就假定它为“MD5”。如果不识别此算法，就忽略这种质询（如果有多个算法的话，就
使用另外一个）。
在这份文档中，用“KD(secret,data)”来表示用密码“secret”对数据“data”使用
摘要算法得到的字符串，而对数据“data”使用校验和算法得到的字符串则表示为
“H(data)”。表示法“unq(X)”表示引用字符串“X”的值（不包含左右两边的引号）。
对MD5和MD5-sess算法来说：
H(data) = MD5(data)
HD(secret, data) = H(concat(secret, ":", data))
也就是说，摘要就是将密码的MD5与冒号和数据连接在一起。MD5-sess算法目的是支
持使用高效的第三方认证服务器
qop 这条指令是可选的，只是为了与RFC 2069[6]后向兼容才保留的。所有与此版本的摘要
方案兼容的实现都应该使用它。
如果提供了这条指令，它就是由一个或多个标记构成的引用字符串，用来说明服务器所
支持的“安全保障”值。值auth说明要进行认证，值auth-int说明要进行具有完整性保
护的认证。一定要忽略那些不识别的选项
 未来可以通过这条指令进行扩展。要忽略所有不认识的指令
F.2 摘要Authorization指令
表F-2根据RFC 2617的描述，对每条摘要Authorization指令都进行了说明。最
新的细节请参见官方规范。 575
表F-2 （来自RFC 2617的）摘要Authorization首部指令
指 令 描 述
username 指定域中的用户名
realm 在WWW-Authenticate首部中传送给客户端的域
摘要认证 ｜ 609
（续）
指 令 描 述
nonce 在WWW-Authenticate首部中传送给客户端的那个与服务器相同的nonce
uri 来自请求行请求URI中的URI。由于代理可以在传输中修改请求行，所以会出现
重复。进行正确的摘要验证计算可能需要原始URI
response 这个就是实际的摘要——摘要认证的重点！响应是一个由32个十六进制数字组
成的字符串，由沟通好的摘要算法生成，用来证明用户知道这个密码
algorithm 一个字符串，说明了用来生成摘要和校验和的一对儿算法。如果未提供，就将其
假定为MD5
opaque 服务器在WWW-Authenticate首部指定的数据串，应该由客户端不经修改地在
后继请求的WWW-Authenticate首部中返回，这个请求应使用同一保护空间内
的URI
cnonce 如果发送了qop指令，就一定要使用这条指令，如果服务器没有在WWW-Authenticate
首部字段中发送qop指令，就一定不能使用这条指令。
cnonce值是客户端提供的不透明引用字符串值，客户端和服务器都用它来避免选
择明文攻击，以提供双向认证以及一些报文一致性检查。
参见本附录稍后介绍的响应摘要和请求摘要计算
qop 说明客户端对报文应用的“安全保障”是什么。如果提供了这条指令，它的值就
必须是服务器在WWW-Authenticate首部中说明的、它支持的可选值之一。这
些值会影响请求摘要的计算方式。
它只是个单独的标记，而不是WWW-Authenticate中那样的可选值引用列表。
这条指令是可选的，以保持对RFC 2069最小实现的后向兼容，但如果服务器说
明它是通过在WWW-Authenticate首部字段中提供qop指令来支持qop的，就
应该使用这条指令
nc 如果发送了qop指令，就一定要指定这条指令，如果服务器没有在WWW-
Authenticate首部字段中发送qop指令，就一定不能使用这条指令。
其值是个十六进制值，表示客户端已经发送的包含nounce值的请求次数（包括
当前请求在内）。比如，作为对指定nonce值的响应发送的第一条请求中，客户
端会发送nc="00000001"。
这条指令的目的是允许服务器通过维护自己保存的此计数值副本来发现请求重
放——如果看到了两次相同的nc值，就说明请求是重放的
 未来可以通过这条指令进行扩展。所有不认识的指令都要忽略掉
F.3 摘要Authentication-Info指令
表F-3根据RFC 2617的描述，对每条Authentication-Info指令都进行了说明。
576 最新的细节请参见官方规范。
610 ｜ 附录F
表F-3 （来自RFC 2617的）摘要Authentication-Info首部指令
指 令 描 述
nextnonce nextnonce指令的值是服务器希望客户端为未来的认证响应使用的nonce。服务器
可能会发送带有nextnonce字段的Authentication-Info首部，作为实现一
次性nonce或修改nonce的手段。如果提供了nextnonce字段，客户端在为下一
条请求构建Authorization首部时就应该使用它。客户端如果没能做到，就会
收到来自服务器的"stale=TRUE"认证请求。
服务器实现应该仔细地考虑使用这种机制带来的性能影响。如果每条响应都包含
了必须在服务器接收的下一条请求中使用的nextnounce指令，就不可能使用管道
化请求了。应该考虑在性能和安全之间进行一些平衡，允许在有限的时间内使用
老的nonce值，以实现请求的管道化。使用nounce计数可以在不影响管道化的
情况下，维护一个新的服务器nonce的大部分安全优势
qop 说明了服务器应用到响应上的“安全保障”选项。值auth说明要进行认证，值
auth-int说明要进行带有完整性保护的认证。服务器在响应中使用的qop指令值
应该与客户端在相应请求中发送的值相同
rspauth response auth指令中的可选响应摘要支持双向认证——服务器证明了它知道用户
的密码，而且通过qop="auth-int"，它还为响应提供了有限的完整性保护。
除了当qop="auth"或者没有在Authorization首部为请求指定qop的情