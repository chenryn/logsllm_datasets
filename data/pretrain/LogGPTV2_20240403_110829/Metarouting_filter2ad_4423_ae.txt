route from one of its customers, then I will treat it as a
provider route. This algebra is not M, but we can transform
it to an M algebra by application of the fm operator to
obtain
⊕ C R P
c C φ
φ
r R R φ
p
P
P
P
φ
φ
φ
φ
which is very similar to the standard customer/peer/provider
rules. For example, c⊕ R = φ can be read as follows: a cus-
tomer cannot send one of its peer routes to a provider (or
a provider cannot accept a customer’s peer routes). In fact,
our table is more general than the rules of [6, 25] in that
r ⊕ R = R and not φ. Note that our relationships can be
implemented on a per preﬁx basis, since the labels of our al-
gebra are conditional/sequential “programs” over the labels
{c, r, p} (we are using the prog operator). In other words,
using the generic operators of RAML, we are able to easily
obtain results more general than those of [6, 25] for a model
of BGP that captures more detail of the actual protocol.
In addition, we see that in the context of the deﬁnition of
the routing algebra for EBGP (Figure 5), we only need this
to be M for the entire expression to be SM — that is, we
don’t have to assume that there are no customer/provider
cycles in the relationship graph as is done [6]. Such cycles,
although odd, really pose no problems for convergence.
Instead of forcing monotonicity, let us instead try lifting to
monotonicity. Table 5 presents the ⊕ table for lm(2, lp(3)),
with labels and signatures renamed as above. This is very
similar to the scheme presented in [9] to model BGP with
backup routes. That model required an entire appendix of
tedious correctness proofs. Here we merely apply a generic
operator. In addition, our resulting algebra is more general,
and includes useful cases that are eliminated in [9]. For
example, the rule
c ⊕ (1, P ) = (2, C)
means that a provider can take a route from a customer that
the customer is getting from one of its providers (creating
a “valley” in the AS path). Of course the level number is
increased making the route less preferred. But this would ac-
tually represent a potential revenue source for the customer,
or a viable emergency routing plan. This type of arrange-
ment is very diﬃcult to implement in BGP today. If this
sort of transit is not appropriate in a given AS, then ﬁlters
can be applied to ensure that this cannot happen (remem-
ber, we have the prog operator providing programmable
labels). However, this does seem to provide more ﬂexibil-
ity than most implementations today — and this represents
potential revenues to ISP.
In fact, there is no reason to force a choice between these
options, we could combine them into this locpref replace-
ment:
class : fm(lp(3)) t(x)=h1, xi lclass : lm(k, lp(3))
This would allow operators to combine these approaches as
they see ﬁt.
Due to space reasons we do not model IBGP in this paper.
However, observe that the scoped product operator provides
more structure than exists in the current design of BGP. For
example, in a RAML model of BGP, all IBGP elements re-
side in the second component of the scoped product and do
not “leak into” the ﬁrst component. Contrast this with the
current BGP design where elements such as the ASPATH for
confederations are hacked into the EBGP component, even
though they are a part of IBGP. With the scoped product
we would naturally deﬁne a new attribute for BGP confed-
eration ASPATHs, and the length of this path could then
be used in the EBGP route selection process. As with the
MyIGP example, a new community set needs to be deﬁned
for IBGP, which is not the same as the EBGP community
attribute, and this internal community set would automat-
ically vanish at AS boundaries. This actually corresponds
closely with common practice among network operators in
making a sharp distinction between internal and external
communities values.
6. LABEL MODALITIES
So far the labels have been fairly abstract objects associ-
ated with arcs between nodes. However, in the world of real
protocols it matters how a label gets attached to the net-
work model. This is especially true when two routers that
share an adjacency but reside in diﬀerent administrative do-
mains — this requires some type of cooperation to construct
labels.
Import policy of N
Export policy of M
N
λN ; λM
M
Figure 6: Construction of shared labels.
One way to accomplish this using sequential lables is il-
lustrated in Figure 6. Here we imagine that nodes N and M
are in diﬀerent administrative domains. We would expect
that the label on the link from N to M would be some-
how constructed by both N and M — or more precisely, by
information from the conﬁguration of N and from the con-
ﬁguration of M . If λN can be constructed from information
at N , and λM can be constructed from information at M ,
then (λN ; λM ) ⊕ σ = λN ⊕ (λM ⊕ σ) represents the com-
position of these policies. That is, λN represents an import
policy at N , and λM represents an export policy at M .
The details of how this information is presented in con-
ﬁguration associated with N and M , and how these policies
are applied are interesting implementation issues, but be-
yond the scope of the current paper. However, we note that
some protocols may require that the export and import rules
deﬁne a single “atomic” label, not a sequential label. For
example, for our model of BGP (Section 5) a sequential la-
bel would involve adding two ASNs to an ASPATH at each
AS boundary, rather than one. It is primarily for this type
of situation that we introduce the notion of a label modality.
λ
λ
(a) local 
(b) peer
λ
λ
λ
λ
(c) local nodal
(d) peer nodal
Figure 7: Four label modalities.
Figure 7 illustrates the four major label modalities. In this
ﬁgure, each ﬁlled circle represents the router that controls
the value of λ associated with the adjacent arc(s). That
is, the conﬁguration of the router represented by the ﬁlled
circle will produce the associated λ.
Modalities can be associated with individual named at-
tributes of a signature. Using BGP as an example, the
locpref attribute is an example of a local modality — the
receiver of the route attaches the label. On the other hand,
med is an example of Figure 7(b), called a peer modality
— the sender of a route attaches the label. The aspath at-
tribute is built up from AS numbers that are conﬁgured at
each node, and as with med, the sender attaches the label.
However, in this case we will insist that the sender uses the
same AS number for all of its BGP sessions, and we call this
a peer nodal modality. The origin attribute provides an ex-
ample of the local nodal modality — the label is local, but
the same value must be used in all sessions. Other modalities
are also useful. For example, the constant modality (always
use a ﬁxed label), and the default modality (which label to
use when one is not supplied by conﬁguration).
7. DISCUSSION AND OPEN PROBLEMS
We are currently implementing a metarouting prototype
in the XORP system, which will be described elsewhere. We
are implementing two distinct approaches. In the ﬁrst ap-
proach, we simply “hijack” BGP. Additional (optional) at-
tributes are deﬁned for updates, which are suﬃciently rich
in structure that they can be used to describe routes for any
routing algebras deﬁned in RAML. The particular algebra
being used by an operator is deﬁned in the router’s conﬁgu-
ration ﬁle and then bound to the appropriate BGP peering
sessions. At session initiation, capabilities negotiation in-
cludes a check that the same algebra is being used on each
end of the session. Of course users are then restricted to
using the hard-state, path-vector mechanism of BGP. Our
second approach is a bit more ambitious — it will allow users
to select not only the routing policy language, but to select
mechanisms from a collection of link-state and path-vector
implementations and then bind these to routing adjacencies.
The routing algebra metalanguage (RAML) presented in
this paper does not represent the only possible choice of base
algebras and algebraic operators. Our main design concerns
were the ability to express most interesting routing protocols
while at the same time retaining the ability to automatically
derive monotonicity properties for each algebraic expression
in the language. This raises many interesting research ques-
tions. For example, is there a natural set of base algebras and
operators? We would also like to explore RAML operators
that preserve the isotonicity properties required of algebras
that use a generalized version Dijkstra’s algorithm. We sus-
pect that a deeper understanding of the semantics of routing
policy metalanguages is required for exploring this and re-
lated questions. Intuition suggests that the more expressive
an RAML is, the more diﬃcult it will be to automatically
determine such global properties (see also [8]).
The RAML should probably include a means of abstrac-
tion over algebras having a speciﬁed monotonicity property.
For example, we deﬁned the BGP routing algebra as
BGPA = EBGPA ⊗ IBGPA,
but we imagine the IBGP component does not actually have
to be a part of the global protocol deﬁnition. That is, BGP’s
policy component could be speciﬁed as
BGPA(B : SM ) = EBGPA ⊗ B,
where B is a variable ranging over all SM routing algebras
— each network could potentially instantiate BGP with a
diﬀerent IBGP.
We have used lexicographic preference on products, but
other approaches may prove useful as well. It is interesting
to compare the algebra
add(1, n) ⊗ width(m),
with the (default) policy of EIGRP [23]. In both cases signa-
tures are pairs of the form hd, bi, were d represents distance
and b represents bandwidth, and ⊕ is deﬁned as
hd1, b1i ⊕ hd2, b2i = hd1 + d2, min(b1, b2)i
However, our deﬁnition uses lexical ordering while EIGRP
computes a derived weight, d + k/b, for each signature hd, bi
(k is a conﬁgured constant).
If the ﬁrst component, d, is
strictly greater than zero, then the algebra is SM, and if
the ﬁrst component can be zero then the algebra is only M
(see [25] for another discussion of EIGRP). It may be pos-
sible to extend RAML with product signatures that do not
use lexical preference, but instead base preference on poly-
nomial expressions (as with EIGRP). The diﬃculty seems
to be ﬁnding the right combination of polynomial opera-
tors that lend themselves well to an automatic derivation of
monotonicity preservation properties.
Routing security is another possible extension to RAML.
Security-related extensions to BGP have been deﬁned in
SBGP [16]. We feel these are needed extensions, but they
are being integrated into monolithic protocol implementa-
tions that provide for little or no reuse between protocols.
Can generic security-related operators be added to RAML
in such a way that certain security properties can be guar-
anteed for routing?
Algebraic frameworks other than that of [25] may provide
foundations for other RAML-like languages. The algebras
of [25] have a right-associative ⊕ operator, which is well
suited for complex policies for path-vector protocols. Per-
haps left-associative algebras may prove useful in modeling
reservation-based and source-based routing protocols.
We have applied RAML operators at the level of rout-
ing algebras, but we believe that operators at the protocol
level are actually needed to model some protocols and pro-
tocol interactions. For example, If RP A = hA, MAi and
RP B = hB, MBi are two routing protocols (ignoring la-
bel modalities). Then the disjunction operator  extends
naturally to the protocol level,
hA, MAi t hB, MBi = hA t B, MA?MBi.
The ? here suggests that some means for combining mech-
anisms in a consistent way needs to be worked out. Put
another way, we can think of this combination as deﬁning a
single protocol. To treat this in full detail seems to require
that protocol instances, the FIB, and the FIB manager be
brought into our formal model. Then we would think of the
preference relation at the FIB-manager level as modeling
what is usually called administrative distance between rout-
ing protocols. In fact, we believe this is the most promising
approach to modeling a protocol such as OSPF. We would
like to declare OSPF with a speciﬁcation something like this,
OSPF = hareas, path-vectori ¯ hadd(1, 232), link-statei,
where the algebra areas could be deﬁned as fm(lp(2)) ⊗
add(1, 3) (the ﬁrst component enforces a simple hierarchy,
while the second restricts path lengths to length at most
3). As mentioned in Section 3, an OSPF signature can be
modeled as a pair, hα, di, where α contains area information
and d represents distance.
Acknowledgements
Initial work for this paper was done while the ﬁrst author
was with Intel Research, and we thank Derek McAuley and
David Tennenhouse for their support. We also thank An-
drea Bittau, Steve Bellovin, Bob Briscoe, Randy Bush, Chi-
kin (Sid) Chau, Jon Crowcroft, Nick Feamster, Wenjun Hu,
Richard Mortier, Kengo Nagahashi, Matthew Roughan, Pe-
ter Sewell, Bruce Shepherd, Ben Strulo, Nigel Walker, and
Gordon Wilfong for helpful comments on early drafts.
8. REFERENCES
[1] R. Callon. Use of OSI IS–IS for Routing in TCP/IP and
generation routers. SIGCOMM Comput. Commun. Rev.,
28(4):229–240, 1998.
[4] E. W. Dijkstra. A Note on Two Problems in Connexion
with Graphs. Numerische Mathematik 1, pages 269–271,
1959.
[5] Forces. IETF Forwarding and Control Element Separation
working group.
[6] Lixin Gao and Jennifer Rexford. Stable internet routing
without global coordination. IEEE/ACM Transactions on
Networking, pages 681–692, December 2001.
[7] M. Gondran and M. Minoux. Graphs and Algorithms.
Wiley, 1984.
[8] Timothy Griﬃn, Aaron D. Jaggard, and Vijay
Ramachandran. Design principles of policy languages for
path vector protocols. In Proc. ACM SIGCOMM,
September 2003.
[9] Timothy G. Griﬃn, Lixin Gao, and Jennifer Rexford.
Inherently safe backup routing with BGP. In Proc. IEEE
INFOCOM, April 2001.
[10] Timothy G. Griﬃn and Geoﬀ Huston. BGP Wedgies, June
2005. Internet Draft (work in progress).
[11] Sam Halabi and Danny McPherson. Internet Routing
Architectures. Cisco Press, second edition, 2001.
[12] Mark Handley, Eddie Kohler, Atanu Ghosh, Orion Hodson,
and Pavlin Radoslavov. Designing extensible IP router
software. In 2nd USENIX Symposium on Networked
Systems Design and Implementation (NSDI), 2005. see also
www.xorp.org.
[13] C. Hendrick. Routing information protocol. RFC 1058,
1988.
[14] Eddie Kohler, Robert Morris, Benjie Chen, John Jannotti,
and M. Frans Kaashoek. The click modular router. ACM
Transactions on Computer Systems, 18(3):263–297, 2000.
[15] K.Varadhan, R.Govindan, and D Estrin. Persistent route
oscillations in inter-domain routing. Computer Networks,
32:1–16, 2000.
[16] Charles Lynn, Joanne Mikkelson, and Karen Seo. Secure
BGP (S-BGP). draft-clynn-s-bgp-protocol-00a.txt. work in
progress.
[17] Andreu Mas-Colell, Michael D. Whinston, and Jerry R.
Green. Microeconomic Theory. Oxford University Press,
1995.
[18] D. McPherson, V. Gill, D. Walton, and A. Retana.
RFC3345: BGP persistent route oscillation condition, 2002.
[19] Mehryar Mohri. Semiring frameworks and algorithms for
shortest-distance problems. J. Autom. Lang. Comb.,
7(3):321–350, 2002.
[20] J. Moy. OSPF version 2. RFC 2328, 1998.
[21] John Moy. OSPF: Anatomy of an Internet Routing
Protocol. Addison-Wesley, 1998.
[22] Craig Partridge, Alex C. Snoeren, W. Timothy Strayer,
Beverly Schwartz, Matthew Condell, and Isidro Castineyra.
Fire: Flexible intra-as routing environment. IEEE Journal
on Selected Areas in Communications (J-SAC), 19(3),
2001. A preliminary version appeared in SIGCOMM 2000.
[23] Albaro Retana, Russ White, and Don Slice. EIGRP for IP.
Addison-Wesley, 1998.
[24] Joao Luis Sobrinho. Algebra and algorithms for QoS path
computation and hop-by-hop. IEEE/ACM Transactions on
Networking, 10(4):541–550, August 2002.
[25] Joao Luis Sobrinho. Network routing with path vector
protocols: Theory and applications. In Proc. ACM
SIGCOMM, September 2003.
[26] Cisco Systems. Endless BGP convergence problem in Cisco
IOS software releases. Field Note, October 10 2001,
http://www.cisco.com/warp/public/770/ fn12942.html.
Dual Environments. RFC1195, December 1990.
[27] Russ White, Danny McPherson, and Srihari Sangli.
[2] Bernard Carr´e. Graphs and Networks. Oxford University
Practical BGP. Addison Wesley, 2005.
Press, 1979.
[3] Dan Decasper, Zubin Dittia, Guru Parulkar, and Bernhard
Plattner. Router plugins: a software architecture for next
[28] Randy Zhang and Micah Bartell. BGP Design and
Implementation. Cisco Press, 2003.