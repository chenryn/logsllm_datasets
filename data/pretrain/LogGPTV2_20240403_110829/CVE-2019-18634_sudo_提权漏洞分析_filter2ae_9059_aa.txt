# CVE-2019-18634 sudo 提权漏洞分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
在这篇文章中，我们将对近期刚刚修复sudo程序漏洞(CVE-2019-18634)进行分析，该漏洞需要在开启pwfeedback选项才能出发，一旦成功利用，攻击者将有可能实现本地提权。影响版本
`1.7.1 - 1.8.30`
接下来，我们将对该漏洞进行分析。
## 环境配置
  * ubuntu 1804 vmware 虚拟机
  * [sudo 1.8.25 版本](https://www.sudo.ws/dist/sudo-1.8.25.tar.gz)
  * gdb(pwndbg 插件), pwntools
后面的分析都会在以上的环境下进行
## 漏洞分析
###  pwfeedback 选项
pwfeedback，也就是 password feedback，开启之后在输入密码的时候会有视觉反馈，显示`*`号， 如下图,
默认情况下不会开启，某些Linux发行版本(Linux Mint和Elementary OS)会默认开启这个选项
开启的方法是在`/etc/sudoers` 文件中添加一行`Defaults pwfeedback`
###  编译 sudo 1.8.25
下载[sudo 1.8.25 版本](https://www.sudo.ws/dist/sudo-1.8.25.tar.gz)的源码
    wget https://www.sudo.ws/dist/sudo-1.8.25.tar.gz
tar 解包之后进入源码目录按照默认选项编译安装即可
    ./configure ;make -j16 ; make install
在测试过程中，系统自带的sudo是 `1.8.21p1` 版本， 安装位置在 `/usr/bin/sudo`  
自己编译的版本安装位置在 `/usr/local/bin/sudo`
###  从poc定位漏洞点
官方给出了两个 poc, `poc1`适用 `sudo 1.8.25p1` 以下的版本, `poc2` 则适用`sudo 1.8.26 - 1.8..30`
, 下面我们将从漏洞触发定位到漏洞代码，并分析漏洞的成因  
`poc1`
     perl -e 'print(("A" x 100 . "x{00}") x 50)' | sudo -S id
     Password: Segmentation fault
`poc2`
    $ socat pty,link=/tmp/pty,waitslave exec:"python -c 'print(("A"*100+chr(0x15))*50)'" &
    $ sudo -S id  buf) {
                    if (write(fd, "b b", 3) == -1)
                    break;
                    --cp;
                }
                left = bufsiz;
                continue;
                } else if (c == sudo_term_erase) {
                if (cp > buf) {
                    if (write(fd, "b b", 3) == -1)
                    break;
                    --cp;
                    left++;
                }
                continue;
                }
                ignore_result(write(fd, "*", 1));
            }
            *cp++ = c;//  buf) {
            if (write(fd, "b b", 3) == -1)
                break;
            --cp;
        }
        left = bufsiz;
        continue;
    }
这里也是漏洞触发点所在。因为`poc1`并不是在终端获取输入流，而是从管道，这里`term.c_cc[VKILL]` 会保持初始化的值，也就是`x00`,
所以传入`x00`的时候会进入这段代码，但是这个管道是单向管道，往管道写`"b
b"`会失败然后break出while循环，问题也就是出现在这里，跳出`while (cp >
buf)`这个循环之后，`cp`的位置没有改变，但是可以读取的最大字符数`left`又变成了`bufsiz`(从代码可找到是256).
所以只要不断传入类似`"xxx...x00"`的字符串，就可以不断向 `buf`里写东西，造成buf溢出。
**poc2**
okay, 理解了`poc1`的触发原理，那么我们再来看`poc2`就十分的简单了。
使用 `poc2`的原因是在`sudo 1.8.26` 中加入了对 EOF的处理，于是`poc1`就不管用了
            if (c == sudo_term_eof) {
            nr = 0;
            break;
但是如果是从终端获取输入流，也就是我们说的pty，情况就不一样了，我们可以在[维基百科](https://en.wikipedia.org/wiki/ASCII#Control_characters)中找到`eof`和`kill`
控制符对应的ascii. `eof( EOT, ^D End-of-file character)` 对应的ascii为0x04, kill为 0x15。
如果从pty获取输入流，那么这个漏洞就又复活了。
对应的 poc
    socat pty,link=/tmp/pty,waitslave exec:"python -c 'print(("A"*100+chr(0x15))*50)'" &
    $ sudo -S id < /tmp/pty
这里创建了一个临时的 pty, 然后还是将 payload 通过 pty 传到 sudo即可
接下来我们就来看看如何对这个漏洞进行利用。