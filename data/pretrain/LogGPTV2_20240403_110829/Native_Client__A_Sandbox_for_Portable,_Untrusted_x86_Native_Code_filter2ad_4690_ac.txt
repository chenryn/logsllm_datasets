architecture. By comparison, the segment register operations
and far calls used by the NaCl trampoline are somewhat less
common, and may have received less consideration over the
history of the x86 architecture.
3.4. Communications
The IMC is the basis of communications into and out of
NaCl modules. The implementation is built around a NaCl
socket, providing a bi-directional, reliable, in-order datagram
service similar to Unix domain sockets [37]. An untrusted
NaCl module receives its ﬁrst NaCl socket when it is created,
accessible from JavaScript via the Document-Object Model
object used to create it. The JavaScript uses the socket to
send messages to the NaCl module, and can also share it
with other NaCl modules. The JavaScript can also choose
to connect the module to other services available to it by
opening and sharing NaCl sockets as NaCl descriptors.
NaCl descriptors can also be used to create shared memory
segments.
Number of
Descriptor
1
2
3
4
5
6
7
8
Linux
OSX Windows
3.3
5.3
6.6
8.2
9.7
11.1
12.6
14.2
31.5
38.6
47.9
50.9
54.1
60.0
63.7
66.2
38
51
64
77
90
104
117
130
Table 3: NaCl resource descriptor transfer cost. The times are
in microseconds. In this test, messages carrying zero data bytes
and a varying number of I/O descriptors are transferred from
a client NaCl module to a server NaCl module. On OSX, a
request/ack mechanism is needed as a bug workaround in the OSX
implementation of sendmsg. On Windows, a DuplicateHandle()
system call is required per I/O object transferred.
Using NaCl messages, Native Client’s SRPC abstraction
is implemented entirely in untrusted code. SRPC provides
a convenient syntax for declaring procedural interfaces be-
tween JavaScript and NaCl modules, or between two NaCl
modules, supporting a few basic types (int, ﬂoat, char)
as well as arrays in addition to NaCl descriptors. More
complex types and pointers are not supported. External
data representation strategies such as XDR [18] or Protocol
Buffers [26] can easily be layered on top of NaCl messages
or SRPC.
Our NPAPI implementation is also layered on top of the
IMC and supports a subset of the common NPAPI interface.
Speciﬁc requirements that shaped the current implementa-
tion are the ability read, modify and invoke properties and
methods on the script objects in the browser, support for
simple raster graphics, provide the createArray() method and
the ability to open and use a URL like a ﬁle descriptor. The
currently implemented NPAPI subset was chosen primarily
for expedience, although we will likely constrain and extend
it further as we improve our understanding of related security
considerations and application requirements.
3.5. Developer Tools
3.5.1. Building NaCl Modules. We have modiﬁed the stan-
dard GNU tool chain, using version 4.2.2 of the gcc collec-
tion of compilers [22], [29] and version 2.18 of binutils [23]
to generate NaCl-compliant binaries. We have built a ref-
erence binary from newlib2 using the resulting tool chain,
rehosted to use the NaCl trampolines to implement system
services (e.g., read(), brk(), gettimeofday(), imc sendmsg()).
Native Client supports an insecure “debug” mode that allows
additional ﬁle-system interaction not otherwise allowed for
secure code.
We modiﬁed gcc for Native Client by changing the
alignment of function entries (-falign-functions) to
2. See http://sourceware.org/newlib/
85
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:17:16 UTC from IEEE Xplore.  Restrictions apply. 
32 bytes and by changing the alignment of the targets
branches (-falign-jumps) to 32 bytes. We also changed
gcc to use nacljmp for indirect control transfers, including
indirect calls and all returns. We made more signiﬁcant
changes to the assembler,
to implement Native Client’s
block alignment requirements. To implement returns, the
assembler ensures that call instructions always appear in
the ﬁnal bytes of a 32 byte block. We also modiﬁed the
assembler to implement indirect control transfer sequences
by expanding the nacljmp pseudo-instruction as a properly
aligned consecutive block of bytes. To facilitate testing we
added support to use a longer nacljmp sequence, align the
text base, and use an and and or that uses relocations as
masks. This permits testing applications by running them on
the command line, and has been used to run the entire gcc
C/C++ test suite. We also changed the linker to set the base
address of the image as required by the NaCl loader (64K
today).
Apart from their direct use the tool chain also serves to
document by example how to modify an existing tools chain
to generate NaCl modules. These changes were achieved
with less than 1000 lines total to be patched in gcc and
binutils, demonstrating the simplicity of porting a compiler
to Native Client.
support
3.5.2. Proﬁling and Debugging. Native Client’s open
source release includes a simple proﬁling framework
trace with minimal per-
to capture a complete call
formance overhead. This
is based on gcc’s
-finstrument-functions code generation option
combined with the rdtsc timing instruction. This proﬁler
is portable, implemented entirely as untrusted code. In our
experience, optimized builds proﬁled in this framework
have performance somewhere between -O0 and -O2 builds.
Optionally, the application programmer can annotate the
proﬁler output with methods similar to printf, with output
appearing in the trace rather than stdout.
Native Client does not currently support interactive debug-
ging of NaCl binary modules. Commonly we debug NaCl
module source code by building with standard tools and a
library that exports all the interfaces to the NaCl service
runtime, allowing us to build debug and NaCl modules from
identical source. Over time we hope to improve our support
for interactive debugging of release NaCl binaries.
4. Experience
Unless otherwise noted, performance measurements in
this section are made without
the NaCl outer sandbox.
Sandbox overhead depends on how much message-passing
and service runtime activity the application requires. At this
time we do not have realistic applications of Native Client
to stress this aspect of the system.
Figure 4: SPEC2000 performance. “Static” results are for statically
linked binaries; “align32” results are for binaries aligned in 32-byte
blocks, and “nacl32” results are for NaCl binaries.
ammp
art
bzip2
crafty
eon
equake
gap
gcc
gzip
mcf
mesa
parser
perlbmk
twolf
vortex
vpr
static
200
46.3
103
113
79.2
62.3
63.9
52.3
149
65.7
87.4
126
94.0
154
112
90.7
aligned
203
48.7
104
124
76.9
62.9
64.0
54.7
149
65.7
89.8
128
99.3
163
116
88.4
NaCl
203
47.2
104
127
82.6
62.5
65.4
57.0
148
66.2
92.5
128
106
165
124
89.6
increase
1.5%
1.9%
1.9%
12%
4.3%
0.3%
2.4%
9.0%
-0.7%
0.8%
5.8%
1.6%
13%
7.1%
11%
-1.2%
Table 4: SPEC2000 performance. Execution time is in seconds. All
binaries are statically linked.
4.1. SPEC2000
A primary goal of Native Client is to deliver substantially
all of the performance of native code execution. NaCl
module performance is impacted by alignment constraints,
extra instructions for indirect control ﬂow transfers, and the
incremental cost of NaCl communication abstractions.
We ﬁrst consider the overhead of making native code side
effect free. To isolate the impact of the NaCl binary con-
straints (Table 1), we built the SPEC2000 CPU benchmarks
using the NaCl compiler, and linked to run as a standard
Linux binary. The worst case for NaCl overhead is CPU
bound applications, as they have the highest density of align-
ment and sandboxing overhead. Figure 4 and Table 4 show
the overhead of NaCl compilation for a set of benchmarks
from SPEC2000. The worst case performance overhead is
crafty at about 12%, with other benchmarks averaging about
5% overall. Hardware performance counter measurements
indicate that the largest slowdowns are due to instruction
cache misses. For crafty, the instruction fetch unit is stalled
during 83% of cycles for the NaCl build, compared to 49%
for the default build. Gcc and vortex are also signiﬁcantly
impacted by instruction cache misses.
As our current alignment implementation is conservative,
86
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:17:16 UTC from IEEE Xplore.  Restrictions apply. 
ammp
art
bzip2
crafty
eon
equake
gap
gcc
gzip
mcf
mesa
parser
perlbmk
twolf
vortex
vpr
static
657
469
492
756
1820
465
1298
2316
492
439
1337
641
1167
773
1019
668
aligned
759
485
525
885
2016
475
1836
3644
537
452
1758
804
1752
937
1364
780
NaCl
766
485
526
885
2017
475
1882
3646
537
451
1769
802
1753
936
1351
780
increase
16.7%
3.3%
7.0%
17.5%
10.8%
2.3%
45.1%
57.5%