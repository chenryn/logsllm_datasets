title:Composition theorems without pre-established session identifiers
author:Ralf K&quot;usters and
Max Tuengerthal
Composition Theorems Without
Pre-Established Session Identiﬁers
Ralf Küsters
University of Trier
Trier, Germany
PI:EMAIL
Max Tuengerthal
University of Trier
Trier, Germany
PI:EMAIL
ABSTRACT
Canetti’s universal composition theorem and the joint state com-
position theorems by Canetti and Rabin are useful and widely em-
ployed tools for the modular design and analysis of cryptographic
protocols. However, these theorems assume that parties participat-
ing in a protocol session have pre-established a unique session ID
(SID). While the use of such SIDs is a good design principle, exist-
ing protocols, in particular real-world security protocols, typically
do not use pre-established SIDs, at least not explicitly and not in
the particular way stipulated by the theorems. As a result, the com-
position theorems cannot be applied for analyzing such protocols
in a modular and faithful way.
In this paper, we therefore present universal and joint state com-
position theorems which do not assume pre-established SIDs. In
our joint state composition theorem, the joint state is an ideal func-
tionality which supports several cryptographic operations, includ-
ing public-key encryption, (authenticated and unauthenticated)
symmetric encryption, MACs, digital signatures, and key deriva-
tion. This functionality has recently been proposed by Küsters and
Tuengerthal and has been shown to be realizable under standard
cryptographic assumptions and for a reasonable class of environ-
ments. We demonstrate the usefulness of our composition theorems
by several case studies on real-world security protocols, including
IEEE 802.11i, SSL/TLS, SSH, IPsec, and EAP-PSK. While our
applications focus on real-world security protocols, our theorems,
models, and techniques should be useful beyond this domain.
Categories and Subject Descriptors
C.2.2 [Computer-Communication Networks]: Network Proto-
cols—Protocol Veriﬁcation
General Terms
Security, Veriﬁcation
1.
INTRODUCTION
Universal composition theorems, such as Canetti’s composition
theorem in the UC model [7] and Küsters’ composition theorem in
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’11, October 17–21, 2011, Chicago, Illinois, USA.
Copyright 2011 ACM 978-1-4503-0948-6/11/10 ...$10.00.
the IITM model [19], allow to obtain security for multiple sessions
of a protocol by analyzing just a single protocol session. These the-
orems assume that diﬀerent protocol sessions have disjoint state; in
particular, each session has to use fresh randomness. This can lead
to ineﬃcient and impractical protocols, since, for example, every
session has to use fresh long-term symmetric and public/private
keys. Canetti and Rabin [11] therefore proposed to combine univer-
sal composition theorems with what they called composition theo-
rems with joint state. As the name suggests, such theorems yield
systems in which diﬀerent sessions may use some joint state, e.g.,
the same long-term and public/private keys.
However, these theorems, both for universal and joint state com-
position, assume that parties participating in a protocol session have
pre-established a unique session ID (SID), and as a result (see Sec-
tion 3), make heavy use of this SID in a speciﬁc way stipulated
by the universal and joint state composition theorems. On the one
hand, the use of such SIDs is a good design principle and as dis-
cussed by Canetti [8] and Barak et al. [2] establishing such SIDs
is simple. On the other hand, many existing protocols, including
most real-world security protocols, do not make use of such pre-es-
tablished SIDs, at least not explicitly and not in the particular way
stipulated by the theorems. As a result, these theorems cannot be
used for the faithful modular analysis of such protocols; at most
for analyzing idealized variants of the original protocols, which is
unsatisfactory and risky, in the sense that attacks on the original
protocols might be missed (see Section 4). The problems resulting
from pre-established SIDs in the existing composition theorems do
not seem to have been brought out in previous work.
The goal of this paper is therefore to obtain general universal
composition and joint state composition theorems that do not as-
sume pre-established SIDs and their use in cryptographic proto-
cols, and hence, to enable modular, yet faithful analysis of proto-
cols, without the need to modify/idealize these protocols. A main
motivation for our work comes from the analysis of real-world se-
curity protocols. While many attacks on such protocols have been
uncovered (see, e.g., [12, 15, 1, 27, 25] for recent examples), their
comprehensive analysis still poses a big challenge, as often pointed
out in the literature (see, e.g., [26, 18, 10]). A central problem is
the complexity of these protocols. In order to tame the complex-
ity, modular analysis of such protocols should be pushed as far as
possible, but without giving up on accurate modeling. Our compo-
sition theorems are useful tools for this kind of modular and faith-
ful analysis. They should be of interest also beyond the analysis of
real-world security protocols. More precisely, the main contribu-
tions of our work are as follows:
Contribution of this Paper. Our universal composition theorem
without pre-established SIDs states that if a protocol realizes an
ideal functionality for a single session, then it also realizes the ideal
41functionality for multiple sessions, subject to mild restrictions on
the single-session simulator. The important point is that a user in-
vokes a protocol instance simply with a local SID, locally chosen
and managed by the user herself, rather than with an SID pre-es-
tablished with other users for that session. This not only provides
the user with a more common and convenient interface, where the
user addresses her protocol instances with the corresponding local
SIDs, but, more importantly, as explained in Section 3, frees the
real protocol from the need to use pre-established SIDs and allows
for realizations that faithfully model existing (real-world) proto-
cols.
In our joint state composition theorem without pre-established
SIDs we consider protocols that use an ideal crypto functionality
Fcrypto proposed in [23]. The functionality Fcrypto allows its users
to perform several cryptographic operations in an ideal way, in-
cluding public-key encryption, authenticated and unauthenticated
symmetric encryption, MACs, digital signatures, key derivation,
and establishing pre-shared keys. As shown in [23], Fcrypto can
be realized under standard cryptographic assumptions, subject to
reasonable restrictions on the environment. Now, our joint state
composition theorem states that under a certain condition on the
protocol, which we call implicit (session) disjointness, it suﬃces
to show that the protocol (which may use Fcrypto) realizes an ideal
functionality for a single session of the protocol to obtain security
for multiple sessions of the protocol, where all sessions may use the
same ideal crypto functionality Fcrypto; again we put mild restric-
tions on the single-session simulator. So, Fcrypto (or its realization),
with the keys stored in it, constitutes the joint state across sessions.
As in the case of the universal composition theorem, users again
invoke protocol instances with locally chosen and managed SIDs.
Unlike joint state composition theorems with pre-established SIDs,
our joint state composition theorem does not modify/idealize the
original protocol.
Given our theorems, (real-world) security protocols can be an-
alyzed with a high degree of modularity and without giving up on
precision: Once implicit disjointness is established for a protocol—
ﬁrst proof step—, it suﬃces to carry out single-session analysis for
the protocols—second proof step—in order to obtain multi-session
security with joint state for the original protocol, not just an ideal-
ized version with pre-established SIDs added in various places, as
explained in Sections 3 and 4. We emphasize that, due to the use
of Fcrypto, in all proof steps often merely information-theoretic or
purely syntactical reasoning, without reasoning about probabilities
and without reduction proofs, suﬃces.
We demonstrate the usefulness of our theorems and approach by
several case studies on real-world security protocols, namely (sub-
protocols of) IEEE 802.11i, SSL/TLS, SSH, IPsec, and EAP-PSK.
More precisely, we show that all these protocols satisfy implicit
disjointness, conﬁrming our believe that this property is satisﬁed
by many (maybe most) real-world security protocols. While prov-
ing implicit disjointness requires to reason about multiple sessions
of a protocol, this step is nevertheless relatively easy. In fact, as
demonstrated by our case studies, to prove implicit disjointness,
typically the security properties of only a fraction of the primitives
used in a protocol need to be considered. For example, to prove that
the SSH key exchange protocol satisﬁes implicit disjointness, only
collision resistance of the hash function is needed, but not the secu-
rity of the encryption scheme, the MAC, or the Diﬃe-Hellman key
exchange used in SSH. Now since the above mentioned protocols
satisfy implicit disjointness, to show that these protocols are secure
key exchange or secure channel protocols, single-session analysis
suﬃces. Performing this single-session analysis for all these proto-
cols is out of the scope of this paper. (The main point of this paper
is to provide the machinery for faithful and highly modular analy-
sis, not to provide a full-ﬂedged analysis of these protocols.) How-
ever, for some of the mentioned protocols single-session analysis
has been carried out in other works (see Section 5). For example,
this has been done for SSL/TLS by Gajek et al. in [16]. However,
they used the original joint state theorem to lift their security re-
sult to the multi-session case, resulting in an idealized version of
SSL/TLS (see Section 5.2). With our theorems and since SSL/TLS
satisﬁes implicit disjointness, multi-session security follows for the
original, unmodiﬁed protocol.
Structure of this Paper.
In Section 2, we recall basics on sim-
ulation-based security and introduce some notation. Our universal
composition and joint state composition theorems without pre-es-
tablished SIDs are then presented in Sections 3 and 4, respectively,
with applications discussed in Section 5. Full details and proofs are
provided in our technical report [22].
2. SIMULATION-BASED SECURITY
1 | ··· | !M(cid:48)
We brieﬂy recall the framework of simulation-based security,
following [19] (see also [22]). We provide a quite model-indepen-
dent account as the details of the model are not important to be able
to follow the rest of this paper.
The General Computational Model. The general computational
model is deﬁned in terms of systems of interactive Turing ma-
chines. An interactive Turing machine (shortly, machine) is a prob-
abilistic polynomial-time Turing machine with named input and
output tapes. The names determine how diﬀerent machines are
connected in a system of machines. A system S of machines is
of the form S = M1 | ··· | Mk | !M(cid:48)
k(cid:48) where the Mi and
M(cid:48)
j are machines such that the names of input tapes of diﬀerent
machines in the system are disjoint. We say that the machines M(cid:48)
j
are in the scope of a bang operator. This operator indicates that
in a run of a system an unbounded number of (fresh) copies of a
machine may be generated. Conversely, machines which are not in
the scope of a bang operator may not be copied. Systems in which
multiple copies of a machine may be generated are often needed,
e.g., in case of multi-party protocols or in case a system describes
the concurrent execution of multiple instances of a protocol. In a
run of a system S at any time only one machine is active and all
other machines wait for new input. A (copy of a) machine M can
trigger another (copy of a) machine M(cid:48) by sending a message on an
output tape corresponding to an input tape of M(cid:48). Identiﬁers, e.g.,
session or party identiﬁers, contained in the message can be used
to address a speciﬁc copy of M(cid:48). If a new identiﬁer is used, a fresh
copy of M(cid:48) would be generated. The ﬁrst machine to be triggered
is the so-called master machine. This machine is also triggered if
a machine does not produce output. A run stops if the master ma-
chine does not produce output or a machine outputs a message on
a tape named decision. Such a message is considered to be the
overall output of the system. Systems will always have polyno-
mial runtime in the security parameter (and possibly the length of
auxiliary input).
Two systems P and Q are called indistinguishable (P ≡ Q) iﬀ
the diﬀerence between the probability that P outputs 1 (on the de-
cision tape) and the probability that Q outputs 1 is negligible in the
security parameter.
Notions of Simulation-Based Security. We need the following
terminology. For a system S, the input/output tapes of machines
in S that do not have a matching output/input tape are called ex-
ternal. These tapes are grouped into I/O and network tapes. We
consider three diﬀerent types of systems, modeling i) real and ideal
protocols/functionalities, ii) adversaries and simulators, and iii) en-
42vironments: Protocol systems and environmental systems are sys-
tems which have an I/O and network interface, i.e., they may have
I/O and network tapes. Adversarial systems only have a network in-
terface. Environmental systems may contain a master machine and
may produce output on the decision tape. We can now deﬁne strong
simulatability; other equivalent security notions, such as (dummy)
UC, can be deﬁned in a similar way [19].
Definition 1
([19]). Let P and F be protocol systems with the
same I/O interface, the real and the ideal protocol, respectively.
Then, P realizes F (P ≤ F ) iﬀ there exists an adversarial sys-
tem S (a simulator or an ideal adversary) such that the systems P
and S|F have the same external interface and for all environmen-
tal systems E, connecting only to the external interface of P (and
hence, S|F ), it holds that E|P ≡ E|S|F .