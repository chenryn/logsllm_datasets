# 【技术分享】如何手脱Locky自定义壳
|
##### 译文声明
本文是翻译文章，文章来源：安全客
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
译者：[我来学英语](http://bobao.360.cn/member/contribute?uid=1264882569)
预估稿费：130RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**前言**
****
Locky是一款勒索软件，因其加密后的文件后缀为.locky而得名。不同于一般的软件，Locky使用了自定义壳对代码进行保护，增加了对其进行静态分析的难度。这篇文章将教你一些小技巧并向你演示如何对Locky进行脱壳。
**手脱Locky自定义壳**
我将向你演示如何使用Ollydbg来给Locky脱壳。这个壳其实是比较简单的一种，但是需要你去分析。你可以去[Hybrid-Analysis](https://www.hybrid-analysis.com/sample/49a48d4ff1b7973e55d5838f20107620ed808851231256bb94c85f6c80b8ebfc?environmentId=100)下载样本。
通常我会先使用PE静态分析工具，比如[PortexAnalyzer](https://github.com/katjahahn/PortEx/tree/master/progs)对脱壳样本进行静态检测。如果分析结果如下图，那么这就告诉我们这个样本是加了壳的。样本的多个节都是高熵值的，包括.rdata段
像die（[detect it easy](https://github.com/horsicq/Detect-It-Easy)）这样的查壳工具是不知道如何对这个样本进行脱壳的，因为这个壳是自定义壳。自定义壳经常会在恶意样本中出现。  
Locky的加壳器有一个比较奇怪的特征，它总是在文件版本信息中添加“ **32-bit Edition** ”字样，其他信息每次都会变化。
    StringFileInfo
    ---------------    language ID: 0x0409
    code page: 0x04b0
    CompanyName: Doubtsoftware.com 
    FileDescription: Advanced Task Scheduler 32-bit Edition 
    FileVersion: 4.1.0.612 
    InternalName: #dvenced Task Scheduler 32-bit Edition 
    LegalCopyright: Copyright © Southsoftware.com, 2002-2015 
    OriginalFilename: Bifscheduler_edmin.exe 
    ProductName: Advanced Task Scheduler 32-bit Edition 
    ProductVersion: 4.1.0.612
Debug Information也是未知类型，因此Portex也无法给出进一步分析信息。
    Debug Information
    *****************
    Time Date Stamp: Thu Dec 09 05:07:00 CET 2083
    Type: 4102553603 no description available
如果你研究过这个样本（你可以使用hex
editor搜索“RSDS”），就会知道样本中包含一个调试路径，这个路径看起来是随机的，当然也可能是被故意修改成看起来随机的：
    Z:as28cxkoaoazoozykzl0tjxw9y4cnijyc6mq3mvnt.pdb
尽管这个信息没法帮助我们脱壳，但是它可以作为这种加壳器的特征。以后再碰到这条信息，我们就可以知道是使用这种加壳器加壳的了。对样本进行字符串和导入表检查似乎也没什么用。
如果你拿到这个样本时还比较早，通过动态调试你可以很轻松的认出他就是Locky。但是如果你拿到的样本比较新，或者他的C&C服务器不再使用，那么它就不会进行加密动作。
现在使用Ollydbg来调试它，别忘了给你的虚拟机做快照。程序加载后可以一直按F8步过，按得时候看着点别跑飞了。如果你不小心在下面这个call上步过了，你就会看到样本执行了一大堆动作，这时你只能重新载入这个样本了。你要做的是按F7步进这个call。
下面这个call也是一样的，按F7步进
后面的操作类似，仔细盯着屏幕，只要没执行一堆作就一直按F8步过。
在地址0x402364处你会注意到代码正在写.rdata段（地址0X417EE）。如果你在这下一个断点，一直按F9并且在数据窗口中看着.rdata所在的内存位置，你就可以看到.rdata段是怎样被解密成那个代码的。
跳转到.rdata段的jump命令在地址0x4020F0出现。
这个地方需要注意，push命令后紧跟ret相当于一个jump操作。ret命令会使你跳转到0x41577A。与上面 **PortexAnalyzer**
生成的报告进行对比，或者从Ollydbg的内存窗口你可以确认，这就是.rdata段的虚拟地址。
但是我们的工作并没有结束，rdata段处被解密的代码仍然是加壳stub（用于将加壳后的代码解密的代码）。所以我们还需要按F8跟踪这段代码一会。在跟踪的过程中你会看到代码开始使用
**GetProcAddress** 收集常见DLL方法的地址，其中一个方法是 **RtlDecompressBuffer**
，这个方法经常被加壳器用来执行脱壳操作。
调试到地址0x415B37时停下
在eax寄存器上右击，选择反汇编器中跟进
现在就可以看到 **RtlDecompressBuffer** 方法的代码了。在PUSH DWORD PTR [EBP + C]命令处下断点
在EDI寄存器上右击选择数据窗口中跟进
可以看到现在数据窗口是空的
按F8之后，解密后的代码就会出现在这部分内存中
最后一件事，打开内存窗口，选择这部分内存，右击选择保存到可执行文件
选择要保存的位置就完成了。得到的二进制文件就是脱壳后的lockey你可以把它加载到hex editor中来查看他的字符串，这样就可以确定这是一个Locky了