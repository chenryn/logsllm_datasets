transient execution attacks and defenses,” in USENIX Security ’19.
[15] S. A. Carr and M. Payer, “Datashield: Conﬁgurable data conﬁdentiality
and integrity,” in AsiaCCS ’17.
[16] C. Carruth, “Speculative load hardening,” July 2018.
[17] M. Castro, M. Costa, and T. Harris, “Securing software by enforcing
data-ﬂow integrity,” in OSDI ’06.
[18] X. Chen, A. Slowinska, D. Andriesse, H. Bos, and C. Giuffrida,
“Stackarmor: Comprehensive protection from stack-based memory error
vulnerabilities for binaries.” in NDSS ’15.
[19] D. Dhurjati and V. Adve, “Backwards-compatible array bounds checking
for c with very low overhead,” in Proceedings of the 28th international
conference on Software engineering.
[20] D. Dhurjati, S. Kowshik, and V. Adve, “SAFECode: enforcing alias
analysis for weakly typed languages,” in PLDI ’06.
[21] D. Dhurjati, S. Kowshik, V. Adve, and C. Lattner, “Memory safety
without garbage collection for embedded applications,” in TECS ’05.
[22] G. J. Duck and R. H. Yap, “EffectiveSan: type and memory error
detection using dynamically typed C/C++,” in PLDI ’18.
[23] ——, “Heap bounds protection with low fat pointers,” in CC ’16.
[24] U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and G. C. Necula, “Xﬁ:
Software guards for system address spaces,” in OSDI ’06.
[25] S. Ghemawat and P. Menage, “TCMalloc: Thread-caching malloc,”
[26] M. Gretton-Dann, “Arm a-proﬁle architecture developments 2018:
2009.
Armv8.5-a,” 2018.
[28] N.
Hadad
J.
and
mitigations,”
Afek,
“Overcoming
spectre
https://alephsecurity.com/2018/06/26/
(some)
browser
spectre-browser-query-cache/, 2018.
[29] Intel, “Speculative execution side channel mitigations,” July 2018,
revision 3.0.
[30] I. R. Jenkins, P. Anantharaman, R. Shapiro, J. P. Brady, S. Bratus,
and S. W. Smith, “Ghostbusting: Mitigating Spectre with intraprocess
memory isolation,” in HoTSoS ’20.
[31] P. Kocher, “Spectre Mitigations in Microsoft’s C/C++ Compiler,” 2018.
[32] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Ham-
burg, M. Lipp, S. Mangard, T. Prescher et al., “Spectre attacks: Exploit-
ing speculative execution,” in S&P ’19.
[33] K. Koning, X. Chen, H. Bos, C. Giuffrida, and E. Athanasopoulos,
“No need to hide: Protecting safe regions on commodity hardware,”
in EuroSys ’17.
[34] T. Kroes, K. Koning, E. van der Kouwe, H. Bos, and C. Giuffrida, “Delta
pointers: Buffer overﬂow checks without the checks,” in EuroSys ’18.
[35] J. A. Kroll, G. Stewart, and A. W. Appel, “Portable software fault iso-
lation,” in 2014 IEEE 27th Computer Security Foundations Symposium.
[36] V. Kuznetzov, L. Szekeres, M. Payer, G. Candea, R. Sekar, and D. Song,
“Code-pointer integrity,” in OSDI ’14.
[37] C. Lattner and V. Adve, “Automatic pool allocation: Improving perfor-
mance by controlling data structure layout in the heap,” in PLDI ’05.
[38] Y. Liu, T. Zhou, K. Chen, H. Chen, and Y. Xia, “Thwarting memory
disclosure with efﬁcient hypervisor-enforced intra-domain isolation,” in
CCS ’15.
[39] V. B. Lvin, G. Novark, E. D. Berger, and B. G. Zorn, “Archipelago:
trading address space for reliability and security,” in ASPLOS ’08.
[40] G. Maisuradze and C. Rossow, “Speculose: Analyzing the secu-
rity implications of speculative execution in cpus,” arXiv preprint
arXiv:1801.04084, 2018.
[41] S. McCamant and G. Morrisett, “Evaluating sﬁ for a cisc architecture,”
in USENIX Security ’06.
[42] R. Mcilroy, J. Sevcik, T. Tebbi, B. L. Titzer, and T. Verwaest, “Spectre
is here to stay: An analysis of side-channels and speculative execution,”
arXiv preprint arXiv:1902.05178, 2019.
[43] M. Miller, “Trends, challenges, and strategic shifts in the software
vulnerability mitigation landscape,” in BlueHat IL ’19.
[44] O. Moerbeek, “A new malloc (3) for openbsd,” in EuroBSDCon 2009.
[45] T. Mytkowicz, A. Diwan, M. Hauswirth, and P. F. Sweeney, “Producing
wrong data without doing anything obviously wrong!” in ASPLOS ’09.
[46] M. Neugschwandtner, A. Sorniotti, and A. Kurmus, “Memory catego-
rization: Separating attacker-controlled data,” in DIMVA ’19.
[47] G. Novark and E. D. Berger, “DieHarder: securing the heap,” in CCS
[48] O. Oleksenko, D. Kuvaiskii, P. Bhatotia, P. Felber, and C. Fetzer, “Intel
MPX Explained: A Cross-layer Analysis of the Intel MPX System
Stack,” Proceedings of
the ACM on Measurement and Analysis of
Computing Systems, 2018.
[49] O. Oleksenko, B. Trach, M. Silberstein, and C. Fetzer, “Specfuzz:
Bringing spectre-type vulnerabilities to the surface,” in USENIX Security
’20.
[50] OpenSSL, “TLS heartbeat read overrun (CVE-2014-0160).”
[51] T. Palit, F. Monrose, and M. Polychronakis, “Mitigating data leakage by
protecting memory-resident sensitive data,” in ACSAC ’19.
[52] F. Pizlo, “What Spectre and Meltdown Mean For WebKit,” Jan 2018.
[53] S. Proskurin, M. Momeu, S. Ghavamnia, V. P. Kemerlis, and M. Poly-
chronakis, “xmp: Selective memory protection for kernel and user
space,” in S&P ’20.
[54] J. Rafkind, A. Wick, J. Regehr, and M. Flatt, “Precise garbage collection
for C,” in ISMM ’09.
[55] C. Reis, A. Moshchuk, and N. Oskov, “Site isolation: Process separation
for web sites within the browser,” in USENIX ’19.
[56] M. Schwarz, M. Lipp, C. Canella, R. Schilling, F. Kargl, and D. Gruss,
“ConTExT: A generic approach for mitigating Spectre,” in NDSS ’20.
[57] D. Sehr, R. Muth, C. L. Bifﬂe, V. Khimenko, E. Pasko, B. Yee,
K. Schimpf, and B. Chen, “Adapting software fault isolation to con-
temporary cpu architectures,” 2010.
[58] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, “Address-
sanitizer: A fast address sanity checker,” in Presented as part of the
2012 {USENIX} Annual Technical Conference ({USENIX}{ATC} 12),
2012, pp. 309–318.
[59] F. J. Serna, “The info leak era on software exploitation,” Black Hat USA,
’10.
[27] M. Guarnieri, B. K¨opf, J. F. Morales, J. Reineke, and A. S´anchez,
“Spectector: Principled detection of speculative information ﬂows,” in
S&P ’20.
2012.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:57:47 UTC from IEEE Xplore.  Restrictions apply. 
141062
[60] H. Shacham, “The geometry of innocent ﬂesh on the bone: Return-into-
libc without function calls (on the x86),” in CCS ’07.
[61] S. Silvestro, H. Liu, C. Crosser, Z. Lin, and T. Liu, “Freeguard: A faster
secure heap allocator,” in CCS ’17.
[62] C. Song, B. Lee, K. Lu, W. Harris, T. Kim, and W. Lee, “Enforcing
kernel security invariants with data ﬂow integrity.” in NDSS ’16.
[63] Y. Sui and J. Xue, “Svf: interprocedural static value-ﬂow analysis in
[64] B. L. Titzer and J. Sevcik, “A year with Spectre: a V8 perspective,” Apr
llvm,” in CC ’16.
2019.
[65] A. Vahldiek-Oberwagner, E. Elnikety, N. O. Duarte, M. Sammler,
P. Druschel, and D. Garg, “ERIM: Secure, efﬁcient in-process isolation
with protection keys (MPK),” in USENIX Security ’19.
[66] E. Van Der Kouwe, T. Kroes, C. Ouwehand, H. Bos, and C. Giuffrida,
“Type-after-type: Practical and complete type-safe memory reuse,” in
ACSAC ’18.
[67] S. Van Schaik, A. Milburn, S.
¨Osterlund, P. Frigo, G. Maisuradze,
K. Razavi, H. Bos, and C. Giuffrida, “RIDL: Rogue in-ﬂight data load,”
in S&P ’19.
[68] M. Vassena, K. V. Gleissenthall, R. G. Kici, D. Stefan, and R. Jhala,
“Automatically eliminating speculative leaks from cryptographic code
with blade,” in POPL ’21.
[69] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham, “Efﬁcient
software-based fault isolation,” in SOSP, 1993.
[70] G. Wang, S. Chattopadhyay, I. Gotovchits, T. Mitra, and A. Roychoud-
hury, “oo7: Low-overhead defense against spectre attacks via program
analysis,” IEEE Transactions on Software Engineering, 2019.
[71] B. Wickman, H. Hu, I. Y. D. Jang, J. L. S. Kashyap, and T. Kim, “Pre-
venting use-after-free attacks with fast forward allocation,” in USENIX
Security ’21.
[72] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy,
S. Okasaka, N. Narula, and N. Fullagar, “Native Client: A sandbox for
portable, untrusted x86 native code,” in S&P ’09.
[73] B. Zeng, G. Tan, and G. Morrisett, “Combining control-ﬂow integrity
and static analysis for efﬁcient and validated data sandboxing,” in CCS
’11.
[74] T. Zhang, D. Lee, and C. Jung, “Bogo: buy spatial memory safety, get
temporal memory safety (almost) free,” in ASPLOS ’19.
UNDEFINED POINTER ARITHMETIC IN SOFTWARE
APPENDIX A
Although TDI is compatible with a range of software, as
discussed in Section IX, it is still incompatible with software
which performs undeﬁned pointer arithmetic and uses the
results across function boundaries. During testing, we found
such pointer arithmetic issues in several pieces of software.
We document these issues here to assist future researchers.
We discovered that CPU2006’s version of gcc stores out-
of-range pointers (pointing to before the start of the allocated
object) in global variables, which are later dereferenced by
other functions. Although TDI can handle pointers being
slightly out-of-bounds (see Section VI), the negative delta in
these cases is non-constant and can be quite large, resulting
in pointers being wrapped. We investigated and found two
pre-2006 gcc patches which remove these cases, in both cases
since they are undeﬁned behavior; they are r62672 from 2003-
02-11, “Don’t use offset pointers.”, and r89543 from 2004-10-
25, “avoid undeﬁned pointer arithmetic on qty table”.
The obstack code in CPU2017’s version of gcc stores cross-
object pointer deltas in a temporary variable inside a struct
allocated on the heap, which is undeﬁned behavior. In fact, the
default behavior of the obstack code – including the version
in CPU2006’s gcc – is to avoid this by using a non-standard
C extension, where supported by the compiler. However, the
code in CPU2017 was modiﬁed by SPEC to disable the use
u_char
ngx_http_geo_range_t **ranges;
*p;
ranges[i] = (ngx_http_geo_range_t *)
(p - (u_char *) fm.addr);
Listing 7: Simpliﬁed code example from nginx 1.18.0’s
ngx_http_geo_create_binary_base function.
of this code path. We re-enable it by removing the newly-
added !defined(SPEC) from obstack.h. Note that there
is other undeﬁned behavior present in CPU2017 (such as
arithmetic using NULL pointers) which we resolve in our
canonicalization pass but present issues for upstream LLVM4.
CPU2016’s soplex uses a pointer delta to adjust pointers
after a call to realloc. We did not encounter this in our tested
conﬁguration (since these objects are allocated in the same
arena), and patching it appears to be non-trivial and invasive.
This issue has also been observed by other researchers [48].
Both the CPU2006 and CPU2017 versions of perlbench
make use of cross-object delta calculation in the mergesort
code. Our pointer analysis correctly handles this for CPU2006,
but in CPU2017 we were forced to exclude the mergesort
function. TDI warns about these issues at compile time, along
with various other unexpected patterns in the code, such as
casting a 0x55555555 constant to a pointer.
We only encountered issues with a single CPU2000 bench-
mark, 254.gap, due to a custom allocator/garbage collector
(‘Gasman’) which would need to be modiﬁed to support
arena-based allocation. We excluded (when instrumenting)
the TypHandle struct (used by GAP’s ‘Gasman’ allocator/-
garbage collector, ) as well as several functions.
nginx provides an illustrative example of arithmetic which
must be excluded, annotated or modiﬁed to be successfully
compiled with TDI. Our pass prints an error when trying to
instrument the http geo module of nginx, due to the code in
Listing 7, which subtracts a pointer from a pointer and stores
the result in an array of pointers (fm is a ﬁle mapping object;
we believe this code is trying to update the base address of an
array of pointers, and ranges should be a ptrdiff t*). Since the
base pointer cannot be determined, masking cannot be applied,
and compilation fails.
APPENDIX B
EVALUATION BUILD DETAILS
We applied patches to musl and libc++ to ﬁx LTO issues
(such as removing weak symbols) and patched several bench-
marks to ﬁx build issues (such as missing includes). We do not
instrument code which performs cross-arena arithmetic (e.g.,
ELF header parsing, vDSO support and stack unwinding); for
similar reasons, we do not instrument our allocator itself.
We needed to pass various compatibility ﬂags and make
some minor source changes (e.g., including header ﬁles) to
make the SPEC benchmarks build in our environment. A
4https://lists.llvm.org/pipermail/llvm-dev/2017-July/115064.html
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:57:47 UTC from IEEE Xplore.  Restrictions apply. 
151063
LLVM IR). Pointers which are added (or otherwise combined,
e.g., ORed) to a non-pointer remain pointers.
If a pointer is subtracted from another pointer, it becomes
a non-pointer; if a pointer is subtracted from a non-pointer, it
becomes a negative pointer. If a negative pointer is added to
a pointer, then we can mark the result as a non-pointer. We
treat similar patterns in the same way; for example, we mark a
pointer XORed with a negative constant as a negative pointer.
We found this to be essential for analyzing both real-world C
code and the output of some LLVM transformations.
then we add it
in a pointer type,
3) Base pointers: If an arithmetic operation is determined
to result
to a list of
potential pointer arithmetic operations, to be considered by the
remaining stages of our analysis. We then attempt to determine
the base pointer for each instance of such arithmetic. If only
one of the operands for an arithmetic operation is a pointer,
then we take that operand as the base pointer. If neither or
both operands are pointers, then we mark the base pointer as
invalid. We found this last case to occur in code calculating
pointer hashes, or in control ﬂow paths with unused results.
However, we do not remove these invalid instances of arith-
metic from the list of potential pointer arithmetic operations;
we later output a warning if we conclude that such arithmetic
should be masked. Although such situations are rare, they
do occur; an example can be found in Appendix A. During
evaluation, we erred on the side of caution, producing an error
rather than a warning, and manually annotated 4 cases which
could encounter this error in some build conﬁgurations.
APPENDIX D
ADDITIONAL RESULTS
perlbench
bzip2
gcc
mcf
milc
namd
gobmk
dealII
soplex
povray
hmmer
sjeng
libquantum
h264ref
lbm
omnetpp
astar
sphinx3
xalancbmk
0%
5%
10%
15%
20%
25%
30%
35%
Fig. 9. CPU2006 (peak) memory overhead
MODIFICATIONS APPLIED TO SPEC BENCHMARK CODE.
TABLE I
Software
CPU2000 gap
CPU2000 gap
CPU2006 gcc
CPU2017 gcc
CPU2017 perlbench
CPU2006 dealII
CPU2017 xz
Reason
Use of legacy termio
Custom garbage col-
lector
Undeﬁned behavior
(negative offsets)
Undeﬁned behavior
(cross-arena deltas)
Undeﬁned behavior
(cross-arena deltas)
Missing #include
>4GB allocation in
SPEC wrapper
Solution
Replaced with termios
Excluded type
Applied (pre-2005) up-
stream patches
!defined(SPEC) re-
moved from obstack.h
Excluded
S_mergesortsv
Added #include
Disable
LTO
spec_mem_io.c
for
summary of the (non-trivial) source changes can be seen in
Table I (together with the ﬁxes for the issues described above).
APPENDIX C