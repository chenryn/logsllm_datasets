以下是优化后的文本，使其更加清晰、连贯和专业：

---

### 参考文献

[15] S. A. Carr 和 M. Payer, “Datashield: 可配置的数据保密性和完整性,” 在 AsiaCCS '17.

[16] C. Carruth, “推测性加载硬化,” 2018年7月.

[17] M. Castro, M. Costa, 和 T. Harris, “通过强制数据流完整性来保护软件,” 在 OSDI '06.

[18] X. Chen, A. Slowinska, D. Andriesse, H. Bos, 和 C. Giuffrida, “Stackarmor: 对二进制文件的栈基内存错误漏洞提供全面保护,” 在 NDSS '15.

[19] D. Dhurjati 和 V. Adve, “C语言中具有非常低开销的向后兼容数组边界检查,” 在第28届国际软件工程会议论文集.

[20] D. Dhurjati, S. Kowshik, 和 V. Adve, “SAFECode: 强制弱类型语言的别名分析,” 在 PLDI '06.

[21] D. Dhurjati, S. Kowshik, V. Adve, 和 C. Lattner, “嵌入式应用中无需垃圾回收的内存安全,” 在 TECS '05.

[22] G. J. Duck 和 R. H. Yap, “EffectiveSan: 使用动态类型化的 C/C++ 进行类型和内存错误检测,” 在 PLDI '18.

[23] ——, “使用低脂肪指针进行堆边界保护,” 在 CC '16.

[24] U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, 和 G. C. Necula, “XFI: 系统地址空间的软件防护,” 在 OSDI '06.

[25] S. Ghemawat 和 P. Menage, “TCMalloc: 线程缓存 malloc.”

[26] M. Gretton-Dann, “Arm A-profile 架构开发 2018: Armv8.5-a,” 2018.

[28] N. Hadad J. 和 Afek, “克服 Spectre (部分) 浏览器缓解措施,” https://alephsecurity.com/2018/06/26/spectre-browser-query-cache/, 2018.

[29] Intel, “推测执行侧通道缓解措施,” 2018年7月, 版本3.0.

[30] I. R. Jenkins, P. Anantharaman, R. Shapiro, J. P. Brady, S. Bratus, 和 S. W. Smith, “Ghostbusting: 通过进程内内存隔离缓解 Spectre,” 在 HoTSoS '20.

[31] P. Kocher, “Microsoft 的 C/C++ 编译器中的 Spectre 缓解措施,” 2018.

[32] P. Kocher, J. Horn, A. Fogh, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp, S. Mangard, T. Prescher 等, “Spectre 攻击: 利用推测执行,” 在 S&P '19.

[33] K. Koning, X. Chen, H. Bos, C. Giuffrida, 和 E. Athanasopoulos, “无需隐藏: 在商用硬件上保护安全区域,” 在 EuroSys '17.

[34] T. Kroes, K. Koning, E. van der Kouwe, H. Bos, 和 C. Giuffrida, “Delta 指针: 无需检查的缓冲区溢出检查,” 在 EuroSys '18.

[35] J. A. Kroll, G. Stewart, 和 A. W. Appel, “便携式软件故障隔离,” 在 2014 IEEE 第27届计算机安全基础研讨会.

[36] V. Kuznetzov, L. Szekeres, M. Payer, G. Candea, R. Sekar, 和 D. Song, “代码指针完整性,” 在 OSDI '14.

[37] C. Lattner 和 V. Adve, “自动池分配: 通过控制堆中的数据结构布局提高性能,” 在 PLDI '05.

[38] Y. Liu, T. Zhou, K. Chen, H. Chen, 和 Y. Xia, “通过高效的管理程序强制域内隔离来阻止内存泄露,” 在 CCS '15.

[39] V. B. Lvin, G. Novark, E. D. Berger, 和 B. G. Zorn, “Archipelago: 以地址空间换取可靠性和安全性,” 在 ASPLOS '08.

[40] G. Maisuradze 和 C. Rossow, “Speculose: 分析 CPU 中推测执行的安全影响,” arXiv 预印本 arXiv:1801.04084, 2018.

[41] S. McCamant 和 G. Morrisett, “评估 CISC 架构的 SFI,” 在 USENIX Security '06.

[42] R. Mcilroy, J. Sevcik, T. Tebbi, B. L. Titzer, 和 T. Verwaest, “Spectre 将长期存在: 对旁路信道和推测执行的分析,” arXiv 预印本 arXiv:1902.05178, 2019.

[43] M. Miller, “软件漏洞缓解领域的趋势、挑战和战略转变,” 在 BlueHat IL '19.

[44] O. Moerbeek, “OpenBSD 的新 malloc (3),” 在 EuroBSDCon 2009.

[45] T. Mytkowicz, A. Diwan, M. Hauswirth, 和 P. F. Sweeney, “在没有任何明显错误的情况下产生错误数据!” 在 ASPLOS '09.

[46] M. Neugschwandtner, A. Sorniotti, 和 A. Kurmus, “内存分类: 分离攻击者控制的数据,” 在 DIMVA '19.

[47] G. Novark 和 E. D. Berger, “DieHarder: 保护堆,” 在 CCS.

[48] O. Oleksenko, D. Kuvaiskii, P. Bhatotia, P. Felber, 和 C. Fetzer, “Intel MPX 解释: Intel MPX 系统堆栈的跨层分析,” ACM 计算系统测量与分析会议论文集, 2018.

[49] O. Oleksenko, B. Trach, M. Silberstein, 和 C. Fetzer, “Specfuzz: 揭示 Spectre 类型的漏洞,” 在 USENIX Security '20.

[50] OpenSSL, “TLS 心跳读取溢出 (CVE-2014-0160).”

[51] T. Palit, F. Monrose, 和 M. Polychronakis, “通过保护内存驻留敏感数据来减轻数据泄漏,” 在 ACSAC '19.

[52] F. Pizlo, “Spectre 和 Meltdown 对 WebKit 的意义,” 2018年1月.

[53] S. Proskurin, M. Momeu, S. Ghavamnia, V. P. Kemerlis, 和 M. Polychronakis, “xmp: 内核和用户空间的选择性内存保护,” 在 S&P '20.

[54] J. Rafkind, A. Wick, J. Regehr, 和 M. Flatt, “C 语言的精确垃圾收集,” 在 ISMM '09.

[55] C. Reis, A. Moshchuk, 和 N. Oskov, “站点隔离: 浏览器内的网站进程分离,” 在 USENIX '19.

[56] M. Schwarz, M. Lipp, C. Canella, R. Schilling, F. Kargl, 和 D. Gruss, “ConTExT: 一种通用的 Spectre 缓解方法,” 在 NDSS '20.

[57] D. Sehr, R. Muth, C. L. Bifﬂe, V. Khimenko, E. Pasko, B. Yee, K. Schimpf, 和 B. Chen, “将软件故障隔离适应于当代 CPU 架构,” 2010.

[58] K. Serebryany, D. Bruening, A. Potapenko, 和 D. Vyukov, “AddressSanitizer: 一个快速的地址正确性检查器,” 在 2012 USENIX 年度技术会议 (USENIX ATC 12), 2012, pp. 309–318.

[59] F. J. Serna, “软件利用的信息泄露时代,” Black Hat USA, '10.

[27] M. Guarnieri, B. K¨opf, J. F. Morales, J. Reineke, 和 A. S´anchez, “Spectector: 原则性的推测信息流检测,” 在 S&P '20.

[60] H. Shacham, “无辜肉体上的几何学: 无函数调用的返回到 libc (在 x86 上),” 在 CCS '07.

[61] S. Silvestro, H. Liu, C. Crosser, Z. Lin, 和 T. Liu, “Freeguard: 一个更快的安全堆分配器,” 在 CCS '17.

[62] C. Song, B. Lee, K. Lu, W. Harris, T. Kim, 和 W. Lee, “通过数据流完整性强制内核安全不变量,” 在 NDSS '16.

[63] Y. Sui 和 J. Xue, “SVF: LLVM 中的过程间静态值流分析,” 在 CC '16.

[64] B. L. Titzer 和 J. Sevcik, “Spectre 一年: V8 的视角,” 2019年4月.

[65] A. Vahldiek-Oberwagner, E. Elnikety, N. O. Duarte, M. Sammler, P. Druschel, 和 D. Garg, “ERIM: 使用保护键 (MPK) 实现安全高效的进程内隔离,” 在 USENIX Security '19.

[66] E. Van Der Kouwe, T. Kroes, C. Ouwehand, H. Bos, 和 C. Giuffrida, “Type-after-type: 实用且完整的类型安全内存重用,” 在 ACSAC '18.

[67] S. Van Schaik, A. Milburn, S. Österlund, P. Frigo, G. Maisuradze, K. Razavi, H. Bos, 和 C. Giuffrida, “RIDL: 蠕虫飞行数据加载,” 在 S&P '19.

[68] M. Vassena, K. V. Gleissenthall, R. G. Kici, D. Stefan, 和 R. Jhala, “使用 Blade 自动消除加密代码中的推测泄漏,” 在 POPL '21.

[69] R. Wahbe, S. Lucco, T. E. Anderson, 和 S. L. Graham, “高效的软件故障隔离,” 在 SOSP, 1993.

[70] G. Wang, S. Chattopadhyay, I. Gotovchits, T. Mitra, 和 A. Roychoudhury, “oo7: 通过程序分析实现低开销的 Spectre 攻击防御,” IEEE 软件工程事务, 2019.

[71] B. Wickman, H. Hu, I. Y. D. Jang, J. L. S. Kashyap, 和 T. Kim, “通过快速前向分配防止 Use-After-Free 攻击,” 在 USENIX Security '21.

[72] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy, S. Okasaka, N. Narula, 和 N. Fullagar, “Native Client: 用于可移植、不受信任的 x86 本地代码的沙箱,” 在 S&P '09.

[73] B. Zeng, G. Tan, 和 G. Morrisett, “结合控制流完整性和静态分析以实现高效且验证的数据沙箱,” 在 CCS '11.

[74] T. Zhang, D. Lee, 和 C. Jung, “Bogo: 买空间内存安全, 几乎免费获得时间内存安全,” 在 ASPLOS '19.

### 未定义指针算术在软件中的问题
#### 附录 A

尽管 TDI 与多种软件兼容（如第九节所述），但它仍不兼容执行未定义指针算术并在函数边界之间使用结果的软件。在测试过程中，我们在几个软件中发现了此类指针算术问题。我们在此记录这些问题，以帮助未来的研究人员。

我们发现 CPU2006 版本的 GCC 将超出范围的指针（指向已分配对象之前）存储在全局变量中，这些全局变量随后被其他函数引用。虽然 TDI 可以处理稍微越界的指针（见第六节），但这些情况下的负增量是不恒定的，并且可能很大，导致指针被包裹。我们调查并发现了两个 2006 年之前的 GCC 补丁，它们消除了这些情况，因为它们是未定义行为；这两个补丁分别是 2003 年 2 月 11 日的 r62672，“不要使用偏移指针”，以及 2004 年 10 月 25 日的 r89543，“避免未定义的指针算术”。

CPU2017 版本的 GCC 中的 obstack 代码在一个堆上分配的结构体临时变量中存储跨对象指针增量，这是未定义行为。实际上，obstack 代码的默认行为——包括 CPU2006 版本的 GCC——是通过使用非标准的 C 扩展来避免这种情况，前提是编译器支持。然而，SPEC 修改了 CPU2017 中的代码，禁用了此代码路径。我们通过从 obstack.h 中删除新添加的 !defined(SPEC) 来重新启用它。请注意，CPU2017 中还存在其他未定义行为（例如使用空指针进行算术运算），我们在规范化传递中解决了这些问题，但在上游 LLVM4 中仍然存在问题。

CPU2016 的 soplex 在调用 realloc 后使用指针增量调整指针。在我们的测试配置中没有遇到这个问题（因为这些对象在同一区域内分配），并且修补它似乎非常复杂且侵入性强。其他研究人员也观察到了这个问题 [48]。

CPU2006 和 CPU2017 版本的 perlbench 在合并排序代码中都使用了跨对象增量计算。我们的指针分析在 CPU2006 中正确处理了这个问题，但在 CPU2017 中我们被迫排除了合并排序函数。TDI 在编译时警告这些问题，以及其他各种意外的代码模式，例如将 0x55555555 常量转换为指针。

我们只遇到了一个 CPU2000 基准测试的问题，即 254.gap，因为它使用了一个自定义的分配器/垃圾收集器（“Gasman”），需要修改以支持基于区域的分配。我们在工具化时排除了 TypHandle 结构（由 GAP 的“Gasman”分配器/垃圾收集器使用）以及几个函数。

nginx 提供了一个必须排除、注释或修改才能成功编译 TDI 的算术示例。我们的传递在尝试工具化 nginx 的 http geo 模块时打印了一个错误，原因是 Listing 7 中的代码减去了一个指针并将结果存储在一个指针数组中（fm 是一个文件映射对象；我们认为这段代码试图更新指针数组的基本地址，而 ranges 应该是一个 ptrdiff_t*）。由于无法确定基本指针，无法应用掩码，编译失败。

#### 附录 B
##### 评估构建细节

我们对 musl 和 libc++ 应用了补丁以修复 LTO 问题（例如，移除弱符号），并对几个基准测试进行了补丁以修复构建问题（例如，缺少包含文件）。我们不工具化执行跨区域算术的代码（例如，ELF 头解析、vDSO 支持和堆栈展开）；出于类似原因，我们也不工具化我们的分配器本身。

我们需要传递各种兼容性标志并进行一些小的源代码更改（例如，包含头文件）以使 SPEC 基准测试在我们的环境中构建。LLVM IR）。如果一个指针被另一个指针减去，它会变成非指针；如果一个指针被一个非指针减去，它会变成负指针。如果一个负指针被加到一个指针上，那么我们可以将结果标记为非指针。我们以相同的方式处理类似的模式；例如，我们将一个指针与负常量进行异或运算的结果标记为负指针。我们发现这对于分析实际的 C 代码和某些 LLVM 变换的输出至关重要。

然后我们将其添加到潜在指针算术操作的列表中，以供分析的其余阶段考虑。然后我们尝试确定每个此类算术实例的基本指针。如果算术操作的一个操作数是指针，那么我们将其作为基本指针。如果两个操作数都不是指针，或者都是指针，那么我们将基本指针标记为无效。我们发现最后一种情况发生在计算指针哈希或在控制流路径中有未使用结果的代码中。但是，我们不会从潜在指针算术操作的列表中删除这些无效的算术实例；如果得出结论认为此类算术应该被掩码，我们会稍后输出警告。尽管这种情况很少发生，但确实会发生；附录 A 中有一个示例。在评估过程中，我们采取了谨慎的态度，在某些构建配置中可能会遇到此错误的情况下，生成错误而不是警告，并手动注释了 4 个案例。

#### 附录 D
##### 附加结果

| 软件 | 原因 | 解决方案 |
| --- | --- | --- |
| CPU2000 gap | 使用旧的 termio | 替换为 termios |
| CPU2000 gap | 自定义垃圾收集器 | 排除类型 |
| CPU2006 gcc | 未定义行为（负偏移） | 应用（2005年前）上游补丁 |
| CPU2017 gcc | 未定义行为（跨区域增量） | 从 obstack.h 中移除 !defined(SPEC) |
| CPU2017 perlbench | 未定义行为（跨区域增量） | 排除 S_mergesortsv |
| CPU2006 dealII | 缺少 #include | 添加 #include |
| CPU2017 xz | 在 SPEC 包装器中 >4GB 分配 | 禁用 LTO spec_mem_io.c |

表 I 总结了（非平凡的）源代码更改（以及上述问题的修复）。

#### 附录 C

---

希望这些优化能够使文本更加清晰、连贯和专业。如果有任何进一步的需求，请告诉我！