compute each tracer’s mean performance relative to HeXcite’s across all benchmarks (shown in the rightmost plot). For each benchmark we omit incompatible
tracers (denoted by a colored ✗). All comparisons to HeXcite yield a statistically significant difference (i.e., Mann-Whitney U test 𝑝 < 0.05).
omits hit counts beyond this range. Table 8 reports HeXcite’s mean
coverage across all loops for each binary relative to UnTracer and
AFL-Clang; and Figure 8 shows a heatmap of HeXcite’s per-loop
coverage relative to UnTracer’s for several benchmarks.
Versus UnTracer: As Table 8 shows, HeXcite’s bucketed un-
rolling brings 130% higher loop penetration coverage over Un-
Tracer. We see that UnTracer beats HeXcite on a minutia of loops
per benchmark (Figure 8)—expectedly—as its inability to track loop
progress inevitably constrains fuzzing to exploring the same few
loops trial after trial. We find that HeXcite queues over 2× as many
test cases, thus showing that its loop-progress-aware coverage leads
fuzzing to sacrifice focusing on the same few loops in favor of a
higher diversity of loops per binary.
Versus source-level always-on tracing: We see that, on aver-
age, HeXcite attains a 36% higher loop coverage than source-level
always-on tracing with AFL-Clang. Though this improvement is
modest, these results show that bucketed unrolling outperforms
conventional coverage tracing’s exhaustive (i.e., on every basic
block) hit count tracking—yet only instruments loop headers. While
we posit that bucketed unrolling has further optimization potential
(e.g., halving the number of buckets, selective insertion, etc.), we
leave exploring this trade-off space to future work.
Q1: Jump mistargeting and bucketed unrolling enable Coverage-
preserving CGT to achieve the highest overall coverage versus block-
only CGT—as well as conventional binary and source-level tracing.
5.3 Q2: Performance Evaluation
To measure the impacts of finer-grained coverage on CGT perfor-
mance, we perform a piece-wise evaluation of the fuzzing test case
throughput (i.e., mean total test cases processed in 24-hours) of
HeXcite’s edge (via jump mistargeting) and full (jump mistargeting
+ bucketed unrolling) coverage versus UnTracer’s block-only cov-
erage, shown in Table 9. To ascertain where coverage-preserving
CGT’s performance stands with respect to always-on tracing, we
further evaluate HeXcite’s best-case throughput alongside the
leading binary- and source-level coverage tracers QEMU, Dyninst,
RetroWrite, and AFL-Clang, shown in Figure 9.
Versus UnTracer: As Table 9 shows, incorporating edge cov-
erage in CGT incurs a mean throughput slowdown of 3%, while
supporting full coverage (i.e., edges and counts) sees a slightly
higher slowdown of 8%. However, as the experiments in § 5.2.1 and
Edge / Block
Rel. Perf MWU
<0.001
0.52
0.046
0.93
<0.001
1.46
0.99
0.433
<0.001
1.06
0.150
0.96
0.332
1.04
0.125
0.97
0.292
0.74
1.02
0.002
0.492
1.01
0.97
0.188
97%
Full / Block
Rel. Perf MWU
<0.001
0.54
<0.001
0.65
<0.001
2.61
1.07
0.090
<0.001
1.24
<0.001
0.64
<0.001
0.78
<0.001
0.18
0.448
0.82
0.99
0.332
<0.001
0.68
0.90
0.047
92%
Best / Block
Rel. Perf MWU
<0.001
0.54
0.046
0.93
<0.001
2.61
1.07
0.090
<0.001
1.24
0.150
0.96
0.332
1.04
0.125
0.97
0.448
0.82
1.02
0.002
0.492
1.01
0.97
0.188
110%
Binary
jasper
mjs
nasm
sam2p
sfconvert
tcpdump
unrtf
yara
lzturbo
pngout
rar
unrar
Mean Rel. Perf.
Table 9: Performance trade-offs of different CGT coverage granularities. We
compute mean throughputs for three HeXcite coverage granularities (edge,
full, and the best of both) relative to UnTracer’s block-only granularity.
§ 5.2.2 show, coverage-preserving CGT attains the highest edge
and loop coverage of all tracers in our evaluation—offsetting the
performance deficits expected of finer-grained coverage (e.g., from
spending more time covering more loops). Furthermore, as column
3 in Table 9 shows, HeXcite’s best-case performance is nearly in-
distinguishable from UnTracer’s, with performance statistically
improved or identical on all but two benchmarks.
Versus binary-only always-on tracing: As Figure 9 shows,
HeXcite averages 11.4×, 24.1×, and 3.6× the throughput of always-
on binary-only tracers QEMU, Dyninst, and RetroWrite, respec-
tively. Furthermore, we observe that all 23 comparisons to HeXcite
yield a statistically significant improvement in HeXcite’s speed
over these competing binary-only tracers.
Versus source-level always-on tracing: HeXcite averages
2.8× the throughput of AFL’s main source-level coverage tracer
AFL-Clang. In only one case (nasm) does HeXcite face lower a
throughput of around 19%; however, the remaining seven open-
source benchmarks see HeXcite attaining a statistically higher
throughput. Thus, we conclude that HeXcite’s coverage-preserving
CGT indeed upholds the speed advantages of CGT—outperforming
even the ordinarily-fast source-level tracing.
Q2: Coverage-preserving CGT trades-off a negligible amount of speed
to attain the highest binary-only code and loop coverage—and still
outperforms conventional always-on binary- and source-level tracing
with over 2–24× the test case throughput.
jaspersam2pyara020406080Relative Total Executionsxxxmjsnasmsfconverttcpdumpunrtflzturbopngoutrarunrar0.02.55.07.510.012.5xxxxxxxxxxxxxxRel. Mean0.00.20.40.60.81.0QEMUDyninstRetroWriteClangHeXciteSession 2A: Fuzzing and Bug Finding CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea360(a) nasm
Binary
jasper
mjs
nasm
sam2p
sfconvert
tcpdump
unrtf
yara
pngout
unrar
Mean Increase
Figure 10: HeXcite’s mean unique bugs over time relative to all supported tracing approaches per benchmark.
(b) sfconvert
(c) unrtf
(d) pngout
vs. Coverage-guided Tracing
HeXcite / UnTracer
HeXcite / QEMU
Rel.
Crash
1.40
1.37
1.99
1.43
1.52
1.28
1.88
0.72
1.27
1.25
+41%
Rel.
Bugs
0.97
1.02
1.21
1.05
1.23
1.04
1.48
1.02
1.36
0.80
+12%
MWU
0.241
0.462
<0.001
0.447
<0.001
0.212
<0.001
0.215
<0.001
0.279
Rel.
Crash
25.32
17.33
20.03
Rel.
Bugs
19.92
6.71
13.63
✗
✗
2.43
1.37
16.80
2.49
2.00
+997%
✗
✗
1.64
1.35
2.34
2.17
2.00
+521%
MWU
<0.001
<0.001
<0.001
✗
✗
<0.001
0.001
<0.001
<0.001
0.039
Rel.
Bugs
HeXcite / RetroWrite
Rel.
Crash
vs. Binary- and Source-level Always-on Tracing
HeXcite / Dyninst
Rel.
Crash
42.50
12.27
18.93
2.24
1.42
1.91
1.67
22.49
MWU
<0.001
<0.001
<0.001
<0.001
<0.001
<0.001
<0.001
<0.001
✗
5.92
✗
✗
1.56
1.29
1.18
12.58
✗
✗
✗
<0.001
0.048
0.001
<0.001
<0.001
MWU
Rel.
Bugs
37.00
3.38
19.24
1.36
1.35
1.27
1.46
2.89
✗
✗
✗
1.84
✗
✗
1.53
1.09
1.28