FieldMatch =FieldMatch.NextMatch
End while
在这个例子中，我仅仅从jfried1namespace导人，但也可以很简单地从jfiedl.csV
namespace导人，然后这样创建Regex对象：
Dim FieldRegex as GetField=New GetField·生成新的regex对象
这是两种风格。
---
## Page 461
.NET高级话题
435
通过装配件构建自己的正则表达式库
这个例子构建了一个小规模的正则表达式库。完整的程序构建了一个装配件（DLL），
其中包含三个已经生成的Regex构造函数：jfriedl.Mai1.Subject，jfriedl.Mail.
Fromfojfriedl.CSV.GetField
前两者很简单，一眼就能明白，最后那个复杂的构造函数展示了构建库的约定
(promise)。请注意，这里不需要设定RegexOptions.Compiled，因为在构造装配件
时已经隐含地设定了。
关于如何使用构建好的装配件，请参考第434页。
Option Explicit On
Option Strict On
Imports System.Text.RegularExpressions
Imports System.Reflection
Module BuildMyLibrary
Sub Main ()
下面调用regexCompliationInfo时提供了pattern、regex选项、类内部的名称、类名，
·以及一个Boolean值表明类是否public。举例来说，要使用第一个类，
‘程序必须使用装配件中"jfriedl.Mail.Subject作为Regex的构造函数。
Dim RCInfo() as RegexCompilationInfo ={
New RegexCompilationInfo(
"^Subject:\s*(.*)·,RegexOptions.IgnoreCase,
"Subject"，"jfriedl.Mail"，true),
New RegexCompilationInfo(
*^From:\s*(.*)",RegexOptions.IgnoreCase,
"From",*jfriedl.Mail",true),
！
New RegexCompilationInfo(
“\G(？:1,)
&
* (? :
&
一
”（?#或者是双引号宇段...
一
&
（？#起始双引号
&
一
·(?
&
一
(?>
"*（？#结束双引号
&
）
（？#...或者...
"&
）
&
·（?#...非引号/非通号文本..）
(?[^"，]*)
&
RegexOptions.IgnorePatternwhitespace,
"GetField","jfriedl.Csv",true)
一
一
‘现在进行主要的处理，生成结果...
Dim AN as AssemblyName = new AssemblyName()
AN.Name=“JfriedlsRegexLibrary”‘DLL文件的名字
AN.Version = New Version(*1.0.0.0*)
Regex.CompileToAssembly（RCInfo，AN)'构建完成
End Sub
End Module
---
## Page 462
436
第9章：.NET
也可以不进行任何导人，而是直接使用：
Dim FieldRegex as jfriedl.CSV.GetField= New jfriedl.CSV.GetField
这有点麻烦，但是清楚地说明了对象的出处。同样，这只是风格的问题。
匹配嵌套结构
Matcling Nested Constructs
微软提供了一种创新的功能，专门用于匹配对称的结构（长期以来，正则表达式对此无能
为力）。它理解起来并不容易一本节篇幅不长，但请注意，其中的内容分量不少。
最简单的办法就是用一个例子来说明：
Dim R As Regex = New Regex(* \(
(?>
&
[~()] +
&
\((?)
"&
\）(?)
·&
"&
(?(DEPTH) (?!))
*&
RegexOptions.IgnorePatternWhitespace)
它匹配第一组正确配对的嵌套括号，例如‘before（nope（yes（here）okay）after'
中用下画线标注的部分。第一个开括号不会匹配，因为它没有对应的闭括号。
这里简要说明了程序的工作原理：
前括号嵌套深度值加1。
2.每匹配一个‘)’，（？）会把深度减1。
3.“（？（DEPTH）（？!））确保最后的）匹配时，深度应该为0。
因为引擎的回溯堆栈保存了当前匹配成功分组的信息，这个办法没有问题。（?）
只是使用了命名捕获的（），它总是能成功匹配。因为它紧跟在（之后，它的成功匹配（此
信息会保存在堆栈中，直到出栈为止）用于标记开括号的数目。
因此，当前已经成功匹配的‘DEPTH’分组总数就保存在回溯堆栈中。我们希望在找到闭括
号之后减去它们。.NET独有的（?）结构，会从堆栈中去掉最近的“succeSsful
---
## Page 463
.NET高级话题
437
DEPTH”标记。如果不存在这样的标记，（?）就会报告失败，整个正则表达式的
匹配宣告失败。
最后的'（？（DEPTH）（？！））是一个普通的条件判断，如果“DEPTH’分组匹配成功它会应用
（？！）。如果在程序运行到此处时选择应用此分支，就表示还存在未匹配的开括号。果真如
此的话，我们就需要退出匹配（我们不希望匹配不对称的序列）所以我们用否定型顺序环
视（？！）来做检查，确保匹配失败。
看到了吗？这就是.NET正则表达式匹配嵌套结构的原理。
Capture对象
Capture Ohjects
.NET的对象模型中还包括Capture对象，之前一直没有介绍过。依视角的不同，它可能为
匹配结果增加了新的观察角度，也可能是增加把结果弄得更精。
Capture对象几乎等价于Group对象，因为它表示一组捕获型括号匹配的文本。与Group
对象一样，它提供了Value（匹配的文本）、Length（匹配文本的长度），以及Index（匹
配文本在目标字符串中的偏移值，编号从0开始）。
对应到匹配过程中各分组的未确定匹配（intermediarymatch），以及该分组最终匹配的文本。
看下面这个例子：
Dim M as Match = Regex.Match(*abcdefghijk","^(..)+")
就是说，M.Groups（1）.Value等于‘ij'）。相反，M.Groups（1）同样包含一组Capture，
它们对应到（..）的匹配过程：
M.Groups(1).Captures(0).Value is‘ab'
M.Groups(1).Captures(1).Value is ‘cd
M.Groups(1).Captures(2).Value is‘ef'
M.Groups(1).Captures(3).Value is‘gh
M.Groups (1).Captures(4).Value is
‘ij’
M.Groups(1).Captures.Count is 5.
---
## Page 464
438
第9章：.NET
你也许会注意到，最后匹配的‘ij’等同于最终全局匹配中的M.Groups（1）.Value。看起
来，Group的Value就是本分组最终匹配文本的简记法。M.Groups（1）.Value是：
M.Groups (1).Captures(M.Groups（1).Captures.Count -1).Value
关于Capture，还要讲几点：
·M.Groups（1）.Capture 是一个CaptureCollection，与普通的集合类（collection）
一样，它包含了Items和count属性。不过，通常大家都不会使用这两个属性，而是
通过索引值直接访问，例如M.Groups（1）.Captures（3）（在C#中是M.Groups[1]，
Captures[3])。
Capture对象没有Success方法，如果需要，请测试Group的Success。
·
到现在，我们已经看到，Capture对象在Group对象内部可用。Match对象也有
captures属性，尽管涌出并不大。M.Captures可以直接访问编号为O的分组的
Captures属性（也就是说M.Captures等价于M.Groups（0）.Captures）。因为编号
为0的分组表示整个匹配，所以不会有“逾历”匹配的选代，所以编号为0的捕获集
合类只有一个Capture。因为它们包含与编号为0的匹配同样的信息，M.Capters和
M.Groups（0）.Captures并不是很有用。
.NET的capture对象是一种创新，但是因为与对象模型“集成过度（overlyintegrated)”，
使用起来反而更复杂，而且令人迷惑。在仔细参阅了.NET的文档，并真正理解了这些对象
之后，我感觉这种做法有利也有弊。一方面，我乐于看到这种创新。虽然它的用法并不会
马上显现出来，但这或许是因为一直以来我都习惯于用传统的正则表达式特性来思考问题。
另一方面，在匹配过程中的额外的分组，匹配完成之后把它们封装到一个对象中，似平降
低了效率，我并不希望降低效率，除非要得到额外的信息。增加的Capture分组在大多数
匹配中不会用到，但是照目前的情况来看，生成Match对象时会构建所有的Group和
Capture对象（以及它们相关的GroupCollection和CaptureCollection对象）。所以无
论是否需要，它们都在那里，如果你能够发现capture对象的使用价值，就不要放过。
---
## Page 465
10
第
章
PHP
PHP
20世纪90年代末期Web的迅猛发展导致了PHP的爆炸性流行，并一直持续至今。PHP得
以流行的理由之一是，即使非专业人员，只需要稍作准备，就能使用PHP的基本功能。除
此之外，PHP还提供了颇受开发老手欢迎的众多高级特性和函数。PHP当然能够支持正则
表达式，而且提供了至少3套独立的，不相关的正则引擎。
PHP的三种正则引l擎是“preg”、“ereg”和“mb_ereg”。本书介绍的是preg引|擎提供的函
数。它使用NFA引擎，通常情况下，在速度和功能方面都要强于其余两者（“preg”读作
"p-reg")。
与之前各章的联系在开始本章之前，读者必须知道，本章的内容强烈依赖于第1至6章介
绍的基础知识。如果读者只对PHP感兴趣，可能会直接从本章开始阅读，但我还是希望他
们认真地看一看前言（尤其是关于体例）和前面的章节：第1、2、3章介绍了与正则表达
式相关的基本概念、特性和技术，第4、5、6章介绍了一些理解正则表达式的关键知识，
它们可以直接应用到PHP的正则表达式中。前几章讲解的重要概念包括NFA引擎进行匹配
基本原理，匹配优先特性、回溯和效率。
接下来我要强调，除了用于速查列表例如本章的第407页，和第3章从第114页到第
123页，我并不希望这本书成为一本参考手册，而希望它成为精通正则表达式的详细教科书。
---
## Page 466
440
第10章：PHP
本章开始简要介绍了preg引擎的历史，然后介绍它的正则流派。接下来的儿节详细考察了
preg函数的接口，然后是关于preg的效率问题，最后是扩展示例。
preg的背景和历史preg这个名字来自接口函数名的前缀，代表“Perl的正则表达式（Perl
RegularExpressions）”。preg引擎的创始人是AndreiZmievski，他对当时作为标准的ereg套
件的诸多肘相当不满意。（ereg表示“扩展的正则表达式（extendedregularexpressions)”，
它能兼容POSIX标准，“扩展”的意思是不仅仅限于一个最简单的正则流派，但是以今天的
标准来看，还相当简陋）。
Andrei的preg套件是一组PCRE（即“Perl兼容的正则表达式”PerlCompatibleRegular
Expressions）接口，这是一套非常棒的基于NFA的正则表达式库，完整地模拟了Perl的语
法和语意，提供了Andrei想要的能力。
在接触PCRE以前，Andrei先阅读了Perl的源代码，以决定是否能够借用到PHP当中。他
显然不是第一个阅读Per的正则表达式源代码的人，也不是第一个认识到代码有多么复杂
的人。Peri的正则表达式功能强，速度快，源代码也在许多年间经过了许多人的修改，已经
超出了单个开发人员的理解能力。
幸运的是，剑桥大学的PhilipHazel同样已经被Perl的正则表达式的源代码搞得头昏脑胀，
所以他写了PCRE库（参见第91页）。好在Philip已经有了现成的可供模拟的语意，所以若
干年后，Andrei找到了这套编写清晰、文档完备、效率出众的库，很方便就能将其绑定到
PHP中。
Perl随着时间的流逝而不断发展，PCRE也是这样，PHP亦然。本书针对的是PHPVersions
4.4.3和5.1.4，这两者都兼容PCREVersion6.6（注1)。
如果你不熟悉PHP的版本信息，清注意4.x和5x是同时维护的，而5.x进行了大规模的扩
展。因为两个系列是分开维护和发布的，很可能某个5.x的版本所用的PCRE的版本要低于
更晚发布的4x版本。
注1：在写作本章时，我研究了当时可用的PHP和PCRE的版本，发现了一些bug，不过本书针
对的PHP4.4.3和5.1.4中已经修正了这些问题。在早期的版本中，本章的某些例子可能无
法正常工作。
---
## Page 467
PHP的正则流派
441
PHP的正则流派
PHP‘s Regex Flavor
表10-1：PHPpreg的正则流派
字符缩略表示法
115 (c)
a[\b]\e\f\n\r\t\octal\xhex\x{hex}\cchar
字符组及相关结构
118 (c)
字符组：【][…]（可包含集合运算符125）
611