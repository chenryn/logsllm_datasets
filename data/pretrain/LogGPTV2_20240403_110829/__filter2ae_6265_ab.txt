    {"a":"A", "b":"B", "c":"C", "d":"D", "junk":"JUNK"}
或者，在另一些情况下，可以由以下只包含三个key-value对的原请求生成
    {"a":"A&b=B", "c":"C", "d":"D"}
这些变形依赖于“待签字符串”的生成方法。攻击者可以通过构造畸形请求来生成具有相同“待签字符串”的请求，从而绕过签名验证限制。
**支付协议的安全漏洞**
由以上分析，第三方支付过程的安全严重依赖于以下三点：
1.密钥的安全管理
2.支付平台签名算法的正确实现
3\. 商户对支付协议的正确使用
然而在生产环境中每个环节都有可能出错，引起严重的安全隐患。
**1.密钥泄露**
这是最常见的一种安全漏洞。密钥泄漏并不是一种罕见的情况，不少app在开发时，将密钥硬编码在app代码中（用于本地实现签名计算）。消息的完整性依赖于签名的计算，密钥泄漏后消息将无法保证未被篡改或伪造。但对称密钥和不对称密钥泄漏后的利用和危害有所区别。
图4展示了最常见的情况。MD5签名密钥编码在用户App中造成密钥泄露。在对相当多的app进行逆向工程后我们发现，有部分app直接照搬一些样例代码，导致key被直接明文编码到程序中，非常容易提取。还有一部分app作者使用了一些变形手段，例如将key拆成奇数位、偶数位分别存储，或使用特定常数进行异或存储。这些简单变形在熟练的攻击者面前是徒劳的。
由于商户和支付平台共享密钥，密钥泄漏后，攻击者既可以冒充商户向支付平台发送订单消息，又可以冒充支付平台向商户发送支付结果。当然，后者更加直接（如图4）。
例如，若攻击者准备购买一件商品，其订单消息为
    notify_url=http://seller.com/notify&out_trade_no=12345&seller=alice&total_fee=100&sign=XXX,
攻击者可以首先通过修改notify_url到攻击者掌控的地址，如http://attacker.com/,提交请求:
    notify_url=http://attacker.com/notify&out_trade_no=12345&seller=alice&total_fee=100&sign=XXX
来获得notify_url的结构。再伪造以下消息签名后发送给商户，伪造异步通知，实现免费购物。
    target_url: http://seller.com/notify
    post_data: put_trade_no=12345&seller=alice&total_fee=100&trade_status=SUCCESS&sign=XXX.
商户收到消息后验证签名正确，所有参数均正确，将完成攻击者的订单。而事实上，攻击者并未进行过任何支付。
另一方面，基于非对称密码体制的签名方案中，私钥泄露后攻击者也可以进行攻击。但是仍依赖于其他的逻辑漏洞。攻击者只能获取商户的私钥，而支付平台的私钥往往被妥善保护无法获得。因此，攻击者无法冒充支付平台向商户发送支付成功的消息，而只能冒充商户向支付平台伪造订单或者篡改订单，修改支付金额。
如图5所示，若攻击者准备购买一件商品，其订单消息为
    notify_url=http://seller.com/notify&out_trade_no=12345&seller=alice&total_fee=100&sign=XXX
攻击者修改金额，使用私钥重新签名，并提交支付订单
    notify_url=http://seller.com/notify&out_trade_no=12345&seller=alice&total_fee=1&sign=XXX
成功支付1元后，商户会收到支付结果消息
    out_trade_no=12345&seller=alice&total_fee=1&trade_status=SUCCESS&sign=XXX
商户进行消息的验证，会发现签名正确，商户号正确，订单12345支付成功。若商户没有验证支付金额与订单是否匹配，将完成攻击者的订单。从而攻击者以1元购买了100元的商品。在许多App中，曾出现过只验证签名和订单id的情况，没有验证实付金额，因此可以通过这种金额篡改进行攻击。
为了防御这样的攻击，商家一定要修改app和服务端的设计，使得签名全部在服务端进行。网上充斥着大量可以直接照搬的富含漏洞的样例代码，一定不要简单修改这些代码就直接接入支付平台。此外，每笔交易均要进行查账，验证钱真的得到了支付，才可以标记订单为成功支付。
一旦出现这样的秘钥泄漏商家将面临严峻的安全风险，支付平台也将面临严重的连带品牌危机。发生这样的危机时，如果简单的替换秘钥将会直接导致老App客户端无法进行交易，如果不替换则将面临严峻的支付风险。目前临时缓解方案是依靠商家服务后台与钱包服务后台的增强校验和风控来探测和抵抗攻击。
**2.签名算法实现错误**
签名泄露只影响个别自己实现错误的商家，而支付平台的漏洞则会影响千万商家。在这一节我们讨论我们提交给两个国内著名支付平台的平台漏洞，他们均已得到修复。
**案例一**
第三方支付平台A采用了对称密钥的设计，并提供了服务端SDK供商家集成。服务端SDK提供了API验证签名是否正确。
在PHP和C#的SDK实现中，当签名字段不存在时，SDK会直接返回签名正确，这就导致了攻击者可以直接冒充支付平台向商户发送伪造的支付结果消息并通过签名认证。
以PHP版代码为例
    public function CheckSign()
    {
           if(!$this->IsSignSet()){
                    returntrue;
           }  
           $sign = $this->MakeSign();
           if($this->GetSign() == $sign){
                    returntrue;
           }  
           throw newException("签名错误！");
    }
    public function IsSignSet()
    {
       return array_key_exists('sign', $this->values);
    }
检查签名时，首先会利用函数 IsSignSet判断签名是否存在。若签名不存在，直接认为签名正确。
由于该支付平台要求商户服务器将订单（包括通知URL）发送给支付服务器获取一个ID，随后商户应用将ID传递给支付客户端调起支付界面，在实际攻击中，
攻击者还需要从其他渠道获取通知URL（例如路径猜测、URL硬编码或存在网络请求中等）才可伪造支付结果。
**案例二**
支付平台B采用了非对称密钥的设计，每个商户有自己的一套公钥私钥，但支付平台的公钥私钥仅一套，即所有商户使用同一个公钥验证来自支付平台的消息。
除此以外，订单消息和支付结果消息中包含字段body描述商品信息，且订单消息和对应支付结果消息中的body一致。
如果攻击者希望免费(低价)购物,应该如何进行呢？回顾上文中关于待签字符串二义性的讨论，待签字符串为形如：
    key1=value1&key2=value2&key3=value3
的格式。&和=作为了连接符号。