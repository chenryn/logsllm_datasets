°C
[ :[puss]@
[redis-server] : 3
[srmpd] : 6
8℃ = [ao2aapu9s]
LLE&t :[ene[1θ
The user-level stack trace can also be inspected by adding ustack to the map key.
The sockstat(8) tool works by tracing key socket-related syscalls using tracepoints, and the
is likely to be the most noticeable, and may become measurable on high network-throughput
sock_recvmsg0 and sock_sendmsg0 kernel functions using kprobes. The overhead of the kprobes
systems.
The source to sockstat(8) is:
+1/usr/local/bin/bpftrace
BEGIN
printf (*Tracing sock statistics. Output every 1 second. n*);
tracepoint:syscalls:sys_enter_accept*,
tracepointsyscalls1sys_enter_connect,
tracepoint:syscalls:sys_enter_bind,
tracepoint:syscalls1sys_enter_socket*,
kprobe :sock_recvmsg,
Bgupuasxoos:aqordy
 [probe] =  count 1:
9 Note for this and.
---
## Page 451
414
 Chapter 10 Networking
interval:s:1
t.ime () 
print (8)
clear (81
The use of these kprobes is a shortcut. These could be traced using syscall tracepoints instead. The
recvfrom(2),recvmsg(2), sendto(2), and sendmsg(2) syscalls, and other variants, can be traced
by adding more tracepoints to the code. It becomes more complex with the read(2) and write(2)
family of syscalls, where the file descriptor must be processed to determine the file type, to match
on socket reads and writes only.
10.3.2 sofamily
sofamily(8) traces new socket connections via the accept(2) and connect(2) system calls and
summarizes the process name and address family. This is useful for workload characterization:
quantifying the load applied and looking for any unexpected socket usage that needs further
investigation. For example, on a prodluction edge server:
+sofanily.bt
Attaching 7 probes...
Tracing socket connect/accepts. Ctrl-C to end.
C
paccept [sshd, 2, AF_INET]: 2
acoept[Java, 2, AF_INET|: 420
econnect[sshd, 2, AF_IMET]: 2
?connect [sshd, 10, AF_INET6| : 2
econnect[ (systend) , 1, AF_UMIX] : 12
econnect[sshd, 1, AF_OBIX]: 34
econnect[java, 2, AF_IxET]: 215
This output shows 420 AF_INET (IPv4) accepts and 215 connection attempts by Java while tracing,
which is expected for this server. The output shows a map for socket accepts (@accept) and
connects (@connect), with the keys process name, address family numbet, and the adress family
name for that number if known.
u paugap s pue xnur o ogoads st (z == I3NIdv *8·a) s8unddeu 1aqunu Apuey ssarppe au
the include/linux/socket.h header. (The table is included on the following pages.) Other kernels
use their own number mappings.
10 0rigin: I crested this tool for this book on 10-Apr-2019,
---
## Page 452
10.3 BPF Tools
415
Since the traced calls occur at a relatively low rate (compared to packet events), the overhead of
this tool is expected to be negligible.
The source to sofamily(8) is:
#1/usx/1ocal/bin/bpEtrace
#include 
BEGIX
printf(*Tracing socket connect/accepts. Ctrl-C to end.\n*) 
 / / fron linux/socket.h:
Bfan2atr [AF_UNSPEC] = *AF_UNSPEC*
Bfan2str [AF_UMIx] = *AF_UNIX*
I3NIav。 - [1aIax1szueg8
Bfan2str [AF_IMET6] = *AF_IMET6*;
tracepoint:syscalls:sys_enter_connect
Bconnect [comn, args=>uservaddr=>sa_fanlly,
Bfan2str [args=>uservaddr>sa_fanily]] = count () 
tracepoint:syacalls:sys_enter_accept,
tracepoint:syscalls1sys_enter_accept4
Bsockaddr [tid] = args=>upeer_sockaddr;
1
tracepoint:syscalls:ays_exit_accept,
tracepointisyscallsisys_exit_accept4
/Bsockaddr [t1d] /
1f (aεgs->ret > o) (
$sa = (struct sockaddr *)@sockaddr[tid];
paccept [comn, sa=>sa_fanily, @fan2ate [§sa=>sa_fanily1] =
count () =
delete (esockadde [tid]) 
EXD
---
## Page 453
416
Chapter 10 Networking
clear (Bsockaddr) : cleax (Bfam2stx) 
The addressfamily is read from the sa_family member of struct sockaddr. This is a number of type
sa_family_t, which resolves to unsigned short. This tool includes the number on the output and
also maps some common address families to string names to aid readability, based on this table
from linux/socket.h:
/* Suppoxted adress famLlles. */
define AF_UMSPEC
define AF_UNIX
1
/* Un.x donain socket.s
• /
define AF_LOCAL
1
/*
POSIX nane for AF_UNIX
* /
define AF_INET
2
/* Intexnet IP Pzotoco1
• /
#define AF_IPX
define AF_Ax25
/* Anateur Radio AX.25
* /
/* Nove11 IFX
define AF_APPLETALK
/* AppleTa1k DOF
* /
define AF_NETRON
/*
Anateur Radlo NET/ROM
• /
define AF_BRIDGE
/* Multiprotocol bridge
* /
define AF_ATXPVC
/* ATH PVCs
• /
define AF_x25
9
/* Reserved for X.25 project
* /
#define AF_INET6
10
/* IP verslon 6
• /
[.-]
This header is included when running this bpftrace program, so that this line:
efan2ste[AF_INET] - "AF_INET*;
becomes:
fan2ste[2] - *AF_IMET*;
mapping the number two to the string *AF_INET".
For the connect(2) syscall, all details are read on the syscall entry. The accept(2) syscalls are traced
differently: the sockaddr pointer is saved in a hash and then retrieved on the exit of those syscalls
to read the address family. This is because the sockaddr is populated during the syscall, so must be
read at the end. The accept(2) return value is also checked (was it successful or not?); otherwise,
the contents of the sockaddr struct would not be valid. This script could be enhanced to do a
similar check for connect(2), so that the output counts are given only for successful new connec-
tions. The soconnect(8) tool shows the different return results for these connect(2) syscalls.
10.3.3 soprotocol
soprotocol(8) traces new socket connections and summarizes the proces name and transport
protocol. This is another workload characterization tool, for the transport protocol. For example,
on a production edge server:
11 Origin: I created this tool for this book on 13-Apr-2019.
---
## Page 454
10.3 BPF Tools
417
+ soprotocol.bt
Attaching 4 prcbes..
Tracing socket connect/accepts. Ctr]-C to end
°C
accept[aVa, 6, IPPR0T0_TCP, TCP]: 1171
econnect[setuidgid, 0, IPPROTO, UNIX] : 2
econnect[ldconfig, 0, IPPRoTo, NIx] : 2
@connect[aystend=xesolve, 17, IPPRoTo_uUDP, UDP} : T9
connect[java, 17, IPPROTO_UDP, UDP]: B0
econnect[Java, 6, IPPROTo_TCP, TCP]: 559
This output shows 559 TCP accepts and 1171 TCP connects by Java while tracing. The output
‘seu ssaoosd :sax aue gm (poauuo@) sqoauuo pue (sdaooe@) sqdaooe papos rog deu e smous
protocol number, protocol name for that number if known, and protocol module name.
Since these calls happen at a relatively low rate (compared to packet events), the overhead of this
tool is expected to be negligible.
The source to soprotocol(8) is:
#1/usr/local/bin/bpftrace
include 
BEGIN
printf (*Tracing socket connect/accepts. Ctr]-C to end.n*)
/ / fron Include/uap1/1inux/in_h:
Bprot2str [IPPoro_1P] - *IpPoro_1e*;
Bpzot2str[IPPROTO_ICNP] = *IPPROrO_ICMP*;
dano1o8aaI。 - [4on"0t0ged1]asgaoxdg
kprobe:security_socket_accept,
kprobe:secuxl ty_socket_connect
$sock = [atruct socket *)arg0;
$protoco] = $sock->sk->sk_protocol & Oxff;
Bconnect[comm, Sprotocol, @pxot2stx[5protoco1]
o [aueuname. This is convenient, and I've used this
in other tools to print the transport protocol. Here is an an example from net/ipv4/tcp_ipv4.c:
struct proto tcp_prot = (
.nane
- TCP",
oxner
TNGO"SIHL =
.c1ose
- tcp_close,
-pre_connect
u =
[.--]
The presence of this name field (.name = *TCP*) is a Linux kernel implementation detail. While
convenient, it is possible that this .name member could change or vanish in future kernels. The
s u a papnjou I qm st qprqm—uasaad aq sies[e pnous rasamoq *raqunu pooopoad μuodsuen
tool as well.
a Suusag sop ued Asea ue aptsosd pou op (z)aoatruoo pue (z)adaose og spuodaoen eosis atL
protocol, and currently there are not any other tracepoints for these events. Without them,
I have switched to using kprobes and chosen the LSM security_socket_* functions, which provide
a struct sock as the first argument, and are a relatively stable interface.
---
## Page 456
10.3 BPF Tools
41.9
10.3.4
soconnect
soconnect(8)12 shows IP protocol socket connect requests. For example:
+ soconnect.bt
Attach.ing 4 pzobes.
PID
PROCESS
FAM ADDRESS
FORT
LAT (us)RESULT
11448 ssh
2
127,0.0.1
22
43 Success
11449
ssh
2
10.168,188.1
22
45134 Success
11451
cur1
...
100.66.96.2
53
6 Success
11451
cur1
2406:da00:ff00::36d0 :a866
80
3 Metvork unreachable
11451
cur1
52,43.200.64
80
3 Sutoess
7 Success
11451curl
2
52.39.122,191
80
11451cur1
2
52,24.119.28
80
19 In progress
[. .-]
This shows two sh(1) connections to port 22, followed by a curl(1) process that begins with a port
53 connection (DNS) and then an attempted IPv6 connection to port S0 that resulted in *network
unreachable,° followed by successful IPv4 connections. The columns are:
• PID: Process ID calling connect(2)
 PROCESS: Process name calling connect(2)
• FAM: Address family number (see the description in sofamily(8) earlier)
• ADDRESS: IP address
• PORT: Remote port
● LAT(us): Latency (duration) of the connect(2) syscall only (see note below)
• RESULT: Syscall error status
Note that IPv6 addresses can be so long that they cause the columns to overflow (as seen in this
example),
This works by instrumenting the connect(2) syscall tracepoints. One benefit is that these occur
in process context, so you can reliably know who made the syscall. Compare this to the later
tcpconnect(8) tool, which traces deeper in TCP and may or may not identify the process respon-
sible. These connect(8) syscalls are also relatively low in frequency compared to packets and other
events, and the overhead should be negligible.
The reported latency is for the connect(0 syscall only. For some applications, including the ssh(1)
processes seen in the earlier output, this spans the network latency to establish a connection to
12 0rign: 1 crested this for the 2011 DTrce book [Gregg 11] and reated this bpfrace version on 9Apr-2019.
13 You might wonder why I don't just make the colums widec.If I did, t would cause wrapping for every Iine of output
in this example, rather than just one. I try to keep the default output of all tools to less than 80 characters wide, s0
that t fts without problems in books, slides, emails, ticketing systems, and chat rooms. Some tools in BCC have a wide
mode svailable, just to ft IPv6 nesty.
---
## Page 457
420
Chapter 10 Networking
the remote host. Other applications may create non-blocking sockets (SOCK_NONBLOCK), and
the connect() syscall may return early before the connection is completed. This can be seen in the
the full connection latency for these non-blocking calls requires instrumenting more events; an
example output as the final curl(1) connection that results in an “In progress° result. To measure
example is the later soconnlat(8) tool.
The source to soconnect(8) is:
+1/usr/locsl/bin/bpftrace
include 
#include 
BEGIX
printf (*4=6s s=16s FAx 416a 1=5s 8s sa^n*, *PID*, "PR0CEss*,
// connect(2) has more details:
_sseoong。 = [0|xs713#g
Berr2atr [EPERH] = "Pezmission denied*;
Berr2str [EINTR] - "Interrupted*;
Berr2str [EAGAIN] - *Routing cache insuff.*≠
(ssoor3] petuep *uxed = [ssoor3 x1szxxe8
Berr2str [EFAULT] - *Sock struct addr invalid*
Berr2str [EPRororrPe] - *Soeket protocol error*;
Berr2str [EAFK0SUPPORT] = *Address fan11y 1nva1id*;
Berr2str [EADDRINUsE] = *Local addr in use*;
Bezx2str [EADDRsorAVAIL] = *%o port ava1lable*;
Berr2str [ENETU(REACB] = *§etvork unreachable*
Berrzstr[EIscoe] - *Already connected*;
Berr2str [ETIMEDoUt] = *Timeout";
pesngex 13e0u0。 - [03sn3N003] x1sgxxe8
Berr2str[EALREADY] = *Not yet conpleted*;
fssexboad uIu - [ss3ar08a1a 11szxxe8
tracepoint1syscalls1sys_enter_connect
/args=>uservaddr->sa_fam1ly == AF_INET 11
args=>uservaddr->sas_family == AF_INET6/
---
## Page 458
10.3 BPF Tools
421
Bsockaddr [tid] = azgs=>uservaddx;
1soasu - [pT]4xe8
tracepoint:ayscalls:ays_exit_connect
/[p]re8/
$dur_us = (nsecs - @start[tid] ) / 1000;
printf (*s=6d s16s 1=3d ", pld, conm, @sockaddz[tid]>sa_fanlly] 
1f (@sockaddx[tid]=>sa_fanily == AF_INET) ↑
$8 = (struct sockaddr_in *)esockaddr[tid];
(00xo  [e >> xodutssa1n_addx s_addx) 
$port, $dur_us, Berr2str [- args->ret]);
}else(
$s6 = (struct sockaddr_in6 *) Bsockaddr [tid] 
port = 15s6=>sin6_port >> 8) 1 (15s6=>sin6_port sin5_addz -in5_u, u6_addr8) ,
$port, $dur_us, Berr2str[- args=>ret]);
delete (@sockadde [t1d]) :
delete (estart[tid]) 
END
1
clear (@start): cIear (Berr2stx) ; clear (@sockaddε) ;