并在载人完成之后，关闭这个伪客户端。
13.2.4AOF 文件的伪客户端
时，这个客户端才会被关闭。
伪客户端关联在服务器状态结构的lua_client属性中：
13.2.3 Lua 脚本的伪客户端 
redis.conf.
8 MB，软性限制的时长为 60秒。
软性限制的时长为 60 秒。
缓冲区大小。
执行发布与订阅功能的客户端分别设置不同的软性限制和硬性限制，该选项的格式为：
第二行设置将从服务器客户端的硬性限制设置为256 MB，而软性限制设置为64 MB，
服务器在载人 AOF文件时，会创建用于执行AOF文件包含的 Redis 命令的伪客户端，
服务器会在初始化时创建负责执行Lua脚本中包含的 Redis 命令的伪客户端，并将这个
关于client-output-buffer-limit 选项的更多用法，可以参考示例配置文件
口服务器状态结构使用clients 链表连接起多个客户端状态，新添加的客户端状态会
第三行设置将执行发布与订阅功能的客户端的硬性限制设置为32 MB，软性限制设置为
lua_client 伪客户端在服务器运行的整个生命期中会一直存在，只有服务器被关闭
第一行设置将普通客户端的硬性限制和软性限制都设置为0，表示不限制客户端的输出
使用client-output-buffer-limit 选项可以为普通客户端、从服务器客户端、
struct redisServer {
client-output-buffer-limit pubsub 32mb 8mb 60
client-output-buffer-limit normal 0 0 0
以下是三个设置示例：
client-output-buffer-limit    
：
被放到链表的末尾。
reached_time 属性的值也会被清零。
！.·.
redisClient *lua_client;
---
## Page 179
口载人AOF文件时使用的伪客户端在载人工作开始时动态创建，载人工作完毕之后关闭。
口处理Lua 脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服
口当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户
口 输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制
口客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区
口 命令的参数和参数个数会被记录在客户端状态的 argv 和 argc 属性里面，而 cmd 
口 输人缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。
口 客户端状态的 flags 属性使用不同标志来表示客户端的角色，以及客户端当前所处
务器关闭。
那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器
的状态。
端被关闭。
设置的软性限制，那么客户端也会被关闭。
制值。
的最大大小为16 KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限
属性则记录了客户端要执行命令的实现函数。
的目标、
端状态。网络连接关闭、
、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会道成客户
、发送了不合协议格式的命令请求、成为CLIENTKILL命令
第13章客户端175
---
## Page 180
操作，并产生命令回复OK。
执行以下操作：
例子，如果我们使用客户端执行以下命令：
14.1
做了些什么准备工作。
以知道，在启动服务器程序、直到服务器可以接受客户端命令请求的这段时间里，服务器都
明这些操作对于服务器维持正常运行有何帮助。
同组件又是如何协作的，等等。
整个过程，说明在执行命令的过程中，服务器和客户端进行了什么交互，服务器中的各个不
中保存客户端执行命令所产生的数据，并通过资源管理来维持服务器自身的运转。
本章的第二节将对 serverCron 函数进行介绍，详细列举这个函数执行的操作，并说
本章的第一节将以服务器执行 SET命令的过程作为例子，展示服务器处理命令请求的
2）服务器接收并处理客户端发来的命令请求 SETKEYVALUE，在数据库中进行设置
1）客户端向服务器发送命令请求 SETKEYVALUE。
本章的最后一节将对服务器的启动过程进行介绍，通过了解 Redis 服务器的启动过程可
4）客户端接收服务器返回的命令回复OK，并将这个回复打印给用户观看。
3）服务器将命令回复OK 发送给客户端。
那么从客户端发送SETKEYVALUE 命令到获得回复OK 期间，客户端和服务器共需要
一个命令请求从发送到获得回复的过程中，客户端和服务器需要完成一系列操作。举个
Redis 服务器负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据库
redis> SET KEY VALUE
命令请求的执行过程
服务
第14章
器
---
## Page 181
态的输人缓冲区之后，客户端状态的样子。
令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。
令请求处理器来执行以下操作：
14.1.2
命令请求发送给服务器，如图14-1所示。
客户端会将这个命令请求转换成协议格式，然后通过连接到服务器的套接字，将协议格式的
14.1.1
行命令请求时所做的各种工作。
redisClient
当客户端与服务器之间的连接套接字因为客户端的写人而变得可读时，服务器将调用命
querybuf
2）对输人缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命
1）读取套接字中协议格式的命令请求，并将其保存到客户端状态的输人缓冲区里面。
之后，分析程序将对输入缓冲区中的协议进行分析：
继续用上一个小节的SET命令为例子，图14-2展示了程序将命令请求保存到客户端状
3）调用命令执行器，执行客户端指定的命令。
本节接下来的内容将对这些操作的执行细节进行补充，详细地说明客户端和服务器在执
然后将这段协议内容发送给服务器。
*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n
那么客户端会将这个命令转换成协议：
SET KEY VALUE
举个例子，假设用户在客户端键人了命令：
读取命令请求
发送命令请求
用户
sdshd
buf
free
键人命令请求
图14-1客户端接收并发送命令请求的过程
图14-2客户端状态中的命令请求
→客户端
将命令请求转换成协议格式
然后发送
→服务器
第14章服务露·177
---
## Page 182
178·第二部分单机数据库的实现
Redis 命令的实现信息，表14-1记录了这个结构的各个主要属性的类型和作用。
等：而字典的值则是一个个redisCommand 结构，每个redisCommand 结构记录了一个
table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd 属性里面。
14.1.3
分别介绍命令执行器所执行的工作。
 milliseconds
calls
flags
 sflags
arity
proc
name.
命令执行器要做的第一件事就是根据客户端状态的 argv［O］参数，在命令表（command
之后，服务器将通过调用命令执行器来完成执行命令所需的余下步骤，以下几个小节将
并将得出的分析结果保存到客户端状态的argv属性和argc 属性里面，如图 14-3所示。
*3\r\n$3\r\nSET\r\n$3\\nKEY\r\n$5\r\nVALUE\\n
飘性名
命令执行器（1）：查找命令实现
redisClient
argc
argv
long long
long long
int
char *
int
redisCommandProc *
char *
图 14-3客户端状态的 argv 属性和 argc 属性
类型
表14-1
redisCommand 结构的主要属性
argv[0]
是 sflags 属性，因为对二进制标识的检查可以方便地通过&、
用，这个命令是否允许在Lua脚本中使用等等
命令是写命令还是读命令，这个命令是否允许在载人数据时使
命令的名字本身也是一个参数，比如说SETmsg"hello
果这个值为负数-N，那么表示参数的数量大于等于N。注意
mmandProc(redisClient *c);
服务器执行这个命令所耗费的总时长
服务器总共执行了多少次这个命令
、～等操作来完成
对 sflags 标识进行分析得出的二进制标识，由程序自动生
命令参数的个数，用于检查命令请求的格式是否正确。如
函数指针，指向命令的实现函数，比如 setCommand。
命令的名字，比如”set”
argv[1]
作用
argv[1]
---
## Page 183
针会指向这个redisCommand结构，如图14-5 所示。
行查找时，命令表将返回＂set”键所对应的 redi sCommand 结构，客户端状态的cmd 指
结构：
继续之前 SET命令的例子，当程序以图 14-3中的 argv[0］作为输人，在命令表中进
 SET命令的名字为"set"，实现函数为 setCommand；命令的参数个数为-3，表
GET命令的名字为"get"，实现函数为 getCommand 函数；命令的参数个数为 2,
图14-4展示了命令表的样子，并且以SET命令和GET命令作为例子，展示了redisCommand
表 14-2列出了 sflags 属性可以使用的标识值，以及这些标识的意义。
表示命令只接受两个参数；命令的标识为"r"，表示这是一个只读命令。
标识
个命令可能会占用大量内存。
示命令接受三个或以上数量的参数；命令的标识为＂wm"，表示SET命令是一个写
W
t
s
人命令，并且在执行这个命令之前，服务器应该对占用内存状况进行检查，因为这
自动被传播（propagate）
使用的命令
使用
令的结果有序
个命令的输出结果进行一次排序，使得命
相同的参数，命令返回的结果可能不同
内存紧缺的话就禁止执行这个命令
需要先检查服务器的内存使用情况，如果
这是-
这个命令可以在服务器载人数据的过程中
当在 Lua 脚本中使用这个命令时，对这
这个命令在监视器（monitor）模式下不会
这是一个随机命令，对于相同的数据集和
这个命令不可以在Lua脚本中使用
这是一个发布与订阅功能方面的命令
这是一个管理命令
这个命令可能会占用大量内存，执行之前
这是一个只读命令，不会修改数据库
这是一个写入命令，可能会修改数据库
一个允许从服务器在带有过期数据时
意义
表14-2
sflags 属性的标识
KEYS等等
RANDOMKEY等等
SINTERSTORE等等
SLAVEOF、PING、INFO 等等
INFO、SHUTDOWN、PUBLISH 等等
SINTER、SUNION、SDIFF、SMEMBERS.
EXEC
SPOP、SRANDMEMBER、SSCAN
BRPOP、BLPOP、BRPOPLPUSH、SPOP 等等
PUBLISH、SUBSCRIBE、PUBSUB 等等
SAVE、BGSAVE、SHUTDOWN 等等
SET、APPEND、
GET、STRLEN、EXISTS 等等
SET、RPUSH、DEL等等
带有这个标识的命令
RPUSH、LPUSH、SADD
第14章服
务器·179
---
## Page 184
180
◆第二部分单机数据库的实现
"publish"
redisClient
"rpush"
"sadd"
"get"
"set"
命令表
+**
cmd
"publish"
"rpush"
"sadd"
"get"
"set"
命令表
···
图14-5
redisCommand
redisCommand
sflags
arity
proc
sflags
arity
"rn
"get"
name
proc
"set"
name
2
m-
设置客户端状态的cmd 指针
redisCommand
sflags
图14-4命令表
" wm"
arity
proc
"set"
name
-3
→ void getCommand(redisClient *c) ;
4
void setCommand(redisClient *c) ;
 void setCommand(redisclient *c);
---
## Page 185
可以正确、顺利地被执行，这些操作包括：
性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令
属性）参数（保存在客户端状态的 argv属性）参数个数（保存在客户端状态的 argc 属
14.1.4命令执行器（2）：执行预备操作
令，并且获得相同执行结果的原因：
回的都是同一个redisCommand 结构。这也是Redis 客户端可以发送不同大小写的命
如说，无论用户输入的命令名字是“SET"、“set"、"SeT"又或者"sEt"，命令表返
者混合大小写，只要命令的名字是正确的，就能找到相应的 redisCommand 结构。比
口检查客户端状态的 cmd 指针是否指向 NULL，如果是的话，那么说明用户输人的
到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd
如果服务器打开了maxmemory 功能，那么在执行命令之前，先检查服务器的内存
口检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命
 根据客户端 cmd 属性指向的 redisCommand 结构的 arity 属性，检查命令请求
redis> SeT msg "hello world"
"pixom otiau, 6su 4as  SET msg "hello world'
#以下四个命令的执行效果完全一样
因为命令表使用的是大小写无关的查找算法，无论输入的命令名字是大写、小写或
占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如
错误。
员
redis> sEt msg "hello world"
户端返回一个错误。比如说，如果redisCommand 结构的 arity属性的值为-3，
OK
OK
务器将向客户端返回一个错误。