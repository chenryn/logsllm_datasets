checking is reduced to a form of information ﬂow analysis.
Consider the scenario in Fig. 2. There are three programs
(Jobs 1, 2, 3) and three ﬁles (Files A, B, C). Let us assume
that the programs are expected to be compliant with a privacy
policy that says: “full IP address will not be used for advertis-
ing. IP address may be used for detecting abuse. In such cases
it will not be combined with account information.” Note that
the policy restricts how a certain type of personal information
ﬂows through the system. The restriction in this example is
based on purpose. Other common restrictions include storage
restrictions (e.g., requiring that certain types of user data
are not stored together) and, for internal policies, role-based
329
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:58:21 UTC from IEEE Xplore.  Restrictions apply. 
For instance, in our setting, we assume that the data inventory
phase labels programs with data that ﬂows to it, a purpose
attribute and a user attribute. Informally, an ALLOW clause
permits graph nodes labeled with any subset of the attribute
values listed in the clause, and a DENY clause forbids graph
nodes labeled with any set that overlaps with the attribute
values in the clause. The layering of clauses determines the
context within which each clause is checked. We deﬁne the
formal evaluation semantics in Section III-E.
C. LEGALEASE, by example
We illustrate LEGALEASE through a series of examples
that build up to a complex clause. In the examples we
use two user-deﬁned attributes: DataType and UseForPurpose
(our deployment uses two additional ones AccessByRole and
InStore). We deﬁne the concept lattice for each of these four
attributes in the next subsection.
The simplest LEGALEASE policy is DENY. The policy
contains a single clause; the clause contains no exceptions
and no attribute restrictions. The policy, rather uninterestingly,
simply denies everything. We next add a restriction along the
DataType attribute for graph nodes to which IP address ﬂows.
DENY DataType IPAddress
As discussed in our running example, there is often a need
to capture some limited form of history of the data ﬂow (e.g.,
that the IP address has been truncated before it can be used).
We capture this notion of typestate in the concept lattice for the
DataType attribute (described below). The lattice contains an
element IPAddress:Truncated meant to represent the truncated
IP address, and the lattice element for IP address IPAddress,
such that IPAddress:Truncated ≤ IPaddress, where ≤ is the
partial order for the lattice. We next add the exception that
allows us to use the truncated IP address. The added lines are
marked with ⊳.
DENY DataType IPAddress
EXCEPT
⊳
⊳
Policy Clause C ::=
Deny Clause D ::=
D | A
DENY T1 · · · Tn EXCEPT A1 · · · Am
| DENY T1 · · · Tn
Allow Clause A ::=
ALLOW T1 · · · Tn EXCEPT D1 · · · Dm
| ALLOW T1 · · · Tn
Attribute T
Value v
hattribute-namei v1 · · · vl
::=
::= hattribute-valuei
TABLE I
GRAMMAR FOR LEGALEASE
any mapping from LEGALEASE clauses to English clauses that
do not fall along these organizational bounds would neces-
sitate (time-consuming) processes to review and update the
LEGALEASE clauses. By designing in a 1-1 correspondence
to policies in English, LEGALEASE clauses can be added,
reviewed, and updated at the same time as the corresponding
English clauses and by the same individuals.
b) Expressivity: LEGALEASE clauses are built around an
attribute abstraction (described below) that allows the language
to evolve as policy evolves. For instance, policies today tend
to focus on access control, retention times, and segregation of
data in storage, [14], [15], [16]. However, information ﬂow
properties [17] provide more meaningful restrictions on infor-
mation use. Similarly, the externally-visible policy may be at a
higher level while the internal policy may be more restrictive
and nuanced. LEGALEASE allows transitioning between these
policies with minimal policy authoring overhead, and provides
enforcement techniques so as to enable stronger public-facing
policy promises.
c) Compositional Reasoning: When the whole policy is
stated as a monolithic logic formula, it may be more difﬁcult
to naturally reason about the effects of the policy, due to
unexpected interactions between different parts of the formula
[18]. LEGALEASE provides meaningful syntactic restrictions
to allow compositional reasoning where the result of checking
the whole policy is a function of reasoning on its parts.
B. LEGALEASE Language Syntax
ALLOW DataType IPAddress:Truncated
A LEGALEASE policy (Table I) is rooted in a single top-
level policy clause. A policy clause is a layered collection
of (alternating) ALLOW and DENY clauses where each clause
relaxes or constricts the enclosing clause (i.e., each layer de-
ﬁnes an exception to the enclosing layer). Each clause contains
a set of domain-speciﬁc attributes that restrict to which data
dependency graph nodes the policy applies. Attributes are
speciﬁed by their name, and one or more values. Attribute
values are picked from a concept lattice [19] for that attribute
(explained below). The absence of an attribute implies that
there no restrictions for that attribute. The policy author deﬁnes
new attributes by providing an attribute name and a lattice of
values. In III-D, we describe the particular instantiation of
attributes we use to specify information ﬂow restrictions on
programs.
Checking: LEGALEASE policies are checked at each node in
the data dependency graph. Each graph node is labeled with
the domain-speciﬁc attribute name and set of lattice values.
The above policy contains a clause with an exception. The
ﬁrst disallows any use of IP address, while the exception
relaxes the ﬁrst allowing use when the IP address is truncated.
Next, we restrict the policy to advertising uses only by adding
a restriction along the UseForPurpose attribute for the value
Advertising, while retaining the exception that allows the use
of IP Address when truncated.
DENY DataType IPAddress
UseForPurpose Advertising
EXCEPT
⊳
ALLOW DataType IPAddress:Truncated
The above policy corresponds to the English clause “full
IP address will not be used for advertising”. Note that since
the ﬁrst clause is restricted only to advertising use, and the
second rule does not relax that attribute, the net effect is that
the clause applies only to use of IP address for advertising
and says nothing about non-advertising uses (consistent with
the English clause).
330
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:58:21 UTC from IEEE Xplore.  Restrictions apply. 
(a) InStore lattice
(b) UseForPurpose lattice
(c) AccessByRole lattice
Fig. 3. Concept lattice [19] examples for three of the domain-speciﬁc attributes we deﬁne.
Attribute Name
InStore
UseForPurpose
AccessByRole
DataType
Concept
Storage
Use for purpose
Access control
Information
Deﬁned In
Section III-D1
Section III-D2
Section III-D3
Section III-D4
Example Lattice
Fig. 3a
Fig. 3b
Fig. 3c
Fig. 4c
TABLE II
ATTRIBUTES USED IN OUR DEPLOYMENT
Finally, consider the English policy “full IP address will not
be used for advertising. IP address may be used for detecting
abuse. In such cases it will not be combined with account
information.” This policy is encoded in LEGALEASE below.
The ﬁrst, second, and third sentences correspond respectively
to lines 1–4, 5–6, and 7–8. DENY DataType IPAddress
UseForPurpose Advertising
EXCEPT
ALLOW DataType IPAddress:Truncated
ALLOW DataType IPAddress
UseForPurpose AbuseDetect
EXCEPT
DENY DataType IPAddress, AccountInfo
⊳
⊳
⊳
⊳
The last clause (in lines 7-8) mentions that the combination
of IPAddress and AccountInfo is denied, but these elements can
be used individually. It turns out that giving formal semantics
to such exceptions where combinations are disallowed whereas
individual elements are allowed is non-trivial. We revisit this
issue when we give formal semantics to LEGALEASE.
In Section VI, we encode the entirety of the externally-
visible privacy policies for Bing and Google, as it pertains to
backend data processing and storage. Therefore, LEGALEASE
satisﬁes our goal of being able to express current policy in a
way that there is a natural 1-1 correspondence with the policy.
We also show through a user study that LEGALEASE is easy
for privacy champions to learn and use.
at hand. The attribute values must be organized as a concept
lattice [19], which is a complete lattice1 of values that the
attribute can take.
The concept lattice serves three purposes in LEGALEASE:
ﬁrst, it abstracts away semantics (e.g., policy datatype and
typestate, use for purpose, access control) in a way that the rest
of LEGALEASE and language tools do not have to be modiﬁed
as long as a new concept can be encoded as a lattice, and the
GROK data mapper can label nodes in the data dependency
graph with the label corresponding to the semantic meaning
of that attribute. In practice we have found the need for only
four concepts (Table II), all of which can be encoded as a
lattice and labeled by the GROK mapper. Second, the lattice
structure allows the user to concisely deﬁne (and refer to)
sets of elements through their least upper bound. Finally, the
lattice structure allows us to statically check the policy for
certain classes of errors (e.g., exceptions that have no effect
as they do not relax or constrict the enclosing clause).
LEGALEASE does not assign any particular semantic mean-
ing to these attributes. In our context, however, we instantiate
the language to specify restrictions on information ﬂow in
our programming model. In particular, the policy datatype
labels denote the information that ﬂows to a particular node
in the data dependency graph, and the typestate labels record
a limited history of declassiﬁcation actions during that ﬂow.
We now deﬁne the four domain-speciﬁc attributes and their
corresponding concept lattices that we use in our deployment.
1) InStore attribute: We deﬁne the InStore attribute to
encode certain policies around collection and storage of data.
For instance, consider the policy “Ads will not store full IP
address”. A privacy champion may interpret that policy as
forbidding storing the entire IP address on any data store
designated for Ads. The concept lattice, illustrated in Fig. 3a,
contains all data stores in the bottom half (e.g., AuctionLogs,
D. Domain-Speciﬁc Attributes
LEGALEASE derives its expressiveness and extensibility
through domain-speciﬁc attributes that can be suitably instan-
tiated to specify policy restrictions speciﬁc to the application
1Recall, a complete lattice is a structure of the form (L, ≤, ∧, ∨, ⊤, ⊥)
where L is a partially ordered set of elements under the ordering relation ≤,
meet (∧) and join (∨) are operators that result respectively in the least upper
bound and the greatest lower bound, and top (⊤) and bottom (⊥) are the
maximal and minimal element.
331
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:58:21 UTC from IEEE Xplore.  Restrictions apply. 
AdClickLogs, WebIndex) and a coarser grained classiﬁcation in
the top half (e.g., AdsData, SearchData). The policy-writer can
use any lattice element in LEGALEASE clauses. As we describe
in the formal semantics section, the policy then applies to all
elements below the mentioned element. Thus by choosing the
AdsData element the policy-writer would cover all data stores
designated for Ads.
The InStore attribute adds a storage restriction in the policy
clause as follows:
DENY DataType IPAddress
InStore AdsData
EXCEPT
⊳
ALLOW DataType IPAddress:Truncated
The policy above disallows storing IP addresses in any data
store designated as Ads unless it has been truncated. The
GROK mapper labels all data stores (e.g., ﬁles) with the InStore
attribute value (e.g., AdClickLogs) so that the above clause is
triggered whenever the non-truncated IP address ﬂows to a ﬁle
designated for storing advertising data.
In LEGALEASE, a use-oriented policy is expressed very
similarly by changing InStore AdsData in the policy above to
UseForPurpose Advertising. With this low editing overhead,
LEGALEASE satisﬁes our expressivity design goal of enabling
seamless transitions towards meaningful restrictions on infor-
mation use.
2) UseForPurpose Attribute: In earlier examples we show
how the UseForPurpose attribute helps encode certain policies
around use of data. In examples so far we have discussed
using data in various products (Advertising) or product features
(AbuseDetect). The use, however, need not be restricted purely
to products. Indeed, policy often seeks to disallow sharing
certain data with third-parties; here Sharing is another use of
the data. All these uses are captured in the concept lattice for
the UseForPurpose attribute (Fig. 3b).
3) AccessByRole Attribute: Internal policies often further
restrict data use based on which team is accessing the data.
These access-control oriented roles often do not show up in
externally-facing policies because they make sense only within
the organizational structure. To encode internal access-control
based policies we deﬁne the AccessByRole attribute where the
lattice (Fig. 3c) is the role-based hierarchy which includes the
org-reporting hierarchy (solid black lines in the ﬁgure), virtual-
teams that may span different parts of the organization (dotted
lines), as well as job-titles (gray lines). The lattice is populated
from the organizational directory service. An example internal
policy may be:
DENY DataType IPAddress
EXCEPT
ALLOW AccessByRole AbuseTeam
EXCEPT
DENY AccessByRole Intern
⊳
⊳
⊳
The above policy allows the abuse detection team to use