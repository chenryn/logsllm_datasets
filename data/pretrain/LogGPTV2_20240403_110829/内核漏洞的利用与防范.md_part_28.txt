每种缓存类型（比如，kma11oc-32）的参数项包括：已使用的对象数目（990）、对象总
耗尽slab，所以更感兴趣于前两个值。对象总数和使用中的对象数之间的差别，这给出为了得
到一个新的slab，我们需要的分配器数量。顺便说一下，解析/proc/slabinfo文件也可以用来判
别旧的SLAB分配器和新的SLUB分配器：一般目的缓存在SLAB分配器中称为size-n，而在
SLUB分配器中称为kmalloc-n。
·我们需要保证一旦创建一个新的slab并分配给一个特定的CPU，我们所有的分配/释放
都将经过它。这是我们在对于Solaris攻击方法的讨论中忽视的，并能够轻易达到。下面
的代码指出了如何在Linux中实现这一过程：
staticintbindcpu(）
cpu_set_tset;
CPU_ZERO(&set):
CPU_SET(O.&set):
if(sched_setaffinity(o,sizeof(cpu_set_t),&set)objsize;
if（unlikely(!c->freelist||!node_match（c,node)))
[1]
object=_slab_al1oc（s，gfpflags,node,addr,c);
[2]
)else{
object=c->freelist;
[3]
c->freelist=object[c->offset];
[4]
stat(C,ALLOC_FASTPATH):
["]
return object:
检索指向当前特定CPU的kmem_cache_cpu的指针，可以将这个结构用于检索对象。特
别地，freelist成员起到了关键的作用。如果它是NULL[1]，执行分支的第一边[2]并调用
_slab_a11oc（）（所谓的慢路径）。由于freelist==NuLL意味着当前slab中没有更多的可
这里的“当前”是指，本书的编写时间早于2.6.30的Linux版本。存储元数据的偏移量是在页结构内部跟踪
的，可能在未来的版本中会发生改变。
---
## Page 143
134第二部分UNIX家族、MacOSX和Windows
用对象，一s1ab_alloc（）将从部分列表中查找另一个合适的slab（如果没有部分slab可用则
分配一个新的），接下来我们将在“强制性概念”一节中描述。
如果freelist不是NULL，那么它的地址作为返回对象的地址[3]并且下一个可用对象
的元数据[4]成为新的freelist地址。注意c->offset是如何按我们所期望的情况用于指定
元数据在可用对象中的偏移量的。
从一个更实用的角度看，它意味着我们可以返回给一个指定的内核路径任意的内存地
址，甚至是用户态的一个地址，以便作为分配调用的结果。我们所需要做的只是使用溢出破坏
object[c->offset]的值，然后驱动这个已遭破坏对象的分配。在这一点上，[3]和[4]处的
代码把我们破坏的值保存到free1ist中，将在下一个调用中返回它。图4.6显示了我们如何
将完全控制的用户态内存返回给一个调用kma11oc（）的内核路径。
应该可以很直接地看到，一个使用我们称为用户态的假冒对象的内核路径完全受到了攻
击者的控制，并且攻击者可以在任何时间随意更改对象内部存储的值。如果对象中存放了任何
的敏感数据，我们的攻击就完成了。同样的是，如果将对象用于存放一些用户态传过来的数据
（比如，一个IOCTL命令），我们可以使“假对象”指向某个内核数据结构（而非用户态），并
且使用我们复制进来的控制数据（比如，IOCTL命令）来重写它。而且payload执行将是指日
可待的（比如，内核态内的一个文件操作）。
空闲列表
可用
已分配
已分配
可用
已分配
已分配
对象
对象
对象
对象
对象
对象
空闲列表
丰
可用
已分配
已分配
可用
已分配
已分配
对象
对象
对象
对象
对象
对象
用户态
可用
对象
元数据
下个可用对象
重写
丰
下个可用对象
图4.6已破坏的可用对象元数据，使分配器返回一个用户态的对象
---
## Page 144
第4章UNIX家族135
注意，这个问题很容易就可以转变为信息泄漏，比如将一些加密信息暂时存放在分配的内
存中。换句话说，这个技术充许我们破坏内核路径到内核分配对象的隐藏信任（在用户态不可
见或不能修改的信任）。
这看起来很漂亮，但是我们完全忽略了一些问题：
·当同一个slab请求另一个对象时会发生什么？
·当一个对象（或我们的对象）释放回分配器会发生什么？
·当我们没有4个（32位系统上的指针大小）或8个（64位系统上的指针大小）溢出字
节，而仅仅有一个或两个时会发生什么？
前两个问题的解决方法位于攻击的恢复阶段。
我们很可能已经知道了第一个问题的答案。事实上，如果我们回想之前看到的分配路径，分
配器将获得一个新的页并创建一个新的slab（并忘记当前的那个），那么反过来，我们可以通过
在假对象的开始赋予NULL来强迫这种情况发生。这很容易做到，如果我们有用户态的假对象
（我们显然已经控制了用户态的内存），但是如果我们把分配重定向到内核态的某个地方，它就
变得有点复杂了。在第二种情况中，我们需要找到一个函数指针（或任何相似的有用变量）赋
予一个4或8字节的NULL值。这没有听起来那样复杂：赋NULL值是用来表示不执行的函数
指针或默认标志/返回值的一个经典方法。default_backing_dev_info的声明就是一个很好
的例子：
structbacking_dev_infodefault_backing_dev_info=1
.name
="default",
.ra_pages
=VM_MAX_READAHEAD*1024/PAGE_CACHE_SIZE
state
=0.
.capabilities=BDI_CAP_MAP_COPY,
.unplug_io_fn=default_unplug_io_fn，
1：
EXPORT_SYMBOL_GPL(default_backing_dev_info):
这个声明描述出了我们之前提到的两种情况。首先，仅声明了整个结构的一些成员，正如
我们从backing_dev_info结构的声明中看到的：
structbacking_dev_info1
structlist_headbdi_list:
structrcu_headrcu_head:
unsigned1ongra_pages;/*在PAGE_CACHE_SIZE单元中最大化提前读取数*
unsigned1ongstate；/*针对这种情况总使用原子bitops*
unsignedintcapabilities;/*设备性能*/
congested_fn*congested_fn：/*当设备是md/dm时的函数指针*/
/
void*congested_data：/*密集函数的aux数据的指针*/
void（*unplug_io_fn)（structbacking_dev_info*，structpage*);
void*unplug_io_data;
char*name:
[..]
即使没有给出整个结构，我们也可以看到只有高亮显示的成员才在default_backing-
dev_info的声明中定义。这意味着其他的成员将初始化为0（0是常用的默认值），并适用于
---
## Page 145
136第二部分UNIX家族、MacOSX和Windows
下一可用对象的指针。同时，显式声明state为0且是unsigned1ong类型。这意味着它将
和一个指针（记住，Linux是ILP32和LP64）的大小一样，因此，可以完全适用于下一可用对
象指针的值。state和congested_fn（一个未初始化，即NULL值）都和看似很有用的函数
指针unp1ug_io_fnO相近。
更有趣的是，因为这个结构由EXPORT_SYMBOL_GPLO）导出，我们可以从/proc/kallsyms
获得它的地址并准确地知道它在核心内存中的位置。出于这个目的，在分析Linux的凭据模型
时，我们可以重用在“在2.6.29以前的版本中”一节中看到的ka11sym_getaddrO函数。在
第二个恢复阶段，处理使得释放一个假对象变得安全，但这并不是那么直接。让我们从释
放路径开始分析：
voidkfree（constvoid*x)
structpage*page;
void*object=（void*）x;
[..]
page=virt_to_head_page(x);
[1]
if(unlikely(!PageSlab(page))){
[2]
BUG_ON(!PageCompound(page));
kmemleak_free(x);
put_page(page):
return:
s1ab_free(page->slab.page,object,_RET_IP_):
1
voidkmem_cache_free(structkmem_cache*s,void*x)
structpage*page;
page=virt_to_head_page（x);
[3]
s1ab_free(s,page,x,_RET_IP_):
trace_kmem_cache_free(_RET_IP_.x):
static-_always_inlinevoidslab_free(structkmem_cache*s
structpage*page,void*x,unsigned1ongaddr)
void**object=（void*）x;
structkmem_cache_cpu*c;
unsigned long flags:
kmemleak_free_recursive(x,s->flags);
local_irq_save(flags):
c=get_cpu_s1ab（s,smp_processor_id());
[.]
if（1ikely(page==c->page&&c->node>=0））{
object[c->offset]-c->freelist;
[4]
c->freelist-object;
[5]
---
## Page 146
第4章UNIX家族137
stat(c,FREE_FASTPATH);
}else