### 3.1 准确性和鲁棒性

本节旨在评估MAS的准确性和鲁棒性。我们面临的一个普遍困难是，即使在受控环境中，也很难且耗时地获得已知正确的对象映射（即“地面真实”）。对于那些我们仅有的实际崩溃转储数据，建立一个地面真实显得尤为困难。鉴于这些方法上的难题，我们在本节中提供的大部分证据都是间接的。

我们的第一个数据集包含了MAS对837个Windows 7崩溃转储的输出。我们试图验证MAS报告为可疑的函数指针是否确实是函数指针。我们检查了这些函数指针的目标是否看起来像是函数的开头。绝大多数函数指针目标包含了一组对应于函数前序的小代码模式。这使我们能够通过运行一个检查这些模式的程序来自动化大部分指针检查。我们手动检查了剩余的指针。对于那些目标看起来不是代码的函数指针，我们应用了第二个标准：我们接受了所有可以直接且明确地从符号信息推导出存在的对象中的字段作为函数指针候选。这包括全局变量和可以通过唯一确定类型的指针从全局变量访问的对象。最终，我们发现总共398,987个MAS输出的函数指针中有24个可疑指针。

我们的数据集中包含的11个Windows Vista SP1崩溃转储允许我们直接比较MAS和KOP的结果。我们手动检查了MAS和KOP输出之间的所有差异。KOP似乎同时存在误报和漏报（见表1）。我们首先检查了MAS返回的所有函数指针，并发现它们都是有效的。然后，我们手动检查了KOP报告但未被MAS输出的所有函数指针的目标。这些目标看起来都不像函数的开头。因此，我们将这些指针分类为KOP的误报（FP. KOP in Table 1）。我们还观察到一些由MAS找到但KOP未找到的函数指针。由于我们已经得出结论，这些指针的目标是函数入口点，因此我们将它们分类为KOP的漏报（FN. KOP in Table 1）。KOP错过了MAS找到的多达40%的函数指针。此外，KOP报告的多达40%的函数指针似乎是不正确的。

我们还尝试解释MAS返回的函数指针。大量报告的函数指针似乎指向了未包含在静态分析中的第三方驱动程序。然而，除了检测广泛使用的反病毒软件的足迹外，我们还在11个崩溃转储中的5个中发现了明显的rootkit感染迹象。我们将在第9节讨论如何在实际崩溃转储中检测rootkit。

接下来，我们试图估计MAS找到的对象的内部一致性。我们检查了MAS生成的完整内核对象映射中的不一致指针。这些指针的类型与对象映射分配给指针目标的对象类型不兼容。例如，对象映射可能在地址A处包含类型T1的对象。另一个对象可能包含类型T2 (T2 ≠ T1) 的指针P，该指针也指向A。P是一个不一致的指针。即使对象映射没有错误，由于对象中的无效指针和崩溃转储中的内存损坏，也可能存在这种不一致。但它们也可能表明对象映射中的错误，例如跟随无效指针导致的错误。如果一个对象至少有一个不一致指针指向它，我们就称其为不一致对象。图5显示了MAS和KOP在Windows Vista SP1崩溃转储中找到的对象映射中的不一致对象百分比。我们认为这个数字可以反映对象映射的正确性。平均而言，MAS生成的对象映射中包含0.5%的不一致对象，而KOP生成的对象映射中则为1%。

### 3.2 性能

本节评估MAS的运行时间。

**静态分析**  
我们在Windows XP SP3、Windows Vista SP1和Windows 7上进行了静态分析。我们的评估主要集中在Windows Vista SP1，因为它允许我们直接比较MAS和KOP。Windows Vista SP1的静态分析包括Windows内核和一组63个标准驱动程序（如win32k、ntfs和tcpip），这是KOP分析的相同驱动程序集。代码库有350万行代码。程序表达图有220万个节点和730万条边。MAS执行了近23,000次候选类型查找。

我们在一个拥有100个节点的集群上进行了静态分析，每个节点配备两个四核2.5 GHz Xeon处理器和16 GB RAM，运行Windows Server 2008 R2 HPC Edition。每个节点用于执行228次候选类型查找。整个静态分析用时不到5小时。根据[3]中的报道，KOP在同一任务上的时间为48小时，使用的是较旧的单处理器机器。

MAS相对于KOP的主要优势在于MAS的静态分析可以并行运行，这使得MAS能够更快完成分析。

**动态分析**  
接下来，我们报告MAS在三组内存快照上的总运行时间和完整性检查。图6显示了MAS和KOP在11个Windows Vista SP1崩溃转储上的运行时间。平均而言，MAS（每份转储160秒）比KOP（每份转储24.5分钟）快9倍以上。KOP在第三个崩溃转储上未能在两小时内完成。

图7显示了MAS在837个Windows 7崩溃转储上的运行时间分布。运行时间集中在40到160秒之间。平均运行时间为105秒，99.9%的运行在5分钟内完成。

最后，在我们大规模恶意软件研究中的154,768个内存快照中，MAS的平均运行时间为31秒。运行时间分布高度集中在这一值附近。

综上所述，我们的实验表明MAS可以快速准确地分析实际崩溃转储和虚拟机内存快照。

### 4 内核恶意软件研究

在本节中，我们介绍了对从一家主要反病毒软件供应商处获得的154,768个潜在恶意软件样本的研究结果。这些样本来自各种来源，其行为对我们来说是未知的，包括样本是否包含恶意软件。所有样本都是不同类型的Windows二进制文件：可执行文件（.exe）、动态链接库（.dll）和驱动程序（.sys）。

我们使用MAS对这些样本进行了分析。具体来说，对于每个样本，我们启动了一个干净的Windows XP SP3虚拟机，配备了256 MB的RAM和一个虚拟处理器，并加载和执行了样本。我们直接运行.exe文件。我们使用一个标准可执行文件加载.dll文件并使其DllMain函数被执行。我们使用服务控制管理器（sc.exe）加载驱动程序（.sys）。在启动样本后，我们等待一分钟，然后获取虚拟机的内存快照，将其转换为Windows崩溃转储，并运行MAS进行分析。

为了获得更多关于虚拟机中事件的洞察，我们编写了一个驱动程序，该驱动程序将虚拟机的大部分内核地址空间设置为不可执行（通过设置页表中的相应位）并捕获和记录任何非执行（NX）页面错误。该驱动程序还记录内核模块的加载和卸载以及池块的分配和释放。

我们在一个包含25个计算节点的集群上评估了所有154,768个样本。集群节点运行Windows Server 2008 R2，并使用Hyper-V作为虚拟机监控程序。每个集群节点上运行4到8个虚拟机，总计同时运行164个虚拟机。每个作业运行2到3分钟。由于虚拟机作业是I/O密集型的，我们采取了一些措施来管理磁盘流量：虚拟机使用基于单个基础镜像的差异磁盘。我们交错启动虚拟机，以确保某些作业的I/O密集阶段与其他作业的一分钟空闲期重合。所有154,768个作业在不到48小时内完成。

MAS仅报告了89,474个样本的内核行为。我们分析了其余65,294个MAS未输出结果的样本的驱动程序日志。驱动程序日志显示，在除1286个样本外的所有情况下，既没有记录模块加载也没有记录非执行页面错误。对于这1286个样本，驱动程序日志显示没有检测到非执行页面错误，并且在样本启动后加载的一些模块在内存快照之前已被卸载。基于这些证据，似乎MAS未报告结果的内存快照中不包含MAS应报告的任何数据。

大量样本未报告内核行为的原因可能有几个。如上所述，其中一些样本可能根本不是恶意软件。另外，我们粗略的样本启动方式可能导致样本无法执行或恶意软件未激活。可靠的触发恶意软件的技术已在其他地方进行了研究[5, 8]，这不是本文的重点。本节的其余部分展示了MAS报告内核行为的89,474个样本的分析结果。

#### 4.1 一般行为统计

表2显示了我们观察到的不同类别内核行为的计数。每个类别的计数是显示该类别行为的样本数量。有些样本在多个类别中显示行为。大多数类别对应于现有工具可以检测到的静态数据结构的修改。IDT表示对处理器中断描述符表中的函数指针的修改。Sysenter表示对决定sysenter指令目标地址的硬件寄存器的修改。Callgate表示对硬件定义的调用门结构中的函数指针的类似修改。

当直接比较时，MAS的速度几乎是KOP的十倍。在11个Windows Vista SP1转储中，MAS没有错认或错过KOP找到的任何函数指针，但KOP错认或错过了多达40%的可疑函数指针。

#### 4.2 函数指针挂钩

我们发现样本总共挂钩了191个不同的函数指针字段，这些字段来自属于Windows内核和五个驱动程序（ntfs、fastfat、ndis、fltmgr、null）的31个不同数据结构。图8显示了挂钩每个191个函数指针字段的样本数量。我们观察到高度集中在一小部分指针上，且长尾效应明显。0到60之间的两个平台主要对应于nt! DRIVER OBJECT和nt! FAST IO DISPATCH的函数指针。几乎50%的函数指针仅被一两个样本挂钩。

我们还统计了每个样本挂钩的动态函数指针数量。分布如图9所示，高度集中。几乎一半的样本恰好挂钩了32个函数指针。还有一个较小的集中在4左右。这种高集中度表明版本或完全相同的底层恶意软件存在于大量样本中。

#### 4.3 聚类

为了对样本进行聚类，我们首先从MAS的报告中提取以下信息作为样本的特征。