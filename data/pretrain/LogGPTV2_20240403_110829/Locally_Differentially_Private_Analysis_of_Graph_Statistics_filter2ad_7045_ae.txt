wi ‚Üê ti ‚àí p1si;
ÀÜwi ‚Üê wi + Lap(
release( ÀÜwi);
Àúdmax
Œµ2
);
*/
*/
10
11
12
13
14 end
15 return
i=1 ÀÜwi
1‚àí2p1 ‚àën
1
Algorithm 3: Local2Rounds(cid:52)
Algorithm 3 contains the formal description of this process.
It takes as input a graph G, the privacy budgets Œµ1,Œµ2 ‚àà R‚â•0 at
the Ô¨Årst and second rounds, respectively, and a non-negative
integer Àúdmax ‚àà Z‚â•0. At the Ô¨Årst round, we apply the RR to the
lower triangular part of A (i.e., there is no overlap between
edges sent by users) and use the UndirectedGraph function
to obtain a noisy graph G(cid:48) = (V,E(cid:48)) by the RR in the same
way as Algorithm 2. Note that G(cid:48) is biased. We calculate an
unbiased estimate of f(cid:52)(G) from G(cid:48) at the second round.
Àúdmax
Œµ2
At the second round, each user vi calculates ÀÜwi = wi +
) by adding the Laplacian noise to wi in Proposi-
Lap(
tion 3 whose sensitivity is at most Àúdmax (as we will prove
i=1 ÀÜwi, which is an
in Theorem 5). Finally, we output
1‚àí2p1 ‚àën
1
unbiased estimate of f(cid:52)(G) by Proposition 3. We call this
algorithm Local2Rounds(cid:52).
Theoretical properties. Local2Rounds(cid:52) has the following
guarantee.
Theorem 5. Local2Rounds(cid:52) provides (Œµ1 + Œµ2)-edge LDP
and (Œµ1 + Œµ2)-relationship DP.
As with LocalRR(cid:52), Local2Rounds(cid:52) does not have the dou-
bling issue; i.e., it provides Œµ-relationship DP (not 2Œµ). This
follows from the fact that we use only the lower triangular
part of A; i.e., we assume j < k < i in counting ti and si.
Theorem 6. Let
Local2Rounds(cid:52). Then, for all Œµ1,Œµ2 ‚àà R‚â•0,
and G ‚àà G such that
G is at most
O
ÀÜf(cid:52)(G,Œµ1,Œµ2, Àúdmax) be the output of
Àúdmax ‚àà Z‚â•0,
(cid:17)(cid:17)
the maximum degree dmax of
2 ( ÀÜf(cid:52)(G,Œµ1,Œµ2, Àúdmax), f(cid:52)(G))] ‚â§
Àúdmax, E[l2
Àúd2
maxn
(cid:16) eŒµ1
(cid:16) Àúd3
.
(1‚àíeŒµ1 )2
maxn + eŒµ1
Œµ2
2
Theorem 6 means that for triangles, the l2 loss is reduced
from O(n4) to O( Àúd3
maxn) by introducing an additional round.
Private calculation of dmax. As with k-stars, we can privately
calculate dmax by using the method described in Section 4.1.
Furthermore, the private calculation of dmax does not increase
the number of rounds; i.e., we can run Local2Rounds(cid:52) with
the private calculation of dmax in two rounds.
SpeciÔ¨Åcally, let Œµ0 ‚àà R‚â•0 be the privacy budget for the
private calculation of dmax. At the Ô¨Årst round, each user vi
) to her degree di, and sends the noisy degree ÀÜdi
adds Lap( 1
Œµ0
(= di + Lap( 1
)) to the data collector, along with the outputs
Œµ0
Ri = (RRŒµ(ai,1), . . . ,RRŒµ(ai,i‚àí1)) of the RR. The data collec-
tor calculates the noisy max degree ÀÜdmax (= max{ ÀÜd1, . . . , ÀÜdn})
as an estimate of dmax, and sends it back to all users. At the
second round, we run Local2Rounds(cid:52) with input G (repre-
sented as a1, . . . ,an), Œµ1, Œµ2, and (cid:98) ÀÜdmax(cid:99).
At the Ô¨Årst round, the calculation of ÀÜdmax provides Œµ0-edge
LDP. Note that it provides 2Œµ0-relationship DP (i.e., it has the
doubling issue) because one edge (vi,v j) ‚àà E affects both of
the degrees di and d j by 1. At the second round, LocalLapk(cid:63)
provides (Œµ1 + Œµ2)-edge LDP and (Œµ1 + Œµ2)-relationship DP
(Theorem 5). Then by the composition theorem [23], this
two-rounds algorithm provides (Œµ0 + Œµ1 + Œµ2)-edge LDP and
(2Œµ0 + Œµ1 + Œµ2)-relationship DP. Although the total privacy
budget is larger for relationship DP, the difference (= Œµ0) can
be very small. In fact, we set (Œµ0,Œµ1,Œµ2) = (0.1,0.45,0.45) or
(0.2,0.9,0.9) in our experiments (i.e., the difference is 0.1 or
0.2), and show that this algorithm provides almost the same
utility as Local2Rounds(cid:52) with the true max degree dmax.
Time complexity. We also note that Local2Rounds(cid:52) has an
advantage over LocalRR(cid:52) in terms of the time complexity.
SpeciÔ¨Åcally, LocalRR(cid:52) is inefÔ¨Åcient because the data col-
lector has to count the number of triangles m3 in the noisy
graph G(cid:48). Since the noisy graph G(cid:48) is dense (especially when
(cid:1) subgraphs with three nodes in
Œµ is small) and there are(cid:0)n
3
USENIX Association
30th USENIX Security Symposium    991
G(cid:48), the number of triangles is m3 = O(n3). Then, the time
complexity of LocalRR(cid:52) is also O(n3), which is not practical
for a graph with a large number of users n. In fact, we im-
plemented LocalRR(cid:52) (Œµ = 1) with C/C++ and measured its
running time using one node of a supercomputer (ABCI: AI
Bridging Cloud Infrastructure [4]). When n = 5000, 10000,
20000, and 40000, the running time was 138, 1107, 9345, and
99561 seconds, respectively; i.e., the running time was almost
cubic in n. We can also estimate the running time for larger n.
For example, when n = 1000000, LocalRR(cid:52) (Œµ = 1) would
require about 35 years (= 1107√ó 1003/(3600√ó 24√ó 365)).
In contrast, the time complexity of Local2Rounds(cid:52) is
O(n2 + nd2
max)1. The factor of n2 comes from the fact that
the size of the noisy graph G(cid:48) is O(n2). This also causes a
large communication overhead, as explained below.
Communication overhead. In Local2Rounds(cid:52), each user
need to see the noisy graph G(cid:48) of size O(n2) to count ti and si.
This results in a per-user communication overhead of O(n2).
Although we do not simulate the communication overhead in
our experiments that use Local2Rounds(cid:52), the O(n2) overhead
might limit its application in very large graphs. An interesting
avenue of future work is how to compress the graph size (e.g.,
via graph projection or random projection) to reduce both the
time complexity and the communication overhead.
4.4 Lower Bounds
We show a general lower bound on the l2 loss of private
estimators ÀÜf of real-valued functions f
in the one-round
LDP model. Treating Œµ as a constant, we have shown that
when Àúdmax = dmax, the expected l2 loss of LocalLaplacek(cid:63) is
O(nd2k‚àí2
max ) (Theorem 2). However, in the centralized model,
2 errors of O(d2k‚àí2
we can use the Laplace mechanism with sensitivity 2(cid:0)dmax
obtain l2
of n is necessary in the one-round LDP model.
max ) for fk(cid:63). Thus, we ask if the factor
(cid:1) to
k‚àí1
We answer this question afÔ¨Årmatively. We show for many
2 ( f (G), ÀÜf (G))
types of queries f , there is a lower bound on l2
for any private estimator ÀÜf of the form
ÀÜf (G) = Àúf (R1(a1), . . . ,Rn(an)),
(6)
where R1, . . . ,Rn satisfy Œµ-edge LDP or Œµ-relationship DP and
Àúf is an aggregate function that takes R1(a1), . . . ,Rn(an) as
input and outputs ÀÜf (G). Here we assume that R1, . . . ,Rn are
independently run, meaning that they are in the one-round
setting. For our lower bound, we require that input edges to
f be ‚Äúindependent‚Äù in the sense that adding an edge to an
1When we evaluate Local2Rounds(cid:52) in our experiments, we can apply
the RR to only edges that are required at the second round; i.e., (v j,vk) ‚àà G(cid:48)
in line 8 of Algorithm 3. Then the time complexity of Local2Rounds(cid:52) can
be reduced to O(nd2
max) in total. We also conÔ¨Årmed that when n = 1000000,
the running time of Local2Rounds(cid:52) was 311 seconds on one node of the
ABCI. Note, however, that this does not protect individual privacy, because
it reveals the fact that users v j and vk are friends with ui to the data collector.
Figure 3: (4,2)-independent cube A for f . In this example,
M = {(v1,v2), (v3,v4)}, G1 = (V,E), A = {(V,E ‚à™ N) : N ‚äÜ
M}, C(v1,v2) = 2, and C(v3,v4) = 3. Adding (v1,v2) and (v3,v4)
increase f by 2 and 3, respectively.
input graph G independently change f by at least D ‚àà R. The
speciÔ¨Åc structure of input graphs we require is as follows:
DeÔ¨Ånition 5. [(n,D)-independent cube for f ] Let D ‚àà R‚â•0.
For Œ∫‚àà N, let G = (V,E)‚àà G be a graph on n = 2Œ∫ nodes, and
let M = {(vi1,vi2 ), (vi3,vi4), . . . , (vi2k‚àí1,vi2Œ∫ )} for integers i j ‚àà
[n] be a set of edges such that each of i1, . . . ,i2Œ∫ is distinct (i.e.,
perfect matching on the nodes). Suppose that M is disjoint
from E; i.e., (vi2 j‚àí1,vi2 j ) /‚àà E for any j ‚àà [Œ∫]. Let A = {(V,E ‚à™
N) : N ‚äÜ M}. Note that A is a set of 2Œ∫ graphs. We say A is
an (n,D)-independent cube for f if for all G(cid:48) = (V,E(cid:48)) ‚àà A,
we have
f (G(cid:48)) = f (G) + ‚àë
e‚ààE(cid:48)‚à©M
Ce,
where Ce ‚àà R satisÔ¨Åes |Ce| ‚â• D for any e ‚àà M.
Such a set of inputs has an ‚Äúindependence‚Äù property be-
cause, regardless of which edges from M has been added
before, adding edge e ‚àà M always changes f by Ce. Figure 3
shows an example of a (4,2)-independent cube for f .
We can also construct a independent cube for a k-star func-
tion as follows. Assume that n is even. It is well known in
graph theory that if n is even, then for any d ‚àà [n‚àí 1], there
exists a d-regular graph where every node has degree d [25].
Therefore, there exists a (dmax ‚àí 1)-regular graph G = (V,E)
of size n. Pick an arbitrary perfect matching M on the nodes.
Now, let G(cid:48) = (V,E(cid:48)) such that E(cid:48) = E \ M. Every node in
G(cid:48) has degree between dmax ‚àí 2 and dmax ‚àí 1. Adding an
(cid:1) new k-stars.
edge in M to G(cid:48) will produce at least 2(cid:0)dmax‚àí2
Thus, A = {(V,E(cid:48) ‚à™ N) : N ‚äÜ M} forms an (n,2(cid:0)dmax‚àí2
(cid:1))-
independent cube for fk(cid:63). Note that the maximum degree of
each graph in A is at most dmax. Figure 4 shows how to con-
struct an independent cube for a k-star function when n = 6
k‚àí1
k‚àí1
992    30th USENIX Security Symposium
USENIX Association
ùë£3ùë£4ùë£1ùë£2ùëÄùë£3ùë£4ùë£1ùë£2ùê∫4ùëìùê∫4=5ùë£3ùë£4ùë£1ùë£2ùê∫2ùëìùê∫2=3ùë£3ùë£4ùë£1ùë£2ùê∫3ùëìùê∫3=2ùë£3ùë£4ùë£1ùë£2ùê∫1ùëìùê∫1=04,2-independentcubeùíú(cid:16) d2k‚àí2
(cid:17)
(cid:16) d2
(cid:17)
max
Œµ2
max
Œµ2
fk(cid:63) O
f(cid:52) O
Centralized
Upper Bound Lower Bound
(cid:16) e2Œµ
(cid:16) e2Œµ
(e2Œµ+1)2 d2k‚àí2
max n
(e2Œµ+1)2 d2
maxn
(cid:17)
(cid:17)
One-round local