    保存到文件中的会话信息的形式如下。
    ``` 代码无行号
        answer|s:21:"
        ";
    ```
    这是有效的 PHP 代码格式，因此应该能够被执行。我们也可以点击图 4-119
    中的"文件包含攻击"链接来尝试。点击后的页面显示如下。链接的 URL
    中使用了空字节攻击的手法使得 .php 扩展名无效。
    ![{%}](Image00175.jpg)
    **图 4-120 外界指定的脚本被执行**
    如你所见，外界指定的脚本（`phpinfo` 函数）被执行了。
    综上所述，文件包含攻击除了能造成 Web 服务器内的文件泄漏，根据 Web
    应用规格或设置的不同，还可能会造成外界指定的任意脚本被执行。
[70]{.注释编号下}
此处的攻击方法参考了小邨孝明的博客文章：
。
#### **安全隐患的产生原因**
当应用满足以下两个条件时，就会产生文件包含漏洞。
-   include 的文件名能够由外界指定
-   没有校验 include 的文件名是否妥当
#### **对策**
消除文件包含漏洞的思路与目录遍历漏洞相同。
-   避免由外界指定文件名
-   避免文件名中包含目录名
-   限制文件名仅包含字母和数字
具体方法在 4.10 节中已经做过讲述，因此此处就不再重复了。
另外，作为防范文件包含攻击的辅助性对策，建议通过设置将 RFI
功能禁止。虽然在 PHP5.2.0
以后版本中已经默认对其进行了禁止，但保险起见最好还是确认一下。确认方法为查看
`phpinfo` 函数的执行结果中 allow_url_include 项目是否为 Off。php.ini
中的设置如下。
``` 代码无行号
allow_url_include = Off
```
#### **总结**
本节讲述了脚本语言中的文件包含功能所引发的漏洞。PHP 中将文件动态 include
的做法无处不在，而如果对文件名的校验不充分，就可能会混入文件包含漏洞。由于该隐患影响极大，因此请务必积极实施防范策略。
## **4.14 eval 相关的问题** {#text00000.html#nav_point_55}
PHP 和 Perl、Ruby、JavaScript
等多数脚本语言中都提供了将字符串解释为脚本代码并执行的功能。绝大多数情况下，该功能由名为
`eval` （evaluate 的省略）的函数提供。而本节就将讲述因 `eval`
的使用方法不当而引起 eval 注入漏洞的问题。
### **4.14.1 eval 注入** {#text00000.html#nav_point_56}
#### **概要**
如果 `eval`
函数的使用方法不当，就有可能导致外界传入的脚本被执行。这被称为 eval 注入
[71]{.注释编号} 攻击，招致此类攻击的漏洞即为 eval 注入漏洞。
[71]{.注释编号下} 也有的书中称为"eval 利用攻击"。本书参考了 CWE-95
的命名"Eval Injection"而将其称为 eval
注入。参考： （2010 年 12
月 18 日）。
eval 注入造成的影响与 OS 命令注入攻击相同，具体如下。
-   信息泄漏
-   篡改网站
-   执行非法操作
-   攻击其他网站（垫脚石）
eval 注入漏洞的对策为实施以下任意一项。
-   不使用 `eval` 或与 `eval` 相当的功能
-   避免 `eval` 的参数中包含外界传入的参数
-   `eval` 的参数中包含外界传入的参数时，将其限定为只包含字母和数字
**eval 注入漏洞总览**
![{%}](Image00176.jpg)
#### **攻击手段与影响**
接下来我们就来看一下 eval 注入的攻击手段及其影响。
-   **存在漏洞的应用**
    `eval`
    可以被应用于各种各样的目的，而作为示例，这里我们来看一下将复杂的数据变换为字符串（序列化）后将其在表单之间传递的情况下所产生的漏洞。
    PHP 中存在名为 `var_export` 的函数，它会将表达式的值以 PHP
    代码的形式返回。下面是该函数的执行例。
    ``` 代码无行号
     1,
      1 => 2,
      2 => 3,
    )
    ```
    由于执行结果是 PHP 代码的形式，因此能够使用 `eval`
    来回溯得到原先的数据（反序列化）。
    下面为使用 `var_export` 函数将数组序列化后传递给表单的脚本。
    > **代码清单 /4e/4e-001.php**
    ``` 代码无行号
    ">
    ```
    以上脚本将收到的数据（此处为数组）经过 `var_export` 函数序列化并使用
    Base64 编码加密后将其传递给了 4e-002.php 脚本。
    > **代码清单 /4e/4e-002.php**
    ``` 代码无行号
    ```
    4e-002.php 将接收到的数据以 Base64 的方式解码，然后使用 `eval`
    还原数据，并通过 `var_dum p` 函数将其显示在页面上 [72]{.注释编号}
    。通过 `eval` 执行的表达式如下所示。阴影部分为经过 `var_export`
    序列化后的字符串，这里将其赋值给了变量 `$a` 。
        $a = array (
          0 => 1,
          1 => 2,
          2 => 3,
        )
        ;
    4e-002.php 的执行结果如下图所示，能够看到值被还原了回去。
    ![{%}](Image00177.jpg)
    **图 4-121 示例脚本的执行结果**
-   **攻击手段**
    4e-002.php 中没有对外界传入的参数进行校验就将其直接传递给了 `eval`
    ，因此便存在能够使得外界注入脚本的漏洞。使用下面这种形式，就能够任意添加交由
    `eval` 执行的表达式。
        $a = 表达式 ; 任意语句 ;
    这里我们使用以下注入语句。
        $a = 0; phpinfo()
        ;
    首先将上面的阴影部分进行 Base64 编码。在 Fiddler 的 Tool 菜单中选
    择"Text Encode/Decode"，这时会出现如图 4-122 的对 话框。在上面输入
    0; phpinfo()，然后选择左侧的"To Base64"。Base64
    编码后的结果会显示在右下方。
    ![{%}](Image00178.jpg)
    **图 4-122 在 Fiddler 中将字符串进行 Base64 编码**
    接下来，将编码后的值传给 4e-002.php。URL 和执行结果显示如下。
    ``` 代码无行号
    http://example.jp/4e/4e-002.php?data=MDsgcGhwaW5mbygp
    ```
    ![{%}](Image00179.jpg)
    **图 4-123 外界注入的脚本被执行了**
    由此可以得知，外界注入的 `phpinfo` 函数被成功执行了。
    而一旦攻击取得成功，PHP
    中能够进行的操作就都有可能被用来攻击应用程序。从而就会导致信息被泄漏、数据被篡改、数据库遭到变更、网站被关闭、其他网站受到攻击等各种典型问题。
[72]{.注释编号下} 由于 `var_dump` 函数内部不会进行 HTML
转义，因此这部分存在 XSS 漏洞。
#### **安全隐患的产生原因**
`evel` 能够执行任意的 PHP 脚本代码，可谓是一种极其危险的功能。4e-002.php
中没有校验传给 `eval` 的参数，因此便使得外界成功地执行了任意脚本。
安全隐患的产生原因能被简单地归纳为如下两点。
-   使用 `eval` 本来就是很危险的
-   没有校验传给 `eval` 的参数
除了 `eval` 之外，PHP 中能够解释输入字符串并将其执行的函数还有以下几种。
**表 4-23 PHP 中能够解释输入字符串并执行的函数**
  函数名                解说
  --------------------- ----------------------------
  `create_function()`   动态生成函数
  `preg_replace()`      指定 e 修饰符时
  `mb_ereg_replace()`   第 4 个参数指定为 \'e\' 时
此外，有些函数能够在参数中指定函数名（回调函数），这时如果函数名能够由外界指定，也会产生漏洞。下面列举的例子都属于此类函数。
**PHP 中能够在参数中指定函数名的函数**
  ---------------------- ---------------------------- ----------------- ------------------
  \`call_user_func()\`   \`call_user_func_array()\`   \`array_map()\`   \`array_walk()\`
  \`array_filter()\`     \`usort()\`                  \`uksort()\`       