      "expires_in":685,"
      "refresh_token":"22b157546b26c2d6c0165c4ef6b3f736",
      "access_token":"cac93e1d29e45bf6d84073dbfb460"
}
Note If using the authorization code grant type is an option, it should be used 
over the resource owner password credentials grant type. the resource owner 
password credentials grant type was introduced to aid migration from http Basic 
authentication and digest authentication to Oauth 2.0.
 Client Credentials Grant Type
The client credentials grant type is equivalent to the Client Account and Password Profile 
in OAuth WRAP and to two-legged OAuth in OAuth 1.0 (see Appendix B). With this 
grant type, the client itself becomes the resource owner (see Figure 4-5). The following 
cURL command talks to the token endpoint of the authorization server, passing the 
client application’s client_id (0rhQErXIX49svVYoXJGt0DWBuFca) and client_secret 
(eYOFkL756W8usQaVNgCNkz9C2D0a).
Chapter 4  Oauth 2.0 Fundamentals
92
\> curl –v –k -X POST --basic
     -u 0rhQErXIX49svVYoXJGt0DWBuFca:eYOFkL756W8usQaVNgCNkz9C2D0a
     -H "Content-Type: application/x-www-form-urlencoded;charset=UTF-8"
     -d "grant_type=client_credentials"
     https://authz.example.com/oauth2/token
This returns the following response, which includes an access token. Unlike the 
resource owner password credentials grant type, the client credentials grant type doesn’t 
return a refresh token:
{     "token_type":"bearer",
      "expires_in":3600,
      "access_token":"4c9a9ae7463ff9bb93ae7f169bd6a"
}
This client credential grant type is mostly used for system-to-system interactions 
with no end user. For example, a web application needs to access an OAuth secured API 
to get some metadata.
 Refresh Grant Type
Although it’s not the case with the implicit grant type and the client credentials grant 
type, with the other two grant types, the OAuth access token comes with a refresh token. 
This refresh token can be used to extend the validity of the access token without the 
involvement of the resource owner. The following cURL command shows how to get a 
new access token from the refresh token: 
Figure 4-5. Client credentials grant type
Chapter 4  Oauth 2.0 Fundamentals
93
\> curl -v -X POST --basic
    -u 0rhQErXIX49svVYoXJGt0DWBuFca:eYOFkL756W8usQaVNgCNkz9C2D0a
    -H "Content-Type: application/x-www-form-urlencoded;charset=UTF-8"
    -k -d "grant_type=refresh_token&
           refresh_token=22b157546b26c2d6c0165c4ef6b3f736"
    https://authz.example.com/oauth2/token
This returns the following response:
{
      "token_type":"bearer",
      "expires_in":3600,
      "refresh_token":"9ecc381836fa5e3baf5a9e86081",
      "access_token":"b574d1ba554c26148f5fca3cceb05e2"
}
Note the refresh token has a much longer lifetime than the access token. If 
the lifetime of the refresh token expires, then the client must initiate the Oauth 
token flow from the start and get a new access token and refresh token. the 
authorization server also has the option to return a new refresh token each time 
the client refreshes the access token. In such cases, the client has to discard the 
previously obtained refresh token and begin using the new one.
 How to Pick the Right Grant Type?
As we discussed at the very beginning of the chapter, OAuth 2.0 is an authorization 
framework. The nature of a framework is to provide multiple options, and it’s up to the 
application developers to pick the best out of those options, based on their use cases. 
OAuth can be used with any kind of application. It can be a web application, single-page 
application, desktop application, or a native mobile application.
To pick the right grant type for those applications, first we need to think how the 
client application is going to invoke the OAuth secured API: whether it is going to access 
the API by itself or on behalf of an end user. If the application wants to access the API 
just being itself, then we should use client credentials grant type and, if not, should 
use authorization code grant type. Both the implicit and password grant types are now 
obsolete.
Chapter 4  Oauth 2.0 Fundamentals
94
 OAuth 2.0 Token Types
Neither OAuth 1.0 nor WRAP could support custom token types. OAuth 1.0 always used 
signature-based tokens, and OAuth WRAP always used bearer tokens over TLS. OAuth 2.0 
isn’t coupled into any token type. In OAuth 2.0, you can introduce your own token type 
if needed. Regardless of the token_type returned in the OAuth token response from the 
authorization server, the client must understand it before using it. Based on the token_
type, the authorization server can add additional attributes/parameters to the response. 
OAuth 2.0 has two main token profiles: OAuth 2.0 Bearer Token Profile and OAuth 
2.0 MAC Token Profile. The most popular OAuth token profile is Bearer; almost all OAuth 
2.0 deployments today are based on the OAuth 2.0 Bearer Token Profile. The next section 
talks about the Bearer Token Profile in detail, and Appendix G discusses the MAC Token 
Profile. 
 OAuth 2.0 Bearer Token Profile
The OAuth 2.0 Bearer Token Profile was influenced by OAuth WRAP, which only 
supported bearer tokens. As its name implies, anyone who bears the token can use 
it—don’t lose it! Bearer tokens must always be used over Transport Layer Security 
(TLS) to avoid losing them in transit. Once the bearer access token is obtained from the 
authorization server, the client can use it in three ways to talk to the resource server. 
These three ways are defined in the RFC 6750. The most popular way is to include the 
access token in the HTTP Authorization header: 
Note an Oauth 2.0 bearer token can be a reference token or self-contained 
token. a reference token is an arbitrary string. an attacker can carry out a brute- 
force attack to guess the token. the authorization server must pick the right length 
and use other possible measures to prevent brute forcing. a self-contained access 
token is a JsOn Web token (JWt), which we discuss in Chapter 7. When the 
resource server gets an access token, which is a reference token, then to validate 
the token, it has to talk to the authorization server (or the token issuer). When the 
access token is a JWt, the resource server can validate the token by itself, by 
verifying the signature of the JWt.
Chapter 4  Oauth 2.0 Fundamentals
95
GET /resource HTTP/1.1
Host: rs.example.com
Authorization: Bearer JGjhgyuyibGGjgjkjdlsjkjdsd
The access token can also be included as a query parameter. This approach is mostly 
used by the client applications developed in JavaScript:
GET /resource?access_token=JGjhgyuyibGGjgjkjdlsjkjdsd
Host: rs.example.com
Note When the value of the Oauth access token is sent as a query parameter, 
the name of the parameter must be access_token. Both Facebook and Google 
use the correct parameter name, but linkedIn uses oauth2_access_token and 
salesforce uses oauth_token.
It’s also possible to send the access token as a form-encoded body parameter. An 
authorization server supporting the Bearer Token Profile should be able to handle any of 
these patterns:
POST /resource HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded
access_token=JGjhgyuyibGGjgjkjdlsjkjdsd
Note the value of the Oauth bearer token is only meaningful to the authorization 
server. the client application should not try to interpret what it says. to make the 
processing logic efficient, the authorization server may include some meaningful 
but nonconfidential data in the access token. For example, if the authorization 
server supports multiple domains with multitenancy, it may include the tenant 
domain in the access token and then base64-encode (see appendix e) it or simply 
use a JsOn Web token (JWt).
Chapter 4  Oauth 2.0 Fundamentals
96
 OAuth 2.0 Client Types
OAuth 2.0 identifies two types of clients: confidential clients and public clients. 
Confidential clients are capable of protecting their own credentials (the client key and the 
client secret), whereas public clients can’t. The OAuth 2.0 specification is built around 
three types of client profiles: web applications, user agent–based applications, and native 
applications. Web applications are considered to be confidential clients, running on a web 
server: end users or resource owners access such applications via a web browser. User 
agent–based applications are considered to be public clients: they download the code 
from a web server and run it on the user agent, such as JavaScript running in the browser. 
These clients are incapable of protecting their credentials—the end user can see anything 
in the JavaScript. Native applications are also considered as public clients: these clients are 
under the control of the end user, and any confidential data stored in those applications 
can be extracted out. Android and iOS native applications are a couple of examples.
Note all four grant types defined in the Oauth 2.0 core specification require 
the client to preregister with the authorization server, and in return it gets a client 
identifier. under the implicit grant type, the client doesn’t get a client secret. at the 
same time, even under other grant types, it’s an option whether to use the client 
secret or not.
Table 4-2 lists the key differences between OAuth 1.0 and OAuth 2.0 Bearer Token 
Profile.
Table 4-2. OAuth 1.0 vs. OAuth 2.0
OAuth 1.0
OAuth 2.0 Bearer Token Profile
an access delegation protocol
an authorization framework for access delegation
signature based: hmaC-sha256/rsa- sha256
nonsignature-based, Bearer token profile
less extensibility
highly extensible via grant types and token types
less developer-friendly
tls required only during the initial handshake
secret key never passed on the wire
more developer-friendly
Bearer token profile mandates using tls during 
the entire flow
secret key goes on the wire (Bearer token profile)
Chapter 4  Oauth 2.0 Fundamentals
97
Note Oauth 2.0 introduces a clear separation between the client, the resource 
owner, the authorization server, and the resource server. But the core Oauth 2.0 
specification doesn’t talk about how the resource server validates an access 
token. most Oauth implementations started doing this by talking to a proprietary 
apI exposed by the authorization server. the Oauth 2.0 token Introspection profile 
standardized this to some extent, and in Chapter 9, we talk more about it.
 JWT Secured Authorization Request (JAR)
In an OAuth 2.0 request to the authorize endpoint of the authorization server, all the 
request parameters flow via the browser as query parameters. The following is an 
example of an OAuth 2.0 authorization code grant request:
https://authz.example.com/oauth2/authorize?
                   response_type=token&
                   client_id=0rhQErXIX49svVYoXJGt0DWBuFca&
                   redirect_uri=https%3A%2F%2Fmycallback
There are a couple of issues with this approach. Since these parameters flow via the 
browser, the end user or anyone on the browser can change the input parameters that 
could result in some unexpected outcomes at the authorization server. At the same time, 
since the request is not integrity protected, the authorization server has no means to 
validate who initiated the request. With JSON Web Token (JWT) secured authorization 
requests, we can overcome these two issues. If you are new to JWT, please check 
Chapters 7 and 8. JSON Web Token (JWT) defines a container to transport data between 
interested parties in a cryptographically safe manner. The JSON Web Signature (JWS) 
specification developed under the IETF JOSE working group, represents a message or 
a payload, which is digitally signed or MACed (when a hashing algorithm is used with 
HMAC), while the JSON Web Encryption (JWE) specification standardizes a way to 
represent an encrypted payload.
One of the draft proposals1 to the IETF OAuth working group suggests to introduce 
the ability to send request parameters in a JWT, which allows the request to be signed 
1 The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request (JAR).
Chapter 4  Oauth 2.0 Fundamentals
98
with JWS and encrypted with JWE so that the integrity, source authentication, and 
confidentiality properties of the authorization request are preserved. At the time of 
writing, this proposal is in its very early stage—and if you are familiar with Security 
Assertion Markup Language (SAML) Single Sign-On, this is quite analogous to the signed 
authentication requests in SAML. The following shows the decoded payload of a sample 
authorization request, which ideally goes within a JWT:
{
  "iss": "s6BhdRkqt3",
  "aud": "https://server.example.com",
  "response_type": "code id_token",
  "client_id": "s6BhdRkqt3",
  "redirect_uri": "https://client.example.org/cb",
  "scope": "openid",
  "state": "af0ifjsldkj",
  "nonce": "n-0S6_WzA2Mj",
  "max_age": 86400
}
Once the client application constructs the JWT (a JWS or a JWE—please see Chapters 
7 and 8 for the details), it can send the authorization request to the OAuth authorization 
server in two ways. One way is called passing by value, and the other is passing by 
reference. The following shows an example of passing by value, where the client 
application sends the JWT in a query parameter called request. The [jwt_assertion] in 
the following request represents either the actual JWS or JWE.
https://server.example.com/authorize?request=[jwt_assertion]
The draft proposal for JWT authorization request introduces the pass by reference 
method to overcome some of the limitations in the pass by value method, as listed here:
• 
Many mobile phones in the market as of this writing still do not 
accept large payloads. The payload restriction is typically either 512 
or 1024 ASCII characters.
• 
The maximum URL length supported by older versions of the 
Internet Explorer is 2083 ASCII characters.
Chapter 4  Oauth 2.0 Fundamentals
99
• 
On a slow connection such as a 2G mobile connection, a large 
URL would cause a slow response. Therefore the use of such is not 
advisable from the user experience point of view.
The following shows an example of pass by reference, where the client application 
sends a link in the request, which can be used by the authorization server to fetch the 
JWT. This is a typical OAuth 2.0 authorization code request, along with the new request_
uri query parameter. The value of the request_uri parameter carries a link pointing to 
the corresponding JWS or JWE.
https://server.example.com/authorize?
        response_type=code&
        client_id=s6BhdRkqt3&
        request_uri=https://tfp.example.org/request.jwt/Schjwew&
        state=af0ifjsldkj
 Pushed Authorization Requests (PAR)
This is another draft proposal being discussed under the IETF OAuth working group 
at the moment, which complements the JWT Secured Authorization Request (JAR) 
approach we discussed in the previous section. One issue with JAR is each client has 
to expose an endpoint directly to the authorization server. This is the endpoint that 
hosts the corresponding JWT, which is used by the authorization server. With Pushed 
Authorization Requests (PAR) draft proposal, this requirement goes a way. PAR defines 
an endpoint at the authorization server end, where each client can directly push (without 
going through the browser) all the parameters in a typical OAuth 2.0 authorization 
request and then use the normal authorization flow via the browser to pass a reference 
to the pushed request. Following is an example, where the client application pushes 
authorization request parameters to an endpoint hosted at the authorization server. This 
push endpoint on the authorization server can be secured either with mutual Transport 
Layer Security (TLS) or with OAuth 2.0 itself (client credentials) or with any other means 
as agreed between the client application and the authorization server.
POST /as/par HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
Chapter 4  Oauth 2.0 Fundamentals
100
response_type=code&
state=af0ifjsldkj&
client_id=s6BhdRkqt3&
redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb&
scope=ais
If the client follows the JAR specification which, we discussed in the previous section, 
it can also send a JWS or a JWE to the push endpoint in the following way.
POST /as/par HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded
Authorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3
request=[jwt_assertion]
Once the push endpoint at the authorization server receives the preceding request, 
it has to carry out all the validation checks against the request that it usually performs 
against a typical authorization request. If it all looks good, the authorization server 
responds with the following. The value of the request_uri parameter in the response 
is bound to the client_id in the request and acts as a reference to the authorization 
request.
HTTP/1.1 201 Created
Date: Tue, 2 Oct 2019 15:22:31 GMT
Content-Type: application/json
{
  "request_uri": "urn:example:bwc4JK-ESC0w8acc191e-Y1LTC2",
  "expires_in": 3600
}
Upon receiving the push response from the authorization server, the client 
application can construct the following request with the request_uri parameter from 
the response to redirect the user to the authorization server.
https://server.example.com/authorize?
        request_uri=urn:example:bwc4JK-ESC0w8acc191e-Y1LTC2
Chapter 4  Oauth 2.0 Fundamentals