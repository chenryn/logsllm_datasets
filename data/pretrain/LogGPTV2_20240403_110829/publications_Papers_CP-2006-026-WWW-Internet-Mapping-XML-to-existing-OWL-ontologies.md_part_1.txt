MAPPING XML TO EXISTING OWL ONTOLOGIES
Toni Rodrigues, Pedro Rosa, Jorge Cardoso
Department of Mathematics and Engineering
University of Madeira
9050-390 Funchal, Portugal
PI:EMAIL, PI:EMAIL, PI:EMAIL
ABSTRACT
Now-a-days, XML has reached a wide recognition and brought interoperability at a syntactic level. Unfortunately, even
when using XML to represent data, problems arise when it is necessary to integrate different data sources because XML
lacks support for efficient sharing of conceptualization. Emerging Semantic Web technologies, such as ontologies, can
enable semantic interoperability. With ontologies, it is possible to formally represent shared domain knowledge models
defined with concepts, attributes, relationships and instances. In this paper, we present a notation to map XML Schema to
existing OWL ontologies and the qualities an algorithm should have to transform XML documents (instances of the
mapped schema) into instances of the mapped ontology.
KEYWORDS
Semantic Web, Ontology Mapping, Ontology Generation, XML, OWL.
1. INTRODUCTION
XML brought syntactic interoperability and became the de facto standard as a B2B data exchange format [1].
However, XML “lacks semantics” [2, 3]. Thus problems arise when it is necessary to manipulate and
integrate different XML data sources. Consequently, today’s organizations are again shifting (or it is
expected them to do so) from a syntactic interoperability level to a semantic one [4]. Emerging Semantic
Web technologies, such as ontologies, can play an important role in this scenario [3, 5]. Ontologies are a
formal and explicit specification of a shared conceptualization [6] can enable semantic interoperability. They
are supported by the W3C through their Web Ontology Language (OWL) [7] Recommendation. To assist the
migration from XML to OWL, it is necessary to develop tools supporting mappings and transformation
between these two standards. The goal presented in this paper is to narrow the gap between XML and OWL
proposing a strategy to map XML Schema to existing OWL ontologies and transform XML data (instances
of the mapped XML Schema) into instances of the ontology according to the performed mapping.
Several works have been done in this area. Most of them intend to automatically transform XML Schema
into newly created ontologies capturing the implicit semantics existing in the structure of XML documents.
Such approach is used in [8]. They describe automatic mappings from XML to RDF as well as from XML
Schema to OWL. However, since the mappings are independents, the generated instances may not respect the
OWL model created from the XML Schema. In [9] the authors cope with this independency between the
mappings. Their implemented framework creates a new ontology from an XML Schema and transforms
instances of the XML Schema into instances of the created ontology.
Another interesting and more complete approach is the XML2OWL framework [10]. It is developed in
XSLT and transforms XML Schema into an OWL ontology. Additionally, it also supports instances
transformation like the previous described work. This framework goes even further since it is able to generate
an ontology from an XML instances document if no schema is available. This framework resembles the one
we have developed but there are several differences. In fact, this tool creates a new ontology from an XML
schema during which the user has no control on the process. That is, the user has no control on the newly
created ontology which, similarly to XSD2OWL framework discussed earlier, captures the implicit semantics
existent in the XML Schema structure. Therefore the created ontologies are quite primitive, that is, they are
not really semantically richer than the mapped XML Schemas. Our main objective is different. Our approach
allows the mapping of XML schema to an existing ontology and appropriately generates rules that
automatically transform instances of the XML schema to instances of the mapped ontology. Usually, the
mapped ontology is semantically richer than the mapped XML Schema since the ontology can be created
independently of the mapped XML data sources.
Tools supporting mapping from XML Schemas to an existing OWL ontology are very scarce. COMA++
is a schema and ontology matching tool [11] providing several automatic matching algorithm. COMA++ can
establish mappings from XML Schema to OWL but it does not intend to map them with the purpose of
facilitating the transformation of schema’s instances into individuals as we do.
Most of the related works (actually all the one found during our research) does not support mappings and
instances transformation to an existing OWL ontology. These facts make our research and implemented
framework a unique contribution to the pool of semantic Web applications. This paper presents a complete
approach to manually map XML Schemas to existing OWL ontologies with the purpose of automatically
transform instances of the mapped schema into instances of the ontology. We backup our work presenting a
scenario solved with the implemented and ready-to-use JXML2OWL framework.
2. MAPPING XML TO OWL
This section presents a notation to specify mappings between XML and OWL. This notation support several
kinds of mappings: one-to-one, one-to-many, many-to-one and many-to-many. Therefore, the presented
notation allows mappings from one XML node to several OWL concepts and mappings from several XML
nodes to one OWL concept. This section also presents several aspects that must be taken into account when
writing an algorithm to perform the instances transformation according to the created mappings.
2.1. XML to OWL Mapping: The Notation
This section defines a notation, represented in Table 1, to specify mappings between elements of an XML
Schema and resources defined by an OWL ontology. Just like OWL ontologies, which are mainly defined by
classes, datatype and object properties, we classify mappings in three distinct types:
• Class mapping: Maps an XML node to an OWL concept
• Datatype property mapping: Maps an XML node to an OWL datatype property
• Object property mapping: Relates two class mappings to an OWL object property
Table 1. Mapping Notation
Mappings Notation
(OWL Class URI, XPath expression)
Class
(OWL Class URI, XPath expression, ID XPath expression)
(OWL Datatype Property URI, Domain Class Mapping, XPath
Datatype Property
Expression)
(OWL Object Property URI, Domain Class Mapping, Range Class
Object Property
Mapping)
OWL resources (classes, object and datatype properties) are addressed using their URI references [12]
while XPath [13] expressions are used to address the mapped XML nodes. The use of XPath expressions
allows distinguishing several XML nodes with the same name but with different ancestors and permits to
map them to their corresponding OWL concepts. It is also possible to use XPath predicates to enables
conditional mappings.
An examination of Table 1 reveals that class mappings are defined by pairs containing the URI reference
of the mapped OWL class as well as an XPath expression identifying the mapped XML nodes. Such pair
means that an instance of the mapped OWL class is created for each XML nodes matching the XPath
expression. As an alternative, it is also possible to create class mappings with triplets where the XML node
used the compute the IDs of the generated instances are directly specified. This second possibility is
discussed in more details in the next section 2.2 of this paper.
Additionally, Table 1 reveals that not only property mappings are specified with triplets but also that class
mappings are used to define property mappings. Such solution enables a complete support of property
mappings in the context of many-to-many mappings. An example of many-to-many mappings is explored as
a scenario in section 4.
The following example shows how class, datatype and object property mappings are created. Let us
consider an ontology with two OWL classes, tourism:Country and tourism:City, which are
respectively the domain and range of the object property tourism:hasCity. Let us also consider its
inverse property tourism:belongsToCountry, the xsd:string datatype properties tourism:
city_name and tourism:country_name, as well as the following XML document:
Using the notation from Table 1, the following mappings are valid:
• cm1 = (tourism:Country, /locations/location/country)
• cm2 = (tourism:City, /locations/location/city)
• op1 = (tourism:hasCity, cm1, cm2)
• op2 = (tourism:belongsToCountry, cm2, cm1)
• dp3 = (tourism:country_name, cm1, /locations/location/country/@name)
• dp4 = (tourism:city_name, cm1, /locations/location/city/@name)
cm1 mapping means that an instance of Country class is created for each XML node matching the
specified XPath expression. Therefore, two Country individuals are created, one for Portugal and one for
France. Similarly, two City individuals are created. op1 mapping means that each OWL instance created
from the class mapping cm1 is the domain of an object property tourism:hasCity whose range is an
individual generated from the class mapping cm2. To obtain the exact individual used as range for a given
individual, it is necessary to compute the relative path from the XPath expression used in the class mapping
to the one used in the object property mapping, which is in the op1 example ../city. dp3 means that for
each instance created from the cm1 class mapping, a datatype property tourism:country_name is also
created. Again, it is also necessary to compute the relative path to find the value used to fill the property,
which is for dp3 mapping @name. Four relationships between individuals (corresponding to the two object
property mappings) are also created: two that relates Portugal and Funchal, and other two that relates France
and Paris. Finally, four datatype properties are also created with the names of the cities and countries.
2.2. XML to OWL Mapping: Instances Transformation
Instances of OWL classes are characterized by having unique identifiers. When creating the OWL instances
document, it must be ensured that unique identifiers are generated for each individual. Another important
task is to detect duplicate instances on the XML document. In fact, several XML nodes identified by different
or even by the same XPath expressions may refer to the same individual. Based on their unique identifier,
duplicate instances (so instances with the same ID) must be detected and filtered so that only one instance is
created. By default, the ID of the instances are generated by sequentially concatenating the underscore
symbol ‘_’ with the prefix of the mapped class, with its local name and with the string-value [13] of the
mapped XML node. In section 2.1 we referred to an alternative notation to specify class mappings where the
XML node used to compute the IDs of the generated instances is directly specified. This notation with
triplets allows the detection of duplicated instances even if the default string-value is different because the
comparison is performed according to the XPath expression specified in the class mapping.
The OWL recommendation also places several restrictions on properties. The most important one when
generating the properties of individuals is that OWL does not allow the assignment of duplicates to property
values. As such, it is necessary to filter and eliminate duplicates when creating both the OWL instances and
the properties. But this is not enough since it is also necessary to perform the union of all the distinct property
values mapped as can see in the following example. Putting all this together, let us consider the following
XML document as well as an ontology with the univ:student OWL class which is the domain of the
univ:email datatype property.
Toni Rodrigues
PI:EMAIL
Pedro Rosa
PI:EMAIL
Jorge Cardoso
PI:EMAIL
PI:EMAIL
The following mappings are valid:
• cm1 = (univ:student, /univ/students/student, /univ/students/student/name)
• cm2 = (univ:student, /univ/professors/professor/students/student,
/univ/professors/professor/students/student/@name)
• pm1 = (univ:email, cm1, /univ/students/student/email)
• pm2 = (univ:email, cm2, /univ/professors/professor/students/student/email)
Three student instances are created with the followings IDs: _univToniRodrigues,
_univPedroRosa and _univMarcoSousa. One should note that it may be necessary to encode the
generated IDs into NCNames [14] to ensure their validity. For the student Toni Rodrigues, the duplicate
instance is discarded, that is, only one instance is created since the generated IDs are the same. However, two
univ:email properties must be created, one for PI:EMAIL and one for