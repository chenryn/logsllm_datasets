in S(cid:48). The VMs that have signiﬁcantly larger error scores are
identiﬁed as anomalies. To ﬁnd such scores, Fluorescence
models the error score as a Gaussian distribution. The VMs
3If two ﬁngerprints α and β have the same similarity to the basis in
dimension j, then σ (Λ j,Tα j) = σ (Λ j,Tβ j). Thus Sα j = Sβ j and in S, the
distance between the ﬁngerprints in dimension j is zero. In general, however,
Tα j and Tβ j may not be identical.
x[1]x[2]x[3]x[4]x[5]x[6]z[1]z[2]x'[1]x'[2]x'[3]x'[4]x'[5]x'[6]z[3]OUTPUTINPUTDimension ReductionReconstructionENCODERDECODERUSENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 371that have error scores within an acceptable conﬁdence interval
of this distribution are considered to be normal, and all others
are ﬂagged as anomalous.
The encoder and decoder networks are 1-layer fully con-
nected neural networks having dimensions D× 2 and 2× D,
respectively, where D is the input encoding dimension. For
optimization, we use ADADELTA [45] as the optimizer and
cross-entropy loss as the loss function. The autoencoder
model is trained on the entire input data for 50 epochs, with a
mini-batch size of 2.
2.3.2 Clustering Approach
Fluorescence’s clustering approach to identifying anomalous
VMs uses DBSCAN [11], a density-based algorithm. (Unlike
some other methods, such as k-means, density-based clus-
tering does not require prior knowledge of the number of
(cid:113)
clusters to be formed.) The Euclidean distance d between two
vector rows of S, representing two VMs, is computed in the
(Sα1 − Sβ 1)2 + (Sα2 − Sβ 2)2 +···
usual way: d(α,β ) =
DBSCAN requires two parameters: ε, which is a distance
threshold, and m, which is the minimum number of points
needed to form a cluster. DBSCAN builds a cluster by choos-
ing an unvisited data point, “expanding” toward all of the
neighboring points that are within ε of that point, and then
recursively expanding from each of those neighbors. A point
is marked as an outlier if it is not a member of a cluster that
contains at least m points.
Fluorescence’s goal is for all normal VMs to be contained
in one or more large (many-member) clusters and for anoma-
lous VMs to be either (1) contained in small clusters or
(2) classiﬁed as outliers. To do this, we need to choose appro-
priate values for ε and m.
To illustrate how we choose ε, we performed experiments
in which we deployed herds of similar VMs with some in-
stances infected with malware, measured the distance be-
tween every pair of VMs, and plotted the distances as a CDF.
Figure 3 summarizes six of these experiments: in each, we
deploy 95 normal VMs and ﬁve that are compromised with
one type of malware. Note the “plateau” in the CDF of each
experiment. The slope to the left of the plateau corresponds
to VM-pairs that are near each other and that we would like
to cluster together. The slope to the right corresponds to
VM-pairs where the VMs are far apart, and where we would
like the VMs not to be clustered together. Thus, the plateau
represents the difference between intra-cluster distances and
inter-cluster distances for a given dataset; a good choice of
ε is one that lies near the left edge of the plateau. Based on
our tuning experiments, we set ε to 100. Tuned in this way,
Fluorescence can collect normal VMs into a small number of
clusters—ideally, a single cluster—each with many members.
We set m to three so that DBSCAN will cluster even small
numbers of VMs. This allows Fluorescence to identify clus-
ters of anomalous VMs, e.g., VMs infected by the same
Figure 3: CDFs of all inter-VM distances in six tuning experiments.
Each experiment involves 100 VMs, where ﬁve are infected with a
single kind of malware.
malware (§4.2.2). After clustering, Fluorescence reports all
outliers and all members of small clusters as anomalous.
2.3.3 Discussion
In cases where a small number of VMs are infected with mal-
ware, Fluorescence’s deep-learning and clustering techniques
are likely to identify the same VMs as anomalous, and thus
serve to validate each other. In other circumstances, however,
the two approaches have different strengths and weaknesses.
One advantage of the autoencoder-based approach is that it
does not require one to tune the algorithm by choosing cluster-
ing parameters: the autoencoder simply learns the dominant
patterns in the dataset and can identify the data points that are
most atypical. However, this comes at a cost in three ways.
First, in the common case where no VMs are infected, the
autoencoder may be overly sensitive. If the error scores of all
VMs are small, then the threshold for ﬂagging anomalies is
also small. In these cases, the clusters and intra-VM distances
computed by the clustering method can be used as a sanity
check. Second, in the rare case that many VMs are infected,
the autoencoder may start to become insensitive: it may learn
the patterns of the infected VMs, even if those VMs are in the
minority (say, 10%). In comparison, the clustering method is
less sensitive, and can be accurate even when the number of
infected VMs is high, as long as the uninfected VMs consti-
tute the largest cluster. Third, while the autoencoder method
can detect anomalies, it cannot report which anomalies are
similar to each other. DBSCAN, of course, can compute
clusters among the anomalous VMs.
The main shortcoming of the clustering approach is that
the threshold for building clusters, ε, may be too “generous.”
If the data points for normal VMs are actually much closer to
each other than ε, then a poor choice of ε means that anoma-
lous VMs that are nevertheless “within ε” will be classiﬁed
as normal by DBSCAN. In contrast, in this situation, the au-
toencoder would essentially learn the threshold automatically.
Similarly, consider a situation in which there are two types of
VMs (e.g., two different kernels) that are similar, and the data
points of these two types form “overlapping” regions when
0100200300400Inter-VM distance0.00.51.0PercentageWin32/GapzPitouRovnixTDL3ZeroAccessTDL4372          22nd International Symposium on Research in Attacks, Intrusions and DefensesUSENIX AssociationImplementation
measured in S. DBSCAN may group instances of these VMs
into a single cluster and thereby obscure small anomalies
in each type. Conversely, the autoencoder could potentially
differentiate between the types and identify anomalous VMs
at a ﬁner grain.
3
Fluorescence depends on its ﬁngerprinting agents (§2.1) to
(1) “snapshot” the kernel code pages within all of the mon-
itored VMs and (2) perform normalization, so that benign
differences do not mask actual anomalies. This section pro-
vides implementation detail about how the agent performs
these tasks. The agent requires some kernel- and architecture-
speciﬁc knowledge to carry out these tasks; our implemen-
tation works with VM guests that run Linux (3.13–4.15) or
Windows 7 kernels for x64 within VMs managed by Xen 4.9.
The agent is implemented in C and uses libVMI [31] to man-
age and access the monitored VMs.
3.1 Walking the Page Table
To obtain all of the executable pages from the kernel of a
VM guest, the Fluorescence agent performs a breadth-ﬁrst
traversal of a page table, starting from the KPGD. Since
hypervisors typically maintain a KPGD for each VM, the
KPGD can be easily accessed through VMI libraries. (The
kernel-speciﬁc knowledge about the location of the KPGD
is encapsulated within libVMI.) Using knowledge of x86 64
page tables, it is straightforward for Fluorescence to ﬁnd all
of the kernel code pages.
In practice, ensuring that the kernel code pages are in mem-
ory is a concern. As previously described (§2.1.1), some ker-
nels can swap their own code pages to external storage, where
they are not easily accessible through VMI. In particular,
we found that Windows 7 swaps its own code pages aggres-
sively: if a page is not used for long time, Windows may
move the page to external storage or mark it as “in transition”
(another kind of invalid page table entry). If the Fluorescence
agent encounters such a page, the resulting ﬁngerprint will be
incomplete, possibly leading to spurious anomaly reports.
To avoid problems caused by swapped-out pages, Fluo-
rescence invokes a tool on VMs running Windows, prior to
taking a ﬁngerprint, that pins all of the guest kernel’s code
pages into memory. Fluorescence uses DRAKVUF [23] for
this purpose. DRAKVUF is a system, built atop libVMI, that
enables one to hijack a process to run an injected executable.
Fluorescence injects code into the winlogon process, which
is a privileged process present on every Windows machine,
that loads and runs a kernel module that pins the kernel’s
executable pages. The Fluorescence agent does this before
each ﬁngerprint of a Windows guest, in order to catch any
pages that might have been injected since the VM was last
ﬁngerprinted. We did not develop a similar page-pinning tool
for Linux guests, because none of the Linux kernels we used
ever swapped any of their code pages out.
3.2 Normalizing Code-Page Content
When a kernel is loaded into memory, the loader patches code
pages to replace symbolic references (to code or data) with
the actual addresses of the things being referenced. Due to
ASLR and other factors, when the same kernel is loaded into
two different VMs, the loaded copies of the kernel will be
patched with different addresses (§2.1.2).
Normalization aims to reduce these differences by replac-
ing patched addresses with constants, in a way that is consis-
tent across all of the VMs. One can think of this as undoing
the patching, replacing all resolved references with symbolic
ones. Consider an original (unloaded) code page P. In every
loaded copy of P, every patched reference to a function f
should be replaced with a constant that represents f —the
same constant in all copies of P. To preserve as much infor-
mation as possible in the normalized pages, a “mostly unique”
constant should be used for each referent: e.g., if a page refers
to two functions f and g, the constants chosen to represent
references to f and g should be different.
To perform this replacement, the Fluorescence agent must
solve two problems. It must determine the constants it will use
to replace patched references, and it must ﬁnd the references.
Determine the constants. To ﬁnd constants in a consistent
way across all of the protected VMs, Fluorescence leverages
the fact that a kernel image consists of many loaded “objects”
(i.e., object ﬁles). A single object generally deﬁnes many
functions and variables, and these things appear at different
offsets within the loaded object. ASLR may randomly arrange
the objects in the kernel’s memory, but it does not rearrange
the contents inside the objects. The offset of a function or
variable within its containing object is thus constant across all
of the kernels that have loaded that object. Fluorescence uses
these constants to normalize loaded pages: given a resolved
reference to a function or variable f , it replaces that reference
with the byte offset of f within the object that contains f .
More speciﬁcally, Fluorescence divides the address space
of a kernel into a number of 4 KB-page-aligned regions of
virtually contiguous memory. (Certain address ranges are
excluded, based on knowledge of how kernels use their ad-
dress spaces: e.g., the “direct mapping” region in Linux, and
the system cache region in Windows, are excluded.) Fluores-
cence makes regions that correspond to the kernel’s loaded
objects by searching for objects in the appropriate area of
the kernel’s address space. For Windows, the search is easy:
the Portable Executable (PE) header value “MZ” appears at
the start of each loaded object. For Linux, the search is also
straightforward. Although ELF headers are not present in
memory, loaded ELF objects follow a common pattern: a se-
ries of executable (code) pages, followed by some read-only
(data) pages, and then by some writable (data) pages. Using
these patterns, it is simple to create regions that correspond
to the kernel’s loaded objects.
After making regions for objects, Fluorescence creates re-
USENIX Association        22nd International Symposium on Research in Attacks, Intrusions and Defenses 373gions that cover the remainder of the kernel’s address space
(with some exceptions as previously noted). Whenever a nor-
malization function wants to replace a resolved reference with
a constant, Fluorescence determines the region that the refer-
ence points into. It replaces the reference with the difference
between the referenced address and the region’s start.
Find the references. Our implemented Fluorescence
agent can provide up to three normalized versions, a.k.a. fea-
ture views (§2.1.2), of every kernel code page. The ﬁrst is the
page content just as it appears in the VM, or the original view.
If a page is not modiﬁed at all by the kernel loader, than all
of the copies of that page will be identical in this view. The
second feature view, called sub-base, and the third, called
disassembly, both modify the original page content by heuris-
tically searching for resolved references and then replacing
those references with constants as described above. The sub-
base and disassembly views differ in how they attempt to ﬁnd
resolved references within the code.
The sub-base view is simple, treating the input page as
an array of eight-byte elements. The sub-base normalization
function examines each element: if the value of an element
can be interpreted as an address that falls within a deﬁned re-
gion, that element is replaced by a constant (i.e., the difference
between the element value and the referenced region’s start).
This heuristic is very fast, correctly transforms constructs like
jump tables that are eight-byte aligned, and “works” because
the 64-bit address space is sparsely ﬁlled. In general, however,
the sub-base method may overlook many resolved references
(e.g., those that are not eight-byte aligned) and may modify
values that are not actually addresses.
The disassembly view attempts to address the shortcomings
of the sub-base view. Given a code page, the disassembly
normalization function uses Capstone [33] to interpret the
code found on the page. It searches the disassembled code for
operands that appear to be (64-bit) absolute addresses and (32-
bit) PC-relative addresses. Whenever one of these appears
to point into a deﬁned region, the normalization function re-
places the address with the appropriate constant as described
above. The disassembly view is often more precise than the
sub-base view, but it is still heuristic; in our experience, it is
still subject to false positives (incorrect modiﬁcations) and
false negatives (overlooked references). This is why Fluo-
rescence relies on multiple feature views of each code page: