### 8. 实际考虑
在本节中，我们将简要讨论资源、优先级约束以及周期性和非周期性线程的问题。

#### 8.1 资源
本文未对由于资源限制导致的阻塞进行全面研究。我们仅探讨了我们的对策对因资源阻塞的线程的影响，而不考虑由资源分配引起的非法信息流问题。

在第7.2节中，我们讨论了非抢占式临界区的解决方案。这里我们关注的是资源持有者或临界区可以被抢占的情况。当资源持有者在其执行过程中可以被抢占时，高优先级线程可能无法立即锁定该资源。在这种情况下，高优先级线程 τh 可以挂起自身，给低优先级资源持有者 τl 释放资源的机会。如图7所示，这种机制可以减少高优先级线程的等待时间。

![图8: 支持抢占的多处理器锁](图8: 支持抢占的多处理器锁)

#### 8.2 优先级约束
在一个实际系统中，线程通常不是独立的，因为它们依赖于其他线程生成的结果。这些依赖关系通常通过一个优先级图来表示，该图指明了哪些线程必须在某个线程之前完成，才能合理地调度后者。

本文不考虑动态依赖关系，例如请求资源时产生的依赖关系。然而，数据依赖关系可以通过静态计算得出。我们利用有效释放时间，并以略微不同的方式计算，只有当所有依赖的线程都生成了结果后，才激活线程 τ。

因此，线程 τ 的有效释放时间设置为其所依赖线程的最晚响应时间。图9说明了这一过程。

![图9: 根据优先级约束调整有效释放时间](图9: 根据优先级约束调整有效释放时间)

由于优先级约束是公开信息，并且响应时间是基于最坏情况下的执行和阻塞时间计算的，因此调整后的调度不会泄露额外的信息。

#### 8.3 周期性和非周期性线程
Sporadic服务器和可延迟服务器 [15] 是提高周期性和非周期性线程响应时间的手段。这些线程具有变化的周期长度或软时限或无时限。准入控制将这些服务器视为普通的实时线程进行规划。然后，调度器利用为这些服务器规划的时间和优先级，在这些线程到达后执行它们。

如果周期性或非周期性线程的到达可以被视为公开信息，我们可以将Sporadic服务器或可延迟服务器视为直到相应的周期性或非周期性线程到达时才开始执行的线程。这个事件是服务器的第一个释放点。因此，只有在这个释放点之后才需要考虑这些服务器的预算。

服务器继承了到达线程的信息流属性，如果相应的谓词对到达线程成立，则应用对策。通常情况下，我们事先不知道到达线程是否满足对策谓词，因此准入控制必须将服务器视为潜在的泄露源。或者，可以在为可能泄露和不泄露的线程预留不同的可延迟服务器时动态做出这一决定。

同样的论点也适用于在即将开始执行前被挂起的线程（例如，当它们等待外部事件时）。如果这些事件的发生是公开信息，我们不必在这部分自挂起时间内切换到空闲线程。相反，我们将这些服务器的释放点调整到事件到达的时间。

Sporadic或可延迟服务器可以用于实现动态线程创建，通过将创建的线程作为这些服务器的有效负载来执行。

### 9. 相关工作
先前已有许多研究解决了调度隐蔽通道问题。首先，我们将详细讨论那些通过修改系统调度器来关闭或缓解这一通道的相关方法。然后，我们将简要概述防止线程通过其外部定时行为泄露信息的替代方法。

#### 9.1 通过修改调度器的方法
Son等人 [25] 分析了速率单调调度对隐蔽定时通道的影响。作者形式化并分类了与RM调度相关的隐蔽定时通道，并得出结论：RM通道是正向可推断的，这意味着在某些设置下，隐蔽定时通道无法关闭。此外，他们还提出了一种衡量该通道容量的方法。我们的方法通过强制潜在的发送者进入最坏情况的行为来关闭这一定时通道。

时间分区系统 [10]，如ARINC 653标准 [1] 所定义的那样，为每个线程分配一个分区，并在各自的分区处于活动状态时分层调度线程。分区本身根据离线计算的时钟驱动调度进行调度。时间分区系统是安全的，因为它们防止不同分区中的线程相互影响其定时行为。

在第7.1节中，我们确定了一些情况下，我们的方法可以接受更多的线程集。此外，对于非实时线程，我们的方法实现了更高的性能，因为只有那些可能泄露信息的线程才需要受到限制。在未经授权的信息流仅从低优先级流向高优先级线程的特殊情况下，我们的方法不会对系统施加任何限制。

Hu [6] 提出了晶格调度器，以最小化需要采取对策（例如，缓存刷新）的时间。晶格调度器为每个安全级别分配一个时间分区（称为时间槽），并在相应的时间槽处于活动状态时分层调度该安全级别的线程。与传统的时间分区系统不同，晶格调度器允许高安全级别的线程消耗当前时间槽的剩余时间。如果当前时间槽中所有线程提前停止，晶格调度器会选择更高安全级别的线程来消耗剩余时间。没有信息泄露，因为只有高安全级别的线程在低安全级别线程提前停止时才会被激活。晶格调度器继承了大多数时间分区调度器的实时特性。然而，由于高安全级别的线程可以消耗提前停止线程的剩余时间，它通常可以接受更多的线程集。与我们的解决方案不同，线程执行中途的阻塞时间不能被不同安全级别的线程消耗。

Boucher等人 [2] 提出了一种尽力而为的调度器，根据线程的时间价值函数选择线程。该函数描述了在特定时间点调度线程的价值。此外，调度器连续测量隐蔽通道带宽，当带宽达到某个阈值时，切换到类似于晶格调度的方案。控制策略可以通过动态调整阈值来权衡隐蔽通道带宽和实时性能，当重要的实时线程面临错过截止时间的风险时。与我们的方法相比，主要区别在于实时准入控制必须考虑隐蔽通道带宽是否达到阈值。他们的方法比我们的方法有更高的开销，因为他们需要在线评估信息流策略。使用静态谓词使我们免除了这一需求。

#### 9.2 其他防止信息泄露的方法
其他防止线程通过外部定时行为变化泄露信息的方法包括模糊时间 [5] 和安全类型系统。

Hu等人 [5] 向时间源和事件传递添加噪声。缺乏精确的时间源使得通过改变线程的定时行为来传递信息变得更加困难。如前所述，模糊时间只能缓解而不是完全关闭定时通道。此外，实时线程需要一定程度的精确定时。

大量工作研究了类型系统，这些系统确保在特定类别的调度器（例如，统一调度器 [24] 或概率调度器 [22]）下运行的程序的机密性，或者独立于底层调度器的程序机密性 [22]。

Russo等人 [21] 提出了一种类型系统，允许线程向调度器发出信号，指示只应调度相同安全级别的线程。该类型系统确保了在非干扰调度器上运行的多线程程序的机密性，即使这些线程是动态创建的。这些作者的一篇较新的论文 [20] 描述了一种转换，将单线程程序转换为多线程程序，使得每个线程只分配给单一安全级别的变量。他们展示了在轮询调度器下执行这些线程时，这种转换建立了针对晶格低≤高的非干扰性。这项工作不涉及实时性问题。

### 致谢
感谢Hendrik Tews、Michael Roitsch和匿名评审员的意见和建议，帮助我们改进了这篇论文。我们还要感谢Intel公司的支持。这项工作得到了欧洲委员会PASR拨款004700的部分资助。

### 10. 结论
我们研究了通过线程调度相关行为的变化而导致的非法信息流，并提出了一种简单的对策来关闭这些通道。预算强制的固定优先级调度器经过修改，对待可能泄露信息的活跃线程（阻塞或提前停止）如同它们是就绪的一样。虽然这增加了系统的空闲时间，但信息不再可以通过调度子系统泄露，并且一些线程的行为与其他线程隔离。

我们通过最低优先级线程的禁止时间 bidle(pr) 来量化增加的空闲时间。因为禁止时间是一个额外的阻塞因素，我们展示了如何重用现有的准入测试来确定给定线程集的可调度性。与原始的、未经修改的测试相比，我们实现的利用率是：

\[ U = U_{\text{orig}} - \frac{b_{\text{idle}}(pr)}{\Pi_{\text{idle}}} \]

我们基于静态谓词来决定何时应用我们的对策，因此我们的方法引入的额外调度开销可以忽略不计。

未来，我们计划正式证明一个因不可抢占性而阻塞的系统的非干扰性。未来的研究方向还包括动态优先级实时调度器、资源管理和通过更宽松的谓词减少系统空闲时间。

### 11. 参考文献
[略]

希望优化后的文本更加清晰、连贯和专业。如果有进一步的修改需求，请告诉我！