scheduler performs no worse compared to an admission for a
classical scheduler as far as blocking due to nonpreemptibil-
ity is concerned.
8. PRACTICAL CONSIDERATIONS
In the following, we shortly address resources, precedence
constraints as well as aperiodic and sporadic threads.
8.1 Resources
A complete investigation of blocking due to resource lim-
itations is out of the scope of this paper. We only investi-
gate the consequences of our countermeasure on threads that
block on a resource. We do not consider illegal information
ﬂow due to the resource allocation.
In Section 7.2 we discussed a solution for nonpreemptible
critical sections. Here we focus on situations where the
holder of a resource or critical section can be preempted.
When resource holders can be preempted in their execu-
tion, higher prioritised threads may fail to immediately lock
the resource. In this situation, a higher prioritised thread τh
can suspend itself to give the low-priority resource holder τl
the chance to free this resource. As shown in Figure 7, this
Figure 8: A preemption-aware multiprocessor lock.
8.2 Precedence Constraints
In a practical system, threads are usually not independent
from each other, because they rely on the results produced
by other threads. These dependencies are typically denoted
by a precedence graph which states which threads must com-
plete before a later thread in the directed graph can sensibly
be scheduled.
Considering dynamic dependencies, as they arise for ex-
ample when requesting resources, is out of the scope of this
paper. However, precedence due to data dependencies can
be computed statically. We exploit eﬀective release times
which we compute in a slightly diﬀerent way and activate
a thread τ only after all those threads have produced their
results on which τ depends.
The eﬀective release time of a thread τ is therefore set to
the latest response time of the threads on which τ depends.
Figure 9 illustrates this procedure.
timetime R R R RidlepriorityprioritylhlhττττlockunlockCPU 1CPU 0max delaypreemptionRRtimepriorityl1l0h0h1ττττtiming behaviour.
Son et al. [25] analyse the impact of rate-monotonic sched-
uling on covert timing channels. The authors formalise and
classify covert timing channels inherent with RM schedul-
ing. They conclude the RM-channel to be positive deducible,
which means in some settings the covert timing channel can-
not be closed. Furthermore, they present a measure for the
capacity of this channel. Our approach closes this timing
channel by forcing the possibly leaking senders into their
worst-case behaviour.
Time-partitioned systems [10], as deﬁned for example in
the Arinc 653 standard [1], assign each thread a partition
and schedule threads hierarchically when their respective
partition is active. The partitions themselves are sched-
uled according to an oﬀ-line-computed clock-driven sched-
ule. Time-partitioned systems are noninterference secure
because they prevent threads in diﬀerent partitions aﬀect-
ing each other’s timing.
In Section 7.1 we identify cases
in which an admission for our approach can accept more
thread sets.
In addition we achieve a higher performance
for nonreal-time threads because only those threads have to
be restricted that could possibly leak information.
In the
special situation when unauthorised information ﬂows are
only from lower to higher prioritised threads, our approach
leaves the system unrestricted.
Hu [6] proposes the lattice scheduler to minimise the times
when countermeasures (e.g., cache ﬂushing) have to be ap-
plied. The lattice scheduler allocates for each security class a
time partition (called time slot) and schedules threads of this
security class hierarchically whenever the respective time
slot is active. In contrast to a traditional time-partitioned
system, the lattice scheduler allows higher classiﬁed threads
to consume part of the remaining in a time slot. In the case
when all threads of the security class that was active in the
current time slot have stopped early, the lattice scheduler se-
lects a higher security class to consume the remaining time
in this slot. No information is leaked because only higher
classiﬁed threads are activated when lower classiﬁed threads
stop early. The lattice scheduler inherits most of its real-
time properties from time-partitioning schedulers. However,
because higher classiﬁed threads may consume the remain-
ing time of early stopped threads it may in general accept
more thread sets. In contrast to our solution, blocking times
in the middle of a thread’s execution cannot be consumed
by threads of a diﬀerent security class.
Boucher et al. [2] propose a best-eﬀort scheduler that se-
lects threads according to their time-value function. This
function describes how valuable it is to schedule the thread
at a given point in time. In addition, the scheduler contin-
uously measures covert-channel bandwidth and when this
bandwidth reaches a certain threshold, it switches to a
scheme similar to lattice scheduling. A control policy can
then trade covert-channel bandwidth against real-time per-
formance by dynamically adjusting this threshold when an
important real-time thread risks missing its deadline. The
main diﬀerence compared with our approach is that the
real-time admission must be changed to take into account
when the covert-channel bandwidth has reached the thresh-
old. Their approach has a considerably higher overhead than
ours because they have to evaluate the information-ﬂow pol-
icy online. The use of static predicates relieve us from this
necessity.
Other approaches to prevent information leakage caused
Figure 9: Adjustment of eﬀective release times to
reﬂect precedence constraints.
Because the precedence constraints are public informa-
tion and because the response times are computed based
on worst-case execution and blocking times, the resulting
adjusted schedule reveals no additional information.
8.3 Aperiodic and Sporadic Threads
Sporadic servers and deferrable servers [15] are means to
increase the response time of sporadic and aperiodic threads.
These are threads which have varying period lengths respec-
tively soft or no deadlines. The admission plans these servers
as normal real-time threads. The scheduler then exploits the
time and priority planned for these servers to execute spo-
radic and aperiodic threads after they have arrived.
If the arrival of a sporadic or aperiodic thread can be
considered as public information, we can treat the sporadic
server or the deferrable server as a thread that does not ex-
ecute until a respective sporadic or aperiodic thread arrives.
This event is the server’s ﬁrst release point. Consequently,
the budgets of these servers need to be considered only after
this release point.
The server inherits the information ﬂow properties of the
arrived thread and we apply the countermeasure if the re-
spective predicate holds for the arrived thread. Because, in
general, we do not know in advance whether the countermea-
sure predicate holds for the arriving thread, the admission
has to treat the server as potentially leaking. Alternatively
this decision can be made dynamically when reserving dis-
tinct deferrable servers for possibly leaking and not leaking
threads.
The same line of arguments holds for threads that are
suspended right before they start execution (e.g., when they
await an external event).
If occurrence of these events is
public information, we need not to switch to the idle thread
for this portion of the self-suspension time.
Instead we
adjust the release point of these servers to the point in time
at which the event arrives.
Sporadic or deferrable servers can be used to implement
dynamic thread creation by executing the created threads
as payload of these servers.
9. RELATED WORK
The scheduling covert channel has been addressed previ-
ously. We ﬁrst elaborate on related approaches which mod-
ify the system scheduler to close or to mitigate this chan-
nel. Then we brieﬂy sketch alternative approaches to pre-
vent threads from leaking information through their external
precedence:actual release time :effective release time :timepriorityllhhττττby variations in a thread’s external timing behaviour include
fuzzy time [5] and security type systems.
Hu et al. [5] adds noise to timing sources and event deliv-
ery. Lacking a precise timing source it becomes more diﬃcult
to signal information by varying the timing behaviour of a
thread. As illustrated beforehand, fuzzy time cannot close
but only mitigate timing channels. Furthermore, real-time
threads require some degree of precise timing.
A large body of work investigates type systems that as-
sert conﬁdentiality for a program that is scheduled under a
speciﬁc class of schedulers (e.g., uniform [24] or probabilistic
schedulers [22]) or that assert program conﬁdentiality inde-
pendent of the underlying scheduler [22].
Among these Russo et al. [21] propose a type system
that allows threads to signal to the scheduler when only
threads of the same security class should be scheduled. This
type system asserts conﬁdentiality of a multithreaded pro-
gram with dynamically created threads running on top of
a noninterferent scheduler. A more recent paper of these
authors [20] describes a transformation in which a single
threaded program is transformed into a multithreaded pro-
gram such that each thread assigns only to variables of a
single security class. They show that this transformation
establishes noninterference for the lattice low ≤ high when
executing the threads under a round-robin scheduler. Real-
time was no concern in this work.
Acknowledgements
Thanks are due to Hendrik Tews, Michael Roitsch and to
the anonymous reviewers for their comments and advices
that helped us improve this paper. We further thank Intel
Corp. for their support. This work is in part funded by the
European Commission through PASR grant 004700.
10. CONCLUSIONS
We investigated illegal information ﬂows through the
scheduling subsystem by alterations in the scheduling re-
lated behaviour of threads and propose a rather simple coun-
termeasure that closes these channels. A budget-enforcing
ﬁxed-priority scheduler is modiﬁed to treat active threads
that block or that stop early and that could potentially leak
information as if they were ready. While this increases the
system’s idle time, information can no longer be leaked via
the scheduling subsystem and some threads become timely
isolated from the behaviour of others.
We quantify the increase in idle time by the prohibition
time of the lowest-prioritised thread bidle(pr). Because the
prohibition time is an additional blocking factor, we showed
how to reuse existing admission tests to determine the sched-
ulablity of a given thread set. The utilisation we achieve
compared to the respective original, unmodiﬁed test is
U = Uorig − bidle(pr)
.
Πidle
The decision when to apply our countermeasure we base
on a static predicate. Thus, the additional scheduling over-
head introduced with our approach is negligible.
In the near future, we plan to formally prove noninterfer-
ence for a system with blocking due to nonpreemptibility.
Additional directions of future research include dynamic-
priority real-time schedulers, resources and reduction of
system idle times due to less restrictive predicates.
11. REFERENCES
[1] ARINC. ARINC 653-1 Standard.
[2] P. Boucher, R. Clark, I. Greenberg, D. Jensen, and
D. Wells. Towards a multilevel-secure, best-eﬀort
real-time scheduler. In 4th IFIP Working Conference
on Dependable Computing for Critical Applications,
San Diego, CA, USA, Jan 1994.
[3] U. Dannowski, J. LeVasseur, E. Skoglund, and
V. Uhlig. L4 eXperimental Kernel Reference Manual,
Version X.2. Technical report, University of
Karlsruhe, 2004. Latest version available from:
http://l4hq.org/docs/manuals/.
[4] Z. Deng and J. Liu. Scheduling real-time applications
in an open environment. In Proceedings of the IEEE
Real-Time Systems Symposium, pages 308–319, Dec.
1997.
[5] W. Hu. Reducing timing channels with fuzzy time. In
IEEE Computer Society Symposium on Research in
Security and Privacy, Oakland, CA, USA, May 1991.
[6] W. Hu. Lattice Scheduling and Covert Channels. In
IEEE Symposium on Security and Privacy,
Washington, DC, USA, 1992.
[7] H. H¨artig, M. Hohmuth, N. Feske, C. Helmuth,
A. Lackorzynski, F. Mehnert, and M. Peter. The
Nizza Secure-System Architecture. In First
International Conference on Collaborative Computing:
Networking, Applications and Worksharing, San Jose,
California, USA, Dec. 2005.
[8] M. Kang and I. Moskowitz. A Pump for Rapid,
Reliable, Secure Communication. In ACM Conference
on Computer and Communication Security, pages 119
– 129, Nov 1993.
[9] L. Kontothanassis, R. Wisniewski, and M. Scott.
Scheduler Conscious Synchronization. ACM
Transactions on Computer Systems, Feb. 1997.
[10] H. Kopetz. The time-triggered architecture. In
ISORC, 1998.
[11] J. Lehoczky, L. Sha, and Y. Ding. The rate-monotonic
scheduling algorithm: Exact characterization and
average case behaviour. In Real-Time Systems
Symposium, pages 166–171, Dec 1989.
[12] J. P. Lehoczky, L. Sha, and Y. Ding. The
rate-monotonic scheduling algorithm: Exact
characterization and average case behavior. In
Real-Time Systems Symposium, pages 166–171, Dec
1989.
[13] J. Liedtke. On µ-kernel construction. In Proceedings of
the 15th ACM Symposium on Operating System
Principles (SOSP), pages 237–250, Copper Mountain
Resort, CO, Dec. 1995.
[14] C. L. Liu and J. W. Layland. Scheduling Algorithms
for Multiprogramming in an Hard-Real-Time
Environment. Journal of the ACM, 20.1:46–61, Jan
1973.
[15] J. W. S. Liu. Real-Time Systems. Prentice Hall, 2000.
[16] Lynuxworks. Lynxos: Partitioning operating systems
vs. process-based operating systems.
http://www.lynuxworks.com/products/
whitepapers/partition.php.
[17] S. Owre, J. M. Rushby, , and N. Shankar. PVS: A
prototype veriﬁcation system. In D. Kapur, editor,
11th International Conference on Automated
Deduction (CADE), volume 607 of Lecture Notes in
Artiﬁcial Intelligence, pages 748–752, Saratoga, NY,
June 1992. Springer-Verlag.
[18] J. Regehr and J. A. Stankovic. HLS: A framework for
composing soft real-time schedulers. In RTSS ’01:
Proceedings of the 22nd IEEE Real-Time Systems
Symposium (RTSS’01), Washington, DC, USA, 2001.
IEEE Computer Society.
[19] J. Rushby. Noninterference, transitivity, and
channel-control security policies. Technical Report
CSL-92-2, Stanford Research Institute, 1992.
[20] A. Russo, J. Hughes, D. Naumann, and A. Sabelfeld.
Closing itnernal timing channels by transformation. In
ACM Symposium on Information, Computer and
Communications Security (ASIACCS’06), 2006.
[21] A. Russo and A. Sabelfeld. Securing interaction
between threads and the scheduler. In 19th IEEE
Computer Security Foundations Workshop, Venice,
Italy, July 2006.
[22] A. Sabelfeld and D. Sands. Probabilistic
noninterference for multi-threaded programs. In
CSFW ’00: Proceedings of the 13th IEEE Computer
Security Foundations Workshop (CSFW’00),
Washington, DC, USA, 2000. IEEE Computer Society.
[23] L. Sha, R. Rajkumar, and J. Lehoczky. Priority
Inheritance Protocols: An Approach to Real-Time
Synchronisation. IEEE Transaction on Computers, 39,
1990.
[24] G. Smith and D. Volpano. Secure information ﬂow in
a multi-threaded imperative language. In POPL ’98:
Proceedings of the 25th ACM SIGPLAN-SIGACT
symposium on Principles of programming languages,
San Diego, California, United States, 1998.
[25] J. Son and J. Alves-Foss. Covert timing channel
analysis of rate monotonic real-time scheduling
algorithm in mls systems. In 7th Annual IEEE
Information Assurance Workshop, West Point, NY,
USA, June 2006.
[26] M. V¨olp, C. J. Hamann, and H. H¨artig. Avoiding
Timing Channels in Fixed-Priority Schedulers - PVS
Sources. available from http://os.inf.tu-
dresden.de/˜voelp/sources/sec rt trans.tgz.