### Optimized Text

**Honest Client and Key Authentication:**
If the client is honest, authenticated, and not compromised, or if the key share \( g^{x} \) accepted by the server was generated by the client, then the client must have accepted a session with the server. Both parties must agree on the established keys and all messages sent during the protocol. This property is stated as a CryptoVerif query and verified.

**Replay Prevention:**
The authentication properties mentioned above are injective, meaning each session of the client (or server) corresponds to a distinct session of the server (or client). This prevents replay attacks.

**Forward Secrecy of Keys:**
The keys \( \text{ats}_c \), \( \text{ats}_s \), \( \text{ems} \), and \( \text{psk} \) exchanged in multiple protocol sessions are indistinguishable from independent fresh random values. This means that even if \( \text{ats}_c \), \( \text{ats}_s \), and \( \text{ems} \) are given to the adversary, the keys remain secret. On the client side, secrecy holds when the server is not compromised before the end of the session. On the server side, secrecy holds when the client is authenticated and not compromised before the end of the session, or when the key share \( g^{x} \) used by the server comes from the client. We prove the secrecy of \( \text{ats}_c \), \( \text{ats}_s \), and \( \text{ems} \) on the server side as soon as the server sends its Finished message. This property allows us to prove the security of 0.5-RTT messages by composition with the record protocol.

**Unique Channel Identifier:**
When \( \text{cid} \) is \( \text{psk} \) or \( H(\log 7) \), the result is immediate: if a client session and a server session have the same \( \text{cid} \), then they have the same \( \log 7 \) due to the collision-resistance of \( H \) (which implies collision-resistance of HMAC-H). Therefore, all their parameters are equal. When \( \text{cid} \) is \( \text{ems} \), collision-resistance ensures that the client and server sessions have the same \( \log 4 \). CryptoVerif proves that if both sessions terminate successfully with the same \( \log 4 \), they have the same \( \log 7 \) and the same keys, making all their parameters equal.

**Verification Steps:**
To prove these properties, we follow these main steps:
1. Apply the security of the signature under the server key \( \text{sk}_S \).
2. Introduce tests to distinguish cases based on whether the Difﬁe-Hellman share received by the server is from the client, and whether the Difﬁe-Hellman share received by the client is from the server.
3. Apply the random oracle assumption on \( x \mapsto \text{HMAC-H}_{\text{kdf}_0}(x) \), replace variables containing \( g^{xy} \) with their values, and apply the gap Difﬁe-Hellman assumption.
4. At this point, the handshake secret \( \text{hs} \) is a fresh random value. Use the properties of the key schedule to show that other keys are fresh random values, and apply the security of the MAC and the signature under the client key \( \text{sk}_C \).

**Handshakes with Pre-Shared Keys:**
We analyze the handshake protocol in Figure 4, starting with 0-RTT and continuing to 1-RTT. We consider both variants of PSK-based 1-RTT, with and without Difﬁe-Hellman exchange. We ignore the ticket \( \text{enckt(psk)} \) and assume an honest client and server initially sharing the pre-shared key \( \text{psk} \). Dishonest clients and servers may be part of the adversary. As in the previous section, we give the handshake keys to the adversary and ignore handshake encryption. Certificates for the client and server are optional since they are already authenticated via the \( \text{psk} \); we do not rely on authentication in our proofs and consider that the adversary performs the signature and verification operations on certificates if they occur.

**Outputs and Verification Results:**
- **Key Authentication:** CryptoVerif shows the same authentication properties as for the handshake without a pre-shared key, assuming both participants are uncompromised. However, CryptoVerif cannot prove the authentication of \( \text{ets}_c \) because the client may offer several pre-shared keys and send a binder for each. Only the binder for the pre-shared key selected by the server is checked, allowing the adversary to alter another proposed binder, yielding a different \( \log 1 \) and \( \text{ets}_c \) on the server side. This is not a serious attack as the record protocol will fail if \( \text{ets}_c \) does not match on both sides.
- **Replay Prevention:** CryptoVerif proves the absence of replays for \( \text{ats}_c \), \( \text{ats}_s \), and \( \text{ems} \). However, it cannot prove replay protection for the 0-RTT session key \( \text{ets}_c \), as the client's ClientHello message can be replayed, resulting in the same key \( \text{ets}_c \) for multiple server sessions.
- **Secrecy of Keys:** The keys \( \text{ets}_c \), \( \text{ats}_c \), \( \text{ats}_s \), \( \text{ems} \), and \( \text{psk} \) are indistinguishable from independent fresh random values. Secrecy holds on both the client and server sides, except for \( \text{ets}_c \) on the server side, which can be forced to accept the same key multiple times by replaying the client's ClientHello message. We prove the secrecy of \( \text{ats}_c \), \( \text{ats}_s \), and \( \text{ems} \) on the server side as soon as the server sends its Finished message.
- **Forward Secrecy:** CryptoVerif cannot prove the secrecy of the keys when \( \text{psk} \) is compromised after the session, even assuming \( \text{hkdf-extract} \) is a random oracle. Secrecy does not hold for the handshake without Difﬁe-Hellman exchange. We believe it still holds for the handshake with Difﬁe-Hellman exchange, but our failure to prove it is due to the current limitations of CryptoVerif.
- **Unique Channel Identifier:** If a client session and a server session have the same \( \log 7 \), they have the same \( \text{psk} \) due to the collision-resistance of \( \text{mac} = \text{HMAC-H} \), ensuring the same \( \text{kb} \), \( \text{es} \), and \( \text{psk} \).

**Record Protocol:**
The third component of TLS 1.3 is the record protocol, which encrypts and decrypts messages after the new client and server sessions are established. In our model, we assume the client and server share a fresh random traffic secret. We generate an encryption key and an initialization vector (IV), and use them to send and receive encrypted messages with a counter distinct for each message. We also generate a new traffic secret as specified in the key update mechanism of TLS 1.3 Draft-18. CryptoVerif proves the following properties automatically:
- **Key and Message Secrecy:** The updated traffic secret is indistinguishable from a fresh random value. The adversary cannot determine which set of plaintexts is encrypted, even if the updated traffic secret is leaked.
- **Message Authentication:** If a message \( m \) is decrypted by the receiver with a counter \( c \), then the message \( m \) was encrypted and sent by an honest sender with the same counter \( c \).
- **Replay Prevention:** The authentication property is injective, meaning any sent application data can be accepted at most once by the receiver.

**Composite Proof for TLS 1.3 Draft-18:**
We compose these results using a hybrid argument. First, we use the secrecy property of the initial handshake to replace all session keys with independent fresh random values. We rely on authentication and replay prevention to ensure the same replacement in matching sessions of the client and server. Then, we use the security properties of the record protocol to obtain secrecy, forward secrecy, authentication, and replay prevention for application messages in both directions. Using the key \( \text{psk} \) provided by the initial handshake, we apply the security of the PSK-based handshake to show that the keys \( \text{ets}_c \), \( \text{ats}_c \), \( \text{ats}_s \), and \( \text{psk} \) are independent fresh random values. We then apply the security of the record protocol to \( \text{ats}_c \) and \( \text{ats}_s \) for 1-RTT messages and to \( \text{ets}_c \) for 0-RTT messages, though the handshake does not prevent replays for \( \text{ets}_c \). Finally, we apply the security of the PSK-based handshake again to the newly obtained \( \text{psk} \), achieving composite security for arbitrary sequences of PSK-based resumptions.

**RefTLS: A Reference TLS 1.3 Implementation with a Verified Protocol Core:**
In today’s web ecosystem, TLS is widely used by various client and server applications to establish secure channels across the Internet. For example, Node.js servers written in JavaScript can accept HTTPS connections using the built-in `https` module, which calls OpenSSL. Popular desktop applications, such as WhatsApp messenger, are also written in JavaScript using the Electron framework, connecting to servers using the same `https` module.

Our goal is to develop a high-assurance reference implementation of TLS 1.3, called RefTLS, that can be seamlessly used by Electron apps and Node.js servers. We aim for a small, easy-to-read, and easy-to-analyze implementation that can serve as an early experimental version of TLS 1.3. Crucially, we want to verify the security of the core protocol code in RefTLS, ensuring it avoids both protocol-level attacks and implementation bugs in its protocol state machine.

**RefTLS Architecture:**
- **Flow and ProScript:** RefTLS is written in Flow, a typed variant of JavaScript, which guarantees the absence of many classic JavaScript bugs. We would like to verify the security of all our Flow code, but since Flow is a fully-fledged programming language, it has features that are hard to automatically verify. We developed ProScript, a typed subset of JavaScript, for writing cryptographic protocol code that can be compiled automatically to ProVerif. ProScript enforces syntactic scoping, strict type checking, and disallows implicit coercions and dynamic extensions.
- **Implementation Structure:** RefTLS is divided into untrusted Flow code for handling network connections and implementing the API, a verified protocol module written in ProScript, and trusted but unverified Flow code for parsing and serializing TLS messages. The core protocol module, called RefTLS-CORE, implements all cryptographic operations and exposes an interface for driving the protocol while hiding keying material and sensitive session state. This isolation is implemented via the Node module system, and we can exploit Electron’s multi-threading feature to provide thread-based isolation to the RefTLS-CORE module, allowing it to be accessed only through a predefined RPC interface. Strong isolation for RefTLS-CORE allows us to verify it without relying on the correctness of the rest of the RefTLS codebase.

However, RefTLS still relies on the security and correctness of the crypto library and the underlying Electron, Node.js, and JavaScript runtimes. In the future, we may reduce this trusted computing base by relying on verified crypto, verified JavaScript interpreters, and least-privilege architectures, such as ESpectro, which can control access to dangerous libraries from JavaScript.