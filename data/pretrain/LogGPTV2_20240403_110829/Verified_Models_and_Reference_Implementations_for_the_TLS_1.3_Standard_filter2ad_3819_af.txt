honest client, and either the client is authenticated and not
compromised, or the client key share gx(cid:2)
accepted by the
server was generated by the client, then the client must
have accepted a session with the server, and they must
agree on the established keys and on all messages sent
in the protocol. We state this property as a CryptoVerif
query and verify it.
• Replay Prevention: The authentication properties stated
above are already injective, that is, they guarantee that
each session of the client (resp. server) corresponds to
a distinct session of the server (resp. client), and conse-
quently, they forbid replay attacks.
• (Forward) Secrecy of Keys: The keys ats c, ats s, ems,
exchanged in several protocol sessions are indis-
and psk
tinguishable from independent fresh random values. This
remains
property means for instance that the keys psk
secret (indistinguishable from independent fresh random
values) even if ats c, ats s, ems are given to the adversary,
and similarly for the other keys. Secrecy holds on the
client side when the server is not compromised before
the end of the session. It holds on the server side when
the client is authenticated and not compromised before
the end of the session or when the key share gx(cid:2)
used
by the server comes from the client. We prove secrecy of
ats c, ats s, and ems on the server side when the key share
gx(cid:2)
comes from the client as soon as the server sends its
Finished message. This property allows us to prove
security of 0.5-RTT messages by composition with the
(cid:2)
(cid:2)
record protocol.
(cid:2)
• Unique Channel Identiﬁer: When cid is psk
or H(log 7),
we do not use CryptoVerif as the result is immediate: if a
client session and a server session have the same cid, then
these sessions have the same log 7 by collision-resistance
of H (which implies collision-resistance of HMAC-H), so
all their parameters are equal.
When cid is ems, collision-resistance just yields that the
client and server sessions have the same log 4. CryptoVerif
proves that, if a client session and a server session both
terminate successfully with the same log 4, then they have
the same log 7 and the same keys, so all their parameters
are equal.
We need to guide CryptoVerif in order to prove these
properties, with the following main steps. We ﬁrst apply
the security of the signature under the server key sk S. We
introduce tests to distinguish cases, depending on whether
the Difﬁe-Hellman share received by the server is a share
gx(cid:2)
from the client, and whether the Difﬁe-Hellman share
received by the client is the share gy generated by the
server upon receipt of gx(cid:2)
. Then we apply the random
oracle assumption on x (cid:3)→ HMAC-H
kdf 0 (x), replace vari-
ables that contain gx(cid:2)y with their values to make equality
tests m = gx(cid:2)y appear, and apply the gap Difﬁe-Hellman
assumption. At this point, the handshake secret hs is a fresh
random value. We use the properties on the key schedule
established in Appendix A to show that the other keys are
fresh random values, and apply the security of the MAC and
of the signature under the client key sk C.
C. Verifying Handshakes with Pre-Shared Keys
We now analyze the handshake protocol in Figure 4, up
until the new client and server sessions are established. The
protocol begins with 0-RTT and continues on to 1-RTT.
We consider both variants of PSK-based 1-RTT, with and
without Difﬁe-Hellman exchange.
We ignore the ticket enckt (psk ) and consider a honest
client and a honest server that initially share the pre-shared
key psk. Dishonest clients and servers may be included
in the adversary. As in the previous section, we give the
handshake keys (kh
s ) to the adversary and ignore
handshake encryption. Certiﬁcates for the client and server
are optional, since they are already authenticated via the psk;
we do not rely on authentication in our proofs and consider
that the adversary performs the signature and veriﬁcation
operations on certiﬁcates if they occur.
c and kh
(cid:2)
The outputs of this protocol are the client early trafﬁc
secret ets c (the derivation of the key kc from ets c is left for
the record protocol), the application trafﬁc secrets ats c and
ats s, the exporter master secret ems, and the resumption
. We run CryptoVerif on our model to
master secret psk
obtain the following veriﬁcation results:
• Key Authentication: CryptoVerif shows the same authen-
tication properties as for the handshake without pre-shared
key, assuming that both participants are uncompromised.
Notably, however, CryptoVerif cannot prove authentica-
tion of ets c. While the binder mackb (. . . ) authenticates
most of the client ClientHello message, the client
495
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
(cid:2)
may offer several pre-shared keys and send a binder for
each of these keys. Only the binder for the pre-shared key
selected by the server is checked. Hence the adversary
may alter another of the proposed binders, yielding a
different log 1 and a different ets c on the server side. This
is not a serious attack, as the record protocol will fail if
ets c does not match on the client and server sides.
• Replay Prevention: CryptoVerif proves that all the au-
thentication properties shown above are injective, thus
showing the absence of replays for ats c, ats s, and ems.
However, CryptoVerif cannot prove replay protection
for the 0-RTT session key ets c, and indeed the client
ClientHello message can be replayed, yielding the
same key ets c for several sessions of the server even
though there is a single session of the client.
• Secrecy of Keys: The keys ets c, ats c, ats s, ems, and
exchanged in several protocol sessions are indistin-
psk
guishable from independent fresh random values. Secrecy
holds both on the client side and on the server side except
that, on the server side, the keys ets c are not independent
of each other since an adversary may force the server to
accept several times the same key ets c by replaying the
client ClientHello message. We prove the secrecy of
ats c, ats s, and ems on the server side as soon as the
server sends its Finished message.
• Forward Secrecy: CryptoVerif is unable to prove secrecy
of the keys when psk is compromised after the end of
the session, even assuming that hkdf-extract is a random
oracle. Secrecy obviously does not hold in this case for the
handshake without Difﬁe-Hellman exchange. We believe
that it still holds for the handshake with Difﬁe-Hellman
exchange; our failure to prove it in this case is due to the
current limitations of CryptoVerif.
• Unique Channel Identiﬁer: We proceed as in the hand-
shake without pre-shared key. We additionally notice that,
if a client session and a server session have the same
log 7, then they have the same psk. Indeed, by collision-
resistance of mac = HMAC-H, they have the same kb, so
the same es, so the same psk.
D. Verifying the Record Protocol
The third component of TLS 1.3 is the record protocol
that encrypts and decrypts messages after the new client and
server sessions have been established in Figures 2 and 4.
In our model, we assume that the client and server share
a fresh random trafﬁc secret. We generate an encryption
key and an initialization vector (IV), and send and receive
encrypted messages using those key and IV, and a counter
that is distinct for each message. (Our model is more detailed
than the symbolic presentation given in the ﬁgures as we
consider the IV and the counter.) We also generate a new
trafﬁc secret as speciﬁed in the key update mechanism
of TLS 1.3 Draft-18 (Section 7.2). CryptoVerif proves the
following properties automatically:
• Key and Message Secrecy: CryptoVerif proves that the
updated trafﬁc secret is indistinguishable from a fresh
random value. It also proves that, when the adversary
(cid:2)
provides two sets of plaintexts mi and m
i of the same
496
Handshake without pre-shared key
ats c
ats s
psk
(cid:2)
Handshake with pre-shared key
(cid:2)
ats c
ats s
psk
ets c
Record protocol
updated ts
Figure 5: Structure of the CryptoVerif proof
padded length, it is unable to determine which of two
sets is encrypted, even when the updated trafﬁc secret is
leaked.
• Message Authentication: CryptoVerif proves that, if a
message m is decrypted by the receiver with a counter c,
then the message m has been encrypted and sent by an
honest sender with the same counter c.
• Replay Prevention: The authentication property above
is injective, that is, any sent application data may be
accepted at most once by the receiver.
E. A Composite Proof for TLS 1.3 Draft-18
We compose these results using a hybrid argument (as
in [40]). Figure 5 summarizes the structure of the composi-
tion; more details are given in the full version [13].
First, we use the secrecy property of the initial handshake
to replace all session keys with independent fresh random
values. We rely on authentication and replay prevention to
show that the same replacement is performed in matching
sessions of the client and server.
Then, we use the security properties of the record protocol
using ats c and ats s as trafﬁc secrets, to obtain secrecy,
forward secrecy (with respect to the compromise of sk S and
sk C), authentication, and replay prevention for application
messages in both directions. The security of the record
protocol also shows that the updated trafﬁc secrets generated
during subsequent key updates preserve these properties.
Using the key psk
provided by the initial handshake,
we then apply the security of the PSK-based handshake, to
obtain that the keys ets c, ats c, ats s, and psk
provided by
this handshake are independent fresh random values. (The
forward secrecy property of the initial handshake allows us
to leak the keys sk S and sk C, so that the adversary can in-
deed perform the signature operations related to certiﬁcates,
as we assumed in our model of handshakes with pre-shared
keys.) We then apply the security of the record protocol to
ats c and ats s, as above, for 1-RTT messages. We also apply
it to ets c for 0-RTT messages, but since the handshake does
not prevent replays for this key, the composition will not
prevent replays for messages sent under this key.
Finally, we apply the security of the PSK-based handshake
, hence obtaining composite
again to the newly obtained psk
security for arbitrary sequences of PSK-based resumptions.
(cid:2)
(cid:2)
(cid:2)
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
VII. REFTLS: A REFERENCE TLS 1.3 IMPLEMENTATION
WITH A VERIFIED PROTOCOL CORE
In today’s web ecosystem, TLS is used by wide variety
of client and server applications to establish secure channels
across the Internet. For example, Node.js servers are written
in JavaScript and can accept HTTPS connections using a
Node’s builtin https module that calls OpenSSL. Popular
desktop applications, such as WhatsApp messenger, are also
written in JavaScript using the Electron framework (which
combines Node.js with the Chromium rendering engine);
they connect to servers using the same https module.
Our goal is to develop a high-assurance reference imple-
mentation of TLS 1.3, called RefTLS, that can be seamlessly
used by Electron apps and Node.js servers. We want our
implementation to be small, easy to read and analyze, and
effective as an early experimental version of TLS 1.3 that
real-world applications can use to help them transition to
TLS 1.3, before it becomes available in mainstream libraries
like OpenSSL. Crucially, we want
to be able to verify
the security of the core protocol code in RefTLS, and
show that it avoids both protocol-level attacks as well as
implementation bugs in its protocol state machine [12].
In this section, we describe RefTLS and evaluate its
progress towards these goals. RefTLS has been used as
a prototype implementation of TLS Draft-13 to Draft-18,
interoperating with other early TLS 1.3 libraries. Its protocol
core has been symbolically analyzed with ProVerif, and it
has been successfully integrated into Electron applications.
Flow and ProScript. RefTLS is written in Flow [32], a
typed variant of JavaScript. Static typing in Flow guarantees
the absence of a large class of classic JavaScript bugs, such
as reading a missing ﬁeld in an object. Consequently, our
code looks very much like a program in a typed functional
language like OCaml or F#. We would like to verify the
security of all our Flow code, but since Flow is a fully-
ﬂedged programming language, it has loops, mutable state,
and many other features that are hard to automatically verify.
In earlier work, we developed a typed subset of JavaScript
called ProScript [48] that was designed for writing crypto-
graphic protocol code that could be compiled automatically
to ProVerif. ProScript is also a subset of Flow and so we can
reuse its ProVerif compiler to extract symbolic models from
the core protocol code in RefTLS, if we write it carefully.
ProScript code is written defensively, in that it cannot,
libraries or extensible
even accidentally, access external
JavaScript functionalities such as object
instantiation, or
redeﬁnable properties such as Array.split. These restrictions
are necessary in JavaScript where external functions can
completely redeﬁne the behavior of all libraries and object
prototypes. The resulting style enforces syntactic scoping
and strict type checking for all variables and functions, and
disallows implicit coercions, object prototype access, and
dynamic extensions of arrays and objects.
For ease of analysis, ProScript disallows loops, recursion,
and only allows access mutable state through a well deﬁned
table interface. These are signiﬁcant restrictions, but as
we show, the resulting language is still expressive enough
to write the core composite protocol code for TLS 1.0-1.3.
Figure 6: RefTLS Architecture. The library is written in
Flow, a typed subset of JavaScript. The protocol core is
veriﬁed by translation to ProVerif. The cryptographic library,
message formatting and parsing, and the runtime framework
are trusted. The application and parts of the RefTLS library
are untrusted (assumed to be adversarial in our model).
Implementation Structure. Figure 6 depicts the architec-
ture of RefTLS and shows how it can be safely integrated
into larger, unveriﬁed and untrusted applications. At the
top, we have Node.js and Electron applications written in
JavaScript. RefTLS exposes an interface to these applica-
tions that exactly matches that of the default Node.js https
module (which uses OpenSSL), allowing these applications
to transparently use RefTLS instead of OpenSSL.
The RefTLS code itself is divided into untrusted Flow
code that handles network connections and implements
the API, a veriﬁed protocol module, written in ProScript,
and some trusted but unveriﬁed Flow code for parsing
and serializing TLS messages. All this code is statically
typechecked in Flow. The core protocol module, called
RefTLS-CORE, implements all the cryptographic operations
of the protocol. It exposes an interface that allows RefTLS
to drive the protocol, but hides all keying material and
sensitive session state within the core module. This isolation
is currently implemented via the Node module system; but
we can also exploit Electron’s multi-threading feature in
order to provide thread-based isolation to the RefTLS-CORE
module, allowing it to only be accessed through a pre-
deﬁned RPC interface. Strong isolation for RefTLS-CORE
allows us to verify it without relying on the correctness of
the rest of the RefTLS codebase.
However, RefTLS still relies on the security and cor-
rectness of the crypto library and the underlying Electron,
Node.js, and JavaScript runtimes. In the future, we may be
able to reduce this trusted computing base by relying on
veriﬁed crypto [73], veriﬁed JavaScript interpreters [29], and
least-privilege architectures, such as ESpectro [69], which
can control access to dangerous libraries from JavaScript.