---
## Page 643
与设计模式相处
下面是一个软件开发反模式的例子。
像设计模式一样，每个反模式
反模式
都有名字，所以我们可以创
建共享词汇。
名称：黄金榔头
问题：你需要为你的开发选择技术，而且你
相信正好有一种技术能够主宰这个架构。
问题与情境，如同设计模式
情境：你需要开发某个新的系统或者是一套
所使用的描述。
软件，然而此系统或软件却无法和开发团队
所熟悉的技术相吻合。
力：
开发团队致力于采用他们所熟悉的技术。
开发团队并不熟悉其他技术。
告诉你为什么这个
解决方案是有吸引
采用不熟悉的技术被认为风险比较高。
力的。
使用熟悉的技术做开发，比较容易规划
和预估。
原本的解决方案：反正就使用熟悉的技术好
了。将熟悉的技术强迫性地用在许多问题上，
不好的但有吸引力的解决方案。
甚至在明显不适当的地方也照用。
重构的解决方案：开发人员通过教育、培训
如何使用一个好的
和读书会，可以学会新的解决方案。
解决方案。
例子：
当采用开放源码的替代品时，Web公司依然
这个反模式金出现在什么地方。
持续使用并维护他们内部自行开发的缓存系
统。
此例取旬PontandPatternRepositoryWiki
网址是http：/ /c2.com/、在那里你可以发
现许多反模式和相关的讨论。
你现在的位置
607
---
## Page 644
设计工具箱
要点
设计箱内的工具
你已经到了可以脱离我们的阶段，现在该是你走向外面的
让设计模式自然而然地出现在
世界，凭着自己的能力探索模式的时候了。
你的设计中，而不是为了使用
而使用。
设计模式并非僵化的教条；
你
00基础
可以依据自己的需要采用或调
整。
00原则
装
总是使用满足需要的最简单解
封装变化
态
决方案，不管它用不用模式。
多用组合，少用继承
针对接口编程，不针对实现编程
承
学习设计模式的类目，可以帮
为交互对象之间的松耦合设计两
你自己熟悉这些模式以及它们
努力
之间的关系。
类应该对折展开效，对修改关闭。
是自己走出去发现更多模
模式的分类（或类目）是将模
依赖抽象，不要依赖具体类。
式的时候了。外面的世界
式分成不同的族群，如果这么
只和朋度文谈
中.有许多属于特定领域
做对你有帮助，就采用吧！
别找我，我金找你
的模式和一些基础的模
你必须相当专注才能够成为一
类应该只有一个改变的理由
式，并未在本书中提及。
个模式的作家：这需要时间也
另外，也可以创建你自己
的模式。
需要耐心，同时还必须乐意做
大量的精化工作。
请牢记：你所遇到大多数的模
牙
00模式
式都是现有模式的变体，而非
去看看附录
新的模式。
代理模式为
你的模式写在这里！
有一些更基础
模式能够为你带来的最大好处
的模式，你可
身或占位符
之一是：让你的团队拥有共享
能会感兴趣。
词汇。
复合
任何社群都有自己的行话，模
复合模
式社群也是如此。别让这些行话
模式，
绊着，在读完这本书之后，你已
解决一再发生的一般性问
经能够应用大部分的行话了。
题。
608
第13章
---
## Page 645
与设计模式相处
离开对象村····
有你们的口子真好。
我们一定会想念你们的。但是，别担心，下一本HeadFirst书
很快就会出版，到时候欢迎你们再度来访。你问我下一本书
是什么主题？这真是好问题！你要不要给点意见？发E一
mail到|booksuggestions@ wickedlysmart.com吧!
PDG
你现在的位置
609
---
## Page 646
连连看解答
习题解答
请将下列模式和描述配对：
模式
描述
装饰者
封装对象，并提供不同的接口。
状态
由子类决定如何实现一个算法中的步骤。
送代器
由子类决定要创建的具体类是哪一个。
外观
确保有且只有一个对象被创建。
策略
封装可以互换的行为，并使用委托来决定要
使用哪一个。
代理
客户用一致的方式处理对象集合和单个对象。
工厂方法
封装了基于状态的行为，并使用委托在行为
之间切换。
适配器
在对象的集合之中游走，而不暴露集合的实
现。
观察者
简化一群类的接口。
模板方法
一包装一个对象，以提供新的行为。
允许客户创建对象的家族，而无需指定他们的
组合
具体类。
单件
让对象能够在状态改变时被通知。
抽象工厂
包装对象，以控制对此对象的访问。
命令
封装请求成为对象。
610
第13章
---
## Page 647
附录A
剩下的模式
并非每个人都广受欢迎。过去10年来，事情改变了许多。自从
《设计模式：可复用面向对象软件的基础》一书出版之后，开发人员就
开始大量地采用这些模式。我们在此附录中所介绍的模式，都是成熟、
典型、正式的四人组模式，只不过可能不像前面章节所探索的模式那么
经常地被使用。但是这些模式本身也有相当可取之处，而如果你遇到了
合适的情形，也应当毫不犹豫地采用它们。我们在此的目标，是希望能
PDG
够让你通盘了解这些模式的意义。
这是附录A
611
---
## Page 648
桥接模式
桥接
使用桥接模式（BridgePattern）不只改变
你的实现，也改变你的抽象。
这是一个抽象，可以是接口或抽果
类。
场景
你打算彻底改革你的“极限休息室”，正
为一个新的人体工学且接口友好的电视遥
控器编程。你要使用好的OO技能，让所有
RemoteControl
每个遥控器都有相同的
的遥控器基于相同的抽象，而对此抽象又
an0
抽象。
offj
做出许多不同的实现一一每部不同型号的电
setChannel()
视都有自己的遥控器实现。
更多方法
RCAControl
SonyControl
有许多的实现，每
on[)
on0
部电视各有一个。
ofl)
off)
setChannel)
setChannel()
更多方法
更多方法
tuneChannel(channel);
你的两难
你不会第一次就做对遥控器的用户界面。事实上，你希望
随着可用性数据收集得越来越丰富的同时，持续改良遥控
器。
使用这个设计，我们可以只改变
所以你的两难之处就在于：遥控器会改变，而电视机也会
电视的实现，而不改变用户界面。
改变。你已经将用户界面抽象出来，所以可以根据不同的
电视机改变它的实现。事情还不只这样，随着使用时间的
增长，用户会对此界面提出一些想法，你还必须应对他们
的反馈来改变抽象。
所以你要如何建立一个0O设计，能够改变实现和抽象呢？
612
附录A
---
## Page 649
剩下的模式
为何使用桥接模式？
桥接模式通过将实现和抽象放在两个不同的类层次中而使它
们可以独立改变。
实现的类层次。
抽象的类展次。
这两个层次之间的关
系，就叫做“桥摇”。
RemoteControl
implemenfor
Has-A
TV
on()
off()
on
aff
setChannel()
implementor.tuneChannel(channel):
tuneChannel()
》更多方法
更多方法
R
此抽象中所有的方法都是以实
ConcreteRemote
现方式实现的。
RCA
Sony
aumentStatior
on
on)
on()
off0
tuneChannel)
off()
ofl)
setChannel(currentStation+1);
tuneChannelg)
setStation()
更多方法
更多方法
nextChannel()
previousChannel)
W更多方法
具体子类是以抽象方式而不是实现方
式实现的。
现在你有了两个层次结构，其中一个是遥控器，而另一个是平台特定的电视机实
现。有了桥接的存在，你就可以独立地改变这两个层次。
桥接的优点
桥接的用途和缺点
将实现予以解耦，让它和界面之间不再永久绑
适合使用在需要跨越多个平台的图形和窗口
定。
系统上。
抽象和实现可以独立扩展，不会影响到对方。
当需要用不同的方式改变接口和实现时，你
对于“具体的抽象类”所做的改变，不会影响
会发现桥接模式很好用。
到客户。
桥接模式的缺点是增加了复杂度。
你现在的位置
613
---
## Page 650
生成器模式
生成器
使用生成器模式（BuilderPattern）封装一个产品的构
造过程，并允许按步骤构造。
场景
“模式乐园”是在对象村外围的一个新主题公园，他们请你为“模式乐园”制定一
套度假计划。客人可以选择旅馆以及各种门票、餐厅订位，甚至也可以选择登记
参加特殊的活动。想要制定一套度假计划，你需要建立像下面这样的结构：
每个假期都规划有好几天。
每天都可以包含旅馆订房、门
票、馨饮，以及特殊活动的任
意组合。
你需要一个有弹性的设计
每个客人的度假计划可能都不太一样，例如天数、活动类型。比方说，当地居民可
能不需要旅馆，但是想要用餐并参与特殊活动。而其他的客人可能是从外地飞过来
的，所以需要旅馆、用餐和门票。
所以，你需要一个有弹性的数据结构，代表客人的规划，以及所有的变化；你也需
PDG
要遵照一系列潜在的复杂顺序，创建这样的规划。你要如何才能够提供一种方式来
创建这个复杂的结构，而不会和创建它的步骤混在一起呢？
614
附录A
---
## Page 651
剩下的模式
为何使用生成器模式？
还记得选代器吗？我们将选代的过程封装进人一个独立的对象
中，并向客户隐藏集合的内部表现。这里也是采取相同的想法：
我们将旅游规划的创建过程，封装到一个对象中（让我们称此
对象为生成器），然后让客户调用生成器为它创建旅游规划。
客户使用抽象的接口建
立规到。
客户指示生成器
builder
AbstractBullder
构递规划，
constructPlanner0
(kegping
addHotelO
addReservation(
adSpecialEvent(
addTickets)
getVacationPlannert
builder.buidDay(date);
builder.adHotel(date,Grand Facadian;
具体生成器创建真正的
bulder.addTickets(Pattems on ice");
产品，并将产品储存在
假期组合结构中。
》规划剩下的假期
VacationBulider
Planner yourPlanner=
vacation
bulider.getVacationPlanner);
buidDay)
addHotel()
addReservation(