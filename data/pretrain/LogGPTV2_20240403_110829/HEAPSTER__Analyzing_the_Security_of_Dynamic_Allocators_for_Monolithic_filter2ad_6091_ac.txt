Deallocator Candidate Test. As we discussed in Section II, in
this paper we target dynamic allocators that re-use freed memory
chunks. With this insight in mind, given the allocator A, for any
candidate de-allocator D in the deallocator candidate set, we
perform the following test:
1) call A for X times and collect the return values a1, a2, ..., aX;
2) call D for X times passing a1, a2, ..., aX as arguments;
3) call A one more time and verify the new return value aX+1
is equal to one of a1, a2, ..., aX.
Specifically, in our configuration we set X to a value of three2.
When this test is successful, we consider the pair (A, D) to be the
blob’s HML.
Deallocator Candidate Execution. De-allocators consume values
dynamically generated by malloc, and therefore, we cannot simply
collect their arguments from the call sites as we do when executing
pointer sources. However, as we are always testing a de-allocator
candidate together with a target allocator, we set the de-allocator’s ar-
guments to the value previously returned by a call to the allocator. In
our experiments, this is always enough to observe the de-allocation
behavior without compromising the execution of the primitive.
HML Pairs Filtering. Wrappers around the real allocator and
de-allocator (i.e., functions that merely call the HML primitives
and forward their results) can still be mistaken for a valid HML.
Since the target of our analysis is the low-level interface of the
main allocator of the firmware blob, we need to further filter the
identified (A, D) pairs to remove false positives. To do this, we
analyze the callgraph of each allocator in an HML pair, and we
recursively remove the ones that call other allocators in another
HML pair. We repeat the same analysis for the de-allocators to
eventually identify the final HML pair.
E. HML Analysis
Once HEAPSTER detects a valid HML pair for a firmware image
(i.e., malloc and free), it needs to collect more information to
support the HML’s security testing. In this section, we discuss how
HEAPSTER recovers the prototypes of the heap functions, how it
identifies hotspots that might impact the symbolic exploration, and
2We chose X=3 to allow for different allocator chunk management policies. We did
not observe any difference in de-allocators identification when using bigger values.
how it collects additional properties of the HML to configure the
bounded model checking.
Prototype Recovery. To be able to support diverse implementations
of malloc and free, we can not assume that the HML primitives
always follow the standard prototypes (i.e., malloc(size), and
free(*ptr)). For instance, we observed firmware images in
our dataset using an extra argument to store error codes in case
an HML primitive happens to fail. In the previous analyses, when
executing malloc and free, we were simply re-using a valid
set of arguments collected at the respective call sites, without any
additional information about their semantics (e.g., which argument is
the requested size). However, HeapHopper’s security testing requires
semantic information for the arguments to create the programs (i.e.,
PoC) that interact with the identified HML. Therefore, in presence
of multiple arguments, we need to understand which argument
represents the size in malloc, and which one represents the
pointer to be freed in free. To extract this information, we execute
the primitive with symbolic arguments constrained to concrete
values3, and, then, we select the argument with the highest number
of observable constraints. This technique is based on the intuition
that the requested size and the pointer to be freed generally go
through several different checks, and therefore, multiple constraints
are set over the symbolic variables. For example, it is very common
that the requested size value falls inside a specific integer range as
it is used later to select an appropriately sized memory chunk.
Hotspot Detection. During the execution of HML functions – in
particular when erroneous conditions are met – the code might call
functions that put the firmware in a stalling state (e.g., an infinite
loop or a sleeping procedure). These procedures are generally
meant to protect the device from damage, and usually require an
external intervention to be solved (i.e., a reboot). However, these
behaviors are problematic when scaling symbolic execution because
the analysis can be stuck analyzing redundant code, with little to no
progress. To detect these “problematic” functions, we profile several
runs of malloc and free by supplying both legitimate and invalid
parameters (e.g., we set the free argument to an invalid pointer).
Whenever the emulation reaches a configured timeout, we identify
the sub-function in which the exploration spent the most time, and
we mark it to be skipped when future executions reach its address.
This process is repeated until malloc and free can be entirely
emulated within the configured timeout. The list of problematic
functions is saved, and used when performing the security testing
to inform the symbolic engine to skip these functions.
However, skipping functions that may be responsible for heap
state changes could interfere with the results of the security
evaluation, and introduce false positives/negatives. During our
evaluation, we confirmed that the functions marked as “problematic”
always bring the firmware code in a stalling state and never return.
This means that the code marked to be skipped does not change the
heap state, reducing the possibility of false negatives. For this reason,
we focus our efforts on removing false positives by re-executing
the generated PoV programs without skipping any function.
HML Properties. To configure the symbolic testing and identify
security violations in an HML, we need to extract some of its
3These arguments are the ones found at the call sites, or valid placeholders.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:35:29 UTC from IEEE Xplore.  Restrictions apply. 
1087
implementation details. In particular: the heap base address, the
heap growth direction (i.e., if it grows toward higher or lower
memory addresses), and the size of inline metadata [24]. Extracting
the first two proprieties is straightforward: since we can execute the
malloc function, the base address corresponds to the first value
returned by the allocator, while the growth direction is inferred
by comparing the result of two subsequent malloc allocations.
To detect the presence of inline metadata, we place memory
breakpoints in the surrounding of a previously allocated chunk, and
then we invoke free over it. Whenever one of these breakpoints
is triggered during free’s execution, we tag the corresponding
memory location as containing heap metadata.
F. HML Model Definition
The core component behind the security testing of the identified
HML is a custom version of HeapHopper [24] that we adapted to
test monolithic firmware images.
Heap Transitions. HeapHopper models the heap as a state machine
where nodes represent heap states, and edges represent transitions
between states. These heap transitions can be benign operations
— i.e., calls to malloc (M) and free (F) — or malicious
exploitation primitives. In particular, HeapHopper implements the
following heap exploitation primitives:
Double-free (DF) Calling free on a memory chunk that was
already been freed, and not re-allocated.
Fake-free (FF) Calling free with a memory address that points
to an invalid or manipulated heap chunk.
Use-after-free (UAF) Writing data to a memory chunk that has
been freed, and has not been re-allocated yet.
Heap overflow (O) Writing data beyond the size of a target chunk.
Heap Vulnerabilities. If the HML does not have defenses against
the exploitation primitives, the data structures holding the state
of the heap can contain erroneous information. This can lead to
a vulnerable state, which, in turn, can serve as a focal point in an
attack against the system. In this paper, we focus on the following
heap vulnerabilities:
Overlapping Chunks (OC) Allocation of a memory chunk that
overlaps with other allocated chunks.
Non-Heap Allocation (NHA) Allocation of a memory chunk
outside the heap region.
Arbitrary Write (AW) A memory write where the attacker can
control the destination address and the content.
Restricted Write (RW) A memory write with restricted capabil-
ities over the destination address or the content being written.
G. HML Bounded Model Checking
HeapHopper Analysis. Given the heap modeling described in the
previous section, we leverage HeapHopper to perform the security
analysis of a heap library using bounded model checking and sym-
bolic execution. HeapHopper generates proof of concept programs
(PoCs) that contain permutations of different benign heap transitions
(i.e., legitimate calls to malloc and free) and malicious transi-
tions (i.e., the exploitation primitives), and while symbolically exe-
cuting them, it checks if any state becomes vulnerable to one of the
heap vulnerability classes defined in Section III-F. When a vulnera-
bility is detected, all the symbolic values in memory are concretized
to obtain a fully concrete Proof-of-Vulnerability (PoV), which we
used later to confirm the finding. To keep the analysis tractable
during exploration, HeapHopper bounds the symbolic values inside
a PoC using specific domain knowledge (e.g., by limiting the mal-
loc requested size parameter to a list of few integer values). We dis-
cuss the main HeapHopper configuration parameters in Appendix G.
HeapHopper Setup. To test the identified HML, we first load a
PoC inside HeapHopper, and, then, we side-load the monolithic
firmware image as the PoC’s library. Finally, we hook any call to
malloc and free executed by the PoC so that they are redirected
to the respective HML functions identified in the firmware blob.
H. PoV Validation
As acknowledged by Eckert et al. [24], and more recently by
Yun et al. [63], HeapHopper can produce false positives. In other
words, a PoC might trigger a heap vulnerability during the symbolic
tracing, which is not confirmed when re-executing the PoV. To
mitigate this issue, HEAPSTER always checks that a PoV generated
by HeapHopper actually triggers the heap vulnerability. To do this,
we re-emulate the concrete PoV without skipping any identified
“problematic” functions (as explained in Section III-E), and we
check whether the execution effectively triggers the discovered
heap vulnerability. Otherwise, we discard the PoV.
I. HeapHopper Modifications
In this work, we build upon the implementation of HeapHop-
per [24], in particular, we modified parts of it to support the analysis
of monolithic firmware images based on ARM CortexM CPUs.
PoC Generation. We changed how HeapHopper generates the
PoCs to: (1) generate ARM binaries, and (2) support the generation
of programs with custom prototypes for malloc and free (as
explained in Section III-E).
PoC Loading. We modified how HeapHopper loads the binaries
under testing inside the underlying emulator. In particular, since
a stand-alone binary HML is not available (e.g., in the original
version of HeapHopper this binary was represented by the GNU
libc [32]), we instruct HeapHopper to use the monolithic firmware
image as a library, which is side-loaded with the PoC under testing
inside the emulator.
Arbitrary Write Model. The original HeapHopper categorized
attacker-controlled writes in Arbitrary Write and Arbitrary Write
Constrained. A vulnerability is classified as an Arbitrary Write
when we can control the destination address and the content to be
written. Arbitrary Write Constrained refers to an attacker-controlled
write that can be redirected only to memory locations where specific
content is present. In our version, we decided to replace Arbitrary
Write Constrained with Restricted Write. We use the Restricted
Write to indicate attacker-controlled write with limited capabilities
over the destination address or the content.
IV. IMPLEMENTATION
We implemented HEAPSTER in Python on top of the binary
analysis framework angr [54].
Firmware Preparation. A mandatory requirement to analyze
a monolithic firmware is to know both its entry point and base
address. This information can be either provided as input to our
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:35:29 UTC from IEEE Xplore.  Restrictions apply. 
1088
system, or extracted with the analysis proposed in FirmXRay [59].
To identify the functions in the firmware image, we extract the entry
point from the Interrupt Vector Table stored in the blob [8], and we
leverage angr’s recursive traversal disassembly to build its Control
Flow Graph (CFG). After recovering the firmware’s CFG, we also
use angr’s CallingConvention analysis to determine the number
of arguments and possible return values of every identified function.
Static Analyses. To implement
the backward slice analysis
presented in Section III-B, we leverage angr’s ReachingDefinition
engine. This analysis enables HEAPSTER to apply the classic RD
dataflow analysis on binaries and to reason about register definitions
and, in a limited way, memory definitions.
Functions Emulation. To dynamically execute the functions of the
firmware blob (symbolically and concretely), we leverage the VEX
execution engine provided by the angr framework. In particular,
the binary code is lifted into the VEX Intermediate Representation
(IR) [44]. Later, the IR instructions are executed to mimic the effect
of the real assembly instructions over the state of the program. The
VEX engine supports both symbolic execution and fully concrete
execution (i.e., no symbolic variables in the program’s state). When
using symbolic execution, we leverage a Depth-First-Search (DFS)
exploration strategy. We discuss the different execution models that
HEAPSTER uses to emulate the functions in the firmware image
in Appendix A. In particular, these execution models have been
implemented by combining together different angr’s Exploration
Techniques, and by instrumenting memory access operations
triggered during the functions’ emulation.
V. EVALUATION
We run the first (small-scale) evaluation on a dataset created by
consolidating 20 images from previous research on firmware re-
hosting and firmware security [22], [29], [33], [43]. We refer to this
dataset as the ground-truth dataset because, for each firmware image,
we are provided with the stripped binary image, and the ELF file
with debug symbols. Consequently, since we have labels for every
function in the firmware, we can confirm whether HEAPSTER is
able to correctly locate the basic functions and the HML primitives.
Our second (large-scale) evaluation is instead conducted on a
collection of monolithic firmware images shared by previous re-
search [59] and extracted from popular fitness devices [52]. We refer
to this collection as the wild dataset. This dataset comprises a total of
799 monolithic firmware images, none of which is accompanied by
debug symbols. To study the distribution of the heap libraries used
by monolithic firmware in the wild, and to avoid wasting resources
to test the security of identical HML implementations, we leverage
BinDiff [66] to calculate the similarity between the allocator func-
tions and to cluster them. For each dataset, we split the evaluation
into four parts: (1) HML identification in each firmware blob, (2)
coarse-grained HML clustering, (3) fine-grained HML clustering,
and (4) security analysis with the modified version of HeapHopper
(discussed in Section III-I) for each fine-grained cluster.
HML Identification. We run the HML identification analysis, as
discussed in Section III, on every firmware blob in both datasets with
a time limit of 72 hours, and a memory limit of 70GB per firmware.
Coarse-grained Clustering. The goal of this analysis is the
identification of allocators belonging to the same heap library im-
plementation. For this clustering, we run the similarity analysis only
considering the bodies of the functions identified as malloc. We
consider two implementations part of the same cluster when BinDiff
reports similarity and confidence scores (cid:2) 0.7. We empirically chose
the threshold of 0.7 with the help of our ground-truth dataset: this
value resulted in the lowest number of misclassifications. Never-
theless, since BinDiff uses several heuristics for its analysis [31],
we compensate for misclassifications with additional manual refine-
ments. In particular, we look for clusters containing a single or few
HMLs, since these cases can either represent scarcely used heap im-
plementations or BinDiff imprecisions. When we detect a potential
misclassification of this kind, we manually compare the outliers with
other HMLs and include them inside the correct cluster. Finally, we
look for situations where two clusters are connected by a few HMLs
with a low similarity score, and we manually adjust the clusters after
confirming that they represent two different heap libraries. In total,
we had to manually correct the classification of only 18 blobs.
Fine-grained Clustering. The goal of this analysis is the
identification of identical HMLs. In particular, since identical
HML implementations are affected by the same vulnerabilities, this
clustering reduces the number of security evaluations performed
with HeapHopper. The fine-grained clustering is based on the
similarity analysis over the body of the malloc’s function and
additionally all of its callees up to a depth level of two4. Whenever
the similarity score reported from BinDiff is equal to 1.0 for all
of these functions, we reported the two HMLs to be in the same
fine-grained cluster. Intuitively, the fine-grained clustering defines
sub-clusters inside the coarse-grained clusters identified in the
previous step. Throughout the rest of the evaluation, we use the
notation AN to indicate an HML belonging to the fine-grained
cluster N within the coarse-grained cluster A. In other words, we
refer to AN as an HML “variant”, since it represents a different
version of the library corresponding to coarse cluster A, or a
customization of the library itself due to developer choices, or,
differences introduced by tool-chains/software development kits.
Security Evaluation. When testing a target HML, we leverage
HeapHopper to generate a PoC that is compliant with the
recovered prototype (as explained in Section III-E). Given an
exploitation primitive (e.g., double-free), we generate all the
possible permutations of meaningful transitions up to a maximum
depth of 7 actions (i.e., δ=7). This value was chosen empirically, as
it was enough to discover vulnerabilities in all heap implementations
tested in our evaluation, maintaining the scalability of our analysis
across all the samples within the heterogeneous firmware datasets.
For every depth δ, we use a single malicious heap transition, and
δ−1 legitimate calls to malloc and free. During the symbolic
tracing, whenever HeapHopper produces a PoV, we filter any false
positive using the re-tracing methodology presented in Section III-H.
A. Ground-Truth Dataset
To evaluate HEAPSTER on the ground-truth dataset, we use the
stripped binary images with no debug symbols. These samples are
compiled for different microcontroller units (MCU) and implement
4Since the boundaries between the allocator and other libraries code can not be
easily identified, we need a heuristic to limit the callees depth.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:35:29 UTC from IEEE Xplore.  Restrictions apply. 
1089
a heterogeneous set of different applications. The average size of a
firmware image in the ground-truth dataset is 66KB (median 45KB)
with, on average, ∼20 thousand (median ∼15 thousand) opcodes.
HML Identification. We parallelized the HML identification anal-
ysis and completed it on all 20 firmware images in 48 hours. We re-
port detailed statistics about memory consumption and time required
for each analysis step in Table V of Appendix D. The biggest average
memory consumption was 3.5GB (median 3GB) during the 3
Pointer Source Identification stage, while the biggest average time
of 3.5 hours (median 1.9 hours) was spent during the 5 Deallocator
Identification stage. Using the debugging symbols we can confirm
that HEAPSTER was able to identify the correct HML (i.e., malloc
and free functions) for every firmware image in this dataset. In
Section III-B, we show that the basic functions are starting points
for pointer sources identification, ultimately providing allocator
candidates. In this evaluation, for 18 samples memcpy successfully
marked the final allocator as a possible pointer source, followed
by 9 samples when considering memset, and 1 using strncpy.
Note that, in a given blob, several basic functions can mark the final
allocator as a pointer source. As detailed in Section III-E, when
malloc or free has more than one parameter in their prototypes,
we use a constraint counting heuristic to differentiate the parameter
representing the size or the pointer to free. This analysis reports
that the size parameter has 2.6 more constraints on average than its
closest competitor (median of 2), while the parameter containing the
pointer to free has, on average, 4.1 more constraints (median 6). In
all 20 blobs, memory and time limits were never triggered, the heap
was growing towards higher addresses, and we always found uses of
heap global variables. We report the results of this analysis in Table I.
Coarse-grained Clustering. The coarse clustering divided the
identified HMLs into three groups: 8 belong to A, 9 are in B, and 3 in
C. We confirm, using the debugging symbols of the related firmware
blobs, that these implementations correspond to nano_malloc
[2], newlib’s malloc [1] and lwip_malloc [49], respectively.
Fine-grained Clustering. The fine-grained clustering identified 8
different sub-clusters in cluster A, 6 in cluster B, and 2 in cluster
C, for an overall total of 16 implementation variants. In particular,
Table I shows that none of the HMLs in cluster A are reported to be
identical, while 2 HMLs belong to cluster B1, and 3 to cluster B2.
Finally, 2 HMLs in C are reported to be identical (C1). We manually
verified the coarse-grained and fine-grained clusters identified in
the ground truth and confirmed the results of this analysis.
HML Security Evaluation. For the ground-truth dataset, we tested
all 20 HMLs with HeapHopper (i.e., even when they are part of
the same fine-grained cluster), analyzing an average of 2k PoCs
per HML, with a maximum analysis time of 10 minutes per PoC.
The complete analysis of a single HML took, in the worst case, a
maximum of 3 hours. Overall, the evaluation time for the entire
ground-truth dataset took 27 hours. Table II summarizes the results.
Results Discussion. The security analysis reported that all heap
libraries in clusters A and B are vulnerable to Overlapping Chunks,
Non-Heap-Allocation, and Restricted Writes using most of the
available exploitation primitives. HeapHopper reported also
Arbitrary Write vulnerabilities for clusters A3, A4, and all the
HMLs in cluster B. Notably, our results show that the HMLs in
cluster C are vulnerable only to Overlapping Chunks.
TABLE I: Evaluation results for the ground-truth dataset with
Size in KB for each sample. Functions reports the total number of
functions of the firmware, the number of identified basic functions
and the number of pointer sources. Cluster shows the HMLs’
categorization results. Patched indicates if any allocator’s functions
had to be patched to avoid symbolic execution roadblocks.
Sample
Functions
HML
Name
Ref. Size
Sources Cluster Patched
[29] 24
p2im controllino slave
[29] 30
p2im console
[29] 44
p2im gateway
[29] 31
p2im drone
[29] 20
p2im car controller
expat panda
[43] 94
atmel 6lowpan udp tx [22] 70
samr 21 http
csaw esc19 csa
csaw esc19 csb
stm32 tcp echo server
stm32 tcp echo client