Technical changes
since the last Tor talk
Nick Mathewson
The Tor Project
Defcon XV
Aug 4, 2007
● Tor was working, usable, and seemed pretty
secure. (v 0.0.7.2)
● Pretty small network.
● No GUI—hard to use.
● We got a couple of Defcon talks!
Marty!
We've got to go back to the future2004!
● Hacking on Tor.(Latest is 0.2.0.4-alpha)
– Security: adding features/ﬁxing security bugs.
– Scalability: adding capacity is hard.
– Scalability: using capacity is hard.
– Usability: adding GUIs, ﬁxing bugs.
– Integration: working nice with other apps is hard.
– Lots more: See the changelog.
● Growing the network: ~200kuser, ~1kserver.
What we've been up to since then.
Outline
● Prelude: brief, fast introduction to Tor
● Directories and server discovery changes:
More secure, more scalable!
● Path generation changes:
More efﬁcient, less ﬁlling!
● Circuit-building protocol changes:
Oops. Crypto is hard.
● Some fun new tools and features:
What do you mean, I need to edit a ﬁle?
Intro anonymity: anonymity networks
hide users among users.
Alice2
Bob1
Bob2
Alice1
Alice3
Network
Intro Tor:There are a bunch of servers,
connected via TLS (ssl).
S
S
S
S
S
S
S
S
S
Intro Tor:clients build circuits through
a network of decrypting relays.
1.
S
S
S
S
S
S
S
S
S
Alice2
2.
3.
Alice1
Intro Tor:circuits are used to relay
multiple TCP streams.
1.
S
S
S
S
S
S
S
S
S
Alice2
2.
3.
Bob1
Bob2
Alice1
4.
See also:
PipeNet,
Onion Routing
6.
5.
A hostile ﬁrst hop can tell Alice is
talking, but not to whom.
S
S
S
S
S
S
S
S
S
Alice2
Bob1
Bob2
Alice1
A hostile last hop can tell somebody is
talking to Bob, but not who.
S
S
S
S
S
S
S
S
S
Alice2
Bob1
Bob2
Alice1
But: two hostile hops can correlate
trafﬁc patterns and link Alice to Bob.
S
S
S
S
S
S
S
S
S
Alice2
Bob1
Bob2
Alice1
No obvious
ﬁx that isn’t
extra-slow.
I. Directories and server discovery
● Every client must know every server.
– (If you just ask a server for a list of neighbors, it can
trivially lie.)
● All clients must know the same servers.
● Servers shouldn’t be able to impersonate each
other.
– (Use self-signed descriptions; identity by PK.)
● Bandwidth matters a lot.
We need to tell clients about servers.
Server discovery is hard because
misinformed clients lose anonymity.
S
S
S
S
S
S
S
S
S
Alice2
Bob1
Bob2
Alice1
Known to Alice1
Known to Alice2
2004: every authority published a big
list of server information.
That was slow.
S1
S2
Sn
Authority
Authority
Authority
Client
Client
Client
...
....
Adding caches helped with
performance...
S1
S2
Sn
Authority
Authority
Authority
Client
Client
Client
...
Cache
Cache
Cache
Cache
....
But a single bad authority could still
break clients badly...
S1
S2
Sn
Authority
Authority
Authority
Client
Client
Client
...
Cache
Cache
Cache
Cache
....
And most information was redundant.
Client
Cache
“What's the directory?”
Sign(Desc1,Desc2,Desc3..Desc99)
“What's the directory?”
Sign(Desc1,Desc3..Desc99,Desc100)
So split directory into status (signed)
and individual descriptors
Client
Cache
“What do authorities A and B say?”
SignA(digest list), SignB(digest list)
“Send me descriptor with digest X”
Descriptor with digest X
(2005)
Remaining Problems:
partitioning, redundancy.
Naming and requesting descriptors by
digest prevents attacks.
S1
Authorities
Client
Cache
“Use server whose identity key is X”.
“Here’s one just for you!”
ID = X
Authorities now vote on a single
consensus status document.
(2007)
S1
S2
Sn
Authority
Authority
Authority
...
1. Distribute signed opinions.
2. Compute result of vote,
and sign it.
3. Distribute signatures; make
multi-signed document.
4. Clients check signatures.
5. Proﬁt!
Authorities say more than “yes/no” for
each server.
● Named?
Authority?
● Running?
Guard?
● Valid?
● Fast?
● Stable?
● Bad exit?
● Exit?
(Actually determining
these can be hard.)
(Keywords deﬁne client
behavior; authorities
improve criteria.)
II. Path generation
2004: all servers chosen with equal*
probability, regardless of capacity.
S1
Client
bw=x
p=2x
bw=4x
bw=x
bw=x/2
bw=2x
bw=2x
bw=x
bw=x
bw=x/2
Big servers were
underused.
Tiny servers
were overloaded.
Now: Bandwidth is not uniform, so don't
select uniformly.
S1
Client
p=x
p=2x
p=4x
p=x
p=x/2
p=2x
p=2x
p=x
p=x
p=x/2
(But cap the maximum to prevent trust
bottlenecks.)
S1
Client
p=x
p=2x
“I can push a
terabit. No, really!”
p=x
p=2x
p=2x
p=x
Unstable servers are useful,
but not for (SSH, IM, ...)
Client
1 hour
10 days
10 days
1 hour
10 days
Use long-lived servers for long-lived
connections.
Client
1 hour
10 days
10 days
1 hour
10 days
Okay for
port 22.
Our original “random” path-selection
approach made sure that every client
would eventually be proﬁled.
Alice loses if first and last hop are evil. (Correlation attacks)
Suppose c/n nodes (bandwidthwise) are compromised.
Therefore, (c/n)^2 of Alice's circuits are compromised.
Therefore, if Alice's behavior stays the same, she will eventually lose.
Tor clients now use “guard” servers to
give long-term Alice a chance.
Alice
S
S
S
S
S
S
Chosen at random*, held ﬁxed**.
If Alice’s guards are good, Alice never has a
vulnerable path.
Okay, so guard nodes might go down.
S
S
X
So add more as needed,
but keep them in order...
S
S
S
S
X
...so we can go back to the original
set when they come back online.
S
S
Old Tor:circuits built on-demand only.
This was slow.
Predict desired ports based on past
behavior.
Alice
S
S
(exit to 80,22)
S
S
S
(exit to 8001)
S
“Cannibalize” unused circuits for
faster response to requests no circuit
supports.
Alice
S
S
S
S
(exit to
weird port)
Service on
weird port
III. Circuit-building protocol
Extend by IP:Port was insufﬁcient:
nodes don't all know each other.
Alice
S1
S2
“Extend this circuit to S2 at
18.244.0.188:9010”
“Uh, how?”
In practice, server knowledge is not 100%
synchronized.
So, use identity key and IP.
Using key-only ID for this created
an MITM attack.
Alice
S1
S2
“Extend this circuit to
S2 at evil:9010”
Only good for trafﬁc analysis...
but other users were effective.
(So, don’t use only identity key.)
evil
Using encrypted create cell for ﬁrst
hop was needless crypto.
Old
Alice
S
“Uh, guys? This is TLS.”
New
Alice
S
E(g^x)
g^y,H(K=g^xy)
X
Y,H(K=H(X|Y))
Already encrypted,
authenticated
Speaking of cryptography,
check for bad values of g^x, g^y.
Client
Bad server
Server 2
E2(gx)
E2(g0)
gy,H(g0y)
g0, H(gx0)
“oops.”
(but once we checked
for bad g^x,g^y,Ian
Goldberg could prove
this protocol secure.)
(Also, we patched OpenSSL for this.)
III. Tools and features
Old Tor:everybody must speak SOCKS.
browser
Tor
???????
Privoxy/
polipo
HTTP
SOCKS
App
TCP
gaim
SOCKS
???????
The old solutions kind of sucked.
browser
Tor
Privoxy/
polipo
HTTP
SOCKS
SOCKS
gaim
SOCKS
Replaced
libc
calls
Linux/BSD
App
On windows, you could
do a net driver...
OSX was screwed.
TransPort (+iptables/pf) support any TCP
App
Tor
You can also do use a VM as your router:
see JanusVM.
Privoxy/
polipo
HTTP
SOCKS
App
Linux,
BSD
or OSX
TCP
TCP +
address
App
SOCKS
Problem: DNS leaks are hard to solve.
Tor
Dumb
App
SOCKS
“get me 1.2.3.4!”
DNS
“Where is naughty.com?”
“1.2.3.4!”
Old solution: “use SOCKS4a or else!”
Tor
Smart
App
SOCKS
“get me naughty.com!”
New solution: Tor acts as a DNS server
Tor
Dumb
App
SOCKS
“get me 1.2.3.4!”
DNS
“Where is naughty.com?”
“1.2.3.4!”
This also lets dumb apps handle
.onion addresses.
Problem: editing text ﬁles is hard.
So, add support for external GUIs.
Tor
Vidalia
TorK
....
Things to do:
● Tor: https://torproject.org
– Try it out; want to run a server?
– See docs and specs for more detail.
● Donate to Tor!
– https://torproject.org/donate.html
– (We’rea tax-deductible charity!)
● Donate to EFF too!
– I’m in the dunk tank at 6:30
● See more talks!
– Roger at 2 on anti-censorship
– Mike at 5 on securing the network and
apps.