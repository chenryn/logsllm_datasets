DuckDB
In-Process Analytical
Database System
Mark Raasveldt
Who Am I?
Mark Raasveldt
CTO of DuckDB Labs
Previously at CWI, Database Architectures
What is DuckDB?
• DuckDB
• In-Process OLAP DBMS
• “The SQLite for Analytics”
• Free and Open Source (MIT)
• duckdb.org
DuckDB
DuckDB
CMU Talk 2020
DuckDB
System Overview
DuckDB - Overview
Column-Store ART Index
Date Store Product Price Customer
Vectorized Processing
MVCC
Table Result
Latest V1 V2
Single-File Storage
HEADER META COL1 COL2 COL2 COL2
Parser
4KB 256KB
database.db
DuckDB - Vectors
• DuckDB uses a vectorized push-based model
• Vectors flow through the operators
• Vectors are the bread and butter of the engine
• DuckDB has a custom vector format
• Similar to Arrow - but designed for execution
Vectorized Processing
• Co-designed with Velox team Table Result
DuckDB - Vectors
Vector
Integer
• Vectors hold data of a single type
1
• For scalar types vectors are logically arrays
2
3
• VectorType determines physical representation
4
• Allows us to push compressed data into the engine! 5
DuckDB - Vectors
Flat Constant Dictionary Sequence
Uncompressed array All rows have the same value Map of indexes to dictionary Base and increment
1 0 a a 1
1 1
1
1 1 b b 2
2
Base
1 0 a 3
3
Dict
1 0 a 1 4
4
1 1 b 5
5
Increment
SelectionVector
Physical & Logical
Physical Logical
Physical Logical Physical Logical
DuckDB - Vectors
• Vectors can be processed as-is (compressed execution)
• Problem: combinatorial explosion!
• Giant code footprint
Flat
Uncompressed array
• Flatten - Convert vector into Flat Vector (i.e. decompress)
1
2
• Need to move/copy data around!
3
4
5
Physical & Logical
• ToUnified - Convert vector to unified format
DuckDB - Vectors
Flat Constant Dictionary
1 0 1 1
1 1
1 1 2 2
2
1 0 1
3
Dict
1 0 1
4
1 1 2
5
SelectionVector
Physical & Logical
Physical Logical
Physical Logical
0
1 0 1
1 0
0
2 1
2 1
0
3 2
0
0
4 3
Unified Format
0
0
5 4
1
Data Selection Data Selection Data Selection
No data copy or data movement required!
DuckDB - Vectors
• Strings are stored in the same format as Umbra
• 16 bytes
• Short strings are inlined (≤ 12 bytes)
• Long strings have a prefix + pointer
• Fast early-out in comparison
[1] Umbra: A Disk-Based System with In-
Memory Performance
DuckDB - Vectors
• Nested types - important for analytics
• Possible solution: store as blobs or strings
• Slow!
• Nested types are stored recursively using vectors
• Allows for highly efficient processing
• Two main nested types: structs and lists
┌────────────────────┐
┌─────────────────────────────────────┐
│ list │
│ struct │
├────────────────────┤
├─────────────────────────────────────┤
│ [1, 2, 3] │
│ {'item': pants, 'price': 42} │
│ [] │
│ NULL │
│ {'item': t-shirt, 'price': 20} │ │ [4, NULL, 6, 7, 8] │
│ {'item': shoes, 'price': NULL} │ │ NULL │
└─────────────────────────────────────┘
└────────────────────┘
DuckDB - Vectors
• Structs store their child vectors and a validity mask
┌─────────────────────────────────────┐
pants 42
│ struct │
. . . ├─────────────────────────────────────┤
│ {'item': pants, 'price': 42} │
t-shirt 20
│ NULL │
shoes .
│ {'item': t-shirt, 'price': 20} │
│ {'item': shoes, 'price': NULL} │
└─────────────────────────────────────┘
Validity item price
DuckDB - Vectors
• Lists are stored as combination of offset/lengths and a child vector
• The child vector can have a different length!
1
┌────────────────────┐
2
│ l │
3
├────────────────────┤
0 - 3
4
│ [1, 2, 3] │
3 - 0
.
│ [] │
3 - 5
6 │ [4, NULL, 6, 7, 8] │
.
│ NULL │
7
└────────────────────┘
8
Offset - Length Child Vector
Query Execution
DuckDB - Pull-Based Model
• DuckDB started as a pull-based system
• “Vector Volcano”
• Every operator implements GetChunk
• Query starts by calling GetChunk on the root
• Nodes recursively call GetChunk on children
DuckDB - Pull-Based Model
• Simplified Hash Join Example
void HashJoin::GetChunk(DataChunk &result) {
if (!build_finished) {
// build the hash table
while(right_child->GetChunk(child_chunk)) {
BuildHashTable(child_chunk);
}
build_finished = true;
}
// probe the hash table
left_child->GetChunk(child_chunk);
ProbeHashTable(child_chunk, result);
}
DuckDB - Pull-Based Model
• In this model:
• Single-threaded execution is straightforward
• Multi-threaded not so much…
• In CURRENT_TIMESTAMP, multi-threaded execution is required!
DuckDB - Parallelism Model
• AWS instances go up to 192 cores
• Multi-threading = potential two-orders of
magnitude speed-up!
DuckDB - Parallelism Model
192 cores
Multi-Threaded Single-Threaded
1 sec > 3 minutes
> 3 hours
1 min
DuckDB - Parallelism Model
• Exchange operator
• Optimizer splits plan into multiple partitions
• Partitions are executed independently
• Operators do not need to be parallelism aware!
DuckDB - Parallelism Model
• Great for bolting parallelism onto a single-threaded system
• But has many problems!
• Plan explosion
• Load imbalance issues
• Added materialization costs
DuckDB - Parallelism Model
• Morsel driven parallelism
• Individual operators are parallelism-aware
• Input data is distributed adaptively
• Parallelism is not baked into the plan
[2014] Morsel-Driven
Parallelism: A NUMA-Aware
Query Evaluation Framework for
the Many-Core Age
Viktor Leis et al.
DuckDB - Pipelines
GROUP BY cid
FIRST(name), SUM(rev+tax)
HASH JOIN
cust.cid=sale.cid
Pipeline 2 (HT Probe + Aggregate)
Scan Scan
cust sale
GROUP BY cid
FIRST(name), SUM(rev+tax)
Pipeline 1 (HT Build)
HASH JOIN
HASH JOIN
cust.cid=sale.cid
cust.cid=sale.cid
Scan
Scan
sale
cust
DuckDB - Pull-Based Model
• How do we implement this in a pull-based volcano model?
• Everything is entangled!
void HashJoin::GetChunk(DataChunk &result) {
if (!build_finished) {
// build the hash table
while(right_child->GetChunk(child_chunk)) {
BuildHashTable(child_chunk);
}
build_finished = true;
}
// probe the hash table
left_child->GetChunk(child_chunk);
ProbeHashTable(child_chunk, result);
}
DuckDB - Push-Based Execution
• Switch to push-based model
• Separate interfaces for sink, source and operator
• Source and sink are parallelism aware!
Source Operator Sink