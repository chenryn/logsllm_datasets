0 
0 
0 
1 
(Byzantine) 12 
(Byzantine) 11 
Table 3. External effects of concurrency 
bugs. 
Table 4. Effects of latent concurrency bugs. 
Finally, 
we found a few (6%) con­
bugs that caused performance 
degradation 
(e.g., 
it to wait forever. 
acquire 
currency 
memory leaks that increase 
server incurs). 
the number of page faults the 
4.3 Latent bugs 
to occur differ 
(or requests) 
Next we analyzed 
that cause the erroneous state 
that cause the external 
to 
In other words, latent 
whether the bugs caused latent errors 
or not. We define a latent bug as one where the (concur­
rent) requests 
from the request 
of the bug to be exposed to the clients 
the application's 
specification). 
cause internal 
an error) 
a failure). 
quest that may not have to run concurrently 
requests. 
by a subsequent 
with any other 
effects 
the violation 
bugs 
corrupted 
(i.e., 
but do not immediately 
is only triggered 
data structures 
to be silently 
A failure 
(i.e., 
re­
cause a wrong output (i.e., 
and has an interesting 
relevant 
fraction 
The fraction 
We found that a 
was somewhat surprising 
is large enough that we believe 
of concurrency 
bugs in 
our study were latent (15% versus 85% non-latent 
bugs). 
This result 
implication. 
there is value in developing 
ternal state of the concurrent 
a recovery 
the correct 
current 
cuted and the application 
bugs from affecting 
even after the con­
that cause the error have already 
been exe­
could prevent 
behavior 
of the application, 
tools that try to recover 
application. 
state is corrupt. 
concurrency 
Performing 
such 
requests 
the in­
We also analyzed 
how latent bugs were categorized 
analysis 
ac­
of their external 
in Table 4 show a very high correlation 
bugs: 92% of the latent bugs manifest 
effects. 
between 
cording to the previous 
The results 
latent and semantic 
themselves 
versely 
that these values are exactly 
of the relatively 
by returning 
small sample size.) 
also 92% of the semantic 
wrong results 
to the client, 
bugs are latent. 
and con­
(The fact 
the same is only a consequence 
We see two possible 
consequences 
of the high correla­
tion between latent and semantic 
methods to address 
have to take into account that they manifest 
through violations 
semantics 
crashing 
or halting), 
themselves 
(rather 
than 
the bar for detecting 
when 
bugs. On the one hand, 
bugs will 
of the application 
caused by latent 
the problems 
which raises 
faults to try to heal the state of the ap­
and becomes a failure. 
On the 
for  the 
methods that 
in the background 
a latent error is activated 
other hand, this opens an opportunity 
handle non-crash 
plication 
of these faults in the foreground. 
tolerating 
(BFT) replication, 
upon, one might be able to get similar 
foreground 
replica that 
replica  that 
checks and recovers 
semantic 
instead 
errors using Byzantine 
Fault Tolerance 
where the output of each request 
is voted 
by having a 
results 
issues the reply, and a background 
of masking the effects 
For instance, 
rather than 
the service 
state. 
of the database 
bugs 
A concrete 
example of a latent bug will help the reader 
surrounding 
updating 
requests 
table contents) 
both the contents 
and the 
to 
the primary replica 
and the binlog structure. 
of the typical 
and semantic. 
This bug is 
the same order for con­
patterns 
Bug # 14262 invol ved con­
understand  some 
that are both latent 
current 
requests 
(e.g., 
caused by the code not enforcing 
that update both the table contents 
current 
binlog. Thus, when a specific set of statements 
the primary replica, 
data by executing 
the statements 
ing on the exact interleaving 
statements 
this bug to the client is only visible 
mary replica 
backup replicas). 
over with a state that 
state (in that it reflects 
execution) 
and subsequent 
those that were previously 
after a fault of the pri­
contact 
the 
In this case, one of the backups will take 
in one order but, depend­
may write those 
order. The result of 
sequence 
will be incoherent 
with 
results 
returned. 
is  sent 
updates the table 
to the binlog in the reverse 
occurs (or when clients 
from the previously 
a different 
of threads, 
otherwise 
diverges 
observed 
for transaction 
In the remainder 
of this section 
we will analyze 
semantic 
First, 
The reason for our focus is 
we found these bugs to have a relevant 
(and 
and more impor­
prevalence.  Second, 
and latent bugs in more detail. 
twofold. 
perhaps unexpected) 
tantly, 
although 
application 
munix [19]), they are not so effective 
maining, 
more subtle types of failures. 
search opportunity 
type of concurrency 
existing 
(e.g., 
at handling 
(e.g., 
Dim­
at handling 
the re­
Thus, there is a re­
tools are very effective 
Rx [28]) and deadlocks 
for improving methods 
that address 
crashes 
this 
bug. 
978-1-4244-7501-8/10/$26.00 
©201O IEEE 
226 
DSN 2010: Fonseca et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:03:53 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
4.4 Characteristics 
of semantic bugs 
We further 
analyzed 
the incorrect 
outputs 
how difficult 
returned 
by se­
it is to de­
mantic bugs in order to determine 
tect them, e.g., using a run-time 
would avoid the use of more expensive 
BFf replication 
[10]. 
monitoring 
tool [30], which 
techniques 
such as 
Number of bugs Persistent? 
Data structure 
Data file 
Index file 
Definition 
file 
Query cache 
Key cache 
Binlog 
11 
9 
8 
7 
6 
5 
Yes 
Yes 
Yes 
No 
No· 
Yes 
Out of all the semantic 
output, 
bugs, we found only one to have 
meaning that the buggy output 
deviated 
from the expected 
a self-inconsistent 
clearly 
bug, the wrong reply returned 
tion about the contents 
time the reply also contains 
the table does not exist in the database. 
of a certain 
reply. In this particular 
to clients  contains 
informa­
table, but at the same 
information 
that indicates 
that 
None of the remaining 
bugs were self-inconsistent, 
im­
Table 5. Most frequent data structures in­
volved in latent bugs. * The contents of the 
cache can also be written back to disk. 
maining 92% involve 
tures. 
inconsistency 
between separate 
struc­
Next we analyzed 
whether the data structures involved 
plying that there are limited 
niques that try to validate 
by analyzing 
the replies. 
We further 
analyzed 
benefits from detection 
tech­
the correctness 
of the application 
output of semantic 
did not fit into either of these groups. 
bugs into two groups. 
these results 
and categorized 
the 
Some of the bugs 
The first group, containing 
58% of these bugs, corre­
ex­
that reflect an ordering 
that is inconsistent 
replies. 
before where binlog entries 
of previously 
with the ordering 
The latent bug we 
were logged in the 
sponds to outputs 
ecuted transactions 
that was implied in previous 
described 
wrong order is an example of such a bug: after the primary 
becomes faulty, 
in which transactions 
differs from the order in which they had been originally 
ecuted. 
in the binlog, 
ex­
the output of the system reflects 
the order 
which 
were recorded 
stored on disk or volatile 
are persistent structures 
kept in memory. Table 5 shows that the three most affected 
data structures 
the database 
mentioned 
bugs involving 
binlog file. We also found a large number of 
caches that are only stored in main memory. 
namely the files that contain 
are persistent, 
the respective 
contents, 
and the afore­
indices, 
structures 
Note, however, 
do not allow us to draw 
that these results 
the probability 
to these data 
bugs, given that we do not know how often 
(and also we cannot claim 
sample of the exist­
conclusions about 
structures trigger 
different  structures 
are accessed 
that we have a perfectly 
ing bugs). 
representative 
that accesses 
Note that the numbers in Table 5  do not add up to the 
total number of latent bugs because certain 
more than one data structure, 
as explained 
before. 
bugs affected 
4.6 Recovering from latent errors 
The second group, containing 
25% of the bugs, corre­
sponds to violations 
lar of the isolation 
that transaction 
concurrent 
by transaction 
of transactional 
semantics, 
in particu­
This means 
of the transactions. 
effects 
some of the updates made 
A could see the intermediate 
of a 
transaction 
B  (e.g., 
B, but not all of them). 
property 
Finally, 
17% of the semantics 
bugs did not fall into either 
of the previous 
two categories. 
4.5 Internal effects of latent bugs 
We also analyzed 
the set of latent bugs in more detail. 
to how the internal 
we paid close attention 
In our analysis, 
state was being corrupted, 
derstanding 
detecting 
for recovering 
so that we could gain better un­
that can be useful for 
the errors before they are exposed to the user and 
of the kinds of techniques 
state of the application. 
the internal 
First, 
we determined 
whether each bug corrupted 
a sin­
data structure, 
or modified two or more data 
way (leaving 
them in  an in­
in  an inconsistent 
state relative 
to each other). 
Only 8% of the latent 
gle high-level 
structures 
correct 
concurrency 
We looked at the ability 
of the application 
to recover 
state). 
mechanisms 
in this section 
The recovery 
are relatively 
from latent bugs after they have caused an error (i.e., cor­
rupted the internal 
consider 
tified the latent errors that can be recovered 
restart 
that do 
We present 
more than one simple recovery 
code. 
in Table 6. Note that some bugs allow 
or other simple mechanisms 
not require 
(e.g., 
recovery-specific 
mechanism. 
extensive 
reloading 
by a server 
the results 
indexes) 
writing 
we 
simple  ones:  we iden­
We found that in one third  of 
to recover 
use simple mechanisms 
they go completely 
chances of adopting proactive 
unnoticed 
by users. This increases 
recovery 
the 
techniques. 
the cases it is possible 
to 
latent errors such that 
4.7 Severity and fixing complexity 
bugs involve a single 
data structure, 
and the re-
of fixing them, according 
to the bug report fields 
Finally, 
we compared 
concurrency 
bugs belonging 
to dif­
and to the 
to their severity 
with respect 
ferent categories 
complexity 
978-1-4244-7501-8/10/$26.00 
©201O IEEE 
227 
DSN 2010: Fonseca et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:03:53 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
Number of bugs 
No simple recovery 
mechanism  8 
Allow for simple recovery:  4 
4 
3 
Server restart 
Other mechanisms 
Table 6. Recovery mechanisms for latent con­
currency bugs. 
Bug immediacy Severity 
Latent 
Non-latent  2.2 
2 
Bug category Severity 
Deadlock 
2.3 
Crash 
1.7 
Error 
2.4 
Hang 
2 
Performance 3 
Semantic 
2.2 
Table 7. Average severity of concurrency 
bugs according to their immediacy and cat­
egory. Maximum severity is rated as 1 (i.e., 
critical 
bug) while minimum severity is rated 
asS. 
these properties. 
that specify 
pared non-latent 
these two properties. 
bugs against 
Additionally, 
latent bugs with respect 
we also com­
to 
in Table 7. The 
severity 
The average 
results 
show that latent 
more severe on average 
of severity 
by external 
the most severe while, 
found to be the least severe. 
of bugs is compared 
bugs were considered 
than non-latent 
effects, 
as expected, 
crash bugs were found to be 
bugs. In the ranking 
performance 
bugs were 
to be slightly 
For the complexity 
of fixing concurrency 
bugs we used 
attempts, 
number of files 
that we extracted 
from the bug reports: 
time to 
four metrics 
fix the bug, number of patching 
changed in the final patch, and the number of comments ex­
changed in the bug reports. 
is perfect, 
in combination 
plexity 
the four complexity 
metrics 
fields contain 
significant 
the average 
Although 
they help us estimate 
in addition 
we also present 
a comparison 
in Table 8. Since some of these 
of fixing these bugs. We present 
the com­
of 
for all four metrics 
outliers, 
none of these metrics 
to presenting 
the median. 
non-latent 
Our analysis 
of the fixing complexity 
ing result: 
to fix than latent bugs in all metrics 
of patches. 
study of the reasons 
a surpris­
bugs were found to be more complex 
except for the number 
so we defer 
We do not have a clear explanation, 
for this to future work. 
revealed 
Bug immediacy Time  Patches  Files  Disc. 
Latent 
Non-latent 137/90 2.7/2 3.9/1 11.6/9 
114/79 3.8/2 2.3/1 10.4/7.5 
Time 
Bug category 
Patches 
Files Disc. 
Deadlock  125/90 1.9/2 1.5/1 9.3/9 
Crash 
Error 
Hang 
Performance 125/92 1.4/2.5 1.8/2 8.2/6 
Semantic  108/67 3.8/2 2.2/1 10.5/8 
128/83 3.5/2 7.7/3 12.9/11 
150/94 3.0/2 4.4/4 17.0111 
210/116 4.5/2 3.8/2 13.2/11 
Table 8. Complexity of fixing concurrency 
bugs according to their immediacy and cat­
egory. For each class of bugs we present the 
average/median for each  of the four metrics: 
time in days, number of patches, number of 
files in the patches and the number of com­
ments in the discussion. 
5 Discussion 
and limitations 
One of the results 
of our study is that the percentage 
of 
(in fact 
First, 
The fact that con­
bugs present 
[15]) is likely 
in bug databases 
to as Heisenbugs 
in the bug database 
when users are faced with 
bugs are underrepresented. 
to their underrepresentation 
bugs are hard to observe and reproduce 
is low. This 
since it has long been believed 
that 
concurrency 
is not very surprising, 
concurrency 
currency 
they are commonly referred 
to contribute 
for three main reasons. 
the bug a  single 
a problem with the software 
Second, even when users are able to reproduce 
machines, 
the developer's 
environments. 
duce the bug, they might not be able to systematically 
produce it using traditional 