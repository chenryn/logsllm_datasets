title:Repairing DoS Vulnerability of Real-World Regexes
author:Nariyoshi Chida and
Tachio Terauchi
7
9
5
3
3
8
9
.
2
2
0
2
.
4
1
2
6
4
P
S
/
9
0
1
1
.
0
1
:
I
O
D
|
E
E
E
I
2
2
0
2
©
0
0
.
1
3
$
/
2
2
/
9
-
6
1
3
1
-
4
5
6
6
-
1
-
8
7
9
|
)
P
S
(
y
c
a
v
i
r
P
d
n
a
y
t
i
r
u
c
e
S
n
o
m
u
i
s
o
p
m
y
S
E
E
E
I
2
2
0
2
2022 IEEE Symposium on Security and Privacy (SP)
Repairing DoS Vulnerability of Real-World Regexes
Nariyoshi Chida
NTT Corporation / Waseda University
PI:EMAIL
Tachio Terauchi
Waseda University
PI:EMAIL
Abstract—There has been much work on synthesizing and
repairing regular expressions (regexes for short) from examples.
These programming-by-example (PBE) methods help the users
write regexes by letting them reflect their intention by examples.
However, the existing methods may generate regexes whose
matching may take super-linear time and are vulnerable to
regex denial of service (ReDoS) attacks. This paper presents
the first PBE repair method that is guaranteed to generate
only invulnerable regexes. Importantly, our method can handle
real-world regexes containing lookarounds and backreferences.
Due to the extensions, the existing formal definitions of ReDoS
vulnerabilities that only consider pure regexes are insufficient.
Therefore, we first give a novel formal semantics and complexity
of backtracking matching algorithms for real-world regexes, and
with them, give the first formal definition of ReDoS vulnerability
for real-world regexes. Next, we present a novel condition called
real-world strong 1-unambiguity that is sufficient for guaran-
teeing the invulnerability of real-world regexes, and formalize
the corresponding PBE repair problem. Finally, we present an
algorithm that solves the repair problem. The algorithm builds
on and extends the previous PBE methods to handle the real-
world extensions and with constraints to enforce the real-world
strong 1-unambiguity condition.
Index Terms—Real-world regexes, ReDoS, synthesis, repair
I. INTRODUCTION
Regular expressions (regexes for short) have become an
integral part of modern programming languages and soft-
ware development, e.g.,
they are used as general purpose
libraries [1], [2], for sanitizing user inputs [3], [4], and
extracting data from unstructured text [5], [6]. Despite the
widespread use of regexes in practice, it is an unfortunate
fact that developers often write regexes which are vulnerable
to regex denial-of-service (ReDoS) attacks in which attackers
craft inputs that cause the regex matching algorithm to take
super linear time [7], [8]. ReDoS is a significant threat to our
society due to the widespread use of regexes [7], [9]–[11].
While some regex engines offer mechanisms to limit their run
time (directly by timeout or indirectly by limiting the number
of backtrackings), determining a proper limit is often difficult,
not to mention that vulnerable regexes may not even have any
reasonable limits that can be assigned as they may struggle
even on legitimate inputs. Furthermore, such options are not
available in many popular regex engines including those in the
standard libraries of Python, Java, and Node.js.
To address the issue, there has been much research on the
topic of overcoming ReDoS vulnerability [12]–[17]. However,
the previous works have focused mainly on the problem of
detecting vulnerable regexes, and the problem of repairing
them remains largely open. As reported by Davis et al. [7],
[18], writing invulnerable regexes is a formidable task that
developers often fail to achieve in practice.
Meanwhile, recent years have seen remarkable progress
on programming-by-example (PBE) methods for synthesizing
and repairing regexes [5], [19]–[24]. In these methods, a set
of positive examples (strings to be accepted) and negative
examples (strings to be rejected) are provided with the goal
to synthesize a regex that correctly classify the examples,
often with additional constraints to bias the synthesis toward
ones syntactically close to the pre-repair regex [22], [24].
PBE methods have the salient advantage of easing the burden
of writing correct regexes by letting the users reflect their
intention by examples [20]–[22], [24]. However, the existing
PBE methods are not designed with resilience to ReDoS in
mind and may generate vulnerable regexes.1
In this paper, we rectify the situation by proposing the
first PBE repair method that is guaranteed to generate only
invulnerable regexes. Importantly, our method can handle the
so-called real-world regexes that have extensions such as
lookarounds, capturing groups, and backreferences [25].
While previous works have investigated formal definitions
of ReDoS vulnerability [12], [14], [16], they only address the
pure regex fragment. The overarching challenge in ReDoS
vulnerabilities is to define the complexity of backtracking
matching algorithm. The previous works for pure regexes
have used nondeterministic finite automata (NFA) to formalize
the behavior of backtracking matching algorithms and its
complexity. Unfortunately, such a NFA-based definition is
difficult for real-world regexes because the expressive power
of real-world regexes is not regular [26].
Our first contribution is the first formal definition of ReDoS
vulnerability for real-world regexes. For this, we introduce a
novel formal semantics of backtracking matching algorithm
for real-world regexes and, by building on it, formally define
the time complexity of backtracking matching algorithms for
real-world regexes. Also, we have discovered a subtle bug
in a previous formal definition of ReDoS vulnerability for
pure regexes [12] which can misclassify some vulnerable
regexes as invulnerable (even for pure regexes). Although the
bug is fixable, this shows the subtlety of formalizing ReDoS
vulnerability.
1 The only exception is the recent work by Li et al. [24], but they only
handle pure regexes and also lack the guarantee to generate only invulnerable
regexes (cf. Section VIII).
© 2022, Nariyoshi Chida. Under license to IEEE.
DOI 10.1109/SP46214.2022.00061
2060
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
Our repair method ensures invulnerability by enforcing the
novel real-world strong 1-unambiguity (RWS1U) introduced
in this paper. RWS1U is inspired by a notion for pure regexes
called strong 1-unambiguity [27], and can be considered as an
extension of it to real-world regexes. We show that RWS1U is
a sufficient condition for invulnerability, and formalize a PBE
repair problem, RWS1U repair problem, whose goal includes
ensuring RWS1U. We prove that the RWS1U repair problem is
NP-hard. We also show that a related notion for pure regexes
called 1-unambiguity (also called deterministic regex) [24],
[28], [29] is insufficient for guaranteeing invulnerability (even
for pure regexes).
Our third contribution is an algorithm for solving the
RWS1U repair problem. Our algorithm builds on the previous
PBE regex repair methods. However, significant extensions
are needed because the previous methods neither support
real-world regexes nor concern ReDoS vulnerability (with
the exception of [24] mentioned above). A key step of the
algorithm is generating SMT constraints that enforce both the
RWS1U condition and consistency with examples. The latter
is enforced by following our novel formal semantics of real-
world regexes, and the former is enforced by using our novel
extended NFA translation that is used to define RWS1U. We
also adapt and extend the key techniques proposed for PBE
regex synthesis and repair, such as the state space pruning
technique by under- and over-approximations [20], [22], with
the support for the real-world extensions and concerns for
ReDoS vulnerability.
We have implemented a prototype of our algorithm in a tool
called REMEDY (Regular Expression Modifier for Ensuring
Deterministic propertY), and have experimented with the tool
on a set of benchmarks of real-world regexes taken from [7].
The experimental results show that REMEDY was able to
successfully repair non-trivial vulnerable regexes from a real-
world data set.
The contributions of the paper are summarized below.
• We initiate a study of ReDoS vulnerabilities for real-
world regexes. To this end, we give a novel formal seman-
tics and the time complexity of backtracking matching
algorithms for real-world regexes, and with it, give the
first formal definition of their ReDoS vulnerability. We
also show a subtle bug in a previous proposal for pure
regexes [12]. (Section III)
• We present the novel real-world strong 1-unambiguity
(RWS1U), and prove that
the condition is sufficient
for guaranteeing invulnerability for real-world regexes.
We define the RWS1U repair problem and prove that
the problem is NP-hard. We also show that a related
condition, 1-unambiguity (i.e., deterministic regex) for
pure regexes [24], [28], [29] is insufficient for ensuring
invulnerability (even for pure regexes). (Section IV)
• We give an algorithm for solving the RWS1U repair
problem that builds on and extends the previous PBE
synthesis and repair methods. Our algorithm extends the
previous methods in two important ways: support for the
real-world extensions and the incorporation of RWS1U
to enforce invulnerability. (Section V)
• We present an implementation of the algorithm in a tool
called REMEDY, and present an evaluation of the tool on
a set of real-world benchmarks. (Section VI)
II. OVERVIEW
We give an informal overview of our repair algorithm by
an example. To illustrate, we use the regex ·∗