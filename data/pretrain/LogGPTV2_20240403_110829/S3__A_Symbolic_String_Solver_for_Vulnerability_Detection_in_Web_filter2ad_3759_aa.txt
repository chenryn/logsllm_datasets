title:S3: A Symbolic String Solver for Vulnerability Detection in Web
Applications
author:Minh-Thai Trinh and
Duc-Hiep Chu and
Joxan Jaffar
S3: A Symbolic String Solver for Vulnerability Detection
in Web Applications
Minh-Thai Trinh
PI:EMAIL
Duc-Hiep Chu
PI:EMAIL
Joxan Jaffar
PI:EMAIL
National University of Singapore
ABSTRACT
Motivated by the vulnerability analysis of web programs which
work on string inputs, we present S3, a new symbolic string solver.
Our solver employs a new algorithm for a constraint language that
is expressive enough for widespread applicability. Speciﬁcally, our
language covers all the main string operations, such as those in
JavaScript. The algorithm ﬁrst makes use of a symbolic represen-
tation so that membership in a set deﬁned by a regular expression
can be encoded as string equations. Secondly, there is a constraint-
based generation of instances from these symbolic expressions so
that the total number of instances can be limited. We evaluate S3
on a well-known set of practical benchmarks, demonstrating both
its robustness (more deﬁnitive answers) and its efﬁciency (about 20
times faster) against the state-of-the-art.
Categories and Subject Descriptors
D.4.6 [Security and Protection]: Veriﬁcation; D.2.5 [Software
Engineering]: Testing and Debugging
General Terms
Security, Reliability, Veriﬁcation
Keywords
String Analysis; String Constraint Solver; Web Applications
1.
INTRODUCTION
Web applications nowadays provide critical services over the In-
ternet and frequently handle sensitive data. Unfortunately, the de-
velopment is error prone, resulting in applications that are vulnera-
ble to attacks by malicious users. The global accessibility of critical
web applications make this an extremely serious problem.
According to the Open Web Application Security Project, or
OWASP for short [26], the most serious web application vulner-
abilities include: (#1) Injection ﬂaws (such as SQL injection) and
(#3) Cross Site Scripting (XSS) ﬂaws. These two vulnerabilities
occur mainly due to inadequate sanitization and inappropriate use
of input strings provided by users.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660372.
How Important is Symbolic String Solving?
To explain why we need string solving, let us look at dynamic anal-
ysis which involves testing an application as a closed entity with a
set of concrete inputs. Its main disadvantage is of course that it
is not a complete method. For example, some program paths may
only be executed if certain inputs are passed as parameters to the
application, but it is very unlikely that a dynamic analyzer can ex-
haustively test an application with all possible inputs. For web ap-
plications, the problem is even more severe since dynamic analysis
needs to take into account not only the value space (i.e., how the
execution of control ﬂow paths depends on input values), but also
an application’s event space (i.e., the possible sequences of user-
interface actions). As a result, there is in general an impractical
number of execution paths to systematically explore, leading to the
“low code coverage” issue of dynamic analysis.
A standard approach to have good or complete coverage is static
analysis. However, the problem here is the existence of false posi-
tives, arising from an over-approximation of the program’s behav-
ior. Recent works to avoid false positives, but still preserve high
code coverage, are based on dynamic symbolic execution (DSE).
Some examples are [28, 4, 5, 23, 12, 30, 15, 16, 17, 14, 29, 9, 8, 24,
35, 21]. These approaches employ both concrete and symbolic ex-
ecution to automatically and systematically generate tests in order
to expose vulnerabilities in web applications. DSE for automated
test generation involves instrumenting and concolically running a
program while collecting path constraints on the inputs. Then it at-
tempts to derive new inputs – using an SMT (Satisﬁability Modulo
Theories) solver – with the hope to steer next executions toward
new program paths. For vulnerability detection, DSE combines the
derived path constraints with the speciﬁcations for attacks, often
given by the security experts, to create queries for the SMT solver.
Code Coverage
False Positives
Executable
Paths (EPs)
Dynamic Analysis
Potentially Low
Low
Unlikely to cover
all EPs
DSE
High
Low
Likely to cover all
EPs
Table 1: DSE as a More Effective Paradigm
In fact, there is a strong connection between an effective vulner-
ability detection framework and symbolic string solving. As shown
in Table 1, DSE achieves higher code coverage. However, because
not all path executed by DSE are guaranteed to be executable, to
avoid false positives we must be able to decide if a (symbolic) path
constraint is satisﬁable or not. Thus a powerful SMT solver, ca-
pable of handling symbolic string variables, is the key to achieve
efﬁcient analyses with high code coverage and low false positives.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
...
...
...
Email: 
...
Figure 1: An Example of Email Address Validation
To illustrate more clearly how constraint solvers can be helpful in
securing web applications, in Fig. 1, we present a JavaScript func-
tion which is used to validate input email addresses. The user ﬁlls
the client-side form, by providing an email address to the HTML
input element with name "email" (and a password, removed for
simplicity). When the Login button is clicked, the browser in-
vokes the JavaScript validating function validateEmail, which
is assigned to the submit event of the form. This function ﬁrst
fetches the email address supplied by the user from the correspond-
ing form ﬁeld and then checks if the email address is valid. Each
student of our department has two email accounts, one from NUS
(nus.edu.sg), the other from SoC (comp.nus.edu.sg). The
web page hence accepts both of these two domains. However, these
two types of accounts have different formats. While the local
part of the former is constructed by one alphabetic characters, fol-
lowed by seven numeric ones, the latter’s simply requires at least
four characters.
The question is whether this web page is vulnerable to an XSS
attack, or to an SQL injection. More speciﬁcally, can the follow-
ing PHP code, with an appropriate instantiation for string variable
$eml, be executed on the server side, leading to an attack:
$eml = $_POST['email'];
$pwd = $_POST['password'];
$stm="SELECT ... where email='$eml' and password='$pwd'";
$result = mysql_query($stm);
The answer is yes for both of the questions. Now, let us explain
the way DSE detects possible vulnerabilities, in comparison with
typical dynamic analyses. Since a dynamic analysis is essentially
black-box testing, it has no knowledge about the JavaScript code.
Thus, it is possible that the dynamic analyzer does not test with
email addresses whose domain is comp.nus.edu.sg, and sub-
sequently, cannot detect SQL injection and XSS vulnerabilities. In
contrast, DSE, which can be seen as white-box testing, enables us
to attempt all execution paths by generating three path constraints,
corresponding to the three program paths of the validateEmail
function.
After symbolically executing the program, DSE frameworks such
as [28] will combine its results with the speciﬁcations for attacks,
given by the security experts, to create queries for the constraint
solver. The speciﬁcations, often come in form of assertions, are
some (regular) grammars encoding a set of strings that would con-
stitute an attack against a particular sink. If the constraint solver
ﬁnds a solution to a query, then this represents an attack that can
reach the critical sink and exploit a code injection vulnerability. For
example, with the speciﬁcation to assert if the input email address
contains ' OR 1=1--, we can in fact generate the input
' OR 1=PI:EMAIL
that leads to an SQL injection. Similarly, a speciﬁcation for an
XSS attack  would help us
to generate the input email address
@comp.nus.edu.sg
that can be exploited by attackers.
In summary for this subsection, DSE, presently the state-of-the-
art in vulnerability detection, is intimately tied to being able to pro-
vide deﬁnitive answers for the derived constraint queries. In the
case of JavaScript and web applications, since the constraints of-
ten concern string variables, symbolic string solving is thus the key
to detect vulnerabilities in this class of applications. As the en-
countered string constraints may be in an undecidable class, it is
important to have a solver which returns a deﬁnitive answer often
and in a timely manner.
We next describe the main contribution of this paper, a new con-
straint solver S3, which stands for Symbolic String Solver. Our
solver makes use of Z3 [11], in order to leverage the recent ad-
vances in modern SMT solvers.
What Language Do We Need?
We ﬁrst argue that a pure string language does not sufﬁce to analyze
web applications. This is due to the fact that non-string operations
(e.g., boolean, arithmetic constraints) are also widely used in web
applications. Moreover, their use is often intertwined with string
operations, such as in the case of string length — a string-to-integer
constraint. Reasoning about strings and non-strings simultaneously
is thus necessary. In other words, we need to deal with a multi-
sorted theory which includes, at least, strings and integers.
To amplify this point, let us now state some statistics from a com-
prehensive study of practical JavaScript applications [28]. Con-
straints arising from the applications have an average (per bench-
mark query) of 63 JavaScript string operations, while the remaining
are boolean, logical and arithmetic constraints. The largest fraction
are for operations like indexOf, length (78%). A signiﬁcant
fraction of the operations, including substring (5%), replace
(8%), and split, match (1%). Of the match, split and
replace operations, 31% are based on regular expressions. Op-
erations such as replace and split give rise to new strings
from the original ones, thereby giving rise to constraints involving
multiple string variables.
To summarize, constraints of interest are either non-strings (e.g.,
bool-sort, int-sort and particularly length constraints) or strings such
as: string equations, membership predicates and high-level string
operations, which are over multiple string variables. It is folklore
that query with just basic string equations along with length con-
straints on the string variables is extremely hard to solve (its decid-
ability is open). Therefore, the validation of any approach can only
realistically be done empirically.
S3: A Robust and Incremental String Solver
Although there exist solvers that can reason about both string and
non-string constraints (e.g., [28, 6, 27, 39]), they depend on strings
being bounded in length. Unbounded regular expressions, which
can be constructed using Kleene star operation, are not supported
Thus the supported high-level operations are only in bounded forms.
For example, instead of fully supporting replace function, which
could mean replacement of all occurrences. existing tools support
an operation to replace a ﬁxed number of occurrences in a string.
It may be argued that certain bounds sufﬁce for a class of appli-
cations. There is a more important reason why the bound depen-
dency is bad: the algorithms that rely on the bounded reasoning
are highly combinatorial in approach. In other words, the problem
at hand is broken down into cases, the number of which is often a
large combinatorial combination arising from some given bounds.
Finally, we mention [1], where there is a real requirement for rea-
soning about unbounded strings. In verifying client-side input val-
idation functions, a bounded string solver can only ﬁnd policy vio-
lations but it cannot prove the conformance to a given policy. There
are certainly some solvers [19, 12, 36, 37] that can reason about un-
bounded strings. However, their key weakness is that they cannot
handle non-string constraints, particularly length constraints. As
shown in the statistics above, missing length constraints (whose ap-
pearance is frequent) will lead to many false positives. This clearly
is not acceptable.
With regard to all the arguments above, we now conclude this
Section with three important features of S3.
First, S3 is expressive (Section 2). Speciﬁcally, it is the ﬁrst
to handle unbounded regular expressions in the presence of length
constraints, and express precisely high-level string operations, which
ultimately enables a more accurate string analysis.
Second, S3 is robust. This means that S3 is able to provide
deﬁnitive answers to a new level, far beyond the state-of-the-art.
This in turn means we can detect more vulnerabilities and more
bugs. We demonstrate in Section 6 with two case studies:
• The ﬁrst compares with Kaluza – the core of Kudzu [28] – a
JavaScript symbolic execution framework. We show that S3
is several times faster, and helps detect many more paths that
reach the critical sink, that is, paths that are vulnerable.
• The second compares with Z3-str [39]. We show S3 reasons
about length constraints much more effectively than Z3-str.
This leads to a large increase in applicability to web pro-
grams, because these kind of constraints are widely used.
Third, S3 is efﬁcient, and one key reason is that it is incremen-
tal. Our algorithm for string theory is designed in an incremental
fashion driven by the try-and-backtrack procedure of the Z3 core
(Section 4), so that given a set of input constraints, we perform
incremental reduction for string variables until the variables are
bounded with constant strings/characters. Another technical chal-
lenge is how to reason, effectively and efﬁciently, about the Kleene
star and high-level operations such as replace (in its most gen-