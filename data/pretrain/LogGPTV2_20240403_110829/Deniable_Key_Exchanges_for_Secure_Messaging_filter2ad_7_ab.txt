cally to the corresponding functions of a PKE scheme; NCSim(r),
a rigged ciphertext generation function; and NCEqv(pk, γ, α, m),
an equivocation function. NCSim produces: pk, a public key; γ, a
ciphertext; and α, some auxiliary information. Public keys and ci-
phertexts produced by NCSim are identically distributed to public
keys and ciphertexts produced by NCGen and NCEnc, respectively.
If NCEqv is called with (pk, γ, α) produced by NCSim, it gener-
ates values sk, r∗, and rN CE such that NCGen(r∗) = (pk, sk)
and NCEnc(pk, m, rN CE) = γ.
In other words, it uses α to
generate a secret key sk corresponding to pk such that the pre-
viously generated γ decrypts to m using sk. All of this is accom-
plished while making key pair (pk, sk) appear as though it were
honestly generated using NCGen, and γ as though it was honestly
generated using NCEnc. There are several existing NCE construc-
tions [6,8,11,31], but they are all considerably more expensive than
the other primitives used in our protocols.
Ring Signatures. Ring signature schemes, originally proposed
by Rivest et al. [24], are a specialized type of digital signature
scheme. A ring signature is veriﬁably produced by a member of a
given set, but the exact identity of the signer cannot be determined.
A ring signature scheme consists of three functions: RSGen(r),
a key generation function; RSig(pk, sk, R, m, r), a signing func-
tion; and RVrf(R, σ, m), a veriﬁcation function. The ring R is a
set of n public keys {pk1, pk2, . . . , pkn} that could possibly have
produced the signature. It is required that n > 1, (pk, sk) was gen-
erated with RSGen, and pk ∈ R. r controls the randomization of
the output. We require the use of ring signature schemes exhibiting
correctness, anonymity against full key exposure, and unforgeabil-
ity with respect to insider corruption [2].
4. THE WALFISH PROTOCOL
In his thesis, Walﬁsh [29] introduced Φdre.1 Φdre is the only
previously deﬁned DAKE of which we are aware that provides de-
niability against both online and ofﬂine judges while simultane-
ously providing forward secrecy.
To prove the security of Φdre, Walﬁsh extended Canetti’s Uni-
versal Composability (UC) framework [4] to produce the General-
ized UC (GUC) framework [29]. Security proofs in the UC frame-
work demonstrate that real protocols operating in the presence of
an adversary A behave identically to idealized protocols, wherein
a trusted central server with secure connections to the protocol par-
ticipants executes an “ideal functionality” program, in the presence
of an adversary S; in other words, these settings are indistinguish-
able from the perspective of a “distinguishing environment” Z. A
common operation for ideal functionalities is to send a “delayed
message” to a party, where the adversary S is allowed to withhold
or delay the message arbitrarily (even if the message contents are
hidden from S). Unfortunately, the UC framework does not pro-
vide security guarantees when information is shared between pro-
tocol sessions (e.g., as in a PKI). GUC differs from UC in that it al-
lows multiple concurrent protocol sessions with shared information
that is accessible by both the adversary and Z. Additionally, Z is
permitted to execute arbitrary other protocols. Shared information
is represented by persistent machines running “shared functionali-
ties”. A GUC-based security model in which a shared functionality
G is accessible is called a G-hybrid model. Despite this additional
distinguishing power, GUC can still provide the usual UC security
guarantees. A simpliﬁed but equivalent framework, the External-
subroutine UC (EUC) framework, can be used to prove security in
the GUC framework more easily [29]. Throughout the remainder
of this work, we assume some familiarity with the UC framework.
4.1 Protocol Φdre
Φdre, depicted in Figure 1, is a two-round interactive DAKE.2
Each message sent between I and R (other than the introductory
message asserting identities) is encrypted using DRE under the
public keys of I and R. This guarantees that all three messages
can be read by both I and R, but nobody else (unless either I or
R has been corrupted). To provide authentication, the core of the
protocol involves each party echoing a nonce generated by their
partner, thereby proving that they can decrypt the communications.
Since only I and R can decrypt the DRE, and each party knows that
they did not produce the response to their nonce themselves, this
provides non-transferable authentication.
In addition, I includes
in its encrypted message an ephemeral public key pk for an NCE
scheme. R generates the shared secret for the session, and encrypts
it using pk as part of its last message to I.
It is trivial for anyone with access to the long-term public keys
to forge protocol transcripts between any two parties, even with-
out access to any long-term secret keys. An ofﬂine forger of this
type merely needs to simulate both participants; although it cannot
decrypt the DRE layer itself, it already knows the contents of all
1Φdre was later restated in a publication by Dodis et al. [12].
2In practice, the protocol can be collapsed into three ﬂows by hav-
ing the party denoted as R in Figure 1 send the session identiﬁer
and party names.
I
R
sid, “I”, “R”
DREnc(P KI , P KR, sid(cid:107)η1)
$←− {0, 1}λ
(pk, sk) ← NCGen()
η2
DREnc(P KI , P KR, sid(cid:107)η1(cid:107)η2(cid:107)pk))
DREnc(P KI , P KR, sid(cid:107)η2(cid:107)NCEnc(pk, k))
$←− {0, 1}λ
η1
k $←− {0, 1}λ
Figure 1: Φdre [29]. The shared secret is k.
messages. Deniability against online judges is provided because
each party can simulate the behavior of the other; the DRE allows
misinformants to read the contents of any messages that the judge
produces on their behalf. The use of NCE is only needed in the non-
erasure model (where we assume that memory cannot be erased)
with semi-adaptive corruptions (i.e., the adversary may not corrupt
participants while the protocol is executing); if erasures are allowed
or corruptions are only static, then a standard PKE scheme sufﬁces.
Walﬁsh used the GUC framework to prove that Φdre provides
its claimed security and deniability properties with semi-adaptive
corruptions in the ¯Gkrk-hybrid model [29]. ¯Gkrk (key registration
with knowledge) is a shared functionality that models a PKI. Any
party P can register for a key pair with ¯Gkrk. ¯Gkrk generates the
requested key pair directly, thereby modeling a PKI that requires
proof of knowledge of secret keys. A corrupted party can override
this by providing its own key pair for storage. P KP , the public key
for a party P , can be retrieved from ¯Gkrk by any machine. ¯GF
krk
also allows SKP , the secret key for party P , to be retrieved by an
honest machine executing F or by P if it has been corrupted.
The deniability of Φdre is necessarily imperfect: if an adversary
is willing to disrupt the protocol in such a way that it is guaranteed
to abort before completion, then incriminating information demon-
strating that I was attempting to communicate with R can be re-
leased. If Justin, an online judge, instructs Mallory, the adversary,
to modify the ﬁrst ﬂow from R to I to an encryption of nonce η(cid:48)
1
known only to Justin (and thereby inevitably cause R to abort), then
Mallory will need to provide I’s response to R. This requires Mal-
lory to actually interact with the real I (i.e., Mallory is a legitimate
informant), or to compromise SKI or SKR without the knowl-
edge of Justin (something disallowed by the GUC framework). If
Mallory attempts to simulate a response, then Justin can later in-
struct Mallory to corrupt a party to recover their secret key. Justin
can then use this secret key to decrypt the simulated response, and
determine that it did not include η(cid:48)
1. Walﬁsh accounts for this weak-
ness of Φdre in the security proof by deﬁning an incrimination pro-
cedure called IncProc. If the adversary causes the protocol to abort,
it gains access to IncProc, which releases incriminating information
that precisely models the real-world leakage.
4.2 Efﬁcient Standard-Model Instantiation
In order to implement Φdre, we must select a DRE scheme to
use. Unfortunately, nearly all existing DRE schemes require use of
the random oracle model. The DRE construction of Chow et al. [9]
is relatively efﬁcient and is secure in the standard model, but it is
still expensive compared to simple encryption schemes. Alongside
the original deﬁnition of Φdre, Walﬁsh describes a construction
of a generic DRE scheme [29]. This scheme involves encrypting
the plaintext twice using a PKE scheme with IND-CCA2 security,
and then providing two non-interactive zero-knowledge proofs of
knowledge (NIZKPK) demonstrating that the encrypted plaintexts
are equal. Unfortunately, NIZKPK schemes are either highly inefﬁ-
cient or require random oracles. In this section, we describe a new
DRE construction that improves the performance of Φdre while
still maintaining its security properties in the standard model.
We begin by making an important observation about Φdre: it is
an interactive protocol that takes place between two known parties.
While DRE in general is a non-interactive protocol, allowing the
DRE scheme to require interactivity does not negatively impact the
usability of the overall scheme. We are able to do this because
for each encryption of a message, the only party that will need to
decrypt the message is available for interactive communications.
Our basic approach to the construction is similar to Walﬁsh’s
general DRE scheme, but we use an interactive zero-knowledge
proof of knowledge (ZKPK) scheme instead. While we will only
describe one possible instantiation, any PKE scheme with IND-
CCA2 security can be combined with any interactive ZKPK of
plaintext equality. This DRE remains “publicly veriﬁable” in the
sense that the ZKPK veriﬁer can verify the correctness of the ci-
phertexts even if they do not know any secret keys; this is sufﬁ-
cient for use in Φdre. As a PKE scheme, we make use of the cryp-
tosystem published by Cramer and Shoup [10]. The Cramer-Shoup
scheme provides IND-CCA2 security in the standard model with
only the DDH assumption. To prove that the two ciphertexts con-
tain identical messages and are of a valid format, we use a Σ ZKPK
of the kind described by Schnorr [25]. The resulting scheme is
secure with only the DDH assumption for the underlying Cramer-
Shoup group, and consists of the following functions:
DRGen(r): key generation is the same as in the Cramer-Shoup
scheme [10]. The resulting public key for a user consists of a group
description (G, q, g1, g2) and values c = gx1
1 , and
h = gz
DREnc(pk1, pk2, m, r): m is encrypted twice using the Cramer-
Shoup scheme (once for each public key), and a ZKPK of plain-
text equality is produced. r is interpreted as r = k1(cid:107)k2 and is
used to randomize the encryptions of m. Given public key pki =
(Gi, qi, g1i, g2i, ci, di, hi), the ciphertexts consist of u1i = gki
1i ,
for i ∈ {1, 2} and
u2i = gki
αi = H(u1i(cid:107)u2i(cid:107)ei) using a collision-resistant hash function H.
The result also includes an interactive ZKPK that proceeds be-
tween the prover P (the party calling DREnc) and the veriﬁer V
(the party that will call DRDec) as follows:
1. P generates random values mi ∈ [0, qi) for i ∈ 1, 2. P then
i )mi, and T4 =
2 , d = gy1
1. The corresponding secret key is (x1, x2, y1, y2, z).
i m, and vi = cki
2i , T3i = (cidαi
2i , ei = hki
1 gx2
i dkiαi
i
computes T1i = gmi
m1
h
1
m2
2
1i , T2i = gmi
, and sends these values to V.
h
2. V generates random value L and sends it to P.
3. P computes ni = mi − Lki (mod qi) for i ∈ {1, 2} and sends
these values to V.
4. V accepts the encryption as valid if the following equalities
?=
?= gni
1i, T2i
2i uL
2i, T3i
hold for i ∈ {1, 2}: T1i
?= h
(cidαi
h
i , and T4
i )ni vL
?= gni
1i uL
)L.
( e1
e2
n1
1
n2
2
1i uy2i
DRDec(pk1, pk2, ski, γ): γ is parsed to locate the encryption for
pki, and decryption proceeds as in the Cramer-Shoup scheme. Let
ski = (x1i, x2i, y1i, y2i, zi). At this point, the recipient of γ has
already veriﬁed that the ciphertexts are of the correct form and
that they contain encryptions of the same message as a result of
the interactive ZKPK. In addition, the recipient computes αi =
H(u1i(cid:107)u2i(cid:107)ei) and then veriﬁes that ux1i
2i )αi ?= vi.
1i ux2i
2i (uy1i
The message m is recovered using m = ei
.
zi
u
1i
The resulting protocol consists of 9 messages (plus an additional
message for the introductory identity assertions). This instantia-
tion of Φdre is very efﬁcient compared to implementations using
non-interactive DRE in the standard model, which typically require
hundreds of group elements to be transmitted [9]. While we do not
prove the security of this variant here, the original proof by Wal-
ﬁsh [29] can be extended without issue, as this interactive DRE
construction satisﬁes all of the required properties of the original
protocol deﬁnition. We caution that the interactive ZKPK sessions
must not be interleaved in order to preserve online repudiation (i.e.,
the veriﬁer must wait for all ZKPK message ﬂows to complete be-
fore decrypting the message). We also note that, if an implementer
is willing to accept the use of the random oracle model, then this
instantiation of DRE can be made non-interactive through the use