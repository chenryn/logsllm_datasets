%s
：在⽅括号中指定⼀组匹配的字符（⽐如 ），遇到不在集合之中的字符，匹配将会停
%[] %[0-9]
⽌。
上⾯所有占位符之中，除了 以外，都会⾃动忽略起⾸的空⽩字符。 不忽略空⽩字符，总是返回当前
%c %c
第⼀个字符，⽆论该字符是否为空格。如果要强制跳过字符前的空⽩字符，可以写成 ，
scanf(" %c", &ch)
即 前加上⼀个空格，表示跳过零个或多个空⽩字符。
%c
下⾯要特别说⼀下占位符 ，它其实不能简单地等同于字符串。它的规则是，从当前第⼀个⾮空⽩字符
%s
开始读起，直到遇到空⽩字符（即空格、换⾏符、制表符等）为⽌。因为 不会包含空⽩字符，所以⽆
%s
法⽤来读取多个单词，除⾮多个 ⼀起使⽤。这也意味着， 不适合读取可能包含空格的字符
%s scanf()
串，⽐如书名或歌曲名。另外， 遇到 占位符，会在字符串变量末尾存储⼀个空字符 。
scanf() %s \0
将字符串读⼊字符数组时，不会检测字符串是否超过了数组⻓度。所以，储存字符串时，很可能
scanf()
会超过数组的边界，导致预想不到的结果。为了防⽌这种情况，使⽤ 占位符时，应该指定读⼊字符串
%s
的最⻓⻓度，即写成 ，其中的 是⼀个整数，表示读取字符串的最⼤⻓度，后⾯的字符将被丢
%[m]s [m]
弃。
char name[11];
scanf("%10s", name);
上⾯示例中， 是⼀个⻓度为 11 的字符数组， 的占位符 表示最多读取⽤户输⼊的 10
name scanf() %10s
个字符，后⾯的字符将被丢弃，这样就不会有数组溢出的⻛险了。
赋值忽略符 #
有时，⽤户的输⼊可能不符合预定的格式。
scanf("%d-%d-%d", &year, &month, &day);
上⾯示例中，如果⽤户输⼊ ，就会正确解读出年、⽉、⽇。问题是⽤户可能输⼊其他格式，⽐
2020-01-01
如 ，这种情况下， 解析数据就会失败。
2020/01/01 scanf()
为了避免这种情况， 提供了⼀个赋值忽略符（assignment suppression character） 。只要
scanf() *
把 加在任何占位符的百分号后⾯，该占位符就不会返回值，解析后将被丢弃。
*
scanf("%d%*c%d%*c%d", &year, &month, &day);
上⾯示例中， 就是在占位符的百分号后⾯，加⼊了赋值忽略符 ，表示这个占位符没有对应的变量，
%*c *
解读后不必返回。
sscanf() #
函数与 很类似，不同之处是 从字符串⾥⾯，⽽不是从⽤户输⼊获取数据。它
sscanf() scanf() sscanf()
的原型定义在头⽂件 ⾥⾯。
stdio.h
int sscanf(const char* s, const char* format, ...);
的第⼀个参数是⼀个字符串指针，⽤来从其中获取数据。其他参数都与 相同。
sscanf() scanf()
主要⽤来处理其他输⼊函数读⼊的字符串，从其中提取数据。
sscanf()
fgets(str, sizeof(str), stdin);
sscanf(str, "%d%d", &i, &j);
上⾯示例中， 先从标准输⼊获取了⼀⾏数据（ 的介绍详⻅下⼀章），存⼊字符数组
fgets() fgets()
。然后， 再从字符串 ⾥⾯提取两个整数，放⼊变量 和 。
str sscanf() str i j
的⼀个好处是，它的数据来源不是流数据，所以可以反复使⽤，不像 的数据来源是流数
sscanf() scanf()
据，只能读取⼀次。
的返回值是成功赋值的变量的数量，如果提取失败，返回常量 EOF。
sscanf()
getchar()，putchar() #
（1）getchar()
函数返回⽤户从键盘输⼊的⼀个字符，使⽤时不带有任何参数。程序运⾏到这个命令就会暂
getchar()
停，等待⽤户从键盘输⼊，等同于使⽤ ⽅法读取⼀个字符。它的原型定义在头⽂件 。
scanf() stdio.h
char ch;
ch = getchar();
scanf("%c", &ch);
不会忽略起⾸的空⽩字符，总是返回当前读取的第⼀个字符，⽆论是否为空格。如果读取失
getchar()
败，返回常量 EOF，由于 EOF 通常是 ，所以返回值的类型要设为 int，⽽不是 char。
-1
由于 返回读取的字符，所以可以⽤在循环条件之中。
getchar()
while (getchar() != '\n')
;
上⾯示例中，只有读到的字符等于换⾏符（ ），才会退出循环，常⽤来跳过某⾏。 循环的循环
\n while
体没有任何语句，表示对该⾏不执⾏任何操作。
下⾯的例⼦是计算某⼀⾏的字符⻓度。
int len = 0;
while(getchar() != '\n')
len++;
上⾯示例中， 每读取⼀个字符，⻓度变量 就会加 1，直到读取到换⾏符为⽌，这时 就
getchar() len len
是该⾏的字符⻓度。
下⾯的例⼦是跳过空格字符。
while ((ch = getchar()) == ' ')
;
上⾯示例中，结束循环后，变量 等于第⼀个⾮空格字符。
ch
（2）putchar()
函数将它的参数字符输出到屏幕，等同于使⽤ 输出⼀个字符。它的原型定义在头⽂
putchar() printf()
件 。
stdio.h
putchar(ch);
printf("%c", ch);
操作成功时， 返回输出的字符，否则返回常量 EOF。
putchar()
（3）⼩结
由于 和 这两个函数的⽤法，要⽐ 和 更简单，⽽且通常是⽤宏来实
getchar() putchar() scanf() printf()
现，所以要⽐ 和 更快。如果操作单个字符，建议优先使⽤这两个函数。
scanf() printf()
puts() #
函数⽤于将参数字符串显示在屏幕（stdout）上，并且⾃动在字符串末尾添加换⾏符。它的原型定
puts()
义在头⽂件 。
stdio.h
puts("Here are some messages:");
puts("Hello World");
上⾯示例中， 在屏幕上输出两⾏内容。
puts()
写⼊成功时， 返回⼀个⾮负整数，否则返回常量 EOF。
puts()
gets() #
函数以前⽤于从 读取整⾏输⼊，现在已经被废除了，仍然放在这⾥介绍⼀下。
gets() stdin
该函数读取⽤户的⼀⾏输⼊，不会跳过起始处的空⽩字符，直到遇到换⾏符为⽌。这个函数会丢弃换⾏
符，将其余字符放⼊参数变量，并在这些字符的末尾添加⼀个空字符 ，使其成为⼀个字符串。
\0
它经常与 配合使⽤。
puts()
char words[81];
puts("Enter a string, please");
gets(words);
上⾯示例使⽤ 在屏幕上输出提示，然后使⽤ 获取⽤户的输⼊。
puts() gets()
由于 获取的字符串，可能超过字符数组变量的最⼤⻓度，有安全⻛险，建议不要使⽤，改为使⽤
gets()
。
fgets()
全⽂完
本⽂由 简悦 SimpRead 转码，⽤以提升阅读体验，原⽂地址
⽂件操作 语⾔教程 ⽹道
- C -
⽹道（WangDoc.com），互联⽹⽂档计划
“
⽹道（WangDoc.com），互联⽹⽂档计划
本章介绍 C 语⾔如何操作⽂件。
⽂件指针 #
C 语⾔提供了⼀个 FILE 数据结构，记录了操作⼀个⽂件所需要的信息。该结构定义在头⽂件 ，所
stdio.h
有⽂件操作函数都要通过这个数据结构，获取⽂件信息。
开始操作⼀个⽂件之前，就要定义⼀个指向该⽂件的 FILE 指针，相当于获取⼀块内存区域，⽤来保存⽂件
信息。
FILE* fp;
上⾯示例定义了⼀个 FILE 指针 。
fp
下⾯是⼀个读取⽂件的完整示例。
#include 
int main(void) {
FILE* fp;
fp = fopen("hello.txt", "r");
char c = fgetc(fp);
printf("%c\n", c);
fclose(fp);
}
上⾯示例中，新建⽂件指针 以后，依次使⽤了下⾯三个⽂件操作函数，分成三个步骤。其他的⽂件操
fp
作，⼤致上也是这样的步骤。
第⼀步，使⽤ 打开指定⽂件，返回⼀个 File 指针。如果出错，返回 NULL。
fopen()
它相当于将指定⽂件的信息与新建的⽂件指针 相关联，在 FILE 结构内部记录了这样⼀些信息：⽂件内
fp
部的当前读写位置、读写报错的记录、⽂件结尾指示器、缓冲区开始位置的指针、⽂件标识符、⼀个计数
器（统计拷⻉进缓冲区的字节数）等等。后继的操作就可以使⽤这个指针（⽽不是⽂件名）来处理指定⽂
件。
同时，它还为⽂件建⽴⼀个缓存区。由于存在缓存区，也可以说 函数 “打开⼀个了流”，后继的读
fopen()
写⽂件都是流模式。
第⼆步，使⽤读写函数，从⽂件读取数据，或者向⽂件写⼊数据。上例使⽤了 函数，从已经打开
fgetc()
的⽂件⾥⾯，读取⼀个字符。
⼀调⽤，⽂件的数据块先拷⻉到缓冲区。不同的计算机有不同的缓冲区⼤⼩，⼀般是 512 字节或
fgetc()
是它的倍数，如 4096 或 16384。随着计算机硬盘容量越来越⼤，缓冲区也越来越⼤。
从缓冲区读取数据，同时将⽂件指针内部的读写位置指示器，指向所读取字符的下⼀个字符。所
fgetc()
有的⽂件读取函数都使⽤相同的缓冲区，后⾯再调⽤任何⼀个读取函数，都将从指示器指向的位置，即上
⼀次读取函数停⽌的位置开始读取。
当读取函数发现已读完缓冲区⾥⾯的所有字符时，会请求把下⼀个缓冲区⼤⼩的数据块，从⽂件拷⻉到缓
冲区中。读取函数就以这种⽅式，读完⽂件的所有内容，直到⽂件结尾。不过，上例是只从缓存区读取⼀
个字符。当函数在缓冲区⾥⾯，读完⽂件的最后⼀个字符时，就把 FILE 结构⾥⾯的⽂件结尾指示器设置为
真。于是，下⼀次再调⽤读取函数时，会返回常量 EOF。EOF 是⼀个整数值，代表⽂件结尾，⼀般
是 。
-1
第三步， 关闭⽂件，同时清空缓存区。
fclose()
上⾯是⽂件读取的过程，⽂件写⼊也是类似的⽅式，先把数据写⼊缓冲区，当缓冲区填满后，缓存区的数
据将被转移到⽂件中。
fopen() #
函数⽤来打开⽂件。所有⽂件操作的第⼀步，都是使⽤ 打开指定⽂件。这个函数的原型
fopen() fopen()
定义在头⽂件 。
stdio.h
FILE* fopen(char* filename, char* mode);
它接受两个参数。第⼀个参数是⽂件名 (可以包含路径)，第⼆个参数是模式字符串，指定对⽂件执⾏的操
作，⽐如下⾯的例⼦中， 表示以读取模式打开⽂件。
r
fp = fopen("in.dat", "r");
成功打开⽂件以后， 返回⼀个 FILE 指针，其他函数可以⽤这个指针操作⽂件。如果⽆法打开⽂件
fopen()
（⽐如⽂件不存在或没有权限），会返回空指针 NULL。所以，执⾏ 以后，最好判断⼀下，有没
fopen()
有打开成功。
fp = fopen("hello.txt", "r");
if (fp == NULL) {
printf("Can't open file!\n");
exit(EXIT_FAILURE);
}
上⾯示例中，如果 返回⼀个空指针，程序就会报错。
fopen()
的模式字符串有以下⼏种。
fopen()
：读模式，只⽤来读取数据。如果⽂件不存在，返回 NULL 指针。
r
：写模式，只⽤来写⼊数据。如果⽂件存在，⽂件⻓度会被截为 0，然后再写⼊；如果⽂件不存
w
在，则创建该⽂件。
：写模式，只⽤来在⽂件尾部追加数据。如果⽂件不存在，则创建该⽂件。
a
：读写模式。如果⽂件存在，指针指向⽂件开始处，可以在⽂件头部添加数据。如果⽂件不存
r+
在，返回 NULL 指针。
：读写模式。如果⽂件存在，⽂件⻓度会被截为 0，然后再写⼊数据。这种模式实际上读不到
w+
数据，反⽽会擦掉数据。如果⽂件不存在，则创建该⽂件。
：读写模式。如果⽂件存在，指针指向⽂件结尾，可以在现有⽂件末尾添加内容。如果⽂件不
a+
存在，则创建该⽂件。
上⼀⼩节说过， 函数会为打开的⽂件创建⼀个缓冲区。读模式下，创建的是读缓存区；写模式
fopen()
下，创建的是写缓存区；读写模式下，会同时创建两个缓冲区。C 语⾔通过缓存区，以流的形式，向⽂件
读写数据。
数据在⽂件⾥⾯，都是以⼆进制形式存储。但是，读取的时候，有不同的解读⽅法：以原本的⼆进制形式
解读，叫做 “⼆进制流”；将⼆进制数据转成⽂本，以⽂本形式解读，叫做 “⽂本流”。写⼊操作也是如此，
分成以⼆进制写⼊和以⽂本写⼊，后者会多⼀个⽂本转⼆进制的步骤。
的模式字符串，默认是以⽂本流读写。如果添加 后缀（表示 binary），就会以 “⼆进制流” 进
fopen() b
⾏读写。⽐如， 是读取⼆进制数据模式， 是写⼊⼆进制数据模式。
rb wb
模式字符串还有⼀个 后缀，表示独占模式（exclusive）。如果⽂件已经存在，则打开⽂件失败；如果⽂
x
件不存在，则新建⽂件，打开后不再允许其他程序或线程访问当前⽂件。⽐如， 表示以独占模式写⼊
wx
⽂件，如果⽂件已经存在，就会打开失败。
标准流 #
Linux 系统默认提供三个已经打开的⽂件，它们的⽂件指针如下。