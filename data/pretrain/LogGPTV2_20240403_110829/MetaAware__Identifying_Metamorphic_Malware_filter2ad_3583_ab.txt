instructions in each maximal trace are symbolically exe-
cuted in a very limited way. Currently, this symbolic execu-
tion is simply the propagation of constant values. Suppose
the ﬁrst (earliest) instruction in a trace assigns a constant
value c to a register or memory location, and this constant
value can be propagated to the target system call Ii as the
address to which ﬂow of control will occur. This call
instruction and the (constant) target address then form an
element of a subpattern for a single maximal trace ending at
Ii. Note that this symbolic execution is not sophisticated
enough to recognize all target addresses unambiguously.
For instance, some addresses may be computed from infor-
mation that is not available until runtime. Therefore, when
an instruction cannot be symbolically executed, the propa-
gated constants are bound to it and recorded. All such in-
structions in their intermediate representation are recorded
in order and form an element of the subpattern for a single
maximal trace ending at Ii. An executable instruction in a
maximal trace is not included in the element.
The subpattern for Ii, denoted Ui, is the set of all such
elements for all maximal traces ending at Ii. The set of all
such subpatterns Ui for all the system or function calls in
code fragment p is called the pattern of p, and is denoted as
P p. The intuition behind this deﬁnition of a program pat-
tern is that a malware program will normally make use of
some well-deﬁned system services, whose addresses must
be found (so that they can be accessed) in a well deﬁned
way. Attempts to obfuscate the program function, without
changing the set of system or library function calls, can still
leave this behavior visible to inspection. Even obfuscation
of the target of a system call may leave the true target ex-
posed as one possibility. Since the proposed method uses
all possible traces, this true target will remain part of the
pattern of the code fragment. The use of both symbolic ex-
ecution and control ﬂow analysis for disassembly will also
overcome many known methods of obfuscation, as will be
shown in section 4.
Figure 1 shows an example of the the patterns gener-
ated for code fragments of the Sapphire worm, and for a
metamorphic variant of this worm. For purposes of illus-
tration, each sub-pattern is presented in Intel x86 assem-
bly language form, and is a result of data ﬂow analysis and
symbolic execution. For instance, subpattern 1 of pattern
P A results from symbolic execution of the instruction trace
mov esi, [0x42AE1018] || call [esi], in which
the second instruction operand depends on the ﬁrst instruc-
tion. Subpattern 3 of pattern P A has two elements, which
result from two traces whose target is the same library func-
tion call. In this example, there happens to be multiple sub-
patterns which are identical. This is because some of the
library functions are called in multiple places, with differ-
ent parameters.
The next section explains a method of pattern matching
414414
Pattern(PA)
Sub-Patterns
1 call [0x42AE1018]
2 call [0x42AE1018]
3
4
5
6
7
8
call [0x42AE101C]
call [0x42AE1010]
mov ebx, [0x42AE1010]
mov eax, [ebx]
call eax
call [0x42AE101C]
call [0x42AE1010]
mov ebp, esp
mov eax, [ebp-40]
call eax
call [0x42AE101C]
call [0x42AE1010]
mov ebp, esp
mov eax, [ebp-40]
call eax
Pattern(PB)
Sub-Patterns
1
2
3
4
5
6
7
8
mov ebp, esp
mov eax, [ebp-40]
call eax
call [0x42AE101C]
call [0x42AE1010]
call [0x42AE1018]
call [0x42AE101C]
call [0x42AE1010]
mov ebp, esp
mov eax, [ebp-40]
call eax
call [0x42AE101C]
call [0x42AE1010]
mov ebx, [0x42AE1010]
mov eax, [ebx]
call eax
call [0x42AE1018]
Figure 1. The patterns of code fragments of Sapphire
worm and its metamorphic version.
to compute the similarity between two binaries. The input
to this process is the patterns derived from the binaries in
the way just described. The pattern matching algorithm is
intended to overcome the differences between two variants
of the same malware.
3.3 Pattern Matching
The purpose of pattern matching is to determine if two
code fragments are similar enough to exhibit functional
equivalency. The proposed method does not produce a for-
mal proof of equivalence. Not only is that undecidable, but
malware variants may in fact compute somewhat different
results. Rather, we consider similarity in system or function
call behavior to be strong evidence that programs have a
similar purpose. The two requirements for deﬁning patterns
and the resulting pattern matching algorithm are:
1. The pattern derived from one malware program should
be very different from patterns derived from other pro-
grams, whether benign, or malware of another type.
2. Patterns derived from metamorphic variants of a single
malware program should be very similar.
The matching algorithm is deﬁned as follows. Two code
fragments k and l are given, where k may be, for instance,
a known instance of malware. The pattern for k has been
computed and is represented as P k = {U k
}. The
pattern for l has been computed and is represented as P l =
{U l
1, ..., U l
Nl
Let similarity scores be real values between 0 (minimum
similarity) and 1 (maximum similarity). Suppose similarity
scores between all pairs of subpatterns, where one subpat-
tern is taken from P k and one subpattern is taken from P l,
have been computed.
1 , ..., U k
Nk
}.
A pattern matching of k and l is a one-to-one assign-
ment from the set of subpatterns of k to the set of subpat-
terns of l. A maximum matching is one that includes all
of the subpatterns of k, and/or all of the subpatterns of l.
A maximum weighted matching is one that maximizes the
sum of the similarity scores of the pairs of subpatterns that
are matched. The value or score produced by a maximum
weighted matching W is equal to the mean of the similarity
scores of pairs of subpatterns that are present in that match-
ing:
(cid:1)
(cid:1)U k
i ,U l
score(U k
j)
i , U l
j(cid:2)∈W
max(Nk, Nl)
(1)
M(P k, P l) =
A maximum weighted matching is an optimistic ap-
proach to computing the similarity between two code frag-
ments. The process of deriving and matching patterns
should not be greatly affected by small errors in disassem-
bly and data ﬂow analysis, or by current program obfusca-
tion techniques. These claims are evaluated in section 4.
Pattern matching is performed after similarity scores are
computed for all pairs of sub-patterns. For each such pair
of sub-patterns, the similarity score of all pairs of elements
is computed, where one element is taken from the ﬁrst sub-
pattern, and the other element is taken from the second sub-
pattern. From this, a maximum weighted matching of the
elements of the two sub-patterns is computed, in the same
way as mentioned before. The similarity score of this pair
of sub-patterns is then the mean of the similarity scores of
pairs of elements that are matched.
Finally, computing the similarity of two elements in-
volves comparison of the instructions or instruction se-
quences (still in their intermediate form) in the two ele-
ments. This step ﬁnds a maximum weighted mapping be-
tween the instructions in the two elements. To do this, it is
required to compute the similarity between any two instruc-
tions, using as input their intermediate forms. The compu-
tation is only an estimate of the similarity between instruc-
tions. Therefore, a heuristic method is used. This method
ﬁrst computes the similarity between operation types. As
an example, add and subtract operations are deemed
to be similar, while add and call are not. The compar-
ison of operands checks for each operand pair whether the
addressing mode, and register or memory addresses or im-
mediate operands (when they can be determined) are the
same, and scores them based on closeness. Closeness of
operands is weighted more heavily than closeness of oper-
ation types when computing a ﬁnal similarity score for two
instructions. This computation is designed to be accurate
enough to capture most obfuscations used in practice.
Figure 2 shows an example of the maximum weighted
matching process for the two patterns shown in Figure 1.
415415
PA
0.1
0.1
0.05
0.73
0.05
1
0.05
1
0.2
0.2
1
0.05
1
0.05
1
0.05
1
1
0.2
0.1
0.2
0.1
0.2
0.1
PB
0.2
0.2
1
0.05
1
0.05
1
0.05
0.1
0.1
0.05
0.73
0.05
1
0.05
1
0.2
0.2
1
0.05
1
0.05
1
0.05
0.1
0.1
0.05
1
0.05
0.73
0.05
0.73
1
1
0.2
0.1
0.2
0.1
0.2
0.1
Figure 2. The maximum weighted pattern matching of
code fragments of the Sapphire Worm and a metamorphic
variant, whose patterns are shown in Figure 1. Each Cell is
a similarity score of two subpatterns, one from pattern P A,
and one from pattern P B. The marked cells show the max-
imum weighted matching. The score of pattern matching
M(P A, P B)=8/8=1.
A software prototype of the proposed method has been
implemented, based on the ideas described above. The Hun-
garian algorithm [29] is a well known method for solving
weighted matching problems and was used in the imple-
mentation. The complexity of this algorithm is approx-
imately O(max2(Nk,Nl)). Although the Hungarian algo-
rithm has a polynomial running time, this could still be un-
desirably slow. For instance, a large program whose code
size is measured in MB can easily produce thousands of
subpatterns. Therefore, when the number of subpatterns
exceeds a threshold, an approximate version of maximum
weighted maching is used. In the next section, the prelimi-
nary results from testing of this software are described.
4 Evaluation
The proposed method computes the similarity between
two binary executables, based on the characteristics de-
scribed above.
If one executable is derived from another
(i.e., is a variant or version of another), the computed sim-
ilarity should be very high. Otherwise, the computed sim-
ilarity should be low, with a large gap allowing these two
cases to be easily distinguished.
The proposed method has been fully implemented. This
implementation can analyze executables for both the Linux
and Windows operating systems, compiled for the Intel x86
instruction set architecture.
Three sets of inputs were used to test this hypothesis ex-
perimentally. The ﬁrst set of inputs consisted of benchmark
programs (compiled for Linux) that were processed using
a tool for ﬁne-grained randomization of commodity soft-
ware [16]. The second set of inputs consisted of variants of
known Windows viruses, downloaded from the VX Heav-
ens [7] website. The third set of inputs consisted of var-
ious releases of the GNU binutils programs, compiled for
the Linux platform. For each set, the similarities of known
variants or versions were computed, and when it made sense
to do so, the similarities of unrelated programs (neither de-
SPEC 
CPU2000
Apache
Misc
twolf
mcf
gcc
bzip2
vortex
crafty
perlbmk
parser
gzip
vpr
httpd
ghttpd
Matching
Code
Size (K)
164.70
7.86
Score
98.48%
97.81%
99.39% 1158.36
29.18
99.23%
399.82
99.77%
99.90%
173.75
483.12
95.74%
104.29
99.07%
31.43
76.87%
100.54
79.94%