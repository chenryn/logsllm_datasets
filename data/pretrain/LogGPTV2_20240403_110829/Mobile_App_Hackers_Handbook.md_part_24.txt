Looking Under the Hood
This section explores the finer details of what happens under the hood when installing and running an
application.
Installing an Application
When an application is installed on an Android device, various tasks must be performed by the Package
Manager Service and installd to ensure that the OS fully recognizes and knows how to work with it. The
following is a high-level view of the steps:
Determine correct installation location according to package parameters
Determine if this is a new installation or update
Store the APK in the appropriate directory
Determine the application’s UID
Create the application data directory and set the appropriate permissions
Extract native libraries and place them in libs directory of application data directory and set appropriate file
and folder permissions
Extract the DEX file from the package and put its optimized equivalent in the cache directory
Add package particulars to packages.list and packages.xml
Send a broadcast stating that the package was installed
This installation process was documented in depth by Ketan Parmar in a blog post at
http://www.kpbird.com/2012/10/in-depth-android-package-manager-and.html#more. For the purposes of the
next discussion, one of the most important points to take away from the previous list is that when an Android
package is installed, it is also stored on the device. User-level applications are stored in /data/app/, and
applications that came with the system image are under /system/app/.
NOTE
Since Android 4.4 (KitKat), applications that request to be run as the system user have to be installed in
/system/priv-app/, otherwise the OS will reject this request. Prior to Android 4.4, any application that was
located in /system/app could be granted this right. This change allows device manufacturers a greater
degree of control over the security of the applications they bundle with their devices.
Here is an example listing of all the APK files present in the /data/app/ folder on an Android 4.4 emulator:
root@android:/data/app # ls -l *.apk
-rw-r--r-- system system ... ApiDemos.apk
-rw-r--r-- system system ... CubeLiveWallpapers.apk
-rw-r--r-- system system ... GestureBuilder.apk
-rw-r--r-- system system ... SmokeTest.apk
-rw-r--r-- system system ... SmokeTestApp.apk
-rw-r--r-- system system ... SoftKeyboard.apk
-rw-r--r-- system system ... WidgetPreview.apk
An important point to note is that each of the APK files listed is world readable according to their file
permissions. This is the reason downloading them off a device or accessing them without having any particular
level of privileges is possible. These same permissions are set on packages stored in the /system/app and
/system/priv-app folders.
The Play Store used to have a Copy Protection function that you could enable when publishing an application.
Applications that have been installed with this deprecated option reside in /data/app-private/ and are marked
with the following file permissions, which do not allow world read access like the other third-party and system
applications:
shell@android:/data/app-private # ls -l -a
-rw-r----- system app_132 629950 2014-04-18 23:40 com.mwr.dz-1.apk
These applications have essentially been installed using the FORWARD_LOCK option provided by the Package
Manager. You can replicate this installation option by using the following command from an ADB shell on your
device:
shell@android:/data/local/tmp $ pm install -l agent.apk
This installs the package with FORWARD_LOCK enabled, which places its APK in the /data/app-private folder. It
should be noted here that this form of “copy protection” is fundamentally broken and relies on users not having
privileged access on their device. If users have privileged access they can retrieve the application and
redistribute it by other means and install it on other devices without this mechanism having any bearing.
NOTE
As of Android 4.1 (Jelly Bean), applications that are installed with this option are stored with the extension
.asec in the /data/app-asec folder and encrypted with a device-specific key, which is stored in
/data/misc/systemkeys/AppsOnSD .sks. The file permissions are set so that it can only be accessed by
privileged users on the device (such as system and root). Initially, this feature was controversial and broke
application features but has since been resolved in the 4.1.2 update. Nikolay Elenkov described this
excellently in a blog post, which you can find at http://nelenkov.blogspot.com/2012/07/using-app-
encryption-in-jelly-bean.html.
Upon installing an application, in addition to storing the APK on disk, the application attributes are cataloged in
files located at /data/system/packages.xml and /data/system/packages.list. These files contain a list of all
installed applications as well as other information important to the package. The packages.xml file stores
information about each installed application, including the permissions that were requested. This means that
any changes made inside this file will directly affect the way that the OS treats the application. For instance,
editing this file and adding or removing a permission from an application literally changes the application’s
permissions. This fact may be used by application testers on Android to manipulate packages into a desirable
state for testing or modification. It has also been used by Android “tinkerers” to build toolkits that allow for the
“revocation” of permissions on chosen applications. This, of course, requires privileged access on the device
because of the allocated file permissions on packages.xml, which is shown here:
root@android:/ # ls -l /data/system/packages.xml
-rw-rw----- system system 57005 2014-04-18 21:38 packages.xml
NOTE
On versions of Android prior to and including 4.0.4 (Ice Cream Sandwich) the packages.xml and
packages.list files were marked as world readable. This can be confirmed by observing the ICS Android
source code and comparing the file permission assignments by tracing the mSettingsFilename and
mPackageListFilename variables over the different versions of Android. You can efficiently perform code
comparisons of this nature at http://grepcode.com/
file/repository.grepcode.com/java/ext/com.google.android/android/4.0.4_r2.1/com/android/server/pm/Settings.java/
Another procedure that takes place at installation time is the optimization and caching of the package’s DEX
file. The classes.dex file is extracted from the APK, optimized using the dexopt utility, and then stored in the
Dalvik cache folder. This folder exists at $ANDROID_DATA/dalvik-cache on every device (which is normally
/data/dalvik-cache). It is optimized so that minimal instruction checking needs to be performed at runtime,
and other such pre-execution checks can be performed on the bytecode. For more information about the specific
tasks run by dexopt go to https://cells-
source.cs.columbia.edu/plugins/gitiles/platform/dalvik/+/android-4.3_r0.9/docs/dexopt.html. The
process of creating an ODEX may take time, and this could degrade first-run performance for applications. This
is why most system applications on an Android image come pre-”odexed,” or a process of odexing is performed
on first startup of the OS. If you explore the filesystem, notice that APKs in the /system/app directory may have
an accompanying file with the same name and an extension of .odex. These are the application’s “optimized
DEX” files that are stored outside of the package archive.
Pre-optimizing the DEX files means that when applications are run they do not need to be processed and stored
in the cache first, which improves the loading time of the application. The processing procedure used by the
dexopt utility for converting a DEX to an ODEX is a complex one. It involves parsing each instruction and
checking for redundancies that can be replaced and using inline native replacements for methods that are called
frequently. This process makes these ODEX files highly dependent on the specific version of the VM in use on
the device. As a consequence, it is unlikely that an ODEX file will work on another device, unless the device
software type and versions are identical.
Running an Application
Android uses an unusual procedure for starting new applications. It works by having a single application VM
started when the OS boots that listens for requests to launch new applications. When it receives a request, it
simply fork()’s itself with new application parameters and code to run. The process that listens for new
application requests is aptly named zygote. This technique makes the process of creating new application VMs
efficient, as core libraries are shared between VMs. When a user clicks on an application icon, an intent is
formulated and sent using startActivity(). This is handled by the Activity Manager Service, which sends a
message to zygote with all the parameters required to start the application. Zygote listens on a UNIX socket
located at /dev/socket/zygote and has the following permissions, which allow only the system UID or root to
interact with it:
root@android:/ # ls -l /dev/socket/zygote
srw-rw---- root system 2014-05-04 11:05 zygote
When an application is started, the Dalvik cache is checked to see whether the application’s DEX file has been
optimized and stored. If it has not, the system has to perform this optimization, which impacts the application’s
loading time.
ART—RUNTIME REPLACEMENT FOR DALVIK
Android 5.0 (Lollipop) makes use of a new runtime named ART (Android Runtime) by default. It was
designed to make applications perform better on the platform and reduce battery consumption. An
experimental version of ART was included in Android 4.4 (KitKat) and could be enabled by going to
Settings ➪ Developer Options ➪ Select Runtime. (See Figure 6.7.)
Making use of ART instead of Dalvik should be completely transparent to average users of the OS, but
marks a significant technical change. Dalvik interprets code at runtime using a Just-in-Time (JIT)
approach, which compiles bytecode to native code on the fly. This compilation introduces a delay and
additional computing resources. ART’s new Ahead-Of-Time (AOT) compilation converts applications to
native code directly at installation time. This process takes a bit longer than its Dalvik counterpart and
takes up more disk space; however, the aim is to improve application load times and responsiveness. This
is achieved by having it stored as native code that at runtime does not need to be interpreted. At the time
of writing, benchmarks performed provided mixed results. Some applications performed better using ART
and others did not. It is suspected that Google will be constantly looking to improve the performance of
applications running on ART and the common consensus is that moving away from the Dalvik runtime is
the right decision.
ART makes use of OAT files instead of DEX files as the stored executable format. On devices that have the
option to make use of ART, there is a utility included on the system image that allows for conversion from
the DEX to OAT format. It is called dex2oat. Rudimentary reverse engineering tools for OAT will be
presented later in this chapter in “Reverse Engineering Applications.”
Figure 6.7 The runtime selection activity available on Android 4.4
Understanding the Security Model
The foundation of the Android application security model is that no two applications running on the same
device should be able to access each other’s data without authorization. They should also not be able to affect
the operation of the other application adversely or without the appropriate consent. This concept is the basis of
an application sandbox.
In theory, this concept is simple but the practical implementation of what defines an authorized action or not is
complex. Keeping an open and extendible environment while maintaining security means that the security
model has to stretch further than just the application code itself. An application would need to know whether
another application is authorized to perform an action and so the concept of application identity is important.
Android has built-in ways of checking which entity created an application, and using this information could
determine what privilege context it can be assigned on the device. After all, if any application author could claim
to be Google, enforcing any trust boundaries would not be possible and every application would have to be
afforded the same level of trust on the device. An application author’s identity is managed by code signing.
Code Signing
The signing of an Android package is done cryptographically through the use of digital certificates whose private
key is only held by the application developers. Code signing is used to prove the identity of an application’s
author in order to designate a degree of trust to it in other aspects of the security model. Signing of a package is
mandatory, even if the certificate used is the default debug certificate that can only be used during development.
To generate your own X.509 certificate that can be used for signing, use the following command:
$ keytool -genkey -v -keystore mykey.keystore -alias alias_name -keyalg RSA
-keysize 2048 -validity 10000
Signing your unsigned application can be performed using the following command, making use of your newly
created certificate:
$ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore
mykey.keystore application.apk alias_name
The certificate information of an application is contained within the CERT.RSA file in the META-INF folder inside
every Android package.
TIP
Remember that an APK is simply a Zip archive that you can unzip using your favorite application.
You can view the certificate using any tool capable of parsing the DER format. Here is an example of using
openssl to display the certificate and its attributes:
$ openssl pkcs7 -inform DER -in CERT.RSA -text -print_certs
Certificate:
Data:
Version: 3 (0x2)
Serial Number: 10623618503190643167 (0x936eacbe07f201df)
Signature Algorithm: sha1WithRSAEncryption
Issuer: C=US, ST=California, L=Mountain View, O=Android,
OU=Android, CN=Android/emailAddress=PI:EMAIL
Validity
Not Before: Feb 29 01:33:46 2008 GMT
Not After : Jul 17 01:33:46 2035 GMT
Subject: C=US, ST=California, L=Mountain View, O=Android,
OU=Android, CN=Android/emailAddress=PI:EMAIL
Subject Public Key Info:
Public Key Algorithm: rsaEncryption
Public-Key: (2048 bit)
Modulus:
00:d6:93:19:04:de:c6:0b:24:b1:ed:c7:62:e0:d9:
d8:25:3e:3e:cd:6c:eb:1d:e2:ff:06:8c:a8:e8:bc:
a8:cd:6b:d3:78:6e:a7:0a:a7:6c:e6:0e:bb:0f:99:
35:59:ff:d9:3e:77:a9:43:e7:e8:3d:4b:64:b8:e4:
fe:a2:d3:e6:56:f1:e2:67:a8:1b:bf:b2:30:b5:78:
c2:04:43:be:4c:72:18:b8:46:f5:21:15:86:f0:38:
a1:4e:89:c2:be:38:7f:8e:be:cf:8f:ca:c3:da:1e:
e3:30:c9:ea:93:d0:a7:c3:dc:4a:f3:50:22:0d:50:
08:07:32:e0:80:97:17:ee:6a:05:33:59:e6:a6:94:
ec:2c:b3:f2:84:a0:a4:66:c8:7a:94:d8:3b:31:09:
3a:67:37:2e:2f:64:12:c0:6e:6d:42:f1:58:18:df:
fe:03:81:cc:0c:d4:44:da:6c:dd:c3:b8:24:58:19:
48:01:b3:25:64:13:4f:bf:de:98:c9:28:77:48:db:
f5:67:6a:54:0d:81:54:c8:bb:ca:07:b9:e2:47:55:
33:11:c4:6b:9a:f7:6f:de:ec:cc:8e:69:e7:c8:a2:
d0:8e:78:26:20:94:3f:99:72:7d:3c:04:fe:72:99:
1d:99:df:9b:ae:38:a0:b2:17:7f:a3:1d:5b:6a:fe:
e9:1f
Exponent: 3 (0x3)
X509v3 extensions:
X509v3 Subject Key Identifier:
48:59:00:56:3D:27:2C:46:AE:11:86:05:A4:74:19:AC:09:CA:8C:11
X509v3 Authority Key Identifier:
keyid:48:59:00:56:3D:27:2C:46:AE:11:86:05:A4:74:19:AC:09:CA:8C:11
DirName:/C=US/ST=California/L=Mountain
View/O=Android/OU=Android/CN=Android/emailAddress=PI:EMAIL
serial:93:6E:AC:BE:07:F2:01:DF
X509v3 Basic Constraints:
CA:TRUE
Signature Algorithm: sha1WithRSAEncryption
7a:af:96:8c:eb:50:c4:41:05:51:18:d0:da:ab:af:01:5b:8a:
76:5a:27:a7:15:a2:c2:b4:4f:22:14:15:ff:da:ce:03:09:5a:
bf:a4:2d:f7:07:08:72:6c:20:69:e5:c3:6e:dd:ae:04:00:be:
29:45:2c:08:4b:c2:7e:b6:a1:7e:ac:9d:be:18:2c:20:4e:b1:
53:11:f4:55:d8:24:b6:56:db:e4:dc:22:40:91:2d:75:86:fe:
88:95:1d:01:a8:fe:b5:ae:5a:42:60:53:5d:f8:34:31:05:24:
22:46:8c:36:e2:2c:2a:5e:f9:94:d6:1d:d7:30:6a:e4:c9:f6:
95:1b:a3:c1:2f:1d:19:14:dd:c6:1f:1a:62:da:2d:f8:27:f6:
03:fe:a5:60:3b:2c:54:0d:bd:7c:01:9c:36:ba:b2:9a:42:71:
c1:17:df:52:3c:db:c5:f3:81:7a:49:e0:ef:a6:0c:bd:7f:74:
17:7e:7a:4f:19:3d:43:f4:22:07:72:66:6e:4c:4d:83:e1:bd:
5a:86:08:7c:f3:4f:2d:ec:21:e2:45:ca:6c:2b:b0:16:e6:83:
63:80:50:d2:c4:30:ee:a7:c2:6a:1c:49:d3:76:0a:58:ab:7f:
1a:82:cc:93:8b:48:31:38:43:24:bd:04:01:fa:12:16:3a:50:
57:0e:68:4d
-----BEGIN CERTIFICATE-----
MIIEqDCCA5CgAwIBAgIJAJNurL4H8gHfMA0GCSqGSIb3DQEBBQUAMIGUMQswCQYD
VQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4g
VmlldzEQMA4GA1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UE
AxMHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTAe
Fw0wODAyMjkwMTMzNDZaFw0zNTA3MTcwMTMzNDZaMIGUMQswCQYDVQQGEwJVUzET
MBEGA1UECBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4G
A1UEChMHQW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9p
ZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTCCASAwDQYJKoZI
hvcNAQEBBQADggENADCCAQgCggEBANaTGQTexgskse3HYuDZ2CU+Ps1s6x3i/waM
qOi8qM1r03hupwqnbOYOuw+ZNVn/2T53qUPn6D1LZLjk/qLT5lbx4meoG7+yMLV4
wgRDvkxyGLhG9SEVhvA4oU6Jwr44f46+z4/Kw9oe4zDJ6pPQp8PcSvNQIg1QCAcy
4ICXF+5qBTNZ5qaU7Cyz8oSgpGbIepTYOzEJOmc3Li9kEsBubULxWBjf/gOBzAzU
RNps3cO4JFgZSAGzJWQTT7/emMkod0jb9WdqVA2BVMi7yge54kdVMxHEa5r3b97s
zI5p58ii0I54JiCUP5lyfTwE/nKZHZnfm644oLIXf6MdW2r+6R8CAQOjgfwwgfkw
HQYDVR0OBBYEFEhZAFY9JyxGrhGGBaR0GawJyowRMIHJBgNVHSMEgcEwgb6AFEhZ
AFY9JyxGrhGGBaR0GawJyowRoYGapIGXMIGUMQswCQYDVQQGEwJVUzETMBEGA1UE
CBMKQ2FsaWZvcm5pYTEWMBQGA1UEBxMNTW91bnRhaW4gVmlldzEQMA4GA1UEChMH
QW5kcm9pZDEQMA4GA1UECxMHQW5kcm9pZDEQMA4GA1UEAxMHQW5kcm9pZDEiMCAG
CSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbYIJAJNurL4H8gHfMAwGA1Ud
EwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEBAHqvlozrUMRBBVEY0NqrrwFbinZa
J6cVosK0TyIUFf/azgMJWr+kLfcHCHJsIGnlw27drgQAvilFLAhLwn62oX6snb4Y
LCBOsVMR9FXYJLZW2+TcIkCRLXWG/oiVHQGo/rWuWkJgU134NDEFJCJGjDbiLCpe
+ZTWHdcwauTJ9pUbo8EvHRkU3cYfGmLaLfgn9gP+pWA7LFQNvXwBnDa6sppCccEX
31I828XzgXpJ4O+mDL1/dBd+ek8ZPUP0IgdyZm5MTYPhvVqGCHzzTy3sIeJFymwr
sBbmg2OAUNLEMO6nwmocSdN2ClirfxqCzJOLSDE4QyS9BAH6EhY6UFcOaE0=
-----END CERTIFICATE-----
You can also use the Java keytool utility with the following parameters:
$ keytool -printcert -file CERT.RSA
Application certificates are not verified by the Android operating system in any way and do not need to be issued
by a certain Certificate Authority (CA) like other platforms. In fact, the majority of applications make use of a
self-signed signing certificate and the OS does not check this certificate against any stored or online repository.
The signing certificate is checked only when the application gets installed and if the certificate subsequently
expires, the application will still run as normal. Google recommends that signing certificates be created with a
validity period of 25 years or longer to support seamless updates to your application (see
http://developer.android.com/tools/publishing/app-signing.html#considerations). Google Play enforces
that the expiration on the signing certificate used to sign published applications is after October 22, 2033. This
again is to support updates to your application.
With all the preceding information at hand, one can observe that the Android OS does not follow a conventional
Public Key Infrastructure (PKI) process. It does not query any infrastructure to check the authenticity of an
author’s claimed identity. This does not mean that the model is flawed in any way, it is simply different.