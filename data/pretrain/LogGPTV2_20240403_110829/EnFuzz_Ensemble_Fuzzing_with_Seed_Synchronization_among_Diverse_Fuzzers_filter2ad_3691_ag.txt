### Table 15: Average Number of Branches for Single Mode

| Project           | AFL   | AFLFast | FairFuzz | libFuzzer | Radamsa | QSYM  |
|-------------------|-------|---------|----------|-----------|---------|-------|
| boringssl         | 2539  | 2645    | 126      | 126       | 1906    | 1913  |
| c-ares            | 2075  | 2216    | 4906     | 4366      | 626     | 604   |
| guetzli           | 9779  | 10082   | 3829     | 3809      | 3796    | 3978  |
| lcms              | 8091  | 8032    | 19557    | 27308     | 258     | 264   |
| libarchive        | 15892 | 14477   | 115      | 114       | 33492   | 36798 |
| libssh            | 16872 | 16886   | 4538     | 4462      | 6377    | 6865  |
| libxml2           | 2294  | 1917    | 54107    | 47226     | 2062    | 2410  |
| openssl-1.0.1     | 2709  | 2706    | 12531    | 11836     | 36059   | 35960 |
| openssl-1.0.2     | 255631| 271299  | 268116   | 238329    | 276850  | 235903|
| openssl-1.1.0     | 3641  | 126     | 2118     | 1661      | 5263    | 604   |
| pcre2             | 14287 | 2993    | 4068     | 8292      | 30615   | 264   |
| proj4             | 16485 | 114     | 49468    | 16782     | 4821    | 6982  |
| re2               | 2126  | 53427   | 2231     | 2190      | 11217   | 37075 |
| woff2             | 3054  | 122     | 1491     | 2755      | 3961    | 604   |
| freetype2         | 12407 | 3879    | 4015     | 8132      | 29324   | 260   |
| harfbuzz          | 15970 | 112     | 44028    | 16051     | 3626    | 8495  |
| json              | 1878  | 55697   | 2473     | 2784      | 13561   | 36620 |
| libjpeg           | 3608  | 100     | 2774     | 2661      | 3561    | 518   |
| libpng            | 13037 | 2591    | 2308     | 7810      | 13463   | 683   |
| llvm              | 11369 | 1003    | 45541    | 18659     | 4547    | 8828  |
| openthread        | 1651  | 51548   | 5295     | 2178      | 5902    | 28694 |
| sqlite            | 3115  | 126     | 1428     | 935       | 2387    | 604   |
| vorbis            | 12655 | 3901    | 3883     | 8212      | 28404   | 260   |
| wpantund          | 15073 | 114     | 45319    | 19045     | 4846    | 4028  |
| **Total**         | 255631| 271299  | 268116   | 238329    | 276850  | 235903|

### Effects of Input Generation Strategy

The input generation strategy significantly influences the performance of fuzzers. For example, the diversity between AFL and Radamsa lies in their input generation methods. As shown in the fifth columns of Table 14 and Table 15, compared to AFL, the numerous inputs generated by Radamsa can have side effects on most target applications (14 out of 25). Excessive inputs can slow down the fuzzer's execution speed. However, for some applications, such as libxml2, Radamsa's domain-specific knowledge allows it to generate structured and complex format data, which improves performance. This domain-specific knowledge is not available in mutation-based fuzzers like AFL, but combining generation-based fuzzers with mutation-based ones can enhance overall performance.

### Table 16: Average Number of Bugs for Single Mode

| Project           | AFL   | AFLFast | FairFuzz | libFuzzer | Radamsa | QSYM  |
|-------------------|-------|---------|----------|-----------|---------|-------|
| boringssl         | 0     | 1       | 0        | 0         | 0       | 0     |
| c-ares            | 0     | 0       | 0        | 0         | 0       | 0     |
| guetzli           | 0     | 0       | 0        | 0         | 0       | 0     |
| lcms              | 0     | 0       | 0        | 0         | 0       | 0     |
| libarchive        | 0     | 0       | 0        | 0         | 0       | 0     |
| libssh            | 0     | 0       | 0        | 0         | 0       | 0     |
| libxml2           | 0     | 0       | 0        | 0         | 0       | 0     |
| openssl-1.0.1     | 0     | 2       | 0        | 0         | 0       | 0     |
| openssl-1.0.2     | 0     | 0       | 0        | 0         | 0       | 0     |
| openssl-1.1.0     | 1     | 1       | 0        | 0         | 0       | 0     |
| pcre2             | 0     | 0       | 0        | 0         | 0       | 0     |
| proj4             | 0     | 0       | 0        | 0         | 0       | 0     |
| re2               | 0     | 0       | 0        | 0         | 0       | 0     |
| woff2             | 0     | 0       | 0        | 0         | 0       | 0     |
| freetype2         | 0     | 0       | 0        | 0         | 0       | 0     |
| harfbuzz          | 0     | 0       | 0        | 0         | 0       | 0     |
| json              | 0     | 0       | 0        | 0         | 0       | 0     |
| libjpeg           | 0     | 0       | 0        | 0         | 0       | 0     |
| libpng            | 0     | 0       | 0        | 0         | 0       | 0     |
| llvm              | 0     | 0       | 0        | 0         | 0       | 0     |
| openthread        | 0     | 0       | 0        | 0         | 0       | 0     |
| sqlite            | 0     | 0       | 0        | 0         | 0       | 0     |
| vorbis            | 0     | 0       | 0        | 0         | 0       | 0     |
| wpantund          | 0     | 0       | 0        | 0         | 0       | 0     |
| **Total**         | 15    | 10      | 0        | 0         | 0       | 0     |

### Performance Variation in Different Modes

To evaluate the performance variation, we use AFL as the baseline and compare other fuzzers in both single and parallel modes. Figures 5, 6, and 7 show the average number of paths covered by each fuzzer in different modes.

#### Key Findings:

1. **Single vs. Parallel Mode:**
   - In single mode, optimized fuzzers like AFLFast and FairFuzz often outperform AFL.
   - In parallel mode, the performance of these optimized fuzzers drops, and AFL performs better on most applications.

2. **Ensemble Fuzzing:**
   - EnFuzz, an ensemble fuzzer, consistently outperforms AFL in both single and parallel modes.
   - EnFuzz-A, EnFuzz-L, and EnFuzz-Q also show significant improvements over AFL, with EnFuzz covering 42.39% more paths than AFL in parallel mode.
   - EnFuzzâˆ’, without seed synchronization, performs worse than AFL, highlighting the importance of seed synchronization.

3. **Diversity and Performance:**
   - The performance of state-of-the-art fuzzers is highly influenced by the diversity of real-world applications.
   - Ensemble fuzzing, which combines multiple fuzzers, can mitigate performance variations and improve overall coverage.

### Conclusion

The performance of modern fuzzers is significantly challenged by the diversity of real-world applications. While optimized strategies may work well in single mode, they do not scale effectively to parallel mode, which is common in industrial settings. Ensemble fuzzing, with its ability to combine multiple fuzzers and synchronize seeds, provides a critical enhancement to both single and parallel modes, leading to better overall performance and coverage.