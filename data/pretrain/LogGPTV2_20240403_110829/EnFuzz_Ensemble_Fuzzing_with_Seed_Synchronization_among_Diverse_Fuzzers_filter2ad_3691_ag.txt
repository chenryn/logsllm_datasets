821
3513
91862
1674
84
1090
864
2834
68
7956
2103
2482
2380
35288
218
6014
10
10939
8068
412
979
159
5760
123
193
1122
3048
93867
Table 15: Average number of branches for single mode.
Project
boringssl
c-ares
guetzli
lcms
libarchive
libssh
libxml2
openssl-1.0.1
openssl-1.0.2
openssl-1.1.0
pcre2
proj4
re2
woff2
freetype2
harfbuzz
json
libjpeg
libpng
llvm
openthread
sqlite
vorbis
wpantund
Total
AFL AFLFast FairFuzz libFuzzer Radamsa QSYM
2539
2645
126
126
1906
1913
2075
2216
4906
4366
626
604
9779
10082
3829
3809
3796
3978
8091
8032
19557
27308
258
264
15892
14477
115
114
33492
36798
16872
16886
4538
4462
6377
6865
2294
1917
54107
47226
2062
2410
2709
2706
12531
11836
36059
35960
255631 271299 268116 238329 276850 235903
3641
126
2118
1661
5263
604
14287
2993
4068
8292
30615
264
16485
114
49468
16782
4821
6982
2126
53427
2231
2190
11217
37075
3054
122
1491
2755
3961
604
12407
3879
4015
8132
29324
260
15970
112
44028
16051
3626
8495
1878
55697
2473
2784
13561
36620
3608
100
2774
2661
3561
518
13037
2591
2308
7810
13463
683
11369
1003
45541
18659
4547
8828
1651
51548
5295
2178
5902
28694
3115
126
1428
935
2387
604
12655
3901
3883
8212
28404
260
15073
114
45319
19045
4846
4028
1135
57356
2646
2771
12605
37269
3) Effects of Input generation strategy–what kind of genera-
tion strategy you use, what kind of corresponding application
you fuzz better. The diversity between AFL and Radamsa is
the input generation strategy. From the ﬁfth columns of Table
14 and Table 15, compared with AFL, the plenty of inputs
generated by Radamsa have some side effects on most target
applications (14 applications). Too many extra inputs will
slow down the execution speed of the fuzzer. However, for
some applications, the inputs generated by Radamsa will im-
prove the performance effectively. Take libxml2 for example,
Radamsa has some domain knowledge that prefers to generate
some structured data and speciﬁc complex format data. These
domain knowledge are not available in most mutation-based
fuzzers, and this is a critical disadvantage of AFL. But with
the help of generation-based fuzzers, the performance of AFL
can be improved greatly.
Table 16: Average number of bugs for single mode.
Project
boringssl
c-ares
guetzli
lcms
libarchive
libssh
libxml2
openssl-1.0.1
openssl-1.0.2
openssl-1.1.0
pcre2
proj4
re2
woff2
freetype2
harfbuzz
json
libjpeg
libpng
llvm
openthread
sqlite
vorbis
wpantund
Total
AFL AFLFast FairFuzz libFuzzer Radamsa QSYM
0
1
0
0
0
0
0
0
2
0
1
0
0
0
0
0
0
0
1
1
0
1
2
0
9
1
1
0
0
0
1
1
0
1
0
1
1
1
1
0
1
0
0
1
1
1
1
1
0
15
0
2
0
0
0
0
1
0
1
0
2
0
0
0
0
0
1
0
1
0
0
1
1
0
10
0
1
0
0
0
0
0
0
2
0
2
0
0
0
0
0
1
0
0
0
0
0
1
0
7
0
2
0
0
0
0
1
0
1
0
1
0
0
0
0
0
1
0
1
0
0
0
1
0
8
0
2
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
1
1
0
0
2
0
7
In conclusion: Different base fuzzers perform variously on
distinct target applications, showing the diversity for the base
fuzzers. The more diversity of these base fuzzers, the more
differently they perform on different applications. Further-
more, the above three types of effects should be considered
and could be incorporated into the fuzzing evaluation guide-
line [25] to avoid biased test cases or metrics selection when
evaluating different types of fuzzing optimization.
B Does performance vary in different modes?
We choose AFL as the baseline, and compare other tools with
AFL on path coverage to demonstrate the performance varia-
tion. Figure 5 shows the average number of paths executed
on Google’s fuzzer-test-suite by each base fuzzer compared
with AFL in single mode. We also collect the result of each
base fuzzer running in parallel mode with four threads, and
the result is presented in Figure 6. Figure 7 shows the average
1982    28th USENIX Security Symposium
USENIX Association
(a) performance of
AFLFast in single thread
(b) performance of
FairFuzz in single thread
(c) performance of
libFuzzer in single thread
(d) performance of
Radamsa in single thread
(d) performance of QSYM
in single thread
Figure 5: Paths covered by base fuzzers compared with AFL in single mode on a single core.
(a) performance of
AFLFast in four threads
(b) performance of
FairFuzz in four threads
(c) performance of
libFuzzer in four threads
(d) performance of
Radamsa in four threads
(d) performance of QSYM
in four threads
Figure 6: Paths covered by base fuzzers compared with AFL in parallel mode with four threads on four cores.
(a) performance of
EnFuzz− in four threads
(a) performance of
EnFuzz-A in four threads
(a) performance of
EnFuzz-Q in four threads
(b) performance of
EnFuzz-L in four threads
(c) performance of
EnFuzz in four threads
Figure 7: Paths covered by EnFuzz with four threads on four cores compared with AFL in parallel mode with four threads on
four cores. EnFuzz− without the proposed seed synchronization performs the worst, and EnFuzz performs the best.
number of paths executed by EnFuzz compared with AFL in
parallel mode with four CPU cores. From these results, we
get the following conclusions:
• From the results of Figure 5 and Figure 6, we ﬁnd
that compared with AFL, the two optimized fuzzers
AFLFast and FairFuzz, block coverage guided fuzzer
libFuzzer, generation-based fuzzer Radamsa and hybrid
fuzzer QSYM perform variously on different applica-
tions both in single mode and in parallel mode. It demon-
strates that the performance of these base fuzzers is chal-
lenged by the diversity of the diverse real applications.
The performance of their fuzzing strategies cannot con-
stantly perform better than AFL. The performance varia-
tion exists in these state-of-the-art fuzzers.
• Comparing the result of Figure 5 and Figure 6, we ﬁnd
that the performance of these base fuzzers in parallel
mode are quite different from those in single mode, es-
pecially for AFLFast and FairFuzz. In single mode, the
other two optimized base fuzzers perform better than
AFL in many applications. But in parallel mode, the
result is completely opposite that the original AFL per-
forms better on almost all applications.
• From the result of Figure 7, it reveals that EnFuzz-A,
EnFuzz-L and EnFuzz always perform better than AFL
on the target applications. For the same computing re-
sources usage where AFL running in parallel mode with
four CPU cores, EnFuzz-A covers 11.26% more paths
than AFL, ranging from 4% to 38% in single cases,
EnFuzz-Q covers 12.48% more paths than AFL, rang-
ing from 5% to 177% in single cases, EnFuzz-L cov-
ers 37.50% more paths than AFL, ranging from 13% to
455% in single cases. EnFuzz covers 42.39% more paths
than AFL, ranging from 14% to 462% in single cases.
Through ensemble fuzzing, the performance variation
can be reduced.
• From the result of Figure 7, it reveals that EnFuzz− with-
out seed synchronization performs worse than AFL paral-
lel mode under the same resource constraint. Compared
with EnFuzz-A, EnFuzz-Q covers 1.09% more paths,
EnFuzz-L covers 23.58% more paths. For EnFuzz, it
covers 27.97% more paths than EnFuzz-A, 26.59% more
paths than EnFuzz-Q, 3.6% more paths than EnFuzz-L,
and always performs the best on all applications. The
more diversity among those integrated base fuzzers, the
better performance of ensemble fuzzing, and the seed
synchronization contributes more to the improvements.
In conclusion: the performance of the state-of-the-art fuzzers
is greatly challenged by the diversity of those real-world appli-
cations, and it can be improved through the ensemble fuzzing
approach. Furthermore, those optimized strategies work in
single mode can not be directly scaled to parallel mode which
is widely used in industrial practice. The ensemble fuzzing
approach is a critical enhancement to the single and parallel
mode of those optimized strategies.
USENIX Association
28th USENIX Security Symposium    1983