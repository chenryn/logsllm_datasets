本的一半。且存活对象增多的话，Copying算法的效率会大大降低。
2.4.4. 标记整理算法(Mark-Compact)
结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清
理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：
13/04/2018 Page 28 of 283
2.4.5. 分代收集算法
分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存
划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young
Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃
圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。
2.4.5.1. 新生代与复制算法
目前大部分JVM的GC对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要
回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代
划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用
Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另
一块Survivor空间中。
2.4.5.2. 老年代与标记复制算法
而老年代因为每次只回收少量对象，因而采用Mark-Compact算法。
1. JAVA虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储class类，
常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。
2. 对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目
前存放对象的那一块)，少数情况会直接分配到老生代。
3. 当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden
Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From
Space进行清理。
4. 如果To Space无法足够存储某个对象，则将这个对象存储到老生代。
5. 在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。
6. 当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被
移到老生代中。
13/04/2018 Page 29 of 283
2.5. JAVA 四中引用类型
2.5.1. 强引用
在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引
用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即
使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之
一。
2.5.2. 软引用
软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它
不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。
2.5.3. 弱引用
弱引用需要用WeakReference类来实现，它比软引用的生存期更短，对于只有弱引用的对象
来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。
2.5.4. 虚引用
虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。虚
引用的主要作用是跟踪对象被垃圾回收的状态。
2.6. GC分代收集算法 VS 分区收集算法
2.6.1. 分代收集算法
当前主流VM垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据
对象存活周期的不同将内存划分为几块, 如JVM中的 新生代、老年代、永久代，这样就可以根据
各年代特点分别采用最适当的GC算法
2.6.1.1. 在新生代-复制算法
每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量
存活对象的复制成本就可以完成收集.
2.6.1.2. 在老年代-标记整理算法
因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标
记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存.
13/04/2018 Page 30 of 283
2.6.2. 分区收集算法
分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的
好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是
整个堆), 从而减少一次GC所产生的停顿。
2.7. GC垃圾收集器
Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；
年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不
同的垃圾收集器，JDK1.6中Sun HotSpot虚拟机的垃圾收集器如下：
2.7.1. Serial垃圾收集器（单线程、复制算法）
Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1之前新生代唯一的垃圾
收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工
作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。
Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限
定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial
垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器。
2.7.2. ParNew 垃圾收集器（Serial+多线程）
ParNew垃圾收集器其实是Serial收集器的多线程版本，也使用复制算法，除了使用多线程进行垃
圾收集之外，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也
要暂停所有其他的工作线程。
13/04/2018 Page 31 of 283
ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限
制垃圾收集器的线程数。【Parallel：平行的】
ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是很多java
虚拟机运行在Server模式下新生代的默认垃圾收集器。
2.7.3. Parallel Scavenge 收集器（多线程复制算法、高效）
Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃
圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码
的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），
高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而
不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个
重要区别。
2.7.4. Serial Old收集器（单线程标记整理算法 ）
Serial Old 是 Serial 垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，
这个收集器也主要是运行在Client默认的java虚拟机默认的年老代垃圾收集器。
在Server模式下，主要有两个用途：
1. 在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。
2. 作为年老代中使用CMS收集器的后备垃圾收集方案。
新生代Serial与年老代Serial Old搭配垃圾收集过程图：
新生代Parallel Scavenge收集器与ParNew收集器工作原理类似，都是多线程的收集器，都使
用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代Parallel
Scavenge/ParNew与年老代Serial Old搭配垃圾收集过程图：
13/04/2018 Page 32 of 283
2.7.5. Parallel Old收集器（多线程标记整理算法）
Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6
才开始提供。
在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只
能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old 正是为了在年老代同样提供吞
吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge
和年老代Parallel Old收集器的搭配策略。
新生代Parallel Scavenge和年老代Parallel Old收集器搭配运行过程图：
2.7.6. CMS收集器（多线程标记清除算法）
Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾
回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。
最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。
CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段：
2.7.6.1. 初始标记
只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。
13/04/2018 Page 33 of 283
2.7.6.2. 并发标记
进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。
2.7.6.3. 重新标记
为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记
记录，仍然需要暂停所有的工作线程。
2.7.6.4. 并发清除
清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并
发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看
CMS收集器的内存回收和用户线程是一起并发地执行。
CMS收集器工作过程：
2.7.7. G1收集器
Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与CMS收集器，G1收
集器两个最突出的改进是：
1. 基于标记-整理算法，不产生内存碎片。
2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域
的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾
最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收
集效率。
2.8. JAVA IO/NIO
2.8.1. 阻塞 IO模型
最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO请求之后，内
核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用
户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用
13/04/2018 Page 34 of 283
户线程才解除block状态。典型的阻塞IO模型的例子为：data = socket.read();如果数据没有就
绪，就会一直阻塞在read方法。
2.8.2. 非阻塞 IO模型
当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个
error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备
好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。
所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO
不会交出CPU，而会一直占用CPU。典型的非阻塞IO模型一般如下：
while(true){
data = socket.read();
if(data!= error){
处理数据
break;
}
}
但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就
绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。
2.8.3. 多路复用 IO模型
多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。在多路复用IO
模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真
正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个
socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有
socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。在Java NIO中，是通
过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这
种方式会导致用户线程的阻塞。多路复用IO模式，通过一个线程就可以管理多个socket，只有当
socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连
接数比较多的情况。
另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态
时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效
率要比用户线程要高的多。
不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件
逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件
迟迟得不到处理，并且会影响新的事件轮询。
13/04/2018 Page 35 of 283
2.8.4. 信号驱动 IO模型
在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函
数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到
信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。
2.8.5. 异步 IO模型
异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就