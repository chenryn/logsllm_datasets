✓
×
×
✓
✓
×
As expected, both RXXR2 and Rexploiter reported high
error rates, which are the ratio of false positivies to reported
positives. This demonstrates that a dynamic approach like
ReScue or a hybrid approach like REVEALER would be better
suited for detecting and exploiting vulnerable regexes, especially
those using extended features.
While being effective, REVEALER can also efficiently detect
ReDoS vulnerabilities. On average, analyzing one regex took it
only 0.0076 second, which is close to the 0.0042 second of the
fastest tool—RXXR2. Rexploiter took two orders of magnitude
longer time than RXXR2 on average. ReScue was the slowest,
and was 2,397 times slower than REVEALER—it spent 18.2259
seconds on analyzing one regex on average. We were unable
to reproduce the 0.6128 second as the authors reported in [30],
even we tried many times with different settings.
C. Characterization of Detected Vulnerabilities
To understand why REVEALER can significantly outperform
the state-of-the-art tools, we characterize the detected vulner-
abilities by extended features (§VI-C1), vulnerable structures
(§VI-C2), and the generated prefixes and suffixes (§VI-C3).
TABLE IV: Breakdown of vulnerable regexes by extended features.
Features
Classical features only
Unicode chars
Set operations
Lookarounds
Backreferences
Non-capturing groups
Named groups
Atomic groups
Conditionals
Greedy quantifiers
Lazy quantifiers
Possessive quantifiers
REVEALER
40
4
339
30
10
95
34
0
0
156
107
10
ReScue RXXR2
10
0
89
0
1
30
0
0
0
44
22
1
10
3
154
16
7
55
10
0
0
84
32
6
Rexploiter
4
1
52
0
0
7
4
0
0
26
10
0
1) Extended Features: We list the extended features sup-
ported by each tool
in Table III. As explained in §V-F,
our prototype implementation does not support all extended
features. Nevertheless, both REVEALER and ReScue support
more extended features than RXXR2 and Rexploiter, and
consequently detected more vulnerable regexes. In Table IV,
we list the categorization of vulnerabilities by extended features.
As shown, only 40 vulnerable regexes do not use any extended
feature, which indicates the need to support them.
Supporting a feature might help a tool detect a vulnerable
regex using such a feature. For instance, Rexploiter supports
Fig. 6: Venn diagram of vulnerabilities.
Fig. 7: The matching steps of regexes reported by each tool.
by them. It further detected 213 previously unknown vulnerable
regexes, which is a 89.87% improvement. ReScue performed the
second, by finding 187 (41.56%) vulnerabilities, which were 1
more than it did in [30]. However, it took 20 additional rounds to
find 13 vulnerabilities, indicating that it has a high requirement
on computing resource. RXXR2 and Rexploiter were less
effective, reporting 112 and 63 vulnerabilities, respectively.
Figure 7 presents the matching step distribution of vulner-
abilities reported by each tool. Different groups divided by
matching steps approximately indicate different complexities,
although each group contains both exponential and polynomial
cases. However, some polynomial cases could also cause
noticeable ReDoS in practice. To find the severe cases, we
increase the input length limit by using 100 pumps and set a
10-minute timeout. We confirmed 1, 4, 4 and 229 such severe
cases in the four groups, respectively. Nine cases were not in the
>1e8 group because their attack cores or attack prefixes were
long, resulting in fewer backtrackings when the input lengths
were short (≤ 128). Five cases in the >1e8 group took at least
2.963-second but less than 10-minute matching time using 100
pumps. They were complex “Loop-after-Loop” (polynomial)
cases with short attack cores. They were separated from those
severe cases when the input lengths became large. The rest two
in the >1e8 group took less than 1 second under long inputs,
but more than 10 minutes with 128-character long inputs. We
will discuss them in §VI-D.
Considering only the 238 (52.89%) severe ones, REVEALER
still greatly outperformed the other tools. ReScue detected only
187 regexes in the >1e8 group (183 were severe, 2 were not, 2
were the special cases mentioned above) and did not detect any
in other groups because it used 1e8 at its internal matching
step threshold. Actually, it could not detect some of the 187
vulnerabilities if an internal threshold smaller than 1e8 was
used, because it would stop the search when the matching steps
of a generated input reached the threshold.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1477
REVEALERReScueRXXR2Rexploiter10376192132166112839693252360001741451021011339050100150200250(1e5, 1e6](1e6, 1e7](1e7, 1e8]>1e8REVEALERReScueRXXR2RexploiterTABLE V: Detected vulnerabilities classified by structure.
Type
Loop in Loop
REVEALER
185
Branch in Loop
Loop after Loop
50
215
ReScue
142
(76.76%)
38
(76%)
7
(3.26%)
RXXR2
87
(47.03%)
25
(50%)
0
(0%)
Rexploiter
38
(20.54%)
3
(6%)
22
(10.23%)
‘Unicode chars’ and ‘Named groups’ while RXXR2 does
not, so it detected 1 and 4 vulnerabilities under these two
types while RXXR2 detected none. Similarly, RXXR2 supports
‘Backreferences’ and ‘Non-capturing groups’ while Rexploiter
does not, RXXR2 thus detected 1 and 23 more vulnerabilities
with the two features than Rexploiter, respectively.
A tool could detect vulnerable regexes using a feature it does
not support. All tools detected many vulnerable regexes with
the feature “Set operation” even only REVEALER supported it,
because they substituted the set expression with simpler but
incomprehensive character literals and were able to find some
valid match strings. Similarly, REVEALER detected 10 cases
with ‘Backreferences’ although the prototype did not support
it, because they met one of the following three conditions. C1:
backreference was not on the matching path of the attack
string, so REVEALER did not transit to a state of it. C2:
backreference could be ignored according to the semantics
of the regex, e.g., both (\1)* and (\1)? can be matched
zero time in (a)b(\1)*c(\1)?(d*)*. The generated attack
strings were still valid even by removing it in E-TREE. C3:
backreference matched the attack core. The subexpression state
it referred to was probably on the matching path, e.g., \1 in
a*([a-z])a*(\1)a* can be matched by the attack core “a”.
Thus even it consumed extra attack core(s), the attack was still
valid.
The tools actually have different levels of feature support.
This is also one of the reasons why the tools have different
performances even though they all support the same feature.
ReScue supports most extended features because it drives the
Java regex engine as a gray box. But it does not consider the
real semantics of a feature as REVEALER does. For instance,
ReScue supports ‘Named groups’. But without understanding
the semantics, it adds the name (e.g., “a” is the group name
in (?x)*) as an input seed and could generate many
incorrect inputs. Besides, RXXR2’s ‘Backreferences’ support
is incomplete (and worse than ours), because it ignores such
features under C1 and terminates the analysis under other
conditions. Overall, it cannot support the full semantics of this
feature because it considers only context-free grammars.
2) Vulnerable Structures: Covering all three types of vul-
nerable e-NFA patterns also allows REVEALER to detect more
vulnerabilities. We classify the detected vulnerabilities and
present the breakdown in Table V.
Other than REVEALER, Rexploiter is the only tool con-
sidering the ‘Loop after Loop’ vulnerable structure, and
therefore performed the best among the three tools in detecting
vulnerabilities in this class. But its performance was strictly
limited by its ability of generating attack strings, which we
will discuss in §VI-C3.
ReScue detected over 76% of ‘Loop in Loop’ and ‘Branch
in Loop’ vulnerabilities, but found about only 3% of ‘Loop
after Loop’ cases. This is because the ‘Loop after Loop’
vulnerabilities are more difficult to trigger. The attack string
must match two loops as well as the path in between. But
ReScue does not consider multiple paths at the same time.
3) Prefixes and Suffixes: REVEALER can well generate both
the prefix and suffix of an attack string. This also helps it find
much more vulnerabilities. Without generating a valid prefix,
the attack string cannot drive the regex engine to the repeated
states. A valid suffix is also needed to force the match to fail
at the end such that the regex engine has to backtrack.
Prefix generation is a difficult task for dynamic analysis ap-
proaches, e.g., fuzzers, as they need to produce valid sequences
of symbols to reach certain inner or deep states. Only a very
limited number of sequences are valid whereas the fuzzers might
(blindly) search over a huge number of possibilities. Genetic
algorithms can help, but not much because genetic algorithms
generate offspring by crossing over or mutating the parent
string, which would not directly lead to deeper states. Even
though ReScue tried to alleviate this problem by improving
its node coverage rate, the improvement is still limited by
the huge search space and the time/resource constraint. One
typical example is the regex (]*?tag[^>]*?(?:identify_-
by)[^>]*>)((?:.*?(?:]*>?.*?(?:
)?)*)*), where the shortest prefix of an attack
string would be a simple string—“”. Nev-
ertheless, ReScue went into a meaningless search on other
possible inputs and therefore triggered a time-out on each run.
The static analysis approaches, on the contrary, will not get
stuck in exploring all the possibilities, because they directly
find the attack core and pump the shortest prefix. Therefore,
both RXXR2 and Rexploiter were successful in this case.
Suffix generation, however, is a task more suitable for
dynamic analysis. A static method can only generate a string
from the designated transition path, and cannot ensure that the
string will not be matched by other paths. For example, given
the regex ^(\S+\.{1})*([^\.]\s+)?$, whose attack core is
‘.’, RXXR2 and Rexploiter would try to generate a string that
fails to match the suffix regex ([^\.]\s+)? but can actually
match (\S+\.{1})*. Hence the entire attack string is accepted.
REVEALER considered both the attack core and the suffix regex,
and generated the correct suffix ‘\t’. ReScue achieved this
through multiple searches.
By taking a hybrid approach, REVEALER inherits the
strengths from both static and dynamic approaches. It can
statically generate a valid prefix by analyzing the structures,
and dynamically find a valid suffix by testing against multiple
subexpressions. Therefore, it generated much more valid attack
strings that can trigger ReDoS vulnerabilities.
D. Validation with Other Regex Engines
We detected 450 vulnerable regexes with a 105 matching
step threshold and a 128 attack string length limit. In practice,
attackers can choose longer attack strings. To understand their
practical impact, we relax the input limit to up to 65,536 pumps,
and measure the wall-clock matching time in the Java 8 regex
engine on which we built REVEALER. We count the regexes
that take a matching time longer than 10 seconds, which is
the criteria used in [11]. We also cross-validate them on regex
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:25:45 UTC from IEEE Xplore.  Restrictions apply. 
1478
TABLE VI: Number of timeout regexes with different pumps.
# of Pumps
Java 8
JavaScript
Python
Ruby
PHP
128
234
196
198
187
0
1,024
381
239
242
227
0
8,192
443
368
373
357
3
65,536
443
391
398