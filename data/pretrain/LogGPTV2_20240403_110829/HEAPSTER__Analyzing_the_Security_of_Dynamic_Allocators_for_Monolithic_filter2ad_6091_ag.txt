nrf52832 xxaa.bin@000d
app fw RELEASE.bin@a4fa
BME-100.bin@57a8
bsafebeacon-S110.bin@e348
ICP NRF52.bin@6b7c
BP application.bin@1175
Hoot release pca10040.bin@87ce
nrf52832 xxaa s132.bin@7370
dddock app dock.bin@d2f5
BLERemote.bin@c7bb
trigno update v040.024 T014.bin@12f3
plugin .bin@e6f4
LRIP nRF52 release.bin@9c15
qtBrainoad Car Release oad.bin
ble5 project zero cc13x2r1lp a
new bin.bin
nrf52832 xxaa.bin@c376
w-qcpr-sensor-mk3 release 0.45.1.69.bin@eece
sma10b firmware.bin@4e84
pavlok 2 2008 0930.bin@739e
nrf52832 xxaa.bin@589c
Exakt Pedal Radio Firmware.bin@3dd4
plot.bin@1050
Bond Gen2.bin@5ff8
LinOn Pro RC18.bin@94ee
bicult ble sdk15 sd 132v6.bin@8e6c
tag-firmware.bin@4acb
C
P
Size
(KB) Tot. B S
101
184
87
83
121
90
53
119
47
117
100
121
117
63
43
283
125
167
46
167
42
168
385
284
98
173
90
81
52
68
112
135
11 D0
843

14 D1
1385

8 D2
715

3
E0
681

17 E1
520

10 E10 
454
7 E11 
439
35 E2
621

4
E3
267

12 E4
1065

8
E5
645

11 E6
560

20 E7
382

14 E8
490

14 E9
464

2
903
22 G0
1172

12 G1
1470

3 H0
406

22 H1
1170

9 H2
480

I0
1437
44

I1
2203 12 25

I2
63
1437

I3
6
1037

829
38
J0

J1
12
673

14
574
J2

2 K0
790

7 K1
907

21 L0
1047

11 M0 
1062
F0 (cid:3)
3
4
3
4
5
4
3
4
4
6
6
6
4
5
5
3
4
5
5
5
3
6
5
4
4
3
4
4
5
5
5
TABLE IV: Firmware blobs in the wild dataset that have been
tested with HeapHopper. Column Tot. show the total number of
functions, B the number of identified basic functions, S the number
of pointer sources, C identified cluster, and P whether is the HML
needed to be patched or not.
average stage execution time topped at 3 hours 50 minutes, median
at 2 hours, which demonstrates that our analysis required less than
2 hours for more than half of the samples in both datasets. Although
both numbers (2 and 4 hours) constitute significant computation
time, we argue that the HML needs to be identified only once per
each sample, facilitating any subsequent (security) analysis.
E. Attacks on Example Board
As discussed in Subsection V-D,
to exemplify how one
can use HEAPSTER to discover attacks on a real device, we
leveraged the STM32-NucleoF401RE board expanded with an
X-NUCLEO-IDW01M1 Wi-Fi Module, as depicted in Figure 5
and used HEAPSTER to find, first, the HML and, next, 3 possible
attacks against the HML that successfully trigger Overlapping
Chunks and Non-Heap Allocation. After that, we run the attacks
on the real board, confirming all of them.
F. Firmware Clustering
Figure 6 depicts the results of our clustering algorithm discussed
in Section V applied to both ground-truth and wild datasets. These
results allowed us to establish a relationship between the two
datasets in our evaluation, perform a deeper investigation of false
negatives presence among the blobs with unidentified HML, and,
re-use HML identification and security evaluation results for the
new firmware samples if they can be assigned to an existing cluster.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:35:29 UTC from IEEE Xplore.  Restrictions apply. 
1097
Fig. 4: In blue, number of blobs in each identified coarse-grained
cluster in the wild-dataset. In orange, number of variants (i.e.,
sub-clusters) per identified coarse-grained cluster in the wild-dataset.
Fig. 5: The STM32-NucleoF401RE board (expanded with an
X-NUCLEO-IDW01M1 Wi-Fi Module) used in our experiments.
Stage AT(sec.) MT(sec.) AM(MB) MM(MB)
t
e
s
a
t
a
D
h
t
u
r
T
d
n
u
o
r
G
t
e
s
a
t
a
D
d
l
i
W
1
2
3
4
5
6
8
1
2
3
4
5
6
7
8
13
766
2333
3526
12565
1858
105
21
2479
999
8679
5808
2999
145
121
10
675
1928
3717
7233
405
94
19
2003
141
3627
136
89
118
95
219
1482
3497
2206
1751
2380
1456
263
2155
2873
4474
2045
2307
2186
2146
207
1277
3031
2020
1555
2412
1257
247
1719
1823
2224
1602
1629
1741
1555
TABLE V: Statistics for the HML identification. Stage corresponds
to each analysis part number as described in Section III. AT/AM
report average time/memory. MT/MM report median time/memory
required for each stage.
G. Bounded Model Checking Configuration
When tracing a PoC with HeapHopper (as explained in
Sections III-F and III-G), we use different parameters to bound
the analysis. Without these limits, the analysis would quickly incur
in state explosion, and, therefore, would not be able to provide
any result. These are the main parameters used to configure the
symbolic execution of the PoC:
Malloc sizes We use a limited number of default values (i.e., 8, 10,
20) as requested sizes when calling malloc.
Overflow sizes When modeling a heap overflow exploitation
primitive, we specify the maximum amount of bytes that can
be overflown. In our configuration, we use a value of 8 bytes.
Chunk header size This parameter is extracted by the analysis
discussed in Section III-E. Practically, this indicates how many
bytes of inline metadata are associated with each heap chunk.
Write target size When symbolically exploring the PoC, we
handle attacker-controlled symbolic writes by concretizing
addresses within a specific memory region we called “write
target”. The larger the memory area dedicated to the “write
target” is, the more opportunities we have to concretize the val-
ues useful to trigger a heap vulnerability. However, the “write
target” size increases together with the complexity (and num-
ber) of path constraints, drastically impacting the performance
of the analysis. For our analysis, we use a value of 32 bytes.
Fake free chunk size When using fake-free as exploitation
primitive, we execute free on a memory region filled with a
configurable number of unconstrained symbolic variables. The
bigger this memory region is, the more flexibility HeapHopper
has to manipulate memory to trigger a vulnerability. However,
similarly to the write target size case, this drastically impacts
the scalability of the analysis. For this reason, in our evaluation,
we limit the size of this memory region to 64 bytes.
Loop iterations When symbolically tracing a PoC, we set a limit
on the number of iterations performed by every concrete loop.
For our security evaluation, we set this value to 1000.
HML extra arguments As discussed in Section III-E, the proto-
types of malloc and free may have extra arguments. In
these cases, we constrain the arguments that are representing
neither the requested size nor the pointer to free, to a list of
possible concrete values. This effectively avoids the generation
of false positives related to an unconstrained argument, but also
ensures a precise execution of the allocator/de-allocator code.
Concretization strategies limits Numbers of possible solutions
used when the HeapHopper’s analysis concretizes a symbolic
memory operation. We set this value to a maximum of 100.
Timeout We use this parameter to stop a symbolic analysis that
becomes too expensive to trace. We set this value to 10
minutes per PoC.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:35:29 UTC from IEEE Xplore.  Restrictions apply. 
1098
Fig. 6: Graph representing the similarity between the allocators discovered inside firmware samples in ground-truth and wild dataset.
We show an edge between nodes only if the BinDiff similarity and confidence scores between the bodies of the respective malloc
have values ≥0.7. Yellow nodes represent firmware of the ground-truth dataset. Nodes with labels represent the firmware blobs we tested
with HeapHopper for the security evaluation (20 from the ground-truth dataset and 32 from the wild dataset).
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:35:29 UTC from IEEE Xplore.  Restrictions apply. 
1099