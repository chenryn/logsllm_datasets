title:BOOMERANG: Exploiting the Semantic Gap in Trusted Execution Environments
author:Aravind Machiry and
Eric Gustafson and
Chad Spensky and
Christopher Salls and
Nick Stephens and
Ruoyu Wang and
Antonio Bianchi and
Yung Ryn Choe and
Christopher Kruegel and
Giovanni Vigna
BOOMERANG: Exploiting the Semantic Gap in Trusted Execution Environments
Aravind Machiry1, Eric Gustafson1,2, Chad Spensky1, Chris Salls1, Nick Stephens1,
Ruoyu Wang1, Antonio Bianchi1, Yung Ryn Choe2, Christopher Kruegel1, and Giovanni Vigna1
{machiry, edg, cspensky, salls, stephens, ﬁsh, antoniob, chris, vigna}@cs.ucsb.edu
1University of California, Santa Barbara
2Sandia National Laboratories
{edgusta, yrchoe}@sandia.gov
Abstract—In the past decade, we have come to rely on comput-
ers for various safety and security-critical tasks, such as securing
our homes, operating our vehicles, and controlling our ﬁnances.
To facilitate these tasks, chip manufacturers have begun including
trusted execution environments (TEEs) in their processors, which
enable critical code (e.g., cryptographic functions) to run in
an isolated hardware environment that is protected from the
traditional operating system (OS) and its applications. While
code in the untrusted environment (e.g., Android or Linux) is
forbidden from accessing any memory or state within the TEE,
the code running in the TEE, by design, has unrestricted access
to the memory of the untrusted OS and its applications. However,
due to the isolation between these two environments, the TEE has
very limited visibility into the untrusted environment’s security
mechanisms (e.g., kernel vs. application memory).
In this paper, we introduce BOOMERANG, a class of vulner-
abilities that arises due to this semantic separation between the
TEE and the untrusted environment. These vulnerabilities permit
untrusted user-level applications to read and write any memory
location in the untrusted environment, including security-sensitive
kernel memory, by leveraging the TEE’s privileged position to
perform the operations on its behalf. BOOMERANG can be used
to steal sensitive data from other applications, bypass security
checks, or even gain full control of the untrusted OS.
To quantify the extent of this vulnerability, we developed an
automated framework for detecting BOOMERANG bugs within
the TEEs of popular mobile phones. Using this framework,
we were able to conﬁrm the existence of BOOMERANG on
four different TEE platforms, affecting hundreds of millions
of devices on the market today. Moreover, we conﬁrmed that,
in at least two instances, BOOMERANG could be leveraged to
completely compromise the untrusted OS (i.e., Android). While
the implications of these vulnerabilities are severe, defenses can be
quickly implemented by vendors, and we are currently in contact
with the affected TEE vendors to deploy adequate ﬁxes. To this
end, we evaluated the two most promising defense proposals
and their inherent trade-offs. This analysis led the proposal of a
novel BOOMERANG defense, addressing the major shortcomings
of the existing defenses with minimal performance overhead. Our
ﬁndings have been reported to and veriﬁed by the corresponding
vendors, who are currently in the process of creating security
patches.
Permission  to  freely  reproduce  all  or  part  of  this  paper  for  noncommercial 
purposes is granted provided that copies bear this notice and the full citation 
on the ﬁrst page.  Reproduction for commercial purposes is strictly prohibited 
without the prior written consent of the Internet Society, the ﬁrst-named author 
(for  reproduction  of  an  entire  paper  only),  and  the  author’s  employer  if  the 
paper  was  prepared  within  the  scope  of  employment.
NDSS  ’17,  26  February  -  1  March  2017,  San  Diego,  CA,  USA
Copyright  2017  Internet  Society,  ISBN  1-891562-46-0
http://dx.doi.org/10.14722/ndss.2017.23227
I.
INTRODUCTION
Today’s computer systems, including household appliances,
cars, and mobile phones, are subjected to an increasing range
of attacks. While legacy security mechanisms, including priv-
ilege levels and process isolation, continue to work for the
general case, they are unable to defend against sophisticated
attacks that are capable of compromising the operating system
(OS) itself. The ability to compromise the OS and the lack of
security in the face of compromise both stem, in part, from the
lack of segregation between the normal and security-critical
applications. To thwart these sophisticated attacks, hardware
manufacturers have introduced a new security mechanism,
known as a trusted execution environment (TEE) (e.g., ARM’s
TrustZone [2]). These new architectures permit the existence
of two separate worlds on the same system on a chip (SoC),
called the secure world (i.e., the world inside the TEE) and
the non-secure world (i.e., the sandboxed world containing the
main OS). Each of these worlds contains its own dedicated
OS and applications, and the software on the system is thus
considered to be either trusted (i.e., in the secure world) or
untrusted (i.e., in the non-secure world). The TEE works by
facilitating the creation of a non-secure world for untrusted
software, which is completely isolated from any critical code
within the secure world by hardware-enforced mechanisms.
Thus, by design, the secure world necessarily has access to all
of the non-secure world’s memory.
In practice, these two worlds frequently need to communi-
cate with each other (e.g., to encrypt or decrypt data with keys
stored inside the TEE). This communication is facilitated by
the OSes in both worlds, which leverage specialized memory
regions and central processing unit (CPU) registers to establish
an application programming interface (API) for the exchange
of data. Moreover, most trusted OSes also permit the instal-
lation of trusted applications (TAs) to expand functionality,
and offer services to the untrusted applications in the non-
secure world. In cases where larger volumes of data must be
processed in the secure world (e.g., when signing or encrypting
bulk data), it is convenient to permit the secure world to read
from and write to non-secure world memory directly. While the
secure world can protect itself from disclosing or overwriting
its own memory space, there is no inherent mechanism for the
secure world to guarantee the safety of operations on the non-
secure world’s memory. This lack of information, or semantic
gap, about the non-secure world from within the secure world
places a great deal of responsibility on the untrusted OS to
sanitize any inputs, especially pointers, that are passed into the
secure world. However, the APIs and data formats for each TA
tend to be application-speciﬁc, and are unknown to both the
untrusted and trusted OS.
In this paper, we present BOOMERANG, a class of vulner-
abilities that stem from the semantic gap between the non-
secure and secure worlds. BOOMERANG is a type of confused
deputy attack, wherein a user-level application in the non-
secure world can leverage a TA to read from or write to
non-secure world memory that it does not own, including
the untrusted OS’s. More speciﬁcally, a malicious user-level
application can send inputs to the TA, which are not properly
checked, that will trick the TA into manipulating memory
locations that should otherwise be inaccessible to the malicious
application. BOOMERANG vulnerabilities can be used to steal
or corrupt data in other user-level applications, or,
in the
worst case, to completely compromise the untrusted OS. We
found exploitable BOOMERANG vulnerabilities in four TEE
implementations. These vulnerabilities were detected using
a combination of manual analysis and an automated static
analysis tool, which is capable of locating potential vectors
for exploiting BOOMERANG in a given TA. We were able
to leverage vulnerabilities in two commercial TEE implemen-
tations to create proof-of-concept exploits: an arbitrary non-
secure world memory read and root-level privilege escalation.
These vulnerabilities, and our corresponding exploits, affect
hundreds of millions of devices that are currently in production
today.
The severity of BOOMERANG is evident, and we have been
working with Google and the affected handset manufacturer
partners (e.g., Qualcomm) to implement adequate defenses. We
will present recommendations for future TEE designs, as well
as immediate ﬁxes for the already-deployed TEE infrastruc-
ture. To this end, we evaluated the effectiveness and the trade-
offs of the two most promising defenses proposals: shared
memory and page table introspection. Additionally, we propose
a novel defense, called Cooperative Semantic Reconstruction
(CSR), which addresses the functionality shortcomings of
existing defenses with minimal performance overhead in the
general case. Our experiments suggest that CSR is the only
solution capable of providing the desired security guarantees,
while balancing both performance and ease-of-implementation.
locating BOOMERANG vulnerabilities in TAs.
In summary, our contributions1 are as follows:
• We present BOOMERANG, a new class of vulnerabilities
that arises from the semantic gap present between TEE
and the untrusted OS.
• We developed a static analysis technique capable of
• We evaluated the extent and severity of BOOMERANG by
examining the most popular TEE implementations and
their accompanying TAs.
• We developed a proof-of-concept memory leak and
to verify the hypothesized
• We evaluated the two existing BOOMERANG defenses,
and present CSR, a novel defense against BOOMERANG,
which outperforms the other proposals in all of the metrics
that we examined.
privilege-escalation exploit
severity of BOOMERANG.
1We released our proof-of-concepts, static analysis tool, and defense imple-
mentation at https://github.com/ucsb-seclab/boomerang/
2
II. BACKGROUND AND RELATED WORK
A TEE is a separate execution environment for code
and its associated data that requires a higher level of trust
than the typical operating system. TEEs can be implemented
as either a physically separated environment (i.e., dedicated
CPU and memory) or on the same SoC as the normal CPU
with specialized hardware-isolation mechanisms (e.g., ARM’s
TrustZone [2]). Because of this strict hardware isolation (e.g.,
separate registers, memory, and peripheral access), the two
execution environments are typically referred to as different
worlds: the secure world (i.e., the world within the TEE) and
the non-secure world. Because the software in the secure world
is assumed to have a higher level of trust than the software
executing in the non-secure world, we refer to all software
in the secure world as trusted and the software in the non-
secure as untrusted. Each world has its own OS, which we
refer to as the untrusted and trusted OSes, and each OS runs
its own respective accompanying applications, which we refer
to as untrusted applications (UAs) and trusted applications
(TAs). Similar to traditional execution environments, both the
secure and non-secure worlds segregate the applications and
their OSes using different execution privileges (i.e., user and
supervisor mode).
In TEE implementations where the secure and non-secure
worlds exist on the same SoC (e.g., TrustZone), the hardware
enforces isolation between the two worlds through the use of
specialized CPU registers and a non-secure (NS) bit. Speciﬁ-
cally, the NS bit is used to restrict access to memory and all
peripherals accessible on the Advanced eXtensible Interface
(AXI) bus. The context switching between the two worlds is
handled by a Secure Monitor that is instantiated when a secure
monitor call (SMC), or a special exception, is issued by either
a privileged (supervisor mode) application in the non-secure
world or any secure world application. To share information,
the worlds can pass a limited amount of information using
either registers or memory regions, which can either be dictated
by the secure world or passed by pointer reference.
The principal idea of the TEE is to minimize the trusted
computing base (TCB), in that the code running in the TEE
is intended to be a small, more easily veriﬁed subset of
the overall system that is used for security-sensitive tasks.
However, in practice, there is a strong desire to have the
TEE offer rich functionality to the non-secure world (e.g.,
digital rights management (DRM) [28], Trusted Input [3], or
authentication [23]). All of these applications require that a
communication channel between the two worlds is established
to share data over. This presents a major security risk to the
TEE, as it must accept input from the non-secure world and
its untrusted software. Indeed, numerous TEE implementations
have been exploited in practice [21], [25], [38], [43], which
resulted in a complete compromise of the secure world.
Consequently, there has been signiﬁcant work to secure this
channel [19] and formalize the APIs [13] to thwart these types
of attacks. Nevertheless, existing implementations still depend
on the non-secure world’s OS to sanitize any inputs before
passing them into the secure world, as sanitization in the secure
world is hindered by the semantic gap.
When the secure and non-secure worlds are on the same
SoC, as in TrustZone, at boot,
the processor will always
start in the secure world. The secure world software is then
Non-secure World
Secure World
TEE Daemon
User Application
4
Trusted Application
Library
1a
1b
1c
User Mode
3
User Mode
Driver Interface (ioctl)
Rich OS
e
c
a
f
r
e
t
n
I
E
E
T
2
S
e
c
u
r
e
M
o
n
i
t
o
r
Trusted OS
Supervisor Mode
Supervisor Mode
Fig. 1: High-level interactions when a user-level untrusted
application exchanges data with a trusted application in a
TrustZone-enabled SoC.
responsible for initializing the sandboxed, non-secure, world
and switching the process state to the non-secure mode. From
the non-secure world’s perspective, the existence of the secure
world is completely hidden, and the hardware architecture
presents itself as if the system had just booted, without any
evidence of the underlying secure world. However, by virtue of
the architecture, the secure world always maintains complete
control over and visibility into the non-secure world (similar
to a hypervisor and its guests). In fact, this feature has been
utilized to implement a variety of interesting systems, such
as: real-time kernel protection [4], transparent memory acqui-
sition [52], kernel-code integrity checking [11], TZ-enforced
Linux containers [42], and memory introspection [57].
Mobile phones have been one of the most prominent
adopters of this technology, and almost every modern smart-
phone comes equipped with a TrustZone-enabled Advanced
RISC Machine (ARM) processor. However, despite efforts to
enforce strict standards (e.g., GlobalPlatform [12]) on TEE
interactions, most of the software running inside these TEEs
is typically custom-built, and the trusted and untrusted software
are commonly developed by completely disjoint entities. For
example, on Android devices, while Google is responsible
for the untrusted OS,
the secure world OS is commonly
developed by other parties like Qualcomm [37], Trustonic [53],
Nvidia [34], and the open-source community [34], [51]. How-
ever, it does appear that Google may eventually deploy their
own trusted OS, which they call Trusty [16].
The existence of BOOMERANG is fundamentally due to
the desire to share memory between untrusted and trusted
applications. The lack of well-deﬁned, secure, standards and
mechanisms for secure world applications to verify security
properties of non-secure memory addresses results in scenarios
wherein untrusted applications can convince trusted applica-