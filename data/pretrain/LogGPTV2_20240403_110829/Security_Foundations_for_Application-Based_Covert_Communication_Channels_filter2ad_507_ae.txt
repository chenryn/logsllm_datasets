2, . . ., Sink
outputs (a) either a sequence of one or more strings ws =
2, . . . or distinguished symbol ⊥, and (b) an ap-
ws
1, ws
plication log string α. We write (ws, α) ←← Sinkγ(wc)
to denote executing Sink on input wc under application
♢
context γ.
Remark. We interpret the environment context ξ as specifying
public deployment parameters (i.e., application configuration),
while the application context γ captures shared parameters
(possibly including secrets) for a given execution or session
of the application. The additional initialization leakage ˆγ rep-
resents side information that an eavesdropper may observe if,
for example, Init is realized by an interactive protocol between
Source and Sink over an insecure channel. This distinction
will become technically relevant when we present our security
notion (cf. §V), where ˆγ is provided to the adversary but γ is
not. Intuitively, our security notion will demand that ˆγ cannot
signal to the adversary information that allows it to distinguish
between covert and overt execution.
The vector x given to Source captures any user inputs,
such as clicking a link when web browsing. The vector wc
captures any data sent over the network by Source, intended
for Sink. The vector ws captures any data sent over the
network by Sink, intended for Source, in response to what it
last received. The application log α captures any application
data stored on the Sink system, such as log files, etc. We
include this additional output to make it available to a covert
channel receiver.
Example. Consider Protozoa. Here, the application channel is
WebRTC: Source and Sink denote the two interacting web
clients, and Init captures the establishment of the WebRTC
connection.
♯
Example. Consider Balboa for web browsing. Source denotes
the web browser and Sink denotes the web server. Init captures
the initialization of the connection between the web browser
and web server—for example,
the TLS handshake in the
case that the parties are utilizing HTTPS, in which case the
application context γ contains the established TLS key of the
connection, whereas the initialization leakage ˆγ contains any
TLS handshake data (e.g., cipher suites).
♯
We also introduce the notion of a user which produces
inputs to drive Source. Intuitively, what we formalize in the
next definition is an algorithmic model of user behavior, in
the context of that user interacting with a specific application.
Definition 6. A user User is a stateful and randomized
algorithm that is parameterized by application context γ. It
has one valid input, a distinguished string NEXT, and upon
this input, User outputs a sequence of one or more strings
x = x1, x2, . . . . We write x ←← Userγ(NEXT) to denote one
♢
“step” of User under application context γ.
Remark. By convention, we assume strings output by User
are always valid inputs to Source, strings output by Source
are always valid inputs to Sink, and vice versa. We also
constrain the output of Source and Sink such that, after fixing
an application context and (implicit) state, for each distinct
input the algorithms either always return ⊥ or never return ⊥;
we refer to such inputs as invalid or valid respectively. Finally
we require that for every application context and state there
exists at least one valid input. Intuitively, this requirement
captures that idea that an application can be used indefinitely
without unexpected termination.
B. Application-based covert channels
Before presenting the formal definition of an application-
based covert channel (ABCC), we first define a message buffer
oracle MsgBuf which provides an interface for pushing and
pulling messages to and from a queue. The message buffer
oracle takes two inputs; the first is a distinguished string in
the set {PUSH, PULL}, and the second depends on whether PUSH
or PULL is used. For MsgBuf(PUSH,·), the second argument
is a string which is then appended to an internal buffer. For
MsgBuf(PULL,·), the second argument is an integer which
denotes the string length to return from the buffer (in first
in, first out order). If the length argument is greater than the
current length of the buffer, then no bits are pulled and the
empty string is returned.
In the context of an ABCC, the message buffer stores
plaintext message inputs to the covert channel. While it
adds some complexity to the model, we utilize a buffer
because there are two potential places in which we can embed
messages—before the application is called, and after—and
the choice of how messages are embedded can be left up
to the covert channel itself. Furthermore, by decoupling the
output of the covert channel from the input of individual
covert messages, we capture the notion of a “best effort” covert
channel which can choose when and where to embed messages
within the stream generated by the overt application. This
flexibility can be contrasted with the standard definition of
a stegosystem (cf. [11], Def. 3), which functions atomically—
on input a covert message, a correct stegoencoder must output
covertext
that embeds the entire message, using only the
current channel history in queries to its channel oracle.
Remark. For reference, an explicit pseudocode description of
the MsgBuf oracle appears in Figure 3. We have elided this
description in subsequent figures which refer to the oracle.
Furthermore, where no confusion may result, we use the
shorthand PUSH to denote MsgBuf(PUSH,·) and PULL to denote
MsgBuf(PULL,·).
Definition 7. For application channel App, an App-based
covert channel is a tuple of randomized algorithms Π =
(Setup, Embeduser, Embedwire, Extractwire, Extractuser) with
the following specifications:
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:36:38 UTC from IEEE Xplore.  Restrictions apply. 
1976
• Setup: A randomized algorithm which, on input environ-
ment context ξ, outputs key K and embedding hint h.
• Embeduser: A stateful and randomized algorithm which,
on input key K, application context γ, embedding hint h,
and sequence of one or more strings x = x1, x2, . . . ,
outputs a sequence of one or more strings x′ =
x′
1, x′
2, . . .. In addition, Embeduser has oracle access to
MsgBuf(PULL,·).
• Embedwire: A stateful and randomized algorithm which,
on input key K, application context γ, embedding hint h,
and sequence of one or more strings wc = w1, w2, . . .,
outputs a sequence of one or more strings wc =
w′
1, w′
2, . . .. In addition, Embeduser has oracle access to
MsgBuf(PULL,·).
• Extractwire: A stateful algorithm which, on input key K,
application context γ, embedding hint h, and sequence
of one or more strings wc = w1, w2, . . ., outputs se-
quence of one or more strings wc = w′
2, . . . and
plaintext Mwire.
• Extractuser: A stateful algorithm which, on input key K,
embedding hint h, and application log α, outputs plain-
♢
text Muser.
1, w′
Correctness. Intuitively, for a covert channel to be correct it
must successfully extract all embedded messages in the same
order they were embedded.
Definition 8. An App-based covert channel is correct if, for all
environment contexts ξ, all application contexts generated by
(γ, ) ←← Init(ξ), all keys and embedding hints generated by
(K, h) ←← Setup(ξ), all App-users User, all valid sequences
ws, and all states of the message buffer BUF, the following
holds:
Execute the sequence
user (K, γ, h, x)
x ←← Userγ(NEXT)
x ←← EmbedPULL
wc ←← Sourceγ(x, ws)
wc ←← EmbedPULL
(wc, Mwire) ←← Extractwire(K, γ, h, wc)
( , α) ←← Sinkγ(wc)
Muser ←← Extractuser(K, h, α)
wire (K, γ, h, wc)
= BUF.
and let BUF′ denote the state of the message buffer oracle
after execution. Then, Muser∥Mwire∥BUF′
♢
Remark. Our definition of correctness, and our upcoming se-
curity notion, impose a continuation-style execution semantics:
first Embeduser runs, pulling message bits from the buffer,
until it has finished processing its current inputs; then Source
runs, until it has finished processing the just-produced outputs
of Embeduser; then Embedwire runs, pulling message bits from
the buffer, until it has finished processing the just-produced
outputs of Source. Only then may Embeduser run again, and
so on. This subtle point is important, as it allows us to avoid
situations where, say, the message bits pulled by Embeduser
are arbitrarily interleaved with those pulled by Embedwire
Oracle MsgBuf(PUSH, v)
BUF ← BUF∥v
return ⊤
Oracle MsgBuf(PULL, v)
if v > |BUF| then return ε
H ← BUF[1 : v]
BUF ← BUF[v + 1 : |BUF|]
return H