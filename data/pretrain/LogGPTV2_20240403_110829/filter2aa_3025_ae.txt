  value	
  is	
  1.	
When	
  constructing	
  the	
  string	
  value	
  in	
  DETAILS.ALBUM_ART,	
  we	
  ensure	
  it	
  passes	
  the	
  atoi()	
  check	
  by	
starting	
  it	
  with	
  the	
  character	
  ‘1’.	
We	
  need	
  to	
  build	
  up	
  a	
  long	
  string	
  in	
  our	
  record’s	
  ALBUM_ART	
  field	
  of	
  the	
  DETAILS	
  table.	
  Recall	
  that	
  we	
will	
  be	
  exploiting	
  the	
  SendResp_albumArt()	
  function,	
  and	
  the	
  string	
  passed	
  into	
  it	
  is	
  not	
  arbitrarily	
long.	
  In	
  fact,	
  it	
  is	
  just	
  over	
  500	
  bytes	
  at	
  most.	
  The	
  ‘object’	
  string	
  consists	
  of	
  the	
  requested	
  object	
  path,	
e.g.,	
  ‘/AlbumArt/1-18.jpg’	
  plus	
  the	
  overhead	
  of	
  the	
  injected	
  SQL	
  syntax.	
  Further,	
  the	
  SQL	
  query	
  gets	
written	
  into	
  a	
  buffer	
  that	
  is	
  256	
  (Listing	
  4)	
  bytes	
  in	
  size,	
  even	
  though	
  the	
  ‘object’	
  string	
  can	
  be	
  as	
  long	
  as	
500	
  bytes.	
  This	
  clearly	
  is	
  a	
  bug,	
  but	
  it’s	
  not	
  the	
  bug	
  we’re	
  attempting	
  to	
  exploit.	
  It	
  is	
  a	
  good	
  idea	
  to	
  keep	
the	
  value	
  that	
  we’re	
  injecting	
  into	
  the	
  ALBUM_ART	
  field	
  to	
  a	
  safe	
  length	
  of	
  128	
  bytes.	
  How	
  can	
  we	
overflow	
  a	
  buffer	
  512	
  bytes	
  in	
  length	
  by	
  enough	
  excess	
  to	
  successfully	
  overwrite	
  the	
  return	
  address	
saved	
  at	
  the	
  top	
  of	
  the	
  stack	
  frame?	
  Using	
  SQLite’s	
  concatenation	
  operator,	
  ‘||’,	
  we	
  can	
  build	
  the	
excessively	
  long	
  string	
  in	
  multiple	
  SQL	
  injection	
  passes,	
  and	
  keep	
  appending	
  more	
  data	
  to	
  the	
  previous.	
For	
  example:	
UPDATE/**/DETAILS/**/set/**/ALBUM_ART=ALBUM_ART||“AAAA”/**/where/**/ID="3";' 
SQL	
  Injection	
  to	
  MIPS	
  Overflows:	
  Rooting	
  SOHO	
  Routers	
Zachary	
  Cutlip	
15 
Appendix	
  B	
  is	
  a	
  listing	
  of	
  a	
  Python	
  script	
  that	
  will	
  insert	
  our	
  long	
  test	
  string	
  into	
  the	
  target’s	
  database.	
In	
  order	
  to	
  trigger	
  the	
  buffer	
  overflow,	
  the	
  client	
  must	
  send	
  a	
  proper	
  SOAP	
  request	
  to	
  MiniDLNA	
  such	
that	
  staged	
  database	
  records	
  are	
  queried	
  and	
  the	
  results	
  processed	
  by	
  the	
  vulnerable	
  callback()	
function.	
SQL	
  Injection	
  to	
  MIPS	
  Overflows:	
  Rooting	
  SOHO	
  Routers	
Zachary	
  Cutlip	
16 
Appendix	
  C	
  is	
  a	
  listing	
  of	
  a	
  Python	
  script	
  that	
  will	
  generate	
  a	
  complete	
  DLNA	
  discovery	
  and	
  conversation.	
We	
  can	
  use	
  it	
  to	
  capture	
  the	
  key	
  SOAP	
  request	
  between	
  client	
  and	
  server	
  using	
  Wireshark	
  and	
  capture	
  it	
for	
  playback.	
Figure 19 Isolating the SOAP request that causes our staged record to be queried. 
SQL	
  Injection	
  to	
  MIPS	
  Overflows:	
  Rooting	
  SOHO	
  Routers	
Zachary	
  Cutlip	
17 
Appendix	
  D	
  lists	
  the	
  SOAP	
  request	
  XML	
  document	
  that	
  will	
  query	
  the	
  ‘PWNED’	
  object	
  ID,	
  thus	
  triggering	
the	
  exploit.	
Having	
  staged	
  the	
  buffer	
  overflow	
  in	
  the	
  database,	
  we	
  can	
  trigger	
  it	
  by	
  sending	
  the	
  captured	
  SOAP	
request	
  using	
  the	
  following	
  wget	
  command:	
$ wget http://10.10.10.1:8200/ctl/ContentDir --header="Host: 10.10.10.1" \ 
  --header=\ 
  'SOAPACTION: "urn:schemas-upnp-org:service:ContentDirectory:1#Browse"' \ 
  --header='"content-type: text/xml ;charset="utf-8"' \ 
  --header="connection: close" --post-file=./soaprequest.xml  
Using	
  a	
  USB	
  disk,	
  we	
  can	
  load	
  a	
  gdbserver	
  cross-­‐compiled6	
  for	
  little	
  endian	
  MIPS	
  onto	
  the	
  live	
  device	
and	
  attach	
  to	
  the	
  running	
  minidlna.exe	
  process.	
  In	
  order	
  to	
  remotely	
  debug	
  we	
  will	
  need	
  to	
  use	
  a	
gdb	
  compiled	
  for	
  our	
  own	
  machine’s	
  host	
  architecture	
  and	
  the	
  little	
  endian	
  MIPS	
  target	
  architecture.	
When	
  sending	
  the	
  SOAP	
  request,	
  we	
  can	
  see	
  gdb	
  catch	
  the	
  crash	
  and	
  that	
  our	
  data	
  lands	
  in	
  the	
  program	
counter:	
Figure 20 Crashing minidlna.exe with control PC register and all S registers. 
We	
  now	
  have	
  control	
  of	
  the	
  program	
  counter,	
  and	
  by	
  extension,	
  the	
  program’s	
  flow	
  of	
  execution.	
Further,	
  we	
  have	
  control	
  over	
  all	
  of	
  the	
  S-­‐registers!	
  This	
  makes	
  things	
  easier	
  as	
  we	
  develop	
  our	
  exploit.	
We	
  overflowed	
  the	
  target	
  buffer	
  with	
  approximately	
  640	
  bytes	
  of	
  data.	
  If	
  we	
  rerun	
  the	
  program	
  with	
  a	
much	
  larger	
  overflow,	
  say	
  over	
  2500	
  bytes,	
  we	
  will	
  be	
  able	
  to	
  see	
  how	
  much	
  of	
  the	
  stack	
  we	
  can	
  control.	
6	
  Cross-­‐compilation	
  is	
  beyond	
  the	
  scope	
  of	
  this	
  paper	
  and	
  is	
  left	
  as	
  an	
  exercise	
  for	
  the	
  reader.	
SQL	
  Injection	
  to	
  MIPS	
  Overflows:	
  Rooting	
  SOHO	
  Routers	
Zachary	
  Cutlip	
18 
We	
  are	
  able	
  to	
  view	
  the	
  state	
  of	
  the	
  stack	
  and	
  the	
  time	
  of	
  crash	
  in	
  gdb.	
  The	
  figure	
  below	
  shows	
  that	
  we	
can	
  control	
  an	
  arbitrary	
  amount	
  of	
  the	
  stack	
  space.	
  Our	
  longer	
  overflow	
  string	
  does	
  not	
  appear	
  to	
  get	
truncated.	
  This	
  gives	
  plenty	
  of	
  room	
  to	
  build	
  a	
  ROP7	
  chain	
  and	
  to	
  stage	
  a	
  payload.	
  We	
  can	
  use	
  the	
  ROP	
exploitation	
  technique	
  to	
  locate	
  a	
  stack	
  address	
  and	
  return	
  into	
  our	
  code	
  there.	
A	
  working	
  exploit	
  buffer	
  is	
  provided	
  in	
  Appendix	
  E.	
  It	
  includes	
  a	
  reverse	
  TCP	
  connect-­‐back	
  shell	
  that	
connects	
  back	
  to	
  the	
  IP	
  address	
  10.10.10.10,	
  port	
  31337.	
7	
  Return	
  Oriented	
  Programming,	
  ROP,	
  is	
  an	
  exploitation	
  technique	
  by	
  which	
  the	
  attacker	
  causes	
  the	
  compromised	
program	
  to	
  execute	
  existing	
  instructions	
  that	
  are	
  part	
  of	
  the	
  program	
  or	
  its	
  libraries,	
  rather	
  than	
  executing	
  buffer	
overflow	
  data	
  directly.	
  http://cseweb.ucsd.edu/~hovav/talks/blackhat08.html	
SQL	
  Injection	
  to	
  MIPS	
  Overflows:	
  Rooting	
  SOHO	
  Routers	
Zachary	
  Cutlip	
19 
Figure 21 A view of the stack after overflowing the buffer. We can put a large amount of user-controlled data on the 
stack.  
SQL	
  Injection	
  to	
  MIPS	
  Overflows:	
  Rooting	
  SOHO	
  Routers	
Zachary	
  Cutlip	
20 
Affected Devices 
In	
  researching	
  these	
  vulnerabilities,	
  I	
  obtained	
  and	
  analyzed	
  the	
  firmware	
  for	