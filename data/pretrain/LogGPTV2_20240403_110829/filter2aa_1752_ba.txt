以 signal() 示内对的进程或新设
的操作。以的实
SIG DFL 将 signo 示的设操作。对 SIGPIPE进程将
。
SIG IGN  signo 示的。
signal()          的 操 作        处 理 程 
SIG DFL 或 SIG IGN 的。出时 SIG ERR设 errno。
9.2.1 等待信号
出调写示的的 POSIX 的 pause() 调以
进程进程处理或进程的
#include 
int pause (void);
– 305 –
 9 
pause() 的时处理
pause()  -1将 errno 设 EINTR。内出的
进程。
 Linux 内 pause() 单的调。操
作。将进程的。然调 schedule() Linux
进程调进程。进程实上何件
内的。实调 C 。∗
9.2.2 例子
我们单的子。子 SIGINT 单的
处理程然程（ SIGINT 
#include 
#include 
#include 
#include 
/* SIGINT 的处理程 */
static void sigint_handler (int signo)
{
/*
* 上处理程
printf()
* 的。
* 我以。
*/
printf (”Caught SIGINT!\n”);
exit (EXIT_SUCCESS);
}
int main (void)
∗ pause() 单的调。的 getpid()  gettid()们。
– 306 –
 9 
{
/*
*  sigint_handler 作 SIGINT 的处理程
。
*/
if (signal (SIGINT, sigint_handler) ==
SIG_ERR) {
fprintf (stderr, ”Cannot handle
SIGINT!\n”);
exit (EXIT_FAILURE);
}
for (;;)
pause ( );
return 0;
}
的子我们 SIGTERM  SIGINT 相同的处理程
。我们将 SIGPROF 操作（进程 SIGHUP（
进程
#include
#include
#include
#include
/* SIGINT 的处理程 */
static void signal_handler (int signo)
{
if (signo == SIGINT)
printf (”Caught SIGINT!\n”);
else if (signo == SIGTERM)
printf (”Caught SIGTERM!\n”);
else {
– 307 –
 9 
/*  */
fprintf (stderr, ”Unexpected signal!\n”);
exit (EXIT_FAILURE);
}
exit (EXIT_SUCCESS);
}
int main (void)
{
/*
*  signal_handler 作 SIGINT 的处理程。
*/
if (signal (SIGINT, signal_handler) == SIG_ERR)
{
fprintf (stderr, ”Cannot handle SIGINT!\n”);
exit (EXIT_FAILURE);
}
/*
*  signal_handler 作 SIGTERM 的处理程。
*/
if (signal (SIGTERM, signal_handler) ==
SIG_ERR) {
fprintf(stderr, ”Cannot handle SIGTERM!\n”);
exit (EXIT_FAILURE);
}
/* 将 SIGPROF 设操作。 */
if (signal (SIGPROF, SIG_DFL) == SIG_ERR) {
fprintf (stderr, ”Cannot reset SIGPROF!\n”);
exit (EXIT_FAILURE);
}
/*  SIGHUP 。 */
if (signal (SIGHUP, SIG_IGN) == SIG_ERR) {
– 308 –
 9 
fprintf (stderr, ”Cannot ignore SIGHUP!\n”);
exit (EXIT_FAILURE);
}
for (;;)
pause ( );
return 0;
}
9.2.3 执行与继承
进程时的设操作进程（
新进程的进程们新的进程
。新进程何进程的操作
的。理的的进程进程
的空间何的处理程能存。
进程程的的内
进程时（或进程进程新的进程
出。内进程将 SIGINT 
SIGQUIT 设 SIG IGN。处理的程以
的。
/*  SIG_INT 时处理 */
if (signal (SIGINT, SIG_IGN) != SIG_IGN) {
if (signal (SIGINT, sigint_handler) == SIG_ERR)
fprintf (stderr, ”Failed to handle
SIGINT!\n”);
}
/*  SIGQUIT 时处理 */
if (signal (SIGQUIT, SIG_IGN) != SIG_IGN) {
if (signal(SIGQUIT, sigquit_handler) == SIG_ERR)
fprintf (stderr, ”Failed to handle
SIGQUIT!\n”);
– 309 –
 9 
}
设的的 signal() 出
的。我们的。
fork() 的能的同。进程调 fork() 时子进程
同的。理的子进程进程同空
间进程的处理程然存子进程。
9.2.4 映射信号编号为字符串
我们的子我们将。时将
的更方（。方以
的。
extern const char * const sys_siglist[];
sys siglist 存的的进
。
 BSD 的 psignal()  Linux 的
#include 
void psignal (int signo, const char *msg);
调 psignal()  stderr 出提的 msg 
空 signo 示的。 signo 效的出
将进提示。
更的 strsignal()。的 Linux  Linux
#define _GNU_SOURCE
#include 
char *strsignal (int signo);
调 strsignal()  signo 的。 signo 效
的的以提示（的 Unix  NULL。
的调 strsignal() 效的程
的。
– 310 –
 9 
sys siglist 的。方我们以写我们的
处理程
static void signal_handler (int signo)
{
printf (”Caught %s\n”, sys_siglist[signo]);
}
9.3 发送信号
kill() 调我们的 kill 以的 kill() 
进程进程
#include 
#include 
int kill (pid_t pid, int signo);
的 kill() 给 pid 的进程 signo。
 pid  0 signo 给调进程的进程的进程。
 pid  -1 signo 调进程的进程出
调进程自 init 。我们将小的理。
 pid 小 -1 signo 给进程 -pid。
的 kill()  0。出调
的。的（调 -1将 errno 设以
EINVAL  signo 的效。
EPERM 调进程的进程。
ESRCH
 pid 的进程或进程存或进程进程。
9.3.1 权限
给进程的进程的。 CAP KILL
的进程（的进程能给何进程。
进程的效的或真的 ID 进程的真的或存的
 ID。单的能给或自的进程。
– 311 –
 9 
Unix  SIGCOUT 同进
程以给何的进程。 ID 相同。
 signo  0提的空调
然进。对进程
的给的进程时。
9.3.2 例子
以何给进程 1722 的进程 SIGHUP 的
int ret;
ret = kill (1722, SIGHUP);
if (ret)
perror (”kill”);
以上段的 kill 能相同
$ kill -HUP 1722
我们给 1722 进程实上何我
们以方式进
int ret;
ret = kill (1722, 0);
if (ret)
; /* 我们 */
else
; /* 我们 */
9.3.3 给自己发送信号
raise() 单的进程给自的方
#include 
int raise (int signo);
– 312 –
 9 
调
raise (signo);
的调的
kill (getpid (), signo);
调时 0时 0 。设 errno。
9.3.4 给整个进程组发送信号
方的给进程的进程
单进程的 ID 的作调 kill() 
#include 
int killpg (int pgrp, int signo);
调
killpg (pgrp, signo);
的调
kill (-pgrp, signo);
即 pgrp  0的 kill() 给调进程的
进程 signo。
时 killpg()  0时 -1将 errno 设以
EINVAL  signo 的效。
EPERM 调进程的给进程。
ESRCH
 pgrp 的进程存。
9.4 重入
内时进程能的何。进程能
的操作进程将处的（
更新或进。进程能处理
。
– 313 –
 9 
时处理程能进程处理程
以何。何进程设的处理程谨的对
的操作及的。处理程对进程时
的何设。（的时
谨。的处理程的
的我们时的方提处理
处理程进程的操作方。
调的进程写文件或
内存处理程同文件写或调 malloc() 或
时进程调存的 strsignal()
然的。程的
处理程调同的的
。以的调自（或同进程的
程的。能操作操作
的或调提的调何的。
9.4.1 有保证的可重入函数
写处理程时设的进程能处的
（或的东。处理程
。
布（即的单处
理程的。的 POSIX.1-2003  Unix 们
上的单。 9-2 出
。
 9-2 的的
– 314 –
 9 
abort()
accept()
access()
aio error()
aio return()
aio suspend()
alarm()
bind()
cfgetispeed()
cfgetospeed()
cfsetispeed()
cfsetospeed()
chdir()
chmod()
chown()
clock gettime()
close()
connect()
creat()
dup()
dup2()
execle()
execve()
Exit()
exit()
fchmod()
fchown()
fcntl()
fdatasync()
fork()
fpathconf()
fstat()
fsync()
ftruncate()
getegid()
geteuid()
getgid()
getgroups()
getpeername()
getpgrp()
getpid()
getppid()
getsockname()
getsockopt()
getuid()
kill()
link()
listen()
lseek()
lstat()
mkdir()
mkfifo()
open()
pathconf()
pause()
pipe()
poll()
posix trace event()
pselect()
raise()
read()
readlink()
recv()
recvfrom()
recvmsg()
rename()
rmdir()
select()
sem post()
send()
sendmsg()
sendto()
setgid()
setpgid()
setsid()
setsockopt()
setuid()
shutdown()
sigaction()
sigaddset()
sigdelset()
sigemptyset()
sigfillset()
sigismember()
signal()
sigpause()
sigpending()
sigprocmask()
sigqueue()
sigset()
sigsuspend()
sleep()
socket()
socketpair()
stat()
symlink()
sysconf()
tcdrain()
tcflow()
tcflush()
tcgetattr()
tcgetpgrp()
tcsendbreak()
tcsetattr()
tcsetpgrp()
time()
timer getoverrun()
timer gettime()
timer settime()
times()
umask()
– 315 –
 9 
更的的 Linux  POSIX 的
的。
9.5 信号集
我们将提的操作集进程
的的集或处理的集。以出的集操作以理
集
#include 
int sigemptyset (sigset_t *set);
int sigfillset (sigset_t *set);
int sigaddset (sigset_t *set, int signo);
int sigdelset (sigset_t *set, int signo);
int sigismember (const sigset_t *set, int signo);
sigemptyset()  set 给的集将集空（的
集。 sigfillset()  set 给的集将满（
的集内。 0。集调