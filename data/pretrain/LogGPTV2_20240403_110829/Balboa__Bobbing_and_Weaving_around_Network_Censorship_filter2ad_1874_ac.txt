We re-use the existing certiﬁcate mechanism in TLS for the
client to authenticate the server. Balboa clients are provi-
sioned with a pinned public key certiﬁcate which is validated
against the signature that the server sends in its Server Key
Exchange TLS Handshake record. If the signature does not
match, Balboa enters a transparent pass-through state and
makes no modiﬁcation to the trafﬁc.
2.6.2 How the Server Authenticates the Client
The main challenge with signaling is for the server to authen-
ticate the client. Balboa’s protocol has two settings: (1) one in
which it assumes that the server waits for a TLS Application
USENIX Association
30th USENIX Security Symposium    3405
does not know whether the server knows that the client is a
Balboa-client.
We solve this problem by having the server acknowledge
that it received the client’s initial signal. By having the server
signal on its outgoing half of the duplex connection, any sub-
sequent messages that it sends will arrive after its acknowl-
edgement message. The server sends its acknowledgment
message by replacing the MAC T on an outgoing Applica-
tion Data record with T ⊕ kS. After sending this message, the
server can start its normal Balboa operations. The client scans
incoming Application Data records and performs the same
check from above to ﬁnd an Application Data record where
the MAC is T ⊕ kS. After observing that message, the client
is free to start rewriting incoming trafﬁc from the server.
2.6.3 Security of Signaling
Several CRSs [7, 11] use a signaling technique based on
Telex [27] which modiﬁes the Client Random ﬁeld of the
TLS Client Hello message. While this change is indistinguish-
able to a censor, we do not use this technique because it would
require us to re-implement many more pieces of TLS, and
it would not work with our method of using TLS libraries’
debugging features to extract TLS key material. In addition,
Telex’s signaling scheme does not offer forward secrecy: a
censor can record network trafﬁc and then, if at any point in
the future they compromise the server, they would be able
to go back through the recorded trafﬁc and determine which
connections used signaling.
In contrast, Balboa’s signaling scheme inherits the forward
secrecy of TLS: because the key material that Balboa uses to
perform signaling is based on the ephemeral key of the TLS
connection, any future compromise of the server would not
reveal which connections had signaling. As a result, Balboa’s
shared covert signaling secret has the same security properties
of Telex’s public key: any client with the key can authenti-
cate itself to the server, but the key does not allow any client
(except for the sever) to identify which clients are using the
key.
3 Balboa Instantiations
We have implemented two instantiations of Balboa: one for
audio streaming and one for web browsing. We describe each
in turn.
3.1 Audio Streaming
This instantiation supports Ogg Vorbis audio streaming trafﬁc
generated by an Icecast instance, with the client running a
media player such as VLC9. The trafﬁc model in this case is
9We have in addition validated that Balboa works for several other media
players, including Audacious, Rhythmbox, etc.
a single Ogg Vorbis ﬁle containing a concatenation of audio
ﬁles.
Our rewriter works speciﬁcally for Ogg Vorbis trafﬁc. Vor-
bis is a free and patent-free audio coding format (similar to
MP3), and Ogg provides a container format for transmitting
Vorbis streams. Icecast streams audio data to the client in an
HTTP/1.0 response which does not terminate. Ogg data itself
is broken up into pages, each of which starts with an Ogg
page header.
When the rewriter encounters an Ogg page, it determines
whether the page is a candidate to be rewritten. A page is
“rewriteable” if its body can be found in the source audio
(i.e., the trafﬁc model). Because an Ogg page might not ﬁt
entirely in a single TLS record, the rewriter sometimes has
to decide whether a page is rewriteable before seeing it in its
entirety. To get around this, the rewriter searches for audio
data preﬁxed by what it has learned is in the body. It then
uses the CRC32 checksum present in the original Ogg page to
determine whether its guess of the audio data was correct. If
the rewriter is unable to ﬁnd a match, then it passes the page
through unmodiﬁed.
If the rewriter does decide to rewrite an Ogg page, it re-
places the Version ﬁeld, which is normally a ‘0’, with ‘*’10.
This Version ﬁeld signals to the receiver that it should attempt
to rewrite the page. Next, the rewriter replaces the Bitstream
Serial Number with the byte offset in the original audio data
to which the data in the page corresponds. With the page
header modiﬁed, the rewriter can replace the entire audio data
component with covert data.
To rewrite an Ogg page on the receiver’s side, we ﬁrst check
whether the page corresponds to covert data by checking that
the Version ﬁeld in the page header is the magic number ‘*’.
If so, we extract the data and then replace it with the actual
audio data using the location speciﬁed in the Bitstream Serial
Number.
3.2 Web Browsing
This instantiation handles web browsing between a Firefox
client and an Apache web server. We consider a trafﬁc model
in which the communicating parties share a directory of
shared assets, such as HTML, images, video ﬁles, etc., and cur-
rently only support a unidirectional covert channel between
the server and client.
Our rewriter works by parsing the HTTP request made
by the client and storing the HTTP version, method,
request URI, and headers. For example, a request
to
https://example.com/dir/index.html might have a ver-
sion of HTTP/1.1, a GET method, /dir/index.html as the
request URI, and header values for ﬁelds such as Host,
User-Agent, and Cookie. Similarly, when the server receives
the HTTP request, its rewriter parses and stores the request in-
formation. The server’s rewriter waits until an HTTP response
10The choice of ‘*’ is arbitrary.
3406    30th USENIX Security Symposium
USENIX Association
is sent in reply. The rewriter parses the response to extract the
status code and headers. If the status code indicates success
and the request URI matches a shared asset, the body of the
HTTP response is overwritten with covert data. In addition, to
indicate to the client that rewriting has occurred, the third byte
of the \r\n\r\n bytes between the response header and body
is rewritten to 0xff. When the client receives the response,
its rewriter parses the response. If the 0xff byte is present,
the rewriter extracts the covert data and replaces it with the
shared asset data.
HTTP allows partial downloads of ﬁles, which is often used
for streaming audio or video ﬁles. Our HTTP rewriter sup-
ports this functionality by ﬁrst checking for a 206 Partial
Content status code. It then checks for Content-Range
headers in the HTTP response and rewrites the shared asset
with the appropriate position offset and length based on values
in the range header.
4 Implementation
We have implemented Balboa alongside rewriters for au-
dio streaming and web browsing. Balboa is implemented in
Rust and is available at https://github.com/GaloisInc/
balboa under an Apache 2.0/MIT dual-license.
Code organization. Balboa is comprised of several Rust
crates that correspond to the components depicted in Figure 1:
• injection contains the core code and traits for injecting
code into a shared library. A rewriter for Balboa needs
to provide implementations of the associated traits for
the particular application being injected.
• tlsRewriter contains code for rewriting the TLS
records, and handles the decryption and re-encryption
required. We have tested the rewriter with the following
TLS libraries: OpenSSL, GnuTLS, and Rustls.
• rewriter contains the traits for implementing protocol-
speciﬁc (plaintext) rewriters. An instantiation of Balboa
needs to provide implementations of these traits.
Because Balboa must contend with partial reads (cf. §2.5.4),
it can be tedious to manually write a state machine to per-
form byte manipulations. To remedy this, the rewriter and
tlsRewriter components are written as coroutines. Coding
in this style makes the rewriter implementations smaller and
easier to develop.
For our audio streaming rewriter, we implemented the
rewriter described in §3.1 and implemented wrapper code
for injecting Balboa into VLC and Icecast. This wrapper code
is reusable across multiple multimedia clients; for example,
the wrapper code works for Audacious, Rhythmbox, MPlayer,
and mpv, among others, without requiring a single line of
code to be changed from the original VLC implementation.
Our web browsing rewriter proceeded similarly: we im-
plemented the rewriter described in §3.2 and implemented
wrapper code for injecting Balboa into Firefox and the Apache
Web Server. We have additionally tested the Firefox injector
on curl.
High speed logging. We developed a highly-performant log-
ging library called Stallone (available at https://github.
com/GaloisInc/stallone) to facilitate debugging Balboa
both during implementation and for any potential future de-
ployment. Due to the careful performance considerations
required, we could not use existing logging libraries, as those
add overheads of hundreds of microseconds per log entry,
which would add noticeable delay to a running Balboa in-
stance. We thus designed Stallone from scratch, taking inspi-
ration from the NanoLog library [29]. Compared to NanoLog,
Stallone does not rely on the CPU’s timestamp counter, which
might not be stable or valid in cloud environments or in any
situation where the user does not know what exact CPU model
they are working with [28]. In addition, Stallone uses stable
identiﬁers for log record types and stores the mapping be-
tween log record identiﬁers and log record metadata (such
as the message and line number) in a special section of the
binary, eliminating the need for this information to be dumped
online. Stallone is written in Rust and is capable of logging
messages at an overhead of around 10 nanoseconds, and as
such may be of independent interest.
5 Security Analysis
In this section we discuss the security of Balboa versus a
censor that controls all network trafﬁc between the communi-
cating parties, and either passively monitors the network or
actively manipulates, blocks, or injects packets. Due to the
heavy systems engineering and subtle implementation details
required in building Balboa—alongside a lack of security
deﬁnitions within the ﬁeld of censorship circumvention—we
forgo a formal (i.e., “provable security”) treatment of Balboa.
Instead, given the relative simplicity of the cryptography in-
side Balboa, we focus more closely on the practical security of
the implementation (and the timing channel that it produces).
Identifying the signaling protocol. Balboa’s signaling pro-
tocol (cf. §2.6) replaces the original MAC of a TLS record
with a one-time-pad of the MAC and a key derived from the
TLS master secret and the pre-shared secret. Because the mas-
ter secret is chosen pseudorandomly for each connection, and
because the censor does not know the pre-shared secret, the
new MAC is indistinguishable from the original to a censor.
However, Balboa’s signaling protocol does leave open the
possibility of a timing channel resulting from the need to com-
pute the modiﬁed MAC and check equality when an invalid
USENIX Association
30th USENIX Security Symposium    3407
MAC is encountered. We minimize this channel by precom-
puting the KDF as soon as the TLS master secret is known,
reducing the online cost to a single XOR operation.
Manipulating the TLS channel. Balboa alters the TLS
channel by replacing the plaintext data in a given TLS record.
This replacement is indistinguishable from standard applica-
tion trafﬁc, assuming the security of TLS. However, due to
restrictions on reading from the network (cf. §2.5.4), Balboa
currently requires the use of a stream cipher suite. Thus, an ac-
tive censor could force a particular cipher suite to be used, one
that is not supported by Balboa. Thus, Balboa only operates
for speciﬁc supported cipher suites, and otherwise operates
in pass-through mode. This however leaves open the possi-
bility of a denial-of-service attack where a censor actively
enforces that only non-stream cipher modes are negotiated.
We view such an attack as highly unlikely, given that 81% of
TLS connections use stream cipher suites [2]. However, even
in this case we can resort to supporting non-streaming modes
as discussed in §B.
A sufﬁciently powerful censor may be able to man-in-the-
middle the TLS connection and thus recover the covert data.
Such attacks are not unrealistic [8]. While we cannot pre-
vent such a censor from identifying that Balboa is in use,
we prevent the censor from acquiring the covert data by re-
encrypting it using a different key than the TLS master secret,
as speciﬁed in §2.5.3.
Manipulating the application itself. A censor could try to
use trafﬁc manipulation or injection to force Balboa to enter
an invalid state, producing behavior that is distinguishable
from what the underlying application would have done. We
carefully designed Balboa such that whenever it reaches a
failure mode it reverts to pass-through mode such that any
observer sees the underlying application behavior directly.
Identifying timing differences. The main difference be-
tween running the application with or without Balboa is the
timing differences introduced by Balboa. We discuss the ef-
fects these timing differences have on classifying Balboa for
audio streaming and web browsing in §6.
Identifying plaintext trafﬁc model differences. A censor
may try to identify Balboa by identifying differences between
a particular trafﬁc model and the baseline behavior of the
network environment. As an example, if an audio streaming
service streams the same song over and over the trafﬁc pattern
may differ sufﬁciently from other audio streaming services
found on the network. Note that this attack is external to
whether Balboa is deployed. That is, if the user’s behavior
varies signiﬁcantly from behavior in the baseline network
environment, a (sufﬁciently powerful) censor could detect
this whether or not Balboa was running at all11. Thus, it is
important to choose an appropriate trafﬁc model instantiation
for the particular deployment environment of Balboa, and this
choice is one that needs to be made with the particular de-
ployment environment in mind (e.g., the expected audio from
a stream in Country A may differ from that in Country B).
Mimicking a client. A censor can try to determine a Balboa
server by acting as a client. Assuming the censor does not
have the required shared key to allow it to signal the server,
the probability it successfully guesses the modiﬁed MAC and
hence passes the signaling protocol is negligible.
Mimicking a server. A censor could also mimic a server,
ﬂagging any client that connects and produces a TLS record
with an invalid MAC. Balboa thwarts this attack by verifying
the public-key signature in the TLS connection against a
pinned public-key. If this veriﬁcation fails, then Balboa enters
a pass-through mode, and the connection appears as normal
to the server.
6 Evaluation
There are several avenues in which we evaluate Balboa: good-
put and detectability. As discussed in §5, the ability for a
censor to identify Balboa depends in part on any delay in-
troduced by the tool over the baseline performance of the
application. Thus, we focus our detectability evaluation on (1)
producing microbenchmarks for the delay introduced by our
two instantiations of Balboa, and (2) building classiﬁers for
Balboa under various network latency settings to investigate
whether a passive censor could detect Balboa.
6.1 Goodput
Because Balboa tunnels data through existing channels, the
goodput of Balboa closely matches the throughput of the cover
channel. In particular, for audio streaming we can replace 98%
of cover data. Thus, when streaming an audio ﬁle encoded
at X kbps (X = 148 or X = 160 is standard), we achieve
a goodput of .98· X. For web browsing the computation is
more complicated, as the percentage of data we can replace
depends on the size of the cover asset. For example, if the
asset is a blank HTML page we would achieve a very low
goodput as there is no cover data to replace. However, for the
“real-world” assets we have tested against (everything from
single HTML pages to video ﬁles) we have found that we can
replace 62–99% of cover data.
11Whether such an attack is feasible in practice depends heavily on the
censor and what their false positive threshold is.
3408    30th USENIX Security Symposium
USENIX Association
6.2 Microbenchmarks
As discussed in §5, Balboa introduces timing delays due to
the processing required to rewrite TLS records and perform
plaintext rewriting. To measure this delay, we ran Balboa on a
standard laptop (Intel Core i7-6820HQ @ 2.7 GHz) for both
our audio streaming and web browsing rewriters, tracking
the cost of each rewrite operation for the sender and receiver.
Each rewrite consists of decrypting the TLS data (encrypted
under the AES128-GCM-SHA256 or AES256-GCM-SHA384 ci-
pher suites), rewriting the plaintext, and re-encrypting—that
is, a rewrite consists of all the processing done by Balboa
upon intercepting a read() or write() from the underlying
application.
Audio streaming. We gathered data while streaming a 10
second Ogg Vorbis audio ﬁle encoded at a bitrate of 148 kbps.
For the sender (i.e., Icecast), we see an average delay of 122µs.
The delay seen on the receiver depends on the particular client
application we are running; for example, for VLC we see an
average delay of 36µs and for MPlayer we see an average
delay of 20µs. The additional delay imposed by the sender
is largely due to (1) the CRC computation required when