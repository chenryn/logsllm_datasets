nsXFormsAccessible.cpp
browser_bug321000.js
nsXFarmsFermControlsiccessible.cpp
nsXFermsAccessible.h
browser_bug386835.js
nsxForesFornControlsAccessible.h
brc
ovser
bu0485137
bug489481
15
nsXFormswidgetsAccessible.cpp
bug413915
nsXFormshidgetsAccessible.h
xul
Makefile.in
browser_bug419612.js
nsXULALertAccessible.cpp
str_bug423833.js
bug420168-15
nsxuCoorPickerAccessible.cpp
nsxuualertAccessible.h
ser_bug424181.js
nsXuLCelorPickerAccessib'e.h
nsxuLFfermcentreLAccessible.cpp
图
11-3
源代码和测试套件的组织结构
以变化为中心的测试的步骤
那么，对于这种类型的项目，如何才能为以变化为中心的测试建立
一个基准呢？
1969
---
## Page 1971
1.了解可执行程序里功能/方法中调用者与被调用者之间的依赖关
系。
这个步骤是通过运行项目所有自动的、手动的和随机的测试用例，
来生成可执行程序的调用关系图。
将调用与被调用的依赖关系的数据存放成一种可以读取的格式，以
便日后检索这些数据，分析代码更改造成的影响范围。
2.了解源代码文件与测试用例之间的对应关系及其代码覆盖率。
这个步骤要生成测试用例与源代码文件/函数之间的对应关系，并把
该数据以可读取的格式保存起来。
经过以上步骤，我们有了一个测试用例与源代码文件和函数之间的
多级对应关系。
在运行了项目的全部测试用例后，找出代码覆盖率中的差距部分。
根据代码覆盖率的差距，制定一个针对性的测试开发计划。
了解调用、被调用的依赖关系和测试用例与源代码文件之间的映射
关系
要了解一个代码改动对整个可执行程序的传播性影响，必须要清楚
可执行程序中各个方法间调用与被调用者之间的关系。
调用关系图生成工具是生成这类信息的绝佳帮手。
为了解如何用调用关系图来确定代码变更造成的影响，让我们看看
图11-4。
1970
---
## Page 1972
(a)
(b)
fQ
f10
f10
图11-4调用流程图
图11-4a是一个可执行程序的静态调用与被调用关系图。方法f2和f3
用到了方法f1的功能，方法f5和f9用到了f3的功能，以此类推。同
时，程序方法可以继承多个上层方法（parentmethod）的功能，并将
本身包含的功能传递给多个下层方法。
在图11-4b中，我们看到方法f3被修改。由于方法f3的变动，所有调
用f3的方法和它们的下层方法（childrenmethod）的行为都会受到潜
在影响，即使这些方法自身没有发生任何变化。然而，根据经验数
据分析，我们可以安全地假定，实际变化之外的三级分离是基本安
全的，因为3的改动所造成的任何后果，可以在测试被改变方法及
其所有二度分离以内的方法时被检测出来。
因此，在理论上，如果我们能够找出涉及方法B3、f5、f9和f8代码的
测试用例，运行这些测试，我们就可以说明因B3的改变而在可执行
文件中所造成的影响。
从可执行程序中生成调用与被调用关系图
经验丰富的测试人员很多都十分熟悉静态代码分析工具。市场上有
很多商业和开源静态代码分析程序。
1971
---
## Page 1973
然而，为了获得可靠的调用与被调用函数关系图，我们应该使用动
态的二进制代码分析（DBA）和代码加检（instrumentation）工具。
Valgrind是被广泛使用的开源DBA工具之一。我们特别感兴趣的是
Valgrind中的一个扩展插件Callgrind。Callgrind可以从可执行程序的
调试版或优化版中，生成可靠而全面的调用关系图。
执行Callgrind扩展插件前，要确认测试机上的Valgrind环境设置正确
无误。Callgrind生成文本格式的输出文件。
借助KCachegrind工具的帮助，Callgrind输出可以被转换成可视化图
形。[山]
示例一
我们假设你有一个称为"foobar"的程序，对应的测试库里有20个测试
用例。
现在，执行以下命令：
valgrind -tool=callgrind./foobar test1
这将生成一个名为callgrind.out.pid的输出文件，其中的"pid"是一个数
字。这个数字是唯一的，每次运行都会不同。
所以，如果你创建一个有20行的批处理文件，每行以一个单独的测
试用例作为可执行文件的参数，最终你会得到20个callgrind.out.pid文
件。
执行命令callgrind_annotatecallgrind.out.pid将生成一个包含两个部分
的测试输出文件。第一部分是输出头信息，我们感兴趣的第二部分
是这样的格式：
Ir
文件：函数
3,437,648
foobar.c:main[/home/your/path/project/foobar]
2,525,400
testframework.c:DrawCircle[/home/your/path/project/foobar]
703,261
foobar.c:Draw[/home/your/path/project/foobar]
.*.
1972
---
## Page 1974
这个例子包含了三列信息。第一列是调用次数。第二列是被调用的
“文件：函数"对。第三列是文件路径。
所以简而言之，对每个测试文，我们可以知道运行该测试用例时被调
用的文件/函数列表。
这些数据将最终产生测试用例与源代码文件之间多对多的映射关
系。根据项目所要求的代码覆盖率，对于给定的源程序，所有能达
到该源代码覆盖率的测试用例，就应作为该源程序的目标测试集。
如果此信息存放在合适的关系数据库中，我们就可以查询任一给定
的文件或函数的测试用例清单。或者反过来查询任一给定的测试用
例所涉及的所有文件：函数。
了解变化的影响
用KCachegrind工具可以把累积的callgrind.out数据变成调用关系视
图。对了解代码变更造成的影响和依赖关系，是非常有用的。
KCachegrind工具有多种输出格式，包括人类可读的"dot"文件格
式。"dot"文件可以作为流行的图形可视化工具Graphviz的输入数
据。"dot"文件可以存储在数据库中，利用程序查询调用与被调用的
依赖关系。
根据调用与被调用的依赖关系，我们应该能够辨别一个改变的影响
可以传播多远。总的来说，在可执行文件中有三种函数类型：
源函数
同步函数
·管道函数
源函数在可执行文件中被多个其他函数调用，而且除了对操作系统
和第三方共享程序库的调用，它不依赖于可执行文件中的其他函
数。因此，源函数中的改变，会对调用它的所有函数造成很多潜在
的次级影响。
同步函数不被可执行文件中的其他函数调用，但它有很多对可执行
文件中其他函数的调用。它所依赖的任何函数的改变，都有可能导
1973
---
## Page 1975
致同步函数行为的改变。因此，同步函数中的改变，理论上没有传
播的影响。
管道函数既可以调用其他函数，也可以被其他函数调用。因此，管
道函数的行为会因为它所调用的函数中的变化而受到影响，还会把
它的行为变化传播给调用它的那些函数。
有了调用关系图的帮助，我们就能够辨别主要的源函数、管道函
数，以及同步函数。
这项工作应定期进行，以检查可执行文件是否发生了任何主要改
动。
在下文“示例三"中，我们将会把这些信息用到以变化为中心的测试
方法中。
但我们必须回答的关键问题是：我们如何识别可执行文件测试覆盖
面的差距？如果我们没有一个能提供100%代码覆盖的全面的测试套
了解代码覆盖和差距分析
在质量保证团队的各式装备中，代码覆盖率是得力的工具之一。有
很多出版物和在线文章辩论代码覆盖率的作用。但我们关心的是，
代码覆盖率可以可靠地提供源代码文件与测试用例之间的对应关系
以及差距，因为以变化为中心的测试要用到这些数据（见
http://en.wikipedia.org/wiki/Code_coverage#Software_code_coverage_to
ols）。
为了说明，让我们来看看一个C/C++代码及其相关的测试，找出源代
码文件与测试用例之间的映射。
如图11-3所示，根据目录结构，我们已经有一些源模块与测试套件
之间粗糙的映射。在“示例一"中，我们文用已有测试用例产生了测
试到文件：函数间的映射。但我们还没有找到测试覆盖面的差距，
这个差距会在以变化为中心的测试中造成盲点。
现在，我们生成一个加检版本的可执行文件。
在大多数的C/C+项目中，可以通过在编译配置文件中加入以下命令
行，生成加检版本：
1974
---
## Page 1976
export CFLAGS="fprofile-arcs-ftest-coverage'
export CXXFLAGS="fprofile-arcs-ftest-coverage"
export LDFLAGS="Igcov-static-libgcc"
生成加检版本以后，我们可以执行多次测试，仅使用为代码库中特
定模块专门设计的测试。这些测试会产生一个粗略的、测试套件到
代码的覆盖关系。例如我们有20个测试套件测试应用程序foobar的X