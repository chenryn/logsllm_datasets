  abstracts	
  ISO	
  compliant	
  modulations	
  so	
  that	
  the	
  ARM	
  can	
  work	
  with	
  those	
  types	
  of	
  tags	
  as	
  well.	
  As	
a	
  C	
  developer	
  looking	
  to	
  enhance	
  the	
  proxmark3,	
  the	
  three	
  main	
  directories	
  of	
  interest	
  are	
  armsrc,	
  client,	
and	
  common.	
  These	
  intuitively	
  named	
  directories	
  contain	
  code	
  for	
  the	
  ARM,	
  the	
  proxmark	
  client,	
  and	
  of	
course	
  shared	
  functionality	
  accessible	
  by	
  either	
  component.	
22	
  https://github.com/Proxmark/proxmark3	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
In	
  order	
  to	
  illustrate	
  the	
  process	
  of	
  enhancing	
  the	
  proxmark3	
  firmware,	
  this	
  paper	
  explores	
  in	
  depth	
  the	
process	
  of	
  introducing	
  client-­‐driven	
  support	
  for	
  a	
  previously	
  unsupported	
  tag	
  format	
  and	
  stand-­‐alone	
support	
  for	
  ISO14443a	
  (NFC)	
  tags.	
  Although	
  proxmark3	
  has	
  an	
  extensive	
  list	
  of	
  supported	
  tag	
  formats,	
there	
  was	
  no	
  support	
  for	
  AWID	
  tags	
  when	
  this	
  research	
  began	
  and	
  with	
  access	
  to	
  both	
  a	
  card	
  and	
  reader	
it	
  was	
  a	
  natural	
  choice	
  for	
  contributing	
  back	
  to	
  the	
  community.23	
Adding	
  real-­‐time	
  demodulation	
  of	
  AWID26	
While	
  demodulation	
  of	
  an	
  AWID	
  FSK	
  waveform	
  from	
  data	
  samples	
  was	
  added	
  in	
  January	
  2015	
  with	
commit	
  1e090a61a149a58a57e9d9acbf5e5532387867a4,	
  there	
  was	
  no	
  corresponding	
  functionality	
  to	
make	
  the	
  pm3	
  an	
  AWID	
  reader	
  in	
  the	
  way	
  ‘lf	
  hid	
  fskdemod’	
  allows.	
  Having	
  an	
  AWID26	
  reader	
  is	
  useful	
for	
  practical	
  attacks	
  in	
  which	
  the	
  penetration	
  tester	
  is	
  trying	
  to	
  skim	
  badge	
  numbers.	
  The	
  tester	
  can	
  leave	
real-­‐time	
  demodulation	
  running	
  and	
  logging	
  while	
  casually	
  attempting	
  to	
  get	
  close	
  enough	
  to	
  people	
  with	
legitimate	
  access	
  to	
  the	
  facility	
  under	
  test.	
The	
  first	
  step	
  in	
  supporting	
  a	
  new	
  tag	
  format	
  is	
  to	
  identify	
  the	
  modulation	
  scheme	
  and	
  parameters	
  in	
  use.	
In	
  general	
  when	
  working	
  with	
  a	
  completely	
  unknown	
  tag	
  the	
  starting	
  point	
  would	
  be	
  to	
  energize	
  the	
  card	
and	
  collect	
  samples	
  to	
  plot.	
  Once	
  familiar	
  with	
  the	
  general	
  envelope	
  of	
  typical	
  modulation	
  schemes,	
  it	
  is	
often	
  possible	
  to	
  recognize	
  the	
  modulation	
  with	
  a	
  simple	
  visual	
  assessment	
  of	
  the	
  waveform.	
  Some	
characteristics	
  such	
  as	
  the	
  data	
  rate	
  can	
  be	
  calculated	
  from	
  the	
  waveform	
  while	
  others	
  may	
  require	
  more	
guesswork	
  or	
  trial	
  and	
  error.	
  Fortunately	
  the	
  AWID	
  cards	
  are	
  clearly	
  marked	
  and	
  as	
  with	
  most	
  cards	
  of	
any	
  popularity,	
  the	
  information	
  is	
  out	
  there	
  if	
  you	
  know	
  where	
  to	
  look.	
  In	
  this	
  case,	
  I	
  found	
  all	
  the	
information	
  I	
  needed	
  from	
  the	
  previously	
  referenced	
  proxmark.org	
  thread	
  on	
  t55x7	
  card	
  programming.	
Decoding	
  the	
  block	
  0	
  value	
  0x00107060	
  tells	
  us	
  that	
  AWID	
  uses	
  FSK2a	
  with	
  RF/50	
  data	
  rate	
  and	
  the	
attached	
  PDF	
  illustrates	
  the	
  high	
  and	
  low	
  logic	
  sequences.	
  This	
  is	
  coincidentally	
  the	
  same	
  FSK	
modulation	
  as	
  used	
  in	
  the	
  popular	
  HID	
  tag	
  format	
  but	
  the	
  similarity	
  starts	
  and	
  ends	
  there	
  with	
  AWID	
  tags	
having	
  a	
  different	
  preamble	
  pattern	
  and	
  encoding	
  technique.	
Moving	
  the	
  AWID	
  demodulation	
  from	
  a	
  client	
  side	
  operation	
  on	
  the	
  local	
  dataset	
  into	
  the	
  ARM	
  is	
  a	
reasonably	
  straightforward	
  process	
  once	
  the	
  logistics	
  are	
  understood.	
  To	
  start,	
  I	
  defined	
  a	
  new	
  command	
opcode	
  with	
  the	
  pneumonic	
  CMD_AWID_DEMOD_FSK	
  by	
  adding	
  it	
  to	
  the	
  appropriate	
  header	
  files	
referenced	
  in	
  the	
  proxmark3	
  ARM	
  section	
  of	
  this	
  document.	
  Logic	
  to	
  handle	
  this	
  command	
  was	
  added	
  in	
the	
  USB	
  packet	
  handling	
  routine	
  from	
  armsrc/appmain.c	
  following	
  the	
  pattern	
  used	
  for	
  the	
  ‘lf	
  hid	
fskdemod’	
  command.	
  A	
  new	
  function	
  CmdAWIDdemodFSK()	
  was	
  added	
  to	
  armsrc/lfops.c	
  including	
  the	
logic	
  from	
  ‘data	
  fskawiddemod’.	
  Migrating	
  the	
  logic	
  from	
  the	
  client	
  to	
  the	
  device	
  side	
  requires	
  changing	
PrintAndLog()	
  calls	
  to	
  the	
  appropriate	
  device	
  side	
  logging	
  function	
  (Dbprintf/DbpString),	
  code	
  to	
  abort	
the	
  function	
  loop	
  in	
  response	
  to	
  a	
  button	
  press,	
  and	
  most	
  critically	
  that	
  the	
  demodulation	
  is	
  fed	
  by	
  live	
data	
  acquisition	
  rather	
  than	
  the	
  graph	
  buffer.	
  On	
  the	
  device	
  side	
  we	
  simply	
  obtain	
  a	
  pointer	
  to	
  BigBuf	
with	
  BigBuf_get_addr()	
  and	
  use	
  DoAcquisition_default()	
  in	
  place	
  of	
  getFromGraphBuf().	
With	
  the	
  device	
  end	
  of	
  the	
  functionality	
  in	
  place,	
  the	
  only	
  thing	
  left	
  to	
  do	
  is	
  update	
  the	
  client	
  to	
  include	
the	
  new	
  context	
  and	
  function.	
  For	
  maintainability	
  it	
  is	
  best	
  to	
  keep	
  tag	
  specific	
  functionality	
  in	
  separate	
23	
  Client	
  demodulation	
  added	
  Jan.	
  18	
  2015	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
files	
  and	
  so	
  client/cmdlfawid.c	
  was	
  created	
  in	
  the	
  likeness	
  of	
  client/cmdlfhid.c	
  along	
  with	
  their	
  associated	
header	
  files.	
  Within	
  this	
  file	
  is	
  a	
  data	
  structure	
  CommandTable[]	
  which	
  exposes	
  available	
  commands	
within	
  a	
  context.	
  CommandTable	
  is	
  a	
  command_s	
  struct	
  containing	
  a	
  command	
  name,	
  function	
  pointer,	
  an	
offline	
  flag,	
  and	
  description.	
  Since	
  the	
  AWID	
  functionality	
  falls	
  under	
  the	
  LF	
  context,	
  the	
  AWID	
commands	
  must	
  be	
  referenced	
  from	
  cmdlf.c	
  with	
  a	
  pointer	
  to	
  a	
  helper	
  function	
  to	
  print	
  command	
  usage	
for	
  the	
  AWID	
  context.	
Example	
  usage	
  and	
  output	
  from	
  ‘lf	
  awid	
  fskdemod’	
  is	
  contained	
  in	
  figure	
  24	
  below:	
Figure	
  24	
  Sample	
  output	
  from	
  'lf	
  awid	
  fskdemod'	
Simulation	
  of	
  AWID26	
  tags	
  from	
  facility-­‐code	
  and	
  card	
  number	
As	
  described	
  earlier,	
  it	
  is	
  possible	
  to	
  simulate	
  most	
  low-­‐frequency	
  tags	
  with	
  built-­‐in	
  generic	
  functions	
allowing	
  the	
  user	
  to	
  specify	
  a	
  modulated	
  bit	
  stream	
  or	
  reproduce	
  an	
  acquired	
  waveform.	
  For	
  example,	
the	
  tag	
  scanned	
  in	
  figure	
  24	
  could	
  be	
  automatically	
  simulated	
  using	
  LF	
  functions	
  search	
  and	
  simfsk.	
  (In	
this	
  scenario,	
  if	
  the	
  tag	
  is	
  supported,	
  lf	
  search,	
  will	
  populate	
  the	
  modulation	
  options	
  and	
  specify	
  the	
demodulated	
  buffer.)	
  It	
  is	
  also	
  possible	
  to	
  use	
  lf	
  simfsk	
  on	
  its	
  own	
  by	
  manually	
  specifying	
  clock	
  speed,	
high	
  and	
  low	
  logic	
  sequences,	
  and	
  tag	
  data.	
  Without	
  the	
  tag	
  present	
  to	
  scan	
  however	
  it	
  becomes	
  a	