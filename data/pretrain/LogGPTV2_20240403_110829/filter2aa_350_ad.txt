    DWORD                   Flags;                         //0x08 
    DWORD                   DebugFlags;                    //0x0C 
    void*                   ConsoleHandle;                 //0x10 
    DWORD                   ConsoleFlags;                  //0x14 
    HANDLE                  StdInputHandle;                //0x18 
    HANDLE                  StdOutputHandle;               //0x1C 
    HANDLE                  StdErrorHandle;                //0x20 
    UNICODE_STRING          CurrentDirectoryPath;          //0x24 
    HANDLE                  CurrentDirectoryHandle;        //0x2C 
    UNICODE_STRING          DllPath;                       //0x30 
    UNICODE_STRING          ImagePathName;                 //0x38 
    UNICODE_STRING          CommandLine;                   //0x40 
    void*                   Environment;                   //0x48 
    DWORD                   StartingPositionLeft;          //0x4C 
    DWORD                   StartingPositionTop;           //0x50 
    DWORD                   Width;                         //0x54 
    DWORD                   Height;                        //0x58 
    DWORD                   CharWidth;                     //0x5C 
    DWORD                   CharHeight;                    //0x60 
    DWORD                   ConsoleTextAttributes;         //0x64 
    DWORD                   WindowFlags;                   //0x68 
    DWORD                   ShowWindowFlags;               //0x6C 
    UNICODE_STRING          WindowTitle;                   //0x70 
生成时在asm上选择：
并勾选nasm：
运行：
    UNICODE_STRING          DesktopName;                   //0x78 
    UNICODE_STRING          ShellInfo;                     //0x80 
    UNICODE_STRING          RuntimeData;                   //0x88 
    RTL_DRIVE_LETTER_CURDIR DLCurrentDirectory[0x20];      //0x90 
} RTL_USER_PROCESS_PARAMETERS;
vs自带命令
readfsdword(0x30)与readgsqword(0x60)的使用
代码如下：
#include 
#include 
#include 
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, * PUNICODE_STRING;
typedef struct _PEB_LDR_DATA {
    BYTE       Reserved1[8];
    PVOID      Reserved2[3];
    LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, * PPEB_LDR_DATA;
typedef struct _RTL_USER_PROCESS_PARAMETERS {
    BYTE           Reserved1[16];
    PVOID          Reserved2[10];
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;
typedef struct _PEB {
    BYTE                          Reserved1[2];
    BYTE                          BeingDebugged;
    BYTE                          Reserved2[1];
    PVOID                         Reserved3[2];
    PPEB_LDR_DATA                 Ldr;
    PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;
    PVOID                         Reserved4[3];
    PVOID                         AtlThunkSListPtr;
    PVOID                         Reserved5;
    ULONG                         Reserved6;
内核层调用
这个一般用不到，函数位PsGetProcessPeb
武器化
反调试
参考：https://jev0n.com/2021/11/18/debug-1.html
    PVOID                         Reserved7;
    ULONG                         Reserved8;
    ULONG                         AtlThunkSListPtr32;
    PVOID                         Reserved9[45];
    BYTE                          Reserved10[96];
    BYTE                          Reserved11[128];
    PVOID                         Reserved12[1];
    ULONG                         SessionId;
} PEB, * PPEB;
#ifndef _WIN64
PPEB pPeb = (PPEB)__readfsdword(0x30);
#else
PPEB pPeb = (PPEB)__readgsqword(0x60);
#endif // _WIN64
int main(void)
{
    wprintf(L"%s\n", pPeb->ProcessParameters->CommandLine.Buffer);
}
IsDebuggerPresent函数反调试
这个API是最经典检测调试器的函数，它底层原理就是返回PEB结构中BeingDebugged位的值，当有调
试器附加的时候BeingDebugged位被置为1。
NtGlobalFlag标志位
PEB的NtGlobalFlag字段（32位Windows的0x68偏移，64位Windows的0xBC）默认为0。反检测代
码：
Heap Flags
在PEB的ProcessHeap位指向_HEAP结构体，该结构体中有俩个字段会受到调试器的影响，具体如何影
响，取决于Windows的版本，主要是修改原始的内容，这两个字段是Flags和ForceFlags。x86检测代码
如下：
#define FLG_HEAP_ENABLE_TAIL_CHECK   0x10
#define FLG_HEAP_ENABLE_FREE_CHECK   0x20
#define FLG_HEAP_VALIDATE_PARAMETERS 0x40
#define NT_GLOBAL_FLAG_DEBUGGED (FLG_HEAP_ENABLE_TAIL_CHECK | 
FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS)
#ifndef _WIN64
PPEB pPeb = (PPEB)__readfsdword(0x30);
DWORD dwNtGlobalFlag = *(PDWORD)((PBYTE)pPeb + 0x68);
#else
PPEB pPeb = (PPEB)__readgsqword(0x60);
DWORD dwNtGlobalFlag = *(PDWORD)((PBYTE)pPeb + 0xBC);
#endif // _WIN64
if (dwNtGlobalFlag & NT_GLOBAL_FLAG_DEBUGGED)
    do something...
堆Magic标志
当进程被调试器调试时该进程堆会被一些特殊的标志填充，这些特殊标记分别是0xABABABAB , 
0xFEEEFEEE。在调试模式下，  NtGlobalFlag的HEAP_TAIL_CHECKING_ENABLED 标志将被默认设置，
堆内存分配会在末尾追加   0xABABABAB标志进行安全检查，如果NtGlobalFlag设置了
HEAP_FREE_CHECKING_ENABLED标志，那么当需要额外的字节来填充堆块尾部时, 就会使用
0xFEEEFEEE(或一部分) 来填充。检测代码如下：
api调用
这个有现成的代码，拿去看好了：https://gist.github.com/christophetd/37141ba273b447ff885c323c
0a7aff93
TEB
BOOL CheckHeapFlagsDebug()
{
    PPEB pPeb = (PPEB)__readfsdword(0x30);
    PVOID pHeapBase = (PVOID)(*(PDWORD_PTR)((PBYTE)pPeb + 0x18));
    DWORD dwHeapFlagsOffset = 0x40;
    DWORD dwHeapForceFlagsOffset = 0x44;
    PDWORD pdwHeapFlags = (PDWORD)((PBYTE)pHeapBase + dwHeapFlagsOffset);
    PDWORD pdwHeapForceFlags = (PDWORD)((PBYTE)pHeapBase + 
dwHeapForceFlagsOffset);
    //HEAP_GROWABLE (2)
    return (*pdwHeapFlags & ~HEAP_GROWABLE) || (*pdwHeapForceFlags != 0); 
}
BOOL CheckHeapMagic()
{
    PROCESS_HEAP_ENTRY HeapEntry = { 0 };
    do
    {
        if (!HeapWalk(GetProcessHeap(), &HeapEntry))
            return false;
    } while (HeapEntry.wFlags != PROCESS_HEAP_ENTRY_BUSY);
    PVOID pOverlapped = (PBYTE)HeapEntry.lpData + HeapEntry.cbData;
    return ((DWORD)(*(PDWORD)pOverlapped) == 0xABABABAB);
}
顾名思义就是线程环境块啦。这个就没那么多玩法了(可以查TEB，里面也有令牌)。先来看一下线程的结
构，与进程类似是一个ETHREAD结构，包含KTHREAD结构：
0:006> dt nt!_ethread
ntdll!_ETHREAD
   +0x000 Tcb              : _KTHREAD
   +0x430 CreateTime       : _LARGE_INTEGER
   +0x438 ExitTime         : _LARGE_INTEGER
   +0x438 KeyedWaitChain   : _LIST_ENTRY
   +0x448 PostBlockList    : _LIST_ENTRY
   +0x448 ForwardLinkShadow : Ptr64 Void
   +0x450 StartAddress     : Ptr64 Void
   +0x458 TerminationPort  : Ptr64 _TERMINATION_PORT
   +0x458 ReaperLink       : Ptr64 _ETHREAD
   +0x458 KeyedWaitValue   : Ptr64 Void
   +0x460 ActiveTimerListLock : Uint8B
   +0x468 ActiveTimerListHead : _LIST_ENTRY
   +0x478 Cid              : _CLIENT_ID
   +0x488 KeyedWaitSemaphore : _KSEMAPHORE
   +0x488 AlpcWaitSemaphore : _KSEMAPHORE
   +0x4a8 ClientSecurity   : _PS_CLIENT_SECURITY_CONTEXT
   +0x4b0 IrpList          : _LIST_ENTRY
   +0x4c0 TopLevelIrp      : Uint8B
   +0x4c8 DeviceToVerify   : Ptr64 _DEVICE_OBJECT
   +0x4d0 Win32StartAddress : Ptr64 Void
   +0x4d8 ChargeOnlySession : Ptr64 Void
   +0x4e0 LegacyPowerObject : Ptr64 Void
   +0x4e8 ThreadListEntry  : _LIST_ENTRY
   +0x4f8 RundownProtect   : _EX_RUNDOWN_REF
   +0x500 ThreadLock       : _EX_PUSH_LOCK
   +0x508 ReadClusterSize  : Uint4B
   +0x50c MmLockOrdering   : Int4B
   +0x510 CrossThreadFlags : Uint4B
   +0x510 Terminated       : Pos 0, 1 Bit
   +0x510 ThreadInserted   : Pos 1, 1 Bit
   +0x510 HideFromDebugger : Pos 2, 1 Bit
   +0x510 ActiveImpersonationInfo : Pos 3, 1 Bit
   +0x510 HardErrorsAreDisabled : Pos 4, 1 Bit
   +0x510 BreakOnTermination : Pos 5, 1 Bit
   +0x510 SkipCreationMsg  : Pos 6, 1 Bit
   +0x510 SkipTerminationMsg : Pos 7, 1 Bit
   +0x510 CopyTokenOnOpen  : Pos 8, 1 Bit
   +0x510 ThreadIoPriority : Pos 9, 3 Bits
   +0x510 ThreadPagePriority : Pos 12, 3 Bits
   +0x510 RundownFail      : Pos 15, 1 Bit
   +0x510 UmsForceQueueTermination : Pos 16, 1 Bit
   +0x510 IndirectCpuSets  : Pos 17, 1 Bit
   +0x510 DisableDynamicCodeOptOut : Pos 18, 1 Bit
   +0x510 ExplicitCaseSensitivity : Pos 19, 1 Bit
   +0x510 PicoNotifyExit   : Pos 20, 1 Bit
   +0x510 DbgWerUserReportActive : Pos 21, 1 Bit
   +0x510 ForcedSelfTrimActive : Pos 22, 1 Bit
   +0x510 SamplingCoverage : Pos 23, 1 Bit
   +0x510 ReservedCrossThreadFlags : Pos 24, 8 Bits
   +0x514 SameThreadPassiveFlags : Uint4B
   +0x514 ActiveExWorker   : Pos 0, 1 Bit
   +0x514 MemoryMaker      : Pos 1, 1 Bit
   +0x514 StoreLockThread  : Pos 2, 2 Bits
   +0x514 ClonedThread     : Pos 4, 1 Bit
   +0x514 KeyedEventInUse  : Pos 5, 1 Bit
   +0x514 SelfTerminate    : Pos 6, 1 Bit
   +0x514 RespectIoPriority : Pos 7, 1 Bit
   +0x514 ActivePageLists  : Pos 8, 1 Bit
   +0x514 SecureContext    : Pos 9, 1 Bit
   +0x514 ZeroPageThread   : Pos 10, 1 Bit
   +0x514 WorkloadClass    : Pos 11, 1 Bit
   +0x514 ReservedSameThreadPassiveFlags : Pos 12, 20 Bits
   +0x518 SameThreadApcFlags : Uint4B
   +0x518 OwnsProcessAddressSpaceExclusive : Pos 0, 1 Bit
   +0x518 OwnsProcessAddressSpaceShared : Pos 1, 1 Bit
   +0x518 HardFaultBehavior : Pos 2, 1 Bit
   +0x518 StartAddressInvalid : Pos 3, 1 Bit
   +0x518 EtwCalloutActive : Pos 4, 1 Bit
   +0x518 SuppressSymbolLoad : Pos 5, 1 Bit
   +0x518 Prefetching      : Pos 6, 1 Bit
   +0x518 OwnsVadExclusive : Pos 7, 1 Bit
   +0x519 SystemPagePriorityActive : Pos 0, 1 Bit
   +0x519 SystemPagePriority : Pos 1, 3 Bits
   +0x519 AllowUserWritesToExecutableMemory : Pos 4, 1 Bit
   +0x519 AllowKernelWritesToExecutableMemory : Pos 5, 1 Bit
   +0x519 OwnsVadShared    : Pos 6, 1 Bit
   +0x51c CacheManagerActive : UChar
   +0x51d DisablePageFaultClustering : UChar
   +0x51e ActiveFaultCount : UChar
   +0x51f LockOrderState   : UChar
   +0x520 PerformanceCountLowReserved : Uint4B
   +0x524 PerformanceCountHighReserved : Int4B
   +0x528 AlpcMessageId    : Uint8B
   +0x530 AlpcMessage      : Ptr64 Void
   +0x530 AlpcReceiveAttributeSet : Uint4B
   +0x538 AlpcWaitListEntry : _LIST_ENTRY
   +0x548 ExitStatus       : Int4B
   +0x54c CacheManagerCount : Uint4B
   +0x550 IoBoostCount     : Uint4B
   +0x554 IoQoSBoostCount  : Uint4B
   +0x558 IoQoSThrottleCount : Uint4B