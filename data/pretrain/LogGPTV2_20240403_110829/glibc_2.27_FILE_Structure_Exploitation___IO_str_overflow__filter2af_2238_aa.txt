# glibc 2.27 FILE Structure Exploitation (_IO_str_overflow)
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 1、前置知识
用fopen打开一个文件，会在heap申请一块内存，并把指针放在栈上。
fopen 会返回一个FILE 结构体
    struct _IO_FILE_plus
    {
      _IO_FILE file;
      const struct 
          *vtable;
    };
    struct _IO_FILE {
      int _flags;        /* High-order word is _IO_MAGIC; rest is flags. */
    #define _IO_file_flags _flags
      /* The following pointers correspond to the C++ streambuf protocol. */
      /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
      char* _IO_read_ptr;    /* Current read pointer */
      char* _IO_read_end;    /* End of get area. */
      char* _IO_read_base;    /* Start of putback+get area. */
      char* _IO_write_base;    /* Start of put area. */
      char* _IO_write_ptr;    /* Current put pointer. */
      char* _IO_write_end;    /* End of put area. */
      char* _IO_buf_base;    /* Start of reserve area. */
      char* _IO_buf_end;    /* End of reserve area. */
      /* The following fields are used to support backing up and undo. */
      char *_IO_save_base; /* Pointer to start of non-current get area. */
      char *_IO_backup_base;  /* Pointer to first valid character of backup area */
      char *_IO_save_end; /* Pointer to end of non-current get area. */
      struct _IO_marker *_markers;
      struct _IO_FILE *_chain;
      int _fileno;//  fd number
    #if 0
      int _blksize;
    #else
      int _flags2;
    #endif
      _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */
    #define __HAVE_COLUMN /* temporary */
      /* 1+column number of pbase(); 0 is unknown. */
      unsigned short _cur_column;
      signed char _vtable_offset;
      char _shortbuf[1];
      /*  char* _save_gptr;  char* _save_egptr; */
      _IO_lock_t *_lock;
    #ifdef _IO_USE_OLD_IO_FILE
    };
简要分析下 fopen 的执行流程：
这里能看到，fopen调用的是`__fopen_internal`
    _IO_FILE *
    __fopen_internal (const char *filename, const char *mode, int is32)
    {
      struct locked_FILE //自己定义了一个结构
      {
        struct _IO_FILE_plus fp;
    #ifdef _IO_MTSAFE_IO
        _IO_lock_t lock;
    #endif
        struct _IO_wide_data wd;
      } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));
      if (new_f == NULL)
        return NULL;
    #ifdef _IO_MTSAFE_IO
      new_f->fp.file._lock = &new_f->lock;
    #endif
      _IO_no_init (&new_f->fp.file, 0, 0, &new_f->wd, &_IO_wfile_jumps);//初始化
      _IO_JUMPS (&new_f->fp) = &_IO_file_jumps;
        //给vtable 赋值 #define _IO_JUMPS(THIS) (THIS)->vtable
      _IO_new_file_init_internal (&new_f->fp);// 这个就是把 当前的 _IO_FILE_plus fp 加入chain
        #if  !_IO_UNIFIED_JUMPTABLES
      new_f->fp.vtable = NULL;
    #endif
      if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)//打开文件
        return __fopen_maybe_mmap (&new_f->fp.file);
      _IO_un_link (&new_f->fp);//失败就从链表上卸载下来
      free (new_f);// free掉
      return NULL;
    }
_IO_no_init内就是一些初始化的操作
    void
    _IO_no_init (_IO_FILE *fp, int flags, int orientation,
             struct _IO_wide_data *wd, const struct _IO_jump_t *jmp)
    {
      _IO_old_init (fp, flags);//初始化_IO_FILE的 下面树初始化 wide character streams
      fp->_mode = orientation;
      if (orientation >= 0)// orientation 这个是=0的
          //_IO_no_init (&new_f->fp.file, 0, 0, &new_f->wd, &_IO_wfile_jumps);
        {
          // wide_data 是 wide character streams 处理宽字节的
          fp->_wide_data = wd;
          fp->_wide_data->_IO_buf_base = NULL;
          fp->_wide_data->_IO_buf_end = NULL;
          fp->_wide_data->_IO_read_base = NULL;
          fp->_wide_data->_IO_read_ptr = NULL;
          fp->_wide_data->_IO_read_end = NULL;
          fp->_wide_data->_IO_write_base = NULL;
          fp->_wide_data->_IO_write_ptr = NULL;
          fp->_wide_data->_IO_write_end = NULL;
          fp->_wide_data->_IO_save_base = NULL;
          fp->_wide_data->_IO_backup_base = NULL;
          fp->_wide_data->_IO_save_end = NULL;
          fp->_wide_data->_wide_vtable = jmp;
        }
      else
        /* Cause predictable crash when a wide function is called on a byte
           stream.  */
        fp->_wide_data = (struct _IO_wide_data *) -1L;
      fp->_freeres_list = NULL;
    }
    void
    _IO_old_init (_IO_FILE *fp, int flags)
    {
      fp->_flags = _IO_MAGIC|flags;
      fp->_flags2 = 0;
      if (stdio_needs_locking)
        fp->_flags2 |= _IO_FLAGS2_NEED_LOCK;
      fp->_IO_buf_base = NULL;
      fp->_IO_buf_end = NULL;
      fp->_IO_read_base = NULL;
      fp->_IO_read_ptr = NULL;
      fp->_IO_read_end = NULL;
      fp->_IO_write_base = NULL;
      fp->_IO_write_ptr = NULL;
      fp->_IO_write_end = NULL;
      fp->_chain = NULL; /* Not necessary. */
      fp->_IO_save_base = NULL;
      fp->_IO_backup_base = NULL;
      fp->_IO_save_end = NULL;
      fp->_markers = NULL;
      fp->_cur_column = 0;
    #if _IO_JUMPS_OFFSET
      fp->_vtable_offset = 0;
    #endif
    #ifdef _IO_MTSAFE_IO
      if (fp->_lock != NULL)
        _IO_lock_init (*fp->_lock);
    #endif
    }
    void
    _IO_new_file_init_internal (struct _IO_FILE_plus *fp)
    {
      /* POSIX.1 allows another file handle to be used to change the position
         of our file descriptor.  Hence we actually don't know the actual
         position before we do the first fseek (and until a following fflush). */
      fp->file._offset = _IO_pos_BAD;
      fp->file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;
      _IO_link_in (fp);//加入链表
      fp->file._fileno = -1;
    }
_IO_list_all 内保存的是当前最新的FILE结构体，而FILE里面的`chain字段`保存的上一个FILE，fileno =
上一次fileno+1.fileno 分配过多，最后又会回到 0.
vtable就是一个好东西，里面全是函数，但不能随意修改，因为libc对这个有检测
## 2、_IO_str_overflow利用
先写出 _IO_str_overflow的利用链
    close -> finish -> _IO_str_overflow ->(char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);
总的来说就是调用_IO_str_overflow函数，也就是 vtable里面的overflow
先看看 `_IO_new_fclose`
    int
    _IO_new_fclose (_IO_FILE *fp)
    {
      int status;
      CHECK_FILE(fp, EOF);
    #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
      /* We desperately try to help programs which are using streams in a
         strange way and mix old and new functions.  Detect old streams
         here.  */
      if (_IO_vtable_offset (fp) != 0)
        return _IO_old_fclose (fp);
    #endif
      /* First unlink the stream.  */
      if (fp->_IO_file_flags & _IO_IS_FILEBUF)
        _IO_un_link ((struct _IO_FILE_plus *) fp);
      _IO_acquire_lock (fp);
      if (fp->_IO_file_flags & _IO_IS_FILEBUF)
        status = _IO_file_close_it (fp);
      else
        status = fp->_flags & _IO_ERR_SEEN ? -1 : 0;
      _IO_release_lock (fp);
      _IO_FINISH (fp); // 这里是关键 把finish 覆盖成_IO_str_overflow
      if (fp->_mode > 0)
        {
          /* This stream has a wide orientation.  This means we have to free
         the conversion functions.  */
          struct _IO_codecvt *cc = fp->_codecvt;
          __libc_lock_lock (__gconv_lock);
          __gconv_release_step (cc->__cd_in.__cd.__steps);
          __gconv_release_step (cc->__cd_out.__cd.__steps);
          __libc_lock_unlock (__gconv_lock);
        }
      else
        {
          if (_IO_have_backup (fp))
        _IO_free_backup_area (fp);
        }
      if (fp != _IO_stdin && fp != _IO_stdout && fp != _IO_stderr)
        {