OptionSupport (4)
OptionUnknown (6)
MSSSupport (4,14,16)
MSSMissing (15,16)
When sending a SYN or an ACK segment with a non-zero
but invalid checksum, a target must respond with a RST
segment or ignore it
As above but with an explicit zeroed checksum
PASS Condition
When sending a SYN segment with EOOL and NOOP
options, a target must respond with a SYN/ACK segment
When sending a SYN segment with an unassigned option
(# 158), a target must respond with a SYN/ACK segment
When sending a SYN segment with an MSS of 515 byte,
a target must not send segments exceeding 515 byte
When sending a SYN segment without an MSS, a target
must not send segments exceeding 536 byte (IPv4) or
1220 byte (IPv6, not tested)
Flags
PASS Condition
Reserved (no MUST)
UrgentPointer (30,31)
When Sending a SYN segment with a reserved ﬂag set
(# 2), a target must respond with a SYN/ACK segment
with zeroed reserved ﬂags
Subsequently, when sending an ACK segment with a
reserved ﬂag set (# 2), a target must not retransmit the
SYN/ACK segment
When sending a sequence of segments ﬂagged as urgent,
a target must acknowledge them with an ACK segment
TCP Checksum. The TCP checksum protects against segment corruption in
transit and is mandatory to both calculate and verify. Even though most Layer 2
MUST, SHOULD, DON’T CARE: TCP Conformance in the Wild
127
protocols already protect against segment corruption, it has been shown [55]
that software or hardware bugs in intermediate systems may still alter packet
data, and thus, high layer checksums are still vital. Checksums are an essential
requirement to consider due to the performance implications of having to iterate
over the entire segment after receiving it, resulting in an incentive to skip this
step even though today this task is typically oﬄoaded to the NIC. Both the
ChecksumIncorrect and the ChecksumZero test (see Table 1) verify the handling
of checksums in the TCP header. They diﬀer only in the kind of checksum
used; the former employs a randomly chosen incorrect checksum while the latter,
posing as a special case, zeroes the ﬁeld instead, i.e., this could appear as if the
ﬁeld is unused.
TCP Options. TCP speciﬁes up to 40 bytes of options for future extensibil-
ity. It is thus crucial that these bytes are actually usable and, if used, handled
correctly. According to the speciﬁcation, any implementation is required to sup-
port the End of option list (EOOL), NOOP, and Maximum Segment Size (MSS)
option. We test these options due to their signiﬁcance for interoperability and,
in the general case, extensibility and performance. The diﬀerent, and sometimes
variable, option length makes header parsing somewhat computationally expen-
sive (especially in hardware), opening the door for non-conformant performance
enhancements comparable to skipping checksum veriﬁcation. Further, an erro-
neous implementation of either requirement can have security repercussions in
the form of buﬀer overﬂows or resource wastage, culminating in a denial of ser-
vice. The OptionSupport test validates the support of EOOL and NOOP, while
the OptionUnknown test checks the handling of an unassigned option. The MSS-
Support test veriﬁes the proper handling of an explicitly stated MSS value, while
the MSSMissing test tests the usage of default values speciﬁed by the RFC in
the absence of the MSS option.
TCP Flags. Alongside the stated TCP options, TCP’s extensibility is mainly
guaranteed by (im-)mutable control ﬂags in its header, of which four are cur-
rently still reserved for future use. The most prominent “recent” example is
ECN [29], which uses two previously reserved bits. Though not explicitly stated
as a numbered formal MUST1, a TCP must zero (when sending) and ignore
(when receiving) unknown header ﬂags, which we test with the Reserved test,
as incorrect handling can considerably block or delay the adoption of future
features.
The UrgentPointer test addresses the long-established URG ﬂag. Validat-
ing the support of segments ﬂagged as urgent, the test splits around 500 bytes
of urgent data into a sequence of three segments with comparable sizes. Each
segment is ﬂagged as urgent, and the urgent pointer ﬁeld caries the oﬀset from
its current sequence number to the sequence number following the urgent data,
i.e., to the sequence number following the payload. Initially intended to speed
up segment processing by indicating data which should be processed imme-
1 RFC 793bis-Draft14 states: “Must be zero in generated segments and must be ignored
in received segments, if corresponding future features are unimplemented by the send-
ing or receiving host.” [27].
128
M. Kosek et al.
Table 2. Results of testbed measurements stating PASS (✓) and FTarget (✗)
Linux Windows macOS
5.2.10
10.14.6
1809
uIP
1.0
lwIP
2.1.2
Seastar
19.06
MUST Test as
deﬁned in Table 1
ChecksumIncorrect
ChecksumZero
OptionSupport
OptionUnknown
MSSSupport
MSSMissing
Reserved
UrgentPointer
diately, the widely-used Berkeley Software Distribution (BSD) socket interface
instead opted to interpret the urgent data as out-of-band data, leading to diverg-
ing implementations. As a result, the urgent pointer’s usage is discouraged for
new applications [27]. Nevertheless, TCP implementations are still required to
support it with data of arbitrary length. As the requirement’s inclusion adds
computational complexity, implementers may see an incentive to skip it.
Pass and Failure Condition Notation. For the remainder of this paper,
we use the following notation to report passing or failing of the above-described
tests. Connections that unmistakably conform are denoted as PASS, whereas not
clearly determinable results (applies only to some tests) are conservatively stated
as UNK. UNKs may have several reasons such as, e.g., hosts ceasing to respond
to non-test packets after having responded to a liveness test. Non-conformities
raised by the target host are denoted as FT arget, and non-conformities raised by
middleboxes on the path rather than the probed host are denoted as FP ath.
3.3 Validation
To evaluate our test design, we performed controlled measurements using a
testbed setup, thereby eliminating possible on-path middlebox interference.
Thus, only FTarget can occur in this validation, but not FPath. To cover a broad
range of hosts, we veriﬁed our test implementations by targeting current versions
of the three dominant Operating Systems (OSs) (Linux, Windows, and macOS)
as well as three alternative TCP stacks (uIP [13], lwIP [7], and Seastar [8]).
We summarize the results in Table 2. As expected, we observe a considerable
degree of conformance. Linux, as well as lwIP, managed to achieve full con-
formance to the tested requirements. Surprisingly, all other stacks failed in at
least one test each. That is, most stacks do not fully adhere to these minimum
requirements. uIP exposed the most critical ﬂaw by crashing when receiving a
segment with urgent data, caused by a segmentation fault while attempting to
MUST, SHOULD, DON’T CARE: TCP Conformance in the Wild
129
read beyond the segment’s size (see Sect. 3.2). Since the release of the tested Ver-
sion of uIP, the project did not undergo further development, but instead moved
to the Contiki OS project [3], where it is currently maintained in Contiki-NG [2].
Following up on Contiki, it was uncovered that both distributions are still vul-
nerable. Their intended deployment platform, embedded microcontrollers, often
lack the memory access controls present in modern OSs, amplifying the risk that
this ﬂaw poses. Addressing this issue, we submitted a Pull request to Contiki-
NG [1]. The remaining FTarget have much less severe repercussions. Seastar,
which bypasses the Linux L4 network stack using Virtio [15], fails both checksum
tests. While hardware oﬄoading is enabled by default, Seastar features software
checksumming, which should take over if oﬄoading is disabled or unsupported
by the host OS. However, host OS support of oﬄoaded features is not veriﬁed,
which can lead to mismatches between believed to be and actually enabled fea-
tures. We reported this issue to the authors [9]. The tests pass if the unsupported
hardware oﬄoads are manually deselected. The FTarget failure for macOS in the
MSSMissing test is a consequence of macOS defaulting to a 1024 bytes MSS
regardless of the IP version, thereby exceeding the IPv4 TCP default MSS, and
falling behind that of IPv6. Windows 10 applies the MSS defaults deﬁned in the
TCP speciﬁcation as a lower bound to any incoming value, overwriting the 515
bytes advertised in the MSSSupport test. Both MSS non-conformities could be
mitigated by path maximum transmission unit (MTU) discovery, dynamically
adjusting the segment size to the real network path.
Takeaway: Only two tested stacks (Linux and lwIP) pass all tests and show full
conformance. Surprisingly, all other stacks failed in at least one category each.
That is, non-conformance to basic mandatory TCP implementation requirements
already exists in current OS implementations. Even though our testbed validation
is limited in the OS diversity, we can already expect to ﬁnd a certain level of host
non-conformance when probing TCP implementations in the wild.
4 TCP Conformance in the Wild
In the following, we move on from our controlled testbed evaluation and present
our measurement study in the Internet. Before we present and discuss the
obtained results, we brieﬂy focus on our measurement setup and our selected
target sets.
4.1 Measurement Setup and Target Hosts
Measurement Setup. Our approach involves performing active probes against
target hosts in the Internet to obtain a representative picture of TCP confor-
mance in the wild. All measurements were performed using a single vantage
point within the IPv4 research network of our university between August 13 and
22, 2019. As we currently do not have IPv6-capable scan infrastructure at our
130
M. Kosek et al.
disposal, we leave this investigation open for future work. Using a probing rate
of 10k pps on a distinct 10 GBit/s uplink, we decided to omit explicit loss detec-
tion and retransmission handling due to the increased complexity, instead stating
results possibly aﬀected by loss as UNK if not clearly determinable otherwise.
Target Hosts. To investigate a diverse set of end-to-end paths as well as end
hosts, a total of 3,731,566 targets have been aggregated from three sources: (i)
the HTTP Archive [33], (ii) Alexa Internet’s top one million most visited sites
list [17,52], and (iii) Censys [25] port 80 and 443 scans.
The HTTP Archive regularly crawls about 5M domains obtained from the
Chrome User Experience Report to study Web performance and publishes the
resulting dataset. We use the dataset of July 2019. For this, we were especially
interested in the Content Delivery Network (CDN) tagged URLs, as no other
source provides URL-to-CDN mappings. Since no IP addresses are provided,
we resolved the 876,835 URLs to IPv4 addresses through four diﬀerent public
DNS services of Cloudﬂare, Google, DNS.WATCH, and Cisco’s OpenDNS. Some
domains contain multiple CDN tags in the original dataset. For these cases, we
obtained the CDN mapping from the chain of CNAME resource records in the
DNS responses and excluded targets that could still not be linked to only a single
CDN. Removing duplicates on a per-URL basis, one target per resolved IPv4
address was selected. The resulting 4,116,937 targets were sampled to at most
10,000 entries per CDN, leading to 147,318 hosts in total. Removing duplicate IP
addresses and blacklist ﬁltering, we derived the ﬁnal set of 27,795 CDN targets.
As recent research has shown [16], preﬁxing www. to a domain might not only
provide diﬀerent TLS security conﬁgurations and certiﬁcates than their non-
www counterparts, but might also (re-)direct the request to servers of diﬀerent
Content Providers (CPs). To study this implications on TCP conformance, we
used the Alexa 1M list published on August 10th, 2019, and resolved every
domain with and without www-preﬁx according to the process outlined in the
HTTP Archive. The resulting 3,297,849 targets were further sampled, randomly
selecting one target with and without www-preﬁx per domain, removing duplicate
IP addresses and blacklist ﬁltering, leading to 466,685 Alexa targets.
Censys provided us research access to their data of Internet-wide port scans,