15.8 验证码和新鲜度
现在再回顾前面的图15-8。客户端起初没有该资源的副本，因此它发送请求给服务
器要求得到一份。服务器用该资源的版本1给以响应。客户端现在可以缓存这份副
本，但是要缓存多长时间呢？
当文档在客户端“过期”之后（也就是说，客户端不再认为该副本有效），客户端必
须从服务器请求一份新的副本。不过，如果该文档在服务器上并未发生改变，客户
端也就不需要再接收一次了——继续使用缓存的副本即可。
这种特殊的请求，称为有条件的请求（conditional request）， 要求客户端使用验证码
（validator）来告知服务器它当前拥有的版本号，并仅当它的当前副本不再有效时才
要求发送新的副本。让我们进一步详细研究这3个关键概念——新鲜度、验证码以
及有条件的请求。
376 ｜ 第15章
15.8.1 新鲜度
服务器应当告知客户端能够将内容缓存多长时间，在这个时间之内就是新鲜的。
服务器可以用这两个首部之一来提供这种信息： Expires（过期）和 Cache-
Control（缓存控制）。
Expires首部规定文档“ 过期”的具体时间——此后就不应当认为它还是最新的。
Expires首部的语法如下：
Expires: Sun Mar 18 23:59:59 GMT 2001
客户端和服务器为了能正确使用Expires首部，它们的时钟必须同步。这并不总是
很容易的，因为它们可能都没有运行像Network Time Protocol（ 网络时间协议，NTP）
这样的时钟同步协议。用相对时间来定义过期的机制会更有用。Cache-Control
首部可以用秒数来规定文档最长使用期——从文档离开服务器之后算起的总计时间。
使用期不与时钟同步，因此可以给出更精确的结果。 360
实际上，Cache-Control首部功能很强大。服务器和客户端都可以用它来说明新鲜度，
并且除了使用期或过期时间之外，还有很多指令可用。表15-3列出了Cache-Control
首部的一些指令。
表15-3 Cache-Control首部的指令
指 令 报文类型 描 述
no-cache 请求 在重新向服务器验证之前，不要返回文档的缓存副本
no-store 请求 不要返回文档的缓存副本。不要保存服务器的响应
max-age 请求 缓存中的文档不能超过指定的使用期
max-stale 请求 文档允许过期（根据服务器提供的过期信息计算），但不能超过
指令中指定的过期值
min-fresh 请求 文档的使用期不能小于这个指定的时间与它的当前存活时间之
和。换句话说，响应必须至少在指定的这段时间之内保持新鲜
no-transform 请求 文档在发送之前不允许被转换
only-if-cached 请求 只有当文档在缓存中才发送，不要联系原始服务器
public 响应 响应可以被任何服务器缓存
private 响应 响应可以被缓存，但只能被单个客户端访问
no-cache 响应 如果该指令伴随一个首部列表的话，那么内容可以被缓存并提
供给客户端，但必须先删除所列出的首部。如果没有指定首部，
缓存中的副本在没有重新向服务器验证之前不能提供给客户端
no-store 响应 响应不允许被缓存
no-transform 响应 响应在提供给客户端之前不能做任何形式的修改
实体和编码 ｜ 377
（续）
指 令 报文类型 描 述
must-revalidate 响应 响应在提供给客户端之前必须重新向服务器验证
proxy-revalidate 响应 共享的缓存在提供给客户端之前必须重新向原始服务器验证。
私有的缓存可以忽略这条指令
max-age 响应 指定文档可以被缓存的时间以及新鲜度的最长时间
s-max-age 响应 指定文档作为共享缓存时的最长使用时间（如果有max-age指
令的话，以本指令为准）。私有的缓存可以忽略本指令
缓存和新鲜度在第7章中曾有详细讨论。
15.8.2 有条件的请求与验证码
当请求缓存服务器中的副本时，如果它不再新鲜，缓存服务器就需要保证它有一个
新鲜的副本。缓存服务器可以向原始服务器获取当前的副本。但在很多情况下，原
始服务器上的文档仍然与缓存中已过期的副本相同。我们在图15-8b中看到过这种
361 情况；缓存的副本或许已经过期了，但原始服务器上的内容与缓存的内容仍然相同。
如果服务器上的文档和已过期的缓存副本相同，而缓存服务器还是要从原始服务器
上取文档的话，那缓存服务器就是在浪费网络带宽，给缓存服务器和原始服务器增
加不必要的负载，使所有事情都变慢了。
为了避免这种情况，HTTP为客户端提供了一种方法，仅当资源改变时才请求副本，
这种特殊请求称为有条件的请求。有条件的请求是标准的HTTP请求报文，但仅当
某个特定条件为真时才执行。例如，某个缓存服务器可能发送下面的有条件GET报
文给服务器，仅当文件/announce.html 从2002年6月29日（这是缓存的文档最后
被作者修改的时间）之后发生改变的情况下才发送它：
GET /announce.html HTTP/1.0
If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT
有条件的请求是通过以“If-”开头的有条件的首部来实现的。在上面的例子中，有条
件的首部是If-Modified-Since（如果-从……之后-修改过）。有条件的首部使得
方法仅在条件为真时才执行。如果条件不满足，服务器就发回一个HTTP错误码。
每个有条件的请求都通过特定的验证码来发挥作用。验证码是文档实例的一个特殊
属性，用它来测试条件是否为真。从概念上说，你可以把验证码看作文件的序列号、
版本号，或者最后发生改变的日期时间。在图15-8b中，那个智能的客户端发送给
服务器的有条件的验证请求是在说：“我有版本1，如果这个资源不再是版本1就把
它发给我。”我们在第7章已经讨论过有条件的缓存再验证了，而本章会更仔细地研
378 ｜ 第15章
究实体验证码的细节。
有条件的首部If-Modified-Since测试的是文档实例最后被修改的日期时间，因此
我们说最后被修改的日期时间就是验证码。有条件的首部If-None-Match测试的
是文档的ETag值，它是与实体相关联的一个特殊的关键字，或者说是版本识别标
记。Last-Modified和ETag是HTTP使用的两种主要验证码。表15-4中列出了用
于有条件请求的4种HTTP首部。每个有条件的首部之后就是这种首部所用的验证
码类型。
表15-4 有条件的请求类型
请求类型 验 证 码 描 述
If-Modified-Since Last-Modified 如果在前一条响应的Last-Modified首部中说明的
时间之后，资源的版本发生变化，就发送其副本
If-Unmodified-Since Last-Modified 仅在前一条响应的Last-Modified首部中说明的时
间之后，资源的版本没有变化，才发送其副本
If-Match ETag 如果实体的标记与前一次响应首部中的ETag相同，
就发送该资源的副本
If-None-Match ETag 如果实体的标记与前一次响应首部中的ETag不同，
就发送该资源的副本 362
HTTP把验证码分为两类：弱验证码（weak validators）和强验证码（strong validators）。
弱验证码不一定能唯一标识资源的一个实例，而强验证码必须如此。弱验证码的一
个例子是对象的大小字节数。有可能资源的内容改变了，而大小还保持不变，因此
假想的字节计数验证码与改变是弱相关的。而资源内容的加密校验和（比如MD5）
就是强验证码，当文档改变时它总是会改变。
最后修改时间被当作弱验证码，因为尽管它说明了资源最后被修改的时间，但它的
描述精度最大就是1秒。因为资源在1秒内可以改变很多次，而且服务器每秒可以
处理数千个请求，最后修改日期时间并不总能反应变化情况。ETag首部被当作强验
证码，因为每当资源内容改变时，服务器都可以在ETag首部放置不同的值。版本
号和摘要校验和也是很好的ETag首部候选，但它们不能带有任意的文本。ETag首
部很灵活，它可以带上任意的文本值（以标记的形式），这样就可以用来设计出各种
各样的客户端和服务器验证策略。
有时候，客户端和服务器可能需要采用不那么精确的实体标记验证方法。例如，某
服务器可能想对一个很大、被广泛缓存的文档进行一些美化修饰，但不想在缓存服
务器再验证时产生很大的传输流量。在这种情况下，该服务器可以在标记前面加上
“W/”前缀来广播一个“弱”实体标记。对于弱实体标记来说，只有当关联的实体
实体和编码 ｜ 379
在语义上发生了重大改变时，标记才会变化。而强实体标记则不管关联的实体发生
了什么性质的变化，标记都一定会改变。
下面的例子展示了客户端如何用弱实体标记向服务器请求再验证。服务器仅当文档
的内容从版本4.0算起发生了显著变化时，才返回主体：
GET /announce.html HTTP/1.1
If-None-Match: W/"v4.0"
概括一下，当客户端多次访问同一个资源时，首先需要判断它当前的副本是不是仍
然新鲜。如果不再新鲜，它们就必须从服务器获取最新的版本。为了避免在资源没
有改变的情况下收到一份相同的副本，客户端可以向服务器发送有条件的请求，说
明能唯一标识客户端当前副本的验证码。只在资源和客户端的副本不同的情况下服
务器才会发送其副本。更多关于缓存再验证的细节，请回顾7.7节。
15.9 范围请求
关于客户端如何要求服务器只在资源的客户端副本不再有效的情况下才发送其副本，
我们已经清楚地理解了。HTTP还进一步锦上添花：它允许客户端实际上只请求文
363 档的一部分，或者说某个范围。
假设你正通过慢速的调制解调器连接下载最新的热门软件，已经下了四分之三，忽
然因为一个网络故障，连接中断了。你已经为等待下载完成耽误了很久，而现在被
迫要全部重头再来，祈祷着别再发生这样的倒霉事了。
有了范围请求，HTTP客户端可以通过请求曾获取失败的实体的一个范围（或者说
一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实
体到这次发出范围请求的时段内，该对象没有改变过。例如：
GET /bigfile.html HTTP/1.1
Host: www.joes-hardware.com
Range: bytes=4000-
User-Agent: Mozilla/4.61 [en] (WinNT; I)
...
在本例中，客户端请求的是文档开头4000字节之后的部分（不必给出结尾字节数，
因为请求方可能不知道文档的大小）。在客户端收到了开头的4000字节之后就失败
的情况下，可以使用这种形式的范围请求。还可以用Range首部来请求多个范围
（这些范围可以按任意顺序给出，也可以相互重叠）。例如，假设客户端同时连接到
多个服务器，为了加速下载文档而从不同的服务器下载同一个文档的不同部分。对
于客户端在一个请求内请求多个不同范围的情况，返回的响应也是单个实体，它有
380 ｜ 第15章
一个多部分主体及Content-Type: multipart/byteranges首部。
并不是所有服务器都接受范围请求，但很多服务器可以。服务器可以通过在响应中
包含Accept-Ranges首部的形式向客户端说明可以接受的范围请求。这个首部的
值是计算范围的单位，通常是以字节计算的。10例如：
HTTP/1.1 200 OK
Date: Fri, 05 Nov 1999 22:35:15 GMT
Server: Apache/1.2.4
Accept-Ranges: bytes
...
图15-9展示了涉及范围请求的一系列HTTP事务的例子。
请求报文
GET /bigfile.html HTTP/1.1
客户端 [...]
响应报文
HTTP/1.1 200 0k
Content-type: text/html
www.joes-hardware.com
Content-length: 65537
Accept-ranges: bytes
[...]
110001
111011
010111 范围请求报文
000101
客户端只收 GET /bigfile.html HTTP.1.1
Range: bytes=20224-
到响应的开头
[...]
20 224字节
客户端的原始请求中 范围响应报文
断了，但第2次请求 HTTP/1.1 206 partial
是要求原来的响应报 Content-Range: bytes=20224-
文中没有收到的部分， Accept-ranges: bytes www.joes-hardware.com
这样客户端就能够从
[...]
中断点继续接收报文了。
图15-9 实体范围请求示例
Range首部在流行的点对点（Peer-to-Peer，P2P）文件共享客户端软件中得到广泛
应用，它们从不同的对等实体同时下载多媒体文件的不同部分。
注10： HTTP/1.1规范中只定义了bytes记号，但服务器和客户端的具体实现可以用它们自己认定的单位来
衡量或切分实体。
实体和编码 ｜ 381
注意，范围请求也属于一类实例操控，因为它们是在客户端和服务器之间针对特定
的对象实例来交换信息的。也就是说，客户端的范围请求仅当客户端和服务器拥有
364 文档的同一个版本时才有意义。
15.10 差异编码
我们曾把网站页面的不同版本看作页面的不同实例。如果客户端有一个页面的已过
期副本，就要请求页面的最新实例。如果服务器有该页面更新的实例，就要把它发
给客户端，哪怕页面上只有一小部分发生了改变，也要把完整的新页面实例发给客
户端。
若改变的地方比较少，与其发送完整的新页面给客户端，客户端更愿意服务器只发
送页面发生改变的部分，这样就可以更快地得到最新的页面。差异编码是HTTP协
议的一个扩展，它通过交换对象改变的部分而不是完整的对象来优化传输性能。差
异编码也是一类实例操控，因为它依赖客户端和服务器之间针对特定的对象实例来
交换信息。RFC 3229描述了差异编码。
图15-10更清楚地展示了差异编码的结构，包括请求、生成、接收和装配文档的全
过程。客户端必须告诉服务器它有页面的哪个版本，它愿意接受页面最新版的差异
（delta），它懂得哪些将差异应用于现有版本的算法。服务器必须检查它是否有这个
365 页面的客户端现有版本，计算客户端现有版本与最新版之间的差异（有若干算法可