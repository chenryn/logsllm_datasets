### 15.8 验证码和新鲜度

现在我们回顾一下图15-8。客户端最初没有该资源的副本，因此它向服务器发送请求以获取一份。服务器响应并提供该资源的第一个版本。客户端可以缓存这份副本，但缓存时间应为多久呢？

当文档在客户端“过期”（即客户端认为该副本不再有效）时，客户端必须再次从服务器请求新副本。但如果文档在服务器上未发生变化，客户端则无需接收新的副本，继续使用缓存中的副本即可。

这种特殊的请求称为有条件的请求（conditional request），要求客户端使用验证码（validator）告知服务器其当前拥有的版本号，并仅在当前副本无效时才请求新副本。接下来我们将详细探讨三个关键概念：新鲜度、验证码以及有条件的请求。

#### 15.8.1 新鲜度

服务器应当通知客户端内容可被缓存的时间，在这段时间内内容被视为新鲜。服务器可以通过以下两个首部之一来提供这些信息：Expires（过期时间）和Cache-Control（缓存控制）。

- **Expires首部** 规定文档具体的过期时间，超过这个时间就不应再认为它是最新的。例如：
  ```
  Expires: Sun Mar 18 23:59:59 GMT 2001
  ```
  为了正确使用Expires首部，客户端和服务器的时钟必须同步。然而，这并不总是容易实现，因为它们可能都没有运行像NTP（网络时间协议）这样的时钟同步协议。

- **Cache-Control首部** 使用相对时间定义过期机制，规定文档的最长使用期（以秒为单位）。这种方法不依赖于时钟同步，因而能提供更精确的结果。例如：
  ```
  Cache-Control: max-age=3600
  ```

实际上，Cache-Control首部功能非常强大。服务器和客户端都可以用它来说明新鲜度，并且除了使用期或过期时间外，还有很多其他指令可用。表15-3列出了Cache-Control首部的一些常用指令。

| 指令 | 报文类型 | 描述 |
|------|----------|------|
| no-cache | 请求 | 在重新向服务器验证之前，不要返回文档的缓存副本 |
| no-store | 请求 | 不要返回文档的缓存副本，也不保存服务器的响应 |
| max-age | 请求 | 缓存中的文档不能超过指定的使用期 |
| max-stale | 请求 | 文档允许过期，但不能超过指令中指定的过期值 |
| min-fresh | 请求 | 文档的使用期不能小于这个指定的时间与它的当前存活时间之和 |
| no-transform | 请求 | 文档在发送之前不允许被转换 |
| only-if-cached | 请求 | 只有当文档在缓存中才发送，不要联系原始服务器 |
| public | 响应 | 响应可以被任何服务器缓存 |
| private | 响应 | 响应可以被缓存，但只能被单个客户端访问 |
| no-cache | 响应 | 如果该指令伴随一个首部列表，则内容可以被缓存并提供给客户端，但必须先删除所列出的首部。如果没有指定首部，缓存中的副本在没有重新向服务器验证之前不能提供给客户端 |
| no-store | 响应 | 响应不允许被缓存 |
| no-transform | 响应 | 响应在提供给客户端之前不能做任何形式的修改 |
| must-revalidate | 响应 | 响应在提供给客户端之前必须重新向服务器验证 |
| proxy-revalidate | 响应 | 共享缓存在提供给客户端之前必须重新向原始服务器验证。私有缓存可以忽略这条指令 |
| max-age | 响应 | 指定文档可以被缓存的时间以及新鲜度的最长时间 |
| s-maxage | 响应 | 指定文档作为共享缓存时的最长使用时间（如果有max-age指令的话，以本指令为准）。私有缓存可以忽略本指令 |

关于缓存和新鲜度的更多细节，请参阅第7章。

#### 15.8.2 有条件的请求与验证码

当缓存服务器中的副本不再新鲜时，缓存服务器需要确保它有一个新鲜的副本。缓存服务器可以从原始服务器获取当前的副本。但在许多情况下，原始服务器上的文档与缓存中已过期的副本相同。如果在这种情况下，缓存服务器仍然从原始服务器获取文档，就会浪费网络带宽，增加不必要的负载，使所有事情都变慢。

为了避免这种情况，HTTP提供了有条件请求的方法，仅当资源改变时才请求副本。这种特殊请求称为有条件的请求。有条件的请求是标准的HTTP请求报文，但仅当某个特定条件为真时才执行。例如，某个缓存服务器可能发送以下有条件的GET报文给服务器，仅当文件/announce.html自2002年6月29日之后发生改变的情况下才发送：

```
GET /announce.html HTTP/1.0
If-Modified-Since: Sat, 29 Jun 2002, 14:30:00 GMT
```

有条件的请求通过以“If-”开头的条件首部来实现。在上面的例子中，条件首部是If-Modified-Since（如果-从……之后-修改过）。条件首部使得方法仅在条件为真时才执行。如果条件不满足，服务器会发回一个HTTP错误码。

每个有条件的请求都通过特定的验证码来发挥作用。验证码是文档实例的一个特殊属性，用于测试条件是否为真。从概念上说，你可以把验证码看作文件的序列号、版本号，或者最后发生改变的日期时间。在图15-8b中，那个智能的客户端发送给服务器的有条件的验证请求是在说：“我有版本1，如果这个资源不再是版本1就把它发给我。”

条件首部If-Modified-Since测试的是文档实例最后被修改的日期时间，因此我们说最后被修改的日期时间就是验证码。条件首部If-None-Match测试的是文档的ETag值，它是与实体相关联的一个特殊的关键字，或者说是版本识别标记。Last-Modified和ETag是HTTP使用的两种主要验证码。表15-4列出了用于有条件请求的四种HTTP首部。每个条件首部之后就是这种首部所用的验证码类型。

| 请求类型 | 验证码 | 描述 |
|-----------|--------|------|
| If-Modified-Since | Last-Modified | 如果在前一条响应的Last-Modified首部中说明的时间之后，资源的版本发生变化，就发送其副本 |
| If-Unmodified-Since | Last-Modified | 仅在前一条响应的Last-Modified首部中说明的时间之后，资源的版本没有变化，才发送其副本 |
| If-Match | ETag | 如果实体的标记与前一次响应首部中的ETag相同，就发送该资源的副本 |
| If-None-Match | ETag | 如果实体的标记与前一次响应首部中的ETag不同，就发送该资源的副本 |

HTTP将验证码分为两类：弱验证码（weak validators）和强验证码（strong validators）。弱验证码不一定能唯一标识资源的一个实例，而强验证码必须如此。弱验证码的一个例子是对象的大小字节数。有可能资源的内容改变了，而大小还保持不变，因此假想的字节计数验证码与改变是弱相关的。而资源内容的加密校验和（如MD5）则是强验证码，当文档改变时它总是会改变。

最后修改时间被当作弱验证码，因为它描述精度最大为1秒。由于资源在1秒内可以改变很多次，而且服务器每秒可以处理数千个请求，最后修改日期时间并不总能反映变化情况。ETag首部被当作强验证码，因为每当资源内容改变时，服务器都可以在ETag首部放置不同的值。版本号和摘要校验和也是很好的ETag首部候选，但它们不能带有任意的文本。ETag首部很灵活，它可以带上任意的文本值（以标记的形式），这样就可以用来设计出各种各样的客户端和服务器验证策略。

有时候，客户端和服务器可能需要采用不那么精确的实体标记验证方法。例如，某服务器可能想对一个很大、被广泛缓存的文档进行一些美化修饰，但不想在缓存服务器再验证时产生很大的传输流量。在这种情况下，该服务器可以在标记前面加上“W/”前缀来广播一个“弱”实体标记。对于弱实体标记来说，只有当关联的实体在语义上发生了重大改变时，标记才会变化。而强实体标记则不管关联的实体发生了什么性质的变化，标记都一定会改变。

下面的例子展示了客户端如何用弱实体标记向服务器请求再验证。服务器仅当文档的内容从版本4.0算起发生了显著变化时，才返回主体：

```
GET /announce.html HTTP/1.1
If-None-Match: W/"v4.0"
```

总结一下，当客户端多次访问同一个资源时，首先需要判断它当前的副本是否仍然新鲜。如果不再新鲜，它们就必须从服务器获取最新的版本。为了避免在资源没有改变的情况下收到一份相同的副本，客户端可以向服务器发送有条件的请求，说明能唯一标识客户端当前副本的验证码。只在资源和客户端的副本不同的情况下服务器才会发送其副本。更多关于缓存再验证的细节，请回顾7.7节。

### 15.9 范围请求

我们已经清楚地理解了客户端如何要求服务器只在资源的客户端副本不再有效的情况下才发送其副本。HTTP还进一步支持范围请求，允许客户端请求文档的一部分，或者说某个范围。

假设你正在通过慢速的调制解调器连接下载最新的热门软件，已经下了四分之三，忽然因为一个网络故障，连接中断了。你已经为等待下载完成耽误了很久，而现在被迫要全部重头再来，祈祷着别再发生这样的倒霉事了。

有了范围请求，HTTP客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这次发出范围请求的时段内，该对象没有改变过。例如：

```
GET /bigfile.html HTTP/1.1
Host: www.joes-hardware.com
Range: bytes=4000-
User-Agent: Mozilla/4.61 [en] (WinNT; I)
...
```

在本例中，客户端请求的是文档开头4000字节之后的部分（不必给出结尾字节数，因为请求方可能不知道文档的大小）。在客户端收到了开头的4000字节之后就失败的情况下，可以使用这种形式的范围请求。还可以用Range首部来请求多个范围（这些范围可以按任意顺序给出，也可以相互重叠）。例如，假设客户端同时连接到多个服务器，为了加速下载文档而从不同的服务器下载同一个文档的不同部分。对于客户端在一个请求内请求多个不同范围的情况，返回的响应也是单个实体，它有多部分主体及Content-Type: multipart/byteranges首部。

并不是所有服务器都接受范围请求，但很多服务器可以。服务器可以通过在响应中包含Accept-Ranges首部的形式向客户端说明可以接受的范围请求。这个首部的值是计算范围的单位，通常是以字节计算的。例如：

```
HTTP/1.1 200 OK
Date: Fri, 05 Nov 1999 22:35:15 GMT
Server: Apache/1.2.4
Accept-Ranges: bytes
...
```

图15-9展示了涉及范围请求的一系列HTTP事务的例子。

```
请求报文
GET /bigfile.html HTTP/1.1
客户端 [...]
响应报文
HTTP/1.1 200 OK
Content-type: text/html
www.joes-hardware.com
Content-length: 65537
Accept-ranges: bytes
[...]
110001
111011
010111 范围请求报文
000101
客户端只收 GET /bigfile.html HTTP/1.1
Range: bytes=20224-
到响应的开头
[...]
20 224字节
客户端的原始请求中 范围响应报文
断了，但第2次请求 HTTP/1.1 206 partial
是要求原来的响应报 Content-Range: bytes=20224-
文中没有收到的部分， Accept-ranges: bytes
www.joes-hardware.com
[...]
这样客户端就能够从
中断点继续接收报文了。
```

Range首部在流行的点对点（Peer-to-Peer，P2P）文件共享客户端软件中得到广泛应用，它们从不同的对等实体同时下载多媒体文件的不同部分。

注意，范围请求也属于一类实例操控，因为它们是在客户端和服务器之间针对特定的对象实例来交换信息的。也就是说，客户端的范围请求仅当客户端和服务器拥有文档的同一个版本时才有意义。

### 15.10 差异编码

我们曾把网站页面的不同版本看作页面的不同实例。如果客户端有一个页面的已过期副本，就要请求页面的最新实例。如果服务器有该页面更新的实例，就要把它发给客户端，哪怕页面上只有一小部分发生了改变，也要把完整的新页面实例发给客户端。

若改变的地方比较少，与其发送完整的新页面给客户端，客户端更愿意服务器只发送页面发生改变的部分，这样就可以更快地得到最新的页面。差异编码是HTTP协议的一个扩展，它通过交换对象改变的部分而不是完整的对象来优化传输性能。差异编码也是一类实例操控，因为它依赖客户端和服务器之间针对特定的对象实例来交换信息。RFC 3229描述了差异编码。

图15-10更清楚地展示了差异编码的结构，包括请求、生成、接收和装配文档的全过程。客户端必须告诉服务器它有页面的哪个版本，它愿意接受页面最新版的差异（delta），它懂得哪些将差异应用于现有版本的算法。服务器必须检查它是否有这个页面的客户端现有版本，计算客户端现有版本与最新版之间的差异（有若干算法可选）。