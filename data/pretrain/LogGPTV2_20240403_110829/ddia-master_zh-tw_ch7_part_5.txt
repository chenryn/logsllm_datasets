快照隔离对长时间执行的只读查询（如备份和分析）非常有用。如果查询的资料在查询执行的同时发生变化，则很难理解查询的含义。当一个事务可以看到资料库在某个特定时间点冻结时的一致快照，理解起来就很容易了。
快照隔离是一个流行的功能：PostgreSQL、使用 InnoDB 引擎的 MySQL、Oracle、SQL Server 等都支援【23,31,32】。
#### 实现快照隔离
与读取提交的隔离类似，快照隔离的实现通常使用写锁来防止脏写（请参阅 “[读已提交](#读已提交)”），这意味著进行写入的事务会阻止另一个事务修改同一个物件。但是读取则不需要加锁。从效能的角度来看，快照隔离的一个关键原则是：**读不阻塞写，写不阻塞读**。这允许资料库在处理一致性快照上的长时间查询时，可以正常地同时处理写入操作，且两者间没有任何锁争用。
为了实现快照隔离，资料库使用了我们看到的用于防止 [图 7-4](../img/fig7-4.png) 中的脏读的机制的一般化。资料库必须可能保留一个物件的几个不同的提交版本，因为各种正在进行的事务可能需要看到资料库在不同的时间点的状态。因为它同时维护著单个物件的多个版本，所以这种技术被称为 **多版本并发控制（MVCC, multi-version concurrency control）**。
如果一个数据库只需要提供 **读已提交** 的隔离级别，而不提供 **快照隔离**，那么保留一个物件的两个版本就足够了：已提交的版本和被覆盖但尚未提交的版本。不过支援快照隔离的储存引擎通常也使用 MVCC 来实现 **读已提交** 隔离级别。一种典型的方法是 **读已提交** 为每个查询使用单独的快照，而 **快照隔离** 对整个事务使用相同的快照。
[图 7-7](../img/fig7-7.png) 说明了 PostgreSQL 如何实现基于 MVCC 的快照隔离【31】（其他实现类似）。当一个事务开始时，它被赋予一个唯一的，永远增长 [^vii] 的事务 ID（`txid`）。每当事务向资料库写入任何内容时，它所写入的资料都会被标记上写入者的事务 ID。
[^vii]: 事实上，事务 ID 是 32 位整数，所以大约会在 40 亿次事务之后溢位。PostgreSQL 的 Vacuum 过程会清理老旧的事务 ID，确保事务 ID 溢位（回卷）不会影响到资料。
![](../img/fig7-7.png)
**图 7-7 使用多版本物件实现快照隔离**
表中的每一行都有一个 `created_by` 栏位，其中包含将该行插入到表中的的事务 ID。此外，每行都有一个 `deleted_by` 栏位，最初是空的。如果某个事务删除了一行，那么该行实际上并未从资料库中删除，而是透过将 `deleted_by` 栏位设定为请求删除的事务的 ID 来标记为删除。在稍后的时间，当确定没有事务可以再访问已删除的资料时，资料库中的垃圾收集过程会将所有带有删除标记的行移除，并释放其空间。[^译注ii]
[^译注ii]: 在 PostgreSQL 中，`created_by` 的实际名称为 `xmin`，`deleted_by` 的实际名称为 `xmax`
`UPDATE` 操作在内部翻译为 `DELETE` 和 `INSERT` 。例如，在 [图 7-7](../img/fig7-7.png) 中，事务 13 从账户 2 中扣除 100 美元，将余额从 500 美元改为 400 美元。实际上包含两条账户 2 的记录：余额为 \$500 的行被标记为 **被事务 13 删除**，余额为 \$400 的行 **由事务 13 建立**。
#### 观察一致性快照的可见性规则
当一个事务从资料库中读取时，事务 ID 用于决定它可以看见哪些物件，看不见哪些物件。透过仔细定义可见性规则，资料库可以向应用程式呈现一致的资料库快照。工作如下：
1. 在每次事务开始时，资料库列出当时所有其他（尚未提交或尚未中止）的事务清单，即使之后提交了，这些事务已执行的任何写入也都会被忽略。
2. 被中止事务所执行的任何写入都将被忽略。
3. 由具有较晚事务 ID（即，在当前事务开始之后开始的）的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。
4. 所有其他写入，对应用都是可见的。
这些规则适用于建立和删除物件。在 [图 7-7](../img/fig7-7.png) 中，当事务 12 从账户 2 读取时，它会看到 \$500 的余额，因为 \$500 余额的删除是由事务 13 完成的（根据规则 3，事务 12 看不到事务 13 执行的删除），且 400 美元记录的建立也是不可见的（按照相同的规则）。
换句话说，如果以下两个条件都成立，则可见一个物件：
- 读事务开始时，建立该物件的事务已经提交。
- 物件未被标记为删除，或如果被标记为删除，请求删除的事务在读事务开始时尚未提交。
长时间执行的事务可能会长时间使用快照，并继续读取（从其他事务的角度来看）早已被覆盖或删除的值。由于从来不原地更新值，而是每次值改变时建立一个新的版本，资料库可以在提供一致快照的同时只产生很小的额外开销。
#### 索引和快照隔离
索引如何在多版本资料库中工作？一种选择是使索引简单地指向物件的所有版本，并且需要索引查询来过滤掉当前事务不可见的任何物件版本。当垃圾收集删除任何事务不再可见的旧物件版本时，相应的索引条目也可以被删除。
在实践中，许多实现细节决定了多版本并发控制的效能。例如，如果同一物件的不同版本可以放入同一个页面中，PostgreSQL 的最佳化可以避免更新索引【31】。
在 CouchDB、Datomic 和 LMDB 中使用另一种方法。虽然它们也使用 [B 树](ch3.md#B树)，但它们使用的是一种 **仅追加 / 写时复制（append-only/copy-on-write）** 的变体，它们在更新时不覆盖树的页面，而为每个修改页面建立一份副本。从父页面直到树根都会级联更新，以指向它们子页面的新版本。任何不受写入影响的页面都不需要被复制，并且保持不变【33,34,35】。
使用仅追加的 B 树，每个写入事务（或一批事务）都会建立一棵新的 B 树，当建立时，从该特定树根生长的树就是资料库的一个一致性快照。没必要根据事务 ID 过滤掉物件，因为后续写入不能修改现有的 B 树；它们只能建立新的树根。但这种方法也需要一个负责压缩和垃圾收集的后台程序。
#### 可重复读与命名混淆
快照隔离是一个有用的隔离级别，特别对于只读事务而言。但是，许多资料库实现了它，却用不同的名字来称呼。在 Oracle 中称为 **可序列化（Serializable）** 的，在 PostgreSQL 和 MySQL 中称为 **可重复读（repeatable read）**【23】。
这种命名混淆的原因是 SQL 标准没有 **快照隔离** 的概念，因为标准是基于 System R 1975 年定义的隔离级别【2】，那时候 **快照隔离** 尚未发明。相反，它定义了 **可重复读**，表面上看起来与快照隔离很相似。PostgreSQL 和 MySQL 称其 **快照隔离** 级别为 **可重复读（repeatable read）**，因为这样符合标准要求，所以它们可以声称自己 “标准相容”。
不幸的是，SQL 标准对隔离级别的定义是有缺陷的 —— 模糊，不精确，并不像标准应有的样子独立于实现【28】。有几个资料库实现了可重复读，但它们实际提供的保证存在很大的差异，尽管表面上是标准化的【23】。在研究文献【29,30】中已经有了可重复读的正式定义，但大多数的实现并不能满足这个正式定义。最后，IBM DB2 使用 “可重复读” 来引用可序列化【8】。
结果，没有人真正知道 **可重复读** 的意思。
### 防止丢失更新
到目前为止已经讨论的 **读已提交** 和 **快照隔离** 级别，主要保证了 **只读事务在并发写入时** 可以看到什么。却忽略了两个事务并发写入的问题 —— 我们只讨论了脏写（请参阅 “[没有脏写](#没有脏写)”），一种特定型别的写 - 写冲突是可能出现的。
并发的写入事务之间还有其他几种有趣的冲突。其中最著名的是 **丢失更新（lost update）** 问题，如 [图 7-1](../img/fig7-1.png) 所示，以两个并发计数器增量为例。
如果应用从资料库中读取一些值，修改它并写回修改的值（读取 - 修改 - 写入序列），则可能会发生丢失更新的问题。如果两个事务同时执行，则其中一个的修改可能会丢失，因为第二个写入的内容并没有包括第一个事务的修改（有时会说后面写入 **狠揍（clobber）** 了前面的写入）这种模式发生在各种不同的情况下：
- 增加计数器或更新账户余额（需要读取当前值，计算新值并写回更新后的值）
- 将本地修改写入一个复杂值中：例如，将元素新增到 JSON 文件中的一个列表（需要解析文件，进行更改并写回修改的文件）
- 两个使用者同时编辑 wiki 页面，每个使用者透过将整个页面内容传送到伺服器来储存其更改，覆写资料库中当前的任何内容。
这是一个普遍的问题，所以已经开发了各种解决方案。