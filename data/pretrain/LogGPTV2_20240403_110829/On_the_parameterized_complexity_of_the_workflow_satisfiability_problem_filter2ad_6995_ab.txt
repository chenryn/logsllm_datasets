(cid:3)
satisﬁed), we will write constraints in the form (ρ, s, S
); that
is, the set of cardinality greater than or equal to 1 appears
after the set of cardinality 1.
2In practice, the set of authorized step-user pairs, A, will not
be deﬁned explicitly. Instead, A will be inferred from other
access control data structures. In particular, R2BAC – the
role-and-relation-based access control model of Wang and
Li [17] – introduces a set of roles R, a user-role relation U R ⊆
U × R and a role-step relation SA ⊆ R × S from which it is
possible to derive the steps for which users are authorized.
For all common access control policies (including R2BAC), it
is straightforward to derive A. We prefer to use A in order
to simplify the exposition.
(cid:3)
(cid:3)
(cid:3)
(cid:3)
The plan π satisﬁes constraint (ρ=, s, s
), for example, if
the same user is assigned to both steps by π, and satisﬁes
constraint (ρ(cid:2)=, s, s
) if diﬀerent users are assigned to s and
(cid:3)
s
. In other words, these represent, respectively, binding-of-
duty and separation-of-duty constraints. Abusing notation
in the interests of readability, we will replace ρ= and ρ(cid:2)= by =
and (cid:2)=, respectively. The constraint ((cid:2)=, s, S
(cid:3)
), for example,
(cid:3)
is satisﬁed by plan π if there is some step in S
to which some
user other than the one who performed step s is assigned.
We may now deﬁne the workﬂow satisﬁability problem, as
deﬁned by Wang and Li [17].
Workflow Satisfiability Problem (WSP)
Input: A constrained workﬂow authorization schema
Output: A valid plan π : S → U or an answer that there
(S, U, (cid:2), A, C)
exists no valid plan
Note that the above deﬁnition does not make any reference
to the ordering on the set of steps. The original deﬁnition,
as formulated by Crampton [5], required an algorithm for
WSP to output an execution schedule (a topological sort
of (S, (cid:2))) in addition to a valid plan. Again, to facilitate
direct comparison with the work of Wang and Li on the
ﬁxed parameter tractability of WSP, we defer discussion of
Crampton’s version of the problem until Section 5. Hence-
forth, we will write WSP(ρ1, . . . , ρt) to denote a special case
of WSP in which all constraints have the form (ρi, s, S
) or
(ρi, S
, s) for some i ∈ [t] and for some s ∈ S and S
(cid:3)
(cid:3) ⊆ S.
(cid:3)
3. ORGANIZATIONAL CONSTRAINTS
The work of Crampton [5, § 2] and of Wang and Li [17, Ex-
amples 1, 2] has noted that a constraint of practical interest
is that users performing two steps must be from the same
department.3 Indeed, in our example illustrated in Figure 1
one could require that the two users who perform steps s3
and s5 belong to the same department. Note, however, that
we will still require that these two users must be diﬀerent.
Similarly, we might wish to insist that the user who approves
the purchase order (step s2) belongs to the same department
as the user who creates the order (step s1).
In short, one can imagine many practical situations in
which some auxiliary information deﬁnes an equivalence re-
lation on the set of users (membership of department, for
example) and that we may wish to require that two steps are
performed by users belonging to either the same department
or to diﬀerent departments. In this section, we introduce two
relations that allow us to model organizational structures, in
which users are partitioned (possibly at several levels) into
diﬀerent organizational units, such as departments.
It is well known that an equivalence relation ∼ on a set X
induces a partition of X into equivalence classes. Conversely,
a partition of X gives rise to an equivalence relation. Given
an equivalence relation on U , we write ∼ in a constraint to
indicate that two users must belong to the same equivalence
class and (cid:2)∼ to denote that two users must belong to diﬀerent
equivalence classes. Hence, (∼, s3, s5) would indicate the
requirement that the signing and countersigning of the goods
received note must be performed by users belonging to the
same equivalence class (department, in this example).
3However, little is known about the complexity of the WSP
when such constraints are used, a deﬁciency we address in
the next section.
8593.1 Organizational Hierarchies
We now show how we can use multiple partitions to deﬁne
an organizational hierarchy. In Section 4.4, we describe a
ﬁxed-parameter tractable algorithm to solve WSP in the
presence of constraints deﬁned over such structures.
Let S be a set. An n-partition of S is an n-tuple
(F1, . . . , Fn) such that F1 ∪ ··· ∪ Fn = S and Fi ∩ Fj = ∅
for all i (cid:2)= j ∈ [n]. We will refer to the elements of an
n-partition as blocks.4
Definition 5. Let (X1, . . . , Xp) and (Y1, . . . Yq) be p-
and q-partitions of the same set. We say that (Y1, . . . Yq)
is a reﬁnement of (X1, . . . , Xp) if for each i ∈ [q] there ex-
ists j ∈ [p] such that Yi ⊆ Xj.
Definition 6. Let U be the set of users in an organi-
zation. An organizational (cid:4)-hierarchy is a collection of (cid:4)
partitions of U , U (1), . . . , U ((cid:2)), where U (i) is a reﬁnement of
U (i+1).
The ith partition is said to be the ith level of the hierarchy.
Each member of U (i) is a subset of U ; we write u(i) to denote
a block in the ith level of the hierarchy.
A constraint of the form (∼i, s1, s2), for example, is sat-
isﬁed by plan π if π(s1), π(s2) ∈ u(i) for some u(i) ∈ U (i).
that we may still deﬁne a constraint
Note, however,
((cid:2)=, s1, s2) which requires that the steps s1 and s2 are per-
formed by diﬀerent users.
More generally, a constraint of the form (∼i, S1, S2) is sat-
isﬁed by plan π if there exists s1 ∈ S1 and s2 ∈ S2 such that
π(s1) and π(s2) belong to the same block in U (i). A con-
straint of the form ((cid:2)∼i, S1, S2) is satisﬁed byπ if there exist
s1 ∈ S1 and s2 ∈ S2 such that π(s1) and π(s2) belong to
diﬀerent blocks in U (i). Note that if π satisﬁes (∼i, S1, S2),
then it satisﬁes (∼j, S1, S2) for all j > i. Conversely, if π
satisﬁes ((cid:2)∼i, S1, S2), then it also satisﬁes ((cid:2)∼j, S1, S2) for all
In other words, for each S1, S2 ⊆ S, we may and
j < i.
will assume without loss of generality that there is at most
one constraint of the form (∼i, S1, S2) and at most one con-
straint of the form ((cid:2)∼j, S1, S2).
We now introduce the notion of a canonical hierarchy. In-
formally, each level of a canonical hierarchy is diﬀerent, the
top level comprises a single block and the bottom level com-
prises the set of all singleton blocks. A canonical hierarchy
is shown in Figure 2, in which a, . . . , j represent users and
the rectangles deﬁne the partition blocks. Note that each
level is a reﬁnement of the one above.
More formally, we have the following deﬁnition.
Definition 7. Let H = U (1), . . . , U ((cid:2)), where U (i) is a
reﬁnement of U (i+1), be a hierarchy. We say H is canonical
if it satisﬁes the following conditions: (i) U (i) (cid:2)= U (i+1);
(ii) U ((cid:2)) is a 1-partition containing the set U ; (iii) U (1) is
an n-partition containing every singleton set (from U ).
Let U (1), . . . , U ((cid:2)) be some hierarchy and let C be a set of
workﬂow constraints. We conclude this section by showing
how we may convert the hierarchy into a canonical hierar-
chy by ﬁrst removing duplicate levels, adding suitable top
and bottom levels (if required), and making appropriate ad-
justments to C. More formally, we perform the following
operations:
4One or more blocks in ann -partition may be the empty
set.
a
a
a
a
a
a
a
b
b
b
b
b
b
b
c
c
c
c
c
c
c
d
d
d
d
d
d
d
e
e
e
e
e
e
e
f
f
f
f
f
f
f
g
g
g
g
g
g
g
h
h
h
h
h
h
h
i
i
i
i
i
i
i
j
j
j
j
j
j
j
Figure 2: A canonical organizational hierarchy
• If U (i) = U (i+1)
for
some
i
then we
re-
place all constraints of the form (∼i+1, S1, S2) and
((cid:2)∼i+1, S1, S2) with constraints of the form (∼i, S1, S2)
and ((cid:2)∼i, S1, S2), respectively. We then remove U (i+1)
from the hierarchy as there are now no constraints that
apply to U (i+1).
• If no partition in the hierarchy has one element (con-
sisting of a single block U ), then add such a partition to
the hierarchy. Clearly every partition is a reﬁnement
of the 1-partition (U ).
• If no partition in the hierarchy has n elements, then
add such a partition to the hierarchy. Clearly such a
partition is a reﬁnement of every other partition.
• Finally, we renumber the levels and the constraints
where appropriate with consecutive integers.
The conversion of a hierarchy to canonical form can be
performed in O((cid:4)n + c) time (since we require O((cid:4)n) time
to ﬁnd all layers that may be deleted and then delete them,
and O(c) time to update the constraints). The number of
levels in the resulting canonical hierarchy is no greater than
(cid:4) + 2.
3.2 Organizational Hierarchies from Man-
agement Structures
We now illustrate how organization hierarchies may be
constructed in a systematic fashion from management struc-
tures. Given a set of users U , we assume that an organiza-
tion deﬁnes a hierarchical binary relation (cid:4) on U in order to
specify management responsibilities and reporting lines. We
assume that the Hasse diagram of (U, (cid:4)) is a directed tree in
which non-leaf nodes represent users with some managerial
responsibility and edges are directed from root node to leaf
nodes. Let Gman = (U, Eman) denote the Hasse diagram of
(U, (cid:4)). The fact that Gman is a tree means that no user has
more than one manager. A user u has direct responsibil-
ity for (or is the line manager of) user v if (u, v) ∈ Eman.
We also assume that the out-degree of a non-leaf node is
at least two. Both of these assumptions would seem to be
reasonable for most organizations with a hierarchical man-
agement structure. (The study of more exotic management
structures such as matrix management is deferred to future
work.)
We now describe one method by which an organizational
hierarchy may be derived from a management tree. Given
a management tree Gman we iteratively construct manage-
ment trees with fewer and fewer nodes as follows:
1. we ﬁrst identify every sub-tree in which there is a single
non-leaf node;
8602. for each such sub-tree we form a single leaf node whose
label is formed from the labels for the respective leaf
nodes;
3. for each resulting sub-tree we form a single node whose
label is formed from the labels of the child and parent
nodes.
We then repeat for the resulting tree, terminating when we
have a tree containing a single node. The above procedure is
illustrated in Figure 3. The ﬁgure shows a sequence of trees,
the ﬁrst of which deﬁnes the management tree in which each
node is labeled with a single user.
j
j