Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Memory Bus
AES Pipeline
PAD 2
PAD1
C(1)
a,c
C(2)
a,c
Ha,c
CBC MAC
CBC MAC
CBC MAC
L(1)
a,c
L(2)
a,c
Integrity
result
Overhead
0
10
20
30
40
50
60
70
80
90
100
110
120
Cycles
Figure 6. Timeline example of a cache line
read from memory with the parameters from
Table 1.
In Figure 7b, we compare the effect of four different
sizes for the Merkle tree cache: without a cache, with a 256-
entry cache, with a 512-entry cache and with a 1024-entry
cache. We see that the introduction of a cache, even a small
one, has a great impact on the performance of the applica-
tions. However, the increase in the size of this cache has
only a minor impact because the number of memory pages
used by these applications is far greater than the number of
entries in the cache. The ideal solution would be that the
size of this cache would be sufﬁcient to store all the page
information and all the nodes of the Merkle tree.
The storage of the MAC increases the memory usage of
the secure program by 50 % using our parameters. To re-
duce this memory footprint, the MAC can be computed over
several lines instead of only one, to the detriment of the
time needed to check this MAC and of the memory bus
utilization. Figure 7c shows the impact of computing the
MAC over one, two and four cache lines without speculative
execution of instructions (CRYPTOPAGE architecture with
a 512-entry Merkle tree cache). The mean performance
penalty is 4.4 % for computing the MAC over two cache
lines and 11.7 % over four cache lines. If we execute the in-
structions before their veriﬁcation, the performance penalty
is very small (less than 1 %, as shown in Figure 7d).
We used SimpleScalar to obtain performance results
that can be compared with the other architectures that also
use SimpleScalar or similar micro-architecture simulators.
However, it only simulates the execution of a process itself
and does not take into account the impact of the operating
system or other processes running on the processor. For in-
stance, the kernel of the operating system is normally called
frequently with a clock interrupt in a multitask operating
system, and this execution can increase the cache miss rate
of the process which was running.
We are currently working to estimate the hardware cost
(number of logic gates) of our modiﬁcations.
4. Related work
In this article, we have proposed a mechanism to im-
plement an on-line memory checker using the HIDE infras-
tructure. In [7], Gassend et al. used a Merkle tree, com-
puted over the whole memory space, to implement an on-
line memory checker. They also used the cache hierarchy of
the processor to improve the speed of the integrity checking
by storing parts of the tree in the cache which is assumed to
be secure. Even with the use of the cache, they get a per-
formance penalty of 20 %. In our proposition, we combine
a simple MAC mechanism and a Merkle tree computed over
the page information (and not the whole memory) to build a
memory checker, secure against replay attacks, with a better
performance penalty.
In [7], Gassend et al. built an off-line memory checker
using incremental hash functions.
In [4], Clarke et al.
proposed another off-line memory checker with a constant
bandwidth overhead by combining hash tree and incremen-
tal hash functions. An off-line memory checker only checks
the integrity of a set of transactions whereas on-line mem-
ory checkers check the integrity of memory during each
memory transaction. Off-line memory checkers are faster
but the veriﬁcation function has to be called before each
security-critical instruction. But between each veriﬁcation,
the instructions are executed without veriﬁcation and this
can cause some information leakages if this mechanism is
combined with memory encryption.
The memory encryption in secure architectures has also
been studied alone in several secure architecture such as
XOM [16, 17, 18], AEGIS [26, 27] and CRYPTOPAGE [15,
6, 5]). For example, in [25], Shi et al. also used the counter
mode to encrypt cache lines. However, they need to store
the counter in memory, so the computation of the pads dur-
ing memory access is delayed until the counter is fetched
from memory. To reduce this problem, they proposed to use
a prediction unit and a special cache to try to guess the cor-
rect counter required to decrypt a line. In our proposition,
we also use the counter mode but the counter is deduced
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006from data stored in the page information structure. As this
structure is always available before memory access, except
if there is a TLB miss, the pads can be computed during the
memory access latency, without relying on a counter cache
or a counter prediction unit.
Finally, the problem of information leakage on the ad-
dress bus has been studied in several works. One approach
is to encrypt the address bus, which is equivalent to per-
forming an initial permutation of the memory space. For in-
stance, this mechanism is used in DS5000 processors. How-
ever, as this encryption does not change during the life of a
process, an attacker can still see that one piece of memory is
more often used than another. Goldreich et al., in [8], pro-
posed several approaches that guarantee that no information
leakages can happen on the address bus but their algorithms
entail a high performance penalty. Zhuang et al. created
an infrastructure called HIDE which prevents information
leakages on the address bus with a low performance penalty
(1.3 % slowdown).
Recently, Yan et al. in [29] developed a new method to
combine memory encryption and integrity protection with
an IPC overhead of 5 % by using the Galois/Counter Mode
of operation (GCM [19]). The encryption process is simi-
lar to our proposition, except that they still need a counter
cache whereas we always have the correct counter ready be-
fore the memory access. The integrity protection is based on
the GCM which is faster than our CBC-MAC because most of
the computation required can be overlapped with the mem-
ory latency. However, they still use a Merkle tree computed
over the whole memory and they do not provide information
leakage protection.
We also have to mention the efforts of the Trusted Com-
puting Group [28] and of Microsoft with its project Next
Generation Secure Computing Base (NGSCB) [22, 21] in
order to secure general purpose computers. However, their
objectives in terms of security are different from ours. We
want to protect the integrity and conﬁdentiality of the code
and data of the processes that are running on our architec-
ture, even in the case of a hardware attack, whereas they
want to provide strong isolation at the software level be-
tween processes, remote attestations that the hardware and
software are in a given state, sealed storage and a secure
path between the input devices to the application. Our ob-
jectives cannot be reached by simply using a Trusted Plat-
form Module (TPM) and a secure operating system.
5. Conclusions and future work
In this work, we described a new simple solution to im-
plement a cheap memory encryption and protection mecha-
nism in processors, based on the HIDE architecture and re-
cursive hash functions, which prevents information leakage
from applications on the data and address bus and can resist
to active external attacks, even in presence of a malicious
operating system or logic analyzer.
The basic idea is to add a Merkle hash tree only at a
coarse grain level (the operating system page descriptor
TLB) to protect the architecture against replay attack at a
low penalty cost. We proposed to improve the performance
even more with the help of a small veriﬁcation cache. A few
novel secure instructions are added to delegate securely the
security management to the operating system and simplify
the hardware secure mechanism.
Once the security is granted at the TLB level, some se-
cret keys are ciphered and added to the TLB to efﬁciently
implement a memory encryption and address shufﬂing in-
side each memory page based on counter mode encryption
and an anti-replay protection based on a CBC-MAC.
The performance penalty of these mechanisms, com-
pared to a normal non-secured architecture, turns out to be
only about 3 % on average on some SPEC2000int bench-
marks, which is far smaller than that achieved by previous
works. This result is reached thanks to the property that one
line of memory is read and written only once between each
chunk permutation.
We are working to extend our proposition to multicore
and multiprocessor systems and to apply our architecture to
secure distributed high performance computing.
6. Acknowledgment
This work is supported in part by a PhD grant from
the D´el´egation G´en´erale pour l’Armement (DGA, a divi-
sion of the French Ministry of Defense), and funded by
the French National Research Agency (ANR) under con-
tract ANR-05-SSIA-005-03 SAFESCALE. The authors wish
to thank Jacques Stern for his valuable comments on this
project, Sylvain Guilley and Renaud Pacalet for their in-
sightful discussions in the GET-TCP project.
References
[1] T. Austin, E. Larson, and D. Ernst. SIMPLESCALAR: An
infrastructure for computer system modeling. Computer,
35(2):59–67, Feb. 2002.
[2] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A concrete
security treatment of symmetric encryption. In Proceedings
of the 38th Annual Symposium on Foundations of Computer
Science (FOCS’97), pages 394–403. IEEE Computer Soci-
ety, Oct. 1997.
[3] M. Bellare and C. Namprempre. Authenticated encryption:
Relations among notions and analysis of the generic com-
position paradigm. In Springer-Verlag, editor, Advances in
Cryptology - Asiacrypt 2000 Proceedings, volume 1976 of
Lecture Notes in Computer Science, 2000.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006[4] D. Clarke, G. E. Suh, B. Gassend, A. Sudan, M. van Dijk,
and S. Devadas. Towards constant bandwidth overhead in-
tegrity checking of untrusted data.
In Proceedings of the
2005 IEEE Symposium on Security and Privacy, pages 139–
153. IEEE Computer Society, May 2005.
[5] G. Duc. CRYPTOPAGE — an architecture to run secure pro-
cesses. Diplˆome d’ ´Etudes Approfondies, ´Ecole Nationale
Sup´erieure des T´el´ecommunications de Bretagne, DEA de
l’Universit´e de Rennes 1, June 2004. http://enstb.
org/∼gduc/dea/rapport/rapport.pdf.
[6] G. Duc, R. Keryell, and C. Lauradoux. CRYPTOPAGE : Sup-
port mat´eriel pour cryptoprocessus. Technique et Science
Informatiques, 24:667–701, 2005.
[7] B. Gassend, G. E. Suh, D. Clarke, M. van Dijk, and S. De-
vadas. Caches and hash trees for efﬁcient memory in-
tegrity veriﬁcation. In Proceedings of the 9th International
Symposium on High-Performance Computer Architecture
(HPCA’03), pages 295–306, Feb. 2003.
[8] O. Goldreich and R. Ostrovsky. Software protection and
the ACM,
Journal of
simulation on oblivious RAMs.
43(3):431–473, 1996.
[9] J. L. Henning. SPEC CPU2000: measuring CPU perfor-
mance in the new millennium. IEEE Computer, 33(7):28–
35, July 2000.
[10] A. Huang. Keeping secrets in hardware:
the Microsoft
XBox (TM) case study. Technical Report AI Memo 2002-
008, MIT, May 2002.
[11] ISO/IEC 9797. Data cryptographic techniques — data in-
tegrity mechanism using a cryptographic check function em-
ploying a block cipher algorithm, 1989.
[12] R. Keryell. CRYPTOPAGE-1 : vers la ﬁn du piratage infor-
matique ? In Symposium d’Architecture (SYMPA’6), pages
35–44, Besanc¸on, June 2000.
[13] P. C. Kocher. Timing attacks on implementations of DIFFIE-
HELLMAN, RSA, DSS, and other systems. In Proceedings
of the 16th Annual International Cryptology Conference on
Advances in Cryptology (CRYPTO’96), number 1109, pages
104–113. Springer-Verlag, Aug. 1996.
In Proceedings of
[14] P. C. Kocher, J. Jaffe, and B. Jun. Differential power
analysis.
the 19th Annual Interna-
tional Cryptology Conference on Advances in Cryptology
(CRYPTO’99), number 1666, pages 388–397. Springer-
Verlag, Aug. 1999.
[15] C. Lauradoux and R. Keryell.
CRYPTOPAGE-2 : un
processeur s´ecuris´e contre le rejeu.
In Symposium
en Architecture et Ad´equation Algorithme Architecture
(SYMPAAA’2003), pages 314–321, La Colle sur Loup,
France, Oct. 2003.
[16] D. Lie, C. Thekkath, M. Mitchell, P. Lincoln, D. Boneh,
J. Mitchell, and M. Horowitz. Architectural support for copy
and tamper resistant software. In Proceedings of the Ninth
International Conference on Architectural Support for Pro-
gramming Languages and Operating Systems (ASPLOS IX),
pages 168–177, Oct. 2000.
[17] D. Lie, C. A. Trekkath, and M. Horowitz.
Implementing
an untrusted operating system on trusted hardware. In Pro-
ceedings of the 9th ACM Symposium on Operating Systems
Principles (SOSP’03), pages 178–192, Oct. 2003.
[18] D. J. Lie. Architectural support for copy and tamper-
resistant software. PhD thesis, Stanford University, 2004.
[19] D. A. McGrew and J. Viega. The galois/counter mode
Submission to NIST Modes of Opera-
of operation.
tion Process, May 2005. http://csrc.nist.gov/
CryptoToolkit/modes/proposedmodes.
[20] R. C. Merkle. A certiﬁed digital signature.
In Proceed-
ings on Advanced in Cryptology (CRYPTO’89), volume 435,
pages 218–238. Springer-Verlag New York, Inc., 1989.
[21] Microsoft Corporation.
NGSCB:
Trusted Com-
2003.
and
puting Base
http://www.microsoft.com/resources/
ngscb/documents/ngscb tcb.doc.
Software Authentication,
[22] Microsoft Corporation.
Security Model
Base,
for
the
2003.
Secure
Next-Generation
http://www.microsoft.com/resources/
ngscb/documents/NGSCB Security Model.doc.
[23] NIST. Computer data authentication, May 1985. Federal
Computing
Information Processing Standards Publication 113.
[24] NIST. Recommendation for block cipher modes of opera-
tion, Dec. 2001. Special Publication 800-38A.
[25] W. Shi, H.-H. S. Lee, M. Ghosh, C. Lu, and A. Boldyreva.
High efﬁciency counter mode security architecture via pre-
diction and precomputation.
In Proceedings of the 32nd
Annual International Symposium on Computer Architec-
ture (ISCA’05), pages 14–24. IEEE Computer Society, June
2005.
[26] G. E. Suh, D. Clarke, B. Gassend, M. van Dijk, and S. De-
vadas. AEGIS: Architecture for tamper-evident and tamper-
resistant processing.
In Proceedings of the 17th Interna-
tional Conference on Supercomputing (ICS’03), pages 160–
171, June 2003.
[27] G. E. Suh, C. W. O’Donnell, I. Sachdev, and S. Devadas.
Design and implementation of the AEGIS single-chip secure
processor using physical random functions. In Proceedings
of the 32nd Annual International Symposium on Computer
Architecture (ISCA’05), pages 25–36. IEEE Computer Soci-
ety, June 2005.
[28] Trusted Computing Group, Mar. 2005. http://www.
trustedcomputinggroup.org.
[29] C. Yan, D. Englender, M. Prvulovic, B. Rogers, and Y. Soli-
hin.
Improving cost, performance, and security of mem-
ory encryption and authentication.
In Proceedings of the
33rd International Symposium on Computer Architecture
(ISCA’06), pages 179–190. IEEE Computer Society, June
2006.
[30] X. Zhuang, T. Zhang, and S. Pande. HIDE: an infrastructure
for efﬁciently protecting information leakage on the address
bus.
In Proceedings of the 11th International Conference
on Architectural Support for Programming Languages and
Operating Systems (ASPLOS-XI), pages 72–84. ACM Press,
Oct. 2004.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006