GR = {(r1, r4), (r1, r5), (r4, r6), (r2, r3),
(r2, r4), (r3, r7)};
GP = {(p2, p1), (p5, p6)};
LU R = {(g1, r1), (g3, r3), (g4, r5), (g5, r6), (g9, r2)};
LRP = {(r1, p1), (r1, p2), (r1, p3), (r1, p4), (r2, p1),
(r2, p2), (r2, p5), (r2, p6), (r3, p5), (r3, p6),
(r4, p1), (r4, p2), (r5, p3), (r5, p4), (r6, p1),
(r7, p6)};
and CM = CSgg ∪ CSrr ∪ CSpp ∪ CAgs→r ∪ CAg→rs as
{(g4, g6), (g5, g6)} is redundant in CAgs→r.
6. MAINTENANCE OPERATIONS
Paper [17] has proposed ﬁrst-order maintenance algorithms
on the reachability of roles (i.e., TCGR ) under various up-
date operations. Those algorithms can be implemented in
SQL in any database systems.
In this section, we brieﬂy
indicate that those algorithms can be adapted to maintain
the reachability of a secured RBAC state. That is, maintain
TCGU , TCGR , TCGP or TCGM when the speciﬁcations or
requirements on the underlining graph are changed. The
maintenance requires storing TCGU , TCGR and TCGP (or
a single TCGM , equivalently) in the database system, in ad-
dition to the secured RBAC state GM and the set of conﬂict
constraints CM .
The maintenance of of a secured RBAC state with the algo-
rithms of [17] is drawn from the following facts:
1. The insertion or deletion of a LRP tuple are func-
tionally equivalent to the insertion/deletion of a priv-
ilege into/from a role, those algorithms can be easily
adapted to support the updates on LRP .
146
4. Find the set of redundant arcs of GM or CM when
the speciﬁcations or requirements on GM or CM are
changed.
In GM , arcs of GU (or GR) are not updated directly as they
imply the subsumption on nodes. A node update can cause
some arcs’ insertion or deletion, and may change the graph’s
hierarchical structure. Refer to [17].
A secure/conﬂict check should be implemented for G(n)
M after
an update of GM such as: (1) when a user is added to an
existing group; (2) when a privilege is added to an existing
role or an arc is add to LRP ; (3) when a new group or a
new role is created; (4) when an arc is inserted in LU R; and
∩
(5) a new conﬂict constraint is added. That is, if TC
CM = ∅ holds, then the operation is legal. Otherwise, the
operation is illegal. A conﬂict check needs to be executed
after performing any update operations.
(n)
M
G
The eﬃciency evaluation on ﬁst-order maintenance algo-
rithms have been reported in [16]. The tests show that such
algorithms are orders of magnitude faster than the recompu-
tation algorithm in most situations. In contrast to the rapid
growth in computation time with respect to more arcs in the
graph, the incremental algorithms remain almost constant
time for more arcs.
7. CONCLUSIONS
In this paper, we have shown how to maintain reachability
relations of a RBAC state by using transitive closure rela-
tions of GU , GR and GP . Our maintenance strategy can
eﬃciently support the dynamic changes of a RBAC state
[16, 17] and can make other operations, such as the oper-
ation on removal redundancy, be implemented easily. We
intensively discuss the operations on ﬁnding and removing
redundancy on a RBAC state, including the redundancy on
the conﬂict constraints.
Our future work is to improve and extend this work in sev-
eral ways: to investigate the maintenance strategy in a more
general model and to support more general conﬂict con-
straints.
8. REFERENCES
[1] A. V. Aho, M. R. Garey, and J. D. Ullman. The
transitive reduction of a directed graph. SIAM J.
Comput., 1(2):131–137, 1972.
[2] ANSI. American national standard for information
technology - role based access control. In ANSI
INCITS 359-2004, 2004.
[3] J. Crampton. On permissions, inheritance and role
hierarchies. In Proc. of ACM conference on Computer
and communications security, pages 85–92, New York,
NY, USA, 2003. ACM Press.
[4] C. Demetrescu and G. F. Italiano. Fully dynamic
transitive closure: Breaking through the o(n 2 )
barrier. In IEEE Symposium on Foundations of
Computer Science, pages 381–389, 2000.
[5] G. Dong and C. Pang. Maintaining transitive closure
in ﬁrst-order after node-set and edge-set deletions.
Information Processing Letters, 62(3):193–199, 1997.
2. As illustrated in the previous section, the accessibility
of groups to roles in GM is expressed by relation ˜TU→R,
which is:
˜TU→R = {(g, r)|(cid:99)TCGU (g, w1) ∧ LU R(w1, w2)
∧(cid:99)TCGR (w2, r)}.
(cid:99)TC
(n)
U
The relation can be maintained from TCGU , TCGR
and LU R. For example, when GU updates into G(n)
U ,
can be derived from the algorithms of [17]. Let
G
L(n)
U R be the new LU R that is spread from the update
of GU . For instance, if group g of {u|LU R(u, )} ∩ VU
is updated into group g(cid:48) then L(n)
U R is the set of LU R
by substituting g with g(cid:48); if group g of {u|LU R(u, )}∩
U R = LU R ∪ {(g(cid:48), r)|LU R(g, r) ∧
VU is deleted then L(n)
GU (g(cid:48), g)} − {(g, r)|LU R(g, r)}.
3. The new ˜TU→R, which denotes as ˜T (n)
U→R, equals to
U→R = {(g, r)|(cid:99)TC
˜T (n)
∧(cid:99)TCGR (w2, r)}.
(n)
U
G
(g, w1) ∧ L(n)
U R(w1, w2)
Example 6. Let consider add user u9 to group g4 of GU in
U = GU ∪{(g9, g4), (g1, g5)}−{(g4, g5)}
can
Figure 3. Then G(n)
that is describable with3 TC-closed arcs set [17]. TC
G
(n)
U
be derived by using the algorithms of [5] on arc-set insertion
and deletion.
The followings are the summarized operations that are sup-
ported by our ﬁrst-order maintenance algorithms:
1. Insert or delete a node, which includes inserting a
group or role into GM , or deleting an existing group
or role from GM ;
2. Insert or delete an arc, which includes inserting an arc
into LU R (LRP ), or deleting an existing arc from LU R
(LRP );
3. Insert or delete a user/privilege. The operations can
be supported in diﬀerent ways. For example, for the
case of inserting user u into group g,
(a) Insert u into group g only.
(b) Insert u into group g and all supergroups {g(cid:48)},
which satisfy g.U ⊂ g(cid:48).U .
(c) Insert u into group g and all subgroups {g(cid:48)(cid:48)},
which satisfy g(cid:48)(cid:48).U ⊂ g.U .
(d) Insert u into group g and the all groups of (b) and
(c), which are comparable with g.
Similar issues exist for the situations of deleting a user
or a privilege.
3A nonempty arc set D is called a TC-closed for graph G =
(V, A): (1) for any arc (u, v) of D, if there exists an arc (w, v)
in G − D then all arcs on the path of G ∪ D starting from
v are not in D; and (2) if TCG+D (u2, u3) holds for any two
arcs (u1, u2) and (u3, u4) of D, then each arc on the paths
from u2 to u3 of G ∪ D is in D; and (3) TCD = D.
147
role-based environments. In CSFW, pages 183–194,
1997.
[24] H. Wang and S. L. Osborn. Delegation in the role
graph model. In SACMAT ’06: Proceedings of the
eleventh ACM symposium on Access control models
and technologies, pages 91–100, New York, NY, USA,
2006. ACM Press.
[25] D. Wijesekera, S. Jajodia, F. Parisi-Presicce, and
A. Hagstr¨om. Removing permissions in the ﬂexible
authorization framework. ACM Trans. Database Syst.,
28(3):209–229, 2003.
[6] G. Dong and R. Topor. Incremental evaluation of
datalog queries. In Proc. Int’l Conference on Database
Theory, pages 282–296, Berlin, Germany, Oct. 1992.
[7] K. Etessami. Dynamic tree isomorphism via ﬁrst-order
updates. In PODS, pages 235–243, 1998.
[8] D. F. Ferraiolo, R. Sandhu, S. Gavrila, D. R. Kuhn,
and R. Chandramouli. Proposed nist standard for
role-based access control. ACM Trans. Inf. Syst.
Secur., 4(3):224–274, 2001.
[9] P. Gibbons, R. Karp, V. Ramachandran, D. Soroker,
and R. Tarjan. Transitive compaction in parallel via
branchings. J. Algorithms, 12(1):110–125, 1991.
[10] S. Grumbach and J. Su. First-order deﬁnability over
constraint databases. In Proceedings of Conference on
Constraint Programming, 1995.
[11] X. Han, P. Kelsen, V. Ramachandran, and R. Tarjan.
Computing minimal spanning subgraphs in linear
time. SIAM J. Comput., 24(6):1332–1358, 1995.
[12] T. Jaeger and J. E. Tidswell. Practical safety in
ﬂexible access control models. ACM Trans. Inf. Syst.
Secur., 4(2):158–190, 2001.
[13] S. Jajodia, P. Samarati, M. L. Sapino, and V. S.
Subrahmanian. Flexible support for multiple access
control policies. ACM Trans. Database Syst.,
26(2):214–260, 2001.
[14] M. Nyanchama and S. Osborn. The role graph model
and conﬂict of interest. ACM Trans. Inf. Syst. Secur.,
2(1):3–33, 1999.
[15] S. Osborn and Y. Guo. Modeling users in role-based
access control. In RBAC ’00: Proceedings of the ﬁfth
ACM workshop on Role-based access control, pages
31–37, New York, NY, USA, 2000. ACM Press.
[16] C. Pang, G. Dong, and K. Ramamohanarao.
Incremental maintenance of shortest distance and
transitive closure in ﬁrst-order logic and sql. ACM
Trans. Database Syst., 30(3):698–721, 2005.
[17] C. Pang, X. Zhang, Y. Zhang, and
K. Ramamohanarao. Maintenance of access roles in
sql. In Technical Report, 2005.
[18] J. S. Park, K. P. Costello, T. M. Neven, and J. A.
Diosomito. A composite RBACapproach for large,
complex organizations. In SACMAT ’04: Proceedings
of the ninth ACM symposium on Access control models
and technologies, pages 163–172, New York, NY, USA,
2004. ACM Press.
[19] S. Patnaik and N. Immerman. Dyn-FO: A parallel
dynamic complexity class. In Proc. ACM Symp. on
Principles of Database Systems, pages 210–221, 1994.
[20] R. S. Sandhu, E. J. Coyne, H. L. Feinstein, and C. E.
Youman. Role-based access control models. IEEE
Computer, 29(2):38–47, Feb. 1996.
[21] B. Shaﬁq, J. Joshi, E. Bertino, and A. Ghafoor.
Secure interoperation in a multidomain environment
employing RBAC policies. IEEE Trans. Knowl. Data
Eng., 17(11):1557–1577, 2005.
[22] M. Shehab, E. Bertino, and A. Ghafoor. SERAT:
Secure role mapping technique for decentralized secure
interoperability. In Proceedings of the tenth ACM
symposium on Access control models and technologies,
pages 159–167, 2005.
[23] R. Simon and M. E. Zurko. Separation of duty in
148