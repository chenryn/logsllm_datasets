客户端CSRF漏洞的第一个条件是存在传出请求的攻击控制的输入参数。上图显示了来自真实示例的易受攻击代码的不同实例，其中通过构造，将WIN.LOC和REQ语义类型分配给AST节点，分别显示为蓝色和橙色框。对于上图的所有三种情况，目标是识别同时具有橙色和蓝色标签（标有红色箭头）的代码行。在较高的层次上，一行代码是JavaScript语句或声明（例如EXP_STMT，VAR_DECL）的非终端AST节点，用谓词isDeclOrStmt（n）表示。
然后，一旦确定了这样的AST节点n，就需要研究该节点是否具有两个子c1和c2，其中一个子节点为REQ类型，另一个子节点为WIN.LOC类型。
按照查询符号，可以编写：
查询1不足以确定是否存在客户端CSRF漏洞，因为返回的节点可能对应于页面加载时未执行的代码行。通过额外的可达性检查来完善它。通常，从isDeclOrStmt（n）这样的节点n开始，可以跟踪CFG的后向边（ε，true和false），以确定是否到达CFG入口节点。然后，每当到达函数定义（例如F_DECL）时，都会在IPCG调用边之后跳转到其所有调用位置。但这还不够，因为可以在触发特定事件时执行功能。因此，需要向后访问ERDDG边，即依赖关系边，然后是注册和调度边。分别处理特殊情况，在这些情况下，浏览器会在加载页面时自动触发事件。继续跟踪CFG，ERDDG和IPCG的后向边，直到到达CFG入口节点或不再有匹配任何先前条件的节点为止。如果CFG条目节点位于查询结果集中，则节点n是可访问的。
**脆弱行为分析：**
先前的查询可以识别客户端CSRF的一般易受攻击行为，即使用攻击者选择的数据值提交HTTP请求的程序。但是，程序可能会对输入进行各种检查，最终可能会影响开发环境。例如，在上图程序1显示了一个易受攻击的脚本，其脚本的第1行的域验证限制了攻击者操纵整个请求URL。但是，程序2显示了攻击者可以选择完整的URL字符串（包括路径和查询字符串）的情况。打算研究的客户端CSRF漏洞的一个方面是确定攻击者可以操纵传出请求的程度。例如，如果window.location属性流至请求参数而没有进行任何清理。查询2捕获了以下方面：
查询2检查由查询1返回的节点n1是否通过PDG边连接到赋值语句，该赋值语句的右侧子级是window.location的属性。谓词hasPDGPath（n2，n1）指定在PDG边之后存在从n2到n1的路径，并且isAssignment（n2）标记n2为VAR_DECL或ASSIGN_EXP节点。
要考虑的另一个方面是请求中攻击者可控项目的数量。例如，上图的程序3显示了一个更复杂的示例，其中，攻击者还可以控制请求正文的内容，从而增加了为易受攻击的行为创建利用漏洞的灵活性。为此，查询可以利用属于同一请求的元素之间的PDG依赖性，将属于同一HTTP请求的易受攻击的代码行聚类。然后，查询可以计算攻击者可控制的注入点的数量（例如，参见程序3第6行中的两个注入点以及第4行中的注入点）。
## 0x04 JAW
在本节中将介绍JAW，这是一个使用HPG研究客户端CSRF漏洞的框架。
JAW从网站的原始URL开始，使用启用JavaScript的网络搜寻器访问网页以收集Web资源。在访问期间，JAW还收集运行时状态值。然后，给定用户定义的语义类型及其对JavaScript语言标记的映射的列表，JAW构造HPG。建设分为两个阶段。首先，JAW识别程序所使用的外部JavaScript，并对其进行独立处理以提取符号模型。然后，它构造其余JavaScript代码的图，并将JavaScript程序的元素链接到状态值。最后，JAW通过在HPG上执行查询来分析客户端CSRF。下图概述了JAW的体系结构。
### A.数据收集
数据收集模块执行两项任务：爬取以发现来自不同用户状态的URL，以及为找到的每个网页收集JavaScript代码和状态值输入。数据收集模块的输入是被测Web应用程序的种子URL，以及可选的测试用例，以通过用户登录，例如，作为脚本化的Selenium任务或通过跟踪记录。
**爬虫：**
开发了一种爬虫，它使用通过Selenium控制的无头Chrome实例。从种子URL开始，爬虫访问Web应用程序以收集Web资源和运行时执行数据。它遵循迭代加深深度优先搜索策略，并在未找到其他URL或分配的时间预算用完时终止（默认值为24h）。如果作为输入提供，它将在爬网会话之前执行测试用例。
**JavaScript代码和状态值：** 当访问每个页面时，爬虫程序每ti = 10秒存储一次Web资源和状态值，其中m =
2次（可配置参数）。爬虫针对每个ti间隔收集HTML页面，JavaScript程序，HTTP请求和响应以及明确显示的JavaScript属性。通过Selenium接口提取JavaScript属性时，为爬虫开发了一个Chrome扩展程序，该扩展程序使用函数hook来拦截对addEventListener的调用以收集事件，并调用chrome.webRequest
API来拦截网络流量。
### B.图构造
收集到的JavaScript代码和状态值来构建HPG。生成的图形被导入Neo4j数据库中，以便进行细粒度的声明式路径遍历，以检测和研究客户端CSRF，本节描述了构建HPG的技术细节。
**规范化JavaScript代码：**
第一步，JAW通过在脚本标签和HTML属性（即内联JavaScript代码）内串联代码段来创建规范化的JavaScript程序，并保留程序段的执行顺序。组合内联代码时，JAW用addEventListener
API替换内联事件处理程序注册。
**库检测：** 为了识别库，使用库检测器，该工具可在执行环境中搜索已知的库签名（例如，全局变量）。
**HPG构造：**
JAW构造HPG的方法如下。首先，为每个检测到的库的符号建模创建图。如果该库的符号模型已经存在，则跳过此步骤。然后，它为正在分析的程序创建一个图。不管使用该图如何，构建HPG的规则都不会改变，如下所示。
**1.AST：** JAW使用Esprima（一种符合标准的ECMAScript解析器）生成标准化源代码的AST。
Esprima的输出是AST的JSON表示形式。在此表示中，节点是具有类型属性（例如VAR_DECL）的键值字典，并且边用临时字典键表示。将JSON输出映射到图形的AST节点和AST边。
**2.CFG ：** 本研究广泛审查了开源CFG生成器，例如escontrol，styx或ast-flow-graph，并选择了Esgraph，因为它很受欢迎并且符合Esprima
。从AST开始，Esgraph生成CFG，其中节点是用于语句或声明的AST节点，对于条件分支，边标记为true或false，对于同一基本块的节点标记为ε。
**3\. PDG：** JAW使用dujs，这是一个基于Esgraph的def-use分析库。修改了dujs以增加对全局变量，闭包和匿名函数调用的支持。
dujs的输出是AST边之间每个变量v的定义使用关系的列表，该JAW导入为HPG中的数据依赖边Dv。对于控制相关性边，JAW根据CFG计算后支配树，每条语句s一个。然后，JAW将树的每个边分别映射到True或false分支的Ct或Cf。
**4.IPCG：**
JAW生成IPCG的方法如下。在AST和CFG的构建过程中，JAW会跟踪所有函数定义和调用站点。然后，它将调用站点与其可能调用的函数定义相关联。
JavaScript中有五种类型的调用表达式：全局对象上的函数调用（例如foo( )），属性调用（例如a.foo( )或a['foo'](
)），构造函数调用（例如，新的Foo( )），通过call( )和apply(
)方法的调用。在所有情况下，实际的函数定义名称都可以使用别名。使用PDG解析指针，并相应地连接调用边。如果指针的值是有条件的，将边连接到每个相应的函数定义。
**5.ERDDG：**
为了生成ERDDG，JAW会在创建AST和CFG期间跟踪事件调度和处理程序注册。对于发现的每个事件处理程序，JAW都会创建一个将顶级AST节点（即CFG节点）连接到处理程序功能的注册边，以及一个将处理程序功能连接到主体语句的依存关系。为了将每个事件调度关联到注册站点，检查它们是否针对相同的DOM元素。为此利用PDG解析在其上调度了事件的指针以及在其上注册了处理程序的指针，并检查它们是否引用相同的变量声明或具有逐字或语义上相同值的不同变量。使用DOM快照来检查两个不同的DOM查询是否可以在语义上针对同一元素。例如，可以使用元素的id或名称属性来查询元素。一旦确定指针引用了相同的元素，就可以在分发站点和注册站点之间连接一条边。
**6.语义类型和传播：**
此步骤的输入是语义类型t和AST节点σ的签名之间的映射T，例如，将WIN.LOC类型映射到JavaScript属性window.location。对于每对（t，σ）∈T，JAW将每种类型t存储到与签名σ匹配的AST节点。然后，JAW通过HPG传播类型t。
算法1将类型t从节点n传播到其他节点。首先，函数propagateLeft将类型t分配给左侧的变量v（例如，分配的变量）（如果有的话），然后将其返回。然后，函数propagateByPDG在PDG边之后传播t，并返回访问路径P。然后，对于路径pi∈P末端的每个节点nt，区分了三种情况。第一种情况是nt是一个函数调用，通过在符号建模过程中分配的特殊语义类型进行建模。如果是这样，将污染输出变量o，然后递归调用o的propertyForward。其次，nt是具有IPCG边的调用表达式。在这种情况下，在函数定义上对参数c进行了污染，该参数与调用站点上污染的参数相对应，并为c调用propertyForward。然后，调查函数定义上下文中的最后一个污染节点是否是污染的return语句。如果是这样，在保存返回结果的调用站点上为变量vle
ft调用propertyForward。第三，nt是传递受污染数据的事件分发表达式。在这种情况下，跳过分派和注册边，污染相应的事件变量，然后为该变量调用propertyForward。当以上条件均不成立时，此过程终止。
在创建用于库的符号建模的HPG和其余代码的HPG时，JAW都会执行语义类型传播。在为其余代码创建HPG时，语义类型映射T包括在符号建模期间创建的映射。
**符号建模：**
此步骤的输出是语义类型和AST节点的映射，该映射在为正在分析的程序构建HPG时使用。符号建模始于从库源代码构建HPG。然后，在传播了语义类型之后，JAW搜索具有过程内输入输出关系的函数定义。更具体地说，JAW通过至少一个输入参数来识别所有非匿名函数表达式，并通过向后程序切片方法来跟踪其返回语句（如果有）的值。在较高的层次上，利用PDG，CFG，IPCG和ERDDG图从返回值的起点开始，一直到修改该值的地方，再到生成该值的地方结束。如果返回的变量（例如o）对函数输入（例如i）具有PDG控件依赖性，则将类型o〜i分配给该函数。如果建立PDG数据依赖关系，则将其标记为o←i。最后，JAW选择具有至少一种语义类型的所有函数表达式和对象属性节点，这些节点将在JavaScript代码的HPG构造中使用。
## 0x05 评估
评估的总体目标是研究客户端CSRF漏洞并评估JAW的有效性和实用性。在4,836个网页上运行JAW，这些网页从106个流行的Web应用程序中爬取，并为228,763,028
LoC生成了HPG。在此过程中，发现在87个应用程序中分配了12,701个可伪造的客户端请求。发现七个应用程序遭受至少一个0
day客户端CSRF漏洞的攻击，可以利用该漏洞执行状态更改操作并破坏服务器的完整性。下图描述了为了构建和分析HPG的每个工具组件的平均处理时间。
### A.实验设置和方法
**测试平台：**