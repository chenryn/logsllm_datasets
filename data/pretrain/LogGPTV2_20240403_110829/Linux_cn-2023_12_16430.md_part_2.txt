但因为 Git 不知道 `mybranch` 是 `main` 的一个分叉，你需要显式地告诉它在何处进行变基。
### 合并操作也使用了“直观”的分支概念
合并操作并不复制提交，但它们确实需要一个“ 基础   base ”提交：合并的工作原理是查看两组更改（从共享基础开始），然后将它们合并。
我们撤销刚才完成的变基操作，然后看看合并基础是什么。
```
$ git switch mybranch
$ git reset --hard 13cb960  # 撤销 rebase
$ git merge-base main mybranch
3997a466c50d2618f10d435d36ef12d5c6f62f57
```
这里我们获得了分支分离出来的“基础”提交，也就是 `3997a4`。这正是你可能会基于我们的直观图片想到的提交。
### GitHub 的拉取请求也使用了直观的概念
如果我们在 GitHub 上创建一个拉取请求，打算将 `mybranch` 合并到 `main`，这个请求会展示出两次提交：也就是 `x` 和 `y`。这完全符合我们的预期，也和我们对分支的直观认识相符。
![](/data/attachment/album/202312/01/004113qbuwytnuqtkhjl3l.png)
我想，如果你在 GitLab 上发起一个合并请求，那显示的内容应该会与此类似。
### 直观理解颇为精准，但它有一定局限性
这使我们的对分支直观定义看起来相当准确！这个“直观”的概念和合并、变基操作以及 GitHub 拉取请求的工作方式完全吻合。
当你在进行合并、变基或创建拉取请求时，你需要明确指定另一个分支（如 `git rebase main`），因为 Git 不知道你的分支是基于哪个分支的。
然而，关于分支的直观理解有一个比较严重的问题：你直觉上认为 `main` 分支和某个分离的分支有很大的区别，但 Git 并不清楚这点。
所以，现在我们要来讨论一下 Git 分支的不同种类。
### 主干和派生分支
对于人类来说，`main` 和 `mybranch` 有着显著的区别，你可能针对如何使用它们，有着截然不同的意图。
通常，我们会将某些分支视为“ 主干   trunk ”分支，同时将其他一些分支看作是“派生”。你甚至可能有派生的派生分支。
当然，Git 自身并没有这样的区分（“派生”是我刚刚构造的术语！），但是分支的种类确实会影响你如何处理它。
例如：
* 你可能会想将 `mybranch` 变基到 `main`，但你大概不会想将 `main` 变基到 `mybranch` —— 那就太奇怪了！
* 一般来说，人们在重写“主干”分支的历史时比短期存在的派生分支更为谨慎。
### Git 允许你进行“反向”的变基
我认为人们经常对 Git 感到困惑的一点是 —— 由于 Git 并没有分支是否是另一个分支的“派生”的概念，它不会给你任何关于何时合适将分支 X 变基到分支 Y 的指引。这一切需要你自己去判断。
例如，你可以执行以下命令：
```
$ git checkout main
$ git rebase mybranch
```
或者
```
$ git checkout mybranch
$ git rebase main
```
Git 将会欣然允许你进行任一操作，尽管在这个案例中 `git rebase main` 是极其正常的，而 `git rebase mybranch` 则显得格外奇怪。许多人表示他们对此感到困惑，所以我提供了一个展示两种变基类型的图片以供参考：
![](/data/attachment/album/202312/01/004114c97y1nk9n96pymk7.png)
相似地，你可以进行“反向”的合并，尽管这相较于反向变基要正常得多——将 `mybranch` 合并到 `main` 和将 `main` 合并到 `mybranch` 都有各自的益处。
下面是一个展示你可以进行的两种合并方式的示意图：
![](/data/attachment/album/202312/01/004115hccjb6cqqqqbegbf.png)
### Git 对于分支之间缺乏层次结构感觉有些奇怪
我经常听到 “`main` 分支没什么特别的” 的表述，而这令我感到困惑——对于我来说，我处理的大部分仓库里，`main` 无疑是非常特别的！那么人们为何会称其为不特别呢？
我觉得，重点在于：尽管分支确实存在彼此间的关系（`main` 通常是非常特别的！），但 Git 并不知情这些关系。
每当你执行如 `git rebase` 或 `git merge` 这样的 `git` 命令时，你都必须明确地告诉 Git 分支间的关系，如果你出错，结果可能会相当混乱。
我不知道 Git 在此方面的设计究竟“对”还是“错”（无疑它有利有弊，而我已对无休止的争论感到厌倦），但我认为，这对于许多人来说，原因在于它有些出人意料。
### Git 关于分支的用户界面也同样怪异
假设你只想查看某个分支上的“派生”提交，正如我们之前讨论的，这是完全正常的需求。
下面是用 `git log` 查看我们分支上的两次派生提交的方法：
```
$ git switch mybranch
$ git log main..mybranch --oneline
13cb960 (HEAD -> mybranch, origin/mybranch) y
9554dab x
```
你可以用 `git diff` 这样查看同样两次提交的合并差异：
```
$ git diff main...mybranch
```
因此，如果你想使用 `git log` 查看 `x` 和 `y` 这两次提交，你需要用到两个点（`..`），但查看同样的提交使用 `git diff`，你却需要用到三个点（`...`）。
我个人从来都记不住 `..` 和 `...` 的具体用意，所以我通常虽然它们在原则上可能很有用，但我选择尽量避免使用它们。
### 在 GitHub 上，默认分支具有特殊性
同样值得一提的是，在 GitHub 上存在一种“特殊的分支”：每一个 GitHub 仓库都有一个“默认分支”（在 Git 术语中，就是 `HEAD` 所指向的地方），具有以下的特别之处：
* 初次克隆仓库时，默认会检出这个分支
* 它作为拉取请求的默认接收分支
* GitHub 建议应该保护这个默认分支，防止被强制推送，等等。
很可能还有许多我未曾想到的场景。
### 总结
这些说法在回顾时看似是显而易见的，但实际上我花费了大量时间去搞清楚一个更“直观”的分支概念，这是因为我已经习惯了技术性的定义，“分支是对某次提交的引用”。
同样，我也没有真正去思索过如何在每次执行 `git rebase` 或 `git merge` 命令时，让 Git 明确理解你分支之间的层次关系——对我而言，这已经成为第二天性，并没有觉得有何困扰。但当我反思这个问题时，可以明显看出，这很容易导致某些人混淆。
*（题图：MJ/a5a52832-fac8-4190-b3bd-fec70166aa16）*
---
via: 
作者：[Julia Evans](https://jvns.ca/) 选题：[lujun9972](https://github.com/lujun9972) 译者：[ChatGPT](https://linux.cn/lctt/ChatGPT) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出