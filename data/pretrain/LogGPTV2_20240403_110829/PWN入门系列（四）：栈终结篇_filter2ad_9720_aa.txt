# PWN入门系列（四）：栈终结篇
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x0 PWN入门系列文章列表
[Mac 环境下 PWN入门系列（一）](https://www.anquanke.com/post/id/187922)
[Mac 环境下 PWN入门系列（二）](https://www.anquanke.com/post/id/189960)
[Mac 环境下 PWN入门系列（三）](https://www.anquanke.com/post/id/193115)
## 0x1 前言
在群里看到了一些表哥在讨论一个基础的PWN栈溢出题目, 虽然自己忙着备考，但是一不小心忍不住 **觉得很简单** 然后熬了一晚 **没有结果**
,最后才发现自己在学习pwn的过程中忽略了很多基础知识的学习和巩固，学习PWN必须要有扎实的基础, 多看一些书籍>、>,比如晚上睡觉前偷偷看一点(暗地里学习……….)
## 0x2 环境说明
调试环境: docker 集成环境
    # 备份每一次的环境,防止丢失
    docker commit -p a974e95a1 mypwn-backup
    docker save -o mypwn.tar mypwn-backup
    # 通过加载备份的镜像还原PWN调试环境
    docker load -i mypwn.tar
系统类型:
    root@mypwn:/ctf/work# lsb_release -d
    Description:    Ubuntu 18.04.2 LTS
## 0x3 浅析x86内存管理架构
###  0x3.1 实模式 、保护模式
x86 两种基本工作运行方式: 实模式 、保护模式
一般我们划分内存单元都是字单元,占8位,
32位程序则说明占用4个字单元,按照4字节来对齐读取。
64位则占用8个字内存单元,按照8字节来对齐再一次性读取8字节来处理。
> CPU工作模式是指: cpu的寻址方式、寄存器大小等用来反应CPU的工作流程的概念。
>
>   * 1.实模式
>
>
> CPU加电并经历最初的混沌状态后,首先进入的就是实模式,是早期8086处理器工作的模式。在该模式下,逻辑地址转换后即为物理地址。  
>  为什么需要这个模式呢,其实我觉得还是硬件决定的。  
>  当时8088CPU有20位地址线,地址空间就是2^20byte = 1MB 大小  
>  那么如何去选择这些地址空间就有了硬件上的难题了。  
>  一般来说译码器都是3-8 4-16这种组合  
>  寄存器2的倍数,没有20位的寄存器怎么办呢?  
>  译码器我们学过两块3-8 转为4-16,那么我们就能考虑两块16寄存器搞个20位寄存器啦。  
>  8088CPU共有8个16位通用寄存器,4个16位段寄存器  
>  段寄存器:
>
>   * cs(code segement):代码段寄存器
>   * ds(data segement):数据段寄存器
>   * ss(stack segement):堆栈段寄存器
>   * es(extra segement):附加段寄存器
>   * fs(flag segment):标志段寄存器
>   * gs(global segement):全局段寄存器
>
>
> 段寄存器决定 **段基址**  
>  通用寄存器决定 **段内偏移量**  
>  **物理地址 = 段基址   举个例子:  
>  段基址是16位:0xff00然后左移4位(4位二进制表示1个16进制)就变成了 0xff000,这样不就是20位地址了吗？  
>  0xff110 = 0xff00
>   * 2.保护模式
>
>
> 操作系统运行最常见的模式,顾名思义比实模式多了保护措施,但是为了实现兼容，寻址方式没太大改变。  
>  32位系统能跑4GB, 64位系统能跑128G,再高的内存就要换系统了。  
>  保护模式增加了个 **全局描述符表(GDT)** 结构,段寄存器不再存放段基址,而是存放这个GDT的索引。  
>  GDT是在进入保护模式时必须要先定义好。  
>  GDT的每一个表项都是一个段描述符只能定义一个内存短。  
> 特权值就存储在段寄存器的低2位: 2^2=4 对应 0、1、2、3  
>  linux一般只有内核态和用户态,也就是两种特权值。
###  0x3.2 地址的概念
物理地址空间: 硬件层面的线路分布
线性地址空间(虚拟地址空间): 线性地址空间对应映射到物理地址空间,线性地址就是作为索引的存在。
地址: 逻辑地址、线性地址、物理地址
逻辑地址: 段寄存器+段内偏移量组成,常见的地址指针*p存放的就是偏移量。
线性地址(虚拟地址):逻辑地址进行分段转换比如左移4位再相加偏移得到。
物理地址:
作用于物理层面,是物理地址空间的索引
  * 启动分段机制，未启动分页机制：逻辑地址—> (分段地址转换) —>线性地址—->物理地址
  * 启动分段和分页机制：逻辑地址—> (分段地址转换) —>线性地址—>分页地址转换) —>物理地址
###  0x3.3 内存管理机制
内存管理机制: 1.分段机制 2.分页机制 3.段页机制
**分段机制** (必须开启的)
分段机制主要是解决”地址总线宽度一般大于寄存器宽度”这个问题。
优点:适合处理复杂系统
**分页机制(可选开启):**
一般的页空间是4k,也就是2^12,也就是12位对应4个16进制数,这个后面PIE会再次涉及,页内的空间是连续存储的。
分页机制将程序划分为多个页,按需来调入内存,能有效提高内存的利用率。
段页机制:
其实就是在不同的段里面引入页机制。
优点: 分页、分段的优点
缺点: 多次重复查表
更多详细内容: [CPU的实模式和保护模式(一)](https://zhuanlan.zhihu.com/p/42309472)
## 0x4 PWN保护说明
我们经常第一步是查保护:
    root@mypwn:/ctf/work/MiniPWN# checksec vuln5
    [*] '/ctf/work/MiniPWN/vuln5'
        Arch:     i386-32-little
        RELRO:    No RELRO
        Stack:    No canary found
        NX:       NX disabled
        PIE:      No PIE (0x8048000)
        RWX:      Has RWX segments
(1)Arch:
  * 说明程序的架构是x86架构-32位程序-小段字节序号
(2)RELRO:
  * 设置符号重定向表格为只读或在程序启动时就解析所有动态符号,从而减少对GOT表的攻击。
  * 编译选项: 关闭 `-z morello` 开启(部分)`-z lazy` 开启(完全)`-z now`
(3)Stack:
  * 栈溢出保护
  * 编译选项: 关闭`-fno-stack-protector` 启用`-fstack-protector-all`
(4) NX
  * 堆栈不可执行,也就是不能在栈上执行shellcode,window下类似DEP(数据执行保护)
  * 编译选项: 关闭 `-z execstack` 开启`-z noexecstack`
(5)PIE
  * 内存地址全随机化(Linux下pie开启必须同时开启aslr)
  * 编译选项: 关闭`-no-pie` 开启`-pie -fPIC`(默认开启)
(6)RWX
  * BSS段可读写执行
全保护关闭编译命令:
生成32位程序: `-m32` 生成64位程序: `-m64`
    gcc -g -fno-stack-protector -z execstack -no-pie -z norelro  -m32 -o vuln 1.c
更多内容推荐参考:checksec及其包含的保护机制
## 0x5 浅析Linux下PIE、ASLR与libc的那些事
###  0x5.1 PIE机理分析
如果对PIE不了解的话,就很容易搞混PIE与地址基址的关系,笔者在做题的时候就经常遇到这些错误。
**Linux 下的PIE与ASLR**
PIE(position-independent
execute),地址无关可执行文件,是在编译时将程序编译为位置无关,主要负责的是代码段和数据段(.data段 .bss段)的地址随机化工作.
ASLR则主要负责其他内存的地址随机化。
**PIE如何作用于ELF可执行文件**
ELF程序运行的时候是cpu在硬盘上调入加载进内存的,这个时候程序就有了内存地址空间。
ELF的文件结构:
    ELF file format:
    +---------------+
    |  File header  | # 文件头保存每个段类型和长度
    +---------------+ 
    | .text section | # 代码段 存放代码和指令
    +---------------+
    | .data section | # 数据段 
    +---------------+
    | .bss section  | # bss段 存放未初始化的全局变量和静态变量,一般可读写
    +---------------+ # 是存放shellcode的好地方。
    |      ...      |
    +---------------+
    |  xxx section  |# 还有字符串段、符号表段行号表段等
    +---------------+
    # 局部变量和函数参数分别在栈中分配(栈和堆分别在内存中分配,在elf文件中不存在对应的部分)
备忘录:
查看每个段的分布命令
`readelf -S vuln5`
> elf中常见的段有如下几种：  
>  代码段 text 存放函数指令  
>  数据段 data 存放已初始化的全局变量和静态变量，  
>  只读数据段 rodata 存放只读常量或const关键字标识的全局变量  
>  bss段 bss 存放未初始化的全局变量和静态变量，这些变量由于为初始化，所以没有必要在elf中为其分配空间。bss段的长度总为0。  
>  调试信息段 debug 存放调试信息  
>  行号表 line 存放编译器代码行号和指令的duiing关系  
>  字符串表 strtab 存储elf中存储的各种字符串  
>  符号表 symtab elf中到处的符号，
当把ELF文件加载到内存的时候,各种段就会被装载在内存地址空间中,形成程序自己的内存空间布局。
查看各个段的加载内存布局命令:
`objdump -h vuln5`
    +------------------------+ Oxffffffff
            |     kernel space       |
            +------------------------+ 0xC0000000
            |        stack           |
            +------------------------+
            |                        |
            |        unused          |
            |                        |
            +------------------------+
            |   dynamic libraries    |
            +------------------------+ 0x40000000
            |                        |
            |        unused          |
            |                        |
            +------------------------+
            |         heap           | # 堆 动态内存分配的空间 进程调用
            +------------------------+ # malloc、free等函数时变化
            |  read/write sections   |
            |      (.data .bss)      |
            +------------------------+
            |   read only sections   |
            | (.init .rodata .text)  |
            +------------------------+ 0x08048000
            |       reserved         |
            +------------------------+
前面我们可以知道程序加载内存的时候不是一次性加载的,而是分页按需加载的,这个时候PIE只能作用于单个内存页,也就是说页内存里面的地址不会被随机化,一般来说页内存的大小是4k,刚好对应了12位,对应16进制的后3位,这就是PIE的一部分缺陷,由此也可以衍生一些相关的攻击点。
这也是ida里面看开了PIE的程序,代码段就只显示后3位的原因。
ps.这里还有个约定俗成的 **特点** :
64位程序pie是以7f开头, 32位程序pie则是以f7开头。
    root@mypwn:/ctf/work/MiniPWN# ldd vuln64
        linux-vdso.so.1 (0x00007ffe65386000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8e2d466000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f8e2d857000)
    root@mypwn:/ctf/work/MiniPWN# ldd vuln5
        linux-gate.so.1 (0xf76ed000)
        libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7504000)
        /lib/ld-linux.so.2 (0xf76ee000)
###  0x5.2 PIE与ASLR的关系
**Linux的ASLR + PIE 作用 == window下ASLR的作用**
Linux的ASLR共有3个级别0、1、2
> 0: 关闭ASLR,没有随机化,堆栈基地址每次都相同,libc加载地址也相同  
>  1: 普通ASLR mmap、栈基地址、libc加载随机化,但是堆没有随机化  
>  2.增强ASLR,增加堆随机化
PIE开启的时候,ASLR必须开启,所以说PIE可以间接认为具有ASLR的功能。
LInux下默认开启ASLR等级且为2
`cat /proc/sys/kernel/randomize_va_space`
`echo 0 >/proc/sys/kernel/randomize_va_space`
###  0x5.3 libc基地址的获取方式
由于Linux默认开启了ASLR,所以就算你开不开PIE,每次加载的时候libc地址都是会变化的(原因往上翻)
    [*] '/ctf/work/MiniPWN/vuln5'
        Arch:     i386-32-little
        RELRO:    No RELRO
        Stack:    No canary found