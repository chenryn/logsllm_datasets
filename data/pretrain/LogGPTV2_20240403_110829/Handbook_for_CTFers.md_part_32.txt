on. Some information is lost during the process. For example, comments in the
source code are usually discarded during compilation, labels in the assembly code,
and symbolic information such as function names and type names also discarded
during linking.
The reverse requires attacker restores some of the loss information with their
knowledge and experience to achieve the attacker’s goals.
2. Different formats executable files
In practice, due to legacy issues and competition between companies, there are
multiple file formats which generated by each of the steps described above. For
example, Windows use the PE (Portable Executable), while Linux systems use the
ELF (Executable and Linkable Fommat). Since both executable file formats were
developed from the COFF (Common Object File Format), the various concepts in
the file structure are similar.
The PE file consists of a DOS header, PE file header, section table and section
data, import table (if you need to reference an external dynamically linked library)
Jao o xu (eouup on suonoung ano apoud ueo no ) aqe uodx pue
programs, which commonly found in DLL files).
The ELF file consists of the ELF header, section data, section table, string
segment, and symbol table.
Sections are logical divisions of parts of a program, usually with specific names, 
such as .text or .code for code sections, .data for data sections. At runtime, sections of
---
## Page 311
5.1 Basics of Revese Engineering
297
an executable are loaded into various locations in memory, and one or more sections
st uoeuas peaano aaes on pue juaaeue roy uasas e on padde ane
based on the permissions (read, write, execute) required for this part of the memory.
A Segmentation Fault is caused if an illegal operation is performed in the
 e po jo sas r u uoo am e e wns sas psao
only be read and executed.
The format details of PE and ELF are now fully disclosed, and a large number of
mature tools are available for parsing and modifying them.
5.1.3Basic Knowledge of Assembly Language
After parsing the file, the attacker is confronted with a large piece of machine code,
which is directly generated by the assembly language, so the attacker needs to have a
basic understanding of assembly before reversing.
The following is an introduction to the key concepts of assembly language to
facilitate you quick understanding of assembly language.
1. Registers, Memory, and Addressing
A register is a component of a CPU that is a high-speed storage component with
e p ss aos  on psn s e s p
addresses. A typical IA-32 (Intel Architecture, 32-bit) or x86 architecture processor
contains the following registers that are explicitly visible in the instructions.
• General purpose registers EAX, EBX, ECX, EDX, ESI, EDL
• Top-of-stack Pointer Register ESP, Bottom-of-stack Pointer Register EBP.
▪ Instruction counter EIP (holds the address of the next instruction to be executed).
▪Segment registers CS, DS, SS, ES, FS, GS.
For the x86-64 architecture, based on these registers, the E prefix is changed to R to
mark 64 bits, and eight general-purpose registers, R8 to R15 are added. In addition,
for the 16-bit case, the E prefix is removed. 16-bit has some restrictions on the use of
registers, which will not be repeated in this book since it is no longer mainstream.
For the general purpose registers, the program can use all of them. The
corresponding mark when using different parts of the registers are shown in
Fig. 5.1, where the naming conventions for spliting R8 to R15 are R8d (low
32 bits), R8w (low 16 bits), and R8b (low 8 bits).
There is also a flag register in the CPU, in which each bit represents the value of a
corresponding flag.There are some commonly used flags:
*AF: Auxiliary Carry Flag, set to 1 when the result is rounded to the third digit.
▪PF: Parity flag, set to 1 when the lowest order byte of the result an arithmetic or bit
wise operation has an even or odd number of 1s.
u u e s n s m I s uis a m I o s e us s 
•ZF: Zero Flag, set to 1 when the result is all zero.
---
## Page 312
298
5 Reverse Engineering
16 bit
RAX
EAX
AX
AII
= 3 bit
RBX
EBX
AL
RCX
ECX
BX
CX
BH
CH
BL
RDX
EXx
CL
RSI
DX
DHI
ES1
DL
RDI
EDXI
RS2
E5SP
RBP
EBP
RI~R15
RSD-RI5D
RboxW
RxxE
Fig, 5.1 The corresponding mark of the registers
spe o ss  1's a
Addressing
mode
nstration
Operating
Immediate
1000h
The number 1000h
Addressing
Direct
[1000b]
Memory 1000h address unit
Register
RAX
The RAX register.
Register
[RAX]
Memory unit with the number of adresses stored in the
indirectly
Base addressing
RAX.
[RBP+10b]
and access the memory unit at this adress.
Take the number in the RBP as the base address, add 10h,
Variable
addressing
[RDI+10h]
Use the RDI as a variable adress register, add 10h to the
number in it, and access the memory unit at this adress.
Base plus index
[RBX+RSI
pso snd
Same logic as above.
+10h]
• OF: Overflow Flag, set to 1 if the number to be operated on is a signed number
and overflow.
CF: Carry Flag, set to 1 when the result is carried out above the highest bit, used
to determine whether overflow of unsigned numbers.
The CPU can operate not only on registers but also on memory units. There are many
ways to address them. Table 5.1 shows the different addressing modes, examples,
and corresponding operation of CPU.
(ssoe panpu)  u Joeado s, ap o uaea1nbo s l, 1e aos o Asea s 1
In the x86/x64 architecture, the four addressing methods of indirect register
addressing, base address addressing, variable address addressing, and base address
index plus addressing are almost the same in terms of the implementation, but there
is a semantic difference. In the 16-bit times, these four types of addressing can not be
mixed. In moderm compilers, the compiler will choose the appropriate addressing
---
## Page 313
5.1 Basics of Reverse Engineering
299
Table 5.2 Com
Operation
Command type
Instruction
code
examples
Corresponding effects
Duta transfer
A0t
mov rax, rbx
rax = rbx
instructions
mov qword ptr
*(rdi) = rax
Addressing
[rdi], rax
lea
lea rax, [rsi]
rax = & **(rsi)
instructions
Arithmetic
add
add qword ptr
add rax, rbx
rax += rbx
instructions
*(rdi) += rax
[rdi], rax
sub
sub rax, rbx
rax - rbx
Logical operations
instructions
and
and rax, rbx
rax &= rbx
Xor
xor rax, thx
rax ^= rbx
Function call
call
call 0x401000
Execute function in 0x401000 address
instructions
Function Return
121
12I
Function Returns
instructions
Compare
cmp
cmp rax, rbx
Changing the flag acconding to the resalt of
instructions
comparing rax and rbx.
Unconditional
duf
jmp 0x401000
Jump to address 0x401000
Stack operation
jump command
push
push rax
Push the value of rax into the stack
instructions
dod
pop rax
Pop an element from the stack into rax.
based on semantics and optimization, for CTF participants, only a little understand-
ing is needed.
2. x86/x64 assembly language
pe [au sasenue quasse 9x9gx 1og sais umedsp om ae a
AT&:T, and this chapter will use the Intel style.
What is machine code? What is assembly language? Machine code is a binary
instruction executed directly on the CPU, while assembly language is a human
readable form for machine code, and assembly language and machine code are
one-to-one correspondence. The machine code depending on the CPU architecture,
and the most common CPU architectures used in CTF are x86 and x86-64 (x64).
The basic format of the x86/x64 assembly instructions is as follows.
Operation code [operand 1][operand 2]
In particular, the existence and form of operands are determined by the type of
opcode. Due to space limitations, it is not possible describe the format and function
of all kinds of instructions in this section. Table 5.2 gives the form, function, and
corresponding high-level language of several common instructions. CTF partici-
pants at the introductory level do not need to know how to write assembly language
---
## Page 314
300
5 Reverse Engineering
Table 5.3
Co
Full name
cmp a, b conditions
Flag
Operations
condition
jz/je
jump if zero/equal
a = b
ZF  1
jnz/jne
jump if not zero/equal
a ! = b
ZF  0
jb/jnae/jc
 jump if below/not above or equal/carry
a  b, unsigned nur
jump if not above/below or equal
abers
 jna/jbe
a = b, unsigned
numbers
0 = d
equal
a > b, signed numbers
numbers
jg/jnle
jump if greater/not less or equal
Jgefjol
jump if greater or equal/not less
a >= b, signed numbers
j/jnge
jump if less/not greater or equal
a < b, signed numbers
jle/jng
jump if less or equal/not greater
a <= b, signed numbers
JO
jump if overlow
OF = 1
jump if signed
SF = 1
programs fluently; they only need to know the common instructions described below
and be able to read them when they encounter them.
There are many conditional jump instructions in assembly language, and they
jump conditionally depending on the flags. The conditional jump instructions are
often preceded by a cmp instruction for comparison, which sets the flags accordingly
(with the same effect on the flags as a sub instruction).
Table 5.3 gives a list of common conditional jump instructions with the cmp
instruction and the flags they are based on.
3. disassembly
While high-level languages often require complex compilation processes, the assem-
bler simply translates the assembly statements into the corresponding machine code
and places the code directly to each other. Therefore, we can easily translate the
machine code back to the assembly language, and such a process is called
ssstes
As mentioned in Sect. 5.1.2, the compilation process also suffers from informa-
tion loss. While we can easily parse and restore the contents of a given instruction,
we must know which data is machine code in order to parse it accordingly. The von
Neumann architecture blurs the distinction between code and data, and may jump
tables, constant pool (ARMs), common constants, and even malicious interfering
data in code sections. So, parsing the instructions simply and directly is often got
trouble. We need to know the correct starting position of the instruction (for
example, label, which is a location in the program that can be easily referenced
when jumping, addressing) to guide the disassembly tool to parse the code correctly.
As mentioned earlier, during the assembly process, the label information is lost.
Because the label is used to identify the jump position, it determines where the
---
## Page 315
5.1 Basics of Reverse Engineering
fore, it is crucial to restore the correct label information to restore the program
s e o s  s x o
execution flow.
Despite the loss of information, we can still successfully restore the flow of the
the linear scan disassembly algorithm and the recursive descent disassembly
program through several algorithms. Two known algorithms are described below:
algorithm.
The linear scan disassembly algorithm is simple and brutal, parsing instructions
eapep ou pu o n as apo  o uq  o ao q o
is that once data is inserted into the code segment, allsubsequent disassembly results
are erroneous and useless.
the problems with linear scan disassembly algorithms. Instead of simply parsing
The recursive descent disassembly algorithm is a new algorithm after discovering
ox m od  mod o sde   edsp pe so
will be executed directly. An unconditional jump instruction will jump mediately
after each instruction. For example, after a normal instruction executed, the next one
to the target position, a function call instruction will jump out temporarily and then
return to continue execution, a return instruction will terminate the current execution
difrent conditions. The algorithm fist matches some known pattems to the starting
process, and a conditional jump instruction may jump to two different positions with
position, then tracks the execution of the program one by one according to the
execution patterns of the instructions, and finally disassembles the program
completely.
4. invoking conventions
If each developer uses different rules to pass function arguments, the program will
scontain unthinkable errors and the maintenance expense will be extremely high. For
this reason, after the advent of compilers, several conventions have been created for
compilers that specify the parameters to be passed between functions, called call
conventions. The following are some common calling conventions.
(1) Calling conventions for x86 32-bit architecture
_cdecl: arguments are push into the stack from right to left, and the caller is
responsible for cleaning up the pressed arguments and placing the retum
value in the EAX when the call is complete. This convention is used by most
C programs on x86 platforms.
_stdcall: arguments are also push into the stack from right to left, and the
Ieo au oye suaunre passaud oq dn Suqueao roj aqrsuodsau st Kued poe
is made, with the retum value also placed in the EAX.
_thiscall: an invocation convention optimized specifically for class methods
that places the “this” pointer to the class method in the ECX register and then
push the rest of the parameters into the stack.
 fastcall: a call convention created to speed up calls by putting the first
argument in ECX, the second in EDX, and then push the subsequent argu-
ments into the stack from right to left.
---
## Page 316
302
5 Reverse Engineering
Fig, 5.2 A region of local
variables
Local Variables
Function 4
Back to address
Parameter
Local Variables
Functien 3
Back to address
Parameter
Local Variables
Function 2
Back to address
Parameter
Local Variables
Function 1
Back to address
Parameter
(2) Call conventions for x86 64-bit architecture
•Microsoft x64-bit (x86-64) call convention: Used on Windows, the first four
parameters are placed into the RCX, RDX, R8 and R9 registers, and then push
remaining parameters into the stack from right to left.
• SystemV x64 invocation conventions: Used on Linux and MacOS, two more