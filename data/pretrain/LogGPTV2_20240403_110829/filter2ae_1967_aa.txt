本文来源：[长亭技术专栏](https://zhuanlan.zhihu.com/p/25892385)  
作者：[ **Jwizard**](https://www.zhihu.com/people/Jwizard)
接上篇：[手把手教你栈溢出从入门到放弃（上）](http://paper.seebug.org/271)
## **_0x00_ 写在前面**
首先还是广播一下2017 Pwn2Own
大赛的最终赛果，本次比赛共发现51个漏洞，长亭安全实验室贡献11个，以积26分的总成绩，在11支参赛团队中名列第三！同时，也祝贺国内的安全团队包揽本次大赛的前三名！
## **_0x10_ 上期回顾**
上篇文章介绍了栈溢出的原理和两种执行方法，两种方法都是通过覆盖返回地址来执行输入的指令片段（shellcode）或者动态库中的函数（return2libc）。本篇会继续介绍另外两种实现方法。一种是覆盖返回地址来执行内存内已有的代码片段（ROP），另一种是将某个函数的地址替换成另一个函数的地址（hijack
GOT）。
## **_0x20_ 相关知识**
## _0x21_ 寄存器
在上篇的背景知识中，我们提到了函数状态相关的三个寄存器－－esp，ebp，eip。下面的内容会涉及更多的寄存器，所以我们大致介绍下寄存器在执行程序指令中的不同用途。
32位x86架构下的寄存器可以被简单分为 **通用寄存器** 和 **特殊寄存器**
两类，通用寄存器在大部分汇编指令下是可以任意使用的（虽然有些指令规定了某些寄存器的特定用途），而特殊寄存器只能被特定的汇编指令使用，不能用来任意存储数据。
32位x86架构下的通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）。
一般寄存器用来存储运行时数据，是指令最常用到的寄存器，除了存放一般性的数据，每个一般寄存器都有自己较为固定的独特用途。eax 被称为累加寄存器（ **A**
ccumulator），用以进行算数运算和返回函数结果等。ebx 被称为基址寄存器（ **B**
ase），在内存寻址时（比如数组运算）用以存放基地址。ecx 被称为记数寄存器（ **C** ounter），用以在循环过程中记数。edx
被称为数据寄存器（ **D** ata），常配合 eax 一起存放运算结果等数据。
索引寄存器通常用于字符串操作中，esi 指向要处理的数据地址（ **S** ource **I** ndex），edi 指向存放处理结果的数据地址（
**D** estination **I** ndex）。
堆栈指针寄存器（esp、ebp）用于保存函数在调用栈中的状态，上篇已有详细的介绍。
32位x86架构下的特殊寄存器包括段地址寄存器（ss、cs、ds、es、fs、gs），标志位寄存器（EFLAGS），以及指令指针寄存器（eip）。
现代操作系统内存通常是以分段的形式存放不同类型的信息的。我们在上篇谈及的函数调用栈就是分段的一个部分（Stack
Segment）。内存分段还包括堆（Heap Segment）、数据段（Data Segment），BSS段，以及代码段（Code
Segment）。代码段存储可执行代码和只读常量（如常量字符串），属性可读可执行，但通常不可写。数据段存储已经初始化且初值不为0的全局变量和静态局部变量，BSS段存储未初始化或初值为0的全局变量和静态局部变量，这两段数据都有可写的属性。堆用于存放程序运行中动态分配的内存，例如C语言中的
malloc() 和 free() 函数就是在堆上分配和释放内存。各段在内存的排列如下图所示。
**Fig1. 内存分段的典型布局**
段地址寄存器就是用来存储内存分段地址的，其中寄存器 ss 存储函数调用栈（ **S** tack **S** egment）的地址，寄存器 cs
存储代码段（ **C** ode **S** egment）的地址，寄存器 ds 存储数据段（ **D** ata **S**
egment）的地址，es、fs、gs 是附加的存储数据段地址的寄存器。
标志位寄存器（EFLAGS）32位中的大部分被用于标志数据或程序的状态，例如 OF（ **O** verflow **F** lag）对应数值溢出、IF（
**I** nterrupt **F** lag）对应中断、ZF（ **Z** ero **F** lag）对应运算结果为0、CF（ **C** arry
**F** lag）对应运算产生进位等等。
指令指针寄存器（eip）存储下一条运行指令的地址，上篇已有详细的介绍。
## _0x22_ 汇编指令
为了更好地理解后面的内容，一点点汇编语言的知识也是必要的，本节会介绍一些基础指令的含义。32位x86架构下的汇编语言有 Intel 和 AT&T
两种格式，本文所用汇编指令都是 Intel 格式。两者最主要的差别如下。
Intel 格式，寄存器名称和数值前无符号：
> _“指令名称 目标操作数 DST，源操作数 SRC”_
AT&T 格式，寄存器名称前加“%”，数值前加“$”：
> _“指令名称 源操作数 SRC，目标操作数 DST”_
一些最常用的汇编指令如下：
  * MOV：数据传输指令，将 SRC 传至 DST，格式为
    MOV DST, SRC;
  * PUSH：压入堆栈指令，将 SRC 压入栈内，格式为
    PUSH SRC;
  * POP：弹出堆栈指令，将栈顶的数据弹出并存至 DST，格式为
    POP DST;
  * LEA：取地址指令，将 MEM 的地址存至 REG ，格式为
    LEA REG, MEM;
  * ADD／SUB：加／减法指令，将运算结果存至 DST，格式为
    ADD/SUB DST, SRC;
  * AND／OR／XOR：按位与／或／异或，将运算结果存至 DST ，格式为
    AND/OR/XOR DST，SRC;
  * CALL：调用指令，将当前的 eip 压入栈顶，并将 PTR 存入 eip，格式为
    CALL PTR;
  * RET：返回指令，操作为将栈顶数据弹出至 eip，格式为
    RET;
介绍完以上背景知识，就可以继续栈溢出技术之路了。
## **_0x30_ ROP ( Return Oriented Programming )**
_－－修改返回地址，让其指向内存中已有的一段指令_
根据上面副标题的说明，要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。可是既然可以覆盖返回地址并定位到内存地址，为什么不直接用上篇提到的
return2libc
呢？因为有时目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配。这时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。假如要执行某段指令（我们将其称为“gadget”，意为小工具），溢出数据应该以下面的方式构造（padding
长度和内容的确定方式参见上篇）：
> **payload :** padding + address of gadget
**Fig 2. 包含单个 gadget 的溢出数据**
如果想连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。所以 gadget 的最后一步应该是 RET
指令，这样程序的控制权（eip）才能得到切换，所以这种技术被称为返回导向编程( **R** eturn **O** riented **P**
rogramming )。要执行多个 gadget，溢出数据应该以下面的方式构造：
> **payload :** padding + address of gadget 1 + address of gadget 2 + ......
> \+ address of gadget n
在这样的构造下，被调用函数返回时会跳转执行 gadget 1，执行完毕时 gadget 1 的 RET 指令会将此时的栈顶数据（也就是 gadget 2
的地址）弹出至 eip，程序继续跳转执行 gadget 2，以此类推。
**Fig 3. 包含多个 gadget 的溢出数据**
现在任务可以分解为：针对程序栈溢出所要实现的效果，找到若干段以 ret
作为结束的指令片段，按照上述的构造将它们的地址填充到溢出数据中。所以我们要解决以下几个问题。
首先，栈溢出之后要实现什么效果？
ROP 常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是 int 0x80。执行这条指令时，被调用函数的编号应存入
eax，调用参数应按顺序存入 ebx，ecx，edx，esi，edi 中。例如，编号125对应函数
    mprotect (void *addr, size_t len, int prot)
，可用该函数将栈的属性改为可执行，这样就可以使用 shellcode 了。假如我们想利用系统调用执行这个函数，eax、ebx、ecx、edx
应该分别为“125”、内存栈的分段地址（可以通过调试工具确定）、“0x10000”（需要修改的空间长度，也许需要更长）、“7”（RWX 权限）。
其次，如何寻找对应的指令片段？
有若干开源工具可以实现搜索以 ret 结尾的指令片段，著名的包括 **ROPgadget** 、 **rp++** 、 **ropeme**
等，甚至也可以用 grep 等文本匹配工具在汇编指令中搜索 ret 再进一步筛选。搜索的详细过程在这里就不再赘述，有兴趣的同学可以参考上述工具的说明文档。
最后，如何传入系统调用的参数？
对于上面提到的 mprotect 函数，我们需要将参数传输至寄存器，所以可以用 pop 指令将栈顶数据弹入寄存器。如果在内存中能找到直接可用的数据，也可以用
mov 指令来进行传输，不过写入数据再 pop 要比先搜索再 mov 来的简单，对吧？如果要用 pop
指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。对于单个 gadget，pop 所传输的数据应该在 gadget
地址之后，如下图所示。
**Fig 4. gadget “pop eax; ret;”**
在调用 mprotect() 为栈开启可执行权限之后，我们希望执行一段 shellcode，所以要将 shellcode 也加入溢出数据，并将