# 【漏洞分析】11月4日：深入解读脏牛Linux本地提权漏洞（CVE-2016-5195）
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
****
**作者：**[ **elemeta**](http://bobao.360.cn/member/contribute?uid=52377967)
**稿费：600RMB（不服你也来投稿啊！）**
**投稿方式：发送邮件至linwei#360.cn，或登陆 ** ** **[
**网页版**](http://bobao.360.cn/contribute/index)****** 在线投稿**
**0x00 概述**
该漏洞是Linux的一个本地提权漏洞，发现者是Phil
Oester，影响>=2.6.22的所有Linux内核版本，修复时间是2016年10月18号。该漏洞的原因是get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。当我们向带有MAP_PRIVATE标记的只读文件映射区域写数据时，会产生一个映射文件的复制(COW)，对此区域的任何修改都不会写回原来的文件，如果上述的竞态条件发生，就能成功的写回原来的文件。比如我们修改su或者passwd程序就可以达到root的目的。
**0x01 POC分析**
POC的地址如下：[[https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c]](https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c),
下面是POC关键部分的伪代码:
    Main:
        fd = open(filename, O_RDONLY)
        fstat(fd, &st)
        map = mmap(NULL, st.st_size , PROT_READ, MAP_PRIVATE, fd, 0)
        start Thread1
        start Thread2
    Thread1：
        f = open("/proc/self/mem", O_RDWR)
        while (1):
            lseek(f, map, SEEK_SET)
            write(f, shellcode, strlen(shellcode))
    Thread2：
        while (1):
            madvise(map, 100, MADV_DONTNEED)
首先打开我们需要修改的只读文件并使用MAP_PRIVATE标记映射文件到内存区域，然后启动两个线程：
其中一个线程向文件映射的内存区域写数据，这时内核采用COW机制。
另一个线程使用带MADV_DONTNEED参数的madvise系统调用将文件映射内存区域释放，达到干扰另一个线程的COW过程，产生竞态条件，当竞态条件发生时就能写入文件成功。
还有一种方法：使用ptrace系统调用的PTRACE_POKETEXT参数来写文件映射的内存区域，参考见[[https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c]](https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c)。
**0x02 漏洞原理分析**
先附上一份[[https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails]](https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails)中的源代码分析结果：
    faultin_page
      handle_mm_fault
        __handle_mm_fault
          handle_pte_fault
            do_fault vm_flags & VM_WRITE))  different thread will now unmap via madvise
    follow_page_mask
      !pte_present && pte_none
    faultin_page
      handle_mm_fault
        __handle_mm_fault
          handle_pte_fault
            do_fault vm_ops || !vma->vm_ops->fault))
            return ERR_PTR(-EFAULT);
        return NULL;
    }
faultin_page
该函数完成follow_page_mask找不到page的处理。第一次查找时页还不在内存中，首先设置FAULT_FLAG_WRITE标记，然后沿着handle_mm_fault
-> __handle_mm_fault -> handle_pte_fault -> do_fault -> do_cow_fault分配页。
    static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,
        unsigned long address, unsigned int *flags, int *nonblocking)
    {
        struct mm_struct *mm = vma->vm_mm;
        if (*flags & FOLL_WRITE)
            fault_flags |= FAULT_FLAG_WRITE; /* 标记失败的原因 WRITE */
        ...
        ret = handle_mm_fault(mm, vma, address, fault_flags); /* 第一次分配page并返回 0 */
        ...
        return 0;
    }
    static int handle_pte_fault(struct mm_struct *mm,
             struct vm_area_struct *vma, unsigned long address,
             pte_t *pte, pmd_t *pmd, unsigned int flags)
    {
        if (!pte_present(entry))
            if (pte_none(entry))
                return do_fault(mm, vma, address, pte, pmd, flags, entry); /* page不在内存中，调页 */
    }
    static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
        unsigned long address, pte_t *page_table, pmd_t *pmd,
        unsigned int flags, pte_t orig_pte)
    {
        if (!(vma->vm_flags & VM_SHARED)) /* VM_PRIVATE模式，使用写时复制(COW)分配页 */
            return do_cow_fault(mm, vma, address, pmd, pgoff, flags,
                    orig_pte);
    }
    static int do_cow_fault(struct mm_struct *mm, struct vm_area_struct *vma,
        unsigned long address, pmd_t *pmd,
        pgoff_t pgoff, unsigned int flags, pte_t orig_pte)
    {
        new_page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma, address); /* 分配一个page */
        ret = __do_fault(vma, address, pgoff, flags, new_page, &fault_page,
             &fault_entry);
        do_set_pte(vma, address, new_page, pte, true, true); /* 设置new_page的PTE */
    }
    static int __do_fault(struct vm_area_struct *vma, unsigned long address,
            pgoff_t pgoff, unsigned int flags,
            struct page *cow_page, struct page **page,
            void **entry)
    {
        ret = vma->vm_ops->fault(vma, &vmf);
    }
    void do_set_pte(struct vm_area_struct *vma, unsigned long address,
        struct page *page, pte_t *pte, bool write, bool anon)
    {
        pte_t entry;
        flush_icache_page(vma, page);
        entry = mk_pte(page, vma->vm_page_prot);
        if (write)
            entry = maybe_mkwrite(pte_mkdirty(entry), vma); /* 带_RW_DIRTY,不带_PAGE_RW */
        if (anon) { /* anon = 1 */
            page_add_new_anon_rmap(page, vma, address, false);
        } else {