For a piece of code at work, we had a set of tasks that are essentially
wrappers around a function. Originally each function was implemented
independently. To reduce code duplication, I tried to make a higher order
function that would take in the wrapped function (`ship_function`) and return
a task that called it and did the other boilerplate code. This code is below:
    def make_ship_function(ship_function, shipment_type_name, task_name):
        @task(ignore_result=True, name=__name__ + "." + task_name)
        @transaction.commit_manually
        def inner(oblpn_nbr, facility_code, company_code, user = None):
            try:
                if not CWLoginContext.user and user:
                    set_login_context_user(user)
                    set_facility_and_company(facility_code, company_code)
                (retval, msg) = ship_function(oblpn_nbr, facility_code, company_code)
                if not retval:
                    transaction.rollback()
                    cwlog.error('{0}.process_shipment_ws returned false: {1}'.format(shipment_type_name, msg))
                    CWLoginContext.user = None
                    raise Exception(msg)
                transaction.commit()
                CWLoginContext.user = None
                return True, None
            except Exception, e:
                transaction.rollback()
                if connection.queries: cwlog.error(connection.queries[-1])
                cwlog.error('Exception in {0}.process_shipment_ws: {1}'.format(shipment_type_name, e))
                CWLoginContext.user = None
                raise e
        return inner
This code does not work properly. Even though in the task decorator, I specify
the name of the task, all tasks generated by make_ship_function will all have
the same name, inner. This goes against my expectations gotten from reading
the docs here:
http://celery.readthedocs.org/en/latest/userguide/tasks.html#names .