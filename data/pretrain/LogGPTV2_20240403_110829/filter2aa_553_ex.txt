指数 = 5，有效数 = .00318（.00318E5）
显而易见，第1种方法精度最高，因为在有效数中使用了所有的5位可用
位。规范化浮点非零值是第1位有效位为非零的值，这也是通常储存浮点数
的方式。
现在，假设最小指数（FLT_MIN_EXP）是-10，那么最小的规范值是：
指数 = -10，有效数 = .10000（.10000E-10）
通常，乘以或除以10意味着使指数增大或减小，但是在这种情况下，如
果除以10，却无法再减小指数。但是，可以改变有效数获得这种表示：
指数 = -10，有效数 = .01000（.01000E-10）
这个数被称为低于正常的（subnormal），因为该数并未使用有效数的
全精度。例如，0.12343E-10除以10得.01234E-10，损失了一位的信息。
对于这个特例，0.1000E-10 是最小的非零正常值（FLT_MIN），最小的
非零低于正常值是0.00001E-10（FLT_TRUE_MIN）。
1616
float.h中的宏FLT_HAS_SUBNURM、DBL_HAS_SUBNORM和
LDBL_HAS_SUBNORM表征实现如何处理低于正常的值。下面是这些宏可
能会用到的值及其含义：
-1   不确定（尚未统一）
0    不存在（例如，实现可能会用0替换低于正常的值）
1    存在
math.h库提供一些方法，包括fpclassify()和isnormal()宏，可以识别程序
何时生成低于正常的值，这样会损失一些精度。
3.求值方案
float.h 中的宏 FLT_EVAL_METHOD 确定了实现采用何种浮点表达式的
求值方案，如下所示（有些实现还会提供其他负值选项）。
-1    不确定
0    对在所有浮点类型范围和精度内的操作、常量求值
1    对在 double 类型的精度内和 float、double 类型的范围内的操
作、常量求值，对
longdouble范围内的long double类型的操作、常量求值
2    对所有浮点类型范围内和long 
double类型精度内的操作和常
量求值
例如，假设程序中要把两个float类型的值相乘，并把乘积赋给第3个
float类型变量。对于选项1（即K&R 
C采用的方案），这两个float类型的值
将被扩展为double类型，使用double类型完成乘法计算，然后在赋值计算结
果时再把乘积转为float类型。
1617
如果选择0（即ANSI C采用的方案），实现将直接使用这两个float类型
的值相乘，然后赋值乘积。这样做比选项1快，但是会稍微损失一点精度。
4.舍入
float.h中的宏FLT_ROUNDS确定了系统如何处理舍入，其指定值所对应
的舍入方案如下所示。
-1   不确定
0    趋零截断
1    舍入到最接近的值
2    趋向正无穷
3    趋向负无穷
系统可以定义其他值，对应其他舍入方案。
一些系统提供控制舍入的方案，在这种情况下，fenv.h中的festround()函
数提供编程控制。
如果只是计算制作37个蛋糕需要多少面粉，这些不同的舍入方案可能并
不重要，但是对于金融和科学计算而言，这很重要。显然，把较高精度的浮
点值转换成较低精度值时需要使用舍入方案。例如，把double类型的计算结
果赋给float类型的变量。另外，在改变进制时，也会用到舍入方案。不同进
制下精确表示的分数不同。例如，考虑下面的代码：
float x = 0.8;
在十进制下，8/10或4/5都可以精确表示0.8。但是大部分计算机系统都
以二进制储存结果，在二进制下，4/5表示为一个无限循环小数：
0.1100110011001100...
1618
因此，在把0.8储存在x中时，将其舍入为一个近似值，其具体值取决于
使用的舍入方案。
尽管如此，有些实现可能不满足 IEC 60559 的要求。例如，底层硬件可
能无法满足要求。因此，C99定义了两个可用作预处理器指令的宏，检查实
现是否符合规范。第 1 个宏是_ _STDC_IEC_559_ _，如果实现遵循IEC
60559浮点规范，该宏被定义为常量1。第2个宏是_
_STDC_IEC_559_COMPLEX_ _，如果实现遵循IEC 60559兼容复数运算，该
宏被定义为常量1。
如果实现中未定义这两个宏，则不能保证遵循IEC 60559。
B.8.2 fenv.h头文件
fenv.h 头文件提供一些与浮点环境交互的方法。也就是说，允许用户设
置浮点控制模式值（该值管理如何执行浮点运算）并确定浮点状态标志（或
异常）的值（报告运算效果的信息）。例如，控制模式设置可指定舍入的方
案；如果运算出现浮点溢出则设置一个状态标志。设置状态标志的操作叫作
抛出异常。
状态标志和控制模式只有在硬件支持的前提下才能发挥作用。例如，如
果硬件没有这些选项，则无法更改舍入方案。
使用下面的编译指示开启支持：
#pragma STDC FENV_ACCESS ON
这意味着程序到包含该编译指示的块末尾一直支持，或者如果该编译指
示是外部的，则支持到该文件或翻译单元的末尾。使用下面的编译指示关闭
支持：
#pragma STDC FENV_ACCESS OFF
使用下面的编译指示可恢复编译器的默认设置，具体设置取决于实现：
1619
#pragma STDC FENV_ACCESS DEFAULT
如果涉及关键的浮点运算，这个功能非常重要。但是，一般用户使用的
程度有限，所以本附录不再深入讨论。
B.8.3 STDC FP_CONTRACT编译指示
一些浮点数处理器可以把有多个运算符的浮点表达式合并成一个运算。
例如，处理器只需一步就求出下面表达式的值：
x*y - z
这加快了运算速度，但是减少了运算的可预测性。STDC
FP_CONTRACT 
编译指示允许用户开启或关闭这个特性。默认状态取决于
实现。
为特定运算关闭合并特性，然后再开启，可以这样做：
#pragma STDC FP_CONTRACT OFF
val = x * y - z;
#pragma STDC FP_CONTRACT ON
B.8.4 math.h库增补
大部分C90数学库中都声明了double类型参数和double类型返回值的函
数，例如：
double sin(double);
double sqrt(double);
C99和C11库为所有这些函数都提供了float类型和long 
double类型的函
数。这些函数的名称由原来函数名加上f或l后缀构成，例如：
1620
float sinf(float);        /* sin()的float版本 */
long double sinl(long double);   /* sin()的long double版本 */
有了这些不同精度的函数系列，用户可以根据具体情况选择最效率的类
型和函数组合。
C99还新增了一些科学、工程和数学运算中常用的函数。表B.5.16列出
了所有数学函数的double版本。在许多情况下，这些函数的返回值都可以使
用现有的函数计算得出，但是新函数计算得更快更精确。例如，loglp(x)表
示的值与与log(1 + x)相同，但是loglp(x)使用了不同的算法，对于较小的x值
而言计算更精确。因此，可以使用log()函数作普通运算，但是对于精确要求
较高且x值较小时，用loglp()函数更好。
除这些函数以外，数学库中还定义了一些常量和与数字分类、舍入相关
的函数。例如，可以把值分为无穷值、非数（NaN）、正常值、低于正常的
值、真零。[NaN是一个特别的值，用于表示一个不是数的值。例如，
asin(2.0)返回NaN，因为定义了asin()函数的参数必须是-1～1范围内的值。
低于正常的值是比使用全精度表示的最小值还要小的数。]还有一些专用的
比较函数，如果一个或多个参数是非正常值时，函数的行为与标准的关系运
算符不同。
使用C99的分类方案可以检测计算的规律性。例如，math.h中的
isnormal()宏，如果其参数是一个正常的数，则返回真。下面的代码使用该
宏在num不正常时结束循环：
#include    // 为了使用isnormal()
...
float num = 1.7e-19;
float numprev = num;
1621
while (isnormal(num)) // 当num为全精度的float类型值
{
numprev = num;
num /= 13.7f;
}
简而言之，数学库为更好地控制如何计算浮点数，提供了扩展支持。
B.8.5 对复数的支持
复数是有实部和虚部的数。实部是普通的实数，如浮点类型表示的数。
虚部表示一个虚数。虚数是-1的平方根的倍数。在数学中，复数通常写作类
似4.2 + 2.0i的形式，其中i表示-1的平方根。
C99支持3种复数类型（在C11中为可选）：
float _Complex
double _Complex
long double _Compplex
例如，储存float _Complex类型的值时，使用与两个float类型元素的数组
相同的内存布局，实部值储存在第1个元素中，虚部值储存在第2个元素中。
C99和C11还支持下面3种虚类型：
float _Imaginary
double _Imaginary
long double _Imaginary
1622
包含了complex.h头文件，就可以用complex代替_Complex，用imaginary
代替_Imaginary。
为复数类型定义的算术运算遵循一般的数学规则。例如，(a+b*I)*
(c+d*I)即是(a*c-b*d)+(b*c+a*d)*I。
complex.h头文件定义了一些宏和接受复数参数并返回复数的函数。特
别是，宏I表示-1的平方根。因此，可以编写这样的代码：
double complex c1 = 4.2 + 2.0 * I;
float imaginary c2= -3.0 * I;
C11提供了另一种方法，通过CMPLX()宏给复数赋值。例如，如果re和
im都是double类型的值，可以这样做：
double complex c3 = CMPLX(re, im);
这种方法的目的是，宏在处理不常见的情况（如，im是无穷大或非数）
时比直接赋值好。
complex.h头文件提供了一些复数函数的原型，其中许多复数函数都有
对应math.h中的函数，其函数名即是对应函数名前加上c前缀。例如，csin()
返回其复数参数的复正弦。其他函数与特定的复数特性相关。例如，creal()
函数返回一个复数的实部，cimag()函数返回一个复数的虚部。也就是说，
给定一个double conplex类型的z，下面的代码为真：
z = creal(z) + cimag(z) * I;
如果熟悉复数，需要使用复数，请详细阅读complex.h中的内容。
下面的示例演示了对复数的一些支持：
// complex.c -- 复数
1623
#include 
#include 
void show_cmlx(complex double cv);
int main(void)
{
complex double v1 = 4.0 + 3.0*I;
double re, im;
complex double v2;
complex double sum, prod, conjug;
printf("Enter the real part of a complex number: ");
scanf("%lf", &re);
printf("Enter the imaginary part of a complex number: ");
scanf("%lf", &im);
// CMPLX()是C11中的一个特性
// v2 = CMPLX(re, im);
v2 = re + im * I;
printf("v1: ");
show_cmlx(v1);
putchar('\n');
1624
printf("v2: ");
show_cmlx(v2);
putchar('\n');
sum = v1 + v2;
prod = v1 * v2;
conjug =conj(v1);
printf("sum: ");
show_cmlx(sum);
putchar('\n');
printf("product: ");
show_cmlx(prod);
putchar('\n');
printf("complex congjugate of v1: ");
show_cmlx(conjug);
putchar('\n');
return 0;
}
void show_cmlx(complex double cv)
{
1625
printf("(%.2f, %.2fi)", creal(cv), cimag(cv));
return;
}
如果使用C++，会发现C++的complex头文件提供一种基于类的方式处理
复数，这与C的complex.h头文件使用的方法不同。
1626
B.9 参考资料IX：C和C++的区别
在很大程度上，C++是C的超集，这意味着一个有效的C程序也是一个
有效的C++程序。C和C++的主要区别是，C++支持许多附加特性。但是，
C++中有许多规则与 C 稍有不同。这些不同使得 C 程序作为C++程序编译时
可能以不同的方式运行或根本不能运行。本节着重讨论这些区别。如果使用
C++的编译器编译C程序，就知道这些不同之处。虽然C和C++的区别对本书
的示例影响很小，但如果把C代码作为C++程序编译的话，会导致产生错误
的消息。
C99标准的发布使得问题更加复杂，因为有些情况下使得C更接近
C++。例如，C99标准允许在代码中的任意处进行声明，而且可以识别//注释
指示符。在其他方面，C99使其与C++的差异变大。例如，新增了变长数组
和关键字restrict。C11缩小了与C++的差异。例如，引进了char16_t类型，新
增了关键字_Alignas，新增了alignas宏与C++的关键字匹配。C11仍处于起步
阶段，许多编译器开发商甚至都没有完全支持C99。我们要了解C90、C99、
C11之间的区别，还要了解C++11与这些标准之间的区别，以及每个标准与C
标准之间的区别。这部分主要讨论C99、C11和C++之间的区别。当然，
C++也正在发展，因此，C和C++的异同也在不断变化。
B.9.1 函数原型
在C++中，函数原型必不可少，但是在C中是可选的。这一区别在声明
一个函数时让函数名后面的圆括号为空，就可以看出来。在C中，空圆括号
说明这是前置原型，但是在C++中则说明该函数没有参数。也就是说，在
C++中，int slice();和int slice(void);相同。例如，下面旧风格的代码在C中可
以接受，但是在C++中会产生错误：
int slice();
int main()
{
1627
...
slice(20, 50);