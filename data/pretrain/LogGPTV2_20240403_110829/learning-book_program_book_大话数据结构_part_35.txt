第7章图
A
F
G
H
H
D
G
D
D
E
图7-5-2
很显然我们是需要策略的，否则在这四通八达的通道中乱窜，要想完成任务那就
只能是碰运气。如果你学过深度优先遍历，这个任务就不难完成了。
首先我们从顶点A开始，做上表示走过的记号后，面前有两条路，通向B和F，
我们给自已定一个原则，在没有碰到重复顶点的情况下，始终是向右手边走，于是走
到了B顶点。整个行路过程，可参看图7-5-2的右图。此时发现有三条分支，分别通
向顶点C、1、G，右手通行原则，使得我们走到了C顶点。就这样，我们一直顺着右
手通道走，一直走到F顶点。当我们依然选择右手通道走过去后，发现走回到顶点A
了，因为在这里做了记号表示已经走过。此时我们退回到顶点F，走向从右数的第二
条通道，到了G顶点，它有三条通道，发现B和D都已经是走过的，于是走到H，当
我们面对通向H的两条通道D和E时，会发现都已经走过了。
此时我们是否已经遍历了所有顶点呢？没有。可能还有很多分支的顶点我们没有
走到，所以我们按原路返回。在顶点H处，再无通道没走过，返回到G，也无未走过
通道，返回到F，没有通道，返回到E，有一条通道通往H的通道，验证后也是走过
的，再返回到顶点D，此时还有三条道未走过，一条条来，H走过了，G走过了，1，
哦，这是一个新顶点，没有标记，赶快记下来。继续返回，直到返回顶点A，确认你
239
---
## Page 264
大据数据结构
已经完成遍历任务，找到了所有的9个顶点。
反应快的同学一定会感觉到，深度优先遍历其实就是一个递归的过程，如果再敏
感一些，会发现其实转换成如图7-5-2的右图后，就像是一棵树的前序遍历，没错，
它就是。它从图中某个顶点V出发，访问此顶点，然后从v的未被访问的邻接点出发
深度优先遍历图，直至图中所有和V有路径相通的顶点都被访问到。事实上，我们
这里讲到的是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍
历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另
选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问
到为止。
如果我们用的是邻接矩阵的方式，则代码如下：
/Boolean是布尔类型，其值是TRUE成FALSE*/
Boolean visited[MAx];
/访问标志的数组/
1·邻接矩阵的深度优先递归算法/
void DFs（MGraph G,int 1)
intj;
printf（“ac”，G.vexs[i]）：/打印顶点，电可以其他操作*
for（-0;jadjLiat[i].data）：/·打印项点，也可以其他操作·/
p=GL->adjList[i].firstedge;
while（p)
if(!visited[p->adjvex])
DFS（GL，p->adjvex）：/*对为访网的邻接项点递归调用*
xeunumVertexes;i++）
visited[1]-FALSE；/初始所有项点状态都是未访问过状态*/
for（i=0;inumVertexes;i++)
if（Ivisited[i]）/*对未访间过的项点调用DES，若是连通图，只会执行一次·/
DFS（GL,1）;
对比两个不同存储结构的深度优先遍历算法，对于个顶点e条边的图来说，邻
接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此
都需要0（n2）的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边
的数量，所以是0（n+e）。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时
间效率上大大提高。
对于有向图而言，由于它只是对通道存在可行或不可行，算法上没有变化，是完
全可以通用的。这里就不再详述了。
241
---
## Page 266
大调数据结构
7.5.2广度优先遍历
广度优先遍历（Breadth_FirstSearch），又称为广度优先搜索，简称BFS。还是以
找钥匙的例子为侧。小孩子不太可能把钥匙丢到大衣柜顶上或厨房的油烟机里去，深
度优先遍历意味着要彻底查找完一个房间才查找下一个房间，这未必是最佳方案。所
以不妨先把家里的所有房间简单看一遍，看看钥匙是不是就放在很显眼的位置，如果
全走一遍没有，再把小孩在每个房间玩得最多的地方或各个家俱的下面找一找，如果
还是没有，那看一下每个房间的抽屉，这样一步步扩大查找的范围，直到找到为止。
事实上，我在全屋查找的第二遍时就在抽水马桶后面的地板上找到了。
如果说图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树
的层序遍历了。我们将图7-5-3的第一幅图稍微变形，变形原则是顶点A放置在最上
第一层，让与它有边的顶点B、F为第二层，再让与B和F有边的顶点C、I、G、E
为第三层，再将这四个顶点有边的D、H放在第四层，如图7-5-3的第二幅图所示。
此时在视觉上感觉图的形状发生了变化，其实顶点和边的关系还是完全相同的。
A)
B
F
G
D
H
出队列
入队列
①
②←
BF
③
④
③←
IGED
GED]
EDH
③←
DH
H
图7-5-3
242
---
## Page 267
第7章图
有了这个讲解，我们来看代码就非常容易了。以下是邻接矩阵结构的广度优先遍
历算法。
/邻接矩阵的广度遍历算法·/
void BFSTraverse(MGraph.G)
inti,;
0eneno
for（i=0；inumVertexes;i++）
visited[i]-FALSE;
InitQueue（sQ）;
for（1-0;1numVertexes;1++）
if（1visited[i])
visited[i]-TRUE;
printf（-c",GL->adjList[i].data）:/打印顶点，也可以其他操作
EnQueue（sQ,1）;
while（1QueueEmpty（Q）)
DeQueue（6Q,6i）;
P=GL->adjList[i].firstedge:/*我到当前项点边表链表头指针·/
while（p)
if(!visited[p->adjvex])
若此顶点来被访问·
1
（.[xadjvex）；/·将此顶点入队列·/
xau<-d-d
1指针指向下一个邻接点/
对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是
一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优
244
---
## Page 269
第7章图
劣之分的，只是视不同的情况选择不同的算法。
不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找
合适的顶点，那么选择哪种遍历就要仔细斟酌了。深度优先更适合目标比较明确，以
找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优
解的情况。
这里还要再多说几句，对于深度和广度而言，已经不是简单的算法实现问题，完
全可以上升到方法论的角度。你求学是博览群书、不求甚解，还是深钻细研、鞭辟入
里；你旅游是走马观花、蜻蜓点水，还是下马看花、深度体验；你交友是四海之内皆
兄弟，还是人生得一知己足矣其实都无对错之分，只视不同人的理解而有了不同
的诠释。我个人觉得深度和广度是既矛盾又统一的两个方面，偏颇都不可取，还望大
家自己慢慢体会。
7.6最小生成树
假设你是电信的实施工程师，需要为一个镇的九个村庄架设通信网络做设计，村
庄位置大致如图7-6-1，其中Vo~V是村庄，之间连线的数字表示村与村间的可通达
的直线距离，比如vo至v就是10公里（个别如vo与v6，V6与vg，vs与v未测算距
离是因为有高山或湖泊，不予考虑）。你们领导要求你必须用最小的成本完成这次任
务。你说怎么办？
V3
图 7-6-1
显然这是一个带权值的图，即网结构。所谓的最小成本，就是n个顶点，用n-1
条边把一个连通图连接起来，并且使得权值的和最小。在这个例子里，每多一公里就
多一份成本，所以只要让线路连线的公里数最少，就是最少成本了。
245
---
## Page 270
大调数据结构
如果你加班加点，没日没夜设计出的结果是如图7-6-2的方案一（粗线为要架设
线路），我想你离被炒航鱼应该是不远了（同学微笑）。因为这个方案比后两个方案多
出60%的成本会让老板气晕过去的。
19161+1+1+81+22+0+9+1
方案一
公里数-8+12+10+11+17+19+16+7=100
方案二
方案三
公里数=8+12+10+11+16+19+16+7=99
图7-6-2
方案三设计得非常巧妙，但也只以极其微弱的优势对方案二胜出，应该说很是饶
幸。我们有没有办法可以精确计算出这种网图的最佳方案呢？答案当然是Yes。
我们在讲图的定义和术语时，曾经提到过，一个连通图的生成树是一个极小的连
通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边。显然图7-6-2
的三个方案都是图7-6-1的网图的生成树。那么我们把构造连通网的最小代价生成树
称为最小生成树（MinimumCostSpanningTree）。
找连通网的最小生成树，经典的有两种算法，普里姆算法和克鲁斯卡尔算法。我
们就分别来介绍一下。
246
---
## Page 271
第7章图
7.6.1普里姆（Prim）算法