The majority of unique code per resource type in our `RESTStorage`
implementations deals with populating default values on an object and
validating the object prior to persistence. The other 99% of the code is
pretty common across all of our resource types and could be generalized. When
we look at our tests, the majority of our `rest_test.go` files are just
ensuring that validation occurs prior to create/update. There is a lot of
duplicate effort where we could just mandate that the framework that calls the
`RESTStorage` guarantees that the object is valid.
I would like to suggest that the `resthandler.go` logic enforces that prior to
calling a `RESTStorage` Create and Update operation, it makes a call to
something like the following:
    type Validator interface {
      // ValidateCreate will populate default values on the object, and ensure its valid for persistence
      ValidateCreate(ctx api.Context, obj runtime.Object) error
      // ValidateUpdate will validate the newObj and copy values required from oldObject prior to persistence
    ValidateUpdate(ctx api.Context, newObj runtime.Object, oldObj runtime.Object) error
    }
In addition, as we look to the future, there are some additional concepts that
I would like the `resthandler.go` to enforce uniformly across all resources
without adding more boilerplate into each `RESTStorage` implementation.
Specifically, I do not want to invoke any Admission control style logic for
invalid input, but I do not want to modify each `RESTStorage` implementation
to have to make an explicit call-out to perform admission control as it just
increases more boiler plate code.