for polymorph and CTree (with 0 detours). When sampling
rate is reduced to 30%, Table III shows that the number of
detours increases slightly for these two programs resulting in
a higher number of possible candidate paths. Figure 7 shows
the distribution of candidate path lengths, including minimum,
maximum and average number of nodes (path length) for
each target program’s candidate paths, which are generated by
joining the detours using heuristics explained in Section VI-B.
We observed that the ﬁrst generated candidate path at 30%
sampling for both polymorph and CTree has fewer nodes. For
example, the ﬁrst candidate path output under 100% sampling
for polymorph includes 10 nodes while the one under 30%
sampling only has 6 nodes. Interestingly, even with fewer
nodes in the ﬁrst candidate path, StatSym can successfully
ﬁnd the vulnerability in its ﬁrst iteration. Also, it is worth
noting that
that dominates runtime overhead,
varies across applications. At 30% sampling, for polymorph,
the program logs generated are very small that it takes less than
2.0 seconds for statistical method to construct candidate paths.
In this case, the statistics-guided symbolic executor dominates
the module,
Fig. 7: Statistics of candidate path lengths. The number below
each application name represents the total number of paths
generated by statistical analysis.
Log Collection and Sampling: Ideally, we need to collect a
large set of the user’s execution traces, and then randomly
sample them to assemble our sets of correct execution logs
and faulty execution logs. To emulate this scenario, we run
our application with a sufﬁciently large number of randomly
generated input sets that result in correct and faulty executions.
We collect logs of the target programs using the Program
Monitor described in Section VI-A. Each log ﬁle corresponds
to a program run and is annotated with a ﬂag indicating
whether it is from a correct or faulty execution. Among all of
the generated logs, we randomly choose one hundred correct
execution logs and one hundred faulty execution logs. In our
evaluation, we use partial, incomplete logging at the sample
rate of 30% and 100%. For polymorph and CTree, we also
select multiple levels of sampling ranging from 20% to 100%
for the sensitivity study in Section VII-C. Note that StatSym
is effective even at a relatively low sampling rate of 20%, as
will be shown later in Section VII-D.
Symbolic Execution: We use unmodiﬁed symbolic execution
on KLEE as the baseline for comparison. For StatSym,
we set the timeout for statistics-guided symbolic execution
to be 15 minutes for a given candidate path; we set
the
symbolic execution timeout length for KLEE to be 8 hours.
The default threshold value τ is set to 10 for all applications
(See Section V-C for details). For both StatSym and KLEE
to perform symbolic execution, proper conﬁguration of the
symbolic inputs in each program is required. Valid program
inputs typically follow certain format. For example, CTree
program requires the option of -n and -q. We note that, without
knowledge of the parameter format and option semantics,
050100150200Polymorph         (4)Ctree(4)thttpd(13)Grep(12)Maximum LengthAverage LengthMinimum Lengththe time (180.6s). On the contrary, for Grep, we observe that
its log size is large (hundreds of MB), the statistical analysis
takes much longer than symbolic execution. In Table IV, we
present the total amount of time (including statistical analysis
and symbolic execution) to identify the vulnerable path for
StatSym compared with the time taken for pure symbolic
exploration by KLEE. We observe that StatSym always
explores signiﬁcantly less number of paths and spends less
time than KLEE to ﬁnd the vulnerability in the program (on
average 85.3% fewer paths). Notably, even with signiﬁcantly
higher number of paths explored, for CTree and Grep, pure
symbolic execution by KLEE fails to ﬁnd the vulnerability
and reports state exploration failure due to lack of available
memory that stopped the constraint solver from forking more
processes. For the smallest program, polymorph, under 30%
sampling, it takes only 214.6 seconds to ﬁnd the vulnerability,
which is a 15 × speedup compared with pure symbolic
execution. Across all four programs, StatSym is able to
correctly discover the vulnerable paths and the corresponding
inputs with no false positives or false negatives. Moreover, the
vulnerable paths for three of the programs are identiﬁed using
the ﬁrst candidate path found by statistical analysis module
(see Section VII-C for details).
KLEE w/ StatSym Pure Sym. Exec. w/ KLEE
#paths
time(sec)
Benchmark
polymorph
CTree
thttpd
Grep
63
112
5168
11462
214.6
45.6
1691.0
563.0
#paths
8368
17575
17882
38708
time(sec)
3252.0
Failed
Failed
Failed
TABLE IV: Number of paths explored and time spent before
ﬁnding the bug in StatSym with KLEE and pure symbolic
execution by KLEE at 30% sampling rate.
C. Case Studies
1) Polymorph: Polymorph is a ﬁle name conversion utility.
Users of polymorph can provide either a ﬁle name or an
entire folder to polymorph for name conversion. Speciﬁcally,
user provides the option -f
together with a string as the
name of the targeted ﬁle for conversion. After parsing the
command line parameters,
the user provided string name
target is passed to function convert ﬁleName() as parameter
original. The vulnerability resides in convert ﬁleName() where
each character in target is read, transformed (if necessary)
and copied to the stack allocated 512-Byte buffer newName
without boundary check. convert ﬁleName() then performs a
series of system calls before it returns. The program will crash
if the stack is ﬁlled with an adversary’s payload.
With 30% sampling rate, there are 12 instrumented locations
denoted by L1∼L12 and 10 instrumented variables, shown in
Figure 8. Table V shows the top 10 predicates. The numbers
in third column of the table denote the instrumented location
index in Figure 8. We observe that the ﬁrst six predicates
limit the length of strings that implicitly depend on target.
When the user-provided ﬁle name is longer than 512 bytes,
Instrumented Locations:
L1: grok commandLine():leave
L3: is ﬁleHidden():leave
L5: does newnameExist():leave
L7: convert ﬁleName():leave
L9: does newnameExist():enter
L11: is ﬁleHidden():enter
Instrumented Variables:
GLOBAL: target, wd, hidden, track, clean, init ﬁle, hidden ﬁle
FUNCPARAM: argc, original, suspect
L2: convert ﬁleName():enter
L4: does nameHaveUppers():enter
L6: grok commandLine():enter
L8: main():enter
L10: main():leave
L12: does nameHaveUppers():leave
Fig. 8: Instrumented locations and variables in Polymorph
No.
P1
P2
P3
P4
P5
P6
P7
P8
P9
P10
Predicate
len(suspect FUNCPARAM) >536.5
len(original FUNCPARAM)>518.0
len(suspect FUNCPARAM)>535.0
len(suspect FUNCPARAM)>517.5
len(suspect FUNCPARAM)>526.0
len(suspect FUNCPARAM)>497.5
track GLOBAL’ in ‘str’ with ‘&lt;’ and
‘&gt;’, the manipulated string is copied to a destination string
variable called ‘dfstr’ and will potentially cause remote code
injection. From Table IV we see that pure symbolic execution
failed after exploring almost 18K individual paths. Two main
reasons exist for the failure: First, thttpd involves large number
3In the case of faulty runs, our monitoring tool will not capture the function
return.
in the function initlinedraw(). When using StatSym to ana-
lyze CTree, the statistical analysis module is able to construct
a candidate path that starts with the main() program entry
point, and ends at the exit point of initlinedraw() function.
The statistical analysis module generates the predicate for
node stonesoup read taint() leave showing that a string
variable named stonesoup tainted buf f has length longer
than 306.5 on vulnerable path. Note that the predicate gives a
sufﬁcient condition that lead to the vulnerability path since the
actual length of the stack buffer is 64. This greatly reduces the
required search space for KLEE during its symbolic execution.
For Grep, the code injection mechanism by STONESOUP is
similar to CTree. Our analysis shows that our approach con-
structs useful predicates that lead to vulnerable path discovery.
D. Sensitivity to Sampling
(a) Polymorph
(b) CTree
Fig. 10: Time breakdown for statistical analysis and symbolic
execution modules of StatSym to analyze polymorph and
CTree when using different levels of sampling rate.
As shown in prior work [9], program logging with proba-
bilistic sampling is required in practice to mitigate the runtime
overhead. We evaluate the effects of reduced sampling rate
using Fjalar [34]. While random sampling has advantages of
reducing performance overhead, it increases the probability of
false alarms in statistical analysis, leading to potentially lower
accuracy in predicate and candidate path construction.
We conduct experiments, and show our results on poly-
morph and CTree applications to understand the implication of
partial logs generated at different sampling rates. As sampling
rate varies from 20% to 100%, we collect 200 log ﬁles from
runtime program sampling and input the logs to StatSym.
In Figure 10a and Figure 10b, we show the time required by
Fig. 9: Candidate paths for Polymorph
of internal and external calls. By reviewing the log ﬁles
for thttpd, we observed that there are hundreds of function
calls from the string injection point, handle read() to the
vulnerability site defang(). Among the large number of paths
spawned by KLEE, only a few of them (less than 1%) reach the
execution point at defang(), while a majority of explored paths
are diverted from the real vulnerable path. Second, the defang()
function involves a tight loop which includes an inner switch
statement. Without additional constraints for the input string,
KLEE itself will need to explore all the branch possibilities
(every loop iteration and case statement). This will spawn
even more states and quickly result in an explosion of states
during exploration. For StatSym, with 30% sampling rate,
the statistical analysis module ﬁnds a skeleton path consisting
of 34 nodes along with 7 detours. Each of the instrumented
location is a key execution point leading to defang(). Our
statistical module identiﬁes a number of high score predicates
including dfstr in defang function as well as other variables
and functions that are related to the dfstr variable. A total of
thirteen candidate paths are constructed by joining the skeleton
and detours. The length of the candidate paths range from 34
to 190 nodes. The ﬁrst candidate path used to guide symbolic
execution has 190 nodes. This path is generated by adding all
the detours to the skeleton path in a randomly-chosen order.
The symbolic execution module was not able to successfully
explore along this candidate path, as the search failed after
exceeding the hop threshold τ = 10 (i.e., after exploring