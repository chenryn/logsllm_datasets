本文来源：[长亭技术专栏](https://zhuanlan.zhihu.com/p/25816426)  
作者：[ **Jwizard**](https://www.zhihu.com/people/Jwizard)
## _0x00_ 写在最前面
_ **开场白：** _快报快报！今天是2017
Pwn2Own黑客大赛的第一天，长亭安全研究实验室在比赛中攻破Linux操作系统和Safari浏览器（突破沙箱且拿到系统最高权限），积分14分，在11支队伍中暂居
Master of Pwn
第一名。作为热爱技术乐于分享的技术团队，我们开办了这个专栏，传播普及计算机安全的“黑魔法”，也会不时披露长亭安全实验室的最新研究成果。
安全领域博大精深，很多童鞋都感兴趣却苦于难以入门，不要紧，我们会从最基础的内容开始，循序渐进地讲给大家。技术长路漫漫，我们携手一起出发吧。
## _0x10_ 本期简介
在计算机安全领域，缓冲区溢出是个古老而经典的话题。众所周知，计算机程序的运行依赖于函数调用栈。栈溢出是指在栈内写入超出长度限制的数据，从而破坏程序运行甚至获得系统控制权的攻击手段。本文将以32位x86架构下的程序为例讲解栈溢出的技术详情。
为了实现栈溢出，要满足两个条件。第一，程序要有向栈内写入数据的行为；第二，程序并不限制写入数据的长度。历史上第一例被广泛注意的“莫里斯蠕虫”病毒就是利用C语言标准库的
gets() 函数并未限制输入数据长度的漏洞，从而实现了栈溢出。
Fig 1. 波士顿科学博物馆保存的存有莫里斯蠕虫源代码的磁盘（source:
[Wikipedia](https://zh.wikipedia.org/wiki/%E8%8E%AB%E9%87%8C%E6%96%AF%E8%A0%95%E8%99%AB)）
如果想用栈溢出来执行攻击指令，就要在溢出数据内包含攻击指令的内容或地址，并且要将程序控制权交给该指令。攻击指令可以是自定义的指令片段，也可以利用系统内已有的函数及指令。
## _0x20_ 背景知识
在介绍如何实现溢出攻击之前，让我们先简单温习一下函数调用栈的相关知识。
函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。
Fig 2. 函数调用发生和结束时调用栈的变化
函数状态主要涉及三个寄存器－－esp，ebp，eip。esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。ebp
用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。eip 用来存储即将执行的程序指令的地址，cpu 依照 eip
的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。
下面让我们来看看发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。
首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。
Fig 3. 将被调用函数的参数压入栈内
然后将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存。
Fig 4. 将被调用函数的返回地址压入栈内
再将当前的ebp 寄存器的值（也就是调用函数的基地址）压入栈内，并将 ebp 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的
ebp（基地址）信息得以保存。同时，ebp 被更新为被调用函数（callee）的基地址。
Fig 5. 将调用函数的基地址（ebp）压入栈内，并将当前栈顶地址传到 ebp 寄存器内
再之后是将被调用函数（callee）的局部变量等数据压入栈内。
Fig 6. 将被调用函数的局部变量压入栈内
在压栈的过程中，esp
寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到
eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。
看过了函数调用发生时的情况，就不难理解函数调用结束时的变化。变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。
首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。
Fig 7. 将被调用函数的局部变量弹出栈外
然后将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 ebp 寄存器内。这样调用函数（caller）的
ebp（基地址）信息得以恢复。此时栈顶会指向返回地址。
Fig 8. 将调用函数（caller）的基地址（ebp）弹出栈外，并存到 ebp 寄存器内
再将返回地址从栈内弹出，并存到 eip 寄存器内。这样调用函数（caller）的 eip（指令）信息得以恢复。
Fig 9. 将被调用函数的返回地址弹出栈外，并存到 eip 寄存器内
至此调用函数（caller）的函数状态就全部恢复了，之后就是继续执行调用函数的指令了。
## _0x30_ 技术清单
介绍完背景知识，就可以继续回归栈溢出攻击的主题了。当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是
eip（还记得 eip 的用途吗？），所以我们的目标就是让 eip 载入攻击指令的地址。
先来看看函数调用结束时，如果要让 eip 指向攻击指令，需要哪些准备？首先，在退栈过程中，返回地址会被传给
eip，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。
Fig 10. 核心目的是用攻击指令的地址来覆盖返回地址
再来看看函数调用发生时，如果要让 eip 指向攻击指令，需要哪些准备？这时，eip
会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制了，不过我们可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。
所以这篇文章会覆盖到的技术大概可以总结为（括号内英文是所用技术的简称）：
  * 修改返回地址，让其指向溢出数据中的一段指令（ **shellcode** ）
  * 修改返回地址，让其指向内存中已有的某个函数（ **return2libc** ）
  * 修改返回地址，让其指向内存中已有的一段指令（ **ROP** ）
  * 修改某个被调用函数的地址，让其指向另一个函数（ **hijack GOT** ）
本篇文章会覆盖前两项技术，后两项会在下篇继续介绍。（所以请点击“关注专栏”持续关注我们吧 ^_^ ）
## _0x40_ Shellcode
_－－修改返回地址，让其指向溢出数据中的一段指令_
根据上面副标题的说明，要完成的任务包括：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。攻击指令一般都是用来打开
shell，从而可以获得当前进程的控制权，所以这类指令片段也被成为“shellcode”。shellcode
可以用汇编语言来写再转成对应的机器码，也可以上网搜索直接复制粘贴，这里就不再赘述。下面我们先写出溢出数据的组成，再确定对应的各部分填充进去。
**payload :** padding1 + address of shellcode + padding2 + shellcode
Fig 11. shellcode 所用溢出数据的构造