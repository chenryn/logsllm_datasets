method to determine the correct order in which the deobfuscation
logic should be applied.
Thus, for multi-level obfuscated samples, manual analysis is
necessary to decide the correct order of deobfuscation logic first,
while our approach can automatically handle.
6.2.3 Deobfuscation Efficiency. Figure 9 shows the average time
required to deobfuscate one obfuscated script. The size of the origi-
nal scripts used as samples ranges from 400 Byte to 400 KB, with
an average of 5.4 KB. On average, it takes less than half a second to
do the deobfuscation, while the emulator takes about two-thirds
of the time, and the other takes up the rest of the time. The other
parts are mainly the reconstruction of AST and the recovery of
scripts. Emulator’s job is to undo the obfuscation. For encoding-
based obfuscation, the emulator needs to do the decoding, which
is slower than string stitching for string-based obfuscation. The
emulator takes much more time for token-based obfuscated scripts
because they contain more subtrees involved in obfuscation. A
typical script token-based obfuscated can contain more than 50
obfuscated subtrees and require more calculations. The time spend
on the emulator can barely be reduced.
6.2.4 Attack Detection based on Deobfuscated Scripts. Table 6 dis-
plays the impact of deobfuscation on detection. Here we use the
same sample as in Section 2.3. The rest of the unobfuscated samples
are used as training set for our detection system. We submit the
samples separately to Microsoft online defender [10] and VirusTotal
[11]. For VirusTotal, as long as one of the AV engines detected it,
we consider it is detected. We also excluded three engine, namely,
Kaspersky, ZoneAlarm and Sophos AV, which detect obfuscation
instead of detecting maliciousness. These engines’ false positives
are too high so that their results have no reference value.
As shown in Table 6, obfuscation can bypass detection effectively.
For Windows Defender, detection rate reduces about 68 times at
least, from 89% to 1.3%. VirusTotal performs slightly better but still
fails in most case. Its detection rate reduces by 12.5% at least. Our
approach, on the other hand, is almost unaffected by obfuscation.
Detection rate reduces up to 8 percent. Moreover, our deobfuscation
module along can provide a lot help for existing detection systems.
For all obfuscation schemes, deobfuscation can improve the detec-
tion rate of Defender and VirusTotal significantly. The detection
rate increase by at least 48% and 82.6% for Defender and VirusTotal,
respectively.
Furthermore, among the four obfuscation schemes, scheme 2
fails most because it is based on string split. If scripts are not split
Table 6: The effect of deobfuscation on detection and semantic-aware detection results
Samples
Original Scripts
Original scripts, all 4 obfuscation schemes
Malicious
Benign
S1
S2
S3
S4
Defender
89.3%
0.0%
1.3%
0.0%
0.0%
0.0%
Deobfuscation +
Defender
89.3%
48.0%
78.6%
84.0%
89.3%
0.0%
VirusTotal
100%
0.0%
8.0%
2.6%
0.0%
0.0%
Deobfuscation +
VirusTotal
100%
76.0%
90.6%
96.0%
97.3%
0.0%
Deobfuscation +
Our model
98.7%
90.7%
93.3%
92.0%
93.3%
0.0%
fine-grain enough, they can still match signatures. And the de-
obfuscation effect on scheme 1 is the worst. That is because the
other three schemes are script block-based, the obfuscation does
not change the structure in the script block, and the structure re-
mains intact after the deobfuscation. Besides, no detection approach
have false positive, since that the PowerShell scripts’ structure is
relatively simple and have no ambiguity.
All in all, deobfuscation can significantly improve the detection
effect. Our semantic-based detection also has good results, which
means semantic analysis on deobfuscated scripts is feasible.
Table 7: Comparison with state-of-the-art detection ap-
proaches in TPR.
Detection approaches
Our approach
AST-based [53]
Character-based [32]
Obfuscated
scripts
-
0.0%
12.1%
Deobfuscated
scripts
92.3%
90.7%
95.7%
Mixed
scripts
92.3%
9.6%
34.7%
6.2.5 Comparison with State-of-the-Art PowerShell Detection Ap-
proaches. Rusak et al. [53] and Hendler et al. [32] present the latest
detection approaches for PowerShell, which apply AST-based and
character-based features for detection respectively. Thus, we re-
produce these two approaches to compare with our approach. For
the approach proposed by Hendler et al. [32], the original design
can support several different classifiers, and we only choose the
one with the best results on their paper (i.e., combination of a 3-
CNN and traditional 3-gram [32]) to reproduce. In the training of
these two previous approaches, we use the same training set and
testing set mentioned above. The results are shown in Table 7. Re-
sults. As shown, both the AST-based and character-based detection
approaches will be bypassed by obfuscation. And our deobfusca-
tion system can increase their detection TPR by 87.2%. Once these
scripts are deobfuscated, our results show that these two previ-
ous approaches can achieve similar, or even higher true-positive
rates than our approach. However, we would like to note that since
the features used by these two approaches are at the syntax level,
they can be more easily evaded compared to our semantic-aware
approach. To show this, we simply mix benign pieces into mali-
cious samples at the granularity of script lines, which changes AST
structure and character distributions without affecting the script
behavior. In Table 7, we call them “Mixed scripts”. An example is
given in §C. As shown, these mixed scripts can greatly decrease
the true-positive rates of AST-based and character-based detection
approaches, but cannot affect that of our approach.
6.2.6 Break-down analysis of techniques used in our deobfuscation.
To demonstrate the benefits of individual major techniques used in
our deobfuscation, we remove or replace one major technique at a
time and then evaluate the impact to performance. It is noteworthy
that the testing sets for the first three columns and last columns are
different and corresponding to the testing sets in §6.2.1 and §6.2.4
respectively. The result is shown in Table 8.
Table 8: Break-down analysis of individual major tech-
niques used in deobfuscation
Deobfuscation phases
w/ all 5 phases
w/o (1) Extract subtrees
w/o (2) Obfuscation detection
w/o (3) Emulation-based Recovery
w/o (4) AST update
w/o (5) Post processing
Recovery
similarity
80.4%
-14.7%
-43.7%
-43.4%
-0.6%
-7.0%
Time
0.46s
+404.3%
+108.7%
+83.7%
-6.5%
-2.1%
Detection
accuracy
92.3%
-12.4%
-54.7%
-53.6%
-0.1%
0.0%
The analysis results are shown in Table 8. Next, we describe
how we remove or replace each phase and discuss the results. “(1)
Extract Subtrees” (§4.2) mainly focus on extracting suspicious sub-
trees. As shown, removing it means that there are more subtrees
we need to analyze, and incurs 4 times more analysis time. Mean-
while, it leads to deterioration of deobfuscation and subsequent
detection results. This is because without this pre-selection, we
may choose the wrong recoverable subtree and fail to recover the
original script pieces. The output of “(2) Obfuscation Detection”
(§4.3) determines the subsequent operations, so we cannot simply
remove this phase. Instead, we experiment with replacing it with
the regex-based obfuscation detector introduced by PSDEM [41].
As shown, the accuracy of such regex-based obfuscation detector
is only half of ours, which results in a 43.7% decrease of similarity
and a 54.7% decrease of detection accuracy.
After we get the recoverable pieces, the next deobfuscation phase
in our design is “(3) Emulation-based Recovery” (§4.4). The latest
automatic method for this task is PSDEM’s string manipulation
based approaches, which entirely relies on regex-based obfuscation
detector to accurately identify the obfuscation techniques. There-
fore, although the approach has good recovery quality for known
obfuscation techniques as discussed in §6.2.1, our results show that
this causes the similarity and detection accuracy to drop by nearly
half. “(4) AST Update” (§4.5) is mainly designed for the completion
of the deobfuscation process, i.e., putting the deobfuscated script
pieces together to the whole recovered script. In terms of the benefit
on performance, this phase can help handle multi-layer obfuscation.
In our results, since most of our samples only involve one layer of
obfuscation, such benefit is not prominent across the entire dataset.
For the last phase, “(5) Post Processing” (§4.6), it is designed for
handling corner-case inconsistencies in the syntax recovery, and
our results show that removing it decreases the recovery similarity
by 7%.
7 DISCUSSION
7.1 Generality of Our Approach
Although our subtree-based deobfuscation approach in this paper
is developed for PowerShell, its design does not require specific
features of PowerShell. As long as the obfuscation is to cover the
semantics by hiding the script pieces as strings, our approach can
be applied to achieve effective deobfuscation. As far as we know,
JavaScript utilize similar obfuscation techniques [66].
Moreover, our method requires only a parser and an unmodified
interpreter for the target language, both of which typically have
official tools available. Meanwhile, the strategy for updating the
tree and finally constructing the deobfuscated script is reusable.
Therefore, the only extra work required to construct a deobfuscation
system for a new language is to collect the samples of the obfuscated