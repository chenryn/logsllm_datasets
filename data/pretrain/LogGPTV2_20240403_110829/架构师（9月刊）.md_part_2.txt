我们想要一种拥有自由许可的开源语言。我们想要它拥有 C 的速度
与 Ruby 的灵活。它要容易理解，像 Lisp 一样真正地支持宏，但也要有
像 Matlab 一样的明显、熟悉的数学符号。它还要像 Python 一样可用于通
用编程，像 R 一样易于统计，像 Perl 一样可自然地用于字符串处理，像
Matlab 一样擅长线性代数，像 shell 一样擅长将程序粘合在一起。总之，
它既要简单易学，但也要让最严肃的黑客开心。我们既希望它是交互式，
也希望它是可编译的。
现在，一个充满活力和蓬勃发展的社区围绕着这种语言成长起来，来
自世界各地的人们在追求这一目标的过程中不断地精炼并重塑着 Julia。
超过 700 人为 Julia 做出了贡献，还有很多人制作了数以千计的令人惊叹
的开源 Julia 软件包。总而言之，我们建立的语言：
快速：Julia 就是为高性能而设计的。Julia 程序通过 LLVM 编译为多
11
InfoQ 架构师 2018 年 9 月
个平台的高效本机代码。
通用：它使用多个调度作为范例，使得它很容易表达众多面向对象和
函数编程的模式。它的标准库提供异步 I/O、进程控制、日志记录、概要
分析、软件包管理器等。
• 动态：Julia是动态类型的，就像一种脚本语言，并且很好地支持
交互式使用。
• 技术：它擅长于数值计算，其语法非常适合数学，支持的数字数
据类型众多，并具有开箱即用并行性。Julia的多次调度非常适合
定义数字和数组类型的数据类型。
• （可选）键入：Julia具有丰富的描述性数据类型语言，类型声明
可用于阐明和巩固程序。
• 可组合：Julia的软件包可以很好地协同工作。单位数量矩阵，货
币和颜色数据表都可以进行，并且性能良好。
如果你要从 Julia0.6 或更早版本升级代码，我们建议首先使用过渡版
0.7，其中包括弃用警告帮助指导完成升级。如果你的代码没有警告，则
可以更改为 1.0 而无需任何功能更改。已注册的软件包正在使用该过渡版
本发布 1.0 兼容的更新。
1.0 更新了哪些功能？
当然，Julia1.0 中最重要的一个新功能是对语言 API 稳定性的承诺：
你为Julia1.0编写的代码可以继续在Julia1.1、1.2等版本中运行。该语言是“已
完善”的，核心语言开发人员和社区都可以放心使用基于此版本的软件包、
工具和新功能。
但 Julia1.0 更新的不仅是稳定性，它还引入了一些强大、创新的语言
功能。自 0.6 版以来，新发布的一些功能包括：
• 全新的内置软件包管理器性能得以大幅改进，使安装包及其
dependencies项变得前所未有的简单。它还支持每个项目的包环
境，并记录工作应用程序的确切状态，以便与他人和你自己进行
12
专热题点 | |T Hopoict
共享。最后，新的设计还引入了对私有包和包存储库的无缝支
持。你可以使用与开源软件包生态系统相同的工具来安装和管理
私有软件包。JuliaCon上展示了新功能设计的详细情况。
• Julia有了一个新的规范表示缺失值。能够表示和处理缺失的数据
是统计和数据科学的基础。与Julian的一贯风格相符，这个新的解
决方案具有通用性、可组合性和高性能。任何泛型集合类型都可
以通过让元素包含missing的预定义值来有效地支持缺失值。在以
前的Julia版本中，这种“联合类型”集合的性能会太慢，但编译器
的改进现在使得Julia可以跟上其他系统中自定义C或C++缺失数据
表示的速度，同时也更加通用和灵活。
• 内置的String类型现在可以安全地保存任意数据。你的程序数小时
甚至数天的工作不再会因为一些无效Unicode杂乱字节而失败。保
留所有字符串数据，同时标记哪些字符有效或无效，可以使你的
应用程序安全方便地处理不可避免具有缺陷的真实数据。
• 语法简单的广播（Broadcasting）已经成为核心语言功能，现在它
比以往任何时候功能都更强大。在Julia1.0中，将广播扩展到自定
义类型并在GPU和其他矢量化硬件上实现高效优化计算变得更简
单，为将来提高性能提升铺平了道路。
• 命名元组是一种新的语言特性，它使得通过名称表示和访问
数据变得高效快捷。例如，你可以将一行数据表示为row=
（name=“Julia”，version=v“1.0.0”，releases=8），并将版本列作为
row.version访问，其性能与不甚快捷的row[2]相同。
• 点运算符现在可以重载，让类型使用obj.property语法来获取和设
置结构字段之外的含义。这对于使用Python和Java等基于类的语
言更顺畅地进行互操作是个福音。属性访问器重载还允许获取一
列数据以匹配命名元组语法的语法：你可以编写table.version来访
问表的version列，就像row.version访问单行的version字段一样。
• Julia的优化器在很多方面变得比我们在这里提到的更聪明，但有
13
InfoQ 架构师 2018 年 9 月
一些亮点值得一提。优化器现在可以通过函数调用传播常量，可
以更好地做到死码消除和静态评估。另外，编译器在避免在长生
命周期对象周围分配短期包装器方面也要好得多，这使得程序员
可以使用便利的高级抽象而无需降低性能成本。
• 现在使用声明相同的语法调用参数类型构造函数。这消除了语言
语法的模糊和令人困惑的地方。
• 迭代协议已经完全重新设计，以便更容易实现多种迭代。现在是
一对一定义一个或两个参数方法，而不是定义三个不同泛型函数
的方法——start，next，和done。这通常使得使用具有开始状态的
默认值的单个定义可以更方便地定义迭代。更重要的是，一旦发
现无法生成值就可以部署迭代器。这些迭代器在I/O、网络和生产
者/消费者模式中无处不在；Julia现在可以用简单直接的方式表达
这些迭代器。
• 范围规则简化。无论名称的全局绑定是否已存在，引入本地范围
的构造现在都是一致的。这消除了先前存在的“软/硬范围”区别，
并且意味着现在Julia可以始终静态地确定变量是本地的还是全局
的。
• 语言本身非常精简，许多组件被拆分为“标准库”软件包，这些软
件包随Julia一起提供但不属于“基础”语言。如果你需要它们，它
可以给你方便（不需要安装），但不会被强加给你。在未来，这
也将允许标准库独立于Julia本身进行版本控制和升级，从而允许
它们以更快的速度发展和改进。
• 我们对Julia的所有API进行了彻底的审查，以提高一致性和可用
性。许多模糊的遗留名称和低效的编程模式已被重命名或重构，
以更优雅地匹配Julia的功能。这促使使用集合更加一致和连贯，
以确保参数排序遵循整个语言的一致标准，并在适当的时候将
（现在更快）关键字参数合并到API中。
• 围绕Julia1.0新功能的新外部包正在构建中。例如：
14
专热题点 | |T Hopoict
• 正在改进数据处理和操纵生态系统，以利用新的缺失支持
• Cassette.jl提供了一种强大的机制，可以将代码转换传递注入
Julia的编译器，从而实现事后分析和现有代码的扩展。除了用
于分析和调试等程序员的工具之外，甚至可以实现机器学习任
务的自动区分。
• 异构体系结构支持得到了极大的改进，并且与Julia编译器的内
部结构进一步分离。英特尔KNL只能用Julia工作。NvidiaGPU
使用CUDANative.jl软件包进行编程，GoogleTPU的端口正在
开发中。
另外，Julia1.0还有无数其他大大小小的改进。有关更改的完整列表，
请参阅文件。
在2012年的文章《为什么我们创造Julia》这篇博客文章中，我们写道：
它不完整，但现在是 1.0 发布的时候——我们创建的语言叫做 Julia。
现在，我们提前叩响了1.0版本发布的扳机，但它发布的时刻已然到来。
真诚地为这些年来为这门现代化编程语言做出贡献的人们感到骄傲。
15
InfoQ 架构师 2018 年 9 月
Kafka 2.0 重磅发布，新特性独家解读
作者 王国璋
增强在线可进化性
就我个人而言，这几年来学到的最重要的一课，就是要永远保证一个
流式数据平台的在线可进化性（online-evolvable）。
之前我曾经读到 Amazon CTO Werner Vogels 写过的一篇博客，里面
就提到这一点，并且有一个精彩的比喻：搭建一个能够在不断产品升级过
程中保证永远在线的数据架构，就像是驾驶着一架简单的单螺旋桨飞机起
飞，然后在飞行过程中，不断换新零件和添加新引擎，直到最后升级成一
架超大的空客飞机，这一切都必须在飞行中同步完成，并且坐在里面的乘
客不能有任何感觉，其难度可想而知。
16
专热题点 | |T Hopoict
而关于一个流数据平台，对于在线可进化性这一点的需求尤甚：这里
我也打一个比方，尽管没有 Vogels 的那样精彩——数据流就像是一个连
接城市各个地区的高速公路，高速公路所连接的地方，比如一家超市、一
家影院，或者一个居民小区，就如同一个企业里面大大小小的各种应用产
品或者数据仓库，超市可以暂时歇业，影院可以暂时关门翻修，居民小区
甚至也可以迁出人口夷平重建，就像是产品或者数据仓库都可以短暂下线
升级维护。然而高速公路却很难彻底打断重搭，因为随时都有人要上路。
更多时候，它只能一边继续完成输送车辆的任务，一边增设车道或者加盖
匝道。就像是一个流数据平台本身，因为不会有一个零流量的时刻，所以
所有的维护和升级都需要保证同步在线完成，而且期间最好没有任何用户
可感知到的性能弱化或者服务差别。而在云环境下，后者显得更为重要。
对于 Kafka 而言，如果一个用户没有一个安全稳定的升级路线的话，那么
她就只能停留在最初的那个版本，再不会升级。
因此我们从很早以前开始注意保证在线升级的方便性，在这一次的
2.0.0 版本中，更多相关的属性被加了进来，比如 KIP-268、KIP-279、KIP-
283 等等。
KIP-268：简化 Kafka Streams 升级过程
Kafka Streams 利用 Consumer Rebalance 协议里面的元数据字符串编
码诸如任务分配、全局查询、版本升级相关的信息。然而，当编码版本
本身改变的时候，就需要进行离线升级。比如之前从 0.10.0 版本向更高
级的版本升级的时候，用户就需要将所有的 Streams 程序下线，换上新的
Kafka 版本号，然后在全部重启。
KIP-268 利用 version prob 可以使得旧版本的任务分配者告知其他高
版本的成员暂时使用旧版本的 Rebalance 元数据编码，这样就可以让用户
依然能够通过 rolling bounce 在线升级 Kafka Streams 的版本。而当所有参
与的成员全部升级完毕之后，最后一次 rebalance 会自动切换回新版本的
元数据编码。
17
InfoQ 架构师 2018 年 9 月
KIP-279：修补多次 Kafka 分区主本迁移时的日志分歧问题
在升级 Kafka 版本或者做定期系统维护的时候，用户往往需要进行连
续的多次 Kafka 分区迁移。在这次发布中我们修补了一个在此过程中可能
会出现的一个会导致日志分歧发生的边缘情况。具体方案就是将此前版本
中已经加入的主本 epoch 信息扩散到 OffsetForLeaderEpochResponse。如
此所有主副本就可以清晰知道自己到底处于当前分区备份的哪一个阶段，
从而杜绝因为消息不对等而可能导致的日志分歧。
KIP-283：降低信息格式向下转换时的内存消耗