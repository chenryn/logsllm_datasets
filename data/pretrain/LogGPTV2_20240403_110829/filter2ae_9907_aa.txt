本文翻译自：  
* * *
Proofpoint研究人员在2018年5月首次发现了DanaBot，分析结果显示与攻击澳大利亚企业的威胁单元有关。本文对DanaBot进行逆向分析并分析了其攻击美国企业的活动。
# DanaBot近期活动
近期，ESET研究人员发文描述了DanaBot的最新攻击活动，受影响的国家包括波兰、意大利、大国和澳大利亚。9月底，研究人员发现攻击者将攻击美国使用的Panda银行木马变成了传播DanaBot。
## Hancitor攻击活动
9月26日，Proofpoint研究人员发现一起针对美国接收者的上万的垃圾邮件攻击活动。邮件使用eFax诱饵文件（图1）和URL链接来下载含有恶意宏的文档（图2）。如果用户启用了宏，宏文件就会执行嵌入的Hancitor恶意软件，恶意软件执行后会接收任务来下载两个版本的Pony窃取器和DanaBot银行木马。
图1: 含有下载恶意payload的宏的URL消息示例
图2:含有Hancitor payload的宏文档
# 恶意软件分析 (v2.003)
DanaBot是一款用Delphi语言开发的银行恶意软件。本节在原有v2.003的基础上进行分析。这是目前最新的版本，最早是9月初出现的。该版本号是基于version字符串（图3）识别的。
图3: 和系统信息一起发回给C2服务器的DanaBot版本字符串
DanaBot是由以下三个组件组成的：
  1. Loader:负责下载和加载主组件。
  2. Main component: 负责下载、配置和加载模块
  3. Modules: 负责完成不同的恶意软件功能
## 反分析技术
DanaBot明显含有大量的垃圾代码，代码中含有额外的指令、条件描述和循环等。加之是用Delphi语言编写的，所以非常影响对DanaBot的逆向。另外，DanaBot使用Windows
API函数哈希和加密字符串来防止分析师和自动化分析工具确定代码的作用。
加密的字符串的字符保存在DWORDs数组中，需要用key和基本的替换密文来解密。Github中有 IDA Pro
Python脚本和加载器中使用的解密字符串和主模块。
## Command & Control IPs
加载器和主模块C2 IP地址都以DWORDs的形式保存。图4是加载器组件的内存示例：
图4: DanaBot加载器模块所在内存中的C2 IP地址示例
## C2通信
之前的分析显示DanaBot的加载器模块使用HTTP进行通信，其主模块使用的是二进制协议。在v2.003版本中，所有组件都使用TCP
443端口的二进制协议。虽然使用的是443端口，但并没有使用TLS。
该协议在183字节的header之后是可选的payload数据。请求中的大多数的header值都回在响应header中返回。Payload数据的格式与特定的命令有关。
## 二进制协议header
Header示例如图5：
图5: DanaBot二进制协议中使用的183字节header
可以分成下面的域：
    •   Offset 0:随机值（垃圾stack）
    •   Offset 4: hardcoded -1 (DWORD)
    •   Offset 8: 命令(DWORD)
    •   Offset 0xc: affiliate ID (DWORD)
    •   Offset 0x10: hardcoded 1 (DWORD)
    •   Offset 0x14: random value based on a linear congruential generator (DWORD)
    •   Offset 0x18: unknown counter variable (DWORD)
    •   Offset 0x1c: system architecture (DWORD)
    •   Offset 0x20: Windows version information (DWORD)
    •   Offset 0x24: command argument (DWORD)
    •   Offset 0x28: admin status (DWORD)
    •   Offset 0x2c: process integrity level (DWORD)
    •   Offset 0x30: payload length (QWORD) 
    •   Offset 0x38: length of next field (BYTE)
    •   Offset 0x39: bot ID (32 bytes) 
    •   Offset 0x59: length of next field (BYTE)
    •   Offset 0x5a: command-dependent (32 bytes) 
    •   Offset 0x7a: length of next field (BYTE)
    •   Offset 0x7b: a nonce (32 bytes)
    •   Offset 0x9b - end of header: random values (stack junk)
## 命令
研究人员共发现了以下命令，其中第一个命令是由loader执行的，其余的命令由主模块执行。
### Command 0x454 (1108): “Request main component”
该命令由加载器执行，用于从C2服务器请求主模块。命令参数（header中的offset
0x24）含有整数32或64来请求x86或x64版本的组件。响应payload中含有加密的数据和加密的128字节RAS签名区块用于验证数据。解密的key由CryptDeriveKey
Windows
API函数生成。数据是用`\x00`字节的初始化向量（IV）进行AES-256-CBC加密的。解密是数据就是`rundll32.exe`会执行的主模块DLL。
### Command 0x453 (1107): “Initial beacon”
这是主组件发送给C2服务器的第一条命令，请求和响应中都没有数据，所以研究人员认为这是一个信标。
### Command 0x44c (1100): “Request module identifiers”
恶意软件用这条命令从C2服务器请求一个模块id列表。图6是含有6个模块id的响应示例：
    759CBB3E1B883BDCA23E9052462F641E
    E0FBBC92DB9927BFC474A64DF4F9C22F
    D0C851FBCA030928B535FAF3188DAFBA
    A5BBBAB3A17BA2119F47F0E4316EE5BF
    4F06D71C93E4105307339704D21C49A3
    8C59B6C9985F983E248E27CC0BF98A2D
图6: 含有模块id列表的Command 0x44c response payload数据
### Command 0x44d (1101): “Request module”
这条命令用于从C2服务器请求模块。Header的offset`0x5a`域含有一个模块id，用于确定应该下载哪个模块。响应payload数据中含有一个1699字节的subheader、加密数据、以及用于验证数据的128字节的RAS签名区块。图7是subheader示例：
图7: 含有1699字节subheader的Command 0x44d response payload数据
下面这些域都在subheader中出现过：
    •   Offset 0: total length of subheader and data (QWORD)
    •   Offset 8: hardcoded -1 (DWORD)
    •   Offset 0x10: module name (520-byte wide string)
    •   Offset 0x218: module filename (520-byte wide string)
    •   Offset 0x649: length of next field (BYTE)
    •   Offset 0x64a: module identifier (32 bytes)
    •   Offset 0x682: module architecture (DWORD)
    •   Offset 0x686: module type (DWORD)
    •   Offset 0x68e: data is ZLIB-compressed flag (DWORD)
    •   Offset 0x692: length of encrypted data (QWORD)
用于解密模块的解密key是由`CryptDeriveKey Windows API`函数生成的，该函数由以下过程初始化：
  1. 复制1699字节的subheader到缓存中，并将以下域清0：  
a. Offset 0: subheader和数据的长度和(QWORD)  
b. Offset 0x692: 解密数据的长度 (QWORD)
  2. 对缓存进行MD5哈希
  3. 哈希的大写十六进制摘要就是MD5哈希本身
数据是用IV和16个空`\x00`字节用AES-256-CBC加密的。解密的字符串可选用ZLIB压缩，一旦解压含有的模块dll就会被rundll32.exe执行。
表1: 模块列表
### Command 0x44f (1103): “Get configuration files”
恶意软件使用该命令来从C2服务器请求配置文件。恶意软件在接收到183字节的响应header后，恶意软件会在C2服务器响应response
payload数据前发送`\xff\xff\xff\xff\xff\xff\xff\xff`。Payload数据的格式和加密与模块类似，但会发送不同的配置文件。
表2: 配置文件
恶意软件用该命令来发送来发送系统信息或截屏等数据到C2。请求payload数据中含有656字节的subheader、加密数据和加密`session
key`（图8是subheader示例）。
图8:含有656字节subheader的 Command 0x44e request payload数据