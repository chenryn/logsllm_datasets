amount of code obfuscation via jumps, resulting in increased
block creations and xfer-stub overheads for such blocks (see
Section 4.1.3), for the analysis range.
Figure 10b shows the latency of Cobra employing block-
coalescing on the same analysis ranges. Block-coalescing
helps in reducing the latency due to xfer-stubs when an-
alyzing code-streams involving loops. As seen from the
graph in Figure 10b, analysis ranges 2 and 3 which con-
tain a large number of loops incur a much lower overall
latency with block-coalescing when compared to their over-
all latency without block-coalescing (Figure 10a). However,
for analysis range 1 there is negligible gain in performance
with block-coalescing, since it contains a very few num-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
ber of loops. A point to note is that, the latency of analysis
range 4 with block-coalescing is more than its latency with-
out block-coalescing (Figure 10a). This is due to the fact that
W32/Ratos, being metamorphic in nature, generates vary-
ing amount of code for a given functionality and embeds a
random amount of anti-analysis code fragments in differ-
ent instances of its deployment.
Skipping helps in further reduction of the overall latency
by excluding standard and/or already analyzed code-streams
from the analysis process. Figure 10c shows the performance
of Cobra with block-coalescing and skipping applied to stan-
dard kernel code-streams. As seen from the graph of Figure
10c, the latency of analysis ranges 1 and 2 are further reduced
as compared to their latency without skipping (Figure 10b).
This is because, the code-streams in analysis ranges 1 and 2
invoke standard kernel functions such as VirtualProtect, Ke-
SetEvent, KeRaiseIrql etc. which are excluded from localized-
executions with skipping. However, analysis range 4 has neg-
ligible improvement since it does not involve any calls to stan-
dard code-streams. Figure 10d shows the performance of Co-
bra with block-coalescing and skipping on standard as well as
already analyzed malware code-streams. As an example, the
single-step handler of W32/Ratos always invokes a procedure
that handles a variant of the TEA decryption algorithm, several
times within its code-stream. This procedure never changes in
terms of its semantics and can be skipped after analyzing it
once. As seen from the graph of Figure 10d, analysis ranges 1–
4 have a reduced latency from their counterparts in Figure 10c.
Note that analysis range 4, which showed a negligible change
with skipping of standard code-streams, shows a noticable la-
tency reduction with skipping applied to already analyzed mal-
ware speciﬁc code-streams.
Thus we can conclude that the performance of the frame-
work is highly dependent on the nature of code being analyzed
and the style of analysis employed by an individual (in terms
of selecting analysis ranges, coalescing blocks, choosing code-
streams to skip etc.). However, the measurements give a gross
indication of the latency one might expect. As seen from Fig-
ure 10, even the worst case latency (without block-coalescing
and skipping) of the framework is found to be within limits to
suit interactive analysis.
7. Conclusions
We have presented Cobra, a stealth, efﬁcient, portable
and easy-to-use dynamic ﬁne-grained malicious code anal-
ysis framework that overcomes the shortcomings in current
research involving ﬁne-grained code analysis in the con-
text of malware. Cobra facilitates the construction of powerful
ﬁne-grained malware analysis tools which are required to com-
bat malware that are increasingly becoming hardened to anal-
ysis. Cobra does not make any visible changes to the executing
code and hence cannot be detected or countered. The frame-
work can capture multithreaded, SM-SC code and obfuscated
code in both user- and kernel-mode while incurring a perfor-
mance latency that is suitable for interactive analysis. The
framework supports selective isolation – a technique that en-
ables ﬁne-grained analysis of malware speciﬁc code-streams
while co-existing with normal code-streams in real-time. Co-
bra currently runs on the Windows (9x, NT, 2K and XP) and
Linux OSs on the IA-32 (and compatible) processors. Co-
bra’s architecture has minmal OS dependency and abstracts
platform speciﬁc details to enable the framework to be ported
to other platforms. We show Cobra’s easy-to-use APIs en-
able construction of powerful ﬁne-grained malware analy-
sis tools and discuss one of our own tools that we have used
for ﬁne-grained analysis of various malware. In our opin-
ion, Cobra is the ﬁrst of its kind in tailoring a ﬁne-grained
code analysis strategy speciﬁcally targetted at analyzing mal-
ware code-streams. Future works include improving the per-
formance of the framework and integrating Cobra into a full
ﬂedged malware analysis environment currently being devel-
oped by us.
References
[1] K. Ashcraft and D. Engler. Using programmer-written compiler
extensions to catch security holes. In Proceedings of the 2002
IEEE Symposium on Security and Privacy, pages 143–159, May
2002.
[2] F. Bellard. Qemu, a fast and portable dynamic translator.
In
USENIX 2005 Annual Technical Conference, FREENIX Track,
pages 41–46, 2005.
[3] J. Bergeron, M. Debbabi, J. Desharnais, M. Erhioui, Y. Lavoie,
and N. Tawbi. Static detection of malicious code in executable
programs. Symposium on Requirements Engineering for Infor-
mation Security (SREIS’01), March 2001.
[4] J. Bergeron, M. Debbabi, J. Desharnais, B. Ktari, M. Salios,
N. Tawbi, R. Charpentier, and M. Patry. Detection of malicious
code in cots software: A short survey. First International Soft-
ware Assurance Certiﬁcation Conference (ISACC’99), March
1999.
[5] J. Bergeron, M. Debbabi, M. Erhioui, and B. Ktari. Static anal-
ysis of binary code to isolate malicious behaviors. In Proceed-
ings of the IEEE 4th International Workshop on Enterprise Se-
curity (WETICE’99), June 1999.
[6] M. Bishop and M. Dilger. Checking for race conditions in ﬁle
accesses. Computing Systems, 9(2), 1996.
[7] V. Bontchev. Methodology of computer anti-virus research.
Ph.D. Thesis, Faculty of Informatics, University of Hamburg,
1998.
[8] D. Bruening. Efﬁcient, transparent, and comprehensive run-
time code manipulation. Ph.D. Thesis. Massachusetts Institute
of Technology., 2004.
[9] H. Chen and D. Wagner. Mops: an infrastructure for examining
security properties of software. In Proceedings of the 9th ACM
Conference on Computer and Communications Security, pages
235–244, November 2002.
[10] B. Chess. Improving computer security using extending static
checking. In Proceedings of the 2002 IEEE Symposium on Se-
curity and Privacy, pages 160–173, May 2002.
[11] D. Chess and S. White. An undetectable computer virus. Virus
Bulletin Conference, 2000.
[12] M. Christodorescu and S. Jha. Static analysis of executables to
detect malicious patterns. In Proceedings of the 12th USENIX
Security Symposium (Security03), pages 169–186, Aug 2003.
[13] M. Christodorescu and S. Jha. Testing malware detectors. In
Proceedings of the ACM SIGSOFT International Symposium
on Software Testing and Analysis (ISSTA04), pages 34–44, July
2004.
[14] M. Christodorescu, S. Jha, S. Seshia, D. Song, and R. Bryant.
Semantic aware malware detection. In Proceedings of the 2005
IEEE Symposium on Security and Privacy, May 2005.
[15] M. Ciubotariu. Netsky: a conﬂict starter? Virus Bulletin, pages
4–8, May 2004.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
[16] F. Cohen. Computer viruses: Theory and experiments. Comput-
ers and Security, 6:22–35, 1987.
Operating system protection through program
[17] F. Cohen.
evolution.
February 1998.
Available online at URL
http://all.net/books/IP/evolve.html. Last Accessed: 01 Novem-
ber 2005.
[18] C. Collberg and C. Thomborson. Watermarking,
tamper-
prooﬁng, and obfuscation - tools for software protection. IEEE
Transactions on Software Engineering, 28(8):735–746, August
2002.
[19] C. Collberg, C. Thomborson, and D. Low. A taxonomy of ob-
fuscating transformations. Technical Report 148, Department of
Computer Science, University of Auckland, July 1997.
[20] Compuware Corporation. Debugging blue screens. Technical
Paper, September 1999.
[21] M. Debbabi, M. Girard, L. Poulin, M. Salois, and N. Tawbi.
Dynamic monitoring of malicious activity in software systems.
Symposium on Requirements Engineering for Information Secu-
rity (SREIS’01), March 2001.
[22] J. Gifﬁn, S. Jha, and B. Miller. Detecting manipulated remote
call streams. In Proceedings of 11th USENIX Security Sympo-
sium (Security’02), 2002.
[23] I. Goldberg, D. Wagner, R. Thomas, and E. Brewer. A secure
environment for untrusted helper applications. In Proceedings
of the 6th USENIX Security Symposium, July 1996.
[24] J. Gordon.
Lessons from virus developers: The bea-
gle worm history through april 24, 2004.
Secu-
at URL
rity Focus, May 2004.
Available online
http://downloads.securityfocus.com/library/BeagleLessons.pdf.
Last accessed 01 November 2005.
[25] Intel Corp. Ia-32 intel architecture software developers manual.
vols 1–3. Intel Developers Guide, 2003.
[26] T. Jensen, D. Metayer, and T. Thorn. Veriﬁcation of control ﬂow
based security properties. In Proceedings of the 1999 IEEE Sym-
posium on Security and Privacy, May 1999.
[27] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna. Static dis-
In Proceedings of the 13th
assembly of obfuscated binaries.
USENIX Security Symposium (Security’04), August 2004.
[28] C. Kruegel, W. Robertson, and G. Vigna. Detecting kernel-level
rootkits through binary analysis. In Proceedings of the 20th An-
nual Computer Security Applications Conference (ACSAC04),
2004.
[29] X. Lai and J. Massey. A proposal for a new block encryption
standard. In Proceedings of the workshop on the theory and ap-
plication of cryptographic techniques on Advances in cryptol-
ogy, pages 389–404, 1991.
[30] K. Lawton. Bochs: The open source ia-32 emulation project.
Available Online at URL http://bochs.sourceforge.net, Last Ac-
cessed: 04 November, 2005.
[31] C. Linn and S. Debray. Obfuscation of executable code to im-
prove resistance to static disassembly.
In Proceedings of the
10th ACM Conference on Computer and Communications Se-
curity, October 2003.
[32] R. Lo, K. Levitt, and R. Olsson. Mcf: A malicious code ﬁlter.
Computers and Society, 14(6):541–566, 1995.
[33] M. Loukides and A. Oram. Getting to know gdb. Linux Journal,
1996.
[34] C. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwoo. Pin: Building cus-
tomized program analysis tools with dynamic instrumentation.
In ACM SIGPLAN Conference on Programming Language De-
sign and Implementation, pages 190–200, 2005.
[35] LURHQ.
Sobig.e - evolution of
Techni-
cal Report. LURHQ, 2003.
Available online at URL
http://www.lurhq.com/sobig-e.html. Last accessed 01 Novem-
ber 2005.
the worm.
[36] J. Maebe, M. Ronsse, and K. De Bosschere. Diota: Dynamic in-
strumentation, optimization and transformation of applications.
Compendium of Workshops and Tutorials held in conjunction
with PACT02’, 2002.
[37] McAfee. W32/hiv. Virus Information Library, October 2000.
Available online at URL http://vil-origin.nai.com/vil/. Last ac-
cessed 28 Oct. 2005.
[38] McAfee. W32/mydoom@mm. Virus Information Library,
2004. Available online at URL http://vil-origin.nai.com/vil/.
Last accessed 28 Oct. 2005.
[39] G. McGraw and G. Morrisett. Attacking malicious code: Re-
port to the infosec research council. IEEE Software, 17(5):33–
41, October 2000.
[40] N. Nethercote and J. Seward. Valgrind: A program supervision
framework. 3rd Workshop on Runtime Veriﬁcation, 2003.
[41] T. Ogiso, Y. Sakabe, M. Soshi, and A. Miyaji. Software ob-
fuscation on a theoretical basis and its implementation. IEICE
Transactions on Fundamentals, E86-A(1), 2003.
[42] V. Paxon. Bro: A system for detecting network intruders in real-
time. In Proceedings of the 7th USENIX Security Symposium,
January 1998.
[43] J. Robbins. Debugging windows based applications using
windbg. Miscrosoft Systems Journal, 1999.
[44] K. Scott, N. Kumar, S. Velusamy, B. Childers, J. Davidson, and
M. Soffa. Reconﬁgurable and retargetable software dynamic
translation.
In 1st Conference on Code Generation and Opti-
mization, pages 36–47, 2003.
[45] P. Singh and A. Lakhotia. Analysis and detection of computer
viruses and worms: An annotated bibliography. ACM SIGPLAN
Notices, 37(2):29–35, February 2002.
[46] L. Spitzner. Honeypots: Tracking hackers. Addison-Wesley,
2003. ISBN: 0-321-10895-7.
[47] Symantec.
Understanding
and managing
morphic
at
http://www.symantec.com/avcenter/whitepapers.html.
Accessed: 28 October 2005.
Available
viruses.
online
poly-
URL
Last
[48] P. Szor. The art of computer virus research and defense. Addi-
son Wesley in collaboration with Symantec Press, 2005.
[49] TrendMicro.
Bkdr.surila.g (w32/ratos).
cyclopedia, August 2004.
http://www.trendmicro.com/vinfo/virusencyclo/.
cessed 28 Oct. 2005.
Virus En-
Available online at URL
ac-
Last
[50] A. Vasudevan and R. Yerraballi. Stealth breakpoints. 21st
Annual Computer Security and Applications Conference (AC-
SAC’05), pages 381–392, December 2005.
[51] A. Vasudevan and R. Yerraballi.
Spike: Engineering mal-
ware analysis tools using unobtrusive binary-instrumentation.
29th Australasian Conference in Computer Science (ACSC’06),
pages 311–320, January 2006.
[52] VMWare Inc. Accelerate software development, testing and de-
ployment with the vmware virtualization platform. Technical
Report, VMWare Technology Network, June 2005.
[53] C. Wang, J. Davidson, J. Hill, and J. Knight. Protection of
software-based survivability mechanisms. In Proceedings of In-
ternational Conference of Dependable Systems and Networks,
2001.
[54] D. Wheeler and R. Needham. Tea, a tiny encryption algorithm.
In Proceedings of the 2nd International Workshop on Fast Soft-
ware Encryption, pages 97–110, 1995.
[55] G. Wroblewski. General method of program code obfuscation.
In Proceedings of the International Conference on Software En-
gineering Research and Practice (SERP), June 2002.
[56] T. Yetiser.
Polymorphic viruses, implementation, detection
and protection. VDS Advanced Research Group, P.O. Box
9393, Baltimore, MD 21228, USA. Available online at URL
http://vx.netlux.org/lib/ayt01.html. Last accessed 28 Oct. 2005.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply.