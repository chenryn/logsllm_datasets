### Code Obfuscation and Performance Analysis

The amount of code obfuscation, particularly through the use of jumps, leads to an increase in block creations and xfer-stub overheads (as detailed in Section 4.1.3) for the specified analysis ranges.

**Figure 10b** illustrates the latency of Cobra when employing block-coalescing on the same analysis ranges. Block-coalescing helps reduce latency caused by xfer-stubs, especially in code-streams involving loops. As shown in **Figure 10b**, analysis ranges 2 and 3, which contain a large number of loops, exhibit significantly lower overall latency with block-coalescing compared to their latency without it (as seen in **Figure 10a**). However, for analysis range 1, there is negligible performance gain from block-coalescing due to the presence of very few loops. It is noteworthy that the latency of analysis range 4 with block-coalescing is higher than its latency without block-coalescing (as depicted in **Figure 10a**). This is because W32/Ratos, being metamorphic, generates varying amounts of code for a given functionality and embeds random anti-analysis code fragments in different instances of its deployment.

### Further Latency Reduction with Skipping

Skipping further reduces overall latency by excluding standard and/or already analyzed code-streams from the analysis process. **Figure 10c** shows the performance of Cobra with both block-coalescing and skipping applied to standard kernel code-streams. The graph in **Figure 10c** indicates that the latency of analysis ranges 1 and 2 is further reduced compared to their latency without skipping (as shown in **Figure 10b**). This is because the code-streams in these ranges invoke standard kernel functions such as `VirtualProtect`, `KeSetEvent`, and `KeRaiseIrql`, which are excluded from localized-executions with skipping. However, analysis range 4 shows negligible improvement since it does not involve any calls to standard code-streams.

**Figure 10d** demonstrates the performance of Cobra with block-coalescing and skipping on both standard and already analyzed malware code-streams. For example, the single-step handler of W32/Ratos repeatedly invokes a procedure that handles a variant of the TEA decryption algorithm. This procedure remains semantically unchanged and can be skipped after a single analysis. As shown in **Figure 10d**, analysis ranges 1–4 have a reduced latency compared to their counterparts in **Figure 10c**. Notably, analysis range 4, which showed minimal change with skipping of standard code-streams, exhibits a noticeable latency reduction when skipping is applied to already analyzed malware-specific code-streams.

### Conclusions

The performance of the framework is highly dependent on the nature of the code being analyzed and the style of analysis employed (e.g., selecting analysis ranges, coalescing blocks, and choosing code-streams to skip). However, the measurements provide a general indication of the expected latency. As shown in **Figure 10**, even the worst-case latency (without block-coalescing and skipping) is within acceptable limits for interactive analysis.

### Summary of Cobra Framework

Cobra is a stealthy, efficient, portable, and user-friendly dynamic fine-grained malicious code analysis framework designed to overcome the limitations of current research in fine-grained code analysis for malware. Cobra facilitates the development of powerful fine-grained malware analysis tools, essential for combating increasingly sophisticated malware. The framework operates without making visible changes to the executing code, rendering it undetectable and uncounterable. Cobra can capture multithreaded, SM-SC, and obfuscated code in both user- and kernel-mode while maintaining a performance latency suitable for interactive analysis. It supports selective isolation, enabling fine-grained analysis of specific malware code-streams in real-time, co-existing with normal code-streams. Currently, Cobra runs on Windows (9x, NT, 2K, and XP) and Linux OSs on IA-32 (and compatible) processors. Its architecture has minimal OS dependency and abstracts platform-specific details, facilitating portability to other platforms. Cobra's easy-to-use APIs enable the construction of powerful fine-grained malware analysis tools. We believe Cobra is the first to tailor a fine-grained code analysis strategy specifically for analyzing malware code-streams. Future work includes improving the framework's performance and integrating Cobra into a comprehensive malware analysis environment currently under development.

### References

[1] K. Ashcraft and D. Engler. Using programmer-written compiler extensions to catch security holes. In Proceedings of the 2002 IEEE Symposium on Security and Privacy, pages 143–159, May 2002.
...
[56] T. Yetiser. Polymorphic viruses, implementation, detection, and protection. VDS Advanced Research Group, P.O. Box 9393, Baltimore, MD 21228, USA. Available online at URL http://vx.netlux.org/lib/ayt01.html. Last accessed 28 Oct. 2005.

---

This optimized version aims to improve clarity, coherence, and professionalism, ensuring that the text is more accessible and informative.