e
s
(
%
e
m
T
i
100$
10$
1$
0.1$
0.01$
0.001$
IL'to'ILIL$Transla0on$
Symbolic$Execu0on$
Ini0al$Model$Crea0on$
Temporal$Execu0on$
Graph$Genera0on$
Model$Transla0on$
Symbolic$Model$Checking$
PLC%Program%Analysis%and%Formal%Veriﬁca9on%Steps%
Traﬃc$Light$
Assembly$Way$
Stacker$
Sorter$
Train$
PID$
Traﬃc"Light"
Assembly"Way"
Stacker"
Sorter"
Train"
PID"
'
s
e
t
a
t
S
'
f
o
'
r
e
b
m
u
N
1000"
100"
10"
1"
State"Space"Size"
PLC'Program'Analysis'and'Formal'Veriﬁca<on'Steps'
Fig. 7. Time Requirements for All Case Studies on Raspberry Pi.
The reported numbers, only 4K states for a full 14 horizon
analysis, proves the effectiveness of the usage of symbolic
execution at reducing the state space size.
the input values affect
Figure 6 shows a sample generated execution graph for
the Assembly Way case study with a model checking bound
of 4. The safety requirement included two atomic propositions
a and b. Thus, each state is assigned with a pair of concrete
atomic propositions, and the state transitions are labeled with
the path predicates as Boolean expressions in inﬁx order. For
readability purposes, we did not include the symbolic variables
and their values in each state. The atomic propositions are
both true regardless of the input values in states S0, S1,
S2, and S3. However,
the atomic
propositions starting in state S3. Out of S3’s four possible
children, |{a,b}|2 = 4, three have been created. Only the path
condition for ha : 0 b : 0i was not satisﬁable.
TSV runs the symbolic model checking engine on the re-
ﬁned and atomic proposition-level abstract temporal execution
graph. Figure 5(d) shows the run times to translate the abstract
TEG into the model checker’s syntax, which is not a signiﬁcant
source of overhead. Figure 5(e) shows the time requirement
results for the symbolic model veriﬁcation that takes no more
than 10 and 90 seconds, on the desktop and Raspberry Pi
respectively. In summation, the total average overheads of less
than three minutes for checking with bound 10 are within
reason for an analysis that is only executed once when new
code is uploaded. Of course, in the case of malicious code
uploading, this bound does not affect productivity, as safety
checks are done independently of plant execution under the
previous, legitimate code.
We ran the same experiments for all of our case studies.
Figure 7 shows how much each analysis step contributes to
veriﬁcation for each case study on the Raspberry Pi with
bound 6. Requirements for each step vary due to different
factors. The costliest test case for symbolic execution was the
AssemblyWay, which explored the most feasible paths. The
single costliest operation was construction of the TEG for the
train interlocking. This was caused by checking the feasibility
of very large path predicates in the symbolic scan cycle.
Despite the variance between use cases, it is clear that the
net overhead is within reasonable bounds for all case studies.
Figure 8 shows the state space cardinality for the generated
temporal execution graphs for the case studies. It is noteworthy
that there is not a direct correlation between the state space
size and the overall analysis time requirement, e.g., the Train
case study results in the smallest state space and yet requires
Fig. 8. State Space Size for All Case Studies on Raspberry Pi.
the largest amount of time to ﬁnish the overall analysis.
E. Scalability
it
that
is crucial
To make sure that TSV can be used for real-world PLC
code veriﬁcations,
it can handle safety
properties of realistic sizes, i.e., number of atomic propo-
sitions, efﬁciently. To that end, we investigated typical and
frequently-used linear temporal logic-based software speciﬁ-
cation formula10 [10], where the largest predicate includes
5 atomic propositions. Figure 9 shows the results of our
experiments with TSV that can handle requirement predicates
with 9 atomic propositions within approximately 2 minutes
on average. It is noteworthy that handling additional safety
properties only requires rerunning the atomic proposition value
concretization on the temporal execution graph. Consequently,
the time requirement to process every new security predicate is
often negligible because the execution graph generation is the
dominant factor in TSV’s overall performance overhead (see
Section VI-D).
VII. RELATED WORK
We now review several previous approaches to safety
veriﬁcation of PLC software. The set of approaches reviewed
here represent the most applicable in terms of ability to run
directly on PLC code without requiring engineers to author an
additional high-level system model. As shown in Table I, our
approach can check more features than any previous approach
to PLC analysis. Existing tools for binary analysis of general
purpose programs are omitted as they do not handle PLC
architectural traits like multi-indexed memories.
10http://patterns.projects.cis.ksu.edu/documentation/patterns/ltl.shtml.
11
TABLE I.
COMPARISON OF ANALYZED FEATURES WITH RELATED WORK. RELATED APPROACHES ARE ABBREVIATED: SAT=SAT SOLVING,
THM=THEOREM PROVING, MOD=MODEL CHECKING
Approach
SAT
SAT
Thm
Thm
Mod
Mod
-
Park et al. [22]
Groote et al. [14]
Homer [15]
Biha [21]
SABOT [18]
Canet et al. [6]
TSV
X
X
X
X
X
X
X
Logic
Boolean
Enum
Branching
Blocks
Function
Cond.
MCR
Numeric
X
X
X
X
X
X
X
X
X
X
X
X
X
Logic
Timers
Nested
X
X
X
X
X
Detection
Edge
Blocks
Data
Counters
Pointers
X
X
X
X
tems, distributed control systems, and PLCs. Such guidelines
are also used in the energy industry [20], [32]. It has, however,
been argued that compliance with these standards can lead to
a false sense of security [24], [33].
There have also been efforts to build novel security mech-
anisms for control systems. Mohan et al. [19] introduced a
monitor that dynamically checks the safety of plant behavior.
A similar approach using model based intrusion detection was
proposed in [7]. Goble [13] introduce mathematical analysis
techniques to evaluate various aspects, such as safety and
reliability, of a given control system including the PLC devices
quantitatively. However, the proposed solution focuses mainly
on accidental failures and does not investigate intentionally
malicious actions.
Compared with existing binary analysis tools, TSV is more
apt for verifying temporal properties. For example, platforms
such as BitBlaze [30], are aimed mainly at comparing binary
programs, identifying malicious behavior, and exploit genera-
tion. Additionally, compared with the existing work combining
symbolic execution and model checking to reduce state space
explosion, TSV is the only solution enabling binary-level
analysis.
PLC vendors themselves have included some rudimentary
security measures into their solutions. Based on market data by
Schwartz et al. [28], we studied the security measures used by
PLCs accounting for 74% of market share. This included PLCs
from Siemens (31%), Rockwell (22%), Mitsubishi Electric
(13%), and Schneider Electric (8%). We found that all four
vendors use only password authorization,
typically with a
single privilege level. Furthermore, password authentication
measure can be disabled in all four systems. Additionally,
certain Siemens systems use client-side authentication. This
allows the attacker to completely bypass authentication by
implementing his own client for uploading malicious code.
VIII. CONCLUSIONS
In this paper, we presented TSV, a trusted veriﬁcation
platform for programmable logic controllers, that allows last
step security veriﬁcation of the control commands right before
they affect the physical system. TSV achieves a reasonable
efﬁciency via using a new hybrid symbolic execution-enable
model checking algorithm. We implemented a real-world pro-
totype of the TSV framework on an independent Raspberry PI
chip with minimal attack surface. Our evaluation results shows
Fig. 9. Scalability Analysis for Various Predicates
The most basic approaches are those using SAT-based
model checking. Park et al. [22] handle only Boolean logic.
This had the advantage of being able to analyze larger
sequence-based control systems, but is only narrowly appli-
cable. Groote et al. [14] employs a similar technique, but
is able to handle timers by modeling the exact wall clock
execution time. This assumes that the approximate time taken
for each scan cycle is known, and fails if scan cycle times
vary too greatly depending on input. An improved handling
of timers can be found in SABOT [18], which models their
termination as a nondeterministic Boolean value. Additionally,
TSV’s improvements over SABOT allow for virtually all PLC
programs to be analyzed, as opposed to exclusively Boolean
variables and timers, which SABOT is limited to.
implement numerical
The two theorem proving based approaches [15], [21]
handle numerical instructions, but not do not implement rules
for overﬂow checks or mixed bit vector and integer arithmetic.
The model checking approach used by Canet et al. [6], uses
the same modeling as TSV for conditional branches, but does
not
instructions, which lead to state
space explosion. Our use of symbolic execution eliminates
this explosion problem. TSV’s ability to handle more PLC
features (in most cases all available features) than previous
work is thanks to the use of ILIL, which reduces side effects
that would otherwise require many high-level modeling rules
into a small set of low-level primitives.
We now review some representative past efforts at securing
control systems. Stouffer et al. [31] present a series of NIST
guideline security architectures for the industrial control sys-
tems that cover supervisory control and data acquisition sys-
12
0.001 0.01 0.1 1 10 100 1000 1 2 3 4 5 6 7 8 9  Time (seconds) Predicate Size (# atomic propositions) Temporal Execution Graph Generation Symbolic Model Verification that TSV can be deployed as a bump-in-the-wire portable
device for efﬁcient and practical veriﬁcation of the control
programs before they are uploaded to programmable logic
controllers.
ACKNOWLEDGEMENTS
This material is based upon work supported by the Ofﬁce
of Naval Research under Award Number N00014-12-1-0462,
and Advanced Research Projects Agency-Energy under Award
Number 20130028603. The authors would like to thank Tim
Yardley for his constructive comments and technical help with
the project.
REFERENCES
[1] Shodan. http://www.shodanhq.net, 2013.
[2] Andreas Bauer, Martin Leucker, and Christian Schallhart. Runtime
ACM Transactions on Software
Veriﬁcation for LTL and TLTL.
Engineering and Methodology, 20(4):14:1–14:64, 2011.
[3] Mordechai Ben-Ari. Mathematical logic for computer science. Springer,
2012.
[4] Dillon Beresford. Exploiting Siemens Simatic S7 PLCs. In Black Hat
USA, 2011.
[5] Rakesh B. Bobba, Katherine M. Rogers, Qiyan Wang, Himanshu
Khurana, Klara Nahrstedt, and Thomas J. Overbye. Detecting false
data injection attacks on dc state estimation.
In Proceedings of the
First Workshop on Secure Control Systems (SCS), 2010.
[6] G. Canet, S. Coufﬁn, J.-J. Lesage, A. Petit, and P. Schnoebelen. Towards
the Automatic Veriﬁcation of PLC Programs Written in Instruction List.
In IEEE International Conference on Systems, Man, and Cybernetics,
volume 4, pages 2449–2454, 2000.
[7] Steve Cheung, Bruno Dutertre, Martin Fong, Ulf Lindqvist, Keith
Skinner, and Alfonso Valdes. Using Model-based Intrusion Detection
for SCADA Networks. In Proceedings of the SCADA Security Scientiﬁc
Symposium, 2007.
[8] E. Clarke, O. Grumberg, and K. Hamaguchi. Another Look at LTL
In Formal Methods in System Design, pages 415–
Model Checking.
427. Springer-Verlag, 1994.
[9] Leonardo De Moura and Nikolaj Bjørner. Z3: An Efﬁcient SMT Solver.
In Tools and Algorithms for the Construction and Analysis of Systems,
pages 337–340. Springer, 2008.
[10] Matthew B. Dwyer, George S. Avrunin, and James C. Corbett. Patterns
in Property Speciﬁcations for Finite-State Veriﬁcation. In Proceedings
of the 21st international conference on Software engineering (ICSE),
pages 411–420. ACM, 1999.
[11] Nicolas Falliere, Liam O. Murchu, and Eric Chien. W32.Stuxnet
Dossier. Technical report, Symantic Security Response, October 2010.
[12] Orlando Ferrante, Luca Benvenuti, Leonardo Mangeruca, Christos
Sofronis, and Alberto Ferrari. Parallel NuSMV: a NuSMV Extension for
the Veriﬁcation of Complex Embedded Systems. In Computer Safety,
Reliability, and Security, pages 409–416. Springer, 2012.
[13] William M Goble. Control Systems Safety Evaluation and Reliability.
International Society of Automation, 2010.
J.F. Groote, S.F.M. van Vlijmen, and J.W.C. Koorn.
The Safety
Guaranteeing System at Station Hoorn-Kersenboogerd. In Tenth Annual
Conference on Systems Integrity, Software Safety and Process Security,
pages 57–68, June 1995.
[14]
[15] Ralf Huuck. Semantics and Analysis of Instruction List Programs.
Electronic Notes in Theoretical Computer Science, 115:3–18, 2005.
John Leyden. Polish Teen Derails Tram after Hacking Train Network.
http://www.theregister.co.uk/2008/01/11/tram hack/, 2008.
[16]
[17] Patrick McDaniel and Stephen McLaughlin.
Security and Privacy
IEEE Security and Privacy, 7:75–77,
Challenges in the Smart Grid.
2009.
[18] Stephen McLaughlin and Patrick McDaniel. SABOT: speciﬁcation-
based payload generation for programmable logic controllers.