建时间就会比远程复制时间长很多，所以连续性复制不会占去太多的总执行时间。
我们的日志文件以包、远程主机，及以秒计的时间戳命名，如果在单一远程主机上执行
多个构建，则可能会有文件名冲突的风险。在日志文件名内使用进程编号变量，$S，也
不是个好的解决方案，因为它在build-all单一调用内是固定常数。我们虽然可以使用
SS初始化计数器，这么做会在每次构建时增值且被用在日志文件的文件名中，但结果只
会让无意义的数字弄乱文件名。解决方案是在两个连续日志文件的产生之间，至少具有
一秒的间隔：sleep正是我们所需的。GNU的date提供&N（nanoseconds十亿分之
一秒）格式项，应该可以满足产生唯一的文件名的需求，无须用到sleep，但POSIX
与旧式date实现，缺乏这个格式项。为满足最大的可移植性，我们就由秒数处理：
sleep 1
1ogf11e=*$package.Shost.$now.1og**;
接下来要进入这个说明的最后部分：用于远程主机上实现构建的长命令，SSSH前置
nice命令是为了降低它的优先权，以避免与系统上的交互式工作竞争资源，即便很多工
作都是在远程系统上做的，但构建日志有时会很大，让$SSH要作的事情变多。
留意SSSH的第二个参数是以双引号界定的长字符串。在该字符串中，以货币符号前置
我们在$SSH参数字符串里所需要用到的命令语法根据运程主机上用户的登录ShelI而
定。我们极小心地限制该语法，让它能在所有一般性UNIXShell内正常运行，这么一
来才能让所有用户，即便是在不同主机上、使用不同登录Shell者都能使用build-al1。
我们无法要求任何地方都使用相同的登录Shell，因为在很多系统上，用户无法选择自己
要用的Shell.替代方案就是使用管道，将命令流传给每个主机上的BourneShell，不过
这么做会为每一个构建启动另一个进程，而让我们陷人更深的混乱：一次处理三个Shell
已经够滩的了
nice SSSH SSSHFLAGS Suserhost *
在登录Shell先出现在命令序列的情况下，如果SBUILDBEGIN脚本存在，则在远程系统
上执行。这么做可提供登录定制，例如当Shell启动文件无法增加PATH变量时（例ksh
www.TopSage.com
---
## Page 236
224
第8章
与sh）。它也会将一些额外的信息写至标准错误输出或标准输出，这样当然也可以写到
构建日志文件中。Bourne-Shell家族里的Shell使用点号命令来执行目前目录中的命令，
面C-Shell家族里的 Shell 则使用source命令。baah与zBh Shell支持这两种命令。
问题是，如果点号命令指定的文件不存在，则有些Shell，包括POSIX的、会中止执行
点号命令。这么一来，尽管true命令是用于条件式的结尾处，也会使得单纯的。
SBUILDBEGIN11true程序代码失败。因此，我们还会需要文件存在与否的试，面
且也必须处理8ource命令。因为两个Shell都认得点号命令与source命令两者，所以
我必须在单一的复杂命令里做这件事，这条命令依赖于布尔运算符相等的优先权：
test -f SBULLDBBGIN6&. $BUILDBEGIN 11\
test -f $BUILDBEGIN && source SBUILDBEGIN 11\
true ·  
我们不爱用这么复杂的语句，但build-all严格的设计需求，务隶可运行于所有登录
Shell中，让我们不得不这么做，我们也找不到更简化的可接受解决方案。
我们假设在buiId-al1使用之前，已做过启动脚本的调试了，否则，如果SBUILDBEGIN
脚本的执行是在错误状态下终止的话，则它可能会被试图执行两次。
长久以来的使用经验告诉我们，记录在构建日志里的额外信息会很有用，所以下面一连
事的echo命令就是为了这个目的，特意安排的格式只是为了让日志文件更容易阅读：
echo 'Package;
Spackage':
echo Archive:
echo *Date1
$PARFILE':
$now':
echo 'Local hostt
$USER':
SLOGDIR':
eeho *Local 1og directory:
echo *Local log file1
echo 'Remote user:
Scser' 1
$logfile';
echoRemote directory1".Sbuilgdir1
有时知道花了多少时间构建也是很有用的（我们有一台较老田的系统，在构建GNUC
编译器时花了将近一天），所以我们的脚本也会报告开始与结束的日期。这些全取自于
远程主机，因为每台主机的时区有可能不同，也可能会有时间差的向题，而且稍后将已
安装文件的时间霸与构建日志的项目作匹配，也是很重要的。由于echo设有适用的可
移植式用法，所以我们使用printf：
printf 'Renote date:
date $DATEFLAGS :
同样地，我们也记录系统与GNU编译器的版本信息，因为在日后的错误报告里会需要
用到：
www.TopSage.com
---
## Page 237
产生脚本
225
printf *Remote uname:
printf *Remote gce verslon:-
unane -a Il true :
gcc --version 1 head -n 1 11 echo 1
：
printf *Remote g++ version1
g++ --version 1 head -n 1 11 echo :
由于其他编译器没有一致的方式可取得版本信息，所以我们无法在build-al1中处理
该工作，取面代之的是，我们可以自：SBUILDBBGIN脚本里，通过适当的命令，产生想
要的报告。接下来，我们的脚本提供其他信息如下：
echo *Configure envlronment:sSTRIPCOoNTS Senvfile 1 SJOMINES':
echo*
‘Bxtra environnent:
SEXTRABNVIRONHEI
echo*
‘Configure directoty:
rstetz onbrguo. ouoe
SONPIOURELAGS1
SOONFIGUREDIR';
echo
‘Make all target8:
$ALLTARGETS';
$CHECKTARGETS′1
磁盘空间耗尽是常见的导致错误发生的原因，所以我们在构建的前与后，都使用df报
告可用空间：
df sbui1lddir 1 $IND&NT :
configure与make都可能被环境变量影响，所以我们最后的一道工作就是排序日志文
件标头：
echo 'Environment:′;
env I env LC_ALL=C sort 1 $INDENT ;
echo
管道中间的env命令乃是为了确保脚本可正常运行于所有Shell下，包括C-Shell家族成
员。
和在本地的设置相同，我们也在远程系统上设置权限掩码，允许组成员完整访间，井且
除此之外的其他人都有读取权限：
unask SUMASK :
包存档文件已经存在于构建目录内，所以我们切换到该目录，如果cd失败，则以错误
状态退出：
cd $bui1ddir 11 exit 1 :
下一步：删除所有旧的存档文件树，这里使用r#的绝对路径，因为这些命令执行于Shell
交互模式下，而有些站点对于这个命令将其设置别名为具有-i的交互式选项：
/bin/rm -rf $bui1ddir/$package 1
www.TopSage.com
---
## Page 238
十第8常网
226
网
有时我们会因为改变了编译器或编译选项，而要再执行一次构建操作，所以递归别除是○1m
有其必要的，这可以确保我们能够从干净的分发开始。rm里的-f选项是要求静默地处
理对于不存在目录的任何抱想。
一个递归文件树的删除是相当危险的操作，也可能成为攻击的目标。因为package是
从信赖的basename命令中取得，我们能够确信它不包含斜杠，因此可以只参照到当前
目录。将Sbuilddir/加人到rm的参数中，则可提供起码的安全性，不过还是不够，因
为不管是builddir或者是package都可能被设置为一个点号；即当前的目录。
这种情况确实会论为安全漏洞，而我们也无法再多作些什么保护，所能做的只有警告标
语。很明显，这个程序应该绝对不要以root身份执行。我们在脚本启动的一开始，就
使用此语旬，则可阻止用户这么做：
test **id -u** -eq 0 6s \
error For security reasons, chis program must Nor be run by root
在我们的所有系统里，只有SunSolaris的id缺乏-u选项的支持，不过我们设置了PATH，
让程序先找到GNUcoreurit版本的id
注意：包安装命令营告诉你：请以root账号构建与安装软件，其实你应该要忽略此指示：因为
只有核少数的包需要这样的权限，而且，即便是要，也只有在安装多骤才需要。
接下来，解开存档文件：
SPAR Sparbaselocal ;
重要的是你必须了解：SPAR是在初始化主机上被展开，但在远程主机上执行。特别是
我们假设tar是支持-j与-z选项的GNU版本，且unzip与jar都可用。对于这个
脚本的每个用户，我们都预期他已在每个远程主机上做好Shell启动文件的适当设置，确
保这些程序都能被找到，我们不能为这些程序提供固定的路径，因为这些路径在每个远
程主机上都可能不尽相同。
如果存档文件已复制到远程主机上，则parbaselocal与parbase会是一致的值，且因
为远程主机已不再需要包存档文件，所以我们将它副除：
我们已准备好切换到包目录开始构建。对于遵循广泛使用的GNUProject惯例的软件包
来说：该目录为包目录的最顶层。遗的是，有些包会将构建目录理在文件树的较深处，
像用来编写脚本以及加速构建窗口系统界面的Tcl与Tk工具就是。命令行的--cd选项
www.TopSage.com
---
## Page 239
产生脚本
227
提供了存储在CONFIGUREDIR里的构建目录的相对路径，用来覆盖掉它的点号（.）默
认值。我们接下来会需要用到package与CONFIGUREDIR这两个变量以切换至构建目录，
且如果切换失败，会以错误码退出：
cd $package/$CONPIGUREDIR 11 exit 1 1
许多包现已含有configure脚本，所以我们可以试试它，如果找到，则以envfile所
提供的任何额外环境变量执行它。我们也会传递任何由--configure选项提供的额外
标志，大部分包不需要这类标志，不过有些较复杂的就要：
test -f configure 乐s\
chmod a+xconfigure && \
S&XTRAENVIRONMENT\
nice tine ./configure $CONFIGUREPLAGS :
chmod命令乃用来加人执行权限，在这里使用的理由有两个：首先，由于我们偶尔会遇
到缺乏该权限的包存档文件，再则，是因为现行Java的jar存档文件格式会忽略记录该
权限（注5）。前置nice命令可降低工作优先权，这么微可对远程系统的影响降到最低。
前置time命令，可报告configure执行时间。我们见过一些非常大的配置脚本，这么
做有助于记录它们的执行时间以作为下一版构建时间的估计。
我们现在要进入操作最多的地方：实际的构建与包的验证，一样是前置nicetime，并
由--al1与--check选项（或它们的默认值）提供的make参数：
nice tine make $ALL/TARG&TS &k nice tIme make $CHECKTARGETS ;
make命令背后隐藏了很多工作，不过完成该工作的规则已通过开发人员写在Makefile
里了，我们终端安装人员通常不必理会内容是什么。
我们希望成功构建完成时，在日志文件内看到报告类似Al1testspassed1这样的信
息，或其他容易理耀的报告，让我们知道一切都好。验证测试是非常重要，绝不应该跳
过，即便是包在开发站点里已运行无误，但没有理由相信它在我们的站点里也会运行得
这么顺利，因为有这么多的东西可能导致它出错：不同的系统架构、编译器、环境变量、
文件系统、本地定制设置与调校、操作系统版本、查找路径、共享函数库、系统标头文
件、XWindowsSystem默认值等等，很多都有可能导致错误发生。
我们现已包装好远程命令，还伴随几行日志文件中最后的报告：
echo *Disk free report for Sbui1ddir/$package:′ :
注5：
这很有可能是设计上的服症，固为展层的lnfoZip格式支持它。
www.TopSage.com
---
## Page 240
228
第8章
df $bui1ddir 1 -SINDENr :
printt ·Renote date:
date SDATEFLAGS :
SBUILDEND脚本就像SBUILDBEGIN脚本一样，在根目录下，提供任何最后的额外日志
文件报告，但true是确保成功地完成：
ed' ;
test -f SBUILDEND && SOUrce $BUILDEND 1I\
Crue 1
build_one函数的最后两行是关闭远程命令列表与函数体，重定向标准输出与标准错误
输出两者到日志文件。最重要的是，在后台执行远程命令，使得该执行可以马上在主体
的内部循环中继续。远程Shell的输人被重定向到null设备，所以它不会悬在那里等待
用户输人：
这样大小的程序与其功能，必定需要在线帮助。由于篇幅的关系，不允许我们在此展现
build-al1的手册页，不过此脚本与它的手册页文件都在本书网站上。
完整的脚本具有一些注释，且在开始处以字每顺序重新排序函数，这些都整理在例8-2
里。虽然这有320行之多（省略注释与空行的情况下），但花时间了解我们写程序的方
式，其实是很受用的。一且新分发的包被取到本地系统上时，一个单行命令便能以并行
处理的方式，在所有构建主机上启动构建与验证。经过一段时间的等待之后，安装程序
会检查构建日志以得知它们的成功或失败，并决定在哪些主机上可以安全地执行make
install。将软件安装在系统上，之后构建目录便可以从远程系统上制除了。
注意：构建失败不能归因于本地的错误时，则应报告给包开发人员。很少有开发人员会广泛使用
各种平台，所以唯有来自安装者的反馈，他们才能作出更具可移植性且健全的包，在执行
之前，你当热应该先看看包的发行注意事项（多半是在叫做BUGS、FAQ、INSTALL、
PROBLEMS藏README的文件内），再看看是不是你发现的这个间题已经有人提出了，只是
尚未修正。在这样的软件模式下，开发人员可以很快地得到安装者的反馈，最后的结果就
是高生产力，而Eric Raymond也将此编写成书（注6）。
注6:
fTbe Cathedral and tbe Bazaar: Musings on Linux and Open Source by an Accidental
Revolutionary3(O'Reilly).
www.TopSage.com
---
## Page 241
产生脚本
例8-2：build-all 序
com
1/bin/sh -
在一台或多台构建主机上，并行构建一个或多个包
语法：
build-all [
=-7 }
--al1 *...*}
--configure *...* ]
--check *...* 1
--logdirectory dir ]
--help 1
--source*dir...*]
-on *[usere]host[:dir][,envfile] ...*]
--versicn }
package (s)
可选用的初始化文件：
SHONE/.build/directories
list of source directories
SHOME/,bui1d/userhosts
list of [user9]host[:dir](,envfile]
IFS='
PATH=/usr/1oca1/bin:/bin:/usr/bin
export PATH