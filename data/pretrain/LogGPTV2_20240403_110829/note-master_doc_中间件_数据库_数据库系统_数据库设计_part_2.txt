  - 说明合法关系集上的约束 **平凡函数依赖**：如果y ⊆ x，则称 x→y 的函数依赖是平凡的 用F+表达F集合的闭包，也就是能够从给定F集合推导出来的函数依赖集合，说人话就是平凡函数依赖是指一个属性集（关系属性的集合）能够决定它的子集，也就是说，当一个属性集的值相同时，它的子集的值也一定相同
### BC范式
属于BC范式的条件是： 对于F+中所有形如a→b的函数依赖(a ⊆ R,b⊆R ),下面至少有一项成立：
BC范式就是要求一个表中的每个属性都只跟主键有关，而不跟其他属性有关
- a → b是平凡的函数依赖（b ⊆ a）
- a是模式R的一个超码 分解不属于BCNF的一般规则： 设R为一个不属于BCNF的一个模式，则存在至少一个非平凡的函数依赖a→b，其中a不是R的超码，我们用两个模式取代R：
- （a ∪ b）
- （R - （b - a ）） 进行迭代直到得到一个BCNF模式集合
### BCNF和保持依赖
由于设计使得函数依赖的强制实施在计算很困难，因此称这个设计不是保持依赖的
### 第三范式
属于第三范式的条件，下面至少一项成立：
- a → b是一个平凡的函数依赖
- a 是R的一个超码
- b - a的每个属性都包含于R的一个候选码中
满足BC范式的关系模式一定满足第三范式，第三范式与 BC 范式的区别在于，BC 范式的依赖是可以推导的，而第三范式依赖只是直接有关：第三范式就是要求一个表中的每个属性都只跟主键直接有关，而不跟其他属性有关
### 其他范式
#### ER模型和规范化
- 正确定义的 ER 图就不需要太多进一步的规范化
#### 属性和联系的命名
- 数据意义相同上的字段使用相同命名最佳
- 大部分联系名都是两个实体名之间加下划线
#### 为性能去规范化
有些范式可能需要在修改或者查询数据时进行更多的操作，这会影响性能，常见去范式提高性能的方式：
1. 信息冗余，如在订单表存放购买人信息
2. 物化视图，虽然还有冗余，但是一致性的维护是由数据库来进行
### 函数依赖理论
#### 函数依赖集的闭包
逻辑蕴含： A → B,B → h 那么 A → H被逻辑蕴含
##### Amstrong 公理
一组关于函数依赖的基本规则，它们可以用来推导出一个关系模式中所有的函数依赖
- 自反律：若a为一属性集且 b ⊆ a，则a → b成立
- 增补律
- 传递律
- 合并律
- 分解律
- 伪传递律
#### 属性集的闭包
如果 a → B，我们称属性B被a函数确定
#### 正则覆盖
#### 无损分解
R1,R2是R的分解，如果用R1,R2替代R没有信息损失，则该分解是无损分解
#### 保持依赖
### 分解算法
#### BCNF分解
#### 3NF分解
#### BCNF和3NF的比较
应用函数依赖进行数据库设计的目标：
- BCNF
- 无损
- 保持依赖
#### 使用多值依赖的分解
##### 多值依赖
函数依赖有时成为**相等依赖** 多值依赖成为**元组产生依赖** 设R为关系模式，让a ⊆ R 且 b ⊆ R 多值依赖 a -> -> b在R上成立的条件是：
### 4NF分解
## 数据库设计的其他方面
- 数据约束和关系数据库设计
显式声明约束的优点：
- 自动保持数据的一致性
- 一些约束在数据库模式的设计中非常有用
- 当然也可以提高访问效率
缺点：
在数据更新时，执行约束会在性能上带来潜在的高代价
### 使用需求：查询、性能
主要的两个度量方法：
- 吞吐量
- 响应时间
### 时态数据建模
时态数据时具有关联时间段的数据 **快照**快照是指一个特定时间点上该数据的值，除了可以将每行记录关联一个时间段来代表有效性之外，也有专门的时序数据库用来解决这种需求，[金融系统](/软件工程/架构/系统设计/金融系统.md#数据存储)用的很多
### 授权需求
不同的用户与组织能看到数据会受到不同的限制，这块是[认证授权](/计算机网络/网络安全/认证与授权.md)需要干的
### 数据流、工作流
工作流表示一个流程中的数据和任务的组合
当用户在执行工作流中的任务时，工作流会与数据库系统进行交互，除了工作流操作的数据之外，数据库还可以存储工作流自身的数据
### 数据库加密
- 数据库层面的加解密 [MySQL](/中间件/数据库/mysql/mysql.md)的AES_ENCRYPY/AES_DECRYPT HEX/UNHEX
- 应用层处理
- 传输层处理 SSL
### 数据库设计的其他问题
数据库设计要求设计者可以预先估计一个组织将来的需求，设计出的模式在需求发生变更时只要做最少的改动即可满足要求。
### 实践中的一些问题
#### 没有唯一键约束
业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引
如果没有唯一索引，很容易会被插入重复数据
#### 执行delete没带查询条件
执行删除操作时，要开启事务，同时要先查询核对影响的行数和数据准确性，再执行删除操作 ；执行删除操作后再次核实，如果情况不对立即回滚
#### 表结构修改没有兼容老数据
比如增加了一个非null字段
#### 时效性要求极高的场景查了备库
备库存放的数据可能不是最新的数据
#### 悬停时间较长的事务被kill
#### 表新增了供查询的字段，却没建索引，导致慢查询
## 数据库技术选型
- 确定数据库类型 [db-engines](https://db-engines.com/en/ranking)
## MySQL 数据库设计
[MySQL 数据库设计规范](https://github.com/Highflyer/MySQL-Design-Specification)
### 命名规范
数据库：
- [a-z ][0-9] _
- 不超过30字符
- 备份数据库可以加自然数
表:
- [a-z ][0-9] _
- 相同关系的表可以加相同的前缀
字段：
- [a-z ][0-9] _
- 多个单词使用下划线分割
- 每个表必须有自增主键（默认系统时间）
- 关联字段名尽可能相同
### 字段类型规范
- 使用较少的空间来存储
- ip最好使用int
- 固定长度的类型使用char
- 最好给默认值
### 索引规范
- 加一个index后缀
- 为每个表创建主键索引
- 复合索引慎重
### 范式规范
- 必须满足第二范式
- 尽量满足第三范式
### 设计原则
核心原则：
- 不在数据库做运算
- 控制列数量（20以内）
- 平衡范式与冗余
- 禁止大SQL
- 禁止大事务
- 禁止大批量
字段原则：
- 用好数据类型节约空间
- 字符转为数字
- 避免使用NULL
- 少用text
索引原则：
- 不在索引列做运算
- innodb主键使用自增
- 不用外键
SQL原则：
- 尽可能简单
- 简单事务
- 避免使用触发器，函数
- 不使用select *
- OR改写成IN或UNION
- 避免前%
- 慎用count（*）
- limit高效分页
- 少用连接join
- group by 
- 使用同类型比较
- 打散批量更新