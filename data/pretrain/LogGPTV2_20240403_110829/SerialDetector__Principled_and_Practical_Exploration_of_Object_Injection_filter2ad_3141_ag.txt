source code via well-known attack triggers (called magic
methods in their setting). On the other hand, SerialDetector
relies on known gadgets. An interesting avenue for future work
is to explore the complementary techniques by Dahse et al. to
implement gadget generation in SerialDetector.
the assembly level
Shahriar and Haddad [40] propose a lightweight approach
based on latent semantic indexing to identify keywords that are
likely responsible for OIVs and apply it systematically to PHP
applications to ﬁnd new vulnerabilities. Rasheed et al. [35]
study DoS vulnerabilities in YAML libraries across different
programming languages and discover several new vulnerabili-
ties. Recently, Lekies et al. [28] showed that code-reuse attacks
are feasible in the client-side web applications by proposing a
new attack vector that breaks all existing XSS mitigations via
script gadgets. Cristalli et al. [10] propose a dynamic approach
to identify trusted execution paths during a training phase
with benign inputs, and leverages this information to detect
insecure deserialization via a lightweight sandbox. Hawkins
and Demsky [23] present ZenIDS, a system to dynamically
learn the trusted execution paths of an application during an
16
online training period and report execution anomalies as po-
tential intrusions. Dietrich et al. [14] investigate deserialization
vulnerabilities to exploit the topology of object graphs con-
structed from Java classes in a way that leads dererialization
to DOS attacks exhausting stack memory, heap memory, and
CPU time. SerialDetector focuses on generating OIV patterns
targeting low level features of the framework and libraries. Our
results are complementary and can help improve the precision
of these techniques. Moreover, to our best knowledge, none
of the existing static analysis has been applied to complex
production software such as Azure DevOps Server.
Our work draws inspiration on exploitation techniques de-
veloped by the practitioners’ community [17], [18], [22], [32].
We leverage these results for the exploitation phase to match
our patterns with existing gadgets [3]. We refer to Muñoz and
Mirosh [32] for an excellent report on deserialization attacks
in .NET and Java libraries. Seacord [39] provides a thorough
discussion on OIV defenses via type whitelisting. Our results
are complementary to gadget generation techniques and can
help these works uncovering unknown gadgets.
Tool support Koutroumpouchos et al. [27] develop Ob-
jectMap, a toolchain for detecting and testing OIVs in Java
and PHP applications. While targeting different languages,
ObjectMap shares similar goals as SerialDetector’s payload
and exploit generation modules. Gadget Inspector [22] is a tool
for discovering gadget chains that can be used to exploit dese-
rialization vulnerabilities in Java applications. SerialKiller [33]
is a Java deserialization library implementing look-ahead dere-
rialization [16] to secure applications from untrusted input. It
inspects Java classes during naming resolution and allows a
combination of blacklisting and whitelisting.
Injection Vulnerabilities Code reuse vulnerabilities have
been studied in breadth in the context of injection vulnerabil-
ities in web applications [6], [9], [12], [24], [28]–[30], [43],
[44], [47], [47]. For the .NET domain, Fu et al. [19] propose
the design of a symbolic execution framework for .NET
bytecode to identify SQL injection vulnerabilities. Doupé et
al. [15] implement a semantics-preserving static refactoring
analysis to separate code and data in .NET binaries with
the goal of protecting legacy applications from server-side
XSS attacks. Our work is exclusively focused on OIVs and
yields results that target such vulnerability in depth. Except
for signiﬁcant engineering challenges with .NET assemblies
(including the framework and libraries), our taint-based data
ﬂow analysis follows the existing line of work targeting web
and mobile application vulnerabilities at the bytecode level
broadly [4], [7], [21], [30], [43], [47].
IX. CONCLUSION
We have pushed the research boundary on key challenges
for OIVs in the modern web. Based on these challenges, we
have identiﬁed the root cause of OIV and proposed patterns
based on the triplet: entry points, sensitive sinks, and attack
triggers. We have presented SerialDetector, the ﬁrst principled
and practical tool implementing a systematic exploration of
OIVs via taint-based static analysis. We have used SerialDetec-
tor to test 15 serialization libraries as well as several vulnerable
applications. We have performed an in-depth security analysis
of the Azure DevOps Server which led SerialDetector discover
RCE vulnerabilities with three assigned CVEs.
ACKNOWLEDGMENT
We thank the anonymous reviewers for useful feedback.
The work was partly funded by the Swedish Research Council
(VR) under the project JointForce and by the Swedish Founda-
tion for Strategic Research (SSF) under the project TrustFull.
[1]
[2]
REFERENCES
“dnlib,” https://github.com/0xd4d/dnlib.
“Standard ECMA-335 Common Language Infrastructure (CLI),” https:
//www.ecma-international.org/publications/standards/Ecma-335.htm.
“YSoSerial.Net,” https://github.com/pwntester/ysoserial.net.
[3]
[4] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y. Le Traon, D. Octeau, and P. McDaniel, “FlowDroid: Precise con-
text, ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint analysis for
Android apps,” in PLDI 2014, 2014, p. 29.
[5] B. A. Azad, P. Laperdrix, and N. Nikiforakis, “Less is more: Quanti-
fying the security beneﬁts of debloating web applications,” in USENIX
Security 19, 2019, pp. 1697–1714.
[6] M. Backes, K. Rieck, M. Skoruppa, B. Stock, and F. Yamaguchi,
“Efﬁcient and ﬂexible discovery of php application vulnerabilities,” in
EuroS&P’17, 2017, pp. 334–349.
[7] M. Balliu, D. Schoepe, and A. Sabelfeld, “We are family: Relating
information-ﬂow trackers,” 2017, pp. 124–145.
[8] T. K. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang, “Jump-oriented
programming: a new class of code-reuse attack,” in ASIACCS 2011,
2011, pp. 30–40.
[9] C. Cifuentes, A. Gross, and N. Keynes, “Understanding caller-sensitive
method vulnerabilities: A class of access control vulnerabilities in the
java platform,” in SOAP 2015, 2015, pp. 7–12.
[10] S. Cristalli, E. Vignati, D. Bruschi, and A. Lanzi, “Trusted Execution
Path for Protecting Java Applications Against Deserialization of Un-
trusted Data,” in RAID 2018, 2018, pp. 445–464.
J. Dahse and T. Holz, “Simulation of built-in PHP features for precise
static code analysis,” in NDSS’14, 2014.
[11]
[12] ——, “Static detection of second-order vulnerabilities in web applica-
[13]
[14]
tions,” in USENIX Security 14, 2014, pp. 989–1003.
J. Dahse, N. Krein, and T. Holz, “Code reuse attacks in php: Automated
pop chain generation,” in CCS’14, 2014, pp. 42–53.
J. Dietrich, K. Jezek, S. Rasheed, A. Tahir, and A. Potanin, “Evil
Pickles: DoS Attacks Based on Object-Graph Engineering,” in ECOOP
2017, 2017, pp. 10:1–10:32.
[15] A. Doupé, W. Cui, M. H. Jakubowski, M. Peinado, C. Kruegel, and
G. Vigna, “dedacota: toward preventing server-side XSS via automatic
code and data separation,” in CCS’13, 2013, pp. 1205–1216.
[16] P. Ernst, “Look-ahead Java deserialization,” January 2013. [Online].
Available: https://www.ibm.com/developerworks/library/se-lookahead/
[17] S. Esser, “Utilizing code reuse/rop in php application exploits,” Black-
Hat USA, 2010.
J. Forshaw, “Are you my Type? Breaking .NET Through Serialization,”
BlackHat, 2012.
[18]
[19] X. Fu, X. Lu, B. Peltsverger, S. Chen, K. Qian, and L. Tao, “A
static analysis framework for detecting SQL injection vulnerabilities,”
in COMPSAC 2007, 2007, pp. 87–96.
[20] E. Gamma, R. Helm, R. Johnson, and J. Vlissides, Design Patterns:
USA: Addison-
Elements of Reusable Object-Oriented Software.
Wesley Longman Publishing Co., Inc., 1995.
[21] M. I. Gordon, D. Kim, J. H. Perkins, L. Gilham, N. Nguyen, and M. C.
Rinard, “Information ﬂow analysis of android applications in droidsafe,”
in NDSS, 2015.
I. Haken, “Automated Discovery of Deserialization Gadget Chains,”
BlackHat, 2018.
[22]
[23] B. Hawkins and B. Demsky, “Zenids: introspective intrusion detection
for PHP applications,” in ICSE 2017, 2017, pp. 232–243.
[24] P. Holzinger, S. Triller, A. Bartel, and E. Bodden, “An in-depth study
of more than ten years of java exploitation,” in CCS’16, 2016, pp. 779–
790.
17
[25]
J. Huang, Y. Li, J. Zhang, and R. Dai, “Uchecker: Automatically
detecting php-based unrestricted ﬁle upload vulnerabilities,” in DSN
2019, 2019, pp. 581–592.
[26] V. Kanvar and U. P. Khedker, “Heap abstractions for static analysis,”
ACM Comput. Surv., vol. 49, no. 2, June 2016.
[27] N. Koutroumpouchos, G. Lavdanis, E. Veroni, C. Ntantogian, and
C. Xenakis, “ObjectMap: Detecting Insecure Object Deserialization,”
in PCI’19, 2019, pp. 67–72.
[28] S. Lekies, K. Kotowicz, S. Groß, E. A. V. Nava, and M. Johns, “Code-
reuse attacks for the web: Breaking cross-site scripting mitigations via
script gadgets,” in CCS 2017, 2017, pp. 1709–1723.
[29] S. Lekies, B. Stock, and M. Johns, “25 million ﬂows later: large-scale
detection of DOM-based XSS,” in CCS 2013, 2013, pp. 1193–1204.
[30] W. Melicher, A. Das, M. Sharif, L. Bauer, and L. Jia, “Riding out
DOMsday: Toward detecting and preventing DOM cross-site scripting,”
in NDSS 2018, 2018.
[31] D. Mitropoulos, P. Louridas, M. Polychronakis, and A. D. Keromytis,
“Defending against web application attacks: Approaches, challenges and
implications,” IEEE Transactions on Dependable and Secure Comput-
ing, vol. 16, no. 2, pp. 188–203, 2019.
[32] A. Muñoz and O. Mirosh, “Friday the 13th JSON Attacks,” BlackHat,
2017.
[33] A. Muñoz and C. Schneider, “Serial killer: Silently pwning your java
endpoints,” 2018.
[34] O. Peles and R. Hay, “One class to rule them all: 0-day deserialization
vulnerabilities in android,” in WOOT’15, 2015.
[35] S. Rasheed, J. Dietrich, and A. Tahir, “Laughter in the wild: A study
into dos vulnerabilities in YAML libraries,” in TrustCom/BigDataSE
2019, 2019, pp. 342–349.
[36] R. Roemer, E. Buchanan, H. Shacham, and S. Savage, “Return-oriented
programming: Systems, languages, and applications,” ACM Trans. Inf.
Syst. Secur., vol. 15, no. 1, pp. 2:1–2:34, 2012.
[37] D. Schoepe, M. Balliu, B. C. Pierce, and A. Sabelfeld, “Explicit secrecy:
A policy for taint tracking,” in EuroS&P, 2016.
[38] E. J. Schwartz, T. Avgerinos, and D. Brumley, “All you ever wanted
to know about dynamic taint analysis and forward symbolic execution
(but might have been afraid to ask),” in IEEE S&P, 2010.
[39] R. Seacord, “Combating Java Deserialization Vulnerabilities with Look-
Ahead Object Input Streams (LAOIS),” June 2017.
[40] H. Shahriar and H. Haddad, “Object injection vulnerability discovery
based on latent semantic indexing,” in SAC, 2016, pp. 801–807.
[41] M. Shcherbakov and M. Balliu, “SerialDetector,” February 2021,
software. [Online]. Available: https://github.com/yuske/SerialDetector
[42] Y. Smaragdakis, M. Bravenboer, and O. Lhoták, “Pick your contexts
well: understanding object-sensitivity,” in POPL 2011, 2011, pp. 17–
30.
[43] F. Spoto, E. Burato, M. D. Ernst, P. Ferrara, A. Lovato, D. Macedonio,
and C. Spiridon, “Static identiﬁcation of injection attacks in java,” ACM
Trans. Program. Lang. Syst., vol. 41, no. 3, pp. 18:1–18:58, 2019.
[44] C. Staicu and M. Pradel, “Freezing the web: A study of ReDoS
vulnerabilities in JavaScript-based web servers,” in USENIX Security,
2018, pp. 361–376.
[45] L. Szekeres, M. Payer, T. Wei, and D. Song, “SoK: Eternal War in
[46] K.
Memory,” in Security & Privacy, 2013, pp. 48–62.
2017
“OWASP
TEAM,
Top
10
cure
owasp-top-10-2017-a8-insecure-deserialization/.
Deserialization,”
Inse-
https://www.kiuwan.com/blog/
A8
–
[47] O. Tripp, M. Pistoia, P. Cousot, R. Cousot, and S. Guarnieri, “An-
dromeda: Accurate and scalable security analysis of web applications,”
in FASE, 2013, pp. 210–225.
[48] R. Vallée-Rai, P. Co, E. Gagnon, L. J. Hendren, P. Lam, and V. Sun-
daresan, “Soot - a java bytecode optimization framework,” in CASCON,
1999.
[49] M.
Wulftange,
Microsoft
[Online].
cve-2019-0604-details-of-a-microsoft-sharepoint-rce-vulnerability
a
2019.
https://www.thezdi.com/blog/2019/3/13/
SharePoint
Available:
“CVE-2019-0604:
Vulnerability,”
Details
RCE
of
C-LDVAR
(cid:104)pc, cs, E, h, s(cid:105) → (cid:104)pc + 1, cs, E, h, s :: v(cid:105)
P(pc) = ldvar x
v = E(x)
C-LDFLD
(cid:104)pc, cs, E, h, s :: l(cid:105) → (cid:104)pc + 1, cs, E, h, s :: v(cid:105)
P(pc) = ldﬂd f
v = h(l, f )
C-BR
(cid:104)pc, cs, E, h, s(cid:105) → (cid:104)i, cs, E, h, s(cid:105)
P(pc) = br i
C-STVAR
P(pc) = stvar x E
= E[x (cid:55)→ v]
(cid:48)
(cid:104)pc, cs, E, h, s :: v(cid:105) → (cid:104)pc + 1, cs, E
, h, s(cid:105)
(cid:48)
C-STFLD
P(pc) = stﬂd f
= h[h(l, f ) (cid:55)→ v]
(cid:48)
(cid:104)pc, cs, E, h, s :: v :: l(cid:105) → (cid:104)pc + 1, cs, E, h
, s(cid:105)
(cid:48)
h
C-NEWOBJ
P(pc) = newobj T
l ∈ Loc fresh
(cid:48)
h
= h[(l, f ) (cid:55)→ ⊥]
(cid:48)
(cid:104)pc, cs, E, h, s :: l(cid:105) → (cid:104)pc + 1, cs, E, h
, s(cid:105)
C-RET
(cid:48)
P(pc) = ret
, s
(cid:104)pc, cs :: st, E, h, s :: v(cid:105) → (cid:104)pc
st = (pc
, E
(cid:48)
(cid:48)
)
(cid:48)(cid:48)
pc
(cid:48)(cid:48)
(cid:48)
(cid:48)
= pc
(cid:48)
, h, s
+ 1
:: v(cid:105)
, cs, E
C-BRTRUE
P(pc) = brtrue i
(cid:48)
(cid:104)pc, cs, E, h, s :: v(cid:105) → (cid:104)pc
(cid:48)
pc
= (v ? i : pc + 1)
, cs, E, h, s(cid:105)
C-CALL
P(pc) = call i
st = (pc, E, s) E
(cid:48)
(cid:104)pc, cs, E, h, s :: v(cid:105) → (cid:104)i, cs :: st, E
, h, (cid:105)
= E[arg (cid:55)→ v]
(cid:48)
Fig. 12: Operational semantics of CIL
APPENDIX
A. A Primer on .NET Technologies
The .NET Framework is a managed execution environ-
ment for Windows providing a variety of services to its
running applications. The framework consists of two major
components: The Common Language Runtime (CLR), which
is the virtual machine that handles running apps, and the
.NET Framework Class Library (FCL), which provides a
library of reusable code that developers can call from their
applications. The FCL implements a collection of reusable
types for user interfaces (e.g., XAML serializer), data access,
web application development (e.g., JSON serializer), network
communications (e.g., SOAP serializer) and other features.
The .NET Framework implements the Common Language
Infrastructure (CLI) speciﬁcation, an ISO and Ecma standard
that describes executable code and a runtime environment.
Compilers for C# and F# generate code in the Common
Intermediate Language (CIL) that can be executed in the CLI
runtime. CIL is an object-oriented binary instruction set within
the CLI speciﬁcation. For our purposes, CIL provides a uniﬁed
language for analyzing code from the .NET Framework and
its applications in absence of source code.
The .NET Framework allows to dynamically instantiate
arbitrary objects based on user-provided types and data. This
is typically achieved via reﬂection which allows to examine
the structure of types, create instances of types, and invoke
methods on types, all based on the description of a type.
Alternatively, the .NET Framework can instantiate an object
at runtime via dynamic code generation by getting a pointer
to a method and generating the CIL code of that method at
runtime.
18