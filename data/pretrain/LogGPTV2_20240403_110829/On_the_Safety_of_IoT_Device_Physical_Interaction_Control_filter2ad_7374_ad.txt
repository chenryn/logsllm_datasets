which could be utilized by the attacker. Assume the malicious ap-
plication has been installed on the platform. It aims at modifying
the status of locationMode to “Home” at a specific time stealthily by
utilizing a system flaw [18]. Then, the locationMode triggers actions
of other devices, which are defined in the home mode control appli-
cation. We assume the home mode control application gets access
to the thermostat and toaster. If a toaster is overheated, it may lead
to the reaction of the fire alarm application, e.g., unlocking the door,
which makes intrusion possible. In this scenario, even a malicious
application does not get access to a lock, it still can affect the lock’s
status indirectly.
In this scenario, we use a First Alert smoke detector, a Z-Wave
Schlage Lock, and a toaster controlled by a wemo outlet to im-
plement a smart toaster. Figure 11 shows logs generated by the
SmartThings platform after the fire alarm application has been
triggered by a smoke event, which is caused by turning on a toaster
switch for 16 minutes. Since the window control flow is similar to
the benign case, we do not show the logs of that flow.
5.4 System Performance
In this section, we measure the performance of our system via pro-
cessing all 185 official SmartThings applications. We test 20 times to
calculate the average performance overhead on a desktop computer
with an Intel 8700K CPU and 16 GB memories. The performance of
the intra-app analysis is influenced by the number of applications
and the complexity of each application. In our experiment, we mea-
sure the time of generating all the intra-app interactions. As shown
Session 5A: CyberphysicalCCS’18, October 15-19, 2018, Toronto, ON, Canada841the application’s description and its functionality [40]. Moreover,
Celik et al. proposed a static taint analysis tool called SAINT for
tracing sensitive data flows in IoT applications [14]. They also in-
troduced Soteria, a static analysis system for finding safety and
security violations in an IoT application or IoT environment [15].
With respect to platform flaws, Fernandes et al. demonstrated
that the overprivilege problem on the SmartThings Platform allows
malicious applications to access non-authorized devices and sensi-
tive event data [18]. In FlowFence, an information flow control and
data isolation mechanism is proposed, focusing on solving sensitive
information leakage on on the SmartThings platform [19]. Besides,
Wang et al. have demonstrated that log information can be used to
monitor malicious behaviors on the SmartThings platform [41].
Considering side channels on IoT platforms, Ronen et al. proved
that attackers are capable of sending sensitive information by using
strobed smart bulbs [1]. Recently, Han et al. demonstrated that
identifying multiple physical impacts triggered by a specific event
can help users to pair correlated devices, e.g., human walking may
change the status of motion, temperature and humidity sensors [24].
Although these research efforts revealed the possible influence of
physical channels on smart home platforms, they mainly focused
on finding physical impacts from a single physical event.
Although many IoT security problems have been addressed by
existing research, our study revealed that a new type of security
problem could happen due to specific physical functions provided
by IoT devices. Especially, the ability of IoT devices to interact with
physical surrounding needs to be monitored and controlled.
Risk Analysis: Many existing research focuses on the risk anal-
ysis of Android applications. Pandita et al. compared the results of
NLP and static analysis to assess risks of Android applications [33].
They provided a mechanism to verify the consistency between
an Android application’s description and its behaviors. Some re-
searchers utilized machine learning techniques to evaluate the risk
of malicious Android applications. For example, Jing et al. used
SVM to give the risk score of an application based on users’ trusted
applications [28]. Arp et al. used static analysis to extract features
from applications and then used SVM to classify those features.
These work focuses on application-level risk analysis and requires
a large amount of training dataset, which does not exist currently
on IoT platforms. In contract, our work focuses on evaluating risks
of the physical interactions among applications on IoT platforms
using limited intra-app interactions as a baseline.
7 DISCUSSION
In this section, we examine the limitations of our design and imple-
mentation, and discuss potential solutions for addressing those lim-
itations.
Risk Analysis: Our risk analysis is sensitive to assigned chan-
nel values. The value assignment is based on the co-occurrence
frequency of two channels in intra-app interactions. Intuitively, a
higher frequency represents a stronger correlation between two
channels. Hence, we give these channels similar values. However,
such an assignment method may not be optimal. It would be an
interesting problem to measure real-world correlations among dif-
ferent physical channels. In our future work, we plan to integrate
other analysis methods, such as physical verification and machine
(a) Intra-app Analysis
(b) Channel Analysis
Figure 12: System Performance
in Figure 12a, the time for intra-app analysis of 185 applications is
around 0.3s. The performance overhead of physical channel identifi-
cation depends on the length of application description as shown in
Figure 12b, which is around 573 seconds in total. The average time
of risk analysis for 135 applications is approximately 1.2 seconds.
6 RELATED WORK
IoT Security: Existing research on IoT security has mainly focused
on addressing traditional security issues on IoT environments, such
as device or protocol flaws [16, 21, 36], malicious applications [18,
36], side channels [1, 24], and platform problems [18, 20, 27, 30].
Regarding devices flaws, some researchers focused on exploit-
ing flaws on an IoT platform to attack the system. For example,
Sivaraman et al. showed that an attacker could conduct a multi-
step attack to compromise a local home network from the Internet
by using a malicious mobile application [36]. By exploiting vul-
nerabilities in communication protocols, Ronen et al. developed
a worm that could use the flaws in ZigBee to spread the worm
among smart bulbs [34]. Chen et al. proposed a mechanism that
could analyze device memory corruption vulnerabilities without
analyzing devices’ firmwares [16].
On application level, Jia et al. proposed a runtime authorization
mechanism that uses context information to ensure the corrective-
ness of sensitive action execution [27]. Yuan et al. explored how to
use static analysis and NLP to identify the inconsistency between
Session 5A: CyberphysicalCCS’18, October 15-19, 2018, Toronto, ON, Canada842learning, into our risk analysis. We will also conduct user studies
to verify the correctiveness of our risk analysis.
Risk Mitigation: Our risk mitigation method is relatively straight-
forward, which relies on developers to add more trigger conditions
empirically. We plan to enhance our risk mitigation in two direc-
tions. First, it would be interesting to develop an automatic risk
mitigation mechanism, which can change trigger conditions for
risky interactions by learning existing applications’ benign inter-
actions. Second, we may develop a dynamic access control mech-
anism for IoT platforms without modifying application code. The
access control policies can be generated automatically by machine
learning techniques or from users’ inputs. Thus, our system could
achieve runtime interaction control without modifying existing
applications.
Channel Identification: In our current design, we identify
physical channels by clustering keywords from application descrip-
tions. We may explore other methods to identify the existence of
physical channels. For example, we may use system logs [41] or
trace devices’ sensor readings [24], to understand devices’ interac-
tions with different physical channels.
Description Integrity: Our system uses application descrip-
tions to identify physical channels. We especially use the descrip-
tions of official applications on the Samsung SmartThings platform
for physical channel identification. If an attacker can craft mali-
cious/misleading application descriptions in the applications, we
need to verify the description integrity before using them in our
system. We will investigate solutions to address such a problem.
8 CONCLUSIONS
In this paper, we have designed IoTMon, an IoT device physical
interaction control system, which can discover all potential inter-
app interaction chains and analyze risk levels of those interaction
chains. We have implemented a prototype of IoTMon and evaluated
it based on official SmartThings applications. Our evaluation results
have demonstrated that IoTMon could effectively capture potential
physical interactions among IoT applications and identify high-risk
inter-app interaction chains.
ACKNOWLEDGMENTS
The authors thank Long Cheng for his help in polishing this paper.
We also think Maxwell Harley for his help in the implementation
of prototype system. This material is based upon work supported
in part by the National Science Foundation (NSF) under Grant
no. 1642143, 1723663, and 1700499. Any opinions, findings, and
conclusions or recommendations expressed in this material are
those of the authors and do not necessarily reflect the views of NSF.
REFERENCES
[1] Extended Functionality Attacks on IoT Devices: The Case of Smart Lights, au-
thor=Ronen, Eyal and Shamir, Adi, booktitle=Proceedings of the 2016 IEEE Euro-
pean Symposium on Security and Privacy (EuroS&P), pages=3–12, year=2016,
organization=IEEE.
[2] Zigbee. https://en.wikipedia.org/wiki/Zigbee.
[3] Home automation system market worth 79.57 billion usd by 2022. http://www.
marketsandmarkets.com/PressReleases/home-automation-control-systems.
asp, 2016.
[4] The stanford parser: A statistical parser. https://nlp.stanford.edu/software/
lex-parser.html, 2016.
[5] Ddos attack that disrupted internet was largest of
its kind in his-
https://www.theguardian.com/technology/2016/oct/26/
tory, experts say.
ddos-attack-dyn-mirai-botnet, 2017.
[6] Euclidean distance. https://en.wikipedia.org/wiki/Euclidean_distance, 2018.
[7] Fenestra. http://www.smartfenestra.com/products/, 2018.
[8] K-means clustering. https://en.wikipedia.org/wiki/K-means_clustering, 2018.
[9] Minkowski distance. https://en.wikipedia.org/wiki/Minkowski_distance, 2018.
[10] Taxicab geometry. https://en.wikipedia.org/wiki/Taxicab_geometry, 2018.
[11] Word2vec, doc2vec & glove: Neural word embeddings for natural language
processing. https://deeplearning4j.org/word2vec.html, 2018.
[12] Apple. ios - home. http://www.apple.com/ios/home/.
[13] D. Arp, M. Spreitzenbarth, M. Hubner, H. Gascon, K. Rieck, and C. Siemens.
DREBIN: Effective and Explainable Detection of Android Malware in Your Pocket.
In Proceedings of the 2014 Network and Distributed Security Symposium (NDSS),
volume 14, pages 23–26, 2014.
[14] Z. B. Celik, L. Babun, A. K. Sikder, H. Aksu, G. Tan, P. McDaniel, and A. S. Uluagac.
Sensitive Information Tracking in Commodity IoT. In Proceedings of the 27th
USENIX Security Symposium (USENIX Security), 2018.
[15] Z. B. Celik, P. McDaniel, and G. Tan. Soteria: Automated IoT Safety and Security
Analysis. In 2018 USENIX Annual Technical Conference (USENIX ATC). USENIX
Association, 2018.
[16] J. Chen, W. Diao, Q. Zhao, C. Zuo, Z. Lin, X. Wang, W. C. Lau, M. Sun, R. Yang,
and K. Zhang. IOTFUZZER: Discovering Memory Corruptions in IoT Through
App-based Fuzzing. In Proceedings of the 22nd Network and Distributed Security
Symposium (NDSS), 2018.
[17] S. Community.
Samsung smartthing applications.
SmartThingsCommunity/SmartThingsPublic, 2017.
https://github.com/
[18] E. Fernandes, J. Jung, and A. Prakash. Security Analysis of Emerging Smart Home
Applications. In Proceedings of the 37th IEEE Symposium on Security and Privacy
(S&P), May 2016.
[19] E. Fernandes, J. Paupore, A. Rahmati, D. Simionato, M. Conti, and A. Prakash.
FlowFence: Practical Data Protection for Emerging IoT Application Frameworks.
In Proceedings of the 25th USENIX Security Symposium (USENIX Security), 2016.
[20] E. Fernandes, A. Rahmati, J. Jung, and A. Prakash. Decoupled-IFTTT: Con-
straining Privilege in Trigger-Action Platforms for the Internet of Things. arXiv
preprint arXiv:1707.00405, 2017.
[21] D. Fisher.
Pair of Bugs Open Honeywell Home Controllers Up to Easy
Hacks. https://threatpost.com/pairof-bugs-open-honeywell-home-controllers-
up-toeasy-hacks/113965/.
[22] B. Fouladi and S. Ghanoun. Honey, I’m home!!-Hacking Z-Wave Home Automa-
tion Systems. Black Hat USA, 2013.
things.
the-
[23] Google. Google home. https://madeby.google.com/home/.
[24] J. Han, A. J. Chung, M. K. Sinha, M. Harishankar, S. Pan, H. Y. Noh, P. Zhang, and
P. Tague. Do You Feel What I Hear? Enabling Autonomous IoT Device Pairing
Using Different Sensor Types. In Proceedings of the 2018 IEEE Symposium on
Security and Privacy (S&P), pages 678–694. IEEE, 2018.
[25] A. Hesseldahl.
A hacker’s-eye view of
the internet of
https://www.recode.net/2015/4/7/11561182/a-hackers-eye-view-of-
internet-of-things/, 2015.
[26] IoTivity. Iotivity website. https://www.iotivity.org/.
[27] Y. J. Jia, Q. A. Chen, S. Wang, A. Rahmati, E. Fernandes, Z. M. Mao, and A. Prakash.
ContexIoT: Towards Providing Contextual Integrity to Appified IoT Platforms.
In Proceedings of the 21st Network and Distributed Security Symposium (NDSS),
February 2017.
[28] Y. Jing, G.-J. Ahn, Z. Zhao, and H. Hu. Riskmon: Continuous and Automated Risk
Assessment of Mobile Applications. In Proceedings of the 4th ACM Conference on
Data and Application Security and Privacy, pages 99–110. ACM, 2014.
[29] N. Lomas. Critical Flaw identified In ZigBee Smart Home Devices, 2015.
[30] C. Nandi and M. D. Ernst. Automatic Trigger Generation for Rule-based Smart
Homes. In Proceedings of the 2016 ACM Workshop on Programming Languages
and Analysis for Security, pages 97–102. ACM, 2016.
[31] K. Olejnik, I. Dacosta, J. S. Machado, K. Huguenin, M. E. Khan, and J.-P. Hubaux.
Smarper: Context-aware and Automatic Runtime-permissions for Mobile Devices.
In Proceedings of the 2017 IEEE Symposium on Security and Privacy (S&P), pages
1058–1076. IEEE, 2017.
[32] OpenHAB. openhab - features - introduction. http://www.openhab.org/features/
introduction.html.
[33] P. Rahul, X. Xiao, W. Yang, W. Enck, and T. Xie. WHYPER: Towards Automating
In Proceedings of the 22nd USENIX
Risk Assessment of Mobile Applications.
Security Symposium (USENIX Security). Citeseer, 2013.
[34] E. Ronen, A. Shamir, A.-O. Weingarten, and C. O’Flynn.
IoT Goes Nuclear:
Creating a ZigBee Chain Reaction. In Proceedings of the 2017 IEEE Symposium on
Security and Privacy (S&P), pages 195–212. IEEE, 2017.
[35] B. Schneier. The Internet of Things Is Wildly Insecure - And Often Unpatchable.
Schneier on Security, 6, 2014.
[36] V. Sivaraman, D. Chan, D. Earl, and R. Boreli. Smart-Phones Attacking Smart-
Homes. In Proceedings of the 9th ACM Conference on Security & Privacy in Wireless
and Mobile Networks (WiSec), pages 195–200. ACM, 2016.
Session 5A: CyberphysicalCCS’18, October 15-19, 2018, Toronto, ON, Canada843[37] S. Smartthing. Smart home. intelligent living. https://www.smartthings.com/.
[38] S. Smartthing. Smartthings developer documentation. http://docs.smartthings.
com/en/latest/.
[39] Steven. Windows automation in smart homes. https://smarthomegearguide.com/
windows-automation-smart-homes/, 2018.
[40] Y. Tian, N. Zhang, Y.-H. Lin, X. Wang, B. Ur, X. Guo, and P. Tague. SmartAuth:
User-Centered Authorization for the Internet of Things. In Proceedings of the
26th USENIX Security Symposium (USENIX Security), pages 361–378, 2017.
[41] Q. Wang, W. U. Hassan, A. Bates, and C. Gunter. Fear and Logging in the Internet
of Things. In Proceedings of the 22nd Network and Distributed Security Symposium
(NDSS), 2018.
[42] Wikipedia. Mirai (malware). https://en.wikipedia.org/wiki/Mirai_(malware).
[43] Wink. A simpler, smarter home. https://www.wink.com/.
[44] T. Yu, V. Sekar, S. Seshan, Y. Agarwal, and C. Xu. Handling a Trillion (unfixable)
Flaws on a Billion Devices: Rethinking Network Security for the Internet-of-
Things.
In Proceedings of the 14th ACM Workshop on Hot Topics in Networks
(HotNets), page 5. ACM, 2015.
A INTRA-APP ANALYSIS
Our system can perform a lightweight static analysis on given
IoT applications. It analyzes the rule grammar of applications by
creating and parsing an AST of the application to find triggers
and actions. The static analysis takes on four distinct phases with
respect to the structure of a Samsung SmartThings application. The
first phase converts the source code of the application into a Groovy
AST. Since the SmartThings platform uses Groovy scripts instead of
wrapping the source in a Groovy class, AstBuilder, provided by the
Groovy project, cannot be utilized. Instead, the CompilationUnit
class can be used to create the AST. The CompilationUnit class is a
package provided by the Groovy language. It is the same one that
the Groovy Console uses for parsing source code into an AST. An
example of its usage is shown in Listing 3. The CompilationUnit
class is suitable for semantic analysis, because it contains classes,
imports, and variable scopes. Listing 3 demonstrates how to use
the CompilationUnit class to generate the AST from a SmartThings
application file, “source.groovy”. By providing the source file and
compilation unit option, the CompilationUnit class can create an
ASTNode object that the analyzer can traverse to understand how
triggers and actions are related to each other.
Listing 3: Using the CompilationUnit Class
1
2
3
4
5
def fileData = new File("./source.groovy")
CompilationUnit cu = new CompilationUnit()
cu.addSource(fileData)
cu.compile(Phases.SEMANTIC_ANALYSIS)
def ast = cu.getAst()
The second phase parses the preferences closure to make a list
of inputs and capabilities. The preferences are shown to users as
a menu where they can select what options their SmartThings
applications should use. Since inputs of SmartThings applications
typically have associated functions for changing the state of the
capability, creating an easy-to-access list of these inputs makes the
retrieval easy. The AST is easy to traverse if there are no “section”
blocks or even those blocks do exist. Listing 4 provides an example
of the preference, which showcases the intricacies of the preference
closure. Specifically, it shows how sections are built from inputs,
and inputs can even have sub-sections. One challenge with creating
the list of inputs is that there are default system variables, such as
“location” and “app”, that SmartThings creates. The easiest way to
fix the problem of undefined default variables is to manually add all
1
2
3
4
5
6
7
8
9
10
11
1
2
3
4
5
default variables into the input list to allow them to be consumed
later in the analysis process.
Listing 4: Preferences Closure
preferences {
// Create section for Power Meter input
section("Power Meter") {
input "powerMeter", "capability.powerMeter"
}
// Create input section for contact
input("recipients", "contact", title: "Send to") {
input "sendPush", bool, title: "Send a push?", options:
["Yes", "No"]
input "phone", "phone", title: "Send a Text?"
}
}
The third phase maps inputs to outputs by parsing subscribe
calls to get trigger handlers. The “installed” and “updated” functions
tell SmartThings which previously-defined inputs are triggers and
which are actions. Inside of the “installed” and “updated” functions,
there are calls to “subscribe” and “schedule”, which tell SmartThings
what actions should be performed when the trigger is activated. The
“schedule” function takes three arguments: a trigger name, a trigger
channel, and a trigger handler. Listing 5 shows an example function
for subscribing to events. It subscribes to all events, which are
created and updated by powerMeter in the platform. By traversing
the trigger handler function and checking for references to inputs
located in the preference closure, the analyzer can tell which inputs
are actions that the trigger calls. After performing three phases,
our tool can have a list of triggers and their associated actions.
Listing 5: Installed Function
def installed() {
// subscribe to powerMeter input and the
// "power" attribute.
subscribe(powerMeter, "power", handleMeter)
}
B INTERACTION CHAIN GRAPH OF 135
APPLICATIONS