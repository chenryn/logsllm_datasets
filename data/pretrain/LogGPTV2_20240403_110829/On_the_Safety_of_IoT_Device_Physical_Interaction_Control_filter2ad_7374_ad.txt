### Potential Attack Scenario

A malicious application, once installed on the platform, can exploit a system flaw [18] to stealthily modify the `locationMode` status to "Home" at a specific time. This modification can trigger actions in other devices, as defined in the home mode control application. We assume that the home mode control application has access to the thermostat and toaster. If the toaster is overheated, it may activate the fire alarm application, leading to unintended actions such as unlocking the door, which could facilitate an intrusion. In this scenario, even if the malicious application does not have direct access to the lock, it can indirectly influence the lock's status.

### Experimental Setup

In our experiment, we use a First Alert smoke detector, a Z-Wave Schlage Lock, and a smart toaster controlled by a Wemo outlet. Figure 11 shows the logs generated by the SmartThings platform after the fire alarm application is triggered by a smoke event, caused by turning on the toaster switch for 16 minutes. The window control flow is similar to the benign case, so we do not include those logs here.

### System Performance

We measure the performance of our system by processing all 185 official SmartThings applications. We conduct 20 tests to calculate the average performance overhead on a desktop computer with an Intel 8700K CPU and 16 GB of RAM. The performance of the intra-app analysis is influenced by the number of applications and their complexity. Our experiment measures the time required to generate all intra-app interactions. As shown in Figure 12a, the intra-app analysis for 185 applications takes approximately 0.3 seconds. The performance overhead for physical channel identification, which depends on the length of the application description, is around 573 seconds in total. The average time for risk analysis of 135 applications is approximately 1.2 seconds.

### Related Work

#### IoT Security
Existing research on IoT security has primarily focused on addressing traditional security issues in IoT environments, such as device or protocol flaws [16, 21, 36], malicious applications [18, 36], side channels [1, 24], and platform problems [18, 20, 27, 30].

- **Device Flaws**: Some researchers have explored exploiting flaws on IoT platforms to attack systems. For example, Sivaraman et al. demonstrated a multi-step attack to compromise a local home network using a malicious mobile application [36]. Ronen et al. developed a worm that could spread through ZigBee vulnerabilities among smart bulbs [34]. Chen et al. proposed a mechanism to analyze device memory corruption without examining firmware [16].
  
- **Application Level**: Jia et al. proposed a runtime authorization mechanism using context information to ensure the correctness of sensitive actions [27]. Yuan et al. used static analysis and NLP to identify inconsistencies between an application's description and its functionality [40].

- **Platform Flaws**: Fernandes et al. highlighted the overprivilege problem on the SmartThings Platform, allowing malicious applications to access unauthorized devices and sensitive event data [18]. FlowFence, an information flow control and data isolation mechanism, was proposed to address sensitive information leakage on the SmartThings platform [19]. Wang et al. demonstrated the use of log information to monitor malicious behaviors [41].

- **Side Channels**: Ronen et al. showed that attackers can send sensitive information using strobed smart bulbs [1]. Han et al. demonstrated that identifying multiple physical impacts from a specific event can help users pair correlated devices, such as human walking affecting motion, temperature, and humidity sensors [24].

#### Risk Analysis
Many existing studies focus on risk analysis for Android applications. Pandita et al. compared NLP and static analysis to assess risks of Android applications [33]. Jing et al. used SVM to score the risk of applications based on users' trusted applications [28]. Arp et al. used static analysis to extract features and then classified them using SVM. These works focus on application-level risk analysis and require large training datasets, which are currently unavailable on IoT platforms. Our work, in contrast, focuses on evaluating the risks of physical interactions among applications on IoT platforms using limited intra-app interactions as a baseline.

### Discussion

#### Limitations and Future Work
- **Risk Analysis**: Our risk analysis is sensitive to assigned channel values, which are based on the co-occurrence frequency of two channels in intra-app interactions. While a higher frequency indicates a stronger correlation, this assignment method may not be optimal. Future work will integrate other analysis methods, such as physical verification and machine learning, to measure real-world correlations among different physical channels.
  
- **Risk Mitigation**: Our current risk mitigation method relies on developers adding more trigger conditions empirically. We plan to develop an automatic risk mitigation mechanism that can adjust trigger conditions for risky interactions by learning from existing applications' benign interactions. Additionally, we aim to create a dynamic access control mechanism for IoT platforms without modifying application code, where policies can be generated automatically using machine learning techniques or user inputs.

- **Channel Identification**: Currently, we identify physical channels by clustering keywords from application descriptions. Future work will explore other methods, such as using system logs or tracing sensor readings, to better understand device interactions with different physical channels.

- **Description Integrity**: Our system uses application descriptions to identify physical channels. If an attacker crafts misleading descriptions, we need to verify the integrity of these descriptions before using them. We will investigate solutions to address this issue.

### Conclusions

In this paper, we present IoTMon, an IoT device physical interaction control system that discovers potential inter-app interaction chains and analyzes their risk levels. We implemented a prototype of IoTMon and evaluated it using official SmartThings applications. Our results demonstrate that IoTMon effectively captures potential physical interactions among IoT applications and identifies high-risk inter-app interaction chains.

### Acknowledgments

The authors thank Long Cheng for his help in polishing the paper and Maxwell Harley for his assistance in implementing the prototype system. This work is supported in part by the National Science Foundation (NSF) under Grant no. 1642143, 1723663, and 1700499. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of NSF.

### References

[References are listed as in the original text.]

### Appendices

#### A. Intra-App Analysis

Our system performs a lightweight static analysis on given IoT applications by analyzing the rule grammar and creating and parsing an AST of the application to find triggers and actions. The static analysis consists of four distinct phases:

1. **AST Conversion**: The source code of the application is converted into a Groovy AST. Since the SmartThings platform uses Groovy scripts, the CompilationUnit class is used to create the AST, as shown in Listing 3.

   ```groovy
   def fileData = new File("./source.groovy")
   CompilationUnit cu = new CompilationUnit()
   cu.addSource(fileData)
   cu.compile(Phases.SEMANTIC_ANALYSIS)
   def ast = cu.getAst()
   ```

2. **Preferences Parsing**: The preferences closure is parsed to create a list of inputs and capabilities. This makes it easy to retrieve the inputs, as shown in Listing 4.

   ```groovy
   preferences {
     // Create section for Power Meter input
     section("Power Meter") {
       input "powerMeter", "capability.powerMeter"
     }
     // Create input section for contact
     input("recipients", "contact", title: "Send to") {
       input "sendPush", bool, title: "Send a push?", options: ["Yes", "No"]
       input "phone", "phone", title: "Send a Text?"
     }
   }
   ```

3. **Input-Output Mapping**: Inputs are mapped to outputs by parsing subscribe calls to get trigger handlers. The "installed" and "updated" functions define triggers and actions. Listing 5 shows an example function for subscribing to events.

   ```groovy
   def installed() {
     // subscribe to powerMeter input and the "power" attribute.
     subscribe(powerMeter, "power", handleMeter)
   }
   ```

After these phases, our tool generates a list of triggers and their associated actions.

#### B. Interaction Chain Graph of 135 Applications

[Details of the interaction chain graph are provided here, as in the original text.]