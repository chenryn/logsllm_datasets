gSqNorm
:: (Fact m, CElt t r) => Cyc t m r
-> r
-- inter-ring operations
embed
twace
coeffsPow, coeffsDec
:: (m â€˜Dividesâ€˜ mâ€™, CElt t r) => Cyc t m
r ->
:: (m â€˜Dividesâ€˜ mâ€™, CElt t r) => Cyc t mâ€™ r ->
Cyc t mâ€™ r
Cyc t m r
powBasis
crtSet
:: (m â€˜Dividesâ€˜ mâ€™, CElt t r) => Cyc t mâ€™ r -> [Cyc t m r]
:: (m â€˜Dividesâ€˜ mâ€™, CElt t r)
=> Tagged m [Cyc t mâ€™ r]
:: (m â€˜Dividesâ€˜ mâ€™, CElt t r, ...) => Tagged m [Cyc t mâ€™ r]
Figure 3.2: Representative functions for the Cyc data type. (The CElt t r constraint
is a synonym for a collection of constraints that include Tensor t, along with various
constraints on the base type r.)
liftB for B = Pow, Dec lifts a cyclotomic ring element coordinate-wise with respect to the
speciï¬ed basis (powerful or decoding).
adviseB for B = Pow, Dec, CRT returns an equivalent ring element whose internal represen-
tation might be with respect to (respectively) the powerful, decoding, or a Chinese
Remainder Theorem basis. These functions have no externally visible effect on the
results of any computations, but they can serve as useful optimization hints. E.g.,
if one needs to compute v * w1, v * w2, etc., then advising that v be in CRT
83
representation can speed up these operations by avoiding duplicate CRT conversions
across the operations.
The following functions relate to sampling error terms from cryptographically relevant
distributions:
tGaussian samples an element of the number ï¬eld ğ¾ from the â€œtweakedâ€ continuous
Gaussian distribution ğ‘¡ Â· ğ·ğ‘Ÿ, given ğ‘£ = ğ‘Ÿ2. (See section 2.2 above for background
on, and the relevance of, tweaked Gaussians. The input is ğ‘£ = ğ‘Ÿ2 because that is
more convenient for implementation.) Because the output is random, its type must be
monadic: rnd (Cyc t m r) for MonadRandom rnd.
errorRounded is a discretized version of tGaussian, which samples from the tweaked
Gaussian and rounds each decoding-basis coefï¬cient to the nearest integer, thereby
producing an output in ğ‘….
errorCoset samples an error term from a (discretized) tweaked Gaussian of parameter
ğ‘ Â· ğ‘Ÿ over a given coset of ğ‘…ğ‘ = ğ‘…/ğ‘ğ‘…. This operation is often used in encryption
schemes when encrypting a desired message from the plaintext space ğ‘…ğ‘.10
gSqNorm yields the scaled squared norm of ğ‘”ğ‘š Â· ğ‘’ (typically for a short error term ğ‘’) under
the canonical embedding, namely, Ë†ğ‘šâˆ’1 Â· â€–ğœ(ğ‘”ğ‘š Â· ğ‘’)â€–2.
Finally, the following functions involve Cyc data types for two indices m|mâ€™; recall that
this means the mth cyclotomic ring can be viewed as a subring of the mâ€™th one. Notice that in
the type signatures, the divisibility constraint is expressed as m â€˜Dividesâ€˜ mâ€™, and recall
from subsection 3.2.6 that this constraint is statically checked by the compiler and carries
no runtime overhead.
10The extra factor of ğ‘ in the Gaussian parameter reï¬‚ects the connection between coset sampling as used in
cryptosystems, and the underlying Ring-LWE error distribution actually used in their security proofs. This
scaling gives the input ğ‘£ a consistent meaning across all the error-sampling functions.
84
embed, twace are respectively the embedding and â€œtweaked traceâ€ functions between the
mth and mâ€™th cyclotomic rings.
coeffsB for B = Pow, Dec expresses an element of the mâ€™th cyclotomic ring with respect
to the relative powerful or decoding basis (âƒ—ğ‘ğ‘šâ€²,ğ‘š and âƒ—ğ‘‘ğ‘šâ€²,ğ‘š, respectively), as a list of
coefï¬cients from the mth cyclotomic.
powBasis is the relative powerful basis âƒ—ğ‘ğ‘šâ€²,ğ‘š of the mâ€™th cyclotomic over the mth one.11
Note that the Tagged m type annotation is needed to specify which subring the basis
is relative to.
crtSet is the relative CRT set âƒ—ğ‘ğ‘šâ€²,ğ‘š of the mâ€™th cyclotomic ring over the mth one, modulo a
prime power. (See subsection 3.3.3 for its formal deï¬nition and a novel algorithm for
computing it.) We have elided some constraints which say that the base type r must
represent Zğ‘ğ‘’ for a prime ğ‘.
We emphasize that both powBasis and crtSet are values (of type Tagged m [Cyc t
mâ€™ r]), not functions. Due to Haskellâ€™s laziness, only those values that are actually used
in a computation are ever computed; moreover, the compiler usually ensures that they are
computed only once each and then memoized.
In addition to the above, we also could have included functions that apply automorphisms
of cyclotomic rings, which would be straightforward to implement in our framework. We
leave this for future work, merely because we have not yet needed automorphisms in any of
our applications.
3.5.2
Implementation
We now describe some notable aspects of the Cyc and UCyc implementations. As previously
mentioned, Cyc is mainly a thin wrapper around UCyc that automatically manages the choice
11We also could have deï¬ned decBasis, but it is slightly more complicated to implement, and we have not
needed it in any of our applications.
85
of representation rep, and also includes some important optimizations for ring elements
that are known to reside in cyclotomic subrings. In turn, UCyc is a thin wrapper around
an instance of the Tensor class. (Recall that Tensor encapsulates the cryptographically
relevant linear transforms on coefï¬cient vectors for cyclotomic rings; see section 3.3 for
details.)
Representations
Cyc t m r can represent an element of the mth cyclotomic ring over base ring r in a few
possible ways:
â€¢ as a UCyc t m rep r for some rep = P, D, C, E;
â€¢ when applicable, as a scalar from the base ring r, or more generally, as an element of
the kth cyclotomic subring for some k|m, i.e., as a Cyc t k r.
The latter subring representations enable some very useful optimizations in memory and
running time: while cryptographic applications often need to treat scalars and subring
elements as residing in some larger cyclotomic ring, Cyc can exploit knowledge of their
â€œtrueâ€ domains to operate more efï¬ciently, as described in subsection 3.5.2 below.
UCyc represents a cyclotomic ring element by its coefï¬cients tensor with respect to the
basis indicated by rep. That is, for rep = P, D, C, a value of type UCyc t m rep r is
simply a value of type (t m r). However, a CRT basis over r does not always exist, e.g.,
if r represents the integers Z, or Zğ‘ for a modulus ğ‘ that does not meet certain criteria. To
handle such cases we use rep =E, which indicates that the representation is relative to a
CRT basis over a certain extension ring CRTExt r that always admits such a basis, e.g., the
complex numbers C. That is, a UCyc t m E r is a value of type (t m (CRTExt r)).
We emphasize that the extension ring CRTExt r is determined by r itself, and UCyc is
entirely agnostic to it. For example, ZqBasic uses the complex numbers, whereas the pair
type (a,b) (which, to recall, represents a product ring) uses the product ring (CRTExt a,
CRTExt b).
86
Operations
Most of the Cyc functions shown in Figure 3.2 (e.g., mulG, divG, the error-sampling func-
tions, coeffsB, powBasis, crtSet) simply call their UCyc counterparts for an appropriate
representation rep (after converting any subring inputs to the full ring). Similarly, most of
the UCyc operations for a given representation just call the appropriate Tensor method. In
what follows we describe some operations that depart from these patterns.
The algebraic instances for Cyc implement operations like (==), (+), and (*) in the
following way: ï¬rst they convert the inputs to â€œcompatibleâ€ representations in the most
efï¬cient way possible, then they compute the output in an associated representation. A few
representative rules for how this is done are as follows:
â€¢ For two scalars from the base ring r, the result is just computed and stored as a scalar,
thus making the operation very fast.
â€¢ Inputs from (possibly different) subrings of indices k1, k2|m are converted to the
compositum of the two subrings, i.e., the cyclotomic of index k = lcm(k1, k2) (which
divides m), then the result is computed there and stored as a subring element.
â€¢ For (+), the inputs are converted to a common representation and added entry-wise.
â€¢ For (*), if one of the inputs is a scalar from the base ring r, it is simply multiplied
by the coefï¬cients of the other input (this works for any r-basis representation).
Otherwise, the two inputs are converted to the same CRT representation and multiplied
entry-wise.
The implementation of the inter-ring operations embed and twace for Cyc is as follows:
embed is â€œlazy,â€ merely storing its input as a subring element and returning instantly. For
twace from index mâ€™ to m, there are two cases: if the input is represented as a UCyc value
(i.e., not as a subring element), then we just invoke the appropriate representation-speciï¬c
twace function on that value (which in turn just invokes a method from Tensor). Otherwise,
the input is represented as an element of the kâ€™th cyclotomic for some kâ€™|mâ€™, in which case
87
we apply twace from index kâ€™ to index k = gcd(m, kâ€™), which is the smallest index where
the result is guaranteed to reside, and store the result as a subring element.
Promoting Base-Ring Operations
Many cryptographic operations on cyclotomic rings are deï¬ned as working entry-wise on the
ring elementâ€™s coefï¬cient vector with respect to some basis (either a particular or arbitrary
one). For example, reducing from ğ‘… to ğ‘…ğ‘ is equivalent to reducing the coefï¬cients from Z
to Zğ‘ in any basis, while â€œdecodingâ€ ğ‘…ğ‘ to ğ‘… (as used in decryption) is deï¬ned as lifting
the Zğ‘-coefï¬cients, relative to the decoding basis, to their smallest representatives in Z. To
implement these and many other operations, we generically â€œpromoteâ€ operations on the
base ring to corresponding operations on cyclotomic rings, using the fact that UCyc t m
rep is an instance of the category-theoretic classes Functor, Applicative, Traversable,
etc.
As a ï¬rst example, consider the Functor class, which introduces the method
fmap :: Functor f => (a -> b) -> f a -> f b
Our Functor instance for UCyc t m rep deï¬nes fmap g c to apply g to each of câ€™s
coefï¬cients (in the basis indicated by rep). This lets us easily promote our specialized
lattice operations from section 3.2. For example, an instance Reduce z zq can be promoted
to an instance Reduce (UCyc t m P z) (UCyc t m P zq) simply by deï¬ning reduce =
fmap reduce. We similarly promote other base-ring operations, including lifting from Zğ‘
to Z, rescaling from Zğ‘ to Zğ‘â€², discretization of Q to either Z or to a desired coset of Zğ‘, and
more.
As a richer example, consider gadgets and decomposition (subsection 3.2.4) for a
cyclotomic ring ğ‘…ğ‘ over base ring Zğ‘. For any gadget vector over Zğ‘, there is a corresponding
88
gadget vector over ğ‘…ğ‘, obtained simply by embedding Zğ‘ into ğ‘…ğ‘. This lets us promote a
Gadget instance for zq to one for UCyc t m rep zq:12,13
gadget = fmap (fmap scalarCyc) gadget
Mathematically, decomposing an ğ‘…ğ‘-element into a short vector over ğ‘… is deï¬ned coefï¬cient-
wise with respect to the powerful basis. That is, we decompose each Zğ‘-coefï¬cient into a
short vector over Z, then collect the corresponding entries of these vectors to yield a vector
of short ğ‘…-elements. To implement this strategy, one might try to promote the function (here
with slightly simpliï¬ed signature)
decompose :: Decompose zq z => zq -> [z]
to Cyc t m zq using fmap, as we did with reduce and lift above. However, a momentâ€™s
thought reveals that this does not work: it yields output of type Cyc t m [z], whereas we
want [Cyc t m z]. The solution is to use the Traversable class, which introduces the
method
traverse :: (Traversable v, Applicative f) =>
(a -> f b) -> v a -> f (v b)
In our setting, v is UCyc t m P, and f is the list type [], which is indeed an instance of
Applicative.14 We can therefore easily promote an instance of Decompose from zq to
UCyc t m P zq, essentially via:
decompose v = traverse decompose v
We similarly promote the error-correction operation correct :: Correct zq z => [zq]
-> (zq, [z]).
12The double calls to fmap are needed because there are two Functor layers around the zq-entries of
gadget :: Tagged gad [zq]: the list [], and the Tagged gad context.
13Technically, we only instantiate the gadget-related classes for Cyc t m zq, not UCyc t m rep zq. This
is because Gadget has Ring as a superclass, which is instantiated by UCyc only for the CRT representations
rep = C, E; however, for geometric reasons the gadget operations on cyclotomic rings must be deï¬ned in
terms of the P or D representations. This does not affect the essential nature of the present discussion.
14Actually, the Applicative instance for [] models nondeterminism, not the entry-wise operations we need.
Fortunately, there is a costless newtype wrapper around [], called ZipList, that instantiates Applicative in
the desired way.
89
Rescaling. Mathematically, rescaling ğ‘…ğ‘ to ğ‘…ğ‘â€² is deï¬ned as applying âŒŠÂ·âŒ‰ğ‘â€² : Zğ‘ â†’ Zğ‘â€²
(represented by the function rescale :: Rescale a b => a -> b; see subsection 3.2.3)
coefï¬cient-wise in either the powerful or decoding basis (for geometrical reasons). However,
there are at least two distinct algorithms that implement this operation, depending on the
representation of the ring element and of Zğ‘ and Zğ‘â€². The generic algorithm simply converts
the input to the required basis and then rescales coefï¬cient-wise. But there is also a more
efï¬cient, specialized algorithm [GHS12c] for rescaling a product ring ğ‘…ğ‘ = ğ‘…ğ‘1 Ã— ğ‘…ğ‘2
to ğ‘…ğ‘1. For the typical case of rescaling an input in the CRT representation to an output in
the CRT representation, the algorithm requires only one CRT transformation for each of ğ‘…ğ‘1
and ğ‘…ğ‘2, as opposed to two and one (respectively) for the generic algorithm. In applications
like HE where ğ‘…ğ‘1 itself can be a product of multiple component rings, this reduces the
work by nearly a factor of two.
In more detail, the specialized algorithm is analogous to the one for product rings
Zğ‘1 Ã— Zğ‘2 described at the end of subsection 3.2.3. To rescale ğ‘ = (ğ‘1, ğ‘2) âˆˆ ğ‘…ğ‘1 Ã— ğ‘…ğ‘2
to ğ‘…ğ‘1, we lift ğ‘2 âˆˆ ğ‘…ğ‘2 to a relatively short representative Â¯ğ‘2 âˆˆ ğ‘… using the powerful or
decoding basis, which involves an inverse-CRT for ğ‘…ğ‘2. We then compute Â¯ğ‘â€²
2 = Â¯ğ‘2 mod ğ‘1ğ‘…
and output ğ‘âˆ’1
2) âˆˆ ğ‘…ğ‘1, which involves a CRT for ğ‘…ğ‘1 on Â¯ğ‘â€²
2.
Â· (ğ‘1 âˆ’ Â¯ğ‘â€²
2
To capture the polymorphism represented by the above algorithms, we deï¬ne a class
called RescaleCyc, which introduces the method rescaleCyc. We give two distinct in-
stances of RescaleCyc for the generic and specialized algorithms, and the compiler auto-
matically chooses the appropriate one based on the concrete types representing the base
ring.
90
STATE-OF-THE-ART HOMOMORPHIC ENCRYPTION WITH Î›âˆ˜ğœ†
CHAPTER 4
Homomorphic encryption is a powerful cryptographic construction which allows com-
putation on encrypted data. It has numerous applications, such as securely ofï¬‚oading
computation to an untrusted third party, private information retrieval [Yi+13], multi-party
computation [MW15], statistical analysis on a large-scale multidimensional corpus [WH12],
and advertising [NLV11], to name a few. Following the ï¬rst plausible construction by Gentry
in 2009 [Gen09b; Gen09a], improvement in the theory of homomorphic encryption has led
to schemes with better efï¬ciency, stronger security assurances, and specialized features (see,
e.g., [Dij+10; SV14; BV11b; Cor+11; CNT12; BV14a; BGV14; Bra12; GHS12b; GHS12a;
Che+13; AP13; Gen+13; BV14b; AP14].)
The promise of efï¬cient homomorphic encryption has led to several implementations of
somewhat-homomorphic encryption (SHE) schemes, all of which highlight particular aspects
of SHE/FHE (e.g., efï¬cient bootstrapping [DM15], good performance [HS], parallelism
using GPUs [Wan+12], and partial parameter generation [LCP17]). However, each lacks
important theoretical developments in homomorphic encryption which results in suboptimal
performance and functionality.
In this chapter, we deï¬ne an advanced SHE scheme that incorporates and reï¬nes a
wide collection of features from a long series of works [LPR13b; BV11b; BV14a; BGV14;
GHS12c; Gen+13; LPR13a; AP13]. Our scheme has several distinguishing features, includ-
ing:
â€¢ advanced SHE functionality like efï¬cient ring switching;
â€¢ support for large plaintext spaces, which is more efï¬cient than encrypting individual
bits;