bytes.
HTTP Methods
When you are attacking web applications, you will be dealing almost exclusively
with the most commonly used methods: GET and POST. You need to be aware
of some important differences between these methods, as they can affect an
application’s security if overlooked.
The GET method is designed to retrieve resources. It can be used to send
parameters to the requested resource in the URL query string. This enables
users to bookmark a URL for a dynamic resource that they can reuse. Or other
users can retrieve the equivalent resource on a subsequent occasion (as in a
bookmarked search query). URLs are displayed on-screen and are logged in
various places, such as the browser history and the web server’s access logs.
They are also transmitted in the Referer header to other sites when external
cc0033..iinndddd 4422 88//1199//22001111 1122::0033::4433 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 43
Chapter 3 n Web Application Technologies 43
links are followed. For these reasons, the query string should not be used to
transmit any sensitive information.
The POST method is designed to perform actions. With this method, request
parameters can be sent both in the URL query string and in the body of the
message. Although the URL can still be bookmarked, any parameters sent in
the message body will be excluded from the bookmark. These parameters will
also be excluded from the various locations in which logs of URLs are main-
tained and from the Referer header. Because the POST method is designed for
performing actions, if a user clicks the browser’s Back button to return to a
page that was accessed using this method, the browser does not automatically
reissue the request. Instead, it warns the user of what it is about to do, as shown
in Figure 3-1. This prevents users from unwittingly performing an action more
than once. For this reason, POST requests should always be used when an action
is being performed.
Figure 3-1: Browsers do not automatically reissue POST requests made by
users, because these might cause an action to be performed more than once
In addition to the GET and POST methods, the HTTP protocol supports numer-
ous other methods that have been created for specifi c purposes. Here are the
other ones you are most likely to require knowledge of:
n HEAD functions in the same way as a GET request, except that the server
should not return a message body in its response. The server should return
the same headers that it would have returned to the corresponding GET
request. Hence, this method can be used to check whether a resource is
present before making a GET request for it.
n TRACE is designed for diagnostic purposes. The server should return in the
response body the exact contents of the request message it received. This
can be used to detect the effect of any proxy servers between the client
and server that may manipulate the request.
n OPTIONS asks the server to report the HTTP methods that are available for
a particular resource. The server typically returns a response containing
anAllow header that lists the available methods.
n PUT attempts to upload the specifi ed resource to the server, using the con-
tent contained in the body of the request. If this method is enabled, you
may be able to leverage it to attack the application, such as by uploading
an arbitrary script and executing it on the server.
cc0033..iinndddd 4433 88//1199//22001111 1122::0033::4444 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 44
44 Chapter 3 n Web Application Technologies
Many other HTTP methods exist that are not directly relevant to attacking
web applications. However, a web server may expose itself to attack if certain
dangerous methods are available. See Chapter 18 for further details on these
methods and examples of using them in an attack.
URLs
A uniform resource locator (URL) is a unique identifi er for a web resource through
which that resource can be retrieved. The format of most URLs is as follows:
protocol://hostname[:port]/[path/]file[?param=value]
Several components in this scheme are optional. The port number usually is
included only if it differs from the default used by the relevant protocol. The
URL used to generate the HTTP request shown earlier is as follows:
https://mdsec.net/auth/488/YourDetails.ashx?uid=129
In addition to this absolute form, URLs may be specifi ed relative to a particular
host, or relative to a particular path on that host. For example:
/auth/488/YourDetails.ashx?uid=129
YourDetails.ashx?uid=129
These relative forms are often used in web pages to describe navigation within
the website or application itself.
NOTE You may encounter the term URI (or uniform resource identifi er)
being used instead of URL, but it is really only used in formal specifi cations
and by those who want to exhibit their pedantry.
REST
Representational state transfer (REST) is a style of architecture for distributed
systems in which requests and responses contain representations of the current
state of the system’s resources. The core technologies employed in the World
Wide Web, including the HTTP protocol and the format of URLs, conform to
the REST architectural style.
Although URLs containing parameters within the query string do themselves
conform to REST constraints, the term “REST-style URL” is often used to signify
a URL that contains its parameters within the URL fi le path, rather than the
query string. For example, the following URL containing a query string:
http://wahh-app.com/search?make=ford&model=pinto
corresponds to the following URL containing “REST-style” parameters:
http://wahh-app.com/search/ford/pinto
cc0033..iinndddd 4444 88//1199//22001111 1122::0033::4444 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 45
Chapter 3 n Web Application Technologies 45
Chapter 4 describes how you need to consider these different parameter styles
when mapping an application’s content and functionality and identifying its
key attack surface.
HTTP Headers
HTTP supports a large number of headers, some of which are designed for
specifi c unusual purposes. Some headers can be used for both requests and
responses, and others are specifi c to one of these message types. The following
sections describe the headers you are likely to encounter when attacking web
applications.
General Headers
n Connection tells the other end of the communication whether it should
close the TCP connection after the HTTP transmission has completed or
keep it open for further messages.
n Content-Encoding specifi es what kind of encoding is being used for the
content contained in the message body, such as gzip, which is used by
some applications to compress responses for faster transmission.
n Content-Length specifi es the length of the message body, in bytes (except
in the case of responses to HEAD requests, when it indicates the length of
the body in the response to the corresponding GET request).
n Content-Type specifi es the type of content contained in the message body,
such as text/html for HTML documents.
n Transfer-Encoding specifi es any encoding that was performed on the
message body to facilitate its transfer over HTTP. It is normally used to
specify chunked encoding when this is employed.
Request Headers
n Accept tells the server what kinds of content the client is willing to accept,
such as image types, offi ce document formats, and so on.
n Accept-Encoding tells the server what kinds of content encoding the client
is willing to accept.
n Authorization submits credentials to the server for one of the built-in
HTTP authentication types.
n Cookie submits cookies to the server that the server previously issued.
n Host specifi es the hostname that appeared in the full URL being requested.
cc0033..iinndddd 4455 88//1199//22001111 1122::0033::4444 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 46
46 Chapter 3 n Web Application Technologies
n If-Modified-Since specifi es when the browser last received the requested
resource. If the resource has not changed since that time, the server may
instruct the client to use its cached copy, using a response with status code 304.
n If-None-Match specifi es an entitytag, which is an identifi er denoting the
contents of the message body. The browser submits the entity tag that
the server issued with the requested resource when it was last received.
The server can use the entity tag to determine whether the browser may
use its cached copy of the resource.
n Origin is used in cross-domain Ajax requests to indicate the domain from
which the request originated (see Chapter 13).
n Referer specifi es the URL from which the current request originated.
n User-Agent provides information about the browser or other client soft-
ware that generated the request.
Response Headers
n Access-Control-Allow-Origin indicates whether the resource can be
retrieved via cross-domain Ajax requests (see Chapter 13).
n Cache-Control passes caching directives to the browser (for example,
no-cache).
n ETag specifi es an entity tag. Clients can submit this identifi er in future
requests for the same resource in the If-None-Match header to notify the
server which version of the resource the browser currently holds in its cache.
n Expires tells the browser for how long the contents of the message body
are valid. The browser may use the cached copy of this resource until
this time.
n Location is used in redirection responses (those that have a status code
starting with 3) to specify the target of the redirect.
n Pragma passes caching directives to the browser (for example, no-cache).
n Server provides information about the web server software being used.
n Set-Cookie issues cookies to the browser that it will submit back to the
server in subsequent requests.
n WWW-Authenticate is used in responses that have a 401 status code to
provide details on the type(s) of authentication that the server supports.
n X-Frame-Options indicates whether and how the current response may
be loaded within a browser frame (see Chapter 13).
cc0033..iinndddd 4466 88//1199//22001111 1122::0033::4444 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 47
Chapter 3 n Web Application Technologies 47
Cookies
Cookies are a key part of the HTTP protocol that most web applications rely
on. Frequently they can be used as a vehicle for exploiting vulnerabilities. The
cookie mechanism enables the server to send items of data to the client, which
the client stores and resubmits to the server. Unlike the other types of request
parameters (those within the URL query string or the message body), cookies
continue to be resubmitted in each subsequent request without any particular
action required by the application or the user.
A server issues a cookie using the Set-Cookie response header, as you
have seen:
Set-Cookie: tracking=tI8rk7joMx44S2Uu85nSWc
The user’s browser then automatically adds the following header to subsequent
requests back to the same server:
Cookie: tracking=tI8rk7joMx44S2Uu85nSWc
Cookies normally consist of a name/value pair, as shown, but they may consist
of any string that does not contain a space. Multiple cookies can be issued by
using multiple Set-Cookie headers in the server’s response. These are submit-
ted back to the server in the same Cookie header, with a semicolon separating
different individual cookies.
In addition to the cookie’s actual value, the Set-Cookie header can include
any of the following optional attributes, which can be used to control how the
browser handles the cookie:
n expires sets a date until which the cookie is valid. This causes the browser
to save the cookie to persistent storage, and it is reused in subsequent
browser sessions until the expiration date is reached. If this attribute is
not set, the cookie is used only in the current browser session.
n domain specifi es the domain for which the cookie is valid. This must be
the same or a parent of the domain from which the cookie is received.
n path specifi es the URL path for which the cookie is valid.
n secure — If this attribute is set, the cookie will be submitted only in HTTPS
requests.
n HttpOnly — If this attribute is set, the cookie cannot be directly accessed
via client-side JavaScript.
Each of these cookie attributes can impact the application’s security. The
primary impact is on the attacker’s ability to directly target other users of the
application. See Chapters 12 and 13 for more details.
cc0033..iinndddd 4477 88//1199//22001111 1122::0033::4444 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 48
48 Chapter 3 n Web Application Technologies
Status Codes
Each HTTP response message must contain a status code in its fi rst line, indi-
cating the result of the request. The status codes fall into fi ve groups, according
to the code’s fi rst digit:
n 1xx — Informational.
n 2xx — The request was successful.
n 3xx — The client is redirected to a different resource.
n 4xx — The request contains an error of some kind.
n 5xx — The server encountered an error fulfi lling the request.
There are numerous specifi c status codes, many of which are used only in
specialized circumstances. Here are the status codes you are most likely to
encounter when attacking a web application, along with the usual reason phrase
associated with them:
n 100 Continue is sent in some circumstances when a client submits a
request containing a body. The response indicates that the request headers
were received and that the client should continue sending the body. The
server returns a second response when the request has been completed.
n 200 OK indicates that the request was successful and that the response
body contains the result of the request.
n 201 Created is returned in response to a PUT request to indicate that the
request was successful.
n 301 Moved Permanently redirects the browser permanently to a different
URL, which is specifi ed in the Location header. The client should use the
new URL in the future rather than the original.
n 302 Found redirects the browser temporarily to a different URL, which is
specifi ed in the Location header. The client should revert to the original
URL in subsequent requests.
n 304 Not Modified instructs the browser to use its cached copy of the
requested resource. The server uses the If-Modified-Since and If-None-
Match request headers to determine whether the client has the latest version
of the resource.
n 400 Bad Request indicates that the client submitted an invalid HTTP request.
You will probably encounter this when you have modifi ed a request in
certain invalid ways, such as by placing a space character into the URL.
n 401 Unauthorized indicates that the server requires HTTP authentication
before the request will be granted. The WWW-Authenticate header contains
details on the type(s) of authentication supported.
cc0033..iinndddd 4488 88//1199//22001111 1122::0033::4444 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 49
Chapter 3 n Web Application Technologies 49
n 403 Forbidden indicates that no one is allowed to access the requested
resource, regardless of authentication.
n 404 Not Found indicates that the requested resource does not exist.
n 405 Method Not Allowed indicates that the method used in the request is
not supported for the specifi ed URL. For example, you may receive this
status code if you attempt to use the PUT method where it is not supported.
n 413 Request Entity Too Large — If you are probing for buffer overfl ow
vulnerabilities in native code, and therefore are submitting long strings
of data, this indicates that the body of your request is too large for the
server to handle.
n 414 Request URI Too Long is similar to the 413 response. It indicates that
the URL used in the request is too large for the server to handle.
n 500 Internal Server Error indicates that the server encountered an
error fulfi lling the request. This normally occurs when you have submit-
ted unexpected input that caused an unhandled error somewhere within
the application’s processing. You should closely review the full contents
of the server’s response for any details indicating the nature of the error.
n 503 Service Unavailable normally indicates that, although the web
server itself is functioning and can respond to requests, the application
accessed via the server is not responding. You should verify whether this
is the result of any action you have performed.
HTTPS
The HTTP protocol uses plain TCP as its transport mechanism, which is unen-
crypted and therefore can be intercepted by an attacker who is suitably posi-
tioned on the network. HTTPS is essentially the same application-layer protocol
as HTTP but is tunneled over the secure transport mechanism, Secure Sockets
Layer (SSL). This protects the privacy and integrity of data passing over the
network, reducing the possibilities for noninvasive interception attacks. HTTP
requests and responses function in exactly the same way regardless of whether
SSL is used for transport.
NOTE SSL has strictly been superseded by transport layer security (TLS), but
the latter usually still is referred to using the older name.
HTTP Proxies
An HTTP proxy is a server that mediates access between the client browser and
the destination web server. When a browser has been confi gured to use a proxy
cc0033..iinndddd 4499 88//1199//22001111 1122::0033::4444 PPMM
Stuttard c03.indd V3 - 07/22/2011 Page 50
50 Chapter 3 n Web Application Technologies
server, it makes all its requests to that server. The proxy relays the requests to
the relevant web servers and forwards their responses back to the browser.
Most proxies also provide additional services, including caching, authentica-
tion, and access control.
You should be aware of two differences in how HTTP works when a proxy
server is being used:
n When a browser issues an unencrypted HTTP request to a proxy server, it
places the full URL into the request, including the protocol prefi x http://,
the server’s hostname, and the port number if this is nonstandard. The
proxy server extracts the hostname and port and uses these to direct the
request to the correct destination web server.
n When HTTPS is being used, the browser cannot perform the SSL hand-
shake with the proxy server, because this would break the secure tunnel
and leave the communications vulnerable to interception attacks. Hence,
the browser must use the proxy as a pure TCP-level relay, which passes
all network data in both directions between the browser and the destina-