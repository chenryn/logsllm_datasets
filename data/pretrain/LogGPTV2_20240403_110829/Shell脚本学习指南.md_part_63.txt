第13章
进程
进程（process）指的是执行中程序的一个实例（instance）。新进程由fork（）与execve（）
等系统调用所起始，然后执行，直到它们下达exit（）系统调用为止。系统调用fork（）
与execve（）的处理相当复杂，且不是本书所要说明的范畴，如果你有兴趣，可以参考
它们的网页，
UNIX系统都支持多进程。虽然计算机看来像是一次微了很多事，但除非是它拥有多个
CPU，否则这只是错觉，事实上，每个进程仅容许在一个极短的期间执行，我们称为时
间片段（timeslice），之后进程会先暂时掏置，让其他等待中的进程执行。时间片段极
短，通常只有几微秒，所以人们很少感觉得到进程将控制权交回kernel，再交给另一个
进程的这种文本切换（contextswitches）。进程本身不管本文切换这件事，也没有必要
在程序里撰写撤回控制权子操作系统的处理。
操作系统内核里，称为调度器（scheduler）的部分负责管理进程的执行。当出现多CPU
时，调度器会试着使用所有CPU处理工作负载。用户除了觉得响应速度的改善之外，多
半不会查觉有何不同，
进程会被指定优先权，这么一来，有时间考虑的进程使能比不重要的进程先执行：nice
与rnice命令即用于调整进程的优先杯
upt命便能示：
S uptime
1:51pm up 298 day(s), 15:42, 32 users, 1oad average: 3.51, 3.50, 3.55
星示开机至今的时间、用户数，及平均负酸
由于平均负载会一直变化，uptime会回报三个平均时闻估算值、分别为最后一分钟、
五分钟及十五分钟的估算值。当平均负载持续地超出可用CPU的承载时，表示系统工作
已超出它所能负荷的了，此时响应可能会陷X述前的状态：
363
www.TopSage.com
---
## Page 376
364
十第
两
讨论操作系统的书，对进程与调度器有较深入的探讨，在本书中讲得太深人会有些文不）11
对题，对大部分用户而言，也没有必要。所以我们在本章，只说明如何建立进程、列出
进程，及删除进程。除此之外，还会介绍将信号传递给进程的方式，及如何监控进程的
执行
13.1进程建立
UNIX对计算机运算世界最大的贡献，就是能够轻易地建立进程。此举有助于用户为庞
大的工作先撰写小型程序处理各个部分，再将它们整合完成整个工作。由于程序设计的
复杂度与日俱增，以小型程序的方式处理会更好写、更好除虫，也更易于了解。
很多程序都由Shell启动：每个命令行里的第一个单词是识别要执行的程序。一个命令
Shell所起始每个进程，都会以下列保证事项启动：
进程具有一个内核本文（kernelcontext）：在内核里的数据结构，会记录与进程相
关的信息，让内核便于管理与控制进程的执行。
进程拥有一个私用的（private）、被保护的（protected）虚拟地址空间，它可能就
像机器可定址空间那么大，不过，其他资源的限制，像是实例内存与外部储存设备
上的swap空间所组合的大小，其他执行中工作的大小，或是系统调校参数的本地
端设置，都会加诸进程执行上的限制。
三个文件描述代码（标准输人、标准输出，与标准错误输出）都已开启，且立即可
用。
起始于交谈模式Shell的进程，会拥有一个控制终端机（controllingterminal），其
扮演三个标准文件数据流的默认来源处与目的地，控制终端机是让用户可将信号传
送给进程，这部分主题在稍后13.3节里将会介绍。
命令行参数里的通配字符会被展开。
内存的一个环境变量区城会存在，包含具有键与值（key/value）指定的字符串，可
通过程序库调用取得（在C里，为getenv（））。
这些保证没有任何差别待遇：所有执行于相同优先权层级的进程都一视同仁，且进程可
以由任何程序写成。
私有地址空间（privateaddressspace）可确保进程不受其他进程或内核干扰，未提供
这样保障的操作系统很容易出错。
这三个已开启的文件，对大部分的程序来说已经够用，可以使用它们而无需烦恼文件开
启与关闭的操作，也不需要知道任何文件名语法或文件系统。
www.TopSage.com
---
## Page 377
进程
365
由Shell展开的通配字符会免除程序的很多负担，也提供了统一性的命令行处理。
环境空间（eavironment space）是除了命令行与输入文件之外，可提供信息给进程的另
一种方式。
13.2
进程列表
列出进程中最重要的命令便是进程状态（process status）命令：Ds.长久以来，ps的
形式发展出主要的两种：SystemV式与BSD式。很多系统两者都提供，有些则是择一
选择性地提供。在SunSolaris系统下：
s /bin/ps
AL GId
SystemV式的进程状态
0:00ps
TIXE CHD
5026 pt8/60
2659 pts/60
0:02 ksh
12369 pts/92
0:02 bash
$ /usr/ucb/pa
BSD式的进程状态
PID TT
2660 pts/60
0.
sd/qori/zsm/00=0
12369 pts/92
5026pt8/60
S0:02/usr/loca1/bin/bash
S
0:01 /bin/ksh
未提供命令行选项，它们的输出就会很相似，只是BSD式的细节较多。这里的输出，可
Ds是与1s的文件列出命令很像，也提供相当多的选项，且在UNIX各种平台上都各有
不同版本，以1s而言，-1选项输出长式数据，是常见用法。如果要取得ps的长
输出，则需要其他选项，在SystemV形式下：
S p8 -ef1
Systen v风格
19 T root
F 'S UID PID PPID C PRI NI ADDR SZ'WCHAN -STIRE -TTY.
DC27.?
TINE CMD
8 S root
0
004120
0.005Y
7 106
D
7 Dec 27 7
s 00:0
19 S root
1
9:53 /etc/init -
19 S root
2
00.0SY:？
00
AS0
D
7 Dec 27 ?
3
? Dec 27 ? 2852:26 fsflush
0:18 pageout
 * *
0
在BSD形式下，则为：
$ ps aux
PID CPU MEM
BSD风格
USER
5582S.
START
TIXE COMMAND
root
30.40.0
0
0?
S
Dec 27 2852:28 fsflush
snith 13680 0.1 0.2 1664 1320 pts/25 o 15:03:45
jones 25268
0.1
2.02093619376 pts/24 S
29:56 enacs -bg ivory
0:00 ps aux
bromm 265190.00.3 54242944 ?
Kar 22
S
Apr 19
2:05 xterm -name thesis
+ + r
www.TopSage.com
---
## Page 378
366
第13章
这两种形式都允许结合选项字母一起执行，而BSD形式还允许去除选项连字号，这两个
例子中，为了符合解说页面，我们都适度地去除了过多的空白。
在这两种类型上，部分设计井不恰当，有时信息太多，但显示的空间却太少：进程起始
日期的缩写格式各有不同，而最后一栏的命令有时会被截断，且显示的栏位值有时也会
全挤在一起，后者令我们在过滤pB的输出时变得很困难，
USER与UID栏为进程拥有者：当你发现进程悬在系统上不动时，这会是关键信息。
PID为进程ID值（processID），此数字是定义进程的唯一值。在ShelI中，该数字可以
到新的进程便加值，直至系统停止，在到达最大可表示的整数值时，进程编号会再从零
开始，但避开已被其他进程使用的值。传统的单一用户系统可能只有少数儿个活动中的
进程，但大型的多用户系统可能就拥有数以千计的进程了。
第一个进程外，每个进程都有父进程并会拥有零至多个子进程，所以进程的形式为树状
结构。进程编号0通常被称为kernel、sched，或ewapper，而且在某些系统上井不会
显示在ps的输出结果中，进程编号1比较特殊：称为init，可参考inir（8）的使用手
册。父进程过早消失（die）的进程，会被重新指定其新的父进程为init。系统在正常
关机下，进程的删除是以由大至小的进程ID依次执行，直到只剩下init为止，当它结
束时，系统便终止。
ps输出的序不保证有一定的规则，且由于进程的列表是持续地变动的，每次执行时都
会看到不同的输出。
由于进程列表是动态的，许多用户会想要持续观察类似Ds这样的文字输出更新状态，或
以图形呈现。很多工具程序提供显示这类信息，但没有共通可用的标准工具。最通用的
应是top了，这是现行许多UNIX版本里的标准工具（注1），我们认为这个工具和GNU
的比ar一样重要，因此如果发现新系统不提供此工具，我们就会立即安装一个。在大部
分系统上，top必须详熟内核数据结构的相关知识，且当操作系统升级时，它也必须更
新，top（类似ps）是少数儿个需特殊权限才能执行的程序，某些系统上，会以setuid
为root的方式变通行事。
此处为top的输出快照（snapshot），这里显示的多处理器计算机服务器还不算太忙碌：
注 1;
可由fp:/ftp.grouprys.com/pab/top下载，另一个仅GNU/Linux系统适用的实例，可参
考 hrtp://procps.sourceforge.met/,
www.TopSage.com
---
## Page 379
进程
1oad averages:5.28,4.74,4.59
do4 $
322 proceses:295 sleeping.4 running, 12 zombie,9 stopped,2 on cpu
15:42:00
CPU ptates:0.0idle,95.98 user, 4.1 kernel,0.0$iowait.,0.08 sap
Memory: 20488 real, 88x free, 1916x swap in use, 8090M swap free
2518jones
PID USERNAME THR PRI NICE
SIZE
505M run
RES STATE
44:43 33.95# Macaulay2
TIME
CPU COMMAND
1
0
506M
23813 smith
1111 owens
1
0
1.9
21K run
768:57 20.39s mserver
87:1924.04ocDom
19
184H
184M cpu/0
25389 brom
1
6T
HOE
23M run
18422.1.07 netscape
+ +
默认状态下，tOP会在列表顶端显示CPU耗用最多的进程，这通常也就是你想看的那
个。不过，top还接受键盘输人，控制排序顺序、限定显示你感兴趣者等等，只要在top
通信期（session）下输人type？，即可得知你的top版本提供了哪些用法。
其他一些列出进程，或显示各类系统负载状态的好用命令，我们量现于表13-1。
表13-1：好用的系统负载命令
系统
命令
所有系统
iostat、netstat,nfsstat、ar,uptime, vmstat, w,xcpustate
x1oad，与xperfmon
Apple Mac OS X
pstat
BSD
pstat 与 systat
GNU/Linux
procinfo
HP A1pha OSF/1
vmube
IBM AIX
monitor
SGIIRIX
gr_osview与osview
Sun Solaris
mpstat、perfmeter、proctool、prstat、ptree 与 sdtperfmeter
注：可由fip:/ftp.cs.toronto.edw/pub/jdd/xcpustate/取将
大部分情况下，Shell在处理下一个命令之前会等待一进程结束。不过只要在命令最后加
人&字符，而非分号或换行符号，便能将进程放在后台中执行：我们在8.2节的build-
al1脚本里使用过此功能。wait命令可用以等待某个特定进程完成，在不加任何参数