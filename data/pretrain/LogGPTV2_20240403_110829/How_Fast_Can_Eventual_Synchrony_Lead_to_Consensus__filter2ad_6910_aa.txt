title:How Fast Can Eventual Synchrony Lead to Consensus?
author:Partha Dutta and
Rachid Guerraoui and
Leslie Lamport
How Fast Can Eventual Synchrony Lead
to Consensus?
Partha Dutta
EPFL, Switzerland
Rachid Guerraoui
EPFL, Switzerland
Leslie Lamport
Microsoft
9 March 2005
To appear in Proceedings of the 2005 International Conference on
Dependable Systems and Networks (DSN 2005).
Abstract
It is well known that the consensus problem can be solved in a distributed
system if, after some time TS, no process fails and there is some upper bound
δ on how long it takes to deliver a message. We know of no existing algorithm
that guarantees consensus among N processes before time TS + O(N δ). We
show that consensus can be achieved by time TS + O(δ).
Contents
1 Introduction
2 Traditional Paxos
3 Round-Based Algorithms
4 The Modiﬁed Paxos Algorithm
5 The Modiﬁed B-Consensus Algorithm
6 Concluding Remarks
1
3
4
5
10
11
1
Introduction
Unbounded message delays and continual process failures make it impossible
to guarantee that a consensus algorithm will terminate [6]. Suppose there is
some time TS after which no process fails and messages are delivered within
a bounded length of time. How soon after time TS can an algorithm ensure
that all nonfaulty processes have reached consensus? It is this question that
we address.
We consider only omission (non-Byzantine) faults. We allow messages to
be lost and processes to fail by stopping, but messages may not be corrupted
and faulty processes may not perform incorrect actions. Byzantine faults
are discussed in the conclusion. A failed process can restart at any time.
Processes have timers that run at approximately the same rate after time
TS.
We say that the system is stable after time TS, and we let δ seconds be the
bound on message-delivery time after stability is reached. More precisely, we
assume that when the system is stable, a nonfaulty process will receive and
react to a message within δ seconds of when the message was sent. (Hence,
δ includes the time needed to process the message after it is received.) We
can therefore consider process actions to be instantaneous, processing time
being counted as message-delivery time or, for actions generated by timeout,
as part of the waiting time. We assume that a majority of the processes are
nonfaulty at time TS, and hence remain nonfaulty forever. (It obviously
doesn’t matter if processes fail after consensus has been reached, but we
assume for simplicity that they never fail after time TS.) We let N be the
number of processes and number them from 0 through N − 1.
Since consensus requires interprocess communication, and all messages
sent before TS might be lost, it must take at least O(δ) seconds after stability
(For presentation simplicity, we write O(∗) for both
to reach consensus.
O(∗) and Ω(∗).) This paper shows how this bound can be achieved. More
precisely, we assume that all processes have (unsynchronized) local clocks
that, after time TS, have an error in their running rate of at most some
known value ρ (cid:191) 1. We describe an algorithm in which every process that
is nonfaulty at time TS decides by time TS + O(δ). Every process that
restarts after time TS decides within O(δ) seconds after it has restarted.
(Recall that we assume no process fails after time TS.)
The processes do not know when time TS has arrived; they have no way
of knowing that the system has become stable. However, we do assume that
the value of δ is known. Although consensus can be guaranteed even if δ is
not known [5], the following informal argument suggests that an algorithm
1
must know δ to achieve a time bound independent of the length of time
that elapses before stability (TS). A completely asynchronous, deterministic
algorithm cannot solve consensus [6]. To ensure progress, an algorithm must
use timeouts to keep from waiting forever for responses from failed processes.
To ensure that consensus is reached after stability, the timeout intervals
must be of length O(δ). If the value of δ is not known to the algorithm,
then the only way to ensure progress seems to be to set the timeouts based
on some guess γ of the value of δ, and to keep increasing γ until consensus
is reached [5]. The time needed to reach consensus after stability is then
O(γS), where γS is the value of γ at time TS. Since γ can grow without
bound until stability is reached, consensus cannot be achieved within O(δ)
seconds after stability. We therefore assume that δ is known.
In this paper, we measure the time required for all nonfaulty processes to
decide in a consensus algorithm; the time required for the processes to termi-
nate the algorithm might be higher. As processes never know if the system
has reached stability, an algorithm cannot terminate until every process
knows that all nonfaulty processes have reached a decision. Otherwise,
processes might terminate before time TS, and there could be a nonfaulty
process that has not decided because it has been unable to communicate
with any other process.
The problem of ﬁnding an algorithm that reaches consensus within O(δ)
can be solved with some simple modiﬁcations to the Paxos consensus al-
gorithm [3, 9, 10] if we assume that the bound on message-delivery time
that holds after TS also applies to messages sent before that time—in other
words, every message sent before time TS is either lost or delivered by time
TS + δ. Furthermore, if we assume that on restart, a process knows that it
has failed so that it can execute a special initialization procedure, then the
problem becomes simpler. Without these assumptions however, the problem
is hard because, even after time TS, an algorithm must cope with obsolete
messages either sent before TS by failed processes or sent by newly-restarted
processes. To our knowledge, all previous consensus algorithms require in
the worst case at least O(N δ) seconds after stability to reach consensus.
Our primary solution is a round-based variant of the Paxos algorithm. In
Section 2 we brieﬂy recall the Paxos algorithm and then point out why any
simple modiﬁcation to Paxos does not decide within O(δ) seconds after TS.
In Section 3 we explain why typical round-based algorithms do not achieve
the desired performance either. Section 4 presents our modiﬁed version of
the Paxos consensus algorithm and its timing analysis. Section 5 brieﬂy
outlines another solution based on an algorithm of Pedone, Schiper, Urb´an,
and Cavin [14]. The concluding section brieﬂy considers Byzantine failures.
2
2 Traditional Paxos
Before presenting our modiﬁed version, we describe the traditional Paxos
consensus algorithm. We omit many details that, while crucial to its cor-
rectness, are irrelevant to our discussion.
The Paxos algorithm assumes a leader-election procedure whose correct
operation is required only to ensure progress, not safety. Each process p
maintains a natural number mbal[p], called its ballot number, which it at-
taches as the ﬁeld m.mbal to every message m it sends. (The variable mbal[p]
was called nextBal[p] in [9] and Commit in [3].) The initial value of mbal[p]
doesn’t matter; for later convenience we let it equal p. The process keeps
mbal[p] (and the rest of its state) in stable storage so it can restart after fail-
ure by simply resuming where it left oﬀ. Process p can execute the following
actions:
Start Phase 1 At any time, if p believes itself to be the leader, then it can
increase mbal[p] to an arbitrary value congruent to p mod N and send
a phase 1a message to every process (including itself).
Receive Phase 1a Message If p receives a phase 1a message m with m.mbal >
mbal[p] then it sets mbal[p] to m.mbal and sends a phase 1b message
to process m.mbal mod N.
Start Phase 2 If p receives a phase 1b message m with m.mbal = mbal[p]
from (cid:100)N/2(cid:101) diﬀerent processes then it sends a phase 2a message to
every process.
Receive Phase 2a Message If p receives a phase 2a message m with m.mbal ≥
mbal[p] then it sets mbal[p] to m.mbal and sends a phase 2b message
to every process.
Decide If p receives phase 2b messages with the same mbal ﬁeld from a
majority of processes then it decides on a value.
Reject Message If p receives a phase 1a or phase 2a message m with m.mbal <
mbal[p],
m.mbal mod N.
it sends a rejected message containing mbal[p] to process
In a real implementation, once a process has decided, it would stop executing
the algorithm and simply respond to every message by announcing the value
it has decided upon. We ignore this optimization for now.
Suppose the leader-election procedure is guaranteed to choose a unique,
nonfaulty leader within O(δ) seconds after the system is stable, and the
3
leader spontaneously executes the Start Phase 1 action every O(δ) seconds.
The following plausible but incorrect argument shows that the Paxos al-
gorithm then guarantees consensus within O(δ) seconds after stability. By
time TS +O(δ), a single process q believes itself to be the leader and executes
the Start Phase 1 action. If the value of mbal[q] that q chooses is larger than
the value of mbal[p] for all other nonfaulty processes p, then consensus will
be reached after all the phase 1a, 1b, 2a, and 2b messages for ballot mbal[q]
are generated by and delivered to nonfaulty processes, which takes at most
4δ seconds. If mbal[q] is less than mbal[p] for some p, then q will receive a
rejected message from p within 2δ seconds and can then execute the Start
Phase 1 action with a larger value of mbal[q]. In this case, consensus will be
reached within 6δ seconds. Hence, consensus is reached within O(δ) seconds
after TS.
The argument that consensus is reached within 4δ or 6δ seconds after q
executes Start Phase 1 is fallacious. It assumes that no process receives a
message m with m.mbal greater than q’s ﬁnal choice of mbal[q]. However,
there could be messages with higher mbal ﬁelds that were sent by processes
that have since failed, or by failed processes that just restarted. Receipt of
such a message could prevent the algorithm from succeeding with the current
value of mbal[q], forcing q to choose a larger value. Since there could be as
many as (cid:100)N/2(cid:101) − 1 such failed processes, it could take O(N δ) seconds to
reach consensus after q ﬁrst executes the Start Phase 1a action.
We will present a version of the Paxos algorithm that does achieve con-
sensus within O(δ) seconds of stability, without relying on any election al-
gorithm. However, we ﬁrst discuss round-based consensus algorithms.
3 Round-Based Algorithms
There are several consensus algorithms that work roughly as follows [2, 5].
Processes execute a sequence of rounds. A process executing round i ignores
messages from lower-numbered rounds; if it receives a message from a higher-
numbered round j, then it begins executing round j. If consensus is not
reached in round i, then a timeout will cause some process to abort round
i and begin round i + 1. (Although aborting might be attributed to the
pronouncement of some oracle, such as a failure detector, the oracle’s imple-
mentation issues the pronouncement when a timeout occurs.) To ensure that
a round started after the system is stable succeeds in reaching consensus, a
timeout interval of O(δ) must be used.
In these round-based algorithms, the round number plays the same role
4
as the ballot number in the Paxos algorithm. The Paxos algorithm’s problem
of old messages with large ballot numbers can be avoided in round-based
algorithms by not allowing a process spontaneously to enter round i+1 until
it has learned that a majority of the processes have begun round i. This
ensures that whenever a majority of the processes are nonfaulty, if a round
i message has been sent, then there is a nonfaulty process executing round
i− 1 or higher. This implies that if i is the highest round being executed by
some nonfaulty process when the system becomes stable, no old messages
or restarted process can disrupt any round from i + 2 on.
Eliminating the problem of obsolete messages does not ensure that round-
based algorithms reach consensus within O(δ) seconds of stability. For round
i to succeed, most of these algorithms require that a coordinator, gener-
ally process i mod N, be nonfaulty. Since there could be (cid:100)N/2(cid:101) − 1 faulty
processes, they could require O(N) rounds to reach consensus, each round
taking O(δ) seconds. There is a round-based consensus algorithm by Moste-
faoui and Raynal [13] that relies on leader election, but considering that
algorithm simply shifts our problem to that of electing a leader within O(δ)
seconds of TS, in the presence of obsolete messages and process restarts.
There is one round-based algorithm that does not rely on a coordinator or
a leader—namely, the B-Consensus algorithm of Pedone et al. [14]. Section 5
outlines an approach to modifying that algorithm so it reaches consensus
within O(δ) seconds of stability.
The number of rounds required to achieve consensus after stability is
investigated in [4], which considers a round-based eventually synchronous
model and looks at the number of rounds needed to achieve consensus after
the ﬁrst stable round is reached. However, the physical duration of a round
is not speciﬁed in [4]. In fact, if processes might restart after TS, then its
algorithm does not achieve consensus within a constant number of rounds.
4 The Modiﬁed Paxos Algorithm
We now reﬁne the Paxos algorithm to achieve consensus within O(δ) seconds
after stability. Our new version has no explicit leader election. Instead, any
process can perform a Start Phase 1 action, under certain circumstances.
The basic idea is to keep a process from choosing ballot numbers that are
too large by emulating the way round-based algorithms avoid anomalously
high round numbers.
Deﬁne the session of a ballot number b to be (cid:98)b/N(cid:99) and deﬁne process
p to be in session (cid:98)mbal[p]/N(cid:99). Similarly, the session of a message m is the
5
session of the ballot number m.mbal. We say that process p enters session s
when its session number changes from some t < s to s. We now modify the
Paxos algorithm so a process does not enter session s + 1 until a majority
of processes have entered session s. We also introduce timeouts and do
away with the leader-election procedure, making leader election implicit in
the Paxos algorithm itself. The use of timeouts makes the Reject action
unnecessary.
Each process maintains a session timer. Whenever a process enters a
new session, it resets its session timer so that if time TS has arrived, then it
will time out between 4δ and σ seconds later, for some σ ≥ 4δ with σ = O(δ).
This is possible because of our assumption that processes have timers with
a known bound ρ (cid:191) δ on their running rates after time TS. Session timers
are set initially to time out within σ seconds.
A process can execute the Start Phase 1 action whenever (i) its session
timer has timed out and (ii) it is either in session 0 or else has received a
message with its current session from a majority of the processes. Condition
(ii) means that, if mbal[p] ≥ N, then p has received a message m with
(cid:98)m.mbal/N(cid:99) = (cid:98)mbal[p]/N(cid:99) from a majority of processes. When p performs
the action, it chooses the new value of mbal[p] to increase its session number
by 1. In other words, it sets mbal[p] to ((cid:98)mbal[p]/N(cid:99) + 1)N + p. Since this
action increases p’s session number, it also resets the session timer.
We make two additional changes to the algorithm. First, we have a