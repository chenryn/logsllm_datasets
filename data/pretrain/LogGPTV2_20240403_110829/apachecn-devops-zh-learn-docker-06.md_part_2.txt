虽然这在运行在一个或几个知名和精选的服务器上的单一应用的环境中可能非常有效，但是在分布式应用架构中，它完全崩溃了。首先，在这个场景中，我们有许多组件，手动跟踪它们变成了一场噩梦。它肯定是不可扩展的。此外，服务 A 通常应该或者永远不会知道其他组件在集群的哪个节点上运行。它们的位置甚至可能不稳定，因为由于应用外部的各种原因，组件 B 可能会从节点 X 移动到另一个节点 Y。因此，我们需要服务 A 找到服务 B 或者任何其他服务的另一种方法。最常用的是外部权威机构在任何给定时间知道系统的拓扑。该外部机构或服务知道当前属于集群的所有节点及其 IP 地址；它知道所有正在运行的服务及其运行位置。通常，这种服务被称为**域名服务**，其中**域名服务**代表**域名系统**。正如我们将看到的，Docker 有一个作为底层引擎的一部分实现的 DNS 服务。Kubernetes 还使用 DNS 服务来促进集群中运行的组件之间的通信:
![](img/58f33aa3-3e09-49d8-9836-55fa714420cc.png)
Components consult an external locator service
在上图中，我们看到了服务 A 想要如何与服务 b 进行通信，但是它不能直接这样做；它必须首先向外部权威机构，一个注册服务，这里称为 a **DNS Service** ，查询服务 b 的去向，注册服务会用请求的信息进行回答，并分发服务 A 可以到达服务 b 的 IP 地址和端口号，然后服务 A 使用这些信息，并与服务 b 建立通信，当然，这是一个低层次上真实发生的事情的天真画面，但它是理解服务发现的架构模式的好画面。
# 按指定路线发送
路由是将数据包从源组件发送到目标组件的机制。路由分为不同的类型。人们使用所谓的现场视察模型(参见本章*进一步阅读*一节中的参考资料)来区分不同类型的路由。在容器和容器编排的上下文中，第 2、3、4 和 7 层的路由是相关的。我们将在后续章节中深入探讨路由的更多细节。在这里，我们只说第 2 层路由是最低级的路由类型，它将一个 MAC 地址连接到一个 MAC 地址，而第 7 层路由，也称为应用层路由，是最高级的路由。例如，后者用于将具有目标标识符(如`example.com/pets`的网址)的请求路由到我们系统中适当的目标组件。
# 负载平衡
每当服务 A 向服务 B 请求服务，但后者在多个实例中运行时，就会使用负载平衡，如下图所示:
![](img/f4bdf274-21dd-42da-b35e-6c39f27e33c8.png)
Request of Service A load balanced to Service B 
如果我们的系统中运行着多个服务实例，比如服务 B，我们希望确保每个实例都获得相同数量的工作负载。这个任务是一个通用的任务，这意味着我们不希望调用者必须进行负载平衡，而是希望一个外部服务拦截该调用，并接管决定将该调用转发到哪个目标服务实例的部分。这个外部服务被称为**负载平衡器**。负载平衡器可以使用不同的算法来决定如何将传入的呼叫分配给目标服务实例。最常用的算法叫做循环法。该算法只是以重复的方式分配请求，从实例 1 开始，然后是实例 2，直到实例 *n* 。最后一个实例完成后，负载平衡器从实例号 1 开始。
# 防御性编程
为分布式应用开发服务时，一定要记住，该服务不是独立的，而是依赖于其他应用服务，甚至依赖于第三方提供的外部服务，例如信用卡验证服务或股票信息服务，仅举两个例子。所有这些其他服务都在我们正在开发的服务之外。我们无法控制它们在任何给定时间的正确性或可用性。因此，在编码时，我们总是需要假设最坏的情况，希望最好的情况。假设最坏的情况意味着我们必须明确处理潜在的失败。
# 重试次数
当外部服务可能暂时不可用或响应不足时，可以使用以下程序。当对另一个服务的调用失败或超时时，调用代码的结构应该使同一调用在短暂的等待时间后重复。如果呼叫再次失败，在下一次尝试之前，等待时间应该稍长一些。这些呼叫应该重复到最大次数，每次都增加等待时间。之后，服务应该放弃并提供一个降级的服务，这可能意味着返回一些过时的缓存数据或者根本没有数据，这取决于具体情况。
# 记录
应始终记录服务中的重要操作。日志信息需要分类才能具有真正的价值。常见的类别有调试、信息、警告、错误和致命。日志信息应该由中央日志聚合服务收集，而不是存储在集群的单个节点上。聚合日志易于解析和过滤相关信息。
# 错误处理
如前所述，分布式应用中的每个应用服务都依赖于其他服务。作为开发人员，我们应该总是做最坏的打算，并做好适当的错误处理。最重要的最佳实践之一是快速失败。对服务进行编码，以便尽早发现不可恢复的错误，如果检测到此类错误，则让服务立即失败。但是不要忘记将有意义的信息记录到 STDERR 或 STDOUT 中，开发人员或系统操作员以后可以使用这些信息来跟踪系统的故障。此外，向调用方返回一个有用的错误，尽可能准确地指出调用失败的原因。
快速失败的一个例子是总是检查调用者提供的输入值。*数值是否在预期范围内且完整？*如果没有，那么不要尝试继续处理，而是立即中止操作。
# 裁员
关键任务系统必须全天候可用。停机是不可接受的，因为它可能会导致公司机会或声誉的巨大损失。在高度分布式的应用中，许多相关组件中至少有一个出现故障的可能性是不可忽视的。可以说，问题不在于某个组件是否会发生故障，而在于什么时候会发生故障。
为了避免当系统中的许多组件之一出现故障时停机，系统的每个单独部分都需要冗余。这包括应用组件以及所有基础架构部分。这意味着，如果我们有一个支付服务作为我们应用的一部分，那么我们需要冗余地运行这个服务。最简单的方法是在集群的不同节点上运行这个服务的多个实例。这同样适用于边缘路由器或负载平衡器。我们承受不起这样的事情。因此，路由器或负载平衡器必须是冗余的。
# 健康检查
我们已经多次提到，在分布式应用架构中，由于它有许多部分，单个组件的故障很有可能发生，并且发生故障只是时间问题。因此，我们冗余地运行系统的每个组件。代理服务然后在服务的各个实例之间负载平衡流量。
但是现在又出现了另一个问题。*代理或路由器如何知道某个服务实例是否可用？*可能已经崩溃，也可能没有反应。为了解决这个问题，人们使用所谓的健康检查。代理或代表代理的一些其他系统服务定期轮询所有服务实例并检查它们的运行状况。问题基本上是*你还在吗？* *你健康吗？*每个服务的答案要么是*是*要么是*否*，或者如果实例不再响应，则运行状况检查超时。
如果组件回答*否*或发生超时，则系统会终止相应的实例，并在其位置旋转一个新实例。如果这一切都以完全自动化的方式发生，那么我们说我们有一个自动修复系统。
# 断路器模式
**断路器**是一种用于避免分布式应用由于许多重要组件的级联故障而停机的机制。断路器有助于避免一个失败的组件在多米诺骨牌效应中摧毁其他相关服务。像电气系统中的断路器一样，它通过中断电源线来保护房屋不会因有故障的插入式电器的故障而烧毁，分布式应用中的断路器会在服务 A 没有响应或出现故障时中断服务 B 的连接。
这可以通过将受保护的服务调用包装在断路器对象中来实现。此对象监视故障。一旦故障次数达到某个阈值，断路器就会跳闸。对断路器的所有后续调用都将返回一个错误，根本不进行受保护的调用:
![](img/eda386ce-8760-4898-b916-87a75d28a9fd.png)
Circuit breaker pattern
# 投入生产
为了在生产中成功运行分布式应用，我们需要考虑前面几节中介绍的最佳实践和模式之外的一些方面。脑海中浮现的一个特定领域是自省和监控。让我们详细讨论最重要的方面。
# 记录
一旦分布式应用投入生产，就不可能对其进行调试。但是我们如何才能找出*用户报告的应用故障的根本原因到底是什么？*解决这个问题的办法是产生丰富而有意义的测井信息。开发人员需要以输出有用信息的方式来检测他们的应用服务，例如当发生错误或遇到潜在的意外或不想要的情况时。通常，这些信息被输出到 STDOUT 和 STDERR，然后由系统守护程序从那里收集，这些守护程序将信息写入本地文件或将其转发到中央日志聚合服务。
如果日志中有足够的信息，开发人员可以使用这些日志来跟踪系统中已报告错误的根本原因。
在具有许多组件的分布式应用体系结构中，日志记录甚至比单片应用更重要。通过应用的所有组件执行单个请求的路径可能非常复杂。此外，请记住组件分布在一群节点上。因此，记录所有重要的事情是有意义的，在每个日志条目中添加一些东西，例如发生的确切时间、发生的组件以及组件运行的节点等。此外，日志信息应该集中在一个中心位置，以便开发人员和系统操作员可以轻松地进行分析。