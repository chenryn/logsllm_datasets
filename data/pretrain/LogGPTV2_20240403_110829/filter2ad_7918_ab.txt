#### Flawed CSRF protection
造成这个漏洞的原因主要是因为错误配置`OAuth`组件，比如说`state`参数的配置
这个参数一般都是与会话信息相关联的一个hash值，在服务端和客户端之间来回传递，作为客户端的`CSRF`令牌
所以说，如果没有配置这个参数的时候，攻击者可以通过将户端端绑定到自己的账户来劫持客户端账户
##### Lab: Forced OAuth profile linking
描述
> ​ This lab gives you the option to attach a social media profile to your
> account so that you can log in via [OAuth](https://portswigger.net/web-> security/oauth) instead of using the normal username and password. Due to
> the insecure implementation of the OAuth flow by the client application, an
> attacker can manipulate this functionality to obtain access to other users'
> accounts.
>
> ​ To solve the lab, use a [CSRF attack](https://portswigger.net/web-> security/csrf) to attach your own social media profile to the admin user's
> account on the blog website, then access the admin panel and delete Carlos.
##### 分析
按照上面的方法，单击`My account`登陆账户
登陆成功之后跳转到了`my/-account`路由
这里存在一个选项，能够将社交账号绑定到帐号中来
点击`Attach a social profile`，之后使用靶场给的社交信息登陆
值得注意的是，在进行请求的时候，`redirect_uri`中将授权代码发送到了`/oauth-linking`路由中，特别的是，这里并没有`state`参数的存在，存在有CSRF漏洞
在burp中开启拦截器，重新加载社交账号
首先是访问传递`client_id`，将其放行
之后一直放行，出现了
点击`continue`进行认证，一直放包，最后出现了带有授权码的url，并复制这个url链接
url: `https://0ad800510493bb41c0ae20b800aa004d.web-security-academy.net/oauth-linking?code=k8gw_duVfcBUiN1irp_BkqHe8n_m9t06knW5iRVerQY`
在之后直接将数据包丢掉，以免使用了这个授权码，形成了有效的登陆
之后在其内置的漏洞利用服务器中添加能够造成CRSF漏洞的代码
最后点击`Deliver exploit to victim`将漏洞利用传递给了客户端，当其加载了`iframe`标签的时候将使用恶意的社交媒体配置文件完成
OAuth 流程，并将其附加到博客网站上的管理员帐户
之后退出账户重新使用社交账户进行登陆
已经成为了管理员账户，之后删除掉`carlos`账户完成漏洞利用
### `OAuth`服务端中的利用
#### Leaking authorization codes and access tokens
根据授权类型，代码获取token将被发送到授权请求的`redirect_uri`参数中的位置，如果服务端没有正确的校验这个URI，攻击者就能够通过这个漏洞将客户端的codes
和
token发送到攻击者控制的`redirect_uri`参数指定位置。那么攻击者就可以利用这些信息发送到服务端合法的`redirect_uri`地址中，就能成功获取用户的账户的访问权限
##### Lab: OAuth account hijacking via redirect_uri
> ​ This lab uses an [OAuth](https://portswigger.net/web-security/oauth)
> service to allow users to log in with their social media account. A
> misconfiguration by the OAuth provider makes it possible for an attacker to
> steal authorization codes associated with other users' accounts.
>
> ​ To solve the lab, steal an authorization code associated with the admin
> user, then use it to access their account and delete Carlos.
>
> ​ The admin user will open anything you send from the exploit server and
> they always have an active session with the OAuth service.
##### 分析
按照相同的手法登陆账户形成一个会话，之后logout账户，再次登陆账户发现不需要输入凭证了，那是因为有一个会话存在，观察http请求中
设置了重定向的url,我们将数据包发送到`Repeater`中修改`redirect_url`
无论修改为什么，他都不会报错，且能够达到重定向的目的，我们就将这个参数改为恶意的服务器
之后查看日志，可以发现携带了一个授权码的链接
说明这里存在漏洞，能够将授权码泄漏到外部域中
我们首先抓取登陆账户的`client_id`页面的数据包，使用burp自带的CRSF生成方式生成poc
值得主意的是这里的poc是不能自动提交的，我们可以添加`aaa.submit()`自己提交
我们可以测试这个是否可行，在漏洞利用服务器中的`View`选项，可以发送payload
可以在日志记录中发现生成的授权码
我们直接攻击受害者，也成功返回了admin的授权码
使用授权码，加上原始`redirect_uri`登陆
成功登陆admin
#### Stealing codes and access tokens via a proxy page
这个应该是上一个的升级版，`redirect_uri`不能传递到外部域当中，但是也提出了一种利用的思路
可以尝试找到可以成功访问不同子域或路径得方法，可以通过目录穿越来寻找白名单
##### Lab: Stealing OAuth access tokens via an open redirect
##### 分析
同样的步骤进行首次登陆，之后再次登陆，获取`client_id`
虽然`redirect_uri`不能指定外部域，但是我们可以发现这里存在一个目录穿越漏洞，我们可以通过`../`进行穿越
同时我们可以发现在`下一篇文章`中对应的`/post/next?path=`参数存在有开方式重定向，甚至可以指定完整域名进行重定向
将漏洞利用传递给受害者，然后从日志中复制他们的token。在 Repeater 中，转到 GET /me 请求并将 Authorization:
Bearer 标头中的token替换为您刚刚复制的token。发送请求。观察您已成功进行 API 调用以获取受害者的数据，包括他们的 API 密钥。
# 参考