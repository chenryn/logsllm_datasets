        server.serve_forever()
###  操作内容：
很容易的一个题，一开始看题的时候没注意，想复杂了。
对于任意输入，服务器返回`输入+flag`的加密结果，加密使用CRT模式，这种模式是在模仿流密钥，其加密解密过程是相同的，都是使用一个固定的串和明文/密文异或，因此我们可以输入`'x00'*42`骗到密钥流，输入空拿到密钥流异或flag，再恢复即可。
    from pwn import *
    c = connect("08560bfda40f2691789fc1b246a80c4e.kr-lab.com",54321)
    c.recv()
    c.send(b"x00"*48+b"n") #远大于flag长度
    lll="e2b68dc585359b6dbcb59566d28a5e2d6a1d3f33d0104bae4e49dcad21b17be4b1cbd206a30062eccab03985f72cdd335c1a0c34784e0d9"
    c.send(b"n")
    c.recv()
    fff = "84daeca2fe0cab5b8fd4a750e5a76c180b781207e5717883772aeac80c87498781aeb037c7625089f3cd3f83f12adb35"
    lll = [lll[i*2:(i+1)*2] for i in range(len(lll)//2)]
    fff = [fff[i*2:(i+1)*2] for i in range(len(fff)//2)]
    "".join([chr(int(i,16)^int(j,16)) for i ,j in zip(lll,fff)])
    #Out: 'flag{9063a267-25ae-45a3-9c6e-62c0eb1db2e9}x06x06x06x06x06x06'
###  FLAG值：
flag{9063a267-25ae-45a3-9c6e-62c0eb1db2e9}
## 0x02 Asymmetric
###  题目内容：
加密代码：
    import gmpy2
    import random
    from Crypto.Util.number import *
    from flag import flag
    def generate_key(nbit):
        p = getPrime(nbit)
        r = random.randint(2, 10)
        s = random.randint(r, nbit)
        while True:
            e = random.randint(3, p**r*(p-1))
            if gmpy2.gcd(e, p**s*(p-1)) == 1:
                break
        pubkey = (long(e), long(p**r))
        return pubkey
    def crypt(msg, pkey):
        e, n = pkey
        m = bytes_to_long(msg)
        assert m 可以分解 n = 165740755190793304655854506052794072378181046252118367693457385632818329041540419488625472007710062128632942664366383551452498541560538744582922713808611320176770401587674618121885719953831122487280978418110380597358747915420928053860076414097300832349400288770613227105348835005596365488460445438176193451867 ** 4
  4. p= 165740755190793304655854506052794072378181046252118367693457385632818329041540419488625472007710062128632942664366383551452498541560538744582922713808611320176770401587674618121885719953831122487280978418110380597358747915420928053860076414097300832349400288770613227105348835005596365488460445438176193451867
  5. 计算欧拉函数tn = (p-1)*p**(4-1) = 754600786340927688096652328072061561501667781193760284816393637647032362908189628005150802929636396969230958922073774180726205402897453096041624408154494621307262657492560975357997726055874834308239749992507552325614973631556754707427580134609221878324704469965450463088892083264951442562525825243127575048382020348554103492066896028626609141603744573014997594974840364196576805574290230717797680784015606678220685175613006381685316530283364526806329843215344864978506611708014826575549754215603111871041127737248061508062509954515180590709902872102201787798519930648214171173734330373307910703014829049876710184952770778694470622205331452485580509360278286073515670426732153881001924269015959417981453605383620989390641130390792523774173999641657942858554351928480041128101430744740512436200403546664177520578640886989763652571240609759845865663456876950525457470394172235559993902647624689429529649263626096716499718400531042263880808947216977594793497148996021186364184681200282011188790384440121901199558788032273541957257900641788680426431582660017327290705017613450049252441247990490420192447135186479915776636136170081178597601023790620339458199878480372174554744535931108868071240358214957464961122323694111668928235098273358
  6. 求私钥 d = invert(e,tn) = 246147986232122522222945935166497181077425041862398601120195387712320320668518872220105275141998812980297487966166790627252138269690896904506351310111884097065720269620266438676878520737977175367219983199379896337289659505759915064579389742995197648778406174134619141885779959575893259706589078686468369934224819830380441408159157001221220006272848458925961856865957481441468977910310524702817391598685924029987182266666925247542967382511744481763491143359600475506219835081162285194819238822782586157524672021241688147776469107932108608614733173699997501684622008897839735803071479737831820615213472811927852485546491792632061225493011556559958048436081543373195780943616410013364904364189910609641011604973761655641640644240421733044416283033016214854248527848120863203309611651900474178577639838594642032729270144216036042626179871605108010066418412061098908069795528844683362447177767221536133092535251655422406812395458552873624709390942643779630423626540260879777817972852233172145227974851300408424539580993751911276200010091904304276075932206170667475223532012398457406488033971582373114546052355967855069052545027197494652214388104705729265794732282116974422654733131733167685515036576104862056823494603230646894054306744939
  7. m = pow(c,d,n) = 13040004482825639935833218643688743654206267733344606731646835124964035844807067414996138109
转成字符串flag{ec33f669d2d659e2bc27dbffdfeb0f38}
第一次给的文件居然忘记加密flag，但是两次产生的n均可在线分解，即使不能分解依然可以进行求多次开方的根，尝试不多于10次也能分解。
###  FLAG值：
flag{ec33f669d2d659e2bc27dbffdfeb0f38}
## 结语
今年初赛crypto比去年简单不少，甚至还拿出考研题凑数，希望后面的题目更have 4 fun。