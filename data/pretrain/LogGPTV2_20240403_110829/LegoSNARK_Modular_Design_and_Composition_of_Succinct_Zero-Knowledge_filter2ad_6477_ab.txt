diﬀerent CP schemes must be compatible with the same commitment scheme (and commitment key).
Essentially we need a sort of universal commitment scheme that is as decoupled 4as possible from
the speciﬁc argument systems that will operate on it.
We argue that achieving such universality with state-of-the-art zkSNARKs entails major chal-
lenges:
(a) Most of the popular zkSNARKs, e.g., [PHGR13, Gro16], are not explicitly commit-and-prove.
This limitation can be overcome using a (somewhat folklore) approach in which the SNARK Π
additionally proves the correct opening of the commitment, i.e., R(x, w)∧“cck(x) opens to x”. This
approach has two main drawbacks: (i) Π must be expressive enough to include the commitment
veriﬁcation in its language, but in our vision Π is a SNARK for a specialized task and may
not have this capability; (ii) even if Π were expressive enough (e.g., supports arbitrary circuits),
encoding commitment veriﬁcation incurs signiﬁcant overheads.5
(b) Some existing SNARKs have commit-and-prove capabilities [Gro10, CFH+15, Lip16, Vee17]. Yet,
each of these schemes uses its own speciﬁc commitment scheme. In some cases [CFH+15] the
commitment keys are relation-dependent, which means commitments cannot be generated before
3 Most of these beneﬁts are the typical ones of modularity, a design approach that is successfully used in a variety
of ﬁelds, such as architecture, manufacturing, software design, and programming.
4 We ﬁnd it apt to describe this notion in terms of coupling, the common measure of how interconnected two
components are in a software system.
5 For example, we experimentally found that, when handling a Pedersen commitment to a vector of length 2048
with [Gro16], the proving overhead is 428 secs (7 minutes).
5
ﬁxing one or multiple relations.6 In the other cases, despite being relation-independent, commit-
ment keys have a very speciﬁc structure that may not ﬁt other proof systems. In summary, a main
limitation of existing commit-and-prove SNARKs is their incompatibility, between them and with
other potentially more eﬃcient candidates to be developed.
1.1 Our Results
LegoSNARK Framework. We present LegoSNARK, a framework for commit-and-prove zk-
SNARKs (CP-SNARKs) that includes:
– Deﬁnitions that formalize CP-SNARKs and their variants.
– Composition recipes that show how to use diﬀerent CP-SNARKs in a generic and secure way for
handling conjunction, disjunction and sequential composition of relations. This composition result
enables the use of modularity in designing CP-SNARKs for complex relations out of schemes for
simpler relations.
– A generic construction to eﬃciently turn a broad class of zkSNARKs into CP-SNARKs that can be
composed together. This class includes several existing schemes such as ones based on quadratic
arithmetic programs [PHGR13, CFH+15, Gro16], or zk-vSQL [ZGK+17a, ZGK+17b]. For this
transformation we only need a “minimal” CP-SNARK, CPlink, for proving that two commitments
(under diﬀerent schemes) open to the same value.
LegoSNARK Gadgets. We populate our framework by constructing new CP-SNARKs for several
basic relations, such as:
– CPlink for proving that two diﬀerent Pedersen-like commitments open to the same vector.7 Plugging
CPlink in our generic construction solves the challenges (a) and (b) mentioned above and gives us
interoperable versions of several existing schemes.
– CPlin for proving that a linear relation F · u = x holds for a committed vector u, a public matrix
F and public vector x.
– CPhad for proving that a vector u0 is the Hadamard product of u1 and u2, when all the three
vectors are committed.
– CPsfprm for proving a self-permutation, i.e., that yi = yφ(i) for a public permutation φ and a
committed vector y.
– CPmm for proving that matrix X is the product of committed matrices A and B.
All the aforementioned schemes have succinct proofs and work for Pedersen-like commitments in
bilinear groups. This means that by using our generic construction with CPlink they can be turned
to support the same commitment and then be composed.
LegoSNARK Applications and Evaluation. Using our initial set of specialized proof gadgets,
our next step is to combine them in order to build new succinct proof systems for diﬀerent use
cases, mentioned below. Our results oﬀer various improvements over the state of the art. We have
also implemented some of our solutions to test their concrete performance.
6 This could be mitigated by using universal circuits, paying a (multiplicative) logarithmic overhead in parameters
size and prover complexity.
7 By “Pedersen-like” we mean schemes where the veriﬁcation algorithm is the same as in Pedersen scheme [Ped92]
for vectors (but the bases can have a diﬀerent distribution).
6
1) Efficient Commit-Ahead-of-Time. Through our generic construction instantiated with
CPlink we also obtained commit-and-prove versions of popular eﬃcient zkSNARKs, such as Groth’s
[Gro16], that can prove statements about data committed using the Pedersen scheme for vectors
[Ped92], in which bases are random group elements that can be generated without trusted setup.
Such commit-and-prove schemes are useful in applications where one needs to commit before the
SNARK keys for a relation are created, e.g., to post commitments on a blockchain so that one can
later prove statements about the committed data. By applying our solution to [Gro16] we obtain a
scheme that is 5000× faster than Groth16, where the commitment is encoded in the circuit.
2) CP-SNARKs for Parallel Computation. Consider the problem of proving (in zero-knowl-
edge) correctness of a computation that consists of the same subcircuit executed in parallel. The
recent Hyrax system [WTs+18] is suitably designed for and shows good performances on this type
of circuit. It requires, however, an additional veriﬁcation cost whenever the repeated subcircuits
share (non-deterministic) inputs, which is common. The veriﬁer thus pays an additional factor
linear in the total width of the circuit. Using our LegoSNARK framework we show how to build a
new CP-SNARK based on Hyrax that avoids this problem. The idea is that parallel computation
on joint inputs can be expressed as the combination of a fully parallel computation (after inputs
were appropriately duplicated) and a permutation check to ensure that inputs have been duplicated
correctly. We build this by combining our CPlin gadget with a version of Hyrax modiﬁed to work
with the polynomial commitment of zk-vSQL [ZGK+17b].
3) CP-SNARKs for Arithmetic Circuits. We give two main constructions of CP-SNARKs
for arithmetic circuit (AC) satisﬁability. Table 1 summarizes a theoretical comparison with other
schemes in the literature (selected among the ones with similar succinctness).
Our ﬁrst scheme, LegoAC, relies on an encoding of AC based on Hadamard products and lin-
ear constraints from [BCC+16] and can be built from CPlin and CPhad gadgets. We evaluate two
instantiations:
- LegoAC1—from our CPlin and a CPhad from [Lip16]—is secure in the generic group model (GGM),
enjoys constant-size proofs, and has a log n factor in proving time (similar to [PHGR13, Gro16]);
- LegoAC2—from our CPlin and CPhad gadgets—is secure in the GGM and random oracle model, it
has log n-size proofs but only linear proving time.
The second CP-SNARK, LegoUAC, builds on an encoding of AC based on Hadamard products,
additions and permutation from [Gro09, BCG+17] and can be built from our CPhad and CPsfprm
gadgets.8 The main novelty of LegoUAC is to admit a universal, circuit-independent CRS, in the
“specialization” model of [GKM+18] where the universal CRS can be specialized to a circuit C
with a deterministic algorithm. LegoUAC’s CRS has O(N ) size where N is an upper bound on the
number of gates of the circuits; in contrast, the CRS has quadratic size in the recent scheme in
[GKM+18]. Our LegoUAC also improves on the approach applying an eﬃcient system, say [Gro16],
on a universal circuit [Val76, GKS17], which would incur at least a logarithmic multiplicative factor
in circuit size.
1.2 Related Work
The idea of combining two diﬀerent NIZKs to improve eﬃciency when handling heterogeneous
computations has been considered by Chase et al. [CGM16] and more recently by Agrawal et
8 Additions are handled for free if the commitment is linearly homomorphic.
7
Uni KG time Prove time Ver. time |crs|
Scheme
[PHGR13, Gro16]
LegoAC1
LegoAC2
[GKM+18]
LegoUAC
–
–
–
(cid:88)
(cid:88)
n + m m + n log n
n + m
n + m
n log n
n
n2
N∗
m + n log n
N
|x|
|x|
|x| + log n
n
n
n2
|x| + log2 N N∗
|x|
|π|
n + m O(1)
O(1)
log n
O(1)
log2 N
Table 1: Comparing pairing-based zkSNARKs for arithmetic circuits with m wires and N gates, of
which n are multiplication gates, na (resp. nc) are addition (resp. multiplication-by-constant) gates,
and N∗ = max(n, na, nc). Numbers in the table are in O(·) notation.
al. [AGM18]. In [AGM18], they propose combining the Pinocchio scheme [PHGR13] with Sigma-
protocol-based NIZKs and show an eﬃcient construction for computations that combines algebraic
relations in a cryptographic group and arbitrary computation. Their approach reveals beneﬁcial
and improves performances. The solution in [AGM18] is tailored to two speciﬁc proof systems and
their combination methodology does not always preserve succinctness. In contrast, our techniques
are general, apply to a variety of existing proof systems and preserve succinctness (they compose
succinct schemes into succinct schemes).
Succinct ZK Proofs. In the past years several research lines have built a variety of zk-SNARKs
for general NP statements. Here we provide an overview of each line, especially focusing on their
diﬀerences in performance.
A major research line is the one based on the seminal paper of Gennaro et al. [GGPR13] who
proposed a pairing-based SNARK based on the NP-complete language of quadratic span/arithmetic
programs. This approach improves on previous approaches by Ishai et al. [IKO07], Groth [Gro10] and
Lipmaa [Lip12], and is the basis of several works such as [PHGR13, BCG+13, BFR+13, BCTV14,
KPP+14, CFH+15, BBFR15, WSR+15, Gro16, FFG+16, GKM+18]. The zkSNARKs in this family
enjoy constant-size proofs and fast veriﬁcation, the latter depending only linearly on the statement
size; on the downside, they feature large overheads at proving time, costly (although amortizable)
preprocessing and security properties based on non-standard non-falsiﬁable assumptions.
A second research line builds on the MPC-in-the-head approach of Ishai et al. [IKOS07] to
construct a ZK argument from an MPC protocol. The ﬁrst scheme that reﬁned and experimented this
approach is ZKBoo [GMO16], then improved in [CDG+17]; a more recent work in this line is Ligero
[AHIV17]. These schemes do not need trusted setup and show excellent proving performances on
Boolean circuits, since they rely only on symmetric-key cryptographic primitives. On the downside
their proofs are not fully succinct, being linear in the circuit size |C| in [GMO16], and ˜O((cid:112)|C|) in
[AHIV17].
The works [ZGK+17a, ZGK+17b, WTs+18] stem from the interactive proof techniques for
low-depth circuits pioneered in Goldwasser et al. [GKR08] and later reﬁned in [CMT12, Tha13,
WJB+17]. The resulting succinct ZK arguments are made non-interactive in the random oracle
model. These schemes oﬀer good proving performance and use asymptotically fewer cryptographic
operations than those from the MPC-in-the-head family; they can be instantiated without [WTs+18]
(or with a circuit-independent [ZGK+17b]) trusted setup. On the other hand their proof size and
veriﬁcation time depend on the structure of the circuit at hand, notably on the depth and in some
cases on the width.
Building on the work of Groth [Gro09], two recent proposals [BCC+16, BBB+17] give ZK argu-
ments for arithmetic circuit satisﬁability that can be instantiated without trusted setup. The ﬁrst
8
√
M ) where M is the number of multiplication
scheme of Bootle et al. [BCC+16] has proofs of size O(
gates in the circuit, while their second scheme (improved in [BBB+17]) has proofs of size O(log M )
but has a linear time veriﬁer.
Compared to the results from the latter three research lines we described, our instantiations
have the disadvantage of needing a trusted setup9, although in some cases this is universal and thus
reusable. In terms of performances, however, our results are more succinct, both in terms of proof
size and veriﬁer time.
A recent line of work [BSBHR18] builds on the seminal works of Kilian [Kil92] and Micali
[Mic94], and generalizations of PCPs (IOPs) [BCS16, RRR16] in order to construct systems (dubbed
zkSTARKs) that are general-purpose (capturing very general computations that can be expressed
as state-machine transitions), do not require trusted setup and oﬀer good timings for prover and
veriﬁer. On the downside, the memory costs for the prover are still high and their security relies on
a non-standard conjecture about Reed-Solomon codes.
1.3 Roadmap
The paper is organized as follows. Section 2 introduces notation and preliminar deﬁnitions. Section
3 provides the basis for building our framework: composing CP-SNARKs, the notion of cc-SNARKs
and our compiler to import existing schemes in the framework. Sections 4 and 5 present constructions
both for Pedersen-like commitments and polynomial commitments. Section 6 explains how to apply
LegoSNARK to build schemes for arithmetic circuits. Section 7 gives experimental details of our
library. We conclude in Section 8.
This text is the full work of our shorter version published at CCS’19. Several results only appear
in this long version. Namely: security proofs, formal deﬁnitions, more schemes and constructions,
and further details.
2 Preliminaries
We use λ ∈ N to denote the security parameter, and 1λ to denote its unary representation. Through-
out the paper we assume that all the algorithms of the cryptographic schemes take as input 1λ,
and thus we omit it from the list of inputs. For a distribution D, we denote by x ← D the fact
that x is being sampled according to D. We remind the reader that an ensemble X = {Xλ}λ∈N is
a family of probability distributions over a family of domains D = {Dλ}λ∈N. We say two ensem-
bles D = {Dλ}λ∈N and D(cid:48) = {D(cid:48)
λ}λ∈N are statistically indistinguishable (denoted by D ≈s D(cid:48)) if
λ(x)| < negl(λ). If A = {Aλ} is a (possibly non-uniform) family of circuits and
D = {Dλ}λ∈N is an ensemble, then we denote by A(D) the ensemble of the outputs of Aλ(x) when
x ← Dλ. We say two ensembles D = {Dλ}λ∈N and D(cid:48) = {D(cid:48)
λ}λ∈N are computationally indistin-
guishable (denoted by D ≈c D(cid:48)) if for every non-uniform polynomial time distinguisher A we have
A(D) ≈s A(D(cid:48)).
We denote by [n] the set of integers {1, . . . , n} and by [: n] the set {0, 1, . . . , n − 1}. By (uj)j∈[(cid:96)]
x |Dλ(x) − D(cid:48)
we denote the tuple (u1, . . . , u(cid:96)).
(cid:80)
1
2
9 We stress that only our concrete instantiations require a trusted setup—our general composition framework does
not.
9
2.1 Relations
Let {Rλ}λ∈N be a family of polynomial-time decidable relations R on pairs (x, w) where x ∈ Dx is
called the statement or input, and w ∈ Dw the witness. We write R(x, w) = 1 to denote that R holds
on (x, w), else we write R(x, w) = 0. When discussing schemes that prove statements on committed
values we assume that Dw can be split in two subdomains Du×Dω. Finally we sometimes use an even
ﬁner grained speciﬁcation of Du assuming we can split it over (cid:96) arbitrary domains (D1×···×D(cid:96)) for
some arity (cid:96). In our security deﬁnitions we assume relations to be generated by a relation generator
RG(1λ) that, on input the security parameter 1λ, outputs R together with some side information,
an auxiliary input auxR, that is given to the adversary. We deﬁne RGλ as the set of all relations
that can be returned by RG(1λ).
2.2 Commitment Schemes
We recall the notion of non-interactive commitment schemes.
Deﬁnition 2.1. A commitment scheme is a tuple of algorithms Com = (Setup, Commit, VerCommit)
that work as follows and satisfy the notions of correctness, binding and hiding deﬁned below.
– Setup(1λ) → ck takes the security parameter and outputs a commitment key ck. This key includes
– Commit(ck, u) → (c, o) takes the commitment key ck and a value u ∈ D, and outputs a commitment