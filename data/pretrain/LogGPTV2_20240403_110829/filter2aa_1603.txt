0x00 前⾔
如有技术交流或渗透测试/代码审计/红队⽅向培训/红蓝对抗评估需求的朋友
欢迎联系QQ/VX-547006660
0x01 前奏
最近在测试某知名安全⼚商的过程中，发现其⼀处重要业务的⼦域竟出现了难得⼀⻅的⾃研WAF，如此⼀来勾起了
我的兴趣~
仔细研究该业务点后，发现某处传参，会直接将传参内容写⼊JS中，⼤⼤的危险
Aut hor: J 0o1ey
于是与WAF的⼀次交锋便从此刻开始~
0x02 平静的闭合与常规操作
由上图的输出位置可知，⽆WAF情况下，我们只需要通过
三个符号来闭合前半部分JS，再⽤//注释后⽅JS，再直接eval执⾏JS代码即可
构造Payload
由于eval，alert，括号等太敏感~毫⽆疑问，直接被WAF秒了
’)]
%27)];eval(alert('xss'))//
Aut hor: J 0o1ey
那只能⽤经验与思路来逐渐替换掉这些敏感的函数关键词了~
0x03 多⼿法组合绕过WAF
解决eval
⾸先解决的是eval被拦截的问题
在JS中绕过对于eval的拦截，可以使⽤Function()动态构造函数
这⾥⽤到了 Function()构造函数的⼀个特性, Function()构造函数虽然不是很常⽤，但是了解⼀下还是很有必要的。
不管是通过函数定义语句还是函数直接量表达式，函数的定义都要使⽤ function()关键字。
但是单函数还可以通过Function()构造函数来定义，⽐如：
这⼀⾏的实际效果和下⾯的⼀⾏代码是等价的。
Function()构造函数可以传⼊任意数量的字符串实参，最后⼀个实参所表示的⽂本是函数体；它可以包含任意的
Javascript 语句，每条语句之间⽤分号分割。
我们依据这个特性就可以使⽤Function()来代替eval()
EG:
两者是等效的
var f = new Function("x","y","return x*y");
var f=function(x,y){x*y};
Function(alert('xss'))
eval(alert('xss'))
Aut hor: J 0o1ey
改造我们的Payload
发现未拦截
直接Function内使⽤函数
不出意外，直接GG了~
?%27]);Function(test)()//
%27]);Function(alert('xss'))()//
Aut hor: J 0o1ey
下⾯思考的就是如何绕过对于函数的检测
绕过函数检测
直接alert既然被拦截，我们就使⽤atob来解密base64的的JS
EG:
构造Payload
atob("YWxlcnQoInhzcyIp")  //base64编码的alert('xss')
%27]);Function(atob('YWxlcnQoInhzcyIp')))()//
Aut hor: J 0o1ey
Md,⼜寄了~估计是正则检测了atob + ()的函数使⽤...
没事，再⽤JS的⼀个特性，反引号来代替括号＋引号
构造Payload
atob`YWxlcnQoInhzcyIp`
%27]);Function(atob`YWxlcnQoInhzcyIp`)()//
Aut hor: J 0o1ey
弹弹弹，弹⾛⻥尾纹
0x04 总结
本初XSS绕过WAF总共⽤了四个简单的TIPS
1.输出在JS内的闭合与注释
2.Function()来代替eval()
3.atob解密base64加密的JS
4.反引号代替括号与引号
所以，⼤多数业务场景并不是没有漏洞，⼤部分情况是受挖掘者脑中的利⽤链与姿势所限。
各种⼩⼿法组合起来达到漏洞利⽤成功的效果，是⼀次有趣的经历。
Aut hor: J 0o1ey