---
## Page 270
254
第10章攻击内核
rootgandroid:/data/loca1/tmp ● insmod ahh_setuid_mod.ko
insmod: init_module *ahh_setuid_mod.ko' falled (Operation not permitted)
uid=2000 (she11) g1d=2000 (ahe11) groups=1003 (graphics) , 1004 (input1.*
PT  du/tesot/eep/proxpueettaus
./setuid 31337
(300x)0=p16(200x)0=pTn
在上面的片段当中，运行insmod 时，很明显有一个错误消息。这是因为init_module函
数返回了-1，使得内核自动卸载这个模块，在下次装入前不用手动卸载。退出root用户后，使
用系统调用setuid31337，就能再次获得root权限。
使用可加载的内核模块来扩展内核十分方便，但是可能正因为如此，一些Android设备中的
内核不支持可加载内核模块。可以通过检查proc文件系统中的module项，或者寻找内核配置
当中的 cONPIG_MODULES值来判断系统是否支持可加载内核模块。自从Android4.3发布后，谷
歌就禁用了所有Nexus设备的可加载内核模块支持。
10.3.5编译自定义内核
尽管Linux内核包含各种工具，可以在运行时配置并扩展内核的功能，但是有一部分功能的
修改必须要求重新编译自定义内核。一些配置修改，例如打开调试工具，就会要求在编译时加上
完整的文件或者函数。本章已经介绍了如何获取源代码，配置编译环境以及配置内核。本节会完
成AOSP支持的GalaxyNexus和三星Galaxy S III的内核编译过程。
1.AOSP支持的设备
对于搭载Android4.2.2的GalaxyNexus，我们已经获得了正确的源代码，搭建了编译环境并
配置了内核。接下来，只需要使用默认的make就可以编译自定义的内核，如下所示：
dev:/android/sre/kerne1/omap $ make
[·..]
Kernel: arch/arm/boot/zImage is ready
$dewo/teuzex/oxs/proxpue/~1Aep
编译成功后，系统会将编译生成的内核镜像写人arch/arm/boot目录下的zImage文件中。如
果发生错误，就必须在编译前解决。10.3.6和10.3.7两节会介绍如何引导编译出的自定义内核。
注意对于所有AOSP支持的设备，包括Nexus系列的所有设备，编译自定义内核的步骤都应
该是相同的。
2.OEM设备
OEM设备的内核编译方法与AOSP设备非常类似，要记得OEM制作固件时使用的代码都是
从AOSP代码修改而来的：面不同厂商的方法会有所差别。本节介绍如何为Sprint版的三星Galaxy
SIⅢI（SPH-L710）手机编译和测试自定义内核。目标是生成一个与设备现有内核兼容的内核。
---
## Page 271
10.3运行自定义内核代码255
编译前首先需要明确的是应该使用什么源代码。对于不同的厂商，寻找源代码的方法也不一
样。如果比较幸运，内核版本字符串引用的正好是AOSP的GIT仓库中某个commit哈希。这种
情况常见于较老的设备，因为厂商直接使用了谷歌提供的内核来编译。10.5.3节中使用的摩托罗
拉Droid手机就是这种情况。可以使用如下命令来查看设备的内核版本：
Linux version 3.0.311130792 (se.infra@s8p132) (gcc version 4.6.x-
shel1eandroid1 / $ cat /proc/version
google 20120106 (prere1ease) (GCC) ) #2 SMP PRREMPT Mon Apr 15 19:05:47
KST 2013
不幸的是，GalaxySIⅢI没有在版本信息中包含commit哈希，因面需要使用其他方法。
使用OEM提供的内核源代码树就是一种方法，首先查看设备在编译时的指纹信息：
s/oxseoox/xosn.1 paHad0/1/xsoz2/z T*>1xdezp/ade2p/5ungues
she11eandroid:/ $ getprop ro.build.fingerprint
兼容性描述文档解释了这个系统属性由下列域组成（因为格式原因稍作修改）：
$ (BRAND) /S (PRODUCT) /S (D&VICE) : $ (RELEASE) /$ (ID) /$ (INCR&MENTAL) : $ (TYPS) /
$ (TAGS)
比较有意思的是第二组域：RELEASB、ID 和INCREMENTAL值。
首先值得注意的是INCREMENTAL域。许多厂商都把INCREMENTAL域用作自定义版本号，
包括三星。从上面的输出结果可以看出，三星将这个固件的版本标记为L710VPBMD4。
有了设备型号（根据ro.product.mode1可以看出是SPH-L710）和三星设定的版本识别
号，就能去三星的开源网站上搜索。用型号搜索的时候，会看到搜索结果中有一个带有MD4的
下载链接。点击下载后，解压缩Kermel.tar.gz和 README_Kermel.txt文件：
dev:~/sph-1710 $ unzip SPH-L710_NA_JB_Opensource.zip Kernel,tar.gz \
Archive: SPH-L710_NA_JB_Open8ource.zip
READxE_Kernel,txt
inflating: Kernel.tar,gz
dev:~/sph-1710 $ nkdir kerme1
inflating: READHE_Kernel. txt
dev:~/sph1710 $ tar zxf Kernel.tar-gz -C kerne1
[. .-]
解压文件后，应该阅读README_Kemel.txt文件。其中的指示包括应该使用什么工具链和
编译配置。例如在这个例子中，说明了需要使用arm-cabi-4.4.3工具链和m2_spr_defconfig来
配置。不过有一点可疑的是，工具髓编译内核时使用的内核版本字符串是gccversion
4.6.x-google20120106（prerelease）。所以要记住，之前找到的内核版本号要比
README_Kemel.txt里的更权威。
下一步是搭建编译环境。README_Kemel.txt文件建议使用AOSP中的工具链。为了避免出
现问题，尽量使用与设备相符合的编译环境，即要与编译指纹当中RELBASE和ID域相关。根
据之前的结果，目标设备的RELEASE为4.1.2，ID为JZ054K。想要找到具体使用哪一个tag，
可以查询 Android 文档中的“Codenames, Tags, and Build Numbers”页： http:/source.android.com/
source/build0numbers.html。查询Jz054K，可以发现它对应的 tag是android-4.1.2_r1。这样
---
## Page 272
256第10章攻击内核
就可以初始化AOSP仓库了，如下所示：
dev:~/aph-1710 s mkdir aosp 4& cd s_
dev:~/sph-1710/aosp $ repo init -u \
https: //android.googlesource.com/a/platform/manifest -b android4.1.2_r1
suAs odex s deoe/ot.t-qds/~:aep
[..-]
检出AOSP仓库正确版本的代码，就可以准备编译内核了。但在编译之前，需要完成环境的
初始化，如下所示：
dev:-/sph-1710/ao8p $ , bui1d/envsetup.sh
dev:~/sph-1710/aosp $ 1unch fu11user
[-- *]
PLATFORM_VERSION=4 .1.2
PLATFORM_VERSION_CODENAME=REL
TARGET_BUILD_VARIANr=user
TARGET_PRODUCT=fu11
TARGET_BUILD_TYPB=re1ea8e
TARGET_BUILD_APPS=
TARGET_ARCH_VARIANT=armv7-a
TARGET_ARCH=arn
HOST_ARCH=x86
HOST_0S_ExTRA=Linux-3.2 .054-generic-x86_64-vith-Ubuntu-12.04-precise
HOST_OS=1inux
HOST_BUILD_PYPE=release
BUILD_ID=JZ054K
OUT_DIR=out
dev:~/8ph-1710/ao8p $ export ARCH=arm
dev:~/sph-1710/ao8p $ export SUBARCH=arm
dev:/sph-1710/aosp $ export CRoSs_CoPILE=arm-eabi-
这样，环境里就有了AOSP的预编译工具链。与编译GalaxyNexus不同的是，这里要使用
ful1-user 编译配置。除此之外，还需要设置CROSS_COMPILE环境变量，面不是（根据
README_Kemel.txt的指示）编辑Makefi1e。查看编译器的版本：
dev:~/sph-1710/aosp $ arm-eabi-gcc -=version
arm-eabi-gcc (Gcc) 4.6.x-google 20120106 (prerelease)
[-.-]
很好！这个编译器版本与运行的内核版本字符串相匹配。理论上，使用这个工具链应该会生
成一个与设备原内核基本相同的内核，至少是互相兼容的。
根据README_Kermel.txt文件中的信息，可以配置和编译内核：
dev:~/sph-1710/aosp $ cd ~/sph1710/kerne1
dev:~/8ph-1710/kernel S make m2_spr_defconfig
[-.-]
# configuration written to .config
---
## Page 273
10.3运行自定义内核代码257
dev:~/sph-1710/kernel $ make
[ - + - ]
Kernel: arch/arm/boot/zInage is ready
如果一切按计划进行，内核会编译成功，并生成压缩的内核镜像/arm/boot/zlmage。在信息安
全领域，事情往往不会这么顺利。编译内核时，可能会遇到一个特别的问题，错误消息如下：
Lzoarch/arm/boot/compressed/piggy.1zo
/bin/sh: 1: 1zop: not found
make[1] : **-_[arch/arm/boot/compressed/vmlinux]Error 2
nake[2] : *** [arch/arm/boot/compressed/piggy.1zo] Error 1
sake; *** [zImage] Error 2
当系统缺乏1zop命令时，就会发生这个错误。三星使用LZO算法来压缩内核，牺牲存储
空间来提高压缩速度。安装这个工具后，再次运行make命令，编译就会成功。
10.3.6制作引1导镜像
前面提到，Android设备有两种典型的引导Linux内核方式：第一种就是正常的启动过程，
使用boot分区；第二种是启动恢复过程，使用recovery分区。这两个分区的文件结构是相同的，
都有一个短的头部，一个压缩的内核，以及一个初始的ramdisk（initrd）镜像。二者通常使用相
同的内核，但也有例外。要想替换这些模式下的内核，就必须为新的内核重建分区镜像。本节关
注的是boot.img
基于现有的引导镜像，为新编译出来的自定义内核创建引导镜像是最容易的。第一步是获取
一个镜像。虽然使用原厂固件中的boot镜像通常也是可行的，但是直接使用设备中的镜像更加
可靠。因为设备的内核可能已经通过OTA升级了，所以使用一个直接从设备中获得的镜像能够
确保系统正确启动。获得设备中镜像的方法，请参考10.2.2节。
下一步是从获得的引1导镜像中提取文件.根据10.2.3节中的步骤操作.就能获得bootimg.cfg
zlmage 和 initrd.img这几个文件。
注意虽然解包和打包的操作经常在运行ADB的机器上进行，但事实上也能在被root的设备
上进行。
10
跟提取内核类似，可以使用abootimg工具来创建boot镜像。abootimg支持两种使用情形：
更新和创建。如果原始的boot镜像不需要保存，那么可以使用如下方式直接更新镜像：
\Dug qooq-xno n- fupaooqe $ Durbese/deuo/teuuax/oxs/pto.xpue/~1Aep
reading kermel from ../arch/arm/boot/zImage
-k ../arch/arm/boot/zTnage
Hriting Boot Image cur-boot.img
上面的命令展示了如何使用abootimg的-u选项来更新boot镜像，可以实现将原本的内核
更换成你自己的内核。也可以使用--create选项把内核、initrd和可选的第二步引导装配成boot
---
## Page 274
258第10章攻击内核
镜像。如果内核或者initrd文件变大了，那么abooti=g命令会给出如下错误消息：
dev:~/android/sre/kernel/omap/staging $ abooting --create neu-boot ing -f 1
bootimg.cfg -k bigger-zImage -r initrd.ing
reading kernel fron bigger-zInage
reading ramdisk from initrd.img
只需使用-c选项或更新abootimg配置文件bootimg.cfg中的bootsize参数就能解决这
个错误。
reading keznel from bigger-zImage
reading randisk from initrd.ing
Writing Boot Image newboot.img
对于三星GalaxySIⅢ手机，操作步骤几乎是一样的。与Nexus家族的设备一样，可以从设
备中获得引导镜像或者原厂镜像。这次通过在SamFirmware网站检索设备型号，下载到原厂镜像
KIES_HOME_L710VPBMD4_L710SPRBMD4_1130792_REV03_user_low_ship.tar.md5。这个镜像
应该与用来升级设备的镜像相同。可以按照如下命令来提取固件镜像和引导镜像：
dev:~/sg83-md4 $ mkdir stock
dev:~/sgs3-md4 $ tar xf KI8s*MD4*.tar.md5 -C stock
dev:~/sgs3-md4 $ mkdir boot 6s cd $_
dev:~/sgs3-md4/boot $ abooting -x -./stock/boot.img
extracting kernel in zImage
vriting boot inage config in booting.cfg
extracting ramdisk in initrd.img
bootimg提取成功后，编译自定义引导镜像所需的准备就已经全部作好了。使用abootimg
命令进行如下操作即可：
dev:~/sgs3-md4/boot $ mkdir -- /staging
dev:~/sgs3-md4/boot $ abootimg --create ../staging/boot.img -f bootimg.cfg 1
reading keznel from /home/dev/sph-1710/kerne1/arch/arm/boot/zImage
reading ramdisk from initrd.img