    JavaScript
    脚本被执行呢？这是因为攻击者能通过一些手段使浏览器将其上传的文件误认为是
    HTML。详情 将在 4.12.3 节中进行说明。
    此外，下载文件会导致 PC
    感染病毒则是因为攻击者恶意利用了用来打开文件的软件中存在的漏洞。
    下载文件造成病毒感染，虽然直接原因在于上传恶意文件的用户，但有时网站的运营方也负有一定责任。因此，在决定网站的服务内容时，应当根据网站的性质决定是否对恶意软件采取措施。详情请参考
    7.4 节。
-   **越权下载文件**
    即使上传后的文件只允许特定的用户下载，有时也会出现没有下载权限的用户也能够下载文件的问题。此类问题的原因多数为没有对文件设置访问权限，从而导致用户通过推测
    URL 而成功下载到了没有下载权限的文件。
    此问题将在 5.3 节中详述。
[63]{.注释编号下}
### **4.12.2 通过上传文件使服务器执行脚本** {#text00000.html#nav_point_51}
#### **概要**
有些文件上传处理会将用户上传的文件保存至 Web
服务器的公开目录中。这时，如果应用中允许上传文件的扩展名为
php、asp、aspx、jsp
等脚本文件的扩展名，用户就能在服务器上将上传的文件作为脚本执行。
如果外界传入的脚本在服务器上被执行，就会造成与 OS
命令注入同样的影响，具体如下。
-   浏览、篡改或删除 Web 服务器内的文件
-   对外发送邮件
-   攻击其他服务器（称为垫脚石）
为了防范通过上传文件而在服务器上执行脚本，可以综合实施以下两种方法，或者实施其中的任意一种。
-   不将用户上传的文件保存在公开目录中，浏览文件需通过脚本
-   将文件的扩展名限定为不可执行的脚本文件
**通过上传文件使服务器执行脚本的安全隐患总览**
![{%}](Image00157.jpg)
#### **攻击手段与影响**
接下来我们就来看一下通过上传文件而使服务器端执行脚本的攻击模式及其影响。
-   **示例脚本解说**
    以下为使用户上传图像文件并将该图像在页面上显示出来的 PHP
    脚本。首先来看文件上传页面。可以看出，上传文件的 form 元素的 enctype
    属性被指定为了 `"multipart/form-data"` 。
    > **代码清单 /4c/4c-001.php**
    ``` 代码无行号
    文件 ：
    ```
    而以下脚本的作用就是接收文件后将其保存在 /4c/img/
    目录中，并在页面上显示出来。
    > **代码清单 /4c/4c-002.php**
    ``` 代码无行号
    ">
    已上传 
    ">
    ```
    正常情况下的执行过程如下所示。
    ![{%}](Image00158.jpg)
    **图 4-105 示例脚本的执行范例（正常情况）**
    > **专栏：警惕文件名中的 XSS**
    >
    > 4c-002.php 中生成图像文件的 URL 时，会通过 urlencode
    > 函数对文件名进行百分号编码，并在显示处理中执行 HTML
    > 转义。这些都是必要的处理。Unix 允许在文件名中使用 \、\"
    > 等字符，因此需要根据所在位置进行相应的转义处理。当然这些都不是新鲜的内容，只是照理实施
    > XSS 的防范策略而已。
-   **PHP 脚本的上传与执行**
    下面就让我们来看一下攻击的例子。这里假设用户上传的不是图像文件，而是以下
    PHP 脚本文件。
    > **代码清单 4c-900.php**
    ``` 代码无行号
    &lt;?php
      system('/bin/cat /etc/passwd');
    ?>
    ```
    这段 PHP 脚本的作用在于通过 `system` 函数调用系统命令 cat 来显示
    etc/passwd 文件的内容。上传该 PHP
    脚本文件后，浏览器的页面显示如下图所示。由于 4c-900.php
    并非标准的图像文件，因此页面上显示为红叉。
    ![{%}](Image00159.jpg)
    **图 4-106 上传了 PHP 脚本**
    接下来点击 4c-900.php 链接，就能使浏览器显示刚才上传的 PHP
    脚本文件。如图 4-107 所示，点击后页面上显示了 etc/passwd
    文件的内容。由此可以得知上传的 PHP 脚本在服务器上被成功执行了。
    ![{%}](Image00160.jpg)
    **图 4-107 上传的 PHP 脚本在服务器上被执行**
    上传的脚本文件在服务器上被执行造成的影响与 OS 命令注入相同。由于
    `system` 和 `passthru` 等函数都能用来调用 OS
    命令，因此攻击者就能够执行当前操作系统账号权限范围内的所有操作。
#### **安全隐患的产生原因**
上传的文件能被作为脚本执行这一安全隐患的产生需满足如下两项条件。
-   上传的文件被保存至公开目录
-   上传后的文件扩展名能被指定为 .php 或 .asp 等表示脚本的扩展名
如果应用中的上传功能满足了上述两项条件，就会滋生安全隐患。因此，防范策略为至少消除上述两项条件中的任意一项。
#### **对策**
正如前项所介绍的那样，用户上传的文件能被作为脚本执行的条件为以下两项：文件被保存在公开目录中以及用户能指定文件扩展名为可执行的脚本文件。因此，消除上述任意一项条件就能防范安全隐患。而考虑到如果仅限制文件的扩展名很有可能会产生疏漏，因此，这里我们将主要介绍另一种对策方法，即不将文件保存在公开目录中。
为了避免将上传的文件保存在公开目录中，下载文件时就需要经过脚本。本书把此类脚本称为"下载脚本"。
使用下载脚本将 4c-002.php 加以改良，结果如下所示。
> **代码清单 /4c/4c-002a.php**
    ">
    已上传 
    ">
可以看出，上述脚本对原先脚本做了 2
处修改。首先，将文件的保存场所从公开目录（/4c/img）改为了由
`get_upload_file_name` 函数返回的文件名。另外，取得图像的 URL
时使其经过了下载脚本。`get_upload_file_name` 函数的源码如下所示。
> **代码清单 /4c/4c-002a.php（get_upload_file_name 的定义）**
``` 代码无行号
define('UPLOADPATH', '/var/upload');
function get_upload_file_name($tofile) {
  // 校验扩展名
  $info = pathinfo($tofile);
  $ext = strtolower($info['extension']);  // 扩展名（统一为小写字母）
  if ($ext != 'gif' && $ext != 'jpg' && $ext != 'png') {
    die(' 只能上传扩展名为 gif、jpg 或 png 的图像文件 ');
  }
  // 下面的处理为生成唯一的文件名
  $count = 0; // 尝试生成文件名的次数
  do {
    // 生成文件名
    $file = sprintf('%s/%08x.%s', UPLOADPATH, mt_rand(), $ext);
    // 生成文件，如果文件已存在则报错
    $fp = @fopen($file, 'x');
  } while ($fp === FALSE && ++$count  进行了改良。
随后将文件关闭，但不删除生成的文件，而是通过 `move_uploaded_file`
函数覆盖原文件。如果将文件删除，就无法保证文件名的唯一性。
下面为下载脚本 4c-003.php 的源码。
> **代码清单 /4c/4c-003.php**
``` 代码无行号
 'image/gif', 'jpg' => 'image/jpeg',
'png' => 'image/png',);
$file = $_GET['file'];
$info = pathinfo($file);       // 取得文件信息
$ext = strtolower($info['extension']);     // 扩展名（统一为小写字母）
$content_type = $mimes[$ext]; // 取得 Content-Type
if (! $content_type) {
  die(' 只能上传扩展名为 gif、jpg 或 png 的图像文件  ');
}
header('Content-Type: ' . $content_type);
readfile(UPLOADPATH . '/' . basename($file));
?>
```
上述脚本是从查询字符串 `file` 中取得文件名的。首先获取扩展名，如果不是
gif、jpg 或 png 就报错。接着输出与各扩展名相对应的
Content-Type，然后再使用 `readfile`
函数读取文件内容并将其输出。这里将从查询字符串中取得的文件名经过
`basename` 函数进行处理是为了防范目录遍历漏洞（参考 4.10 节）。