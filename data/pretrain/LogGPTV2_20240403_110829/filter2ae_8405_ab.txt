可见，该漏洞的利用门槛非常低，且可以对NEO上的所有资产进行双花攻击。危害非常严重。
### 4\. 虚拟机不一致性执行
智能合约平台共识机制，本质上是将所有的交易【Tx_1 Tx_2 …….
Tx_n】按顺序作用到初始State_0上，使全网始终保持相同的状态。在状态机复制过程中，我们要求State_n × Tx_{n+1}
-->State_{n+1}是决定性的。State_n × Tx_{n+1} -->
State_{n+1}实质上就是智能合约虚拟机对Tx_{n+1}的执行过程，如果智能合约虚拟机中存在设计或者实现漏洞，导致虚拟机不一致性执行（对相同的输入State_n
和Tx_{n+1}，输出State_{n+1}不一致）。则攻击者可以利用该问题在网络中产生分叉和并进行双花攻击。下面我们介绍多个EOS和NEO上我们发现的虚拟机不一致执行漏洞和其产生原因。
#### 4.1 EOS虚拟机内存破坏RCE漏洞:
此前，我们公开了文章[《EOS Node Remote Code Execution Vulnerability --- EOS WASM Contract
Function Table Array Out of Bound》](http://blogs.360.cn/post/eos-node-remote-code-execution-vulnerability.html "《EOS Node Remote Code Execution
Vulnerability --- EOS WASM Contract Function Table Array Out of Bound》")。
在该文中，我们发现了一个EOS
WASM虚拟机的一个内存越界写漏洞，针对该漏洞我们编写的利用程序可以成功利用该漏洞使EOS虚拟机执行任意指令，从而完全控制EOS所有出块和验证节点。
究其本质而言，是在State_n ×
Tx_{n+1}State_{n+1}过程中。攻击者能让EOS虚拟机完全脱离原本执行路径，执行任意指令，自然可以完成双花攻击。其攻击流程如下：
  * 步骤1：攻击者构造能够实现RCE的恶意智能合约，并将该合约发布到EOS网络中。
  * 步骤2：EOS超级节点解析到该合约后，触发漏洞，执行攻击者自定义的任意指令。
  * 步骤3：攻击者实现双花攻击。
该漏洞的危害非常严重，且是第一次智能合约平台受到远程代码执行攻击事件。读者可以阅读该文章了解相关细节，在此不再赘述。
#### 4.2 EOS虚拟机内存未初始化造成双花攻击
我们在编写《EOS Node Remote Code Execution Vulnerability --- EOS WASM Contract
Function Table Array Out of
Bound》的利用程序的过程中，还利用了EOS中当时的一个未公开的内存未初始化漏洞。在内存破坏攻击中，内存未初始化漏洞通常能够造成信息泄露、类型混淆等进一步问题，从而辅助我们绕过如ASLR之类的现代二进制程序的缓解措施，进一步实现攻击。然而在智能合约虚拟机中，内存未初始化漏洞有更直接的利用方式，可以直接造成双花攻击。以下为我们在EOS
RCE中利用的一个内存未初始化漏洞的细节，其可以被用来直接实现EOS智能合约代币资产双花攻击。
WASM虚拟机通过grow_memory伪代码来申请新的内存。在EOS WASM
grow_memory最初的实现中，未对申请到的内存进行清零操作。该块内存的空间实际上是随机的（依赖于合约执行机器的内存状态）。则攻击者可以构造恶意合约，实现对EOS上任意合约资产的双花攻击。其攻击流程如下：
  * 步骤1： 攻击者构造恶意智能合约。合约中通过grow_memory获得一块新的内存地址。
  * 步骤2：合约中读取该地址中的某个bit内容。【此时该bit可能为0，也可能为1，依赖于合约执行机器的状态】。
  * 步骤3：合约判断该bit的内容，如果为1。则发送代币给A用户，如果为0，则发送代币给B用户。从而实现双花攻击。
#### 4.3 EOS虚拟机内存越界读造成双花攻击:
在传统的内存破坏中，内存越界读漏洞主要将会导致信息泄露，从而辅助我们绕过如ASLR之类的现代二进制程序的缓解措施，进一步与其他漏洞一起实现攻击。然而在智能合约虚拟机中，内存越界读漏洞有更直接的利用方式，可以直接造成双花攻击。下面为一个我们发现的EOS内存越界读漏洞，我们可以利用该漏洞实现双花攻击。
当EOS WASM将一个offset转换内WASM内存地址时，其边界检查过程如下：
![
](https://images.seebug.org/content/images/2018/11/c6c677c7-423e-4616-b3fd-0bcbd91679b1.png-w331s)
在这里|ptr|的类型实际上是一个I32类型，它可以是一个负数。那么当： -sizeof(T) < ptr < 0
的时候，ptr+sizeof(T)是一个很小的数可以通过该边界检查。在之后的寻址中，我们看到代码：
`T &base = (T)(getMemoryBaseAddress(mem)+ptr)`
|base|的地址将会超过WASM的内存基址，从而让智能合约实现内存越界读【读到的内存地址内容取决于虚拟机当前执行状态，可被认为是随机的】。攻击者可以利用该漏洞实现双花攻击。其攻击过程如下：
  * 步骤1： 攻击者构造恶意智能合约。合约中利用内存越界读漏洞，读取超越WASM内存基址的某个bit。此时该bit可能为0，也可能为1，依赖于合约执行机器的状态】
  * 步骤2：合约判断该bit的内容，如果为1。则发送代币给A用户，如果为0，则发送代币给B用户。从而实现双花攻击。
#### 4.4 标准函数实现不一致造成双花攻击
总结上面双花攻击两个例子的本质，实际上是EOS合约在执行过程中因为某些内存漏洞原因读取到了随机变量，从而打破了原本虚拟机执行的一致性，造成了双花攻击。事实上，合约执行的不一致性，不一定完全依赖于随机性。这里我们介绍一个因为各个平台（版本）对标准C函数实现不一致造成的双花攻击。
在C语言标准定义中，memcmp函数的返回值被要求为：小于0，等于0，或者大于0。然而各种不同的C版本实现中，具体返回的可能不一样（但依然符合C标准）。攻击者可以利用该标准实现的不一致性，造成运行在不同系统上的EOS
虚拟机执行结果不一致，进而实现双花攻击。其攻击流程如下：
  * 步骤1：攻击者构造恶意智能合约，在合约中调用memcmp函数，并获取返回值。
  * 步骤2：此时，不同的平台和版本实现Memcmp的返回值不一致（即使EOS虚拟机的二进制代码是相同的）。恶意合约判断Memcmp的返回值，决定转账给A或B。从而完成双花。
该漏洞的具体修复如下：
![