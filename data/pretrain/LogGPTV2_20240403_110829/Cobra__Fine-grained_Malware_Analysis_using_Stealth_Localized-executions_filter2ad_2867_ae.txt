event. In our example, the IDT write event (AC IDTWRITE)
is used to obtain the single-step handler address and to setup
another overlay point on the single-step handler. The Cobra
API cobra comm is used to communicate between a callback
and other modules of the analysis tool, in situations where the
analysis tool is designed as a seperate process. In our exam-
ple, WiLDCAT runs the plugin in the address space of the tar-
get process/thread while the tool itself runs as a separate pro-
cess.
5. Experience
This section will discuss our experience with Cobra in ana-
lyzing a real-world malware, W32/Ratos [49], thereby illus-
trating the framework utility. We chose W32/Ratos for our
analysis and discussion since it operates in both user- and
kernel-mode, containing complex code envelopes and a vari-
ety of anti-analysis tricks that one would typically encounter in
recent malware. Before we proceed to discuss our experience
with W32/Ratos, a few words regarding the analysis environ-
ment are in order. To validate Cobra, we use our prototype mal-
ware analysis environment codenamed WiLDCAT. The current
version of WiLDCAT runs under the Windows OSs (9x, 2K
and XP) on the IA-32 (and compatible) processors. It makes
use of Cobra (apart from other frameworks such as SPiKE [51]
and VAMPiRE [50]) for real-time malware analysis in both a
coarse- and ﬁne-grained fashion. For analysis purposes, an In-
tel 1.7 GHz 32-bit processor with 512 MB of memory running
the Windows XP OS and WiLDCAT was used.
W32/Ratos, with variants known as W32/Ratos.A, Back-
door.Ratos.A, Backdoor.Nemog etc. is a trojan that runs under
the Windows OSs. It is usually deployed as a second stage mal-
ware after being downloaded as a payload of other malware
such as W32/MyDoom [38] and its variants. W32/Ratos and
its variants (hereon referred to as W32/Ratos collectively) ex-
ecute in both user- and kernel-mode. Once in place, the trojan
will allow external users to relay mail through random ports,
and to use the victim’s machine as an HTTP proxy. The trojan
also has the ability to uninstall or update itself, and to down-
load ﬁles by connecting to various predeﬁned list of IP ad-
dresses and ports on various public ﬁle sharing networks.
The internal structure of W32/Ratos is as shown in Fig-
ure 7. The malware consists of a user-mode process (named
DX32HHLP.EXE) and a kernel-mode component (named
DX32HHEC.SYS) running as a service. DX32HHLP.EXE is
responsible for the bulk of the malware functionality with the
kernel-mode component aiding encryption/decryption and ini-
tial deployment. W32/Ratos and its variants cannot be
analyzed using current static approaches. The malware em-
ploys complex multithreaded metamorphic code envelopes for
both its user- and kernel-mode components. W32/Ratos em-
ploys a multilevel encryption/decryption scheme employing
algorithims which resemble the TEA [54] and IDEA [29] ci-
phers. It employs a windowed mechanism where only a small
portion of it is decrypted in a pre-allocated region of mem-
ory, at a given time.
1 = Level-1 Decryption (IDEA cipher)
Metamorphic Code Fragments 
employing Level-2 decryption
2 = Level-2 Decryption (Variant of TEA cipher)
Metamorphic Code Fragments using the 
single-step handler for Level-2 decryption
DX32HHLP.EXE Address Space
Launch Code
and Data
(Polymorphic)
Static Encrypted
Code and Data
(IDEA cipher)
2
2
2
2
2
2
2
2
. . . .
1
1
1
User-Mode
Kernel-Mode
DX32HHEC.SYS
Launch Code
and Data
(Polymorphic)
Static Encrypted
Code and Data
(IDEA cipher)
Dynamically Allocated Memory Regions
using VirtualAlloc
Dynamically Allocated Memory Regions
using ExAllocatePool
2
2
2
l
r
e
d
n
a
H
2
2
. . . .
2
2
2
2
1
1
1
p
e
t
S
-
e
g
n
S
i
l
Figure 7. W32/Ratos Internal Structure
The metamorphic code envelopes access code and data us-
ing relative pointers for self-modiﬁcations and integrity checks
(see Section 5.1). Both the user- and the kernel-mode compo-
nents employ several anti-analysis tricks to prevent themselves
from being analyzed. Such checks include among other things,
code execution time proﬁling and privilege level detections.
These techniques are not handled by current dynamic ﬁne-
grained code analysis frameworks and the malware upon such
detections will remain dormant or put the system into an unsta-
ble state. The trojan code envelop is multithreaded in both user-
and kernel-mode and in certain cases achieve decryption via a
single-step exception (see Section 5.2) and also employ debug-
ging registers for their internal computation, thereby defeat-
ing current debuggers. The kernel-mode component of the tro-
jan achieves a stealth proﬁle by hooking several Windows OS
kernel functions such as ZwQueryDirInformation and ZwQw-
erySystemInformation.
The following paragraphs discuss in further detail, our ex-
perience in analyzing W32/Ratos, employing Cobra. The dis-
cussion serves as the basis on which we were able to docu-
ment the inner structure (shown in Figure 7) and operation of
the malware, thus illustrating the utility of the framework. For
purposes of discussion, we will proceed to look at some sim-
pliﬁed code fragments of W32/Ratos under different analysis
sessions with WiLDCAT. The code fragments are shown in the
32-bit assembly language syntax of the IA-32 (and compati-
ble) processors.
5.1. Metamorphism and Memory Layout
Our ﬁrst step in analyzing W32/Ratos started with a coarse-
grained analysis of the malware, thereby documenting its be-
haviour at a high level. We used SPiKE [51], our stealth coarse-
grained malware analysis framework, to obtain the different
system calls that were issued by the malware. It is found
that W32/Ratos issues several calls to ExAllocatePool, Vir-
tualAlloc, VirtualProtect and MMProbeandLockPages, func-
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
Metamorphic Code Fragment:
    ...
01. 2d003fe0h: mov eax, [edi+3ah]
02. 2d003fe3h: xor eax, [edi+2bh]
03. 2d003fe5h: mov [edi+2ch], eax
04. 2d003fe8h: call 2d003ff0h --> PC
05. 2d003ff0h: pop ebp            addressing
06. 2d003ff1h: mov ebx, [edi+1ah] 
07. 2d003ff4h: mov [ebp+eax], ebx
08. 2d003ff6h: mov esi, ebp
09. 2d003ff8h: add eax, ebp
10. 2d003ffbh: call eax --> data decrypt
11. 2d003ffeh: xor [edi+1ah], 7ch
12. 2d004001h: call d [edi+0bh]
13. 2d004004h: jne 2d00400Ah
14. 2d004006h: add ax, [bx+si]
15. 2d004006h: mov eax, 051
16. 2d004009h: xor eax, eax
    ...
encrypted
data for
code
decrypt
(a)
Obfuscated code:
01. 2d003fe0h: mov eax, 1B02EB02h 
02. 2d003fe5h: mov esi, E105EE3ch
03. 2d003feah: xor eax, 12344456h
04. 2d003fefh: mov eax, [ebx+esi]
    ...
(b)
3
2
1
Code decrypt:
    ...
01. push ebx
02. bts w [esp], 3
03. popf
04. mov edx, 4e773421h
05. sub edx, 33112255h
06. mov eax, 77421223h
07. push ebx
    ...
    ret
(c)
Unobfuscated code:
01. mov esi, [edi+7dh]
02. call d [edi+10h] --> stack fix
03. push esi
04. push edi
05. mov ebx, [esp+8+4]
06. push ebx
07. lea edx, [edi+04]
08. push edx
09. push 4096
10. lea eax, [edi+7c]
11. mov eax, [eax+4]
12. call eax  --> winsock.dll!read
13. jne 2d004f1a
...
(d)
Figure 8. (a)-(d) W32/Ratos Metamorphism
tions which allocate a range of memory outside of the existing
code and/or data regions and change the attributes of the allo-
cated memory range. The malware also creates several threads
in both kernel- and user-mode as exempiﬁed by calls to PsCre-
ateSystemThread and CreateThread APIs. We proceed to do
a deeper investigation by using KiSwitchContext as our ﬁrst
overlay point and invoking Cobra for ﬁne-grained analysis of
the threads created by the malware. KiSwitchContext is an in-
ternal Windows OS kernel function that is used for thread pre-
emption. We also instruct Cobra to generate events on mem-
ory accesses (reads, writes and/or executes) to any memory re-
gion allocated with the ExAllocatePool and VirtualAlloc APIs.
Consider the code fragment shown in Figure 8a. This (and
several other) code fragments show the trojan metamorphic en-
velop in action. The code fragment shown here was obtained
on events generated as a result of a write to the memory re-
gions allocated by the malware using the ExAllocatePool and
VirtualAlloc APIs and is a coalesced version of the blocks that
were executed by Cobra during the analysis process.
W32/Ratos employs a multilevel decryption mechanism
and metamorphic code engine to execute its internal code. The
ﬁrst level of decryption results in code fragments that are gen-
erated on the ﬂy and executed in the memory regions allocated
via the VirtualAlloc and ExAllocatePool APIs. Though the ac-
tual instructions of the decrypted code can vary from session to
session of analysis due to the metamorphic nature, they have a
regular pattern as shown in the example code fragment in Fig-
ure 8a. Here we see a fragment of a subroutine of the malware,
that is responsible for its update feature.
Every code fragment generated by the metamorphic engine
have two parts: a self-modifying second level decryption and
an encrypted data that is responsible for the actual function-
ing of the fragment. The self-modifying section uses a pro-
gram counter relative addressing (lines 4–5, Figure 8a) and
modiﬁes the code fragment by employing a second level de-
cryption. Some of the metamorphic code fragments employ a
second level decryption via a single-step handler in the kernel-
mode component of the trojan (see Section 5.2). The second
level of decryption changes the actual instructions at the start
of the code fragment and creates an obfuscated code section by
employing the encrypted data of the metamorphic code frag-
ment. It is also responsible for setting up the data for the new
instructions that are decrypted. (lines 10 and 12, Figure 8a).
The memory regions allocated via the VirtualAlloc and ExAl-
locatePool APIs thus act as a runtime window for code and
data decryption on the ﬂy. This technique ensures that not all
of the malware code and/or data are in the decrypted form at
a given time thereby making the analysis process harder. With
Cobra however, it is relatively easy to document such tech-
niques by using events corresponding to memory region ac-
cesses. Figure 7 shows the memory layout of W32/Ratos as a
result.
The code generated by the second layer of decryption over-
writes the start of the metamorphic code fragment and looks
like a sequence regular instructions but are in fact obfuscated
(Figure 8b). The actual instructions that are executed depend
on the constants to the various instructions. Cobra’s block exe-
cution events quickly reveal the actual code behind the obfus-
cated instructions as shown in Figure 8d. Upon further investi-
gations it is found that the obfuscated instructions of the code
fragment is actually a part of the trojan update feature that re-
sults in downlaods from certain public ﬁle sharing networks. A
metamorphic code fragment in certain cases, can also include
an integrity check on the code fragment to see if there has been
tampering. In such cases, the trojan simply ensures that the sec-
ond level decryption is voided, which results in the obfuscated
fragment not being decrypted leading to spurious faults dur-
ing the analysis process. Manual patching of such detections is
a tedious process since the malware employs several such in-
tegrity checks within its code-streams. However, with Cobra,
such integrity checks are not an issue since the framework en-
sures that the original code is left untouched in memory.
5.2. Decryption and Anti-Analysis Tricks
W32/Ratos employs a multilevel decryption scheme. The
ﬁrst level of decryption results in the generation of metamor-
phic code envelopes as discussed in the previous section. The
metamorphic code fragments employ a second level of decryp-
tion for their code and data. In certain cases the second level of
decryption is performed using a sublte technique involving the
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:50:44 UTC from IEEE Xplore.  Restrictions apply. 
    ...