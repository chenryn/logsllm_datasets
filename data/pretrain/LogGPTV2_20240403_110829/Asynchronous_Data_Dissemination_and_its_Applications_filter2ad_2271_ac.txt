every honest node outputs ğ‘€.
Proof. Clearly, every honest sender outputs ğ‘€. Thus, we again
focus on honest recipient nodes.
We will first argue that an honest recipient node will never
output a wrong message. Suppose node ğ‘– outputs a polynomial ğ‘ğ‘Ÿ (Â·)
as the message in the ğ‘Ÿth iteration in the reconstruction phase. Let
ğ‘‡ğ‘Ÿ be the set of symbols node ğ‘– used in iteration ğ‘Ÿ. Then, ğ‘ğ‘Ÿ (Â·) is
consistent with 2ğ‘¡ +1 points from ğ‘‡ğ‘Ÿ , of which at least ğ‘¡ +1 are from
honest nodes. All these points belong on both polynomial ğ‘(Â·) and
ğ‘ğ‘Ÿ (Â·). Since both ğ‘ğ‘Ÿ (Â·) and ğ‘(Â·) are degree-ğ‘¡ polynomials and agree
on ğ‘¡ + 1 points, ğ‘ğ‘Ÿ (Â·) and ğ‘(Â·) are the same polynomial.
Next, we argue that every honest recipient node will eventually
output a message. From Lemma 3.2, at the end of the dispersal phase,
every honest node holds the correct symbol of ğ‘€â€² = RSEnc(ğ‘€, ğ‘›, ğ‘¡ +
1) and will send it to all other nodes in its RECONSTRUCT messages.
Thus, every recipient node will eventually receive 2ğ‘¡ + 1 correct
symbols from all honest nodes, and at most ğ‘¡ incorrect symbols
from malicious nodes. Hence, the RSDec algorithm will correct all
the errors and will return the correct message.
â–¡
We will next argue about the total communication cost of our
ADD protocol.
Lemma 3.4. The total communication cost of our ADD protocol is
ğ‘‚(ğ‘›|ğ‘€|+ğ‘›2).
Proof. Recall that |ğ‘€â€²|= ğ‘›|ğ‘€|/(ğ‘¡ + 1) = ğ‘‚(|ğ‘€|). During the dis-
persal phase, each sender node sends a message of size |ğ‘€â€²|/ğ‘›+ğ‘‚(1)
to every other node. During the reconstruction phase, each node
sends a message of size |ğ‘€â€²|/ğ‘›+ğ‘‚(1) to every other node. Therefore,
the total communication cost of the protocol is ğ‘›|ğ‘€â€²|+ğ‘‚(ğ‘›2), which
is the same as ğ‘‚(ğ‘›|ğ‘€|+ğ‘›2).
â–¡
Using Lemma 3.2, 3.3 and 3.4, we get the following theorem.
Theorem 3.5. In an asynchronous network of ğ‘› = 3ğ‘¡ + 1 nodes, of
which up to ğ‘¡ nodes can be malicous, Algorithm 1 solves ADD with a
communication complexity of ğ‘‚(ğ‘›|ğ‘€|+ğ‘›2).
Remark. One subtle point to note here is that the Reed-Solomon
code requires the field size to be larger than ğ‘›. Hence, each symbol
in the encoded codeword is of size ğ‘‚(log ğ‘›). As a result, the size
of the encoded message is at least ğ‘‚(ğ‘› log ğ‘›). Thus, ADD is more
useful when the message size is â„¦(ğ‘› log ğ‘›) which is the case for
our RBCand AVSS applications. We will give a lower bound in
1. Input: 2. RSEnc1. Input: 2.RSEnc1. Input: Node 1Node 2Node 3Node 43. Output  3. Output OEC3. Output  Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2708Algorithm 2 Brachaâ€™s RBC [14]
1: // only broadcaster node
2: input ğ‘€
3: send âŸ¨PROPOSE, ğ‘€âŸ© to all
4: // all nodes
5: input ğ‘ƒ(Â·) // predicate ğ‘ƒ(Â·) returns true unless otherwise specified.
6: upon receiving âŸ¨PROPOSE, ğ‘€âŸ© from the broadcaster do
7:
8:
9: upon receiving 2ğ‘¡ +1 âŸ¨ECHO, ğ‘€âŸ© messages and not having sent a READY
send âŸ¨ECHO, ğ‘€âŸ© to all
if ğ‘ƒ(ğ‘€) then
send âŸ¨READY, ğ‘€âŸ© to all
10:
11: upon receiving ğ‘¡ +1 âŸ¨READY, ğ‘€âŸ© messages and not having sent a READY
message do
message do
send âŸ¨READY, ğ‘€âŸ© to all
12:
13: upon receiving 2ğ‘¡ + 1 âŸ¨READY, ğ‘€âŸ© messages do
14:
output ğ‘€
Â§ 6 showing that the communication complexity of Algorithm 1 is
optimal for |ğ‘€|â‰¥ Î˜(ğ‘› log ğ‘›).
Now let us analyze the computation cost of each node in Algo-
rithm 1. The encoding step at every sender during the dispersal
phase involves ğ‘‚(ğ‘›2) operations (additions and multiplications) in
Zğ‘ (the recipient nodes do nothing). During the reconstruction
phase, each recipient node needs to invoke the RSDec algorithm
anywhere between one to ğ‘¡ times, and each invocation of RSDec
requires ğ‘‚(ğ‘› polylog(ğ‘›)) computation if we use the decoding algo-
rithm of Gao [28].
4 RELIABLE BROADCAST
Reliable broadcast (RBC) was introduced by Bracha [14]. In the
same paper, Bracha provided a RBC protocol for a single bit with a
communication complexity of ğ‘‚(ğ‘›2). In this paper, we present two
RBC protocols for long messages. Both protocols are built upon
Brachaâ€™s RBC. The first protocol is conceptually simpler and uses
Brachaâ€™s RBC and ADD in a modular way. However, it requires
two additional rounds of communication than Brachaâ€™s RBC. Our
second protocol merges the steps of Brachaâ€™s RBC and ADD and
matches the round complexity of Brachaâ€™s RBC.
Definition 4.1 (Reliable Broadcast). A protocol for a set of nodes
{1, ...., ğ‘›}, where a distinguished node called the broadcaster holds
an initial input ğ‘€ of size |ğ‘€|, is a reliable broadcast protocol, if the
following properties hold
â€¢ Agreement. If an honest node outputs a message ğ‘€â€² and another
honest node outputs a message ğ‘€â€²â€², then ğ‘€â€² = ğ‘€â€²â€².
â€¢ Validity. If the broadcaster is honest, all honest nodes eventually
â€¢ Totality. If an honest node outputs a message, then every honest
output the message ğ‘€.
node eventually outputs a message.
Since our RBC protocols rely upon Brachaâ€™s RBC protocol [14],
we first describe Brachaâ€™s RBC protocol in Algorithm 2. The main
idea of Brachaâ€™s RBC is to use quorum intersection (of ECHO mes-
sages) for agreement and use vote amplification (of READY messages)
for totality. However, the protocol needs to attach the input ğ‘€ in
every message, leading to a high communication cost of ğ‘‚(ğ‘›2|ğ‘€|).
Algorithm 3 ADD-based RBC for long messages
1: // only broadcaster node
2: input ğ‘€
3: send âŸ¨PROPOSE, ğ‘€âŸ© to all
4: // all nodes
5: input ğ‘ƒ(Â·) // predicate ğ‘ƒ(Â·) returns true unless otherwise specified.
6: upon receiving âŸ¨PROPOSE, ğ‘€âŸ© from the broadcaster do
7:
8:
9:
10: upon receiving 2ğ‘¡ + 1 âŸ¨ECHO, â„âŸ© messages and not having sent a READY
let â„ := hash(ğ‘€)
send âŸ¨ECHO, â„âŸ© to all
if ğ‘ƒ(ğ‘€) then
send âŸ¨READY, â„âŸ© to all
11:
12: upon receiving ğ‘¡ + 1 âŸ¨READY, â„âŸ© messages and not having sent a READY
message do
message do
send âŸ¨READY, â„âŸ© to all
if received âŸ¨PROPOSE, ğ‘€âŸ© and â„ = hash(ğ‘€) then
13:
14: upon receiving 2ğ‘¡ + 1 âŸ¨READY, â„âŸ© messages do
15:
16:
17:
18:
ADD(ğ‘€)
ADD(âŠ¥)
else
Algorithm 4 Four-round RBC protocol for long messages
1: // only broadcaster node
2: input ğ‘€
3: send âŸ¨PROPOSE, ğ‘€âŸ© to all
4: // all nodes
5: input ğ‘ƒ(Â·) // predicate ğ‘ƒ(Â·) returns true unless otherwise specified.
6: upon receiving âŸ¨PROPOSE, ğ‘€âŸ© from the broadcaster do
7:
8:
9:
10:
11: upon receiving 2ğ‘¡ +1 âŸ¨ECHO, ğ‘šğ‘–, â„âŸ© matching messages and not having
Let â„ := hash(ğ‘€)
Let ğ‘€â€² := [ğ‘š1, ğ‘š2, . . . , ğ‘šğ‘›] := RSEnc(ğ‘€ğ‘–, ğ‘›, ğ‘¡ + 1)
send âŸ¨ECHO, ğ‘š ğ‘— , â„âŸ© to node ğ‘— for ğ‘— = 1, 2, . . . , ğ‘›
if ğ‘ƒ(ğ‘€) then
sent a READY message do
send âŸ¨READY, ğ‘šğ‘–, â„âŸ© to all
12:
13: upon receiving ğ‘¡ + 1 âŸ¨READY,âˆ—, â„âŸ© messages and not having sent a
READY message do
Wait for ğ‘¡ + 1 matching âŸ¨ECHO, ğ‘šâ€²
send âŸ¨READY, ğ‘šâ€²
ğ‘–, â„âŸ© to all
ğ‘–, â„âŸ©
14:
15:
16: For the first âŸ¨READY, ğ‘šâˆ—
ğ‘‡â„ initialized as {}
17: for 0 â‰¤ ğ‘Ÿ â‰¤ ğ‘¡ do
18:
19:
20:
21:
// Error Correction
upon |ğ‘‡â„ |â‰¥ 2ğ‘¡ + ğ‘Ÿ + 1 do
Let ğ‘€â€² be coefficients of RSDec(ğ‘¡ + 1, ğ‘Ÿ,ğ‘‡ )
if hash(ğ‘€â€²) = â„ then
output ğ‘€â€² and return
ğ‘— , â„âŸ© received from node ğ‘—, add (ğ‘—, ğ‘šâˆ—
ğ‘— ) to ğ‘‡â„ //
We modify the RBC protocol interface to add an external check
before sending the ECHO message, denote it as a predicate ğ‘ƒ(Â·). We
do so to make our AVSS and ACSS protocols use RBC in a modular
way. For standard RBC, this step can be skipped, i.e., ğ‘ƒ(Â·) always
returns true.
We give our first RBC protocol for long messages in Algorithm 3
where we highlight the changes from Brachaâ€™s RBC in blue. We
then prove it achieves all the required properties of RBC. We give
our second RBC protocol in Algorithm 4 and defer its proofs to
Appendix A.
Session 10C: Foundations CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2709The core idea in our first RBC protocol is to run the Brachaâ€™s
RBC only on the hash of the message ğ‘€, and then disseminate
the message ğ‘€ using ADD. The previous best RBC protocol for
long messages due to Cachin and Tessaro [16] also runs Brachaâ€™s
RBC on the hash digest. However, their protocol requires attaching
Merkle path proofs in the messages, which inevitably incurs a cost
of ğ‘‚(ğ‘›|ğ‘€|+ğœ…ğ‘›2 log ğ‘›). Our ADD protocol removes these Merkle path
proofs and leads to a total communication cost of ğ‘‚(ğ‘›|ğ‘€|+ğœ…ğ‘›2) for
RBC.
More specifically, the broadcaster in our ADD-based RBC pro-
tocol first sends ğ‘€ to all other nodes. Every honest node, upon
receiving the message from the broadcaster, first participates in
a Brachaâ€™s RBC on â„, the hash digest of ğ‘€. Once Brachaâ€™s RBC
terminates, i.e., a node receives 2ğ‘¡ + 1 READY messages for some â„,
the node inputs ğ‘€ to the ADD protocol if â„ = hash(ğ‘€). Otherwise
(if â„ Ì¸= hash(ğ‘€) or if the node has not received a PROPOSE message
from the broadcaster), the node inputs âŠ¥ to ADD. Recall that in
Brachaâ€™s RBC, a node outputs ğ‘€ upon receiving 2ğ‘¡ + 1 READY mes-
sages for ğ‘€, which implies at least ğ‘¡ + 1 honest nodes have received
ğ‘€ from the broadcaster before sending ECHO for ğ‘€. Similarly, in
our RBC protocol, when a node receives 2ğ‘¡ + 1 READY messages for
some hash â„, at least ğ‘¡ + 1 honest nodes have received the message
ğ‘€ such that hash(ğ‘€) = â„ Moreover, the agreement property of the
Brachaâ€™s RBC guarantees that no two honest nodes will agree on
different hashes, and thus any honest node that receives ğ‘€â€² Ì¸= ğ‘€
from the broadcaster will input âŠ¥ to the ADD. Therefore, the ini-
tial condition of ADD is met. Hence, the guarantees of our ADD
protocol ensure the desired properties of the RBC protocol.
The four-round RBC protocol (Algorithm 4) saves two rounds
by merging our ADD into Brachaâ€™s RBC, thanks to the similarity
in their message patterns. More specifically, the ECHO and READY
messages in Brachaâ€™s RBC now also attach the symbols of the
message which were sent separately in ADD before.
4.1 Analysis of Algorithm 3
First, we show that running Brachaâ€™s RBC on the hash â„ sets up
the initial condition for ADD.
Lemma 4.2. If any honest node executes ADD(ğ‘€), then there are
at least 2ğ‘¡ + 1 nodes, among which at least ğ‘¡ + 1 are honest nodes, that
receive ğ‘€ from the broadcaster and send âŸ¨ECHO, â„âŸ© to all other nodes
where â„ = hash(ğ‘€).
Proof. An honest node ğ‘– executes ADD(ğ‘€) only upon receiving
âŸ¨READY, â„ = hash(ğ‘€)âŸ© messages from a quorum Q2 of 2ğ‘¡ + 1 nodes.
Since there are at most ğ‘¡ malicious nodes in the system, at least ğ‘¡ +1
of the nodes in Q2 are honest. This implies that at least one honest
node receives âŸ¨ECHO, â„âŸ© from a quorum Q1 of 2ğ‘¡ + 1 nodes. Again,