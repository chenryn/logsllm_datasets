        // 如果连接过早关闭（即一个pending的connection被关闭了，此时会调用OnConnectionClosed
        if (connection && connection->callbacks() == pending_->database_callbacks) {
            pending_->callbacks->OnError(
                IndexedDBDatabaseError(blink::kWebIDBDatabaseExceptionAbortError,
                                       "The connection was closed."));
            // 该连接将在数据库中被重置
            db_->RequestComplete(this);
            return;
        }
        // 如果当前connection不是最后一个要处理的连接，则不会执行到StartUpgrade创建新连接。
        if (!db_->connections_.empty())
            return;
        StartUpgrade();
    }
如果当前连接类型不为`pending connection`，即 **该连接并非被过早关闭** （即正常情况，正常情况是比异常情况更容易触发的），并且
**当前连接为connections_中的最后一个连接**
。则该函数会执行[StartUpgrade](https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc;l=243)函数，`StartUpgrade`函数内部会使得IndexedDBDatabase
**创建一个新的pending connection至connections_列表中** 。
    // Initiate the upgrade. The bulk of the work actually happens in
    // IndexedDBDatabase::VersionChangeOperation in order to kick the
    // transaction into the correct state.
    void StartUpgrade() {
        // 使数据库创建一个新的连接
        connection_ = db_->CreateConnection(pending_->database_callbacks,
                                            pending_->child_process_id);
        DCHECK_EQ(db_->connections_.count(connection_.get()), 1UL);
        std::vector object_store_ids;
        IndexedDBTransaction* transaction = connection_->CreateTransaction(
            pending_->transaction_id,
            std::set(object_store_ids.begin(), object_store_ids.end()),
            blink::mojom::IDBTransactionMode::VersionChange,
            new IndexedDBBackingStore::Transaction(db_->backing_store()));
        db_->RegisterAndScheduleTransaction(transaction);
        transaction->ScheduleTask(
            base::BindOnce(&IndexedDBDatabase::VersionChangeOperation, db_,
                           pending_->version, pending_->callbacks));
    }
这样，`connections_`集合元素将不为0。当控制流从`OnConnectionClosed`函数返回时，便无法通过下面的判断。这样，就无法执行`factory_->ReleaseDatabase`。
>
> 预期情况是，当最后一个连接被erase后，一定进入下面的if语句以执行`factory_->ReleaseDatabase`，但在这里显然是一个非预期情况。
    void IndexedDBDatabase::Close(IndexedDBConnection* connection, bool forced) {
      // ...
      if (active_request_)
        active_request_->OnConnectionClosed(connection);
      // 如果当前数据库中的所有连接和所有请求均已经全部释放完成，则从IndexDBFactory类实例中删除指向当前IndexedDBData的指针
      if (connections_.empty() && !active_request_ && pending_requests_.empty()) {
        backing_store_ = nullptr;
        factory_->ReleaseDatabase(identifier_, forced);
      }
    }
而`factory_->ReleaseDatabase`函数会将 **指向当前数据库的原始指针**
从`database_map_`中删除，也就是说，若`IndexedDBFactoryImpl::ReleaseDatabase`不被执行，则
**该原始指针就一直保存在`database_map_`中**。
    void IndexedDBFactoryImpl::ReleaseDatabase(
        const IndexedDBDatabase::Identifier& identifier,
        bool forced_close) {
      DCHECK(!database_map_.find(identifier)->second->backing_store());
      // 将当前IndexedDatabase原始指针从database_map中删除
      RemoveDatabaseFromMaps(identifier);
      // No grace period on a forced-close, as the initiator is
      // assuming the backing store will be released once all
      // connections are closed.
      ReleaseBackingStore(identifier.first, forced_close);
    }
最终，`database_map_`中保留的 **原始指针并没有被删除** 。
同时，当控制流返回`IndexedDBDatabase::ForceClose`函数时，由于`connections_`集合既执行了`erase`函数，又执行了`insert`函数，因此在下一次判断循环条件`it
!= connections_.end()`时，`connection_`集合中仍然存在connection（尽管此时的连接非彼时的连接），
**connection_集合的元素个数将保持不变** 。而`end`函数返回的是`list`的迭代器，
**所以返回的`end`迭代器将保证不变**，而`it++`，因此将跳出该循环，结束 **连接的终止操作**
。但最重要的是，`IndexedDBFactoryImpl::database_map`中 **仍然保留指向当前数据库的原始指针**
。该指针本应该在当前循环执行结束时被移除，但这里却没有被移除。
    void IndexedDBDatabase::ForceClose() {
      // ...
      auto it = connections_.begin();
      while (it != connections_.end()) {
        IndexedDBConnection* connection = *it++;
        // 注意这一步，执行`connection->ForceClose()`时，程序会关闭当前连接。
        // 但倘若当前遍历的连接是connection_中的最后一条连接，则会执行函数StartUpgrade以建立新连接
        connection->ForceClose();
      }
      // ...
    }
现在，我们可以成功将指向当前`IndexedDatabase`的一个原始指针保存至 **本不该保存的地方**
(指`database_map`)。而我们下一步要做的就是尝试将当前`IndexedDatabase`所使用的内存释放。
####  b. 释放IndexedDB内存
IndexedDBDatabase对象是一种 **引用计数（Reference counted）的对象** 。
针对该对象的计数引用被保存在IndexedDBConnection对象、IndexedDBTransaction对象或其他正在进行或待处理的请求对象中。
一旦引用计数降至0，会立即释放对象。（以免忘记，这段又重复了一遍）
    class CONTENT_EXPORT IndexedDBConnection {
     // ...
      // NULL in some unit tests, and after the connection is closed.
      scoped_refptr database_;
     // ...
    };
    class CONTENT_EXPORT IndexedDBTransaction {
     // ...
      scoped_refptr database_;
     // ...
    }
也就是说，一旦我们将所有与当前IndexedDBDatabase对象相关的Connection和Transaction对象全部释放，那么当前IndexedDBDatabase就会因为引用计数为0而自动释放。
Issue941746给出了一种方法 ——
通过调用`IndexedDBFactoryImpl::AbortTransactionsForDatabase`来释放IndexedDBDatabase对象。
    // 函数调用call
    content::IndexedDBFactoryImpl::AbortTransactionsForDatabase
      content::IndexedDBFactoryImpl::AbortTransactions                 // 循环对所有IndexedDatabase执行AbortAllTransactionsForConnections
        content::IndexedDBDatabase::AbortAllTransactionsForConnections // 循环对所有Connection执行FinishAllTransactions
          content::IndexedDBConnection::FinishAllTransactions          // 循环对所有Transactions执行Abort
            content::IndexedDBTransaction::Abort
              content::IndexedDBConnection::RemoveTransaction          // 释放Transaction
              content::IndexedDBDatabase::TransactionFinished          // 释放Connection
执行`AbortTransactionsForDatabase`函数将会释放所有的`IndexedDBConnection`以及`IndexedDBTransaction`，进而释放`IndexedDatabase`对象，如此就能达到我们想要释放某个IndexedDatabase对象的目的。
> 这里贴出IndexedDBTransaction::Abort函数的关键代码。 **请注意函数内部的注释** 。
    void IndexedDBTransaction::Abort(const IndexedDBDatabaseError& error) {
      // ...
      database_->TransactionFinished(this, false);
      // RemoveTransaction will delete |this|.
      // Note: During force-close situations, the connection can be destroyed during
      // the |IndexedDBDatabase::TransactionFinished| call
      // 上面这段注释表示，在`force_close = true`的前提下，执行该函数将会释放connection以及trasaction
      if (connection_)
        connection_->RemoveTransaction(id_);
    }
####  c. 如何触发UAF
根据上面的分析，我们可以得出，当顺序调用这三个函数时，我们便可以成功使`database_map`中保存一个指向已被释放内存的悬垂指针。
  * `Open(db1)`
  * `DeleteDatabase(db1, force_close=True)`
  * `AbortTransactionsForDatabase`
之后，我们只需通过Heap Spray将这块被释放的内存重新分配回来即可利用。
但这里有个问题，如何在render进程中通过IndexedDBFactory来调用这三个函数呢？实际上，render的JS接口可以调用IndexedDB的`open`和`deleteDatabase`，但无法调用`AbortTransactionsForDatabase`接口。同时，这里存在一个问题，
**我们无法保证browser进程中的函数执行顺序如我们所期待的那样** ，因为Js中IndexedDB接口大多都是 **异步**
的，因此browser中的这三个函数可能无法依次、完全的完成执行。
但我们又必须在render进程中依次同步执行这三个函数，而这就是为什么 **该漏洞只能在`render RCE`的基础上利用**的原因了。由于
**`render RCE`可以给render进程自己打上patch**，所以就可以在render进程中打patch **以保证这三个函数可以被同步调用**
（即依次执行）。
> 这也是为什么在 **环境搭建** 时要在chrome源码中打上patch的原因，因为手动打上patch可以模拟render RCE 打patch的结果。
    // third_party/blink/renderer/modules/indexeddb/web_idb_factory_impl.cc
    void WebIDBFactoryImpl::Open(
           std::make_unique(
               base::WrapUnique(database_callbacks));
       DCHECK(!name.IsNull());
       factory_->Open(GetCallbacksProxy(std::move(callbacks_impl)),
                      GetDatabaseCallbacksProxy(std::move(database_callbacks_impl)),
                      name, version, transaction_id);
    +  if (version == 3) {
    +    mojom::blink::IDBCallbacksAssociatedPtrInfo ptr_info;
    +    auto request = mojo::MakeRequest(&ptr_info);
    +    factory_->DeleteDatabase(std::move(ptr_info), origin, name, true);
    +    factory_->AbortTransactionsForDatabase(origin, base::OnceCallback());
    +  }
     }
####  d. POC
笔者在`issue 941746`提供的poc上做了一点修改，新构造的POC删除了无用的语句，并使Chrome触发Crash
Chrome成功crash
> 图中多输出的`nice`，为chrome打patch时多添加的一条printf语句
>
> 该语句的输出表示patch部分代码被执行。
###  4\. 后记
以下是chrome团队修复后的代码。该[patch](https://chromium.googlesource.com/chromium/src.git/+/eaf2e8bce3855d362e53034bd83f0e3aff8714e4%5E%21/)彻彻底底将`connections_`集合中的所有连接全部关闭。patch前的代码依赖
**迭代器** 来判断是否全部关闭所有连接，而patch后的代码使用集合元素个数来进行判断，某种程度上使得代码更加安全。
    @@ -1949,10 +1949,10 @@
         request->AbortForForceClose();
       }
    -  auto it = connections_.begin();
    -  while (it != connections_.end()) {
    -    IndexedDBConnection* connection = *it++;
    +  while (!connections_.empty()) {
    +    IndexedDBConnection* connection = *connections_.begin();
         connection->ForceClose();
    +    connections_.erase(connection);
       }
       DCHECK(connections_.empty());
       DCHECK(!active_request_);
## 四、参考
[The Most Secure Browser? Pwning Chrome from 2016 to
2019](https://www.blackhat.com/us-19/briefings/schedule/index.html#the-most-secure-browser-pwning-chrome-from--to--16274)
  * [Presentation Slides](http://i.blackhat.com/USA-19/Wednesday/us-19-Feng-The-Most-Secure-Browser-Pwning-Chrome-From-2016-To-2019.pdf)
  * [White Paper](http://i.blackhat.com/USA-19/Wednesday/us-19-Feng-The-Most-Secure-Browser-Pwning-Chrome-From-2016-To-2019-wp.pdf)
[NVD – CVE-2019-5826 Dtail](https://nvd.nist.gov/vuln/detail/CVE-2019-5826)
[Chrome Issue 941746: Security: UAF in
content::IndexedDBDatabase](https://crbug.com/941746)
[通过IndexedDB条件竞争实现Chrome沙箱逃逸（上）](https://www.anquanke.com/post/id/183809#h3-3)
> 该文章 **并没有涉及** 我们当前所研究的UAF漏洞，但即便如此，它仍然提供了一些关于`IndexedDB`相关的说明。