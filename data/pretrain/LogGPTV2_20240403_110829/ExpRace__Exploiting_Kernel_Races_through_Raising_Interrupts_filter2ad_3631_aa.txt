title:ExpRace: Exploiting Kernel Races through Raising Interrupts
author:Yoochan Lee and
Changwoo Min and
Byoungyoung Lee
ExpRacE: Exploiting Kernel Races through 
Raising Interrupts
Yoochan Lee, Seoul National University; Changwoo Min, Virginia Tech; 
Byoungyoung Lee, Seoul National University
https://www.usenix.org/conference/usenixsecurity21/presentation/lee-yoochan
This paper is included in the Proceedings of the 30th USENIX Security Symposium.August 11–13, 2021978-1-939133-24-3Open access to the Proceedings of the 30th USENIX Security Symposium is sponsored by USENIX.EXPRACE: Exploiting Kernel Races through Raising Interrupts
Yoochan Lee
Seoul National University
PI:EMAIL
Changwoo Min
Virginia Tech
PI:EMAIL
Byoungyoung Lee ∗
Seoul National University
PI:EMAIL
Abstract
A kernel data race is notoriously challenging to detect, re-
produce, and diagnose, mainly caused by nondeterministic
thread interleaving. The kernel data race has a critical secu-
rity implication since it often leads to memory corruption,
which can be abused to launch privilege escalation attacks.
Interestingly, due to the challenges above, the exploitation of
the kernel data race is also challenging. Specifically, we find
that some kernel races are nearly impossible to exploit due
to their unique requirement on execution orders, which are
almost impossible to happen without manual intervention.
This paper develops a generic exploitation technique
for kernel data races. To this end, we first analyze kernel
data races, which finds an intrinsic condition classifying
easy-to-exploit and hard-to-exploit races. Then we develop
EXPRACE, a generic race exploitation technique for mod-
ern kernels, including Linux, Microsoft Windows, and MAC
OS X. EXPRACE turns hard-to-exploit races into easy-to-
exploit races by manipulating an interrupt mechanism during
the exploitation. According to our evaluation with 10 real-
world hard-to-exploit races, EXPRACE was able to exploit
all of those within 10 to 118 seconds, while an exploitation
without EXPRACE failed for all given 24 hours.
1 Introduction
Data races are concurrency bugs, which occur when multiple
threads access the same memory location while at least one
access modifies the location. Without employing a proper syn-
chronization mechanism (such as spinlocks, mutexes, etc.),
the data race ends up with inconsistent results, severely harm-
ing the security and reliability of underlying systems.
Data races are notoriously difficult to detect, reproduce,
and diagnose because they are inherently non-deterministic,
caused by thread interleaving or scheduling. This unique char-
acteristic and challenge of data races motivate many stud-
ies [3, 7, 9, 18, 27, 30, 40, 50, 57, 65, 66] to focus on assisting
∗Corresponding author
CVE
PoC
Kernel Ver.
Race Type Crash Type
CVE-2016-8655 < Linux 4.8.12 Single-var. Use-after-free
✔
CVE-2017-2636 < Linux 4.10.1 Single-var. Double-free
✔
CVE-2017-7533 < Linux 4.12.3 Single-var. Heap overflow
✔
CVE-2017-17712 < Linux 4.14.6 Single-var. Uninitialized use ✗
CVE-2019-11486 < Linux 5.0.8
✔
Single-var. Use-after-free
CVE-2017-15265 < Linux 4.13.8 Multi-var. Use-after-free
CVE-2019-1999 < Linux 4.19.37 Multi-var. Use-after-free
CVE-2019-2025 < Linux 4.19.6 Multi-var. Use-after-free
CVE-2019-6974 < Linux 4.20.8 Multi-var. Use-after-free
Multi-var. Use-after-free
11eb85ec...
< Linux 5.6
1a6084f8...
Multi-var. Use-after-free
< Linux 5.6
< Linux4.19.97 Multi-var. Use-after-free
20f2e4c2...
< Linux 4.4
4842e98f...
Multi-var. Use-after-free
< Linux 4.14 Multi-var. NULL deref.
da1b9564...
e20a2e9c...
< Linux 4.19.32 Multi-var. Double-Free
✗
▲
▲
✗
✗
✗
✗
✗
✗
✗
Table 1: Real-world kernel data races in Linux. ✔ denotes an exploit
is publicly available; ▲ denotes an exploit is publicly available
but requires kernel modification; ✗ denotes no publicly available
exploits.
software developers in detecting, reproducing, and diagnosing
race issues.
Notably, data races in the kernel can be abused to launch
privilege escalation attacks. Data races often lead to tra-
ditional memory corruptions, including buffer overflows,
double-free, use-after-free, etc. Hence, unprivileged users can
exploit the memory corruption issue caused by the kernel data
race to gain its privilege illegally.
Interestingly, due to the aforementioned challenges related
to races, the exploitation of kernel data races is also challeng-
ing. Specifically, race exploitation requires precisely control-
ling the thread interleaving, but the kernel does not offer such
a feature for users. Hence race exploitation in practice relies
on a brute-force attack – i.e., simply keeping trying to trigger
the race until success. Such a brute-force attack works for
some kernel races and has been leveraged by most race-based
privilege escalation attacks. For instance, as shown in Table 1,
exploits known to the public annotated with a checkmark (✔)
do so with the brute-force attack. However, we observe that
USENIX Association
30th USENIX Security Symposium    2363
the same brute-force attack is not effective at all for some
types of kernel races (i.e., annotated with a triangle ▲).
In particular, we tested those hard-to-exploit cases, CVE-
2019-1999 [23], and CVE-2019-2025 [24]. We confirmed that
the brute-force exploitation fails, which tried 5 billion times
and 15 million times of exploitation for 24 hours (more details
in §7.1). It is worth noting that these two kernel races were
confirmed to be vulnerabilities by kernel developers, but such
confirmation is done by manually modifying the kernel – i.e.,
manually inserting a sleep function between racing memory
accesses in hopes that the success chance of a brute-force
attack increases. In other words, when those were confirmed,
the testing environment was contrived, which cannot clearly
state its exploitability in real-world.1
This paper proposes EXPRACE, a generic exploitation tech-
nique for kernel data races. To this end, we attempt to answer
the following two research questions regarding kernel races;
Q1: Why some kernel races are exploitable through a brute-
force attack, while others are nearly impossible to exploit?;
Q2: Would it be possible to develop a new exploitation tech-
nique that augments the exploitability of hard-to-exploit ker-
nel races?
To answer the first question, we dissect the kernel data
races into two categories – 1) a single-variable race and 2)
a multi-variable race – and study the exploitability of each
category. Our study found a specific set of multi-variable
races (named non-inclusive multi-variable races), where its
probability of successful brute-force exploitation is near zero.
Specifically, exploitation of non-inclusive multi-variable races
imposes a unique execution order to trigger, which is nearly
impossible to occur without using extra debugging features
(e.g., inserting a sleep or installing a breakpoint).
To answer the second question, we develop EXPRACE,
a generic exploitation technique for non-inclusive multi-
variable races. The key idea of EXPRACE is to keep raising
interrupts to alter kernel thread’s interleaving indirectly. This
allows EXPRACE to transform hard-to-exploit multi-variable
races into easy-to-exploit multi-variable races. Executing this
idea involves several challenges. First, how to raise an inter-
rupt from userspace? An interrupt mechanism is only control-
lable from the kernel, and clearly, it is not directly accessible
from userspace. Second, even if EXPRACE is somehow able
to raise an interrupt, how can it impact the thread interleaving
in a controlled way? Races occur by multiple threads running
on multiple CPU cores. It is unclear how to deliver such an
interrupt to a specific thread to alter the thread interleaving
for exploitation. Hence, we systematically analyze interrupt
mechanisms in modern kernels, including Linux, Microsoft
Windows, and Mac OS X. Then EXPRACE proposes four new
race exploitation methods, where each leverages a different
interrupt mechanism (i.e., rescheduling IPI, TLB shootdown
1The term ‘exploitability’ in this paper means the reproducibility of the
race, but we use ‘exploitability’ throughout the paper as precisely triggering
a race is an essential step to exploit race condition vulnerabilities.
IPI, membarrier IPI, and hardware interrupts).
In order to demonstrate the exploitation effectiveness, we
evaluated EXPRACE with 10 real-world multi-variable races
in Linux. Our evaluation results confirm that EXPRACE truly
transformed hard-to-exploit races into easy-to-exploit races.
While a brute-force attack without EXPRACE failed to exploit
all of those for 24 hours, a brute-force attack with EXPRACE
has successfully exploited all those 10. The time taken to suc-
ceed the exploitation varies depending on each exploitation
method and vulnerability, but it takes from 10 seconds to 118
seconds.
We note that a clear understanding of the exploitability is
the key for security risk assessment and management. In this
regard, many works proposing new exploitation techniques
(such as heap sprays [14, 51], ASLR breaking attacks [26],
return-oriented programming [48], data-oriented program-
ming [25], etc.) significantly impact and help to design secure
systems. We believe EXPRACE also sheds a light on kernel
race exploitation, which is a relatively under-explored vulner-
ability type but emerging threats.
To summarize, this paper makes the following contribu-
tions:
• Analysis of Race Exploitability. We analyzed kernel data
races and found an intrinsic condition inherent to each race
bug, classifying easy-to-exploit races and hard-to-exploit
races.
• Race Exploitation Methods. EXPRACE presents several
new race exploitation methods for modern OSes, includ-
ing Linux, Microsoft Windows, and Mac OS X, against
those hard-to-exploit races. EXPRACE indirectly induces
the kernel to raise various interrupts, which transforms the
hard-to-exploit races into easy-to-exploit races.
• Evaluation with Real-World Races. We used EXPRACE
to exploit ten hard-to-exploit real-world kernel races. Our
evaluation show that EXPRACE can exploit all of those
within 10 to 118 seconds, while a simple brute-force attack
without EXPRACE failed for all in given 24 hours.
The organization of this paper is as follows. §2 analyzes
the race exploitability, and §3 describes the problem scope
and research approaches of EXPRACE. Then §4 provides a
background to understand EXPRACE. §5 presents race ex-
ploitation techniques for the Linux kernel, and §6 presents for
Microsoft Windows and Mac OS X. §8 presents the discus-
sion on EXPRACE. §7 evaluates EXPRACE, and §9 discusses
the related work of this paper. §10 concludes the paper.
2 Exploitability of Kernel Data Races
A kernel data race is a concurrency bug in the kernel, which
happens due to improper synchronization of data in its con-
current accesses. Data races in the kernel are notoriously chal-
lenging to exploit because its runtime behavior is inherently
2364    30th USENIX Security Symposium
USENIX Association
Figure 1: Categorization of kernel data races according to its execution order requirement. Tx and Ty denote the time taken between two
instructions in Syscallx and Syscally, respectively.
non-deterministic (e.g., impacted by core/thread scheduling
orders). Since it involves complex thread interleaving, it is
difficult to understand the root cause and reproduce for debug-
ging. This, in fact, becomes a critical hurdle for adversaries
who want to exploit data races, which is the key motivation
of this paper
In the following, we dive into details of data races from an
exploitation perspective. To this end, we first categorize data
races into two common types [30, 38], a single-variable race,
and a multi-variable race. Then we analyze the exploitability
of each race type to motivate this paper.
2.1 Single-Variable Race
A single variable race is a concurrency bug pattern that an-
other task violates atomicity over a single variable (but not
correctly enforced by the code) in one task.
An example of a single variable race is illustrated in Fig-
2) are running
ure 1-(a), where two tasks (Taskx and Tasky
on its own CPU core. These two tasks invoke Syscallx and
Syscally, respectively. Syscallx’s handler executes an in-
struction B , and Syscally’s handler executes two instructions
A and C . All these three instructions access the same, single
memory variable M. Under this setting, if B overwrites the
variable M in the middle of A and C (i.e., Ty, which denotes
the time taken between two instructions in Syscally), the read
operation in C would get a different value of M compared to
the value read in A . In other words, the correct behavior may
require the atomicity of M over Ty (i.e., the value of M should
not change over Ty), but such atomicity is violated due to B .
Exploiting Single-Variable Race. To exploit the single-
variable race, one needs to precisely control the execution
timing involving two kernel threads, where each kernel thread
corresponds to Taskx and Tasky, respectively, so that the ex-
ecution order is in A ≫ B ≫ C (p ≫ q denotes p hap-
pens before q). Since there is no way to precisely control
kernel threads’ execution order due to the non-deterministic
scheduling behavior, brute-force attacks are typically the only
exploitation option in practice. In other words, the attacker
keeps invoking Syscallx and Syscally from user threads of
Taskx and Tasky, respectively, in hopes that B is executed
within Ty at some point.
Ty
TSyscallx
Hence, the probability of successful exploitation (i.e.,
Psingle) is roughly
, where TSyscallx denotes the time
taken to handle each Syscallx. Here, we focus on capturing
the exploitation probability when invoking a single Syscally.
Thus, we assume that if Syscallx terminates earlier than
Syscally, the same Syscallx invocation keeps being per-
formed until Syscally terminates, which is still a typical
brute-force exploitation strategy. Please note that we do not
consider the case TSyscallx ≤ Ty, because in most of single
variable race condition, TSyscallx is bigger than Ty. Although
Psingle may seem low, it clearly implicates that the exploitation
is feasible with many trials. In fact, the goal of most adver-
saries is completed if taking over the system once. Thus the
brute-force exploitation is effective and sufficient to exploit a
single-variable race. Roughly interpreting the practical impli-
cation of Psingle, the maximum number of TSyscallx is about 1
M cycles, and Ty is about 10 cycles according to our evalua-
tion. Then the brute-force would certainly succeed if Syscally
can be invoked more than 100 K times, which can be mostly
completed within one minute. Taking the real-world exploits
as another example, available privilege escalation exploits
(including CVE-2017-7533 [45], CVE-2017-2636 [44], and
CVE-2016-8655 [43]) succeed the brute-force exploitation
ranging from 5 to 30 seconds.
2In this paper, Task can refer to both a user process (or a heavyweight
user process) or a user thread (or a lightweight user process) if not explicitly
stated. The reason why we use this neutral term Task is that many race cases
are working the same for both the process and thread. For those race cases
showing different restrictions, we will specifically mention which one we
refer to.
2.2 Multi-Variable Race
A multi- variable race violates the atomicity involving mul-
tiple variables. Taking the example in Figure 1-(b), suppose
instruction A and B access the variable M1, and instruction