# CVE-2020-0022 蓝牙漏洞初探（上）一个bug引发的血案
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一. 引言
大家好，我是来自银基TIGER TEAM的Cure。本次为大家带来的是CVE-2020-0022
漏洞研究的第一部分。近年来，蓝牙已成为可移动设备的标配，在手机、智能手表等电子产品的短距离数据传输场景得以广泛应用。蓝牙的传输除依赖硬件芯片之外，还需要相关固件与主机操作系统的支持，而后两者则常常成为RCE（远程代码执行）攻击的标靶。
CVE-2020-0022是一个由于Android 系统在蓝牙传输收包重组过程所存在的代码bug而引发的漏洞。该漏洞对Android
8、9、10均存在影响，对于Android 8、9有潜力引发Memory Leak（内存泄露）和RCE，而对于Android
10则能够引起蓝牙守护进程的崩溃。相关bug可以由2020年2月发布的Android A-143894715号安全补丁进行修复。
笔者在研究该漏洞原理的时候克服了不少困难，并将心得整理成了“CVE-2020-0022 蓝牙漏洞初探”这一系列。本系列分三个部分：
第一部分：一个bug引发的血案  
该部分介绍Android 蓝牙协议的框架，详细分析相关模块的代码原理，并着重分析相关bug，结合demo给出其初步危害。
第二部分：探索Memory Leak  
该部分向更高的目标进发，详细阐述arm64 架构下libc库memcpy函数的实现及其“特殊”行为，并借助这一点结合demo给出相应漏洞下使能Memory
Leak的方法。
第三部分：探索RCE  
该部分进一步升级目标，首先明确RCE的难点所在，并详细介绍对于C++ vtable的攻击方法，并基于此给出相应漏洞下使能RCE的延伸思路。
本文为系列的第一部分，第二、三部分会在后面的时间里逐步为大家呈现。希望本文提供的技术探索与实例，能够起到抛砖引玉的作用；同时，也为初学者提供一些思路与参考。
## 二. 蓝牙相关知识
###  2.1 生活中的蓝牙
蓝牙作为短距离无线网络通信的解决方案，蓝牙已深入人们的生活，其常见应用场景包括但不限于：
1）文件传输，例如在缺少USB线的情况下在笔记本和手机之间传输照片。
2）蓝牙耳机，使能无线地在设备（例如笔记本、MP3）与耳机之间传输音频数据，为用户带来方便。
3）蓝牙打印机，例如使用手机连接打印机而打印文件而不需额外地携带U盘。
4）蓝牙上网，例如当开启“手机热点”，笔记本等设备可以使用手机流量进行上网。其中，笔记本与手机的连接方式可以选择蓝牙。
###  2.2 蓝牙通信架构
笔者在检索、整合相关资料后，绘制的蓝牙设备通信架构图如下所示。
图中，左半部分和右半部分分别代表一个带有蓝牙功能的设备，例如手机。其中，金粉色的矩形框代表了设备中自应用程序至物理总线驱动的软件协议栈，而蓝色部分则代表了蓝牙硬件芯片。
当发生数据交互时，应用程序所提供的数据包，经由各协议层的封装，发送至物理总线并抵达蓝牙芯片。相应固件对数据包进行处理后，载入到无线通信信号中进行传输。
图中的“诸多上层协议层”，在蓝牙上网、蓝牙耳机等不同应用场景具备着多种多样的形式，但由于其与本系列所讨论的漏洞关系不大，故不作进一步展开。图中，标为淡蓝色的L2CAP和HCI的两个协议层，作为绝大多数场景下的统一封装层，是我们较为关注的重点。
###  2.3 分包与重组
L2CAP层和HCI层为绝大多数蓝牙数据传输的I/O路径所共有，本节对其与漏洞相关的工作模式进行简介。
L2CAP层和HCI层在发送和接收的过程中均涉及到数据包的分包与组包，笔者绘制下图以对分包行为进行描述。组包过程作为其逆过程，请读者自行推断。
在发送路径上，上不同的上层协议层传输给L2CAP的数据统称为SDU（Service Data
Unit）。SDU的最大长度可达65536字节，当较大的SDU其进入L2CAP层后，则会触发分段（Segmentation），得到多个较小的数据片段，L2CAP层对每个片段添加L2CAP协议头，封装为PDU数据包并传递至HCI层。当单个PDU进入HCI层，若其大小超过HCI层的限定，则触发分解（Fragmentation），再对得到的每块碎片数据分别添加HCI头，并依次发送至蓝牙控制器。
在接收路径上，相应地，对于蓝牙控制器收到的多个HCI数据包，HCI层需要对其进行重组（与分解对应），得到PDU传递给L2CAP层；类似地，L2CAP层需要对多个PDU进行重组（与分段对应），得到SDU传递给上层协议层。
蓝牙数据传输主要涉及两种链路：SCO（Synchronous）和ACL（Asynchronous
Connectionless），前者常用于同步话音传输，后者主要用于分组数据传送，为本系列所关注。
对于ACL链路，HCI-ACL数据包的格式如下图所示。
其中，PB Flag是Packet Boundary Flag的缩写，该字段占用两个bit，当其数值为00或10时，表征当前HCI包是上层L2CAP
PDU分解所得碎片中的首包；当其数值为01时，表征当前HCI包是上层L2CAP
PDU分解所得碎片中的续包；当其值为11时，表征其封装了一个完整的上层L2CAP PDU。
对于ACL链路，L2CAP PDU的格式如下图所示。
其中，Length描述的是当前L2CAP PDU的数据部分的总长度，而SDU Length描述的是当前L2CAP所属SDU的长度。值得注意的是，L2CAP
SDU字段只存在于部分协议的首个L2CAP数据包。
## 三. 漏洞细节
###  3.1 漏洞概述
CVE-2020-0022漏洞的本质在于，接收端在处理HCI
ACL数据包重组的过程中，存在代码bug，使得相应的memcpy阶段能够向相应缓冲区写入超过预期长度的数据。
这种非法的写入，能够初步地使得执行收包的进程即蓝牙守护进程发生崩溃，在精心构造之下，能够导致内存内容泄露乃至RCE。
本文仅关注通过漏洞引发进程崩溃的情形，其他基于漏洞的进一步攻击方法将在本系列的后续文章中给予阐述。
###  3.2 代码分析
相关代码位于system/bt/hci/src/packet_fragmenter.cc，核心流程即HCI-ACL数据包的重组，对应函数为reassemble_and_dispatch。
**3.2.1 HCI-ACL数据包的初步解析**
蓝牙守护进程对与新接收的HCI-ACL数据包，作初步解析如下图所示。
这里，HCI-ACL数据包在其已有处理过程中被封装为BT_HDR结构，其中，通过packet->data可以得到HCI数据包的起点。
根据前面对HCI ACL数据包结构的分析，有：
① Line 128读取了HCI-ACL数据包的数据长度，即当前HCI-ACL数据包所包含的部分L2CAP PDU的长度，并存入acl_length；
② Line 129读取了L2CAP PDU的前两个字节所含的数字，并存入l2cap_length。若当前HCI-ACL数据包为首个碎片，则l2cap_length即相应L2CAP PDU的数据长度，；
③ Line 127和Line 133读取了HCI-ACL头的handle部分，并提取了当前HCI包是否为对应L2CAP PDU的首个碎片的信息。
**3.2.2 首个HCL-ACL碎片的处理**
若当前HCI-ACL数据包是相应L2CAP PDU的首个碎片，其相关处理流程如笔者所绘制的下图所示。
下面结合代码进行分析。
继数据包的初步解析后，若当前HCI包为首个碎片（Line 136），则l2cap_length为L2CAP
PDU的数据长度，在其基础上添加L2CAP头的长度和HCI-ACL头的长度，即得到封装了整个L2CAP PDU的HCI-ACL数据包的长度，记作full_length。
在确定full_length的合法性（Line 161 ~ Line 178）后，在内存中分配相应BT_HDR结构partial（Line