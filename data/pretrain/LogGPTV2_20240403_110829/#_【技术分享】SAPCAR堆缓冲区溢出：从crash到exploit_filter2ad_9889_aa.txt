# 【技术分享】SAPCAR堆缓冲区溢出：从crash到exploit
|
##### 译文声明
本文是翻译文章，文章来源：coresecurity.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
翻译：[WisFree](http://bobao.360.cn/member/contribute?uid=2606963099)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**一、介绍**
几周之前，我们在SAPCAR中发现了简单的[堆缓冲区溢出漏洞](https://www.coresecurity.com/advisories/sap-sapcar-heap-based-buffer-overflow-vulnerability)。在这篇文章中，我们将会详细讨论该漏洞的技术细节以及漏洞方法。
为此，SAP已经发布了官方安全公告#2441560，并将该问题归类为“潜在的拒绝服务（DoS）”。通过研究发现，我们不仅可以利用这个漏洞来实现代码执行，而且实现起来也相对比较容易。除此之外，我们也希望这篇文章可以让那些对代码利用感兴趣的初学者提供一个很好的参考实例。
在这篇文章中，我们将了解如何通过模糊测试技术来获取到大量崩溃信息，如何找出漏洞的根本成因，以及如何确定漏洞的可利用性。接下来，我们将会使用众所周知的文件指针重写技术来设计出相应的漏洞利用代码。除此之外，本文的最后一章还会给大家介绍glibc
2.24中所采用的漏洞缓解技术细节。
我们认为这是一篇极具教育意义的技术文章，因为如果我们想要对SAP系统管理员发动攻击的话，还需要一种更加可靠的漏洞利用技术。（更多细节请参考4.4章）
**二、SAPCAR**
SAPCAR是一款针对SAR和CAR文档的命令行工具，而这两种文件格式是SAP专用的文档文件格式，SAP通常都会使用这种格式来发布软件或数据包。
本文所介绍的这个漏洞将会影响SAPCAR的v721.510版本，不过其他产品和版本仍然可能会受到影响，但我们现在只对这个特定版本进行测试。
**三、崩溃分析**
我们的起始点是那导致SAPCAR代码发生崩溃的507份文件，这些文件由[@martingalloar](https://twitter.com/martingalloar)慷慨提供，感谢Martin！这些崩溃信息是通过[honggfuzz](https://github.com/google/honggfuzz)（一款fuzzer-模糊测试工具）找到的，fuzzer对文档内容列表功能进行了测试，测试过程中需要使用到命令行参数-tvf。
Honggfuzz所创建的文件名中包含某些与崩溃相关的信息，例如程序计数器注册地址，以及终止进程的信号描述。下面给出的是一个文件示例：
    SIGSEGV.PC.7ffff6d1ef44.STACK.2d9c8e9f0.CODE.1.ADDR.0x8c4ff0.INSTR.movdqu_-0x50()%rsi),%xmm5.fuzz.verified
在对崩溃记录进行了简单的分析之后，我们发现PC（程序计数器）值重复了很多次，这表明单独的崩溃事件数量可能比崩溃文件的数量要少，也就是相同的崩溃事件可能多次出现。单独PC地址的准确数量可以通过下列命令确定：
    $ ls | cut -d '.' -f 3 | uniq | wc -l
    13
这是一个非常好的消息，因为我们只用处理13个不同的崩溃点，而不是一开始的507个。
**3.1 对崩溃信息进行分类**
接下来我们要做的就是确定每一个输入文件导致代码发生崩溃的原因。对于那13个崩溃点，我们只需要在程序运行时绑定一个调试器（Debugger），然后在程序发生崩溃时检查寄存器和内存情况，而且这种方法也适用于输入文件数量较大的情况。
幸运的是，网上有很多工具可以帮助我们完成这些工作。其中一个是一款针对gdb的名叫[exploitable](https://github.com/jfoote/exploitable)的插件，这款插件可以根据严重性和可利用性对崩溃进行分类。为了保证分类结果的有效性，它使用了一系列启发式算法来分析被调试程序的运行状态。
[exploitable](https://github.com/jfoote/exploitable)插件仍然会要求我们通过gdb来运行每一个崩溃文件。为了让整个过程通过自动化的方式实现，我们还需要使用到这款名叫[Crashwalk](https://github.com/bnagy/crashwalk)（由Ben
Nagy开发）的实用工具。虽然它使用的是相同的gdb插件，但它可以简化整个分析过程，并允许我们以多种形式访问分析结果。安装步骤如下：
    $ git clone https://github.com/bnagy/crashwalk.git
    $ sudo apt-get install golang-go
    $ export GOPATH=$HOME/crashwalk/
    $ go get -u github.com/bnagy/crashwalk/cmd/...
    $ mkdir src
    $ git clone https://github.com/jfoote/exploitable.git src/exploitable
不过Crashwalk在选取文件名的时候存在一些问题，因此我们需要对崩溃文件进行快速重命名，以此来避免文件名中存在特殊字符，然后保证工具的正常运行：
    $ ./crashwalk/bin/cwtriage -root crashes/ -match lala -- ./sapcar_721.510_linux_x86_64 -tvf @@
cwtriage将会输出每一个崩溃文件的分析结果，并将分析数据默认保存在crashwalk.db数据库中，我们可以使用cwdump命令来查询这个数据库。
输出结果包括对漏洞可利用性的分类，当然了，分类的准确性还不能保证，因为这个结果只是exploitable插件使用启发式算法得出的，但我们可以根据这个结果来确定需要分析的漏洞顺序。由于我们真正感兴趣的是如何利用那些可利用的漏洞，所以我们首先要查询crashwalk数据库来获取那些可利用的漏洞：
    $ ./crashwalk/bin/cwdump crashwalk.db | sed -n -e '/Classification: EXPLOITABLE/,/END SUMMARY/ p'
    Classification: EXPLOITABLE
    Hash: f5c06ffc7aa3f42a736f4bb7ea700ef9.5f3bf91c3626b65747adc8881231d81b
    Command: ./sapcar_721.510_linux_x86_64 -tvf crashes/lala4
    Faulting Frame:
       None @ 0x000000000040c58b: in /home/ubuntu/sapcar_721.510_linux_x86_64
    Disassembly:
    Stack Head (7 entries):
       __GI__IO_unsave_markers   @ 0x00007ffff6bc092a: in /lib/x86_64-linux-gnu/libc-2.23.so (BL)
       _IO_new_file_close_it     @ 0x00007ffff6bbd872: in /lib/x86_64-linux-gnu/libc-2.23.so (BL)
       _IO_new_fclose            @ 0x00007ffff6bb13ef: in /lib/x86_64-linux-gnu/libc-2.23.so (BL)
       None                      @ 0x000000000040c58b: in /home/ubuntu/sapcar_721.510_linux_x86_64
       None                      @ 0x000000000041958b: in /home/ubuntu/sapcar_721.510_linux_x86_64
       None                      @ 0x000000000042bc43: in /home/ubuntu/sapcar_721.510_linux_x86_64
       None                      @ 0x000000000043fc66: in /home/ubuntu/sapcar_721.510_linux_x86_64
    Registers:
    rax=0x00000000005a8594 rbx=0x00000000005a8594 rcx=0x00007fffffffcb00 rdx=0x0000000000008000 
    rsi=0x00007ffff6f07b28 rdi=0x00000000005a8594 rbp=0x0000000000000000 rsp=0x00007fffffffcac8 
     r8=0x0000000000a1c770  r9=0x0000000000000000 r10=0x0000000000000477 r11=0x00007ffff6bb1260 
    r12=0x0000000000000000 r13=0x00007ffff0000920 r14=0x0000000000a3070d r15=0x000000000000000e 
    rip=0x00007ffff6bc092a efl=0x0000000000010202  cs=0x0000000000000033  ss=0x000000000000002b 
     ds=0x0000000000000000  es=0x0000000000000000  fs=0x0000000000000000  gs=0x0000000000000000 
    Extra Data:
       Description: Access violation on destination operand
       Short description: DestAv (8/22)
       Explanation: The target crashed on an access violation at an address matching the destination operand of the instruction. This likely indicates a write access violation, which means the attacker may control the write address and/or value.
    ---END SUMMARY---
我个人非常喜欢[gdb-peda](https://github.com/longld/peda)插件，所以我将会在接下来的测试过程中使用到它。当然了，你也可以使用例如[gef](https://github.com/hugsy/gef)和[pwndbg](https://github.com/pwndbg/pwndbg)这样的工具，但我目前还没有尝试使用过它们。
通过gdb来运行SAPCAR代码之后，我们将得到下列输出：
    [----------------------------------registers-----------------------------------]
    RAX: 0x5a8594 (sub    ecx,esi)
    RBX: 0x5a8594 (sub    ecx,esi)
    RCX: 0x7fffffffcb00 --> 0x5a8594 (sub    ecx,esi)
    RDX: 0x8000 
    RSI: 0x7ffff6f07b28 --> 0xa2dc30 --> 0x7ffff6f06260 --> 0x0 
    RDI: 0x5a8594 (sub    ecx,esi)
    RBP: 0x0 
    RSP: 0x7fffffffcaf8 --> 0x7ffff6bbd872 (:    test   BYTE PTR [rbx+0x74],0x20)
    RIP: 0x7ffff6bc092a (:    mov    QWORD PTR [rdi+0x60],0x0)
    R8 : 0xa2dc40 --> 0xa304e0 --> 0x0 
    R9 : 0x0 
    R10: 0x477 
    R11: 0x7ffff6bb1260 (:    push   r12)
    R12: 0x0 
    R13: 0x7ffff0000920 --> 0x474e5543432b2b00 ('')
    R14: 0xa3056d --> 0x20000000 ('')
    R15: 0xe
    EFLAGS: 0x10202 (carry parity adjust zero sign trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0x7ffff6bc0920 :    cmp    QWORD PTR [rdi+0x60],0x0
       0x7ffff6bc0925 :    mov    rax,rdi
       0x7ffff6bc0928 :    je     0x7ffff6bc0932 
    => 0x7ffff6bc092a :    mov    QWORD PTR [rdi+0x60],0x0
       0x7ffff6bc0932 :    mov    rdi,QWORD PTR [rax+0x48]
       0x7ffff6bc0936 :    test   rdi,rdi
       0x7ffff6bc0939 :    je     0x7ffff6bc0965 
       0x7ffff6bc093b :    test   DWORD PTR [rax],0x100
    [------------------------------------stack-------------------------------------]
    0000| 0x7fffffffcaf8 --> 0x7ffff6bbd872 (:    test   BYTE PTR [rbx+0x74],0x20)
    0008| 0x7fffffffcb00 --> 0x5a8594 (sub    ecx,esi)
    0016| 0x7fffffffcb08 --> 0x7fffffffcb50 --> 0x7fffffffcfe0 --> 0x7fffffffe1d0 --> 0x7fffffffe3b0 --> 0x5af800 (mov    QWORD PTR [rsp-0x18],rbx)
    0024| 0x7fffffffcb10 --> 0xa30510 ("sapevents.dll")
    0032| 0x7fffffffcb18 --> 0x7ffff6bb13ef (:    mov    edx,DWORD PTR [rbx])
    0040| 0x7fffffffcb20 --> 0xa1c790 --> 0xa2dc60 --> 0xa30520 --> 0x20 (' ')
    0048| 0x7fffffffcb28 --> 0x7fffffffcb50 --> 0x7fffffffcfe0 --> 0x7fffffffe1d0 --> 0x7fffffffe3b0 --> 0x5af800 (mov    QWORD PTR [rsp-0x18],rbx)
    0056| 0x7fffffffcb30 --> 0xa30510 ("sapevents.dll")
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    Stopped reason: SIGSEGV
    __GI__IO_unsave_markers (fp=fp@entry=0x5a8594) at genops.c:1065
有趣的地方在于，指向FILE结构的指针通常会在堆内存中出现问题。不过在我们的测试过程中，它指向的是文本部分中的某个位置：
    gdb-peda$ vmmap 0x5a8594
    Start              End                Perm    Name
    0x00400000         0x007c9000         r-xp    /home/ubuntu/sapcar_721.510_linux_x86_64
找到了该文件指针的位置并检查了周围内存区域之后，我们可以看到这些数据与输入文件内容非常相似：
    gdb-peda$ find 0x5a8594
    Searching for '0x5a8594' in: None ranges
    Found 1 results, display max 1 items:
     [heap] : 0xa1d8d0 --> 0x5a8594 (sub    ecx,esi)
    gdb-peda$ x/16xg 0xa1d8d0 - 64