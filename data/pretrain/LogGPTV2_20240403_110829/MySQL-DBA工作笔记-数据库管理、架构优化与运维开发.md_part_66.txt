道到底发生了什么，
路径有很大的差别，如果想让命令更通用，
可用，但是到了 UNIX 下却并不买账。比如 awk，grep 在 SunOS，AIX，Linux下对应的
在后期需要改进时，就很容易把握。
为好，适当加入一些相关的注释和说明。有些精简的命令可以加一些特定的描述，这样
复杂的功能。
令来完成一个很复杂的工作。有些人喜欢通过一些很简单的操作来组合起来，完成一个
但是如果脚本的维护和后期的改进不是你一个人来完成的话，最好还是有一些规范
对于这个部分，需要大家自己把握一个度，可能有些人喜欢用一个很“精简”的命
8．动态脚本
如果你已经沉淀了不少的功能集，可以考虑把它们整合到函数库中，在以后的处理
7.函数库
对于脚本中的数据和文件处理，
then
elif [
then
if [ $MachineType = SunOS ] 
可以考虑通过 Shell 脚本来生成一些特定功能的 Shell 脚本。比如：使用动态变量进
完成一些复杂的功能时，可以考虑使用动态脚本来实现。
如果大家在UNIX、
5．适用的平台
4．命令的简化和功能的简化
export
export
export
export
export
export
export
export
export
export
export AWK=/usr/xpg4/bin/awk
志
 $MachineType = AIX
TR=/usr/bin/tr
AWK=/bin/awk
AWK=/usr/bin/awk
TR=/usr/xpg4/bin/tr
TR=/usr/bin/tr
GREP=
而且对于问题排查时是极为重要的。
=/usr/xpg4/bin/grep
Linux
下写过一些脚本，
最好还是有一些详尽的日志；没有日志，谁也不知
，可以考虑下面的形式。
可能会发现有一些命令的选项在Linux
---
## Page 443
的功能很强大。
个舍入的运算，在Oracle中就是ceilO函数实现的功能。
样在操作的时候更容易理解。
用 sed/awk 来完成。
识也需要补补。有很多的功能可能通过一些文件处理能够实现，但是有时候就很容易使
数据的校验和错误的处理都是需要格外关注的，毕竟软件的很多细节都是成败的关键。
节都没有做校验，在复杂的场景中就很容易出错，如果要写一个比较完善的脚本，那么
pages_float=^echo "scale=2 ; 100 / 3 "|bc
SQL> select ceil(100/3) from dual;
抛砖引玉一下，
sed+awk在 Shell 脚本的编写中有很重要的作用，使用的过程中正则表达式的一些知
pages_
your message is :this is a test
cat test.sh
可以使用read 来引入一些输入参数的值，加入一些提示信息。
10．强大的工具集 sed+awk
使用 Shell 则需要类似下面的一些转换和处理，当然了，在文件的处理方面，Shell
使用一个简单的 SQL 就马上得到期望的结果。
使用Shell做数据运算，和其他编程语言相比，感觉还是比较吃力的，比如我想做一
12.充分利用其他工具的功能集
[orallg@racl
在写脚本的时候，
11．交互性
ls-llawk‘{print$9
可以这样来写：
脚本的编写过程中，可能大家经常忽略的就是一些数据的校验功能，可能有很多细
9．完整的数据校验和容错处理
http://blog.itpub.net/23718752/viewspace-1210639/
34
echo
num=`echo
input
your message:
~]S
比如我想对当前目录下的文件，输出文件名都添加一个后缀.abc。
有一些参数需要输入，
ksh testa.sh
(660+)uu)0s6=
，我们可以提供一些可读性的提示信息。这
第11章运维开发基础|421
---
## Page 444
422|MySQLDBA工作笔记：数据库管理、架构优化与运维开发
然后全量刷新，这样我们就知道哪些信息做了刷新，优点是思路很清晰，做没做一目
不是完整，准确。大体有以下三个维度：
贯穿起来，其中有一个点很重要，也是我们容易忽略的：有些元数据我们也无法确认是
11.2.3
提升还是很有帮助的。
现也是一个 Shell脚本，可以通过阅读脚本逻辑来强化 Shell能力。
好的方式，如果使用一个命令就能够搞定最好。
器去免密码登录，我需要给他开通这些服务器的访问权限，常规思路如下：
操作复杂度就高了，我们可以对这个场景做一些优化改进。比如我们使用的都是中控机
11.2.2如何快速建立服务器之间的 ssh 互信
对于MySQL 元数据建设，可以从主机、实例、业务、集群几个维度来完善，把流程
cat ~/.ssh/id_rsa.pub Issh 10.12.1.1 "cat - >> ~/.ssh/authorized_keys"
首先复制.ssh/id_rsa.pub 到目标服务器，比如目标服务器是10.12.1.1，则命令为：
在服务器之间建立 ssh 互信的操作很普遍，但是如果服务器的规模和数量巨大，这个
(3）目前系统中已经过期的信息（比如系统下线，但是元数据没有及时变更)
（2）目前系统中错误的实例信息
（1）目前系统中遗漏的实例信息
上面三种方式都是经过检验还不错的方法，能简化繁琐重复的工作，对运维能力的
ssh 10.12.1.1 "cat - >> ~/.ssh/authorized_keys" > ~/.ssh/authorized_keys
然后 ssh 登录到目标端，执行：
scp .ssh/id_rsa.pub root@10.12.1.1:~
所以意识到这个问题之后，我们需要采取行动来完善。一种方式是全量的扫描，
因为数据是收上来了，但是到底差了多少，目前来说还无法判断。
3通过Shell 脚本抽取MySQL 实例信息
---
## Page 445
的样子。
如果实例是比较规范的，可能得到的结果是一个比较规整的格式，看起来会有些单调
从哪个维度得到呢，推荐是从实例维度。
的业务等信息，其实这些信息是一些概要的信息，
触发的。
做数据流转。不应该是系统来反向主动抓取，一来有延迟，二来效率也不高。
维护也是类似的道理，比较优雅的方式是通过客户端主动推送，或者通过流程的方式来
房子的需求，再去找中介，这个事情的效率和价值就会是指数级的提升。元数据的信息
来的不一样。
即刷新那些确实变化的，那么一个问题就出来了，我们怎么知道扫描抓取的信息和原
去租房子，中介反复来问你，要不要租房子，你肯定也会烦；但是如果你明确了需要租
了然，但是缺点也很明显，有些控制过度了；另外一种方式是全量扫描，增量刷新，
实例维度我拆分了如下图11-4所示的属性，
由此我们可以明确几个信息，数据抽取是必要的，数据抽取应该是周期性或者主动
”所以主动抓取的方式不是很“优雅”，而且对业务的依赖和侵入性较高，打个比方你
当然如果不规整，配置存在较大差异的，可能会是如下图11-5 这种情况。
一般来说，
4306
4306
4306
4306
4306
开票
开周
开福
，我们印象中的实例信息，基本都是CPU，内存等的系统属性，加上归属
1024
8192
4096
10240
4096
15936
7913
5.7.16.10
57.16-10.
OFF
ON
图11-4
能够得到一个实例相对全面的信息。
如果我们想得到一些更细粒度的信息，
u9
12431
38
12424
162
306
None
None
None
None
None
None
7
3
第11章运维开发基础|423
ROABMTED
ROARMTED
READNTED
COMETED
COAMMTED
ROARMTED
CEADRITED
1024
1024
1024
1024
76G
---
## Page 446
424丨MySQLDBA工作笔记：数据库管理、架构优化与运维开发
的业务。如果某些业务平常的日增长数据在1000M,结果有一天突然爆发增长到了4000M,
周期之后偏移量未发生任何变化，则可以断定没有任何数据的写入，很可能是一个空跑
些业务属于僵尸业务，可以通过分析binlog 的偏移量来得到一个初步判断，如果在一个
11.2.4
直观了。
别、内存大小、redo大小、数据量大小。对于单机多实例的情况，查看信息就非常方便
是否开启、数据目录、字符集、server_id,数据库版本、binlog 日志保留天数、事务隔离级
utf820257225.7.16-10-1og
utf8 2025721
utf8
理解，相比原地踏步来说，改进的效果要好很多。
量小于 buffer_pool_size 等等。
server_id的配置不规范，binlog 的保留周期太短，redo太小，事务隔离级别不统一，数据
抽取了数据库层级的信息之后，我们可以基于已有的数据做一些深入分析，比如哪
列的含义分别是：端口、socket 文件路径、是否开启 binlog、buffer_pool大小、GTID
5724/data/mysql
这种感觉就跟你登山一般，如果你用全新的视角来看待已有的事物，绝对会有新的
5722
输出结果类似于：
脚本内容可以参考开源项目github:https://github.com/jeanron100/mysql_devops。
从这些信息里面，我们可以挖掘出很多待改进的信息，比如内存配置不够合理，
723
4312
使用 Shell脚本抽取MySQL 表属性信息
430
/data/mysql
东开临
512
8192
220
7857
5852
55.190g
5.7.16.10
5.5.19-g
log
OFF
OFF
OFF
图11-5
268435456 OFF
26843
268435456OFF
16080
16080
t8mb2130
8mb41944311
456
t8mb4
fermb4134240
1024
17157
OFF
1024
/data/mysql_5724/data/
/data/mysql_5723/data/
/data/mysql_5722/data/
3
None
None
None
REAMTED
RCEARTE
RCOAMATED
REAMANTED
REPEALE.
128
1024
1024
1.10
1.1G
18G
---
## Page 447
一些操作演示。
取和管理；而对数据架构操作则是通过常见的数据结构（如列表，字典和集合等）进行
结构操作两个部分来进行总结。对于文件管理主要是基于文件的路径，文件属性进行提
11.3.1
Python 资源。
维开发计划，很多技术知识点都是在碰到了问题之后查看文档或者博客得到解决方法的。
而是以 Python 语言作为开启运维开发的一个入口。
11.3
碎片率等。
础信息，对于表中的碎片分析，则是通过和系统层结合来得到的。
而这个很可能是我们 DBA 同学目前比较容易忽视的。
现，从设计上就可以改进和完善，为后期的问题排查也提供一种参考思路。；
率很高，表中的索引过度设计等，这些对于业务来说是很欢迎的，因为如果能够及时发
这是对于业务探索的第一步。
则这种情况我们可以基于建立的模型来做出响应，但这些信息在系统层面是无法感知的。
为了避免采集到的表数量过多，目前是优先采集数据量在100M以上的表，然后分析
对于Python 的基础，发现还是有很多基础需要巩固，我们计划分为文件管理和数据
本小节中我们会通过几个实例来串联一些知识点，当然我也会推荐一些实用的
我写了一个初版的采集脚本，会基于数据字典information_schema.tables 采集一些基
所以简而言之，表属性的收集是一个很细粒度的工作，虽然琐碎，但是非常重要，
除此之外，还会有某些表数据量太大，某些表数据增长过于频繁，某些表中的碎片
'/root/test'
>>>os.getcwd()
得到当前的所在的路径。
>>> import os
我们先来看一下文件管理的部分。
对于 Python 的学习是一个持续的过程，你完全不用先完整的学完 Python 再开始你的运
1．文件管理
同时限于篇幅，我们不会逐一的介绍Python 开发的完整技术体系，主要原因如下：
我们一说到运维开发语言，基本上就是在说Python了，语言之争我们不在此讨论，
Python基础和数据结构
运维开发必修技：Python 开发
第11章运维开发基础丨425
---
## Page 448
426丨MySQL DBA工作笔记：数据库管理、架构优化与运维开发
redis
>>> os.path.basename ('/root/test')
返回 path 中的子文件夹。
返回 path 中的文件名。
得到当前的路径，
返回当前 path 的文件夹。
>>> os.path.dirname ('/root')
返回指定 path 的文件夹部分。