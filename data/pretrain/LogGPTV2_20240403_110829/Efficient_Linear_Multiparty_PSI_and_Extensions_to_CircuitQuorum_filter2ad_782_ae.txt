(3) Invoking the F ğœ
wPSM
B2A
EQ
ğ‘– , resp., and receive the additive shares âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1 and âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘– resp., as outputs.
ğ‘ƒ1 and ğ‘ƒğ‘– send their inputs âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ
(4) Invoking the F Fğ‘
1 and âŸ¨ğ‘’ğ‘ğ‘– ğ‘—âŸ©ğµ
(5) Converting to (ğ‘›, ğ‘¡) shares: For each ğ‘— âˆˆ [ğ›½],
â€¢ ğ‘ƒ1 computes âŸ¨ğ‘ ğ‘—âŸ©1 =ğ‘›
ğ‘–=2âŸ¨ğ‘“ğ‘– ğ‘—âŸ©1 and for each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘ƒğ‘– sets âŸ¨ğ‘ ğ‘—âŸ©ğ‘– = âŸ¨ğ‘“ğ‘– ğ‘—âŸ©ğ‘–.
ğ‘—
â€¢ ğ‘ƒ1, Â· Â· Â· , ğ‘ƒğ‘› compute [ğ‘ ğ‘—] â† ConvertSharesğ‘›,ğ‘¡ (âŸ¨ğ‘ ğ‘—âŸ©).
(6) Computing shares of intersection: For each ğ‘— âˆˆ [ğ›½],
â€¢ Compute [ğ‘£ (0)
] = [ğ‘ ğ‘—] âˆ’ ğ‘› + 1.
â€¢ For each ğ‘– âˆˆ [ğ‘‘], compute [ğ‘£ (ğ‘–)
â€¢ Let [ğ‘(0)
â€¢ For ğ‘– âˆˆ [ğ‘˜], compute [ğ‘(ğ‘–)
â€¢ Compute [ğ‘ ğ‘—] = 1 âˆ’ [ğ‘(ğ‘˜)
â€¢ ğ‘ƒ1 inputs {[ğ‘ ğ‘—]1} ğ‘— âˆˆ[ğ›½] and Table1. For ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, ğ‘ƒğ‘– inputs {[ğ‘ ğ‘—]ğ‘–} ğ‘— âˆˆ[ğ›½].
â€¢ All parties receive the output ğ‘‡ .
] â† MultFğ‘›,ğ‘¡ ([ğ‘(ğ‘–âˆ’1)
].
] â† MultFğ‘›,ğ‘¡ ([ğ‘£ (ğ‘–âˆ’1)
] = [ğ‘£ (ind0)
], [ğ‘£ (indğ‘–)
], [ğ‘£ (ğ‘–âˆ’1)
]).
]).
].
ğ‘—
ğ‘—
ğ‘—
ğ‘—
ğ‘—
ğ‘—
ğ‘—
ğ‘—
ğ‘—
(7) Computing the circuit ğ¶ğ›½,ğœ,ğ‘: The parties invoke the FMPC functionality parameterized ğ¶ğ›½,ğœ,ğ‘ by as follows:
Figure 6: CIRCUIT PSI PROTOCOL
(Sec. 2.3.1), boolean to arithmetic share conversion F Fğ‘
B2A
2.3.2), and the ğ‘›-party functionalities from Section 2.5.
(Section
We consider standard multiparty functionality FMPC that is pa-
rameterized by a circuit ğ¶. The circuit ğ¶ takes as inputs ğ¼ğ‘– from
each ğ‘ƒğ‘–, for ğ‘– âˆˆ [ğ‘›] and the functionality computes the circuit ğ¶
on these inputs and returns ğ¶(ğ¼1, Â· Â· Â· , ğ¼ğ‘›). In our construction, to
evaluate a symmetric function ğ‘“ , we consider the circuit ğ¶ğ›½,ğœ,ğ‘,
which takes as inputs {[ğ‘ ğ‘—]ğ‘–} ğ‘— âˆˆ[ğ›½] from ğ‘ƒğ‘– for each ğ‘– âˆˆ [ğ‘›] such
that ğ‘ ğ‘— âˆˆ Fğ‘ and ğ‘1, . . . , ğ‘ğ›½ âˆˆ {0, 1}ğœ from ğ‘ƒ1, computes {ğ‘ ğ‘—} ğ‘— âˆˆ[ğ›½]
by reconstructing the shares, and computes ğ‘‡ = ğ‘“
.
ğ‘ ğ‘—
We set things up such that ğ‘ ğ‘— = 1, if ğ‘ ğ‘— âˆˆ âˆ©ğ‘›
ğ‘–=1ğ‘‹ğ‘–; else ğ‘ ğ‘— = 0. Next,
give an overview and describe the protocol formally in Figure 6.
Protocol Overview. On input ğ‘‹ğ‘– from party ğ‘ƒğ‘–, for each ğ‘– âˆˆ [ğ‘›],
the protocol proceeds in seven steps: The first two steps of the
protocol, namely the Hashing and Invoking the F ğ›½,ğœ,ğ‘
wPSM functionality,
are same as Steps 2 and 3 of our mPSI protocol (Figure 4). At the
end of these steps, ğ‘ƒ1 holds Table1 of ğ›½ bins containing one element
(cid:32) 
ğ‘— âˆˆ[ğ›½]:ğ‘ ğ‘— =1
(cid:33)
each and other parties ğ‘ƒğ‘–â€™s hold Tableğ‘– with ğ›½ bins of arbitrary size.
Moreover, for each ğ‘– âˆˆ {2, . . . , ğ‘›} and ğ‘— âˆˆ [ğ›½], ğ‘ƒ1 holds ğ‘¦ğ‘– ğ‘— âˆˆ {0, 1}ğœ
and ğ‘ƒğ‘– holds ğ‘¤ğ‘– ğ‘— âˆˆ {0, 1}ğœ such that ğ‘¦ğ‘– ğ‘— = ğ‘¤ğ‘– ğ‘— iff Table1[ ğ‘—] âˆˆ
Tableğ‘–[ ğ‘—] (except with negligible probability). Now, in the next step,
the parties check whether this equality holds or not. Formally, in
Step 3, for each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, parties ğ‘ƒ1 and ğ‘ƒğ‘– invoke the F ğœ
EQ
functionality with inputs ğ‘¦ğ‘– ğ‘— and ğ‘¤ğ‘– ğ‘—, respectively and receive as
outputs, the boolean shares7.
Rest of the steps are executed for each bin ğ‘— independently. In
Step 4, for each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}, parties ğ‘ƒ1 and ğ‘ƒğ‘– invoke the F Fğ‘
B2A
functionality to convert the boolean shares to additive shares over
Fğ‘, where ğ‘ > ğ‘› is a prime. Next, in Step 5, parties convert these
additive shares between ğ‘ƒ1 and ğ‘ƒğ‘– for ğ‘– âˆˆ [ğ‘›]\{1} to (ğ‘›, ğ‘¡)-shares of
values ğ‘ ğ‘— such that ğ‘ ğ‘— denotes the number of parties in [ğ‘›]\{1} that
have the element stored at Table1[ ğ‘—]. In Step 6, the task is to securely
compute shares of whether ğ‘ ğ‘— = ğ‘› âˆ’ 1 or not. Let ğ‘£ ğ‘— = ğ‘ ğ‘— âˆ’ (ğ‘› âˆ’ 1).
7We note that these four steps of our protocol together follow the blueprint of executing
a circuit PSI protocol [16, 26, 45, 64â€“66] between ğ‘ƒ1 and ğ‘ƒğ‘– (for each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}),
while ensuring a consistent mapping of elements of ğ‘ƒ1 (via Cuckoo hashing into
Table1) across all instantiations. To explicitly spell out this consistent hashing, we
make a whitebox use of the circuit-PSI blueprint from [65].
Session 4C: Private Set Intersection CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1189ğ‘—
Now, using property of fields with prime order, ğ‘£ ğ‘— = 0 (and hence,
ğ‘ ğ‘— = ğ‘› âˆ’ 1) if and only if ğ‘£ğ‘âˆ’1
= 0. For this, parties first compute
for ğ‘– âˆˆ {0} âˆª [ğ‘‘] where ğ‘‘ = âŒˆlog ğ‘âŒ‰ âˆ’ 1 (requiring ğ‘‘
shares of ğ‘£2ğ‘–
ğ‘—
calls to MultFğ‘›,ğ‘¡) and then multiply shares of appropriate powers
of ğ‘£ ğ‘— (requiring at most ğ‘‘ calls to MultFğ‘›,ğ‘¡). Then, parties locally
compute shares of ğ‘ ğ‘— = 1 âˆ’ ğ‘£ğ‘âˆ’1
. It holds that ğ‘ ğ‘— is 1 if and only if
ğ‘ ğ‘— = ğ‘› âˆ’ 1.
Finally, parties invoke FMPC functionality for circuit ğ¶ğ›½,ğœ,ğ‘ (de-
scribed above) with shares of ğ‘ ğ‘— and Table1[ ğ‘—], for all ğ‘— âˆˆ [ğ›½].
ğ‘—
Remark. The well-known/standard definition of circuit-PSI [13,
45, 64â€“66] outputs shares of 0/1 values (ğ‘ ğ‘—) and these are given
as input to the circuit ğ¶ğ›½,ğœ,ğ‘. We compute the same in step 6 of
our protocol because it offers the flexibility to compute arbitrary
functions. However, circuits for certain functions might themselves
involve computing equality checks on ğ‘ ğ‘—â€™s. For such functions, one
can consider an optimization wherein ğ¶ğ›½,ğœ,ğ‘ takes shares of ğ‘ ğ‘—, for
all ğ‘— âˆˆ [ğ›½] (computed in step 5 of the protocol) as input and ğ¶ğ›½,ğœ,ğ‘
checks if ğ‘ ğ‘— = ğ‘› âˆ’ 1 to determine if the corresponding element is
in the intersection. On the other hand, many functions, such as
cardinality of intersection, can be computed by adding the ğ‘ ğ‘— values
and no additional equality checks are needed in ğ¶ğ›½,ğœ,ğ‘.
4.2 Correctness and Security Proof
Theorem 4.1. The protocol in Figure 6 securely realizes F ğ‘›,ğ‘š,ğ‘“
Câˆ’PSI in
the F -hybrid model, where F = (F ğ›½,ğœ,ğ‘
, ConvertSharesğ‘›,ğ‘¡ , F ğœ
EQ,
wPSM
F Fğ‘
B2A, MultFğ‘›,ğ‘¡), against a semi-honest adversary corrupting ğ‘¡ < ğ‘›/2
parties. Our protocol has total communication at most 2ğ‘šğ‘›(ğœ†ğœ… +
36(log ğ‘›)2)with at most 4âŒˆlog ğ‘›âŒ‰ + âŒˆlog ğœâŒ‰ + 6 rounds.

ğ‘— âˆˆ[ğ›½]:ğ‘ ğ‘— =1
Table1[ ğ‘—] and ğ‘Œâˆ— =
Proof. Correctness: Let ğ‘Œ =
ğ‘–=1ğ‘‹ğ‘–. For statistical correctness, we need to show that ğ‘‡ = ğ‘“ (ğ‘Œâˆ—)
âˆ©ğ‘›
with all but negligible probability in ğœ…. By correctness of the FMPC
(parameterized by the circuit ğ¶ğ›½,ğœ,ğ‘) functionality, whenever ğ‘Œ =
ğ‘Œâˆ— we have ğ‘‡ = ğ¶(Table1, {ğ‘ ğ‘—} ğ‘— âˆˆ[ğ›½]) = ğ‘“ (ğ‘Œ) = ğ‘“ (ğ‘Œâˆ—). So it suffices
to upper bound the probability of ğ‘Œâˆ— â‰  ğ‘Œ. For the rest of the proof
we assume that cuckoo hashing by ğ‘ƒ1 succeeds which happens with
probability at most 1 âˆ’ 2âˆ’41.
As we will see later, steps 3â€“6 do not lead to correctness error of
our protocol. We make a few observations about these steps below,
that will be used in both lemmata that follow. For each ğ‘— âˆˆ [ğ›½],
â€¢ (Step 3) By correctness of F ğœ
EQ
â€¢ (Step 4) By correctness of F Fğ‘
B2A
â€¢ (Step 5) By correctness of ConvertSharesğ‘›,ğ‘¡, ğ‘ ğ‘— =
â€¢ (Step 6) First, ğ‘£ (0)
correctness of MultFğ‘›,ğ‘¡ for every ğ‘– âˆˆ [ğ‘‘], it holds that ğ‘£ (ğ‘–)
(ğ‘£ ğ‘—)2ğ‘– and ğ‘(ğ‘˜)
Now, using the property of finite fields, we get that ğ‘(ğ‘˜)
ğ‘–=2
= ğ‘ ğ‘— âˆ’ (ğ‘› âˆ’ 1). Also, let ğ‘£ ğ‘— = ğ‘£ (0)
= 0, and
consequently, ğ‘ ğ‘— = 1, if and only if ğ‘£ ğ‘— = 0. Hence, ğ‘ ğ‘— = 1 if and only
if ğ‘ ğ‘— = ğ‘› âˆ’ 1. This in turn implies that ğ‘’ğ‘ğ‘– ğ‘— = 1 for all ğ‘– âˆˆ {2, . . . , ğ‘›}.
ğ‘“ğ‘– ğ‘— < ğ‘›.
. Next, by
ğ‘— â‰¡
, for each ğ‘– âˆˆ [ğ‘›] \ {1}, ğ‘’ğ‘ğ‘– ğ‘— equals
, for each ğ‘– âˆˆ [ğ‘›] \ {1}, ğ‘“ğ‘– ğ‘— = ğ‘’ğ‘ğ‘– ğ‘—.
1 when ğ‘¦ğ‘– ğ‘— = ğ‘¤ğ‘– ğ‘— and 0 otherwise.
. Finally, ğ‘ ğ‘— = 1 âˆ’ ğ‘(ğ‘˜)
= ğ‘£ğ‘âˆ’1
ğ‘—
ğ‘›
ğ‘—
ğ‘—
ğ‘—
.
ğ‘—
ğ‘—
To conclude, we have shown that ğ‘ ğ‘— = 1 if and only if ğ‘’ğ‘ğ‘– ğ‘— = 1 for
all ğ‘– âˆˆ {2, . . . , ğ‘›}. We now prove the following two lemmata.
Lemma 4.2. ğ‘Œâˆ— âŠ† ğ‘Œ .
Proof. Let ğ‘’ = Table1[ ğ‘—] âˆˆ ğ‘Œâˆ—. Therefore, for each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›},
by the definition of simple hashing ğ‘’ âˆˆ Tableğ‘–[ ğ‘—]. Hence by correct-
ness of F ğ›½,ğœ,ğ‘
guarantees that ğ‘¦ğ‘– ğ‘— = ğ‘¤ğ‘– ğ‘— (and hence ğ‘’ğ‘ğ‘– ğ‘— = 1) for
each ğ‘– âˆˆ {2, Â· Â· Â· , ğ‘›}. Using what we show above, we get that in this
wPSM
case ğ‘ ğ‘— = 1 and hence, ğ‘’ âˆˆ ğ‘Œ.
â–¡
Lemma 4.3. ğ‘Œ âŠ† ğ‘Œâˆ— with probability at least 1 âˆ’ 2âˆ’ğœ…âˆ’1.
Proof. Suppose ğ‘’ = Table1[ ğ‘—] âˆ‰ ğ‘Œâˆ—. Since ğ‘’ âˆ‰ ğ‘Œâˆ—, let ğ‘–âˆ— âˆˆ
{2, Â· Â· Â· , ğ‘›} be such that ğ‘’ âˆ‰ ğ‘‹ğ‘–âˆ—. We now show that ğ‘’ âˆ‰ Tableğ‘–âˆ—[ ğ‘—]
with the following disjoint and exhaustive scenarios.
â€¢ ğ‘’ âˆˆ ğ‘‹1: Since ğ‘’ âˆ‰ ğ‘‹ğ‘–âˆ— and any dummy elements inserted by ğ‘ƒğ‘–âˆ—
are distinct from real elements, it holds that ğ‘’ âˆ‰ Tableğ‘–âˆ—[ ğ‘—].
â€¢ ğ‘’ âˆ‰ ğ‘‹1: Then, ğ‘’ is a dummy element inserted by ğ‘ƒ1. Since dummy
elements of ğ‘ƒâˆ—
ğ‘– are distinct from dummy elements of ğ‘ƒ1, it holds
that ğ‘’ âˆ‰ Tableğ‘–âˆ—[ ğ‘—].
Since ğ‘’ âˆˆ ğ‘Œ, it holds that ğ‘ ğ‘— = 1 and hence, ğ‘’ğ‘ğ‘–âˆ— ğ‘— = 1, i.e., ğ‘¦ğ‘–âˆ— ğ‘— = ğ‘¤ğ‘–âˆ— ğ‘—.
Now, probability that ğ‘¦ğ‘–âˆ— ğ‘— = ğ‘¤ğ‘–âˆ— ğ‘— when ğ‘’ âˆ‰ Tableğ‘–âˆ— is at most 2âˆ’ğœ.
Note that this is the probability that Table1[ ğ‘—] âˆˆ ğ‘Œ\ğ‘Œâˆ—. By union
bound over all bins it holds that with probability at least 1 âˆ’ ğ›½2âˆ’ğœ
the set ğ‘Œ\ğ‘Œâˆ— is empty.
â–¡
Hence, except with failure probability at most 2âˆ’ğœ… (that includes
the probability of cuckoo hashing failure), the output of the protocol