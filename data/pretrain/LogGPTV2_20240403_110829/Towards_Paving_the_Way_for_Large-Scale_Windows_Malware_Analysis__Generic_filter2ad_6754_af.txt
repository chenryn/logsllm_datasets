(e.g.,“WriteFile”). So BinUnpack has to perform IAT comparison
frequently. Overall, BinUnpack only brings marginal overhead to
benign program execution.
8.3 Hook-evasion Resistance Evaluation
In addition to high runtime overhead, the lack of anti-analysis
resistance is another reason to limit the application of generic un-
packing. In this section, we evaluate the capacity of BinUnpack’s
hook-evasion resistance with a classical user-level API monitor
(Detours [33]) and two prevalent sandboxes that provide API hook-
ing service (CWSandbox [101] and Cuckoo Sandbox [71]). The test
data contains the known packers from Table 1, which lists com-
mon hook evasions adopted by packers. Besides, we modify the
source code of UPX to represent another three evasions: Custom
Loader [57], Stealth Loader [39], and DLL integrity check. Custom
Loader [57] implements the functionality of “LoadLibrary” and
“GetProcAddress”, which avoids explicitly calling these two APIs.
Stealth Loader [39] avoids calling “NtMapViewOfSection” and maps
a DLL into non-file-mapped memory. DLL integrity check is used
19http://www.alexa.com
Session 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada406to detect whether the dll loaded in memory is modified. Fortunately,
BinUnpack has countermeasures to defeat all of these evasions.
The evaluation results are summarized in Appendix Table 7. For
child process and process hollowing evasions, CWSandbox and
Cuckoo can deal with them because these sandboxes recursively
hook APIs in child processes. But Detours is process-specific, and it
needs to inject code into the target process space. Except BinUnpack,
the left API monitors identify target APIs by matching the virtual
addresses where these APIs are expected to locate. Therefore, stolen
code technique can make them miss the target. As Detours and
the two sandboxes do not implement exception handlers perfectly,
crash hooking module is particularly effective to impede all of them.
In addition, both Custom Loader [57] and Stealth Loader [39] are
able to circumvent user-level API hooking. By contrast, the design
of kernel-level DLL hijacking and fast binary function matching
technique [87] enable BinUnpack to resist to these stealthy hook
evasions. Furthermore, only BinUnpack is resilient to DLL inte-
grity check. Other three API monitors also have to patch the DLL
loaded in memory. Section 7.2 has discussed the countermeasure
we have taken to bypass DLL integrity checking; that is, we adopt
Shadow Walker rootkit [90] to forward the data access of custom
DLL to the target DLL. Strong hook-evasion resistance explains
why BinUnpack exhibits much broader unpacking scope, and our
approach also provides a new way to develop resilient API monitor
in sandbox.
8.4 Unpacking Wild Packed Malware
The high performance of BinUnpack enables us to perform a large-
scale evaluation. We test BinUnpack on 238, 835 packed malware
samples we have collected. BinUnpack succeeds in 97.3% of samples,
and each unpacking can be completed within 0.5 second for most
cases. The reason for the left 2.7% failures is either the binary code
is not executable or the unpacking routine exits early. After further
investigation, we find some custom packers attempt to detect the
involvement of human by checking the movement of mouse cursor.
If the positions of mouse cursor are not changed, the packer will
consider itself is under monitoring and exit early.
The big challenge to this experiment is that we do not have the
ground truth (e.g., source code or the binary code with no packer)
for most samples. We apply two statistic measures from the pre-
vious work to assess whether BinUnpack can recover the original
code: entropy deviation [55] and “code-to-data” ratio [86]. The byte
entropy value examines the randomness in binary code, and it has
been used to efficiently recognize packed binary [4, 54, 55, 74]. If
the sample is being compressed or encrypted, the entropy value
is typically high. According to PinDemonium’s evaluation [55], a
entropy deviation value of 0.4 between the unpacked version and
the packed version is sufficient to verify the correct process dump.
Another measure comes from Eureka [86], as the code-to-data ratio
would increase when a malware sample unpacks itself. Eureka uses
the threshold of 0.5 to determine the end of unpacking.
We did not select these two measures by accident. They are com-
plementary to each other, because the attempts to lower the entropy
value will increase code-to-data ratio eventually [99]. As shown in
Figure 8(a), all of the entropy deviations are beyond the threshold
0.4. The deviation value is from 0.61 to 0.96 with the average va-
lue 0.93. For “code-to-data” ratio evaluation (Figure 8(b)), 99.1% of
packed malware’s ratio ranges from 0.0 to 0.03, and the remaining
0.9%’s ratio is from 1.1 to 4.5, which is far above the threshold 0.5.
We further study these outliers and find that they are packed by
Armadillo or SoftwarePassport. Unlike other packers, these two
packers did not apply any instruction-level obfuscation. Instead,
they use double processes to mislead unpackers. However, these
outlier packed samples still exhibit a high entropy value. Figure 8(c)
shows the VirusTotal detection numbers for the packed malware,
the outputs of BinUnpack, and their differences, respectively. Af-
ter BinUnpack’s preprocessing, there are 7 to 19 extra anti-virus
scanners (the average number is 18) are able to recognize that mal-
ware. Our evaluation demonstrates the effectiveness of BinUnpack
against wild packed malware.
9 RELATED WORK
Several previous work has confirmed that erasing the IAT of original
code is common in packers [17, 44, 82, 86, 97]. However, the work to
utilize IAT rebuilding for unpacking and resist to various evasions
at the same time is rare. We have discussed the status quo of generic
unpacking techniques in Section 2 and compared the recent tools
in Section 8.1. This section focuses on other related work.
The latest talk [100] raises three concerns on malware unpacking,
and they fits our motivations perfectly: 1) researchers often underes-
timate the complexity of packers; 2) anti-virus products often report
false alarms when scanning packed benign programs; 3) the perva-
sive packed malware has severely limited the accuracy of machine
learning. Therefore, advanced generic unpacking is desperately
necessary. The recent work studies the common ways used by mal-
ware to detect the existence of a DBI tool and develops an anti-DBI
resistant unpacker [76]. However, the overhead is still quite high,
and it cannot handle the process hollowing technique. Xabier et al.
customize multi-path exploration techniques on packed code [98].
The purpose is to trigger the unpacking routine that checks run-
time environment. We believe BinUnpack can also benefit from
multi-path exploration to execute the hidden unpacking routine.
Debray et al. try to extract the unpacking routine code instead of
original code [18], which can provide insight to the mechanism of
custom packers.
Another related direction is DLL hijacking and its prevention.
DLL hijacking [79] is originally designed for malicious component
loading, and several methods have been proposed to prevent DLL
hijacking. Taeho Kwon and Zhendong Su [46, 47] present an auto-
matic technique to detect unsafe component loadings. Their tool
profiles an application’s dynamic loading behaviour via hooking
the APIs that are used to load component. These APIs include
“LdrLoadDLL”, “LdrpLoadDll”, and “LdrpMapDll”, which we have
introduced in the Figure 10. Byungho Min and Vijay Varadhara-
jan [61, 62] propose a cross verification mechanism for secure
execution and dynamic component loading. They also hook the
APIs including “LdrLoadDLL” to monitor the dynamic loading beha-
viour. All of these DLL hijacking prevention work assume that DLL
hijackers can not enter the OS kernel. In contrast, our work studies
how to use DLL hijacking for defense purpose, and the available
resources for defenders are rich. For example, BinUnpack can enter
Session 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada407(a) Entropy Value
(b) Code-to-Data Ratio
(c) VirusTotal Detection Number
Figure 8: The cumulative distribution result of unpacking wild packed malware.
the OS kernel to hook native APIs. Therefore, using these DLL
hijacking prevention mechanisms to defeat BinUnpack becomes
increasingly difficult.
10 DISCUSSION & CONCLUSION
The prototype of BinUnpack has several limitations. First, we find
some custom packers can evade BinUnpack by detecting the mo-
vement of mouse cursor. Our next work is to create an artificial,
realistic environment that can simulate how users interact with
OS. Like other work [44, 49, 55], we find some unpacked code can
not function correctly. The reason is IAT obfuscation such as API
redirection [39] renders the rebuilt IAT incomplete. Our current
design only needs to make sure that the rebuilt IAT is different
from unpacking routine IAT. However, accurately reconstructing
the whole IAT requires heavyweight data flow analysis. We leave
it as our future work. Another interesting direction is to study the
feasibility of applying BinUnpack’s idea to Linux malware [16].
Packed malware in circulation is a tremendous amount. The
existing generic unpacking tools are limited by the high overhead
and lack of anti-analysis resistance. In this paper, we develop a no-
vel unpacking approach, BinUnpack, which is based on capturing
the “rebuilt-then-called” feature instead of “written-then-executed”
memory. BinUnpack’s design is free from tedious memory access
tracing and results in very small runtime overhead. To withstand
anti-hooking tricks, we develop BinUnpack’s API monitor module
by kernel-level DLL hijacking. Our large-scale experiments demon-
strate the efficacy and generality of BinUnpack.
11 ACKNOWLEDGMENTS
We thank the ACM CCS 2018 anonymous reviewers for their valu-
able feedback. This research was supported in part by the Natural
Science Foundation of Hubei Province of China grant 2017CFB307,
the National Natural Science Foundation of China grants (U1636107,
61373168, 61332019, and 61672394), the National Key R&D Program
of China (2017YF-B0802903), Project 2117H14243A, and Sichuan
Province Research and Technology Supporting Plan. Jiang Ming
was also supported by UT System STARs Program.
REFERENCES
[1] Aguila. 2016. Scylla - x64/x86 Imports Reconstruction. https://github.com/
NtQuery/Scylla. (2016).
[2] Anonymous Author. 2004. Hooking Windows API - Technics of hooking API
[3] Piotr Bania. 2009. Generic Unpacking of Self-modifying, Aggressive, Packed
functions on Windows. The CodeBreakers Journal 1, 2 (2004).
Binary Programs. https://arxiv.org/abs/0905.4581. (2009).
[4] Munkhbayar Bat-Erdene, Taebeom Kim, Hyundo Park, and Heejo Lee. 2017.
Packer Detection for Multi-Layer Executables Using Entropy Analysis. Entropy
19, 3 (2017).
[5] Ulrich Bayer, Paolo Milani Comparetti, Clemens Hlauschek, Christopher Kruegel,
and Engin Kirda. 2009. Scalable, Behavior-Based Malware Clustering. In Procee-
dings of the 16th Network and Distributed System Security Symposium (NDSS’09).
Ransomware attack still
looms in Australia as Government warns WannaCry threat not over.
http://www.abc.net.au/news/2017-05-15/ransomware-attack-to-hit-victims-
in-australia-government-says/8526346. (May 16 2017).
[6] Henry Belot and Stephanie Borys. 2017.
[7] Leyla Bilge, Andrea Lanzi, and Davide Balzarotti. 2011. Thwarting Real-time
Dynamic Unpacking. In Proceedings of the Fourth European Workshop on System
Security (EUROSEC’11).
[8] Lutz Böhne. 2008. Pandora’s Bochs: Automatic unpacking of malware. University
of Mannheim 6 (2008).
[9] Guillaume Bonfante, Jose Fernandez, Jean-Yves Marion, Benjamin Rouxel, Fabrice
Sabatier, and Aurélien Thierry. 2015. CoDisasm: Medium Scale Concatic Disas-
sembly of Self-Modifying Binaries with Overlapping Instructions. In Proceedings
of the 22nd ACM SIGSAC Conference on Computer and Communications Security
(CCS’15).
[10] Denis Bueno, Kevin J. Compton, Karem A. Sakallah, and Michael Bailey. 2013.
Detecting Traditional Packers, Decisively. In Proceedings of the 16th International
Symposium on Research in Attacks, Intrusions, and Defenses (RAID’13).
[11] Alexei Bulazel and Bülent Yener. 2017. A Survey On Automated Dynamic Malware
Analysis Evasion and Counter-Evasion: PC, Mobile, and Web. In Proceedings of
the 1st Reversing and Offensive-oriented Trends Symposium.
[12] Jamie Butler and Kris Kendal. 2007. Blackout: What really happened. Black Hat
USA. (2007).
[13] Joan Calvet and Pierre-Marc Bureau. 2010. Understanding Swizzor’s Obfuscation
Scheme. REcon 2010. (2010).
[14] Joan Calvet, Fanny Lalonde Lévesque, Jose M. Fernandez, Erwann Traourouder,
Francois Menet, and Jean-Yves Marion. 2015. WaveAtlas: surfing through the
landscape of current malware packers. Virus Bulletin Conference. (2015).
[15] Cisco. 2017. Cisco 2017 Midyear Cybersecurity Report. https://www.cisco.com/
c/m/en_au/products/security/offers/annual-cybersecurity-report-2017.html.
(2017).
[16] Emanuele Cozzi, Mariano Graziano, Yanick Fratantonio, and Davide Balzarotti.
2018. Understanding Linux Malware. In Proceedings of the 39th IEEE Symposium
on Security and Privacy (S&P’18).
[17] DataRescue. 2005. Using the Universal PE Unpacker Plug-in included in IDA Pro
4.9 to unpack compressed executables. https://www.hex-rays.com/products/ida/
support/tutorials/unpack_pe/unpacking.pdf. (2005).
[18] Saumya Debray and Jay Patel. 2010. Reverse Engineering Self-Modifying Code:
Unpacker Extraction. In Proceedings of the 17th Working Conference on Reverse
Engineering (WCRE’10).
[19] Artem Dinaburg, Paul Royal, Monirul Sharif, and Wenke Lee. 2008. Ether: Mal-
ware Analysis via Hardware Virtualization Extensions. In Proceedings of the 15th
ACM Conference on Computer and Communications Security (CCS’08).
[20] Ken Dunham and Egan Hadsell. 2011. Malcode Context of API Abuse. SANS
Institute InfoSec Reading Room. (2011).
[21] Peter Ferrie. 2008. Anti-unpacker tricks. Virus Bulletin. (2008).
[22] Stephen Fewer. 2013. Reflective DLL Injection. https://github.com/stephenfewer/
ReflectiveDLLInjection. (2013).
01234567050k100k150k200k250kNumber of Packed Malware Packed Unpacked Difference0123456050k100k150k200k250k Packed  Unpacked Difference010203040506070050k100k150k200k250k Packed Dumped  DifferenceSession 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada408Blog. (2017).
[23] Halvar Flake. 2004. Structural comparison of executable objects.. In Proceedings
of the 2004 GI International Conference on Detection of Intrusions & Malware, and
Vulnerability Assessment (DIMVA’04).
[24] Jianming Fu, Xinwen Liu, and Binling Cheng. 2011. Malware behavior Capturing
based on Taint Propagation and Stack Backtracing. In Proceedings of the 10th
IEEE International Conference on Trust, Security and Privacy in Computing and
Communications (TrustCom’11).
[25] Gabriela Limon Garcia. 2007. Forensic physical memory analysis: an overview of
tools and techniques. In TKK T-110.5290 Seminar on Network Security. 305–320.
[26] Joseph Gardiner, Marco Cova, and Shishir Nagaraja. 2014. Command & Control:
Understanding, Denying and Detecting. arXiv CoRR abs/1408.1136 (2014). http:
//arxiv.org/abs/1408.1136
[27] Emre Güler. 2017. Anti-Sandboxing Techniques in Cerber Ransomware. VMRay
[28] Fanglu Guo, Peter Ferrie, and Tzi-Cker Chiueh. 2008. A Study of the Packer
Problem and Its Solutions. In Proceedings of the 11th International Symposium on
Recent Advances in Intrusion Detection (RAID’08).
[29] Irfan Ul Haq, Sergio Chica, Juan Caballero, and Somesh Jha. 2017. Malware
Lineage in the Wild. arXiv:1710.05202 [cs.CR]. (2017).
[30] Ashkan Hosseini. 2017. Ten Process Injection Techniques: A Technical Survey of
Common and Trending Process Injection Techniques. Endpoint Security Blog.
(2017).
[31] Xin Hu, Sandeep Bhatkar, Kent Griffin, and Kang G. Shin. 2013. MutantX-S:
Scalable Malware Clustering Based on Static Features. In Proceedings of the 2013
USENIX Conference on Annual Technical Conference (USENIX ATC’13).
[32] Xin Hu, Tzi cker Chiueh, and Kang G. Shin. 2009. Large-scale malware indexing
using function-call graphs. In Proceedings of the 16th ACM conference on Computer
and Communications Security (CCS’09).
[33] Galen Hunt and Doug Brubacher. 1999. Detours: Binary interception of win32
functions. In 3rd Usenix Windows NT Symposium.
//www.huorong.cn/doc/introduce_engine.pdf. (2017).
[34] Huorong Network. 2017. The Introduction to Huorong Anti-Virus Engine. http:
[35] Ryoichi Isawa, Masakatu Morii, and Daisuke Inoue. 2016. Comparing Malware
Samples for Unpacking: A Feasibility Study. In Proceedings of the 11th Asia Joint
Conference on Information Security.
[36] Min Gyung Kang, Pongsin Poosankam, and Heng Yin. 2007. Renovo: A hidden
code extractor for packed executables. In Proceedings of the 5th ACM Workshop
on Recurring Malcode (WORM’07).
[37] Yuhei Kawakoya, Makoto Iwamura, and Mitsutaka Itoh. 2010. Memory behavior-
based automatic malware unpacking in stealth debugging environment. In Pro-
ceedings of the 5th International Conference on Malicious and Unwanted Software
(MALWARE’10).
[38] Yuhei Kawakoya, Makoto Iwamura, Eitaro Shioji, and Takeo Hariu. 2013. API
Chaser: Anti-analysis Resistant Malware Analyzer. In Proceedings of the 16th In-
ternational Symposium on Research in Attacks, Intrusions, and Defenses (RAID’13).
[39] Yuhei Kawakoya, Eitaro Shioji, Yuto Otsuki, Makoto Iwamura, and Takeshi
Yada. 2017. Stealth Loader: Trace-Free Program Loading for API Obfuscation. In
Proceedings of the 20th International Symposium on Research in Attacks, Intrusions,
and Defenses (RAID’17).
[40] Hyung Chan Kim, Tatsunori ORII, Katsunari Yoshioka, Daisuke Inoue, Jungsuk
Song, Masashi ETO, Junji Shikata, Tsutomu Matsumoto, and Koji Nakao. 2011.
An Empirical Evaluation of an Unpacking Method Implemented with Dynamic
Binary Instrumentation.
IEICE TRANSACTIONS on Information and Systems
E94-D, 9 (2011).
New Breed of Cerber Ransomware Employs
https://www.cyphort.com/new-breed-of-cerber-
[41] Paul Kimayong. 2017.
Anti-Sandbox Armoring.
ransomware-employs-anti-sandbox-armoring. (2017).
[42] Dhilung Kirat and Giovanni Vigna. 2015. MalGene: Automatic Extraction of
Malware Analysis Evasion Signature. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security (CCS’15).
[43] Eugene Kolodenker, William Koch, Gianluca Stringhini, and Manuel Egele. 2017.
PayBreak: Defense Against Cryptographic Ransomware. In Proceedings of the
2017 ACM on Asia Conference on Computer and Communications Security (ASIA
CCS’17).
[44] David Korczynski. 2016. RePEconstruct: reconstructing binaries with self-
modifying code and import address table destruction. In Proceedings of the 11th
International Conference on Malicious and Unwanted Software (MALWARE’16).
[45] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna. 2004. Static Disassembly
of Obfuscated Binaries. In Proceedings of the 13th USENIX Security Symposium
(USENIX Security’04).
[46] Taeho Kwon and Zhendong Su. 2010. Automatic Detection of Unsafe Component
Loadings. In Proceedings of the 19th International Symposium on Software Testing
and Analysis (ISSTA’10).
[47] Taeho Kwon and Zhendong Su. 2012. Automatic detection of unsafe dynamic
component loadings.
IEEE Transactions on Software Engineering 38, 2 (2012),
293–313.