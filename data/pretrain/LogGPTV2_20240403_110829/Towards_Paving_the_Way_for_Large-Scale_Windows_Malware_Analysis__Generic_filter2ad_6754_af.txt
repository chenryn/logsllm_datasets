### 8.3 Hook-Evasion Resistance Evaluation

In addition to high runtime overhead, the lack of anti-analysis resistance is another factor limiting the application of generic unpacking. In this section, we evaluate BinUnpack’s hook-evasion resistance using a classical user-level API monitor (Detours [33]) and two prevalent sandboxes that provide API hooking services (CWSandbox [101] and Cuckoo Sandbox [71]). The test data includes known packers from Table 1, which lists common hook evasions adopted by packers. Additionally, we modified the source code of UPX to implement three other evasions: Custom Loader [57], Stealth Loader [39], and DLL integrity check. 

- **Custom Loader [57]**: Implements the functionality of “LoadLibrary” and “GetProcAddress,” thereby avoiding explicit calls to these APIs.
- **Stealth Loader [39]**: Avoids calling “NtMapViewOfSection” and maps a DLL into non-file-mapped memory.
- **DLL Integrity Check**: Detects whether the DLL loaded in memory has been modified.

Fortunately, BinUnpack has countermeasures to defeat all of these evasions. The evaluation results are summarized in Appendix Table 7. For child process and process hollowing evasions, CWSandbox and Cuckoo can handle them because these sandboxes recursively hook APIs in child processes. However, Detours is process-specific and requires code injection into the target process space. Except for BinUnpack, the remaining API monitors identify target APIs by matching the virtual addresses where these APIs are expected to be located. Therefore, the stolen code technique can make them miss the target. Since Detours and the two sandboxes do not implement exception handlers perfectly, crash hooking modules are particularly effective in impeding all of them. Both Custom Loader [57] and Stealth Loader [39] can circumvent user-level API hooking. In contrast, BinUnpack's design, which uses kernel-level DLL hijacking and fast binary function matching [87], enables it to resist these stealthy hook evasions. Furthermore, only BinUnpack is resilient to DLL integrity checks. Other API monitors must patch the DLL loaded in memory. Section 7.2 discusses the countermeasure we have taken to bypass DLL integrity checking, which involves using the Shadow Walker rootkit [90] to forward data access from the custom DLL to the target DLL. This strong hook-evasion resistance explains why BinUnpack exhibits a much broader unpacking scope and provides a new way to develop resilient API monitors in sandboxes.

### 8.4 Unpacking Wild Packed Malware

BinUnpack's high performance allows us to perform large-scale evaluations. We tested BinUnpack on 238,835 packed malware samples. BinUnpack succeeded in 97.3% of the samples, with each unpacking typically completed within 0.5 seconds. The 2.7% failure rate is due to either the binary code being non-executable or the unpacking routine exiting prematurely. Further investigation revealed that some custom packers attempt to detect human involvement by checking the movement of the mouse cursor. If the cursor position remains unchanged, the packer assumes it is under monitoring and exits early.

A significant challenge in this experiment is the lack of ground truth (e.g., source code or the binary code without the packer) for most samples. To assess whether BinUnpack can recover the original code, we applied two statistical measures from previous work: entropy deviation [55] and "code-to-data" ratio [86]. Entropy value examines the randomness in binary code and has been used to efficiently recognize packed binaries [4, 54, 55, 74]. Compressed or encrypted samples typically have high entropy values. According to PinDemonium’s evaluation [55], an entropy deviation of 0.4 between the unpacked and packed versions is sufficient to verify the correct process dump. Eureka [86] uses a threshold of 0.5 for the "code-to-data" ratio to determine the end of unpacking.

These two measures were chosen because they complement each other; attempts to lower the entropy value will eventually increase the "code-to-data" ratio [99]. As shown in Figure 8(a), all entropy deviations exceed the threshold of 0.4, ranging from 0.61 to 0.96 with an average of 0.93. For the "code-to-data" ratio evaluation (Figure 8(b)), 99.1% of packed malware ratios range from 0.0 to 0.03, while the remaining 0.9% have ratios from 1.1 to 4.5, far above the threshold of 0.5. Further study of these outliers revealed that they are packed by Armadillo or SoftwarePassport. Unlike other packers, these two do not apply instruction-level obfuscation but use double processes to mislead unpackers. However, these outlier packed samples still exhibit high entropy values. Figure 8(c) shows the VirusTotal detection numbers for the packed malware, the outputs of BinUnpack, and their differences. After BinUnpack's preprocessing, there are 7 to 19 additional antivirus scanners (with an average of 18) able to recognize the malware. Our evaluation demonstrates the effectiveness of BinUnpack against wild packed malware.

### 9. Related Work

Several previous studies have confirmed that erasing the IAT of the original code is common in packers [17, 44, 82, 86, 97]. However, utilizing IAT rebuilding for unpacking while resisting various evasions simultaneously is rare. We discussed the status quo of generic unpacking techniques in Section 2 and compared recent tools in Section 8.1. This section focuses on other related work.

The latest talk [100] raises three concerns about malware unpacking that align with our motivations: 1) researchers often underestimate the complexity of packers; 2) antivirus products frequently report false alarms when scanning packed benign programs; 3) the prevalence of packed malware severely limits the accuracy of machine learning. Therefore, advanced generic unpacking is essential. Recent work has studied common ways malware detects the presence of a DBI tool and developed an anti-DBI resistant unpacker [76]. However, the overhead is still high, and it cannot handle process hollowing. Xabier et al. customized multi-path exploration techniques on packed code [98] to trigger the unpacking routine that checks the runtime environment. We believe BinUnpack can also benefit from multi-path exploration to execute hidden unpacking routines. Debray et al. tried to extract the unpacking routine code instead of the original code [18], providing insights into the mechanisms of custom packers.

Another related direction is DLL hijacking and its prevention. DLL hijacking [79] was originally designed for malicious component loading, and several methods have been proposed to prevent it. Taeho Kwon and Zhendong Su [46, 47] presented an automatic technique to detect unsafe component loadings. Their tool profiles an application’s dynamic loading behavior by hooking APIs such as “LdrLoadDLL,” “LdrpLoadDll,” and “LdrpMapDll.” Byungho Min and Vijay Varadhara-jan [61, 62] proposed a cross-verification mechanism for secure execution and dynamic component loading, also hooking APIs like “LdrLoadDLL” to monitor dynamic loading behavior. These DLL hijacking prevention works assume that DLL hijackers cannot enter the OS kernel. In contrast, our work explores how to use DLL hijacking for defensive purposes, with rich resources available for defenders. For example, BinUnpack can enter the OS kernel to hook native APIs, making it increasingly difficult to defeat BinUnpack using these DLL hijacking prevention mechanisms.

### 10. Discussion & Conclusion

The prototype of BinUnpack has several limitations. First, some custom packers can evade BinUnpack by detecting the movement of the mouse cursor. Our next step is to create an artificial, realistic environment that simulates user interactions with the OS. Like other work [44, 49, 55], we find that some unpacked code may not function correctly due to IAT obfuscation, such as API redirection [39], which renders the rebuilt IAT incomplete. Our current design ensures that the rebuilt IAT differs from the unpacking routine IAT, but accurately reconstructing the entire IAT requires heavyweight data flow analysis, which we leave for future work. Another interesting direction is to study the feasibility of applying BinUnpack’s ideas to Linux malware [16].

Packed malware in circulation is vast, and existing generic unpacking tools are limited by high overhead and a lack of anti-analysis resistance. In this paper, we developed a novel unpacking approach, BinUnpack, which captures the "rebuilt-then-called" feature instead of "written-then-executed" memory. BinUnpack’s design avoids tedious memory access tracing, resulting in minimal runtime overhead. To withstand anti-hooking tricks, we developed BinUnpack’s API monitor module using kernel-level DLL hijacking. Our large-scale experiments demonstrate the efficacy and generality of BinUnpack.

### 11. Acknowledgments

We thank the anonymous reviewers of ACM CCS 2018 for their valuable feedback. This research was supported in part by the Natural Science Foundation of Hubei Province of China (grant 2017CFB307), the National Natural Science Foundation of China (grants U1636107, 61373168, 61332019, and 61672394), the National Key R&D Program of China (2017YF-B0802903), Project 2117H14243A, and the Sichuan Province Research and Technology Supporting Plan. Jiang Ming was also supported by the UT System STARs Program.

### References

[References listed here as in the original text]

This version of the text is more structured, clear, and professional, with improved readability and coherence.