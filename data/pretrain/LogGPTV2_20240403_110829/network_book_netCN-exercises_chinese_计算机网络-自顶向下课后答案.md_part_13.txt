|-|-|-|-|-|
|||x|y|z|
||x|0|3|4|
|从|y|3|0|6|
||z|4|6|0|
P9、不，这是因为降低链路成本不会导致循环(由该链路的两个节点之间的下一跳关系引起)。将两个节点连接到一个链路相当于将链路重量从无限降到有限权。
P10、在每一步中，节点距离向量的每一次更新都是基于Bellman-Ford方程，即只减少距离向量中的这些值。价值没有增加。如果没有更新，则不会发送消息。因此，D(X)是不增加的。由于这些代价是有限的，那么最终距离向量将稳定在有限的步骤。
P11、
a)
| | |
|-|-|
|Router z |Informs w, Dz(x)=$\infty$|
| |Informs y, Dz(x)=6 |
|Router w |Informs y, Dw(x)=$\infty$|
|| Informs z, Dw(x)=5 |
|Router y |Informs w, Dy(x)=4 |
|| Informs z, Dy(x)=4 |
b) 是的，会有一个数不胜数到无穷大的问题。下表显示了路由收敛过程。假设在t0时间发生链路成本更改。在时间T1，y更新其距离向量并通知邻居w和z。在下表中，“$\to$”表示“通知”。
|time |t0 |t1 |t2 |t3 |t4 |
|-----|---|---|---|---|---|
|Z | $\to$ w, Dz(x)=$\infty$||No change |$\to$ w, Dz(x)=$\infty$||
||$\to$y, Dz(x)=6|||$\to$y, Dz(x)=11 ||
|W|$\to$y, Dw(x)=$\infty$||$\to$y, Dw(x)=$\infty$| |No change |
||$\to$z,Dw(x)=5||$\to$z,Dw(x)=10 ||
|Y|$\to$w, Dy(x)=4 |$\to$w, Dy(x)=9 ||No change|$\to$w, Dy(x)=14 |
||$\to$z, Dy(x)=4 |$\to$z, Dy(x)=$\infty$|||$\to$z, Dy(x)=$\infty$|
我们看到w，y，z在计算路由器x的开销时形成一个循环。如果我们继续上面表中所示的迭代，那么在T27，z通过它与x的直接联系检测到它对x的最小成本是50。在T29，w通过z得知它对x的最小成本为51。在t30，y将其最小成本更新为52(通过w)。最后，在T31，没有更新，路由是稳定的。
|time |t27 |t28 |t29 |t30 |t31|
|-----|----|----|----|----|---|
|Z |$\to$w, Dz(x)=50 ||||via w, $\infty$|
||$\to$y, Dz(x)=50|||| via y, 55 |
||||||via z, 50 |
|W ||$\to$y, Dw(x)= |$\to$y, Dw(x)=51 ||via w, $\infty$|
||| $\to$z, Dw(x)=50 |$\to$z, Dw(x)= $\infty$ ||via y, $\infty$|
||||||via z, 51 |
|Y| |$\to$w, Dy(x)=53| |$\to$w, Dy(x)= $\infty$ |via w, 52 |
|| |$\to$z, Dy(x)= $\infty$ ||$\to$z, Dy(x)= 52 |via y, 60 |
||||||via z, 53 |
c)切断y和z之间的连接。
P12、由于在BGP、循环中从AS到目的地都提供了完整的路径信息检测是简单的-如果BGP对等体接收到包含自己的AS号的路由AS路径，然后使用该路由将导致环路。
P13、选择的路径不一定是最短的路径.回顾一下，在路线选择过程中有许多问题需要考虑。由于经济原因，较长的无环路路径很可能比较短的无环路路径更可取。例如，AS可能更愿意将流量发送给一个邻居，而不是另一个距离较短的邻居。
P14、
a) eBGP 
b) iBGP 
c) eBGP 
d) iBGP 
P15、
a)I1，因为这个接口开始从1D到网关路由器1c的最低成本路径。
b)I2。这两种路由都有相等的路径长度，但I2开始的路径有最近的下一跳路由器。
c)一.1。I1开始具有最短路径的路径。
P16、C迫使B在东海岸将所有B的流量移交给D的方法之一是C只在东海岸通过其东海岸凝视点登出其到D的路线。
P17、
![avater](./img/8.png)
在上述解决方案中，X不知道AC链路，因为X没有接收到包含AC链路的w或y的广告路由(即，X在到达目的地的路径上没有接收包含A和AS C的广告。
P18、BitTorrent文件共享和Skype P2P应用程序。考虑一个BitTorrent文件共享网络，其中对等点1、2和3分别位于存根网络W、X和Y中。由于BitTorrent的文件共享机制，使得Peer 2有可能从Peer 1中获取数据块，然后将这些数据块转发到3，这相当于最终被发送到存根网络Y的B转发数据。
P19、A应该建议B两条路线，A-W和A-V。
A应该只向C建议一条路线，A-V。
C作为路径接收：B-A-W、B-A-V、A-V。
P20、由于Z想要传输Y的流量，Z将以这种方式向Y发送路由广告。这样，当Y有一个发送到可以通过Z到达的IP的数据报时，Y将可以选择通过Z发送该数据报。但是，如果Z将路由转发到Y，Y可以将这些路由重登到X。因此，在这种情况下，Z无法阻止从X到Z的传输。
P21、请求响应模式通常会有更多的开销(以交换消息的数量来衡量)，原因有几个。首先，经理收到的每一条信息都需要两条消息：投票和响应。陷阱只向发送方生成一条消息。如果管理器只希望在发生条件时才得到通知，那么轮询的开销就会更大，因为许多轮询消息可能表明等待条件尚未发生。陷阱只在条件发生时生成消息。
在发生事件时，陷阱还会立即通知经理。使用轮询，管理器需要等待半个轮询周期(平均)，从事件发生到经理(通过其轮询消息)发现事件已经发生。
如果丢失了陷阱消息，托管设备将不会发送其他副本。如果一个投票消息或它的响应丢失了，经理就会知道已经丢失了一条消息(因为答复永远不会到达)。因此，如果需要，经理可以重新投票。
P22、通常，最需要网络管理的时间是在压力时，网络可能会严重拥挤，数据包正在丢失。在TCP上运行SNMP时，TCP的拥塞控制将导致SNMP在网络管理器需要发送SNMP消息时退出并停止发送消息。
[Back to Index](#目录)
# 第六章
## 复习题6 
R1、交通方式，如汽车、公共汽车、火车、汽车。
R2、虽然每个链路保证通过链路发送的IP数据报将在链路的另一端无错误地被接收，但不能保证IP数据报将以适当的顺序到达最终目的地。使用IP，同一TCP连接中的数据报可以在网络中采取不同的路由，从而导致出现故障。仍然需要TCP以正确的顺序向应用程序的接收端提供字节流。此外，IP可能由于路由循环或设备故障而丢失数据包。
R3、帧：IP和TCP中也有帧；链路访问；可靠传递：TCP中也有可靠的传递；流控制：TCP中也有流控制；错误检测：IP和TCP中也有错误检测；错误更正；全双工：TCP也是全双工。
R4、当一个节点正在发送时，它将开始从另一个节点接收一个分组，这将发生冲突。
R5、时隙ALOHA：1、2和4(时隙ALOHA仅部分分散，因为它要求所有节点中的时钟是同步的)。令牌环：1，2，3，4。
R6、在第5次碰撞之后，适配器从{0，1，2，…中选择，31。它选择4的概率是1/32。等待204.8微秒。
R7、在民意测验中，讨论领袖一次只允许一个参与者说话，每个参与者都有机会以一种循环的方式交谈。对于象征性的戒指，没有讨论的领导者，但有葡萄酒杯，参与者轮流持有。只有当参与者拿着酒杯时，才允许参与者说话。
R8、当节点发送帧时，节点必须等待帧在整个环周围传播，然后节点才能释放令牌。因此，如果L/R比tprop小，那么协议就会效率低下。
R9、$2^{48}$个MAC地址；$2^{32}$个IPv4地址；$2^{128}$个IPv6地址。
R10、C的适配器将处理这些帧，但是适配器不会将数据报传递到协议栈中。如果使用LAN广播地址，则C的适配器将处理帧并将数据报传递到协议栈。
R11、在广播帧中发送ARP查询，因为查询主机没有将哪个适配器地址对应于所述IP地址。对于响应，发送节点知道应该将响应发送到的适配器地址，因此不需要发送广播帧(必须由LAN上的所有其他节点处理)。
R12、不可能。每个LAN都有自己的一组不同的适配器，每个适配器都有一个唯一的LAN地址。
R13、这三种以太网技术具有相同的帧结构。
R14、2(内部子网和外部因特网)
R15、在802.1Q中有一个12位的VLAN标识符。因此，可以支持212=4096个VLAN。
R16、我们可以把N个开关串在一起。第一个也是最后一个交换机将使用一个端口进行中继；中间的N-2交换机将使用两个端口。因此，端口总数为2+2(N-2)=2N-2端口。
[Back to Index](#目录)
## 问题6 
P1、
1 1 1 0 1 
0 1 1 0 0 
1 0 0 1 0 
1 1 0 1 1 
1 1 0 0 0 
P2、假设我们从初始的二维奇偶矩阵开始：
0 0 0 0 
1 1 1 1 
0 1 0 1 
1 0 1 0 
由于在第2行第3栏中出现了一些错误，第2行和第3列的奇偶校验现在在下面的矩阵中是错误的：
0 0 0 0 
1 1 0 1 
0 1 0 1 
1 0 1 0 
现在假设第2行、第2列和第3列有一个位错误。第2行的奇偶校验现在是正确的！列2和3的奇偶校验是错误的，但是我们不能检测错误发生在哪一行！
0 0 0 0
1 0 0 1 
0 1 0 1 
1 0 1 0 
上述示例显示，可以检测到双比特错误(如果没有纠正)。
P3、
```
  01001100 01101001 
+ 01101110 01101011 
------------------------------ 
  10111010 11010100 
+ 00100000 01001100 
------------------------------ 
  11011011 00100000 
+ 01100001 01111001
----------------------------- 
  00111100 10011010 (溢出，然后绕过去) 
+ 01100101 01110010 
------------------------------ 
  10100010 00001100 
```
和的补码是： 01011101 11110011 
P4、