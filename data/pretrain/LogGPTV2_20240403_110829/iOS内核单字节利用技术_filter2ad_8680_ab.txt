                while (va vme_end) {
    ...
                    m = vm_page_lookup(object, offset);
    ...
                    vm_fault_enter(m,      // Calls pmap_enter_options()
                        dst_map->pmap,     // to map m->vmp_phys_page.
                        va,
                        prot,
                        prot,
                        VM_PAGE_WIRED(m),
                        FALSE,            /* change_wiring */
                        VM_KERN_MEMORY_NONE,    /* tag - not wiring */
                        &fault_info,
                        NULL,             /* need_retry */
                        &type_of_fault);
    ...
                    offset += PAGE_SIZE_64;
                    va += PAGE_SIZE;
               }
           }
       }
    ...
            vm_map_copy_insert(dst_map, last, copy);
    ...
        vm_map_unlock(dst_map);
    ...
    }
让我们一步步完成这个步骤。首先，处理其他vm_map_copy类型:
        if (copy->type == VM_MAP_COPY_OBJECT) {
    ...
        }
    ...
        if (copy->type == VM_MAP_COPY_KERNEL_BUFFER) {
    ...
        }
这个 vm_map 是加锁的:
       vm_map_lock(dst_map);
我们在vm_map_entry(fake)对象链表上输入一个for循环:
        for (entry = vm_map_copy_first_entry(copy);
            entry != vm_map_copy_to_entry(copy);
            entry = entry->vme_next) {
我们处理的情况下，vm_map_entry是wired的，因此应该立即出现故障:
            if (entry->wired_count != 0) {
设置后，我们将遍历wired条目中的每个虚拟地址。由于我们控制了伪造的vm_map_entry内容，所以我们可以控制读取的对象指针（类型为vm_objec）和偏移量：
                object = VME_OBJECT(entry);
                offset = VME_OFFSET(entry);
    ...
                while (va vme_end) {
我们为需要wired的内存的每个物理页查找vm_page
结构。由于我们控制了伪造的vm_object和偏移量，我们可以使vm_page_lookup()返回一个指针，指向一个伪造的vm_page结构体，我们控制它的内容:
                    m = vm_page_lookup(object, offset);
最后，我们调用vm_fault_enter（）在页面中进行故障处理：
                    vm_fault_enter(m,      // Calls pmap_enter_options()
                        dst_map->pmap,     // to map m->vmp_phys_page.
                        va,
                        prot,
                        prot,
                        VM_PAGE_WIRED(m),
                        FALSE,            /* change_wiring */
                        VM_KERN_MEMORY_NONE,    /* tag - not wiring */
                        &fault_info,
                        NULL,             /* need_retry */
                        &type_of_fault);
vm_fault_enter（）的调用比较复杂，所以我不把代码放在这里。可以这样说，通过适当地设置伪造objects中的字段，就可以使用伪造的vm_page对象确定vm_fault_enter（），从而使用任意的物理页码调用pmap_enter_options():
    kern_return_t
    pmap_enter_options(
            pmap_t pmap,
            vm_map_address_t v,
            ppnum_t pn,
            vm_prot_t prot,
            vm_prot_t fault_type,
            unsigned int flags,
            boolean_t wired,
            unsigned int options,
            __unused void   *arg)
pmap_enter_options（）负责修改目标的页表，以插入转换表条目，该转换表条目将建立从虚拟地址到物理地址的映射。似于 vm_map
如何管理地址空间的虚拟映射的状态，pmap结构管理地址空间物理映射(即页表)的状态。并根据osfmk/arm/pmap.c中的源代码。在添加转换表条目之前，不会对提供的物理页码进行进一步验证。
因此，我们破坏的vm_map_copy对象实际上为我们提供了一个非常强大的原语:将任意物理内存直接映射到用户空间中的进程中!
我决定在iOS 13.3的oob_timestamp
exploit所提供的内核读/写原语之上为vm_map_copy物理内存映射技术构建POC，有两个主要原因。
首先，我没有一个较好的漏洞可以用来开发一个完整的exploit。尽管我最初是在试图利用oob_timestamp漏洞时偶然发现这个想法的，但很快就发现这个漏洞并不适合这种技术。
其次，我希望独立实现该技术所使用的漏洞来评估该技术。似乎很有可能使该技术具有确定性（也就是说，没有故障案例）；在一个不可靠的的漏洞上实施它会使得很难单独进行评估。
这种技术适合于kalloc.80
至kalloc.32768的任何分配器区域中的可控一字节堆溢出(即65到32768字节的通用分配），为了便于在后文中参考，我将其称为“单字节利用技术”。
我们已经列出了上述技术的基本要素:创建一个KERNEL_BUFFER类型的vm_map_copy，其中包含一个指向伪造的vm_map_entry列表的指针，将该类型破坏为ENTRY_LIST，使用vm_map_copyout_internal()接收它，并将任意物理内存映射到我们的地址空间中。但是，成功的利用要复杂得多：
  * 1.我们还没有处理伪造的vm_map_entry/vm_object/vm_page将被构造在哪里。
  * 2.我们需要确保在映射物理页面之后，调用vm_map_copyout_internal（）的内核线程不会崩溃，死机或死锁。
  * 3.映射一个物理页面是非常好的，但是它本身可能还不足以实现任意内核读/写。这是因为: 
    * kernelcache在物理内存中的加载地址是未知的，因此我们不能直接映射它的任何特定页面，而应该首先定位它。