(e.g., bytes and words).
constitutes a valid payload, we use the following procedure to
determine if operations are controllable.
Next, the ngx_http_do_read_client_request_
body() function stores the contents of the request into a
different heap buffer. Notice that without A2C this becomes
vulnerable to heap spraying attacks which can be further lever-
aged to launch attacks such as ROP. Also, the same function
has a heap buffer overﬂow vulnerability that allows overwriting
a function pointer, read_event_handler, which will be
called inside ngx_http_request_handler(). However,
since the instrumented program encodes all external requests,
the payload at Line 302 and the address accessed at Line
2133 are mutated. Assume the malicious shellcode contains
a sequence of nop instructions (0x90*n) for the nop-sled
portion of a heap spray attack and the malicious address
injected is 0x00b7c010. In the instrumented program, the
nop instructions (0x90*n) are encoded to “0x89*n”, which
denotes a sequence of mov instructions that write to invalid
memory locations (e.g. mov ecx, ecx(-76767677h)).
At this point, even though the shellcode is successfully in-
jected, due to the mutation, it crashes upon execution. Simi-
larly, the injected function pointer at Line 2133 is also broken.
Note that if the request is valid, despite it being encoded by
the instrumented program, it will be decoded at the frontier
and will not affect normal execution.
IV. DESIGN
A. Decoding Frontier Computation via Constraint Solving.
The ﬁrst phase of A2C is to determine the decoding frontier
that will be used to identify the encoding and decoding sets
in the next analysis phase. As we will see in the next section,
A2C needs to decode at more places than input related buffers.
According to the deﬁnition in Section II, the decoding
frontier consists of three kinds of operations: comparative,
terminal, and uncontrollable. While the identiﬁcation of the
ﬁrst two is straightforward, we focus on the third in this
section.
We ﬁrst deﬁne controllable operations as follows: if valid
payloads can be generated in a memory region (e.g., a buffer)
right after a set of operations by manipulating program inputs,
these operations are controllable. An example of a controllable
operation is the toupper() transformation that turns a lower
case character into its upper case. Assume an application
transforms a text input buffer A into another buffer B using
toupper(). The attacker can carefully prepare the input so
that after the transformation, buffer B contains the intended
payload. It was indeed reported that existing operations in a
program could be leveraged to compute/decode payloads [5].
We further formulate the determination of controllable op-
erations as a constraint solving problem. We consider program
inputs as symbolic variables. We further model the operations
that compute the values for a memory region (at a given
program point) from the program inputs as a set of constraints.
We then assert the values (of the memory region) to be some
valid payload and query a solver if there is a satisfying (SAT)
solution. If so, one may be able to manipulate the input (e.g.,
using the SAT solution generated by the solver) to induce the
given payload. While it is difﬁcult to precisely deﬁne what
Procedure to Determine Decoding Frontier. Given a pro-
gram to protect, A2C identiﬁes all memory regions larger
than or equal
to 16 bytes that can be affected by inputs
(through a standard static taint analysis). These regions include
buffers, consecutive local variables (on stack), consecutive
global variables (in data section), as well as structures. For
example, four consecutive local integer variables related to
inputs constitute a region for testing. For these regions, A2C
creates constraints according to the operations that compute the
values in the regions from program inputs. Other variables that
are not related to inputs are considered as free variables. This
makes our analysis a conservative one as free variables can take
any values during constraint solving, whereas in practice these
variables may have various restrictions. After we generate the
constraints, we use the Z3 solver [25] to test whether payloads
can be generated through these operations. In particular, we
collected 1.4GB binary codes, 200MB shellcode, and 200MB
ROP gadgets from Internet [1], [3], [51], [53], [52]. We also
generate 1.0G random numbers. We further break the data
sets down to sequences based on the size of the region under
testing. If the size is unknown, we use 16-byte sequences.
We then assert the values of the region equal to each of
these sequences one by one. If the constraint solver yields
SAT, TIMEOUT, or UNKNOWN for any of the sequences,
which implies that an attacker may be able to construct some
malicious payload through the operations, then the operations
are considered controllable. If the constraints are UNSAT for
all these sequences, the operations that deﬁne the values of
the memory region are considered uncontrollable.
Essence. Intuitively, we use the large pool of binary code and
shell code snippets to model the distribution of executable
payloads and the large pool of ROP gadget subsequences to
model the distribution of address-based payloads (for code
reuse attacks). We further use a large set of random number
sequences to model the distribution of other arbitrary pay-
loads. Since we only consider operations uncontrollable when
all these sequences yield UNSAT results, A2C provides strong
probabilistic guarantees that the values beyond these operations
are not exploitable.
Note that for complex programs, it may be difﬁcult to
model the entire data ﬂow from program inputs to the memory
region of interest due to various reasons such as unmodeled
library calls and uncertainty of data ﬂow caused by aliasing.
A2C leverages backward slicing, starting from the memory
region of interest and traverses backward along data depen-
dencies until the traversal becomes infeasible (e.g., due to
unmodeled library calls). If program inputs cannot be reached
by the traversal, A2C treats the farthest variables that
it
can reach as free variables. Note that this yields an over-
approximation, which is safe. The decoding frontier analysis
marks all the operations on the decoding frontier. Since the
algorithms in this phase are standard, details are omitted.
In the following, we use a number of examples to facilitate
understanding of decoding frontier.
Uncontrollable Operation Example One. Fig. 4 shows a code
snippet from 464.h264ref (i.e., a video decoding program) in
SPEC 2006.
4
Fig. 4. Uncontrollable operations due to type widening in 464.h264ref.
Fig. 4 (a) shows three arrays m7, img, and mpr with
m7 a temporary array that stores intermediate values during
encoding, img holding raw input values and mpr calculated
by the program and not related to inputs. Observe that m7
is an int array whereas the other two are arrays of short int.
Fig. 4 (b) shows the constraints generated. Lines 7-9 denote
the constraints representing the operations. Line 7 denotes the
subtraction at Line 6. Line 9 denotes the range constraints of
img and mpr. We use “0,1,2,3” to represent that the same
constraint applies to four respective elements. Line 9 denotes
the payload assertion. We iterate this test with i from 0 to the
number of sequences in our test data set.
The test result shows that
the constraints are always
UNSAT. This is mainly because the assignment of short
to int (called type widening) requires payloads to have two
zero bytes in every four bytes. As such, Line 6 is on the
decoding frontier. Type widening is one of the major reasons
for uncontrollability. Another popular form of type widening
is through bit operations, namely, only a few bits of a word
are set. Examples are omitted.
Uncontrollable Operation Example Two. Another common
kind of uncontrollable operation is one that induces intensive
correlations between values. For example, Fig. 5 (a) shows a
code snippet from 429.mcf in SPEC.
Fig. 5. Uncontrollable operations in 429.mcf program.
Fields n, n_trips, max_m, and m are consecutive in the
structure network and they are all related to inputs (in[0]
and in[1]). As such, A2C needs to test if the operations
on these ﬁelds are controllable. The constraints are shown in
Fig. 5 (b). Observe that the net→max_m (i.e., net[3] in the
constraint) and net→m (i.e., net[4]) are identical except
when net→max_m has a constant value 0xA10001. The
other 8 bytes are also closely correlated through in[0] and
in[1]. Consequently, the solver returns UNSAT for all the
payload tests.
Controllable Operation Examples. Most controllable oper-
ations are straightforward, such as copy operations. Method
toupper() is another example of a controllable operation.
The solver returns SAT for many payload sequences, such
as consecutive 0x90’s, which represent the NOP instructions
(nop-sled) in exploits. A2C also determines unicode conversion
functions (e.g., mbtowc()) as controllable. This is because
while unicode conversion translates an ASCII character to two
bytes with an additional byte (0x00), it also translates two
byte characters such as Chinese, Japanese, and Korean charac-
ters to two bytes [63], making payload construction feasible.
Our results echo the message conveyed in [5] that Unicode
conversion function can be leveraged to construct payloads.
In fact, all the data conversion/encryption/decryption/encoding
via table lookup (e.g., iconv(), mbtowc(), wctomb(),
and Inﬂate (Huffman Coding) Algorithm) are recognized as
controllable by A2C.
Fig. 6. Controllable operations in 456.hmmer program.
Interestingly, we also observe that some operations of
complex types and performing complex computations are
determined as controllable by our analysis. Consider the
following example that leverages existing ﬂoating point op-
erations to construct malicious payloads. According to the
IEEE-754 ﬂoating point representation standard, even a very
small ﬂoating point value can affect all the 4 bytes of its
presentation. For example, a ﬂoating point variable 0.0001 is
encoded as 0x38d1b717 in memory. Fig. 6 shows FNorm()
in 456.hmmer from SPEC. It ﬁrst adds all elements in v
into sum using FSum(), and then each element is divided
by the sum if the sum is not 0.0. If the sum is 0.0, all
the elements in v have 1.0 / n where n is the size of v.
Note that when there are multiple deﬁnitions of a variable
(e.g., v[x]), A2C disjoins the constraints for these deﬁnitions,
which are represented in the SSA form. The solver returns
SAT for the constraints. The exploit
is a sequence
of values (e.g., −12068,−18966,−14108,−13991, ...) whose
binary representations do not denote any meaningful payload.
But they are transformed to a meaningful payload by the
operations in Fig. 6. The payload issues a system call through
int 0x80 with arguments.
input
B. Static Analysis to Compute Decoding and Encoding Sets
the
In this section, we discuss the second phase,
computation of decoding and encoding sets.
Language. A2C works on the Single Static Assignment (SSA)
LLVM IR, which is generated from program source code.
To facilitate precise discussion, we introduce a simpliﬁed
language which models the LLVM IR in Fig. 7.
i.e.,
Memory loads and stores are denoted by LOAD(xa) and
STORE(xa, xv), respectively, with xa holding the address and
xv the value. The address of a ﬁeld access is explicitly
computed by x := xbase → f with xbase the base pointer
and f the ﬁeld. Array accesses can be considered as a special
kind of ﬁeld accesses. F(xa) models a call to function F with
xa the actual argument and xf the formal argument. Function
return is modeled by ret.
5
// Declarations (Data Types)1. unsigned int       m7[...][...];2. unsigned short   img[...][...];3. unsigned short   mpr[...][...];    ...// Transformative Operations4.  for (int x = 0; ...; x++ ) 5.    for (int y = 0; ...; y++ )6.     m7[x][y] = img[...][...] - mpr[...][...];; Constraints for Operations (img - mpr)7.   m7[0,1,2,3] = img[0,1,2,3] - mpr[0,1,2,3]             /\ ; Constraints for the range of unsigned short8.   0 n_trips = in[0];        ...7.    net->n = (in[0]+in[0]+1);8.    net->m = (in[0]+in[0]+in[0]+in[1]);9.    if ( ... ) net->max_m = net-> m;10.  else      net->max_m = 0xA10001;; Constraints for Operations 11. net[0] = (2 * in[0] + 1)                  /\ 12. net[1] = in[0]                                 /\ 13. ( (net[2] = (3 * in[0] + in[1])) \/ 14.   (net[2] = 0xA10001))                  /\15. net[3] = (3 * in[0] + in[1])             /\ ; Constraints for Payloads; (i will select a payload to test)16. net[0] = payload[i]         /\ 17. net[1] = payload[i+1]     /\ 18. net[2] = payload[i+2]     /\ 19. net[3] = payload[i+3]   (a) Code snippet from 429.mcf (b) Constraints from the code snippet// Declarations (Data Types)1. float v[...], sum;2. int x, n;// Transformative Operations3.   sum = FSum(v, n);        // FSum returns a sum of all elements.4.   if (sum != 0.0) 5.     for (x = 0; x  | == | ...
e ::= x | c | x op c | x1 op x2 | x → f
x ::= {x1, x2, x3, ...}
c ::= {true, f alse, 0, 1, 2, ...}
(cid:96) ::= {(cid:96)1, (cid:96)2, (cid:96)3, ...}
Operator
Expr
V ar
Const
Label
Fig. 7. Language.
Conditional or loop statements are not directly modeled.
Instead we deﬁne jumps using goto and guarded goto.
Conditional and loop statements can be constructed by com-
bining jumps and guarded jumps. strcat(xa1, xa2) denotes a
function that concatenates two strings. It appends the second
string denoted by pointer xa2 to the ﬁrst string xa1. We deﬁne
lib(x1, x2, ...) to model library calls. It takes several xn’s as
arguments and returns a value in another variable. Function
input(xbuf , xsize) models library calls that read inputs such
as read() and recv(). The x := φ(y, x1, x2) denotes the φ
function in SSA that determines the value of a variable at the
joint point of two branches. In particular, if y is true, x := x1
otherwise x := x2. We also explicitly model heap allocation
through the malloc() function.
Operator denotes uncontrollable (computed by the previous
phase) or comparative operations. Each statement is annotated
with a label, which can be intuitively considered as the line
number of the statement in the program.
a
σ
SRC
::= (cid:96) | x | a.f
Addr
::= (Addr | V ar) × Context → P(Addr)
P ointsT o
::= CONST((cid:96), x) | MARKED((cid:96), x)
Source
::= (Addr | V ar) × Context → P(Source)
T aintStore τ
Context
C
::= (cid:96)
::= P()
DecodeSet DEC
EncodeSet EN C ::= P()
ChkSrc((cid:96), x)
::=
if MARKED((cid:96)m, xm) ∈ τ (cid:96)(x, C) then
DEC := DEC ∪ {}
if ({C, (cid:96), x} ∈ DEC) then
foreach CONST((cid:96)c, c) ∈ τ (cid:96)(x, C) then
EN C := EN C ∪ {}
ChkStrcat((cid:96), xa1, xa2)
::=
if ∃a ∈ σ(cid:96)(xa1, C), MARKED((cid:96)m, xm) ∈ τ (cid:96)(a, C) then
if ∃b ∈ σ(cid:96)(xa2, C), CONST((cid:96)c, c) ∈ τ (cid:96)(b, C) then
EN C := EN C ∪ {}
if ∃a ∈ σ(cid:96)(xa2,C ), MARKED((cid:96)m, xm) ∈ τ (cid:96)(a, C) then
if ∃b ∈ σ(cid:96)(xa1, C), CONST((cid:96)c, c) ∈ τ (cid:96)(b, C) then
EN C := EN C ∪ {}
TaintConst((cid:96), x, c)
::=
if {∈ EN C} then
τ (cid:96)(x, C) := {MARKED((cid:96), c)}
τ (cid:96)(x, C) := {CONST((cid:96), c)}
else
Fig. 8. Deﬁnitions for Abstract Interpretation Rules.
C. Static Analysis Phase
We formulate the static analysis as an abstract