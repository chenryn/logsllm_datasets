### Table IV: Causal Graph Comparison (BEEP/ProTracer)

To further compare the quality of the query results, we evaluate the causal graphs generated by BEEP and ProTracer in answering forward queries. The results are summarized in Table IV, which includes the number of taint sources, the number of processes (i.e., internal nodes along the attack path), the number of files affected by the attacks, and the total number of nodes in the graphs. Note that LogGC would produce the same graphs as BEEP.

| Taint Sources | Processes | Affected Files | Total Nodes |
|--------------|-----------|----------------|-------------|
| 580/128      | 148/82    | 388/208        | 432/226     |
| 864/305      |           |                |             |

Observations:
- Both systems identify the same set of taint sources and processes.
- Differences in the number of affected files are due to BEEP not logging file accesses during the start and end phases (e.g., loaded libraries). Therefore, ProTracer-generated graphs are more comprehensive.
- ProTracer-induced graphs are significantly smaller than those generated by BEEP, reducing the effort required for human inspection.

### Visual Comparison of Graphs

To provide an intuitive understanding of the differences between ProTracer and BEEP graphs, we present parts of the graphs for a forward query in the backdoor attack case. The query aims to find all reachable items from external IPs connected to the FTP server. There are three connections:
- **a.a.a.a**: Downloaded and uploaded a file, and exploited the backdoor.
- **b.b.b.b**: Simply downloaded and uploaded a file.
- **c.c.c.c**: Lost its connection.

#### BEEP Graph
- **Nodes**: 68
- **Details**: The BEEP graph is more detailed but also more complex. For example, the box at the bottom of the BEEP graph shows a zoomed-in view of part of the graph, which is reduced to a single node (FTP-a0) in the ProTracer graph.

#### ProTracer Graph
- **Nodes**: 432
- **Details**: The ProTracer graph is more concise and clear. It avoids logging many events and generating nodes for them, making it easier to understand while still being informative. Events related to c.c.c.c are excluded from the log because the taints did not propagate to any permanent changes.

### Discussion of ProTracer Limitations

1. **Unit Partitioning**:
   - While the execution of many programs can be divided into autonomous units connected through workflow, ProTracer relies on training runs to identify unit loops and workflow dependencies. If unit loops cannot be properly identified, ProTracer treats the entire execution as a single unit. This may lead to broken causal paths if dependencies are missed.

2. **System Integrity**:
   - Similar to most audit logging systems, ProTracer requires that the kernel and the user space daemon are not compromised. This limitation can be mitigated by porting ProTracer to a hypervisor. If a system is initially clean and later subverted, the initial subversion will be accurately captured, but subsequent log entries cannot be trusted.

3. **Malware Analysis**:
   - ProTracer excels at capturing provenance through benign and commonly used applications like browsers and editors. However, malware often uses obfuscation and self-modification, which can create challenges for ProTracer's analysis. As a result, ProTracer typically treats malware execution as a single unit, which is reasonable since all malware actions are of interest in attack investigations.

### Related Work

- **System Logging**:
  - Many works have focused on tracking provenance using system-level audit logs, but they often suffer from dependency explosion and high overhead. BEEP and LogGC are closely related, but ProTracer has lower space and runtime overhead due to its new infrastructure and the integration of tainting and logging. ProTracer-generated graphs are also more concise.

- **Dynamic Information Flow Tracking and Tainting**:
  - Tainting and dynamic information flow tracking have been studied extensively, with high precision but high runtime overhead. ProTracer optimizes tainting at the unit level to avoid heavy instrumentation, but tainting alone cannot answer how-queries.

- **Log Storage and Presentation**:
  - Provenance data can be represented as graphs, and researchers have worked on reducing their size using Web graph compression and dictionary-based encoding. Some techniques reduce events offline, while ProTracer performs online reduction, making these offline techniques complementary.

### Conclusion

We developed ProTracer, a cost-effective provenance tracing system that alternates between logging and unit-level taint propagation, and processes events through a lightweight kernel module and a sophisticated concurrent user space daemon. Our evaluation results show that ProTracer substantially improves upon the state-of-the-art, generating only 13MB of audit log per day and 0.84GB (Server)/2.32GB (Client) in 3 months with less than 7% overhead, while retaining all attack-related information.

### Acknowledgments

We thank the anonymous reviewers for their constructive comments. This research was supported, in part, by DARPA, NSF, ONR, and Cisco Systems. Any opinions, findings, and conclusions in this paper are those of the authors and do not necessarily reflect the views of our sponsors.

### References

[References listed as in the original text]

This optimized version of the text is more structured, clear, and professional, making it easier to read and understand.