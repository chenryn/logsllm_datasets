measured from these input-output pairs, perhaps as we do)
would therefore involve enumerating 21320 possible inputs,
which is obviously impractical.
In this light, our technique that performs interference anal-
ysis for real codebases in the timeframe of minutes-to-hours
(and far faster with parallelization) is a dramatic improvement.
Moreover, these results are likely to only improve with ad-
vances in symbolic execution and model counting. Even our
experimentation with various optimizations for postcondition
generation and model counting was not exhaustive. That said,
the results above suggest that the costs of our approach are
likely to remain sufﬁciently high for real codebases to preclude
its use for interactive analysis by human programmers. Rather,
we expect that our analysis could be run as a diagnostic
technique overnight, for example.
VII. DISCUSSION AND LIMITATIONS
Our methodology builds from two tasks that are recognized,
difﬁcult challenges in computer science. The ﬁrst
is the
construction of a logical postcondition Πproc for a procedure
proc, for which we leverage symbolic execution. As such, our
technique inherits the limitations of existing symbolic execu-
tion tools and those incumbent on generating postconditions,
more generally. For example, symbolic execution is difﬁcult to
scale to some procedures, and challenges involving symbolic
pointers and unbounded loops can require workarounds, as
they did in our TCP case study (Sec. VI-C). The second
challenge problem underpinning our methodology is model
counting, which is #P-complete. We are optimistic that future
improvements in these areas will be amenable to adoption
within our methodology.
Our approach is powerful in that
it can be applied to
scenarios in which the distributions of inputs—whether they
be attacker controlled or other—are unknown, and this is often
the case in practice. In some cases, the input distributions
are unknowable, especially for VarsC . In others, they may be
knowable but require considerable empirical data to estimate
(e.g., the distributions of user-input search terms, in a context
like that of Sec. VI-A). That said, because it is insensitive
to these distributions, it does not offer an immediate way
to accommodate these distributions if they are known. Still,
our methodology allows these inputs to be accounted for in a
principled way, in contrast to others that either disallow them
or assign them heuristically.
VIII. CONCLUSION
In this paper we have suggested a new method for as-
sessing interference and attempts to mitigate it. Informally,
noninterference is achieved when the output produced by a
procedure in response to an adversary’s input is unaffected by
secret values that the adversary is not authorized to observe.
Following this intuition, we have developed a method to
estimate the number of pairs of attacker-controlled inputs and
attacker-observable outputs that are possible, conditioned on
the secret being limited to a particular sample. The discovery
of such pairs that are possible for one sample but not another
reveals interference.
We clariﬁed the effectiveness of our strategy both on
artiﬁcial examples (Sec. V) and on real-world codebases
(Sec. VI). Speciﬁcally, we evaluated leakage in the Sphinx
auto-complete feature of its search interface due to its re-
sponse sizes, and the effectiveness of a variety of mitigations
(Sec. VI-A); the CRIME vulnerabilities of adaptive compres-
sion in Gzip and ﬁxed-dictionary compression in Smaz
(Sec. VI-B); and leakage of TCP sequence numbers in Linux
and the effectiveness of two mitigations of our own design
(Sec. VI-C). Within these contexts we also explored leakage
over a single procedure execution and over many, and showed
that our framework allowed for a useful comparison of how
procedures leaked data as the number of executions grows.
Central to our methodology’s ability to scale to real code-
bases is our expression of leakage assessment within a frame-
526
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:23 UTC from IEEE Xplore.  Restrictions apply. 
work that permits the use of approximate model counting (and
speciﬁcally hash-based model counting). While the resulting
tool is not yet quick enough to support interactive use, it is
positioned to beneﬁt from advances in symbolic execution and
approximate model counting, both active areas of research.
ACKNOWLEDGEMENTS
This work was supported in part by NSF grants 1330599,
1619450, 1652954, and 1718084.
REFERENCES
[1] B. W. Lampson, “A note on the conﬁnement problem,” Communications
of the ACM, vol. 16, no. 10, pp. 613–615, 1973.
[2] D. King, B. Hicks, M. Hicks, and T. Jaeger, “Implicit ﬂows: Can’t live
with ’em, can’t live without ’em,” in 4th International Conference on
Information Systems Security, 2008, pp. 56–70.
[3] J. A. Goguen and J. Meseguer, “Security policies and security models,”
in 3rd IEEE Symposium on Security and Privacy, 1982, pp. 11–20.
[4] S. Chakraborty, K. S. Meel, and M. Y. Vardi, “A scalable approximate
model counter,” in Principles and Practice of Constraint Programming,
ser. LNCS, vol. 8124, 2013.
[5] S. Chen, R. Wang, X. Wang, and K. Zhang, “Side-channel leaks in
web applications: A reality today, a challenge tomorrow,” in 31st IEEE
Symposium on Security and Privacy, 2010, pp. 191–206.
[6] J. Kelsey, “Compression and information leakage of plaintext,” in 9th
International Workshop on Fast Software Encryption, 2002, pp. 263–
276.
[7] R. T. Morris, “A weakness in the 4.2BSD Unix TCP/IP software,” 1985.
[8] Z. Qian, Z. M. Mao, and T. Xie, “Collaborative TCP sequence number
inference attack – how to crack sequence number under a second,” in
19th ACM Conference on Computer and Communications Security, 2012,
pp. 593–604.
[9] A. C. Myers, “JFlow: Practical mostly-static information ﬂow control,”
in 26th ACM Symposium on Principles of Programming Languages,
1999, pp. 228–241.
[10] A. Sabelfeld and A. C. Myers, “Language-based information-ﬂow se-
curity,” IEEE Journal on Selected Areas in Communications, vol. 21,
no. 1, Jan. 2003.
[11] N. Javanovic, C. Kruegel, and E. Kirda, “Pixy: A static analysis tool for
detecting web application vulnerabilities,” in 27th IEEE Symposium on
Security and Privacy, 2006.
[12] Q. A. Chen, Z. Qian, Y. J. Jia, Y. Shao, and Z. M. Mao, “Static
detection of packet
injection vulnerabilities: A case for identifying
attacker-controlled implicit information leaks,” in 22nd ACM Conference
on Computer and Communications Security, 2015.
[13] F. Nentwich, N. Jovanovic, E. Kirda, C. Kruegel, and G. Vigna, “Cross-
site scripting prevention with dynamic data tainting and static analysis,”
in 14th Network and Distributed System Security Symposium, 2007.
[14] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. L.
Traon, D. Octeau, and P. McDaniel, “FlowDroid: Precise context, ﬂow,
ﬁeld, object-sensitive and lifecycle-aware taint analysis for Android
apps,” in 35th ACM Conference on Programming Language Design and
Implementation, 2014, pp. 259–269.
[15] D. E. R. Denning, Cryptography and Data Security. Addison-Wesley,
1982.
[16] J. W. Gray, “Toward a mathematical foundation for information ﬂow
security,” in 12th IEEE Symposium on Research in Security and Privacy,
1991, pp. 21–34.
[17] D. Clark, S. Hunt, and P. Malacaria, “Quantitative analysis of the leakage
of conﬁdential data,” Electronic Notes in Theoretical Computer Science,
vol. 59, no. 3, 2002.
[18] G. Lowe, “Quantifying information ﬂow,” in 15th IEEE Workshop on
Computer Security Foundations, 2002.
[19] D. Clark, S. Hunt, and P. Malacaria, “Quantitative information ﬂow,
relations and polymorphic types,” Journal of Logic and Computation,
vol. 15, no. 2, 2005.
[20] M. R. Clarkson, A. C. Myers, and F. B. Schneider, “Belief in information
ﬂow,” in 18th IEEE Workshop on Computer Security Foundations, 2005,
pp. 31–45.
[21] D. Clark, S. Hunt, and P. Malacaria, “A static analysis for quantifying
information ﬂow in a simple imperative language,” Journal of Computer
Security, vol. 15, no. 3, pp. 321–371, 2007.
[22] P. Malacaria, “Assessing security threats of looping constructs,” in 34th
ACM Symposium on Principles of Programming Languages, 2007, pp.
225–235.
[23] B. K¨opf, L. Mauborgne, and M. Ochoa, “Automatic quantiﬁcation of
cache side-channels,” in 24th International Conference on Computer
Aided Veriﬁcation, 2012, pp. 564–580.
[24] G. Doychev, B. K ¨opf, L. Mauborgne, and J. Reineke, “CacheAudit: A
tool for the static analysis of cache side channels,” in 22nd USENIX
Security Symposium, 2013, pp. 431–446.
[25] K. Zhang, Z. Li, R. Wang, X. Wang, and S. Chen, “Sidebuster:
Automated detection and quantiﬁcation of side-channel leaks in web
application development,” in 17th ACM Conference on Computer and
Communications Security, 2010, pp. 595–606.
[26] P. Chapman and D. Evans, “Automated black-box detection of side-
channel vulnerabilities in web applications,” in 18th ACM Conference
on Computer and Communications Security, 2011, pp. 263–274.
[27] Q.-S. Phan and P. Malacaria, “Abstract model counting: A novel ap-
proach for quantiﬁcation of information leaks,” in 9th ACM Symposium
on Information, Computer and Communications Security, 2014, pp. 283–
292.
[28] P. Mardziel, M. S. Alvim, M. Hicks, and M. R. Clarkson, “Quantifying
information ﬂow for dynamic secrets,” in 35th IEEE Symposium on
Security and Privacy, 2014, pp. 540–555.
[29] B. K¨opf and D. Basin, “An information-theoretic model for adaptive
side-channel attacks,” in 14th ACM Conference on Computer and Com-
munications Security, 2007, pp. 286–296.
[30] C. S. P˘as˘areanu, Q.-S. Phan, and P. Malacaria, “Multi-run side-channel
analysis using symbolic execution and max-SMT,” in 29th IEEE Com-
puter Security Foundations Symposium, 2016, pp. 387–400.
[31] Q.-S. Phan, L. Bang, C. S. P˘as˘areanu, P. Malacaria, and T. Bultan,
“Synthesis of adaptive side-channel attacks,” in 30th IEEE Computer
Security Foundations Symposium, 2017.
[32] B. K¨opf and A. Rybalchenko, “Approximation and randomization for
quantitative information-ﬂow analysis,” in 23rd IEEE Computer Security
Foundations Symposium, Jul. 2010, pp. 3–14.
[33] A. Biere, M. Heule, and H. van Maaren, Handbook of Satisﬁability.
IOS press, 2009, vol. 185.
[34] M. Backes, B. K ¨opf, and A. Rybalchenko, “Automatic discovery and
quantiﬁcation of information leaks,” in 30th IEEE Symposium on Secu-
rity and Privacy, 2009, pp. 141–153.
[35] A. D. Pierro, C. Hankin, and H. Wiklicky, “Approximate non-
interference,” Journal of Computer Security, vol. 12, no. 1, pp. 37–81,
Jan. 2004.
[36] R. Ensaﬁ, J. C. Park, D. Kapur, and J. R. Crandall, “Idle port scanning
and non-interference analysis of network protocol stacks using model
checking,” in 19th USENIX Security Symposium, 2010.
[37] T. Murray, D. Matichuk, M. Brassil, P. Gammie, T. Bourke, S. Seefried,
C. Lewis, X. Gao, and G. Klein, “seL4: From general purpose to a proof
of information ﬂow enforcement,” in 34th IEEE Symposium on Security
and Privacy, 2013, pp. 415–429.
[38] C. Hritcu, J. Hughes, B. C. Pierce, A. Spector-Zabusky, D. Vytiniotis,
A. A. de Amorim, and L. Lampropoulos, “Testing noninterference,
quickly,” in 18th ACM International Conference on Functional Program-
ming, 2013, pp. 455–468.
[39] F. D ¨orre and V. Klebanov, “Practical detection of entropy loss in pseudo-
random number generators,” in 23rd ACM Conference on Computer and
Communications Security, 2016, pp. 678–689.
[40] T. Antonopoulos, P. Gazzillo, M. Hicks, E. Koskinen, T. Terauchi, and
S. Wei, “Decomposition instead of self-composition for proving the
absence of timing channels,” in 38th ACM Conference on Programming
Language Design and Implementation, 2017, pp. 362–375.
[41] J. Chen, Y. Feng, and I. Dillig, “Precise detection of side-channel
vulnerabilities using quantitative cartesian Hoare logic,” in 24th ACM
Conference on Computer and Communications Security, 2017, pp. 875–
890.
[42] G. Smith, “Quantifying information ﬂow using min-entropy,” in 8th
International Conference on Quantitative Evaluation of Systems, Sep.
2011, pp. 159–167.
[43] Y. Dodis, R. Ostrovsky, L. Reyzin, and A. Smith, “Fuzzy extractors:
How to generate strong keys from biometrics and other noisy data,”
SIAM Journal on Computing, vol. 38, no. 1, pp. 97–139, 2008.
527
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:23 UTC from IEEE Xplore.  Restrictions apply. 
[44] C. Cadar, D. Dunbar, and D. Engler, “KLEE: Unassisted and automatic
generation of high-coverage tests for complex systems programs,” in 8th
USENIX Symposium on Operating Systems Design and Implementation,
Dec. 2008.
[45] V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: a platform for
in-vivo multi-path analysis of software systems,” in 16th International
Conference on Architectural Support for Programming Languages and
Operating Systems, 2011, pp. 265–278.
[46] M. Soos, “The CryptoMiniSAT 5 set of solvers at SAT Competition
2016,” SAT COMPETITION 2016, p. 28, 2016.
[47] A. Ivrii, S. Malik, K. S. Meel, and M. Y. Vardi, “On computing minimal
independent support and its applications to sampling and counting,”
Constraints, vol. 21, no. 1, pp. 41–58, Jan. 2016.
[48] G. Kellaris, G. Kollios, K. Nissim, and A. O’Neill, “Generic attacks
on secure outsourced databases,” in 23rd ACM Conference on Computer
and Communications Security, 2016, pp. 1329–1340.
[49] K. P. Dyer, S. E. Coull, T. Ristenpart, and T. Shrimpton, “Peek-a-boo,
I still see you: Why efﬁcient trafﬁc analysis countermeasures fail,” in
33rd IEEE Symposium on Security and Privacy, 2012, pp. 332–346.
[50] J. Alawatugoda, D. Stebila, and C. Boyd, “Protecting encrypted cookies
from compression side-channel attacks,” in Financial Cryptography and
Data Security, 2015, pp. 86–106.
[51] S. Sanﬁlippo, “Small strings compression library,” https://github.com/
antirez/smaz, 2009.
[52] Y. Cao, Z. Qian, Z. Wang, T. Dao, S. V. Krishnamurthy, and L. M. Mar-
vel, “Off-path TCP exploits: Global rate limit considered dangerous,” in
25th USENIX Security Symposium, 2016, pp. 209–225.
[53] “Linux blind TCP spooﬁng vulnerability,” http://www.securityfocus.
com/bid/580/info, 1999.
[54] J. Dike, “User-mode Linux,” in Annual Linux Showcase & Conference,
2001.
[55] V. Kuznetsov, J. Kinder, S. Bucur, and G. Candea, “Efﬁcient state merg-
ing in symbolic execution,” in 33rd ACM Conference on Programming
Language Design and Implementation, 2012, pp. 193–204.
APPENDIX
A. From Procedure to Logical Postcondition
As mentioned in Sec. III, the logical postcondition Πproc
represents the relationship between inputs and outputs induced
by procedure proc. To extract Πproc from proc, we apply
symbolic execution to proc. After marking each input variable
(i.e., each parameter in VarsC , VarsI ,9 and VarsS ) symbolic
before the user-deﬁned entry point, we utilize KLEE [44]
or S2E [45] to explore all feasible execution paths through
proc that reach a return. On each path through proc, the
symbolic execution engine accumulates a set of constraints
among symbolic variables implied by the branches taken
and assignments computed along that path. These constraints
coupled with the assignments for VarsO deﬁned by our API
make_observable, as accumulated through the return
instruction, form the postcondition for the path, and then Πproc
is simply the disjunction of the path conditions generated for
each execution path.
Symbolic execution can suffer from state explosion, and
so we leveraged an optimization in our work to manage
this explosion. Speciﬁcally, we implemented a searcher to
perform state merging [55] frequently, wherein the constraints
accumulated along two or more execution preﬁxes ending
at
the same instruction are disjoined and then simpliﬁed
to the extent possible (using an SMT solver); execution is
then continued from their last instruction, accumulating more
9To model the random input generated from random number generator
rand () in symbolic execution, we created a symbolic variable per rand ()
function call as its returned value.
Sec.
Procedure
VI-A Auto-complete
VI-B Gzip
VI-B Smaz
VI-C v3.18
VI-C v3.18-patched
VI-C v3.18-rmCounter
KLEE
×1
2d
3d
2d
7d
KLEE
×16
12h
21h
18h
4d
KLEE
×1, merging
S2E
×16
8h
6h
17m
18m
17m
Fig. 13: Postcondition generation times for case studies
constraints into their now-combined constraints. In doing so,
these two execution preﬁxes need only be extended once,
versus each being extended separately if no merging occurred.
This optimization dramatically reduced the number of sym-
bolic states managed in one of our case studies in Sec. VI-C,
improving the speed of extracting Πproc by more than 600×.
For this case study, we forced state merging to occur whenever
a symbolic state was forked at a symbolic branch. To reduce
the complexity of the merged path constraint, however, we
avoided merging two path constraints when their expressions
for the outputs in O differed or when two path constraints (in
conjunctive normal form) had less than half of their conjuncts
in common.
A well-known limitation of symbolic execution is how to
manage unbounded loops, since these can prevent symbolic
execution from terminating. In the case studies of Sec. VI we
bounded all inputs, which was enough in these case studies to
ensure that symbolic execution terminated. Provided that we
bound the input parameters sufﬁciently loosely to encompass
all values they can take on in practice, this bounding does not
impact the assessment provided by our measures in practice.
Postcondition generation costs are summarized in Fig. 13.
These computations were performed on a DELL PowerEdge
R710 server equipped with two 2.67GHz Intel Xeon 5550
processors and 128GB memory. Each processor includes 4
physical cores and had hyperthreading enabled. As indicated
in Fig. 13, we experimented with both KLEE and S2E to
generate postconditions, depending on the procedure. In the
column headings, a ‘×1’ or ‘×16’ indicates the number
of processes across which the computation was divided. To
enable multi-process support in KLEE (i.e., ‘×16’), we made
a small modiﬁcation in KLEE’s execution engine, to cause
it to explore only execution paths starting from a predeﬁned
branching preﬁx. The designation ‘merging’ indicates the use
of the KLEE optimization summarized above; as indicated
in Fig. 13, this optimization was remarkably effective on the
Linux TCP implementations discussed in Sec. VI-C. S2E was
conﬁgured to utilize its concolic execution capabilities.
528
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:39:23 UTC from IEEE Xplore.  Restrictions apply.