EnQueue (123) ;
//写入123
EnQueue (456) ;
//写入789
//写入456
BnQueue (789) ;
//从队列中读出数据
m - DeQueue() 
//读出123
n=DeQueue();
//读出456
o=DeQueue();//读出 789
虽然示例程序中没有展示实际的数组以及Push、Pop、EnQucue、
①汇编语言中有push和pop两个指令，但这里指的是程序员为了以LIFO形
式对数组进行读写而微成的Push品数和Pop函数。
②通需情况下，往栈写入数据称为Push（入栈），从栈中读出数据称为Pop
（出栈）往队列中写入数据称为EnQueue（入列），从队列中读出数据称为
DeQueue（出列）这里直接把它们各自的英文名称作为函数名字使用了。
---
## Page 87
4.5栈、队列以及环恶缓冲区
DeQueue的处理内容，不过还是希望大家能够据此对栈及队列是如何
使用内存的有一个大体印象。
顾名思义，在栈中，LIFO方式表示栈的数组中所保存的最后面的
数据（LastIn）会被最先读取出来（FirstOut）。代码清单4-4的程序运
行后，按照123、456、789的顺序写入的数据，结果却按照789、456、
123的顺序被读取出来（图47）
表示栈的数组
Push(1231:运行后
Push(456);运行后
Push(789);运行后
789
456
456
123
123
123
I=Popll:运行后
k=Popl;运行后
j=Pop0；运行后
456
123
123
围47代码清单44运行时栈的变化
栈的原意是“干草堆积如山”。干草堆积成山后，最后堆的干草会
被最先抽取出来。干草堆也是用来临时保存家禽饲料的方式。程序中
也是如此，为了实现临时保存数据的目的，使用这种类似于干草堆的
机制是非常方便的。而这种机制体现在内存上，就是栈。当我们需要
暂时舍弃当前的数据，随后再原貌还原时，会使用栈。
与栈相对的是队列，顾名思义，FIFO方式表示队列的数组中所保
更多资料请关注裁的新浪薄客http：//blo
---
## Page 88
第4章熟练使用有楼有角的内存
存的最初数据（FirstInput）会最先被读取出来（First Out）。代码清单
45中的程序运行后，按照123、456、789的顺序写人的数据，结果会
按照123、456、789的顺序被读取出来（图4-8）。
表示队列的数组
EnQueue(123):
EnQueue(456):
EnQueue(789:
运行后
运行后
运行后
123
123
123
456
456
789
0 = DeQueue0;
n = DeQueue() :
m = DeQueuell:
运行后
运行后
运行后
456
789
789
图4-8代码清单4-5运行时队列的变化
队列这一方式也称为排队。排队指的是买车票时在自动售票机前
等候的队列等。排队时，站在最前面的乘客先买票，购买后率先从队
列中走出来。当随机前来的购票乘客数量和自动售票机的处理速度不
相符时，排队能起到很好的缓冲作用。程序中也是如此，为了协调好
数据输人和处理时机间的关系，采用类似于排队的机制是很方便的。
在内存上，实现这种机制的方式就是队列。当我们需要处理通讯中发
送的数据时，或由同时运行的多个程序所发送过来的数据时，会用到
这种对队列中存储的不规则数据进行处理的方法。
队列一般是以环状缓冲区（ringbuffer）的方式来实现的，也就是
---
## Page 89
4.6表便元素的追加种副除更客
本章标题中所说的“熟练使用有棱有角的内存”。例如，假设我们要用
有6个元素的数组来实现一个队列。这时可以从数组的起始位置开始
有序地存储数据，然后再按照存储时的顺序把数据读出。在数组的末
尾写人数据后，后一个数据就会被写人数组的起始位置（此时数据已经
被读出所以该位置是空的）。这样，数组的末尾就和开头连接了起来，
数据的写人和读出也就循环起来了（图4-9）。
下一个要读出的位置
下一个要读出的位置
数据1
数据2
数据2
数3
数据4
数据3
下一个要写入的位置
下一个要写入的位置
图49环状缓冲区的模型
4.6链表使元素的追加和删除更容易
接下来介绍的链表和二叉查找树，都是不用考虑索引的顺序就可
以对数组元素进行读写的方式。通过使用链表，可以更加高效地对数
组数据（元素）进行追加和制除处理。而通过使用二叉查找树，则可以
更加高效地对数组数据进行检索。
在数组的各个元素中，除了数据的值之外，通过为其附带上下一
个元素的索引，即可实现链表。数据的值和下一个元素的索引组合在
一起，就构成了数组的一个元素。这样，数组元素相连就构成了念珠
---
## Page 90
第4章熟练使用有棱有角的内存
似的链表。由于链表末尾的元素没有后续的数据，因此就需要用别的
值（在这里是-1）来填充（图4-10）。
p(0)
值：111
下一个元素：1
代码清单的初始位置
p[1]
值：222
下一个元素：2
p(2)
值：333
下一个元素：3
链表的链
p(3)
值：444
下一个元素：4
p[4]
值：555
下一个元素：5
p(5)
下一个元素：-1
值：666
表的末尾
图4-10链表的示例（初始状态）
在需要追加或删除数据的情况下，使用链表是很高效的。首先，
让我们来看一下删除的情况。在图4-10表示的链表中，假设要删除从
起始位置开始的第3个元素。此时，我们只需要把第2个元素的“下一
个元素：2”变成“下一个元素：3”即可。由于数组的元素通常是按照
索引顺序来引用的，因此当我们需要引用构成链表的数组的某一个元
素时，通过该元素的索引信息就可以找到下一个元素。当第2个元
素的下一个元素变成第4个元素后，那么第3个元素就被删除了。
虽然第3个元素在物理内存上还残留着，但在逻辑上则确实被删除了
（图 4-11 )。
接下来就让我们来看一下如何往链表中追加数据。假设要在图
4-10的链表的第5位前追加一个新数据。此时，我们只需要在刚才消
除的第3个元素的位置中保存新的数据，并将第4个元素的“下一个元
素：5”变更成“下一个元素：2”，以使新追加的元素的索引信息变成
---
## Page 91
4.6表使元素的遇加和除更容易
“下一个元素：5”即可。虽然新追加的元素在物理上是第3个，但从逻
辑上看来则是第5个（图4-12）。
p(0]
值：111
下一个元案：1
pl11
下一个元素
值：222
把2变更成3
p(21
下一个元素：3
值：333
该元素被从链表
p[3]
值：444
中删除了
下一个元素：4
p(4]
值：555
下一个元素：5
链表的
p(5]
值：666
下一个元案
围4-11删除链表的第3个元素的方法
pl01
值：111
下一个元素：1
pl11
值：222
下一个元素：3
p(21
值：777
把该元素追加到
下一个元素：5
链表中
p(3)
值：444
下一个元素：4
pl41
值：555
下一个元素：
把5变成2
pl51
值：666
下一个元素
链表的链
图4-12铺表中追加元素的方法
如果不使用链表数组，那么中途删除或追加元素时，其后的元素
就必须要全部移动。示例中数组的元素只有6个，处理起来不会花费
较多时间。而在实际的程序中，有时需要对包含数千至数万个元素的
---
## Page 92
第4章熟练使用有橙有角的内存
数组进行频繁的数据追加或删除操作。如果每次都需要移动数千至数
万个元素，那么哪怕是高速计算机也会花费很长时间（图4-13、图
4-14）。反之，使用代码清单来追加或删除数据则毫不费事。
删除前的状态
删除后的状态
p[0]
值：111
p[0]
值：111
p[1]
值：222
想要除的元素
pl1]
值：222
p|2]
值：333
通过移动元素
值：444
值：444
来填充
p|3]
p(3)
值：555
p|4]
值：555
p(4)
值：666
p(5]
值：666
p(51
图413单纯使用数组的情况下的元素删除
追加前的状态
谊加后的状态
p(0]
值：111
p(0]
值：111
pl1]
值：222