title:POSTER: Oblivious Access System on Decentralized Database over Parallel
Smart Contract Model
author:Zhong-Yi Guo and
Yu-Chi Chen and
Hsiu-Ping Lin
POSTER: Oblivious Access System on Decentralized Database
over Parallel Smart Contract Model
Zhong-Yi Guo
Yuan Ze University
Taoyuan, Taiwan
PI:EMAIL
Yu-Chi Chen
Yuan Ze University
Taoyuan, Taiwan
PI:EMAIL
Hsiu-Ping Lin
National Taiwan University
Taipei, Taiwan
PI:EMAIL
ABSTRACT
Data stored on centralized cloud servers may have some risks. More-
over, it may leak the data access pattern when accessing data on
cloud servers. Oblivious RAM (ORAM) is a candidate solution to
hide the data access pattern, but it inherently induces some over-
heads of accessing data. In this paper, we address the issues above,
and propose the oblivious access system on decentralized data-
base over parallel smart contract model. The proposed system can
slightly reduce the overhead of ORAM and overcome the problem
from centralized servers. The main techniques are to use parallel
smart contract model to improve the performance of smart contract
execution and garbled circuit to reduce the cost of communication.
CCS CONCEPTS
â€¢ Security and privacy â†’ Management and querying of en-
crypted data; â€¢ Information systems â†’ Distributed storage;
Distributed database transactions; â€¢ Computer systems orga-
nization â†’ Client-server architectures.
KEYWORDS
Smart contract, Blockchain, Oblivious RAM, Garbled circuit
ACM Reference Format:
Zhong-Yi Guo, Yu-Chi Chen, and Hsiu-Ping Lin. 2020. POSTER: Oblivious
Access System on Decentralized Database over Parallel Smart Contract
Model. In Proceedings of the 15th ACM Asia Conference on Computer and
Communications Security (ASIA CCS â€™20), October 5â€“9, 2020, Taipei, Taiwan.
ACM, New York, NY, USA, 3 pages. https://doi.org/10.1145/3320269.3405436
1 INTRODUCTION
In traditional IoT systems, the collected data will be stored in cen-
tralized cloud servers. Hence, users have to trust that the centralized
cloud servers protect their sensitive and private data, which are
normally unencrypted. Therefore, centralized IoT systems might
face some challenges. Data stored in centralized cloud servers has a
risk of being modified or deleted. Furthermore, If centralized cloud
servers stop working, the entire system will face the risk of getting
paralyzed.
Blockchain, which is first proposed by Nakamoto[5], is a dis-
tributed timestamp ledger of blocks which is utilized to share and
Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
ASIA CCS â€™20, October 5â€“9, 2020, Taipei, Taiwan
Â© 2020 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-6750-9/20/10.
https://doi.org/10.1145/3320269.3405436
store data. It may be a promising technique to resolve the problems
which centralized IoT systems are facing because of its superior
properties (decentralization, tamper resistance, anonymity, security
and privacy). Owing to the invention of smart contracts [7], which
is an executable codes on the blockchain, the blockchain has now
evolved into a platform for developing decentralized applications.
Among these applications, decentralized data management has at-
tracted widespread attentions from computer science and academic
fields. Therefore, smart contracts can be regarded as decentralized
cloud servers. Suppose data is encrypted by users before uploading
to the smart contract. If users access the identical data multiple
times, the smart contract will learn the data is important to users.
Thus, even if the data is encrypted, attackers can infer sensitive
information from the data access pattern.
To address this issue, Oblivious RAM (ORAM), firstly introduced
by Goldreich and Ostrovsky [2], is a method to hide the data ac-
cess pattern. It allows clients to store data on an untrusted server.
The protocol guarantees that the server learns nothing about the
clientâ€™s access pattern or data. In recent years, plenty of ORAM
frameworks(e.g., [3, 4, 6, 8]) have been introduced to increase the
efficiency. In general, users must keep a position map on the local-
side. Therefore, ORAM actually induces some communication and
memory storage overheads of data access.
We propose the oblivious access system on decentralized data-
base over parallel smart contract model, aiming to provide the
service of decentralized cloud storage which hides the data access
pattern and overcomes the overheads above. In our oblivious struc-
ture, we follow the tree-based ORAMs [6, 8] which store data in
the binary tree and rely on the position map to access the data.
Specially, the position map is not held by users, it is stored on the
smart contract, instead. Besides, we garble some fields on the po-
sition map and use garbled circuit [9] to return the data. Through
the techniques above, it reduces the cost of communication and
memory storage. Furthermore, Yu et al.[10] proposed a parallel
smart contract (PSC) model. It uses multi-thread technology [1] to
execute smart contracts in parallel. Using this new model to process
transactions may reduce the average time cost and improve the
performance.
2 PRELIMINARIES
2.1 Parallel Smart Contract Model
Yu et al.[10] propose a parallel smart contract model on blockchain
which has a better performance in transaction processing. This
paper uses multi-thread technology to implement the proposed
model where transactions are executed in parallel. With this model,
it can at least save 23.8% in time cost. This model consists of two
phases as follows:
Poster Session ASIA CCS '20, October 5â€“9, 2020, Taipei, Taiwan895â€¢ TransSplit(ğ‘‡1, . . . ,ğ‘‡ğ‘›): It groups the transactions and leaves
no shared variables for each transaction group. It takes as
input the transactions ğ‘‡1,...,ğ‘‡ğ‘›, then outputs the transaction
sets ğ‘‡ğ‘†ğ‘’ğ‘¡1
, . . . ,ğ‘‡ğ‘†ğ‘’ğ‘¡ğ‘ .
, . . . ,ğ‘‡ğ‘†ğ‘’ğ‘¡ğ‘): It takes as input the transac-
â€¢ MultiProcess(ğ‘‡ğ‘†ğ‘’ğ‘¡1
tion setsğ‘‡ğ‘†ğ‘’ğ‘¡1
, . . . ,ğ‘‡ğ‘†ğ‘’ğ‘¡ğ‘ , then outputs the threads ğ‘¡â„1, . . . , ğ‘¡â„ğ‘
to execute the transaction sets parallelly.
2.2 Garbled Circuit
Garbled circuit, which was first introduced by Yao, [9] is a crypto-
graphic technique to hide the circuit and input. It mainly consists
of two phases as follows:
â€¢ CreateGC(1ğœ†, ğ¶): It takes as input a security parameter ğœ†
and a circuit ğ¶, then outputs a garbled circuit(cid:101)ğ¶ and(cid:101)ğ‘¤, which
â€¢ EvalGC((cid:101)ğ¶,(cid:101)ğ‘¤ğ‘–): It takes as input a garbled circuit(cid:101)ğ¶ and a set
of garbled input(cid:101)ğ‘¤ğ‘–, then outputs the evaluated value ğ‘¦.
is a set of input labels for each input wire of C.
3 THE PROPOSED SYSTEM
3.1 Building Blocks
3.1.1 Data Block Format. Similar to existing ORAMs, we store data
in blocks, and a data block is the basic unit for read or write opera-
tions by the user. A plain-text data block consists of the ID of the
data block, denoted as ğ‘–ğ‘‘ğ‘› and the content of the data block, denoted
as ğ‘ğ‘›. Before being uploaded to the service-side, the plain-text data
block are encrypted with the secret key k. Thus, the encrypted data
block which is denoted as ğµğ‘› has the following format:
ğµğ‘› = (ğ‘–ğ‘‘ğ‘›, ğ‘ğ‘›)
Service-side Storage Organization. We follow the tree-based
3.1.2
ORAMs structure and take it as our oblivious structure. The service-
side storage is organized into a binary tree. Moreover, each node in
the binary tree is a data bucket which stores up to ğ‘‚(log ğ‘) data
blocks. In order to access the data from the service-side storage, the
user must create a position map ğ‘ğ‘œğ‘  which is related to the data
position. The illustration of accessing data is shown in Fig. 1.
Figure 1: Accessing data from the service-side storage
Service-side. Here, smart contract(SC) is the service-side.
3.1.3
The specific algorithms on the service-side are formal described as
follows:
outputs a transaction ğ‘‡ğ¼ and an oblivious database ODB.
â€¢ SC-KeyGen(1ğœ, ğ‘–ğ‘‘ğ‘ˆ ) : It take as input a security parameter
ğœ and the userâ€™s ID ğ‘–ğ‘‘ğ‘ˆ , then outputs the userâ€™s private key
ğ‘ ğ‘˜ğ‘ˆ and the userâ€™s public key ğ‘ğ‘˜ğ‘ˆ .
â€¢ SC-Sign(ğ‘ ğ‘˜ğ‘ˆ ,ğ‘‡) : It takes as input the userâ€™s private key ğ‘ ğ‘˜ğ‘ˆ
and a transaction ğ‘‡ , then outputs a digital signature of the
transaction ğœ.
â€¢ SC-Vrfy(ğ‘ğ‘˜ğ‘ˆ , ğœ,ğ‘‡) : It takes as input the userâ€™s public key
ğ‘ğ‘˜ğ‘ˆ , the digital signature of the transaction ğœ and a transac-
tion ğ‘‡ , then outputs a verification of the transaction ğ‘£.
which is the location of target dataâ€™s ID on the position map.
â€¢ ğ‘‡ğ‘Ÿğ‘’ğ‘ğ‘‘(ğ‘™ğ‘œğ‘ğ‘–ğ‘‘) : It takes as input the location of target dataâ€™s
ID on the position map ğ‘™ğ‘œğ‘ğ‘–ğ‘‘, then outputs a transaction ğ‘‡ğ‘…
and a set of the cipher-text data blocks {ğµğ‘–}.
â€¢ ğ‘‡ğ‘–ğ‘›ğ‘–ğ‘¡ğ‘–ğ‘ğ‘™ğ‘–ğ‘§ğ‘’({ğµğ‘›} ,(cid:103)ğ‘ğ‘œğ‘ ,(cid:101)ğ¶ğ‘’ğ‘£ğ‘ğ‘™ ,(cid:101)ğ¶ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’) : Its take as input a set
of cipher-text data blocks {ğµğ‘›}, the garbled position map(cid:103)ğ‘ğ‘œğ‘ ,
a garbled circuit(cid:101)ğ¶ğ‘’ğ‘£ğ‘ğ‘™ and a garbled circuit(cid:101)ğ¶ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’, then
â€¢ ğ‘‡ğ‘’ğ‘£ğ‘ğ‘™ ((cid:101)ğ‘¤ğ‘–ğ‘‘,(cid:103)ğ‘ğ‘œğ‘ ,(cid:101)ğ¶ğ‘’ğ‘£ğ‘ğ‘™) : It takes as input a garbled label of
target dataâ€™s ID(cid:101)ğ‘¤ğ‘–ğ‘‘, the garbled position map(cid:103)ğ‘ğ‘œğ‘  and a
garbled circuit(cid:101)ğ¶ğ‘’ğ‘£ğ‘ğ‘™, then outputs a transaction ğ‘‡ğ¸ and ğ‘™ğ‘œğ‘ğ‘–ğ‘‘
(cid:9) , ğ‘) : It takes as input re-encrypted data blocks
â€¢ ğ‘‡ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’((cid:8)ğµâˆ—
(cid:8)ğµâˆ—
(cid:9) and a random path ğ‘, then outputs a transaction ğ‘‡ğ‘Š
â€¢ ğ‘‡ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’((cid:103)ğ‘ğ‘œğ‘ ,(cid:101)ğ¶ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’) : It takes as input the garbled posi-
tion map(cid:103)ğ‘ğ‘œğ‘  and a garbled circuit(cid:101)ğ¶ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’, then outputs a
transaction ğ‘‡ğ‘…ğ‘ƒ and(cid:103)ğ‘ğ‘œğ‘ âˆ— as the garbled position map to the
â€¢ ğ‘‡ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’((cid:101)ğ¶âˆ—