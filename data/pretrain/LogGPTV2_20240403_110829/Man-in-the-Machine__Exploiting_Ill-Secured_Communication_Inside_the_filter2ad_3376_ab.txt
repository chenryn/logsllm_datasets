careless, it will not check that it is creating the ﬁrst in-
stance of the pipe. By choreographing the creation of the
instances and client connections, the attacker can then
become a man in the middle between the legitimate client
and server, passing messages between two pipes. It helps
to know that Windows connects new clients to the server
instances in round-robin order.
To summarize, it is easy to overlook the necessary se-
curity controls for named pipes, thus creating vulnera-
bilities, but on the other hand, careful conﬁguration can
avoid most of the issues.
3.3 Hardware security tokens
Universal Serial Bus (USB) allows peripheral devices to
communicate with a computer. USB human interface de-
vices (HID) include keyboards and pointing devices, but
also hardware security tokens.
In Linux, HIDs are character devices and mapped
to special ﬁles under /dev/hidraw*. The currently
logged-in user gets by default read-write access to the
special ﬁle. If the user session is interrupted, either by
the user logging out or by switching users, the read-write
access is reassigned to the display manager and later to
the next logged-in user. Thus, exactly one user at a time
has access to a USB HID. Windows lacks such mech-
anisms for dynamic access-rights assignment, and more
than one user at a time could have access to a HID device
including hardware security tokens.
Attack vectors. The MitMa attacker in Windows can
access USB HIDs plugged in by other users. This also
applies to USB security tokens. The security of the to-
ken will then depend on application-level security mech-
anisms implemented in the hardware or software.
3.4 Safe IPC methods
It is worth noting that some IPC mechanisms, such as
anonymous pipes and socket pairs, are not vulnerable to
our attacks. In these methods, both endpoints of the IPC
channel are created at the same time by the same pro-
cess, which prevents an untrusted process from getting to
the middle. Unfortunately, these IPC methods can only
be used between related processes (typically parent and
child), which severely limits the software architecture.
Thus, it is attractive to use the more client-server oriented
but less safe methods described above.
On macOS, apart from the same IPC methods that are
available on Windows and Linux, there are also Mach
IPC methods that are based on the Mach kernel, such as
Figure 2: Password manager architecture with native app
and browser extension
CFMessagePort. These IPC channels are associated with
a login session [10], and a process from one login session
cannot interact with another. Thus, these IPC methods
are immune to MitMa attacks between users.
In the following sections, we show how the attack
vectors described above are affecting real-world applica-
tions. Table 2 summarizes the applications and the vul-
nerabilities that we found.
4 Case study 1: Password managers
We chose password managers as our primary case study
because the information they send over IPC is obviously
critical and, thus, it is easy to identify security violations.
Password managers help users to choose and remem-
ber strong passwords without reusing them [24]. They
store passwords along with the associated hostnames and
usernames in an encrypted password vault. The key
to the vault is typically derived from a master pass-
word. Password managers are often integrated to the
web browser and assist the user both by offering to cre-
ate and store passwords and by entering them into login
pages. We focus on password managers that consist of
two discrete components: a stand-alone app for manag-
ing the password vault and a browser extension for the
web-browser integration, as in Figure 2. We analyze the
inter-process communication between these two compo-
nents.
As the following sections will show, the MitMa at-
tacker is able to capture passwords and other conﬁden-
tial information from a large number of password man-
agers. What we ﬁnd interesting is that, in almost all
cases, the software developers have taken some mea-
sures to authenticate or encrypt the communication be-
tween the browser extension and the app. This shows
that they do not fully trust the security of the chosen IPC
method. Yet, none of the studied examples implements
well-designed cryptographic protection that would com-
pletely protect the communication from the MitMa at-
tacker. The main message of the current paper is to high-
light this ambivalent attitude towards IPC security and to
suggest a rethink.
1514    27th USENIX Security Symposium
USENIX Association
s
w
o
d
n
i
W
x Communication
u
n
i
L
channel
  N/A Network socket
  N/A Network socket
  N/A Network socket
  N/A Network socket
  N/A Named pipe
  N/A Network socket
S
O
c
a
Browser,
extension version m
Chrome, 8.4.3.6
Firefox, 8.4.3.4
Safari, 8.4.5
Chrome, 5.5.3
Firefox, 5.5.3
Safari, 5.5
Safari, 4.6.12
Chrome, 1.0.0.3
Firefox, 1.0.3
Chrome, 3.1.3434
Firefox, 3.1.3434
Chrome, 8.0.12.120
Firefox, 8.0.12.130
Safari, 8.0.2.63
Application
type
Application
version
RoboForm 8.4.4
Dashlane 5.1.0
1Password 6.8.4
F-Secure Key 4.7.114
Password Boss
3.1.3434
Sticky Password 8.0.4
FIDO U2F Key
DigiSign 4.0.12.5850
Blizzard 1.10.1.9799
Transmission 2.93
Spotify 1.0.73.345
MySQL 5.7.21
Keybase 1.0.40
Password
managers
Hardware
tokens
Backends with
HTTP API
Others
—
—
—
—
—
—
—


USB
 
Network socket
 
  N/A Network socket
Network socket
 
Network socket
 
Named pipe
 
Named pipe
 




Attacks
Client impersonation
Server impersonation
Server impersonation
Client impersonation
Server impersonation
Man-in-the-middle
Client impersonation
Server impersonation
Unauthorized access
Client impersonation
Client impersonation
Client impersonation
Client impersonation
Man-in-the-middle
Server impersonation
Table 2: Discovered vulnerabilities ( vulnerable,  not vulnerable)
4.1 Managers with network sockets
Many password managers use network sockets as the
IPC method because of its portability across operating
systems and browsers and compatibility with web APIs.
This section discusses the MitMa vulnerabilities found
in such implementations.
4.1.1 RoboForm
The RoboForm [7] password manager (S) and its browser
extension (E) communicate via the loopback network in-
terface with HTTP without any authentication. The pro-
tocol is basically as follows:
1. E → S: “list”
2. E ← S: [item id1,item id2, ...,item idn]
3. E → S: “getdataitem”, item idi
4. E ← S: itemi
The extension ﬁrst requests a list of all items stored in
the password vault by sending an HTTP POST request to
http://127.0.0.1:54512. The server replies with the
item identiﬁers, which consist of a type (e.g. password,
safenote) and name. To retrieve an item, the extension
sends a getdataitem request to the server, which re-
turns the item data in plaintext.
Attacks. Since there is no authentication between the
browser extension and the native app, a MitMa attacker
can impersonate the browser extension by simply con-
necting to the above URL. It can then retrieve all the
sensitive information from the user’s password vault.
4.1.2 Dashlane
in one, the
Dashlane [3] has two modes of operation:
browser extension retrieves passwords directly from a
cloud storage and, in the other, from a desktop app. We
only consider the latter operating mode. The Dashlane
app runs a WebSocket server on port 11456.
The WebSocket communication between the Dashlane
app (server) and the browser extension (client) is pro-
tected as follows. First, all messages are encrypted with
keys derived from a hard-coded constant secret and a
nonce, which is fresh for each message and included in
the message. Second, the server veriﬁes the browser-
extension id in the HTTP Origin header of each request.
Third, the server veriﬁes the client process by check-
ing its code-signing signature using APIs provided by
the operating system. The process must be a whitelisted
web browser and the signature must be generated by a
whitelisted software publisher. Fourth, the server checks
that the client process is owned by the same user as the
server.
A peculiar feature of Dashlane is that the browser ex-
tension collects all DOM elements from the web pages
USENIX Association
27th USENIX Security Symposium    1515
that the user visits and sends them to the app for anal-
ysis. The app then instructs the extension on actions to
take, such as to save the contents of a web form to the
app when the user submits it.
Attacks. The veriﬁcation of the browser binary and user
id prevented us from impersonating the web browser or
browser extension. However, it does not prevent imper-
sonation of the server to the browser extension. We ex-
plored what the MitMa attacker can achieve with server
impersonation. The attacker ﬁrst needs the shared con-
stant secret, which it can ﬁnd in the JavaScript code of
the browser extension. The attacker then runs its ma-
licious WebSocket server on port 11456 before the be-
nign server starts, which effectively forces the benign
server to fail over to another port (the user is not noti-
ﬁed about this). Since the attacker knows the encryption
keys, the browser extension will happily communicate
with the malicious server. As a result, the attacker ob-
tains all HTML content from the web pages that the vic-
tim visits. This includes personal data displayed on web
pages, such as emails and social-network messages. Fur-
thermore, the malicious app can instruct the extension to
collect web-form data and send the data to it. Then, any
usernames and passwords that the user types in are sent
to the malicious app regardless of whether the user wants
to save them to the vault or not.
4.1.3 1Password
1Password [1] app runs a WebSocket server on port
6263. The very ﬁrst time when the browser extension
communicates with the WebSocket server, the server ver-
iﬁes the client binary and user in the same way as Dash-
lane does. They then run the following protocol to agree
on a shared encryption key.
1. E → S: “hello”
2. E ← S: code (random 6-digit string)
3. E → S: hmac key
4. Both the browser and the app display the code. The user
compares the codes and conﬁrms to the app that they
match. Otherwise, the protocol restarts.
5. E ← S: “authRegistered”
6. E → S: nonceE
7. E ← S: nonceS,
8. E → S: mE = HMAC(hmac key,mS)
9. E ← S: “welcome”
mS = HMAC(hmac key,nonceS||nonceE )
Finally,
both sides derive the encryption key
which
K = HMAC(hmac key,mS||mE||“encryption”),
will be used to protect all future communication.
Attacks. The above protocol is clearly not a secure key
exchange. The checks on the client binary and user, how-
ever, protect against many attacks that otherwise could
exploit the protocol weaknesses. The remaining criti-
cal ﬂaw is that the protocol requires user conﬁrmation
only on the app side. This allows the attacker’s mali-
cious background process to skip the conﬁrmation step,
and the browser extension will happily connect to it.
Because of the above ﬂaw, the attacker can imperson-
ate the app to the browser extension, like in Dashlane. By
analyzing the JavaScript code of the 1Password browser
extension, we found commands that the app can issue to
the extension, such as collectDocuments, which tells
the browser extension to collect data on the page the user
is visiting including the URL and data entered into web
forms.
4.1.4 F-Secure Key
The F-Secure Key [4] app runs an HTTP server on the
localhost port 24166. If the port is already occupied by
another process, the server fails to run.
To start using the browser extension, the user needs
to cut and paste an authorization token from the app to
the extension. The secret token is then used to encrypt
parts of the messages exchanged between the app and
the extension, including usernames and passwords. Ad-