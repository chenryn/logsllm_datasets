一个相对较新的概念，它指向当前帧的底部。与S寄存器不同，在
一个程序的执行过程中它不会改变。1出于寻址的考虑，这个栈限
制为当前数据空间最初的32KB，而且与其他的机器不同，它会向上
增加。21除硬件栈之外，还有一个具有8个16位字的寄存器栈。这
些寄存器的号码从R0编到R7，但是，指令集把它们用作一个循环
栈，其中栈的顶部由环境寄存器的RP位定义。在下面这个例子中，
RP设置为3，这就意味着R3是栈的顶部，视为A寄存器（如图8-3所
示）。
1072
---
## Page 1074
RP
R7
E
E
011
R6
F
R5
G
R4
工
R3
A
R2
R1
C
RO
D
图8-3：寄存器栈
假设最初这个寄存器栈是“空"的，一个典型的指令序列如下所示：
LOADvar^a-把变量a压入栈（R0）
LOADvar~b-把变量b压入栈（R1）
ADD-把A和B（R1和R0）加起来，把结果保存在R0（A）中
STORvar^c-把A的值赋给变量c
指令的宽度都是16位，这没有为一个地址字段剩下许多空间：只有
9位。为了解决这个问题，Tandem基于一系列寄存器的偏移量进行
寻址（如图8-4所示）。
只有下列的内存区域可以直接定位（换句话说，不用间接寻址）：
·当前数据空间的前256个字，称为"G”（global）模式。这些经常用
于间接指针。
L寄存器正偏移的前128个字，称为L+。这些是当前程序调用的全
局变量，在C中，这些称为自变量。
·系统数据的前64个字（“SG+"模式）。系统调用运行在用户数据空
间，所以，CPU需要一些方法让授权的过程访问系统数据。对于没
1073
---
## Page 1075
有授权的过程来说，它们是不能访问的，甚至是只读的。
用户数据
LLLLL%
未使用的栈
局部数据
L
栈桢
调用参数
调用的过程
G
%377
全局数据
%0
系统数据
LL%
SG
系统数据
%0
图8-4：内存寻址
L寄存器当前值下方的前32个字。这包括调用者栈帧（3个字）和
传给过程的最多29个参数字。
·在这个栈顶部下方的前32个字（S-寻址）。它们用于子过程（在其
他过程中定义的过程），子过程调用不会剩下一个栈帧。因此，这
个地址既处理子过程的本地变量也处理子过程的参数。
这些地址模式都编码在指令地址字段的最初几位中，如图8-5所示。
1074
---
## Page 1076
偏移
Global (0:%377)
10
偏移
L+(0%177)
110
偏移
SG(0%77)
1110
偏移
L(%37:0)
1111
偏移
S-(%37:0)
图8-5：地址形式
%符号代表八进制数，如同%377等于十进制的255，或十六进制的
7F。Tandem没有使用十六进制。
这个指令形式也规定了单级的间接寻址：如果I位设置进指令，找回
的数据字会作为最终操作数的地址，它必须在相同的地址空间。这
个地址空间和数据字的宽度都是16位，所以，不存在多级间接寻址
的可能性。
这种实现的一个问题是数据的单位是一个16位的字，不是一个字
节。这个指令集也通过一个不同的寻址方法提供了“字节指令”：地
址的低位指定字中的字节，而地址的其余部分是这个字地址的低15
位。对于数据存取，这种方法把字节寻址限制到数据空间的前
32KB；对于代码存取，这种方法把字节存取限制到当前指令地址空
间的一半长。这导致一个过程不能越过代码空间中的32KB边界。
还有两个指令：LWP（从程序载入字）和LBP（从程序载入字
节），它们可以访问当前代码空间中的数据。
[1]这与21世纪大多数的处理器使用的通用指针寄存器相同。
[2]在20世纪70年代，栈是相当新的概念。如同它的前身HP3000，
Tandem对栈的支持明显超越了其他系统（例如，DEC的PDP-11，它
是那时候最有影响的基于栈的另一台机器）对栈的支持。
8.4.2过程调用
1075
---
## Page 1077
Tandem的编程模式受Algol和Pascal的很大影响，所以，它为返回一
个值的函数提供了保留字function，并为不返回值的函数提供了保留
字procedure。有两个指令用于调用一个过程：PCAL用于当前代码
空间中的过程，SCAL用于系统代码空间中的过程。SCAL实现了其
他架构中的系统调用的功能。
所有调用都是间接通过一个过程入口点表（ProcedureEntryPoint
Table，PEP），它占据了每个代码空间的前512个字。PCAL或SCAI
指令的最后9位是在这个表中的一个索引。这种方式有危险也有好
处：内核和用户代码使用完全相同的函数调用方法，这简化了编码
规则并容许代码在内核和用户空间之间相互移动。另一方面，至少
从理论上来说，SCAL指令使任何用户程序都能够调用任何内核函
数。
系统基于环境寄存器中的priv位来保护敏感过程的使用。它分为三
种过程：
非特权过程：任何过程都可以访问它，无论这些过程是否有权限。
特权过程：只有从其他有特权的过程中才可以访问它。
可调用过程：可以从任何过程中调用它，但是，一旦调用后就会设
置priv位。它们在特权过程和非特权过程之间提供了链接。
特权过程、非特权过程和可调用过程之间的区别取决于它们在PEP
中的位置。因此，在系统PEP（有时候称为SEP）中也可能存在非
特权库的过程。这张表的结构如图8-6所示。
1076
---
## Page 1078
特权过程
可调用过程
非特权过程
2
1
第一个priv
0
第一个可调用过程
图8-6：过程入口点表
8.4.3PCAL和SCAL指令的行为
PCAL指令完成下列行为：
如果环境寄存器中的priv位没有设置（意味着这个调用过程是非特
权的），检查"第一个priv"的值（代码空间的字为1）。如果指令中
的偏移量更大或相等，这个过程正在设法调用一个特权过程。生成
一个保护阀。
·如果环境寄存器中的priv位没有设置，检查“第一个可调用过程"的
值（代码空间的字为0）。如果指令中的偏移量更大或相等，设置
环境寄存器中的priv位。
把P寄存器（程序计数器）中当前的值压入栈。
把环境寄存器中原来的值压入栈。
把L寄存器当前的值压入栈。
1077
---
## Page 1079
把S寄存器（栈指针）复制到L寄存器。
把环境寄存器的RP字段设置为7（空）。
把这个指令定位的PEP字的内容载入P寄存器。
SCAL指令的工作方式完全相同，除此之外，它还设置环境寄存器
中的SC位，因而确保在内核空间中继续执行。数据空间不会改变。
PCAL和SCAL指令非常相似，程序员通常不必区分它们。由系统在
执行的时候区分它们。因此，库过程可以在用户代码和系统代码之
间相互移动而不必重新编译。
8.5处理器间总线
CPU之前的所有通信都通过处理器间总线（IPB）进行。实际上有两
条总线，称为X和Y（如图8-1所示），以防一条出故障。与其他的
组件不同，当两条总线正常时会并行使用。数据以长度固定为16字
的包的形式通过总线。总线的速度可以快到使两个CPU的内存满负
荷，所以，客户端CPU利用SEND指令在调度程序中同步地执行
它。目的（服务器）CPU在启动一个传输的时候为它预留缓存空
间。在传输完成时，目的CPU收到一个总线接收中断信号并处理这
个包。
8.6输入/输出
每个处理器都有一个最多有32个控制器的单I/O总线。所有的控制器
都采用双通道并连接到两个不同的CPU。任何时候，只有一个CPU
可以访问任意特定的控制器。在CPU和控制器之间的关系称为拥有
关系：控制的CPU“拥有"控制器。备份的通道不会使用，直到主通
道出故障或系统操作员手动切换到它（所谓的主切换）。
磁盘问题是一个特别敏感的问题，因为许多组件都可能出故障。出