$这样的简易正则表达式也很好用，它可以用来匹配空的（empty）字符串或行列。例
如在grep加上-v选项可以用来显示所有不匹配于模式的行，使用上面的微法，便能过
滤掉文件里的空（empty）行。
例如，C的源代码在经过处理后，变成了include文件与#define宏时，这种用法
就很有用了，因为这样一来你可以了解C编译器实际上看到的是什么（这是一种初级的
调试法，但有时你就是要这么微）。扩展文件（expandedfile）里头时常包含的空白或
空行通常会比原始码更多，因此要排除空行只要：
scc-foo.c1grep -vs>foo.out
预先期除空行
与S仅在BRE的起始与结尾处具有特殊用途。在BRE下，ab^cd里的^表示的，就
是自身（~）：同样地，efSgh里的s在这里表示的也就是字面上的货币字符。它也可能
与其他正则表达式连用，例如\与\$，或是【$]（注3）。
3.2.2.5BRE运算符优先级
在数学表达式里，正则表达式的运算符具有某种已定义的优先级（precedence），指的是
某个运算符（优先级较高）将比其他运算符先被处理，表3-5提供BRE运算符的优先
级—由高至低。
表3-5：BRE运算符优先级，由高至低
运算符
表示意义
[..] [==][：:]
用于字符排序的方括号符号
\metacharacter
转义的meta字符
注 3:
[^]并非有效的正则表达式，请确认你了解是为什么。
www.TopSage.com
---
## Page 68
56
第3章
表3-5：BRE运算符优先级，由高至低（续）
运算符
在我式表意文
[]
方括号表达式
[\）\digit
子表达式与后向引用
前置单个字符重现的正则表达式
无符号（no symbol)
连续
$
锚点（Anchors）
3.2.3扩展正则表达式
ERE（Extended Regular Expressions）的含义就如同其名字所示：拥有比基本正则表达
式更多的功能。BRE与ERE在大多数meta字符与功能应用上几乎是完全一致，但ERE
里有些meta字符看起来与BRE类似，却具有完全不同的意义。
3.2.3.1匹配单个字符
在匹配单个字符的情况下，ERE本质上是与BRE是一致的，特别是像一般字符、用以转
义meta字符的反斜杠，以及方括号表达式，这些行为模式都与先前提及的BRE相同。较
有名的一个例外出现在awk里：其、符号在方括号表达式内表示其他的含义。固此，如
需匹配左方括号、连字符、右方括号或是反斜杠，你应该用【\\-\1\\]。这是使用上
的经验法则。
3.2.3.2后向引用不存在
ERE里是没有后向引I用的（注4）。圆括号在ERE里具特殊含义，但和BRE里的使用又
有所不同（这点稍后会介绍），在ERE里，\（与\）匹配的是字面上的左括号与右括号。
3.2.2.3匹配单个表达式与多个正则表达式
ERE在匹配多字符这方面，与BRE有很明显的不同，不过，在*的处理上和BRE是相
同的（注5）。
注 4;
这在grep与egrep命令下有不间的影响，这并非正则表达式匹配能力的问题，只是UNIX
的一种处理方式而巴。
注 5:
看的·*
www.TopSage.com
---
## Page 69
查找与替换
57
区间表达式可用于ERE中，但它们是写在花括号里（（1），且不需前置反斜杠字符。因
与q（1042）。而\（与\)则可用以匹配字面上的花括号，当在ERE里（找不到匹配的
)时，POSIX特意保留其含义为“未定义（undefFined）状态”，
ERE另有两个meta字符，可更细腻地处理匹配控制：
？
匹配于0个或一个前置正则表达式
匹配于1个或多个前置正则表达式
你可以把？想成是“可选用的”，也就是说，匹配前置正则表达式的文本，要么出现，要
么没出现，举例来说，与ab?e匹配的有ac与abc，就这两者！”（与ab*e相较之下，
后者匹配于中间有任意个b）。
+字符在概念上与*meta字符类似，不过前置正则表达式要匹配的文本在这里至少得出
现一次。因此，ab+e匹配于abc、abbc、abbbc，但不匹配于ac。你当然可以把ab+e
的正则表达式形式换成abb*c：无论如何，当前置正则表达式很复杂时，使用+可以少
打一点字，当然也减少了打错字的几率！
3.2.3.4交替
方括号表达式易于表示“匹配于此字符，或其他字符，或”，但不能指定“匹配于这
个序列（sequence），或其他序列（sequence），或”，要达到后者的目的，你可以使用
交替（alternation）运算符，即垂直的一条线，或称为管道字符（1）。你可以简单写好
两个字符序列，再以1将其隔开。例如readlwrite匹配于read与write两者、fat丨8low
匹配于fast与s1ow两者。你还可以使用多个该符号：eleepldozeldreamlnod
offlalumber匹配于5个表达式。
1字符为ERE运算符里优先级最低的。因此，左边会一路扩展到运算符的左边，一直到
一个前置1的字符，或者是到另一个正则表达式的起始。同样地，1的右边也是一路扩
展到运算符的右边，一直到后续的：字符，或是到整个正则表达式的结尾。这部分将在
下→节探讨。
3.2.3.5分组
你应该已经发现，在ERE里，我们已提到运算符是被应用到“前置的正则表达式”。这
是因为有圆方括号（（...））提供分组功能，让接下来的运算符可以应用，举例来说，
（why）+匹配于一个或连续重复的多个why.
www.TopSage.com
---
## Page 70
8S
第3常双
在必须用到交替（altermation）时，分组的功能就特别好用了（也是必需的）它可以让OIm
你用以构建复杂并较灵活性的正则表达式。举例来说，[Tt】he（CPUlcomputer）is
指的就是：在The（或the）与is之间，含有cPU或computer的句子。要特别注意
的一点是，圆括号在这里是meta字符，而非要匹配的输人文本。
将重复（repetition）运算符与交替功能结合时，分组功能也是一定用得到的。
readlwrite+指的是正好一个read，或是一个write后面接着任意数个e字符
（writee、writeee等），比较有用的模式应该是（zeadlwrite）+，它指的是：有一个
或重现多个read，或者一个或重现多个write。
当然，（readlwrite）+所指的字符串中间，不允许有空白。（（readlwzite）
[[：Bpace：]]*）+的正则表达式看起来虽然比较复杂，不过也比较实际些。乍看之下，
这可能会搞不清楚，不过若把这些组成部分分隔开来看，其实就不难理解了，图3-1为
图解说明。
(something1)+
something1一次或多次出现
（something2)[:space：]]*something1是something2.
可能跟看一个空格字符
read|write
something2是“ed“或“write
图3-1：读取一个复杂的正则表达式
结论就是：这个单个正则表达式是用以匹配多个连续出现的read或是write，且中间
可能被空自字符隔开。
在（[：space：]]之后使用*是一种判断调用（judgmentcall）。使用一个*而非+，此
匹配可以取得在行（或字符串）结尾的单词。但也可能可以匹配中间完全没有空白的单
词。运用正则表达式时常会需要用到这样的判断调用（judgmentcall）。该如何构建正
则表达式，需要根据输人的数据以及这些数据的用途而定。
最后要说的是：当你将交替（alternation）操作结合与$锚点字符使用时，分组就非
常好用了。由于1为所有运算符中优先级最低的，因此正则表达式^abcdlefgh$意思是
“匹配字符串的起始处是否有abcd，或者字符串结尾处是否有efgh”，这和
*（abcdlefgh）s不一样，后者表示的是“找一个正是abcd或正是efgh的字符串”。
www.TopSage.com
---
## Page 71
查找与替换
59
3.2.3.6停驻文本匹配
与S在这里表示的意义与BRE里的相同：将正则表达式停驻在文本字符串（或行）的
以，像ab^cd与ef$gh这样的正则表达式仍是有效的，只是无法匹配到任何东西，因
为前置了文本，与$后面的文本，会让它们分别无法匹配到“字符串的开始”与“字
符串结尾”。正如其他的meta字符一般，它们在方括号表达式中的确失去了它们特殊的
意义。
3.2.3.7ERE运算符的优先级
在ERE里运算符的优先级和BRE一样。表3-6由高至低列出了ERE运算符的优先级。
表3-6：ERE运算符优先级，由高至低
运算符
[..] [= =] [: :]
用于字对应的方括号符号
\metacharacter
转义的meta字符
[]
方括号表达式
()
分组
* + ? ()
重复前置的正则表达式
无符号（nosymbol）
连续字容
S
镇点（Anchors）
1
交替（Alternation）
3.2.4正则表达式的扩展
很多程序提供正则表达式语法扩展，这类扩展大多采取反斜杠加一个字符，以形成新的
运算符。类似POSIXBRE里\（..\）与\（..\）的反斜杠。
最常见的扩展为\运算符，分别匹配“单词（word）”的开头与结尾。单词是由
字母、数字及下划线组成的。我们称这类字符为单词组成（word-constituent）。
单词的开头要么出现在行起始处，要么出现在第一个后面紧眼一个非单词组成
（nonword-constituent）字符的单词组成（word-constituent）字符。同样的，单词的结
尾要么出现在一行的结尾处，要么出现在一个非单词组成字符之前的最后一个单词组成
字符。
实际上，单词的匹配其实相当直接易懂，正则表达式\则匹配于第二个字符串，第一个期不
匹配。需要特别注意的一点是：在\的表达式下，两个字符串都不匹配。
虽然POSIX标准化的只有ex编辑器，但在所有商用UNIX系统上，ed、ex以及vi编
辑器都支持单词匹配，而且几乎已是标准配备。GNU/Linux与BSD系统上附带的克隆
程序（"clone”version）也支持单词匹配，还有emacs、vim与vile也是。除此之外，
通常grep与sed也会支持，不过最好在系统里再通过手册页（manpage）确认一下。
可处理正则表达式的标准工具的GNU版本，通常还支持许多额外的运算符，如表3-7所
示。
表3-7：额外的GNU正则表达式运算符
运算符
含义
匹配任何单词组成字符，等同于[[：alnum：1_]
\W
匹配任何非单词组成字符，等同于[^[：alnum：]_]
1
匹配单词的起始与结尾，如前文所述
\b
匹配单词的起始或结尾处所找到的空字符串。这是\运算符的赔合
注意：由于awk使用\b表示后退字符，因此GNUawk（gawk）使用\y表
示此功能
\B
匹配两个单词组成字符之间的空字符事
分别匹配enacs缓冲区的开始与结尾。GNU程序（还有emacs）通常将它们
视为与及$同义
虽然POSIX明白表示了NUL字符无须是可匹配的，但GNU程序则无此限制。若NUL
字符出现在输人数据里，则它可以通过.meta字符或方括号表达式来匹配。
3.2.5程序与正则表达式
有两种不同的正则表达式风格是经年累月的历史产物。虽然egrep风格的扩展正则表达
式在UNIX早期开发时就已经存在了，但KenThompson并不觉得有必要在ed编辑器
里使用这样全方位的正则表达式（由于PDP-11的小型地址空间、扩展正则表达式的复
杂度，以及实际应用时大部分的编辑工作使用基本正则表达式已足够了，这样的决定其
实相当合理）。
ed的程序代码后来成了gxep的基础（grep为ed命令中g/re/p的缩写，意即全局
性匹配re，并将其打印）。ed的程序代码后来也成为初始构建sed的根基。
www.TopSage.com
---
## Page 73
查找与替换
就在pre-V7时期，A1Aho创造了egrep，AlAho是贝尔实验室的研究人员，他为正COIm
则表达式匹配与语言解析的研究英定了基础。egrep里的核心匹配程序代码，日后也被
awk的正则表达式拿来使用。
\运算符起源于滑铁卢大学的Rob Pike、Tom Duff、HughRedelmeier，以及
David Tilbrook所修改的ed版本（Rob Pike是这些运算符的发明者之一）。Bill Joy在
UCB时，便将这两个运算符纳入ex与vi编辑器，自那时起，它就广为流传。区间表
达式源起于Programmer'sWorkbenchUNIX（注6），之后通过SystemIII以及此后的
SystemV，特别将其取出用于商用UNIX系统上，表3-8列出的是各种UNIX程序与其
使用的正则表达式。
表3-8：UNIX程序及其正则表达式类型
类型
ppdoxb
ex/vi
more
BRE
*
ERE
√
1ex是一个很特别的工具，通常是用于语言处理器中的词法分析器的构建。虽然已纳人
POSIX，但我们不会在这里进一步讨论，因为它与Shell1脚本无关。1ess与pg虽然不
是POSIX的一部分，但它们也支持正则表达式。有些系统会有page程序，它本质上和
more是相同的，只是在每个充满屏幕的输出画面之间，会清除屏幕
正如我们在本章开头所提到的：要（试图）解决多个grep的矛盾，POSIX决定以单个
grep程序解决。POSIX的grep默认行为模式使用的是BRE，加上-E选项则它使用
ERE，及加上-F选项，则它使用fgrep的固定字符串匹配算法，因此，真正地遵循POSIX
的程序应以grep-E...取代egrep....不过，因为所有的UNIX系统确实拥有它，
且可能已经有许多年了，所以我们继续在自己的脚本中使用它。
最后要注意的一点就是：通常，awk在其扩展正则表达式里不支持区间表达式。直至
2005年，各种不同厂商的awk版本也并非全面支持区间表达式。为了让程序具有可移
植性，若需要在awk程序里匹配大方括号，应该以反斜杠转义它，或将它们括在方括号
表达式里。
6
Programmer'sWorkbench（PWB）UNIX是用在AT&T里以支持电信交换软件开发的变
化版。它电可以用于商业用途。
www.TopSage.com