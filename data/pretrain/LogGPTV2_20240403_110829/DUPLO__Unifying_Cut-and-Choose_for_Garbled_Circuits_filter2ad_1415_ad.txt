ğ‘ âˆˆ ğ„ğ±ğ©(ğ”¹), ğ‘˜ âˆˆ ğ„ğ±ğ©(ğ•‚).
view of ğ‘’ to an adversary that can decrypt under (all and
only) the keys in ğ‘†.
âˆ™ A function ğ«(ğ‘) mapping a pattern ğ‘ to a corresponding
set of keys, which may be recoverable by an adversary
that sees all the parts of ğ‘.
The deï¬nition of these functions is virtually identical to the
one given in [18] for expressions with pseudorandom keys,
extended with an additional case for our â€œcontrolled swapâ€
expressions. Informally, ğ©(ğ‘’, ğ‘†) replaces all subexpressions of
ğ‘’ of the form â¦ƒğ‘’â€²â¦„ğ‘˜ for some ğ‘˜ âˆ‰ ğ‘† and ğ‘’â€² âˆˆ ğğšğ­(ğ‘ ), with
the pattern â¦ƒğ‘ â¦„ğ‘˜. The formal deï¬nition is given in Fig. 1.
The formal deï¬nition of ğ« is more technical, and uses the
auxiliary functions ğŠğğ²ğ¬ and ğğšğ«ğ­ğ¬ describing the keys and
parts of an expression given in Fig. 2. As a matter of notation,
for any two expressions ğ‘’â€² and ğ‘’, we say that ğ‘’â€² is a sub-
expression of ğ‘’, denoted as ğ‘’â€² â‹ ğ‘’, if ğ‘’â€² âˆˆ ğğšğ«ğ­ğ¬(ğ‘’). Notice that
encryption keys ğ‘˜ are not considered sub-expressions ofâ¦ƒğ‘’â¦„ğ‘˜,
cannot, in general, recover ğ‘˜ from â¦ƒğ‘’â¦„ğ‘˜. Informally, ğ«(ğ‘’) is
as, even an adversary with unlimited decryption capabilities
deï¬ned as the set of all keys that can be potentially recov-
ered from ğğšğ«ğ­ğ¬(ğ‘’). In [18], this is deï¬ned using a general
framework to model partial information in symbolic security
analysis. For simplicity, here we only give the deï¬nition
specialized to our class of expressions.
Deï¬nition 3. For any ğ‘’ âˆˆ ğğšğ­, we deï¬ne the key recovery
)
function ğ« âˆ¶ ğğšğ­ â†’ â„˜(ğğšğ­(ğ•‚)) as follows:
ğ«(ğ‘’) = ğ–¦âˆ—
{ğ‘˜ âˆˆ ğŠğğ²ğ¬(ğ‘’) âˆ£ (ğ‘˜ â‹ ğ‘’) âˆ¨ (âˆƒğ‘˜â€² âˆˆ ğŠğğ²ğ¬(ğ‘’).ğ‘˜ â‰º ğ‘˜â€²)}
Informally, ğ«(ğ‘’) contains all keys ğ‘˜ from ğŠğğ²ğ¬(ğ‘’) (and
pseudorandom keys that can be derived from ğ‘˜) such that
either ğ‘˜ appears in ğ‘’ as a sub-expression, or ğ‘˜ is related to
(
some other key in ğŠğğ²ğ¬(ğ‘’). The intuition behind this deï¬nition
is that the adversary can learn a key ğ‘˜ either by reading it
directly from the parts of ğ‘’, or by combining diï¬€erent pieces
of partial information about ğ‘˜. We refer the reader to [18] for
further discussion and justiï¬cation of this deï¬nition.
One can check by induction that the following commutative
properties hold for ğ© and ğ«: For any pattern ğ‘’ âˆˆ ğğšğ­, set
of keys ğ‘† âŠ† ğŠâˆ—, and pseudorandom renaming ğ›¼, we have
ğ›¼(ğ©(ğ‘’, ğ‘†)) = ğ©(ğ›¼(ğ‘’), ğ›¼(ğ‘†)), and ğ›¼(ğ«(ğ‘’)) = ğ«(ğ›¼(ğ‘’)).
h) Computational soundness: We can now return to
the framework of [12] to associate computationally sound
symbolic patterns to cryptographic expressions. The functions
ğ© and ğ« are used to deï¬ne, for any ğ‘’ âˆˆ ğğšğ­, a key recovery
operator
ğ‘’(ğ‘†) = ğ«(ğ©(ğ‘’, ğ‘†))
mapping any set of keys ğ‘† âŠ† ğ–¦âˆ—(ğŠ), to the set of keys
potentially recoverable by an adversary that
is capable of
decrypting under the keys in ğ‘†. This operator is used in [12]
to prove the following general computational soundness result.
Theorem 2 ([12, Theorem 1]). Assume the functions ğ©, ğ«
satisfy the following properties:
1) ğ©(ğ‘’, ğŠâˆ—) = ğ‘’
2) ğ©(ğ©(ğ‘’, ğ‘†), ğ‘‡ ) = ğ©(ğ‘’, ğ‘† âˆ© ğ‘‡ ) for all ğ‘†, ğ‘‡ âŠ† ğŠâˆ—
3) ğ«(ğ©(ğ‘’, ğ‘‡ )) âŠ† ğ«(ğ‘’) for all ğ‘‡ âŠ† ğŠâˆ—
4) The distributions (cid:2)ğ‘’(cid:3) and (cid:2)ğ©(ğ‘’, ğ«(ğ‘’))(cid:3) are computation-
ally indistinguishable.
Then, the key recovery operator ğ‘’ has a (unique) greatest
ï¬xed point Fix(ğ‘’) = âˆ©ğ‘–>0 (ğ‘–)
ğ‘’ (ğŠâˆ—), and the pattern
ğğšğ­ğ­ğğ«ğ§(ğ‘’) = ğ©(ğ‘’, Fix(ğ‘’))
is computationally sound, in the sense that (cid:2)ğğšğ­ğ­ğğ«ğ§(ğ‘’)(cid:3) and
(cid:2)ğ‘’(cid:3) are computationally indistinguishable distributions.
One can check that the functions ğ© and ğ« satisfy all the
conditions 1 to 3 in Theorem 2. For the last condition, the
following lemma shows that (cid:2)ğ‘’(cid:3) and (cid:2)ğ©(ğ‘’, ğ«(ğ‘’))(cid:3) are indis-
tinguishable for all patterns ğ‘’. The proof is omitted due to
space constraint. Using the soundness theorem of the general
symbolic framework of [12] we can then conclude that our
symbolic semantics is computationally sound.
Lemma 3. For any ğ‘’ âˆˆ ğğšğ­, the probability distributions (cid:2)ğ‘’(cid:3)
and (cid:2)ğ©(ğ‘’, ğ«(ğ‘’))(cid:3) are computationally indistinguishable.
Recall that renamings commute with the pattern function
ğ©, i.e., for any expression ğ‘’ and for any set of keys ğ‘† âŠ† ğŠâˆ—,
ğ©(ğ›¼(ğ‘’), ğ›¼(ğ‘†)) = ğ›¼(ğ©(ğ‘’, ğ‘†)). It follows that ğğšğ­ğ­ğğ«ğ§(ğ›¼(ğ‘’)) =
ğ›¼(ğğšğ­ğ­ğğ«ğ§(ğ‘’)), and therefore we can extend the computational
soundness theorem to pattern equivalence up to renaming. That
is, for any two expressions ğ‘’1 and ğ‘’2, symbolic equivalence
(up to pseudorandom renaming) of their patterns ğğšğ­ğ­ğğ«ğ§(ğ‘’1)
and ğğšğ­ğ­ğğ«ğ§(ğ‘’2) implies that the two probability distributions
(cid:2)ğ‘’1(cid:3) and (cid:2)ğ‘’2(cid:3) are computationally indistinguishable.
Theorem 3. For any two symbolic expressions ğ‘’0, ğ‘’1,
if
ğğšğ­ğ­ğğ«ğ§(ğ‘’0) â‰ˆ ğğšğ­ğ­ğğ«ğ§(ğ‘’1), then (cid:2)ğ‘’0(cid:3) and (cid:2)ğ‘’1(cid:3) are compu-
tationally indistinguishable.
152
III. INDUCTIVE CIRCUITS
ğ‘–=1 and wires {ğ‘¤ğ‘–}ğ‘
Traditionally, boolean circuits are described by two sets of
gates {ğ‘”ğ‘–}ğ‘
ğ‘–=1 and a description of how they
are connected together. Each wire carries a boolean value, that
is either given as part of the input to the circuit, or is computed
by a gate. Each gate is associated to a number of input and
output wires, and sets the value of the output wires to some
ï¬xed function of the values of the input wires. For simplicity,
we consider circuits using just two types of gates:
S
Swap
A
U
Assoc
Unassoc
D
Dup
â†‘N
NAnd
âˆ™ a NAND gate that on input two boolean values ğ‘¥0, ğ‘¥1,
computes the output ğ‘¦ = ğ‘¥0 â†‘ ğ‘¥1, and
âˆ™ a DUP gate, which duplicates the value on its single input
wire ğ‘¥ to its two output wires ğ‘¦0 = ğ‘¦1 = ğ‘¥.
The NAND function itself is complete for the set of all
boolean functions, and the DUP gate can be used to implement
arbitrary fan-out. So any boolean circuit can be converted to
this notation. A circuit with ğ‘› input wires and ğ‘š output wires
computes a boolean function ğ‘“ âˆ¶ {0, 1}ğ‘› â†’ {0, 1}ğ‘š
.
This traditional formalization of circuits is completely un-
structured, making it inconvenient to use in symbolic construc-
tions and proofs of security. Below we present an alternative
way to describe boolean circuits, which is inductive (larger
circuits are built from smaller ones), and supports deï¬nitions
and proofs by structural induction.
We begin by putting some structure on the set of input and
output wires of a circuit, by deï¬ning the notion of a wire
bundle. Informally, the shape of a wire bundle is deï¬ned by
a well parenthesized expression like (â—¦, (â—¦, â—¦)). Formally, we
can deï¬ne bundle to be either a single wire (represented by
the symbol â—¦), or an ordered pair (ğ‘¢, ğ‘£) where ğ‘¢ and ğ‘£ are wire
bundles. The size of a bundle is simply the number of wires
in it, i.e., the number of â—¦ subexpressions. Each wire â—¦ carries
a bit ğ‘ âˆˆ {0, 1}, and a bundle of ğ‘› wires naturally carries a
bit vector in {0, 1}ğ‘›
, but the additional bundle structure will
give us easier access to individual bits, without having to index
them. We remark that the grouping of wires is not associative,
i.e., ((ğ‘¢, ğ‘£), ğ‘¤) is diï¬€erent from (ğ‘¢, (ğ‘£, ğ‘¤)).
We deï¬ne circuits inductively, specifying a number of
basic circuits, and some general operations to combine them
together. Each circuit takes as input a bundle of wires, and
produces as output another bundle. The set of circuits with
input shape ğ‘  and output shape ğ‘¡ is denoted by Circuit(ğ‘ , ğ‘¡).
Circuits,
their inputs and outputs, and the functions they
compute, are formally speciï¬ed in the following deï¬nition,
with the base and inductive cases illustrated in Fig. 3 and 4.
Deï¬nition 4. A circuit
from the
set {ğ’ğ°ğšğ©, ğ€ğ¬ğ¬ğ¨ğœ, ğ”ğ§ğšğ¬ğ¬ğ¨ğœ, ğƒğ®ğ©, ğğ€ğ§ğ}, or it is a composite
circuit built using operations â‹™ and ğ…ğ¢ğ«ğ¬ğ­. The semantics of
basic circuits are:
is either a basic circuit
((ğ‘¢, ğ‘£), ğ‘¤).
âˆ™ ğ’ğ°ğšğ© consumes wires (ğ‘¢, ğ‘£) and produces wires (ğ‘£, ğ‘¢).
âˆ™ ğ€ğ¬ğ¬ğ¨ğœ consumes wires (ğ‘¢, (ğ‘£, ğ‘¤)) and produces wires
âˆ™ ğ”ğ§ğšğ¬ğ¬ğ¨ğœ consumes wires ((ğ‘¢, ğ‘£), ğ‘¤) and produces wires
âˆ™ ğƒğ®ğ© consumes a single wire ğ‘¤ and produces wires (ğ‘¤, ğ‘¤).
(ğ‘¢, (ğ‘£, ğ‘¤)).
Fig. 3. The atomic circuits ğ’ğ°ğšğ©, ğ€ğ¬ğ¬ğ¨ğœ, ğ”ğ§ğšğ¬ğ¬ğ¨ğœ, ğƒğ®ğ©, and ğğ€ğ§ğ. The
dotted lines indicate how values are transferred from input wires to output
wires. For ğ’ğ°ğšğ©, ğ€ğ¬ğ¬ğ¨ğœ, and ğ”ğ§ğšğ¬ğ¬ğ¨ğœ, an arrow may represent a bundle of
more than one wires.
ğ¶0
ğ¶1
ğ¶0 â‹™ ğ¶1
ğ¶
ğ…ğ¢ğ«ğ¬ğ­(ğ¶)
Fig. 4. Composite circuits ğ¶0 â‹™ ğ¶1 and ğ…ğ¢ğ«ğ¬ğ­(ğ¶) using operations â‹™ and
ğ…ğ¢ğ«ğ¬ğ­ on circuits ğ¶0, ğ¶1, ğ¶. Dotted lines draw the boundaries of composite
circuits.
âˆ™ ğğ€ğ§ğ consumes wires (ğ‘¢, ğ‘£), where ğ‘¢ and ğ‘£ are single
wires carrying bits ğ‘¥ and ğ‘¦, and its output is a single
wire that carries the bit ğ‘¥ â†‘ ğ‘¦.
For composite circuits, assume ğ¶0 is a circuit that takes ğ‘¢
as input wires and produces output wires ğ‘¤, and ğ¶1 a circuit
that takes ğ‘¤ as input wires and produces output wires ğ‘£. Then
âˆ™ ğ¶0 â‹™ ğ¶1 is a circuit that takes input ğ‘¢ and produces
output ğ‘£, obtained by ï¬rst applying ğ¶0 on ğ‘¢ to get an
intermediate result ğ‘¤, and then applying ğ¶1 on ğ‘¤ to get ğ‘£.
âˆ™ ğ…ğ¢ğ«ğ¬ğ­(ğ¶0) is a circuit that takes input wires (ğ‘¢, ğ‘¢â€²) and
produces output wires (ğ‘¤, ğ‘¢â€²) for any wires ğ‘¢â€², where ğ‘¤
is the output of ğ¶0 on input ğ‘¢, and ğ‘¢â€² is left unchanged
by the circuit.
To evaluate a circuit, we deï¬ne the function ğ„ğ¯(ğ¶, ğ‘¤) that
takes a circuit ğ¶ âˆˆ Circuit(ğ‘ , ğ‘¡) and a wire bundle ğ‘¤ of shape
ğ‘ , and return a bundle of shape ğ‘¡ according to the above
semantics. For simplicity, we usually just write ğ¶(ğ‘¥) for the
boolean value carried on the wires ğ‘¢ = ğ„ğ¯(ğ¶, ğ‘¤) where ğ‘¥ is
the value carried on ğ‘¤.
We remark that the circuit concatenation operation â‹™ is
associative, i.e., (ğ¶0 â‹™ ğ¶1) â‹™ ğ¶2 and ğ¶0 â‹™ (ğ¶1 â‹™ ğ¶2)
produce the same circuit. So, we may omit the parentheses
when writing a sequence of concatenations ğ¶0 â‹™ ğ¶1 â‹™ ğ¶2.
For a circuit ğ¶, we say that ğ¶â€² is a sub-circuit of ğ¶ if one
of the following holds: