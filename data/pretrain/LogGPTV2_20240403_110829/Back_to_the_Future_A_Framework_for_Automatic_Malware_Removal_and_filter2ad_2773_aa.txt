# Title: Back to the Future: A Framework for Automatic Malware Removal and System Repair

## Authors:
- Francis Hsu
- Hao Chen
- Thomas Ristenpart
- Jason Li
- Zhendong Su

### Abstract
Malware, software with malicious intent, has become a widespread threat to system security. Detecting malware reliably is challenging due to the frequent emergence of new and polymorphic malware programs. Additionally, removing malware and repairing its damage to the system is difficult because it can extensively modify the system.

We propose a novel framework for automatically removing malware and repairing its damage to a system. The primary goal of our framework is to preserve system integrity. Our framework monitors and logs the operations of untrusted programs. Using these logs, it can completely remove malware programs and their effects on the system. Our framework does not require signatures or prior knowledge of malware behavior. We implemented this framework on Windows and evaluated it with seven types of malware, including spyware, trojan horses, and email worms. Comparing our tool with two popular commercial anti-malware tools, we found that our tool detected all the malware modifications identified by the commercial tools, but the commercial tools overlooked up to 97% of the modifications detected by our tool. The runtime and space overhead of our prototype tool are acceptable. Our experience suggests that this framework offers an effective new defense against malware.

### 1. Introduction
Malware has become an epidemic problem. Recent studies have shown that a significant number of computers running Windows in major research universities and other environments are infected with one or more malware programs [19, 15]. One major reason for the proliferation of malware is the diversity of software applications and vendors. Many cutting-edge applications come from vendors with questionable reputations, and some P2P applications often carry adware or spyware that is difficult to remove [8].

The most common defense against malware is detection. However, since most detectors rely on static signatures of known malware, they cannot reliably detect new or polymorphic malware. Users may also ignore or disable working detection programs to install and run malware-bundled applications. As malware accumulates, the computer often becomes unusable due to slow response times, exhausted storage, and frequent application crashes. Even good malware detectors cannot fully protect users from running malware.

When a user cannot avoid running malware, the next defense is to remove it once the adverse effects are noticed. Common approaches include:

- **Running an anti-malware program:** This approach relies on known malware signatures and cannot reliably remove new or polymorphic malware, nor can it restore infected data.
- **Taking periodic snapshots of the system:** This involves restoring the system to the last clean snapshot, which can destroy new, clean data created after the snapshot.
- **Formatting the disk and reinstalling the operating system:** This drastic approach destroys all user data and configurations but is often advised when other methods fail to remove all malware components.

To address these issues, we introduce "Back to the Future," a framework that can remove all components of both known and unknown malware, restore infected data while preserving clean data, and require minimal user intervention. The framework monitors and logs the operations of untrusted programs designated by the user. It can then remove all components of the untrusted programs and restore infected data at the user’s request. If an untrusted program turns out to be malware, the framework can remove all its components and restore all infected files automatically. We name this framework "Back to the Future" because it conceptually rolls back the system to a prior good state and then brings only the trusted processes back to their pre-recovery state.

The primary security goal of our framework is to preserve the integrity of the system while the user runs potentially harmful programs. In some cases, our framework can also provide availability by freeing resources usurped by malware. Our framework does not aim to provide confidentiality, but it can incorporate user-indicated confidential information and stop running malware before it discloses such information. Unlike typical sandboxing environments, our framework does not require specific rules about allowed operations.

### 2. Framework

#### 2.1. Overview
Figure 1 illustrates the three components of Back to the Future: a monitor, a logger, and a recovery agent. The monitor intercepts read and write operations of monitored processes. The logger records the write operations of untrusted processes. When the monitor determines that an untrusted process may harm a trusted process, it invokes the recovery agent to restore system integrity.

Our framework addresses two main challenges:
1. Determining when an untrusted program may violate system integrity.
2. Removing all effects of an untrusted program.

#### 2.2. System Integrity

##### 2.2.1. Integrity Model
We start with Biba’s integrity model, which states that no subject can read objects of lower integrity levels, and no subject can write objects of higher integrity levels. Our framework defines two integrity levels: trusted and untrusted. Applying Biba’s model, our framework requires that trusted processes should not read untrusted data, and untrusted processes should not write trusted data.

Strictly following Biba’s model limits the user's ability to run untrusted programs. For example, the framework would have to stop an untrusted process immediately if it tries to overwrite trusted data. However, if no trusted process will ever read this data again (e.g., temporary scratch data), stopping the untrusted process is unnecessary. Therefore, we adopt a relaxed integrity model that only requires no trusted process to read untrusted data, but allows untrusted processes to freely write any data. This model can be viewed as a lazy Biba’s model, enforcing integrity only when untrusted data could flow into trusted processes.

##### 2.2.2. Preserving System Integrity
To preserve system integrity, the framework must intervene when a trusted process is about to read untrusted data. A good intervening approach should:
- Preserve the consistency of processes: The approach should not change the behavior of the process.
- Allow processes to run as long as possible: The approach should allow a process to run until it cannot preserve system integrity or the consistency of some processes.

We propose the following options for preserving system integrity:
- **Deny the operation:** Deny the read operation and terminate the trusted process.
- **Allow the operation:**
  - **Terminate the untrusted process:** Terminate the untrusted process that wrote the untrusted data, and restore the old data. Repeat this until the restored data is trusted.
  - **Mark the trusted process as untrusted:** Treat the trusted process as untrusted and allow the read operation to continue.

Sometimes, we may want to preserve good effects of untrusted applications. For example, media files downloaded by malware-laden P2P applications can be marked as trusted if the user is confident they will not affect trusted applications.

#### 2.3. System Recovery

##### 2.3.1. Basic Approach for System Recovery
During monitoring, the framework logs all write operations of both trusted and untrusted processes. During recovery, the framework first reverses all logged operations reverse-chronologically and then reapplies all logged operations of only the trusted processes chronologically. This approach ensures that the system appears as if the untrusted processes had never run. However, it is inefficient because it undoes and redoes many write operations of trusted processes.

##### 2.3.2. Refined Approach for System Recovery
We refine the basic approach by avoiding unnecessary recovery operations. For example:
- **Example 1:** If a trusted process T writes before an untrusted process U, during recovery, the framework only needs to undo U’s write operation.
- **Example 2:** If U writes before T, the framework does not need to undo either U’s or T’s write operation because T’s trusted data has overwritten U’s untrusted data.

This refined approach tracks whether each location contains trusted or untrusted data. During monitoring:
- When a trusted process writes to a data location, mark the new data as trusted.
- When an untrusted process writes to a location, mark the new data as untrusted.

By tracking the order of writes and the trust status of data, the framework can efficiently remove the effects of untrusted processes and restore the system to a trusted state.