title:Back to the Future: A Framework for Automatic Malware Removal and
System Repair
author:Francis Hsu and
Hao Chen and
Thomas Ristenpart and
Jason Li and
Zhendong Su
Back to the Future: A Framework for Automatic Malware Removal
and System Repair ⁄
Francis Hsu
Hao Chen
Thomas Ristenparty
University of California, Davis
Jason Liz
Zhendong Su
ffhsu,hchen,ristenpa,lija,PI:EMAIL
Abstract
Malware, software with malicious intent, has emerged
as a widely-spread threat to system security. It is di–cult to
detect malware reliably because new and polymorphic mal-
ware programs appear frequently. It is also di–cult to re-
move malware and repair its damage to the system because
it can extensively modify a system.
We propose a novel framework for automatically remov-
ing malware from and repairing its damage to a system.
The primary goal of our framework is to preserve system
integrity. Our framework monitors and logs untrusted pro-
grams’ operations. Using the logs, it can completely remove
malware programs and their eﬁects on the system. Our
framework does not require signatures or other prior knowl-
edge of malware behavior. We implemented this framework
on Windows and evaluated it with seven spyware, trojan
horses, and email worms. Comparing our tool with two
popular commercial anti-malware tools, we found that our
tool detected all the malware’s modi(cid:2)cations to the system
detected by the commercial tools, but the commercial tools
overlooked up to 97% of the modi(cid:2)cations detected by our
tool. The runtime and space overhead of our prototype tool
is acceptable. Our experience suggests that this framework
oﬁers an eﬁective new defense against malware.
1. Introduction
Malware has become an epidemic problem. A recent
study showed that a signi(cid:2)cant number of computers run-
⁄This research is supported in part by Intel IT Research, and by the I3P
and the O–ce of Science and Technology at the Department of Homeland
Security. Points of view in this document are those of the author(s) and
do not necessarily represent the o–cial position of the U.S. Department of
Homeland Security or the O–ce of Science and Technology.
yAuthor is currently at University of California, San Diego. Email:
PI:EMAIL
currently
at Microsoft Corporation.
Email:
zAuthor
is
PI:EMAIL
ning Windows in a major research university were infected
with one or more malware programs [19]. Another recent
study showed that one in three computers has malicious
code on it [15]. A major reason for the malware problem
is the proliferation of software applications and the diver-
sity of their vendors. Many cutting-edge applications come
from vendors with questionable reputations. For example,
many P2P applications carry code that will install adware
or spyware that is very di–cult to remove [8].
The most common defense against malware is detection.
However, since most detectors search for malicious code
patterns (static signatures) of known malware, they cannot
reliably detect new malware or variants of known malware
(also known as polymorphic malware). Naive users ignore
or disable working detection programs to install and run
malware programs when trying to use applications bundled
with malware. As these malware programs accumulate,
the computer often becomes unusable due to slow response
time, exhausted storage, and frequent application crashes.
In short, even good malware detectors cannot protect the
user from running malware programs.
In the case that the user cannot avoid running malware on
his system, the next defense is to remove it once the user no-
tices its adverse eﬁect on his computer. Typically, removing
a malware program involves removing all the components
installed by this program and restoring all the data modi(cid:2)ed
or deleted by this program. Common approaches include:
† Running an anti-malware program to remove all the
components of the malware. However, because it re-
lies on known malware signatures, this approach can-
not reliably remove new or polymorphic malware, nor
can it restore infected data.
† Taking periodic snapshots of the system, and restoring
the infected system to the last clean snapshot. This ap-
proach will destroy all the new data created after the
snapshot, even if they are clean. Although the user
may avoid this problem by saving the clean data, man-
ually determining which data are clean is laborious and
unreliable.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006† Formatting the disk and reinstalling the operating sys-
tem. This drastic approach will destroy all the user data
and con(cid:2)gurations. Unfortunately, since most other
approaches fail to remove all the components of the
malware program, this approach is often advised and
followed.
trusted, such as all pre-installed applications on a new com-
puter from a reputable vendor. There is no harm in mis-
classifying a non-malware program as untrusted, except for
incurring some performance penalty. (We will discuss per-
formance issues in Section 4.)
We summarize the major contributions of our paper:
These problems call for a better approach, one that can
remove all the components of both known and unknown
malware, that can restore data infected by malware while
preserving clean data, and that requires minimal user inter-
vention. We introduce Back to the Future, a framework for
achieving these goals. The framework monitors and logs
operations of untrusted programs designated by the user,
and can remove all the components of the untrusted pro-
grams and restore the infected data at the user’s request.
In other words, this framework allows the user to run un-
trusted programs without compromising the integrity of the
system. If an untrusted program turns out to be spyware, the
framework can remove all the components of the malware
automatically and reliably; if the untrusted program turns
out to be a virus, the framework can also restore all the in-
fected (cid:2)les automatically. We name this framework Back to
the Future because conceptually we have (cid:2)rst rolled back
the system to a prior good state. From there, we then bring
only the trusted processes back to their pre-recovery state
(for the prior good state this is the future).
The primary security goal of our framework is integrity:
we want to preserve the integrity of the system while the
user is running malware programs.
In some cases, our
framework can also provide availability: by completely re-
moving malware from the system, it will free the resources
usurped by the malware. Our framework does not aim
to provide con(cid:2)dentiality. However, if the user can indi-
cate con(cid:2)dential information on his system, our framework
can incorporate this information and provide con(cid:2)dentiality.
Furthermore, in the process of preserving system integrity
we may stop running malware before it discloses con(cid:2)den-
tial information. Our framework may seem similar to sand-
boxing environments; however, unlike a typical sandboxing
environment, our framework does not require system or ap-
plication speci(cid:2)c rules about what operations are allowed
(see Section 6 for further discussion).
Our framework monitors untrusted processes, and re-
moves them and their eﬁects on the system automatically
at the user’s request. However, our framework needs the
user to decide which programs are trusted and which are
untrusted. On the surface, this requirement seems as di–-
cult as malware detection, but in fact, our framework only
expects the user to evaluate the trustworthiness of a pro-
gram conservatively: when in doubt, the user should con-
sider the program as untrusted. In practice, there are often
sound heuristics for deciding if a program is trusted. It is
reasonable to consider programs from reliable sources as
† We propose a new framework for preserving system
integrity while allowing the user to run untrusted pro-
grams. The framework monitors and logs the operation
of untrusted programs, and uses these logs for remov-
ing the untrusted programs and their eﬁects completely
and automatically. Since this framework does not need
any prior knowledge about the untrusted program, it
can defend against both known and unknown malware.
† Our framework provides a transparent environment for
running both trusted and untrusted programs. The user
does not need to modify any existing programs. No
program should notice that it is running in our frame-
work.
† We have implemented a prototype of our framework
on Windows, where the threat of malware is greatest,
and evaluated it with seven spyware, trojan horses, and
email worms. Comparing our tool with two popular
commercial anti-malware tools, we found that our tool
detected all the malware’s modi(cid:2)cations to the system
detected by the commercial tools, but the commercial
tools overlooked up to 97% of the modi(cid:2)cations de-
tected by our tool.
2. Framework
2.1. Overview
Figure 1 illustrates the three components of Back to the
Future: a monitor, a logger, and a recovery agent. The mon-
itor intercepts each monitored process’s read and write op-
erations. The logger records some write operations of the
untrusted processes. When the monitor determines that an
untrusted process may harm a trusted process, it invokes the
recovery agent to restore system integrity.
Our framework needs to solve two challenges. First, how
does it determine when an untrusted program may violate
the integrity of the system? Second, how does it remove
all the eﬁects of an untrusted program? Intuitively, after re-
covery, the system should look as if only the trusted appli-
cations have run, and the untrusted applications have never
been installed or run. The next two sections describe our
solutions to these two challenges.
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Trusted
Process
Untrusted
Process
Logger
Recovery
Agent
Monitor
Operating System
Figure 1. Framework for monitoring, logging
and recovery.
2.2. System Integrity
This section de(cid:2)nes the notion of system integrity, de-
scribes a criterion for checking when an untrusted program
may violate system integrity, and discusses how to preserve
system integrity.
2.2.1. Integrity Model
We start with Biba’s integrity model [3], which says
that no subject can read objects of lower integrity levels,
and no subject can write objects of higher integrity levels.
Our framework de(cid:2)nes two integrity levels: trusted and un-
trusted. Applying Biba’s model, our framework would re-
quire that trusted processes should not read untrusted data,
and untrusted processes should not write trusted data.
Strictly following Biba’s model, however, considerably
limits the user’s ability to run untrusted programs. For ex-
ample, the framework would have to stop an untrusted pro-
cess immediately when the process tries to overwrite trusted
data.
If no trusted process will ever read this data again
(e.g., temporary scratch data), stopping the untrusted pro-
cess is unnecessary. Even if some trusted process will read
this data, the framework does not have to intervene until just
before the read operation happens.
Hence, we adopt a relaxed integrity model. Our model
only requires that no trusted process should read untrusted
data, but untrusted processes can freely write (or overwrite)
any data they desire. This model can be viewed as a lazy
Biba’s model: it does not enforce integrity until the point
where untrusted data could (cid:3)ow into trusted processes. The
laziness in our model allows the user to run more untrusted
applications without interference from the integrity policy.
2.2.2. Preserving System Integrity
To preserve system integrity, the framework must inter-
vene when a trusted process is about to read untrusted data.
We argue that a good intervening approach should satisfy
the following properties:
† Preserving the consistency of processes: The approach
should preserve the consistency of both trusted and un-
trusted processes. This means that if the approach al-
lows a process to continue, it should not change the
process’s behavior. For example, the approach should
not selectively deny certain operations of the process.
† Allowing processes to run as long as possible: The ap-
proach should allow a process to run as long as pos-
sible until it cannot preserve system integrity or the
consistency of some processes.
We propose the following options for preserving system
integrity:
† Deny the operation: This option preserves system in-
tegrity by denying this read operation. To preserve
the consistency of the trusted process that issued the
read operation, the framework must also terminate the
trusted process.
† Allow the operation: We can allow this read operation
but still preserve system integrity with the following
approaches:
(cid:150) Terminate the untrusted process: We terminate
the untrusted process that has written the un-
trusted data, and restore the old data at the same
location. If the restored data is still untrusted, we
terminate the process that had written it, restore
the old data, and repeat this procedure until the
data that we have restored is trusted. This solu-
tion preserves system integrity by replacing un-
trusted data with trusted data.
(cid:150) Mark the trusted process as untrusted: We be-
gin to treat the trusted process as untrusted. No-
tice, however, that we do not need to remove the
data written by this process in the past. Since this
process is now untrusted, we allow the read oper-
ation to continue, as untrusted processes can read
any data. This solution preserves system integrity
by reducing the set of trusted processes.
Sometimes we may want to preserve good eﬁects of un-
trusted applications. Under such cases, we can mark the
untrusted data as trusted and let the read operation con-
tinue. As an example, consider media (cid:2)les downloaded by
malware-laden P2P applications.
If the user is con(cid:2)dent
that the media (cid:2)les will not aﬁect trusted applications, we
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006can allow a trusted application, say a media player, to play
these media (cid:2)les.
2.3. System Recovery
This section describes how the framework removes all
the eﬁects of untrusted programs on the system.
2.3.1. Basic Approach for System Recovery
We (cid:2)rst describe a basic approach for system recovery
that is conceptually simple and serves as a reference for
reasoning about the correctness of a more e–cient but com-
plex approach. During monitoring, the framework logs all
the operations of both trusted and untrusted processes; dur-
ing recovery, the framework (cid:2)rst reverses all the logged
operations of both trusted and untrusted processes reverse-
chronologically, and then reapplies all the logged operations
of only the trusted processes chronologically.
We next elaborate on this approach. Given a de(cid:2)nition
of the state of a system (e.g., the state consists of the (cid:2)le
system and the registry), we can divide the operations of all
the processes into two categories: read operations (which
do not change the system state) and write operations (which
do change the system state). Since our goal is to remove
all the eﬁects of the untrusted processes on the system, the
framework needs to log only the write operations. This ap-
proach requires the framework to log the write operations
of both trusted and untrusted processes. Moreover, since
the framework needs to undo the write operations during
the recovery phase, it needs to log the old data overwritten
by each write operation during the monitoring phase.
One can argue that after recovery this basic approach
brings the system to a state that looks as if the untrusted pro-
cesses have never run. However, this approach is ine–cient,
because during recovery it (cid:2)rst undoes each write operation
by the trusted processes and later redoes the same opera-
tion. For most write operations, undoing them followed by
redoing them will have no net eﬁect. We could save time by
avoiding undoing and redoing these write operations, and
save space by not logging these write operations.
2.3.2. Re(cid:2)ned Approach for System Recovery
We re(cid:2)ne the basic approach by avoiding the recovery
operations with no net eﬁect. We motivate the re(cid:2)ned ap-
proach by two examples, where a trusted process T and an
untrusted process U write to the same data location:
† Example 1: T writes before U writes. During recov-
ery, the framework only needs to undo U’s write op-
eration; it does not need to undo and then to redo T’s
write operation, and it does not need to log this opera-
tion during monitoring.
† Example 2. U writes before T writes. During recov-
ery, the framework does not need to undo either U’s
write or T’s write, because T’s trusted data has over-
written U’s untrusted data.
These two examples suggest that we can detect unnec-
essary recovery operations by tracking the order in which
trusted and untrusted processes write to the same data lo-
cation.
In fact, it su–ces to track whether each location
contains trusted or untrusted data. In this re(cid:2)ned approach,
during monitoring:
† When a trusted process writes to a data location, mark
the new data in the location as trusted.
† When an untrusted process writes to a location: