    b = temp;
}
In templates, the variable "T" usually stands for the substi-
tuted data type. We can call Swap with almost any data type:
int i1, i2;
CString cs1,cs2;
CmyDataType md1, md2;
Swap( i1, i2 );
Swap( cs1, cs2);
Swap( md1, md2 );
The best part of this template is that the compiler will actu-
ally give you a meaningful message if you get it wrong. If the
250    Chapter 15 •
ATL and Compiler Support 
types aren't compatible, the compiler will give you an error mes-
sage. We should note that the template definition is readable
code. The angle brackets do take some adjustment.
Template Classes
Template functions are actually one of the simpler things we can
do with templates. The real power of ATL comes in defining
classes. ATL makes heavy use of template classes. The syntax of
defining a class template is very similar to the function template
above.
template 
class PrintClass 
{
public:
    T m_data;
public:
    void Set( T a ) { m_data = a; };
    void Print() { cout  x;
x.Set( 101 );
x.Print();
One of the characteristics of ATL is multiple inheritance.
Most ATL COM classes created by the ATL class wizard are built
around multiple inheritance. 
Here's one of the headers generated by the ATL wizard.
class ATL_NO_VTABLE CBasicTypes : 
public CComObjectRootEx,
public CComCoClass,
public IBasicTypes
Basic Templates
251
Additonal Information and Updates: http://www.iftech.com/dcom
Notice that this coclass is implemented by the ATL templates
CComObjectRootEx and CComCoClass. The CComObjectRootEx
template handles reference counting for the COM object, CCom-
CoClass implements the COM class factory. The third inherited
class, IBasicTypes, is an interface, which is a plain C++ base
class (with a COM VTABLE layout)
Template code can get extremely ugly. Because of its terse-
ness, template code is hard to follow. Take the following exam-
ple:
typedef CComObject > > IEnumObject;
IEnumObject* pNewEnum = NULL;
This looks like an entry in the obfuscated C++ code contest
- templates nested three deep! This example declares an ATL
enumeration interface. (The three template classes here are CCo-
mObject<>, CComEnum<>, and _Copy<>.) 
There are several interesting things going on here. A pecu-
liar aspect of templates is how they handle typedef statements.
No code is generated until an actual object is declared. Another
oddity is the placement of angle brackets. The critical difference
here is between ">>" and "> >". The former is the stream opera-
tor, the latter is the end of a nested template definition. If you
forget the space between angle brackets, you'll get some inter-
esting compiler errors.
The fundamental ATL classes include:
252    Chapter 15 •
ATL and Compiler Support 
ATL Class
Template 
Argument
Description
CComObjectRoot
Your class.
Implements the methods of IUn-
known. This class gives you Que-
ryInterface, AddRef, and Release. 
Works for non-aggregated 
classes. Uses single threading 
model.
CComObjectRootEx
ThreadModel. Use 
one of the threading 
model classes.
Handles the reference counting 
for the object. ATL objects must 
be based on CComObjectRoot or 
CComObjectRootEx.
CComCoClass
Your Class and a 
pointer to the CLSID 
to the object.
Defines the object's default class 
factory and aggregation model. 
CComSingleThread-
Model,
CComMultiThread-
Model
Single and multi-treading mod-
els.
IDispatchImpl
Your class, the IID, 
and LIBID.
IDispatch implementation for 
dual interfaces.
CComPtr
Interface
Implements a smart pointer to 
manage an interface.
CComQIPtr
Interface, IID of inter-
face
Implements a smart pointer to 
manage an interface. Allows que-
rying of interfaces.
CComAggObject
Contained class
Implements IUnknown for an 
aggregated object.
Table 15.1
Fundamental ATL Classes
Native Compiler Directives
253
Additonal Information and Updates: http://www.iftech.com/dcom
Native Compiler Directives
One of the most important recent changes to COM was the addi-
tion of native Visual C++ compiler directives. By native, we
mean that these commands can be included directly into your
C++ source code, and the compiler will recognize them. This
native support is oriented towards the client program. This is an
interesting step towards making COM programming a lot easier. 
The #IMPORT Directive
The import statement allows the compiler and pre-processor to
use a type library to resolve certain types of COM references.
This information is converted into C++, making it easily available
to the application. Type libraries have a tremendous amount of
useful COM information in them. This includes Class Identifiers
(CLSID), Interface ID's, and especially interface definitions. 
Traditionally the only way to get this information was
through include files. MIDL generates the C++ headers for these
definitions, but you have to locate and include the proper head-
ers. While not especially difficult, this step is tedious and prone
to failure when header files are moved or changed.
As useful as these changes are, they aren't really anything
new. Many languages that support COM have had this feature for
years. Visual Basic has a component browser that does much the
same thing. 
//#import "filename" [attributes]
#import  no_namespace 
The syntax is quite simple. There are however, quite a num-
ber of attributes for the import statement. The only one you'll
commonly see is "no_namespace". We'll discuss namespaces
shortly.
Like the C++ include statement, the #import directive can
use either angle brackets "" or double quotes. Like the
include statement, the choice affects the search order of directo-
ries for the type library. Angle brackets will search the "PATH"
and "LIB" environment variables first, and lastly check the com-
254    Chapter 15 •
ATL and Compiler Support 
piler include path option ("/I"). Double quotes will search the
current directory first, followed by the paths shown above.
Type libraries aren't the only way to get this type informa-
tion. EXE and DLL files can also contain type libraries. You can
also specify these types of file in the import directive.
Namespace Declarations
Name spaces in C++ are used to prevent name conflicts with
variables, types, and functions. By default, the import directive
puts all its generated code in a C++ "namespace." The
namespace used is based on the type library name. If the typeli-
brary was "TEST.TLB" the namespace would be "TESTLib".  To
use data declared in a namespace, you have to prefix everything
with the namespace name. Here's an example of a simple
namespace.
namespace MySpace {
    typedef int SPECIAL;
}
MySpace::SPECIAL x;
If you leave off the "no_namespace" attribute for the import
statement, you'll have to prefix all the import generated declara-
tions with a namespace. One of the things the import statement
does is define "smart pointers" for all of the interfaces in the
library. If we create an enumeration in MIDL called RGB_ENUM,
we would have access to it through the import statement. Our
client program could refer to this enumeration, but it would have
to prefix it with the type library namespace.
#import "TEST.TLB"
// The compiler will give an error here:
RGB_ENUM BadRgbEnum;
// This works.
TESTLib::RGB_ENUM  RgbVal;
Native Compiler Directives
255
Additonal Information and Updates: http://www.iftech.com/dcom
If you don't want to mess with namespaces, you import with
the "no_namespace" attribute. This allows you to use the MIDL
names directly.  Of course if the type library you import has
name collisions with your program, you'll have to use the name
spaces.
Smart Interface Pointers
In the 1956 science fiction classic "Invasion of the body-snatch-
ers", aliens replace everybody in a small town with substitutes
that are grown in giant green seed-pods. These replacement
people look the same, talk the same, and act the same as the
originals, but they are strangely different - they are loveless,
emotionless automatons. The plot of this movie reminds me of
smart pointers.
Smart pointers are helper classes that manage interfaces
automatically. A smart pointer 'takes over' a COM interface,
replacing its behavior with some subtle, but different actions.
The main advantage of smart pointers is that they handle the
COM creation, reference counting, and releasing automatically.
With smart pointers, COM interfaces act a lot more like normal
C++ pointers.
Before we get much farther, we should look at the down-
side of smart pointers. The most significant one is that they don't
handle remote access. Smart pointers use CoCreateInstance,
instead of the more powerful CoCreateInstanceEx method. There
is no way to pass a smart pointer the COSERVERINFO structure,
which contains the remote computer name. If your going to use
a remote system, you'll have to specify the remote computer
using DCOMCNFG.
The other common problem with smart pointers is related to
program scope. The smart pointer constructor and destructor
create and destroy the actual COM interface. This means you've
got to be careful about the scope of the pointer.
Another issue is error handling. When a smart pointer gets a
COM error, it throws an exception. This means you'll have to
program with try/catch blocks. In terms of program overhead,
256    Chapter 15 •
ATL and Compiler Support 
smart pointers are quite efficient. You shouldn't see a significant
performance hit from using them.
Smart Pointer Classes
There are several classes of smart pointers in Visual C++. The
first group of classes come from ATL, and are called CComPtr<>
and CComQIPtr<>.  These classes don't offer big advantages
over standard COM interfaces.
If you are using the #import directive, you have access to a
more powerful type of smart pointer. These pointers are based
on _com_ptr_t. Much of the power of these objects is in their
constructor. When you create a _com_ptr_t with either new or a
declaration, it can actually connect to a COM object. This means
the constructor is calling CoCreateInstance and managing the
resultant interface. 
Here's a typical use of a _com_ptr_t object. This smart
pointer is bound to a specific interface - IBasicTypes. The type
IBasicTypesPtr is a smart pointer. It is automatically declared by
the 
#import 
directive. 
This 
is 
done 
with 
a 
macro
_COM_SMARTPTR_TYPEDEF, which creates a typedef with the
interface name + "Ptr".
The definition translates into something similar to the fol-
lowing typedef.
typedef _com_ptr_t IBasic-
TypesPtr;
Surprise,  _com_ptr_t is a template! The __uuidof() macro
retrieves the GUID of the IBasicTypes interface. 
Here's how we use the class:
IBasicTypesPtr pI( _T("BasicTypes.BasicTypes.1") );
long l1=1;
long l2=0;
pI->LongTest( l1, &l2 );
Native Compiler Directives
257
Additonal Information and Updates: http://www.iftech.com/dcom
You'll immediately notice the missing steps: there is no
CoCreateInstance() and no Release() called, and no HRESULT
returned. Actually, all the usual things are going on, but they are
hidden in the smart pointer class. First, the CLSIDFromString()
is called to translate the CLSID (or ProgID) into a GUID. If the
CLSID is valid, the smart pointer calls CoCreateInstance and
obtains an interface pointer. The returned interface is saved
internally and used whenever it is required. 
Watch Out for Destructors
Smart pointers are wonderful things, but they also present some
problems. You've got to be careful about the scope of smart
pointers. When you declare them as we did above, smart point-
ers are created on the stack. This means that a pointer’s lifetime
will be only within the braces {} in which it was declared. This
might be inside a function, or inside an if block. 
Remember that the smart pointer destructor will be called
when it goes out of scope. By default, the destructor of a smart
pointer automatically calls Release(). This can cause several
problems. When you destroy the last reference to the COM
object, the COM server may shutdown. This means that the next
COM call may have to restart the server - this can be quite slow
for an out-of-process server.
Here's a piece of code that will cause problems:
void main()
{
CoInitialize(0);
IBeepPtr pBadPtr( _T("Beep.Beep.1") );
pBadPtr->Beep();
CoUninitialize();
// crash on exit
}
The problem here is that CoUninitialize() is called before
the destructor to the smart pointer. You'll get an un-handled
exception from this code. The smart pointer calls Release() on its
258    Chapter 15 •
ATL and Compiler Support 
destructor, but COM has already been shut down by CoUninitial-
ize(). 
There is a relatively simple work-around. Declare the smart
pointer inside a set of braces. This will ensure that the pointer is
destroyed before CoUninitialize();
void main()
{
CoInitialize(0);
{
IBeepPtr pBadPtr( _T("Beep.Beep.1") );
pBadPtr->Beep();
}
CoUninitialize(); // no problem
}
This is lousy code for several other reasons. The main prob-
lem is that it has no error checking. If the "Beep.Beep.1" inter-
face isn't registered, the declaration of the smart pointer will
throw an exception. There is no try/catch block; it will fail with
an uncaught exception. The next section describes how to catch
errors thrown by a smart pointer.
Smart Pointer Error Handling
Many smart pointer operations don't return an HRESULT. Obvi-
ously, they need some sort of error checking. They get around
this by throwing an exception whenever they get an error
HRESULT. The _com_ptr_t class calls _com_issue_error when-
ever it encounters an error. _com_issue_error constructs a
_com_error object with the HRESULT and throws it. Here's the
code of the _com_ptr_t implementation of AddRef(). 
void AddRef() 
{ 
if (m_pInterface == NULL) {
_com_issue_error(E_POINTER);
}
m_pInterface->AddRef(); 
}
Native Compiler Directives
259
Additonal Information and Updates: http://www.iftech.com/dcom
AddRef needs a valid interface pointer. If the member inter-
face pointer is NULL, it calls _com_issue_error with the HRESULT
of E_POINTER. You can also see that the implementation of
smart pointers isn't especially complicated.
To catch the _com_error, you need to include all smart
pointer objects with a try-catch block.
try
{
IBasicTypesPtr pI( _T("BadCLSID.BadCLSID.1") );
PI->SomeMethod();
}
catch (_com_error e)
{
// handle the error
}
All the code you write with smart pointers will need try-
catch blocks. 
The _com_error class provides a nice encapsulation of
HRESULTs and common error handling functions. You can
retrieve the raw HRESULT code by calling Error.
catch( _com_error e )
{
        cout << "HRESULT = " << e.Error() << endl;
        cout << "ErrorMessage() = " << e.ErrorMessage() 
<< endl;
}
The ErrorMessage method takes the place of the Format-
String API. The ErrorMessage method of _com_error handles the
creation of the printable error string. It also automatically deletes
the message buffer when it's done. FormatString is a very trou-
blesome function. It has numerous complex arguments. The
other problem with FormatString is that it allocates a string buffer
that must be explicitly released with LocalFree(). 
260    Chapter 15 •
ATL and Compiler Support 
How the IMPORT Directive Works
You've probably been wondering how the import directive
accomplishes all the things it does. It includes MIDL definitions
in the C++ program, creates smart pointers, and it gives us the
useful _com_error type. The way all this is accomplished is quite
ingenious. 
The import directive creates two header files. These files are
automatically created by retrieving information from the type
library. The contents of these two files are included in the source
as headers. Whenever the type library changes, the contents of
these two headers is regenerated.
The first type of file is a typelib header, or TLH. It includes
the following sections:
• The COMDEF.H header
• MIDL structure, enum, coclass, and interface typedefs.
• Smart pointer definitions for interfaces.
• Interface wrapper declarations.
• Interface raw declarations.
• An #include of the TLI file.
The other generated file is a typelib implementation file, and
has the extension TLI. TLI files contain the implementation of
smart pointer wrapper methods.
Raw and Wrapper Methods
When you call a method on a smart pointer, you're not directly
calling a COM method. The smart pointer has a wrapper method
for each of the interfaces methods. When you call the wrapper