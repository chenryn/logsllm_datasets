faster than LESE by two orders of magnitude on average. Thus,
our comparison to LESE demonstrates that NEUEX’s neural
mode can handle loops by synthesizing the loop constraints in
form of neural net without analyzing the program.
Veritesting. We compare NEUEX with Veritesting [33]. Since
the original implementation used in the paper is not pub-
licly available, we instead used its publicly available re-
implementation as part of the Angr binary analysis frame-
work [1], [94]. We report on the cURL program for comparison
as a starting point, because in our experiments vanilla KLEE
was able to ﬁnd the cURL exploit
in 34 minutes, so a
conceptual advance on KLEE should be able to identify it
faster. The Veritesting implementation on Angr requires a
target address that it aims to ﬁnd exploits at. We provided the
known vulnerability point address in cURL as a target address
to this implementation. We gave the same symbolic arguments
for Angr as we did for KLEE and NEUEX. We then used
Angr’s symbolic execution routine with the Veritesting ﬂag
turned on to ﬁnd concrete inputs to reach the vulnerability. In
12 hours, it analyzed a total of 530 unique instructions, 2, 353
symbolic states, 38 static analysis calls for Veritesting and
198 unique external functions where stubs were not available.
Veritesting was not able to reach the vulnerability in 12 hours.
VII. RELATED WORK
NEUEX is a new design point in constraint synthesis and
constraint solving. In this section, we discuss the problems of
the existing symbolic execution tools and present how NEUEX
differs from existing constraint synthesis.
A. Symbolic Execution
Symbolic execution [68] has been used for program ver-
iﬁcation [50], software testing [40], and program repair via
speciﬁcation inference [80]. In the last decade, we have
witnessed an increased adoption of dynamic symbolic execu-
tion [62] where symbolic execution is used to partition the
input space, with the goal of achieving increased behavioral
coverage. The input partitions computed are often deﬁned as
program paths, all inputs tracing the same path belong to the
same partition. Thus, the test generation achieved by dynamic
symbolic execution suffers from the path explosion problem.
This problem can be exacerbated owing to the presence of
complex control ﬂows, including long-running loops (which
may affect the scalability of dynamic symbolic execution since
it involves loop unrolling) and external libraries. However,
NEUEX does not suffer from the path explosion as it learns
the constraints from test executions directly.
Tackling path explosion is a major challenge in symbolic
execution. Boonstopel et al. suggest the pruning of redundant
paths during the symbolic execution tree construction [37].
One of the predominant ways of tackling the path explosion
problem is by summarizing the behavior of code fragments
in a program [31], [33], [60], [72], [92]. Simply speaking, a
summarization technique provides an approximation of the be-
havior of certain fragments of a program to keep the scalability
of symbolic execution manageable. Such an approximation of
behaviors is also useful when certain code fragments, such as
remote calls and libraries written in a different language, are
not available for analysis.
Among the past approaches supporting approximation of
behaviors of (parts of) a program, the use of function sum-
maries has been studied by Godefroid [60]. Such function
summaries can also be computed on-demand [31]. Kuznetsov
et al. present a selective technique to merge dynamic states.
It merges two dynamic symbolic execution runs based on an
estimation of the difﬁculty in solving the resultant Satisﬁability
Modulo Theory (SMT) constraints [72]. Veritesting suggests
supporting dynamic symbolic execution with static symbolic
execution thereby alleviating path explosion due to factors
such as loop unrolling [33], which still suffers from unknown
function calls and SMT solver timeouts. We conceptually and
experimentally compare to this approach. Related works [84],
[92] suggest grouping together paths based on similar symbolic
expressions in variables, and use such symbolic expressions as
dynamic summaries to group paths.
B. Constraint Synthesis
To support the summarization of program behaviors, the
other core technical primitive we can use is constraint synthe-
sis. In our work, we propose a new constraint synthesis ap-
proach which utilizes neural networks to learn the constraints
which are infeasible for symbolic execution. In comparison
with previous solutions, the major difference is that NEUEX
does not require any pre-deﬁned templates of constraints and
can learn any kind of relationships between variables.
Over the last decade,
there are two lines of works in
constraint synthesis: white-box and black-box approaches.
White-box constraint
inference relies on a combination of
light-weight techniques such as abstract interpretation [47],
[48], [86], interpolation [43], [67], [76] or model checking
algorithm IC3 [38]. Although some white-box approaches can
provide sound and complete constraints [46], it is dependent on
the availability of source code and a human-speciﬁed semantics
of the source language. Constructing these tools have required
considerable manual expertise to achieve precision, and many
of these techniques can be highly computationally intensive.
To handle the unavailability of source code, there also
exist a rich class of works on reverse engineering from
13
dynamic executions [54], [58], [66], [81]–[83]. Such works
can be used to generate summaries of observed behavior from
test executions. These summaries are not guaranteed to be
complete. On the other hand, such incomplete summaries
can be obtained from tests, and hence the source code of
the code fragment being summarized need not be available.
Daikon [54] is one of the earlier works proposing a synthesis
of potential invariants from values observed in test executions.
The invariants supported in Daikon are in the form of linear
relations among program variables. DIG extends Daikon to
enable dynamic discovery of non-linear polynomial invariants
via a combination of techniques including equation solving and
polyhedral reasoning [82]. Krishna et al. use the decision tree,
a machine learning technique, to learn the inductive constraints
from good and bad test executions [70].
NEUEX devises a new gradient-based constraint solver, the
ﬁrst work which solves the conjunction of neural and SMT
constraints. Angora [42] uses gradient-based approach which
is similar to NEUEX, albeit for a completely different usage. It
treats the predicates of branches as a black-box function which
is not differentiable, while NEUEX encodes the symbolic
constraints into a differentiable function and embeds it into
neural constraints. A concurrent work, NeuZZ [93], utilizes
neural networks to guide random fuzzing to predict the control-
ﬂow edges exercised by a given input. Our work instead
uses neural networks to improve upon dynamic symbolic
execution. Li et al. [74] propose a method to solve symbolic
constraints using a classiﬁcation-based optimization technique
called RACOS [99], instead of using SAT/SMT solvers. Unlike
our work, their work does not attempt to learn a non-symbolic
representation of the program to ameliorate the difﬁculties
of symbolic analyses, and hence our work proposes entirely
different constraint solving techniques.
VIII. CONCLUSION
NEUEX utilizes neural networks to inductively learn con-
straints which approximate program behavior. Our proposed
neuro-symbolic execution solves neural and symbolic con-
straints together, and can be seen as a general purpose testing
and analysis engine for programs. NEUEX’s solver offers a
new design to simultaneously solve both symbolic constraints
and neural constraints effectively, thus augmenting symbolic
execution. Our technique ﬁnds 94% more bugs than vanilla
dynamic symbolic execution.
ACKNOWLEDGMENTS
We thank Marcel Böhme, Shruti Tople, Shin Hwei Tan, Xi-
ang Gao, Sergey Mechtaev, the anonymous reviewers, and our
shepherd Endadul Hoque for their feedback on this work. We
thank Changze Cui for helping us in the most recent version
of our implementation and experiments. Thanks to Vinamra
Bhatia for helping on Veritesting. All opinions expressed in this
paper are solely those of the authors. This research is supported
by research grant DSOCL17019 from DSO, Singapore. This
research was partially supported by a grant from the National
Research Foundation, Prime Minister’s Ofﬁce, Singapore un-
der its National Cybersecurity R&D Program (TSUNAMi
project, No. NRF2014NCR-NCR001-21) and administered by
the National Cybersecurity R&D Directorate.
REFERENCES
[1] Angr. https://github.com/angr/angr.
[2] BIND DNS Server. https://www.isc.org/downloads/bind/.
[3] CA-1999-14.
https://www-uxsup.csx.cam.ac.uk/pub/webmirrors/
www.cert.org/advisories/CA-1999-14.html.
[4] CA-2003-07. https://lwn.net/Articles/24238/.
[5] CA-2003-12. https://seclists.org/cert/2003/12.
[6] Clang Static Analyzer. https://clang-analyzer.llvm.org/.
[7] CVE-1999-0009. https://nvd.nist.gov/vuln/detail/CVE-1999-0009.
[8] CVE-1999-0047. https://nvd.nist.gov/vuln/detail/CVE-1999-0047.
[9] CVE-1999-0131. https://nvd.nist.gov/vuln/detail/CVE-1999-0131.
[10] CVE-1999-0206. https://nvd.nist.gov/vuln/detail/CVE-1999-0206.
[11] CVE-1999-0368. https://nvd.nist.gov/vuln/detail/CVE-1999-0368.
[12] CVE-1999-0878. https://nvd.nist.gov/vuln/detail/CVE-1999-0878.
[13] CVE-2001-0013. https://nvd.nist.gov/vuln/detail/CVE-2001-0013.
[14] CVE-2001-0653. https://nvd.nist.gov/vuln/detail/CVE-2001-0653.
[15] CVE-2002-0906. https://nvd.nist.gov/vuln/detail/CVE-2002-0906.
[16] CVE-2003-0466. https://nvd.nist.gov/vuln/detail/CVE-2003-0466.
[17] CVE-2014-8130. https://nvd.nist.gov/vuln/detail/CVE-2014-8130.
[18] CVE-2015-3416. https://nvd.nist.gov/vuln/detail/CVE-2015-3416.
[19] CVE-2016-9586. https://nvd.nist.gov/vuln/detail/CVE-2016-9586.
[20] CVE-2017-14245. https://nvd.nist.gov/vuln/detail/CVE-2017-14245.
[21] CVE-2017-14246. https://nvd.nist.gov/vuln/detail/CVE-2017-14246.
[22] CVE-2017-16942. https://nvd.nist.gov/vuln/detail/CVE-2017-16942.
[23] CVE-2017-7598. https://nvd.nist.gov/vuln/detail/CVE-2017-7598.
[24] CVE-2017-7599. https://nvd.nist.gov/vuln/detail/CVE-2017-7599.
[25] CVE-2017-7600. https://nvd.nist.gov/vuln/detail/CVE-2017-7600.
[26] Klee uClibc. https://github.com/klee/klee-uclibc.
[27] STP – The Simple Theorem Prover. https://stp.github.io/.
[28] uClibc. https://www.uclibc.org/.
[29] M. Abadi, P. Barham, J. Chen, Z. Chen, A. Davis, J. Dean, M. Devin,
S. Ghemawat, G. Irving, M. Isard et al., “TensorFlow: A System for
Large-Scale Machine Learning,” in OSDI’16.
[30] E. Ábrahám, “Building Bridges between Symbolic Computation and
Satisﬁability Checking,” in ISSAC’15.
[31] S. Anand, P. Godefroid, and N. Tillman, “Demand-Driven Composi-
tional Symbolic Execution,” in TACAS’08.
[32] A. Andoni, R. Panigrahy, G. Valiant, and L. Zhang, “Learning Poly-
nomials with Neural Networks,” in ICML’14.
[33] T. Avgerinos, A. Rebert, S. Cha, and D. Brumley, “Enhancing Sym-
bolic Execution with Veritesting,” in ICSE’14.
[34] R. Baldoni, E. Coppa, D. C. D’Elia, C. Demetrescu, and I. Finoc-
chi, “A Survey of Symbolic Execution Techniques,” ACM Computer
Survey’18.
[35] O. Bastani, R. Sharma, A. Aiken, and P. Liang, “Synthesizing Program
Input Grammars,” in PLDI’17.
[36] M. Bojarski, D. Del Testa, D. Dworakowski, B. Firner, B. Flepp,
P. Goyal, L. D. Jackel, M. Monfort, U. Muller, J. Zhang et al., “End-
to-End Deep Learning for Self-Driving Cars,” arXiv, 2016.
[37] P. Boonstoppel, C. Cadar, and D. Engler, “RWset: Attacking Path
Explosion in Constraint-Based Test Generation,” in TACAS’08.
[38] A. R. Bradley, “SAT-Based Model Checking Without Unrolling,” in
VMCAI’11.
[39] A. Bundy and L. Wallen, “Breadth-ﬁrst Search,” in Catalogue of
Artiﬁcial Intelligence Tools, 1984.
[40] C. Cadar, D. Dunbar, D. R. Engler et al., “KLEE: Unassisted and
Automatic Generation of High-Coverage Tests for Complex Systems
Programs,” in OSDI’08.
[41] C. Cadar and K. Sen, “Symbolic Execution for Software Testing: Three
Decades Later,” Comm of ACM’13.
[42] P. Chen and H. Chen, “Angora: Efﬁcient Fuzzing by Principled
Search,” SP’18.
14
[43] Y.-F. Chen, C.-D. Hong, B.-Y. Wang, and L. Zhang, “Counterexample-
Guided Polynomial Loop Invariant Generation by Lagrange Interpo-
lation,” in CAV’15.
[44] V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: A Platform for
In-Vivo Multi-Path Analysis of Software Systems,” ACM SIGPLAN
Notices, 2011.
[45] A. Coen-Porisini, G. Denaro, C. Ghezzi, and M. Pezzé, “Using
Symbolic Execution for Verifying Safety-Critical Systems,” in ACM
SE Notes’01.
[46] M. A. Colón, S. Sankaranarayanan, and H. B. Sipma, “Linear Invariant
Generation Using Non-Linear Constraint Solving,” in CAV’03.
[47] P. Cousot and R. Cousot, “Abstract Interpretation: A Uniﬁed Lattice
Model for Static Analysis of Programs by Construction or Approxi-
mation of Fixpoints,” in POPL’77.
[48] P. Cousot, R. Cousot, J. Feret, L. Mauborgne, A. Miné, D. Monniaux,
and X. Rival, “The ASTRÉE Analyzer,” in ESOP’05.
[49] W. Cui, J. Kannan, and H. J. Wang, “Discoverer: Automatic Protocol
Reverse Engineering from Network Traces,” in USENIX Security’07.
[50] R. Dannenberg and G. Ernst, “Formal Program Veriﬁcation using
Symbolic Execution,” in IEEE TSE’82.
[51] M. Davis, G. Logemann, and D. Loveland, “A Machine Program for
Theorem-proving,” Communications of the ACM, 1962.
[52] E. de Castro Lopo. libsndﬁle. http://www.mega-nerd.com/libsndﬁle/.
[53] L. de Moura and N. Bjørner, “Z3: An Efﬁcient SMT Solver,” in
TACAS’08.
[54] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant, C. Pacheco, M. S.
Tschantz, and C. Xiao, “The Daikon system for dynamic detection of
likely invariants,” in Science of Computer Programming, 2007.
[55] K.-I. Funahashi, “On the approximate realization of continuous map-
pings by neural networks,” in Neural Networks’89.
[56] V. Ganesh, A. Kie˙zun, S. Artzi, P. J. Guo, P. Hooimeijer, and M. Ernst,
“HAMPI: A String Solver for Testing, Analysis and Vulnerability
Detection,” in CAV’11.
[57] S. Gao, S. Kong, and E. M. Clarke, “dReal: An SMT Solver for
Nonlinear Theories over the Reals,” in CADE’13.
[58] P. Garg, C. Löding, P. Madhusudan, and D. Neider, “ICE: A Robust
Framework for Learning Invariants,” in CAV’14.
[59] X. Glorot, A. Bordes, and Y. Bengio, “Deep Sparse Rectiﬁer Neural
Networks,” in AISTATS’11.
[60] P. Godefroid, “Compositional Dynamic Test Generation,” in POPL’07.
[61] P. Godefroid, A. Kiezun, and M. Y. Levin, “Grammar-based Whitebox
Fuzzing,” in PLDI’08.
[62] P. Godefroid, N. Klarlund, and K. Sen, “DART: Directed Automated
Random Testing,” in PLDI’05.
[63] P. Godefroid, M. Y. Levin, D. A. Molnar et al., “Automated Whitebox
Fuzz Testing,” in NDSS’08.
[64] L. B. Godfrey and M. S. Gashler, “A Continuum among Logarithmic,
to Improve
Linear, and Exponential Functions, and Its Potential
Generalization in Neural Networks,” in IC3K’15.
I. J. Goodfellow, J. Shlens, and C. Szegedy, “Explaining and Harness-
ing Adversarial Examples,” in ICLR’15.
[65]
[66] A. Gupta and A. Rybalchenko, “InvGen: An Efﬁcient Invariant Gen-
erator,” in CAV’09.
[67] R. Jhala and K. L. McMillan, “A Practical and Complete Approach
to Predicate Reﬁnement,” in TACAS’06.
J. C. King, “Symbolic Execution and Program Testing,” Communica-
tions of the ACM, 1976.
[68]
[69] D. P. Kingma and J. Ba, “Adam: A Method for Stochastic Optimiza-
tion,” in ICLR’15.
[70] S. Krishna, C. Puhrsch, and T. Wies, “Learning Invariants using
Decision Trees,” arXiv, 2015.
[71] A. Krizhevsky, I. Sutskever, and G. E. Hinton, “ImageNet Classiﬁca-
tion with Deep Convolutional Neural Networks,” in NIPS’12.
[72] V. Kuznetsov, J. Kinder, S. Bucur, and G. Candea, “Efﬁcient State
Merging in Symbolic Execution,” in PLDI’12.
[73] G. Li, E. Andreasen, and I. Ghosh, “SymJS: Automatic Symbolic
Testing of JavaScript Web Applications,” in FSE’14.
15
[74] X. Li, Y. Liang, H. Qian, Y.-Q. Hu, L. Bu, Y. Yu, X. Chen, and
X. Li, “Symbolic Execution of Complex Program Driven by. Machine
Learning Based Constraint Solving,” in ASE’16.
J. H. Liang, V. Ganesh, P. Poupart, and K. Czarnecki, “Exponential
Recency Weighted Average Branching Heuristic for SAT Solvers,” in
AAAI’16.
[75]
[76] K. McMillan, “Interpolation and SAT-based Model Checking,” in
CAV’03.
[77] L. Medsker and L. Jain, Recurrent Neural Networks: Design and
Applications. CRC press, 1999.
[78] D. Molnar, X. C. Li, and D. Wagner, “Dynamic Test Generation to Find
Integer Bugs in x86 Binary Linux Programs,” in USENIX Security’09.
[79] N. Narodytska, S. P. Kasiviswanathan, L. Ryzhyk, M. Sagiv, and
T. Walsh, “Verifying Properties of Binarized Deep Neural Networks,”
arXiv, 2017.
[80] H. D. T. Nguyen, D. Qi, A. Roychoudhury, and S. Chandra, “SemFix:
Program Repair via Semantic Analysis,” in ICSE ’13.
[81] T. Nguyen, T. Antonopoulos, A. Ruef,
and M. Hicks,
“Counterexample-Guided Approach to Finding Numerical Invariants,”
in FSE’17.
[82] T. Nguyen, D. Kapur, W. Weimer, and S. Forrest, “DIG: A Dynamic
Invariant Generator for Polynomial and Array Invariants.”
[83] S. Padhi and T. Millstein, “Data-Driven Loop Invariant Inference with
Automatic Feature Synthesis,” arXiv, 2017.
[84] D. Qi, H. Nguyen, and A. Roychoudhury, “Path Exploration using
Symbolic Output,” in TOSEM’13.
[85] N. Qian, “On the Momentum Term in Gradient Descent Learning
Algorithms,” in Neural Networks’99.
[86] E. Rodríguez-Carbonell and D. Kapur, “Automatic Generation of Poly-
nomial Invariants of Bounded Degree using Abstract Interpretation,”
Science of Computer Programming, 2007.
[87] S. Ruder, “An Overview of Gradient Descent Optimization Algo-
rithms,” arXiv, 2016.
[88] D. E. Rumelhart, G. E. Hinton, and R. J. Williams, Learning Internal
Representations by Error Propagation, 1985.
[89] P. Rümmer and T. Wahl, “An SMT-LIB Theory of Binary Floating-
Point Arithmetic,” in SMT’10.
[90] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and D. Song,
“A Symbolic Execution Framework for JavaScript,” in SP’10.
[91] P. Saxena, P. Poosankam, S. McCamant, and D. Song, “Loop-Extended
Symbolic Execution on Binary Programs,” in ISSTA’09.
[92] K. Sen, G. Necula, L. Gong, and W. Choi, “multiSE: Multi-path
Symbolic Execution,” in FSE’15.
[93] D. She, K. Pei, D. Epstein, J. Yang, B. Ray, and S. Jana, “NEUZZ:
Efﬁcient Fuzzing with Neural Program Smoothing,” arXiv, 2018.
[94] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kruegel, and G. Vigna,
“SoK: (State of) The Art of War: Offensive Techniques in Binary
Analysis,” in SP’16.
[95] S. F. Siegel, M. Zheng, Z. Luo, T. K. Zirkel, A. V. Marianiello, J. G.
Edenhofner, M. B. Dwyer, and M. S. Rogers, “CIVL: The Concurrency
Intermediate Veriﬁcation Language,” in SC’15.
[96] N. Srivastava, G. Hinton, A. Krizhevsky, I. Sutskever, and R. Salakhut-
dinov, “Dropout: A Simple Way to Prevent Neural Networks from
Overﬁtting,” JMLR’14.
[97] X. Xie, B. Chen, Y. Liu, W. Le, and X. Li, “Proteus: Computing Dis-
junctive Loop Summary via Path Dependency Analysis,” in FSE’16.
[98] Y. Yao, L. Rosasco, and A. Caponnetto, “On Early Stopping in
Gradient Descent Learning,” Constructive Approximation, 2007.
[99] Y. Yu, H. Qian, and Y.-Q. Hu, “Derivative-Free Optimization via
Classiﬁcation,” in AAAI’16.
[100] Y. Zheng, X. Zhang, and V. Ganesh, “Z3-str: A Z3-Based String Solver
for Web Application Analysis,” in FSE’13.
[101] M. Zitser, R. Lippmann, and T. Leek, “Testing Static Analysis Tools
using Exploitable Buffer Overﬂows from Open Source Code,” in ACM
SIGSOFT Software Engineering Notes, 2004.