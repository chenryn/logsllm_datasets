ery identifier mentioned here, save for the Bluetooth MAC address.
Apps may need specific permissions to access some of these
sources of device-public information, therefore a careful user may
be able to notice that a malicious application is accessing some
device-public information. However, while Android 6 introduced
a feature alerting the user at the time some permissions are used,
a malicious app can bypass this alert by lowering its own “Target
SDK Version.” By doing this, the old permission model, in which the
user is not informed the moment an app uses a permission, is used.
ANDROID_ID. This is a device’s unique ID number, set by Android
upon a device’s first boot or factory reset.
IMEI. The IMEI is a hardware identifier given to each piece of
cellular equipment, including the baseband radios of mobile phones.
WiFi MAC address. Similar to the IMEI, MAC addresses are
uniquely assigned to most conventional network hardware. The
WiFi MAC address can be obtained by any app requesting the
ACCESS_WIFI_STATE, using the API WifiInfo.getMacAddress().
In Android 6 (and later versions), the behavior of this API has been
changed, so that it always returns the value 02:00:00:00:00:00.
However, we found that it is still possible to access this identifier
using the NetworkInterface.getHardwareAddress() API.
Bluetooth MAC Address. The device’s Bluetooth MAC address
is a persistent hardware identifier that can be queried by using
the API BluetoothAdapter.getAddress(). This API requires
the BLUETOOTH permission. Starting from Android 6, the behavior
of this API has been changed, so that it always returns the value
02:00:00:00:00:00.
ADB serial number. The device’s ADB Serial Number, which
is used to identify devices on the Android Debug Bridge, is an
identifier that persists across factory resets. It can be accessed by
querying the android.os.SystemProperties object using the
key ro.serialno.
Google account email. Many Android devices use Google account
emails as a form of Single Sign-On, and the email address used can
be easily obtained using the AccountManager API.
Google Service Framework ID. This ID is used to identify a user
when accessing Google Service Framework applications.
Google Advertising ID. In an attempt to allow users to opt-out of
mobile ad tracking campaigns, Google created a specific persistent
identifier [15] to be used with advertising. It can be queried by
any app (through the AdvertisingIdClient class in the Google
Play Services), but, unlike the other identifiers, also freely reset by
the user. Google’s policy [18] states that all advertising must use
exclusively this identifier for tracking (“in place of any other device
identifiers for any advertising purposes”), although in practice it
is often not used [35].
Phone number. We consider the phone number associated with
the SIM card inserted in a device as device-public information. A
specific API (getLine1Number, requiring the READ_PHONE_STATE
permission) exists to retrieve this value, however the returned value
is not always reliable, depending on the SIM Card manufacturer.
Various workarounds do exist, including reading the call log, which
requires the READ_CALL_LOG permission.
Received SMS Messages. Any app (with proper permissions) can
request to be notified of the origin and content of new SMS messages.
Incoming Phone Calls. Apps can request to be notified about the
basic data of incoming calls, including the caller’s number. Addition-
ally, Apps can also read the call history. Interestingly, phone calls
can be used for authentication, by using part of the sender’s phone
number (which remote services can control) as a verification code.
SIM Card Serial Number. In devices where a SIM Card is present,
apps can access this identifier, which is tied to the used SIM Card,
by using the getSimSerialNumber API.
External Storage. Many Android devices today come with, or have
the ability to add, some form of external storage, usually in the form
of a larger Flash-based storage device or SD card. The precise behav-
ior of external storage differs among Android versions and devices,
ACSAC 2017, December 4–8, 2017, San Juan, PR, USA
A. Bianchi et al.
Table 1: Considered sources of device-public information.
Source
Required Permission
Survives
factory reset
Linked to a
Google Account
Linked to a
SIM Card
ANDROID_ID
IMEI
WiFi MAC address
Bluetooth MAC address
Google account email
Google Service Framework ID
Google Advertising ID
–
READ_PHONE_STATE
ACCESS_WIFI_STATE
BLUETOOTH
GET_ACCOUNTS
READ_GSERVICES
–
Phone Number READ_PHONE_STATE or READ_CALL_LOG
Incoming Phone Calls
SIM Card Serial Number
Received SMS Messages
External Storage
READ_CALL_LOG
READ_PHONE_STATE
RECEIVE_SMS or READ_SMS
READ_EXTERNAL_STORAGE
–
✓
✓
✓
–
–
–
–
–
–
–
–
–
–
–
–
✓
✓
✓
–
–
–
–
–
–
–
–
–
–
–
–
✓
✓
✓
✓
–
but, typically, any app can request the READ_EXTERNAL_STORAGE
permission to access its contents. This gives the app access to the
public areas of the external storage, shared by all apps.
Files stored in here are publicly accessible and some of them are
not deleted upon app’s uninstallation [23]. Therefore, as a usability
feature for the users, some apps store authentication cookies in
this location, so that the credentials survive app’s re-installation.
Unfortunately, while this may sound a reasonable practice, it is not
secure. In fact, in this scenario, an attacker would be able to easily
hijack the user’s account by reading the files containing these
authentication cookies and using their content to authenticate with
the victim apps’ remote backends.
For the attacker’s device, we created the “ID Injector,” which
takes data from the “ID Leaker” and injects them into an attacker-
controlled device. We use the Xposed framework [1] (a tool for
performing run-time patching of the Android framework) to
easily hook the Android API methods used to query device-public
information, and spoof their results to return the data leaked from
the victim. The external storage’s content is also transferred from
the victim and copied into place. Without external information,
there is no way for the app under analysis to tell that the data has
been spoofed. Because of our usage of the Xposed framework, the
attacker-controlled device (but not the victim’s one) must be rooted
to properly spoof the received identity.
3.3 Proof-of-Concept Attack Implementation
In simple terms, the attack consists of an app on the victim’s device,
which steals a set of device- and user-specific information, and exfil-
trates it to the attacker. The attacker can then inject this information
into their own device, so that apps behave seamlessly as if they are
still on the victim’s device. In particular, the attacker can use vul-
nerable apps as if authenticated as the victim on the victim’s phone.
We implemented the “identity transfer” attack in two different
components: the “ID Leaker,” and the “ID Injector.” The “ID Leaker”
app, which could be thought of as a prototypical third-party
malicious application, requires the Android permissions to access
the SMS, device call notifications, external storage contents, and
static device identifiers (refer to Table 1). The app then uses the well-
documented Android APIs to access and leak the device-public data
that constitutes the user’s identity, and it sends it to the attacker’s
device. We note that the app’s functionality could be easily hidden
inside a seemingly legitimate app, and that it can run on completely
unmodified devices without requiring any admin privileges (there-
fore on un-rooted devices). We also note that if an attacker aims at
hijacking the account of a specific victim app, the “ID Leaker” only
requires the permissions needed to access the specific device-public
information used by the victim app for authentication purposes.
4 VULNERABILITY DETECTION
In order to understand how widespread device-public authenti-
cation schemes are on Android, we created an automated system
to locate vulnerable apps in the wild. This system could also be
used by security researchers, software developers, and app market
operators to automatically spot weakness in the authentication
mechanisms used by the analyzed apps.
While the attack described in Section 3.3 is very effective against
vulnerable apps, we cannot simply use it against all apps to build a de-
tection system, for two main reasons. First, it is difficult to differenti-
ate success of the attack from other application behaviors, as we have
no baseline of the app’s normal behavior to compare it to, and cannot
link changes in this behavior to device-public information. Second,
as we discuss in Section 2, “authentication” can be implemented in
a variety of ways, making it difficult, if not impossible, to concretely
define and locate authentication behaviors in a generalized way. We
therefore cannot rely on any direct knowledge of the authentication
itself to help understand when our exploit is having an effect.
To address these challenges, we developed an approach that
aims at identifying authentication behaviors indirectly. We build
our approach on the observation that an app behaves differently
depending on whether or not it has already authenticated its user
to a previously created account, and that this difference will be
reflected in the app’s user interface.
Exploitation and Mitigation of Authentication Schemes. . .
ACSAC 2017, December 4–8, 2017, San Juan, PR, USA
Thus, as a first step, the system executes the app, provides any
requested device-public information to the app, and records the
app’s behaviors. These behaviors are in the form of a trace of
different UI states (as detailed in Section 4.4). The aim of this initial
execution is both to trigger the app’s authentication or registration
mechanism, as well as to get the server’s backend to store some
sort of state for the user, which can be observed in future traces.
Next, all app-private information for the app is deleted. We
achieve this by uninstalling and re-installing the app. This operation
deletes all app’s files in private locations.
At this point, the app is executed again and, if the behavior is
different from the one observed during the first run, it is possible
that the app may be using device-public information (which could
be both device’s identifiers or publicly accessible files in the external
storage) to authenticate the user. Typically, a difference may be
observable because of the absence of a “login” screen due to already
being authenticated, or the absence of an introductory “welcome”
screen due to restoring the previously-saved user state, but more
subtle UI modifications are possible.
As a last step, the system confirms the vulnerability, by
transferring the device-public information to a different device,
executing the app again, and comparing these behaviors with the
previous ones. This transfer operation encompasses copying both
publicly accessible files and device’s identifiers.
In the remainder of this section, we will first discuss in detail
the three steps of our analysis, as shown in Figure 1. We will then
provide several technical details about the underlying dynamic
analysis and the comparison of states and traces.
4.1 Step 1: Capturing Initial Behavior
First, we need to characterize the behavior of a given application
when installed for the first time on an Android device. Our system
functions primarily by collecting and comparing traces, consisting
of an ordered list of UI states encountered during a given execution
of the app. Details of how states and traces are collected and
compared can be found in Section 4.4.
However, our system truly needs to characterize the “normal”
behavior, not just merely record one execution. This is far from
trivial, mainly due to the fact that dynamic analysis is hindered by
non-deterministic behaviors present in apps, the OS, and network
communications. To address this challenge, we first execute the
analyzed application on multiple devices, collecting multiple traces.
Recent work has shown that running the same app multiple times
is, in Android, effective in reducing the effects of non-deterministic
behaviors during dynamic analysis [9]. The collected app behaviors
are then used to compute a so-called Invariant, representing the most
common set of behaviors. Specifically, the Invariant set is computed
as the set of all states that appear in all the collected traces.
4.2 Step 2: Vulnerability Detection
In this step, we delete all app-private data from the devices used in
Step 1, collect new traces, and compare them with the Invariant. We
accomplish clearing the app-private data by re-installing the app,
which is known to remove all app-private information, including
authentication tokens, cookies, databases and other private files.
After re-installation, the app is dynamically stimulated, and
traces are collected in the same way as in Step 1. Then, we compare
the new traces against the Invariant, looking for behavioral
differences in the traces. These discrepancies are typically due to
setup, registration, or login interfaces. Therefore, they are a strong
signal the app was able to authenticate with the remote backend,