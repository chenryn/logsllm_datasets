secure function evaluation on mobile devices. In
Journal of Security and Communication Networks
(SCN), To appear 2014.
[8] H. Carter, B. Mood, P. Traynor, and K. Butler.
Secure outsourced garbled circuit evaluation for
mobile devices. In Proceedings of the USENIX
Security Symposium, 2013.
[9] I. Damg˚ard, M. Geisler, M. Krøigaard, and J. B.
Nielsen. Asynchronous multiparty computation:
Theory and implementation. In Proceedings of the
12th International Conference on Practice and Theory
in Public Key Cryptography: PKC ’09, Irvine, pages
160–179, Berlin, Heidelberg, 2009. Springer-Verlag.
[10] C. Gentry, S. Gorbunov, S. Halevi,
V. Vaikuntanathan, and D. Vinayagamurthy. How to
compress (reusable) garbled circuits. Cryptology
ePrint Archive, Report 2013/687, 2013.
http://eprint.iacr.org/.
[11] C. Gentry, S. Halevi, S. Lu, R. Ostrovsky,
M. Raykova, and D. Wichs. Garbled ram revisited. In
Advances in Cryptology–EUROCRYPT 2014, pages
405–422. Springer Berlin Heidelberg, 2014.
[12] C. Gentry, S. Halevi, and N. P. Smart. Homomorphic
Evaluation of the AES Circuit. In Proceedings of
CRYPTO, 2012.
[13] S. Goldwasser, Y. Kalai, R. A. Popa,
V. Vaikuntanathan, and N. Zeldovich. Reusable
Garbled Circuits and Succinct Functional Encryption.
In Proceedings of the ACM Symposium on Theory of
Computing (STOC), STOC ’13, 2013.
[14] V. Goyal, P. Mohassel, and A. Smith. Eﬃcient two
party and multi party computation against covert
adversaries. In Proceedings of the theory and
applications of cryptographic techniques annual
international conference on Advances in cryptology,
2008.
[15] S. Halevi, Y. Lindell, and B. Pinkas. Secure
Computation on the Web: Computing without
Simultaneous Interaction. In CRYPTO’11, 2011.
[16] W. Henecka, S. K¨ogl, A.-R. Sadeghi, T. Schneider,
and I. Wehrenberg. Tasty: tool for automating secure
two-party computations. In Proceedings of the ACM
conference on Computer and Communications
Security, 2010.
[17] A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith.
Secure two-party computations in ansi c. In
Proceedings of the 2012 ACM Conference on
Computer and Communications Security, CCS ’12,
pages 772–783, New York, NY, USA, 2012. ACM.
[18] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster
secure two-party computation using garbled circuits.
In Proceedings of the USENIX Security Symposium,
2011.
[19] Y. Huang, J. Katz, and D. Evans.
Quid-Pro-Quo-tocols: Strengthening Semi-Honest
Protocols with Dual Execution. IEEE Symposium on
Security and Privacy, (33rd), May 2012.
[20] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank.
Extending oblivious transfers eﬃciently. In
Proceedings of CRYPTO, 2003.
[21] S. Kamara, P. Mohassel, M. Raykova, and
S. Sadeghian. Scaling private set intersection to
billion-element sets. Technical Report
MSR-TR-2013-63, Microsoft Research, 2013.
[22] S. Kamara, P. Mohassel, and B. Riva. Salus: A system
for server-aided secure function evaluation. In
Proceedings of the ACM conference on Computer and
communications security (CCS), 2012.
[23] F. Kerschbaum. Expression rewriting for optimizing
secure computation. In Conference on Data and
Application Security and Privacy, 2013.
[24] M. S. Kiraz and B. Schoenmakers. A protocol issue for
the malicious case of yao’s garbled circuit
construction. In Proceedings of Symposium on
Information Theory in the Benelux, 2006.
[25] V. Kolesnikov and T. Schneider. Improved Garbled
Circuit: Free XOR Gates and Applications. In
Proceedings of the international colloquium on
Automata, Languages and Programming, Part II, 2008.
[26] B. Kreuter, B. Mood, a. shelat, and K. Butler. PCF:
A Portable Circuit Format for Scalable Two-Party
Secure Computation. In Proceedings of the USENIX
Security Symposium, 2013.
[27] B. Kreuter, a. shelat, and C.-H. Shen. Billion-gate
secure computation with malicious adversaries. In
Proceedings of the USENIX Security Symposium, 2012.
[28] L. Kruger, S. Jha, E.-J. Goh, and D. Boneh. Secure
function evaluation with ordered binary decision
diagrams. In Proceedings of the ACM conference on
Computer and communications security (CCS), 2006.
[29] Y. Lindell and B. Pinkas. An eﬃcient protocol for
secure two-party computation in the presence of
malicious adversaries. In Proceedings of the annual
international conference on Advances in Cryptology,
2007.
[30] S. Lu and R. Ostrovsky. How to garble ram programs.
In Advances in Cryptology–EUROCRYPT 2013, pages
719–734. Springer Berlin Heidelberg, 2013.
[31] S. Lu and R. Ostrovsky. Garbled ram revisited, part
ii. Cryptology ePrint Archive, Report 2014/083, 2014.
http://eprint.iacr.org/.
[32] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella.
Fairplay–a secure two-party computation system. In
Proceedings of the USENIX Security Symposium, 2004.
[33] B. Mood, L. Letaw, and K. Butler. Memory-eﬃcient
garbled circuit generation for mobile devices. In
Proceedings of the IFCA International Conference on
Financial Cryptography and Data Security (FC), 2012.
[34] M. Naor and B. Pinkas. Oblivious transfer and
polynomial evaluation. In Proceedings of the annual
ACM Symposium on Theory of Computing (STOC),
1999.
[35] M. Naor and B. Pinkas. Eﬃcient oblivious transfer
protocols. In Proceedings of the annual ACM-SIAM
Symposium on Discrete algorithms (SODA), 2001.
[36] B. Pinkas, T. Schneider, N. P. Smart, and S. C.
Williams. Secure Two-Party Computation is Practical.
In ASIACRYPT, 2009.
[37] a. shelat and C.-H. Shen. Two-output secure
computation with malicious adversaries. In
Proceedings of EUROCRYPT, 2011.
[38] a. shelat and C.-H. Shen. Fast two-party secure
computation with minimal assumptions. In Conference
on Computer and Communications Security (CCS),
2013.
[39] A. C. Yao. Protocols for secure computations. In
Proceedings of the IEEE Symposium on Foundations
of Computer Science (FOCS), 1982.
[40] Y. Zhang, A. Steele, and M. Blanton. PICCO: A
General-purpose Compiler for Private Distributed
Computation. In Proceedings of the ACM Conference
on Computer Communications Security (CCS), 2013.
APPENDIX
A. CMTB PROTOCOL
As we are building oﬀ of the CMTB garbled circuit exe-
cution system, we give an abbreviated version of the proto-
col. In our description we refer to the generator, the cloud,
and the evaluator. The cloud is the party the evaluator out-
sources her computation to.
Circuit generation and check: The template for the gar-
bled circuit is augmented to add one-time XOR pads on the
output bits and split the evaluator’s input wires per the in-
put encoding scheme. The generator generates the necessary
garbled circuits and commits to them and sends the com-
mitments to the evaluator. The generator then commits to
input labels for the evaluator’s inputs.
CMTB relies on Goyal et al.’s [14] random seed check,
which was implemented by Kreuter et al. [27] to combat
generation of incorrect circuits. This technique uses a cut-
and-choose style protocol to determine whether the genera-
tor created the correct circuits by creating and committing
to many diﬀerent circuits. Some of those circuits are used
for evaluation, while the others are used as check circuits.
Evaluator’s inputs: Rather than a two-party oblivious
transfer, we perform a three-party outsourced oblivious trans-
fer. An outsourced oblivious transfer is an OT that gets the
select bits from one party, the wire labels from another, and
returns the selected wire labels to a third party. The party
that selects the wire labels does not learn what the wire la-
bels are, and the party that inputs the wire labels does not
learn which wire was selected; the third party only learns
the selected wire labels. In CMTB, the generator oﬀers up
wire labels, the evaluator provides the select bits, and the
cloud receives the selected labels. CMTB uses the Ishai OT
extension [20] to reduce the number of OTs.
CMTB uses an encoding technique from Lindell and Pinkas
[29], which prevents the generator from ﬁnding out any in-
formation about the evaluator’s input if a selective failure
attack transpires. CMTB also uses the commitment tech-
nique of Kreuter et al. [27] to prevent the generator from
swapping the two possible outputs of the oblivious transfer.
To ensure the evaluator’s input is consistent across all cir-
cuits, CMTB uses a technique from Lindell and Pinkas [29],
whereby the inputs are derived from a single oblivious trans-
fer.
Generator’s input and consistency check: The gener-
ator sends his input to the cloud for the evaluation circuits.
Then the generator, evaluator, and cloud all work together
to prove the input consistency of the generator’s input. For
the generator’s input consistency check, CMTB uses the
malleable-claw free construction from shelat and Shen [37].
Circuit evaluations: The cloud evaluates the garbled cir-
Figure 7: The amount of time it takes to save and load a bit
in PartialGC when using 256 circuits.
cuits marked for evaluation and checks the circuits marked
for checking. The cloud enters in the generator and eval-
uator’s input into each garbled circuit and evaluates each
circuit. The output for any particular bit is then the ma-
jority output between all evaluator circuits. The cloud then
recreates each check circuit. The cloud creates the hashes of
each garbled circuit and sends those hashes to the evaluator.
The evaluator then veriﬁes the hashes are the same as the
ones the generator previously committed to.
Output consistency check and output: The three par-
ties prove together that the cloud did not modify the output
before she sent it to the generator or evaluator. Both the
evaluator and generator receive their respective outputs. All
outputs are blinded by the respective party’s one-time pad
inside the garbled circuit to prevent the cloud from learning
what any output bit represents.
CMTB uses the XOR one-time pad technique from Ki-
raz [24] to prevent the evaluator from learning the gener-
ator’s real output. To prevent output modiﬁcation, CMTB
uses the witness-indistinguishable zero-knowledge proof from
Kreuter et al. [27].
B. OVERHEAD OF REUSING VALUES
We created several versions of the keyed database program
to determine the runtime of saving and loading the database
on a per bit basis using our system (See Figure 7). This
ﬁgure shows it is possible to save and load a large amount
of saved wire labels in a relatively short time. The time to
load a wire label is larger than the time to save a value since
saving only involves saving the wire label to a ﬁle and loading
involves reading from a ﬁle and creating the partial input
gates. Although not shown in the ﬁgure, the time to save or
load a single bit also increases with the circuit parameter.
This is because we need S copies of that bit - one for every
circuit.
C. EXAMPLE PROGRAM
In this section we describe the execution of an attendance
application. Imagine a building where the host wants each
user to sign in from their phones to keep a log of the guests,
but also wants to keep this information secret.
This application has three distinct programs. The ﬁrst
program initializes a counter to a number input by the eval-
uator. The second program, which is used until the last pro-
gram is called, takes in a name and increments the counter
 0 0.0005 0.001 0.0015 0.002 0.0025 0.003Keyed64Keyed128Keyed256Time (s)ProgramLoadSaveCount
2
Saved Guests
Guest1
Guest2
Guest 3 then enters the dwelling and executes the program
as before. At this point, the memory is as follows:
Count
3
Saved Guests
Guest1
Guest2
Guest3
Finally, the host runs the last program that outputs the
count and the guests in the database. In this case the count
is 3 and the guests are Guest1, Guest2, and Guest3.
by one. The last program outputs all names and returns the
count of users.
For this application, users (rather, their mobile phones)
assume the role of evaluators in the protocol (Section 4).
First, the host runs the initial program to initialize a
database. We cannot execute the second program to add
names to the log until this is done, lest we reveal that there
is no memory saved (i.e., there is no one else present).
Protocol in Brief: In this ﬁrst program, the cut-and-choose
OT is executed to select the circuit split (the circuits that
are for evaluation and generation). Both parties save the de-
cryption keys: the cloud saves the keys attained from the OT
and the generator saves both possible keys that could have
been selected by the cloud. The evaluator performs the OOT
with the other parties to input the initial value into the pro-
gram. There is no input by the generator so the generator’s
input check does not execute. There is no partial input so
that phase of the protocol is skipped. The garbled circuit to
set the initial value is executed; while there is no output to
the generator or evaluator, a partial output is produced: the
cloud saves the garbled wire value, which it possesses, and
the generator saves both possible wire values (the generator
does not know what value the cloud has, and the cloud does
not know what the value it has saved actually represents).
The cloud also saves the circuit split.
Saved memory after the program execution (when the
evaluator inputs 0 as the initial value):
Count
0
Saved Guests
Guest 1 then enters the building and executes the pro-
gram, entering his name (“Guest 1”) as input.
Protocol in Brief: In this second program, the cut-and-
choose OT is not executed. Instead, both the generator and
cloud load the saved decryption key values, hash them, and
use those values for the check and evaluation circuit infor-
mation (instead of attaining new keys through an OT, which
would break security). The new keys are saved, and the eval-
uator then performs the OOT for input. The generator does
not have any input in this program so the check for the gen-
erator’s input is skipped. Since there exists a partial input,
the generator loads both possible wire values and creates
the partial input gates. The cloud loads the attained values,
receives the partial input gates from the generator, and then
executes (and checks) the partial input gates to receive the
garbled input values. The garbled circuit is then executed
and partial output saved as before (although there is more
data to save for this program as there is a name present in
the database).
After executing the second program the memory is as fol-
lows:
Count
1
Saved Guests
Guest1
Guest 2 then enters the dwelling and runs the program.
The execution is similar to the previous one (when Guest 1
entered), except that it’s executed by Guest 2’s phone.
At this point, the memory is as follows: