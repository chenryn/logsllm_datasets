### Secure Function Evaluation on Mobile Devices
**Journal of Security and Communication Networks (SCN), To Appear 2014.**

### References

1. **H. Carter, B. Mood, P. Traynor, and K. Butler.**
   - **Title:** Secure outsourced garbled circuit evaluation for mobile devices.
   - **Publication:** Proceedings of the USENIX Security Symposium, 2013.

2. **I. Damgård, M. Geisler, M. Krøigaard, and J. B. Nielsen.**
   - **Title:** Asynchronous multiparty computation: Theory and implementation.
   - **Publication:** Proceedings of the 12th International Conference on Practice and Theory in Public Key Cryptography: PKC ’09, Berlin, Heidelberg, pages 160–179, 2009. Springer-Verlag.

3. **C. Gentry, S. Gorbunov, S. Halevi, V. Vaikuntanathan, and D. Vinayagamurthy.**
   - **Title:** How to compress (reusable) garbled circuits.
   - **Publication:** Cryptology ePrint Archive, Report 2013/687, 2013. [http://eprint.iacr.org/](http://eprint.iacr.org/)

4. **C. Gentry, S. Halevi, S. Lu, R. Ostrovsky, M. Raykova, and D. Wichs.**
   - **Title:** Garbled RAM revisited.
   - **Publication:** Advances in Cryptology–EUROCRYPT 2014, pages 405–422. Springer Berlin Heidelberg, 2014.

5. **C. Gentry, S. Halevi, and N. P. Smart.**
   - **Title:** Homomorphic Evaluation of the AES Circuit.
   - **Publication:** Proceedings of CRYPTO, 2012.

6. **S. Goldwasser, Y. Kalai, R. A. Popa, V. Vaikuntanathan, and N. Zeldovich.**
   - **Title:** Reusable Garbled Circuits and Succinct Functional Encryption.
   - **Publication:** Proceedings of the ACM Symposium on Theory of Computing (STOC), STOC ’13, 2013.

7. **V. Goyal, P. Mohassel, and A. Smith.**
   - **Title:** Efficient two-party and multi-party computation against covert adversaries.
   - **Publication:** Proceedings of the theory and applications of cryptographic techniques annual international conference on Advances in cryptology, 2008.

8. **S. Halevi, Y. Lindell, and B. Pinkas.**
   - **Title:** Secure Computation on the Web: Computing without Simultaneous Interaction.
   - **Publication:** CRYPTO’11, 2011.

9. **W. Henecka, S. Kögl, A.-R. Sadeghi, T. Schneider, and I. Wehrenberg.**
   - **Title:** TASTY: Tool for automating secure two-party computations.
   - **Publication:** Proceedings of the ACM conference on Computer and Communications Security, 2010.

10. **A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith.**
    - **Title:** Secure two-party computations in ANSI C.
    - **Publication:** Proceedings of the 2012 ACM Conference on Computer and Communications Security, CCS ’12, pages 772–783, New York, NY, USA, 2012. ACM.

11. **Y. Huang, D. Evans, J. Katz, and L. Malka.**
    - **Title:** Faster secure two-party computation using garbled circuits.
    - **Publication:** Proceedings of the USENIX Security Symposium, 2011.

12. **Y. Huang, J. Katz, and D. Evans.**
    - **Title:** Quid-Pro-Quo-tocols: Strengthening Semi-Honest Protocols with Dual Execution.
    - **Publication:** IEEE Symposium on Security and Privacy, (33rd), May 2012.

13. **Y. Ishai, J. Kilian, K. Nissim, and E. Petrank.**
    - **Title:** Extending oblivious transfers efficiently.
    - **Publication:** Proceedings of CRYPTO, 2003.

14. **S. Kamara, P. Mohassel, M. Raykova, and S. Sadeghian.**
    - **Title:** Scaling private set intersection to billion-element sets.
    - **Publication:** Technical Report MSR-TR-2013-63, Microsoft Research, 2013.

15. **S. Kamara, P. Mohassel, and B. Riva.**
    - **Title:** Salus: A system for server-aided secure function evaluation.
    - **Publication:** Proceedings of the ACM conference on Computer and communications security (CCS), 2012.

16. **F. Kerschbaum.**
    - **Title:** Expression rewriting for optimizing secure computation.
    - **Publication:** Conference on Data and Application Security and Privacy, 2013.

17. **M. S. Kiraz and B. Schoenmakers.**
    - **Title:** A protocol issue for the malicious case of Yao’s garbled circuit construction.
    - **Publication:** Proceedings of Symposium on Information Theory in the Benelux, 2006.

18. **V. Kolesnikov and T. Schneider.**
    - **Title:** Improved Garbled Circuit: Free XOR Gates and Applications.
    - **Publication:** Proceedings of the international colloquium on Automata, Languages and Programming, Part II, 2008.

19. **B. Kreuter, B. Mood, a. shelat, and K. Butler.**
    - **Title:** PCF: A Portable Circuit Format for Scalable Two-Party Secure Computation.
    - **Publication:** Proceedings of the USENIX Security Symposium, 2013.

20. **B. Kreuter, a. shelat, and C.-H. Shen.**
    - **Title:** Billion-gate secure computation with malicious adversaries.
    - **Publication:** Proceedings of the USENIX Security Symposium, 2012.

21. **L. Kruger, S. Jha, E.-J. Goh, and D. Boneh.**
    - **Title:** Secure function evaluation with ordered binary decision diagrams.
    - **Publication:** Proceedings of the ACM conference on Computer and communications security (CCS), 2006.

22. **Y. Lindell and B. Pinkas.**
    - **Title:** An efficient protocol for secure two-party computation in the presence of malicious adversaries.
    - **Publication:** Proceedings of the annual international conference on Advances in Cryptology, 2007.

23. **S. Lu and R. Ostrovsky.**
    - **Title:** How to garble RAM programs.
    - **Publication:** Advances in Cryptology–EUROCRYPT 2013, pages 719–734. Springer Berlin Heidelberg, 2013.

24. **S. Lu and R. Ostrovsky.**
    - **Title:** Garbled RAM revisited, part II.
    - **Publication:** Cryptology ePrint Archive, Report 2014/083, 2014. [http://eprint.iacr.org/](http://eprint.iacr.org/)

25. **D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella.**
    - **Title:** Fairplay–a secure two-party computation system.
    - **Publication:** Proceedings of the USENIX Security Symposium, 2004.

26. **B. Mood, L. Letaw, and K. Butler.**
    - **Title:** Memory-efficient garbled circuit generation for mobile devices.
    - **Publication:** Proceedings of the IFCA International Conference on Financial Cryptography and Data Security (FC), 2012.

27. **M. Naor and B. Pinkas.**
    - **Title:** Oblivious transfer and polynomial evaluation.
    - **Publication:** Proceedings of the annual ACM Symposium on Theory of Computing (STOC), 1999.

28. **M. Naor and B. Pinkas.**
    - **Title:** Efficient oblivious transfer protocols.
    - **Publication:** Proceedings of the annual ACM-SIAM Symposium on Discrete algorithms (SODA), 2001.

29. **B. Pinkas, T. Schneider, N. P. Smart, and S. C. Williams.**
    - **Title:** Secure Two-Party Computation is Practical.
    - **Publication:** ASIACRYPT, 2009.

30. **a. shelat and C.-H. Shen.**
    - **Title:** Two-output secure computation with malicious adversaries.
    - **Publication:** Proceedings of EUROCRYPT, 2011.

31. **a. shelat and C.-H. Shen.**
    - **Title:** Fast two-party secure computation with minimal assumptions.
    - **Publication:** Conference on Computer and Communications Security (CCS), 2013.

32. **A. C. Yao.**
    - **Title:** Protocols for secure computations.
    - **Publication:** Proceedings of the IEEE Symposium on Foundations of Computer Science (FOCS), 1982.

33. **Y. Zhang, A. Steele, and M. Blanton.**
    - **Title:** PICCO: A General-purpose Compiler for Private Distributed Computation.
    - **Publication:** Proceedings of the ACM Conference on Computer Communications Security (CCS), 2013.

### Appendix

#### A. CMTB Protocol

We build upon the CMTB garbled circuit execution system. Here is an abbreviated version of the protocol, involving the generator, the cloud, and the evaluator. The cloud is the party to which the evaluator outsources her computation.

1. **Circuit Generation and Check:**
   - The template for the garbled circuit is augmented to add one-time XOR pads on the output bits and split the evaluator’s input wires per the input encoding scheme.
   - The generator generates the necessary garbled circuits, commits to them, and sends the commitments to the evaluator.
   - The generator then commits to input labels for the evaluator’s inputs.
   - CMTB relies on Goyal et al.’s [14] random seed check, implemented by Kreuter et al. [27], to combat incorrect circuit generation. This technique uses a cut-and-choose style protocol to verify the correctness of the circuits.

2. **Evaluator’s Inputs:**
   - Instead of a two-party oblivious transfer, we perform a three-party outsourced oblivious transfer.
   - The generator offers wire labels, the evaluator provides select bits, and the cloud receives the selected labels.
   - CMTB uses the Ishai OT extension [20] to reduce the number of OTs.
   - CMTB employs an encoding technique from Lindell and Pinkas [29] to prevent the generator from learning any information about the evaluator’s input in case of a selective failure attack.
   - The commitment technique of Kreuter et al. [27] is used to prevent the generator from swapping the two possible outputs of the oblivious transfer.
   - To ensure consistent inputs across all circuits, CMTB uses a technique from Lindell and Pinkas [29].

3. **Generator’s Input and Consistency Check:**
   - The generator sends his input to the cloud for the evaluation circuits.
   - The generator, evaluator, and cloud work together to prove the input consistency of the generator’s input.
   - For the generator’s input consistency check, CMTB uses the malleable-claw free construction from shelat and Shen [37].

4. **Circuit Evaluations:**
   - The cloud evaluates the garbled circuits marked for evaluation and checks the circuits marked for checking.
   - The cloud enters the generator and evaluator’s inputs into each garbled circuit and evaluates each circuit.
   - The output for any particular bit is determined by the majority output between all evaluator circuits.
   - The cloud recreates each check circuit, creates hashes of each garbled circuit, and sends those hashes to the evaluator.
   - The evaluator verifies the hashes match the ones the generator previously committed to.

5. **Output Consistency Check and Output:**
   - The three parties jointly prove that the cloud did not modify the output before sending it to the generator or evaluator.
   - Both the evaluator and generator receive their respective outputs, blinded by one-time pads inside the garbled circuit to prevent the cloud from learning what any output bit represents.
   - CMTB uses the XOR one-time pad technique from Kiraz [24] to prevent the evaluator from learning the generator’s real output.
   - To prevent output modification, CMTB uses the witness-indistinguishable zero-knowledge proof from Kreuter et al. [27].

#### B. Overhead of Reusing Values

We created several versions of the keyed database program to determine the runtime of saving and loading the database on a per-bit basis using our system (See Figure 7). This figure shows that it is possible to save and load a large amount of saved wire labels in a relatively short time. The time to load a wire label is larger than the time to save a value because saving only involves saving the wire label to a file, while loading involves reading from a file and creating the partial input gates. Although not shown in the figure, the time to save or load a single bit also increases with the circuit parameter, as S copies of that bit are needed for every circuit.

#### C. Example Program

In this section, we describe the execution of an attendance application. Imagine a building where the host wants each user to sign in from their phones to keep a log of guests, while keeping this information secret.

This application has three distinct programs:
1. **Initialization Program:**
   - Initializes a counter to a number input by the evaluator.
   - Cut-and-choose OT is executed to select the circuit split.
   - Both parties save the decryption keys, and the evaluator performs the OOT to input the initial value.
   - There is no input by the generator, so the generator’s input check is skipped.
   - The garbled circuit sets the initial value, and the cloud saves the garbled wire value, while the generator saves both possible wire values.

2. **Increment Program:**
   - Takes in a name and increments the counter by one.
   - The cut-and-choose OT is not executed; instead, the generator and cloud load the saved decryption key values, hash them, and use these values for the check and evaluation circuit information.
   - The new keys are saved, and the evaluator performs the OOT for input.
   - The generator loads both possible wire values and creates the partial input gates.
   - The cloud loads the attained values, receives the partial input gates from the generator, and executes the partial input gates to receive the garbled input values.
   - The garbled circuit is executed, and partial output is saved.

3. **Final Program:**
   - Outputs all names and returns the count of users.
   - The host runs this program to output the count and the guests in the database.

**Example Execution:**
- **Initial State:**
  - Count: 0
  - Saved Guests: None

- **Guest 1 Enters:**
  - Guest 1 runs the increment program, entering their name.
  - Count: 1
  - Saved Guests: Guest 1

- **Guest 2 Enters:**
  - Guest 2 runs the increment program, entering their name.
  - Count: 2
  - Saved Guests: Guest 1, Guest 2

- **Guest 3 Enters:**
  - Guest 3 runs the increment program, entering their name.
  - Count: 3
  - Saved Guests: Guest 1, Guest 2, Guest 3

- **Host Runs Final Program:**
  - Outputs the count (3) and the guests (Guest 1, Guest 2, Guest 3).

This example demonstrates how the application can securely log guest entries while maintaining privacy.