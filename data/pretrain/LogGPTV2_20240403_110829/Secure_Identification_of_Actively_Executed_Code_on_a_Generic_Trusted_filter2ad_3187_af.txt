o
y
K
l
(
|
E
|
-
|
C
|
 2000
 1800
 1600
 1400
 1200
 1000
 800
 600
 400
 200
 0
multi-PAL SQLite DB
Efficiency Condition is false
empirical check
 2
 4
 6
 8
 10
PALs in Execution Flow
 12
trend
 14
 16
Fig. 11: Validation of the performance model. The slope of trend line
represents the t1/k constant in the efﬁciency condition. |C| is the size of
the code base. |E| is the size of the code in an execution ﬂow.
multiple PALs. Instead, a negative efﬁciency ratio indicates
that it is better to protect the whole code base. The (positive)
efﬁciency condition can be deﬁned as follows. First, given the
linearity of the code isolation and identiﬁcation costs, we group
them as tid(C) + tis(C) = k|C|, for some constant k. Then:
k|C| + t1
k|E| + nt1
> 1 → |C| − |E|
n − 1
>
t1
k
eff iciency
condition
The efﬁciency ratio depends on both the size of the code
base and the size of the execution ﬂow. However, the efﬁciency
condition depends only on their difference (in addition to n and
t1/k, the architecture-speciﬁc constant discussed later).
We validate the model through an experiment that uses
different sets of PALs with cardinality from 2 to 16. For each
set we varied the aggregated size |E| (i.e., the size of executed
code). We empirically measured the maximum aggregated
size for each set for which the fvTE protocol is faster than
the traditional monolithic approach. This corresponds to the
empirical check in Fig. 11. Notice that the trend of these
empirical measurements is well approximated by a straight line
which divides the plane in two areas: the shaded one where
the efﬁciency condition is false, and the other area where it is
true. The slope of the line represents the constant t1/k.
Discussion. The constant t1/k depends strongly on the TCC.
In our experiments, it depends on our testbed hardware plat-
form and the software (XMHF/TrustVisor, see Section V-A)
that provides trusted computing services. In Flicker [33] both
terms are larger due to the interaction with the slow TPM,
particularly k for the identiﬁcation. Instead, future trusted
computing technologies such as Intel SGX [25] are expected to
reduce signiﬁcantly both t1 and k. However, since the constant
also depends on the software that supports trusted executions,
it is difﬁcult to predict its trend without running experiments
on a real platform.
VII. RELATED WORK
Code identity and trusted executions. Code identity has
been originally deﬁned as the digest of a program’s code
in [30]. The same deﬁnition was later borrowed for trusted
hardware-based code executions [17, 18] as a useful mecha-
nism for sealed storage and attestation purposes. Current plat-
forms and CPU extensions such as AEGIS[41], Intel TXT [24],
Intel SGX [25], OASIS [36], TrustLite [28] allow to identify
some code before the execution by hashing its content. Tools
that leverage some of these architectures, such as Flicker [33],
TrustVisor [32], Haven [10] do not address the problem of code
size inside the trusted environment and execute monolithic
applications, whose identity can be veriﬁed remotely. In this
paper, we do not change the deﬁnition of code identity (i.e.,
429
the hash of the binary), and we observe that another way for
the client to verify a remote execution is to (be able to) make
trust inferences. Therefore, by building a robust chain of trust
throughout the modules of a large code base, it is sufﬁcient
for the client to verify only part of the chain to infer that the
execution of the whole code base was performed correctly.
OASIS [36] proposes to deal with an application whose
size is greater than the cache by building a Merkle tree over its
code blocks. However, it requires new hardware support, so it
does not provide general solution that retroﬁts existing trusted
computing components. Our protocol instead could leverage
OASIS by implementing our TCC abstraction (Section III) and,
with minimal modiﬁcations, it could also include our novel
secure storage construction (Section IV-D).
The BIND service [38] leverages ﬁne-grained code at-
testation to secure a distributed system. BIND targets small
pieces of code, while our protocol is able to provide exe-
cution integrity guarantees of large code bases. Additionally,
although small modules could use BIND to build a chain
by verifying each other, the resulting construction (similar
to that in Section IV-A) would not be veriﬁcation efﬁcient
and could incur veriﬁcation loop issues (Section IV-C). Our
protocol addresses these drawbacks and guarantees integrity
when the client eventually veriﬁes the execution. Finally,
BIND’s security kernel was not implemented [33].
A research work related to ours is the On-board Cre-
dential (ObC) Project [16, 29, 12]. The ObC Project deﬁnes
an open architecture based on secure hardware [43, 44] for
the installation and execution of credential mechanisms on
constrained ObC-ready (typically mobile) devices. It enables a
service provider to provision secrets to a family of (installed)
credential programs [29], which are executed slice-wise in a
secure environment [16], possibly using the TPM’s late launch
mechanism [12]. Such credential programs are application
or platform-speciﬁc, while our work is concerned about the
efﬁcient veriﬁcation of executions that are performed on a
generic trusted component. The chain of trust among the slices
is based on the slice endorsement token, containing the family
and program-speciﬁc secrets, which is created online on a per-
slice basis. In our case, the chain is explicit in each PAL
through a reference to the previous/next PAL’s identity, and
only needs an ofﬂine setup (i.e., the process of making the
code base available on the UTP) performed by the service
authors. Also, access to secured data is controlled by (our)
construction through the trusted component, allowing secure
data exchange among PALs pairwise.
Deﬁning code modules. Making modules/partitions out of
programs is a programming-language problem that has been
widely studied, e.g., in the context of privilege separation
[27], parallel program execution [19, 48] and secure distributed
computation [49]. Deﬁning such a method for PALs is orthogo-
nal to and out of the scope of this paper. We mention however
that we built our SQLite-based prototype (Section V-C) by
using both static and dynamic program analysis to distinguish
the non-active code and remove it, and performing extensive
testing to check the correctness of the resulting active code.
As an additional example, in another application for secure
image ﬁltering, we implemented and protected each ﬁlter as
a separate task, and then created a secure and efﬁciently
veriﬁable chain using our protocol, though a different TCC.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:56 UTC from IEEE Xplore.  Restrictions apply. 
VIII. CONCLUSIONS
In this paper we have shown that current trends in Trusted
Computing create a trade-off between security and efﬁciency
due to code identity assignment. We presented a general
protocol that enables efﬁciently veriﬁable (at the client) and
ﬂexible (at the UTP) trusted executions of arbitrarily sized
code bases by identifying only the actively executed code.
We successfully applied our protocol to a real-world database
engine, showing positive results already with a 1MB code base.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for their valuable comments.
This work was partially supported by the EC through project H2020-
643964 (SUPERCLOUD), by national funds of Fundac¸˜ao para a
Ciˆencia e a Tecnologia (FCT) through project UID/CEC/00408/2013
(LaSIGE), and by the research grant SFRH/BD/51562/2011.
REFERENCES
[1] “Exploit-DB,” http://www.exploit-db.com/.
[2] “Open Sourced Vulnerability Database,” http://www.osvdb.org/.
[3] “SQLite Deployments,” http://sqlite.org/mostdeployed.html.
[4] “SQLite in Android,” http://developer.android.com/reference/ android/
database/ sqlite/ SQLiteDatabase.html.
[5] “SQLite in iCloud,” https://developer.apple.com/library/ios/ documen-
tation/ DataManagement/ Conceptual/ UsingCoreData WithiCloudPG/
UsingSQLiteStoragewithi Cloud/UsingSQLiteStoragewithiCloud.html.
[6] Amazon, “AWS CloudHSM, Secure Key Storage and Cryptographic
Operations,” http://aws.amazon.com/cloudhsm.
[7] I. Anati and S. Gueron, “Innovative technology for cpu based attestation
and sealing,” in Proceedings of the 2nd Workshop on Hardware and
Architectural Support for Security and Privacy (HASP), 2013.
[8] A. M. Azab, P. Ning, and X. Zhang, “SICE: a hardware-level strongly
isolated computing environment for x86 multi-core platforms,” in Pro-
ceedings of the 18th Conference on Computer and Communications
Security (CCS), 2011, pp. 375–388.
[9] S. Bajaj and R. Sion, “TrustedDB,” in Proceedings of the International
Conference on Management of Data (SIGMOD), 2011, pp. 205–216.
[10] A. Baumann, M. Peinado, and G. Hunt, “Shielding applications from
an untrusted cloud with Haven,” in Proceedings of the 11th USENIX
conference on Operating Systems Design and Implementation (OSDI),
oct 2014, pp. 267–283.
[11] S. Bratus, N. D’Cunha, E. Sparks, and S. W. Smith, “Trusted Computing
- Challenges and Applications,” in Proceedings of the 1st international
conference on Trusted Computing and Trust in Information Technologies
(TRUST), vol. 4968, 2008, pp. 14–32.
[12] S. Bugiel and J.-E. Ekberg, “Implementing an application-speciﬁc cre-
dential platform using late-launched mobile trusted module,” in Proceed-
ings of the 5th ACM workshop on Scalable trusted computing (STC),
2010, p. 21.
[13] B. Chen and R. Morris, “Certifying program execution with secure
processors,” in Proceedings of the 9th conference on Hot Topics in
Operating Systems (HOTOS), may 2003, p. 23.
[14] C. J. Cremers, “The Scyther Tool: Veriﬁcation, Falsiﬁcation, and Anal-
ysis of Security Protocols,” in Proceedings of the 20th international
conference on Computer Aided Veriﬁcation (CAV), vol. 5123, Berlin,
Heidelberg, jul 2008, pp. 414–418.
[15] ——, “Unbounded veriﬁcation, falsiﬁcation, and characterization of
security protocols by pattern reﬁnement,” in Proceedings of the 15th
conference on Computer and Communications Security (CCS), oct 2008,
p. 119.
[16] J.-E. Ekberg, N. Asokan, K. Kostiainen, and A. Rantala, “Scheduling
execution of credentials in constrained secure environments,” in Pro-
ceedings of the Workshop on Scalable Trusted Computing (STC), 2008.
[17] P. England, B. Lampson, J. Manferdelli, M. Peinado, and B. Willman,
“A Trusted Open Platform,” Computer, vol. 36, no. 7, pp. 55–62, 2003.
[18] P. England and M. Peinado, “Authenticated Operation of Open Com-
puting Devices,” in Proceedings of the 7th Australian Conference on
Information Security and Privacy (ACISP), jul 2002, pp. 346–361.
[19] M. Girkar and C. Polychronopoulos, “Partitioning programs for parallel
execution,” in Proceedings of the 2nd Int. Conference on Supercomputing
(ICS), 1988, pp. 216–229.
[20] D. Grawrock, Dynamics of a Trusted Platform: A Building Block
Approach.
Intel Press, apr 2009.
[21] L. Gu, X. Ding, R. H. Deng, B. Xie, and H. Mei, “Remote attestation
on program execution,” in Proceedings of the 3rd ACM workshop on
Scalable Trusted Computing (STC), 2008, pp. 11–20.
430
[22] C. Hawblitzel, J. Howell, J. R. Lorch, A. Narayan, B. Parno, D. Zhang,
and B. Zill, “Ironclad apps: end-to-end security via automated full-
system veriﬁcation,” in Proc. of the 11th USENIX conference on Operat-
ing Systems Design and Implementation (OSDI), oct 2014, pp. 165–181.
[23] O. S. Hofmann, S. Kim, A. M. Dunn, M. Z. Lee, and E. Witchel,
“InkTag,” ACM SIGPLAN Notices, vol. 48, no. 4, p. 265, apr 2013.
[24] Intel, “Intel Trusted Execution Technology,” http://www.intel.com/
content/dam/www/ public/us/en/ documents/ guides/ intel-txt-software-
development-guide.pdf.
[25] ——, “Software Guard Extensions,” https://software.intel.com/sites/
default/ﬁles/managed/48/88/329298-002.pdf.
[26] B. Kauer, “OSLO: improving the security of trusted computing,” in
Proceedings of 16th USENIX Security Symposium, aug 2007, p. 16.
[27] D. Kilpatrick, “Privman: A library for partitioning applications,” in
the USENIX Annual Technical Conference (Freenix
Proceedings of
track), 2003.
[28] P. Koeberl, S. Schulz, A.-R. Sadeghi, and V. Varadharajan, “TrustLite,”
in Proceedings of the 9th European Conference on Computer Systems
(EuroSys), 2014, pp. 1–14.
[29] K. Kostiainen, J.-E. Ekberg, N. Asokan, and A. Rantala, “On-board cre-
dentials with open provisioning,” in Proceedings of the 4th International
Symposium on Information, Computer, and Communications Security
(ASIACCS), 2009, p. 104.
[30] B. Lampson, M. Abadi, M. Burrows, and E. Wobber, “Authentication
theory and practice,” ACM Transactions on
in distributed systems:
Computer Systems (TOCS), vol. 10, no. 4, pp. 265–310, nov 1992.
[31] Y. Li, J. McCune, J. Newsome, A. Perrig, B. Baker, and W. Drewry,
“MiniBox: a two-way sandbox for x86 native code,” in Proc. of the
USENIX Annual Technical Conference (ATC), jun 2014, pp. 409–420.
[32] J. M. McCune, Y. Li, N. Qu, Z. Zhou, A. Datta, V. Gligor, and A. Perrig,
“TrustVisor: Efﬁcient TCB Reduction and Attestation.” in Proc. of the
IEEE Symposium on Security and Privacy (S&P), 2010, pp. 143–158.
[33] J. M. McCune, B. Parno, A. Perrig, M. K. Reiter, and H. Isozaki,
“Flicker: An Execution Infrastructure for TCB Minimization,” in Pro-
ceedings of the European Conference in Computer Systems (EuroSys),
vol. 42, no. 4, 2008, pp. 315–328.
[34] F. McKeen, I. Alexandrovich, A. Berenzon, C. V. Rozas, H. Shaﬁ,
V. Shanbhogue, and U. R. Savagaonkar, “Innovative instructions and
software model for isolated execution,” in Proceedings of
the 2nd
for Security and
Workshop on Hardware and Architectural Support
Privacy (HASP), 2013, pp. 1–1.
[35] Microsoft, “BitLocker,” http://windows.microsoft.com/ en-us/ windows7/
products/ features/bitlocker.
[36] E. Owusu, J. Guajardo, J. McCune, J. Newsome, A. Perrig, and A. Va-
sudevan, “OASIS,” in Proceedings of the 2013 Conference on Computer
& Communications Security (CCS), nov 2013, pp. 13–24.
[37] R. Sailer, X. Zhang, T. Jaeger, and L. van Doorn, “Design and im-
plementation of a TCG-based integrity measurement architecture,” in
Proceedings of the 13th USENIX Security Symposium, 2004, p. 16.
[38] E. Shi, A. Perrig, and L. van Doorn, “BIND: A Fine-Grained Attestation
Service for Secure Distributed Systems,” in Proceedings of the IEEE
Symposium on Security and Privacy (S&P), may 2005, pp. 154–168.
[39] S. W. Smith and S. Weingart, “Building a high-performance, pro-
grammable secure coprocessor,” Computer Networks, vol. 31, no. 9, pp.
831–860, 1999.
[40] SQLite, “http://www.sqlite.org/.”
[41] G. E. Suh, D. Clarke, B. Gassend, M. van Dijk, and S. Devadas,
“AEGIS,” in Proceedings of the 17th Annual International Conference
on Supercomputing (ICS), 2003, pp. 160–171.
[42] G. E. Suh, C. W. O’Donnell, I. Sachdev, and S. Devadas, “Design
and Implementation of the AEGIS Single-Chip Secure Processor Using
Physical Random Functions,” in Proceedings of the 32nd International
Symposium on Computer Architecture (ISCA), 2005, pp. 25–36.
[43] Trusted Computing Group, “MTM Speciﬁcation v1.0 rev. 7.02,” 2010.
[44] ——, “Mobile Trusted Module 2.0 Use Cases,” 2011.
[45] ——, “TPM Main Speciﬁcation Version 1.2, Rev. 116,” 2011.
[46] A. Vasudevan, S. Chaki, L. Jia, J. McCune, J. Newsome, and A. Datta,
“Design, Implementation and Veriﬁcation of an eXtensible and Modular
Hypervisor Framework,” in Proceedings of the IEEE Symposium on
Security and Privacy (S&P), may 2013, pp. 430–444.
[47] B. Vavala, N. Neves, and P. Steenkiste, “Securing Passive Replication
Through Veriﬁcation,” in Proceedings of the 34st IEEE Symposium on
Reliable Distributed Systems (SRDS), 2015, pp. 176–181.
[48] E. Yardimci and M. Franz, “Mostly static program partitioning of
binary executables,” ACM Transactions on Programming Languages and
Systems (TOPLAS), vol. 31, no. 5, pp. 1–46, jun 2009.
[49] S. Zdancewic, L. Zheng, N. Nystrom, and A. C. Myers, “Secure program
partitioning,” ACM Transactions on Computer Systems (TOCS), vol. 20,
no. 3, pp. 283–328, aug 2002.
[50] ZeroMQ, “http://zeromq.org/.”
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:56 UTC from IEEE Xplore.  Restrictions apply.