chain does not exceed the threshold. However, due to the
limited power of the adversary in such attacks, in fact, their
goals usually are not directly launching malicious behaviors,
while they aim to open doors for facilitating the following
ROP attacks. In that way, our scheme is likely to detect the
following ROP attacks.
D. Gadgets Within Sliding Windows
In most cases, the gadgets within the sliding windows are
not enough for an ROP attack. However, in the whole life-
cycle of a process, we can not eliminate the possibility for the
adversary to ﬁnd one sliding window where an ROP attack
is possible. For such cases, the current version of ROPecker
cannot detect them. One possible solution is to dynamically
reduce the window size to lower the possibility of ROP attacks.
Speciﬁcally, we can observe all
the sliding windows that
ever occurred during normal executions, analyze each of them
to evaluate the possibility of launching an ROP attack, and
record the highly possible ones. According to those recorded
sliding windows, ROPecker could choose a dynamic way to
temporally reduce the window size when the execution ﬂow
is running in one of them, and immediately restore the size
when the execution ﬂow moves out.
X. RELATED WORK
A. Randomization
Address Space Layout Randomization (ASLR) is proposed
to prevent ROP attack by randomizing base addresses of code
segments. Given that the adversary has to know the locations
of the gadgets to launch an ROP attack, the ASLR technique
seems to effectively prevent ROP attacks. However, it has been
shown that ASLR can be bypassed by leveraging brute-force
attacks [30] or information leakage attacks [31]. In addition,
some libraries or applications may not be ASLR-compatible,
which allows the adversary to ﬁnd useful gadgets to circumvent
ASLR mechanism.
Facing such difﬁculties, researchers proposed the binary
stirring technique [8], which imbues x86 native code with
the ability to self-randomize its instruction addresses each
time it is launched. Note that the size of the modiﬁed binary
ﬁle increases on average by 73%. The ILR [7] technique is
proposed to randomize the location of every instruction in a
program for thwarting an attacker’s ability to re-use program
functionality. The new generated ILR-programs have to be
executed on a dedicated Virtual Machine (VM). The run-time
performance overhead is relatively low, but the rule ﬁles are
quite large and their in-memory size are even worse, e.g., the
on-disk size of the rule ﬁle for the benchmark tool 481.wrf is
about 264MB, while its in-memory size reaches to 345M B.
Note that the whole database in our system is only 210M B..
B. Compiler-Based Approaches
The control ﬂow integrity [19] is a typical technique to
defend against the code reuse attack. However, the traditional
control ﬂow works in function level, which leads to the failure
of the detection of the ROP attack since its disorder of control
ﬂow is on instruction level. CFLocking [5] aims to limit/lock
the number of abnormal control ﬂow transfer by recompiling
a program. Essentially this technique can not handle the ROP
attacks that use unaligned gadgets.
The return-less kernel [4] is a compiler-based approach
that aims to remove the ret opcode from the kernel image by
placing the control data into a dedicated buffer instead of the
stack. Obviously this technique only defends against ret-based
ROP attack. Following the same idea, Shuo et al. [15] propose
a virtualization based approach, which requires the source code
and compiler to insert control-data-integrity-checking code into
function prologue and epilogue. Again, this approach can not
defend against the ROP attack that use jump/call instructions.
G-free [6] is a compiler-based approach, which aims to
1) eliminate all unaligned indirect branch instructions with
aligned sled [6] and 2) protect the aligned indirect branch in-
structions to prevent them from being misused. G-free requires
side information, i.e., the source code. Moreover, the inserted
code may introduce new gadgets, which can be potentially
used by the adversary.
C. Instrumentation-Based Approaches
[2], DROP [1]
TRUSS [32], ROPDefender
and
TaintCheck [33] use code instrumentation technique to
insert checking code into binary code to detect ROP attack.
Such approaches not only break the binary integrity, but
also suffer high performance overhead. For instance,
the
preliminary performance measurements for DROP range from
1.9X to 21X, and the performance overhead for TaintCheck is
over 20X. In addition, some of them, such as ROPDefender
and DROP only focus on ret-based ROP, rather than handling
all types of ROP attack.
To overcome the high performance overhead issue, sev-
eral new approaches are proposed. Speciﬁcally, the IPR [9]
12
technique is proposed, which aims to smash the gadgets in
place without changing the code size. However, many gadgets
can not be removed using the in-place technique. In addition,
the in-place smashing technique may not always smash a
signiﬁcant part of the executable address space [9], and it
is hard to give a deﬁnitive answer on whether the remaining
un-modiﬁable gadgets would be sufﬁcient for constructing a
meaningful ROP attack. The ROPGuard [3] and KBouncer [11]
approaches only add the checking points in the selective
critical functions (e.g., Windows APIs) by instrumenting the
binary code on-the-ﬂy. Although the infrequent invocations
of the checking algorithm lead to low performance overhead,
they inevitably miss the ROP attacks that do not use those
paths. Note that
the ROPGuard only works the non-JOP
code and KBouncer completely relies on non-fully reliable
LBR records, which could be overﬂowed or polluted during
context switches. CCFIR [10] randomly inserts all legal tar-
gets of indirect control-transfer instructions into a dedicated
Springboard board, and then instruments the binaries to limit
indirect transfers to ﬂow only to the board. CCFIR suffers
from compatibility issues due to the integrity protection of the
system shared libraries on certain platforms (e.g., Windows 7).
In addition, the compatibility issue may lead to the failure of
the ROP defence since the adversary may only use the gadgets
from such non-instrumented system libraries.
D. Others
CFIMon [34] is to detect a variety of attacks violating con-
trol ﬂow integrity by collecting and analyzing run-time traces
on-the-ﬂy. However it has high detection latency that may
cause it too late to detect an attack. MoCFI [35] is a framework
to mitigate control ﬂow attacks on smart phones. It performs
control ﬂow integrity checking on-the-ﬂy without requiring the
applications source code, and the experiment results show that
it does not induce notable overhead when applied to popular
iOS applications. Polychronakis et al. propose a method [36]
to identify ROP payloads in arbitrary data. The technique
speculatively drives the execution of code that already exists
in the address space of a targeted process according to the
scanned input data, and identiﬁes the execution of valid ROP
code at run-time. The basic idea of the payload detection
method has been adopted by our payload checking algorithm.
XI. CONCLUSIONS AND FUTURE WORK
We have presented ROPecker, a novel and universal ROP
attack detection and prevention system. We have innovated
two techniques as the main building blocks of ROPecker.
One is the gadget chain detection algorithm which detects
the chain in the past and future execution ﬂow, and the other
is the sliding window mechanism which allows the detection
algorithm to be triggered with a proper timing so as to achieve
high accuracy and efﬁciency. ROPecker does not require source
code, special compiler, or binary instrumentations. In fact, our
scheme is complementary to instrumentation- and compiler-
based approaches, as well as randomization schemes. Our
scheme provides another line to defend against ROP attacks.
We evaluated the security of ROPecker by running experiments
with real-life ROP attacks and those generated from Q. We also
evaluated its performance by running benchmark tools which
show acceptable performance loss.
Future Work. The current design and implementation of
ROPecker focus on user-space ROP attacks. In the future
work, we will extend ROPecker to defend against kernel-
space ROP attacks, because the hallmarks of ROP attacks
are still there. However, ROPecker should not be placed in
the kernel space any more, since it may be disabled by the
adversary once the kernel is compromised. An promising way
is to move ROPecker into the hypervisor space, where the
adversary cannot access. By doing so, the performance penalty
will be higher because the host-guest switch cost is higher than
the one of kernel-user context switch. The performance loss
may also be introduced by interrupts and exceptions, because
they may introduce poor temporal and spatial locality for the
kernel execution ﬂow, and thereby increase the frequency of
the detection algorithm invocation.
In the future work, we also aim to extend ROPecker to
support ARM platform. The ARM-based CPUs might not have
LBR registers or the registers with similar functionality. Thus,
the past payload detection will be removed in such environ-
ment. Fortunately, the ROPecker future payload detection still
works, unlike other schemes [11] that completely rely on LBR.
On ARM platforms, instructions are aligned to 16 bits or
32 bits. This will simplify the disassembler and the gadget
analysis of the ROPecker pre-processor. The minor change is
that the optional alignment checking does not work on ARM-
based platform.
ACKNOWLEDGMENTS
The authors would like to thank the anonymous reviewers
and our shepherd Davide Balzarotti for their numerous, insight-
ful comments that greatly helped improve the presentation of
this paper. The authors are also grateful to Virgil D. Gligor
and Edward J. Schwartz for useful discussions. This research
is supported by the Singapore National Research Foundation
under its International Research Centre Singapore Funding
Initiative and administered by the IDM Programme Ofﬁce,
Media Development Authority (MDA).
REFERENCES
[1] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and L. Xie, “DROP: De-
tecting Return-Oriented Programming Malicious Code,” in Proceedings
of the 5th International Conference on Information Systems Security,
2009.
[2] L. Davi, A.-R. Sadeghi, and M. Winandy, “ROPdefender: A Detection
Tool
to Defend Against Return-oriented Programming Attacks,” in
Proceedings of the 6th ACM Symposium on Information, Computer and
Communications Security, 2011.
[3] F. Ivan, “Runtime prevention of return-oriented programming attacks,”
https://code.google.com/p/ropguard/.
J. Li, Z. Wang, X. Jiang, M. Grace, and S. Bahram, “Defeating Return-
oriented Rootkits with ”Return-Less” Kernels,” in Proceedings of the
5th European Conference on Computer Systems, 2010.
[4]
[5] T. Bletsch, X. Jiang, and V. Freeh, “Mitigating Code-reuse Attacks with
Control-ﬂow Locking,” in Proceedings of the 27th Annual Computer
Security Applications Conference, 2011.
[6] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda, “G-Free:
Defeating Return-oriented Programming Through Gadget-less Bina-
ries,” in Proceedings of the 26th Annual Computer Security Applications
Conference, 2010.
J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W. Davidson,
“ILR: Where’D My Gadgets Go?” in Proceedings of the 33rd IEEE
Symposium on Security and Privacy, 2012.
[7]
13
[8] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin, “Binary Stirring:
Self-randomizing Instruction Addresses of Legacy x86 Binary Code,”
in Proceedings of the 19th ACM Conference on Computer and Com-
munications Security, 2012.
[9] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Smashing the
Gadgets: Hindering Return-oriented Programming Using In-place Code
Randomization,” in Proceedings of
the 33rd IEEE Symposium on
Security and Privacy, 2012.
[10] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou, “Practical Control Flow Integrity and Ran-
domization for Binary Executables,” in Proceedings of the 34th IEEE
Symposium on Security and Privacy, 2013.
[11] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Transparent ROP
Exploit Mitigation Using Indirect Branch Tracing,” in Proceedings of
the 22nd USENIX Conference on Security, 2013.
[12] H. Shacham, “The Geometry of Innocent Flesh on the Bone: Return-
into-libc Without Function Calls (on the x86),” in Proceedings of the
14th ACM Conference on Computer and Communications Security,
2007.
[13] E. Buchanan, R. Roemer, H. Shacham, and S. Savage, “When Good
Instructions Go Bad: Generalizing Return-oriented Programming to
RISC,” in Proceedings of the 15th ACM Conference on Computer and
Communications Security, 2008.
[14] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham,
and M. Winandy, “Return-oriented Programming Without Returns,” in
Proceedings of the 17th ACM Conference on Computer and Communi-
cations Security, 2010.
[15] T. Shuo, H. Yeping, and D. Baozeng, “Prevent Kernel Return-oriented
Programming Attacks Using Hardware Virtualization,” in Proceedings
of the 8th International Conference on Information Security Practice
and Experience, 2012.
[16] R. Sailer, X. Zhang, T. Jaeger, and L. van Doorn, “Design and
Implementation of a TCG-based Integrity Measurement Architecture,”
in Proceedings of the 13th Conference on USENIX Security Symposium,
2004.
[17] E. J. Schwartz, T. Avgerinos, and D. Brumley, “Q: Exploit Hardening
the 20th USENIX Conference on
Made Easy,” in Proceedings of
Security, 2011.
[18] M. Tran, M. Etheridge, T. Bletsch, X. Jiang, V. Freeh, and P. Ning,
“On the Expressiveness of Return-into-libc Attacks,” in Proceedings
of the 14th International Conference on Recent Advances in Intrusion
Detection, 2011.
[19] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-ﬂow
Integrity,” in Proceedings of the 12th ACM conference on Computer
and communications security, 2005.
[20] B. Daniel P. and C. Marco, “Understanding the Linux Kernel, Third
Edition, chapter 2 - hardware cache and chapter 9 - demand paging,”
2005.
[21] G.
Dabah,
“A
lightweight,
Disassembler/Decomposer
http://ragestorm.net/distorm/.
Library
Easy-to-Use
for
and
Fast
x86/AMD64,”
[22] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna, “Static Disassembly
of Obfuscated Binaries,” in Proceedings of the 13th Conference on
USENIX Security Symposium, 2004.
[23] P. Barham, B. Dragovic, K. Fraser, S. Hand, T. Harris, A. Ho, R. Neuge-
bauer, I. Pratt, and A. Warﬁeld, “Xen and the Art of Virtualization,”
in Proceedings of the 19th ACM Symposium on Operating Systems
Principles, 2003.
“Standard Performance Evaluation Corporation, SPEC CPU2006
Benchmarks,” http://www.spec.org/osg/cpu2006.
[24]
[25] C. Russell,
“Disk Performance Benchmark Tool
- Bonnie,”
[26]
http://www.coker.com.au/bonnie++/.
“The Apache
http://httpd.apache.org/.
Software
Foundation, Apache HTTP
Server,”
[27] Longld, “Payload Already Inside: Data Resue For ROP Exploits,”
https://media.blackhat.com/bh-us-10/whitepapers/Le/BlackHat-USA-
2010-Le-Paper-Payload-already-inside-data-reuse-for-ROP-exploits-
wp.pdf, 2010.
“HT Editor 2.0.20 Buffer Overﬂow (ROP PoC),” http://www.exploit-
db.com/exploits/22683/.
[28]
[29] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko, C. Liebchen, and A.-
R. Sadeghi, “Just-In-Time Code Reuse: On the Effectiveness of Fine-
Grained Address Space Layout Randomization,” in Proceedings of the
34th IEEE Symposium on Security and Privacy, 2013.
[30] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D. Boneh,
“On the Effectiveness of Address-space Randomization,” in Proceed-
ings of the 11th ACM Conference on Computer and Communications
Security, 2004.
[31] A. Sotirov and M. Dowd, “Bypassing Browser Memory Protections,”
Blackhat USA 2008.
[32] S. Saravanan, Z. Qin, and W. Weng-Fai, “Transparent Runtime Shadow
Stack: Protection Against Malicious Return Address Modiﬁcations,”
2008.
J. Newsome and D. Song, “Dynamic taint analysis for automatic
detection, analysis, and signature generation of exploits on commodity
software,” 2005.
[33]
[34] Y. Xia, Y. Liu, H. Chen, and B. Zang, “CFIMon: Detecting Violation of
Control Flow Integrity Using Performance Counters,” in Proceedings of
the 42nd Annual IEEE/IFIP International Conference on Dependable
Systems and Networks, 2012.
[35] L. Davi, A. Dmitrienko, M. Egele, T. Fischer, T. Holz, R. Hund,
S. N¨urnberger, and A.-R. Sadeghi, “MoCFI: A Framework to Mitigate
Control-ﬂow Attacks on Smartphones,” in 19th Annual Network &
Distributed System Security Symposium, 2012.
[36] M. Polychronakis and A. D. Keromytis, “ROP Payload Detection Using
Speculative Code Execution,” in Proceedings of the 6th International
Conference on Malicious and Unwanted Software, 2011.
14