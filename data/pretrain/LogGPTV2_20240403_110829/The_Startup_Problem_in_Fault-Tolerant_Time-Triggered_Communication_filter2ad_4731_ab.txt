the identiﬁer of its sender. Hence, the node listens to the
communication channels and has to identify, based on the
messages received, if there is a sufﬁcient number of nodes
communicating synchronously. If such a set exists, the node
integrates into this set and becomes synchronized. If such
a sufﬁcient set does not exist, the node enters the coldstart
phase.
In the coldstart phase, the node waits for coldstart sig-
nals, that are used to indicate a particular position in the
TDMA round schedule. A node that receives a coldstart
signal will set its local state to this position and reply in its
assigned slot. If a node does not receive a coldstart signal
for a speciﬁed timeout, it sends such a signal (only a subset
of nodes may be conﬁgured to send a coldstart signal). The
nodes are able to acquire the number of nodes that react to
the coldstart signal by counting the replies. The coldstart
phase ends when a sufﬁcient set of nodes has been synchro-
nized. In general it may also happen that only a subset of
nodes in coldstart will reach synchronous operation. For
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:30:08 UTC from IEEE Xplore.  Restrictions apply. 
this reason each startup algorithm should deﬁne conditions
for a re-transition to the integration phase, such that nodes
that did not reach the sync phase are able to integrate to the
established synchronous communication.
In the sync phase the node has reached synchronous op-
eration (but not necessarily steady state). If synchronization
is lost, the nodes restart the startup process with the integra-
tion phase.
The transitions between the different phases of the
startup strategy can be taken either by the expiration of
timeouts or by the reception of a sufﬁciently long sequence
of messages per TDMA round. It is highly important that
a faulty node or channel cannot be able to spread such a
sequence of messages (e.g. by masquerading a number of
different nodes) that will cause a non-faulty node to take an
incorrect transition between startup phases.
4.1 Integration
During sync phase each node sends a message which car-
ries its sender’s identiﬁer in its a priori assigned sending
slot. Integration is, hence, a straightforward task: when a
node receives a sufﬁciently long sequence of messages dur-
ing one TDMA round, the node knows that synchronous
communication exists, and, furthermore, is able to adjust its
local state to the state contained in the received messages.
The necessary length of the sequence has to be longer than
the sequence of messages that a faulty node can insert into
the distributed algorithm execution.
Insert means in this
context that a message from a faulty node is relayed by the
communication medium. Guardians are able to block faulty
messages, which means that not each message generated by
a faulty node will be inserted into the distributed algorithm
execution.
As deﬁned in our system model, only one slot per TDMA
round is assigned to each node and the round layout is equal
for each round. Given a guardian that guarantees that a node
will only send in its sending slot during synchronous oper-
ation, it is guaranteed that a faulty node can insert only one
faulty message per TDMA round per channel. The number
of messages that an integrating node needs to receive de-
pends on the ﬁltering techniques used in the guardian. An
integrating node needs:
• 1-out-of-2 messages (that is a sequence of 1 message),
if the faulty message is detectably faulty (as the non-
faulty message can be identiﬁed), or
• 2-out-of-3 messages (that is a sequence of 2 messages),
if the faulty message is not detectably faulty (a major-
ity vote has to be done, to identify the non-faulty mes-
sage).
There is an interdependency between the slot to node re-
lation, the required ﬁltering techniques in the guardian, and
the required number of messages necessary for integration:
if the system model is generalized with respect to the rela-
tion of slots to nodes such that a node is allowed to acquire
more than one slot per round, a faulty node can simulate a
number of nodes which is equal to the maximum number of
slots in which it is allowed to send. If we do not use fur-
ther ﬁltering techniques we have to implement a majority
voting: a node has to receive (k + 1)-out-of-(2k + 1) cor-
responding messages, where k is the maximum number of
slots assigned to a node in a TDMA round. However, that
does not mean that we require (k +1) distinct nodes, as also
correct nodes can be assigned more than one slot per round.
The integration phase can terminate “successfully” or
“unsuccessfully”: when the node has received a sufﬁciently
long sequence of messages it is able to synchronize to a run-
ning system and the integration terminates successfully. If
the node is not able to integrate for a given duration, the
node terminates the integration phase unsuccessfully and
transits to the coldstart phase.
4.2 Coldstart
In the coldstart phase a node a) waits for coldstart signals
and b) sends coldstart signals by itself. The system can be
conﬁgured such that only a dedicated set of nodes, the “core
system” is allowed to enter coldstart phase. Nodes that are
not in the core system will enter sync phase only by integra-
tion. Coldstart signals are starting signals for the nodes to
start synchronized communication. There are several ways
to construct such a coldstart signal:
Noise:
any kind of activity that can be detected by nodes.
This form of coldstart signal highly depends on the physical
layer used for the realization of the channels.
Semantic-Free Coldstart Message:
a valid unique mes-
sage that is sent as coldstart signal. The reception of the
message alone is evaluated as coldstart signal.
Semantic-Full Coldstart Message:
a valid unique mes-
sage that is sent as coldstart signal. This coldstart signal
carries additional information, for example where to start in
the communication schedule.
In a fault-tolerant system it is necessary to conﬁgure
more than one node to send a coldstart signal and, hence,
there is always the possibility that these nodes send their
coldstart signals at approximately the same point in time
causing a contention. According to our system model the
communication channels are half-duplex and, hence, con-
tentions cannot be detected immediately by the senders.
Furthermore, propagation delays on the communication
channels and deaf windows in the nodes (that are phases
when a node switches from receiving to transmitting) make
it impossible that a node receives the coldstart signal from
another node instantaneously. If the contention is not re-
solved, the quality of the initial synchronization depends on
these parameters (propagation delay and deaf window). A
contention-resolving algorithm can be used to ensure that
eventually there is only one node that sends a coldstart sig-
nal that will not result in a contention. A contention sce-
nario with two nodes is depicted in Figure 2.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:30:08 UTC from IEEE Xplore.  Restrictions apply. 
Listen
Pre-Send
Transmit
Listen
Pre-Send
Transmit
pd
contention
Figure 2. Initial precision after a contention
During the listen periods, the nodes try to receive cold-
start signals. At some point in time the nodes decide that
they have to initiate the coldstart themselves. During the
following pre-send period the nodes are not able to receive
messages from the communication channels. Finally, the
nodes broadcast their messages. We see that the quality of
the initial precision, Πcontention , depends on the maximum
propagation delay, δpd, (the propagation delay is assumed
also to cover digitalization errors at the receiver) and the
duration of the pre-send period, ∆pre−send .
Πcontention = δpd + ∆pre−send
(1)
We can distinguish two types of contentions depending
on the topology of the communication medium.
Physical Contentions occur, when two or more nodes
send at approximately the same time and the signals of these
nodes physically overlay on the medium. This type of con-
tention may occur in a bus topology.
Logical Contentions
are a result of the replication of
the shared medium where the replicas are controlled by
mutually independent instances, e.g.
central guardians.
Each of these instances guarantees a transmission free of
physical contentions on one replica. However, since these
instances are independent of each other, nodes that start
to broadcast at approximately the same time may occupy
only a subset of the replicas each. A receiver, therefore,
will receive messages from different senders on the replicas
of the communication medium. Logical contentions may
occur in a star conﬁguration of a system.
This paper focuses on the star topology and therefore on
logical contentions.
A deterministic contention resolving algorithm, guaran-
tees that there exists an upper bound in time, when the ac-
cess of at least one node will not result in a contention:
Property 3 If several nodes have produced a contention at
their n-th access to the shared medium, there exists an x
such that the (n + x)-th access of at least one node in this
set will not result in a contention.
This property is essential for the coldstart phase since it
guarantees that even if there are more nodes sending their
coldstart signal at approximately the same point in time,
there exists an upper bound in time when one node will send
its coldstart signal without a contention.
The contention problem naturally arises in communica-
tion networks based on a shared communication medium
and, hence, communication protocols have to provide solu-
tions for this problem. A summary of contention resolv-
ing algorithms of well-established communication proto-
cols (such as Avionics Full-Duplex Ethernet, Token Bus,
etc.) can be found in [14, p.35 ff.]. Such protocols usually
use priority-based algorithms where the priorities are real-
ized as different unique timeouts; e.g. a re-try timeout – if
a contention occurs the one node with the shortest timeout
will be the ﬁrst to re-transmit its message.
The coldstart will terminate “successfully”, if the node
ﬁnds a sufﬁcient number of nodes/channels synchronized.
The node then transits to the sync phase. The coldstart ter-
minates “unsuccessfully” if the number of nodes/channels
is not sufﬁcient. When the coldstart phase terminates un-
successfully another coldstart phase may be started imme-
diately or the integration phase may be re-started, which
allows the node to check wether a different set of nodes
reached sync phase already. Determining, whether a set of
nodes/channels is sufﬁcient, or not, is done at design time
and can be bound to the following numbers:
1. the numbers of nodes/channels necessary to guarantee
the correct operation of the application, or
2. the numbers of nodes/channels necessary to allow an
unsynchronized node to integrate into a synchronized
system (this is the approach used within this paper).
5 Assessment of the LTTP and the FlexRay
Startup Algorithms
This section discusses the startup algorithms of LTTP
(Layered TTP) and FlexRay. Both algorithms have been
analyzed using the SAL model checker developed by SRI
International. Due to space limitations we only outline the
algorithms, detailed descriptions can be found in Steiner’s
PhD thesis [14] and the FlexRay speciﬁcation [4].
5.1 LTTP
Layered TTP is a research derivative of TTP/C. Its prime
purpose is the layering of TTP/C services such that it can
be easily tailored to a customer’s needs. With respect to
startup LTTP tries on the one hand to minimize the required
guardian functionality by using mechanisms like majority
voting and on the other hand to decouple the guardian func-
tionality from the protocol to enhance diversity and mini-
mize the possibility of common mode failures.
5.1.1 Algorithm Overview
The startup algorithm of LTTP was developed with respect
to the general startup strategy discussed in Section 4 and
with heavy support of model-checking experiments. It is
fully compliant to the system model discussed in Section 2.
The algorithm uses the following message types:
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:30:08 UTC from IEEE Xplore.  Restrictions apply. 
cs-frames:
cs-frames are the starting signals in the sys-
tem and have length dcs. cs-frames only carry the binary
information that they are cs-frames (semantic-less coldstart
messages). A successful cs-frame will signal the start of a
TDMA round.
ack-frames:
acknowledgment frames are used to ac-
knowledge a received cs-frame. ack-frames have length
dack , where dcs = dack . ack-frames carry the current slot
position in the TDMA schedule.
i-frames:
i-frames are the regular frames transmitted
when a set of nodes is synchronized. i-frames have a min-
imum length of di, where dack < di.
i-frames carry the
current slot position in the TDMA schedule.
cu-frames:
cu-frames (cleanup-frames) are used for the
speedup of the startup algorithm. cu-frames have length
dcu, where dack < dcu < di.
The startup algorithm is represented by the state machine
in Figure 3.
Integrate
Coldstart
Init
(1)
I-frame
Detection
(2)
Contention
Resolving
(5)
Sync
(9)
Passive
Tentative
(7)
(2)
Active
Tentative
(6)
Relax
(4)
Con-
firmation
(3)
Cleanup