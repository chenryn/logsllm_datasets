Cui, and Amy Wang. UPA: An Automated, Accurate and Efficient Differen-
tially Private Big-data Mining System. In To appear at the 50th Annual IEEE/IFIP
International Conference on Dependable Systems and Networks (DSN ’20). IEEE.
[50] Yanlin Li, Jonathan M McCune, James Newsome, Adrian Perrig, Brandon Baker,
and Will Drewry. MiniBox: A Two-Way Sandbox for x86 Native Code.. In USENIX
Annual Technical Conference. 409–420.
[51] Joshua Lind, Christian Priebe, Divya Muthukumaran, Dan O’Keeffe, Pierre-Louis
Aublin, Florian Kelbert, Tobias Reiher, David Goltzsche, David Eyers, Rüdiger
Kapitza, et al. Glamdring: Automatic application partitioning for Intel SGX. In
2017 USENIX Annual Technical Conference (USENIX ATC 17), Santa Clara, CA.
[52] Nuno P Lopes, David Menendez, Santosh Nagarakatte, and John Regehr. Provably
correct peephole optimizations with alive. ACM SIGPLAN Notices 50, 6 (2015),
22–32.
[53] Sinisa Matetic, Mansoor Ahmed, Kari Kostiainen, Aritra Dhar, David Sommer,
Arthur Gervais, Ari Juels, and Srdjan Capkun. ROTE: Rollback Protection for
Trusted Execution. IACR Cryptology ePrint Archive 2017 (2017), 48.
[54] Saeid Mofrad, Ishtiaq Ahmed, Shiyong Lu, Ping Yang, Heming Cui, and Feng-
wei Zhang. SecDATAVIEW: a secure big data workflow management system
for heterogeneous computing environments. In Proceedings of The 35th Annual
Computer Security Applications Conference (ACSAC’19).
[55] Khanh Nguyen, Lu Fang, Guoqing Xu, Brian Demsky, Shan Lu, Sanazsadat
Alamian, and Onur Mutlu. Yak: A high-performance big-data-friendly garbage
collector. In 12th USENIX Symposium on Operating Systems Design and Implemen-
tation (OSDI 16). 349–365.
[56] Christian Priebe, Kapil Vaswani, and Manuel Costa. EnclaveDB: A Secure Data-
base using SGX. In Proceedings of the 2018 IEEE Symposium on Security and Privacy.
IEEE, 0.
[57] Konstantin Rubinov, Lucia Rosculete, Tulika Mitra, and Abhik Roychoudhury. Au-
tomated partitioning of android applications for trusted execution environments.
In ICSE. IEEE, 923–934.
[58] Nuno Santos, Himanshu Raj, Stefan Saroiu, and Alec Wolman. Using ARM
TrustZone to build a trusted language runtime for mobile applications. ACM
SIGARCH Computer Architecture News 42, 1 (2014), 67–80.
[59] Felix Schuster, Manuel Costa, Cédric Fournet, Christos Gkantsidis, Marcus
Peinado, Gloria Mainar-Ruiz, and Mark Russinovich. VC3: Trustworthy data ana-
lytics in the cloud using SGX. In Security and Privacy (SP), 2015 IEEE Symposium
on. IEEE, 38–54.
[60] Fahad Shaon, Murat Kantarcioglu, Zhiqiang Lin, and Latifur Khan.
SGX-
BigMatrix: A Practical Encrypted Data Analytic Framework With Trusted Proces-
sors. In Proceedings of the 17th ACM conference on Computer and communications
security (CCS ’10).
[61] Ming-Wei Shih, Mohan Kumar, Taesoo Kim, and Ada Gavrilovska. S-NFV: Se-
curing NFV states by using SGX. In Proceedings of the 2016 ACM International
Workshop on Security in Software Defined Networks & Network Function Virtual-
ization. ACM, 45–48.
[62] Shweta Shinde, Dat Le Tien, Shruti Tople, and Prateek Saxena. PANOPLY: Low-
TCB Linux Applications With SGX Enclaves. In Proc. of the Annual Network and
Distributed System Security Symp.(NDSS).
[63] Alexander Sotirov. Heap feng shui in javascript. Black Hat Europe 2007 (2007).
[64] Pramod Subramanyan, Rohit Sinha, Ilia Lebedev, Srinivas Devadas, and Sanjit A
Seshia. A formal foundation for secure remote execution of enclaves. In Pro-
ceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
Security. ACM, 2435–2450.
[65] Yogesh Swami. Intel SGX Remote Attestation is not sufficient. IACR (2017).
[66] Hongliang Tian, Yong Zhang, Chunxiao Xing, and Shoumeng Yan. SGXKernel:
A Library Operating System Optimized for Intel SGX. In Proceedings of the
Computing Frontiers Conference. ACM, 35–44.
[67] Chia-Che Tsai, Donald E Porter, and Mona Vij. Graphene-SGX: A practical
library OS for unmodified applications on SGX. In 2017 USENIX Annual Technical
Conference (USENIX ATC).
[68] Jo Van Bulck, David Oswald, Eduard Marin, Abdulla Aldoseri, Flavio D. Garcia,
and Frank Piessens. A Tale of Two Worlds: Assessing the Vulnerability of
Enclave Shielding Runtimes. In Proceedings of the 2019 ACM SIGSAC Conference
on Computer and Communications Security (London, United Kingdom) (CCS ’19).
Association for Computing Machinery, New York, NY, USA, 1741–1758.
[69] Jo Van Bulck, Frank Piessens, and Raoul Strackx. SGX-Step: A practical at-
tack framework for precise enclave execution control. In Proceedings of the 2nd
Workshop on System Software for Trusted Execution. ACM, 4.
[70] Huibo Wang, Erick Bauman, Vishal Karande, Zhiqiang Lin, Yueqiang Cheng,
and Yinqian Zhang. Running Language Interpreters Inside SGX: A Lightweight,
Legacy-Compatible Script Code Hardening Approach. In Proceedings of the 2019
ACM Asia Conference on Computer and Communications Security. ACM, 114–121.
[71] Huibo Wang, Pei Wang, Yu Ding, Mingshen Sun, Yiming Jing, Ran Duan, Long
Li, Yulong Zhang, Tao Wei, and Zhiqiang Lin. Towards Memory Safe Enclave
Programming with Rust-SGX. In Proceedings of the 2019 ACM SIGSAC Conference
on Computer and Communications Security (London, United Kingdom) (CCS ’19).
Association for Computing Machinery, New York, NY, USA, 2333–2350.
[72] Nico Weichbrodt, Anil Kurmus, Peter Pietzuch, and Rüdiger Kapitza. AsyncShock:
Exploiting synchronisation bugs in Intel SGX enclaves. In European Symposium
on Research in Computer Security. Springer, 440–457.
[73] Samuel Weiser, Mario Werner, Ferdinand Brasser, Maja Malenko, Stefan Mangard,
and Ahmad-Reza Sadeghi. TIMBER-V: Tag-Isolated Memory Bringing Fine-
grained Enclaves to RISC-V.
[74] Jean Yang and Chris Hawblitzel. Safe to the last instruction: automated ver-
ification of a type-safe operating system. ACM Sigplan Notices 45, 6 (2010),
99–110.
[75] Min Hong Yun and Lin Zhong. Ginseng: Keeping Secrets in Registers When You
Distrust the Operating System.. In NDSS.
[76] Matei Zaharia, Mosharaf Chowdhury, Tathagata Das, Ankur Dave, Justin Ma,
Murphy McCauley, Michael J Franklin, Scott Shenker, and Ion Stoica. Resilient dis-
tributed datasets: A fault-tolerant abstraction for in-memory cluster computing.
In NSDI. USENIX Association, 2–2.
[77] Wenting Zheng, Ankur Dave, Jethro G Beekman, Raluca Ada Popa, Joseph E
Gonzalez, and Ion Stoica. Opaque: An Oblivious and Encrypted Distributed
Analytics Platform.. In NSDI. 283–298.
9 APPENDIX
A JAVA BYTECODE SIZE
Dependent Classes Size
Package Name
LinearRegr (UDF)
Spark + Scala
Java RT
Total
1.1 KB
2.3 MB
5.0 MB
7.3 MB
Jar Size
1.1 KB
17.4 MB
65.0 MB
82.4 MB
Table 4: Enclave memory usage of Java bytecode.
B SAMPLE JIT CODE
Figure 9: Uranus’s JIT Compilation.
Figure 9 shows that verified Java bytecode sequences are compiled
into native code. aload_0 and getfield are compiled as instruc-
tion 1 and instruction 2 ∼ 7, respectively. Figure 9 shows the native
code with runtime checks (in dash box, line 3 ∼ 6).
C URANUS’S MULTI-THREADING AND
EXCEPTION HANDLING
Uranus supports multi-threading executions and in-enclave syn-
chronization. Uranus does not support thread creation within an
enclave, so Uranus is a one-to-one mapping between an enclave
thread and an external thread. Uranus re-implements Java’s lock-
ing mechanism with spinlocks, as these locks do not require going
across enclave boundary. We does not choose to block threads in
locks, as blocking requires help from OS and leaving the enclave,
which makes synchronization bugs easier to exploit [65, 69, 72]. An
EnclaveException is thrown when synchronization (e.g., lock
and wait) is invoked on non-enclave objects. Uranus’s current
multi-threading support is sufficient for our evaluation.
To handle exceptions, Uranus adopts a similar design of Hotspot’s
exception capture and dispatch mechanism. Hotspot makes use
of OS signals and dynamic checks to capture exceptions. For ex-
ample, Hotspot does not explicitly check if an object is null for
NullPointerException. Instead, it proceeds such memory ac-
cesses, which incurs segfault for a Hotspot-defined handler to
capture the faults. Uranus did not adopt this exception capturing
mechanism using OS signals for two reasons. First, SGX cannot
safely handle memory faults in enclaves. Specifically, although cur-
rent SGX hardware can handle some hardware faults (e.g., sigfpe)
by using AEX, the SGX hardware does not provide sufficient in-
formation (e.g., segfault memory address) for memory faults
within an enclave [15]. Therefore, handling memory faults can re-
lay on only the exception information provided by OS, insecure for
Uranus: an attacker outside an enclave can manipulate the excep-
tion information to tamper with the control flow of the trusted Java
code running within the enclave. Second, it may result in informa-
tion leakage, since handling OS signals requires leaving enclaves,
and attackers can infer control flows or plaintext data by observing
if there are exceptions.
Uranus supports handling memory exceptions in enclaves, in-
cluding NullPointerException, ArrayOutOf BoundException
and ArithmeticException, by using runtime checks. Some of
these checks (e.g., array bound checks) are already in JVM, and
Uranus adds only NullPointer checks and DividedByZero checks.
When an exception is captured by Uranus, Uranus searches for
a handler of the exception in the current function, and searches
in the caller if such one does not exit, recursively. When Uranus
cannot find a corresponding handler for an exception in enclaves,
Uranus throws an EnclaveException outside enclaves with ex-
ception information (e.g., exception location) encrypted. This set
of exception support is sufficient to run the trusted code of the
real-world applications in our evaluation.
D EVALUATED APPLICATION
Framework
Distributed Data Analytics:
Opaque (encryption mode)
VC3
Spark-Uranus
Privacy-preserving ZooKeeper
SecureKeeper
ZooKeeper-Uranus
LoC Modifications
4k (C++), 2.6k (Scala)
7k (C/C++)
4 annotated functions
and encryption/decryption [250 LoC]
3.4k (C), 154 (Java)
2 annotated functions
and encryption/decryption [87 LoC]
Table 5: Code modified by Uranus and code rewriting systems.
Table 5 shows the number of LoC added to Spark-Uranus and
ZooKeeper-Uranus. For Spark-Uranus, we add three wrapper
functions, annotate them with JECall, and use these functions to
call Spark UDF in ResultTask.run(), ShuffleMapTask.run()
Java Source CodeVerifiedJava BytecodeCompiled Codevoid udf_process(  /* parameters */) {  …  if(r.disease==“cancer”)   …} aload_1getfield #11 1  mov rax, [r14, 0xf]2  mov rcx, [rsp, 0x0]3  cmp rcx, [enclavestart]4  jl L15  cmp rcx, [enclaveend]6  jg L17  mov rax, [rcx + 0xf]L1: call throw_errorJavacUranus’sJITEnclaveand SortShuffleWritter of Spark. The first two wrappers call
Uranus’s loadClass API to load and verify UDF’s dependent
classes. Specifically, ResultTask and ShuffleMapTask execute
map and reduce functions, respectively; SortShuffleWritter
merges reduced data before shuffling data. To preserve the execu-
tion integrity of Spark DAG (Direct Acyclic Graph), a sequence of
UDF, we adopt the self-verification protocol in Opaque [77]. The
driver program of Spark-Uranus computes an authentication mes-
sage Auth ← Encryptk(id, DAG, P1, ..., Pp), where id is the stage
id, Pi is the partition id. A task execution function verifies Spark
DAG’s integrity by checking the authenticity of Auth. On the other
hand, the JECall-annotated functions encrypt processed results
along with the authentication message Auth. Spark-Uranus clients
verify Auth within encrypted results.
ZooKeeper-Uranus annotates two functions which process user
data: FinalRequestProcessor.processRequest() and PrepReq-
uestProcessor.pProcess(). These functions decrypt data received
from client requests and encrypt data after parsing it. ZooKeeper’s
file path names are encrypted using a deterministic encryption
approach, and payloads are encrypted with path names to prevent
attackers replacing a path’s data.
E COMPARISON OF LOC
System
Uranus
JVM on SGX-LKL [10]
Civet [16]
Component
JIT compiler
Garbage Collector
Code Verifier
Exception Handler
Native Libraries∗
Bytecode and Class∗
SGX SDK
JVM∗
SGX-LKL
SGX-MUSL
Civet’s components
Modified JVM
Graphene-SGX
GNU libc∗
LoC
14, 411
6, 600
1, 281
310
6, 837
22, 494
171, 606
913, 951
38, 870
99, 222
38, 481
422, 199
49, 689
1, 008, 773
Table 6: Comparisons of Loc between Uranus, SGX-LKL-JVM and
Civet. Components with ∗ are ported from the codebase of GNU libc
or JVM and are not modified.
Table 6 shows the comparisons of LoC between Uranus, JVM
running on SGX-LKL and Civet. For Civet, we use the LoC reported
in Civet’s paper [16]. For JVM on SGX-LKL, we measured its LoC in
its repository [10]. Overall, Uranus has much fewer LoC than the
other two systems. Moreover, most of Uranus’s LoC is from SGX
SDK, and Uranus’s codebase can be further reduced by removing
some SGX SDK’s components that are not used by Uranus.
F MORE BENCHMARKS OF URANUS’S GC
Except for the stress test of Uranus’s GC in Figure 7b, both Spark-
Uranus and ZooKeeper-Uranus take the fast path of Uranus’s
GC because their threads running enclaves conduct computation
individually and do not share objects. To analyze Uranus’s GC
Figure 10: KV-Uranus’s multi-threading scalability.
efficiency in slow path (§4.4), we used the key-value store pro-
gram in Figure 1 and the ChronicleMap [3] library to implement
KV-Uranus, a secure key-value store server that parses the plain-
text of key-value pairs only in enclaves. To reduce the time cost
of encryption and decryption for every request, we implemented
a plaintext key-value pair cache shared by all threads within the
enclave. Each key and value is 16 byte respectively, and the cache
is 10MB, including key-value pairs and metadata. Outside an en-
clave, the value and key are encrypted together to avoid attackers
replacing a key’s value with another’s. KV-Uranus takes the same
partition as SecureKeeper and ZooKeeper-Uranus, and thus has
the same security guarantees.
In Figure 10, we ran KV-Uranus with the same ZK-Smoketest [14]
benchmark and same workload as for ZooKeeper-Uranus. We
measured the median processing time on the KV-Uranus server
program (i.e., network round-trip time was excluded in order to pre-
cisely analyze Uranus GC’s effect) in three settings: KV-Uranus;
KV-Native, the native and insecure key-value server program; and
KV-Uranus with Uranus’s region-based GC mechanism disabled
(all threads share a global enclave heap). We varied the number of
threads in the key-value server program. When the same number
of threads are run on the server, KV-Uranus’s per-request process-
ing time was 10us ∼ 22us, faster than KV-Uranus-disable-region’s.
We found that the total GC time for all threads of KV-Uranus
and KV-Uranus-disable-region were 12.5s and 21.4s, respectively.
Therefore, we believe Uranus’s GC is efficient for diverse applica-
tions.
12345678Number of threads ran in ChronicleMap server75100125150175200225250Server processing Time (us)KV-NativeKV-UranusKV-Uranus-disable-region