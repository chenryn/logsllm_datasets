title:On Designing an Efficient Distributed Black-Box Fuzzing System for
Mobile Devices
author:Lee Wang Hao and
Murali Srirangam Ramanujam and
S. P. T. Krishnan
On Designing an Efﬁcient Distributed Black-Box Fuzzing
System for Mobile Devices
Wang Hao Lee
Institute for Infocomm
Research
Singapore
PI:EMAIL
Murali Srirangam
Ramanujam
Institute for Infocomm
Research
Singapore
muralism@i2r.a-
star.edu.sg
S. P. T. Krishnan
Institute for Infocomm
Research
Singapore
krishnan@i2r.a-
star.edu.sg
ABSTRACT
Security researchers who jailbreak iOS devices had crowd-
sourced for system level vulnerabilities [1] for iOS. However,
their success depended on whether a particular device owner
encountered a crash in system-level code. To conduct vol-
untary security testing, Black-box fuzzing is one of the ideal
low-cost and simple technique to ﬁnd system level vulnera-
bilities for the less technical crowd. However, it is usually
not the most eﬀective method due to the large fuzzing space.
At the same time, when fuzzing mobile devices such as to-
day’s smartphones, it is extremely time consuming to instru-
ment mobile devices of varying versions of system software
across the world.
In this paper, we describe Mobile Vul-
nerability Discovery Pipeline (MVDP), a semi-automated,
vulnerability discovery pipeline for mobile devices. MVDP
is a carefully crafted process targeted to produce malicious
output that is more likely to crash the target leading to vul-
nerability discovery. MVDP employs a few novel black-box
fuzzing techniques such as distributed fuzzing, parameter
selection, mutation position optimisation and selection of
good seed ﬁles. To date, MVDP has discovered around 1900
crashing inputs and helped to identify 7 unique vulnerabili-
ties across various Android and iOS phone models.
Categories and Subject Descriptors
D.4.6 [Security and Protection]: Invasive software—Mo-
bile Vulnerability; D.2.5 [Software Engineering]: Testing
and Debugging—Distributed Debugging
Keywords
Black-Box Fuzzing, Zero-Day Vulnerability, Crash Analysis,
Smart-phones
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ASIA CCS’15, April 14–17, 2015, Singapore.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3245-3/15/04 ...$15.00.
http://dx.doi.org/10.1145/2714576.2714607.
1.
INTRODUCTION
The increased sophistication of mobile devices brings with
it many unknown vulnerabilities. It is critical to identify the
vulnerabilities before attackers use them for 0-day exploits.
The simplicity of black-box fuzzers allows non-security pro-
fessionals to run security experiments and gather security
related defects for the manufacturer or security researchers.
On the other hand, the space for blind fuzzing is intractable
and many duplicated fuzzed ﬁles or ﬁles with less meaning-
ful mutations are produced. Hence, it is vital to devise tech-
niques for discovering unknown vulnerabilities from a black-
box perspective that yield higher detection-rates with fewer
input tests. At a high level, three approaches to discover-
ing software vulnerabilities exist: white-box, black-box and
grey-box testing. The most suitable approach depends on
the availability of the source codes, design speciﬁcations, size
of source base and time and resources available. White box
testing makes use of a program’s source code to test the in-
ternal mechanism of the system or component. The openess
of today’s mobile Operating Systems today are mixed. Ap-
ple’s iOS is generally closed source with some open-sourced
components like XNU, WebKit, Objective-C runtime, dyld
and so on. Debugging system level binaries are diﬃcult
without a Jailbreak which in itself is an exploit. Most of
Google’s Android OS is fully open-source with the excep-
tion of device drivers and UI customization [2]. The less
popular Blackberry 10 and Windows Phone operating sys-
tems on the other hand are completely closed source. The
complexity and size of the code-base would require signiﬁ-
cant time and resources for investigation. These code bases
would also get updated before a researcher can suﬃciently
understand the system. In the context of voluntary security
testing, it would be too intrusive to instrument a volunteer’s
device. Direct instrumentation of libraries that are common
on mobile and desktop platforms on more robust desktop en-
vironments may accurately simulate the target environment,
but target devices available around the world are actual live
device targets providing the most accurate exploitation con-
text. Furthermore, not every mobile device platform have
common libraries with their desktop counterparts; for ex-
ample, Webkit on iOS vs Mac OS X.
On the other hand, grey and black-box testing approaches
require little or no knowledge of the architecture, respec-
tively. As such, a large volume of test cases are needed to
probe an unknown target. Black-box fuzzing at the extreme
end of the spectrum, requires numerous unexpected or mal-
31formed inputs to test the response of the target. Although
the basic idea may seem to lack elegance, it is highly eﬀective
in practice and simple in discovering critical bugs [3] even for
users not coming from a security background. An average
user has nearly 3 mobile devices according to a Sophos sur-
vey [4]. Shops also have unsold display-set devices switched
on during the day. To harness the availability of idle devices
and allow mainstream users to help researchers ﬁnd secu-
rity defects, we describe in this paper techniques such as
distributed fuzzing, parameter selection, mutation position
optimisation and selection of good seed ﬁles.
Audio, video and images are the most consumed media
types on smartphones and drive-by-download exploits have
been developed for these media in the past [5, 6, 7]. Hence,
for this paper, we targeted the multimedia libraries (audio,
video and images) on Android and iOS. Although only au-
dio, video and images are tested in this paper, the technique
is general and can be extended to include other data-formats
that can be sent over the internet.
1.1 Fuzzing Challenges and Motivations
Black-box fuzzing is a popular, cheap and eﬀective for
ﬁnding bugs in applications for the masses. However, a good
scalable black-box fuzzing architecture can always present
challenges that need to be addressed before it can eﬀectively
enable vulnerability discovery. Overall, we summarize sev-
eral challenges as below:
a) Selecting good starting (seed) ﬁles: The quality of
the fuzzing output depends on the quality of seed ﬁles.
This means the seed ﬁles from which the malformed
inputs are generated must be of good quality [8]. The
GIF ﬁle format, for example has several well-deﬁned
sections deﬁned in its speciﬁcation [9]. A good seed ﬁle
should have all sections and sub-types of a particular
data-format. More information about this is provided
in Subsection 2.1.
b) Virtually unlimited fuzzing space: The fuzzing
space for any ﬁle format can be exponentially large and
exploring every single possibility can be next to impos-
sible. For example, fuzz testing executed using binary
ﬁles has is that it requires a large number of fault-
inserted ﬁles to cover every test case [10]. As such,
without much knowledge of the input format, we still
need a method of generating and selecting fuzzing con-
ﬁgurations that output fuzzed ﬁles containing a uni-
formly distributed set of mutation positions covering
a diverse set of ﬁelds of the seed ﬁle.
c) Fuzzing scalability: If we were to generate test cases
on the device itself, it is likely that the same malformed
ﬁle is generated across multiple devices. This con-
tributes to wasted computing power and less coverage
of fuzzing space. There is also no means to compare
test results across devices as each device might have
performed the same or a diﬀerent test. Hence, the
fuzzed ﬁles should be generated only once and have
copies distributed to diﬀerent devices for testing. We
need a server setup to coordinate the fuzz distribution
across a great number of devices and collect and quan-
tify the results.
When multiple devices of the same model and OS
version are being fuzzed, there is a need to devise a
method of balancing the inputs. With load balanc-
ing, more tests can be processed on a device/OS plat-
form, duplicate tests can be eliminated and vulnera-
bilities can be discovered faster. This means that if
we have multiple devices running the same OS ver-
sion, the server must be able to identify them as of the
same model and and allocate diﬀerent inputs to each
one of them.
When fuzzing many devices across the world, it is es-
sential to have a new set of test input ready for the
next arriving device of the same model and OS ver-
sion. Storing fuzzed input thus require large amounts
of storage space and the growth of space utilisation
increases with the amount of devices connected to the
test server. In addition, conducting tests across the in-
ternet requires massive network transfer of these test
data much to the volunteer’s deﬁcit. Hence, we will
need a means of optimizing the content being stored
without comprimising on performance considerably.
With these challenges, it is noted that more eﬃcient black-
box fuzzing framework should be developed for discovering
unknown vulnerabilities and bugs in mobile platforms, es-
pecially on smartphones.
1.2 Contributions
In this paper, we address the challenges described above
and designed Mobile Vulnerability Discovery Pipeline (MVDP),
a scalable distributed fuzzing infrastructure for discovering
unknown vulnerabilities for smartphones.
MVDP comprises of techniques to enable internet-scale
voluntary security testing. The paper emphasizes the fol-
lowing key contributions for improvising black-box testing:
• Ensuring universal uniqueness of fuzzes. Send-
ing the same ﬁle to the same device is a wastage of
time, computing and network resources. Our paper
presents FEET (Fuzzing Engine Evaluation Tool), a
novel mechanism that ensures unique fuzzed ﬁles with
well-distributed modiﬁcation positions are prioritised.
• Ensuring uniformity of fuzz campaigns (jobs).
Fuzzing is phased as jobs. Jobs are groups of N ﬁles
analagous to a campaign in [11]. The basic idea of
an optimized job in our case is that a job will contain
a high diversity of modiﬁcation positions as possible.
Without considering too many intricacies of the ﬁle-
format or system code from a black-box perspective,
this technique attempts to ensure that a job tests out
as many “ﬁelds” of a data-format as possible. This
uniformity is measured using a chi-square test on all
ﬁles in a job/fuzz epoch.
• Improving Scalability and Fuzz Reuse. It is men-
tioned in Section 1.1 that fuzz ﬁles are generated once
and the copy is used to fuzz many devices, the side ef-
fect of it is the staggering growth of storage use when
devices run out of test cases or arrival of more test
devices. Diﬀ-patches rather than use of actual ﬁle has
a huge impact especially when it comes to MP4 and
other storage-heavy ﬁles. Before fuzzing, the device
32creates the actual fuzz ﬁle by patching out the seed
ﬁle. Refer to subsection 3.1.1 for more information on
this approach.
By sending just the patches of the seed ﬁle rather than
sending fuzzed ﬁles, we have been able to achieve up
to 90% lesser network traﬃc. Each fuzzed ﬁle is a only
BSDdiﬀ patch ﬁle of approximately 500bytes. This
makes it suitable for large scale fuzzing across the in-
ternet and future voluntary experiments by the general
public on a large scale analagous to SETI@home [13]
or BOINC [12].
Overall, MVDP comprises of various stages to generate
good fuzzing output, hasten the process of vulnerability dis-
covery and maximize the coverage of the test space. MVDP
at its present stage discovers vulnerabilities of media ﬁle-
formats but can be applied to target any data-format aces-
sible over the internet.
The layout of the paper is organised as follows. Section
2 introduces the architecture of MVDP and its four oper-
ational stages.
In Section 3 we share the implementation
and experiments done. Section 3 sheds light on the results
obtained and its implications. Section 4 lists related work,
Section 5 talks about future work and Section 6 concludes
the paper.
2. THE PROCESS
The Mobile Vulnerability Discovery Pipeline consists of
several processes that can be programmed into server-end
and device-end. Figure 1 provides an overview of the pipeline
with the numbers representing the order of operations. The
entire MVDP process can be described as three operating
stages: the Quality Input Generation, Device and Task Man-
agement, and Crash Analysis.
2.1 Quality Input Generation
This is a semi-automated stage consisting of automatic
downloading and initial good seed ﬁle selection. Additional
manual augmentation of good seed ﬁles is advisable but op-
tional. It aims to construct the best fuzzing conﬁguration
to be used such that the fuzzed ﬁles have good coverage and
uniform distribution. The following sub-sections describe
them in more detail.
2.1.1 Seed File Downloader (SFD)
To fuzz a data-format eﬀectively, the clean input data
(also known as seed ﬁles or initial ﬁles [14]) must cover as
high ﬁeld coverage as possible as deﬁned in the respective
ﬁle format RFC. To achieve this, data-format samples are
downloaded and further manually augmented.
For the purpose of this paper, the main data inputs for
fuzzing are ﬁle-based inputs. Rather than constructing such
a ﬁle from scratch, ﬁles are downloaded from the internet.
The search and download process is automated using web
APIs They scans the Internet for seed ﬁles using the Google
custom search Engine [15] and Microsoft Azure Search [16].
These raw inputs are given to SFAT.
2.1.2 Seed File Analysis Tool (SFAT)
SFAT compares, sorts and clusters the raw input ﬁles ac-
cording to their protocol coverage. File format parsers like
Figure 1: Architectural Flow Diagram of MVDP
showing automatic and manual processes.
Hachoir [17] provides ﬁle information for the seed ﬁle selec-