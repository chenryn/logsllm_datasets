# 在容器里 
# 创建一对 Veth Pair 设备。其中一个叫作 eth0，另一个叫作 vethb4963f3$ ip link add eth0 type veth peer name vethb4963f3 
# 启动 eth0 设备$ ip link set eth0 up  
# 将 Veth Pair 设备的另一端（也就是 vethb4963f3 设备）放到宿主机（也就是 Host Namespace）里$ ip link set vethb4963f3 netns $HOST_NS 
# 通过 Host Namespace，启动宿主机上的 vethb4963f3 设备$ ip netns exec $HOST_NS ip link set vethb4963f3 up 这样，vethb4963f3 就出现在了宿主机上，而且这个 Veth Pair设备的另一端，就是容器里面的 eth0。当然，你可能已经想到，上述创建 Veth Pair设备的操作，其实也可以先在宿主机上执行，然后再把该设备的一端放到容器的Network Namespace 里，这个原理是一样的。不过，CNI 插件之所以要"反着"来，是因为 CNI 里对 Namespace操作函数的设计就是如此，如下所示：    err := containerNS.Do(func(hostNS ns.NetNS) error {  ...  return nil})这个设计其实很容易理解。在编程时，容器的 Namespace 是可以直接通过Namespace 文件拿到的；而 HostNamespace，则是一个隐含在上下文的参数。所以，像上面这样，先通过容器Namespace 进入容器里面，然后再反向操作 HostNamespace，对于编程来说要更加方便。接下来，CNI bridge 插件就可以把 vethb4963f3 设备连接在 CNI网桥上。这相当于在宿主机上执行：    