tions as the user types into the “to” (i.e., sender) ﬁeld.
Experiment: We opened a document from BCloud in
the WPS Ofﬁce application. Then, from the WPS Ofﬁce
app, we shared the document with K-9 Mail. K-9 Mail’s
“compose” window was displayed. We then chose to
send as the work account, and picked a contact to add
to the “to” ﬁeld. We tried to attach another ﬁle, and the
“attach” action opened Android’s system ﬁle browser.
We selected a ﬁle and returned to K-9 Mail’s compose
screen. We then switched to the home screen without
sending the work email. We repeated the entire experi-
ment in the default (i.e., unlabeled) context, with the send
as ﬁeld set to the personal account. We then sent both
emails. Throughout the experiment, we watched the sys-
tem log for important events (e.g., network denial).
Observations: We made the following observations, and
veriﬁed them using the system log:
1. Context-speciﬁc instances. As we shared work data (in
the context {t}) with WPS Ofﬁce and subsequently K-9
Email, instances of these applications (i.e., processes and
components) were started in the work context {t}, and
attached to the internal and external (SD card) storage
layer Layer(t). The unlabeled context resulted in sepa-
rate instances with the empty label ({}), attached to the
default storage layer. Instances in both contexts existed
concurrently, without any crashes or abnormal behavior.
2. Context-speciﬁc data separation. While attaching an-
other document in the work ({t}) instance of K-9 Mail,
we could see all the documents on the default stor-
age layer (i.e., unlabeled ﬁles), and documents in work
Layer(t) (i.e., added from BCloud). On the contrary, in
the default context, we could only see the ﬁles on the
default layer. Further, in the default context, K-9 Mail
suggested from all of the user’s unlabeled contacts, but
none of the work contacts. In the work context, K-9 Mail
suggested from all the work contacts, and the unlabeled
contacts that existed before BCloud synced its labeled
contacts. That is, K-9 Mail could not see new records
created in the default layer’s contacts database after it
was copied over to Layer(t).
3. Domain Declassiﬁcation. In the work context, K-9
Email was unable to connect to the SMTP and IMAP
sub-domains of gmail.com, but could only connect
with the domains declassiﬁed by tag t. Unmodiﬁed K-9
Email silently handled these network access exceptions,
without crashing or displaying errors messages.
9 Trade-offs and Limitations
This section describes the trade-offs of our approach,
motivated in part by the observations in the case study.
1 Intent intent = new Intent();
2 // Add ‘‘t’’ to the intent’s label.
3 intent.addToLabel(‘‘t’’);
4 // Add data to the intent ...
5 startActivity(intent);//Call self
Listing 3: BCloud starts itself with new label
1. Centralized perspective: The user cannot view both
labeled and unlabeled data together, unless an applica-
tion is started in the labeled context (e.g., K-9 Mail in
context {t}). We envision modiﬁed application launch-
ers and phone settings that allow the user to start applica-
tions (e.g., File Browsers) with a certain label by default,
for making labeled and default data available together.
Our test apps use similar techniques; hence such launch-
ers should not be hard to create. On the other hand,
a centralized perspective on more than one non-default
context (e.g., {t1,t2,t3, ..}) may require a trusted OS ap-
plication exempt from polyinstantiation (but subject to
only ﬂoating labels), as ﬂoating labels by themselves are
vulnerable to information leaks ( Section 6).
2. Updates to default layer: While context-speciﬁc ver-
sions of ﬁles may be generally acceptable, in case of
database ﬁles (e.g., contacts read by K-9 Mail in the work
context) the user may expect new records in the unla-
beled context to be propagated to the copy in the labeled
context. The lack of updates is mainly a trade-off of
our ﬁle-level copy-on-write implementation (i.e., Over-
layFS). As mentioned in Section 5, a block-level copy-
on-write ﬁle system (e.g., BTRFS [32]) may mitigate this
trade-off, as it would only copy the blocks modiﬁed by
the labeled context, and newly allocated blocks in the de-
fault context would be accessible to the labeled context,
although this aspect needs further exploration.
3. Access control denials: Floating labels ensure that
inter-component communication is never denied, and
that resources (e.g., ﬁles, other components) are available
in all secrecy contexts. Although apps may be denied
network access, research has addressed this challenge in
the past (e.g., AppFence [17]). Further, most IDEs (e.g.,
Eclipse) enforce compile-time checks for proper excep-
tion handling, and it is uncommon for apps to crash due
to network denial, as observed in the case study as well.
4. Instance Explosion: Weir creates separate context-
speciﬁc K-9 Mail instances, only for the contexts in use.
The theoretical worst-case count of component instances
is equivalent to the number of components multiplied
by the number of all existing contexts (not just those
in use). Our event-based and “lazy” instantiation makes
this worst case practically improbable, unlike approaches
that execute all existing contexts (see Section 10). On the
other hand, a denial of service attack on a particular ap-
plication component may be feasible, by starting a very
large number of its instances in a short amount of time
for noticeable impact on the lookup time of that compo-
1132  25th USENIX Security Symposium 
USENIX Association
nent. Our implementation can be modiﬁed to detect and
prevent unusual rates of component instantiation. Note
that polyinstantiation of a component only affects its own
lookup time (as discussed in Section 7.1), and cannot be
used for an attack with a device-wide impact.
5. Resource Overhead: Polyinstantiation may cause
resource overhead in terms of the memory, battery and
storage. The memory overhead is manageable as An-
droid’s out of memory manager automatically reclaims
memory from low priority components. Further, any
measurement of the battery or storage use is bound to
be subjective with respect to the number of labels, num-
ber of apps/components, type of apps (e.g., game vs. text
editor), aspects of the user scenario (e.g., user-initiated
ﬂows, scenario-speciﬁc storage access). An objective
large-scale study will be explored in the future.
6. Consistency Issues: To a remote server, the instances
of an application in Weir are analogous to instances run-
ning on different devices (e.g., a user logged in from two
devices). Hence, any data consistency issues in such sce-
narios are not a result of polyinstantiation.
7. Covert Channels: Weir mediates overt communi-
cation between subjects and objects, but does not ad-
dress covert channels existing in Android. A clearance
label [6, 40, 44] can be used to defend against adver-
saries using covert channels by preventing access to cer-
tain tainted data in the ﬁrst place. While a clearance
label can be easily incorporated into Weir, setting the
clearance policy for third party applications with un-
predictable use cases is hard, and needs further explo-
ration from a policy speciﬁcation standpoint. Finally,
unlike IFC systems that focus on preventing untrusted
code within a program from exﬁltrating data (e.g., Secure
multi-execution [11]), Weir’s focus is inter-application
data sharing. Hence, compartmentalizing an application
using clearance is outside the scope of this paper.
8. Explicit labeling of messages and ﬁles: On Android,
an indirect message through the OS (e.g., intent message)
is required before a bi-directional Binder connection can
be established between two instances. Weir allows ﬂoat-
ing labels on such indirect communication (but not on
direct Binder calls), and polyinstantiation ensures that
the two instances at the end of a bidirectional Binder
connection have the same label, which is sufﬁcient for
synchronous Binder messages. Hence, labeling of indi-
vidual Binder messages does not provide additional ﬂex-
ibility, unlike in explicit labeling DIFC systems (e.g.,
COWL [41], Flume [21]). Note that Weir allows explicit
labeling of indirect messages (i.e., intent labeling). Fur-
ther, explicit labeling of a ﬁle with a label that is different
from its creating process instance would place it on an
incorrect layer. Such incorrectly stored ﬁles will not be
visible to future instances started with matching labels,
and may cause unpredictable application behavior. Thus,
our design trades the ﬂexibility in explicitly labeling ﬁles
for stable context-sensitive storage.
10 Related Work
In Section 3.1 we described prior DIFC proposals for An-
droid (i.e., Aquifer [28], Jia et al. [19] and Maxoid [46]).
We now describe other relevant prior research.
DIFC: Myers and Liskov presented the Decentralized
Labeling Model (DLM) [26] that allowed security prin-
cipals to deﬁne their own labels. Since then, numerous
DIFC systems have been proposed that provide valuable
policy and enforcement models [20,21,25–27,33,44,49,
50]. Language-based DIFC approaches (e.g., JFlow [25]
and Jif [27]) provide precision within the program, but
rely on the OS for DIFC enforcement on OS objects
(e.g., processes, ﬁles, sockets). On the contrary, coarse-
grained OS-level approaches (e.g., HiStar [49] and As-
bestos [44]) provide security for ﬂows between OS ob-
jects, but cannot reason about ﬂows at the granularity of
a programming language variable. While Weir is also an
OS-level DIFC approach, which means it cannot achieve
precision at the program variable level, context sensitive
enforcement ensures that Weir always has higher preci-
sion than traditional OS-level DIFC. Further, while Lam-
inar [30, 33] provides both language-level as well as the
OS-level enforcement, it requires applications to be mod-
iﬁed to use the precise language-level enforcement. This
is not an option for backwards compatible DIFC on An-
droid. Finally, Weir does not require general-purpose ap-
plications to explicitly deﬁne ﬂows as in Laminar, HiStar
and Flume [20, 21], as inter-application communication
in Android tends to be unpredictable.
Secure multi-execution: Secure multi-execution [11]
was proposed to determine and enforce that a program’s
execution is noninterferent, i.e., to eliminate unlawful
data ﬂows by untrusted code within a program. The
approach achieves noninterference using multiple con-
current executions at all points in the lattice, removing
statements that do not match the labels of speciﬁc exe-
cutions. On the contrary, lazy polyinstantiation creates
only one instance in the security context of the caller.
Unlike secure multi-execution where the multiple execu-
tions are treated as a part of the same program instance,
polyinstantiation treats multiple executions as unrelated
context-speciﬁc instances separated in memory and stor-
age. Our approach is more suitable for Android’s inter-
application data sharing abstractions, while secure multi-
execution may be useful to prove non-interference for a
general program. Further, secure multi-execution only
assumes a ﬁnite, predeﬁned label set. This assumption
is violated in DIFC systems, where the label set is often
USENIX Association  
25th USENIX Security Symposium  1133
large and not known a priori, and executing all labels at
once is impractical.
Faceted Execution: Jeeves [48] and Jaqueline [47] en-
sure that security principals see different views of data
based on their secrecy contexts, using a technique de-
ﬁned as faceted execution. The result of Weir’s approach
is similar; i.e., each security principal can only see data
at its own secrecy context. For faceted execution, the
copies of data have to be speciﬁed by the programmer
a priori, which is acceptable if the security of different
users using a single program (e.g., a conference submis-
sion site) is to be deﬁned. On the contrary, on Android,
Weir’s approach of allowing applications to operate un-
modiﬁed, and creating context-speciﬁc copies on the go,
is more practical. To elaborate, data in terms of Weir is
not the value(s) of a programming language variable, but
the instances of components in memory and ﬁle system
layers per label. Finally, just like secure multi-execution,
faceted execution is more suitable when the IFC lattice is
small (e.g., two labels) or ﬁnite, and may not be feasible
for DIFC, where tags can be created at runtime.
Coarse-grained Containers: Approaches such as Sam-
sung Knox [34] and Android for Work [2] protect en-
terprise data by isolating groups of applications into dif-
ferent containers. Containers cannot compensate for the
lack of data secrecy guarantees, as they do not address
threats within the container, i.e., the accidental export of
secret data by a trusted application or the potential com-
promise of a trusted application. Virtual phones (e.g.,
Cells [4]) are similarly inadequate for data secrecy.
Transitive Enforcement on Android: Android permis-
sions lack transitive enforcement, and are susceptible to
privilege escalation attacks [7, 16]. IPC Inspection [14]
enforces transitivity by reducing the caller’s effective
permissions to those of the least privileged component in
the call chain. Quire [12] provides the call chain infor-
mation to applications being called, to prevent confused
deputy attacks. Like ﬂoating labels, privilege reduction
is additive, and may severely restrict shared components.
Fine-grained Taint Tracking on Android: Taint-
Droid [13] detects private data leaks via ﬁne-grained taint
tracking on Android, but is vulnerable to implicit ﬂows.
CleanOS [43] and Pebbles [38] use ﬁne-grained taint
tracking on memory and storage to evict and manage pri-
vate data respectively. For tracking data in databases,
both approaches rely on modiﬁcation to the database li-
brary, which may not be secure as the library executes in
the memory of the enforcement subject.
11 Conclusion
Android’s component and storage abstractions make se-
cure and practical DIFC enforcement challenging. To ad-
dress these challenges, we present lazy polyinstantiation
and domain declassiﬁcation. We design and implement a
DIFC system, Weir, and show a negligible performance
impact as well as compatibility with legacy applications.
In doing so, we show how secure and backwards com-
patible DIFC enforcement can be achieved on Android.
Acknowledgements
This work was supported in part by the NSA Sci-
ence of Security Lablet at North Carolina State Uni-
versity, NSF CAREER grant CNS-1253346, NSF-SaTC
grants CNS-1228782 and CNS-1228620, and the United
State Air force and Defense Advanced Research Agency
(DARPA) under Contract No. FA8650-15-C-7562. Any
opinions, ﬁndings, and conclusions or recommendations
expressed in this material are those of the authors and do
not necessarily reﬂect the views of the funding agencies.
References
[1] ALJURAIDAN,
J., FRAGKAKI, E., BAUER, L.,
JIA, L.,
FUKUSHIMA, K., KIYOMOTO, S., AND MIYAKE, Y. Run-Time
Enforcement of Information Flow Properties on Android. Tech.
Rep. CMY-CyLab-12-015, CyLab, Carnegie Mellon University,
2012.
[2] ANDROID. Android for Work. https://www.android.
com/work/.
[3] ANDROID DEVELOPERS
.
Tasks
and Back Stack.
https://developer.android.com/guide/
components/tasks-and-back-stack.html.
[4] ANDRUS, J., DALL, C., HOF, A. V., LAADAN, O., AND NIEH,
J. Cells: a virtual mobile smartphone architecture. In Proceed-
ings of the Twenty-Third ACM Symposium on Operating Systems
Principles (2011), ACM, pp. 173–187.
[5] BAUER, L., CAI, S., JIA, L., PASSARO, T., STROUCKEN, M.,
AND TIAN, Y. Run-time Monitoring and Formal Analysis of In-
formation Flows in Chromium. In Proceedings of the ISOC Net-
work and Distributed Systems Security Symposium (NDSS) (Feb
2015).
[6] BELL, D. E., AND LAPADULA, L. J. Secure Computer Sys-
tems: Mathematical Foundations. Tech. Rep. MTR-2547, Vol. 1,
MITRE Corp., 1973.
[7] DAVI, L., DMITRIENKO, A., SADEGHI, A.-R., AND
WINANDY, M. Privilege Escalation Attacks on Android.
In
Proceedings of the 13th Information Security Conference (ISC)
(2010).
[8] DENNING, D. E. A Lattice Model of Secure Information Flow.
Communications of the ACM (1976).
[9] DEVELOPERS, K.-. M. K-9 Mail. https://github.com/
k9mail, 2015.