  * `libscveFaceRecognition_skel.so`
  * `libthread_blur_skel.so`
为了证明这一点，我们利用其中一个已发现的漏洞，获得了在基于骁龙处理器的设备上执行无符号代码的能力，包括三星、Pixel、LG、小米、OnePlus、HTC和索尼手机。
一个能够访问DSP的用户域的安卓应用获得了以下可能性。
  * 触发DSP内核恐慌并重启移动设备。
  * 隐藏恶意代码。反病毒软件不扫描Hexagon指令集。
  * cDSP负责对来自摄像头传感器的流媒体视频进行预处理。攻击者可以接管这个流程。
  * 访问DSP内核驱动程序。驱动程序中的漏洞可以将应用程序的权限扩大到客户操作系统或DSP内核的权限。
## DSP驱动器
QuRT操作系统实现了自己的设备驱动模型，称为QuRT驱动调用（QDI）。QDI是无法从Android
API中访问的。像POSIX一样，QDI设备驱动的操作权限高于请求驱动服务的用户代码。QDI提供了一个简单的驱动程序调用API，隐藏了所有与特权模式相关的实现细节。
`libqurt.a`库是Hexagon SDK的一部分，它包含QDI基础设施。FastRPC外壳与该库静态链接。
在QuRT的可执行二进制文件中可以找到几十个QDI驱动程序。它们通常被命名为`/dev/...`、`/qdi/...`、`/power/...`、`/drv/...`、`/adsp/...`或`/qos/...`。`int
qurt_qdi_open(const char*
drv)`函数可以用来获得对QDI驱动的访问。一个小的整数设备句柄会被返回。这是与POSIX文件描述符的直接平行。
QDI只提供了一个宏，是必要的用户可见的API。这个`qurt_qdi_handle_invoke`宏负责所有的通用驱动操作。事实上，`qurt_qdi_open`只是这个宏的一个特例。这些是宏的参数:
  1. QDI句柄或预定义的常量值之一。
  2. 定义所请求动作的方法编号。在SDK的头文件中，我们看到。 
    * 方法1和2被保留用于名称注册和名称查询。
    * 3-31保留用于对开放句柄的POSIX类型的操作。
    * 32-127保留给QDI基础设施。
    * 128-255保留给自动生成的方法使用，比如可能由IDL生成的方法。
    * 256和更高的是私有方法号。驱动程序可以按照自己的意愿使用这些方法。
  3. 0到9个可选的32位参数。
`qurt_qdi_handle_invoke`宏调用相关的设备驱动调用函数，该函数实现了主要的驱动逻辑，并提供了一个指定的方法号和可选的参数。
这是一个从用户PD代码中调用QDI驱动的例子。
一个QDI驱动使用`int qurt_qdi_devname_register(const char *name, qurt_qdi_obj_t
*opener)` API函数在QuRT中注册自己。驱动程序提供它的名字和一个指向开启器对象的指针作为参数。
开启者对象的第一个字段是驱动程序调用函数。QuRT调用这个函数来处理来自用户PD或其他驱动程序的驱动请求，并提供以下参数。
  * QDI句柄，代表发送QDI请求的客户端。
  * 发出该QDI请求的开启器对象。
  * 由调用者提供的QDI方法。
  * 由调用者提供的九个可选参数。
一般来说，驱动程序的调用函数是一个由QDI方法ID组成的开关运算器。每个方法可以使用与所提供的参数数量不同的参数。参数类型是`qurt_qdi_arg_t`。
请注意，驱动程序调用函数是基于模糊的漏洞研究的一个很好的目标，因为方法是由ID识别的，而不是由名字识别的，调用者不需要知道参数的确切数量和它们的实际类型来调用驱动程序方法。
## 基于反馈的QDI驱动程序的模糊测试
为了在Ubuntu上摸索QDI驱动，我们使用了与摸索DSP库相同的QEMU Hexagon和AFL的组合。然而，我们实现了另一个Hexagon
ELF二进制文件qdi_exec，而不是skel_loader程序，它负责这些操作。
  1. 将作为第一个命令行参数收到的数据文件解析为QDI方法ID和一个由9个参数组成的数组，用于驱动调用函数。
  2. 通过第二个命令行参数中指定的地址调用驱动程序调用函数，并提供QDI方法ID和从数据文件中解码的参数。
我们为`qdi_exec`程序使用了以下输入文件格式。
  * 头部（4字节）。它包含三个有价值的字段。 
    * QDI方法ID（10个低位）。在图7的例子中，它是0x01。
    * 参数的数量（4位）。在这个例子中，只有一个参数被使用。其余八个参数被认为是零。
    * 参数类型的掩码（9位）。正如我们前面提到的，每个参数要么是一个数字，要么是一个指向缓冲区的指针。在掩码中，每个参数用一个比特表示。值为0意味着该参数是一个数字，正值意味着该参数是一个缓冲区。
  * 缓冲区参数的大小（每个参数4字节）。在这个例子中，长度为0x0A的`/dev/diag`字符串被用作参数。
  * 缓冲区参数的内容。
【图7：用于fuzz QDI驱动程序的输入数据文件】
QDI驱动是作为QuRT
ELF的一部分实现的。高通公司没有把它们包括在`runelf.pbn`版本的QuRT中，我们在模拟器上与我们的程序一起运行。因此，我们不得不对`runelf.pbn`
ELF文件进行如下修补。
  1. 在`runelf.pbn`中添加用于真实设备的QuRT ELF的程序段。我们使用了从Pixel 4设备上提取的aDSP二进制文件。
  2. 将QDI驱动使用的`malloc`和`memcpy`内核函数重定向到其用户模式实现。内核内存函数限制了用户和内核空间之间的一些传输。
【图8： QDI驱动程序模糊测试方案】
AFL模糊器对数据文件的内容进行了修改，并在模拟器上触发了经过修补的`runelf.pbn`的执行。`runelf.pbn`加载了我们的`qdi_exec`程序，它直接调用了QDI驱动的调用函数。
我们通过对QuRT二进制文件的逆向工程，手动找到了QDI驱动调用函数的起始地址。开启者对象位于代码中的驱动程序名称旁边。
模糊器在骁龙855 aDSP内置的十几个QDI驱动程序中发现了许多崩溃现象。其中大部分也适用于cDSP。
## 利用QDI驱动程序中的漏洞
QDI驱动中的任何故障都可以被用来引起DSP内核的恐慌，并重新启动移动设备。例如，下面的每一行代码都会引起DSP恐慌，并可用于对设备进行DoS攻击。
出于研究目的，我们成功地利用了`/dev/i2c` QDI驱动的几个任意内核读写漏洞和`/dev/glink`
QDI驱动的两个代码执行漏洞。出于安全原因，我们不能公布POC代码，但我们注意到，利用方法相当简单。这是一个读取原语的例子。
恶意的Android应用程序可以利用QDI驱动中发现的漏洞和用户PD的DSP库中描述的漏洞，在DSP客户操作系统的上下文中执行自定义代码。
## 从客户操作系统PD请求安卓服务
如果我们试图从DSP客户操作系统的代码中打开一个与安卓有关的文件，会发生什么？答案是，QuRT将我们的请求重定向到一个特殊的Android守护进程。正如你在图9中看到的，在骁龙855设备上，有两个aDSP守护进程和一个cDSP守护进程，它们以不同的权限运作。
【图9： DSP Android守护程序】
在Pixel 4设备上，这些守护程序的启动命令可以在`init.sm8150.rc`文件中找到。
【图10：像素4`init.sm8150.rc`初始化文件】
这些高权限的`vendor.adsprpcd`和`vendor.cdsprpcd`守护进程处理DSP客户操作系统请求。`u:r:adsprpcd:s0`和`u:r:cdsprpcd:s0`上下文只可以访问与DSP相关的目录和对象，它们作为系统用户操作，但同时又受到SELinux的限制。
## 结论
aDSP和cDSP子系统是非常有前景的安全研究领域。首先，DSP可以被第三方Android应用程序调用。其次，DSP处理个人信息，如通过设备传感器的视频和语音数据。第三，正如我们在博客中介绍的那样，DSP组件中存在许多安全问题。
高通公司为披露的DSP漏洞分配了CVE-2020-11201、CVE-2020-11202、CVE-2020-11206、CVE-2020-11207、CVE-2020-11208和CVE-2020-11209。对于QDI驱动程序中发现的漏洞，高通公司决定不指定CVE。所有问题都已通过2020年11月的高通公司安全补丁成功修复。
出于研究目的，我们利用了一些已发现的漏洞，获得了在所有基于骁龙的移动终端的aDSP和cDSP上执行特权代码的能力。