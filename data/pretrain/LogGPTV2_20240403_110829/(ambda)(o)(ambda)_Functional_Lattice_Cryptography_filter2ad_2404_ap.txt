1. sample an error term ð‘’ âˆˆ ðœ‡ + ð‘ð‘…â€² (from a distribution that should be a ð‘ factor wider
than that of the secret key);
2. sample a uniformly random ð‘1 â† ð‘…â€²
ð‘ž;
106
3. output the LSD-form ciphertext ð‘(ð‘†) = (ð‘’ âˆ’ ð‘1 Â· ð‘ ) + ð‘1 Â· ð‘† âˆˆ ð‘…â€²
ð‘ž[ð‘†], with ð‘˜ = 0, ð‘™ =
1 âˆˆ Zð‘.
(Observe that ð‘(ð‘ ) = ð‘’ (mod ð‘žð‘…â€²), as desired.)
This translates directly into just a few lines of Haskell code, which is monadic due to its use
of randomness:
encrypt :: (m â€˜Dividesâ€˜ mâ€™, MonadRandom rnd, ...)
=> SK (Cyc mâ€™ z)
-> PT (Cyc m zp)
-> rnd (CT m zp (Cyc mâ€™ zq))
encrypt (SK v s) mu = do
e
 SK (Cyc mâ€™ z) -> CT m zp (Cyc mâ€™ zq) -> Cyc mâ€™ z
errorTerm (SK _ s) (CT LSD _ _ c) = liftDec (evaluate c (reduce s))
Following Equation (4.3.2), we then compute ð‘™Â· ð‘”âˆ’ð‘˜
of the message ðœ‡ into ð‘…â€²
ð‘, so we ï¬nally take the twace to recover ðœ‡ âˆˆ ð‘…ð‘ itself:
ð‘šâ€² Â· ð‘’ mod ð‘ð‘…â€². This yields the embedding
decrypt :: (Lift zq z, Reduce z zp, ...)
=> SK (Cyc mâ€™ z) -> CT m zp (Cyc mâ€™ zq) -> PT (Cyc m zp)
decrypt sk ct@(CT LSD k l _) =
let e = reduce (errorTerm sk ct)
in (scalarCyc l) * twace (iterate divG e !! k)
107
4.3.3 Homomorphic Addition and Multiplication
Homomorphic addition of ciphertexts with the same values of ð‘˜ and ð‘™ is simple: convert the
ciphertexts to the same form (MSD or LSD), then add their polynomials. It is also possible
adjust the values of ð‘˜, ð‘™ as needed by multiplying the polynomial by an appropriate factor,
which only slightly enlarges the error. Accordingly, we deï¬ne CT m zp (Cyc mâ€™ zq) to be
an instance of Additive, for appropriate argument types.
Now consider homomorphic multiplication: suppose ciphertexts ð‘1(ð‘†), ð‘2(ð‘†) encrypt
messages ðœ‡1, ðœ‡2 in LSD form, with auxiliary values ð‘˜1, ð‘™1 and ð‘˜2, ð‘™2 respectively. Then
ð‘”ð‘šâ€² Â· ð‘1(ð‘ ) Â· ð‘2(ð‘ ) = ð‘”ð‘šâ€² Â· ð‘’1 Â· ð‘’2
ð‘”ð‘šâ€² Â· ð‘’1 Â· ð‘’2 = (ð‘™1ð‘™2)âˆ’1 Â· ð‘”ð‘˜1+ð‘˜2+1
ð‘šâ€²
(mod ð‘žð‘…â€²),
Â· (ðœ‡1ðœ‡2)
(mod ð‘ð‘…â€²),
and the error term ð‘’ = ð‘”ð‘šâ€² Â· ð‘’1 Â· ð‘’2 satisï¬es Invariant 4.2.2, because ð‘’1, ð‘’2 do (see subsec-
tion 4.2.2). Therefore, the LSD-form ciphertext
ð‘(ð‘†) := ð‘”ð‘šâ€² Â· ð‘1(ð‘†) Â· ð‘2(ð‘†) âˆˆ ð‘…â€²
ð‘ž[ð‘†]
encrypts ðœ‡1ðœ‡2 âˆˆ ð‘…ð‘ with auxiliary values ð‘˜ = ð‘˜1 + ð‘˜2 + 1 and ð‘™ = ð‘™1ð‘™2 âˆˆ Zð‘. Notice that
the degree of the output polynomial is the sum of the degrees of the input polynomials.
More generally, it turns out that we only need one of ð‘1(ð‘†), ð‘2(ð‘†) to be in LSD form; the
product ð‘(ð‘†) then has the same form as the other ciphertext.2 All this translates immediately
to an instance of Ring for CT m zp (Cyc mâ€™ zq), with the interesting case of multiplication
having the one-line implementation
(CT LSD k1 l1 c1) * (CT d2 k2 l2 c2) =
CT d2 (k1+k2+1) (l1*l2) (mulG  c1 * c2)
2If both ciphertexts are in MSD form, then it is possible to use the â€œscale freeâ€ homomorphic multiplication
method of [Bra12], but we have not implemented it because it appears to be signiï¬cantly less efï¬cient than
just converting one ciphertext to LSD form.
108
(The other cases just swap the arguments or convert one ciphertext to LSD form, thus
reducing to the case above.)
4.3.4 Modulus Switching
Switching the ciphertext modulus is a form of rescaling typically used for decreasing
the modulus, which commensurately reduces the absolute magnitude of the error in a
ciphertextâ€”though the error rate relative to the modulus stays essentially the same. Because
homomorphic multiplication implicitly multiplies the error terms, keeping their absolute
magnitudes small can yield major beneï¬ts in controlling the error growth. Modulus switch-
ing is also sometimes useful to temporarily increase the modulus, as explained in the next
subsection.
Modulus switching is easiest to describe and implement for ciphertexts in MSD form
(Equation (4.3.3)) that have degree at most one. Suppose we have a ciphertext ð‘(ð‘†) =
ð‘0 + ð‘1ð‘† under secret key ð‘  âˆˆ ð‘…â€², where
ð‘0 + ð‘1ð‘  = ð‘‘ â‰ˆ ð‘ž
ð‘ Â· ð›¾
(mod ð‘žð‘…â€²)
ð‘šâ€² Â· ðœ‡ âˆˆ ð‘…ð‘. Switching to a modulus ð‘žâ€² is just a suitable rescaling of each
for ð›¾ = ð‘™âˆ’1 Â· ð‘”ð‘˜
ð‘– â‰ˆ (ð‘žâ€²/ð‘ž) Â· ð‘ð‘–; note that the right-hand sides here are
ð‘ð‘– âˆˆ ð‘…â€²
fractional, so they need to be discretized using an appropriate basis (see the next paragraph).
ð‘žâ€² such that ð‘â€²
ð‘ž to some ð‘â€²
ð‘– âˆˆ ð‘…â€²
Observe that
ð‘â€²
0 + ð‘â€²
1ð‘  â‰ˆ ð‘žâ€²
ð‘ž (ð‘0 + ð‘1ð‘ ) = ð‘žâ€²
ð‘ž Â· ð‘‘ â‰ˆ ð‘žâ€²
ð‘ Â· ð›¾
(mod ð‘žâ€²ð‘…â€²),
so the message is unchanged but the absolute error is essentially scaled by a ð‘žâ€²/ð‘ž factor.
Note that the ï¬rst approximation above hides the extra discretization error ð‘’0 + ð‘’1ð‘  where
ð‘ž ð‘ð‘–, so the main question is what bases of ð‘…â€² to use for the discretization, to best
ð‘’ð‘– = ð‘â€²
maintain Invariant 4.2.2. We want both ð‘’0 and ð‘’1ð‘  to satisfy the invariant, which means
ð‘– âˆ’ ð‘žâ€²
109
we want the entries of ðœŽ(ð‘’0 Â· ð‘”ð‘šâ€²) and ðœŽ(ð‘’1ð‘  Â· ð‘”ð‘šâ€²) = ðœŽ(ð‘’1) âŠ™ ðœŽ(ð‘  Â· ð‘”ð‘šâ€²) to be essentially
independent and as small as possible; because ð‘  âˆˆ ð‘…â€² itself satisï¬es the invariant (i.e., the
entries of ðœŽ(ð‘  Â· ð‘”ð‘šâ€²) are small), we want the entries of ðœŽ(ð‘’1) to be as small as possible. It
turns out that these goals are best achieved by rescaling ð‘0 using the decoding basis âƒ—ð‘‘, and ð‘1
using the powerful basis âƒ—ð‘. This is because ð‘”ð‘šâ€² Â· âƒ—ð‘‘ and âƒ—ð‘ respectively have nearly optimal
spectral norms over all bases of ð‘”ð‘šâ€²ð‘…â€² and ð‘…â€², as shown in [LPR13a].
Our Haskell implementation is therefore simply
rescaleLinearCT :: (Rescale zq zqâ€™, ...)
=> CT m zp (Cyc mâ€™ zq) -> CT m zp (Cyc mâ€™ zqâ€™)
rescaleLinearCT (CT MSD k l (Poly [c0,c1])) =
let câ€™0 = rescaleDec c0
câ€™1 = rescalePow c1
in CT MSD k l $ Poly [câ€™0, câ€™1]
4.3.5 Key Switching and Linearization
Recall that homomorphic multiplication causes the degree of the ciphertext polynomial to
increase. Key switching is a technique for reducing the degree, typically back to linear.
More generally, key switching is a mechanism for proxy re-encryption: given two secret
keys ð‘ in and ð‘ out (which may or may not be different), one can construct a â€œhintâ€ that lets
an untrusted party convert an encryption under ð‘ in to one under ð‘ out, while preserving the
secrecy of the message and the keys.
Key switching uses a gadget âƒ—ð‘” âˆˆ (ð‘…â€²
ð‘ž â†’
(ð‘…â€²)â„“ (both typically promoted from Zð‘ž; see sections 3.2.4 and 3.5.2). Recall that ð‘”âˆ’1(ð‘)
outputs a short vector over ð‘…â€² such that âƒ—ð‘”ð‘¡ Â· ð‘”âˆ’1(ð‘) = ð‘ (mod ð‘žð‘…â€²).
ð‘ž)â„“ and associated decomposition function ð‘”âˆ’1 : ð‘…â€²
The core operations. Let ð‘ in, ð‘ out âˆˆ ð‘…â€² denote some arbitrary secret values. A key-
switching hint for ð‘ in under ð‘ out is a matrix ð» âˆˆ (ð‘…â€²
ð‘ž)2Ã—â„“, where each column can be seen as
110
a linear polynomial over ð‘…â€²
ð‘ž, such that
(1, ð‘ out) Â· ð» â‰ˆ ð‘ in Â· âƒ—ð‘”ð‘¡
(mod ð‘žð‘…â€²).
(4.3.4)
Such an ð» is constructed simply by letting the columns be Ring-LWE samples with se-
cret ð‘ out, and adding ð‘ in Â· âƒ—ð‘”ð‘¡ to the top row. In essence, such an ð» is pseudorandom by the
Ring-LWE assumption, and hence hides the secrets.
The core key-switching step takes a hint ð» and some ð‘ âˆˆ ð‘…â€²
ð‘ž, and simply outputs
ð‘â€² = ð» Â· ð‘”âˆ’1(ð‘) âˆˆ (ð‘…â€²
ð‘ž)2,
(4.3.5)
which can be viewed as a linear polynomial ð‘â€²(ð‘†). Notice that by Equation (4.3.4),
ð‘â€²(ð‘ out) = (1, ð‘ out)Â·ð‘â€² = ((1, ð‘ out)Â·ð»)Â·ð‘”âˆ’1(ð‘) â‰ˆ ð‘ inÂ·âƒ—ð‘”ð‘¡Â·ð‘”âˆ’1(ð‘) = ð‘ inÂ·ð‘
(mod ð‘žð‘…â€²), (4.3.6)
where the approximation holds because ð‘”âˆ’1(ð‘) is short. More precisely, because the error
terms in Equation (4.3.4) satisfy Invariant 4.2.2, we want all the elements of the decompo-
sition ð‘”âˆ’1(ð‘) to have small entries in the canonical embedding, so it is best to decompose
relative to the powerful basis.
Following Equation (4.3.5), our Haskell code for the core key-switching step is simply
as follows (here knapsack computes the inner product of a list of polynomials over ð‘…â€²
a list of ð‘…â€²
ð‘ž-elements):
ð‘ž and
switch :: (Decompose gad zq z, râ€™q ~ Cyc mâ€™ zq, ...)
=> Tagged gad [Polynomial râ€™q] -> râ€™q -> Polynomial râ€™q
switch hint c =
untag $ knapsack  hint  (fmap reduce  decompose c)
111
Switching ciphertexts. The above tools can be used to switch MSD-form ciphertexts of
degree up to ð‘‘ under ð‘ in as follows: ï¬rst publish a hint ð»ð‘– for each power ð‘ ð‘–
in, ð‘– = 1, . . . , ð‘‘,
all under the same ð‘ out. Then to switch a ciphertext ð‘(ð‘†):
â€¢ For each ð‘– = 1, . . . , ð‘‘, apply the core step to coefï¬cient ð‘ð‘– âˆˆ ð‘…â€²
ing hint ð»ð‘–, to get a linear polynomial ð‘â€²
ð‘– = ð»ð‘– Â· ð‘”âˆ’1(ð‘ð‘–). Also let ð‘â€²
ð‘ž using the correspond-
0 = ð‘0.
â€¢ Sum the ð‘â€²
ð‘– to get a linear polynomial ð‘â€²(ð‘†), which is the output.
Then ð‘â€²(ð‘ out) â‰ˆ ð‘(ð‘ in) (mod ð‘žð‘…â€²) by Equation (4.3.6) above, so the two ciphertexts encrypt
the same message.
Notice that the error rate in ð‘â€²(ð‘†) is essentially the sum of two separate quantities: the
error rate in the original ð‘(ð‘†), and the error rate in ð» times a factor corresponding to the
norm of the output of ð‘”âˆ’1. We typically set the latter error rate to be much smaller than
the former, so that key-switching incurs essentially no error growth. This can be done
by constructing ð» over a modulus ð‘žâ€² â‰« ð‘ž, and scaling up ð‘(ð‘†) to this modulus before
decomposing.
Haskell functions. Our implementation includes a variety of key-switching functions,
whose types all roughly follow this general form:
keySwitchFoo :: (MonadRandom rnd, ...) => SK râ€™ -> SK râ€™
-> Tagged (gad, zqâ€™) (rnd (CT m zp râ€™q -> CT m zp râ€™q))
Unpacking this, the inputs are the two secret keys ð‘ out, ð‘ in âˆˆ ð‘…â€², and the output is essentially
a re-encryption function that maps one ciphertext to another. The extra Tagged (gad,zqâ€™)
context indicates what gadget and modulus are used to construct the hint, while the rnd
wrapper indicates that randomness is used in constructing (but not applying) the function;
this is because constructing the hint requires randomness.
Outputting a re-encryption functionâ€”rather than just a hint itself, which would need to
be fed into a separate function that actually does the switchingâ€”has advantages in terms
112
of simplicity and safety. First, it reï¬‚ects the abstract re-encryption functionality provided
by key switching. Second, we implement a variety of key-switching functions that each
operate slightly differently, and may even involve different types of hints (e.g., see the
next subsection). With our approach, the hint is abstracted away entirely, and each style of
key-switching can be implemented by a single client-visible function, instead of requiring
two separate functions and a specialized data type.
A prototypical implementation of a key-switching function is as follows (here ksHint is
a function that constructs a key-switching hint for ð‘ in under ð‘ out, as described above):
-- switch a linear ciphertext from one key to another
keySwitchLinear sout sin = tag $ do -- rnd monad
hint :: Tagged gad [Polynomial (Cyc mâ€™ zqâ€™)] 
CT MSD k l $ Poly [c0] + switch hint c1
4.3.6 Ring Tunneling
We provide a simple implementation of ring tunneling in Î›âˆ˜ðœ†, which to our knowledge is
the ï¬rst realization of ring-switching of any kind.
Linear functions. Since ring-tunneling induces a linear function on the plaintext, we
introduce a useful abstract data type to represent linear functions on cyclotomic rings:
newtype Linear z e r s = D [Cyc s z]
The parameters z represents the base type, while the parameters e, r, s represent the indices
of the cyclotomic rings ð¸, ð‘…, ð‘†. For example, Cyc s z represents the ring ð‘†. An ð¸-linear
function ð¿ is internally represented by its list âƒ—ð‘¦ = ð¿(âƒ—ð‘‘ð‘Ÿ,ð‘’) of values on the relative decoding
basis âƒ—ð‘‘ð‘Ÿ,ð‘’ of ð‘…/ð¸, hence the constructor named D. (We could also represent linear functions
via the relative powerful basis, but so far we have not needed to do so.) Using our interface
for cyclotomic rings (section 3.5), evaluating a linear function is straightforward:
113
evalLin :: (e â€˜Dividesâ€˜ r, e â€˜Dividesâ€˜ s, ...)
=> Linear z e r s -> Cyc r z -> Cyc s z
evalLin (D ys) r =
dotprod ys (fmap embed (coeffsCyc Dec r :: [Cyc e z]))
Lemma 4.2.1 leads to the following very simple Haskell function to extend a linear
function; notice that the constraints use the type-level arithmetic described in subsection 3.2.6
to enforce the hypotheses of Lemma 4.2.1.
extendLin :: (e ~ FGCD r eâ€™, râ€™ ~ FLCM r eâ€™, (FLCM s eâ€™) â€˜Dividesâ€˜ sâ€™)
=> Linear z e r s -> Linear z eâ€™ râ€™ sâ€™
extendLin (Dec ys) = Dec (fmap embed ys)
Tunneling. Next we give our implementation of ring tunneling.
tunnel f sout sin (CT MSD 0 s c) = tag $ do -- rnd monad
hints :: [Tagged gad [Polynomial (Cyc t sâ€™ zq)]] <-
tunnelHint f sout sin
let fâ€™ = extendLin $ lift f :: Linear t z eâ€™ râ€™ sâ€™
fâ€™q = reduce fâ€™ :: Linear t zqâ€™ eâ€™ râ€™ sâ€™
[c0,c1] = coeffs c