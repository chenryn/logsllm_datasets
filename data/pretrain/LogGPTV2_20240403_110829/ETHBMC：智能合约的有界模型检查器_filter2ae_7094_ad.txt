假设i.len和j.len都是常数，可以使用更复杂的方案。首先，如果i.len 6 =
j.len（第4行），可以简单地反驳两个值计算为相同的哈希，因此只需将i 6 =
j添加到Π。其次，当两个值匹配时（第6-16行），在用于哈希计算的可能的内存位置（第9-13行）上构造一个嵌套的ITE（IF-THEN-ELSE）表达式。在构造编码时，在每个级别上都会检查是否可以轻易证明两个内存位置相等（第9行），否则可以立即中止（第10行）并将两个keccak值编码为不相等（第15行）。否则将沿着len参数的范围（第8行）进行迭代。遍历每个内存位置（第9-12行），构造条件∆
[im，i.addr + k] = ∆ [jm，j.addr +
k]，编码为i的内存位置必须与j相同计算到相同的哈希值。在每次迭代中，将ITE表达式的真实分支分配给循环的前一次迭代的编码，特殊情况是循环的第一次迭代提供i
= j。因此，如果后端SMT求解器遍历嵌套编码，并且可以证明所有内存位置都相等，那么它将最终到达最终谓词i =
j。但是，如果它证明任何条件都成立，则得出否定谓词i！= j，在构造的每次迭代中都将其赋值。
乍一看，要求两个keccak元组都依赖恒定长度的参数似乎是一个强大的假设。然而实际上，通常是这种情况，例如，在固定大小的数据结构上计算的keccak值始终具有固定的长度，对于计算映射数据类型的内存偏移也是如此，可通过keccak操作对其进行访问。因此，额外地提取了计算的关键部分，以便以后匹配读/写。
另外，当遇到带有常数变量的相等检查时，即keccak ==
c，其中c为常数，可以立即得出结论，结果必须是不相等的。否则，假设可以计算哈希冲突。换句话说，假设可以计算一个特定的输入，这将导致keccak函数的（恒定）输出。注意：在特定情况下，攻击者可能知道生成c的正确输入。
## 0x05 Design and Implementation
现在，提供了ETHBMC架构的概述，下图提供了图形概述。该工具包含三个主要模块，即符号执行器，检测模块和验证模块。
ETHBMC在大约13,000行Rust代码中实现。
ETHBMC利用其符号执行引擎来探索程序可以到达的可用状态空间。在探索过程中，可以随时将达到此状态所需的必要条件（或约束）转换为一阶逻辑。探索结束后（即执行终止），将使用其他约束对攻击者的目标进行编码。例如，对一个约束进行编码，使攻击者的帐户余额在执行的最后一个状态必须高于在执行的第一个状态。然后，利用后端SMT求解器来求解约束系统。SMT求解器通过枚举执行证明：它试图找到约束系统的满意（具体）分配，从而证明可以求解。对智能合约的完整执行进行建模。因此，既达到有效的暂停状态又满足攻击者模型的令人满意的任务证明了合约中的漏洞。此外，由SMT求解器找到的具体分配是智能合约的有效输入（即交易），最后通过运行具体的脱机执行来验证该漏洞利用是真的。
###  1）符号执行器
执行器以广度优先搜索方式探索合约。每当执行者需要断言给定代码路径的可满足性时，都会查询后端SMT求解器。本文评估了不同的求解器，发现在此问题域中，Yices2优于其他方法，例如Boolector和Z3
。本文探索所有代码路径，直到它们到达停止状态，或者求解器超时或拒绝该路径。如果在执行过程中遇到循环，则使用循环展开，即执行n次循环，然后退出循环。本研究在限制调用深度方面使用了相同的策略，因为在具有多个帐户的环境中，合约可能会无限循环地相互调用。此外采用了几种标准的符号执行优化技术：恒定折叠，算术重写和约束集缓存。当执行器处于挂起状态时，所有最终状态都将传递到检测模块以进行进一步分析。
###  2）检测模块
本文使用其他路径约束对攻击者的目标进行编码，例如施加一个附加约束，以指定在执行当前交易后，跟踪者帐户的余额必须高于整个分析开始时的余额。当遇到DELEGATECALL或CALLCODE指令时，创建了一个附加的状态劫持，在这里试图劫持合约的控制流。为劫持添加了一个约束，将CALLCODE
/
DELEGATECALL的目标地址约束为攻击者的帐户广播。如果这个约束是可以满足的，可以重定向控制流。同样，标记执行SELFDESTRUCT指令的状态，以检测可被外部攻击者破坏的合约。请注意，如果可以使用SELFDESTRUCT指令从帐户中窃取资金，则ETHBMC会检测到这两种情况。如果检测到任何类型的漏洞，则会将相应的状态传递给验证模块。
如果无法检测到任何攻击，则会计算状态改变状态的集合，即经历环境变化的σh子集。只有这些状态才能在执行程序中引发新的路径，其他状态将导致与上一轮中探讨的初始状态相同。因此仅进一步探讨这些状态。
###  3）验证模块
在最后一步中，试图为每个具有可行攻击路径的状态生成有效的事务。利用SMT求解器生成触发漏洞所需的事务数据。在成功生成攻击数据后，利用go-ethereum工具套件，特别是EVM实用程序，以离线方式模拟攻击。 这能够模拟所有生成的事务并检查它们是否与所需的攻击向量匹配。
## 0x06 Evalution
###  1）现有技术的实证分析
首先将ETHBMC与前文中检验的静态分析工具进行比较。使将SELFDESTRUCT指令嵌入每个合约中，因为所有工具都为此提供了检测模块。此外，重新创建了检查的奇偶校验帐户黑客程序，以模拟复杂的实际情况。下表列出了本研究的发现。
**分析设置：**
不幸的是无法让MAIAN正常工作；目前，分析器所需的多个库不兼容。作者既没有指定他们在原始文章中使用的版本，也没有回答有关这些问题的多个GitHub问题。同样，本文仅讨论Vandal，因为MadMax继承了其函数。
在撰写本文时，根据工具的最新版本进行了评估。这对应于github commit
d7b7fd1上的teEther，版本0.2.4中的Manticore，0.20.0中的Mythril，github commit f7bfee7
上的Vandal，在github commit 8fd230和Oyente上的安全在github上提交6c9d382
。虽然Oyente提供了一种检测暴露的SELFDESTRUCT指令的模式，们在测试过程中发现该模式似乎是固有破坏的。为了进行健全性检查，测试了一个仅带有一个单行函数的简单合约，该函数可以自毁合约（即List
1中没有周围的if子句）。 Oyente将合约标记为不脆弱。因此将其从实验中排除。
为了进行评估，将所有合约编译为字节码，并将其用作不同分析器的输入。这保证了所有工具之间的比较是公平的，没有人可以利用源代码信息获得好处。
**Keccak256函数：** 从简单的合约测试开始，即对分析器建模哈希函数（即List 1）的能力进行测试。合约将哈希输入与随机选择的常数值进行比较。
如果攻击者想通过检查（第2行），他们将不得不提供一个预映像。由于keccak是一种加密安全的哈希函数，因此在实践中这是不可行的，并且合约也不容易受到攻击。
Manticore，Securify和ETHBMC正确地将合约标识为安全的，所有其他工具均报告存在漏洞。但是，根据源代码审查，teEther应该可以通过实验。在合约的第一次通过中，teEther使用二进制切片来查找导致潜在脆弱状态的路径。在第二条路径中，它象征性地执行这些路径，以查找可能达到此状态的输入。但是，对于此实验，teEther报告它找不到包含SELFDESTRUCT指令的潜在路径。根据理解，它仅应在第二遍中放弃可利用合约的可能性。因此，对于该实验，将teEther列为不正确的。
由于映射数据类型的普遍性，将继续使用List
2中列出的合约进行分析，一个攻击者可以通过首先调用createUser，提供自己的帐户地址作为输入，然后与她调用destruct来利用该合约分配的ID。只有teEther和ETHBMC才能找到脆弱状态。
**内存复制操作：** 下一个实验旨在测试执行者对内存复制式操作的处理方式。使用List
3中所示的协定。由于输入定义为字符串，因此使用类似于memcopy的指令将calldata复制到内存中。
乍一看，Securify似乎通过了实验，报告了一个易受攻击的状态。但是，这与前文中的源代码审查直接冲突，因为发现它只是忽略了像memcopy这样的指令。因此进行了第二次验证实验，如下所示：
运行该实验两次，一次按原样进行，另一次对第2行的条件取反，导致Securify将这两个实例标记为易受攻击。这证实了对Securify不能正确推理此程序的怀疑，因为上述实例显然是不容易受到攻击的。对所有工具重复此实验，但结果没有改变。除teEther和ETHBMC之外的所有工具都无法找到易受攻击的状态。