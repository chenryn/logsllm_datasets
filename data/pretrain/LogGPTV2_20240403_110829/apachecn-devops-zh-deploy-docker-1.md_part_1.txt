# 一、容器——不仅仅是另一个流行语
在技术方面，有时进步很小，但正如容器化一样，进步是巨大的，将长期以来的实践和教导完全颠倒过来。有了这本书，我们将带您从运行一个微小的服务，到使用 Docker 的容器化构建弹性可扩展的系统，这是这场革命的基石。我们将通过基本模块进行稳定但一致的升级，重点是 Docker 的内部工作，并且在继续的过程中，我们将尝试将大部分时间花在复杂的部署及其考虑事项上。
让我们看看本章将讲述的内容:
*   什么是容器，为什么我们需要它们？
*   Docker 在容器界的地位
*   用容器思维思考
# 容器的什么和为什么
我们不能一开始就谈论 Docker，而不实际涵盖使它成为如此强大的工具的想法。在最基本的层面上，容器是一个独立的用户空间环境，用于给定的离散功能集。换句话说，这是一种将系统(或一个系统的一部分)模块化成更容易管理和维护的部分的方法，同时通常对故障也非常有弹性。
在实践中，这种净收益从来都不是免费的，需要在新工具(如 Docker)的采用和实现上进行一些投资，但是这种变化给采用者带来了巨大的好处，在开发、维护和扩展成本上大幅降低。
在这一点上，你可能会问:容器到底是如何提供如此巨大的好处的？为了理解这一点，我们首先需要在这样的工具可用之前了解一下部署。
在部署的早期，部署服务的过程是这样的:
1.  开发人员会编写一些代码。
2.  运营部将部署该代码。
3.  如果在部署中有任何问题，运营团队会告诉开发人员解决一些问题，然后我们会回到第 1 步。
这个过程的简化如下所示:
```
dev machine => code => ops => bare-metal hosts
```
开发人员将不得不等待整个过程反弹回来，以便在出现问题时尝试编写修复程序。更糟糕的是，运营团队通常不得不使用各种神秘的魔法形式来确保开发人员提供给他们的代码能够在部署机器上实际运行，因为库版本、操作系统补丁和语言编译器/解释器的差异都有很高的失败风险，并且可能会在这漫长的中断-补丁-部署尝试周期中花费大量时间。
部署发展的下一步是通过裸机主机的虚拟化来改进这一工作流程，因为手动维护机器和环境的异构组合是一场彻头彻尾的噩梦，即使它们的数量只有个位数。`chroot`等早期工具在 70 年代末问世，但后来被 Xen、KVM、Hyper-V 等虚拟机管理程序以及其他一些虚拟机管理程序所取代(尽管不是完全取代)，这不仅降低了较大系统的管理复杂性，还为 Ops 和开发人员提供了更一致且计算密度更高的部署环境:
```
dev machine => code => ops => n hosts * VM deployments per host
```
这有助于减少管道末端的故障，但从开发人员到部署的路径仍然存在风险，因为虚拟机环境很容易与开发人员不同步。
从这里，如果我们真的试图弄清楚如何让这个系统变得更好，我们已经可以看到 Docker 和其他容器技术是如何有机地进行下一步的。通过使开发人员的沙箱环境尽可能接近生产环境，具有足够功能的容器系统的开发人员可以绕过 ops 步骤，确保代码可以在部署环境中工作，并防止由于多个组交互的开销而导致的任何冗长的重写周期:
```
dev machine => container => n hosts * VM deployments per host
```
由于 Ops 主要在系统设置的早期阶段被需要，开发人员现在可以将他们的代码从想法中直接带到用户面前，并且相信他们会发现的大多数问题都是他们能够解决的。
如果你认为这是部署服务的新模式，那么很有理由理解为什么我们现在有 DevOps 角色，为什么在**平台即服务** ( **PaaS** )设置中有如此多的嗡嗡声，以及为什么如此多的科技巨头可以在 15 分钟内用开发者的简单操作`git push origin`在不与系统进行任何其他交互的情况下，一次对数百万人使用的服务进行更改。
但好处也不止于此！如果您在任何地方都有许多小容器，并且如果您增加或减少了对服务的需求，您可以添加或删除一部分主机，并且如果容器编排正确，将不会有停机时间，也不会有用户注意到的伸缩变化。对于需要在不同时间处理可变负载的服务提供商来说，这非常方便——以网飞和他们的峰值收视时间为例。在大多数情况下，这些也可以在几乎所有的云平台上实现自动化(即 AWS 自动扩展组、Google Cluster Autoscaler 和 Azure Autoscale)，这样，如果发生某些触发或资源消耗发生变化，服务将自动上下扩展主机数量来处理负载。通过自动化所有这些过程，您的 PaaS 几乎可以成为一个“一劳永逸”的灵活层，在此之上，开发人员可以担心真正重要的事情，而不会浪费时间去尝试弄清楚一些系统库是否安装在部署主机上。
现在不要误会我；无论怎么想象，做出这些令人惊叹的 PaaS 服务之一都不是一件容易的事情，道路上布满了无数隐藏的陷阱，但是如果你想在整个晚上都能睡得很香，而没有愤怒的客户、老板或同事的电话，无论你是否是开发人员，你都必须努力尽可能接近这些理想的设置。
# Docker 的地方
到目前为止，我们已经谈了很多关于容器的问题，但是还没有提到 Docker。虽然 Docker 已经成为容器化的事实标准，但它目前是该领域许多竞争技术之一，今天相关的可能不是明天。出于这个原因，我们将介绍一点容器生态系统，这样，如果您看到这个领域发生了变化，请不要犹豫，尝试另一种解决方案，因为为工作选择合适的工具几乎总是胜过尝试，俗话说，在圆孔中安装方形钉子。
虽然大多数人都知道 Docker 是**命令行界面** ( **CLI** )工具，但 Docker 平台不止于此，还包括创建和管理集群、处理持久存储、构建和共享 Docker 容器等工具，但目前，我们将重点关注生态系统中最重要的部分:Docker 容器。
# Docker 容器简介
Docker 容器本质上是一组文件系统层，这些文件系统层按顺序堆叠在彼此之上，以创建最终布局，然后由主机内核在隔离的环境中运行。每一层描述相对于其先前的父层，哪些文件已经被添加、修改和/或删除。例如，你有一个带有文件`/foo/bar`的基础图层，下一个图层添加一个文件`/foo/baz`。当容器启动时，它将按顺序组合各层，得到的容器将同时具有`/foo/bar`和`/foo/baz`。对任何新的层重复这个过程，最终得到一个完整的文件系统来运行指定的一个或多个服务。
把映像中文件系统层的排列想象成交响乐中复杂的声音层次:你在后面有打击乐器来为声音提供基础，管乐器靠近一点来驱动动作，在前面有弦乐器来引导旋律。一起，它创造了一个令人愉快的最终结果。在 Docker 的情况下，您通常让基础层设置主要的操作系统层和配置，服务基础结构层在基础层之上(解释器安装、助手编译等)，您运行的最终映像最终以实际的服务代码结束。目前，这是您需要知道的全部内容，但是我们将在下一章中更详细地讨论这个主题。
本质上，当前形式的 Docker 是一个平台，允许在可扩展、易于互换和易于分发的容器中轻松快速地开发隔离的(或不依赖于服务如何配置的)Linux 和 Windows 服务。
# 竞争
在我们深入了解 Docker 本身之前，让我们也大致介绍一下当前的一些竞争对手，看看它们与 Docker 本身有何不同。几乎所有这些都很奇怪，它们通常是围绕 Linux 控制组(`cgroups`)和名称空间的一种抽象形式，分别限制了 Linux 主机物理资源的使用，并将进程组相互隔离。虽然这里提到的几乎每一个工具都提供了某种形式的资源容器化，但是它在隔离深度、实现安全性和/或容器分布方面有很大的不同。
# rkt
`rkt`，常被写成 **Rocket** ，是 CoreOS 最接近的竞争应用容器化平台，最初是作为更安全的应用容器运行时启动的。随着时间的推移，Docker 已经解决了许多安全问题，但与作为用户服务以有限权限运行的`rkt`不同，Docker 的主服务以 root 身份运行。这意味着，如果有人设法突破 Docker 容器，他们将自动拥有对主机根目录的完全访问权限，从操作角度来看，这显然是一件非常糟糕的事情，而对于`rkt`来说，黑客还需要将他们的权限从受限用户升级。虽然从安全角度来看，这种比较并没有给 Docker 带来太大的好处，但如果要推断它的发展轨迹，这个问题有可能在未来得到很大程度的缓解和/或解决。
另一个有趣的区别是，与 Docker 不同，Docker 被设计为在容器内运行单个进程，`rkt`可以在一个容器内运行多个进程。这使得在一个容器中部署多个服务变得更加容易。现在，说了这么多，你实际上*可以*在一个 Docker 容器中运行多个进程(我们将在本书的稍后部分讨论这个问题)，但是正确地设置它是一件非常痛苦的事情，但是我确实在实践中发现，保持服务和容器基于单个进程的压力确实会促使开发人员将容器创建为真正的微服务，而不是将其视为迷你虚拟机，所以不要认为这一定是一个问题。