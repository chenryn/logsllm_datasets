  Stack:	
  0x773377A2	
  -­‐	
  ntdll!RtlEnterCriLcalSecLon	
  0x643548A0	
  -­‐	
  chrome_child!base::internal::LockImpl::Lock	
  0x6577FA77	
  -­‐	
  chrome_child!media::Pipeline::GetStaLsLcs	
  0x653914ED	
  -­‐	
  chrome_child!content::WebMediaPlayerImpl::videoDecodedByteCount	
  0x64CB8397	
  -­‐	
  chrome_child!WebCore::HTMLMediaElementV8Internal::webkitVideoDecodedByteCountArributeGererCallback	
  0x6453377A	
  -­‐	
  chrome_child!v8::internal::PropertyCallbackArguments::Call	
  0x644EB930	
  -­‐	
  chrome_child!v8::internal::JSObject::GetPropertyWithCallback	
  0x644B5CE5	
  -­‐	
  chrome_child!v8::internal::Object::GetProperty	
ISSUE	
  #18	
Chrome	
  35	
  Bug 
Caught	
  a	
  Stack	
  Overﬂow	
  in	
  process	
  2232	
  at	
  2014-­‐07-­‐08	
  08:37:05	
  with	
  a	
  crash	
  hash	
  of	
  8815714D.CE7CE246	
Registers:	
  eax	
  =	
  0x664EBD1C	
  (R-­‐-­‐)	
  -­‐	
  chrome_child!WebCore::HTMLContentElement::`voable'	
  ebx	
  =	
  0x00000001	
  ecx	
  =	
  0x4386EE38	
  (RW-­‐)	
  edx	
  =	
  0x000A3090	
  (RW-­‐)	
  esi	
  =	
  0x4386EE38	
  (RW-­‐)	
  edi	
  =	
  0x43868330	
  (RW-­‐)	
  ebp	
  =	
  0x000A300C	
  (RW-­‐)	
  esp	
  =	
  0x000A2FFC	
  (RW-­‐)	
  eip	
  =	
  0x64CF3811	
  (R-­‐X)	
  -­‐	
  chrome_child!WebCore::InserLonPoint::detach	
Code:	
  0x64CF3811	
  -­‐	
  push	
  ebx	
  0x64CF3812	
  -­‐	
  push	
  esi	
  0x64CF3813	
  -­‐	
  mov	
  ebx,	
  ecx	
  0x64CF3815	
  -­‐	
  push	
  edi	
  0x64CF3816	
  -­‐	
  xor	
  edi,	
  edi	
  0x64CF3818	
  -­‐	
  cmp	
  [ebx+3ch],	
  edi	
  0x64CF381B	
  -­‐	
  jbe	
  64cf38b1h	
  0x64CF3821	
  -­‐	
  cmp	
  edi,	
  [ebx+3ch]	
Call	
  Stack:	
  0x64CF3811	
  -­‐	
  chrome_child!WebCore::InserLonPoint::detach	
  0x64AB5DD2	
  -­‐	
  chrome_child!WebCore::ElementShadow::detach	
  0x647F8CAF	
  -­‐	
  chrome_child!WebCore::Element::detach	
  0x64D52043	
  -­‐	
  chrome_child!WebCore::HTMLPlugInElement::detach	
  0x647F8CFC	
  -­‐	
  chrome_child!WebCore::ContainerNode::detach	
  0x647F8CB9	
  -­‐	
  chrome_child!WebCore::Element::detach	
  0x64D52043	
  -­‐	
  chrome_child!WebCore::HTMLPlugInElement::detach	
  0x647F8CFC	
  -­‐	
  chrome_child!WebCore::ContainerNode::detach	
  0x647F8CB9	
  -­‐	
  chrome_child!WebCore::Element::detach	
Acknowledge	
  Microso~ 
•  MS14-­‐035	
  (June	
  2014)	
•  MS14-­‐037	
  (July	
  2014)	
•  MS14-­‐051	
  (August	
  2014)	
Summary 
Fuzzing	
  =	
  Programming 
  +	
  SpeciﬁcaTon	
  reading	
  +	
  VulnerabiliTes’	
  characterisTc	
  collecTng	
  +	
  Ideas 
J 	
  0days 
J  Javascript,	
  HTML,	
  CSS	
  and	
  programming	
L 	
  Browser	
  &	
  Compiler	
L 	
  Vulnerability	
  discovery	
  &	
  Security	
  intuiTon 
Browser	
  Security	
  Model 
•  知己知彼，百战不殆。	
–  If	
  you	
  know	
  your	
  enemies	
  and	
  know	
  yourself,	
you	
  will	
  not	
  be	
  imperiled	
  in	
  a	
  hundred	
  ba>les.	
•  不知彼而知己，一胜一负。 
–  If	
  you	
  do	
  not	
  know	
  your	
  enemies	
  but	
  do	
  know	
yourself,	
  you	
  will	
  win	
  one	
  and	
  lose	
  one.	
•  不知彼，不知己，每战必殆。 
–  If	
  you	
  do	
  not	
  know	
  your	
  enemies	
  nor	
  yourself,	
you	
  will	
  be	
  imperiled	
  in	
  every	
  single	
  ba>le.	
  -­‐-­‐	
  孙子（Sun	
  Tzu） 
Browser	
  Exploit	
  and	
  MiTgaTon 
•  Two	
  exploit	
  miTgaTons	
–  ASLR	
–  DEP 
•  Turing	
  complete	
–  Reading	
–  WriTng	
–  ExecuTng 
•  DEP	
  -­‐>	
  Execute 
•  ASLR	
  bypass	
  -­‐>	
  Reading	
  &	
  WriTng 
HANDLE	
  __stdcall	
  RtlCreateHeap(ULONG	
  Flags,	
  PVOID	
  BaseAddress,	
  ULONG	
SizeToReserve,	
  ULONG	
  SizeToCommit,	
  PRTL_HEAP_DEFINITION	
  DeﬁniLon)	
  { 
  RandFreeSize	
  =	
  (RtlpHeapGenerateRandomValue64()	
  &	
  0x1F)	
  =	
  0	
  )	
  { 
    HeapHandle	
  =	
  (char	
  *)BaseAddress	
  +	
  RandFreeSize; 
    SizeToReserve	
  =	
  AllocaLonSize	
  -­‐	
  RandFreeSize; 
  } 
} 
void	
  *__fastcall	
  RtlpAllocateHeap(int	
  hHeapArg,	
  unsigned	
  int	
  a2,	
  int	
  a3,	
ULONG	
  SizeToCommit,	
  int	
  a5,	
  int	
  a6)	
  { 
  ... 
  if	
  (	
  BlockSize	
  >	
  *(_DWORD	
  *)(hHeap	
  +	
  0x5C)	
  )	
  { 
  if	
  (	
  *(_BYTE	
  *)(hHeap	
  +	
  0x40)	
  &	
  2	
  )	
  { 
        SizeToCommit	
  +=	
  24; 
        RandOﬀ	
  =	
  (RtlpHeapGenerateRandomValue32()	
  &	
  0xF)	
  =	
  0	
  )	
  {	
  …	
  HeapHandle	
  =	
  (char	
  *)lpAddress	
  +	
  0x20; 
  ... 
} 
VirtualAlloc	
  is	
  not	
  randomized! 
Windows	
  7	
[+]	
  VirtualAlloc 
3:	
  00890000 
4:	
  00990000 
5:	
  00A90000 
6:	
  00B90000	
7:	
  00C90000 
8:	
  00D90000 
9:	
  01030000 
[+]	
  HeapCreate 
0:	
  01260000 
1:	
  01430000 
2:	
  00390000 
3:	
  01630000 
4:	
  00640000 
5:	
  01210000 
6:	
  013F0000 
Windows	
  8.1	
[+]	
  VirtualAlloc 
3:	
  00B20000 
4:	
  00C20000 
5:	
  00D20000 
6:	
  00E20000 
7:	
  00F20000 
8:	
  01020000 
9:	
  01120000 
[+]	
  HeapCreate 
0:	
  018F0000 
1:	
  019F0000 
2:	
  01B20000 
3:	
  011F0000 
4:	
  01C90000 
5:	
  01E00000 
6:	
  019B0000 
Windows	
  7	
[+]	
  Default	
  HeapAlloc 
0:	
  006D7FE8 
1:	
  006D8FE8 
2:	
  006D9FE8 
3:	
  006DAFE8 
4:	
  006DBFE8 
5:	
  006DCFE8 
6:	
  006DDFE8 
[+]	
  Large	
  HeapAlloc 
0:	
  01440020 
1:	
  01640020 
2:	
  01740020 
3:	
  01840020 
4:	
  01940020 
5:	
  01A40020 
6:	
  01B40020 
Windows	
  8.1	
[+]	
  Default	
  HeapAlloc 
0:	
  00CC9198 
1:	
  00CCA198 
2:	
  00CCB198 
3:	
  00CCC198 
4:	
  00CCD198 
5:	
  00CCE198 
6:	
  00CCF198 
[+]	
  Large	
  HeapAlloc 
0:	
  01A13020 
1:	
  01B49020 
2:	
  01CB7020 
3:	
  01E24020 
4:	
  01FCE020 
5:	
  020DB020 
6:	
  021EE020 
ASLR	
  in	
  IE	
  11 
bool	
  __thiscall	
  Segment::IniLalize(Segment	
  *this,	
  unsigned	
  __int32	
a2)	
  { 
  … 
  if	
  (	
  PageAllocator::RequestAlloc(*((PageAllocator	
  **)this	
  +	
  5),	
  *((_DWORD	
  *)this	
  +	
  3)	
  <<	
  12)	
  )	
  { 
  lpAddress	
  =	
  VirtualAlloc(0,	
  *((_DWORD	
  *)v2	
  +	
  3)	
  <<	
  12,	
  a2	
        |	
  0x2000,	
  4u); 
  *((_DWORD	
  *)v2	
  +	
  2)	
  =	
  lpAddress; 
  if	
  (	
  lpAddress	
  &&	
  !(unsigned	
  __int8)(*(int	
  (__stdcall	
  **)	
         (Segment	
  *,	
  char	
  *))(**((_DWORD	
  **)v2	
  +	
  5)	
  +	
  4))	
         (v2,	
  (char	