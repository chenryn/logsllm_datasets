## QUIC 内部细节由于 QUIC 在协议栈里比较偏底层，所以我只简略介绍两个内部的关键知识点。QUIC的基本数据传输单位是**包**（packet）和**帧**（frame），一个包由多个帧组成，包面向的是"连接"，帧面向的是"流"。QUIC 使用不透明的"**连接ID**"来标记通信的两个端点，客户端和服务器可以自行选择一组 ID来标记自己，这样就解除了 TCP 里连接对"IP 地址 +端口"（即常说的四元组）的强绑定，支持"**连接迁移**"（ConnectionMigration）。![](Images/39b4a4927043b7f93e3d4dee31c292f2.png){savepage-src="https://static001.geekbang.org/resource/image/ae/3b/ae0c482ea0c3b8ebc71924b19feb9b3b.png"}比如你下班回家，手机会自动由 4G 切换到 WiFi。这时 IP 地址会发生变化，TCP就必须重新建立连接。而 QUIC 连接里的两端连接 ID不会变，所以连接在"逻辑上"没有中断，它就可以在新的 IP地址上继续使用之前的连接，消除重连的成本，实现连接的无缝迁移。QUIC 的帧里有多种类型，PING、ACK 等帧用于管理连接，而 STREAM帧专门用来实现流。QUIC 里的流与 HTTP/2 的流非常相似，也是帧的序列，你可以对比着来理解。但HTTP/2 里的流都是双向的，而 QUIC 则分为双向流和单向流。![](Images/1d86380c912f1f1e058c0213cdfcfa56.png){savepage-src="https://static001.geekbang.org/resource/image/9a/10/9ab3858bf918dffafa275c400d78d910.png"}QUIC 帧普遍采用变长编码，最少只要 1 个字节，最多有 8 个字节。流 ID的最大可用位数是 62，数量上比 HTTP/2 的 2\^31 大大增加。流 ID 还保留了最低两位用作标志，第 1 位标记流的发起者，0 表示客户端，1表示服务器；第 2 位标记流的方向，0 表示双向流，1 表示单向流。所以 QUIC 流 ID 的奇偶性质和 HTTP/2 刚好相反，客户端的 ID 是偶数，从 0开始计数。
## HTTP/3 协议了解了 QUIC 之后，再来看 HTTP/3 就容易多了。因为 QUIC 本身就已经支持了加密、流和多路复用，所以 HTTP/3的工作减轻了很多，把流控制都交给 QUIC 去做。调用的不再是 TLS的安全接口，也不是 Socket API，而是专门的 QUIC 函数。不过这个"QUIC函数"还没有形成标准，必须要绑定到某一个具体的实现库。HTTP/3 里仍然使用流来发送"请求 - 响应"，但它自身不需要像 HTTP/2那样再去定义流，而是直接使用 QUIC 的流，相当于做了一个"概念映射"。HTTP/3 里的"双向流"可以完全对应到 HTTP/2 的流，而"单向流"在 HTTP/3里用来实现控制和推送，近似地对应 HTTP/2 的 0 号流。由于流管理被"下放"到了 QUIC，所以 HTTP/3 里帧的结构也变简单了。帧头只有两个字段：类型和长度，而且同样都采用变长编码，最小只需要两个字节。![](Images/49fed9172d72197cc2d8f737425c8ee4.png){savepage-src="https://static001.geekbang.org/resource/image/26/5b/2606cbaa1a2e606a3640cc1825f5605b.png"}HTTP/3 里的帧仍然分成数据帧和控制帧两类，HEADERS 帧和 DATA帧传输数据，但其他一些帧因为在下层的 QUIC 里有了替代，所以在 HTTP/3里就都消失了，比如 RST_STREAM、WINDOW_UPDATE、PING 等。头部压缩算法在 HTTP/3里升级成了"**QPACK**"，使用方式上也做了改变。虽然也分成静态表和动态表，但在流上发送HEADERS帧时不能更新字段，只能引用，索引表的更新需要在专门的单向流上发送指令来管理，解决了HPACK 的"队头阻塞"问题。另外，QPACK 的字典也做了优化，静态表由之前的 61 个增加到了 98个，而且序号从 0 开始，也就是说":authority"的编号是 0。
## HTTP/3 服务发现讲了这么多，不知道你注意到了没有：HTTP/3没有指定默认的端口号，也就是说不一定非要在 UDP 的 80 或者 443 上提供HTTP/3 服务。那么，该怎么"发现"HTTP/3 呢？这就要用到 HTTP/2 里的"扩展帧"了。浏览器需要先用 HTTP/2协议连接服务器，然后服务器可以在启动 HTTP/2连接后发送一个"**Alt-Svc**"帧，包含一个"h3=host:port"的字符串，告诉浏览器在另一个端点上提供等价的HTTP/3 服务。浏览器收到"Alt-Svc"帧，会使用 QUIC异步连接指定的端口，如果连接成功，就会断开 HTTP/2 连接，改用新的 HTTP/3收发数据。
## 小结HTTP/3综合了我们之前讲的所有技术（HTTP/1、SSL/TLS、HTTP/2），包含知识点很多，比如队头阻塞、0-RTT握手、虚拟的"流"、多路复用，算得上是"集大成之作"，需要多下些功夫好好体会。1.  [HTTP/3 基于 QUIC    协议，完全解决了"队头阻塞"问题，弱网环境下的表现会优于    HTTP/2；]{.orange}2.  [QUIC 是一个新的传输层协议，建立在 UDP    之上，实现了可靠传输；]{.orange}3.  [QUIC 内含了 TLS1.3，只能加密通信，支持 0-RTT 快速建连；]{.orange}4.  [QUIC 的连接使用"不透明"的连接 ID，不绑定在"IP 地址 +    端口"上，支持"连接迁移"；]{.orange}5.  [QUIC 的流与 HTTP/2 的流很相似，但分为双向流和单向流；]{.orange}6.  [HTTP/3 没有指定默认端口号，需要用 HTTP/2    的扩展帧"Alt-Svc"来发现。]{.orange}
## 课下作业1.  IP 协议要比 UDP 协议省去 8 个字节的成本，也更通用，QUIC    为什么不构建在 IP 协议之上呢？2.  说一说你理解的 QUIC、HTTP/3 的好处。3.  对比一下 HTTP/3 和 HTTP/2 各自的流、帧，有什么相同点和不同点。欢迎你把自己的学习体会写在留言区，与我和其他同学一起讨论。如果你觉得有所收获，也欢迎把文章分享给你的朋友。![unpreview](Images/c9e03232a22a74971610a4cb8181396e.png){savepage-src="https://static001.geekbang.org/resource/image/58/df/5857f14a3b06b6c0dd38e00b4a6124df.png"}![unpreview](Images/4913a489805db29b38aefa585223c013.png){savepage-src="https://static001.geekbang.org/resource/image/56/63/56d766fc04654a31536f554b8bde7b63.jpg"}
# 33 \| 我应该迁移到HTTP/2吗？这一讲是"飞翔篇"的最后一讲，而 HTTP 的所有知识也差不多快学完了。前面你已经看到了新的 HTTP/2 和 HTTP/3协议，了解了它们的特点和工作原理，如果再联系上前几天"安全篇"的HTTPS，你可能又会发出疑问："刚费了好大的力气升级到 HTTPS，这又出了一个HTTP/2，还有再次升级的必要吗？"与各大浏览器"强推"HTTPS 的待遇不一样，HTTP/2的公布可谓是"波澜不惊"。虽然它是 HTTP 协议的一个重大升级，但Apple、Google 等科技巨头并没有像 HTTPS 那样给予大量资源的支持。直到今天，HTTP/2在互联网上还是处于"不温不火"的状态，虽然已经有了不少的网站改造升级到了HTTP/2，但普及的速度远不及 HTTPS。所以，你有这样的疑问也是很自然的，升级到 HTTP/2究竟能给我们带来多少好处呢？到底"值不值"呢？
## HTTP/2 的优点前面的几讲主要关注了 HTTP/2的内部实现，今天我们就来看看它有哪些优点和缺点。首先要说的是，HTTP/2 最大的一个优点是**完全保持了与 HTTP/1的兼容**，在语义上没有任何变化，之前在 HTTP 上的所有投入都不会浪费。因为兼容 HTTP/1，所以 HTTP/2 也具有 HTTP/1 的所有优点，并且"基本"解决了HTTP/1 的所有缺点，安全与性能兼顾，可以认为是"[更安全的 HTTP、更快的HTTPS]{.orange}"。``{=html}在安全上，HTTP/2 对 HTTPS 在各方面都做了强化。下层的 TLS 至少是1.2，而且只能使用前向安全的密码套件（即ECDHE），这同时也就默认实现了"TLS False Start"，支持 1-RTT握手，所以不需要再加额外的配置就可以自动实现 HTTPS 加速。安全有了保障，再来看 HTTP/2 在性能方面的改进。你应该知道，影响网络速度的两个关键因素是"**带宽**"和"**延迟**"，HTTP/2的头部压缩、多路复用、流优先级、服务器推送等手段其实都是针对这两个要点。所谓的"带宽"就是网络的传输速度。从最早的 56K/s，到如今的100M/s，虽然网速已经是"今非昔比"，比从前快了几十倍、几百倍，但仍然是"稀缺资源"，图片、视频这样的多媒体数据很容易会把带宽用尽。节约带宽的基本手段就是压缩，在 HTTP/1 里只能压缩 body，而 HTTP/2则可以用 HPACK 算法压缩header，这对高流量的网站非常有价值，有数据表明能节省大概 5%\~10%的流量，这是实实在在的"真金白银"。与 HTTP/1"并发多个连接"不同，HTTP/2的"多路复用"特性要求对**一个域名（或者 IP）只用一个 TCP连接**，所有的数据都在这一个连接上传输，这样不仅节约了客户端、服务器和网络的资源，还可以把带宽跑满，让TCP 充分"吃饱"。这是为什么呢？我们来看一下在 HTTP/1里的长连接，虽然是双向通信，但任意一个时间点实际上还是单向的：上行请求时下行空闲，下行响应时上行空闲，再加上"队头阻塞"，实际的带宽打了个"对折"还不止（可参考[第17 讲](https://time.geekbang.org/column/article/104949)）。而在 HTTP/2 里，"多路复用"则让 TCP开足了马力，"全速狂奔"，多个请求响应并发，每时每刻上下行方向上都有流在传输数据，没有空闲的时候，带宽的利用率能够接近100%。所以，HTTP/2 只使用一个连接，就能抵得过 HTTP/1 里的五六个连接。不过流也可能会有依赖关系，可能会存在等待导致的阻塞，这就是"延迟"，所以HTTP/2 的其他特性就派上了用场。"优先级"可以让客户端告诉服务器，哪个文件更重要，更需要优先传输，服务器就可以调高流的优先级，合理地分配有限的带宽资源，让高优先级的HTML、图片更快地到达客户端，尽早加载显示。"服务器推送"也是降低延迟的有效手段，它不需要客户端预先请求，服务器直接就发给客户端，这就省去了客户端解析HTML 再请求的时间。
## HTTP/2 的缺点说了一大堆 HTTP/2 的优点，再来看看它有什么缺点吧。听过上一讲 HTTP/3 的介绍，你就知道 HTTP/2 在 TCP级别还是存在"队头阻塞"的问题。所以，如果网络连接质量差，发生丢包，那么TCP 会等待重传，传输速度就会降低。另外，在移动网络中发生 IP 地址切换的时候，下层的 TCP必须重新建连，要再次"握手"，经历"慢启动"，而且之前连接里积累的 HPACK字典也都消失了，必须重头开始计算，导致带宽浪费和时延。刚才也说了，HTTP/2对一个域名只开一个连接，所以一旦这个连接出问题，那么整个网站的体验也就变差了。而这些情况下 HTTP/1反而不会受到影响，因为它"本来就慢"，而且还会对一个域名开 6\~8个连接，顶多其中的一两个连接会"更慢"，其他的连接不会受到影响。