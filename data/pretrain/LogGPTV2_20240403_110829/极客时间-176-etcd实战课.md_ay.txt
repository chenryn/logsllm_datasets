# 21 \| 分布式锁：为什么基于etcd实现分布式锁比Redis锁更安全？你好，我是唐聪。在软件开发过程中，我们经常会遇到各种场景要求对共享资源进行互斥操作，否则整个系统的数据一致性就会出现问题。典型场景如商品库存操作、Kubernertes调度器为 Pod 分配运行的 Node。那要如何实现对共享资源进行互斥操作呢？锁就是其中一个非常通用的解决方案。在单节点多线程环境，你使用本地的互斥锁就可以完成资源的互斥操作。然而单节点存在单点故障，为了保证服务高可用，你需要多节点部署。在多节点部署的分布式架构中，你就需要使用分布式锁来解决资源互斥操作了。但是为什么有的业务使用了分布式锁还会出现各种严重超卖事故呢？分布式锁的实现和使用过程需要注意什么？今天，我就和你聊聊分布式锁背后的故事，我将通过一个茅台超卖的案例，为你介绍基于Redis实现的分布锁优缺点，引出分布式锁的核心要素，对比分布式锁的几种业界典型实现方案，深入剖析etcd 分布式锁的实现。希望通过这节课，让你了解 etcd分布式锁的应用场景、核心原理，在业务开发过程中，优雅、合理的使用分布式锁去解决各类资源互斥、并发操作问题。从茅台超卖案例看分布式锁要素首先我们从去年一个因 Redis分布式锁实现问题导致茅台超卖案例slate-object="inline"说起，在这个网友分享的真实案例中，因茅台的稀缺性，事件最终定级为P0 级生产事故，后果影响严重。那么它是如何导致超卖的呢？首先和你简单介绍下此案例中的 Redis 简易分布式锁实现方案，它使用了Redis SET 命令来实现。    SET key value [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|KEEPTTL] [NX|XX    [GET简单给你介绍下 SET命令重点参数含义：1.  `EX`    设置过期时间，单位秒；        2.  `NX` 当 key 不存在的时候，才设置    key；    3.  `XX` 当 key 存在的时候，才设置    key。    此业务就是基于 Set key value EX 10 NX 命令来实现的分布式锁，并通过JAVA 的 try-finally 语句，执行 Del key语句来释放锁，简易流程如下：    
# 对资源key加锁，key不存在时创建，并且设置，10秒自动过期    SET key value EX 10 NX    业务逻辑流程1，校验用户身份    业务逻辑流程2，查询并校验库存(get and compare)    业务逻辑流程3，库存>0，扣减库存(Decr stock)，生成秒杀茅台订单    