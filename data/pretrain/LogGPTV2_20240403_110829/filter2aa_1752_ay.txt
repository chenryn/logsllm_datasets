。调 alloca() 的能 alloca() 的
内存然何工作以。
 malloc() 实的相同的
int open_sysconf (const char *file, int flags,
int mode)
{
const char *etc = SYSCONF_DIR; /* ”/etc/” */
char *name;
int fd;
name = malloc (strlen (etc) + strlen (file) +
1);
if (!name) {
perror (”malloc”);
return -1;
}
strcpy (name, etc);
strcat (name, file);
fd = open (name, flags, mode);
free (name);
return fd;
}
的能 alloca() 的内存作调的
的内存存的。
的
– 281 –
 8 
内存理
/* DO NOT DO THIS! */
ret = foo (x, alloca (10));
alloca() 的。或出
的。小小的 alloca() 出
出程。 alloca() 存。出
们对 alloca() 的。
以性 alloca()。然 Linux
上 alloca() 们的工。的异
出（ alloca() 进内存单)
malloc() 的性能。对 Linux 小的内存 alloca() 能
的性能。
8.7.1 栈中的复制串
alloca() 的时。
/* we want to duplicate ’song’ */
char *dup;
dup = alloca (strlen (song) + 1);
strcpy (dup, song);
/* manipulate ’dup’... */
return; /* ’dup’ is automatically freed */
以及 alloca() 实的效 Linux 提
strdup() 将给的
#define _GNU_SOURCE
#include 
char * strdupa (const char *s);
char * strndupa (const char *s, size_t n);
调 strdupa( )  s 的。 strndupa() 将 s 的 n 。
 s  n s  n 然自上空。
 alloca() 的。调时的自。 POSIX 
 alloca( ) strdupa( )或 strndupa( ) 们的操作的
– 282 –
 8 
内存理
。性。然 Linux 上
alloca() 以及的的以单的
内存方性能上的提单的
内存的方式。
8.7.2 变长数组
C99 进（VLAs的时的
的时。。 GNUC  C99 将
对的的。 VLAs  alloca() 相
的方存的。的方的
for (i = 0; i 
void * memset (void *s, int c, size_t n);
调 memset() 将 s 的 n 设 c s。
将内存零
/* zero out [s,s+256) */
memset (s, ’\0’, 256);
bzero()  BSD 的相同能的。新的
 memset() Linux 出对的性的提
 bzero()
#include 
void bzero (void *s, size_t n);
的调能 memset() 的子
bzero (s, 256);
 bzero()（ b 的) 文件  
。
以 calloc() 内存 memset()
。 malloc() 内存上 memset() 进
– 286 –
 8 
内存理
零。然能的将调
零的空间 calloc() 更。处
调 calloc() 内存零的内存然工
的将零效。
8.9.2 字节比较
 strcmp() 相 memcmp() 内存相
#include 
int memcmp (const void *s1, const void *s2,
size_t n);
调 memcmp()  s1  s2 的 n 内存相同 0
 s1 小 s2 小 0 的 0 的。
BSD 同提自能的
#include 
int bcmp (const void *s1, const void *s2, size_t
n);
调 bcmp()  s1  s2 的 n 内存 0
 0 。的存（的对
memcmp() 或 bcmp() 相的。同的
实能的内相。的
的
/* are two dinghies identical? (BROKEN) */
int compare_dinghies (struct dinghy *a, struct
dinghy *b)
{
return memcmp (a, b, sizeof (struct dinghy));
}
程们能的
。方实的工作然的 memcmp()
– 287 –
 8 
内存理
/* are two dinghies identical? */
int compare_dinghies (struct dinghy *a, struct
dinghy *b)
{
int ret;
if (a->nr_oars nr_oars)
return -1;
if (a->nr_oars > b->nr_oars)
return 1;
ret = strcmp (a->boat_name, b->boat_name);
if (ret)
return ret;
/* and so on, for each member... */
}
8.9.3 字节移动
memmove()  src 的 n  dst dst
#include 
void * memmove (void *dst, const void *src,
size_t n);
同 BSD 提的实相同的能
#include 
void bcopy (const void *src, void *dst, size_t n);
出的的相同们的的
bcopy() 的的。
bcopy()  memmove() 以处理内存（ dst 的
 src 。们内存给的内上或
。然程。以 C 
内存的 memmove() 。能
– 288 –
 8 
内存理
#include 
void * memcpy (void *dst, const void *src, size_t
n);
 dst  src 间能   memmove() 。
的的。的 memccpy()
#include 
void * memccpy (void *dst, const void *src, int
c, size_t n);
memccpy()  memcpy()  c  src 的 n 
时。 dst  c 的或 c 时
 NULL。
我们以 mempcpy() 的内存
#define _GNU_SOURCE
#include 
void * mempcpy (void *dst, const void *src,
size_t n);
 mempcpy()  memcpy()  memccpy() 的
的内存的的的。内存的
时的。的性能提的
 dst+n 。 GNU 的。
8.9.4 字节搜索
 memchr()  memrchr() 以内存给的
#include 
void * memchr (const void *s, int c, size_t n);
 memchr()  s 的的 n  c c 将 unsigned
char
#define _GNU_SOURCE
– 289 –
 8 
内存理
#include 
void * memrchr (const void *s, int c, size_t n);
 c 的的 c  NULL。
memrchr()  memchr()  s 的内存 n 
。 memchr() 同 memrchr()  GNU 的扩展 C 的
。对更的的 memmem() 以内
存的
#define _GNU_SOURCE
#include 
void * memmem (const void *haystack,
size_t haystacklen,
const void *needle,
size_t needlelen);
memmem()  haystacklen 的内存 haystack 
 needlelen 的 needle 的子的。 haystack 能
 needle NULL。同 GNU 的扩展。
8.9.5 字节加密
Linux 的 C 提进单的
#define _GNU_SOURCE
#include 
void * memfrob (void *s, size_t n);
memfrob() 将 s 的的 n  42 进异或操作
对进。 s。
对相同的调 memfrob() 以将。程对
 secret 进实性的操作
memfrob (memfrob (secret, len), len);
时绝对的（更的的
对的单处理。 GNU 。
– 290 –
 8 
内存理
8.10 内存锁定
Linux 实页调页调时将页进
时出。进程的空间实的
理内存小的同时上的空间提
理内存的
对进程的程（
内页调的。然程能
的页调
性（Determinism 时间的程自页的调
。内存操作页 - 的
操作 - 程能超出的时间。
能的页内存进
程能内存操作页提
的的程提效能。
性（Security
内存能页调
以的方式存上。
的以的方式存上的
内存的备能存文
件。性的能
。的程以将
理内存上。
然内的能对的的。的
性性能提的页内存的
页能出内存。我们相内的设将的页
出能的页。的的
能将的页出。
8.10.1 锁定部分地址空间
POSIX1003.1b-1993 将或更的页理内
存们。给的间
– 291 –
 8 
内存理
#include 
int mlock (const void *addr, size_t len);
调 mlock() 将 addr  len 的内存。的
 0时 -1设 errno。
调将 [addr,addr+len) 的理内存页。调
的理页将。 POSIX 
 addr 页对。 Linux 真的时
的将 addr 调的页。对的程
 addr 页对的。
的 errno 
EINVAL
 len 。
ENOMEM  RLIMIT MEMLOCK 的页 (
)。
EPERM
RLIMIT MEMLOCK  0进程 CAP IPC LOCK 。（同
。
 fork() 的子进程进程处
的内存。然 Linux 对空间写时子
进程的页内存子进程对们写操作。
子设程内存的
。进程以的页
int ret;
/* lock ’secret’ in memory */
ret = mlock (secret, strlen (secret));
if (ret)
perror (”mlock”);
8.10.2 锁定全部地址空间
进程理内存的空间 mlock() 
。 POSIX  mlockall() 满实时的
– 292 –
 8 
内存理
#include 
int mlockall (int flags);
mlockall() 进程空间理内存的页。
flags 的或操作以
MCL CURRENT 设 mlockall() 将映射的页（
段映射文件) 进程空间。
MCL FUTURE
设 mlockall() 将映射的页
进程空间。
程同时设。时 0时
 -1设 errno 
EINVAL
 len 。
ENOMEM      的 页    RLIMIT MEMLOCK   的   (  
)。
EPERM
RLIMIT MEMLOCK  0进程 CAP IPC LOCK 。（同
。
8.10.3 内存解锁
POSIX 提将页内存内将
页出
#include 
int munlock (const void *addr, size_t len);
int munlockall (void);
调 munlock()  addr  len 的内存的页。
 mlock() 的效。 munlockall()  mlockall() 的效。时
 0时 -1设 errno
EINVAL
 len （对 munlock()。
ENOMEM 的页的。
EPERM
RLIMIT MEMLOCK  0进程 CAP IPC LOCK 。（同
。
– 293 –
 8 