如果登录成功，会返回200，否则返回401表示认证失败。
我们推荐使用第二种方法，因为它比较直观。事实上，第二种方法和第一种方法本质上一
样。--user字段最终也会被翻译成Authorization字段，读者可以通过curl的-v参数查看具体的
交互过程。
3. 新建仓库
用户可以通过API的形式在Docker Hub上创建镜像仓库，此时需要提供命名空间和仓库名。
一般情况下，命名空间为用户名。
14.4 平台API 171
方法：PUT /v1/repositories/(namespace)/(repo_name)/ 1
用例请求：
2
PUT /v1/repositories/foo/bar/ HTTP/1.1
Host: index.docker.io
Accept: application/json 3
Content-Type: application/json
Authorization: Basic akmklmasadalkm==
X-Docker-Token: true 4
[{"id": "9e89cc6f0bc3c38722009fe6857087b486531f9a779a0c17e3ed29dae8f12c4f"}]
用例返回：
5
HTTP/1.1 200
Vary: Accept
6
Content-Type: application/json
WWW-Authenticate: Token signature=123abc,repository="foo/bar",access=write
X-Docker-Token: signature=123abc,repository="foo/bar",access=write
7
X-Docker-Endpoints: registry-1.docker.io [, registry-2.docker.io]
""
9
参数：（无）
状态码
8
 200：创建成功。
 400：错误，通常为JSON内部格式或者参数错误。 10
 401：认证失败。
 403：账户尚未激活。 10
curl操作：
11
$ curl -v -L -X PUT --user helloworld:123456 -H "Accept: application/json" -H "Content-Type:
application/json" --post301 https://index.docker.io/v1/repositories/helloworld/foo2 -d '[{"id":
"1cb837a9709a2fff9591c4ca4ff6f336b0c98308ac1bbb493179888787a6c691"}]' 13
JSON里面添加的是加入该仓库的镜像的id列表。
14
4. 上传镜像
接下来，我们需要说明如何把一个镜像上传到Docker Hub中。这分为两部分，首先需要将本地
15
的镜像标记成Docker Hub响应库里的镜像，然后通过push操作把镜像从本地上传到Docker Hub中。
本地现有镜像如下： 16
micall@micall-ThinkPad:~$ docker images
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE 17
dockerfile/redis latest 1cb837a9709a 2 weeks ago
progrium/ambassadord latest ebc261f84aa4 3 weeks ago 224.4 MB
ubuntu latest 86ce37374f40 7 weeks ago 192.7 MB 18
minimicall/node_web 0.1 730770dff17f 7 weeks ago 268.7 MB
172 第14章 Docker API
我们要把dockerfile/redis上传到helloworld用户的foo仓库，所以需要先把该镜像签入
helloworld/foo。具体操作为：
curl -v -X POST http://localhost:2376/images/dockerfile/redis/tag?repo=minimicall/foo&tag=lat est
标记完之后，我们可以看到minimicall/foo镜像，它和dockerfile/redis一模一样，具体为：
micall@micall-ThinkPad:~$ docker images
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE
dockerfile/redis latest 1cb837a9709a 2 weeks ago 419.1 MB
minimicall/foo latest 1cb837a9709a 2 weeks ago 419.1 MB
好了，终于到了上传的一刻！其操作为：
~$ XAR=`echo '{"username":"minimicall","password":"110110","email":"PI:EMAIL",
"serveraddress":"index.docker.io"}' | base64 --wrap=0`
$echo $XAR
eyJ1c2VybmFtZSI6Im1pbmltaWNhbGwiLCJwYXNzd29yZCI6IjExMDExMCIsImVtYWlsIjoiNDcwOTEwMzU3QHFxLmNvbSIsIn
NlcnZlcmFkZHJlc3MiOiJpbmRleC5kb2NrZXIuaW8ifQo=
$ curl -v -X POST -L --post301 -H "X-Registry-Auth:$XAR" http://localhost:2376/images/minimicall
/node_web/push
在上述操作中，我们首先通过用户名、密码、邮箱和服务器地址的JSON格式来生成Base64
编码，然后赋给变量XAR。上传操作是images下的push操作，它需要加入HTTP头X-Registry-Auth
字段，其值为XAR的值。上传过程需要等待，根据镜像的大小和网络状况决定。至此，我们成功
地使用API将镜像上传到Docker Hub中。
5. 下载镜像
下载镜像是创建镜像的一种方式。
方法：POST /images/create
用例请求：POST /images/create?fromImage=base HTTP/1.1
用例返回：
HTTP/1.1 200 OK
Content-Type: application/json
{"status":"Pulling..."}
{"status":"Pulling", "progress":"1 B/ 100 B", "progressDetail":{"current":1, "total":100}}
{"error":"Invalid..."}
...
参数
 fromImage：基础镜像。
 fromSrc：导入源，一个可以获得镜像的URL地址。
 repo：仓库。
 tag：标签。
14.5 API实战：docker-py库编程 173
 registry：拉取镜像的注册服务器。 1
curl操作：
2
$ curl -v -X POST http://localhost:2376/images/create?fromImage=minimicall/foo&tag=latest
[1] 22386
micall@micall-ThinkPad:~$ * Hostname was NOT found in DNS cache 3
* Trying ::1...
* Connected to localhost (::1) port 2376 (#0)
> POST /images/create?fromImage=minimicall/foo HTTP/1.1 4
> User-Agent: curl/7.35.0
> Host: localhost:2376
> Accept: */*
5
>
>> import docker
>>>
如果import docker没有提示出错，就说明docker-py已经正确安装了。
14.5.2 docker-py库编程
开发环境已经搭建完毕，接下来进入编程环节。
1. 连接Docker后台
在14.2节中，我们已经知道连接后台有两种方式，一种是tcp，一种是unix socket方式。要管
理Docker，必然先要连接到Docker后台。docker-py库支持这两种方式连接Docker后台，下面我们
通过一个例子来说明其用法。首先，用Vim创建一个doc_info.py文件，其内容为：
import docker
cli = docker.Client(base_url='tcp://127.0.0.1:2376')
#cli = docker.Client(base_url='unix://var/run/docker.sock')
print cli.info()
第一行用import指令引入了docker包，然后对Docker后台进行连接。读者可以选取两种方式
中的一种，tcp方式可以连接其他主机的Docker后台。Client函数的参数如下所示。
 base_url：指定要连接到的Docker后台，包含IP地址和监听的端口。
 version：API的版本号。
 timeout：超时时间。
 tls：tls支持。
这里我们只设置了base_url参数，其他的都采用默认参数。在上述代码中，读者可以将注释
部分打开，对比两种不同的连接方式。
14.5 API实战：docker-py库编程 175
最后，使用info函数输出Docker的相关信息。保存该文件，然后在命令行下运行python
1
dock_info.py，具体如下：
2
$ python docker_info.py
{u'NGoroutines': 77, u'DockerRootDir': u'/var/lib/docker', u'DriverStatus': [[u'Root Dir', u'/var/
lib/docker/aufs'], [u'Dirs', u'387']], u'OperatingSystem': u'Ubuntu 14.04 LTS', u'Containers':
64, u'MemTotal': 8181542912, u'Driver': u'aufs', u'IndexServerAddress': 3
u'https://index.docker.io/v1/', u'InitPath': u'/usr/bin/docker', u'ExecutionDriver':
u'native-0.2', u'Name': u'micall-ThinkPad', u'NCPU': 4, u'Debug': 0, u'ID':
u'3MDX:LBWZ:TA5F:KR2T:LI44:34VF:PDLQ:5ZDF:3BOQ:PEPS:OMIP:DTWU', u'IPv4Forwarding': 1, 4
u'KernelVersion': u'3.13.0-24-generic', u'NFd': 68, u'InitSha1': u'', u'Labels': None,
u'MemoryLimit':1, u'SwapLimit': 0, u'Images': 255, u'NEventsListener': 2}
5
可以看到，所获取的信息和使用docker info命令获得的信息一致。
2. 查看本地镜像 6
接下来，我们可以查看本地所有的镜像。创建文件doc_images.py，其内容为：
7
import docker
cli = docker.Client('tcp://127.0.0.1:2376')
print cli.images() 9
运行python doc_images.py命令：
8
# python doc_images.py
[{u'Created': 1422350386, u'VirtualSize': 889663485, u'ParentId':
u'1d1ee8ba08f761fddc3c40b8baad7c3958b34f3a35bb900516763adb5a5cd1b7', u'RepoTags': 10
[u'minimicall/centos-mysql:v1'], u'Id':
u'a34a95bedc997f382b2662cf77f230448f43599fd09b9c7fd14bd1b84b2c36f5', u'Size': 0}, {u'Created':
1421911413, u'VirtualSize': 744788608, u'ParentId': 10
u'5e927153cfba10fadef255b55c92dd623f43dbd33444c0f
...
11
3. 构建容器
我们也可以直接在Python命令环境中编程，此时直接在命令行下敲入python即可。下面我们
13
使用Dockerfile构建一个容器：
>>> from io import BytesIO 14
>>> from docker import Client
>>> dockerfile = '''
... #Shared Volume 15
... FROM busybox:buildroot-2014.02
... MAINTAINER minimicall, PI:EMAIL
... VOLUME /data 16
... CMD ["/bin/sh"]
... '''
>>> f = BytesIO(dockerfile.encode('utf-8')) 17
>>> cli = Client(base_url='tcp://127.0.0.1:2376')
>>> response = [line for line in cli.build(fileobj=f,rm=True,tag='minimicall/volume')]
>>> 18
>>> response
176 第14章 Docker API
['{"stream":"Step 0 : FROM busybox:buildroot-2014.02\\n"}\r\n', '{"status":"The image you are pulling
has been verified","id":"busybox:buildroot-2014.02"}\r\n', '{"status":"Pulling fs
layer","progressDetail":{},"id":"ea13149945cb"}'
可以看到，我们基于busybox构建了一个名为minimicall/volume的镜像。创建完之后，可以
查看是否存在该容器：
>>> cli.images()
[{u'Created': 1422772698, u'VirtualSize': 2433303, u'ParentId':
u'ff311d5495905d69b5cd603825fc4cd76078ed9a6fe064edc84f4247950c74c8', u'RepoTags':
[u'minimicall/volume:latest'], u'Id':
u'99dbb68a761cda72afb4e469c6c1bec6dabf4a88adde2fd7e9b236abdcd900b6', u'Size': 0},
可见，minimicall/volume:latest已经成功创建了。
4. 启动容器
有了镜像，接下来以该镜像为基础启动容器：
>>> container = cli.create_container(image='busybox:latest',command='/bin/sleep 30')
>>> print container
{u'Id': u'4d21ff66e440f989f0a24c6c29990e121000aa198385326a768c97a977f56650', u'Warnings': None}
>>>
docker-py的API函数都是根据Docker API编写的，所以这里就不再列举更多的例子了。更多
关于docker-py的API编程的内容，可以访问其官网：https://github.com/docker/docker-py。
15.2 Fig安装 177
1