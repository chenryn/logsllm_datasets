### 2. 栈溢出（Stack Overflow）现在你知道了调用栈是一种用来管理执行上下文的数据结构，符合后进先出的规则。不过还有一点你要注意，**调用栈是有大小的**，当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，我们把这种错误叫做**栈溢出**。特别是在你写递归代码的时候，就很容易出现栈溢出的情况。比如下面这段代码：    function division(a,b){    return division(a,b)}console.log(division(1,2))当执行时，就会抛出栈溢出错误，如下图：![](Images/ed33b1c26b8451dffc0da39506032c2d.png){savepage-src="https://static001.geekbang.org/resource/image/b4/4d/b4f7196077d9ef4eac1ca6a279f2054d.png"}```{=html}```栈溢出错误]{.reference}```{=html}```从上图你可以看到，抛出的错误信息为：超过了最大栈调用大小（Maximum callstack size exceeded）。那为什么会出现这个问题呢？这是因为当 JavaScript引擎开始执行这段代码时，它首先调用函数division，并创建执行上下文，压入栈中；然而，这个函数是**递归的，并且没有任何终止条件**，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。理解了栈溢出原因后，你就可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式，或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。
## 总结好了，今天的内容就讲到这里，下面来总结下今天的内容。-   每调用一个函数，JavaScript    引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后    JavaScript 引擎开始执行函数代码。-   如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B    函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。-   当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。-   当分配的调用栈空间被占满时，会引发"堆栈溢出"问题。栈是一种非常重要的数据结构，不光应用在 JavaScript语言中，其他的编程语言，如 C/C++、Java、Python等语言，在执行过程中也都使用了栈来管理函数之间的调用关系。所以栈是非常基础且重要的知识点，你必须得掌握。
## 思考时间最后，我给你留个思考题，你可以看下面这段代码：    function runStack (n) {  if (n === 0) return 100;  return runStack( n- 2);}runStack(50000)这是一段递归代码，可以通过传入参数 n，让代码递归执行 n次，也就意味着调用栈的深度能达到 n，当输入一个较大的数时，比如50000，就会出现栈溢出的问题，那么你能优化下这段代码，以解决栈溢出的问题吗？欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。![](Images/7e91bd5c116048de87e68468f727fc3c.png){savepage-src="https://static001.geekbang.org/resource/image/3f/cb/3f4d5bec2d5c89600b4628581144d8cb.jpg"}
# 09 \| 块级作用域：var缺陷以及为什么要引入let和const？在前面[《07 \| 变量提升：JavaScript代码是按顺序执行的吗？》](https://time.geekbang.org/column/article/119046)这篇文章中，我们已经讲解了JavaScript 中变量提升的相关内容，**正是由于 JavaScript存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript的一个重要设计缺陷**。虽然 ECMAScript6（以下简称 ES6）已经通过引入块级作用域并配合 let、const关键字，来避开了这种设计缺陷，但是由于 JavaScript需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。这也加大了你理解概念的难度，因为既要理解新的机制，又要理解变量提升这套机制，关键这两套机制还是同时运行在"一套"系统中的。但如果抛开 JavaScript的底层去理解这些，那么你大概率会很难深入理解其概念。俗话说，"断病要断因，治病要治根"，所以为了便于你更好地理解和学习，今天我们这篇文章会先"**探病因**"------分析为什么在JavaScript中会存在变量提升，以及变量提升所带来的问题；然后再来"**开药方**"------介绍如何通过**块级作用域并配合let 和 const 关键字**来修复这种缺陷。
## 作用域（scope）为什么 JavaScript中会存在变量提升这个特性，而其他语言似乎都没有这个特性呢？要讲清楚这个问题，我们就得先从作用域讲起。``{=html}**作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。**在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。-   **全局作用域**中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。-   **函数作用域**就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。在 ES6 之前，JavaScript只支持这两种作用域，相较而言，其他语言则都普遍支持**块级作用域**。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。为了更好地理解块级作用域，你可以参考下面的一些示例代码：    //if 块if(1){} //while 块while(1){} // 函数块function foo(){ //for 循环块for(let i = 0; i```开始执行 showName 函数时的调用栈]{.reference}```{=html}```showName 函数的执行上下文创建后，JavaScript 引擎便开始执行 showName函数内部的代码了。首先执行的是：    console.log(myname);执行这段代码需要使用变量myname，结合上面的调用栈状态图，你可以看到这里有两个 myname变量：一个在全局执行上下文中，其值是"极客时间"；另外一个在 showName函数的执行上下文中，其值是 undefined。那么到底该使用哪个呢？相信做过 JavaScript开发的同学都能轻松回答出来答案："当然是**先使用函数执行上下文里面的变量**啦！"的确是这样，这是因为在函数执行过程中，JavaScript会优先从当前的执行上下文中查找变量，由于变量提升，当前的执行上下文中就包含了变量myname，而值是 undefined，所以获取到的 myname 的值就是 undefined。这输出的结果和其他大部分支持块级作用域的语言都不一样，比如上面 C语言输出的就是全局变量，所以这会很容易造成误解，特别是在你会一些其他语言的基础之上，再来学习JavaScript，你会觉得这种结果很不自然。
### 2. 本应销毁的变量没有被销毁接下来我们再来看下面这段让人误解更大的代码：    function foo(){  for (var i = 0; i ```varTest 函数的执行上下文]{.reference}```{=html}```从执行上下文的变量环境中可以看出，最终只生成了一个变量 x，函数体内所有对x 的赋值操作都会直接改变变量环境中的 x 值。所以上述代码最后通过 console.log(x) 输出的是2，而对于相同逻辑的代码，其他语言最后一步输出的值应该是 1，因为在 if块里面的声明不应该影响到块外面的变量。既然支持块级作用域和不支持块级作用域的代码执行逻辑是不一样的，那么接下来我们就来改造上面的代码，让其支持块级作用域。这个改造过程其实很简单，只需要把 var 关键字替换为 let关键字，改造后的代码如下：    function letTest() {  let x = 1;  if (true) {    let x = 2;  // 不同的变量    console.log(x);  // 2  }  console.log(x);  // 1}执行这段代码，其输出结果就和我们的预期是一致的。这是因为 let关键字是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把 if块中通过 let 声明的变量存放到变量环境中，这也就意味着在 if 块通过 let声明的关键字，并不会提升到全函数可见。所以在 if 块之内打印出来的值是2，跳出语块之后，打印出来的值就是 1了。这种就非常**符合我们的编程习惯了：作用块内声明的变量不影响块外面的变量**。
## JavaScript 是如何支持块级作用域的现在你知道了 ES 可以通过使用 let 或者 const关键字来实现块级作用域，不过你是否有过这样的疑问："在同一段代码中，ES6是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？"那么接下来，我们就要**站在执行上下文的角度**来揭开答案。你已经知道 JavaScript 引擎是通过变量环境实现函数级作用域的，那么 ES6又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？你可以先看下面这段代码：    function foo(){    var a = 1    let b = 2    {      let b = 3      var c = 4      let d = 5      console.log(a)      console.log(b)    }    console.log(b)     console.log(c)    console.log(d)}   foo()当执行上面这段代码的时候，JavaScript引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，关于如何创建执行上下文我们在前面的文章中已经分析过了，但是现在的情况有点不一样，我们引入了let 关键字，let 关键字会创建块级作用域，那么 let关键字是如何影响执行上下文的呢？接下来我们就来一步步分析上面这段代码的执行流程。**第一步是编译并创建执行上下文**，下面是我画出来的执行上下文示意图，你可以参考下：![](Images/8ca7cf050ae80327d157737763af545b.png){savepage-src="https://static001.geekbang.org/resource/image/f9/67/f9f67f2f53437218baef9dc724bd4c67.png"}```{=html}```刚执行时 foo 函数的执行上下文]{.reference}```{=html}```通过上图，我们可以得出以下结论：-   函数内部通过 var    声明的变量，在编译阶段全都被存放到**变量环境**里面了。-   通过 let 声明的变量，在编译阶段会被存放到**词法环境（Lexical    Environment）**中。-   在函数的作用域内部，通过 let 声明的变量并没有被存放到词法环境中。接下来，**第二步继续执行代码**，当执行到代码块里面时，变量环境中 a的值已经被设置成了 1，词法环境中 b 的值已经被设置成了2，这时候函数的执行上下文就如下图所示：![](Images/2e46aec9f06f26720ddc28dd07a55ae7.png){savepage-src="https://static001.geekbang.org/resource/image/7e/fa/7e0f7bc362e0dea21d27dc5fb08d06fa.png"}```{=html}```执行 foo 函数内部作用域块时的执行上下文]{.reference}```{=html}```从图中可以看出，当进入函数的作用域块时，作用域块中通过 let声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量b，在该作用域块内部也声明了变量b，当执行到作用域内部时，它们都是独立的存在。其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过let 或者 const 声明的变量。再接下来，当执行到作用域块中的`console.log(a)`这行代码时，就需要在词法环境和变量环境中查找变量a的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。这样一个变量查找过程就完成了，你可以参考下图：![](Images/6890cf46a9dfa6e001bf1dc1f1baa57b.png){savepage-src="https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png"}```{=html}```变量查找过程]{.reference}```{=html}```从上图你可以清晰地看出变量查找流程，不过要完整理解查找变量或者查找函数的流程，就涉及到作用域链了，这个我们会在下篇文章中做详细介绍。当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：![](Images/f2357a321ae958f33c949db0b505dfed.png){savepage-src="https://static001.geekbang.org/resource/image/d4/28/d4f99640d62feba4202aa072f6369d28.png"}```{=html}```作用域执行完成示意图]{.reference}```{=html}```通过上面的分析，想必你已经理解了词法环境的结构和工作机制，块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript引擎也就同时支持了变量提升和块级作用域了。