the layout information in the protected storage of the
processor (see Section 3.1 and Figure 3);
• memory access control is enabled as discussed
above; and
• the module key KN,SP,SM is created – using the text
section and layout of the actually loaded module –
and stored in the protected storage.
This explains why we do not need to trust the operating
system that loads the module in memory: if the content of
the text section, or the layout information would be mod-
iﬁed before execution of the protect instruction, then
the key generated for the module would be different and
subsequent attestations or authentications performed by
the module would fail. Once the protect instruction has
succeeded, the hardware-implemented memory access
control scheme ensures that software on the node can no
longer tamper with SM.
The only way to lift the memory access control is by
calling the processor instruction:
unprotect
The effect of this instruction is to lift the memory protec-
tion of the module from which the unprotect instruction
is called. A module should only call unprotect after it
has cleared the protected data section.
Finally, it remains to decide how to handle memory
access violations. We opt for the simple design of reset-
ting the processor and clearing memory on every reset.
This has the advantage of clearly being secure for the
security properties we aim for. However an important
disadvantage is that it may have a negative impact on
availability of the node: a bug in the software may cause
USENIX Association  
22nd USENIX Security Symposium  485
the node to reset and clear its memory. An interesting
avenue for future work is to come up with strategies to
handle memory access violations in less severe ways. In-
valid reads could return some default value as in secure
multi-execution [10]. Invalid writes or jumps could be
dropped or modiﬁed to actions that are allowed as in
edit-automata [35]. For instance, an invalid memory read
might just return zero, and an invalid jump might be redi-
rected to an exception handler.
3.4 Remote attestation and secure commu-
nication
The module key KN,SP,SM is managed by the hardware of
the node, and it can only be used by software in two ways.
The ﬁrst way is by means of the following processor
instruction (we discuss the second way in Section 3.5):
MAC-seal start address, length, result address
This instruction can only be called from within the text
section of a protected module, and the effect is that the
processor will compute the MAC of the data in memory
starting at start address and up to start address + length
using the module key of the module performing the in-
struction. The resulting MAC value is written to result
address.
Modules can use this processor instruction to protect
the integrity of data they send to their provider. The
data plus the corresponding MAC can be sent using the
untrusted operating system over an untrusted network. If
the MAC veriﬁes correctly (using KN,SP,SM) upon receipt
by the provider SP, he can be sure that this data indeed
comes from SM running on N on behalf of SP as the
node’s hardware makes sure only this speciﬁc module can
compute MACs with the module key KN,SP,SM.
To implement remote attestation, we only need to add
a freshness guarantee (i.e. protect against replay attacks).
Provider SP sends a fresh nonce No to the node N, and
the module SM returns the MAC of this nonce using the
key KN,SP,SM, computed using the MAC-seal instruction.
This gives the SP assurance that the correct module is
running on that node at this point in time.
Building on this scheme, we can also implement secure
communication. Whenever SP wants to receive data from
SM on N, it sends a request to the node containing a nonce
No and possibly some input data I that is to be provided
to SM. This request is received by untrusted code on the
node which passes No and I as arguments to the function
of SM to be called. When SM has calculated the output
O, it asks the processor to calculate a MAC of No||I||O
using the MAC-seal instruction. This MAC is then sent
along with O to SP. By verifying the MAC with its own
copy of the module key, the provider has strong assurance
that O has been produced by SM on node N given input I.
3.5 Secure linking and local communica-
tion
In this section, we discuss how we assure the secure link-
ing property mentioned in Section 2.3. More speciﬁcally,
we consider the situation where a module SM1 wants to
call another module SM2 and wants to be ensured that
(1) the integrity of SM2 has not been compromised, and
(2) SM2 is correctly protected by the processor. The sec-
ond point is important, and is the reason why SM1 can
not just verify the integrity of the text section of SM2
by itself. SM1 will need help from the processor to give
assurance that SM2 is loaded with the expected layout and
that protection for SM2 is enabled.
In our design, if module SM1 wants to link securely
to SM2, SM1 should be deployed with a MAC of SM2
created with the module key KN,SP,SM1. The processor
provides a special instruction to check the existence and
integrity of a module at a speciﬁed address:
MAC-verify address, expected MAC.
This instruction will:
• verify that a module is loaded (with protection en-
abled) at the provided address;
• compute the MAC of the identity of that module
using the module key of the module calling this in-
struction;
• compare the resulting MAC with the expected MAC
parameter of the instruction; and
• if the MACs were equal, return the module’s ID (to
be explained below), otherwise return zero.
This is the second (and ﬁnal) way in which a module
can use its module key (next to the MAC-seal instruction
discussed in Section 3.4).
Using this processor instruction, a module can securely
check for the presence of another expected module, and
can then call that other module.
Since this authentication process is relatively expen-
sive (it requires the computation of a MAC), our design
also includes a more efﬁcient mechanism for repeated
authentication. The processor will assign sequential IDs6
to modules that it loads, and will ensure that – within
one boot cycle – it never reuses these IDs. A processor
instruction:
get-id address
6To avoid confusion between the two different identity concepts used
in this text, we will refer to the hardware-assigned number as ID while
the text section and layout of a module is referred to as identity.
486  22nd USENIX Security Symposium 
USENIX Association
Node
SM1
SP1
S
SMS
...
...
IP
SMn
SPn
Figure 4: Setup of the sensor node example discussed in
Section 3.6. Sancus ensures only module SMS is allowed
to directly communicate with the sensor S. Other modules
securely link to SMS to receive sensor data in a trusted
way.
checks that a protected module is present at address and
returns the ID of the module. Once a module has checked
using the initial authentication method that the module at a
given address is the expected module, it can remember the
ID of that module, and then for subsequent authentications
it sufﬁces to check that the same module is still loaded at
that address using the get-id instruction.
3.6 An end-to-end example
To make the discussion in the previous sections more
concrete, this section gives a small example of how our
design may be applied in the area of sensor networks.
Figure 4 shows our example setup. It contains a single
node to which a sensor S is attached; communication with
S is done through memory-mapped I/O. The owner of
the sensor network, IP, has deployed a special module on
the processor, SMS, that is in charge of communicating
with S. By ensuring that the protected data section of SMS
contains the memory-mapped I/O region of S, IP ensures
that no software outside of SMS is allowed to conﬁgure
or communicate directly with S; all requests to S need to
go through SMS.
Figure 4 also shows a number of software providers
(SP1, . . . ,SP n) who have each deployed a module
(SM1, . . . ,SM n). In the remainder of this section, we walk
the reader through the life cycle of a module in this exam-
ple setup.
The ﬁrst step for a provider SP is to contact IP and
request permission to run a module on the sensor node.
If IP accepts the request, it provides SP with its provider
key for the node, KN,SP.
Next, SP creates the module SM, that he wants to run
on the processor and calculates the associated module
key, KN,SP,SM. Since SM will communicate with SMS, SP
requests the identity of SMS from IP. A MAC of this iden-
tity, created with KN,SP,SM, is included in an unprotected
section of SM so that SM can use it to authenticate SMS.
Then SM is sent to the node for deployment.
Once SM is received on the node, it is loaded, by un-
trusted software like the operating system, into mem-
ory and the processor is requested to protect SM, using
the protect processor instruction. As discussed, the
processor enables memory protection, computes the key
KN,SP,SM and stores it in hardware.
Now that SM has been deployed, SP can start request-
ing data from it. We will assume that SM’s function is to
request data from S through SMS, perform some transfor-
mation, ﬁltering or aggregation on it and return the result
to SP. The ﬁrst step is for SP to send a request containing
a nonce No to the node. Once the request is received (by
untrusted code) on the node, SM is called passing No as
an argument.
Before SM calls SMS, it needs to verify the integrity of
module SMS. It does this by executing the MAC-verify
instruction passing the address of the known MAC of SMS
and the address of the entry point it is about to call. The
ID of SMS is then returned to SM and, if it is non-zero,
SM calls SMS to receive the sensor data from S. SM will
usually also store the returned ID of SMS in its protected
data section so that future authentications of SMS can be
done with the get-id instruction.
Once the received sensor data has been processed into
the output data O, SM will request the processor to seal
No||O using the MAC-seal instruction. SM then passes
this MAC together with O to the (untrusted) network stack
to be sent to SP. When SP receives the output of SM, it
can verify its integrity by recalculating the MAC.
4
Implementation
This section discusses the implementation of Sancus. We
have implemented hardware support for all security fea-
tures discussed in Section 3 as well as a compiler that can
create software modules suitable for deployment on the
hardware.
4.1 The processor
Our hardware implementation is based on an open source
implementation of the TI MSP430 architecture:
the
openMSP430 from the OpenCores project [20]. We have
chosen this architecture because both GCC and LLVM
support it and there exists a lot of software running na-
tively on the MSP430, for example the Contiki operating
system.
The discussion is organized as follows. First, we ex-
plain the features added to the openMSP430 in order to
implement the isolation of software modules. Then, we
discuss how we added support for the attestation related
USENIX Association  
22nd USENIX Security Symposium  487
Registers
Inputs
pc
TS
TE
PS
PE
EN
prev pc
mab
mb en
≥
<
≥
<
≥
<
Output
violation
Figure 5: Schematic of the Memory Access Logic (MAL),
the hardware used to enforce the memory access rules for
a single protected module.
operations. Finally, we describe the modiﬁcations we
made to the openMSP430 core itself.
Isolation. This part of the implementation deals with
enforcing the access rights shown in Table 1. For this
purpose, the processor needs access to the layout of ev-
ery software module that is currently protected. Since
the access rights need to be checked on every instruction,
accessing these values should be as fast as possible. For
this reason, we have decided to store the layout informa-
tion in special registers inside the processor. Note that
this means the total number of software modules that
can be protected at any particular time has a ﬁxed upper
bound. This upper bound, NSM, can be conﬁgured when
synthesizing the processor.
Figure 5 gives an overview of the Memory Access
Logic (MAL) circuit used to enforce the access rights of
a single software module. This MAL circuit is instanti-
ated NSM times in the processor. It has four inputs: pc
and prev pc are the current and previous values of the
program counter, respectively. The input mab is the mem-
ory address bus – the address currently used for load or
store operations7 – while mb en indicates whether the
address bus is enabled for the current instruction. The
MAL circuit has one output, violation, that is asserted
whenever one of of the access rules is violated.
Apart from the input and output signals, the MAL cir-
cuit also keeps state in registers. The layout of the pro-
tected software module is captured in the TS (start of text
section), TE (end of text section), PS (start of protected
section) and PE (end of protected section) registers. The
EN register is set to 1 if there is currently a module being
protected by this MAL circuit instantiation. The layout
is saved in the registers when the protect instruction is
7Of course, this includes implicit memory accesses like a call
instruction.
called at which time EN is also set. When the unprotect
instruction is called, we just unset EN which disables all
checks.
In our prototype we load new modules through a debug
interface on the node and only the debug unit is allowed
to write to the memory region where text sections are
loaded. Therefore, the read-only nature of text sections
is already enforced and the MAL does not need to check
this. In a production implementation this check should be
added and would cost two additional comparators in the
MAL circuit.
Since the circuit is purely combinational, no extra cy-
cles are needed for the enforcement of access rights. As
explained above, this is exactly what we want since these
rights need to be checked for every instruction. The only
downside this approach might have is that this large com-
binational circuit may add to the length of the critical
path of the processor. We will show in Section 5 that
this is not the case. Note that since the MAL circuits are
instantiated in parallel, NSM does not inﬂuence the length
of the critical path.
Apart from hardware circuit blocks that enforce the
access rights, we also added a single hardware circuit
to control the MAL circuit instantiations. It implements
three tasks: (1) combine the violation signals from
every MAL instantiation into a single signal; (2) keep
track of the value of the current and previous program
counter; and (3) when the protect instruction is called,
select a free MAL instantiation to store the layout of the
new software module and assign it a unique ID.
Attestation. As explained in Section 3, two crypto-
graphic features are needed to implement our design:
the ability to create MACs and a key derivation func-
tion. Since our implementation is based on a small mi-
croprocessor, one of our main goals here is to make the
implementation of these features as small as possible.
The MAC algorithm we have chosen is HMAC, the
hash-based message authentication code. One of the rea-
sons we have chosen HMAC is its simplicity: only two
calls of a hash function are needed to calculate a MAC.
Another reason is that it serves as the basic building block
for HKDF [28], a key derivation function. This means a
lot of hardware can be shared between the implementa-
tions of the MAC and the key derivation function. For the
hash function, we have chosen to use SPONGENT because
it is one of the hash functions with the smallest hardware
footprint published to date [5]. More speciﬁcally, we
use the variant SPONGENT-128/128/8 implemented us-
ing a bit-parallel, word-serial architecture, which has a
small footprint while maintaining acceptable throughput.
Since SPONGENT-128/128/8 requires 8 bit inputs and the