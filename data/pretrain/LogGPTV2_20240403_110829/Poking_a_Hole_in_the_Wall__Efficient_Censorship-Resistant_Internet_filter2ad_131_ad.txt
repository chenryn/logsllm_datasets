message. However, instead of replacing the pixels of the raw input
video, it replaces the bits of the encoded video signal, i.e., after the
input video has been compressed by the WebRTC video codec. This
technique helps increase not only the capacity of the channel but
also its resistance to trac analysis. In our system, it is implemented
by instrumenting the WebRTC stack of the Protozoa gateway.
Upstream and downstream hooks: Figure 5 illustrates the Web-
RTC stack as it is implemented in the Protozoa gateway. It is based
on the WebRTC stack bundled into the Chromium browser. The
WebRTC stack contains a built-in codec (VP8), which processes the
video signal of local web applications that use the WebRTC API. To
access the video frames generated by the WebRTC application and
implement encoded media tunneling, the WebRTC stack includes
two hooks that can intercept the processing of the media stream
in dierent directions, i.e., upstream or downstream. The upstream
hook intercepts outgoing frame data, i.e., from a local camera device
to the network. It is placed after the raw video signal has been pro-
cessed by the video engine, and right before the frame data is passed
Session 1A: Anonymous Routing and Censorship CCS '20, November 9–13, 2020, Virtual Event, USA39WebRTC Applica(cid:87)ion (e.g.,(cid:172)whereb(cid:116)(cid:173)com)
Web API (Ja(cid:89)aScrip(cid:87))
WebRTC API (C++)
Session managemen(cid:87)/signalling
Voice Engine
A(cid:88)dio Codec
Jitter B(cid:88)ffer
Echo Cancelling
Noise Red(cid:88)ction
Video Engine
Video Codec
Jitter B(cid:88)ffer
Image Enhance
Proto(cid:93)oa Hooks
Transpor(cid:87)
SRTP
M(cid:88)ltiple(cid:91)ing
STUN
TURN
ICE
WebRTC
Figure 5: WebRTC software stack and Protozoa’s hooks.
over to the transport layer where SRTP packets are created, and sent
to the network. The downstream hook intercepts incoming frame
data, i.e., from the network to the local screen. It is placed right
after the transport layer has nished reconstructing an encoded
frame sent in multiple network packets, and right before handing
it over to the video engine to be decoded and rendered on screen.
We strategically placed hooks in the WebRTC stack in order to
manipulate a special data structure, named encoded frame bitstream
partitions (EFBP), where we can embed Protozoa messages.
Using EFBP as a covert data mule: To help understand how the
covert data is embedded into the carrier frame data, Figure 6 depicts
the format of the SRTP packets, which is the means through which
video data is exchanged. The bulk of SRTP packet space is reserved
for the transmission of media payload in the eld named encoded
frame bitstream (EFB). This eld contains the bits of an encoded
(compressed) video frame as it is generated by VP8, the default
WebRTC codec. An encoded frame contains a small (3-10 bytes)
uncompressed header, and two partitions which carry compressed
bitstreams containing actual carrier video data. We call EFBP the
contiguous space occupied by these partitions. The EFBP has ve
extremely interesting properties for our problem domain:
(1) The EFBP consists of a blob of bits that contains the actual
video data of the carrier stream. Since this information is
irrelevant for us, we can eectively use this eld for carrying
covert data by overwriting it with covert data.
(2) The EFBP, once it is generated by VP8, is no longer modi-
ed by the WebRTC downstream pipeline. This means that
the covert data bits placed in this eld are not going to be
corrupted, e.g., due to compression or other destructive op-
erations, before being sent to the network.
(3) The EFBP will be used as payload of the SRTP packet, and
contains no relevant metadata that inuences the transport
layer logic, hence, modifying this eld will not disturb the
normal functioning of packet transfer over the network.
(4) The EFBP, prior to being assembled into SRTP packets, will
be encrypted, and protected with authentication markers.
This means that covert data placed inside the EFBP will be
encrypted and integrity-protected for free.
(5) The EFBP will be encrypted resorting to a stream cipher
that preserves the plaintext size, therefore, embedded covert
messages do not change the size of encrypted EFBPs.
For all these reasons, we use the EFBP as a free storage space for
transmitting covert data in the form of Protozoa messages.
0
V=2 P X
1
CC M
PT
SRTP Packe(cid:87)
2
3
(cid:23)
seq(cid:88)ence n(cid:88)mber
(cid:87)imes(cid:87)amp
s(cid:92)nchroni(cid:93)a(cid:87)ion so(cid:88)rce (SSRC) iden(cid:87)i(cid:192)er
con(cid:87)rib(cid:88)(cid:87)ing so(cid:88)rce (CSRC) iden(cid:87)i(cid:192)ers ...
RTP e(cid:91)(cid:87)ension (op(cid:87)ional)
Encoded F(cid:85)ame Bi(cid:87)(cid:86)(cid:87)(cid:85)eam ...
RTP padding
SRTP MKI (op(cid:87)ional)
a(cid:88)(cid:87)hen(cid:87)ica(cid:87)ion (cid:87)ag (recommended)
n
o
i
(cid:87)
(cid:85)
o
p
d
e
a
c
i
(cid:87)
(cid:87)
n
e
h
(cid:87)
(cid:88)
A
RTP pad co(cid:88)n(cid:87)
n
o
i
(cid:87)
(cid:85)
o
p
d
e
p
(cid:92)
(cid:85)
c
n
E
(cid:87)
Uncompressed
Header
Enc(cid:82)ded F(cid:85)ame Bi(cid:87)(cid:86)(cid:87)(cid:85)eam
Par(cid:87)i(cid:87)ion I
Par(cid:87)i(cid:87)ion II
Segmen(cid:87) 1
...
Segmen(cid:87) n
Termina(cid:87)or
Packe(cid:87) Leng(cid:87)h
Packe(cid:87) ID
Packe(cid:87) Frag.
N(cid:88)mber
Las(cid:87) Frag Flag
IP Packe(cid:87) Da(cid:87)a
EFBP Field
Pro(cid:87)o(cid:93)oa Message
Figure 6: Format of SRTP packets: Protozoa replaces the
EFBP payload containing carrier video bits with covert data.
Protozoa message transmission: To embed covert IP packets in-
side an EFBP, Protozoa uses the message format depicted in Figure 6.
A single message consists of multiple segments followed by a Ter-
minator (i.e., a zero-length segment) which delimits the EFBP area
occupied by covert data. Each segment carries an entire IP packet
or a packet fragment. IP packet fragmentation may be required at
the sender’s endpoint shall the next available IP packet be larger
than the available EFBP space on the frame; this process will help
to use the covert channel in its maximal capacity. As a result, a
covert IP packet can be transmitted in a single segment or span
across multiple segments. Each segment has a small header that
allows the receiving endpoint to reassemble IP packet fragments.
Message transmission works as follows. For every new frame
generated by the video engine, there is an opportunity for sending
a new message, which causes the upstream hook to be executed
and given access to the encoded frame. The hook accesses the EFBP
data structure, checks its size, and tells the encoder service how
much free space exists in the frame for sending covert data. The
hook waits for the encoder to assemble a new message containing
locally queued IP packets. Then, the hook copies it into the EFBP
and returns, letting the WebRTC pipeline to proceed with its normal
execution until the resulting SRTP packets are transmitted. At the
receiving endpoint, the reverse operation is performed. Whenever
an encoded frame is reassembled, the downstream hook is executed
and extracts the Protozoa message from the EFBP eld. This mes-
sage is sent to the local decoder service, which reassembles the
ingress IP packets and forwards them to their rightful destination.
4.5 Prevent Video Decoding Malfunction
While it is possible to fully replace the content of the EFBP eld,
the undisciplined corruption of a frame bitstream can prevent the
video decoder in the WebRTC downstream pipeline from correctly
decoding video frame data at the receiver’s endpoint. In fact, we
empirically veried that in such situations, WebRTC triggers con-
gestion control mechanisms in the downstream pipeline for ensur-
ing the reception of video. In particular, it advertises a Picture Loss
Indication (PLI) in the accompanying RTCP control channel [61],
Session 1A: Anonymous Routing and Censorship CCS '20, November 9–13, 2020, Virtual Event, USA40aimed at requesting the retransmission of a key frame upon being
unable to decode the corrupted frame data. In particular, VP8 pro-
duces two dierent types of encoded frames. Key frames can be
decoded without any reference to previous frames and provide seek-
ing points within a video stream. Delta frames are encoded with
reference to the prior key frame and ensuing frames. By advertising
PLIs and sending key frames upon detecting corrupted frames, the
resulting trac patterns produced by WebRTC applications would
make Protozoa vulnerable to trac analysis.
To overcome this problem, the downstream hook feeds the Web-
RTC video decoder with a pre-recorded sequence of valid encoded
frames instead of the corrupted frames received over the network.
Since the encoded frames may either be key frames or delta frames,
the downstream hook uses the uncompressed header information
kept intact after covert data embedding (see Figure 6) to decide
which type of frame and corresponding resolution (e.g., 640x480)
should be provided to the native WebRTC video decoder. Then, it
restores the corrupted bitstream with a bitstream of a valid frame.
This allows us to establish a covert channel where the size of egress
frames on the upstream pipeline is maintained, and to deliver the
decoder valid data so that it does not trigger congestion control.
4.6 Implementation and Optimizations
We developed a Protozoa prototype [2] by writing approximately
3,000 lines of C++ code. This includes the instrumentation of the
native WebRTC codebase of the Chromium browser v79.0.3945.117,
a stable release from January 2020. Protozoa requires the proper
establishment of a WebRTC video session for embedding data into
encoded frames sent over the wire. To this end, WebRTC must be
able to access a video feed that can be directly obtained from the