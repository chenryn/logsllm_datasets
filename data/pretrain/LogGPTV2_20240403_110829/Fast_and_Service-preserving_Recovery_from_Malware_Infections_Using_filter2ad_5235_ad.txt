broader framework of intrusion detection. Related work
we are currently conducting seeks to use machine learn-
ing techniques to analyze payloads of network trafﬁc and
could act as a trigger for this malware cleaning operation.
We are also considering employing elements of moving
target defense, such as changing the IP address, pass-
words, or even the physical host machine of a restored
container to complicate and delay attacks while more ro-
bust defenses can be deployed.
8 Conclusion
The main contribution of our work is a new method for
malware recovery. Rather than using logging or VM-
based methods for removing malware, CRIU-MR uses
Linux containers and CRIU to quickly restore a system
to a safe state in the event of an infection. Furthermore,
our method improves upon prior work by very quickly
recovering the state of trusted services after recovery
with minimal impact to clients. We conduct two exper-
iments to test the speed and availability of CRIU-MR
and ﬁnd promising results. Our test of the duration of
the malware recovery process ﬁnds that malware recov-
ery does not take signiﬁcantly more time than a CRIU
checkpoint/restore with no policy. Furthermore, our sec-
ond experiment indicates that CRIU-MR is capable of
restoring container processes and TCP connections after
malware recovery, even when many concurrent connec-
tions are present. The success of this tool is dependent
on its use in the context of other systems, such as IDS’s,
ﬁrewalls, and antivirus scanners. Information from these
systems, along with static application-speciﬁc knowl-
edge, can form a robust policy for malware removal.
CRIU-MR can now be used by both administrators and
researchers to build systems which are responsive and
service-preserving when faced with malware infections.
9 Acknowledgments
This work was supported by the United States Ofﬁce of
Naval Research under Contract N000141612107.
References
[1] ab - Apache HTTP server benchmarking tool.
https:
//httpd.apache.org/docs/2.4/programs/ab.html. Ac-
cessed: 2018-02-05.
[2] Contagio malware dump. http://contagiodump.blogspot.
com/. Accessed: 2018-02-05.
USENIX Association
27th USENIX Security Symposium    1207
[3] CRIU: TCP Repair. https://criu.org/TCP_connection.
Accessed: 2018-02-05.
[4] Cuckoo sandbox. https://cuckoosandbox.org/. Accessed:
2018-02-05.
[5] Hybrid analysis. https://www.hybrid-analysis.com/. Ac-
cessed: 2018-02-05.
[6] Linux containers - lxc.
https://linuxcontainers.org/
lxc/. Accessed: 2018-02-05.
[7] Logstash. https://www.elastic.co/products/logstash.
Accessed: 2018-02-05.
[8] Lxc
security.
https://linuxcontainers.org/lxc/
security/. Accessed: 2018-02-05.
[9] Metasploit.
2018-02-05.
https://www.metasploit.com/. Accessed:
[10] National vulnerability database: Cve-2017-17562 detail. https:
Ac-
//nvd.nist.gov/vuln/detail/CVE-2017-17562.
cessed: 2018-02-05.
[11] Timeit.
https://docs.python.org/2/library/timeit.
html. Accessed: 2018-02-05.
[24] HODSON, D. Remote LD_PRELOAD exploitation. https:
//www.elttam.com.au/blog/goahead/. Accessed: 2018-
02-05.
[25] HSU, F., CHEN, H., RISTENPART, T., LI, J., AND SU, Z. Back
to the future: A framework for automatic malware removal and
system repair. In Proceedings of the 22Nd Annual Computer Se-
curity Applications Conference (Washington, DC, USA, 2006),
ACSAC ’06, IEEE Computer Society, pp. 257–268.
[26] JORDANEY, R., SHARAD, K., DASH, S. K., WANG, Z., PAP-
INI, D., NOURETDINOV, I., AND CAVALLARO, L. Transcend:
Detecting concept drift in malware classiﬁcation models. In 26th
USENIX Security Symposium (USENIX Security 17) (Vancouver,
BC, 2017), USENIX Association, pp. 625–642.
[27] KHARAZ, A., ARSHAD, S., MULLINER, C., ROBERTSON, W.,
AND KIRDA, E. UNVEIL: A large-scale, automated approach
to detecting ransomware. In 25th USENIX Security Symposium
(USENIX Security 16) (Austin, TX, 2016), USENIX Association,
pp. 757–772.
[28] LABS, M.
2017 state of malware report.
//www.malwarebytes.com/pdf/white-papers/
stateofmalware.pdf. Accessed: 2018-02-05.
https:
[12] Usage of operating systems for websites. https://w3techs.
com/technologies/overview/operating_system/all.
Accessed: 2018-02-05.
[13] Virus total. https://www.virustotal.com. Accessed: 2018-
02-05.
[14] ARAUJO, F., HAMLEN, K. W., BIEDERMANN, S., AND
KATZENBEISSER, S.
to honey-patches:
Lightweight attacker misdirection, deception, and disinforma-
tion. In Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security (New York, NY, USA,
2014), CCS ’14, ACM, pp. 942–953.
From patches
[15] BARTOS, K., SOFKA, M., AND FRANC, V. Optimized invariant
representation of network trafﬁc for detecting unseen malware
variants. In 25th USENIX Security Symposium (USENIX Security
16) (Austin, TX, 2016), USENIX Association, pp. 807–822.
[16] CISCO. ClamAV. https://www.clamav.net/. Accessed:
2018-02-05.
[17] CISCO. Snort. https://www.snort.org/. Accessed: 2018-
02-05.
[18] DE OLIVEIRA, D. A. S., CRANDALL, J. R., WASSERMANN,
G., WU, S. F., SU, Z., AND CHONG, F. T. Execrecorder: Vm-
based full-system replay for attack analysis and system recovery.
In Proceedings of the 1st Workshop on Architectural and System
Support for Improving Software Dependability (New York, NY,
USA, 2006), ASID ’06, ACM, pp. 66–71.
[19] ELBADAWI, K., AND AL-SHAER, E. Timevm: A framework for
online intrusion mitigation and fast recovery using multi-time-lag
trafﬁc replay. In Proceedings of the 4th International Symposium
on Information, Computer, and Communications Security (New
York, NY, USA, 2009), ASIACCS ’09, ACM, pp. 135–145.
[20] GOEL, A., PO, K., FARHADI, K., LI, Z., AND DE LARA, E.
The taser intrusion recovery system. In Proceedings of the Twen-
tieth ACM Symposium on Operating Systems Principles (New
York, NY, USA, 2005), SOSP ’05, ACM, pp. 163–176.
[21] GOOGLE. Protocol buffers. https://developers.google.
com/protocol-buffers/. Accessed: 2018-02-05.
[22] GRATTAFIORI, A. Understanding and hardening linux contain-
ers. Whitepaper, NCC Group (2016).
[23] HERTZ, J. Abusing privileged and unprivileged linux containers.
Whitepaper, NCC Group (2016).
[29] LABS, S. O.
https://www.
sentinelone.com/blog/hiding-plain-sight/. Accessed:
2018-02-05.
Hiding in plain sight?
[30] LEVER, C., KOTZIAS, P., BALZAROTTI, D., CABALLERO, J.,
AND ANTONAKAKIS, M. A lustrum of malware network com-
munication: Evolution and insights. In 2017 IEEE Symposium on
Security and Privacy (SP) (May 2017), pp. 788–804.
[31] MAEDA, K. Performance evaluation of object serialization li-
braries in xml, json and binary formats. In Digital Information
and Communication Technology and it’s Applications (DICTAP),
2012 Second International Conference on (May 2012), pp. 177–
182.
[32] MOHAN, C., HADERLE, D., LINDSAY, B., PIRAHESH, H.,
AND SCHWARZ, P. Aries: A transaction recovery method sup-
porting ﬁne-granularity locking and partial rollbacks using write-
ahead logging. ACM Trans. Database Syst. 17, 1 (Mar. 1992),
94–162.
[33] PALEARI, R., MARTIGNONI, L., PASSERINI, E., DAVIDSON,
D., FREDRIKSON, M., GIFFIN, J., AND JHA, S. Automatic gen-
eration of remediation procedures for malware infections. In Pro-
ceedings of the 19th USENIX Conference on Security (Berkeley,
CA, USA, 2010), USENIX Security’10, USENIX Association,
pp. 27–27.
[34] PASSERINI, E., PALEARI, R., AND MARTIGNONI, L. How
good are malware detectors at remediating infected systems? In
Proceedings of the 6th International Conference on Detection of
Intrusions and Malware, and Vulnerability Assessment (Berlin,
Heidelberg, 2009), DIMVA ’09, Springer-Verlag, pp. 21–37.
[35] SHAN, Z., WANG, X., AND C. CHIUEH, T. Malware clear-
ance for secure commitment of os-level virtual machines. IEEE
Transactions on Dependable and Secure Computing 10, 2 (March
2013), 70–83.
[36] SOFTWARE, E. Goahead: Simple, secure embedded web server.
https://www.embedthis.com/goahead/. Accessed: 2018-
02-05.
[37] SOLTESZ, S., PÖTZL, H., FIUCZYNSKI, M. E., BAVIER, A.,
AND PETERSON, L. Container-based operating system virtual-
ization: A scalable, high-performance alternative to hypervisors.
SIGOPS Oper. Syst. Rev. 41, 3 (Mar. 2007), 275–287.
[38] SUBRAHMANIAN, V., OVELGONNE, M., DUMITRAS, T., AND
ADITYA PRAKASH, B. The Global Cyber-Vulnerability Report.
01 2015.
1208    27th USENIX Security Symposium
USENIX Association
released to the kernel and forwarded along to or from the
container.
[39] VASUDEVAN, A. Maltrak: Tracking and eliminating unknown
malware. In Proceedings of the 2008 Annual Computer Security
Applications Conference (Washington, DC, USA, 2008), ACSAC
’08, IEEE Computer Society, pp. 311–321.
[40] VIRTUOZZO. CRIU. https://criu.org. Accessed: 2018-02-
05.
[41] ZHU, Z., AND DUMITRAS, T. Featuresmith: Automatically en-
gineering features for malware detection by mining the security
In Proceedings of the 2016 ACM SIGSAC Confer-
literature.
ence on Computer and Communications Security (New York, NY,
USA, 2016), CCS ’16, ACM, pp. 767–778.
Appendices
A Logstash Pipelines for Snort and Cla-
mAV Triggers
Logstash [7] can be a useful tool for parsing and for-
warding alerts from a variety of sources. The “grok”
ﬁlter, a ﬁltering action in the Logstash pipeline, can
be used to parse alerts from arbitrary sources (such as
ﬁles, network ports, etc.)
into easily parseable JSON.
Listing 1 shows an example of using Logstash with the
grok ﬁlter to parse Snort alerts and send them to the
CRIU-MR agent. The Snort command used to gen-
erate the alerts is snort -c snort.conf -i lxcbr0
-A full -k none, where -A full denotes full alert
syntax. The -k none parameter indicates no checksums
should be calculated, which we anecdotally observe is re-
quired for obtaining alerts on both inbound and outbound
trafﬁc.
The ClamAV parsing is very similar. The command
to execute the scanner is clamscan path/to/scan
–no-summary –infected > output.log. The Snort
example is modiﬁed slightly for the different output
format. Namely,
to
output.log, the multiline code is not needed (each
line of output.log corresponds to one alert), and the
add_field codec is modiﬁed for the appropriate trigger
type. Finally the grok parsing code in the ﬁlter step sim-
ply becomes:
the path is changed to point
%{GREEDYDATA: f i l e p a t h } :
%{GREEDYDATA: malwarename } FOUND
B NFQUEUE Buffer
Listing 2 shows an example implementation of a buffer
for packets intended for the interface lxcbr0, which is
the default interface used for the Linux container net-
working. This simple python script uses the netﬁl-
terqueue library (available via pip) to hold packets until
the program terminates via a kill signal. Packets are then
USENIX Association
27th USENIX Security Symposium    1209
Listing 1: Logstash Pipeline for Snort Alert Parsing
# s t a n d a r d p a t h f o r
p a t h => " / v a r / l o g / s n o r t / a l e r t "
# combines m u l t i p l e
codec => m u l t i l i n e {
s n o r t a l e r t s
p a t t e r n => " ^ \ [ \ ∗ \ ∗ \ ]
n e g a t e => true
what => " p r e v i o u s "
"
l i n e s as a s i n g l e
l o g e v e n t
}
# adding a f i e l d t o t h e p a r s e d j s o n so t h a t CRIU−MR knows
# how t o p a r s e
a d d _ f i e l d => { " t r i g g e r _ t y p e " => " s n o r t " }
i t
i n p u t {
f i l e {
}
}
f i l t e r {
grok {
o u t p u t {
t c p {
}
}
}
}
# P a r s i n g o u t p u t o f
# n e w l i n e s added f o r
r e a d a b i l i t y
match => { " message " => " \ [ \ ∗ \ ∗ \ ]
s n o r t
i n t o JSON
%{NUMBER: r e v i s i o n } \ ] %{GREEDYDATA: r u l e } \ [ \ ∗ \ ∗ \ ] ∗ \ n \ [ P r i o r i t y :
%{NUMBER: p r i o r i t y } \ ]
:%{MINUTE: minute }:%{SECOND: second } %{IP : s r c _ i p }:%{NUMBER: s r c _ p o r t }
−> %{IP : d s t _ i p }:%{NUMBER: d s t _ p o r t }∗ \ n ∗ \ n ∗ \ n∗ " }
\ n%{MONTHNUM: month } \/%{MONTHDAY: day}−%{HOUR: hour }
\[%{NUMBER: v e r s i o n }:%{NUMBER: s i d } :
h o s t => 
p o r t => 
1210    27th USENIX Security Symposium
USENIX Association
Listing 2: NFQUEUE Python Buffer
i m p o r t os
from n e t f i l t e r q u e u e
i m p o r t
s i g n a l
i m p o r t N e t f i l t e r Q u e u e
def
frame ) :
s e n d _ p a c k e t s ( s i g n a l ,
p r i n t ( " s e n d i n g p a c k e t s and s h u t t i n g down " )
os . system ( " i p t a b l e s −D INPUT −i
l x c b r 0 −j NFQUEUE −−queue−num 1 " )
os . system ( " i p t a b l e s −D OUTPUT −o l x c b r 0 −j NFQUEUE −−queue−num 1 " )
os . system ( " i p t a b l e s −D FORWARD −o l x c b r 0 −j NFQUEUE −−queue−num 1 " )
f o r p a c k e t
in p a c k e t s :
p a c k e t . a c c e p t ( )
n f q u e u e . unbind ( )
def h o l d _ p a c k e t ( p k t ) :
g l o b a l p a c k e t s
p r i n t ( " h o l d i n g " + s t r ( p k t ) )
p a c k e t s . append ( p k t )
p a c k e t s = [ ]
s i g n a l . s i g n a l ( s i g n a l . SIGTERM ,
l x c b r 0 −j NFQUEUE −−queue−num 1 " )
os . system ( " i p t a b l e s −I
os . system ( " i p t a b l e s −I OUTPUT −o l x c b r 0 −j NFQUEUE −−queue−num 1 " )
os . system ( " i p t a b l e s −I FORWARD −o l x c b r 0 −j NFQUEUE −−queue−num 1 " )
s e n d _ p a c k e t s )
INPUT −i
n f q u e u e = N e t f i l t e r Q u e u e ( )
n f q u e u e . b i n d ( 1 , h o l d _ p a c k e t )
t r y :
n f q u e u e . run ( )
e x c e p t K e y b o a r d I n t e r r u p t :
s e n d _ p a c k e t s ( None , None )
USENIX Association
27th USENIX Security Symposium    1211