last response arrives.
In particular, four different loading times have been
measured and two percentages have also been calcu-
lated, to compare the overheads introduced by our ap-
proach.
Loading Time w/o Shadow Execution (LTWS) The
full loading time of a page, without the use of our sys-
tem.
Loading Time in VM public (LTVMPUB) The full
loading time of a page within the V Mpublic.
Loading Time in VM private (LTVMPRI) The full
loading time of a page within the V Mprivate.
Loading Time for Usability (LTFU) The partial load-
ing time of a page within V Mprivate, when using our
implementation:
this is the time after which a user is
able to access the whole signiﬁcant content of a page,
even if some parts of it (i.e., the banners not found by
the proxy) are not completely visible. This measure is
only meaningful for web browsing measurements, pre-
sented later in this section.
Overhead Percentage in VM private (OPVMPRI)
The loading time overhead induced by our implemen-
Application
Adobe Reader
Apple Update
LTWS
(ms)
371
6470
LTVMPUB
(ms)
LTVMPRI
(ms)
OPVMPRI
403
7937
508
9527
+36%
+47%
Table 3. Application Performance
tation in V Mprivate, w.r.t. LTWS, expressed in percent-
age.
Overhead Percentage For Usability (OPFU) The
loading time overhead induced by Porfolio in VM pri-
vate since usability, w.r.t. LTWS, expressed in percent-
age.
Applications updates overheads In Table 3 we can see a
summary of the timing details related to Adobe Reader
and Apple Update. Let us start by considering the third
and the fourth columns. Since the instance of the ap-
plication running in the virtual environment is the one
with direct access to the Internet, it is also the ﬁrst one
receiving the response. The instance in the real desktop
receives the response with a delay of about 20%. This is
due to the fact that the proxy-thread serving the real ma-
chine has to inspect the cache and search for the correct
match before injecting it to the application in the real
environment.
Let us now have a look to the last column showing the
percentage overhead with respect to the execution of the
same application in a system without our system. These
numbers are acceptable considering the fact that in these
operations (searching for available updates) it is not so
crucial to have an immediate response from the network
as these requests operate in the background.
Web browsing overheads To measure the performances
of Mozilla Firefox, we used a small add-on speciﬁc for
this browser, called Load Time Analyzer [10]. This is a
simple and compact utility that allows users to measure
the amount of time taken by web pages to load inside
Firefox. Load Time Analyzer also produces graphs that
show the occurrence of events such as requests for the
page, images and scripts, along with events like the ex-
ecution of an on-load script: they enabled us to identify
when the signiﬁcant components of a page have been
loaded and therefore the possibility to measure the so-
called “time for usability”, i.e., time from which a user
can start exploring the content of a page, even if not
all the elements are completely loaded (e.g., the adver-
tisements). Since this tool is a lightweight component
we believe that the performance is not inﬂuenced by the
add-on itself. To prevent cache-related effects, we also
329329
Website
Maps.Google.com
TransitChicago.com
Altavista.com
Ansi.com
Wordreference.com
Berkeley.edu
CNN.com
MSN.com
Yahoo.com
LTWS
(ms)
2156
2469
891
3364
451
6259
10031
8031
3141
LTVM
PUB(ms)
4110
3565
1652
7198
1192
7320
18840
12568
4186
LTVM
PRI(ms)
5541
4812
1392
7461
1382
7721
103829
55250
52718
OPVM
PRI
+157%
+94%
+56%
+121%
+206%
+23%
Table 4. Load Time of websites in Firefox
disabled the Firefox cache, setting it to zero megabytes.
The most important observation that can be made con-
cerning timings presented in Table 4 concerns the last
three rows for which the OPVMPRI is missing. For
websites like these, i.e. full of advertisements, what re-
ally matters is the “time for usability”. The OPFU for
the last the last three websites are respectively: 120%,
102% and 67%.
We also noted that some of the overhead was due to the
choice of using the VirtualBox VM, where the VM runs
as a regular process. Use of para-virtualized systems
such Xen would result in much lower overheads, but
would have required support from the operating system.
In contrast, our choice of VirtualBox was inﬂuenced by
our (usability) requirement of a “drop-in” solution that
provides operating system transparency, i.e., no modiﬁ-
cations to the operating system.
5 Related Work
The goal of most works discussed in this section is to
enforce the non-interference property [5]. We only dis-
cuss some representative works closely related to ours.
A more comprehensive treatment of previous works in
this area can be found in the extensive survey [16] by
Sabelfeld and Myers.
Runtime approaches. The scripting language Perl
has a taint mode [22] that tracks data that arrives from
untrusted sources (such as the network).
Perl also
supports implicit downgrading data from “tainted” to
“untainted” through pattern matching. Recently, sev-
eral works have proposed the use of taint-tracking to
defeat attacks by enforcing integrity policies on pro-
grams [13, 17, 25].
[26, 4] target spyware detection
through such taint tracking. However, most taint track-
ing approaches do not track all forms of implicit ﬂows,
as explained here [2], and therefore may miss certain
conﬁdential information leaks. A signature based ap-
proach [23] detects spyware by looking for footprints
in network trafﬁc; however, this approach will fail for
spyware that uses implicit ﬂows to communicate conﬁ-
dential information.
There are a few approaches [21, 28, 20] that employ a
combination of static and dynamic methods to avoid the
limitations of pure dynamic approaches. In both these
works, the use of dynamic techniques is to expand the
scope of the static analysis based policy enforcement
mechanisms. However, all the above works can be im-
precise in reporting false alarms when in fact there is
no leakage of information, say when a program outputs
identical information in both the branches of a condition
that handles sensitive information.
Data sandboxing [9] partitions a program into private
and public zones based on the data handled, and enforces
different conﬁdentiality policies on these zones. How-
ever, this technique is applicable only when the source
of the program is available. TightLip [27] is another re-
cent approach that is closely related to ours. TightLip
detects breaches due to conﬁdentiality by using dopple-
ganger processes. While TightLip is designed to detect
conﬁdentiality violations by trusted programs due to ac-
cess control errors, we detect conﬁdentiality violations
of programs that may intentionally leak sensitive infor-
mation. Another important difference is that we handle
threats to conﬁdentiality in an operating system trans-
parent manner through the use of virtual machines and
isolated execution. This main beneﬁt of our approach
makes it readily usable in Windows operating systems,
where threats to data conﬁdentiality are numerous.
for writing secure programs Myers
Languages
presents a language called Jif [12] that uses a typesys-
tem to aid the programmer to construct programs that
respect conﬁdentiality. Flow Caml [14], developed by
Simonet and Pottier, is another realistic programming
language aimed at supporting information ﬂow controls.
These approaches provide robust production, when the
producer of the software wants to develop programs that
respect conﬁdentiality. They do not address concerns
about binary code, which is the typical mode of distri-
bution by content producers.
Theorem proving based approaches.
In order to im-
prove over the precision offered by static analysis, Joshi
et al [8] (and more recently, Darvas et al. [3] and Barthe
et al.
[1]) have proposed the use of theorem proving
techniques. This is done by characterizing information
ﬂow as a safety problem (using a technique called self-
composition, summarized in a formulation by [18]) and
330330
using theorem proving technology to certify programs
as safe. The downside of a theorem-proving based ap-
proach is that it is not fully automated and requires man-
ual intervention.
6 Conclusion
In this paper, we presented a solution for preventing in-
formation leaks pertaining to an end user’s conﬁdential
information. Our solution works by the technique of
shadow execution, which runs two executable copies of
a program with a different set of inputs and prevents in-
formation leaks by construction. We implemented our
technique for Windows based applications, and evalu-
ated our system with several examples. The results from
our approach lead us to believe that our prototype makes
a signiﬁcant step towards utilizing the power of com-
modity virtual machines for the purpose of protecting
end user data conﬁdentiality.
Note The authors gratefully acknowledge the partial sup-
port of this research through their NSF grants (CNS-
0716584), (CNS-0551660) and (CCF-0742686). The
ﬁrst two authors are enrolled in the UIC-Politecnico di
Milano joint Masters program.
References
[1] G. Barthe, P. D’Argenio, and T. Rezk. Secure informa-
tion ﬂow by self-composition. In Proc. IEEE Computer
Security Foundations Workshop, 2004.
[2] L. Cavallaro, P. Saxena, and R. Sekar. On the limits of in-
formation ﬂow techniques for malware analysis and con-
tainment. In Detection of Intrusions, Malware and Vul-
nerability Analysis (DIMVA), July 2008.
[3] A. Darvas, R. H¨ahnle, and D. Sands. A theorem prov-
In
ing approach to analysis of secure information ﬂow.
Proc. 2nd International Conference on Security in Perva-
sive Computing, 2005.
[4] M. Egele, C. Kruegel, E. Kirda, H. Yin, and D. Song. Dy-
In USENIX Annual Technical
namic spyware analysis.
Conference, Berkeley, CA, USA, 2007.
[5] J. A. Goguen and J. Meseguer. Security policies and secu-
rity models. In IEEE Symposium on Security and Privacy,
pages 11–20, Apr. 1982.
[6] G. Hunt and D. Brubacher. Detours: binary interception
of win32 functions. In USENIX Windows NT Symposium,
Berkeley, CA, USA, 1999.
[7] InnoTek.
VirtualBox Documentation available at
http://www.virtualbox.org/. http://www.virtualbox.org.
[8] R. Joshi and K. R. M. Leino. A semantic approach to
secure information ﬂow. Science of Computer Program-
ming, 37(1–3):113–138, 2000.
[9] T. Khatiwala, R. Swaminathan, and V. N. Venkatakrish-
nan. Data sandboxing: A technique for enforcing conﬁ-
dentiality policies. In ACSAC, Miami Beach, Dec. 2006.
[10] Load time analyzer: A Firefox add-on. Available at
https://addons.mozilla.org/en-US
/firefox/addon/3371.
[11] MSDN.
Hooks Documentation
at
en-us/
ms632589.aspx. http://msdn.microsoft.com.
http://msdn2.microsoft.com/
available
library/
[12] A. C. Myers. JFlow: Practical mostly-static information
ﬂow control. In ACM Symposium on Principles of Pro-
gramming Languages (POPL), Jan. 1999.
[13] J. Newsome and D. Song. Dynamic taint analysis for
automatic detection, analysis, and signature generation of
In Network and Dis-
exploits on commodity software.
tributed Systems Security, 2005.
[14] F. Pottier and V. Simonet. Information ﬂow inference for
In ACM Symposium on Principles of Programming
ml.
Languages (POPL), 2002.
[15] T. Richardson, Q. Stafford-Fraser, K. R. Wood, and
IEEE Internet
A. Hopper. Virtual network computing.
Computing, 2(1):33–38, 1998.
[16] A. Sabelfeld and A. C. Myers.
Language-based
IEEE J. Selected Areas in
information-ﬂow security.
Communications, 21(1), Jan. 2003.
[17] G. E. Suh, J. W. Lee, D. Zhang, and S. Devadas. Se-
cure program execution via dynamic information ﬂow
tracking. In Architectural Support for Programming Lan-
guages and Operating Systems, 2004.
[18] T. Terauchi and A. Aiken. Secure information ﬂow as
In Static Analysis Symposium (SAS),
a safety problem.
2005.
[19] TightVNC. Available at http://www.tightvnc.org.
[20] S. Tse and S. Zdancewic.
Run-time principals in
In IEEE Symposium on
information-ﬂow type systems.
Security and Privacy., 2004.
[21] V.N. Venkatakrishnan, W. Xu, D. C. DuVarney, and
R. Sekar. Provably correct runtime enforcement of non-
interference properties. In ICICS Raleigh, NC, November
2006.
[22] L. Wall, T. Christiansen, and R. Schwartz. Programming
Perl. O’Reilly, 1996.
[23] H. Wang, S. Jha, and V. Ganapathy. Netspy: Automatic
In ACSA
generation of spyware signatures for NIDS.
Computer Applications Security Conference , Dec. 2006.
[24] WireShark: a network protocol analyzer. Available at
http://www.wireshark.org/docs.
[25] W. Xu, S. Bhatkar, and R. Sekar. Taint-enhanced policy
enforcement: A practical approach to defeat a wide range
of attacks. In USENIX Security Symposium, 2006.
[26] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda.
Panorama: capturing system-wide information ﬂow for
malware detection and analysis. In ACM Conference on
Computer and Comm. Security, Alexandra, Oct 2007.
[27] A. R. Yumerefendi, B. Mickle, and L. P. Cox. Tightlip:
In NSDI.
Keeping applications from spilling the beans.
USENIX, 2007.
[28] L. Zheng and A. Myers. Dynamic security labels and
noninterference. In Workshop on Formal Aspects in Secu-
rity and Trust (FAST), 2004.
331331