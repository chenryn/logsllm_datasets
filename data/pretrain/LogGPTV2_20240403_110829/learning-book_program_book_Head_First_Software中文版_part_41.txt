我们常是一张机恭代表我们准务测试
GiftCard startGC =
new GiftCard(activationDate, expirationDate, gcValue);
GiftCard endGC =
·接，是一
陈“结束礼
以测试行单处
理中返留的值，
// Here's where the mock object creation happens
DBAccessor mockAccessor = EasyMock.createMock(DBAccessor.class);
…所以，我们要求框架老创建模拟对素，该时象
实现正确的提口
在送一点上.
横就对象还知迷的不多。
只知道他必绣创建BAcc的警
代物。所以，官知遥合“mock”的方法，但除选之外，没有其他一
怪浪
有任何行为。
306
第8章
---
## Page 343
测试驱动开发
一里你创建了一个模拟对象，它是在记录模式，那
记值，你已经
表示你资的它什是期特的，什公是要做的所
不兰编系自己
以，它你把它放在重播模武并显你的测试使用它
时，你已经确切地建立了模拟对象应读做件么。
是这里的一大
胜利。
// Tell our test -framework what to call, and what to expect
EasyMock,expect (mockAccessor,getGC(12345)) .andReturn (startGC) ;
上
当serGc（）用那个佳被诺用时，送需给
首先，预期以“12345”的佳得用
stnrGC对象.…运在模拟以数揭为中取
sGC()…这个值与我们这里制速
得礼券，并显我们已经提供了该测试情
的Otinnlo对象是相匹配的。
节的准础值。
// Simulate processing an order
这置没有做任何事情……但官善诉模加对累你应值城
mockAccessor.saveOrder(orderInfo) :
Odet2lo对象为季数，调用neOrde）.若则，表示
件事出了得，并应服出例外。
// Then the processor should call saveGC(...) with an empty GC
nockAccessor.saveGC(endGC);
提卷，模拟时象让uwGc0波调用，使用eicc礼益，模加花
费的正确金额。如果用这要值没有被课用，测试应错失险。
// And nothing else should get
called on our mock.
EasyMock.replay(mockAccessor);
请用upay(），所模拟对象相架“好的
// Create an OrderProcessor...
OrderProcessor processor = new OrderProcessor();
这像激活该对象：
processor.setDBAccessor(mockAccessor):
它现在已准务码
被使用
Receipt rpt = processor.processOrder (orderInfo);
这置是我们使用模加对象为DBAcc
// Validate receipt...
实成的警代物的地方：我们测试行单处理，
但不必为某个得定的别试象例编军实现
（或任何其他特定的测试象例）
这重看起来有振多工作要做，但是，我们
已岩下了一个类、如美增加别试持定礼系
的所有其他定化
那可是一件大事。
你持省下更多的类·…
目前位置
307
---
## Page 344
为何使用模拟对象？
没有愚囊的问题
它们能给我什么好处？
equals(）方法比较？
答：
正确——EasyMock测试Mock对象在执行期间
个接口的自定义的实现方法。看看303页，我们需要礼券获得的参数与通过equa1s（）方法原本说它应该得到的
的三种不网的变化（如果你把testnvalidGiftCard也算进来参数。这表示你必须为要用来当作参数的方法的类提供
的语）。其申的两个有不网的行为，不只是值不相网。没equals（）方法，还有其他比较运算将可帮助你处理像障列
有模拟对象，我们必频自己实现这些代码。你可以这样做，一样的东西，在郡里参考值也被比较，查看EasyMock文格
但何必呢？
(www.easymock.org/Documentation）可获得史多信也。
继续下去。感到该设计有点儿本末倒置。我们正在告诉
接口。由于礼券没有任何行为上的变化，因此，在这里安
排接口真没有太多意叉，第二，我们真正改变的是它返四
的值，因为、不管念样，它儿手就是简单的数据对象，我（Dependencyinjection），它出现在振多枢架中，特别是，
们可以在测试开始之相，通过实例化两个不同的礼券，得Spring枢架构建在关联性注入与控制逆转（Inversionof
到相同的结果，并且设定我们希望的值，在此使用模拟对control）的概念之上，一载来讲，关联性注入相当支持测
象（和需要的接口）有点儿“杀鸡用牛刀”。
试—尤其是在你必频隐藏某难看的东西的案例中，如
数视库或网络时，这都是有关关联性管理和对一个指定的
的地方都需要接口？
怒要多个实现的地方安排接口，这并不是很理想，但只要
你如通你正在增加仅供测试的接口，通常也没有什么大不
了的。一般地，能够以较少的测试代码有效地进行单元测
很多我们通过DBAccessor做的事情，工厂模式能创建不网
试所获得的价值，会超过这项要协所常要的代价。
种类的DBAccessors，然而、有签人觉得关联性注人比较干
问：什么是replay()方法所关系到的事？
净。它对你的设计有影响，确实常需在原本打算不安排接
口的地方增加接口，但那些通需不是你的设计会产生问题
的地方：它通常是代码中没有人费心去看的部分，因为时
间紧造，项目必须准时交付。
发生的事情，一旦调用replay)，它会验证部之后所得到
的任何方法调用。如果它得到它没有预期的调用、以不同
顺序或以不网的参数，就会据出意外（因而让你的测试失
败）。
308第8章
---
## Page 345
测试驱动开发
好软件是可测试的..
当设计软件时，有很多事情需要去思考：代码的重用性、干净的API、设计模式等。
同等重要的是去考虑你的代码的可测试性。我们已经讨论过一些可测试性的衡量方
法，如组织良好的代码和代码的测试覆盖率。然面，不要忘了，正因为你每次提交
代码时运行Unit，但不能保证你的代码是没有问题的。
几个有关测试的坏习惯，你需要小心：
一堆未能切中要害的测试
如果你是测试驱动开发的新手，很容易编写很多不起作用的测试代码。例如，你可
能编写了向Starbuzz下订单的测试代码，但在订单成立后，你没有检查礼券余额或
收据信息，“没有发生例外，太好了，继续前进”。这就好像在说，“编译成功
了，交付吧”。
焦点被模糊掉..
过于热切地想验证数据，很容易一头热地测试你一开始输送给系统的假数据。例
如，假设你编写了一段测试代码去检查礼券值和有效日期在你调用getGC（)时是正
确的。这是一个简化的例子，但如果你的测试进人到代码的多个分层时，真的很容
易忘记你原本打算要测试的东西。
过去的魔鬼
×
你需要特别地小心，每次你的自动化测试开始时，你的系统是处在一个已知的状
态。如果你没有一个已建立的模式来规范如何编写测试代码（像在每个测试结束
后，回滚数据库交易），很容易就会让一些乱七八槽的测试结果残留在系统之中。
甚至更槽糕的是编写的其他测试代码依赖这些东西。例如，想像一下，如果我们端
到端地测试一张订单，接着，后续的测试使用同一张礼券败“余额不足的礼券”的
测试。当这一对测试第二次执行时，会发生什么事情？如果有人刚好重新运行第二
个测试呢？每项测试都应该从一个已知的、可恢复的状态执行。
编写不良的测试代码的方式很多一—这些只是当中的少部分。使用搜索
引擎，做一个“TDD反面设计模式”的查询就会发现很多。然而，不要
让这些不良的测试把你吓住了—正如其他的事情一样，你编写的测试
代码越多，你就越能掌握其中的奥妙。
目前位置
309
---
## Page 346
全部绿灯，任务完成了
让测试通过并不容易.·
你做到了一
一通过策略设计模式、关联性注入（看前面的没有愚盘的问题）、模拟对象的
帮助，你拥有了真正的能力，但又不是太笨重的单元测试套件。你现在还有一堆测试，以
便确保系统一直做预先设定的任务。所以，为了保持系统在正轨上：
在你编写产品代码之前，总是先编写测试代码。
确认你的测试失败，然后实现最简单的，能使测试通过的事情。
每一项测试应该只测试一件事情：那可能表示有多个推断，但只针对一
个真实的概念。
?
一且你回到绿灯的状态（你的测试通过），你可以重构相关的代码，如
果你看到有什么事情不是这样的话。没有新的功能一—只是整理和重新
组织。
开始下一项测试，当你把所有的测试都解决了，任务也完成了。
当你的测试通过时，你就完成了任务
之前，我们没有办法真地知道何时完成了开发任务。你编写了一堆代码，可能运行了几次
以确认这些代码能运行，然后，继续前进，除非某个人说有问题，大多数开发人员不会回
头看。通过测试驱动开发，我们准确地知道何时能完成一究竞什么东西能运行。
我完全确定我定成了，事情账
手运行得不错。
EiEst
对
我们的测试件在工
又是856
310
第8章
Bo6，如累你还这么说，就把这本书据给图书馆吧
---
## Page 347
测试驱动开发
TDD填字游戏
以下是填字游戏的测试，填人答案使每一
个通过。
横排提示
竖排提示
2. You aint gonna need it.
3. Red, Green,
1. Fine grained tests.
5. TDO.
7. Wrte the.ode tha wll et the test to pass
4. When you should test.
6. Mock objects realize
8. Bad approaches to TDO are called
9. .... testing is essential to TDD.
10. TDD means writing tests 
11. To help reduce test code you can use
10. Your tests should .
..... at first.
12. To do effective TDD you need to have low.
objects.
13. To help reduce dependencies to real classes you can
esn
奢案见315页
目前位置
311
---
## Page 348
测试、红灯、编码、绿灯
测试驱动开发人员生
命中的一天…
?
从你即将为其工作的任务
一且你开发的应用程序通过了测试，你就知道你构建了什么
开始。
样的系统，程序的编码工作已就完成了。把代码调人到版
本控制工具中，版本控制工具会通知你的CI工具，它会聪
明地检查你的新的代码、构建它并运行测试。夜以继日地工
标，周礼券预订咖唯
作，甚至当Bob将一些破坏你的代码调入时…
接着，邮件自动发出了……
入礼异的号码，你的多字和基项的供
应店名、得点西摄义级得一个确以号、
余额和准音容略的信付时间。
优先级：
[20
任务：
博汉订单信
乌.礼信s
和收信息
/s
编写代码让你的测试通过，重构代码，增
一显你的代码通过测试，这时就慎
?
加另外一个测试，再让它通过。重复这个
把代码调入到存储目录中，并继续
循环，直到你完成所有增加进来的测试。
下一项任务.
所有的测试都应通过（C3工》
应诚持续确认这件事）
类实的实现代码
但是，事需上，遥过采用T00，Bo5立刻知还，
因为测试舍先验，他金知道到反弄怀了什么代础。
312
第8章
---
## Page 349
测试驱动开发
?
）为第一项功能片段编写第一个测
试程序。现在你处在红灯阶段。
?
编写最简单的实现代码，并能让它
通过测试，你现在处在绿灯阶段。
该项测试会失险，怎个人都
如递，温有美系！
?
重构你想整理的代码，然后编写下
段测试代码.再次处在红灯阶段。
PDG
你的第一项测试应该还是通过的—
但新的测试金先验，查到你实现新的。
租证合通过的代码，
目前位置
313
---
## Page 350
软件开发工具箱
软件开发工具箱
喜8
软件开发的宗旨就是要开发和交付伟大的软件。在本章中，
你学到了几项技术使你保持在正确的开发轨道上，本书完整
的工具清单，见附录i
本章要点
开发技术
TDD意味着你将多次重
这里是在本章你
构代码。很怕弄坏什么
先编写测试代码，再编写应
学到的一些美健
东西吗？只需要利用版
用程序代码让测试通过。
技术.··
本控制工具回滚到原先
你的测试一开始会失败，然
的地方，再试一次。
而，在它们通过后，你可以
有时候，测试会影响
进行重构。
你的设计
要知道当
一在运整技术览后
中的平衡点，谨慎地扶
使用模拟对象，提供测试需
-9
择，判断增加的可测试
要对象的各种变化。
性是否值得。
开发原则
使用策略设计模式并配
之以关联性注入，以帮
TDD通使你集中子系统的功能
助去耦合化的类。
性
把测试保存在与源代码
自动化测试让重构更安全
平行的日录之中，如
如果你弄坏了什么，你会立
tests/目录。大多数的
刻知道。
构建和自动化测试工具
能很好地配合这样的设
良好的代码覆盖率在TOD中比
置.
较容易成功。
尽量缩短构建和测试执
行的时间、所以，执行
全部的测试套件不会妨
得你的开发进度。
314
第8章
---
## Page 351
测试驱动开发
TDD填字游戏答案
以下是填字游戏的测试，填入答案使每一个
通过。
U
YAGN
REFACTOR
0
ME
T
S
m
r