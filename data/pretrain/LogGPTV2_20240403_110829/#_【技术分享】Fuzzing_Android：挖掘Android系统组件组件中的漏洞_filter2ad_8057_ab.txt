而让组件来解析我们的畸形文件用的是Stagefright命令行命令实现的 。最后通过使用定制的Crash分类机制来识别出独特的Crash。
**音频和视频作为攻击向量**
无论是在传统PC还是移动平台上,音频和视频文件都一直是最受欢迎的攻击向量.这样的一种现象的出现是有很多原因的.
1.多媒体文件格式一般比较复杂,往往包含很多复杂的数据结构.这样解析这些数据时,程序犯错的可能性就会很大.而且考虑到效率等因素解析多媒体文件格式的程序基本都是用C写的,这也很容易造成一个内存崩溃.
2.现在市面上有大量的多媒体文件解析器(播放器),他们对各种各样多媒体文件格式的解析方式不尽相同,这样一来攻击面又扩大了不少.
3.用户们普遍认为一个音频或者视频文件并不会造成什么实质性的影响,于是他们往往会去下载和播放未知来源的视频或音频.
4.可以未经用户明确同意播放音频或视频.比如:媒体文件在网页内播放，媒体文件通过MMS发送,这时系统会自动解析媒体文件.
**The Stagefright framework**
Stagefright框架在Android中负责解析各种多媒体文件的算法逻辑。 这个框架的一般体系结构可以在下图中观察到
Stagefright 只是媒体播放器AwesomePlayer的客户端.这个组件
实现了将视频和音频字幕源与相应的连接的功能，能够在播放用户提供的媒体文件时使视频与音频字幕同步。
MediaExtractor组件通过给定的媒体文件类型调用适当的数据解析器。 最后，为了准备播放，AwesomePlayer使用OMXCodec
组件，以便设置用于每个数据源的解码器
**开始Fuzzing**
stagefright命令行接口被用于在进行测试的Android设备上来解析每个恶意的媒体文件
它可以从Android源码树定制，其主要能力是对媒体文件进行解码/编码，强制使用 软件或硬件编解码器和用于音频文件的回放功能。
这个工具的完整的功能列表如下：
畸形文件数据的生成是在连接着正在测试的Android设备的本地机器上完成的。 这个过程通常使用Basic Fuzzing Framework,zzuf或
Fuzzbox这些开源的fuzz工具。 然后将畸形的文件发送到Android设备上，之后Android设备上通过使用
stagefright命令行接口对畸形文件进行解析 。 在fuzzing过程中 使用上一节中指定的格式生成日志。 下面是一个在fuzzing
Stagefright框架(媒体文件使用BFF变异)过程中收集到的日志:
**  
**
**Fuzzing the application install process in Android**
对于这个特定的项目，fuzzing已被用来使用多种方法修改APK的不同组件，并检查这如何影响Android中的安装过程。APK的内部的主要目标是由程序代码编译得到的
classes.dex和 AndroidManifest.xml文件。事实上在apk的安装过程中其中一个 installd进程是以较高的系统
特权运行的，这使得这个组件成为一个非常有吸引力的目标，因为在fuzzing期间发现的任何问题的可以在系统安全层面产生很大的影响。
本节将概述项目中会涉及的Android进程。
此外，该部分还会介绍两种不同的fuzz方法(用来测试两种不同的安卓版本:KitKat和Lollipop),在实际的fuzzing过程,他们会被视为一个单独的主题。
**Android中应用程序安装过程的概述**
PackageInstaller是Android上负责安装其他应用程序的默认应用程序。 包安装器调用InstallAppProgress
activity来接收来自用户的指令。 此activity调用 Package Manager Service中以system权限运行的installd
守护进程来安装apk，并且其主要功能是接收来自Package Manager Service的请求。
在安装apk时系统地会调用两个主要的方法run_dexopt(KitKat)以及 run_dex2oat(ART)他们实际上是使用了dexopt
和dex2oat两个命令行工具.这就是这次fuzzing的主要目标了.一个apk文件中有四个我们感兴趣的组件分别为,classes.dex
manifest文件,META-INF文件夹,lib文件夹.
下图为各个组件的概览.
我们写的Android app的代码最后会被编译成.dex文件,并使用zip打包成为apk文件.下面是dex文件格式的一个概览.
具体的文件格式可以参考:[http://blog.sina.com.cn/s/blog_66d7a4550101bkqg.html](http://blog.sina.com.cn/s/blog_66d7a4550101bkqg.html)
**开始Fuzzing**
这次的fuzzing考虑到了两个不同的Android版本,分别为KitKat和Lollipop.
**Fuzzing KitKat**
尽管dexopt可以作为一个独立的二进制程序在命令行中被使用,但是他却不能被用于fuzzing,原因是他需要非常多的参数,而且有些参数还不能通过shell环境变量传递给他.在这样的一种情况下我们的fuzz采用了正常的apk过程来使程序运行我们的测试数据.大体思路是:拿到大量的合法的apk文件,然后对他们中的classs.dex
文件进行变异,之后在重打包为apk文件,最后把他交给Android的安装apk的进程去处理,并且监控其是否发生崩溃.
以下是一些具体步骤:
1.从种子apk文件中解压出classes.dex文件 : unzip –d  
2.fuzz解压出的dex文件:  –s  classes.dex > fuzzed.dex
3.在原来的apk文件中移除掉原来的dex文件: aapt r  classes.dex
4.使用fuzz得到的dex文件重打包为一个新的apk文件: aapt r  classes.dex
5.生成签名文件: keytool -genkey -v -keystore keystore.keystore -alias keystore
-keyalg RSA -keysize 2048 -validity 10000
6.移除apk中的META-INF目录: zip –delete  META-INF/*
7.用我们刚刚生成的签名文件对apk签名.:jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1
-keystore   <keystore_alias
下面是在fuzz kikat时的部分日志.
**Android Lollipop**
和dexopt不同,dex2oat这个程序可以使用它的命令行参数来完成解析dex文件的工作,那么我们的fuzz就使用了这个工具的命令行接口来进行后续的fuzz.他需要两个参数分别为:
输入的dex文件,和输出的 oat文件.其参数列表如下:
那么在Lollipop上进行fuzz的思路就是,首先拿到一个初始化的dex文件集(可以从之前的那些apk文件中提取),然后对他们进行变异,之后把变异后的文件交给dex2oat去解析.如果检测到了崩溃,我们还需要把dex文件重新打包到apk文件中,然后使用apk的安装流程再次测试来确认这是一个可以重现的Crash.
下面是一个fuzz的日志的例子.
**在Android上使用AFL**
AFL是现在比较流行的一个Fuzz工具,他原本是运行在linux PC上的,后面经过Adrian
Denkiewicz的修改使得我们可以在Android上使用这款神器.
**Using AFL for Stagefright fuzzing**
在Android上使用AFL的一个最大的挑战就是怎样完全自动化的进行整个Fuzzing过程.下面一个大体的思路.
为了实现更加好的自动化fuzz效果使用了如下的架构.
**总结**
Fuzz安卓的一些系统组件和Fuzz其他的位于PC的程序在本质上并无区别,只是在提交测试数据给程序执行这一步需要做的工作会更多以及对程序Crash的日志监控机制还不是太完善.