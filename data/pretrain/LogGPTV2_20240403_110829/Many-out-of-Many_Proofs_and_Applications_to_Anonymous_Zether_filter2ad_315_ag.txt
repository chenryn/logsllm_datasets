cure payment (such as those concerning “front-running” [6,
§3.1] and replay protection), and also admits an efﬁcient wal-
let. Zether features constant storage per-user, which moreover
is automatic.
Zether is conﬁdential (in the sense of hiding transaction
amounts), but is not anonymous (in the sense of hiding partici-
pants’ identities) or deniable. An appendix [6, §D] suggests the
anonymous approach pursued by this paper. Our Anonymous
Zether construction efﬁciently combines the attractive features
of Zether with anonymity.
The attributes of this section are summarized in Table I.
I. Performance
We now describe our
implementation is open-source,
implementation of Anonymous
Zether. This
available
at github.com/benediamond/anonymous-zether.
Surprisingly, Anonymous Zether is competitive—in traditional
measures of efﬁciency (that
is, proving time, veriﬁcation
time, and proof size)—with the standalone cryptocurrencies
Zcash, Monero and Quisquis, despite its additional advantages
(see Table I) and the fact
it operates entirely within
an Ethereum smart contract (a highly constrained computing
environment).
that
Our implementation is fully equipped for use “today”. It
not only supports the generation and veriﬁcation of proofs,
but also includes a fully-featured, efﬁcient wallet.
Each Anonymous Zether contract necessarily interoperates
with some ERC-20-compliant token contract. Given an Anony-
mous Zether contract, our client may either generate a new
account or “mount” an existing one (whose private key has
been supplied). Mounting entails querying only 128 bytes from
an untrusted full node, and furthermore takes place in constant
time (i.e., it need not scan through prior transactions). Our
client’s “fund” and “burn” methods facilitate the transfer of
ERC-20 funds (of the appropriate type) into and out of, respec-
tively, the Anonymous Zether contract’s escrow pool. Finally,
our client’s “transfer” method fully encapsulates the process
of constructing a statement, generating a proof, dispatching
both to the Anonymous Zether contract, and ﬁnally updating
the wallet’s local account state appropriately (if the transaction
succeeds). It also asynchronously receives incoming transfers,
using Ethereum’s “event” system.
Our web3-based wallet is written in JavaScript; proving
takes place in a Node.js module. Veriﬁcation takes place in
Solidity contracts. We use only native Solidity code, and do
not introduce ad-hoc precompiles.
We report online performance measurements in Table II.
Each number next to “Tr” (i.e., “Transfer”) indicates the size
of the anonymity set used (including the actual sender and
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:00 UTC from IEEE Xplore.  Restrictions apply. 
1812
TABLE I: Attributes of various anonymous cryptocurrencies.
System
Zcash
Monero
Lelantus
Quisquis
Basic Zether
Anon. Zether
Standard
Assumptions
and No
Trusted Setup
Strong
Anonymity
Deniability
Direct
Payments w/o
Out-of-Band
Comm.
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Full Node’s
Storage is
Constant Per
User
Tx. Overhead
Independent
of Amt. of
Funds Spent
?
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Honest
Transactions
Necessarily
Succeed
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
Efﬁcient
Wallet
(cid:88)
(cid:88)
recipient). For typographical reasons, we suppress the O(·)
in each entry of the bottom row, which records asymptotic
behavior. Our proving times were obtained on a standard
MacBook Pro, with a 2.6GHz Intel Core i7 processor. The
veriﬁcation time given reﬂects the time taken by the local EVM
in evaluating a read-only call to the veriﬁcation contract. Our
proof size assumes 32-byte ﬁeld elements and 64-byte (i.e.,
uncompressed) points, as Ethereum’s precompiled contracts
require. Our transaction size reﬂects the size of the full
Solidity ABI-encoded data payload, which itself includes both
a statement and its proof. Gas used incorporates not just
veriﬁcation itself, but also the relevant account maintenance
associated with the Zether Smart Contract; our gas measure-
ments do incorporate EIP-1108.
TABLE II: Transaction benchmarks, by anonymity set size.
Prv. Time
(ms)
820
1,618
1,754
1,942
2,478
3,530
5,987
N log N
Vf. Time
(ms)
45
68
80
100
152
265
502
N log N
Prf. Size
(bytes)
1,152
2,048
2,624
3,200
3,776
4,352
4,928
log N
Tx. Size
(bytes)
1,380
2,628
3,460
4,548
6,148
8,772
13,444
N
Gas Used
(units)
2,323,693
4,798,095
5,626,028
7,306,703
10,890,953
18,690,516
36,152,558
N log N
Burn
Tr (2)
Tr (4)
Tr (8)
Tr (16)
Tr (32)
Tr (64)
Tr (N)
In Table III, we compare our protocol concretely to others
along more traditional metrics. We emphasize that Zcash and
Monero depend on the number of input and output UTXOs
consumed and produced. We thus restrict to transactions in
which two (shielded) UTXOs are consumed and two are
produced, and use 10 mix-ins per UTXO in Monero. For fair
comparison, we ﬁx anonymity sets of size 16 in Quisquis and
Anonymous Zether.
A few additional factors complicate the comparison. Zcash,
Monero and Quisquis use compressed (33-byte) point rep-
resentations, whereas Ethereum’s precompiles—and hence
Anonymous Zether—do not; this “inﬂates” our transaction
sizes. Additionally, our prover and veriﬁer are written in
JavaScript and Solidity; Zcash, Monero and Quisquis are
written in C++ and Go. This language difference plausibly
inﬂates our prover and veriﬁer time by an order of magnitude.
TABLE III: Direct performance comparisons.
Zcash
Monero
Quisquis
Anonymous Zether
Proving Time
(ms)
5,600
982
471
2,478
Verif. Time
(ms)
9
46
72
170
Transaction Size
(bytes)
2,757
2,543
26,060
6,148
We stress again that Zcash and Monero depend on the
quantity of funds spent, whereas Quisquis and Anonymous
Zether do not. For example, ﬁxing N = 16, our transactions
become smaller than Monero’s as soon the latter consumes 7
UTXOs or more (with the number of output UTXOs again
ﬁxed at 2). Our proving time is faster than Zcash’s so long as
at least 2 Sapling notes are spent.
We compare in further detail our transaction sizes with those
of Quisquis. Our full transactions feature 2N + 8 log(N ) +
20 group elements and 2 log(N ) + 10 ﬁeld elements (plus
an additional 196 bytes used in the Solidity ABI encoding).
√
Quisquis’s (assuming the amount of recipients t = 1) contain
N +39 ﬁeld
30N +22
elements. Were an uncompressed point representation used in
both systems, this would amount, in the case N = 16, to total
transaction sizes of 6.1 kB and 45.3 kB, respectively.
√
N +52 group elements and 6N +10
ACKNOWLEDGMENT
I would like to thank Markulf Kohlweiss and Michele
Ciampi for many helpful discussions and suggestions.
DISCLAIMER
This paper was prepared for informational purposes by the
Artiﬁcial Intelligence Research group of JPMorgan Chase &
Co. and its afﬁliates (“J.P. Morgan”), and is not a product of
the Research Department of J.P. Morgan. J.P. Morgan makes
no representation and warranty whatsoever and disclaims all
liability, for the completeness, accuracy or reliability of the
information contained herein. This document is not intended
as investment research or investment advice, or a recommen-
dation, offer or solicitation for the purchase or sale of any
security, ﬁnancial instrument, ﬁnancial product or service, or
to be used in any way for evaluating the merits of participating
in any transaction, and shall not constitute a solicitation under
any jurisdiction or to any person, if such solicitation under
such jurisdiction or to such person would be unlawful.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:14:00 UTC from IEEE Xplore.  Restrictions apply. 
1813
REFERENCES
[1] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system.” 2008.
[2] D. Ron and A. Shamir, “Quantitative analysis of the full Bitcoin
transaction graph,” in Financial Cryptography and Data Security (A.-R.
Sadeghi, ed.), (Berlin, Heidelberg), pp. 6–24, Springer Berlin Heidel-
berg, 2013.
[3] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer,
and M. Virza, “Zerocash: Decentralized anonymous payments from
Bitcoin,” in 2014 IEEE Symposium on Security and Privacy, pp. 459–
474, 2014. Full version.
[4] S. Noether, A. Mackenzie, and the Monero Research Lab, “Ring
conﬁdential transactions,” Ledger, vol. 1, pp. 1–18, May 2016.
[5] P. Fauzi, S. Meiklejohn, R. Mercer, and C. Orlandi, “Quisquis: A new
design for anonymous cryptocurrencies,” in Advances in Cryptology
– ASIACRYPT 2019 (S. D. Galbraith and S. Moriai, eds.), Springer
International Publishing, 2019.
[6] B. B¨unz, S. Agrawal, M. Zamani, and D. Boneh, “Zether: Towards
privacy in a smart contract world,” in International Conference on
Financial Cryptography and Data Security, 2020. Full version.
[7] B. B¨unz, L. Kiffer, L. Luu, and M. Zamani, “Flyclient: Super-light
clients for cryptocurrencies,” in 2020 IEEE Symposium on Security and
Privacy, pp. 928–946, 2020.
[8] E. Stefanov, M. V. Dijk, E. Shi, T.-H. H. Chan, C. Fletcher, L. Ren,
X. Yu, and S. Devadas, “Path ORAM: An extremely simple oblivious
ram protocol,” Journal of the ACM, vol. 65, Apr. 2018.
[9] J. Groth and M. Kohlweiss, “One-out-of-many proofs: Or how to leak
a secret and spend a coin,” in Advances in Cryptology – EUROCRYPT
2015 (E. Oswald and M. Fischlin, eds.), vol. 9057 of Lecture Notes in
Computer Science, pp. 253–280, Springer Berlin Heidelberg, 2015.
[10] J. Bootle, A. Cerulli, P. Chaidos, E. Ghadaﬁ, J. Groth, and C. Petit,
“Short accountable ring signatures based on DDH,” in Computer Secu-
rity – ESORICS 2015 (G. Pernul, P. Y A Ryan, and E. Weippl, eds.),
vol. 9326 of Lecture Notes in Computer Science, pp. 243–265, Springer
International Publishing, 2015.
[11] M. F. Esgin, R. Steinfeld, A. Sakzad, J. K. Liu, and D. Liu, “Short lattice-
based one-out-of-many proofs and applications to ring signatures,” in