        .long sys_muhe_test
        .long sys_hello
**2\. 定义syscall的宏**
文件arch/x86/include/asm/unistd_32.h中添加
    #define __NR_hello 337
    #define __NR_muhe_test    338
    #ifdef __KERNEL__
    #define NR_syscalls 339
要注意NR_syscalls要修改成现有的调用数目，比如原来有0~336一共337个调用，现在增加了两个，那就改成339。
**3\. 添加函数定义**
文件include/linux/syscalls.h
    asmlinkage long sys_muhe_test(int arg0);
    asmlinkage long sys_hello(void);
**4\. 编写syscall代码**
新建目录放自定义syscall的代码
    # muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test [2:43:06] 
    $ cat muhe_test.c
    #include 
    asmlinkage long sys_muhe_test(int arg0){
        printk("I am syscall");
        printk("syscall arg %d",arg0);
        return ((long)arg0);
    }
    asmlinkage long sys_hello(void){
        printk("hello my kernel worldn");
        return 0;
    }
    # muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test [2:43:12] 
    $ cat Makefile
    obj-y := muhe_test.o
**5\. 修改Makefile**
    # muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1 [2:44:59] 
    $ cat Makefile| grep muhe
    core-y        += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ muhe_test/
**6\. 编译**
    make -j2
我虚拟机分配了两个核，所以使用-j2 这样能稍微快一点。
**0x04: busybox编译配置**
**1\. 编译步骤**
    $ make menuconfig
    $ make
    $ make install
**2\. 遇到的问题**
**2.1 问题一以及解决方案**
错误
        loginutils/passwd.c:188:12: error: ‘RLIMIT_FSIZE’ undeclared (first use in this function)
      setrlimit(RLIMIT_FSIZE, &rlimit_fsize);
解决
    $  vim include/libbb.h
    $  add a line #include 
    #include 
    #include 
    #include 
**2.2 问题二以及解决方案**
错误
        linux/ext2_fs.h: 没有那个文件或目录
解决
        Linux System Utilities --->
            [ ] mkfs_ext2 
            [ ] mkfs_vfat
**3\. 编译完成之后如下配置**
**1\. 方案1**
    $ cd _install
    $ mkdir -pv {bin,sbin,etc,proc,sys,usr/{bin,sbin}}
    $ cat init
    #!/bin/sh
    echo "INIT SCRIPT"
    mount -t proc none /proc
    mount -t sysfs none /sys
    mount -t debugfs none /sys/kernel/debug
    mkdir /tmp
    mount -t tmpfs none /tmp
    mdev -s # We need this to find /dev/sda later
    echo -e "nBoot took $(cut -d' ' -f1 /proc/uptime) secondsn"
    exec /bin/sh
    $ chmod +x init
    $ find . -print0 
        | cpio --null -ov --format=newc 
        | gzip -9 > /tmp/initramfs-busybox-x86.cpio.gz
    $ qemu-system-i386 -kernel arch/i386/boot/bzImage -initrd /tmp/initramfs-busybox-x86.cpio.gz
**2\. 方案2**
后面为了方便，使用了另一种方式：
目录结构和之前差不多，添加inittab文件：
    $ cat etc/inittab 
    ::sysinit:/etc/init.d/rcS
    ::askfirst:/bin/ash
    ::ctrlaltdel:/sbin/reboot
    ::shutdown:/sbin/swapoff -a
    ::shutdown:/bin/umount -a -r
    ::restart:/sbin/init
添加rcS文件
    $ cat etc/init.d/rcS 
    #!/bin/sh
    #!/bin/sh
    mount -t proc none /proc
    mount -t sys none /sys
    /bin/mount -n -t sysfs none /sys
    /bin/mount -t ramfs none /dev
    /sbin/mdev -    $ chmod +x ./etc/init.d/rcS
配置下dev目录
    mkdir dev
    sudo mknod dev/ttyAMA0 c 204 64
    sudo mknod dev/null c 1 3
    sudo mknod dev/console c 5 1
    $ find . | cpio -o --format=newc > ../rootfs.img
    $ qemu-system-i386 -kernel arch/i386/boot/bzImage -initrd ../busybox-1.19.4/rootfs.img -append "root=/dev/ram rdinit=/sbin/init"
**0x05: 测试系统调用**
    # muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1 [2:45:04] 
    $ cd muhe_test_syscall_lib 
    # muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test_syscall_lib [2:51:48] 
    $ cat muhe_test_syscall_lib.c
    #include 
    #include 
    #include 
    int main(int argc,char **argv)
    {
            printf("n Diving to kernel levelnn");
            syscall(337,1337);
            return 0;
    }
    # muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test_syscall_lib [2:51:51] 
    $ gcc muhe_test_syscall_lib.c -o muhe -static
一定要静态链接，因为你进busybox链接库那些是没有的。
    # muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1/muhe_test_syscall_lib [2:52:20] 
    $ cp muhe_test_syscall_lib/muhe ../busybox-1.19.4/_install/usr/muhe
这里要注意，每次拷贝新文件到busybox的文件系统中去，都要执行find . | cpio -o –format=newc >
../rootfs.img去生成新的rootfs。
然后qemu起系统
    # muhe @ ubuntu in ~/linux_kernel/linux-2.6.32.1/linux-2.6.32.1 [2:53:33] 
    $  qemu-system-i386 -kernel arch/i386/boot/bzImage -initrd ../busybox-1.19.4/rootfs.img -append "root=/dev/ram rdinit=/sbin/init"
**0x06:引用与参考**
[adding-hello-world-system-call-to-linux](https://arvindsraj.wordpress.com/2012/10/05/adding-hello-world-system-call-to-linux/)
[Adding a new system call to the Linux
kernel](http://www.cs.rochester.edu/~sandhya/csc256/)
[Adding a system call in X86 QEMU
Environment](http://linuxseekernel.blogspot.ie/2014/07/adding-system-call-in-x86-qemu.html)
[Create a simple file
system](http://linuxseekernel.blogspot.com/2014/06/create-simple-file-system.html)
[Setup for linux kernel dev using
qemu](https://beyermatthias.de/blog/2016/11/01/setup-for-linux-kernel-dev-using-qemu/)
[root-file-system-for-embedded-system](http://blog.3mdeb.com/2013/06/07/root-file-system-for-embedded-system/)
**传送门**
* * *
[**【系列分享】Linux
内核漏洞利用教程（二）：两个Demo**](http://bobao.360.cn/learning/detail/3702.html)