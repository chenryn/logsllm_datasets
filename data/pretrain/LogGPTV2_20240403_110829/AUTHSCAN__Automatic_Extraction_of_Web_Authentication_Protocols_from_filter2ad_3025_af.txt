veriﬁcation time for ProVerif is within 1 minute in our case
studies. It shows that the security-relevant parts of the pro-
tocols generated are usually small. We ﬁnd that additional
source code results in the reduced number of iterations in
our blackbox fuzzing step. For example, in BrowserID,
the client-side code is available, therefore, the number of
fuzzing iterations is smaller (20-30 rounds) than other SSO
protocols (30-500 rounds as shown in the sixth column,
Table 2). Our data shows that AUTHSCAN’s protocol ex-
traction step is sufﬁcient to ﬁnd ﬂaws even when much of
the protocol implementation is unavailable as shown in the
Facebook case.
Redundant Data Reduction. When querying off-the-shelf
veriﬁcation tools like ProVerif, it is important to remove re-
dundant terms for better scalability. As shown in Table 2,
AUTHSCAN ﬁnds that the majority of the messages (more
than 80%) and HTTP parameters (more than 50%) are irrel-
evant to the protocol and AUTHSCAN can successfully ﬁlter
them out. This shows that an automatic tool is helpful in
constructing the models from the complicated implementa-
tion details. Furthermore, this reduction helps greatly in re-
ducing the veriﬁcation time. For BrowserID, ProVerif does
not terminate within one hour if we naively retain all terms
exchanged in the communication. In summary, we ﬁnd the
AUTHSCAN has promising scalability for real-world secu-
rity protocol implementations.
7 Related Work
Protocol Speciﬁcation & Veriﬁcation. Security protocol
veriﬁcation has been well studied in the literature. Many
logics and calculi have been proposed to formally spec-
ify the security protocols and security properties, such as
BAN logic [13, 21], WL model [44], Spi-calculus [12]. A
number of automatic veriﬁcation tools have been developed
and used to check the correctness of the security proto-
cols, such as Athena [37], ProVerif [18], Murphi [34] and
AVISPA [10]. These works focus on verifying the high-
level speciﬁcations of the security protocols. However, our
approach focuses on how to extract the high-level protocol
speciﬁcation from the implementations.
Protocol Extraction. Works on automatically extracting
models from the protocol implementations are most related
to this work. Lie et al. [30] have proposed a method to
automatically extract speciﬁcations from the protocol code.
The model is extracted using program slicing and veriﬁed
by Murphi tool. Aizatulin et al. [14] have proposed model
extraction using symbolic execution. These works extract
the protocol speciﬁcations from the source code, while our
approach does not assume to have the source code and pro-
vides blackbox fuzzing to infer the semantics when the
source code is not available.
Security Analysis on SSO Protocols.
Extensive re-
search has been conducted to manually analyze security
of SSO protocols. By reverse enginerrring the client
implementations, Hanna et al. [27] have revealed that
some SSO protocols,
including Facebook Connect and
Google Friend Connect, use the cross-domain communi-
cation channel–postMessage insecurely, E.Tsyrklevich
and V.Tsyrklevich [40] have demonstrated several attacks
such as CSRF against the OpenID protocol. Wang et al.’s
work [42] have conducted a ﬁeld study on the commercially
deployed web SSO systems and discovered 8 serious logic
ﬂaws in many notable IDPs and SPs. Xing et al. [45] have
attempt to protect integrators for their integration of third-
party SSO Web services.
Some formal analysis approaches also have been used
to analyze the security of SSO protocols. Miculan and Ur-
ban [33] manually extract speciﬁcation of Facebook Con-
nect Protocol from the HTTP messages exchaged. They
model the protocol in HLSPL and check it using AVISPA.
Bansal et al. [17] use applied pi-calculus and ProVerif to
analyze the OAuth 2.0 protocol. Their work focuses on con-
structing concrete attacks from the attack trace reported by
ProVerif, and building the operational web attacker model
library called WebSpi to map the attack trace to web-site
actions. Sun et al. [39] also model the web attacker pre-
cisely. Sun et al.manually extract OpenID 2.0 implemen-
tation in HLPSL and verify the model using AVISPA and
found CSRF attacks. There are also other formal analy-
sis approaches on SSO protocol. Most of them model the
protocol manually based on the protocol documentation or
speciﬁcation, and take into consideration only the network
attack model. For example, there have been several formal
analysis approaches on SAML SSO protocols [16, 26, 28].
In contrast to these work, AUTHSCAN looks at the security
ﬂaws in the implementations.
8 Conclusion
We present AUTHSCAN, an end-to-end platform to au-
tomatically recover authentication protocol speciﬁcations
from their implementations. AUTHSCAN has successfully
detected 7 security vulnerabilities in real-world applications
automatically. Our techniques assume no knowledge of the
protocol speciﬁcations being checked and rely on a small set
of practical assumptions. We hope further research can lead
to tools that recover and check complicated security proto-
cols at the lowest level of their implementation details.
Acknowledgments
We thank our shepherd Venkat Venkatakrishnan and the
anonymous reviewers for their insightful comments to im-
prove this manuscript. We also thank Matthew Finifter, Joel
Weinberger, Jun Pang, Yacin Nadji, Joseph Hong, Bod-
hisatta Roy and Mayank Dhiman for their helpful feed-
back and comments. This research is partially supported
by research grant R-252-000-495-133 from Ministry of Ed-
ucation, Singapore, research project “Automatic Checking
and Veriﬁcation of Security Protocol Implementations” and
“Research and Development in the Formal Veriﬁcation of
System Design and Implementation”.
References
[1] AUTHSCAN. https://sites.google.com/site/ndss2013/.
[2] BrowserID.
https://wiki.mozilla.org/
Identity/BrowserID.
[3] Facebook
Connect
Authentication.
http://developers.facebook.com/docs/authentication/.
[4] Node.js
Manual
http://nodejs.org/api/crypto.html.
v0.8.14
&
Documentation.
[5] What is OpenID. http://openid.net/get-an-openid/what-is-
openid/.
[6] Windows Live Messenger Connect, Version
4.1.
http://msdn.microsoft.com/en-us/library/ff749458.aspx.
[7] Facebook Connect Used By 250 Million People Per
Month. http://allfacebook.com/facebook-connect-used-by-
250-million-people-per-month b25501, Dec. 8, 2010.
[8] Security Vulnerability Allegedly Discovered in Drop-
http://news.softpedia.com/news/Design-
box Client.
Security-Flaw-Allegedly-Discovered-in-Dropbox-Client-
194427.shtml, Apr. 11, 2011.
[9] Mozilla jwcrypto. https://github.com/mozilla/
jwcrypto, May 13, 2012.
[10] The AVISPA project homepage.
http://www.
avispa-project.org/, May 13, 2012.
[11] Wolfram alpha. http://www.wolframalpha.com/,
May 13, 2012.
[12] M. Abadi and A. D. Gordon. A Calculus for Cryptographic
Protocols: The spi Calculus. Information and Computation,
148(1):1–70, 1999.
[13] M. Abadi and M. R. Tuttle. A Semantics for A Logic of
Authentication (Extended Abstract). In PODC, pages 201–
216, 1991.
[14] M. Aizatulin, A. D. Gordon, and J. J¨urjens. Extracting and
Verifying Cryptographic Models from C Protocol Code by
Symbolic Execution. In CCS, pages 331–340, 2011.
[15] D. Akhawe, A. Barth, P. E. Lam, J. Mitchell, and D. Song.
In CSF,
Towards a Formal Foundation of Web Security.
pages 290–304, 2010.
[16] A. Armando, R. Carbone, L. Compagna, J. Cuellar, and
L. Tobarra. Formal Analysis of SAML 2.0 Web Browser
Single Sign-On: Breaking the SAML-based Single Sign-On
for Google Apps. In FMSE, pages 1–10, 2008.
[17] C. Bansal, K. Bhargavan, and S. Maffeis. Discovering Con-
crete Attacks on Website Authorization by Formal Analysis.
In CSF, pages 247–262, 2012.
[18] B. Blanchet. An Efﬁcient Cryptographic Protocol Veriﬁer
Based on Prolog Rules. In CSFW, pages 82–96, 2001.
[19] B. Blanchet. Computationally Sound Mechanized Proofs of
Correspondence Assertions. In CSF, pages 97–111, 2007.
[20] B. Blanchet and A. Chaudhuri. Automated Formal Analysis
of a Protocol for Secure File Sharing on Untrusted Storage.
In S&P, pages 417–431, 2008.
[21] M. Burrows, M. Abadi, and R. Needham. A Logic of
Authentication. ACM Transactions On Computer Systems,
8:18–36, 1990.
[22] C. J. Cremers. The Scyther Tool: Veriﬁcation, Falsiﬁcation,
and Analysis of Security Protocols. In CAV, pages 414–418,
2008.
[23] G. Delzanno and P. Ganty. Automatic Veriﬁcation of Time
Sensitive Cryptographic Protocols. In TACAS, pages 342–
356, 2004.
[24] D. Dolev and A. Yao. On the Security of Public Key Pro-
tocols. IEEE Transactions on Information Theory, 29:198–
208, 1983.
[25] D. E.Hammer-Lahav and D.Hardt. The OAuth2.0 Autho-
rization Protocol. 2011. IETF Internet Draft.
[26] T. Gross. Security Analysis of the SAML Single Sign-On
Browser/Artifact Proﬁle. In ACSAC, pages 298 – 307, 2003.
[27] S. Hanna, E. C. R. Shinz, D. Akhawe, A. Boehmz, P. Saxena,
and D. Song. The Emperor’s New API: On the (In)Secure
Usage of New Client Side Primitives. In W2SP, 2010.
[28] S. M. Hansen, J. Skriver, and H. R. Nielson. Using Static
Analysis to Validate the SAML Single Sign-On Protocol. In
WITS, pages 27–40, 2005.
[29] S. Juraj, M. Andreas, S. J¨org, K. Marco, and J. Meiko. On
Breaking SAML: Be Whoever You Want to Be. In USENIX
Security, 2012.
[30] D. Lie, A. Chou, D. Engler, and D. L. Dill. A Simple Method
In ISCA, pages
for Extracting Models for Protocol Code.
192–203, 2001.
[31] G. Lowe. Breaking and Fixing the Needham-Schroeder
Public-Key Protocol Using FDR. In TACAS, pages 147–166,
1996.
[32] G. Lowe. A Hierarchy of Authentication Speciﬁcations. In
CSFW, pages 31–43, 1997.
[33] M. Miculan and C. Urban. Formal Analysis of Facebook
Connect Single Sign-On Authentication Protocol. In SOF-
SEM, pages 99–116, 2011.
[34] J. C. Mitchell, M. Mitchell, and U. Stern. Automated Anal-
ysis of Cryptographic Protocols Using Murphi. pages 141–
151. IEEE Computer Society Press, 1997.
[35] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and
D. Song. A Symbolic Execution Framework for JavaScript.
In S&P, pages 513–528, 2010.
[36] P. Saxena, S. Hanna, P. Poosankam, and D. Song. FLAX:
Systematic Discovery of Client-side Validation Vulnerabili-
ties in Rich Web Applications. In NDSS, 2010.
[37] D. X. Song. Athena: A New Efﬁcient Automatic Checker
for Security Protocol Analysis. In CSFW, pages 192–202,
1999.
[38] J. Sun, Y. Liu, J. S. Dong, and J. Pang. PAT: Towards Flex-
In CAV, pages 709–714,
ible Veriﬁcation under Fairness.
2009.
[39] S.-T. Sun, K. Hawkey, and K. Beznosov. Systematically
Breaking and Fixing OpenID Security: Formal Analysis,
Semi-Automated Empirical Evaluation, and Practical Coun-
termeasures. Computers & Security, 31:465–483, 2012.
[40] E. Tsyrklevich and V. Tsyrklevich. Single Sign-On for the
Internet: A Security Story. In BlackHat, July 2007.
[41] D. Wagner and B. Schneier. Analysis of the SSL 3.0 proto-
col. In WOEC, volume 2, pages 29–40, 1996.
[42] R. Wang, S. Chen, and X. Wang. Signing Me onto Your
Accounts through Facebook and Google: a Trafﬁc-Guided
Security Study of Commercially Deployed Single-Sign-On
Web Services. In S&P, pages 365–379, 2012.
[43] T. Wang, T. Wei, G. Gu, and W. Zou.
TaintScope:
A Checksum-Aware Directed Fuzzing Tool for Automatic
Software Vulnerability Detection. In S&P, May 2010.
[44] T. Y. C. Woo and S. S. Lam. A Semantic Model for Authen-
tication Protocols. In S&P, pages 178–194, 1993.
[45] L. Xing, Y. Chen, X. Wang, and S. Chen. InteGuard: To-
ward Automatic Protection of Third-Party Web Service In-
tegrations. In NDSS, 2013.
A Termination of Algorithm 1
We informally argue why the Algorithm 1 terminates.
First, since AUTHSCAN uses only one trace t as the basis to
generate the P roSet which has a ﬁxed number of local pro-
tocols and free variables. The newly generated traces in the
fuzzing step do not generate new local protocols and vari-
ables, but infer more TML terms over these variables and
add new actions. Second, for each HTTP data, AUTHSCAN
generates two probes: one in which the data is removed and
the other in which the data is mutated. Thus, for a message
containing N HTTP data elements, only 2N probes are gen-
erated. Third, after each iteration (step 4-9), the number of
variables inferred is monotonically non-increasing; we can
only remove certain variables as redundant data. Finally, by
bounding the nesting function depth and number of traces
in trP ool, all searches and fuzzing operates over ﬁnite state
and must terminate.
B Protocol Extraction
B.1 Extracting BrowserID Protocol
In this section, we detail
the process on analyzing
myfavoritebeer.org to demonstrate how AUTH-
SCAN extracts model from the implementation. As shown
in Figure 5, the traces captured by AUTHSCAN are listed
in the ﬁrst two columns, and the corresponding TML state-
ments inferred are placed in the third column.
that
From message (4),
From message (2), AUTHSCAN infers the HTTP pa-
rameter csrf as a nonce. AUTHSCAN also associates
user name (USER) and password (PWD) to represent that
they should be matching.
through
white box analysis, AUTHSCAN infers that spkUser
and spkUser−1 are an asymmetric key pair generated
by function generateKeypair().
In message (5),
the HTTP parameter cert
AUTHSCAN ﬁgures out
is encoded as a JSON Web Token (JWT) with each
segment separated with “.”
and encoded with Base64
encoding (as described in Section 4.2). When apply-
ing the signature veriﬁcation algorithm RSA over one
of the segment (the brute-force search as discussed in