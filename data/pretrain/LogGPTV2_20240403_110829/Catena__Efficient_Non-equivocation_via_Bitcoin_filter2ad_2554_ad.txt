### Transaction Visibility and Equivocation Prevention
Similarly, it shows client c2 the transaction for s2 and hides the one for s1. As a result, the log server can easily equivocate to clients who do not verify transaction chaining, as they cannot ensure the server is not hiding an inconsistent statement. In Catena, clients prevent this attack by verifying that every statement they accept is part of a transaction that spends the previous transaction’s continuation output, thereby chaining all the way back to the genesis transaction.

### Blockchain Reorganizations
Like Bitcoin, Catena must also handle small, day-to-day accidental forks or blockchain reorganizations (see §II-B3). These small forks are automatically resolved by the Bitcoin network: as more blocks are found, one of the forks eventually overtakes the other and becomes the main chain [42]. To ensure payments are not reversed by these small reorganizations, Bitcoin merchants only consider a block and its transactions confirmed if six or more blocks are built on top of it.

Catena allows clients to set their own application-specific number of required confirmations before accepting a statement (a minimum of six is recommended). This approach balances resilience to forks and the latency of accepting statements. Additionally, as a security measure against longer accidental forks, Catena clients remember recently-issued statements. If a statement is withdrawn due to a reorganization, Catena clients can ensure the reissued statement matches the previously seen one.

### Paying for a Catena Log
A Catena log server must pay Bitcoin transaction fees to start a log and append statements to it. Initially, the Catena log server must obtain some bitcoins (BTC), perhaps from a Bitcoin exchange [68]. The server then issues the log’s genesis transaction and pays for its fee. The server locks some coins in the genesis transaction’s continuation output, which can "fund" future log transactions. To issue the first statement, the server signs a new Catena transaction with the statement key. This transaction commits the statement (via an OP_RETURN output), transfers the genesis transaction’s coins back to the log server, and leaves a small fee for the miners. The remaining coins are locked in the new transaction’s continuation output. The server repeats this process for every new statement, spending the coins locked in the previous Catena transaction, until it runs out of funds. We analyze the costs of running a Catena log in terms of transaction fees in §VI-C1.

To "re-fund" the chain, Catena transactions can have additional inputs that lock extra coins in the transaction’s continuation output (see Figure 5). Importantly, these inputs can only be used to add extra funds and cannot be used to maliciously join two different logs. This is because Catena transactions are restricted to using only their first input to spend a previous Catena transaction. Thus, clients can easily detect if a Catena transaction tries to point to two distinct previous Catena transactions by using additional inputs.

**Figure 5.** A Catena chain can be "re-funded" by allowing the next transaction in the chain to have additional inputs that lock extra coins in that transaction’s continuation output. In this example, Catena transactions pay 0.5 BTC as a fee to ensure tx8 does not run out of coins, thus "re-funding" it using extra inputs.

### Attacks
In this section, we describe attacks on Bitcoin that can translate into attacks on Catena and explain what Catena clients can do to protect themselves. We also discuss attacks launched by a compromised log server or a compromised header relay network.

#### Log Server Attacks
An attacker might compromise the Catena log server and steal its statement key. In this case, the attacker can issue their own statements but cannot fork the log to equivocate about statements. All clients will see all attacker-issued statements and can check their correctness at the application layer (see §VII-3). The attacker can also steal the server’s Bitcoin funds. However, Catena’s primary goal is to prevent equivocation in the face of stolen key attacks, and orthogonal techniques can be used to secure the Bitcoin wallet of Catena servers [69].

Once the attacker has the statement key, they can abruptly "end" the log by issuing a transaction that is not in the correct Catena format. To recover from such an attack, the Catena log server must abandon that log and start a new one with a new genesis transaction. In this sense, Catena performs no worse than previous systems, which would also need to advertise a new public key to log clients if all log server secrets were compromised. A compromised log server could also hide transactions from Catena clients, causing them to lose freshness and remain unaware of the newest issued statements. However, as discussed above, the log server cannot equivocate about statements as that would require double-spending a transaction in Bitcoin.

#### Accidental Forks
Accidental forks in the Bitcoin blockchain pose a threat to Catena clients, as adversaries can double-spend Catena transactions across forks and equivocate. In the past, Bitcoin has had three major accidental forks. Two of them, in August 2010 and March 2013, were due to bugs in the bitcoind daemon [70], [71], and one, in July 2015, was caused by at least one irrational miner [72], which we expand on below. All of these forks orphaned a significant number of blocks, enough to unconfirm previously confirmed transactions. During the March 2013 fork [71], an honest-but-curious user attempted a double-spend attack on a Bitcoin exchange, which succeeded. However, the attacker quickly returned the funds to the exchange [73].

We stress that accidental forks have been rare and are thus outside our threat model. Furthermore, clients find out about forks via the header relay network and refuse to accept statements until forks are resolved, providing an extra line of defense. Thus, an adversary who wants to exploit an accidental fork must compromise the header relay network to hide one of the forks (or compromise the Bitcoin P2P network instead). As a last line of defense, Catena clients can wait for additional confirmations to protect themselves against accidental forks, at the cost of additional latency.

**1. SPV Mining:**
The July 2015 fork was caused by at least one irrational miner who mined for over an hour on top of an unverified chain [74]. "SPV" normally stands for Simplified Payment Verification, as discussed in §II-B6, but here it indicates that miners are not verifying the block they are mining on. SPV mining is used by some rational miners to lower their rate of orphaned blocks by starting to mine earlier [61]. However, when performed without a timeout, this strategy is actually irrational, as it can leave miners mining on an invalid fork indefinitely. As we explain below, this is what happened in July 2015.

Instead of waiting to hear about a solved block on the P2P network, SPV miners obtain a solved block hash directly from other mining pools via their Stratum mining API [75]. They then mine on top of that hash, assuming its corresponding block is correct and expecting to eventually receive the full block via the P2P network. Unfortunately, if the block is invalid, the P2P network will not waste bandwidth broadcasting it. Thus, SPV miners will never hear about an invalid block, which is why they need to time out after a while and switch to mining on the correct chain. Otherwise, SPV miners could be left mining on top of an invalid chain forever. This is exactly what happened in July 2015, when several miners did not implement timeout logic and went on to mine several invalid blocks, losing over $50,000 in mining rewards [72].

SPV mining remains a concern for the Bitcoin network. However, future Bitcoin improvements should further decrease the orphan rate and steer miners away from this unhealthy mining strategy. These could include improvements in block propagation delay and block verification speed, as well as new fast block relay networks, such as Falcon [76] and FIBRE [77].

#### Adversarial Mining Attacks
A sufficiently powerful adversary can mine their own side chain and fork the Bitcoin blockchain, enabling them to double-spend transactions across the two forks. Unfortunately, thin clients are more vulnerable than full nodes to a generalized "Vector76" attack, where the attacker mines a 6-block long side chain that is at least one block longer than the main chain [78]. The side chain’s first block contains a transaction `tx` with `k` confirmations, which the attacker will later replace with another transaction `tx'` double-spending the same output(s) as `tx`. When the attacker successfully mines the side chain, they show the side chain only to the victim, who will accept `tx`. Then, the attacker ceases to mine, issues `tx'` to the main chain, and lets the main chain win the race, confirming `tx'` and unconfirming `tx`.

Full nodes are more resilient to this attack because they can relay the attacker’s side chain to the rest of the network, while thin clients cannot. Thus, with full nodes, the attacker’s side chain could be adopted by the network, preventing the double-spend. However, we stress that with proper timing, the attacker can also trick full nodes if they are able to propagate their side chain to the victim at the same time as the same-length main chain is propagating to the rest of the network [78].

Similar to previous work [14], [15], [24], [54]–[59], we exclude adversaries who can mine a 6-block long side chain from our threat model because they are extremely powerful and have not been observed in practice. These adversaries can break not only thin nodes but also full nodes with proper attack timing. The main countermeasure against these attacks is to simply wait for more confirmations, making the attacker’s job more difficult. Another countermeasure is for Catena clients to accept a block header only after hearing about it from multiple sources, ensuring the attacker’s side chain is seen by the whole Bitcoin P2P network.

#### Bitcoin P2P Network Attacks
An attacker can "eclipse" nodes on the P2P network and withhold newly mined blocks from them via Sybil attacks [44] and so-called eclipse attacks [60]. For example, an attacker who eclipses a Catena client can increase their chances of succeeding at an adversarial mining attack. Even worse, an attacker who eclipses Bitcoin miners can double-spend without adversarially mining by simply preventing miners from seeing each other’s blocks. Fortunately, eclipse attacks on miners have not been observed yet in the wild and it is not clear that they could remain undetected for long. First, countermeasures against eclipse attacks have already been implemented in Bitcoin’s P2P network code. Second, mining pool operators would quickly notice the fork by an increase in their fraction of mined blocks. Third, eclipse attacks could be detected faster in the future if miners also broadcast "status reports": block headers that are below the difficulty target but are sufficiently difficult to give information about how much mining power is behind a fork [79]. Finally, block relay networks such as the Bitcoin Fast Relay Network (FRN) [80], Falcon [76], or FIBRE [77] are being deployed or are already deployed between Bitcoin miners, making eclipsing miners much harder.

A more powerful attacker could simply Sybil-attack Bitcoin’s P2P network, which would constitute a break of Bitcoin itself and, if practical, would be a concern for both Bitcoin and Catena. We plan on investigating to what extent a Sybil attack can partition the Bitcoin P2P network in future work.

#### Header Relay Network Attacks
A sufficiently powerful attacker who can adversarially mine and who controls the header relay network (HRN) could equivocate to a Catena client. First, the attacker controlling the HRN eclipses the client from the Bitcoin network, hiding all newly-mined blocks from the client. Second, the attacker adversarially mines a sufficiently long side chain that confirms some fake statement `si`. Depending on the attacker’s mining power, this could take days or weeks, which means the victim would become suspicious, as they are not seeing any mining activity. When done, the attacker shows this side chain to the victim, who will accept `si`. Finally, the attacker stops eclipsing the victim and shows them the main chain that confirms an inconsistent statement `s'i` and unconirms `si`. Importantly, even without an HRN in our design, this attack would be possible via an adversarial Bitcoin P2P network [60].

Fortunately, this attack can be easily detected by Catena clients if they use their local time to compute the rate at which blocks are mined and compare it to the normal Bitcoin rate while accounting for variance in the time between blocks. However, such heuristics for detecting attacks are beyond the scope of our work, so we defer them to future work. Finally, note that a more powerful attacker could leverage control of the HRN network to make generalized "Vector76" attacks more likely to succeed (see §V-C). Specifically, as they get closer to successfully mining the 6-block long side chain, the attacker could eclipse the victim, effectively buying them some extra time to win the race against the Bitcoin network. As before, such a powerful attacker could also pull off this attack using Bitcoin’s P2P network should our design not require an HRN. The same countermeasures as discussed above and in §V-C could be used to prevent this attack.

### Prototype and Evaluation
We implemented a Catena prototype in Java using the bitcoinj [23] library, consisting of 3000 lines of code, as measured with the sloccount tool. Our code is available on GitHub: https://github.com/non-equivocation/catena-java

Our prototype implements a Catena log server and a Catena client, both operating as thin nodes on the Bitcoin network, but does not implement a header relay network (HRN). Instead, in our first implementation, Catena clients use only the Bitcoin P2P network to fetch both block headers and Catena transactions with their associated Merkle proofs. In a future, more scalable implementation, we plan on fetching transactions and Merkle proofs from the log server and using a header relay network for downloading block headers. Next, we discuss our implementation and its internal API, which can be used to implement Catena’s API from §III-B.

#### Catena Log Server
The log server manages the statement key used to sign new Catena statements (see §IV-A2) and a set of funding keys used to "re-fund" a Catena log (see §IV-E). The server provides an `appendStatement(s)` API for issuing a statement `s`, abstracting the Bitcoin layer away from applications. Though currently not implemented, the server should "re-fund" the chain automatically, assuming there are sufficient funds controlled by the funding keys.

#### Catena Log Client
The client connects to the Bitcoin P2P network and sets a Bloom filter [53] on all its connections to filter out irrelevant transactions. This way, Catena clients only receive server-issued Catena transactions (see §II-B6) and save orders of magnitude in bandwidth. Recall that Catena chains together transactions, and clients verify this, thereby preventing malicious P2P nodes from equivocating about statements (see §IV-C). While additional bandwidth will be consumed by small blockchain reorganizations (see §IV-D), this amount is manageable.