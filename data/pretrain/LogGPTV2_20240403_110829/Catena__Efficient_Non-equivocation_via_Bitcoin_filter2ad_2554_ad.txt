1. Similarly, it shows
client c2 the transaction for s(cid:2)
1 and hides the one for s1. As a
result, the log server can easily equivocate to clients who don’t
400
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:20:17 UTC from IEEE Xplore.  Restrictions apply. 
verify transaction chaining as they cannot ensure the server is
not hiding an inconsistent statement. To conclude, in Catena,
clients prevent this attack by checking that every statement
they accept is part of a transaction that spends the previous
transaction’s continuation output, chaining all the way back to
the genesis transaction.
D. Blockchain Reorganizations
Like Bitcoin, Catena also needs to deal with small day-
to-day accidental forks or blockchain reorganizations (see
§II-B3). These small forks are automatically resolved by the
Bitcoin network: as more blocks are found, eventually one of
the forks overtakes the other one and becomes the main chain
[42]. To be certain payments are not reversed by these small
reorganizations, Bitcoin merchants only consider a block and
its transactions conﬁrmed if 6 or more blocks are built on top
of it.
Catena also allows clients to set their own application-
speciﬁc number of required conﬁrmations before accepting a
statement (a minimum of 6 is recommended). As a result,
Catena makes a trade-off between resilience to forks and
latency of accepting statements. Additionally, as a security
measure against longer accidental forks, Catena clients re-
member recently-issued statements. This way, if a statement is
withdrawn due to a reorganization, Catena clients can ensure
the reissued statement matches the previously seen one.
E. Paying for a Catena Log
A Catena log server must pay Bitcoin transaction fees to
start a log and append statements to it. Initially, the Catena
log server must obtain some bitcoins (BTC), perhaps from a
Bitcoin exchange [68]. Then, the server can issue the log’s
genesis transaction and pay for its fee. The server locks
some coins in the genesis transaction’s continuation output
which can “fund” future log transactions. To issue the ﬁrst
statement, the server signs a new Catena transaction with the
statement key. This transaction commits the statement (via
an OP_RETURN output), transfers the genesis transaction’s
coins back to the log server and leaves a small fee for the
miners. As before, the remaining coins are locked in this
new transaction’s continuation output. The server repeats this
process for every new statement, spending the coins locked
in the previous Catena transaction, until it runs out of funds.
We analyze the costs of running a Catena log in terms of
transaction fees in §VI-C1.
inputs that
lock extra coins in that
To “re-fund” the chain, Catena transactions can have ad-
ditional
transaction’s
continuation output (see Figure 5). Importantly, these inputs
can only be used to add extra funds and cannot be used to
maliciously join two different logs. This is because we restrict
Catena transactions to only use their ﬁrst input to spend a
previous Catena transaction. Thus, clients can easily detect
if a Catena transaction tries to point to two distinct previous
Catena transactions by using additional inputs.
Fig. 5. A Catena chain can be “re-funded” by allowing the next transaction
in the chain to have additional inputs that lock extra coins in that transaction’s
continuation output. In this example, Catena transactions pay .5 BTC as a fee
so to ensure tx8 does not run out of coins we “re-fund” it using extra inputs.
V. ATTACKS
In this section we describe attacks on Bitcoin that can
translate into attacks on Catena and explain what Catena
clients can do to protect themselves. We also describe attacks
launched by a compromised log server or a compromised
header relay network.
A. Log Server Attacks
An attacker might compromise the Catena log server and
steal its statement key. In this case, the attacker can issue
his own statements, but he cannot fork the log to equivocate
about statements. That is, all clients will see all attacker-issued
statements and can check their correctness at the application
layer (see §VII-3). The attacker can also steal the server’s
Bitcoin funds. However, we stress that Catena’s main goal is
to prevent equivocation in the face of stolen key attacks and
orthogonal techniques can be used to secure the Bitcoin wallet
of Catena servers [69].
Once the attacker has the statement key, he can also abruptly
“end” the log by issuing a transaction that is not in the correct
Catena format. To recover from such an attack, the Catena
log server has to abandon that log and start a new one with
a new genesis transaction. In this sense, Catena performs
no worse than previous systems, which would also have to
advertise a new public key to log clients if all log server
secrets were compromised. A compromised log server could
also hide away transactions from Catena clients. As a result,
Catena clients would lose freshness and not be aware of the
newest issued statements. However, as discussed above, the
log server cannot equivocate about statements as that would
require double spending a transaction in Bitcoin.
B. Accidental Forks
Accidental forks in the Bitcoin blockchain pose a threat to
Catena clients as adversaries can double spend Catena trans-
actions across forks and equivocate. In the past, Bitcoin has
had three major accidental forks. Two of them, in August 2010
and March 2013, were due to bugs in the bitcoind daemon
[70], [71] and one of them, in July 2015, was caused by at least
one irrational miner [72], which we expand on below. All of
these forks orphaned a signiﬁcant number of blocks, enough
to unconﬁrm previously conﬁrmed transactions. Moreover,
during the March 2013 fork [71], an honest-but-curious user
401
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:20:17 UTC from IEEE Xplore.  Restrictions apply. 
attempted a double spend attack on a Bitcoin exchange which
succeeded. However, the attacker quickly returned the funds
to the exchange [73].
We stress that accidental forks have been rare and are thus
outside of our threat model. Furthermore, clients ﬁnd out
about forks via the header relay network and refuse accepting
statements until forks are resolved, which gives them an extra
line of defense. Thus, an adversary who wants to exploit an
accidental fork has to compromise the header relay network
to hide one of the forks (or compromise the Bitcoin P2P
network instead). As a last line of defense, Catena clients can
wait for additional conﬁrmations to protect themselves against
accidental forks at the cost of additional latency.
1) “SPV” Mining: The July 2015 fork was caused by at
least one irrational miner who mined for over an hour on top of
an unveriﬁed chain [74]. “SPV” normally stands for Simpliﬁed
Payment Veriﬁcation as discussed in §II-B6, but here it is used
to indicate that miners are not verifying the block they are
mining on. SPV mining is used by some rational miners as a
way to lower their rate of orphaned blocks by starting to mine
earlier [61]. However, when performed without a timeout, this
strategy is actually irrational as it can leave miners mining on
an invalid fork indeﬁnitely. As we explain below, this is what
happened in July 2015.
Instead of waiting to hear about a solved block on the P2P
network, SPV miners obtain a solved block hash directly from
other mining pools via their Stratum mining API [75]. Then,
they mine on top of that hash, assuming its corresponding
block is correct and expecting to eventually receive the full
block via the P2P network. Unfortunately, if the block is in-
valid, the P2P network will not waste bandwidth broadcasting
it. Thus, SPV miners will never hear about an invalid block,
which is why they need to time out after a while and switch to
mining on the correct chain. Otherwise, SPV miners could be
left mining on top of an invalid chain forever. This is exactly
what happened in July 2015, when several miners did not
implement timeout logic and went on to mine several invalid
blocks, losing over $50,000 in mining rewards [72].
SPV mining remains a concern for the Bitcoin network.
However, future Bitcoin improvements should further decrease
the orphan rate and steer miners away from this unhealthy
mining strategy. These could be improvements in block prop-
agation delay and block veriﬁcation speed as well as new fast
block relay networks, such as Falcon [76] and FIBRE [77].
C. Adversarial Mining Attacks
A sufﬁciently powerful adversary can mine his own side
chain and fork the Bitcoin blockchain, enabling him to double
spend transactions across the two forks. Unfortunately, thin
clients are more vulnerable than full nodes to a generalized
“Vector76” attack where the attacker mines a 6-block long side
chain that is at least one block longer than the main chain
[78]. The side chain’s ﬁrst block contains a transaction tx
with k conﬁrmations which the attacker will later replace with
another transaction tx(cid:2) double-spending the same output(s)
as tx. When the attacker successfully mines the side chain,
he shows the side chain only to the victim, who will accept
tx. Then, the attacker ceases to mine, issues tx(cid:2) to the main
chain and lets the main chain win the race, conﬁrming tx(cid:2) and
unconﬁrming tx.
Full nodes are more resilient to this attack because they can
relay the attacker’s side chain to the rest of the network, while
thin clients cannot. Thus, with full nodes, the attacker’s side
chain could be adopted by the network, which would prevent
the double spend. However, we stress that with proper timing,
the attacker can also trick full nodes if he is able to propagate
his side chain to the victim at the same time as the same-length
main chain is propagating to the rest of the network [78].
Similar to previous work [14], [15], [24], [54]–[59], we ex-
clude adversaries who can mine a 6-block long side chain from
our threat model because they are extremely powerful and so
far they have not been observed in practice. These adversaries
can break not only thin nodes but also full nodes with proper
attack timing. The main countermeasure against these attacks
is to simply wait for more conﬁrmations, which makes the
attacker’s job more difﬁcult. Another countermeasure is for
Catena clients to accept a block header only after hearing
about it from multiple sources, so as to ensure the attacker’s
side chain is seen by the whole Bitcoin P2P network.
D. Bitcoin P2P Network Attacks
An attacker can “eclipse” nodes on the P2P network and
withhold newly mined blocks from them via Sybil attacks [44]
and so-called eclipse attacks [60]. For example, an attacker
who eclipses a Catena client can increase their chances of
succeeding at an adversarial mining attack. Even worse, an
attacker who eclipses Bitcoin miners can double spend without
adversarially mining by simply preventing miners from seeing
each other’s blocks. Fortunately, eclipse attacks on miners have
not been observed yet in the wild and it is not clear that
they could remain undetected for long. First, countermeasures
against eclipse attacks have been already implemented in
Bitcoin’s P2P network code. Second, mining pool operators
would quickly notice the fork by an increase in their fraction
of mined blocks. Third, eclipse attacks could be detected faster
in the future if miners also broadcast “status reports:” block
headers that are below the difﬁculty target but are sufﬁciently
difﬁcult to give information about how much mining power is
behind a fork [79]. Finally, block relay networks such as the
Bitcoin Fast Relay Network (FRN) [80], Falcon [76] or FIBRE
[77] are being deployed or are already deployed between
Bitcoin miners, making eclipsing miners much harder.
A more powerful attacker could simply Sybil-attack Bit-
coin’s P2P network, which would constitute a break of Bitcoin
itself and, if practical, would be a concern for both Bitcoin and
Catena. We plan on investigating to what extent a Sybil attack
can partition the Bitcoin P2P network in future work.
E. Header Relay Network Attacks
A sufﬁciently powerful attacker who can adversarially mine
and who controls the header relay network (HRN) could
equivocate to a Catena client. First, the attacker controlling
402
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:20:17 UTC from IEEE Xplore.  Restrictions apply. 
the HRN eclipses the client from the Bitcoin network, hiding
all newly-mined blocks from the client. Second, the attacker
adversarially mines a sufﬁciently long side chain that conﬁrms
some fake statement si. Depending on the attacker’s mining
power, this could take days or weeks, which means the victim
would become suspicious, as they are not seeing any mining
activity. When done, the attacker shows this side chain to the
victim who will accept si. Finally, the attacker stops eclipsing
the victim and shows them the main chain that conﬁrms an
inconsistent statement s(cid:2)
i and unconﬁrms si. Importantly, even
without an HRN in our design, this attack would be possible
via an adversarial Bitcoin P2P network [60].
Fortunately, this attack can be easily detected by Catena
clients if they use their local time to compute the rate at
which blocks are mined and compare it to the normal Bitcoin
rate while accounting for variance in the time between blocks.
However, such heuristics for detecting attacks are beyond the
scope of our work, so we defer them to future work. Finally,
note that a more powerful attacker could leverage control of
the HRN network to make generalized “Vector76” attacks
more likely to succeed (see §V-C). Speciﬁcally, as he gets
closer to successfully mining the 6-block long side chain, the
attacker could eclipse the victim, which effectively buys him
some extra time to win the race against the Bitcoin network. As
before, such a powerful attacker could also pull off this attack
using Bitcoin’s P2P network should our design not require an
HRN. The same countermeasures as discussed above and in
§V-C could be used to prevent this attack.
VI. PROTOTYPE AND EVALUATION
We implemented a Catena prototype in Java using the
bitcoinj [23] library in 3000 lines of code, as measured with
the sloccount tool. Our code is available on GitHub:
https://github.com/non-equivocation/catena-java
Our prototype implements a Catena log server and a Catena
client, both operating as thin nodes on the Bitcoin network, but
does not implement a header relay network (HRN). Instead, in
our ﬁrst implementation, Catena clients use only the Bitcoin
P2P network to fetch both block headers and fetch Catena
transactions with their associated Merkle proofs. In a future,
more scalable implementation, we plan on fetching transac-
tions and Merkle proofs from the log server and on using a
header relay network for downloading block headers. Next, we
discuss our implementation and its internal API, which can be
used to implement Catena’s API from §III-B.
A. Catena Log Server
The log server manages the statement key used to sign
new Catena statements (see §IV-A2) and a set of funding
keys used to “re-fund” a Catena log (see §IV-E). The server
provides an appendStatement(s) API for issuing a statement
s, which abstracts the Bitcoin layer away from applications.
Though currently not implemented, the server should “re-
fund” the chain automatically assuming there are sufﬁcient
funds controlled by the funding keys.
B. Catena Log Client
The client connects to the Bitcoin P2P network and sets a
Bloom ﬁlter [53] on all its connections to ﬁlter out irrelevant
transactions. This way, Catena clients only receive server-
issued Catena transactions (see §II-B6) and save orders of
magnitude in bandwidth. Recall that Catena chains together
transactions and clients verify this, thereby preventing ma-
licious P2P nodes from equivocating about statements (see
§IV-C). While additional bandwidth will be consumed by
small blockchain reorganizations (see §IV-D),
this amount