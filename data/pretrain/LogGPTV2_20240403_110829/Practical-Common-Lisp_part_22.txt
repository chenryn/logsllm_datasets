① 这仅仅是出于阐述目的。很明显，编写对于诸如“+”这样的内置函数的测试用例有点荒唐，因为如果连这么基
如果正在做测试，那么就可以在REPL中输入这些表达式并检查它们是否返回r。但你可能想
带有副作用的函数会以稍微不同的方式进行测试。你必须调用该函数，然后查找是否有证
一个自动测试框架的关键特性在于该框架应该能够告诉你是否所有的测试都通过了。当计算
该测试框架的主要设计目标是使其可以尽可能简单地增加新测试，运行多个测试套件，以及
考虑如何在测试中检测一个函数是否在特定情况下产生了一个特别的错误。
测试标准库函数。
本的东西都无法正常工作的话，那么测试过程按照你期待的方式运行的可能性也微乎其微。另一方面，多数
(defun test-+ ()
CommonLisp平台在很大程度上是用CommonLisp本身实现的，因此不难想象可以用CommonLisp编写测试套件来
两个最初的尝试
(and
{+-1-3)
1
第9章
123)
-4)
6）
实践：建立单元测试框架
www.TopSage.com
---
## Page 109
由于第二个版本更接近于预期结果，所以最好是看看能否可以将某些烦人的重复消除掉。
值的高效函数，但同时它还可以像第二个版本那样能够报告单独测试用例的结果。就功能而言，
9.2
常困难。
例的话，
发生了错误输入，测试结果就会被错误地标记。
以及测试表达式乏味的重复，这些急切需要被重构。其中测试表达式的重复尤其讨厌，因为如果
本身标记到结果上。现在运行test-+就可以明确显示出发生了什么事。
FORMAT在其第一个格式实参为假时打印出FAIL，而在其他情况下为paSS。
你可以写成类似下面这样。
个测试用例。
一些有用的信息。当teSt-+返回NIL时，你会知道某些测试失败了，但却不会知道这究竟是哪-
写大量的重复测试代码。然而一旦发现某个测试用例失败了，同样也会发现它的运行报告会遗漏
我们真正所需要的编程方式应该是可以写出像第一个tést-+那样能够返回单一的T或NIL
另一个问题在于，你无法得到单一的关于所有测试是否都通过的指示。如果只有三个测试用
因此,让我们来尝试另一种简单得甚至有些愚蠢的方法。为了找出每个测试用例的运行情况
16
消除重复的FORMAT相似调用的最简单方法就是创建一个新函数。
这次的结果报告更像是你想要的，可是代码本身却一团糟。问题出在对FORMAT的重复调用
CL-USER> (test-+)
现在每个测试用例都将单独报告结果。FORMAT指令中的～：[FAIL~;PaSs~]部分将导致
pass
(defun test-+ ()
一旦它返回r，就可知道测试用例通过了。这种组织测试的方式也很优美简洁——不需要编
CL-USER> (test-+)
无论何时，当想要运行这组测试用例时，都可以调用test-+。
重构
，很容易通过扫描输出并查找“FAIL”来看到这点。不过当有几百个测试用例时，这将非
(format
format t"
第9章 
八
（+
(+12)3)
（=
t
-1-3)-4)))
123)6)
(+-1-3)-4}
"~:[FAIL~;pass~]
"~:[FAIL~;pass~]
实践：建立单元测试框架
www.TopSage.com
~a~名"
~a~名”
~a~g"
(=(+-1-3)-4)(=(+-1-3}-4)))
(+123)
(+1 2) 3)*(=(+ 1 2) 3))
（9
(=(+123)6))
，“然后会将测试表达式
---
## Page 110
其等价于下面的代码：
PROGN之中。注意是怎样使用，@将反引用模板所生成的表达式列表嵌人到结果表达式之中的。
义check来接受任意数量的形式并将它们中的每个都封装在一个对report-result的调用里。
并要让其与下列形式含义等同。
方法应该能够自动编写容易出错的report-result调用。代码可能要写成下面这样。
想将代码作为数据来对待，这就意味着肯定需要一个宏。或者从另外一个角度来看，你所需要的
的应该是可以将表达式同时看作代码（为了获得结果）和数据（用来作为标签）。无论何时，若
少现在如果打算改变报告结果的方式，则只需要修改一处即可。
（check（=（+12）3））
有了check的新版本就可以写出一个像下面这样新版本的test-+~：
这个定义使用了一种常见的宏习惯用法，将一系列打算转化成单一形式的形式分装在一个
既然不喜欢重复的代码，那为什么不将那些对check的重复调用也一并消除掉呢？你可以定
接下来需要摆脱的是测试用例表达式的重复以及由此带来的错误标记结果的风险。真正想要
现在就可以用report-result来代替FORMAT编写test-+了。这不是一个大的改进，但至
(defun test-+()
(defun test-+()
(defmacro check（&bodyforms)
(defuntest-+()
现在就可以改变test-+来使用check了。
很容易就可以写出一个宏来作这种转换。
(report-result（=（+12）3）·(=（+12）3））
(defuntest-+()
(defmacro check（form)
(defun report-result（result form)
(progn
(check
(progn
(check（=
(report-result,form',form))
(report-result
(report-result
(report-result
check
check
（=（+-1-3）
（+12）3）
123)6）
（=
（+
（+
（+
-1-3)
12）3））
-4)))
（=
=
（=（+12）3）（=（+12）3））
3）
（+-1-3）-4）（=（+-1-3）-4）））
+
-4)))
6）)
www.TopSage.com
6）
（
---
## Page 111
一的名字，这就需要用到with-gensyms了。可以像下面这样来定义combine-results：
并且它应与下列形式等同：
供这样一种构造，但你没有理由不能使用它：自己编写提供这一功能的宏是极其简单的。
没有短路行为，那么就可以用它来代替pROGN，从而事情也就完成了。虽然CommonLisp并不提
AND在本例中并不能完成你想要的事。另一方面，如果有一个像AND那样运作的操作符，同时又
合结果了。不幸的是，由于AND存在短路行为，即一旦某个测试用例失败了就跳过其余的测试，
生成最终用来运行测试用例的代码，所以只需改变它来生成可以同时跟踪结果的代码就可以了。
9.3
来做到。
版本有着相同的功能。
94
现在report-result返回了它的测试用例结果，故而看起来只需将PROGN变成AND就可以组
首先可以对report-result做一个小改变，以使其在报告时顺便退回测试用例结果。
接下来可以修复test-+以使其返回值可以指示所有测试用例是否都通过了。由于check负责
编写这个宏唯一麻烦之处在于，需要在展开式中引入一个变量，即前面代码中的result。
(let ((result t))
暂时把测试用例放在一边，所需要的宏应如下所示，我们称其为combine-results
多亏有了check，这个版本才和test-+的第一个版本一样简洁，而其展开代码却与第二个
(defmacro combine-results (&body forms)
(combine-results
(defun report-result (result form)
result)
修复返回值
(with-gensyms (result)
result)
(baz)
(bar)
(foo)
(format t "~:[FAIL~;pass"]
unless (baz) (setf result nil))
inless
(report-result 
(report-result
第9章实践：建立单元测试框架
,result)))
,@(loop for f in forms collect ^(unless ,f (setf ,result nil)))
(bar)
(setf result
(setf result nil))
，并且现在若想对test-+的行为做出任何改变，也都可以通过改变check
(=(+-1-3)-4)*(=(+-1-3)-4))))
（=
www.TopSage.com
nil))
···
~a~&" result form)
---
## Page 112
自己的结果。运行test-arithmetic将得到下列结果：
函数添加一些测试用例，则可以写一个新测试函数。
可能就要以某种方式将它们组织起来，而不是将它们全部塞进一个函数里。例如，假设想要对“*”
了，那么只需在check形式中找到那个测试用例并找出其失败原因即可。但如果编写了大量测试,
9.4更好的结果输出
个测试都通过了。
②你不得不通过改变测试来使其失败，因为你不能改变“+”的行为。
① 如果test-+已经被编译了，这在特定Lisp实现中可能会隐式地发生，你可能需要重新求值test-+的定义以使改
这个函数使用combine-results来代替check，因为test-+和test-*都将分别汇报它们
由于只有一个测试函数，所以当前的结果输出是相当清晰的。如果一-个特定的测试用例失败
现在有了两个测试函数，你可能还想用另一个函数来运行所有测试，这也相当简单。
如果改变了一个测试用例而导致其失败?，最终的返回值也将变成NIL。
使用这个版本的check，test-+就可以输出它的三个测试表达式结果，并返回T以说明每-
变后的check定义影响test-+的行为。另一方面，解释执行的代码通常在每次代码被解释时重新展开宏，从而
defun test-* ()
FAIL...
pass
CL-USER>
ssed
pass
CL-USER>
现在可以通过简单地改变展开式用combine-results代替PROGN来修复check。
使宏的重定义的效果立竿见影。
(defun test-arithmetic ()
NIL
(defmacro check (&body forms)
(test-+)
(combine-results
(check
(test-*)))
(（((': ' n-)、o S u   d)'
(combine-results
(=(*3 5）15)))
(*22)4)
(test-+)
(= (+ 1 2)3)