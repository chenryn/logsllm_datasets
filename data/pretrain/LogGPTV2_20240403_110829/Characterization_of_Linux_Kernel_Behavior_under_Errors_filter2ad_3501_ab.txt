Configure LKCD
Prepare the system for 
the next crash
Document
Boot Linux
Save System 
M emory to 
Swap disk
Auto-Reboot
Figure 3: Automated Process of Injecting Errors 
An error is injected through the kernel injection module when 
the target instruction is activated/executed. In case of a crash 
(1) the system memory is copied into a temporary disk loca-
tion (a dump device), (2) Linux is booted by crash handler or 
by  watchdog  hardware  monitor,  and  the  memory  image  pre-
viously  saved  in  the  dump  device  is  moved  to  the  dump 
directory,  and  (3)  the  experiments  continue  with  the  next 
error being injected. Observe that the system is rebooted after 
each  run  (each  single  error  injection)  whenever  the  target 
instruction is activated (i.e., the kernel executes the corrupted 
instruction).  If  the  target  instruction  is  not  activated,  the  ex-
periment proceeds to select the next target instruction without 
rebooting the system. 
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:05:58 UTC from IEEE Xplore.  Restrictions apply. 
Crash  Handler. The  core  part  of  the  Linux  injector  is  the 
crash  handler,  which  invokes  the  crash  dump  function  of 
LKCD to save the kernel image at the time of crash. Embed-
ding  the  crash  handler  into  strategic  locations  in  the  kernel 
enables  the  collecting  of  crucial  information  for  discriminat-
ing  among  different  categories  of  crashes  and  hangs,  e.g., 
kernel  panic,  divide  by  zero  error,  overflow,  bounds  check, 
invalid  opcode,  coprocessor  segment  overrun,  segment  not 
present, stack exception, general protection fault, page fault. 
Error Model 
5.2 
The error model assumed in this study is an error that impacts 
correct execution of an instruction by the processor. An error 
can  originate  in  the  disk,  network,  bus,  memory,  or  cache. 
Single-bit errors are injected to impact the instructions of the 
target kernel functions. Previous research on microprocessors 
[7], [8] has shown that most (90-99%) device-level transients 
can  be  modeled  as  logic-level,  single-bit  errors.  Data  on  op-
erational  errors  also  show  that  many  errors  in  the  field  are 
single-bit  errors  [13].  Four  attributes  characterize  each  error 
injected:  
•  Trigger (when?) – An error is injected when a target in-
struction  in  a  given  kernel  function  is  reached;  the  kernel 
activity  is  invoked  by  executing  a  user-level  workload 
(benchmark) program. 
•  Location (where?) – Error location is pre-selected based 
on the profiling of kernel functions; the most frequently used 
kernel functions by the workload are selected for injections. 
Doing  so  allows  achieving  a  sufficiently  high  error  activa-
tion  rate  to  obtain  statistically  valid  results  and  conducting 
the experiments within a reasonable timeframe. 
•  Type  (what?)  –  One  single-bit  error  per  byte  of  an  in-
struction binary is injected.  
•  Duration  (how  long?)  –  An  injected  error  persists 
throughout the execution time of the benchmark program. 
5.3  Outcomes, Measures, and Experiment Setup 
Outcomes  from  error  injection  experiments  are  classified 
according to the categories give in Table 3. 
Crash  latency. The  crash  latency  is  defined  as  the  interval 
between  the  time  an  error  is  injected  and  the  time  the  error 
manifests, i.e., the system crashes. To measure the latency, at 
the end of the error injection routine (part of the error injec-
tor), the current value of the performance counter is recorded 
and  subtracted  from  the  value  of  the  counter  at  the  time  of 
error  manifestation  (recorded  by  the  crash  handler  routine). 
Two  routines,  the  error  injector  and  the  crash  handler,  are 
used to capture the injection time and the error manifestation 
time, respectively. Since it takes time for the system to switch 
between  the  two  routines,  simply  taking  the  difference  be-
tween  the  two  values  would  include  the  switching  time  be-
tween  routines.  Additional  measurements  were  conducted  to 
assess  the  switching  time  and  subtract  it  from  the  calculated 
crash latency. 
Error Propagation. Errors injected and activated in one  ker-
nel  subsystem  may  propagate  to  another  subsystem  causing 
the system to crash. Since the kernel is generally divided into 
several different  modules and those  modules  may interact,  it 
is valuable to analyze error propagation patterns. The injector 
automatically identifies the Linux kernel subsystem where an 
error is injected and the subsystem where the crash happens.  
Summary  of  Experiment  Setup.  Table  2  summarizes  the  key 
characteristics of the experimental setup.  
Table 2: Experimental Setup Summary 
Hardware Platform 
Linux OS 
Supporting Tools 
e
p
y
T
U
P
C
4
P
l
e
t
n
I
k
c
o
l
C
U
P
C
]
z
H
G
[
]
B
K
[
e
h
c
a
C
y
r
o
m
e
M
]
B
M
[
l
e
n
r
e
K
5
.
1
6
5
2
6
5
2
9
1
.
4
.
2
m
e
t
s
y
S
e
l
i
F
2
t
x
E
p
m
u
d
h
s
a
r
C
D
C
K
L
n
o
i
t
u
b
i
r
t
s
i
D
3
.
7
t
a
H
d
e
R
d
a
o
l
k
r
o
W
h
c
n
e
B
x
i
n
U
-
e
d
l
e
n
r
e
K
g
u
b
B
D
K
g
n
i
l
i
f
o
r
P
f
o
r
p
n
r
e
K
Error 
Injection 
Tool 
-
r
e
K
x
u
n
i
L
r
o
t
c
e
j
n
I
l
e
n
Outcome  
Category 
Table 3: Outcome Categories 
Description 
Activated 
The corrupted instruction is executed. 
Not Manifested  The corrupted instruction is executed, however it does not cause a visible abnormal impact on the system. 
Fail Silence 
Violation 
Either operating system or application erroneously detects presence of an error or allows incorrect data/response 
to propagate out. 
Crash 
Hang 
Operating sys-
tem stops work-
ing, e.g., bad 
trap or system 
panic. 
System re-
sources are 
exhausted re-
sulting in a non-
operational 
system, e.g., 
deadlock. 
Unable to handle kernel NULL pointer dereference,a page fault – the kernel tries to access the bad page 
pointed by NULL pointer. 
Unable to handle kernel page request, a page fault – the kernel tries to access some bad page. 
Out of memory, a page fault – kernel runs out of memory. 
General protection fault, e.g., exceeding segment limit, writing to a read-only code or data segment, load-
ing a selector with a system descriptor. 
Kernel Panic, operating system detected an error. 
Trap – invalid opcode, an illegal instruction not defined in the instruction set is executed. 
Trap – divide error, a math error. 
Trap – init3, a software interrupt triggered by int3 instructions; often used for breakpoint. 
Trap –  bounds, bounds checking error. 
Trap –invalid TSS (task state segment), the selector, code segment, or stack segment is outside the table 
limit, or stack is not write-able. 
Trap – overflow, math error.
Proceedings of the 2003 International Conference on Dependable Systems and Networks (DSN’03) 
0-7695-1959-8/03 $17.00 (c) 2003 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:05:58 UTC from IEEE Xplore.  Restrictions apply. 
6  Experimental Results  
This section presents results from error injection experiments 
on  the  selected  kernel  functions  (selected  via  the  profiling 
discussed  in  Section  4)  while  running  the  benchmark  pro-
grams.  Three  types  of  error  injection  campaigns  are  con-
ducted. Table 4 provides brief description of each campaign: 
A random  injections  are  made  to  non-branch  instructions,  B
conditional  branch  instructions  only  are  targeted  and  C  the 
impact of reversing the logic of conditional branch instruction 
(i.e., taking a valid but incorrect branch) is studied. Note that, 
in campaigns A and B a target instruction is injected multiple 
times depending on the number of bytes in the binary repre-
sentation  of  the  instruction.  This  section  presents  the  overall 
outcomes of the three fault injection campaigns followed by a 
detailed  discussion  of 
injection  outcomes 
(hang/crash failures, fail silence violations and not manifested 
errors). 
the  error 
Table 4: Definition of Fault Injection Campaigns 
Campaign Name  Target Instructions  Target Bit 
A – Any Random 
Error 
B – Random 
Branch Error 
C – Valid but In-
correct Branch 
All non-branch instruc-
tions within the se-
lected function 
All conditional branch 
instructions within the 
selected function 
All conditional branch 
instructions within the 
selected function 
A random bit in each 
byte of the instruc-
tion  
A random bit in each 
byte of the branch 
instruction 
The bit that reverses 
the condition of the 
branch instruction 
6.1 
Statistics on Error Activation and Failure Distribu-
tions 
Figure  4  summarizes  the  results  of  the  three  error  injection 
campaigns. For each campaign, the tables on the left give the 
statistics  on  the  outcome  categories  for  each  targeted  kernel 
subsystem.  The  number  in  brackets  beside  each  subsystem 
indicates  the  number  of  functions  injected.  For  example, 
“arch [6]” indicates that 6 functions from the arch subsystem 
were  selected  for  error  injection  in  a  given  campaign2.  For 
each  outcome  category,  the  percentage  in  the  parentheses  is 
calculated with respect to the total number of activated errors. 
The pie charts on the right provide the overall error distribu-
tions for each outcome category 3.
The  major  findings  from  over  35,000  fault  injections  are 
summarized below.  
•  Not  surprisingly,  a  significant  percentage  (35~65%)  of 
injected  errors  are  not  activated,  i.e.  the  corrupted  instruc-
tion is not executed. 
2 Note  that,  while  all  32 core  functions  (i.e.,  contributing  to 95%  of  kernel 
activity) selected by the kernel profiling are targeted in each error injection 
campaign,  the  total  number  of  functions  injected  in  a  given  campaign  is 
much larger, and different for each campaign. For example, in campaign A, a 
total  of  51  functions  are  injected  (including  the  top  32  determined  by  the 
profiler).  This  ensures  that  same  core  functions  are  studied  in  each  error 
injection  campaign  and  that  the  number  of  activated  errors  is  sufficient  for 
valid statistical analysis.
3 In  tables  in  Figure  4,  percentages  given  in  the  bottom  of  column 