reference counting of tokens
– Usually only if the exploit is executed several times on the same 
box without rebooting it in between
Windows Local GDI
Kernel Memory Overwrite
•
Payload
– Solution: Restore the original access token after executing a new 
privileged process, or whatever it is we wanted to do with our 
elevated privileges
– Also restores the overwritten system call pointer
– Done! Reliable exploitation of the GDI bug across all the vulnerable 
Windows 2000 and Windows XP systems has been achieved
Windows Local GDI
Kernel Memory Overwrite
Windows Local GDI
Kernel Memory Overwrite
Demonstration
•
Finding the vulnerability
– Fuzzing it
• Almost instant crash 
• Very similar to NetBSD-SA2007-004, which was demonstrated 
at our BlackHat Europe talk
– Tracking it down
• DDB / GDB 
• Source code
– Introduction to the bug
• Mbuf  pointer overflow / arbitrary MFREE()
NetBSD mbuf Overflow
•
mbufs
– Basic kernel memory unit
– Stores socket buffers and packet data
– Data can span several mbufs (linked list) 
NetBSD mbuf Overflow
•
Developing the exploit
– MFREE() allow for an arbitrary 32-bit value to be written to an 
arbitrary address (Normal unlinking stuff)
– mbuf can have external storage
• And their own free routine!
– This is what I'm using in my exploit
– Exploited mbuf is freed in sbdrop()
NetBSD mbuf Overflow
NetBSD mbuf Overflow
sbdrop(struct sockbuf *sb, int len)
{
struct mbuf     *m, *mn, *next;
next = (m = sb->sb_mb) ? m->m_nextpkt : 0;
while (len > 0) {
if (m == 0) {
if (next == 0)
panic("sbdrop");
m = next;
next = m->m_nextpkt;
continue;
}
if (m->m_len > len) {
m->m_len -= len;
m->m_data += len;
sb->sb_cc -= len;
break;
}
len -= m->m_len;
sbfree(sb, m);
MFREE(m, mn);
•
Unlink technique
– Remove mbuf from chain and link remaining neighboring mbufs 
together
– “Arbitrary” write operations takes place
#define _MCLDEREFERENCE(m)  \ 
do {
    (m)->m_ext.ext_nextref->m_ext.ext_prevref =(m)->m_ext.ext_prevref;
    (m)->m_ext.ext_prevref->m_ext.ext_nextref =(m)->m_ext.ext_nextref;
} while (/* CONSTCOND */ 0)
NetBSD mbuf Overflow
•
Unlink technique example
– Unlinking an mbuf with these values
• m_ext.ext_nextref == 0xdeadbeef
• m_ext.ext_prevref == 0xbadc0ded
– Can be expressed as
• *(unsigned *)(0xbadc0ded+NN) = 0xdeadbeef;
• *(unsigned *)(0xdeadbeef+PP) = 0xbadc0ded;
– Where NN and PP are the offsets to ext_nextref and ext_prevref in 
the mbuf structure respectively.
NetBSD mbuf Overflow
•
Targets to overwrite
– Return address
– “Random” function pointer
– sysent – function pointers to syscalls
•
Cleaning up
– Memory pools, messy and changes between releases
– mbinit()
NetBSD mbuf Overflow
•
External free() technique
– Some mbufs holds a reference to their own free() routine
– No unlinking is done if ext_nextref references its own mbuf
– Point ext_free to your payload – Job done!
– Bonus – No mess to clean up
NetBSD mbuf Overflow
•
Payload
– How to find your process
• I have used allproc and %fs 
– Changing credentials 
• Credential structure pointer found in proc structure
• Change UID 0
– “Cheating” my way out of the loop
• I'm lazy – Return from payload with an extra leave
– Placing the payload
• Return to userland
NetBSD mbuf Overflow
Demonstration
NetBSD mbuf Overflow
•
Bug found and researched by Alfredo Ortega
•
PoC code was released to execute a breakpoint
•
I successfully tested the vulnerability against OpenBSD 4.0, 3.9, 3.8, 3.7, 
3.6, 3.5, 3.4, 3.3, 3.2, 3.1 (older releases with support for IPv6 might be 
vulnerable too)
•
Code is different in OpenBSD  and then jmp backwards to reach stage 1
OpenBSD IPv6
Remote mbuf Overflow
Payload in 3 stages
•
Stage 1 – Backdoor installation, icmp6_input wrapper
•
Stage 2 – Backdoor
•
Stage 3 – Command(s)
OpenBSD IPv6
Remote mbuf Overflow
Stage 1 (1/2)
•
Find stage 2
– Last mbuf in chain for previous packet (%esp+108)
•
Calculate address of symbol resolver routine (offset from start of stage 2)
•
Resolve inet6sw and fetch inet6sw[4].pr_input, the address of 
the current icmp6_input function.
OpenBSD IPv6
Remote mbuf Overflow
OpenBSD IPv6
Remote mbuf Overflow
Stage 1 (2/2)
•
Make sure backdoor is not already installed
– Compare the first four bytes of the backdoor with the corresponding 
bytes in the input function (starts with a call instead of push %ebp).
•
Allocate kernel memory for stage 2 and copy the code.
•
Wrap icmp6_input with stage 2
– Replace inet6sw[4].pr_input with pointer to stage 2
•
Clean up stack and return
addl    $0x20, %esp
popl    %ebx
popl    %esi
popl    %edi
leave
ret
Stage 2 (1/4) – ELF symbol resolver
•
Find ELF header, which is mapped after .bss
– Scan for ”\x7FELF” from Interrupt Descriptor Table
•
Search for hash of symbol string in the .dynsym section
OpenBSD IPv6
Remote mbuf Overflow
Stage 2 (2/4)
•
Listen for ICMPv6 packets with magic bytes
– Copy stage 3 code to allocated memory
– Wrap system call with stage 3 command
•
Call the real icmp6_input routine and return
OpenBSD IPv6
Remote mbuf Overflow
Stage 2 (3/4) – Syscall wrapper
•
Exploit will be more portable if system calls are used
•
Need process context to use system calls
•
fork1() from initproc inside an interrupt does not work (anymore)
•
Wrap a system call, wait for it to be called, fork1() from that process
OpenBSD IPv6
Remote mbuf Overflow
Stage 2 (4/4) – Syscall wrapper
•
Wrap gettimeofday() with stage 3, since it is called quite frequently
•
Store address of the real gettimeofday() and its index (116) at the 
beginning of the stage 3 command
# Set syscall address in table
.macro set_syscall sysent, idx, addr
movl   \sysent, %ecx
movl   \idx, %eax # Index
movl   \addr, 4(%ecx, %eax, 8)
.endm
OpenBSD IPv6
Remote mbuf Overflow
Stage 3 (1/3) – Commands
•
Connect-back
•
Set secure level
•
Shell commands (/bin/sh -c)
•
Uninstall backdoor
There is no built-in command for transferring files.
Use a connect-back shell and:
•
uuencode(1) + cat(1) to send (binary) files
•
script(1) + uuencode(1)to fetch them.
OpenBSD IPv6
Remote mbuf Overflow
OpenBSD IPv6
Remote mbuf Overflow
Stage 3 (2/3) – Initialization
•
Use stage 2 resolver to resolve symbols
•
Reset the wrapped system call to the original function pointer
•
Call the real system call and save the return value
•
fork1() from the calling process
Stage 3 (3/3) – Command process
•
Make sure we run as root
.macro setuid_root proc
    movl 16(\proc), %eax  # struct pcred pointer
    movl $0, 4(%eax)      # Real User ID
.endm
•
Terminate the process on failure
OpenBSD IPv6
Remote mbuf Overflow
Demonstration
OpenBSD IPv6
Remote mbuf Overflow
•
Kernel vulnerability in the IEEE 802.11 subsystem of FreeBSD
– Vulnerability found and exploited by Karl Janmar
– IOCTL
– Integer-overflow
– Stackbased buffer overflow
– wpa_supplicant
– WPA-PSK
FreeBSD 802.11
Remote Integer Overflow
FreeBSD 802.11
Remote Integer Overflow
Demonstration