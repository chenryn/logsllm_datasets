#    ROOT: DEBUG客户端项目端口8082，几个需要说明的地方：1.  本地测试的时候有一个坑，也就是我们需要配置    context-path，否则可能会出现客户端和授权服务器服务端 Cookie    干扰，导致 CSRF    防御触发的问题。这个问题出现后程序没有任何错误日志输出，只有开启    DEBUG 模式后才能看到 DEBUG    日志里有提示，因此这个问题非常难以排查。说实话，我也不知道 Spring    为什么不把这个信息作为 WARN    级别的日志输出。        2.  作为 OAuth 客户端，我们需要配置 OAuth 服务端获取 Token    的地址、授权（获取授权码）的地址，需要配置客户端的    ID、密码和授权范围。        3.  因为使用的是 JWT    Token，我们需要配置公钥（当然，如果不在这里直接配置公钥的话，也可以配置从授权服务器服务端获取公钥）。        接下来，我们可以开始编码了。第一步，实现 MVC 的配置：    @Configuration    @EnableWebMvc    public class WebMvcConfig implements WebMvcConfigurer {        /**         * 配置RequestContextListener用于启用session scope的Bean         * @return         */        @Bean        public RequestContextListener requestContextListener() {            return new RequestContextListener();        }        /**         * 配置index路径的首页Controller         * @param registry         */        @Override        public void addViewControllers(ViewControllerRegistry registry) {            registry.addViewController("/")                    .setViewName("forward:/index");            registry.addViewController("/index");        }    }这里做了两件事情：1.       配置 RequestContextListener，用于启用 session scope 的    Bean；    2.       配置了 index 路径的首页    Controller。        第二步，实现安全方面的配置：    @Configuration    @Order(200)    public class WebSecurityConfig extends WebSecurityConfigurerAdapter {        /**         * /路径和/login路径允许访问，其它路径需要身份认证后才能访问         * @param http         * @throws Exception         */        @Override        protected void configure(HttpSecurity http) throws Exception {            http                    .authorizeRequests()                    .antMatchers("/", "/login**")                    .permitAll()                    .anyRequest()                    .authenticated();        }    }这里我们实现的是 / 路径和 /login路径允许访问，其它路径需要身份认证后才能访问。第三步，我们来创建一个控制器：    @RestController    public class DemoController {        @Autowired        OAuth2RestTemplate restTemplate;        //演示登录后才能访问的安全页面        @GetMapping("/securedPage")        public ModelAndView securedPage(OAuth2Authentication authentication) {            return new ModelAndView("securedPage").addObject("authentication", authentication);        }        //演示通过OAuth2RestTemplate调用受保护资源        @GetMapping("/remoteCall")        public String remoteCall() {            ResponseEntity responseEntity = restTemplate.getForEntity("http://localhost:8081/user/name", String.class);            return responseEntity.getBody();        }    }这里我们实现了两个功能：1.       securedPage    页面，实现的功能是，把用户信息作为模型传入了视图，这样打开页面后就能显示用户名和权限。        2.       remoteCall 接口，实现的功能是，通过引入    OAuth2RestTemplate，在登录后就可以使用凭据直接从受保护资源服务器拿资源，不需要繁琐地实现获得访问令牌、在请求头里加入访问令牌的过程。        第四步，配置一下刚才用到的 OAuth2RestTemplate Bean，并启用 OAuth2Sso功能：     @Configuration    @EnableOAuth2Sso //这个注解包含了@EnableOAuth2Client    public class OAuthClientConfig {        /**         * 定义了OAuth2RestTemplate，网上一些比较老的资料给出的是手动读取配置文件来实现，最新版本已经可以自动注入OAuth2ProtectedResourceDetails         * @param oAuth2ClientContext         * @param details         * @return         */        @Bean        public OAuth2RestTemplate oauth2RestTemplate(OAuth2ClientContext oAuth2ClientContext,                                                     OAuth2ProtectedResourceDetails details) {            return new OAuth2RestTemplate(details, oAuth2ClientContext);        }    }第五步，实现首页：                            Spring Security SSO Client            Login                以及登录后才能访问的 securedPage页面：                             Secured Page            Welcome, Name                        Your authorities are authorities                演示单点登录好，客户端程序搭建好之后，我们先来测试一下单点登录的功能。启动客户端项目，打开浏览器访问：    http://localhost:8082/ui/securedPage可以看到，页面自动转到了授权服务器（8080端口）的登录页面：![](Images/00e5ca3792a65ff8b5f17aa9148bf549.png)savepage-src="https://static001.geekbang.org/resource/image/05/81/05b76f316304e3ef2d1494bae501c381.png"}登录后显示了当前用户名和权限：![](Images/1e97d1cd34139615fdf92aeaed3194e7.png)savepage-src="https://static001.geekbang.org/resource/image/7d/37/7d24bc73267506c15f9feyy546557237.png"}我们再启动另一个客户端网站，端口改为8083，然后访问同样的地址：![](Images/8ff71377153e47ad6791713f883b1af8.png)savepage-src="https://static001.geekbang.org/resource/image/7a/46/7a50619ace3e40c8ff7c0aa860f11246.png"}可以看到直接是登录状态，单点登录测试成功。是不是很方便？其实，为了达成单点登录的效果，程序在背后自动实现了多次302 重定向，整个流程为：    http://localhost:8083/ui/securedPage ->    http://localhost:8083/ui/login ->    http://localhost:8080/oauth/authorize?client_id=userservice3&redirect_uri=http://localhost:8083/ui/login&response_type=code&scope=FOO&state=Sobjqe ->    http://localhost:8083/ui/login?code=CDdvHa&state=Sobjqe ->    http://localhost:8083/ui/securedPage演示客户端请求资源服务器资源还记得吗，在上一节“搭建客户端程序”中，我们还定义了一个 remoteCall 接口，直接使用 OAuth2RestTemplate 来访问远程资源服务器的资源。现在，我们来测试一下这个接口是否可以实现自动的 OAuth 流程。访问：    http://localhost:8082/ui/remoteCall会先转到授权服务器登录，登录后自动跳转回来：![](Images/2af275ce7e8d377c6ce95d1adb014e39.png)savepage-src="https://static001.geekbang.org/resource/image/01/27/016f28b7161d2c600197aa2392b0de27.png"}可以看到输出了用户名，对应的资源服务器服务端接口是：    @PreAuthorize("hasAuthority('READ') or hasAuthority('WRITE')")    @GetMapping("name")    public String name(OAuth2Authentication authentication) {        return authentication.getName();    }换一个 writer用户登录试试，也能得到正确的输出：![](Images/db773012ebaaced230400bb40b7ca386.png)savepage-src="https://static001.geekbang.org/resource/image/yy/84/yy2bca66c45cefa56d2d727c3a136a84.png"}总结今天这一讲，我们完整演示了如何使用 Spring Cloud 的 OAuth 2.0组件基于三个程序角色（授权服务器、受保护资源服务器和客户端）实现三种OAuth 2.0的授权许可类型（资源拥有者凭据许可、客户端凭据许可和授权码许可）。我们先演示了三种授权许可类型的手动流程，然后也演示了如何实现权限控制和单点登录，以及如何使用客户端程序来实现自动的OAuth 2.0 流程。我把今天用到的所有代码都放到了 GitHub上，你可以点击这个链接slate-object="inline"查看。最后，我再提一下，将来 Spring 对于 OAuth 2.0的支持可能会转移到由社区推进的 Spring Authorization Server项目上来继续运作slate-object="inline"。如果你感兴趣的话，可以及时关注这个项目的进展。