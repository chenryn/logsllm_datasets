读者可能会问：“为什么要在这里讨论文件结构？我已经知道了。”这么说吧，UNIX环境中
的文件具有非常重要的意义，因为它们提供了到操作系统服务和设备的简单而又统一的接口。
UNIX里的一切事物都是文件。这就是原因！
这就意味着在一般情况下，程序完全可以像对待文件那样对待磁盘文件、串行口、打印机
以及其他设备。在后面的内容里我们将给出一些例外情况，比如网络方面等；但就主要用法
来说，你只需要五个基本的函数就足以应付大多数问题，它们是：open、close、read、write
和ioctl。
目录是特殊形式的文件。在现如今的UNIX操作系统里，甚至超级用户也不再被允许直接对
目录进行写操作。在正常情况下，所有用户都必须通过高级的opendir/readdir操作接口才能读取
加入jaVa编程群：524621833
---
## Page 87
68Linux程序设计
目录，不再需要了解系统中的目录是如何具体实现的。我们将在本章后面的内容里学习对目录
本身进行操作的特殊函数。
可以这么说，UNIX里面的任何事物都可以用一个文件来代表，要不就可以通过特殊的文件
来进行操作。这当然会与我们熟悉的正常文件有一定的区别，但其基本原则是一致的。下面就
来看看我们刚才提到的特殊文件。
3.1.1目录结构
一个文件，除了本身包含的内容以外，还会有一个名字和其他一些用于管理方面的“属性”
信息，比如文件的建立/修改日期、它的访问权限等。这些属性都被保存在一种我们称之为inode
（结点）的数据结构里，文件的长度和它在磁盘上的存放地点也保存在这里。系统使用的是文件
的结点编号、而子目录结构只不过是为方便人们的使用而给文件起的名字。
目录是一种用来保存结点号和其他文件的名字的特殊文件。目录文件里一个数据项实际上
是一个指向代表某个文件的inode结点的链接指针，删除该文件名就等于翻除与之对应的链接指
针（文件的结点号可以通过“ln-i”命令查看）。利用in命令，我们可以在不同的子目录里创建
到同一个文件的链接。如果文件的链接个数（即“1s-1”命令的输出中跟在访问权限后面的那个
数字）变为零，就表示该结点以及它所指向的数据不再有人使用，磁盘上的相应位置就会被标
记为可用空间。
文件排列在目录里，目录还可以有下一级的子目录。这就构成了我们熟悉的树状目录结构。
进-一步划分为电子邮件、商业信函、工具程序等各项用途的子目录。许多UNIX操作系统下的
是波浪线字符“”。要想进人他人的登录子目录，敲人“-user”（“~”加用户名）即可。各个
用户的登录子目录通常是一个高层目录的下级子目录，这个高层目录就是为这个目的而创建的，
在刚才举的例子里，它就是“/home”。但要提醒读者注意的是，标准函数库里的函数不能识别
和处理文件名参数中使用的波浪线符号。
"/home”又是根目录“7”的一个下级子目录，根目录位于目
录树的最顶端，它的各种下级子目录里包含着系统中的一切文件。
根自录一般都有存放系统程序（二进制可执行文件）用的“/bin”、
表物理设备和提供这些设备操作接口的文件传统上会被放在一个
名为“/dev”的子自录里。Linux文件系统布局的进一步资料请参
考“LinuxFile SystemStandard”（《Linux文件系统标准》），读者
oada W
图3-1。
图3-1
3.1.2文件和设备
硬件设备在UNIX操作系统通常也被表示（映射）为文件。比方说，作为根用户，我们下面
加入iaVa编程群：524621833
---
## Page 88
第3章如何使用和处理文件
69
的命令把CD-ROM驱动器映射为--个文件：
S mount -t 1so9660 /dev/hdc /mnt/cd_rom
s cd /mnt/cd_rom
这个命令把（开机引导时被加载为hdc的）CD-ROM驱动器中的当前内容挂装为子目录
/mnt/cd-rom下的文件结构。随后我们就可以象对普通文件进行操作那样在CD-ROM盘的子目录
中浸游，只不过其内容是只读的罢了。
比较重要的设备文件有三个，它们是/dev/console、/dev/tty和/dev/null。
1./dev/console设备
这个设备代表的是系统控制台。出错和诊断信息通常会被发送到这个设备。每个UNIX系统
都会有一个专门的终端或显示屏用来接收控制台消息。在过去，它会是一台专用的打印终端。
在现代的工作站，它通常就是“活联”的虚拟控制台，而在X窗口系统下，它会是屏幕上一个特
殊的控制台窗口。
2./dev/tty设备
特殊文件/dev/tty是进程控制终端（键盘和显示屏，或者键盘和窗口）的一个假名（逻辑设
备）一一-如果这个程序有控制终端的话。举例来说，通过cron运行的进程就没有控制终端，所以
它们就不能打开/dev/tty设备。
在能够使用该设备的情况下，/dev/uty允许程序直接向用户输出信息，不管用户具体使用的
是哪种类型的伪终端或硬件终端。在标准输出被重定向的情况下，这一功能非常有用。命令“1s
-R|more”就是一个这样的例子，因为more程序需要提示用户进行键盘操作之后才能显示下一
页内容。我们将在第5章看到更多使用/dev/uty的例子。
需要提醒大家注意的是，/dev/console设备只有一个，但通过/dev/tty能够访问的物理设备却
可以说是数不胜数。
/
3.idev/null设备
它就是我们所说的空（null）设备。所有写向这个设备的输出都将被丢弃。面读这个设备会
立刻返回一个文件尾标志，所以在cp命令里可以把它用做拷贝空文件的源文件。人们经常把不
想看到的输出重定向到/dev/null。
创建空文件的另一个办法是使用“touch”命今，它的作用是改变文件
的修改时间；如果指定名字的文件不存在，就创建一个断文件。但它并不会主动把有内
容的文件变成空文件。
Secho do not want to see thie >/dev/null
S cp/dev/nul1 eapty_f11e
可以在/dev里找到的其他设备包括硬盘和软盘、通信端口、磁带驱动器、CD-ROM、声卡以
及一些代表系统内部工作状态的设备。甚至还有一个名为/dev/zero设备，它的作用是作为内容是
null字节的源文件创建零长度文件。访问其中的某些设备需要具有超级用户权限：普通用户不能
通过编写程序去直接访问底层设备一一比如硬盘。设备文件的名字会随系统的不同而不同。
Solaris和Linux都提供了以超级用户身份运行的对设备进行管理的命令或软件，那些设备以其他
加入jaVa编程群：524621833
---
## Page 89
70
Linux程序设计
方式是无法访问的：可以由用户挂装的文件系统上提供的moumt就是一个这样的命令。
在这一章里，我们将集中讨论磁盘上的文件和目录。我们将在第5章讨论另一种设备，用户
的终端。
3.2系统调用和设备驱动程序
用很少数量的函数我们就可以对文件和设备进行访问和控制。这些函数被称为系统调用，
是由UNIX（和Linux）直接提供的，是通向操作系统本身的操作接口。
操作系统的核心部分、即内核，是一系列设备驱动程序。这是一些对系统硬件进行操控的
底层接口1，我们将在第21章对设备驱动程序做深人的研究。举例来说，磁带机就有-个与之对
应的设备驱动程序，它知道如何启动磁带、如何对它前后回绕、如何对它进行读写，等等。它
还知道磁带必须以固定长度的数据块为单位进行读写。因为磁带上的数据读写操作完全是线性
的、所以该驱动程序并不能直接访问磁带上的数据块，必须先把它回绕到正确的位置才行。
类似地，一个底层的硬盘设备驱动程序--次必须读写一整块硬盘扇区，但能够直接存取硬
盘上任意位置上的数据块，因为硬盘是一种随机存取设备。
为了向用户提供一个统一的操作界面，设备驱动程序封装了所有与硬件直接相关的功能操
作，人们一般通过ioctl调用来完成典型的硬件功能。
/dev中的设备文件其用法都是一致的，它们都可以被打开、读、写和关闭。举例来说，用来
访问正常文件的open调用同样可以用来访问一台用户终端、一台打印机或一台磁带机。
用来访问设备驱动程序的底层函数，即系统调用，包括：
uodo .
打开一个文件或设备。
•read
从一个打开的文件或设备里读数据。
• write
写入一个文件或设备。
close
关闭一个文件或设备。
• ioctl
把控制信息传递到设备驱动程序。
系统调用ioctl被用来提供一些与特定硬件设备有关的必要控制（与正常输入输出相对应），
所以它的用法随设备的不同而不同。举例来说，一个ioct1调用对磁带机来说是回绕，对串行口来
说就是设置数据流控制字符。由于这个原因，各种计算机上的iocu倒不必具备什么可移植性。此
外，每个驱动程序都有它自己的一套ioctl命令。
这些调用和其他的系统调用的文档一般被放在UNIX操作系统man命令给出的使用手册的第
二小节。语法模型提供了系统调用的参数清单及其函数返回类型，而相关的“#define”定义了
有关的常数，它们都由include语句中的头文件提供。每个系统调用特有的特点包括在各个调用
的说明里。
3.3库函数
之低。为什么呢？
·系统调用会降低计算机的执行性能。这是因为UNIX没有一个在运行用户程序代码和执行
加入jaVa编程群：524621833
---
## Page 90
第3章如何使用和处理文件
71
它内核代码两种情况之间来回切换的开关，因此系统调用与函数调用相比开销要大一些。
·硬件在技术和工艺上有一定的条条框框，这会给底层系统调用一次能够读写的数据块加上
限制。举个例子，磁带机的写操作一般都要求达到其最小数据块长度，比如说是10k：如
果你写的数据量少于这个数字，带机还是会以10k为单位卷绕磁带，这就在磁带上留下
了空隙。
为了给设备和磁盘文件提供更高层的操作界面，UNIX操作系统提供了一系列的标准函数库。
它们是一些由函数构成的集合，用户可以把它们包括在自已的程序里去处理那些与设备和文件
有关的问题。带有输出缓冲功能的标准I/O库就是一个这样的例子。用户可以高效率地写任意长
度的数据块，库函数则在数据满足数据块长度要求的时候安排执行底层系统调用。这就大大降
低了系统调用的负面影响。
库函数的文档一般被放在UNIX操作系统man命令给出的使用手册的第三小节，并且往往会
有一个与之对应的头文件，比如与标准I/O库对应的stdio.h文件。
下面这个图是对前几小节讨论的总结，图3-2的UNIX系统显示了各种文件函数与用户、设备
驱动程序、内核和硬件之间的关系。
用户程序
库
一用户空润
用
系统调用
内核
内核空间
硬件设备
图3-2
3.4文件的底层访问
一个运行中的程序被称为一个进程，它有一些与之关联的文件描述符。这是一些小数值整
数，用户可以通过它们访问打开的文件和设备。可用文件描述符的数量取决于UNIX系统的配置
情况。在一个程序开始运行的时候，这些文件描述符里一般会有三个是已经为它打开了的。它
们是：
·0
标准输人。
·1
标准输出。
·2
标准错误。
加入jaVa编程群：524621833
---
## Page 91
72
Linux程序设计
用户可以通过系统调用open把其他文件描述符与文件和设备关联在一起，我们马上就要介
绍到这个调用。即使只有自动打开的文件描述符，就已经足以让我们利用write编写出一些简单
的程序了。
3.4.1write系统调用
#include 
size_t write(int fildea, conat void *buf. aize_t nbytes):
系统调用write的作用是把缓冲区buf里的前nbytes个字节写人与文件描述符fildes相关联的文
件中去。它的返回值是实际写出的字节数。如果文件描述符有错，或者底层设备驱动程序对数
据块尺寸比较敏感，该返回值就可能会小于nbytes的值。如果这个函数的返回值是0，就表示没
有写出任何数据；如果是-1，就表示在write调用中出现了错误，对应的错误代码保存在全局变
量errno里面。
有了这些知识，我们来编写第一个C语言程序simple_write.c，如下所示：
#include 
tinclude 
int main()
if ((write(1. *Here is gcme data\n*, 18)) 1= 18)
vrite(2, *A vrite error has occurred on file descriptor 1\n*,46):
exit(0) :
1
这个程序很简单，只是在标准输出上显示一条消息面已。当一个程序退出运行的时候，所
有已经打开的文件描述符都会自动关闭，不需要由用户来明确地关闭它们。如果我们是在处理
被缓冲的输出，情况就不一样了。
Saixple_write
Here is some data
$
有一个不太重要的问题，就是write会报告说它写的字节比用户要求的少。这并不一定是个
错误。用户应该在自已的程序里检查errno看看是否出现了错误，然后再次调用write写出其余的
数据。
本章中的所有例子都假设当前子目录已经被放在读者的PATH变量里了，另外，读者没有在
自己是超级用户时运行这些程序。如果没有把当前子目录放到PATH变量里去（超级用户绝不应
该这样做），你可以象下面这样给出当前子目录来运行这些个程序：
$./sinple_write
3.4.2read系统调用
#include 
size_t read(int fildes, const void *buf, size_t nbytes);
系统调用read的作用是从与文件描述符fildes相关联的文件里读人nbytes个字节的数据并把它
加入jaVa编程群：524621833
---
## Page 92
第3章如何使用和处理文件73
们放到数据区buf里去。它的返回值是实际读人的字节数，它可能会小于nbytes的值。如果这个
函数的返回值是0，就表示没有读入任何数据；它到达了文件尾。同样，如果是-1，就表示在
read调用中出现了错误。
下面这个simple_read.c程序把标准输人的前128个字节拷贝到标准输出去。如果输入少于128
个字节，就把它们全体拷贝过去。
#include 
include 
int nain()
char buffer[128]:
int nread;
nread = read(0. buffer, 1281;
if (nread 9*
write(2.*A read error has occurred\n*, 26):
{T-
if ((write(1,buffer,nread)) = nread)
write(2.*A write error has occurredn*,27);
exit(0):
运行这个程序，我们会看到：
S cho hello tbere 1 simple_read
hello there
S sixple_reed<draft1.txt
Files
In this chapter we will be looking at files and directories and how to manipulate
them. We will learn how to create files, os
请注意，下一个shell提示符出现在输出数据最后一行的尾部，这是因为例子里的128字节没
有构成完整的两行（最后一个字符不是换行符）。
3.4.3open系统调用