1
请注意，任何单个字符都存在多种表示及编码方法。
·尽可能使用白名单输入验证并拒绝非规范格式的输入。
6.通过设计来避免SQL注入的危险
·使用存储过程以便在数据库层拥有较细粒度的许可。
·可以使用数据访问抽象层来对整个应用施加安全的数据访问。
8.11常见问题解答
问题：为什么不能使用参数化语句来提供表名或列名？
解答：不能在参数化语句中提供SQL标识符，是因为在数据库中它们会被编译并且之后
会被提供的数据填充。这要求SQL标识符在提供数据之前的编译期间出现。
问题：为什么不能拥有参数化的ORDERBY子句？
解答：这个问题的答案与上一问题相同，因为ORDERBY包含一个SQL标识符，也就是
要进行排序的列。
问题：如何在X技术中对Y数据库使用参数化语句？
解答：大多数现代编程语言和数据库均支持参数化语句，请查看当前使用的数据库访问
API的文档。请记住，有时也将这些语句称为预处理语句。
问题：如何参数化存储过程调用？
解答：在大多数编程语言中，这与使用参数化语句非常类似或者完全相同。请查询当前使
用的数据库访问API的文档。请记住，有时也将这些语句称为可调用语句。
问题：从哪里获取良好的用于验证X的黑名单？
解答：非常不幸，向黑名单中放入什么内容取决于应用程序的语境。如果可能的话，请尽
量不要使用黑名单，因为我们无法列举出所有的潜在攻击或恶意输入。如果必须使
用黑名单，请确保要么使用输出编码，要么将黑名单输入验证作为唯一的验证方法。
325
---
## Page 340
SQL注入攻击与防御（第2版）
问题：使用白名单输入验证是安全的吗？
解答：不是。这取决于您允许通过的内容。例如，可能允许输入单引号，当在动态SQL
中包含这样的输入时就会产生问题。
问题：哪些场合比较适合使用白名单输入验证？哪些场合适合使用黑名单输入验证？
解答：在应用程序中接收输入的地方使用白名单输入验证，以便对敏感内容执行验证。在
Web应用防火墙或类似的位置适合将黑名单验证作为附加的控制，以此来检测明显
的 SQL注入攻击企图。
问题：需要对发送给数据库和从数据库获取的输入都进行编码吗？为什么？
解答：不管在哪里使用动态SQL，都需要确保提交给数据库的内容不会引发SQL注入间
题。这并不意味着恶意内容已经变得安全。当从数据库查询这些内容并在其他地方
的动态SQL中使用时，还是会存在危险。
问题：应该在哪些位置进行编码？
解答：应该在使用信息的位置附近进行编码。如果在数据未到达数据库之前向数据库提交
数据，就应该对数据进行编码。应该在有可能使用数据的位置附近（例如，将数据展
编码）对来自数据库的数据进行编码。
问题：如何对使用X技术收到的输入执行规范化/标准化？
解答：请参考开发过程中使用的框架的文档来获取规范化和标准化支持。如果没有其他支
持可用的话，也可以考虑使用外部框架（比如用于标准化的icu或iconv）来将输入转
换成ASCII。
问题：为什么Unicode的规范化如此复杂？
解答：Unicode 允许使用多字节格式米表示字符。考虑到Unicode的产生方式，同一字符
可能存在多种表示。有些情况下，使用的可能是过时或实现上比较拙劣的Unicode
解释器。在这些解释器中，某个字符的额外无效表示可能还在起作用。
问题：可以在存储过程中使用动态SQL，是吧？
解答：是的。但请注意，您同样还可以在存储过程中包含SQL注入。如果在存储过程的
动态SQL查询中包含用户控制的信息，那么将很容易受到攻击。
问题：我使用了Hibermate，因而可以免受SQL注入攻击，对吗？
解答：不对。Hibemate 确实能够激发安全的数据库访问行为，但您仍然可以在Hibermate
中创建可注入的SQL代码（尤其是使用原生查询时）。要避免动态SQL并确保正在
对约束变量使用参数化语句。
326
---
## Page 341
第9章平台层防御
本章目标
·使用运行时保护
·确保数据库安全
·附加的部署考虑
9.1概述
第8章讨论了在代码层防止SQL注入时可以采取的操作和防御措施。本章将注意力转移
到检测、减轻并阻止SQL注入的平台层防御。平台层防御是指能提高应用程序总体安全的运
行时优化处理或配置更改。本章涉及的保护范围会有所变化，不过从整体来看，我们介绍的技
术将有助于实现一种多层的安全架构。
我们将首先介绍运行时保护技术和技巧，比如Web服务器插件和影响应用框架的特性。接
下来介绍确保数据库中数据及数据库自身的安全策略，以减少可利用的SQL注入漏洞带来的
影响。最后介绍在基础结构层可以进行哪些工作以降低威胁。
一定要记住，本章介绍的解决方案不能替代安全代码的编写，它们与安全代码是互补的关
系。加固过的数据库不会阻止SQL注入，但却明显会使利用漏洞变得更困难，也有助于减轻
漏洞可能造成的影响。Web应用程序防火墙或数据库防火墙可以扮演漏润检测和代码校正之间
的虚拟补丁的角色，还可以作为 O-day威胁(zero-day threat)的强大防御，比如自动 mass-SQL注
入攻击，它在数天内成功注入了逾10万个Web站点。不管是现有的还是新的应用，平台层安
全都是总体安全策略的重要组成部分。
9.2使用运行时保护
本节关注安全解决方案的运行时保护，这些解决方案用于检测、减轻或防止那些不需要重
编译易受攻击的应用程序的源代码即可部署的SQL注入。这里介绍的解决方案主要是Web服
务器和部署框架（例如，NET框架、J2EE、PHP等）的软件插件或是针对Web或应用平台的用
于修改和扩展特性的技术。我们讨论的大多数软件解决方案都是开源或免费的，可以从Intermet
上下载到。虽然有些商业产品实现了本章讨论的一种或多种策略和技术，并且在绝大多数情况
下这些商业产品都支持配置和管理选项，以使使之在企业环境下进行更好的配置，但我们在这
里不会介绍它们。
运行时保护是一种有价值的用于减轻并防止已知的SQL注入漏洞利用的工具。修复易受攻
击的源代码永远是理想的解决方案，但所需要的开发成本可能并不可行、不实用、不能物有所
---
## Page 342
SQL注入攻击与防御（第2版）
值，或者没有办法实现。通常购买的商业版现货供应(Commercial Off-The-Shelf，COTS）应用是
编译后的格式，不存在修复代码的可能。即便能得到某种COTS应用的非编译代码，但自定义
的内容却可能违反合同并（或）干扰软件供应商根据正常的发布周期来提供更新。接近退役的合
法应用程序可能无法确保必需的代码修改所需要的时间和努力。相关组织可能在计划修改代
码，但短期内他们不具备进行这项工作的资源。这些常见的情况使以虚拟补丁（virtual patching）
或权宜解决方案方式出现的运行时保护变得很有必要。
即便获取了修复代码的时间和资源，也仍然可以将运行时保护作为一种有价值的安全层来
检测或挫败未知的SQL注入漏润利用。如果应用程序从未经历过安全代码复查或渗透测试，
应用程序所有者就可能不会意识到这些漏润，来自初始利用技术和散布在Intemet上的最新最
大的SQL注入螨虫的成胁同样存在。从这方面看，运行时保护不仅是一种反应性的防御机制，
面且是实现全面的应用程序安全的主动步骤。
虽然运行时保护提供了很多好处，但不要忘记考虑它可能涉及的一些成本。根据解决方案
的不同，应该预见到方案可能出现某种程度的性能衰退（不难发现，运行时保护存在附加的处
理和开销）。评估解决方案时（尤其是商业方案），一定要索取文档化的性能统计。另外，要注意
有些运行时解决方案比其他方案更难配置。如果解决方案过于复杂，工作起来花费的时间和资
源超过了修复代码所花费的成本（甚至更加糟糕），那么您可能会决定不使用它。请确保选择的
解决方案附带了详细的安装说明、配置案例和支持（这并不意味着付费支持，有些免费的解决
方案会通过论坛提供很好的在线支持），获取最合适的运行时保护，关键是积极主动地学习该
技术的分界线并评估它如何才能最好地提供帮助。
9.2.1Web应用防火墙
在Web应用程序的安全问题中，最有名的运行时解决方案是使用Web应用防火墙(WAF)。
WAF是一种网络设备或是一种将安全特性添加到Web应用的基于软件的解决方案。具体来说，
我们主要关注WAF能够在SQL注入保护上提供什么功能。
基于软件的WAF通常是一些以最小化配置嵌入到Web服务器或应用程序中的模块，它们
的主要好处是Web基础结构仍保持不变，并且能够无缝地处理HTTP/HTTPS通信，因为它们
运行在承载Web或应用程序的进程中。基于网络设备的WAF不会耗费Web服务器资源，相反
它们可以保护多种不同技术的Web应用程序。我们不会深入讲解网络设备。不过，如果运行在
配置为反向代理（reverseproxy）服务器的Web服务器上，就可以使用一些软件解决方案作为网
络设备。
秘密手记
需要帮助以评估WAF吗？
遗憾的是，有时WAF的有效性会受到批评，不过这些批评通常针对的是特定的实
现或商业产品，不管人们对WAF的评价如何，它都将是Web应用安全的中流砥柱（尤
其是在成为标准体（standard body）之后），比如PCI(Payment CardIndustry，支付卡行业）
同意将其作为满足PCIRequiremcnt6.6的一个选项。
为帮助评估潜在的WAF解决方案的各种特征，WASC（Web应用安全协会）公布了
“WAFEC(WebApplication Security Consortium，Web应用防火墙评估标准）”文档（www
webappsec.org/projects/wafec/).它为启动WAF解决方案评估提供了良好的开端，
328
---
## Page 343
第9章平台层防御
使用 ModSecurity
WAF的事实标准是开源的ModSecurity（www.modsecurity.org/）。ModSecurity被开发成
Apache 的一个模块。如果将Apache Web服务器配置成反向代理，那么ModSccurity实际上可
以保护任何Web应用（甚至是ASP和ASPNETWeb应用)。可以使用 ModSecurity来实现攻击
预防、监控、入侵检测和一般的应用程序加固。我们将使用ModSecurity作为主要的例子来介
绍使用WAF时在检测并预防SQL注入方面的主要特征。
1）可配置规则集
Web应用程序的环境是唯一的。WAF必须高度可配置才能适应各种不同的情况。
ModSecurity的威力在于它的规则语言上，这种语言是配置指令和应用到HTTP请求和响应的
一种简单编程语言的组合。ModSecurity的结果通常是具体的动作，比如允许请求通过、把请
求记录到日志或者阻塞该请求。在查看具体的例子之前，我们先看一下ModSecurity的SecRule
指令的通用语法，如下所示：
SecRule VARIABLE OPERATOR [ACTIONS]
VARIABLE属性告诉 ModSecurity到哪里访问请求或响应，OPERATOR 属性告诉ModSecurity
如何检查数据，ACTIONS属性确定出现匹配时做哪些操作。ACTIONS属性是可选的规则选项，
它可以定义默认的全局动作。
处理HTTP请求数据时，可以对ModSecurity的规则进行配置以实现否定（例如，黑名单)
或肯定（例如，白名单）的安全模型，如下所示是ModSecurity 核心规则集(ModSecurityCore Rule
Set）的Generic Attacks 规则文件（modsccurity_crs_40_generic_attacks.conf)中的一条实际的黑名
单 SQL注入规则：
SQL injection
SecRule
REQUEST_COOKIES |REQUEST_COOKIES_NAMES REQUEST_FILENAME:| ARGS_NA
MES |ARGS I xML : / * * (?L : \bxp_cmdshe11 \b) = \
*phase:2, rev: *2.2.3', capture, multiMatch, t:none, t:ur1DecodeUni, t:r
Attack', id: * 959052', tag: *WEB_ATTACK/SQL_INJECTION*, tag: *WASCTC/WA
SC-
19′, tag: *oWASP_TOP_10/A1', tag: *oWASP_AppSensor/CIE1', tag: 'PCI/6.5
.2′, 1ogdata : *s(TX.0) *, severity:*2', setvar: *tx.msg=% (rule,msg) ′, se
tvar:tx.sql_injection_score=+$[tx.critical_anomaly_score),setvar:
tx.anomaly_score=+$ (tx.critical_anomaly_score), setvar:tx.$(rule. 1
d) WEB_ATTACK/SQL_INJECTION3 (matched_var_name) =#{tx. 0} "
接下来的要点有助于我们了解该规则，它们介绍了每一条配置指令。要想获取关于ModSecurity
指令的更多信息，请参考ModSecurity的官方文档，它位于www.modsecurity.org/documentation/。
·该规则是一条安全规则(SecRule)，用于分析数据并根据结果执行动作。
●该规则将应用到请求体(phase:2)。对请求体进行分析的具体对象是请求路径(REQUEST
FILENAME).所有的请求参数值都包括POST数据（ARGS)和请求参数名（ARGS_NAMES)
请求中包含的所有cookie(REQUEST_COOKIES)和cookie 名称(REQUEST_COOKIES
NAMES)，以及请求中包含的所有XML内容(XML：/*)
329
---
## Page 344
SQL注入攻击与防御（第2版
·根据正则表达式模式来匹配每个目标对象。请注意，已经为该正则表达式启用了捕获
(capture），这意味着以后可以使用替代变量0~9来访问那些使用括号分组且部分匹配该
模式的数据。
·匹配之前先让请求数据经历多种转换（使用rsymtax米表示），这样有助于解码攻击者采
用的避开性编码（evasive encoding）。最开始是r:none，它清除之前设置的所有转换函数
和规则。最后是t:replaceComments，它用一个空格替换C风格的注释（例如/*注释*/)。
转换的更多信息）。
·指示ModSecurity将这条规则的响应体记录到日志中（ctl:audiLogParts=+E)。
·接下来，对该规则的一次成功的匹配将导致请求被锁定（blocked)。一条表明这是一次
SQL注入攻击的消息将添加到规则（msg:“SQLinjectionAttack")，一个区分攻击类型的标
此外，还要借助前面提到的捕获特性来将部分匹配数据记录到日志中(logdata:“%{TX.0)”)。
写日志前请正确避开所有数据以避免日志伪造攻击。
·成功的匹配将使ModSccurity核心规则集（CoreRuleSet）内使用的一些变量递增或者设
置这些变量，以跟踪由用户设置的阅值的异常匹配。
·该规则还被分配了唯一的ID（id:“959052”)。
ModSecurity核心规则集包含了用于SQL注入和SQL首注的黑名单规则，根据应用程序的
差异，它们可能会产生误判，这些规则的默认动作是递增异常记录，这些异常记录将用于跟踪
已匹配规则的普遍程度。采用这种方式，用户可以为应用程序设置恰当的异常阅值以避免阻塞
具有“现成可用（out-of-the-box）”规则集的合法请求。我们可以在不影响正常应用行为的前提
下最小化可能的误判面不会影响到应用程序的正常行为，并调整规则以便轻松地设置规则以阻
塞本应面对的 0-day威胁。并非只有ModSccurity会产生错误肯定，如果调整不正确，那么所
有WAF都会产生误判。ModSecurity核心规则集的默认行为是首选的，因为我们希望在产品环
境中开启主动保护前监视应用的行为并调整规则。如果正在使用ModSecurity修复已知的漏润，
那么可以构造一个自定义的实现了积极安全的规则集（白名单)。
下面展示了一种自定义的白名单规则，可以用来为PHP脚本应用虚拟补丁。发送给script
php 的请求必须包含一个名为 statid的参数，它的值必须是1~3位长度的数字。拥有这个补丁
后，便不可能出现借助statid参数的SQL注入漏洞利用：
SecRule 6ARGS "!@eq 1"
SecRule ARGS_NAMES *!^statids"
2）请求覆盖范围
WAF的SQL注入保护可能需要很多技巧。实际上，攻击有效载荷可以出现在HTTP请求
的任何位置，比如查询字符串、POST数据、cookie、自定义的或是标准的HTTP头（例如，Referer、
Server等)，以及URL路径的部分内容中。ModSecurity能够处理所有这些情况。下面列出了
ModSecurity支持的变量列表（例如，用于分析的目标对象）的一个例子，它有助于读者了解
330