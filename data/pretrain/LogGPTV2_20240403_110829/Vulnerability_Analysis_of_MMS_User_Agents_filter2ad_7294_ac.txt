pleted, the fuzzing can be started. As soon as the applica-
tion crashes, the two steps have to be repeated over before
the fuzzing can be continued.
6.1 Fuzzing MMS Header Fields
The MMS header, as shown in Figures 3 and 4, is com-
posed out of multiple variable-length ﬁelds besides the sim-
ple 1-byte-wide ﬁelds. The different ﬁelds use various kinds
of encoding schemas in the binary MMS message format.
The encoding schemas used are the main focus in this sec-
tion.
6.1.1 Number Formats
the long-int-
We looked at three number formats:
eger,
the uintvar (variable length unsigned inte-
ger) and the value-length (all speciﬁed in [21]).
The value-length is heavily used for encoded-
-strings, and, therefore, needs special attention.
Long Integer. The long-integer is a multi-byte value
where the ﬁrst byte indicates the number of bytes com-
posing the value. These bytes must be interpreted as a
big-endian unsigned integer.
used where all but the last byte have the most signif-
icant bit set, to indicate a following byte. The maxi-
mum value length is 32 bit encoded in 5 bytes.
Value Length. The value-length format is either ex-
actly 1 byte, or multiple bytes long. In the 1-byte for-
mat, a number between 0 and 30 can be represented.
In the multi-byte format the ﬁrst byte needs to be 31
and is followed by a uintvar.
The number formats are somehow complex and imple-
mentation errors in the corresponding parsing routines seem
likely. Therefore, we designed test cases for each format.
Along with the parsing tests, standard boundary condition
tests were implemented. Below, we ﬁrst present the pars-
ing tests, followed by a short description of the boundary
condition tests.
The long-integer format consists of a length byte
followed by a number of data bytes. We anticipate that
incorrectly written parsers overwrite a static buffer due to
blindly copying the number of bytes given by the length
ﬁeld. Therefore, for each test case, the length and the num-
ber of data bytes is increased by one, starting with a length
of zero.
The uintvar format does not have a range limit since
is terminated by a special character (like a NULL-
it
terminated string), and, therefore, the format is tested like
a string. Tests are divided into two parts, relatively short
strings ranging in length from 1 to 255 and long strings
matching common buffer sizes (256, 512, 1024, 2048,
4096, ...65535).
The boundary condition tests where conducted by legally
encoding the test values into the relevant ﬁelds (e.g., the
length ﬁeld of an encoded-string). Our test values are
based on the advice given by [13]. Basically three groups
are tested: very small numbers (e.g., -1, 0, 1, 2, 10, 20,
30), very big numbers (e.g, 0xffff, 0x7fffffff, 0xffffffff) and
numbers around the byte boundaries (e.g., 28, 28 − 1, 28 + 1,
216).
6.1.2 String Formats
Strings are basically encoded as a sequence of characters
terminated by a NULL character, with a few exceptions for
special cases. The earlier-mentioned encoded-string
is a combination of a normal string and a length ﬁeld. The
different string types are speciﬁed in [21] and are explained
below.
Variable Length Unsigned Integer. The uintvar for-
mat separates the number into 7 bit blocks with the re-
maining bit (the most signiﬁcant bit) as a continue ﬂag.
If a value requires more then 7 bits, multiple bytes are
Text-String. A text-string is a NULL-terminated
string of characters. A leading quote character (dec-
imal 127) is required if the ﬁrst character is between
128 and 255.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:30:50 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Encoded-String. The
encoded-string
the text-string.
basically
is an extension of
The
encoded-string is either a text-string or a
value-length followed by a character-set
identifier and a text-string, to indicate the
total length and the character-set used by the string,
respectively.
String fuzzing is performed by a number of fuzzing
tools [4, 10], and, therefore, we do not provide many details.
In general all string ﬁelds were tested for buffer overﬂows
using sequences of printable and non-printable characters
of various lengths. Special test strings containing format
directives, such as “%n”, were used to trigger possible for-
mat string vulnerabilities.
Encoded-strings also required more tests. Here,
the length ﬁeld is set to indicate fewer bytes than the string
actually contains. Parsers that blindly accept the length in-
dication would allocate a buffer to hold exactly the number
of bytes indicated, and then use strcpy (since the string
is NULL-terminated) to copy the string.
6.1.3 The Content Type Field
The Content-Type ﬁeld has a special format and requires
particular attention. The format of the ﬁeld is deﬁned in
[21] (p.90), and consists of several subﬁelds (parameters):
a value-length (for the complete ﬁeld) followed by the
content-type itself, followed by the parameters. The
parameters are encoded like message header ﬁelds: ﬁrst
the ﬁeld name (encoded as 1-byte-value) and then the value
(e.g., a NULL-terminated string). The content-type it-
self is either a 1-byte-value (in case of a “well-known” type)
or a string.
We anticipated that User Agent implementations would
be “optimized” for standard cases and would likely misbe-
have in non-standard cases. In our test cases, all parameters
are treated as string ﬁelds and were tested by using the string
length and format string tests described earlier.
6.2 Fuzzing the MMS Message Body
The MMS message body consists of multi-part en-
tries. This means that each body part consists of a small
header right before the actual content data. The individ-
ual body parts are concatenated. The format of the multi-
part entry header is almost the same as the format of the
Content-Type ﬁeld in the message header and has two addi-
tional length ﬁelds.
For testing the multi-part entry header we used the exact
same test cases that we created for the Content-Type ﬁeld.
We did not perform any content data fuzzing besides SMIL,
which is described below.
Figure 5. A SMIL ﬁle generated by MMS Com-
poser.
6.3 Fuzzing SMIL
SMIL [17] along with WML [18] is the presentation
layer of an MMS message, it describes how the multiple
parts of a message (e.g., text, image, audio or video) are
presented to the user. In other words, it is the HTML of
MMS messages. Figure 5 shows a SMIL ﬁle generated by
MMS Composer, the PocketPC MMS User Agent.
We concentrated our analysis on the most obvious prob-
lem: the length of ﬁeld values. We ignored ﬁelds with com-
mon formats like width or height, since these also exist
in HTML. We tried to avoid testing reused (tested) code by
only testing SMIL-speciﬁc parts, where the code could not
have been reused. Also, we only looked at ﬁelds that do not
need any parsing, because of possible buffer size checks.
We decided to focus our efforts on the id parameter of the
region ﬁeld and the region and src parameter of the
text ﬁeld. These ﬁelds were tested using the string tests
described earlier.
6.4 Fuzzing Results
We used our virtual MMS system to deliver “fuzzed”
MMS messages to the User Agent, and we found numer-
ous string-length-related buffer overﬂows. We also found
that the parser that handles the binary Content-Type values
does not behave well and crashes when fed with unexpected
values. In total we discovered more then 10 different ﬁelds
whose parsing routines contain buffer overﬂows. Some of
the buffer overﬂows are security-critical since they reach
the stored return address on the stack, and allow one to hi-
jack the program’s control ﬂow. To demonstrate that some
of the attacks found were exploitable we developed a proof-
of-concept exploit for one of the vulnerabilities.
In the M-Notiﬁcation.ind message we found that the
length of the three header ﬁelds X-Mms-Content-Location,
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:30:50 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Subject, and X-Mms-Transaction-ID is not handled cor-
rectly, leading to buffer overﬂows. We could use these over-
ﬂows to perform a denial of service attack, only, since they
do not allow one to overwrite the return address saved on
the stack.
In the M-Retrieve.conf message parsing routines we
found three buffer overﬂows. As in the M-Notiﬁcation.ind
message, the Subject can be used to crash the applica-
tion. The other two overﬂows were found in the Content-
Type ﬁeld.
In this case, the content-type itself and
the start-info parameter trigger a stack overﬂow.
Also, the content-type part overﬂow reaches the return
address stored on the stack.
Additionally,
three buffer overﬂows where found in
the multi-part entry header of the message body. Here,
the content-type, Content-ID, and Content-
Location ﬁelds are not handled correctly. All three over-
ﬂows reach the return address stored on the stack and can
be used for gaining control over the program counter.
We further found multiple string-length-related over-
ﬂows in the SMIL parser. In this case, the id parameter of
the region tag and the region parameter of the text
tag can be used to overﬂow the stack.
The results gathered from our tests clearly show that se-
curity was neglected while the particular MMS User Agent
was developed; even very basic string length checks were
not implemented.
7 Attacking MMS User Agents
Through our tests of the sanitization performed by the
MMS Relay (see Section 5.2), we found it more likely that
message-body-related vulnerabilities could be exploited in
the real world. The reason for this is that the MMS Relay
sanitizes some ﬁelds and converts the header ﬁelds of an
MMS message to plain text. Thus, the infrastructure would
remove the exploit from the message or reject the message
altogether.
We have further investigated possibilities for circum-
venting the mobile phone service provider infrastructure in
order to deliver malformed MMS messages to victim de-
vices. The easiest way to accomplish this task is to run a
malicious MMSC (e.g., an HTTP server with the conﬁgura-
tion described in Section 5.3). Then, one would only need
to send a notiﬁcation message to the victim device contain-
ing a URL pointing to the malicious MMSC. The problem
is that some phone service providers run closed MMS sys-
tems, where the WAP gateway cannot connect to any IP
address other than the one of the MMS Relay. Therefore,
closed MMS systems implicitly protect their users.
To be able to attack a device using a real-world infras-
tructure, we leveraged the lack of checks on the MMS mes-
sage body. Therefore, we created a proof-of-concept exploit
Figure 6. The Proof-of-Concept MMS Com-
poser Exploit.
that executes code on the target device using the buffer over-
ﬂow vulnerability found in the SMIL parser. We exploited
the buffer overﬂow in the parser for the id parameter of
region tag to overwrite the return address and hijack the
program’s control ﬂow. The exploit displays a message box
to show that the code was executed. Figure 6 shows the
result of the execution of the MMS Composer exploit.
The malicious MMS message that contains the ex-
ploit/shellcode is sent like any other MMS message: it is
submitted to the MMS Relay of the senders mobile phone
service provider, forwarded to the MMS Relay of the recip-
ient’s service provider, and delivered to the recipient. The
MMS message is actually generated on and sent from a
desktop computer that accesses the service provider’s net-
work via a GPRS dial-up connection.
Our exploit is the ﬁrst to perform a remote code exe-
cution attack against a mobile phone using an MMS mes-
sage as the attack vector. Vulnerabilities like the one we
exploited for our proof-of-concept attack have serious im-
plications, because they do not require user interaction in
order to activate their payload, and, therefore, can be lever-
aged by worms that spread using MMS messages. In ad-
dition, vulnerabilities in MMS User Agents pose a more
serious threat than the ones in traditional applications. In
fact, MMS User Agents are always running, and, therefore,
can always be attacked, while traditional network applica-
tions can only be attacked when the phone is connected to
an IP-based network.
8 Conclusions
We presented a novel method for performing vulnerabil-
ity analysis of smart phones that takes into account the side-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:30:50 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006[12] Oulu University Secure Programming Group. PROTOS
Security Testing of Protocol Implementations.
http:
//www.ee.oulu.fi/research/ouspg/protos/,
2002.
[13] P. Oehlert. Violating Assumptions with Fuzzing. IEEE Se-
curity and Privacy, April 2005.
[14] S. Hellkvist. MMSLib. http://www.hellkvist.
org/software/#MMSLIB, 2004.
[15] The Kannel Group. Kannel: Open Source WAP and SMS
Gateway. http://www.kannel.org.
[16] P. M. W. Enck, P. Traynor and T. L. Porta. Exploiting Open
Functionality in SMS-Capable Cellular Networks. In Con-
ference on Computer and Communications Security, 2005.
[17] W3C.
Synchronized Multimedia Integration Language
http://www.w3.org/TR/2005/
(SMIL 2.1).
REC-SMIL2-20051213/, December 2005.
[18] WAP Forum.
less Markup Language Speciﬁcation.
wapforum.org.
Wireless Application Protocol Wire-
http://www.
[19] WAP Forum. WAP-210-WSP Wireless Application Protocol
Architecture Speciﬁcation. http://www.wapforum.
com, 2000.
[20] WAP Forum. WAP-206-WSP Wireless Application Protocol
Multimedia Messaging Service Client Transactions Speciﬁ-
cation. http://www.wapforum.com, 2001.
[21] WAP Forum. WAP-230-WSP Wireless Application Protocol
Wireless Session Protocol Speciﬁcation. http://www.
wapforum.com, 2001.
[22] WAP Forum. WAP-209-WSP Wireless Application Pro-
http://www.
tocol MMS Encapsulation Protocol.
wapforum.com, 2002.
effects of the service infrastructure. Our method relies on a
simulated infrastructure to avoid the cost and time factors
normally associated with the use of mobile phone service
networks. We developed a security testing tool that used the
simulated infrastructure to identify a number of vulnerabil-
ities in a commonly used implementation of an MMS User
Agent. One of the vulnerabilities was exploited to create the
ﬁrst remote code injection attack that uses MMS messages
as the delivery vector.
Future work will focus on the analysis of other User
Agent implementations. Devices that support MMS trans-
fer using wireless LAN can be easily tested using a setup
like the one we presented in this paper. For testing devices
that do not support a setup like ours, additional ways have to
be found for delivering MMS messages to devices without
using the infrastructure of a service provider.
Acknowledgments
This research was supported by the Army Research Of-
ﬁce, under agreement DAAD19-01-1-0484, and by the Na-
tional Science Foundation, under grants CCR-0238492 and
CCR-0524853.
References
[1] Apache Software Foundation.
Apache HTTP Server.
http://httpd.apache.org.
[2] ArcSoft. MMS Composer. http://www.arcsoft.
com, 2002.
[3] B. Jurry XFocus Team. Siemens Mobile SMS Exceptional
Character Vulnerability. http://www.xfocus.org/
advisories/200201/2.html, January 2002.
[4] D. Aitel Immunity Inc. SPIKE The Advantages of Block-
Based Protocol Analysis for Security Testing. http://
immunity.com, 2003.
[5] F-Secure.
F-Secure Virus Descriptions : Commwar-
http://www.f-secure.com/v-descs/
rior.A.
commwarrior.shtml, 2005.
[6] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter,
P. Leach, and T. Berners-Lee. Hypertext transfer protocol –
HTTP/1.1, 1999.
[7] i-mate.
i-mate PDA2k.
http://imate.com/
t-DETAILSP DA2K.aspx.
[8] J. de Haas. Mobile Security: SMS and a little WAP. http:
//www.itsx.com/hal2001/hal2001-itsx.ppt,
August 2001.
[9] M. Laakso, M. Varpiola. Vulnerabilities Go Mobile. May
2002.
[10] O. Whitehouse @stack Inc.
FuzzServer.
http://
www.blackops.cn/tools/FuzzerServer.zip,
January 2002.
[11] O. Whitehouse @stack Inc.
Nokia Phones Vulnera-
ble to DoS Attacks. http://www.infoworld.com/
article/03/02/26/HNnokiados 1.html, Febru-
ary 2003.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:30:50 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006