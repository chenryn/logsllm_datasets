6.1
8.1.0.29
7.69.80.9
10.2
15.05
0.9.40.0
18.0.1025
4.7
11
6.2.5
5.2
1.1.11
5.10.0.116
6.1












































Dyn
Code
present?






















Table 1: List of applications that were tested for
false positives on Windows OS. “.reloc present?”
column indicates if relocation table was present, and
“Fiber present?” indicates if the application had user
level threads or Fibers.
Guest OS Qemu
PVE only
WinXPSP3
Win7SP1
48s
1m 57s
1m 5s
2m 36s
PVE +
CFIC
1m 27s
3m 26s
PVE +
CFIC +
WL Cache
1m 15s
3m 12s
Table 3: Times taken to boot Windows 7 and XP
till the login screeen is reached. PVE only repre-
sents the time taken with only the PVE compo-
nent enabled. Similarly, PVE +CFIC and PVE
+CFIC+WL Cache correspond to both components
enabled and both components enabled with whitelist
caching respectively.
parse the binary to scan for target address generation pat-
terns. For example, Wartell et al. [34] scan the binary to
identify call instructions and perform simple data-ﬂow anal-
ysis to identify instructions that use the generated address
in an arithmetic computation.
5. EVALUATION
Total-CFI was implemented as a plugin for DECAF [1,
37], which is a modiﬁcation of Qemu [6] version 1.0.1, a
full system emulator. DECAF modiﬁes dynamic transla-
tion code of Qemu to incorporate opcode speciﬁc callbacks
into the translation blocks. It also modiﬁes the TLB cache
manipulation code to dispatch a callback whenever an en-
try is made to the TLB cache. In all, Total-CFI consists of
3.8K lines of C code. In this section, we present the evalu-
ation of Total-CFI. All the experiments were performed on
a system with Intel core i7, 2.93GHz Quad core processor
and 8GB of RAM, running Ubuntu 10.04 with Linux kernel
318CVE
Application
(Version)
Attack Technique
Exploit EIP Target EIP
CVE-2010-0249
CVE-2010-3962
CVE-2011-0073
Internet Explorer (6.0)
Internet Explorer (6.0)
FireFox 3.5.0
Uninitialized memory. Heap spray
Incorrect variable initialization. Heap spray
Dangling pointer abuse
CVE-2011-0257
QuickTime 7.6
CVE-2006-1016
CVE-2009-3672
CVE-2006-1359
∗
CVE-2010-4398
Internet Explorer (6.0)
Internet Explorer (6.0)
Internet Explorer (6.0)
Windows 7 kernel
Buﬀer overﬂow
Stack Overﬂow
Incorrect variable initialization. Heap-spray
Incorrect variable initialization. Heap-spray
Improper driver interaction. Buﬀer overﬂow
0x7dc98c85
0x71a51440
0x00346e54
0x0c0d0c0d
0x71a52c66
0x01730ee5
0x0044888d
0x00194ab0
0x773f67a8
0x74913ﬀ2
0x7c8097f3
0x95dca042
0x0c112402
0x0013e0d4
0x77c3210d
0xb8cb8694
Vulnerable
Module
mshtml.dll
mswsock.dll
js3250.dll
QuickTime-
Player.exe
ws2 32.dll
mshtml.dll
mshtml.dll
win32k.sys
Table 2: Summary of Exploits. Exploit EIP indicates the EIP address where the indirect control transfer was
reported. Target EIP corresponds to the branch address and the vulnerable module is the module containing
the EIP.
is a kernel exploit
∗
System
state
# ﬁles in
Total Size
cache
(B)
Avg. size
per ﬁle
(KB)
6.405
7.237
1725024
2853392
Login screen
Desktop
UI visible
Boot
completed
3 programs
running
5 programs
running
263
385
454
504
645
3496120
7.52
3900312
5672224
7.557
8.588
# ﬁles
without
.reloc
0
7
9
9
13
Table 4: Memory Overhead for whitelist cache with
respect to number of ﬁles in the cache at diﬀerent
system states on Windows 7. ”#ﬁles without .reloc”
refers to the number of ﬁles in the ﬁle cache that
did not have reloc section in the binary. For such
ﬁles, the binaries were parsed to extract statically
determinable addresses.
2.6.32-44-generic-pae. We evaluate Total-CFI on two factors
- accuracy and performance.
False-Positive evaluation. To measure its accuracy, we
tested benign applications and exploits on Total-CFI to check
for false positives and false negatives. We ran Total-CFI on
25 common applications that are listed in Table 1, on Win-
dows XP and Windows 7. We observed that several pre-
loaded application executables in Windows do not contain
relocation table in them. For such executables, we parsed
the PE ﬁle and extracted statically determinable addresses
into the whitelist. 0 exploits were reported in all 25 appli-
cations.
False-Negative evaluation. To check the eﬀectiveness of
Total-CFI on detecting exploits, we ran Total-CFI on 7 re-
cent real-world exploits that have exploits available in the
MetaSploit framework, and one Windows 7 kernel exploit.
All the exploits were detected. The summary of exploits
and their detection are listed in Table 2.
It is worth noting
that the kernel exploit, CVE-2010-4398, which starts as a
user mode program, exploits a vulnerability in Win32k.sys
and eventually escalates privilege. A crafted REG BINARY
value for SystemDefaultEUDCFont registry key is inserted to
cause a stack-based buﬀer overﬂow in the RtlQueryRegistry-
Values function in Win32k.sys. Monitoring a user program
(or a set of user programs) alone is insuﬃcient in identifying
such an attack. It is essential to monitor both the kernel
Figure 4: Percentage overhead of Total-CFI with re-
spect to Qemu 1.0.1 for Pass Mark CPU and Mem-
ory benchmark on Windows 7 SP1.
code and the user level code to diagnose such attacks. De-
tailed results are tabulated in Table 2.
Performance evaluation. We capture the performance
overhead introduced by Total-CFI under two categories. (1)
Execution overhead and (2) Memory overhead. We con-
ducted experiments to measure the boot time execution over-
head introduced by Total-CFI on Windows 7 and XP. The
results are listed in Table 3. We consider boot time exe-
cution overhead under performance evaluation because va-
riety of activities occur during the system boot that span
across system level, user level and IO. Moreover, most mod-
ule loads happen during the system boot. Therefore, the
boot process is perhaps the worst case scenario with respect
to performance overhead imposed by Total-CFI. Optionally,
Total-CFI can be turned on after the boot process and it
can monitor the execution of all the newly created processes
from that point forward.
In Table 3, Total-CFI is conﬁgured in 3 modes. PVE only
mode performed no CFI enforcement, but generated the pro-
cess, module and thread related information from the guest.
Whereas PVE +CFIC is the setup with both PVE and CFI
components turned on and lastly, PVE +CFIC+WL Cache
corresponds to the conﬁguration with whitelist cache con-
319taining all the binaries loaded during the boot process. With
whitelist caching enabled, the overhead on Windows XP and
7 were found to be 56.2% and 64.1% respectively. Keeping
integration with hardware in mind, we also captured the
memory overhead introduced by Total-CFI to maintain the
shadow whitelist during the boot process on Windows 7.
The memory overhead indicates the amount of memory
required to store the whitelists. The results are tabulated
in Table 4. We found the average overhead per ﬁle to be
7.46KB. We observed that the whitelist for ﬁles without .re-
loc section tend to be larger in size since Total-CFI takes
a conservative approach to extract all the statically deter-
minable addresses from the binary. Furthermore, from our
experiments, we found that even with large number of pro-
grams in the memory (such as Microsoft Oﬃce applications,
Adobe ﬂash, IE, Google Chrome and so on), no more than
1000 ﬁles were present in the whitelist cache. At the rate of
7.46KB per ﬁle, one would need to set aside approximately
8MB in the hardware for the whitelists, which is conceiv-
able. In combination with a carefully designed cache ﬂush
policy to accommodate for even larger number of ﬁles in the
memory, we believe that integrating whitelist management
into the hardware is not far fetched.
Furthermore, we ran the Pass Mark4 CPU and Memory
benchmark on Total-CFI. The results are shown in Figure 4.
The CPU benchmark on Total-CFI showed an average over-
head of 4.4% over Qemu and the memory benchmark showed
an average overhead of 19.8%.
6. DISCUSSION AND FUTURE WORK
6.1 Security Analysis
Evading Total-CFI. In this paper, we address the attacks
that arise due to control ﬂow violations. Most attacks in the
wild are control hijacking attacks, where attacker executes
malicious payload by diverting control ﬂow. However, there
exist data only attacks [12] that do not hijack control ﬂow
(e.g., bad system conﬁguration resulting in unintended priv-
ilege escalation). Such attacks are out of our scope. That
said, works in the past [9, 15, 8] have focussed on addressing
data integrity concerns. There also exist techniques based