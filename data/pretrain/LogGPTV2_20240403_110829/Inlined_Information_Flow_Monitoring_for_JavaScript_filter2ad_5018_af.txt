useful applications and policies.
Li et al implement Mash-IF [34], an add-on for Firefox
that uses a combination of a static data-ﬂow analysis of
a subset of JS and run-time reference monitoring of calls
to DOM API to enforce information-ﬂow policies in web
mashups. This approach is less coarse-grained than BFlow,
but implicit ﬂows are not accounted for, and no soundness
or security argument is made. The authors have reported
that among the 10 client mashups studied, they have found
no false positives and no false negatives. Policies in Mash-IF
are speciﬁed by the user, utilizing a graphical interface to
designate sensitivity of form elements.
Chugh et al [18] implement a hybrid monitor for JS IF
tracking. To deal with dynamic code evaluation, they de-
vise a constraint-based static analysis that applies to code
with “holes” representing code that will only be determined
at run time. The idea is to generate constraints on that
code, to be checked at runtime before applying eval. The
static analysis is based on a transformation that introduces
taint-tracking instrumentation that is analyzed but not ex-
ecuted. Their staged IF veriﬁer achieves a relatively low
false positive rate of 33% in experiments on the Alexa top
100 sites, for simple but useful policies (cookies are secret,
address bar is untainted, relative to the hole in which third-
party code is plugged). Some important JS features are not
supported (call, apply, with).
Sandboxing and object capability transformations are sim-
ilar, though less intricate, to those of our inliner. For exam-
ple, it transforms reads and writes into function calls to a
run-time system as well. Performance has been reported
for Caja (http://code.google.com/p/google-caja/wiki/
Performance). In the Valija mode, which is aimed at sup-
porting legacy ES3 code (i.e., a subset of thereof), it features
slowdowns of 5× to 163×.
6. DISCUSSION
Despite decades of research on IFC, and a spate of recent
work that speciﬁcally targets JS, no deﬁnitive solution has
emerged. It may be that carefully engineered taint tracking
will turn out to be a good compromise for general use, but
there will continue to be scenarios where the assurance of
strong IFC is worth its cost.
In this paper we report on
progress in evaluating two ideas that seem among the most
promising approaches to IFC for client-side JS, namely in-
lining and the no-sensitive-update rule.
In this paper we
focus on ECMAScript 5 and parts of the Web API needed
for interesting mashups and policies.
Our current prototype has too high performance overhead
for many usage scenarios. However, compared with other ap-
proaches like interpreter modiﬁcation [11, 33], custom meta-
circular interpreters[28] or SME [26], inlined monitoring has
promising paths for improving performance, notably sparse
inlining and extended JIT support. Sparse inlining has been
hinted at in previous work [17] and aims at reducing the
amount of program instrumentation based on a static IF
analysis performed ahead of inlining. The observation is
that well-engineered JS programs feature substantial code
fragments for which ﬂows of information can be inferred
statically. Those fragments can then remain unchanged and
the rest of the program is instrumented accounting for the
inferred ﬂows. This diﬀers from sparse labeling: in addition
to allowing unlabeled values at run-time, it disables their
monitoring as well. The boxing invariant still holds: the
monitor core is only called from instrumented parts of code
which operate on labeled/boxed values only.
In our experiments, the monitor core and API facades
beneﬁt from eﬃcient JIT compilation, but the instrumented
program itself does not. One of the likely culprits is the
abundance of function calls that the program makes to the
core. Many of these functions are small, pure and amenable
641optimization. However, it appears that the calls themselves
are not optimized — especially in the recursive case. We
believe it could be possible to extend the JITs with eﬃ-
cient support for the functional programming styles. There
are precedents: asm.js and other fast JS subsets now have
specialized compilers in many browsers. This could have
a better chance of becoming a part of the mainstream en-
gines due to the limited scope of the changes (as opposed to
information-ﬂow tracking modiﬁcations) and potential im-
pact beyond that of our monitor. For example, it will likely
beneﬁt functional languages that have JS backends: Clojure,
Haskell, Elm and others.
We build on prior works that include correctness proofs
for their designs. We do not present proofs of soundness
or transparency for our implementation, due to the com-
plexity of the language and API’s we are supporting. Such
eﬀort would be on the scale of a compiler veriﬁcation and
will be better motivated once IFC technology matures in
terms of applicability and performance. However, we be-
lieve the modular structure of the inliner as well as prior
work opens up interesting possibilities to simplify assurance.
The rewriting rules are quite simple and the properties of
the transformed program rely on those of the RTS functions
as well as the isolation, conﬁnement and mediation proper-
ties of API facades. One might formalize transparency and
noninterference for the instrumented program in the mech-
anized framework of [13] and using the mechanized DOM
formalization of [47]. To prove isolation properties of the
transformed code one might leverage the existing work on
verifying secure subsets of JavaScript [45]. The proof would
rely on precise speciﬁcations for the RTS, which would in-
clude bisimulation-style properties for both noninterference
and transparency; these could either be veriﬁed or tested.
What we really want to do is investigate NSU by experi-
ments on sizeable existing web sites. This requires substan-
tial additional work, to (a) implement API facades for var-
ious libraries encountered, (b) devise eﬀective means of ex-
perimentation under realistic workloads, (c) develop precise
policies for these applications, and (d) automate checking of
transparency, soundness, and permissiveness.
7. ACKNOWLEDGMENTS
This work was partially supported by NSF award CNS-
1228930 and by Department of Homeland Security under
contract 11027-202037-DS to HRL Laboratories.
8. REFERENCES
[1] D. Akhawe, A. Barth, P. E. Lam, J. Mitchell, and
D. Song. Towards a formal foundation of web security.
In IEEE CSF, 2010.
[2] A. Almeida-Matos, J. Fragoso Santos, and T. Rezk. A
secure information ﬂow monitor for a core of DOM. In
TGC, 2014.
[3] A. Askarov and A. Sabelfeld. Tight enforcement of
information-release policies for dynamic languages. In
IEEE CSF, 2009.
[4] T. H. Austin and C. Flanagan. Eﬃcient purely
dynamic information ﬂow analysis. In ACM PLAS,
2009.
[5] T. H. Austin and C. Flanagan. Permissive dynamic
information ﬂow analysis. In ACM PLAS, 2010.
[6] T. H. Austin and C. Flanagan. Multiple facets for
dynamic information ﬂow. In ACM POPL, 2012.
[7] A. Banerjee, D. A. Naumann, and S. Rosenberg.
Expressive declassiﬁcation policies and modular static
enforcement. In IEEE Symp. Sec. & Priv., 2008.
[8] G. Barthe, D. Pichardie, and T. Rezk. A certiﬁed
lightweight non-interference java bytecode veriﬁer. In
ESOP, 2007.
[9] L. Bauer, S. Cai, L. Jia, T. Passaro, M. Stroucken,
and Y. Tian. Run-time monitoring and formal analysis
of information ﬂows in Chromium. In NDSS, 2015.
[10] A. Bichhawat, V. Rajani, D. Garg, and C. Hammer.
Generalizing permissive-upgrade in dynamic
information ﬂow analysis. In ACM PLAS, 2014.
[11] A. Bichhawat, V. Rajani, D. Garg, and C. Hammer.
Information ﬂow control in WebKit’s JavaScript
bytecode. In Prin. of Sec. and Trust (POST), 2014.
[12] A. Birgisson, D. Hedin, and A. Sabelfeld. Boosting the
permissiveness of dynamic information-ﬂow tracking
by testing. In ESORICS, 2012.
[13] M. Bodin et al. A trusted mechanised JavaSript
speciﬁcation. In ACM POPL, 2014.
[14] A. Chudnov. Inlined Information Flow Monitoring for
Web Applications in JavaScript. PhD thesis, Stevens
Institute of Technology, 2015.
[15] A. Chudnov. JEST. http://chudnov.com/jest, 2015.
[16] A. Chudnov, G. Kuan, and D. A. Naumann.
Information ﬂow monitoring as abstract interpretation
for relational logic. In IEEE CSF, 2014.
[17] A. Chudnov and D. A. Naumann. Information ﬂow
monitor inlining. In IEEE CSF, 2010.
[18] R. Chugh, J. A. Meister, R. Jhala, and S. Lerner.
Staged information ﬂow for JavaScript. In PLDI, 2009.
[19] M. R. Clarkson and F. B. Schneider. Hyperproperties.
Journal of Computer Security, 18(6), 2010.
[20] D. Devriese and F. Piessens. Noninterference through
secure multi-execution. In IEEE Symp. Sec. & Priv.,
2010.
[21] M. Dhawan and V. Ganapathy. Analyzing information
ﬂow in JavaScript-based browser extensions. In
ACSAC, 2009.
[22] C. Fournet, N. Swamy, J. Chen, P.-´E. Dagand, P.-Y.
Strub, and B. Livshits. Fully abstract compilation to
JavaScript. In ACM POPL, 2013.
[23] A. Gal et al. Trace-based just-in-time type
specialization for dynamic languages. In ACM PLAS,
2009.
[24] P. Gardner, S. Maﬀeis, and G. D. Smith. Towards a
program logic for JavaScript. In ACM POPL, 2012.
[25] D. B. Giﬃn, A. Levy, D. Stefan, D. Terei, D. Mazi`eres,
J. Mitchell, and A. Russo. Hails: Protecting data
privacy in untrusted web applications. In SOSP, 2012.
[26] W. D. Groef, D. Devriese, N. Nikiforakis, and
F. Piessens. FlowFox: a web browser with ﬂexible and
precise information ﬂow control. In ACM CCS, 2012.
[27] D. Hedin, L. Bello, and A. Sabelfeld. Value-sensitive
hybrid information ﬂow control for a JavaScript-like
language. In IEEE CSF, 2015.
[28] D. Hedin, A. Birgisson, L. Bello, and A. Sabelfeld.
JSFlow: tracking information ﬂow in JavaScript and
its APIs. In ACM SAC, 2014.
642[29] D. Hedin and A. Sabelfeld. Information-ﬂow security
for a core of JavaScript. In IEEE CSF, 2012.
[30] U. H¨olzle, C. Chambers, and D. Ungar. Optimizing
dynamically-typed object-oriented languages with
polymorphic inline caches. In ECOOP, 1991.
[31] C. Hri¸tcu, M. Greenberg, B. Karel, B. C. Pierce, and
G. Morrisett. All your IFCException are belong to us.
In IEEE Symp. Sec. & Priv., 2013.
[32] D. Jang, R. Jhala, S. Lerner, and H. Shacham. An
empirical study of privacy-violating information ﬂows
in JavaScript web applications. In ACM CCS, 2010.
[33] S. Just, A. Cleary, B. Shirley, and C. Hammer.
Information ﬂow analysis for JavaScript. In PLASTIC,
2011.
[34] Z. Li, K. Zhang, and X. Wang. Mash-if: Practical
information-ﬂow control within client-side mashups. In
DSN, 2010.
[35] S. Maﬀeis, J. C. Mitchell, and A. Taly. Object
capabilities and isolation of untrusted web
applications. In IEEE Symp. Sec. & Priv., 2010.
[47] V. Rajani, A. Bichhawat, D. Garg, and C. Hammer.
Information ﬂow control for event handling and the
DOM in web browsers. In IEEE CSF, 2015.
[48] P. Ratanaworabhan, B. Livshits, and B. Zorn.
JSMeter: Comparing the behavior of JavaScript
benchmarks with real Web applications. In USENIX
WebApps, 2010.
[49] G. Richards, A. Gal, B. Eich, and J. Vitek.
Automated construction of JavaScript benchmarks. In
OOPSLA, 2011.
[50] G. Richards, C. Hammer, B. Burg, and J. Vitek. The
eval that men do - a large-scale study of the use of
eval in JavaScript applications. In ECOOP, 2011.
[51] A. Russo and A. Sabelfeld. Dynamic vs. static
ﬂow-sensitive security analysis. In IEEE CSF, 2010.
[52] A. Russo, A. Sabelfeld, and A. Chudnov. Tracking
information ﬂow in dynamic tree structures. In
ESORICS, 2009.
[53] A. Sabelfeld and D. Sands. Dimensions and principles
of declassiﬁcation. J. Computer Security, 17(5), 2009.
[36] J. Magazinius, D. Hedin, and A. Sabelfeld.
[54] J. Santos and T. Rezk. An information ﬂow
Architectures for inlining security monitors in web
applications. In ESSoS, 2014.
[37] J. Magazinius, P. H. Phung, and D. Sands. Safe
wrappers and sane policies for self protecting
javascript. In NordSec, 2010.
[38] J. Magazinius, A. Russo, and A. Sabelfeld. On-the-ﬂy
inlining of dynamic security monitors. In SEC, 2010.
[39] P. Marchenko, U. Erlingsson, and B. Karp. Keeping
sensitive data in browsers safe with ScriptPolice. Univ.
College London report RN/13/20, also HCSS’13.
[40] S. Moore and S. Chong. Static analysis for eﬃcient
hybrid information-ﬂow control. In IEEE CSF, 2011.
[41] A. C. Myers, A. Sabelfeld, and S. Zdancewic.
Enforcing robust declassiﬁcation and qualiﬁed
robustness. J. of Computer Security, 14(2), 2006.
[42] P. H. Phung, D. Sands, and A. Chudnov. Lightweight
self-protecting JavaScript. In ASIACCS, 2009.
[43] K. Pingali and G. Bilardi. Optimal control dependence
computation and the roman chariots problem. ACM
TOPLAS, 1997.
[44] M. Pistoia, A. Banerjee, and D. A. Naumann. Beyond
stack inspection: A uniﬁed access-control and
information-ﬂow security model. In IEEE Symp. Sec.
& Priv., 2007.
[45] J. G. Politz, S. A. Eliopoulos, A. Guha, and
S. Krishnamurthi. ADsafety: Type-based veriﬁcation
of JavaScript sandboxing. In USENIX Security, 2011.
[46] W. Rafnsson and A. Sabelfeld. Secure multi-execution:
Fine-grained, declassiﬁcation-aware, and transparent.
In IEEE CSF, 2013.
monitor-inlining compiler for securing a core of
JavaScript. In ICT Systems Security and Privacy
Protection, volume 428 of Advances in Information
and Communication Technology. IFIP, 2014.
[55] D. Stefan, E. Z. Yang, P. Marchenko, A. Russo,
D. Herman, B. Karp, and D. Mazi`eres. Protecting
users by conﬁning JavaScript with COWL. In OSDI,
2014.
[56] L. Stegeman, H. Mackenzie, et al. GHCJS: a Haskell
to JavaScript compiler.
https://github.com/ghcjs/ghcjs. Accessed August
2015.
[57] P. Thiemann. Towards specializing JavaScript
programs. In PSI, volume 8974 of LNCS, 2014.
[58] J. A. Vaughan and S. Chong. Inference of expressive
declassiﬁcation policies. In IEEE Symp. Sec. & Priv.,
2011.
[59] P. Vogt, F. Nentwich, N. Jovanovic, E. Kirda,
C. Kr¨ugel, and G. Vigna. Cross site scripting
prevention with dynamic data tainting and static
analysis. In NDSS, 2007.
[60] D. M. Volpano, C. E. Irvine, and G. Smith. A sound
type system for secure ﬂow analysis. Journal of
Computer Security, 4(2/3), 1996.
[61] A. Yip, N. Narula, M. N. Krohn, and R. Morris.
Privacy-preserving browser-side scripting with BFlow.
In EuroSys, 2009.
[62] S. A. Zdancewic. Programming languages for
information security. PhD Diss., Cornell Univ., 2002.
643