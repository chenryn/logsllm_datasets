S avk *BBGIN ( for (x = 0;x= 2) ? n : 2
for [k = 2: (m > 1) &4 (k2  0)
nMord8++
命令管道在awk里可以发挥强大的功能。管道可以在字符字符串中标明，也可以包含任
意的Shell命令。这里是与getline搭配使用，如下：
“Gate* 1 get1ine now
close (*date*)
print *the current time is*, now
大部分系统会限制打开文件的个数，所以当使用管道通过时，我们通过c1ose（）函数
关闭管道文件。在旧式awk实现里，close为语句，所以没有可移植的方式，可以像
使用函数一样使用它，并取得可靠的返回代码。
接下来说明的是：如何在循环里使用命令管道：
ssou/sa/ st u- peou. = puemoo
whlie ((command 1  get1ine 9) > 0)
close (ccmmand)
print s
我们使用变量保存管道，以避免重复复杂字符申，并确保所有使用的命令都确实匹配。
www.TopSage.com
---
## Page 276
264
第9章
在命令字符串里，每个字符都是有意义的，即使是不被注意的单一空格差异，也会引用
到不同的命令。
9.7.7输出重定向
print与printf语句（见9.9.8节）多半是将其输出传送到标准输出。不过，你也可以
改成传送到文件：
print *Hello, wor1d* > file
printf(*Tbe tenth power of $d is d\n*, 2, 2^10) > */dev/tty*
为了附加到已存在的文件（或是该文件不存在时，则建立一个新的）中，可使用>>输
出重定向：
print *Hello, world* >> file
你可以在多个输出语句上，将它们的输出全部重定向到相同的文件，当完成写人输出后，
请使用close（file）关闭文件，释放它使用的资源。
请避免在没有适当插入close（）的情况下，混用>与>>传到相同文件。在awk里，这
些运算符告知输出文件应该如何打开使用。一且打开后，文件便会一直保持在打开状态，
直到你明确指出要关闭它或直到程序终结，相比之下，Shell的重定向是要求每个命令打
开文件并美闭它。
或者，你也可以将输出传送到管道：
for (name in telephone)
(,110)040
print name *\t" telephone[name] I*sort*
由于输人是来自管道，因此关闭输出管道的操作是在完成时立即执行。如果你需要在相
同程序中读取输出时，这点格外重要。例如，你可以指示输出到临时性文件，然后在完
成之后再读取它：
tmpfile - */tmp/telephone.tmp*
coemand = *sort > * tmpfi1e
for (name in telephone)
print nane *\t* telephone[nane] I command
(0a[o0))Tq8
close (command)
clo8e(tmpEi1e)
11T.2d
在awk里的管道，使得整个UNIX工具集可以任我们支配，避免对其他程序语言中提供
大量函数库的需求，也有助于让语言保持在小规模状态。例如，awk不提供排序的内建
函数，因为它只要复制功能强大的sort命令的功能即可，详见4.1节。
www.TopSage.com
---
## Page 277
awk的惊人表现
近期的awk实现，除了POSIX外，都提供将缓冲区数据导到输出流的函数：COIm
fflush（file）。留意一开始的两个ff（指的是fileflush）.它会在成功时返回0，失败
时返网-1，调用fflush（）（省略参数）与fflush（""）（参数为空的字符申）的行为
模式视执行期而定，换句话说：请避免在可移植性很重要的程序里使用它。
9.7.8执行外部程序
我们已在之前提到过，getline语句以及在awk管道里的输出重定向都可与外部程序通
信。system（command)函数提供的是第三种方式：其返回值为命令的退出状态码。首
先，它会先清除所有缓冲区输出，然后开始一个/bin/sh实例并将命令送给它。Shell
的标准错误输出和标准输出与awk程序的相同，所以除非命令的I/O被重定向，否则来
自awk程序和Shell命令两者的输出，都会以预期的顺序出现。
这里是解决电话名录排序问题较短的程序方案，使用临时性文件与system（），而非awk
管道：
for (name in telephone)
print name *\t* telephone[name]> tmpfile
[d ,> 1xos,)ss
close (tnpfile)
临时性文件必须在调用system（）之前关闭，以确保任何缓冲区输出都正确地记录在文
件内。
对于披system（）执行的命令并不需要调用close（），因为close（）仅针对以I/O重定
向运算符所打开的文件或管道，还有getline.print或printf。
system（）函数提供了简单删除脚本临时性文件的方式：
d.-
传递给system（）的命令可包含数行：
system(*cat <<BOFILE\nuno^ndos\ntres\nEOPILE*)
它产生的输出和从嵌人文件复制到标准输出一样：
uno
dos
tres
由于每次调用system（）都会起始一个全新的Shell，因此没有简单的方式可以在分开的
system（）调用内的命令之间传递数据，除非通过中间文件。下面有个简单解决方案，将
输出管道传送到Shell，以送出多个命令：
www.TopSage.com