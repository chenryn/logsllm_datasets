i c a t
Bad . dsk 56−128−3
5.3
NTFS Image Causes icat to Crash
icat crashes while processing a ﬁle on a corrupted NTFS ﬁlesystem image.
The crash occurs when
dereferencing fs data run at line 1570 of ntfs.c:
1543
/∗
c y c l e
through
the
number
of
runs
we have
∗/
1544
while
( f s d a t a r u n )
{
1545
1546
/∗ We may
get
a FILLER
entry
at
the
beginning
of
the
run
1547
∗
i f
we
are
p r o c e s s i n g
a non−base
f i l e
record
because
1548
∗
t h i s
\$DATA a t t r i b u t e
could
not
be
the
f i r s t
in
the
b i g g e r
1549
∗
a t t r i b u t e .
Therefore ,
do
not
e r r o r
i f
i t
s t a r t s
at
0
1550
∗/
1551
i f
( f s d a t a r u n −>f l a g s & FS DATA FILLER)
{
[ . . .
code
e l i d e d
. . . ]
1564
}
1565
e l s e
{
1566
f s d a t a r u n = f s d a t a r u n −>next ;
1567
}
1568
}
1569
1570
addr = f s d a t a r u n −>addr ;
The check at line 1544 ensures that fs data run is non-NULL, however line 1566 updates the variable
without returning to the check (with a continue) or performing the check again. This leads to a NULL
dereference at line 1570.
http://www.isecpartners.com
6/12
5.3.1
Reproduction
$
patch . py
NtfsPart . dsk Bad . dsk
7567157 AA
$
i c a t
Bad . dsk 8−128−1
5.4
NTFS Image Causes ﬂs to Crash (1)
fls crashes while listing ﬁles from a corrupted image. The crash occurs when copying data in fs data put str.
The calling code is in ntfs.c:
1778
/∗ Add
t h i s
r e s i d e n t
stream
to
the
f s i n o d e −>a t t r
l i s t
∗/
1779
f s i n o d e −>a t t r =
1780
f s d a t a p u t s t r ( f s i n o d e −>attr ,
name ,
type ,
1781
getu16 ( fs −>endian ,
attr −>id ) ,
1782
( void
∗)
( ( u i n t p t r t )
a t t r +
1783
getu16 ( fs −>endian ,
1784
attr −>c . r . s o f f ) ) ,
getu32 ( fs −>endian ,
1785
attr −>c . r . s s i z e ) ) ;
The read buﬀer is attr plus an arbitrary 16-bit oﬀset and the read length is an arbitrary 32-bit length.
No bounds checking is performed to ensure that the buﬀer contains as many bytes as are requested.
5.4.1
Reproduction
$
patch . py
NtfsPart . dsk Bad . dsk
7652939
\x01
$
f l s −r l p
Bad . dsk
5.5
NTFS Image Causes ﬂs to Crash (2)
fls crashes while listing ﬁles from a corrupted image. The crash occurs at line 208 of ntfs dent.c while
dereferencing idxe:
205
/∗
perform
some
s a n i t y
checks
on
index
b u f f e r
head
206
∗ and
advance
by 4−bytes
i f
i n v a l i d
207
∗/
208
i f
( ( getu48 ( fs −>endian ,
idxe−>f i l e
r e f ) > fs −>last inum )
| |
209
( getu48 ( fs −>endian ,
idxe−>f i l e
r e f ) f i r s t i n u m )
| |
210
( getu16 ( fs −>endian ,
idxe−>i d x l e n ) endian ,
211
idxe−>s t r l e n ) )
212
| |
( getu16 ( fs −>endian ,
idxe−>i d x l e n ) % 4)
213
| |
( getu16 ( fs −>endian ,
idxe−>i d x l e n ) >
s i z e ) )
{
214
idxe = ( n t f s i d x e n t r y
∗)
( ( u i n t p t r t )
idxe + 4) ;
215
continue ;
216
}
This code is executed in a loop while walking a table and advancing idxe. The variable is initially in
range, but is eventually moved out of range because the caller passes in a large size (line 735) which is an
arbitrary 32-bit integer taken from the ﬁlesystem image. No bounds checking is performed to ensure that
the value is in range.
734
r e t v a l = n t f s d e n t i d x e n t r y ( ntfs ,
dinfo ,
l i s t s e e n ,
idxe ,
735
getu32 ( fs −>endian ,
736
i d x e l i s t −>b u f o f f ) −
737
getu32 ( fs −>endian ,
i d x e l i s t −>b e g i n o f f ) ,
738
getu32 ( fs −>endian ,
739
i d x e l i s t −>e n d o f f ) −
740
getu32 ( fs −>endian ,
i d x e l i s t −>b e g i n o f f ) ,
f l a g s ,
action ,
ptr ) ;
http://www.isecpartners.com
7/12
5.5.1
Reproduction
$
patch . py
NtfsPart . dsk Bad . dsk
7653298
d
$
f l s −r l p
Bad . dsk
5.6
NTFS Image Causes fsstat to Crash
fstat crashes while processing a corrupted ﬁlesystem image. The crash happens when dereferencing sid
in line 2714 of ntfs.c:
2703
unsigned
i n t
o w n e r o f f s e t =
2704
getu32 ( fs −>endian ,
sds−>s e l f
r e l
s e c
d e s c . owner ) ;
2705
n t f s
s i d
∗ s i d =
2706
( n t f s
s i d
∗)
( ( u i n t 8 t
∗) & sds−>s e l f
r e l
s e c
d e s c
+
o w n e r o f f s e t ) ;
2707