have
matching
cid , oﬀer C, mode S, pk C, pk S, psk , kc, ks, psk
authenticated
sent
the
session
(with
same
same
peer,
then
the
(cid:2)
).
the
Unique Channel Identiﬁer: If a client
Replay Prevention: Any application data m sent over a
session cid may be accepted at most once by the peer.
session and a
server session have the same identiﬁer cid, then all
other parameters in these sessions must match (same
cid , oﬀer C, mode S, pk C, pk S, psk , kc, ks, psk
).
(cid:2)
These security goals encompass most of the standard
security goals for secure channel protocols such as TLS. For
example, secrecy for application data implicitly requires that
the authenticated key exchange must generate secret keys.
Authentication incorporates the requirement that the client
and server must have matching sessions, and in particular,
that they agree on each others’ identities as well as the
inputs and outputs of negotiation. Hence, it prohibits client
and server impersonation, and man-in-the-middle downgrade
attacks.
The requirement for a unique channel identiﬁer is a bit
more unusual, but it allows multiple TLS sessions to be
securely composed, for example via session resumption or
renegotiation, without exposing them to credential forward-
ing attacks like Triple Handshake [15]. The channel identi-
ﬁer could itself be a session key or a value generated from
it, but is more usually a public value that is derived from
session data contributed by both the client and server [17].
Symbolic vs. Computational Models. Before we can model
and verify TLS 1.3 against the security goals given above,
we need to specify our protocol execution model. There
are two different styles in which protocols have classically
been modeled, and in this paper, we employ both of them.
Symbolic models were developed by the security proto-
col veriﬁcation community for ease of automated analysis.
Cryptographers, on the other hand, prefer to use computa-
tional models and do their proofs by hand. A full comparison
between these styles is beyond the scope of this paper (see
e.g. [26]); here we brieﬂy outline their differences in terms
of the two tools we will use.
ProVerif [25], [27] analyzes symbolic protocol models,
whereas CryptoVerif [24] veriﬁes computational models.
485
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
The input languages of both tools are similar. For each
protocol role (e.g. client or server) we write a process that
can send and receive messages over public channels, trigger
security events, and store messages in persistent databases.
In ProVerif, messages are modeled as abstract terms. Pro-
cesses can generate new nonces and keys, which are treated
as atomic opaque terms that are fresh and unguessable.
Functions map terms to terms. For example, encryption
constructs a complex term from its arguments (key and
plaintext) that can only be deconstructed by decryption (with
the same key). The attacker is an arbitrary ProVerif process
running in parallel with the protocol, which can read and
write messages on public channels, and can manipulate them
symbolically.
In CryptoVerif, messages are concrete bitstrings. Freshly
generated nonces and keys are randomly sampled bitstrings
that the attacker can guess with some probability (depending
on their length). Encryption and decryption are functions on
bitstrings to which we may associate standard cryptographic
assumptions such as IND-CCA. The attacker is a probabilis-
tic polynomial-time CryptoVerif process running in parallel.
Authentication goals in both ProVerif and CryptoVerif are
written as correspondences between events: for example,
if the client triggers a certain event, then the server must
have triggered a matching event in the past. Secrecy is
treated differently in the two tools; in ProVerif, we typically
ask whether the attacker can compute a secret, whereas in
CryptoVerif, we ask whether it can distinguish a secret from
a random bitstring.
The analysis techniques employed by the two tools are
quite different. ProVerif searches for a protocol trace that
violates the security goal, whereas CryptoVerif tries to con-
struct a cryptographic proof that the protocol is equivalent
(with high probability) to a trivially secure protocol. ProVerif
is a push-button tool that may return that the security goal
is true in the symbolic model, or that the goal is false with a
counterexample, or that it is unable to conclude, or may fail
to terminate. CryptoVerif is semi-automated, it can search for
proofs but requires human guidance for non-trivial protocols.
We use both ProVerif and CryptoVerif for their comple-
mentary strengths. CryptoVerif can prove stronger security
properties of the protocol under precise cryptographic as-
sumptions, but the proofs require more work. ProVerif can
quickly analyze large protocols to automatically ﬁnd attacks,
but a positive result does not immediately provide a cryp-
tographic proof of security. Deriving sound cryptographic
proofs using symbolic analysis is still an open problem for
real-world protocols [34].
A Realistic Threat Model for TLS. We seek to analyze
TLS 1.3 for the above security goals against a rich threat
model that includes both classic protocol adversaries as well
as new ones that apply speciﬁcally to multi-mode protocols
like TLS. In particular, we model recent downgrade attacks
on TLS by allowing the use of weak cryptographic algo-
rithms in older versions of TLS. In our analyses, the attacker
can use any of the following attack vectors to disrupt the
protocol.
• Network Adversary: As usual, we assume that
the
attacker can intercept, modify, and send all messages sent
on public network channels.
• Compromised Principals: The attacker can compromise
any client or server principal P by asking for its long-
term secrets, such as its private key (sk P ) or pre-shared
key (psk). We do not restrict which principals can be
compromised, but whenever such a compromise occurs,
we mark it with a security event: Compromised(pk P) or
CompromisedPSK(psk ). If the compromise event occurs
after a session is complete, we issue a different security
event: PostSessionCompromise(cid, pk P).
• Weak Long-term Keys: If the client or server has a
weak key that the attacker may be able to break with
sufﬁcient computation, we treat such keys the same
way as compromised keys and we issue a more gen-
eral event:WeakOrCompromised(pk P). This conservative
model of weak keys is enough to uncover attacks like
FREAK [12] that rely on the use of 512-bit RSA keys by
TLS servers.
• RSA Decryption Oracles: TLS versions up to 1.2 use
RSA PKCS#1 v1.5 encryption, which is known to be vul-
nerable to a form of padding oracle attack on decryption
originally discovered by Bleichenbacher [28]. Although
countermeasures to this attack have been incorporated
into TLS, they remains hard to implement securely [59]
resulting in continued attacks such as DROWN [7].
Furthermore, such padding oracles can sometimes even
be converted to signature oracles for the corresponding
private key [47].
We assume that any TLS server (at any version) that
enables RSA decryption may potentially be vulnerable
to such attacks. We distinguish between two kinds of
RSA key exchange: RSA(StrongRSADecryption) and
RSA(WeakRSADecryption). In any session, if the server
chooses the latter, we provide the attacker with a decryp-
tion and signature oracle for that private key.
• Weak Difﬁe-Hellman Groups: To account for attacks
like Logjam [1], we allow servers to choose between
strong and weak Difﬁe-Hellman groups (or elliptic
curves), and mark the corresponding key exchange mode
as DHE(StrongDH) or DHE(WeakDH). We conservatively
assume that weak groups have size 1, so all Difﬁe-
Hellman exponentiations in these groups return the same
distinguished element BadElement.
Even strong Difﬁe-Hellman groups typically have small
subgroups that should be avoided. We model these sub-
groups by allowing a weak subgroup (of size 1) even
within a strong group. A malicious client or server may
choose BadElement as its public value, and then all
exponentiations with this element as the base will also
return BadElement. To avoid generating keys in this
subgroup, clients and servers must validate the received
public value.
• Weak Hash Functions: TLS uses hash functions for
key derivation, HMAC, and for signatures. Versions up
to TLS 1.2 use various combinations of MD5 and SHA-
1, both of which are considered weak today, leading to
exploitable attacks on TLS such as SLOTH [23].
486
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
We model both strong and weak hash functions, and the
client and server get to negotiate which function they will
use in signatures. Strong hash functions are treated as one-
way functions in our symbolic model, whereas weak hash
functions are treated as point functions that map all inputs
to a constant value: Collision. Hence, in our model, it is
trivial for the attacker to ﬁnd collisions as well as second
preimages for weak hash functions.
• Weak Authenticated Encryption: To model recent at-
tacks on RC4 [3], [71] and TripleDES [22], we allow
both weak and strong authenticated encryption schemes.
For data encrypted with a weak scheme, irrespective of the
key, we provide the adversary with a decryption oracle.
A number of attacks on the TLS Record protocol stem
from its use of a MAC-Encode-Encrypt construction for
CBC-mode ciphersuites. This construction is known to
be vulnerable to padding oracle attacks such as POO-
DLE [60] and Lucky13 [4], and countermeasures have
proved hard to implement correctly [2]. We model such
attacks using a leaky decryption function. Whenever a
client or server decrypts a message with this function, the
function returns the right result but also leaks the plaintext
to the adversary.
The series of threats described above comprise our con-
servative threat model for TLS 1.3, and incorporates entire
classes of attacks that have been shown to be effective
against older versions of the protocol,
including Triple
Handshake, POODLE, Lucky 13, RC4 NOMORE, FREAK,
Logjam, SLOTH, DROWN. In most cases, we assume
strictly stronger adversaries than have been demonstrated
in practice, but since attacks only get better over time,
our model seeks to be defensive against future attacks. It
is worth noting that, even though TLS 1.3 does not itself
support any weak ciphers, TLS 1.3 clients and servers will
need to support
legacy protocol versions for backwards
compatibility. Our model enables a ﬁne-grained analysis of
vulnerabilities: we can ask whether TLS 1.3 connections
between a client and a server are secure even if TLS 1.2
connections between them are broken.
Verifying TLS 1.2 in ProVerif. We encode our threat model
as a generic ProVerif crypto library that can be used with
any protocol. To evaluate this model, and in preparation for
our analysis of TLS 1.3, we symbolically analyze a model of
TLS 1.2 using ProVerif. Our model includes TLS 1.2 clients
and servers that support both RSA and Difﬁe-Hellman key
exchanges, and are willing to use both weak and strong
cryptography. We assume that clients are unauthenticated.
ClientFinished,
We write ProVerif processes for TLS 1.2 clients and
servers that exchange messages according to the protocol
standard, and issue a sequence of events–ClientOffers,
ServerChooses,
ServerFinished,
ClientSends, ServerReceives–indicating their progress
through the protocol. We then compose these processes with
our threat model and add queries for message authenticity
and secrecy. For example, a secrecy query may ask whether
the attacker can learn some application data message m sent
by the client over a TLS 1.2 session with identiﬁer cid.
When we run ProVerif for this query, it ﬁnds a counter-
example: the attacker can learn m if it can compromise
server’s private key (WeakOrCompromised(pkS)). To check
whether this is the only case in which m is leaked, we
reﬁne the secrecy query and run ProVerif again. ProVerif
again ﬁnds a counter-example:
the attacker can learn
the server chooses a weak Difﬁe-Hellman group
m if
(ServerChoosesKex(DHE(WeakDH))). In this way, we keep
reﬁning our queries until we obtain the strongest security
properties that hold for TLS 1.2 in our model:
• TLS 1.2 Secrecy: A message m sent by an honest client
in a session cid to a server S cannot be known to the
adversary unless one of the following conditions holds:
(1) the server’s public key is weak or compromised, or
(2) the session uses a weak Difﬁe-Hellman group, or
(3) the session uses weak authenticated encryption, or
(4) the server uses weak RSA decryption with the same
public key (in this or any other session), or
(5) the server uses a weak hash function for signing with
the same public key (in any session).
• TLS 1.2 Authenticity & Replay Protection: Every
message m accepted by an honest client in a session cid
with some server S corresponds to a unique message sent
by S on a matching session, unless one of the conditions
(1)-(5) above holds.
Both these queries are veriﬁed by ProVerif in a few
seconds. All the disjuncts (1)-(5) in these queries are nec-
essary, removing any of them results in a counterexample
discovered by ProVerif, corresponding to some well-known
attack on badly conﬁgured TLS 1.2 connections.
Interestingly, the conditions (2) and (3) are session spe-
ciﬁc, that is, only the sessions where these weak construc-
tions are used are affected. In contrast, (4) and (5) indicate
that the use of weak RSA decryption or a weak hash function
in any session affects all other sessions that use the same
server public key. As we shall see, this has an impact on the
security of TLS 1.3 when it is composed with TLS 1.2.
We can also verify our TLS 1.2 model for more advanced
properties. Forward secrecy does not hold in general for
TLS 1.2, but can be proved for DHE sessions that use strong
groups. Channel identiﬁers like cid = kc are not unique, and
ProVerif ﬁnds a variant of the Triple Handshake attack, un-
less we implement the recommended countermeasure [64].
Veriﬁcation Effort. The work of verifying TLS 1.2 can be
divided into three tasks. We ﬁrst modeled the threat model as
a 400 line ProVerif library, but this library can now be reused
for other protocols, including TLS 1.3. We then modeled the
TLS 1.2 protocol in about 200 lines of ProVerif. Finally, we
wrote about 50 lines of queries, both to validate our model
(e.g. checking that the protocol completes in the absence of
an attacker) and to prove our desired security goals. Most
of the effort is in formalizing, reﬁning, and discovering the
right security queries. Although ProVerif is fully automated,
veriﬁcation gets more expensive as the protocol grows more
complex. So, as we extend our models to cover multiple
modes of TLS 1.3 composed with TLS 1.2, we sometimes
need to simplify or restructure our models to aid veriﬁcation.
487
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
Client C
Server S
Long-term Keys: (sk C, pk C)
Long-term Keys: (sk S, pk S)
ClientHello(nC, oﬀer C[(G, gx), G
(cid:2))
RetryRequest(G
(cid:2)])
Generates x
(cid:2) and computes:
es = kdf0
Generates y and computes:
es = kdf0
ClientHello(nC, oﬀer
(cid:2)
C[G
(cid:2)
, gx(cid:2)
])
Chooses parameters:
mode S = (TLS1.3, DHE(G
(cid:2)), H(), enc())
log 1
(cid:2)
ServerHello(nS, mode S[G
, gy])
log 1