  Candidate --> Follower: 发现新的任期号、新的Leader
  Candidate --> Leader: 收到半数以上票数
  Leader --> Follower: 发现新的任期号
```
- Leader 会周期性的发送心跳包给 Follower。
- 每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms~300ms
- 如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段
- 竞选阶段Candidate会向其他节点发送投票请求，Follower同意投票则向该Candidate回复同意投票
- 当 Candidate获得超过半数票时，就成为Leader节点，如果有多个Candidate获得相同的票数，则重新开始投票
多个候选人同时发起选举，导致选票被瓜分，没有候选人获得半数选票，选举失败，所以每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 瓜分选票的概率很低
每一任新的领导人出现，都会带有一个任期（term），任期是连续的整数，充当逻辑时钟。任期时长不确定，只要网络不发生大面积分区，而且超过半数的节点和 Leader 一直可以正常工作，这届任期可能就会非常长，通过任期可以比较各个节点的数据新旧、识别过期的 Leader 等。
如果一个候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态，如果一个节点接收到一个包含较小的任期编号值的请求，那么它会直接拒绝这个请求
#### 日志复制
- 为了解决多个节点的[复制状态机](/软件工程/架构/系统设计/分布式/分布式数据.md#复制)的一致性问题
Raft 对“已提交”的条件定义也很简单有效，如果一个日志被 Leader 复制到大多数节点，日志就算被提交了，这点跟[Kafka的生产者](/中间件/消息队列/Kafka/生产者.md#生产者)提交一样
![2022711113515](/assets/2022711113515.webp)
#### 成员变更
当集群里的机器发生变更时，Raft 引入了一个过渡共识的状态，处于这个状态的算法：
- 所有的日志追加写入，都会复制到新老配置里所有的服务器
- 新老配置里的任何一个服务器，都有可能被选举成 Leader 节点
- 无论是选举，还是达成共识后提交日志，投票需要同时满足旧配置里半数以上服务器的通过，而且也需要新配置里半数以上服务器的通过
类似于数据迁移的双写策略
#### 数据同步
- 自客户端的修改都会被传入 Leader。此时该修改还未被提交，只是写入日志中
- Leader 会把修改复制到所有 Follower
- Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交
- 此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致
#### 安全性问题
通过给选举和日志复制增加一系列规则，来实现 Raft 算法的安全性
切换新 Leader 之后，新的 Leader 可能没有同步到最新的日志写入。而这可能会导致，新的 Leader 会尝试覆盖之前 Leader 已经写入的数据
想要确保 Leader 的日志是最新的，只需要在 Leader 选举的时候，让只有最新日志的 Leader 才能被选上就好，即当节点收到选举投票的时候，需检查候选者的最后一条日志中的任期号，若小于自己则拒绝投票。如果任期号相同，日志却比自己短，也拒绝为其投票
日志匹配：
- 不同日志中的两个记录，如果拥有相同的任期和索引，它们的内容相同。
- 不同日志中的两个记录，如果拥有相同的任期和索引，它们之前的内容也相同
如果某个日志条目在某个任期号中已经被提交，该记录必定出现在更大任期号的所有领导人中，限制 Candidate 提交选举请求的时候，必须至少和 Follower 的日志一样新，才可以获得选票
## Goossip协议
最终一致性的分布式共识协议
- 系统中不一致的状态有可能会在一定时间内被外部直接观察到
![2020111815129](/assets/2020111815129.gif)
### 直接邮寄
直接发送更新数据，当数据发送失败时，将数据缓存下来，然后重传，可能会因为缓存队列满了而丢数据
### 反熵
- 全量同步数据
每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性
### 传谣
- 只对外发送变更消息，周期性地联系其他节点发送新数据，直到所有的节点都存储了该新数据
## Quorum NWR
- N：表示集群中同一份数据有多少个副本
- W：成功完成 W 个副本更新，才完成写操作
- R：读取一个数据对象时需要读 R 个副本
- 当 W + R > N 的时候，W和R肯定会有重叠的副本，对于客户端来讲，整个系统能保证强一致性（客户端一致性，多了层筛选，每次都选最新的，这样对上层业务就是一致的了）
- W + R <= N 的时候，对于客户端来讲，整个系统只能保证最终一致性
## PBFT
前提：
1. 消息来源无法伪造
2. 基于大多数原则（2f + 1）实现共识 f为叛徒数
![2022722161932](/assets/2022722161932.webp)
主节点叛变了怎么办？
如果恶意节点当选了主节点，此时无论忠诚节点数多少，忠诚节点们将都无法达成共识
当客户端发现主节点是叛徒时，就可以向其他可信节点发送指令，这些节点就可以在自己选举出新的可信主节点
## PoW
- 工作量证明，增加作恶的成本
请求方做了一些运算，解决了某个问题，然后把运算结果发送给验证方，进行核验，验证方根据运算结果，这个过程是不对称的，运算要耗费较多的资源，但易于验证
给定一个随机值，如果其哈希值满足特定形式，工作就完成，验证方验证变更的字符串是不是真的满足这个形式来验证通过
区块链的工作证明是通过对区块头执行 SHA256 哈希运算，得到小于目标值（动态调整的公共值，像比特币这个值现在正在越调越小）的哈希值，来证明自己的工作量，只有验证通过后，当前区块才会被加入链中
![区块头及区块体](/assets/2022722171655.webp)
## 共识的局限性
- 投票节点数量是固定的
- 依赖超时机制
- 对网络问题敏感