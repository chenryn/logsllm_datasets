(2) For AES designs with trojans, Transys successfully
translates all assertions to the 20 trojan-injected AES designs.
For example, as shown in Figure 7, Transys translates 4
AES Information Flow Tracking assertions written in the
AES-04 design (a trojan-free design) to the 20 AES designs
with different trojans injected. The trojans include leaking the
secret key through AM radio, leakage current, spread spectrum
communications, and draining the battery to cause denial-of-
service [25], [26]. In this case, the translated assertions can
potentially be used to detect the injected trojans.
(3) For processor designs, we translate assertions from the
OR1200 to 5 processor designs in two different architectures.
We found that the assertions A19 and A26 do not exist in the
two RISC-V cores: A19 and A26 are about the l.mtspr in-
struction and custom instructions, which are not implemented
in the two RISC-V cores.
We ﬁrst evaluate the remaining 46 of the 50 total transla-
tions, and among those the translation rate is 85%. Among
the 7 failed cases, 3 of them fail in the Transformation Pass
and 4 of them fail in the Reﬁnement Pass—Transys cannot
ﬁnd valid preconditions to make the consequent true. All the
failed cases happen when we try to translate the assertions
from OR1K designs to RISC-V designs: 2 of them are to the
OpenV core, and 5 of them are to the Picorv32 core.
We separately evaluate the 4 translations for which the as-
sertion does not exist in the target design. Transys successfully
translates 3 of them. These 3 new assertions are valid but the
policies they capture are different than the original assertions’
policies. The false positive rate here is 75%.
(4) For RSA designs, we translate 1 assertion mined from
the speciﬁcation, and 5 Information Flow Tracking assertions.
All of them are successfully translated to the new designs.
(5) We also test Transys by translating the assertions back
to the original designs. Transys successfully translates all as-
sertions back to the original designs. This implies the variable
mapping pass can map the variables to themselves, and the
second and third pass preserve the structure of the assertions.
Designs
AES
AES w/ Trojan
CPU
RSA
Total
Total Translations
360
400
46
18
824
Total Succ
336
400
39
18
793
Fail in VM Pass
0
0
0
0
0
Fail in T Pass
8
0
3
0
11
Fail in R Pass
16
0
4
0
20
Total Transl. Rate
93%
100%
85%
100%
96%
Table X: Main results of assertion translation for 18 AES designs, 20 AES designs with trojans, 5 processor designs, and 3 RSA designs.
Fig. 6: AES01—AES18 translation
results: total transl. number and suc-
cess transl. rate.
Fig.
7: AES-T100—AES-T2100
transl. results: total transl. number
and success transl. rate.
Fig. 8: RSA01—RSA03 translation
results: total transl. number and suc-
cess transl. rate.
Fig. 9: CPU translation results: total
transl. number and success transl.
rate.
C. Quality
To evaluate the quality of the translated assertions, we
ﬁrst check whether the translated assertions are valid for the
target design using the model checking tool Cadence IFV.
We then manually review the assertions alongside the design
speciﬁcations to determine whether the translated assertions
are semantically equivalent to the original assertions.
1) Validity: We check whether the translated assertions
are valid by adding them to the target designs and running
Cadence IFV. Figures 6, 7, 8, and 9 shows the results. For
the nine Information Flow Tracking assertions, we do not have
the tool to check the validity of the translated assertions (167 in
total) and thus their validity result is not available. All the other
626 translated assertions can pass veriﬁcation by Cadence IFV,
indicating that the assertions Transys generates are valid.
2) Equivalence: Figures 10, 11, 12, and 13 show the results
of the equivalence checking. Type equivalence refers to the
case that the translated assertion and the original assertion
belong to the same type or module of security properties,
as given in column 1 of Tables I, II, III, and IV. Semantic
equivalence refers to the case that the translated assertion and
the original assertion are semantically the same.
The translation of assertions to trojan-injected AES designs
achieves 100% semantic equivalence rate. For other designs,
the translation of 23 (64%) assertions has type and semantic
equivalence rate above 60% (between 60% and 100%). The
translations of the remaining 13 (36%) assertions have type
and semantic equivalence rate between 20% to 50%. The
low rates mainly happen in two cases:
the translation of
Information Flow Tracking assertions and the translation from
OpenRISC cores to RISC-V cores.
The main reason for the translated assertions to fail to
capture the meaning of the original assertion is because the
variable mapping pass fails to map to an accurate variable or
even fails to map to the correct module in the target design. In
No.
Original
AES01
AES02
AES03
AES04
AES05
AES06
AES07
AES08
AES09
AES10
AES11
AES12
AES13
AES14
AES15
AES16
AES17
AES18
Translation Results
(keysched.state == 4) → (keysched.next_key_reg[31:0] ==
keysched.next_key_reg[63:32] ⊕ keysched.last_key_i[31:0])
(round_ctr_reg[0]) & (key_mem_we) & (!round_ctr_inc) →
(key_mem_new == key[255:128])
u1.r1.t0.w0 == u1.r1.t0.key[127:96]
(key_exp.key_start==1)&(key_exp.round[1:0]==2’b01)→#1
(key_exp.wr_data==prev(key_exp.key_in[255:192]))|
(key_exp.wr3==0)
a1.k0b == a1.k0a ⊕ a1.k4a
n.a.
(!u0.kld)→#1(u0.w[0]==prev(u0.w[0]⊕u0.subword⊕u0.rcon))
a1.k0a == prev({a1.k0[31:24] ⊕ rcon, a1.k0[23:0]})
n.a.
(keysched.state == 4) → (keysched.next_key_reg[31:0] ==
keysched.next_key_reg[63:32] ⊕ keysched.last_key_i[31:0])
AES_CORE_DATAPATH.KEY_EXPANDER.key[3]
==
AES_CORE_DATAPATH.KEY_EXPANDER.key_in[31:0]
(!u0.kld) → #1 (u0.w[1] == prev(u0.w[0] ⊕ u0.w[1] ⊕
u0.subword ⊕ u0.rcon))
w0_next == sbox_out ⊕ rcon ⊕ w0
w4 == key[127:96] ⊕ subword ⊕ 16777216
w4 == w0 ⊕ subword ⊕ {rcon2[31:24],24’b0}
wNext[1] == w[1] ⊕ wNext[0]
roundkey_text == mixcolumns_text ⊕ okey
roundkey_text == mixcolumns_text ⊕ okey
w7 == key[127:96] ⊕ key[95:64] ⊕ key[63:32] ⊕ key[31:0]
⊕ subword ⊕ 16777216
Table XI: The results of translating A28-01 to 18 AES designs.
all our experiments, we choose the parameters in the Variable
Mapping Phase empirically to be α : β : γ = 3 : 2 : 1. This
combination works well in most cases, but not all of them.
D. Case Studies
In this section, we show 3 examples: (1) translation from
one AES design to another AES design; (2) translation from
one processor design to two different processor designs from
two architectures (OR1K architecture and RISC-V architec-
ture); (3) translating an Information Flow Tracking assertion
from one trojan-free AES design to a trojan-injected design.
050100150#oftransl.A27-01toA27-10A28-01toA28-04A29-01toA29-02A36-01toA36-04AssertionId.(groupedasranges)020406080100Ratio(%)n/aTransl.ratioValidratio050100150#oftransl.A27-01toA27-10A28-01toA28-04A29-01toA29-02A36-01toA36-04AssertionId.(groupedasranges)020406080100Ratio(%)n/aTransl.ratioValidratio0123#oftransl.A32-01A33-06A36-05A36-06A37-01A37-02AssertionId.020406080100Ratio(%)n/an/an/an/an/aTransl.ratioValidratio012345#oftransl.A01A03A04A08A09A15A17A19A23A26AssertionId.020406080100Ratio(%)Transl.ratioValidratioFig. 10: Type and semantic equiv. for
AES01—AES18 designs.
Fig. 11: Type and semantic equiv. for
AES-T100—AES-T2100 designs.
Fig. 12: Type and semantic equiv. for
RSA01—RSA03 designs.
Fig. 13: Type and semantic equiv. for
CPU designs.
ST
Pass
CR
Pass
Pass Translation Results
VM
Pass
(key_exp.pstate==4)→(key_exp.key_in[31:0]==
key_exp.key_in[63:32]⊕key_exp.key_in[31:0])
(key_exp.pstate==4) → (key_exp.wr_data==key_exp.key_in[255:192])
(key_exp.pstate==4) → (key_exp.wr_data==key_exp.key_in[191:128])
(key_exp.pstate==4) → (key_exp.wr_data==key_exp.key_in[127:64])
(key_exp.pstate==4) → (key_exp.wr_data==key_exp.key_in[63:0])
i_key == key_exp.key_in
(key_exp.key_start==1)&(key_exp.round[1:0]==2’b01)→#1
(key_exp.wr_data==prev(key_exp.key_in[255:192]))|(key_exp.wr3==0)
(key_exp.key_start==0)&(key_exp.key_start_L==1)
&(key_exp.round[1:0]==2’b01)→#1
(key_exp.wr_data==prev(key_exp.key_in[191:128]))|(key_exp.wr3==0)
(key_exp.key_start==0)&(key_exp.wr3==1)&(key_exp.init_wr3==1)
&(key_exp.round[1:0]==2’b01)→#1
(key_exp.wr_data==prev(key_exp.key_in[127:64]))|
(key_exp.wr3==0)
(key_exp.key_start==0)&(key_exp.wr3==1)&(key_exp.init_wr4==1)
&(key_exp.round[1:0]==2’b01)→#1
(key_exp.wr_data==prev(key_exp.key_in[63:0]))|
(key_exp.wr3==0)
i_key == key_exp.key_in
No.
Original
OR1200
Espresso
Translation Results
(or1200_rf.rf_we==1)→(or1200_rf.rf_addrw!=0)|
(or1200_rf.rf_dataw==0)
(or1200_rf.rf_we==1)→(or1200_rf.rf_addrw!=0)|
(or1200_rf.rf_dataw==0)
(mor1kx_rf_espresso.rfa_o_use_last)&
(mor1kx_rf_espresso.result_last[0]==0)&
(mor1kx_rf_espresso.rfd_last==mor1kx_rf_espresso.rfa_r)&
(mor1kx_rf_espresso.rfa_adr_i[0])&
(mor1kx_rf_espresso.rfa_o[0]==0)→
(mor1kx_rf_espresso.rfa_adr_i(cid:54)=0)|
(mor1kx_rf_espresso.rfa_o==0)
Cappuccino mor1kx_rf_cappuccino.rf_wradr==
mor1kx_rf_cappuccino.wb_rfd_adr_i
(mor1kx_rf_cappuccino.rf_wradr)&
(mor1kx_rf_cappuccino.rf_wrdat)→
(mor1kx_rf_cappuccino.rf_wrdat==0)|
(mor1kx_rf_cappuccino.rf_wraddr!=0)
n.a.
picorv32.dbg_mem_rdata == picorv32.mem_rdata
OpenV
Picorv32
Table XII: Detailed results of translating A28-01 to the AES03 design. VM:
Variable Mapping, ST: Structural Transformation, CR: Constraint Reﬁnement.
1) Example 1: We show the details of translating the
assertion A28-01 from AES09 to all AES designs. Table XI
shows the resulting assertions. For the assertions in AES02,
AES03, AES12, we classify them as in the same type as
the original assertion, but not as having equivalent semantics.
For the assertions in AES16 and AES17, they belong to the
calculation of round keys, and thus are neither type equivalent
nor semantically equivalent to the original assertion.
Table XII shows the detailed results of translating assertion
A28-01 from AES09 to AES03. After the Variable Mapping
Pass, keysched.next_key_reg and keysched.last_key_i are
both mapped to key_exp.key_in. The assertion generated is
not valid yet. After the Transformation Pass, Transys outputs
5 assertions. These assertions are generated from the part of
the PDG that contains the variable key_exp.key_in. Only the
5th assertion is valid. Finally, from the Reﬁnement Pass, all
the 4 assertions are reﬁned and are valid. It is worth noting
that the antecedents generated from the Reﬁnement Pass are
neither close to the part of the code of the consequent nor
similar to the original code, and thus it would be difﬁcult for
a human to ﬁgure them out manually.
2) Example 2: Table XIII shows the translation results
for translating assertion A04 to ﬁve processor designs. The
translation fails in the Reﬁnement Pass when translating
the assertion to the OpenV design. For the other designs,
Transys can successfully generate valid assertions. The trans-
Table XIII: The results of translating A04 to 5 CPU designs.
lated assertions for the OR1200, Espresso, and Cappuccino
processors are semantically equivalent. These three designs
are all implementations of the OR1K architecture and it is
easier to translate assertions among them. The assertion for
the Picorv32 does not capture the same semantic meaning,
but it also belongs to the type of security properties that are
relavent to the memory.
3) Example 3:
In this example,