类似“没有将磁碟插入驱动器”这样的情况中。 
· 系统调用可能因为外部的事件（如信号等）而被中断。这可能不代表彻底的执行失
败，但是如果需要，程序应当重新尝试执行系统调用。 
在一个好的、大量使用系统调用的程序中，很多情况下，多数的代码将被用于检测、处
理错误和其它意外情况，而不是用于完成程序的主要任务。 
2.2.3 系统调用返回的错误码 
多数系统调用在成功执行之后返回 0，而在失败的时候返回非 0 值。（不过，也有许多
函数通过返回值表示不同的意义；例如，malloc 在执行失败后返回空指针。在使用系统调
用之前，务请仔细阅读相关的手册页。）（译者注：前文提到的 malloc 函数并不属于一般意
义上的系统调用，而是 Glibc 提供的库函数。）尽管这些信息足够用于判定程序是否应该继
续执行，它并不足以让程序清楚地了解如何对已经出现的错误进行恢复和处理。 
多数系统调用在执行失败的时候会通过一个特殊的全局变量errno保存错误相关的信息
2。当执行失败的时候，系统调用会将errno设置为特定的值以指示错误原因。因为所有系统
调用均会使用errno指示出现的错误，你应该在出现错误之后立刻将errno的值保存到其它的
变量中。在此之后的系统调用过程可能在出错的情况下覆盖现有的值。 
错误代码是整型的；可能值均通过预处理宏指定了。这些宏的命名均为错误的约定名字
www.AdvancedLinuxProgramming.com 
27
2 实际上，出于线程安全的考虑，errno会被实现为一个宏；但是使用方式与一个普通的全局变量并无二
致。 
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
的全部大写形式加上前缀 E 构成——例如“EACCES”和“EINVAL”等。始终应该通过这
些宏表示 errno 的值，而不是直接使用整数。如果要使用这些错误代码，则需要在程序中包
含。 
GNU/Linux 提供了 strerror 函数以简化错误处理。这个函数用于返回一个 errno 错误代
码对应的说明性字符串。这个字符串可以用于程序输出的错误信息中。使用 strerror 需要在
程序中包含。 
GNU/Linux 还提供了 perror 函数。这个函数会直接将错误信息输出到 stderr 流。传递
给 perror 的参数是一个前缀字符串；当函数执行的时候，这个字符串将作为错误信息的前
缀输出，因此通常可以在这个字符串中说明出错的函数。使用 perror 需要在程序中包含
。 
在这个代码片断中我们尝试打开一个文件；如果打开文件操作失败，它会输出错误信息
并退出程序。注意系统调用 open 在成功时返回一个文件描述符，而在失败时返回 -1。 
fd = open (“inputfile.txt”, O_RDONLY); 
if (fd == -1) { 
  /* 对 open 的调用失败。输出错误信息并退出。*/ 
  fprintf (stderr, “error opening file: %s\n”, strerror (errno)); 
  exit (1); 
} 
取决于你的程序和系统调用本身的特性，当出错的时候你可以选择输出错误信息、取消
一个操作、强制退出程序、重新尝试调用甚至是直接忽略这个错误。不过，包含一段通过某
种方式处理所有错误情况的程序逻辑是非常必要的。 
有一个你始终应该注意（尤其在执行 I/O 操作的时候）的错误代码是 EINTR。某些函
数，如 read、write 和 sleep 等，可能需要很长时间才能执行完毕。这些函数被成为阻塞
（blocking）函数，因为程序的执行会被阻塞直到这个函数调用结束。但是，当程序在阻塞
过程中收到一个信号，这些函数可能不等执行完毕就直接返回。在这种情况下，errno 被设
置为 EINTR。通常在这种时候你应该尝试重新执行这个操作。 
下面的代码片断中，我们利用 chown 函数将 path 指定的文件的属主改为 user_id 指明
的用户。如果调用失败，程序将根据 errno 的值作出不同的响应。注意，当我们检测到一个
可能是程序 bug 的错误情况时，我们通过 abort 或 assert 退出程序；这样会导致生成一个核
心转储文件（core file）。这对于事后调试（post-mortem debugging）将很有用。对于其它不
可恢复的错误，我们通过 exit 与一个非 0 返回值表明错误的出现；因为这种情况下核心转储
文件并不会带来更多的好处。 
rval = chown (path, user_id, -1); 
if (rval != 0) { 
  /* 保存 errno 的值，因为下次系统调用将可能抹去这个值。*/ 
  int error_code = errno; 
  /* 操作失败；chown 会在执行出错时返回 -1。*/ 
  assert (rval == -1); 
  /* 检查 errno 的值，并作出相应的处理。*/ 
  switch (error_code) { 
  case EPERM:         /* 权限不足。*/ 
  case EROFS:         /* PATH 位于一个只读文件系统中。*/ 
www.AdvancedLinuxProgramming.com 
28
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
  case ENAMETOOLONG: /* PATH 长度超过限度。*/ 
  case ENOENT:        /* PATH 指定的路径不存在。*/ 
  case ENOTDIR:       /* PATH 的某些部分不是文件夹。*/ 
  case EACCES:        /* PATH 的某些部分无法访问。*/ 
    /* 文件有些问题。输出错误信息。*/ 
    fprintf (stderr, “error changing ownership of %s: %s\n”, 
               path, strerror (error_code)); 
    /* 不要结束程序；可能可以给用户提供一个重新选择文件的机会……*/ 
    break; 
  case EFAULT: 
    /* PATH 包含了非法的内存地址。这可能是一个程序 bug。*/ 
    abort (); 
  case ENOMEM: 
    /* 内核内存不足。*/ 
    fprintf (stderr, “%s\n”, strerror (error_code)); 
    exit (1); 
  default: 
    /* 其它一些非预期的错误代码。我们已经尝试处理所有可能的错误代码； 
如果我们忽略了某个代码，这将是一个 bug！*/ 
abort (); 
}; 
} 
你可以选择使用下面这段代码；当运行成功的时候它的行为方式与上面的程序相同。 
rval = chown (path, user_id, -1); 
assert (rval == 0); 
但如果调用失败，这段代码无法对错误进行汇报、处理及恢复。 
选择第一种、第二种或是两者之间的某种错误处理方式，完全取决于你的程序对错误检
测和处理方面的要求。 
2.2.4 错误与资源分配 
很多情况下，当一个系统调用失败的时候程序可以选择取消当前的操作而不终止运行，
因为这些错误是可以恢复的。一种方式是从当前函数中返回，通过将错误代码传回给调用者
表示错误的出现。 
如果你决定从函数当中返回，必须确保函数中已经成功分配的资源必须首先被释放。这
些资源可能包括内存、文件描述符、文件指针、临时文件、同步对象等。否则，如果你的程
序继续保持运行，这些资源将被泄漏。 
考虑这个例子，一个函数将一个文件的内容读入缓冲区。这个函数可能会按照这个步骤
执行： 
www.AdvancedLinuxProgramming.com 
29
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
1. 
分配缓冲区。 
2. 
打开文件。 
3. 
将文件读入缓冲区。 
4. 
关闭文件。 
5. 
返回缓冲区。 
如果文件不存在，第二步将失败。从这个函数中返回 NULL 是一种可选的对策。但是，
如果缓冲区已经在第一步中完成分配，直接返回可能导致内存的泄漏。你必须记得在返回之
前的流程中释放这个缓冲区。如果程序在第三步出错，不仅是缓冲区，你还必须记住关闭文
件。 
列表 2.6 展示了这个函数的一种实现。 
代码列表 2.6 （readfile.c）在异常情况下释放资源 
#include  
#include  
#include  
#include  
#include  
char* read_from_file (const char* filename, size_t length) 
{ 
  char* buffer; 
  int fd; 
  ssize_t bytes_read; 
/* 分配缓冲区。*/ 
  buffer = (char*) malloc (length); 
  if (buffer == NULL) 
    return NULL; 
  /* 打开文件。*/ 
  fd = open (filename, O_RDONLY); 
  if (fd == -1) { 
    /* open 失败。在返回之前释放缓冲区。*/ 
    free (buffer); 
    return NULL; 
  } 
  /* 读取数据。*/ 
  bytes_read = read (fd, buffer, length); 
  if (bytes_read != length) { 
    /* read 失败。释放缓冲区，关闭文件，然后返回。*/ 
    free (buffer); 
  close (fd); 
www.AdvancedLinuxProgramming.com 
30
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 
  return NULL; 
} 
} 
Linux 会在程序退出的时候清理分配的内存、打开的文件和其它绝大多数资源，因此在
调用 exit 之前释放缓冲区并关闭文件。不过，你可能需要手工释放其它资源，如临时文件和
共享内存等——这些资源在进程结束后仍然存在。 
2.3 编写并使用程序库 
差不多可以认为，每个程序都链接到一个或几个库上。任何一个使用了 C 函数（诸如
printf 等）都须链接到 C 运行时库。如果你的程序具有图形界面（GUI），它将被链接到窗
口系统的库。如果你的程序使用了数据库，数据库供应商会提供给你一些简化访问数据库的
库。 
在这些情况中，你必须作出选择：静态（statically）还是动态（dynamically）地将程序
链接到库上。如果你选择了静态链接，程序体积可能会更大，程序也会比较难以升级，但是
可能相对而言比较易于部署。如果你选择动态链接，则程序体积会比较小、易于升级，但是
部署的难度将会有所提高。本节中我们将介绍静态和动态两种链接方法，仔细比较它们的优
劣，并提出一些在两者之间选择的简单的规则。 
2.3.1 存档文件 
存档文件（archive），也被称为静态库（static library），是一个存储了多个对象文件（object 
file）的单一文件。（与 Windows 系统的 .LIB 文件基本相当。）编译器得到一个存档文件后，
会在这个存档文件中寻找需要的对象文件，将其提取出来，然后与链接一个单独的对象文件
一样地将其链接到你的程序中。 
你可以使用 ar 命令创建存档文件。传统上，存档文件使用 .a 后缀名，以便与 .o 的对
象文件区分开。下面的命令可以将 test1.o 和 test2.o 合并成一个 libtest.a 存档： 
% ar cr libtest.a test1.o test2.o 
上面命令中的cr选项通知ar创建这个存档文件3。现在你可以通过为gcc或g++指定 –ltest
参数将程序链接到这个库。这个过程在第一章“起步”1.2.2 节“链接对象文件”中进行了
说明。 
当链接器在命令行参数中获取到一个存档文件时，它将在其中搜索所有之前已经被引用
而没有被定义的符号（函数或变量）的定义。定义了这些符号的对象文件将从存档中被提取
出来，链接到新程序执行文件中。因为链接器会在读取命令行参数的过程中一遇见存档文件
就进行解析，通常将存档文件放在命令行参数的最后最有意义。例如，假设 test.c 包含了列
表 2.7 中的代码而 app.c 包含了列表 2.8 中的代码。 
代码列表 2.7 （test.c）库内容 
www.AdvancedLinuxProgramming.com 
31
int f () 
3 还有其它一些选项，包括从存档中删除一个文件或者执行其它操作。这些操作很少用，不过在ar手册页
中都有说明。 
高级 Linux 程序设计·卷一·Linux 平台上的高级 UNIX 编程 
完美废人 译 