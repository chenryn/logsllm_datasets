---
author: Two-bit History
category: 观点
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 1
  viewnum: 8739
date: '2018-12-25 14:45:00'
editorchoice: true
excerpt: 我知道这很学院派，可一行超过 80 个字符的代码还是让我抓狂。我也在网上见过不少人认为即使在现代的视网膜屏幕下也应当采用行长度为 80 个字符的标准，可他们都不理解我对破坏这一标准的怒火，就算多
  1 个字符也不行。
fromurl: https://twobithistory.org/2018/06/23/ibm-029-card-punch.html
id: 10382
islctt: true
largepic: /data/attachment/album/201812/25/144551dtit8dpgprga5p3n.jpg
permalink: /article-10382-1.html
pic: /data/attachment/album/201812/25/144551dtit8dpgprga5p3n.jpg.thumb.jpg
related:
- displayorder: 0
  raid: 10482
reviewer: wxy
selector: lujun9972
summary: 我知道这很学院派，可一行超过 80 个字符的代码还是让我抓狂。我也在网上见过不少人认为即使在现代的视网膜屏幕下也应当采用行长度为 80 个字符的标准，可他们都不理解我对破坏这一标准的怒火，就算多
  1 个字符也不行。
tags:
- 打孔卡
thumb: false
title: IBM 029 型打孔机
titlepic: true
translator: wwhio
updated: '2018-12-25 14:45:00'
---
我知道这很学院派，可一行超过 80 个字符的代码还是让我抓狂。我也在网上见过不少人认为即使在现代的视网膜屏幕下也应当采用行长度为 80 个字符的标准，可他们都不理解我对破坏这一标准的怒火，就算多 1 个字符也不行。
在这一标准的黄金时期，一行代码的长度几乎不会超过 80 个字符的限制。在那时，这一限制是物理的，没有第 81 列用于存放第 81 个字符。每一个试图把函数名起的又长又臭的程序员都会在短暂的愉悦后迎来更多的麻烦，而这仅仅是因为没有足够的空间放下整个函数的声明。
这一黄金时期也是 打孔卡   punch card 编程时期。在 20 世纪 60 年代，IBM 打孔卡设立了标准，这个标准就是打孔卡的宽度为 80 列。这个 80 列标准在后来的电传打字机和哑终端时期得以延续，并逐渐成为操作系统中隐藏的细节。时至今日，即使我们用上了更大、更好的屏幕，偏向于使用更长的标识符而不是类似 `iswcntrl()` 这样令人难以猜测的函数名，可当你打开新的终端模拟器窗口时，默认的宽度依然是 80 个字符。
从 Quora 上的很多问题中可以发现，很多人并不能想象如何使用打孔卡给计算机编程。我承认，在很长的一段时间里我也不能理解打孔卡编程是如何工作的，因为这让我想到就像劳工一样不停的给这些打孔卡打孔。当然，这是一个误解，程序员不需要亲自给打孔卡打孔，就像是火车调度员不用亲自扳道岔。程序员们有 打孔机   card punch machines （也被称为 键控打孔机   key punches ），这让他们可以使用打字机式的键盘给打孔卡打孔。这样的设备在 19 世纪 90 年代时就已经不是什么新技术了。
那时，最为广泛使用的打孔机之一便是 IBM 029 型打孔机。就算在今天，它也许是最棒的打孔机。
![](/data/attachment/album/201812/25/144551dtit8dpgprga5p3n.jpg)
IBM 029 型打孔机在 1964 年作为 IBM 的 System/360 大型电脑的配件发售的。System/360 是计算系统与外设所组成的一个系列，在 20 世纪 60 年代晚期，它几乎垄断了整个大型计算机市场。就像其它 System/360 外设一样，029 型打孔机也是个大块头。那时，计算机和家具的界限还很模糊，但 029 型打孔机可不是那种会占领你的整张桌子的机器。它改进自 026 型打孔机，增加了新的字符支持，如括号，总体上也更加安静。与前辈 026 型所展出 20 世纪 40 年代的圆形按钮与工业化的样貌相比，029 型的按键方正扁平、功能按键还有酷炫的蓝色高亮提示。它的另一个重要买点是它能够在 数字区   numeric field 左侧自动的填充 0 ，这证明了 JavaScript 程序员不是第一批懒得自己做 左填充   left-padding 的程序员。（LCTT 译注：这项功能需要额外的 4 张    标准模块系统卡    SMS card 才能使用。例如设置数字区域长度为 6 列时，操作员只需要输入 73 ，打孔机会自动填充起始位置上的 4 个 0 ，故最终输出 000073。[更多信息](https://en.wikipedia.org/wiki/Keypunch#IBM_029_Card_Punch)）
等等！你说的是 IBM 在 1964 年发布了全新的打孔机？你知道那张在贝尔实验室拍摄的 Unix 之父正在使用电传打字机的照片吗？那是哪一年的来着？1970？打孔机不是应该在 20 世纪 60 年代中期到晚期时就过时了吗？是的，你也许会奇怪，为什么直到 1984 年，IBM 的产品目录中还会出现 029 型打孔机的身影    1 。事实上，直到 20 世纪 70 年代，大多数程序员仍然在使用打孔卡编程。其实二战期间就已经有人在用电传打字机了，可那时并没能普及。客观的讲，电传打字机几乎和打孔卡一样古老。也许和你想象的恰恰相反，并不是电传打字机本身限制了它的普及，而是计算时间。人们拒绝使用电传打字机的原因是，它是可交互的，它和计算机使用 “在线”的传输方式      online    mode of communication 。在以 Unix 为代表的分时操作系统被发明前，你和电脑的交互会被任何人的使用而打断，而这一点延迟通常意味着几千美元的损失。所以程序员们普遍选择离线地使用打孔机编程，再将打孔卡放入大型计算机中，作为 批任务   batch job 执行。在那时，还没有即廉价又可靠的存储设备，可打孔卡的廉价优势已经足够让它成为那时最流行的数据存储方式了。那时的程序是书架上一摞打孔卡而不是硬盘里的一堆文件。
那么实际使用 IBM 029 型打孔机是个什么样子呢？这很难向没有实际看过打孔卡的人解释。一张打孔卡通常有 12 行 80 列。打孔卡下面是从 1 到 9 的 数字行   digit rows ，打孔卡上的每一列都有这些行所对应的数字。最上面的三行是 空间行      zone    rows ，通常由两行空白行和一行 0 行组成。第 12 行是打孔卡最顶部的行，接下来是 11 行，随后是从数字 0 到 9 所在的行。这个有点让人感到困惑的顺序的原因是打孔卡的上边缘被称为 12 边   12 edge 、下边缘被称为  9 边   9 edge 。那时，为了让打孔卡便于整理，常常会剪去打孔卡的一个角。
![](/data/attachment/album/201812/25/144552j4ce2ze22qc8cdc5.png)
（LCTT 译注：可参考[EBCDIC 编码](https://zh.wikipedia.org/wiki/EBCDIC)）
在打孔卡发明之初，孔洞的形状是圆形的，但是 IBM 最终意识到如果使用窄长方形作为孔洞，一张卡就可以放下更多的列了。每一列中孔洞的不同组合就可以表达不同的字符。像 029 型这样的拥有人性化设计的打孔机除了完成本质的打孔任务外，还会在打孔卡最上方打印出每一列所对应的字符。输入是数字就在对应的数字行上打孔。输入的是字母或符号就用一个在空间列的孔和一或俩个在数字列的孔的组合表示，例如字母 A 就用一个在第 12 空间行的空和一个数字 1 所在行的孔表示。这是一种顺序编码，在第一台打孔机被发明后，也叫 Hollerith 编码。这种编码只能表示相对较小的一套字符集，小写字母就没有包含在这套字符集中。如今一些聪明的工程师可能想知道为什么打卡不干脆使用二进制编码 —— 毕竟，有 12 行，你可以编码超过 4000 个字符。 使用 Hollerith 编码是因为它确保在单个列中出现不超过三个孔。这保留了卡的结构强度。二进制编码会带来太多的孔，会因为孔洞过于密集而断裂。