首先，让我们获取 0.1 的指数和尾数。我们需要减去 1023 来得到实际的指数，因为浮点运算就是这么计算的。
```
>>> get_exponent(0.1) - 1023
-4
>>> get_significand(0.1)
2702159776422298
```
它们根据 `2**指数 + 尾数 / 2**(52 - 指数)` 这个公式得到 `0.1`。
下面是 Python 中的计算:
```
>>> 2**-4 + 2702159776422298 / 2**(52 + 4)
0.1
```
（你可能会担心这种计算的浮点精度问题，但在本例中，我很确定它没问题。因为根据定义，这些数字没有精度问题 -- 从 `2**-4` 开始的浮点数以 `1/2**(52 + 4)` 步长递增。）
`0.2` 也一样:
```
>>> get_exponent(0.2) - 1023
-3
>>> get_significand(0.2)
2702159776422298
```
它们共同工作得到 `0.2`:
```
>>> 2**-3 + 2702159776422298 / 2**(52 + 3)
0.2
```
（顺便说一下，0.1 和 0.2 具有相同的尾数并不是巧合 —— 因为 `x` 和 `2*x` 总是有相同的尾数。）
#### 步骤 2：重新计算 0.1 以获得更大的指数
`0.2` 的指数比 `0.1` 大 -- -3 大于 -4。
所以我们需要重新计算：
```
2**-4 + 2702159776422298 / 2**(52 + 4)
```
等于 `X / 2**(52 + 3)`
如果我们解出 `2**-4 + 2702159776422298 / 2**(52 + 4) = X / 2**(52 + 3)`，我们能得到：
`X = 2**51 + 2702159776422298 / 2`
在 Python 中，我们很容易得到：
```
>>> 2**51 + 2702159776422298 //2
3602879701896397
```
#### 步骤 3：添加符号位
现在我们试着做加法：
```
2**-3 + 2702159776422298 / 2**(52 + 3) + 3602879701896397 / 2**(52 + 3)
```
我们需要将 `2702159776422298` 和 `3602879701896397` 相加：
```
>>> 2702159776422298  + 3602879701896397
6305039478318695
```
棒。但是 `6305039478318695` 比 `2**52-1`（尾数的最大值）大，问题来了:
```
>>> 6305039478318695 > 2**52
True
```
#### 第四步：增加指数
目前结果是：
```
2**-3 + 6305039478318695 / 2**(52 + 3)
```
首先，它减去 2\*\*52：
```
2**-2 + 1801439850948199 / 2**(52 + 3)
```
完美，但最后的 `2**(52 + 3)` 需要改为 `2**(52 + 2)`。
我们需要将 `1801439850948199` 除以 2。这就是难题的地方 -- `1801439850948199` 是一个奇数!
```
>>> 1801439850948199  / 2
900719925474099.5
```
它正好在两个整数之间，所以我们四舍五入到最接近它的偶数（这是浮点运算规范要求的），所以最终的浮点结果是:
```
>>> 2**-2 + 900719925474100 / 2**(52 + 2)
0.30000000000000004
```
它就是我们预期的结果：
```
>>> 0.1 + 0.2
0.30000000000000004
```
#### 在硬件中它可能并不是这样工作的
在硬件中做浮点数加法，以上操作方式可能并不完全一模一样（例如，它并不是求解 “X”），我相信有很多有效的技巧，但我认为思想是类似的。
#### 打印浮点数是非常奇怪的
我们之前说过，浮点数 0.3 不等于 0.3。它实际上是:
```
>>> f"{0.3:.80f}"
'0.29999999999999998889776975374843459576368331909179687500000000000000000000000000'
```
但是当你打印它时，为什么会显示 `0.3`？
计算机实际上并没有打印出数字的精确值，而是打印出了*最短*的十进制数 `d`，其中 `f` 是最接近 `d` 的浮点数。
事实证明，有效做到这一点很不简单，有很多关于它的学术论文，比如 [快速且准确地打印浮点数](https://legacy.cs.indiana.edu/~dyb/pubs/FP-Printing-PLDI96.pdf)、[如何准确打印浮点数](https://lists.nongnu.org/archive/html/gcl-devel/2012-10/pdfkieTlklRzN.pdf) 等。
#### 如果计算机打印出浮点数的精确值，会不会更直观一些？
四舍五入到一个干净的十进制值很好，但在某种程度上，我觉得如果计算机只打印一个浮点数的精确值可能会更直观 -- 当你得到一个奇怪的结果时，它可能会让你看起来不那么惊讶。
对我来说，`0.1000000000000000055511151231257827021181583404541015625 + 0.200000000000000011102230246251565404236316680908203125 = 0.3000000000000000444089209850062616169452667236328125` 比 `0.1 + 0.2 = 0.30000000000000000004` 惊讶少一点。
这也许是一个坏主意，因为它肯定会占用大量的屏幕空间。
#### PHP 快速说明
有人在评论中指出在 PHP 中 `` 会输出 `0.3`，这是否说明在 PHP 中浮点运算不一样？
非也 —— 我在 [这里](https://replit.com/languages/php_cli) 运行:
``，得到了与 Python 完全相同的答案：5.5511151231258E-17。因此，浮点运算的基本原理是一样的。
我认为在 PHP 中 `0.1 + 0.2` 输出 `0.3` 的原因是 PHP 显示浮点数的算法没有 Python 精确 —— 即使这个数字不是最接近 0.3 的浮点数，它也会显示 `0.3`。
#### 总结
我有点怀疑是否有人能耐心完成以上所有些算术，但它写出来对我很有帮助，所以我还是发表了这篇文章，希望它能有所帮助。
*（题图：MJ/53e9a241-14c6-4dc7-87d0-f9801cd2d7ab）*
---
via: 
作者：[Julia Evans](https://jvns.ca/) 选题：[lkxed](https://github.com/lkxed/) 译者：[MjSeven](https://github.com/MjSeven) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出