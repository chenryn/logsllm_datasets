act dishonestly in order to alter the credentials they receive.
In each game, we remove one of these opportunities for dishonest
action and show that the resulting game is indistinguishable from
the previous game to an efficient adversary. This means that in
the final game, the adversary has no opportunity to create fake
credentials, and so cannot win the game.
1, ğµ2/ğµâ„
1 , ğ¶2/ğ¶â„
G3: After extracting the attributes ğ‘€, ğ¸1, ğ¸2 as described in G2,
We present the games below.
G0: This game is identical to the standard ğ‘¢ğ‘›ğ¹ğ‘‚ğ‘…ğºğ¸ game.
G1: This game is identical to the ğ‘¢ğ‘›ğ¹ğ‘‚ğ‘…ğºğ¸ game, but we add
a set Mğ‘€ğ´ğ¶, that keeps track of all attributes that the plat-
form has issued a MAC on. To do this, we modify the re-
ceiving interaction so that when a proof ğœ‹ provided by the
receiver is verified by the platform, we run the knowledge
extractor to extract witnesses (â„, ğ‘Ÿ1, ğ‘Ÿ2, ğ‘Ÿ3, ğ‘Ÿğ‘›ğ‘‘, ğ‘‘ğ´, ğ‘§ğ´, ğ‘‘ğ¹ , ğ‘§ğ¹ )
and abort if extraction fails. We use these witnesses to de-
crypt (ğ´1, ğ´2), (ğµ1, ğµ2), (ğ¶1, ğ¶2) to get attributes ğ‘€, ğ¸1, ğ¸2,
i.e. ğ´2/ğ´â„
1 , respectively. We then add (ğ‘€, ğ¸1, ğ¸2)
to Mğ‘€ğ´ğ¶. The extractor fails with negligible probability, so
this game is indistinguishable from Game 0.
G2: We further modify so that every time a message is sent or
reported, if the proof output by present verifies, we again run
the proof of knowledge extractor on the MAC presentation
proof ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡ to extract attributes ğ‘€, ğ¸1, and ğ¸2 and abort if
extraction fails. Once again, failure happens with negligible
probability and this is indistinguishable from G1.
we immediately abort if (ğ‘€, ğ¸1, ğ¸2) âˆ‰ Mğ‘€ğ´ğ¶.
If the game aborts due to the above reason, it means that the
user proved ownership of a MAC that the platform never
created. (Note that weâ€™re not requiring that the attributes be
in any way correct at this stage, we are just looking directly
at the exact attributes of the MACs that the platform created
and comparing them to the attributes that the adversary tries
to prove it has. This can happen with negligible probability
due to the unforgeability of the anonymous credentials of
[5], and therefore G3 is indistinguishable from G2.
In this next game, every time an individual presents a valid
receiving proof to the platform, we run the extractor to
get witnesses â„, ğ‘Ÿ1, ğ‘Ÿ2, ğ‘Ÿ3, ğ‘Ÿğ‘›ğ‘‘, ğ‘‘ğ´, ğ‘§ğ´, ğ‘‘ğ¹ , ğ‘§ğ¹ . We immediately
abort if the extractor fails. By the extractability of the proof
system, a valid proof fails extraction with negligible prob-
ability and so this game is indistinguishable to the forgery
adversary. On success, we are guaranteed that the properties
included in the proof are guaranteed to hold, i.e. that ğ‘ƒ1 âˆ§ ğ‘ƒğ´
or ğ‘ƒ1 âˆ§ ğ‘ƒğ¹ as described in Figure 5 is satisfied.
We also note that by this check, if ğ‘ƒ1 âˆ§ ğ‘ƒğ´ holds, then we
are guaranteed that:
G4:
ğ´1, ğ´2 = ğºğ‘Ÿ1, ğ»ğ‘Ÿ1ğºğ‘‘ğ´
ğ‘‘
ğµ1, ğµ2 = ğºğ‘Ÿ2, ğ»ğ‘Ÿ2ğºğ‘Ÿğ‘›ğ‘‘ ğ¸(ğ´)
1
ğ¶1, ğ¶2 = ğºğ‘Ÿ3, ğ»ğ‘Ÿ3ğ‘Œ ğ‘Ÿğ‘›ğ‘‘ ğ¸(ğ´)
2
ğ¶ğ´ = ğºğ‘‘ğ´
ğ‘‘
ğ¶ğ‘‘ = ğºğ‘‘ğ¹
ğ‘‘
ğºğ‘§ğ´
ğ‘¦3
ğºğ‘§ğ¹
ğ‘¦3
So, the encryptions are valid encryptions of ğ‘‘ğ´ and a re-
randomization of (ğ¸1, ğ¸2) under public key ğ».
Similarly, if ğ‘ƒ1 âˆ§ ğ‘ƒğ¹ holds, then we are guaranteed that
ğ´1, ğ´2 = ğºğ‘Ÿ1, ğ»ğ‘Ÿ1ğºğ‘‘ğ¹
ğ‘‘
ğµ1, ğµ2 = ğºğ‘Ÿ2, ğ»ğ‘Ÿ2ğºğ‘Ÿğ‘›ğ‘‘ğ¶ğ¸1/ğºğ‘§ğ¹
ğ‘¦1 ğ¸1/ğºğ‘§ğ¹
ğ‘¦1
ğ‘¦1
= ğ»ğ‘Ÿ2ğºğ‘Ÿğ‘›ğ‘‘ğºğ‘§ğ¹
= ğ»ğ‘Ÿ2ğºğ‘Ÿğ‘›ğ‘‘ ğ¸1
ğ¶1, ğ¶2 = ğºğ‘Ÿ3, ğ»ğ‘Ÿ3ğ‘Œ ğ‘Ÿğ‘›ğ‘‘ğ¶ğ¸2/ğºğ‘§ğ¹
ğ‘¦2 ğ¸2/ğºğ‘§ğ¹
ğ‘¦2
ğ‘¦2
= ğ»ğ‘Ÿ3ğ‘Œ ğ‘Ÿğ‘›ğ‘‘ğºğ‘§ğ¹
= ğ»ğ‘Ÿ3ğ‘Œ ğ‘Ÿğ‘›ğ‘‘ ğ¸2
ğ¶ğ‘‘ = ğºğ‘‘ğ¹
ğ‘‘
ğ¶ğ´ = ğºğ‘‘ğ´
ğ‘‘
ğºğ‘§ğ¹
ğ‘¦3
ğºğ‘§ğ´
ğ‘¦3
G5:
ğ‘‘
, ğ¶â€²
ğ¸1
So, this guarantees that in the forwarded case, the encrypted
values must be an encryption of ğ‘‘ğ¹ and a re-randomization
of (ğ¸1, ğ¸2), where (ğ‘§ğ¹ , ğ‘‘ğ¹ , ğ¸1, ğ¸2) is a valid opening for the
commitment ğ¶ğ¹ .
In this game, we check the sending/reporting proofs in the
interaction. When given valid ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡ and ğœ‹ğ‘Ÿğ‘’ğ‘Ÿğ‘ğ‘›ğ‘‘ proofs
associated with commitments ğ¶ğ¹ = (ğ¶ğ‘‘, ğ¶ğ¸1, ğ¶ğ¸2) and ğ¶â€²
ğ¹ =
(ğ¶â€²
, ğ¶â€²
ğ¸2), we apply the proof extractor to extract the
witnesses (ğ‘§â€², ğ‘Ÿğ‘›ğ‘‘) from ğœ‹ğ‘Ÿğ‘’ğ‘Ÿğ‘ğ‘›ğ‘‘, aborting on failure. By the
strong extractability property, this extraction fails with only
negligible probability and otherwise we are guaranteed that
the statement in ğœ‹ğ‘Ÿğ‘’ğ‘Ÿğ‘ğ‘›ğ‘‘ holds true for the provided values
of ğ¶ğ¹ and ğ¶â€²
ğ¹ .
Moreover, this guarantees that if (ğ‘§, ğ‘‘, ğ¸1, ğ¸2) is the open-
ing of ğ¶ğ¹ extracted from the associated presentation proof
ğœ‹ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘’ğ‘›ğ‘¡, then we must have
ğ‘¦3 = ğºğ‘§+ğ‘§â€²
ğ¶â€²
ğ‘‘ = ğ¶ğ‘‘ğºğ‘§â€²
ğ‘¦3 ğºğ‘‘
ğ‘‘
ğ¶â€²
ğ‘¦1ğºğ‘Ÿğ‘›ğ‘‘ğ¶ğ¸1 = ğºğ‘§+ğ‘§â€²
ğ¸1 = ğºğ‘§â€²
ğ‘¦1 ğºğ‘Ÿğ‘›ğ‘‘ ğ¸1
ğ‘¦2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘ğ¶ğ¸2 = ğºğ‘§+ğ‘§â€²
ğ¶â€²
ğ¸2 = ğºğ‘§â€²
ğ‘¦2 ğ‘Œ ğ‘Ÿğ‘›ğ‘‘ ğ¸2
and so (ğ‘§ + ğ‘§â€², ğ‘‘, ğ¸1ğºğ‘Ÿğ‘›ğ‘‘, ğ¸2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘) must be a valid opening
for ğ¶â€²
ğ¹ .
By the requirements of Game 3, the sending user must have
had a valid MAC on (ğ‘‘, ğ¸1, ğ¸2), and so this ensures that the
opening ğ¶â€²
ğ¹ must be a re-randomization of attributes that
the user has a valid MAC for.
G6: We have shown that the attributes used to prove and create
MACs must be internally consistent (within a send/receive
operation), but we now show that they need to consistent
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1505Because the decryption ğ¸2ğ‘Œ ğ‘Ÿ/(ğ¸1ğºğ‘Ÿ)ğ‘¦ will be constant for any
value of ğ‘Ÿ, we can trace back through these extracted receipts to the
first time a MAC on attributes (ğ‘‘, ğ¸1, ğ¸2) was created. This must
either have been the result of a call to goodAuth or malSend. If it
was from malSend, then the sender wasnâ€™t an honest user, and so
such attributes cannot be used to win the forgeability game.
Otherwise, if it was in goodAuth, then the tuple must have been
added to Mğ‘ ğ‘’ğ‘›ğ‘¡, and so similarly canâ€™t be used to win the game.
Therefore, we have shown that there is no way for the adversary
to win Game 9. Because we showed that Game 9 was indistinguish-
able from the ğ‘¢ğ‘›ğ¹ğ‘‚ğ‘…ğºğ¸ game. We can conclude that any efficient
adversary will have negligible advantage against ğ‘¢ğ‘›ğ¹ğ‘‚ğ‘…ğºğ¸, and
therefore Scheme 2 is unforgeable.
â–¡
C.4 Deniability â€“ Proof of Theorem 5.4
Proof. As in the first scheme, the complete proof that this
scheme satisfies the deniability requirements of a secure source-
tracking scheme appears in the full version of this paper.
â–¡
across transactions too. Let G4 be identical to G3 except
for the modification that every time we have a valid pair
of sending proofs ğœ‹ğ‘ and ğœ‹ğ‘Ÿ , we extract the opening (ğ‘§ +
ğ‘§â€², ğ‘‘, ğ¸1ğºğ‘Ÿğ‘›ğ‘‘, ğ¸2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘) of ğ¶â€²
ğ¹ from the sending proof In the
same manner as G3. Then, during the corresponding receiv-
ing proof that uses the same ğ¶â€²
ğ¹ and some arbitrary ğ¶ğ´, we
once again extract the witnesses (â„, ğ‘Ÿ1, ğ‘Ÿ2, ğ‘Ÿ3, ğ‘Ÿğ‘›ğ‘‘, ğ‘‘ğ´, ğ‘§ğ´, ğ‘‘ğ¹ , ğ‘§ğ¹),
aborting on failure. By the extractability of the proof system,
extraction fails with negligible probability, making this game
indistinguishable from G5.
G7: We modify G6 so that after extracting the above witnesses,
we use them to compute the new opening (ğ‘§ğ¹ , ğ‘‘ğ¹ , ğ¸â€²
1 =
ğ¶ğ¸1/ğºğ‘§ğ¹
We abort if these openings are not the same, i.e. if (ğ‘§ +
ğ‘§â€², ğ‘‘, ğ¸1ğºğ‘Ÿğ‘›ğ‘‘, ğ¸2ğ‘Œ ğ‘Ÿğ‘›ğ‘‘) â‰  (ğ‘§ğ¹ , ğ‘‘ğ¹ , ğ¸â€²
We first note that ğ¸â€²
2 are completely determined by
the value of ğ‘§ğ¹ , so it suffices to show that we must have
(ğ‘§+ğ‘§â€², ğ‘‘) = (ğ‘§ğ¹ , ğ‘‘ğ¹). If this is not the case, this means that the
adversary was able to find distinct pairs (ğ‘§1, ğ‘‘1) and (ğ‘§2, ğ‘‘2)
such that ğºğ‘§1
however, this implies that the
adversary knows the discrete log of ğºğ‘¦3 with respect to ğºğ‘‘
or vice versa, both of which we assume are unknown, so we
conclude that finding two such pairs will happen with only
negligible probability, and so the game is indistinguishable
from G6.
2 = ğ¶ğ¸2/ğºğ‘§ğ¹
ğ‘¦2 .
1 and ğ¸â€²
ğ‘‘ = ğºğ‘§2
1, ğ¸â€²
2).
ğ‘¦1 , ğ¸â€²
ğ‘¦3ğºğ‘‘1
ğ‘¦3ğºğ‘‘2
ğ‘‘
G8: We just showed that the openings of the forwarding commit-
ment created by the sender canâ€™t be changed by the receiver.
We will now do the same for authoring commitments. We
note that for authoring commitments, the source encryption
is chosen by the platform and verified in the clear, so we
need only ensure that the message stored in ğ¶ğ´ created by
an honest sender stays constant.
We modify G7 by adding the requirement that each time
goodAuth or goodFwd is called, we save the message ğ‘š
(which could be âŠ¥) that is associated with the authoring
commitment ğ¶ğ´ that gets presented to the platform. Then, if
the receiving proof verifies, we extract witnesses ğ‘§ğ´ and ğ‘‘ğ´
from the proof, aborting if the extraction fails. This happens
with negligible probability, so this game is indistinguishable
from G7.
ğ»(ğ‘š) â‰  ğ‘‘ğ´.
As before, if this is the case, then after being provided a valid
opening (ğ‘§, ğ‘‘) by the honest sender, the adversary found
some new (ğ‘§ğ´, ğ‘‘ğ´) such that ğºğ‘§
. By the same
reasoning as the previous game, this can be achieved only
with negligible probability, and therefore this new game is
indistinguishable from G4 to an efficient adversary.
G9: After extracting witnesses ğ‘§ğ´ and ğ‘‘ğ´ in G8, we abort if
ğ‘‘ = ğºğ‘§ğ´
ğ‘¦3 ğºğ‘‘ğ´
ğ‘‘
ğ‘¦3ğºğ‘‘
By the definition of G9, we know that if a message is success-
fully sent or reported with attributes ğ‘‘, ğ¸1, ğ¸2, then either the ad-
versary must have previously received a message with attributes
ğ‘‘, ğ¸1ğºğ‘Ÿ , ğ¸2ğ‘Œ ğ‘Ÿ for some random ğ‘Ÿ, or in the case of sending, (ğ¸1, ğ¸2)
must decrypt to the senderâ€™s identity. (If the attributes came from
an unused forwarding or authoring commitment, we would have
ğ‘‘ = âŠ¥ and the protocol would automatically fail).
Session 5C: Messaging and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea1506