to the classical single-tenant POR when only one user is
present, we do not integrate such a protocol into the model.
The POR Protocol. The aim of the POR protocol
is to allow a user (or a veriﬁer) to check if the ﬁle is
still entirely stored at the provider. To this end, the user
uses his personal keys and the veriﬁcation key to verify the
response sent by the provider; the latter uses the public key
of the user, the uploaded ﬁle, and the metadata to issue the
response to the user. At the end, the user outputs a Boolean
value dec ∈ {TRUE, FALSE}. Formally, we have:
POR :
[U : skU, pkU, vkU; S : pkU, M, Data(M )]
−→ [U : vkU, dec].
The protocol run is accepted by the user if and only if
dec = TRUE. Unlike the Store protocol, we point out that
metadata maintained by the provider is not modiﬁed in this
protocol. However, it may be the case that the user has to
update his veriﬁcation key vkU—which explains the reason
why this is part of the local output.
Adopting common terminology, we say that an MTPOR
is publicly-veriﬁable if the POR-protocol does not require
the secret key skU of the user. In such cases, veriﬁcation
can be outsourced to a third party veriﬁer V. Otherwise, an
MTPOR is said to be privately-veriﬁable.
2.3. Correctness
We consider correctness from the perspective of the
provider and the user. From the former perspective, it is
necessary to ensure that if two honest users initiate Store
with the same ﬁle (cid:102)M, then during the protocol run the
same ﬁle M is outsourced. This notion ensures correct and
effective whole-ﬁle deduplication.
From a user’s perspective, correctness intuitively means
that if an honest user U uploaded a ﬁle to an honest provider
S and later on runs the POR protocol, the user should
accept. For a formal treatment though, one needs to take
into account that in the time lapse between the ﬁle upload
by a user U and the execution of the POR procedure, the
provider may have executed other Store protocol runs (i.e.,
with another user U(cid:48)) which may have changed the metadata.
For example, while the ﬁle M would not be stored a second
time, information about U(cid:48) would be integrated into the
metadata Data(M ). Still, the POR protocol executed by
U afterwards should be successful although Data(M ) has
changed from the initial Store performed by U. We stress that
this property has to hold even if some tenants are malicious,
e.g., deviate from the protocol, as long as both U and S are
honest. We capture this formally by saying that the new
content of Data(M ) evolved from the last known metadata
that has been generated when U executed Store.
Deﬁnition 1 (Evolvable Metadata). For a key pair (sk, pk),
(cid:48), we denote
a ﬁle M, and two metadata Data, Data
(cid:48)
by E = E(sk, pk, M, Data, Data
) the event that when
running Store with inputs sk, pk, M on the user side
and input Data on the provider side where the provider
behaves honestly, the metadata with respect to M is
(cid:48). We say that Data
(cid:48) is evolvable from
updated to Data
Data with respect to (sk, pk, M ) if:
Pr(cid:2)E(sk, pk, M, Data, Data
(2)
This captures that the metadata Data may be possibly
(cid:48) while running Store for a ﬁle M with
updated to Data
keys (sk, pk). We express this by:
)(cid:3) > 0.
(cid:48)
Data
(sk,pk,M )−→ Data
(cid:48)
.
(3)
Moreover, we extend this notion to the case where one
metadata may be evolved from another metadata also
after running Store multiple times. That is, we write
Data M⇒ Data
(cid:48) if there exists metadata Data1, . . . , Data(cid:96)
and key pairs (sk1, pk1), . . . , (sk(cid:96), pk(cid:96)) such that:
• Data
• Datai
• Data(cid:96)
Datai+1 for i = 1, . . . , (cid:96) − 1
(cid:48)
Data
−→ Data1
−→
−→
(sk(cid:96)+1,pk(cid:96)+1,M )
(ski+1,pki+1,M )
(sk1,pk1,M )
In this case, we likewise say that Data
(cid:48) is evolvable from
Data. Finally, we say that a metadata Data is M-
evolvable if ⊥ M⇒ Data. Recall that the metadata is
initially set to ⊥. Hence, this notion expresses that Data
could be a possible metadata resulting from multiple
executions of Store for the same ﬁle M.
Note that the deﬁnition of evolvable metadata refers to
the ﬁle M as seen by S (i.e., after the user has uploaded it to
the cloud). We are now ready to give the formal deﬁnition
for correctness of a MTPOR.
Deﬁnition 2 (Correctness). An MTPOR scheme is correct
if the following holds with overwhelming probability in
the security parameter for any key pairs (sk, pk), any
ﬁle M, and any M-evolvable metadata Data.
Consider a Store execution with the above mentioned
(cid:48). Then, it holds
inputs and the outputs vk and Data
(cid:48)(cid:48), and any
for any metadata Data
protocol execution of POR with inputs sk, pk, vk (user
(cid:48)(cid:48) (provider side), the user accepts at
side) and M, Data
the end of the protocol run.
(cid:48)(cid:48) with Data
(cid:48) M⇒ Data
2.4. Security
the conﬁdentiality of the ﬁle (cid:102)M,
MTPOR exhibits similar security considerations as in
the case of single-tenant POR. Recall that the purpose of
executing a POR or an MTPOR is to allow users to verify
whether the ﬁle is still entirely stored by the provider.
Consequently, we do not consider in this paper other security
to ensure
goals besides data retrievability. For example,
the user can encrypt
the ﬁle during the Store protocol by leveraging message-
locked encryption using a key derived from the ﬁle contents
such as [6], [10]. We also do not take into account any
privacy leakage resulting from the use of deduplication [24].
More speciﬁcally, we assume that the cloud storage employs
Proofs of Ownership [23] in order to ensure that tenants
indeed possess the ﬁles.
In a nutshell, our attacker model concentrates on a
dishonest provider A who aims to mislead the user by storing
few (or no) parts of the ﬁle but still tries to pass the POR
protocol. Hence, security can be captured by a similar notion
as in single-tenant POR, i.e., using the notion of an extractor.
Recall that an extractor algorithm expresses the notion that
if a provider is able to convince a user within the POR
protocol, one can extract the ﬁle from the provider.
However, as opposed to the case of single-tenant POR,
we have to consider a stronger attacker model where A might
collude with one or several tenants. We call such tenants
corrupted. Corrupted tenants are under the full control of
the attacker. In particular, the attacker knows all their keys,
including the veriﬁcation key.
To formalize security, we envision a game between
an adversary A and an environment E. The task of the
environment is to play the role of all honest users and to
challenge the adversary. That is, whenever we say that an
honest user executes a certain protocol, we mean that the
environment honestly executes the protocol on behalf of this
user. However, we allow the attacker to initiate protocol runs
by honest users at her wish. To keep track of all honest
users, we assume that the environment maintains a set U.
The adversary can now interact with the environment using
four types of queries: a Setup-query, a Store-query, a POR-
query, and a Corrupt-query.
In a Setup-query, a new honest user U is created. That is,
the environment generates a key pair (skU, pkU) and stores a
quadruple (U, skU, pkU, VKU) in U. The ﬁrst entry identiﬁes
the user, the following two entries give the keys of the user,
while VKU represents the set of veriﬁcation keys stored by
the user—each per ﬁle stored by U. Initially, VKU is set to
∅. In addition, we assume that the environment hands the
public key to the adversary.
In a Store-query, the adversary presents a user U and a
ﬁle M to the environment E. The environment stores for
each ﬁle M that has been part of a Store-request a set
Users(M ) that contains the set of users that have executed
Store with the attacker for the ﬁle M. Upon receiving a
Store-query, the environment proceeds as follows:
• If the user has not been created before (in terms of a
Setup-request) or if the user is corrupted, the environ-
ment aborts the game. This is equivalent to checking
if some quadruple (U, skU, pkU, VKU) is stored in U.
• The environment executes on behalf of the user the
Store protocol with the adversary, using the key pair
skU, pkU and the ﬁle M as input. Let vkU denote the
output for the user. If the set VKU of veriﬁcation keys
(cid:48)
U),
stored for user U already contains a tuple (M, vk
this tuple is replaced by (M, vkU). This reﬂects the
case that an honest user runs Store again for the same
ﬁle. Otherwise, VKU is updated to VKU ← VKU ∪
{(M, vkU)} and the quadruple stored in U is updated
accordingly.
• Finally, the environment stores U in Users(M ) if this
is not the case already.
Observe that this captures the situation where the adversary
runs the Store protocol for a given ﬁle with an honest user.
As he can simulate the protocol with a corrupted user on
his own, we do not need a separate oracle query for this
case. Similarly, corrupted users do not need to be stored in
U—see also below.
In a POR-query, the attacker A gives a user U and a ﬁle
M to E. The environment ﬁrst checks if U is recorded in
Users(M ) and if a quadruple (id, skU, pkU, VKU) is stored
in U. If this is not the case, E aborts. Otherwise, it executes
on behalf of U the POR-protocol with A, using the values
skU, pkU, vkU as input such that (M, vkU) ∈ VKU. The
purpose of this query is to allow the attacker to execute
the POR-protocol with an honest user of its choice. Also
here, POR executions with corrupted users can be simulated
by A and hence do not require any interaction with the
environment.
Finally, in a Corrupt-query, the attacker A hands a user
U to E. If the user is not recorded in U,
it aborts the
game. Otherwise, it locates the corresponding quadruple
(id, skU, pkU, VKU) ∈ U and hands the secret key skU and the
set of veriﬁcation keys VKU to the attacker. Furthermore, it
removes the quadruple from U, indicating that U is no longer
honest.
The attacker is allowed to make a polynomial number of
queries (i.e., polynomial in the security parameter λ). We say
that the attacker is static if he makes no Corrupt-queries and
adaptive otherwise. Notice that a static adversary can still
collude with corrupted users but these are under the control
of the attacker right from the start. That is, the attacker can
create both honest and corrupted users but cannot corrupt
honest users. Eventually, the attacker quits the game by
selecting a ﬁle M, an honest user U that is recorded in
Users(M ), and by providing the description of a cheating
prover P. Observe that the attacker cannot quit if no honest
user is present at this point in time.
From this point on, the deﬁnitions are analogous to
the standard POR deﬁnitions [32]. Namely, we say that a
cheating prover P is ε-admissible if in an ε fraction of POR
runs with U, this user accepts at the end of the protocol.
Here, the probability is over the coins of the user and the
prover.
Deﬁnition 3 (Soundness). We say a MTPOR is ε-sound if
there exists an efﬁcient extraction algorithm Extr such
that, for every adversary A, whenever A executes the
game explained above, outputs a ε-admissible cheating
prover P for a ﬁle M and a user U,
the extraction
algorithm recovers M from P except with negligible
probability. We say that it is strongly ε-sound if this
property holds in the presence of an adaptive attacker.
2.5. Tag Sharing
Within our model, we distinguish between two types of
data that are stored by the provider: the uploaded ﬁles and
associated metadata. The crucial aspect of multi-tenant POR
lies in the deduplication of the ﬁles, meaning that duplicate
ﬁles/objects are stored only once. For generality purposes,
multi-tenant POR, however, does not make any speciﬁc
assumptions about the storage of the associated metadata.
In fact, a trivial instantiation of multi-tenant POR would
be that the metadata Data(M ) is simply a collection of the
user data for all users U ∈ Users(M ) that are registered
for this ﬁle M and the respective ﬁle tags τU as outlined
for single-tenant PORs (cf. Sec. 2.1). Here, each tenant U
constructs his own tags τU using his own secret material;
that is, only the ﬁle is deduplicated, but the tags are stored
separately for each user. While this approach would resist
against malicious tenants, its storage overhead is essentially
the number of tags times the number of users (cf. Figure 1).
In this section, we address this problem and introduce
the deﬁnition of tag sharing. The overall goal of tag sharing
is to enable storage efﬁciency with respect to the storage
of that tags. To motivate the deﬁnition, observe that the
size |Data(M )| of the metadata can be expressed as a
function of two parameters2: the size |M| of M, and the
number k of users registered to the ﬁle. For example, a
straightforward realization of MTPOR based on a single-
tenant POR consists of storing the ﬁle only once but storing
the tags separately for each user. In this case, it would
hold that |Data(M )| ∈ O(k · |M|). That is, the number
of users and the ﬁle size are directly coupled in the storage
complexity. The goal of tag sharing is to make the storage
consumed for storing the tags independent of the number of
users. We capture this as follows.
Deﬁnition 4 (Tag Sharing MTPOR). We say that an MT-
POR achieves tag sharing if it holds for all ﬁles M (with
their respective number of users k) and the maintained
metadata, that its size can be expressed by
|Data(M )| = f (|M|) + g(k)
(4)
for some function f and g. We denote by Data =
(Dataﬁle, Datausers) the splitting of the metadata such
that |Dataﬁle| = f (|M|) and |Datausers| = g(k).
We stress at this stage that the storage efforts induced by
the number of users and the ﬁle size, respectively, are
decoupled. Notice that we make no assumptions on the
functions f and g—for instance, g could be a constant
function.
Next, we highlight an intrinsic property of the Store
protocol that holds in a tag sharing MTPOR. Recall that
in a tag sharing MTPOR, the size of Dataﬁle is f (|M|) and
is therefore independent of the number of users. Hence, even
if the number k of users that upload this ﬁle continuously
increases, the size of Dataﬁle is bounded by a function that
solely depends on |M|. This means that, after a certain
number of uploads, the information stored in Dataﬁle may
still change when Store is executed but the size will no
∗:
longer increase. We denote this variant of Store as Store
Deﬁnition 5. In a tag sharing MTPOR, we refer to the
variant of the Store protocol where the Dataﬁle part