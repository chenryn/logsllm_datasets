---
tags: ['计算机', '编译原理']
---
# 优化程序性能
编写高效程序需要注意的：
- 合适的算法与数据结构
- 编写出能让编译器转换为高效机器代码的源代码
## 编译器优化的能力和局限性
gcc中指定优化级别的参数有：-O0、-O1、-O2、-O3、-Og、-Os、-Ofast
- 0 为没有任何优化
- -O1、-O2、-O3 中，随着数字变大，代码的优化程度也越高, 是以牺牲程序的可调试性为代价的
- -Os 是在 -O2 的基础上，去掉了那些会导致最终可执行程序增大的优化
- -Ofast 是在 -O3 的基础上，添加了一些非常规优化，这些优化是通过打破一些国际标准（比如一些数学函数的实现标准）来实现的
在执行优化的过程，编译期所考虑的是必须执行安全的优化，所以必须考虑所有的情况，这样优化的选择就比较少了
如内存别名，看似优化能减少几次内存读写成本，但如果两个指针都指向同一块内存，那么看似可以优化的操作就会导致程序结果执行出错
```c
// 如果x与y都指向同一块内存
void func(int *x, int *y) {
    *x += *y;
    *x += *y;
}
// 那么如果编译期将代码优化成这样, 程序的执行结果就错了
void func(int *x, int *y) {
    *x += 2 * *y;
}
```
对于函数内联优化，也就是将原本的函数调用提取出来，将代码展开到调用处，不仅可以减少函数调用成本，同时展开之后也方便做其他优化, 这种优化方式在JVM的[后端编译优化](/编程语言/JAVA/JVM/后端编译与优化.md#方法内联)中也得到了较好的执行
内存的读写成本大概是在百纳秒这个级别，而函数的调用成本不仅需要将内存中的帧指针移位到堆栈上,并在其上添加新帧.函数参数被移入本地寄存器以供使用,并且堆栈指针被前进到堆栈的新顶部以执行该函数，需要多条指令来完成，这还只是针对C的函数调用，像OOP语言多态的虚方法之类的东西，调用之前需要进行查表，或者Java语言这种动态方法调用，需要做的事更多，过程调用不仅带来了开销，同时也会妨碍大多数的优化
## 表示程序性能
- 每元素周期数(CPE)
也就是执行的CPU周期数
### 循环展开
通过诸如循环展开等的优化方法，可以使得用更少的循环完成计算
```c
// 未展开前
for (i = 1; i  b[i]) {
        int t = a[i];
        a[i] = b[i];
        b[i] = a[i];
    }
}
// 条件传送码
for(int i = 0; i < n; i++) {
    int min = a[i] < b[i]? a[i]: b[i];
    int max = a[i] < b[i]? a[i]: b[i];
    a[i] = min;
    b[i] = max;
}
```
## 理解内存性能
- 加载性能：内存读操作是有依赖的，所以会受限于其他的读操作或者写操作
- 存储性能：单纯的写是没有依赖的，可以很快，但是如果有写-读依赖，也会受限
## 应用：性能提高技术
### 高级设计：[算法与数据结构](/算法与数据结构/算法与数据结构.md)
### 基本编码原则
- 消除连续的函数调用
- 消除不必要的内存引用：使用临时变量保存中间结果，避免频繁读写数组或者全局变量
### 低级优化
- 循环展开
- 多个累积变量与重新结合, 提升指令并行程度
- 使得编译采用条件数据传送
## 确认和消除性能瓶颈
- gprof