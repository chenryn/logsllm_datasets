transactions that include setup and out/status.
III. METHODOLOGY
This work is inspired by the advent of non-intrusive, high-
speed USB protocol analyzers. These tools passively intercept
individual packets in order to reconstruct USB traces at the
logical layer. Developers are able to use this information to
detect errors at different levels of the USB stack as well as
measure performance [22]. Unfortunately, these devices are
costly, reaching into the thousands of dollars. In this study,
we worked with a USB analyzer that weighed 1.65 pounds
with 6x5x2.5 inch dimensions, hampering its portability and
adoptability. In order to inspect the results of the USB trace,
users must also plug the USB analyzer into another PC with
specialized software. Additionally, it is difﬁcult to collect large
numbers of USB traces, as manual unplugging and reinsertion
of the device is required.
This section is structured as follows: in Section III-A we
present a threat model for our scheme; in Section III-B we
compare the performance of an industry-class USB protocol
analyzer with our own Android-based device; in Section III-C
we detail our data collection procedure; in Section III-D we
discuss the contents of our corpus of collected data; in Section
III-E we describe our feature extraction procedures; and in
Section III-F we offer insights into how these features can be
used to identify hosts.
A. Threat Model
We assume that an adversary has the ability to arbitrarily
control the software of the host system being ﬁngerprinted,
and has ownership of the kernel. We assume that the adversary
thus has the ability to modify the USB device driver and to
modify USB messages returned from the host. Additionally,
such ownership allows the host to arbitrarily relay messages
to a different computer through a network interface,
thus
allowing the bypass of the LPC bus where the TPM resides,
and other peripherals. We assume that the attacker has the
ability to physically access the host machine and to tamper
with it; however, we assume that
the initial collection of
measurements is performed on an uncompromised machine.
We do not assume the use of wireless USB on the system. We
further analyze the security of the scheme and its potential
limitations in Section VI-B.
Host
Client
USB
System
USB Bus 
Interface
Device
Function
USB
Device
USB Bus 
Interface
Android 
Application
Ellysis USB
Explorer
Logical Communications Flow
Physical Communications Flow
Control Transfer
GetDescriptor (Device)
SetAddress (121)
GetDescriptor (Device)
GetDescriptor (Conﬁguration)
GetDescriptor (Conﬁguration)
GetDescriptor (String: Language)
GetDescriptor (String: Product)
GetDescriptor (String: Manufacturer)
GetDescriptor (String: Serial Number)
SetConﬁguration
GetDescriptor (String: Interface)
ClearFeature (Endpoint 1 IN)
ClearFeature (Endpoint 2 OUT)
ClearFeature (Endpoint 1 IN)
GetDescriptor (String: Language)
GetDescriptor (String: Serial Number)
Android (sec)
0
N/R
0.132 202
0.132 508
0.132 782
0.133 057
0.133 423
0.133 698
0.134 003
0.134 491
0.134 918
N/R
N/R
N/R
1.135 742
1.136 048
Ellisys (sec)
0
0.111 992 200
0.131 983 683
0.132 773 683
0.132 890 216
0.133 015 483
0.133 257 716
0.133 390 216
0.133 508 250
0.133 803 183
0.134 272 716
0.165 663 866
0.166 395 233
0.167 016 066
1.134 755 000
1.135 822 016
Fig. 3: USB communications model. We observed physical
communications via an Ellisys USB Explorer to conﬁrm the
correctness of an Android-based protocol analyzer.
TABLE I: Enumeration on a Linux host. The Ellysis USB Ex-
plorer conﬁrms the approximated timing information captured
by our application in the Android kernel. N/R denotes events
that were not recorded by our device.
B. Hardware USB Analyzer
Our approach to machine ﬁngerprinting begins with the
observation that lightweight devices with USB interfaces are
now ubiquitous, to the point that many of us carry multiple
USB devices on our person throughout the day. Smart phones
charge and physically connect to other machines with USB,
and USB ﬂash drives are a ﬁxture of key chains and briefcases
in many work environments. Even certain USB drives, such
as Imation’s IronKey [23], now come equipped with on-board
CPUs that provide additional security and usability features.
As we developed our own protocol analyzer device, we
used the Ellisys USB Explorer 200 [22] to establish a ground
truth for USB observation. Figure 3 visualizes the Ellisys
explorer’s ideal vantage point in the USB communications
model; by physically intercepting packets as they traverse the
wire, Ellisys can obtain highly precise timing information and
perfectly reconstruct traces. This performance comes at the
cost of usability. Figure 3 also depicts the vantage point of
our own USB collection mechanism, an Android smartphone
application that intercepts messages at the device controller
driver level. By routing our own device through the USB
analyzer, we were able to conﬁrm the correct behavior of
our Android application. Using Ellisys software, we were able
to map the timing data of our observed USB enumeration
recordings to the actual serial bus activity. A representative
mapping between Android and Ellisys data is shown in Table
I. This assured the proper functionality of our USB collection
application, allowing us to move forward with data collection.
C. Smartphone Collection
To avoid using costly and exotic hardware, we developed
a USB analyzer for a device that many users already own,
namely an Android smartphone. The timing data measurable
from the device’s userspace USB function proved too coarse-
grained, so we resorted to accessing kernel memory through
rooting the phone. We used kprobe modules to dynamically al-
ter musb gadget ep0.c (forward to driver, musb g ep0 irq)
and android.c (android setup). With these modiﬁcations in-
stalled, we were able to capture individual IRQs with microsec-
ond timing. We were also able to force calls to usb disconnect
after each enumeration, thereby automating the process of
recording multiple traces on a target host. This allowed us
to collect the individual transactions that constitute the full
enumeration process. While the need to root the device is
a limitation to our approach, we note that the installation of
aftermarket open-source ﬁrmware for Android devices is now a
simple process thanks to communities like CyanogenMod [24].
Moreover, when ﬁnished collecting data, the kprobe modules
are automatically uninstalled, allowing the phone to resume
the standard USB behaviors of a stock Android device.
To ensure consistent behavior across a variety of hosts and
devices, we chose to collect timestamps from all transactions’
IRQs, but the data payloads of only the setup IRQs. We found
that logging the contents of every IRQ required excessive
memory copying in atomic functions, consequently causing
USB enumeration to fail and the device’s kernel to panic.
Additionally, the setup transaction dictates the contents of sub-
sequent transactions within the control transfer. We concluded
that dumping the payloads of setup transactions alone would
offer sufﬁcient information to see the full context of enumer-
ation. We call the combination of transaction timestamps and
content captured over the course of enumeration a USB Trace.
Kernel-level buffering occurred whenever an IRQ’s times-
tamp was logged. The resulting average delay was 120 µs
compared to the serial bus activity observed via Ellisys. For
example, the delay between the ﬁrst and second IRQ in a
control
the log
showed as much as 150 µs delay, a 147 µs discrepancy.
Fortunately, at the end of each control transfer, there is a
pause of sufﬁcient length to permit the buffer time to fully
clear, thus resynchronizing with the serial bus. This gives us
accurate timing information for the setup transaction of every
control transfer, shown in Table I.
transfer is as short as a 3 µs. However,
Using the Android USB Analyzer application that we
explain in greater detail in Section VI-A, we were able to
automate collection of USB traces. The process for data
collection was as follows:
4
Class
OS
Model
Label
Host Count
Linux 3.2
OSX 10.6
OSX 10.7
OSX 10.8
Windows 7 SP1
256
8
2
15
49
182
256
27
5
25
8
2
2
23
3
32
6
34
43
4
5
32
5
256
32,150
TABLE II: Description of data corpus.
Apple iMac 10
Apple iMac 11
Apple iMac 12
Apple iMac 13
Apple Mac Mini 52
Dell Dimension 4700
Dell Latitude 6500
Dell Latitude 6510
Dell Optiplex 745
Dell Optiplex 760
Dell Optiplex 980
Dell Optiplex 990
Dell Optiplex gx520
Dell Optiplex sx280
Dell Precision t3500
Dell Precision t3600
TOTAL MACHINES INSPECTED:
TOTAL MEASUREMENTS COLLECTED:
1. Record target machine attributes in Android USB Analyzer
interface (e.g., serial number, OS, Manufacturer).
2. Hard reset the target machine.
3. Disconnect other USB devices from the target machine.
4. Plug the phone into the target machine.
5. Allow the Android USB Analyzer
automatically
enumerations.
application to
of USB
speciﬁed
number
collect
the
The procedure was meant to eliminate additional variables
that might inﬂuence the timing result. Determining the robust-
ness of the approach when the machine is potentially under
load, or identifying appropriate periods of machine quiescence,
is future work.
We elected to develop on Android due to the widespread
adoption of this platform. However, we note that our methodol-
ogy would be similarly effective using other collection devices.
For example, in preliminary tests we collected data using a
Gumstix device [10] running a Linux kernel that was modiﬁed
to record USB message timestamps. Using the Gumstix data,
we identiﬁed machines by OS and model with comparable
accuracy to our Android data corpus (see Section IV-B).
D. Data Corpus
Following the procedure described above, we performed
data collection on a variety of machines across a university
campus. In addition to 8 student-accessible computer labs, we
also obtained decommissioned machines from the university’s
IT department. Our dataset includes thousands of traces col-
lected from 6 Linux, 66 OSX, and 182 Windows hosts. The
corpus is described comprehensively in Table II. We collected
at least 50 enumeration traces from each machine, and col-
lected data from some machines multiple times, resulting in
5
(a) GetDescriptor (Serial)
(b) GetDescriptor (Language)
(c) GetDescriptor (Manufacturer)
(d) SetConﬁguration (1)
Fig. 4: Timing data for selected features by operating system.