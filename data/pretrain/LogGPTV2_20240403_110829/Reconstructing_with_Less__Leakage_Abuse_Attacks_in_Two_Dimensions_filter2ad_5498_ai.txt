â–¡
C.5 Proof of Lemma 5.3
Proof. Let ğ´0 be the set of IDs of points with height 0. We argue
that the height of ğ‘ âˆˆ ğ‘‰ is given by the maximum length of a path
from ğ‘ to ğ‘ over all ğ‘ âˆˆ ğ´0. Fix some ğ‘ âˆˆ ğ‘‰ and suppose that
the maximum length of any path from the vertices in ğ´0 to ğ‘ is â„“,
and let there be such a maximal path from some ğ‘ âˆˆ ğ´0 to ğ‘. By
correctness of Algorithm 1, the path from ğ‘ to ğ‘ in ğº corresponds
to a chain in database D. Thus the height of ğ‘ is â‰¥ â„“. Suppose for a
contradiction that ğ‘ has height â„“â€² > â„“; By definition of height there
must exist a chain ğ¶ âŠ† D of size â„“â€² with ğ‘ as the maximal element.
Let ğ‘1 âª¯ ğ‘2 âª¯ Â· Â· Â· âª¯ ğ‘â„“â€² be the elements of ğ¶. We have that ğ‘ğ‘–+1
must minimally dominate ğ‘ğ‘–, otherwise we could could extend the
chain from ğ‘ to ğ‘ to have length greater than â„“â€². By correctness
of ğº, each edge (ğ‘ğ‘–, ğ‘ğ‘–+1) must be in ğº. Hence the length of the
longest path from ğ‘ to ğ‘ in ğº is â„“â€² > â„“, a contradiction. Thus the
height of ğ‘ is given by the length of the longest path from ğ‘ to ğ‘
over all ğ‘ âˆˆ ğ´0. Let ğ¿ be the number of partitions in the canonical
antichain partition of D. We have shown that Algorithm computes
the partition A = (ğ´0, . . . , ğ´ğ¿) correctly. Let ğ‘1, . . . , ğ‘ğ‘š be elements
of a partition ğ´ âˆˆ A. We show that Algorithm 2 correctly computes
an ordering of ğ‘1, . . . , ğ‘ğ‘š i.e. a ğ‘ğ›¾1, . . . , ğ‘ğ›¾ğ‘š such that ğ›¾ğ‘– = 1, . . . , ğ‘š
and for all ğ‘— either ğ‘ğ›¾ ğ‘— âª¯ğ‘ ğ‘ğ›¾ ğ‘—+1 or ğ‘ğ›¾ ğ‘—+1 âª¯ğ‘ ğ‘ğ›¾ ğ‘— . If |ğ´| < 3 then
we are done. |ğ´| â‰¥ 3 then on line 12 we compute all responses in
RS(D) that contain exactly two elements in ğ´ and denote this set as
ğ‘†. A response containing exactly two elements ğ‘, ğ‘â€² âˆˆ ğ´ exists only
if ğ‘ minimally anti-dominates ğ‘â€² (or vice versa). Next we delete
all ğ‘ âˆˆ D âˆ’ ğ´ from responses in ğ‘† and make it a set. Let {ğ‘, ğ‘â€²}
be an element of the resulting set ğ‘†. Without loss of generality,
suppose ğ‘â€² minimally anti-dominates ğ‘. Suppose that there exists
another set {ğ‘â€², ğ‘â€²â€²} âˆˆ ğ‘†. Then by transitivity ğ‘â€²â€² must minimally
anti-dominate ğ‘â€². We can thus â€œorder" the elements in ğ´ by finding
consecutive pairs of points in the responses.
This Algorithm terminates in ğ‘‚(ğ‘…2|RS(D)|) time, as it takes
ğ‘‚(ğ‘…2) time to find the longest paths in ğº and ğ‘‚(ğ‘…2|RS(D)|) to
order the antichains.
â–¡
C.6 Proof of Lemma 5.4
Proof. The antichains returned by Algorithm 2 may have in-
consistent direction. The first step of Algorithm 3 is to fix their
orientation. We assume that the first antichain, ğ´0, has the correct
orientation. Then, we find the first element of ğ´0 that has a dom-
inance edge to a point in ğ´1, the second antichain. Let that edge
be (ğ‘1, ğ‘2), ğ‘1 âˆˆ ğ´0, ğ‘2 âˆˆ ğ´1. If there are multiple options for ğ‘2, we
pick the smallest one in order. Note that each member ğ‘ of antichain
ğ‘– must have a dominance edge with some member ğ‘ of antichain
ğ‘—, ğ‘— < ğ‘–. Otherwise, ğ‘ would be part of some previous antichain.
If the order of antichain 1 is wrong, then a point ğ‘â€²
1 âˆˆ ğ´0 in order
before ğ‘1 must have an edge with point ğ‘â€²
2 âˆˆ ğ´1, in order after
ğ‘2. If the chains were correctly ordered that would be impossible
as ğ‘â€²
2 cannot
dominate ğ‘â€²
1. Thus, Algorithm 2 can correctly orient the second
chain given the order of the previous antichains. Maintaining this
invariant, Algorithm 2 correctly orients all antichains.
2 anti-dominates ğ‘1 and ğ‘1 anti-dominates ğ‘â€²
1. Thus, ğ‘â€²
We begin constructing the anti-dominance graph by adding
anti-dominance edges between consecutive pairs of points in each
antichain. It remains to add anti-dominance edges between points
in different antichains. The algorithm iterates through pairs of
chains, and finds points ğ‘ğ‘– and ğ‘ ğ‘— that are not connected in ğº and
ğ‘ğ‘– âˆˆ ğ´ğ‘–, ğ‘ ğ‘— âˆˆ ğ´ğ‘— , ğ‘– < ğ‘—. Point ğ‘ğ‘– either anti-dominates ğ‘ ğ‘— or ğ‘ ğ‘—
anti-dominates ğ‘ğ‘–. In order to determine their relationship, we look
for a dominance edge between the antichains. If ğ‘ ğ‘— anti-dominates
ğ‘ğ‘–, then all predecessors of ğ‘ğ‘– are also anti-dominated by ğ‘ ğ‘— and
its successors. So, if a predecessor of ğ‘ ğ‘— dominates a successor of
ğ‘ğ‘–. Then ğ‘ ğ‘— must anti-dominate ğ‘ğ‘–. Similarly, if a successor of ğ‘ ğ‘—
dominates a predecessor of ğ‘ğ‘–, then ğ‘ğ‘– anti-dominates ğ‘ ğ‘—.
This technique finds only strict anti-dominance edges. It remains
to find any collinear anti-dominance edges. Given a pair of points
ğ‘ and ğ‘, such that ğ‘ anti-dominates ğ‘, and a point ğ‘˜ that is in
Boxes(ğ‘, ğ‘), ğ‘˜ must have an anti-dominance relationship with both.
If no such path exists in ğºâ€², we add appropriate edges depending
on which of the Boxes ğ‘˜ is in. Note that in some cases, as explained
by Proposition 3, itâ€™s impossible to determine all collinearities. Our
definition of the anti-dominance graph is that it contains minimal
anti-dominance edges. Thus, after we remove any transitive edges,
we have generated Dâ€™s anti-dominance graph.
The algorithm takes ğ‘‚(ğ‘…2|RS(D)|) time: ğ‘‚(ğ‘…2) to fix the an-
tichains and add edges between them, and ğ‘‚(ğ‘…3 Â· |RS(D)|) to run
Boxes for any anti-dominance pair.
â–¡
C.7
Proof of Theorem 5.5
Proof. By Lemma 5.1, PossibleConfigs has all possible config-
urations of a given set of extreme points. Thus, at some point we
pick the correct config. By Lemmas 5.2 and 5.4, we know that ğº and
ğºâ€² return correct weak dominance and anti-dominance graphs. By
Proposition 2, we know that if the smallest response that contains
top and bottom is empty, then they are an antipodal pair. Similarly
for left and right. We find all such pairs. We iterate though pairs of
points and find any that satisfy the close pair requirements from
Definition 3.3, constructing the closePairs set. The anti-dominance
graph encodes the components as the connected components of
the anti-dominance graph form the flippable components.
By Theorem 3.5, given (ğº, ğºâ€², antipodalPairs, closePairs) out-
put by the algorithm, we can construct all members of set Eo(D).
Session 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2259Mean Squared
Error
Hausdorff
Distance
Pairwise Relative
Distance Error
CPU Usage
(hours)
Max Memory
Required (GB)
Normalized Mean
Error
NIS 2009: NCH & NDX
NIS 2009: NCH & NPR
NIS 2009: NDX & NPR
Figure 12: Accuracy (measured with the metrics defined in Section 7.3) and computational resource usage (CPU time and max-
imum memory required) of our reconstructions of the NIS 2009 datasets as a function of the query ratio, under the Uniform
(blue circle â€¢), Beta (green star â˜…), and Gaussian (orange â™¦) query distributions.
The first graph we return is sufficient as any other extreme point
configurations whose response set matches RS(D) are either rota-
tions/reflections or contain antipodal pairs. This Algorithm takes
ğ‘‚(ğ‘…3|RS(D)|) time, as it takes ğ‘‚(ğ‘…3|RS(D)|) time to run Algo-
rithms 9, 1, 2 and 3. Finding antipodal pairs takes ğ‘‚(|RS(D)|) and
finding close pairs ğ‘‚(ğ‘…3). Finally, it takes ğ‘‚(ğ‘…4) time to generate
and compare the leakage. We can encode graphs ğº and ğºâ€² by their
linear extensions in linear space, and the sets antipodalPairs and
closePairs contain at most ğ‘‚(ğ‘…) points.
â–¡
Chao-Lee. Chao and Lee proposed an estimator that utilizes sample
coverage [8]. The sample coverage ğ¶ of a sample ğ¿ is the sum of
the probabilities of the the token-response pairs that appear in ğ¿.
this approximation in combination with an additive term to correct
estimates of data drawn from skew distributions. Let ğ‘ğ‘– be the
probability that a query sampled from the distribution matches the
Knowledge of ğ¶ can then be used to estimate(cid:98)ğœŒ. Chao and Lee use
2 (cid:1) token-
2 (cid:1)(cid:0)ğ‘1+1
ğ‘–-th token-response pair, of the possible ğ‘„ =(cid:0)ğ‘0+1
the the token-response pairs that appear in ğ¿: ğ¶ =ğ‘„
be used to estimate(cid:98)ğœŒ â‰ˆ ğ‘‘/ Ë†ğ¶. Thus,
where Ë†ğ›¾ is an estimate of the coefficient of variation ğ›¾ = (ğ‘–(ğ‘ğ‘– âˆ’
response pairs. Let 1ğ¿(ğ‘–) be the following indicator function: 1ğ¿(ğ‘–)
equals 1 if the i-th token-response pair is in ğ¿ and 0 otherwise. The
sample coverage ğ¶ of a sample ğ¿ is the sum of the probabilities of
ğ‘–=1 ğ‘ğ‘– Â· 1ğ¿(ğ‘–).
Note that Ë†ğ¶ = 1 âˆ’ ğ‘“1/ğ‘› is a natural estimate for ğ¶, which can then
(cid:98)ğœŒChaoLee =
+ ğ‘›(1 âˆ’ Ë†ğ¶)
ğ‘ğ‘šğ‘’ğ‘ğ‘›)2/ğ‘„)1/2/ğ‘ğ‘šğ‘’ğ‘ğ‘› and ğ‘ğ‘šğ‘’ğ‘ğ‘› is the mean of the probabilities
ğ‘1, . . . , ğ‘ğ‘„.
Shlosser. Shlosser derived an estimator that works well under the
assumption that the sample is large and the sampling fraction is non-
negligible [42]. We used an implementation of Shlosser Estimator
that used a Bernoulli Sampling scheme. This estimator is more
effective for skewed distributions.
Let ğ‘ be the probability with which a token-response pair is
included in the sample. In [42], Shlosser derived the estimator
Â· Ë†ğ›¾2,
ğ‘‘
Ë†ğ¶
Ë†ğ¶
D Estimators
Let D be a database of ğ‘… records and let
ğ‘€ = {{(ğ‘¡1, ğ´1), . . . , (ğ‘¡ğ‘š, ğ´ğ‘š) : ğ´ğ‘– âˆˆ RS(D)}}
be a sample (i.e. multiset) of ğ‘š token-response pairs that are leaked
when queries are issued according to an arbitrary distribution. Let
ğ‘€ be a sample and let ğ‘› denote the size of a subsample ğ¿ âŠ† ğ‘€.
Denote by ğ‘‘ the number of distinct tokens in a subsample ğ¿ âŠ† ğ‘€.
Definition D.1. [45] Let ğ¿ be a subsample and let ğ‘“ğ‘– be the number
of search tokens that are observed ğ‘– times in ğ¿. The fingerprint of
a sample ğ¿ is the vector ğ¹ = (ğ‘“1, ğ‘“2, ..., ğ‘“ğ‘›), where |ğ¿| = ğ‘›. We can
ğ‘–=1 ğ‘– ğ‘“ğ‘–
ğ‘–=1 ğ‘“ğ‘–.
express the total number of token-response pairs in ğ¿ as ğ‘› =ğ‘›
and the number of observed distinct search tokens as ğ‘‘ =ğ‘›
To estimate(cid:98)ğœŒ â‰ˆ ğœŒ, we let ğ¿ be a submultiset of ğ‘€ comprised of
all token-response pairs that contain the identifiers of the points
whose ğœŒ value we wish to compute. We then use an estimator to
estimate how many unique search tokens are associated with those
record identifiers. We describe three such estimators below.
(cid:98)ğœŒShloss = ğ‘‘ + ğ‘“1ğ‘›
ğ‘›
ğ‘–=1(1 âˆ’ ğ‘)ğ‘– Â· ğ‘“ğ‘–
ğ‘–=1 ğ‘– Â· (1 âˆ’ ğ‘)ğ‘–âˆ’1 Â· ğ‘“ğ‘–
.
This estimator rests on the assumption that ğ‘ = ğ‘›/ğ‘„. As [21]
notes, the Shlosser estimator further rests on the assumption that
Session 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2260E[ğ‘“ğ‘–]/E[ğ‘“1] â‰ˆ ğ¹ğ‘–/ğ¹1 where ğ¹ğ‘– is the number of tokens that appear
ğ‘– times in entire database; This assumption isnâ€™t often satisfied in
our setting, but our experiments demonstrate that Shlosser did
comparable to Jackknife in various cases.
Jackknife. The jackknife method was introduced as a technique
for correcting the bias of an estimator [40]. We use the jackknife
estimators described in [2, 3], which have been used for the prob-
lem of estimating the number of unique attributes in a relational
database [21], in database reconstruction [27], and in biology for
the related problem of species estimation. Given a biased estimate,
jackknife estimators use sampling with replacement to estimate
the bias ğ‘ğ‘–ğ‘ğ‘  ğ‘—ğ‘ğ‘ğ‘˜, and obtain(cid:98)ğœŒjack.
estimate the bias ğ‘ğ‘–ğ‘ğ‘  ğ‘—ğ‘ğ‘ğ‘˜, and obtain(cid:98)ğœŒjack = ğ‘‘ âˆ’ ğ‘ğ‘–ğ‘ğ‘  ğ‘—ğ‘ğ‘ğ‘˜. Let ğ‘‘ğ‘›
One can view ğ‘‘ as a biased estimate of the true ğœŒ. Given a biased
estimate ğ‘‘, jackknife estimators use sampling with replacement to
denote the number of unique tokens in ğ¿ and let ğ‘‘ğ‘›âˆ’1(ğ‘˜) denote
the number of unique tokens in ğ¿ when the ğ‘˜-th token-response
removed. Note that ğ‘‘ğ‘›âˆ’1(ğ‘˜) = ğ‘‘ğ‘› âˆ’ 1 if and only if the ğ‘˜-th pair
ğ‘˜=1 ğ‘‘(ğ‘›âˆ’1)(ğ‘˜). The first order
order jackknife considers all ğ‘› samples generated by leaving one
is unique in ğ¿. Let ğ‘‘ğ‘›âˆ’1 = (1/ğ‘›)ğ‘›
jackknife estimator is(cid:98)ğœŒjack = ğ‘‘ âˆ’ (ğ‘› âˆ’ 1)(ğ‘‘(ğ‘›âˆ’1) âˆ’ ğ‘‘). The second
pair out, in addition to all(cid:0)ğ‘›
2(cid:1) generated by leaving two pairs out.
(cid:1) samples and has bias ğ‘‚(ğ‘›âˆ’ğ‘˜+1).
ğ‘–=1(cid:0)ğ‘›
that generatesğ‘˜
This method can be extended to an ğ‘˜-th order jackknife estimators
ğ‘–
E Experimental Results
In Figure 12, we show the results of our reconstructions of the
NIS 2009 dataset. Overall, the results follow a similar trend to the
results in Figure 9. There is a decrease in normalized mean error,
mean squared error, and pairwise relative distance error, as a larger
percentage of queries is observed. We also note that the maximum
memory required is fairly constant across all runs.
Session 7C: Database and Privacy CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2261