## **背景介绍**
本文基本上是今年六七月花挺大量的一段时间读了一些学术论文，也提及了一些常见的DNS利用技巧，有旧有新然后整合起来做个简单的总结。涉及的范围不是很广，但还是可以讲到一些覆盖皮毛的知识，并且在本文中可以发现在真实安全环境下的攻防对抗的逐渐升级，安全无止境。希望抛砖引玉，同样对DNS安全有研究或有兴趣的朋友可以一同交流学习。
## **DNS Data**
**Data Collections**
一般来说，我们会通过收集数据来丰富我们的研究工作，同时这些数据也是可以被用作在安全测试当中。比较推荐的是Rapid7的开放DNS数据库，他们提供了存储DNS解析信息的FDNS（Forward
DNS）和PTR信息的RDNS（Reserve DNS）。
同时Rapid7也提供了人性化的api接口供用户进行即时查询读取，接口地址为
**Passive DNS**
讲到DNS数据集，不得不提的是Passive DNS。我查阅了很多互联网博客资料，发现并没有哪个对Passive
DNS的概念描述得很清楚，导致大多数人会误以为Passive DNS和之前提供的DNS解析数据是差不多的，但是还是略有不同。Passive
DNS，顾名思义其实就是被动获取的DNS数据信息。它是由一些研究者放入互联网当中的流量抓取工具抓到的DNS数据信息，然后存储到一个中央数据库，形成了Passive
DNS
database。这种数据信息和一些本地DNS数据不同的是，它包含的不仅是当前的DNS数据（包括IP映射等），还包括了历史上所存在的一些DNS数据映射等。研究人员可以通过对这种数据变更发现一些隐藏的关系链，甚至挖掘出一些未知的威胁风险等，例如发现新的恶意域名。攻击者可以通过一系列手段绕过一些本地DNS特征，但是想要绕过这种全局化的DNS信息是非常困难的。
一个域名在某个时间段内可以解析到多个IP地址上，一个IP地址也可以某个时间段内映射在多个域名，这些映射历史都是可以被Passive
DNS数据包含在内，这样研究者可以从这些关联数据中发现已知的恶意域名与未知恶意域名之间的关系，从而挖掘出未知的威胁风险。
所以通过Passive DNS来构建域名间联系，可以通过定义如下公式来定义该联系的权重。
将该公式实验应用到下面这个域名解析图中，去计算每个域名节点之间的联系权重。举个例子，计算D1和D3之间的联系权重，D1和D3的IP映射当中有一个IP是重叠的，且很明显D1≠D3，所以w(D1,D3)=1-1/2=0.5，符合域名图中的权重数值。
将该公式用于计算3322.org这个著名的恶意域名的二级域名之间的联系关系，并将关系图绘制出来可以发现，二级域名间存在一个团体性的关系联系，这往往给我们对恶意域名的行为进行明显地区分或加以更深入的分析。
利用上面的权重关系可以进一步分析一些未知域名与著名恶意域名之间的联系权重，从而判断未知域名是否具有恶意性。但是问题在于这些需要进行判断的未知域名与著名恶意域名间不一定存在直接联系，它们可能类似上述图中的D2与D6的关系，需要经过一段路径才能联系在一起。所以以D2和D6作为例子，那么需要首先定义D2和D6中间的路径，即有如下几种情况：
  1. D2-D3-D1-D4-D5-D6；
  2. D2-D3-D1-D4-D6；
  3. D2-D3-D4-D5-D6；
  4. D2-D3-D4-D6；
如果从直观上选择一般选择路径最短，但是首先这里会定义一个联系关系函数assoc(P)，assoc(P)要求必须是每次经过路径的最大值，因为最大值路径代表了最强关联性，可以理解这种强关联性更易于传播“恶意行为”这个属性。
所以选择路径Path
3：D2-D3-D4-D5-D6。那么该公式中的w(P)，即路径权重是由edge的值相乘得到，但path越长，推定确定性越低，所以没经过一个hop需要打折一次。即如下公式：
因为要通过著名恶意域名去判断未知域名，所以要设立一个关于已知恶意域名的对象seed，多个seed形成一个S集合。最终就是通过seed来计算未知域名的恶意性可能性值。
定义一个列表M(d)，这是一个seed与未知域名之间关系值assoc()函数的排序列表，即 (assoc(s1, d), . . . , assoc(sn,
d))，列表排序说明了在列表第一个的assoc(s1,d)说明d与s1的关联系最高，这里是通过与一个恶意域的强关联和与其他恶意域的弱关联从双面判定该域名与指定恶意域的强关联性。得到如下的mal(d,S)，这个公式推算出需要判断的未知域名的恶意可能性值。
可是如上的公式推算忽略一个情况，就是公有云的问题。像阿里云这些可能由于云厂商拥有的是有限的IP地址池，所以可能有些主机域名因为厂商的缘故会共享使用或者不同时间段内映射到同一个IP地址。但它们之间并不存在恶意联系。那么如何解决这种误会问题呢？有两个解决办法：
  1. 简单粗暴，直接将这类IP地址剔除不进行计算（不现实，且最后推算出的公式不通用）；
如果一个IP在一段时间内被映射到大量的域名，那么它很可能是一个公共IP。因此，如果IP在某个时间段内承载超过t个域名，我们将排除这些IP，其中t是一个可配置参数。
  2. 重新定义域名间联系权重w(d1,d2)；
定义一个asn(I)，I为IP地址集合，那么asn(I)表示这个集合中IP地址归属的自治系统域（AS）的编号，这里默认认为一个服务提供商只会提供一个AS内的IP地址。但实际上像AS16509和AS14618都属于Amazon，所以结果会略有偏差。这时需要通过whois信息中的提供商记录来加以判断。
## **DNS Rebinding**
DNS重绑定是一种比较常见的攻击形式，1996年该技术扰乱了JVM自身的安全措施。该技术的主要核心就是绕过SOP的限制来进行一些内网威胁攻击。基本过程如下：
  1. 第一次DNS解析请求到外部合法域名绕过安全限制；
  2. 第二次DNS解析请求发现数据变更请求到内网地址。
这种技术可以用于防火墙绕过或者IP劫持等。那么一般如果要实现这种技术利用，可以建立在好几种不同的基础原理上
  1. 给同一个主机域名配置多个DNS的A记录（1996年攻击JVM的手法）；
  2. 极短的TTL老化时间；
  3. 不同浏览器中的Pinning设置时间不一样导致可以通过在部署弱安全措施的浏览器上实施攻击（DNS Pinning即浏览器会在自身设置好的缓存时间前使用自己缓存库中的IP地址或域名，这期间不信任不依赖TTL老化时间）；
  4. Flash的crossdomain.xml不够严谨（由于Flash将死，不详述）；
针对这种攻击技术的防护可以从三个方面进行部署：
防火墙绕过层面：
  1. 关闭企业对外的53端口禁止内网对外部DNS服务器进行请求，然后在本地DNS服务器上进行外部域名映射到内网IP地址；
  2. 用户的个人PC防火墙可以加上dnswall的部署；
  3. Windows的防火墙可以阻断对127回环IP地址的DNS解析请求；
插件安全
  1. Flash Player需设置严谨的policy文件且需在socket连接前先通过policy的安全检查。
  2. Java需使用CONNECT方法对外连接；
  3. Java LiveConnect需使用和浏览器统一的缓存池以移除不同Pinning时间导致漏洞利用；
浏览器安全
如果插件默认拒绝socket连接
  * 检查请求包Host字段  
因为javascript标准不允许xhr自定义host字段，所以通过检查该字段可以防止在一个IP地址上承载多个主机域名。
  * 源信息细粒化  
其实就是收集关于目标信息的一些细粒化的信息，包括其公钥信息等，再次请求时为了防止目标被篡改那么就会比对这些额外信息是否匹配，如果不匹配那么有可能遭受了DNS重绑定攻击了。
  * 智能化Pinning  
服务商一般会降低TTL来提高应用健壮性，但牺牲了安全性，使其可以被DNS重绑定攻击。所以使用“C类固定”，只允许重绑定源目标的同C类地址。同时RFC1938标准文档阻止了公用IP地址和私用IP地址之间重绑定。
  * 基于协议的Pinning  
浏览器在重绑定时参考目标服务器部署的一些policy措施（例如，crossdomain.xml和部署在reverse DNS上的policy）。