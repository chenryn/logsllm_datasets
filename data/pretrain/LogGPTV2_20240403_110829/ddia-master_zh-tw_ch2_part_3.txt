但是，在表示多对一和多对多的关系时，关系资料库和文件资料库并没有根本的不同：在这两种情况下，相关专案都被一个唯一的识别符号引用，这个识别符号在关系模型中被称为 **外来键**，在文件模型中称为 **文件引用**【9】。该识别符号在读取时透过连线或后续查询来解析。迄今为止，文件资料库没有走 CODASYL 的老路。
### 关系型资料库与文件资料库在今日的对比
将关系资料库与文件资料库进行比较时，可以考虑许多方面的差异，包括它们的容错属性（请参阅 [第五章](ch5.md)）和处理并发性（请参阅 [第七章](ch7.md)）。本章将只关注资料模型中的差异。
支援文件资料模型的主要论据是架构灵活性，因区域性而拥有更好的效能，以及对于某些应用程式而言更接近于应用程式使用的资料结构。关系模型透过为连线提供更好的支援以及支援多对一和多对多的关系来反击。
#### 哪种资料模型更有助于简化应用程式码？
如果应用程式中的资料具有类似文件的结构（即，一对多关系树，通常一次性载入整个树），那么使用文件模型可能是一个好主意。将类似文件的结构分解成多个表（如 [图 2-1](../img/fig2-1.png) 中的 `positions`、`education` 和 `contact_info`）的关系技术可能导致繁琐的模式和不必要的复杂的应用程式程式码。
文件模型有一定的局限性：例如，不能直接引用文件中的巢状的专案，而是需要说 “使用者 251 的位置列表中的第二项”（很像层次模型中的访问路径）。但是，只要档案巢状不太深，这通常不是问题。
文件资料库对连线的糟糕支援可能是个问题，也可能不是问题，这取决于应用程式。例如，如果某分析型应用程式使用一个文件资料库来记录何时何地发生了何事，那么多对多关系可能永远也用不上。【19】。
但如果你的应用程式确实会用到多对多关系，那么文件模型就没有那么诱人了。尽管可以透过反规范化来消除对连线的需求，但这需要应用程式程式码来做额外的工作以确保资料一致性。尽管应用程式程式码可以透过向资料库发出多个请求的方式来模拟连线，但这也将复杂性转移到应用程式中，而且通常也会比由资料库内的专用程式码更慢。在这种情况下，使用文件模型可能会导致更复杂的应用程式码与更差的效能【15】。
我们没有办法说哪种资料模型更有助于简化应用程式码，因为它取决于资料项之间的关系种类。对高度关联的资料而言，文件模型是极其糟糕的，关系模型是可以接受的，而选用图形模型（请参阅 “[图资料模型](#图资料模型)”）是最自然的。
#### 文件模型中的模式灵活性
大多数文件资料库以及关系资料库中的 JSON 支援都不会强制文件中的资料采用何种模式。关系资料库的 XML 支援通常带有可选的模式验证。没有模式意味著可以将任意的键和值新增到文件中，并且当读取时，客户端无法保证文件可能包含的栏位。
文件资料库有时称为 **无模式（schemaless）**，但这具有误导性，因为读取资料的程式码通常假定某种结构 —— 即存在隐式模式，但不由资料库强制执行【20】。一个更精确的术语是 **读时模式**（即 schema-on-read，资料的结构是隐含的，只有在资料被读取时才被解释），相应的是 **写时模式**（即 schema-on-write，传统的关系资料库方法中，模式明确，且资料库确保所有的资料都符合其模式）【21】。
读时模式类似于程式语言中的动态（执行时）型别检查，而写时模式类似于静态（编译时）型别检查。就像静态和动态型别检查的相对优点具有很大的争议性一样【22】，资料库中模式的强制性是一个具有争议的话题，一般来说没有正确或错误的答案。
在应用程式想要改变其资料格式的情况下，这些方法之间的区别尤其明显。例如，假设你把每个使用者的全名储存在一个栏位中，而现在想分别储存名字和姓氏【23】。在文件资料库中，只需开始写入具有新栏位的新文件，并在应用程式中使用程式码来处理读取旧文件的情况。例如：
```go
if (user && user.name && !user.first_name) {
  // Documents written before Dec 8, 2013 don't have first_name
  user.first_name = user.name.split(" ")[0];
}
```
另一方面，在 “静态型别” 资料库模式中，通常会执行以下 **迁移（migration）** 操作：
```sql
ALTER TABLE users ADD COLUMN first_name text;
UPDATE users SET first_name = split_part(name, ' ', 1);      -- PostgreSQL
UPDATE users SET first_name = substring_index(name, ' ', 1);      -- MySQL
```
模式变更的速度很慢，而且要求停运。它的这种坏名誉并不是完全应得的：大多数关系资料库系统可在几毫秒内执行 `ALTER TABLE` 语句。MySQL 是一个值得注意的例外，它执行 `ALTER TABLE` 时会复制整个表，这可能意味著在更改一个大型表时会花费几分钟甚至几个小时的停机时间，尽管存在各种工具来解决这个限制【24,25,26】。
大型表上执行 `UPDATE` 语句在任何资料库上都可能会很慢，因为每一行都需要重写。要是不可接受的话，应用程式可以将 `first_name` 设定为预设值 `NULL`，并在读取时再填充，就像使用文件资料库一样。
当由于某种原因（例如，资料是异构的）集合中的专案并不都具有相同的结构时，读时模式更具优势。例如，如果：
* 存在许多不同型别的物件，将每种型别的物件放在自己的表中是不现实的。
* 资料的结构由外部系统决定。你无法控制外部系统且它随时可能变化。
在上述情况下，模式的坏处远大于它的帮助，无模式文件可能是一个更加自然的资料模型。但是，要是所有记录都具有相同的结构，那么模式是记录并强制这种结构的有效机制。第四章将更详细地讨论模式和模式演化。
#### 查询的资料区域性
文件通常以单个连续字串形式进行储存，编码为 JSON、XML 或其二进位制变体（如 MongoDB 的 BSON）。如果应用程式经常需要访问整个文件（例如，将其渲染至网页），那么储存区域性会带来效能优势。如果将资料分割到多个表中（如 [图 2-1](../img/fig2-1.png) 所示），则需要进行多次索引查询才能将其全部检索出来，这可能需要更多的磁碟查询并花费更多的时间。
区域性仅仅适用于同时需要文件绝大部分内容的情况。即使只访问文件其中的一小部分，资料库通常需要载入整个文件，对于大型文件来说这种载入行为是很浪费的。更新文件时，通常需要整个重写。只有不改变文件大小的修改才可以容易地原地执行。因此，通常建议保持相对小的文件，并避免增加文件大小的写入【9】。这些效能限制大大减少了文件资料库的实用场景。
值得指出的是，为了区域性而分组集合相关资料的想法并不局限于文件模型。例如，Google 的 Spanner 资料库在关系资料模型中提供了同样的区域性属性，允许模式宣告一个表的行应该交错（巢状）在父表内【27】。Oracle 类似地允许使用一个称为 **多表索引丛集表（multi-table index cluster tables）** 的类似特性【28】。Bigtable 资料模型（用于 Cassandra 和 HBase）中的 **列族（column-family）** 概念与管理区域性的目的类似【29】。
在 [第三章](ch3.md) 将还会看到更多关于区域性的内容。
#### 文件和关系资料库的融合
自 2000 年代中期以来，大多数关系资料库系统（MySQL 除外）都已支援 XML。这包括对 XML 文件进行本地修改的功能，以及在 XML 文件中进行索引和查询的功能。这允许应用程式使用那种与文件资料库应当使用的非常类似的资料模型。
从 9.3 版本开始的 PostgreSQL 【8】，从 5.7 版本开始的 MySQL 以及从版本 10.5 开始的 IBM DB2【30】也对 JSON 文件提供了类似的支援级别。鉴于用在 Web APIs 的 JSON 流行趋势，其他关系资料库很可能会跟随他们的脚步并新增 JSON 支援。
在文件资料库中，RethinkDB 在其查询语言中支援类似关系的连线，一些 MongoDB 驱动程式可以自动解析资料库引用（有效地执行客户端连线，尽管这可能比在资料库中执行的连线慢，需要额外的网路往返，并且最佳化更少）。
随著时间的推移，关系资料库和文件资料库似乎变得越来越相似，这是一件好事：资料模型相互补充 [^v]，如果一个数据库能够处理类似文件的资料，并能够对其执行关系查询，那么应用程式就可以使用最符合其需求的功能组合。
关系模型和文件模型的混合是未来资料库一条很好的路线。
[^v]: Codd 对关系模型【1】的原始描述实际上允许在关系模式中与 JSON 文件非常相似。他称之为 **非简单域（nonsimple domains）**。这个想法是，一行中的值不一定是一个像数字或字串一样的原始资料型别，也可以是一个巢状的关系（表），因此可以把一个任意巢状的树结构作为一个值，这很像 30 年后新增到 SQL 中的 JSON 或 XML 支援。
## 资料查询语言
当引入关系模型时，关系模型包含了一种查询资料的新方法：SQL 是一种 **宣告式** 查询语言，而 IMS 和 CODASYL 使用 **命令式** 程式码来查询资料库。那是什么意思？
许多常用的程式语言是命令式的。例如，给定一个动物物种的列表，返回列表中的鲨鱼可以这样写：
```js
function getSharks() {
    var sharks = [];
    for (var i = 0; i < animals.length; i++) {
        if (animals[i].family === "Sharks") {
            sharks.push(animals[i]);
        }
    }
    return sharks;
}
```
而在关系代数中，你可以这样写：
$$
sharks = \sigma_{family = "sharks"}(animals)
$$
其中 $\sigma$（希腊字母西格玛）是选择运算子，只返回符合 `family="shark"` 条件的动物。
定义 SQL 时，它紧密地遵循关系代数的结构：