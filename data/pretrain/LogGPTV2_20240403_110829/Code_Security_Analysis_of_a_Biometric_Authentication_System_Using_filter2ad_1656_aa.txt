title:Code Security Analysis of a Biometric Authentication System Using
Automated Theorem Provers
author:Jan J&quot;urjens
Code Security Analysis
of a Biometric Authentication System
Using Automated Theorem Provers
Software & Systems Engineering, Dep. of Informatics, TU Munich, Germany
http://www4.in.tum.de/˜juerjens
Jan J¨urjens
Abstract
Understanding the security goals provided
by cryptographic protocol implementations is
known to be diﬃcult, since security require-
ments such as secrecy, integrity and authentic-
ity of data are notoriously hard to establish, es-
pecially in the context of cryptographic interac-
tions. A lot of research has been devoted to de-
veloping formal techniques to analyze abstract
speciﬁcations of cryptographic protocols. Less
attention has been paid to the analysis of cryp-
toprotocol implementations, for which a formal
link to speciﬁcations is often not available. In
this paper, we apply an approach to determine
security goals provided by a C implementation
to a industrially-strength biometric authentica-
tion system. Our approach is based on control
ﬂow graphs and automated theorem provers for
ﬁrst-order logic.
1 Introduction
While a signiﬁcant amount of research has
been directed to develop formal techniques
to analyze abstract speciﬁcations of crypto-
graphic protocols,
few attempts have been
made to apply the results developed in that
setting to the analysis of cryptoprotocol im-
plementations. Even if speciﬁcations exist for
these implementations, and even if these had
been analyzed formally, there is usually no
guarantee that the implementation actually
conforms to the speciﬁcation. An example for a
protocol whose design had been formally veri-
ﬁed for security and whose implementation was
later found to contain a weakness with respect
to its use of cryptographic algorithms can be
found in [RS98]. Even in software projects
where speciﬁcation techniques are used, often
changes in the code that become necessary dur-
ing the implementation phase because of dy-
namically changing requirements are not re-
ﬂected in the speciﬁcations. In this paper, we
therefore propose an approach to determine se-
curity goals provided by a protocol implemen-
tation on the source-code level.
Our approach uses automated theorem
provers (ATPs) for ﬁrst-order logic. These are
not only automatic, but also quite eﬃcient and
powerful, because of the eﬃcient proof pro-
cedures implemented in these tools and be-
cause security requirements can be formalized
straightforwardly in ﬁrst-order logic (FOL).
The C code gives rise to a control ﬂow graph in
which the cryptographic operations are repre-
sented as abstract functions. The control ﬂow
graph is translated to formulas in ﬁrst-order
logic with equality. Together with a logical for-
malization of the security requirements, they
are then given as input into any ATP (such
as e-SETHEO [SW00]) supporting the TPTP
input notation, which is a standard input nota-
tion for automated theorem provers (ATPs). If
the analysis reveals that there could be an at-
tack against the protocol, an attack generation
script written in Prolog is generated from the
C code. A tool for our approach is available
over a web-interface and as open-source [sec].
the current paper
consists
in applying our approach to an
industrially-strength biometric authentication
protocol. This work is motivated by an ap-
plication of our veriﬁcation tools in an indus-
trial research and development project. In that
project, we gathered some valuable experiences
The contribution of
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:12:51 UTC from IEEE Xplore.  Restrictions apply. 
1
with the secure design of biometric authenti-
cation protocols and possible pitfalls involved,
as well as experiences with applying our veri-
ﬁcation tools to industrial systems. Since we
would like to share these experiences without
compromising our conﬁdentiality agreements,
we decided to deﬁne our own biometric authen-
tication protocol, based solely on openly acces-
sible information such as [VB03], and demon-
strate which kind of problems may arise, and
how one can detect them on the implementa-
tion level using our tools. We would like to
stress that any resemblances between the pro-
tocol presented here and actually existing pro-
tocols in industrial use are purely coincidental,
and that we make no implication that there
may have been any security concern with re-
spect to any present or past system of any of
our present or past industrial partners, of the
kind presented here or any other kind.
Note that this work is not just a matter
of using well-understood concepts and exist-
ing components, and of applying these to a
particular problem: Although there is a lot
of work on verifying abstract speciﬁcations of
cryptographic protocol using formal methods,
the veriﬁcation of implementations of crypto-
graphic protocols using ﬁrst-order logic is a
new research topic. Because of the security
problems which may be created at the transi-
tion from an abstract speciﬁcation to an im-
plementation, as mentioned above, one cannot
naively apply the speciﬁcation-based veriﬁca-
tion techniques to the source-code level. Also,
in the case of biometric authentication proto-
cols, problems may arise which are not present
in usual authentication protocols.
It is not our goal to provide an automated
full formal veriﬁcation of C code. Instead, our
goal is to increase understanding of the secu-
rity properties of cryptoprotocol implementa-
tions in a way as automated as possible to fa-
cilitate use in an industrial environment. Be-
cause of the abstractions used, the approach
may produce false alarms (which however have
not surfaced yet in practical examples). Also,
for space restrictions we cannot consider fea-
tures such as pointer arithmetic in our presen-
tation here (we essentially follow the approach
in [CKY03] there). We do not consider casts,
and expressions are assumed to be well-typed.
Loops are only investigated through a bounded
number of rounds (which is a classical approach
ANSI C editor
C
code
Annota−
tions
Text
Report
prepro−
cessed
annotated
code
Analyzer
Control
flow
graph
data flow
"uses"
ATP
result
Automated
Theorem Prover
seCse Suite
Formula
generator
FOL
formula
Figure 1. Tool-ﬂow of the seCse analy-
sis suite
in automated software veriﬁcation). Also, our
focus here is on high-level security properties
such as secrecy and authenticity, and not on de-
tecting low-level security ﬂaws such as buﬀer-
overﬂow attacks.
2 Code Analysis
The analysis approach presented here works
with the well-known Dolev-Yao adversary
model
for security analysis [DY83, Mea91,
Gol03]. The adversary can read messages sent
over the network and collect them in his knowl-
edge set, merge and extract messages in the
knowledge set, and delete or insert messages on
the communication links. The security require-
ments can then be formalized relative to this
adversary model. For example, a data value
remains secret from the adversary if it never
appears in the knowledge set of the adversary.
We explain the transformation from the con-
trol ﬂow graph generated from the C program
to ﬁrst-order logic, which is given as input
to the automated theorem prover. The cor-
responding tool-ﬂow is shown in Fig. 1. For
space restrictions, we restrict our explanation
to the analysis for secrecy of data. We use
a predicate knows which deﬁnes a bound on
the knowledge set deﬁned above. Precisely,
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:12:51 UTC from IEEE Xplore.  Restrictions apply. 
2
(cid:127)
(cid:127)
(cid:127)
(cid:127)
(cid:127)
(cid:127)
(cid:127)
(cid:127)
(cid:127)
)
enc(E, E(cid:1)
)
dec(E, E(cid:1)
)
hash(E)
sign(E, E(cid:1)
ver(E, E(cid:1), E(cid:1)(cid:1)
kgen(E)
inv(E)
conc(E, E(cid:1)
head(E) and tail(E)
)
)
(encryption)
(decryption)
(hashing)
(signing)
(veriﬁcation of signature)
(key generation)
(inverse key)
(concatenation)
(head and tail of concat.)
Figure 2. Crypto Operations
knows(E) means that the adversary may get
to know E during the execution of the proto-
col. For any data value s supposed to remain
conﬁdential, one thus has to check whether one
can derive knows(s).
Formally, one considers a term algebra gen-
erated from ground data such as variables,
keys, nonces and other data using symbolic op-
erations including the ones in Fig. 2. There,
the symbols E, E(cid:1), and E(cid:1)(cid:1) denote terms in-
ducticely constructed in this way. These sym-
bolic operations are the abstract versions of
the cryptographic algorithms used in the code.
Generating keys and random values is formal-
ized by introducing new variables represent-
ing the keys and random values. For keys
and random values that are supposed to be
freshly generated for each round of the proto-
col, one thus has a formula parameterized over
these variables, which is then closed by forall-
quantiﬁcation. In that term algebra, one de-
ﬁnes the equations dec(enc(E, K), inv(K)) = E
and ver(sign(E, inv(K)), K, E) = true
for all
terms E, K, and the usual laws regarding con-
catenation, head(), and tail().
The set of predicates deﬁned to hold for a
given program is deﬁned as follows. For each
publicly known expression E, the statement
knows(E) is derived. To model the fact that the
adversary may enlarge his set of knowledge by
constructing new expressions from the ones he
knows, including the use of cryptographic op-
erations, formulas are generated for these op-
erations for which some examples are given in
Fig. 3. We use the TPTP notation for the ﬁrst-
order logic formulas [SS01], which is the input
notation for many automated theorem provers
including the one we use, e-SETHEO [SW00].
Here & means logical conjunction and ![E1, E2]
forall-quantiﬁcation over E1, E2.
We now deﬁne how a control ﬂow graph gen-
erated from a C program (for example, using
the aiCall tool [Abs04]) gives rise to a logical
formula characterizing the interaction between
the adversary and the protocol participants.
Step 1 We observe that the graph can
be transformed to consist of transitions of
the form trans(state, inpattern, condition, action,
truestate), where inpattern is empty and
condition equals true where they are not
needed, and where action is a logical ex-
pression of the form localvar = value respec-
tively outpattern in case of a local assignment
resp. output command (leaving it empty if not
needed). There may also be another transition
with the negation of the given condition.
that
For
is
a
second
s2 = t1.
code
gives
2 Now
a
such
, . . . , argn).
assume
rise
to
the
Step
transition
source
that
TR1 = trans(s1, i1, c1, a1, t1)
transition TR2 =
there
trans(s2, i2, c2, a2, t2) where
If
there is no such transition TR2, we deﬁne
TR2 = trans(t1, [], true, [], t1) to simplify our
presentation, where []
is the empty input
or output pattern and trueis the boolean
Suppose that c1 is of the form
condition.
i1, we deﬁne
cond(arg1
¯i1 = knows(i1) in case i1 is non-empty and
otherwise ¯i1 = true. For a1, we deﬁne ¯a1 = a1
in case a1 is of the form localvar = value and
¯a1 = knows(outpattern) in case a1 = outpattern
(and ¯a1 = true in case a1 is empty). Then for
TR1 we deﬁne the following predicate:
PRED(TR1) ≡ ¯i1&c1 ⇒ ¯a1&PRED(TR2) (1)
if the
The formula formalizes the fact that,
adversary knows an expression he can assign
to the variable i1 such that the condition c1
holds, then this implies that ¯a1 will hold ac-
cording to the protocol, which means that ei-
ther the equation localvar = value holds in case
of an assignment, or the adversary gets to know
outpattern, in case it is sent out in a1. Also
then the predicate for the succeeding transi-
tion TR2 will hold.
To construct the recursive deﬁnition above,
we assume that the control ﬂow graph is ﬁnite
and cycle-free. Since in general there may be
unbounded loops in the C program (although
in the case of cryptographic protocols, these
are not so prevalent because the emphasis is
Proceedings of the 21st Annual Computer Security Applications Conference (ACSAC 2005) 
1063-9527/05 $20.00 © 2005 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:12:51 UTC from IEEE Xplore.  Restrictions apply. 
3
input_formula(construct_message_1,axiom,(
! [E1,E2] :
( (
knows(E1)
& knows(E2) )
=> (
knows(conc(E1, E2))
& knows(enc(E1, E2))