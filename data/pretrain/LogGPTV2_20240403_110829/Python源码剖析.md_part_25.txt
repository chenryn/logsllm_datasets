行“func=f（）”时，会执行函数r中的“defg(）：”语句，这时Python会将约束“a=2”
引用应该引用的是函数f定义的作用域中所创建的约束。
用域是函数g的作用域的直接外围作用域，所以，按照最内嵌套作用域规则，[1处的名字
数之内，所以函数g定义的作用域内嵌于函数主的作用域之内。换句话说，函数主的作
该是“a=1”才对。但是我们之前说到了，作用域仅仅是由文本决定的，函数g位于函
数内的约束“a=2”在其之外应该是不起作用的，当执行func（）时，起作用的约束应
清单8-2的[1]处，函数g内的“printa”的输出结果为2。初看上去有些疑问，因为函
思不得其解。
表的正是“直接外围作用域”这个概念。
的一种方案，即是形而下的“器”。
决定谁的关系。实际上，Pyhon实现闭包是为了实现最内嵌套作用域规则。换句话说，最
Eune//[2]
“闭包”是最内嵌套作用域规则的实现方案？这两个问题看上去是一致的，但却隐含着谁
“闭包”。
func=
def E0):
defg(）:
实际上这里有一个相当微妙的问题，最内嵌套作用域规则是“闭包”的结果呢，还是
print
尽管在代码清单8-2的[2]处，“a=2”这个约束已经不起作用了，但是Pyhon在执
代码清单8-2的[2]处调用的函数实际上调用的是函数中定义的内嵌函数g在代码
2
print
这里显示的作用域规则通常也被称为LEGB规则，其中的E为enclosing的缩写，代
defg
初学Pyhon时，由于大家不清楚Python的作用域规则，所以会对一些出错的情况百
global表达式
printa//[1]:输出结果为2
//[21
a
比如下面的例子：
ython源码剖析
8.2
名字、作用域和名字空间
深度探索动态语言核心技术
145
---
## Page 176
Python源码剖析
146
域中可见，就会出现在local名字空间中。换句话说，就遮蔽了外围作用域的相同的名字。
的“道”。
现象又一次地说明了最内嵌套作用域规则是指导Pyhon实现（这一次是编译器的实现）
Pyhon采用的是静态作用域规则，仅仅根据程序正文就能确定名字引用策略。同时，这个
中查找名字，也就是说Py山on在编译时就已经知道名字究竟藏身于何处。这正说明了
在函数E中，名字引用对应的字节码指令为主OADFAST，这条指令是指在1ocal名字空间
字引用对应的字节码指令是LOAD_GLOBAL，意思是要在globa1名字空间中查找名字；
def :
所以使用的是1ocal名字空间中的a所对应的对象。但是很不幸的是，虽然名字a在[1]
这个约束的名字a就是可见的，按照LEGB规则，在1ocal名字空间中就能找到名字a，
a”之后建立的，但是由于它们在同一个作用域内，所以在代码清单8-2的[11处，“a=2
邮
def g(）:
处已经可见了，但是要到[2]处对这个名字的赋值动作才会发生，a才会引用一个有效的对
可见（起作用）的”，这句话的意思对应到这里，就是说虽然“a=2”这个约束是在“print
个奇怪问题的症结所在。“由一个赋值语句引进的名字在这个赋值语句所在的作用域里是
怎么到了函数里，同样的代码，就说没有赋值了呢？
该是1才对，而且在调用之前我们调用了函数g，g可是已经老老实实地输出了结果，
定义的作用域内明明巴经建立了“a=1”这个约束，按照LEGB规则，这个输出结果应
上面的例子表明，一旦作用域中有了对于某个名字的赋值操作，这个名字就会在作用
对于相同的“printa”，Python竟然编译出了不同的字节码指令，在函数g中，
print
如下所示：
更为有趣的东西隐藏在编译之后的字节码中，我们可以看看上面的代码反汇编的结
理解这个错误的关键在于深刻理解最内嵌套作用域规则，这个规则的第一句话就是这
运行的结果会抛出异常，显示代码清单8-2的口]处有错，
第8章Python虚拟机框架
N
PRINT_NEWLINE
LOAD_FAST
PRINT_NEWLINE
江NTG
LOAD_GLOBAL
一深度探索动态语言核心技术
ITEM
TTEM
(a)
(a)
异常的信息为“1ocal
司
---
## Page 177
8.2.3.4
中会同时存在属性引用和名字引用，下面的例子标出了这些不同的引用：
么外围去查找，不用了，有就是有，没有就是没有，简单明了。通常在一个Pyton程序
名字引用所要遵循的LEGB规则简单多了。属性引用肚里可没那么多花花肠子，还要到什
引用就是到对象的名字空间中去查找名字，这里没有嵌套的作用域，它所要遵循的规则比
说它功能更强大了，而是说它的功能更弱了。在属性引用时，一定会有对象存在，而属性
的对象。但是属性引用可以视为一种特殊的名字引用，它不受LEGB规则的制约。这不是
printa7/输出结果：2
Bef(1:
printa//输出结果：2
看了下面两个例子，你就会对glboal语句了如指掌了：
们强制命令Python对某个名字的引1用只参考global名字空间，而不用再去管LEGB规则。
心地为我们准备了globai关键字。当一个作用域中出现了global语句时，就意味着我
但是这个赋值操作在我们的设想中应该改变外围作用域中的名字a对应的对象，Pyton精
deff():
但是有的时候，我们就是想在函数中输出外围作用域的名字a，同时还要对a进行赋值，
class A(object):
msg=hello worla
import sya
口
P
def set (self, mame）:
属性引用与名字引用
return g
defg():
global
属性引用实质上也是一种名字引用，其本质都是到名字空间中去查找一个名字所引用
中
pzinta//输出结果：1
globala
+口
江
ython源码剖析
8.2名字、作用域和名字空间
一深度探索动态语言核心技术
147
---
## Page 178
148
Python源码剖析
引用遵循的LEGB的规则不会越过module的边界。
owner，但是这对module2中的函数一点影响都没有，因为函数是在module2中，而名字
尽管module1中在调用show_owner函数之前，在module1的名字空间中引入了名字
达代码清单8-3的[2]时，发生了一次名字引用，寻找名字owner，由于名字引用是不能访
对象中的名字show_owner对应的函数对象。在调用函数的过程中，Python的执行流程到
module2对应的module对象：然后，Python通过属性引1用获得了module2对应的module
代码清单8-3
间，但是它们的结合也给初识Pyhon的人带来相当的惊奇体验。看代码清单8-3的例子。
定义的多个嵌套的名字空间（作用域）。这两种方式的结合使我们能访问任何一个名字空
就可以访问各个独立名字空间中的名字：而通过名字引用，我们可以访问本module内部
代码清单8-4
参数，我们可以修改代码，如代码清单8-4所示。
问自身mudule之外的名字空间，所以按照LEGB规则，[2]处输出的结果是moaule2。
module2.show_owner(0//[1]
a,show(False)
a.set('python)//1.
[modulel.py]
dlef show_owmer(）:
[module2.py]
owner
import module2
[modulel.py]
print owner//[2]
三A（）//对么的名字引用
在8.2.1节中提到，module为Python应用程序划分了名字空间，通过属性引用，我们
def show(self,bhow_name):
第8章Python虚拟机框架
那么有没有办法让show_owner能输出module1中的owner信息呢？有的，通过函数
在代码清单8-3的[1]处，
show_name：//对show_name的名字引用
self.name =name
else:
modulel
"module2"
一深度探索动态语言核心技术
printmeg//对msg的名字引用
//1.对a的名字引用：2.对a中show的局性引用
对a的名字引用：2.
7/1.对selE中name的属性引用2.对name的名字引用
，发生了两次引用：首先，Python通过名字引用获得了名字
对a中Bet的属性引用
---
## Page 179
8.3
际上就是Py山on的虚拟机的具体实现，它是一个非常巨大的函数，因此我们在列出其中
经站在了Python虚拟机的门槛外，只需要轻轻推动一下第一张骨牌，整个执行过程就像
过程非常地复杂，后面将用单独的一章来剖析，这里假设初始化的动作已经完成，我们已
在以后剖析运行时环境初始化时我们就能弄清楚两者的区别和联系。运行时环境的初始化
实际就是一个栈帧，是一个与某个CodeBlock对应的概念。这里不明白两者的区别不要紧
何执行源文件编译后的字节码指令序列的。
来说，谈论这些是如何实现的还为时尚早，毕竟，我们现在还不知道Pyhon虚拟机是如
实现这些形而上的“道”的呢？这些都会在随后的章节中依次展开讨论。对于现在的我们
我们就已经提到，它们只是用于指导Pyhon如何实现的“道”，Python的源码中又是如何
代码出现的位置，而非代码执行的时间。
这条规则对于理解Python的行为至关重要。正是这条规则，决定了Python行为的更多是
的字符串对象。从而使LEGB规则能够正确地引用到字符串对象“moduie1。
考函数机制一章），而其对应的对象则是从module1中传递过来的module1.owner对应
的源代码时和以前有些不同。
是一个与上一节部析的执行环境不同的概念。运行时环境是一个全局的概念，而执行环境
作为名字出现在函数的local名字空间中（机理上可以这么理解，实际实现并非如此，参
有赋值行为”的动作。什么意思呢？也就是说，函数的参数也创建了一个约束，参数名将
个名字引用，还是遵循着LEGB规则。关键之处在于，函数的参数的传递机制是一种“拥
多米诺骨牌一样，一环扣一环地展开。
def show_owmer(owmer):
module2.show_owner(owner)//[1]
Python虚拟机的运行框架
owmer=
[module2.py]
printowner//[2]
作用域和名字空间概念和规则对于理解Pyhon的运行时行为非常关键，但是，之前
这个推动第一张骨牌的地方在一个名叫PyEval_EvalFramEx的函数中，这个函数实
这又是最内嵌套作用域规则的杰作，经过对那么多实例的研究探讨，我们可以发现，
这次在代码清单8-4的[2]处输出的结果就是“module1”了。有趣的是，[2]处还是
当Python启动后，首先会进行Pyhon运行时环境的初始化。注意这里的运行时环境
module2
tatnpou,
Python源码剖析
8.3
Python虚拟机的运行框架
一深度探索动态语言核心技术
149
---
## Page 180
Python源码剖析
150
SDK编程的朋友可以想象一下Windows下那个巨大的消息循环，就是那样的结构：
指令的整体架构，其实就是一个for循环加上一个巨大的switch/case结构，熟悉Windows
序列的开始位置：next_instr永远指向下一条待执行的字节码指令的位置：_last主指
历过程中所使用的这3个变量都是char·类型的变量：first_instr永远指向字节码指令
cocode实际上是一个Pystringobject对象，而其中的字符数组才是真正有意义的东西
[ceval.c]
向上一条已经执行过的字节码指令的位置。图8-5展示了这3个变量在遍历中某时刻的情
这也就是说，整个字节码指令序列实际上就是一个在C中普普通通的字符数组。因此，遍
次执行字节码指令的过程。在Pyhon的虚拟机中，利用3个变量来完成整个遍历过程。
令的参数，Python虚拟机执行字节码指令序列的过程就是从头到尾遍历整个co_code、依
了堆栈的栈顶指针，使其指向->f_stacktop:
PyCodeobject对象包含的重要信息都被照顾到了。当然，另一个重要的动作就是初始化
Pyobject*
[PyEval EvalFrameEx in ceval.c]
那么这个一步一步的动作是如何完成的呢，我们来看一看Pyhon虚拟机执行字节码
前面我们说过，在PyCodeobject对象的co_code域中保存着字节码指令和字节码指
PyEval_EvalFrameEx首先会初始化一些变量，其中PyFrameObject对象中的
第8章Python虚拟机框架
for
f->fstacktop= NULL;
first_Instr=
names=ce->co_names1
next
freevars
f
LONXHM
一深度探索动态语言核心技术
instr
PyEval_EvalFrameEx(PyFrameObjeet
pointer
first_instr
code
f-flasti：上一条已执行的字节码在co_code中的索引
INSTR_OFESET();
图8-5遍历字节码指令序列
_atacktop:
co_code：字节码序列
remains NoLL unless yield suspends frame 
TAaPT.<-3
*E,
next_instr
---
## Page 181
对字节码指令的执行。是正常结束呢？还是因为有错误发生，实在是执行不下去了？why
时Python执行引擎的状态。因为Python执行引擎不一定每次执行都会正确无误，很有可
最终完成了对Python程序的执行。
数，完成对下一条指令的执行。如此一条一条地遍历co_code中包含的所有字节码指令
或者是for循环处，不管如何，Pyuon接下来的动作都是获得下一条字节码指令和指令参
语句。在case语句中，就是Python对字节码指令的实现。
进行判断，根据判断的结果选择不同的case语句，每一条字节码指令都会对应一个case
的那个PC寄存器。
但是无论如何，next_instr总是指向Python下一条要执行的字节码，这很像x86平台上
义无反顾地担负起这一重任。关于why在Pyhon虚拟机中作用的详细剖析，我们留到剖
所以在Pyhon退出了执行引的时候，就需要知道执行引擎到底是因为什么原因结束了
能在执行到某条字节码的时候，产生了错误，这就是我们熟悉的那个“异常”一
节码指令，由于存在是否需要指令参数的区别，所以next_instr的位移可能是不同的。
是没有参数的，而判断是否带参字节码是通过HABARG这个宏实现的。注意，对不同的字
[PyEval EvalFrameEx in ceval.c]
的尊容，请参考ceval.c中的源码。
#define NEXTARG()
define
需要提到的一点是那个名叫“why”的神秘变量，它指示了在退出这个巨大的for循环
在成功执行完一条字节码指令后，Python的执行流程会跳转到fast_next_opcode处，
Python在获得了一条字节码指令和其需要的指令参数后，会对字节码指令利用switch
在对PyCodeObject对象的分析中我们说过，Pyhon的字节码有的是带参数的，有的
在这个执行架构中，对字节码的一步一步地遍历是通过几个宏来实现的：
注意，这只是一个极度简化之后的Pyhon虚拟机的样子，如果想一睹Pyuhon虚拟机
dispatch
case
case NOP:
1f(HAS_ARG(opcode))
7/如果指令需要参数，获得指令参数
opcOdeNEXTOP（）:
INSTROFESET()
goto
LOAD_FAST:
tast_next_opcode;
NEXTARG(;
(next_instr+=2,(next_instr[-i]<<8)+next_instr[-2]x
(int(next_instr-first_instr))
instr++)
Python源码剖析
8.3
Python虚拟机的运行框架
一深度探索动态语言核心技术
-exception
151
---