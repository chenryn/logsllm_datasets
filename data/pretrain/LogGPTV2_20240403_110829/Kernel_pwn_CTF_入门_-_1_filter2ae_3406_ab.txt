>
###  3\. 调试过程
####  a. attach qemu
调试时最好使用 root 权限执行 `/bin/sh`，相关修改方法已经在上面说明，此处暂且不表。
在启动 qemu 时，额外指定参数 `-gdb tcp::1234` （或者等价的`-s`），之后 qemu 将做好 gdb attach 的准备。如果希望
qemu 启动后立即挂起，则必须附带 `-S` 参数。
同时，调试内核时，为了加载 vmlinux 符号表， **必须额外指定`-append "nokaslr"`以关闭 kernel
ASLR**。这样符号表才能正确的对应至内存中的指定位置， **否则将无法给目标函数下断点** 。
qemu启动后， **必须另起一个终端** ，键入 `gdb -q -ex "target remote localhost:1234"`，即可
attach 至 qemu上。
gdb attach 上 qemu 后，可以加载 vmlinux 符号表、给特定函数下断点，并输入 `continue` 以执行至目标函数处。
    # qemu 指定 -S 参数后挂起，此时在gdb键入以下命令
    gef> add-symbol-file vmlinux
    gef> b start_kernel
    gef> continue
    [Breakpoint 1, start_kernel () at init/main.c:837]
    ......
对于内核中的各个符号来说，我们也可以通过以下命令来查看一些符号在内存中的加载地址：
    # grep  /proc/kalsyms
    grep prepare_kernel_cred  /proc/kallsyms
    grep commit_creds  /proc/kallsyms
    grep ko_test_init  /proc/kallsyms
> 坑点1：之前笔者编写了以下 shell 脚本：
>  
>  
>     # 其他设置
>     [...]
>     # **后台** 启动 qemu
>     qemu-system-x86_64 [other args] &
>     # 直接在当前终端打开 GDB
>     gdb -q -ex "target remote localhost:1234"
>  
>
> 但在执行脚本时，当笔者在 GDB 中键入 Ctrl+C 时， SIGINT 信号将直接终止 qemu 而不是挂起内部的
> kernel。因此，gdb必须在另一个终端启动才可以正常处理 Ctrl+C。
>
> 正确的脚本如下：
>  
>  
>     # 其他设置
>     [...]
>     # **后台** 启动 qemu
>     qemu-system-x86_64 [other args] &
>     # 开启新终端，在新终端中打开 GDB
>     gnome-terminal -e 'gdb -q -ex "target remote localhost:1234"'
>  
>
> 坑点2：对于 gdb gef 插件来说，最好不要使用常规的`target remote
> localhost:1234`语句（无需root权限）来连接远程，否则会报以下错误：
>  
>  
>     gef➤  target remote localhost:1234
>     Remote debugging using localhost:1234
>     warning: No executable has been specified and target does not support
>     determining executable automatically.  Try using the "file" command.
>     0x000000000000fff0 in ?? ()
>     [ Legend: Modified register | Code | Heap | Stack | String ]
>     ──────────────────────────────────── registers
> ────────────────────────────────────
>     [!] Command 'context' failed to execute properly, reason: 'NoneType'
> object has no attribute 'all_registers'
>  
>
> 与之相对的，使用效果更好的 `gef-remote` 命令（需要root权限）连接 qemu：
>  
>  
>     # 一定要提前指定架构
>     set architecture i386:x86-64
>     gef-remote --qemu-mode localhost:1234
>  
>
> 坑点3：如果 qemu 断在 `start_kernel`时 gef 报错：
>  
>  
>     [!] Command 'context' failed to execute properly, reason: max() arg is
> an empty sequence
>  
>
> 直接单步 `ni` 一下即可。
####  b. attach drivers
#####  1) 常规步骤
首先， 将目标驱动加载进内核中：
    insmod 
之后，通过以下命令查看 qemu 中内核驱动的 text 段的装载基地址：
    # 查看装载驱动
    lsmod
    # 获取驱动加载的基地址
    grep  /proc/modules
在 gdb 窗口中，键入 以下命令以加载调试符号：
    add-symbol-file mydrivers/ko_test.ko  [-s  ] ...
> 注，与 vmlinux 不同，使用 add-symbol-file 加载内核模块符号时， **必须指定内核模块的 text 段基地址** 。
>
> 因为内核位于众所周知的虚拟地址（该地址与 vmlinux elf
> 文件的加载地址相同），但内核模块只是一个存档，不存在有效加载地址，只能等到内核加载器分配内存并决定在哪里加载此模块的每个可加载部分。因此在加载内核模块前，我们无法得知内核模块将会加载到哪块内存上。故将符号文件加载进
> gdb 时，我们必须尽可能显式指定每个 section 的地址。
>
> 需要注意的是， **加载符号文件时，越多指定每个 section 的地址越好** 。否则如果只单独指定了 .text
> 段的基地址，则有可能在给函数下断点时断不下来，非常影响调试。
如何查看目标内核模块的各个 section 加载首地址呢？请执行以下命令：
    grep "0x" /sys/module/ko_test/sections/.*
#####  2) 例子
一个小小例子：调试 ko_test.ko 的步骤如下：
  * 首先在 qemu 中的 kernel shell 执行以下命令 
        # 首先装载 ko_test 进内核中
    insmod /ko_test.ko
    # 查看当前 ko_test 装载的地址
    grep ko_test /proc/modules
    grep "0x" /sys/module/ko_test/sections/.*
输出如下：
  * 记录下这些地址，之后进入 gdb 中，先按下 Ctrl+C 断下 kernel，然后键入以下命令： 
        # 将对应符号加载至该地址处
    add-symbol-file mydrivers/ko_test.ko  0xffffffffc0002000 \
                        -s .rodata.str1.1 0xffffffffc000304c \
                        -s .symtab        0xffffffffc0007000 \
                        -s .text.unlikely 0xffffffffc0002000
    # 下断点
    b ko_test_init
    b ko_test_exit
    # 使其继续执行
    continue
  * 最后回到 qemu 中，在 kernel shell 中执行以下命令： 
        # 卸载 ko_test
    rmmod ko_tes
此时 gdb 会断到 ko_test_exit 中：
如果在卸载了ko_test后，又重新加载 ko_test，
        insmod ko_test
则 gdb 会立即断到 ko_test_init 中：
> 这可能是因为指定了 nokaslr，使得相同驱动多次加载的基地址是一致的。
上面调试 kernel module 的 init 函数方法算是一个小 trick，它利用了 **noaslr 环境下相同驱动重新加载的基地址一致**
的原理来下断。但最为正确的调试 init 函数的方式，还是得跟踪 `do_init_module` 函数的控制流来获取基地址。以下是一系列相关操作步骤：
> 跟踪 `do_init_module` 函数是因为它在 `load_module`
> 函数中被调用。`load_module`函数将在完成大量的内存加载工作后，最后进入 `do_init_module` 函数中执行内核模块的 init
> 函数，并在其中进行善后工作。
>
> `load_module`函数将被作为 SYSCALL 函数的 `init_module`调用。
  * 首先让 kernel 跑飞，等到 kernel 加载完成，shell 界面显示后，gdb 按下 ctrl + C 断下，给 `do_init_module`函数下断。该函数的前半部分将会执行 内核模块的 init 函数： 
        /*
     * This is where the real work happens.
     *
     * Keep it uninlined to provide a reliable breakpoint target, e.g. for the gdb
     * helper command 'lx-symbols'.
     */
    static noinline int do_init_module(struct module *mod)
    {
      [...]
      /* Start the module */
      if (mod->init != NULL)
        ret = do_one_initcall(mod->init);   // init` 成员即可查看到 kernel module init 函数的首地址。
  * 要想看到当前 kernel module 的全部 section 地址，可以在 gdb 中键入以下命令 
        # 查看当前 module 的 sections 个数
    p mod->sect_attrs->nsections
    # 查看第 3 个 section 信息
    p mod->sect_attrs->attrs[2]
有了当前内核模块的全部 section 名称与基地址后，就可以按照之前的方法来加载符号文件了。
####  c. 启动脚本
> 配环境真是一件麻烦到极点的事情，不过目前就到此为止了 🙂
笔者将一系列启动命令整合成了一个 shell 脚本，方便一键运行：
    #! /bin/bash
    # 判断当前权限是否为 root，需要高权限以执行 gef-remote --qemu-mode
    user=$(env | grep "^USER" | cut -d "=" -f 2)
    if [ "$user" != "root"  ]
      then
        echo "请使用 root 权限执行"
        exit
    fi
    # 复制驱动至 rootfs
    cp ./mydrivers/*.ko busybox-1.34.1/_install
    # 构建 rootfs
    pushd busybox-1.34.1/_install
    find . | cpio -o --format=newc > ../../rootfs.img
    popd
    # 启动 qemu
    qemu-system-x86_64 \
        -kernel ./arch/x86/boot/bzImage \
        -initrd ./rootfs.img \
        -append "nokaslr" \
        -s  \
        -S&
        # -s ： 等价于 -gdb tcp::1234， 指定 qemu 的调试链接
        # -S ：指定 qemu 启动后立即挂起
        # -nographic                # 关闭 QEMU 图形界面
        # -append "console=ttyS0"   # 和 -nographic 一起使用，启动的界面就变成了当前终端
    gnome-terminal -e 'gdb -x mygdbinit'
gdbinit 内容如下：
    set architecture i386:x86-64
    add-symbol-file vmlinux
    gef-remote --qemu-mode localhost:1234
    b start_kernel
    c