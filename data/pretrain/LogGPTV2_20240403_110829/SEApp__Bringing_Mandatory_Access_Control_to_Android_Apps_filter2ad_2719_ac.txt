### 5.2 SEApp Policy Structure

Developers who wish to leverage our approach to enhance the security of their applications must include the policy within their Android Package (APK). A predefined directory, `policy`, located at the root of the APK, is where the SEApp-aware package installer will search for the policy module (refer to Figure 3). This directory should contain four files, which we refer to as "local," that define a policy structure similar to that of the system. Specifically, developers can operate at two levels: (i) defining the app's policy logic using the policy language described in Section 4 (in the `sepolicy.cil` file), and (ii) configuring the security context for each process (in the `seapp_contexts` and `mac_permissions.xml` files) and for each file or directory (in the `file_contexts` file).

#### 5.2.1 Processes

Unlike system processes, a system service requires the assignment of a security context to both its processes and its Binder [17] to be fully compliant with SEAndroid. The Binder is a lightweight inter-process communication primitive that provides access to a service. The `servicemanager`, a process started during device boot-up, tracks all available services on the device. Based on the labels specified in the `service_contexts` file, SEApp allows assigning a SELinux domain to each process of the security-enhanced app. To do this, the developer lists entries in the `seapp_contexts` file that determine the security context for the processes. Valid input selectors include `user`, `seinfo`, and `name`: `user` is based on the type of UID; `seinfo` matches the app's `seinfo` tag in the `mac_permissions.xml` file; and `name` matches either a prefix or the full process name. The combination of these selectors determines a class of processes, to which the specified domain is assigned. To prevent privilege escalation, only domains defined within the app's policy module and `untrusted_app` are permitted. If a process falls into multiple classes, the most selective one, based on the input selector, is chosen.

For example, Listing 1 shows the assignment of the `unclassified` and `secret` domains to the `:unclassified` and `:secret` processes, respectively.

In Android, developers typically focus on components rather than processes. Normally, all components of an application run in a single process. However, it is possible to change this default behavior by setting the `android:process` attribute in the `AndroidManifest.xml`, thus creating a remote component. By specifying an `android:process` consistent with the `seapp_contexts` configuration, distinct domains can be assigned to different app components. The developer only needs to create the appropriate Intent object [21], as they would for remote components on stock Android. The system handles the assignment of the correct domain to the process. This design supports Android activities, services, broadcast receivers, and content providers without modifying the `PackageParser` [62], as there are no changes to the manifest schema.

#### 5.2.2 Files

The developer specifies the SELinux security contexts of internal files in the `file_contexts` file. Each entry in this file consists of three syntactic elements: `pathname_regexp`, `file_type`, and `security_context`. `pathname_regexp` defines the directory the entry refers to (it can be a specific path or a regular expression); `file_type` describes the class of filesystem resource (e.g., directory, file); and `security_context` is the security context used to label the resource. Entries must be confined to the app's dedicated directory and use types defined by the app's policy module, except for `app_data_file`. Due to regex support, a path may match multiple entries, in which case the most specific one is used. Examples of valid `file_contexts` entries are shown in Listing 2: the first line sets the default label for app files, while the second and third lines specify the labels for files in the `dir/unclassified` and `dir/secret` directories, respectively.

In SELinux, the security context of a file is inherited from the parent folder, even if `file_contexts` specifies otherwise. Since it is essential that files are labeled as expected by the developer, we enforce file relabeling at creation. A new native service has been added to the system (see Section 6.2). We also provide an alternative implementation of the `java.io.File` class, named `android.os.File`, which sets the file and directory context upon creation, transparently handling the call to our service.

#### 5.2.3 System Services

To support any third-party app, the `untrusted_app` domain grants a process the permissions to access all system services required by the app, as specified in the `AndroidManifest.xml`. For example, in Android 11, the `untrusted_app_all.te` platform policy file [28] permits a process labeled with `untrusted_app` to access services like `audioserver`, `camera`, `location`, `mediaserver`, and `nfc`.

To prevent certain components of the app from holding the privilege to bind to unnecessary system services, the developer can define a domain with a subset of the `untrusted_app` privileges (in the `sepolicy.cil` file) and ensure that the components are executed in the process labeled with it. Listing 3 shows an example where the `cameraserver` service is made accessible to the `secret` process.

### 6. Implementation

This section describes the main changes introduced in Android by SEApp. We first analyze the modifications required to manage policy modules during device boot and at app installation. We then describe how the runtime support was implemented.

#### 6.1 Policy Compilation

##### 6.1.1 Boot Procedure

Since the introduction of Project Treble [10], policy files are split among multiple partitions, one for each device maintainer (i.e., platform, SoC vendor, ODM, and OEM). This feature facilitates updates to new versions of Android by separating the Android OS Framework from the device-specific low-level software written by chip manufacturers. However, each time a partition policy (i.e., a segment) changes, an on-device compilation is required.

The `init` process divides its operations into three stages [19]: (i) first stage (early mount), (ii) SELinux setup, and (iii) second stage (init.rc). The first stage mounts essential partitions (`/dev`, `/proc`, `/sys`, and `/sys/fs/selinux`), along with other partitions specified as early mounted. Once the required partitions are mounted, `init` enters the SELinux setup stage, where it loads the SELinux policy. Since the `/data` partition, where policy modules are stored, is not yet mounted, it is not possible to integrate them with the system policy at this stage. As the last operation of the SELinux setup, `init` re-executes itself to transition from the initial kernel domain to the `init` domain, entering the second stage.

In the second stage, `init` parses the `init.rc` files and performs the built-in functions listed there, including mounting the `/data` partition. Now, the policy modules are available, and we can produce the binary policy by integrating the system policy, SEApp macros, and app policy modules using `secilc` [26]. To trigger the build and reload of the policy, we implemented a new built-in function and modified the `init.rc` to call this function right after `/data` is mounted. This ensures that the policy modules are loaded before any application starts, making the policy non-bypassable.

Although most Android devices supporting Android 10 were released with Treble support, `init` still supports the use of a legacy monolithic binary policy. For compatibility with devices using a monolithic binary policy, additional changes are required, as SEApp needs the system policy written in CIL to be compiled alongside app modules. We modified the Android build process to push the `sepolicy.cil` files onto the device, even for non-Treble devices. New entries in the device tree were added to make the policy segments available during the `init` SELinux setup stage [22].

We decided to store the policy modules in the `/data` partition, which required adapting the boot procedure but integrates smoothly with the current Android design. The `/data` partition is one of the few writable partitions and is dedicated to holding the APKs installed by the user, as well as their dedicated data directories. This makes it the best option for containing app policy modules. Additionally, a factory reset wipes the `/data` partition, removing the customization, including the apps and their policy modules.

##### 6.1.2 App Installation

As introduced in Section 5.2, developers who want to define their own policy module must include it in the app package. During app installation, the `PackageManagerService` [23] inspects the APK to identify whether the installation involves a policy module by looking for the `policy` directory at the root of the archive. If the app has a policy module attached, the `PackageManagerService` extracts it (Step 1) and uses our `PolicyModuleValidator` to verify the constraints on `sepolicy.cil` (through the `SEAppPolicyParser`, Section 4) and on the configuration files (Section 5). If the constraints are violated, the app installation stops. Otherwise, the policy module is stored within `/data/selinux`, in a directory identified by the package name (Step 2). The `PackageManagerService` then invokes `installd` [20] through the `Installer` to trigger the policy compilation with an `exec` call to the `secilc` program (Steps 3 and 4). `Secilc` reads the system `sepolicy.cil` fragments, the SEApp macros, and the `sepolicy.cil` fragments of the app policy modules in the `/data/selinux` directory (Step 5), and builds the binary policy (Step 6). When `secilc` execution returns without errors, the binary policy is read by `installd` (Step 7) and loaded with `selinux_android_load_policy`, which writes the `sys/selinux/load` file (Step 8).

To load the policy files after `init`, the SELinux implementation in Android has been slightly modified. Specifically, we modified the policy loading function within `libselinux` (function `selinux_android_load_policy`) and changed the system policy to allow `installd` to load the app policy module. For the policy configuration files, some changes were introduced to properly load the application `file_contexts`, `seapp_contexts`, and `mac_permissions.xml`. The `SELinux-MMAC` [27], responsible for loading the `mac_permissions.xml` file and assigning `seinfo` values to APKs, was modified to load the new `mac_permissions.xml` specified within the app policy module. The loading of `file_contexts` and `seapp_contexts` was configured to treat system and app configuration files separately. SEApp-enhanced applications will load exclusively their configuration files, while the loading of system and other apps' configuration files is prohibited. System services and daemons, however, load the base system configurations once and then load the app policy module-specific configuration files as needed. Examples include the `Zygote` and `restorecon` services, which need to retrieve `seapp_contexts` and `file_contexts` at runtime (see Section 6.2).

Our implementation also supports the uninstallation of SEApp apps. The regular uninstallation process is extended with a step where the global policy is recompiled to remove the impact of old modules on the overall binary policy. For application updates, the native `installd` runs with the necessary permissions to remove and apply new file types based on the content of the `file_contexts`.

#### 6.2 Runtime Support

In addition to the steps described above, other aspects must be considered to extend SELinux support at the application layer.

##### 6.2.1 Processes

Android application design is based on components, each of which lives inside a process and serves as an entry point for the system or the user to interact with the app. To activate a component, an asynchronous message called an intent, containing both the reference to the target component and the parameters needed for its execution, must be created. The intent is then routed by the system to the `ActivityManagerService` [12] via Binder IPC. Before delivering the intent request to the target component, the `ActivityManagerService` checks if the process in which the target component should be executed is already running. If not, the native service called `Zygote` [29] is executed. `Zygote` spawns and correctly sets up the new application process by first replicating itself through a `fork`, then using the input provided by the `ActivityManagerService` (such as package name, `seinfo`, `android:process`, etc.) to configure the process GID, seccomp filter, UID, and finally the SELinux security context. We adapted the final configuration step, forcing `Zygote` to set the security context based on the `seapp_contexts` located at `/data/selinux/packageName` (i.e., the one provided by the developer for their app). The process name is used to assign the proper context to the process when it starts, before the process logic begins. If the developer did not specify a domain, `Zygote` uses the system `seapp_contexts` as a fallback. After the correct labeling, the `ActivityManagerService` completes the configuration by binding the application class, launching the component, and delivering the intent message. Figure 5 details the process.

This implementation design offers several benefits, including backward compatibility, support for all components, and ease of use. Developers who want to use our solution only need to configure some files, with minimal changes to the application code, facilitating the introduction of SELinux in existing apps.

We also explored other design alternatives where the developer could explicitly state a domain transition in the code. Although this would give developers more control over domain transitions, it has some drawbacks. First, the developer would need to manage the isolation between source and target domains in a multi-threaded scenario. Second, this design implies granting too many permissions to the app (e.g., `dyntransition`, `setcurrent`, and read/write access to `selinuxfs`). Moreover, such a solution would introduce a new Android API, which, if not used correctly, could be difficult to control.

##### 6.2.2 Files

Android applications aiming to create a file can use the `java.io.File` abstraction. Each file creation request generated by the application is captured by the Android Runtime (ART) [15] and converted into the appropriate syscall. The result is that the file is created with the correct security context. To ensure that files are labeled as expected by the developer, we enforce file relabeling at creation. A new native service has been added to the system (see Section 6.2). We also provide an alternative implementation of the `java.io.File` class, named `android.os.File`, which sets the file and directory context upon creation, transparently handling the call to our service.

Figure 6 illustrates the file relabeling process.