capability-based access control for web origins to restrict
access by web content to the functionality of the JavaScript
bridge. Along the same lines, NoInjection [38] adds saniti-
zation to the bridge of PhoneGap to prevent code injections.
Morbs [35] proposes an extension to the Android application
framework to attach origin information on ICC channels that
can cross origin between apps, thus enabling apps to apply a
same-origin policy and prevent the reported cross site scripting
and request forgery attacks. Additionally, different modiﬁca-
tions to the Android WebView and Android IDEs have been
discussed [35], [39], such as supporting whitelisting of web
origins that have access to the JavaScript bridge; displaying
the security of WebView connections to the end user; or lint
tools to warn app developers about insecure TLS certiﬁcate
validation in WebViews.
3) Actors’ Roles: Fundamentally, platform developers are
required to integrate better isolation of web origins in Web-
Views and support origin-based access control on data ﬂows
(R1. ). Additionally, providers of web app frameworks and
app publishers are responsible for securing their web-to-app
and app-to-web bridges (R4.
and R6. ).
4) Lesson Learned: The trend towards web apps and usage
of web technologies lowered the hurdle for writing apps even
more. However, some of the same mistakes known from web
applications in browsers were replicated and new problems
arose. Cross-origin and web-to-app/app-to-web vulnerabilities
constitute serious security challenges for the move towards
web apps. However, since such issues are ﬁxable by platform
developers and do not require tens of thousands of developers
or millions of end users to adopt new security mechanisms,
we think this trend is worth pushing in the future.
Our assessment (Webiﬁcation): Using standard web
technology for building apps has proven satisfactory, if
somewhat initially shaky. After well-known web security
issues have been ﬁxed and integrated with the platform’s
app sandboxing, this trend should continue.
D. Programming-induced Leaks
This section deals with challenges and countermeasures
regarding data leaks caused by developer errors for apps,
frameworks, and libraries.
1) Challenges: Android provides a comprehensive set of
APIs for app developers. A fraction of these APIs are security-
related and provide interfaces for Android’s permission sys-
tem, secure network protocols and cryptographic primitives.
Prior work has investigated the quality of security-related API
implementations: Fahl et al. [40] investigated security issues
with customized TLS certiﬁcate validation implementations in
Android apps and found widespread, serious problems with
how developers used TLS. In follow-up work, they conducted
developer interviews to learn the root causes of misusing
Android’s integrated TLS API and found that the current API
is too complex for many developers [42]. Although Android
provides safe defaults, in ≈95% of the cases app developers
decided to implement customized certiﬁcate validation mech-
anisms, the result being an active MITMA vulnerability.
An analysis on the programming quality of cryptographic
primitives such as block ciphers and message authentication
codes in Android apps by Egele et al. [43] found that 88% of
the analyzed apps made at least one mistake when using those
primitives. The authors came to the conclusion that Android’s
default conﬁguration for cryptographic primitives is not safe
enough and that the API documentation in this area is poor.
It was also found that apps load code via insecure channels
(e.g., http) without veriﬁcation of the loaded code [30]. Of
the hereby analyzed apps, 9.25% are vulnerable to insecure
code loading, meaning attackers can inject malicious code into
benign apps and turn them into malware. The authors came to
the conclusion that this is an API issue, since Android’s API
does not provide secure remote code loading.
2) Countermeasures: MalloDroid [40] is a static analysis
tool to detect broken TLS certiﬁcate validation implementa-
tions in Android apps. Fahl et al. [42] propose a redesign
of Android’s middleware/SDK to prevent developers from
willfully or accidentally breaking TLS certiﬁcate validation.
SMV-Hunter [41] is a similar approach, additionally applying
dynamic code analysis techniques. CryptoLint [43] is a static
analysis tool
to detect misuse of cryptographic APIs on
Android. CHEX [22] is a static analysis tool to automatically
detect component hijacking vulnerabilities. ScanDroid [80] is
a modular data ﬂow analysis tool for apps, which tracks data
ﬂows through and across components. AndroidLeaks [81] is
a large-scale analysis tool to detect privacy leaks in apps
with the intention to reduce the overhead for manual security
audits. FlowDroid [82] applies static taint analysis techniques
to detect (un-)intentional privacy leaks in Android apps.
3) Actors’ Roles: Apps that misuse the above security
related APIs leave their apps vulnerable to other apps installed
on the device (C2. ),
to malicious dynamic code loading
(C5. ) or network attacks (C6. ).
A common conclusion of the above API misuse studies
is that Android’s API design does not provide safe defaults
(A1. ) in many cases [43]) and when it does, these defaults
often do not match the average developer’s needs [42] (A4.
,
A5. ). A study to identify the root causes of these issues
conducted with Android developers [42] suggests a redesign
of existing security related APIs with the developer’s needs
445445
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:11:39 UTC from IEEE Xplore.  Restrictions apply. 
in mind (R1. ). Better toolchain support to support secure
API usage (R7. ) could help the developers of apps (R5. )
and library providers (R4. ) to write more secure code. App
markets (R3. ) could run analyses on apps to prevent insecure
apps from being installed on end users’ devices.
4) Lesson Learned: Previous research uncovered numerous
programming issues. A high number of (new) developers code
(mobile/web) apps, and security APIs seem to pose a severe
challenge for many of them. Developer interviews illustrated
that many inexperienced developers write (mobile/web) apps
and struggle to provide the basic functionality, which leaves
no room for security and privacy considerations. Many of the
provided security APIs allow for very detailed conﬁgurations,
which seem to overwhelm the average developer and result
in insecure/improper selection of security options. Developers
are on the front line of the security battle and many of them
are currently overburdened. However, user studies with de-
velopers [42] illustrate that platform developers could modify
the current API design to achieve better security by making
APIs more developer-friendly. We argue that it should become
common practice to use developer studies to test and improve
security and privacy APIs.
Our assessment (Programming-induced Leaks): Ex-
isting work on redesigning and simplifying usage of
APIs and security-related tools should be extended and
complemented by research on currently unexplored areas
of developer usability.
E. Software Distribution
Software distribution in the appiﬁed world has changed from
a decentralized to a centralized model.
1) Challenges: Android’s ecosystem has piqued the interest
into investigating the impact of its software distribution chan-
nels for the protection of end users against malicious apps. A
second challenge is the protection of app developers against
common problems such as piracy.
a) App Piracy and Malware Incentives: Pioneering work
investigated the incentives of malware developers and the state
of malware for modern smartphone operating systems like
iOS and Android [46]. The authors discovered that the most
common malware activities were collecting user information
and sending premium-rate SMS messages. This work predicted
that in the future, with proliferation of the app markets and
advertisement networks for mobile platforms, ad fraud will
be a major incentive for malware authors. This prediction
has been proven accurate by different follow-up studies [47],
[32], [48], [49], [50], [29]. With the exception of a dedicated
malware detection analysis [32], these studies focused on re-
packaged (also noted as cloned [49], [50] or piggybacked [48])
apps, which have been identiﬁed as a major malware distri-
bution method. The common bottom-line of all works (except
one [32]) is that markets contain a noticeable number of re-
packaged apps. Although all studies found trojan-like malware
in the markets, the vast majority of re-packaged apps have been
modiﬁed to siphon ad revenue from the original app authors
(e.g., by exchanging the ad lib or ad identiﬁer), thus suggesting
that plagiarists of apps are ﬁscally motivated. Hence, this
majority of re-packaged apps is not strictly malware in the
sense that they harm the end user, but instead ﬁnancially harm
the affected app developers [50].
The implication of this research is that besides the known
open challenge of protecting end users from malware dis-
tributed over markets, another pressing issue is the protection
of app developers against plagiarism. Both are important
factors in maintaining a healthy appiﬁed ecosystem, which
needs to be achieved primarily by app markets. A particular
challenge towards this goal is that plagiarism not only occurs
within a market, but also across markets. To ﬁght plagiarism,
some alternative markets like Amazon’s App Store require
the app developers to participate in their DRM solutions—
with limited success [106]. Moreover, the technical enabler
for re-packaging apps has to be considered: Android apps
are signed by their developers and the signature is used to
verify install-time integrity of the installation package and to
implement a same-origin update policy. Thus, app developer
certiﬁcates can be (and are, by default) self-signed certiﬁcates
whose signature of app packages can be simply replaced with
a new signature. This allows re-packaging of apps with a low
technical knowledge and effort.
b) Application Signing Issues: Recent work [7] brought
up the central role of app markets in appiﬁed ecosystems as a
new threat for their users. Due to their central role and power
when distributing apps, app markets have enormous potential
to cheat on their users by withholding apps or updates. A
central security mechanism for software distribution is the
prior mentioned app signing with self-signed certiﬁcates. In-
vestigations [11], [7], [84] illustrate that the way app develop-
ers and publishers handle the current app signing mechanism
undermines the mechanism’s intention: Many developers and
publishers use one single key to sign up to 25,000 apps.
Without having effective revocation mechanisms at hand, such
practices are a serious threat to Android users. For instance,
Android allows developers to deﬁne permissions that are only
available to apps with the same origin (i.e., signing key) in
order to establish secure ICC. This same-origin assumption
(and with it secure ICC) is defeated by these inappropriate
app certiﬁcation practices.
2) Countermeasures: Different market-enabled solutions
have been proposed to address the malware problem: Me-
teor [83] addresses security issues arising from multi-market
environments by providing the same security semantics as
for single-markets (e.g. kill switches and developer name
consistency). MAST [84] ranks apps based on their attributes
and helps targeting scarce malware analysis resources to apps
with highest potential of being malicious. Application Trans-
parency [7] addresses Android’s application signing issues. It
introduces different kinds of cryptographic proofs that allow
users to verify the authenticity of apps offered on app markets.
Naturally, different analysis methods evolved to identify
malware: DNADroid [49] is an approach to detect pirated
apps in markets by applying program dependency graphs
446446
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:11:39 UTC from IEEE Xplore.  Restrictions apply. 
for methods in candidate apps. RiskRanker [85] proposes a
proactive zero-day malware detection. CHABADA [86] takes a
different approach from the prior malware detection tools by
relying on anomaly detection: by grouping apps from same
categories (e.g., games) by their protected API usage patterns,
malicious apps stick out as outliers from those sets.
Ernst et al. [87] divert from the adversarial trust assumptions
between app vendor and market operator in prior works by
relying on a collaborative veriﬁcation. Assuming that benign
developers will co-operate by annotating their code such that
it can be effectively veriﬁed, while malicious apps can be
reliably rejected, this could enable high-assurance app stores.
AppInk [89] aims at deterring app repackaging through
dynamic watermarking of apps. Through an IDE extension,
app developers can encode watermarks as triggerable code in
their app that can be checked dynamically by a companion
app to conﬁrm authorship.
3) Actors’ Roles: Platform developers (A1.
, R1. ) are
responsible for ﬁxing key signing issues and allowing for
secure distribution of apps in the ecosystem, for instance,
distribution of encrypted application packages and full support
for PKIs. Additionally, end users (R8. ) could run malware
detection software on their devices. However,
this would
require more effective support for malware detection from the
platform developers (see Section IV-B).
App markets (A3.
, R3. ) with their central role in the soft-
ware distribution process have an enormous impact on security.
To prove their correct operations, they can add accountability
, R5. ) and
features [7]. However, also app developers (A5.
, R6. ) bear full responsibility for misusing
publishers (A6.
app signing recommendations and have the potential to ﬁx
these issues in the future.
4) Lesson Learned: Appiﬁcation has created an interesting
paradigm shift here. Software distribution and installation have
become highly centralized. Users typically go to a single app
market to search for and install their apps. With their central
role in the appiﬁed ecosystem, app markets’ impact on overall
security is enormous. They serve as a line of defense in the
ﬁght against malware and could also implement one or more
of the many proposed app vetting technologies to protect their
users against buggy apps. On the other hand, app markets can
also serve as powerful attackers against their own users. They
can act as malware distributors or withhold apps or updates.
Although app markets are in a very powerful position, not
many of the security and privacy mechanisms proposed by
researchers have been adopted by app markets as of today.
However, when it comes to privacy, it is potentially not in
the best interest of an app market to protect its users. App
markets’ major motive is monetization by selling apps to their
users. As was shown in our systematization, particularly the
solutions proposed by researchers to improve users’ awareness
and control of privacy issues often would require the app
markets’ cooperation. However, less installs and less lucrative
advertising potential could potentially harm app markets’
interests. Thus, one result of our work is that researchers
should look for additional actors in the ecosystem that could
assist in improving users privacy. In particular, app publishers
and generators as a strongly emerging pattern for software
distribution [7] have not yet received any attention, although
their inﬂuence on the ecosystem can be considerable. It is
unclear to which extent publishers and app generators are
trustworthy or are harming the security of apps (e.g., following
security best practices) and the privacy of users (e.g., adding
tracking code).
Our assessment (Software Distribution): Centralizing
software distribution has proven successful for protecting
end users against malicious software and for ﬁghting
piracy, and should be retained. The threat of malicious
app markets is manageable, with countermeasures (al-
most) ready to be deployed for market-scale application
sets. Trustworthiness of app publishers and generators as
emerging actors has to be evaluated and established.
F. Vendor Customization/Fragmentation
Fragmentation in appiﬁed ecosystems is a wide spread phe-
nomenon since many hardware and software vendors compete
for the customer base in the ecosystem.
1) Challenges: The Android ecosystem is fragmented at
two different levels: First, Android devices are shipped with
different OS versions customized by different vendors. Second,
vendors ship their devices with custom system apps. Different
works investigated the impact of vendor customizations on the
permission enforcement on Android [24], [15], [51], [52], [53]
that led to a large number of overprivileged system apps [15].
Moreover, vendor customization signiﬁcantly increases the
phone’s attack surface. Vendors introduce higher-privileged
apps that act as confused deputies [52] or misconﬁgurations
at framework layer [53], both of which allow unprivileged
apps access to protected functionality. Recently, the impact
of vendor customizations of the device drivers [107] has
been investigated and the study reports very similar results:
customizations of Android to ﬁt the vendor-speciﬁc hardware
have signiﬁcantly increased the attack surface of the platform
and provided attackers access to highly sensible functionality.
2) Countermeasures: As of today no research has been
conducted to investigate countermeasures to challenges that
stem from fragmented appiﬁed ecosystems.
3) Actors’ Roles: Vendor customizations, and thus device
vendors, are responsible for the security degradations caused
by fragmentation and customization (A2.
, R2. ).
4) Lesson Learned: Android’s open ecosystem, in contrast
to tighter controlled ecosystems like Apple’s iOS, allows
vendor customization and fosters the fragmentation that comes
along with such customizations. Hence, Android’s ecosystem
illustrates the potential security risks that such an open ap-
proach can induce and should be a warning to concurrent or
future appiﬁed platforms.
Another lesson to be learned from Android is encouraging
vendors to use (system) apps instead of OS patches to provide
custom hardware support and force Android to become more
modular. Forcing vendors to patch the OS was mainly driven
447447
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:11:39 UTC from IEEE Xplore.  Restrictions apply. 
by having only two different privilege levels for apps: system
and third party. Eliminating the need for OS patches and
allowing vendors to deﬁne more privilege levels to integrate
customization purely at user space level could reduce frag-
mentation and drastically reduce the attack surface caused by
OS modiﬁcations. Although prior works found that vendor app
developers make the same mistakes as third-party developers,
e.g., over-requesting permissions, bugs in more privileged
vendor apps could be more efﬁciently ﬁxed via the standard
app update mechanism in contrast to OS updates. Since vendor
app and third party app developers presumably make the same
classes of errors, efforts to ﬁx those error classes could be
focused instead of having to ﬁght two challenges—apps and
OS patches.
Our assessment (Vendor Customization/Fragmenta-
tion): Allowing different vendors to customize their
devices fueled the adoption process of Android as an
appiﬁcation platform. However, customizing the OS core
raised new challenges for platform developers and device
vendors. Hence, future fragmentation should focus on
system apps rather than OS patches.
G. Software Update Mechanism
Due to centralization of software distribution, app updates
are straight forward and can be pushed to millions of users si-
multaneously. However, fragmentation of the ecosystem makes
OS updates very challenging.
1) Challenges: Application life-cycles are very fast paced
and updates for actively maintained apps are published in
high frequency to markets [29] from where automated update
mechanisms distribute them to end users. This is even pushed
forward with centralizing updates of security critical libraries
such as WebView. In contrast, the situation at OS and appli-
cation framework level is rather bleak. Thomas et al. [108]
present a ﬁeld study of 20,400 Android devices to measure
the prevalence of Android platform speciﬁc bugs in the wild.
They deﬁne a metric to rank the performance of device
manufacturers and network operators, based on their provision
of updates and exposure to critical vulnerabilities. Their central
ﬁnding is a signiﬁcant variability in the timely delivery of
security updates across different device manufacturers and
network operators, since at least
87% of all investigated
devices were vulnerable to at least 11 different vulnerabilities.
In addition, the complexity of upgrading the Android OS
version induced problems in the permission management
across OS versions [51]. This attack class is currently unique to
permission-based mobile systems, such as Android, since the
attacker does not corrupt the current system or update image,
but instead strategically requests permissions and attributes
that are available on the future OS version.
2) Countermeasures: No research has thus far investigated
countermeasures for challenges that stem from software update
mechanisms as implemented on Android. Apart from research,
Google has with their latest Android versions changed their
update strategy for their Nexus devices [109], [110]. It remains
to be seen if other vendors adopt this strategy. Moreover,
the SecUp [51] app can detect apps that exploit the above
mentioned privilege-escalation attack through OS updates.
3) Actors’ Roles: Providing OS updates is responsibility
of device vendors (A2.
,
R1. ) are responsible for introducing the upgrade privilege
escalation attack.
, R2. ). Platform developers (A1.
4) Lesson Learned: Many researchers expect the platform
developer to implement their countermeasures. However, even
if that should happen—which is rare, as of today devices
are not long-term and frequently maintained by vendors ex-
cept Google—this expectation is causing slow adaption of
new mechanisms and contributes to the fragmentation of
the ecosystem [5], [108]. This also opens a large window
of opportunity for attackers to compromise the system. In-
terestingly, appiﬁed platforms like Android already have a
modularization of software at the application layer. This is
inspired by classical high-assurance systems like EROS [111]
and in fact, the Binder IPC of Android establishes something
like a microkernel-like concept on top of the Linux kernel in
userspace. We would like to see this modularization extended
to allow modular updates of the system so that security updates
can be deployed faster to the end user without requiring a full
system update. This is an area where appiﬁed platforms are
way behind traditional operating systems.
Our assessment (Software Update Mechanism): Since
most proposed countermeasures rely on OS updates, and
OS fragmentation make these very cumbersome, the plat-
form developers should create better update mechanisms,
so that security ﬁxes and countermeasures can be more
easily deployed.
V. CONCLUSION
The central conclusion we draw from this systematization
is that, like many new technologies, Android is a story of both
victory and defeat. New security mechanisms were introduced
without a clear understanding of how these applications would
be developed and used, and well-established security mecha-
nisms were re-used to meet the expected security needs of the
new general purpose computing platform. Some of the these
techniques were a great success, while others failed almost
entirely. We draw the following meta-conclusion:
Our meta-assessment: Some aspects worked out beau-
tifully, e.g., centralizing software distribution helps to
tackle critical security issues and makes ﬁghting piracy
and malware easier. Other approaches had initial difﬁcul-
ties, but are now more or less on track after research has
helped to identify and bridge them. Examples comprise
easier-to-use APIs that have started to replace hard-to-use
but well-intended security APIs over the last few years, as
well as the concept of Webiﬁcation that has enabled more
developers to produce their own apps. However, some
approaches should be re-thought from the beginning and
448448
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:11:39 UTC from IEEE Xplore.  Restrictions apply. 
arguably abandoned for designs of future OSes: Permis-
sion dialogs for end users should be removed entirely,
since they failed for the same reasons warning messages