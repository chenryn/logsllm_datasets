hread_read is invoked, the binder driver ﬁrstly ﬁnds out the
return_error’s state is abnormal and return this error state
to servicemanager’s user space. In the end, servicemanager
exits and restarts after receiving this error state from the
binder driver.
The process /system/bin/keystore hosts the system ser-
vice android.security.keystore and registers it in servicem-
anager when the process starts. Namely, this system service
would not be registered in servicemanager if this process
is started earlier than servicemanager, or servicemanager
restarts while this process does not. When the vulnera-
bility causes servicemanager to restart, the process /sys-
tem/bin/keystore is not aﬀected. Therefore, the system ser-
vice android.security.keystore cannot be registered in ser-
vicemanager again unless a fresh restart of the system. Since
any app that wants to communicate with a system service
must get the handler from servicemanager, and the system
service android.security.keystore is not registered in service-
manager now, no app can use this system service.
The system service android.security.keystore is responsi-
ble for the key’s operation in Android system. Hence, any
action which is related with key’s operation cannot be done,
such as uninstalling any app and adding a new user, or the
system would crash. Furthermore, two items in Settings app
cannot be clicked, or the app Settings would crash. These
items include Security and VPN sub-item in the item More.
This vulnerability was found manually. When reading the
source code of servicemanager, we found that the ﬂag of the
request sent by each function is zero, i.e., servicemanager
needs to return a result. We wondered what would hap-
pen to servicemanager if the ﬂag was one. After sending a
hand-craft malformed input to servicemanager, we found it
crashed. Then we analyzed the source code of serviceman-
ager and the binder driver by hand and ﬁgured out the root
cause of this. In the meanwhile, the eﬀect of serviceman-
ager’s restart on the system service android.security.keystore
was also discovered.
4.4.3 Vulnerability in WiFi System Service
Figure 4: Attack a system service
Because this method invokes the fake interface to encapsu-
late the parcel with a descriptor string of the fake interface,
but the remote real interface is implemented by the system
service X (represented by the token in the IBinder object).
When the system service checks the descriptor string in the
parcel object, it ﬁnds out the diﬀerence and throws back a
SecurityException to the system service A. Figure 4 illus-
trates the whole process.
The ﬁrst vulnerability of this kind was found by analyz-
ing the code generated by the AIDL system and crafting the
malicious interface manually. Then we put the generated
methods of this kind of malformed argument into buzzer.
After testing all the system services in Android system with
buzzer, we found several system services are vulnerable. Ta-
ble 1 displays these system services with the name, the target
vulnerable method and the interface name.
These system services have 10 vulnerabilities classiﬁed
into the same kind. The vulnerabilities could lead to dif-
ferent results, crashing diﬀerent processes where the sys-
tem services run. These processes include system server,
com.android.settings and so on. Furthermore, diﬀerent vul-
nerabilities have diﬀerent triggered conditions. They all de-
pend on the related interfaces’ functions.
The vulnerabilities in the system service display and mount
could crash the system services without any further opera-
tion, as the interfaces in both system services are directly in-
voked when the requests are received. The trigger conditions
of the vulneraibilities in the other vulnerable system ser-
vices are listed as follows. The system service launcherapps
– the apps displayed in the launcher are changed. Namely,
this vulnerability could prevent the system from uninstalling
any app. The system service bluetooth manager – the blue-
tooth’s state is changed. The malicious app needs to request
the permission BLUETOOTH. The system service ﬁngerprint –
the app sends a succeeding request to this system service.
For example, the request could be sent for removing a ﬁn-
gerprint id number. More details about this system service
would be illustrated in section 4.4.6. The system service
window – the device’s screen orientation is rotated. The
system service lock settings – the user changes the settings
of the screen lock. The system service wallpaper – the wall-
paper is changed. The system service audio – the routing
of media channels and streams from the current device to
external speakers and destination devices is changed, such
as plugging in a headset or headphones.
In summary, the trigger of this kind of vulnerability de-
pends on the functions in the interfaces. The vulnerability
366
Service Name
Target Vulnerable Method
Interface
Table 1: Aﬀected system services and the interfaces
bluetooth manager
bluetooth manager
launcherapps
lock settings
wallpaper
ﬁngerprint
window
display
mount
audio
registerAdapter
android.bluetooth.IBluetoothManagerCallback
registerStateChangeCallback
addOnAppsChangedListener
android.bluetooth.IBluetoothStateChangeCallback
android.content.pm.IOnAppsChangedListener
registerObserver
getWallpaper
startListening
watchRotation
com.android.internal.widget.ILockSettingsObserver
android.app.IWallpaperManagerCallback
android.service.ﬁngerprint.IFingerprintServiceReceiver
android.view.IRotationWatcher
createVirtualDisplay
android.hardware.display.IVirtualDisplayCallback
mountObb
startWatchingRoutes
android.os.storage.IObbActionListener
android.media.IAudioRoutesObserver
Nowadays, Android devices including Nexus 6 and Nexus
9 support dual-band WiFi, i.e., 2.4GHz and 5GHz. There-
fore, Android system allows users to choose diﬀerent band
in these devices. By default, WiFi band number could only
be one of the three values: 0(Automatic), 1(5GHz) and
2(2.4GHz). When the band number is greater than two,
WiFi system service cannot ﬁnd any frequency band related
with the number and then the device cannot connect to any
WiFi AP. This vulnerability has been mentioned in section
2.2. The exploitation of this vulnerability could set the band
number greater than two. However, this is not the whole
scene. There is also a vulnerability in the app Settings. Af-
ter the band number has been set greater than two, if the
user chooses to modify the frequency band in Settings, this
app would crash. With the combination of the two vulnera-
bilities, an attacker could make the device never connect to
a WiFi AP successfully.
The vulnerability in Settings locates in the class Advanced-
WifiSettings. Listing 2 shows the vulnerable method of
this class. The index is obtained from the system service
wiﬁ. The string array summaries is gained from the resource
ﬁle arrays.xml. It has only three items: “Automatic”, “5 GHz
only” and “2.4 GHz only”. Consequently, when the index
number is greater than two, an exception StringIndexOut-
OfBoundsException would be generated. The exception is
not handled, so the app Settings crashes.
P r e f e r e n c e f r e q u e n c y B a n d P r e f ,
summaries = g e t R e s o u r c e s ( ) .
i n t i n d e x ) {
Listing 2: The vulnerable method
1 private void updateFrequencyBandSummary (
2
3 S t r i n g [ ]
4
5
6 f r e q u e n c y B a n d P r e f . setSummary ( summaries [ i n d e x ] ) ;
7 }
g e t S t r i n g A r r a y (
R. a r r a y . w i f i
f r e q u e n c y b a n d e n t r i e s ) ;
In summary, with the vulnerability in WiFi system ser-
vice, WiFi frequency band could be set any number by send-
ing the request to the system service wiﬁ. Then, if the band
number is greater than two, the device loses connection with
a WiFi AP and the setting item in the app Settings can-
not be opened which results in that the user cannot change
the WiFi band. Namely, the combination of the two vul-
nerabilities makes the device never connect to a WiFi AP
successfully.
The vulnerability in WiFi system service was found by
running buzzer to test this system service. We found the
device could not connect to a WiFi AP even after a fresh
reboot of the system. Then we analyzed the log messages
367
and recorded the methods which were tested. After reading
the source code of this system service again, we surmised
the target methods and ﬁgured out the vulnerable method.
4.4.4 Vulnerability in Search System Service
The system service search is responsible for the search
UI, and maintains a registry of searchable activities. Since
Android 5.0, a new method launchAssistAction has been
added to the system service search. This method is used
to ask the system to start an activity that accepts the ac-
tion ACTION_ASSIST. The system of Google’s Nexus image
contains Google’s Android apps and it has a system app
named com.google.android.googlequicksearchbox. This app
has an activity which accepts the intent whose action is AC-
TION_ASSIST. Therefore, if an attacker constantly sends a
request to the system service search to invoke this function,
the target activity in this app would be called. Then, the
whole screen would be nearly frozen and the user cannot
click anything. The battery would be exhausted and the
device would power oﬀ, unless the power button is pressed
and not released until the device reboots.
This vulnerability was found by hand. Because the vul-
nerable method always causes the UI to be covered by the
search activity, we thought that if this method was con-
stantly invoked, perhaps the UI could not be used. By uti-
lizing buzzer to send requests to the speciﬁc method contin-
ually, our thought was proved right with this vulnerability
found.
4.4.5 Vulnerabilities caused by NULL reference
The method registerClient in the system service me-
dia.audio policy doesn’t validate whether the incoming ar-
gument is NULL and uses this argument directly. If this ar-
gument is NULL, this system service would crash. This sys-
tem service runs in the process /system/bin/mediaserver.
The crash of this system service would lead to the crash
of this process. Then this process would be restarted by
the process init. Some other system services including me-
dia.audio ﬂinger, media.player, media.camera and media.so-
und trigger hw, also run in this process. Therefore, these
system services are unavailable if this process crashes. Namely,
the user cannot watch video, listen to music and use the
camera if this process crashes. So a malicious app could
constantly send a request to crash the system service me-
dia.audio policy and the process /system/bin/mediaserver,
and then any app related with the system service media.*
cannot be used. The method decode in the system service
media.player has the same vulnerability. The exploitation
of this vulnerability and the result are also the same.
The method getActiveConfig in the system service Sur-
faceFlinger has the same vulnerability that it doesn’t check
whether the incoming argument is NULL and uses this argu-
ment directly. This system service runs in the process sys-
tem_server. Thus, the crash of this system service would
result in that the whole system seems to restart.
In summary, the exploitation of the three vulnerabilities
in these system services could crash these services and their
hosting processes. Furthermore, the malicious app does not
need to request any permission.
These three vulnerabilities were found by buzzer auto-
matically. Because the eﬀect of these vulnerabilities was
obvious, it was easy for us to ﬁgure out the target vulnera-
ble methods from the log messages. There is a trick in the
exploitation of the vulnerability in the system service me-
dia.player. Buzzer puts nothing in the request’s data and
the target system service gains a string from the function
Parcel.readCString(). This function does not return an
empty string like the function Parcel.readString8() and
Parcel.readString16(). It returns a NULL string value. In
this way, the target system service obtains the NULL string
which results in the crash. Therefore, the design of this
function Parcel.readCString() might be reconsidered.
4.4.6 The other defects
Android 5.0.1 has 96 system services, but some of them
are not used in some devices, such as the system service
consumer ir (control infrared rays in the Android device)
in Nexus 6 and 9, the telephony-related system services in
Nexus 9 (WiFi version). Besides, some system services have
the permission-checking function with the function body not
implemented, which leaves a hidden hazard in this system
service. For instance, the system service ﬁngerprint has
no hardware supported in the kernel and its permission-
checking function checkPermission has no function body
which should check whether the app has the permissions
USE_FINGERPRINT and ENROLL_FINGERPRINT. With the vul-
nerability described in section 4.4.1, a malicious app with-
out requesting any permission could send a request with the
argument of the fake interface android.service.finger-
print.IFingerprintServiceReceiver to this system ser-
vice. When the attacker sends another request to the system
service ﬁngerprint to remove a ﬁngerprint id, this system
service would crash as nativeRemove function just returns
an error number.
In summary, the system should reduce
these kinds of system services which results in the decrease
of the attack surface.
Some other system services could annoy users if these sys-
tem services are abused by the attacker. For instance, the
system service statusbar manages the status bar on the An-
droid device’s screen. A method of this system service could
let the screen show the recent apps. This could be abused
to annoy users if a malicious app constantly sends a request
to invoke this method. However, if the recent apps’ list
is empty, the abuse has no inﬂuence. The methods in these
system services, which annoy users, do not need the attacker
to request any permission.
4.5 Responses from Google
We notiﬁed Google of these vulnerabilities and provided
them with all the technique details. After analyzing our
report, Google security team created tracking numbers for
these issues. The tracking numbers are ANDROID-20076875,
ANDROID-20643294, ANDROID-21117978, ANDROID-215-
23339, ANDROID-21585255 and ANDROID-22489397. We
also obtained ﬁve CVE-IDs from them. Moreover, we would