methodologies to measure the time intervals in TDC de-
pending on the requirements on the measurement resolution.
For example, the coarse counter method [2] works well at the
nanosecond resolution level, while the “ﬁne” measurement [9,
10] provides much better resolution but smaller measuring
range. Generally, the GPU CUDA core runs at GHz level,
and the frequency measurement should have the strong ca-
pability to recognize the core frequency variations across the
GPU chip which will largely aﬀect the robustness of our key
generation. We thus choose the “ﬁne” measurement method
whose resolution can achieve as high as 1 picosecond [9, 10].
Note that the TDC is usually composed of inverters, which
is quite simple to be implemented in the integrated circuit
technology, and has negligible area and power overhead to
the GPU chip.
Fingerprint Generation. The next step is to convert the
measured frequency of each GPU core into binary digits.
The goal is to ensure that each bit (bi) has an equal proba-
bility of 0 or 1: P (bi = 0) == P (bi = 1) == 0.5. Ultimately,
this leads to a completely random binary ﬁngerprint, which
provides maximum entropy – providing lower collision prob-
ability with the same ﬁngerprint length. Empirically, due to
process variations, the actual frequency of the CUDA core
is considered to follow normal distribution:
f (x) =
− (x−µ)2
2σ2
e
√
1
2π
σ
(1)
where µ is the designated operation frequency of the GPU
Core, e.g.
for a 3GHz GPU, µ = 3G. The standard de-
viation σ is determined by the processing technology, i.e.,
whether the chip is fabricated under 32nm or 11nm tech-
nology. The cumulative distribution function (CDF) of a
normal distributions is represented as:
F (x) =
1
2
(1 + erf(
x − µ√
2σ
))
(2)
√
where erf() is the Gauss error function. The inverse of the
cumulative distribution function (CDF) is the quantile func-
2σ· erf−1(2p− 1). That
tion, denoted as x = F −1(p) = µ +
is, given a probability p, F −1(p) returns the corresponding
threshold x so that Pr(X ≤ x) = p.
To generate an n-bit code from each GPU core, 2n − 1
thresholds is needed to separate the core frequency spectrum
into 2n brackets. The thresholds are denoted as {T1, ..., T2n−1},
so that a frequency bracket (Bi) is the interval [Ti−1, Ti].
Note that we have two special thresholds T0 = −∞ and
T2n = ∞. To ensure a uniform distribution of the code (or,
0.5 probability of 1 and 0 at each bit), the integral of the
1651probability distribution function over each interval should
be identical, that is:
(cid:90) Ti
Ti−1
1
2n
f (x)dx = F (Ti) − F (Ti−1) =
(3)
With the quantile function, we have: Ti = F −1(i/2n).
Unfortunately, the quantile function of a normal distribu-
tion cannot be expressed in closed form in elementary func-
tions. That says, we cannot directly compute Ti = F −1(p)
for a given p. There are several diﬀerent numerical ap-
proximations for the normal distribution CDF or the quan-
tile function. Tools/tables are available to compute/check
percentiles for standard normal distribution (Φ−1(p)). For
a general normal distribution, F −1(p) could be calculated
with: F −1(p) = µ + σΦ−1(p). For instance, we want to en-
code 2 bits from each CUDA core, four intervals are used:
[−∞, µ−0.674σ], [µ−0.674σ, µ], [µ, µ+0.674σ], [µ+0.674σ,∞].
With the 4 brackets deﬁned as above, encoding is straight
forward. For instance, when the measured frequency F qcorei ∈
[−∞, µ−0.674σ], the 2-bit ﬁngerprint segment generated by
Core i is “00”. Similarly, [µ− 0.674σ, µ] corresponds to “01”,
[µ, µ + 0.674σ] corresponds to “10”, and so on. We also XOR
the n-bit string from each core with the last n bits of the core
ID. This will not change the “good” properties of the ﬁnger-
print (e.g., randomness), however, it mitigates the possible
derandomization eﬀect caused by frequency degradation.
In a GPU chip, we extract n bits from each CUDA core.
To obtain an N -bit ﬁngerprint, we select m = N
n CUDA
cores for ﬁngerprint generation. Initially, we set N = 256
(AES key length), n = 2, and m = 128. At each CUDA core,
circuits sre designed to compare measured frequencies with
pre-set thresholds, and emit n ﬁngerprint bits. Output from
the measurement and encoding mechanism for each core is
assembled (concatenated) to generate the ﬁngerprint. The
design of the digital circuits for encoding and ﬁngerprint as-
sembly is straightforward, hence, we omit the technical de-
tails here. It is worth pointing out that, as we have claimed
before, the area and power overhead of adding such auxiliary
circuits is negligible to the entire GPU chip.
Core Selection. As we have discussed, m (e.g., 128) out of
2880 CUDA cores are selected to each emit an n-bit ﬁnger-
print segment, so that an N -bit ﬁngerprint is generated from
each GPU. The selection of the m CUDA cores is a nontriv-
ial problem.
In particular, process variations also contain
the systematic eﬀects. It implies that the nearby cores have
high possibility to exhibit similar frequency. When one core
is used for the key generation, its nearby cores should not
be further chosen to maintain the randomness of the selec-
tion. In the initial design, we evenly distribute the m cores
into each GPU SMX. Inside the SMX, we further evenly dis-
tribute the number of cores into each execution cluster. In
other words, two cores (when m is set as 128) are randomly
selected from each execution cluster to produce the ﬁnger-
print in our investigated NVIDIA GPU Kepler Architecture.
In order to keep a record of the cores used for the key gener-
ation, we attach an SRAM-based buﬀer to each GPU SMX,
which contains 192 bit with each bit describing the selection
of its corresponding CUDA core.
4. CONCLUSION AND FUTURE WORK
In this poster, we introduce a hardware signature based on
GPU core frequency variation. We present a mechanism to
extract bits from inherent hardware features of GPU cores.
We further generate a unique, physically unclonable, unpre-
dictable and random bitstring from the extracted bits. The
bitstring is then used as a hardware ﬁngerprint of the GPS.
The extracted ﬁngerprint cannot be used directly for au-
thentication – although ﬁngerprint is inherently uncloneable,
anyone who has access to the ﬁngerprint can fabricate a de-
vice that contains a same ﬁngerprint in memory to imper-
sonate the original device. For authentication purpose, we
will further extend the proposed POK to generate multi-
ple challenge response pairs (CRPs) similar to [5, 8], where
each response is unique to an external challenge. Meanwhile,
GPU cores are suﬀering the wear-out eﬀects during runtime
execution, which could cause frequency degradation and af-
fect the key stability. Another future work is to eﬃciently
avoid the frequency degradation of the selected cores, and
to develop a protocol to handle ﬁngerprint update.
5. ACKNOWLEDGEMENTS
Fengjun Li was supported in part by NSF EPS-0903806,
University of Kansas GRF-2301075, and KU RIC Strate-
gic Initiative Grant INS-0073037. Xin Fu was supported in
part by NSF CCF-1320730, NSF CCF-1351054. Bo Luo was
supported in part by NSF CNS-1422206, NSF IIS-1513324,
NSF OIA-1308762, and KU GRF-2301876.
6. REFERENCES
[1] A. Agrawal, A. Ansari, and J. Torrellas. Mosaic:
Exploiting the spatial locality of process variation to
reduce refresh energy in on-chip edram modules. In
HPCA, 2014.
[2] J. Kalisz. Review of methods for time interval
measurements with picosecond resolution. Metrologia,
41(1):17, 2004.
[3] U. R. Karpuzcu, K. B. Kolluru, N. S. Kim, and
J. Torrellas. Varius-ntv: A microarchitectural model
to capture the increased sensitivity of manycores to
process variations at near-threshold voltages. In DSN,
pages 1–11, 2012.
[4] J. Lee, P. Ajgaonkar, and N. S. Kim. Analyzing
throughput of gpgpus exploiting within-die
core-to-core frequency variation. In IEEE ISPASS,
pages 237–246, April 2011.
[5] R. Pappu, B. Recht, J. Taylor, and N. Gershenfeld.
Physical one-way functions. Science, 297(5589), 2002.
[6] S. Sarangi, B. Greskamp, A. Tiwari, and J. Torrellas.
Eval: Utilizing processors with variation-induced
timing errors. In MICRO, pages 423–434. IEEE, 2008.
[7] S. Seo, R. G. Dreslinski, M. Woh, Y. Park,
C. Charkrabari, S. Mahlke, D. Blaauw, and T. Mudge.
Process variation in near-threshold wide simd
architectures. In DAC, pages 980–987, 2012.
[8] G. Suh and S. Devadas. Physical unclonable functions
for device authentication and secret key generation. In
ACM/IEEE DAC, June 2007.
[9] Z. Xu, M. Miyahara, and A. Matsuzawa. A 1
[10] Z. Xu, M. Miyahara, and A. Matsuzawa. Picosecond
ps-resolution integrator-based time-to-digital converter
using a sar-adc in 90nm cmos. In NEWCAS, 2013.
resolution time-to-digital converter using gm − c
integrator and sar-adc. Nuclear Science, IEEE
Transactions on, 61(2):852–859, 2014.
1652