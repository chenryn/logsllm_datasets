YES
sat_bnd
3496x
sat_unbnd
YES
_
unsat_bnd
unsat_unbnd
_
Timeout (TO) is at 2h. ‘*’: regular expressions are removed.
58
23
36
35
31
21
3225 120
451s 129
TO 30
TO 46
S3
YES
YES
YES
YES
YES
YES
YES
YES
NO
NO
_
_
_
_
_
_
_
_
Table 10: S3 vs. Z3-str
To demonstrate that S3 is better, we ﬁrst use six test cases from the
SAT benchmarks of Kaluza. We follow the setting of Z3-str [39]
and remove all the constraints related to regular expressions. This
way we can run Z3-str on the resulting constraints. These six
benchmarks are presented in the ﬁrst part of Table 10. For each of
them, while S3 returns YES with a solution model, Z3-str instead
returns NO. We note that the models S3 provides are validated as
correct by using Z3-str itself.
We now brieﬂy discuss why we have this difference. One reason
is that Z3-str cannot acquire the concrete values assigned to length
variables. In contrast, our design, presented in Section 4.2, enables
the direct interactions between the string solver plug-in Z3-str-(cid:63)
and Z3 core, to query if the lengths of some string variables have
been deduced or constrained in the arithmetic theory. This helps
Z3-str-(cid:63) avoid repetitive case analysis.
More speciﬁcally, the six we use in Table 10, have the following
(frequent) pattern: there exists at least one variable that is only con-
strained by its length. Basically, with the constraint length(x)=i,
the solution for x can be any string of length i, i.e. “@..@”, where
each @ is an arbitrary character. However, Z3-str cannot make use
of this length constraint and keeps trying to assign string value for
x, starting from the empty string. Given that x is constrained by its
length, Z3-str must try-and-test many times until there is no more
conﬂict with that length constraint. Thus, the total number of values
to be tested by Z3-str will be blown up, preventing it from ﬁnding
a solution.
We next consider another set of benchmarks, representing an-
other pattern (which is also frequent in Kaluza’s benchmarks): there
exists a relationship between the lengths of different string vari-
ables. Indeed the example presented in Fig. 4 resembles such pat-
tern. See the second part of Table 10, where statistics for 4 bench-
marks are shown. We purposely make two benchmarks satisﬁable
– names start with ‘sat’, whereas the other two are unsatisﬁable –
names start with ‘unsat’. In the two whose names end with ‘bnd’,
the lengths of the string variables are bounded by 10, while in the
other two (the names end with ‘unbnd’), there is no such bound.
For each satisﬁable benchmarks, both Z3-str and S3 can ﬁnd a cor-
rect solution model. However, S3 outperforms Z3-str signiﬁcantly
by an order of magnitude. For the unsatisﬁable cases, while S3 re-
turns NO within a second, Z3-str runs for more than 2 hours without
producing an answer.
In summary, our design allows the full interaction between string
theory and arithmetic theory, enabling S3 to handle length con-
straints more effectively. Thus, even discounting the fact that S3
solves a more general class of constraints than Z3-str, its perfor-
mance is much better in the common class of constraints. This
ensures its applicability in web programs, where length constraints
are ubiquitous.
7. RELATED WORK
Symbolic execution has recently been exploited to address a wide
range of security problems. Some notable examples are: auto-
mated ﬁngerprint generation [7], protocol replay [25], automated
code transformation to eliminate SQL injection attacks in legacy
web applications [4].
Motivated by the problem of analyzing JavaScript code for the
purpose of detecting security ﬂaws, [28] proposed a framework,
Kudzu, which leverages the beneﬁts of both concrete and symbolic
evaluation. This work effectively reduced the analysis problem of
web applications to the problem of solving string constraints. In
order to be widely applicable, it is important to have a string solver
which is able to reason about both string and non-string constraints.
Importantly, the solver must also support constraints involving reg-
ular expressions and with multiple variables.
There is a vast literature on the problem of string solving. In
previous Sections, we have carefully positioned our work against
Kaluza and Z3-str. We now focus on other closely related work.
Practical methods for solving string equations can loosely be di-
vided into bounded and unbounded methods. Bounded methods
(e.g., HAMPI [22], CFGAnalyzer [3], and [18]) often assume ﬁxed
length string variables, then treat the problem as a normal constraint
satisfaction problem (CSP). These methods can be quite efﬁcient in
ﬁnding satisfying assignments and often can express a wider range
of constraints than the unbounded methods. However, as also iden-
tiﬁed in [28], there is still a big gap in order to apply them to con-
straints arising from the analysis of web applications.
In the spirit of Kaluza, [6] proposed to reason about feasibility
of a symbolic execution path from high-level programs, of which
string constraints are involved. In principle, the approach is similar
to Kaluza: it proceeds by ﬁrst enumerating concrete length values,
before encoding strings into bit-vectors. It supports common in-
teger related string operations, taken from the basic .NET string
library, except for replace. Unlike Kaluza, however, regular ex-
pressions are not supported here. In a similar manner,
[27] ad-
dresses multiple types of constraints for Java PathFinder. Though
this approach can handle many operators, it provides limited sup-
port for replace, requiring the result and arguments to be con-
crete. Furthermore, it does not handle regular expressions. In sum-
mary, the above methods are less powerful than S3 in terms of the
expressiveness of the input language. Importantly, they have simi-
lar limitations as Kaluza, which we have carefully discussed.
PISA [33] is the ﬁrst path- and index-sensitive string solver that
targets static analysis of web applications. The veriﬁcation is con-
ducted by encoding the program in Monadic Second-Order Logic
(M2L). It supports regular expressions as well as Java’s replace
method. However, it does not support binary operations between
two variables, i.e., PISA requires at least one of them to be con-
stant. Also importantly, its expressiveness for arithmetic operations
is restricted due to the limitations of M2L. For example, it does not
support numeric multiplications and divisions.
Other unbounded methods are often built upon the theory of au-
tomata or regular languages. We will be brief and mention a few
notable works. Java String Analyzer (JSA) [10] applies static anal-
ysis to model ﬂow graphs of Java programs in order to capture de-
pendencies among string variables. A ﬁnite automata is then de-
rived to constrain possible string values. The work [31] used ﬁ-
nite state machines (FSMs) for abstracting strings during symbolic
execution of Java programs. They handle a few core methods in
the java.lang.String class, and some other related classes.
They partially integrate a numeric constraint solver. For instance,
string operations which return integers, such as indexOf, trigger
case-splits over all possible return values.
In short, using automata and/or regular language representations
potentially enables the reasoning of inﬁnite strings and regular ex-
pressions. However, most of existing approaches have difﬁculties
in handling string operations related to integers such as length
and indexOf, let alone other high-level operations addressed in
this paper. More importantly, to assist web application analysis, it
is necessary to reason about both string and non-string behavior to-
gether. It is not clear how to adapt such techniques for the purpose,
given that they do not provide native support for constraints of the
type integer.
Since our method does not rely on the length bounds in enu-
merating solutions, and our particular treatment of (possibly un-
bounded) recursive operations is lazy, it is possible that S3 can
handle query of unbounded length variables as well as unbounded
regular expression. However, to guarantee termination, we do rely
on the fact that the lengths are bounded. In fact, our work targets
the input constraints arising from realistic web applications. There-
fore, even when the lengths are not precisely known – in the case
of static analysis – it is reasonable to assume that the lengths of in-
put string variables are indeed bounded, as many modern practical
string solvers do.
8. CONCLUDING REMARKS
This paper presents a new algorithm for solving string constraints.
The class of constraints is practically expressive, for its intended
purpose of analyzing web programs which manipulate string in-
puts. Experimental evaluations show that our solver S3, despite
being more expressive than other solvers, is much more robust and
efﬁcient.
We remark that in lieu of presenting an end-to-end system, we
show that our proposed solver is indeed a modular contribution to
any hypothetical dynamic symbolic execution end-to-end system.
That is, the superior performance of our solver can be used, without
signiﬁcant engineering of integrating it, to obtain an improvement
in the hypothetical system.
We believe, based on its symbolic representation of string con-
straints, S3 can also be extended to be more efﬁcient in the context
of static analysis, where even regular expressions can also be sym-
bolically constructed.
Astute readers might already notice that our underlying symbolic
representation goes well beyond regular languages. As an example,
{an·bn | n ≥ 0} can be easily modeled as star(a, n)·star(b, n)∧
n ≥ 0. While this paper focuses on the practical impact of S3,
investigating the theoretical impact of such symbolic representation
is left as our future work.
9. REFERENCES
[1] M. Alkhalaf, T. Bultan, and J. L. Gallegos. Verifying
Client-side Input Validation Functions Using String
Analysis. In ICSE, pages 947–957, 2012.
[2] M. Alkhalaf, S. R. Choudhary, M. Fazzini, T. Bultan,
A. Orso, and C. Kruegel. ViewPoints: Differential String
Analysis for Discovering Client- and Server-side Input
Validation Inconsistencies. In ISSTA, pages 56–66, 2012.
[3] R. Axelsson, K. Heljanko, and M. Lange. Analyzing
Context-Free Grammars Using an Incremental SAT Solver.
In ICALP, pages 410–422, 2008.
[4] P. Bisht, T. Hinrichs, N. Skrupsky, R. Bobrowicz, and V. N.
Venkatakrishnan. NoTamper: Automatic Blackbox Detection
of Parameter Tampering Opportunities in Web Applications.
In CCS, pages 607–618, 2010.
[5] P. Bisht, T. Hinrichs, N. Skrupsky, and V. N.
Venkatakrishnan. WAPTEC: Whitebox Analysis of Web
Applications for Parameter Tampering Exploit Construction.
In CCS, pages 575–586, 2011.
[6] N. Bjørner, N. Tillmann, and A. Voronkov. Path Feasibility
Analysis for String-Manipulating Programs. In TACAS,
pages 307–321, 2009.
[7] D. Brumley, J. Caballero, Z. Liang, J. Newsome, and
D. Song. Towards Automatic Discovery of Deviations in
Binary Implementations with Applications to Error
Detection and Fingerprint Generation. In USENIX Security
Symposium, pages 15:1–15:16, 2007.
[8] S. Bucur, J. Kinder, and G. Candea. Prototyping Symbolic
Execution Engines for Interpreted Languages. In ASPLOS,
pages 239–254, 2014.
[9] A. Chaudhuri and J. S. Foster. Symbolic Security Analysis of
Ruby-on-rails Web Applications. In CCS, pages 585–594,
2010.
[10] A. S. Christensen, A. Møller, and M. I. Schwartzbach.
Precise Analysis of String Expressions. In SAS, pages 1–18,
2003.
[11] L. M. de Moura and N. Bjørner. Z3: An Efﬁcient SMT
Solver. In TACAS, pages 337–340, 2008.
[12] M. Emmi, R. Majumdar, and K. Sen. Dynamic Test Input
Generation for Database Applications. In ISSTA, pages
151–162, 2007.
[13] G. Gange, J. A. Navas, P. J. Stuckey, H. Søndergaard, and
P. Schachte. Unbounded Model-Checking with Interpolation
for Regular Language Constraints. In TACAS, pages
277–291, 2013.
[14] I. Ghosh, N. Shaﬁei, G. Li, and W.-F. Chiang. JST: An
Automatic Test Generation Tool for Industrial Java
Applications with Strings. In ICSE, pages 992–1001, 2013.
[15] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed
Automated Random Testing. SIGPLAN Not., 40(6):213–223,
June 2005.
[16] P. Godefroid, M. Y. Levin, and D. A. Molnar. Automated
Whitebox Fuzz Testing. In NDSS, pages 151–166, 2008.
[17] W. G. Halfond, S. Anand, and A. Orso. Precise Interface
Identiﬁcation to Improve Testing and Analysis of Web
Applications. In ISSTA, pages 285–296, 2009.
[18] J. He, P. Flener, J. Pearson, and W. Zhang. Solving String
Constraints: The Case for Constraint Programming. In CP,
pages 381–397, 2013.
[19] P. Hooimeijer and W. Weimer. A Decision Procedure for
Subset Constraints over Regular Languages. In PLDI, pages
188–198, 2009.
[20] P. Hooimeijer and W. Weimer. Solving String Constraints
Lazily. In ASE, pages 377–386, 2010.
[21] C. S. Jensen, M. R. Prasad, and A. Møller. Automated
Testing with Targeted Event Sequence Generation. In ISSTA,
pages 67–77, 2013.
[22] A. Kiezun, V. Ganesh, P. J. Guo, P. Hooimeijer, and M. D.
Ernst. HAMPI: A Solver for String Constraints. In ISSTA,
pages 105–116, 2009.
[23] A. Kiezun, P. J. Guo, K. Jayaraman, and M. D. Ernst.
Automatic Creation of SQL Injection and Cross-site
Scripting Attacks. In ICSE, pages 199–209, 2009.
[24] J. Maras, M. Štula, and J. Carlson. Generating Feature Usage
Scenarios in Client-side Web Applications. In ICWE, pages
186–200, 2013.
[25] J. Newsome, D. Brumley, J. Franklin, and D. Song.
Replayer: Automatic Protocol Replay by Binary Analysis. In
CCS, pages 311–321, 2006.
[26] OWASP. Top ten project, May 2013.
http://www.owasp.org/.
[27] G. Redelinghuys, W. Visser, and J. Geldenhuys. Symbolic
Execution of Programs with Strings. In SAICSIT, pages
139–148, 2012.
[28] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and
D. Song. A Symbolic Execution Framework for JavaScript.
In SP, pages 513–528, 2010.
[29] K. Sen, S. Kalasapur, T. Brutch, and S. Gibbs. Jalangi: A
Selective Record-replay and Dynamic Analysis Framework
for JavaScript. In ESEC/FSE, pages 488–498, 2013.
[30] K. Sen, D. Marinov, and G. Agha. CUTE: A Concolic Unit
Testing Engine for C. In ESEC/FSE, pages 263–272, 2005.
[31] D. Shannon, I. Ghosh, S. Rajan, and S. Khurshid. Efﬁcient
Symbolic Execution of Strings for Validating Web
Applications. In DEFECTS, pages 22–26, 2009.
[32] T. Tateishi, M. Pistoia, and O. Tripp. Path- and
Index-sensitive String Analysis based on Monadic
Second-order Logic. In ISSTA, pages 166–176, 2011.
[33] T. Tateishi, M. Pistoia, and O. Tripp. Path- and
Index-sensitive String Analysis Based on Monadic
Second-order Logic. ACM Trans. Softw. Eng. Methodol.,
22(4):33:1–33:33, Oct. 2013.
[34] M. Veanes, P. d. Halleux, and N. Tillmann. Rex: Symbolic
Regular Expression Explorer. In ICST, pages 498–507, 2010.
[35] R. Wang, P. Ning, T. Xie, and Q. Chen. MetaSymploit:
Day-one Defense Against Script-based Attacks with
Security-enhanced Symbolic Analysis. In SEC, pages 65–80,
2013.
[36] G. Wassermann and Z. Su. Sound and Precise Analysis of
Web Applications for Injection Vulnerabilities. In PLDI,
pages 32–41, 2007.
[37] G. Wassermann and Z. Su. Static Detection of Cross-site
Scripting Vulnerabilities. In ICSE, pages 171–180, 2008.
[38] F. Yu, M. Alkhalaf, and T. Bultan. STRANGER: An
Automata-based String Analysis Tool for PHP. In TACAS,
pages 154–157, 2010.
[39] Y. Zheng, X. Zhang, and V. Ganesh. Z3-str: A Z3-based
String Solver for Web Application Analysis. In ESEC/FSE,
pages 114–124, 2013.