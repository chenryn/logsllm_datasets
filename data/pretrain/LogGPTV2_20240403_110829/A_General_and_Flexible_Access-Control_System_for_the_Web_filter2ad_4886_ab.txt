til the end of the semester, Alice is taking CS101"
(step 6).
Finally, there is enough information to prove that
Alice should be allowed to access the (cid:12)le. Once a
proof is generated, Alice sends another request for
/midterm.html to the server (step 7). This time
she includes in the request the challenge and its
proof. The server checks that the proof is valid,
and that Alice proved the correct challenge. If both
checks succeed, the server returns the requested
page (step 8).
3.2 Logic
Our authorization system, like other proof-carrying
authorization systems, has a core logic with an
application-speci(cid:12)c logic de(cid:12)ned on top of it.
The application-speci(cid:12)c logic is used to de(cid:12)ne the
operators and rules useful for writing security poli-
cies for web access control { in our case standard
operators like says and speaksfor were su(cid:14)cient.
Unlike in traditional distributed authorization sys-
tems, in which these operators would be primitive,
in proof-carrying authorization systems these oper-
ators are implemented as de(cid:12)nitions using the core
logic. This is what makes it possible for our system
to work seamlessly across administrative domains {
as long as they share a common core logic, the op-
erators of any application-speci(cid:12)c logic can be re-
garded merely as abbreviations.
The following are operators of our application-
speci(cid:12)c logic, their informal de(cid:12)nitions, and their
encodings in the AF logic.
A says F A principal A says any statement that
is true. Also, if A says the formula X, and the
formula Y is true, and X and Y imply formula
Z, then A also says Z { this allows the principal
A to draw conclusions based on its beliefs.
A says F (cid:17) 9G : A(G) ^ (G ! F )
A speaksfor B This operator is used for delega-
tion. If principal A speaks for principal B, then
anything that A says is spoken with principal
B’s authority.
A speaksfor B (cid:17) 8F : (A says F )
! (B says F )
A.s The principal A:s (or localname(A; s)) is a
new principal created in A’s local name space
from the string s. Principal A controls what
A:s says.
In our example, the principal reg-
istrar creates the principal registrar.cs101, and
signs a formula like ‘key(\alice") speaksfor (reg-
istrar.\cs101")’ for each student in the class.
A:s(F ) (cid:17) 8L : lnlike(L) ! L(A)(S)(F )
The lnlike operator is used to break the re-
cursion in the de(cid:12)nition of localname. The
de(cid:12)nition of lnlike looks complicated, but is
such that lnlike(L) is true for every function
L that behaves as a local name should; that
is, it returns true for every function that gener-
ates a principal whose authority A can delegate.
localname is one of the operators explicitly de-
(cid:12)ned so that it obeys only the set of rules that
we require of it; this makes its de(cid:12)nition some-
what more complicated and adds complexity to
the proofs of lemmas about it.
lnlike(L) (cid:17) 8A; S; F; G :
((A says G) and (G ! (L(A)(S) says F )))
! L(A)(S)(F )
Rules about these operators can be proved as lem-
mas and are also transient to the core logic. Using
the operators we de(cid:12)ned, we can now prove rules
such as this one, which states that says follows im-
plication:
A says F
A says G
F ! G
says imp
The core logic we use is a variant of the AF logic
(the rules of which are presented in Appendix A).
The only rules that aren’t standard rules of higher-
order logic are the four that allow us to reason about
digital signatures, time, and implication inside the
says operator.
3.3 Client: Proxy Server
The job of the proxy server is to be the intermedi-
ary between a web browser that has no knowledge
of the PCA protocol and a web server that is PCA-
enabled. An attempt by the browser to access a
web page results in a dialogue between the proxy
and the server that houses the page. The dialogue is
conducted through PCA-enhanced HTTP|HTTP
augmented with headers that allow it to convey in-
formation needed for authorization using the PCA
protocol. The browser is completely unaware of this
dialogue; it sees only the web page returned at the
end.
When Alice requests to see the page http: //
server/ midterm. html, her browser forms the re-
quest and sends it to the local proxy (Figure 2, step
1). The proxy server forwards the request without
modifying it (step 2).
3.4 Secure Transmission and Session
Identi(cid:12)ers
The session identi(cid:12)er is a shared secret between the
client and server. The identi(cid:12)er is used in challenges
and proofs (including in digitally signed formulas
within the proofs) to make them speci(cid:12)c to a single
session. This is important because the server caches
previously proven challenges and allows clients to
present the session identi(cid:12)er as a token that demon-
strates that they have already provided the server
with a proof.
The session identi(cid:12)er is a string generated by the
server using a cryptographic pseudorandom number
generator. Our implementation uses a 144-bit value
which is then stored using a base-64 encoding. (144
bits was chosen because the value converts evenly
into the base-64 encoding.)
Since the session identi(cid:12)er may be su(cid:14)cient to gain
access to a resource, stealing a session identi(cid:12)er,
akin to stealing a proof in a system where goals are
not unique, compromises the security of the system.
In order to keep the session identi(cid:12)er secret, com-
munication between the client and server uses the
secure protocol HTTPS instead of normal HTTP in
all cases where a session identi(cid:12)er is sent.
If the
client attempts to make a standard HTTP request
for a PCA-protected page, the server replies with
a special \Authorization Required" message which
directs the client to switch to HTTPS and retry the
request.
the server, asking for
Alice’s proxy contacts
midterm. html. Since that page is PCA-protected
and the proxy used HTTP, the server rejects the
request. The proxy switches to HTTPS and sends
the same request again.
Make request
N
challenge(cid:13)
in reply?
Y
same(cid:13)
challenge?
Y
N
Done
assum’s.(cid:13)
purged?
Y
N
purge assumptions
try to prove
N
proved?
fetch facts
Y
Y
new(cid:13)
facts?
N
Fail
Figure 3. Client (cid:13)owchart.
3.5 Server: Proposition Generator and
Iterative Authorization
When a client attempts to access a PCA-protected
web page, the server replies with a statement of
the theorem that it wants the client to prove before
granting it access. This statement, or proposition,
can be generated autonomously; it depends only on
the pathname of the (cid:12)le that the client is trying to
access and on the syntax of the logic in which it is
to be encoded.
Client
Web(cid:13)
browser
13
HTTP(cid:13)
proxy
6
8
Prover
7
2
9
5
12
Fact server
Server
HTTP server
4
3
11
10
Prop.(cid:13)
gen.
Checker
Figure 2. The components of the system.
The server’s proposition generator provides the
server with a list of propositions. The server returns
to the client the (cid:12)rst unproven proposition. If the
client successfully proves that proposition in a sub-
sequent request, then the server will reply with the
next unproven proposition as the challenge. This
process of proving and then receiving the next chal-
lenge from a list of unproven propositions is called
iterative authorization. The processes for the client
and server are shown in the (cid:13)owcharts of Figure 3
and Figure 4.
The process of iterative authorization terminates
when either the client gives up (i.e., cannot prove
one of the propositions) or has successfully proven
all of the propositions, in which case access is al-
lowed.
If the client presents a proof which fails
when the server checks it, it is simply discarded.
In this case, the same challenge will be returned to
the client twice.
If the client receives the same challenge twice, it
knows that although it \successfully" constructed
a proof for that challenge, the proof was rejected
by the server. This means that one of the client’s
assumptions must have been incorrect. The client
may choose to discard some assumptions and retry
the proof process.
Our system generates a proposition for each direc-
tory level of the URL speci(cid:12)ed in the client’s re-
quest. This ensures that the client has permission
to access the full path (i.e., just like in standard
access control for a hierarchical (cid:12)le system). Since
the server returns identical challenges regardless of
whether the requested object exists, returning a
challenge reveals no information about the existence
of objects on the server.
Isolating the proposition generator from the rest of
the server makes it easy to adapt the server for other
applications of PCA; using it for another applica-
tion may require nothing more than changing the
proposition generator.
After receiving the second, encrypted request, the
server (cid:12)rst generates the session ID, \sid". It then
passes the request and the ID to the proposition
generator. The proposition generator returns a list
of propositions that Alice must prove before she is
allowed to see /midterm. html:
(key "server") says
(goal "http://server/" "sid")
(key "server") says
(goal "http://server/midterm.html" "sid")
For the purposes of this example, we will deal only
with the second challenge. In reality, Alice would
(cid:12)rst have to prove that she is allowed to access
http: // server/, and only then could she try to
prove that she is also allowed to access http: //
server/ midterm. html.
A bene(cid:12)t of iterative authorization is that it allows
parts of the security policy to be hidden from unau-
thorized clients. Only when a challenge has been
proven will the client be able to access the facts that
it needs to prove the next challenge. In the context
of our application this means, for example, that a
client must prove that it is allowed to access a direc-
tory before it can even (cid:12)nd out what goal it must
prove (and therefore what facts it must gather) to
gain access to a particular (cid:12)le in that directory.
generate challenges
proposition as its single parameter.
Proof(cid:13)
supplied?
Y
N
more(cid:13)
challenges?
N
Y
get next challenge
proof(cid:13)
cached?
N
Y
check proof
N
proof(cid:13)
OK?
Y
add to cache
Return(cid:13)
requested(cid:13)
page
Return(cid:13)
challenge
Once the client has constructed a proof of the chal-
lenge, it makes another HTTPS request (this can be
done with the same TCP connection if allowed by
keep-alive) containing the challenge and the proof.
The challenge is included in an \Authorization"
request-header (cid:12)eld, and the proof is included in a
series of \X-PCA-Proof" request-header (cid:12)elds. The
server checks that the proof proves the supplied
challenge, adds the challenge to its cache of proven
propositions, and then begins the checking process
for the next proposition.
The (cid:12)rst proposition in the example is the one
stating that the server says that it’s OK to read
http: // server/. The server checks whether it
has already been proven and moves on to the
next one.
(Remember that for the purposes of
the example we’re concentrating only on the sec-
ond proposition; the authorization process for each
is identical.) The next proposition states that
the server says it’s OK to read http: // server/
midterm. html. This one hasn’t been proven yet,
so the server constructs an HTTP response that
includes this proposition as a challenge and sends
it to Alice. This is step 5 of Figure 2.
3.7 Client: Prover
Figure 4. Server (cid:13)owchart.
3.6 Server: Challenges; Client: Proofs
For each authorization request, the server’s proposi-
tion generator generates a list of propositions which
must be proven before access is granted. Each
proposition contains a URL and a session identi-
(cid:12)er. The server checks each proposition to see if
it was previously proven by the client by checking
a cache of previously proven challenges.
If all of
the propositions have been proven, access is allowed
immediately. Otherwise, the (cid:12)rst unproven propo-
sition is returned to the client as a challenge. Any
other unproven propositions are discarded.
The server constructs a reply with a status code of
\Unauthorized." This is a standard HTTP response
code (401) [10]. The response includes the required
HTTP header (cid:12)eld \WWW-Authenticate" with an
authentication scheme of \PCA" and the unproven
In the course of a PCA conversation with a server,
the proxy needs to generate proofs that will demon-
strate to the server that the client should be allowed
access to a particular (cid:12)le. This task is independent
enough from the rest of the authorization process
that it is convenient to abstract it into a separate
component. During a PCA conversation the client
may need to prove multiple statements; the process
of proving each is left to the prover.
The core of the prover in our system is the Twelf log-
ical framework [18]. Proofs are generated automati-
cally by a logic program that uses tactics. The goal
that must be proven is encoded as the statement
of a theorem. Axioms that are likely to be helpful
in proving the theorem are added as assumptions.
The logic program generates a derivation of the the-
orem; this is the \proof" that the proxy sends to the
server.
The tactics that de(cid:12)ne the prover roughly corre-
spond to the inference rules of the application-
speci(cid:12)c logic. Together with the algorithm that uses
them, the tactics comprise a decision procedure that
generates proofs { for our system to always (cid:12)nd
proofs of true statements, this decision procedure
must be decidable.
A tactic for proving A speaksfor C would be to (cid:12)nd
proofs of A speaksfor B and B speaksfor C and then
use the transitivity lemma for speaksfor. Other tac-
tics might be used to guide the search for these sub-
goals. The order in which tactics are applied af-
fects their e(cid:11)ectiveness. Care must also be taken
to avoid situations in which tactics might guide the
prover into in(cid:12)nite (or (cid:12)nite but time-consuming)
branches that don’t lead to a proof. For the re-
stricted set of rules that we are interested in, the
prover in our system is able to automatically gener-
ate proofs whenever they exist.
As part of generating the proof of a goal given to it
by the proxy, the prover’s job is to (cid:12)nd all the as-
sumptions that are required by the proof. Assump-
tions needed to generate a proof might include state-
ments made by the server about who is allowed to
access a particular (cid:12)le, statements about clock skew,
statements by which principals delegate authority to
other principals, or statements of goal. While some
of these might be known to the proxy, and would
therefore have been provided to the prover, others
might need to be obtained from web pages.
Since fetching assumptions from the web is a rela-
tively time-consuming process (hundreds of millisec-
onds is a long time for a single step of an interac-
tive authorization that should be transparent to the
user), the prover caches the assumptions for future
use. The prover also periodically discards assump-
tions which have not been recently used in successful
proofs.
3.8 Client: Iterative Proving
The client is responsible for proof generation. The
client may not always be able to generate a proof of
the challenge on the (cid:12)rst try. It may need to obtain
additional information, such as signed delegations