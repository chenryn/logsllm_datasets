e.g., Boxify [24] shows that such overhead is negligible (open-
ing a camera introduces an overhead of 1.24 ms).
Results presented in this section were measured on a
Google Nexus 5X phone running Android 7.0. In our ex-
periments, the HMA App Store was connected to the phone
through a micro-USB cable, hence network delays were not
considered. Yet, compared to the standard use of apps, HMA
incurs negligible network-delay overheads, because the only
bandwidth overhead introduced by HMA is the container-app
payload whose size is only several hundreds of kilobytes.
10.3.1 App Installation
When a user wants to install an mHealth app, the
HMA App Store ﬁrst creates a container app for it. Based on
our experiments, assuming the HMA App Store decompiles
the mHealth APKs beforehand, for 90% of the cases, generat-
ing a container app takes, on average, 5 s. Note that a large
part of the delay comes from the compilation of the container
app, and the measurement was performed on a laptop com-
puter. Also note that the HMA App Store can always prepare
in advance container apps for each mHealth app, as presented
in Section 8.2. The size of the container app is only several
hundreds of kilobytes, which takes less than a second for the
HMA Manager app to download using a 3G or 4G Internet
connection. As a result, the total delay overhead introduced
by HMA would be less than 5 s in the worst-case scenario, and
less than a second if container apps are generated beforehand,
which is acceptable.
On Android, apps can be launched from two different states:
cold starts where apps are launched for the ﬁrst time since
the phone was booted or since the system killed the apps,
and warm starts where the apps’ activities might still reside
in memory, and the system only needs to bring them to the
foreground, hence faster than cold starts.
Experiment Set-Up. For cold-start delays, we rely on An-
droid’s ofﬁcial launch-performance proﬁling method [13].
For each app, we installed its container app, copied its APK
ﬁle to its container app’s private directory, and launched the
container app through adb. We then extracted the time infor-
mation from the Displayed entry of the logcat output. To
simulate a ﬁrst launch, before we launched an app, we used the
command adb shell pm clear [package-name] to bring
the app back to its initial state. To simulate a cold start, be-
fore we launched an app, we used the command adb shell
am force-stop [package-name] to kill all the foreground
activities and background processes of the app. For each app,
we collected 50 measurements per launch setting. For a base-
line, we measured the delays when the mHealth apps were
executed without HMA.
To measure warm-start delays, due to the lack of Android
supports for proﬁling warm starts, we have to instrument
the source code of the sensitive apps to log the time that
the app enters different stages in its lifecycle. Because apps
in our dataset are closed source, we used an open-source
app.32 To simulate a warm start, we used the command input
keyevent 187 to bring the app to the background, and then
we used the monkey command to bring the app back to the
foreground. By subtracting the time when the onResume()
method is successfully executed with the time before the
monkey command is sent, we know the warm-start delay
experienced by the app. We measured the warm-start delays
experienced by the app in both settings (w/ and w/o HMA), 50
measurements per setting.
Results. Intuitively, in HMA, the ﬁrst launch of an mHealth
will experience longer delays than the subsequent cold starts,
because the container app has to process the APK and store the
information needed for user-level virtualization. Our experi-
ments show that the median of this process takes 6.5 ± 0.16 s
(as compared to 0.74 ± 0.07 s if the mHealth apps were
launched w/o HMA). Note that this occurs only once, hence it
is negligible w.r.t. the lifetime of the app.
Fig. 2 shows the bar plot of subsequent cold-start delays,
with and without HMA, experienced by mHealth apps; the
heights of the bars represent the mean values, and the er-
ror bars represent one standard deviation. It can be seen that
the average delays are at most 3.0 ± 0.5 s and 1.3 ± 0.05 s
if the apps are executed with and without HMA, respectively.
For 90% of the cases, the average delay with HMA is less than
2.0 ± 0.3 s. Note that our prototype is a proof-of-concept
hence not optimized. Still, the observed delays are under the
USENIX Association
28th USENIX Security Symposium    723
Figure 2: Cold-start delays experienced by mHealth apps when they are executed with and without HMA. Note that our HMA
implementation is a proof-of-concept, hence not-optimized. The heights of the bars represent mean values and the error bars
represent the standard deviation. For each setting, we collected 50 measurements per app. The full names of the apps can be
found in Appendix B of our technical report at [44].
delay limit of 5 s suggested by Android [13]. Also, in our user
study, 97% of participants agreed that a launch delay of 5 s is
acceptable (Section 10.6).
Regarding warm-start delays, we found that the average
delay experienced by our tested app, when it was launched
with and without HMA, was ∼0.55 s. This is intuitive, because
the app’s processes were still running and the activities still
resided in the phone’s memory. In case the garbage collector
evicts the activities from the phone’s memory, warm-start
delays can be longer, due to the overheads of activity initial-
izations. We cannot simulate this case, because Android does
not provide methods to control the garbage collector. How-
ever, in this case, the delay will still be less than cold-start
delays (i.e., at most 3 s).
10.4 HMA Robustness and Compatibility
In this section, we present the evaluation of HMA in terms of
its robustness and its compatibility with Android versions.
Runtime Robustness. Following the approach used in previ-
ous work, (e.g., [35] and [53]), we manually tested each app
in our dataset with HMA. For each mHealth app, we extracted
its APK, created a container app using HMA App Store,
and installed the container app on the phone. Thereafter,
we used the HMA Manager to launch the app. We manu-
ally used most of the functionality of the mHealth app, and
checked if it had crashed during its execution. We found
that all of the apps in our dataset worked normally, except
one app that threw an error when making an SQLite con-
nection. To determine the cause of this error, we ran an ex-
ample app33 that uses the ofﬁcial Android API for database
access (i.e., Android.database.sqlite) to insert and re-
trieve records from an SQLite database, and the example
app ran successfully. We suspect that the mHealth app threw
an error because it speciﬁes the full path to the database
(i.e., /data/data/package-name/db-name). Hence, when
running the app inside of the HMA container app, the hard-
coded path is not longer valid. To avoid this problem, de-
velopers should specify the relative path to the database
(i.e., ./db-name) instead of its full path.
Compatibility. We ran HMA on a series of smartphones with
Android OS from version 5.0 to 8.0, which accounts for 89%
of the current Android version distribution [7]. We found that
HMA can be successfully deployed on mainstream commercial
Android devices. But, there are two apps (Mole Mapper and
Alzheimer’s Speed of Processing Game) that initially
failed to run on our Nexus 5X (Android 7.1.1) due to the in-
compatibility between 32-bit and 64-bit systems. We ﬁxed the
problem by enabling the option -abi armeabi-v7a when in-
stalling them. From the list of 20 apps that we ﬁltered out, we
found that 3 apps (Hearing Aid, What’s Up and Cardiac
diagnosis) successfully ran on Android 5.0 and 6.0, but they
failed to run in later versions of Android. We investigated the
log of the three apps and found that API methods related
to GMS services that we do not support were called in the
later versions of Android. This problem could be solved if
these services are hooked, as we discussed in Section 10.2.
Note that, with the recent release of Android 9, Google has
restricted the use of Java reﬂection34 – the programming in-
terface that all user-level virtualization techniques rely on.
Therefore, for HMA to work seamlessly in Android 9, new
user-level virtualization techniques need to be explored. Still,
Android 9 has only less than 1% market share [7], which
means HMA will be compatible with most Android devices
in the coming years. Alternatively, HMA could work with
rooted Android 9 devices by using dynamic customization
frameworks, e.g., Xposed.35
10.5
Inter-App Communication Support
Sharing resources with other apps via customized features
(e.g., custom permissions and custom intent-ﬁlters) and pub-
licly exposing components (e.g., activities, services and con-
tent providers) could facilitate ﬁngerprinting attacks. HMA can
partially support inter-app communications, but it is prefer-
able to avoid such features to guarantee robust ﬁngerprinting
protection. Avoiding inter-app communication, however, can
affect apps’ functionality and backward compatibility. To
estimate the effect of using HMA and avoiding inter-app com-
munication on existing apps, we analyzed a set of popular
724    28th USENIX Security Symposium
USENIX Association
sensitive apps from the Google Play Store. Our results show
that a small number of apps use inter-app communication fea-
tures that are not supported by HMA and, in many cases, such
features are not directly related to apps’ key functionalities.
Dataset. We collected a total of 1045 APK ﬁles from the
most popular free apps in the Medical and Health&Fitness
categories in the US Google Play Store. By checking the apps’
descriptions, we found that approximately 60% directly match
HMA’s use case (i.e., health- and ﬁtness-related apps). The rest
of the apps are less related to HMA’s use case, e.g., apps for
medical doctors and nurses, apps for managing accounts with
health providers, and apps for managing gym subscriptions.
From the APK ﬁles, we extracted the manifest ﬁle using the
apktool application.
Custom Permissions. Permissions deﬁned by apps to con-
trol access to their components can be used to ﬁngerprint
them (e.g., they typically include the app name), as any app
can list the permissions of other apps. Hence, custom permis-
sions should be avoided. We found that a total of 531 apps
declared custom permissions. However, most of these permis-
sion declarations are related to deprecated services (Google
Cloud Messaging and Android Maps API v2)36 and can be
replaced with newer alternatives that do not require custom
permissions. Therefore, ignoring permissions associated with
these deprecated services, we found that only 68 apps (6.5%)
declared valid custom permissions.
Signature-Level Permissions. Signature permissions37 are
a subset of custom permissions, hence they can be used to
ﬁngerprint apps. Given that HMA container apps are all signed
by the same key, a malicious app inside a container app could
abuse signature permissions to access resources of sensitive
apps in other container apps. Therefore, HMA currently does
not declare signature permissions in the container apps. Our
analysis shows that only 113 apps (10.8%) declared signature
permissions and, as explained before, many of these permis-
sions are associated with deprecated services (e.g., Google
Cloud Messaging and Android Maps API).
Content Providers. Any app can list the content providers
of other installed apps and use this information to ﬁngerprint
them. Therefore, HMA obfuscates this information in the con-
tainer app. This means that public content providers (used
to share data with other apps) are not currently supported
by HMA. Our analysis shows that only 84 apps (8%) declare
public content providers. From these apps, 68% declare pub-
lic content-providers associated with third-party frameworks
(e.g., Seattle Clouds) for services such as ﬁle sharing and
authentication, and approximately 23% require permission to
access the provider.
Intent Filters. Custom intent ﬁlters, i.e., intent ﬁlters with
app-speciﬁc actions, could be used to ﬁngerprint apps. Apps
cannot list the intent ﬁlters of other apps, but they can list all
the activities of other apps that can be performed by a par-
ticular intent. Hence, developers should avoid using custom
intent ﬁlters in their apps’ activities. Our analysis shows that
this is not a problem, as only 38 apps (3.6%) have activities
with custom intent ﬁlters.
Activities and Explicit Intents. Explicit intents are currently
not supported by HMA because container apps obfuscate the
activities’ names of sensitive apps; thus, direct reference to
sensitive apps’ activities is not possible. However, it is recom-
mended to use only explicit intents to launch internal activ-
ities; not activities of other apps (implicit intents should be
used instead). Our analysis shows that 170 apps (16.2%) de-
clare activities that can be launched by other apps via explicit
intents only, i.e., no intent ﬁlters. We noticed that many apps
(67) declared this type of activities to support Google’s Fire-
base authentication services. Yet, Firebase’s ofﬁcial documen-
tation does not seem to mention this approach to support its
services. Hence, to be compatible with HMA, these apps could
evaluate alternative (ofﬁcial) approaches to support Firebase
services or rely on other services for user authentication.
Services and Explicit Intents. Explicit intents are recom-
mended to access services offered by other apps. But, as stated
before, it is not possible to use explicit intents with HMA. Our
analysis show that 367 apps (35.1%) declare public services
that require explicit intents. This is a signiﬁcant number, yet
we noticed that a large number of apps (252) use services
with explicit intents to support Google Play services for au-
thentication (Google Sign-In user revocation). Hence, these
apps could use alternative user authentication services to be
compatible with HMA. We also notice that only 44 apps de-
clared services that belong to the app itself; this indicates that
most of these services are associated with third-parties and
probably are not part of apps’ main functionalities.
Broadcast Receivers. Whereas any app can list the broad-
cast receivers of other apps, HMA container apps obfuscate
the names of the receivers to defend against ﬁngerprinting
attacks. The container app can declare the same intent ﬁlters
for receivers that the sensitive app declares (including custom
intent ﬁlters) because other apps cannot list these intent ﬁlters.
As broadcast receivers offer asynchronous communication,
nosy apps cannot use API methods to check if an app is receiv-
ing a particular broadcast intent. In short, broadcast receivers
are supported by HMA.
10.6 HMA Usability and Desirability
To evaluate the usability of HMA and the users’ interest for it,
we conducted a user study that was approved by our institu-
tional ethical committee. It involved 30 student subjects (19
males, 11 females, 22 ± 4.5 years old) from 18 areas of study.
The participants were experienced Android users: 87% of
them have used an Android phone for at least a year. Also, they
were relatively concerned about their privacy; using the stan-
dard metric for measuring privacy perception (IUIPC) [39],
we found that, on a scale from 1 to 5, 97% of participants
USENIX Association
28th USENIX Security Symposium    725
graded at least 3.0 and an average of 4.1.
We began the study with an entry survey about demo-
graphic information, privacy postures, users’ awareness and
concerns about the problem of LIA collections. Then, we pro-
vided each participant with a fresh phone and asked them to
install and use two apps: a popular public-transportation app
for our city and an mHealth app called Cancer.Net. To pre-
cisely measure the users’ perceptions of the delay introduced
by HMA, the participants were asked to use the two aforemen-
tioned apps with and without HMA; detailed instructions were
provided to them. 67% of the participants had used the trans-
portation app before, whereas only 7% of them had used the
Cancer.Net app or an mHealth app. We ﬁnished the user
study with an exit survey containing questions related to the
usability of HMA and the users’ levels of interest in HMA. The
user-study session took ∼45 minutes, and we paid each partic-
ipant ∼$25 (i.e., 25 CHF). The transcript of survey questions
and the instructions can be found at 38.
Our study shows that the participants are concerned about
the privacy of health-related data: 90% of the participants
would be at least concerned if their health-related informa-
tion were collected by apps installed on their phones and
shared with third parties, and 87% of participants would be
at least concerned if third parties learned that they had used
health-related apps. Indeed, our study conﬁrms the ﬁndings
from previous works (e.g., [41]) that the majority of people
never read privacy policies. Therefore, the current solution of
using privacy policies by Google for LIA collections is not
satisfactory. These ﬁndings make clear the case for HMA.
Regarding the usability of HMA, only 30% of the participants
noticed a difference when the two apps ran with and without
HMA. Note that the delays that users experienced in the user
study were the ﬁrst-launch delays, which are 4.2 ± 0.06 s and
5.1 ± 0.07 s for the transportation app and the Cancer.Net
app, respectively. From the open-ended question in our exit
survey, we found that the observed differences are mainly
about the launching delay of the apps and the change in the
app names in permission prompts. From the close-ended
questions, which were coded using a ﬁve-point Likert scale,
we observe the following. Almost all participants agree that
these changes and delays are acceptable (97% and 93% of the
participants, respectively). 93% of the participants also agree
that the use of an HMA Manager to install and launch apps is
at least somewhat acceptable. Also, 90% of the participants
agreed that HMA does not affect the user experience of the apps
that it protects, and that they are at least somewhat interested