### Overhead Analysis
Boxify [24] demonstrates that the overhead introduced by opening a camera is negligible, with an additional delay of only 1.24 ms.

### Experimental Setup and Results
The results presented in this section were measured on a Google Nexus 5X phone running Android 7.0. In our experiments, the HMA App Store was connected to the phone via a micro-USB cable, eliminating network delays. Compared to the standard use of apps, HMA introduces negligible network-delay overheads. The only bandwidth overhead is the container-app payload, which is several hundred kilobytes in size.

#### 10.3.1 App Installation
When a user wants to install an mHealth app, the HMA App Store first creates a container app for it. Based on our experiments, assuming the HMA App Store has decompiled the mHealth APKs beforehand, generating a container app takes, on average, 5 seconds for 90% of the cases. A significant portion of this delay is due to the compilation of the container app, and the measurements were performed on a laptop computer. The HMA App Store can always prepare container apps in advance for each mHealth app, as discussed in Section 8.2. The container app size is only several hundred kilobytes, which the HMA Manager app can download in less than a second using a 3G or 4G Internet connection. Consequently, the total delay overhead introduced by HMA would be less than 5 seconds in the worst-case scenario and less than a second if container apps are pre-generated, which is acceptable.

On Android, apps can be launched from two different states: cold starts (where apps are launched for the first time since the phone was booted or the system killed the apps) and warm starts (where the app's activities might still reside in memory, and the system only needs to bring them to the foreground, making them faster than cold starts).

##### Experiment Set-Up
For cold-start delays, we used Android’s official launch-performance profiling method [13]. For each app, we installed its container app, copied its APK file to the container app’s private directory, and launched the container app through `adb`. We then extracted the time information from the `Displayed` entry of the `logcat` output. To simulate a first launch, we used the command `adb shell pm clear [package-name]` to reset the app to its initial state. To simulate a cold start, we used the command `adb shell am force-stop [package-name]` to kill all foreground activities and background processes of the app. For each app, we collected 50 measurements per launch setting. For a baseline, we measured the delays when the mHealth apps were executed without HMA.

To measure warm-start delays, due to the lack of Android support for profiling warm starts, we instrumented the source code of an open-source app to log the time at different stages of its lifecycle. To simulate a warm start, we used the command `input keyevent 187` to send the app to the background and then used the `monkey` command to bring it back to the foreground. By subtracting the time when the `onResume()` method is successfully executed from the time before the `monkey` command is sent, we determined the warm-start delay. We measured the warm-start delays in both settings (with and without HMA), collecting 50 measurements per setting.

##### Results
Intuitively, the first launch of an mHealth app in HMA will experience longer delays than subsequent cold starts because the container app must process the APK and store the necessary information for user-level virtualization. Our experiments show that this process takes a median of 6.5 ± 0.16 seconds (compared to 0.74 ± 0.07 seconds without HMA). This delay occurs only once and is negligible over the app's lifetime.

Figure 2 shows the bar plot of subsequent cold-start delays with and without HMA, experienced by mHealth apps. The heights of the bars represent mean values, and the error bars represent one standard deviation. The average delays are at most 3.0 ± 0.5 seconds and 1.3 ± 0.05 seconds for apps executed with and without HMA, respectively. For 90% of the cases, the average delay with HMA is less than 2.0 ± 0.3 seconds. Note that our prototype is a proof-of-concept and not optimized. Still, the observed delays are under the 5-second delay limit suggested by Android [13]. In our user study, 97% of participants agreed that a launch delay of 5 seconds is acceptable (Section 10.6).

Regarding warm-start delays, we found that the average delay for our tested app, when launched with and without HMA, was approximately 0.55 seconds. This is intuitive because the app’s processes were still running, and the activities remained in the phone’s memory. If the garbage collector evicts the activities from memory, warm-start delays can be longer due to activity initialization overheads. However, even in this case, the delay will still be less than cold-start delays (i.e., at most 3 seconds).

### 10.4 HMA Robustness and Compatibility
In this section, we evaluate HMA in terms of its robustness and compatibility with Android versions.

#### Runtime Robustness
Following the approach used in previous work (e.g., [35] and [53]), we manually tested each app in our dataset with HMA. For each mHealth app, we extracted its APK, created a container app using the HMA App Store, and installed the container app on the phone. We then used the HMA Manager to launch the app and manually tested most of its functionality to check for crashes. We found that all apps in our dataset worked normally, except one that threw an error when making an SQLite connection. To determine the cause, we ran an example app that uses the official Android API for database access (i.e., `Android.database.sqlite`) and found that it ran successfully. We suspect the error occurred because the mHealth app specified the full path to the database (i.e., `/data/data/package-name/db-name`). When running inside the HMA container app, this hardcoded path is no longer valid. Developers should specify the relative path to the database (i.e., `./db-name`) instead.

#### Compatibility
We ran HMA on a series of smartphones with Android OS versions from 5.0 to 8.0, which account for 89% of the current Android version distribution [7]. We found that HMA can be successfully deployed on mainstream commercial Android devices. However, two apps (Mole Mapper and Alzheimer’s Speed of Processing Game) initially failed to run on our Nexus 5X (Android 7.1.1) due to incompatibility between 32-bit and 64-bit systems. We fixed this by enabling the `-abi armeabi-v7a` option during installation. From the list of 20 filtered apps, we found that three apps (Hearing Aid, What’s Up, and Cardiac Diagnosis) ran successfully on Android 5.0 and 6.0 but failed in later versions. We investigated the logs and found that API methods related to GMS services, which we do not support, were called in later versions. This problem could be solved by hooking these services, as discussed in Section 10.2.

Note that, with the recent release of Android 9, Google has restricted the use of Java reflection, which all user-level virtualization techniques rely on. Therefore, new user-level virtualization techniques need to be explored for HMA to work seamlessly on Android 9. However, Android 9 has less than 1% market share [7], meaning HMA will be compatible with most Android devices in the coming years. Alternatively, HMA could work with rooted Android 9 devices using dynamic customization frameworks like Xposed.

### 10.5 Inter-App Communication Support
Sharing resources with other apps via customized features (e.g., custom permissions and custom intent-filters) and publicly exposing components (e.g., activities, services, and content providers) can facilitate fingerprinting attacks. HMA can partially support inter-app communications, but it is preferable to avoid such features to ensure robust fingerprinting protection. Avoiding inter-app communication, however, can affect apps’ functionality and backward compatibility. To estimate the effect of using HMA and avoiding inter-app communication on existing apps, we analyzed a set of popular sensitive apps from the Google Play Store. Our results show that a small number of apps use inter-app communication features not supported by HMA, and in many cases, these features are not directly related to the apps’ key functionalities.

#### Dataset
We collected a total of 1,045 APK files from the most popular free apps in the Medical and Health & Fitness categories in the US Google Play Store. Approximately 60% of these apps directly match HMA’s use case (i.e., health- and fitness-related apps). The rest are less related, such as apps for medical professionals, managing health provider accounts, and gym subscriptions. We extracted the manifest files using the `apktool` application.

#### Custom Permissions
Permissions defined by apps to control access to their components can be used to fingerprint them. We found that 531 apps declared custom permissions. However, most of these declarations are related to deprecated services (Google Cloud Messaging and Android Maps API v2) and can be replaced with newer alternatives that do not require custom permissions. Ignoring permissions associated with these deprecated services, only 68 apps (6.5%) declared valid custom permissions.

#### Signature-Level Permissions
Signature permissions are a subset of custom permissions and can be used to fingerprint apps. Since HMA container apps are signed by the same key, a malicious app inside a container app could abuse signature permissions to access resources of sensitive apps in other container apps. HMA currently does not declare signature permissions in the container apps. Our analysis shows that only 113 apps (10.8%) declared signature permissions, and many of these are associated with deprecated services.

#### Content Providers
Any app can list the content providers of other installed apps and use this information to fingerprint them. HMA obfuscates this information in the container app, meaning public content providers (used to share data with other apps) are not currently supported. Our analysis shows that only 84 apps (8%) declare public content providers. Of these, 68% are associated with third-party frameworks for services like file sharing and authentication, and approximately 23% require permission to access the provider.

#### Intent Filters
Custom intent filters, i.e., intent filters with app-specific actions, can be used to fingerprint apps. Apps cannot list the intent filters of other apps but can list all activities that can be performed by a particular intent. Our analysis shows that only 38 apps (3.6%) have activities with custom intent filters.

#### Activities and Explicit Intents
Explicit intents are currently not supported by HMA because container apps obfuscate the activities' names of sensitive apps, making direct references impossible. It is recommended to use only explicit intents to launch internal activities, not activities of other apps (implicit intents should be used instead). Our analysis shows that 170 apps (16.2%) declare activities that can be launched by other apps via explicit intents only. Many of these apps (67) declared such activities to support Google’s Firebase authentication services. However, Firebase’s official documentation does not mention this approach. To be compatible with HMA, these apps could evaluate alternative (official) approaches to support Firebase services or rely on other services for user authentication.

#### Services and Explicit Intents
Explicit intents are recommended to access services offered by other apps. However, it is not possible to use explicit intents with HMA. Our analysis shows that 367 apps (35.1%) declare public services that require explicit intents. Many of these apps (252) use services with explicit intents to support Google Play services for authentication (Google Sign-In user revocation). These apps could use alternative user authentication services to be compatible with HMA. Only 44 apps declared services that belong to the app itself, indicating that most of these services are associated with third-parties and not part of the apps’ main functionalities.

#### Broadcast Receivers
While any app can list the broadcast receivers of other apps, HMA container apps obfuscate the names of the receivers to defend against fingerprinting attacks. The container app can declare the same intent filters for receivers that the sensitive app declares, including custom intent filters, because other apps cannot list these intent filters. As broadcast receivers offer asynchronous communication, nosy apps cannot use API methods to check if an app is receiving a particular broadcast intent. In short, broadcast receivers are supported by HMA.

### 10.6 HMA Usability and Desirability
To evaluate the usability of HMA and users’ interest, we conducted a user study approved by our institutional ethical committee. The study involved 30 student subjects (19 males, 11 females, aged 22 ± 4.5 years) from 18 areas of study. The participants were experienced Android users, with 87% having used an Android phone for at least a year. They were also relatively concerned about their privacy, with 97% grading at least 3.0 out of 5 on the IUIPC scale [39], with an average of 4.1.

We began the study with an entry survey on demographic information, privacy postures, and concerns about LIA collections. Each participant was provided with a fresh phone and asked to install and use two apps: a popular public-transportation app for our city and an mHealth app called Cancer.Net. To measure the users’ perceptions of the delay introduced by HMA, participants were asked to use the two apps with and without HMA, with detailed instructions provided. 67% of the participants had used the transportation app before, while only 7% had used the Cancer.Net app or an mHealth app. The user study concluded with an exit survey on HMA’s usability and the users’ interest levels. The session took approximately 45 minutes, and each participant was paid $25 (25 CHF). The survey questions and instructions can be found at [38].

Our study shows that participants are concerned about the privacy of health-related data: 90% would be at least concerned if their health-related information were collected by apps and shared with third parties, and 87% would be at least concerned if third parties learned they had used health-related apps. These findings confirm previous works (e.g., [41]) that most people never read privacy policies, making the current solution of using privacy policies by Google for LIA collections unsatisfactory. These findings underscore the need for HMA.

Regarding HMA’s usability, only 30% of participants noticed a difference when the two apps ran with and without HMA. The delays experienced in the user study were the first-launch delays, which were 4.2 ± 0.06 seconds and 5.1 ± 0.07 seconds for the transportation app and the Cancer.Net app, respectively. From the open-ended question in our exit survey, we found that the observed differences were mainly about the launching delay and changes in app names in permission prompts. From the close-ended questions, coded using a five-point Likert scale, we observed the following: almost all participants agree that these changes and delays are acceptable (97% and 93%, respectively). 93% of participants also agree that using an HMA Manager to install and launch apps is at least somewhat acceptable. Additionally, 90% of participants agreed that HMA does not affect the user experience of the apps it protects and that they are at least somewhat interested in using HMA.