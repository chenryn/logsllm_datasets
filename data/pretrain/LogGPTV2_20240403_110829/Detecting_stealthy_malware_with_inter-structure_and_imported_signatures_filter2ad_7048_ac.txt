In general, kernel mode rootkits are implemented as kernel
modules (e.g., a device driver) and loaded into kernel space
of operating system in various ways. The most important
task of kernel mode rootkits is to hide themselves. To this
end, an e(cid:11)ective scanner should be able to discover hidden
kernel modules. In Linux, the kernel module data structure
is used to represent a loaded LKM. Unfortunately, all (cid:12)elds
of the module data structure are independent of its LKM
function except unloading. After a module being loaded,
the values of all (cid:12)elds of its data structure are insigni(cid:12)cant
to executing its code or accessing its data.
We do an experiment to demonstrate the function-indepen
dence of (cid:12)elds of the module data structure. First, we load
an LKM which contains two functions: mygetsid () and mod-
ifymyself () and a char array mystring. The mygetsid func-
tion will hook the getsid system call and output mystring
to system log; the modifymyself function is used to set the
memory block of the module data structure to zero. Second,
we will call the modifymyself function to clear the module
data structure. Final, we will call getsid system call from a
user space application to trigger the mygetsid function. We
can examine system log to determine whether the code and
data of kernel module can be executed or accessed correct-
ly after related module data structure being cleared. In the
experiment, we can observe that the correct contents of mys-
tring are output by mygetsid function to system log. The
result of the experiment proves that modifying any (cid:12)eld of
a module data structure cannot break the normal functions
of corresponding LKM.
222
DTSSFRPSignaturePageText Sectionmodule module_core Page Protection Invariant 4: for each module data structure m, there exists a signature page p, such that: (cid:120)pcontains a DTS, and (cid:120)p.RP points to mIn the rest of this section, we will describe three kinds of
objects detection in detail based on Linux 2.6.9 platform.
4.1 Hidden Sockets
Socket hiding is a common goal for attackers to conceal
their malicious communications. DeepScanner can detect
hidden sockets based on Invariant 1 or Invariant 3.
When users only want to detect hidden sockets, DeepScan-
ner uses Invariant 1 as scanning signature. In Linux 2.6.9,
the socket alloc data structure is stored in a dedicated cache
allocated by calling kernel routine kmem cache alloc. To
speed up scanning, DeepScanner employs a directive scan-
ning strategy. It fetches candidate memory block by travers-
ing the kernel slab list with speci(cid:12)c item size. DeepScan-
ner assume each candidate block cb as a socket alloc data
structure and check whether it satis(cid:12)es Invariant 1, namely
check whether ((struct socket alloc)(cb)).vfs inode is point-
ed to by (((struct socket alloc)(cb)).socket)->(cid:12)le->f dentry-
>d inode. If it meets Invariant 1, ((struct socket alloc)(cb)).socket
will be the desired socket data structure.
On the other hand, if DeepScanner already have a process
descriptor list, it can easily enumerate all socket data struc-
tures via traversing the (cid:12)les (cid:12)eld of each task struct data
structure according to Invariant 3.
4.2 Hidden Processes
Process hiding is often the primary feature of a kernel
mode rootkit. DeepScanner can detect hidden processes
based on Invariant 2.
In addition, given a complete pro-
cesses list, DeepScanner can further get all sockets using
Invariant 3.
According to Invariant 2, there are two scanning modes
to choose: scan task struct directly or scan thread info and
then get task struct indirectly. To increase scanning speed,
DeepScanner choose the latter. Prior to the 2.6 kernel se-
ries, the task struct is stored at the end of the kernel stack
of each process. In kernel 2.6, the task struct is moved from
process kernel stack to a slab block. Instead, the thread info
is stored at the bottom of the kernel stack. On x86 platform,
the process kernel stack is 8kb-aligned (two pages), so the
address of the thread info data structure is also 8kb-align.
Based on this fact, DeepScanner check candidate memory
block 8kb by 8kb rather than byte by byte, namely one scan-
ning step of DeepScanner is 8kb. During detecting hidden
processes, DeepScanner can only fetches the memory block-
s begin with 8kb-aligned address, and check whether they
satisfy Invariant 2. This scanning mode dramatically speeds
up scanning. As a comparison, if scan task struct directly,
the scanner may need to traverse target memory space byte
by byte.
Given a thread info structure, getting the corresponding
task struct is very simple. It can be obtained by referencing
the memory area pointed by thread info.task. The informa-
tion in task struct data structures obtained by scanning will
construct a scanner view of system processes.
4.3 Hidden Kernel Modules
DeepScanner uses imported signatures to detect hidden
kernel modules. In order to introduce imported signatures,
we patch the module loading mechanism of Linux kernel.
During module loading, the patched kernel will add a new
page prior to the text section of module. The page will be
allocated in HIGHMEM region of kernel memory. Deep-
Figure 10: An imported signature for the module
data structure.
signature page, which corresponds to a module data struc-
ture. Scanner can get the information about the module via
the RP pointer in the signature page and further check the
integrity of the of the module with SF.
3.3 Signatures for Linux 2.4
Because some rootkits are aimed at Linux 2.4, we also
construct corresponding invariants for Linux 2.4.18.
The signatures for Linux 2.4.18 are similar to the above
signatures. But for Linux 2.4.18, the task struct data struc-
tures are directly allocated in the process stack and there is
not a thread info data structure in kernel. For this reason,
we use an imported signature to detect hidden processes on
Linux 2.4.18 platform. The related invariant is similar to
Invariant 4.
4.
IMPLEMENTATION
To evaluate the usefulness of our approach, we implement-
ed a prototype system DeepScanner to detect the stealthy
malware in Linux. The main purpose of DeepScanner is to
demonstrate the e(cid:11)ectiveness of inter-structure and import-
ed signatures. For the sake of convenience, DeepScanner is
currently implemented as an LKM and a user mode GUI
console. DeepScanner LKM is responsible for scanning ker-
nel memory and reporting results to the console. The con-
sole is used to manage scanning operations, collect various
results, and make cross-view comparison.
As shown in Figure 10, DeepScanner uses cross-view tech-
nique to detect the hidden objects. First, DeepScanner tra-
verses target kernel memory and enumerating all processes,
sockets and modules according to above 4 invariants. Sec-
ond, it will collect the output of system utilities, including
ps, netstat, and lsmod. Finally, DeepScanner will compare
the two results of di(cid:11)erent views. If an object is found in the
scanner view but not in the utility view, it means a possible
stealthy malware is detected. Besides, because the imported
signature is the base to detect hidden modules, we also im-
plement a hypervisor based monitor to protect the signature
page.
223
Kenerl MemoryDeepScannerInter-structure SignaturesImported SignatureScanningObjects in Scanner View Objects in Utility View HiddenObjects_System Utilities (ps,netstat,lsmod)Table 1: The Con(cid:12)gurations of experiment environ-
ment.
Hardware Con(cid:12)guration
Processor
RAM
Storage
Intel Core(TM2) T5600, 1.83GHz
2.0GB
60GB IDE
Hypervisor Con(cid:12)guration
Hypervisor
Version
Xen
3.1.0
Host OS Con(cid:12)guration
OS Version
Red Hat Enterprise Linux 5
Kernel Version 2.6.18
Xen supported Domain 0
Guest OS Con(cid:12)guration I
OS Version
Red Hat Enterprise Linux 4
Kernel Version 2.6.9
Xen supported
Paravirtualization Domain U
Guest OS Con(cid:12)guration II
OS Version
Red Hat 7.3
Kernel Version 2.4.18
Xen supported HVM
tables will be trapped into hypervisor [11]. The function
ptwr do page fault will be called to handle the update oper-
ation when guest OS is in kernel mode. Based on the model,
we implement a protection monitor (PM) in XEN hypervi-
sor. It will intercept ptwr do page fault to check if the target
PTE to be updated to writeable corresponds to a signature
page.
If so, the update operations will be terminated by
PM. As shown in Figure 11, to identify the signature pages
in hypervisor, we add a new hypercall do write protect page
to XEN. When a new signature page is created, system will
invoke do write protect page to notify PM and send the vir-
tual address of the related PTE to it. The PM maintains
a list to store the addresses of PTEs need to be protected.
With the support of the list, the PM can know which update
to PTE needs to be checked. Consequently, the signature
pages always are read only after being created.
In XEN full-virtualization (HVM) mode, Shadow Page
Table (SPT) is employed to manage the memory. A page
fault handler sh page fault is used to handle the page faults.
Mapping a guest OS page to a shadow page with di(cid:11)eren-
t permissions will be trapped into the handler. Similar to
the case in para-virtualization, the system will invoke a new
hypercall do hvm write protect page to notify the PM that
a new signature page has been created, and PM will record
the address of PTE of the signature page. When a mapping
being trapped, PM will intercept sh page fault to check if
there is a di(cid:11)erent permission setting about the PTE of sig-
nature pages (writeable for guest OS pages while read-only
for shadow pages). If so, PM makes sure the physical pages
are marked read-only.
5. EVALUATION
In this section, we present our experiments and results. In
particular, we have conducted two sets of experiments. The
(cid:12)rst set of experiments is to evaluate DeepScanner’s e(cid:11)ec-
tiveness in detecting seven real-world rootkits. These rootk-
its cover the major stealth techniques (KOH and DKOM)
currently employed by malwares. DeepScanner turns out to
Figure 11: Signature Page Protection in XEN Para-
virtualization Mode.
Scanner check each page in HIGHMEM region to check
whether it contains a DTS. The DTS is an 8 bytes sequence
0x89c089db89c989d2 corresponding to a NOP instructions
segment (mov eax, eax ; mov ebx, ebx ; mov ecx, ecx ; mov edx,
edx ). The NOP instruction sequence has enough discrim-
inability and normally doesn’t exist in the system memory
space according to our observations. Furthermore, it is fully
side-e(cid:11)ect-free. According to our experiments, the sequence
can be used to unambiguously identify signature pages.
The RP part of a signature page is a pointer to corre-
sponding module data structure, and the SF part stores
some static (cid:12)elds of the module data structure, including
name, module core, syms, etc. After getting a signature
page, DeepScanner will get necessary information of a mod-
ule data structure via RP pointer and further check the in-
tegrity of the data structure via comparing it with SF.
A problem need to be considered is that attackers can
introduce noise by constructing some malformed imported
signature pages following our design, which may lead to false
positives. From the viewpoint of system security detection,
it is sure that the integrity of system has been compromised
when a scanner found a malformed signature. In other word-
s, the system has been intruded by attackers. Because a
primary goal of attackers is concealing their behaviors, we
think attackers don’t want to interfere security detection
mechanism by this way.
To DeepScanner, signature page protection is critical to
discover hidden kernel modules. It will be describe in fol-
lowing subsection.
4.4 Signature Page Protection
The integrity of signature pages determines the e(cid:11)ective-
ness of hidden kernel module detection.
It is not enough
for signature pages protection just only to set the signature
page to read-only in its page table entry (PTE). Kernel mod-
e rootkits can easily modify the PTE and set the signature
page to writable.
In this paper, we employ VMM technique to protect the
integrity of imported signature pages. We implement a mon-
itor in XEN hypervisor. Any attempts to modify the access
permissions of signature page will be trapped into the hyper-
visor. The monitor will terminate the operation to modify
the PTE of signature pages.
In XEN para-virtualization mode, a guest OS is not per-
mitted to modify its page tables directly, any update of page
224
Hypervisor Guest OS PTEPTEPTEPTEPage Table update PTEptwr_do_page_fault Protection MonitorSignaturePage create a signature pagedo_write_protect_pageinvokehypercalltraplist of protected PTE address PTEaddresscheck Table 2: E(cid:11)ectiveness of DeepScanner in detecting 7 real-world rootkits.
Rootkit
Kernal
Hidden Function
process
socket module
Stealth Techniques
adore-0.42
knark-2.4.3
wnps-0.26
Linux 2.4
adore-ng-0.56 Linux 2.6
Linux 2.4
Linux 2.6
enyelkm-1.1.2 Linux 2.6
Linux 2.4
Linux 2.4
modhide-1.0
hp-1.0.0
Y
Y
Y
Y
Y
Y
N
Y
Y
Y
Y
N
N
N
Y
Y
Y
Y
Y
N
Y
DOH, DKOM
DOH, DKOM
DOH, DKOM
DOH, DKOM
DOH
DKOM
DKOM
process
socket module
p
p