响应式系统是我们所知的最具 *生产效率* 的系统架构（在多核、云及移动架构的背景下）：
* 错误的隔离为组件与组件之间裹上[舱壁](http://skife.org/architecture/fault-tolerance/2009/12/31/bulkheads.html)（LCTT 译注：当船遭到损坏进水时，舱壁能够防止水从损坏的船舱流入其他船舱），防止引发连锁错误，从而限制住错误的波及范围以及严重性。
* 监管者的层级制度提供了多个等级的防护，搭配以自我修复能力，避免了许多曾经在侦查(inverstigate)时引发的操作 代价   （    cost    ） ——大量的 瞬时故障   （    transient failures    ） 。
* 消息传送和位置透明性允许组件被卸载下线、代替或 重新布线   （    rerouted    ） 同时不影响终端用户的使用体验，并降低中断的代价、它们的相对紧迫性以及诊断和修正所需的资源。
* 复制减少了数据丢失的风险，减轻了数据 检索   （    retrieval    ） 和存储的有效性错误的影响。
* 韧性允许在使用率波动时保存资源，允许在负载很低时，最小化操作开销，并且允许在负载增加时，最小化 运行中断   （    outgae    ） 或 紧急投入   （    urgent investment    ） 伸缩性的风险。
因此，响应式系统使 生成系统   （    creation systems    ） 很好的应对错误、随时间变化的负载——同时还能保持低运营成本。
### 响应式编程与响应式系统的关联
响应式编程是一种管理 内部逻辑   （    internal logic    ） 和 数据流转换   （    dataflow transformation    ） 的好技术，在本地的组件中，做为一种优化代码清晰度、性能以及资源利用率的方法。响应式系统，是一组架构上的原则，旨在强调分布式信息交流并为我们提供一种处理分布式系统弹性与韧性的工具。
只使用响应式编程常遇到的一个问题，是一个事件驱动的基于回调的或声明式的程序中两个计算阶段的 高度耦合   （    tight coupling    ） ，使得 *弹性* 难以实现，因此时它的转换链通常存活时间短，并且它的各个阶段——回调函数或 组合子   （    combinator    ） ——是匿名的，也就是不可寻址的。
这意味着，它通常在内部处理成功与错误的状态而不会向外界发送相应的信号。这种寻址能力的缺失导致单个 阶段   （    stages    ） 很难恢复，因为它通常并不清楚异常应该，甚至不清楚异常可以，发送到何处去。
另一个与响应式系统方法的不同之处在于单纯的响应式编程允许 *时间* 上的 解耦   （    decoupling    ） ，但不允许 *空间* 上的（除非是如上面所述的，在底层通过网络传送消息来 分发   （    distribute    ） 数据流）。正如叙述的，在时间上的解耦使 *并发性* 成为可能，但是是空间上的解耦使  分布   （    distribution    ） 和 移动性   （    mobility    ）  （使得不仅仅静态拓扑可用，还包括了动态拓扑）成为可能的——而这些正是 *韧性* 所必需的要素。
位置透明性的缺失使得很难以韧性方式对一个基于适应性响应式编程技术的程序进行向外扩展，因为这样就需要分附加工具，例如 消息总线   （    message bus    ） ， 数据网格   （    data grid    ） 或者在顶层的 定制网络协议   （    bespoke network protocol    ） 。而这点正是响应式系统的消息驱动编程的闪光的地方，因为它是一个包含了其编程模型和所有伸缩向度语义的交流抽象概念，因此降低了复杂性与认知超载。
对于基于回调的编程，常会被提及的一个问题是写这样的程序或许相对来说会比较简单，但最终会引发一些真正的后果。
例如，对于基于匿名回调的系统，当你想理解它们，维护它们或最重要的是在 生产供应中断   （    production outages    ） 或错误行为发生时，你想知道到底发生了什么、发生在哪以及为什么发生，但此时它们只提供极少的内部信息。
为响应式系统设计的库与平台（例如 [Akka](http://akka.io/) 项目和 [Erlang](https://www.erlang.org/) 平台）学到了这一点，它们依赖于那些更容易理解的长期存活的可寻址组件。当错误发生时，根据导致错误的消息可以找到唯一的组件。当可寻址的概念存在组件模型的核心中时， 监控方案   （    monitoring solution    ） 就有了一个 *有意义* 的方式来呈现它收集的数据——利用 传播   （    propagated    ） 的身份标识。
一个好的编程范式的选择，一个选择实现像可寻址能力和错误管理这些东西的范式，已经被证明在生产中是无价的，因它在设计中承认了现实并非一帆风顺，*接受并拥抱错误的出现* 而不是毫无希望地去尝试避免错误。
总而言之，响应式编程是一个非常有用的实现技术，可以用在响应式架构当中。但是记住这只能帮助管理一部分：异步且非阻塞执行下的数据流管理——通常只在单个结点或服务中。当有多个结点时，就需要开始认真地考虑像 数据一致性   （    data consistency    ） 、 跨结点沟通   （    cross-node communication    ） 、 协调   （    coordination    ） 、 版本控制   （    versioning    ） 、 编制   （    orchestration    ） 、 错误管理   （    failure management    ） 、 关注与责任   （    concerns and responsibilities    ） 分离等等的东西——也即是：系统架构。
因此，要最大化响应式编程的价值，就把它作为构建响应式系统的工具来使用。构建一个响应式系统需要的不仅是在一个已存在的遗留下来的 软件栈   （    software stack    ） 上抽象掉特定的操作系统资源和少量的异步 API 和   断路器    （    circuit breakers    ） 。此时应该拥抱你在创建一个包含多个服务的分布式系统这一事实——这意味着所有东西都要共同合作，提供一致性与灵敏的体验，而不仅仅是如预期工作，但同时还要在发生错误和不可预料的负载下正常工作。
### 总结
企业和中间件供应商在目睹了应用响应式所带来的企业利润增长后，同样开始拥抱响应式。在本文中，我们把响应式系统做为企业最终目标进行描述——假设了多核、云和移动架构的背景——而响应式编程则从中担任重要工具的角色。
响应式编程在内部逻辑及数据流转换的组件层次上为开发者提高了生产率——通过性能与资源的有效利用实现。而响应式系统在构建  原生云   （    cloud native    ）  和其它大型分布式系统的系统层次上为架构师及 DevOps 从业者提高了生产率——通过弹性与韧性。我们建议在响应式系统设计原则中结合响应式编程技术。
### 脚注
> 
> 1. 参考 Conal Elliott，FRP 的发明者，见[这个演示](https://begriffs.com/posts/2015-07-22-essence-of-frp.html)。
> 2. [Amdahl 定律](https://en.wikipedia.org/wiki/Amdahl%2527s_law)揭示了系统理论上的加速会被一系列的子部件限制，这意味着系统在新的资源加入后会出现 收益递减   （    diminishing returns    ） 。
> 3. Neil Günter 的   通用可伸缩性定律    （    Universal Scalability Law    ） 是理解并发与分布式系统的竞争与协作的重要工具，它揭示了当新资源加入到系统中时，保持一致性的开销会导致不好的结果。
> 4. 消息可以是同步的（要求发送者和接受者同时存在），也可以是异步的（允许他们在时间上解耦）。其语义上的区别超出本文的讨论范围。
> 
> 
> 
---
via: 
作者：[Jonas Bonér](https://www.oreilly.com/people/e0b57-jonas-boner)， [Viktor Klang](https://www.oreilly.com/people/f96106d4-4ce6-41d9-9d2b-d24590598fcd) 译者：[XLCYun](https://github.com/XLCYun) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 组织编译，[Linux中国](https://linux.cn/) 荣誉推出