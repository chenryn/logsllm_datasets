# References

[14] Karthikeyan Bhargavan, Antoine Delignat-Lavaud, Cédric Fournet, Anitha Gollamudi, Georges Gonthier, Nadim Kobeissi, Natalia Kulatova, Aseem Rastogi, Thomas Sibut-Pinote, Nikhil Swamy, et al. 2016. Formal verification of smart contracts: Short paper. In *Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for Security*. ACM, 91–96.

[15] Alex Biryukov, Dmitry Khovratovich, and Sergei Tikhomirov. 2017. Findel: Secure Derivative Contracts for Ethereum. In *International Conference on Financial Cryptography and Data Security*. Springer, 453–467.

[16] Nikolaj Bjørner, Arie Gurfinkel, Ken McMillan, and Andrey Rybalchenko. 2015. Horn clause solvers for program verification. In *Fields of Logic and Computation II*. Springer, 24–51.

[17] Rod M. Burstall and John Darlington. 1977. A transformation system for developing recursive programs. *Journal of the ACM (JACM)* 24, 1 (1977), 44–67.

[18] Patrick Cousot and Radhia Cousot. 2004. Basic concepts of abstract interpretation. In *Building the Information Society*. Springer, 359–366.

[19] Monika Di Angelo and Gernot Salzer. 2019. A survey of tools for analyzing Ethereum smart contracts. In *2019 IEEE International Conference on Decentralized Applications and Infrastructures (DAPPCON)*. IEEE, 69–78.

[20] Changyu Dong, Yilei Wang, Amjad Aldweesh, Patrick McCorry, and Aad van Moorsel. 2017. Betrayal, Distrust, and Rationality: Smart Counter-Collusion Contracts for Verifiable Cloud Computing. (2017).

[21] Ethereum. 2018. Solidity Docs. *Ethereum*. https://solidity.readthedocs.io/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions

[22] Ethereum. 2019. Solidity Docs. *Ethereum*. https://solidity.readthedocs.io/en/v0.5.13/security-considerations

[23] Neville Grech, Michael Kong, Anton Jurisevic, Lexi Brent, Bernhard Scholz, and Yannis Smaragdakis. 2018. MadMax: Surviving Out-of-gas Conditions in Ethereum Smart Contracts. *Object-Oriented Programming, Systems, Languages & Applications (OOPSLA)* (2018).

[24] Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. 2018. Foundations and Tools for the Static Analysis of Ethereum Smart Contracts. In *Proceedings of the 30th International Conference on Computer-Aided Verification (CAV)*. Springer, 51–78.

[25] Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. 2018. A Semantic Framework for the Security Analysis of Ethereum Smart Contracts. In *Proceedings of the 7th International Conference on Principles of Security and Trust (POST)*. Springer, 243–269.

[26] Shelly Grossman, Ittai Abraham, Guy Golan-Gueta, Yan Michalevsky, Noam Rinetzky, Mooly Sagiv, and Yoni Zohar. 2017. Online detection of effectively callback free objects with applications to smart contracts. *Proceedings of the ACM on Programming Languages* 2, POPL (2017), 48.

[27] Adam Hahn, Rajveer Singh, Chen-Ching Liu, and Sijie Chen. 2017. Smart Contract-Based Campus Demonstration of Decentralized Transactive Energy Auctions. In *Power & Energy Society Innovative Smart Grid Technologies Conference (ISGT), 2017 IEEE*. IEEE, 1–5.

[28] Manuel V. Hermenegildo, Francisco Bueno, Manuel Carro, Pedro López-García, Edison Mera, José F. Morales, and Germán Puebla. 2012. An overview of Ciao and its design philosophy. *Theory and Practice of Logic Programming* 12, 1-2 (2012), 219–252.

[29] Everett Hildenbrandt, Manasvi Saxena, Xiaoran Zhu, Nishant Rodrigues, Philip Daian, Dwight Guth, and Grigore Rosu. 2017. KEVM: A Complete Semantics of the Ethereum Virtual Machine. *Technical Report*.

[30] Yoichi Hirai. 2017. Defining the Ethereum Virtual Machine for Interactive Theorem Provers. In *International Conference on Financial Cryptography and Data Security*. Springer, 520–535.

[31] Kryštof Hoder and Nikolaj Bjørner. 2012. Generalized property directed reachability. In *International Conference on Theory and Applications of Satisfiability Testing*. Springer, 157–171.

[32] Kryštof Hoder, Nikolaj Bjørner, and Leonardo De Moura. 2011. µZ–an efficient engine for fixed points with constraints. In *International Conference on Computer Aided Verification*. Springer, 457–462.

[33] Herbert Jordan, Bernhard Scholz, and Pavle Subotić. 2016. Soufflé: On synthesis of program analyzers. In *International Conference on Computer Aided Verification*. Springer, 422–430.

[34] Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. 2018. ZEUS: Analyzing Safety of Smart Contracts. *NDSS*.

[35] Johannes Krupp and Christian Rossow. 2018. TEETHER: Gnawing at Ethereum to Automatically Exploit Smart Contracts. In *Proceedings of the 27th USENIX Conference on Security Symposium (SEC’18)*. USENIX Association, 1317–1333.

[36] Jing Liu and Zhentian Liu. 2019. A survey on security verification of blockchain smart contracts. *IEEE Access* 7 (2019), 77894–77904.

[37] Ning Lu, Bin Wang, Yongxin Zhang, Wenbo Shi, and Christian Esposito. 2019. NeuCheck: A more practical Ethereum smart contract security analysis tool. *Software: Practice and Experience* (2019).

[38] Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor. 2016. Making smart contracts smarter. In *Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security*. ACM, 254–269.

[39] Florian Mathieu and Ryno Mathee. 2017. Blocktix: Decentralized Event Hosting and Ticket Distribution Network. (2017). Available at https://blocktix.io/public/doc/blocktix-wp-draft.pdf.

[40] Patrick McCorry, Siamak F. Shahandashti, and Feng Hao. 2017. A Smart Contract for Boardroom Voting with Maximum Voter Privacy. *Proceedings of the Financial Cryptography and Data Security Conference* (2017).

[41] Satoshi Nakamoto. 2008. Bitcoin: A Peer-to-Peer Electronic Cash System. Available at http://bitcoin.org/bitcoin.pdf.

[42] Ivica Nikolić, Aashish Kolluri, Ilya Sergey, Prateek Saxena, and Aquinas Hobor. 2018. Finding The Greedy, Prodigal, and Suicidal Contracts at Scale. *arXiv preprint arXiv:1802.06038* (2018).

[43] Benedikt Notheisen, Magnus Gödde, and Christof Weinhardt. 2017. Trading Stocks on Blocks-Engineering Decentralized Markets. In *International Conference on Design Science Research in Information Systems*. Springer, 474–478.

[44] Trail of Bits. 2018. Manticore: Symbolic Execution for Humans. https://github.com/trailofbits/manticore.

[45] Daejun Park, Yi Zhang, Manasvi Saxena, Philip Daian, and Grigore Roşu. 2018. A formal verification tool for Ethereum VM bytecode. In *Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering*. ACM, 912–915.

[46] Hisao Tamaki. 1984. Unfold/fold transformation of logic programs. *Proc. of 2nd ILPC* (1984), 127–138.

[47] Christof Ferreira Torres, Julian Schütte, et al. 2018. Osiris: Hunting for integer bugs in Ethereum smart contracts. In *Proceedings of the 34th Annual Computer Security Applications Conference (SAC)*. ACM, 664–676.

[48] Petar Tsankov, Andrei Dan, Dana Drachsler-Cohen, Arthur Gervais, Florian Bünzli, and Martin Vechev. 2018. Securify: Practical Security Analysis of Smart Contracts. In *Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security (Toronto, Canada) (CCS)*. ACM, 67–82.

[49] Zheng Yang and Hang Lei. 2019. FEther: An Extensible Definitional Interpreter for Smart-Contract Verifications in Coq. *IEEE Access* 7 (2019), 37770–37791.

[50] Ence Zhou, Song Hua, Bingfeng Pi, Jun Sun, Yashihide Nomura, Kazuhiro Yamashita, and Hidetoshi Kurihara. 2018. Security Assurance for Smart Contract. In *New Technologies, Mobility and Security (NTMS), 2018 9th IFIP International Conference on*. IEEE, 1–5.

## Appendix

The appendix is structured as follows:

- **§ A**: Overview of the analysis specification language HoRSt.
- **§ B**: Theoretical foundations of our work, including the soundness proof of our analysis.
- **§ C**: Implementation details of the security properties discussed in the paper using HoRSt.
- **§ D**: Discussion of soundness issues in related works, with concrete counterexamples highlighting soundness flaws in existing static analyzers.

### A. HoRSt

This section introduces the newly developed language HoRSt, which allows for high-level specification of Horn-clause-based static analyses. We will first provide a brief primer illustrating the main functionality of HoRSt, followed by a detailed discussion of its language features.

#### A.1. HoRSt by Example

To illustrate the features of HoRSt, we show how to express a general rule for binary stack operations, subsuming the rule for addition presented in § 3. Figure 13 shows an excerpt of the HoRSt specification for the presented static analysis.

**Abstract Domain:**
The abstract domain of the analysis is realized by the definition of the abstract datatype `AbsDom`.

**Predicate Signatures:**
Predicate signatures can be specified by corresponding predicate declarations, as done for the `MState` predicate. HoRSt allows parametrizing predicates to specify whole predicate families. The `MState` predicate is parametrized by two integer values (specified in curly braces) that correspond to the contract's identifier and the program counter whose state it approximates.

**Non-Recursive Operations:**
HoRSt supports non-recursive operations over arbitrary types, such as `absadd`, which implements abstract addition. In the given example, we present a single rule template for generating rules for all binary stack operations. We define a function `binOp` that, given an opcode `c` and two integer arguments, applies the binary operation corresponding to the opcode. This function is then used in the rule template `opBin`.

**Rule Templates:**
Rule templates serve to generate the abstract semantics in the form of Horn clauses. Since the abstract semantics is specified as a function on a concrete contract, the generation of Horn clauses in HoRSt needs to be linked to a concrete contract bytecode.

**Selector Functions:**
To handle tasks like reading files or parsing bytecodes, HoRSt provides an interface for interacting with custom relations generated by Java™ code. This interface is specified upfront by so-called selector functions, which are declared but not defined in the HoRSt specification. In the given example, we declare selector functions for accessing the identifiers of the contracts to be analyzed (`ids`), the set of binary operations (`binOps`), and for the program counters in a contract that hold opcodes of a specific type (`pcsForIdAndOpcode`). Additionally, selector functions allow for incorporating the results of a pre-analysis, as shown by the `argumentsTwoForIdAndPc` selector function.

**Horn Clause Generation:**
We can parametrize the rule over the cross product of the result of (nested) selector function applications, as done for the `opBin` rule. This generates Horn clauses abstracting the behavior of a binary stack operation: a stack size check is performed, the two arguments are selected from the stack, and finally, the `MState` predicate at the next program counter is implied with an updated stack having the operation’s result as the top element.

```hoRSt
1 datatype AbsDom := @T | @V ; // Abstract Domain
2 datatype Opcode := @STOP | @ADD | ... | @INVALID | @SELFDESTRUCT // opcodes (shortened)
3
4 pred MState { int * int }: int * array  * array  * array  * bool ;
5
6 op absadd (a: AbsDom, b: AbsDom): AbsDom := match (a, b) with | (@V(x), @V(y)) => @V((x + y) mod MAX) | _ => @T;
7 op binOp (c: Opcode, x: AbsDom, y: AbsDom): AbsDom := match c with | @ADD => absadd(x, y) | ... | _ => @T;
8
9 sel ids : unit -> [int]; // contracts to be analyzed
10 sel binOps : unit -> [int]; // binary stack operations
11 sel pcsForIdAndOpcode : int * int -> [int]; // program counters at which a specific opcode occurs in a specific contract
12 sel argumentsTwoForIdAndPc : int * int -> [int * int]; // results from the preanalysis for a given contract and pc
13
14 op tryConcrete {!c: int}(val: AbsDom): AbsDom := (!c = ~1) ? (val) : (@V(!c));
15
16 rule opBin :=
17
18 MState {!id, !pc}(?size, ?sa, ?mem, ?stor, ?cl), ?size > 1,
19 ?x = tryConcrete {!a}(select ?sa(?size - 1)),
20 ?y = tryConcrete {!b}(select ?sa(?size - 2))
21 => MState {!id, !pc + 1}(?size - 1, store ?sa(?size - 2)(binOp(intToOpCode(!op), ?x, ?y)), ?mem, ?stor, ?cl);
22
23 (!id: int) in ids(),
24 (!pc: int) in pcsForIdAndOpcode(!id, !op),
25 (!a: int, !b: int) in argumentsTwoForIdAndPc(!id, !pc)
26 clause [?x: AbsDom, ?y: AbsDom, ?size: int, ?sa: array, ?mem: array, ?stor: array, ?cl: bool]
27 for (!op: int) in binOps(),
```

**Figure 13:** HoRSt rule describing the abstract semantics of local binary stack operations.

#### A.2. HoRSt in Detail

**Types and Operations:**
HoRSt provides primitive types `Boolean` and `Integer`, non-recursive sum types, and arrays over all types. The type of abstract values \(\hat{D}\) used in § 3, consisting of the unknown value \(\top\) and concrete integer values, can be defined as follows:

```hoRSt
1 datatype AbsDom = @T | @V;
```

HoRSt also allows defining non-recursive operations over arbitrary types, implemented as hygienic macros on the expression level. For working with sum types, HoRSt provides match expressions. For example, the abstract addition operation described in § 3.2 can be defined as:

```hoRSt
1 op absadd (a: AbsDom, b: AbsDom): AbsDom :=
2 match (a, b) with
3 | (@V(x), @V(y)) => @V(x + y) // for two concrete values, return sum
4 | _ => @T; // else return top
```

**Predicates:**
The abstraction’s predicate signature \(S\) is given in terms of predicate declarations. A predicate declaration introduces a predicate symbol that ranges over arguments of arbitrary types. HoRSt supports declaring a whole family of predicates with the same argument types by allowing the specification of compile-time constants, called parameters. For example, the `MState` predicate:

```hoRSt
1 pred MState { int }: int * array  * array  * array  * bool;
```

**Selector Functions:**
HoRSt itself provides no facilities to read files, parse bytecode, etc. Instead, these tasks are handled by Java™ code. HoRSt interacts with this Java™ code through an upfront-specified interface implemented by so-called selector functions. Selector functions are restricted to take a fixed number of arguments of primitive types and to return a sequence of tuples of primitive types.

Examples of selector function declarations:

```hoRSt
1 sel interval : int -> [int]; // integers from 0 to (n - 1)
2 sel pcsForOpcode : int -> [int]; // program counters for given opcode
3 sel pcsAndValuesForOpcode : int -> [int * int]; // program counters and precomputed values
```

**Rules:**
The fundamental abstraction of HoRSt is the concept of a rule, which describes a collection of Horn clauses. A rule can be either a singleton rule instantiated once or a template for arbitrarily many instantiations, describing a family of rules. The second case is enabled by the use of selector functions, which provide the sequence that the rule family ranges over. For each tuple returned by a selector function, the parameters of the rule template will be instantiated according to the tuple values.