and Big Data (OBD), International Conference on. IEEE, 25–30.
[14] Karthikeyan Bhargavan, Antoine Delignat-Lavaud, Cédric Fournet, Anitha Gol-
lamudi, Georges Gonthier, Nadim Kobeissi, Natalia Kulatova, Aseem Rastogi,
Thomas Sibut-Pinote, Nikhil Swamy, et al. 2016. Formal verification of smart
contracts: Short paper. In Proceedings of the 2016 ACM Workshop on Programming
Languages and Analysis for Security. ACM, 91–96.
[15] Alex Biryukov, Dmitry Khovratovich, and Sergei Tikhomirov. 2017. Findel:
Secure Derivative Contracts for Ethereum. In International Conference on Financial
Cryptography and Data Security. Springer, 453–467.
[16] Nikolaj Bjørner, Arie Gurfinkel, Ken McMillan, and Andrey Rybalchenko. 2015.
Horn clause solvers for program verification. In Fields of Logic and Computation
II. Springer, 24–51.
[17] Rod M Burstall and John Darlington. 1977. A transformation system for develop-
ing recursive programs. Journal of the ACM (JACM) 24, 1 (1977), 44–67.
[18] Patrick Cousot and Radhia Cousot. 2004. Basic concepts of abstract interpretation.
In Building the Information Society. Springer, 359–366.
[19] Monika Di Angelo and Gernot Salzer. 2019. A survey of tools for analyzing
ethereum smart contracts. In 2019 IEEE International Conference on Decentralized
Applications and Infrastructures (DAPPCON). IEEE, 69–78.
[20] Changyu Dong, Yilei Wang, Amjad Aldweesh, Patrick McCorry, and Aad van
Moorsel. 2017. Betrayal, Distrust, and Rationality: Smart Counter-Collusion
Contracts for Verifiable Cloud Computing. (2017).
eThor: Practical and Provably Sound Static Analysis
of Ethereum Smart Contracts
Accepted for ACM CCS, 2020
[21] Ethereum 2018. Solidity Docs. Ethereum. https://solidity.readthedocs.io/en/
develop/control-structures.html#error-handling-assert-require-revert-and-
exceptions
[22] Ethereum 2019. Solidity Docs. Ethereum. https://solidity.readthedocs.io/en/
v0.5.13/security-considerations
[23] Neville Grech, Michael Kong, Anton Jurisevic, Lexi Brent, Bernhard Scholz,
and Yannis Smaragdakis. 2018. MadMax: Surviving Out-of-gas Conditions in
Ethereum Smart Contracts. Object-Oriented Programming, Systems, Languages &
Applications OOPSLA (2018).
[24] Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. 2018. Foundations
and Tools for the Static Analysis of Ethereum Smart Contracts. In Proceedings of
the 30th International Conference on Computer-Aided Verification (CAV). Springer,
51–78.
[25] Ilya Grishchenko, Matteo Maffei, and Clara Schneidewind. 2018. A Semantic
Framework for the Security Analysis of Ethereum Smart Contracts. In Proceedings
of the 7th International Conference on Principles of Security and Trust (POST).
Springer, 243–269.
[26] Shelly Grossman, Ittai Abraham, Guy Golan-Gueta, Yan Michalevsky, Noam
Rinetzky, Mooly Sagiv, and Yoni Zohar. 2017. Online detection of effectively
callback free objects with applications to smart contracts. Proceedings of the ACM
on Programming Languages 2, POPL (2017), 48.
[27] Adam Hahn, Rajveer Singh, Chen-Ching Liu, and Sijie Chen. 2017. Smart
Contract-Based Campus Demonstration of Decentralized Transactive Energy
Auctions. In Power & Energy Society Innovative Smart Grid Technologies Conference
(ISGT), 2017 IEEE. IEEE, 1–5.
[28] Manuel V Hermenegildo, Francisco Bueno, Manuel Carro, Pedro López-García,
Edison Mera, José F Morales, and Germán Puebla. 2012. An overview of Ciao and
its design philosophy. Theory and Practice of Logic Programming 12, 1-2 (2012),
219–252.
[29] Everett Hildenbrandt, Manasvi Saxena, Xiaoran Zhu, Nishant Rodrigues, Philip
Daian, Dwight Guth, and Grigore Rosu. 2017. KEVM: A Complete Semantics of
the Ethereum Virtual Machine. Technical Report.
[30] Yoichi Hirai. 2017. Defining the ethereum virtual machine for interactive theorem
provers. In International Conference on Financial Cryptography and Data Security.
Springer, 520–535.
[31] Kryštof Hoder and Nikolaj Bjørner. 2012. Generalized property directed reach-
ability. In International Conference on Theory and Applications of Satisfiability
Testing. Springer, 157–171.
[32] Kryštof Hoder, Nikolaj Bjørner, and Leonardo De Moura. 2011. µZ–an efficient
engine for fixed points with constraints. In International Conference on Computer
Aided Verification. Springer, 457–462.
[33] Herbert Jordan, Bernhard Scholz, and Pavle Subotić. 2016. Soufflé: On synthesis
of program analyzers. In International Conference on Computer Aided Verification.
Springer, 422–430.
[34] Sukrit Kalra, Seep Goel, Mohan Dhawan, and Subodh Sharma. 2018. ZEUS:
Analyzing Safety of Smart Contracts. NDSS.
[35] Johannes Krupp and Christian Rossow. 2018. TEETHER: Gnawing at Ethereum
to Automatically Exploit Smart Contracts. In Proceedings of the 27th USENIX
Conference on Security Symposium (SEC’18). USENIX Association, 1317–1333.
[36] Jing Liu and Zhentian Liu. 2019. A survey on security verification of blockchain
smart contracts. IEEE Access 7 (2019), 77894–77904.
[37] Ning Lu, Bin Wang, Yongxin Zhang, Wenbo Shi, and Christian Esposito. 2019.
NeuCheck: A more practical Ethereum smart contract security analysis tool.
Software: Practice and Experience (2019).
[38] Loi Luu, Duc-Hiep Chu, Hrishi Olickel, Prateek Saxena, and Aquinas Hobor.
2016. Making smart contracts smarter. In Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security. ACM, 254–269.
[39] Florian Mathieu and Ryno Mathee. 2017. Blocktix: Decentralized Event Hosting
and Ticket Distribution Network. (2017). Available at https://blocktix.io/public/
doc/blocktix-wp-draft.pdf.
[40] Patrick McCorry, Siamak F. Shahandashti, and Feng Hao. 2017. A Smart Contract
for Boardroom Voting with Maximum Voter Privacy. Proceedings of the Financial
Cryptography and Data Security Conference (2017).
[41] Satoshi Nakamoto. 2008. Bitcoin: A Peer-to-Peer Electronic Cash System. Avail-
able at http://bitcoin.org/bitcoin.pdf.
[42] Ivica Nikolic, Aashish Kolluri, Ilya Sergey, Prateek Saxena, and Aquinas Hobor.
2018. Finding The Greedy, Prodigal, and Suicidal Contracts at Scale. arXiv
preprint arXiv:1802.06038 (2018).
[43] Benedikt Notheisen, Magnus Gödde, and Christof Weinhardt. 2017. Trading
Stocks on Blocks-Engineering Decentralized Markets. In International Conference
on Design Science Research in Information Systems. Springer, 474–478.
[44] Trail of Bits. 2018. Manticore: Symbolic Execution for Humans. https://
github.com/trailofbits/manticore.
[45] Daejun Park, Yi Zhang, Manasvi Saxena, Philip Daian, and Grigore Roşu. 2018. A
formal verification tool for ethereum vm bytecode. In Proceedings of the 2018 26th
ACM Joint Meeting on European Software Engineering Conference and Symposium
on the Foundations of Software Engineering. ACM, 912–915.
[46] Hisao Tamaki. 1984. Unfold/fold transformation of logic programs. Proc. of 2nd
ILPC (1984), 127–138.
[47] Christof Ferreira Torres, Julian Schütte, et al. 2018. Osiris: Hunting for integer
bugs in ethereum smart contracts. In Proceedings of the 34th Annual Computer
Security Applications Conference (SAC). ACM, 664–676.
[48] Petar Tsankov, Andrei Dan, Dana Drachsler-Cohen, Arthur Gervais, Florian
Bünzli, and Martin Vechev. 2018. Securify: Practical Security Analysis of Smart
Contracts. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and
Communications Security (Toronto, Canada) (CCS). ACM, 67–82.
[49] Zheng Yang and Hang Lei. 2019. FEther: An Extensible Definitional Interpreter
for Smart-Contract Verifications in Coq. IEEE Access 7 (2019), 37770–37791.
[50] Ence Zhou, Song Hua, Bingfeng Pi, Jun Sun, Yashihide Nomura, Kazuhiro Ya-
mashita, and Hidetoshi Kurihara. 2018. Security Assurance for Smart Contract.
In New Technologies, Mobility and Security (NTMS), 2018 9th IFIP International
Conference on. IEEE, 1–5.
APPENDIX
The appendix is structured as follows: In § A we overview the
analysis specification language HoRSt. In § B we make the theo-
retical foundations of our work explicit, in particular we give the
soundness proof of our analysis. § C gives details on how the se-
curity properties discussed in the paper are implemented in eThor
using HoRSt. Finally, in § D we discuss the soundness issues in
related works and give concrete counterexamples for highlighting
soundness flaws in existing static analyzers.
A HORST
This section gives an introduction to the newly developed language
HoRSt that allows for the high-level specification of Horn-clause
based static analyses. We will first give a short primer that illus-
trates the main functionality of HoRSt, followed by a more detailed
discussion of HoRSt’s language features.
A.1 HoRSt by Example
For illustrating the features of HoRSt we show how to express a
general rule for binary stack operations, subsuming the rule for
addition presented in § 3. Figure 13 shows an excerpt of the HoRSt-
specification of the presented static analysis. The abstract domain
of the analysis is realized by the definition of the abstract datatype
AbsDom. Predicate signatures can be specified by corresponding predi-
cate declarations as done for the case of the MState predicate. HoRSt
allows for parametrizing predicates and thereby specifying whole
predicate families: The MState predicate is parametrized by two in-
teger values (as specified in the curly braces) that will intuitively
correspond to the contract’s identifier and the program counter
whose state it is approximating. The arguments of the MState predi-
cate family reflect exactly those specified in § 3.
To facilitate modular specifications, HoRSt supports non-recursive
operations over arbitrary types, such as absadd which implements
abstract addition. In the given example, we show the flexibility of
HoRSt by presenting a single rule template for generating rules for
all binary stack operations. To this end, we define a function binOp
that given an opcode c and two integer arguments applies to them
the binary operation corresponding to the opcode. This function is
then leveraged in the rule template opBin. Rule templates serve for
generating the abstract semantics given in the form of Horn clauses.
As in our case the abstract semantics is specified as a function on a
concrete contract, the generation of horn clauses in HoRSt needs
to be linked to a concrete contract bytecode. In order to account
15
Accepted for ACM CCS, 2020
Clara Schneidewind, Ilya Grishchenko, Markus Scherer, and Matteo Maffei
1 datatype AbsDom := @T | @V ; // Abstract Domain
2 datatype Opcode := @STOP | @ADD | ... | @INVALID | @SELFDESTRUCT // opcodes ( shortened )
3
4 pred MState { int * int }: int * array  * array  * array  * bool ;
5
6 op absadd (a: AbsDom , b: AbsDom ): AbsDom := match (a , b) with | ( @V (x) , @V (y)) => @V (( x + y) mod MAX ) | _ => @T ;
7 op binOp (c: Opcode , x: AbsDom , y: AbsDom ): AbsDom := match c with | @ADD => absadd (x , y) | ... | _ => @T ;
8
9 sel ids : unit -> [ int ]; // contracts to be analyzed
10 sel binOps : unit -> [ int ]; // binary stack operations
11 sel pcsForIdAndOpcode : int * int -> [ int ]; // program counters at which a specific opcode occurs in a specific contract
12 sel argumentsTwoForIdAndPc : int * int -> [ int * int ]; // results from the preanalysis for a given contract and pc
13
14 op tryConcrete {! c: int }( val : AbsDom ): AbsDom := (! c = ~1) ? ( val ) : ( @V (! c));
15
16 rule opBin :=
17
18
19
20
21
22
23
24
25
MState {! id , ! pc }(? size , ?sa , ? mem , ? stor , ? cl ) , ? size > 1,
?x = tryConcrete {! a} ( select ? sa (? size -1) ) ,
?y = tryConcrete {! b} ( select ? sa (? size -2) )
=> MState {! id , ! pc +1}(? size -1, store ? sa (? size -2) ( binOp ( intToOpCode (!op) , ?x ,? y)) , ? mem , ? stor , ? cl );
(! id : int ) in ids () ,
(! pc : int ) in pcsForIdAndOpcode (! id , !op) ,
(! a: int , !b: int ) in argumentsTwoForIdAndPc (! id , ! pc )
clause [? x: AbsDom , ?y: AbsDom , ? size : int , ? sa : array , ? mem : array , ? stor : array , ? cl : bool ]
for (!op: int ) in binOps () ,
Figure 13: HoRSt rule describing the abstract semantics of local binary stack operations.
for that in a generic fashion given that HoRSt cannot support fa-
cilities for reading files or parsing bytecodes, HoRSt provides an
interface for interacting with custom relations generated by Java™
code. This interface is specified upfront by so called selector func-
tions (introduced with the key word sel) which are declared, but not
defined in the HoRSt specification. In the given example, we declare
selector functions for accessing the identifiers of the contracts to
be analyzed (ids), the set of binary operations (binOps) and for the
program counters in a contract that hold opcodes of a specific type
(pcForIdAndOpcode). In addition to that, selector functions also allow for
more advanced functionalities such as incorporating the results of
a pre-analysis in an elegant fashion: To this end, we declare the
selector function argumentsTwoForIdAndPc that returns arguments to the
operation that could be statically pre-computed (returning −1 in
case of failure). For generating Horn clauses, we can parametrize
the rule over the cross product of the result of (nested) selector
function applications as done in for the opBin rule. This then exactly
generates Horn clauses abstracting the behavior of a binary stack
operation as discussed in § 3: A stack size check is performed, the
two arguments are selected from the stack and finally the MState pred-
icate at the next program counter is implied with an updated stack
having the operation’s result as top element. The only derivation
occurs due to the consideration of the pre-analysis: the operation
tryConcrete tries to access the statically precomputed argument, and
only in case its absence performs the (more expensive) stack ac-
cess. This step however is not a necessity, but just illustrates how
the interplay between different stages of a static analysis can be
implemented for boosting the performance.
A.2 HoRSt in Detail
In the following, we present a short overview of the features of
HoRSt.
Types and Operations. For specifying the super domain D of
the abstraction, HoRSt provides in addition to the primitive types
Boolean and Integer, non-recursive sum types and arrays over
all types. The type of abstract values ˆD used in § 3 that consists of
the unknown value ⊤ and concrete integer values, can be defined
as follows:
1 datatype AbsDom = @T | @V ;
In addition, HoRSt allows us to define non-recursive operations
over arbitrary types. These operations are implemented as hygienic
macros on the expression level. To work with sum types, HoRSt
provides match expressions. This mechanism can, e.g., be used to
define the abstract addition operation described in § 3.2 as follows:
1 op absadd (a: AbsDom , b: AbsDom ): AbsDom :=
2
3
match (a , b) with
| ( @V (x) , @V (y)) => @V (x + y) // for two concrete values ,
return sum
4
| _
=> @T ;
// else return top
Predicates. The abstraction’s predicate signature S is given in
terms of predicate declarations. A predicate declaration introduces
a predicate symbol that ranges over arguments of arbitrary types.
HoRSt supports a mechanism for declaring a whole family of predi-
cates with the same argument types by allowing for the specification
of compile-time constants that we will from now on call parameters.
We illustrate the syntax of predicate declarations with the predicate
MStatepc defined in Figure 4 that models an abstract execution
state:
1 pred MState { int }: int * array  * array  * array 
* bool ;
The declared predicate has one parameter of type int and five ar-
guments. The parameter represents the program counter pc and
should be considered part of the predicate name. The distinction
between parameters and arguments is supported by HoRSt for per-
formance reasons: different parameter instantiations are compiled
to different predicate names in the underlying SMT representation
which leads to speed-ups in practice and additionally facilitates the
folding optimization discussed in § 4. Selector Functions. HoRSt
itself provides no facilities to read files, parse bytecode, etc. Instead,
these tasks are handled by Java™ code. HoRSt interacts with this
Java™ code by an upfront-specified interface which is implemented
16
eThor: Practical and Provably Sound Static Analysis
of Ethereum Smart Contracts
by so-called selector functions. The tasks performed by selector
functions can be as easy as providing an interval of integers or
as complicated as precomputing the results of certain bytecode
operations, from a HoRSt perspective we only see the interface
provided by selector function declarations that associate selector
function names with their type signature. Selector functions are
restricted to take a fixed number of arguments of primitive types
and to return a sequence of tuples of primitive types.
Examples of selector function declarations are given below:
1 sel interval : int -> [ int ]; // integers from 0 to (n -1)
2 sel pcsForOpcode : int -> [ int ]; // program counters for given
opcode
3 sel pcsAndValuesForOpcode : int -> [ int * int ]; // program
counters and precomputed values
In general, selector functions can be seen as the bridge between the
analysis specification and the parts of the software stack respon-
sible for preprocessing (parsing, etc.) real world smart contracts.
For instance, as previously discussed, the predicate signature Sc∗,
the abstraction function αc∗ as well as the abstract semantics δ(c∗)
are dependent on the concrete contract c∗ under analysis. Selec-
tor functions allow us to implement such a parametrization (e.g.,
iterating over opcode sequences in order to generate rules in δ(c∗)
according to the opcode at each program counter).
The separation of concerns introduced by selector functions
helps to keep the HoRSt specifications declarative while the tech-
nical details of providing the actual values can be tested by unit
tests.
Rules. The fundamental abstraction of HoRSt is the concept of rule,
which essentially describes a collection of Horn clauses. It therefore
can be seen as the mechanism for specifying the abstract semantics
δ(c∗). A rule is either a singleton rule that is just instantiated once
or may act as a template for arbitrarily many instantiations – hence
describing a family of rules. The second case is enabled by the use of
selector functions which provide the sequence that the rule family
ranges over. More technically, for each tuple returned by a selector
function the parameters of the rule template will be instantiated
according to the tuple values.