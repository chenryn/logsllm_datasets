果然在这里，可以看到首先会通过发送广播的intent中携带一些数据过来，主要是两个数据：
·进程id：作用主要是为了过滤其他应用，只处理本应用的逻辑，因为这个广播发送之后所有的应用都能接收到，但是脱壳时肯定只是针对于某一个应用，那么只需要在这个应用的广播接收中做处理即可。
·命令字符串：是为了发送广播可以支持多种功能，后面分析也可以看到的确有很多功能。
得到命令之后就开始构造一个执行器类，这里用到了设计模式中的命令模式。下面继续看看有哪几种命令执行器类，代码如下：
18.2 工具命令分析
下面就来逐一分析这个工具支持哪几种命令。
1.dump_dexinfo
获取应用运行时内存中dex的信息DumpDexInfoCommandHandler，代码如下：
进入方法详细查看一下：
可以看到，这里的实现逻辑是，全部通过反射机制获取每个应用的dex文件对应的DexFile类型对象，这里的工作和Android中插件化开发逻辑有点类似，通过应用的默认类加载PathClassLoader类得到DexPathList类，然后再得到具体的DexFile对象即可。
这里要说的就是这个dex文件对应的cookie值，这个值非常重要，是后续命令操作的基本信息，它代表的含义就是底层中每个应用的dex文件对应的唯一id值，系统会维护一个map结构来保存这些数据，然后通过这个cookie值找到对应的dex文件信息。
命令用法：
这里使用的是命令方式发送一个广播，通过--ei携带目标进程id是一个int类型，通过--es携带命令字符串。
2.dump_dexfile
这个命令也是后续脱壳的重要命令，就是dump出应用内存中的dex文件DumpDex-FileCommandHandler，代码如下：
这里可以看到dump出应用的内存数据，首先需要传入源应用的dex数据，也就是apk文件，这一般都是存放在/data/app/xxx.apk目录下的，然后构建了一个dump之后的dex文件路径，通过源码查看是在/data/data/xxx/files/dexdump.odex中。接下继续查看dump的核心代码：
看到这里有一个核心的方法，但是可惜的是这个方法是native的，而这个工具并没有把native层的代码公开，但是通过这里传递的参数可以了解到，底层应该是采用了libdvm.so或者是libart.so库得到具体的函数，然后通过dex对应的cookie值获取信息。
命令用法：
注意这里的dexpath参数代表需要脱壳的dex文件，也就是应用程序文件。
3.backsmali
这个命令与上面的命令功能差不多，只是这个命令多了一层操作，就是把dex文件转化成smali文件，所以这里不再详细说明了，可以先得到dex文件，然后通过工具得到smali文件。
命令用法：
注意这里的dexpath参数代表需要脱壳的dex文件，也就是应用程序文件。而最终生成的smali文件是放在/data/data/xxx/smali下面的。
4.dump_mem
这个命令是用来dump出应用程序运行时内存中指定开始位置和长度的内存块数据的DumpMemCommandHandler，代码如下所示：
可惜这个方法也是native层的，但是可以知道每个应用运行时的内存地址都在/proc/[pid]/maps文件中，如下所示：
那么查找内存地址，然后使用memcpy进行内存数据拷贝也是非常简单的。
命令用法：
注意这里的start和length都是十进制的，而不是十六进制的数据格式。
5.dump_heap
这个命令可以dump出虚拟机的堆内存信息，文件可以使用Java heap工具进行分析，而对于这个命令想一下应该也知道实现逻辑，也是在native层的，而且这个代码逻辑应该和上面的那个命令差不多。
命令用法：
6.dump_class
这个命令主要用于dump出dex文件中的类信息，因为在DexFile对象中有一个隐藏的方法可以把dex文件中的所有类名获取到getClassNameList，如下代码：
可以看到这个方法的传入参数为一个dex文件对应的cookie值。
命令用法：
这里的dexpath是需要得到所有类信息的dex文件路径，也就是应用的apk文件路径。
7.invoke
这个命令用于运行时动态调用Lua脚本，该功能可以通过Lua脚本动态调用Java代码。使用场景：可以动态调用解密函数，完成解密；可以动态触发特定逻辑。代码就不进行分析了，因为觉得这个命令很少使用。
命令用法：
这里的filepath是Lua脚本文件的存放路径。
18.3 工具日志信息
ZjDroid工具除了操作命令，还有两个非常重要的打印日志的tag：
·adb logcat-s zjdroid-shell-{package name}。这个tag可以查看上面每个命令执行的结果，便于查看命令执行的状态。
·adb logcat-s zjdroid-apimonitor-{package name}。这个tag可以监听对应包名应用调用的API信息，这个作用有点类似于运行时权限请求。可以直接通过Xposed提供的方法对一些敏感API进行拦截，然后添加监控代码即可。
18.4 工具用法总结
完全分析完ZjDroid工具的功能，下面就来总结一下：
1）获取apk当前加载dex文件信息：
2）获取指定dex文件包含可加载类名：
3）根据Dalvik相关内存指针动态反编译指定dex，并以文件形式保存：
4）dump指定dex内存中的数据并保存到文件（数据为odex格式，可在PC上反编译）：
5）dump指定内存空间区域数据到文件：
6）dump Dalvik堆栈信息到文件，文件可以通过Java heap分析工具分析处理：
7）运行时动态调用Lua脚本。该功能可以通过Lua脚本动态调用Java代码。使用场景：可以动态调用解密函数，完成解密。可以动态触发特定逻辑：
8）相关命令执行结果查看。命令执行结果：
敏感API调用监控输出结果：
18.5 工具使用案例
下面就要用一个案例来看看这个工具到底如何使用，有哪些功效。案例是捕鱼达人v1.0.1版本，具体的apk文件可以自行去网上搜索。安装游戏之后，然后顺便把上面的ZjDroid模块工具也安装上，之后进行重启生效。
最好是单独开一个CMD窗口用来查看打印结果，但是从上面的命令可以看到，应该需要这游戏的包名和进程id，那么这两个数据怎么获取呢？其实在前几章已经介绍很多次，用一个命令即可：adb shell dumpsys activity top。如下所示，但是这时候需要运行起来捕鱼达人游戏：
使用命令就可以获取到游戏的包名org.cocos2d.fishingjoy3和进程id=25304，这两个数据非常重要，这里可以先进行保管，进而后面使用。
下面首先来看一下这个应用用了哪些敏感的API数据，使用上面查看日志的命令即可：
运行结果如下所示：
这里有网络请求信息、网络切换的广播等数据，感觉这个工具的功能还是蛮多的。
下面再来看一下这个应用的dex文件信息，可以使用下面命令即可：
运行之后的结果如下所示：
这时候会发现，运行没有看到实际效果，原因是需要通过日志才能看到数据，因为上面命令运行的结果都是需要通过这个日志才可以看到的：
查看日志信息，结果如下所示：
这里可以看到具体的信息，看到有一个filepath，这就是后续有些命令需要用到的dex路径，所以一定要记下来。
接下来看一个关于dump出游戏中所有的类名的命令：
这里的路径就是上面获取到的apk路径，结果还需要通过上面的日志命令才可以看到，如下所示：
这就导出了游戏包含的所有类名了。
最后来看如何脱壳，这是最关键的，也是本章的重点，当然也是这个工具最实用的一个功能。而本章用的游戏也是经过加固处理的，可以反编译看看这个游戏，如图18-3所示。
图18-3 游戏加固图
会发现没几个类，而且有一个Application类，那么可以认定这个游戏被加固了，这里不介绍是使用哪家的加固平台操作了，也不再使用IDA等工具去动态调试脱壳了，这里直接使用这个工具进行操作即可。为了后续代码阅读方便，可以直接获取它的smali代码，使用这个命令：
这个命令的运行结果通过日志查看，如下所示：
而这个smali文件夹是存放在应用的/data/app/org.cocos2d.fishingjoy3/smali中，可以把它拷贝出来即可，如图18-4所示。
图18-4 dump出游戏之后的smali代码
可以看到成功脱壳了，生成了游戏的所有smali文件代码。这个脱壳操作和后面章节介绍使用IDA工具进行脱壳的原理都差不多，因为应用程序不管怎么加固，最终都会使用一个系统函数将dex文件加载到内存中，而加载之前肯定要进行解密操作，只要在加载之前解密之后进行拦截即可。
18.6 本章小结
本章介绍了基于Xposed框架的脱壳神器ZjDroid的实现原理以及具体用法，从而使读者感受到Xposed框架的强大之处。当然本章只讲了一部分功能，还可以利用这个框架编写游戏外挂等操作。可以慢慢地解读这个框架的源码，能够学习到很多知识点。
第19章 Native层Hook神器Cydia Substrate
前面介绍了Android中一款hook神器Xposed，本章介绍另外一个hook神器Cydia Substrate，当逆向游戏和应用的时候遇到so文件中的一个重要方法，这时候就想进行hook操作，但是Xposed几乎没法用，就需要使用这个框架了。这个框架的优点在于Hook底层函数非常方便，对so中的函数进行hook操作非常便捷。
19.1 环境搭建
先介绍这个框架如何安装使用，操作的环境如下：
·设备系统：小米三+原生CM 4.4系统
·框架版本：0.9.4010
·是否root：必须root
关于这个环境，可能有的同学操作最大的问题就在于设备和系统，用不同设备、不同系统，可能安装会失败，具体问题可能需要自己去解决了。关于框架apk和功能jar包下载地址可以去官网：http://www.cydiasubstrate.com。
19.2 Hook Java层功能
搭建好了环境，下面就直接操作了。首先来看看如何Hook Java层功能。
第一步：导入jar包
在Eclipse中新建一个Android工程，将下载好的框架的jar包拷贝到工程的libs目录下即可，如图19-1所示。
图19-1 导入jar包
第二步：编写Hook入口类
具体API不多介绍了，就那么几个，没必要详细讲。下面代码对系统的imei进行Hook操作了：
下面代码是对系统的颜色值进行了Hook：
第三步：配置XML信息
在AndroidManifest.xml中需要配置两个地方：一个是使用权限，一个是声明hook的入口类。
第四步：安装运行
代码编写完成之后，直接运行安装即可，前提是需要正确安装Cydia Substrate框架程序，安装成功界面如图19-2所示。
安装Hook项目时会出现提示，如图19-3所示。
点击按钮，进入框架界面，点击重启即可。然后查看系统界面颜色以及返回的imei值，如图19-4所示。
图19-2 安装成功
图19-3 提示安装Hook项目
图19-4 框架界面