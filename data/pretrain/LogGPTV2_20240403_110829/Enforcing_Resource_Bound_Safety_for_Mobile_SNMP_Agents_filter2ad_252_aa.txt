title:Enforcing Resource Bound Safety for Mobile SNMP Agents
author:Weijiang Yu and
Aloysius K. Mok
Enforcing Resource Bound Safety for Mobile SNMP Agents 
Weijiang Yu and Aloysius K. Mok
Department of Computer Sciences
University of Texas at Austin
Austin, Texas 78712, USA
fwjyu,PI:EMAIL
Abstract
The integration of mobile agents with SNMP creates sig-
niﬁcant advantages for the management of complex net-
works. Nevertheless, the security concerns of mobile agent
technology limit its acceptance in practice. A key issue is
to safeguard resource usage abuse by malicious or buggy
mobile agents on the hosting system. This paper describes
how the TINMAN architecture, a framework and a suite of
tools for enforcing resource safety of mobile code is ap-
plied to mobile SNMP agents. TINMAN uses a suite of
resource-usage checking tools which consists of a resource
bound predictor, a usage certiﬁcation generator and a veri-
ﬁer at compile-time, and certiﬁcate validation and monitor-
ing tools at run-time. This paper shows how TINMAN tools
can provide 100% coverage by a combination of off-line
static analysis and run-time monitoring in enforcing safety
on resource consumption of mobile SNMP agents. Exper-
imental results from the current TINMAN implementation
are given.
1 Introduction
The Simple Network Management Protocol (SNMP) is
the most widely adopted framework for network and sys-
tem management in service today. Many network devices
have been equipped with an SNMP agent gathering system
information. The centralized management architecture of
SNMP framework, however, has obvious drawbacks regard-
ing performance, ﬂexibility and scalability [17]. Moreover,
the lack of essential support for dynamic network manage-
ment makes it difﬁcult for SNMP to manage increasingly
heterogeneous networks.
To address these problems, recent research activities
have started to address the integration of mobile agents with
This work is supported in part by a grant from the US Ofﬁce of Naval
Research under grant number N00014-99-1-0402 and N00014-98-1-0704.
SNMP management [12, 14, 17]. The introduction of the
mobile agent technology has demonstrated its ﬂexibility and
effectiveness in SNMP management. For example, a mo-
bile agent may behave as a sub-agent of an AgentX (a built-
in SNMP protocol) to perform the corresponding network
management services. This way, the mobile agent frame-
work can decentralize and automate the SNMP manage-
ment on the desired network devices.
However, the mobile agent-based SNMP cannot be ac-
cepted with conﬁdence by hardware manufacturers and sys-
tem administrators unless an external mobile agent could
be trusted not to breach security policies. One of the se-
rious security concerns is resource bound safety: limits on
the consumption of system resources such as CPU cycles,
memory and network bandwidth by a mobile agent must
be observed. Failure to properly delimit resource consump-
tion by untrusted mobile agents may deny legitimate users
access to system resources, as is in the case of Denial of
Service (DoS) attacks.
Most mobile agent frameworks exploit traditional tech-
niques for authorization, authentication and access control
to local resources. These techniques, however, cannot pro-
tect the hosting systems from DoS attacks caused by the
execution of mobile agents, for example, by buggy or ma-
licious SNMP agents. Therefore, the availability of effec-
tive tools for checking, monitoring and enforcing resource
bound safety is an essential factor in the acceptance of a
mobile SNMP agent framework.
This paper describes an architecture called TINMAN
whose goal is to provide a set of tools to efﬁciently and ef-
fectively perform resource bound checks on mobile agents.
The goal of this paper is to demonstrate the effectiveness
of the TINMAN architecture in achieving resource usage
safety for a mobile agent-based SNMP framework.
The key idea of our approach is to endow a mobile
agent with formally veriﬁable certiﬁcates describing its re-
source consumption behavior. Ideally, the hosting system,
or a code recipient, validates the certiﬁcate, and, assuming
that the certiﬁcate passes validation, grants resources to the
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:29:18 UTC from IEEE Xplore.  Restrictions apply. 
code to complete its execution without any further run-time
checks. The difﬁculty with this approach is that the exact
resource usage is often determined dynamically and can-
not in general be derived by compile-time static analysis.
Our approach is a combination of off-line theorem prov-
ing and on-line monitoring. TINMAN performs resource
bound prediction off-line and outputs the veriﬁcation con-
ditions including any unproved assertions by the program-
mer that are automatically checked at run time. The code
recipient, in addition to certiﬁcate validation, automatically
performs run-time checking on the unproved assertions with
relatively small overhead. The off-line and run-time mech-
anisms together provide complete coverage and guarantee
resource safety. This mixed strategy applied to resource
safety distinguishes our approach from previous work.
A major contribution of our work is that we push the
limit of automating ﬁne-grain resource consumption checks
by the adoption of a set of tools for resource utilization pre-
diction, certiﬁcate generation and validation, and run-time
event monitoring.
An overview of the TINMAN architecture is presented in
the next section. Section 3 describes how to use TINMAN
tools to ascertain the resource consumption safety of mo-
bile SNMP agents. It includes a detailed description of re-
source prediction, certiﬁcate generation and validation and
on-line checks using an example SNMP agent. Experimen-
tal results are given in section 4. Section 5 discusses related
work. Concluding remarks and future work are in section
6.
2 Architecture Overview of TINMAN
In this section, we give a general overview of the TIN-
MAN architecture. The application of TINMAN to a con-
crete mobile agent-based SNMP will be demonstrated in the
next section.
The TINMAN system ensures the resource safety of mo-
bile codes by detecting potentially malicious mobile code
that may consume inordinate amounts of resources such as
CPU, memory and network bandwidth, as manifested in
DoS attacks. There are two key issues regarding resource
safety: resource safety policy and resource safety enforce-
ment. Resource safety policy spells out resource usage con-
straints that mobile agents must observe in order to maintain
permission to execute on a host. In TINMAN, the resource
safety policy is established by a set of speciﬁcations which
consists of three parts: resource usage for each service pro-
vided by the hosting system, resource limit for each active
session (i.e., execution of a mobile agent), and the interpre-
tation of the speciﬁcation by a proof system consisting of
axioms and inference rules. Resource safety enforcement
pertains to the authorization of resource usage and the lim-
itation of actual resource usage by a program. It prevents
a mobile agent from violating resource safety policy by on-
line monitoring and dynamic analysis.
TINMAN performs resource safety enforcement by cou-
pling language level and run-time system level mechanisms.
At the language level, a mobile agent is analyzed and con-
verted into a certiﬁed program, i.e., a program with a cer-
tiﬁcate on resource bounds. The certiﬁcate, once formally
validated, guarantees that the program will not violate a re-
source safety property.
In general, it is not possible to guarantee resource bound
by only checking the certiﬁcate without further run-time
checks since exact resource usage cannot in general be de-
rived a priori by compile-time static analysis, unless, say,
the halting problem is decidable, which it is not. Our ap-
proach is to combine off-line veriﬁcation and on-line check-
ing by the run-time system. It is akin to constructing a proof
on resource usage for every computation, where part of the
proof is done off-line and the unveriﬁed part is checked on-
line as the particular computation unfolds.
Figure 1 shows the architecture of the TINMAN system.
The following describes the typical steps taken to ensure
resource safety of a piece of mobile agent code by the func-
tions of the main components of TINMAN, as illustrated in
Figure 1.
(cid:15) Resource prediction. The resource bound of the code is
predicted off-line with user-input information, if nec-
essary. This is done interactively with a suite of com-
piler tools modiﬁed for the purpose while allowing the
programmer to enter assertions that can only be es-
tablished on-line (e.g., run-time environment-speciﬁc
parameters) or cannot be established automatically by
the tools. The output is a set of annotations and as-
sertions, called the resource skeleton which captures
the resource usage behavior of the code, to be checked
against the resource safety policy.
(cid:15) Resource speciﬁcation generation. The resource skele-
ton is automatically translated into a speciﬁcation con-
sisting of a group of predicates in a formal logic of a
proof system.
(cid:15) Certiﬁcate generation. The speciﬁcation is secured by
applying the resource safety policy, with the help of a
proof system [11]. The output is a proof of the resource
usage bounds of the resource skeleton, called the re-
source usage certiﬁcate. The code with resource skele-
ton and certiﬁcate are now ready to be downloaded by
a remote host.
(cid:15) Resource skeleton validation. A remote host (code re-
cipient) validates the resource skeleton that has been
inserted off-line, and checks for any inconsistency with
the imported code, and any violation against the safety
policy on resource usage.
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:29:18 UTC from IEEE Xplore.  Restrictions apply. 
Source Code
Resource Prediction
Resource Specification
Generation
Resource Skeleton Validation
User Bounds and 
Arguments Requests
Certificate Generation
Annotated Source Code
with Resource Skeleton
+
Resource Usage
Certificate
Off−line Checker
Resource
Safety
Policy
Proof System
Certificate Verification
Run−time Events Insertion
Translated Code with
Run−time Checking
On−line Checker
Figure 1. The Architecture of TINMAN for Resource Bound Safety for Mobile Code
(cid:15) Certiﬁcate veriﬁcation.
If no violation to resource
safety policy is detected, the resource usage certiﬁ-
cate is veriﬁed by a proof checker.
If it is found
to be valid, the code is safe to be installed and ex-
ecuted. We emphasize that the validation on-line is
done by proof-checking which is much more doable
than proof-generation that is done off-line.
(cid:15) Run-time events insertion. Assertions whose validity
the off-line analyzer fails to provide a proof are moni-
tored on-line. This is done by having the program an-
notations automatically converted into event generator
code that notiﬁes the run-time system on the progress
of the mobile code execution. The run-time resource
usage monitor matches the events generated at run time
with the behavior inferred from the resource skeleton.
Architecturally, the ﬁrst three steps are done on the code
producer site, grouped into an off-line checker, and the last
three steps are done by the code recipient, grouped into an
on-line checker. The resource prediction module requires
potentially the intervention of the programmer, and so does
the certiﬁcate generation module in case a certiﬁcate cannot
be automatically generated due to the overly complicated
program structure of the source code. The user of a host
where mobile code runs needs to manually conﬁgure the
policy rules on resource limits such as maximum running
time and memory usage of a mobile agent process. All other
modules are automatically done by TINMAN tools. In other
words, the programmer of the mobile agent code helps to
create the certiﬁcate for resource safety off-line since this
can be done by taking advantage of computational resources
that are usually more abundant off-line.
The guiding principle of TINMAN is to do as much work
off-line as possible and leave the hosting code recipient to
do as little as possible while ensuring complete coverage.
Accordingly, compliance with the resource security policy
by mobile agents is to be achieved by having the code pro-
ducer and the recipient cooperate in verifying what is pos-
sible off-line and monitoring on-line what has not been ver-
iﬁed off-line.
3 TINMAN Application: Mobile SNMP
Agents
The TINMAN architecture is a general framework for
securing the resource usage bounds of mobile code, and it
is applicable to a variety of applications and platforms. In
this section, we describe how the TINMAN tools are used to
enforce resource bound safety for untrusted and potentially
malicious mobile SNMP agents.
We use the open source NET-SNMP toolkit [5] as the
framework for writing mobile SNMP agents. NET-SNMP
(previously known as UCD-SNMP) is an implementation
of all three SNMP protocols (v1, v2c, v3) as well as
AgentX, which includes a master agent and libraries
to develop sub-agents.
In a NET-SNMP-based SNMP
management framework that supports mobile agents, a
mobile SNMP agent may behave as an AgentX sub-agent,
migrating between network nodes to acquire information
from or provide services to a local host.
Example: A Mobile SNMP Agent for Single Scalar
Registration. For clarity of explanation, we use a simple
agent that comes with the NET-SNMP package. The agent,
called “scalar agent” creates some scalar registrations at a
local host which allows some simple variables to be ac-
cessed via SNMP. The source code of the example is shown
in Figure 2. The main() code establishes the connection be-
tween the local host and the agent itself. It attaches itself
to the master agent using the AgentX protocol, initializes
agent library and MIB code, and falls into a while loop to
poll SNMP operations. The init scalar int() code is the im-
plementation of a user-deﬁned SNMP service. It registers
a variable “example1” as accessible and makes it writable.
When the scalar agent arrives at a node where it is sched-
uled to run, it performs the requests for manipulation on the
Proceedings of the 18th Annual Computer Security Applications Conference (ACSAC(cid:146)02) 
1063-9527/02 $17.00 ' 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:29:18 UTC from IEEE Xplore.  Restrictions apply. 
int  main (int argc, char **argv) {
B1:  snmp_enable_stderrlog();
        ds_set_boolean(DS_APPLICATION_ID,
                    DS_AGENT_ROLE, 1);
        init_agent("scalar");
U2:  init_scalar_int();
B3:  init_snmp("scalar");
       keep_running = 1;
       signal(SIGTERM, stop_server);
       signal(SIGINT, stop_server);
L4:  while(keep_running) {
       B5:   agent_check_and_process(1);
       }
B6:  snmp_shutdown("scalar");
        exit(0);
}
RETSIGTYPE stop_server(int a) {
    keep_running = 0;
}
void  init_scalar_int(void) {
B7:  int   example1 = 42;  /* default value */
      oid my_registration_oid[] =
        {1,3,6,1,4,1,8072,2,1,1,0};
      DEBUGMSGTL(("example_scalar_int",
         "Initalizing example scalar int.\
          Default value = %d\n",
          example1));
      netsnmp_register_int_instance(
         "my example int variable",
          my_registration_oid,
          OID_LENGTH(my_registration_oid),
          &example1, NULL);
     DEBUGMSGTL(("example_scalar_int",
       "Done initalizing scalar int\n"));
}
Figure 2. Source Code of Scalar SNMP Agent