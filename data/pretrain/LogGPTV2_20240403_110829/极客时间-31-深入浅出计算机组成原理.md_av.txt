## 读写数据所需要的译码器现在，我们的数据能够存储在 D 型触发器里了。如果我们把很多个 D型触发器放在一起，就可以形成一块很大的存储空间，甚至可以当成一块内存来用。像我现在手头这台电脑，有16G内存。那我们怎么才能知道，写入和读取的数据，是在这么大的内存的哪几个比特呢？于是，我们就需要有一个电路，来完成"寻址"的工作。这个"寻址"电路，就是我们接下来要讲的译码器。在现在实际使用的计算机里面，内存所使用的 DRAM，并不是通过上面的 D型触发器来实现的，而是使用了一种 CMOS芯片来实现的。不过，这并不影响我们从基础原理方面来理解译码器。在这里，我们还是可以把内存芯片，当成是很多个连在一起的D 型触发器来实现的。如果把"寻址"这件事情退化到最简单的情况，就是在两个地址中，去选择一个地址。这样的电路，我们叫作**2-1选择器**。我把它的电路实现画在了这里。我们通过一个反相器、两个与门和一个或门，就可以实现一个 2-1选择器。通过控制反相器的输入是 0 还是1，能够决定对应的输出信号，是和地址 A，还是地址 B 的输入信号一致。![](Images/7e37d9301a66c14d4c55f534e3b83896.png){savepage-src="https://static001.geekbang.org/resource/image/38/a0/383bfbb085c1eeb9b9473ae6f18e97a0.jpeg"}```{=html}```2-1 选择器电路示意图]{.reference}```{=html}```一个反向器只能有 0 和 1这样两个状态，所以我们只能从两个地址中选择一个。如果输入的信号有三个不同的开关，我们就能从]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[2]{#20.html#MathJax-Span-4.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.47em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[[3]{#20.html#MathJax-Span-5.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.52em;"}]{style="display: inline-block; position: relative; width: 0.944em; height: 0px;"}]{#20.html#MathJax-Span-3.msubsup}]{#20.html#MathJax-Span-2.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.32em, 1000.94em, 2.449em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 0.944em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.179em;"}]{#20.html#MathJax-Span-1.mathstyle="width: 1.179em; display: inline-block;"}``{=html}[$2^{3}$]{.MJX_Assistive_MathMLrole="presentation"}]{#20.html#MathJax-Element-1-Frame .MathJaxtabindex="0" style="position: relative;"mathml="23"role="presentation"}$$，也就是 8个地址中选择一个了。这样的电路，我们就叫**3-8译码器**。现代的计算机，如果 CPU 是 64 位的，就意味着我们的寻址空间也是]{.MathJax_Previewstyle="color: inherit; display: none;"}[``{=html}[[[[[2]{#20.html#MathJax-Span-9.mnstyle="font-family: MathJax_Main;"}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; clip: rect(3.202em, 1000.47em, 4.144em, -999.998em); top: -3.998em; left: 0em;"}[64]{#20.html#MathJax-Span-12.mnstyle="font-size: 70.7%; font-family: MathJax_Main;"}]{#20.html#MathJax-Span-11.mrow}]{#20.html#MathJax-Span-10.texatom}[]{style="display: inline-block; width: 0px; height: 4.002em;"}]{style="position: absolute; top: -4.374em; left: 0.52em;"}]{style="display: inline-block; position: relative; width: 1.273em; height: 0px;"}]{#20.html#MathJax-Span-8.msubsup}]{#20.html#MathJax-Span-7.mrow}[]{style="display: inline-block; width: 0px; height: 2.308em;"}]{style="position: absolute; clip: rect(1.273em, 1001.27em, 2.449em, -999.998em); top: -2.304em; left: 0em;"}]{style="display: inline-block; position: relative; width: 1.273em; height: 0px; font-size: 125%;"}[]{style="display: inline-block; overflow: hidden; vertical-align: -0.056em; border-left: 0px solid; width: 0px; height: 1.238em;"}]{#20.html#MathJax-Span-6.mathstyle="width: 1.602em; display: inline-block;"}``{=html}[$2^{64}$]{.MJX_Assistive_MathMLrole="presentation"}]{#20.html#MathJax-Element-2-Frame .MathJaxtabindex="0" style="position: relative;"mathml="264"role="presentation"}$$，那么我们就需要一个有 64 个开关的译码器。![](Images/b4ab439c543862db1a210590687a0852.png){savepage-src="https://static001.geekbang.org/resource/image/40/01/4002b5f8f60a913e655d5268348ee201.jpeg"}```{=html}```当我们把译码器和内存连到一起时，通常会组成这样一个电路]{.reference}```{=html}```所以说，其实译码器的本质，就是从输入的多个位的信号中，根据一定的开关和电路组合，选择出自己想要的信号。除了能够进行"寻址"之外，我们还可以把对应的需要运行的指令码，同样通过译码器，找出我们期望执行的指令，也就是在之前我们讲到过的opcode，以及后面对应的操作数或者寄存器地址。只是，这样的"译码器"，比起2-1 选择器和 3-8 译码器，要复杂的多。
## 建立数据通路，构造一个最简单的 CPUD 触发器、自动计数以及译码器，再加上一个我们之前说过的ALU，我们就凑齐了一个拼装一个 CPU必须要的零件了。下面，我们就来看一看，怎么把这些零件组合起来，才能实现指令执行和算术逻辑计算的CPU。![](Images/232e48a17fe6383dcc28b3a8faea8e45.png){savepage-src="https://static001.geekbang.org/resource/image/68/71/6863e10fc635791878d1ecd57618b871.jpeg"}```{=html}```CPU 实现的抽象逻辑图]{.reference}```{=html}```1.  首先，我们有一个自动计数器。这个自动计数器会随着时钟主频不断地自增，来作为我们的    PC 寄存器。2.  在这个自动计数器的后面，我们连上一个译码器。译码器还要同时连着我们通过大量的    D 触发器组成的内存。3.  自动计数器会随着时钟主频不断自增，从译码器当中，找到对应的计数器所表示的内存地址，然后读取出里面的    CPU 指令。4.  读取出来的 CPU 指令会通过我们的 CPU 时钟的控制，写入到一个由 D    触发器组成的寄存器，也就是指令寄存器当中。5.  在指令寄存器后面，我们可以再跟一个译码器。这个译码器不再是用来寻址的了，而是把我们拿到的指令，解析成    opcode 和对应的操作数。6.  当我们拿到对应的 opcode 和操作数，对应的输出线路就要连接    ALU，开始进行各种算术和逻辑运算。对应的计算结果，则会再写回到 D    触发器组成的寄存器或者内存当中。这样的一个完整的通路，也就完成了我们的 CPU的一条指令的执行过程。在这个过程中，你会发现这样几个有意思的问题。第一个，是我们之前在[第 6讲](https://time.geekbang.org/column/article/94075)讲过的程序跳转所使用的条件码寄存器。那时，讲计算机的指令执行的时候，我们说高级语言中的if...else，其实是变成了一条 cmp 指令和一条 jmp 指令。cmp指令是在进行对应的比较，比较的结果会更新到条件码寄存器当中。jmp指令则是根据条件码寄存器当中的标志位，来决定是否进行跳转以及跳转到什么地址。不知道你当时看到这个知识点的时候，有没有一些疑惑，为什么我们的 if...else会变成这样两条指令，而不是设计成一个复杂的电路，变成一条指令？到这里，我们就可以解释了。这样分成两个指令实现，完全匹配好了我们在电路层面，"译码 -执行 - 更新寄存器"这样的步骤。cmp 指令的执行结果放到了条件码寄存器里面，我们的条件跳转指令也是在 ALU层面执行的，而不是在控制器里面执行的。这样的实现方式在电路层面非常直观，我们不需要一个非常复杂的电路，就能实现if...else 的功能。第二个，是关于我们在[第](https://time.geekbang.org/column/article/98872)[17讲](https://time.geekbang.org/column/article/98872)里讲到的指令周期、CPU周期和时钟周期的差异。在上面的抽象的逻辑模型中，你很容易发现，我们执行一条指令，其实可以不放在一个时钟周期里面，可以直接拆分到多个时钟周期。我们可以在一个时钟周期里面，去自增 PC寄存器的值，也就是指令对应的内存地址。然后，我们要根据这个地址从 D触发器里面读取指令，这个还是可以在刚才那个时钟周期内。但是对应的指令写入到指令寄存器，我们可以放在一个新的时钟周期里面。指令译码给到ALU之后的计算结果，要写回到寄存器，又可以放到另一个新的时钟周期。所以，执行一条计算机指令，其实可以拆分到很多个时钟周期，而不是必须使用单指令周期处理器的设计。因为从内存里面读取指令时间很长，所以如果使用单指令周期处理器，就意味着我们的指令都要去等待一些慢速的操作。这些不同指令执行速度的差异，也正是计算机指令有指令周期、CPU周期和时钟周期之分的原因。因此，现代我们优化 CPU 的性能时，用的 CPU都不是单指令周期处理器，而是通过流水线、分支预测等技术，来实现在一个周期里同时执行多个指令。
## 总结延伸好了，今天我们讲完了，怎么通过连接不同功能的电路，实现出一个完整的 CPU。我们可以通过自动计数器的电路，来实现一个 PC寄存器，不断生成下一条要执行的计算机指令的内存地址。然后通过译码器，从内存里面读出对应的指令，写入到D触发器实现的指令寄存器中。再通过另外一个译码器，把它解析成我们需要执行的指令和操作数的地址。这些电路，组成了我们计算机五大组成部分里面的控制器。我们把 opcode 和对应的操作数，发送给 ALU进行计算，得到计算结果，再写回到寄存器以及内存里面来，这个就是我们计算机五大组成部分里面的运算器。我们的时钟信号，则提供了协调这样一条条指令的执行时间和先后顺序的机制。同样的，这也带来了一个挑战，那就是单指令周期处理器去执行一条指令的时间太长了。而这个挑战，也是我们接下来的几讲里要解答的问题。
## 推荐阅读《编码：隐匿在计算机软硬件背后的语言》的第 17章，用更多细节的流程来讲解了 CPU 的数据通路。《计算机组成与设计 硬件 /软件接口》的 4.1 到 4.4 小节，从另外一个层面和角度讲解了 CPU的数据通路的建立，推荐你阅读一下。
## 课后思考CPU 在执行无条件跳转的时候，不需要通过运算器以及ALU，可以直接在控制器里面完成，你能说说这是为什么吗？欢迎在留言区写下你的思考和疑惑，你也可以把今天的内容分享给你的朋友，和他一起学习和进步。![](Images/79d06107d349635530fbf82aa8dfb625.png){savepage-src="https://static001.geekbang.org/resource/image/28/29/281ca28b90c8aa0aecbb5adc08394f29.jpg"}
# 20 \| 面向流水线的指令设计（上）：一心多用的现代CPU前面我们用了三讲，用一个个的电路组合，制作出了一个完整功能的CPU。这里面一下子给你引入了三个"周期"的概念，分别是指令周期、机器周期（或者CPU 周期）以及时钟周期。你可能会有点摸不着头脑了，为什么小小一个CPU，有那么多的周期（Cycle）呢？我们在专栏一开始，不是把 CPU的性能定义得非常清楚了吗？我们说程序的性能，是由三个因素相乘来衡量的，我们还专门说过"指令数×CPI×时钟周期"这个公式。这里面和周期相关的只有一个时钟周期，也就是我们CPU 的主频倒数。当时讲的时候我们说，一个 CPU的时钟周期可以认为是可以完成一条最简单的计算机指令的时间。那么，为什么我们在构造 CPU的时候，一下子出来了那么多个周期呢？这一讲，我就来为你说道说道，带你更深入地看看现代CPU 是怎么一回事儿。