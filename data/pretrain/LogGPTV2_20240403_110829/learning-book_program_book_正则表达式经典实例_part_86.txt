标记语言和数据交换441
www.TopSage.com
---
## Page 458
段插人匹配注释的正则表达式中时，这是必需的），引擎就必须尝试所有可能的重复组
合，然后才能宣布匹配尝试失败，并继续执行。这种可选择的数量会随着引擎必须尝
试匹配的每个额外字符极端迅速地扩张。然而，如果这种情形能够避免的话，那么使
用嵌套量词也不会带来任何危险。例如，模式
正则选项：无
正则流派：.NET、Java、PCRE、Perl、Ruby
关于原子分组（以及和它相对的占有量词）的详细工作原理，请参考实例2.14。
查找C语言风格的注释
前面给出的XML风格的注释所使用的模式，同样可以用于其他种类的非嵌套的多行注
释。C语言风格的注释可以以*并始，以随后出现的第一个*/结束，或者以/作
为并始而以一行的结尾作为结束。下面的正则表达式可以匹配这两种注释类型，其中
使用一个竖线操作符来把两种类型的模式组合在了一起：
/\*[\s\S] *?\*/1//.*
正则选项：无（“点号匹配换行符”必须关闭）
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
参见
实例8.9会讲解如何在XML风格的注释中查找特定的单词。
8.9在XML风格的注释中查找单词
问题描述
你想要找到在(X)HTML或XML注释之内的出现的所有TODO单词。例如，你想要只
匹配到下面字符事中加下划线的文本：
Come up with a cooler comment for this example.-->
解决方案
这个问题至少有2种解决方案，二者都各有优点。第一种方法是后面要介绍的“两步
442第8章
www.TopSage.com
---
## Page 459
解决方案”，它会使用一个外层正则式查找注释，然后在每个匹配中使用另外一个正则
式或者甚至是使用纯文本搜索进行查找。如果你会撰写代码来完成这个任务，这样做
是最好的，因为把任务划分成2个步骤会把事情变得简单而且快速。然而，如果你要
使用一个文本编辑器或者grep工具来在多个文件中进行查找，那么把任务分解成两步
就不可以了，除非你所选择的工具提供了特殊选项，允许你从另外一个正则式找到的
匹配中进行查找。
当你需要使用单个正则式在注释中查找单词，那么可以通过环视的帮助来完成这个任
务。这第二种方法会在后面的“单步解决方案”小节中找到。
两步解决方案
如果情况允许，那么可以选择的较好解决方案是把这个任务分解为2个步骤：先查找
注释，然后再在注释中查找TODO。
下面是用来查找注释的方法：
正则选项：点号匹配换行符
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
JavaScript中没有“点号匹配换行符”的选项，但是你可以使用一个包含所有字符的字
符类来代替点号的位置，如下所示：
正则选项：无
正则流派：JavaScript
使用上面所给的一个正则式找到注释之后，你可以在匹配到的每一个注释中查找字面
的字符串（TODO>。如果愿意，还可以使用一个不区分大小写的正则式，并且在两端
添加单词边界，使之只能匹配到完整的TODO单词，如下所示：
\bTODO\b
正则选项：不区分大小写
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
实例3.13中展示了如何从一个外层正则式的匹配中进行查找。
单步解决方案
顺序环视（参考实例2.16中的讲解）允许使用单个正则式来解决这个问题，虽然这样
做的效率会有些低。在下面这个正则表达式中，使用了肯定型顺序环视来确保单词
TODO之后会跟着结束的注释分隔符号-->。如果只有它，并不能说明该单词是位于一
个注释内部，还是在它之后跟着一个注释，因此我们使用了一个否定型顺序环视来确
1本书第一章中“使用正则表达式的工具”小节中介绍过的PowerGREP工具就允许在匹配中进行
查找。
标记语言和数据交换443
www.TopSage.com
---
## Page 460
保在->之前不会出现起始注释分隔符号)
正则选项：不区分大小写、点号匹配换行符
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
个s\S]作为替代：
\bTODO\b(?=(?:(?!)
正则选项：不区分大小写
正则流派：JavaScript
讨论
两步解决方案
实例3.13中给出了在另外一个正则表达式的匹配中进行查找的代码。它需要一个内层
和一个外层正则表达式。查找注释的正则式会用作外层正则式，而bTODO\b>则会被
用作内层正则式。这里需要注意的一点是在注释正则式中的点号或者字符类之后的懒
情*?>量词。我们在实例2.13中解释过，它会允许你匹配之后的第-一个-->（也就是当
前注释的结束），而不是在目标字符串中的最后一个->。
单步解决方案
这个解决方案更为复杂，而且速度也较慢。它的优点是把前面解决方案中的2个步骤
结合成了一个正则表达式。因此，它可以被用在文本编辑器、IDE或者其他不允许在另
外一个正则式的匹配中进行查找的工具中。
下面我们给出了这个正则式在宽松排列模式下的分解形式，仔细看一下它的各个组成
部分：
\bTODO\b
匹配字符序列"TODO”，整字匹配
(?=
#判断下面的正则式可以在这里产生匹配
(?：
#
分组但是不捕获...
(？!
匹配字符序列”-->"
正则选项：点号匹配换行符、宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
这个包含注释的版本不能用于JavaScript，因为JavaScript中不支持“宽松排列”和“点
号匹配换行符”的模式。
注意这个正则式中包含了一个嵌套在一个外层的肯定型顺序环视之内的否定型顺序环
444第8章
www.TopSage.com
---
## Page 461
视。这样就允许你要求所匹配到的任何TODO之后都会跟着->，而且在二者之间不
会出现中带下划线的文本。我们需要在
顺序环视的开始使用.*?>，否则，这个正则式只能匹配其后紧跟着-->的单词TODO，
二者之间不能包含任何字符。量词*?）会重复点号0次或多次，但是会重复尽量少的
次数，这是因为我们只想匹配到第一个出现的->为止。
稍微离一下题，我们可以把到目前为止所得到的这个正则式重新写作
)\b>，把其中第2个（\b）移到循序环视之后，这样不会影响它将
匹配到的文本内容。这是因为两个单词边界和顺序环视都是长度为0的断言（参考
实例2.16中的“环视”小节）。然而，最好还是先使用单词边界，这样可以提高可
读性和效率。在一个部分匹配的中间，正则引擎可以更快地检查单词边界，宣布匹
配失败，然后继续在字符串中的下一个字符进行尝试，而不必在根本没有必要的情
况下（因为这样匹配到的TODO不是一个完整的单词）还要去花费时间检查顺序
环视。
现在我们继续刚才的讨论，正则式（\bTODO\b(?=.*?-->)）现在看来应该够用了，但是
式还是会匹配到TODO，因为它之后会跟着-->，然而这里的TODO并不位于一个注
释之间。因此，我们还需要把位于顺序环视之内的点号从可以匹配任意字符替换为可
以匹配不属于字符串)。在JavaScript中，因为不能使用“点号匹配换行符”
选项，它的等价形式是)》。
变体
标记语言和数据交换445
www.TopSage.com
---
## Page 462
"->，而且二者之间不会出现。之所以没有做这样的检查，是基于如
下的几个原因：
·通常可以不必进行这种双重检查也不会出现问题，特别是因为单步正则表达式的
本意是用在文本编辑器或类似工具中，从而你可以亲眼确认得到的结果；
进行更少的检查也就意味着在执行检查时会花费更少的时间（也就是说，略去额
外的检查会提高速度）；
最重要的是，由于你并不知道该注释的起始位置在前面多远的地方，因此这样的
向后看要求无限长度的逆序环视，而它只有在.NET中才能支持。
如果你用的得正好是.NET，而且想要添加这样的检查，那么就可以使用如下的正则表
达式：
（i）：）=）q\qoq\（+（·（=>）
正则选项：不区分大小写、点号匹配换行符
正则流派：.NET
这个只能用于.NET的更加严格的正则表达式在前面添加了一个肯定型逆序环视，它与
结尾处的顺序环视的工作原理一样，只不过它是反过来进行检查的。因为逆序环视会
从它找到的任意字符。
因为前导的顺序环视和结尾处的顺序环视都是长度为0的断言，所以最后匹配到
的仍然只是单词TODO。在环视中匹配到的字符事并不会被加入到最后匹配到的
文本中。
参见
实例8.8中包含关于如何匹配XML风格注释的详细讨论。
8.10替换在CSV文件中使用的分隔符
问题描述
你想要把在CSV文件中的所有的逗号域分隔符都替换为制表符。在双引号引起来的值
中的逗号应当保持不变。
解决方案
下面的正则表达式会匹配一个单独的CSV域，以及之前可能存在的分隔符。前面的分
隔符通常是一个逗号，但是如果匹配到的是第一个记录中的第一个域，那么也可以是
446第8章
www.TopSage.com
---
## Page 463
一个空字符串（也就是什么都没有），如果匹配到的是之后任意记录的第一个域，那么
也可以是一个换行符。每次找到一个匹配时，这个域本身，包括两边可能会用到的双
引号，会被一起捕获到第2个向后引用中，而它之前的分隔符则会被匹配到第1个向
后引用中。
提示
在本实例中的正则表达式只能用于合法的CSV文件，它们必须遵守在本
章前面讨论过的“适号分隔值（CSV）”小节中的格式规则。
（（1[]：）1+[u\x\]）（｜u\x\1)
正则选项：无（“点号匹配换行符”必须关掉）
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
下面给出了同一个正则表达式的宽松排列模式：
（，丨\r?\n1）#捕获分组#1匹配域分隔符或者字符串开始
（
捕获分组#2匹配一个单独的域，它可以是：
[,\r\n] +
一个没有被引起来的域
或者..
”(？：["]|"") *"
#一个引起来的域（可能会包含被转义的双引号）
）?
这个分组是可选的，因为域可以为空
正则选项：宽松排列（“^和S匹配换行处”选项必须关闭）