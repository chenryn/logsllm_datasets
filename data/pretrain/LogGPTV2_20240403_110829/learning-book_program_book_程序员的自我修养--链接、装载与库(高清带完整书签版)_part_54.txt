指针。
因此，如果你的程序出现了这样的错误，请着重检查指针的使用情况。
10.2栈与调用惯例
10.2.1什么是栈
栈（stack）是现代计算机程序里最为重要的概念之一，几乎每一个程序都使用了栈，
没有栈就没有函数，没有局部变量，也就没有我们如今能够看见的所有的计算机语言。在解
释为什么栈会如此重要之前，让我们来先了解一下传统的栈的定义：
在经典的计算机科学中，栈被定义为一个特殊的容器，用户可以将数据压入栈中（入栈，
push），也可以将已经压入栈中的数据弹出（出栈，pop），但栈这个客器必须遵守一条规则：
先入栈的数据后出栈（FirstInLastOut,FIFO），多多少少像叠成一叠的书（如图10-2所示）：
先叠上去的书在最下面，因此要最后才能取出。
在计算机系统中，栈则是一个具有以上属性的动态内存区城，程序可以将数据压入栈中，
也可以将数据从栈项弹出。压栈操作使得栈增大，而弹出操作使栈减小。
在经典的操作系统里，栈总是向下增长的。在i386下，栈顶由称为esp的寄存器进行
定位。压栈的操作使栈项的地址减小，弹出的操作使栈项地址增大。
程序员的自我修养一链接、装载与库
---
## Page 310
10.2栈与调用惯例
287
图10-2现实生活中的栈：叠起来的书
图10-3是-个栈的实例。
栈底·
Oxbiff
Oxbt
pop
Oxdt
esp e
Oxb4
push
图10-3程序栈实例
这里栈底的地址是0xbfr，而面esp 寄存器标明了栈项，地址为Oxbf4。在栈上压入
数据会导致esp减小，弹出数据使得esp增大。相反，直接减小esp的值也等效于在栈上开
辟空间，直接增大esp的值等效于在栈上回收空间。
栈在程序运行中具有举足轻重的地位。最重要的，栈保存了一个函数调用所需要的维护
信息，这常常被称为堆栈帧（StackFrame）或活动记录（Activate Record）。堆栈帧一般
包括如下几方面内容：
·函数的返回地址和参数。
临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。
保存的上下文：包括在函数调用前后需要保持不变的寄存器。
在i386中，一个函数的活动记录用ebp和esp这两个寄存器划定范围。esp 寄存器始终
指向栈的顶部，同时也就指向了当前函数的活动记录的项部。而相对的，cbp寄存器指向了
程序员的自我修养—链接、装载与库
---
## Page 311
288
第10章内存
函数活动记录的个固定位置，ebp寄存器又被称为帧指针（FramePointer）。一个很常见
的活动记录示例如图10-4所示。
参数
ebp·
返回地址
Oid EBP
保存的寄存器
活动记录
局部变量
其他数据
esp +
图10-4活动记录
不随这个函数的执行而变化，相反地，esp始终指向栈项，因此随着函数的执行，esp会不
断变化。周定不变的ebp可以用来定位函数活动记录中的各个数据，在ebp之前首先是这个
函数的返回地址，它的地址是ebp-4，再往前是压入栈中的参数，它们的地址分别是ebp-8、
ebp-12等，视参数数量和大小而定。cbp所直接指向的数据是调用该函数前ebp的值，这样
在函数返回的时候，cbp可以通过读取这个值恢复到调用前的值。之所以函数的活动记录会
形成这样的结构，是因为函数调用本身是如此书写的：一个i386下的函数总是这样调用的：
·把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存
器传递。
·把当前指令的下一条指令的地址压入栈中。
·跳转到函数体执行。
其中第2步和第3步由指令call一起执行。跳转到函数体之后即开始执行函数，而i386
函数体的“标准”开头是这样的（但也可以不一样）：
·push ebp：把ebp压入栈中（称为oldebp）。
·mov ebp,esp：ebp=esp（这时ebp 指向栈顶，而此时栈项就是old ebp）。
【可选】subesp,XXX：在栈上分配XXX字节的临时空间。
·【可选】pushXXX：如有必要，保存名为XXX寄存器（可重复多个）。
程序员的自我修养一链接、装载与库
---
## Page 312
10.2栈与调用惯例
289
把ebp压入栈中，是为了在函数返回的时候使于恢复以前的ebp值。而之所以可能要保
存一些寄存器，在于编译器可能要求某些寄存器在调用前后保持不变，那么函数就可以在调
用开始时将这些寄存器的值压入栈中，在结束后再取出。不难想象，在函数返回时，所进行
的“标准”结尾与“标准”开头正好相反：
·【可选】popXXX：如有必要，恢复保存过的寄存器（可重复多个）。
movesp,cbp：恢复ESP同时回收局部变量空间。
·popebp：从栈中恢复保存的ebp的值。
·ret：从栈中取得返回地址，并跳转到该位置。
提
GCC编译器有一个参数叫做-fomit-frame-pointer可以取消额指针，即不使用任何赖指
示
针，而是通过esp直接计算锁上变量的位置。这么做的好处是可以多出一个ebp寄存器
供使用，但是坏处却很多，比如帧上寻址速度会变慢，而且没有帧指针之后，无法准确
定位函数的调用轨迹（StackTrace。所以除非你很清楚你在做什么，否则请尽量不使用
这个参数。
为了加深印象，下面我们反汇编一个函数看看：
int foo ()
return 123;
这个函数反汇编（VC9,i386，Debug模式）得到的结果如图10-5所示（非粗体部分为
调试用的代码）。
我们可以看到头两行保存了旧的ebp，并让ebp指向当前的栈顶。接下来的一行指令
004113A3 sub
esp, 0C0h
将栈扩大了0xC0个字节，其中多出来的空间的值并不确定，这么一大段多出来的空间可以
存储局部变量、某些临时数据以及调试信息。在第3步里，函数将3个寄存器保存在了栈上。
这3个寄存器在函数随后的执行中可能被修改，所以要先保存一下这些寄存器原本的值，以
便在退出函数时恢复。第4步的代码用于调试。这段汇编大致等价于如下伪代码：
edi = ebp - 0x0C;
ecx = 0x30:
for (1 ecx 1= 0; --ecx, edi+=4)
*((int*)edi) = eax}
可以计算出，0x30*4=0xC0。所以实际上这段代码将内存地址从ebp-0xC0到ebp这
一段全部初始化为0xCC。恰好就是第2步在栈上分配出来的空间。
程序员的自我修养——链接、装载与库
---
## Page 313
290
第10章内存
保cbp
第1步
004113A0push
itobp指向目前的栈项
004113A1mov
ebp
ebpesp
第2步
004113A3sub
espoCoh
在栈上开赔一块空间
004113A9push
004113AA push
ebx
esi
第3步
004113ABpush
ed!
保存ebx、esi
ed存器
004113AClea
edi{ebp-0Coh)
004113B2 mov
ecx30h
第4步
004113B7 mov
加入调试信息
004113BCrepstos
dword ptr es[edi]
004113BEmov
eax,7Bh
返图123（0x7B)
第5步
004113C3pop
在这里返回值是通过
004113C4pop
edi
ex寄存器传递的
004113C5pop
esl
ebx
004113C6mov
espebp
第步
004113C8pop
ebp
esi、ebx资存提
从栈上恢复
004113C9 ret
恢复进入函数前的
第7步
第8步
esplDebp
使用ret指令返国
图10-5fo0函数汇编代码分析
【小知识】
我们在VC下调试程序的时候，常常看到一些没有初始化的变量或内存区域的值是
“烫”，例如下列代码：
int main()
char p[12];
此代码中的数组p没有初始化，当我们在Debug模式下送行这个程序，在main中设下
断点并监视（watch）数组p时，就能看见如图10-6的情形。
程序员的自我修养一链接、装载与库
---
## Page 314
10.2栈与调用惯例
291
kutor
图10-6未初始化的局部变量
之所以会出现“烫”这么一个奇怪的字，就是因为Debug模式在第4步里，将所有的
分配出来的栈空间的每一个字节都初始化为0xCC.0xCCCC（即两个连续排列的OxCC）的
汉字编码就是资，所以0xCCCC如果被当作文本就是“烫”。
将未初始化数据设置为0xCC的理由是这样可以有助于判断一个变量是否没有初始化.
如果一个指针变量的值是OxCCCCCCCC，那么我们就可以基本相信这个指针没有经过初始
化，当然这个信息仅供参考，编译器检查未初始化变量的方法并不能以此为证据，有时编译
器还会使用0xCDCDCDCD作为未初始化标记，此时我们就会看到汉字“屯屯”。
在第5步，函数格0x7B（即123）赋值给cax，作为返回值传出。在函数返回之后，调
用方可以通过读取cax寄存器来获取返回值。接下来的儿步是函数的资源清理阶段，从栈中
恢复保存的寄存器、ebp等。最后使用ret指令从函数返回。
以上介绍的是i386标准函数进入和退出指令序列，它们基本的形式为：
push ebp
*dqa Aou
sub esp,
esp
[push reg1]
[push regn]
函数实际内容
[pop regn]
[popreg1]
pop ebp
mov e8p, ebp
ret
其中x为栈上开辟出来的临时空间的字节数，reg1.regn分别代表需要保存的n个寄存器。
方括号部分为可选项。不过在有些场合下，编译器生成函数的进入和退出指令序列时并不按
照标准的方式进行。例如一个满足如下要求的C函数：
函数被声明为static（不可在此编译单元之外访问）。
函数在本编译单元仅被直接调用，没有显示或隐式取地址（即没有任何函数指针指向
过这个函数）
编译器可以确信满足这两条的函数不会在其他编译单元内被调用，因此可以随意地修改
程序员的自我修养一键接、装载与库
---
## Page 315
292
第10章内存
这个函数的各个方面—包括进入和退出指令序列—来达到优化的目的。
【小知识】HotPatchPrologue
在Windows的函数里，有些函数尽管使用了标准的进入指令序列，但在这些指今之前
却插入了一些特珠的内容：
mov edi, edi
我们知道这条指令没有任何用处，事实上也确实如此，这条指令在汇编之后会成为一个
占用2个字节的机器码，纯粹作为占位符而存在，使用这条指令开头的品数整体上看起来是
这样的：
nop
nop
nop
nop
nop
FUNCTION:
：品数的实际入口
mov edi, edi
：2字节的占位符
push ebp