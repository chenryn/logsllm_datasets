# CVE-2020-1317：Windows组策略中的漏洞
|
##### 译文声明
本文是翻译文章，文章原作者 Eran Shimony，文章来源：cyberark.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 绪论
本文是一个为期一年的研究项目的一部分，该项目发现了各大供应商的60个不同漏洞。本文讨论Windows组策略对象（GPO）机制中的一个漏洞。此漏洞专门针对策略更新步骤，允许域环境中的标准用户执行文件系统攻击，进而允许攻击者躲过反病毒软件，绕过安全加固措施，并可能导致公司组织网络中的严重损失。此漏洞影响所有运行Windows的计算机（Windows
2008及以上），并可提升其在域环境中的权限。
如果您对本研究的其他发现感兴趣，请回顾[第1部分](https://www.cyberark.com/threat-research-blog/follow-the-link-exploiting-symbolic-links-with-ease/)和[第2部分](https://www.cyberark.com/threat-research-blog/lazy-privilege-escalation-abusing-dells-dup-framework-cve-2019-3726/)。
###  概述
GPSVC将所有加入域的Windows计算机暴露于提权漏洞。运行gpudate.exe就可以通过文件操纵攻击提升为特权用户。
Windows的组策略机制已经存在很久了。它被认为是在域环境中分发设置的相对安全的方法，不管是打印机设置、备份设备设置，还是其他什么设置。因此，组策略需要与许多组件交互。许多交互就意味着存在许多潜在的漏洞，这就是我们要讲的。
###  示意图
## 0x01 分析
组策略或GPO对象最早是在Windows
2000开始使用的。距今已经有一段时间了，他们有点改变了，但基本上还是一样的。GPO被管理员用于在受管理的环境中强制执行其策略，功能非常强大。管理员可以用GPO做任何他们想做的事情，从禁用Windows
Defender和防火墙到安装软件和打印机。
在Windows中，每个用户都有一组本地组策略，可以由本地管理员修改，这允许他们为本地计算机设置规则。在加入域环境的计算机上，域管理员突发奇想应用于你的计算机的GPO常常会导致你的电脑出问题。
遵循最小特权原则是众所周知的安全最佳实践，这个原则将用户的特权级别限制在最低限度。对于组策略来说，也就是不允许域用户成为本地管理员组的一部分，因为本地管理员可以改变域管理员应用的任何组策略，使GPO无法在企业网络上有效地强制执行设置。
有趣的是，本地非特权用户可以手动请求组策略更新。因此，如果在组策略更新进程中发现bug，你可以随时自己触发这个bug，这就使潜在的攻击更容易了。不必等待约90分钟（在时间差为30分钟的域环境上推送组策略更新的默认时间段），管理员可以立即强制更新。
我们感兴趣的是本地组策略服务，其名为gpsvc。此服务需要特权才能执行其功能，因此它在NT
AUTHORITYSYSTEM的上下文中运行。这点很重要，因为如果我们能找到它执行的不安全文件操作，我们也许就可以使用文件操纵攻击将操作重解析到另一个文件。
毫无意外，gpsvc托管在Svchost.exe里，并且主要在C:WindowsSystem32gpsvc.dll中实现。这个DLL有一个RPC接口，我用James
Forshaw创建的这个好[工具](https://github.com/tyranid/WindowsRpcClients)将其反编译成C。其中，有几个有趣的方法可以由本地用户调用。
    uint Server_ProcessRefresh(string p0, sbyte p1, sbyte p2, sbyte p3, int p4, out Struct_0 p5)
    uint Server_RegisterForNotification(string p0, int p1, int p2, out int p3)
    uint Server_CheckRegisterForNotification(string p0, int p1)
    uint Server_LockPolicySection(string p0, int p1, int p2, out NtApiDotNet.Ndr.Marshal.NdrContextHandle p3)
    uint Server_UnLockPolicySection(ref NtApiDotNet.Ndr.Marshal.NdrContextHandle p0) uint Server_GetGroupPolicyObjectList(string p0, string p1, string p2, int p3, out Struct_2[] p4, out int p5)
    uint Server_GetAppliedGroupPolicyObjectList(int p0, string p1, string p2, string p3, out Struct_2[] p4, out int p5)
    uint Server_GenerateGroupPolicyNotification(int p0, string p1, int p2)
为了知道运行gpupdate命令的时候调用了gpsvc里的哪个方法，我打开了windbg，在所有暴露出的RPC例程上下断点，输入命令：
    bm gpsvc!Server_*
结果显示第一个函数是对我们有用的，即Server_ProcessRefresh()，它会启动更新过程。不过，在继续之前，请注意客户端通过RPC请求服务端服务的这个行为是导致许多bug的根源。倒霉的是，Windows不同组件间正是用RPC通信的，没有了RPC，Widows就无法正常运作了。（可以试试杀掉DCOM服务，体验下Windows怎样给你点蓝色看看）
Server_ProcessRefresh()从域控制器请求GPO对象，接收到结果后，就对每个组策略调用ProcessGPOList()。
这个方法反编译后超过600行代码，其中还使用了COM对象。如果我洋洋洒洒写下关于gpsvc.dll中COM对象的十页长篇大论，就没人爱看这篇文章了，所以我就对细节一笔带过，主要说重要部分。
看下方法的签名，就可以猜出它的功能：
    ProcessGPOList(
    struct _GPEXT *a1,
     struct _GPOINFO *a2,
     struct _GROUP_POLICY_OBJECTW *a3,
     struct _GROUP_POLICY_OBJECTW *a4, int a5,
     unsigned __int64 a6,
     struct CGPExtensionExecutionState *a7,
     int *a8
不是所有参数都有正式文档记载，叫人一如既往地失望。不过，`_GROUP_POLICY_OBJECTW`是有文档的，程序员可以在C++里创建这个对象：
    typedef struct _GROUP_POLICY_OBJECTW {
    DWORD dwOptions;
    DWORD dwVersion;
    LPWSTR lpDSPath;
    LPWSTR lpFileSysPath;
    LPWSTR lpDisplayName;
    WCHAR szGPOName[50];
    GPO_LINK GPOLink;
    LPARAM lParam;
    struct _GROUP_POLICY_OBJECTW *pNext;
    struct _GROUP_POLICY_OBJECTW *pPrev;
    LPWSTR lpExtensions;
    LPARAM lParam2;
    LPWSTR lpLink;
    } GROUP_POLICY_OBJECTW,*PGROUP_POLICY_OBJECTW;
可见_GROUP_POLICY_OBJECTW是个链表结构，有许多成员。其中两个成员*pPrev和*PNext是指向_GROUP_POLICY_OBJECTW的指针，这样就可以轻松遍历链表。本地服务会遍历该链表，根据对象中包含的是否为同类型的GPO对象决定是否要循着指针继续向下走。因此，对每个组策略都会调用ProcessGPOList()。
再看看GPOLink和szGPOName。参数GPOLink可以设置为五种值（复制自MSDN：[https://docs.microsoft.com/en-us/windows/win32/api/userenv/ns-userenv-group_policy_objectw）：](https://docs.microsoft.com/en-us/windows/win32/api/userenv/ns-userenv-group_policy_objectw%EF%BC%89%EF%BC%9A)
  * GPLinkUnknown – 没有关联信息。
  * GPLinkMachine – 该GPO关联到一台计算机（本地或远程的）。
  * GPLinkSite – 该GPO关联到一个站（site）。
  * GPLinkDomain – 该GPO关联到一个域。
  * GPLinkOrganizationalUnit – 该GPO关联到一个组织单位。
其实，这个参数的值决定着本地服务会把组策略写到哪里。如果你把GPO关联到一台计算机，那么会写到C:ProgramDataMicrosoftGroup
PolicyHistory{GUID}MachinePrefererncesApplied-ObjectApplied-Object.xml。
但是，如果GPOLink的值为GPLinkOrganizationalUnit，那么策略应用于域中 **所有**
用户和计算机，GPSVC会把策略复制到本地用户 **可访问**
的路径下。对此，Windows用了%localappdata%环境变量：C:UserseranAppDataLocalMicrosoftGroup
PolicyHistory{szGPOName}USER-SIDPreferencesApplied-ObjectApplied-Object.xml。其中Applied-ObjectApplied-Object.xml会替换为策略所应用的对象。比如，对打印机的策略会替换为
PrintersPrinters.xml。
我之前提过gpsvc以NT
AUTHORITYSYSTEM身份进行所有文件操作吗？这就表示如果服务没有模拟本地用户的话（也确实没有模拟），就可以通过符号链接攻击来利用目录的ACL。试图进行文件操纵攻击时，我们先要检查特权组件是否使用了模拟本地用户的API，例如：
  * RpcImpersonateClient
  * ImpersonateLoggedOnUser
  * CoImpersonateClient
大概有12次对这些API的调用，不包含对SetTokenInformation的调用。看来开发者还是懂得模拟用户的重要性的。但是，所有的代码路径都要正确进行模拟，这就麻烦了。在本漏洞中，问题之处位于模块gpprefcl.dll，这个DLL把载入到ProcessGPOList函数的那些组策略写入磁盘。
看看gpprefcl.dll的导出表就可以得到关于其作用的线索（节选）：
      7     4 0002E450 GenerateGroupPolicyApplications
      8     5 0002EE10 GenerateGroupPolicyDataSources
      9     6 0002F080 GenerateGroupPolicyDevices
      10    7 0002D820 GenerateGroupPolicyDrives
      11    8 0002D5B0 GenerateGroupPolicyEnviron
      12    9 0002DD00 GenerateGroupPolicyFiles
      13    A 0002F2F0 GenerateGroupPolicyFolderOptions