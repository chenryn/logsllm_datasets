# CVE-2020-1317：Windows组策略中的漏洞

#### 译文声明
本文为翻译文章，原作者为Eran Shimony，原文发表于cyberark.com。译文仅供参考，具体内容和含义以原文为准。

## 0x00 绪论
本研究项目为期一年，共发现了来自各大供应商的60个不同漏洞。本文将重点讨论Windows组策略对象（GPO）机制中的一个特定漏洞。该漏洞针对策略更新步骤，允许域环境中的标准用户执行文件系统攻击，从而绕过反病毒软件和安全加固措施，可能导致公司组织网络遭受严重损失。此漏洞影响所有运行Windows 2008及以上版本的计算机，并可能提升攻击者在域环境中的权限。

如需了解本研究项目的其他发现，请参阅[第1部分](https://www.cyberark.com/threat-research-blog/follow-the-link-exploiting-symbolic-links-with-ease/)和[第2部分](https://www.cyberark.com/threat-research-blog/lazy-privilege-escalation-abusing-dells-dup-framework-cve-2019-3726/)。

### 概述
GPSVC服务使所有加入域的Windows计算机暴露于提权漏洞。通过运行gpudate.exe并进行文件操作攻击，标准用户可以提升至特权用户。

Windows的组策略机制历史悠久，被认为是分发设置的一种相对安全的方法，无论是打印机设置、备份设备设置还是其他配置。然而，由于组策略需要与多个组件交互，这增加了潜在的漏洞风险。本文将探讨其中的一个漏洞。

### 示意图
（此处可插入相关示意图）

## 0x01 分析
组策略或GPO对象最早出现在Windows 2000中。尽管经过了一些变化，但其基本功能保持不变。GPO被管理员用于在受管理环境中强制执行各种策略，从禁用Windows Defender和防火墙到安装软件和打印机等。

在Windows中，每个用户都有一组本地组策略，这些策略可以由本地管理员修改，以便为本地计算机设置规则。在域环境中，域管理员应用的GPO可能会导致用户的计算机出现问题。遵循最小特权原则是一种广泛认可的安全最佳实践，这意味着不应让域用户成为本地管理员组的一部分，因为本地管理员可以更改任何组策略，从而使GPO无法在企业网络上有效执行。

有趣的是，本地非特权用户可以手动请求组策略更新。因此，如果在组策略更新过程中存在漏洞，用户可以随时触发该漏洞，从而更容易发起潜在的攻击。无需等待约90分钟（这是默认的组策略更新时间间隔），管理员可以立即强制更新。

我们关注的是名为gpsvc的本地组策略服务。此服务需要特权才能执行其功能，因此它在NT AUTHORITY\SYSTEM上下文中运行。如果我们能找到它执行的不安全文件操作，就可以利用文件操作攻击将其重定向到另一个文件。

不出所料，gpsvc托管在Svchost.exe中，并主要实现在C:\Windows\System32\gpsvc.dll中。这个DLL有一个RPC接口，我使用James Forshaw创建的工具将其反编译成C代码。其中有几个方法可以由本地用户调用：

```c
uint Server_ProcessRefresh(string p0, sbyte p1, sbyte p2, sbyte p3, int p4, out Struct_0 p5)
uint Server_RegisterForNotification(string p0, int p1, int p2, out int p3)
uint Server_CheckRegisterForNotification(string p0, int p1)
uint Server_LockPolicySection(string p0, int p1, int p2, out NtApiDotNet.Ndr.Marshal.NdrContextHandle p3)
uint Server_UnLockPolicySection(ref NtApiDotNet.Ndr.Marshal.NdrContextHandle p0) 
uint Server_GetGroupPolicyObjectList(string p0, string p1, string p2, int p3, out Struct_2[] p4, out int p5)
uint Server_GetAppliedGroupPolicyObjectList(int p0, string p1, string p2, string p3, out Struct_2[] p4, out int p5)
uint Server_GenerateGroupPolicyNotification(int p0, string p1, int p2)
```

为了确定运行`gpupdate`命令时调用了哪个方法，我在Windbg中对所有暴露的RPC例程设置了断点，并输入了以下命令：

```shell
bm gpsvc!Server_*
```

结果显示，第一个有用的方法是`Server_ProcessRefresh()`，它启动了更新过程。需要注意的是，客户端通过RPC请求服务端的服务是许多漏洞的根源。不幸的是，Windows的不同组件之间正是通过RPC进行通信的，没有RPC，Windows就无法正常工作。（尝试终止DCOM服务，看看Windows会如何崩溃）

`Server_ProcessRefresh()`从域控制器请求GPO对象，接收到结果后，对每个组策略调用`ProcessGPOList()`。这个方法反编译后的代码超过600行，涉及COM对象。为了避免冗长，我将简要介绍关键部分。

查看方法签名，可以推测其功能：

```c
ProcessGPOList(
    struct _GPEXT *a1,
    struct _GPOINFO *a2,
    struct _GROUP_POLICY_OBJECTW *a3,
    struct _GROUP_POLICY_OBJECTW *a4, 
    int a5,
    unsigned __int64 a6,
    struct CGPExtensionExecutionState *a7,
    int *a8
)
```

虽然不是所有参数都有正式文档记录，但`_GROUP_POLICY_OBJECTW`结构是有文档的。程序员可以在C++中创建这个对象：

```c
typedef struct _GROUP_POLICY_OBJECTW {
    DWORD dwOptions;
    DWORD dwVersion;
    LPWSTR lpDSPath;
    LPWSTR lpFileSysPath;
    LPWSTR lpDisplayName;
    WCHAR szGPOName[50];
    GPO_LINK GPOLink;
    LPARAM lParam;
    struct _GROUP_POLICY_OBJECTW *pNext;
    struct _GROUP_POLICY_OBJECTW *pPrev;
    LPWSTR lpExtensions;
    LPARAM lParam2;
    LPWSTR lpLink;
} GROUP_POLICY_OBJECTW, *PGROUP_POLICY_OBJECTW;
```

可见，`_GROUP_POLICY_OBJECTW`是一个链表结构，包含多个成员。其中两个成员`*pNext`和`*pPrev`是指向`_GROUP_POLICY_OBJECTW`的指针，便于遍历链表。本地服务会遍历该链表，并根据对象是否为同类型的GPO决定是否继续遍历。因此，对于每个组策略都会调用`ProcessGPOList()`。

再来看`GPOLink`和`szGPOName`。`GPOLink`参数可以设置为五种值（参考MSDN文档：[https://docs.microsoft.com/en-us/windows/win32/api/userenv/ns-userenv-group_policy_objectw]）：

- `GPLinkUnknown` – 没有关联信息。
- `GPLinkMachine` – 该GPO关联到一台计算机（本地或远程的）。
- `GPLinkSite` – 该GPO关联到一个站点。
- `GPLinkDomain` – 该GPO关联到一个域。
- `GPLinkOrganizationalUnit` – 该GPO关联到一个组织单位。

实际上，这个参数的值决定了本地服务将组策略写入的位置。如果GPO关联到一台计算机，策略将写入`C:\ProgramData\Microsoft\Group Policy\History\{GUID}\Machine\Preferences\Applied-Object.xml`。

但如果`GPOLink`的值为`GPLinkOrganizationalUnit`，策略将应用于域中的所有用户和计算机，并复制到本地用户可访问的路径下。Windows使用`%localappdata%`环境变量，路径为`C:\Users\eran\AppData\Local\Microsoft\Group Policy\History\{szGPOName}\USER-SID\Preferences\Applied-Object.xml`。其中`Applied-Object.xml`会被替换为策略所应用的对象。例如，打印机策略将替换为`Printers.xml`。

我之前提到过，gpsvc以NT AUTHORITY\SYSTEM身份进行所有文件操作吗？这意味着如果服务没有模拟本地用户（确实没有），可以通过符号链接攻击来利用目录的ACL。在尝试文件操作攻击时，我们需要检查特权组件是否使用了模拟本地用户的API，例如：

- `RpcImpersonateClient`
- `ImpersonateLoggedOnUser`
- `CoImpersonateClient`

大约有12次对这些API的调用，不包括对`SetTokenInformation`的调用。开发者显然知道模拟用户的重要性，但所有代码路径都必须正确模拟，这就变得复杂了。在这个漏洞中，问题出在`gpprefcl.dll`模块中，该模块负责将加载到`ProcessGPOList`函数中的组策略写入磁盘。

查看`gpprefcl.dll`的导出表可以提供一些关于其功能的线索（节选）：

```plaintext
      7     4 0002E450 GenerateGroupPolicyApplications
      8     5 0002EE10 GenerateGroupPolicyDataSources
      9     6 0002F080 GenerateGroupPolicyDevices
      10    7 0002D820 GenerateGroupPolicyDrives
      11    8 0002D5B0 GenerateGroupPolicyEnviron
      12    9 0002DD00 GenerateGroupPolicyFiles
      13    A 0002F2F0 GenerateGroupPolicyFolderOptions
```

通过这些分析，我们可以更好地理解漏洞的来源及其潜在的风险。