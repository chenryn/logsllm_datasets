# 优化后的文本

## 1. 引言

在本节中，我们将讨论符号计算树和具体攻击者之间的关系。首先，我们定义了过程计算树，并通过观察等价性引出了相应的过程计算树之间的等价性。

### 1.1 过程计算树的定义

过程计算树是一种计算树。观察等价性使得对应的过程计算树之间具有等价性：

**引理 7**：设 \( P \) 和 \( Q \) 是两个简单过程。如果 \( P \sim_o Q \)，则 \( T_P \sim T_Q \)。

这并不直接从 [2] 得出（参见 [20] 中的证明）。

## 2. 调度计算树

当具体攻击者的所有行为都是符号攻击者行为的实例时，可以将具体攻击者视为调度符号攻击者行为的机器。这就是我们试图在这里捕捉的内容。

假设给定一个安全参数 \( \eta \) 和一个从名称到实际位串的映射 \( \tau \)，存在一个解析函数 \( \kappa_\tau^\eta \)，该函数将位串映射为其符号表示。这个解析函数是全函数，可能使用适当长度的常量或新名称。

对于任何符号计算树 \( T \) 和随机磁带 \( \tau \)，令 \( O_{T, \tau} \) 为一个依赖于树 \( T \) 和样本 \( \tau \) 的预言机。当 \( T \) 是一个过程计算树时，预言机可以简单地理解为模拟网络并响应攻击者的消息。这对于直观理解 \( O_{T, \tau} \) 很方便，但我们会稍后转换树 \( T \)。因此我们需要一个通用的定义。

直觉上，树指定了如何自适应地查询预言机及其答案。形式化如下：

- 当被依次查询 \( m_1, \ldots, m_{n-1} \) 后再查询 \( m_n \) 时，
  - 预言机首先计算 \( \kappa_\tau^\eta(m_n) \)。设 \( r_j = \kappa_\tau^\eta(m_j) \) 对于 \( 1 \leq j \leq n \)。
  - 如果 \( r_1 \cdots r_n \) 不是 \( T \) 中的位置，则预言机返回 0。
  - 否则，设 \( \varphi_1 = \nu n_1 \sigma_1 = \varphi(T, r_1 \cdots r_{n-1}) \)，\( \varphi_2 = \nu n_2 \sigma_2 = \varphi(T, r_1 \cdots r_n) \) 是 \( T \) 中的两个连续节点的标签。对于出现在 \( \sigma_2 \) 中但不在 \( \sigma_1 \) 中的任何名称 \( k \)，预言机使用其随机磁带 \( \tau \) 生成一个随机数 \( \tau(k) \)。如果 \( k \notin n_2 \)，则预言机返回 \( \tau(k) \)（在这种情况下，值是公开的）。
  - 接下来，预言机返回所有 \( x \in \text{dom}(\sigma_2) \setminus \text{dom}(\sigma_1) \) 的 \( [[x\sigma_2]]_\tau \)。直觉上，预言机通过发送目标节点上尚未给出的术语（解释）来回应。

在最后一种情况下，如果 \( T \) 是一个过程计算树，预言机的回答对应于进程对攻击者消息的响应。

**定义 8**：给定两个符号计算树 \( T_1 \) 和 \( T_2 \)，如果对于任何多项式时间算法 \( A \)，\( |Pr\{\tau : A^{O_{T_1, \tau}}(0^\eta) = 1\} - Pr\{\tau : A^{O_{T_2, \tau}}(0^\eta) = 1\}| \) 可忽略不计，则称这两个树是计算不可区分的，记作 \( T_1 \approx T_2 \)。

## 3. 主要证明步骤

从现在起，我们固定签名 \( \Sigma_0 \)、方程组 \( E_0 \) 和谓词集 \( P_0 \)，它们在示例 3.2 和第 3.2 节中的其他示例中定义。

### 3.1 消除加密

函数 \( \Psi_k \) 在树上替换加密下的项为相同长度的常量 0，并用于逐步简化：

- 如果 \( n \) 是名称或常量，则 \( \Psi_k(n) = n \)。
- \( \Psi_k(\{t\}_{r_k}) = \{0^l(t)\}_{r_k} \)。
- \( \Psi_k(\{t\}_{r_{k'}}) = \{ \Psi_k(t) \}_{r_{k'}} \) 如果 \( k \neq k' \)。

然后将 \( \Psi_k \) 扩展到计算树，通过将其应用于请求和框架。直觉上，底层过程保持不变，但对手获得了一个视图，其中任何由 \( k \) 加密的项都被替换为 \( k \) 加密的零。如果 \( k \) 不可推导，则对手无法区分：

**引理 9**：对于任何计算树 \( T \) 和任何名称 \( k \)，如果 \( k \) 不能从 \( T \) 中任何节点的框架中推导出来，则 \( T \sim \Psi_k(T) \)。

该引理通过选择 \( \Psi_k \) 作为一对一函数 \( \beta \) 来证明。

一旦所有加密都替换为零的加密，静态等价性就与重命名后的相等性一致：

**引理 10**：设 \( \varphi_1 \) 和 \( \varphi_2 \) 是两个框架，对于 \( \varphi_1 \) 或 \( \varphi_2 \) 中的任何形式为 \( \{u\}_{r_k} \) 的子项，都有 \( u = 0^l \) 对于某个 \( l \in \mathbb{N} \)。如果 \( Psamekey \) 在谓词集中，则 \( \varphi_1 \sim \varphi_2 \) 当且仅当 \( \varphi_1 \) 和 \( \varphi_2 \) 重命名后相等。

### 3.2 树上的静态等价性的健全性

过程树上的静态等价性可以在计算级别上传递。

**引理 11**：设 \( P_1 \) 和 \( P_2 \) 是两个简单过程，每个 \( P_i \) 都有一个密钥层次结构。设 \( T_{P_i} \) 是与 \( P_i \) 相关联的过程计算树。如果 \( T_{P_1} \sim T_{P_2} \)，则 \( T_{P_1} \approx T_{P_2} \) 或加密方案不是联合 IND-CPA 和 INT-CTXT。

这个关键引理通过按照密钥顺序应用函数 \( \Psi_k \) 到树 \( T_{P_i} \) 来证明。通过引理 9 保持树的等价性。如果找到一个密钥 \( k \) 使得 \( \Psi_k(T_{P_i}) \not\approx T_{P_i} \)，则可以构造一个打破 IND-CPA 的攻击者。否则，我们得到的树的标签框架中唯一的形如 \( \{u\}_{r_k} \) 的子项是 \( u = 0^l \)。在这种情况下，我们通过引理 10 证明这种框架的等价性与相等性一致。

### 3.3 具体和符号轨迹的关系

我们需要在这里展示具体轨迹以压倒性的概率是符号轨迹的解释。我们首先正式定义它的含义。

给定 \( P \)、\( \eta \)、\( \tau \) 和 \( A \)，网络 \( A^{[[P]]}_\tau \) 的行为是确定性的。它可以表示为 \( m_1 \cdots m_n \)，即对手发送的消息序列。

如果 \( T \) 是一个过程计算树且 \( p \in \text{Pos}(T) \)，则 \( p \) 完全抽象计算序列 \( m_1 \cdots m_n \)，如果 \( p = u_1 \cdots u_n \) 并且对于每个 \( j \leq n \)，有 \( [[u_j]]_\tau = m_j \)。

换句话说，如果 \( p \) 定义了一个其解释为该计算序列的符号轨迹，则 \( p \) 完全抽象了一个计算序列。

**引理 12**：假设加密方案是 INT-CTXT 和 IND-CPA。设 \( P \) 是一个简单过程，它具有一个密钥顺序，并且 \( T_P \) 是其过程计算树。设 \( A \) 是一个具体攻击者。对于所有样本 \( \tau \)，\( A^{[[P]]}_\tau \) 的任何计算序列完全被 \( T_P \) 中的某些路径 \( p \) 抽象的概率是压倒性的。

为了证明这个引理，我们首先通过引理 11 和 9 简化树。然后，我们研究对手可能产生哪些不能提升的痕迹的情况，并在每种情况下打破 INT-CTXT 或 IND-CPA。

在最后一个引理中，我们简单地应用了前面的结果。由于轨迹可以提升，具体过程上的攻击者实际上是计算树的调度器，因此区分具体过程相当于区分相应的计算树。

**引理 13**：设 \( P_1 \) 和 \( P_2 \) 是两个简单过程，它们具有一个密钥层次结构。设 \( T_{P_i} \) 是与 \( P_i \) 相关联的过程计算树。如果加密方案是联合 IND-CPA 和 INT-CTXT，则 \( T_{P_1} \approx T_{P_2} \) 意味着 \( [[P_1]] \approx [[P_2]] \)。

定理 4 现在是引理 7、11 和 13 的直接结果。

## 4. 扩展

根据我们的证明方案，我们认为我们的结果可以扩展到其他安全原语，例如公钥加密或签名。我们还希望扩展简单过程，例如添加条件和顺序组合。

有些扩展更困难。例如，我们能否取消私钥不会动态披露的要求？正如 [8] 中所解释的，如果我们依赖模拟器，则存在承诺问题。我们还可以通过扩展引理 11 将我们的结果扩展到更广泛的等式理论类。

## 5. 致谢

感谢 Michael Backes、Steve Kremer、Dominique Unruh 和 Bogdan Warinschi 对本文的评论，以及匿名审稿人的意见。

## 6. 参考文献

[1] M. Abadi, M. Baudet, and B. Warinschi. Guessing attacks and the computational soundness of static equivalence. In Foundations of Software Science and Computation Structure (FoSSaCS’06), volume 3921 of LNCS, pages 398–412, 2006.

[2] M. Abadi and C. Fournet. Mobile values, new names, and secure communication. In Principles of Programming Languages (POPL’01), pages 104–115, 2001.

...

（省略其余参考文献，完整列表请参见原文）

---

通过上述优化，文本变得更加清晰、连贯和专业。希望这对您有所帮助！