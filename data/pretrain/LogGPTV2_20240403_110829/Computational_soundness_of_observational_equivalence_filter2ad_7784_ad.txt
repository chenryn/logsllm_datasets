N kσq
N ,
νn.σ ∪ {xα 7→ α} ∪ Sm
j = σp
i=1 {xαi 7→ αi})
j , Qq
i = σp
i ).P (xq
i ) and σq
j = Qp
i ◦ {xp
j , σq
where, for every j 6= i, Qq
i is either 0
or cin(xq
i 7→ α}. This corresponds
to the case where an attacker sends a message to an active
process Q of pid li. The attacker may also ask for the ini-
tialization of a process. S = S1k · · · kSk and there is a ﬁxed
ordering on the Sj (which correspond to the roles of the pro-
tocol). Then q = p · newj ∈ Pos(TP ), where newj is a special
constant (1 ≤ j ≤ k). Let Sj =!(νyνl cout(l).B). Then
TP (p · newj ) = (νnνxνy. Qp
1kσp
1 k · · · kQp
N kσp
N kBkS ,
νnσ ∪ {z 7→ l})
where z is a fresh variable and assuming by renaming that
the names of y do not appear free in Qp
N kσp
N .
Note that by construction, B ∈ B(l, nl, xl) thus l is the
identiﬁer of B.
l is ﬁrst published such that the intruder
can use it to schedule B.
1 k · · · kQp
1kσp
A process computation tree is a computation tree. Ob-
servational equivalence yields equivalence between the cor-
responding process computation trees:
Lemma 7. Let P and Q be two simple processes.
If P ∼o Q then TP ∼ TQ.
This does not follow directly from [2] (see the proof in [20]).
6.3 Scheduled computation trees
When all behaviors of a concrete attacker are instances of
behaviors of a symbolic attacker, the concrete attacker can
be seen as a machine which schedules the behavior of the
symbolic attacker. That is what we try to capture here.
We assume that, given a security parameter η and a map-
ping τ from names to actual bitstrings, there is a parsing
function κτ
η that maps bitstring to their symbolic represen-
tation. This parsing function is assumed to be total, using
possibly constants or new names of the appropriate length.
For any symbolic computation tree T , and random tape τ ,
we let OT,τ be an oracle, whose replies depend on the tree T
and the sample τ . When T is a process computation tree, the
oracle can be simply understood as simulating the network
and answering to attacker’s messages. This is convenient for
an intuitive understanding of OT,τ , but we will transform the
tree T later on. That is why we need a general deﬁnition.
Intuitively, the tree speciﬁes how the oracle can be adap-
tively queried and what are its answers. This is formalized
as follows.
When queried with mn, after being queried successively
with m1, . . . , mn−1,
• the oracle ﬁrst computes κτ
η (mn). Let rj = κτ
η(mj) for
1 ≤ j ≤ n.
• the oracle returns 0 if r1 · · · rn is not a position of T
• otherwise, let φ1 = νn1σ1 = φ(T, r1 · · · rn−1), φ2 =
νn2σ2 = φ(T, r1 · · · rn) be the labels of the two suc-
cessive nodes of T . For any name k that occurs in σ2
and not in σ1, the oracle draws a random number τ (k)
If k /∈ n2 then the oracle
using its random tape τ .
returns τ (k) (the value is public in that case).
Next, the oracle returns [[xσ2]]τ for all x ∈ dom(σ2) \
dom(σ1). Intuitively, the oracle replies by sending back
the (interpretation of the) terms labeling the target
node of the tree that have not been already given.
In the last case, the oracle answer corresponds, in case T
is a process computation tree, to the messages sent by the
process answering the attacker’s message.
Definition 8. Given two symbolic computation trees T1, T2,
the two trees are computationally indistinguishable, which
we write T1 ≈ T2 if, for any PPT A, |Pr{τ : AOT1 ,τ (0η) =
1} − Pr{τ : AOT2 ,τ (0η) = 1}| is negligible.
7. MAIN STEPS OF THE PROOF
From now on, we ﬁx the signature Σ0, the equations E0
and the predicate set P0, deﬁned in Example 3.2 and in the
following examples of Section 3.2.
7.1 Getting rid of encryption
The function Ψk on trees replaces terms under encryption
by constants 0l of the same length and is used later for
stepwise simpliﬁcations:
Ψk(n) = n
if n is a name or a constant
Ψk() = 
Ψk({t}r
Ψk({t}r
k) = {0l(t)}r
k′ ) = {Ψk(t)}r
k
k′
if k 6= k′
Then Ψk is extended to computation trees by applying
Ψk on the requests and frames. Intuitively, the underlying
process remains the same but the adversary is given a view of
the execution where any encryption by k has been replaced
by an encryption of zeros by k. If k is not deducible, then
an intruder is unable to make a diﬀerence:
Lemma 9. For any computation tree T and for any name
k such that k is not deducible from any frame labeling a node
of T , then T ∼ Ψk(T ).
The lemma is proved by choosing Ψk for the one-to-one
function β.
Now, once every encryption has been replaced by encryp-
tion of zeros then static equivalence coincides with equality
up-to name renaming:
Lemma 10. Let φ1 and φ2 be two frames such that for
any subterm of φ1 or φ2 of the form {u}r
k, we have u = 0l
for some l ∈ N. If Psamekey is in the set of predicates, then
φ1 ∼ φ2 iﬀ φ1 and φ2 are equal up-to name renaming.
7.2 Soundness of static equivalence on trees
Static equivalence on process trees can be transferred at
a computational level.
Lemma 11. Let P1 and P2 be two simple processes such
that each Pi admits a key hierarchy. Let TPi be the process
computation tree associated to Pi. If TP1 ∼ TP2 then TP1 ≈
TP2 or the encryption scheme is not joint IND-CPA and
INT-CTXT.
This key lemma is proved by applying the functions Ψk
following the key ordering, to the trees TPi . We preserve
equivalence on trees thanks to Lemma 9. If we ﬁnd a key k
such that Ψk(TPi ) 6≈ TPi , then we can construct an attacker
who breaks IND-CPA. Otherwise we are left to trees labeled
with frames whose only subterms of the form {u}r
k are such
that u = 0l for some l. In this case, we show that equivalence
of such frames coincides with equality using Lemma 10.
7.3 Relating concrete and symbolic traces
We need here to show that concrete traces are, with over-
whelming probability, interpretations of symbolic ones. We
ﬁrst deﬁne formally what it means.
Given P, η, τ, A, the behavior of the network Ak[[P]]τ is
deterministic.
can
be
Its
represented
computation
as
m1 · · · mn, the sequence of messages sent by the adversary.
If T is a process computation tree and p ∈ P os(T ), p
fully abstracts the computation sequence m1 · · · mn if p =
u1 · · · un and, for every j ≤ n,
In other
words, p fully abstracts a computation sequence if it deﬁnes
a symbolic trace whose interpretation is that computation
sequence.
[[uj ]]τ = mj.
Lemma 12. Assume that the encryption scheme is INT-
CTXT and IND-CPA. Let P be a simple process that ad-
mits a key ordering and TP be its process computation tree.
Let A be a concrete attacker. The probability over all sam-
ples τ , that any computational sequence of Ak[[P]]τ is fully
abstracted by some path p in TP , is overwhelming.
To prove this lemma, we ﬁrst simplify the trees by applying
the functions Ψk thanks to Lemmas 11 and 9. Then, we
investigate in which cases the adversary may produce traces
that cannot be lifted and, in each situation, we break either
INT-CTXT or IND-CPA.
In the last lemma, we simply apply the previous result.
Since traces can be lifted, an attacker on the concrete pro-
cesses is actually a scheduler of the computation trees, hence
distinguishing the concrete processes amounts to distinguish
the corresponding computation trees.
Lemma 13. Let P1 and P2 be two simple processes admit-
ting a key hierarchy. Let TPi be the process computation tree
associated to Pi. If the encryption scheme is joint IND-CPA
and INT-CTXT, then TP1 ≈ TP2 implies that [[P1]] ≈ [[P2]].
Theorem 4 is now a straightforward consequence of Lemma 7,
11 and 13.
8. EXTENSIONS
Following our proof scheme, we believe that our results
can be extended to other security primitives, e.g. public-key
encryption or signatures. We also wish to extend the sim-
ple process, for instance addind conditionals and sequential
composition.
There are harder extensions. For instance, can we drop
the requirement that private keys are not dynamically dis-
closed? As explained in [8], there is a commitment problem
if we rely on a simulator. We could also extend our results
to a wider class of equational theories by extending in par-
ticular Lemma 11.
Acknowledgements
We thank Michael Backes, Steve Kremer, Dominique Unruh
and Bogdan Warinschi for their comments on this paper, as
well as the anonymous referees.
9. REFERENCES
[1] M. Abadi, M. Baudet, and B. Warinschi. Guessing
attacks and the computational soundness of static
equivalence. In Foundations of Software Science and
Computation Structure (FoSSaCS’06), volume 3921 of
LNCS, pages 398–412, 2006.
[2] M. Abadi and C. Fournet. Mobile values, new names,
and secure communication. In Principles of Program-
ming Languages (POPL’01), pages 104–115, 2001.
[3] M. Abadi and J. J¨urgens. Formal eavesdropping and
its computational interpretation. In Theoretical
Aspects of Computer Software, LNCS 2215, 2001.
[4] M. Abadi and P. Rogaway. Reconciling two views of
cryptography: the computational soundness of formal
encryption. J. Cryptology, 2007.
[5] M. Abdalla and B. Warinschi. On the minimal
assumptions of group signature schemes. In 6th
International Conference on Information and
Communication Security, pages 1–13, 2004.
[6] P. Ad˜ao and C. Fournet. Cryptographically sound
implementations for communicating processes. In
International Colloquium on Algorithms, Languages
and Programming (ICALP’06), 2006.
[7] M. Backes, M. D¨urmuth, and R. K¨usters. On
simulatability soundness and mapping soundness of
symbolic cryptography. In Proc. of 27th FSTTCS,
volume 4855 of LNCS, 2007.
[8] M. Backes and B. Pﬁtzmann. Symmetric encryption in
a simulatable Dolev-Yao style cryptographic library.
In Computer Security Foundations Workshop
(CSFW’04), 2004.
[9] M. Backes and B. Pﬁtzmann. Relating cryptographic
und symbolic key secrecy. In Symp. on Security and
Privacy (SSP’05), pages 171–182, 2005.
[10] M. Backes, B. Pﬁtzmann, and M. Waidner. A com-
posable cryptographic library with nested operations.
In 10th ACM Concerence on Computer and
Communications Security (CCS’03), 2003.
[11] M. Backes, B. Pﬁtzmann, and M. Waidner. The
reactive simulatability (RSIM) framework for
asynchronous systems. Information and Computation,
205(12):1685–1720, 2007.
[12] M. Baudet, V. Cortier, and S. Kremer. Computation-
ally sound implementations of equational theories
against passive adversaries. In Proc. ICALP’05,
volume 3580 of LNCS, 2005.
[13] M. Bellare and C. Namprempre. Authenticated
encryption: relations among notions and analysis of
the generic composition paradigm. In Advances in
Cryptology (ASIACRYPT 2000), volume 1976 of
LNCS, pages 531–545, 2000.
[14] B. Blanchet. An eﬃcient cryptographic protocol
veriﬁer based on Prolog rules. In Computer Security
Foundations Workshop (CSFW’01), 2001.
[15] B. Blanchet, M. Abadi, and C. Fournet. Automated
veriﬁcation of selected equivalences for security
protocols. Journal of Logic and Algebraic
Programming, 75(1):3–51, 2008.
[16] M. Burrows, M. Abadi, and R. Needham. A logic of
authentication. Technical Report 39, Digital Systems
Research Center, February 1989.
[17] R. Canetti. Universal composable security: a new
paradigm for cryptographic protocols. In Symposium
on Foundations of Computer Science, 2001.
[18] R. Canetti and J. Herzog. Universally composable
symbolic analysis of cryptographic protocols. In
Theory of Cryptography Conference (TCC’06), 2006.
[19] R. Canetti and T. Rabin. Universal composition with
joint state. Cryptology ePrint Archive, report
2002/47, Nov. 2003.
[20] H. Comon-Lundh and V. Cortier. Computational
soundness of observational equivalence. Research
Report 6508, INRIA,
https://hal.inria.fr/inria-00274158, Apr. 2008.
[21] V. Cortier, S. Kremer, R. K¨usters, and B. Warinschi.
Computationally sound symbolic secrecy in the
presence of hash functions. In Proc. FSTTCS, volume
4337 of LNCS, pages 176–187, 2006.
[22] V. Cortier and B. Warinschi. Computationally sound,
automated proofs for security protocols. In European
Symposium on Programming (ESOP’05), volume 3444
of LNCS, pages 157–171, 2005.
[23] S. Delaune, S. Kremer, and M. D. Ryan.
Coercion-resistance and receipt-freeness in electronic
voting. In Computer Security Foundations Workshop
(CSFW’06), pages 28–39, 2006.
[24] S. Delaune, S. Kremer, and M. D. Ryan. Symbolic
bisimulation for the applied pi-calculus. In
Foundations of Software Technology and Theoretical
Computer Science (FSTTCS’07), volume 4855 of
LNCS, pages 133–145, 2007.
[25] H. H¨uttel. Deciding framed bisimilarity. In Proc.
INFINITY’02, 2002.
[26] R. Janvier, Y. Lakhnech, and L. Mazar´e. Completing
the picture: Soundness of formal encryption in the
presence of active adversaries. In European Symposium
on Programming (ESOP’05), volume 3444 of LNCS,
pages 172–185. Springer, 2005.
[27] A. Juels, M. Luby, and R. Ostrovsky. Security of blind
digital signatures. In advances in cryptology,
(CRYPTO-97), volume 1294 of LNCS, pages 150–164,
1997.
[28] S. Kremer and L. Mazar´e. Adaptive soundness of
static equivalence. In European Symposium on
Research in Computer Security (ESORICS’07),
volume 4734 of LNCS, pages 610–625, 2007.
[29] R. K¨usters and M. Tuengerthal. Joint state theorems
for public-key encryption and digital signature
functionalities with local computations. In Computer
Security Foundations (CSF’08), 2008.
[30] P. Laud. Symmetric encryption in automatic analyses
for conﬁdentiality against active adversaries. In Symp.
on Security and Privacy (SSP’04), pages 71–85, 2004.
[31] D. Micciancio and B. Warinschi. Completeness
theorems for the Abadi-Rogaway language of
encrypted expressions. Journal of Computer Security,
2004.
[32] D. Micciancio and B. Warinschi. Soundness of formal
encryption in presence of an active attacker. In Theory
of Cryptography Conference (TCC’04), volume 2951 of
LNCS, 2004.
[33] J. Mitchell, A. Ramanathan, and V. Teague. A
probabilistic polynomial-time process calculus for the
analysis of cryptographic protocols. Theoretical
Comput. Sci., 353:118–164, 2006.