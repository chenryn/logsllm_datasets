available, estimates from other sources place the number of
monthly active WhatsApp users in the US at 25 million [16].
Our estimate deviates from this number, because our results
include all registered numbers, not only active ones. Another
statistic [17] estimates the number of US mobile phone numbers
that accessed WhatsApp in 2019 at 68.1 million, which seems
to be an overestimation based on our results.
8
For a random subset of 150,000 users we also analyzed
the availability of proﬁle pictures and About texts: 49.6 %
have a publicly available proﬁle picture and 89.7 % have a
public About text. An analysis of the most popular About texts
shows that the predeﬁned (language-dependent) text is the most
popular (77.6 %), followed by “Available” (6.71 %), and the
empty string (0.81 %, including “.” and “*** no status ***”),
while very few users enter custom texts.
Signal. Our script for Signal uses 100 accounts over 25 days
to check all 505 million mobile phone numbers in the US.
Our results show that Signal currently has 2.5 million users
registered in the US, of which 82.3 % have set an encrypted
user name, and 47.8 % use an encrypted proﬁle picture. We
also cross-checked with WhatsApp to see if Signal users differ
in their use of public proﬁle pictures, and found that 42.3 %
of Signal users are also registered on WhatsApp (cf. Tab. IV),
and 46.3 % of them have a public proﬁle picture there.
While this is slightly lower than the average for WhatsApp
users (49.6 %), it is not sufﬁcient to indicate an increased
privacy-awareness of Signal’s users, at least for proﬁle pictures.
Telegram. For Telegram we use 20 accounts running
for 20 days on random US mobile phone numbers. Since Tele-
gram’s rate limits are very strict, only 100,000 numbers
were checked during that time: 0.9 % of those are registered
and 41.9 % have a non-zero importer_count. These num-
bers have a higher probability than random ones to be present on
other messengers, with 20.2 % of the numbers being registered
with WhatsApp and 1.1 % registered with Signal, compared to
the average success rates of 9.8 % and 0.9 %, respectively. Of
the discovered Telegram users, 44 % of the crawled users have
at least one public proﬁle picture, with 2 % of users having
more than 10 pictures available.
Summary and Comparison. An overview of the tested
messengers, our crawling setup, and our most important results
are given in Tab. III. Our crawling of WhatsApp, Signal,
and Telegram provides insight into privacy aspects of these
messengers with regard to their contact discovery service. The
ﬁrst notable difference is the storage of the users’ contact
information, where both WhatsApp and Telegram retain this
information on the server, while Signal chooses not to maintain
a server-side state in order to better preserve the users’ privacy.
This practice unfortunately requires signiﬁcantly higher rate-
limits for the contact discovery process, since all of a user’s
contacts are compared on every sync, and the server has no
possibility to compare them to previously synced numbers.
While Telegram uses the server-side storage of contacts to
enforce strict rate limits, WhatsApp nevertheless lets individual
clients check millions of numbers.
With its focus on privacy, Signal excels in exposing almost
no information about registered users, apart from their phone
number. In contrast, WhatsApp exposes proﬁle pictures and
the About text for registered numbers, and requires users to
opt-out of sharing this data by changing the default settings.
Our results show that only half of all US users prevent such
sharing by either not uploading an image or changing the
settings. Telegram behaves even worse: it allows crawling
multiple images and also additional information for each user.
The importer_count offered by its API even provides
information about users not registered with the service. This
can help attackers to acquire likely active numbers, which can
be searched on other platforms.
Our results also show that many users are registered with
multiple services (cf. Tab. IV), with 42.3 % of Signal users
also being active on WhatsApp. We only found 2 out of 10,129
checked users on all three platforms (i.e., less than 0.02 %).
In Fig. 3, we visualize the popularity of WhatsApp and Signal
for the individual US states and Washington D.C. On average,
about 10 % of residents have mobile numbers from another
state [22], which may obscure these results to some extent.
Interestingly, Washington D.C. numbers are more than twice as
often registered on Signal than numbers from any other state,
with Washington D.C. also being the region with the most
non-local numbers (55 %) [22].
V.
INCREMENTAL CONTACT DISCOVERY
We propose a new rate-limiting scheme for contact discovery
in messengers without server-side contact storage such as Signal.
Setting strict limits for services without server-side contact stor-
age is difﬁcult, since the server cannot determine if the user’s
input in discovery requests changes signiﬁcantly with each
invocation. We named our new approach incremental contact
discovery and shared its details with the Signal developers who
consider to implement a similar approach (cf. § VIII). Our
approach provides strict improvements over existing solutions,
as it enables the service to enforce stricter rate limits with
negligible overhead and without degrading usability or privacy.
A. Approach
Incremental contact discovery is based on the observation
that the database of registered users changes only gradually
over time. Similarly, the contacts of legitimate users change
only slowly. Given that clients are able to store the last state
for each of their contacts, they only need to query the server
for changes since the last synchronization. Hence, if the server
tracks database changes (new and unsubscribed users), clients
who connect regularly only need to synchronize with the set
of recent database changes. This enables the server to enforce
stricter rate limits on the full database, which is only needed
for initial synchronization, for newly added client contacts, and
whenever the client fails to regularly synchronize with the set
of changes. Conversely, enumeration attacks require frequent
changes to the client set, and thus will quickly exceed the rate
limits when syncing with the full database.
9
Assumptions. Based on Signal’s current rate limits, we
assume that each user has at most m = 50,000 contacts that are
synced up to 4 times per day. This set changes slowly, i.e., only
by several contacts per day. Another reasonable assumption is
that the server database of registered users does not signiﬁcantly
change within short time periods, e.g., only 0.5 % of users join
or leave the service per day (cf. § V-C).
Algorithm. The server of the service provider stores
two sets of contacts: the full set SF and the delta set SD.
SF contains all registered users, while SD contains only
information about users that registered or unregistered within
the last TF days. Both sets, SF and SD, are associated with
their own leaky buckets of (the same) size m, which are empty
after TF and TD days, respectively. The server stores leaky
bucket values tF and tD for each client, which represent
the (future) points in time when the leaky buckets will be
empty for requests to SF and SD, respectively.
A newly registered client syncs with the full set SF to
receive the current state of the user’s contacts. For subsequent
syncs, the client only syncs with SD to receive recently changed
contacts, provided that it synchronizes at least every TF days.
If the client is ofﬂine for a longer period of time, it can sync
with SF again, since the leaky bucket associated with it will
be empty. New contacts added by the user are initially synced
with SF in order to learn their current state.
The synchronization with SF is given in Alg. 1. It takes as
inputs the server’s set SF , the maximum number of contacts m,
and the associated time TF after which the bucket will be
empty. The client provides the set of contacts CF and the
server provides the client’s corresponding bucket parameter tF .
The output is the set D which is the intersection of CF with SF ,
or an error, if the rate limit is exceeded.
When a client initiates a sync with SF , the algorithm
calculates tnew, the new (future) timestamp when the client’s
leaky bucket would be empty (line 1). Here, |CF|/m × TF
represents the additional time which the bucket needs to drain.
If tnew is further into the future than TF (line 2), this indicates
that the maximum bucket size is reached, and the request will
abort with an error (line 3). Otherwise, the leaky bucket is
updated for the client (line 4), and the intersection between the
client set CF and the server set SF is returned (line 5).
The synchronization with SD shown in Alg. 2 is quite
similar. Here, the server supplies SF , SD, m, TD, and tD,
and the client provides the previously synced contacts CD.
The main difference to Alg. 1 is that it outputs RD, i.e., the
requested contacts that changed (registered or unregistered)
within the last TF days together with their current state (line 5).
Note that SF is only used to check the state for contacts in SD.
Algorithm 1 Synchronization with full set SF
Input: SF , m, TF , CF , tF
Output: D
1: tnew ← max(tF , current time) +|CF|/m × TF
2: if tnew > current time + TF then
3:
4: tF ← tnew
5: return CF ∩ SF
raise RateLimitExceededError
B. Implementation
We provide an open-source proof-of-concept
imple-
incremental contact discovery scheme
mentation of our
Algorithm 2 Synchronization with delta set SD
Input: SF , SD, m, TD, CD, tD
Output: RD
1: tnew ← max(tD, current time) +|CD|/m × TD
2: if tnew > current time + TD then
3:
4: tD ← tnew
5: return {(x, x ∈ SF ) for x ∈ CD ∩ SD}
raise RateLimitExceededError
written in Python at https://contact-discovery.github.io/. It
uses Flask [54] to provide a REST API for performing contact
discovery. While not yet optimized for performance, our
implementation can be useful for service providers and their
developers, and in particular can facilitate integration of our
idea into real-world applications.
C. Evaluation
Overhead. Our incremental contact discovery introduces
only minimal server-side storage overhead, since the only
additional information is the set SD (which is small compared
to SF ), as well as the additional leaky bucket states for each
user. The runtime is even improved, since subsequent contact
discovery requests are only compared to the smaller set SD.
the additional storage overhead is
introduced by the need to store a timestamp of the last sync
to select the appropriate set to sync with, as well as a set of
previously unsynced contacts CD.
On the client side,
Improvement. To evaluate our construction, we compare
it to the leaky bucket approach currently deployed by Signal.
Concretely, we compare the discovery rate of the schemes, i.e.,
the number of users that can be found by a single client within
one day with a random lookup strategy. Rate-limiting schemes
should minimize this rate for attackers without impacting
usability for legitimate users. For Signal, the discovery rate
is r = s · 4 · 50,000/day, where s is the success rate for
a single lookup, i.e., the ratio between registered users and
all possible (mobile) phone numbers. Based on our ﬁndings
in § IV-H, we assume s = 0.5 %, which results in a discovery
rate of r = 1,000/day for Signal’s leaky bucket approach.
For our construction, the discovery rate is the sum of the
rates rF and rD for the buckets SF and SD, respectively.
While rF is calculated (similar to Signal) as rF = s · m/TF ,
rD is calculated as rD = s · m · c · TF /TD, where c is the
change rate of the server database. To minimize r, we have
to set TF = (cid:112)TD/c. With Signal’s parameters s = 0.5 %,
for our construction therefore is r = 1,000 · √
m = 50,000, and TD = 0.25 days, the total discovery rate
c/day, and the
√
improvement factor is exactly 1/
c.
In reality, the expected change rate depends on the popular-
ity of the platform: Telegram saw 1.5 M new registrations
per day while growing from 300 M to 400 M users [23],
corresponding to a daily change rate of ≈0.5 %. WhatsApp,
reporting 2 billion users in February 2020 [25] (up from 1.5 bil-
lion in January 2018 [18]), increases its userbase by an average
of 0.05 % per day. Compared to Signal’s rate limiting scheme,
incremental contact discovery results in an improvement
of 14.1x and 44.7x for Telegram’s and WhatsApp’s change
rate, respectively (cf. Tab. V). Even at a theoretical change rate
of 25 % per day, incremental discovery is twice as effective
as Signal’s current approach. Crawling entire countries would
10
c (in %/d)
0.01
0.05
0.1
0.5
1.0
2.0
TF (in d)
50.0
22.4
15.8
7.1
5.0
3.5
r (in #contacts/d)
Improvement
10.0
22.4
31.6
70.7
100.0
141.4
100.0x
44.7x
31.6x
14.1x
10.0x
7.1x
Table V: Effect of change rate c on the optimal choice for TF ,
the discovery rate r for our incremental contact discovery, and
the improvement compared to Signal’s leaky bucket approach.
only be feasible for very powerful attackers, as it would require
over 100k registered accounts (at c = 0.05 %) to crawl, e.g.,
the US in 24 hours. It should be noted that in practice the
change rate c will ﬂuctuate over time. The resulting efﬁciency
impact of non-optimal choices for TF is further analyzed in § E.
Privacy Considerations. If attackers can cover the whole
number space every TF days, it is possible to ﬁnd all newly
registered users and to maintain an accurate database. This is not
different from today, as attackers with this capacity can sweep
the full number space as well. Using the result from Alg. 2,
users learn if a contact in their set has (un)registered in the
last TF days, but this information can currently also be retrieved
by simply storing past discovery results.
D. Generalization
Our construction can be generalized to further decrease an
attacker’s efﬁciency. This can be achieved by using multiple
sets containing the incremental changes of the server set over
different time periods (e.g., one month, week, and day) such
that the leak rate of SF can be further decreased. It is even
possible to use sets dynamically chosen by the service without
modifying the client: each client sends its timestamp of the
last sync to the service, which can be used to perform contact
discovery with the appropriate set.
VI. MITIGATION TECHNIQUES
We now discuss countermeasures and (mostly known)
mitigation techniques for both hash reversal and enumeration
attacks. We discuss further supplemental techniques in § F.
A. Hash Reversal Mitigations
Private set intersection (PSI) protocols (cf. § VII-A) can
compute the intersection between the registered user database
and the users’ address books in a privacy-preserving manner.
Thus, utilizing provably secure PSI protocols in contact discov-
ery entirely prevents attacks where curious service providers
can learn the user’s social graph when receiving hashes of
low-entropy contact identiﬁers such as phone numbers.
However, even with PSI, protocol participants can still
perform enumeration attacks. Even with actively secure con-
structions (where privacy is still guaranteed despite arbitrary
deviations from the protocol), it is possible to choose different
inputs for each execution. In fact, the privacy provided by PSI
interferes with efforts to detect if the respective other party
replaced the majority of inputs compared to the last execution.
Thus, these protocols must be combined with protections against
enumeration attacks by restricting the number of protocol
executions and inputs to the minimum (cf. § VI-B and § V).
Moreover, PSI protocols currently do not achieve practical
performance for a very large number of users (cf. § VII-A). For
example, for the current amount of about 2 billion WhatsApp
users [25], each user has to initially download an encrypted
and compressed database of ≈8 GiB [37]. More practical PSI
designs either rely on rather unrealistic trust assumptions (e.g.,
non-colluding servers) or on trusted hardware [49] that provides
no provable security guarantees and often suffers from side-
channel vulnerabilities [9]. Hence, we discuss reasonable
performance/privacy trade-offs for contact discovery next.
Database Partitioning. To reduce the communication
overhead of PSI protocols to practical levels, the user database