# tl;dr
SQLite是世界上部署最多的软件之一。然而，从安全的角度来看，它只是通过WebSQL和浏览器开发的视角来进行安全检查。对于安全检查来说，这只是冰山一角。  
在我们的长期研究中，我们尝试了在SQLite中利用内存损坏问题，而不依赖SQL语言以外的任何环境。使用我们创新的查询劫持和面向查询编程技术，我们证明了能够在SQLite引擎中利用内存损坏问题。我们将在几个实际场景中演示这些技术:pwning密码窃取者后端服务器，以及使用更高的权限实现IOS持久性。  
我们希望发布我们的研究方法，能对其他安全从业人员有所启发，继续在无数可用的场景中审查SQLite。鉴于SQLite实际上是嵌入到每个主要的操作系统(桌面或移动)，因此审计的机会还是非常多的。此外，这里提供的许多原语并不是SQLite独有的，可以移植到其他SQL引擎。
# 动机
这项研究开始时，[omriher](https://twitter.com/omriher?lang=en
"omriher")和我正在查看一些由臭名昭著的密码窃取程序泄露的源代码。虽然存在很多密码窃取程序(Azorult、Loki
Bot和Pony等)，但他们的操作方式基本上是相同的：  
计算机感染恶意软件，恶意软件在使用凭据时捕获凭据，或者收集由各种客户端维护的存储凭据。  
客户端软件使用SQLite数据库的情况并不少见。  
在恶意软件收集到这些SQLite文件后，它会将它们发送到C2服务器，在那里使用PHP对它们进行解析，并将其存储在包含所有被盗凭据的集合数据库中。  
审计这些密码窃取程序泄露的源代码，我们开始猜测上面描述的攻击面。  
这些攻击会带来很大的影响，因为SQLite是目前部署最广泛的软件之一。
一个令人惊讶的复杂代码库，可在几乎任何设备中使用。这还不值得我们为此研究一番吗？
# SQLite简介
你可能没有意识到，你现在此刻正在使用SQLite的可能性很高。  
SQLite是一个C语言库，它实现了一个 小型， 快速， 自包含， 高可靠性， 功能齐全的
SQL数据库引擎。SQLite是世界上使用最多的数据库引擎。它内置于所有移动电话和大多数计算机中，并且捆绑在人们每天使用的无数其他应用程序中。  
与大多数其他SQL数据库不同，SQLite没有单独的服务器进程。SQLite直接读写普通磁盘文件。包含多个表、索引、触发器和视图的完整SQL数据库包含在单个磁盘文件中。
# 攻击面
鉴于我们控制数据库及其内容，我们可以将可用的攻击面分为两部分：数据库的加载和初始解析，以及对数据库执行的SELECT查询。  
sqlite3_open完成的初始加载实际上是一个非常有限的攻击面，
它基本上是很多用于打开数据库的设置和配置代码；最主要的攻击面是[头](https://www.sqlite.org/fileformat.html#the_database_header
"头")解析，针对AFL的测试。  
当我们开始查询数据库时，事情变得更加有趣。  
使用SQLite作者的话：
“SELECT语句是SQL语言中最复杂的命令。  
尽管我们无法控制查询本身(因为它在我们的目标中是硬编码的)，但仔细研究SELECT过程是一个必不可少的过程。  
由于SQLite3是虚拟机，因此必须首先使用一个`sqlite3_preare*`例程将每个SQL语句编译成字节码程序。  
在其余操作中，prepare函数遍历并扩展所有SELECT子查询。此过程的一部分是验证所有相关对象(如表或视图)是否确实存在，并在主模式中定位它们。
# sqlite_master和DDL
每个SQLite数据库都有一个sqlite_master表，该表定义了数据库及其所有对象(例如表、视图、索引等)的模式。sqlite_master表定义为：
我们特别感兴趣的部分是sql列。  
此字段是用于描述对象的DDL(数据定义语言)。  
在某种意义上，DDL命令类似于C头文件。DDL命令用于定义数据库中数据容器的结构、名称和类型，就像头文件通常定义类型定义、结构、类和其他数据结构一样。  
如果我们检查数据库文件，这些DDL语句实际上以纯文本形式出现：
在查询准备期间，sqlite3LocateTable（）尝试查找描述我们感兴趣的查询表的内存结构。  
sqlite3LocateTable()读取sqlite_master中可用的模式，如果这是第一次这样做，它还会对每个结果j进行回调，以验证DDL语句是否有效，并构建必要的内部数据结构来描述所讨论的对象。
# DDL补丁
当我们了解了这个过程后，不禁要问到，我们可以简单地替换文件中以纯文本形式出现的DDL吗？  
如果我们可以将我们自己的SQL注入到文件中，也许我们可以影响它的行为。  
基于上面的代码片段，DDL语句似乎必须以“create”开头。  
检查SQLite的文档发现，我们可以创建以下对象：  
CREATE
VIEW命令给了我们一个有趣的想法。简单来说，VIEW只是预先打包的SELECT语句。如果我们用兼容的VIEW替换目标软件所期望的表，那么有趣的机会就会显露出来。
# 劫持任何查询
想象一下以下场景：  
原始数据库有一个名为dummy的表，其定义为：  
目标软件使用以下内容对其进行查询：  
如果我们将dummy作为view，我们实际上可以劫持这个查询：  
这个“陷阱”view使我们能够劫持查询-这意味着我们生成了一个完全由我们控制的全新查询。  
这种细微差别极大地扩展了我们的攻击面，从极小的头解析和加载软件执行的无法控制的查询，到现在我们可以通过修补DDL并使用子查询创建我们自己的view来与SQLite解释器的大部分进行交互。  
现在我们可以与SQLite解释器进行交互，我们的下一个问题是SQLite中内置了哪些开发原语？它是否允许任何系统命令，从文件系统读取或写入文件系统？  
由于我们不是第一个从exploitation角度注意到SQLite的人，所以回顾以前在该领域所做的工作是很有必要的。我们从最基本的开始。
# SQL注入
我们希望熟悉SQLite提供的内部原语。有什么系统命令？我们可以加载任意库吗？  
[看起来](http://atta.cked.me/home/sqlite3injectioncheatsheet
"看起来")最直接的技巧是附加一个新的数据库文件，并使用如下方式向其写入：
我们附加一个新数据库，创建单个表并插入单行文本。然后，新数据库创建一个新文件(因为数据库是SQLite中的文件)，其中包含我们的Web shell。  
PHP解释器非会解析我们的数据库，直到PHP的开始标记“<？”。  
但是，DDL不能以“ATTACH”开头
另一个相关选项是load_extension函数。虽然此函数应该允许我们加载任意共享对象，但默认情况下它是禁用的。
# SQLite中的内存损坏
与任何其他用C编写的软件一样，在评估SQLite的安全性时，内存安全问题绝对是需要考虑的问题。  
在他伟大的[博客文章](https://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html
"博客文章")中，michałzalewski描述了他如何用afl对sqlite进行模糊测试，以获得一些令人印象深刻的结果：在仅仅30分钟的模糊测试中出现了22个bug。  
有趣的是，SQLite从此开始使用AFL作为其卓越测试套件中不可或缺的一部分。  
这些内存损坏问题都得到了应有的重视，但是，从攻击者的角度来看，如果没有合适的框架来利用这些漏洞，这些漏洞存在与否基本没有任何差别。  
现代缓解技术在利用内存损坏问题方面构成了一个主要障碍，攻击者需要找到一个更灵活的环境。  
安全研究社区很快就会找到完美的目标！
# Web SQL
Web SQL数据库是一种网页API，用于将数据存储在数据库中，可以通过JavaScript使用SQL的变体进行查询。W3C
Web应用程序工作组在2010年11月停止了该规范的工作，理由是缺少SQLite以外的独立实现。  
目前，该API仍受Google Chrome、Opera和Safari的支持。  
他们都使用SQLite作为该API的后端。  
在一些最流行的浏览器中，任何网站都可以访问SQLite中不受信任的输入，这引起了安全社区的注意，因此，漏洞的数量开始上升。  
突然之间，JavaScript解释器可以利用SQLite中的bug来实现浏览器漏洞利用。  
已经发表了几份令人印象深刻的研究报告：  
如[CVE-2015-7036](https://nvd.nist.gov/vuln/detail/CVE-2015-7036
"CVE-2015-7036")。  
不受信任的指针取消引用fts3_tokenizer()。  
Chaitin团队在Blackhat
17中展示的[更复杂的利用](https://www.blackhat.com/docs/us-17/wednesday/us-17-Feng-Many-Birds-One-Stone-Exploiting-A-Single-SQLite-Vulnerability-Across-Multiple-Software.pdf "更复杂的利用")。  
fts3OptimizeFunc()中的类型混淆  
Exodus最近利用的麦哲伦[漏洞](https://blog.exodusintel.com/2019/01/22/exploiting-the-magellan-bug-on-64-bit-chrome-desktop "漏洞")。  
fts3SegReaderNext（）中的整数溢出  
过去WebSQL的研究中表明，名为“FTS”的虚拟表模块可能是我们研究的重点。
# FTS
全文搜索(Full-text search，FTS)是一个虚拟表模块，允许对一组文档进行文本搜索。  
从SQL语句的角度来看，虚拟表对象看起来像任何其他表或视图。但是在幕后背后，虚拟表上的查询调用影子表上的回调方法，而不是通常对数据库文件的读写。  
一些虚拟表实现，如FTS，利用真实(非虚拟)数据库表来存储内容。  
例如，当将字符串插入到FTS3虚拟表中时，必须生成一些元数据以允许高效的文本搜索。  
此元数据最终存储在名为`%_Segdir`和`%_Segments`的实表中，而内容本身存储在`%_content`中，其中`%`是原始虚拟表的名称。  
这些包含虚拟表数据的辅助实表称为“影子表”
由于它们的信任性质，在影子表之间传递数据的接口为bug提供了肥沃的土壤。CVE-2019-8457-我们在RTREE虚拟表模块中发现的一个新的OOB读取漏洞，很好地证明了这一点。  
用于地理索引的RTREE虚拟表应该以整型列开头。因此，其他RTREE接口期望RTREE中的第一列是整数。然而，如果我们创建一个表，其中第一列是字符串，如下图所示，并将其传递给rtreenode()接口，则会发生OOB读取。
现在我们可以使用查询劫持来获得对查询的控制，并且知道在哪里可以找到漏洞，现在是时候利用漏洞了。
# SQLite Internals For Exploit Development
以前关于SQLite漏洞利用的文章清楚地表明包装封装环境总是有必要的，无论是这篇关于滥用SQLite令牌生成器的[博客文章](https://medium.com/0xcc/bypass-php-safe-mode-by-abusing-sqlite3s-fts-tokenizer-256ee2555607
"博客文章")中看到的PHP解释器，还是使用JavaScript解释器在Web SQL上的相关工作，封装环境总是非常有必要。  
很多安全社区很擅长利用JavaScript进行漏洞利用开发，那么我们可以用SQL实现类似的原语吗  
考虑到SQL是图灵完备的([[1]](http://assets.en.oreilly.com/1/event/27/High%252520Performance%252520SQL%252520with%252520PostgreSQL%252520Presentation.pdf
"\[1\]")，[[2]](http://wiki.postgresql.org/wiki/Mandelbrot_set
"\[2\]"))，基于我们的pwning经验为漏洞利用开发创建一个原始列表。  
内存泄漏。  
将整数打包和解包到64位指针。  
指针算法。  
在内存中创建复杂的假对象。  
堆喷射  
我们将逐一解决这些原语，并使用SQL来实现它们  
为了在PHP7上实现RCE，我们将利用尚未被修复的1-day
[CVE-2015-7036](https://nvd.nist.gov/vuln/detail/CVE-2015-7036