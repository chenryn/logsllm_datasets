将代号为HD 2000/3000的GPU和CPU集成到同一个晶片（die）中，
前者的名字也由英特尔集成显卡改称为Intel Processor Graphics。
将内存控制器（MCH）和CPU集成到一个晶片。
老雷评点
这一年5月，老雷从工作多年的平台部门转入英特尔的GPU
团队。
2.2.9 Ivy Bridge微架构
从2012年4月推出的第三代酷睿处理器内部使用的是Ivy Bridge微架
构，它与Sandy Bridge的变化不大，大多数开发工作也是在以色列完成
的，主要的改进如下。
生产工艺方面：使用22nm 3-D晶体管技术，功耗更低。
新增了随机数产生器和RdRand指令。
集成的GPU支持DirectX 11。
老雷评点
晨起，于衣柜中偶见当年庆祝Ivy Bridge发布的T恤衫，勾起
许多回忆。
老雷再评
当年庆祝Ivy Bridge发布时还得到一件特别的礼物—— 一块
基于Ivy Bridge微架构的I5 3450 CPU。此CPU在信封中躺了5年
多，直到2017年10月，它才有机会实际运行，虽然此时它已经不
再时尚，但是却刚好符合老雷调试某个特定问题的需要。
2.2.10 Haswell微架构
在2013年台北Computex大会上正式推出的第四代酷睿微架构的代号
为Haswell。其主要具有以下新特征。
更宽的执行流水线，新增两个微指令分发端口，每个时钟周期可以
分发的微指令从原来的6条提升为8条。
改进AVX技术，升级为AVX2。
新增Transactional Memory支持，简称TSX。
2.2.11 Broadwell微架构
第五代酷睿微架构的代号为Broadwell，在设计方面只是在Haswell
微架构上略加改进，而在生产工艺方面，则从22nm降低到14nm。产品
的推出时间是2015年第二季度。Broadwell引入的改进主要如下。
新增RDSEED指令，可以读取基于热噪声（shermal noise）产生的
随机数。
引入对抗恶意软件的Supervisor Mode Access Prevention（SMAP）
技术，用于防止内核态恶意软件窃取用空间信息。
2.2.12 Skylake微架构
于2015年8月推出的代号为Skylake的第六代酷睿微架构引入了多项
新技术，是IA历史上的又一力作。其主要开发工作仍是在英特尔的以色
列研发中心完成的，用时4年之久。Skylake具有如下新特征。
旨在提高系统安全性的Intel MPX（Memory Protection Extensions）
技术。
允许应用程序产生私密内存区（称为enclave）的Intel
SGX（Software Guard Extensions）技术。
集成了第9代（Gen9）英特尔GPU，支持DirectX 12和完全的HEVC
编解码硬件加速。
强大的实时指令追踪（RTIT）技术，详见第5章。
老雷评点
在英特尔内部关于CPU研发的DTTC会议中，老雷首次听到
RTIT技术，认识了负责该技术的以色列同事，并与他们探讨了
关于调试支持的一些话题。
2.2.13 Kaby Lake微架构
英特尔原本计划接替Skylake的下一代产品是基于10nm工艺的
Cannonlake，但是遇到困难，作为弥补方案，于2017年年初推出了Kaby
Lake 微架构的第七代酷睿处理器。在作者撰写本书中的GPU内容时，
使用的笔记本电脑配备的是Kaby Lake处理器，内部的GPU是Gen 9.5。
本书中关于处理器的内容大多是针对以上描述的IA处理器的，但是
关于这些处理器的功能和结构的系统介绍远远超出了本书的范围。了解
IA处理器的一个极佳途径就是阅读英特尔公司的《英特尔64和IA-32架
构软件开发者手册》（《Intel 64 and IA-32 Intel®Architecture Software
Developer’s Manual》，以下简称《IA编程手册》）。该手册的目前版
本分为4卷10册。卷1《基本架构》介绍了基本执行环境、数据类型、指
令集概要、过程调用、中断和异常、一般编程和使用FPU、MMX、SSE
编程等内容。卷2《指令参考》分四册（卷2A、2B、2C和2D）按字母
顺序详细地介绍了每一条指令。卷3《系统编程指南》（卷3A、3B、3C
和3D）从更深的层次阐述了英特尔架构的关键特征，包括保护模式下
的内存管理、保护机制、中断和异常处理、任务管理、多处理器管理、
高级可编程中断控制器（APIC）、处理器管理和初始化、高速缓存管
理、MMX/SSE/SSE2系统编程、系统管理、MCA、调试和性能监控、
8086模拟、混合16位和32位代码，以及IA32兼容性等内容。最后一卷是
MSR寄存器的详细描述。感兴趣的读者可以从英特尔网站免费下载英特
尔架构手册的电子版本，也可以获取英特尔公司不定期免费提供的这些
手册的印刷版本。
老雷评点
《中庸》有言，“君子戒慎乎其所不睹，恐惧乎其所不
闻。”CPU者，软件之所由生、所由载也，严肃钻研软件者，曷
可忽乎哉！本节文字，看似散淡，实甚费心，望读者察之。
2.3 CPU的操作模式
英特尔公司于1978年推出的8086处理器是x86处理器的第一代产
品，其后的IA-32处理器都是在8086的基础上发展演变而来的。尽管今
天的IA-32处理器与20多年前的8086相比，功能上已经有天壤之别，但
是它们仍保持着对包括8086在内的低版本处理器的向下兼容性。因此，
今天的IA-32处理器仍然可以很好地执行多年前为8086处理器编写的软
件。那么，32位的IA-32处理器是如何执行16位的8086/80286程序的呢？
要回答这个问题，就要了解CPU的操作模式。我们可以把操作模式理解
为CPU的工作方式，在不同的操作模式下CPU按照不同的方式来工作，
目的是可以执行不同种类的程序、完成不同的任务。迄今为止，IA-32
处理器定义了图2-2所示的5种操作模式，分别介绍如下。
图2-2 CPU的操作模式（摘自《IA-32手册》卷3A）
（1）保护模式（Protected Mode）：所有IA-32处理器的本位
（native）模式，具有强大的虚拟内存支持和完善的任务保护机制，为
现代操作系统提供了良好的多任务（multitasking）运行环境。2.4节和
2.5节将进一步介绍与保护模式有关的重要概念。
（2）实地址模式（Real-address Mode）：简称实模式（Real
Mode），即模拟8086处理器的工作模式。工作在此模式下的IA-32处理
器相当于高速的8086处理器。实模式提供了一种简单的单任务环境，可
以直接访问物理内存和I/O空间，由于操作系统和应用软件运行在同一
个内存空间中和同一个优先级上，因此操作系统的数据很容易被应用软
件所破坏。DOS操作系统运行在实模式下。CPU在上电或复位后总是处
于实模式状态。
（3）虚拟8086模式（Virtual-8086 Mode）：保护模式下用来执行
8086任务（程序）的准模式（quasi-operating mode）。通过该模式，可
以把8086程序当作保护模式的一项任务来执行。实地址模式无疑为运行
8086程序提供了良好的硬件环境，但由于实地址模式无法运行现代的主
流操作系统，从保护模式切换到实模式来运行8086程序需要较大的开
销，难以实现。虚拟8086模式允许在不退出保护模式的情况下执行8086
程序，当CPU切换到一个8086任务时，它便以类似实模式的方式工作，
当CPU被切换到其他普通32位任务时，仍然以正常的方式工作，这样就
可以在一个操作系统下“同时”运行8086任务和普通的32位任务了。需要
注意的是，运行在虚拟8086模式下的8086任务在I/O访问方面会受到一
些限制，与运行在实模式下是有所不同的，但这是为了保证操作系统和
其他任务的安全所必需的。
（4）系统管理模式（System Management Mode，SMM）：供系统
固件（firmware）执行电源管理、安全检查或与平台相关的特殊任务。
当CPU的系统管理中断管脚（SMI#）被激活时，处理器会将当前正在
执行的任务的上下文保存起来，然后切换到另一个单独的（separate）
地址空间中执行专门的SMM例程。SMM例程通过RSM指令使处理器退
出SMM模式并恢复到响应系统管理中断前的状态。386 SL处理器最先
引入系统管理模式，其后的所有IA-32处理器都支持该模式。
（5）IA-32e模式：支持Intel 64的64位工作模式，曾经称为64位内
存扩展技术（Extended Memory 64 Technology，EM64T），是IA-32
CPU支持64位的一种扩展技术，具有对现有32位程序的良好兼容性。
IA-32e模式由两个子模式组成：64位模式和兼容模式。64位模式提供了
64位的线性寻址能力，并能够访问超过64GB的物理内存（32位下启用
PAE功能后最多访问64GB物理内存）。兼容模式用于执行现有的32位
应用程序，使它们不做任何改动就可以运行在64位操作系统上。对于运
行在IA-32e模式下的64位操作系统，系统内核和内核态的驱动程序一定
是64位的代码，工作在64位模式下，应用程序可以是32位的（在兼容模
式下执行），也可以是64位的（在64位模式下执行）。本书讨论的情况
除特别说明外不包括IA-32e模式。
处理器在上电开始运行时或复位后是处于实地址模式的，CR0控制
寄存器的PE（Protection Enable）标志用来控制处理器处于实地址模式
还是保护模式。标志寄存器（EFLAGS）的VM标志用来控制处理器是
在虚拟8086模式还是普通保护模式下，EFER寄存器（Extended-Feature-
Enable Register）的LME（Long Mode Enable）用来启用IA-32e模式。关
于模式切换的细节，感兴趣的读者可以参阅IA编程手册卷3A第9章中
的“模式切换”一节。
2.4 寄存器
寄存器（register）是位于CPU内部的高速存储单元，用来临时存放
计算过程中用到的操作数、结果、程序指针或其他信息。CPU可以直接
操作寄存器中的值，因此访问寄存器的速度比访问内存要快得多。
通用数据寄存器的宽度（size）决定了CPU可以直接表示的数据范
围。比如32位的数据寄存器可以直接表示的最大整数值为2321，这也意
味着采用32位寄存器的CPU单次计算支持的最大整数位数是32位。因
此，寄存器的宽度和个数的多少是CPU的最基本指标。我们通常所说的
CPU位数，比如16位CPU、32位CPU或64位CPU，指的就是CPU中通用
寄存器的位数（宽度）。
与RISC CPU相比，CISC CPU的通用寄存器数量是比较少的。x86
CPU定义的用于程序执行的基本寄存器共有16个，包括8个通用寄存
器、6个段寄存器、1个标志寄存器和1个程序指针寄存器（EIP）。随着
CPU功能的增加，IA-32 CPU逐渐加入了控制寄存器、调试寄存器、用
于浮点和向量计算的向量寄存器、性能监视的寄存器，以及与CPU型号
有关的MSR寄存器，下面我们先分别介绍32位下的各类寄存器，然后再
扩展到64位的情况。
2.4.1 通用数据寄存器
通用数据寄存器又称GPR（General Purpose Register），共有8个，
分别为EAX、EBX、ECX、EDX、ESP、EBP、ESI和EDI，每个的最大
宽度是32位。E代表Extended（扩展），因为这些寄存器的名字来源于
16位的x86处理器（8086、80286等），当时称为AX、BX等。其中
EAX、EBX、ECX和EDX可以按字节（比如AL、AH、BL、BH等）或
字（比如AX、BX等）来访问。
尽管GPR寄存器大多数时候是通用的，可以用作任何用途，但是在
某些情况下，它们也有特定的隐含用法。举例来说，在下面这条循环赋
值（串赋值）指令中，ESI和EDI分别指向源和目标，ECX用作计数器，
控制要复制的长度。
rep movs dword ptr es:[edi],dword ptr [esi]
CPU执行这条指令时，会自动调整ESI、EDI和ECX的值，循环执
行。著名的memcpy函数内部就使用了这条指令。类似地，memset函数
内部主要依靠的是下面这条串存储指令：
rep stos dword ptr es:[edi]
这条指令执行时，CPU会将EAX中的值写到EDI指向的内存，然后
调整EDI和ECX。值得一提的是，上面这两条串指令的机器码都只有两
个字节，分别是0xf3a5和0xf3ab。
 老雷评点 
上述指令反映了CISC指令集的优点——（对软件工程师而
言）易于编程，源程序可读性高，目标代码紧凑短小（节约空
间）。
EBP和ESP主要用来维护堆栈，ESP（Extended Stack Pointer）通常
指向栈的顶部，EBP（Extended Base Pointer）指向当前栈帧（frame）
的起始地址（base pointer的名字即由此而来）。值得注意的是，在包括
x86在内的很多CPU架构中，栈都是向下生长的，因此当向栈中压入数
据时，栈指针（ESP）的值会减小，而不是增大，我们将在第2卷中详
细地介绍栈。
2.4.2 标志寄存器
IA-32 CPU有一个32位的标志寄存器，名为EFLAGS（见图2-3）。
标志寄存器的作用相当于大型机时代的监视控制面板。每个标志位相当
于面板上的一个按钮或指示灯，分别用来切换CPU的工作参数或显示
CPU的状态。
图2-3 EFLAGS寄存器
EFLAGS寄存器包含3类标志：用于报告算术指令（如ADD、
SUB、MUL、DIV等）结果的状态标志（CF、PF、AF、ZF、SF、
OF）；控制字符串指令操作方向的控制标志（DF）；供系统软件执行
管理操作的系统标志。表2-1列出了EFLAGS寄存器中各个标志位的含
义。
表2-1 EFLAGS寄存器中各个标志位的含义
标  志
位
含  义
CF（Carry Flag） 0