sanitizer,”
https://github.com/google/kmsan.
2018,
2018,
2018,
[7] “Undefined
behavior
sanitizer,”
https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html.
[8] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley,
“Enhancing symbolic execution with veritesting,” in Pro-
ceedings of the 36th International Conference on Software
Engineering (ICSE), Hyderabad, India, May–Jun. 2014.
[9] R. Baldoni, E. Coppa, D. C. D’elia, C. Demetrescu, and
I. Finocchi, “A survey of symbolic execution techniques,”
ACM Computing Surveys (CSUR), vol. 51, no. 3, p. 50,
2018.
[10] R. Baldoni, E. Coppa, D. C. Dâ ˘A ´Zelia, C. Demetrescu,
and I. Finocchi, “A survey of symbolic execution tech-
niques,” ACM Computing Surveys (CSUR), vol. 51, no. 3,
pp. 1–39, 2018.
[11] C. Cadar, D. Dunbar, D. R. Engler et al., “Klee: Unassisted
and automatic generation of high-coverage tests for
complex systems programs.” in Proceedings of the 8th
USENIX Symposium on Operating Systems Design and
Implementation (OSDI), San Diego, CA, Dec. 2008.
[12] C. Cadar, V. Ganesh, P. Pawlowski, D. Dill, and D. Engler,
“Exe: A system for automatically generating inputs of
death using symbolic execution,” in Proceedings of the
13th ACM Conference on Computer and Communications
Security (CCS), Alexandria, VA, Oct.–Nov. 2006.
15
[13] C. Cadar and K. Sen, “Symbolic execution for software
testing: three decades later,” Communications of the ACM,
vol. 56, no. 2, pp. 82–90, 2013.
[14] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley,
“Unleashing mayhem on binary code,” in Proceedings
of the 33rd IEEE Symposium on Security and Privacy
(Oakland), San Francisco, CA, May 2012.
[15] V. Chipounov, V. Kuznetsov, and G. Candea, “S2e: A
platform for in-vivo multi-path analysis of software
systems,” Acm Sigplan Notices, vol. 46, no. 3, pp. 265–
278, 2011.
[16] J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili, S. Hao,
C. Kruegel, and G. Vigna, “Difuze: Interface aware
fuzzing for kernel drivers,” in Proceedings of the 24th
ACM Conference on Computer and Communications
Security (CCS), Dallas, TX, Oct.–Nov. 2017.
selective
[17] EPFL,
bolic
http://s2e.systems/docs/Howtos/Coverage/index.html.
“S2e:
execution
sym-
2018,
platform,”
The
[18] L.
“llvmlinux,”
https://wiki.linuxfoundation.org/llvmlinux.
Foundation,
2017,
[19] D. Gens, S. Schmitt, L. Davi, and A.-R. Sadeghi, “K-
miner: Uncovering memory corruption in linux,” in
Proceedings of the 2018 Annual Network and Distributed
System Security Symposium (NDSS), San Diego, CA, Feb.
2018.
[20] P. Godefroid, M. Y. Levin, and D. Molnar, “Sage:
whitebox fuzzing for security testing,” Queue, vol. 10,
no. 1, p. 20, 2012.
[21] I. Google, “ClusterFuzz: All Your Bug Are Belong to Us,”
2019, https://github.com/google/clusterfuzz.
[22] N. Group, “Triforce linux syscall
fuzzer,” 2016,
https://github.com/nccgroup/ TriforceLinuxSyscallFuzzer.
[23] I. Haller, A. Slowinska, M. Neugschwandtner, and H. Bos,
“Dowsing for overflows: A guided fuzzer to find buffer
boundary violations.” in Proceedings of the 22th USENIX
Security Symposium (Security), Washington, DC, Aug.
2013.
[24] H. Han and S. K. Cha, “Imf: Inferred model-based fuzzer,”
in Proceedings of the 24th ACM Conference on Computer
and Communications Security (CCS), Dallas, TX, Oct.–
Nov. 2017.
[25] Intel, 2016, https://lafintel.wordpress.com/2016/08/15/
circumventing-fuzzing-roadblocks-with-compiler-
transformations/.
[26] D. R. Jeong, K. Kim, B. Shivakumar, B. Lee, and I. Shin,
“Razzer: Finding kernel race bugs through fuzzing,” in
Proceedings of the 38th IEEE Symposium on Security and
Privacy (Oakland), San Francisco, CA, May 2019.
[27] D. Jones, “Trinity: Linux system call fuzzer,” 2011,
https://github.com/kernelslacker/trinity.
[28] S. Y. Kim, S. Lee, I. Yun, W. Xu, B. Lee, Y. Yun, and
T. Kim, “Cab-fuzz: practical concolic testing techniques
for cots operating systems,” in Proceedings of the 2017
USENIX Annual Technical Conference (ATC), Santa Clara,
CA, Jul. 2017.
[29] G. Klees, A. Ruef, B. Cooper, S. Wei, and M. Hicks,
“Evaluating fuzz testing,” in Proceedings of the 2018 ACM
SIGSAC Conference on Computer and Communications
Security. ACM, 2018, pp. 2123–2138.
[30] Y. Li, B. Chen, M. Chandramohan, S.-W. Lin, Y. Liu, and
A. Tiu, “Steelix: program-state based binary fuzzing,” in
Proceedings of the 16th European Software Engineering
Conference (ESEC) / 25th ACM SIGSOFT Symposium
on the Foundations of Software Engineering (FSE),
Paderborn, Germany, Sep. 2017.
[31] A. Machiry, C. Spensky, J. Corina, N. Stephens,
C. Kruegel, and G. Vigna, “Dr.checker: A soundy analysis
for linux kernel drivers,” in 26th USENIX Security
Symposium (USENIX Security 17), 2017, pp. 1007–1024.
[32] R. Majumdar and K. Sen, “Hybrid concolic testing,” in
Proceedings of the 29th International Conference on
Software Engineering (ICSE), Minneapolis, MN, May
2007.
[33] S. Pailoor, A. Aday, and S. Jana, “Moonshine: Optimiz-
ing os fuzzer seed selection with trace distillation,” in
Proceedings of the 27th USENIX Security Symposium
(Security), Baltimore, MD, USA, Aug. 2018.
[34] B. S. Pak, “Hybrid fuzz testing: Discovering software bugs
via fuzzing and symbolic execution,” School of Computer
Science Carnegie Mellon University, 2012.
[35] J. Pan, G. Yan, and X. Fan, “Digtool: A virtualization-
based framework for detecting kernel vulnerabilities,” in
26th USENIX Security Symposium (USENIX Security 17),
2017, pp. 149–165.
[36] H. Peng, Y. Shoshitaishvili, and M. Payer, “T-fuzz: fuzzing
by program transformation.” SP18.
[37] D. A. Ramos and D. R. Engler, “Under-constrained
symbolic execution: Correctness checking for real code.”
in Proceedings of the 24th USENIX Security Symposium
(Security), Washington, DC, Aug. 2015.
[38] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida,
and H. Bos, “Vuzzer: Application-aware evolutionary
fuzzing,” in Proceedings of the 2017 Annual Network
and Distributed System Security Symposium (NDSS), San
Diego, CA, Feb.–Mar. 2017.
[39] Rode0day, “Archived Results: Final Scores for Rode0day-
18.10,” 2018, https://rode0day.mit.edu/results/4.
[40] S. Schumilo, C. Aschermann, R. Gawlik, S. Schinzel,
and T. Holz, “kafl: Hardware-assisted feedback fuzzing
for os kernels,” in Proceedings of the 26th USENIX
Security Symposium (Security), Vancouver, BC, Canada,
Aug. 2017.
[41] K. Sen, D. Marinov, and G. Agha, “Cute: a concolic
unit testing engine for c,” in ACM SIGSOFT Software
Engineering Notes, vol. 30, no. 5. ACM, 2005, pp.
263–272.
[42] Y. Shoshitaishvili, C. Kruegel, G. Vigna, R. Wang, C. Salls,
N. Stephens, M. Polino, A. Dutcher, J. Grosen, S. Feng
et al., “Sok:(state of) the art of war: Offensive techniques
in binary analysis,” in Proceedings of the 37th IEEE
Symposium on Security and Privacy (Oakland), San Jose,
CA, May 2016.
[43] D. Song, F. Hetzelt, D. Das, C. Spensky, Y. Na, S. Vol-
ckaert, G. Vigna, C. Kruegel, J.-P. Seifert, and M. Franz,
“Periscope: An effective probing and fuzzing framework
for the hardware-os boundary,” in Proceedings of the
2019 Annual Network and Distributed System Security
Symposium (NDSS), San Diego, CA, Feb. 2019.
[44] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang,
J. Corbetta, Y. Shoshitaishvili, C. Kruegel, and G. Vigna,
“Driller: Augmenting fuzzing through selective symbolic
execution.” in Proceedings of the 2016 Annual Network
and Distributed System Security Symposium (NDSS), San
Diego, CA, Feb. 2016.
[45] Y. Sui and J. Xue, “Svf: interprocedural static value-flow
analysis in llvm,” in Proceedings of the 25th International
Conference on Compiler Construction. ACM, 2016.
[46] D.
Vyukov,
“Syzkaller,”
https://github.com/google/syzkaller.
2015,
[47] P. Wang, J. Krinke, K. Lu, G. Li, and S. Dodier-
Lazaro, “How double-fetch situations turn into double-
fetch vulnerabilities: A study of double fetches in the
linux kernel,” in 26th {USENIX} Security Symposium
({USENIX} Security 17), 2017, pp. 1–16.
[48] W. Wang, K. Lu, and P.-C. Yew, “Check it again: Detecting
lacking-recheck bugs in os kernels,” in Proceedings of
the 2018 ACM SIGSAC Conference on Computer and
Communications Security. ACM, 2018, pp. 1899–1913.
[49] V. M. Weaver and D. Jones, “perf fuzzer: Targeted fuzzing
of the perf event open () system call,” Technical Report
UMAINEVMW-TR-PERF-FUZZER, University of Maine,
Tech. Rep., 2015.
[50] M. Xu, C. Qian, K. Lu, M. Backes, and T. Kim, “Precise
and scalable detection of double-fetch bugs in os kernels,”
in 2018 IEEE Symposium on Security and Privacy (SP).
IEEE, 2018, pp. 661–678.
[51] I. Yun, S. Lee, M. Xu, Y. Jang, and T. Kim, “Qsym: a
practical concolic execution engine tailored for hybrid
fuzzing,” in Proceedings of the 27th USENIX Security
Symposium (Security), Baltimore, MD, USA, Aug. 2018.
2014,
Zalewsk,
fuzzy
[52] M.
“American
http://lcamtuf.coredump.cx/afl.
lop,”
[53] L. Zhao, Y. Duan, H. Yin, and J. Xuan, “Send hardest
problems my way: Probabilistic path prioritization for
hybrid fuzzing,” in Proceedings of the 2019 Annual
Network and Distributed System Security Symposium
(NDSS), San Diego, CA, Feb. 2019.
[54] Y. Zheng, A. Davanian, H. Yin, C. Song, H. Zhu, and
L. Sun, “Firm-afl: High-throughput greybox fuzzing of
iot firmware via augmented process emulation,” in 28th
USENIX Security Symposium (USENIX Security 19), 2019,
pp. 1099–1114.
APPENDIX
A. Static Dependency Analysis
Table VII presents the result of our static dependency
analysis. From the technical perspective, our approach to
static points-to analysis is brought from that of Razzer [26].
Specifically, we partition kernel source code according to
subsystem classification, and then separately perform the
analysis on each partition. Such a partitioning approach not
16
Category
File system
Network
Drivers
Analysis
Target
fs/
net/
drivers/
Size
(.bc)
75 MB
255 MB
322 MB
Analysis
Time (h)
# Candidate
Pairs
7
90
83
110 K
530 K
460 K
TABLE VII: The details of HFL static dependency analysis.
Category
File system
Network
Drivers
#Prog
4.6 M
5.1 M
5.0 M
#ProgS
1,526
2,121
2,034
#InputS
521
1,225
1,472
S
#Input′
343
632
851
TABLE VIII: The statistics of hybrid-specific feature in the experi-
ment (§VI-B3). Prog and ProgS denote concretely and symbolically
executed programs during the experiment, respectively. InputS are
new input programs produced as a result of the execution of ProgS.
Of which, Input′
S are the ones actually contributing new execution
path.
only allows us to alleviate significant analysis overhead, but fits
each partition into each syscall category properly. Considering
these factors, we believe this effectively identifies potential
dependencies that suit our purpose although it may lead to
false negative outcomes due to missing dependencies across
partitions. Since such analysis is one time task in our work,
we note its non-trivial overhead does not affect the overall
performance of HFL.
B. Statistics of Hybrid-Fuzzing
In Table VIII, we illustrate more detailed analysis of the
hybrid-specific feature in the coverage experiment (§VI-B3). In
the table, Prog and ProgS indicate concretely and symbolically
executed programs, respectively. InputS in the fourth column
represents input programs that are newly generated as a result
of symbolic execution. One notable observation is that out of
symbolically executed programs (ProgS), non-negligible cases
do not yield new inputs although they are supposed to trigger
tight branches on the particular path. This is mostly caused by
non-deterministic states of internal kernel instances which are
not under our control. In the fifth and sixth columns, as expected,
the new input programs (InputS) not only contribute new code
paths (i.e., Input′
S), but also have significant influence on the
future input generation, then lead to coverage improvement.
This stems from that such new inputs would be pushed into
the corpus and reused as a source of mutation, thereby helping
trigger other new paths.
Crash type
Description
integer overflow
integer overflow
integer overflow
task hang
task hang
task hang
task hang
task hang
task hang
task hang
task hang
task hang
task hang
kernel BUG at fs/xfs/xfs_message.c
kernel BUG at fs/btrfs/ctree.c
kernel BUG at net/core/skbuff.c
Undefined behaviour in fs/open.c
WARNING in __alloc_pages_slowpath
task hung in truncate_inode_pages_range
WARNING in __ext4_handle_dirty_metadata
WARNING in usb_submit_urb
unable to handle kernel paging request in alloc_vmap_area
Undefined behaviour in net/core/sock.c
task hung in blk_mq_get_tag
task hung in __fdget_pos
task hung in __flush_work
TABLE IX: List of 13 known vulnerabilities.
Kernel
4.19-rc8
4.17.19
4.19-rc8
5.0-rc2
4.18.20
4.20.0
4.19-rc2
4.19-rc2
4.18-rc4
4.20.2
4.17.19
4.17.19
5.0-rc2
Component
Tool
Lines of Code
Fuzzer
Symbolic Analyzer
Kernel Translator
Coordinator
syzkaller
s2e-2.0
gcc-7.3
-
840 (Go)
420 (C++)
820 (C)
480 (Python)
TABLE X: Modifications of the tools used in HFL. Note that
coordinator acts as a glue in communcation between fuzzer and
symbolic analyzer (e.g., user program transformation).
17