int y = 0377L;
int z = 0x7fffL;
如果希望指定为⽆符号整数 ，可以使⽤后缀 或 。
unsigned int u U
int x = 123U;
和 可以结合使⽤，表示 类型。 和 的⼤⼩写和组合顺序⽆所谓。
L U unsigned long L U
int x = 123LU;
对于浮点数，编译器默认指定为 double 类型，如果希望指定为其他类型，需要在⼩数后⾯添加后缀
f
（float）或 （long double）。
l
科学计数法也可以使⽤后缀。
1.2345e+10F
1.2345e+10L
总结⼀下，常⽤的字⾯量后缀有下⾯这些。
和 ： 类型。
f F float
和 ：对于整数是 类型，对于⼩数是 类型。
l L long int long double
和 ：Long Long 类型，⽐如 。
ll LL 3LL
和 ：表示 ，⽐如 、 。
u U unsigned int 15U 0377U
还可以与其他整数后缀结合，放在前⾯或后⾯都可以，⽐如 、 和 都是合法的。
u 10UL 10ULL 10LLU
下⾯是⼀些示例。
int x = 1234;
long int x = 1234L;
long long int x = 1234LL
unsigned int x = 1234U;
unsigned long int x = 1234UL;
unsigned long long int x = 1234ULL;
float x = 3.14f;
double x = 3.14;
long double x = 3.14L;
溢出 #
每⼀种数据类型都有数值范围，如果存放的数值超出了这个范围（⼩于最⼩值或⼤于最⼤值），需要更多
的⼆进制位存储，就会发⽣溢出。⼤于最⼤值，叫做向上溢出（overflow）；⼩于最⼩值，叫做向下溢出
（underflow）。
⼀般来说，编译器不会对溢出报错，会正常执⾏代码，但是会忽略多出来的⼆进制位，只保留剩下的位，
这样往往会得到意想不到的结果。所以，应该避免溢出。
unsigned char x = 255;
x = x + 1;
printf("%d\n", x);
上⾯示例中，变量 加 ，得到的结果不是 ，⽽是 。因为 是 类型，最⼤值是
x 1 256 0 x unsign char
（⼆进制 ），加 后就发⽣了溢出， （⼆进制 ）的最⾼位 被丢弃，剩
255 11111111 1 256 100000000 1
下的值就是 。
0
再看下⾯的例⼦。
unsigned int ui = UINT_MAX;
ui++;
printf("ui = %u\n", ui);
ui--;
printf("ui = %u\n", ui);
上⾯示例中，常量 是 unsigned int 类型的最⼤值。如果加 ，对于该类型就会溢出，从⽽得
UINT_MAX 1
到 ；⽽ 是该类型的最⼩值，再减 ，⼜会得到 。
0 0 1 UINT_MAX
溢出很容易被忽视，编译器⼜不会报错，所以必须⾮常⼩⼼。
for (unsigned int i = n; i >= 0; --i)
上⾯代码表⾯看似乎没有问题，但是循环变量 的类型是 unsigned int，这个类型的最⼩值是 ，不可
i 0
能得到⼩于 0 的结果。当 等于 0，再减去 的时候，并不会返回 ，⽽是返回 unsigned int 的类型
i 1 -1
最⼤值，这个值总是⼤于等于 ，导致⽆限循环。
0
为了避免溢出，最好⽅法就是将运算结果与类型的极限值进⾏⽐较。
unsigned int ui;
unsigned int sum;
if (sum + ui > UINT_MAX) too_big();
else sum = sum + ui;
if (ui > UINT_MAX - sum) too_big();
else sum = sum + ui;
上⾯示例中，变量 和 都是 unsigned int 类型，它们相加的和还是 unsigned int 类型，这就有可
sum ui
能发⽣溢出。但是，不能通过相加的和是否超出了最⼤值 ，来判断是否发⽣了溢出，因为
UINT_MAX sum +
总是返回溢出后的结果，不可能⼤于 。正确的⽐较⽅法是，判断 与 之间
ui UINT_MAX UINT_MAX - sum ui
的⼤⼩关系。
下⾯是另⼀种错误的写法。
unsigned int i = 5;
unsigned int j = 7;
if (i - j  i)
sizeof 运算符 #
是 C 语⾔提供的⼀个运算符，返回某种数据类型或某个值占⽤的字节数量。它的参数可以是数据
sizeof
类型的关键字，也可以是变量名或某个具体的值。
int x = sizeof(int);
int i;
sizeof(i);
sizeof(3.14);
上⾯的第⼀个示例，返回得到 类型占⽤的字节数量（通常是 或 ）。第⼆个示例返回整数变量占
int 4 8
⽤字节数量，结果与前⼀个示例完全⼀样。第三个示例返回浮点数 占⽤的字节数量，由于浮点数的字
3.14
⾯量⼀律存储为 double 类型，所以会返回 ，因为 double 类型占⽤的 8 个字节。
8
运算符的返回值，C 语⾔只规定是⽆符号整数，并没有规定具体的类型，⽽是留给系统⾃⼰去决
sizeof
定， 到底返回什么类型。不同的系统中，返回值的类型有可能是 ，也有可能是
sizeof unsigned int
，甚⾄是 ，对应的 占位符分别是 、 和 。这样
unsigned long unsigned long long printf() %u %lu %llu
不利于程序的可移植性。
C 语⾔提供了⼀个解决⽅法，创造了⼀个类型别名 ，⽤来统⼀表示 的返回值类型。该别名
size_t sizeof
定义在 头⽂件（引⼊ 时会⾃动引⼊）⾥⾯，对应当前系统的 的返回值类型，可
stddef.h stdio.h sizeof
能是 ，也可能是 。
unsigned int unsigned long
C 语⾔还提供了⼀个常量 ，表示 可以表示的最⼤整数。所以， 能够表示的整数
SIZE_MAX size_t size_t
范围为 。
[0, SIZE_MAX]
有专⻔的占位符 或 ，⽤来处理 类型的值。
printf() %zd %zu size_t
printf("%zd\n", sizeof(int));
上⾯代码中，不管 返回值的类型是什么， 占位符（或 ）都可以正确输出。
sizeof %zd %zu
如果当前系统不⽀持 或 ，可使⽤ （unsigned int）或 （unsigned long int）代替。
%zd %zu %u %lu
类型的⾃动转换 #
某些情况下，C 语⾔会⾃动转换某个值的类型。
赋值运算 #
赋值运算符会⾃动将右边的值，转成左边变量的类型。
（1）浮点数赋值给整数变量
浮点数赋予整数变量时，C 语⾔直接丢弃⼩数部分，⽽不是四舍五⼊。
int x = 3.14;
上⾯示例中，变量 是整数类型，赋给它的值是⼀个浮点数。编译器会⾃动把 先转为 类型，丢
x 3.14 int
弃⼩数部分，再赋值给 ，因此 的值是 。
x x 3
这种⾃动转换会导致部分数据的丢失（ 丢失了⼩数部分），所以最好不要跨类型赋值，尽量保证变量
3.14
与所要赋予的值是同⼀个类型。
注意，舍弃⼩数部分时，不是四舍五⼊，⽽是整个舍弃。
int x = 12.99;
上⾯示例中， 等于 ，⽽不是四舍五⼊的 。
x 12 13
（2）整数赋值给浮点数变量
整数赋值给浮点数变量时，会⾃动转为浮点数。
float y = 12 * 2;
上⾯示例中，变量 的值不是 ，⽽是 ，因为等号右边的整数⾃动转为了浮点数。
y 24 24.0
（3）窄类型赋值给宽类型
字节宽度较⼩的整数类型，赋值给字节宽度较⼤的整数变量时，会发⽣类型提升，即窄类型⾃动转为宽类
型。
⽐如， 或 类型赋值给 类型，会⾃动提升为 。
char short int int
char x = 10;
int i = x + y;
上⾯示例中，变量 的类型是 ，由于赋值给 类型，所以会⾃动提升为 。
x char int int
（4）宽类型赋值给窄类型
字节宽度较⼤的类型，赋值给字节宽度较⼩的变量时，会发⽣类型降级，⾃动转为后者的类型。这时可能
会发⽣截值（truncation），系统会⾃动截去多余的⼆进制位，导致难以预料的结果。
int i = 321;
char ch = i;
上⾯例⼦中，变量 是 类型，宽度是 8 个⼆进制位。变量 是 类型，将 赋值给 ，后
ch char i int i ch
者只能容纳 （⼆进制形式为 ，共 9 位）的后⼋位，前⾯多出来的⼆进制位被丢弃，保留后⼋
i 101000001
位就变成了 （⼗进制的 65，相当于字符 ）。
01000001 A
浮点数赋值给整数类型的值，也会发⽣截值，浮点数的⼩数部分会被截去。
double pi = 3.14159;
int i = pi;
上⾯示例中， 等于 ， 的⼩数部分被截去了。
i 3 pi
混合类型的运算 #
不同类型的值进⾏混合计算时，必须先转成同⼀个类型，才能进⾏计算。转换规则如下：
（1）整数与浮点数混合运算时，整数转为浮点数类型，与另⼀个运算数类型相同。
3 + 1.2
上⾯示例是 类型与 类型的混合计算， 类型的 会先转成 的 ，再进⾏计算，
int float int 3 float 3.0
得到 。
4.2
（2）不同的浮点数类型混合运算时，宽度较⼩的类型转为宽度较⼤的类型，⽐如 转为 ，
float double
转为 。
double long double
（3）不同的整数类型混合运算时，宽度较⼩的类型会提升为宽度较⼤的类型。⽐如 转为 ，
short int
转为 等，有时还会将带符号的类型 转为⽆符号 。
int long signed unsigned
下⾯例⼦的执⾏结果，可能会出⼈意料。
int a = -5;
if (a  300) do_something();
上⾯示例中，表达式 和 都会⾃动转为 int 类型，所以函数 会执⾏两次。
a - 5 b + c do_something()
函数 #
函数的参数和返回值，会⾃动转成函数定义⾥指定的类型。
int dostuff(int, unsigned char);
char m = 42;
unsigned short n = 43;
long long int c = dostuff(a, b);
上⾯示例中，参数变量 和 不管原来的类型是什么，都会转成函数 定义的参数类型。
a b dostuff()
下⾯是返回值⾃动转换类型的例⼦。
char func(void) {
int a = 42;
return a;
}
上⾯示例中，函数内部的变量 是 类型，但是返回的值是 类型，因为函数定义中返回的是这个
a int char
类型。
类型的显式转换 #
原则上，应该避免类型的⾃动转换，防⽌出现意料之外的结果。C 语⾔提供了类型的显式转换，允许⼿动
转换类型。
只要在⼀个值或变量的前⾯，使⽤圆括号指定类型 ，就可以将这个值或变量转为指定的类型，这叫
(type)
做 “类型指定”（casting）。
(unsigned char) ch
上⾯示例将变量 转成⽆符号的字符类型。
ch
long int y = (long int) 10 + 12;
上⾯示例中， 将 显式转为 类型。这⾥的显示转换其实是不必要的，因为赋值运