Caches are only vulnerable to CPDoS attacks if they store and reuse
error pages. Web caching systems such as Stackpath, CDNSun,
KeyCDN and G-Core labs cannot be affected by CPDoS attacks,
since these CDNs do not cache error messages at all. This is also
true for Apache HTTPD, Nginx and Squid when using them as an
intermediate cache without involving any other vulnerable web
caching systems.
As with other cache poisoning vulnerabilities, CPDoS attacks
are only possible when a vulnerable web caching system does not
contain a fresh copy of the to be attacked resource. That is, if a
shared cache still maintains and reuses a stored fresh response for
recurring requests, a malicious request is not able to poison the
intermediary. The web caching system serves all requests to the
target resource. None of the requests are forwarded to the origin
server until the freshness lifetime is expired, so that no error page
can be triggered. This means if a cache still owns a fresh response,
an attacker has to wait until the cached content is stale. The most
straightforward information to find out the expiration time is the
Expires header which indicates the absolute expiration date. If the
response does not contain an Expires header or the expiration time
of this header is overridden by the max-age or s-maxage directive
control directive, the attacker can make use of the Age header. The
Age header declares the seconds of stay in the cache. The value of the
Age header subtracted from the value of the max-age or s-maxage
directive is the relative expiration time of the cached response. If
the cached response is expired, the attackerâ€™s request must be the
very first request so that it can reach the origin server to trigger
an error page. To increase the likelihood for being the first request,
we send automatized requests with a one second interval when the
response is close to expire. With this technique we were able to
successfully attack all twelve vulnerable websites of our spot check
experiment. Sending regularly performed requests with one second
distance of time is also a useful approach for cached responses
which does contain any expiration time information, i.e., resources
which are implicitly cached. Such responses usually do not contain
any max-age or s-maxage directives and Expire headers. Here,
the attacker needs to send automatized requests until one of the
requests is forwarded to the origin server. Moreover, automatized
requests with a one second interval are not considered as harmful
even when they are sent over a long time, since health checks
requests can also have the same interval. We tested this technique
on several CDNs which also included WAFs and DDoS protections.
Since we only used a single client to perform the attack, none of
CDNs detected the malicious requests.
Many web applications configure the proxy cache or the CDN
to serve the whole website. This means all resources including dy-
namic pages and static files are forwarded and processed by the
cache. To exclude dynamic pages from being implicitly cached,
content providers include no-store or max-age=0 to the response
header, so that each request must be forwarded to the origin server.
If a vulnerable cache in conjunction with a vulnerable server-side
HTTP implementation is used, these resources can be attacked with-
out the need to wait and any automation of sending requests. One
single malicious request is enough to paralyze the target resource,
since each request is forwarded to the origin server. Vulnerable
websites which configure the CDN to serve all resources are, e.g.,
marines.com, ethereum.org and nasa.gov.
There also many web applications which only configure the
cache to store and reuses responses of certain URL paths such as for
static files in the javascript or images directory. Other URL paths
are accordingly not cached at all. Many content providers also
maintain subdomains (e.g. static.example.org) or a specific domain
for static files which are served via a cache. In these cases, only
resources within the cached URL paths or the specific domain can be
affected. To find out whether a distinct response traverses a cache,
an attacker can inspect the response headers. For instance, the Age
response header indicate that a cache is utilized. The main website
of IKEA (ikea.com) does not use CloudFront or any other vulnerable
HTTP implementations which indicates that this homepage is most
likely not vulnerable to CPDoS attacks. However, IKEA uses a
specific domain (fw.ota.homesmart.ikea.net) in conjunction with
CloudFront to host the update files of their Internet of Things
devices.
Another important limitation of CPDoS attacks is that the web
caching systems except Fastly do only cache error pages for few
minutes or seconds. Fastly stores and reuses the error page for one
hour. If this time span is over, then the first benign request to the
target resource is forwarded to origin server and refreshed again.
Still, to extend the duration of CPDoS attacks, malicious clients can
resend harmful requests in accordance to the fixed interval.
6 RESPONSIBLE DISCLOSURE
All discovered vulnerabilities have been reported to the HTTP
implementation vendors and cache providers on February 19, 2019.
We worked closely with these organizations to support them in
eliminating the detected threats. We did not notify the website
owners directly, but left it to the contacted entities to inform their
customers.
Amazon Web Services (AWS). We reported this issue to the AWS-
Security team. They confirmed the vulnerabilities on CloudFront.
The AWS-Security team stopped caching error pages with the status
code 400 Bad Request by default. However, they took over three
months to fix our CPDoS reportings. Unfortunately, the overall
disclosure process was characterized by a one-way communica-
tion. We periodically asked for the current state, without getting
much information back from the AWS-Security team. They never
contacted us to keep us up to date with the current process. For
11
example, we only got noticed about the changed default caching
policy by checking back the revision history of their respective
documentation hosted in Github. Thus, we do not have much in-
formation on the noticeable amount of time required to resolve
our reported CPDoS vulnerability, although having asked for it
explicitly. We can only assume that this delay has to do with the
large number of affected users they had to test after implementing
according countermeasures. Moreover, Amazon suggests users to
deploy an AWS WAF in front of the corresponding CloudFront
instance. AWS WAF allows defining rules which drop malicious
requests before they reach the origin server.
Microsoft. Microsoft was able to reproduce the reported issues and
published an update to mitigate this vulnerability. They assigned
this case to CVE-2019-0941 [27] which is published in June 2019.
Play 1. The developers of the Play 1 confirmed the reported issues
and provided a security patch which limits the impact of the X-
HTTP-Method-Override header [6]. The security patch is included
in the versions 1.5.3 and 1.4.6. Older version are not maintained by
this security patch. Web applications which use older versions of
Play 1 therefore should update to the newest versions in order to
mitigate CPDoS attacks.
Flask. We reported the HMO attack to the developer team of Flask
multiple times. Unfortunately, we have not received any answer
form them so far and hence we have to assume, that Flask-based
web applications are still vulnerable to CPDoS.
7 DISCUSSION
Using malformed requests to damage web applications is a well-
known threat. Request header size limits and blocking meta charac-
ters are therefore vital means of protection to avoid known cache
poisoning attacks as well as other DoS attacks such as request
header buffer flow [26] and ReDoS [38]. Also, many security guide-
lines such as the documentation of Apache HTTPD [2], OWASP
[35], and the HTTP standard [12] recommend to block oversized
headers and meta characters in headers. CPDoS attacks, however,
aims to beat these security mechanisms with their own weapons.
HHO and HMC CPDoS attacks intentionally send a request with
an oversized header or harmful meta character with the intent to
get blocked by an error page which will be cached. Along these
lines, it is interesting to see that CDN services, which claim to be
an effective measure to defeat DoS and especially DDoS attacks,
desperately fail when it comes to CPDoS.
According to our experiment results, most of the presented at-
tack vectors are only feasible when CloudFront is deployed as the
underlying CDN, since it is the only analyzed cache which illicitly
stores the error code 400 Bad Request. Such a non-conformance
is the main reason for the HHO and HMC attacks. The other major
issue for both attacks is fact that the cache forwards oversized head-
ers and requests with harmful meta characters. Violations of the
HTTP standard and implementation issues are also the main rea-
son for many other cache-related vulnerabilities including request
smuggling, host of troubles, response splitting, and web deception
attacks. The HMO CPDoS attack is, however, a vulnerability which
does not exploit any implementation issues and violations of the
HTTP standard. The X-HTTP-Method-Override header or similar
12
headers are legitimate auxiliaries to tunnel HTTP methods which
are not supported by WAFs or web browsers. Play 1 and Flask re-
turns the error code 404 Not Found or 405 Method Not Allowed
when an unsupported action in X-HTTP-Method-Override header
is received. Both error messages are allowed to be cached according
to RFC 7231. Akamai, CDN77, Fastly, Cloudflare, CloudFront, and
Varnish follow this policy and cache such error codes. If these web
caching systems are used in combination with one of the mentioned
web frameworks, these combinations have an actual risk of falling
victim to CDPoS attacks, even though they are in conformance with
the HTTP standard and do not have any implementation issues.
Therefore, the HMO CPDoS attack can be considered as a new kind
of cache poisoning attack which does not exploit any implementa-
tion issues or RFC violations. This shows that CPDoS attacks do
not always result from programming mistakes or unintentional
violations of specification policies, but can also be the exploit of
the conflict between two legitimate concepts. In case of HMO CP-
DoS attacks, this conflict refers to the usage of method overriding
headers and the caching of allowed error messages.
Even though we did not detect attack vectors in other web
caching systems and HTTP implementations, this does not mean
that other constellations are not vulnerable to CPDoS attacks. As
shown by Table 1 eight of fifteen tested web caching systems do
store error pages and some of them even cache error pages which
are not allowed. If an attacker is able to initiate other error pages
or even cacheable error code at the target URL, then she may af-
fect other web caching systems and HTTP implementations with
CPDoS attacks as well. James Kettle, for instance, discovered two
other forms of CPDoS attacks which fortunately are only successful
due to specific implementation issues of the corresponding web
application. The first CPDoS attack utilized the X-Forwarded-Port
header [21]. This header usually informs the endpoint about the
port that the client uses to connect to the intermediate system,
which operates in front of the origin server. In the revealed attack,
the cached response contained the redirect. A DoS was caused by
the userâ€™s browser trying to follow the cached redirect and timing
out. The second attack was able to create a DoS at www.tesla.com
due to a faulty WAF configuration [20]. Tesla configured their WAF
to block certain strings which have been used by other cache poison
attacks. Unfortunately, requests with such strings were blocked by a
403 Forbidden error page which was also cached. This shows that
HMO, HHO, and HMC are not the only variations of CPDoS attacks.
There are, certainly, many other ways to provoke an error page on
the origin server. To the best of our knowledge and according to
our experiences in developing web applications, it is not unlikely
to provoke an 500 Internal Server Error status code or other
5xx errors in real world web applications and services. Akamai and
Cloudflare do cache 5xx error codes. At this point, we did not find
a way to provoke such error messages in our experiments.
Moreover, we need to consider that contemporary web appli-
cations and distributed systems in particular are usually layered.
That is, they often utilize other intermediate components such as
load balancer, WAFs or other security gateways which are located
between cache and endpoint. Such middleboxes or middleware
may provide other request header size limits, meta character han-
dling or header overriding features. Such systems may also react to
malicious requests with error codes that could be cached.
8 COUNTERMEASURES
The most intuitive, as well as effective countermeasure, against CP-
DoS attacks is to exclude error pages from being cached. However,
content providers which exclude cacheable error codes such as 404
Not Found from being stored, need to consider that this setting
may impair the performance and scalability. There two ways to
exclude error pages from being cached. The first approach is to
configure the web caching systems to omit the storage of error
responses. Akamai, CDN77, CloudFront, CloudFront, Fastly, and
Varnish provide options to do so. Content providers can also add the
no-store directive to the Cache-Control response header which
prohibits all caches from storing the content. According to our own
evaluation, all tested web caching systems except CloudFront hon-
ored the keyword no-store in error pages and still do so. At the
time of our experiments in February 2019, CloudFront cached error
pages for five minutes by default and even did so when no-store
was included in the error response header. The only way to avoid
storing error pages in CloudFront was to disable each error code
from caching via the CDNâ€™s configuration interface. Fortunately,
AWS changed the behavior of caching error pages after our CPDoS
reporting. One important change is that 400 Bad Request error
pages are not cached by default anymore. CloudFront only caches
400 Bad Request error messages if they include a max-age or
s-maxage control directive [1].
As mentioned before, the disobey of the HTTP standard in terms
of ignoring control directives is the main cause for many cache-
related vulnerabilities. Beside the consideration of cache-related
control directives, web caching systems must, therefore, only store
error codes which are permitted by the HTTP standard. Status codes
such as 400 Bad Request are not allowed to be cached, since this
error message is only dedicated to a request which is malformed or
invalid. Other error codes such as 404 Not Found, 405 Method Not
Allowed or 410 Gone can be cached, since they provide error infor-
mation which is valid for all clients. Also, HTTP implementations
have to use the appropriate status code for the corresponding error
case. Table 3 shows that almost all tested system return the status
code 400 Bad Request for an oversized request header. IIS even
replies with status the cacheable 404 Not Found error code when a
limit for a specific request header is exceeded. Both error messages
are not the appropriate one for requests exceeding the header size
limit. According to HTTP standard, the appropriate error code is
431 Request Header Fields Too Large. Such error information
is not stored and reused by any of the tested web caching systems.
To test the compliance and behavior of caches, we recommend to
use the cache testing tool of Nguyen et al. [31] or Mark Nottingham
[33].
Another very effective countermeasure against CPDoS attacks is
the usage of WAFs. Many CDNs provide the option to enable WAFs
in order to protect web applications against malicious requests. To
avoid CPDoS attacks, content providers can configure the WAF to
explicitly block oversized requests, requests with meta characters
or malicious headers. Using WAFs is, however, only effective if the
WAF is implemented in the cache or in front of the cache, so that
harmful requests can be eliminated before they are forwarded to the
origin server. The experiments in Section 5 and the CPDoS attack
of James Kettle on www.tesla.com [20] show that WAFs which are
integrated at the origin server such as ModSecurity do not help
against CPDoS attacks. Requests which are blocked by a WAFs at
the origin can still trigger an error page that is stored by the cache.
Moreover, we recommend adding a subsection to the "Security
Considerations" section of the RFC 7230 [12] to discuss the con-
sequences of non-compliance with the protocol specification in
order to avoid HHO, HMC and other web cache poisoning attacks.
The "Security Considerations" section of RFC 7230 mentions cache-
poisoning attacks including response splitting and request smug-
gling. However, the standard only makes recommendations that
relate to these two specific attacks. The specification does not men-
tion that the source of many cache-related attacks lies in violations
of the standard. Such an additional description would increase de-
velopersâ€™ awareness of compliance with the specifications. HMO
attacks, on the other hand, cannot be avoided by complying with
the standard, as they are based on non-standard means which is
the X-HTTP-Method-Override header in this case. To avoid HMO
attacks while maintaining the scalability, content providers do not
need to exclude the 404 Not Found and 405 Method Not Allowed
error code from caching. Here, vulnerable web frameworks must
follow the approach of Symfony, Lavarel as well as the plugins of
Django and Express.js. These HTTP implementations support the
method overriding headers, but only consider to change the action
when the method in the request line is POST. By this, a 404 Not
Found error page cannot be triggered by malicious GET request,
since method overriding headers are ignored. When trying to poi-
son the cache with a POST request with a method override header
including GET, the returning response is not stored by any tested
cache. Also, the use of non-standard headers is a general approach
to conduct other cache-poisoning attacks as described by James
Kettle [22]. It is the responsibility of HTTP implementations to
carefully integrate non-standard headers to avoid such attacks. To
analyze impact of standardized or non-standard headers in respect
to caches, developers and software testers can use, e.g., the testing
tools of Nguyen et al. [31] and Mark Nottingham [33].
9 CONCLUSION AND OUTLOOK
Vulnerabilities stemming from the semantic gap result in serious
security threats. Distributed systems are especially prone to such
attacks as they are composed by distinct layers. Their existence is
one major prerequisite for the different interpretation of an object,
in this case the application messages floating through the interme-
diaries.
In this paper we extended the known vulnerabilities rooted
in a semantic gap by introducing a class of new attacks, "Cache-
Poisoned Denial-of-Service (CPDoS)". We systematically study how
to provoke errors during request processing on an origin server
and the case, in which error responses get stored and distributed
by caching systems. We introduce three concrete CPDoS attack
variations that are caused by the inconsistent treatment of the
HTTP method override header, header size limits and the parsing
of meta characters. We show the practical relevance by identifying
the amount of available web caching systems that are vulnerable to
CPDoS. The consequences can be severe as one simple request is
sufficient to paralyze a victim website within a large geographical
region (see Figure 8 in Appendix B). Depending on the resource
13
[18] Suman Jana and Vitaly Shmatikov. 2012. Abusing File Processing in Malware
Detectors for Fun and Profit. In 33rd IEEE Symposium on Security and Privacy.
80â€“94. https://doi.org/10.1109/SP.2012.15
[19] Y. Jia, Y. Chen, X. Dong, P. Saxena, J. Mao, and Z. Liang. 2015. Man-in-the-
browser-cache. Computers and Security 55, C (2015), 62â€“80. https://doi.org/10.
1016/j.cose.2015.07.004
https:
[20] J. Kettle. 2018. Bypassing Web Cache Poisoning Countermeasures.
//portswigger.net/blog/practical-web-cache-poisoning
[21] J. Kettle. 2018. Denial of service via cache poisoning . https://hackerone.com/
reports/409370
//portswigger.net/blog/practical-web-cache-poisoning
[22] J. Kettle. 2018. Practical Web Cache Poisoning. In Blackhat USA.
[23] A. Klein. 2004. Divide and Conquer - HTTP Response Splitting, Web Cache
https:
Poisoning Attacks, and Related Topics. White Paper. Sanctum, Inc.
//dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf
[24] C. Linhart, A. Klein, R. Heled, and S. Orrin. 2005. HTTP REQUEST SMUGGLING.
https:
http://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf
IETF. https://tools.ietf.org/html/rfc2324
[25] L. Masinter. 1998. Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0). RFC 2324.
[26] NATIONAL VULNERABILITY DATABASE. 2010. CVE-2010-2730 Detail. CVE
[27] NATIONAL VULNERABILITY DATABASE. 2019. CVE-2019-0941 Detail. CVE
[28] Netcraft. 2019. January 2019 Web Server Survey. https://news.netcraft.com/
2010-2730. Nist. https://nvd.nist.gov/vuln/detail/CVE-2010-2730
2019-0941. Nist. https://nvd.nist.gov/vuln/detail/CVE-2019-0941
archives/2019/01/24/january-2019-web-server-survey.html
[29] S. Newman. 2015. Building microservices: designing fine-grained systems. Oâ€™Reilly.
[30] H. V. Nguyen, L. Lo Iacono, and H. Federrath. 2018. Systematic Analysis of Web
Browser Caches. In 2nd International Conference on Web Studies (WS). https:
//doi.org/10.1145/3240431.3240443
[31] H. V. Nguyen, L. Lo Iacono, and H. Federrath. 2019. Mind the Cache: Large-Scale
Analysis of Web Caching. In 34rd ACM/SIGAPP Symposium on Applied Computing
(SAC). https://doi.org/10.1145/3297280.3297526
[32] H. Nielsen and S. Lawrence. 2000. An HTTP Extension Framework. RFC 2774.
IETF. https://tools.ietf.org/html/rfc2774
[33] M. Nottingham. 2019. HTTP Caching Tests. https://cache-tests.fyi/
[34] M. Nottingham and R. Fielding. 2012. Additional HTTP Status Codes. RFC 6585.
[35] OWASP. 2017. Denial of Service Cheat Sheet. https://www.owasp.org/index.
IETF. https://tools.ietf.org/html/rfc6585
php/Denial_of_Service_Cheat_Sheet#Mitigation_3:_Limit_length_and_size
[36] L. Richardson and S. Ruby. 2008. RESTful web services. Oâ€™Reilly Media, Inc.
[37] J. Somorovsky, M. Heiderich, M. Jensen, J. Schwenk, N. Gruschka, and L. Lo Iacono.
2011. All Your Clouds Are Belong to Us: Security Analysis of Cloud Management
Interfaces. In 3rd ACM Workshop on Cloud Computing Security Workshop. ACM,
New York, NY, USA, 3â€“14. https://doi.org/10.1145/2046660.2046664 http://doi.
acm.org/10.1145/2046660.2046664.
[38] C.-A. Staicu and M.l Pradel. 2018. Freezing the Web: A Study of ReDoS Vulnera-
bilities in Javascript-based Web Servers. In 27th USENIX Conference on Security
Symposium (USENIX Security). USENIX Association, Berkeley, CA, USA, 361â€“376.
http://dl.acm.org/citation.cfm?id=3277203.3277231
[39] S. Triukosea, Z. Al-Qudad, and M. Rabinovich. 2009. Content Delivery Networks:
Protection or Threat?. In 14th European Symposium on Research in Computer
Security (ESORICS). https://doi.org/10.1007/978-3-642-04444-1_23
that is being blocked by an error page, the web page or web service
can be disabled piecemeal (see Figure 6 in Appendix A).
According to our experiments 11% of the DoD web sites, 30% of
the Alexa Top 500 websites and 16% of the URLs in the analyzed
HTTP Archive data set are potentially vulnerable to CPDoS attacks.
These cached contents include also mission-critical firmware and
update files. Considering the fact that modern distributed appli-
cations often follow the Mircoservices [29] and Service-Oriented
Architecture (SOA) [10] design principles where services are imple-
mented with different programming languages and are operated by
distinct entities, more semantic gap vulnerabilities may appear in
the future. Hence, a more in-depth understanding of such vulnera-
bilities needs to be gathered in order to develop robust safeguards
that do not depend on particular implementation and concatenation
of system layers.
ACKNOWLEDGMENT
First of all, we would like to thank all reviewers for their thoughtful
remarks and comments. Moreover, we would especially like to thank
Shuo Chen and James Kettle for their feedback and suggestions.
Finally, we appreciated the disclosure processes with the AWS-
Security team, the Microsoft Security Response Center and the Play
Framework development team.
This work has been funded by the German Federal Ministry of
Education and Research within the funding program "Forschung
an Fachhochschulen" (contract no. 13FH016IX6).
REFERENCES
[1] Amazon. 2019. How CloudFront Processes and Caches HTTP 4xx and 5xx Status
Codes from Your Origin. https://docs.aws.amazon.com/AmazonCloudFront/
latest/DeveloperGuide/HTTPStatusCodes.html
[2] Apache HTTP Server Project. 2019. Security Tips. https://httpd.apache.org/
docs/trunk/misc/security_tips.html
[3] G. Barish and K. Obraczke. 2000. World Wide Web caching: trends and techniques.
IEEE Communications Magazine 38, 5 (2000), 178â€“184. https://doi.org/10.1109/
35.841844
[4] M. Belshe, R. Peon, and M. Thomson. 2015. Hypertext Transfer Protocol Version 2
[5] T. Bray. 2016. An HTTP Status Code to Report Legal Obstacles. RFC 7725. IETF.
[6] A. Chatiron. 2019. Define allowed methods used in â€™X-HTTP-Method-Overrideâ€™.
(HTTP/2). RFC 7540. IETF. https://tools.ietf.org/html/rfc7540
https://tools.ietf.org/html/rfc7725
https://github.com/playframework/play1/issues/1300
[7] J. Chen, J. Jiang, H. Duan, N. Weaver, T. Wan, and V. Paxson. 2016. Host of
Troubles: Multiple Host Ambiguities in HTTP Implementations. In 23th ACM
SIGSAC Conference on Computer and Communications Security (CCS). https:
//doi.org/10.1145/2976749.2978394
[8] G. Clemm and J. Whitehead J. Crawford, J. Reschke. 2010. Binding Extensions
to Web Distributed Authoring and Versioning (WebDAV). RFC 5842. IETF. https:
//tools.ietf.org/html/rfc5842
[9] L. Dusseault. 2007. HTTP Extensions for Web Distributed Authoring and Versioning
(WebDAV). RFC 4918. IETF. https://tools.ietf.org/html/rfc4918
[10] T. Erl. 2007. SOA Principles of Service Design. Prentice Hall PTR.
[11] R. Fielding, M. Nottingham, and J. Reschke. 2014. Hypertext Transfer Protocol
[12] R. Fielding and J. Reschke. 2014. Hypertext Transfer Protocol (HTTP/1.1): Message
[13] R. Fielding and J. Reschke. 2014. Hypertext Transfer Protocol (HTTP/1.1): Semantics
[14] Flask. 2010. Adding HTTP Method Overrides. http://flask.pocoo.org/docs/1.0/
(HTTP/1.1): Caching. RFC 7234. IETF. https://tools.ietf.org/html/rfc7234
Syntax and Routing. RFC 7230. IETF. https://tools.ietf.org/html/rfc7230
and Content. RFC 7231. IETF. https://tools.ietf.org/html/rfc7231
patterns/methodoverrides/
//blogs.akamai.com/2017/03/on-web-cache-deception-attacks.html
[15] O. Gil. 2017. WEB CACHE DECEPTION ATTACK. In Blackhat USA. https:
[16] K. Holtman and A. Mutz. 1998. Transparent Content Negotiation in HTTP. RFC
[17] IEEE Spectrum. 2018. Interactive: The Top Programming Languages 2018. https:
2295. IETF. https://tools.ietf.org/html/rfc2295
//spectrum.ieee.org/static/interactive-the-top-programming-languages-2018
14
APPENDIX A: ILLUSTRATIVE EXAMPLES OF CPDOS ATTACK
A.1 Ethereum-website
Figure 6: These screenshots show the start page of the website ethereum.org and how parts as well as the whole page are
rendered inaccessible due to a successful CPDoS attack. More specifically, this website has been vulnerable to HHO CPDoS.
A.2 Marines-website
Figure 7: These two screenshots show the start page of the website marines.com before a) and after b) a successful CPDoS
attack. More specifically, this website has been vulnerable to HHO CPDoS.
15
APPENDIX B: CPDOS ATTACK SPREAD
Legend:
none-affected region,
affected region,
attacker,
origin server
(a)
(b)
Figure 8: Affected CDN regions when sending a CPDoS attack from a) Frankfurt, Germany and b) Northern Virginia, USA to
a victim origin server in Cologne, Germany.
16