235
由
273
---
## Page 278
236
列一个或多个原因导致：
进程在刚刚启动之后通常要比稳定状态下处理请求的速度慢一点。慢的原因可能是由下
分的请求都受到了影响。
因此，不仅5%的请求受到了影响（那些由于后端问题不可能成功的请求），实际上大部
可用线程/（5000+95)线程工作），这会造成80.4%的错误率。
端服务器并没有这么多可用线程。忽略副作用，前端也仅能够处理19.6%的请求（1000
使用100s的截止时间，5%的请求会消耗5000个线程（50QPS*100seconds），但是前
的95%仍耗时100ms。
用，导致对这些部分的请求不可用。结果，5%的请求要一直到超时才能完成，而剩余
假设某个事件导致5%的请求永远不会结束。这可能是由于Bigtable某个行范围不可
作（1000QPS*0.1s）。
的请求，每个请求耗时100ms完成。这意味着前端服务器共计有100个工作线程同时工
意味着前端服务器有共计1000个线程容量。在常规状态下，前端服务器发送1000QPS
假设上面那个例子中的前端服务器由10个任务组成，每个任务有100个工作线程。这
请求延迟的双峰分布（Bimodal）
慢启动和冷缓存
下列指导思想可以帮助解决这一类问题
·当使用按键值空间分布的某种共享资源时，应该考虑按键值分布限制请求数量
·如果无法完成的请求能够尽早返回一个错误而不是等完整个截止时间，我们就可
·检测这个问题可能会很困难。尤其是当我们监控平均延迟的时候，很难发现原来
·将截止时间设置得比平均延迟大好几个数量级通常是不好的。在前述例子中，最
某个异常客户端大量产生负载的情况下提供一些公平性。
或者使用某种滥用跟踪系统。假设你的后端要处理来自不同客户端的性能和特征
导致了线程耗尽问题。
开始只有一小部分请求超时，但是由于截止时间设置比平均延迟高三个数量级，
选项，一定要启用它。
是最好的，而不是等待这个后端服务器变得可用。如果RPC层支持快速失败的
以避免这个问题。例如，如果一个后端服务器不可用，经常立刻返回一个错误值
布情况。
是双峰分布导致的问题。当我们观测到延迟上升时，应该额外注意观察延迟的分
各异的请求，我们可以考虑限制一个客户端只能占用25%的线程总数，以便在
第22章
处理连锁故障
---
## Page 279
重启
在某个集群维护之后恢复服务状态
上线一个新的集群
时应该采用一定步骤来避免问题的发生。
如果某个服务不是按照100%冷缓存模式来配置部署的，那出问题的可能性会升高，同
务前端之间的硬黏性或软黏性（hard/soft stickiness）设置来达到。
常耗时。其他服务可能使用缓存将用户状态放置在内存中。这可以通过在反向代理和服
热缓存下，只有很少请求没有命中缓存，但是当缓存是空的情况下，100%的请求都非
大部分请求都是由缓存提供的，所以缓存没有命中的请求会非常慢。在稳定状态和一个
同样的，有些服务器会在缓存没有充满之前效率很低。例如，对某些Google的服务来说，
运行时性能优化，
必需的初始化过程
下列情况可能会导致冷缓存问题：
JIT编译过程，热点优化，以及类延迟加载机制。
在接收到第一个请求后，需要跟后端服务器建立连接。
缓存中的数据可能是过期的。
·使用通用的连锁故障避免手段。尤其是，服务器应该在进入过载状况，或者降级
·过量配备（overprovision）该服务。区分延迟类缓存和容量类缓存是很重要的
将缓存在多个服务器中共享，但是可能会多消耗一层RPC和额外的延迟问题。
将缓存从一个软件服务器拿出到另外的独立服务器中，比如memcache，而且可以
如果某个有缓存的任务最近重启了，那么它的缓存需要一定时间填充。可能有必要
刚刚增加的集群的缓存是空的。
低平均延迟），但是在没有缓存的情况下就不可能达到。
有的时候，
能，但是最后却变成了强制依赖。
是经过良好设计的、可安全使用的容量类缓存。有些时候加入缓存是为了提高性
该对增加缓存层非常警惕，应该确保每个新添加的缓存要么是延迟类缓存，要么
但是使用容量类缓存时，该服务将不能够在空缓存下处理请求负载。运维人员应
当使用延迟类缓存时，服务器可以在空缓存的情况下仍然处理预期的请求负载
同样的观察也适用于延迟：
你会发现服务容量的一大部分都来自于缓存中的服务，
尤其是Java
如果无法访问缓存，
慢启动和冷缓存
就无法服务那
237
275
---
## Page 280
276
238
些触发条件。
连锁故障的触发条件
如下几个：
后端服务器可能会彼此之间代理请求。这种在层内的交互通信可能会导致问题，原因有
然而，假设后端服务器中的所有任务会彼此通信。例如，当存储层无法处理某个请求时，
通常会同时修复后端和前端服务器。
和存储层通信。一个存储层的问题会造成和它通信的服务器的问题，修复存储层的问题
当某个服务容易产生连锁故障时，有
在前面的莎士比亚搜索服务的例子中，前端服务器和后端服务器通信，后端服务器随后
保持调用栈永远向下
·这种通信容易导致分布式死锁。后端服务器可能使用同样的线程池来等待发送
·取决于交互通信的重要性，初始化整个系统可能会变得更复杂。
·如果这种交互通信是由于某种失败因素或者过载情况导致的（如负载重新分布机
制在负载很高的时候很活跃），这种交互通信可能在延迟上升的时候从不常见变
线程池可用。这种行为可能会导致线程耗尽问题的扩散。
环。应该由客户端来进行这种通信。例如，如果一个前端需要和后端通信，但是
更多的负载，因为请求通常要被解析两次，还需要主后端消耗资源等待副后端任务，
得很常见。
后端B给后端A发送了一个请求，于是占用了后端B的一个线程等待后端A的
给其他后端的RPC，以及处理来自其他后端的请求。假设后端A的线程池满了，
证缓存随时是热的状态也是一个不错的选择。
热起来，就可以增加更多的请求了。确保所有集群都处理一定程度的负载，以保
当为一个集群增加负载时，需要缓慢增加。初期的小流量会加热缓存，一旦缓存
猜错了后端任务，后端不会代理请求给正确的后端，而是通过返回错误使得前端
整个系统都处于过载状态，那么从主到副的这种代理可能会增多，会给系统带来
例如，假设一个用户有一个主后端和一个预先选择好的另外集群中的一个热备后
何表现。
状况下主动拒绝请求，同时应该进行测试，以观察服务在大规模重启等情况下如
在正确的后端任务上重试它的请求。
在用户的请求路径中最好能够避免使用同层通信一
端，主后端在底层出现错误或者延迟上升的情况下将请求代理给热备后端。如果
第22章处理连锁故障
一
一些情况可能触发多米诺骨牌效应。本节指出了某
一也就是避免通信路径中出现
---
## Page 281
变可能会导致具体每个请求的平均成本发生变化。同样的，由于用户使用的增多或者行
化，这将导致后端服务可能会从另外一个集群接收请求。同时，前端代码或者配置的改
由于负载均衡配置的改动、用户流量的变化及集群问题等可能导致前端服务器负载的变
请求特征的变化
给另外一个集群而使延迟升高。
某个服务的关键依赖可能不可用，导致上游服务的容量不可用，或者由于需要将请求发
如果服务是多集群部署的，某些容量可能会由于维护或者集群事故而不可用。同样的，
计划中或计划外的不可用
上升，却没有进行对应的容量调整导致的。
在很多情况下，
自然增长
你的服务通常应该实现某种改变记录，这样可以帮助尽快识别最新的改变。
量或者更改请求特点的情况下。
在发生连锁故障时，检查最近的改变以及回滚通常是明智的，尤其在这些改变会影响容
用和限制的改变、后端的改变和其他系统组件的改变可能导致连锁故障的发生。
新的二进制文件、
新的发布
好办法。
峰值时间推送更新。根据请求数量和可用容量来动态调节任务的同时更新数量可能是个
为了避免这种情况，必须要在设计进程更新机制的时候考虑到对容量的影响，或者在非
发布一个新版本或者更新配置文件时，可能由于大量任务同时受影响而触发连锁故障
进程更新
其他的物理机器上）都可能会导致某个服务进入崩溃边缘。
很多其他原因导致。一个非常小的事件（例如，几个任务崩溃，或者几个任务被转移到
death，会触发进程崩溃的RPC）而崩溃，或者由于集群问题，代码中的断言错误，或者
某些服务任务会崩溃，减少了服务可用容量。进程可能会由于接收到致死请求（query of
进程崩溃
，连锁故障不是由于某个特定的服务改变导致的，而是由于使用量的天然
、配置更改，或者底层架构的改变都可能导致请求特征的改变，
连锁故障的触发条件
，资源使
239
277
---
## Page 282
279
278
240
因为缓存的影响，逐渐升高的负载可能与瞬间提升的负载性能差距很大。因此，应该考
以此进行回归测试，按最差情况配备资源，或者使用利用率和安全系数做妥协。
压力测试同时显示了临界点所在，这一点是容量规划流程的关键所在。这使得我们可以
件应该可以拒绝一小部分请求而继续存活。
过载情况下开始崩溃，或者返回大量错误信息就非常容易造成连锁故障。设计良好的组
回错误或者降级的回复。但是不应该显著降低它成功处理请求的速率。
某一临界点不能再处理更多请求。在这个临界点上，组件理想情况下针对多余的负载返
压力测试每个组件直到它们崩溃。随着压力上升，一个组件通常可以成功处理请求直到
知识也能够在紧急情况下帮助on-call工程师处理故障。
时如何表现可以帮助确定为了修复问题所需要完成的最重要的工程性任务。最不济这种
理解服务在高负载情况下的行为模式可能是避免连锁反应最重要的一步。知道系统过载
测试直到出现故障，还要继续测试
重的情况下是否会进入连锁故障模式。
你应该针对服务进行压力测试，通过对重载下服务行为的观察可以确定该服务在负载很
受连锁故障影响的测试策略。
从理论上预测服务会以什么方式进入故障状态是很困难的。这一节讨论了检测服务是否
连锁故障的测试
留的资源限制中，
然减少，导致无关任务的CPU资源不够。当进行压力测试时，应确保服务一直停留在预
MapReduce任务，在很多机器上使用了很多CPU，那么总共的备用CPU资源就可能突
决于集群中其他任务的行为，所以可能随时消失。例如，如果一个团队启动了一个
依赖这些备用资源作为你的安全防护网是很危险的。这些备用资源的可用性完全取
器之间都不一样。
资源，以便在CPU峰值的时候提供一个安全防护。这种备用CPU资源在集群和集群机
某些集群操作系统允许超卖资源。CPU是一个模糊资源；通常机器会有一些备用CPU
资源限制