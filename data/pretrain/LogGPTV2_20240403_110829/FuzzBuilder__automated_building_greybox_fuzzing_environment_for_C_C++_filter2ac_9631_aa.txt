title:FuzzBuilder: automated building greybox fuzzing environment for C/C++
library
author:Joonun Jang and
Huy Kang Kim
FuzzBuilder: Automated building greybox
fuzzing environment for C/C++ library
Joonun Jang
Huy Kang Kim
Samsung Research
Korea University
Seoul, Republic of Korea
PI:EMAIL
Seoul, Republic of Korea
PI:EMAIL
ABSTRACT
Fuzzing is an effective method to find bugs in software. Many
security communities are interested in fuzzing as an automated
approach to verify software security because most of the bugs dis-
covered by fuzzing are related to security vulnerabilities. However,
not all software can be tested by fuzzing because fuzzing requires
a running environment, especially an executable. Notably, in the
case of libraries, most of the libraries do not have a relevant exe-
cutable in practice. Thus, state-of-the-art fuzzers have a limitation
to test an arbitrary library. To overcome this problem, we propose
FuzzBuilder to provide an automated fuzzing environment for li-
braries. FuzzBuilder generates an executable that calls library API
functions to enable library fuzzing. Moreover, any executable gen-
erated by FuzzBuilder is compatible with existing fuzzers such as
AFL. We evaluate the overall performance of FuzzBuilder by testing
open source libraries. Consequently, we discovered unknown bugs
in libraries while achieving high code coverage. We believe that
FuzzBuilder helps security researchers to save both setup cost and
learning cost for library fuzzing.
CCS CONCEPTS
• Security and privacy → Software security engineering;
KEYWORDS
greybox fuzzing, library fuzzing, software development, unit test
ACM Reference Format:
Joonun Jang and Huy Kang Kim. 2019. FuzzBuilder: Automated building
greybox fuzzing environment for C/C++ library. In 2019 Annual Computer
Security Applications Conference (ACSAC ’19), December 9–13, 2019, San
Juan, PR, USA. ACM, New York, NY, USA, 11 pages. https://doi.org/10.1145/
3359789.3359846
1 INTRODUCTION
Greybox fuzzing is a test method used to find bugs residing in
software. Security researchers often use greybox fuzzing as an au-
tomated method to find security flaws in programs because most
of the bugs found by greybox fuzzing can be related to security
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
ACSAC ’19, December 9–13, 2019, San Juan, PR, USA
© 2019 Association for Computing Machinery.
ACM ISBN 978-1-4503-7628-0/19/12...$15.00
https://doi.org/10.1145/3359789.3359846
vulnerabilities. Until today, greybox fuzzing has been researched
extensively, and many fuzzers have been implemented, such as
AFL [35], AFLFast [13], AFLGo [12], VUzzer [24], T-Fuzz [23], An-
gora [14], and CollAFL [17]. The fuzzers showed their performance
by discovering bugs in programs. Table 1 shows the number of
unknown bugs found by each greybox fuzzer.
Table 1: The number of unknown bugs found by greybox
fuzzers
greybox fuzzer
AFL
AFLFast
AFLGo
VUzzer
T-Fuzz
Angora
CollAFL
# of bugs
more than 370
12
39
8
3
175
157
Greybox fuzzing is well known for its advantage of being able
to test with only binaries. However, most of the bugs in Table 1 are
in open source software. This implies that greybox fuzzing is also
useful when source code is available. Therefore, it is necessary to
apply greybox fuzzing to a development process to prevent security
vulnerabilities at an early stage. In practice, large IT companies such
as Google and Microsoft enforce fuzzing in their development pro-
cess. Notably, Google developed OSS-Fuzz [27], which is a greybox
fuzzing service platform for open source software.
Greybox fuzzing requires an execution of a program. This implies
that it is not easy to apply greybox fuzzing to libraries. Nonetheless,
libraries need to be tested with greybox fuzzing, as vulnerabilities
in libraries potentially affect many programs by being reused.
A simple approach for fuzzing a library is to generate an exe-
cutable that calls library API functions and then fuzzing the gener-
ated executable. The executable enables library fuzzing by calling
library API functions with arbitrary input values generated by a
fuzzer. To this end, source code for an executable should be written
manually. Generally, writing code can be done by developers or
testers.
Developers can write code with in-depth knowledge of a library.
Thus, a library API can be used correctly, which helps to reduce false
positive bugs. Additionally, various combinations of library API
functions can be used, which helps to achieve high code coverage.
However, writing code is an additional task for developers. Fur-
thermore, it is difficult for developers to write code for fuzzing
627because they may not know fuzzing sufficiently. Therefore, devel-
opers need to be educated about fuzzing. These things make it
difficult for developers to support greybox fuzzing in practice.
Table 2 shows the status of both unit test and fuzzing of the top
10 stars of open source libraries obtained from GitHub by using
search filter: C, C++, and parse. Source code for fuzzing was found
only in a few project’s repositories, while source code for unit tests
was found in all project’s repository. Even if the number of projects
is increased up to top 30, 24 projects have source code for unit tests,
while only five projects have source code for fuzzing. This shows
that developers do not support fuzzing sufficiently in practice.
Table 2: The status of supporting unit test and fuzzing in
library projects
project
libphonenumber
rapidjson
http-parser
redcarpet
grbl
tinyxml2
cJSON
yajl
libpostal
pugixml
unittest
fuzzing
✔
✔
✔
✔
✔
✔
✔
✔
✔
✔
✗
✗
✗
✗
✗
✗
✔
✗
✗
✔
In the case of testers, testers can write code that is fuzzing-
friendly. However, it takes much time for testers to understand
library API functions for using them correctly. Especially it is chal-
lenging for testers to write code to achieve high code coverage
because in-depth knowledge of libraries is required. This way is
not also practical considering that testers may test more than one
program in parallel.
Above all, writing code is a labor-intensive job. Moreover, it is
required to maintain this source code whenever library code change.
To overcome these problems, we propose an approach to generate
executables automatically for application of greybox fuzzing to
libraries. The main idea is to generate executables through static
and dynamic analysis of unit tests in projects.
Our research helps developers by eliminating their additional
task to support greybox fuzzing. Further, testers can do fuzzing
libraries with minimized effort. We implemented this method as
a tool, FuzzBuilder that is based on LLVM framework [21]. Exe-
cutables generated by FuzzBuilder can be tested by various grey-
box fuzzers such as AFL without any customization. We evaluated
FuzzBuilder by measuring code coverage and by discovering un-
known bugs.
To clarify the scope of this study, Fig 1 is shown to display a dif-
ference between general fuzzing researches and our research. Most
of the fuzzing researches have focused on discovering bugs in given
executables. They did not consider how executables were prepared.
Thus, in the case of libraries, if there is no relevant executable for a
library, the library cannot be tested by greybox fuzzing. Our study
focuses on generating executables that enable any software to be
tested by fuzzers. Although the main target of our approach is to
Library
Executable
Bugs
FuzzBuilder
Fuzzing researches
Figure 1: Research area of this study
generate executables for library fuzzing, other types of software
also can be a target of the proposed method.
For example, daemon, which is a program that runs as a back-
ground process, is one of the programs that cannot be tested by
most of the greybox fuzzers as greybox fuzzers require guaran-
teed termination of a program. This is because fuzzers should con-
tinue to execute a program with many input values they generated.
FuzzBuilder can help to do fuzzing a daemon by generating an
executable that calls functions which are defined in the daemon.
Although a generated executable and an original program are not
the same, this is sufficient to provide an opportunity to prevent
security problems by fuzzing several essential functions. In this
way, FuzzBuilder lends a way to extend a type of target that cannot
be tested by greybox fuzzers initially without any modification.
matically to fuzz libraries.
In summary, our contributions are as follows.
• We propose a novel approach to generate executables auto-
• For practicality, generated executables are compatible with
various greybox fuzzers such as AFL.
• We implemented this approach as a tool, FuzzBuilder that
is based on LLVM framework. Source code is available at
https://github.com/hksecurity/FuzzBuilder.
2 BACKGROUND
2.1 Library Fuzzing
A library is a collection of implementation of features that has a well-
defined interface. Various independent programs can use prebuilt
features of libraries developed by other developers. This reuse of
features contributes to the field of computer science because of its
high productivity caused by low implementation time and cost.
However, vulnerabilities in libraries can be more critical than
bugs in other software because they can affect various programs
that use the libraries. Therefore, it is required to test libraries with
greybox fuzzing to prevent security vulnerabilities preemptively.
An interface of a library, which is referred to as a library API, is
defined as a set of functions that a library exports. Library API func-
tions are functions from a library API. A program can use a library
by calling its API functions along with parameters. Instructions
in a library are executed based on a value passed as parameters.
This means that library fuzzing requires a set of instructions to call
library API functions with input values.
Libfuzzer [26] is a renowned greybox fuzzer for a library. To
use Libfuzzer, developers should define LLVMFuzzerTestOneInput
function, which is used as an interface between a fuzzer and a
target library. This function has two parameters; the first parameter
denotes a buffer address, which stores a random value generated
by a fuzzer, and the second parameter denotes a buffer size.
Developers should write a body of this function. When writing
this function, it should be included that calling library API functions
6281
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
static bool initflag = false ;
static char * buffer = NULL ;
static int buffer_len = 0;
init () {
... // omitted logic about an initialization
initflag = true ;
}
insert ( char * input , int len ) {
if ( initflag == false ) return ;
buffer = calloc ( len + 1, 1) ;
memcpy ( buffer , input , len );
buffer_len = len ;
}
parse_A () {
... // omitted logic about a parsing
}
parse_B () {
... // omitted logic about a parsing
}
Figure 2: The example for understanding why function se-
quence is required to achieve higher code coverage
with parameters of this function. For this, at first, developers should
select a base function to pass a value from a fuzzer to a library. A
base function is a function that has instructions for loading a value
to the memory where a library will use. Then, developers should
choose other library API functions to be tested jointly for testing
various features of a library.
Our suggestion is to automate this job. Thus, generated executa-
bles should include instructions to do the followings.
• Obtaining a value from a fuzzer.
• Passing the value to a target library through a base function.
• Calling various library API functions related to the base
function.
2.2 Function Sequence
Writing code for library fuzzing is initiated by selecting a base
function. Additionally, calling other functions related to a base
function is desired to achieve sufficient code coverage. For example,
an implementation of a specific feature in a library can be divided
into one or more functions. Further, a specific function in a library
cannot be tested alone if the function requires a return value of
other function. In these cases, all of the related functions should be
tested jointly. Thus, it is considered to call a sequence of functions
when writing code for library fuzzing. Han et al. [18] introduced
a similar concept as an API model which includes two types of
dependency; ordering dependencies and value dependencies in
their kernel fuzzer.
In this paper, we define a function sequence as a set of functions
to be tested jointly. Fig 2 shows that why a function sequence is
required to write code for library fuzzing.
In this example, a base function is insert function. insert function
works well only if initflag set to true. Therefore, init function should
5,000
4,000
3,000
2,000
1,000
0
s
e
n
i
l
d
e
t
i
s
i
v
f
o
#
0
1
2
3
time(h)
4
5
6
with seeds
without seed
Figure 3: Line coverage comparison between when seeds are
given and when not given
be called before calling insert function. Further, insert function is
only used for storing a value passed through a parameter. Actual
usage of the value is defined in parse_A, and parse_B. Therefore,
to achieve a higher code coverage in this example, it is required to
write code for calling two function sequences, init - insert - parse_A,
and init - insert - parse_B.
2.3
Low test coverage is a representative weakness of greybox fuzzing.
Because greybox fuzzing depends on randomness, it is not easy
to explore deep program paths. Therefore, it is recommended to
provide seeds to a greybox fuzzer to alleviate this problem.
Seed in greybox fuzzing
A seed is a sample input. Seeds can explore various and deep
program paths without any input generation mechanism of grey-
box fuzzing. Seeds can help to increase test coverage because, for
exploring more program paths, it is better to manipulate seeds than
to start from scratch. Fig 3 is the result of fuzzing of pkcs12 exe-
cutable for 6 hours by AFL. When seeds are provided, higher code
coverage is achieved from the beginning, and coverage continues
to increase during fuzzing. After 6 hours of fuzzing, code coverage
of around 10 times higher than that of without seeds was achieved.
Consequently, it is necessary to provide seeds to greybox fuzzing
for efficiency. Therefore, automation in this study includes generat-
ing seeds.
2.4 Unit Test
A unit test is conducted to verify whether a program works correctly