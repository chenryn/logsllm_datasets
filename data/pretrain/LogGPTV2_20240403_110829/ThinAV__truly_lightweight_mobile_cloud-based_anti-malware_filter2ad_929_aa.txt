title:ThinAV: truly lightweight mobile cloud-based anti-malware
author:Chris Jarabek and
David Barrera and
John Aycock
ThinAV: Truly Lightweight Mobile Cloud-based
Anti-malware
Chris Jarabek
David Barrera
John Aycock
Department of Computer Science
School of Computer Science
Department of Computer Science
University of Calgary
2500 University Drive NW
Calgary, AB, Canada T2N 1N4
PI:EMAIL
Carleton University
1125 Colonel By Drive
Ottawa, ON, Canada K1S 5B6
PI:EMAIL
University of Calgary
2500 University Drive NW
Calgary, AB, Canada T2N 1N4
PI:EMAIL
ABSTRACT
This paper introduces ThinAV, an anti-malware system for
Android that uses pre-existing web-based ﬁle scanning ser-
vices for malware detection. The goal in developing Thi-
nAV was to assess the feasibility of providing real-time anti-
malware scanning over a wide area network where resource
limitation is a factor. As a result, our research provides a
necessary counterpoint to many of the big-budget, resource-
intensive idealized solutions that have been suggested in the
area of cloud-based security. The evaluation of ThinAV
shows that it functions well over a wide area network, re-
sulting in a system which is highly practical for providing
anti-malware security on smartphones.
Keywords
Android, Malware, Cloud computing, Anti-virus
1.
INTRODUCTION
The exponential rise in malware has caused countless re-
search papers to begin with vacuous statements about the
exponential rise in malware. Typically these are backed up
by token citations to Gartner and Symantec reports, and
occasionally a Department of Justice publication for good
measure. We will omit this particular ritual.
Massive numbers of malware signatures and related up-
dating issues have caused many anti-malware vendors to
move parts of their product into the cloud over the last few
years (e.g., [4, 18]). The answer to the question of how big
anti-malware can get is therefore limitless. Few people seem
to be asking the opposite question, however: how small can
anti-malware be? This is an especially relevant question for
mobile devices. We should note that by “small” we are nat-
urally referring to a small amount of anti-malware software
running on end hosts, but also a small amount of supporting
infrastructure (ideally none). In other words, a tiny piece of
software on the end host plus a massive local cloud infras-
tructure to maintain does not equal small.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ACSAC ’12 Dec. 3-7, 2012, Orlando, Florida USA
Copyright 2012 ACM 978-1-4503-1312-4/12/12 ...$15.00.
We began answering this question for desktop comput-
ers.1 We wrote a small Python program to intercept ﬁle
accesses under Linux; we thus had our small desktop foot-
print, but somehow we had to check the ﬁles being accessed
for malicious content, without creating or maintaining our
own cloud infrastructure.
We observed that cloud-based anti-malware exists already,
and it is freely-available in the sense that anyone can query it
on the Internet. Speciﬁcally, we used Kaspersky, VirusChief,
and VirusTotal.2 All of these are similar insofar as a user of
the service can upload any type of ﬁle, and receive a report
about the malware (if any) that might be contained in the
ﬁle. These WAN-based services acted as our anti-malware
scanners; any access to a ﬁle that had not already been
scanned by our system would be sent for scanning.
Our system was designed in a modular fashion, so it was
able to leverage all these existing anti-malware services eas-
ily. Scanning requests were sent via the site’s API if one
existed (VirusTotal), otherwise they were made via HTTP
requests and the results scraped from the HTTP responses.
(We note that only VirusTotal had terms of service listed,
which we abided by in addition to making attempts to mini-
mize our traﬃc to all these services during testing and eval-
uation.)
On the desktop, we found that two factors conspired to
create an underwhelming user experience. First, the multi-
tude of diﬀerent ﬁles being accessed resulted in poor local
cache performance and many ﬁles being uploaded. Second,
these ﬁles would often be accessed several at a time, and in
rapid succession, aggravating latency issues. Furthermore,
an orthogonal problem is that the ﬁles being uploaded could
potentially contain sensitive data.
While things look grim on the desktop, the situation for
mobile devices – notably Android – is such that our idea ﬁts
into the ecosystem better and works well. That is the topic
of this paper.
A survey of malware encountered in the wild on Android,
iOS and Symbian devices [9] found that all instances of mal-
ware for Android devices used application packages as their
vector, meaning that users were unknowingly installing the
malware on their device. This is not surprising, as Android
applications can be installed from an arbitrarily large num-
ber of places, unlike the one-stop (and one-stop only!) shop-
ping for iOS applications. There are multiple major An-
1We only summarize our desktop implementation and exper-
iments here due to space constraints; full details are in [14].
2
kaspersky.com; viruschief.com; virustotal.com.
209
droid app markets, even more minor markets, and apps can
be downloaded and installed from the Internet or via USB.
Furthermore, it is relatively trivial to construct and release
a Trojanized version of a legitimate application.
Clearly there is a need for anti-malware protection on An-
droid. In fact, Google has announced that due to the spate of
malware on their market, they have developed their own in-
ternal anti-malware scanning system called Bouncer, which
performs automated scanning of apps submitted to the mar-
ket [16]. But this is just one application source of many, and
this is where our system, ThinAV, ﬁts in.
ThinAV provides lightweight cloud-based anti-malware pro-
tection for Android devices, combining a small Android client
with the ability to leverage multiple anti-malware services
on the Internet. Android eﬀectively forces each application
to run as a diﬀerent user, thus limiting what we need to
scan, as one app cannot modify another. We can reason-
ably constrain ThinAV to look at apps as they are installed,
combined with a “killswitch” to manage cases of post hoc de-
tection. This addresses ﬁle access latency, but also privacy:
only apps, not data, need to be scanned, and ThinAV’s de-
sign proxies scan requests so that individual users cannot be
easily proﬁled by their IP addresses.
Section 3 presents ThinAV’s architecture, after the related
work in Section 2. Section 4 extensively evaluates ThinAV,
and is followed by a discussion of ThinAV’s limitations and
our conclusions in Sections 5 and 6, respectively.
2. RELATED WORK
Cloud-based malware scanning as posited in [19, 20] was
a signiﬁcant source of inspiration for ThinAV. Their sys-
tem, CloudAV, has end hosts run a lightweight client (300
LOC in Linux, and 1200 LOC in Windows) which tracks and
suspends ﬁle access requests until a ﬁle has been scanned.
This is the only lightweight part; CloudAV relies on a local
cloud service consisting of twelve parallel VMs, ten of which
run diﬀerent anti-virus engines, and two run behavioral de-
tection engines. These dedicated scanning servers run in a
LAN environment, where the performance hit from network
latency and system load is minimal. Even an extension of
the CloudAV work to a mobile setting [21] failed to provide
any information on how fast their solution operated in the
lower-bandwidth / higher-latency mobile realm. ThinAV,
by contrast, is truly lightweight. It has a small client that
runs on the end host and it relies on already-existing anti-
malware services on the Internet.
Many cloud-based anti-malware systems (e.g., [17, 5, 6,
4]) are an exercise in load balancing. Well-provisioned cloud
servers perform intensive processing, in concert with clients
that handle less demanding processing or operations that re-
quire client-side context. (In some cases, just extra process-
ing power and not a cloud is needed: one system validates
the contents of a mobile device when it is connected to a
desktop or laptop computer via USB [7].) Some systems [13,
22, 2] tilt the balance and make the client a straightforward
source of security data for the cloud to process, but again
this needs resources on the server side if not the client side.
ThinAV sidesteps this by combining a lightweight client with
the ability to leverage existing services.
At the other extreme is anti-malware that is based on
the end host, per the traditional anti-malware model. This
presents a problem on resource-constrained mobile devices,
and consequently these mobile systems tend to employ var-
ious generic detection heuristics, such as battery consump-
tion [15], memory consumption [12], and heuristic (mostly
permission-based) rules [8]. Running solely on a mobile de-
vice is neither lightweight nor does it allow use of existing
services, though.
Finally, Meteor [1] draws on existing information sources
such as developer registries, application databases and re-
mote application killswitches to provide single-market secu-
rity guarantees in a multi-market environment. While Me-
teor could potentially provide a framework in which ThinAV
could operate, the server-side component is as yet unimple-
mented.
3. SYSTEM ARCHITECTURE
In this section we present the ThinAV anti-malware sys-
tem. We begin with an overview, followed by a threat model,
and then describe each ThinAV component.
3.1 Overview
ThinAV is an anti-malware system for Android which of-
ﬂoads the chore of scanning to existing third-party malware
scanning services. ThinAV was designed to be lightweight,
modular, extensible and has been tested with freely available
online services such as Kaspersky, VirusChief, VirusTotal
and ComDroid [3]. These scanning services all behave simi-
larly in receiving cryptographic hashes of ﬁles or the binaries
themselves as queries, and returning a scan result.
As shown in Figure 1, ThinAV consists of two main com-
ponents: (1) an Android client, which submits applications
for scanning and (2) a server which submits received ﬁles to
third-party scanning services and notiﬁes the client in the
event of malware detection. The client software consists of
modiﬁcations to the Android OS package manager as well as
a client app for user notiﬁcation of the scan result. A Kill-
switch module acts as a periodic post-installation scanner
for installed apps. For performance reasons (described in
Section 4), the server caches scan results in order to return
them faster to clients.
Aside from performance and power consumption reduc-
tion, a clear beneﬁt of splitting the client and server is the
ability to update scanning modules without having to up-
date the client code. This enables on-demand addition or
removal of scanning services.
3.2 Threat Model
Android provides strong application isolation by assign-
ing each application an unprivileged unique UNIX user id
(UID). Once apps are installed, the underlying Linux ker-
nel ensures isolation between apps and grants privileges ac-
cording to the pre-approved permission request (displayed
to the user at install-time). Under this security model, the
key threat to the user and OS originates primarily from ma-
licious apps that are installed voluntarily by a user, rather
than from traditional vectors for malware such as drive-by-
downloads and malicious executables [9]. Our threat model
assumes:
1. Side-loaded3 apps cannot be executed without being
installed through the OS-provided PackageInstaller,
3Side-loaded apps are installed through mechanisms other
than the oﬃcial Google Play Store (e.g., third-party mar-
kets, ﬁle downloads).
210
Third-party Scanning Services
VirusTotal 
Service
VirusChief
Service
Kaspersky 
Service
ComDroid 
Service
VirusTotal 
Module
VirusChief
Module
Kaspersky 
Module
ComDroid 
Module
Thin AV
Thin AV Web Interface
Thin AV Safe 
Installer
PackageInstaller
Thin AV 
Killswitch
Application 
Repository
Android 
Device
Application Sources
Web Site
E-Mail
USB
Third-Party 
Market
G
Official Google 
Market
Figure 1: System architecture diagram for ThinAV.
a low-level framework responsible for completing the
installation process.
2. Once installed, applications cannot modify their code
dynamically. The only way to modify code or func-
tionality is through an application update, which in
itself is a new installation (that preserves user data)
bound to Assumption 1.
3. The OS and pre-installed system applications are trusted.
3.3 Server
The ThinAV server component is responsible for receiving
scan requests and submitting them to the scanning mod-
ules on behalf of the client. The ThinAV server is currently
implemented in Python using the Flask4 0.8 web applica-
tion micro-framework and runs on Linux. The server is de-
signed in a modular object-oriented fashion, where a par-
ent class provides scanning modules (i.e., subclasses) with
all the functionality needed for searching and updating the
local cache, as well as uploading binaries via HTTP POST
requests.
To improve performance, the ThinAV server uses a local
cache, which is implemented as a ﬂat ﬁle containing previous
scan results. While most online malware scanning services
cache scan results, the latency in returning results (even
those which are cached) was found to be unacceptable in our
test conditions (see Section 4). Thus, whenever a scanning
module is instantiated, the local cache is ﬁrst checked.
4
http://flask.pocoo.org/
211
The cache holds an MD5 hash of each scanned ﬁle, the
full path to the ﬁle, the number of times ThinAV has been
asked to analyze the ﬁle, the last time such an access has
occurred, the infection status of the ﬁle, a note for additional
scan details, and the module that was used when the ﬁle was
analyzed.
3.4 Safe Installer
Safe Installer is the ThinAV component on the client re-
sponsible for preventing malicious applications from being
installed. To build Safe Installer, we modiﬁed the Android
Package Installer framework,5 the system code in charge of
parsing Android packages to verify integrity, and later com-
pleting the installation or update process by creating a new
UID (if necessary) and placing ﬁles in the appropriate direc-
tories. All side-loaded applications must go through the An-
droid Package Installer for installation, making this a ideal
choke-point for placing our ThinAV client.
Speciﬁcally, we modiﬁed the PackageInstallerActivity
class to make use of ThinAvService, a new service class
which communicates with the Thin AV server described in
the previous section. The service provides a single public
function checkAPK, accessed via an interface deﬁned using
the Android Interface Deﬁnition Language. The checkAPK
function takes the ﬁle system path of the Android app pack-
age (APK) being installed, reads the ﬁle and creates a cryp-
tographic hash of the APK. This hash is then sent to the
ThinAV web application, which returns a scan report, if such
a report exists. If no scan report exists, the APK is uploaded
to ThinAV where it is passed oﬀ to one of the third-party
scanning services. When a scan result is returned, that re-
sult is passed back to ThinAvService and checkAPK then
returns a Boolean value indicating whether or not the in-
stallation should be allowed to proceed. The PackageIn-
stallerActivity then allows or prevents the installation of
the application, displaying the appropriate information di-
alogs to the user, where necessary.
3.5 Killswitch
Safe Installer can prevent the installation of applications
known to be malicious. However, Safe Installer will be un-
able to prevent the installation of malicious apps in two
cases. First, when a malicious application was installed on a
device prior to the installation of ThinAV; and second, when
an application was installed on a device but was not ﬂagged
as malicious at the time of installation. A Killswitch was de-
veloped to address these two scenarios. The Killswitch op-
erates independently of any speciﬁc application installation
mechanism, making it ideal for the multi-market ecosystem
available on Android devices.
The Killswitch was developed as a standalone Android ap-
plication capable of communicating with the ThinAV server,
similar to the Safe Installer, but invoked on-demand rather
than automatically at install-time.
The Killswitch has three diﬀerent functions available to
the user. (1) It can upload all applications to ThinAV for
analysis (if those applications are not in the ThinAV local
cache); (2) it can manually check if any non-system applica-
tions on the device have been ﬂagged as malicious; and (3)
it can regularly check the device for malicious applications
5Speciﬁcally, we modiﬁed the Android 2.3.7 source code
which was in use by most deployed Android devices [23].
using a scheduled event. In the current implementation the
killswitch is scheduled to run every 15 minutes.
When the Killswitch is checking for malicious apps, it uses
the PackageManager class to locate all Android packages in-
stalled on the device. For each package, the Killswitch reads
the meta-data, creates a hash of each app’s byte contents,
and a collection of all package hashes is sent to the Thi-
nAV server. If a package has already been hashed by the
Killswitch, then the hash is stored in a ﬁle which is only ac-
cessible to the Killswitch. This hash can then be retrieved
much more quickly than recomputing the hash every time
the device is ﬁngerprinted. If any of the hashes sent to the
ThinAV server are found to be from a malicious app, the
user is notiﬁed of the infection, and presented a list of appli-
cations suspected to be malicious. The user can then choose
to initiate the removal of those applications.
3.6 Scanning Modules
ThinAV can be conﬁgured to oﬄoad scanning to any third-
party malware scanning service with a public API or web
interface. The system currently has modules for four scan-
ning services that are freely available online: Kaspersky, Vir-
usChief, VirusTotal, and ComDroid. These services all be-
have similarly insofar as a user can upload any type of ﬁle
(executable, data, etc.) through the website of the service
and receive a report as to any malware that might be con-