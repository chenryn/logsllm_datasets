开，并按代码中的顺序依次调用。
Test::Nginx::Socket provides many filters for your convenience. Consider the
following data section from the aforementioned test block.
Test::Nginx::Socket 提供了许多常用的过滤器。看下来自前述测试块的一个数据节：
[source,test-base]
— error_code: 200 —-
If we want to place the section value, 200, in a separate line, like below,
如果你想把200这个值单独放在一行，就像这样，
[source,test-base]
— error_code 200 —-
then the section value would contain a trailing new line, which leads to a test
failure. This is because the one-line form always excludes the trailing new-line
character while the multi-line form always includes one. To explicitly exclude the
trailing new-line in the multi-line form, we can employ the chomp filter, as in
那么数据节的值里就会有一个换行符，导致状态码无法匹配。 这是因为单行模式的
值会移除结尾的换行符，而多行模式不会。要想在多行模式里去掉结尾的换行，我
们可以采用 chomp 过滤器，像这样
Openresty中文编程网 User Guide Page 14
Test File Layout PDF last generated: November 08, 2016
[source,test-base]
— error_code chomp 200 —-
Now it has exactly the same semantics as the previous one-line form.
现在它的语义跟之前的单行模式一样了。
Some filters have more dramatic effect on the section values. For instance, the
eval filter evaluates the section value as arbitrary Perl code, and the Perl value
resulted from the execution will be used as the final section value. The following
section demonstrates using the eval filter to produce 4096 a’s:
有些过滤器效果更加显著。 比如， eval 过滤器会把给定的值当作 Perl 代码执行，
返回执行结果作为最终的值。 下面的数据节示范如何用 eval 过滤器生成4096个
‘a’：
[source,test-base]
— response_body eval “a” x 4096 —-
The original value of the response_body section above is a Perl expression where
the x symbol is a Perl operator is used to construct a string that repeats the string
specified as the left-hand-side N times where N is specified by the right-hand-side.
The resulting 4096-byte Perl string after evaluating this expression dictated by the
eval filter will be used as the final section value for comparison with the actual
response body data. It is obvious that use of the eval filter and a Perl expression
here is much more readable and manageable by directly pasting that 4096-byte
string in the test block.
response_body 数据节原来的值是一个 Perl 表达式，其中 x 运算符会把左边的字符
串重复 N 次，N是它右边的数字。 eval 返回的包含4096个字符的 Perl 字符串会被
用作数据节最终的值，跟响应体作比较。 显而易见，无论从可读性还是从可维护性
上看，使用 eval 过滤器和一个 Perl 表达式要比直接贴上4096个字符更胜一筹。
As with data sections, the user can also define her own filters, as we shall see in a
later section.
我们稍后会提到，用户可以定义自己的过滤器，并应用在数据节上。
=== A Complete Example 一个完整的例子
We can conclude this section by a complete test file example given below, with both
the prologue part and the data part.
我们以一个完整的，包含序言部分和数据部分的测试文件示例结束本节。
Openresty中文编程网 User Guide Page 15
Test File Layout PDF last generated: November 08, 2016
[source,test-base]
use Test::Nginx::Socket ‘no_plan’;
run_tests();
DDAATTAA
=== TEST 1: hello, world This is just a simple demonstration of the echo directive
provided by ngx_http_echo_module. ngx_http_echo_module 提供的 echo 指令的一
个简单演示。 — config location = /t { echo “hello, world!”; } — request GET /t —
response_body hello, world! — error_code: 200 —-
We will see how to actually run such test files in the next section.
下一节我们看看如何把它运行起来。
NOTE: The test file layout described in this section is exactly the same as the test
files based on other test frameworks derived from Test::Base , the superclass of
Test::Nginx::Socket , except those specialized test sections and specialized Perl
functions defined only in Test::Nginx::Socket . All the Test::Base derivatives share
the same basic layout and syntax. They proudly inherit the same veins of blood.
NOTE: 本节中描述的测试文件布局跟其他基于 TEST::Base （Test::Nginx::Socket 的
父类）的测试框架的几乎一样，除了一些特殊的数据节和仅在 Test::Nginx::Socket 定
义的 Perl 函数。所有衍生自 Test::Base 的框架都继承了相同的基本布局和语法。毕
竟它们本是同根生。
Openresty中文编程网 User Guide Page 16
Running Tests PDF last generated: November 08, 2016
Running Tests
SSuummmmaarryy:: 一如大多数基于 Perl 的测试框架，`Test:Nginx` 依靠命令行
工具 `prove` 来运行测试文件。
== Running Tests
Like most Perl-based testing frameworks, Test:Nginx relies on Perl’s prove
command-line utility to run the test files. The prove utility is usually shipped with
the standard perl distribution so we should already have it when we have perl
installed.
一如大多数基于 Perl 的测试框架， Test:Nginx 依靠命令行工具 prove 来运行测试文
件。 prove 工具通常随 perl 一同发布，所以在安装了 perl 之后，我们一般也有了
prove 。
Test::Nginx always invokes a real NGINX server and a real socket client to run the
tests. It automatically uses the nginx program found in the system environment
PATH . It is your responsibility to specify the right nginx in your PATH environment
for the test suite. Usually we just specify the path of the nginx program inside the
OpenResty installation tree. For example,
Test::Nginx 总是启动一个真实的 NGINX 服务器和真实的套接字客户端来运行测试。
它默认使用系统的环境变量 PATH 来搜索 nginx 程序。你需要保证在这个环境变量
里面能够找到它。 通常我们会指定 OpenResty 安装包里面的 nginx 程序路径。举
个例子，
[source,bash]
export PATH=/usr/local/openresty/nginx/sbin:$PATH —-
Here we assume that OpenResty is installed to the default prefix, i.e.,
/usr/local/openresty/ .
这里我们假设 OpenResty 安装在默认路径，即 /usr/local/openresty/ 。
You can always use the which command to verify if the PATH environment is
indeed set properly:
你可以使用which 命令验证 PATH 环境变量是否设置正确：
Openresty中文编程网 User Guide Page 17
Running Tests PDF last generated: November 08, 2016
[source,console]
$ which nginx /usr/local/openresty/nginx/sbin/nginx —-
For convenience, we usually wrap such environment settings in a custom shell
script so that we do not risk polluting the system-wide or account-wide environment
settings nor take on the burden of manually setting the environments manually for
every shell session. For example, I usually have a local bash script named go in
each project I work on. A typical go script might look like below
为了方便，我们通常把类似这样的环境变量设置封装在一个自定义 shell 脚本中，
在避免污染全局或本账户的环境变量的同时，也甩掉在每个 shell 会话中手工设置环
境变量的负担。 举个例子，我通常在参与的每个项目中放置一个名为 go 的本地
bash 脚本。 这个脚本看上去大概是这个样子：
[source,bash]
#!/usr/bin/env bash
export PATH=/usr/local/openresty/nginx/sbin:$PATH
exec prove “$@”
Then we can use this ./go script to substitute the prove utility in any of the
subsequent commands involving prove .
然后我们可以在要用到 prove 工具的场景中，用这个 ./go 脚本替换掉它。
Because Test::Nginx makes heavy use of environment variables for the callers to
fine tune the testing behaviors (as we shall see in later sections), such shell
wrapper scripts also make it easy to manage all these environment variable
settings and hard to get things wrong.
由于调整 Test::Nginx 的测试行为重度依赖于对环境变量的使用（接下来我们会看到
这一点）， 这样的包装脚本也让相关环境变量的管理变得简单，让忙中出错变得困
难。
NOTE: Please do not confuse the name of this bash script with Google’s Go
programming language. It has nothing to do with the Go language in any way.
NOTE: 请不要把这个 bash 脚本的名字跟 Google 的 Go 编程语言弄混。 它跟 Go 语
言风牛马不相及。
=== Running A Single File 运行单个测试
Openresty中文编程网 User Guide Page 18
Running Tests PDF last generated: November 08, 2016
If you want to run a single test file, say, t/foo.t , then all you need to do is just
typing the following command in your terminal.
假设你想要运行某个测试文件，比如说，t/foo.t ，你所需的只是在终端敲入如下命
令。
[source,bash]
prove t/foo.t —-
Here inside t/foo.t we employs the simple test file example presented in the
previous section. We repeat the content below for the reader’s convenience.
t/foo.t 里的内容正是上一节展示的测试文件示例。我们将它列在下面，以便读者查
看。
[source,test-base] .t/foo.t —- use Test::Nginx::Socket ‘no_plan’;
run_tests();
DDAATTAA
=== TEST 1: hello, world This is just a simple demonstration of the echo directive
provided by ngx_http_echo_module. ngx_http_echo_module 提供的 echo 指令的一
个简单演示。 — config location = /t { echo “hello, world!”; } — request GET /t —
response_body hello, world! — error_code: 200 —-
It is worth mentioning that we could run the following command instead if we have a
custom wrapper script called ./go for prove (as mentioned earlier in this section):
值得一提的是，假如我们用一个名为 ./go 的脚本包装了 prove （正如本节开头部分
提到的），运行命令的方式会是这样：
[source,bash]
./go foo.t —-
When everything goes well, it generates an output like this:
如果一切顺利，会有如下输出：
…. t/foo.t .. ok All tests successful. Files=1, Tests=2, 0 wallclock secs (0.02 usr
0.01 sys + 0.08 cusr 0.03 csys = 0.14 CPU) Result: PASS ….
This is a very concise summary. The first line tells you all tests were passed while
the second line gives you a summary of the number of test files (1 in this case), the
number of tests (2 in this case), and the wallclock and CPU times used to run all
the tests.
Openresty中文编程网 User Guide Page 19
Running Tests PDF last generated: November 08, 2016
这段总结惜字如金。第一行告诉你所有测试都通过了，第二行则给出测试文件数
（1）、测试数（2）以及运行全部测试所花费的墙上时间和CPU用时。
It is interesting to see that we have only one test block in the sample test file but in
the test summary output by prove we see that the number of tests are 2. Why the
difference? We can easily find it out by asking prove to generate a detailed test
report for all the individual tests. This is achieved by passing the -v option
(meaning “verbose”) to the prove command we used earlier:
有趣的是，虽然测试文件示例中只有一个测试块，但是 prove 输出的测试总结却显
示测试数为2。 为什么会这样？让 prove 给所有测试生成一份详细的测试报告来揭
示真相。 这需要给之前的 prove 命令添加 -v 选项（v 代表 verbose ）：
[source,bash,linenums]
prove -v t/foo.t —-
Now the output shows all the individual tests performed in that test file:
现在可以在输出里看到测试文件中每个测试的运行情况：
…. t/foo.t .. ok 1 - TEST 1: hello, world - status code ok ok 2 - TEST 1: hello, world
- response_body - response is expected (req 0) 1..2 ok All tests successful.
Files=1, Tests=2, 0 wallclock secs (0.01 usr 0.01 sys + 0.07 cusr 0.03 csys =
0.12 CPU) Result: PASS ….
Obviously, the first test is doing the status code check, which is dictated by the
error_code data section in the test block, and the second test is doing the
response body check, required by the response_body section. Now the mystery is
solved.
显而易见，第一个测试检查状态码，这是 error_code 数据节的命令； 而第二个测试
检查响应体，则是 response_body 要求的。原来如此。
It is worth mentioning that the --- error_code: 200 section is automatically assumed
when no error_code section is explicitly provided in the test block. So our test block
above can be simplified by removing the --- error_code:200 line without affecting
the number of tests. This is because that checking 200 response status code is so
common that Test::Nginx makes it the default. If you expect a different status code,
like 500, then just add an explicit error_code section.
值得一提的是， 如果测试块中没有指定 error_code ，默认会设置
--- error_code: 200 。 因此我们可以移除多余的 --- error_code: 200 ，而不影响测试的
总数。 毕竟检查响应状态码是否为200是个常见的需求，所以 Test::Nginx 把它设置
为默认行为。 如果你期望的是其他状态码，比如500，那么就加上一个 error_code