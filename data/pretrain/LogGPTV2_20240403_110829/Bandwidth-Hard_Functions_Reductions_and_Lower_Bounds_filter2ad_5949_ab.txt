+ crt ∈ Ω
(cid:16)(cid:112)cb · cr · Πcc(G)
(cid:17)
,
(cid:18) Πcc(G)
t
(cid:19)
where m is the cache size, t is the number of steps in the pebbling, cb is the cost of a blue move and cr is the
cost of a red move.
1In contrast to [AB17], we use energy cost to refer to bandwidth cost.
5
Theorem 1.2 demonstrates that the goals of designing an MHF with high cumulative complexity and
high bandwidth complexity are well aligned. In fact, we use Theorem 1.2 to show that a family {Gn}∞
of constant indegree DAGs constructed by Schnitger [Sch83] has high energy costs because Πcc(Gn) ∈
(cid:107)
Ω(n2) [AdRNV16]. As an intermediate step to proving Theorem 1.2 we show that rbpeb
This result is interesting as it suggests that an attacker will not be able to dramatically decrease energy costs
by exploiting parallelism. By contrast, for any constant indegree DAG G it is known that the parallel cu-
[AB16] while it is known that Πcc(Gn) ∈ Ω(n2)
mulative pebbling cost is at most Π
cc(G) ∈ O(cid:16) n2 log log n
(G, m) ≥ rbpeb(G, 2m).
(cid:17)
n=1
(cid:107)
log n
for the constant indegree DAGs constructed by Schnitger [Sch83].
We also prove a similar theorem that directly relates ecost and cmc. In particular, we show that
(cid:18)(cid:113)
ecost (fG,H ) ∈ Ω
cbcrcmc (fG,H ) − cbm
.
obtain the following lower bound for scrypt: ecost (scrypt) ∈ Ω(cid:0)√
Crucially, this bound applies to any MHF not just for iMHFs. For iMHFs we could use our pebbling reduc-
(cid:107)
tion to relate ecost (fG,H ) to rbpeb
(G) and we could use [AS15] to relate cmc (fG,H ) to Πcc(G), but no such
pebbling reduction is known for dMHFs. Combining our result with a result of Alwen et al. [ACP+17] we
previously proved that ecost (scrypt) ∈ Ω (n · cb) their result assumes that the attacker must transfer data
to/from cache in blocks of size w. While our lower bound is weaker, it is the ﬁrst unconditional lower bound
on the bandwidth hardness of scrypt. We conjecture that our results could be extended to show that
ecost (scrypt) ∈ Ω (n · cb) without condition.
cbcrn(cid:1). While Ren and Devadas [RD17]
On the Bandwidth Hardness of Important iMHF Candidates.
bounds on the bandwidth hardness of several important iMHF candidates including Argon2iA, Argon2iB [BDK16],
aATSample and DRSample [ABH17]. We use Argon2iA to refer to v1.1 and we use Argon2iB to refer to ver-
sions v1.2+ 2. Thus, Argon2iB (the current version of Argon2i) is particularly important to cryptanalyze as
it won the password hashing competition and is being considered for standardization by the Cryptography
Form Research Group (CFRG) of the IRTF [BDKJ16].
In Section 5, we provide lower
aATSample and DRSample are important to study as they are the ﬁrst practical iMHF candidate with
nearly asymptotically optimal cmc3. For the families of graphs generated by aATSample and DRSample
[ABH17] we show the following:
Theorem 1.3. Let G be a graph generated by aATSample. Then there exists a constant C > 0 so that for
all m ≤ Cn
log n ,
(cid:107)
rbpeb
(G, m) ≥ min(Ω(n)cb, Ω(n log n)cr),
holds with high probability.
Theorem 1.4. Let G be a graph generated by DRSample and 0  0
so that for all m ≤ Cnρ, with high probability,
(cid:107)
rbpeb
(G, m) ≥ min
Ω(n)cb, Ω(n3/2−ρ/2)cr
.
(cid:19)
(cid:17)
We provide lower bounds on the bandwidth hardness on the family of graphs generated by Argon2iB. The
bounds are slightly weaker for Argon2iB in that they only hold if the attacker has cache size m ≤ Cn2/3−.
2The speciﬁcation of Argon2i has changed several times, but the only changes that aﬀect are analysis are changes that
aﬀect the underlying DAG G. A change to the edge distribution was introduced in v1.2 where a non-uniform indexing was
introduced. We use Argon2iB to refer to the version that is currently being considered for standardization by the Cryptography
Form Research Group (CFRG) of the IRTF[BDKJ16].
and cmc (aATSample) ∈ Ω
[ABH17] while any iMHF fG,H has cmc at
(cid:17)
(cid:16) n2·w
log n
(cid:17)
(cid:16) n2·w
log n
most cmc(cid:0)fG,H
3In particular, cmc (DRSample) ∈ Ω
(cid:1) ∈ O(cid:16) n2·w·log log n
(cid:17)
.
log n
(cid:16)
6
Theorem 1.5. Let G be a graph generated by Argon2iB. Then there exists a constant C > 0 so that for any
0  0 (computation may
(G, m) ≤ k” is in NP5
(cid:107)
be cheap, but it is not free). Furthermore, the decision problem rbpeb
so the decision problem is fundamentally diﬀerent when we require cr > 0. While the decision problem
(cid:107)
rbpeb
is important for the cryptanalysis of MHFs to the best of our knowledge nothing was known about
the complexity of this problem prior to our paper.
(cid:107)
= “is rbpeb
Gilbert et al. [GLT79] previously showed that the following decision problem was PSPACE complete:
Given a DAG G decide if there is a legal black pebbling with space complexity at most m i.e., during
every pebbling round there are at most m pebbles on the graph. Gilbert et al. showed that the minimum
space black pebbling problem was PSPACE − Hard by reduction from the Truly Quantiﬁed Boolean Formula
(TQBF) problem. Observing that any 3 − SAT instance φ with n variables is also a TQBF instance (albeit
with no ∀ quantiﬁers) their reduction allows us to transform φ into a DAG Gφ. The graph Gφ has the
property that it can be pebbled with at most m = 3n + 3 black pebbles if and only if φ is satisﬁable. In
(cid:107)
Appendix D we detail a gadget to append to Gφ to create a graph Hφ so that rbpeb
(H) = x1 if φ is a
(cid:107)
satisﬁable assignment, but rbpeb
(Hφ) > x1 if φ is not a satisﬁable assignment.
2 Preliminaries
We use [n] to denote the set {1, 2, . . . , n} and [a, b] = {a, a + 1, . . . , b} where a, b ∈ N with a ≤ b. Similarly,
we use (a, b] to denote the set [a, b] − {a}.
latter decision problem is PSPACE complete [GLT79].
4In particular, rbpeb(cid:107)(G, m) = 0 if and only if there is a legal black pebbling of G using at most m black pebbles where the
5In particular, for a DAG with indeg(G) = O (1) there is always a red-blue pebbling with cost at most O (n · cr + n · cb) —
pebble nodes in topological order and never remove a pebble from a node. Thus, the optimal red-blue pebbling runs in time at
since any red-blue pebbling running in time t in the parallel random oracle model has cost at least t· cr.
most t ∈ O(cid:16)
(cid:17)
n + n·cb
cr
7
We assume a given directed acyclic graph (DAG) G = (V, E) is labeled in topological order and when G
has size n we will use V = [n] to denote the set of vertices. We say a node v ∈ V has indegree δ = indeg(v)
if there exist δ incoming edges δ = |(V × {v}) ∩ E|. We say that G has indegree δ = indeg(G) if the
maximum indegree of any node of G is δ. A node with indegree 0 is called a source node and a node with
no outgoing edges is called a sink. We use parentsG(v) = {u ∈ V : (u, v) ∈ E} to denote the parents of a
node v ∈ V and similarly for a set S ⊆ V , we deﬁne parentsG(S) = {u ∈ V : (u, v) ∈ E, v ∈ S}. In general,
G(v) =
we use ancestorsG(v) = (cid:83)
G(v) to denote the set of all ancestors of v — here, parents2
i≥1 parentsi
parentsG (parentsG(v)) denotes the grandparents of v and parentsi+1
is clear from context we will simply write parents (resp. ancestors). We denote the set of all sinks of G with
sinks(G) = {v ∈ V : (cid:64)(v, u) ∈ E}, the nodes with no incoming edges.
|V | = n} and often will bound
the maximum indegree Gn,δ = {G ∈ Gn : indeg(G) ≤ δ}. For directed path p = (v1, v2, . . . , vz) in G, its
length is the number of nodes it traverses, length(p) := z (as opposed to the number of edges). We say the
depth d = depth(G) of DAG G is the length of the longest directed path in G.
We often consider the set of all DAGs of equal size Gn = {G = (V, E) :
G (v) = parentsG
(cid:0)parentsi
G(v)(cid:1). When G
An iMHF can be speciﬁed by a DAG G and a random oracle H as in the next deﬁnition.
Deﬁnition 2.1. Given a directed acyclic graph G = (V = [n], E) with a set of sink nodes sinks(G) and a
random oracle function H : Σ∗ → Σ(cid:96) over an alphabet Σ, we deﬁne the labeling of graph G as labG,H : Σ∗ →
Σ∗. We omit the subscripts G, H when the dependency on the graph G and hash function H is clear. In
particular, given an input x the (H, x) labeling of G is deﬁned recursively by
(cid:40)
labH,x(v) =
H(v, x),
H (v, labH,x(v1), . . . , labH,x(vd)) ,
indeg(v) = 0
indeg(v) > 0,
where v1, . . . , vd are the parents of v in G, according to some predetermined lexicographical order. We deﬁne
fG,H (x) = {labH,x(s)}s∈sinks(G).
If there is a single sink node sG then fG,H (x) = labH,x(sG).
We will often consider graphs obtained from other graphs by removing subsets of nodes. Thus if S ⊂ V ,
then let G − S be the DAG obtained from G by removing nodes S and incident edges.
simultaneously) so we require that V ⊆ (cid:83)
Given a directed acyclic graph (DAG) G = (V, E) the goal of the red-blue pebbling game is to place
pebbles on all sink nodes of G (not necessarily simultaneously).
Let RB = ((B0, R0), (B1, R1), . . . , (Bt, Rt)) (resp. RB(cid:107)) denote the set of all sequential (resp. parallel)
red-blue pebblings of a DAG G. The game is played in rounds and we use Bi ⊆ V (resp. Ri ⊆ V ) to
denote the set of nodes with blue pebbles (resp. red pebbles) in round i. Initially, no nodes contain pebbles,
so that B0 ∪ R0 = ∅. The goal is to eventually place a red-pebble on every node in V (not-necessarily
i Ri. We also require that in every round i > 0 we have (1)
parents (Ri \ (Ri−1 ∪ Bi−1)) ⊆ Ri−1, (2) Bi \ Bi−1 ⊆ Ri−1 and (3) |Ri| ≤ m during every time step i.
We let RB(cid:107)(G, m) be the set of all valid parallel red-blue pebblings of G with a cache-size of m pebbles.
Intuitively, in each round i ≥ 1 we may place a red pebble on a node v ∈ V if either parents(v) ⊆ Ri−1 all of
v’s parents contain red pebbles in the previous conﬁguration (called a red move) or v contained a blue pebble
in the previous round (called a blue move). On the other hand, we may place a blue pebble at v ∈ Pi (also
called a blue move) if v contained a red pebble in the previous round. Blue moves represent data transfer
to/from memory and are more expensive than red-moves (computation).
We say that a pebbling ((B0, R0), (B1, R1), . . . , (Bt, Rt)) is sequential if |Ri \ Ri−1| ≤ 1 for all 0  1, (e, d, b)-block-depth robustness is a strictly stronger notion than (e, d)-depth-
robustness since for any set S with |S| ≤ e), it follows that N (S, 1) ⊂ N (S, b). Hence, (e, d, b ≥ 1)-block
depth robustness implies (e, d)-depth robustness. On the other hand, (e, d)-depth robustness only implies
(e/b, d, b)-block depth robustness.
The cumulative memory complexity of an iMHF is very closely related to the notion of depth-robustness [AB16,
cc(G) ∈ O(cid:16)
(cid:107)
en + n · √
(cid:17)
ABP17, ABH17, BZ17].
In particular, we know that Π
Π
depth-robustness can also be a useful tool in bandwidth hardness.
. We will show that Π
dn
(cid:107)
cc(G) ≥ ed for a depth-robust DAG and that
(G, m), thus
(cid:107)
(cid:107)
cc(G) can be used to lower bound rbpeb
2.2 Metagraphs
We will also frequently use the notion of a metagraph in our analysis. For a ﬁxed integer m ∈ [n], let
n(cid:48) = (cid:98)n/m(cid:99). For all i ∈ [n(cid:48)], let Mi = [(i − 1)m + 1, im] ⊆ V . Moreover, we denote the ﬁrst and last thirds
respectively of Mi with
(cid:104)
(cid:20)
M F