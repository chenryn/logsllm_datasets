log(pml)
Although this calculation is done under idealized con-
ditions of independent message loss probabilities on each
message (pml), it serves as a good baseline for comparing
the scalability of different failure detection protocols. For
example, the all-to-all heartbeat protocols discussed in Sec-
tion 2 have a sub-optimality factor that varies linearly with
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:23:09 UTC from IEEE Xplore.  Restrictions apply. 
group size.
3. The Basic SWIM Approach
As mentioned earlier, the SWIM approach has two compo-
nents:
(1) a Failure Detector Component, that detects failures of
members, and
(2) a Dissemination Component, that disseminates informa-
tion about members that have recently either joined or left
the group, or failed.
We now lay the ground by describing the basic SWIM
protocol. The basic protocol uses the random-probing based
failure detector protocol of [12] (Section 3.1) and dissem-
inates membership updates via network multicast (Sec-
tion 3.2). The SWIM protocol is developed in the succeed-
ing section (Section 4) by reﬁning this initial design.
3.1. SWIM Failure Detector
The SWIM failure detector algorithm [12] uses two pa-
rameters: protocol period T (cid:4)
(in time units) and integer k,
the size of failure detection subgroups. The protocol does
not require clocks to be synchronized across members, and
properties of the protocol hold if T (cid:4)
is the average protocol
period at group members.
Figure 1 illustrates the working of the protocol at an ar-
bitrary member Mi. During each protocol period of length
T (cid:4)
time units (on Mi’s local clock), a random member is
selected from Mi’s membership list (say Mj), and a ping
message sent to it. Mi then waits for a replying ack from
Mj. If this is not received within a prespeciﬁed time-out
(determined by the message round-trip time, which is cho-
sen smaller than the protocol period), Mi indirectly probes
Mj. Mi selects k members at random and sends each a
ping-req(Mj) message. Each of these members in turn
(those that are non-faulty), on receiving this message, pings
Mj and forwards the ack from Mj (if received) back to
Mi. At the end of this protocol period, Mi checks if it has
received any acks, directly from Mj or indirectly through
one of the k members; if not, it declares Mj as failed in
its local membership list, and hands this update off to the
Dissemination Component.
In the example of Figure 1, one of the k members man-
ages to complete this cycle of events as Mj is up, and Mi
does not suspect Mj as faulty at the end of this protocol
period.
The prespeciﬁed time-out used to initiate indirect prob-
ing is based on an estimate of the distribution of round-trip
time within the network, e.g. an average or 99th percentile
could be used. Note that the protocol period T (cid:4)
has to be
at least three times the round-trip estimate. In our experi-
ments, we use the average measured round-trip time to set
TIME
M
    i
M
choose random 
    j
choose k random
members
T’
M
    j
ping
ack
ping-req(Mj)
...
ack
ping
ack
ping
Figure 1. SWIM failure detection: Example protocol period at
Mi. This shows all the possible messages that a protocol period
may initiate. Some message contents excluded for simplicity.
the time-out, and our protocol period is signiﬁcantly larger
than this value.
The data contained in each message of this protocol is
tagged with the unique sequence number of the protocol pe-
riod at the initiator (Mi). Notice that the size of ping,ping-
req,ack messages is bounded by a constant, and is indepen-
dent of group size.
The second part of the above protocol uses an indirect
probing subgroup of members to relay both pings and acks.
The rationale for using this approach, rather than sending k
ping messages directly to Mj, or relaying back acks in re-
ply to ping-reqs directly back to Mi, is to avoid the effect
of any congestion on the network path between Mi and Mj;
this might have led to the dropping of the original ping mes-
sage or its ack.
This failure detector protocol is analyzed in [12]. Here, we
summarize the results of the analysis5:
• If each member has a membership list of size n, and a
fraction qf of these are non-faulty, the likelihood of an ar-
bitrary member being chosen as a ping target in a protocol
· qf )n−1, which decreases quickly (and
period is 1− (1− 1
asymptotically as n → ∞) to 1 − e−qf .
• As a result, the expected time between failure of an arbi-
trary member and its detection by some process in the group
is at most T (cid:4)·
1
−qf . This gives an estimate of the protocol
1−e
period length in terms of the application-speciﬁed expected
detection time.
• If qml is the probability of timely delivery of a packet
by the network, independent across all packets, an arbitrary
non-faulty member will be falsely detected as failed within
n
5The reader is encouraged to work out these results, or refer to [12].
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:23:09 UTC from IEEE Xplore.  Restrictions apply. 
)k ·
ml
qf
e
qf −1 .
e
a protocol period with probability qf · (1 − q2
) · (1 − qf ·
q4
• This gives a conﬁgurable value for k in terms of the false
ml
positive probability required by the application.
• This failure detector satisﬁes Strong Completeness: a
faulty member will eventually be chosen a ping target at
each non-faulty member, and deleted from its membership
list.• The expected message load per member imposed by the
protocol is a constant that does not vary with group size,
and is symmetrical across all members. This load can be
calculated from the estimate of k.
• None of these properties depend (except asymptotically)
on the group size n.
3.2. Dissemination Component and Dynamic Mem-
bership
Upon detecting the failure of another group member, the
process simply multicasts this information to the rest of the
group as failed(Mj) message. A member receiving this
message deletes Mj from its local membership list.
Information about newly joined members or voluntarily
leaving members are multicast in a similar manner. How-
ever, for a process to join the group, it would need to know
at least one contact member in the group. This can be real-
ized through one of several means: if the group is associated
with a well known server or IP multicast address, all joins
could be directed to the associated address. In the absence
of such infrastructure 6, join messages could be broadcast,
and group members hearing it can probabilistically decide
(by tossing a coin) whether to reply to it. Alternatively, to
avoid multiple member replies, a static coordinator could
be maintained within the group for the purpose of handling
group join requests. In fact, existence of multiple coordi-
nators does not affect the correctness of the protocol, and
only leads to multiple replies to the join request. Discovery
and resolution of multiple coordinators can be done over
time through the Dissemination Component. In the current
version of SWIM, we have chosen to maintain a coordina-
tor, although there is no reason to preclude any of the other
strategies.
4. A More Robust and Efﬁcient SWIM
Section 3 described the basic SWIM protocol that dis-
seminates membership updates (resulting from member
joins, leaves or failures) using network multicast. However,
network multicast primitives such as IP multicast etc., are
only best-effort - message losses within the network can
cause arbitrary and correlated non-receipt of membership
6Absence of centralization is a common design philosophy in peer-to-
peer systems today.
changes at any group member. In Section 4.1, we describe
the design of a Dissemination Component that piggybacks
membership updates on the ping and ack messages sent by
the failure detector protocol. This completely eliminates
the generation of extra packets by the Dissemination Com-
ponent (viz., multicasts). The only packets generated by
SWIM then are pings, ping-reqs and acks, thus giving
a constant expected message overhead per group member.
This approach results in an infection-style of dissemination,
with the associated beneﬁts of robustness to packet losses,
and of low latency.
The basic SWIM failure detector protocol, in spite of
its calculable accuracy, is subject to slow processes (e.g.
ones losing a lot of packets from buffer overﬂow) declar-
ing several other non-faulty processes as faulty. It is also
possible that a process is perturbed for small durations of
time, e.g. on an overloaded host. This might cause the pro-
cess to miss the opportunity to send timely replies to pings
received meanwhile, and be mistakenly declared as failed.
Section 4.2 presents the Suspicion mechanism, where a pro-
cess that is unresponsive to ping messages, as generated
by the SWIM failure detector protocol described in Sec-
tion 3, is not immediately declared as “faulty”.
Instead,
the process is declared as “suspected”, and this information
spread through the group using the Dissemination Compo-
nent. After a prespeciﬁed time-out (we discuss values for
this parameter in Section 5), the suspected process is de-
clared as “faulty” and this information disseminated to the
group. However, if the suspected process responds to a ping
request before this time-out expires, information about this
is disseminated to the group as an “alive” message. The
process is then rejuvenated in membership lists at different
members without ever having to leave or rejoin the group.
This prespeciﬁed time-out thus effectively trades off an in-
crease in failure detection time for a reduction in frequency
of false failure detections.
The basic SWIM failure detection protocol guarantees
eventual detection of the failure of an arbitrary process Mi,
at each non-faulty group member Mj. However, it gives
no deterministic guarantees on the time between failure of
an arbitrary member Mi and its detection at another arbi-
trary member Mj (in terms of the number of local proto-
col rounds at Mj). Section 4.3 describes a modiﬁcation to
the original SWIM failure detector protocol that guarantees
such a Time Bounded Completeness property; the time in-
terval between the occurrence of a failure and its detection
at member Mj is no more than two times the group size (in
number of protocol periods).
4.1. Infection-Style Dissemination Component
The basic SWIM protocol of Section 3 propagates mem-
bership updates through the group using a multicast primi-
tive. Hardware multicast and IP multicast are available on
Proceedings of the International Conference on Dependable Systems and Networks (DSN’02) 
0-7695-1597-5/02 $17.00 © 2002 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:23:09 UTC from IEEE Xplore.  Restrictions apply. 
most networks and operating systems, but are rarely en-
abled, e.g., for administrative reasons. The basic SWIM
protocol would then have to use a costly broadcast, or an
inefﬁcient point-to-point messaging scheme, in order to dis-
seminate the membership updates to all group members.
Furthermore, as this multicast is unreliable, membership
changes can be disseminated only on a best-effort basis to
the group.
Instead, the augmented SWIM protocol eliminates the
use of an external multicast primitive altogether. It does so
by piggybacking the information to be disseminated on the
ping, ping-req and ack messages generated by the failure
detector protocol. We call this an infection-style dissemina-
tion mechanism as information spreads in a manner analo-
gous to the spread of gossip in society, or epidemic in the
general population [8]. Notice that this implementation of
the Dissemination Component does not generate any extra
packets (such as multicasts) - all “messages” handed to this
component are propagated by piggybacking on the packets
of the Failure Detection Component.
Bailey [2] presents a deterministic analysis of the spread
of an epidemic within a homogeneously mixing group of
n members with one initial infected member. The relation
between the (expected) number of infected members x (ini-
tially 1) and time t, under a contact rate of β per time unit,
is obtained as:
= β · x · (n − x) ⇒ x =
dx
dt
n
1 + (n − 1)e−βnt
In our infection-style dissemination component, the spread
of a membership update through the ping and ack messages
can be analyzed in a similar manner. With the protocol pe-
riod treated as a time unit, contact rate β is the probability
of contact between any pair of infected and non-infected
members, and equals [1− (1− 1
n2 ). This gives
us x =
)2] = ( 2
n
− 1
n
n
1+(n−1)e
−(2− 1
n
)t .
)λ
−(2− 1
n
1
(2− 1
n
n
1+(n−1)n
≥ n · (1 −
Such an epidemic process spreads exponentially fast in
the group; after t = λ.log n rounds of the protocol, where λ
is a parameter, the expected number of infected members is
). A member-
x =
ship update propagated in infection-style by piggybacking
will thus reach (n − n−((2− 1
n )λ−2)) group members after
λ.log n protocol periods. To simplify, as n increases (and
→ ∞), the estimate for x goes to (n − n−(2λ−2)). Setting
λ to a small constant sufﬁces to disseminate the epidemic
reliably - this is true even at small group sizes, as borne out
by our experiments in Section 5.
)λ−1
n
The literature contains the analysis of several other styles
of epidemics [4, 8, 13], with essentially similar conclusions