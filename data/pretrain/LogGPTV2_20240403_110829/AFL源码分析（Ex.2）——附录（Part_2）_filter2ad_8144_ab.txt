因为许多`UBSAN`的机制并没有提供一致的调用`abort()`或独特的退出代码的方法来在产生故障的情况下终止程序。
也就是说，可以对该库的某些版本进行二进制修补以解决此问题，而较新的版本则支持显式的编译时标志——请参见此邮件列表线程以获取提示：
## 2\. parallel_fuzzing.txt(同步fuzz模式手册)
本文档讨论在单台机器上或不同机器中同步`afl-fuzz`作业的方式。 有关此模式的一般说明手册，请参阅自述文件。
###  2.1 介绍
`afl-fuzz`的每个副本将占用一个`CPU`内核。
这意味着在`n`核系统上，您几乎总是可以运行`n`个并发的模糊测试作业，而几乎不会对性能造成任何影响(您可以使用`afl-gotcpu`工具来确保这一点)。
实际上，如果您仅在多核系统上的进行一个模糊测试作业，那么您将无法充分利用硬件。 因此，并行化通常是正确的方法。
当针对多个不相关的二进制文件进行测试或以`dumb`(`-n`)模式使用该工具时，只需启动几个完全独立的`afl-fuzz`实例就可以了。
当您想让多个`fuzzer`测试一个共同的目标时，情况就变得更加复杂。如果一个`fuzzer`合成了一个难以命中但有趣的测试用例，则其余实例将无法使用该输入来指导其工作。
为了解决这个问题，`afl-fuzz`提供了一种简单的方式来实时同步测试用例。
### 2.2 在一个系统上并行`fuzzer`
如果要在本地系统上的多个内核上并行执行单个作业，只需创建一个新的空输出目录(`sync dir`)，该目录将由`afl-fuzz`的所有实例共享，然后为每个实例进行一个命名——例如`fuzzer01`，`fuzzer02`等。
像这样运行第一个实例`(“master”，-M)`：
    ./afl-fuzz -i testcase_dir -o sync_dir -M fuzzer01 [...other stuff...]
然后，像这样启动其他的子实例`secondary(-S)`：
    ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer02 [...other stuff...]
    ./afl-fuzz -i testcase_dir -o sync_dir -S fuzzer03 [...other stuff...]
每个`fuzzer`将把它的状态保存在一个单独的子目录中，例如：`/path/to/sync_dir/fuzzer01/`
每个实例还将定期重新扫描顶级同步目录以查找其他`fuzzer`发现的任何有趣的测试用例——并在它们被认为足够有趣时将其合并到自己的模糊测试用例中。
**-M和-S模式之间的区别在于，主实例仍将执行确定性检查** 。 而辅助实例将直接进行随机调整。 如果您根本不想进行确定性的模糊测试，则可以使用-S运行所有实例。 对于非常慢或复杂的目标，或者在运行高度并行化的作业时，这通常是一个不错的计划。
请注意，尽管有实验性功能支持并行化确定性检查，但运行多个`-M`实例非常浪费。 若真的要进行此项测试，您需要这样创建`-M`实例，如下所示：
    ./afl-fuzz -i testcase_dir -o sync_dir -M masterA:1/3 [...]
    ./afl-fuzz -i testcase_dir -o sync_dir -M masterB:2/3 [...]
    ./afl-fuzz -i testcase_dir -o sync_dir -M masterC:3/3 [...]
    ......
其中`:`后的第一个值是主实例的顺序`ID`(从`1`开始)，第二个值是用于并行化确定性检查模糊测试的`fuzzer`总数。
请注意，如果启动的`fuzzer`数量少于传递给`-M`的第二个数字所指示的数量，则最终的代码覆盖率可能会很差。
您还可以使用提供的`afl-whatsup`工具从命令行监视作业进度。 当实例不再寻找新的代码路径时，可能是时候停止测试了。
警告：在显式指定`-f`选项时要格外小心。 每个模糊器都必须使用单独的临时文件； 否则，可能会出现严重问题。 一个安全的例子可能如下所示：
    ./afl-fuzz [...] -S fuzzer10 -f file10.txt ./fuzzed/binary @@
    ./afl-fuzz [...] -S fuzzer11 -f file11.txt ./fuzzed/binary @@
    ./afl-fuzz [...] -S fuzzer12 -f file12.txt ./fuzzed/binary @@
如果您在不使用`-f`的情况下使用`@@`并让`afl-fuzz`提供文件名，则可以避免此问题。
### 2.3 在多个系统上并行`fuzzer`
多系统并行化的基本操作原理与`2.2`中解释的机制类似。关键区别在于您需要编写一个执行以下两个操作的简单脚本：
  * 使用带有`authorized_keys`的`SSH`信息连接到每台机器，并通过机器本地的每个``检索`/path/to/sync_dir//queue/`目录下的`tar`文件。 最好使用在`fuzzer ID`中包含主机名的命名方案，以便您可以执行下一个操作： 
        for s in {1..10}; do
        ssh user[@host](https://github.com/host "@host")${s} "tar -czf - sync/host${s}_fuzzid*/[qf]*" >host${s}.tgz
    done
  * 在所有剩余的机器上分发和解包这些文件，例如: 
        for s in {1..10}; do
        for d in {1..10}; do
            test "$s" = "$d" && continue
            ssh user[@host](https://github.com/host "@host")${d} 'tar -kxzf -' 
请注意，这些第三方工具在运行`Internet`或不受信任的用户的系统上运行是不安全的。
在开发自定义测试用例同步代码时，需要记住几个优化点：
  * 同步不必经常发生：每`30`分钟左右运行一次同步可能就很好了。
  * 无需同步崩溃/挂起：您只需要复制`queue/*`下的所有文件(理想情况下，还有`fuzzer_stats`)。
  * 不必(也不建议!)覆盖现有文件： `tar`中的`-k`选项是避免这种情况的好方法。
  * 无需为不在特定计算机上本地运行的`fuzzer`提取目录，而只需在较早的运行期间将其复制到该系统上即可。
  * 对于大型系统集群，您将需要为每个主机合并压缩包，这将使您使用`n`个`SSH`连接进行同步，而不是`n * (n-1)`。您可能还希望实现分段同步。 例如，您可能有`10`组系统，第`1`组仅将测试用例推送到第`2`组，第`2`组仅将他们推送到第`3`组； 依此类推，最终第`10`组反馈到第`1`组。这种机制将使测试有趣的案例在整个系统集群中传播，而不必将每个模糊测试队列都复制到每个主机。
  * 您不希望每个系统上都有`afl-fuzz`的“主”实例，您应该使用`-S`来全部运行它们，而只需在系统集群中的某个位置指定一个进程来使用`-M`即可。
_不_ 建议跳过同步脚本并直接在远程文件系统上运行`fuzzer`，`I/O`等待状态中的意外延迟和不可杀死的进程可能会使事情变得混乱。
###  2.4 远程监控和数据收集
您可以使用`screen`、`nohup`、`tmux`或等效的工具来运行`afl-fuzz`的远程实例。如果您将程序的输出重定向到一个文件，它会自动从花里胡哨(译者注：原文如此)的`UI`切换到更有限的状态报告。还有一些基本的机器可读信息总是写入输出目录中的`fuzzer_stats`文件。在本地，该信息可以通过`afl-whatsup`进行解析。
原则上，您可以使用通过`-M`启动的主实例的状态屏幕来监控整体模糊测试进度并决定何时停止。在这种模式下，最重要的决策信号是很长一段时间内都没有找到新的路径。如果您没有主实例，只需选择任何单个辅助实例来观看并执行该操作。
您还可以依靠该实例的输出目录来收集并合成语料库，该语料库将涵盖在队列中任何地方发现的所有值得注意的路径。通过`-S`启动的辅助实例不需要任何特殊监控，只需确保它们已正确启动。
请记住，导致实例崩溃的输入不会自动反馈到主实例，因此您可能仍想从同步脚本或运行状况检查脚本中监控整个测试队列的崩溃情况(更多信息请参阅`afl-whatsup`)。
###  2.5 特异性设置
对于并行的`fuzzer`，允许进行独立的特异性设置，以下一切都是允许的:
  * `afl-fuzz`可以与其他的基于扩展覆盖率的引导工具一起运行(例如，与`concolic`一并执行)。第三方工具只需遵循本文件中所述的协议即可从`out_dir//queue/*`中提取新的测试用例，并将自己的发现写入`out_dir//queue/*`中按编号顺序的`id:nnnnnn`文件。
  * 可以使用不同(但相关)的目标二进制文件运行一些同步模糊器。例如，在共享发现的测试用例的同时对几个不同的`JPEG`解析器(例如 `IJG jpeg`和`libjpeg-turbo`)进行压力测试可以产生协同效应并提高整体覆盖率。(在这种情况下，每个二进制文件都运行一个`-M`实例是一个不错的方案)
  * 可以让一些`fuzzer`以不同的方式调用二进制文件。例如，`djpeg`支持多种`DCT`模式，可使用命令行标志进行配置，而`dwebp`支持增量和一次性解码。在某些情况下，采用多种不同的模式，然后汇集测试用例的`fuzz`结果将提高覆盖率。
  * 不太令人信服的是，使用不同的起始测试用例(例如，渐进式和标准 JPEG）或字典运行同步模糊器。同步机制确保测试集随着时间的推移会变得相当均匀，但它引入了一些初始可变性。
[原译者注：特异性设置相当有用]