`Has(X, b) ∧ Has(X, ga)´”
This deﬁnition captures the intuition that a thread can com-
pute the value of gab if and only if it has the required com-
ponents. Note that for a thread that just has gab but not
a or b, this predicate is false, and therefore we have that
Has(X, gab) does not imply Computes(X, gab).
Note that the deﬁnition of Computes suggests that gab (cid:54)=
gba, because of the explicit listing of both sides of the dis-
junction. If the equality would hold, one could just deﬁne
Computes(X, gab) ≡ Has(X, a) ∧ Has(X, gb) to achieve the
same result.
Using the deﬁnition of Computes, the ﬁrst axiom is given
as:
DH1
Computes(X, gab) ⊃ Has(X, gab)
and corresponds to the extension of the Has predicate, which
can be seen by unfolding the deﬁnition of Computes. The
second axiom states
Has(X, gab) ⊃“
∃m.`Receive(X, m) ∧ Contains(m, gab)´”
Computes(X, gab) ∨
DH2
ing it. Eﬀectively this restricts any agent (including the in-
truder) from knowing a term of the form gab at the start of
each run, but it also excludes that gab is used as a parameter
for a protocol.
For completeness, we also give the remaining DH axioms
DH3 `Receive(X, m) ∧ Contains(m, gab)´ ⊃
.`Computes(Y, gab) ∧ Send(Y, m
∃Y, m
(cid:48)
(cid:48)
) ∧
(cid:48)
Contains(m
, gab)´
DH4
Fresh(X, a) ⊃ Fresh(X, ga)
which capture the assumption that gab must have been ei-
ther computed or received (but was not given as a param-
eter). The fourth axiom echoes the extension of the Fresh
predicate.
Summarizing, even with the extension of the Has predicate
and the additional axioms, the behaviour of the equivalence
for Diﬃe-Hellman is not captured in PCL, for two reasons.
First, with respect to the execution model, the sequence of
actions represented by Formula (4) cannot be enabled in the
execution model by just changing the protocol logic. Second,
we observe that given Has(X, h(a, b)), the protocol logic does
not allow us to conclude that Has(X, h(b, a)) as one would
expect (especially in the case where ¬Computes(X, h(a, b))).
Hence, the essential equivalence for any Diﬃe-Hellman type
protocol is not captured in the execution model, nor in the
protocol logic.
Implications
4.1.2
The Diﬃe-Hellman extension does not correctly capture
the algebraic properties of Diﬃe-Hellman exponentials. As
a result, certain possible behaviours of DH-like protocols
are not considered within the logic and its execution model.
The extension is therefore not a faithful representation of
DH-like protocols.
4.1.3 Resolving the problem
The essential feature to be captured is the equality gab =
gba. If this is introduced at the term level, e.g. by having
the equality h(a, b) = h(b, a) in the term system, this solves
at the same time the problem in the execution model, pro-
tocol logic and proof system. Some further modiﬁcations to
the axioms are required, and the current proofs have to be
modiﬁed to take the term equality into account. Alterna-
tively, one might consider introducing generalizations of the
Diﬃe-Hellman assumption, as e.g. in [5].
4.2 Keyed hashes
In [20] and [21] basic PCL is extended and applied to a
case study of protocols that do not rely solely on signatures.
As observed previously, such an application requires addi-
tional axioms.
In particular, to prove authentication, we
need to introduce an axiom that allows us to conclude the
existence of a thread.
Appendix A of [21] gives such additional axioms and def-
initions for keyed hash functions: one deﬁnition and four
hashing axioms. We reproduce them here for convenience.
This axiom captures the notion that one can only possess
such a term gab by computing it from its parts, or receiv-
Deﬁne Computes (HASH) :
Computes(X, HASHK (a)) ≡ Has(X, K) ∧ Has(X, a)
As we will see in the following, the intention of this predicate
seems to be to express which thread computed the hashed
value from its components. However, this intuition is not
correctly captured by the deﬁnition: a typical use pattern
of a keyed hash would be to provide an integrity check for a
message m, as in
ˆX → ˆY : m, HASHK (m) ,
(5)
where K is a key shared between ˆX and ˆY . In the typical
use pattern, the HASHK (m) is received by an agent which
at that point can construct the message m himself. In this
use case, the message hash is received with (or after) the
message, and is then used to verify the integrity of the mes-
sage.
Assume we have that m (or some subterm of it) is freshly
generated by X, and we have that Computes(X, HASHK (m))
holds. However, we can also prove that once a thread Y of
the recipient ˆY receives the message, Y not only has K, but
also m. Thus the predicate Computes(Y, HASHK (m)) holds
as well. Put diﬀerently, we have that for a typical use case,
Computes(. . .) holds for both the thread who creates as well
as the thread who receives. In particular, this is also true
for the protocols under consideration in [21]. The protocols
in the paper assume typing information (no hash mistaken
for a nonce) and receive the hashed values at a point where
they know the hash components.
Let K be a key shared between ˆX and ˆY . Then, we can
prove5 the following property (invariant) for the protocols
in [21]:
Honest( ˆX) ∧ Has(X, HASHK (m)) ⊃
Computes(X, HASHK (m))
(6)
Intuitively one can see that an honest agent either creates
the hash by having the components, or receives it. In this
last case, where an honest agent receives the hash, the mes-
sage integrity is veriﬁed using the hash, which is possible
only because the recipient also has both the key K and the
message m. We will use this result in our discussion of the
HASH4 axiom later on.
The ﬁrst axiom in [21, Appendix A] that uses the deﬁni-
tion of Computes() is the following:
HASH1
Computes(X, HASHK (x)) ⊃ Has(X, x)∧Has(X, K)
If we unfold the deﬁnition of Computes in this axiom, it re-
duces to φ ⊃ φ. The second hash axiom states the following:
HASH2
Computes(X, HASHK (x)) ⊃ Has(X, HASHK (x))
This axiom informally states that whoever computes the
hash value also has it. If we again unfold the deﬁnition of
Computes, we can see that this works as an extension of the
closure properties of the Has predicate (as deﬁned in [14]).
Eﬀectively, it introduces a new term structure fx(y) to the
PCL syntax, and expresses the one-way property of the hash
function.
5Note that this cannot be proven using only basic PCL,
but it can be proven using PCL combined with the meta-
reasoning required to capture the assumption that variables
are typed, as pointed out in Section 3.3.
The third hash function axiom is
HASH3 Receive(X, HASHK (x)) ⊃
∃Y.Computes(Y, HASHK (x)) ∧ Send(Y, HASHK (x)) .
This axiom is not sound. Consider the following protocol in
Alice and Bob style notation, where m is a freshly generated
nonce of the initiator, and K(cid:48) is a symmetrical key shared
by the initiator and responder:
Init → Resp : ENCK(cid:48){| HASHK (m)|}
Resp → Init : HASHK (m)
(7)
In a normal run of this protocol, the initiator sends the hash
as part of a bigger term, but does not send m. Thus the re-
sponder cannot compute the hash itself, but simply decrypts
the message, and sends the hash back. Thus, the precondi-
tions are fulﬁlled by an initiator thread of this protocol, but
the postcondition does not hold: only the initiator thread
can compute it, but it does not send it out in the required
form. (Observe that contrary to the protocols in [21], this
protocol in (7) does not satisfy the typical usage pattern,
and therefore Formula (6) does not hold here.)
The fourth axiom is
HASH4 Has(X, HASHK (x))⊃ Computes(X, HASHK (x))
∨ ∃Y, m. Computes(Y, HASHK (x)) ∧ Send(Y, m) ∧
Contains(m, HASHK (x)) .
This axiom seems to express: if someone has the hash value,
she computed the hash herself, or somebody computed it
and sent it (possibly as a subterm).
With a suitable restriction on the intruder knowledge (the
intruder should not know some HASHK (x) initially without
knowing the components) this axiom can be proven sound.
However, there is a problem with the applications of the
axiom in the proofs of [14]. Each time this axiom is applied
in proofs in the paper, one assumes honesty of ˆX and ˆY , and
that K is the key shared between them. Thus we can rewrite
the application of axiom HASH4 using Formula (6), as in
the following. First we unfold the deﬁnition of the axiom
Honest( ˆX) ∧ HASH4 =
Honest( ˆX) ∧`Has(X, HASHK (x)) ⊃
Computes(X, HASHK (x)) ∨ Φ´ ,
(8)
where Φ is used to denote the right-hand disjunct of the ax-
iom HASH4, starting from the existential quantiﬁer. Now
we use Formula (6) to get
Honest( ˆX) ∧ HASH4 = Honest( ˆX) .
(9)
In other words, if ˆX is assumed to be honest when applying
axiom HASH4, the left-hand disjunct of the conclusion is
always true (rendering the right-hand disjunct inconsequen-
tial). Because the right-hand disjunct of the conclusion con-
tains the required thread existence, but is rendered useless,
the axiom cannot be used here for proving authentication
properties, based on our observations in Section 3.1.
4.2.1
The authentication proofs of the four-way handshake and
group key handshake protocols in [20, 21] are not correct in
their current form. The reason for this is that these protocols
Implications
do not contain signatures, and based on the observations
in Section 3.1, any authentication proofs for such protocols
must rely on newly introduced axioms.
In this case, the
only candidates are the axioms HASH3 and HASH4. As
shown above, HASH3 is not sound, and for the protocols
in [20,21], HASH4 cannot be used to prove the existence of
a thread. Hence the authentication proofs of the handshakes
are incorrect, and therefore also the compositional proof of
authentication of IEEE 802.11i is incorrect.
4.2.2 Resolving the problem
The properties of a keyed hash function like the ones oc-
curring here are similar to the properties of symmetric-key
cryptography. Thus, once suﬃcient reasoning infrastructure
is in place for symmetric-key cryptography, one can devise
a straightforward deﬁnition of a non-keyed hash function.
Combining these two elements should lead to a natural def-
inition and extension of the logic for keyed hashes.
Alternatively, it might be possible to reinstate rules that
were used in older works, as e.g. found in [11, page 15].
5. CONCLUSIONS
In this paper, we have ﬁrst shown that basic PCL as de-
ﬁned in [9,13,14,17] cannot be used to prove authentication
properties of protocols without signatures. We consider this
to be a strong limitation on the scope of basic PCL. Next,
we have pointed out two reasoning tools that are missing
in basic PCL: reasoning about preceding actions of a role
within a thread, and the lack of a formal type system. With
respect to PCL extensions, we have shown that the PCL
Diﬃe-Hellman extension from [9,13,14,17] does not capture
the algebraic behaviour of Diﬃe-Hellman protocols correctly
in the execution model and protocol logic. Finally, we have
shown that the extension for protocols with keyed hash func-
tions in [20, 21] is not sound.
It follows that some claimed PCL proofs cannot be proven
within the basic logic as deﬁned in [9,13,14,17], or make use
of unsound axioms. These proofs include the authentication
proofs of the CR protocol from [13, 14] and the SSL/TLS
and IEEE 802.11i protocols from [20, 21].
In the papers on PCL the proofs of the invariants are
often not given. This lack of proof details for the invariants
is surprising, as the invariants themselves are the diﬃcult
part. Furthermore, many of the proofs seem impossible to
be completed in PCL without resorting to meta-reasoning.