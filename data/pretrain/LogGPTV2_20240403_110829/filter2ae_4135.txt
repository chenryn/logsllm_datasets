# Glibc 2.27å…³äºTcacheçš„å¢å¼ºä¿æŠ¤
##### è¯‘æ–‡å£°æ˜
æœ¬æ–‡æ˜¯ç¿»è¯‘æ–‡ç« 
è¯‘æ–‡ä»…ä¾›å‚è€ƒï¼Œå…·ä½“å†…å®¹è¡¨è¾¾ä»¥åŠå«ä¹‰åŸæ–‡ä¸ºå‡†ã€‚
## 0x01 å‰è¨€
åœ¨2020å¹´09æœˆ10æ—¥ï¼Œ`Ubuntu`åŸºé‡‘ä¼šå‘å¸ƒäº†åä¸ºä¸º`2.27-3ubuntu1.3`çš„æ›´æ–°ï¼Œæœ¬æ¬¡æ›´æ–°è¿›è¡Œäº†å¯¹äº`Tcache`åˆ†é…æœºåˆ¶çš„æ›´æ–°ï¼Œè¿™å°†å¯¼è‡´ä¸€æ‰¹å¯¹äº`Tcache`çš„åˆ©ç”¨å¤±æ•ˆï¼Œæœ¬æ–‡ä»æºç çš„è§’åº¦åˆ†æäº†å˜åŠ¨çš„æºç ä¸ä¿æŠ¤ã€‚
## 0x02 è·å–æºç 
ç”±äºæ­¤è½¯ä»¶åŒ…ç›®å‰è¿˜å¤„äºæµ‹è¯•çŠ¶æ€(`proposed`)ï¼Œæˆ‘ä»¬æ— æ³•ä½¿ç”¨`apt-get update && apt-get upgrade`ç›´æ¥è·å–åˆ°æ­¤ç‰ˆæœ¬ã€‚
è¿è¡Œä»¥ä¸‹å‘½ä»¤å¯ç”¨è·å–æµ‹è¯•çŠ¶æ€è½¯ä»¶åŒ…æºç ï¼š
    sudo echo 'deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
    ' >> /etc/apt/sources.list
    sudo echo 'deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
    ' >> /etc/apt/sources.list
æ¥ä¸‹æ¥è¿è¡Œ`sudo apt-get update`æ›´æ–°è½¯ä»¶æº
ğŸš«ï¼šæ›´æ–°å®Œè½¯ä»¶æºåï¼Œä¸¥ç¦ç›´æ¥ä½¿ç”¨`sudo apt-get
upgrade`æ›´æ–°è½¯ä»¶ï¼Œéƒ¨åˆ†æµ‹è¯•ç‰ˆæ ¸å¿ƒè½¯ä»¶(ä¾‹å¦‚`glibc`)ä¸€æ—¦è¢«æ›´æ–°åˆ°æµ‹è¯•ç‰ˆå°†æ— æ³•è¿›è¡Œé™çº§ã€‚
æ¥ä¸‹æ¥è¿è¡Œ`sudo apt-get source libc6/bionic-proposed`ä»¥è·å–ç›®æ ‡æºç 
âš ï¸ï¼šæ¥ä¸‹æ¥è¯·ç¼–è¾‘`/etc/apt/sources.list`ï¼Œæ³¨é‡Šæ‰åˆšåˆšæ·»åŠ çš„æºï¼Œå¹¶è¿è¡Œ`sudo apt-get update`æ›´æ–°è½¯ä»¶æº
## 0x03 ä»£ç å˜æ›´
### 1.`Tcache`ç»“æ„ä½“å®šä¹‰å˜æ›´
åŸå§‹å®šä¹‰ï¼š
    /* We overlay this structure on the user-data portion of a chunk when
       the chunk is stored in the per-thread cache.  */
    typedef struct tcache_entry
    {
      struct tcache_entry *next;
    } tcache_entry;
æ–°å®šä¹‰ï¼š
    /* We overlay this structure on the user-data portion of a chunk when
       the chunk is stored in the per-thread cache.  */
    typedef struct tcache_entry
    {
      struct tcache_entry *next;
      /* This field exists to detect double frees.  */
      struct tcache_perthread_struct *key;
    } tcache_entry;
æ„ä¹‰ï¼š
åŠ å…¥äº†é¢å¤–æŒ‡é’ˆ`key`ï¼Œå¯ä»¥ç”¨æ¥æ£€æŸ¥é“¾è¡¨å®Œæ•´æ€§ã€‚
### 2.åŠ å…¥`Tcache`æ•°é‡é™åˆ¶
åŸå§‹å®šä¹‰ï¼š
æ— 
æ–°å®šä¹‰ï¼š
    #define MAX_TCACHE_COUNT 127    /* Maximum value of counts[] entries.  */
æ„ä¹‰ï¼š
é™åˆ¶`Tcache`çš„æ•°é‡
### 3.`tcache_put`åŠ å…¥äº†æ–°æ­¥éª¤
åŸå§‹å®šä¹‰ï¼š
    /* Caller must ensure that we know tc_idx is valid and there's room
       for more chunks.  */
    static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx)
    {
      tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
      assert (tc_idx next = tcache->entries[tc_idx];
      tcache->entries[tc_idx] = e;
      ++(tcache->counts[tc_idx]);
    }
æ–°å®šä¹‰ï¼š
    /* Caller must ensure that we know tc_idx is valid and there's room
       for more chunks.  */
    static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx)
    {
      tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
      assert (tc_idx key = tcache;
      e->next = tcache->entries[tc_idx];
      tcache->entries[tc_idx] = e;
      ++(tcache->counts[tc_idx]);
    }
æ„ä¹‰ï¼š
ç°åœ¨ï¼Œå°†`chunk`ç½®å…¥`Tcache`ä¸­æ—¶ï¼Œå°†ä¼šæ–°å¢ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘`Tcache`ï¼Œç”¨äºæ£€æŸ¥`Double Free`ã€‚
### 4.`tcache_get`åŠ å…¥äº†æ–°æ­¥éª¤
åŸå§‹å®šä¹‰ï¼š
    /* Caller must ensure that we know tc_idx is valid and there's
       available chunks to remove.  */
    static __always_inline void *
    tcache_get (size_t tc_idx)
    {
      tcache_entry *e = tcache->entries[tc_idx];
      assert (tc_idx entries[tc_idx] > 0);
      tcache->entries[tc_idx] = e->next;
      --(tcache->counts[tc_idx]);
      return (void *) e;
    }
æ–°å®šä¹‰ï¼š
    /* Caller must ensure that we know tc_idx is valid and there's
       available chunks to remove.  */
    static __always_inline void *
    tcache_get (size_t tc_idx)
    {
      tcache_entry *e = tcache->entries[tc_idx];
      assert (tc_idx entries[tc_idx] > 0);
      tcache->entries[tc_idx] = e->next;
      --(tcache->counts[tc_idx]);
      e->key = NULL;
      return (void *) e;
    }
æ„ä¹‰ï¼š
ç°åœ¨ï¼Œå°†`chunk`ä»`Tcache`ä¸­ç§»é™¤æ—¶ï¼Œå°†ä¼šæ¸…ç©ºæ–°å¢çš„æŒ‡é’ˆã€‚
### 5.`int_free`ä¸­åŠ å…¥äº†æ–°æ£€æŸ¥
åŸå§‹å®šä¹‰ï¼š
    #if USE_TCACHE
      {
        size_t tc_idx = csize2tidx (size);
        if (tcache
        && tc_idx counts[tc_idx]  chance), so verify it's not an unlikely
               coincidence before aborting.  */
            if (__glibc_unlikely (e->key == tcache))
              {
                tcache_entry *tmp;
                LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
                for (tmp = tcache->entries[tc_idx]; tmp; tmp = tmp->next)
                  if (tmp == e)
                    malloc_printerr ("free(): double free detected in tcache 2");
                    /* If we get here, it was a coincidence.  We've wasted a
                       few cycles, but don't abort.  */
              }
            if (tcache->counts[tc_idx] = 3);
                  if (ncopies > 9)
                    memcpy (d, s, copysize);
                  else
                    {
                      *(d + 0) = *(s + 0);
                      *(d + 1) = *(s + 1);
                      *(d + 2) = *(s + 2);
                      if (ncopies > 4)
                        {
                          *(d + 3) = *(s + 3);
                          *(d + 4) = *(s + 4);
                          if (ncopies > 6)
                            {
                              *(d + 5) = *(s + 5);
                              *(d + 6) = *(s + 6);
                              if (ncopies > 8)
                                {
                                  *(d + 7) = *(s + 7);
                                  *(d + 8) = *(s + 8);
                                }
                            }
                        }
                    }
                  _int_free (av, oldp, 1);
                  check_inuse_chunk (av, newp);
                  return chunk2mem (newp);
                }
            }
        }
    .........
    }
æ–°å®šä¹‰ï¼š
    void* _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,
             INTERNAL_SIZE_T nb)
    {
    .........
              /*
                 Avoid copy if newp is next chunk after oldp.
               */
              if (newp == next)
                {
                  newsize += oldsize;
                  newp = oldp;
                }
              else
                {
                    memcpy (newmem, chunk2mem (oldp), oldsize - SIZE_SZ);
                  _int_free (av, oldp, 1);
                  check_inuse_chunk (av, newp);
                  return chunk2mem (newp);
                }
            }
        }
    .........
    }
æ„ä¹‰ï¼š
æ­¤å¤„ç”±åŸæ¥çš„é€ä½å¤åˆ¶ç›´æ¥å˜æ›´ä¸ºä½¿ç”¨`memcpy`ï¼Œå®ç°ä¸Šæ›´åŠ ç®€æ´ã€‚
### 7.`do_set_tcache_count`å‘ç”Ÿäº†å˜æ›´
åŸå§‹å®šä¹‰ï¼š
    static inline int __always_inline do_set_tcache_count (size_t value)
    {
      LIBC_PROBE (memory_tunable_tcache_count, 2, value, mp_.tcache_count);
      mp_.tcache_count = value;
      return 1;
    }
æ–°å®šä¹‰ï¼š
    static inline int __always_inline do_set_tcache_count (size_t value)
    {
      if (value <= MAX_TCACHE_COUNT)
        {
          LIBC_PROBE (memory_tunable_tcache_count, 2, value, mp_.tcache_count);
          mp_.tcache_count = value;
        }
      return 1;
    }
æ„ä¹‰ï¼š
é™åˆ¶`tcache_count`çš„æ•°ç›®å¿…é¡»å°äº`MAX_TCACHE_COUNT`(å³`127`)ï¼Œé˜²æ­¢å‘ç”Ÿæº¢å‡ºã€‚
## 0x04 å˜åŒ–æ€»ç»“
ä»¥ä¸Šå‡ å¤§å˜åŒ–åŸºæœ¬ä¸Šéƒ½æ˜¯é’ˆå¯¹çš„`Tcache`è¿›è¡Œçš„æ›´æ–°ï¼Œä¸”æ›´æ–°åçš„ä»£ç åŸºæœ¬`100%`ç…§æ¬`Glibc
2.31`çš„ä»£ç ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç›´æ¥åˆ©ç”¨`2.31`çš„æ€è·¯ï¼Œç›´æ¥ç¯¡æ”¹`key`æŒ‡é’ˆå°±å¯ä»¥å®Œæˆåˆ©ç”¨äº†ã€‚