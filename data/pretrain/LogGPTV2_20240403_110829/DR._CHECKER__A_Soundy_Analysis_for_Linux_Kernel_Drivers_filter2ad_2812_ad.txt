into kernel space.
1 # d e f i n e MLOG STR LEN
2 . . .
3 i n t m l o g d o r e a d ( c h a r
4 {
u s e r ∗ buf ,
s i z e t
l e n )
16
buf += s i z e ;
i += s i z e ;
}
}
family functions). An example of a previously un-
known buffer overﬂow, detected via ITDUD, is shown
in Listing 2.
Tainted Arithmetic Detector (TAD) checks for tainted
data that is used in operations that could cause an over-
ﬂow or underﬂow (e.g., add, sub, or mul). An example
of a zero-day detected by TAD is shown in Listing 3.
Invalid Cast Detector (ICD) keeps tracks of allocation
sizes of objects and checks for any casts into an object of
a different size.
Tainted Loop Bound Detector (TLBD) checks for
tainted data that is used as a loop bound (i.e., a loop guard
in which at least one of the values is tainted). These
bugs could lead to a denial of service or even an arbi-
trary memory write. The example in Listing 3 shows this
in a real-world bug, which also triggered on TAD.
1014    26th USENIX Security Symposium
USENIX Association
Listing 4: An information leak bug via padded ﬁelds de-
tected by our ULD in Mediatek’s FM driver where a
struct’s memory is not sanitized before being copied back
to user space leaking kernel stack data.
1 fm s32 f m g e t a u d i n f o ( f m a u d i o i n f o t ∗ d a t a )
2 {
( fm low ops . b i . g e t a u d i n f o ) {
r e t u r n fm low ops . b i . g e t a u d i n f o ( d a t a ) ;
i f
} e l s e {
d a t a ->a u d p a t h = FM AUD ERR ;
d a t a ->i 2 s i n f o . mode = FM I2S MODE ERR ;
d a t a ->i 2 s i n f o . s t a t u s = FM I2S STATE ERR ;
d a t a ->i 2 s i n f o . r a t e = FM I2S SR ERR ;
r e t u r n 0 ;
3
4
5
6
7
8
9
10
11
12
}
13 }
14 . . .
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
c a s e FM IOCTL GET AUDIO INFO :
a u d d a t a ;
i n i t i a l i z e d
f m a u d i o i n f o t
/ / ∗∗ no memset o f a u d d a t a ∗∗
/ / Not a l l
f i e l d s o f a u d d a t a are
r e t = f m g e t a u d i n f o (& a u d d a t a ) ;
( r e t ) {
i f
WCN DBG(FM ERR|MAIN, ” f m g e t a u d i n f o e r r \n ” ) ;
}
/ / Copying t h e
/ /
i f
from padding and u n i n i t i a l i z e d
f i e l d s
( c o p y t o u s e r ( ( v o i d ∗) arg , &a u d d a t a ,
s i z e o f ( f m a u d i o i n f o t ) ) ) {
WCN DBG(FM ERR|MAIN, ” c o p y t o u s e r
r e t = -EFAULT ;
g o t o o u t ;
e r r o r \n ” ) ;
s t r u c t
r e s u l t s
i n d a t a - l e a k a g e
}
. . .
Tainted Pointer Dereference Detector (TPDD) detects
pointers that are tainted and directly dereferenced. This
bug arises when a user-speciﬁed index into a kernel struc-
ture is used without checking.
Tainted Size Detector (TSD) checks for tainted data that
is used as a size argument in any of the copy to or
copy from functions. These types of bugs can result
in information leaks or buffer overﬂows since the tainted
size is used to control the number of copied bytes.
Uninit Leak Detector (ULD) keeps tracks of which
objects are initialized, and will raise a warning if
any src pointer for a userspace copy function (e.g.,
copy to user) can point to any uninitialized objects. It
also detects structures with padding [40] and will raise
a warning if memset or kzalloc has not been called on
the corresponding objects, as this can lead to an infor-
mation leak. An example of a previously unknown bug
detected by this detector is as shown in Listing 4
Global Variable Race Detector (GVRD) checks for
global variables that are accessed without a mutex. Since
the kernel is reentrant, accessing globals without syn-
cronization can result in race conditions that could lead
to time of check to time of use (TOCTOU) bugs.
5
Implementation
DR. CHECKER is built on top of LLVM 3.8 [30]. LLVM
was chosen because of its ﬂexibility in writing analy-
ses, applicability to different architectures, and excellent
community support. We used integer range analysis as
implemented by Rodrigues et al. [42]. This analysis is
used by our vulnerability detectors to verify certain prop-
erties (e.g., checking for an invalid cast).
We implemented DR. CHECKER as an LLVM mod-
ule pass, which consumes: a bitcode ﬁle, an entry
function name, and an entry function type.
It
then runs our SDT analysis, employing the various anal-
ysis engines and vulnerability detectors. Depending on
the entry function type, certain arguments to the
entry functions are tainted before invoking the SDT (See
Section 5.3).
Because our analysis operates on LLVM bitcode, we
must ﬁrst identify and build all of the driver’s bitcode
ﬁles for a given kernel (Section 5.1). Similarly, we
must identify all of the entry points in these drivers
(Section 5.2) in order to pass them to our SDT analysis.
Identifying Vendor Drivers
5.1
To analyze the drivers independently, we must ﬁrst dif-
ferentiate driver source code ﬁles from that of the core
kernel code. Unfortunately, there is no standard location
in the various kernel source trees for driver code. Making
the problem even harder, a number of the driver source
ﬁles omit vendor copyright information, and some ven-
dors even modify the existing sources directly to imple-
ment their own functionality. Thus, we employ a com-
bination of techniques to identify the locations of the
vendor drivers in the source tree. First, we perform a
diff against the mainline sources, and compare those
ﬁles with a referenced vendor’s conﬁguration options
to search for ﬁle names containing the vendor’s name.
Luckily, each vendor has a code-name that is used in all
of their options and most of their ﬁles (e.g., Qualcomm
conﬁguration options contain the string MSM, Mediatek is
MTK, and Huawei is either HISI or HUAWEI), which helps
us identify the various vendor options and ﬁle names. We
do this for all of the vendors, and save the locations of the
drivers relative to the source tree.
Once the driver ﬁles are identiﬁed, we compile them
using clang [51] into both Advanced RISC Machine
(ARM) 32 bit and 64 bit bitcode ﬁles. This necessi-
tated a few non-trivial modiﬁcations to clang, as there
are numerous GNU C Compiler (GCC) compiler op-
tions used by the Linux kernel that are not supported
by clang (e.g., the -fno-var-tracking-assignments
and -Wno-unused-but-set-variable options used
by various Android vendors). We also added additional
USENIX Association
26th USENIX Security Symposium    1015
compiler options to clang (e.g., -target) to aid our anal-
ysis. In fact, building the Linux kernel using LLVM is an
ongoing project [52], suggesting that considerable effort
is still needed.
Finally, for each driver, we link all of the dependent
vendor ﬁles into a single bitcode ﬁle using llvm-link,
resulting in a self-contained bitcode ﬁle for each driver.
5.2 Driver Entry Points
Linux kernel drivers have various ways to interact with
the userspace programs, categorized by 3 operations:
ﬁle [20], attribute [35], and socket [37].
File operations are the most common way of interact-
ing with userspace.
In this case, the driver exposes
a ﬁle under a known directory (e.g., /dev, /sys, or
/proc) that is used for communication. During ini-
tialization, the driver speciﬁes the functions to be in-
voked for various operations by populating function
pointers in a structure, which will be used to han-
dle speciﬁc operations (e.g., read, write, or ioctl).
The structure used for initialization can be different
there are at least 86
for each driver type.
different types of structures in Android kernels (e.g.,
struct snd pcm ops, struct file operations, or
struct watchdog ops [3]). Even worse, the entry
functions can be at different offset in each of these
structures. For example, the ioctl function pointer is
at ﬁeld 2 in struct snd pcm ops, and at ﬁeld 8 in
struct file operations. Even for the same struc-
ture, different kernels may implement the ﬁelds differ-
ently, which results in the location of the entry function
being different for each kernel. For example, struct
file operations on Mediatek’s mt8163 kernel has its
ioctl function at ﬁeld 11, whereas on Huawei, it ap-
pears at ﬁeld 9 in the structure.
In fact,
To handle these eccentricities in an automated way,
we used c2xml [11] to parse the header ﬁles of each
kernel and ﬁnd the offsets for possible entry function
ﬁelds (e.g., read or write) in these structures. Later,
given a bitcode ﬁle for a driver, we locate the different
ﬁle operation structures being initialized, and identify the
functions used to initialize the different entry functions.
Listing 5: An initialization of a ﬁle operations structure
in the mlog driver of Mediatek
1 s t a t i c
2 p r o c m l o g o p e r a t i o n s = {
f i l e o p e r a t i o n s
c o n s t
s t r u c t
. owner = NULL,
. l l s e e k = NULL,
. r e a d = mlog read ,
. p o l l = m l o g p o l l ,
. open = mlog open ,
. r e l e a s e = m l o g r e l e a s e ,
. l l s e e k = g e n e r i c f i l e l l s e e k ,
3
4
5
6
7
8
9
10 };
Entry Type
Read (File)
Write (File)
Ioctl (File)
DevStore (Attribute)
NetDevIoctl (Socket)
char *buf, size t len
char *buf, size t len
long arg
const char *buf
struct *ifreq
Direct
Direct
Direct
Indirect
Indirect
Indirect
Table 1: Tainted arguments for each driver entry function
type wether they are directly and indirectly tainted.
Argument(s)
Taint Type
V4Ioctl
struct v4l2 format *f
These serve as our entry points for the corresponding op-
erations. For example, given the initialization as shown
in Listing 5, and the knowledge that read entry func-
tion is at offset 2 (zero indexed), we mark the function
mlog read as a read entry function.
Attribute operations are operations usually exposed by
a driver to read or write certain attributes of that driver.
The maximum size of data read or written is limited to a
single page in memory.
Sockets operations are exposed by drivers as a socket
ﬁle, typically a UNIX socket, which is used to commu-
nicate with userspace via various socket operations (e.g.,
send, recv, or ioctl).
There are also other drivers in which the kernel
implements a main wrapper function, which performs
initial veriﬁcation of the user parameters and par-
tially sanitizes them before calling the corresponding
driver function(s). An example of this can be seen
in the V4L2 Framework [66], which is used for video
drivers.
For our implementation we consider only
struct v4l2 ioctl ops, which can be invoked by
userspace via the wrapper function video ioctl2.
5.3 Tainting Entry Point Arguments
An entry point argument can contain either directly
tainted data (i.e.,
the argument is passed directly by
userspace and never checked) or indirectly tainted data
(i.e., the argument points to a kernel location, which con-
tains the tainted data). All of the tainted entry point
functions can be categorized in six categories, which are
shown in Table 1, along with the type of taint data that
their arguments represent.
An explicit example of directly tainted data is shown
In this snippet, tc client ioctl is
in Listing 6.
an ioctl entry function, so argument 2 (arg) is di-
rectly tainted. Thus, the statement char c=(char*)arg
would be dereferencing tainted data and is ﬂagged
as a warning. Alternatively, argument 2 (ctrl) in
iris s ext ctrls is a V4Ioctl and is indirectly
tainted. As such,
the dereference (data = (ctrl-
>controls[0]).string) is safe, but it would taint
data.
1016    26th USENIX Security Symposium
USENIX Association