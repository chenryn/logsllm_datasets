for computation (where amongst other things parameters include a circuit description, or
code to be compiled). MATRIX can receive a script for automatically generating circuits
based on the number of parties, and then will provide the circuits of the correct size for
each experiment. This is important in real-world systems like MPSaaS, since the circuit
needs to be generated for the exact number of parties who are online when the experiment
starts. MATRIX takes care of this issue automatically. We stress that MATRIX can run
any MPC protocol, and it does not have to be circuit based (e.g., speciﬁc protocols like PSI
can be run, as well as SPDZ-like systems that generate gates to be computed on the ﬂy; in
fact, as we have mentioned, SPDZ-2 together with its run-time [12] is already incorporated
in MATRIX).
MATRIX receives an experiment conﬁguration ﬁle that deﬁnes a series of experiments
(executions). For each experiment, the number of repetitions is deﬁned, how many parties
participate, the location of the parties (cloud regions), the machine type for all parties,
and the protocol parameters (for example, the circuit that they execute if the protocol
is a circuit-based protocol). When spot (or low priority) instances are desired, then the
conﬁguration also includes the maximum price that you are willing to pay for the instances
(in the cloud bidding scheme).1
The MATRIX binding to a speciﬁc cloud vendor is abstracted to a small layer of the
code, and can be deployed to any vendor providing a complete automation API. MATRIX
was ﬁrst deployed in AWS, and the time to port it completely to Azure (using Azure CLI
2.0) was just 2 person days.
Monitoring, result collection, reporting and fault handling: MATRIX monitors
the execution of the MPC program across all the hosts, and detects exit signals that
indicate cheat detection, protocol breach or simply machine failure. In addition, the system
collects MPC logs written during the protocol execution (according to the format in the
contract). Such logs typically include micro-benchmarking of the diﬀerent protocol phases.
For example, it is possible to measure the times for peer-2-peer communication setup,
the input sharing phase, online computation, and so on. The granularity of the logs and
measurements taken is at the full discretion of the protocol, and typically includes running-
time and actual bandwidth sent and received. MATRIX also automatically measures the
memory usage of each machine.
1Although the system receives a maximum price, in AWS it begins by checking the latest winning price
for the instances desired, and bids that price ﬁrst, if it is lower. By experience, in almost all cases, the last
winning price was suﬃcient, resulting in considerable cost savings.
13
All of the results are recorded by MATRIX in an ElasticSearch database, which en-
ables users to review performance dashboards and compare the performance of diﬀerent
protocols, running on diﬀerent machines in diﬀerent regions and so on, using a tool like
Kibana; see Figure 3 for an example. MATRIX also generates spreadsheet reports for
post-execution analysis.
Figure 3: MPC analytics using Kibana.
2.3 MPSaas Administration Component
The MPSaaS Administrator component is used to create, manage and execute MPC pro-
tocols as desired. The MPSaaS administrator is the party who initiates the execution, and
invites participants. In the PrivatePoll example, this could be an HR consulting company
authoring Salary Polls, or it could be a researcher wishing to survey gender wage gap. The
administrator can purchase these services from an MPC-CSP (service provider) or may act
itself as a service provider using the open source platform. We stress that the administrator
has no access to private inputs, since each participating party runs the MPC protocol lo-
cally, and thus need not be trusted at all. The administrator component contains all of the
capabilities necessary to manage the MPC executions, and is connected to the administra-
tion capabilities of the MATRIX system. In Figure 4, you can see the administrator page
for creating new executions (in our speciﬁc example of PrivatePoll these are all polls) and
viewing the status of active ones. The administrator can also see the results of completed
polls.
14
Figure 4: The main admin page for MPSaaS.
In Figure 5, you can see the administrator page for creating or editing a poll. In our
Proof-Of-Concept (POC) implementation, each poll includes a single numeric private input
( such as “salary”).
Figure 5: The poll create/edit page.
The result type governs the circuit chosen to evaluate the functionalilty. For our POC,
the “Basic” option deﬁnes a circuit that evaluates the mean and variance, whereas the
“Histogram” result would require a circuit that also sorts or buckets the input values.
15
We stress that any reasonable MPC solution would also include a minimal number of
participants (enforced as part of the protocol) in order to provide privacy. (it is also possible
to include diﬀerential privacy guarantees by adding the required noise to the result inside
the MPC; by adding the noise to the result and not to the input, far higher accuracy can be
achieved. The best way to do this is left to future work.) Although very basic, we remark
that this already suﬃces for achieving quite general results. In particular, a general study
of gender wage gap can be carried out by deﬁning a diﬀerent poll for each sector/years
of experience/sex, and then obtaining the results for each set separately. Since only the
salary needs to be protected, this suﬃces.
Finally, the administrator page also includes the option to view information about the
uses registered to the poll; see Figure 6. As a matter of policy, this page can be open to
all participants to view, depending on the desired result. Speciﬁcally, in many cases, the
parties’ input is private but the fact of their participation need not be. In these cases, it
is useful to allow all parties to view who is registered, to ensure that their private input is
really protected under a large aggregation. For simplicity and a seamless login ﬂow, the
basic login functionality in the POC is carried out simply using a Google of Facebook ID.
Additional attributes may be added to users by creating an extended user proﬁle, if this is
desired.
Figure 6: The user participation page.
We stress that none of the above is a recommendation as to how to run a secure MPC
system for polling. This depends exactly on the use case, and is an orthogonal issue. Here,
we merely demonstrate the capabilities of the system.
2.4 MPSaas End-User Component
The end-user component is used for actually running the MPC protocol. Although some
MPC executions have been demonstrated on a mobile platform (e.g., [17]), they are limited
and do not include a rich variety of MPC protocols. Since realistic end-user execution
is essential for achieving true peer-2-peer MPC, enabling Mobile, IOT and in-browser
general MPC execution is a cornerstone of this research. We reviewed available open-source
implementations of MPC and found that none work on our platforms. For example, for
oblivious transfer, neither LibOTE, SimpleOT or any TinyOT implementations are available.
16
It is of course possible to simply reimplement any MPC protocol for mobile and browser
environments. However, this is very time consuming and an obstacle to deployment. We
therefore searched for general techniques that can be reused to help port existing MPC
code to mobile devices and browser. We report on these techniques and the challenges
encountered in Appendix A.
2.5 PrivatePoll End User Workﬂow
In this section, we describe the user experience in participating in an MPSaaS secure
multiparty computation, via their mobile phone (after having installed the PrivatePoll
mobile app). Users are notiﬁed of existing polls via any standard means. In order to join
a poll, the user logs in using an existing Google or Facebook account, at which point she
is presented the available and completed polls. The user can view completed polls she has
participated in previously, and can see active polls. For each active polls, the user may
view how many users are registered (see the middle screen in Figure 7 and the number
next to the “active” button), and the poll open date and time. The user may then select
to join a poll. See Figure 7 for this ﬂow.
Figure 7: The user login, poll status, and poll join pages.
Once the user selects to join an active poll, she is prompted to select her participation
mode. The online mode refers to running a mobile or browser instance (which requires
her to be online when the poll begins), whereas the oﬄine mode refers to using a cloud
instance. We stress that the cloud instance is always online, thereby allowing the user
17
herself to be oﬄine during the actual MPC execution. If the user selects online mode, then
her request is registered and a notiﬁcation will be sent to her to login and input her private
value prior to the poll. We stress that the MPSaaS system generates the circuit at the
time of the actual execution, so if a user does not actual come online, this will not prevent
the poll from proceeding.
If the users selects to be oﬄine, then she can choose to either use a hosted instance or
her own instance; see Figure 8.
Figure 8: The user instance generation pages.
It is always preferable for a user to choose her own instance, and in this case the user
is directed to connect a Docker instance. This Docker instance can be in her own AWS
account, or the AWS organizations service can be used. This service enables the service
provider (MPSaaS) to set a policy and have users create accounts via the service provider,
with the policy transparent to the user. This policy can be set to only allow the provider
to monitor usage, thereby preventing the MPSaaS administrator from viewing the data.
(Future versions will allow cross-cloud instances so that users are not required to rely on
AWS or Azure or any single cloud provider.) If the user insists on not setting up her own
instance, then she can choose a hosted instance which is run by the poll administrator. This
is clearly not recommended, but may be chosen by a participant who does not consider the
poll information to be private (e.g., a faculty member of a public university in the USA,
whose salary is anyway public record). In this latter case, the image of a separate instance
is automatically deployed for the speciﬁc user, on the administrator’s AWS account. This
18
image includes a user facing mini web-server, which will serve the user granted access to the
instance (this can be extended so that the user receives an out-of-band one-time-password
to login, or some other method).
Figure 9: The input/output pages.
In oﬄine mode executions, the user is immediately redirected to the registered instance
to enter her input (left screen in Figure 9). In online mode executions, the user is sent
a reminder just before the execution begins, at which point she can enter her input and
get output (middle screen in Figure 9).
In all cases, the user receives the computation
result to her mobile app, providing additional motivation for participating (right screen in
Figure 9).
3 The HyperMPC Protocol
3.1 Preliminaries
3.1.1 Model
We consider a set P of n parties, P = {P1, . . . , Pn}, who are connected by a complete
network of secure (private and authentic) channels.
We consider a computation over any ﬁnite ﬁeld F with |F| > 2n. To every party Pi ∈ P
a unique, non-zero element αi ∈ F \ {0} is assigned (e.g. the i-th element in F). We stress
19
that HyperMPC is perfectly secure, and thus there is no need to work in a large ﬁeld (this is
in contrast to statistically secure protocols that have a basic error of 1/|F| and thus need to
repeat checks in case F is small, making the complexity higher). We also remark that since
we can work over any ﬁeld, Boolean circuits can be embedded into GF [2k] for the smallest
k such that 2k > 2n. In this case, as long as we verify that all input values are either 0
or 1, it follows that ﬁeld addition is equivalent to Boolean XOR and ﬁeld multiplication is
equivalent to Boolean AND.
The function to be computed is speciﬁed as an arithmetic circuit over F, with input,
addition, multiplication, random, and output gates. A random gate is simply a gate
that outputs a random value;
it is always possible to generate randomness by adding
random inputs provided by the parties, but dedicated random gates can be computed
more eﬃciently. We denote the number of gates of each type by cI , cA, cM , cR, and cO,
respectively.
We consider a malicious adversary who can corrupt up to t parties for any ﬁxed t with
t  0,
R is invertible, where MR denotes the matrix consisting of the rows i ∈ R of
the matrix M C
20
M , M C denotes the matrix consisting of the columns j ∈ C of M , and M C
R = (MR)C.
A hyper-invertible r-by-c matrix M can be constructed as
M = {λi,j} i=1,...,r
j=1,...c
with λi,j =
c(cid:89)
k=1
k(cid:54)=j
βi − αk
αj − αk
,
where α1, . . . , αc, β1, . . . , βr are ﬁxed distinct elements in F (and |F| ≥ c+r). The mappings
deﬁned by hyper-invertible matrices have a very nice symmetry property: Any subset of n
input/output values can be expressed as a linear function of the remaining n input/output
values:
Lemma 3.1 ([5]) Let M be a hyper-invertible n-by-n matrix and (y1, . . . , yn)T = M ·
(x1, . . . , xn)T .2 Then for all index sets A, B ⊆ {1, . . . , n} with |A| + |B| = n, there exists
an invertible linear function f : Fn → Fn, mapping the values {xi}i∈A,{yi}i∈B onto the
values {xi}i /∈A,{yi}i /∈B.
More details and proofs can be found in [5, Section 3].
An intuitive explanation. The power of a hyper-invertible matrix can best be demon-
strated in the linear mapping induced by the matrix. We say that a matrix M with r
rows and c columns induces a linear mapping fM , which takes as input c values x1, . . . , xc,
and computes as output r values y1, . . . , yr, such that (y1, . . . , yr)T = M · (x1, . . . , xc)T . In
other words, for any c input values x1, . . . , xc, the mapping deﬁnes the corresponding out-