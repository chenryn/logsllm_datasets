mcf
CPU
CPU
vpr
CPU
twolf
syscall & CPU Gnu C compiler from SPEC INT 2000
gcc
vortex
syscall & CPU Object oriented database from SPEC INT 2000
syscall
pyramid
gzip
syscall
Description
ﬁle compression program from SPEC INT 2000 benchmark.
ﬁle compression program from SPEC INT 2000 benchmark.
Game playing (Chess) program from SPEC INT 2000 benchmark
combinatorial optimization program from SPEC INT 2000
FPGA circuit and routing placement from SPEC INT 2000
Place and route simulator from SPEC INT 2000
Multidimensional database index creation
ﬁle compression program
Table 5. Benchmark suite
Authenticated
Program
Original
Authenticated
Time Std. Time
(secs)
(secs)
198.56
196.80
156.39
155.38
108.39
108.32
244.96
240.96
221.25
228.25
402.59
389.97
93.97
92.88
3.91
3.80
0.99
1.02
2.82
2.78
Dev.
1.46
0.14
0.15
8.22
1.24
5.58
1.19
0.01
0.01
0.03
Std. Overhead
Dev.
2.67
0.19
0.27
1.35
3.38
8.38
0.74
0.01
0.01
0.03
(%)
0.89
0.65
0.06
1.66
3.16
3.24
1.17
2.89
3.03
1.01
1.78
bzip2
gzip-spec
crafty
mcf
vpr
twolf
gcc
vortex
pyramid
gzip
Average
Table 6. Performance overhead
of executables were created: unauthenticated binaries cor-
responding to the unmodiﬁed program and authenticated
binaries that use authenticated system calls. We use unau-
thenticated binaries generated by PLTO rather than simply
gcc as the baseline, since PLTO itself applies certain opti-
mizations such as dead code elimination, basic block lay-
out, and instruction scheduling. As a result, applying these
optimizations in both cases gives the most accurate repre-
sentation of the actual cost of an authenticated call. The cost
of transforming the programs including PLTO optimizations
ranged from 3.19 seconds for mcf to 85.37 seconds for gcc.
Our experiment consisted of measuring the time taken
for each program to execute on a ﬁxed set of inputs. The
time utility was used to measure the time taken by each
program, with the total computed as the sum of the user and
system time. As before, each experiment was repeated 12
times; the highest and lowest readings were discarded, and
the average of the remaining 10 readings is used in the table.
The results, reported in table 6, indicate a modest overhead
ranging from 0.06% to 3.24%.
Our ﬁnal experiment studies the effect of the authenti-
SystemCall
getpid()
gettimeofday()
read(4096)
write(4096)
brk()
rdtsc cost
loop cost
Original
Cost
(cycles)
1141
1395
7324
39479
1155
84
4
Overhead
(%)
342.2
308.8
36.7
2.3
340.1
Cost
(cycles)
5045
5703
10013
40396
5083
84
4
Table 4. Effect of authentication
cate the overhead of the measurement process itself. Each
experiment was repeated 12 times; the highest and lowest
readings were discarded, and the average of the remaining
10 readings is used in the table. Column 2 gives the num-
ber of cycles required to execute an unmodiﬁed system call
on an unmodiﬁed kernel, while columns 3 and 4 show the
effect of authenticated system calls.
The results indicate a noticeable cost for the checking
mechanism, about 4000 cycles for each call. As might be
expected, however, on a percentage basis, the overhead is
much more signiﬁcant for simple system calls such as get-
pid and gettimeofday than for more complex calls like write,
where the costs associated with buffering and memory ac-
cesses dominate.
To measure the effect of these techniques on the over-
all performance of applications, we compared the running
times of 10 programs and their protected counterparts (ta-
ble 5). These programs can be classiﬁed as either CPU
or system call intensive, as shown in the table; the CPU-
intensive programs are from the SPECint-2000 benchmark
suite, while the system call intensive programs are a col-
lection of common applications that make a large number
of system calls. The programs were compiled using gcc
3.2.2 into statically linked relocatables that were then pro-
cessed using our binary rewriting system, PLTO. Two types
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:08:19 UTC from IEEE Xplore.  Restrictions apply. 
cation mechanism on a multi-program benchmark. This
benchmark is similar to the Andrew Benchmark and con-
sists of a series of tasks that perform routine operations
such as ﬁle creation, directory creation, ﬁle compression,
ﬁle archival, permission checking, moving ﬁles, deleting
ﬁles, and sorting the content of ﬁles. Each iteration of the
benchmark results in the invocation of about 12000 sys-
tem calls. Authenticated versions of several general pur-
pose tools such as gzip, gunzip, rm, chdir, mv, chmod, tar,
cat, and cp were used to perform the tasks. The execution
time of the benchmark using original binaries was 258.68
seconds, while the execution time for authenticated binaries
was 261.50 seconds, an increase of only 1.09%.
It is difﬁcult to compare the overhead of authenticated
system calls with other system call monitors because each
system enforces different policies. Note, however, that the
total overhead of our approach is well below that of other
systems, even though we do policy checking on all system
calls, unlike, for example, Systrace [15] and Ostia [5].
4. Improving Policies
This section describes techniques for making policies
more expressive to allow, for example, more complete ar-
gument coverage. We have not yet implemented these tech-
niques, but we anticipate that they will all be relatively
straightforward extensions to the existing system.
Meta-policies and policy templates. An ASC meta-
policy is a speciﬁcation that dictates how strict a policy is
required for each system call. In particular, for each sys-
tem call, the meta-policy indicates whether the call site must
be speciﬁed in the policy and which arguments of the sys-
tem call must be constrained. Compared with our basic ap-
proach, meta-policies focus on what must be protected for a
system call rather than what can be protected automatically
based on static analysis. Meta-policies would typically be
derived from the threat level of different system calls [2]
and local administrative policies.
The meta-policy is given as input to the installer along
with the original program (ﬁgure 3). If the policy generator
cannot determine all the argument values required by the
meta-policy based on static analysis, it generates a policy
template with spaces for the additional required arguments.
An administrator can then hand-specify a value or a pattern
(e.g., “/home/smith/www/*”) for an argument based on ap-
plication knowledge or dynamic proﬁling. The result of this
is the complete ASC policy, which is used during the rewrit-
ing phase by the installer.
Patterns in meta-policies are implemented by having the
installer store the patterns in the program address space.
Patterns are protected and handled like constant value
strings: patterns are stored in the read-only text segment
meta−policy
policy
template
complete
policy
key
original
program
policy
generation
rewriting
protected
program
Trusted Installer
Figure 3. Meta-policies and policy templates
and the address of the pattern is included in the policy de-
scriptor that is protected by the MAC. The kernel checks
the MAC to verify that the policy and the patterns have not
been modiﬁed, and uses standard pattern matching routines
to match the argument runtime value against the pattern.
Or, program checking techniques might be used to do the
pattern matching in the untrusted application, with a quick
veriﬁcation by the kernel.
Meta-policies also play a role in extending authenticated
calls to handle dynamic libraries. With dynamic libraries,
system call sites for calls within the library are not known
until the library is loaded at runtime. This means that our
basic approach cannot protect the call site from alteration
using a MAC, as is done with statically-linked binaries. In
addition, arguments used by system calls in dynamic li-
braries are often passed as arguments to library functions,
meaning that their values cannot be determined by static
analysis.
Dynamic libraries are processed based on the security
requirements stated in the meta-policy as follows. The dy-
namic libraries on a machine are installed ﬁrst before the ap-
plication programs. During this process, if a system call in
a dynamic library function cannot satisfy the meta-policy—
that is, static analysis cannot generate a complete policy—
the speciﬁc function is removed from the dynamic library
and set aside for static linking with application programs
that require the function. Once this has been done for all
system calls in the library, the functions that remain have
their system calls transformed into authenticated calls in the
same manner as before. Functions in this new protected dy-
namic library can then be loaded at runtime. Note that since
a single meta-policy is used for the installation of each dy-
namic library, it must be something that is appropriate for
all applications that use that library on a given machine.
Policies with state. Another useful feature is to allow
policies that rely on state of some sort. For example, one
might want a policy that requires that each call to open must
be followed by a close before open can be called again.
Here, the state would be a boolean indicating whether open
is allowed. The state variable would be checked and modi-
ﬁed by the syscall checker when an open is called, and mod-
Proceedings of the 2005 International Conference on Dependable Systems and Networks (DSN’05) 
0-7695-2282-3/05 $20.00 © 2005 IEEE
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:08:19 UTC from IEEE Xplore.  Restrictions apply. 
iﬁed again when close is called.
An obvious way to support policy state is to store the
state in the kernel. However, one of the virtues of authen-
ticated system calls is that they require minimal change to
the kernel, something that would be lost if the state is large
or has a complex structure. Therefore, we would like a way
to keep any policy state in the application itself, with only
the updates and maintenance being done by the kernel.
This can be achieved using the idea of on-line memory
checkers, where a data structure is stored in unreliable mem-
ory, and a trusted checker with a small amount of reliable
memory veriﬁes the correctness of each update as it oc-
curs [3]. Assume that some per-process state in the form
of a byte string is required to implement policy state. Then,
we modify the basic authenticated system call approach as