###  攻击模式
尽管有一些明显的方法，可以针对这样的设计发起攻击，例如通过USB的方式从连接的PC中传输恶意代码。但是，如果我们能尝试一种自包含的攻击（例如：供应链攻击），这样会更有趣。  
我选择的方法是“压缩”代码。考虑到执行时间、内存使用量和代码大小之间的权衡，我们不可能使用诸如DEFLATE或LZMA之类的压缩算法。如果使用这些算法，用户就会发现他们的钱包在20秒后才能启动。  
尽管压缩整个闪存空间的方案是可以实现的，但我并不想更换保存在闪存之中的MCU引导程序。其原因在于，有两种方法可以在设备上安装新固件：  
1、使用JTAG，嵌入式固件开发人员所使用的调试接口可以上传新的固件；  
2、使用引导加载程序（Bootloader），这也是Ledger用户用于安装固件更新的方法，大家可以在GitHub上找到由Ledger提供的Python工具（
 ）。  
第二种方式也是我在使用的方法。但如果我在刷入新引导程序过程中出现错误，那么该方法将会失败，只能通过使用JTAG接口来恢复。  
因此，更换引导加载程序（Bootloader）并不是一个合适的选项，我们必须排除掉不能用的压缩方案。  
然而，还存在着另外一种方法。在编译C程序时，工具链（编译程序的软件套件）会执行许多内容，从而使全部任务都能成功完成。例如，许多处理器并没有用于划分较大数字的指令，编译器会通过插入除法操作的软件来解决这一问题。另一个例子是，在为函数中定义的变量声明初始值时，当函数被调用，编译器会在开始时插入额外的代码，用于将数据复制到堆栈中。  
编译器插入执行这些任务的额外函数，被称为“编译器内在函数”。由于MCU同时具有引导加载程序和固件，并且它们是完全独立的程序，所以这些内在函数将在闪存中出现两次，每个程序中只出现一次。  
这样一来，我们就可以插入恶意例程，用来代替编译器intrinisc例程的一个冗余副本（特别是固件中的副本）。这样一来，我们在引导加载程序中就保留了完整的代码副本。  
由于引导加载程序中的原有内容与固件中的内容完全相同，因此当SE向MCU询问其闪存内容时，我们可以通过删除恶意代码并将其从引导加载程序发送给代码，从而“拼凑”出正确的映像。当固件需要使用原有内容时，我们可以跳转到引导加载程序中的原有内容。  
如果你是自行实验，在根据源代码构建引导程序和固件后，可以使用此命令来查找想要的符号。
    nm -S --size-sort -t d bin/token | grep -i " t "
通过该命令，我发现了一些引导加载程序和固件中都一致的符号。毫无疑问，这些都是编译器内在函数。
    134228637 00000124 T memcpy
    134228761 00000140 T memset
    134228357 00000266 T __udivsi3
为了实际使用我们隐藏的恶意代码，我们将不得不对其他功能进行挂钩。我们通过在想要定位的函数中插入到有效载荷的分支来实现。
这就需要将发送闪存内容的函数挂钩到SE，以便发送引导加载程序中的函数，而不是我们的恶意代码。  
我也会对绘制到屏幕上的函数进行挂钩，从而就可以进行各种有趣和令人兴奋的操作。其中就包括，改变显示的比特币地址以及修改键盘记录密码的内容，我会在稍后进行解释。  
用这两个钩子和__udivsi3作为我们的攻击向量，这就是我们所说的漏洞的攻击方式。
通过该方式，我们可以释放258字节的有效载荷。所以，即使我们是想将memcpy和memset放入，也需要对大小进行优化。
## 漏洞利用
我们的有效载荷共需要两部分：  
1、修改发送给SE的闪存内容代码，以欺骗验证过程；  
2、诸如键盘记录器、密钥生成后门等攻击。  
既然我们的漏洞利用方式中无法对SE进行攻击，那么我们如何添加后门呢？  
Ledger的SE固件拥有用户界面应用程序，它负责仪表盘显示和设置功能。同时，它也会用于生成恢复种子的初始过程。  
如果我们可以修改用户界面，就可以修改在最开始生成的恢复种子。这一过程很简单，原因在于用户界面是开源的，并且Ledger允许用户安装修改后的UX应用程序。  
在正常情况下，设备会显示“用户界面不是官方的“警告，任何一位仔细的用户在看到这个提示后都会敲响警钟。  
但回顾之前的内容·，我们可以控制显示屏所显示的内容，从而就可以简单地隐藏掉非官方UX的警告。  
在这个演示中，我们不会进行攻击者真正会执行的行为，例如产生一个看起来随机但实际上完全可预测的恢复种子，我们将会进行一些更为直观的操作。
    diff --git a/src/bolos_ux_onboarding_3_new.c b/src/bolos_ux_onboarding_3_new.c
    index ce1849c..b950ae7 100644
    --- a/src/bolos_ux_onboarding_3_new.c
    +++ b/src/bolos_ux_onboarding_3_new.c
    @@ -395,7 +395,7 @@ void screen_onboarding_3_new_init(void) {
     #else
         G_bolos_ux_context.onboarding_kind = BOLOS_UX_ONBOARDING_NEW_24;
    -    cx_rng((unsigned char *)G_bolos_ux_context.string_buffer, 32);
    +    os_memset(G_bolos_ux_context.string_buffer, 0, 32);
         G_bolos_ux_context.words_buffer_length = bolos_ux_mnemonic_from_data(
             (unsigned char *)G_bolos_ux_context.string_buffer, 32,
             (unsigned char *)G_bolos_ux_context.words_buffer,
如果你熟悉C语言，就会注意到我正在用一个函数调用，来将随机数生成器的系统调用替换为一个函数调用，并将所有的熵设置为零。正如大家在文章中视频所看到的那样，它会生成一个恢复种子，其中前23个字不被使用（最后一个字有所不同，作为校验和）。  
由于私钥来源于恢复种子，因此如果我们控制恢复种子，就可以控制设备生成的所有比特币地址。  
如果我们结合上述内容，就会创造出这种非常有效的攻击方式。
当然，由于SE认为MCU在运行的是正版固件，所以可以通过认证。正如我前面提到的那样，我们不需要进行硬件篡改，就可以破坏Ledger的完整性。
由于攻击者可以控制可信任显示屏和硬件上的按钮，因此要检测到这一漏洞是非常困难的。
## 漏洞修复
Ledger采取了多种缓解措施，试图阻止攻击者利用此漏洞。  
首先，MCU固件已经过优化和重新安排。具体而言，固件调用引导加载程序中的函数，而不是复制函数。虽然这可以防止特定的攻击模式，但我们知道，还存在其他的攻击方法，可能是我们所不知的。  
其次，在SE要求MCU发送闪存中的内容时，SE会将MCU进行计时。这是为了防止使用压缩算法而设计的。它也可以防止计算机通过USB方式向固件中添加代码。由于代码可以保存在RAM中，因此我不太确定后者的详细完成方式。  
但是，需要注意的是，SE运行频率达28MHz，而MCU运行频率高达80MHz。这就引发了一个问题，就是一个较慢的芯片是否能对一个更快的芯片进行准确计时，以防止它执行额外的内容，特别是在慢速UART通信的前提下。  
Ledger拒绝提供更详细的资料，因此我没有机会验证这些缓解措施是如何修复漏洞的。  
然而，是否真的有可能使用时序和“难以压缩”固件的组合来实现该模型中的安全性呢？  
使用这个模型来构建安全系统是一个非常令人兴奋的建议，我认为Ledger需要推动这一趋势的发展。
## 与Ledger的沟通
在计划披露此漏洞之前，我曾与Ledger的首席执行官进行过沟通，大家可以在archive.is和archive.org上面找到其主要评论的归档副本，以防止因为一些原因而消失。  
由于Ledger的一些评论是主观的，而还有一些更具有事实性，因此下面我将讨论一些这些评论。  
我想要解决的第一个问题就是，在文档中，这些漏洞可能需要一系列令人难以置信的前提条件。  
根据Saleem报告的漏洞，我们需要在设置种子之前先物理访问设备，安装MCU固件的自定义版本，在目标计算机上安装恶意软件并让用户点击一个特定的按钮。  
我对这种方法的来源感到困惑。在后来的沟通过程中，我被告知当他们在Reddit上发表这些内容时，首席执行官根本不知情这些漏洞的存在。  
正如我在文章开头所说的那样，有三种方法可以利用这一漏洞，其中有一种方案所需的条件较为简单。  
我之前提到的恶意软件攻击向量，就能很好地引出我与Larchevêque评论相关的一个问题。  
当出现严重的安全问题时，可以选择下面两种缓解/修复方式之一。
###  完全隐藏安全修复程序
这是一种避免引起黑帽子关注的有效方法，如果我们的产品是闭源的，那么就可以实现。  
但这也有缺点，大多数用户考虑到时间、性能等问题，会避免进行更新。
###  提醒用户关键安全问题并强制更新
这通常用于开源产品，或者是供应商怀疑野外已经有安全漏洞的利用时。  
然而，其缺点在于，这样的提醒会提示黑帽黑客。因此，用户必须立即更新，以获得先发制人的优势。  
Ledger采用了一种有缺陷的方案，他们采用了两个方法中最糟糕的一个。由于会将重点放在固件更新中的安全修复程序，而不是提醒用户进行攻击，就会失去先发制人的优势。  
这样一来，黑帽黑客就有足够的时间来确定如何利用风险，从而使所有用户都面临恶意软件的攻击威胁。  
我的担忧被证明是正确的，因为我已经在固件更新中看到了相应的说明。
## 时间节点
2017年11月11日：向Ledger CTO Nicolas Bacca正式报告漏洞；  
2017年11月14日：采用改进的MCU固件和用户界面，来演示实际的供应链攻击。将代码发送给Bacca。  
2017年12月30日：通过将固件降级为不支持的版本来更新Ledger Nano S。  
2018年3月6日：Ledger发布Ledger Nano的固件更新。  
2018年3月20日：发布Write-up和PoC代码。  
Ledger Blue在本文撰写之前尚未发布固件更新。
## 致谢
感谢Josh Harvey为我提供Ledger Nano S设备，因此我可以将理论上的攻击方式实际实践一遍。同时感谢Matthew Green、Kenn
White和Josh Harvey在我撰写本文的过程中提供的宝贵帮助。