AddressSanitizer [36] also uses a quarantine pool,
though with a FIFO reuse order, among other techniques.
PageHeap [2] places freed pages in a quarantine, with the
read/write page permissions removed. Attempted reuse
will be detected only if the page has not yet been reallo-
cated, so it may miss some attacks. These defenses can
also be defeated by exhausting the heap.
Microsoft’s MemoryProtection consists of Delayed
Free (similar to a quarantine) and Isolated Heap (which
separates normal objects from “critical” objects) [8].
Both of these defenses can be bypassed [22].
Cling [11] only reuses memory among heap objects of
the same type, so it ensures type-safe heap memory reuse
but not full heap temporal memory safety.
7.4 Limiting the Damage from Exploits
Rather than attempting to enforce memory safety en-
tirely, which may be considered too expensive, some ap-
proaches have focused on containing the exploit.
Often the goal of exploiting a user-after-free vulnera-
bility is to hijack the control ﬂow, such as by modifying
function pointers per our introductory example. One de-
fense is control-ﬂow integrity (CFI) [10], but recent work
on “control-ﬂow bending” [16] has shown that even the
ideal CFI policy may admit attacks for some programs.
Code pointer integrity (CPI) is essentially memory safety
(spatial and temporal) applied only to code pointers [26].
Code pointer separation (CPS) is a weaker defense than
CPI, but stronger than CFI. Both CPI and CPS require
compiler support.
CFI, CPS and CPI do not help against non-control
data attacks, such as reading a session key or changing
an ‘isAdmin’ variable [17]; recently, “data-oriented pro-
gramming” has been shown to be Turing-complete [24].
8 Limitations and Future Work
Oscar is only a proof-of-concept for measuring the over-
head on benchmarks, and is not ready for production, pri-
marily due to the following two limitations.
Reclaiming page-table memory takes some engineer-
ing, such as using pte free(). Alternatively, the Linux
source mentions they “Should really implement gc for
free page table pages. This could be done with a ref-
erence count in struct page.”15 Not all page-tables can
be reclaimed, as some page-tables may contain entries
for a few long-lived objects, but the fact that most ob-
jects are short-lived (the “generational hypothesis” be-
hind garbage collection) suggests that reclamation may
be possible for many page-tables. Note that the memory
overhead comparison in Section 4.3 already counts the
size of paging structures against Oscar, yet Oscar still
has lower overall overhead despite not cleaning up the
paging structures at all.
We did not encounter any issues with users’ mmap re-
quests overlapping Oscar’s region of shadow addresses
(or vice-versa), but it would be safer to deterministically
enforce this by intercepting the users’ mmap calls.
Currently, all threads share the same high-water mark
for placing new shadows, and this high-water mark is
protected with a global mutex. A better approach would
be to dynamically partition the address space between
threads/arenas; for example, when a new allocator arena
is created, it could split half the address space from
the arena that has the current largest share of the ad-
dress space. Each arena could therefore have its own
15http://lxr.free-electrons.com/source/arch/x86/include/asm/pgalloc.h
830    26th USENIX Security Symposium
USENIX Association
high-water mark, and allocations could be made inde-
pendently of other arenas. This could lower the overhead
of the memcached benchmarks, but not the SPEC CPU
benchmarks (which are all single-threaded).
Our techniques could be applied to other popular
memory allocators (e.g., tcmalloc), or more generally,
any custom memory allocator. The overheads reported
for SPEC CPU are based on instrumenting the standard
malloc/free only, providing a level of protection simi-
lar to prior work. Wrapping CMA’s provides more com-
prehensive protection, though the overheads would be
higher for a few benchmarks, as discussed in Section 5.2.
If we are willing to modify internal malloc, Os-
car can be selective in how to refresh (or batch-create)
shadows. For example, objects that are small enough
(among other conditions) to ﬁt in internal malloc’s
“small bins” are reused in a ﬁrst-in-ﬁrst-out order, which
means that a speculatively created shadow is likely to be
used eventually. Other bins are last-in-ﬁrst-out or even
best-ﬁt, which makes their future use less predictable.
This optimization may particularly beneﬁt xalancbmk
and dealII, for which the ordinary refresh shadow ap-
proach was a net loss.
We could take advantage of the short-lived nature of
most objects to experiment with placing multiple objects
per shadow; fewer shadows means lower runtime and
memory overhead. To further reduce memory overhead,
we could change internal malloc to place the canon-
ical address ﬁeld at the start of each page, rather than
the start of each object. All objects on the page would
then share the canonical address ﬁeld, which could dras-
tically reduce the memory overhead for programs with
many small allocations (e.g., soplex).
9 Conclusion
Efﬁcient, backwards compatible,
temporal memory
safety for C programs is a challenging, unsolved prob-
lem. By viewing many of the existing schemes as lock-
and-key, we showed that page-permissions-based pro-
tection schemes were the most elegant and theoretically
promising. We built upon Dhurjati and Adve’s core idea
of one shadow per object. That idea is unworkable by it-
self due to accumulation of vm area structs for freed
objects and incompatibility with programs that fork().
Dhurjati and Adve’s combination of static analysis par-
tially solves the ﬁrst issue but not the second, and comes
with the cost of requiring source-code analysis. Our sys-
tem Oscar addresses both issues and introduces new op-
timizations, all without needing source code, providing
low overheads for many benchmarks and simpler deploy-
ment. Oscar thereby brings page-permissions-based pro-
tection schemes to the forefront of practical solutions for
temporal memory safety.
10 Acknowledgements
This work was supported by the AFOSR under MURI
award FA9550-12-1-0040, Intel through the ISTC for Se-
cure Computing, and the Hewlett Foundation through the
Center for Long-Term Cybersecurity.
We thank Nicholas Carlini, David Fiﬁeld, ´Ulfar Er-
lingsson, and the anonymous reviewers for helpful com-
ments and suggestions.
References
[1] AddressSanitizerLeakSanitizer.
github.com/google/sanitizers/wiki/
AddressSanitizerLeakSanitizer.
https://
[2] How to use Pageheap.exe in Windows XP, Windows 2000, and
Windows Server 2003. https://support.microsoft.com/
en-us/kb/286470.
[3] Memcheck: a memory error detector. http://valgrind.org/
docs/manual/mc-manual.html.
[4] Ownership and moves.
scope/move.html.
https://rustbyexample.com/
[5] Readme 1st CPU2006. https://www.spec.org/cpu2006/
Docs/readme1st.html#Q21.
[6] Threads and fork():
think twice before mixing them.
https://www.linuxprogrammingblog.com/threads-
and-fork-think-twice-before-using-them, June 2009.
[7] Advancing Moore’s Law in 2014!
http://www.intel.
com/content/dam/www/public/us/en/documents/
presentation/advancing-moores-law-in-2014-
presentation.pdf, August 2014.
[8] Efﬁcacy of MemoryProtection against use-after-free vulner-
http://community.hpe.com/t5/Security-
abilities.
Research/Efficacy-of-MemoryProtection-against-
use-after-free/ba-p/6556134#.VsFYB8v8vCK,
2014.
July
[9] Electric Fence.
http://elinux.org/index.php?title=
Electric_Fence&oldid=369914, January 2015.
[10] ABADI, M., BUDIU, M., ERLINGSSON, ´U., AND LIGATTI, J.
Control-ﬂow integrity principles, implementations, and applica-
tions. TISSEC (2009).
[11] AKRITIDIS, P. Cling: A Memory Allocator to Mitigate Dangling
Pointers. In USENIX Security (2010), pp. 177–192.
[12] ATIKOGLU, B., XU, Y., FRACHTENBERG, E., JIANG, S., AND
PALECZNY, M. Workload analysis of a large-scale key-value
In ACM SIGMETRICS Performance Evaluation Review
store.
(2012), vol. 40, ACM, pp. 53–64.
[13] BERGER, E. D., AND ZORN, B. G. DieHard: probabilistic mem-
ory safety for unsafe languages. ACM SIGPLAN Notices 41, 6
(2006), 158–168.
[14] BERGER, E. D., ZORN, B. G., AND MCKINLEY, K. S. Recon-
sidering custom memory allocation. ACM SIGPLAN Notices 48,
4S (2013), 46–57.
[15] CABALLERO, J., GRIECO, G., MARRON, M., AND NAPPA, A.
Undangle: early detection of dangling pointers in use-after-free
and double-free vulnerabilities. In International Symposium on
Software Testing and Analysis (2012), ACM, pp. 133–143.
[16] CARLINI, N., BARRESI, A., PAYER, M., WAGNER, D., AND
GROSS, T. R. Control-ﬂow bending: On the effectiveness of
control-ﬂow integrity. In USENIX Security (2015), pp. 161–176.
USENIX Association
26th USENIX Security Symposium    831
[17] CHEN, S., XU, J., SEZER, E. C., GAURIAR, P., AND IYER,
In
R. K. Non-Control-Data Attacks Are Realistic Threats.
USENIX Security (2005), vol. 5.
[36] SEREBRYANY, K., BRUENING, D., POTAPENKO, A., AND
VYUKOV, D. AddressSanitizer: A fast address sanity checker.
In USENIX ATC (2012), pp. 309–318.
[37] SHUTEMOV, K. A.
[RFC, PATCHv1 00/28] 5-level pag-
http://lkml.iu.edu/hypermail/linux/kernel/
ing.
1612.1/00383.html, Dec 2016.
[38] SIMPSON, M. S., AND BARUA, R. K. MemSafe: ensuring the
spatial and temporal memory safety of C at runtime. Software:
Practice and Experience 43, 1 (2013), 93–128.
[39] SZEKERES, L., PAYER, M., WEI, T., AND SONG, D. SoK:
Eternal war in memory. In IEEE S&P (2013), IEEE, pp. 48–62.
[40] TICE, C., ROEDER, T., COLLINGBOURNE, P., CHECKOWAY,
S., ERLINGSSON, ´U., LOZANO, L., AND PIKE, G. Enforcing
forward-edge control-ﬂow integrity in gcc & llvm. In USENIX
Security (2014).
[41] VAN DER KOUWE, E., NIGADE, V., AND GIUFFRIDA, C. Dan-
In EuroSys (2017),
gSan: Scalable Use-after-free Detection.
pp. 405–419.
[42] YOUNAN, Y. FreeSentry: protecting against use-after-free vul-
nerabilities due to dangling pointers. In NDSS (2015).
[18] CHEN, X., SLOWINSKA, A., AND BOS, H. Who allocated my
memory? Detecting custom memory allocators in C binaries. In
WCRE (2013), pp. 22–31.
[19] CHEN, X., SLOWINSKA, A., AND BOS, H. On the detection
of custom memory allocators in C binaries. Empirical Software
Engineering (2015), 1–25.
[20] CORPORATION,
I.
5-Level Paging and 5-Level EPT.
https://software.intel.com/sites/default/files/
managed/2b/80/5-level_paging_white_paper.pdf, May
2017.
[21] COWAN, C., BEATTIE, S., JOHANSEN, J., AND WAGLE, P.
PointGuard: protecting pointers from buffer overﬂow vulnerabil-
ities. In USENIX Security (2003), vol. 12, pp. 91–104.
[22] DEMOTT,
J.
UaF: Mitigation and Bypass.
https:
//bromiumlabs.files.wordpress.com/2015/01/
demott_uaf_migitation_and_bypass2.pdf,
2015.
January
[23] DHURJATI, D., AND ADVE, V. Efﬁciently detecting all dangling
pointer uses in production servers. In Dependable Systems and
Networks (2006), IEEE, pp. 269–280.
[24] HU, H., SHINDE, S., ADRIAN, S., CHUA, Z. L., SAXENA, P.,
AND LIANG, Z. Data-Oriented Programming: On the Expressive
of Non-Control Data Attacks. In IEEE S&P (2016).
[25] JIM, T., MORRISETT, J. G., GROSSMAN, D., HICKS, M. W.,
CHENEY, J., AND WANG, Y. Cyclone: A Safe Dialect of C. In
USENIX ATC (2002), pp. 275–288.
[26] KUZNETSOV, V., SZEKERES, L., PAYER, M., CANDEA, G.,
In OSDI
SEKAR, R., AND SONG, D. Code-pointer integrity.
(2014), pp. 147–163.
[27] LEE, B., SONG, C., JANG, Y., WANG, T., KIM, T., LU, L.,
AND LEE, W. Preventing Use-after-free with Dangling Pointers
Nulliﬁcation. In NDSS (2015).
[28] LVIN, V. B., NOVARK, G., BERGER, E. D., AND ZORN, B. G.
Archipelago: trading address space for reliability and security.
ACM SIGOPS Operating Systems Review 42, 2 (2008), 115–124.
[29] NAGARAKATTE, S. personal communication, June 2017.
[30] NAGARAKATTE, S., MARTIN, M. M., AND ZDANCEWIC, S.
Watchdog: Hardware for safe and secure manual memory man-
agement and full memory safety. ACM SIGARCH Computer Ar-
chitecture News 40, 3 (2012), 189–200.
[31] NAGARAKATTE, S., ZHAO,
J., MARTIN, M. M., AND
ZDANCEWIC, S. CETS: compiler enforced temporal safety for
C. ACM Sigplan Notices 45, 8 (2010), 31–40.
[32] NAGARAKATTE, S. G. Practical low-overhead enforcement of
memory safety for C programs. University of Pennsylvania, 2012.
Doctoral dissertation.
[33] NECULA, G. C., MCPEAK, S., AND WEIMER, W. CCured:
Type-safe retroﬁtting of legacy code. ACM SIGPLAN Notices 37,
1 (2002), 128–139.
[34] ROGERS, A., CARLISLE, M. C., REPPY, J. H., AND HENDREN,
L. J. Supporting dynamic data structures on distributed-memory
machines. TOPLAS 17, 2 (1995), 233–263.
[35] SAHITA, R. L., SHANBHOGUE, V., NEIGER, G., EDWARDS, J.,
OUZIEL, I., HUNTLEY, B. E., SHWARTSMAN, S., DURHAM,
D. M., ANDERSON, A. V., LEMAY, M., ET AL. Method and
apparatus for ﬁne grain memory protection, Dec. 31 2015. US
Patent 20,150,378,633.
832    26th USENIX Security Symposium
USENIX Association