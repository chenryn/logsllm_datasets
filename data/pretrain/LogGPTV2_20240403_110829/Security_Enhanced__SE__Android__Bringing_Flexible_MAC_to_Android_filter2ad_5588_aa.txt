title:Security Enhanced (SE) Android: Bringing Flexible MAC to Android
author:Stephen Smalley and
Robert Craig
Security Enhanced (SE) Android: Bringing Flexible MAC to Android
Stephen Smalley and Robert Craig
Trusted Systems Research
National Security Agency
{sds,rpcraig}@tycho.nsa.gov
Abstract
The Android software stack for mobile devices deﬁnes
and enforces its own security model for apps through its
application-layer permissions model. However, at its foun-
dation, Android relies upon the Linux kernel to protect the
system from malicious or ﬂawed apps and to isolate apps
from one another. At present, Android leverages Linux dis-
cretionary access control (DAC) to enforce these guaran-
tees, despite the known shortcomings of DAC. In this pa-
per, we motivate and describe our work to bring ﬂexible
mandatory access control (MAC) to Android by enabling
the effective use of Security Enhanced Linux (SELinux) for
kernel-level MAC and by developing a set of middleware
MAC extensions to the Android permissions model. We then
demonstrate the beneﬁts of our security enhancements for
Android through a detailed analysis of how they mitigate a
number of previously published exploits and vulnerabilities
for Android. Finally, we evaluate the overheads imposed by
our security enhancements.
1. Introduction
Android is a Linux-based open source software stack for
mobile devices [4]. One of Android’s design goals was
to facilitate a rich and open ecosystem of applications in
which critical functionality can be provided or replaced by
third party applications or apps [40]. Google Play, the of-
ﬁcial app market for Android apps, is also notable for its
low barrier to entry and lack of a formal review process for
accepting new apps [2]. In such an environment, the need
for a strong security model that is capable of addressing the
threat of ﬂawed and malicious apps is particularly evident.
Android’s existing security model is implemented at two
layers: an application-level permissions model (aka An-
droid permissions) and a kernel-level sandboxing and isola-
tion mechanism. The application-level permissions model,
which is enforced by the Android middleware, controls ac-
cess to application components, such as the ability to invoke
a service provided by another application, and it controls
access to system resources, such as the ability to access the
camera or the network. The Android permissions model
is directly exposed to Android application developers, who
must specify the set of required permissions as part of their
application’s manifest ﬁle, and to end users, who must ap-
prove the set of permissions deemed dangerous before in-
stalling an application [1].
Underneath the user-visible Android permission model,
the Linux kernel provides the foundational mechanism for
application isolation and sandboxing. This mechanism nor-
mally operates invisibly to the app developers and users, so
long as an app does not attempt to violate the restrictions
imposed by the kernel. Application isolation and sandbox-
ing in Android is necessarily enforced by the Linux kernel
since the Dalvik VM is not a security boundary and any app
can run native code [3]. At present, Android relies on Linux
discretionary access control (DAC) to implement these con-
trols.
In particular, Android employs DAC in two primary
ways. First, Android uses DAC to restrict the use of system
facilities by apps. In some cases, DAC is used to ensure that
certain system resources can only be indirectly accessed by
apps through system services which can then mediate ac-
cess and address sharing concerns. In other cases, DAC is
used to directly authorize apps to access system resources,
e.g. the ability to create bluetooth or network sockets and
the ability to access the ﬁlesystem on the SDcard. The
socket controls required some custom kernel modiﬁcations
for Android since Linux DAC does not normally control the
use of these sockets.
Second, Android uses DAC to isolate apps from one an-
other in much the same way DAC is employed in conven-
tional Linux systems to isolate users on a multi-user sys-
tem. Each app is allocated a unique user and group iden-
tiﬁer (UID and GID, respectively) when it is installed, and
this (UID, GID) pair is assigned to the processes and the
private data ﬁles associated with the app [1]. This approach
is designed to prevent one app from directly accessing the
process state or ﬁles of another app through the kernel in-
terfaces. Apps signed by the same key may optionally be
run in the same (UID, GID) pair if they wish to fully share
resources without restriction.
The shortcomings of DAC, particularly with respect to
protecting against ﬂawed and malicious applications, are
well established [29]. In some respects, by modifying the
Linux kernel and by using DAC identities to directly rep-
resent applications rather than users, Android has mitigated
some of the problems associated with DAC in its security
model. Nonetheless, signiﬁcant weaknesses remain, such
as the ability of ﬂawed or malicious apps to leak access to
data, the coarse granularity of the DAC permissions, and the
inability to conﬁne any system daemons or setuid programs
that run with the root or superuser identity.
Security Enhanced Linux (SELinux) was originally de-
veloped as a Mandatory Access Control (MAC) mechanism
for Linux to demonstrate how to overcome the shortcom-
ings of DAC [28]. Although SELinux has long been in-
tegrated into the mainline Linux kernel and is available in
many Linux distributions, neither it nor any other kernel
MAC mechanism is presently used by Android. Unlike
DAC, SELinux enforces a system-wide security policy over
all processes, objects and operations based on security la-
bels that can encode a variety of security-relevant informa-
tion about each process and object. As a MAC mechanism,
SELinux is capable of conﬁning ﬂawed and malicious ap-
plications, even ones that run with the root or superuser
identity.
SELinux offers three primary beneﬁts for Android. First,
SELinux is capable of conﬁning the privileged Android sys-
tem daemons in order to protect them from misuse and
to limit the damage that can be done via them.
In the
absence of SELinux, any ﬂaw in any one of these privi-
leged daemons is fatal to the security of the device. Sec-
ond, SELinux provides a stronger mechanism than DAC
for isolating and sandboxing Android apps. SELinux can
fully control all possible interactions among Android apps
at the kernel layer, and it can control all access to system
resources by the apps. Lastly, SELinux provides a central-
ized policy conﬁguration that can be analyzed for potential
information ﬂows and privilege escalation paths.
In order to bring these beneﬁts to Android and motivate
the need for similar capabilities in other mobile operating
systems, we initiated the Security Enhanced Android or SE
Android project. The SE Android project is initially en-
abling the use of SELinux in Android, although it is not
limited in scope to SELinux alone. SE Android also refers
to the reference implementation produced by the project.
The current SE Android reference implementation provides
a worked example of how to enable and apply SELinux at
the lower layers of the Android software stack and provides
a demonstration of the value provided by SELinux in con-
ﬁning various root exploits and application vulnerabilities.
Our unique contributions in the work described by this
paper include:
• Identifying and overcoming several challenges to en-
abling the effective use of SELinux in Android,
• Integrating SELinux and middleware MAC into An-
droid in a comprehensive and coherent manner,
• Demonstrating concretely how SELinux mitigates real
Android exploits and app vulnerabilities, and
• Merging our security enhancements into the mainline
Android platform maintained by the Android Open
Source Project (AOSP).
The remainder of this paper is as follows. We ﬁrst pro-
vide a description of the challenges to enabling the effective
use of SELinux in Android in Section 2. We then identify
how those challenges were overcome in the SE Android ref-
erence implementation in Section 3. An analysis of how SE
Android blocks a variety of previously published exploits
and vulnerabilities for Android is captured in Section 4. Our
results from measuring the size and performance overheads
due to SE Android are reported in Section 5. Related work
is discussed in Section 6.
2. Challenges
Prior to our work, the challenges to using SELinux in
Android were manifold. These challenges spanned the ker-
nel, userspace, and policy conﬁguration. In prior efforts by
others to enable the use of SELinux in Android [44, 35],
many of these challenges were either completely over-
looked or merely worked around rather than being fully ad-
dressed.
2.1. Kernel challenges
The ﬁrst set of challenges to using SELinux in Android
was in the Linux kernel. Even though SELinux is part of
the standard Linux kernel, enabling the use of SELinux in
Android requires more than merely enabling SELinux in the
kernel build conﬁguration. In order to provide per-ﬁle pro-
tection and to support automatic security context transitions
on executables, SELinux requires that the ﬁlesystem pro-
vide support for security labeling. In Linux, the underlying
storage for ﬁle security labels is typically provided through
the use of extended attributes on ﬁles. However, the orig-
inal preferred ﬁlesystem type for Android devices was the
yaffs2 ﬁlesystem, which is not part of the mainline Linux
kernel and did not originally support extended attributes at
all. More recently, yaffs2 has gained support for extended
attributes, but still lacked the necessary support for auto-
matic security labeling of newly created ﬁles.
Furthermore, Android introduces a number of new ker-
nel subsystems and drivers to the Linux kernel. These sub-
systems include new mechanisms for application processes
to communicate, such as the Binder IPC mechanism and the
Anonymous Shared Memory (ashmem) mechanism, as well
as various other Android-speciﬁc facilities, such as the An-
droid logging and wake lock mechanisms. These Android-
unique kernel subsystems have not been previously studied
or instrumented for SELinux and thus introduce the possi-
bility of inter-app communication or privileged interfaces
that are completely uncontrolled by SELinux.
2.2. Userspace challenges
The second set of challenges was in the Android
userspace software stack. In the past, signiﬁcant work has
gone into integrating support for SELinux into conventional
GNU/Linux distributions. However, in Android, almost ev-
erything above the kernel is different from a typical Linux
distribution, from system-level components such as its own
unique init program, C library (bionic) and core daemons
up through the Dalvik runtime and application frameworks.
As a result, none of the prior work to integrate SELinux into
Linux userspace could be directly reused for Android.
Android also brings unique challenges for integrating
SELinux into the userspace due to its model for starting
In Android, a single process, the zygote, preloads
apps.
the Dalvik VM and common class ﬁles, and then upon re-
quest, forks a child process for each app, loading that app’s
speciﬁc classes into the child. This avoids the overhead of
the Dalvik VM and common class initialization on each app
start. However, SELinux normally performs automatic se-
curity context transitions upon program execution. Hence,
the zygote model does not naturally lend itself to running
apps in particular SELinux security contexts by default.
Android’s rich support for sharing through the Android
framework services also poses challenges for enabling the
effective use of SELinux in Android. As much of this shar-
ing occurs at the middleware layer and is only visible at
the kernel layer as communications between each app and
the system server (where the framework service implemen-
tation resides) in Android, it is impossible to fully address
controlled sharing among apps at the kernel layer.
2.3. Policy challenges
The third set of challenges to enabling the use of
SELinux in Android was in the policy conﬁguration. For
Linux distributions, the SELinux reference policy [43, 47]
provides the standard base policy from which the various
distribution policies are constructed. This reference policy
has been developed over many years based on the feedback
and contributions of many SELinux users and developers.
However, the reference policy was developed based on
the normal operation of the conventional Linux userspace
and the typical ways in which Linux distributions are used.
As Android has its own unique userspace software stack,
and as its ﬁlesystem layout and usage model differs substan-
tially from that of conventional Linux, the reference pol-
icy does not provide a good foundation for constructing a
SELinux policy for Android. The reference policy is also
quite large, and thus is not well suited to the resource con-
straints of small devices.
Lastly, the reference policy aims to provide comprehen-
sive least privilege for Linux distributions. This requires
that the distributions and end users often have to customize
the policy for their speciﬁc environment and needs. While
this is feasible for Linux developers and administrators, it
would impose a signiﬁcant usability challenge for typical
Android users and app developers if they had to understand
or write SELinux policy.
3. Implementation
This section discusses how the previously noted chal-
lenges to enabling the effective use of SELinux in Android
were overcome in the SE Android reference implementa-
tion. Overcoming these challenges required changes to the
kernel, changes and new additions to the Android userspace
software stack, and the creation of a new policy conﬁgura-
tion for Android.
3.1. Kernel support
Kernel support for SELinux in Android can be divided
into two categories. Basic enablement of SELinux and
ﬁlesystem support for security labels is required in order to
use SELinux at all. Instrumenting Android-speciﬁc subsys-
tems for SELinux is required in order to provide complete
control.
3.1.1. Basic enablement and ﬁlesystem support. Using
SELinux in Android ﬁrst requires enabling SELinux and
its dependencies in the kernel conﬁguration and rebuilding
the kernel. SELinux dependencies in the kernel include the
Linux Security Module (LSM) framework [49], the audit
subsystem, and ﬁlesystem support for extended attributes
and security labels for each relevant ﬁlesystem for the de-
vice. Filesystems that do not support extended attributes or
security labeling such as vfat can still be used, but can only
be labeled and protected at per-mount granularity rather
than per-ﬁle granularity.
As noted earlier, the yaffs2 ﬁlesystem used for NAND
storage on Android devices did not originally support ex-
tended attributes or security labeling. Filesystem support
for extended attributes was recently added to the yaffs2
ﬁlesystem, thereby providing storage for security labels. To
provide full security labeling functionality, we implemented
a ﬁx to the yaffs2 getxattr implementation and we imple-
mented support for automatically setting a security label on
new yaffs2 ﬁles when they are created.
More recent Android devices have begun using the Linux
ext4 ﬁlesystem for eMMC storage on Android devices,
since eMMC exposes a traditional block-based interface
on which conventional disk-based Linux ﬁlesystems can be
layered. ext4 already incorporates all the necessary support
for extended attributes and security labeling and is already
tested with SELinux as part of conventional Linux distribu-
tions.
3.1.2. Android-speciﬁc subsystems. We began our study
of the Android-speciﬁc kernel subsystems and drivers with
the Binder subsystem as it is the central IPC primitive for
Android apps. The Binder enables transparent invocation
of objects whether local (intra-process) or remote (inter-
process), and it provides lifecycle management of objects
shared across multiple processes. At the kernel level, the
core Binder functionality is implemented by a binder driver
that presents a /dev/binder interface to applications. This
/dev/binder interface can be opened by all Android apps to
perform IPC transactions via speciﬁc ioctl commands im-
plemented by the driver.
One process, known as the Binder context manager, pro-
vides name service functionality for the Binder and enables
the bootstrapping of communications with other services.
The Android servicemanager program registers itself as the
Binder context manager via the /dev/binder interface during
system startup and handles initial requests by applications
to obtain references to other services.
Once the servicemanager is operating, the various An-
droid framework services can register object references
with the servicemanager. These object references can then
be looked up by Android apps from the servicemanager and
used to initiate IPC to the Android framework services. The
Binder references are kernel-managed capabilities, similar
to open ﬁle descriptors. Initially, each app can only initiate
IPC to the servicemanager, and it can only initiate IPC on
a given Binder object if it receives a reference to the object
from a process that already has one.
To support SELinux or any other MAC mechanism, it
was necessary to deﬁne new LSM security hooks and in-
sert calls to these hooks into the binder driver on IPC
transactions and on security-relevant control operations.
These hooks were then implemented for SELinux to pro-
vide SELinux permission checks over inter-app commu-
nication and over binder control operations. In particular,
permission checks were implemented to control which pro-
cesses can communicate with one another, to control the
propagation of Binder references and open ﬁle descriptors
via Binder IPC, and to control which process can serve as
the Binder context manager.
We next looked at the Anonymous Shared Memory or
ashmem subsystem. As ashmem regions are represented by