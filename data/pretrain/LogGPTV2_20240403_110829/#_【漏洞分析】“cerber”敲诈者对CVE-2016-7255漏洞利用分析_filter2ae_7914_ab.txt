ID的数组。在Win7 x64下，该ID为0x133a。
图14 判断系统版本并初始化syscall ID
之前已经获得cbWNDExtra成员在tagWND结构体中的偏移，现在需要获得所操作窗口的tagWND结构体在内核中的地址。幸运的是，tagWND.head.pSelf成员（head成员偏移0x20处）泄露了tagWND结构体在内核中的地址，可以首先通过HMValidateHandle函数获取tagWND结构体的内容进而获取tagWND.head.pSelf成员，从而取得tagWND结构体在内核中的地址。之后对tagWND结构体成员内核地址的获取都是先使用该方法获取tagWND结构体的内核地址再加上相应的偏移。
图15 获取tagWND地址
tagWND的地址加上cbWNDExtra成员的偏移即可得cbWNDExtra成员在内核中的地址。由于xxxNextWindow函数操作的是spmenu成员中的值加上0x28后的结果，而木马的目的是修改cbWNDExtra的值，因此木马将cbWNDExtra成员（大小为4字节）在内核中的地址减去0x28后加上3字节，将该值传递给spmenu，让cbWNDExtra的最高字节与0x4进行或操作。这样原本大小为0的cbWNDExtra就变成了0x4000000。此时窗口的附加数据长度就变为了0x4000000。
完成附加数据长度的增长之后，需要往附加数据中写入特定的值以寻求覆盖一些关键的标志位达到权限提升。该木马使用的方法是再次创建一个窗口，并确保该窗口的tagWND的地址与触发漏洞的窗口的tagWND的地址距离足够小，以保证触发漏洞的窗口的附加数据可以覆盖到该窗口的tagWND。为此，木马在完成该步骤之前创建了100个窗口，并选取两个tagWND结构体地址相差小于0x3fd00的窗口，一个作为触发漏洞的窗口，一个作为利用的窗口。
图16 创建两个窗口进行漏洞触发和利用
选取好两个窗口之后调用xxxNextWindow函数触发漏洞。在用户态中可以模拟按键VK_MENU来触发xxxNextWindow函数的调用。漏洞触发后，窗口1的附加数据长度变为0x4000000，覆盖了窗口2的tagWND结构体。
图17 模拟VK_MENU触发xxxNextWindow函数的调用
木马利用该漏洞的目的是提升权限，因此木马必须对一些重要的标志位，例如进程令牌进行修改。幸运的是，通过检索tagWND结构体的一些成员就能找到可以进行操作的地方。TagWND.head.pti
-> ppi -> Process->
ActiveProcessLinks保存所有进程的EPROCESS对象，木马可以通过检索这些对象获得系统高权限进程的相关信息。
那么木马该如何获得这些信息？由于窗口1的附加数据覆盖了窗口2的tagWND结构体，而且可以调用NtUserSetWindowLongPtr函数（32位下可以调用SetWindowLong函数）对窗口的附加数据进行写操作，这意味着可以操作窗口2的tagWND结构体。如果将某个内核地址写入窗口2的tagWND结构体中的某个成员，再利用其它函数读取该成员的值，就能够读取该内核地址中的值。木马选取的是tagWND的spwndParent成员。该成员偏移为0x58。
图18 利用spwndParent任意读
木马通过syscall调用NtUserSetWindowLongPtr函数写窗口1的附加数据，而数据操作的起始偏移为窗口2tagWND.
spwndParent的内核地址-窗口1附加数据区的起始地址，也就是窗口1附加数据覆盖到窗口2
tagWND结构体spwndParent成员的位置。木马将之前提到的ActiveProcessLinks链表的内核地址写入窗口2
tagWND结构体的spwndParent成员。然后调用GetAncestor函数，该函数实际调用内核态函数NtUserGetAncestor，当gaFlags参数为GA_PARENT（1）时，该函数将读取tagWND结构体的spwndParent成员。
图19 gaFlags参数为1时读取的值
如此一来，木马就能够读取ActiveProcessLinks链表的内核地址，并且可以遍历该链表获取其它进程的EPROCESS对象。木马遍历ActiveProcessLinks链表中每个进程的PID，以获得当前进程的EPROCESS对象。
图20 获得当前进程的EPROCESS对象  
之后还会继续遍历链表，获得system进程（PID=4）的EPROCESS对象。
图21 获得system进程的EPROCESS对象
然后木马读取system进程EPROCESS对象偏移0x208的值，也就是token成员，同时也获取当前进程的token成员的内核地址。之后它将用system进程的token替换掉当前进程的token，以达到提权的目的。
图22 读取system进程EPROCESS对象的token成员
图23 读取当前进程EPROCESS对象的token成员
在完成必要的读取操作之后，木马需要将token写入当前进程的EPROCESS对象的相应偏移中，而对于写操作，木马选择了SetWindowText函数。SetWindowText函数会将数据写入tagWND.strname.Buffer,如果可以将tagWND.strname.Buffer修改为当前进程token的内核地址，就可以对当前进程的token进行修改。和之前的原理一样，可以利用syscall调用NtUserSetWindowLongPtr，通过写入数据到窗口1的附加数据区域以覆盖窗口2的tagWND.strname.Buffer成员，即可修改窗口2的tagWND.strname.Buffer为当前进程EPROCESS对象的token成员的内核地址。
图24 获取tagWND.strname.Buffer
之后调用SetWindowText将system进程的token写入到tagWND.strname.Buffer的地址中，也就是用system进程的token代替当前进程的token，从而使当前进程拥有system权限。至此进程提权成功。
图25 cerber敲诈者木马提权成功
**  
**
**0x4 缓解机制**
通过微软的补丁可以发现，在对win32k!xxxNextWindow的调用时进行了限制。如下图所示。
图26 缓解机制
在对spmenu.fFlags进行或操作之前会首先判断tagWND的style成员是否为WS_CHILD或WS_CHILDWINDOW（0x40000000），也就是所操作窗口的类型是否为WS_CHILD或WS_CHILDWINDOW，如果窗口类型为WS_CHILD或WS_CHILDWINDOW则跳过此处的操作，不会对spmenu.fFlags进行或操作。由于调用以GWL_ID做为nIndex参数的NtUserSetWindowLongPtr函数的时候，只有当所操作的窗口类型为WS_CHILD或WS_CHILDWINDOW（0x40000000）的情况下才会将dwNewLong参数中的值赋予tagWND.spmenu（见图5），而此处限制了窗口的类型，从而对整个漏洞触发的过程进行了限制。
**0x5 总结**
如今越来越多的恶意程序使用nDay漏洞进行攻击或者辅助自身的攻击，而对此最好的解决方法就是及时打上补丁以阻止恶意攻击。对于用户而言，提高安全意识，不运行安全性未知的程序，为系统及时打上补丁，这些对于防范恶意程序攻击都是非常有必要的。
360安全卫士针对敲诈者木马独家推出了“反勒索服务”，用户在安装360安全卫士并开启该服务的情况下，如果防不住各类敲诈者木马，360负责替用户赔付赎金。