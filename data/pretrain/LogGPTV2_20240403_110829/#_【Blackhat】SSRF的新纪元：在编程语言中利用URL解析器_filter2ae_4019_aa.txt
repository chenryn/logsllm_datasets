# 【Blackhat】SSRF的新纪元：在编程语言中利用URL解析器
##### 译文声明
本文是翻译文章，文章来源：blackhat.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
作者：[Orange Tsai ](http://blog.orange.tw/) 译者：[
**math1as**](http://bobao.360.cn/member/contribute?uid=1336370560)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
并非完全翻译,掺杂了一点自己的私货和见解。
**  
**
**什么是SSRF**
****
[1] 服务器端请求伪造
[2] 穿透防火墙,直达内网
[3] 让如下的内网服务陷入危险当中
Structs2
Redis
Elastic
**  
**
**SSRF中的协议'走私'**
[1] 让SSRF的利用更加有效
本质上说,是利用原本的协议夹带信息,攻击到目标的应用
[2] 用来'走私'的协议必须是适合的,比如
基于HTTP的各类协议=>Elastic,CouchDB,Mongodb,Docker
基于Text的各类协议=>FTP,SMTP,Redis,Memcached
**  
**
**一个有趣的例子**
****
像这样的一个协议
我们来分析一下,各个不同的python库,分别请求到的是哪个域名呢？
可以看到,Python真是个矛盾的语言呢。
**另一个有趣的例子**
[1] HTTP协议中的CRLF(换行符)注入
[2] 使用HTTP协议'走私'信息来攻击SMTP协议
我们尝试构造CRLF注入,来进行如下的攻击
STMP '讨厌' HTTP协议
这似乎是不可利用的,可是,真的如此么?
我们在传统的SSRF利用中都使用gopher协议来进行相关攻击
可是事实上,如果真实的利用场景中不支持gopher协议呢?
**利用HTTPS协议:SSL握手中,什么信息不会被加密?**
[1] HTTPS协议中的CRLF(换行符)注入
[2] 化腐朽为神奇 – 利用TLS SNI(Server Name Indication),它是用来改善SSL和TLS的一项特性
允许客户端在服务器端向其发送证书之前请求服务器的域名。
https://tools.ietf.org/html/rfc4366RFC文档
简单的说,原本的访问,是将域名解析后,向目标ip直接发送client hello,不包含域名
而现在包含了域名,给我们的CRLF攻击提供了利用空间
我们尝试构造CRLF注入,来进行如下的攻击
监听25端口
分析发现,127.0.0.1被作为域名信息附加在了client hello之后
由此我们成功的向STMP'走私'了信息,实施了一次攻击
**URL解析中的问题**
[1] 所有的问题,几乎都是由URL解析器和请求函数的不一致造成的。
[2] 为什么验证一个URL的合法性是很困难的?
1.在 RFC2396/RFC3986 中进行了说明,但是也只是停留在说明书的层面。
2.WHATWG(网页超文本应用技术工作小组)定义了一个基于RFC的具体实现
但是不同的编程语言仍然使用他们自己的实现
**RFC 3986中定义的URL组成部分**
大致用这张图片来说明
其中的协议部分,在真实场景中一般都为http或https
而查询字符串和fragment,也就是#号后的部分,我们实际上是不关心的,因为这和我们的利用无关
所以,我们着重看的也就是authority和path部分
那么,在这几个部分中,能不能进行CRLF注入?
各个语言以及他们对应的库的情况如下图所示
可以看到支持CRLF注入的部分还是很多的,但是除了在实际的请求中能利用CRLF注入外
还要能通过URL解析器的检查,而这个图也列出来了对应的情况。
**关于URL解析器**
[1] 让我们思考如下的php代码
在这段代码中,我们最后使用readfile函数来实施我们的SSRF攻击
但是,我们构造出的URL需要经过parse_url的相应检查
**误用URL解析器的后果**
当我们对上述的php脚本传入这样的一个URL
对于我们的请求函数readfile来说,它所请求的端口是11211
而相反的,对于parse_url来说,它则认为这个url的端口号是80,符合规定
这就产生了一个差异化的问题,从而造成了SSRF的成功利用
让我们来看看,在RFC3986中,相关的定义
那么,按照这个标准,当我们传入如下URL的时候,会发生什么呢
对比我们的两个函数
可以看到,parse_url最终得到的部分实际上是google.com
而readfile则忠实的执行了RFC的定义,将链接指向了evil.com
进行一下简单的分析
[1] 这样的问题同样影响了如下的编程语言
cURL,Python
[2] RFC3962的进一步分析
在3.2小节中有如下的定义:authority(基础认证)部分应该由//作为开始而由接下来的一个/号,或者问号
以及 #号作为一个结束,当然,如果都没有,这个部分将延续到URL的结尾。
**cURL的利用**
参照我们刚才所得到的结论
对这样的一个URL进行分析和测试
可以发现,在cURL作为请求的实施者时,它最终将evil.com:80作为了目标
而其他的几种URL解析器则得到了不一样的结果,产生了不一致。
当他们被一起使用时,可以被利用的有如下的几种组合
于是我向cURL团队报告了这个问题,很快的我得到了一个补丁
但是这个补丁又可以被添加一个空格的方式绕过
但是,当我再次向cURL报告这个情况的时候,他们认为,cURL并不能100%的验证URL的合法性
它本来就是要让你来传给他正确的URL参数的
并且他们表示,这个漏洞不会修复,但是上一个补丁仍然在7.54.0版本中被使用了
**NodeJS的Unicode解析问题**
让我们来看如下的一段nodeJS代码
可以看到,阻止了我们使用..来读取上层目录的内容
当对其传入如下的URL时,会发生什么呢
注意,这里的N是 U+FF2E,也就是拉丁文中的N,其unicode编码为 /xFF/x2E
最终,由于nodeJS的处理问题 xFF 被丢弃了,剩下的x2E被解析为.
于是我们得到了如下的结论
在NodeJS的http模块中, NN/ 可以起到../ 的作用,绕过特定的过滤
那么,nodeJS对于之前我们所研究的CRLF注入,又能不能够加以防御呢?
[1] HTTP模块可以避免直接的CRLF注入
[2] 那么,当我们将换行符编码时,会如何呢?
很明显,这时候它并不会进行自动的解码操作
如何打破这个僵局呢? 使用U+FF0D和U+FF0A
我们成功的往请求中注入了新的一行
**Glibc中的NSS特性**