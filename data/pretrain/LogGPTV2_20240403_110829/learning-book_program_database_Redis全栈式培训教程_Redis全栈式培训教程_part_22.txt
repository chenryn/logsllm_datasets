18.5.2.核心源码
**
*模拟生成短信验证码
@param key
@return
*
public String sendMsg(String key) {
Random rd = new Random();
rd.nextInt(10);
StringBuilder sb = new StringBuilder();
for（inti=0;i inter(){
Listalist=newArrayList（);//用户A信息
for（inti=0;iblist=new ArrayList(）;//用户B信息
for（int i=6;isets=this.redisTemplate.opsForSet().intersect（"user_a”,"user_b");// 求共同好友
return sets;
春风阁讲堂出品
067
---
## Page 291
春风阁讲堂出品
291
---
## Page 292
18.9.SpringCache集成Redis
18.9.1.工程依赖
implementation'org.springframework.boot:spring-boot-starter-data-redis
implementation 'org.springframework.boot:spring-boot-starter-web'
testImplementation 'org.springframework.boot:spring-boot-starter-test'
参考源码工程 sredis-cache,官网地址：https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache
春风阁讲堂出品
292
---
## Page 293
18.9.2.
核心源码
@RequestMapping(value = "/simple")
@RestController
oublic class SimpleController {
@RequestMapping(value = "/query/{key}")
public String query(@PathVariable String key){
System.out.println（"执行query:"+key）;
public String update(@PathVariable String key, @PathVariable String value){
return value;
public String delete(@PathVariable String key) {
return "success";
@CacheEvict(value ={ "mycache"}, allEntries = true)
@RequestMapping(value = "/clear")
public String clear(）{
return "success";
春风阁讲堂出品
293
---
## Page 294
19.Redis常用实践问题
19.1.前端启动&持久化误用
19.1.1.Reids前后端启动问题
在我们的配置文件中，有一个是否以守护模式启动选项
1.设置成no的时候，Redis相当于是前台启动，当shell进程退出以后，Redis就会退出，当然可以结合nohup来解决
2.生产建议
daemonize no建议改成 daemonize yes
19.1.2.缓存与持久模式的误用
首先要确定我们的业务场景，到底是纯缓存，还是需要持久化，如果不需要持久化，我们建议将AOF关掉，否则在一些磁盘性能差+主从同步
时，否则容易引起一些问题
生产建议：
尽量使用纯缓存模式，缓存模式关闭AOF
春风阁讲堂出品
294
---
## Page 295
19.2.Redis单实例不亦太大
1.一般在生产，Redis通常会建立主从，在主从模式下，我们要开启主从同步
2.主从模式的时候，全量同步的时候会默认打开RDB持久化（除非使用无盘复制，但无盘复制只有在网络好+IO差的时候才使用，非主流）
3.如果Redis单个实例内存太大，比如超过了20G，那么在RDB刷盘的时候，可能导致IO繁忙，进而影响Redis的写操作
4.单实例太大，同样会影响碎片整理、key过期、key淘汰这样一些功能，严重时引起主从超时和切换
生产建议：
单个实例一般在10G以下为最佳，这里视具体资源，如果是SSD，可考虑20G左右
如果是业务上存储量确实很大，这里建议大家从业务上拆分，拆分成多个实例
春风阁讲堂出品
295
---
## Page 296
19.3.Cluster集群不宜过重
1.RedisCluster集群是Redis3以后的一种高可用架构方案，解决了Sentinel模式下不能动态扩容的问题
2.这给很多维护者造成误区，把有的业务放到一个Redis集群里面，然后再通过扩容来解决，虽然Redis官方给出了Reids集群的理论上限为1000，
但其实在生产中，远远达不到
3.随着Redis集群的扩大，Redis之间的通信开销会加大，同时不同的业务场景之间会相互影响
4.不同的业务对Redis的需求可能不一样，比如是否需要持久化
生产建议：
1.通过业务上进行拆分，将无关业务拆分成不同集群
2.将大集群拆分成小集群，这种由大到小的拆分方式，在问题处理、故障隔离上都方使和安全很多
春风阁讲堂出品
296
---
## Page 297
19.4.应用场景中缓存穿透
19.4.1.问题现象
应用程序
回顾一下我们17.2章节中热点场景下的数据加速流程
1.
业务请求进来后，优先从缓存加载数据
热点场景
2.若命中，则直接返回
数据加载
3.没未命中，则从数据库查询
4.
若数据库命中，则将值重写缓存
1、
若缓存命中则从缓存加载
但如果出现以下这两种特殊情况，比如：
Redis
2、
若缓存未中则从数据库加载
用户请求的id在缓存中不存在？
3、将数据写入Redis
2.
恶意用户伪造不存在的id发起请求！
这样的用户请求导致的结果是：每次从缓存中都查不到数据，
而需要查询数据库，同时数据库中也没有查到该数据，也没法
数据库
放入缓存。也就是说，每次这个用户请求过来的时候，都要查
询一次缓存+数据库
春风阁讲堂出品
297
---
## Page 298
19.4.2.解决方案
1.业务上采用一定的规则进行过滤，这是最好的方案，没有之一，比如电话号码，邮箱等等，这种方法对恶意用户攻击有奇效
2.把空也定义成一个特殊的对象，但这种方法在恶意攻击时，内存可能会溢出
3.采用布隆过滤器作前置过滤，布隆过滤器虽然有一定的误差，但问题不大
（当布隆过滤器说某个值存在时，这个值可能不存在：当它说不存在时，那就肯定不存在）
key1
hash1
hash2
hash3
春风阁讲堂出品
298
---
## Page 299
19.5.应用场景中缓存击穿
19.5.1.问题现象
应用程序
热点Key失效触发
正常情况下
数据初始
请求Redis
在某些Key属于极端热点数据，且并发量很大的情况下，如果这个key
2
3
过期，可能会在某个瞬间出现大量的并发请求同时执行，相当于大量
的并发请求直接打到了数据库。这种情况，就是我们常说的缓存击穿
出现这种现象，一般有以下几个明显特征
Redis
多线程下导致
应用的并发量特别大，一般这个大，是相当于数据库来讲
数据库请求激增
2.
某一个热点Key的极端大，比如热点新闻，TOP点击榜
3.缓存重构特别费时间，比如复杂的SQL、多次IO
数据库
春风阁讲堂出品
667
---
## Page 300
19.5.2.解决方案
1.优化热点Key的重构，让其尽可能简单
2.重构时增加分布式锁，或者单机锁，避免多线程同时进行缓存重构
3.提前进行缓存的自动续期
春风阁讲堂出品
300
---
## Page 301
19.6.应用场景中缓存雪崩
19.6.1．问题现象
而缓存雪崩是缓存击穿的升级版，缓存击穿说的是某一个/类热门key失效了，而缓存雪崩说的是有多个热门key同时失效。看起来，如果发生
缓存雪崩，问题更严重
出现的原因一般有两种：
2.缓存服务器down机了，可能是机器硬件问题，或者机房网络问题。总之，造成了整个缓存的不可用
19.6.2.解决方案
1.分采用分批过期，比如随机时间过期，让缓存过期的时间点避免过度集中
2.Redis部署采用高可用集群方式
3.应用上作熔断+服务降级
ps：雪崩现象并不是Redis特有，在我们几乎所有的分布式架构中，都存在这种现象，比如在一个应用，同时连接了A、B数据库，提供了基于A、
B数据库的相关服务，如果数据库A出问题了，有可能导致基于B数据库的服务也被影响，大家想想，这是为什么呢？
1、如果A、B在一线程，那么必受影响
2、如果A、B在同一个进程（JVM)，如果不作熔断的话，那么将耗光所有进程资源，B也会受影响
3、如果A、B跨机器/节点，但仍在同一个集群，那么B有可能也会受到间接影响
春风阁讲堂出品
10≤
---
## Page 302
19.7.应用场景中bigKey问题
回顾一下我们16.3章节中性能基准测试的结果
Redis值大小与性能测试
1.图右是Redis性能与键值大小的关系图
2.随着值往上增大，Redis性能承下降趋势
值大小（k)读tps写tps
3.一般我们在设计Redis的值大小时，建议在10K以下
60000
4.结合具体的场景，我们可以采用Hash,List类型进行替
换处理
50000
5.bigKey问题，同样会影响碎片整理、key过期、key
40000
淘汰这样一些功能，严重时引起超时和主从切换
30000
20000
10000
0
0.03
1
2
A
8
10
16
20
30
40
100
春风阁讲堂出品
302
---
## Page 303
19.8.Redis与本地缓存平衡
Redis性能非常高，但Redis缓存不是万能的，且性能肯定是低于本地缓存，所以
Redis客户端模式
在项目中我们需要平衡好Redis缓存与本地缓存
1.Redis主要在于存储空间大，而且可以扩容，但性能较本地慢
应用程序
2.本地缓存主要在于性能高，但空间一般较小，且不可以扩容
生产建议：
1.查询
2.查询
3.Redis
1.
一般性能要求特别高、而且存储空间要不求不大的，我们优先使用本地缓存
本地缓存
Redis缓存
失效
2.
如果存储要求特别大，那只能用Redis缓存
本地级缓存
4.查询
3.可以考虑Redis中的本地缓存策略，这样在缓存更新、加载方面会方便很多
数据库
5.更新
本地缓存
Redis缓存
数据库
春风阁讲堂出品
303
---
## Page 304
19.9.Redis最佳实践
1.规范部署、规范目录、自制脚本，搭建一个稳定的Redis环境
2.主从模式下、cluster模式下中主从节点一定要分机器部署，防单点故障
3.一定要同网部署，同交换机为最佳，时间<2ms，否则意义不大
4.单个节点内存不宜过多，太大会影响性能，如果数据量多，建议从业务上进行拆分，一般经验值不超过10G
5.Redis的值对象不宜过大，1K级别为最好，超过10K时，要特别小心，可能会影响性能问题
6.虽然万物皆可为String，但若操作对象存在复杂结构时，优先考虑Hash，List等其它类型
7.在无强烈持久化需求时，建议不要开启AOF机制
8.无论Redis如何演进，目前缓存仍然作为Redis最多、最稳定的使用场景
9.一定要防止Key集中过期，防止给业务带来较大波大
10.建议线上采用普通密码认证方式或者ACL机制，不建议无密码、TLS机制
11.上线前做好基准测试，预估一下Redis性能数据
春风阁讲堂出品
---