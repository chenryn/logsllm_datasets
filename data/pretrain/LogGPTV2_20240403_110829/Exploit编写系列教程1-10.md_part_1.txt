Exploit 编写系列教程 1 - 10
目录
译序............................................................................................................................................2
Exploit 编写系列教程第一篇：栈溢出...............................................................................3
Exploit 编写系列教程第二篇：跳至ShellCode............................................................25
Exploit 编写系列教程第三篇a：基亍SEH的Exploit.................................................54
Exploit 编写系列教程第三篇b：基亍SEH的Exploit—又一个实例........................77
Exploit 编写系列教程第四篇：编写Metasploit Exploit.............................................83
Exploit 编写系列教程第五篇：利用调试器模块及插件加速exploit开发.................94
Exploit 编写系列教程第六篇：绕过Cookie,SafeSeh,HW DEP 和ASLR..............126
Exploit 编写系列教程第七篇：编写Unicode Exploit................................................218
Exploit 编写系列教程第八篇：Win32 Egg Hunting..................................................256
Exploit 编写系列教程第九篇：Win32 Shellcode编写入门......................................316
Exploit 编写系列教程第十篇：利用ROP绕过DEP.....................................................432
附录A：对《基亍栈的溢出》一文的补充.......................................................................509
附录B：对《编写unicode exploit》一文的补充........................................................511
译序
经过众兄弟十个多月来的努力，终亍将此与题翻译完成。其实本与题是否已经结束，我也曾就此问过
作者，但他也丌确实；另外又问了他是否会写关亍堆溢出的文章，他说堆溢出相对复杂多了，目前丌会写，
但以后可能会。纵观此系列教程，文中已经揽括当前大部分栈溢出利用技术，幵针对各种 windows 安全
机制讲述了各种绕过方式，是本人目前见过关亍栈溢出方面最为完整，最为全面的教程，很佩朋作者的这
种共享精神，这也正是国内所缺乏的。随着明年《0day 安全：软件漏洞分析技术》第 2 版的出版，也就
渐渐地弥补了当前国内关亍深入 windows 溢出书籍的空缺，之前的《网络渗透技术》是国内第一本溢出
书籍，但涉及平台过，而丏年代久远，一些新兴技术未能概述其中，新书的出版也正弥补了这一点。这套
教程对亍 windows 平台上的栈溢出讲述得相当详细，在翻译过程中都让人觉得有点厌烦，同时也由此可
见作者是相当的有耐性！对亍广大溢出初学者戒者刚入门的朊友，确实是套丌错的教程，在此也给阅读本
教程的朊友一个建议：纸上得来终觉浅，绝知此事要躬行！在制作本电子书的过程中，曾本想叫原作者perter
为此写个前言，但他说怕侵犯到版权问题，必须确保没有人利用此教程获取经济利益，幵说需要时间让他
考虑，可能几天甚至几周，因此提前发布本教程。如果后面原作者答应为此写上前言，我会再补充上去幵
发到论坛上的。最近特别感谢cntrump兄弟对本与题进行整理幵制作成电子书，同时感谢看雪上诸位参不
翻译的兄弟，没有他们就没有本与题的出现，但究亍各位译者水平有限，文中难免有误（也确实存在丌少
问题），望见谅。另外由亍译文是由各位译者直接发在论坛上，本人幵没有进一步检查幵统一文章格式，因
此文中存在丌少表达错误，图片丌够清晰，甚至各译文的格式也是差异甚多，究亍时间关系未能一一纠正，
请大家多多海涵！除本人之外，其他参不本与题翻译的各位兄弟分别如下（按翻译先后排列）：moonife、
dge、秋风寒、dragonltx，翻译的过程是辛苦的，感谢各位兄弟的无私奉献，同时献诗一首以共勉：
尘世须臾堪几何，勿令逝者付东流
年少可学须勤学，莫待白首空叹息
riusksk（泉哥）
2010/10/24夜记于厦门
Exploit 编写教程第一篇：基于栈的溢出
译：看雪论坛-moonife-2009-11-16
上个星期五（2009.7.17），一个叫„Crazy_Hacker‟的人（nick）在packetstormsecurity.org.
网站报告了一个存在于Easy RM to MP3 Conversion Utility (on XP SP2 En)软件中的漏洞
（http://packetstormsecurity.org/0907-exploits/）。同时还发布了漏洞利用的POC代码（顺便
说下，在我的虚拟机xp sp3 英文版中利用不成功）。没多久另一个Exploit也放了出来。
漂亮。你可以复制这个POC代码，运行它，也许看到它没利用成功（或者你真的幸运的话，
会成功的）。又或者你试着理解它并编译自己的可以成功利用的Exploit；在者你就从头开始
编写自己的Exploit。
在啰嗦下：除非你真能够快速的反汇编和读懂shellcode，否则我建议你不要拿到一个Exploit
（特别是已经编译了的可执行文件）就运行它，假如它仅仅是为了在你电脑上开一个后门
呢？
问题是：Exploit 作者是怎样开发他们的利用程序的呢？从检测可能存在的问题到编写可以
利用成功的Exploit这个过程是怎么样的呢？您如何使用漏洞信息，编写自己的Exploit呢？
自从我这个Blog的建立，写缓冲区溢出利用的基础教程就摆到了我“To Do”列表上了，但
是我真的没时间去写（要不就是忘了）。
今天当我看到这个漏洞报告的时候，大致看来一下它的利用，我意识到这个漏洞报告可以用
来做为展示如何编写基本的 Exlpoit 的完美案例。它的简洁可以让我用来展示编写有效和稳
定的基于缓冲区溢出的Exlpoit的一些技术。
所以现在也许是个好时机.....尽管这个漏洞已经有了一个Exploit（无论它是否真的有效），我
依然用这个存在于Easy RM to MP3 Conversion Utility上漏洞作为一个案例来迈出我们编写
有效的Exploit的第一步，当然是在手上没有其他人给出Exploit的情形下。我们将从头开始
开发（环境是在XP sp3 下）。
在我们开始之前，我先做如下声明：这个文档只作为纯粹的教育目的，我不想任何人用这个
文档上或我博客上的任何信息真的去攻击电脑或破坏行为。因此我对使用这些信息而做出的
破坏行为不负任何的责任。到时如果我不允许，你将不能继续访问我的网站，所以如果你怀
着龌龊的目的，请你马上离开！
不管怎么样，开始吧！通常你可以在漏洞报告中得到基本的信息。在本例中，基本信息有：
“通过创建一个恶意的.m3u文件将触发Easy RM to MP3 Converter version 2.7.3.700缓冲区
溢出利用。”这些报告往往没什么特别之处，但在多数情况下，你会从中得到一些灵感来模
拟一次崩溃或让程序行为异常。如果没有，那么第一个发现的安全研究人员可能会透露给供
应商，给他们机会修补...或者只是想保密为他/她所用...
开始Exploit编写系列（希望）教程第一部分之前，请允许我介绍下我发起的讨论组（需
要注册），在那里你可以讨论Exploit 的编写相关问题。可通过这个网址访问：
http://www.corelan.be:8800/index.php/forum/writing-exploits/
验证Bug
首先，让我们验证当这个程序打开恶意构造的 m3u 文件的时候确实崩了（或者找一个类似
的当打开特别构造数据文件的时候崩溃的程序）。
在XP上安装带有漏洞的Easy RM to MP3程序版本。漏洞报告指出这个Exploit工作在xp sp2
下，但是我用sp3（英文版）。
程序在这里下载（moonife：没下载地址，自己找）：
提示: 你可以到oldapps.com 和 oldversion.com找到旧的版本
我们将用下面简单的perl脚本来创建一个m3u文件，或许它或帮我们找到关于这个漏洞的更
多有用信息。
my $file= "crash.m3u";
my $junk= "\x41" x 10000;
open($FILE,">$file");
print $FILE "$junk";
close($FILE);
print "m3u File Created successfully\n";
运行这个perl脚本创建m3u文件，文件将被10000个A（0x41）字母来填充，然后用Easy RM
to MP3打开............程序抛出一个错误，但是看起来这个错误被程序异常处理例程捕捉到了，
程序并没崩掉。试下 20000 个 A，一样的结果（看来还没冲掉有用的信息啊）。很好，换
30000个.....
Boom-程序崩掉了
好，这样看了程序在20000到30000个之间可以崩掉，那么我们用这个可以做什么呢？
验证Bug是否可以勾起我们的兴趣
很明显，一个程序的崩溃并不都意味着存在可利用的漏洞，在多数情况下，程序崩溃并不能
利用，但是有时候是可以利用的。“可利用”，我是指你可以让程序做出“越轨“的事...
比如执行你自己的代码，让一个做越轨的事最简单的方法是控制它的执行流程（让它指向别
是什么地方）。可通过控制指令指针（EIP），这个CPU寄存器永远指向下一条要执行的指
令地址。
假定程序调用只有一个参数的函数，在进入函数前，它要先保存当前指令的地址（moonife：
返回地址压栈，这个地址具体是 call XXXX 指令的下一条指令起始地址），如果你改变这
个指针（EIP）的值，让它指向你的代码片段，这样你就获得了程序流程的控制权和让它干
越轨的事了。一般的在控制流程后让程序执行你希望执行的那些代码叫做“shellcode”。如
果我们可以让程序执行我们的shellcode，我们可以叫它“Working Exploit”。多数情况下这
个指针叫它EIP。这个寄存器大小为4 Byte。所以你可以修改这四个字节，在你的程序（或
电脑上正在运行的程序）。
继续前需要的一些理论知识
我们只需要很少的几个术语
用户进程空间中关键的3个组成部分：
代码段：（包含可执行程序中的指令。EIP始终指向下一条指令）
数据段：（变量，动态的缓冲区）
栈段：（用了传数据/参数给函数，还用作局部变量的的空间。栈段从（=栈的底部））整个
虚拟内存页（4KB）低部开始向低地址方向增长。Push指令将把一个4byte大小的值压入栈，
pop则将一个4byte大小的值入栈。如果你要直接访问栈中数据，可以通过ESP,它永远指向
栈顶。
当执行push指令后，ESP将指向低地址（ESP-4）， 而执行pop指令的时候，ESP将指向
高地址（ESP+4）。
当进入一个函数/例程中的时候，将创建一个函数帧。这个帧和调用者传进来的参数连在一
起和被用来给子例程传参数。可通过ESP获得当前栈顶，通过EBP获得函数帧的底部。
CPU（Intel，x86）各主要寄存器的一般用途：
EAX：存储器：用于执行计算，并用于存储函数的返回值。基本操作，如加，减，比较使用
这个通用寄存器
EBX：存储数据
ECX：计数器：常用于计数循环的次数。
EDX：数据
ESP：栈顶指针
EBP：基指针（常用来表示一个函数帧的底部）
ESI：源操作数指针
EDI：目的地址指针
EIP：指令指针
用户进程空间映像如下图所示：
.text区块是只读的，包含了程序的执行代码，防止被修改。这些虚拟内存区块有着固定的大
小。.data和.bss区块被用来保存全局和静态的变量。.data区块用于已经初始化的全局变量，
字符串，和其他的内容。.bss区块用于未初始化的变量...这两个区块都是可写的和有固定的
大小。堆区块被用于其他的变量（moonife：动态申请的）。它可以根据需要来改变大小。
堆内存的分配工作由系统来管理。
栈的数据结构特点是LIFO（后进先出）。最后通过push压入的将最先被pop弹出。栈包括
局部变量，函数调用和不需要长期保存的其他信息。每一个数据被压入，往低地址方向生长。
每调用一个函数，参数都将会并诶调用者压入栈中，同时保存 EBP 和 EIP 的值。当函数返
回时，保存的栈中原EIP值将弹出到EIP中，所以正常的执行流程被恢复。
这样：当函数 Do_Something(param 1)被调用，有以下步骤：
Push param 1
Call Do_Something 的同时push EIP（返回地址）
Push EBP，这是必须的 ，因为我们需要改变EBP的值来引用栈中的值，这是通过mov ebp,esp
来实现的，所以栈中的数据，很容易被引用。
最后，局部变量被压入栈，在我们这个例子是：do_something::buffer[128]。
因此，当函数结束的时候，将返回main函数。
Memory map :
.text
__________________________
.data
__________________________
.bss
__________________________
__________________________
do_something::buffer[128]
__________________________
Top of stack. ESP points to
begin of saved EBP
do_something::buffer[128] __________________________
saved EIP
__________________________
ptr to param1
__________________________
main() local vars
__________________________
envp, argv, etc
Bottom of stack
__________________________
如果想要引发缓冲区溢出，你需要重写do_something::buffer空间以及被保存的EBP和最终EIP
的值。当我们的do_something函数返回的时候，从栈中弹出已被重写的EIP的和EBP。长话短
说，通过控制EIP，函数将使用被改变的返回地址来“恢复正常流程”。如果你可以重写缓
冲区，EBP，EIP和把你自己的代码放到“prt to param1”在（moonife：进入函数前压入的参数
所在的栈位置）的地方...思考下。在缓冲区被填充为[buffer][EBP][EIP][your code]后，ESP
应该就指向你代码开始的地方了。所以只要你让EIP指向你的代码，控制权在你手中了！
为了观察栈中数据和各寄存器的值，我们需要把一个调试器附加到程序上，如此我们就可以
观察程序的运行情况（特别的崩溃现场）。
这里有很多调试器可以到达这个目的，为经常使用的是：Windbg, OllyDbg, Immunity‟s
Debugger 和 PyDBG
这里我们用WinDbg，按照WinDbg（完全安装）和用“windbg -I”注册它为一个“post-mortem”
调试器。
你可以禁止 “xxxx has encountered a problem and needs to close” 的弹窗通过设置下面的键值:
HKLM\Software\Microsoft\Windows NT\CurrentVersion\AeDebug\Auto : 设为0
为了避免WinDbg找不到符号文件，在硬盘上创建一个文件夹（如：c:\windbgsymbols）。打
开WinDbg，然后“File”->“Symbol File Path”，输入以下字符串：
SRV*C:\windbgsymbols*http://msdl.microsoft.com/download/symbols
好了，让我们开始吧！
运行Easy RM to MP3，并打开恶意构造的m3u文件。程序再次崩溃，如果你已经禁止了弹窗，
WinDbg会自动捕获异常，如果没有禁止，点击“debug”按钮开始用WinDbg调试。
我们可以看到此时EIP的值被覆盖为41414141，是AAAA的16进制形式。
小知识补充：在Intel X86上，采用小端字节序（moonife：地址低位存储值的低位，地址高