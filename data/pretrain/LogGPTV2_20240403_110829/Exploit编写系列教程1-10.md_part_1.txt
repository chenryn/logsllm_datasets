# Exploit 编写系列教程 1 - 10

## 目录
- 译序............................................................................................................................2
- 第一篇：栈溢出........................................................................................................3
- 第二篇：跳至ShellCode.......................................................................................25
- 第三篇a：基于SEH的Exploit..........................................................................54
- 第三篇b：基于SEH的Exploit—又一个实例..................................................77
- 第四篇：编写Metasploit Exploit.....................................................................83
- 第五篇：利用调试器模块及插件加速exploit开发.........................................94
- 第六篇：绕过Cookie, SafeSeh, HW DEP 和 ASLR......................................126
- 第七篇：编写Unicode Exploit.........................................................................218
- 第八篇：Win32 Egg Hunting..........................................................................256
- 第九篇：Win32 Shellcode编写入门...............................................................316
- 第十篇：利用ROP绕过DEP...........................................................................432
- 附录A：对《基于栈的溢出》一文的补充.......................................................509
- 附录B：对《编写unicode exploit》一文的补充........................................511

### 译序
经过各位成员近一年的努力，我们终于完成了本专题的翻译工作。虽然不确定该系列是否已经完结，但作者表示目前不会撰写关于堆溢出的文章，因为其复杂度较高。此系列涵盖了当前大部分栈溢出利用技术，并详细介绍了如何绕过各种Windows安全机制，是迄今为止最为全面和详尽的栈溢出教程之一。随着明年《0day 安全：软件漏洞分析技术》第二版的出版，国内关于深入探讨Windows平台溢出的书籍空白将得以填补。之前的《网络渗透技术》是国内首部关于溢出的书籍，但由于涉及平台广泛且年代久远，未能涵盖一些新兴技术。新书的发布正好弥补了这一点。

这套教程对于Windows平台上栈溢出的讲解非常细致，在翻译过程中甚至让人感到有些繁琐，可见作者的耐心与专业精神。对于初学者或刚入门的朋友来说，这是一套非常有价值的教程。在此建议读者：理论学习固然重要，但实践操作更为关键。在制作电子书的过程中，曾尝试邀请原作者Peter为本书撰写前言，但他担心版权问题并希望确保无人利用此教程获取经济利益，因此需要时间考虑。如果后续他同意添加前言，我们会及时更新并发布到论坛上。特别感谢cntrump兄弟对本专题进行整理并制成电子书，同时也感谢看雪论坛上的各位参与翻译的朋友们。由于时间有限，文中可能存在表达错误、图片不清晰以及格式差异等问题，敬请谅解。

除本人外，其他参与本专题翻译的人员（按翻译顺序排列）如下：moonife、dge、秋风寒、dragonltx。以下是献给所有无私奉献者的诗句：
尘世须臾堪几何，勿令逝者付东流。
年少可学须勤学，莫待白首空叹息。

riusksk（泉哥）
2010/10/24 夜记于厦门

### 第一篇：基于栈的溢出
**译者：看雪论坛-moonife-2009-11-16**

2009年7月17日，一位名为“Crazy_Hacker”的用户在packetstormsecurity.org网站上报告了一个存在于Easy RM to MP3 Conversion Utility (on XP SP2 En)软件中的漏洞（详情见 http://packetstormsecurity.org/0907-exploits/）。同时发布了漏洞利用的POC代码（注：在我的XP SP3英文版虚拟机中未能成功复现）。不久后，另一个Exploit也出现了。你可以复制这个POC代码，运行它，或许会看到它并未成功（或者你足够幸运的话，可能会成功）。或者你可以尝试理解并修改该代码以创建一个成功的Exploit；再或者从头开始编写自己的Exploit。

需要注意的是，除非你能快速反汇编并理解shellcode，否则不要轻易运行任何未知来源的Exploit，尤其是已编译的可执行文件，以防它们可能包含恶意代码。

那么，Exploit作者是如何开发这些利用程序的呢？从检测潜在漏洞到编写成功利用的过程又是怎样的呢？你如何根据漏洞信息来编写自己的Exploit呢？

自从我开设这个博客以来，一直计划撰写一篇关于缓冲区溢出基础的教程，但由于种种原因一直未能成行。今天，当我看到这份漏洞报告时，发现它可以作为展示如何编写基本Exploit的一个完美案例。其简洁性使我能够演示一些有效的基于缓冲区溢出的Exploit编写技术。

现在可能是开始的好时机。尽管这个漏洞已经有了一个Exploit（无论它是否真的有效），我还是决定用这个存在于Easy RM to MP3 Conversion Utility上的漏洞作为一个案例，来展示如何从零开始编写一个有效的Exploit（环境为XP SP3）。

在开始之前，请注意：本文档仅用于教育目的。我并不希望任何人使用文档中的信息进行非法活动。因此，我对由此产生的任何破坏行为不负责任。如果你有不良企图，请立即离开！

无论如何，让我们开始吧！通常情况下，你可以在漏洞报告中找到基本信息。在这个例子中，基本信息包括：“通过创建一个恶意的.m3u文件，可以触发Easy RM to MP3 Converter version 2.7.3.700的缓冲区溢出。” 这些报告往往没有太多细节，但在大多数情况下，你会从中获得灵感来模拟崩溃或异常行为。如果没有，最初的安全研究人员可能会将信息透露给供应商，让他们有机会修复漏洞……或者仅仅为了保密而自己使用。

在开始本系列的第一部分之前，我想介绍一下我发起的讨论组（需注册），在那里你可以讨论与Exploit编写相关的问题。网址为：http://www.corelan.be:8800/index.php/forum/writing-exploits/

#### 验证Bug
首先，我们需要验证当程序打开恶意构造的m3u文件时确实会崩溃（或找一个类似的在打开特定数据文件时崩溃的程序）。

在XP上安装带有漏洞的Easy RM to MP3程序版本。漏洞报告指出该Exploit适用于XP SP2，但我使用的是SP3（英文版）。你可以从oldapps.com 或 oldversion.com下载旧版本。

我们将使用以下简单的Perl脚本来创建一个m3u文件，或许能帮助我们找到更多关于这个漏洞的信息：

```perl
my $file = "crash.m3u";
my $junk = "\x41" x 10000;
open($FILE, ">$file");
print $FILE "$junk";
close($FILE);
print "m3u File Created successfully\n";
```

运行这个Perl脚本创建m3u文件，文件将被10000个'A'（0x41）填充，然后用Easy RM to MP3打开……程序抛出了一个错误，但看起来这个错误被程序的异常处理例程捕获了，程序并未崩溃。试试20000个'A'，结果相同（看来还未覆盖有用的信息）。很好，换成30000个……

程序崩溃了！

显然，程序在20000到30000个字符之间崩溃。那么，我们接下来可以做些什么呢？

#### 判断Bug是否可利用
显然，并非所有的程序崩溃都意味着存在可利用的漏洞。在多数情况下，崩溃并不能被利用，但有时是可以的。“可利用”是指你可以让程序执行你的代码，从而实现某些“越轨”行为。最简单的方法是控制程序的执行流程，即通过控制指令指针（EIP），这个CPU寄存器始终指向要执行的下一条指令地址。

假设程序调用一个只有一个参数的函数，在进入函数之前，它会保存当前指令的地址（返回地址压栈，这个地址具体是call XXXX指令的下一条指令起始地址）。如果你改变这个指针（EIP）的值，让它指向你的代码片段，你就获得了程序流程的控制权，并可以让它执行你的代码。这种在控制流程后让程序执行的代码通常被称为“shellcode”。如果我们能让程序执行我们的shellcode，我们就可以称之为“Working Exploit”。多数情况下，这个指针称为EIP。这个寄存器大小为4字节。因此，你可以修改这四个字节，在你的程序（或电脑上正在运行的程序）中。

#### 理论知识
我们需要了解几个关键术语：

- **用户进程空间的关键组成部分**：
  - 代码段：包含可执行程序中的指令。EIP始终指向下一条指令。
  - 数据段：变量和动态缓冲区。
  - 栈段：用于传递数据/参数给函数，还用作局部变量的空间。栈段从整个虚拟内存页（4KB）低部开始向低地址方向增长。Push指令将把一个4字节大小的值压入栈，pop则将一个4字节大小的值弹出栈。直接访问栈中数据可以通过ESP，它永远指向栈顶。

- **CPU（Intel，x86）各主要寄存器的一般用途**：
  - EAX：存储器，用于执行计算，并用于存储函数的返回值。基本操作如加、减、比较使用这个通用寄存器。
  - EBX：存储数据。
  - ECX：计数器，常用于计数循环的次数。
  - EDX：数据。
  - ESP：栈顶指针。
  - EBP：基指针，常用来表示一个函数帧的底部。
  - ESI：源操作数指针。
  - EDI：目的地址指针。
  - EIP：指令指针。

用户进程空间映像如下图所示：

```
.text
__________________________
.data
__________________________
.bss
__________________________
__________________________
do_something::buffer[128]
__________________________
Top of stack. ESP points to
begin of saved EBP
do_something::buffer[128] __________________________
saved EIP
__________________________
ptr to param1
__________________________
main() local vars
__________________________
envp, argv, etc
Bottom of stack
__________________________
```

若要引发缓冲区溢出，你需要重写`do_something::buffer`空间以及被保存的EBP和最终EIP的值。当`do_something`函数返回时，从栈中弹出已被重写的EIP和EBP。简而言之，通过控制EIP，函数将使用被改变的返回地址来“恢复正常流程”。如果你可以重写缓冲区、EBP、EIP并将你自己的代码放到“ptr to param1”的位置……思考一下。在缓冲区被填充为[buffer][EBP][EIP][your code]后，ESP应该指向你代码的开始位置。因此，只要你让EIP指向你的代码，控制权就在你手中了！

为了观察栈中数据和各寄存器的值，我们需要将调试器附加到程序上，以便观察程序的运行情况（特别是崩溃现场）。

有许多调试器可以达到这个目的，常用的有：Windbg, OllyDbg, Immunity's Debugger 和 PyDBG。这里我们使用Windbg。按照Windbg（完全安装）和用`windbg -I`注册它为一个“post-mortem”调试器。

你可以通过设置以下键值来禁止“xxxx has encountered a problem and needs to close”的弹窗：
- `HKLM\Software\Microsoft\Windows NT\CurrentVersion\AeDebug\Auto` 设为0

为了避免Windbg找不到符号文件，在硬盘上创建一个文件夹（如：c:\windbgsymbols）。打开Windbg，然后选择“File”->“Symbol File Path”，输入以下字符串：
- `SRV*C:\windbgsymbols*http://msdl.microsoft.com/download/symbols`

好了，让我们开始吧！

运行Easy RM to MP3，并打开恶意构造的m3u文件。程序再次崩溃，如果你已经禁止了弹窗，Windbg会自动捕获异常。如果没有禁止，点击“debug”按钮开始用Windbg调试。

我们可以看到此时EIP的值被覆盖为41414141，这是AAAA的16进制形式。

**小知识补充**：在Intel X86架构上，采用小端字节序（地址低位存储值的低位，地址高位存储值的高位）。