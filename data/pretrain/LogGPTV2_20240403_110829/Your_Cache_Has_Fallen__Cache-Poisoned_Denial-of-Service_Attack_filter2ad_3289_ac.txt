(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:32)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
–
–
–
–
✓
✓
–
–
–
–
✓
–
–
–
✓
–
–
–
–
✓
–
–
–
–
–
–
–
–
✓
–
–
✓
–
–
–
–
–
–
–
–
–
–
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
(cid:35)
endpoint for /index.html. In such a case, web frameworks usually
returns an error message, e.g., the status code 404 Not Found
or 405 Method Not Allowed. The shared cache assigns the re-
turned response with the error code to the GET request target-
ing http://example.org/index.html. Since the status codes 404 Not
Found and 405 Method Not Allowed are cacheable according to
the HTTP Caching RFC 7231 as shown in Table 1, caches store and
reuse this error response for recurring requests. Each benign client
making a subsequent GET request to http://example.org/index.html
receives the cached error message instead of the legitimated web
application’s start page.
4.2 HTTP Header Oversize (HHO) Attack
The HTTP standard does not define any size limit for request head-
ers. Hence, intermediate systems, web servers and web frameworks
specify their own limit. Most web servers and proxy caches provide
a request header limit of about 8,000 bytes in order to avoid security
threats such as request header overflow [26] or ReDoS [38] attacks.
However, there are also intermediate systems, which specify a limit
larger than 8,000 bytes. For instance, the Amazon CloudFront CDN
allows up to 24,713 bytes. In an exploratory study we gathered the
default HTTP request header limits deployed by various HTTP
engines and cache systems (see Table 3).
This semantic gap in terms of different request header size limits
can be exploited to conduct a CPDoS attack. To execute an HTTP
Header Oversize (HHO) attack, a malicious client needs to send a
GET request including a header larger than the limit of the origin
server but smaller than the one of the cache. To do so, an attacker
has two options. First, she crafts a request header with many ma-
licious headers. The other option is to include one single header
with an oversized key or value as shown in Figure 4.
The web caching system forwards this request including the
oversized header to the endpoint, since the header size is under
the limit of the intermediary. The web server, however, blocks this
request and returns an error page, as the request exceeds the header
size limit. This returned error page is stored and will be reused for
equivalent requests.
4.3 HTTP Meta Character (HMC) Attack
The HTTP Meta Character (HMC) works similar to the HHO attack.
Instead of sending an oversized header, this attack tries to bypass
a cache with a request header containing a harmful meta charac-
ter. Meta characters can be e.g. control characters such as the line
break/carriage return (\n), line feed (\r) or any other Unicode con-
trol characters. As the \n and \r characters are used by the response
5
Figure 4: Flow and example construction of the HTTP
header oversize (HHO) attack
Figure 5: Flow and example construction of the HTTP Meta
Character (HMC) attack
splitting attack to poison a cache, some HTTP implementations
block requests containing these symbols.
HTTP implementations, which drop such characters, mostly
return an error message signaling that they do not parse this request.
However, there are some cache intermediaries which do not care
about certain control characters. They simply forward the request
including the meta character to the origin server which return
an error code. The resulting error page is then stored and reused
by the cache. This constellation can be exploited by a malicious
client to conduct another form of CPDoS attack. We declare this
vulnerability as HTTP Meta Character (HMC) attack. To do so, the
attacker crafts a request with a meta character, e.g. \n, as shown
in Figure 5. The goal of this example attack in is to fool the origin
server into believing that it is attacked by a response splitting
request. As with the previously presented vulnerabilities, the HMO
request traverses the cache without any issues. Once the request
reaches the endpoint, it is blocked and an according error page is
returned, since the web server is aware of the implications regarding
suspicious characters such as \n. This error message is then stored
and recycled by the corresponding web caching system.
5 PRACTICABILITY OF CPDOS ATTACKS
In order to explore the existence of CPDoS weaknesses in the wild,
we conducted a series of experiments. A crucial prerequisite for a
potential CPDoS vulnerability is a web caching system that stores
and reuses error pages produced by the origin server. Table 1 high-
lights that Varnish, Apache TS, Akamai, Azure, CDN77, Cloudflare,
CloudFront and Fastly do so. Based on these findings, we conducted
three experiments—one for each introduced CPDoS variant—to ex-
amine whether these intermediate systems are vulnerable to CPDoS
attacks.
5.1 Experiments Setup
The first step to analyze whether CPDoS vulnerabilities exist in
practical environments is to figure out vulnerable HTTP implemen-
tations which are utilized as the origin server. HTTP implementa-
tions on the origin server can be diverse systems including, e.g.,
6
reverse proxies, web servers, web frameworks, cloud services or
other intermediate systems as well as another cache.
In our first experiment, we analyzed the method override header
support in web frameworks. Additionally, we also evaluated what
error page is returned when sending a method override header
containing an HTTP method which is not implemented by corre-
sponding resource endpoint. Based on the findings in Table 1 where
we know what error page is stored by what web caching systems,
we inferred what web framework in combination with what web
caching systems might be vulnerable to HMO attacks. For this em-
pirical analysis we chose 13 web frameworks based on the most
popular programming languages according to IEEE Spectrum [17].
The analyzed collection of web frameworks includes ASP.NET v2.2,
BeeGo v1.10.0, Django v2.1.7, Express.js v.4.16.4, Flask v1.0.2, Gin
v1.3.0, Laravel v5.7, Meteor.js v1.8, Rails v5.2.2, Play Framework 1
(Play 1) v1.5.1, Play Framework 2 (Play 2) v2.7, Spring Boot v2.1.2
and Symfony v4.2.
The second experiment investigated the request header size lim-
its of the web caching systems in Table 1 as well as the 13 web
frameworks. As the web frameworks ASP.NET and Spring Boot re-
quires an underlying web server to be deployed in production mode,
we additionally also evaluate the request header limits of Microsoft
Internet Information Services (IIS) v10.0.17763.1 and Tomcat v9.0.14.
Moreover, we also evaluated popular cloud services including Ama-
zon S3, Github Pages, Gitlab Pages, Google Storage and Heroku.
As with the first experiment, we also tested which error code is
returned when the request header size limit is exceeded. With these
findings we figured out what HTTP implementations in conjunc-
tion with what web caching systems are potentially vulnerable to
HHO attacks.
The last experiment evaluated the feasibility of HMC attacks.
Here, we evaluated the handling of meta characters in all mentioned
web caching systems, web frameworks, web servers and cloud ser-
vices. To test as many meta characters as possible we collected as
list of 520 potentially irritating strings. This collection contains
control, special, international and other unicode characters as well
as strings comprising attack vectors including cross site scripting
(XSS), SQL injections and remote execution attacks. The goals of
AttackerGET /index.html HTTP/1.1Host: example.orgX-Oversized-Header: Big valueGET /index.html HTTP/1.1Host: example.orgX-Oversized-Header: Big valueHTTP/1.1 400 Bad RequestContent-Length: 20Content-Type: text/plainHeader size exceededHTTP/1.1 400 Bad RequestContent-Length: 20Content-Type: text/plainHeader size exceededShared CacheOriginServerGET /index.html HTTP/1.1Host: example.orgHTTP/1.1 400 Bad RequestContent-Length: 20Content-Type: text/plainHeader size exceeded321456BenignClientAttackerGET /index.html HTTP/1.1Host: example.orgX-Metachar-Header: \nGET /index.html HTTP/1.1Host: example.orgX-Metachar-Header: \nHTTP/1.1 400 Bad RequestContent-Length: 21Content-Type: text/plainCharacter not allowedHTTP/1.1 400 Bad RequestContent-Length: 21Content-Type: text/plainCharacter not allowedShared CacheOriginServerGET /index.html HTTP/1.1Host: example.orgHTTP/1.1 400 Bad RequestContent-Length: 21Content-Type: text/plainCharacter not allowed321456BenignClientthis study was to analyze what characters and strings are blocked,
sanitized and processed or forwarded without any issues. Moreover,
we also evaluated what error page is triggered when a character or
string is blocked. Based on our findings we were able to conclude
what characters and what symbols need to be send to what constel-
lation of HTTP engine and web caching system to induce an HMC
attack.
5.2 Feasibility of HMO attacks
Table 2 shows the results of the first experiment. It highlights that
Symfony, Laravel and Play 1 support method override headers by
default. Django and Express.js instead do not consider method over-
ride headers by default, but provide plugins to add this feature.
Flask does not offer any plugin for the integration of method over-
ride headers, but provides an official tutorial how to enable it [14].
Table 2 also points out what error code is returned when the web
framework receives a method override header with an action that
is not implemented by the addressed resource endpoint.
Even though the web frameworks with a method overriding
header support return cacheable error codes, we observed that only
Play 1 and Flask are vulnerable to HMO CPDoS attacks. However,
both web frameworks can only be affected if Fastly, Akamai, Cloud-
flare, CloudFront, CDN77 and Varnish are used as intermediate
cache. The reason why these web frameworks are vulnerable lies in
the fact that Play 1 and Flask do perform an HTTP method change
for GET as well as POST requests in case an HTTP method override
header is present. Laravel, Symfony and the plugins for Django and
Express.js are not vulnerable to HMO CPDoS, since they ignore
HTTP method override headers in GET requests and restrict them-
selves to transform the method for POST requests only. Attackers
cannot poison the tested web caching systems with a POST request,
since responses to POST requests are not stored by any of them.
Malicious clients can attack web applications implemented with
the Play 1 by sending a GET request with the method override
header including, e.g., POST as value. If the corresponding resource
endpoint does not implement any functionality for POST, then the
web framework returns the error code 404 Not Found. Akamai,
Fastly, CDN77, Cloudflare, CloudFront and Varnish cache this status
code by default (see Table 1). Flask is also vulnerable to HMO
CPDoS attacks, if the support of HTTP method override headers
is implemented with the official tutorial of the web framework’s
website. However, HMO attacks are only possible, if Akamai and
CloudFront are utilized as CDN, since Flask returns the status code
405 Method Not Allowed. Akamai and CloudFront are the only
analyzed web caching systems, which store and reuse error pages
with this code.