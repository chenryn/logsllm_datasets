title:Using Linearly-Homomorphic Encryption to Evaluate Degree-2 Functions
on Encrypted Data
author:Dario Catalano and
Dario Fiore
Using Linearly-Homomorphic Encryption
to Evaluate Degree-2 Functions on Encrypted Data
Dario Catalano
University of Catania
Catania, Italy
PI:EMAIL
Dario Fiore
dario.ﬁPI:EMAIL
IMDEA Software Institute
Madrid, Spain
ABSTRACT
We show a technique to transform a linearly-homomorphic
encryption into a scheme capable of evaluating degree-2 com-
putations on ciphertexts. Our transformation is surprisingly
simple and requires only one very mild property on the un-
derlying linearly-homomorphic scheme: the message space
must be a public ring in which it is possible to sample el-
ements uniformly at random. This allows us to instanti-
ate our transformation with virtually all existing number-
theoretic linearly-homomorphic schemes, such as Goldwasser-
Micali, Paillier, or ElGamal. Our resulting schemes achieve
circuit privacy and are compact when considering a sub-
class of degree-2 polynomials where the number of additions
of degree-2 terms is bounded by a constant.
As an additional contribution we extend our technique to
build a protocol for outsourcing computation on encrypted
data using two (non-communicating) servers. Somewhat in-
terestingly, in this case we can boost a linearly-homomorphic
scheme to support the evaluation of any degree-2 polynomial
while achieving full compactness.
Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection
Keywords
Homomorphic Encryption; Secure Computation
1.
INTRODUCTION
The problem of enabling computation over encrypted data
is one of the most intriguing questions in cryptography and
has been attracting signiﬁcant attention lately.
In a nut-
shell, this problem involves two parties, a client holding an
input x and a server holding some function f . The goal of
the client is to learn f (x) without disclosing unnecessary in-
formation about x (aka semantic security). The goal of the
server is to perform the computation without revealing to
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813624 .
the client any information (beyond f (x)) about f (aka cir-
cuit privacy). Moreover, to minimize the communication be-
tween client and server as well as the client’s work, it would
be desirable that the server’s response be shorter than the
size of f (aka compactness). Computing on encrypted data
is a problem that arises in a variety of settings, including,
for instance, secure cloud computing, encrypted database
search, and many more.
A natural way to solve the problem is to rely on so-called
homomorphic encryption (HE) schemes. Informally, these
are encryption mechanisms that allow one to perform com-
putations on the encrypted plaintexts by performing similar
operations on the ciphertexts.
In other words, homomor-
phic encryption allows to perform meaningful operations on
plaintexts (e.g., additions and multiplications) without, at
any stage, needing to decrypt the corresponding ciphertexts.
The idea of homomorphic encryption was ﬁrst suggested
in 1978 by Rivest, Adleman and Dertouzous [34], though
its ﬁrst fully-ﬂedged realization was proposed only in 2009
in a breakthrough result by Gentry [17]. Earlier than that,
many other authors suggested encryption schemes that, al-
beit not supporting arbitrary functionalities, still allow for
meaningful operations. This is the case, for instance, of the
Goldwasser-Micali cryptosystem [21], Paillier’s cryptosys-
tem [33] and many other schemes [10, 30, 32, 13, 6, 25].
All these schemes are linearly-homomorphic (i.e., they sup-
port linear functions only), and they can be seen as based
on the same blueprint. Namely, they are all (probabilistic)
public-key encryption schemes based on a discrete log trap-
door modulo a large integer which is hard to factor.1
In
such schemes, the message space is a ring M of modular
residues and ciphertexts are in the group G (denoted multi-
plicatively) of invertible elements of some particular ring of
integers modulo a number hard to factor. The encryption
of a message m is a group element of the form Enc(m; r) =
gmre ∈ G, where e is some public integer, g a ﬁxed pub-
lic element, and r is chosen at random in some particular
(multiplicative) subgroup R of G. Since R is a subgroup,
such schemes have an additive homomorphic property: an
encryption of m1 + m2 can be obtained from any encryption
of m1 and m2, as E(m1; r1)· E(m2; r2) ≡ E(m1 + m2; r1r2).
In other words, (homomorphic) additions of plaintexts are
obtained by multiplying the corresponding ciphertexts.
1An exception is the scheme by Bresson et al. [6] in which
the ciphertext is composed by two group elements, as well
as schemes such as ElGamal “in the exponent” [11] where
the modulus N is allowed to be prime.
1518Generalizing these schemes to support more complex func-
tionalities – say, multiplications – seems like a lost cause at
ﬁrst as, being the ciphertext space only a group, in general
there might be no way to operate on two ciphertexts in order
to obtain a multiplication of the corresponding plaintexts.
A nice exception to this barrier was suggested by Boneh,
Goh and Nissim [3] who revisited the above blueprint in
the context of composite-order bilinear groups, and in this
setting show how to use the bilinear map to gain one sin-
gle multiplication on encrypted plaintexts. However, this
construction is very speciﬁc to bilinear groups, and it re-
mains an intriguing open problem whether it is possible to
extend any linearly-homomorphic scheme (e.g., Paillier or
Goldwasser-Micali) in a natural way in order to support
multiplications.2 Beyond its theoretical interest, answering
this question in the positive, might allow to build homomor-
phic cryptosystems that could adopt (directly and for free!)
many of the satellite protocols, tools (e.g., ZK-PoK, thresh-
old variants and so on), libraries and standard parameters
that have been studied and developed for the underlying
linear schemes over the last thirty+ years.
1.1 Our Contribution
Homomorphic Encryption for Quadratic Functions.
Our main result is a way to generalize the blueprint de-
scribed above3 in order to gain the possibility of performing
one multiplication on encrypted plaintexts. Slightly more in
detail, we show a simple technique which takes a linearly-
homomorphic encryption scheme and uses it to build an HE
scheme which supports arithmetic computations of degree 2
on ciphertexts.4
Our technique is quite generic and requires only one very
mild property from the underlying linearly-homomorphic
scheme: the message space must be a public ring in which
it is possible to sample elements uniformly at random. We
call HE schemes satisfying this property public-space and
we show that virtually all existing schemes are so (or can be
easily modiﬁed in order to become so). This means that we
can instantiate our transformation with a variety of exist-
ing schemes (e.g., [20, 10, 30, 33, 13, 6, 25]) thus obtaining
several HE schemes capable of evaluating one multiplication
and whose security relies on a variety of assumptions, such
as quadratic/composite residuosity, DDH, or decision linear,
to name a few. Furthermore, when applied to the BGN en-
cryption scheme [3], our solution yields an HE scheme that
supports computations of degree up to 4.
Our technique is surprisingly simple, and at an intuitive
level it works as follows. Starting from a linearly homomor-
phic encryption scheme HE = (KeyGen, Enc, Dec) based on
the blueprint described above, the idea is to modify an en-
cryption of m into a “multiplication-friendly” encryption of
the same plaintext. Slightly more in detail, given Enc(m),
we choose a random b(cid:48) ∈ M and set the new ciphertext as
C = (b(cid:48), Enc(m − b(cid:48))), where “−” denotes subtraction (i.e.,
addition of the additive inverse) in the ring M. Notice that
2At this point it is worth noting that Ishai and Paskin [24]
build HE from a linearly-homomorphic scheme, albeit in a
“less natural way”. We discuss this work in more detail later
on in the related work section.
3Actually, we do not need to assume the group structure –
we do it here only for ease of exposition.
4Precisely, our solution achieves compactness for a subclass
of degree-2 polynomials that we specify slightly below.
by setting b(cid:48) = m− b, for some unknown b, the above can be
rewritten as C = (m−b, Enc(b)). To perform the multiplica-
tion one proceeds as follows. Given C1 = (m1 − b1, Enc(b1))
and C2 = (m2 − b2, Enc(b2)) one ﬁrst computes the product
(m1 − b1)(m2 − b2), moves it up to the ciphertext space (i.e.,
encrypts it), and then (homomorphically) removes the terms
m1b2 and m2b1 from the product by exploiting the linearly-
homomorphic properties of HE. Slightly more in detail, one
computes C = (α, β1, β2) where:
α = Enc(m1m2 − b1b2)
= Enc ((m1 − b1) · (m2 − b2)) ·
·[Enc(b1)(m2−b2)] · [Enc(b2)(m1−b1)]
β1 = Enc(b1),
β2 = Enc(b2)
stant L, i.e., polynomials of the form P ((cid:126)x) +(cid:80)L
Decryption of any ciphertext (α, β1, β2) works by ﬁrst re-
trieving b1 and b2 (from β1 and β2) and then by adding
(b1b2) to the decryption of α. At this point, once obtained
ciphertexts via the above manipulations, these can be kept
additively-homomorphic. This however comes at the cost of
loosing compactness. In fact, addition after multiplication
consists into homomorphically adding the α components of
the ciphertexts and concatenating the β components. So the
ciphertext will start growing (linearly) with additions after
performing the multiplication (this also means that decryp-
tion cost increases linearly as well). Importantly, however,
we show a technique to re-randomize ciphertexts so as to
achieve circuit privacy. To be precise, our scheme compactly
supports all degree-2 multivariate polynomials in which the
number of additions of degree-2 terms is bounded by a con-
i=1 Qi((cid:126)x) ·
Ri((cid:126)x) where P, Qi, Ri are linear.
In fact, assuming that
P, Qi, Ri have at most n terms each, the decryption cost
is O(L) in contrast to the cost of evaluating f ((cid:126)x) which is
O(n · L). Despite limited, this class of computations is still
meaningful in some contexts. For instance, we observe that
the celebrated SPDZ protocol [14] requires a somewhat ho-
momorphic encryption scheme capable of evaluating exactly
this class of computations (for L = 1). Finally, as we il-
lustrate in a couple of paragraphs below, we show how to
completely remove this compactness issue in a novel pro-
tocol for outsourcing computation on encrypted data using
two servers. In this case we can boost linearly-homomorphic
encryption to evaluate any degree-2 multivariate polynomial
on encrypted data.
On the importance of being simple and black box. Be-
yond its simplicity, a very attractive feature of our technique
is that it applies in a black box way to essentially all known
linearly-homomorphic encryption schemes. This allows us
to directly “inherit” all the protocols and tools previously
developed for the underlying schemes.
Providing alternatives to existing schemes. Our
construction provides the ﬁrst realizations of practical ho-
momorphic encryption schemes (beyond linear) in groups
like Z∗
N . Compared to the recent lattice-based homomorphic
encryption schemes, ours are clearly much less expressive.
Yet we believe that our results remain relevant for at least
two reasons. First, they provide alternatives to lattice-based
cryptography. Given our current understanding of complex-
ity theory it is possible to imagine a world where the lattice
problems used to build homomorphic encryption are easy to
solve while (some) number theoretic problems remain hard.
Notice that we are not saying that this scenario is plausible
1519or even likely, just that it is possible. Second, our schemes
can immediately take advantage of the thirty+ years eﬀorts
done on number-theoretic (linearly) homomorphic encryp-
tion schemes.
Indeed, adopting our schemes induces only
a small overhead (i.e., the multiplication algorithm), and
this holds also from an implementation perspective. For
instance, there may be no need to develop complex new li-
braries or to deal with new delicate parameters choices.
Overcoming the Compactness Issue: Two-Server Del-
egation of Computation on Encrypted Data. As
a second contribution, we show how to extend our tech-
niques to build a protocol for outsourcing computation on
encrypted data by using two servers.
In brief, two-server
delegation of computation enables a client to outsource the
computation of a function f on some input m by using two
distinct servers in such a way that:
it is possible to re-
cover the result f (m) from the servers’ response, and the
two servers do not need to interact. For security, the proto-
col preserves the conﬁdentiality of the client’s inputs as long
as the two servers do not collude. Somewhat interestingly,
for this protocol we show a construction which completely
removes the compactness issue arising in our previous trans-
formation. Namely, we use a linearly-homomorphic scheme
in order to outsource the evaluation of any multivariate poly-
nomial of degree 2 while keeping the ciphertexts (i.e., the
servers’ responses) of constant-size.
This solution has interesting applications to outsourcing
the computation on encrypted data of various statistical
functions (e.g., mean, variance, covariance, RMS, linear re-
gression, correlation coeﬃcient, and many more) or distance
measures (e.g., euclidean distance) over vectors of integers.
And somewhat interestingly, all this can be performed quite
eﬃciently (cf. Section 6) by using cryptosystems such as
Paillier’s [33] or Joye-Libert [25].
Our solution oﬀers two more interesting properties that