# Title: Using Linearly-Homomorphic Encryption to Evaluate Degree-2 Functions on Encrypted Data

## Authors:
- Dario Catalano
  - University of Catania, Catania, Italy
  - Email: [dario.catalano@unict.it](mailto:dario.catalano@unict.it)
- Dario Fiore
  - IMDEA Software Institute, Madrid, Spain
  - Email: [dario.fiore@imdea.org](mailto:dario.fiore@imdea.org)

## Abstract
We present a technique to transform a linearly-homomorphic encryption scheme into one capable of evaluating degree-2 computations on ciphertexts. Our transformation is surprisingly simple and requires only that the message space be a public ring in which elements can be uniformly sampled at random. This allows us to instantiate our transformation with virtually all existing number-theoretic linearly-homomorphic schemes, such as Goldwasser-Micali, Paillier, or ElGamal. The resulting schemes achieve circuit privacy and are compact for a subclass of degree-2 polynomials where the number of additions of degree-2 terms is bounded by a constant.

As an additional contribution, we extend our technique to build a protocol for outsourcing computation on encrypted data using two non-communicating servers. In this case, we can boost a linearly-homomorphic scheme to support the evaluation of any degree-2 polynomial while achieving full compactness.

## Categories and Subject Descriptors
K.6.5 [Management of Computing and Information Systems]: Security and Protection

## Keywords
Homomorphic Encryption, Secure Computation

## 1. Introduction
The problem of enabling computation over encrypted data is one of the most intriguing questions in cryptography and has attracted significant attention recently. In essence, this problem involves a client holding an input \( x \) and a server holding a function \( f \). The client's goal is to learn \( f(x) \) without disclosing unnecessary information about \( x \) (semantic security), while the server aims to perform the computation without revealing any information beyond \( f(x) \) (circuit privacy). Additionally, to minimize communication and client workload, it is desirable that the server's response be shorter than the size of \( f \) (compactness). This problem arises in various settings, including secure cloud computing and encrypted database search.

A natural solution is to use homomorphic encryption (HE) schemes, which allow computations on encrypted plaintexts by performing similar operations on the ciphertexts. The idea of homomorphic encryption was first suggested in 1978 by Rivest, Adleman, and Dertouzous [34], though its first fully-fledged realization was proposed in 2009 by Gentry [17]. Earlier, several authors proposed encryption schemes that, while not supporting arbitrary functionalities, still allowed for meaningful operations. Examples include the Goldwasser-Micali cryptosystem [21], Paillier’s cryptosystem [33], and others [10, 30, 32, 13, 6, 25]. These schemes are linearly-homomorphic, supporting only linear functions, and are based on a discrete log trapdoor modulo a large integer that is hard to factor.

In these schemes, the message space is a ring \( M \) of modular residues, and ciphertexts are in the group \( G \) (denoted multiplicatively) of invertible elements of some particular ring of integers modulo a number hard to factor. The encryption of a message \( m \) is a group element of the form \( \text{Enc}(m; r) = g^m r^e \in G \), where \( e \) is a public integer, \( g \) is a fixed public element, and \( r \) is chosen at random in some particular (multiplicative) subgroup \( R \) of \( G \). Since \( R \) is a subgroup, these schemes have an additive homomorphic property: an encryption of \( m_1 + m_2 \) can be obtained from any encryptions of \( m_1 \) and \( m_2 \), as \( \text{Enc}(m_1; r_1) \cdot \text{Enc}(m_2; r_2) \equiv \text{Enc}(m_1 + m_2; r_1 r_2) \).

Generalizing these schemes to support more complex functionalities, such as multiplications, seems challenging because the ciphertext space is only a group. A notable exception is the construction by Boneh, Goh, and Nissim [3], which uses composite-order bilinear groups to gain one single multiplication on encrypted plaintexts. However, this construction is specific to bilinear groups, and it remains an open problem whether it is possible to extend any linearly-homomorphic scheme (e.g., Paillier or Goldwasser-Micali) to support multiplications in a natural way.

### 1.1 Our Contribution
**Homomorphic Encryption for Quadratic Functions:**
Our main result is a technique to generalize the blueprint described above to enable the performance of one multiplication on encrypted plaintexts. We show a simple method that takes a linearly-homomorphic encryption scheme and uses it to build an HE scheme that supports arithmetic computations of degree 2 on ciphertexts. Our technique is generic and requires only that the message space be a public ring in which elements can be uniformly sampled at random. We call such HE schemes "public-space" and show that virtually all existing schemes are so (or can be easily modified to become so). This means we can instantiate our transformation with a variety of existing schemes (e.g., [20, 10, 30, 33, 13, 6, 25]), obtaining several HE schemes capable of evaluating one multiplication and whose security relies on various assumptions, such as quadratic/composite residuosity, DDH, or decision linear. Furthermore, when applied to the BGN encryption scheme [3], our solution yields an HE scheme that supports computations of degree up to 4.

Our technique is surprisingly simple. Starting from a linearly-homomorphic encryption scheme \( \text{HE} = (\text{KeyGen}, \text{Enc}, \text{Dec}) \) based on the blueprint, the idea is to modify an encryption of \( m \) into a "multiplication-friendly" encryption of the same plaintext. Given \( \text{Enc}(m) \), we choose a random \( b' \in M \) and set the new ciphertext as \( C = (b', \text{Enc}(m - b')) \), where “-” denotes subtraction in the ring \( M \). By setting \( b' = m - b \) for some unknown \( b \), the above can be rewritten as \( C = (m - b, \text{Enc}(b)) \). To perform the multiplication, given \( C_1 = (m_1 - b_1, \text{Enc}(b_1)) \) and \( C_2 = (m_2 - b_2, \text{Enc}(b_2)) \), one computes the product \( (m_1 - b_1)(m_2 - b_2) \), encrypts it, and then removes the terms \( m_1 b_2 \) and \( m_2 b_1 \) from the product using the linearly-homomorphic properties of HE. Specifically, one computes \( C = (\alpha, \beta_1, \beta_2) \) where:
\[
\alpha = \text{Enc}(m_1 m_2 - b_1 b_2) = \text{Enc}((m_1 - b_1) \cdot (m_2 - b_2)) \cdot \text{Enc}(b_1)^{m_2 - b_2} \cdot \text{Enc}(b_2)^{m_1 - b_1}
\]
\[
\beta_1 = \text{Enc}(b_1), \quad \beta_2 = \text{Enc}(b_2)
\]

Decryption of any ciphertext \( (\alpha, \beta_1, \beta_2) \) works by first retrieving \( b_1 \) and \( b_2 \) (from \( \beta_1 \) and \( \beta_2 \)) and then adding \( (b_1 b_2) \) to the decryption of \( \alpha \). After obtaining the ciphertexts via the above manipulations, they can be kept additively-homomorphic. However, this comes at the cost of losing compactness. Addition after multiplication consists of homomorphically adding the \( \alpha \) components of the ciphertexts and concatenating the \( \beta \) components, causing the ciphertext to grow linearly with additions after performing the multiplication. Importantly, we show a technique to re-randomize ciphertexts to achieve circuit privacy. Our scheme compactly supports all degree-2 multivariate polynomials in which the number of additions of degree-2 terms is bounded by a constant \( L \), i.e., polynomials of the form \( P(\vec{x}) + \sum_{i=1}^L Q_i(\vec{x}) \cdot R_i(\vec{x}) \) where \( P, Q_i, R_i \) are linear. Assuming \( P, Q_i, R_i \) have at most \( n \) terms each, the decryption cost is \( O(L) \) compared to the cost of evaluating \( f(\vec{x}) \), which is \( O(n \cdot L) \). Despite the limitations, this class of computations is meaningful in some contexts, such as the SPDZ protocol [14], which requires a somewhat homomorphic encryption scheme capable of evaluating exactly this class of computations (for \( L = 1 \)).

**On the Importance of Being Simple and Black Box:**
Beyond its simplicity, a very attractive feature of our technique is that it applies in a black-box manner to essentially all known linearly-homomorphic encryption schemes. This allows us to directly "inherit" all the protocols and tools previously developed for the underlying schemes. Our construction provides the first realizations of practical homomorphic encryption schemes (beyond linear) in groups like \( \mathbb{Z}_N^* \). Compared to recent lattice-based homomorphic encryption schemes, ours are less expressive. However, they remain relevant for two reasons: they provide alternatives to lattice-based cryptography, and they can immediately take advantage of the extensive efforts made on number-theoretic (linearly) homomorphic encryption schemes. Adopting our schemes induces only a small overhead, and this holds from an implementation perspective as well.

**Overcoming the Compactness Issue: Two-Server Delegation of Computation on Encrypted Data:**
As a second contribution, we extend our techniques to build a protocol for outsourcing computation on encrypted data using two servers. This protocol enables a client to outsource the computation of a function \( f \) on some input \( m \) by using two distinct servers such that the result \( f(m) \) can be recovered from the servers' responses, and the two servers do not need to interact. For security, the protocol preserves the confidentiality of the client's inputs as long as the two servers do not collude. Interestingly, for this protocol, we show a construction that completely removes the compactness issue arising in our previous transformation. We use a linearly-homomorphic scheme to outsource the evaluation of any multivariate polynomial of degree 2 while keeping the ciphertexts (i.e., the servers' responses) of constant size. This solution has applications in outsourcing the computation of various statistical functions (e.g., mean, variance, covariance, RMS, linear regression, correlation coefficient, and more) or distance measures (e.g., Euclidean distance) over vectors of integers. All this can be performed efficiently using cryptosystems such as Paillier's [33] or Joye-Libert [25].

Our solution offers two more interesting properties: