title:What the App is That? Deception and Countermeasures in the Android
User Interface
author:Antonio Bianchi and
Jacopo Corbetta and
Luca Invernizzi and
Yanick Fratantonio and
Christopher Kruegel and
Giovanni Vigna
2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy
What the App is That?
Deception and Countermeasures
in the Android User Interface
Antonio Bianchi, Jacopo Corbetta, Luca Invernizzi, Yanick Fratantonio, Christopher Kruegel, Giovanni Vigna
Department of Computer Science
University of California, Santa Barbara
{antoniob,jacopo,invernizzi,yanick,chris,vigna}@cs.ucsb.edu
Abstract—Mobile applications are part of the everyday lives of
billions of people, who often trust them with sensitive information.
These users identify the currently focused app solely by its visual
appearance, since the GUIs of the most popular mobile OSes do not
show any trusted indication of the app origin.
In this paper, we analyze in detail the many ways in which
Android users can be confused into misidentifying an app, thus,
for instance, being deceived into giving sensitive information to a
malicious app. Our analysis of the Android platform APIs, assisted by
an automated state-exploration tool, led us to identify and categorize
a variety of attack vectors (some previously known, others novel, such
as a non-escapable fullscreen overlay) that allow a malicious app to
surreptitiously replace or mimic the GUI of other apps and mount
phishing and click-jacking attacks. Limitations in the system GUI
make these attacks significantly harder to notice than on a desktop
machine, leaving users completely defenseless against them.
To mitigate GUI attacks, we have developed a two-layer defense.
To detect malicious apps at the market level, we developed a tool that
uses static analysis to identify code that could launch GUI confusion
attacks. We show how this tool detects apps that might launch GUI
attacks, such as ransomware programs. Since these attacks are meant
to confuse humans, we have also designed and implemented an
on-device defense that addresses the underlying issue of the lack of a
security indicator in the Android GUI. We add such an indicator to
the system navigation bar; this indicator securely informs users about
the origin of the app with which they are interacting (e.g., the PayPal
app is backed by “PayPal, Inc.”).
We demonstrate the effectiveness of our attacks and the proposed
on-device defense with a user study involving 308 human subjects,
whose ability to detect the attacks increased significantly when using
a system equipped with our defense.
I.
INTRODUCTION
Today, smartphone and tablet usage is on the rise, becoming the
primary way of accessing digital media in the US [1]. Many users
now trust their mobile devices to perform tasks, such as mobile
banking or shopping, through mobile applications, typically called
“apps.” This wealth of confidential data has not gone unnoticed by
cybercriminals: over the last few years, mobile malware has grown
at an alarming rate [2].
Popular mobile operating systems run multiple apps concurrently.
For example, a user can run both her mobile banking application
and a new game she is checking out. Obviously, a game should not
receive financial information. As a consequence, the ability to tell
the two apps apart is crucial. At the same time, it is important for
these apps to have user-friendly interfaces that make the most of
the limited space and interaction possibilities.
Let us assume that a victim user is playing the game, which
is malicious. When this user switches to another app, the game
will remain active in the background (to support background
processing and event notifications). However, it will also silently
wait for the user to login into her bank. When the malicious game
detects that the user activates the banking app, it changes its own
appearance to mimic the bank’s user interface and instantly “steals
the focus” to become the target with which the victim interacts. The
user is oblivious to this switch of apps in the foreground, because
she recognizes the graphical user interface (GUI) of the banking
application. In fact, there have been no changes on the user’s display
throughout the attack at all, so it is impossible for her to detect it:
she will then insert her personal banking credentials, which will
then be collected by the author of the malicious app.
In this paper, we study this and a variety of other GUI confusion
attacks. With this term, we denote attacks that exploit the user’s in-
ability to verify which app is, at any moment, drawing on the screen
and receiving user inputs. GUI confusion attacks are similar to social
engineering attacks such as phishing and click-jacking. As such, they
are not fundamentally novel. However, we find that the combination
of powerful app APIs and a limited user interface make these
attacks much harder to detect on Android devices than their “cousins”
launched on desktop machines, typically against web browsers.
The importance of GUI-related attacks on Android has been
pointed out by several publications in the past, such as [3], [4]
(with a focus on “tapjacking”), [5] (with a focus on phishing attacks
deriving from control transfers), and [6] (with a focus on state
disclosure through shared-memory counters). Our paper generalizes
these previously-discovered techniques by systematizing existing
exploits. Furthermore, we introduce a number of novel attacks. As
an extreme example of a novel attack, we found that a malicious app
has the ability to create a complete virtual environment that acts as a
full Android interface, with complete control of all user interactions
and inputs. This makes it very hard for a victim user to escape the
grip of such a malicious application. Even though at the time of this
writing the number of known samples performing GUI confusion
attacks is limited, we believe (as we will show in this paper) that
this is a real, currently unsolved, problem in the Android ecosystem.
This paper also introduces two novel approaches to defend
© 2015, Antonio Bianchi. Under license to IEEE.
© 2015, Antonio Bianchi. Under license to IEEE.
© 2015, Antonio Bianchi. Under license to IEEE.
DOI 10.1109/SP.2015.62
DOI 10.1109/SP.2015.62
DOI 10.1109/SP.2015.62
930
930
931
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:15 UTC from IEEE Xplore.  Restrictions apply. 
against GUI confusion attacks. The first approach leverages static
code analysis to automatically find apps that could abuse Android
APIs for GUI confusion attacks. We envision that this defense could
be deployed at the market level, identifying suspicious apps before
they hit the users. Interestingly, we detected that many benign apps
are using potentially-dangerous APIs, thus ruling out simple API
modifications as a defense mechanism.
Our static analysis approach is effective in identifying potentially-
malicious apps. More precisely, our technique detects apps that
interfere with the UI in response to some action taken by the user
(or another app). The apps that we detect in this fashion fulfill two
necessary preconditions of GUI confusion attacks: They monitor the
user and other apps, and they interfere with the UI (e.g., by stealing
the focus and occupying the top position on the screen). However,
these two conditions are not sufficient for GUI confusion attacks. It
is possible that legitimate apps monitor other apps and interfere with
the UI. As an example, consider an “app-locker” program, which
restricts access to certain parts of the phone (and other apps). When
looking at the code, both types of programs (that is, malicious apps
that launch GUI confusion attacks as well as app-lockers) look very
similar and make use of the same Android APIs. The difference is in
the intention of the apps, as well as the content they display to users.
Malicious apps will attempt to mimic legitimate programs to entice
the user to enter sensitive data. App-lockers, on the other hand, will
display a screen that allows a user to enter a PIN or a password to
unlock the phone. These semantic differences are a fundamental
limitation for detection approaches that are purely code-based.
To address the limitations of code-based detection, we devised
a second, on-device defense. This approach relies on modifications
to the Android UI to display a trusted indicator that allows users
to determine which app and developer they are interacting with,
attempting to reuse security habits and training users might already
have. To this end, we designed a solution (exemplified in Figure 1)
that follows two well-accepted paradigms in web security:
• the Extended Validation SSL/TLS certification and visualization
(the current-best-practice solution used by critical businesses to
be safely identified by their users)
• the use of a “secure-image” to established a shared secret between
the user interface and the user (similarly to what is currently
used in different websites [7], [8] and recently proposed for the
Android keyboard [9])
We evaluate the effectiveness of our solution with a user study
involving 308 human subjects. We provided users with a system
that implements several of our proposed defense modifications, and
verified that the success ratio of the (normally invisible) deception
attacks significantly decreases.
To summarize, the main contributions of this paper are:
• We systematically study and categorize the different techniques
an attacker can use to mount GUI deception attacks. We describe
several new attack vectors that we found, and we introduce a tool
to automatically explore reachable GUI states and identify the
ones that can be used to mount an attack. This tool was able to
automatically find two vulnerabilities in the Android framework
that allow an app to gain full control of a device’s UI.
• We study, using static analysis, how benign apps legitimately use
API calls that render these attacks possible. Then, we develop
a detection tool that can identify their malicious usage, so that
suspicious apps can be detected at the market level.
Fig. 1: Comparison between how SSL Extended Validation
information is shown in a modern Browser (Chrome 33) and what
our implemented defense mechanism shows on the navigation bar
of an Android device.
• We propose an on-device defense that allows users to securely
identify authors of the apps with which they interact. We compare
our solution with the current state of the art, and we show that
our solution has the highest coverage of possible attacks.
• In a user study with 308 subjects, we evaluate the effectiveness
of these attack techniques, and show that our on-device defense
helps users in identifying attacks.
For the source code of the proof-of-concept attacks we
developed and the prototype of the proposed on-device defense,
refer to our repository1.
II. BACKGROUND
To understand the attack and defense possibilities in the Android
platform, it is necessary to introduce a few concepts and terms.
The Android platform is based on the Linux operating system
and it has been designed mainly for touchscreen mobile devices.
Unless otherwise noted, in this paper we will mainly focus on
Android version 4.4. When relevant, we will also explain new
features and differences introduced by Android 5.0 (the latest
available version at the time of writing).
In an Android device, apps are normally pre-installed
or downloaded from the Google Play Store or from another
manufacturer-managed market, although manual offline installation
and unofficial markets can also be used. Typically, each app runs iso-
lated from others except for well-defined communication channels.
Every app is contained in an apk file. The content of this file
is signed to guarantee that the app has not been tampered with and
that it is coming from the developer that owns the corresponding
private key. There is no central authority, however, to ensure that
the information contained in the developer’s signing certificate is
indeed accurate. Once installed on a device, an app is identified by
its package name. It is not possible to install apps with the same
package name at the same time on a single device.
Apps are composed of different developer-defined components.
Specifically, four types of components exist in Android: Activity,
Service, Broadcast Receiver, and Content Provider. An Activity
defines a graphical user interface and its interactions with user’s
actions. Differently, a Service is a component running in background,
performing long-running operations. A Broadcast Receiver is a
component that responds to specific system-wide messages. Finally,
a Content Provider is used to manage data shared with other
components (either within the same app or with external ones).
1https://github.com/ucsb-seclab/android ui deception
931931932
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:15 UTC from IEEE Xplore.  Restrictions apply. 
Status Bar
Top
Activity
Toast
Navigation
Bar
Fig. 2: Typical Android user interface appearance. The status bar
is at the top of the screen, while the navigation bar occupies the
bottom. A browser app is open, and its main Activity is shown in
the remaining space.
To perform sensitive operations (e.g., tasks that can cost money
or access private user data), apps need specific permissions. All
the permissions requested by a non-system app must be approved
by the user during the app’s installation: a user can either grant all
requested permissions or abort the installation. Some operations
require permissions that are only granted to system apps (typically
pre-installed or manufacturer-signed). Required permissions,
together with other properties (such as the package name and
the list of the app’s components), are defined in a manifest file
(AndroidManifest.xml), stored in the app’s apk file.
A. Android graphical elements
Figure 2 shows the typical appearance of the Android user
interface on a smartphone. The small status bar, at the top, shows
information about the device’s state, such as the current network
connectivity status or the battery level. At the bottom, the navigation
bar shows three big buttons that allow the user to “navigate” among
all currently running apps as well as within the focused app.
Details may vary depending on the manufacturer (some devices
merge the status and navigation bars, for instance, and legacy devices
may use hardware buttons for the navigation bar). In this work we
will use as reference the current guidelines2, as they represent a
typical modern implementation; in general, our considerations can
be adapted to any Android device with minor modifications.
2http://developer.android.com/design/handhelds/index.html ,
http://developer.android.com/design/patterns/compatibility.html
932932933
Apps draw graphical elements by instantiating system-provided
components: Views, Windows, and Activities.
Views. A View is the basic UI building block in Android.
Buttons, text fields, images, and OpenGL viewports are all examples
of views. A collection of Views is itself a View, enabling hierarchical
layouts.
Activities. An Activity can be described as a controller in a
Model-View-Controller pattern. An Activity is usually associated
with a View (for the graphical layout) and defines actions that happen
when the View elements are activated (e.g., a button gets clicked).
Activities are organized in a global stack that is managed by the
ActivityManager system Service. The Activity on top of the stack
is shown to the user. We will call this the top Activity and the app
controlling it the top app.
Activities are added and removed from the Activity stack in
many situations. Each app can reorder the ones it owns, but separate
permissions are required for global monitoring or manipulation.
Users can request an Activity switch using the navigation bar buttons:
• The Back button (bottom left in Figure 2) removes the top Activity
from the top of the stack, so that the one below is displayed. This
default behavior can be overridden by the top Activity.
• The Home button lets the user return to the base “home” screen,
usually managed by a system app. A normal app can only replace
the home screen if the user specifically allows this.
• The Recent button (bottom right in Figure 2) shows the list of
top Activities of the running apps, so the user can switch among
them. Activities have the option not to be listed. In Android 5.0,
applications can also decide to show different thumbnails on
the Recent menu (for instance, a browser can show a different
thumbnail in the Recent menu for each opened tab).
Windows. A Window is a lower-level concept: a virtual surface
where graphical content is drawn as defined by the contained Views.
In Figure 2, the Status Bar, the Navigation Bar and the top Activity
are all drawn in separate Windows. Normally, apps do not explicitly
create Windows; they just define and open Activities (which in
turn define Views), and the content of the top Activity is drawn in
the system-managed top-activity Window. Windows are normally
managed automatically by the WindowManager system Service,
although apps can also explicitly create Windows, as we will show
later.
III. GUI CONFUSION ATTACKS
In this section, we discuss classes of GUI confusion attacks
that allow for launching stealthy and effective phishing-style or
click-jacking-style operations.
In our threat model, a malicious app is running on the victim’s
Android device, and it can only use APIs that are available to any
benign non-system app. We will indicate when attacks require par-
ticular permissions. We also assume that the base Android operating
system is not compromised, forming a Trusted Computing Base.
We have identified several Android functionalities (Attack
Vectors, categorized in Table I) that a malicious app can use to