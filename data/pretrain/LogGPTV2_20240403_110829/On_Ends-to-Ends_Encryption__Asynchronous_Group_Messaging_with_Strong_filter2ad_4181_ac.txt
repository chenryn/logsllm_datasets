round AKE protocol but ART does not have
speciﬁc requirements on its structure.
public
the
gι(gλA
1 λB
1 )ι(gλC
1 λD
1 )
ι(gλA
1 λB
1 ) ; gι(gλA
1 λB
1 )
ι(gλC
1 λD
1 ) ; gι(gλC
1 λD
1 )
1 ; gλA
λA
1
1 ; gλB
λB
1
1 ; gλC
λC
1
1 ; gλD
λD
1
(a) Alice creates an ART group with three other members.
Alice updates their key by choosing a new leaf
key λA
2 , computing the updated nodes
gλA
2 λB
1 =
gλB
1
(cid:17)λA
2
(cid:16)
(cid:18)
(cid:19)ι(gλA
2 λB
1 )
gι(gλA
2 λB
1 )ι(gλC
1 λD
1 )
ι(gλA
2 λB
1 ) ; gι(gλA
2 λB
1 )
ι(gλC
1 λD
1 ) ; gι(gλC
1 λD
1 )
gι(gλA
2 λB
1 )ι(gλC
1 λD
1 ) =
gι(gλC
1 λD
1 )
2 to the tree root, and
on the path from λA
broadcasting the updated public keys to the
group.
(b) Alice updates, choosing a fresh leaf key and broadcasting updated public keys. Updated nodes are shown in
boxed red
1 ; gλB
λB
1 ; gλC
λC
2 ; gλA
λA
2
1
1
1 ; gλD
λD
1
Charlie updates their key in the same way: by
2 , computing the
choosing a new leaf key λC
updated nodes on the path from λC
2 to the tree
root, and broadcasting the updated public keys
to the group.
gι(gλA
2 λB
1 )ι(gλC
2 λD
1 )
ι(gλA
2 λB
1 ) ; gι(gλA
2 λB
1 )
ι(gλC
2 λD
1 ) ; gι(gλC
2 λD
1 )
2 ; gλA
λA
2
1 ; gλB
λB
1
2 ; gλC
λC
2
1 ; gλD
λD
1
(c) Charlie updates their key in the same way.
Figure 3: Example ART tree creation and updates. We write secret keys and the corresponding
public keys at each node except the root, separated by (cid:107). Leaf keys are denoted λu
i , where u is the
corresponding identity and i a counter. ι(·) denotes a mapping from group elements to integers. From
any secret leaf key and the set of public keys on its copath, an agent can compute the tree key by
repeated exponentiation.
11
shared group key
ι(gkAkB) ; gι(gkAkB )
?
ι(kA) ; gι(kA)
ι(kB) ; gι(kB)
ι(kC) ; gι(kC)
ι(kD) ; gι(kD)
Our insight here is that the initiator should not directly use received public keys at the leaf
nodes, since then they cannot derive their parents’ public keys. Instead, we propose a design in
which they derive secret keys for each leaf node with the properties that
(i) for each group member, both the initiator and that group member can asynchronously
derive the secret key assigned to that leaf node but
(ii) no other actor (group member or adversary) can derive that secret key.
The creator can use their knowledge of all the secret keys to compute the intermediate public keys
in the tree, subsequently deleting the leaf secrets. (This leads to additional trust assumptions on
the initiator, but assumptions which are mitigated by the key update protocol we deﬁne later.)
How can we derive these leaf secrets? Our core insight is that they can be the session keys of
any strong one-round AKE protocol, which we denote KeyExchange. KeyExchange takes
two private keys ek and ik and two public keys EK and IK and returns a bitstring, with the
property that KeyExchange(ik I, IK R, ek I, EK R) = KeyExchange(ik R, IK I, ek R, EK I).4
To use such a protocol we leverage the existing idea of prekeys and introduce the new
idea of a setup key. Prekeys were ﬁrst introduced by Marlinspike [37] for asynchronicity in
the TextSecure messaging app. They are DH ephemeral public keys cached by an untrusted
intermediate server, and fetched on demand by messaging clients. The prekeys are sent to clients
through the public key infrastructure at the same time as long-term identity keys, and act as
initial messages for a one-round AKE protocol.
To enable computing an initial tree for a group, we introduce the idea of a one-time DH
setup key, generated locally by the creator of a group and used only during the creation of that
session. This key is used to perform an initial key exchange with the prekeys, and allows the
initiator to generate secret leaf keys for the other group members while they are oﬄine.
Asynchronous tree construction works as follows. Suppose the initiator (“Alice”) wishes to
create a group of size n containing herself and n − 1 peers. She begins by generating a DH
key suk we call the setup key. She then requests from the public-key infrastructure the public
identity key IK and an ephemeral prekey EK for each of her intended peers (“Bob”, “Charlie”,
. . . ), numbering them 1 through n − 1. Using her secret identity key ik a and the setup key suk
together with the received public keys for each peer, she executes a one-round key exchange
protocol to derive leaf keys λ1, . . . , λn−1. Using these generated leaf keys together with a fresh
leaf key λ0, she builds a DH tree whose root becomes the initial group key.
We do not force a particular instantiation of KeyExchange. For example, it can be
instantiated with an unauthenticated DH exchange between Alice’s setup key and Bob’s prekey,
resulting in an unauthenticated tree structure. This is the design we analyse in Section 6.2. A
more practical instantiation (discussed in Section 6.3) is with a strong AKE protocol which
provides authentication, in which case the group key can inherit the authentication properties.
To create a group, Alice broadcasts
4If the AKE protocol has a diﬀerent algorithm for the initiator and responder, we can add an additonal ‘Role’
argument.
12
(i) the public prekeys (EK i) and identities (IK i) she used,
(ii) the public setup key SUK ,
(iii) the tree T of public keys, and
(iv) a signature of (i),(ii),(iii) under her identity key.
Upon receiving such a message and verifying the signature, each group member can reproduce the
computation of the tree key. First, they compute their leaf key λi = KeyExchange(ik i, IK A, ek i, SUK ).
Second, they extract their copath of public keys from the tree. Finally, they iteratively exponen-
tiate with the public keys on the copath until they reach the ﬁnal key, which by construction is
the shared secret at the root of the tree. (Recall that we call this shared secret the “tree key” tk,
and derive from it the stage key sk.)
We give a pseudocode deﬁnition of these algorithms in Figure 8 on page 29, Algorithms 1,2
and 3.
5.2 ART Updates
To achieve PCS, we must be able to update stage keys in a way that depends both on state
from previous stages and on newly exchanged messages. (Cohn-Gordon, Cremers, and Garratt
[14] prove necessity of this double dependency.) Since PCS is an explicit goal of ART, it must
therefore support an eﬃcient mechanism for any group member to update their key.
If e.g., Alice changes her leaf key, other group members can compute all the intermediate
values in the resulting updated tree using only (i) their view of the tree before the change, and
(ii) the list of updated public DH keys of nodes along the path from Alice’s leaf node to the
root of the tree. This update is eﬃcient and asynchronous, since Alice can compute (ii) in
logarithmic time and broadcast it to the group with her new leaf key.
Speciﬁcally, if at any point Alice wishes to change her leaf key from λb to λ(cid:48)
b, she computes
the new public keys at all nodes along the path from her leaf to the tree root, and broadcasts to
the group her public leaf key together with these public keys. She authenticates this message
with a MAC under a key derived from the previous stage key. A group member who receives
such a message can update their stored copath (at the node on the intersection of the two paths
to the root). Computing the key induced by this new path yields the updated group key, and
can be done purely locally.
We give a pseudocode deﬁnition of these algorithms in Figure 8, Algorithms 4 and 5.
Stage key chaining In order to achieve PCS, stage keys cannot be independent—instead,
each stage key must depend on both the recent message exchange and on previous stages. As
long as one of these two sources of secret data is unknown to the adversary, the stage key will be
as well. (Cohn-Gordon, Cremers, and Garratt [14] prove an impossibility result that no stateless
protocol can achieve PCS, giving a generic attack.) The resulting stage keys form a hash chain
as depicted in Figure 4.
5.3 Algorithms
We give pseudocode algorithms for all of the operations in our design in Figure 8 on page 29. As
an example, consider the situation where Alice wishes to create a group with ﬁve other agents,
using Algorithm 1. She begins by generating a setup keypair with secret key suk, and a leaf
keypair with secret key λ0 for herself. She retrieves the public identity and ephemeral prekeys
of each peer, and creates the tree in Figure 5.
13
π.tk
π.sk
KDF
π.sk(cid:48)
π.tk(cid:48)
KDF
π.sk(cid:48)(cid:48)
Figure 4: Derivation of stage keys π.sk. When a new tree key π.tk is computed (as the root of a DH
tree), it is combined with the current stage key to derive a new stage key π.sk(cid:48), etc. This “chaining” of
keys is an important ingredient for achieving PCS. Note that the ART KDF also includes π.IDs and
π.T , per Algorithm 2 on page 29.
grk 0
gι(gλ0λ1 )ι(gλ2λ3 )
gλ4λ5
gλ0λ1
gλ2λ3
λ4=EK suk
4
λ5=EK suk
5
λ0
λ1=EK suk
1
λ2=EK suk
2
λ3=EK suk