the source node’s codebase. We require that a unique imple-
mentation of a dependency be reachable in the dependency
graph. In Figure 7d, two implementations are reachable for
pkg.A, so the compiler would reject publication of pkg.B.
Namespace consistency encourages modular design with-
out imposing a speciﬁc module system, thereby permitting a
wider range of workﬂows than previous systems. For instance,
independently linking components via common interfaces iso-
lates each component’s namespace and abstract dependencies
from their implementation. Provided the namespaces of these
components are consistent, an updated version of one com-
ponent may link against the other classes without changing
them. Programs can evolve incrementally and securely, while
avoiding unnecessary re-publication of classes.
The consistency constraint applies to the static dependen-
cies of a class and does not constrain the dynamic type of
objects beyond normal type safety. At run time, a reference
may point to an object whose class type is neither in the
class’s codebase nor consistent with its namespace. There is
no possibility for confusion, because our constraint ensures
that dependent code only interacts with the object via a
consistently resolved supertype.
200
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:46:49 UTC from IEEE Xplore.  Restrictions apply. 
void m(Object o) {
...
1 package pkg;
2 class C {
3
4
5
6
7
8
9 }
...
}
}
void m(A a) {
void m(A a) {
1 package pkg;
2 class B extends C {
3
4
5
6 }
...
}
(a) A mobile superclass
(b) A subclass of pkg.C
(c) Codebases
(d) Dependency graph
Fig. 7: Two classes using different versions of pkg.A
6.3. Explicit Codebases
We introduce explicit codebases as a language mechanism
for referencing speciﬁc implementations of dependencies. An
explicit codebase is a name for a codebase object published
in Fabric. A programmer may use this alias to qualify
dependencies that should be resolved through the speciﬁed
codebase rather than the class’s codebase. Explicit codebases
may appear at the root of any fully qualiﬁed type name.
When a name is qualiﬁed via an explicit codebase,
the
namespace of the speciﬁed dependency is isolated from that
of the dependent class. Because the programmer’s intention
is unambiguous, dependencies linked via explicit codebases
are exempt from namespace-consistency checks.
Explicit codebases may refer to multiple implementations
of a dependency in the same namespace. For instance, to
override the superclass method C.m(A) in pkg.B, the class
deﬁnition should read:
1 package pkg;
2 codebase cb1;
3 class B extends C {
4
void m(cb1.A a) {
5
6
7 }
...
}
The publisher associates the alias “cb1” with a Fabric refer-
ence to codebase CB1 on the command line.
We expect explicit codebases to have two main uses. The
most common use is to support evolving published code.
Using explicit codebases, classes may provide methods or
implement interfaces that preserve compatibility with code
and persistent objects from older class versions. A second use
for explicit codebases is for composing software components
with conﬂicting dependencies. If software components have
201
conﬂicting dependencies that do not affect program function-
ality, it may be desirable to isolate the namespace of each
component using an explicit codebase.
7. Implementation
To evaluate our design, we extended the Fabric prototype
with support for mobile code, as described in this section.
7.1. Compiler
We extended the Fabric compiler to support
the new
language features and analyzes. Additional extensions were
required to enable the compiler to load dependencies from
Fabric. Provider-bounded label checking is implemented as
part of Jif and is inherited by Fabric. These compiler changes
comprise about 12k lines of Java code.
7.2. Class loading
To load and run mobile code, we implemented a Java class
loader that is used by worker nodes. When the JVM requests
a new class, the class loader fetches the corresponding Fabric
FClass object, which contains references to its home code-
base, as well as the source code. To specify which codebase
should be used, the compiler mangles class names mentioned
by mobile code to include their home codebases.
After fetching a class object, the loader invokes the Fabric
compiler on the source code to verify the class and generate
bytecode. Important context information, such as the worker’s
principal, the run-time label of the code, and the codebase,
are also passed to the compiler. The compiler generates Java
bytecode and caches it locally in memory and on disk, so
that compilation can be reused. After compilation, the loader
reads the bytecode from cache and uses the Java class loader
API to load it into the JVM.
For bootstrapping purposes, certain system classes are
treated specially. They are loaded from bytecode on disk, in
much the same way as by the default Java classloader.
The deﬁnitions of the Codebase and FClass classes were
written in Fabric and contain about 90 lines of code. The
remaining changes to the runtime system comprise about
2,200 lines of Java code and 420 lines of Fabric code.
7.3. Limitations
Some mechanisms are not
implemented in the current
Fabric implementation. These mechanisms should not have
any signiﬁcant effect on the results reported here.
• Access labels are implemented, but full support for
run-time enforcement of access labels in multiworker
transactions is incomplete.
• When an object
is fetched from a remote node, a
dynamic check is done to ensure that
its class is a
subtype of the expected type of the reference to the
object. Currently this check does not take into account
parameters of parameterized types.
• We have not implemented the class object replication
scheme of Section 5.6.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:46:49 UTC from IEEE Xplore.  Restrictions apply. 
CB1pkg.Apkg.CCB2pkg.Apkg.Bv1v2pkg.Apkg.Cpkg.Apkg.Bpkg.Cpkg.Bpkg.Av2pkg.Av1pkg.Cboundary
= new Box(0,0,0,0);
{ provider (cid:116) MapServer.provider (cid:116) pc (cid:116) {⊥→;(cid:62)←user} }
resLbl (cid:118) {(cid:62)→n},
localStore (cid:60) resLbl
label fetchLabel = {resLbl (cid:117) {(cid:62)→ms}};
Box
for (User friend : user.friends)
1 Map {resLbl}
2 createMap (User user, label resLbl, label friendAccess)
3 where
4
5
6
7
8 {
9
10
11
12
13
14
15
16
17
18
19
20
21
22 }
if (friendAccess
&& {friend→friend.locGrp} (cid:118) fetchLabel)
addPin(annotated, friend.location, friend);
(cid:118) {(cid:62)→friend.sn})
for (User friend : user.friends)
if (friendAccess
&& {friend→friend.locGrp} (cid:118) resLbl)
(cid:118) {(cid:62)→friend.sn}
boundary.expand(friend.location);
Map map = ms.getMap(boundary)
.copy(resLbl, localStore);
(cid:118) { resLbl (cid:117) {(cid:62)→user.sn} (cid:117) {(cid:62)→ms} (cid:117) friendAccess },
return map;
Fig. 8: An important part of the FriendMap code. Some details have
been changed for clarity (e.g., Fabric does not currently support Java
5’s for-loop syntax, and some error handling has been elided).
8. Evaluation
Our architecture has three key goals. First, it should be
secure. This topic has been discussed throughout the paper.
Second, it should be expressive; it should enable a range
of useful applications to be built. Third,
it should have
acceptable performance.
To evaluate the system, we implemented two example
applications, which include the FriendMap application. These
examples cover many of the current uses of mobile code,
but also enable new functionality. These example applications
work correctly on our prototype implementation, demonstrat-
ing that provider-bounded security veriﬁcation allows interest-
ing code and that codebases enable incremental development.
Performance measurements from these examples suggest that
run-time overhead is acceptable for many uses.
8.1. FriendMap example
To show that Mobile Fabric is sufﬁciently powerful to se-
curely implement interesting functionality, we implemented a
prototype of the FriendMap example. It contains roughly 2500
lines of Fabric code, roughly 200 of which implement the
extended versions of FriendMap and Snapp. FriendMap was
developed over the course of six weeks by two developers.
As described in Section 2, the application runs on Alice’s
worker, and integrates code from FriendMap, MapServ, and
Snapp with data from Snapp and MapServ.
Figure 8 shows the method createMap, which provides
the key functionality of FriendMap. This method computes
a bounding box of a user’s friends (lines 9–14), uses that
bounding box to fetch an image from MapServ and construct
a private copy (lines 15–16), and then annotates that map with
the user’s friends’ locations (lines 17–20).
202
The method takes the dynamic labels resultLbl and
friendAccess as arguments. The resultLbl argument de-
scribes the policy on the created map; it is used in lines 13
and 19 to ensure that friends with private locations will not
affect the resulting map.
The friendAccess argument allows the caller to specify a
bound on the access labels of the friends who are fetched. This
allows a user to plot friends stored on other social networks,
while preventing the user from fetching those objects if the
friends’ social networks are not trusted to learn about the state
of the computation (lines 12 and 18).
In addition to these dynamic checks, this code requires
further relationships between various labels in order to be
considered secure. These relationships are demanded by the
where clauses on lines 3–7, which are required to be checked
by any method that calls createMap.
For example, the ﬁrst clause (on lines 4–5) guards the
ﬂows of information from the code itself (labeled provider
and MapServer.provider), from the fact that the method
was called (labeled pc), and from the user’s set of friends
(labeled {⊥→; (cid:62)←user}) to effects on the resulting map
(labeled resLbl), as well as fetches of the user’s object, the
map server’s initial map, and the friends (with access labels
{*→user.sn}, {*→ms} and friendAccess respectively).
Omitting any of the where clauses or the dynamic checks
in this example would lead to exploitable information ﬂows
in the FriendMap application. Mobile Fabric requires the
FriendMap developers to insert these checks; without them
the application would fail to compile, and thus users would
not be able to execute them.
We also implemented one of the evolution scenarios de-
scribed in Section 6. We implemented a second version of
the Snapp codebase that adds a mood ﬁeld to User objects.
The version 2 classes use the explicit codebase feature to
refer to the version 1 classes, and the User class in version 2
extends the User class in version 1.
We subsequently extended the FriendMap application to
make use of this extended functionality. FriendMap version 2
extends FriendMap version 1, and overrides the implementa-
tion of the addPin method to color the added pin using the
user’s mood. Because version 2 is a backwards compatible
extension of version 1, it must be able to handle version 1
User objects that have no moods. The implementation uses
explicit codebases to perform dynamic type checks, and falls
back to version 1 behavior if version 1 users are encountered.
8.2. Bidding agent example
In this example, a user supplies an agent to choose between
two ticket offers made by different airlines. The choice may
depend on factors conﬁdential to the user, such as preferred
price or expected service level. Airlines, in turn, supply agents
that compete for the best offer to provide to the user, while
maximizing proﬁt. This example is about 570 lines of code.
Four parties participate: a trusted broker, two airlines, and
the user. They are represented by Fabric principals Broker,
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:46:49 UTC from IEEE Xplore.  Restrictions apply. 
int {L} choice( Offer[L]{L} offer1,
Offer[L]{L} offer2 );
1 interface UserAgent[label L] {
2
3
4 }
5 interface Agent[principal A, label L] {
6
7
8
9
10
11 }
void prepareForAuction{A→;A←}();
Offer[L]{L} makeOffer {L} (
UserAgent[L]{L} userChoice,
Offer[L]{L} bestOffer);
...
Fig. 9: Interfaces provided by Broker
new label{Broker→;User←;AirlineA←;AirlineB←}
1 label{Broker←} auction =
2
3 Agent[AirlineA,auction] agentA = a.getAgent(auction);
4 Agent[AirlineB,auction] agentB = b.getAgent(auction);
5 UserAgent[auction] userAgent = u.getAgent(auction);
Fig. 10: Initializing airline and user agents
AirlineA, AirlineB, and User. Principal Broker is trusted
by others: Broker(cid:60)AirlineA, Broker(cid:60)AirlineB, and
Broker(cid:60)User; no other trust relationships are assumed.
Every principal is associated with a Fabric store.
To facilitate interaction of different mobile agents, Broker
publishes interfaces, illustrated in Figure 9, for the airlines’
and user’s agents. The interfaces use principal and label
parameterization, a Fabric language feature that facilitates
modular development and genericity. Interface UserAgent
has a label parameter L that corresponds to the security level
of the offers that
it chooses from. The choice function
returns -1 if the ﬁrst offer is preferred, 1 if the second offer
is preferred, and 0 if offers are equally preferred. Interface
Agent for airline agents uses two parameters: A for the airline
principal and L for the label of the offers. Two noteworthy
methods here are prepareForAuction and makeOffer.
Method prepareForAuction may be called before bidding
starts. The begin-label of this method, {A→;A←} permits
information about calling this method to be observed by
airline A. This permits airline agents to fetch new information
from airline airlines, such as seat availability or current
lowest prices. Method makeOffer is called during the bidding
phase and generates a new offer to the user’s agent. The
signature of this method records the key feature of our mobile-
code framework: the user’s agent is passed in as a method
argument, and can be called internally by the airline agent.
Similarly, the current best offer is passed as another argument,
allowing the agent to ﬁnd an offer better than the current best
according to the user—while still trying to maximize proﬁt.
The enforcement of information-ﬂow policies ensures that no
conﬁdential information (such as the user’s maximum price
or offers from competing airlines) ﬂows from the agents to
the principals that provided them, despite the fact that these
agents process this sensitive information directly.
Figure 10 shows initialization of mobile agents. Lines 1–2
declare a label auction at which offers are produced. The
conﬁdentiality component of this label, {Broker→}, records
Java class loader
Bytecode cache
Deserializing
Compiling