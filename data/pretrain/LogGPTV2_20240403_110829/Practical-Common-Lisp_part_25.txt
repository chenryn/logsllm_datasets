→1.0
0
1）
↑
↑
个
0
0.123
0.123
123.0
1.23e+19
0.123
123.0
1.0
↑
→
→#c(3.0 0:0)
→
→#c(2 1)
1/2
#c(0.5 1.0)
#c(2.0 1.0)
#c(2/3 3/4)
www.TopSage.com
一#B、#X、#O和#R语法只用在有理
---
## Page 122
FLOOR和TRUNCATE函数之间的关系如下所示：
刚好位于两个整数之间，它舍入到最接近的偶数上。
向正无穷方向截断，返回大于或等于参数的最小整数；TRUNCATE向零截断，对于正实参而言，
数或浮点数）转化成整数：FLOOR向负无穷方向截断，返回小于或等于实参的最大整数；CEILING
等价的复数。
点数也将被转化成更大的表示。同样，如果实参中的任何一个是复数，则任何实参数会被转化成
参将被转化成以实际浮点实参的“最大”浮点表示而成的最接近浮点值。那些“较小”表示的浮
浮点数和复数是有传播性的。如果所有实参都是实数但其中有一个或更多是浮点数，那么其他实
带有有理部分的复数操作的结果产生了一个零虚部的数，此时结果将是一个有理数。尽管如此，
当只有一个参数时，+和*直接返回其值，-返回其相反值，而/返回其倒数。
相同的函数而后再在所得结果和其余参数上再次调用。例如，（+12 3）等价于（+（+1 2）3）。
两个相关的函数是MOD和REM，它返回两个实数截断相除得到的模和余数。这两个函数与
②严格来讲，MOD等价于Perl和Python中的%操作符，而REM等价于C和Java中的%。（从技术上来讲，名在C中的行为
①出于数学一致性的考虑，+和＊也可以不带参数被调用。这种情况下，它们将返回适当的值：+返回0，而*返回1。
因此，对于正的商它们是等价的，而对于负的商它们产生不同的结果。
因为/不作截断处理，所以Common Lisp提供了4种类型的截断和舍入用于将一个实数（有理
如果所有实参都是相同类型的数(有理数、浮点数或复数)，则结果也将是同类型的，除非
直到C99标准时才明确指定。）
+
+
+
1
1
+
+
#c(11) #c(2-1))→3
#c(1 2) 3/2)
23.0)
1 2.0)
4）
23}
105 2)
10 5)
23}
54}
#c(1 2)#c(3 4))
10.0 3.0)
(floor
35)
3)
(/ x y)} y) (mod x y)) =
√
个
个
↑
个
个
个
1/4
2/3
#c(5/2 2)
L
2
2６
#c(4 6)
#c(42)
13.0
m
0.6666667
3.0
www.TopSage.com
10.3初等数学
105
---
## Page 123
零。另外两个谓词EVENP和ODDP，测试单一整数参数是否是偶数或奇数。这些函数名称中的P后
数参数并返回最小或最大值。
可以用超过两个参数来调用，这时每个参数都跟其右边的那个参数相比较。
缀是一种谓词函数的标准命名约定，这些函数能够测试某些条件并返回一个布尔值。
所有参数具有相同值时才返回真。如下所示：
等价。（但通用等价谓词EQUALP使用=来比较数字。）如果它以超过两个参数被调用，它将只有当
将把不同类型在数学意义上等价的值视为等价，而通用等价谓词EQL将由于其类型差异而视其不
10.4数值比较
示了INCF/DECF、1+/1-和+/-之间的关系：
有所不同。1+和1-只是返回一个新值的函数，而INCF和DECF会修改一个位置。下面的恒等式显
106
要想选出几个数字中最小或最大的那个，你可以使用函数MIN或MAX，其接受任意数量的实
函数、=检查有理数和浮点数（也就是实数）的次序。跟=和/=相似，这些函数也
函数=是数值等价谓词。它用数学意义上的值来比较数字，而忽略类型上的区别。这样，：
(incf x)
函数1+和1-提供了表示从一个数字增加或减少一个的简化方式。注意它们与宏INCF和DECF
其他一些常用函数包括ZEROP、MINUSP和PLUSP，用来测试单一实数是否等于、小于或大于
(/= 1
相反，只有当函数/=的全部实参都是不同值时才返回真。
(max -1 2-3) -→ 2
(max 10 11)
=被拼写成了其逻辑等价形式NOT-GREATERP和NOT-LESSP，而不是更确切的
前面加上CHAR来命名；大小写无关的版本拼出比较符的名字，前面加上CHAR和一个连字符。不
它们全是相同字符时才返回真。大小写无关版本是CHAR-EQUAL。
是大小写无关的。
为替代，有两类函数提供了数值比较符的特定于字符的相似物：一类是大小写相关的，而另一类
将它们与其他字符相比较。由于字符不是数字，所以不能使用诸如这样的数值比较函数。作
10.7
的名字）是Tab、Page、Rubout、Linefeed、Return和Backspace。
尽管后者在技术上是合法的。其他半标准化的名字（如果字符集包含相应的字符实现就必须采用
Lisp实现，但所有实现都支持名字Space和Newline。这样就应该写成用#\Space来代替“#\”,
性不高，特定字符的替代语法是#\后跟该字符的名字。具体支持的名字取决于字符集和所在的
#\之后，包括“"”、“（”和空格这样的特殊字符。但以这种方式来写空格字符对我们来说可续
码,尽管从标准化组织的观点来看,Unicode在Common Lisp自身的标准化成型时期只是昙花一现.
的语言当字符编码改变时（比如说从8位ASCII到21位Unicode°）可能会出现问题。由于Common
10.6
以及取出一个比值或一个复数中的部分。完整的函数列表参见任何Common Lisp参考。
COSH和TANH及其逆函数ASINH、ACOSH和ATANH。它还提供了函数用来获取一个整数中单独的位
EXP和EXPT，基本三角函数SIN、COS和TAN及其逆函数ASIN、ACOS和ATAN，双曲函数SINH、
10.5
① 甚至像Java也会产生问题，它基于Unicode注定将成为未来主流字符编码这一理论，而从一-开始就被设计使用
数值=的大小写相关相似物是函数CHAR=。像=那样，CHAR=可以接受任意数量的实参并只在
其余的字符比较符遵循了相同的命名模式：大小写相关的比较符通过在其对应的数值比较符
字符的读取语法很简单：#\后跟想要的字符。这样，#\x就是字符x。任何字符都可以用在
CommonLisp字符和数字是不同类型的对象。本该如此一
目前为止，你所看到的函数只是初级的内置数学函数。Lisp也支持对数函数LOG，指数函数
位表示。太惨了。
字符比较
字符
高等数学
www.TopSage.com
--字符不是数字，而将其同等对待
10.7字符比较
107
---
## Page 125
输出。
出可读性良好输出的函数。例如，
因此，如果想要看到一个字符串的实际内容，就要使用诸如FORMAT这种原本就是设计用于打印
取器读取的。
也可以包括这两个字符。事实上，反斜杠总是转义其下一个字符，无论它是什么，尽管这对于除
何字符集支持的字符，除了双引号（"）和反斜杠（1)。而如果你将它们用一个反斜杠转义的话
串的这些方面，其余部分留到第11章再作介绍。
列。但字符串也有其自己的字面语法和一个用来进行字符串特定操作的函数库。本章将讨论字符
将在下一章讨论用来处理序列的许多函数时谈及许多字符串应用，因为字符串只不过是一种序
10.8
请参见你喜爱的CommonLisp参考。
获取不同大小写的对应字符，以及在代表字符编码的数值和实际字符对象之间转化。对于完整的细节，
108
正如你所看到的那样，字面字符串写在闭合的双引号里。你可以在一个字面字符串中包括任
注意，REPL将以可读的形式原样打印字符串，并带有外围的引号和任何必要的转义反斜杠。
如前所述，CommonLisp中的字符串其实是一种复合数据类型，
其他处理字符的函数包括测试一个给定字符是否是字母或者数字字符，测试一个字符的大小写，
"foo\"bar"
CL-USER>"foo\"bar"
"foo\bar"
"\"foobar\""
"foo\\bar"
"foo\"bar
"foobar"
字面字符串
字符串
数值相似物
第10章数字、字符和字符串
>=