embedded user-agents”. The security concern is that
using internal user-agent means that the whole user-
agent can be controlled by the host app, thus all data
in OAuth steps can be manipulated by the host app.
As shown in Figure 6(b), data in step 1 to step 5 can
all be manipulated by the host app,
including client
ID and redirect URI, user credentials, client name and
icon, authorization scope and access token. All these
data are highly sensitive and the leakage or modiﬁcation
on these data can cause severe security problems. Un-
fortunately, although well-studied and documented, our
ﬁndings show that insecure OAuth implementations with
WebViews are still very common.
4.3.3 Malicious XPM Behaviors
Finding 8: We conﬁrm the Web resource manip-
ulation behaviors with clearly malicious intents for
the ﬁrst time. As shown in Table 7, our study leads
to the discovery of some apps with malicious XPM
behaviors. To ﬁnd more malicious XPM behaviors,
we analyze more apps in the 1,414 apps that have
XPM behaviors. We write scripts to prioritize XPM
behaviors that manipulates either top Web services such
as Facebook, Google, or URLs contain very sensitive
words, such as “oauth”, “token”, “password”. Then we
select 200 apps for manual study, and ﬁnally we conﬁrm
22 malicious XPM behaviors in 21 distinct apps (listed in
Appendix A). Based on their malicious aims, we classify
these apps into three categories: impersonating relying
party in OAuth (A1, 2 apps), stealing user credentials
(A2, 6 apps) and stealing cookies (A3, 14 apps). Note
that one app named InstaView exhibits both A1 and A2
behaviors. We have reported these apps to Google Play,
and most of these apps have already been removed.
A1: Impersonating Relying Party in OAuth. We ﬁnd
Figure 6: OAuth 2.0 implicit grant. (a) is the standard
and secure implicit grant ﬂow using external user-agents
(such as external browsers), where the third-party app
can only control data in step 1 and step 7.
(b) shows
common insecure implementation using internal user-
agents such as WebViews, where the third-party app is
able to manipulate all data from step 1 to step 5.
apps impersonate another relying party in OAuth by
providing the client ID of the victim in step 1 (see
Figure 6(b)) and intercepting access token of the victim
in step 5. For example, Instaview is a visitor tracking
app that tells users who has viewed their Instagram ac-
count. It has 1,000,000-5,000,000 installations in Google
Play. To provide users with the visiting information, it
asks users to grant several permissions by OAuth in a
WebView. However, it uses the client ID of another app
named Tinder. After user authorization, it intercepts the
access token for Tinder using shouldOverrideUrlLoad-
ing API. After that it continues to impersonate Tinder to
access user data from the authorization server Instagram.
By using the client ID and access token of another app,
Instaview bypasses registration auditing and resource
usage monitoring from Instagram. One may think that
users would refuse to authorize Instaview when they see
the permissions are granted to Tinder. Actually, we
ﬁnd this app receives more than 27,000 ﬁve stars in
Google Play. Furthermore, since Instaview controls the
WebView, it can modify the name and icon in step 3 in
Figure 6(b) to cheat users.
A2: Stealing User Credentials. Apps in this category
inject JavaScript code to sensitive Web pages, such as
login page and OAuth authorization page to steal user
credentials. For example, Adkingkong is an app for
USENIX Association
27th USENIX Security Symposium    1193
 !"#$%&’#()%’&&*+,#-’.,/(012(!%3,#4"5,%&#64"$,#78%59",/(%:;%’/$%#,$"#,5(%*’("6/%+56&,?8%#,$"#,5(%*’("6/%+56&,E8%59",/(%/’G,%’/$%"56/F8%59",/(%/’G,%’/$%"56/users to buy advertisements. This app has 500,000 to
1,000,000 installations in Google Play. This app asks
users to login with their Google accounts in a WebView.
However, when users input their emails and passwords,
it uses loadUrlJs API to inject JavaScript code into the
login page and steals user credentials. The Instaview app
described above also steals user credentials in step 2 of
Figure 6(b) using similar methods.
A3: Stealing and Abusing Cookies. We ﬁnd sev-
eral apps using XPM to steal cookies and abuse these
cookies. For example, Chatous is an app for users to
randomly chat with real people. Its installation count is
about 10,000,000 to 50,000,000.
It incorporates Face-
book OAuth SDK for users to sign in with their Facebook
accounts. When Facebook ofﬁcial app is not installed on
user devices, Facebook SDK uses a WebView to do the
OAuth. After user login, Facebook cookies will be saved
into the local storage of WebView. We ﬁnd that Chatous
gets Facebook cookies using CookieManager.getCookie
API and directly invokes Facebook APIs using these
cookies to get the user friend list and send invitation
messages to all the friends of the user. Actually, without
Facebook cookies these APIs are invisible to third-party
apps such as Chatous. We also ﬁnd other apps from
the same developer of Chatous exhibit similar behaviors,
including Melon, Kiwi, and Plaza. Both Melon and Kiwi
have 10,000,000 to 50,000,000 installations, and Plaza
has 1,000,000 to 5,000,000 installations.
Finding 9: Malicious XPM behaviors exist on both
Android and iOS. For the 21 apps with malicious
XPM behaviors, we try to look for their counterparts
on iOS platform and successfully ﬁnd 8 apps have iOS
versions. Then we use network trafﬁc analysis to check
if they have the same XPM behaviors as their Android
counterparts. Finally we conﬁrm the Chatous iOS app
and other 3 apps from the same developers still have
the same malicious XPM behaviors (i.e.
stealing and
abusing cookies).
Finding 10: Most of malicious XPM behaviors
target OAuth.
In our results, 18 out of 21 apps with
malicious XPM behaviors attack OAuth, indicating that
OAuth is the mostly targeted Web service.
Finding 11: Malicious XPM behaviors have af-
fected a large number of users. For the 21 apps with
malicious XPM behaviors, we collect their installation
count in Google Play. We ﬁnd that these 21 apps have to-
tal installations ranging from 29,885,000 to 131,220,000,
which means a lot of users are affected.
5
Implications on Mitigation
Our empirical study shows that the Web resource ma-
nipulation capability of WebView brings huge risks to
service providers. This section studies the awareness of
such risks to service providers and reviews the defensive
mechanisms in securing Web service integration.
5.1 Risk Awareness to Service Providers
We study ﬁve popular Web service providers (Facebook,
Twitter, Google, Weibo and QQ) on whether they pro-
hibit users from accessing login and OAuth pages in
WebView. The result is shown in Table 8.
Table 8: Experiments on loading login/OAuth pages of
major Web service providers in WebView.
Service
providers
Facebook
Twitter
Google
Weibo
QQ
Allow login
in WebView
Allow OAuth
in WebView
Y
Y
Y
Y
Y
Y
Y
N
Y
Y
We ﬁnd that these providers all support user login and
OAuth in WebViews, except Google who blocks OAuth
in embedded WebViews [3]. However, our further study
ﬁnd that Google only uses “USER-AGENT” header to
identify WebViews, which can be easily manipulated
by host apps. For example, in Android, apps can use
setUserAgentString API to change the “USER-AGENT”
header to any value such as “Google Chrome”. We con-
duct such an experiment and successfully load Google
OAuth page in our controlled WebView. Thus, we draw
the following conclusion.
Finding 12: Most Web service providers are un-
aware of risks in Web resource manipulation, and can
not effectively prevent users from accessing sensitive
pages in WebView.
5.2 Evaluating Defensive Techniques
To secure Web service integration, several techniques
have been proposed. Based on our measurement results,
we rethink their solutions and conclude several ﬁndings.
Finding 13: Complete isolation of WebView is not
compatible to most apps. Complete isolation is a com-
mon way to protect host program from untrusted code.
LayerCake [41] protects the in-app WebView by running
WebView in a separate process and seamlessly sharing
UI display and events between the host app process and
the WebView process. Similarly, AdSplit [44] and Ad-
Droid [37] use process-level isolation to run WebView-
based advertisements in separate processes. Although
complete isolation is achieved between the host app
process and the WebView process, it can not further sup-
port WebView manipulation which requires accessing
1194    27th USENIX Security Symposium
USENIX Association
WebView resources directly in the host process. In our
study, we ﬁnd that most of XPM behaviors are necessary
to improve the usability for mobile users (see Findings
6). Thus, though complete isolation improves security, it
is hard to apply to existing apps.
Finding 14: Fine-grained access control is a must
for regulating Web resource manipulation APIs. Ac-
cess control is the fundamental way to regulate API
usage. To regulate Web resource manipulation APIs,
WIREFRAME [20] uses binary rewriting to replace
default WebView instances in apps with isolated and
mediated WIREFRAME instances.
It further provides
origin-based access control policy, in which each app
is treated as a standalone origin and policies can be
expressed as whether an app from origin X can access
the Web resources of origin Y. In theory, WIREFRAME
is quite useful in preventing the abuse of Web resource
manipualation APIs found in our case studies. However,
we ﬁnd the access control mechanism in WIREFRAME
is not ﬁne-grained enough because they make the whole
app as a single origin, while our Finding 3 shows that
more than 60% of XPM behaviors are from libraries.
Thus, without ﬁne-grained access control, systems like
WIREFRAME are hard to effectively protect Web re-
sources from being abused.
6 Discussion
The cross-principal manipulation problem proposed in
this paper is similar to the one faced by Web browser
extensions [27, 25], since both mobile apps and browser
extensions can manipulate Web resources. The common
challenge is how to identify suspicious ones. The most
signiﬁcant difference we observe is that mobile apps may
manipulate content from their own servers or others,
while most browser extensions are designed to operate
on web content of others. Thus, different to vetting
suspicious browser extensions, a new challenge met by
our work is that we need a ﬁne-grained analysis to
recognize whether the host app manipulates his own
resources or resources of other parties. Our work makes
non-trivial efforts by leveraging static analysis, code
similarity and search engines.
Currently, our work has a few limitations. Since
our static analyzer is based on several existing static
analysis tools [28, 11, 30], XPMChecker inherits lim-
itations of these tools. Besides, XPMChecker can not
prevent determined attackers from evading our analysis.
For example,
they can hide the invocations of Web
resource manipulation APIs using Java reﬂection, or
obfuscate the identiﬁers for recognizing Web principals
and app principals. To handle this case, XPMChecker
can adopt more sophisticated techniques [31, 14, 13, 39]
which is an orthogonal research direction. In this paper,
XPMChecker is designed to perform an empirical study
rather than to be a detection tool. Our evaluation and
study show that it is effective to draw several insightful
ﬁndings.
Although our empirical study is performed on Android
apps, the ideas proposed in this paper also work on
in our study, manual effects
iOS platform. Finally,
are involved to classify XPM behaviors.
In the future
work, we plan to automatically label the types of XPM
behaviors with heuristic rules and learning techniques.
7 Related Work
The interplay between mobile app, embedded browser,
and embedded web content is complex and fraught with
security concerns.
Prior work have discussed these
problems in several aspects.
Web-to-App Security. A large number of these works
focus on how Web code can attack native apps. Several
works point out that malicious JavaScript code from
unauthorized Web origin can get sensitive data from
the host apps through several ways, including abusing
the JavaScript bridge (exported Java functions using
addJavascriptInterface API) [32, 17, 36, 23], accessing
ﬁle system [17, 23, 45], abusing HTML5 geolocation
API [23] or postMessage API [24]. To detect such
malicious Web code, BridgeScope [48] is proposed to
precisely and scalably vet JavaScript Bridge vulnerabil-
ities in hybrid apps. Rastogi et al. [40] try to detect
and ﬁnd the provenance of attacks from ad libraries
to host apps.
Jin et al. [26] study the channels for
malicious JavaScript to be loaded by HTML5-based
mobile apps. Further more, some defensive mechanisms
are also proposed. NoFRAK [22] enforces access control
rules for the Web code in Cordova framework, with
the help of unforgeable capability tokens from the Web
server. Draco [46] provides a uniform and ﬁne-grained
access control framework to regulate Web code.
App-to-Web Security. An opposite research direc-
tion is to study how host apps can attack Web resources.
Luo et al. [32] show that malicious apps can attack
Web pages by injecting JavaScript code or snifﬁng and
hijacking Web navigation events.
In [33], they also
demonstrate that malicious apps can hijack touch events
of the web pages. Shehab et al. [43] and Chen et
al. [16] focus on the security issues of a certain kind
of Web service, i.e. OAuth in mobile apps. When
using WebView as the user-agent in OAuth, Shehab
et al. [43] show that user credentials and authorization
interface may be attacked, while Chen et al. [16] point
out that access token sent in redirection URI may be
leaked by the host app. However, none of existing
work seeks to ﬁnd such attacks in real-world apps.
This paper ﬁrstly phrases this threat as cross-principal
USENIX Association
27th USENIX Security Symposium    1195
Web resource manipulation, then overcomes several non-
trivial challenges to design a detection tool, and ﬁnally
conﬁrms this kind of attack in not only Android apps but
also iOS apps.
Furthermore, XPMChecker leverages techniques from
several related ﬁelds, including static analysis, library
detection, and text similarity. The static analyzer mod-
ule is based on state-of-the-art static analysis tools,
including Soot [28], Flowdroid [11] and IccTA [30].
Speciﬁcally, we use the intermediate representations
provided by Soot [28], build an ICFG for each APK
based on Flowdroid [11], and extract inter-component
information provided by IccTA [30]. Our method to
distinguish library code and app code is inspired by some
library detection work [19, 47, 34, 49]. Furthermore,
search engine is utilized by the XPMClassiﬁer module
to recognize XPM behaviors. Besides, search engine is
also widely used in the context of short-text semantic
similarity, such as in [38, 21, 42, 15].
8 Conclusion
This paper conducts the ﬁrst empirical study on Web re-
source manipulation with large-scale apps. We deﬁne the
threats in Web resource manipulation as XPM problems.
To support automatically recognizing XPM behaviors,
we design XPMChecker which overcomes several non-
trivial challenges. With a study of 80,694 top Google
Play apps, we ﬁnd that 49.2% of manipulation points
are XPM, 4.8% of apps contain XPM behaviors, and
more than 70% XPM behaviors manipulate top popular
Web sites. More importantly, we conﬁrm the threat of
XPM behaviors with obvious malicious intents in both
Android and iOS apps. Our further studies actuate us
to rethink existing defensive mechanisms and propose
new suggestions for future defense design. Besides, to
facilitate further research in XPM behaviors, we release
the dataset at https://xhzhang.github.io/XPMChe
cker/.
Acknowledgements
We would like to thank the anonymous reviewers for
their insightful comments that helped improve the quality
of the paper. This work was supported in part by the Na-
tional Natural Science Foundation of China (U1636204,
61602123, 61602121, U1736208) and the National Pro-
gram on Key Basic Research (NO. 2015CB358800).
Yuan Zhang was supported in part by the Shanghai Sail-
ing Program under Grant 16YF1400800 and a research
gift from Ant Financial. The IU author is supported in
part by the NSF 1408874, 1527141, 1618493 and ARO
W911NF1610127.
References
[1] Apache Cordova. https://cordova.apache.org/.
[2] Building Web Apps in WebView. https://developer.andr
oid.com/guide/webapps/webview.html.
[3] Modernizing OAuth Interactions in Native Apps for Better
Usability and Security. https://developers.googleblog.