# 第六章：分割槽
![](../img/ch6.png)
> 我们必须跳出电脑指令序列的窠臼。叙述定义、描述元资料、梳理关系，而不是编写过程。
>
> —— Grace Murray Hopper，未来的计算机及其管理（1962）
>
-------------
[TOC]
在 [第五章](ch5.md) 中，我们讨论了复制 —— 即资料在不同节点上的副本，对于非常大的资料集，或非常高的吞吐量，仅仅进行复制是不够的：我们需要将资料进行 **分割槽（partitions）**，也称为 **分片（sharding）**[^i]。
[^i]: 正如本章所讨论的，分割槽是一种有意将大型资料库分解成小型资料库的方式。它与 **网路分割槽（network partitions, netsplits）** 无关，这是节点之间网路故障的一种。我们将在 [第八章](ch8.md) 讨论这些错误。
> #### 术语澄清
>
> 上文中的 **分割槽（partition）**，在 MongoDB，Elasticsearch 和 Solr Cloud 中被称为 **分片（shard）**，在 HBase 中称之为 **区域（Region）**，Bigtable 中则是 **表块（tablet）**，Cassandra 和 Riak 中是 **虚节点（vnode）**，Couchbase 中叫做 **虚桶（vBucket）**。但是 **分割槽（partitioning）** 是最约定俗成的叫法。
>
通常情况下，每条资料（每条记录，每行或每个文件）属于且仅属于一个分割槽。有很多方法可以实现这一点，本章将进行深入讨论。实际上，每个分割槽都是自己的小型资料库，尽管资料库可能支援同时进行多个分割槽的操作。
分割槽主要是为了 **可伸缩性**。不同的分割槽可以放在不共享丛集中的不同节点上（请参阅 [第二部分](part-ii.md) 关于 [无共享架构](part-ii.md#无共享架构) 的定义）。因此，大资料集可以分布在多个磁碟上，并且查询负载可以分布在多个处理器上。
对于在单个分割槽上执行的查询，每个节点可以独立执行对自己的查询，因此可以透过新增更多的节点来扩大查询吞吐量。大型，复杂的查询可能会跨越多个节点并行处理，尽管这也带来了新的困难。
分割槽资料库在 20 世纪 80 年代由 Teradata 和 NonStop SQL【1】等产品率先推出，最近因为 NoSQL 资料库和基于 Hadoop 的资料仓库重新被关注。有些系统是为事务性工作设计的，有些系统则用于分析（请参阅 “[事务处理还是分析](ch3.md#事务处理还是分析？)”）：这种差异会影响系统的运作方式，但是分割槽的基本原理均适用于这两种工作方式。
在本章中，我们将首先介绍分割大型资料集的不同方法，并观察索引如何与分割槽配合。然后我们将讨论 [分割槽再平衡（rebalancing）](#分割槽再平衡)，如果想要新增或删除丛集中的节点，则必须进行再平衡。最后，我们将概述资料库如何将请求路由到正确的分割槽并执行查询。
## 分割槽与复制
分割槽通常与复制结合使用，使得每个分割槽的副本储存在多个节点上。这意味著，即使每条记录属于一个分割槽，它仍然可以储存在多个不同的节点上以获得容错能力。
一个节点可能储存多个分割槽。如果使用主从复制模型，则分割槽和复制的组合如 [图 6-1](../img/fig6-1.png) 所示。每个分割槽领导者（主库）被分配给一个节点，追随者（从库）被分配给其他节点。每个节点可能是某些分割槽的主库，同时是其他分割槽的从库。
我们在 [第五章](ch5.md) 讨论的关于资料库复制的所有内容同样适用于分割槽的复制。大多数情况下，分割槽方案的选择与复制方案的选择是独立的，为简单起见，本章中将忽略复制。
![](../img/fig6-1.png)
**图 6-1 组合使用复制和分割槽：每个节点充当某些分割槽的主库，其他分割槽充当从库。**
## 键值资料的分割槽
假设你有大量资料并且想要分割槽，如何决定在哪些节点上储存哪些记录呢？
分割槽目标是将资料和查询负载均匀分布在各个节点上。如果每个节点公平分享资料和负载，那么理论上 10 个节点应该能够处理 10 倍的资料量和 10 倍的单个节点的读写吞吐量（暂时忽略复制）。
如果分割槽是不公平的，一些分割槽比其他分割槽有更多的资料或查询，我们称之为 **偏斜（skew）**。资料偏斜的存在使分割槽效率下降很多。在极端的情况下，所有的负载可能压在一个分割槽上，其余 9 个节点空闲的，瓶颈落在这一个繁忙的节点上。不均衡导致的高负载的分割槽被称为 **热点（hot spot）**。
避免热点最简单的方法是将记录随机分配给节点。这将在所有节点上平均分配资料，但是它有一个很大的缺点：当你试图读取一个特定的值时，你无法知道它在哪个节点上，所以你必须并行地查询所有的节点。
我们可以做得更好。现在假设你有一个简单的键值资料模型，其中你总是透过其主键访问记录。例如，在一本老式的纸质百科全书中，你可以透过标题来查询一个条目；由于所有条目按字母顺序排序，因此你可以快速找到你要查询的条目。
### 根据键的范围分割槽
一种分割槽的方法是为每个分割槽指定一块连续的键范围（从最小值到最大值），如纸质百科全书的卷（[图 6-2](../img/fig6-2.png)）。如果知道范围之间的边界，则可以轻松确定哪个分割槽包含某个值。如果你还知道分割槽所在的节点，那么可以直接向相应的节点发出请求（对于百科全书而言，就像从书架上选取正确的书籍）。
![](../img/fig6-2.png)
**图 6-2 印刷版百科全书按照关键字范围进行分割槽**
键的范围不一定均匀分布，因为资料也很可能不均匀分布。例如在 [图 6-2](../img/fig6-2.png) 中，第 1 卷包含以 A 和 B 开头的单词，但第 12 卷则包含以 T、U、V、X、Y 和 Z 开头的单词。只是简单的规定每个卷包含两个字母会导致一些卷比其他卷大。为了均匀分配资料，分割槽边界需要依据资料调整。
分割槽边界可以由管理员手动选择，也可以由资料库自动选择（我们会在 “[分割槽再平衡](#分割槽再平衡)” 中更详细地讨论分割槽边界的选择）。Bigtable 使用了这种分割槽策略，以及其开源等价物 HBase 【2, 3】、RethinkDB 和 2.4 版本之前的 MongoDB 【4】。
在每个分割槽中，我们可以按照一定的顺序储存键（请参阅 “[SSTables 和 LSM 树](ch3.md#SSTables和LSM树)”）。好处是进行范围扫描非常简单，你可以将键作为联合索引来处理，以便在一次查询中获取多个相关记录（请参阅 “[多列索引](ch3.md#多列索引)”）。例如，假设我们有一个程式来储存感测器网路的资料，其中主键是测量的时间戳（年月日时分秒）。范围扫描在这种情况下非常有用，因为我们可以轻松获取某个月份的所有资料。
然而，Key Range 分割槽的缺点是某些特定的访问模式会导致热点。如果主键是时间戳，则分割槽对应于时间范围，例如，给每天分配一个分割槽。不幸的是，由于我们在测量发生时将资料从感测器写入资料库，因此所有写入操作都会转到同一个分割槽（即今天的分割槽），这样分割槽可能会因写入而过载，而其他分割槽则处于空闲状态【5】。
为了避免感测器资料库中的这个问题，需要使用除了时间戳以外的其他东西作为主键的第一个部分。例如，可以在每个时间戳前新增感测器名称，这样会首先按感测器名称，然后按时间进行分割槽。假设有多个感测器同时执行，写入负载将最终均匀分布在不同分割槽上。现在，当想要在一个时间范围内获取多个感测器的值时，你需要为每个感测器名称执行一个单独的范围查询。