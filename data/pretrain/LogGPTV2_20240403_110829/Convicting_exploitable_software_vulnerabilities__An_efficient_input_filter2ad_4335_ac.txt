for the predicate instance pj that controls the deﬁnition of
ti’s value. Line 35 makes use of SCD information and
looks for the control dependence of the deﬁnition of ti. Es-
sentially, the search algorithm takes into account the effect
of control dependence without incurring oversized lineage
sets.
The Mutate method takes the benign test input T and
the lineage DL that is found by the Search method, and
tries to mutate T by replacing the DL with something else.
The mutation method applies several heuristics in changing
T , as shown in line 41-53, the ﬁrst heuristic is to change
the integer values in DL to the maximum unsigned integer
(MAXUINT, i.e., 0xffffffff), several other boundary
values such as 0,−10,−100,−1000, 1, 10, 1000, and ’%n’,
etc. Changing to a boundary integer is to exploit integer
overﬂow or integer value related vulnerabilities; changing
to ’%n’ is to trigger format-string vulnerability. The sec-
ond heuristic is to change the size of input, with the goal
of triggering buffer overﬂows. This is done by duplicating
DL in T after each iteration till a threshold is hit (we set
the threshold as 16 since we seldom ﬁnd the buffer length is
greater than 216). In other words, this heuristic replaces DL
in T with DL · DL, DL · DL · DL · DL, and so on. Users
also have the freedom to insert their own heuristics. We ob-
serve that simple heuristics turn out to be highly effective in
producing exploits.
Directed Input Generation.
If the benign input T
does not cover the suspect s, the Driver function calls
DirectedTGen to generate a new program input to cover
s. Starting from s, the input generation procedure transi-
tively searches along s’s static control dependencies until
it sees a direct/indirect control dependence p that has been
executed with input T , then it tries to mutate the lineage
of the ﬁrst execution instance p1 such that program execu-
tion with the new input takes the edge p → t, which leads
to s. In other words, the new execution is one step closer
to s. The procedure repeats until s gets covered. Com-
pared with the state of the art of test generation techniques,
our input generation is more directed, meaning that we only
try to cover a speciﬁc program point instead of all feasible
program paths. Another difference is that our technique is
facilitated by data lineage.
(a) Real
(b) Spurious
Figure 3. Correlations
Currently,
this procedure involves user interactions,
namely, the function MMutate requires the user to inspect
predicate conditions to construct a replacement of the rele-
vant lineage. Compared with the automated Mutate, the
possible mutations in MMutate (line 19) are not bounded
by the types of considered vunerabilities. While source
code access would be beneﬁcial to MMutate, our experi-
ence shows that the desired mutation can also be inferred
from the binary predicate instruction and its lineage, as
demonstrated by the evaluation case in Section 5.1.3.
Correlated Inputs. So far, we have presented our tech-
nique on trying to mutate a test case by replacing one
lineage. However, if the inputs have correlations, multi-
ple lineages may have to be mutated in order to success-
fully trigger a vulnerability. Consider the example in Fig-
ure 3(a). The suspect is at statement 9. Since variable
packettype is set to 0 according to the lineage, variable
i is set to MAX SIZE-1. If our system only tries to mutate
DL(packettype) to generate the exploit, it would fail
because the lineage of fgetc(in), as shown inside the
second rectangle, needs to change simultaneously in order
to trigger the attack. This is due to input correlation. To han-
dle such correlated input mutations, a potential solution is
to mutate the input in multiple rounds, namely, recursively
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:15:55 UTC from IEEE Xplore.  Restrictions apply. 
Input :...0x00 … aaaaaaaa\0…char buf[MAX_SIZE];packettype=fgetc(in);…i=0;if (packettype==0)       i = MAX_SIZE-1;else      while (fgetc( in) ) i++;buf[i]= ...1.2.3.4.5.6.7.8.9.Input :...0x00 0x01… 0x01 ……  0xFF …char buf[MAX_SIZE];fread(&size, sizeof(short),1,in);…i=0;while (i pkt.user_id = m_alloc
(sizeof *packet->pkt.user_id + pktlen);
...
p = packet->pkt.user_id->name;
for( ; pktlen; pktlen--, p++ )
*p = iobuf_get_noeof(inp);
*p = 0;
...
Figure 4. Parse-packet.c of Gnupg-1.0.5
The integer overﬂow suspect
is the expression of
m alloc. We started with a benign input. Unfor-
tunately,
the benign input did not lead to execution of
parse user id, we have to ﬁrst mutate the benign in-
put such that the desired path is covered.
In this case,
our diablo based SCD module is called, and it disas-
sembles the binary code of gnupg, and generates an inter-
procedural static control ﬂow graphThe total time of such
a procedure is 238 seconds in our experiment. We dis-
play part of the graph in Figure 5. A box node represents
a basic block and the instructions of this basic block are
displayed inside the box. For better illustration, we an-
notate the graph with the corresponding source code. As
we can see, the initial input drives program execution along
the path from 0x805d1de to 0x805d1e5 while the de-
sired program point is at line 1597. According to our
SCD computation, line 1597 is transitively statically con-
trol dependent on the call site to function parse user id
(0x805d386), which in turn is statically control depen-
dent on the switch statement at line 397 (0x805d1de).
This point was executed by our initial input. The lineage of
pkttype(%ecx) at this point contains the input value of
6. We manually inspected the path condition and concluded
that changing the lineage value to 13 leads to the suspect.
With the mutated benign input that drives the execu-
tion to 1597, the mutator found the lineage at 1597 is not
empty due to the data dependences between 1597 and 1585,