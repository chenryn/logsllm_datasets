title:Secure and Flexible Monitoring of Virtual Machines
author:Bryan D. Payne and
Wenke Lee
23rd Annual Computer Security Applications Conference
23rd Annual Computer Security Applications Conference
Secure and Flexible Monitoring of Virtual Machines
Bryan D. Payne Martim D. P. de A. Carbone Wenke Lee
Georgia Institute of Technology
{bdpayne,mcarbone,wenke}@cc.gatech.edu
Abstract
The monitoring of virtual machines has many applica-
tions in areas such as security and systems management. A
monitoring technique known as introspection has received
signiﬁcant discussion in the research literature, but these
prior works have focused on the applications of introspec-
tion rather than how to properly build a monitoring archi-
tecture. In this paper we propose a set of requirements that
should guide the development of virtual machine monitor-
ing solutions. To illustrate the viability of these require-
ments, we describe the design of XenAccess, a monitoring
library for operating systems running on Xen. XenAccess
incorporates virtual memory introspection and virtual disk
monitoring capabilities, allowing monitor applications to
safely and efﬁciently access the memory state and disk ac-
tivity of a target operating system. XenAccess’ efﬁciency
and functionality are illustrated through a series of perfor-
mance tests and practical examples.
1 Introduction
On the wave of its renewed popularity, researchers are
identifying many new applications that leverage the abstrac-
tions and isolation provided by virtualization. One area that
has received signiﬁcant attention is security. Security ap-
plications beneﬁt from virtualization by running in isolated
virtual machines (VMs) and building smaller trusted com-
puting bases (TCBs). This technique has been used in a
variety of research projects [21, 9, 10, 18, 7, 15, 2].
Among the security research that uses virtualization, an
increasingly common practice is to setup a secure VM that
is used to monitor the other VMs running on the same vir-
tual machine monitor (VMM)1. These monitors are used in
intrusion detection systems (IDS), integrity checking, hon-
eypot systems and forensic analysis, among others. We be-
lieve that this idea is sound, yet many previous efforts in
this space have focused more on the applications of intro-
1Throughout this paper, the term VMM refers to the virtual machine
monitor on top of which VM’s run, whereas the term monitor refers to the
actual VM monitoring applications that we focus on in this work.
spection than building a proper architecture to support the
technique.
In this paper, we present the XenAccess monitoring li-
brary and our lessons learned from the implementation pro-
cess. XenAccess provides virtual memory introspection and
virtual disk monitoring capabilities. Our experience de-
signing and implementing this library has shown that im-
plementing introspection in a secure and efﬁcient manner
is non-trivial. However, our architecture demonstrates how
one can achieve these goals without losing monitoring func-
tionality. Monitoring with XenAccess requires no changes
to the VMM or to the VM being monitored. In addition,
no changes are required to the OS being monitored, so Xe-
nAccess is not restricted to monitoring open source OSes.
While our current implementation focuses on monitoring
XenoLinux the XenAccess Library can be extended to mon-
itor any OS that runs on the VMM. XenAccess incurs a
negligible performance penalty for typical monitor appli-
cations.
We designed the XenAccess architecture based on six
high-level requirements. In a general sense, these require-
ments can be seen as typical good programming guidelines,
or good security guidelines. For example, some of our re-
quirements could be seen as specialized versions of Saltzer
and Schroeder’s classic security design principles [28]. This
is intentional, as our goal was to leverage known design
principles in order to build a robust monitoring architec-
ture. With this in mind, we identify the following six re-
quirements for monitoring VMs:
1. No superﬂuous modiﬁcations to the VMM. The
VMM should remain as small and simple as possible
since it is part of the TCB. If a VMM includes the nec-
essary primitives to support the monitoring architec-
ture, then it should not be modiﬁed. If a VMM lacks
the necessary primitives, then the modiﬁcations made
should be what is minimally required to support the
monitoring architecture.
2. No modiﬁcations to the VM or the target OS. Mod-
iﬁcations to the target OS (i.e., the OS being moni-
tored), are problematic. The target OS can tamper with
1063-9527/07 $25.00 © 2007 IEEE
1063-9527/07 $25.00 © 2007 IEEE
DOI 10.1109/ACSAC.2007.10
DOI 10.1109/ACSAC.2007.10
385
385
this code, and changes to the target OS may require ac-
cess to the target OS source code, which is not always
available. One of the key reasons why virtualization is
attractive for monitoring is the isolation between VMs.
Placing monitoring code within the same OS that is
being monitored bypasses this isolation, negating this
key beneﬁt. Therefore, this requirement encourages all
monitoring code to remain in an isolated VM unless
such a restriction makes it impossible for a monitor to
gather the necessary information.
3. Small performance impact. An excessive perfor-
mance impact can render a monitoring architecture
worthless. This requirement ensures that the monitor-
ing architecture does not prevent the target OS from
performing its intended functions. The performance
impact is measured as any reduction in performance of
an application caused by the monitoring software. Ide-
ally this impact is both small and consistent, but some
initialization costs may be required.
4. Rapid development of new monitors. New monitors
may be needed to address new types of attacks. Fur-
thermore, it is advantageous to keep the monitor code
simple to limit the opportunity for introducing errors
into the monitors. The monitoring architecture should
provide APIs that are used to develop new monitors.
Therefore, satisfaction of this requirement means that
the APIs should be designed in a way that simpliﬁes
the job of the monitor developer.
5. Ability to monitor any data on target OS. Monitors
should have a full view into the target OS. The moni-
toring architecture should not be limited to providing
information about a small part of the target OS. For
example, an ideal memory monitor should be able to
view all memory on the target OS. Likewise, an ideal
disk monitor should be able to view all data going to
and from the disk device. While this ideal may not al-
ways be possible, the more information a monitor can
view, the harder it is for an attacker to evade detection.
6. Target OS cannot tamper with monitors. If the tar-
get OS can tamper with the monitors, then the pos-
sibility exists for malicious code to tamper with the
monitors. For this reason, all of the monitors should
be isolated or protected from the target OS. This is re-
lated to requirement (2), above. However, here we re-
quire that all monitor code, regardless of its location,
be protected from attack. If all monitor code is in an
isolated VM, then this is not difﬁcult. If some moni-
tor code must be placed outside of the TCB, then addi-
tional measures must be taken to protect that code. The
extent of these measures will depend on the nature of
the code being protected.
Our main contribution is the XenAccess monitoring ar-
chitecture that satisﬁes the above requirements.
It is im-
portant to emphasize that this paper addresses an architec-
ture for security and not actual security techniques (such as
IDS algorithms). These are topics for future papers. The
remainder of this paper focuses on the XenAccess archi-
tecture, its implementation, and some example applications
that demonstrate the performance and ﬂexibility of XenAc-
cess. Section 2 discusses the related work. Section 3 pro-
vides background information on the components in Xen
used to build XenAccess. Section 4 presents the architec-
ture and implementation details for XenAccess. Section
5 shows the results of our performance testing along with
some example applications. Section 6 discusses future di-
rections in this research space and we conclude with Section
7.
2 Related Work
VMMs ﬁrst came into use over 35 years ago [11]. While
Madnick and Donovan identiﬁed the security beneﬁts of
VMMs in the early 70s [20], research that explicitly lever-
aged these beneﬁts did not take place until nearly 20 years
later [17, 16]. More recently, virtualization is being used in
different ways to address a variety of systems management,
and security problems. In the security space, we have seen
innovative work in intrusion detection systems [10, 18, 15],
workload isolation [21, 9], attack investigation and debug-
ging [7], and system monitoring [13, 2]. Each of these ap-
plications have one thing in common: they each require the
ability to monitor data from a target OS. However, the me-
chanics of how to properly do such monitoring have not
been adequately addressed in the literature. Through the
details provided in this paper, and by making XenAccess an
open source project, we are exposing these mechanics for
the beneﬁt of future work in this space.
The technique of virtual memory introspection was in-
troduced by Garﬁnkel and Rosenblum [10]. While this
work laid out how introspection could be used to build an
intrusion detection system, the underlying mechanics of in-
trospection were not discussed. Joshi et al presented a sys-
tem called IntroVirt [15] that uses introspection and replay
to test if a system was previously attacked through a known
vulnerability. Similar to the ﬁrst effort, only limited details
were given regarding the introspection mechanism. More
recently, several projects have provided details about their
introspection techniques, only to reveal suboptimal security
decisions in their architecture. The Hyperspector project
[18] is a virtual distributed monitoring environment used
for intrusion detection. The Hyperspector approach to in-
trospection is to provide access to a few speciﬁc pieces of
information (processes, sockets, etc). This limited view into
the target OS violates property (5) of our requirements for a
robust monitoring solution, and Hyperspector also violates
386386
property (1) by extensively modifying the VMM, and (6) by
sharing OS kernels between VMs. Asrigo et al presented a
system for monitoring honeypots [2], but they violate prop-
erty (2) by requiring hooks in the target OS kernel, property
(3) by causing a substantial performance impact, and prop-
erty (4) by incorporating kernel code in new monitor hooks.
Finally, the Antfarm system [13] tracks only OS-level pro-
cesses, violating property (5), and performs the monitor-
ing from within the VMM, violating property (1). Each of
these virtual memory introspection systems were built to
provide monitoring capabilities for a security system. How-
ever, none of these systems meet our six requirements for a
monitoring solution, making it much more likely for an in-
truder to compromise, evade or disable the monitors.
Monitoring in a virtualized environment is not the only
approach. Petroni et al developed Copilot [23], a secure co-
processor used to monitor the memory of a host. In practice,
this approach is very similar to virtual memory introspec-
tion from a VM, but it requires extra hardware and cannot
be generalized to monitoring other data such as disk I/O.
Looking into the commercial world, many monitoring ap-
plications sold today simply run within the target OS. For
example, anti-virus software typically runs in the same OS
that it is protecting. However, this architecture is ﬂawed be-
cause malicious software can simply disable the anti-virus
software [3].
Monitoring at the disk level has traditionally taken place
as part of a research trend focused on creating smarter,
more semantically-aware devices. This has applications in
both systems optimization and security. Sivathanu et al
has shown how smart disks can employ gray-boxing tech-
niques [1] to infer the semantics of the underlying ﬁlesys-
tem and use this knowledge to enable various performance
improvements and features like secure ﬁle deletion [29].
Researchers at Carnegie-Mellon University have leveraged
the physical isolation of such systems to enable intrusion
detection [22, 12] and recovery capabilities [30]. These sys-
tems are able to perform their functions in a tamper-resistant
manner, regardless of an OS compromise. This approach,
however, has the obvious downside of requiring additional
hardware support and the need for a special infrastructure
for communication between the management tools inside
the OS and the disk IDS. XenAccess leverages virtualiza-
tion to provide the same level of monitoring functionality
without either of these limitations.
More recently, disk monitoring has started to receive
attention in the context of virtual machines. Hyper-
Spector’s approach is to mount a shadow version of the
monitored ﬁlesystem and execute integrity checkers (e.g.,
tripwire). Not only does this require signiﬁcant modiﬁ-
cations to the VMM, violating property (1) and increasing
the chances of a VMM compromise; it also limits access to
the disk data by providing an exclusively static and high-
level view of it, violating property (5) and making it very
easy to evade the monitor. Elango et al [8] and Jones et al
[14] have applied some of the principles of semantically-
smart disk systems and gray-boxing [29, 1] to the perfor-
mance improvement of Xen virtual machines. Their results
show how monitoring and active control of virtual machines
can have a wide variety of applications outside the security
area.
XenAccess is designed to work with Xen [4], but the
ideas of virtual memory introspection and disk monitoring
are not unique to Xen. Our architecture could be ported to
any of today’s virtualization solutions. In the past, many
researchers choose to work with User Mode Linux (UML)
[6], a virtualization solution that allows you to boot a Linux
kernel as a process in a running version of Linux. The ear-
liest work with introspection used VMWare [31], a full fea-
tured commercial virtualization product. Looking forward,
interest is now growing in the kernel-based virtualization
driver (KVM) [24] that is built into the Linux kernel starting
with version 2.6.20. While our techniques are viable on any
of these platforms, a virtualization solution designed as an
independent and lightweight software layer running directly
on the hardware, such as Xen, offers a solid foundation to a
security-oriented solution.
3 Xen Hypervisor Background
The XenAccess monitoring library is based on Xen [4], a
popular open-source virtual machine monitor (VMM). This
section gives an overview of Xen’s architecture, followed
by a discussion of its memory management and block de-
vice I/O subsystems. The discussion of these subsystems
is central to the understanding of XenAccess’ monitoring
components.
3.1 Overview
Xen has traditionally used a paravirtualized approach to
implement virtualization. This technique consists of alter-
ing the guest OSes by replacing sensitive instructions that
cannot be virtualized with special hypercalls, that is, calls
that are made directly to the VMM. This approach has the
advantage of providing good performance, since no trap-
ping is done, and also allowing virtual machines to run on
top of non-virtualizable architectures (such as x86) [25].
Nevertheless, one drawback of paravirtualization is that the
guest OSes must be modiﬁed. Recent versions of Xen have
the capability to run unmodiﬁed OSes by using the new Intel
VT-x and AMD-V technologies. XenAccess uses paravir-
tualized domains without violating property (2) because the
changes required for paravirtualization are not strictly part
of the XenAccess architecture and do not make it any easier
for the target OS to tamper with the monitoring code.
Xen uses a split domain architecture, meaning that reg-
387387
that page of memory. Using this scheme, Xen provides ta-
bles to convert from MFN to PFN and PFN to MFN. These
tables are called M2P and P2M, respectively. Similarly, the
running OSes use a page table (PT) to convert between vir-
tual addresses and machine addresses. Xen protects these
PTs in order to ensure the memory isolation between VMs.
A paravirtualized OS must invoke a hypercall to modify its
PT.
3.3 Device I/O
Xen’s device I/O architecture is based on a split driver
In this model, there is a frontend driver inside
model.
domU’s kernel that communicates with a backend driver in-
side dom0’s kernel. Inter-domain communication relies on
shared asynchronous I/O rings, shared memory pages and a
control framework called XenBus. This architecture is cur-