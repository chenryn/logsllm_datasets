以下是经过优化后的参考文献列表，以确保其更加清晰、连贯和专业：

1. Ishai, Y., Kushilevitz, E., Ostrovsky, R., & Sahai, A. (2009). Extracting correlations. In *50th Annual IEEE Symposium on Foundations of Computer Science* (FOCS'09) (pp. 261-270). IEEE.
2. Ishai, Y., Prabhakaran, M., & Sahai, A. (2008). Founding Cryptography on Oblivious Transfer - Efficiently. In *CRYPTO '08* (pp. 572-591).
3. Ishai, Y., Prabhakaran, M., & Sahai, A. (2009). Secure Arithmetic Computation with No Honest Majority. In *TCC* (pp. 294-314).
4. Jagadeesh, K. A., Wu, D. J., Birgmeier, J. A., Boneh, D., & Bejerano, G. (2017). Deriving genomic diagnoses without revealing patient genomes. *Science*, 357(6352), 692-695.
5. Jayaraman, B., Li, H., & Evans, D. (2017). Decentralized certificate authorities. arXiv preprint arXiv:1706.03370.
6. Jha, S., Kruger, L., & Shmatikov, V. (2008). Towards practical privacy for genomic computation. In *IEEE Symposium on Security and Privacy* (SP 2008) (pp. 216-230). IEEE.
7. Kamm, L., Bogdanov, D., Laur, S., & Vilo, J. (2013). A new way to protect privacy in large-scale genome-wide association studies. *Bioinformatics*, 29(7), 886-893.
8. Kamm, L., & Willemson, J. (2014). Secure floating point arithmetic and private satellite collision analysis. *International Journal of Information Security*, 1-18.
9. Karr, A. F., Lin, X., Sanil, A. P., & Reiter, J. P. (2009). Privacy-preserving analysis of vertically partitioned data using secure matrix products. *Journal of Official Statistics*, 25(1), 125.
10. Katz, J., Malozemoff, A. J., & Wang, X. (2016). Efficiently enforcing input validity in secure two-party computation. Cryptology ePrint Archive, Report 2016/184. https://eprint.iacr.org/2016/184.
11. Keller, M., Orsini, E., & Scholl, P. (2015). Actively secure OT extension with optimal overhead. In *Annual Cryptology Conference* (pp. 724-741). Springer.
12. Kerschbaum, F., Schneider, T., & Schröpfer, A. (2014). Automatic protocol selection in secure two-party computations. In I. Boureanu, P. Owesarski, & S. Vaudenay (Eds.), *Applied Cryptography and Network Security* (pp. 566-584). Springer International Publishing.
13. Kilian, J. (1988). Founding cryptography on oblivious transfer. In *STOC '88* (pp. 20-31). ACM.
14. Kiss, Á., Liu, J., Schneider, T., Asokan, N., & Pinkas, B. (2017). Private set intersection for unequal set sizes with mobile applications. *Proceedings on Privacy Enhancing Technologies*, 2017(4), 177-197.
15. Kolesnikov, V., & Schneider, T. (2008). Improved Garbled Circuit: Free XOR Gates and Applications. In *ICALP '08* (pp. 486-498). Springer-Verlag.
16. Larraia, E. (2014). Extending oblivious transfer efficiently. In *International Conference on Cryptology and Information Security in Latin America* (pp. 368-386). Springer.
17. Lindell, Y., & Pinkas, B. (2009). A Proof of Security of Yao’s Protocol for Two-Party Computation. *Journal of Cryptology*, 22(2), 161-188.
18. Lindell, Y., & Pinkas, B. (2009). Secure Multiparty Computation for Privacy-Preserving Data Mining. *The Journal of Privacy and Confidentiality*, 1(1), 59-98.
19. Liu, C., Wang, X. S., Nayak, K., Huang, Y., & Shi, E. (2015). ObliVM: A programming framework for secure computation. In *IEEE Symposium on Security and Privacy* (SP '15) (pp. 359-376). IEEE Computer Society.
20. Lu, S., & Ostrovsky, R. (2013). How to garble RAM programs. In *EUROCRYPT* (pp. 719-734). Springer.
21. Malkhi, D., Nisan, N., Pinkas, B., & Sella, Y. (2004). Fairplay – A Secure Two-Party Computation System. In *USENIX Security Symposium '04*.
22. Mohassel, P., & Rindal, P. (2018). Aby3: A mixed protocol framework for machine learning. In *ACM SIGSAC Conference on Computer and Communications Security* (CCS '18) (pp. 35-52). ACM.
23. Mood, B., Gupta, D., Carter, H., Butler, K., & Traynor, P. (2016). Frigate: A validated, extensible, and efficient compiler and interpreter for secure computation. In *IEEE European Symposium on Security and Privacy* (Euro S&P) (pp. 112-127).
24. Naor, M., & Pinkas, B. (2006). Oblivious polynomial evaluation. *SIAM Journal on Computing*, 35(5), 1254-1281.
25. Nielsen, J. B., Nordholt, P. S., Orlandi, C., & Burra, S. S. (2012). A new approach to practical active-secure two-party computation. In *CRYPTO 2012* (pp. 681-700). Springer.
26. Nikolaenko, V., Weinsberg, U., Ioannidis, S., Joye, M., Boneh, D., & Taft, N. (2013). Privacy-preserving ridge regression on hundreds of millions of records. In *IEEE Symposium on Security and Privacy* (SP) (pp. 334-348). IEEE.
27. Perry, J., Gupta, D., Feigenbaum, J., & Wright, R. N. (2018). SSC Protocol Comparison Tool. https://code.google.com/archive/p/syssc-ui/. Accessed 2018-06-25.
28. Perry, J., Gupta, D., Feigenbaum, J., & Wright, R. N. (2018). SSC Protocol Comparison Tool. http://work.debayangupta.com/ssc/. Accessed 2018-06-25.
29. Perry, J., Gupta, D., Feigenbaum, J., & Wright, R. N. (2014). Systematizing secure computation for research and decision support. In *International Conference on Security and Cryptography for Networks* (pp. 380-397). Springer.
30. Pinkas, B., Schneider, T., Weinert, C., & Wieder, U. (2018). Efficient circuit-based PSI via cuckoo hashing. In *EUROCRYPT* (pp. 125-157). Springer.
31. Pullonen, P., Bogdanov, D., & Schneider, T. (2012). The design and implementation of a two-party protocol suite for Sharemind 3. *Cybernetica Research Reports T-4-17*.
32. Rabin, M. (1981). How to exchange secrets by oblivious transfer. Technical Report TR-81, Harvard University.
33. Rastogi, A., Hammer, M., & Hicks, M. (2014). Wyvern: A Programming Language for Generic, Mixed-Mode Multiparty Computations. In *IEEE Symposium on Security and Privacy* (SP) (pp. 655-670). IEEE.
34. Rastogi, A., Swamy, N., & Hicks, M. (2017). Wys*: A verified language extension for secure multi-party computations. arXiv preprint arXiv:1711.06467.
35. Microsoft Research. (2016). Simple Encrypted Arithmetic Library (SEAL). https://www.microsoft.com/en-us/research/project/simple-encrypted-arithmetic-library/.
36. Rohloff, K., & Ryan, G. (2016). The PALISADE lattice cryptography library. https://git.njit.edu/palisade/PALISADE.
37. Rotaru, D. (2018). awesome-mpc. https://github.com/rdragos/awesome-mpc.
38. Shamir, A. (1979). How to share a secret. *Communications of the ACM*, 22, 612-613.
39. Shan, Z., Ren, K., Blanton, M., & Wang, C. (2018). Practical secure computation outsourcing: A survey. *ACM Computing Surveys (CSUR)*, 51(2), 31.
40. Songhori, E. M., Hussain, S. U., Sadeghi, A.-R., Schneider, T., & Koushanfar, F. (2015). TinyGarble: Highly Compressed and Scalable Sequential Garbled Circuits. In *IEEE S & P*.
41. Tian, L., Jayaraman, B., Gu, Q., & Evans, D. (2016). Aggregating private sparse learning models using multi-party computation. In *NIPS Workshop on Private Multi-Party Machine Learning*, Barcelona, Spain.
42. Tillich, S., & Smart, N. (2018). Circuits of basic functions suitable for MPC and FHE. https://homes.esat.kuleuven.be/~nsmart/MPC. Accessed 21 June 2018.
43. Van Dijk, M. (1997). Secret key sharing and secret key generation. PhD thesis, Eindhoven University of Technology.
44. Wang, X., Malozemoff, A. J., & Katz, J. (2016). EMP-toolkit: Efficient MultiParty computation toolkit. https://github.com/emp-toolkit.
45. Wang, X., Malozemoff, A. J., & Katz, J. (2017). Faster secure two-party computation in the single-execution setting. In *EUROCRYPT 2017* (pp. 399-424).
46. Wang, X., Ranellucci, S., & Katz, J. (2017). Authenticated garbling and efficient maliciously secure two-party computation. In *ACM SIGSAC Conference on Computer and Communications Security* (CCS '17) (pp. 21-37). ACM.
47. Wang, X., Ranellucci, S., & Katz, J. (2017). Global-scale secure multiparty computation. In *ACM SIGSAC Conference on Computer and Communications Security* (CCS '17) (pp. 39-56). ACM.
48. Wiesner, S. (1983). Conjugate coding. *SIGACT News*, 15(1), 78-88.
49. Yao, A. (1982). Protocols for Secure Computations (Extended Abstract). In *FOCS '82* (pp. 160-164).
50. Yao, A. (1986). How to Generate and Exchange Secrets. In *FOCS '86* (pp. 162-167).
51. Zahur, S., & Evans, D. (2015). Obliv-C: A language for extensible data-oblivious computation. IACR Cryptology ePrint Archive 2015/1153.
52. Zahur, S., Rosulek, M., & Evans, D. (2015). Two halves make a whole. In *Annual International Conference on the Theory and Applications of Cryptographic Techniques* (pp. 220-250). Springer.
53. Zahur, S., Wang, X., Raykova, M., Gascón, A., Doerner, J., Evans, D., & Katz, J. (2016). Revisiting square-root ORAM: efficient random access in multi-party computation. In *IEEE Symposium on Security and Privacy* (SP) (pp. 218-234). IEEE.
54. Zeliadt, N. (2014). Cryptographic methods enable analyses without privacy breaches. *Nature Medicine*, 20(6), 563.
55. Zhang, Y., Blanton, M., & Almashaqbeh, G. (2017). Implementing support for pointers to private data in a general-purpose secure multi-party compiler. *ACM Transactions on Privacy and Security (TOPS)*, 21(2), 6:1-6:34.
56. Zhang, Y., Steele, A., & Blanton, M. (2013). PICCO: A general-purpose compiler for private distributed computation. In *ACM SIGSAC Conference on Computer & Communications Security* (CCS '13) (pp. 813-826). ACM.

### 附录A：内积代码

以下是一些实现内积函数的代码片段。这些代码已经从GitHub上的版本进行了轻微修改，以适应长度。

#### a) EMP-toolkit
示例包含在一个文件中。使用CMake编译为一个可执行文件，由双方运行。
```cpp
void innerprod(int bits, string inputs_a[], string inputs_b[], int len) {
    Integer sum(bits, 0, PUBLIC);
    for (int i = 0; i < len; i++) {
        Integer x = Integer::decode(inputs_a[i], bits, ALICE);
        Integer y = Integer::decode(inputs_b[i], bits, BOB);
        sum += x * y;
    }
    cout << "Inner product: " << sum.reveal() << endl;
}
```

#### b) Obliv-C
示例包含在一个文件中。编译并运行需要几个简短的脚本。
```c
#include <obliv-c.h>
int main() {
    int len = io->input.size;
    obliv_int *v1 = malloc(sizeof(obliv_int) * len);
    obliv_int *v2 = malloc(sizeof(obliv_int) * len);
    feedOblivIntArray(v1, io->input.arr, len, 1);
    feedOblivIntArray(v2, io->input.arr, len, 2);
    obliv_int sum = 0;
    for (int i = 0; i < len; i++) {
        sum += v1[i] * v2[i];
    }
    revealInt(io->result, sum, 0);
}
```

#### c) ObliVM
示例是一个定义安全计算的单个文件。编译和运行需要几个简短的脚本。
```c
int main@n@m(int@n x, int@m y) {
    secure int32[public (n/32)] a;
    secure int32[public (m/32)] b;
    public int32 len = n/32;
    for (public int32 i = 0; i < len; i++) {
        a[i] = x[i];
        b[i] = y[i];
    }
    secure int32 sum = 0;
    for (public int32 i = 0; i < len; i++) {
        sum += a[i] * b[i];
    }
    return sum;
}
```

#### d) SCALE-MAMBA
一个文件定义了安全计算。执行前必须定义加密参数，设置证书颁发机构，并运行脚本来编译和执行程序。
```python
sum = sint(0)
for i in range(3):
    x1 = sint(i)
    x2 = sint(i * 2)
    prod = x1 * x2
    sum = sum + prod
print_ln("%s", sum.reveal())
```

#### e) Sharemind
示例需要一个SecreC文件来定义函数，并可能包括支持输入和输出的文件。执行依赖于所使用的平台，但提供的虚拟机包括编译和执行支持及安全代码的脚本。
```cpp
import shared3p;
domain pd_shared3p shared3p;
void main() {
    pd_shared3p uint64 [[1]] a = argument("a");
    pd_shared3p uint64 [[1]] b = argument("b");
    pd_shared3p uint64 c = sum(a * b);
    publish("c", c);
}
```

#### f) PICCO
示例需要在PICCO的C扩展中定义一个函数，两个配置文件和编码的输入文件。执行是一个多步骤过程：用户必须定义证书并运行几个自定义命令行工具。
```c
public int LEN = 10;
public int main() {
    int A[LEN], B[LEN];
    smcinput(A, 1, LEN);
    smcinput(B, 2, LEN);
    int p = A @ B;
    smcoutput(p, 1);
    return 0;
}
```

#### g) Frigate
示例包含在一个文件中，并通过命令行工具编译。
```c
int result = 0;
for (sint i = 0; i < LEN; i++) {
    result = result + (alice.data[i] * bob.data[i]);
}
output1 = result;
output2 = result;
```

#### h) CBMC-GC
示例包含在一个C文件中，并通过简单的Make系统编译和模拟。
```c
int product = 0;
for (int i = 0; i < LEN; i++) {
    product += INPUT_A.xs[i] * INPUT_B.xs[i];
}
return product;
```

希望这些优化后的参考文献和代码片段对您有所帮助！