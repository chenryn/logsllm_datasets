GNU Readline Library User Interface
Edition 6.1, for Readline Library Version 6.1.
October 2009
Chet Ramey, Case Western Reserve University
Brian Fox, Free Software Foundation
This manual describes the end user interface of the GNU Readline Library (version 6.1,
9 October 2009), a library which aids in the consistency of user interface across discrete
programs which provide a command line interface.
Copyright c⃝ 1988–2009 Free Software Foundation, Inc.
Permission is granted to make and distribute verbatim copies of this manual provided the
copyright notice and this permission notice are preserved on all copies.
Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.3 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with the Front-Cover texts being “A GNU Manual”, and with the Back-Cover
Texts as in (a) below. A copy of the license is included in the section entitled
“GNU Free Documentation License”.
(a) The FSF’s Back-Cover Text is: You are free to copy and modify this GNU
manual. Buying copies from GNU Press supports the FSF in developing GNU
and promoting software freedom.”
Published by the Free Software Foundation
59 Temple Place, Suite 330,
Boston, MA 02111-1307
USA
i
Table of Contents
1
Command Line Editing . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1
Introduction to Line Editing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2
Readline Interaction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2.1
Readline Bare Essentials. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2.2
Readline Movement Commands. . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2.3
Readline Killing Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2.4
Readline Arguments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2.5
Searching for Commands in the History. . . . . . . . . . . . . . . . . . . . 3
1.3
Readline Init File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.1
Readline Init File Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.3.2
Conditional Init Constructs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3.3
Sample Init File. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.4
Bindable Readline Commands. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.4.1
Commands For Moving. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.4.2
Commands For Manipulating The History . . . . . . . . . . . . . . . . 13
1.4.3
Commands For Changing Text . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.4.4
Killing And Yanking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.4.5
Specifying Numeric Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.4.6
Letting Readline Type For You. . . . . . . . . . . . . . . . . . . . . . . . . . . 17
1.4.7
Keyboard Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.4.8
Some Miscellaneous Commands . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.5
Readline vi Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
Appendix A
GNU Free Documentation License
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
Chapter 1: Command Line Editing
1
1 Command Line Editing
This chapter describes the basic features of the gnu command line editing interface.
1.1 Introduction to Line Editing
The following paragraphs describe the notation used to represent keystrokes.
The text C-k is read as ‘Control-K’ and describes the character produced when the k
key is pressed while the Control key is depressed.
The text M-k is read as ‘Meta-K’ and describes the character produced when the Meta
key (if you have one) is depressed, and the k key is pressed. The Meta key is labeled ALT
on many keyboards. On keyboards with two keys labeled ALT (usually to either side of the
space bar), the ALT on the left side is generally set to work as a Meta key. The ALT key on
the right may also be conﬁgured to work as a Meta key or may be conﬁgured as some other
modiﬁer, such as a Compose key for typing accented characters.
If you do not have a Meta or ALT key, or another key working as a Meta key, the identical
keystroke can be generated by typing ESC ﬁrst, and then typing k. Either process is known
as metafying the k key.
The text M-C-k is read as ‘Meta-Control-k’ and describes the character produced by
metafying C-k.
In addition, several keys have their own names. Speciﬁcally, DEL, ESC, LFD, SPC, RET,
and TAB all stand for themselves when seen in this text, or in an init ﬁle (see Section 1.3
[Readline Init File], page 4). If your keyboard lacks a LFD key, typing C-j will produce the
desired character. The RET key may be labeled Return or Enter on some keyboards.
1.2 Readline Interaction
Often during an interactive session you type in a long line of text, only to notice that the
ﬁrst word on the line is misspelled. The Readline library gives you a set of commands for
manipulating the text as you type it in, allowing you to just ﬁx your typo, and not forcing
you to retype the majority of the line. Using these editing commands, you move the cursor
to the place that needs correction, and delete or insert the text of the corrections. Then,
when you are satisﬁed with the line, you simply press RET. You do not have to be at the end
of the line to press RET; the entire line is accepted regardless of the location of the cursor
within the line.
1.2.1 Readline Bare Essentials
In order to enter characters into the line, simply type them. The typed character appears
where the cursor was, and then the cursor moves one space to the right. If you mistype a
character, you can use your erase character to back up and delete the mistyped character.
Sometimes you may mistype a character, and not notice the error until you have typed
several other characters. In that case, you can type C-b to move the cursor to the left, and
then correct your mistake. Afterwards, you can move the cursor to the right with C-f.
When you add text in the middle of a line, you will notice that characters to the right
of the cursor are ‘pushed over’ to make room for the text that you have inserted. Likewise,
when you delete text behind the cursor, characters to the right of the cursor are ‘pulled
Chapter 1: Command Line Editing
2
back’ to ﬁll in the blank space created by the removal of the text. A list of the bare essentials
for editing the text of an input line follows.
C-b
Move back one character.
C-f
Move forward one character.
DEL or Backspace
Delete the character to the left of the cursor.
C-d
Delete the character underneath the cursor.
Printing characters
Insert the character into the line at the cursor.
C-_ or C-x C-u
Undo the last editing command. You can undo all the way back to an empty
line.
(Depending on your conﬁguration, the Backspace key be set to delete the character to the
left of the cursor and the DEL key set to delete the character underneath the cursor, like
C-d, rather than the character to the left of the cursor.)
1.2.2 Readline Movement Commands
The above table describes the most basic keystrokes that you need in order to do editing of
the input line. For your convenience, many other commands have been added in addition
to C-b, C-f, C-d, and DEL. Here are some commands for moving more rapidly about the
line.
C-a
Move to the start of the line.
C-e
Move to the end of the line.
M-f
Move forward a word, where a word is composed of letters and digits.
M-b
Move backward a word.
C-l
Clear the screen, reprinting the current line at the top.
Notice how C-f moves forward a character, while M-f moves forward a word. It is a loose
convention that control keystrokes operate on characters while meta keystrokes operate on
words.
1.2.3 Readline Killing Commands
Killing text means to delete the text from the line, but to save it away for later use, usually
by yanking (re-inserting) it back into the line. (‘Cut’ and ‘paste’ are more recent jargon for
‘kill’ and ‘yank’.)
If the description for a command says that it ‘kills’ text, then you can be sure that you
can get the text back in a diﬀerent (or the same) place later.
When you use a kill command, the text is saved in a kill-ring. Any number of consecutive
kills save all of the killed text together, so that when you yank it back, you get it all. The
kill ring is not line speciﬁc; the text that you killed on a previously typed line is available
to be yanked back later, when you are typing another line.
Here is the list of commands for killing text.
Chapter 1: Command Line Editing
3
C-k
Kill the text from the current cursor position to the end of the line.
M-d
Kill from the cursor to the end of the current word, or, if between words, to the
end of the next word. Word boundaries are the same as those used by M-f.
M-DEL
Kill from the cursor the start of the current word, or, if between words, to the
start of the previous word. Word boundaries are the same as those used by
M-b.
C-w
Kill from the cursor to the previous whitespace. This is diﬀerent than M-DEL
because the word boundaries diﬀer.
Here is how to yank the text back into the line.
Yanking means to copy the most-
recently-killed text from the kill buﬀer.
C-y
Yank the most recently killed text back into the buﬀer at the cursor.
M-y
Rotate the kill-ring, and yank the new top. You can only do this if the prior
command is C-y or M-y.
1.2.4 Readline Arguments
You can pass numeric arguments to Readline commands. Sometimes the argument acts
as a repeat count, other times it is the sign of the argument that is signiﬁcant. If you
pass a negative argument to a command which normally acts in a forward direction, that
command will act in a backward direction. For example, to kill text back to the start of
the line, you might type ‘M-- C-k’.
The general way to pass numeric arguments to a command is to type meta digits before
the command. If the ﬁrst ‘digit’ typed is a minus sign (‘-’), then the sign of the argument
will be negative. Once you have typed one meta digit to get the argument started, you
can type the remainder of the digits, and then the command. For example, to give the C-d
command an argument of 10, you could type ‘M-1 0 C-d’, which will delete the next ten
characters on the input line.
1.2.5 Searching for Commands in the History
Readline provides commands for searching through the command history for lines containing
a speciﬁed string. There are two search modes: incremental and non-incremental.
Incremental searches begin before the user has ﬁnished typing the search string. As each
character of the search string is typed, Readline displays the next entry from the history
matching the string typed so far. An incremental search requires only as many characters as
needed to ﬁnd the desired history entry. To search backward in the history for a particular
string, type C-r. Typing C-s searches forward through the history. The characters present
in the value of the isearch-terminators variable are used to terminate an incremental
search. If that variable has not been assigned a value, the ESC and C-J characters will
terminate an incremental search.
C-g will abort an incremental search and restore the
original line. When the search is terminated, the history entry containing the search string
becomes the current line.
To ﬁnd other matching entries in the history list, type C-r or C-s as appropriate. This
will search backward or forward in the history for the next entry matching the search string
typed so far. Any other key sequence bound to a Readline command will terminate the
Chapter 1: Command Line Editing
4
search and execute that command. For instance, a RET will terminate the search and accept
the line, thereby executing the command from the history list. A movement command will
terminate the search, make the last line found the current line, and begin editing.
Readline remembers the last incremental search string. If two C-rs are typed without
any intervening characters deﬁning a new search string, any remembered search string is
used.
Non-incremental searches read the entire search string before starting to search for
matching history lines.
The search string may be typed by the user or be part of the
contents of the current line.
1.3 Readline Init File
Although the Readline library comes with a set of Emacs-like keybindings installed by
default, it is possible to use a diﬀerent set of keybindings. Any user can customize programs
that use Readline by putting commands in an inputrc ﬁle, conventionally in his home
directory. The name of this ﬁle is taken from the value of the environment variable INPUTRC.
If that variable is unset, the default is ‘~/.inputrc’. If that ﬁle does not exist or cannot
be read, the ultimate default is ‘/etc/inputrc’.
When a program which uses the Readline library starts up, the init ﬁle is read, and the
key bindings are set.
In addition, the C-x C-r command re-reads this init ﬁle, thus incorporating any changes
that you might have made to it.
1.3.1 Readline Init File Syntax
There are only a few basic constructs allowed in the Readline init ﬁle. Blank lines are
ignored. Lines beginning with a ‘#’ are comments. Lines beginning with a ‘$’ indicate
conditional constructs (see Section 1.3.2 [Conditional Init Constructs], page 10).
Other
lines denote variable settings and key bindings.
Variable Settings
You can modify the run-time behavior of Readline by altering the values of
variables in Readline using the set command within the init ﬁle. The syntax
is simple:
set variable value
Here, for example, is how to change from the default Emacs-like key binding to
use vi line editing commands:
set editing-mode vi
Variable names and values, where appropriate, are recognized without regard
to case. Unrecognized variable names are ignored.
Boolean variables (those that can be set to on or oﬀ) are set to on if the value is
null or empty, on (case-insensitive), or 1. Any other value results in the variable
being set to oﬀ.
A great deal of run-time behavior is changeable with the following variables.
bell-style
Controls what happens when Readline wants to ring the termi-