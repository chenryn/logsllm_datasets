# GNU Readline Library User Interface
## Edition 6.1, for Readline Library Version 6.1
### October 2009
#### Authors:
- Chet Ramey, Case Western Reserve University
- Brian Fox, Free Software Foundation

This manual provides a comprehensive guide to the end-user interface of the GNU Readline Library (version 6.1, released on 9 October 2009). The library is designed to ensure a consistent user interface across various programs that offer a command-line interface.

**Copyright © 1988–2009 Free Software Foundation, Inc.**

Permission is granted to make and distribute verbatim copies of this manual, provided that the copyright notice and this permission notice are preserved on all copies.

Additionally, you may copy, distribute, and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation, with no Invariant Sections, with the Front-Cover texts being “A GNU Manual,” and with the Back-Cover Texts as specified in (a) below. A copy of the license is included in the section entitled "GNU Free Documentation License."

(a) The FSF’s Back-Cover Text: "You are free to copy and modify this GNU manual. Buying copies from GNU Press supports the FSF in developing GNU and promoting software freedom."

**Published by:**
Free Software Foundation  
59 Temple Place, Suite 330  
Boston, MA 02111-1307  
USA

---

## Table of Contents
1. Command Line Editing
   1.1. Introduction to Line Editing
   1.2. Readline Interaction
      1.2.1. Readline Bare Essentials
      1.2.2. Readline Movement Commands
      1.2.3. Readline Killing Commands
      1.2.4. Readline Arguments
      1.2.5. Searching for Commands in the History
   1.3. Readline Init File
      1.3.1. Readline Init File Syntax
      1.3.2. Conditional Init Constructs
      1.3.3. Sample Init File
   1.4. Bindable Readline Commands
      1.4.1. Commands For Moving
      1.4.2. Commands For Manipulating The History
      1.4.3. Commands For Changing Text
      1.4.4. Killing And Yanking
      1.4.5. Specifying Numeric Arguments
      1.4.6. Letting Readline Type For You
      1.4.7. Keyboard Macros
      1.4.8. Some Miscellaneous Commands
   1.5. Readline vi Mode
2. Appendix A: GNU Free Documentation License

---

## Chapter 1: Command Line Editing

### 1.1. Introduction to Line Editing

The following paragraphs describe the notation used to represent keystrokes:

- `C-k` is read as ‘Control-K’ and describes the character produced when the `k` key is pressed while the Control key is depressed.
- `M-k` is read as ‘Meta-K’ and describes the character produced when the Meta key (labeled ALT on many keyboards) is depressed, and the `k` key is pressed. If your keyboard has two ALT keys, the left one is typically configured as the Meta key.
- If you do not have a Meta or ALT key, the identical keystroke can be generated by typing `ESC` followed by `k`. This process is known as metafying the `k` key.
- `M-C-k` is read as ‘Meta-Control-k’ and describes the character produced by metafying `C-k`.

Additionally, several keys have their own names. Specifically, `DEL`, `ESC`, `LFD`, `SPC`, `RET`, and `TAB` all stand for themselves when seen in this text or in an init file. If your keyboard lacks a `LFD` key, typing `C-j` will produce the desired character. The `RET` key may be labeled `Return` or `Enter` on some keyboards.

### 1.2. Readline Interaction

During an interactive session, you often type a long line of text only to notice that the first word is misspelled. The Readline library provides a set of commands for manipulating the text, allowing you to correct typos without retyping the entire line. You can move the cursor to the place that needs correction, delete or insert the text, and then press `RET` to accept the line. The cursor does not need to be at the end of the line to press `RET`; the entire line is accepted regardless of the cursor's position.

#### 1.2.1. Readline Bare Essentials

To enter characters into the line, simply type them. The typed character appears where the cursor was, and the cursor moves one space to the right. If you mistype a character, use your erase character to back up and delete the mistyped character. To move the cursor, use the following commands:

- `C-b`: Move back one character.
- `C-f`: Move forward one character.
- `DEL` or `Backspace`: Delete the character to the left of the cursor.
- `C-d`: Delete the character underneath the cursor.
- Printing characters: Insert the character into the line at the cursor.
- `C-_` or `C-x C-u`: Undo the last editing command. You can undo all the way back to an empty line.

(Note: Depending on your configuration, the `Backspace` key may delete the character to the left of the cursor, and the `DEL` key may delete the character underneath the cursor, like `C-d`.)

#### 1.2.2. Readline Movement Commands

In addition to the basic keystrokes, Readline provides commands for moving more rapidly about the line:

- `C-a`: Move to the start of the line.
- `C-e`: Move to the end of the line.
- `M-f`: Move forward a word, where a word is composed of letters and digits.
- `M-b`: Move backward a word.
- `C-l`: Clear the screen, reprinting the current line at the top.

Note how `C-f` moves forward a character, while `M-f` moves forward a word. It is a loose convention that control keystrokes operate on characters, while meta keystrokes operate on words.

#### 1.2.3. Readline Killing Commands

Killing text means deleting it from the line but saving it for later use, usually by yanking (re-inserting) it back into the line. (‘Cut’ and ‘paste’ are more recent jargon for ‘kill’ and ‘yank’.)

- `C-k`: Kill the text from the current cursor position to the end of the line.
- `M-d`: Kill from the cursor to the end of the current word, or, if between words, to the end of the next word. Word boundaries are the same as those used by `M-f`.
- `M-DEL`: Kill from the cursor to the start of the current word, or, if between words, to the start of the previous word. Word boundaries are the same as those used by `M-b`.
- `C-w`: Kill from the cursor to the previous whitespace. This is different than `M-DEL` because the word boundaries differ.

To yank the text back into the line:

- `C-y`: Yank the most recently killed text back into the buffer at the cursor.
- `M-y`: Rotate the kill-ring, and yank the new top. You can only do this if the prior command is `C-y` or `M-y`.

#### 1.2.4. Readline Arguments

You can pass numeric arguments to Readline commands. Sometimes the argument acts as a repeat count, and other times it is the sign of the argument that is significant. If you pass a negative argument to a command that normally acts in a forward direction, the command will act in a backward direction. For example, to kill text back to the start of the line, you might type `M-- C-k`.

The general way to pass numeric arguments to a command is to type meta digits before the command. If the first 'digit' typed is a minus sign (`-`), then the sign of the argument will be negative. Once you have typed one meta digit to get the argument started, you can type the remainder of the digits, and then the command. For example, to give the `C-d` command an argument of 10, you could type `M-1 0 C-d`, which will delete the next ten characters on the input line.

#### 1.2.5. Searching for Commands in the History

Readline provides commands for searching through the command history for lines containing a specified string. There are two search modes: incremental and non-incremental.

- **Incremental Searches**: Begin before the user has finished typing the search string. As each character of the search string is typed, Readline displays the next entry from the history matching the string typed so far. An incremental search requires only as many characters as needed to find the desired history entry. To search backward in the history for a particular string, type `C-r`. Typing `C-s` searches forward through the history. The characters present in the value of the `isearch-terminators` variable are used to terminate an incremental search. If that variable has not been assigned a value, the `ESC` and `C-J` characters will terminate an incremental search. `C-g` will abort an incremental search and restore the original line. When the search is terminated, the history entry containing the search string becomes the current line. To find other matching entries in the history list, type `C-r` or `C-s` as appropriate. Any other key sequence bound to a Readline command will terminate the search and execute that command. For instance, a `RET` will terminate the search and accept the line, thereby executing the command from the history list. A movement command will terminate the search, make the last line found the current line, and begin editing. Readline remembers the last incremental search string. If two `C-r`s are typed without any intervening characters defining a new search string, any remembered search string is used.
- **Non-incremental Searches**: Read the entire search string before starting to search for matching history lines. The search string may be typed by the user or be part of the contents of the current line.

### 1.3. Readline Init File

Although the Readline library comes with a set of Emacs-like keybindings installed by default, it is possible to use a different set of keybindings. Any user can customize programs that use Readline by putting commands in an `inputrc` file, conventionally located in their home directory. The name of this file is taken from the value of the environment variable `INPUTRC`. If that variable is unset, the default is `~/.inputrc`. If that file does not exist or cannot be read, the ultimate default is `/etc/inputrc`.

When a program that uses the Readline library starts up, the init file is read, and the key bindings are set. Additionally, the `C-x C-r` command re-reads this init file, incorporating any changes that you might have made to it.

#### 1.3.1. Readline Init File Syntax

There are only a few basic constructs allowed in the Readline init file. Blank lines are ignored. Lines beginning with a `#` are comments. Lines beginning with a `$` indicate conditional constructs (see Section 1.3.2 [Conditional Init Constructs], page 10). Other lines denote variable settings and key bindings.

**Variable Settings**

You can modify the run-time behavior of Readline by altering the values of variables in Readline using the `set` command within the init file. The syntax is simple:

```
set variable value
```

For example, to change from the default Emacs-like key binding to use vi line editing commands:

```
set editing-mode vi
```

Variable names and values, where appropriate, are recognized without regard to case. Unrecognized variable names are ignored. Boolean variables (those that can be set to `on` or `off`) are set to `on` if the value is null or empty, `on` (case-insensitive), or `1`. Any other value results in the variable being set to `off`.

A great deal of run-time behavior is changeable with the following variables:

- `bell-style`: Controls what happens when Readline wants to ring the terminal bell.