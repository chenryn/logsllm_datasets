---
## Page 246
它都会创建一个新的符号。这样：
形式并被转化成符号，但这些符号还没有进入任何包，每当读取器读到一个带有“#：”的名字时，
名字中不包含前导冒号。
时，它们求值到自身。这样：
键字符号在书写上以一个冒号开始。这类符号在名为KEYWORD的包中创建并自动导出。更进一步，
需等待该包的下一个版本的发布即可完成手头的工作。
者可能忽略了导出一个确实应当开放给公众的符号。在这种情况下，含双冒号的名字可以让你无
是公开的而哪些名字是私有的约定，那么在使用时肯定会遇到麻烦。另一方面，有时一个包的作
是个好主意—导出符号的集合定义了一个包的公共接口，而如果你不遵守包作者关于哪些名字
出，那么读取器会产生一个错误。含双冒号的名字可以指向命名包中的任何符号，尽管这通常不
为公共接口来使用的符号。如果命名的包不含有一个给定名字的符号，或是含有该符号但并未导
符号名转化成一个符号对象。
号处拆开，前一部分作为包的名字，后一部分作为符号的名字。读取器查找适当的包并用它来将
形式时返回了相同的符号。
个特定的hello-wor1d函数的原因就在于,读取器在读取对该函数的调用和定义该函数的DEFUN
数所指向的函数、变量或其他程序元素。因此，诸如(hello-world)这样的表达式得以调用一
它都将得到相同的符号对象。这是很重要的，因为求值器使用符号的对象标识来决定一个给定函
INTERN，从而将该名字转化成一个符号。这样，每当读取器读到相同的包里面相同的名字时，
这样的名字时，它先将名字中所有未转义的字母转换成大写形式，然后将得来的字符串传给
到包里。
NIL。INTERN也会返回一个已有的符号，否则它会创建一个以该字符串命名的新符号并将其添加
只含单冒号的名字必须指向-个外部符号（extermal symbol）—一个被包导出（export）作
含有单冒号或双冒号的名字是包限定的名字。当读取器读取包限定的名字时，它将名字在冒
你所使用的大多数名字都是非限定的（ungualified)，就是说名字里不带冒号。当读取器读到
未进入的符号在写法上以“#：”开始。这些名字（在去掉“#：”后）被正常地转换成大写
和所有符号一样，关键字符号的名字在它们被创建之前就被读取器全部转换成大写形式了。
FIND-SYMBOL在包中查找名为给定字符串的符号并将其返回，如果没有找到任何符号则返回
一般不需要自行书写这种语法，但有时当你打印一个含有由GENSYM所返回的符号的S-表达
(eql'#:foo‘#:foo）→NIL
(symbol-name :foo)→"Foo"
(eql':foo :foo) → T
www.TopSage.com
21.1
读取器是如何使用包的
229
---
## Page 247
出、隐蔽和导人符号。不过首先让我们看一些你已经在使用的包。最初启动Lisp时，*PACKAGE*
21.3·三个标准包
号称为未进入（uninterned）的符号，它不能被读取器读取，并且将采用#：foo语法进行打印。
并且如果它是一个隐蔽符号，也会被清除出隐蔽符号列表。你可能想让一个符号从一个包中退出
中一个符号必须导人该包，以便可添加到该包的隐蔽符号列表并使另一个符号成为不可访问的
被导出或是成为隐蔽符号。举个例子，如果一个包需要使用两个带有同名外部符号的包，那么其
包中可以直接访问而无需使用它们的主包。其他时候，导入符号则是因为只有存在的符号才可以
包。这样，同一个符号可以同时存在于多个包中。有时，导入符号只是因为希望它们在被导入的
的名字-符号列表之外维护了一个隐蔽符号的列表。
为隐蔽（shadow）符号来解决冲突，这可以使其他同名的符号变得不可访问。每一个包都在它们
号。这就是说，一个包不能同时有一个本身定义的符号和一个同名的继承得来的符号，或是同时
符号以外，还可以使其能够通过带有单冒号的限定名称来引用，如同你在上一节里所看到的那样。
过在包中导出（export）一个符号来使其成为外部符号。导出操作除了可以使包的其他使用者继承
其他包来继承这些包中的符号。在被使用的包中，只有外部（extemal）符号才能被继承。可以通
到包的名字-符号表中。该符号首先停留的包称作该符号的主包（home package)。
时我们称该符号存在（present）于该包中。当读取器让一个新符号进入一个包时，该符号会添加
(accessible)。换句话说，一个包中可访问的符号是，该包为当前包时非限定名字指向的符号。
定名字可以访问一个符号。为了更有意义地谈论这些方法，你需要了解一些词汇表。
上，每一个包都含有一个从名字到符号的查找表，但还有其他几种方式通过一个给定包中的非限
21.2
式时就会看到它。
从而消除该符号和一个来自你想使用的包中的外部符号之间的冲突。一个不存在于任何包中的符
从不同的包中继承两个具有相同名字的不同符号。不过，你可以通过使其中一个可访问的符号成
最后，一个已有的符号可以从一个包中退出（uninterm），这会导致它被清除出名字-符号表
另一种方式是当某个包继承一个符号时,该符号在该包中就是可访问的。一个包通过使用(use)
可以通过两种方式访问一个符号。前一种方式要求包的名字-符号表中含有该符号的项，这
首先，所有可在一个给定包中通过FIND-SYMBOL找到的符号被称为在该包中是可访问的
230
一个已有的符号可以通过将其添加到另一个包的名字-符号表中，来导入（import）到这个
为了保证从名字到符号的映射的确定性，包系统只允许每个名字在给定的包中指向单一符
在下--节里，我将向你展示如何定义你自己的包，包括如何让一个包使用另一个包，如何导
如同我先前提到的，包所实现的从名字到符号的映射比简单的查找表更加灵活。在核心层面
(gensym)→ #:G3128
包和符号相关的术语
第 21章编写大型程序：包和符号
www.TopSage.com
---
## Page 248
可以使用显式的包限定方式来引用任何关键字符号：
写出类似下面的代码：
COMMON-LISP的所有符号。?通常情况下，你定义的所有包都将使用COMMON-LISP，因此不需要
USER是作为一个“模板”包来提供的，在其中你可以创建自己的名字，同时还能轻松地访问
USER中的符号来读取。
那么读取器将把DEFVAR作为COMMON-LISP中的符号来读取，同时把*X*作为COMMON-LISP-
甚至可以使用COMMON-LISP的昵称CL：
查看*PACKAGE*的值，可以输入：
COMMON-LISP-USER包中。例如，名字*PACKAGE*是从COMMON-LISP包中导出的，如果你想要
数、宏、变量之类的名字都将转化成从COMMON-LISP包中导出的符号，而其他名字进人到
后者导出了语言标准定义的所有名字。因此，当在REPL中键入一个表达式时，所有诸如标准函
的值通常是COMMON-LISP-USER包，有时也叫做CL-USER。?CL-USER使用了包COMMON-LISP,
REPL不能在COMMON-LISP包中启动，因为你不能在这个包中添加新符号。COMMON-LISP-
② COMMON-LISP-USER也允许提供对由从其他语言实现所定义的包导出的符号的访问。尽管这在本意上是为了给
① 每一个包都有一个正式名字以及零个或多个昵称（nickname），昵称可用在任何需要用到包名的地方，例如带有
第三个标准包是KEYWORD包，这个包被Lisp读取器用来创建以冒号开始的名字。这样，你也
(cl:defun (x) (cl:+ x 2))
但是*X*不是COMMON-LISP中的符号，因此如果你输入：
CL-USER> cl:*package*
 #
 CL-USER> common-lisp:*package*
包限定的名字，或是在一个DEFPACRAGE或IN-PACKAGB形式中引用那个包。
#
#
CL-USER> *package*
继承自实现定义的包的符号将返回一些其他的值。
package-name (symbol-package 
司时把some-symbol替换成你想要的符号。
package-name (symbol-package
而要想查出一个符号最初来源于哪个包，可以求值下列表达式：
mapcar #'package-name
以在REPL中求值下列表达式：
语言标准并未涉及的符号名。要想看到在一个特定的实现中COMMON-LISP-USER都从哪些包中继承了符号，可
用户提供方便一
www.TopSage.com
'car))
'some-symbol))
例如：
"HSN-SIT-NOWWOD：（
→"COMMON-LISP"
21.3三个标准包
231
---
## Page 249
而无需担心和不相关的代码产生命名冲突。因此你最好用DEFPACKAGE定义一个新的包。
查看如何组织用于这样一个程序的包。
下描述所有有关的选项。这个程序是完全假想出来的，包括我将引用的其他库在内。要点在于,
他包里导人什么符号，还可以创建隐蔽符号来解决冲突。
DEFPACKAGE来定义新的包，在创建包的同时还能指定它使用哪些包，导出哪些包，以及它从其
些名字如何被使用。
导出是没有意义的。你可以导出符号以便特定的名字更加易于访问，但包系统并不允许你限制这
变量或其他任何东西的名字时，包机制就无能为力了。因此，谈论把一个函数或变量从一个包中
制读取器将文本名字转换成符号对象来完成的。但在后面求值器中，当符号被解释成一个函数、
以调用什么函数或访问什么变量的直接控制。它们只提供对于名字空间的基本控制，这是通过控
的符号。
而当你编写可能用于不同环境中的库时，你会想要定义分开的包并导出那些构成了库的公共API
序就会需要定义新的包，这样不同的程序可以加载到同一个Lisp环境中，而不会破坏彼此的名字。
21.4定义你自己的包
下的简单包：
如果应用程序写得足够简单，没有用到超出语言本身所能提供的库，那么你可以定义一个如
尽管如此，在开始定义包之前，理解包无法做到的一件事是很重要的。包无法提供对于谁可
232
②DEFPACKAGE进行的所有处理也都可以通过管理包对象的函数来完成。尽管如此，由于一个包在通常情况下都要
① 这与Java的包系统不同，Java的包系统在提供类的名字空间的同时还引l入了Java的访问控制机制。非Lisp语言中包
所需的第一个包是提供了整个应用程序命名空间的包，你需要命名你的函数、变量，等等，
假设你正在使用包来编写一个将E-mail消息组织进一个可搜索数据库的程序，我将在此背景
记住上述这件事，你可以开始学习如何定义包并将它们捆绑在一起了。你可以通过宏
使用COMMON-LISP-USER包对于在REPL中进行尝试是好的，不过一旦你开始编写实际的程
系统最接近Common Lisp的语言是Perl。
这段代码定义了一个包，名为COM.GIGAMONKEYS.EMAIL-DB，其继承了由COMMON-LISP包
(defpackage :com.gigamonkeys.email-db
CL-USER>
CL-USER> keyword:a
CL-USER> :a
作。例如，DEFPACRAGE可以在使用那些用到的包之前将有关符号添加到隐蔽符号列表中。
在使用前被完全定义，所以这些函数很少用到。另外，DEFPACKAGE可以采用正确的顺序来完成所有的包管理操
(:use :common-1isp))
第21章编写大型程序：包和符号
(eql :a keyword:a)
www.TopSage.com
---
## Page 250
与先前定义在cOMMON-LISP-USER中的函数共存的hello-wor1d函数。这是已有函数的行为：
字以外，你几乎可以使用任何你想要使用的名字来实现任何目的。这样，你可以定义一个新的、
件中后续表达式的读取方式。
或COMPILE-FILE编译的文件中包含了一个IN-PACKAGE，那么它将改变当时的包，从而影响文
式的方式，直到你通过另一个IN-PACKAGE调用来改变它。类似地，如果你在用LOAD加载的文件
后你试图使用该包时带来问题。
形式的操作将使这些符号进人到当前的包中，这在某种程度上泄露了名字空间，并可能也会在以
式。事实上，由于读取器的大小写转换约定，多数符号和包真正的名字都是大写的。
将把名字转换成大写形式。也可以用字符串来书写DEFPACKAGE，若这样就需要全部使用大写形
面的DEFPACKAGE那样使用关键字符号，是一种允许把名字书写成小写字母的常用风格，读取器
自身；要么是一个符号，代表其名字，要么是一个字符，代表一个含有该字符的单字符串。像上
串描述符（string designator）来指定包和符号的名字。字符串描述符要么是一个字符串，代表其
几种表示方法。包和符号都是用字符串来命名的。不过，在DEFPACKAGE形式中，可以使用字符
导出的所有符号。
①在许多Lisp实现里，如果你只是使用COMMON-LISP包，那么：use子句是可选的。如果省略了它，包将自动从一
通过将当前包设置为COM.GIGAMONKEYS.EMAIL-DB包，除了那些继承自COMMON-LISP的名
?
②
如果你在REPL中输人这个表达式，它将改变*PACKAGE*的值，从而影响REPL读取后续表达
为了读取这个包中的代码，你需要使用IN-PACKAGE宏来使其成为当前包：
你也可以使用非关键字符号一
NIL
hello,world
CL-USER>(hello-world)
(in-package:com.gigamonkeys.email-db)
(defpackage"COM.GIGAMONKEYS.EMAIL-DB"
FILE编译时和文件加载时都会执行的代码，从而在编译期就可以改变读取器读取文件其余部分的方式。
使用IN-PACKAGE而不是仅仅用SETF来修改*PACKAGE*的原因在于，IN-PACKAGE可以展开成在文件被COMPILE-
归结为美学范畴。
内存，在DEFPACKAGB通过它实现（或代码展开）之后，符号会变成垃圾。然而，差异是如此微小，以至于这被
一些人使用“#：”语法的未进入的符号来代替关键字符号。这通过在关键字包中未进入任何符号来节省一小部分
来编写DEFPACKAGE形式，那么它将可以同时工作在CommonLisp和与之相近的另一种模式下。
种Lisp并不符合CommonLisp标准，因为所有标准中定义的名字都是被定义成大写的。但如果你使用关键字符号
并且在带有大写名称的coMMON-LISP包以外，它还提供了一个使用小写字母的common-lisp包。严格来讲，这
使用关键字来代替字符串还有另一个优点：Allegro支持一种“现代模式”的Lisp，其中读取器并不做大小写转换。
而将其写成（：use：cl）。
地指定你想要使用的包列表，那么代码将会变得更加具有可移植性。那些不愿意打字的人可以使用包的昵称，从
个由具体实现所定义的包列表中继承名字，而这个包列表通常都包括COMMON-LISP。尽管如此，如果总是显式
（:USe"COMMON-LISP"）)
-DEFPACKAGE中的名字不会被求值，但是随后读取DEFPACKAGE
www.TopSage.com
C
?
---
## Page 251
的包直接访问。因此，在定义了这个包以后，你可以将主应用程序包的定义作如下改变：
数。：export子句指定了COM.GIGAMONKEYS.TEXT-DB外部的名字，这些名字可以被所有使用它
义一个新的包，这次将导出一些特定的名字，从而使其对于其他包可见。
函数。你可能意识到这些函数会对其他程序有用，并且决定将它们重新打包成一个库。你应当定
21.5打包可重用的库
旧的函数行为没有被干扰：
然后用如下方式测试它：
环境，但在SLIME中默认提示符由包名的简化版本构成。