Service  such  as  debit  account,  and  other  dynamic 
constraints can come into effect such as contexts. 
Fig. 5. Enforcing SOD in a banking application 
client.       
Within the frameworks of this case study, we carried 
out early performance measurements. In particular, we 
measured  the  time  for  executing  access  requests  from 
the Application Client to the Application Web Service. 
For this purpose, we configured an RBAC system with 
50  users  and  10  roles.  The  interceptor  runs  on  a 
Pentium IV, 2 GHz, and the Authorization Engine on a 
Pentium  M,  1.6  GHz.  Executing  1000  random  access 
requests  such  as  debit/credit  account,  we  obtained  an 
average  latency  time  of  about  86  ms  per  access 
(compared  to  14  ms  per  access  without  using  our 
framework).  This  way,  an  access  request  is  about  six 
times  slower  than  an  ordinary  Web  Service  request 
without employing our authorization framework. 
Our  authorization  framework,  however,  can  be 
configured  in  a  way  that  only  security-critical  access 
requests are guided through our framework (cf. Section 
3.1).  Other  requests  need  not  be  intercepted,  i.e., 
functionality  which  is  not  security-critical  is  exported 
directly by the Application Web Service and not by the 
interceptor.  Remember 
the 
Application  Web  Service  interface  is  designed  by  a 
domain  expert  who  knows  which  functionality  is 
security-critical and which not. 
that  we  assume 
that 
5.2. Lattice-based access control policies 
Our  authorization  framework can also be employed 
for  implementing  lattice-based  access  control  (LBAC) 
policies  [24].  LBAC  has  specifically  been  used  in 
military, but it sometimes has also been implemented in 
large enterprises [25]. Although LBAC is an old access 
control  model,  we  use  it  here  to  demonstrate  the 
flexibility of the authorization engine component of our 
authorization framework.  
As shown by Sandhu [26], RBAC can be configured 
to  simulate  LBAC  policies  by  forming  two  dual  role-
hierarchies  (one  for  the  read  roles,  and  the  other  one 
264264
for  the  write  roles)  and  by  defining  authorization 
constraints  on  the  RBAC  relations.  In  particular,  a 
security label x is then represented by two roles xR and 
xW  with  xR  the  appropriate  read  role  and  xW  the 
appropriate write role. For the sake of brevity, we leave 
out here the details of this construction.  
We  now  discuss  an  LBAC  policy  with  n  security 
labels l1, …, ln. In order to employ the USE system for 
implementing  LBAC,  we  first  express  LBAC  in  OCL. 
To give an impression, how the OCL version of LBAC 
looks  like,  we  here  give  one  of  the  authorization 
constraints  used  by  Sandhu;  the  other  constraints  of 
Sandhu’s  construction  can  be  expressed similarly. The 
constraint states that each session has exactly two roles 
xR and xW and means that the user has logged in at the 
security  level  x.  For  this  purpose,  we  define  two  role 
sets  RR  =  {L1R,  …,  LnR}  and  WR  =  {L1W,  …, 
LnW} for the read and the write roles, respectively. We 
also add an attribute called label for each role. Then, 
we obtain the following OCL constraint: 
context Session inv SessionConstraint: 
let 
 RR : Set(Role) = Set{L1R, …, LnR}, 
 WR : Set(Role) = Set{L1W, …, LnW} 
in 
 self.role_->size()=2 and  
 self.role_->forAll(rr, wr| 
  RR->includes(rr) and WR->includes(wr) 
  and rr.label=wr.label) 
Note  that  this  specific  authorization  constraint  is 
enforced  at  run-time  and  not  at  administration  time 
because  sessions  are  involved.  The  constraint  is 
checked whenever a new user session is created by the 
Application Client (cf. Section 3), which tries to access 
classified  data.  In  this  case,  the  CreateSession  RBAC 
system  function  is  called  by  the  Application  Client. 
This request is then passed to the authorization engine 
via  the  Access  Decision  Handler.  If  the  constraint  is 
violated,  this  result  is  returned  to  the  Application 
Client.  Otherwise,  the  security  state  is  changed  within 
the authorization engine accordingly, i.e., a new object 
of  the  UML  class  Session is generated. In addition, 
the  fact  that  the  role  has  been  activated  successfully 
must also be stored in the authorization engine.   
6. Related work 
There  is  a  plethora  of  works  in  the  context  of 
security  modeling  with  UML  such  as  [18,  19,  29].  As 
indicated  above,  the  USE  system  is  a  general-purpose 
validation  tool  and  can  hence  be  employed  for  other 
UML/OCL  encodings  of  RBAC  policies  than  that 
given  in  Section  4.  In  particular,  Lodderstedt  et  al. 
for 
present 
language  SecureUML 
the  modeling 
integrating  the  specification  of  access  control  into 
application models and automatic generation of access 
control  infrastructures  for  applications  [18].  They  also 
deal  with  authorization  constraints,  but  do  not 
concentrate  on  SOD  constraints.  Another  difference  is 
that  our  aim  was  to  make  available  an  organization-
wide 
for  Web  Service 
applications  that  can  enforce  various  RBAC  policies. 
Then,  applications  can  use  our  engine  if  needed.  We 
did  not  primarily  intend  to  provide  a  methodology  to 
integrate access control and application models. 
authorization 
engine 
XACML  is  an  OASIS  standard  that  supports  the 
specification  of  authorization  policies  and  related 
queries  in  a  standardized,  machine-readable  way  [15]. 
The RBAC profile of XACML extends the standard for 
expressing authorization policies that use RBAC with a 
scope  limited  to  core  and  hierarchical  RBAC  [20]. 
However,  the  profile  lacks  the  full  support  of  SOD 
constraints  and  other  variations  of  authorization 
constraints. Clearly, one can argue that RBAC policies 
can  be  specified  directly 
in  XACML.  However, 
manually  specifying  such  policies  directly  in  XACML 
could  be  comparatively  complicated,  time  consuming 
and hence error-prone. Due to the fact that OCL has a 
formal  semantics  [16]  we  can  validate  RBAC  policies 
w.r.t. conflicting and missing constraints by tools such 
as USE [22]. To our knowledge, no tool exists that can 
validate XACML policies in that sense. 
integrated 
(for  example,  Adage  was 
Furthermore,  there  exist  other  authorization  engine 
prototypes,  which  can  be  compared  with  our  engine. 
One of those engines is Adage, developed by Zurko et 
al.  [30].  Adage  has  been  developed  with  similar  goals 
in  mind.  Specifically,  Adage  can  enforce  different 
kinds of role-based SOD constraints on the middleware 
layer 
into 
CORBA).  Moreover,  Adage  makes  available  a  policy 
specification  language  called  AL.  However,  some 
constraint  types  are  not  supported  by  Adage  such  as 
context  constraints.  Furthermore,  a  validation  tool  for 
access  control  policies  is  not  available.  Bhatti  et  al. 
present  an  authorization  framework  for  Web  Services 
which can enforce temporal constraints in the sense of 
the GTRBAC model introduced by Joshi et al. [31]. In 
addition, simple SOD constraints are supported.  
7. Conclusion and future work 
In  this  paper,  we  presented  a  Web  Services-based 
authorization  framework  to  enforce  organization-wide 
RBAC  policies  across  various 
(Web  Service) 
applications.  Due  to  the  fact  that Web Services aim at 
integrating  various  applications  of  organizations  and 
hence  possibly  expose  security-critical  functionality,  it 
265265
is desirable to enforce organizational rules on the Web 
Service  level.  In  particular,  we  showed  how  our 
authorization  framework  integrates  an  authorization 
engine  with  the  organization-wide  applications  by 
means  of  an  interceptor.  This  way,  the  authorization 
logic  is  decoupled  from  the  application  logic.  The 
authorization engine can be easily extended to support 
new 
that  are 
expressible in OCL. This way, the authorization engine 
can 
implement  various  kinds  of  authorization 
constraints, independent of the domain in question.  
types  of  authorization  constraints 
As  part  of  future  work,  we  can  extend  our 
authorization  engine  to  incorporate  constraints  on 
delegation  and  revocation.  Last  but  not  least,  it  would 
be interesting to integrate the authorization engine into 
a Workflow Management System. 
References 
1.  J.  Rumbaugh,  I.  Jacobson,  G.  Booch.  The  Unified 
Modeling Language Reference   Manual, Second Edition. 
Reading, Mass., Addison Wesley Longman, 2004. 
2.  J.  Warmer,  A.  Kleppe.  The  Object  Constraint  Language: 
Getting  Your  Models  Ready  for  MDA,  Addison-Wesley, 
2003. 
3.  R.  Sandhu,  E.  Coyne,  H.  Feinstein,  C.  Youman.  Role-
based access control models, IEEE Computer, vol. 29, no. 
2, pp. 38–47, Feb. 1996. 
4.  American  National  Standards  Institute  Inc.  Role  Based 
Access Control, ANSI-INCITS 359-2004, 2004. 
5.  D.F. Ferraiolo, D.R. Kuhn, R. Chandramouli, Role-based 
access control, Artec House, Boston, 2003. 
6.  M. Nyanchama, S. Osborn. The graph model and conflicts 
of interest. ACM Trans. Inf.Syst. Sec. 2, 1, 1999. 
7.  G.-J.  Ahn.  The  RCL  2000  language  for  specifying  role-
based  authorization  constraints,  Ph.D.  dissertation, 
George Mason University, Fairfax, Virginia, 1999. 
8.  V.  D.  Gligor,  S.  I.  Gavrila,  D.  Ferraiolo.  On  the  formal 
definition  of  separation-of-duty  policies  and 
their 
composition.  In  Proc.  IEEE  Symposium  on  Security  and 
Privacy, May 1998, pp. 172–185. 
In  10th 
9.  R.  Simon,  M.  Zurko.  Separation  of  duty  in  role-based 
environments, 
IEEE  Computer  Security 
Foundations Workshop (CSFW ’97), 1997, pp. 183–194. 
10. K. Sohr, M. Drouineaud, G.-J. Ahn. Formal Specification 
of  Role-based  Security  Policies  for  Clinical  Information 
Systems,  in  Proc.  of  the  20th    ACM  Symposium  on 
Applied Computing, 2005. 
11. J.  Joshi,  E.  Bertino,  U.  Latif,  A.  Ghafoor.  A  generalized 
temporal  role-based  access  control  model.  IEEE  Trans. 
Knowl. Data Eng., vol. 17, no. 1, pp. 4–23, 2005. 
12. E.  Bertino,  E.  Ferrari,  V.  Atluri.  The  specification  and 
enforcement  of  authorization  constraints  in  workflow 
management  systems.  ACM  Trans.  Inf.  Syst.  Secur.,  vol. 
2, no. 1, pp. 65–104, 1999. 
13. L.  Zhang,  G.-J.  Ahn,  B.-T.  Chu. A role-based delegation 
systems, 
information 
framework 
healthcare 
for 
Proceedings  of  the  7th  ACM  Symposium  on  Access 
Control  Models  and  Technologies,  June  03-04,  2002, 
Monterey, California, USA. 
14. American  National  Standards  Institute  Inc.,  Role  Based 
Access Control, 2004, ANSI-INCITS 359-2004. 
15.  OASIS.  eXtensible  Access  Control  Markup  Language 
(XACML), Vers. 2.0, February 2005. 
16. M.  Richters.  A  Precise  Approach  to  Validating  UML 
Models  and  OCL  Constraints.  PhD  thesis.  Universität 
Bremen, 2002. 
17. E.  Gamma,  R.  Helm,  R.  Johnson,  J.  Vlissides.  Design 
Patterns: Elements of Reusable Object-Oriented Software, 
Addison-Wesley, 1995. 
18. T. Lodderstedt, D. Basin, J. Doser. SecureUML: A UML-
Based  Modeling  Language  for  Model-Driven  Security, 
UML,  5th  International  Conference.  Vol.  2460.  Dresden, 
Germany, pp.426-441, 2002. 
19. I.  Ray,  N.  Li,  R.  France,  D.-K.  Kim.  Using  UML  to 
visualize role-based access control constraints. In Proc. of 
the  9th  ACM  Symp.  on  Access  Control  Models  and 
Technologies, pp. 115–124, USA, 2004. 
20. A.  Anderson.  Core  and  hierarchical  role  based  access 
control  (RBAC)  profile  of  XACML  v2.0,  OASIS 
Standard, 2005. 
21. D.  Ferraiolo,  D.  Gilbert,  N.  Lynch.  An  examination  of 
federal  and  commercial  access  control  policy  needs,  in 
Proc.  of  the  NIST-NCSC  Nat.  (U.S.)  Comp.  Security 
Conference, 1993, pp. 107–116. 
22. K.  Sohr,  M.  Drouineaud,  G.-J.  Ahn,  M.  Gogolla. 
Analyzing  and  Managing  Role-Based  Access  Control 
Policies,  IEEE  Trans.  Knowl.  Data  Eng.,  vol.  20,  no.  7, 
2008. 
23. C.  K.  Georgiadis,  I.  Mavridis,  G.  Pangalos,  R.  K. 
Thomas.  Flexible 
team-based  access  control  using 
contexts.  In  Proc.  of  the  6th  ACM  Symp.  on  Access 
Control Models and Technologies, p.21-27, 2001, USA. 
24. D.E. Denning. A lattice model of secure information flow, 
Comm. of the ACM, vol. 19, no. 5, pp. 236-243, 1976. 
25. G. Stampe. Personal Communication, 2007. 
26. R.S.  Sandhu.  Role  hierarchies and constraints for lattice-
based  access  controls.  In  Proc.  4th  European  Symposium 
on Research in Computer Security, 1996.  
27. W3C:  XML-Signature  Syntax  and  Processing,  2002. 
Available  at  http://www.w3.org/TR/2002/REC-xmldsig-
core-20020212/ 
28. M. Brandner, M. Craes, F. Oellermann, O. Zimmermann. 
Web  services-oriented  architecture  in  production  in  the 
finance  industry.  Informatik  Spektrum, vol. 27, no 2, pp. 
136-145, 2004. 
29. T. Priebe, W. Dobmeier, B. Muschall, G. Pernul. ABAC 
attributbasierte 
- 
Zugriffskontrolle, Sicherheit 2005, pp. 285-296. 
Referenzmodell 
Ein 
für 
30.  M.  Zurko,  R.  Simon,  T.  Sanfilippo.  A  user-centered, 
modular  authorization  service  built  on  an  RBAC 
foundation.  In  Proc.  of  the  IEEE  Symp.  On  Sec.  and 
Priv., pp. 57–71, Oakland, 1999. 
31. R. Bhatti, A. Ghafoor, E. Bertino, J. Joshi. X-GTRBAC: 
an  XML-based  policy  specification  framework  and 
architecture  for  enterprise-wide  access  control.  ACM 
TISSEC, 8(2):187–227, 2005.  
266266