tine that we shall call OP1.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:08:41 UTC from IEEE Xplore.  Restrictions apply. 
A := B;
C := if D
then E
else F ;
Under the original formulation of Kemmerer in which all
information ﬂows associated with a given operation are
recorded in one column, this would lead to SRM entries
Operation
Resource
Attribute
A
B
C
D
E
F
Op1
M
R
M
R
R
R
The natural interpretation of this SRM is that ﬂows from
B, D, E, and F to both A and C are present. Inspection of the
code shows that this is not true and that a more appropriate
SRM would be
Operation
Resource
Attribute Op1 Op1
A
B
C
D
E
F
M
R
M
R
R
R
6.2.3 Guard Expansion
Even this version can stand reﬁnement since it shows C as
always containing information about both E and F, when
in fact it contains information about one or the other. To
reﬂect this reﬁnement, the following expansion of the SRM
is used:
Operation/Guard
Resource Op1 Op1 Op1 Op1
G1
Attribute
G2
A
B
C
D
E
F
where: G1=true
G2=D
G3=(cid:2) D
G3
G1
M
R
M
R
M
R
M
R
The Gypsy SRM tool displays a basic view of the com-
plete SRM in which the multiple ﬂows of complex routines
are composed into a single column, but it calculates the ex-
panded form. The ﬂow explanations, which are done on an
operation by operation basis, display expanded columns as
well as guard information.
6.3. The GIFT
The Gypsy SRM tool was successful, but the manual
analysis required, even with the explanatory material pro-
vided made its application to large or complex systems
problematic and the Gypsy Information Flow Tool (GIFT 3)
was developed to help mechanize the analysis by creating
information ﬂow formulae.
Several covert channel tools have been built based on the
generation of information ﬂow theorems. The best known
of these are the old and new SPECIAL tools of [10] and
[27]. These tools require a restricted form of a state machine
speciﬁcation for the system being analyzed. A security level
is assigned (often arbitrarily) to each state component and
to the invokers of the system operations. For each transfer
of information within the system, a putative theorem is gen-
erated that, if true, guarantees that the information transfer
proceeds according to the system’s security policy.
This approach is overly conservative for several reasons:
1. It considers operations in isolation. It is often the case
that there is no way to exploit the apparent insecurity
of a given routine.
2. The required labeling of every state component with a
classiﬁcation results in inappropriate labels for some
components. In many cases, the number of failed the-
orems is a function of the labeling strategy used, and
substantial effort is required to choose a suitable label-
ing.
If it is possible to ﬁnd a labeling that results in no
failed theorems, then the model is free of covert storage
channels. Failed theorems do not necessarily indicate ex-
ploitable channels, but substantial effort is required to en-
sure that this is the case. Most real systems exhibit a fair
number of failed theorems when this approach is applied.
6.4 A Simpliﬁed Example
The fragment of code used in connection with the above
discussion of the SRM approach does not satisfy our con-
ventions for Gypsy covert channel analysis. Nevertheless,
it can be used to demonstrate the nature of the formulas that
3The acronym was coined by Craig Singer, one of the developers. Since
some of the development was done in the hope that a contract to support
LOCK with the tool would materialize, the name is a potential pun.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:08:41 UTC from IEEE Xplore.  Restrictions apply. 
will be produced by the GIFT. If we present the fragment
as an equivalent set of guarded assignment statements, it
becomes
true then A := B;
then C := E;
if
if
if not D then C := F ;
D
In addition to the guarded assignments that character-
ize the system in terms of conditional information ﬂows,
it is necessary to know the security level associated with
each of the system entities, A, B, C, D, E, and F. Without
a loss of generality, we will deﬁne a unique level function
for each entity, leaving the arguments required unspeciﬁed.
We will name these functions Level of A(...) through
Level of F(...). As can be seen from the SRM and
the guarded assignments, information ﬂows into A from
B unconditionally, into C from E when D=true, into C
from F when D=false, and into C from D unconditionally.
These ﬂows are secure if and only if the targets of the ﬂows
have security levels equal to or above those of the sources
when the ﬂow condition is satisﬁed. This gives rise to the
following information ﬂow formulas:
Level_of_A(...) ge Level_of_B(...)
Level_of_C(...) ge Level_of_D(...)
D => Level_of_C(...) ge Level_of_E(...)
not D => Level_of_C(...) ge Level_of_F(...)
If each of these formulas can be proven, then the fragment
is secure.
The GIFT provided facilities for deﬁning a TCB in terms
of a type that represented the internal state and a set of pro-
cedures or functions that operated on the state and/or re-
turned information about it. It also provided mechanisms
for deﬁning security labels, for associating labels with state
components (as seen above), and for deﬁning a level com-
parison function.
In addition to lattice policies, policies
based on total orderings, partial orderings, and isolation
among equivalence classes.
In most cases, Gypsy was used solely to specify the TCB,
but not to implement it. The original dependency analyzer
was designed to operate on code rather than speciﬁcations
and had to be modiﬁed to work on speciﬁcations. This leads
to fairly draconian requirements on speciﬁcation style, but
the requirements are necessary to ensure that the speciﬁca-
tions explicitly reﬂect the effects of TCB operations on the
TCB state. The GIFT manual[21]4 goes into considerable
detail on the restrictions and conventions and provides an
example.
4Like many of the CLI reports associated with Gypsy and the GVE,
this report is out of print. Copies are available in Postscript form from the
author, jmchugh@cert.org.
7. An Interesting Application
The SRM tool supported analyses other than for covert
channels. In the late 1980s, CLI worked with TRW and TIS
on the development of a process model for the construction
of high performance trusted systems[17]. For the second
phase of this project, we applied the model to the construc-
tion of a MLS windowing system[8]. Formal analysis was
one of the primary risk mitigation strategies used in the pro-
cess and the SRM tool played a signiﬁcant role in the design
of the windowing architecture. We were debating whether
to attempt to secure the X-window protocol by imposing a
TCB on the reference implementation of X windows or to
use a more radical approach. Compartmented Mode Work-
stations (CMWs) had taken the former path, but we were
uncertain that the requirements for our target, the B3 level
of the TCSEC could be satisﬁed with this approach. Cut and
paste operations were particularly problematic. We created
a model of the ICCCM cut and paste protocol in Gypsy and
used the SRM tool to analyze its information ﬂow charac-
teristics. In ICCCM cut and paste, the cutting window as-
serts ownership of an X resource known as the “selection”
and associates the object to cut with it. The pasting window
determines the owner of the selection, inquires as to the for-
mats in which the selection can be made available, chooses
one (or more) and asks for the selection to be converted to
that (those) format(s). The cutting window performs the
conversion. The pasting window then asserts ownership of
the selection and copies the converted object.
It is clear
that no MLS policy would permit cutting from a high level
window followed by pasting to a low level one, the reverse
seems desirable.
We modeled this in some detail in Gypsy, producing the
SRM shown in ﬁgure 1. Analysis of the SRM conﬁrmed
our intuitions, i.e.
the bidirectional messages required by
cut and paste could not be supported in a MLS context. The
CMW effort swept this under the rug (where it remains to
this day) by declaring that these were covert channels and,
since the B1 criteria do not require covert channel analysis,
the behaviors were acceptable. At ﬁrst, we were tempted
by the interpretation and performed analyses to attempt to
determine the information capacity of these communica-
tions mechanisms. One problem that arose is the fact that
the design of the X protocol goes to great length to make
it difﬁcult to determine whether events result from human
or program activity. Thus, a mechanism that might be re-
stricted to a few bits per second when driven by a human
clicking a mouse could be driven by program commands at
much higher rates. Ultimately, we concluded that commu-
nications mechanisms required by the X protocol could not
be considered as covert channels under any circumstances
(even at B1) and that the X protocol was inherently insecure
and unsecurable in an MLS sense. This led us to an archi-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 07:08:41 UTC from IEEE Xplore.  Restrictions apply. 
Resource
SIZE (STATE.ATOM LIST)
DOMAIN (STATE.ATOM LIST)
RANGE (STATE.ATOM LIST)
SIZE (STATE.ATOM LIST[IND#1])
STATE.ATOM LIST[IND#1][IND#2]
SIZE (STATE.CLIENT LIST)
DOMAIN (STATE.CLIENT LIST)
RANGE (STATE.CLIENT LIST)
STATE.CLIENT LIST[IND#3].P
STATE.CLIENT LIST[IND#3].SL
STATE.CURRENTTIME
SIZE (STATE.PENDING EVENTS)
STATE.PENDING EVENTS[IND#4].BODY
STATE.PENDING EVENTS[IND#4].EV NAME
STATE.PENDING EVENTS[IND#4].ORIGINATOR
STATE.PENDING EVENTS[IND#4].RECIPIENT
STATE.REQUESTOR
STATE.REQUEST P
SIZE (STATE.SELECTION LIST)
DOMAIN (STATE.SELECTION LIST)
RANGE (STATE.SELECTION LIST)
STATE.SELECTION LIST[IND#5].OWNER
STATE.SELECTION LIST[IND#5].TIME
SIZE (STATE.WIN LIST)
DOMAIN (STATE.WIN LIST)
RANGE (STATE.WIN LIST)
STATE.WIN LIST[IND#6].OWNER
SIZE (STATE.WIN LIST[IND#6].PROPS)
DOMAIN (STATE.WIN LIST[IND#6].PROPS)
RANGE (STATE.WIN LIST[IND#6].PROPS)
SIZE(STATE.WIN LIST[IND#6].PROPS[IND#7].DATA)
STATE.WIN LIST[IND#6].PROPS[IND#7].DATA[IND#8]
STATE.WIN LIST[IND#6].PROPS[IND#7].FORMAT
STATE.WIN LIST[IND#6].PROPS[IND#7].TYPE VAL
USER-IN
USER-OUT
SETSEL
GETSEL
CONVRT
CHANGE
SENDEV
SELECT
SELECT
SELECT
#1
R
R
#2
R
R
#3
R
R
#4
R
R
#5
#6
#7
#8
R
R
M R
M R