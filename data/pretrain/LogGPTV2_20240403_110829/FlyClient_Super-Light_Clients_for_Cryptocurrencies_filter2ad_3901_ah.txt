j such that (2j−1)n
. In other words, there
is some sampled interval of size n(cid:48) = n/2j in the protocol
where the fork point lies between the start and the middle of
the interval. Let l denote the length from a till n, i.e., the
length of the fork, l > n(cid:48)
2 . The number of invalid blocks in
the interval is hj = (1− c)l ≥ (1− c) n(cid:48)
2 . Thus, the probability
the veriﬁer fails to catch the invalid chain is at most equal
to the probability the veriﬁer fails at step j, or Pr[fail] ≤
Pr[fail at j] ≤
=(cid:0) 1+c
n(cid:48)−(1−c) n(cid:48)
(cid:19)k
(cid:1)k
(cid:18)
Note that if l ≤ k, the veriﬁer will sample all of the
2
n(cid:48)
.
2
2j
adversary’s invalid blocks and Pr[fail] = 0.
Given that f is non-increasing,
D. Proof of Lemma 3
Proof. We prove the statement by contradiction. We show
that given f, there exists another PDF f(cid:48) that with a single
query succeeds in catching the adversary with slightly higher
probability.
there exist numbers
x1, x2, d ∈ [0, 1] and intervals I1 = [x1, x1 + d] and
I2 = [x2, x2 + d] such that x1 + d ≤ x2 ≤ 1 − d and
f (x) > f (x(cid:48)), for all x ∈ I1 ∧ x(cid:48) ∈ I2. Any adversarial
strategy can be deﬁned by a fork point a ∈ [0, 1] and by the
ranges of blocks which are invalid after a. Note that given a
fork point, the adversary can freely decide which blocks, i.e.,
which intervals, to make invalid and which ones to honestly
mine. For any strategy which produces an invalid block in I1
but valid blocks in I2 there exists a strategy which creates an
additional invalid block in I2 and one more valid block in I1
without changing any other part of the strategy. Note that the
converse is not true. If the fork point a is > x1 then it may
not be possible to move invalid blocks to the ﬁrst interval.
Given that the querying probability of any point in I2 is lower
than the probability of any point in I1 the adversary is always
better off by moving all possible invalid blocks to I2. I2 must
therefore contain no less invalid blocks than I1 in any strategy
which is optimal for the adversary.
Consider the probability distribution f(cid:48) which is equal to f
on all points but x ∈ I1 ∪ I2. There exists an  > 0 such that
for any point x ∈ I2, f(cid:48)(x) = f (x)+ and for any point in I1,
f(cid:48)(x) = f (x) −  and the following condition holds: For all
adversaries, a single query drawn from the distribution deﬁned
by f(cid:48) has a slightly higher probability of querying an invalid
block than a single query drawn from the distribution deﬁned
by f. This is because f(cid:48) queries with higher probability in
I2 which must contain no less invalid blocks than I1 for any
optimal adversary.
E. Proof of Lemma 4
Proof. Let Bn be the head of the chain created by A with
MMR root Mn−1 Let Bi → Bi+1 be an invalid difﬁculty
adjustment. Note that this directly implies that there exists
no ΠBi∈Mn−1 as all veriﬁers will directly reject this proof.
Consider the (invalid) proof Π∗
created by the MMR
proof generation algorithm with the modiﬁcations deﬁned in
Bi∈Mn−1
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:03 UTC from IEEE Xplore.  Restrictions apply. 
944
Bi∈Mn−1
Deﬁnition 7. Let x(cid:48) be the highest node in Π∗
that
would have led a veriﬁer to reject the proof. For example if the
dampening factor τ = 4 and the invalid difﬁculty adjustment
from Bi → Bi+1 raises the difﬁculty by a factor of 100 then
x(cid:48) will be the third node in ΠBi∈Mn−1. Note that any proof
containing x(cid:48) will be rejected by the veriﬁer. Let M(cid:48) be the
subtree of Mn−1 that is spanned by x(cid:48)s parent. All leafs of
M(cid:48) are invalid as all inclusion proofs for these leafs must
contain x(cid:48) (unless A found a collision on the MMR’s hash
function which happens with at most negligible probability).
This means A(cid:48) can change the difﬁculty adjustment for all
of these leafs of M(cid:48) without changing the validity of any
other node. The blocks spanned by M(cid:48) are all invalid and
need not to contain a valid proof of work. A(cid:48) does this such
that the difﬁculty adjustments are all valid but also consistent
with the parent of x(cid:48), i.e., the root of M(cid:48). Note that this is
possible since, by assumption, the parent of x(cid:48) does not cause
the veriﬁer to reject the proof. Consistency with x(cid:48) implies
that the start and end difﬁculty as well as the total weight,
the total time and the total number of blocks are as deﬁned in
x(cid:48). These parameters therefore don’t change for the subchain
spanned by M(cid:48)s leafs from the chain generated by A vs. the
chain generated by A(cid:48). A(cid:48) repeats this process until it creates
a chain with only valid difﬁculty transitions. All other valid
blocks A(cid:48) attempts to create using its oracle queries. Since C(cid:48)
contains at most as much proof of work as C it can be created
with at least probability p − negl(λ).
APPENDIX C
COMPARISON WITH NIPOPOW
NIPoPoW like FlyClient promises short proofs of proof of
work for light clients. We compare FlyClient with NIPoPoW
by analytically computing NIPoPoWs proof size. We match
the security level of NIPoPoW and FlyClient such that for
security parameter λ an attacker who controls a c fraction of
the main chain’s mining power succeeds with probability 2−λ.
Concretely, in NIPoPoW we set both the number of blocks
checked at the end of the chain (k) and the length of each
super-chain m to log 1
(2)λ. The total NIPoPoW proof size is
c
log 1
c
(2)λ · ((log2(n) + 1) · B + log2(n) · (cid:100)log2(log2(n, 2), 2)(cid:101) · |H|),
for B = 508 bytes being the size of each block header and
|H| = 32 bytes being the size of a hash. We compare the
two light client approaches in Figure 6. The evaluation uses a
security parameter of λ = 50 and 3 different parameterizations
of c. c is a bound on the fraction of the honest mining power
that an adversary controls.
1+c is the fraction of the total
mining power that the adversary controls. For c = 0.9 this is
47.3%. We see that both proofs are very efﬁcient producing
proofs under 6 MB even for the largest parameters. FlyClient
outperforms NIPoPoW over all parameters but especially for
large values of c, yielding an almost 40% improvement in
proof size. This validates the optimization approach for ﬁnding
an optimal light client design. Note that for n = 10 million,
an SPV client would have required a 4.9 GB proof over 1000
c
times more than the corresponding FlyClient proof for c = 0.9.
Fig. 6. Comparison of FlyClient and NIPoPoW at varying difﬁculty levels and
λ = 50.
APPENDIX D
DISCUSSION
A. Transferable and Unique Proofs
A major beneﬁt of the non-interactive proofs is that they are
transferable. A single prover can produce a proof and other
users can relay the proof without any additional computation.
The relayed proof is still convincing to a veriﬁer. A full node,
therefore, can create a proof which many other clients can use.
Moreover, by applying the Fiat-Shamir heuristic to the head
of the chain we enforce that there only exists a single valid
non-interactive proof for a given chain. It therefore sufﬁces
if a single party produces the proof for the valid chain and
forwards it to all FlyClient nodes.
B. Subchain Proofs
Another beneﬁt of the non-interactive proofs is that they
allow clients to re-sync to a chain that has grown since the
last time they were given a proof for it, by only needing to
download a shorter proof for the section of the chain they have
not seen. Once a FlyClient has received a proof for a chain of n
blocks (or D cumulative difﬁculty), they are convinced that at
the point in time when they received the proof for that chain it
was the honest chain. Suppose that at a later point in time the
chain has grown to n(cid:48) blocks (or D(cid:48) difﬁculty), the FlyClient
needs only to verify that this new section is honest and thus
only require a proof logarithmic in the size of the new section.
We note that the prover must also provide a single MMR proof
that block n is in the MMR of block n(cid:48), meaning the previous
chain is a preﬁx of the new chain.
Theorem 6 (Subchain Proofs). A FlyClient that was given a
valid proof for a chain of length n at a time when the honest
chain had length n, and when the honest chain has length n(cid:48)
is given a subproof for the subchain from n to n(cid:48) including a
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:03 UTC from IEEE Xplore.  Restrictions apply. 
945
010002000300040005000600002,000,0004,000,0006,000,0008,000,00010,000,000Proof size in KBBlockchain length nc=0.1 FlyClientc=0.1 NIPoPoWc=0.5 FlyClientc=0.5 NIPoPoWc=0.9 FlyClientc=0.9 NIPoPoWMerkle proof that block n is in the MMR of block n(cid:48), would
not accept another chain if they were instead given the full
proof for a chain of length n(cid:48).
Proof. We consider two strategies the adversary may choose:
(1) It forks from the honest chain after block n, this is as if
the genesis block were set to block n and the subproof from
block n to n(cid:48) is a whole proof for a chain of n(cid:48)−n blocks. (2)
The adversary forks from the honest chain before n, by the
security of the proof for the ﬁrst n blocks, the FlyClient would
not accept the adversary’s chain up to n so their subproof from
n to n(cid:48) would fail because the FlyClient’s block n is not in the
MMR of the adversary’s new chain. The FlyClient that receives
the whole proof would also not accept the adversary’s proof
based on the security of a proof for n(cid:48) blocks.
We note that a subchain proof does not have to be created
speciﬁcally for the subchain, a FlyClient can take a proof for
a chain of n(cid:48) blocks and only check the blocks after n. This
allows for FlyClient to use only the part of a transferable n(cid:48)
chain proof which it has not yet veriﬁed. This is a convenient
option for FlyClient that may be running on cell phones or
other data-limited devices and do not want to use data re-
checking sections they have already veriﬁed. Subchain proofs
also introduce the option of select checkpoint proofs, meaning
that proofs can be created for select points in the chain and
a FlyClient can request
the precomputed proof they need,
minimizing the computation overhead for prover full nodes
and proofs will be more easily reused.
C. Deploying FlyClient
The only modiﬁcation to the block structure of Bitcoin,
Ethereum and similar blockchain protocols that is required
to implement FlyClient is to include the MMR root in every
block. Updating/checking the MMR root requires O(log n)
work, where n is the length of the chain, and minimum storage
overhead of 2n tree nodes that contain a hash and 5 integers.
The MMR root can be added to blocks in three different
ways. The ﬁrst way is a hard fork in which the MMR root is
added to the header of all blocks (both old and new). In some
newer blockchain designs, such as the Mimblewimble [40]-
based Grin and Beam MW [41], this is already the case.
Alternatively, a soft fork can be used such that new blocks
contain the MMR root while old blocks do not. A soft fork
gets “activated” when a majority of nodes have enforced the
new protocol rules. Starting from the soft fork, new blocks
would store the MMR root encoded in a backwards compatible
way like in a special transaction. In FlyClient, the miner would
provide the block headers, as well as the special transaction
and a proof that the transaction is part of the block. The proof
size would grow by a factor that is proportional to log(|tx|),
where |tx| is the number of transactions.
A third deployment path is called a velvet fork and was
proposed by [42]. In velvet forks, blocks by outdated miners
are not rejected, making it a backwards compatible update
to blockchain protocols which rely on clients reinterpreting
the blockchain data. For FlyClient the velvet fork would lead
to a constant fraction α of blocks containing an MMR root.
Blocks created by outdated nodes would not contain the root.
The FlyClient protocol would simply treat multiple blocks as
one. Concretely, blocks that do not contain an MMR root are
viewed as part of the next upgraded block. The miner will
always download and check these joined blocks together. If in
expectation 1/α blocks are joined, the FlyClient proof would
be at most 1/α large than for an equivalent fully upgraded
chain. Velvet forks, therefore, lead to less efﬁcient proofs but
provide an uncontentious deployment mechanism for FlyClient.
D. FlyClient for Proof-of-X Protocols
For simplicity, in this paper we describe FlyClient in the
context of Bitcoin and Ethereum, where the blockchain grows
based on a PoW mining process. Our protocol, however, is ap-
plicable to any proof-of-X protocol [43], where a more energy-
efﬁcient alternative to PoW is used to build a chain based
on the longest chain rule. Examples of such alternatives are
proof-of-stake [44], proof-of-space [45], or proof-of-elapsed-
time [46]. Such a protocol must allow any node to verify the
validity of each block individually ensuring that the block
creator has spent (or burnt) a certain amount of a resource
uniquely for this block.
E. Connection to Proof of Sequential Work
Cohen and Pietrzak [47] propose a simple proof of se-
quential work (PoSW) construction based on Merkle trees
with added edges. A PoSW [48] convinces a veriﬁer that a
signiﬁcant amount of sequential work was applied to a given
input. In the construction of [47], the edges which are added
to a full Merkle tree connect the left siblings of a leaf’s path
to the root with the leaf itself. The veriﬁer simply queries
random leafs and checks that they are part of the tree and
have the correct incoming edges. This construction is almost1
identical to an iterative MMR construction, where every leaf is
the root of the previous MMR. FlyClient follows this design,
storing the previous MMR root in every new block/leaf. It
is easy to see that constructing a FlyClient chain of length n
takes θ(n) sequential steps. The veriﬁcation algorithm of [47]
can be interpreted as our FlyClient protocol with a uniform
querying distribution. A FlyClient blockchain is, therefore, a
PoSW, albeit an inefﬁcient one. In a PoSW, a cheating prover
will cheat on a constant fraction of leafs in order to save
a signiﬁcant amount of sequential work. FlyClient’s security
guarantee is stronger, ensuring that, from no point on the chain,
a constant (or more) fraction of leafs are corrupted.
1In [47], a node can have more than two incoming edges.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:03:03 UTC from IEEE Xplore.  Restrictions apply. 
946