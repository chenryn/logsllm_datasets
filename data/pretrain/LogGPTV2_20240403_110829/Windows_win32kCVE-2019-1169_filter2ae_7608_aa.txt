# Windows win32k空指针解引用内核信息泄露漏洞分析（CVE-2019-1169）
##### 译文声明
本文是翻译文章，文章原作者 hubspot，文章来源：cdn2.hubspot.net
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 一、漏洞详情
近期，VS-Labs针对微软在2019年8月补丁更新中修复的win32k.sys
NULL指针解引用漏洞进行了研究。利用该漏洞，攻击者可以创建一个漏洞利用程序，从而从受影响Windows 7计算机上的任何内核地址中泄露数据。  
在本文中，我们将展示VS-Labs如何编写这一漏洞利用程序，我们首先建立了测试环境，然后使用DIaphora分析补丁，最后使用C++语言编写漏洞利用程序。希望通过阅读这篇文章，能够使读者对这个典型的漏洞产生深刻的理解。  
要阅读本文，需要读者事先具备以下知识：  
C/C++相关知识（必备）；  
X86编译知识（必备）；  
Windows用户空间漏洞利用经验（推荐）。
## 二、漏洞分析
###  2.1 漏洞公告分析
在分析CVE-2019-1169之前，我们首先分析了两份单独的漏洞公告，其中一份是来自Microsoft的，另一份是来自ZDI。经过初步分析，我们发现了这两份公告之间的差异。  
Microsoft在CVE-2019-1169的漏洞公告页面上将该漏洞描述为影响Windows 7、Windows 7 SP1、Windows Server
2008和Windows Server 2008 R2的任意代码执行漏洞。在这里，Microsoft没有列出不再受支持的漏洞操作系统，例如Windows
XP，但这些操作系统也存在该漏洞。  
另一方面，ZDI的ZDI-19-709漏洞公告将该漏洞描述为xxxMNDragOver()中的NULL指针解引用漏洞。  
在这份通告中还提到，可以通过在回调期间破坏菜单来触发漏洞，从而使攻击者能够从用户模式代码读取内核内存。  
在这里，我们必须要提出一个问题——在两份通告中，究竟哪一个是正确的？  
经过进一步的研究，我们已经能够确定，ZDI的公告实际上是正确的，而Microsoft的公告是将多个公告组合在了一起，并使用其中最严重的一个漏洞描述为其贴上标签，这样可能会为用户带来错误的印象，会让人们觉得CVE-2019-1169可以导致攻击者实现特权提升。  
在我们开展分析之前，有必要描述一些有关NULL指针解引用漏洞工作原理的背景知识。
###  2.2 空指针解引用的原因和影响
之所以会产生NULL指针解引用漏洞，是因为开发人员在解除对指针的引用并检索其指向的数据之前没有检查指针是否为NULL。这通常是由于开发人员忘记了其代码中的一个代码路径会将对象或指针更改为意外状态而导致的。这可能导致开发人员做出错误的假设，也就是必须进行哪些检查才能适当地保护其程序免受恶意输入的侵害。  
NULL指针解引用漏洞的严重性，取决于解引用后应用程序如何使用这个指针。如果将指针指向的数据用于写操作的位置，就能导致攻击者可以写入任意内存，从而可能会导致代码执行。  
同样，如果使用指针来确定从哪里读取数据，那么攻击者就只能实现任意读取，最终导致的潜在危害就是信息泄露。在这两种情形中，攻击者都必须要分配NULL页，以便在解应用指针时，受影响的程序会在分配的NULL页中引用攻击者控制的数据。然后，这些数据将在受影响的应用程序中使用，这将会导致攻击者控制程序的行为。  
在制作NULL页时，攻击者必须确保NULL页的内容与NULL指针指向的数据的结构相匹配，否则他们将无法控制应用程序的数据。我们应该指出，这表明没有通用方法可以为NULL页制作数据。每个受影响的应用程序可能都需要用一个你哟功能程序唯一的数据来填充NULL页。  
最后，需要特别说明的是，我们在本文中仅会讨论内核模式NULL指针解引用漏洞，但同样的概念也适用于用户模式NULL指针解引用漏洞。二者之间唯一的区别在于，内核模式NULL指针解引用漏洞更有可能导致特权提升，因为内核模式代码可以读取系统上的任何地址，而对于用户模式的NULL指针解引用漏洞，则只能在用户模式地址空间内读取或写入地址。
## 三、漏洞影响范围
我们再次阅读Microsoft的公告，发现其中表示，该漏洞不会影响Windows 8、Windows 8.1和Windows 10。  
这些版本之所以不受漏洞影响的原因，可以在2012年MSRC上Matt Miller的演讲中找到。该研究人员的研究成果指出，在Windows
8和更高版本上，用户尝试使用前64KB内存（0x00000000 – 0x0000FFFF）会阻止其使用，以防止出现NULL指针解引用漏洞。  
这个缓解措施的工作原理就如同内核模式尝试在该区域中分配内存一样，将会引发访问冲突，这会导致BSOD，从而向系统管理员表明网络内部可能存在攻击者。  
同样，用户模式应用程序将无法在这些区域中分配内存，而是会返回错误。  
这里要注意的一点是，这个缓解措施已经反向移植到Windows
Vista及更高版本的64位版本中。因此，只能在大多数Windows操作系统的32位版本上利用NULL指针解引用。但是，如何验证这一点呢？我们需要进行一些开发工作。  
3.1 验证是否已回传NULL页面缓解  
为了测试NULL页缓解措施是否已经反向移植到Windows 7
x64中国呢，我们使用了以下代码，该代码尝试使用ZwVirtualAllocMemory()分配NULL页。
    NULLPageAllocation.cpp：
    // NULLPageAllocation.cpp: This file contains the 'main' function. 
    // Program execution begins and ends there.
    #include 
    #include 
    #include   
    // Needed to solve the issue "Function returning function 
    // is not allowed”. Might be because it defines 
    // NTSTATUS and some other data structures.
    // Definition taken from NtAllocateVirtualMemory function (ntifs.h) -Windows drivers
    typedef NTSTATUS(WINAPI* ZwAllocateVirtualMemory)(HANDLE ProcessHandle, PVOID* BaseAddress, ULONG_PTR ZeroBits, PSIZE_T RegionSize, ULONG AllocationType, ULONG Protect); 
    #define STATUS_SUCCESS 0
    int main()
    {
            // Get the address of NtAllocateVirtualMemory()
            // which is exported from ntdll.dll
            ZwAllocateVirtualMemory pZwAllocateVirtualMemory = (ZwAllocateVirtualMemory)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "ZwAllocateVirtualMemory"); 
            DWORD baseAddress = 0x1;
            SIZE_T sizeOfAllocation = 1024;
            NTSTATUS result = pZwAllocateVirtualMemory(GetCurrentProcess(), (PVOID*)&baseAddress, 0, &sizeOfAllocation, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
            if (result == STATUS_SUCCESS) {
                    printf("[*] Successfully allocated the NULL page!rn");
            }
            else {
                    printf("[!] Could not allocate the NULL page...rn");
            }
    }
在这个示例中，将0x1作为基址，因为ZwVirtualAllocMemory()不允许address参数为0x0。但是，如果提供了0x1，那么ZwVirtualAllocMemory()会在内部将0x1向下舍入到下一个页面对齐的地址0x0。因此，攻击者可以请求ZwVirtualAllocMemory()尝试分配NULL页，而不会违反ZwVirtualAllocMemory()的参数要求。  
这里需要注意的是，如果尝试使用其他内存分配函数，将无法实现这一点，因为ZwVirtualAllocMemory()和其NT等效函数NtVirtualAllocMemory()具有在NULL页上分配内存的独特功能，而其他调用（例如VirtualAlloc()）则可以舍入到最接近的页边界，也拒绝小于某个地址的地址。下图展示了我们尝试在Windows
7 SP1 x64计算机上运行该程序的结果。
需要关注的是，返回的错误代码保存在result变量中，该代码为0xC00000F0或STATUS_INVALID_PARAMETER_2。通过参考Microsoft的NTSTATUS页面，我们确定这个错误代码表明第二个参数会传递给ZwAllocateVirtualMemory()，这是要分配的内存的基址，是无效的。我们也许想弄清楚，如果尝试在NULL页之外、前64KB内存中分配内存，将会发生什么情况。实际上，这样的尝试也会失败，但错误代码会有所不同。在下面展示的示例中，我们尝试在位于前64KB内存中的0xF80C地址处分配内存。  
这会导致ZwAllocateVirtualMemory()返回相同的错误代码0xC00000F0或STATUS_INVALID_PARAMETER_2，表示指定的内存地址无效，如下图所示。
最后，如果用户尝试在内存前64KB之外的较低位内存地址上分配内存，那么ZwAllocateVirtualMemory()会成功，如下图所示。
从最后三个测试的结果来看，可以确认ZwAllocateVirtualMemory()的内部已经修改，但改动仅是为了确保它不能在NULL页的前64KB内存中分配内存。  
在NtVirtualAllocateMemory()进行相同的测试，展示出类似的结果，表明它也以相同的方式进行了修复，因此我们就可以确认CVE-2019-1169仅影响Windows
7 x86和更低版本，而不会影响Windows 7 x64、Windows 8和更高版本。
## 四、目标设定
###  4.1 环境设置：快照和文件夹
在我们掌握了哪些系统受到CVE-2019-1169漏洞的影响之后，我们就可以创建一个环境来分析补丁。在这里，我们使用了运行Windows 7 SP1
x86的VirtualBox VM。然后，在纯净版映像的状态拍摄两个快照。  
第一个快照命名为“Windows 7 2019年7月补丁”，将CVE-2019-1169之前的所有补丁安装在纯净版本的Windows 7
SP1映像上。这一过程，是通过安装2019年7月每月汇总补丁（KB4507449）来实现的。  
在每月汇总补丁中，包含当月和前几个月的所有补丁程序，这样使得研究人员可以轻松获得已经安装了正确补丁集合的系统。  
第二个快照命名为“Windows 7 2019年8月补丁”，是在安装KB4512486后拍摄的，其中包含CVE-2019-1169的修复。  
为了确认这是正确的更新程序包，我们查看了Microsoft
CVE-2019-1169的漏洞公告页面，该页面上说明，修复了CVE-2019-1169漏洞的2019年8月安全更新程序包编号为KB4512486。下图展示了执行这些操作后，VirtualBox的快照视图。
一旦安装补丁并拍摄快照后，我们就可以从其中的两个快照中提取win32k.sys文件，并将其复制到主机上。  
未修复的win32k.sys被放置在名为Old的文件夹中，而修复后的win32k.sys被放置在名为New的文件夹中。该文件夹的结构如下图所示：
然后，我们将这两个win32k.sys文件加载到IDA Pro中进行分析，并将生成的IDA Pro数据库文件（.i64文件）保存在相应的本地文件夹中。