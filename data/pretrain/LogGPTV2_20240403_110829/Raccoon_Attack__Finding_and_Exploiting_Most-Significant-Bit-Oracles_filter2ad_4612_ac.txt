face [41] pads keys to the block size of the hash function. The
padding of the shared key can result in a timing side chan-
nel as different key lengths will lead to different amount of
padding applied, and therefore to a different number of calls
to the hash compression function. We show a practical attack
based on this side channel in Appendix A.
3.4 OD: Direct Side Channels
Until now, we discussed side channels based on small timing
differences in the processing of the shared DH secret. How-
ever, it is possible that an implementation provides a direct
oracle which does not rely on timing differences but relies
on direct differences in behavior, such as error messages or
handling of the connection state (like closing the underlying
socket). If an implementation behaves differently depending
on the shared secret, it provides an attacker with a direct side
channel. The reason why these direct oracles might be plausi-
ble is that, for example, the zero byte is considered a special
character in many programming languages. For example, in
C the zero byte is used to terminate strings. This can result
in programming errors, which can, in return, lead to observ-
able differences in response to network queries. We show in
Section 7 that a non-negligible number of real-world servers
indeed present such directly observable behavior differences.
In all observed cases, this side channel only leaked the most
signiﬁcant byte of the PMS, which is equivalent to a leak of
k = n mod 8 bits for a prime p of bit-size n.
3.5 Further Oracle Considerations
Big number libraries. Even if a protocol does maintain lead-
ing zero bytes of the shared secret, the used big number library
might introduce an oracle that leaks the most signiﬁcant bits.
If the big number library does not maintain ﬁxed-size big num-
bers internally, the resulting shared secret has to be padded
by the application to the modulus size if the shared secret has
fewer bytes than the modulus.
Hitting the block boundaries with dangerous modulus
sizes. In our examples above, we used unusual modulus
sizes of 1025 and 1913 bits to instantiate the length distin-
guishing oracles. We arrived at these numbers by comput-
ing the input lengths for a given hash function that leak the
top x leading zero bits of the potential input at the critical
block border of the nth block, using the following formula:
cbb(x,b, p,n) = n∗ b− p + x, where b is the block size of the
hash function in bits, and p is the ﬁxed padding part of the
hash function, also in bits.
On the reliability of timing side channels. If the attacker
uses a timing side channel, the oracle will liekly give occa-
sionally wrong results, as timing measurements are inherently
noisy. Thus, any classiﬁer will exhibit some probability of
false classiﬁcation. The distinguishing attack can be made
practical if the attacker can send several queries to the target.
The attacker can then use standard statistical tests to build a
reliable oracle out of the noisy oracle. We give more details
in Subsection 6.1.
4 Raccoon Length Distinguishing Oracles in
TLS
In this section, we ﬁrst describe the high-level attack scenario.
The main contribution of this section is a detailed analysis
of the different TLS key derivation functions, which results
in different critical block boundaries (cf. Subsection 3.5 and
Table 2) to trigger the length distinguishing oracles. We
concentrate our analysis on OHand OC, which result from the
TLS design combined with the hash function properties (e.g.,
different timing proﬁles for inputs of different block lengths).
We stress that OPand ODare implementation-dependent and
can potentially be found exploitable at any block boundary.
4.1 TLS Attack Scenarios
For the attack scenarios described below, the attacker needs
access to a functional oracle from Section 3. Furthermore, the
honest client and server have to use a vulnerable TLS version
and negotiate TLS-DHE or a connection with a static TLS
key share.
Raccoone: Length distinguishing attack on ephemeral
keys. The goal of the Raccoone attack is to detect the leading
bits in the DH shared secret in a MitM attacker model with
ephemeral keys. If the attacker wants to perform the attack, it
218    30th USENIX Security Symposium
USENIX Association
can measure the presented side channels in Section 3 at two
different positions within a TLS connection:
• The attacker can target the server and measure the time
the server used to compute the premaster secret. The
attacker can do this by measuring the time between the
server receiving the ClientKeyExchange message and
the server sending its Finished message.
• Or, the attacker can target the client and measure the
time the client used to compute the premaster secret. The
attacker can do this by measuring the time the client took
to read the ServerKeyExchange message up to sending
the Finished message by the client.
By repeatedly observing TLS-DHE handshakes between
an honest client A and an honest server B the attacker can
learn typical timing values. After this, the attacker will be
able to detect if leading zero bytes are present in the unknown
pms by observing faster response times.
This length distinguishing attack is applicable even if the
server does not reuse ephemeral DH values. However, in this
case the attack poses little threat in practice, since the attacker
merely learns the length of a fully ephemeral, one-time shared
secret. This does not allow the attacker to decrypt or modify
trafﬁc.
Raccoons: Length distinguishing attack on a static key. In
this scenario, the attacker has recorded a previous TLS-DH(E)
session, and the goal is to recover the length of the premaster
secret used in this session between two honest peers.
In
contrast to Raccoone, in this scenario, the server uses a static
key, or is reusing the same ephemeral DH secret for a certain
period of time, covering the recorded TLS-DHE session and
the full duration of the attack.
To perform the attack, the attacker selects an appropri-
ate oracle of OH, OC, OPand OD from Section 3, con-
nects to the server and sends a Difﬁe-Hellman share in a
ClientKeyExchange message. For the length distinguishing
attack, this ClientKeyExchange message contains the origi-
nally observed key share from the honest client. Note that an
attacker can also send related key shares here to retrieve the
MSBs of related premaster secrets (see Section 5). Of course,
the attacker cannot construct a valid Finished message since
the secret key is unknown to the attacker. The server receiving
a message crafted by the attacker will, therefore, terminate the
connection by either sending a fatal Alert message or closing
the TCP connection. However, the server always needs to
compute the premaster secret and derive the master secret
using the PRF. Therefore, the server’s response will depend
on the leading bits of the premaster secret.
If the attacker uses a timing side channel, the reliability
of the side channel can be improved as described in Subsec-
tion 3.5.
4.2 Analysis of TLS Key Derivations
Since the TLS key derivation is of special interest for this
paper, we will analyze it in detail. The starting point for the
key derivation is the PMS. In a two-step key derivation, ﬁrst
a master secret is computed from this premaster secret, and
then two sets of keys (one for each communication direction)
are derived from the master secret.
How exactly the master secret is derived from the pre-
master secret depends on the negotiated protocol version
and cipher suite. Note that an attacker can observe the
ClientKeyExchange message on any version or cipher suite
and then send it as part of a different protocol version and
cipher suite to a server (as long as the server supports it). We
now analyze different TLS versions and how they use the
premaster secret to derive further keys with their PRFs. Our
analysis of critical block borders is summarized in Table 2.
Protocol version /
Cipher suites
TLS 1.2 (_SHA384)
TLS 1.2 (others)
TLS 1.0 and 1.1
SSLv3
Key derivation
SHA-384 PRF
SHA-256 PRF
MD5/SHA-1 PRF
Custom MD5/SHA-1
Critical pms comp.
block borders
128, 239, 367, ...
64, 119, 183, ...
110, 238, 366, ...
45, 54, 55, 56, 99, 118,
119, 120, ...
Table 2: Key derivation properties of non-PSK cipher suites.
The ﬁrst and second column provide the protocol version,
cipher suite, and the hash algorithms used in the key derivation
function. The last column provides critical block borders for
premaster secrets pms in bytes. For example, a 239-byte long
pms consumes one less SHA-384 hash compression than a
240 bytes long pms.
TLS 1.2. In TLS 1.2 the master secret is derived from an
HMAC-based PRF construction. The master secret is com-
puted as:
ms = PRF(pms,label,ClientRandom || ServerRandom) .
The premaster secret will be used as a key for HMAC op-
erations within the PRF. The used HMAC depends on the
selected cipher suite. Per default, SHA-256 is used, but the
cipher suite could also specify the usage of SHA-384 (if the
cipher suite name ends with _SHA384). For TLS 1.2 the side
channel analysis of Section 3 can be directly applied. The
premaster secret maximum size is the size of the DH key.
In conﬁgurations with recommended DH key sizes larger
than 2000 bits, the computed premaster secret will with over-
whelming probability be larger than the block border (64 bytes
for SHA-256 and 128 bytes for SHA-384). If the premaster
secret is larger than the block size of the hash function, it must
be hashed before using it in the HMAC computation. This
potentially enables a side channel based on the number of
hash compression function invocations (cf. Subsection 3.2).
USENIX Association
30th USENIX Security Symposium    219
Note that in the case of SHA-384-PRFs with DH key sizes
slightly bigger than 1024 bits, the hash function invocation
side channel and the resulting oracle OH can be used (see Sub-
section 3.1).
TLS 1.0 and TLS 1.1. These two protocol versions use the
same PRF, which is based on a combination of SHA-1 and
MD5. In this PRF, the premaster secret is split into two halves:
The ﬁrst half enters an expansion function based on MD5,
while the second half enters a distinct key expansion function
based on SHA-1. The ﬁnal output of the TLS 1.0 and 1.1 PRF
is the XOR of these two expansion functions. If the premaster
secret has an odd number of bytes, the byte in the middle of
the PMS will be used by both halves.
Since TLS 1.0 and TLS 1.1 split the shared secret into
two halves, the computations for inputs that reach the block
borders changes in comparison to TLS 1.2, as each hash
function adds its own padding and length bytes internally.
Note that since two hash functions are used at the same time
(with identical input lengths and hash function properties such
as input block size, length, and padding, see Table 1), the
created side channel is ampliﬁed. For TLS 1.0 and TLS 1.1
the size of inputs which leak the top x leading zero bytes at
the nth block border can be computed with the formula
cbbTLS1.0/1.1(x,n) = (64n− 9)· 2 + x ,
(2)
where x is the number of most signiﬁcant bytes to be leaked.
SSLv3. Even though SSLv3 is deprecated, there still exist
servers on the web which support it.5 SSLv3 key derivation is
strictly different from the key derivation used in TLS. While
the leading zero bytes from the premaster secret are stripped,
the master secret is then computed as
ms :=MD5(pms || SHA1(pms || ”A” || r1 || r2)) ||
MD5(pms || SHA1(pms || ”BB” || r1 || r2)) ||
MD5(pms || SHA1(pms || ”CCC” || r1 || r2)) ,
(3)
where r1 := ClientRandom and r2 := ServerRandom.
This computation results in more opportunities for an at-
tacker to construct a possible side channel from an additional
hash function compression invocation. The outer MD5 func-
tions hash the shared secret in concatenation with the output
of the inner SHA-1 function. The outer function adds an off-
set of 20 bytes to the shared secret. As this operation is done
three times, the side channel within the MD5 computation
is ampliﬁed by a factor of three. The inner SHA-1 computa-
tion hashes different inputs each time. The ﬁrst call hashes
a label of length 1, while the second call hashes a label of
length 2, and the last call hashes a label of length 3. Each time
two (32-byte long) random values of the client and server are
hashed as well. This generates a total offset of 65, 66 and 67
bytes, respectively. The resulting inputs (in bytes) which leak
5According to the SSL pulse measurements of September 2020, SSLv3
is supported by 4.4% of the servers from the Alexa top 150k list.
the top x leading zero bytes at the nth block in SSLv3 can
therefore be computed as:
cbbSSL(x,n) = 64n− (9 + 20) + x
cbbSSL−A(x,n) = 64n− (9 + 65) + x; n > 1
cbbSSL−BB(x,n) = 64n− (9 + 66) + x; n > 1
cbbSSL−CCC(x,n) = 64n− (9 + 67) + x; n > 1
(4)
TLS DHE-PSK. Although not as widespread, TLS also of-
fers a variety of cipher suites that allow the usage of preshared
keys (PSK) [31]. In DHE-PSK, the client basically performs
the same handshake as a normal DHE handshake, resulting in
the shared DH value gab mod p. Then, both client and server
authenticate using a premaster secret which is computed based
on the preshared key PSK as
pms := len(gab mod p) || gab mod p || len(PSK) || PSK ,
(5)
where len(x) indicates a two-byte length value of x (in bytes).
Since DHE-PSK changes the way the premaster secret is
computed, the block borders for the Raccoon attack change
as well. Interestingly, the block borders depend on the length
of the preshared key PSK. DHE-PSK shifts the length of the
PMS, which enters the PRF by 4 +|PSK| bytes. This can
bring otherwise unfeasible modulus sizes in proximity to the
critical block border for the attacker. An attacker being able to
set a PSK for an arbitrary, attacker-controlled identity could
therefore choose a PSK to reach the advantageous critical
block boundaries. A related side channel exists in SSH and is
described in Section 8.
If the attacker is not an authenticated user, they could use
the DHE-PSK premaster secret processing within the PRF
to perform a different length-distinguishing attack. Since
the PSK length also directly inﬂuences the PRF computation
time, the server response time could be used to determine
the length of the PSK. Note that this is possible even if the