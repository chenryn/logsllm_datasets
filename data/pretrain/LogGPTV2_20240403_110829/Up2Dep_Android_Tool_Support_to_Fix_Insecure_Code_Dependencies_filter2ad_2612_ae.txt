buzzword?-mapping research on security in devops. In 2016 11th International
Conference on Availability, Reliability and Security (ARES). IEEE, 542–547.
[38] D. C. Nguyen, E. Derr, M. Backes, and S. Bugiel. 2019. Short Text, Large Effect:
Measuring the Impact of User Reviews on Android App Security & Privacy.
In 2019 2019 IEEE Symposium on Security and Privacy (SP), Vol. 00. 155–169.
https://doi.org/10.1109/SP.2019.00012
[39] Duc Cuong Nguyen, Dominik Wermke, Yasemin Acar, Michael Backes, Charles
Weir, and Sascha Fahl. 2017. A Stitch in Time: Supporting Android Developers
in Writing Secure Code. In Proceedings of the 2017 ACM SIGSAC Conference on
Computer and Communications Security (Dallas, Texas, USA) (CCS ’17). ACM,
New York, NY, USA, 1065–1077. https://doi.org/10.1145/3133956.3133977
[40] Hiroki Ogawa, Eiji Takimoto, Koichi Mouri, and Shoichi Saito. 2018. User-Side
Updating of Third-Party Libraries for Android Applications. In 2018 Sixth In-
ternational Symposium on Computing and Networking Workshops (CANDARW).
IEEE, 452–458.
[41] Sebastian Poeplau, Yanick Fratantonio, Antonio Bianchi, Christopher Kruegel,
and Giovanni Vigna. 2014. Execute This! Analyzing Unsafe and Malicious Dy-
namic Code Loading in Android Applications.. In NDSS 2014, Vol. 14. 23–26.
[42] Sazzadur Rahaman, Ya Xiao, Sharmin Afrose, Fahad Shaon, Ke Tian, Miles
Frantz, Murat Kantarcioglu, and Danfeng (Daphne) Yao. 2019. CryptoGuard:
High Precision Detection of Cryptographic Vulnerabilities in Massive-sized Java
Projects. In Proceedings of the 2019 ACM SIGSAC Conference on Computer and
Communications Security (London, United Kingdom) (CCS ’19). ACM, 2455–2472.
https://doi.org/10.1145/3319535.3345659
[43] S. Shuai, D. Guowei, G. Tao, Y. Tianchang, and S. Chenjie. 2014. Modelling
Analysis and Auto-detection of Cryptographic Misuse in Android Applications.
In 2014 IEEE 12th International Conference on Dependable, Autonomic and Secure
Computing. 75–80. https://doi.org/10.1109/DASC.2014.22
[44] Ryan Stevens, Clint Gibler, Jon Crussell, Jeremy Erickson, and Hao Chen. 2012.
Investigating user privacy in android ad libraries. In Workshop on Mobile Security
Technologies (MoST), Vol. 10.
[45] Raja Vallée-Rai, Etienne Gagnon, Laurie Hendren, Patrick Lam, Patrice Pominville,
and Vijay Sundaresan. 2000. Optimizing Java bytecode using the Soot framework:
Is it feasible?. In International conference on compiler construction. Springer, 18–34.
[46] Takuya Watanabe, Mitsuaki Akiyama, Fumihiro Kanei, Eitaro Shioji, Yuta Takata,
Bo Sun, Yuta Ishi, Toshiki Shibahara, Takeshi Yagi, and Tatsuya Mori. 2017. Under-
standing the Origins of Mobile App Vulnerabilities: A Large-scale Measurement
Study of Free and Paid Apps. In Proceedings of the 14th International Conference
273ACSAC 2020, December 7–11, 2020, Austin, USA
Duc Cuong Nguyen, Erik Derr, Michael Backes, and Sven Bugiel
on Mining Software Repositories (Buenos Aires, Argentina) (MSR ’17). IEEE Press,
Piscataway, NJ, USA, 14–24. https://doi.org/10.1109/MSR.2017.23
[47] Jiexin Zhang, Alastair R. Beresford, and Stephan A. Kollmann. 2019. LibID: Reli-
able Identification of Obfuscated Third-Party Android Libraries. In Proceedings of
the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis
(Beijing, China) (ISSTA 2019). Association for Computing Machinery, New York,
NY, USA, 55–65. https://doi.org/10.1145/3293882.3330563
A SURVEY QUESTIONS
A.1 App Development
Q1: How do you prefer getting update notifications? [multiple
choice]
• Yellow highlighting on the dependency version
• Pop up when new versions are available, with “Ignore” option
• When I build/compile my project?
• Other [free text]
Q2: Based on which criteria do you usually pick a library for
your projects? [multiple choice]
• Popularity
• Easy to use
• Functionality
• Security
• Other
Q3: Have you developed any third-party libraries?[Yes/No]
• Yes: Which library is that? [freetext]
• No
Q4: How would you rate the security (whether a given version
has security vulnerability) of libraries you decide to include it into
your projects [single choice]
1-5
Q5: Did you notice any highlights regarding outdated library
versions in your app’s Gradle files? [single choice]
• Yes
• No
• I don’t know
Q6: Where do you reach out for help while solving programming
tasks that relate to third-party libraries? [multiple choice]
• StackOverflow
• Search engines
• Third party library’s website
• Other [free text]
A.2 Up2Dep Usage
Q7: How did you get to know Up2Dep? [multiple choice]
• Friends, colleagues
• IntelliJ IDEA/Android Studio repository
• Twiter
• Android Developer Conference
• Other
Q8: Which features of Up2Dep do you find useful? (screenshots
are included for each feature)
• Compatibility check (compatible version vs. latest version)
• Insecure version check
• Crypto API misuse check
• Show dependencies and alternative API suggestions
• Other [free text]
Q9: Since you started using Up2Dep, how many outdated li-
braries have you updated?
• 0
• 1
• More than 2
• Other [free text]
A.3 Up2Dep Usability - SUS Questions
Q10: For each of the following statements, how strongly do you
agree or disagree (Strongly disagree, disagree, neutral, agree, strongly
agree)
to be able to use Up2Dep.
• I think that I would like to use Up2Dep frequently.
• I found Up2Dep unnecessarily complex.
• I thought Up2Dep was easy to use.
• I think that I would need the support of a technical person
• I found the various functions of Up2Dep were well inte-
• I thought there was too much inconsistency in Up2Dep.
• I would imagine that most people would learn to use Up2Dep
• I found Up2Dep very cumbersome to use.
• I felt very confident using Up2Dep.
• I needed to learn a lot of things before I could get going with
very quickly.
grated.
Up2Dep.
A.4 Demographic
Q11: How many years have you been programming in Android?
• less than 1 year
• around 2 years
• around 3 years
• more than 3 years
Q12: How old are you?
• 18–30
• 31-40
• 41-50
• >50
• No answer
Q13: What is your gender?
• Male
• Female
• No answer
Q14: How many apps have you developed so far?
• 1
• 2
• more than 2
• 0
Q15: Do you have IT-Security background?
• Yes
• No
Q16: Where are you from? [free text]
274Up2Dep: Android Tool Support to Fix Insecure Code Dependencies
ACSAC 2020, December 7–11, 2020, Austin, USA
{
1 ext . supportVersio n = 2 5 . 3 . 1
2 dependencies
3
4
5
implementation ' com . example : magic : 1 . 2 . 1 '
/ / or
implementation group :
' 1 . 2 . 2 '
' com . example ' , name :
v e r s i o n :
' magic ' ,
6
7
8
/ / dependencies use v a r i a b l e as v e r s i o n s t r i n g
implementation ' com . android . support :
support −v4 : $supportVersion '
implementation ' com . android . support :
appcompbat−v7 : $supportVersion '
9 }
Listing 1: Declaring external dependencies in Android
projects.
B BACKGROUND
We will briefly provide information on the Gradle build system and
Android Studio plugin development.
B.1 Gradle Build Tool in Android Studio
Android Studio uses Gradle Build Tool [2] as an Android Studio
plugin to automate and to manage the app build process. The Gradle
build system eases the task of including internal and/or external
libraries to app builds as dependencies. In our work, we do not take
into account local binary dependencies, e.g., jar files that develop-
ers manually download and import into their projects because the
majority of third-party libraries are included in Android projects
via central repositories. Besides, for local module dependencies and
local binary dependencies, the exact version information is not
available, one can only profile the binary files and provide approxi-
mate matches which would add up another factor of uncertainty.
Listing 1 shows examples of how developers can declare their
project’s external dependencies in Android Studio. On line 3, compo-
nents of a dependency’s information are colon-separated, group_id:-
artifact_id:version, while on line 5, they are declared as key-values.
From this information, when developers choose to sync their project’s
dependencies, Gradle will sync such dependencies from the default
repository (e.g., JCenter or Maven) or the ones declared in the
gradle.settings file of the app project. Besides, developers can also
declare version strings as a variable (line 1) and use this variable for
the external dependency’s version (lines 7,8). This helps developers
avoiding repeatedly specifying (and updating) version strings for
multiple libraries from the same group (e.g., com.android.support)
that use the same version string.
B.2 Android Studio Plugin
Android Studio is based on Jetbrain’s IntelliJ IDEA. Therefore, to
develop an Android Studio plugin one needs to create an IntelliJ
IDEA plugin that targets Android Studio. The IntelliJ platform
provides tools designed for static code analysis, i.e., inspections
that allow developers to check for potential problems in the source
code. Examples of such inspections are finding probable bugs, dead
code, performance issues, improving code structure and quality,
or examining coding practices and guidelines. In the following,
we describe how code inspection and quick-fixes work in IntelliJ
IDEA/Android Studio. Code inspection in Android Studio leverages
the program structure interface (PSI) to analyze source code files of
a project. PSI is responsible for parsing files and creating syntactic
as well as semantic code models. This allows the IDE to efficiently
perform static code analysis on a project’s source code such as
identifying code inconsistency, probable bugs, and specification
violations. There are two main program structure interfaces in
IntelliJ IDEA namely PsiFile and PsiElement. PsiFile represents the
content of a code file as a hierarchy of elements (so-called PsiTree).
Each specific programming language can extend the PsiFile base
class to have its own representation, such as PsiJavaFile for Java
language, GroovyFileBase for Groovy language, or KtFile for Kotlin
language. PsiElements are used to explore the internal structure of
a project’s source code by the IntelliJ platform.
Specifically, PsiElements are used to perform code inspection
and quick-fixes on IntelliJ IDEA/Android Studio projects. When
a quick-fix is applied, PsiElements are updated, removed from, or
additionally added to an existing PsiFile.
To analyze developer’s code, one can extend the InpsectionPro-
fileEntry class to build a PsiElementVisitor that traverses through
all PsiElements belonging to a PsiFile. Each PsiElement corresponds
to a keyword, a variable, or an operation in a particular language.
To apply a quick-fix, e.g., updating a dependency declared in the
file build.gradle of an Android project (see Appendix B.1), a new
PsiElement representing a newer version is created and replaces the
existing PsiElement that represents the outdated library’s version.
Figure 7: Invitation to our online survey inside Android Stu-
dio.
Table 1: Participant demographics of online survey.
Age
Gender
Based
Programming Experience (years)
Apps Developed
IT-Security Background
18-30
No answer
Male
No answer
Europe
Asia
Other
3
>2
2
1
0
Yes
No
22
1
21
2
13
9
1
10
5
4
4
12
6
2
3
17
6
275ACSAC 2020, December 7–11, 2020, Austin, USA
Duc Cuong Nguyen, Erik Derr, Michael Backes, and Sven Bugiel
Figure 8: Up2Dep warns against using an insecure library version (with publicly disclosed vulnerability).
Figure 9: Up2Dep warns against re-using a cryptographic API misuse in a library.
Figure 10: Up2Dep shows how developers can migrate their project dependencies to the latest version when incompatibility
between library versions occurs, i.e., the return type of method load has changed from RequestBuilder to RequestCreator.
Figure 11: Up2Dep warns against an outdated library.
Figure 12: Up2Dep provides different options to update an outdated library version.
276