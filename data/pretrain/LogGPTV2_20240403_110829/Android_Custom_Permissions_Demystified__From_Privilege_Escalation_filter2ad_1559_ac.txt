6Note that it does not mean that these permissions have been granted to the
seed app. In fact, the granting of dangerous system permissions needs the
user’s consent, and the signature ones cannot be granted to the apps signed
by different certiﬁcates from system apps.
Seed GenerationSeed GenerationTest Case ConstructionTest Case ConstructionTest App DatasetEffective CasesTest CasesExtract Critical Paths• In the single-app mode, the test app must exist on the
phone after executing the last operation. In other words,
the permission requests must exist at last.
• The OS update operation only can be executed once. Our
test focuses on the lasted version of Android OS and thus
only considers updating the OS from the previous version
to the current version.
Besides, we can control the fuzzing testing scale by limiting
the number of seed apps and test cases deriving from one seed
app.
Fig. 3: Construct a test case (an execution sequence).
C. Test Case Execution
meeting the requirements: app installation, app uninstallation,
app update, and OS update. All of them can trigger the system
to refresh the granting status of existing permissions.
• When installing a new app, new custom permission
deﬁnitions may be added to the system.
• When uninstalling an app, existing custom permission
deﬁnitions may be removed.
• When updating an app, existing custom permission deﬁ-
nitions may be updated or removed.
• During major OS updates, new system permissions may
be added to the system, and existing system permissions
may be removed.
Note that, considering that updating an app is installing
(different versions of) this app multiple times, we do not need
to indicate the app update operation in test cases.
Mutating Test App. In the app installation operation, the test
app to install is the mutated version of the previously installed
test app, say the same package name and app signature.
It changes some attributes (group and protection level) of
the previously deﬁned custom permission or removes this
permission deﬁnition directly. For example, it changes the
protection level from normal to dangerous and puts the
custom permission into the PHONE group. The permission name
cannot be changed. Otherwise, it will deﬁne a new permission.
Also,
the app deﬁning the custom
permission is treated as the test app because we do not change
the permission requests in the whole operation sequence.
Test Case Construction. When CUPERFUZZER constructs a
test case, it randomly selects uncertain amount of operations
from the {app installation, app uninstallation, OS update} to
generate an execution sequence.
in the dual-app mode,
Also, to generate a meaningful test case, we set the follow-
ing restrictions.
• The ﬁrst operation must be seed app installation because
the fuzzing execution environment (physical phone) will
be reset before every test.
• Before executing an app uninstallation operation, there
must exist a test app for uninstalling. Uninstalling a non-
existing app is meaningless.
75
In this step, CUPERFUZZER dynamically executes the op-
erations in test cases in order. All operations are conducted
on physical devices equipped with AOSP Android OS, e.g.,
Google Pixel series phones. The reasons for not using Android
emulators (virtual devices) include:
• Emulators do not support the OS update operation.
• The images of emulators may exist undocumented mod-
iﬁcations to adapt to the underlying hardware.
Parallel Case Execution. To facilitate the execution of test
cases on physical devices, a computer is used as the controller
to send test cases and monitor the execution status. The com-
munication between them is supported by adb (Android Debug
Bridge), a versatile command-line tool. Also, CUPERFUZZER
supports parallel execution by increasing the number of test
devices. It can assign test cases to different devices to achieve
the load balance during the testing.
As mentioned before, there are three kinds of operations
in a test case. Among them, the app installation (uninstal-
lation) operation can be executed through the adb install
(uninstall) command directly. To the OS update operation,
we combine the capabilities of adb and fastboot to automate
this process, that is, rebooting the device into the fastboot
mode and ﬂashing a new OS image (without wiping data).
Environment Reset. After completing a test case execution,
the test environment will be reset to the factory default status.
It should be noted that, in general, the user needs to manually
authorize to allow the computer to interact with a device
through adb. However, once the device is reset (through a
factory reset or OS downgrade), the previous authorization
status will be erased, breaking the adb communication. To
solve this issue, we can modify the source code of Android
OS and compile a special version of the target OS image for
test devices, which skips the authorization step and keeps adb
always open. More speciﬁcally, in the build.prop ﬁle of the
image, if ro.adb.secure is set to 0, the device will trust
the connected computer by default without user authorization.
Also, the image can be built with the userdebug type option
to support the always-open adb debugging [6].
D. Effective Case Checking
To each completed test case, CUPERFUZZER needs to check
whether it is an effective case that achieves privilege escala-
tion. An effective case can be determined through checking
...Install seed app(s)Install seed app(s)Install new test appInstall new test appOperation-1Operation-2Uninstall test appUninstall test appOS updateRandomly select an operation.the granting status of the requested permissions in the test
app (or the app requesting permissions in the dual-app mode).
Expressly, we set the following two rules.
• Rule 1: The test app (or the app requesting permissions
in the dual-app mode) has been granted a dangerous
permission without user consent.
• Rule 2: The test app (or the app requesting permissions
in the dual-app mode) has been granted a signature
permission, but the test app and the app deﬁning this
permission are signed by different certiﬁcates.
Note that,
in the whole process of test case execution,
CUPERFUZZER does not grant any dangerous permission to
the test app through simulating user interactions.
To automate this checking, CUPERFUZZER uses adb to
obtain the permission granting list of the test app (or the app
requesting permissions in the dual-app mode) and extracts the
granted permissions. If there exists any granted dangerous or
signature permission matching the above rules, this test case
is effective and will be recorded for further analysis.
A. Prototype Implementation
We implemented a full-feature prototype of CUPERFUZZER
with around 653 lines of Python code. Besides, in order to
make our framework fully automated, we integrated several
tools into it. For example, as mentioned in Section IV-C, adb
and fastboot are used for device control and OS update.
For test app generation, Apktool [2] and jarsigner [20]
are integrated. Since our fuzzer needs lots of test apps, it is
impractical to generate them manually. In our implementation,
we ﬁrst use Android Studio to build a signed APK ﬁle that
declares a custom permission. Then, CUPERFUZZER decodes
this APK ﬁle using Apktool to obtain its manifest ﬁle. When
generating a new app declaring a new custom permission,
CUPERFUZZER replaces the old permission deﬁnition with
the new one (in the manifest) and then repackages the decoded
resources back to an APK ﬁle using Apktool as well. Finally,
CUPERFUZZER uses jarsigner to sign the APK ﬁle, and a
new signed APK ﬁle is built. Therefore, the whole process can
be completed automatically.
E. Critical Path Extraction
B. Experiment Setup
After obtaining all effective test cases, CUPERFUZZER
extracts the critical paths to assist the cause identiﬁcations.
A critical path is deﬁned as the least necessary operations
to trigger a privilege escalation issue. An effective test case
contains multiple operations, and some operations are not
related to the ﬁnal privilege escalation. Also, many similar
effective cases may be discovered in the test and contain the
same critical path. CUPERFUZZER extracts the critical paths
through the following steps:
(1) Test Cases Classiﬁcation. Discovered effective cases are
classiﬁed into different categories according to their execution
results. The test cases in the same category should lead to the
same permission granting.
(2) Find Critical Path. In each category, we ﬁnd the test
cases with the least operations, called candidate cases. To
a randomly selected candidate case, we delete its ﬁrst / last
operation (including the operation of seed installation) and
execute this case again. If the same execution result occurs,
we add this pruned case into this category and repeat this
step. If it is different, we obtain a critical path (the operation
sequence of this candidate case) and record this path.
(3) Delete Duplicate Cases. In the same category,
if an
effective case contains the extracted critical path, this case
will be deleted. Note that, in this matching process, we do
not require that the installed apps used in the operation of app
installation are the same. We repeat Step 2 and Step 3 until
all effective cases have been deleted.
Based on the extracted critical paths, we try to determine
the root causes of the discovered effective cases by analyzing
the source code of Android OS.
V. IMPLEMENTATION AND EXPERIMENT RESULTS
In this section, we present the prototype implementation of
CUPERFUZZER and summarize the experiment results.
Hardware Setup. In our experiments, we deployed a laptop
(Windows 10, 4G RAM, Intel Core i5) as the controller and
four Google Pixel 2 phones as the case execution devices. The
controller can assign test cases to different phones for parallel
execution.
Android OS. Our experiments focused on the custom per-
mission security issues on the latest version of Android OS,
which is Android 10. Following the approach described in
Section IV-C, we built two versions of Android OS images
for Pixel 2 based on the source code of AOSP Android 9
(PQ3A.190801.002) and 10 (QQ3A.200705.002). Note that
we only modiﬁed the adb connection and screen locking
related system parameters. CUPERFUZZER executes a test
case containing OS update operations on the devices equipped
with Android 9 and ﬂashes the Android 10 image (without
wiping data) to achieve the OS update. Other test cases are
executed on the devices equipped with Android 10.
Test Case Optimization. Since the amount of generated test
cases can be inﬁnite in theory and dynamic execution is time-
consuming, we set some optimization measures to control
the experiment scale and improve the vulnerability discovery
efﬁciency.
Operations. If a test case contains many operations, it is too
complex to be exploited in practice. Therefore, we empirically
limited that a test case only can contain up to ﬁve operations
(without counting the operation of seed app installation).
Seed apps. When generating a seed app, the name of the
deﬁned custom permission is a variable and cannot be the
same as a system permission. In order to follow this rule,
we extracted all declared system permissions7 from Android
9 and Android 10. The results showed there are 88 system
7Obtained through adb shell pm list permissions -f -g on Pixel 2.
76
permissions (3 for normal, 3 for dangerous, and 82 for
signature) which exist in Android 10 but not in Android 9,
as listed in Appendix A. Therefore, we randomly selected one
permission name from the new dangerous system permissions
and the new signature system permissions respectively, and
constructed the following pre-deﬁned permission name list for
seed apps to handle this special situation.
• android.permission.ACTIVITY_RECOGNITION
(new dangerous system permission in Android 10)
• android.permission.MANAGE_APPOPS
the seed apps with the ﬁrst
(new signature system permission in Android 10)
• com.test.cp (a general custom permission name)
Note that
two permission
names are only used to construct the test cases containing
the OS update operation. The last permission name is used
to construct all kinds of test cases. Also, we do not use the
name of a new normal system permission added in Android
10 because normal permissions will be granted automatically.
Since we have 2 seed generation models, 3 available per-
mission names, 3 kinds of protection levels, and 12 system
permission groups8 (as listed in Appendix B), the combina-
tions of custom permission attributes could be calculated as
Combinations = 2×3×3×13 (12 groups and no group) = 234
Therefore, 234 kinds of seed apps can be selected for our
experiments in total.
Execution sequence. An app execution sequence (test case)
will be generated based on a selected seed app. Since there
are 3 kinds of protection levels and 13 kinds of groups, the
subsequent app installation operation can install 40 (3×13 + no
custom permission deﬁnition) kinds of mutated test apps. If an
execution sequence contains three app installation operations
(without including the installation of the seed app), there will
be 64,000 (40×40×40) combinations, which is quite large. On
the other hand, we hope CUPERFUZZER can perform different
execution sequences as many as possible. Therefore, we set the
following restriction: when generating a new test app, only
one attribute can be changed differently from the previously
installed test app, say protection level or group. Under this
restriction, the kinds of mutated test apps become 15, and the
combinations of three app installation operations have been
reduced to 3,346.
Test Case Execution. After applying the above measures, a
seed app can still generate lots of test cases. To balance
the coverage of test cases from different seeds, we used the
following case execution method. CUPERFUZZER randomly
selects a seed app and executes a test case generated from it.
This process is repeated until all test cases have been executed
or the controller interrupts the testing.
C. Result Summary
During our experiments, CUPERFUZZER executed 40,195
test cases on four Pixel 2 phones in 319.3 hours (around 13.3
days) until we stopped it.
8Obtained through adb shell pm list permission-groups on Pixel 2.
77
TABLE III: Average execution time of the operation.
Operation Type
Operation
Case execution
Environment reset
App installation
App uninstallation
OS update
Factory reset
OS downgrade
Time Cost
(second)
1.1
0.5
109.8
60.2
129.5
Efﬁciency. On average, CUPERFUZZER costed 114.4s to
execute a test case in the experiment, which is slower than
the case execution in an ideal situation (without execution
errors). The extra time cost came from error handling. Among
the 40,195 test cases, 4,788 cases (around 11.9%) cannot be
executed successfully for the ﬁrst time, and CUPERFUZZER
skipped them. The main reason is that when multiple devices
enter the fastboot mode at the same time, reading or writing
data may fail with an error message, such as "status read failed
(too many links)" or "command write failed (unknown error)".
Under this situation, the device is unable to reboot normally
and has to go through environment reset. Note that we do not
retest the failed cases because there are many cases waiting
for testing, and such a retest step will increase the complexity
of execution logic.
In Table III, we list the average time cost of operation
execution and environment reset in an ideal situation (i.e.,
every operation is executed successfully). The time cost of an
upgrade or downgrade operation includes the cost of ﬂashing
images and device reboot.
Results. Finally, CUPERFUZZER discovered 2,384 effective
test cases which triggered privilege escalation issues. All these
issues were matched by the ﬁrst checking rule deﬁned in
Section IV-D, say obtaining dangerous permissions without