bit of the data ﬁle in the setup, while the proposed scheme
requires one group multiplication per each chunk of data bits
2.2 Related work
Recently, there are extensive studies [1–3, 7–10, 13, 15,
20, 21, 26, 28, 29] on remote data integrity check. Juels
and Kaliski [21] presented a strong security model called
“Proofs of Retrievability” (POR) and a POR scheme with
bounded-use, and Ateniese et al. [1, 3] gave an efﬁcient
scheme which is secure under a weaker “Provable Data
Possession” (PDP) model. Efﬁcient methods using some
sorts of homomorphic authentication tag are proposed in
[2, 9, 26]. Dynamic-PDP [15] extends to dynamic setting,
public veriﬁability is exploited in Shacham and Waters [26]
and Wang et al. [29], and the privacy issue in public veriﬁca-
tion is studied in Wang et al. [28]. Readers can refer to Yang
and Jia [30] for a survey of secure cloud storage.
required to compute the product(cid:81)
The most efﬁcient variant scheme E-PDP in Ateniese et
al. [1] suffers from the attack by Shacham and Waters [26].
In the main scheme of Ateniese et al. [1], the prover is
for all tags
Ti selected by the challenge Chal. The authors proposed
an efﬁcient variant scheme, named E-PDP, by setting all
coefﬁcients ai in the challenge Chal as 1, so that only
multiplication is involved and expensive exponentiation is
avoided. Shacham and Waters [26] presented an attack on
E-PDP, such that the adversary can answer correctly a non-
negligible fraction of queries, but there exists no extractor
that can recover any data block.
Dodis et al. [13] reduces the communication cost of SW
scheme from O(λ2) to O(λ) in the special case where s = 1
and the size of all authentication tags is equal to the size of
error erasure encoded ﬁle.
(i,ai)∈Chal Tai
i
Kate et al. [22] proposed an efﬁcient commitment scheme
for polynomial and Benabbas et al. [4] proposed a veriﬁable
delegation scheme for polynomial. Both schemes alone can
be extended to support POR easily but with limitations:
The POR scheme in Benabbas et al. [4] requires only O(λ)
bits response per veriﬁcation due to their newly constructed
veriﬁable delegation scheme for polynomial. However, in
this scheme, the size of all authentication tags is also equal
to the size of error erasure encoded ﬁle. In a POR scheme
implied by Kate et al. [22], either every bit in the data
1 In contrast, the public key of Ateniese et al. [1] is only O(λ) bits long.
Notation Semantics
x $←− S
λ
s
Uniformly randomly choose x from the ﬁnite set S.
Bit-length of group size, i.e. group size is 2λ.
The number of group elements in a data block. Typi-
cally, an authentication tag consists of one group
element. So s is also the ratio of the size of a data
block to the size of an authentication tag.
The number of data blocks accessed during a veriﬁ-
cation.
The number of data blocks in an encoded data ﬁle.
Thus the size of an encoded data ﬁle is nsλ bits.
A vector of form (m0, m1, m2, . . . , md−1), where d
is the dimension of vector (cid:126)m.
A polynomial m0 + m1x + m2x2 + . . . + md−1xd−1
of degree d− 1 with vector (cid:126)m as coefﬁcient, where d
is the dimension of vector (cid:126)m.
Pseudorandom function [18].
Proofs of Retrievability [21].
Provable Data Possession [1].
Efﬁcient Proofs of Retrievability; it is the name of the
scheme proposed in this paper.
(cid:96)
n
(cid:126)m
f (cid:126)m(x)
PRF
POR
PDP
EPOR
Table 1. Summary of Key Notations in this paper.
ﬁle has to be accessed during each veriﬁcation, or there is
linear storage overhead w.r.t. the number of ﬁle blocks on
data owner side. We will elaborate more on the polynomial
commitment scheme [22] in Section 4.
3. Formulation
The key notations used in this paper are summarized in
Table 1.
3.1 System Model
We restate the POR [21, 26] model as below, with slight
modiﬁcations on notations. We adopt the 1-round prove-
verify version in Juels and Kaliski [21] for simplicity.
DEFINITION 1 (POR [21, 26]). A Proofs Of Retrievabil-
ity (POR ) scheme consists of four algorithms (KeyGen,
DEncode, Prove, Verify):
• KeyGen(1λ) → (pk, sk): Given security parameter
λ, the randomized key generating algorithm outputs a
public-private key pair (pk, sk).
• DEncode(sk, M) → (idM, ˆM): Given the private key
sk and a data ﬁle M, the encoding algorithm DEncode
produces a unique identiﬁer idM and the encoded ﬁle
ˆM.
• Prove(pk, idM, ˆM, C) → ψ: Given the public key pk,
an identiﬁer idM, an encoded ﬁle ˆM, and a challenge
query C, the prover algorithm Prove produces a proof ψ.
• Verify(sk, idM, C, ψ) → accept or reject: Given the
private key sk, an identiﬁer idM, a challenge query
C, and a proof ψ, the deterministic verifying algorithm
Verify will output either accept or reject.
Completeness. A POR scheme (KeyGen, DEncode, Prove,
Verify) is complete, if an honest prover (who ensures the
integrity of his storage and executes the procedure Prove
to compute a proof) will always be accepted by the veri-
ﬁer. More precisely, for any key pair (pk, sk) generated by
KeyGen, and any data ﬁle M, any challenge query C, if
ψ ← Prove(pk, idM, ˆM, C), then Verify(sk, idM, C, ψ)
outputs accept with probability 1, where (idM, ˆM) ←
DEncode(sk, M).
3.2 Security Model
3.2.1 Trust Model and Scope of Topic
In a POR system, only the data owner is trusted and the
cloud storage server is treated as untrusted and potentially
malicious.
The following topics are out of the scope of this paper,
since most existing techniques in these topics can be applied
with our work: (1) Support of dynamic operations (e.g. in-
sertion or deletion of a data block after setup); (2) Denial of
Service Attack; (3) Frame attack where dishonest data owner
claims that an honest cloud storage server was cheating.
3.2.2 POR Security Game
We rewrite the POR security game in [21, 26] in a standard
way. The security game between a probabilistic polynomial
time (PPT) adversary A and a PPT challenger C w.r.t. a
POR scheme E = (KeyGen, DEncode, Prove, Verify) is
as below.
Setup: The challenger C runs the key generating algorithm
KeyGen to obtain public-private key pair (pk, sk), and gives
pk to the adversary A.
Learning: The adversary A adaptively make queries where
each query is one of the following:
• Store query (M): Given a data ﬁle M chosen by A, the
challenger C responds by running data encoding algo-
rithm (id, ˆM) ← DEncode(sk, M) and sending the en-
coded data ﬁle ˆM together with its identiﬁer id to A.
• Veriﬁcation query (id): Given a ﬁle identiﬁer id chosen
by A, if id is the ﬁrst part of output of some previous
store query that A has made, then the challenger C ini-
tiates a POR veriﬁcation with A w.r.t. the data ﬁle M
associated to the identiﬁer id in this way:
C chooses a random challenge Chal;
A produces a proof ψ w.r.t. the challenge Chal;
Note: adversary A may generate the proof in an ar-
bitrary method rather than applying the algorithm
Prove.
C veriﬁes the proof ψ by running algorithm Verify(sk,
id, Chal, ψ). Denote the output as b.
At the end C sends the decision bit b ∈ {accept, reject} to
A as feedback. Otherwise, if id is not in the output of any
previous store query that A has made, C does nothing.
Commit: Adversary A chooses a ﬁle identiﬁer id∗ among
all ﬁle identiﬁers she obtains from C by making store queries
in Learning phase, and commit id∗ to C. Let M∗ denote the
data ﬁle associated to identiﬁer id∗.
Retrieve: The challenger C initiates ζ number of POR
veriﬁcations with A w.r.t. the data ﬁle M∗, where C plays
the role of veriﬁer and A plays the role of prover, as in
the Learning phase. From messages collected in these ζ
interactions with A, C extracts a data ﬁle M(cid:48) using some
PPT extractor algorithm. The adversary A wins this game, if
and only if M(cid:48) (cid:54)= M∗.
The adversary A is -admissible [26], if the probability that
A convinces C to accept in a veriﬁcation in the Retrieve
E
phase, is at least . We denote the above game as Game
A(ζ).
DEFINITION 2 ([21, 26]). A POR scheme E is sound, if
for any PPT -admissible adversary A with non-negligible
, there exists a polynomial ζ, such that the advantage
Adv
E
A(ζ) deﬁned as below is negligible.
(cid:104)A wins Game
(cid:105)
E
A(ζ)
Adv
E
A(ζ) def= Pr
(1)
3.3 Assumption
DEFINITION 3 (s-SDH Assumption [5, 6]). Let p and q =
2p + 1 be prime, and QR be the subgroup with order p of
quadratic residues in Z∗
q. Let g be a random generator of
QR. Let α $←− Zp be chosen at random. Given as input
a tuple (p, q, T = (g, gα, gα2
)), for any PPT
adversary A, the probability
, . . . , gαs−1
w = g1/(α+c) where (c, w) = A(p, q, T )
Pr
(cid:105)
(cid:104)
is negligible in log p.
We remark that when our scheme is alternatively instan-
tiated over an elliptic curve group, the elliptic curve version
of Strong Difﬁe-Hellman Assumption is required.
4. Background on Polynomial Commitment
Scheme
Kate, Zaverucha and Goldberg [22] proposed a constant2
size commitment scheme for polynomial. This scheme has
a property which is desirable for our construction of POR
scheme, that is, their commitment scheme allows the com-
mitter of a polynomial f (x) to generate a constant size proof
for the correctness of the polynomial evaluation f (r) at any
particular point x = r. Their scheme exploits a simple and
elegant algebraic property of polynomials: For any polyno-
mial f (x) ∈ Zp[x] and for any scalar input r ∈ Zp, the
polynomial x − r divides the polynomial f (x) − f (r).
2 Here “constant size” means O(λ) bits where λ is the security parameter, in
other words, constant number of group elements where each group element
is λ bits long.
f (cid:126)m(x) ≡(cid:80)s−1
Let us denote with f (cid:126)m(x) ∈ Zp[x] the polynomial with
coefﬁcient vector (cid:126)m = (m0, . . . , ms−1) ∈ (Zp)s, that is,
j=0 mjxj. Let G and GT be two multiplicative
group of prime order p and e : G × G → GT be a bilinear
map.
j=0
(cid:16)
gαj(cid:17)mj
to commit a polynomial f (cid:126)m(x) := (cid:80)s−1
is, C := (cid:81)s−1
The commitment scheme [22] can be summarized as be-
low: In the setup, a trust party chooses a public key pk :=
) ∈ Gs, where g is a generator of group G
(g, gα, . . ., gαs−1
and α ∈ Zp is chosen at random and kept secret. In order
j=0 mjxj with coef-
ﬁcient vector (cid:126)m = (m0, . . . , ms−1) ∈ (Zp)s, a committer
can compute a commitment C using the public key pk, that
= gf (cid:126)m(α) ∈ G, and then publish
C. Later, for any scalar r ∈ Zp, the committer can compute
y := f (cid:126)m(r) ∈ Zp and generate a short proof ψ (or witness
as in [22]) to convince a veriﬁer that y is indeed the cor-
rect evaluation of f (cid:126)m(r), without revealing the polynomial
f (cid:126)m(x). The proof (or witness) ψ is generated in the follow-
ing steps:
1. Divide the polynomial f (cid:126)m(x) − f (cid:126)m(r) with (x − r)
using polynomial long division, and denote the coefﬁ-
cient vector of the resulting quotient polynomial as (cid:126)w =
(w0, w1, . . . , ws−2), that is, f (cid:126)w(x) ≡ f (cid:126)m(x)−f (cid:126)m(r)
(cid:16)
same way as computing gf (cid:126)m(α), i.e. ψ :=(cid:81)s−2
2. Then compute ψ := gf (cid:126)w(α) using the public key pk in the
.
gαj(cid:17)wj
x−r
j=0
= gf (cid:126)w(α) ∈ G.
After receiving (r, y, ψ) from the committer, a veriﬁer can
verify whether y ?= f (cid:126)m(r) with the proof ψ and public
) and the public commitment C
key pk = (g, gα, . . . , gαs−1
of the unknown polynomial f (cid:126)m(x), using a bilinear map 3
e : G × G → GT :
e(g,C)/e(g, g)y
?= e(ψ, gα/gr).
(2)