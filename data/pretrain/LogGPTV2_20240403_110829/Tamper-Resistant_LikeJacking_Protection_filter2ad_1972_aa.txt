title:Tamper-Resistant LikeJacking Protection
author:Martin Johns and
Sebastian Lekies
Tamper-Resistant LikeJacking Protection(cid:2)
Martin Johns and Sebastian Lekies
SAP Security Research
Germany
http://www.websand.eu
Abstract. The ClickJacking variant LikeJacking speciﬁcally targets
Web widgets that oﬀer seamless integration of third party services, such
as social sharing facilities. The standard defense against ClickJacking
is preventing framing completely or allowing framing only in trusted
contexts. These measures cannot be taken in the case of LikeJacking,
due to the widgets’ inherent requirement to be available to arbitrary
Web applications. In this paper, we report on advances in implement-
ing LikeJacking protection that takes the speciﬁc needs of such widgets
into account and is compatible with current browsers. Our technique is
based on three pillars: A JavaScript-driven visibility check, a secure in-
browser communication protocol, and a reliable method to validate the
integrity of essential DOM properties and APIs. To study our protec-
tion mechanism’s performance characteristics and interoperability with
productive Web code, we applied it to 635 real-world Web pages. The
evaluation’s results show that our method performs well even for large,
non-trivial DOM structures and is applicable without requiring changes
for the majority of the social sharing widgets used by the tested Web
applications.
1
Introduction
The days, in which a single application provider provided the code, as well as,
the content of a single Web application are long gone. Nowadays, mixing services
by multiple parties in the context of a single Web document is the norm and
not any longer the exception [23]. A major driving force of this development
are seamless sharing widgets, such as like buttons provided by social networks
like Facebook or Google Plus. These widgets allow one-click interaction with the
network without leaving the context of the page which hosts the widget. Potential
uses for such widgets are not reduced to social sharing but are increasingly
adopted by unrelated services. For instance, the micropayment service Flattr
oﬀers similar widgets1 to initiate payments directed to the widget’s hosting page.
While signiﬁcantly lowering the barrier to interact with the widget provider’s
services, such widgets also open the door for abuse: In the recent past, a variant
of the ClickJacking [1, 7, 12] attack, aptly named LikeJacking, appears in the
(cid:2) This work was in parts supported by the EU Project Web- Sand (FP7-256964).
1 Flattr tools: http://developers.flattr.net/tools/
S.J. Stolfo, A. Stavrou, and C.V. Wright (Eds.): RAID 2013, LNCS 8145, pp. 265–285, 2013.
c(cid:2) Springer-Verlag Berlin Heidelberg 2013
266
M. Johns and S. Lekies
wild repeatedly [21, 28] and has received considerable attention [12, 30]. As we
will discuss in Section 3.1, preventing LikeJacking attacks is non-trivial and,
unlike the X-Frames-Option-header [20] in the case of general ClickJacking, no
applicable, browser-based security measure exist.
Up to now, there is no reliable countermeasure against LikeJacking available,
forcing service operators either to expose their users to the risk or to break
the widget’s seamless interaction model [30]. For this reason, in this paper, we
investigate a protection approach that is speciﬁcally targeted at LikeJacking
attacks, to mitigate this currently unsolved security problem.
Contributions: In this paper, we make the following contributions:
– We propose a novel LikeJacking protection methodology that relies only on
JavaScript capabilities already present in today’s Web browsers, and hence,
can be adopted immediately. The proposed protection mechanism is based on
JavaScript-based checking of visibility conditions (see Sec. 4) and a secure
communication protocol between the protection script and the embedded
widget (see Sec. 5).
– Furthermore, we present a methodology to reliably check the integrity of an
existing DOM tree instance and the corresponding DOM APIs (see Sec. 6).
This methodology eﬀectively enables a JavaScript to validate its embedding
DOM, even in the context of untrusted Web documents. Furthermore, we
document how this technique can be implemented in a cross-browser fash-
ion and document that the process performs well even for large DOM tree
structures (see Sec. 7.2).
– Finally, as part of the protection measure’s evaluation, we report on a prac-
tical study, which examines how popular Web sites handle social sharing
widgets in respect to visibility properties (see Sec. 7.2).
2 Technical Background
2.1 Social Sharing Widgets
In the beginning of the Web, the content of a single HTML document was static
and originated from exactly one source: the hosting server. This changed soon
during the evolution of the Web. Nowadays, Web sites often include a multi-
tude of services from many diﬀerent third parties [23]. Due to the Same-Origin
Policy, however, interaction and integration of such third party services is not
straightforward. The technical methods of choice, for this purpose are script in-
cludes and iframe elements, which are nowadays omnipresent in the Web [16].
Nevertheless, when visiting a Web site, a non-technical user is not able to recog-
nize all the iframe elements as many Web sites use this technology to seamlessly
integrate third part content. Thereby, CSS style declarations are used to style
the iframe elements in a way that the content of the iframe appeals to be part
of the embedding page. Besides advertisement, this technique is increasingly
used to provide seamless interaction capabilities between diﬀerent Web appli-
cations. One such integration feature that received special attention lately are
Tamper-Resistant LikeJacking Protection
267
Social Sharing widgets. These widgets can be used to share arbitrary content
with your friends on your favorite social networks. Thereby, the social network
provides the sharing functionality in the form of a simple Web document that
can be embedded via an iframe into the page. As the social network’s cookies
are attached to all requests initiated by and within the iframe, the iframes UI
controls and scripts act in the name of the user towards the social network. One
important requirement for such a scenario is that the user is encouraged to use
the widget as both, the social network and the embedding page, have an interest
in the user’s social interaction. Therefore, the functionality should be as easy as
possible and ultimately only consist of one single click.
2.2 Click- and LikeJacking
The underlying security problem of Clickjacking was ﬁrst discovered by Ruder-
man in 2002 [25]. In the Mozilla bug tracking system he noted that transparent
iframes can lead to security problems. However, it took another 6 years until the
term Clickjacking was coined by Hansen and Grossman [7].
The term ClickJacking denotes a class of attacks, that aim to trick users
into interacting with cross-domain Web UIs without their knowledge. In gen-
eral, ClickJacking utilizes iframes which are hidden to the user, using varying
techniques. Instead the user is presented a completely diﬀerent UI which is posi-
tioned by the attacker either over or under the iframe. Hence, when attempting
to interact with the attacker’s fake UI, the user is actually clicking elements in
the hidden iframe. In particular, the following attack implementations have been
discussed and demonstrated:
Hiding the iframe via CSS: Several CSS properties, such as opacity or mask
can be used to render the target iframe completely transparent. This allows
it to position the attacker’s crafted GUI below the iframe. When the user
tries to click the fake elements, his click is received by the overlaying iframe.
Obstructing the iframe with overlaying elements: Alternatively to an in-
visible iframe and underlying fake GUI, also the opposite scenario is possible:
The adversary can also place his GUI elements on top of the iframe, thus,
completely or partially obstructing it. In such situation, he could either cover
everything but the button, that he wants the victim to click, or he could cover
it completely and set the overlay’s pointer-events-property to none, which
causes the clicks received by the overlay to be seamlessly passed on to the
underlying DOM elements, i.e., the target iframe.
Moving the iframe under the mouse pointer: Finally, the attacker could
render the iframe outside of the screen’s visible regions. Then, when he
anticipates a click from the user, e.g., in the context of a game, he can
quickly position the iframe under the user’s mouse.
2.3 Countermeasure
The currently established countermease against Clickjacking is frame busting.
The goal of frame busting is to forbid an untrusted site to frame a security sen-
sitive Web page. This can be achieved by including a small snippet of JavaScript
268
M. Johns and S. Lekies
into the security sensitive page. The script checks wether the page is framed and
if so it redirects the top browser window away from the untrusted site towards
the security sensitive site eﬀectively busting out of the frame. As shown by Ryd-
stedt et al. [26] many problems exist with practical implementations that allow
an attacker to circumvent the protective measures.
The X-Frame-Options response header also follows the idea of forbidding
framing to third-party Web sites [20]. The mechanism is not implemented in
JavaScript, but browser itself prevents the untrusted framing. Furthermore, if
there is an existing trust relationship between the involved sites, a Web document
can selectively allow being framed by some-origin pages or speciﬁcally whitelisted
sites, using the corresponding values for the header [20].
3 LikeJacking Protection via Visibility Proofs
3.1 Problem Statement
As discussed above, all currently available ClickJacking countermeasures require
a pre-existing trust relationship between the widget and the including domain.
On the most basic and best-supported level, this trust relationship is limited
to the widget’s ’own’ domain, using the X-Frame-Option header’s same-origin
directive. In the foreseeable future, as soon as the header’s Allow-from option
receives wider support, the widget can deﬁne a whitelist of domains that are
permitted to include the widget’s hosting frame.
However, in situations, in which a widget is designed to be included in arbi-
trary domains, as it is the case with social sharing widgets, the whitelisting ap-
proach does not work anymore. As it stands today, the widget is at the mercy of
the including page: It has to allow being framed generally and has only very lim-
ited means to obtain information on the actual framing context via its referrer
information, which is known to be unreliable [3, 14].
In [12] Huang et al. propose a browser provided mechanism to ensure that
visibility conditions of speciﬁed Web UI elements are ensured. Huang’s core
technique is currently under standardization by the W3C as a potential exten-
sion of the Content Security Policy (CSP) mechanism [19]. If this technique
would receive broad browser support in the future, it could be used as a suiting
mitigation strategy. Unfortunately, it is unknown if, when, and to which degree
the technique will actually be implemented in the Web browsers. Similar tech-
niques, which are discussed now for years, still have no broad browser support.
For instance, the highly useful Allow-from directive for the X-Frame-Options-
header, is still not fully supported by all browser, and up to now, there is no
deﬁnite commitment that Internet Explorer will implement CSP. Hence, it is
reasonable to assume, that native browser supported security measures will take
a considerable time.
Thus, for the time being, browser-provided means do not oﬀer the needed ﬂex-
ibility and security properties for the outlined Web widget use-cases. However,
as motivated in the beginning of this paper, LikeJacking is a real threat today.
For this reason, we investigated a solution that can be built with the means that
Tamper-Resistant LikeJacking Protection
269
Web browser oﬀer today. In the remainder of this paper we propose a solution
that satisﬁes the following criteria:
Visibility proof: The Web widget receives validation that its UI was visible to
the user during the user’s interaction with the widget.
Legacy browser compatibility: The aim of the proposed technology is to
provide protection today that is compatible with at least a signiﬁcant major-
ity of the currently deployed Web browsers. Thus, relying on future browser
features is out of scope for this paper.
Tamper resistance: Even under the assumption, that the widget is included in
an actively malicious page, the protection and validation mechanism should
either hold, or in unrecoverable cases, reliably detect potentially malicious
situation, so that the widget can react accordingly.
No disruption: In case of legitimate usage of the widget, the hosting page
should remain as unaﬀected as possible.
Based on these requirements, several implementation characteristics can be
deducted immediately: For one, it follows directly from the legacy browser com-
patibility requirement that the measure will rely on JavaScript to enforce the
desired properties. Furthermore, as the visibility of the widget is governed by
the hosting document, the solution’s script will have be executed, at least par-
tially, in the context the hosting page. Finally, based on these implications, the
solution has to anticipate potential JavaScript-driven attacks from the hosting
page, to fulﬁll the tamper resistance goals.
3.2 The Big Picture
In this section, we give a high level overview on our protection approach. The
emphasis is on its general functionality, without going into deep technical detail.
The core of our methodology is a JavaScript library that is included in the
hosting Web document (see Fig. 1). The script ensures that the widget’s prede-
ﬁned visibility conditions are met. This is done through the utilization of DOM
APIs, which provide access to the widget’s rendering conditions, such as position,
size or CSS properties. The speciﬁcs of this process are discussed in Section 4.
The widget itself is included in the hosting page using a standard iframe-
element. However, all user interaction of the widget is disabled until it has been
veriﬁed that the frame is clearly visible to the user.
If the JavaScript library can verify, that the visibility requirements are indeed
met, the script signals the widget, that it is safe to enable user interaction (see
Sec. 5). From this point on, clicks received by widget are handled seamlessly. To
prevent a malicious site to alter the widget’s rendering after the initial visibility
check, the validation is repeated in a randomized pattern.
3.3 Security Considerations and Resulting Technical Challenges
Our system relies on running a script in the scope of a Web document that
is controlled by an untrusted third party. We do not have control over when
270
M. Johns and S. Lekies
(cid:38)(cid:23)(cid:7)(cid:22)(cid:13)(cid:20)(cid:24)(cid:39)(cid:1)(cid:1)
(cid:35)
(cid:34)(cid:28)(cid:13)(cid:23)(cid:13)(cid:2)(cid:12)(cid:9)(cid:7)(cid:15)(cid:32)(cid:14)(cid:23)(cid:35)(cid:1)
(cid:7)(cid:22)(cid:13)(cid:20)(cid:24)(cid:39)(cid:1)
(cid:38)(cid:33)(cid:23)(cid:7)(cid:22)(cid:13)(cid:20)(cid:24)(cid:39)(cid:1)
(cid:3)(cid:13)(cid:23)(cid:13)(cid:2)(cid:12)(cid:9)(cid:7)(cid:15)(cid:1)(cid:22)(cid:9)(cid:21)(cid:27)(cid:9)(cid:23)(cid:24)(cid:1)
(cid:3)(cid:13)(cid:23)(cid:13)(cid:6)(cid:13)(cid:16)(cid:13)(cid:24)(cid:30)(cid:1)(cid:22)(cid:9)(cid:23)(cid:27)(cid:16)(cid:24)(cid:1)
(cid:3)(cid:13)(cid:23)(cid:13)(cid:6)(cid:13)(cid:16)(cid:13)(cid:24)(cid:30)(cid:30)(cid:1)(cid:22)(cid:9)(cid:23)(cid:27)(cid:16)(cid:24)(cid:1)
(cid:30)(cid:1)
(cid:38)(cid:13)(cid:10)(cid:22)(cid:5)(cid:17)(cid:9)(cid:1)(cid:1)
(cid:23)(cid:22)(cid:7)(cid:37)(cid:36)(cid:29)(cid:13)(cid:8)(cid:11)(cid:9)(cid:24)(cid:1)(cid:23)(cid:19)(cid:27)(cid:22)(cid:7)(cid:9)(cid:36)(cid:39)(cid:1)
(cid:38)(cid:8)(cid:13)(cid:28)(cid:1)(cid:13)(cid:8)(cid:37)(cid:36)(cid:20)(cid:19)(cid:23)(cid:13)(cid:25)(cid:19)(cid:18)(cid:1)(cid:11)(cid:27)(cid:5)(cid:22)(cid:8)(cid:36)(cid:39)(cid:1)
(cid:38)(cid:38)(cid:38)(cid:38)(cid:38)(cid:38)(cid:38)(cid:38)
(cid:4)(cid:13)(cid:8)(cid:11)(cid:9)(cid:24)(cid:1)(cid:20)(cid:22)(cid:19)(cid:28)(cid:13)(cid:8)(cid:9)(cid:22)(cid:1)
Fig. 1. Overview of the protection system