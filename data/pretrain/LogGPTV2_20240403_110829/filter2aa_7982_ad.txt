是一个或更多的字母字符) 指定影响 RE 剩余部分的选项。它们提供和屏弃由应用指定的任何选项。可获得的选项字母有:
.RS 2
.TP 3
\fBb\fR
RE 的剩余部分是一个 BRE
.TP 3
\fBc\fR
大小写敏感 (通常是缺省的)
.TP 3
\fBe\fR
RE 的剩余部分是一个 ERE
.TP 3
\fBi\fR
大小写不敏感 (参见下面的 MATCHING 匹配)
.TP 3
\fBm\fR
历史上的 \fBn \fR的同义词
.TP 3
\fBn\fR
换行敏感匹配 (参见下面的 MATCHING 匹配)
.TP 3
\fBp\fR
部分换行敏感匹配 (参见下面的 MATCHING 匹配)
.TP 3
\fBq\fR
RE 的剩余部分是一个文字 (被引用起来的 ``quoted'')字符串，都是普通字符
.TP 3
\fBs\fR
非换行敏感匹配 (通常是缺省的)
.TP 3
\fBt\fR
紧凑语法 (通常是缺省的；参见后面)
.TP 3
\fBw\fR
反向部分换行敏感 (离奇的 ``weird'') 匹配 (参见下面的 MATCHING 匹配)
.TP 3
\fBx\fR
展开语法 (参见后面)
.RE
.PP
嵌入选项影响的序列被
\fB)\fR
终结。它们只在一个 ARE 的开始处有效，此后不可以在其中使用。
.PP
除了通常的(紧凑) RE 语法，其中所有字符都有意义，还有一个展开语法，在所有风格的 RE 中都可以使用 \fB-expanded\fR 开关来获得它，或者在 ARE 中使用嵌入的 x 选项。在展开语法中，忽略白空格和在 \fB#\fR 和随后的换行(或 RE 结束)之间的所有字符，这就允许了在一个复杂的 RE 中进行分段和注释。有对这些基本规则的三个例外:
.RS 2
.PP
保留有前导`\fB\e\fR'的白空格或 `\fB#\fR'
.PP
保留在方括号表达式中的白空格或 `\fB#\fR' 
.PP
在多字符符号如 ARE `\fB(?:\fR' 或 `\fB\e(\fR' 中间的白空格或注释是非法的
.RE
.PP
展开语法中的白空格是 blank、tab
.VS 8.2
、和属于空格字符类的任何字符。
.VE 8.2
.PP
最后，在 ARE 中，在方括号表达式外面，序列 `\fB(?#\fIttt\fB)\fR'
(这里的
\fIttt\fR
是不包含 `\fB)\fR' 的任何文本)
是一个注释，它将被完全忽略。同样，不允许它在多字符符号如 `\fB(?:\fR'中间的出现。这种注释是历史产物而不是很有用的设施，它的使用被淘汰了；应使用展开语法来替代。
.PP
如果应用(或一个启始的 \fB***=\fR 指示符)指定用户的输入被作为一个文字串而不是一个 RE 来对待，则不能获得这些元语法扩展。
.SH "匹配 MATCHING"
译注：下述引自 XBD RE 规定中的匹配定义，略有变更。
.PP
译注：零个或多个字符的一个序列被称为与 RE 匹配的条件是在这个序列中的字符对应于这个模式定义的一个字符序列。
.PP
译注：对一个匹配的序列的查找开始于一个字符串的开始处，停止于找到第一个匹配字符串的时候，这里定义\fB第一个\fR的意思为“字符串中最早开始的”。如果模式允许匹配的字符有可变的数目，因此在这个点开始的序列多于一个，则匹配最长的那个序列。例如: RE bb* 匹配 abbbc 中的第2到第4个字符，而 RE (wee|week)(knights|night) 匹配 weeknights 的所有10个字符。
.PP
译注：与整个匹配是最长的最左匹配相一致，从左到右的每个子模式，匹配最长的可能的字符串。为此，一个空串被认为比根本没有匹配长。例如，针对(against) abcdef 匹配 RE (.*).* ,子表达式 (\1) 是 abcdef，而针对 bc 匹配 RE (a*)*，子表达式 (\1) 是空串。
.PP
译注：通过向每个子表达式递归的提供最左最长匹配来确定什么(子)字符串对应于子表达式是可能的，而附带条件是整体匹配是最左的、最长的。例如，针对acdacaaa 匹配 (ac*)c*d[ac]*\1 匹配出 acdacaaa (这里 \1=a)； 而简单的给 (ac*) 匹配最长的将生成 \1=ac，但整体匹配将变小 (acdac)。概念上，实现必须检查每种可能的匹配，并在生成的最左最长的总体匹配中，为最左子表达式挑出一个最长的匹配(子串)并以此类推。注意，这意味着子表达式的匹配是上下文相关的: 在一个很大的 RE 中的一个子表达式所匹配的字符串可能与它作为一个独立的 RE 时不同，还有，即使在类似的字符序列中，在同一个很大的 RE 中的同一个子表达式的两个实例可能匹配不同的长度。例如，在 RE (a.*b)(a.*b) 中，两个完全相同的子表达式将分别的匹配 accbaccccb 的四个和六个字符。
.PP
如果一个 RE 能匹配一个给定字符串中的多于一个的子串，RE 匹配在这个字符串中最先开始的子串。如果 RE能匹配的在这一点上开始的子串多于一个，它的选择决定于它的\fB偏好\fR(preference): 要么是最长的子串，要么是最短的子串。
.PP
多数原子和所有约束，都没有偏好。一个有圆括号的 RE 与 RE 有相同的偏好(有可能没有)。一个有
\fB{\fIm\fB}\fR
或
\fB{\fIm\fB}?\fR
定量符的定量原子与原子自身有相同的偏好(有可能没有)。一个有其他平常的定量符的定量原子(包括在 
\fB{\fIm\fB,\fIn\fB}\fR
中
\fIm\fR
等于
\fIn\fR)
偏好最长的匹配。一个有不贪婪定量符的定量原子(包括在 
\fB{\fIm\fB,\fIn\fB}?\fR
中
\fIm\fR
等于
\fIn\fR
的情况)
偏好最短的匹配。一个分支与在它的里面的第一个定量原子有相同的偏好。用 \fB|\fR 操作符连接起来的一个由两个或多个分支组成的 RE 偏好最长的匹配。
.PP
取决于匹配整个 RE 的规则所强加的约束，基于可能子串的表现，子表达式可以匹配最长或最短的可能子串，在 
RE 中开始较早的子表达式优先于开始较晚的。注意，外部的子表达式优先于其中的构件子表达式。
.PP
注意，可以分别的使用定量符
\fB{1,1}\fR
和
\fB{1,1}?\fR
在子表达式或整个 RE 上强制最长和最短偏好。
.PP
用字符数而不是整理元素数来测量匹配长度。一个空串被当作比根本没有匹配长 ，例如
\fBbb*\fR
匹配 `\fBabbbc\fR'中间的三个字符，
\fB(week|wee)(night|knights)\fR
匹配 `\fBweeknights\fR'的所有10个字符，在针对(against)
\fBabc\fR
匹配 \fB(.*).*\fR 的时候圆括号中的子表达式匹配所有这三个字符，而在针对
\fBbc\fR
匹配 \fB(a*)*\fR 的时候整个 RE 和圆括号中子表达式都匹配一个空串。
.PP
如果指定了大小写无关匹配，效果如同所有字母的大小写区别都消失了。当存在大小写区别的一个字符在方括号表达式外面作为一个普通字符出现的时候，它被有效的转变成包含大小写二者的一个方括号表达式， 所以 \fBx\fR 变成了`\fB[xX]\fR'。当它出现在一个方括号表达式中，把它对应的所有大小写添加到方括号中，所以\fB[x]\fR 变成 \fB[xX]\fR而 \fB[^x]\fR 变成 `\fB[^xX]\fR'。
.PP
如果指定了换行敏感匹配，则 \fB.\fR 和使用 \fB^\fR 的方括号表达式永不匹配换行字符(所以除非 RE 显式安排，否则永不会跨越换行来进行匹配)，并且 \fB^\fR 和 \fB$\fR 除了分别匹配字符串的开始和结束之外，还分别的匹配在换行之后和之前的空串。ARE \fB\A\fR 和 \fB\Z\fR 继续\fB只\fR匹配字符串的开始和结束。
.PP
如果指定了部分换行敏感，这将致使 \fB.\fR 和方括号表达式成为换行敏感匹配，但不影响 \fB^\fR 和‘\fB$\fR’。
.PP
如果指定了反向部分换行敏感，这将致使 \fB^\fR 和 \fB$\fR 成为换行敏感匹配，但不影响 \fB.\fR 和方括号。这不是很有用，提供它只是为了对称。
.SH "限制和兼容性 LIMITS AND COMPATIBILITY"
对于 RE 的长度没有强加特定的限制。想要高度可移植的程序不应该依赖比 256 字节长的 RE，因为遵从 POSIX 的实现可能拒绝接受这样的 RE。
.PP
专属 ARE 并且实际上与 POSIX ERE 不相容的特征是在方括号表达式中的 \fB\e\fR 不失去它的特殊意义。所有其他 ARE 特征使用的语法在 POSIX ERE 中是非法的，或着有未定义或未指定的效果；指示符的 \fB***\fR 语法同样不属于 BRE 和 ERE 二者的 POSIX 语法。
.PP
许多 ARE 扩展取自 Perl，为了整理它们而进行了一些变更，还有一些 Perl 扩展未提供。要注意的不相容包括：‘\fB\eb\fR’、‘\fB\eB\fR’，缺乏对尾随的换行的特殊对待，为受换行敏感匹配影响的 RE 增加了方括号表达式补全，在先行约束中对圆括号和后引用的限制，和最长/最短匹配的匹配语义。
.PP
自从这个包的一个早期的 beta 测试版本做了变更以来，RE 的匹配的规则包含正常的和非贪婪的定量符二者。(新规则更加简单和清晰，而不在猜测用户的真实意图上费很大力气。)
.PP
Henry Spencer 的原始的 1986 \fIregexp\fR 包，仍被广泛的使用(例如，在 Tcl 8.1 之前的发行中)，它实现了今天的 ERE 的一个早期版本。在 \fIregexp \fR的近似 ERE (简写为 RRE)和 ARE 之间有四点不相容: 
In roughly increasing order of significance:
.PP
.RS
在 ARE 中，跟随着一个字母字符的 \fB\e\fR  要么是转义要么是一个错误，而在 RRE 中，它只是写字母的另一种方式。这不应该是一个问题，因为在  RRE 中没有理由写出这样的一个序列。
.PP
在 ARE 中跟随着一个数字的 \fB{\fR 是一个束缚的开始，而在 RRE 中，\fB{\fR 总是一个普通字符。这样的序列是少见的，并且经常导致一个错误，原因是随后的字符看起来不象一个有效的束缚。
.PP
在 ARE 中，在`\fB[\|]\fR'内 \fB\e\fR 保持是一个特殊字符，所以在`\fB[\|]\fR'内一个文字 \fB\e\fR 必须写成`\fB\e\e\fR'。在 RRE 中，在\fB[\|]\fR内 `\fB\e\e\fR' 也给出一个文字 \fB\e\fR，但只有真正的偏执狂程序员才例行公事的双写反斜杠。
.PP
ARE 为 RE 报告最长的和最短的匹配，而不是按指定的查找次序找到的第一个匹配。这可能影响寄希望于第一个匹配不被报告的一些 RRE。(废弃了为快速匹配而优化查找次序的 RRE 细致工艺(ARE 并行的检查所有可能的匹配，并且它们的性能在很大程度上不敏感于它们的复杂性)，而为故意的找寻非最长或最短的一个匹配而开发的查找次序需要重写。)
.RE
.SH "基本正则表达式 BASIC REGULAR EXPRESSIONS"
BRE 在一些方面与 ERE 有所区别。 `\fB|\fR', `\fB+\fR',
和
\fB?\fR
是普通字符并且没有与之等价的功能。用于束缚的分界符是
\fB\e{\fR
和 `\fB\e}\fR',
而 
\fB{\fR
和
\fB}\fR
本身是普通字符。用于嵌套子表达式的圆括号是
\fB\e(\fR
和`\fB\e)\fR',
而 
\fB(\fR
和
\fB)\fR
自身是普通字符。除了在 RE 或一个圆括号中的子表达式的开始处之外，
\fB^\fR
是一个普通字符，除了在 RE 或一个圆括号中的子表达式的结束处之外，
\fB$\fR
是一个普通字符，而在 RE 或一个圆括号中的子表达式的开始处之外出现的 
\fB*\fR
是一个普通字符(在可能的前导 `\fB^\fR' 之后)。最后，可获得单一数字的后引用， 
\fB\e\fR
分别是
\fB[[::]]\fR
的同义词；没有其他可获得的转义。
.SH "参见 SEE ALSO"
RegExp(3), regexp(n), regsub(n), lsearch(n), switch(n), text(n)
.SH "关键字 KEYWORDS"
match, regular expression, string
.SH "[中文版维护人]"
.B 寒蝉退士
.SH "[中文版最新更新]"
.B 2001/10/26
.SH "《中国 Linux 论坛 man 手册页翻译计划》:"
.BI http://cmpp.linuxforum.net