%1 = load i32* %b.addr, align 4!
%cmp = icmp sgt i32 %0, %1!
br i1 %cmp, label %if.then, label %if.else!
!
if.then: !
%2 = load i32* %a.addr, align 4!
store i32 %2, i32* %r, align 4!
br label %if.end!
!
if.else: !
%3 = load i32* %b.addr, align 4!
store i32 %3, i32* %r, align 4!
br label %if.end!
!
if.end: !
%4 = load i32* %r, align 4!
ret i32 %4!
}!
Phi node example, post SSA
define i32 @foo(i32 %a, i32 %b) nounwind uwtable ssp
{!
entry:!
%cmp = icmp sgt i32 %a, %b!
br i1 %cmp, label %if.then, label %if.else!
!
if.then: br label %if.end!
!
if.else: br label %if.end!
!
if.end: %r.0 = phi i32 [ %a, %if.then ], [ %b,
%if.else ]!
ret i32 %r.0!
}!
Phi node example 2
int aa(int a, int b) {!
int i = 0;!
int k = 0;!
while( k  and friends
¡
 Compiler stores information about object types off to
the side so that it can be used at run-time
LLVM and Run Time Type Information
 The LLVM codebase implements its own RTTI for
LLVM objects
When writing passes, you use LLVM specific helpers
¡
isa - True or false if pointer/reference is of type T!
¡
cast - “Checked cast”, asserts on failure if not type T!
¡
dyn_cast - unchecked cast, null if not type T
¡
 The project advises you not to use big chains of these
to approximate ‘match’ from ML
 Instead they give you a Visitor pattern (yay)
 You might find these insufficient (or distasteful)
Common Patterns
 “Iterate over BasicBlock in a Function”
Use begin(), end() iterators of Function
¡
 “Iterate over Instructions in a Function”
Use inst_iterator
¡
 “Iterate over Def-Use chains”
Use use_begin, use_end!
¡
InstVisitor
 Pattern to avoid giant blocks of !
!if(T *n = dyn_cast(foo))!
 Inherit from InstVisitor class and define a visitTInst
method
 Could work for your purposes
 Could confuse control flow even more
Including LLVM In Your Project
 llvm-config – executable that will provide useful
info about the installed LLVM
 Provide paths to headers, library files, etc
 If LLVM is built with Cmake, it will add a
FindLLVM.cmake to your /usr/share
 Compiling your code with –fno-rtti will probably be
required
 If you compiled LLVM yourself, you can pass
LLVM_REQUIRES_RTTI to cmake
 Needed if combining boost and llvm
Passes and transformations
Passes
 In the previous lab, we wrote a
pass
 Compiling is the act of passing
over and analyzing/transforming
IR
 Most things that happen in LLVM
happen in the context of a pass
 Passes can have complicated
actions
Pass Dependencies
 Passes can depend on the output of other passes
Analysis passes for alias analysis
¡
 Passes note their dependencies on other passes
By overriding the getAnalysisUsage method
¡
 PassManager figures out the dependency graph
It also attempts to optimize the traversal of the graph
¡
 Each Pass returns a bool, PassManager runs until
everyone stops
Pass Manager
 PassManager performs dependency maintenance
Note that PassManager invocations could be multi-threaded!
¡
Importance of multiple LLVMContexts
¡
 PassManager also performs optimizations of pass
ordering
 PassManager defines different kinds of Passes that
can be run
 ModulePass – Run on entire module
 FunctionPass – Run on individual functions
 BasicBlockpass – Run on individual basic blocks
Pass Rules
 Non-analysis passes should not ‘remember’ any
information about a function or basic block
 Analysis passes should remember some information
Otherwise why run them
¡
 Transformation passes should be idempotent
Lab: Escape Analysis
 If a variable is allocated on the local stack, a pointer
to that variable should not outlive the stack
 This could happen if a pointer to a local is returned
or assigned to a global
 clang currently includes a check for this, but the
check is kind of busted
Algorithm For Escape Analysis
 Populate a set of values that escape the function via
return or store
 Traverse the set checking for alloca-ed values in
the Values descending from the escapes
Structure of Provided Driver
 Driver is laid out similarly to before
 Collection of tests are included
Projects built on LLVM
 Google AddressSanitizer/ThreadSanitizer
http://code.google.com/p/address-sanitizer/
¡
 Utah Integer Overflow Checker
http://embed.cs.utah.edu/ioc/
¡
 Emscripten, LLVM to Javascript
https://github.com/kripken/emscripten/wiki
¡
 Dagger, decompilation from x86 to LLVM
http://llvm.org/devmtg/2013-04/bougacha-slides.pdf
¡
Important LLVM subprojects
 poolalloc – field-sensitive, context-sensitive alias
analysis
 lldb – llvm debugger
 klee – symbolic execution for LLVM
 FreeBSD compiles with clang, soon will switch to
building exclusively with clang
Conclusion
 LLVM enables powerful transformations
 Includes an “industry grade” C/C++ frontend
clang is default compiler on OSX, supported by Apple
¡
Can compile much of Linux userspace
¡
 Well defined Intermediate Language
 Modular and pluggable framework for analysis and
transformation
Project Documentation
 Good documentation online
http://www.llvm.org/docs
¡
 Documentation covers many aspects of the LLVM
project
Programmers manual details finer points of the C++ API
¡
Language reference is ultimate source for language details and
¡
semantics
 Relatively responsive IRC channel on OFTC
 Active and responsive mailing list
|---|--|
| 0 | Using LLVM For Program 
Transformation 
A N D R E W   R U E F  
U N I V E R S I T Y   O F   M A R Y L A N D  
C O M P U T E R   S C I E N C E  |
| 1 |  |