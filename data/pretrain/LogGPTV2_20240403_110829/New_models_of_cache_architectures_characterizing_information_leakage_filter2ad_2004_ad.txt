### 优化后的文本

#### 干扰表示
- \( \text{Ip} \rightarrow \text{Oq} \) 表示访问缓存集 \( q \) 时的命中情况。
- 受害者的地址索引为 \( p \) 的缓存行在缓存集 \( q \) 中发生命中，表示为 \( \text{Ip} \rightarrow \text{Oq} \) 的干扰。
- 类似地，\( I^{-1} \) 表示将受害者的缓存行引入缓存的非关键操作。此时，\( I^{-1} \rightarrow \text{Oq} \) 表示添加随机噪声的虚假干扰。
- 相关的干扰概率、互信息和非干扰条件可以类似地评估这些类型的侧信道漏洞。

#### 其他系统特性
我们的缓存建模方法也可以扩展到现代微处理器的其他特性：

1. **多进程**：
   - 除了受害者和攻击者之外的其他进程可能会影响攻击者的观察结果。我们可以引入一个新的状态 \( R \)，表示由其他进程占用的缓存行。
   - 新的缓存事件“R miss”可以从状态 \( A \) 转移到 \( R \)，生成虚假干扰并为攻击者的观察添加噪声。
   - 状态 \( R \) 也可以叠加在 \( \text{INV} \) 状态上，“R miss”可以在从 \( A \) 到 \( \text{INV} \) 的“无效化”转换中出现（如图1所示）。
   - 这种方法将我们测量的虚假干扰视为来自多个来源的“噪声”——无效化、其他进程或其他通道噪声。

2. **预取**：
   - 预取是在请求之前将数据加载到缓存中，以避免未来的缓存未命中。
   - 我们添加两个新的事件“V prefetch”和“A prefetch”来模拟受害者和攻击者的数据预取。
   - 预取可以通过添加噪声来减少侧信道泄漏。例如，在类型I攻击中，“V prefetch”可以驱逐攻击者的缓存行，并使缓存状态从 \( A \) 转移到 \( V \)。这会在攻击者稍后对该行进行缓存未命中时生成虚假干扰，可能满足条件C2。
   - “A prefetch”可以驱逐受害者的缓存行，并使缓存状态从 \( V \) 转移到 \( A \)。这样，攻击者会对此行经历缓存命中，并且无法观察到受害者之前的动作，可能满足条件C1。

3. **AES-NI [27]**：
   - Intel x86处理器引入了专门用于AES块加密和解密的新指令。这消除了使用AES-NI指令重写的AES实现中的缓存使用。
   - 由于这移除了状态 \( V \) 及其所有相关转换（如图1所示），攻击者无法观察到任何来自受害者的干扰，从而满足条件C1。
   - 不幸的是，AES-NI不适用于旧代码（或未使用AES-NI指令编写的新代码）。它也不能缓解来自其他密码算法（如RSA）的缓存侧信道泄漏。此外，它也不保护其他处理器（如移动设备中常用的ARM处理器）中的缓存侧信道泄漏。

### 缓存模型验证
我们启动一个实际的攻击程序，以验证我们的缓存建模案例研究的结果。我们使用候选密钥的概率分布来量化攻击的可行性，从而评估系统的脆弱性。

#### 候选密钥的概率分布
当攻击者试图破解一个密码计算平台时，他可以向平台输入不同的明文，并请求用他想窃取的密钥进行加密。然后，他收集加密过程中的侧信道观察，并尝试推断密钥或缩小其可能值。为了提高准确性并完全恢复密钥，攻击者通常会重复多次攻击轮次以获得不同的候选密钥。他计算候选密钥的概率分布，并选择具有最高概率的密钥。成功的攻击能够基于候选密钥概率分布中显著较高的概率选择正确的密钥。因此，我们使用这种方法来评估攻击的成功率以及系统的脆弱性。

#### 实现
我们在AES [17] 上发起了一次基于访问的侧信道攻击。我们使用gem5 [28] 在不同缓存架构上模拟该攻击，并比较它们的候选密钥概率分布。对于每个缓存，我们模拟L1缓存，缓存大小为32 Kbytes，行大小为32 bytes，组关联度为8-way，这是现代处理器的典型配置。受害者在学习阶段（密钥已知给攻击者）和攻击阶段（密钥未知给攻击者）分别运行AES加密2^18个随机块。攻击者通过连续预热和探测缓存来收集每条缓存行的访问时间，以推断受害者的内存访问，进而推断其加密密钥。

#### 攻击结果
图2显示了攻击结果。我们用实红线表示候选密钥的概率分布，虚蓝线表示正确的加密密钥。

- 对于传统缓存（图2a），八个密钥（32-39）的概率超过10%，其余接近零。正确密钥字节值35在前八个候选密钥中，但攻击者无法将其挑选出来。这是因为一条缓存行包含8个AES条目，当攻击者观察到受害者对这条行的访问时，无法区分哪个条目实际上被访问。他需要其他方法（如暴力破解或两轮攻击[17]）才能从8个可能值中找到正确的密钥。我们得出结论：对传统缓存的攻击成功。
- 对于随机驱逐缓存（图2d），展示了两种类型的RE缓存：RE1000（每1000次内存访问随机驱逐一条缓存行——红色）和RE10（每10次内存访问驱逐一条缓存行——黑色）。RE缓存也泄露了八个候选密钥：RE1000的概率分布与传统缓存相同，而RE10则小得多。驱逐频率更高的RE缓存更难以攻击。

图2b显示了SP缓存的候选密钥分布。结果显示，攻击没有产生任何显著的候选密钥。因此，对SP缓存的攻击在2^18个样本下失败。我们对分区锁定缓存（图2c）、随机排列缓存（图2e）和Newcache（图2f）也得出了相同的结论。

通过比较表9和图2，我们发现两种独立评估方法的结果是一致的。对于分区方法，PL和SP缓存可以有效防御类型I侧信道攻击。对于随机化方法，RP和NewCache也非常有效地减少了类型I侧信道泄漏。如果增加驱逐频率（以性能为代价），RE缓存更难以攻击。

### 相关工作
过去的工作在评估侧信道攻击方面可以根据其特征分为几类：

- **互信息**：[29] 应用了互信息和猜测熵来评估密钥恢复的可行性。[30] 提出了静态分析来建立针对缓存侧信道攻击的形式安全保证，并可以估计侧信道的信息泄漏上限。[31] 提出了一种适应性侧信道攻击的信息论度量，可以估计攻击者的剩余不确定性以调整策略。
- **成功率**：[29] 定义了成功率作为评估侧信道密钥恢复可行性的通用指标。[32] 定义了平均成功率来评估缓存时序攻击。它还建立了分析模型来估计成功率以确定最佳攻击策略。[33] 建立了一个预测模型来评估通过缓存的侧信道泄漏。它计算了攻击者在给定受害者的关键内存访问时正确检测内存访问的概率。
- **相关性度量**：[34] 提出了侧信道漏洞因子 (SVF) 来衡量系统对所有侧信道的脆弱性。它计算皮尔逊相关系数来衡量受害者执行轨迹和攻击者观察轨迹之间的相似矩阵。[35] 提出了基于时序的缓存侧信道攻击的时间-SVF度量。[36] 设计了一种称为缓存侧信道漏洞 (CSV) 的度量，以克服SVF在其范围、定义和测量方面的问题。它还指出，使用单一度量（如SVF [34]）来评估所有可能形式的侧信道信息泄漏是存在问题的，因为它可能会给出误导性结果，并且不能正确确定哪种安全缓存设计在防御哪种侧信道攻击方面更有效。

### 结论
本文提出了一种新颖的方法来评估缓存系统对侧信道攻击的脆弱性。我们从非干扰属性出发建模侧信道泄漏，并使用三个非干扰条件下的互信息来确保无侧信道泄漏。然后，我们展示了如何建模缓存架构，并将这些模型与我们的侧信道泄漏模型结合。我们还对每个详细的安全缓存架构模拟进行了实际攻击，以验证我们的建模方法是否与现实一致（“真实情况”）。

我们的建模方法专注于导致缓存侧信道泄漏的根本原因：影响缓存行为的干扰。理论上，它可以涵盖所有类型的侧信道攻击（已知或未知）。在案例研究中，我们考虑了基于外部干扰引起的缓存未命中的侧信道攻击（类型I）。但这些缓存和干扰模型可以扩展到其他类型的攻击，如第6节所述。未来的工作还可以将这些评估方法扩展到新的缓存架构和其他影响缓存行为的系统特性，以及其他可能受到侧信道或隐蔽通道攻击的子系统（不仅仅是缓存）。

### 致谢
本研究得到了DHS/AFRL FA8750-12-2-0295和NSF CNS-1218817的部分支持。

### 参考文献
[此处省略参考文献列表]

希望这些修改能帮助你更好地表达你的研究内容！如果有更多需要修改的地方，请随时告诉我。