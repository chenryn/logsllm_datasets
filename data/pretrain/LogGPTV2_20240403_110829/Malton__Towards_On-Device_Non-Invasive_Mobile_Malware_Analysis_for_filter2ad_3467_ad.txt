query()
06
CursorWrapper.
getColumnIndex()
08
String.
replace()
String@0x6fd83c00 ((cid:256)data1(cid:257))
Int 0x33
07
CursorWrapper.
getString() 
String@0x12d05288 ((cid:256)+86 1471501**95(cid:257))
String@0x6fbe4480 ((cid:256) (cid:257))
String@0x12d8bd68 ((cid:256)+86(cid:257))
14
SmsManager.
sendTextMessage()
String@0X6fbe22d0 ((cid:256)(cid:257))
String@0x12d056c8 ((cid:256)+861471501**95(cid:257))
09
String.
replace()
String@0x12d2d988 ((cid:256)1471501**95(cid:257))
Arg1: String@0x12d2d988 ((cid:256)1471501**95(cid:257))
Arg2: NULL
Arg3: String@0x130b2c28 ((cid:256)Jeremy(cid:11579)(cid:17929)(cid:1114)(cid:712)http://cdn.yyupload.com/down/4279193/XXshenqi.apk(cid:257))
Arg4: NULL 
Arg5: NULL
Figure 4: Malton can help the analyst construct the complete ﬂow of information leakage in the XXshenqi malware. The ellipses
refer to function invocations, where the grey ellipses represent taint sources and the ellipses with bold lines denote taint sinks. The
rectangles indicate data and red italics strings highlight the tainted information.
were still active when Malton inspects the same samples.
Hence, in the worst case, Malton’s results may be penal-
ized since the malware cannot receive commands.
Summary Compared with existing tools running in the
emulator and monitoring malware behaviors in a sin-
gle layer, Malton can capture more sensitive behaviors
thanks to its on-device and cross-layer inspection.
4.2 Malware Analysis
To answer Q2, we evaluate Malton with sophisticat-
ed malware samples by constructing the complete ﬂow
of information leakage across different layers, detecting
stealthy behaviors with Java/JNI reﬂection, dissecting the
behaviors of packed Android malware, and identifying
the malicious behaviors of hidden code.
4.2.1 Identify Cross-Layer Information Leakage
This experiment uses the sample in the XXShenqi [3]
malware family, which is an SMS phishing malware with
package name com.example.xxshenqi. When the mal-
ware is launched, it reads the contact information and
creates a phishing SMS message that will be sent to all
the contacts collected. In this inspection, we focused on
the behavior of creating and sending the phishing SMS
message to the retrieved contacts by letting the contact-
s be the taint source and the methods for sending SMS
messages be the taint sink. The detailed ﬂow is illustrat-
ed in Figure 4.
To retrieve the information of each contact, the mal-
ware ﬁrst obtains the column index and the value of the
ﬁeld id in step 1 and step 2 in Figure 46, respective-
ly. Then, a new instance of the class CursorWrapper
6The number in each ellipse denotes the step index.
is created based on id and uri (com.android.contact),
and this contact’s phone number is acquired through this
instance. After that, blank characters and the national
number (“+86”) are removed from the retrieved phone
number in steps 8 and 9. In the method String.replace()7,
StringFactory.newStringFromString() and String.setCharAt()
are invoked to create a new string according to the
current string and set the speciﬁed character(s) of the
new string, respectively. These two methods are JNI
functions and implemented in the system layer. For
String.setCharAt(), Malton can further determine the taint-
ed portion of the string at the byte granularity. By con-
trast, TaintDroid does not support this functionality be-
cause for JNI methods it lets the taint tag of the whole
return value be the union of the function arguments’ taint
tags. After that, a phishing SMS message is constructed
according to the display name of a retrieved contact and
the phishing URL through steps 10-13. Finally, the phish-
ing SMS is sent to the contact in step 14 and a message
“send Message to Jeremy 1” is printed in step 15.
Summary By conducting the cross-layer taint propaga-
tion, Malton can help the analyst construct the complete
ﬂow of information leakage.
4.2.2 Detect Stealthy Malicious Behaviors
Some malware adopts Java/JNI reﬂection to hide their
malicious behaviors. We use the sample in the photo38
malware family to evaluate Malton’s capability of detect-
ing such stealthy behaviors. Figure 5 demonstrates the i-
dentiﬁed stealthy behaviors, which are completed in two
different threads. The number in the ellipse and rectan-
gle is the step index, and we use different colours (i.e.,
7in /libcore/libart/src/main/java/java/lang/String.java
8md5:8bd9f5970afec4b8e8a978f70d5e87ab
USENIX Association
26th USENIX Security Symposium    297
01
Activity.
getSystemService()
02
TelephonyManager.
getDeviceId()
(cid:256)phone(cid:257)
03
mem=0x12b1a000-0x12b1d000 size=12288 
mmap()  
prot=rw- flags=0x22
04
InvokeVirtualOrInterfaceWithJValues() 
method=(cid:257)run()(cid:257)
TelephonyManager@0x12e99348
05
Class=(cid:257)Landroid/telephony/SmsManager;(cid:257)
DefineClass() 
06
SmsManager.
+
(cid:263)(cid:17829)(cid:1324)(cid:4543)(cid:16123)(cid:4546)(cid:8715)(cid:63)(cid:81)(cid:16892)(cid:2145)(cid:11831)(cid:29)(cid:264)
(cid:256)353490069945232(cid:257)
+ (cid:256)\n(cid:257)
+
(cid:263)(cid:3521)(cid:2605)(cid:29)(cid:36)(cid:50)(cid:54)(cid:51)(cid:3)(cid:82)(cid:81)(cid:3)(cid:43)(cid:68)(cid:80)(cid:80)(cid:72)(cid:85)(cid:43)(cid:72)(cid:68)(cid:71)(cid:30)(cid:63)(cid:81)(cid:6273)
(cid:7536)(cid:29)(cid:36)(cid:81)(cid:71)(cid:85)(cid:82)(cid:76)(cid:71)(cid:30)(cid:63)(cid:81)(cid:13105)(cid:13589)(cid:10366)(cid:7522)(cid:29)(cid:25)(cid:17)(cid:19)(cid:264)
07
SmsManager.
getDefault()
Arg1: (cid:256)15767549497(cid:257)
Arg2: NULL
Arg3:(cid:263)(cid:17829)(cid:1324)(cid:4543)(cid:16123)(cid:4546)(cid:8715)(cid:63)(cid:81)(cid:16892)(cid:2145)(cid:11831)(cid:29)353490069945232\n(cid:3521)(cid:2605)(cid:29)(cid:36)(cid:50)(cid:54)(cid:51)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)
(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:82)(cid:81)(cid:3)(cid:43)(cid:68)(cid:80)(cid:80)(cid:72)(cid:85)(cid:43)(cid:72)(cid:68)(cid:71)(cid:30)(cid:63)(cid:81)(cid:6273)(cid:7536)(cid:29)(cid:36)(cid:81)(cid:71)(cid:85)(cid:82)(cid:76)(cid:71)(cid:30)(cid:63)(cid:81)(cid:13105)(cid:13589)(cid:10366)(cid:7522)(cid:29)(cid:25)(cid:17)(cid:19)(cid:264)
Arg4: NULL
Arg5: NULL
Object@0x12eac048
12
SmsManager.
sendTextMessage()
InvokeMethod() 
11
method=(cid:256)sendTextMessage(cid:257)
08
Class.
forName() 
Class.
getMethod() 
Method.
invoke()
09
10
(cid:256)android.telephony.SmsManager(cid:257)
Class@0x130f5c08
(cid:256)sendTextMessage(cid:257)
Method@0x12e482c8
Figure 5: Malton can detect stealthy behaviors through the Java/JNI reﬂection of the photo3 malware. The ellipses refer to
function invocations in the framework layer, where the grey ellipses represent taint sources and the ellipses with bold lines denote
taint sinks. The round corner rectangles stand for function invocations at the runtime layer. Other rectangles indicate data and red
italics strings highlight the tainted information.
ID is
blue and red) for the numbers to distinguish two threads.
The execution paths are denoted by both the solid lines
and dashed lines, and the solid lines further indicate how
the information is leaked. We describe the identiﬁed ma-
licious behaviors as follows.
• The device
returned by the method
TelephonyManager.getDeviceId() in step 1 and step 2.
• A new thread is created to send the collected
In step 3,
information to the malware author.
a memory area is allocated by the system cal-
l sys mmap(), and the thread method run() is invoked
by the runtime through the JNI reﬂection function
InvokeVirualOrInterfaceWithJValues() in step 4. Nex-
t, the class android/telephony/SmsManager is deﬁned
and initialized in step 5 and step 6.
In step 7,
the SmsManager object is obtained through the static
method SmsManager.getDefault().
• The malware sends SMS messages through Java
reﬂection. Speciﬁcally, in step 8, the malware obtain-
the android.telephony.SmsManager
s the object of
the
class
through
reﬂection method
Class.forName().
Then,
retrieves the method
object of sendTextMessage() using the Java reﬂection
method Class.getMethod() in step 9. Finally, it calls
the Java method sendTextMessage() in step 10. This
invocation goes to the method InvokeMethod() in the
ART runtime layer in step 11.
Java
it
Summary Malton can identify malware’s stealthy be-
haviors through Java/JNI reﬂection in different layers.
4.2.3 Dissect Packed Android Malware’s Behaviors
Since Malton stores the collected information into log
ﬁles, we can dissect the behaviors of packed Android
malware by analyzing the log ﬁles. As an example, Fig-
ure 6 shows partial log ﬁle of analyzing the packed mal-
ware sample9, and Figure 7 illustrates the identiﬁed mali-
cious behaviors of this sample. Such behaviors can be di-
vided into two parts. One is related to the original packed
malware (Lines 1-21), and the other one is relevant to the
hidden payloads of the malware (Lines 22-30).
is
Once
the
loaded
started,
is
the malware
class
for
com.netease.nis.wrapper.MyApplication
preparing the real payload (Line 2). Then, the Android
framework API Application.attach() is invoked (Line 4)
to set the property of the app context. After that, the
malware calls the Java method System.loadLibrary() to
load its native component libnesec.so at Line 7.
Malton empowers us to observe that the ART runtime
(Line 8) and the
invokes the function FindClass()
to locate the
function LoadNativeLibrary()
class com.netease.nis.wrapper.MyJni and load the library
libnesec.so, respectively.
(Line 9)
After initialization, the malware calls the JNI method
MyJni.load() to release and load the hidden Dalvik byte-
code into memory. More precisely, the package name
is ﬁrst obtained through JNI reﬂection (Line 11 and
12). Then, the hidden bytecode is written into the ﬁle
“.cache/classes.dex” under the app’s directory (Line 13
and 14). After that, a new DexFile object is initialized
based on the newly created Dex ﬁle through the runtime
function DexFile::OpenMemory() (Line 16).
to
the
Intent
handle
receiver
the packed malware
also ﬁnd that
an
reg-
We
isters
Intent
com.zjdroid.invoke at Line 19 and 21. Note
that ZjDroid [9] is a dynamic unpacking tool based
on the Xposed framework and is started by the Intent
com.zjdroid.invoke.
By registering the Intent
receiver, the malware can detect the existence of ZjDroid.
the app loads and initializes the class
v.v.v.MainActivity in Line 23 to 26, and the hidden mali-
cious payloads are executed at Line 29. To hide itself, the
Finally,
9md5: 03b2deeb3a30285b1cf5253d883e5967
298    26th USENIX Security Symposium
USENIX Association
(cid:257)
n
o
i
t
a
c
i
l
p
p
A
y
M
.
r
e
p
p
a
r
w
.
s
i
.
n
e
s
a
e
t
e
n
m
o
c
.
(cid:256)
(cid:257)
y
t
i
v
i
t
c
A
n
a
M
v
v
v
(cid:256)
i
.
.
.
f
0
s
r
o
i
v
a
h
e
B
f
0
s
r
o
i
v
a
h
e
B