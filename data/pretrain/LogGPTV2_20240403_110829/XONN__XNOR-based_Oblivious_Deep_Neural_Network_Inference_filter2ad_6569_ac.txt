USENIX Association
Binary-VDP
BN+BA
0
0
1
0
0
1
1
0
1
0
1
1
A
d
d
e
r
1
-
b
i
t
A
d
d
e
r
1
-
b
i
t
A
d
d
e
r
2
-
b
i
t
...
.n
.
.
.
.
.
.
.
.
.
.
.
.
.
.
1
1
1
0
1
1
0
0
1
1
0
1
A
d
d
e
r
1
-
b
i
t
A
d
d
e
r
1
-
b
i
t
A
d
d
e
r
2
-
b
i
t
...
p
A
d
d
e
r
l
o
g
2
n
-
b
i
t
c
o
m
p
a
r
e
w
i
t
h
Integer-VDP
BN+BA
binary
weights
w[1]
w[2]
w[3]
w[4]
w[n-3]
w[n-2]
w[n-1]
w[n]
b-bit
input
x[1]
x[2]
x[3]
x[4]
x[n-3]
x[n-2]
x[n-1]
x[n]
Select
Select
Select
Select
Select
Select
Select
Select
n
p
Figure 4: Circuit for binary-VDP followed by comparison
for batch normalization (BN) and binary activation (BA).
Select Circuit
1
1
W
3.3 Oblivious Conditional Addition Protocol
b
x
b
b
In XONN, all of the activation values as well as neural net-
work weights are binary. However, the input to the neural
network is provided by the user and is not necessarily bi-
nary. The ﬁrst layer of a typical neural network comprises
either an FC or a CONV layer, both of which are evaluated
using oblivious Integer-VDP. On the one side, the user pro-
vides her input as non-binary (integer) values. On the other
side, the network parameters are binary values representing
−1 and 1. We now demonstrate how Integer-VDP can be
described as an OT problem. Let us denote the user’s input
as a vector v1 of n (b-bit) integers. The server holds a vector
of n binary values denoted by v2. The result of Integer-VDP
is a number “y” that can be described with
b′ ="log2(n · (2b − 1))#
1, called v∗
bits. Figure 6 summarizes the steps in the OCA protocol.
The ﬁrst step is to bit-extend v1 from b-bit to b′-bit. In other
words, if v1 is a vector of signed integer/ﬁxed-point num-
bers, the most signiﬁcant bit should be repeated (b′ − b)-
many times, otherwise, it has to be zero-padded for most
signiﬁcant bits. We denote the bit-extended vector by v∗
1.
The second step is to create the two’s complement vector
1. The client also creates a vector of n (b′-
of v∗
bit) randomly generated numbers, denoted as r. She com-
putes element-wise vector subtractions v∗
and
1 − r mod 2b′
v∗
. These two vectors are n-many pair of mes-
sages that will be used as input to n-many 1-out-of-two OTs.
More precisely, v∗
is a list of ﬁrst messages and
1 − r mod 2b′
v∗
is a list of second messages. The server’s list
of selection bits is v2. After n-many OTs are ﬁnished, the
server has a list of n transferred numbers called vt where
1 − r mod 2b′
1 − r mod 2b′
vt[i] =$ v∗
1[i] − r[i] mod 2b′
1[i] − r[i] mod 2b′
v∗
i f v2[i] = 0
i f v2[i] = 1
i = 1, ... , n.
Figure 5: Circuit for Integer-VDP followed by comparison
for batch normalization (BN) and binary activation (BN).
i=1 r[i] mod 2b′
i=1 vt[i] mod 2b′
Finally, the client computes y1 = ∑n
and
the server computes y2 = ∑n
. By OT’s def-
inition, the receiver (server) gets only one of the two mes-
sages from the sender. That is, based on each selection bit (a
binary weight), the receiver gets an additive share of either
the sender’s number or its two’s complement. Upon adding
all of the received numbers, the receiver computes an addi-
tive share of the Integer-VDP result. Now, even though the
sender does not know which messages were selected by the
receiver, she can add all of the randomly generated numbers
r[i]s which is equal to the other additive share of the Integer-
VDP result. Since all numbers are described in the two’s
complement format, subtractions are equivalent to the addi-
tion of the two’s complement values, which are created by
the sender at the beginning of OCA. Moreover, it is possible
that as we accumulate the values, the bit-length of the ﬁnal
Integer-VDP result grows accordingly. This is supported due
to the bit-extension process at the beginning of the protocol.
In other words, all additions are performed in a larger ring
such that the result does not overﬂow.
Note that all numbers belong to the ring Z
2b′ and by def-
inition, a ring is closed under addition, therefore, y1 and y2
are true additive shares of y = y1 + y2 mod 2b′
. We described
the OCA protocol for one Integer-VDP computation. As we
outlined in Section 3.2, all linear operations in the ﬁrst layer
of the DL model (either FC or CONV) can be formulated as
a series of Integer-VDPs.
USENIX Association
28th USENIX Security Symposium    1507
Sender:
(1) Bit-extends all elements of v1 and creates v∗
1
(2) Creates two’s complement of v∗
(3) Creates random vector r : same size as v∗
1
(4) Creates list of ﬁrst messages as m2 = v∗
(5) Creates list of second messages as m1 = v∗
1 : v∗
1
1 − r mod 2b′
1 − r mod 2b′
Sender & Receiver:
(6) Parties engage in Oblivious Transfer (OT)
Sender puts m1 and m2 as message vectors
Receiver puts v2 vector as selection bits
Receiver:
(7) Gets vector vt where:
vt[i] =%v∗
1[i] − r[i] mod 2b′ (if v2[i] = 0)
1[i] − r[i] mod 2b′ (if v2[i] = 1)
v∗
Sender:
(8) Computes her additive share of VDP result as:
Receiver:
y1 = ∑n
i=1 r[i] mod 2b′
(9) Computes his additive share of VDP result as:
y2 = ∑n
i=1 vt[i] mod 2b′
Figure 6: Oblivious Conditional Addition (OCA) protocol.
In traditional OT, public-key encryption is needed for
each OT invocation which can be computationally expensive.
Thanks to the Oblivious Transfer Extension technique [16,
17, 18], one can perform many OTs using symmetric-key en-
cryption and only a ﬁxed number of public-key operations.
Required Modiﬁcation to the Next Layer. So far, we have
shown how to perform Integer-VDP using OT. However, we
need to add an “addition” layer to reconstruct the true value
of y from its additive shares before further processing it. The
overhead of this layer, as well as OT computations, are dis-
cussed next. Note that OCA is used only for the ﬁrst layer
and it does not change the overall constant round complexity
of XONN since it is performed only once regardless of the
number of layers in the DL model.
Comparison to Integer-VDP in GC. Table 1 shows the
computation and communication costs for two approaches:
(i) computing the ﬁrst layer in GC and (ii) utilizing OCA.
OCA removes the GC cost of the ﬁrst layer in XONN. How-
ever, it adds the overhead of a set of OTs and the GC costs
associated with the new ADD layer.
Table 1: Computation and communication cost of OCA.
Costs
{Sender, Receiver}
GC
OT
OCA
Comp. (AES ops)
Comm. (bit)
(n + 1) · b · {2, 4}
(n + 1) · b · 2 · 128
n · {1, 2}
n · b
ADD Layer
b′· {2, 4}
b′ · 2 · 128
3.4 Security of XONN
We consider the Honest-but-Curious (HbC) adversary model
consistent with all of the state-of-the-art solutions for obliv-
ious inference [7, 8, 9, 10, 13, 25]. In this model, neither of
the involved parties is trusted but they are assumed to follow
the protocol. Both server and client cannot infer any infor-
mation about the other party’s input from the entire protocol
transcript. XONN relies solely on the GC and OT protocols,
both of which are proven to be secure in the HbC adversary
model in [26] and [15], respectively. Utilizing binary neu-
ral networks does not affect GC and OT protocols in any
way. More precisely, we have changed the function f (.) that
is evaluated in GC such that it is more efﬁcient for the GC
protocol: drastically reducing the number of AND gates and
using XOR gates instead. Our novel Oblivious Conditional
Addition (OCA) protocol (Section 3.3) is also based on the
OT protocol. The sender creates a list of message pairs and
puts them as input to the OT protocol. Each message is an
additive share of the sender’s private data from which the se-
cret data cannot be reconstructed. The receiver puts a list of
selection bits as input to the OT. By OT’s deﬁnition, the re-
ceiver learns nothing about the unselected messages and the
sender does not learn the selection bits.
During the past few years, several attacks have been pro-
posed that extract some information about the DL model by
querying the server many times [1, 27, 28].
It has been
shown that some of these attacks can be effective in the
black-box setting where the client only receives the predic-
tion results and does not have access to the model. Therefore,
considering the deﬁnition of an oblivious inference, these
type of attacks are out of the scope of oblivious inference
frameworks. However, in Appendix B, we show how these
attacks can be thwarted by adding a simple layer at the end
of the neural network which adds a negligible overhead.
Security Against Malicious Adversaries. The HbC ad-
versary model is the standard security model in the liter-
ature. However, there are more powerful security models
such as security against covert and malicious adversaries.
In the malicious security model, the adversary (either the
client or server) can deviate from the protocol at any time
with the goal of learning more about the input from the