where Prğ‘– is the collision probability of two independent sam-
ples from (ğ’³ mod ğ‘ğ‘–).
The above lemma implies that if the distribution (ğ’³ mod ğ‘)
is within statistical distance ğœ€ from the uniform distribution
over Zğ‘š
ğ‘ , then we have
âˆ†(ğ·0, ğ·1) â‰¤ ğœ€ +âˆšï¸€ğ‘ğ‘›/ğ‘ğ‘š.
This can be seen by considering a distribution ğ’³ â€² such that
(ğ’³ mod ğ‘) is uniform distribution over Zğ‘š
ğ‘ and âˆ†(ğ’³ ,ğ’³ â€²) â‰¤ ğœ€.
Lemma 2.7 (Special case of Lemma 8 in [4]). There
exists a universal constant ğ¾ > 1 such that for all ğ‘š â‰¥ 2ğ‘›,
ğœ€ > 0 and ğœ â‰¥ ğ¾ğœ‚ğœ€(Z), the following holds for X â†Ë’ ğ·ğ‘›Ã—ğ‘šZ,ğœ :
âˆš
2ğœ‹ğ‘š/ğ¾  1 âˆ’ 4ğ‘šğœ€ + ğ‘‚(exp(âˆ’ğ‘š/ğ¾)).
We will also require the following theorem, adapted from
Theorem 17 in [27].
âˆš
ğ‘š1ğœ2
Theorem 2.8 ([27]). Let ğ‘›, ğ‘š1, ğ‘š2, and ğœ† be integers
satisfying ğ‘š2 â‰¥ ğ‘š1 > 100 and ğœ1, ğœ2 be positive real num-
bers. Let ğ‘›â€² = max{ğœ†, ğ‘›} and assume that ğ‘›â€² > 100. We
ğ‘š1ğ‘›â€² log ğ‘š1), ğ‘š1 â‰¥
also assume that they satisfy ğœ1 â‰¥ â„¦(
â„¦(ğ‘›â€² log (ğœ1ğ‘›â€²)), and ğœ2 â‰¥ â„¦(ğ‘›â€²5/2âˆš
1 log3/2(ğ‘š1ğœ1)).
Then, there exists a probabilistic polynomial-time algorithm
that given ğ‘›, ğ‘š1, ğ‘š2, ğœ† (in unary), ğœ1, and ğœ2, returns X1 âˆˆ
Zğ‘›Ã—ğ‘š1 , X2 âˆˆ Zğ‘›Ã—ğ‘š2 , and U âˆˆ Zğ‘šÃ—ğ‘š with ğ‘š = ğ‘š1 + ğ‘š2
such that:
âˆ™ the distribution of (X1, X2) is within statistical distance
2âˆ’Î©(ğ‘›â€²) of the distribution ğ·ğ‘›Ã—ğ‘š1
Ã—(ğ·Zğ‘š2 ,ğœ2,ğ›¿1 Ã—Â·Â·Â·Ã—
Z,ğœ1
ğ·Zğ‘š2 ,ğœ2,ğ›¿ğ‘› )ğ‘¡, where ğ›¿ğ‘– denotes the ğ‘–th canonical unit
vector in Zğ‘š2 whose ğ‘–th coordinate is 1 and whose
remaining coordinates are 0,
âˆ™ we have | det U| = 1 and (X1|X2) Â· U = (Iğ‘›|0),
âˆš
âˆ™ every column of U has norm â‰¤ ğ‘‚(
ğ‘›â€²ğ‘š1ğœ2) with
probability â‰¥ 1 âˆ’ 2âˆ’Î©(ğ‘›â€²).
Three remarks are in order regarding the theorem. First,
we take the transpose of the theorem in [27]. This is just
for a notational convenience. Secondly, the distribution of
X = (X1|X2) in Theorem 17 in [27] is slightly different
from the above in that all entries of the first column of
X equal to 1. As noted right after Lemma 7 in [27], the
theorem still holds even with the change. Finally, in the above
theorem, we introduce the statistical security parameter ğœ†
and differentiate it from the lattice dimension ğ‘›, while the
theorem in [27] assigns the same variable ğ‘› for both. This
change is introduced because we will invoke the theorem for
possibly small ğ‘› for which 2âˆ’ğ‘› is no longer negligible.
In our security analysis, we need a variant of the above the-
orem where X is chosen from a slightly different distribution
and U need not be efficiently samplable.
Lemma 2.9. Let ğ‘›, ğ‘š1, ğ‘š2, ğ‘š, ğœ†, ğ‘›â€², ğœ1, ğœ2 be as in Theo-
rem 2.8. Then, for all but 2âˆ’Î©(ğ‘›â€²) probability over (X1, X2) âˆˆ
Zğ‘›Ã—ğ‘š1 Ã— Zğ‘›Ã—ğ‘š2 chosen from ğ·ğ‘›Ã—ğ‘š1
, there exists
Z,ğœ1
U âˆˆ Zğ‘šÃ—ğ‘š such that | det U| = 1, (X1|X2)Â· U = (Iğ‘›|0), and
âˆš
every column of U has norm â‰¤ ğ‘‚(
Ã— ğ·ğ‘›Ã—ğ‘š2
Z,ğœ2
ğ‘›â€²ğ‘š1ğœ2).
âˆ‘ï¸€
To prepare for the proof of Lemma 2.9, we define RÂ´enyi
Divergence (RD) and review its properties following [6]. For
any two probability distributions ğ‘ƒ and ğ‘„ such that the
support of ğ‘ƒ is a subset of the support of ğ‘„ over a countable
domain ğ‘‹, we define the RD (of order 2) by ğ‘…(ğ‘ƒâ€–ğ‘„) =
ğ‘¥âˆˆğ‘‹ ğ‘ƒ (ğ‘¥)2/ğ‘„(ğ‘¥), with the convention that the fraction is
zero when both the numerator and denominator are zero.
We will use the following property: if ğ‘ƒ (resp. ğ‘„) is a direct
product of independent distributions ğ‘ƒ1 and ğ‘ƒ2 (resp. ğ‘„1
and ğ‘„2), then we have ğ‘…ğ·(ğ‘ƒâ€–ğ‘„) = ğ‘…ğ·(ğ‘ƒ1Ã— ğ‘ƒ2â€–ğ‘„1Ã— ğ‘„2) =
ğ‘…ğ·(ğ‘ƒ1â€–ğ‘ƒ2) Â· ğ‘…ğ·(ğ‘„1â€–ğ‘„2).
Session K1:  Secure ComputationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA2283Lemma 2.10 (Lemma 2.9 in [6]). Let ğ‘ƒ and ğ‘„ denote
distributions with Supp(ğ‘ƒ ) âŠ† Supp(ğ‘„) and ğ´ âŠ† Supp(ğ‘„) be
arbitrary set. Then, we have ğ‘„(ğ´) â‰¥ ğ‘ƒ (ğ´)2/ğ‘…(ğ‘ƒâ€–ğ‘„) where
ğ‘ƒ (ğ´) and ğ‘„(ğ´) are measure of ğ´ under the distribution ğ‘ƒ
and ğ‘„ respectively.
We also recall that the RD between two offset discrete
Gaussians is bounded as follows.
Lemma 2.11 (Lemma 4.2 in [26]). For any ğ‘›-dimensional
lattice ğ¿ âŠ† Rğ‘› and invertible matrix Î£, set ğ‘ƒ = ğ·Î›,Î£,w and
ğ‘„ = ğ·Î›,Î£,z for some fixed w, z âˆˆ Î›. Then, ğ‘…(ğ‘ƒâ€–ğ‘„) â‰¤
exp(2ğœ‹â€–w âˆ’ zâ€–2/ğ‘ ğ‘›(Î£)2).
Then, we proceed to the proof of Lemma 2.9.
Proof of Lemma 2.9. Let ğ´ âŠ† Zğ‘›Ã—ğ‘š be the set of X =
(X1|X2) such that U satisfying the properties listed in the
statement does not exist. Theorem 2.8 implies that when X is
Ã— (ğ·Zğ‘š2 ,ğœ2,ğ›¿1 Ã—
sampled from the distribution ğ‘„ := ğ·ğ‘š1Ã—ğ‘š2
Â·Â·Â·Ã—ğ·Zğ‘š2 ,ğœ2,ğ›¿ğ‘› )ğ‘¡, we have ğ‘„(ğ´) â‰¤ 2âˆ’Î©(ğ‘›â€²). We want to prove
that ğ‘ƒ (ğ´) = 2âˆ’Î©(ğ‘›â€²) for the distribution ğ‘ƒ := ğ·ğ‘›Ã—ğ‘š1
Ã—
Z,ğœ1
ğ·ğ‘›Ã—ğ‘š2
Z,ğœ2
ğ‘…(ğ‘ƒâ€–ğ‘„) = ğ‘‚(1). We have
. By Lemma 2.10, we have ğ‘ƒ (ğ´) â‰¤âˆšï¸€ğ‘„(ğ´) Â· ğ‘…(ğ‘ƒâ€–ğ‘„) â‰¤
âˆšï¸€ğ‘…(ğ‘ƒâ€–ğ‘„)Â· 2âˆ’Î©(ğ‘›â€²). To complete the proof, it suffices to show
ğ‘…(ğ‘ƒâ€–ğ‘„) = ğ‘…(ï¸€ğ·ğ‘›Ã—ğ‘š1
Ã—(ğ·Zğ‘š2 ,ğœ2,ğ›¿1 Ã— Â·Â·Â· Ã— ğ·Zğ‘š2 ,ğœ2,ğ›¿ğ‘› ))ï¸€
Ã— ğ·ğ‘›Ã—ğ‘š2
Z,ğœ2
â€–ğ·ğ‘š1Ã—ğ‘š2
Z,ğœ1
Z,ğœ1
Z,ğœ1
= ğ‘…((ğ·Z,ğœ2 )ğ‘›â€–(ğ·Z,ğœ2,1)ğ‘›)
â‰¤ exp(2ğœ‹ğ‘›/ğœ2
2),
where we use Lemma 2.11 in the last inequality. Since ğœ2 â‰¥
â„¦(ğ‘›1/2), we conclude that ğ‘…(ğ‘ƒâ€–ğ‘„) = ğ‘‚(1). This completes
â–¡
the proof of Lemma 2.9.
Next, we define the learning with errors (LWE) assumption.
It was shown that the assumption holds as long as certain
lattice problems are hard in the worst case [12, 34, 36].
Definition 2.12. For an integers ğ‘› = ğ‘›(ğœ†), ğ‘š = ğ‘š(ğœ†),
ğ‘ = ğ‘(ğœ†), a real number ğ›¼(ğœ†) âˆˆ (0, 1), and an algorithm ğ’œ, the
advantage for the learning with errors problem LWEğ‘›,ğ‘š,ğ‘,ğ›¼
of ğ’œ is defined as follows:
âƒ’âƒ’ Pr[ğ’œ(A, As + x) â†’ 1] âˆ’ Pr[ğ’œ(A, w + x) â†’ 1]âƒ’âƒ’
ğ‘ , and x â†Ë’ ğ·ğ‘šZ,ğ›¼ğ‘. We
where A â†Ë’ Zğ‘›Ã—ğ‘š
say that LWEğ‘›,ğ‘š,ğ‘,ğ›¼ assumption holds if the advantage is
negligible for every probabilistic polynomial-time ğ’œ.
ğ‘ , w â†Ë’ Zğ‘š
, s â†Ë’ Zğ‘›
ğ‘
3 TRACE AND REVOKE FROM
INNER-PRODUCT FUNCTIONAL
ENCRYPTION
In this section, we provide a generic transformation from
a bounded collusion, random keys inner-product functional
encryption scheme â„±â„° to a trace-and-revoke scheme ğ’¯ â„›.
Since intuition was provided in Section 1, we proceed directly
to the formal construction.
3.1 The Scheme
We construct a trace-and-revoke scheme ğ’¯ â„› following the
specifications of Definition 2.1. Our scheme assumes the
existence of a public directory pd which contains the identities
of the users that have been assigned keys in the system. The
public directory is initially empty. We assume that pd can
only be modified by a central authority (the key generator).
(1) Setup(1ğœ†, 1ğ‘¡, 1ğ‘Ÿ). Upon input the security parameter ğœ†,
the bound ğ‘¡ on the number of traitors and the bound
ğ‘Ÿ on the number of revoked users, proceed as follows:
(a) Let (pk, msk) â† â„±â„°.Setup(1ğœ†, 1â„“), where â„“ = ğ‘¡+ğ‘Ÿ+1.
(b) Output the public key pk and master secret key msk.
(2) KeyGen(msk, id). Upon input the master secret key msk
to the public directory pd.
ğ‘. The pair ğ‘id = (id, xid) is appended
and a user identity id âˆˆ ID, proceed as follows:
(a) Sample xid â†Ë’ Zâ„“
(b) Let skid â† â„±â„°.KeyGen(msk, xid).
(c) Output skid.
(3) Enc(pd, pk,â„›, ğ‘š). Upon input the public key pk, a set
of revoked users â„› of cardinality â‰¤ ğ‘Ÿ and a plaintext
messages ğ‘š âˆˆ â„³ = Zğ‘, proceed as follows:
(a) Compute vâ„› âˆˆ Zâ„“
ğ‘ âˆ– {âƒ—0} such that âŸ¨xid, vâ„›âŸ© = 0 for
(b) Compute yâ„› = ğ‘š Â· vâ„›.
(c) Output ğ¶ = (ğ¶1, ğ¶2) = (â„±â„°.Enc(pk, yâ„›),â„›).
every id âˆˆ â„›.
every id âˆˆ â„›.
(4) Dec(pd, skid, ğ¶). Upon input the secret key skid for user
id and a ciphertext ğ¶ = (ğ¶1, ğ¶2), proceed as follows:
(a) Parse ğ¶2 as ğ¶2 = â„›. If id âˆˆ â„›, then abort.
(b) Compute vâ„› âˆˆ Zâ„“
ğ‘ âˆ– {âƒ—0} such that âŸ¨xid, vâ„›âŸ© = 0 for
(c) Compute and output ğ‘š = â„±â„°.Dec(skid, ğ¶1)/âŸ¨xid, vâ„›âŸ©.
(5) Trace(pd,â„›,ğ’®,ğ’ªğ’Ÿ). Upon input the public directory pd,
a revoked set of users â„›, a suspect set ğ’® of users and
given access to the oracle ğ’ªğ’Ÿ, first proceed as follows:
(a) Find ğ‘š, ğ‘šâ€² âˆˆ â„³ such that the following quantity is
Pr
ğ¶â†Ë’Enc(pd,pk,â„›,ğ‘š)
âˆ’
Pr
(ğ¶, ğ‘š) = 1
â€²
, ğ‘š) = 1
ğ¶â€²â†Ë’Enc(pd,pk,â„›,ğ‘šâ€²)
(ğ¶
(b) Set ğ’®1 = {id1, id2, . . .} = ğ’® âˆ– â„›.
(c) Compute vâ„› âˆˆ Zâ„“
every id âˆˆ â„›.
ğ‘ âˆ– {âƒ—0} such that âŸ¨xid, vâ„›âŸ© = 0 for
Then execute the following steps with ğ‘– = 1, 2, . . .:
(d) If ğ‘– = 1, set vğ’®ğ‘– = âƒ—0. If ğ’®ğ‘– = âˆ…, set vğ’®ğ‘– = (ğ‘šâ€²âˆ’ğ‘š)Â·vâ„›.
Else compute vğ’®ğ‘– âˆˆ Zâ„“
(i) âŸ¨xid, vğ’®ğ‘–âŸ© = 0 for every id âˆˆ ğ’®ğ‘– âˆª â„›.
(ii) âŸ¨xid, vğ’®ğ‘–âŸ© = (ğ‘šâ€² âˆ’ ğ‘š) Â· âŸ¨xid, vâ„›âŸ© for every id âˆˆ
ğ‘ such that:
ğ’®1 âˆ– ğ’®ğ‘–.
(e) Repeat the following steps sufficiently many times
(as dictated by Hoeffdingâ€™s inequality) to compute an
approximation of the probability ğ‘ğ‘– that the response
from ğ’ªğ’Ÿ is ğ‘ğ‘– = 1.
(i) Construct y = vğ’®ğ‘– + ğ‘š Â· vâ„› âˆˆ Zâ„“
ğ‘;
(ii) The probe ciphertext is ğ¶ğ’®ğ‘– = (â„±â„°.Enc(pk, y),â„›);
non-negligible:
âƒ’âƒ’âƒ’
[ï¸ğ’ªğ’Ÿ
[ï¸ğ’ªğ’Ÿ
]ï¸
]ï¸âƒ’âƒ’âƒ’.
Session K1:  Secure ComputationCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA2284get a binary value ğ‘ğ‘– as output.
(iii) Provide the oracle ğ’ªğ’Ÿ with (ğ¶ğ’®ğ‘– , ğ‘š) as input and
(f) If ğ‘– > 1 and |ğ‘ğ‘– âˆ’ ğ‘ğ‘–âˆ’1| is non-negligible, then output
(g) If ğ’®ğ‘– = âˆ…, then output âŠ¥ and abort; else, set ğ’®ğ‘–+1 =
idğ‘–âˆ’1 and abort;
ğ’®ğ‘– âˆ– {idğ‘–}.
For the correctness and the tracing security proof, we
require that in Step (a) of Algorithm Enc, in Step (b) of Algo-
rithm Dec and in Step (c) of Algorithm Trace, the vector vâ„›
be uniquely determined by â„›, in the same unique way across
all algorithms. One way of achieving this property is to order
the xidâ€™s for id âˆˆ â„› lexicographically, and run a deterministic
linear system solver. We proceed in the same way (using
always the same deterministic algorithm) for vector vğ’®ğ‘– at
Step (d) of Algorithm Trace.
We remark that one can send â„› instead of vâ„› in the
encryption algorithm. This will make the ciphertext longer,
but make the encryption and decryption algorithms slightly
more efficient.
We first check the correctness of the scheme.
Theorem 3.1. Assume that ğ‘ = ğœ†ğœ”(1). Let â„› be a set of
revoked users of cardinality â‰¤ ğ‘Ÿ. Then, for every id /âˆˆ â„› and
every ğ‘š âˆˆ â„³ = Zğ‘, we have
Dec(pd, skid, Enc(pd, pk,â„›, ğ‘š)) = ğ‘š,
with probability â‰¥ 1 âˆ’ ğœ†âˆ’ğœ”(1).
Proof. As xid is uniform in Zâ„“
ğ‘, and thanks to the parame-
ter choices of ğ‘ = ğœ†ğœ”(1) and â„“ > ğ‘Ÿ, we have that âŸ¨xid, vâ„›âŸ© Ì¸= 0,
with overwhelming probability. The execution of Dec(pd, skid, ğ¶),
with ğ¶ = (ğ¶1, ğ¶2) = Enc(pd, pk,â„›, ğ‘š), proceeds to Step (b)
and computes (with overwhelming probability):
Dec(pd, skid, ğ¶) =