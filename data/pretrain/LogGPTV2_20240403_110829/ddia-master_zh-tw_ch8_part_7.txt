#### 全域性快照的同步时钟
在 “[快照隔离和可重复读](ch7.md#快照隔离和可重复读)” 中，我们讨论了快照隔离，这是资料库中非常有用的功能，需要支援小型快速读写事务和大型长时间执行的只读事务（用于备份或分析）。它允许只读事务看到特定时间点的处于一致状态的资料库，且不会锁定和干扰读写事务。
快照隔离最常见的实现需要单调递增的事务 ID。如果写入比快照晚（即，写入具有比快照更大的事务 ID），则该写入对于快照事务是不可见的。在单节点资料库上，一个简单的计数器就足以生成事务 ID。
但是当资料库分布在许多机器上，也许可能在多个数据中心中时，由于需要协调，（跨所有分割槽）全域性单调递增的事务 ID 会很难生成。事务 ID 必须反映因果关系：如果事务 B 读取由事务 A 写入的值，则 B 必须具有比 A 更大的事务 ID，否则快照就无法保持一致。在有大量的小规模、高频率的事务情景下，在分散式系统中建立事务 ID 成为一个难以处理的瓶颈 [^vi]。
[^vi]: 存在分散式序列号生成器，例如 Twitter 的雪花（Snowflake），其以可伸缩的方式（例如，透过将 ID 空间的块分配给不同节点）近似单调地增加唯一 ID。但是，它们通常无法保证与因果关系一致的排序，因为分配的 ID 块的时间范围比资料库读取和写入的时间范围要长。另请参阅 “[顺序保证](ch9.md#顺序保证)”。
我们可以使用同步时钟的时间戳作为事务 ID 吗？如果我们能够获得足够好的同步性，那么这种方法将具有很合适的属性：更晚的事务会有更大的时间戳。当然，问题在于时钟精度的不确定性。
Spanner 以这种方式实现跨资料中心的快照隔离【59，60】。它使用 TrueTime API 报告的时钟置信区间，并基于以下观察结果：如果你有两个置信区间，每个置信区间包含最早和最晚可能的时间戳（$A = [A_{earliest}, A_{latest}]$，$B=[B_{earliest}, B_{latest}]$），这两个区间不重叠（即：$A_{earliest} <A_{latest} <B_{earliest} <B_{latest}$）的话，那么 B 肯定发生在 A 之后 —— 这是毫无疑问的。只有当区间重叠时，我们才不确定 A 和 B 发生的顺序。
为了确保事务时间戳反映因果关系，在提交读写事务之前，Spanner 在提交读写事务时，会故意等待置信区间长度的时间。透过这样，它可以确保任何可能读取资料的事务处于足够晚的时间，因此它们的置信区间不会重叠。为了保持尽可能短的等待时间，Spanner 需要保持尽可能小的时钟不确定性，为此，Google 在每个资料中心都部署了一个 GPS 接收器或原子钟，这允许时钟同步到大约 7 毫秒以内【41】。
对分散式事务语义使用时钟同步是一个活跃的研究领域【57,61,62】。这些想法很有趣，但是它们还没有在谷歌之外的主流资料库中实现。
### 程序暂停
让我们考虑在分散式系统中使用危险时钟的另一个例子。假设你有一个数据库，每个分割槽只有一个领导者。只有领导被允许接受写入。一个节点如何知道它仍然是领导者（它并没有被别人宣告为死亡），并且它可以安全地接受写入？
一种选择是领导者从其他节点获得一个 **租约（lease）**，类似一个带超时的锁【63】。任一时刻只有一个节点可以持有租约 —— 因此，当一个节点获得一个租约时，它知道它在某段时间内自己是领导者，直到租约到期。为了保持领导地位，节点必须周期性地在租约过期前续期。
如果节点发生故障，就会停止续期，所以当租约过期时，另一个节点可以接管。
可以想象，请求处理回圈看起来像这样：
```java
while (true) {
  request = getIncomingRequest();
  // 确保租约还剩下至少 10 秒
  if (lease.expiryTimeMillis - System.currentTimeMillis() < 10000){
    lease = lease.renew();
  }
  if (lease.isValid()) {
    process(request);
  }
}
```
这个程式码有什么问题？首先，它依赖于同步时钟：租约到期时间由另一台机器设定（例如，当前时间加上 30 秒，计算到期时间），并将其与本地系统时钟进行比较。如果时钟不同步超过几秒，这段程式码将开始做奇怪的事情。
其次，即使我们将协议更改为仅使用本地单调时钟，也存在另一个问题：程式码假定在执行剩余时间检查 `System.currentTimeMillis()` 和实际执行请求 `process(request)` 中间的时间间隔非常短。通常情况下，这段程式码执行得非常快，所以 10 秒的缓冲区已经足够确保 **租约** 在请求处理到一半时不会过期。
但是，如果程式执行中出现了意外的停顿呢？例如，想象一下，执行绪在 `lease.isValid()` 行周围停止 15 秒，然后才继续。在这种情况下，在请求被处理的时候，租约可能已经过期，而另一个节点已经接管了领导。然而，没有什么可以告诉这个执行绪已经暂停了这么长时间了，所以这段程式码不会注意到租约已经到期了，直到回圈的下一个迭代 —— 到那个时候它可能已经做了一些不安全的处理请求。
假设一个执行绪可能会暂停很长时间，这是疯了吗？不幸的是，这种情况发生的原因有很多种：
* 许多程式语言执行时（如 Java 虚拟机器）都有一个垃圾收集器（GC），偶尔需要停止所有正在执行的执行绪。这些 “**停止所有处理（stop-the-world）**”GC 暂停有时会持续几分钟【64】！甚至像 HotSpot JVM 的 CMS 这样的所谓的 “并行” 垃圾收集器也不能完全与应用程式程式码并行执行，它需要不时地停止所有处理【65】。尽管通常可以透过改变分配模式或调整 GC 设定来减少暂停【66】，但是如果我们想要提供健壮的保证，就必须假设最坏的情况发生。
* 在虚拟化环境中，可以 **挂起（suspend）** 虚拟机器（暂停执行所有程序并将记忆体内容储存到磁碟）并恢复（恢复记忆体内容并继续执行）。这个暂停可以在程序执行的任何时候发生，并且可以持续任意长的时间。这个功能有时用于虚拟机器从一个主机到另一个主机的实时迁移，而不需要重新启动，在这种情况下，暂停的长度取决于程序写入记忆体的速率【67】。
* 在终端使用者的装置（如膝上型电脑）上，执行也可能被暂停并随意恢复，例如当用户关闭膝上型电脑的盖子时。
* 当作业系统上下文切换到另一个执行绪时，或者当管理程式切换到另一个虚拟机器时（在虚拟机器中执行时），当前正在执行的执行绪可能在程式码中的任意点处暂停。在虚拟机器的情况下，在其他虚拟机器中花费的 CPU 时间被称为 **窃取时间（steal time）**。如果机器处于沉重的负载下（即，如果等待执行的执行绪伫列很长），暂停的执行绪再次执行可能需要一些时间。
* 如果应用程式执行同步磁碟访问，则执行绪可能暂停，等待缓慢的磁碟 I/O 操作完成【68】。在许多语言中，即使程式码没有包含档案访问，磁碟访问也可能出乎意料地发生 —— 例如，Java 类载入器在第一次使用时惰性载入类档案，这可能在程式执行过程中随时发生。I/O 暂停和 GC 暂停甚至可能合谋组合它们的延迟【69】。如果磁碟实际上是一个网路档案系统或网路块装置（如亚马逊的 EBS），I/O 延迟进一步受到网路延迟变化的影响【29】。
* 如果作业系统配置为允许交换到磁碟（页面交换），则简单的记忆体访问可能导致 **页面错误（page fault）**，要求将磁碟中的页面装入记忆体。当这个缓慢的 I/O 操作发生时，执行绪暂停。如果记忆体压力很高，则可能需要将另一个页面换出到磁碟。在极端情况下，作业系统可能花费大部分时间将页面交换到记忆体中，而实际上完成的工作很少（这被称为 **抖动**，即 thrashing）。为了避免这个问题，通常在伺服器机器上停用页面排程（如果你宁愿干掉一个程序来释放记忆体，也不愿意冒抖动风险）。
* 可以透过传送 SIGSTOP 讯号来暂停 Unix 程序，例如透过在 shell 中按下 Ctrl-Z。这个讯号立即阻止程序继续执行更多的 CPU 周期，直到 SIGCONT 恢复为止，此时它将继续执行。即使你的环境通常不使用 SIGSTOP，也可能由运维工程师意外发送。