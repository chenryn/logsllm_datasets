Figure 13: CDF of connection setup
time, RTT=0.2ms.
512
1024
2048
4096
8192
16384
32768
File size (bytes)
Figure 14: Data transfer duration using
SMKEX over trans-atlantic tunnels.
To run SMKEX, our library implementation rst opens an MPTCP
connection and uses an MPTCP API (from Hesmans et al.[23]) that
blocks until the specied number of subows is created. If the con-
nection falls back to regular TCP the SMKEX handshake fails; the
same happens if the desired number of subows is not created in a
predened amount of time.
Once the MPTCP connection has enough active subows (two
by default), SMKEX can start the handshake. However, if we simply
send SMKEX messages using the sockets API provided by default
by MPTCP, there is no control over the subow that will carry the
handshake data. In most cases, all the messages will be delivered
by the rst subow, and this would break the security of SMKEX
making MITM attacks easy to execute.
To send and receive data on specic subows, we have made
two changes to the MPTCP Linux kernel implementation as fol-
lows: a) the send syscall allows specifying which subow must
carry the provided application data, and b) the receive syscall
allows specifying which subow to receive data from. When data
is received on another subow than the expected one, the recv
returns a specic error code telling the library which subow it
should read data from. Finally, to avoid changing the syscall API,
our implementation reuses an unused byte in the flags parameter
to specify the desired subow in the send and recv calls.
Finally, we use the fullmesh MPTCP path manager that, by de-
fault, creates one subow for each interface: a mobile client, for
instance, will create two subows to the server, one on cellular and
one on Wi.
CDN integration. There are two deployment scenarios we target;
in both scenarios, a server and a mobile client support SMKEX
running over MPTCP. The rst scenario is the one depicted in
Figure 5, where the MPTCP subows are terminated at the server.
The second scenario involves a CDN and is shown in Figure 12: in
this case the two subows do not reach the same server, and an
additional mechanism is required to direct the secondary MPTCP
subows to the appropriate server. This is the preferred scenario
for SMKEX because it provides the best path diversity, as shown in
our measurement study; we discuss it next.
To route client trac to nearby edge servers, CDNs use one of
two approaches: DNS redirection, where the client location is used
to select a local replica, or use IP anycast where all edge servers ad-
vertise the same IP address and Internet routing distributed clients
to their closest servers. In this paper, we assume the edge servers
rely on IP anycast; this solution is used by many, including the
Microsoft CDN [21].
Consider the example in Figure 12, where the service address
A is advertised in BGP by both edge servers. When the MPTCP
connection starts over the cellular interface, its rst subow will
be handled by edge server 1 which is closest to the client (from a
routing hops point of view). Edge server 1 will serve content from
its local cache, or contact the origin server the required content is
not cached. When the client opens its wireless subow, the resulting
subow will reach edge server 2. The only remaining problem is
that edge server 2 must now forward the subow to edge server 1
over the CDN’s internal network.
To achieve this, we use Beamer [40], a load balancer that supports
MPTCP. To use Beamer, the CDN rst assigns a unique numeric
identier to each of its edge servers. Beamer works as follows: when
the rst subow is setup to edge server 1, the edge server will tell
the client its unique identier. The client will include this identier
into its second subow which will reach edge server 2; this server
will simply proxy the connection to edge server 1.
Note that on-path attackers can modify the connection ID, but
the only eect is that the secondary subows will be rerouted
incorrectly in the CDN network, and will be broken (i.e. edge server
2 will send the subow to another edge server instead of sending
to edge server 1). In this case, the SMKEX handshake will fail.
Practicality of SMKEX. While this section shows that SMKEX
relies on CDN’s and popular websites to update their infrastructure
in order to ensure the highest security possible, it is important
to note that MPTCP deployment requires the same changes as
SMKEX: an MPTCP enabled kernel and a load balancer. We believe
such deployment is near because load balancers are already widely
deployed in production [18, 36, 41] and MPTCP is already widely
deployed on mobile clients.
9 EVALUATION
The goal of our evaluation is to test the correctness of our implemen-
tation and its behavior in practice. We tested our implementation
on our local testbed and using Amazon to create wide-area path
diversity.
Testbed experiments. In our rst experiment, the client and server
run on two quad-core Xeon machines connected via two Gigabit
links emulating the dierent paths. Our client repeatedly sets up
an encrypted connection to the server and we measure the time it
takes to perform the connection handshake. Figure 13 shows the
 0 20 40 60 80 100 0.3 0.35 0.4 0.45 0.5 0.55 0.6CDF (%)Connection setup time (ms)DHSMKEXCDF of connection setup times for SMKEX compared to standard
Die-Hellman. In the median, SMKEX takes about 50µs more than
standard Die Hellman; this dierence is explained by the addi-
tional round-trip time our MPTCP-based implementation requires.
MPTCP only sets up the second subow after the rst subow is
setup.
Amazon EC2 Experiments. To test our path diversity setup, we
rented two VMs in two EC2 datacenters on the east coast (Virginia
and Ohio). One VM terminates a long term client tunnel, oering
path diversity. The other VM is used to emulate an edge CDN server.
Our server and client are close to each other (5ms RTT), but they
also set up a path via the USA using long-term openVPN tunnels
to one of the Amazon VMs. Our client repeatedly downloads les
of dierent sizes from the server. In gure 14 we plot the total
download time. The measured latencies are as follows: the long
path has an RTT of 280ms (crossing the Atlantic four times), and
the short path has an RTT of 5ms.
For small les, the expected download latency should be domi-
nated by the long path RTT: our implementation requires two RTTs
over this path, one to setup the MPTCP subow and one to perform
the key exchange. After the key is set up, the server sends all data
via the low latency path. The experiments conrm this hypothesis
the latency is around 650ms for all le sizes we tested. The le size
has little inuence on the download because the local, high-speed
(50Mbps) link is used for data transfer.
10 EXTENSIONS OF SMKEX
Due to its simplicity, SMKEX may be easily extended to actually
increase the security of TOFU or TLS-like protocols. In the pre-
vious sections, we have focused on the basic version of SMKEX,
because this provides the highest degree of usability. As Unger et
al. [49] write, “defending against mass surveillance requires a com-
munication system that virtually all users can successfully use. Thus,
it may be wise to start from the basic user experience of today’s widely
deployed communication apps and try to add as much security as
possible...”. Hence, in this section we show two possible enhance-
ments of SMKEX: (a) TOFU enhancement; (b) TLS integration. In
§C.3, we also discuss the possibility of using double ratcheting to
provide forward and backward secrecy even across messages from
a single session. Note that these extensions are shown informally,
with the goal to show how SMKEX can be used in various other
scenarios. We leave a formal analysis of these extensions and their
implementation to future work.
10.1 TOFU enhancement
SMKEX can be enhanced by using a Trust-on-rst-use (TOFU) ap-
proach6, increasing the security of applications that rely on TOFU
authentication, such as SSH or websites using self-signed certi-
cates.
This could be done by having the server use a long-term pub-
lic/private key pair which is stored by clients and then used together
with the server’s ephemeral public key to derive the session key.
That is, if we let X =  x be the ephemeral public key of the client
(with corresponding private key x), Y =    be the ephemeral public
6Term probably coined by Wendlandt et al. [50].
Client
A1
A2
A1
A2
 x
NC
   ,  ls
NS , H( x , NC ,    , NS ,  ls)
Figure 15: TOFU-based SMKEX protocol.
Server
B1
B2
B1
B2
key of the server (with private key  ) and LS =  ls be the long-term
public key (with corresponding private key ls), then the client can
send as input to the key derivation the concatenation of Y x and
S, while the server would use X  and X ls. A similar approach,
Lx
but requiring the client to also use a long-term key, is used in Sig-
nal [46], known as triple Die-Hellman, possibly inspired from
Protocol 4 of Blake-Wilson et al. [5]. A similar protocol has also
been proposed and analyzed by Krawczyk and Wee [30].
A depiction of our modied protocol with the server using a
long-term key is shown in Figure 15. As mentioned by Wendlandt
et al. [50], existing TOFU protocols suer from two main issues: a)
possible active attacks during the rst connection; b) possible active
attacks during an update of the server’s long-term key. With our
TOFU-based SMKEX protocol, such attacks are no longer possible
in the A/A and A-P scenarios. Therefore, by storing and checking
the server’s long-term public key, our TOFU-based SMKEX proto-
col provides partial protection against active adversaries (i.e., A/A
and A-P) during initial setup and during server key update (which
was not the case for previous TOFU approaches), while providing
protection even against A-A adversaries if these are not able to
synchronize during the initial key setup (or key update).
The main disadvantage of TOFU-based approaches (including
this extension of SMKEX), is that when long-term keys change
(either genuinely or due to an attack), the client is forced to either:
a) drop the connection (if we want no user interaction) or b) ask the
user about what to do in this case (which might hinder usability).
Nevertheless, given that previous TOFU-based methods pro-
vided the highest security for opportunistic encryption (see the
survey of Unger et al. [49, Table I]) and that SMKEX also increases
the security of TOFU approaches, we can conclude that using a
TOFU-enhanced SMKEX protocol provides the highest security for
opportunistic encryption to date.
10.2 Integration into TLS
We can also easily integrate SMKEX with TLS, obtaining a combined
protocol (which we called MTLS) that provides increased security
over TLS, while retaining all the security benets of the classic
single-path TLS. This extension benets TLS security in two ways:
rst, it provides improved opportunistic security to unauthenticated
TLS, which is described in [44, Section C.5]. Second, it works as an
additional barrier in case of Certicate Authority (CA) attacks, as
described below.
Several attacks on TLS have exploited problems with CAs: some
have issued certicates to invalid parties [33], some have been
attacked and rogue certicates issued [17, 20], checking revoked
certicates is dicult [35], many share their secret keys with possi-
bly less-secure partners [7]. Privacy issues also appear when large
institutions monitor employees with the help of fake certicates
Protocol
SMKEX
TLS
MTLS
A-A
A-P, A/A
Auth Rogue Auth Rogue
-
X
X
-
X
X
Table 3: Comparing the security features of SMKEX, TLS and
MTLS
Client
A1
A2
A1
A2
ClientHello,  x
NC
ServerHello,   
NS , H(NC ,  x , NS ,   )
Server
B1
B2
B1
B2
Figure 16: Key exchange in Multipath TLS (MTLS) proto-
col. The rst path executes the standard TLS key exchange,
while the second path is used to validate keying information
similarly to SMKEX.
installed in browsers. Finally, governments might force their ISPs
and local CAs to collaborate and trick users into using rogue certi-
cates. By combining SMKEX with TLS we may thwart such attacks.
We illustrate the advantage of MTLS over single TLS or SMKEX
in Table 3 for the dierent attackers (A-P, A/A, A-A) and scenarios
(authentic and rogue certicates).
We illustrate our design using TLS1.3. SMKEX is supported with
the (EC)DHE exchange mode and the PSK with (EC)DHE key ex-
change mode. Accordingly, we assume that the client and servers
exchange some form of Die-Hellman public key shares  x and
   (nite-eld or elliptic curves). We only improve the security of
the server authentication portion of TLS; client authentication and
other key exchange extensions downgrade to the single path case.
Figure 16 illustrates the MTLS key exchange. The standard TLS
key exchange runs on the rst path, with two modications. First,
the Client Hello message indicates in an extension that MTLS is
used, and the ClientHello.random NC in this message, as well as
the ServerHello.random NS in the response, are dropped.7 MTLS
introduces two new messages on the second path. The client sends
NC, and the server responds with NS as well as a hash of NC, NS,
 x and   .
MTLS provides all the security of a standard TLS exchange, with
added protection against attackers that forge the server’s long term
secret. For example, in the case of a forged certicate an attacker
that is only present on the rst path is unable to successfully com-
plete the key exchange with the client. The verication of the hash
fails at the client, and the key exchange terminates immediately.
More precisely, MTLS provides security against all attackers
for which the test session is either fresh according to the original