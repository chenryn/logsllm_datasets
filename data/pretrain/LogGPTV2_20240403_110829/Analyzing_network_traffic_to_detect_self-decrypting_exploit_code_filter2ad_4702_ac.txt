software ﬂaws to counter various attacks. This approach
requires information about the source code.
Work on static binary disassembly is also relevant to this
work. There are two widely used disassembly techniques.
The linear sweep method, which decodes bytes sequentially,
has diﬃculties distinguishing between embedded data and
actual instructions. Therefore it can be defeated by data in-
jection attacks, and by other attacks, such as the use of over-
lapping instructions. Figure 2(a) shows an example where
this is the case. Recursive traversal, which decodes bytes by
following the control ﬂow of the program, can better deal
with such attacks. However, it requires the entry point of
the program to be known in advance. Moreover, the target
address of a branch instruction cannot always be statically
determined by recursive traversal. In this case, linear sweep
may recover more valid instructions. Kruegel et al.
[13]
proposed an advanced disassembly technique. This method
used the program’s control ﬂow graph and statistical tech-
niques to correctly identify a large fraction of the program’s
instructions. However, the assumptions of this method are
not fully compatible with the requirements for disassem-
bling code in network traﬃc, i.e the absent information of
program starting location. In addition, it does not correctly
handle code in which self-modifying and/or overlapping in-
structions are used.
3. THE PROPOSED METHOD
This section describes a network-level hybrid method for
the detection of polymorphic exploit code. First, the detec-
tion methods based on static binary code analysis [10, 23,
22, 9] can possibly identify the control ﬂow and data ﬂow
information of the exploit code. However they cannot well
handle static analysis resistant (i.e.
self-modifying) poly-
morphic exploit code which will not reveal its actual form
until it is actually executed. Second, the detection method
based on emulated execution of network traﬃc [19] is doing
better in this aspect. However it will incur a high process-
ing overhead if each instruction sequence is executed. Simple
strategies to select possible instruction sequences for execu-
tion will miss some attacks.
We are motivated to explore whether it is possible to de-
tect such highly obfuscated polymorphic exploit code by
combining these two types of techniques.
3.1 Overview of the Proposed Method
The overall idea is to scan the network traﬃc for the
presence of the decryption routine which is characteristic of
polymorphic exploit code. Static analysis is used to locate
the decryption routine inside the network traﬃc. Limited
emulation of instruction execution is performed to reveal
concealed components such as self-modifying instructions of
the decryption routine. Moreover, a heuristic approach is
explored to further increase the overall accuracy.
More speciﬁcally, a form of GetP C code is ﬁrst looked for
as the basic means of locating the start of the decryption
routine. GetP C code is a generally inevitable component of
a decryption routine. As argued by Polychronakis et al. [19],
reliable exploit code should avoid any hard-coded absolute
addressing. Therefore, the decryption routine must have
some way to dynamically determine the address of the en-
crypted payload in the vulnerable program’s address space,
in order to modify it. This is accomplished by GetP C code,
which computes absolute addresses as oﬀsets from the cur-
rent value of the program counter (the P C). The GetP C
code should be among the very few instructions that cannot
be self-modifying or concealed, and it also should be among
the very few ﬁrst functional instructions of a decryption rou-
tine. Therefore, detection of GetP C code helps localize the
start of the decryption routine.
Then, the rest of the decryption routine is found by travers-
ing the bytes from where the GetP C code is found, and look-
ing for a loop in the control ﬂow structure. Loops are likely
to occur in decryption routines for the simple reason that
decryption of a sequence of bytes is a very repetitive process.
Recursive traversal disassembly is generally useful enough to
derive the control ﬂow structure if no complex static analysis
resistant techniques are involved. Otherwise, the task is ac-
complished by a novel two-way traversal and backward data-
ﬂow analysis to more precisely pinpoint the non-concealed
instructions of the decryption routine, and by emulated in-
struction execution on already found instructions to reveal
the concealed component, i.e. the self-modifying part of the
decryption routine.
Finally, the detected code is veriﬁed to improve the over-
all accuracy. The proposed approach checks whether the
detected code satisﬁes two properties that we observe from
typical decryption routines. These properties have not been
used for this purpose previously.
We now describe the method in detail, starting with the
decryption routine localization.
3.2 Decryption Routine Localization
Generally speaking, a decryption routine is suspected if
the control ﬂow structure shows the existence of a loop.
3.2.1 General Approach
Our general approach works by ﬁrst ﬁnding the starting
point of the decryption routine and then using recursive
traversal to ﬁnd the loop structure of the decryption rou-
tine.
Starting Point Localization
The ﬁrst step is to ﬁnd the starting instruction of the de-
cryption routine which is hidden within the network traﬃc.
This is done by scanning network traﬃc for candidate seed-
ing instructions of GetP C code. We now explain GetP C
code and seeding instructions.
We now ﬁrst give an overview to the proposed method.
GetP C code is a generally inevitable component of the
Figure 2: Disassembly of decryption routines for a) Countdown b) JmpCallAdditive encoders. In each ﬁgure, the left-
most column shows instructions’ addresses represented in hex format; the middle column shows the actual instruction
bytes; the rightmost column shows the decoded instructions. The underlined instructions are the seeding instruction,
the instruction for decrypting the encrypted exploit payload and the instruction for updating the address of encrypted
exploit payload. For both examples, a loop structure is presented. In ﬁgure a), instruction call 000A at address 0006
and pop esi at address 000C are the GetP C code of this example. Similarly, in ﬁgure b), instruction call 0002 at address
000E and pop esi at address 0002 are the GetP C code.
decryption routine.
It is used to dynamically determine
the address of the encrypted payload in the vulnerable pro-
gram’s address space, in order to modify it. Polychronakis
et al. [19] identiﬁed two 1 feasible and easy forms of GetP C
code. One way is through a call instruction. Execution of
a call instruction pushes the return address (the PC) onto
the stack. The decryption routine when executed can easily
read this return address from the stack. The second way