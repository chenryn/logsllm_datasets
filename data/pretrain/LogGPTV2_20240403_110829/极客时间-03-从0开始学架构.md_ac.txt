# 02 \| 架构设计的历史背景理解了架构的有关概念和定义之后，今天，我会给你讲讲[架构设计的历史背景]{.orange}。我认为，如果想要深入理解一个事物的本质，最好的方式就是去追寻这个事物出现的历史背景和推动因素。我们先来简单梳理一下软件开发进化的历史，探索一下软件架构出现的历史背景。
## 机器语言（1940 年之前） {#03.html#-1940-}最早的软件开发使用的是"**机器语言**"，直接使用二进制码 0 和 1来表示机器可以识别的指令和数据。例如，在 8086机器上完成"s=768+12288-1280"的数学运算，机器码如下：    101100000000000000000011000001010000000000110000001011010000000000000101不用多说，不管是当时的程序员，还是现在的程序员，第一眼看到这样一串东西时，肯定是一头雾水，因为这实在是太难看懂了，这还只是一行运算，如果要输出一个"helloworld"，面对几十上百行这样的 0/1 串，眼睛都要花了！看都没法看，更何况去写这样的程序，如果不小心哪个地方敲错了，将 1 敲成了0，例如：    101100000000000000000011000001010000000000110000001011000000000000000101如果要找出这个程序中的错误，程序员的心里阴影面积有多大？归纳一下，机器语言的主要问题是三难：**太难写、太难读、太难改**！
## 汇编语言（20 世纪 40 年代） {#03.html#-20-40-}为了解决机器语言编写、阅读、修改复杂的问题，**汇编语言**应运而生。汇编语言又叫"**符号语言**"，用助记符代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。例如，为了完成"将寄存器 BX 的内容送到 AX中"的简单操作，汇编语言和机器语言分别如下。    机器语言：1000100111011000汇编语言：mov ax,bx相比机器语言来说，汇编语言就清晰得多了。mov 是操作，ax 和 bx是寄存器代号，mov ax,bx 语句基本上就是"将寄存器 BX 的内容送到AX"的简化版的翻译，即使不懂汇编，单纯看到这样一串语言，至少也能明白大概意思。汇编语言虽然解决了机器语言读写复杂的问题，但本质上还是**面向机器**的，因为写汇编语言需要我们精确了解计算机底层的知识。例如，CPU指令、寄存器、段地址等底层的细节。这对于程序员来说同样很复杂，因为程序员需要将现实世界中的问题和需求按照机器的逻辑进行翻译。例如，对于程序员来说，在现实世界中面对的问题是4 + 6 = ？。而要用汇编语言实现一个简单的加法运算，代码如下：    .section .data  a: .int 10  b: .int 20  format: .asciz "%d\n".section .text.global _start_start:  movl a, %edx    addl b, %edx    pushl %edx  pushl $format  call printf  movl $0, (%esp)  call exit这还只是实现一个简单的加法运算所需要的汇编程序，可以想象一下，实现一个四则运算的程序会更加复杂，更不用说用汇编写一个操作系统了！除了编写本身复杂，还有另外一个复杂的地方在于：不同 CPU的汇编指令和结构是不同的。例如，Intel 的 CPU 和 Motorola 的 CPU指令不同，同样一个程序，为 Intel 的 CPU 写一次，还要为 Motorola 的 CPU再写一次，而且指令完全不同。
## 高级语言（20 世纪 50 年代） {#03.html#-20-50-}为了解决汇编语言的问题，计算机前辈们从 20 世纪 50年代开始又设计了多个**高级语言**，最初的高级语言有下面几个，并且这些语言至今还在特定的领域继续使用。``{=html}-   Fortran：1955 年，名称取自"FORmula    TRANslator"，即公式翻译器，由约翰·巴科斯（John Backus）等人发明。-   LISP：1958 年，名称取自"LISt    Processor"，即枚举处理器，由约翰·麦卡锡（John McCarthy）等人发明。-   Cobol：1959 年，名称取自"Common Business Oriented    Language"，即通用商业导向语言，由葛丽丝·霍普（Grace Hopper）发明。为什么称这些语言为"高级语言"呢？原因在于这些语言让程序员不需要关注机器底层的低级结构和逻辑，而只要关注具体的问题和业务即可。还是以 4 + 6=？这个加法为例，如果用 LISP语言实现，只需要简单一行代码即可：    (+ 4 6)除此以外，通过编译程序的处理，高级语言可以被编译为适合不同 CPU指令的机器语言。程序员只要写一次程序，就可以在多个不同的机器上编译运行，无须根据不同的机器指令重写整个程序。
## 第一次软件危机与结构化程序设计（20 世纪 60 年代\~20 世纪 70 年代） {#03.html#-20-60-20-70-}高级语言的出现，解放了程序员，但好景不长，随着软件的规模和复杂度的大大增加，20世纪 60年代中期开始爆发了第一次软件危机，典型表现有软件质量低下、项目无法如期完成、项目严重超支等，因为软件而导致的重大事故时有发生。例如，1963年美国（）的水手一号火箭发射失败事故，就是因为一行FORTRAN 代码错误导致的。软件危机最典型的例子莫过于 IBM 的 System/360的操作系统开发。佛瑞德·布鲁克斯（Frederick P. Brooks,Jr.）作为项目主管，率领 2000 多个程序员夜以继日地工作，共计花费了 5000人一年的工作量，写出将近 100 万行的源码，总共投入 5亿美元，是美国的"曼哈顿"原子弹计划投入的1/4。尽管投入如此巨大，但项目进度却一再延迟，软件质量也得不到保障。布鲁克斯后来基于这个项目经验而总结的《人月神话》一书，成了畅销的软件工程书籍。为了解决问题，在 1968、1969 年连续召开两次著名的 NATO会议，会议正式创造了"软件危机"一词，并提出了针对性的解决方法"软件工程"。虽然"软件工程"提出之后也曾被视为软件领域的银弹，但后来事实证明，软件工程同样无法根除软件危机，只能在一定程度上缓解软件危机。差不多同一时间，"结构化程序设计"作为另外一种解决软件危机的方案被提了出来。艾兹赫尔·戴克斯特拉（EdsgerDijkstra）于 1968 年发表了著名的《GOTO有害论》论文，引起了长达数年的论战，并由此产生了**结构化程序设计方法**。同时，第一个结构化的程序语言Pascal 也在此时诞生，并迅速流行起来。结构化程序设计的主要特点是抛弃 goto语句，采取"自顶向下、逐步细化、模块化"的指导思想。结构化程序设计本质上还是一种面向过程的设计思想，但通过"自顶向下、逐步细化、模块化"的方法，将软件的复杂度控制在一定范围内，从而从整体上降低了软件开发的复杂度。结构化程序方法成为了20 世纪 70 年代软件开发的潮流。