种交叉编译器，它生成的是和运行环境中的CPU不同的CPU所使用的
本地代码。例如，在Pentium系列CPU的Windows这一运行环境下，
也可以作成SH及MIPS等CPU用的WindowsCE”程序，而这就是通
过使用交叉编译器来实现的。
读到这里大家可能稍微有一些混乱，不妨让我们来梳理一下。大
家在计算机软件商店等处购买编译器时，可能会跟店员说明3点：“想
要买的是何种编程语言用的编译器”“编译器生成的本地代码是用于哪
上，通常只要说明产品名及版本就可以了。
①SH（SuperH）是日立制作所和三菱电积典同成立的瑞萨技术开发的CPU。
该CPU有多种类型，在手机、率载GPS、PDA、游戏机等设备上均有使用。
②Windows CE是采用了MIPS、SH等CPU的PDA及嵌入式开发领城广泛
使用的操作系统。
③现在编译需基本上不需要购买，都已经致认集成到开发IDE中了。
译者注
---
## Page 155
84仅靠省译是无法得到可执行文件的
请帮我拿一个C语言用的、用来输出
环境下的编译器
xB6系CPU本地代码的、Windo
好的，给您
围8-6确定编译器种类的三个关键词
8.4仅靠编译是无法得到可执行文件的
编译器转换源代码后，就会生成本地文件。不过，本地文件是无
法直接运行的。为了得到可以运行的EXE文件，编译之后还需要进行
“链接”处理。下面，就让我们使用BorlandC++Compiler5.5（以下称
为BorlandC++）来看一下编译和链接是如何进行的。
Borland C++的编译器是bcc32.exe这个命令行工具。在Windows
的命令提示符中，运行下列命令后，由C语言编写的源文件Smaplel.c
就会被编译。
bcc32 -W -c Sample1.c
"-W-e”是用来指定编译Windows用的程序的选项。选项是对编译
器的指示。有时也称为“开关”。
①命令行工具指的是在Windows的命令提示符下使用的CUI程序。
②编译Samplel.c后，可能会出现WinMain的参数没有被用到的警告提示，不
过这不会造成什么影响。由于登告并不是出错，因而也可以生成目标文件。
更多资料请关注裁的新浪薄客http：//blo
---
## Page 156
第8章从源文件到可执行文件
编译后生成的不是EXE文件，面是扩展名为“obj”的目标文件
Samplel.c编译后，就生成了Samplel.obj目标文件。虽然目标文件的
内容是本地代码，但却无法直接运行。那么这是为什么呢？原因就是
当前程序还处于未完成状态。
让我们再来看一遍代码清单8-1中的源代码。（1）围起来的函数
AveragcO同（2）围起来的函数WinMainO是程序员自己作成的，处理
内容记述在源代码中。AverageO是用来返回两个参数数值的平均值的
函数，Winmain0是程序的运行起始函数。除此之外，还有（3）指出的
sprintfO函数和（4）指出的MessageBoxO函数。sprintfO是通过指定格
式把数值变换成字符串的函数，MessageBoxO是消息框函数，不过源
代码中都没有记述这些函数的处理内容。因此，这时就必须将存储着
sprintfO和MessageBoxO的处理内容的目标文件同Samplel.obj结合，
否则处理就不完整，EXE文件也就无法完成。
把多个目标文件结合，生成1个EXE文件的处理就是链接，运行
连接的程序就称为链接器（linkageeditor或连结器）。BorlandC++的链
接器就是ilink32.exe的命令行工具。在Windows命令提示符下运行以
下命令后，程序所需的目标文件就会被全部链接生成Samplel.exe这个
EXE文件。
ilink32 -Tpe -c -x -aa c0w32.obj Sample1.obj. Sample1l.exe,,
import32.1ib cw32.1ib
①目标文件（object file）中的object一词，指的是编译器生成结果的意思。
和面向对象编程（object oriented programming）的object没有任何关系。面
向对象端程的对象指的是数据和处理的集合体。
42
---
## Page 157
8.5房动及库文件
8.5
启动及库文件
链接选项“-Tpe-C-x-aa”是指定生成Windows用的EXE文件的选
项。在这些选项之后，会指定结合的目标文件。面该命令行中就指定
了c0w32.obj、Samplel.obj这两个目标文件，这点相信大家都能看得出
来。Samplel.obj是Samplel.c编译后得到的目标文件。c0w32.obj这个
目标文件记述的是同所有程序起始位置相结合的处理内容，称为程序
的启动。因面，即使程序不调用其他目标文件的函数，也必须要进行
链接，并和启动结合起来。c0w32.obj是由BorlandC++提供的。如果
C：盘中安装有BorandC++的话，文件夹C:Borlandbcc55lib中就会
有c0w32.obj这个文件。
那么，大家可能会有这样一个疑问：“链接时不指定sprintfO和
MessageBoxO的目标文件也没问题么？”这个担心是多余的。在链接的
命令行末尾，存在着扩展名是“.lib”的import32.lib和cw32.lib这两个
文件。这是因为 sprintf)的目标文件在cw32.lib中，MessageBoxO的目
标文件在import32.lib中（实际上，MessageBox0的目标文件在user32.
dII这个DLL文件中。关于这一点，我们会在后面进行说明）。
像import32.lib及cw32.lib这样的文件称为库文件。库文件指的是
把多个目标文件集成保存到一个文件中的形式。链接器指定库文件后，
就会从中把需要的目标文件抽取出来，并同其他目标文件结合生成
EXE文件。
Samplel.obj是尚未完成的本地代码，这个在前面已经进行了说
明。这是因为，Samplel.obj文件中包含有“链接时请结合sprintfO及
MessageBoxO”这样的信息。意思是如果不存在其他函数的话，程序就
无法运行。下面，我们就来做一个尝试，看看在不指定这两个库文件
---
## Page 158
第8章从源文件到可执行文件
的情况下进行链接会发生什么。
i1ink32 -Tpe -c -x -aa c0v32.obj Sample1.obj. Sample1.exe
在命令提示符上运行上述命令后，链接器就会出现如图8-7所示的
错误消息（实际上显示的错误消息更多、这里对其进行了省略）。
Eror:无法解析外部符号_Sintf（请参考C:TESTBPISAMPLE1.OBJ）
Error：无法解析外部符号“MessageBoxA'（请参考C:TESTBPASAMPLE1.OBJ）
图8-7链接器的镭误信息
该错误消息表示的是无法解析Samplel.obj参照的外部符号。外部
符号是指其他目标文件中的变量或函数。sprintf及MessageBoxA是目
标文件中sprintfO及MessageBoxO的名称。代码中记述的函数名同目
标文件中的函数名有一些差异，不过大家只需把它理解成这是C编译
述着目的变量及函数的目标文件，因而无法进行链接的意思。
sprintfO等函数，不是通过源代码形式而是通过库文件形式和编译
器一起提供的。这样的函数称为标准函数。之所以使用库文件，是为
了简化为链接器的参数指定多个目标文件这一过程。例如，在链接调
用了数百个标准函数的程序时，就要在链接器的命令行中指定数百个
目标文件，这样就太繁琐了。而利用存储着多个目标文件的库文件的
话，则只需在链接器的命令行中指定几个库文件就可以了。
通过以目标文件的形式或集合多个目标文件的库文件形式来提供
函数，就可以不用公开标准函数的源代码内容。由于标准函数的源代
码是编译器厂商的贵重财产，因此若被其他公司任意转用的话，可能
---
## Page 159
8.6DLL文件及导入库
会造成一些损失。
8.6DLL文件及导入库
Windows以函数的形式为应用提供了各种功能。这些形式的函数
称为API（Application Programming Interface，应用程序接口）。例如，
Samplel.c中调用的MessageBoxO，它并不是C语言的标准函数，面是
Windows提供的API的一种。MessageBoxO提供了显示消息框的功能。
Windows中，API的目标文件，并不是存储在通常的库文件中，面
是存储在名为DLL（DynamicLinkLibrary）文件的特殊库文件中。就如
Dynamic这一名称所表示的那样，DLL文件是程序运行时动态结合的
文件。在前面的介绍中，我们提到MessageBoxO的目标文件是存储在
import32.lib中的。实际上，import32lib中仅仅存储着两个信息，一是
MessageBox(在user32.dll这个DLL文件中，另一个是存储着DLL文
件的文件夹信息，MessageBoxO的目标文件的实体实际上并不存在。
我们把类似于import32.lib这样的库文件称为导入库。
与此相反，存储着目标文件的实体，并直接和EXE文件结合的库
文件形式称为静态链接库。静态（static=静态的）同动态（dynamic=
动态的）是相反的意思。存储着sprintfO的目标文件的cw32lib就是静
态链接库。sprintfO提供了通过指定格式把数值转换成字符串的功能。
通过结合导人库文件，执行时从DLL文件中调出的MessageBoxO
函数这一信息就会和EXE文件进行结合。这样，链接器链接时就不会
再出现错误消息，从而就可以顺利编写EXE文件。
至此，我们总结一下Windows中的编译及链接机制，如图8-8
所示。
---
## Page 160
第8章从源文件到可执行文件
由程序员编写
源文件
Sample1.c
编译
Sample1.obj
目标文件
存储在C:Borlandbcc55vib
+
这个文件夹中
启动用的
静态链接库
cw32.lb
抽出
+
sprintf(0的
目标文件
导入库
import32.lib
抽出
+
MessageBoxi的信息
用来调用
动态链接库
user32.dll
静态链接
拍出
动态链接
MessageBox(]
可执行文件
的目标文件
Sample1.exe
图8-8Windows中的编译和链接机制
8.7
可执行文件运行时的必要条件
在了解了通过程序的编译及链接来生成EXE文件的机制后，接下
来看一下EXE文件的运行机制。EXE文件是作为单独的文件储存在硬
盘中的。通过资源管理器找到并双击EXE文件，就会把EXE文件的内
容加载到内存中运行。
---
## Page 161
8.7可执行文件运行时的必要条件
请大家思考一下下面的问题。本地代码在对程序中记述的变量进
行读写时，是参照数据存储的内存地址来运行命令的。在调用函数时，
程序的处理流程就会跳转到存储着函数处理内容的内存地址上。EXE
文件作为本地代码的程序，并没有指定变量及函数的实际内存地址。
在类似于Windows操作系统这样的可以加载多个可执行程序的运行环
境中，每次运行时，程序内的变量及函数被分配到的内存地址都是不
同的。那么，在EXE文件中，变量和函数的内存地址的值，是如何来
表示的呢？
下面就让我们来揭晓答案。那就是EXE文件中给变量及函数分配
了虚拟的内存地址。在程序运行时，虚拟的内存地址会转换成实际的
内存地址。链接器会在EXE文件的开头，追加转换内存地址所需的必
要信息。这个信息称为再配置信息。
EXE文件的再配置信息，就成为了变量和函数的相对地址。相对
地址表示的是相对于基点地址的偏移量，也就是相对距离。实现相对
地址，也是需要花费一番心思的。在源代码中，虽然变量及函数是在
不同位置分散记述的，但在链接后的EXE文件中，变量及函数就会变
成一个连续排列的组。这样一来，各变量的内存地址就可以用相对于
变量组起始位置这一基点的偏移量来表示，同样，各函数的内存地址
也可以用相对于函数组起始位置这一基点的偏移量来表示。而各组基
点的内存地址则是在程序运行时被分配的（图8-9）。
---
## Page 162
8章从源文件到可执行文件
再配置信息
变量1
变量组的基点
变量（数据）组
变量2
偏移量
支量3
函数1
函数组的基点
函数（处理）组
数2
偏移量
函数3
图8-9链接后的EXE文件的构遗
8.8程序加载时会生成栈和堆
EXE文件的内容分为再配置信息、变量组和函数组，这一点想必
大家都清楚了吧。不过，当程序加载到内存后，除此之外还会额外生
成两个组，那就是栈和堆。栈是用来存储函数内部临时使用的变量（局
部变量”）.以及函数调用时所用的参数的内存区域。堆是用来存储程
序运行时的任意数据及对象的内存领域（图8-10）。
EXE文件中并不存在栈及堆的组。栈和堆需要的内存空间是在
EXE文件加载到内存后开始运行时得到分配的。因而，内存中的程序，
就是由用于变量的内存空间、用于函数的内存空间、用于栈的内存空
间、用于堆的内存空间这4部分构成的。当然，在内存中，加载
Windows等操作系统的内存空间又是另外一回事了（图8-10）。
①局部变量是指只在调用函数时存在于内存申的变量。例如，在代码清单8-1
中，WinMain品数的处理中的ave和buff都是局部变量。全局变量是指程
序运行时一直存在于内存中的变量。代码清单8-1中的title就是全局变量。
---
## Page 163
8.8程序加就时会生成税和增
内存
用于操作系统的空间
用于变量的空间
复制EXE文件