因此，我们需要细粒度代码覆盖率报告来展示这种情况。在DMA缓冲区和事件队列上进行变换实质上是构建具有Fuzzing
功能的HCD仿真器。对于常见的HCD驱动程序，例如Intel
XHCI，QEMU已经提供了相应的HCD仿真，并且可以尝试在那里添加模糊测试功能。对于QEMU不提供HCD仿真的其他HCD驱动程序，需要从头开始构建HCD仿真。
###  USB设备模糊测试
我们没有对USB设备进行系统的模糊测试。嵌入式系统（例如Android设备）中USB
OTG和DRD控制器的广泛采用将威胁模型扩展到了USB主机。例如，在USB充电期间，没有人希望他们的手机被黑客入侵。在架构上，Syzkaller USB
fuzzer设想了一种模糊USB设备堆栈的方法，如下所示。
用户空间模糊器不会让用户空间模糊器与USB内核驱动程序通信，而是操作USB主机设备驱动程序。有希望，模糊器活动将通过USB主机堆栈传播到USB设备/小工具堆栈。因此，我们需要配置内核以在同一内核映像中启用所有不同的设备功能，以及代码覆盖率报告。
Syzkaller设想了一种模糊USB设备堆栈的方法。Syzkaller是一个系统调用模糊器，意味着输入突变发生在系统调用参数中，但这并不意味着我们必须在系统调用层（例如用户空间）进行模糊测试。再次查看上图，我们可以找到从模糊器到模糊测试目标的路径（例如USB主机设备驱动程序或USB设备驱动程序）。怎么知道所有模糊输入是否成功传播到目标而不是被中间层过滤？一个核心问题是基于系统调用的模糊测试是否适合内核中的USB模糊测试。同样，Syzkaller
USB模糊器可以适应Syzkaller本身的限制，而不是考虑从头开始构建USB模糊器。
缩短模糊测试路径是将模糊器输入到目标代码附近。例如，我们可以通过在QEMU中构建USB
UDC仿真器/模糊器来摆脱整个USB主机堆栈，直接启用UDC驱动程序模糊测试。但是，这并不意味着任何DMA写入都可以转换为对上层USB设备驱动程序的有效USB请求。因此，模糊测试路径确实更短，但我们仍然希望更好的变异算法和更细的代码覆盖粒度。最后，我们可能需要在堆栈中的不同层上使用不同的模糊器，确保所有模糊输入都应用于目标而不进行过滤。例如，我们可能需要构建一个USB主机模糊器，直接向不同的USB设备驱动程序发送USB请求。
###  Android USB模糊测试
Android可能是最重的USB设备堆栈用户，通过维护自己的内核分支并实现额外的USB设备功能驱动程序（例如MTP）。与典型的USB主机相比，Android设备中的OTG
/ DRD支持也使攻击面增加了一倍，最根本的挑战是运行Android内核映像，其中包含使用QEMU的真实Android设备使用的相应UDC /
DRD驱动程序。由于SoC自定义和变化，在QEMU中运行非AOSP内核会带来额外的困难。这就是为什么许多Android模糊测试仍需要物理设备。
###  协议引导/状态模糊测试
要模糊USB主机或设备驱动程序，我们需要与目标建立虚拟连接，例如确保内核驱动程序已初始化并准备好处理输入，有状态并引导模糊器学习结构输入。最后，在包含其他层以重用现有协议和状态控制之间进行权衡，从而增加模糊路径和复杂性，并在模糊器中直接实现轻量级协议感知/状态模糊测试，以减少模糊测试路径。
####  Type-C / USBIP / WUSB模糊测试
除了USB主机和USB设备之外，USB中还有更多东西，包括USB
Type-C，USBIP，WUSB等。虽然我们可以重用USB模糊测试中的一些技术，但这些技术引入了不同的软件堆栈。
## 4.总结
这篇文章探讨了USB模糊测试，这是软件安全和操作系统安全性最近的热门话题。我们首先要了解USB堆栈是什么，以及为什么USB比人们通常想象的更大，而不是将USB视为另一个软件。我们调查了一些以前关于USB模糊测试的工作，从使用专用硬件到运行QEMU。
## 参考文献
[1]   
[2]
[3]
[4]   
[5]   
[ 6]   
[7]   
[8]   
[9]   
[10]  
[11]   
[12]
[13] [https://github. com/xairy/linux
/commit/ff543afbf78902acea566fa4c635240ede651f77](https://github.%20com/xairy/linux%20/commit/ff543afbf78902acea566fa4c635240ede651f77)  
[14]