Using the same technique as before, we reduced a GFS
speciﬁcation incorporating these assumptions to GFS SS,
which extends Niobe SS as follows. A read() in GFS SS
returns either (1) the value of SerialDB, (2) a value from
pending wrreq or pending wrresp, or (3) a dropped write.
seman-
tics [12], which are weaker than linearizability, but stronger
than safe semantics. The proof is again very simple [8].
Thus, using formal methods, we were able to identify two
assumptions that upgrade GFS’ consistency guarantees to
well-understood regular register semantics. This ﬁnding
casts light on GFS’ consistency model, which we found
hard to grasp from the original paper.
standard regular
GFS SS offers
register
5. Inspecting Alternative Designs
In the previous sections, we showed that formal meth-
ods can aid in understanding and comparing mechanisms
and consistency properties of fault-tolerant ﬁle systems.
Our experience indicates that formal methods can be a valu-
able tool during the design phase of a system, as well. They
can be used by a designer to evaluate alternative designs
comfortably. To inspect the effects of an alternative design
on consistency, a system builder only modiﬁes the spec-
iﬁcation and re-checks the reﬁnement mapping, to verify
whether the system still implements its SimpleStore.
Using our framework (consisting of TLA+ speciﬁca-
tions, SimpleStores, and reﬁnement mappings), we experi-
mented with a simple design alternative for Niobe. As we
have seen, one distinction between Niobe and GFS designs
is that the former directs all reads and writes to the same
primary, while the latter allows all replicas to answer a read
request. GFS’ read-any decision has an important impact
on performance, since it increases GFS read throughput by
distributing bandwidth across distinct replicas.
As a speciﬁc question of alternative design, what
would happen to Niobe’s consistency semantics if it were
to employ the same read-any policy as GFS? Without extra
mechanism, Niobe would no longer be linearizable, since it
admits behaviors like the one shown for GFS in Figure 5.
However, we were able to model-check a mapping from
Niobe with read-any to GFS SS, which shows that it must
offer regular register semantics.
An interesting follow-up question is whether read-any
Niobe can give up or simplify some of its mechanisms
(e.g., reconciliation at primary take-over) without losing the
regular-register status. This question is a good example of
a new question space whose exploration is enabled by our
framework and an interesting point of future work.
6. Related Work
Formal modeling and methods have long been used to
reason about software [3, 4] and hardware [11, 17]. We
leverage these techniques and apply them to several fault-
tolerant ﬁle systems. While formal methods have been
widely used in hardware designs [11], builders of fault-
tolerant ﬁle systems have still not adopted modeling and
veriﬁcation as a general practice. By sharing our experi-
ence, we hope to convince those builders of the utility and
practicality of formally specifying their systems.
Our work is by no means the ﬁrst with this goal. Many
previous works report on the beneﬁts of applying formal
methods to various classes of systems, e.g.: caches [11],
space shuttle software [6], on-line transaction processing
systems [10], local and distributed ﬁle systems [18, 20, 21],
and many others (a wealth of examples are presented in a
survey [5]). Our work shows how and why to apply several
formal methods to another important application domain:
enterprise fault-tolerant, replicated ﬁle systems. From this
body of previous works, the closest to ours are those pre-
senting formal modeling case studies for local or distributed
ﬁle systems (e.g., Coda, AFS) [18, 20, 21]. Fault-tolerant
ﬁle systems differ from these systems in that they include
new types of complex mechanisms, e.g., automatic recon-
ﬁguration and recovery. We believe that our study geared
toward fault-tolerant ﬁle systems is likely to have impact in
this speciﬁc domain in ways that previous studies may not.
Some works [2, 18] introduce new formal frameworks
especially designed for modeling ﬁle systems. Because
these specialized frameworks do not support model check-
ing, proofs require manual effort.
In contrast, we apply
generic formalisms, which enable automatic veriﬁcations.
The technique of reducing complex systems to sim-
ple models to reason about consistency has been used be-
fore [11, 19]. In particular, the storage service model in-
troduced in [19] is a valid abstraction, however the model’s
use of histories made it inappropriate for model-checking.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:17:16 UTC from IEEE Xplore.  Restrictions apply. 
11. w(1)3. Ack w(1)R1C1C2R20R32. w(1)  2. w(1)4. r5. r(1)6. r7. r(0)8. Ack w(1)9. w(1)1International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 20081-4244-2398-9/08/$20.00 ©2008 IEEE100DSN 2008: Geambasu et al.7. Conclusions and Lessons Learned
We have presented our experience with applying for-
mal methods to analyze and compare three real-world fault-
tolerant ﬁle systems. We now share four of the lessons we
learned from our experiment.
First, moderately detailed TLA+ speciﬁcations of real
systems are not as hard to produce as we had thought be-
forehand. For example, one student wrote a ﬁrst workable
speciﬁcation for GFS in about two weeks. Clearly, the more
in-depth the speciﬁcation is, the more time it takes to write.
But overall, we believe that writing a high-level speciﬁca-
tion by a system designer is a fairly easy task, yet a remark-
ably useful one for understanding the system.
Second, we found that the exercise of writing TLA+
speciﬁcations exposed similarities in seemingly dissimilar
systems. This was the case for GFS and Niobe, where we
factored out all common mechanisms into one abstraction.
We believe that our common TLA+ speciﬁcation can ease
the building of speciﬁcations for other primary-secondary-
master systems (e.g., Boxwood [15]).
Third, formal speciﬁcations enable insightful semantic
comparison, even between strongly and weakly consistent
systems. By building client-centric models of the systems
and comparing them, we were able to understand better how
the systems behave and to reach several conclusions, e.g.:
1. Niobe and Chain perform similarly from a client per-
spective, implementing similar client-centric models.
2. GFS can be upgraded to regular register semantics via
a clear set of assumptions.
3. GFS’ design decision to read from any replica for per-
formance heavily inﬂuences its consistency model. In
particular, if Niobe were to adopt this design decision
for performance, its consistency model would degrade
from linearizability to regular-register.
Finally, we found that intuition can often be unreli-
able, and thus backing it up with formal veriﬁcation is use-
ful. For example, after verifying that Chain implemented
Chain SimpleStore, we truly believed that the same model
was right for Niobe, as well, without realizing that it missed
one type of Niobe transition. It then took several iterations
of the model to arrive at the right model (Niobe SS).
Thus, our practical experience has shown that for-
mal speciﬁcations and methods are useful tools for design-
ing, analyzing and comparing fault-tolerant ﬁle systems.
Through the use of such tools, systems designers can in-
crease the trust in the behavior of these important infras-
tructure components in the presence of failures.
8. Acknowledgments
We thank Hank Levy and Chandu Thekkath for their
valuable comments on the paper, and Idit Keidar, Dahlia
Malkhi, and Yuan Yu for their ideas during our work. We
also thank the anonymous reviewers for their valuable com-
ments. This work was mostly done during an internship at
Microsoft Research. Roxana Geambasu is supported in part
by National Science Foundation Grant NSF-614975.
References
[1] M. Abadi and L. Lamport. The existence of reﬁnement map-
pings. Theoretical Computer Science, 1991.
[2] K. Bhargavan, M. Shapiro, and F. le Fessant. Modelling repli-
cation protocols with actions and constraints, 2003.
[3] M. Bickford and D. Guaspari. Formalizing the chain replica-
tion protocol. http://www.cs.cornell.edu/Info/Projects/
NuPrl/FDLcontentAUXdocs/ChainRepl, 2006.
[4] D. Chkliaev, P. van der Stok, and J. Hooman. Formal mod-
eling and analysis of atomic commitment protocols. In Proc.
of the Conference on Parallel and Distributed Systems, 2000.
[5] E. Clarke and J. Wing. Formal methods: state of the art and
future directions. ACM Computing Surveys, 28(4), 1996.
[6] J. Crow and B. D. Vito. Formalizing space shuttle software
requirements: four case studies. ACM Transactions on Soft-
ware Engineering and Methodology, 7(3), 1998.
[7] G. DeCandia, D. Hastorun, M. Jampani, G. Kakulapati,
A. Lakshman, A. Pilchin, S. Sivasubramanian, and W. V.
P. Vosshall. Dynamo: Amazon’s highly available key-value
store. In Proc. of ACM SOSP, 2007.
[8] R. Geambasu, A. Birrell, and J. MacCormick.
TLA+
Speciﬁcations and Proofs for Niobe, GFS, and Chain.
http://cs.washington.edu/homes/roxana/fm/, 2007.
[9] S. Ghemawat, H. Gobioff, and S. Leung. The Google File
System. In Proc. of ACM SOSP, 2003.
[10] I. Houston and S. King. CICS project report: Experiences
and results from using Z. In Proc. of Formal Development
Methods, 1991.
[11] R. Joshi, L. Lamport, J. Matthews, S. Tasiran, M. Tuttle, and
Y. Yu. Checking cache-coherence with TLA+. Formal Meth-
ods in System Design, 2003.
[12] L. Lamport. On interprocess communication. Distributed
Computing, 1986.
[13] L. Lamport. Specifying Systems. Addison Wesley, 2003.
[14] L. Lamport, Y. Yu, and L. Zhang.
TLA+ tools.
re-
search.microsoft.com/research/sv/TLA Tools, 2007.
[15] J. MacCormick, N. Murphy, M. Najork, C. Thekkath, and
L. Zhou. Boxwood: Abstractions as the foundation for stor-
age infrastructure. In Proc. of OSDI, 2004.
[16] J. MacCormick, C. Thekkath, M. Jager, K. Roomp, L. Zhou,
and R. Peterson. Niobe: A practical replication protocol.
ACM Trans. Storage, 2008.
[17] K. Shimizu and D. Dill. Using formal speciﬁcations for func-
tional validation of hardware designs. IEEE Des. Test, 2002.
[18] M. Sivathanu, A. Arpaci-Dusseau, R. Arpaci-Dusseau, and
In Proc. of the USENIX
S. Jha. A logic of ﬁle systems.
Conference on File and Storage Technologies, 2005.
[19] R. van Renesse and F. Schneider. Chain replication for high
throughput and availability. In Proc. of OSDI, 2004.
[20] J. Wing and M. Vaziri. A case study in model checking soft-
ware systems. Science of Computer Programming, 1997.
[21] J. Yang, P. Twohey, D. Engler, and M. Musuvathi. Using
model checking to ﬁnd serious ﬁle system errors. In Proc. of
OSDI, 2004.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 13:17:16 UTC from IEEE Xplore.  Restrictions apply. 
International Conference on Dependable Systems & Networks: Anchorage, Alaska, June 24-27 20081-4244-2398-9/08/$20.00 ©2008 IEEE101DSN 2008: Geambasu et al.