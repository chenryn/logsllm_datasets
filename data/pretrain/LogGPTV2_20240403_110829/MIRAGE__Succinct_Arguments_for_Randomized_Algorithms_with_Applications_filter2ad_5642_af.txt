This work
610 sec
1.8 GB
473 KB
Auction
Crowdfund
Auction
Crowdfund
22.78 sec
22.71 sec
57.85 MB
57.8 MB
3.93 KB
3.93 KB
N/A
N/A
7.9 sec
7.9 sec
32 B
32 B
10.3 sec
10.3 sec
322 sec
319 sec
128 B
128 B
160 B
160 B
1.5 ms
1.5 ms
2.1 ms
2.1 ms
• There is about 30× ampliﬁcation factor in the proof genera-
tion time. The reason this factor is larger than the previously
reported overhead in Table 4 is because nearly half of the in-
structions in the universal circuit were not used (mainly the
opcode types that were not used heavily by the commitments
or the applications being evaluated).
• Comparison with existing work: The proof size of Sonic [31]
is 1152 bytes in the unhelped mode (compared to 160 bytes
in our case), and the veriﬁer’s effort is 3× worse than ours.
For the prover, the ampliﬁcation factor of the number of
exponentiations in Sonic [31] is more than 50× in the un-
helped prover’s case, compared to 30× in our case, when
the circuit is highly utilized.
In the future, we will also evaluate other applications that
require trusted setup per user-deﬁned computations.
7 Conclusion and Discussion
In this paper, we presented MIRAGE a zk-SNARK protocol
that allows the veriﬁcation of randomized algorithms efﬁ-
ciently. Compared to baseline zk-SNARKs, our protocol in-
creases the veriﬁcation overhead by one pairing, and increases
the proof size by one group element in the generic group
model. We used our protocol to build an efﬁcient universal
circuit, and illustrated savings in different contexts, including
privacy-preserving smart contracts. However, our work leaves
several open problems for future work, which we discuss next.
7.1 Scalability
Although we signiﬁcantly reduced the cost of universal cir-
cuits in this paper and illustrated the impact on different ap-
plications, there is still a cost that has to be paid for being
universal. In this subsection, we discuss some directions that
could be considered to alleviate the scalability challenges.
Distributed systems for ZK proof computation. As large
zk-SNARK circuits lead to high memory consumption at
the prover’s side, one way to avoid such practical limitation
is to use a distributed system to compute the zk-SNARK
3Refers to the additional part of veriﬁcation key added per computation.
Note that this can be veriﬁed by any party.
proof using multiple instances. A recent system, DIZK [12],
was shown to enable computations of zk-SNARK proofs for
circuits that have hundreds of millions of constraints, which
would ﬁt for very large instantiations of our universal circuit.
This could scale the number of participants in the application
we evaluated by two orders of magnitude.
Recursive SNARKs. Another approach to increase the scala-
bility and efﬁciency of the prover, while also enabling light-
weight clients, would be to divide the circuit into different
parts, e.g., based on opcodes, prove the correctness of each
separately, and then use one layer of recursive SNARKs [6,47]
to compress the proofs into one and verify the global con-
sistency. This will have the beneﬁt of reducing the memory
requirements of the prover, and also letting the prover only
pay for the opcodes that are heavily used by the computation.
Cryptographic opcodes. As most zk-SNARK circuits in-
clude cryptographic gadgets for verifying knowledge of se-
crets, or for computing commitments, etc., it could be useful to
include opcodes for well-known cryptographic functions. For
instance, in the context of HAWK privacy-preserving smart
contract system [16], most of the manager’s circuit does not
depend on the computation being veriﬁed. If the universal
circuit supports additional commitment opcodes, this would
signiﬁcantly reduce the cost of the cryptographic operations
required by the protocol, and the universality cost will only
include the cost of representing the custom user-deﬁned logic.
This would allow increasing the number of participants.
7.2 High-level tool for specifying computation
The library we developed to specify computations is currently
a low-level library, which means that the programmer is ex-
pected to have knowledge of the opcodes when representing
the computation in order to get an optimized performance
and develop a secure representation. This is in some sense
similar to the background requirements needed when devel-
oping zk-SNARK circuits using low-level gadget libraries,
e.g, [46]. We plan to develop a high-level tool that can com-
pile high-level description of the computation to an optimized
speciﬁcation, given the opcodes. Some techniques from exist-
ing high-level frameworks [5, 10, 11] could be used, however
the cost model in our setting is different. Additionally, our
USENIX Association
29th USENIX Security Symposium    2141
modiﬁed zk-SNARK construction enables the usage of ran-
domness in the circuit to check permutations and potentially
many other types of computations more efﬁciently.
7.3 Workload characterization
In Section 5.2, we used a nearly uniform way to set the number
of each opcode provided in the circuit. Although the opcodes
we provide can represent most basic operations, their distri-
bution might not always be the most optimal for all possible
kinds of applications. A future direction would be to obtain a
realistic distribution based on workload characterization of
computations in different domains. If the universal circuit
targets an application-speciﬁc domain like smart contracts,
then studying existing smart contracts and analyzing the dis-
tributions of the basic operations could provide better insight.
Acknowledgments
This work was supported in part by DARPA under grant
N66001-15-C-4066 and the Center for Long-Term Cyber-
security (CLTC). Charalampos Papamanthou was supported
by NSF awards #1514261 and #1652259 as well as by NIST.
Dimitrios Papadopoulos was supported by Hong Kong RGC
under grant ECS-26208318. Any opinions, ﬁndings, and con-
clusions or recommendations expressed in this material are
those of the authors and do not necessarily reﬂect the views
of NSF, NIST, DARPA, CLTC or Hong Kong RGC.
References
[1] R. Gennaro, C. Gentry, B. Parno, and M. Raykova, “Quadratic span
programs and succinct nizks without pcps,” in Advances in Cryptology–
EUROCRYPT 2013. Springer, 2013, pp. 626–645.
[2] B. Parno, J. Howell, C. Gentry, and M. Raykova, “Pinocchio: Nearly
practical veriﬁable computation,” in S & P, 2013.
[3] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza, “Snarks
for C: verifying program executions succinctly and in zero knowledge,”
in CRYPTO, 2013.
[4] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Succinct non-
interactive zero knowledge for a von neumann architecture,” in USENIX
Security, 2014.
[5] C. Costello, C. Fournet, J. Howell, M. Kohlweiss, B. Kreuter,
M. Naehrig, B. Parno, and S. Zahur, “Geppetto: Versatile veriﬁable
computation,” in S&P, 2014.
[6] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Scalable zero
knowledge via cycles of elliptic curves,” in CRYPTO, 2014.
[7] J. Groth, “On the size of pairing-based non-interactive arguments,” in
EUROCRYPT 2016, 2016, pp. 305–326.
[8] J. Groth and M. Maller, “Snarky signatures: Minimal signatures of
knowledge from simulation-extractable snarks,” in Annual Interna-
tional Cryptology Conference. Springer, 2017, pp. 581–612.
[9] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and M. Wal-
ﬁsh, “Verifying computations with state,” in Proceedings of the Twenty-
Fourth ACM Symposium on Operating Systems Principles. ACM,
2013, pp. 341–357.
[11] A. Kosba, C. Papamanthou, and E. Shi, “xJsnark: a framework for
efﬁcient veriﬁable computation,” in 2018 IEEE Symposium on Security
and Privacy.
IEEE, 2018, pp. 944–961.
[12] H. Wu, W. Zheng, A. Chiesa, R. A. Popa, and I. Stoica, “DIZK: A
distributed zero knowledge proof system,” in 27th USENIX Security
Symposium (USENIX Security 18), 2018, pp. 675–692.
[13] G. Danezis, C. Fournet, M. Kohlweiss, and B. Parno, “Pinocchio Coin:
building Zerocoin from a succinct pairing-based proof system,” in
PETShop, 2013.
[14] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer,
and M. Virza, “Zerocash: Decentralized anonymous payments from
bitcoin,” in S & P, 2014.
[15] A. Delignat-Lavaud, C. Fournet, M. Kohlweiss, and B. Parno, “Cin-
derella: Turning shabby x.509 certiﬁcates into elegant anonymous
credentials with the magic of veriﬁable computation,” in S& P, 2016.
[16] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou, “Hawk:
The blockchain model of cryptography and privacy-preserving smart
contracts,” in IEEE Symposium on Security and Privacy, 2016.
[17] A. Juels, A. Kosba, and E. Shi, “The ring of gyges: Using smart con-
tracts for crime,” Manuscript, 2015.
[18] A. Naveh and E. Tromer, “Photoproof: Cryptographic image authen-
tication for any set of permissible transformations,” in 2016 IEEE
Symposium on Security and Privacy (SP).
IEEE, 2016, pp. 255–271.
[19] E. Ben-Sasson, A. Chiesa, M. Green, E. Tromer, and M. Virza, “Secure
sampling of public parameters for succinct zero knowledge proofs,”
in 2015 IEEE Symposium on Security and Privacy.
IEEE, 2015, pp.
287–304.
[20] S. Bowe, A. Gabizon, and I. Miers, “Scalable multi-party computation
for zk-snark parameters in the random beacon model.” 2017.
[21] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam, “Ligero:
Lightweight sublinear arguments without a trusted setup,” in Proceed-
ings of the 2017 ACM SIGSAC Conference on Computer and Commu-
nications Security. ACM, 2017, pp. 2087–2104.
[22] B. Bünz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell,
“Bulletproofs: Short proofs for conﬁdential transactions and more,” in
2018 IEEE Symposium on Security and Privacy (SP).
IEEE, 2018,
pp. 315–334.
[23] Y. Zhang, D. Genkin, J. Katz, D. Papadopoulos, and C. Papamanthou,
“A zero-knowledge version of vsql.” IACR Cryptology ePrint Archive,
vol. 2017, p. 1146, 2017.
[24] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walﬁsh, “Doubly-
efﬁcient zksnarks without trusted setup,” in 2018 IEEE Symposium on
Security and Privacy (SP).
IEEE, 2018, pp. 926–943.
[25] E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev, “Scalable, trans-
parent, and post-quantum secure computational integrity.” IACR Cryp-
tology ePrint Archive, 2018.
[26] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and
N. P. Ward, “Aurora: Transparent succinct arguments for r1cs,” 2018,
https://eprint.iacr.org/2018/828.
[27] T. Xie, J. Zhang, Y. Zhang, C. Papamanthou, and D. Song, “Libra:
Succinct zero-knowledge proofs with optimal prover computation,”
2019, https://eprint.iacr.org/2019/317.
[28] J. Zhang, T. Xie, Y. Zhang, and D. Song, “Transparent polynomial
delegation and its applications to zero knowledge proof,” in SSP, 2020,
https://eprint.iacr.org/2019/1482.
[29] J. Groth, M. Kohlweiss, M. Maller, S. Meiklejohn, and I. Miers, “Up-
datable and universal common reference strings with applications to
zk-snarks,” in Annual International Cryptology Conference. Springer,
2018, pp. 698–728.
[10] R. S. Wahby, S. T. V. Setty, Z. Ren, A. J. Blumberg, and M. Walﬁsh,
“Efﬁcient RAM and control ﬂow in veriﬁable outsourced computation,”
in NDSS, 2015.
[30] M. Campanelli, D. Fiore, and A. Querol, “Legosnark: Modular design
and composition of succinct zero-knowledge proofs,” Cryptology ePrint
Archive, Report 2019/142, 2019, https://eprint.iacr.org/2019/142.
2142    29th USENIX Security Symposium
USENIX Association
[31] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn, “Sonic: Zero-
knowledge snarks from linear-size universal and updateable structured
reference strings.”
[32] C. Baum, J. Bootle, A. Cerulli, R. Del Pino, J. Groth, and V. Lyuba-
shevsky, “Sub-linear lattice-based zero-knowledge arguments for
arithmetic circuits,” in Annual International Cryptology Conference.
Springer, 2018, pp. 669–699.
[33] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit, “Efﬁcient zero-
knowledge arguments for arithmetic circuits in the discrete log setting,”
in Annual International Conference on the Theory and Applications of
Cryptographic Techniques. Springer, 2016, pp. 327–357.
[34] E. Ben-Sasson, A. Chiesa, and N. Spooner, “Interactive oracle proofs,”
in Theory of Cryptography Conference. Springer, 2016, pp. 31–60.
[35] S. Goldwasser, S. Micali, and C. Rackoff, “The knowledge complexity
of interactive proof systems,” SIAM Journal on computing, vol. 18,
no. 1, pp. 186–208, 1989.
[36] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum, “Delegating compu-
tation: interactive proofs for muggles,” Journal of the ACM (JACM),
vol. 62, no. 4, p. 27, 2015.
[37] G. Cormode, M. Mitzenmacher, and J. Thaler, “Practical veriﬁed com-
putation with streaming interactive proofs,” in Proceedings of the 3rd
Innovations in Theoretical Computer Science Conference. ACM,
2012, pp. 90–112.
[38] J. Thaler, “Time-optimal interactive proofs for circuit evaluation,” in
Annual Cryptology Conference. Springer, 2013, pp. 71–89.
[39] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward, “Marlin:
Preprocessing zksnarks with universal and updatable srs,” Cryptology
ePrint Archive, Report 2019/1047, 2019.
[40] A. Gabizon, Z. J. Williamson, and O. Ciobotaru, “Plonk: Permuta-
tions over lagrange-bases for oecumenical noninteractive arguments of
knowledge,” Cryptology ePrint Archive, Report 2019/953, 2019.
[41] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” 2008.
[42] G. Wood, “Ethereum: A secure decentralized transaction ledger,” http:
//gavwood.com/paper.pdf.
[43] H. W. Lenstra Jr, “Primality testing with gaussian periods,” in Pro-
ceedings of the 22nd Conference Kanpur on Foundations of Software
Technology and Theoretical Computer Science. Springer-Verlag, 2002,
p. 1.
[44] M. O. Rabin, “Probabilistic algorithm for testing primality,” Journal of
Number Theory, vol. 12, no. 1, pp. 128 – 138, 1980.
[45] G. Fuchsbauer, E. Kiltz, and J. Loss, “The algebraic group model and
its applications,” in Advances in Cryptology – CRYPTO 2018, 2018.
[46] “libsnark,” https://github.com/scipr-lab/libsnark, 2019.
[47] S. Bowe, A. Chiesa, M. Green, I. Miers, P. Mishra, and H. Wu,
“Zexe: Enabling decentralized private computation,” Cryptology ePrint
Archive, Report 2018/962, 2018, https://eprint.iacr.org/2018/962.
A A zk-SNARK for Cuniv
In this section, we describe the zk-SNARK protocol for the
simple universal circuit Cuniv that was presented in Section 4
in detail. Before describing the protocol, we introduce addi-
tional notations. Let φl,φl(cid:48), φz, φz(cid:48) and φr be mapping func-
tions that map the variable types and indices in our universal
circuit construction to the actual wire indices used in Proto-
col 2 in Section 3, e.g., φl(i)gets the index of the wire carrying
the value of li. Deﬁne the following sets:
• IL = {φl(i)}i∈{1,..,ns+3n∗+3n+}
• IL(cid:48) = {φl(cid:48)(i)}i∈{1,..,ns+3n∗+3n+}
• Ispec = IL ∪ IL(cid:48) (Note: in the general case of our multi-
opcode universal circuit (Section 5), this will also include
the functionality selectors of the instructions).
• IZio = {φz(i)}i∈{1,..,ns}
• IZw = {φz(i)}i∈{ns+1,..,ns+3n∗+3n+}
• IZ(cid:48) = {φz(cid:48)(i)}i∈{1,..,ns+3n∗+3n+}
• IR = {φr(i)}i∈{1,2}
• Iaux represents all other intermediate wire indices in the
universal circuit, i.e., Iaux = {k : k ∈ {1, ..,m}∧ k /∈ IL ∪
IL(cid:48) ∪ IZio ∪ IZw ∪ IZ(cid:48) ∪ IR}, where m is the total number of
wires in the universal circuit.