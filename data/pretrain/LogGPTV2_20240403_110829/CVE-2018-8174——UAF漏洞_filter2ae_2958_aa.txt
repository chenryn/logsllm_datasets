# CVE-2018-8174——UAF漏洞
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 一、 前言
CVE-2018-8174漏洞在当时影响最新版本的IE浏览器以及使用了IE内核的应用程序。用户在浏览网页或者打开Office文档的时候都可能中招。该漏洞的核心就是UAF，也算是大家比较熟悉的一种漏洞，本次实验就是为了对该漏洞进行详细分析理解，并详细分析记录复现过程，供大家相互交流学习。
## 二、 实验目标
###  1 .漏洞实例简介
CVE-2018-8174是2018年4月份由360团队在一起APT攻击中捕获的0day，实际攻击样本中该漏洞结合CVE-2017-0199（一个关于office
ole相关的逻辑漏洞）实现远程代码访问执行，360将该漏洞命名为“双杀”漏洞。该漏洞存在于VBsCript引擎中，VbsCript在释放相关对象时对引用计数问题处理不善，当我们构造特定的对象引用即有可能借助该漏洞实现释放内存空间的访问，即UAF利用。这次实验就是为了从漏洞本身入手，熟练掌握windbg的使用以及深入理解该漏洞的利用技巧并且对VBS虚拟机脚本解释机制进行一定程度的刺探。
###  2 逆向目标
本次实验的主要目的就是为了介绍UAF漏洞本身的成因，尝试浮现还原整个利用攻击过程以及最后的调试分析CVE-2018-8174漏洞的成因和POC代码的验证。
###  3 漏洞基本原理
在介绍漏洞的原理前我们先来通过一段C++代码制造的悬垂指针来理解一下UAF，代码如下：
在指针p1被释放后，却仍然可以执行已经被释放的内存，而且在 free 了 p1 之后再次申请同样大小空间，操作系统会将刚刚 free 了的内存重新分配。
并且可以通过p2操作p1,那么如果再次使用p1，则可以通过p2修改程序功能等目的。p1就叫做悬垂指针，UAF会造成内存破坏的原因就是使用了悬垂指针。
在理解了上面的悬垂指针后再看在vbs中的悬垂指针是怎样的，用一个根据原始 PoC 修改的造成悬垂指针的脚本来理解一下：
如上图，在UAF函数中，Set array_a(1)=New Trigger 是创建了一个 Trigger 实例给数组array_a，Erase
array_a 在析构 array_a 中的元素时，会调用 Trigger 的重载的析构函数；在此函数中先增加了一个 array_b(0) 对
Trigger 实例的引用（Trigger实例引用计数+1），又通过 array_a(1)=1 删除 array_a(1) 对 Trigger
实例的引用，（Trigger的实例引用计数减1）来平衡引用计数后，才会彻底释放 Trigger 实例；但是此时 array_b(0)
仍然保留着这个类的引用，然后在 TriggerVuln 函数中，array_b(0)=0对 array_b(0) 进行访问时造成了触发漏洞，此时
array_b(0) 就叫做悬垂指针。
###  4 漏洞分析与验证的方法
对于漏洞的分析，是根据原始的POC仿造写了一个造成悬垂指针的脚本来进行分析，对于漏洞的验证则是通过仿写脚本的调试以及结合vbscript的IDA逆向分析的结合，最终产生一个浏览器崩溃的效果。
## 三、实验环境
###  1 工具
Windbg
###  2 环境
Win7、kali
## 四、 实验过程
###  1 漏洞复现
打开本地的CVE-2018-8174_PoC.html，可以发现触发了shellcode并且弹出了计算器：
###  2 逆向分析
漏洞的基本原理在上面已经讲过了，下面我们就直接用windbg进行调试。
先在windbg所在文件夹开启hpa页堆调试和ust栈回溯选项:
先不做任何断点来直接看一下IE的崩溃现场：
这表明访问了已经释放的内存导致奔溃，用!heap -p -a eax看一下：
可以看到对象所在的内存已经被释放了。
同时我们通过IDA逆向vbscript.dll看一下VBScriptClass::Release函数中的逻辑：
基本上每行有用的伪代码后面我都做了详细的注释，这里也就不细讲了，接下来直接用windbg进行漏洞的溯源。
首先给windbg中下断点：
    bu vbscript!VBScriptClass::TerminateClass ".printf \"Class %mu at %x, terminate called\\n\", poi(@ecx + 0x24), @ecx; g";
    bu vbscript!VBScriptClass::Release ".printf \"Class %mu at: %x ref counter, release called: %d\\n\", poi(@eax + 0x24), @ecx, poi(@eax + 0x4); g";
    bu vbscript!VBScriptClass::Create+0x55 ".printf \"Class %mu created at %x\\n\", poi(@esi + 0x24), @esi; g";
    bu vbscript!VbsIsEmpty
在按下g让程序运行以后，程序会断在我们脚本中设计的IsEmpty处：
我们可以看到Trigger对象创建在了61ff98的地方。
我们可以用dd命令看一下对象地址相对应的内容：
02指的就是引用计数，00469b8c存放的就是类的名字“Trigger”。下面是从网上找的VBscriptClass类结构图：
以上是通过在Create函数的地方下断点的方式来输出类的地址，下面就通过vbscript!VbsIsEmpty断点追溯到类的地址。
    0:005> dd 61ff98
    0061ff98  6dd41748 00000002 0061e6b0 0061d098
    0061ffa8  00000850 00000000 00000000 01d4b41c
    0061ffb8  00000000 00469b8c 00000000 00000000
    0061ffc8  00000000 00000000 171305bb 0800218f
    0061ffd8  01d4a428 00000001 111305bd 03002185
    0061ffe8  00000000 00000000 00610038 00610038
    0061fff8  00620000 00000000 000100ae 01000000
    00620008  ffeeffee 00000001 fea000a8 fea000a8
    0:005> dd poi(esp+c)
    0061fe18  0000004a 000007ff 01d4b3f8 02000002 //01d4b3f8是数据结构地址
    0061fe28  00610000 01d49828 00000001 00000000
    0061fe38  0239cf68 0061fe58 01d489fc 00000001
    0061fe48  00000000 00000141 00000148 01d48854
    0061fe58  0239d1ac 0061fe98 00000001 00000000
    0061fe68  0000400c 00000000 0061e548 00000000
    0061fe78  0000400c 00000000 0061e508 00000000
    0061fe88  00000000 0000000b 00000195 00000013
    0:005> dd 1d4b3f8 l8
    01d4b3f8  0000200c 000007ff 0046a4b0 02000002 //200c这两个字节表示的是VBScript变量类型，表示的是SAFEARRAY类型，ARRAY在046a4b0存放
    01d4b408  00000000 00000000 3713059b 0c0121e1
    0:005> dd 46a4b0
    0046a4b0  08800001 00000010 00000000 004a5ba0//4a5ba0为array_a数据元素地址
    +0x000 cDims      : 1       //cDims表示维数
      +0x002 fFeatures    : 0x880
      +0x004 cbElements    : 0x10
      +0x008 cLocks      : 0
      +0x00c pvData      : 004a5ba0 Void    //array_a数据元素地址
      +0x010 rgsabound    : [1] tagSAFEARRAYBOUND
    0046a4c0  00000002 00000000 2ad0008a 80000000
    0046a4d0  6a6a0050 00000000 6a327be0 0046c390
    0046a4e0  6a333ce0 00000000 00000000 00000000
    0046a4f0  00000000 00000000 2ad0008c 80000000
    0046a500  00000056 00000000 00000000 00000000
    0046a510  00000000 00000000 00000000 00000000
    0046a520  00000000 00000000 2ad000b6 80000000
    0:005> dd 4a5ba0
    004a5ba0  00000000 00000000 00000000 00000000 //array_a(0)没有定义
    004a5bb0  00000009 00000132 0061ff98 00000001 //array_a(1)type==0x9表示是一个object,值为0061ff98，这也是我们通过create断点得到的值，即类对象的地址
    004a5bc0  2ad1908b 88000000 00000000 0046a328
    004a5bd0  004a5d38 004a5a68 00000000 00000000
    004a5be0  00000000 00000000 2ad1908e 88000000
    004a5bf0  00000000 6dd9aa60 004a5c98 004a5c48
    004a5c00  00000000 00000000 00000000 00000000
    004a5c10  2ad19071 88000000 00000000 0040497c
接下来就执行到了第二个断点，即析构函数中的ISEmpty的时候（在Erase
array_a的时候，会触发Class_Terminate析构函数），此时Set array_b(0)=array_a(1)已执行：
    Breakpoint 3 hit
    eax=6dd4185c ebx=0239c938 ecx=6dd9a9d8 edx=0239c8b0 esi=01d4a574 edi=00000001
    eip=6dd5c206 esp=0239c7cc ebp=0239c7dc iopl=0     nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000       efl=00000246
    vbscript!VbsIsEmpty:
    6dd5c206 8bff       mov   edi,edi
    0:005> dd poi(esp+c)
    0061fde8  01d4600c 0061ff10 0061e554 00433018 //data buffer在00433018
    0061fdf8  00000000 00000132 0061ff98 00000001
    0061fe08  0239cd24 0061fe38 00610001 0000002b
    0061fe18  0000400c 000007ff 0061e508 02000002
    0061fe28  00610000 01d49828 00000001 00000000
    0061fe38  0239cf68 0061fe58 01d489fc 00000001
    0061fe48  00000000 00000141 00000148 01d48854
    0061fe58  0239d1ac 0061fe98 00000001 00000000
    0:005> dd 433018  //safearray结构
    00433018  08920001 00000010 00000000 004a5f88
    00433028  00000002 00000000 2ad63fad 8a000000
    00433038  00420056 00530020 00720063 00700069
    00433048  00200074 0061004c 0067006e 00610075
    00433058  00650067 00000000 2ad63fa7 88000000
    00433068  6a6acaf0 00000001 6a327be0 0044fa28
    00433078  6a2c4320 0044fa28 6a322028 00000001
    00433088  00000005 00000000 2ad63fb9 88000000
    0:005> dd 4a5f88
    004a5f88  00000009 00000132 0061ff98 00000001 //类型还是0x09，array_b(0)中此时保存着类对象地址
    004a5f98  00000000 00000000 00000000 00000000
    004a5fa8  2ad19006 80000000 000001b0 00000000
    004a5fb8  00000000 00000000 00000000 00000000
    004a5fc8  00000000 00000000 2ad19009 80000000
    004a5fd8  000001b5 00000000 00000004 00008a0c
    004a5fe8  003c0090 003c0090 003c0038 003c0038
    004a5ff8  2ad1900c 8000a000 000001ba 00000000
    0:005> dd 61ff98 //类对象地址
    0061ff98  6dd41748 00000004 0061e6b0 0061d098
    0061ffa8  00000850 00000000 00000000 01d4b41c
    0061ffb8  00000001 00469b8c 00000000 00000000
    0061ffc8  00000000 00000000 171305bb 0800218f
    0061ffd8  01d4a428 00000001 111305bd 03002185
    0061ffe8  00000000 00000000 00610038 00610038
    0061fff8  00620000 00000000 000100ae 01000000
    00620008  ffeeffee 00000001 fea000a8 fea000a8
    0:005> du 469b8c //类名称
    00469b8c  "Trigger"
再然后就是第三次断点，此时Erase已经执行完毕，可以看到已经到了漏洞点：
在上面我们可以发现显然有些地方出现了错误，明明 array_b 还保留着对 Trigger Object引用的时候，Trigger Object却随着
Erase array_a被释放了。我们来看看错误的地方：
在IDA里面查看过 VBScriptClass::Release的伪代码，以及上面的调试后，我们猜测在脚本中的重载的析构函数中，Set
array_b(0)=array_a(1)这句是否有对Class Trigger的引用计数进行操作：
接下来通过windbg调试进行验证，首先在以下位置下断点：
    bu vbscript!VbsErase
    bu vbscript!VBScriptClass::Release
    bu vbscript!VbsIsEmpty
    bu  vbscript!VBScriptClass::Create+0x55 ".printf \"Class %mu created at %x\\n\", poi(@esi + 0x24), @esi; g"
前面的几次 Release 不用看，一直到VbsErase后面的release的时候单步调试
（此时在调试日志中，类对象地址已经被bu vbscript!VBScriptClass::Create+0x55 “.printf \”Class %mu
created at %x\n\”, poi([@esi](https://github.com/esi "@esi") \+ 0x24),
[@esi](https://github.com/esi "@esi"); g”; 打印出来了，或者运行到 release 的时候的esp
+8也是类对象地址）
    0:013> g
    ModLoad: 6eb30000 6eb9b000  C:\Windows\system32\vbscript.dll
    Class Trigger created at 412f58
    Breakpoint 1 hit
    eax=00412f58 ebx=0247cf90 ecx=6eb31748 edx=00000002 esi=00000000 edi=0041fe20
    eip=6eb41ef3 esp=0247ce48 ebp=0247cf38 iopl=0     nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000       efl=00000246
    vbscript!VBScriptClass::Release:
    6eb41ef3 8bff       mov   edi,edi
    0:005> g
    Breakpoint 1 hit
    eax=00412f58 ebx=00000320 ecx=6eb31748 edx=00000000 esi=0214b3f8 edi=00000009
    eip=6eb41ef3 esp=0247cdfc ebp=0247ce0c iopl=0     nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000       efl=00000202
    vbscript!VBScriptClass::Release:
    6eb41ef3 8bff       mov   edi,edi
    0:005> g
    Breakpoint 1 hit
    eax=00412f58 ebx=00000320 ecx=6eb31748 edx=00000002 esi=0214b3f8 edi=00000009