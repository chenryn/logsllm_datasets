# 程序分析理论 第五部分 对控制流分析的基于类型和响应的系统模型
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 前言
本篇是程序分析理论第十一篇：基于类型和响应的系统模型Type and Effect Systems
想法：加入type模型在分析过程中触发响应模型实现函数指向。
## 基于类型的系统模型 Type System
基于类型的系统模型首先要引入类型要素，类型要素包括bool，类型转换，int。我们分析的语句形式包括：变量，true /false ， e e，fn ，
fun ，let in。
首先，我们做出基于类型的函数语言的语法：
和之前的语法相似，常数为c ，变量为 x，函数fn _π x = > e_0 ，递归函数 fun\_π f x => e_0 ,并列语句 e_1 e_2
，if语句 if e_0 then e_1 else e_2 ，函数调用语句 let x = e_1 in e_2 ，判断语句 e_1 op
e_2。其中不同的是在函数和递归函数中添加了断点π。
接着，我们提出底层类型模型实现类型判断：
用语句表示就是Γ |- e : t
其中Γ表示 。e表示抽象语句 ，t表示类型
任意 c 存在type，如 true = bool 7 = int
对于任意判断语句参数为int类型，结果为bool类型
应用到所有语句就会变成：
Γ |- c : t_c
Γ |- x : t Γ(x) = t
Γ[x->t _x] |- e_0 : t_0 / Γ |- fn_ π x=>e_0 : t_x -> t_0 (x类型是t_x，e_0最后输出类型是
t_0)
Γ[f -> t _x- >t_0][x->t_x] |- e_0 : t_0 / Γ |- fun_π f x=>e_0 : t_x -> t_0
(x类型是t_x，e_0最后输出类型是 t_0，递归时，f作为t_x进入以t_0输出)
Γ |- e_1 : t_2 -> t_0 Γ |- e_2 : t_2 / Γ |- e_1 e_2 -> t_0
(e_1将t_2类型转换成t_0，e_2是t_2类型。最后输出是t_0类型)
Γ |- e_0 : bool Γ |- e_1 : t Γ |- e_2 : t / Γ |- if e_0 then e_1 else e_2 : t
(经过判断后执行语句)
Γ |- e_1 : t_1 Γ[x -> t_1] |- e_2 : t_2 / Γ |- let e_1 in e_2 : t_2
(最终根据e_2确定type)
Γ |- e_1 : t_1 Γ |- e_2 : t_2 / Γ |- e_1 op e_2 : t
(判断语句两个参数是可以比较的类型，返回值是bool类型)
###  例子 Example
首先let in结构Γ |- e_1 : t_1 Γ[x -> t_1] |- e_2 : t_2 / Γ |- let e_1 in e_2 : t_2
fun 结构Γ[f -> t _x- >t_0][x->t_x] |- e_0 : t_0 / Γ |- fun_π f x=>e_0 : t_x -t_0
fn结构Γ[x->t _x] |- y : t_0 / Γ |- fn\_ π x=>y : t _x - > t_0 Γ[x->t_x] |- z :
t_0 / Γ |- fn_π x=>z : t_x -t_0
e_1 e_2结构 Γ |- e_1 : t_2 -> t_0 Γ |- e_2 : t_2 / Γ |- e_1 e_2 -> t_0
总结下来的操作就是 [f -> (t -> t) -> (t -> t)] [x -> t ->t] 递归函数中，不断循环fn y的操作，再执行fn
z的操作。
所以基于类型的系统模型应用在控制流分析中可以根据数据类型调用函数，int bool始终是本身，t->t代表是一个函数的抽象。
由于存在多个相同的类型转换的函数抽象无法区别彼此，我们添加标记φ。
我们在之前的fn和fun结构中增加了断点，此时可以应用这些断点进行区别。
## 基于响应的系统模型Effect System
对于特定type_1和特定type_2形成对应关系的语句，我们应当作出相应的特定操作。这就是基于响应的思想。
对于控制流，我们要做的响应是抽象函数的调用。对于异常，我们要做出不同特定的响应。对于作用域我们要对数据作用域作出响应。对于交互我们要对不同时间的信号作出响应。
要实现这样一个系统模型，我们要使用基于类型的函数语言，底层类型系统，响应系统的拓展。
首先基于类型的函数语言和底层类型系统在上面已经提到，响应系统的拓展就是使用上面提到的φ进行。
上一个例子我们得到 [f -> (t -> t) -> (t -> t)] [x -> t ->t]的结论，但是转换之间调用的函数无法确定，此时我们应用φ。
由于存在fn y和fn z，所以同类φ中存在y z 两种方法，实际执行中可能是两种之中的一个。还有fun f，同类φ中只有F。至于g
()则不调用函数，为空。
最后得到 [f -> (t – {Y,Z} -> t) – {F} -> (t – 空 -> t)] [x -> t – {Y,Z} ->t]
仅仅记录调用函数肯定不能直接实现程序分析，还要有值，也就是程序中一定存在某处是赋值语句，在控制流分析中，我们把赋值语句也当作了函数，或者说某个函数的返回值是一个值，所以我们可以做出e
-> v 的归纳。
加上这一归纳后的语法也发生了一些变化：
c -> c
fn_π x => e _0 — > fn\_π x -> e_0
fun_π f x -> e _0 — > fn\_π x ->(e _0[f - > fun\_π f x -> e_0])
(在递归过程中，不断分解成fn x -> e_0)
e_1 —> fn_π x -> e_0 e_2 —> v_2 e_0[x -> v_2] —> v_0 / e_1 e_2 —>v_0
(e_1是一个函数，e_2是赋值，最终是将v_2当作x代入函数，返回值v_0)
e_0 —>true e_1 —>v_1 / if e_0 then e_1 else e_2 —> v_1 (判断为true返回e_1的返回值)
e_0 —>false e_2 —>v_2 / if e_0 then e_1 else e_2 —> v_2 (判断为false返回e_2的返回值)
e_1 -> v_1 e_2[x->v_1] ->v_2 /let x = e_1 in e_2 ->v_2 (函数返回值为v_1 代入e_2中得到v_2)