of the message; otherwise the message is not read at all. For exam-
ple, process ‘in(Claim(x)).P’ may only read messages of the form
Claim(M), binding x to M in P. Encryption just binds x to the en-
crypted message, while decryption checks if the message contained
in x matches the form {M1, . . . ,Mn}M0 (or {|M1, . . . ,Mn|}M0 ), i.e.,
is a tuple of n messages encrypted with the appropriate key. Only in
this case x is decrypted and the variables in the patterns M1, . . . ,Mn
get bound to the decrypted messages. Similarly to the input prim-
itive, decryption also may test part of the decrypted messages by
pattern-matching mechanism. Finally, the primitives run(I1,I2,M ).S
and commit(I1,I2,M ).S declare that the sequential process I1 is start-
ing and committing respectively, a protocol session with I2 for au-
thenticating message M . These constructs are used to check the
correspondence assertions [24].
It is important to note that we make a distinction between static
terms, or patterns, and dynamic terms, or messages. The former,
noted M , deﬁne the set of syntactically legal terms; the latter, noted
M, deﬁne the set of terms that may arise at run time. The difference
is that messages may have (nested) encryptions, while patterns may
not: notice, to this regard, that in the syntax of processes, encryp-
tions may only be formed by means of the encrypt preﬁx.
Example 1. Let us consider a (ﬂawed) simpliﬁcation of the pro-
tocol presented in the Introduction, obtained by eliminating the
nonce.
(we implement signature by encrypting with the private
key.)
A → B :
{B, m}Priv(kA)
responder are run in parallel. The Initiator generates a new mes-
sage m, declares the start of the session with the responder, signs
m together with the responder identiﬁer and sends the obtained ci-
phertext on the network. The Responder reads a message from the
network and tries to decrypt it with the public key of the initia-
tor and checks that its own identiﬁer is the ﬁrst component of the
plaintext. If this is the case, it commits on the received message x.
Operational Semantics. We deﬁne the operational semantics of
ρ-spi in terms of traces, after [7]. A trace is a possible sequence
of actions performed by a process. Each process primitive has an
associated action and we denote with Act the set of all possible
actions. The dynamics of the calculus is is formalized by means
of a transition relation between conﬁgurations, i.e., pairs (cid:8)s, P(cid:9),
where s ∈ Act
is a trace, P is a (closed) process. Each transi-
tion (cid:8)s, P(cid:9) −→ (cid:8)s :: α, P
(cid:11)(cid:9) simulates one computation step in P and
records the corresponding action in the trace.
∗
Principals do not directly synchronize with each other. Instead,
they may receive from the unique channel an arbitrary message M
known by the environment, which models the Dolev-Yao intruder:
the environment knows all the identity labels, the messages sent
on the network, the content of ciphertexts whose decryption key
is known, ciphertexts created by its knowledge and all the keys
declared as owned by E together with all the public keys. Finally,
it may create fresh names not appearing in the trace. The transition
relation is given in detail in Appendix A.
Deﬁnition 1 (Traces) The set T (P) of traces of process P is the set
of all the traces generated by a ﬁnite sequence of transitions from
(cid:11)(cid:9)}
the conﬁguration (cid:8)ε, P(cid:9): T (P) = {s | ∃P
The notion of safety (similar to the one in [11]) formalizes the cor-
respondence property of [24], also known as agreement [18].
s.t. (cid:8)ε, P(cid:9) −→∗ (cid:8)s, P
(cid:11)
The narration of the protocol in ρ-spi is reported in Table 2; after
declaring the key pair for A, an unbounded number of instances
of A as initiator and an unbounded number of instances of B as
Deﬁnition 2 (Safety) A trace s is safe if and only if whenever s =
(cid:11)
(cid:11)(cid:11)
s1 :: commit(B, A, M) :: s2, then s1 = s
1 :: run(A, B, M) :: s
1, and
1 :: s2 is safe. A process P is safe if, ∀s ∈ T (P), s is safe.
(cid:11)(cid:11)
(cid:11)
1 :: s
s
Table 2 Simple Protocol in ρ-spi calculus
Protocol (cid:1) let kA = asym-key(A) . (A (cid:2) !Initiator | B (cid:2) !Responder)
Initiator (cid:1) new(m).run(A, B, m).encrypt {|B, m|}Priv(kA) as z.out(z).
Responder (cid:1) in(z).decrypt z as {|B, x|}Pub(kA).commit(B, A, x)
Informally, a trace is safe if every commit(B, A, M) is preceded by
a distinct run(A, B, M). This guarantees that whenever B is con-
vinced of the identity of A sending M, then A has indeed started the
protocol with B for authenticating M.
Example 2. To illustrate the semantics of the calculus and the
notion of safety, let us consider again the protocol of Example 1. It
suffers of the following standard replay attack, where E imperson-
ates A by just replaying a previously intercepted message:
→ B :
A
E(A) → B :
{B, m}Priv(kA)
{B, m}Priv(kA)
Consider the ρ-spi calculus speciﬁcation of Table 2. The attack
mentioned above corresponds to the following execution trace of
process Protocol:
asym− key(kA, A) :: new(m) :: run(A, B, m) ::
encrypt{|B, m|}Priv(kA) :: out({|B, m|}Priv(kA)) ::
in({|B, m|}Priv(kA)) :: decrypt{|B, m|}Priv(kA) :: commit(B, A, m) ::
in({|B, m|}Priv(kA)) :: decrypt{|B, m|}Priv(kA) :: commit(B, A, m)
Notice that the same message {B, m}Priv(kA) is read twice by two
different instances of the Responder. This causes two commits with
just one run, thus making this trace unsafe. The presence of the
nonce (as discussed in the Introduction) repairs the protocol avoid-
ing this replay attack.
3. THE TYPE AND EFFECT SYSTEM
Authentication protocols are typically based on challenge-response
schemes in which the knowledge of a secret key is proved by either
encrypting or decrypting a fresh challenge using such a key. Here
we consider authentication protocols that use nonces (number used
only once) as fresh challenges. There are three possible kinds of
nonce handshakes [12, 15]: in Public-Out Secret-Home (POSH),
the nonce is sent as cleartext and received into a ciphertext, in
Secret-Out Public-Home (SOPH) the opposite happens, while in
Secret-Out Secret-Home (SOSH), the nonce is sent out and received
back into (different) ciphertexts.
Our type and effect system is based on some basic notions and
rules (Section 3.1), and generic rules for processes (Section 3.2).
The core of the analysis collects rules for checking authentication
based on all of the above described nonce handshakes (Section 3.3).
All types, effects and typing rules involve judgments on messages,
i.e. the dynamic terms arising at run time: this is required to prove
Subject reduction for the type and effect system.
3.1 Basic Notions and Rules
The deﬁnitions of the types and effects as well as the rules for deriv-
ing basic judgments are in Table 3. The typing environment Γ is an
ordered set of bindings between names/variables and types. Types
regulate the use of terms in the authentication task. A long-term
key shared between I and J has type keysym(I, J) and it can only be
used by I and J. A name used for creating a key pair owned by I has
type keyasym(I); the private and public keys created by that name
have type keypub(I) and keypriv(I), respectively. While private keys
can only be used by their owners, public keys are available to every
principal. Every untagged term potentially known by the enemy
has type Un. A nonce used by I and J in a SOPH/SOSH for au-
thenticating M has initially type nonce(I, J, M). As explained in
Section 3.3, when the nonce is sent back by I, the type is cast to
Un, since the nonce may be sent as cleartext. Trusted principals
can encrypt messages only subject to certain hypotheses: the type
enc( f ) is assigned to ciphertexts which can be created under the hy-
pothesis represented by the atomic effect f . This type is discussed
in Section §3.2, where we also describe effects.
Well-Formedness conditions are mostly standard. The empty en-
vironment is well-formed (ENV (cid:14)). An environment Γ is well-
formed (ENV NAME AND VAR) only if it does not contain multiple
occurrences of the same name/variable a. Moreover, types may
only depend on untrusted terms. Since identities have always type
Un (cf. rule IDENTITY), this condition just enforces that M has
type Un in nonce(I, J, M).
The typing rules for public and private keys are straightforward.
The type and effect system is provided with two sub-typing rules,
namely ENEMY KNOWLEDGE, in Table 3 and SECRET NONCE
(discussed in section 3.4, Table 6). ENEMY KNOWLEDGE charac-
terizes the knowledge of the enemy: as mentioned in §2, the enemy
may be provided with both symmetric and asymmetric long-term
keys; furthermore, the enemy knows all the public keys and may
learn the secret nonces intended to be shared with him. Hence, all
the corresponding types are subtypes of Un.
3.2 Typing Processes
To ease the presentation of the process calculus, so far we have
given an untyped version of the restriction.
Indeed, the type of
nonces needs to be explicitly indicated in the restriction primitive.
We will write new(n : T ), where T is either Un or nonce(I, J, M).
Processes are typed according to the judgment Γ (cid:15) P : e. Intu-
itively, Γ (cid:15) P : e means that the process P can be typed under the
typing environment Γ and the hypotheses expressed by the effect e.
Judgment I;Γ (cid:15) S : e, for the sequential process S executed by the
entity I, has the same intuitive meaning.
Effects are multisets of the atomic effects reported in Table 3,
and their intuitive meaning explained below.
• The freshness of a public nonce n is expressed by f resh(n) or
f resh(n, I, J, M), according to the type of the nonce: f resh(n)
is used in POSH nonce handshakes, where n is generated
as Un and sent in clear, while f resh(n, I, J, M) is used for
SOPH/SOSH, where n has type nonce(I, J, M) and is sent
encrypted. These atomic effects are added when the nonce is
generated and are removed whenever a commit requires the
freshness of n. The purpose is to guarantee that each nonce
is checked at most once, i.e., there is at most one commit on
each nonce.
• Sometimes an encryption represents the start of an authenti-
cation session (as in the simple protocol of Example 2). We
require each of those encryptions to be preceded by a differ-
ent run. The atomic effect run(I, J, M) serves this purpose: it
Table 3 Types Deﬁnitions
a, b range over names and variables.
Types
T
::= keysym(I, J)
keyasym(I)
keypub(I)
keypriv(I)
Un
nonce(I, J, M)
enc( f )
long-term key
asymmetric component
public key
private key
untrusted
secret nonce
ciphertext
Environment Well-Formedness
Atomic Effects
f
::= (cid:14)
f resh(n)
f resh(n, I, J, M)
run(I, J, M)
in(M)
dec{M1, . . . ,Mn}M0
empty effect
public nonce freshness
secret nonce freshness
run
input
decryption
ENV (cid:14)
(cid:14) (cid:15) (cid:16)
ENV NAME AND VAR
a /∈ dom(Γ)
Γ (cid:15) (cid:16)
a (cid:17)= I
T depends on M ⇒ Γ (cid:15) M : Un
Γ, a : T (cid:15) (cid:16)
PROJECTION
Γ, a : T,Γ(cid:11) (cid:15) (cid:16)
Γ, a : T,Γ(cid:11) (cid:15) a : T
Typing Rules for Messages
IDENTITY
Γ (cid:15) I : Un
PUBLIC KEY
Γ (cid:15) k : keyasym(I)
Γ (cid:15) Pub(k) : keypub(I)
PRIVATE KEY
Γ (cid:15) k : keyasym(I)
Γ (cid:15) Priv(k) : keypriv(I)
SUBSUMPTION
Γ (cid:15) N : T
Γ (cid:15) T
(cid:11)
Γ (cid:15) N : T
(cid:11) <: T
ENEMY KNOLEDGE
T ∈ {keysym(E, I), keyasym(E), keypriv(E), keypub(I), nonce(E, I, M)}
Γ (cid:15) T <: Un
is added to the typing effects when a run primitive is typed,
and it is removed when typing an encryption representing a
new session between I and J exchanging M.
• Receiving M is recorded by the atomic effect in(M) and de-
crypting the ciphertext {M1, . . . ,Mn}M0 is recorded by the
atomic effect dec{M1, . . . ,Mn}M0 . These effects are useful
in the authentication rules (Table 5) to check that a message
has been received/decrypted.
The Rules for judgments Γ (cid:15) P : e and I;Γ (cid:15) S : e are reported in
Table 4 and described below. Key declarations are typed by SYM-
METRIC and ASYMMETRIC KEY: the key just created is inserted
in Γ with the appropriate type. REPLICATION typechecks the repli-
cation of sequential processes, while PAR typechecks the parallel
composition of two processes: the resulting effect is the the sum
of the effects required for typing the components. IDENTITY AS-
SIGNMENT is straightforward: Γ (cid:15) A (cid:2) S : e only if A;Γ (cid:15) S : e,
namely only if S can be executed by A under Γ and the hypothe-
ses in e. Notice that sequential processes can be executed only
by trusted principals: as discussed in §2, the enemy is implicitly
modeled by the semantics. By NIL, the null process can be always
typed. RUN adds the atomic effect run(A, I, M) to the typing effect
of the continuation process. In INPUT, all the free variables in the
input messages are inserted in Γ with type Un. The atomic effects
in(Mi) keep track of the received messages. By OUTPUT, a term
can be sent on the network only if it is typable by Un.
The restriction may be typed by two different rules: NEW NAME
and NEW SECRET NONCE. In the former, the nonce is intended to
be sent as cleartext on the network, so n is typed with Un. Since
f resh(n) is added to the typing effect of the
the nonce is fresh,