In spite of this difﬁculty, in general the penalty for using
the cryptoserver is less than 3%. The fact that the client
load remained extremely low, even when that one client
machine was pushing both boards at full speed, reinforces
the value of the cryptoserver merely in its role to ofﬂoad
processing, without beginning to consider speed beneﬁts
offered by increased parallelism and (possibly) faster sin-
gle cryptographic operations.
5.2. TLS Performance
Microbenchmarks help us characterize the details of
cryptoserver performance, but leave many unanswered
questions as to how the cryptoserver performs with real
world tasks. We decided to benchmark the cryptoserver
with a client supporting the TLS protocol to get a better
understanding of how a cryptoserver might accelerate a
secure Web server. We wrote a small, multithreaded server
that uses OpenSSL to respond to HTTP HEAD requests
with a ﬁxed string. We had a benchmark client written by
Cryptoserver Conﬁguration
AXL200 only (insecure)
AXL200 (secure)
nFast 300 only (insecure)
nFast 300 (secure)
nFast 300 (insecure, CRT)
nFast 300 (secure, CRT)
Both (insecure)
Both (secure)
Both (insecure, multi)
Both (secure, multi)
Both (insecure, CRT)
Both (insecure, CRT, multi)
Both (secure, CRT, multi)
Threads Throughput
265.73
265.58
93.20
93.21
299.41
299.34
354.01
354.17
355.50
355.55
560.60
563.94
562.25
26
26
26
26
26
26
70
70
30
30
70
30
30
Table 3. Multi-Threaded Performance
Dan Boneh, Michael Malkin, and Tom Wu that generates
HTTP HEAD requests over a TLS connection.
While these benchmarks programs are somewhat artiﬁ-
cial, they are small enough that we can easily understand
their behavior. The client opens a TLS connection (specif-
ically not resuming a prior connection), and sends a 19
byte HTTP HEAD request. The server replies with a 107
byte answer, and closes the connection. This is nearly the
worst case for TLS, as we are exchanging very little data
per RSA operation. However, since RSA performance is
exactly what we are trying to characterize, this is exactly
what we want.
The experimental setup is the same as before. For sim-
plicity of presentation, we only measured the AXL200
board. The results are shown in Table 4.
In all cases,
Cryptoserver Conﬁguration
Local AXL200
Remote AXL200 (secure)
Remote AXL200 (insecure)
Throughput
(connections/s)
187.38
244.68
261.64
Table 4. TLS Performance
the TLS benchmark server ran with 30 threads and the
TLS benchmark client ran with 40 threads, i.e., it could
request up to 40 concurrent RSA operations on the TLS
server. With the TLS server running locally, the server’s
CPU saturated. By using a remote cryptoserver, through-
put actually increased, as we are able to take advantage
of the available parallelism. The insecure connection to
the cryptoserver enabled the client to use  98% of an
AXL200’s maximum throughput; with a secure connec-
tion, the client exceeded 92% of an AXL200’s maximum
throughput.
6. Related Work
Network-attached cryptographic acceleration has only
been used in special cases so far. Rainbow Technolo-
gies has sold products in their CryptoSwift EN line for
several years, but its network connectivity is not secured.
This makes it only appropriate for use on trustworthy net-
works. In contrast, our approach is suitable for deploy-
ment on any network with suitable availability – 1000
1024-bit RSA operations per second requires approxi-
mately 4 Mbit/s of bandwidth; hardly a problem with
common 100 Mbit/s Ethernet infrastructure.
Note that in our approach the client must trust the cryp-
toserver with knowledge of his private key, and thus our
approach is quite different from the harder and gener-
ally unsolved problems of “server-aided cryptography,”
“remotely-keyed encryption” [2, 3, 22] or “computing
with encrypted data” [14]. We do this for practical rea-
sons, as we seek performance levels as close to available
hardware as possible. If truly practical server-aided cryp-
tographic techniques become available, then we are ide-
ally positioned to accommodate them.
7. Future Work
Viewing cryptography as a network service changes our
perspective about the costs of cryptography. Cryptogra-
phy is no longer computationally prohibitive; it is only
an RPC away. We are building applications using abun-
dant public key operations, including secure communi-
cation services for dynamic coalitions, private database
retrieval, and others. We also plan to build cryptoserver
clients implementing standard cryptographic APIs such as
PKCS #11, Microsoft’s CryptoAPI, and the Java Cryptog-
raphy Environment. This will allow legacy applications to
seamlessly take advantage of the cryptoserver. We may
also examine other choices of implementation platform
and middleware, increase the ﬂexibility and usability of
the server.
A remaining challenge is to see how well our software
architecture scales. While the software was designed with
scalability in mind (e.g., using a ﬁxed thread pool, accom-
modating inter- and intra-request parallelism, multiple re-
quest and reply handler threads to spread the symmetric
cryptographic load, etc.), the proof will be actually run-
ning thousands of modular exponentiations per second on
a suitable machine. This challenge will only increase as
the speed of accelerators increases and their latency for
single operations goes down.
In our
implementation, each request
includes the
client’s private key. Alternatively, if the cryptoserver al-
ready knows the client’s private key, then the request may
include an authentication token that demonstrates who
the request is coming from and that the request is fresh.
While this would require a more trustworthy cryptoserver,
it would reduce the network bandwidth required by nearly
half. There are several cryptographic accelerator products
on the market that will maintain secure local storage of
one or more private keys, and control access to them. It
would be a simple matter to provide shared network ac-
cess to such an accelerator in the manner presented above.
The cryptoserver offers interesting options for those
paranoid about their cryptographic operations. As our
server supports a heterogeneous collection of hardware
accelerators running concurrently, it would be a fairly sim-
ple modiﬁcation to use one accelerator to check the re-
sults delivered by another. By using different accelera-
tors, a single accelerator could not produce a doctored
result along with a doctored “inverse.” The tradeoff be-
tween paranoia and throughput could be easily managed
by checking a user-selectable fraction of results. By se-
lecting hardware accelerators designed and manufactured
in disjoint countries, no single government would be in a
position to compromise a RSA operation. Such a system
would be highly resistant to many attacks, including fault
injection [4].
A similar level of paranoia is available to clients, as dis-
cussed in Section 3: it is easy for the client code to issue
RPCs to more than one server. One might, for example,
use servers operated by different organizations, or servers
physically in multiple countries, to cross-verify results.
This ability to use multiple cryptoservers also makes it
very easy for clients to protect themselves against mali-
cious servers through the use of threshold cryptographic
techniques as discussed in Section 2.
8. Conclusion
We have demonstrated that public key cryptography can
be provided as a service over untrusted networks. This
architecture has many advantages: it ofﬂoads work from
clients, it allows greater utilization of cryptographic ac-
celerators by sharing them among many clients, and it has
acceptably small performance overhead. In addition, it en-
ables new security applications that were previously con-
sidered too costly. Our implementation consists of cus-
tomized software on top of generally available hardware.
Benchmark data indicate that our approach is fast and ef-
fective. Hardware trends and other factors indicate that
our approach will be increasingly attractive over time.
Acknowledgments
We thank Teresa Lunt for useful discussion about this
work. We thank Larry Hines at Atalla for providing addi-
tional information about the AXL200. We thank Jessica
Nelson at nCipher for technical assistance with the nFast
300. We thank the anonymous referees for helpful com-
ments on an earlier version of this paper.
References
[1] C. Adams. RFC 2025: The simple public-key GSS-API
mechanism (SPKM), Oct. 1996.
[2] M. Blaze.
High-bandwidth encryption with low-
bandwidth smartcards.
In Proceedings of the Fast Soft-
ware Encryption Workshop, number 1039 in Lecure Notes
in Computer Science, pages 33–40. Springer-Verlag, 1996.
[3] M. Blaze, J. Feigenbaum, and M. Naor. A formal treat-
ment of remotely keyed encryption. In K. Nyberg, editor,
Proceedings of EUROCRYPT’98, number 1403 in Lecure
Notes in Computer Science, pages 251–265. Springer-
Verlag, 1998.
[4] D. Boneh, R. DeMillo, and R. Lipton. On the importance
of checking cryptographic protocols for faults.
In Pro-
ceedings of Eurocrypt ’97, volume 1233 of Lecture Notes
in Computer Science, pages 37–51. Springer-Verlag, 1997.
[5] C. Boyd. Digital multisignatures. In H. Beker and F. Piper,
editors, Cryptography and Coding, Institute of Mathemat-
ics and Its Applications (IMA), pages 241–246. Clarendon
Press, 1989.
[6] V. Boyko, M. Peinado, and R. Venkatesan. Speeding up
discrete log and factoring based schemes via precomputa-
tion. In K. Nyberg, editor, Advances in Cryptology – EU-
ROCRYPT ’98, number 1403 in LNCS, pages 221–235,
Espoo, Finland, 1998. Springer-Verlag.
[7] C. Cachin, S. Micali, and M. Stadler. Computationally pri-
vate information retrieval with polylogarithmic communi-
cation. In Proceedings of EUROCRYPT ’99, pages 402–
414, 1999.
[8] D. Chaum. Blind signatures for untraceable payments. In
R. L. Rivest, A. Sherman, and D. Chaum, editors, Proc.
CRYPTO 82, pages 199–203, New York, 1983. Plenum
Press.
[9] D. Chaum and E. van Heyst.
Group signatures.
In D. W. Davies, editor, Advances in Cryptology—
EUROCRYPT 91, volume 547 of Lecture Notes in Com-
puter Science, pages 257–265. Springer-Verlag, 8–11 Apr.
1991.
[10] B. Chor, E. Kushilevitz, O. Goldreich, and M. Sudan. Pri-
vate information retrieval. Journal of the Association for
Computing Machinery, 45(6):965–981, Nov. 1998.
[11] R. Cramer, I. Damg˚ard, and B. Schoenmakers. Proofs of
partial knowledge and simpliﬁed design of witness hiding
protocols.
In Y. G. Desmedt, editor, Proc. CRYPTO 95,
pages 174–187. Springer, 1994. Lecture Notes in Com-
puter Science No. 839.
[12] Y. Desmedt and Y. Frankel. Threshold cryptosystems. In
G. Brassard, editor, Proc. CRYPTO 89, pages 307–315.
Springer-Verlag, 1990. Lecture Notes in Computer Sci-
ence No. 435.
[13] M. Eisler, A. Chiu, and L. Ling. RFC 2203: RPC-
SEC GSS protocol speciﬁcation, Sept. 1997.
[14] J. Feigenbaum. Encrypting problem instances: Or...can
you take advantage of someone without having to trust
him? In H. C. Williams, editor, Proc. CRYPTO 85, pages
477–488. Springer, 1986. Lecture Notes in Computer Sci-
ence No. 218.
[15] Y. Gertner, Y. Ishai, E. Kushilevitz, and T. Malkin. Protect-
ing data privacy in private information retrieval schemes.
In Proceedings of the 30th Annual ACM Symposium on
Theory of Computing (STOC-98), pages 151–160, New
York, May 23–26 1998. ACM Press.
[16] B. Huberman, T. Hogg, and M. Franklin. Enhancing pri-
vacy and trust in electronic communities. In Proceedings
of the ACM Conference on Electronic Commerce, 1999.
[17] M. Jakobsson, K. Sako, and R. Impagliazzo. Designated
veriﬁer proofs and their applications.
In U. Maurer, ed-
itor, Advances in Cryptology—EUROCRYPT 96, volume
1070 of Lecture Notes in Computer Science, pages 143–
154. Springer-Verlag, 12–16 May 1996.
[18] P. Kakkar, C. A. Gunter, and M. Abadi. Reasoning about
security for active networks. In Proceedings of the 13th
IEEE Computer Security Foundations Workshop, pages
118–129, Cambridge, UK, July 2000.
[19] B. A. LaMacchia and A. M. Odlyzko. Computation of
discrete logarithms in prime ﬁelds. Designs, Codes, and
Cryptography, 1:47–62, 1991.
[20] A. K. Lenstra and E. R. Verheul. Selecting cryptographic
key sizes. In Proceedings of the Public Key Cryptography
Conference 2000, Jan. 2000. Available from http://
www.cryptosavvy.com.
[21] J. Linn. RFC 2743: Generic security service application
program interface, version 2, update 1, Jan. 2000.
[22] S. Lucks. Accelerated remotely keyed encryption.
In
L. Knudsen, editor, Proceedings of the Fast Software En-
cryption Workshop, number 1636 in Lecure Notes in Com-
puter Science, pages 112–123. Springer-Verlag, 1999.
[23] A. J. Menezes, P. C. Van Oorschot, and S. A. Vanstone.
Handbook of applied cryptography. The CRC Press series
on discrete mathematics and its applications. CRC Press,
2000 N.W. Corporate Blvd., Boca Raton, FL 33431-9868,
USA, 1997.
[24] F. Monrose, P. Wyckoff, and A. Rubin. Distributed execu-
tion with remote audit. In Proceedings of the Network and
Distributed Systems Security Symposium. Internet Society,
1999.
[25] N. Nisan, S. London, O. Regev, and N. Camiel. Globally
distributed computation over the internet — the popcorn
project.
In Proceedings of the International Conference
on Distributed Computing Systems, pages 592–601, 1998.