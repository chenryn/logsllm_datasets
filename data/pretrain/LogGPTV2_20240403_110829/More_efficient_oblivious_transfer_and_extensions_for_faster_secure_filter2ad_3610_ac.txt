cols; a more eﬃcient protocol that is secure in the random oracle model and a
less eﬃcient protocol that is secure in the standard model and under standard
assumptions. In this section, we describe a new semi-honest OT protocol that
is secure in the standard model and is essentially an optimized instantiation of
the OT protocol of [16]. When implemented over elliptic curves, our protocol
is about three times faster than the standard model OT of [46] and only two
times slower than the random oracle OT of [46] (see §6.1 for a comparison of the
protocol runtimes). Hence, our protocol is a good alternative for those preferring
to not rely on random oracles.
Our n×OT(cid:96) protocol is based on the DDH assumption and uses a key deriva-
tion function (KDF); see Deﬁnition A1. We also assume that it is possible to
sample a random element of the group, and the DDH assumption will remain
hard even when the coins used to sample the element are given to the distin-
guisher (i.e., (g, h, ga, ha) is indistinguishable from (g, h, ga, gb) for random a, b,
even given the coins used to sample h). This holds for all known groups in which
the DDH problem is assumed to be hard and can be implemented as described
next. For ﬁnite ﬁelds, one can sample a random element h ∈ Zp of order q by
choosing a random x ∈R Zp and computing h = x(p−1)/q until h (cid:54)= 1. For ellip-
tic curves, one chooses a random x-coordinate, obtains a quadratic equation for
the y-coordinate and randomly chooses one of the solutions as h (if no solution
exists, start from the beginning).
The computational complexity of our protocol for n× OT(cid:96) is 2n exponentia-
tions for the sender Sand 2n ﬁxed-base exponentiations for the receiver R (in
ﬁxed-base exponentiations, the same “base” g is raised to the power of many dif-
ferent exponents; more eﬃcient exponentiation algorithms exist for this case [44,
Sec. 14.6.3]). In addition, S computes the KDF function 2n times, and R com-
putes it n times. R samples n random group elements according to the above
deﬁnition. See Protocol 51 for a detailed description of the protocol.
The protocol is secure in the presence of a semi-honest adversary (see Def-
inition A3). The view of a corrupted sender consists of the pairs {(h0
i )}n
i=1
which are completely independent of the receiver’s inputs, and therefore can
be simulated perfectly. For the corrupted receiver, we need to show the exis-
tence of a simulator S1 that produces a computationally-indistinguishable view,
given the inputs and outputs of the receiver, i.e., σ and (xσ1
n ), without
). S1 works by running an
knowing the other sender values (x1−σ1
execution of the protocol playing an honest S using inputs xσ1
n and
= 0 for all 1 ≤ i ≤ n. The only diﬀerence between the view
using x1−σi
, . . . , x1−σn
1 , . . . , xσn
1 , . . . , xσn
i , h1
i
1
n
13
PROTOCOL 51 (Optimized n×OT(cid:96) Protocol)
i ) of (cid:96)-bit strings, for every 1 ≤ i ≤ n. R holds
Inputs: S holds n pairs (x0
the selection bits σ = (σ1, . . . , σn). The parties agree on a group (cid:104)G, q, g(cid:105) for
which the DDH is hard, and a key derivation function KDF.
First Round (Receiver): Choose random exponents αi∈RZq and random
group elements hi∈RG for every 1 ≤ i ≤ n. Then, for every i, set (h0
i ) as
follows:
(cid:26) (gαi , hi)
i , h1
i , x1
i ) def=
(h0
i , h1
i , h1
i ) to S.
(hi, gαi )
if σi = 0
if σi = 1
Send the pairs (h0
Second Round (Sender): Choose a random element r∈RZq and com-
pute u = gr. Then, for each pair (h0
i ) =
i )r(cid:1) and compute the pair of ciphertexts:
i ) compute the keys: (k0
(cid:0)(h0
i )r, (h1
i , k1
i , h1
v0
i = x0
i ⊕ KDF(k0
i )
i = x1
i ⊕ KDF(k1
i ).
Send u together with the n pairs (v0
Output Computation (Receiver): For every 1 ≤ i ≤ n, set kσi
xσi
i = vσi
n ); S has no output.
i ). R outputs (xσ1
i ⊕ KDF(kσi
1 , . . . , xσn
i ) to R.
i = uαi and
and v1
i , v1
i
i
⊕ KDF(k1−σi
of the receiver generated by the simulator and in a real execution is regard-
ing the values {v1−σi
}n
i=1, which equal x1−σi
) in a real execution
and just KDF(k1−σi
) in the simulation. From the security of the KDF with re-
spect to DDH (see Deﬁnition A1), and using a standard hybrid argument, the
values (KDF(k1−σ1
), . . . , KDF(k1−σn
1), . . . , KDF(hr
n)) are indistin-
guishable from n uniform strings z1, . . . , zn each of size (cid:96) (even when the distin-
guisher sees (cid:104)G, q, g, u = gr(cid:105)). This implies that the values {v1−σi
}n
i=1 in the real
execution are computationally indistinguishable from those in the simulation.
)) = (KDF(hr
n
1
i
i
i
An additional optimization for random OT. When constructing OT extensions
(see §2.2) the parties ﬁrst run κ× OTκ on random inputs (this holds for our
optimized OT extension protocol, and also for the original protocol of [32] if
κ×OTm is implemented via κ×OTκ as described in §2.2). Observe that in this case,
the sender only needs to send u = gr to the receiver R; the parties can then derive
the values locally (S by computing x0
i )r), and
R by computing xσi
i = KDF(uαi)). This reduces the communication since the
elements v0
i and v1
i do not have to be sent. In addition, this means that the
messages sent by S and R are actually independent of each other, and so the
protocol consists of a single round of communication. (As pointed out in [49],
this optimization can also be carried out on the protocols of Naor-Pinkas [46].
However, those protocols still require two rounds of communication which can
be a drawback in high latency networks.) The timings that appear in §7 are for
an implementation that uses this additional optimization.5
i = KDF((h0
i = KDF((h1
i )r) and x1
5 We remark that, in order to prove the security of this optimization in the standard
model (without a random oracle), we need to change the ideal functionality for the
random OT such that for every i, the output of the sender is (β0
i )) and
σi
i )), and the output of the receiver is (σi, βσi
(β1
i )). That is,
i
i , x0
, KDF(gβ
i = KDF(gβ0
i = KDF(gβ1
i , x1
14
1| . . .|k0
κ] and K1 = [k1
1| . . .|k1
i ) = G(ksi
i , v1
i ) = (G(k0
i ) ⊕ vsi
i .
i ) ⊕ G(k1
i ). Now, R needs to send only one m-bit element ui = G(k0
i and k1
i ) ⊕ ti ⊕ r), and S recovers G(ksi
5.3 Optimized General OT Extension
In the following, we optimize the m×OT(cid:96) extension protocol of [32], described
in §2.2. Recall, that in the ﬁrst step of the protocol in [32], R chooses a huge
m × κ matrix T = [t1| . . .|tκ] while S waits idly. The parties then engage in a
κ×OTm protocol, where the inputs of the receiver are (ti, ti ⊕ r) where r is its
input in the outer m×OT(cid:96) protocol (m selection bits). After the OT, S holds
ti ⊕ (si · r) for every 1 ≤ i ≤ κ. As described in the appendices of [30, 32],
the protocol can be modiﬁed such that R only needs to choose two small κ × κ
matrices K0 = [k0
κ] of seeds. These seeds are used
as input to κ×OTκ; speciﬁcally R’s input as sender in the i-th OT is (k0
i , k1
i )
and, as in [32], the input of S is si. To transfer the m-bit tuple (ti, ti ⊕ r) in
the i-th OT, R expands k0
i using a pseudo-random generator G, sends
i ) ⊕ ti, G(k1
(v0
Our main observation is that, instead of choosing ti randomly, we can set ti =
i ) ⊕ r
G(k0
to S (whereas in previous protocols of [30, 32] two m-bit elements were sent).
Observe that if S had input si = 0 in the i-th OT, then it can just deﬁne its
output qi to be G(k0
i ). In contrast, if S had input si = 1 in the i-
i ) ⊕ ui. Since
th OT, then it can deﬁne its output qi to be G(k1
i )⊕r = ti⊕r, as required.
ui = G(k0
The full description of our protocol is given in Protocol 52. This optimization
is signiﬁcant in applications of m×OT(cid:96) extension where m is very large and (cid:96)
is short, such as in GMW. In typical use-cases for GMW (cf. §7), m is in the
size of several millions to a billion, while (cid:96) is one. Thereby, the communication
complexity of GMW is almost reduced by half.
In addition, as in [30], observe that unlike [32] the initial OT phase in Protocol 52
is completely independent of the actual inputs of the parties. Thus, the parties
can perform the initial OT phase before their inputs are determined.
Finally, another problem that arises in the original protocol of [32] is that the
entire m× κ matrix is transmitted together and processed. This means that the
number of OTs to be obtained must be predetermined and, if m is very large,
this results in considerable latency as well as memory management issues. As
in [24], our optimization enables us to process small blocks of the matrix at a
time, reducing latency, computation time, and memory management problems.
In addition, it is possible to continually extend OTs, with no a priori bound
on m. This is very useful in a secure computation setting, where parties may
interact many times together with no a priori bound.
i )⊕G(k1
i )⊕r, we have that G(k1
i )⊕ui = G(k0
i ) ⊕ ui = G(ksi
Theorem 53 Assuming that G is a pseudorandom generator and H is a corre-
lation-robust function (as in Deﬁnition A2), Protocol 52 privately-computes the
m×OT(cid:96)-functionality in the presence of semi-honest adversaries, in the κ×OTκ-
hybrid model.
in addition to receiving their input and output from the random OT functionality, the
parties receive the “discrete log” of the pertinent values. This additional information
is of no consequence in our applications of random OT.
15
PROTOCOL 52 (General OT extension protocol)
j , x1
seeds {(k0
j ) of (cid:96)-bit strings, for every 1 ≤ j ≤ m. R
Inputs: S holds m pairs (x0
holds m selection bits r = (r1, . . . , rm).
Initial OT Phase (base OTs):
1. S choose a random string s = (s1, . . . , sκ) and R chooses κ pairs of κ-bits
2. The parties invoke the κ×OTκ-functionality, where S plays the receiver with
i ) for every 1 ≤ i ≤ κ.
3. For every 1 ≤ i ≤ κ, let ti = G(k0
i ). Let T = [t1| . . .|tk] denote the m × κ
bit matrix where the i-th column is ti, and let tj denote the j-th row of T ,
for 1 ≤ j ≤ m.
input s and R plays the sender with inputs (k0
i )}κ
i , k1
i , k1
i=1.
i ) and ui = ti ⊕ G(k1
OT extension Phasea:
1. R computes ti = G(k0
every 1 ≤ i ≤ κ.
2. For every 1 ≤ i ≤ κ, S deﬁnes qi = (si · ui) ⊕ G(ksi