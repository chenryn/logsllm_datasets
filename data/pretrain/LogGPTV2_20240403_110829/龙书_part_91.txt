例8.11
旦是，如果 b 和 α 都在出口处活跃，我们就必须使用第四个语句把值从一个变量复制到另--个。
在编译时刻对算术表达式求值时，必须使用和运行时刻相同的求值方法。K.Thompson 给出了一个很完美的解决
总的来说，在从 DAG 生成代码时我们必须非常小心地处理变量的名字。如果变量被定值两次，或者虽然只赋值
另一类代数优化是局部强度消减(reduction in strength），就是把一个代价较高的运算替换为
在 DAG上消除死代码的操作可以按照如下方式实现。我们从一个 DAG上删除所有没有附
344
第三种相关的优化是常量合并（constant folding）。使用这种方法时，我们在编译时刻对常量
代数恒等式表示基本块的另一-类重要的优化方法。
译器就不需要另带一-个解析器。
方法：对常量表达式进行编译，在目标机上执行目标代码，然后把表达式替换为执行结果。按照这样的做法，缤
--次但初始值x被使用过，那么必须保证不会在原先存放：值的结点被全部使用之前改变的值。
1
11
P
P
如果图 8-13 中的 a 和b 是活跃变量，而 c 和é 不是，我们可以立刻消除标记为 e 的
当我们寻找公共子表达式的时候，我们实际
C
代价较高的
=×I=[×x 
x/2
Xx
：因此，表达式2＊3.14 可以被替换为6.28。
代价较低的
x
x0.5
x+x
xxx
比如，我们可以使用诸如
x/1 =x
x-0=x
图8-13
bn
+
例8.11 中的基本块的 DAG
Cn
第8章
门
---
## Page 361
的三个子结点分别表示a。、j和Y。没有变量用这个结点标号。不同之处在于此结点的创建杀
个结点的标号之一。
的结点表示。这个结点的左右子结点分别代表数组初始值(本例中是 a。）和下标i。变量×是这
不合法的。
z=x。然而，因为j可能等于i，中间的语句可能实际上改变了a[i]的值。因此，这种优化是
看起来好像是一个公共子表达式。在这种情况下，我们可能会把第三个指令=a［i]优化为
序列：
8.5.5数组引用的表示
语言表达式中哪些地方有括号。
式计算α+（b－c)。因此，如果一-个 Fortran 编译器想按照语言的定义来优化程序，它必须跟踪源
说，编译器可以通过任意数学上等价的表达式来求值，前提是不能违反原来表达式的括号的一致
机算术(因为上溢或下溢等原因)可能不一定遵守数学上的代数恒等式。比如，Fortran 语言标准
生成一个 DAG 结点。
可以通过将参数相减并测试由减法运算设置的条件代码来测试。因此，对－y和x>y，只需要
M的结点。
然而，因为＊是可交换的，所以我们还应该检查是否存在-一个标记为＊且左右子结点分别是N
个标记为＊且左右子结点分别是 M和N的新结点时，我们总是检查这样的结点是否已经存在。
和结合律等。比如，假设语言的参考手册确定＊是可交换的，也就是说，*y=*x。在创建
在实践中，因为在程序中频繁使用符号常量，所以会出现常量表达式。
代码生成
D
①
 2）对数组的赋值（比如 a[j］=y)用--个新创建的运算符为[］=的结点来表示。这个结点
初看上去，数组下标指令似乎可以像其他的运算那样处理。比如，考虑下列的三地址指令
结合律也可以用于揭示公共子表达式。比如，如果源程序中包含如下的赋值语句：
《和=这样的关系运算符有时会产生意料之外的公共子表达式。比如，条件表达式x〉y也
）即不能跨越括号求值——译者注。
1）从一个数组取值并赋给其他变量的运算（比如x=a[i])用一个新创建的运算符为=[
在 DAG 中，表示数组访问的正确方法如下。
如果我们把 a[i]当作是一个和α+i类似的关于a和i 的普通运算，那么 a[i]的两次使月
编译器的设计者应该仔细阅读语言的参考手册，以决定可以重新排列哪些计算。因为计算
：然而，减法运算可能引起上溢或下溢，而比较指令不会引起这个问题。
N
p
如果t没有在基本块之外使用，通过应用+的交换律和结合律，我们可以把这个序列改为：
则可能生成下面的中间代码：
= a[i]
=b+
+9=
345
用
---
## Page 362
的调用不仅使用了以×为附加变量的结点，还杀死了这个结点。
程调用使用和改变了它访问的所有数据。因此，如果变量×在一个过程P的访问范围之内，对P
不需要杀死其他结点。
我们知道是 x(而不是其他变量)被赋予y的值。因此，我们只需要杀死以×为附加变量的结点,
序列
制在一个较小的子集内。即使是局部分析也可以限制一个指针指向的范围。比如，对于下面的
把至今为止构造出来的DAG中的其他结点全部杀死。
标识符的结点当作其参数。但是这么做会影响死代码的消除过程。更加重要的是，*=运算符会
量的使用，而*α=Y可能对任意一个变量赋值。其结果是，运算符=＊必须把当前所有带有附加
那样，通过指针进行间接赋值时，我们并不知道p 和g 指向哪里。从效果看，x=*p 是对任意变
8.5.6指针赋值和过程调用
点的结点都把 a。作为孙结点，而不是子结点。
我们在图8-15 中看到的，被杀的结点和杀死被杀结
b[j］=y杀死带有附加变量×的结点。然而，正如
位置。因此，很重要的一件事情就是让第三个指令
i 表示同一个值，那么b[i]和b[]代表了同一
个字节，那么b代表了a的第四个元素。如果j
这里的情况是，为了效率方面的原因，b被定值为数
以杀死别的结点。例如考虑下面的三地址代码
也必须被杀死。类似地，如果一个结点具有数组后代，即使它的子结点都不是数组结点，它也可
例8. 14
一个具有同样的运算分量a。和i。的新结点。
的结点被建立时，它不会被认为和N等同，而是必须创建
当标号为[］=的结点被创建时，N就被杀死了。因此当z
的 DAG 见图8-14。对应于x的结点 N首先被创建，但是
例8.13
也就是说，它不可能成为--个公共子表达式。
死了所有当前已经建立的，其值依赖于a。的结点。一个被杀死的结点不可能再获得任何标号。
过程调用和通过指针赋值很相似。在缺乏全局数据流信息的情况下，我们必须假设一个过
我们可以进行一些全局指针分析，以便把-个指针在代码中某个位置上可能指向的变量限
.a中的一个位置。例如，如果a 的元素长度是
346
当我们像下面的赋值语句
[j]
= y
[1]q
a[i]
11
 有时即使某个结点的所有子结点都没有像例8.13 中的a。那样的附加数组变量，它
基本块
口
和
图8-15即使没有把一个数组作为子结点，
一个结点也可能杀死对该数组的使用
图8-14
+
被杀死
"-个数组赋值序列的 DAG
10
10
jc
jo
第8章
---
## Page 363
在两个使用同一个数组的指令都是数组访问而不是对数组元素赋值时，它们才可以交换顺序。
的求值运算之后。
的赋值运算即可。
后。对同一数组的两个求值运算可以交换顺序，只要在交换时它们都没有越过某个对同一数组
或求值运算之后。
结点的值之后，才可以计算这个结点的值。
计算不同结点值的指令的顺序。应记住如下规则：
赖于程序如何重新计算d的值。
这种情况下，我们就可以再次回到这个基本块并消除b=α。直观地讲，如果在任何使用b 的这
局分析把此基本块外对b 的使用全部替换为对 α 的使用，从而消除在基本块外对b 的使用。在
要计算α和b 的值。我们可以用下面的序列来完成这个计算：
优化的基本块不会计算b 的值。
就足以重建那个基本块了。第三个指令c=α+c 必须使用α 而不是b 作为运算分量，因为经过
口处不活跃，那么下面的三个语句
例8.15
的值。有时我们可以通过全局优化技术，设法用其中的一两个变量来替代其他变量，从而消除这
是不包含编译器为了处理表达式而生成的临时变量)。
果我们没有全局活跃变量的信息作为依据，就要假设程序的所有变量都在基本块出口处活跃（但
某个变量的值。我们倾向于把计算得到的结果赋给一个在基本块出口处活跃的变量。但是，如
的三地址代码。对每个具有一个或多个附加变量的结点，我们构造一个三地址语句来计算其中
的运算完成。在完成这些优化处理之后，我们就可以根据优化得到的 DAG 重组生成相应基本块
8. 5. 7 从 DAG 到基本块的重组 
也就是说，当重组代码的时候，没有一个语句可以跨越过程调用或指针间接赋值运算。只有
1）指令的顺序必须遵守 DAG 中的结点的顺序。也就是说，只有在计算出一个结点的各个子
值的时刻，d中的值仍然和b一样，那么我们就可以消除这个复制运算。这种情况是否成立依
3）对数组元素的求值必须跟在所有(在原基本块中)在它之前的对同一数组的赋值指令之
如果b 和α都在出口处活跃，或者我们不能够确定它们是否在出口处活跃，那么我们还是需
复制语句。
对 DAG 的各种优化处理可以在生成 DAG 图时进行，也可以在 DAG 构造完成后通过对 DAG
代码生成
 2）对数组的赋值必须跟在所有(按照原基本块中的指令顺序)在它之前的对同一数组的赋值
当从 DAG 重构基本块时，我们不仅要关心用哪些变量来存放 DAG 中的结点的值，还要关心
4）一个变量的使用必须跟在所有(在原基本块中)在它之前的过程调用和指针间接赋值运算之后。
如果结点有多个附加的活跃变量，我们就必须引人复制语句，以便给每-一个变量都赋予正确
这个基本块仍然比原来的基本块高效。虽然指令数目相同，但我们已经把一个减法替换为
P
+c
P-
回顾一-下图8-12 中的 DAG。在例8.10 后面的讨论中，我们确定如果b 在基本块的出
347
一
依
---
## Page 364
使用方法：
8.6一个简单的代码生成器
使得指令个数最少。
里，语句é=*p 都可以被替换为é=C。请修正 DAG 构造算法以利用这种情况带来的好处，并
码中，因为 p 可能指向的所有位置在第二个和第四个语句之间没有被赋值，所以不管 p 指向哪
构造 DAG 图。假设如下：
者注）
8.5.88.5节的练习
把你的算法应用到练习8.5.6的代码中。
值和使用之间没有做任何修改，我们就可以利用这种情况来简化DAG。比如，在练习8.5.6 的代
在代码生成中的主要问题之一是决定如何最大限度地利用寄存器。寄存器有如下四种主要
在本节中，我们将考虑一个为单个基本块生成代码的算法。它依次考虑各个三地址指令，并
348
●在大部分机器的体系结构中，执行一个运算时该运算的部分或全部运算分量必须存放在
2）假设×和都在基本块的出口处活跃，利用加法的结合律和交换律来修改这个基本块，
练习8.5.8：假设一个基本块由下面的C语言赋值语句生成：
！练习8.5.7：如果一个指针或数组表达式（比如 a[i]或者*p)被赋值之后又被使用，且赋
1）p可以指向任何地方。
2）p 只能指向b或d。
*p = a[i]
e = *p
a[i]= b
练习8.5.6：分别按照下面的两个假设，为基本块