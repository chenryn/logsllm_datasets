# 读文件    f = open(filePath,'rb')    data = []    
# 得到图像的像素值    img = image.open(f)    
# 得到图像尺寸    width, height = img.size    for x in range(width):        for y in range(height):            
# 得到点 (x,y) 的三个通道值            c1, c2, c3 = img.getpixel((x, y))            data.append([c1, c2, c3])    f.close()    
# 采用 Min-Max 规范化    mm = preprocessing.MinMaxScaler()    data = mm.fit_transform(data)    return np.mat(data), width, height因为 jpg 格式的图像是三个通道 (R,G,B)，也就是一个像素点具有 3个特征值。这里我们用 c1、c2、c3 来获取平面坐标点 (x,y)的三个特征值，特征值是在 0-255 之间。为了加快聚类的收敛，我们需要采用 Min-Max规范化对数据进行规范化。我们定义的 load_data 函数返回的结果包括了针对(R,G,B) 三个通道规范化的数据，以及图像的尺寸信息。在定义好 load_data函数后，我们直接调用就可以得到相关信息，代码如下：    
# 加载图像，得到规范化的结果 img，以及图像尺寸img, width, height = load_data('./weixin.jpg')假设我们想要对图像分割成 2 部分，在聚类阶段，我们可以将聚类数设置为2，这样图像就自动聚成 2 类。代码如下：    
# 用 K-Means 对图像进行 2 聚类kmeans =KMeans(n_clusters=2)kmeans.fit(img)label = kmeans.predict(img)
# 将图像聚类结果，转化成图像尺寸的矩阵label = label.reshape([width, height])
# 创建个新图像 pic_mark，用来保存图像聚类的结果，并设置不同的灰度值pic_mark = image.new("L", (width, height))for x in range(width):    for y in range(height):        
# 根据类别设置图像灰度, 类别 0 灰度值为 255， 类别 1 灰度值为 127        pic_mark.putpixel((x, y), int(256/(label[x][y]+1))-1)pic_mark.save("weixin_mark.jpg", "JPEG")代码中有一些参数，我来给你讲解一下这些参数的作用和设置方法。我们使用了 fit 和 predict这两个函数来做数据的训练拟合和预测，因为传入的参数是一样的，我们可以同时进行fit 和 predict 操作，这样我们可以直接使用 fit_predict(data)得到聚类的结果。得到聚类的结果 label后，实际上是一个一维的向量，我们需要把它转化成图像尺寸的矩阵。label的聚类结果是从 0 开始统计的，当聚类数为 2 的时候，聚类的标识 label=0或者 1。如果你想对图像聚类的结果进行可视化，直接看 0 和 1 是看不出来的，还需要将0 和 1 转化为灰度值。灰度值一般是在 0-255 的范围内，我们可以将 label=0设定为灰度值 255，label=1 设定为灰度值 127。具体方法是用int(256/(label\[x\]\[y\]+1))-1。可视化的时候，主要是通过设置图像的灰度值进行显示。所以我们把聚类label=0 的像素点都统一设置灰度值为 255，把聚类 label=1的像素点都统一设置灰度值为 127。原来图像的灰度值是在 0-255之间，现在就只有 2 种颜色（也就是灰度为 255，和灰度 127）。有了这些灰度信息，我们就可以用 image.new 创建一个新的图像，用 putpixel函数对新图像的点进行灰度值的设置，最后用 save函数保存聚类的灰度图像。这样你就可以看到聚类的可视化结果了，如下图所示：![](Images/f87560f9e4352a47169069341d8610bf.png){savepage-src="https://static001.geekbang.org/resource/image/94/6b/9420b9bedf2e3514b0624543a69fb06b.png"}\上面是分割成 2个部分的分割可视化，完整代码见[这里](https://github.com/cystanford/kmeans/blob/master/kmeans1.py)。如果我们想要分割成 16个部分，该如何对不同分类设置不同的颜色值呢？这里需要用到 skimage工具包，它是图像处理工具包。你需要使用 pip install scikit-image来进行安装。这段代码可以将聚类标识矩阵转化为不同颜色的矩阵：    from skimage import color
# 将聚类标识矩阵转化为不同颜色的矩阵label_color = (color.label2rgb(label)*255).astype(np.uint8)label_color = label_color.transpose(1,0,2)images = image.fromarray(label_color)images.save('weixin_mark_color.jpg')代码中，我使用 skimage 中的 label2rgb 函数来将 label分类标识转化为颜色数值，因为我们的颜色值范围是 \[0,255\]，所以还需要乘以255 进行转化，最后再转化为 np.uint8 类型。unit8类型代表无符号整数，范围是 0-255 之间。得到颜色矩阵后，你可以把它输出出来，这时你发现输出的图像是颠倒的，原因可能是图像源拍摄的时候本身是倒置的。我们需要设置三维矩阵的转置，让第一维和第二维颠倒过来，也就是使用transpose(1,0,2)，将原来的 (0,1,2）顺序转化为 (1,0,2)顺序，即第一维和第二维互换。最后我们使用 fromarray 函数，它可以通过矩阵来生成图片，并使用 save进行保存。最后得到的分类标识颜色化图像是这样的：![](Images/b2f90eec93da2296050b972a99840b26.png){savepage-src="https://static001.geekbang.org/resource/image/d2/b7/d26df5f1ed26cca53118a99aa04484b7.png"}\完整的代码见[这里](https://github.com/cystanford/kmeans/blob/master/kmeans2.py)。刚才我们做的是聚类的可视化。如果我们想要看到对应的原图，可以将每个簇（即每个类别）的点的RGB 值设置为该簇质心点的 RGB 值，也就是簇内的点的特征均为质心点的特征。我给出了完整的代码，代码中，我可以把范围为 0-255 的数值投射到 1-256数值之间，方法是对每个数值进行加 1，你可以自己来运行下：    
# -*- coding: utf-8 -*-