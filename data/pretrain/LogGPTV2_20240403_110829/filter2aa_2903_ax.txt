R0～R30：共31个，既可以使用X0～X30这样的名称访问寄存器的
全部64位，也可以用W0～W30这样的名称只使用低32位。其中R29
一般用作栈帧指针（Frame Pointer，FP），R30用作函数返回地
址，简称LR。
SP：64位宽，专用作栈指针，也可以通过WSP访问低32位。
PC：程序指针，64位。
V0～V31：共32个，供SIMD和浮点数用途，128位，既可以使用Q0
～Q31访问完整的128位，也可以通过D0～D31、S0～S31、H0～
H31或者B0～B31访问低64位、32位、16位或者8位。
PSR（PState）：程序状态寄存器，仍为32位。
图2-23所示的是运行在AArch64状态的Windows 10的一个执行现
场，从中可以看到上面介绍的大部分寄存器（不包括V0～V31）。
图2-23 ARM64执行现场
在内存管理方面，VMSAv8是ARMv8定义的虚拟内存系统架构，包
括VMSAv8-64和VMSAv8-32两套分页格式。其中VMSAv8-64是
AArch64状态下使用的主要格式，其主要特征如下。
最多4级页表。
输入地址最多为48位，输出地址也是最多为48位，即虚拟地址空间
和物理地址空间都为256TB。
支持的页大小有4KB、16KB和64KB。
VMSAv8-64实际上是32位下的LPAE格式的进一步扩展，这与x64
的分页格式是对32位x86的PAE格式的扩展如出一辙，不再赘述。
 老雷评点  
翻阅ARM手册，时常见x86的影子，此亦常理。
尽管本节花了较大篇幅介绍ARM架构，但是所涵盖的内容仍只是
纷繁复杂的ARM架构的一小部分。如果大家希望系统学习ARM架构，
那么ARM手册是很好的学习材料。推荐大家先阅读v7版本，因为v8版
本过于冗长，有5700多页，是v7版本（2700多页）的2倍还多。ARMv7
手册分为四篇：A篇名为《应用层架构》，介绍应用程序开发的基础知
识，相当于IA手册的卷1；B篇名为《系统层架构》，介绍开发系统软
件（操作系统）所需了解的深入内容，相当于IA手册的卷3；C篇名为
《调试架构》，介绍调试有关的机制；D篇为附录。
2.10 本章小结
很多软件工程师对硬件了解得太少，甚至不愿意去学习硬件知识，
事实上，了解必要的硬件知识对理解软件经常会起到事半功倍的效果，
扎实的硬件基础对于软件工程师来说也是非常重要的。
本章首先介绍了指令集和指令的执行过程（见2.1节），而后介绍
了IA-32处理器的发展历程和主要功能（见2.2节）。2.3节介绍了CPU的
操作模式和每种操作模式的基本特征和用途。2.4节介绍了IA-32 CPU的
寄存器。2.5节介绍了保护模式的内涵和主要保护机制。2.6节和2.7节详
细介绍了保护模式下的内存管理机制。2.8节介绍了个人计算机系统的
基本架构。2.9节概述了ARM架构的基础知识。
虽然本章的部分内容与软件调试没有直接的关系，但是这些内容对
于理解计算机系统的底层原理和进行系统级调试有着重要意义，是成为
软件调试高手必须掌握的基础内容。下一章将介绍CPU的中断和异常机
制。
参考资料
[1] Jack Doweck. Inside Intel Core™ Microarchitecture and Smart
Memory Access: An In-Depth Look at Intel Innovations for Accelerating
Execution of Memory-Related Instructions. Intel Corporation, 2006.
[2] 毛德操, 胡希明. 嵌入式系统——采用公开源码和
StrongARM/Xscale处理器[M]. 杭州：浙江大学出版社, 2003.
[3] IA-32 Intel Architecture Software Developer’s Manual Volume 1.
Intel Corporation.
[4] IA-32 Intel Architecture Software Developer’s Manual Volume
2A. Intel Corporation.
[5] IA-32 Intel Architecture Software Developer’s Manual Volume
2B. Intel Corporation.
[6] IA-32 Intel Architecture Software Developer’s Manual Volume 3.
Intel Corporation.
[7] INTEL 80386 PROGRAMMER’S REFERENCE MANUAL. Intel
Corporation.
[8] Tom Shanley. The Unabridged Pentium 4: IA-32 Processor
Genealogy[M]. Boston: Addison Wesley, 2004.
[9] P6 Family of Processors: Hardware Developer’s Manual. Intel
Corporation.
[10] Intel Sandy Bridge Review. bit-tech网站.
[11] Intel’s Haswell CPU Microarchitecture. realworldtech网站.
[12] ARM Architecture Reference Manual: ARMv7-A and ARMv7-R
edition (Chapter B3 Virtual Memory System Architecture (VMSA)) (B3-
1307). ARM Holdings.
[13] A Tour of the P6 Microarchitecture. Intel Corporation.
第3章 中断和异常
当形容一个人固执不知变通时，人们会说他“死心眼，顺着一条路
跑到天黑”，用这句话来描述CPU也非常恰当。因为无论把CPU的指令
指针（IP）指向哪个内存地址，它都会试图执行那里的指令，执行完一
条，再取下一条执行，如此往复。为了让CPU能够暂时停下当前的任
务，转去处理突发事件或其他需要处理的任务，人们设计了中断
（interrupt）和异常（exception）机制。
在计算机系统中，包括任务切换、时间更新、软件调试在内的很多
功能都是依靠中断和异常机制实现的。毫不夸张地说，中断和异常是计
算机原理中最重要的概念之一，充分理解中断和异常是理解CPU和系统
软件的关键。
本章先介绍x86架构的中断和异常（见3.1～3.5节），然后再扩展到
ARM架构（见3.6节）。
 老雷评点 
中断机制的出现是计算机历史上的一个重要里程碑，有了中
断后，才有了以处理中断为核心任务的系统软件，才有了专门为
系统软件开辟的内核空间，进而才确立了软件世界之二分格局。
3.1 概念和差异
本节将先介绍中断和异常的概念，帮助读者了解其基本特征，然后
比较它们之间有什么不同。
3.1.1 中断
中断通常是由CPU外部的输入输出设备（硬件）所触发的，供外部
设备通知CPU“有事情需要处理”，因此又称为中断请求（interrupt
request）。中断请求的目的是希望CPU暂时停止执行当前正在执行的程
序，转去执行中断请求所对应的中断处理例程（Interrupt Service
Routine，ISR）。
考虑到有些任务是不可打断的，为了防止CPU这时也被打扰，可以
通过执行CLI指令清除标志寄存器的IF位，以使CPU暂时“不受打扰”。
但有个例外，这样做只能使CPU不受可屏蔽中断的打扰，一旦有不可屏
蔽中断（Non-Maskable Interrupt，NMI）发生时，CPU仍要立即转去处
理。不过因为NMI中断通常很少发生，而且不可打断代码通常也比较
短，所以大多数情况下还是不存在问题的。可屏蔽中断请求信号通常是
通过CPU的INTR引脚发给CPU的，不可屏蔽中断信号通常是通过NMI引
脚发给CPU的。
中断机制为CPU和外部设备间的通信提供了一种高效的方法，有了
中断机制，CPU就可以不用去频繁地查询外部设备的状态了，因为当外
部设备有“事”需要CPU处理时，它可以发出中断请求通知CPU。但是如
果有太多的设备都向CPU发送请求，那么也会导致CPU频繁地在各个中
断处理例程间“奔波”，从而影响正常程序的执行。这好比我们通常只把
手机号码公开给熟悉的人，不然就可能会被频繁的来电“中断”正常的工
作。从这个意义上讲，中断是计算机系统中非常宝贵的资源。如果为某
个设备分配了中断资源，那么便赋予了它随时打断CPU的权力。
在硬件级，中断是由一块专门芯片来管理的，通常称之为中断控制
器（Interrupt Controller）。它负责分配中断资源和管理各个中断源发出
的中断请求。为了便于标识各个中断请求，中断管理器通常用
IRQ（Interrupt ReQuest）后面加上数字来表示不同路（line）的中断请
求信号，比如IRQ0、IRQ1等。根据从最初的个人计算机（IBM PC）系
统传承下来的约定，IRQ0通常是分配给系统时钟的，IRQ1通常是分配
给键盘的，IRQ3和IRQ4通常是分配给串口１和串口2的，IRQ6通常是分
配给软盘驱动器的。
图3-1所示的是作者使用的系统中各个中断请求号的分配情况。从
中可以看出，IRQ0、IRQ1、IRQ4和IRQ6的用途仍然与最初PC系统的用
途是一致的。IRQ9则是由很多个设备所共享的，这是因为PCI总线标准
支持多个PCI设备共用一个中断请求信号。
图3-1 中断请求（IRQ）号的分配情况
3.1.2 异常
与中断不同，异常通常是CPU在执行指令时因为检测到预先定义的
某个（或多个）条件而产生的同步事件。
异常的来源有3种。第一种来源是程序错误，即当CPU在执行程序
指令时遇到操作数有错误或检测到指令规范中定义的非法情况。前者的
一个典型例子是执行除法指令时遇到除数为零，后者的典型例子包括在
用户模式下执行特权指令等。第二种来源是某些特殊指令，这些指令的
预期行为就是产生相应的异常，比如INT 3指令的目的就是产生一个断
点异常，让CPU中断（break）进调试器。换句话说，这个异常是“故
意”产生的，是预料内的。这样的指令还有INTO、INT n和BOUND。第
三种来源是奔腾CPU引入的机器检查异常（Machine Check
Exception），即当CPU执行指令期间检测到CPU内部或外部的硬件错
误，详细内容参见第6章。
3.1.3 比较
至此，我们可以归纳出中断和异常的根本差异是：异常来自于CPU
本身，是CPU主动产生的；而中断来自于外部设备，是中断源发起的，
CPU是被动的。
对于机器检查异常，虽然有时是因为外部设备通过设置CPU的特殊
管脚（BUSCHK#或BINIT#和MCERR#）触发的，但是从产生角度来
看，仍然是CPU检测到管脚信号然后产生异常的，所以机器检查异常仍
然是在CPU内部产生的。
在很多文献和书籍中，尤其是在早期的资料中，把由INT n指令产
生的异常称为软件中断（software interrupt），把来自外部硬件的中断
（包括可屏蔽中断和不可屏蔽中断）称为外部中断。尽管今天仍然有很
多地方使用这种说法，但是大家应该意识到，严格来说，INT n导致的
软件中断不是中断而是异常。因为INT n指令的行为更符合异常的特征
——产生于CPU内部，来源是正在执行的指令本身。在本书中，如不加
特殊说明，中断就是指来自CPU外部的硬件中断。
3.2 异常的分类
根据CPU报告异常的方式和导致异常的指令是否可以安全地重新执
行，IA-32 CPU把异常分为3类：错误（fault）、陷阱（trap）和中止
（abort）。
3.2.1 错误类异常
导致错误类异常的情况通常可以被纠正，而且一旦纠正后，程序可
以无损失地恢复执行。此类异常的一个最常见例子就是第2章提到的缺
页异常。缺页异常是虚拟内存机制的重要基础，有时也称为页错误异常
或者缺页错误。为了节约物理内存空间，操作系统会把某些暂时不用的
内存以页为单位交换到外部存储器（通常是硬盘）上。当有程序访问到
这些不在物理内存中的页所对应的内存地址时，CPU便会产生缺页异
常，并转去执行该异常的处理程序，后者会调用内存管理器的函数把对
应的内存页交换回物理内存，然后再让CPU返回到导致该异常的那条指
令处恢复执行。当第二次执行刚才导致异常的指令时，对应的内存页已
经在物理内存中（错误情况被纠正），因此就不会再产生缺页异常了。
在Windows这样的操作系统中，缺页异常每秒钟都发生很多次。在
Windows系统中按Ctrl + Shift + Esc组合键，打开任务管理器，显示出PF
Delta列（选择View→Select Columns），便可以观察缺页异常的发生情
况。PF Delta值的含义是两次更新间的新增次数，默认每秒钟更新一
次。图3-2是作者在分析淘宝客户端软件（AliPay）时做的一个截图，图
中是按Page Faults列排序的，该列代表的是对应进程中缺页异常的累计
发生次数，位列前三名的分别是AlipaySecSvc、AlipayBsm和
TaobaoProtect，全都是AliPay软件的成员。
图3-2 观察缺页异常的发生情况
因为处理每次Page Faults时要执行比较复杂的逻辑，所以高的Page
Faults也常常意味着比较高的CPU使用率。在图3-2中，AlipaySecSvc进
程使用的CPU总时间高达1小时20分32秒。
当CPU报告错误类异常时，CPU将其状态恢复成导致该异常的指令
被执行之前的状态。而且在CPU转去执行异常处理程序前，在栈中保存
的CS和EIP指针是指向导致异常的这条指令的（而不是下一条指令）。
因此，当异常处理程序返回继续执行时，CPU接下来执行的第一条指令
仍然是刚才导致异常的那条指令。所以，如果导致异常的情况还没有被
消除，那么CPU会再次产生异常。
3.2.2 陷阱类异常
下面再来看陷阱类异常。与错误类异常不同，当CPU报告陷阱类异
常时，导致该异常的指令已经执行完毕，压入栈的CS和EIP值（即异常
处理程序的返回地址）是导致该异常的指令执行后紧接着要执行的下一
条指令。值得说明的是，下一条指令并不一定是与导致异常的指令相邻
的下一条。如果导致异常的指令是跳转指令或函数调用指令，那么下一
条指令可能是内存地址不相邻的另一条指令。
导致陷阱类异常的情况通常也是可以无损失地恢复执行的。比如
INT 3指令导致的断点异常就属于陷阱类异常，该异常会使CPU中断到
调试器（见4.1节），从调试器返回后，被调试器程序可以继续执行。
3.2.3 中止类异常