public database vulnerabilities. We present a more detailed
comparison of our results with [31] for public attacks in Ap-
pendix B.1, then present our new private database attacks
for those apps.
In summary, in these apps which are originally analyzed
for public database attacks, we found all three combinations
of public and private attacks to be possible (public and pri-
vate alone, and also combined). Furthermore, combining
public and private vulnerabilities can mean more sophisti-
cated and complex attacks.
Table 2: Database vulnerabilities in representative apps of [31]: [31]
only deals with public databases, the private column is new. Column
three shows the closest APK version we could ﬁnd.
It is marked
with “+” if has been updated since the publication of
[31]. Column
four and ﬁve show the minimum and target SDK for which an app is
compiled respectively. The last two columns show our ﬁndings for the
public and private database attacks. In the public column, “” means
there is still a public database vulnerability, while blank means it is
ﬁxed. In the Private column, if we ﬁnd a private vulnerability we use
“” (not considered by [31]) and blank otherwise. We use “-” if the
dynamic testing could not be done due to some runtime issue (e.g.,
requires registering a valid phone number.)
ID App Name
Version SDKM SDKT Public Private
3.6.0 +
4.6.7 +
3.7.7 +
13
11
-
7
8
5




8
5
14
4
15
14
11
5
8
14
8
7
9
4
7
5
14
10

-
-

-
-



-










18
-
22
-
21
19
19
-
10
17
21
7
23
-
-
-
23
-
1
2
3
4
5
6
7
8
Pansi SMS
Youni SMS
mOffice -
Outlook sync
Shady SMS 4.0
PAYG
360 Kouxin
GO SMS Pro
Messenger
WithYou
Nimbuzz
Messenger
MiTalk Messenger
3.38 +
1.5.0
7.0.3 +
2.0.90 +
4.1.0 +
9
7.3.32 +
10 Youdao Dictionary 6.5.1 +
11 GO FBWidget
12 Netease Weibo
13 Dolphin Browser
2.4.0 +
11.5.3 +
2.2
HD
14 Maxthon Android
Web Browser
15 Boat Browser Mini
16 Mobile Security
4.5.8.
2000 +
3.0.2
7.0 +
Personal Ed.
17 Droid Call Filter
18 Tc Assistant
19 GO TwiWidget
20 Sina Weibo
21 Tencent WBlog
1.0.23
4.5.0 +
2.1
6.3.1 +
6.1.2 +
7. RELATED WORK
In the past few years, many diﬀerent aspects of Android
security have been studied. Even though many works aim
to detect vulnerabilities in benign apps [11, 7, 13, 1, 21],
few works also try to exploit them. Database vulnerabili-
ties which may compromise the security of system has been
partially studied in [31, 21].
ContentScope [31] is the ﬁrst work on public database
vulnerabilities for Android apps.
It ﬁnds public database
vulnerabilities in Android apps built for the Android SDK
16 or lower in which the content provider components are
by default accessible by other apps on the phone. Our work
considers the new class of private database vulnerabilities
and the corresponding attacks. Another diﬀerence is that
we focus on apps whose SDK target is 17 and higher where
the default assumption has been changed to reduce the oc-
curence of public database attacks. We only analyze the
representative apps in [31] which have lower SDK targets
under their lower SDK assumption to compare our results
with ContentScope. We also propose a framework for anal-
ysis of public and private database vulnerabilities with the
key being modelling of URI semantics and other Android
libraries to help symbolic execution.
CHEX [21] is an information ﬂow analysis tool which is
tailored to detect component hijacking vulnerabilities in be-
nign Android apps. Component hijacking attacks happen
when an unauthorized app, issuing requests to one or more
exported components in a vulnerable app, seeks to read or
write sensitive data. CHEX reports the potential vulnera-
bilities pertaining to the private databases. Compared to
this work, our analysis system takes one step further and
generates working exploits for the detected vulnerabilities.
Privacy leakage and privilege escalation [9] attacks are two
more broad classes of attacks that have attracted researchers
during the past few years. Privacy leakage might happen as
the result of over-privileged malware or privilege escalation
attacks due to application bugs or ﬂaws in the system design.
A few systems have been proposed to mitigate these classes
of attacks [24, 10, 2, 22, 15, 30, 28, 16]. Where the patch-
ing and repackaging works [30, 28, 16] are the closest to our
mitigation approach. Jinseong et al. [16] try to improve the
coarse-grained policies by banning particular data values to
reach a security critical method. However, the analysis used
to determine such data values might not be precise enough.
Our proposed approach utilizes precise analysis such as sym-
bolic execution and only modiﬁes the manifest ﬁle to pro-
vide more ﬁne-grained policy enforcement while [16] needs
to modify the source code of the app.
Android apps often use libraries such as android.net.Uri
to perform operations on structured data. Octeau et al. [23]
propose a constant propagation framework to resolve ﬁelds
of URI and Intent objects at a given program point. How-
ever, our system synthesizes URIs and Intents which drive
the execution of the program along a particular path. More-
over, it is not clear how they handle important operations
such as UriMatcher.match(Uri) or Uri.compareTo(Uri), mod-
eled using SFTs in our work.
There is a body of work which support string manipu-
lation operations statically for diﬀerent applications [25, 8,
17, 26]. We transform the utility methods of URI classes
to SFTs [14, 27] and leverage the CVC4 SMT solver [20].
Another line of research [8, 19, 29] determines the values of
string expressions at a given program point. Our approach
635diﬀers from these works as we intend to generate strings
that drive execution paths to reach a program point. Java
String Analyzer [8] models ﬂow graphs of string operations
to a context-free grammar which is over-approximated to a
ﬁnite state automaton. Instead, we use the existing SMT
solvers which support both numeric and string constraints.
8. CONCLUSION
In this paper, we study the database attacks targeting An-
droid apps and propose an analyzer which can ﬁnd and con-
ﬁrm database vulnerabilities in apps. We show that many
popular Android apps from the Google Play store have pub-
lic and private database vulnerabilities and conﬁrm them by
generating exploits. Even apps which have been previously
reported as having public database vulnerabilities, can still
be vulnerable or exploited in new ways. We also propose
an extension for Android to mitigate the public and private
database attacks. As our extension only requires modiﬁca-
tion to the manifest ﬁle, it can protect apps without having
to ﬁx the vulnerable app code.
9. REFERENCES
[1] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel,
J. Klein, Y. L. Traon, D. Octeau, and P. McDaniel.
FlowDroid: Precise Context, Flow, Field,
Object-sensitive and Lifecycle-aware Taint Analysis
for Android Apps. In PLDI, 2014.
[2] M. Backes, S. Gerling, C. Hammer, M. Maﬀei, and
P. Styp-Rekowsky. AppGuard – Enforcing User
Requirements on Android Apps. In TACAS, 2013.
[3] T. Berners-Lee, R. Fielding, U. Irvine, and
L. Masinter. Uniform Resource Identiﬁers (URI), 8
1998. RFC 2396.
[4] P. Boonstoppel, C. Cadar, and D. R. Engler. RWset:
Attacking Path Explosion in Constraint-Based Test
Generation. In TACAS, 2008.
[5] C. Cadar, D. Dunbar, and D. Engler. KLEE:
Unassisted and Automatic Generation of
High-coverage Tests for Complex Systems Programs.
In USENIX, 2008.
[6] Z. Cai and R. H. C. Yap:. Inferring the detection logic
and evaluating the eﬀectiveness of android anti-virus
apps. In CODASPY, 2016.
[7] P. P. Chan, L. C. Hui, and S. M. Yiu. DroidChecker:
Analyzing Android Applications for Capability Leak.
In WiSec, 2012.
[8] A. S. Christensen, A. Møller, and M. I. Schwartzbach.
Precise Analysis of String Expressions. In SAS, 2003.
[9] L. Davi, A. Dmitrienko, A. Sadeghi, and M. Winandy.
Privilege Escalation Attacks on Android. In ISC, 2010.
[10] M. Dietz, S. Shekhar, Y. Pisetsky, A. Shu, and D. S.
Wallach. Quire: Lightweight Provenance for Smart
Phone Operating Systems. In USENIX, 2011.
[11] M. C. Grace, Y. Zhou, Z. Wang, and X. Jiang.
Systematic Detection of Capability Leaks in Stock
Android Smartphones. In NDSS, 2012.
[12] B. Hassanshahi, Y. Jia, R. H. C. Yap, P. Saxena, and
Z. Liang. Web-to-Application Injection Attacks on
Android: Characterization and Detection. In
ESORICS, 2015.
[13] J. Hoﬀmann, M. Ussath, T. Holz, and
M. Spreitzenbarth. Slicing Droids: Program Slicing for
Smali Code. In SAC, 2013.
[14] P. Hooimeijer, B. Livshits, D. Molnar, P. Saxena, and
M. Veanes. Fast and Precise Sanitizer Analysis with
BEK. In USENIX, 2011.
[15] P. Hornyack, S. Han, J. Jung, S. Schechter, and
D. Wetherall. These Aren’T the Droids You’Re
Looking for: Retroﬁtting Android to Protect Data
from Imperious Applications. In CCS, 2011.
[16] J. Jeon, K. K. Micinski, J. A. Vaughan, A. Fogel,
N. Reddy, J. S. Foster, and T. Millstein. Dr. Android
and Mr. Hide: Fine-grained Permissions in Android
Applications. In SPSM, 2012.
[17] A. Kiezun, V. Ganesh, P. J. Guo, P. Hooimeijer, and
M. D. Ernst. HAMPI: A Solver for String Constraints.
In ISSTA, 2009.
[18] P. Lam, E. Bodden, L. Hendren, and T. U.
Darmstadt. The soot framework for java program
analysis: a retrospective. In CETUS, 2011.
[19] D. Li, Y. Lyu, M. Wan, and W. G. J. Halfond. String
Analysis for Java and Android Applications. In
ESEC/FSE, 2015.
[20] T. Liang, A. Reynolds, C. Tinelli, C. Barrett, and
M. Deters. A DPLL(T) Theory Solver for a Theory of
Strings and Regular Expressions. In CAV, 2014.
[21] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. CHEX:
Statically Vetting Android Apps for Component
Hijacking Vulnerabilities. In CCS, 2012.
[22] M. Nauman, S. Khan, and X. Zhang. Apex: Extending
Android Permission Model and Enforcement with
User-deﬁned Runtime Constraints. In ASIACCS, 2010.
[23] D. Octeau, D. Luchaup, M. Dering, S. Jha, and
P. McDaniel. Composite Constant Propagation:
Application to Android Inter-Component
Communication Analysis. In ICSE, 2015.
[24] M. Ongtang, S. McLaughlin, W. Enck, and
P. McDaniel. Semantically Rich Application-Centric
Security in Android. In ACSAC, 2009.
[25] P. Saxena, D. Akhawe, S. Hanna, F. Mao,
S. McCamant, and D. Song. A Symbolic Execution
Framework for JavaScript. In S&P, 2010.
[26] M.-T. Trinh, D.-H. Chu, and J. Jaﬀar. S3: A Symbolic
String Solver for Vulnerability Detection in Web
Applications. In CCS, 2014.
[27] M. Veanes, P. Hooimeijer, B. Livshits, D. Molnar, and
N. Bjorner. Symbolic Finite State Transducers:
Algorithms and Applications. In CIAA, 2012.
[28] R. Xu, H. Sa¨ıdi, and R. Anderson. Aurasium:
Practical Policy Enforcement for Android
Applications. In USENIX, 2012.
[29] F. Yu, T. Bultan, M. Cova, and O. H. Ibarra.
Symbolic String Veriﬁcation: An Automata-Based
Approach. In MCS, 2008.
[30] M. Zhang and H. Yin. AppSealer: Automatic
Generation of Vulnerability-Speciﬁc Patches for
Preventing Component Hijacking Attacks in Android
Applications. In NDSS, 2014.
[31] Y. Zhou and X. Jiang. Detecting Passive Content
Leaks and Pollution in Android Applications. In
NDSS, 2013.
636APPENDIX
A. OTHER SYMBOLIC MODELS FOR URI-
BASED LIBRARY METHODS
Fig. 3 depicts our model for Uri.compareTo(Uri) as an over-
approximation of this method: it returns 0 if the string rep-
resentations of the two URIs are equal (i.e., transitions reach
the accepting state q7) and 1 otherwise. If the ﬁelds of the
base Uri and the argument Uri are represented by f1,i and
f2,i respectively and ϕ denotes the path constraint computed
so far, ci which is the constraint label of a transition is: f1,i
= f2,i ∧ ϕ. For instance, the transition from the start state,
S, to q1 symbolically represents all possible scheme ﬁelds
in the base URI (f1,1) which match the scheme ﬁeld of the
argument URI (f2,1) and also satisfy the path constraint.
We explain how our symbolic model for Uri.compareTo()
works using an example. If we add the two methods in List-
ing 6 to the PublicDatabase class in Listing 1 which is vul-
nerable to the public database pollution attacks, this class
will also become vulnerable to the public database leakage
attacks. In order to generate working exploits, our analysis
needs to compare the two Uri instances, u1 and u2 at Line
4 in Listing 6. Our symbolic executor ﬁrst creates a sum-