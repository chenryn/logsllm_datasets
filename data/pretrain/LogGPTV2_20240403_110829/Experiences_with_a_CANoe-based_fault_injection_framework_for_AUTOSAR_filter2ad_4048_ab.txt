fault duration) 
and space (e.g., 
would provide  empirical  insight 
six specific 
goals, which are outlined 
below. 
the fault-injection 
• Observabilty. 
The effect(s) 
-or lack thereof 
-of an 
injected 
fault should be readily 
apparent. 
It should be 
978-1-4244-7501-8/10/$26.00 
©201O IEEE 
570 
DSN 2010: Lanigan et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:03:03 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEE/IFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
(API) call should abort 
on the API, return an error 
hooks cause errors in­
data structures. 
The argu­
hooks can be either modifi­
the 
arguments 
represent 
specific 
Interface 
by manipulating 
Programming 
and, depending 
Application 
immediately 
code to the caller. Manipulation 
directly 
ments passed to manipulation 
able or non-modifiable. 
Modifiable 
data structures 
Non-modifiable 
hook. Rather, 
to the hook (e.g., 
active suppression 
nipulation 
hooks (i.e., 
before its data structures 
that can be manipulated 
arguments 
they can be used to provide 
current 
are not manipulated 
inside of the 
additional 
context 
the target API call will be aborted 
are manipulated). 
slot, global time, etc). In general, 
hooks take precedence 
over active ma­
inside of the hook. 
The SWIFI DLL also implements 
six fault-injection 
refers to 
parameter 
parameter 
represents 
local or global variable) 
(see Figure 1). The location 
as well as CAPL exten­
to be changed by CAPL 
parameters that define faults, 
sions that allow the parameters 
scripts 
the AUTOSAR API call where the fault is to be injected. 
The argument 
data structure 
(e.g., 
which is to be manipulated 
wise operation. 
can specify 
sixth parameter 
hook is active at the selected 
gument, mask, operation 
a mask using a bit­
an optional 
to. The 
which bytes the mask should be applied 
For large data structures, 
within the scope of that call, 
is aflag that specifies 
In this case, the ar­
by applying 
location. 
and offset 
a specific 
whether 
a suppression 
offset 
parameters 
a user interface 
over the fault-injection 
process. 
are ignored. 
that allows 
A CANoe panel provides 
Instead, 
manual control 
this panel cannot access the fault-injection 
di­
rectly. 
These system variables 
parameters 
target 
which is associated 
by a CAPL script, 
Node 1 in Figure 1). 
the panel modifies CANoe system-variables. 
are then mapped to fault-injection 
However, 
parameters 
node (e.g., 
with the 
CANoe 
SWIFI Dll 
Fault-injection 
Parameters 
Node 1 (FI target) 
Node 2 
Node 3 
Node 4 
Figure 1. An overview of the fault-injection 
framework. 
to distinguish 
injected 
possible 
fect (e.g., 
is masked by some error-handling 
between a fault that has no ef­
into "dead code") versus a fault that 
mechanism. 
• Portability. 
The modifications 
needed to apply the 
framework to different 
and to port it between AUTOSAR implementations, 
should be minimal. 
applications, 
AUTOSAR-based 
• Flexibility. 
The framework 
should be flexible 
a wide range offault-injection 
and 
enough 
scenarios 
to support 
fault types. 
4.1. Fault-Injection 
Hooks 
• Probe effects. It is important 
for the fault-injection 
framework to avoid probe effects, 
tended and undesired 
alterations 
by the fault injection 
process 
fects attributed 
to the faults 
(as opposed to ef­
being injected). 
itself 
which are unin­
to the system caused 
4. A Fault-Injection 
Framework for CANoe 
framework 
Our fault-injection 
ponents: 
functionality, 
injection 
functionality 
(see Figure I). 
an AUTOSAR DLL that implements 
application 
and a SWIFI DLL that implements 
fault­
consists 
of two major com­
Fault-injection 
hooks are defined in the SWIFI DLL 
and called from the AUTOSAR DLL. Two types of fault­
injection 
base. Suppression 
suppression 
hooks can be inserted 
into the AUTOSAR code­
hook is active, 
that an AUTOSAR 
it signals 
hooks cause errors directly.  When 
a 
BSW layers to 
at different 
by the AUTOSAR con­
three components 
for fault injection. 
We did not add hooks to the RTE 
it is mostly auto-generated 
tools. The Watchdog Manager (WdgM) is part 
that 
layer and provides 
AUTOSAR components 
a service 
for timing vio­
selected 
time­
Hooks added to the W dgM allow watchdog 
The AUTOSAR COM (Com) 
We selected 
target 
because 
figuration 
of the System Services 
monitors 
lations. 
outs to be triggered 
component 
just below the RTE, and provides 
for routing 
the Com component 
nents on different 
on the same ECU) communication 
provides 
layers. 
the FlexRay controller 
with faults 
The FJexRay Driver (Fr) provides 
layer, 
a signal-based 
gateway 
faults in 
compo­
Injecting 
(i.e., 
components 
manually. 
in the Communication 
to be disrupted. 
It also 
at lower 
of 
It is part of the Commu-
injected 
an abstraction 
data between components. 
allows both inter-node 
ECUs) and intra-node 
comparison 
a basis for 
hardware. 
Services 
resides 
(i.e., 
978-1-4244-7501-8/101$26.00 
©2010 IEEE 
571 
DSN 2010: Lanigan et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:03:03 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
AUTOSAR Layer  AUTOSARAPI 
Description 
Manipulated 
data 
System Services 
WdgM_UpdateAliveCounter  Notifies the WdgM that a supervised 
entity identifier 
Communication 
Services Com_SendSignal 
Communication 
Services ComJReceiveSignal 
Communication 
Drivers FLTransmi t TxLPdu 
Communication 
Drivers FrJReceiveRxLPdu 
entity is still alive. 
Sends data to the RTE as an AUTOSAR 
signal. 
Receives data from the RTE as an 
AUTOSAR signa\. 
Transfers 
as a PDU. 
Receives data from the FJexRay con­
troller 
as  a PD U. 
data to the FJexRay controller 
signal identifier, 
data buffer 
signal identifier, 
data buffer 
data buffer, buffer length,  channel,  slot 
identifier, 
data buffer, buffer length, controller 
flags 
controller 
flags 
Table 1. Hooks were added to manipulate data structures 
in five AUTOSAR API calls. 
layer, 
Drivers 
which is the lowest-level 
nication 
by 
The functionality 
These hooks are meant to cause low-level  FlexRay  proto­
an AUTOSAR DLL that has been instrumented 
col errors that are then passed to higher layers or onto the 
in Table 1. When no 
injection 
faults are active, 
by the front and rear 
FlexRay bus directly. 
wheels changes smoothly 
throttle 
of the rear FlexRay node is provided 
with fault­
listed 
the speed reported 
Hooks were added to a total of five AUTOSAR API calls, 
to changes in the 
to each other. 
value, and identically 
hooks at the locations 
with respect 
with respect 
BSW layer. 
Some manipulations 
designed 
to manifest 
at the FlexRay 
indicator 
For example, 
on the correct 
caused otherwise 
level worked as expected. 
modify­
valid frames 
while null frames were 
a mask to set 
Applying 
bit in FLTransmi t TxLPdu also 
protocol 
ing the channel argument 
to be sent on the wrong channel, 
registered 
channel. 
the null-frame 
caused null frames to be sent. In this case, the rear-wheel 
speed did not change when the throttle 
manipulations 
designed 
were not as effective. 
to register 
is designed 
is received 
with the startup 
the sync frame indicator 
mask to set these bits in the controller 
ing the frame from FLTransmitTxLPdu did not result 
in a ContentError being recorded 
by CANoe. It is likely 
that the simulated 
the preconfigured 
For example, 
a Con ten tError when a static 
controller 
FlexRay parameters. 
frame indicator 
is set to O. However, 
to cause FlexRay protocol 
Other 
errors 
the FlexRay protocol 
these bits in favor of 
flags prior to send­
increased. 
set to 1 while 
applying 
ignores 
frame 
a 
layers 
in temporal 
differences 
Suppression 
hooks in components 
at different 
manifestation. 
Per­
Com_ReceiveSignal to return an er­
and no longer respond to throt­
in Fr...ReceiveRxLPdu, no differences 
in front 
caused visible 
manently  forcing 
ror code caused the wheel speed at the rear FlexRay 
node to drop immediately 
tle changes. However, when the same hook was ac­
tivated 
vs. rear wheel speed were visible 
is that sup­
put was changed. A possible 
the receive 
pressing 
buffer 
How­
from being updated when a frame is received. 
ever, the previous 
be read and passed through the AUTOSAR stack to the 
application. 
Com_ReceiveSignal call seems to prevent any data 
from reaching 
Targetting 
the application 
the WdgM_UpdateAli veCounter API 
Fr...Recei veRxLPdu prevents 
value contained 
in this buffer can still 
explanation 
suppressing 
In contrast, 
software. 
until the throttle  in­
the higher-level 
The functions 
implement­
both manipulation 
descriptions 
of these APIs, in­
and error codes, can be found in 
their arguments 
in Table 1. Complete 
listed 
cluding 
the AUTOSAR specifications. 
ing each call were modified to contain 
hooks and suppression 
erally placed at the very beginning 
any built-in 
call was aborted 
otherwise) 
ally placed after the target argument 
but before it was first used. 
were avoided. 
error checking 
hooks. Suppression 
hooks were gen­
of the function, 
takes place. Thus, the entire 
API 
or 
and any side effects of the call (intended 
before 
Manipulation 
hooks were gener­
had been initialized, 
5. Evaluation 
We should note that this application 
we used a demo version 
of CANoe 
on Windows XP) and a vendor-supplied 
of the AUTOSAR 3.0 specification. 
im­
We ap­
framework to a simple "by-wire" 
specifically 
developed 
For this evaluation, 
(v7.1, running 
plementation 
plied the fault-injection 
application 
tions. 
to be fault-tolerant, 
level error handling. 
strating 
application-level 
to verify that the fault injection 
tional 
that faults 
However, 
can be injected 
and does not provide 
for CANoe demonstra­
was not designed 
any application­
it is sufficient 
for demon­
and visualized. 
In fact, 
error handling 
could make it more difficult 
framework itself 
is func­
by masking errors that would otherwise 
be visible. 
of two FlexRay nodes, a single 
The application 
consists 
Area Network (CAN) node and a CANIFlexRay 
The CAN node sends throttle 
Controller 
gateway. 
and brake inputs 
through the gateway to the FlexRay nodes. The FlexRay 
nodes calculate 
wheels, 
adjustable 
display 
functionalities 
front FlexRay node are implemented 
front and rear wheel speed. The 
of the CAN node, the gateway node and the 
the wheel speed for the front and rear 
panel provides 
user­
and brake controls, 
of the calculated 
respectively. 
A CANoe control 
as well as a graphical 
with CAPL scripts. 
throttle 
978-1-4244-7501-8/10/$26.00 
©201O IEEE 
572 
DSN 2010: Lanigan et al. 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 18,2021 at 14:03:03 UTC from IEEE Xplore.  Restrictions apply. 
2010 IEEEIIFIP International 
Conference 
on Dependable 
Systems & Networks (DSN) 
two of AUTOSARs built-in 
Modifying 
call exercised 
mechanisms. 
caused errors to be reported 
ment Event Tracer (DET). Suppressing 
caused the watchdog 
timer to expire and report an error. 
by the AUTOSAR Develop­
the entity-identifier 
parameter 
the API call entirely 
error-handling 
if the mechanism 
logs the error or 
it will only be observable 
otherwise 
notifies 
the user. 
6. Lessons  Learned 
This proof-of-concept 
eral ways, but there were also significant 
ing CANoe in this manner. 
in sev­
drawbacks 
to us­
framework  showed  promise 
The functionality 
of the framework 
was 
AUTOSAR error-handling 
Fuuctiouality. 
mostly satisfactory. 