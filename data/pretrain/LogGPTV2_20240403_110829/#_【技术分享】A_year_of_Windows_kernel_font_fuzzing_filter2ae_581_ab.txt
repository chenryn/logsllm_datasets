事实证明我们不需要等待很久，我们最先提交的两个漏洞中的一个很快被证明就是Keen
Team在2015年Pwn2own期间使用的TTF漏洞，并且一个OTF漏洞在2015年7月Hacking
Team泄露的数据中被发现存在相同的（甚至包含了完整的利用代码），随后由Microsoft在紧急公告中修复。
有趣的是，这两个发生撞洞的漏洞其实是很难挖掘的。我们的Fuzzing工具在第一次运行期间不断地触发程序的崩溃，通过一些简单的分析，我们确定这两个条件确实可以通过在许多合法字体中执行微小的改变（比如单比特翻转，单字节交换）来触发。这似乎验证了我们通过挖掘上报漏洞来提高漏洞利用门槛的追求，因为它确认了这些漏洞通常会被其他研究人员发现和利用。
**与HackingTeam的0day撞洞**
在2015年5月向微软报告了第一批漏洞（7个OpenType和4个TrueType错误）后，我们耐心等待厂商发布相应的修补程序。很快，我们被告知他们重现了所有的问题，并安排在八月的补丁日进行修复。然而在7月20日当时我正在休假，我突然发现微软当天发布了一个临时的MS15-078安全公告：
有趣的是，我是被致谢的三个人之一
它迅速的证明了，我们之前报告的一个漏洞与Hacking Team泄漏文件中的两个独立研究人员发现的exp发生了撞洞。在2015年7月5日，Hacking
Team公司的千兆数据文件被公布在Twitter帐户上。安全行业中的绝大多数人都急于调查这些突然出现的有价值的资源，其中不仅发现了监控产品的源代码和有争议的业务操作信息，而且还存在多个软件中的0day漏洞，例如Flash
Player（4个exp），Windows 内核（2个exp），Internet
Explorer，SELinux等。然而直到7月20日，都没有公开的信息表明CVE-2015-2426曾被暗地里报告给了微软。
这个exp利用漏洞来实现在Windows（最高8.1）平台的本地权限提升。有关漏洞和利用技术的详细分析可以在360
Vulcan团队的博客文章中找到，但实质上，这个漏洞是由OpenType驱动程序中的ATMFD.DLL做出的无效假设引起的，如图所示，在伪代码中表示如下：
    LPVOID lpBuffer = EngAllocMem(8 + GPOS.Class1Count * 0x20);
    if (lpBuffer != NULL) {
     // Copy the first element.
     memcpy(lpBuffer + 8, ..., 0x20);
     // Copy the remaining Class1Count - 1 elements.
    }
这里，代码假定Class1Count（GPOS表中的16位字段）的值始终非零，并复制第一个表项，而不考虑实际值。
因此，如果字段等于0x0000，则动态分配的缓冲区会发生32（0x20）字节的溢出。通过适当的布局内核内存池（pool），可以将win32k.sys的CHwndTargetProp对象直接布置在发生溢出的内存区域之后，然后用一个用户模式的地址去修改它的vtable（虚函数表）。在那里，它只是泄漏了win32k.sys模块的基地址，之后构造了一个ROP链来禁用SMEP和调用实现权限提升的shellcode。
更重要的是，如果要通过Fuzz来触发漏洞，那么只需要将文件中特定位置（对应于Class1Count字段）的两个连续字节的值设置为0即可。换句话说，它可以被一个最简单的随机Fuzz工具测试出来，但是令人惊讶的是，在这么多安全机制被加入的情况下，这样的漏洞甚至可以存活到2015年。
出于好奇，原来HT的exp随后被NCC集团的Cedric Halbronn移植到64位的Windows 8.1中(见本文）。
**与pwn2own的漏洞撞洞**
三周后，2015年8月11日，第一批漏洞的补丁按计划发布。我再一次对致谢部分感到了惊讶，这次是把其中一个漏洞归功给了另一个研究人员。
这一次是Keen
Team的人，如果你查找CVE-2015-2455，其中的一个结果将是一个ZDI-15-388的页面，在页面的标题中就说明了这是pwn2own上使用的漏洞，并提到它是与“IUP”TrueType指令相关的。是的，这就是编号为368的漏洞。在pwn2own期间，该漏洞确实被利用来实现沙盒逃逸和通过“Adobe
Reader”或“Adobe Flash
Player”两者之一（具体不太清楚，因为在比赛期间曾使用了两个不同的TTF漏洞）获得对目标系统的完全控制。比赛发生在2015年3月19、20日。有一点疑问的是，对其他Team
Keen的TTF漏洞的公开是在2015年REcon的“This Time Font hunting you down in 4
bytes”演讲上。值得注意的是，自打他们通过ZDI报告这个漏洞后，微软花了几乎5个月的时间来进行修复，但仍然满足Project
Zero的90天披露时限（开始日期是5月21日）。
至于技术细节是在执行“IUP”指令时存在一个漏洞，它转换为通过TrueType指令集规范中的大纲插值未触及点：
如果仔细观察，可以发现在末尾有一个重要说明：将IUP应用于区域0是一个错误。是的，就像你猜的那样这就是漏洞所在。win32k！itrp_IUP上的指令处理程序没有验证当前区域是不是区域0，因此它可以直接把区域0当成区域1去操作，这最终导致了基于内核内存池（pool）的缓冲区溢出，而且溢出的内容和长度都可控。下面的三个TrueType指令就足以触发崩溃：
    PUSH [] / * 压入一个值* /
    0
    SZP2 [] / * SetZonePointer2 * /
    IUP [0] / * InterpolateUntPts * /
更重要的是，当正常改变字体时，崩溃也很容易被触发 –
单个bit的翻转就足以将SZP2/SZPS指令的参数从1更改为0。因此，这是在我第一次运行Fuzzing测试时最先触发的崩溃。在我后来添加一个TrueType程序生成器之后，这个问题会出现在每一个测试用例身上，这迫使我们在生成器中通过绕过一些特定的结构来避免这个问题，直到bug被修复。
这个案例或许是一个很好的例子，即不需要Fuzz测试也不需要进行审计，仅仅通过仔细阅读官方文档就可以获得关键的漏洞点。
**最后的一些想法**
我们的成果和努力证明了正确的Fuzz测试仍然是一个非常有效的漏洞挖掘方法，即使是针对在理论上已经很成熟的和经过了严格测试的代码库而言。此外，这两个漏洞的撞洞现象证明了Windows内核字体漏洞仍然存在，至少是在2015年依然在野外被积极使用。在本系列的第二篇文章里，我们将对关键技术部分进行讨论，包括：我们是如何准备输入数据的，如何去变异和生成字体样本，大规模的Fuzzing
Windows内核，如何复现漏洞和减少它们。