0x72727563:
第4章应用程序调试实践
backtrace时就会很方便。
调试对象的环境中，标准情况下程序和共享库会被定位到什么地址，在阅读
的使用环境下，与连接器的定位地址有关的选项也可能发生变化，因此记住在
定位到0x3000000000、0x2aaa0000地址附近，具体情况由连接器决定。不同
之后的地址。在x86_64中，程序定位到0x400000或0x0600000附近，共享库被
Linux发行版中，程序被定位到0x08000000地址附近，共享库被定位到0xb0000000
栈帧的#0、#1显示的地址上很难放置程序、共享内存等。大多数i386架构的
www.TopSage.com
红网
---
## Page 171
当做返回地址使用，导致 segmentation fault。
用图来表示则如图 4-4 所示。strcpy()写入字符串的空间，原本是用于保存返回
制的字符串超过了这个长度（导致缓冲区溢出)。
用 strcpy()复制buf 的地方。此时就能立刻看出，原因就是 buf 只有5字节长，复
curry”这个字符串是源代码中的 names 这个字符串的一部分，而使用 names 的是
的错误位置的可能性很高。实际上引发该问题的源代码如下所示。“building"…
如上所示，栈指针指向的空间前后几乎都是字符串，因此将这种字符串写入栈上
法是从栈中获取返回地址，因此先调查一下栈。
性也不是没有，所以必须进一步验证这个假说是否成立。上一节说明的第3类方
这个字符串的一部分被写入了。但是，连续出现4个字符代码对应的数字的可能
“elb"。考虑到x86_64和 i386 架构为 little endian，因此可以认为是“.…-ble."
在本 hack 的例子中以此观点查看地址 Ox20656c62，就会发现它是ASCⅡI字符串
若缓冲区过小，再加上对输入字符串的长度检查不完善，就可能发生这种状况。
据写入地址的典型情况之一就是字符串复制。由于字符串的输入长度很难预测
int main(void)
void func(void)
char names[] = "book cat dog building vegetable curry";
$9 = Oxbfc6f64c " building vegetable curry"
(gdb) p (char*)$esp-20
xbfc6f669:
oxbfc6f661: 
oxbfc6f659:
Oxbfc6f651:
(gdb) x/30c $esp-15
 return EXIT_SUCCESS;
func();
strcpy(buf, names);
char buf[5]; 
-108"\224'
.00.  ,0, 0,, 11 ,, 11 , 11 ,, 11
101 'e' 116't' 97'a′ 98'b' 108 l′ 101'e' 32′'99 'c'
100 'd' 105 'i′ 110 'n′ 103 'g' 32'′ 118 'v' 101'e'103 'g'
4'\004'
www.TopSage.com
HACK#28 数组非法访问导致内存破坏|153
b00\, ii. Il,ZT-,q\, 8
8'\b'-116'\214'
160
---
## Page 172
161
就是说，从 0x080483c5地址的call指令执行，到返回0x088483ca之间有可能发生
可见，栈跟踪中显示的ox080483ca，可以认为是前面的call指令放到栈上的。也
0x080483ca处执行了什么操作。
因，唯一的线索只有栈帧最后的 bufov2.c:19。我们对其进行反汇编，看看这个
讨论程序在发生 segmentation fault 时，产生的 core 的 backtrace 如下所示。
访问数据空间中静态分配的数组时，如果出现 bug，也会发生类似的现象。下面
本例中，backtrace 的#0 所示的地址也不存在。而且，其数值为 8，很难找出其原
确定破坏跳转地址值的位置
图4-4func()的栈
缩小到使用该数值的部分。
况会更难调查。即便如此，如果那个数值经常在程序中出现，就可以将调查范围
本例中的地址是字符串的一部分，比较容易判别，而只是将数值错误地写入的情
154 |
0x080483ca :
0x080483c5 :
(gdb) disas 0x080483ca
#3 0x080483ca in main () at bufov2.c:19
#2 0x00000008 in ?? ()
#1 0x0000000a in ?? ()
#0 0x00000008 in ?? ()
(gdb) bt
strpy()之后
strpy()之前
0x080483be :
”第4章应用程序调试实践
.··
book cat dog building vegeta
mov
call
movl
burf[0] ..· buf[4]
www.TopSage.com
func()的栈
$0x0,%eax
0x80482b0 
$0x80484a8,(esp)
置（GOT破坏）
*+*
bte
指中..
指向main的返回
地址
aurry
main()的栈
---
## Page 173
像下面这样调查该地址附近的整体结构。
况（bug）也多种多样，很难一概而论，可以假设应当写入的地址就位于附近，
因此，很可能是错将8当做了要保存的地址写入了GOT区域。而弄错地址的情
是如GDB所示，0x80495a8是GOT的一部分，通常的用户程序不会写入该区域。
那么，哪里写入了这个8呢？刚才也说过，这个数字太普通，因此很难找出，但
segmentationfault，这样就能说得通了。
现0x08048296 地址处的jmp指令访问的地址值为0x8。跳转到该地址导致
到了0x80495b0号地址中存储的地址（0x080482b6）。这样跟踪指令之后，就会发
了问题。那么，被调用的0x80482b0处发生了什么呢？调查后可以发现，它跳转
8048484 5589553 8000568103 3110000 ..... ..
$ objdump -s bufov2
Contents of section ,fini:
+：
0x80495a8 : 0x000008
(gdb) x 0x80495a8
End of assembler dump.
0x0804829e :
0x0804829c :
0x08048296 :
0x08048290 : pushl 0x80495a4
Oump of assembler code from 0x8048290 to 0x80482a0
(gdb) disas 0x8848290 ex80482a0
0x080482bb : jmp
0x080482b6 :
(gdb) disas
0x80495b0 : 0x080482b6
(gdb)x θx80495bθ
0x080482bb :
0x080482b6 :
0x080482b0 : jmp
Dump of assembler code from 0x80482b0 to 0x80482c0:
(gdb) disas 0x80482b0 ex80482c0
调用函数的原理”。
这里是通过 PLT调用库函数的代码。详情参见“HACK#63理解用GOT/PLT
push
jmp
push
0x8048290 
www.TopSage.com
8x0$
0x8048290 
$0x8
*0x80495b0
%al, (%eax)
%al, (%eax)
*0x80495a8
HACK#28 数组非法访问导致内存破坏 1 155
---
## Page 174
于错误的指针操作或错误的数组下标引起的。用这个观点来看看源代码。
由上可见，被破坏的地址Ox80495a8位于.got.plt section中，紧跟着就是保存用
156 1第 4 章 应用程序调试实践
入.data section 的数据错误地写入了·got.plt section。地址错误大多数情况是由
户的静态数据的.data section。这种情况下能想到的一种可能性就是，将本应写
int calc_index(void)
int my_data[2] = {1, 2];
Contents of section -got:
Contents of section .dynamic:
80494d0 00000000
Contents of section .jcr:
80495b4 00000 0000000 cc940408 01000000
Contents 
80495a0 d4940408 00000000 00000000 a6820408
Contents C
804959c 00000000
80494c8 ffffffff 000oo00
Contents of section .dtors
80494co ffffffff 00000000
Contentso
80484bc 00000000
Contents of section .eh_frame:
80495c4 02000000
80495b0 b6820408
8049594 00000000 0000000
80484b0 61206d65 73736167 650a00
Contents of section .rodata:
8048494 50e876fe ffff595b c9c3
return -7;
/*该函数有 bug，返回错误的值*/
of section .data:
of section ,got.plt:
of section .ctors:
www.TopSage.com
11+
.......
+±++t+ ±
 a message..
P.v...YI..
....$.........
---
## Page 175
所在。本hack介绍利用监视点进行调试的方法。
且能立即复现bug，那么利用GDB的监视点（watchpoint）可以更高效地确定bug
几个证据确定实施非法内存写入的地点。但是，如果调试对象程序就在手头，而
segmentationfault的例子。[HACK#28]的分析过程基本上是分析core文件，根据
监视点何时有效？
#29
访问”就介绍了利用GDB的watch命令在内存内容被破坏的瞬间就发现的方法。
就必须依靠一定的感觉和经验。下面的“HACK#29利用监视点检测非法内存
法。确定内存内容被破坏的过程可以按照某种步骤进行，但找出引发破坏的地方
本 hack 介绍了错误的数组操作引发内存破坏而导致 segmentation fault 的调试方
总结
查到怀疑某个函数有问题，然后多关注该函数内的处理并找出bug，就会容易许多。
际情况下下标计算会更复杂些，可能并不会一看代码就能发现bug。但是，如果能调
呢？实际上，读一下源代码就会立即发现真的是calc_index（）返回了错误的值。实
calc_index（）负责计算。到这里就会想到，是不是calc_index（）返回了错误的下标
源代码中有个静态数组my_data，并有对该数组进行写入的操作，而其下标由
int main(void)
return EXIT_SUCCESS;
printf("This is amessage\n");
my_data[idx+1]=0x08;
my_data[idx]=0x0a;
intidx=calc_index(）;
定变量或地址的数据被访问时暂停程序运行。
本hack通过实例，介绍监视点（watchpoint）的用法。监视点能在指
利用监视点检测非法内存访问
www.TopSage.com
大和一洋
164
---
## Page 176
165
的函数）的地址。调查 core 时已知非法写入的数值为Ox8，因此可以判断，这次
这是包含 glibc 中的_dl_runtime_resolve 函数（获取库函数地址并设置到 GOT 中
这里发生了向 0x80495a8的写入操作，所以程序中断了运行，New value右边的数
直接指定地址而不是指定变量名或符号时，要在地址前面加上*，这与在 break 命
监视点的设置方法
写入为正常的写入操作。我们继续执行程序。
值就是写入指定地址的新数值。但是，这次NewvaLue 为十六进制数的 θxb7fflacθ,
令中指定地址是一样的。然后在该状态下执行程序。
输入下面的命令设置监视点。
行，因此调查中断位置，即可得知是否发生了预期之外的写入操作。
写入的地方。当指定的变量或内存地址等被读取或写入时监视点会中断程序执
0x80495a8。下面我们要执行生成 core 文件的程序，利用 watchpoint 检测进行错误
[HACK#28]中通过调查 core 文件，可以比较容易地确定被错误地写入的地址为
158 1   第 4 章  应用程序调试实践
0ld value = -1208018240
Hardware watchpoint 1: *134518184
Hardware watchpoint 1: *134518184
Continuing.
(gdb)c
Oxb7fflaco ;
(gdb) x/i -1208018240
_dl_relocate_object (l=oxb7ffc710, scope=0xb7ffc8c8, lazy=1,
New value = -1208018240
old value = 0
Hardware watchpoint 1: *134518184
Hardware watchpoint 1: *134518184
Starting program: /home/yamato/tmp/bufovrn.work/bufov2
(gdb) run
Hardware watchpoint 1: *134518184
268
(gdb) watch *0x80495a8
consider_profiling=0) at dl-reloc.c:268
 ELF_DYNAMIC_RELOCATE (l, lazy, consider_profiling);
www.TopSage.com
push%eax
---
## Page 177
地址具体来说就是0x80495c4+%eax*4。%eax的值和地址计算结果如下所示。
停止执行的地址的前一个命令为①的 movl，它将8这个数值写入了某个地址，
进一步分析问题似乎应该阅读汇编代码。
寻找问题原因
会显示C源代码中的下一行。
printf()。这是因为监视点的中断与断点不同，是在访问数据之后发生的，因此
行的 printf 语句，这是监视点的中断位置，但引发程序停止的似乎并不是这个
上述 New value 的值为 8，正是我们要找的写入操作。不过显示出的源代码为 19
$6 = 0x80495a8
End of assembler dump.
$4 = (void *) 0x80483be
(gdb) p $pc
(gdb) p/x (0x80495c4 + $eax*4)
0x080483c5 :
0x080483b0 :
Oump of assembler code for function main:
19
main () at bufov2.c:19
(gdb) p $eax
0x080483be 
0x080483a5
0x080483a2:
9x0804839a :
(gdb) disas
New value = 8
0x080483b3
x0804839f :
GOT/PLT 调用函数的原理”。
上面将监视点设在了GOT区域内。关于GOT请参见“HACK#63理解用
0
2
call
www.TopSage.com
$0xa,0x80495c0(,%eax,4)
Oxfffffffc(%ebp),*eax
seax,Oxfffffffc(%ebp)
0x8048374 
0x80482b0 
$0x80484a8,(%esp)
$0x8,0x80495c4(,%eax,4)——
Oxfffffffc(%ebp),%eax 
HACK#29 利用监视点检测非法内存访问1159
该
<166
---
## Page 178
167
错误使用内存相关库函数引起的bug
视点（watchpoint）的用法。
本 hack 通过实例介绍了能在指定变量或地址的数据被访问时暂停程序执行的监
现了错误的负值，确定 bug 位于 calc_index()中。
到这里，idx 的值不正确这个假设就很容易成立了。实际调查后会发现，下面出
相应的C语言源代码用下述方法获取。
0x88495a8这个地址就是执行了非法写入的地址，可以判断这部分就是直接原因。
应用程序，特别是C 语言应用程序的 bug 中，最常见的就是内存相关库函数的错
#30