overhead of ShareJS. Even for the smaller split size values,
the network utilization is almost identical.
In order to compare SECRET with Google Docs we ob-
served the communication between our browser and Google
during editing a freshly generated document. Google Docs
synchronizes the content via HTTP POST requests trans-
mitting a parameter named bundles that contains OT infor-
mation. For our measurement, we extracted only this HTTP
parameter and left out all other parameters4.
Compared to Google Docs, SECRET needs less commu-
nication to synchronize the unencrypted document content.
The main reason for this diﬀerence is the meta information
that Google Docs transmits within each OT synchroniza-
tion request (e. g., session management information). Some
of this information is even redundant since it is sent simul-
taneously as a GET and POST parameter.
10.3.2 Encrypted Network Overhead
In Figure 5d the network overhead of editing an encrypted
block in SECRET is displayed. With encryption enabled,
almost every key stroke causes a re-encryption of an existing
ED element, which is then sent over the network. This leads
to a substantial growth of network traﬃc.
The traﬃc utilization of SECRET is always above the one
of Google Docs5, regardless of the chosen split size. This is
an expected result caused by the enabled encryption. One
4Since we did not reverse-engineer Google Docs, it is possible
that our measurement technique misses some OT related
messages. However, these messages would only increase the
bandwidth required by Google Docs.
5Since no related work measured network traﬃc utilization,
we cannot compare our solution with other encrypted ap-
proaches.
can see that SECRET has a linear relation between the in-
serted text and network traﬃc, similar to the unencrypted
Google Docs.
10.4 Bandwidth Requirements
Despite the overhead of our approach, the system is us-
able: At a typing speed of 200 key strokes per minute, enter-
ing a 1024 byte document takes 307 seconds. With encryp-
tion and a split size of 128 bytes, the total payload traﬃc
sent by the client is roughly 119 Kbyte. However, the traﬃc
being transmitted is larger. The two main reasons for this
is URL encoding that is applied to the messages and HTTP
headers being added to the messages.
We measured the required traﬃc bandwidth of SECRET
using the network analysis tool Wireshark. Using the set-
tings given above, our tool requires a bandwidth of
14 kbit/s (see Figure 7).
If other users of the system type at the same speed, then
each of them generates incoming traﬃc at a similar rate.
Considering that even very slow mobile connections provide
a connection speed of 32 Kbit/s or more, it would require at
least a couple of users typing simultaneously to exceed such
a connection.
Summarized, a split size value of 128 bytes seems to be a
good trade-oﬀ between the storage overhead and the network
overhead. With this setting, SECRET requires a storage
overhead of factor 1.92 and a network utilization that does
not exceed even very slow connections.
SECRET is the ﬁrst considering network bandwidth in
addition to storage overhead in its evaluation.
11. CONCLUSION AND OUTLOOK
We presented SECRET, the ﬁrst fully collaborative web
editor on encrypted data with obliviousness using a docu-
ment based approach. By that, we have answered a research
question that has been open for the last four years. Our ex-
tensive evaluation reveals that – with the right choice of
parameters – SECRET achieves three times lesser storage
overhead compared to all existing solutions. SECRET is
frugal with network bandwidth and could also be applied to
mobile low-bandwidth application areas.
Although SECRET is fully working, there are still open
research questions. Most notably, whether it is possible
to include SECRET’s concept to full-ﬂedged oﬃce docu-
ments such as Microsoft Oﬃce, LibreOﬃce, or OpenOﬃce;
maybe by integrating it into their online collaboration ser-
vices. To help the research community in this ﬁeld, we pub-
lished SECRET and its novel structure preserving encryp-
tion concept using OTs as open source software.
0123464128256512102420484096Plain Document Size (KByte)Content Text (Byte)16048121664128256512102420484096Encrypted Document Size (KByte)Content Text (Byte)040801201600512102415362048Network Traffic (KByte)Plaintext BlockAppended Text (Byte)02004006008000512102415362048Network Traffic (KByte)Encrypted BlockAppended Text (Byte)02004006008000512102415362048Network	Traffic	(KByte)Encrypted	BlockAppended	Text	(Byte)Split	size	=	32Split	size	=	64Split	size	=	128Split	size	=	256Split	size	=	512Google	Docs84512. ACKNOWLEDGMENTS
This research results from work in the research projects
SyncEnc and VERTRAG, which are funded by the Ger-
man Federal Ministry of Education and Research (BMBF,
FKZ: 16KIS0412K and 13N13097), as well as the FutureTrust
project funded by the European Commission (grant 700542-
Future-Trust-H2020-DS-2015-1).
References
[1] L. Adkinson-Orellana, D. A. Rodr´ıguez-Silva, F. Gil-
Casti˜neira, and J. C. Burguillo-Rial. Privacy for google
docs: Implementing a transparent encryption layer. In
CloudViews, pages 20–21, 2010.
[2] A. Barth. The Web Origin Concept. RFC 6454 (Pro-
posed Standard), Dec. 2011. URL http://www.ietf.org/
rfc/rfc6454.txt.
[3] A. Barth, C. Jackson, and J. C. Mitchell. Securing
frame communication in browsers. In USENIX Secu-
rity, 2008.
[4] M. Bellare, O. Goldreich, and S. Goldwasser. Incremen-
tal cryptography: The case of hashing and signing. In
CRYPTO, pages 216–233. Springer, 1994.
[5] T. Bray. The JavaScript Object Notation (JSON) Data
Interchange Format. RFC 7159 (Proposed Standard),
Mar. 2014. URL http://www.ietf.org/rfc/rfc7159.txt.
[6] T. Bray, F. Yergeau, E. Maler, J. Paoli, and
M. Sperberg-McQueen. Extensible markup language
(XML) 1.0 (ﬁfth edition). W3C recommendation, W3C,
Nov. 2008.
[7] E. Buonanno, J. Katz, and M. Yung. Incremental un-
forgeable encryption. In FSE, pages 109–124. Springer,
2001.
[8] M. Clear, K. Reid, D. Ennis, A. Hughes, and H. Tewari.
Collaboration-preserving authenticated encryption for
operational transformation systems. In ISC, pages 204–
223. Springer, 2012.
[9] G. D’Angelo, F. Vitali, and S. Zacchiroli. Content
cloaking: preserving privacy with google docs and other
web applications. In SAC, pages 826–830. ACM, 2010.
[10] A. H. Davis, C. Sun, and J. Lu. Generalizing opera-
tional transformation to the standard general markup
language. In CSCW, pages 58–67. ACM, 2002.
[11] C. A. Ellis and S. J. Gibbs. Concurrency control in
groupware systems. In SIGMOD, volume 18, pages 399–
407. ACM, 1989.
[12] A. J. Feldman, W. P. Zeller, M. J. Freedman, and E. W.
Felten. SPORC: Group collaboration using untrusted
cloud resources. In OSDI, pages 337–350, 2010.
[13] I. Fette and A. Melnikov. The WebSocket Protocol.
RFC 6455 (Proposed Standard), Dec. 2011. URL http:
//www.ietf.org/rfc/rfc6455.txt.
[14] J. Gentle, N. Smith, and Others. ShareJS. https://
(Retrieved: Oc-
github.com/share/ShareJS/tree/0.6.
tober 2016).
[15] P. Grubbs, R. McPherson, M. Naveed, T. Ristenpart,
and V. Shmatikov. Breaking web applications built on
top of encrypted data. In CCS, pages 1353–1364. ACM,
2016.
[16] F. Hirsch, T. Roessler, J. Reagle, and D. Eastlake. XML
encryption syntax and processing version 1.1. W3C rec-
ommendation, W3C, Apr. 2013.
[17] Y. Huang and D. Evans. Private editing using un-
In ICDCSW, pages 263–272.
trusted cloud services.
IEEE, 2011.
[18] C.-L. Ignat and G. Oster. Peer-to-peer collaboration
over xml documents. In CDVE. Springer, 2008.
[19] C. L. Ignat, G. Oster, et al. Flexible reconciliation
of xml documents in asynchronous editing. In ICEIS,
pages 359–368, 2007.
[20] M. Jones and J. Hildebrand. JSON Web Encryption
(JWE). RFC 7516 (Proposed Standard), May 2015.
URL http://www.ietf.org/rfc/rfc7516.txt.
[21] H. Krawczyk, M. Bellare, and R. Canetti. HMAC:
Keyed-Hashing for Message Authentication. RFC 2104
(Informational), Feb. 1997. URL http://www.ietf.org/
rfc/rfc2104.txt. Updated by RFC 6151.
[22] J. Li, M. N. Krohn, D. Mazi`eres, and D. Shasha. Secure
untrusted data repository (SUNDR). In OSDI, page 9,
2004.
[23] P. Mahajan, S. Setty, S. Lee, A. Clement, L. Alvisi,
M. Dahlin, and M. Walﬁsh. Depot: Cloud storage with
minimal trust. In TOCS. ACM, 2011.
[24] N. Mehta, J. Sicking, E. Graﬀ, A. Popescu, J. Orlow,
and J. Bell. Indexed database API. Recommendation,
W3C, Jan. 2015.
[25] R. C. Merkle. A digital signature based on a conven-
In CRYPTO, pages 369–
tional encryption function.
378. Springer, 1987.
[26] D. Micciancio. Oblivious data structures: applications
to cryptography. In STOC, pages 456–464. ACM, 1997.
[27] A. Michalas and M. Bakopoulos. SecGOD Google Docs:
Now I feel safer! In ICITST. IEEE, 2012.
[28] D. A. Nichols, P. Curtis, M. Dixon, and J. Lamping.
High-latency, low-bandwidth windowing in the jupiter
collaboration system. In UIST. ACM, 1995.
[29] G. Oster, H. Skaf-Molli, P. Molli, H. Naja-Jazzar, et al.
Supporting collaborative writing of xml documents. In
ICEIS, pages 335–341, 2007.
[30] R. A. Popa, E. Stark, S. Valdez, J. Helfer, N. Zeldovich,
and H. Balakrishnan. Building web applications on top
of encrypted data using mylar. In NSDI, pages 157–172,
2014.
[31] M. Ressel, D. Nitsche-Ruhland, and R. Gunzenh¨auser.
An integrating, transformation-oriented approach to
concurrency control and undo in group editors.
In
CSCW, pages 288–297. ACM, 1996.
[32] A. Shraer, C. Cachin, A. Cidon,
I. Keidar,
Y. Michalevsky, and D. Shaket. Venus: Veriﬁcation
for untrusted cloud storage. In CCSW. ACM, 2010.
[33] C. Sun, X. Jia, Y. Zhang, Y. Yang, and D. Chen.
Achieving convergence, causality preservation, and in-
tention preservation in real-time cooperative editing
systems. TOCHI, 5(1):63–108, 1998.
[34] M. Watson. Web cryptography API. W3C recommen-
dation, Jan. 2017.
[35] WHATWG.
Online,
https://html.spec.whatwg.org/#posting-messages, Oc-
tober 2015.
Html – posting messages.
[36] WHATWG. Dom – mutation observers. Online,
https://dom.spec.whatwg.org/#mutation-observers,
May 2016.
[37] C. Zhang, J. Jin, E.-C. Chang, and S. Mehrotra. Secure
quasi-realtime collaborative editing over low-cost stor-
age services. In SDM, pages 111–129. Springer, 2012.
846APPENDIX
A.
INTEGRITY PROTECTION
Ensuring the integrity of a whole document is easy: One
can simply append a Message Authentication Code (e. g.
an HMAC [21]) or use an authenticated encryption scheme
like AES-GCM. This has been done before, for example,
by Clear et al. [8]. However, if parts of a document are
to be left unprotected intentionally, it is crucial to identify
all parts which must not be left unprotected in order to
keep integrity for the sensitive parts. The remainder of this
section, we describe a concept to provide integrity we are
currently working on.
A.1 Deﬁnition of Integrity
We assume, that encrypted parts are leafs in the tree,
which holds for ED elements, and that the leafs are individ-
ually integrity protected by AES-GCM. This ensures that
even an adversary changing a single bit in the ciphertext
would be detected. However, if we furthermore assume an
adversary that may insert, delete, or reorder parts of a docu-
ment, we would not be able to detect if the adversary modi-
ﬁed the document structure (e. g., by swapping ED elements
without changing any bit within these elements). For that
reason, we need to categorize nodes in the document tree.
Definition 1. A critical node is a node in a document
tree that has at least one critical node as child. All ED ele-
ments are critical nodes.
The intuition behind this deﬁnition is as follows: If there is
any encrypted data in a document tree, then all nodes on
the path from the document root to that ED element are
critical. If there are at least two ED elements in a document
tree, then the critical nodes build a subtree of the document
tree.
We deﬁne integrity of a partially encrypted document tree
as follows:
Definition 2. Integrity of a partially encrypted docu-
ment tree is given if no attacker is able to eﬃciently modify
the structure of the subtree formed by the critical nodes or
the content of ED elements in it without being detected.
Informally spoken, this deﬁnition prevents all unauthorized
modiﬁcations of the document structure except of parts that
consist entirely of unencrypted branches and leafs. Note that
this deﬁnition only covers the tree structure. The content
of a critical node may be modiﬁed without violating the
integrity6.
A.2 Technical Concept
For our integrity concept, we use the fact that every ED
element in the document tree has a randomly generated
unique ID in form of an XML attribute. These IDs are used
as Additional Authenticated Data (AAD) in AES-GCM upon
encryption of the content of that element. Every other crit-
ical node is also provided with an ID attribute. The value
of that attribute is computed as the hash value of the ID
attributes of all critical child nodes. This way, we build a
Merkle-Tree [25] using the IDs to protect the structure. At
6This probably sounds undesirable. However, if the content
is not meant to be modiﬁable, one should simply put the
corresponding subtree into an ED element.
the root node, we introduce another XML attribute named
IntegrityTag.
Its value is either an HMAC or a digital
signature of the root’s ID, depending on whether public ver-
iﬁcation of the integrity is required or not.
A.3 Security Consideration
If a collision-resistant hash function is used, the security
properties of Merkle-Trees guarantee that every modiﬁcation
in the structure of critical nodes result in a diﬀerent ID of
at least the root node. Given that the IntegrityTag was
build using a secure construction (i. e. an attacker cannot
forge a valid value), every unauthorized modiﬁcation of the
structure can be detected.
There is a hypothetical modiﬁcation an unauthorized at-
tacker can perform that remains undetectable for some users
of the system: An attacker could replace the ciphertext of
an ED element with a diﬀerent ciphertext (probably gener-
ated under the same key), but keeping the original ID. This
modiﬁcation is detected once a user tries to decrypt that
ED element since diﬀerent AAD were involved in the origi-
nal encryption. However, all users who do not have access to
the key for that ED element cannot detect this attack. They
can only check the ED elements they have keys for and com-
pute and compare the IntegrityTag, which succeeds since
the attacker did not change any IDs or other ED elements.
Nevertheless, this issue is negligible since the modiﬁcation
is instantly detected by users who have the corresponding
keys. Users, who do not have the corresponding keys, are
not concerned of that particular ED element anyway since
they cannot decrypt it.
B. ADDITIONAL FIGURES
Figure 6: Screenshot of our proof-of-concept demo.
Figure 7: Screenshot from Wireshark measuring the re-
quired bandwidth for SECRET at 200 key strokes per
minute with a split size of 128 bytes.
847(a) Storage requirements for unencrypted documents.
(b) Storage requirements for encrypted documents.
(c) Network overhead in an unencrypted document.
(d) Network overhead in the encrypted document.
Figure 8: SECRET evaluation results.
0123464128256512102420484096Plain Document Size (KByte)Content Text (Byte)16048121664128256512102420484096Encrypted Document Size (KByte)Content Text (Byte)040801201600512102415362048Network Traffic (KByte)Plaintext BlockAppended Text (Byte)02004006008000512102415362048Network Traffic (KByte)Encrypted BlockAppended Text (Byte)02004006008000512102415362048Network	Traffic	(KByte)Encrypted	BlockAppended	Text	(Byte)Split	size	=	32Split	size	=	64Split	size	=	128Split	size	=	256Split	size	=	512Google	Docs848