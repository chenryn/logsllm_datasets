where the parameters of elliptic curve (G; ğ‘ƒ; ğ‘) are implicit public
parameters. We use the standard Schnorr proof [29] for Rğ·ğ¿, ap-
ply the Fiat-Shamir [18] transformation to get a non-interactive
ZKPoK. Denote by nizkPoK the proof generator and Verifzk the
verify algorithm for Rğ·ğ¿.
3 TWO-PARTY SIGNATURES FOR ECDSA
In this section, we present a two-party protocol 2ECDSA. We first
describe the distributed key generation phase that is executed once,
followed by the signing phase which may run multiple times. The
process is also illustrated in Fig. 3.
Let MtA be the multiplicative-to-additive functionality, nizkPoK
be the NIZK proof for discrete logarithm relation Rğ·ğ¿. Let H :
{0, 1}âˆ— â†’ {0, 1}ğœ… be a hash function.
Although we make a logical presentation of the signing proce-
dure in four phases, in the actual protocol they are intertwined. We
could reorder the messages in the instantiations such that messages
of MtA from ğ‘ƒ2 to ğ‘ƒ1 come first, followed by all messages from ğ‘ƒ1
to ğ‘ƒ2, which results in a 3-pass signing protocol.
Distributed Key Generation Phase Keygen(G, ğ‘ƒ, ğ‘).
Given the joint input (G, ğ‘ƒ, ğ‘) and security parameter ğœ†:
(1) ğ‘ƒ1â€™s first message:
â€¢ ğ‘ƒ1 chooses a random ğ‘¥1 â† Zğ‘, and computes ğ‘„1 = ğ‘¥1 Â· ğ‘ƒ
and nizk1 = nizkPoK(ğ‘„1, ğ‘¥1)
â€¢ ğ‘ƒ1 sends f1 = H(ğ‘„1, nizk1) to ğ‘ƒ2
(2) ğ‘ƒ2â€™s first message:
(3) ğ‘ƒ1â€™s second message:
â€¢ ğ‘ƒ2 chooses a random ğ‘¥2 â† Zğ‘, and computes ğ‘„2 = ğ‘¥2 Â· ğ‘ƒ
and nizk2 = nizkPoK(ğ‘„2, ğ‘¥2)
â€¢ ğ‘ƒ2 sends ğ‘„2, nizk2 to ğ‘ƒ1
â€¢ On receiving ğ‘„2, nizk2 from ğ‘ƒ2, ğ‘ƒ1 verifies nizk2. If Ver-
ifzk(nizk2)=0, abort
â€¢ Else, ğ‘ƒ1 sends ğ‘„1, nizk1 to ğ‘ƒ2
â€¢ On receiving ğ‘„1, nizk1 from ğ‘ƒ1, ğ‘ƒ2 verifies nizk1.
â€¢ If f1 â‰  H(ğ‘„1, nizk1) or Verifzk(nizk1)=0, abort.
â€¢ ğ‘ƒ1 computes ğ‘„ = ğ‘„1 + ğ‘„2, stores (ğ‘„, ğ‘¥1, ğ‘„1, ğ‘„2).
â€¢ ğ‘ƒ2 computes ğ‘„ = ğ‘„2 + ğ‘„1, stores (ğ‘„, ğ‘¥2, ğ‘„1, ğ‘„2).
(5) Compute output:
(4) ğ‘ƒ2â€™s verification:
Distributed Sign Phase Sign(sid, ğ‘š). They begin with the session
id sid, ğ‘š the message to be signed, and additive share of secret key.
The protocol is divided into 4 logical steps, and only the last one is
online.
â€¢ ğ‘ƒ1 has (ğ‘„, ğ‘¥1, ğ‘„1, ğ‘„2) as the output of Keygen, message ğ‘š
and session id sid.
â€¢ ğ‘ƒ2 has (ğ‘„, ğ‘¥2, ğ‘„1, ğ‘„2) as the output of Keygen, message ğ‘š
and session id sid.
(1) Commitment of ğ‘ƒ2â€™s nonce:
â€¢ ğ‘ƒ2 chooses a random ğ‘˜2 â† Zğ‘, and computes ğ‘…2 = ğ‘˜2 Â· ğ‘ƒ
with nizk3 = nizkPoK(ğ‘…2, ğ‘˜2)
â€¢ ğ‘ƒ2 computes and sends f2 = H(ğ‘…2, nizk3) to ğ‘ƒ1.
(2) MtA and Consistency Check:
â€¢ ğ‘ƒ1 chooses a random ğ‘¥â€²1 â† Zğ‘, and computes ğ‘„â€²1 = ğ‘¥â€²1 Â· ğ‘ƒ.
â€¢ ğ‘ƒ1 and ğ‘ƒ2 invoke the MtA functionality with input ğ‘¥â€²1 and
ğ‘˜2 respectively and receives ğ‘¡ğ´, ğ‘¡ğµ such that
ğ‘¡ğ´ + ğ‘¡ğµ = ğ‘¥â€²1ğ‘˜2 mod ğ‘.
â€¢ ğ‘ƒ1 chooses a random ğ‘Ÿ1 â† Zğ‘, and computes ğ‘ğ‘ := ğ‘¡ğ´ +
ğ‘¥â€²1ğ‘Ÿ1 âˆ’ ğ‘¥1 mod ğ‘ and sends (ğ‘Ÿ1, ğ‘ğ‘) to ğ‘ƒ2.
â€¢ ğ‘ƒ2 checks the consistency by checking
?
= (ğ‘Ÿ1 + ğ‘˜2) Â· ğ‘„â€²1 âˆ’ ğ‘„1.
(ğ‘¡ğµ + ğ‘ğ‘) Â· ğ‘ƒ
â€¢ if the consistency check passes, ğ‘ƒ2 computes
ğ‘¥â€²2 = ğ‘¥2 âˆ’ (ğ‘¡ğµ + ğ‘ğ‘) mod ğ‘.
(3) Nonce Key Exchange:
â€¢ ğ‘ƒ1 chooses a random ğ‘˜1 â† Zğ‘, computes and sends ğ‘…1 =
ğ‘˜1 Â· ğ‘ƒ with nizk4 = nizkPoK(ğ‘…1, ğ‘˜1) to ğ‘ƒ2.
â€¢ ğ‘ƒ2 aborts if Verifzk(nizk4)=0, otherwise sends (ğ‘…2, nizk3)
to ğ‘ƒ1 and computes ğ‘… = (ğ‘Ÿğ‘¥, ğ‘Ÿğ‘¦) = (ğ‘˜2+ğ‘Ÿ1)Â·ğ‘…1, and ğ‘Ÿ = ğ‘Ÿğ‘¥
mod ğ‘.
â€¢ ğ‘ƒ1 aborts if f2 â‰  H(ğ‘…2, nizk3) or Verifzk(nizk3)=0, other-
wise computes ğ‘… = (ğ‘Ÿğ‘¥, ğ‘Ÿğ‘¦) = ğ‘˜1 Â· ğ‘…2 + ğ‘˜1ğ‘Ÿ1 Â· ğ‘ƒ and ğ‘Ÿ = ğ‘Ÿğ‘¥
mod ğ‘.
(4) Online Signature:
â€¢ Given ğ‘š, ğ‘ƒ2 computes â„ = ğ»(ğ‘š) and sends
ğ‘ 2 = (ğ‘˜2 + ğ‘Ÿ1)âˆ’1(â„ + ğ‘Ÿğ‘¥â€²2) mod ğ‘
to ğ‘ƒ1.
â€¢ On receiving ğ‘ 2, ğ‘ƒ1 computes
ğ‘  = ğ‘˜âˆ’1
1 (ğ‘ 2 + ğ‘Ÿğ‘¥â€²1) mod ğ‘.
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea563â€¢ ğ‘ƒ1 aborts if Verify(ğ‘š; (ğ‘Ÿ, ğ‘ )) = 0, else returns (ğ‘Ÿ, ğ‘ ) as the
final signature.
Correctness. By the definition of ğ‘¥â€²2, we have
ğ‘¥â€²2 = ğ‘¥2 âˆ’ (ğ‘¡ğµ + ğ‘ğ‘)
= ğ‘¥2 âˆ’ (ğ‘¡ğµ + ğ‘¡ğ´ + ğ‘¥â€²1ğ‘Ÿ1 âˆ’ ğ‘¥1)
= ğ‘¥2 âˆ’ (ğ‘¥â€²1ğ‘˜2 + ğ‘¥â€²1ğ‘Ÿ1) + ğ‘¥1
over Zğ‘, thus ğ‘¥â€²1(ğ‘Ÿ1 + ğ‘˜2) + ğ‘¥â€²2 = ğ‘¥1 + ğ‘¥2 mod ğ‘.
Let ğ‘˜ := ğ‘˜1(ğ‘Ÿ1 + ğ‘˜2) mod ğ‘, then ğ‘… = ğ‘˜ Â· ğ‘ƒ. We have
(cid:2)
1 (ğ‘Ÿ1 + ğ‘˜2)âˆ’1(cid:2)ğ»(ğ‘š) + ğ‘Ÿ(ğ‘¥â€²2 + ğ‘¥â€²1ğ‘Ÿ1 + ğ‘¥â€²1ğ‘˜2)
(ğ‘Ÿ1 + ğ‘˜2)âˆ’1(ğ»(ğ‘š) + ğ‘Ÿğ‘¥â€²2) + ğ‘Ÿğ‘¥â€²1
(cid:3)
(cid:3)
ğ‘  = ğ‘˜âˆ’1
1 (ğ‘ 2 + ğ‘Ÿğ‘¥â€²1)
= ğ‘˜âˆ’1
1
= ğ‘˜âˆ’1
= ğ‘˜âˆ’1
= ğ‘˜âˆ’1
1 (ğ‘Ÿ1 + ğ‘˜2)âˆ’1 [ğ»(ğ‘š) + ğ‘Ÿ(ğ‘¥1 + ğ‘¥2)]
1 (ğ‘Ÿ1 + ğ‘˜2)âˆ’1(ğ»(ğ‘š) + ğ‘Ÿğ‘¥)
over Zğ‘. Thus, (ğ‘Ÿ, ğ‘ ) is a valid signature of ğ‘š.
3.1 Security of 2ECDSA
Theorem 3.1. The two-party 2ECDSA protocol in Figure 3 securely
computes FECDSA in the random oracle model in the presence of a
malicious static adversary under the real/ideal definition. Concretely,
there exists a simulator for the scheme such that any probabilistic
polynomial time adversary, who corrupted ğ‘ƒ1 or ğ‘ƒ2, can distinguish a
real execution of the protocol from a simulated one with only negligible
probability.
We present a sketch of the proof here. Please refer to Appendix
B for the full proof.
Simulator S could only access an ideal functionality FECDSA for
computing ECDSA signatures. All S learns in the ideal world is
the public key ğ‘„ generated in the key generation phase and several
signatures (ğ‘Ÿ, ğ‘ ) for messages ğ‘š of its choice in the signing phase. In
the real world, the adversary, having either corrupted ğ‘ƒ1 or ğ‘ƒ2 will
also see all the interactions with the non-corrupted party. Thus S
must be able to simulate the adversaryâ€™s view of these interactions,
while only knowing the expected output.
The proof proceeds in two cases: the adversary corrupts ğ‘ƒ1, and
the adversary corrupts ğ‘ƒ2.
S simulates ğ‘ƒ2- Corrupted ğ‘ƒ1. In the key generation phase, after
receiving public key ğ‘„ from FECDSA and receiving f1 from A, S
could extract ğ‘„1, nizk1 such that f1 = H(ğ‘„1, nizk1) in the random
oracle model with overwhelming probability. Furthermore, if nizk1
is accepted, there exists knowledge extractor to successfully output
ğ‘¥1. Then, S computes ğ‘„2 = ğ‘„ âˆ’ ğ‘„1 and generates nizk2 by query-
ing the zero knowledge simulator Sim. The indistinguishability
between the simulated and real key generation is obvious.
During the signing phase, S could receive a signature (ğ‘Ÿ, ğ‘ ) of
message ğ‘š from FECDSA, and recover ğ‘… via verification algorithm.
(1) S invokes A with a totally random f2.
(2) S interacts with A on behave of FMtA and in doing so re-
ceives its input ğ‘¥â€²1 and output shares ğ‘¡ğ´. S checks the consis-
?
tency of ğ‘„â€²1, ğ‘Ÿ1, ğ‘ğ‘ received from A by verifying ğ‘„â€²1
= ğ‘¥â€²1 Â· ğ‘ƒ
and ğ‘ğ‘
?
= ğ‘¡ğ´ + ğ‘¥â€²1ğ‘Ÿ1 âˆ’ ğ‘¥1 mod ğ‘.
(3) On receiving ğ‘…1, nizk4, S sets ğ‘…2 = ğ‘˜âˆ’1
1
Â· ğ‘… âˆ’ ğ‘Ÿ1 Â· ğ‘ƒ (where ğ‘˜1
is extracted from accepting proof nizk4). S generates nizk3
to A by querying zero knowledge simulator Sim. Then, it
puts (ğ‘…2||nizk3, f2) into the hash list of H to indicate that
f2 = H(ğ‘…2, nizk3).
(4) After extracting ğ‘˜1 from nizk4, ğ‘ 2 = ğ‘˜1ğ‘  âˆ’ ğ‘¥â€²1ğ‘Ÿ mod ğ‘ could
be easily computed from ğ‘ , ğ‘¥â€²1 and ğ‘˜1.
Note that S would abort if any of the checks does not pass.
The difference between a real execution and the simulation is
how ğ‘…2 and ğ‘ 2 are computed, and the consistency of ğ‘„â€²1 and ğ‘¥â€²1
is check. In the simulation, ğ‘…2 is ğ‘˜âˆ’1
Â· ğ‘… âˆ’ ğ‘Ÿ1 Â· ğ‘ƒ whereas in the
1
real execution ğ‘…2 = ğ‘˜2 Â· ğ‘ƒ where ğ‘˜2 â† Zğ‘. Since FECDSA samples
ğ‘… uniformly at random from G, the distribution in both cases is
identical. Ext extracts ğ‘˜1 with knowledge error 1/ğ‘. Conditional on
the correctness of ğ‘˜1, in the simulation
ğ‘ 2 = ğ‘˜1ğ‘  âˆ’ ğ‘¥â€²1ğ‘Ÿ = (ğ‘Ÿ1 + ğ‘˜2)âˆ’1(ğ»(ğ‘š) + ğ‘Ÿğ‘¥â€²2) mod ğ‘
which is identical to that in the real execution. The conditions
ğ‘„â€²1 = ğ‘¥â€²1 Â· ğ‘ƒ and ğ‘ğ‘ = ğ‘¡ğ´ + ğ‘¥â€²1ğ‘Ÿ1 âˆ’ ğ‘¥1 mod ğ‘ in the simulation are
equivalent to (ğ‘¡ğµ + ğ‘ğ‘) Â· ğ‘ƒ = (ğ‘Ÿ1 + ğ‘˜2) Â· ğ‘„â€²1 âˆ’ ğ‘„1 in the real game.
This implies that the view of a corrupted ğ‘ƒ1 in the real execution
is indistinguishable from that of the simulation, i.e., the advantage of
any PPT adversary who corrupts ğ‘ƒ1 to distinguish the real execution
and simulated execution given by S is negligible.
S simulates ğ‘ƒ1- Corrupted ğ‘ƒ2. After receiving public key ğ‘„
from FECDSA, S invokes A with a totally random f1, and receives
(ğ‘„2, nizk2). After extracting ğ‘¥2 from the accepting proof nizk2, S
computes ğ‘„1 = ğ‘„ âˆ’ ğ‘„2 and nizk1 by querying zero knowledge
simulator Sim. Then S fixes the computation of f1 with random
oracle, and sends ğ‘„1, nizk1 to A. The indistinguishability between
the simulated and real key generation is obvious.
During the signing phase, S could receive a signature (ğ‘Ÿ, ğ‘ ) of
message ğ‘š from FECDSA, and recover ğ‘… via verification algorithm.
(1) S invokes A with Sign(sid, ğ‘š) and receives f2 from A. Then,
S could extract ğ‘…2, nizk3 and further ğ‘˜2 such that f2 = H(ğ‘…2, nizk3)
and ğ‘…2 = ğ‘˜2 Â· ğ‘ƒ with overwhelming probability with the help
of random oracle and knowledge extractor (if the proof is
accepted).
(2) S interacts with A on behave of FMtA and in doing so re-
ceives its input ğ‘˜â€²2 and output shares ğ‘¡ğµ. S samples a random
ğ‘Ÿ1 â† Zğ‘ and a random ğ‘ğ‘ â† Zğ‘, computes
ğ‘„â€²1 = (ğ‘˜â€²2 + ğ‘Ÿ1)âˆ’1[(ğ‘¡ğµ + ğ‘ğ‘) Â· ğ‘ƒ + ğ‘„1],
and sends ğ‘„â€²1, ğ‘Ÿ1, ğ‘ğ‘ to A.
zero knowledge simulator Sim, and sends them to A.
of ğ‘˜â€²2 with ğ‘…2
(3) S computes ğ‘…1 = (ğ‘Ÿ1+ğ‘˜2)âˆ’1Â·ğ‘…, generates nizk4 by querying
(4) On receiving (ğ‘…2, nizk3) from A, S checks the consistency
(5) S checks the correctness of ğ‘ 2 by verifying
ğ‘ 2 Â· (ğ‘Ÿ1 Â· ğ‘ƒ + ğ‘…2)
?
= â„ Â· ğ‘ƒ + ğ‘Ÿ Â· (ğ‘¥2 âˆ’ ğ‘¡ğµ âˆ’ ğ‘ğ‘) Â· ğ‘ƒ,
where â„ = ğ»(ğ‘š). If all the check conditions pass, S would
output (ğ‘Ÿ, ğ‘ ) as output.
Note that S would abort if any of the checks does not pass.
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea564Figure 3: Two-party protocol 2ECDSA from a single MtA.
ğ‘ƒ1ğ‘ƒ2............................................Keygen(G,ğ‘ƒ,ğ‘)............................................ğ‘¥1â†Zğ‘,ğ‘„1=ğ‘¥1Â·ğ‘ƒnizk1:=nizkPoK(ğ‘„1,ğ‘¥1)f1:=H(ğ‘„1,nizk1)âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ğ‘¥2â†Zğ‘,ğ‘„2=ğ‘¥2Â·ğ‘ƒifVerifzk(nizk2)=0,returnâŠ¥ğ‘„2,nizk2â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’nizk2:=nizkPoK(ğ‘„2,ğ‘¥2)ğ‘„1,nizk1âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’iff1â‰ H(ğ‘„1,nizk1),returnâŠ¥ifVerifzk(nizk1)=0,returnâŠ¥ğ‘„=ğ‘„1+ğ‘„2ğ‘„=ğ‘„1+ğ‘„2..............................................Sign(sid,ğ‘š)..............................................(1)Commitğ‘ƒ2â€™sNonceğ‘˜2â†Zğ‘,ğ‘…2=ğ‘˜2Â·ğ‘ƒf2:=H(ğ‘…2,nizk3)â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’nizk3:=nizkPoK(ğ‘…2,ğ‘˜2)(2)MtAandConsistencyğ‘¥â€²1â†Zğ‘,ğ‘„â€²1=ğ‘¥â€²1Â·ğ‘ƒğ‘¥â€²1âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ğ‘˜2â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’MtAğ‘¡ğ´â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’ğ‘¡ğµâˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ğ‘Ÿ1â†Zğ‘ğ‘ğ‘=ğ‘¡ğ´+ğ‘¥â€²1ğ‘Ÿ1âˆ’ğ‘¥1modğ‘ğ‘„â€²1,ğ‘Ÿ1,ğ‘ğ‘âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’if(ğ‘¡ğµ+ğ‘ğ‘)ğ‘ƒ=(ğ‘Ÿ1+ğ‘˜2)ğ‘„â€²1âˆ’ğ‘„1ğ‘¥â€²2=ğ‘¥2âˆ’(ğ‘¡ğµ+ğ‘ğ‘)modğ‘(3)NonceKEğ‘˜1â†Zğ‘,ğ‘…1=ğ‘˜1Â·ğ‘ƒnizk4:=nizkPoK(ğ‘…1,ğ‘˜1)ğ‘…1,nizk4âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’ifVerifzk(nizk4)=0,returnâŠ¥iff2â‰ H(ğ‘…2,nizk3),returnâŠ¥ğ‘…2,nizk3â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’ğ‘…:=(ğ‘Ÿ1+ğ‘˜2)Â·ğ‘…1ifVerifzk(nizk3)=0,returnâŠ¥ğ‘…:=ğ‘˜1Â·ğ‘…2+ğ‘˜1ğ‘Ÿ1Â·ğ‘ƒ(4)OnlineSignğ‘ =ğ‘˜âˆ’11(ğ‘ 2+ğ‘Ÿğ‘¥â€²1)modğ‘ğ‘ 2â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’ğ‘ 2=(ğ‘Ÿ1+ğ‘˜2)âˆ’1(ğ»(ğ‘š)+ğ‘Ÿğ‘¥â€²2)modğ‘ifVerify(ğ‘š;(ğ‘Ÿ,ğ‘ ))=0,returnâŠ¥elsereturn(ğ‘Ÿ,ğ‘ )Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea565The difference between a real execution and the simulation is
how ğ‘…1 and ğ‘„â€²1 are computed, and the condition that (ğ‘Ÿ, ğ‘ ) is output
or not.
In the simulation, ğ‘…1 is ğ‘…1 = (ğ‘Ÿ1 + ğ‘˜2)âˆ’1 Â· ğ‘… whereas in the
real execution ğ‘…1 = ğ‘˜1 Â· ğ‘ƒ where ğ‘˜1 â† Zğ‘. Since FECDSA samples
ğ‘… uniformly at random from G, the distribution in both cases is
identical. In the simulation, ğ‘„â€²1 is (ğ‘˜â€²2 + ğ‘Ÿ1)âˆ’1[(ğ‘¡ğµ + ğ‘ğ‘) Â· ğ‘ƒ + ğ‘„1]
whereas in the real execution ğ‘„â€²1 = ğ‘¥â€²1 Â· ğ‘ƒ for ğ‘¥â€²1 â† Zğ‘. Since ğ‘Ÿ1 and
ğ‘ğ‘ are sampled randomly and the consistency check always passes,
the distribution in both cases is identical.
In the real execution, the Verify algorithm checks that ğ‘  Â· ğ‘…
â„ Â· ğ‘ƒ + ğ‘Ÿ Â· ğ‘„, which holds if and only if the following holds,
?
=
ğ‘ƒ1
Setup
Multiplication