side of the rule encodes that ˜ltkA is sent on the network,
effectively adding it to the adversary’s knowledge. Addition-
ally, we log the action RevLtk($A), which will enable us
to restrict this capability in the property speciﬁcations.
The model described in this and the previous section
describes the behaviour of the TLS 1.3 protocol in the
presence of an active network adversary. The Tamarin model
assumes the standard black-box cryptography assumption,
as outlined in Section 3.2. This view simpliﬁes the proofs
and enables the analysis of many different security contexts.
In the two following sections, we model and verify the
required secrecy and authentication properties.
4.2. Secrecy properties and results
We formally model and analyse two main secrecy prop-
erties. The ﬁrst is the secrecy of session keys that implies
perfect forward secrecy in the presence of an active adversary.
The formal property that we verify is:
lemma secret_session_keys:
(1) "All actor peer role k #i.
(2)
(3)
SessionKey(actor, peer, role, )@i
& not ((Ex #r. RevLtk(peer)@r
& #r  not Ex #j. KU(k)@j"
(4)
Intuitively, the above property requires that for all protocol
behaviours and for all possible values of the variables on
the ﬁrst line (All) (1): if an authenticated session key k is
accepted (encoded by the occurrence of the SessionKey
action) (2), and the adversary has not revealed the long-term
private keys of the actor or the peer before the session key
is accepted (3), then the adversary can not derive the key k
(4).
Our way of modelling this property is very ﬂexible. In the
unilaterally authenticated mode, only the client establishes a
session key with the ﬂag authenticated. In the mutually
authenticated mode, both roles log this action. These actions
can also be used to verify the appropriate secrecy properties.
As we will see later, this is also suitable for the more ﬂexible
delayed client authentication modes that will be allowed in
the ﬁnal TLS 1.3 speciﬁcation.
The second property that we prove is that the client’s
early data keys are secure as long as the long-term private
key of the server is not revealed.
lemma secret_early_data_keys:
(1) "All actor peer k #i.
(2)
(3)
(4)
In particular, each time (1) that a client logs that it has
produced an early data key (2) and the peer’s long-term
private keys are not compromised (3), then the adversary
does not know the early data key (4).
EarlyDataKey(actor, peer, ’client’, k)@i
& not
==> not Ex #j. KU(k)@j"
(Ex #r. RevLtk(peer)@r)
Proof approach in Tamarin. Many of the security proper-
ties of TLS stem from the secrecy of the shared secrets, i.e.
479479
the ephemeral secret (es) and the static secret (ss). Proving
the secrecy of these components initially seems simple; at
its core, the main TLS mechanism includes an authenticated
Difﬁe–Hellman exchange. However, complications arise due
to the interactions between different handshake modes in
an unbounded number of sessions and connections, and
powerful adversarial interference.
As a ﬁrst step, it is necessary to prove a few fundamental
invariant properties. These help all future proofs by either
reducing the number of contradictory dead-ends which
the prover would otherwise explore, or to help skip some
common intermediate steps. In particular, it is essential to
apply some straightforward inductive proofs to avoid falling
into the many inﬁnite loops present.
From here, simple auxiliary lemmas can be constructed.
These lemmas help us piece together the more complicated
proofs in a modular way. For example, a common deduction
uses the fact that knowledge of the PSK implies that the
adversary must also have knowledge of some (ss, es) pair
from a previous handshake.
Ideally, the auxiliary lemmas are sufﬁciently small and
incremental that they can be proved automatically. Since
each describes a small property which is likely to remain
consistent throughout model changes, these can be used
to quickly incorporate changes and reproduce proofs. The
proofs for secrecy of ss and es follow from the auxiliary
lemmas in a more manageable way than would otherwise be
the case. The main burden of proof is to unravel the client
and server states to a point where the adversary needs to
break the standard Difﬁe-Hellman assumptions, or else the
secrecy follows from inductive reasoning.
Finally, the proof of session-key secrecy then follows
from the secrecy proofs for the ss and es values, which
are both used as key-derivation inputs. Using this approach,
we successfully verify these properties in Tamarin for the
full interaction between the modes modelled.
We note that the construction of the auxiliary lemmas
and the proving of the secrecy of ss and es requires an
intimate knowledge of TLS 1.3 and a great deal of ingenuity;
this part of the analysis is not a straightforward application
of the Tamarin tool. Considerable interaction with the tool
is required so as to correctly guide it through the proof trees
of the respective ss and es lemmas.
Separation of properties. One of the decisions made when
specifying the security properties was to separate the secrecy
and authentication requirements. Note that we could have
equally combined both into a single property, as commonly
deﬁned in AKE models.
The beneﬁt of this approach is twofold. First of all,
separating the properties results in a richer understanding of
the security of the protocol. For example, the structure of the
proof conﬁrms the intuition that the secrecy of session keys
depends largely on the use of a Difﬁe-Hellman exchange.
The second beneﬁt of this approach is to provide a better
foundation for future analysis. While our current model
considers the security of all handshake modes equally, there
are some discrepancies in the guarantees provided by the
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:43 UTC from IEEE Xplore.  Restrictions apply. 
various handshake modes. For example, if we were to allow
adversarial compromise of semi-static secrets such as PSKs
and server semi-static DH exponents, we would discover
that the secrecy of the static secret is not immediate in all
handshake modes. By keeping the properties separate, it will
be easier to move to a more nuanced security model in the
future.
4.3. Authentication properties and results
The fourth property is analogous to the second, and en-
sures that the server obtains a guarantee on the agreement on
the transcript with the client, after it has been authenticated.
lemma mutual_transcript_agreement:
"All actor peer transcript #i.
CommitTranscript(actor, peer, ’server’, transcript)@i
& not ((Ex #r. RevLtk(peer)@r)
|(Ex #r. RevLtk(actor)@r))
==> (Ex #j.
RunningTranscript(peer, actor, ’client’, transcript)@j
& #j  (Ex #j peer2.
(5) RunningNonces(peer, peer2, ’server’, nonces)@j
(6) & #j  (Ex #j peer2.
RunningTranscript(peer, peer2, ’server’, transcript)@j
& #j  (Ex #j.
RunningNonces(peer, actor, ’client’, nonces)@j
& #j < #i)"
480480
Implicit authentication. In building the series of lemmas
which lead to the ﬁnal security properties, the most prob-
lematic areas coincided with the PSK modes. In particular,
the security of the PSK handshake relies on knowing that
the resumption secret can only be known by a previous
communication partner. This is the implicit authentication
property.
While we were able to overcome this challenge and
eventually prove that this property holds, it does identify a
potentially troublesome component to analyse. As we will
see in the next section, the PSK mode certainly requires
close attention.
We note that there are a plethora of entity authentication
algorithms which could be used to add an explicit authenti-
cation step to the session resumption mechanism, some of
which can be found in [25].
4.4. Analysis conclusions
Our model from Section 3 covers many possible complex
interactions between the various modes, for an unbounded
number of sessions. When combined with the security proper-
ties in this section, this gives rise to very complex veriﬁcation
problems. Nevertheless, we managed to successfully prove
the main properties. Our results imply the absence of a large
class of attacks, many of which are not covered by other
analysis methods, e.g., attacks that exploit the interaction
between the various modes. This is a very encouraging result,
since it shows that the core design underlying draft-10
is solid.
Despite this, the late addition of new functionalities can
still be problematic, as will become clear in the next section.
5. Enabling client authentication in PSK mode
While draft-10 does not yet appear
to permit
certiﬁcate-based client authentication in PSK mode (and
in particular in resumption using a PSK), we extended our
model as speciﬁed in one of the proposals for this intended
functionality [46].
By enabling client authentication either in the initial
handshake, or with a post-handshake signature over the
handshake hash, our Tamarin analysis ﬁnds an attack. The
result is a violation of client authentication, as the adversary
can impersonate a client when communicating with a server.
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:43 UTC from IEEE Xplore.  Restrictions apply. 
(As server Charlie)
(As client Alice)
Client Alice
Initial handshake 1
Client not authenticated, PSK1 exchanged
Generate nc
Charlie
Reuse psk id
Server Bob
Initial handshake 2
Client not authenticated, PSK2 exchanged
Start PSK1 resumption
Reuse nc, psk id
Start PSK2 resumption
client_random = nc
session_ticket = psk id
client_random = nc
session_ticket = psk id
Generate ns
Accept PSK1 resumption
Recompute Finished
Accept PSK2 resumption
server_random = ns
Reuse ns
server_random = ns
PSK1 resumption done
Recompute Finished
PSK2 resumption done
Compute session keys
based on PSK1
Compute session keys
based on PSK1, PSK2
Compute session keys
based on PSK2
Client authentication request
Re-encrypt
Client authentication request
Client authentication
Certiﬁcate = CertAlice
CertiﬁcateVerify =
sign(nc, ns, psk id, CertAlice, . . .)
Re-encrypt
Client authentication
Certiﬁcate = CertAlice
CertiﬁcateVerify =
sign(nc, ns, psk id, CertAlice, . . .)
Alice is in a session with me (Bob).
Only Alice knows the session keys.
Application data exchange
Charlie impersonates Alice
Figure 8. Client impersonation attack on TLS 1.3 draft-10 if delayed client authentication allowed in PSK mode. The attack involves two handshakes,
two resumptions, and a client authentication request. A full explanation is given in Section 5.1.
481481
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:17:43 UTC from IEEE Xplore.  Restrictions apply. 
5.1. The attack
We note that the attack as described here is for the
delayed authentication setting, but can easily be adapted for
authentication as part of the handshake.
We now describe the attack depicted in Figure 8 in more
detail: Alice plays the role of the victim client, and Bob the
role of the targeted server. Charlie is an active man-in-the-
middle adversary, whom Alice believes to be a legitimate
server. In the interest of clarity we have omitted message
components and computations which are not relevant to the
attack. The full attack can be reproduced using our code at
[1].
The attack proceeds in three main steps, each involving
different TLS subprotocols.
Step 1: Establish legitimate PSKs. In the ﬁrst stage of the
attack, Alice starts a connection with Charlie, and Charlie
starts a connection with Bob. In both connections, a PSK
is established. At this point, both handshakes are computed
honestly. Alice shares a PSK denoted PSK1 with Charlie,
and Charlie shares a PSK denoted PSK2 with Bob.
Note that Charlie ensures the session ticket (psk id) is
the same across both connections by replaying the value
obtained from Bob.
Step 2: Resumption with matching freshness. In the next
step, Alice wishes to resume a connection with Charlie using
PSK1. As usual, Alice generates a random nonce nc, and
sends it together with the PSK identiﬁer, psk id.
Charlie re-uses the value nc to initiate a PSK-resumption
handshake with Bob, using the same identiﬁer, psk id. Bob
responds with a random nonce ns, and the server Finished
message, computed using PSK2.
Charlie now re-uses the nonce ns, and recomputes the
server Finished message using PSK1. Alice returns her
Finished message to Charlie, who recomputes it using
PSK2.
At this point, Alice and Charlie share session keys (i.e.,
application trafﬁc keys) derived from PSK1, and Charlie and
Bob share session keys derived from PSK2. Note that the
keys that Charlie shares with Alice and with Bob respectively,
are distinct.
Step 3: Delayed client authentication. Following the re-
sumption handshake, Charlie attempts to make a request to
Bob over their established TLS channel. The request calls for
client authentication, so Charlie is subsequently prompted
for his certiﬁcate and veriﬁcation3. Charlie re-encrypts this
request for Alice.
To compute the veriﬁcation signature, Alice uses the
session_hash value, which is deﬁned as the hash of