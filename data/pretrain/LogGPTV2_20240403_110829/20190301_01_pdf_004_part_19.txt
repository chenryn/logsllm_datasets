DBMS_OUTPUT.PUT_LINE('BLOCK level_0');
level_1b;
DBMS_OUTPUT.PUT_LINE('END BLOCK level_0');
END level_0;
The following is the resulting output:
BEGIN
level_0;
END;
BLOCK level_0
.. BLOCK level_1b
.. BLOCK level_1a
.. END BLOCK level_1a
.. END BLOCK level_1b
END BLOCK level_0
In the following example, procedure level_1a, which is the sibling of procedure
level_1b, which is an ancestor of procedure level_3b is successfully invoked.
CREATE OR REPLACE PROCEDURE level_0
IS
PROCEDURE level_1a
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('.. BLOCK level_1a');
DBMS_OUTPUT.PUT_LINE('.. END BLOCK level_1a');
END level_1a;
PROCEDURE level_1b
IS
PROCEDURE level_2b
IS
PROCEDURE level_3b
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('........ BLOCK level_3b');
level_1a; -- Ancestor's sibling block called
level_0.level_1a; -- Qualified ancestor's sibling block
DBMS_OUTPUT.PUT_LINE('........ END BLOCK level_3b');
END level_3b;
BEGIN
DBMS_OUTPUT.PUT_LINE('...... BLOCK level_2b');
level_3b; -- Local block called
DBMS_OUTPUT.PUT_LINE('...... END BLOCK level_2b');
END level_2b;
BEGIN
DBMS_OUTPUT.PUT_LINE('.. BLOCK level_1b');
level_2b; -- Local block called
DBMS_OUTPUT.PUT_LINE('.. END BLOCK level_1b');
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 165
Database Compatibility for Oracle® Developers Guide
END level_1b;
BEGIN
DBMS_OUTPUT.PUT_LINE('BLOCK level_0');
level_1b;
DBMS_OUTPUT.PUT_LINE('END BLOCK level_0');
END level_0;
The following is the resulting output:
BEGIN
level_0;
END;
BLOCK level_0
.. BLOCK level_1b
...... BLOCK level_2b
........ BLOCK level_3b
.. BLOCK level_1a
.. END BLOCK level_1a
.. BLOCK level_1a
.. END BLOCK level_1a
........ END BLOCK level_3b
...... END BLOCK level_2b
.. END BLOCK level_1b
END BLOCK level_0
3.2.6.5 Using Forward Declarations
As discussed so far, when a subprogram is to be invoked, it must have been declared
somewhere in the hierarchy of blocks within the standalone program, but prior to where it
is invoked. In other words, when scanning the SPL code from beginning to end, the
subprogram declaration must be found before its invocation.
However, there is a method of constructing the SPL code so that the full declaration of
the subprogram (that is, its optional declaration section, its mandatory executable section,
and optional exception section) appears in the SPL code after the point in the code where
it is invoked.
This is accomplished by inserting a forward declaration in the SPL code prior to its
invocation. The forward declaration is the specification of a subprocedure or subfunction
name, formal parameters, and return type if it is a subfunction.
The full subprogram specification consisting of the optional declaration section, the
executable section, and the optional exception section must be specified in the same
declaration section as the forward declaration, but may appear following other
subprogram declarations that invoke this subprogram with the forward declaration.
Typical usage of a forward declaration is when two subprograms invoke each other as
shown by the following:
DECLARE
FUNCTION add_one (
p_add IN NUMBER
) RETURN NUMBER;
FUNCTION test_max (
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 166
Database Compatibility for Oracle® Developers Guide
p_test IN NUMBER)
RETURN NUMBER
IS
BEGIN
IF p_test < 5 THEN
RETURN add_one(p_test);
END IF;
DBMS_OUTPUT.PUT('Final value is ');
RETURN p_test;
END;
FUNCTION add_one (
p_add IN NUMBER)
RETURN NUMBER
IS
BEGIN
DBMS_OUTPUT.PUT_LINE('Increase by 1');
RETURN test_max(p_add + 1);
END;
BEGIN
DBMS_OUTPUT.PUT_LINE(test_max(3));
END;
Subfunction test_max invokes subfunction add_one, which also invokes subfunction
test_max, so a forward declaration is required for one of the subprograms, which is
implemented for add_one at the beginning of the anonymous block declaration section.
The resulting output from the anonymous block is as follows:
Increase by 1
Increase by 1
Final value is 5
3.2.6.6 Overloading Subprograms
Generally, subprograms of the same type (subprocedure or subfunction) with the same
name, and same formal parameter specification can appear multiple times within the
same standalone program as long as they are not sibling blocks (that is, the subprograms
are not declared in the same local block).
Each subprogram can be individually invoked depending upon the use of qualifiers and
the location where the subprogram invocation is made as discussed in the previous
sections.
It is however possible to declare subprograms, even as siblings, that are of the same
subprogram type and name as long as certain aspects of the formal parameters differ.
These characteristics (subprogram type, name, and formal parameter specification) is
generally known as a program’s signature.
The declaration of multiple subprograms where the signatures are identical except for
certain aspects of the formal parameter specification is referred to as subprogram
overloading.
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 167
Database Compatibility for Oracle® Developers Guide
Thus, the determination of which particular overloaded subprogram is to be invoked is
determined by a match of the actual parameters specified by the subprogram invocation
and the formal parameter lists of the overloaded subprograms.
Any of the following differences permit overloaded subprograms:
 The number of formal parameters are different.
 At least one pair of data types of the corresponding formal parameters (that is,
compared according to the same order of appearance in the formal parameter list)
are different, but are not aliases. Data type aliases are discussed later in this
section.
Note that the following differences alone do not permit overloaded subprograms:
 Different formal parameter names
 Different parameter modes (IN, IN OUT, OUT) for the corresponding formal
parameters
 For subfunctions, different data types in the RETURN clause
As previously indicated, one of the differences allowing overloaded subprograms are
different data types.
However, certain data types have alternative names referred to as aliases, which can be
used for the table definition.
For example, there are fixed length character data types that can be specified as CHAR or
CHARACTER. There are variable length character data types that can be specified as CHAR
VARYING, CHARACTER VARYING, VARCHAR, or VARCHAR2. For integers, there are
BINARY_INTEGER, PLS_INTEGER, and INTEGER data types. For numbers, there are
NUMBER, NUMERIC, DEC, and DECIMAL data types.
For detailed information about the data types supported by Advanced Server, please see
the Database Compatibility for Oracle Developers Reference Guide, available from
EnterpriseDB at:
https://www.enterprisedb.com/resources/product-documentation
Thus, when attempting to create overloaded subprograms, the formal parameter data
types are not considered different if the specified data types are aliases of each other.
It can be determined if certain data types are aliases of other types by displaying the table
definition containing the data types in question.
For example, the following table definition contains some data types and their aliases.
CREATE TABLE data_type_aliases (
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 168
Database Compatibility for Oracle® Developers Guide
dt_BLOB BLOB,
dt_LONG_RAW LONG RAW,
dt_RAW RAW(4),
dt_BYTEA BYTEA,
dt_INTEGER INTEGER,
dt_BINARY_INTEGER BINARY_INTEGER,
dt_PLS_INTEGER PLS_INTEGER,
dt_REAL REAL,
dt_DOUBLE_PRECISION DOUBLE PRECISION,
dt_FLOAT FLOAT,
dt_NUMBER NUMBER,
dt_DECIMAL DECIMAL,
dt_NUMERIC NUMERIC,
dt_CHAR CHAR,
dt_CHARACTER CHARACTER,
dt_VARCHAR2 VARCHAR2(4),
dt_CHAR_VARYING CHAR VARYING(4),
dt_VARCHAR VARCHAR(4)
);
Using the PSQL \d command to display the table definition, the Type column displays
the data type internally assigned to each column based upon its data type in the table
definition:
\d data_type_aliases
Column | Type | Modifiers
---------------------+----------------------+-----------
dt_blob | bytea |
dt_long_raw | bytea |
dt_raw | bytea(4) |
dt_bytea | bytea |
dt_integer | integer |
dt_binary_integer | integer |
dt_pls_integer | integer |
dt_real | real |
dt_double_precision | double precision |
dt_float | double precision |
dt_number | numeric |
dt_decimal | numeric |
dt_numeric | numeric |
dt_char | character(1) |
dt_character | character(1) |
dt_varchar2 | character varying(4) |
dt_char_varying | character varying(4) |
dt_varchar | character varying(4) |
In the example, the base set of data types are bytea, integer, real, double
precision, numeric, character, and character varying.
When attempting to declare overloaded subprograms, a pair of formal parameter data
types that are aliases would not be sufficient to allow subprogram overloading. Thus,
parameters with data types INTEGER and PLS_INTEGER cannot overload a pair of
subprograms, but data types INTEGER and REAL, or INTEGER and FLOAT, or INTEGER
and NUMBER can overload the subprograms.
Note: The overloading rules based upon formal parameter data types are not compatible
with Oracle databases. Generally, the Advanced Server rules are more flexible, and
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 169
Database Compatibility for Oracle® Developers Guide
certain combinations are allowed in Advanced Server that would result in an error when
attempting to create the procedure or function in Oracle databases.
For certain pairs of data types used for overloading, casting of the arguments specified by
the subprogram invocation may be required to avoid an error encountered during runtime
of the subprogram. Invocation of a subprogram must include the actual parameter list that
can specifically identify the data types. Certain pairs of overloaded data types may
require the CAST function to explicitly identify data types. For example, pairs of
overloaded data types that may require casting during the invocation are CHAR and
VARCHAR2, or NUMBER and REAL.
The following example shows a group of overloaded subfunctions invoked from within
an anonymous block. The executable section of the anonymous block contains the use of
the CAST function to invoke overloaded functions with certain data types.
DECLARE
FUNCTION add_it (
p_add_1 IN BINARY_INTEGER,
p_add_2 IN BINARY_INTEGER
) RETURN VARCHAR2
IS
BEGIN
RETURN 'add_it BINARY_INTEGER: ' || TO_CHAR(p_add_1 + p_add_2,9999.9999);
END add_it;
FUNCTION add_it (
p_add_1 IN NUMBER,
p_add_2 IN NUMBER
) RETURN VARCHAR2
IS
BEGIN
RETURN 'add_it NUMBER: ' || TO_CHAR(p_add_1 + p_add_2,999.9999);
END add_it;
FUNCTION add_it (
p_add_1 IN REAL,
p_add_2 IN REAL
) RETURN VARCHAR2
IS
BEGIN
RETURN 'add_it REAL: ' || TO_CHAR(p_add_1 + p_add_2,9999.9999);
END add_it;
FUNCTION add_it (
p_add_1 IN DOUBLE PRECISION,
p_add_2 IN DOUBLE PRECISION
) RETURN VARCHAR2
IS
BEGIN
RETURN 'add_it DOUBLE PRECISION: ' || TO_CHAR(p_add_1 + p_add_2,9999.9999);
END add_it;
BEGIN
DBMS_OUTPUT.PUT_LINE(add_it (25, 50));
DBMS_OUTPUT.PUT_LINE(add_it (25.3333, 50.3333));
DBMS_OUTPUT.PUT_LINE(add_it (TO_NUMBER(25.3333), TO_NUMBER(50.3333)));
DBMS_OUTPUT.PUT_LINE(add_it (CAST('25.3333' AS REAL), CAST('50.3333' AS REAL)));
DBMS_OUTPUT.PUT_LINE(add_it (CAST('25.3333' AS DOUBLE PRECISION),
CAST('50.3333' AS DOUBLE PRECISION)));
END;
The following is the output displayed from the anonymous block:
add_it BINARY_INTEGER: 75.0000
add_it NUMBER: 75.6666
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 170
Database Compatibility for Oracle® Developers Guide
add_it NUMBER: 75.6666
add_it REAL: 75.6666
add_it DOUBLE PRECISION: 75.6666
3.2.6.7 Accessing Subprogram Variables
Variable declared in blocks such as subprograms or anonymous blocks can be accessed
from the executable section or the exception section of other blocks depending upon their
relative location.
Accessing a variable means being able to reference it within a SQL statement or an SPL
statement as is done with any local variable.
Note: If the subprogram signature contains formal parameters, these may be accessed in
the same manner as local variables of the subprogram. In this section, all discussion
related to variables of a subprogram also applies to formal parameters of the subprogram.
Access of variables not only includes those defined as a data type, but also includes
others such as record types, collection types, and cursors.
The variable may be accessed by at most one qualifier, which is the name of the
subprogram or labeled anonymous block in which the variable has been locally declared.
The syntax to reference a variable is shown by the following:
[qualifier.]variable
If specified, qualifier is the subprogram or labeled anonymous block in which
variable has been declared in its declaration section (that is, it is a local variable).
Note: In Advanced Server, there is only one circumstance where two qualifiers are
permitted. This scenario is for accessing public variables of packages where the reference
can be specified in the following format:
schema_name.package_name.public_variable_name
For more information about supported package syntax, please see the Database
Compatibility for Oracle Developers Built-In Packages Guide.
The following summarizes how variables can be accessed:
 Variables can be accessed as long as the block in which the variable has been
locally declared is within the ancestor hierarchical path starting from the block
containing the reference to the variable. Such variables declared in ancestor
blocks are referred to as global variables.
 If a reference to an unqualified variable is made, the first attempt is to locate a
local variable of that name. If such a local variable does not exist, then the search
Copyright © 2007 - 2018 EnterpriseDB Corporation. All rights reserved. 171
Database Compatibility for Oracle® Developers Guide
for the variable is made in the parent of the current block, and so forth,
proceeding up the ancestor hierarchy. If such a variable is not found, then an error
occurs upon invocation of the subprogram.
 If a reference to a qualified variable is made, the same search process is
performed as described in the previous bullet point, but searching for the first
match of the subprogram or labeled anonymous block that contains the local
variable. The search proceeds up the ancestor hierarchy until a match is found. If
such a match is not found, then an error occurs upon invocation of the
subprogram.
The following location of variables cannot be accessed relative to the block from where
the reference to the variable is made:
 Variables declared in a descendent block cannot be accessed,
 Variables declared in a sibling block, a sibling block of an ancestor block, or any
descendants within the sibling block cannot be accessed.
Note: The Advanced Server process for accessing variables is not compatible with Oracle
databases. For Oracle, any number of qualifiers can be specified and the search is based
upon the first match of the first qualifier in a similar manner to the Oracle matching
algorithm for invoking subprograms.
The following example displays how variables in various blocks are accessed, with and
without qualifiers. The lines that are commented out illustrate attempts to access
variables that would result in an error.
CREATE OR REPLACE PROCEDURE level_0
IS
v_level_0 VARCHAR2(20) := 'Value from level_0';
PROCEDURE level_1a
IS
v_level_1a VARCHAR2(20) := 'Value from level_1a';
PROCEDURE level_2a