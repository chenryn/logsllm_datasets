Stack
Stack
Stack
Stack
Integer
Integer
Integer
Integer
Integer
Integer
Integer
UAF
UAF
UAF
UAF
DF
DF
FS
FS
# BBs
41,625,163
67,772
74,723
300,071
283,157
75,404
291,275
260,986
53,490
90,738
100,186
374,830
65,198
128,427
53,490
60,849
78,419,067
67,697
809,977
1,049,494
75,142
74,695
132,302
2,316,152
2,316,133
132,302
5,980,255
5,980,255
132,302
127,209
108,442
4,568,619
Size (MB)
56.0
0.65
0.65
1.10
1.10
1.01
1.20
0.85
0.67
1.09
0.71
1.85
0.71
0.66
0.67
0.69
55.0
0.97
2.00
1.10
1.00
1.03
1.02
4.61
4.61
1.02
6.40
6.40
1.02
0.74
0.69
5.07
∆Root Cause
247
26,216
33,211
28
59
1,828
8
19,322
6,319
1,848
4,051
122,740
94
83,123
6,566
335
3
1
1
2
1
1
1
38
38
296
49
51
57,859
1
1
11,722
∆Alert
1
1
1
33,824
16,821
2
234
2
1
1
14,402
77,990
30
1
-
107
8
7
25,268
780,404
1
203
-
1
1
58,058
-
719
-
1
1
36,804
Located
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
† Equivalent to applied patch.
Table 4: System Evaluation for Real-World Vulnerabilities
Has Patch Match
Yes†
[61]
No
[62]
[63]
[64]
No
[65]
No
No
[66]
No
[67]
[68]
[69]
No
No
[70]
[71]
[72]
[73]
No
No
No
[74]
[74]
No
[75]
[75]
No
[76]
[77]
-
Yes
Yes
Yes
-
Yes
-
-
Yes
-
Yes
Yes
Yes
-
-
Yes
Yes
Yes
Yes
-
-
-
Yes
Yes
-
Yes
Yes
-
Yes
Yes
The “∆Root Cause” column lists how many basic blocks
were executed between the state where ARCUS ﬁrst identiﬁes
the vulnerability and its determined root cause point. The
numbers vary substantially by class, with heap and stack
overﬂows having distances upwards of 120,000 basic blocks
whereas integer overﬂows and format strings are usually 1.
“∆Alert” reports the number of blocks between where the
runtime monitor ﬂagged the execution and where ARCUS
ﬁrst detected the bug during analysis. In other words, the
distance between the monitor alert and the ultimate root cause
determined by ARCUS is the sum of “∆Root Cause” and
“∆Alert.” Distances vary depending on which monitor was
tripped and the overall program complexity. Some executions
were not halted until over 700,000 blocks past the bug’s initial
symptoms. 0-days found by ARCUS have no reported value
since they were not detected by a monitor.
4.3 Consistency to Advisories & Patches
We evaluate the quality of reports for the real-world exploits
by manually comparing them against public vulnerability
advisories. For example, in CVE-2017-9167, the advisory
states that AutoTrace 0.31.1 has a heap-based buffer overﬂow
in the ReadImage function deﬁned in input-bmp.c on line
337. Accordingly, we expect ARCUS’s root cause report to
include the code compiled from this line.
When ARCUS provides a recommendation for extra con-
straints, we also manually verify that the reported guardian
does in fact control the execution of the vulnerable code and
that the recommended constraints would prevent the exploit.
For example, the ARCUS report for CVE-2018-12327 recom-
mends enforcing at the inner most loop in Figure 1 that a ‘]’
character occurs within the ﬁrst 257 characters of hname, as
explained in detail in Subsection 3.2. This does prevent the
exploit from succeeding, making the report satisfactory.
Some of the evaluated vulnerabilities have already been
ﬁxed in newer versions of the targeted programs. In these
cases, we use the patch to further verify the quality of AR-
CUS’s reports by manually conﬁrming that they identify the
same code.
Results. The results are shown in the “Located,” “Has
Patch,” and “Match” columns of Table 4. All 31 reports
correctly identify the exploited vulnerable code. There are
patches available at the time of evaluation for 5 of the 8
heap overﬂows, 4 of the 8 stack overﬂows, 4 of the 7 integer
overﬂows, 3 of the 4 use after frees, 1 of the 2 double frees,
1998    30th USENIX Security Symposium
USENIX Association
and all 2 format string vulnerabilities. In all but 1 of the 19
ofﬁcial patches available for our tested vulnerabilities, the
report generated by ARCUS is consistent with the applied
patch. CVE-2004-0597 is a special case where a parent func-
tion calls a child using unsafe parameters, causing the child
to overﬂow a heap buffer. ARCUS correctly identiﬁes the
vulnerable code, however the developers chose to patch the
parent function, whereas ARCUS suggests adding checks
inside the child. Both ﬁxes are correct, so this report is satis-
factory despite being slightly different from the ofﬁcial patch.
12 of the evaluated vulnerabilities are not patched at the time
of evaluation.
4.4 Runtime & Storage Overheads
Dataset & Selection Criteria. To evaluate the performance
and storage overheads of ARCUS, we start with the SPEC
CPU 2006 benchmark and a storage threshold of 100 GB. We
pick this suite because it is commonly used and intentionally
designed to stress CPU performance. Since our design re-
quires control ﬂow tracing, CPU intensive tasks are the most
costly to trace. I/O tasks by comparison incur signiﬁcantly
less overhead due to blocking, which we demonstrate using
Nginx with PHP. Consequently, we consider the SPEC work-
loads to represent realistic worst case scenarios for ARCUS.
To simulate long-running services and heavy workloads,
we stress Nginx and PHP with default settings using
ApacheBench (ab) to generate 50,000 requests for ﬁles rang-
ing from 100 KB to 100 MB. This experiment also uses a
100 GB storage threshold.
Results. Figure 6 shows the performance and storage over-
heads of tracing the SPEC workloads without the runtime
monitors. The average overhead is 7.21% with a geometric
mean of 3.81%, which is consistent with other Intel PT sys-
tems [1], [2]. A few workloads have overheads upward of
25%, which is also consistent with prior work and is caused
by programs with frequent indirect calls and jumps. A work-
load yields 110 MB of data on average, which at our chosen
storage threshold allows us to store 930 invocations of the
program before old data is deleted. In the worst case, we can
store 83 invocations.
For the Nginx with PHP stress test, shown in Figure 7,
performance overhead is negligible at under 2%. ARCUS
generates at most 1.6 MB of data per request, allowing us
to store the past 64,000 requests given our 100 GB storage
quota. We observe that ﬁle size has little inﬂuence over stor-
age requirements, with the smallest ﬁle producing 1.2 MB of
data per request and the largest producing 1.6 MB.
4.5 Case Studies
Discovering Nearby 0-Days. ARCUS discovers that ver-
sion 1.2.0 of libzip has a known vulnerability that can be
altered into a new, previously undiscovered, 0-day.11 Speciﬁ-
cally, there is a buggy memory freeing function that maintains
a ﬂag in a parent structure to track whether a substructure has
already been freed. Calling the freeing function twice on the
same structure, without checking the ﬂag, results in a double
free (CVE-2017-12858), exploitable via a malformed input.
However, what was not previously known, but uncovered
by ARCUS, is that further corrupting the malformed input can
trigger a UAF, which has been assigned CVE-2019-17582.
Speciﬁcally, after freeing the parent structure, invoking the
freeing function again can cause it to access the ﬂag that is
no longer properly allocated.
Although both bugs reside in the same function, they are
distinct — the known CVE double frees the child structure
while the new bug inappropriately accesses the parent struc-
ture’s ﬂag. A developer ﬁxing the prior by more carefully
checking the ﬂag will not remediate the latter. ARCUS is able