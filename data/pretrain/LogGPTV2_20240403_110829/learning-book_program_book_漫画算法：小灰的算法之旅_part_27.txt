小灰，我这里有一个新
需求，和钱有关系。
这样的需求，我最喜
欢啦：快给我说说。
“双十一"快要到了，我们需要上线一个发放红包的功能。这个功能
类似于微信群发红包的功能。
例如一个人在群里发了100块钱的红包，群里
有10个人一起来抢红包，每人抢到的金额随机分配。
---
## Page 499
微信红包
大茜
10.21元
手气最佳
小
6.39元
小红
3.28元
小
0.02元
哎呀，为什么我只抢到了2分钱呢？
嘿嘿，只是举个例子啦。此外，我们的红包
功能有一些具体规则。
红包功能需要满足哪些具体规则呢？
1.所有人抢到的金额之和要等于红包金额，不能多也不能少。
2.每个人至少抢到1分钱。
---
## Page 500
3.要保证红包拆分的金额尽可能分布均衡，不要出现两极分化太严重的
情况。
这个简单，放心交给我吧！
为了避免出现高并发引起的一些问题，每个人领取红包的金额不能在领
的时候才计算，必须先计算好每个红包拆出的金额，并把它们放在一个
队列里，领取红包的用户要在队列中找到属于自己的那一份。
100元红包
用户群
21.5
16.3
39.2
18.0
5.0
红包金额队列
于是，小灰很快想出了一个拆分红包金额的方法。
小灰的思路是怎样的呢？具体如下所示。
每次拆分的金额=随机区间[1分，剩余金额-1分]
举个例子，如果分发的红包是100元，有5个人抢，那么队列第1个位置
的金额在0.01到99.99元之间取随机数。
假设第1个位置随机得到20元，队列第2个位置的金额要在0.01到79.99元
之间取随机数。
假设第2个位置随机得到30元，队列第3个位置的金额要在0.01到49.99
---
## Page 501
元之间取随机数。
假设第3个位置随机得到15元，队列第4个位置的金额要在0.01到34.99
元之间取随机数。
假设第4个位置随机得到22元，那么第5个位置自然是35-22=13元。
小灰把做出的Demo演示给产品经理......
哎呀，你这不行啊，这样随机的结果很不均
衡！
这不是挺好的吗？怎么不行了？
如果以这样的方式来拆分红包的话，前面拆
分的金额会很大，后面的金额会越来越小！
---
## Page 502
为什么这么说呢？让我们来分析一下。
假设红包总额为100元，有5个人来抢。
第1个人抢到金额的随机范围是[0.01，99.99]元，在正常的情况下，抢
到金额的中位数是50元。
假设第1个人随机抢到了50元，那么剩余金额是50元。
第2个人抢到金额的随机范围就小得多了，只有[0.01，49.99】元，在正
常的情况下，抢到金额的中位数是25元。
假设第2个人随机抢到了25元，那么剩余金额是25元。
第3个人抢到金额的随机范围就更小了，只有[0，24.99]元，按中位数可
以抢到12.5元。
以此类推，红包的随机范围将会越来越小，这样的结果一点也不公平，
用户肯定要气得大骂了。
说得也是啊......那如果我把随机
的拆分金额打乱顺序放入队列呢？这样避免了先抢的用户占优势，
后抢的用户吃亏。
---
## Page 503
那也不行，虽然金额的顺序被打乱了，但金
额的大小仍然是两极分化严重，最大的金额可能超过总额一半，最
小的金额会非常小。
天响，这可怎么办？
6.5.2
用算法解决问题
小灰，你怎么还不找个女朋友，工作
太忙了吗？
---
## Page 504
喉，还不是被一个需求给折腾的！
事情是这样子的...（小灰把工
作中的难题告诉了大黄）
小灰，关于红包拆分的问题，其实没
有固定答案，稍微动动脑筋，就可以想出很多种高效又均衡的分配
算法。
---
## Page 505
有什么好的方法呢，你给举个例子呗？
有一个最简单的思路，就是把每次随
机金额的上限定为剩余人均金额的2倍。
方法1：二倍均值法
假设剩余红包金额为m元，剩余人数为n，那么有如下公式。
每次抢到的金额=随机区间[0.01，m/n×2-0.01]元
这个公式，保证了每次随机金额的平均值是相等的，不会因为抢红包
的先后顺序而造成不公平。
举个例子如下。
假设有5个人，红包总额100元。
100÷5×2=40，所以第1个人抢到的金额随机范围是[0.01，39.99]元，在
正常情况下，平均可以抢到20元。
假设第1个人随机抢到了20元，那么剩余金额是80元。
80÷4x2=40，所以第2个人抢到的金额的随机范围同样是[0.01，39.99]
---
## Page 506
元，在正常的情况下，还是平均可以抢到20元。
假设第2个人随机抢到了20元，那么剩余金额是60元。
60÷3x2=40，所以第3个人抢到的金额的随机范围同样是[0.01，39.99]
元，平均可以抢到20元。
以此类推，每一次抢到金额随机范围的均值是相等的。
这样做真的是均等的吗？如果第
1个人运气很好，随机抢到39元，第2个人所抢金额的随机区间不就
缩减到[0.01，60.99]元了吗？
这个问题提得很好。第1次随机的金
额有一半概率超过20元，使得后面的随机金额上限不足39.99元；
但相应地，第1次随机的金额同样也有一半的概率小于20元，使得
后面的随机金额上限超过39.99元。因此从整体来看，第2次随机的
平均范围仍然是[0.01，39.99]元。
---
## Page 507
原来如此，那么代码怎么实现
呢？
代码非常简单，让我们来看一看。
1./ **
2.*拆分红包
3.*@param totalAmount
总金额（以分为单位）
4.*@param totalPeopleNum
总人数
6. public static List divideRedPackage(Integer
totalAmount, Integer totalPeopleNum){
7.
List amountList = new ArrayList();
8.
Integer restAmount = totalAmount;
9.
Integer restPeopleNum = totalPeopleNum;
10.
Random random = new Random();
11.
for(int i=0; i amountList = divideRedPackage(1oo0, 10);
24.
for(Integer amount : amountList){
25.
System.out.println("
抢到金
额："+new BigDecimal(amount).
divide(new BigDecimal(1oo)));
26.
27.}
---
## Page 509
明白了，还真是个好办法！
这个方法虽然公平，但也存在局限
性，即除最后一次外，其他每次抢到的金额都要小于剩余人均金额
的2倍，并不是完全自由地随机抢红包。
哦，那怎样能做到既公平，又不
超过总金额，又能提高随机抢红包的自由度呢？
---
## Page 510
有另一种方法，我们姑且把它叫作线
段切割法吧。
方法2：线段切割法
何谓线段切割法？我们可以把红包总金额想象成一条很长的线段，而每
个人抢到的金额，则是这条主线段所拆分出的若干子线段。
100元红包
20元
3元
22元
30元
15元
如何确定每一条子线段的长度呢？
由"切割点"来决定。当n个人一起抢红包时，就需要确定n-1个切割点。
因此，当n个人一起抢总金额为m的红包时，我们需要做n-1次随机运
算，以此确定n-1个切割点。随机的范围区间是[1，m-1]。
当所有切割点确定以后，子线段的长度也随之确定。此时红包的拆分金
额，就等同于每个子线段的长度。
这就是线段切割法的思路，在这里需要注意以下两点。
1.当随机切割点出现重复时，如何处理。
2.如何尽可能降低时间复杂度和空间复杂度。
---
## Page 511
关于线段切割法，我们就不写具体代
码了，有兴趣的读者可以尝试一下。此外，实现红包拆分的算法肯
定不止这两种，聪明的读者可以开动脑筋，想一想有没有更好的选
择。
好了，关于红包算法我们就介绍到这
里，祝愿大家每次抢红包时都能拥有好手气！
6.6算法之路无止境
---
## Page 512
大黄，大黄，你还知
道什么样的算法，再
给我讲讲明？
小灰，你学习了算法和数据结
构的基础知识，学习了许多算
法面试题的解法，又学习了许
多工作中会应用到的算法，我
已经没有什么可教你的了，
啊，难道我已经把算
去学通了？
---
## Page 513
不，不，不，算法的学习道路
是没有尽头的。你现在只是走
进了算法的大门，要想在算法
领域更上一层楼，还需要读更
多的书，请教更多的牛人，进
行更多的思考。
就这样，小灰继续在算法的世界中摸索、前进着，这个世界充满了新
奇，也同样充满了挑战。
尽管小灰学到了许多东西，但小灰仍然保持着一颗求索的心。因为小灰
明白，算法之路，永无止境...
再见！
Table of Contents
扉页
版权页
且录
---
## Page 514
内容简介
Preface 推荐序
Preface 前言
第1章算法概述
1.1算法和数据结构
1.1.1小灰和大黄
1.1.2什么是算法
1.1.3什么是数据结构
1.2时间复杂度
1.2.1算法的好与坏
1.2.2基本操作执行次数
1.2.3渐进时间复杂度
1.2.4时间复杂度的巨大差异
1.3空间复杂度
1.3.1什么是空间复杂度
1.3.2空间复杂度的计算
1.3.3时间与空间的取舍
14小结
第2章数据结构基础
2.1什么是数组
---
## Page 515
2.11初识数组
2.1.2数组的基本操作
2.1.3数组的优势和劣势
2.2什么是链表
2.2.1“正规军”和“地下党”
2.2.2链表的基本操作
2.2.3数组VS链表
2.3栈和队列
2.3.1物理结构和逻辑结构
2.3.2什么是栈
2.3.3栈的基本操作
2.3.4什么是队列
2.3.5队列的基本操作
2.3.6栈和队列的应用
22.4神奇的散列表
2.4.1为什么需要散列表
2.4.2哈希函数
2.4.3散列表的读写操作
2.5小结
第3章树
---
## Page 516
3.1树和二叉树
3.1.1什么是树
3.1.2什么是二叉树
3.1.3二叉树的应用
3.2二叉树的遍历
3.2.1为什么要研究遍历
3.2.2深度优先遍历
3.2.3广度优先遍历
3.3什么是二叉堆
3.3.1初识二叉堆
3.3.2二叉堆的自我调整
3.3.3二叉堆的代码实现
3.4什么是优先队列
3.4.1优先队列的特点
3.4.2优先队列的实现
3.5小结
第4章排序算法
4.1引言
4.2什么是冒泡排序
4.2.1初识冒泡排序
---
## Page 517
4.2.2冒泡排序的优化
4.2.3鸡尾酒排序
4.3什么是快速排序
4.3.1初识快速排序
4.3.2基准元素的选择
4.3.3元素的交换
4.3.4单边循环法
4.3.5非递归实现
4.4什么是堆排序
4.4.1传说中的堆排序
4.4.2堆排序的代码实现
4.5计数排序和桶排序
4.5.1线性时间的排序
4.5.2初识计数排序
4.5.3计数排序的优化
4.5.4什么是桶排序
4.6小结
第5章面试中的算法
5.1蹉曙满志的小灰
5.2如何判断链表有环
---
## Page 518
5.2.1一场与链表相关的面试
5.2.2解题思路
5.2.3问题扩展
5.3最小栈的实现
5.3.1一场关于栈的面试
5.3.2解题思路
5.4如何求出最大公约数
5.4.1一场求最大公约数的面试
5.4.2解题思路
5.5如何判断一个数是否为2的整数次幂
5.5.1一场很“2"的面试
5.5.2解题思路
5.6无序数组排序后的最大相邻差
5.6.1一道奇范的面试题
5.6.2解题思路
5.7如何用栈实现队列
5.71又是一道关于栈的面试题
5.7.2解题思路
5.8寻找全排列的下一个数
5.8.1一道关于数字的题目
---
## Page 519
5.8.2解题思路
5.9删去k个数字后的最小值
5.9.1又是一道关于数字的题目
5.9.2解题思路
5.10如何实现大整数相加
5.10.1加法，你会不会
5.10.2解题思路
5.11如何求解金矿问题
5.11.1一个关于财富自由的问题
5.11.2解题思路
5.12寻找缺失的整数
5.12.1“五行"缺一个整数
5.12.2间题扩展
第6章算法的实际应用
6.1小灰上班的第1天
6.2Bitmap的巧用
6.2.1一个关于用户标签的需求
6.2.2用算法解决问题
6.3LRU算法的应用
6.3.1一个关于用户信息的需求
---
## Page 520
6.3.2用算法解决问题
6.4什么是A星寻路算法
6.4.1一个关于迷宫寻路的需求
6.4.2用算法解决问题
6.5如何实现红包算法
6.5.1一个关于钱的需求
6.5.2用算法解决问题
6.6算法之路无止境
---