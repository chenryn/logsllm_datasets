### 3. Message Filtering by Non-Malicious Nodes
A non-malicious node will block a message if the condition \( c_t - t_s > \text{max\_delay} \) is met, where \( c_t \) is the current time, \( t_s \) is the timestamp on the message, and \(\text{max\_delay}\) is a system-defined parameter. Additionally, a message will be blocked if the signature check fails.

### 4.8 Rekeying
Per-topic encryption keys (authorization keys) are similar to capabilities issued to authorized subscribers. When a subscriber unsubscribes, the per-topic encryption key must be changed, and the new key must be communicated to all other authorized subscribers. Changing the per-topic encryption key for every unsubscription can be very expensive. Therefore, EventGuard employs periodic rekeying.

We periodically change all per-topic encryption keys by updating \( rk(MS) \). Specifically, we divide time into epochs, each consisting of a fixed number of time units (e.g., one month). All subscriptions and advertisements need to be renewed at the beginning of each epoch. Epochs are numbered consecutively starting from 0. The secret key used by the MS in the \( T \)-th epoch is derived from the primary secret key \( rk(MS) \) as \( rk(MS; T) = KH_{rk(MS)}(T) \). The MS uses \( rk(MS; T) \) to generate authorization keys during the \( T \)-th epoch. If a subscriber \( S \) unsubscribes for topic \( w \) in epoch \( T \), they can still read the contents of publications under topic \( w \) until the end of epoch \( T \) but not after.

Note that \( rk(MS; T) \) is used only for generating per-topic encryption keys. The MS always uses the primary secret key \( rk(MS) \) for signing subscriptions, unsubscriptions, advertisements, and unadvertisements. All topic tokens, unsubscribe tokens, and unadvertise tokens are derived using the primary secret key \( rk(MS) \). Therefore, these tokens do not change across epochs. This means that none of the subscriptions and advertisements disseminated into the pub-sub network need to be changed every epoch. Our rekeying technique requires only the subscribers and publishers to obtain new per-topic encryption keys from the MS every epoch. Additionally, periodic rekeying facilitates the MS in billing the subscribers and publishers for the next epoch.

### 5. EVENTGUARD EVALUATION
We have implemented EventGuard on top of the Siena pub-sub core [5]. We used a Java-based implementation of Siena [4] and added EventGuard extensions in the form of an EventGuard package. No changes were made to the Siena pub-sub core (e.g., the content-based routing and event matching algorithms). For further details on the EventGuard implementation, refer to [19].

#### Cryptographic Primitives
Table 1 provides a quick reference of the cryptographic algorithms used in our implementation of EventGuard. We use MD5 for the hash function \( H \), HMAC-MD5 for the keyed hash function \( KH \), 128-bit AES encryption algorithm in cipher-block-chaining mode (CBC) for \( E \), and 512-bit ElGamal algorithm for digital signatures. Table 1 also shows the execution times for different cryptographic primitives used by EventGuard. All measurements were made on a 900 MHz Intel Pentium III running RedHat Linux 9.0 using Sun Java 1.5.0. These times were measured using the `nanoTime` method introduced in J2SE 1.5.0 and averaged over 1000 measurements. Note that the computation time for hash functions (MD5 and HMAC-MD5) depends on the block size. For instance, MD5 hashes can be computed at 2 MB/s when the block size is small (16 Bytes) and about 61 MB/s when the block size is large (1024 Bytes).

In the following sections, we present macro-benchmarks to quantify the performance of the entire system. We measure changes in throughput and latency of the pub-sub network due to EventGuard mechanisms.

#### 5.1 Macro-Benchmarks
In this section, we present two sets of macro-benchmarks for EventGuard. The first set of experiments is simulation-based, while the second set is obtained from our prototype implementation of EventGuard on the Siena pub-sub core.

| Primitive | Algorithm | Computation Time |
|-----------|-----------|------------------|
| \( H \)   | MD5       | 2 MB/s-61 MB/s   |
| \( KH \)  | HMAC-MD5  | 1.5 MB/s-49 MB/s |
| \( E \)   | AES-128-CBC | 10 MB/s          |
| \( \text{sig} \) | ElGamal-512-sign | 714 Sign/s |
| \( \text{verify} \) | ElGamal-512-verify | 588 Verify/s |

**Simulation-based Experiments (5.1.1)**
In this section, we present performance results from simulation-based experiments on EventGuard. First, we show the improvements in message confidentiality and integrity due to EventGuard. Second, we measure the system's throughput in the presence of malicious nodes. Third, we analyze the average load on the MS, the publisher, the subscriber, and the nodes as we vary the subscription and publication rates.

**Simulation Setup:**
We used the GT-ITM [23] topology generator to create an Internet topology with 4K nodes. These nodes were connected to form a binary tree-based hierarchical topology. The latencies for links were obtained from the underlying Internet topology generated by GT-ITM, with round trip times varying from 24ms to 184ms (mean 74ms, standard deviation 50ms). We simulated 32 publishers and 8K subscribers, randomly connected to one leaf node in the pub-sub network. We used discrete event simulation [10] to simulate the pub-sub network. All experimental results were averaged over 5 independent simulation runs. We simulated 128 topics, with the popularity of each topic following a Zipf-like distribution [15]. Each publisher published on 16 topics (randomly picked from the set of 128 topics), and each subscriber subscribed to 4 topics.

**Confidentiality and Integrity:**
Figure 4 shows the fraction of messages that violate their confidentiality and integrity guarantees when in transit between a publisher and its subscribers, with different fractions of malicious nodes (\( p \)) and different values of \( N_S \) (number of subscribers). A message loses its confidentiality and integrity as soon as it transits through one bad node in the pub-sub network. When \( p \) is small, even a small increase in \( p \) results in a heavy loss of message confidentiality and integrity. As \( N_S \) increases, the height of the binary tree network increases, and so does the probability that at least one bad node appears on a path from a publisher to its subscribers. On the contrary, EventGuard is capable of preserving the confidentiality and integrity of all messages, regardless of the number of malicious nodes in the system.

**Flooding-based DoS Attack:**
Figure 5 shows the fraction of network bandwidth expended on flooded messages as the fraction of malicious nodes (\( p \)) varies with 8K subscribers. We assume that every malicious node performs a publication flooding-based DoS attack at the rate of 100 messages per unit time, and each publisher publishes at the rate of 25 publications per unit time. We considered two cases: Case one, where malicious nodes are uniformly distributed throughout the pub-sub network (EventGuard-sparse in Figure 5); and Case two, where malicious nodes form \( k \) clusters in the pub-sub network (EventGuard-cluster-\( k \) in Figure 5). When malicious nodes are clustered together, the loss in throughput for EventGuard is relatively much smaller. This is because EventGuard ensures that no flooding attack propagates beyond one non-malicious pub-sub node. Hence, clustered malicious nodes cannot significantly affect other non-malicious nodes in the system (see Figure 3).

**Load:**
Figure 6 shows the relative computational load on the MS, the publisher, the subscribers, and a pub-sub node as we vary the rate of subscriptions, unsubscriptions, and publications, keeping the aggregate rate constant (we do not consider advertisement and unadvertisement costs in this experiment). We set the subscription rate equal to the unsubscription rate to ensure that the average number of active subscriptions in the system is almost constant. Note that only the control operations on subscriptions and unsubscriptions involve the MS. If a pub-sub network is largely dominated by publications (which is true in most cases), the relative load on the MS would be very small. If the load on the MS is not acceptable, EventGuard mechanisms easily permit the addition of additional meta-services. The fact that the meta-services do not have to interact with one another (they share the private key \( rk(MS) \)) makes it possible to build an efficient load balancing system to handle the MS load and vary the number of active meta-services on-demand.

Observe that the load on a node remains almost constant as it depends only on the aggregate rate of subscriptions, unsubscriptions, and publications. On the other hand, the relative load on a publisher decreases as the publication rate decreases, as a publisher is not involved in subscribe and unsubscribe operations. Subscriber load is typically much smaller than the average node load because the number of publications delivered to a subscriber is very small compared to the total number of publications sent on the pub-sub network. Only those publications that match a subscriberâ€™s subscriptions are delivered to the subscriber.

**Implementation-based Experiments (5.1.2)**
We now present performance measurements from our prototype implementation of EventGuard on the Siena pub-sub core. First, we present measurements on the loss in throughput and the increase in latency in publications due to EventGuard. Second, we measure the effectiveness of EventGuard against flooding-based DoS attacks.

**Experimental Setup:**
Our implementation of EventGuard is built on top of the Siena pub-sub core. We ran this implementation on eight machines, each with 8 processors (total of 64 processors) (550 MHz Intel Pentium III Xeon processors running RedHat Linux 9.0) connected via a high-speed LAN. We instrumented the pub-sub core to simulate the wide-area network delays obtained from the GT-ITM topology generator.

The pub-sub network consisted of one publisher, 32 subscribers, and one MS, with the publisher as the root of the tree and the subscribers as leaves. We constructed a complete binary tree topology using different numbers of nodes (0, 2, 6, 14, 30) and linked these nodes using open TCP connections to form the pub-sub network. The subscribers were uniformly distributed among all the leaf nodes. Each entity (publisher, subscriber, node, and MS) was run on a separate processor.

**Throughput:**
We measured the throughput in terms of the maximum number of publications per second that can be handled by the pub-sub system with and without EventGuard. We measured the maximum throughput as follows: we engineered the publisher to generate publications at the rate of \( q \) publications per unit time. In each run of this experiment, the rate \( q \) was fixed. We monitored the number of outstanding publications required to be processed at every node. If at any node the number of outstanding publications monotonically increased for five consecutive observations, we concluded that the node was saturated, and the experiment was aborted. We iteratively varied \( q \) across different experimental runs to identify the minimum value \( q_{\text{min}} \) such that some node in the pub-sub network was saturated.