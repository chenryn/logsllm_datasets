Third, a non-malicious node blocks any message if the con-
dition jct (cid:0) tsj > max delay is met, where ct is the current
time, ts is the timestamp on a message, and max delay is a
system de(cid:12)ned parameter or the signature check fails.
4.8 Rekeying
Per-topic encryption keys (authorization keys) are like ca-
pabilities issued to authorized subscribers. Hence, when a
subscriber unsubscribes, the per-topic encryption key needs
to be changed and the new key has to be communicated to
all other authorized subscribers. We observe that changing
the per topic encryption key on every unsubscription can be
very expensive. As a result, EventGuard resorts to periodic
rekeying.
We periodically change all per-topic encryption keys by
changing rk(M S). More speci(cid:12)cally, we divide time into
epochs of epoch time units (say, one month). All subscrip-
tions and advertisements need to be renewed at the begin-
ning of every time epoch. We number epochs with consec-
utive integers starting from epoch number 0. The secret
key used by the M S in the T th epoch is derived from the
primary secret key rk(M S) as rk(M S; T ) = KHrk(M S)(T ).
The M S uses rk(M S; T ) to replace rk(M S) during the T th
epoch for generating authorization keys. Hence, if a sub-
scriber S unsubscribes for topic w in epoch T , it would still
be able to read the contents of publications under topic w
till the end of epoch T (but not after epoch T ) by sni(cid:14)ng
the pub-sub network.
Note that rk(M S; T ) is used only for generating per-topic
encryption keys. The M S always uses the primary secret
key rk(M S) for signing subscriptions, unsubscriptions, ad-
vertisements and unadvertisements. Also, all topic tokens,
unsubscribe tokens and unadvertise tokens are derived us-
ing the primary secret key rk(M S). Hence, tokens do not
change across epochs. Therefore, none of the subscription
and advertisements disseminated into the pub-sub network
needs to be changed every epoch. Our rekeying technique
requires only the subscribers and the publishers to obtain
new per-topic encryption keys from the M S every epoch.
Additionally, periodic rekeying facilitates the M S to bill the
subscribers and the publishers for the next epoch.
5. EVENTGUARD EVALUATION
We have implemented EventGuard on top of the Siena
pub-sub core [5]. We used a Java based implementation of
Siena [4] and added EventGuard extensions to it in the form
of an EventGuard package. No changes were made as such to
the Siena pub-sub core (e.g., the content-based routing and
event matching algorithms). For further details on Event-
Guard implementation refer to [19].
Cryptographic Primitives. Table 1 provides a quick ref-
erence of the cryptographic algorithms used by our imple-
mentation of EventGuard. We use MD5 for the hash func-
tion H, HMAC-MD5 for the keyed hash function KH, 128-
bit AES encryption algorithm in cipher-block-chaining mode
(CBC) for E and 512-bit ElGamal algorithm for digital sig-
natures. Table 1 also shows the amount of time it takes for
executing di(cid:11)erent cryptographic primitives used by Event-
Guard. All our measurements were made on a 900MHz In-
tel Pentium III running RedHat Linux 9.0 using Sun Java
1.5.0. These times have been measured using the new nan-
oTime method introduced in J2SE 1.5.0. All reported values
have been averaged over 1000 measurements. Note that the
computation time for hash computation (MD5 and HMAC-
MD5) depends on the block size. For instance, MD5 hashes
can be computed at 2 MB/s when the block size is small
(16 Bytes) and about 61 MB/s when the block size is large
(1024 Bytes).
In the following sections, we present macro-benchmarks to
quantify the performance of the entire system. We measure
changes in throughput, latency of the pub-sub network as
an e(cid:11)ect of EventGuard mechanisms.
5.1 Macro›Benchmarks
In this section, we present two sets of macro-benchmarks
for EventGuard. The (cid:12)rst set of experiments is simulation
based. The second set of experiments is obtained from our
prototype implementation of EventGuard on Siena pub-sub
core.
H
KH
E
sig
sig
MD5
HMAC-MD5
AES-128-CBC
ElGamal-512-sign
ElGamal-512-verify
2 MB/s-61 MB/s
1.5 MB/s-49 MB/s
10 MB/s
714 Sign/s
588 Verify/s
Table 1: Computation Times for Cryptographic
Primitives used by EventGuard
Simulation based Experiments
5.1.1
In this section, we present performance results from simu-
lation based experiments on EventGuard. First, we present
the improvements on message con(cid:12)dentiality & integrity due
to EventGuard. Second, we measure the throughput of the
system in the presence of malicious nodes. Third, we show
the average load on the M S, the publisher, the subscriber
and the nodes as we vary the subscription and publication
rate.
Simulation Setup. We used GT-ITM [23] topology gener-
ator to generate an Internet topology consisting of 4K nodes.
We linked these nodes to form a binary tree based hierarchi-
cal topology. The latencies for links were obtained from the
underlying Internet topology generated by GT-ITM. The
round trip times on these links varied from 24ms to 184ms
with mean 74ms and standard deviation 50ms. We sim-
ulated 32 publishers and N S=8K subscribers. The sub-
scribers were randomly connected to one leaf node in the
pub-sub network. We used discrete event simulation [10]
to simulate the pub-sub network. All experimental results
presented in this section were averaged over 5 independent
simulation runs. We simulated 128 topics, with the popular-
ity of each topic varying according to a Zipf-like distribution
[15]. Each publisher publishes on 16 topics (randomly picked
from the set of 128 topics) and each subscriber subscribes
for 4 topics.
Con(cid:12)dentiality and Integrity. Figure 4 shows the frac-
tion of messages that violate their con(cid:12)dentiality and in-
tegrity guarantees when in transit between a publisher and
its subscribers with di(cid:11)erent fractions of malicious nodes (p)
and di(cid:11)erent values of N S (number of subscribers). We as-
sume that a message looses its con(cid:12)dentiality and integrity
as soon as it transits one bad node in the pub-sub network.
Observe that when p is small, even a small increase in p re-
sults in a heavy loss of message con(cid:12)dentiality and integrity.
Also, as N S increases, the height of the binary tree network
increases and so does the probability that at least one bad
node appears on a path from a publisher to its subscribers.
On the contrary, EventGuard is capable of preserving the
con(cid:12)dentiality and integrity of all messages irrespective of
the number of malicious nodes in the system.
Flooding-based DoS Attack. Figure 5 shows the frac-
tion of network bandwidth expended on (cid:13)ooded messages
as the fraction of malicious nodes (p) varies with N S=8K
subscribers. We assume that every malicious node performs
a publication (cid:13)ooding-based DoS attack at the rate of 100
messages per unit time. We assume that each publisher
publishes at the rate of 25 publications per unit time. We
considered two cases: Case one wherein the malicious nodes
are uniformly distributed throughout the pub-sub network
(EventGuard-sparse in Figure 5); and Case two wherein
malicious nodes form k clusters in the pub-sub network
y
t
i
r
g
e
t
n
I
d
n
a
y
t
i
l
a
i
t
n
e
d
i
f
n
o
C
 1
 0.8
 0.6
 0.4
 0.2
 0
’N=1K’
’N=4K’
’N=8K’
’EventGuard’
 0  0.05  0.1  0.15  0.2  0.25  0.3  0.35  0.4  0.45  0.5
Fraction of Bad Nodes
i
h
t
d
w
d
n
a
B
d
e
t
s
a
W
f
o
n
o
i
t
c
a
r
F
 1
 0.8
 0.6
 0.4
 0.2
 0
’Siena’
’EventGuard-sparse’
’EventGuard-cluster-1’
’EventGuard-cluster-10’
 0  0.05  0.1  0.15  0.2  0.25  0.3  0.35  0.4  0.45  0.5
Fraction of Bad Nodes
d
a
o
L
 10
 8
 6
 4
 2
 0
’MS’
’publisher’
’subscriber’
’node’
 0
 0.5
 1
 1.5
 2
 2.5
 3
 3.5
 4
Ratio of sub to pub rate
Figure 4: Con(cid:12)dentiality and In-
tegrity
Figure 5: Flooding-based DoS
Attack
Figure 6: M S Load
(EventGuard-cluster-k in Figure 5). When malicious nodes
are clustered together on the pub-sub network, we found
that the loss in throughput for EventGuard is relatively
much smaller. This is because EventGuard ensures that no
(cid:13)ooding attack propagates beyond one non-malicious pub-
sub node. Hence, clustered malicious nodes cannot signif-
icantly a(cid:11)ect other non-malicious nodes in the system (see
Figure 3).
Load. Figure 6 shows the relative computational load on
the M S, the publisher, the subscribers and a pub-sub nodes
as we vary the rate of subscriptions, unsubscriptions and
publications keeping the aggregate rate a constant (we do
not consider advertisement and unadvertisement costs in
this experiment). We set the subscription rate to be equal to
unsubscription rate so as to ensure that the average number
of active subscriptions in the system is almost a constant.
Note that only the control operations on subscriptions and
unsubscriptions involves the M S. Hence, if a pub-sub net-
work is largely dominated by publications (which is true
in most cases) then the relative load on the M S would
be very small.
If the load on a M S is not acceptable,
EventGuard mechanisms easily permits one to add addi-
tional meta-services. The fact that the meta-services do not
have to interact with one another (they share the private
key rk(M S)) makes it possible for one to build an e(cid:14)cient
load balancing system to handle the M S load and vary the
number of active meta-services on-demand.
Observe that the load on a node remains almost a con-
stant as it depends only on the aggregate rate of subscrip-
tions, unsubscriptions and publications. On the other hand,
the relative load on a publisher decreases as the publication
rate decreases; this is because a publisher is not involved
in subscribe and unsubscribe operations. Subscriber load is
typically much smaller than the average node load because
the number of publications delivered to a subscriber is very
small when compared to the total number of publications
sent on the pub-sub network. Recall that only those publi-
cations that match a subscriber’s subscriptions are delivered
to the subscriber.
Implementation based Experiments
5.1.2
We now present performance measurements from our pro-
totype implementation of EventGuard on Siena pub-sub core.
First, we present measurements on the loss in throughput
and the increase in latency in publications due to Event-
Guard. Second, we measure the e(cid:11)ectiveness of EventGuard
against (cid:13)ooding based DoS attacks.
Experimental Setup. Our implementation of EventGuard
is built on top of Siena pub-sub core. We ran this imple-
mentation of EventGuard on eight machines each with 8-
processor (total of 64 processors) (550 MHz Intel Pentium
III Xeon processors running RedHat Linux 9.0) connected
via a high speed LAN. We instrumented the pub-sub core
to simulate the wide-area network delays obtained from the
GT-ITM topology generator.
The pub-sub network consisted for one publisher, 32 sub-
scribers, and one M S, with the publisher as the root of the
tree and the subscribers as leaves. We constructed complete
binary tree topology using di(cid:11)erent number of nodes (0, 2,
6, 14, 30) and linked these nodes using open TCP connec-
tions to form the pub-sub network. The subscribers were
uniformly distributed among all the leaf nodes. Each entity
(publisher, subscriber, node, and M S) was run on a sepa-
rate processor.
Throughput. We measured the throughput in terms of
the maximum number of publications per second that can
be handled by the pub-sub system with and without Event-
Guard. We measured the maximum throughput as follows.
We engineered the publisher to generate publications at the
rate of q publications per unit time. In each run of this ex-
periment, the rate q was (cid:12)xed. We monitored the number of
outstanding publications required to be processed at every
node.
If at any node the number of outstanding publica-
tions monotonically increased for (cid:12)ve consecutive observa-
tions, then we conclude that the node is saturated and the
experiment aborted. We iteratively vary q across di(cid:11)erent
experimental runs to identify the minimum value qmin =
throughput such that some node in the pub-sub network is