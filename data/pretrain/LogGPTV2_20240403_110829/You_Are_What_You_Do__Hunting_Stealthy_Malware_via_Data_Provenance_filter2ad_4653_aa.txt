title:You Are What You Do: Hunting Stealthy Malware via Data Provenance
Analysis
author:Qi Wang and
Wajih Ul Hassan and
Ding Li and
Kangkook Jee and
Xiao Yu and
Kexuan Zou and
Junghwan Rhee and
Zhengzhang Chen and
Wei Cheng and
Carl A. Gunter and
Haifeng Chen
You Are What You Do: Hunting Stealthy Malware
via Data Provenance Analysis
Qi Wang1, Wajih Ul Hassan1, Ding Li2, Kangkook Jee3, Xiao Yu2
Kexuan Zou1, Junghwan Rhee2, Zhengzhang Chen2, Wei Cheng2, Carl A. Gunter1, Haifeng Chen2
1University of Illinois Urbana-Champaign
2NEC Laboratories America, Inc.
3University of Texas at Dallas
{qiwang11, whassan3, kzou3, cgunter}@illinois.edu
{dingli, xiao, rhee, zchen, weicheng, haifeng}@nec-labs.com
PI:EMAIL
Abstract—To subvert recent advances in perimeter and host
security, the attacker community has developed and employed
various attack vectors to make a malware much stealthier than
before to penetrate the target system and prolong its presence.
Such advanced malware or “stealthy malware” makes use of
various techniques to impersonate or abuse benign applications
and legitimate system tools to minimize its footprints in the target
system. It is thus difﬁcult for traditional detection tools, such as
malware scanners, to detect it, as the malware normally does
not expose its malicious payload in a ﬁle and hides its malicious
behaviors among the benign behaviors of the processes.
In this paper, we present PROVDETECTOR, a provenance-
based approach for detecting stealthy malware. Our insight
behind the PROVDETECTOR approach is that although a stealthy
malware attempts to blend into benign processes, its malicious be-
haviors inevitably interact with the underlying operating system
(OS), which will be exposed to and captured by provenance mon-
itoring. Based on this intuition, PROVDETECTOR ﬁrst employs a
novel selection algorithm to identify possibly malicious parts in
the OS-level provenance data of a process. It then applies a neural
embedding and machine learning pipeline to automatically detect
any behavior that deviates signiﬁcantly from normal behaviors.
We evaluate our approach on a large provenance dataset from
an enterprise network and demonstrate that it achieves very high
detection performance of stealthy malware (an average F1 score
of 0.974). Further, we conduct thorough interpretability studies to
understand the internals of the learned machine learning models.
I.
INTRODUCTION
The long-lasting arms race on security warfare has entered
a new stage. Malware detection has greatly advanced beyond
traditional defenses [95], [92] due to innovations such as
machine learning based detection [108], [65], [54], [53] and
threat
the attacker
community has also sought for sophisticated attack vectors to
keep up with the advances. Adversaries are now increasingly
focusing on new techniques to evade detection and prolong
their presence on the target system.
intelligence computing [101]. However,
A new kind of technique, i.e., stealthy malware, hides the
malware’s (or an attacker’s) identity by impersonating well-
trusted benign processes. Besides simple methods such as
Network and Distributed Systems Security (NDSS) Symposium 2020
23-26 February 2020, San Diego, CA, USA
ISBN 1-891562-61-4
https://dx.doi.org/10.14722/ndss.2020.24167
www.ndss-symposium.org
renaming processes and program ﬁle names, more advanced
stealthy techniques are being actively developed and employed.
Unlike the traditional malware family that persists on the disk
for its payload, stealthy malware hides its malicious logic in
the memory space of well-trusted processes, or stores it into
less attended locations such as Windows registry or service
conﬁgurations. Recent reports [90] have estimated that stealthy
malware constituting 35% of all attacks, grew by 364% in the
ﬁrst half of 2019, and these attacks are ten times more likely
to succeed compared to traditional attacks [6], [4].
Despite the importance and urgency, we are yet to see any
deﬁnitive solution that detects stealthy malware which employs
advanced impersonation techniques. One reason is that stealthy
malware minimizes the usage of regular ﬁle systems and,
instead, only uses locations of network buffer, registry, and
service conﬁgurations to evade traditional ﬁle-based malware
scanners. To make things worse, the attacker has multiple
options to craft new attacks as needed using different im-
personation techniques. First, the attack can take advantage
of the well-trusted and powerful system utilities. The latest
OSes are shipped with well-trusted administrative tools to ease
the system operations; but these tools are commonly abused
targets. For instance, PowerShell and Windows Management
Instrumental Command-line (WMIC) have long histories of
being abused by attackers [52]. Second, an attack can inject
malicious logic into benign processes via legitimate OS APIs
(e.g., CreateRemoteThread() of Win32 API) or use shared
system resources. Finally, the attack can exploit vulnerabilities
of a benign program to gain its control. Since attackers have so
many options, the detection approaches that are based on static
or behavioral signatures cannot keep up with the evolution of
stealthy malware.
Based on the characteristics of stealthy malware, we sug-
gest that an effective defense needs to meet the following three
principles. First, the defense technique should not be based on
static ﬁle-level indicators since they are not distinguishable
for stealthy malware. Second, the technique should be able to
detect abnormal behavior of well-trusted programs as they are
susceptible to attackers with stealthy attack vectors. Third, the
technique should be light-weight so as to capture each target
program’s behavior at a detailed level from each host without
deteriorating usability.
Kernel-level (i.e., OS-level) provenance analysis [63], [30],
[56], [73], [55] is a practical solution that is widely adopted
in real-world enterprises to pervasively monitor and protect
their systems. Even when a malware could hijack a benign
process with its malicious logic, it still leaves traces in the
provenance data. For example, when a compromised benign
process accesses a sensitive ﬁle, the kernel-level provenance
will record the ﬁle access activity. OS kernel supports data
collection for provenance analysis incurring only a reasonable
amount of overhead when it is compared to heavy-weight
dynamic analyses such as virtual machine (VM) assisted-
instrumentation or sandbox execution [66], [62].
In this paper, we propose PROVDETECTOR, a security
system that aims to detect stealthy impersonation malware.
PROVDETECTOR relies on kernel-level provenance monitoring
to capture the dynamic behaviors of each target process.
PROVDETECTOR then embeds provenance data to build mod-
els for anomaly detection, which detect a program’s runtime
behaviors that deviate from previously observed benign execu-
tion history. Thus it can detect previously unseen attacks. To
hunt for stealthy malware, PROVDETECTOR employs a neural
embedding model [69] to project the different components
in the provenance graph of a process into a n-dimensional
numerical vectors space, where similar components are geo-
graphically closer. Then a density-based novelty detection [11]
method is deployed to detect the abnormal causal paths in
the provenance graph. Both the embedding model and the
novelty detection model are trained with only benign data.
However, while the design insight of PROVDETECTOR to
capture and build each program’s behavioral model using
provenance data seems plausible, the following two challenges
must be addressed to realize PROVDETECTOR.
C1: Detection of marginal deviation. Impersonation-based
stealthy malware tends to incur only marginal deviation for its
malicious behavior, so it can blend into a benign program’s
normal behavior. For instance, some stealthy malware only
creates another thread to plant its malicious logic into the
victim process. While the victim process still carries out its
original tasks, the injected malicious logic also runs alongside
it. Therefore, PROVDETECTOR needs to accurately identify
and isolate the marginal outlier events that deviate signiﬁcantly
from the program’s benign behaviors. Conventional model
learning is likely to disregard such a small portion of behavior
as negligible background noise, resulting in misclassiﬁcation
of malicious behaviors.
To address the ﬁrst challenge, PROVDETECTOR breaks
provenance graphs into causal paths and uses the causal paths
as the basic components for detection (§V-C).The insight of
this decision is that
the actions of stealthy malware have
logical connections and causal dependencies [60], [56]. By
using causal paths as detection components, PROVDETECTOR
can isolate the benign part of the provenance graph from the
malicious part.
C2: Scalable model building. The size of the provenance
graph grows rapidly over time connecting an enormous number
of system objects. For a provenance-based approach which
takes provenance data as its input and builds a model for each
process, it is common to see that even in a small organization
that has over hundreds of hosts, the system events reported
from each end-host incur signiﬁcant data processing pressure.
While simplistic modeling [39] that is based on a single-hop re-
lation scale to digest large-scale provenance graphs, the single-
hop relation cannot capture and embed contextual causality
into the model. However, a modeling that is based on a multi-
hop relation (e.g., n-gram [33] or sub-graph matching [40])
would incur huge computation and storage pressure, making
it infeasible for any realistic deployment.
To address this second challenge, PROVDETECTOR only
processes the suspicious part of a provenance graph. This is
achieved by a novel path selection algorithm (§V-C1) that only
selects the top K most uncommon causal paths in a provenance
graph. Our insight is that the part of a provenance graph that
is shared by most instances of a program is not likely to be
malicious. Thus, we only need to focus on the part that is
uncommon in other instances. Leveraging this path selection
algorithm, PROVDETECTOR can reduce most of the training
and detection workload.
To conﬁrm the effectiveness of our approach, we conducted
a systematic evaluation of PROVDETECTOR in an enterprise
environment with 306 hosts for three months. We collected
benign provenance data of 23 target programs and used
PROVDETECTOR to build their detection models. We then
evaluated them with 1150 stealthy impersonation attacks and
1150 benign program instances (50 for each target program).
PROVDETECTOR achieved a very high detection performance
with an average F1 score of 0.974. We also conducted
systematic measurements to identify features contributing to
PROVDETECTOR’s detection capability on stealthy malware.
Our evaluation demonstrated that PROVDETECTOR is efﬁcient
enough to be used in a realistic enterprise environment.
To summarize,
contributions:
in this paper, we make the following
• We designed and implemented PROVDETECTOR, a
provenance-based system to detect stealthy malware that
employs impersonation techniques.
• To guarantee a high detection accuracy and efﬁciency, we
proposed a novel path selection algorithm to identify the
potentially malicious part in the provenance graph of a
process.
• We designed a novel neural embedding and machine
learning pipeline that automatically builds a behavioral
proﬁle for each program and identiﬁes anomalous pro-
cesses.
• We performed a systematic evaluation with real malware
to demonstrate the effectiveness of PROVDETECTOR.
We further explained its effectiveness through several
interpretability studies.
II. BACKGROUND AND MOTIVATION
In this section, we introduce the stealthy malware we focus
on in this study and present our insights of using provenance
analysis to detect such malware.
A. Living Off the Land and Stealthy Attacks
“Living off the land” has been a popular trend in cyberat-
tacks over the last few years. It is characterized by the usage of
trusted off-the-shelf applications and preinstalled system tools
to conduct stealthy attacks. Since many of these tools are used
by system administrators for legitimate purposes, it is harder
for the defenders to completely block access to these tools for
attack prevention.
2
called “Empire” [12] to open encrypted backdoor. Note that
both of the downloaded PowerShell scripts are obfuscated and
resided only in memory.
B. Existing Detection Methods for Stealthy Malware
Existing detection methods, such as anti-virus (AV) soft-
ware, use a combination of the following practices [105]
to detect malware. As we will discuss, these methods are
ineffective at detecting stealthy malware.
Memory Scanning.
AV software offers memory scanning
as one of their multi-layered solutions. Such techniques scan
memory just-in-time at the loading point or in a scheduled
way. However, this approach essentially is looking for known
payloads in memory. Adversaries can customize or obfuscate
the attack payload to avoid detection.
Lockdown Approaches.
Lockdown approaches, such as ap-
plication control or whitelisting, do not help much as stealthy
malware often leverages administrative tools or other appli-
cations that are typically in a company’s whitelist of trusted
applications. The defenders could not completely block access
to these programs to block the attacks.
Email Security and Network Security. As shown in Figure 1,
script-based malware is often spread through phishing emails.
Many security vendors provide solutions for email and net-
work security by inspecting and blocking suspicious attacks
by evaluating URLs, attachment ﬁles, and scripts. However,
similar to the limitation of memory scanning, attack payload
is easy to be modiﬁed to avoid detection.
In particular, the existing in-host defenses are effective
against known ﬁle-based malware families. However, the char-
acteristics of stealthy malware, such as low attack footprint,
absence of ﬁles, usage of dual-use tool, make the detection
difﬁcult for existing methods.
C. Detecting Stealthy Malware Using Provenance Analysis
As discussed in §II-B, existing methods are ineffective at
detecting stealthy malware. Since it has multiple characteristics
to evade detection, we propose to detect stealthy malware by
inspecting its behavior. More speciﬁcally, our approach tracks
and analyzes the system provenance data related to a program
to hunt down stealthy attacks based on behavior differences.
Figure 2 illustrates an example of a stealthy attack and
the provenance graphs of two process instances of MS Word
(winword.exe) with and without an attack. In Figure 2a, we
show the provenance graph of a benign instance of MS Word.
A benign MS Word process typically reads multiple types of
ﬁles (e.g., dat, doc, css) created by other programs or itself
and writes new ﬁles (e.g., doc, txt, png). The created ﬁles
will also be read by other programs like the Outlook email
client (e.g., sent as an attachment). It can also start other
programs such as Internet Explorer (iexplore.exe) when
a user clicks the URLs in a doc ﬁle. In contrast, Figure 2b
shows the provenance graph of a malicious instance of MS
Word, which is used in the DDE script-based attack as shown
in Figure 1. Note that we highlight the key attack paths with
red arrows. Similar with the benign instance, this malicious
MS Word instance also reads and writes different types of
Fig. 1: The kill chain of the DDE script-based attack [5].
Stealthy impersonation malware, which has been increas-
ingly employed in recent cyberattacks [21], [90], heavily uses
the “living off the land” strategy to try to evade detection.
Instead of storing its payload directly onto a disk and executing
it, the malicious code is typically injected into some running
processes (often trusted applications or system tools) and
executed only within the process memory (i.e., RAM). There
are multiple ways to achieve such impersonation purpose.
Memory Code Injection. Memory code injection allows a
malware to inject malicious code into a legitimate process’
memory. These attacks often targets long-running,