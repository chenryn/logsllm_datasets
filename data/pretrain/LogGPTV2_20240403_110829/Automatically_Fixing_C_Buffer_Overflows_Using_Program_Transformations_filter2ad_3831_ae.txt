### 优化后的文本

#### 不安全函数的变化
- `strcpy`: 28/39 (71.8%)
- `strcat`: 72/115 (62.6%)
- `sprintf`: 1/2 (50%)
- `vsprintf`: 0
- `memcpy`: 0

图2展示了SLR对不安全函数的影响。

### 运行时开销
在实际应用中，这种转换的运行时开销只在一个案例中出现，并且可以忽略不计。具体来说：
1. 在一个案例中，缓冲区指针是缓冲区数组的一部分。由于我们不支持对数组的形状分析，因此无法处理这种情况。
2. 另一个案例中，缓冲区的定义是一个包含堆分配的三元表达式的结果。这是一个简单的结构修复问题，但由于它只在300次测试中出现了一次，我们选择忽略它。

### 安全类型替换（STR）
STR应用于所有局部作用域中的`char`指针，即在函数内部声明的指针。测试程序中有296个候选对象。其中，59个在用户自定义函数中以潜在不安全的方式使用。我们进行了跨过程的指针使用分析。当指针在用户自定义函数内部未被写入时，SAFE TYPE REPLACEMENT会替换该指针。如果指针被写入，则会在日志中打印详细消息，解释为什么不能完成转换。其余237个`char`指针通过了STR的预条件（表VI中的“Buffers Replaced”），这些指针都是局部声明和使用的。STR成功替换了所有237个`char`指针（100%）。表VI总结了结果。

### 表VI：测试程序上的STR运行结果
| 项目 | 数量 |
| --- | --- |
| 总候选数 | 296 |
| 潜在不安全使用 | 59 |
| 替换成功的缓冲区 | 237 |

### 测试与性能
对于所有转换，我们运行了`make test`来执行程序的测试套件。转换前后的测试结果一致，表明我们的转换没有破坏或改变功能。

### RQ3：对性能的影响
虽然我们的程序转换修复了缓冲区溢出，但可能会带来性能开销。我们使用开源程序集测量了开销。我们在所有可能的目标上应用了SLR和STR，并编译了每个程序（转换前后）。

- **SLR性能开销**：
  - libpng和LibTIFF经过大量转换（表V）。图3显示了libpng的性能数据。转换后没有明显的性能变化，因为SLR用行为相似的安全替代函数替换原函数。strlcpy系列函数的作者也报告了最小的开销[45]。
  - 对于libpng，转换后的版本在-O0、-O1、-O2和-O3优化级别下的运行时间分别增加了4.59%、3.01%、3.60%和1.22%。测试在ThinkPad笔记本上进行，配置为Intel Core i5-3210M 2.50GHz x 4 CPU，3.6GB RAM，Ubuntu 12.04 LTS操作系统，使用gcc-4.2编译。

- **STR性能开销**：
  - STR在libpng、zlib和LibTIFF上进行了测试。libpng和zlib的更改较少，但它们在热点循环中执行。而LibTIFF有大量的更改（表VI）。图4和图5显示了LibTIFF和zlib的性能数据。STR转换带来的开销相对较低。
  - 应用STR后，LibTIFF在-O3优化级别下的开销约为12%，zlib在-O3优化级别下的最高开销为18.83%。有趣的是，转换后的版本在-O0之后没有进一步优化。这直观上是有道理的，因为我们的转换仅在少数地方进行了修改。在-O1优化后，编译器在-O2和-O3优化级别上几乎没有更多的优化空间。
  - STR的测试在MacBook上进行，配置为2 GHz Intel Core 2 Duo处理器，4GB 1067 MHz DDR3内存，运行Mac OS X Lion 10.7.4，使用llvm-gcc 4.2.1编译。

### 相关工作
本节将我们的基于转换的方法与其他检测和修复缓冲区溢出漏洞的方法进行比较。首先讨论一般方法，然后讨论两种具体的转换。

- **一般方法**：
  大多数关于缓冲区溢出漏洞的研究集中在静态分析检测[10, 15, 18, 36, 38, 62, 63, 65]。动态分析方法主要集中在防止缓冲区溢出漏洞，除了少数检测方法[46, 55, 57]。静态方法从简单的词法分析器[62]到进行整数分析以近似C源代码中的指针算术[63]，再到应用抽象解释证明运行时错误的不存在[10]。早期的方法通常有较高的误报率，但使用符号分析检测缓冲区溢出的方法[2, 21, 22, 36, 54, 63, 65]报告了更好的结果。我们的程序转换则尝试通过替换所有不安全库函数和`char`指针来修复缓冲区溢出。

- **防御方法**：
  Cowan等人[13]确定了四种基本的防御缓冲区溢出漏洞的方法：(1) 编写正确的代码；(2) 使栈段不可执行；(3) 检查数组边界；(4) 检查代码完整性。

希望这些改进能帮助你更好地理解和传达你的研究内容。