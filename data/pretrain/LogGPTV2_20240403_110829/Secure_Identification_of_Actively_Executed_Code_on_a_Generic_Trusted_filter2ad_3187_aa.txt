title:Secure Identification of Actively Executed Code on a Generic Trusted
Component
author:Bruno Vavala and
Nuno Ferreira Neves and
Peter Steenkiste
2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks
Secure IdentiÔ¨Åcation of Actively Executed Code
on a Generic Trusted Component
Bruno Vavala1,2, Nuno Neves2, Peter Steenkiste1
1CSD, Carnegie Mellon University, U.S.
2LaSIGE, Faculdade de CiÀÜencias, Universidade de Lisboa, Portugal
Abstract‚ÄîCode identity is a fundamental concept for authenti-
cated operations in Trusted Computing. In today‚Äôs approach, the
overhead of assigning an identity to a protected service increases
linearly with the service code size. In addition, service code size
continues to grow to accommodate richer services. This trend
negatively impacts either the security or the efÔ¨Åciency of current
protocols for trusted executions.
We present an execution protocol that breaks the dependency
between the code size of
the service and the identiÔ¨Åcation
overhead, without affecting security, and that works on different
trusted components. This is achieved by computing an identity
for each of the code modules that are actually executed, and
then building a robust chain of trust that links them together for
efÔ¨Åcient veriÔ¨Åcation. We implemented and applied our protocol to
a widely-deployed database engine, improving query-processing
time up to 2√ó compared to the monolithic execution of the engine.
I.
INTRODUCTION
The continuous growth of Cloud Computing today has
increasingly fueled research on new security techniques. In
the past decade, special focus has been given to the protection
of security-sensitive application modules running on untrusted
third-party (UTP) platforms through the use of Trusted Com-
puting Components (TCCs). In the research literature, several
trusted execution architectures have been proposed [13, 42, 33,
21, 32, 8, 23, 31]. In the industry, on the other hand, TCCs
are primarily used for storing cryptographic material, e.g., as
in BitLocker [35] and Amazon CloudHSM [6], but prototypes
are emerging for securing complex software [25, 10].
In the Trusted Computing area, code identiÔ¨Åcation [17] is a
key mechanism for guaranteeing execution integrity. It consists
of: computing and attesting the identity of some code c on the
UTP side; and then verifying both the attestation and the code
identity on the client side. More precisely, the UTP includes a
TCC that computes c‚Äôs identity by hashing it. The TCC then
digitally signs c‚Äôs identity and sends the signed identity to the
client. This allows the client to verify that the correct code was
executed. By extending the same procedure to the input and
output data, the client is also able to verify that the received
output was obtained by running c with the correct input.
The major challenge with using code identiÔ¨Åcation for
securing increasingly complex software is that the overhead
to compute c‚Äôs identity before the execution grows linearly
with c‚Äôs size. In particular,
the overhead scales with the
size of the code that may be executed, not the size of the
code modules that are actually executed. Consequently, this
becomes a concern when the actively executed code is only a
fraction of the code base. In addition, such overhead should
not be considered as a one-time burden. In fact, frequent code
identiÔ¨Åcation is desirable to refresh the execution integrity
property, which is otherwise guaranteed only at load time.
In this paper we present a protocol for code identiÔ¨Åcation
and execution that breaks the coupling between code size
and cost of identiÔ¨Åcation. The protocol has two key desirable
features. First, the trusted architecture loads, identiÔ¨Åes and
runs only modules of the code base that are actually executed.
This provides execution Ô¨Çexibility to the UTP and saves TCC
resources. Second, the correct execution sequence of code
modules is guaranteed by a robust and veriÔ¨Åable execution
chain. Each module secures the application data using a secret
key that depends on its own identity and the identity of the
next module in the correct sequence. These two mechanisms
combined enable a secure and efÔ¨Åcient identiÔ¨Åcation.
The protocol further enables efÔ¨Åcient veriÔ¨Åcation on the
client side. In fact, the client checks that the correct code was
executed by only verifying a chain endpoint to bootstrap trust
in the whole chain. The client does not need to be aware a
priori of the exact execution order; also, unused code modules
have to be neither loaded nor veriÔ¨Åed.
Additionally, our protocol
We make the following contributions:
is agnostic to the details of
the TCC, which makes our contribution generally applicable.
The protocol performs downcalls (to the TCC) by means
of a simple and generic interface. Five primitives (including
one on the client side for execution veriÔ¨Åcation) represent
the bridge between the protocol and the trusted computing
services provided by the TCC, such as isolated code execution,
attestation and secure storage. These services are available, or
implementable, on different trusted components.
‚Ä¢ We design an efÔ¨Åcient protocol for the secure execution of
complex software inside a generic trusted component. The cost
of code identiÔ¨Åcation scales with the size of the modules that
are executed, rather than with the size of the service code base.
‚Ä¢ We analyze the security of our constructions. Also, we
introduce a novel zero-round key sharing technique for trusted
executions that improves performance with minimal changes.
‚Ä¢ We implement the protocol on a hypervisor-based TCC
(XMHF/TrustVisor [32, 46]). We apply it
to the widely-
deployed SQLite DB engine [40], formally verify its correct-
ness, and show its performance beneÔ¨Åts.
The paper is organized as follows. We elaborate on the
challenges of securing remote code execution and outline our
solution in Section II. We provide background on TCCs in
Section III and deÔ¨Åne our protocol in Sections IV. We describe
our implementation, formal veriÔ¨Åcation and experimental eval-
978-1-4673-8891-7/16 $31.00 ¬© 2016 IEEE
DOI 10.1109/DSN.2016.45
419
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:56 UTC from IEEE Xplore.  Restrictions apply. 
Static Root of 
Trust: a system 
is able to boot 
in a verifiable 
trusted state. 
[2004] 
TOCTOU 
Problem: static 
measurements 
do not reflect 
later changes. 
[2005-] 
Dynamic Root 
of Trust: build 
a new robust 
and verifiable 
chain of trust 
on demand. 
[2008] 
Fast Trusted 
Computing: 
combine slow 
trusted chips  
with software 
on main CPU. 
[2010-] 
Large Trusted 
Executions: 
implement 
large services 
in the trusted 
environment. 
[2011-] 




)
s
m
(
y
c
n
e
t
a
L

		

Fig. 1: Trends in Trusted Computing research work show an initial focus on
reducing the Trusted Computing Base (TCB), while recent advances in tech-
nology enable to secure entire unmodiÔ¨Åed services, thus enlarging the TCB.
Code Size (KB)
Fig. 2: Security-sensitive code registration latency in XMHF/TrustVisor. It
shows a linear dependence between code size and protection overhead.
timeline





uation in Section V. In Section VI we devise and validate a
performance model for code identiÔ¨Åcation. We review related
work and draw conclusions in Section VII and VIII.
II. TOWARDS FLEXIBLE TRUSTED EXECUTIONS
Current trends (Fig. 1) in Trusted Computing (TC) evi-
dence that the code used in trusted executions is growing.
We show that this raises either efÔ¨Åciency or security concerns
in TC architectures, and that this is a result of how code
identiÔ¨Åcation is done today [17]. This helps us deÔ¨Åning the
problem statement, goals, and outlining our solution.
A. Previous Work
Early work used trusted hardware to verify the integrity
of a system‚Äôs initial state [37, 26]. The mechanism involves
identifying‚Äîtaking integrity measurements, i.e., hashing‚Äîthe
software components (e.g., BIOS, boot loader, OS, applica-
tions) that bring the system into an operative state. The identi-
ties are stored on trusted hardware (e.g., a TPM) and conveyed
to a client through an attestation. The client bootstraps trust
in the system‚Äôs initial state by verifying the validity of the
attestation and matching the identities with the expected ones.
Preserving trust during the execution is hard. Operating
systems are constantly subject to attacks; vulnerabilities are
discovered on a daily basis [2]; and tools are available to
exploit them [1]. Hence, the guarantee that a system is trusted
at a certain point in time may not hold later‚Äîthis is also known
as time-of-check-time-of-use (TOCTOU) gap [38, 11].
This gap was reduced through the notion of late launch
[20] to create a Measured Launch Environment on demand.
Flicker [33] shows that the technology can be used to run
a security-sensitive piece of code in isolation. The result is
a dramatic reduction in TCB size and, consequently, of the
attack surface. Subsequently, given the poor performance of the
low-power hardware modules, solutions were devised to speed
up the computation [32, 8]. Instead of relying directly on the
hardware module, trust is extended to a small trusted software
module that enables faster code identiÔ¨Åcation. Recently, faster
trusted hardware has also been proposed [34].
Improvements on TC technology have made it possible to
grow the code base from a few KB to hundreds of MB. In
fact, in order to provide security guarantees to a broader set of
applications, some works have secured entire database engines
[9, 47], and even unmodiÔ¨Åed Windows binaries such as SQL
Server and Apache HTTP Server [10].
B. Security or EfÔ¨Åciency, But Not Both
There are currently two alternatives to deal with such
large code bases, and both come with big downsides. We dub
the Ô¨Årst as measure-once-execute-forever [10]. The integrity
420
measurement is taken only before the execution of the code,
which then continues in the trusted environment indeÔ¨Ånitely.
This approach brings us back to the TOCTOU problem. Since
the integrity measurement of a code base is only taken once, it
will not detect any later successful attack that compromises it.
The second alternative is instead dubbed measure-once-
execute-once. The measurements are repeated before each ex-
ecution (e.g., a Flicker [33] based application). This approach
instead may raise efÔ¨Åciency issues. In fact, in order to assign an
identity to the code, this must be loaded Ô¨Årst and then hashed.
As an example, in Fig. 2 we quantify this load-and-hash
cost on XMHF/TrustVisor [32, 46], a recent tool for efÔ¨Åcient
and secure code execution. We measured the time to register
different code bases. During this procedure, the memory pages
of the code are isolated and identiÔ¨Åed. The time scales linearly
with the code size reaching about 37ms for just 1MB of code.
Such a linear dependence holds also for Intel SGX [25,
34], used to build secure Enclaves. In fact, after an En-
clave is created and protected (ENCLS[ECREATE] instruction),
code pages must be added and measured (ENCLS[EADD],
ENCLS[EEXTEND]), before Ô¨Ånalizing the Enclave and Ô¨Åx its
identity (ENCLS[EINIT]). Hence, the overhead of creating an
Enclave identity grows with the code size. We lack however
an SGX-enabled platform to measure the (likely lower) slope.
C. Problem DeÔ¨Ånition
Clearly, the code identiÔ¨Åcation cost has become a bottle-
neck. If the code is identiÔ¨Åed only once, identity integrity
stales over time;
the
overall execution time may increase considerably for large
code bases. The ideal balance is to have non-stale identities
and an execution time less dependent from code base size.
if the code is identiÔ¨Åed repeatedly,
In this paper, we aim at making the secure execution cost
scale with the size of the actually executed code, instead of
the size of the code base as a whole, independently from the
used trusted component. Such generally-applicable method can
balance the cost of re-identifying some code to refresh integrity
guarantees and further reduce the active TCB size.
In summary, we seek to attain the following properties:
1) Secure proof of execution. The proof of execution of the
correct code must be unforgeable, unambiguous, and linked
to the hardware root of trust.
2) Low TCC resource usage. The protocol should achieve
security with minimal resource (code identiÔ¨Åcation, cryp-
tography, storage, etc.) demand on the TCC.
3) VeriÔ¨Åcation efÔ¨Åciency. The overhead for the client should
be constant, independently from the code base‚Äîi.e., a Ô¨Åxed
number of hashes and digital signatures.
4) Communication efÔ¨Åciency. The protocol should be ‚Äùnon-
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:56 UTC from IEEE Xplore.  Restrictions apply. 
interactive‚Äù, requiring only a small additional constant
amount of trafÔ¨Åc to enable successful client veriÔ¨Åcation.
5) TCC agnostic execution. The protocol should use any
underlying TC architecture as a black-box, thus allowing
to retroÔ¨Åt existing trusted components.
D. Overview of our Solution
The core of our solution is displayed in Fig. 3. On the
left, the code base is depicted as a set of logically connected
modules (arrows express the control Ô¨Çow graph) stored on the
UTP, working together to provide a service. On the right,
our protocol works as follows. It executes in the sequence on
the TCC 1(cid:2) the modules of the code base that are necessary
for the requested service (e.g., module C is not
loaded).
Given a particular client request, only the modules required to
serve it are considered active (A and B in the Ô¨Ågure). Active
modules are loaded and run according to the correct execution
order. Each module secures 2(cid:2) the intermediate state before
it terminates. The next active module is then executed 3(cid:2) and
it validates the previous intermediate state 4(cid:2). Such state is
passed through modules by means of logical secure channels.
to having a single identity assigned to the
code base, each module has its own identity. This identity is
calculated as the hash of the code. This allows us to maintain
backward compatibility, so to achieve a general solution that is
implementable on current TCCs. Our protocol builds a robust
execution chain based on the identities of the modules, and
guarantees that the modules are executed in the correct order
with respect to the control Ô¨Çow graph.
In contrast
Each executing active module has access to data and
resources required for the computation. Before the execution,
each module is expected to receive some input from the client
(e.g., a request) or some intermediate state from other modules.
Similarly, when it terminates, each module is expected to
produce either an output for the client (e.g., a reply) or some
intermediate state to be processed by the next module in the
execution Ô¨Çow. Before and after the execution, every piece
of data to/from any module is handled by the UTP in the
untrusted environment; consequently, it must be secured by
means of the available TCC resources (e.g., secure storage).
An executing active module has access to the Identity
Table (or identity set) of the code base. Such module can thus
leverage TCC-based access control mechanisms to secure data.
Intermediate states are transferred between modules through