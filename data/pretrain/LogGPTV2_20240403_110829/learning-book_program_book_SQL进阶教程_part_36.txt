是从前面几个关于封闭性的例子来看，这句话还是很有说服力的。笔者经
常听到有人说在实际工作中理论并没有太大作用，但是笔者认为那是极大
的误解。
Theory is practical.
---
## Page 246
2-4地址这一巨大的怪物一
233
地址这一巨大的怪物
为什么关系数据库里设有指针
Codd提出关系模型的主要动机是将数据存储和管理从物理层的束缚中解放出来。关系数据库的历史
可以说是将编程行为从对地址的依赖中解放出来的奋斗历史。
在关系模型诞生之前的研究工作中，最大动机是明确区分数据管理中
注0
的逻辑层和物理层。我们可以把它叫作数据独立性目标·（data independence
按据 GL ete 在Ortaee n Opte
Relst:ioxs7 Theory for Pnicti/t:ioners
objective ) @
一书中的描述，数据独立性意味
着我们能够自向地改变数据的物
—Codd
理存储和动网方式，无须按阳数
据被用户感知的方式进行相应的
一般说到关系数据库中没有指针时，并不是说在物理层也完全没有指
修改。
—编者注
针。相反，在物理层，指针是存在的。但是，就像前面说过的那样，在关
注
换自（关系数据库：生产力的实
系系统中，物理层的详细存储信息对用户是不可见的。·
用基础)
C.J. Date
注司
资自 (数据率系统导论 (第7期 1);
写在前面
构。但是严格来说，它其实是存在的，只不过被隐藏了，因而对用户不可见。
不过，如果这么说，可能会有人列举出用户可以使用的指针，比如Oracle
中的rowid或PostgreSQL中的oid来反对。确实，用户可以使用这些指针，
但是它们都是个别数据库厂商违反SQL标准而进行的扩展，而标准SQL
一直在努力摆脱指针。因为SQL和数据库都在极力提升数据在表现层的
抽象度，以及对用户隐藏物理层的概念。
但是反过来，对于已经习惯C语言中指针操作的程序员来说，这种
做法可能有些奇怪。时不时就会有人批评道：“SQL中不能进行指针操作，
非常不方便，这是一个缺陷”。
---
## Page 247
234—第2章关系数据库的世界
面向过程语言的程序员不喜欢SQL
关系模型是为摆脱地址而生的
在进入正题之前，笔者想先强调一些理所当然的事情。请大家思考时
弃掉作为程序员的一些先入为主的观念。在现实世界的各种业务中，归
根到底，我们想要的是“数据”，而不是“用于表明数据位置的地址”地
址什么的只会增加额外的工作，丝毫不会让我们感到高兴。这一点，笔者
认为怎么强调都不算过分，因为计算机中已经出现了违背我们意愿的地址
溢出问题。还有，如果使用C语言或者汇编语言，程序员甚至不得不在编
程过程中有意识地操作地址。
但是在1969年，数据库的世界几乎成功地摆脱了地址。Codd在谈论
关系模型理论时用到的“数据独立性目标”的概念，指的就是将数据库从
地址中解放出来（相反，关系模型之前的数据库模型，例如分层模型和网
状模型，都严重地依赖地址）。当时的编程世界还在进行看指针操作，因
此这是非常超前的尝试。归功于此，现在的数据库工程师不用在意数据的
存储地址了，他们只需关注数据内容就可以了，
关于这一点，Codd曾经明确地这样说过。
在计算机编址中，位置的概念总是起看重要作用，从插板地址开始
然后绝对数值编址、相对数值编址以及带有算术性质的符号编址（例如，
汇编语言中的符号地址 A+3；在Fortran、Algol或PL/I 中称为X的数组中
一个元素的地址X（+1,J-2）。在关系模型中，我们通过完全关联的编址
来代替位置编址。在关系数据库中，每个数据可以借助于关系名、主键的
值以及属性名唯一地编址。这种形式的关联地址使用户（是的，也使得程
序员）把以下两点留给系统来完成：(1)确定要插入数据库的一块新信息的
注0
放置细节：(2)当检索数据时选择适当的存取通路。·
指白（关系数报库：生产力的实
用基础)。
需要注意的是，这里说的“地址”不仅包括指针操作的地址，还包括
数组下标等。Codd对所有依赖地址的数据存储和管理都感到厌焕（正因
如此，最初的关系模型中并没有出现数组）。
图灵社区会员 非洲钢(PI:EMAIL) 专享 尊重版权
---
## Page 248
2-4地址这—巨大的怪物—23.5
和Codd长期共事过的CJ.Date曾经像下面这样赞扬过Codd用心做
出的努力。
其次，数据库中的关系无论如何都不能具有指针的那些属性。众所周知，
关系数据库出现以前，数据库中充满了指针的概念，为了访同到想要的数
据必须借助很多指针。对这些数据库进行应用程序编程时很容易出现错误，
而且数据不能由终端用户直接访问，这些同题都是指针导致的。Codd试图
注0
通过关系模型解决这些同题，并取得了成功。·
Datatase n Depcth: felatonrT
Theory for Prect itfoners,
0"Rely eds, 2005
数据的管理方法，从依据位置变为了依据内容。这个变化刚好与从物
理层向逻辑层（抽象化）从符号向名字（意文化）的转变相对应。很明显，
这给系统的终端用户和程序员带来了非常大的好处。不论对谁来说，“翔
于理解。因此放弃地址的深刻意义是，通过放弃掉系统中没有意文的东西，
创造出一个易于人类理解的有意义的世界。Codd之所以与成千上万的普
注9
通程序员不同，原因在于他对人类认知特点的深刻理解·。
过于强大的润察能力也特来了一
个不好的结果，那就是引人了臭
“在关系模型中，我们通过完全关联的编址来代替位置编址。”Codd的
名昭著的多值逻辑。详情读参考
1-3 节和 2-8节
就一直困扰着数据库工程师的难题，即“如何逃出地址的魔咒”。而关系
注图
数据库的成功也证明了Codd的这一观点的正确性·。也就是说，一个优
标准S0L不支持白动编号功能，
以及许多理论家对代理键持批评
雅的数据结构胜过一百行杂要般的代码。突然想起来，ES.Raymond也曾
的态度，都是出于同样的埋由。
说过类似的话。
精巧的数据结构搭配策拙的代码，远远好过策拙的数据结构搭配精巧
注9
的代码。
Tbe CathedraI & the Bazaer:
by an Accerta? Retoary,
Msings or Lr anf 0pe Sure
版可参考（大教堂与集育）1机
0'Reily Medla, 2001 年。 中 文
域工业出版社, 2014 年 L
虽然关系模型确实是优雅且强大的数据模型，但是也没能使数据库彻
I htt.p:/ww,.cetb,orng/=esr/
rt:ings/cathedral-bazaan/]
底地摆脱地址。从物理层来看，数据还是与以前一样由地址来管理。但是
如果因此就断言Codd的“数据独立性目标”半途而废了，还是有些苛刻的。
（目前）我们可以使用的只有冯·诺依曼型计算机，它不仅使用地址管理
数据，而且要求运行于其上的程序也要这样。因此，其实更应该说，Codd
---
## Page 249
236—第2章关系数据库的世界
是在受到各种限制的情况下思考出了关系模型这一折中的方案。
即使放眼SQL之外的其他编程语言，各个编程语言的历史中也都一
Pascal、Java、Perl 等新一代的语言都在努力地对用户隐藏指针。在这一
点上，关系数据库与SQL的发展轨迹是一致的。
对冯·诺依曼型计算机感到不满的人中，Codd的态度还算温和，而
有些人的批评就很尖锐了，其中之一就是约翰·巴克斯（John Backus，
1924—2007)。他是Fortran语言和 BNF范式的发明人，于1977年获得了
图灵奖（顺便说一下，Codd是1981年的图灵奖获奖者）。他认为，受到
冯·诺依曼型计算机数据管理方式的限制，连编程的世界都充满着巨多地
址，地址已经泛澄了。
因此程序设计基本上是通过冯·诺依曼瓶颈来计划和实现大量字的交
通的细节策划，而且这个交通的许多部分不仅涉及重要的数据本身，而且
注0
还涉及在哪里找到它。·
指白（程序论计能从冯 · 泌依量
风格中解放出来码？程序的函数
风略及其代致)）（收录于（AOM图灵
关于编程语言受限于地址的结果，约翰·巴克斯这样感概道：“这
奖演进其： 前20年 (196-1985 1)
1电子工业出张社, 2008年1) 1英文
二十年，编程语言一步一步地发展成了现在这样雕肿的样子”，从他发出
原文地 址 为http:/l,ecs,ong/
citatlor,cf#2ld=359579 l
感到现在又过了二十年，这一状况还是没有得到改善，甚至一直在恶化。
因为过去的二十年间又诞生了很多新的语言，但是其中没有一种语言真正
摆脱地址这一怪物，实现真正的自由。
当然，一定程度上对使用者隐藏地址也确实是编程语言的进步。但是
深入到内部看的话，还是到处都充斥着如同洪水一般的地址。面向对象的
方法也没能成为通用的杜绝地址泛溢的有效手段。因为对象仍然是由OID
这样的地址来管理的，而且程序变得复杂后，对象会被大量生成，这样就
和以往的面向过程语言中大量声明变量没有什么区别了。
是的，变量一—它正是编程语言中地址的化身。所有的变量都由没
有实际意义的地址管理着。而且，要想在面向过程语言中处理数据，只
能通过把数据赋值给变量。只要使用变量，就无法逃出地址的魔咒。反
过来说，之所以SQL能成为不依赖于地址的自由的语言，也是因为它不
使用变量。
---
## Page 250
2-4地址这巨大的怪物—237
不曾远去的老将—一J.Backus的梦想
与SQL一样不使用变量的语言还有Lisp-它是一种年龄仅次于
约翰·巴克斯也曾经将摆脱冯·诺依曼风格的希望寄托在它（所代表的函
数式语言）身上。
确实，寄希望于Lisp或Haskell也是不无道理的。就笔者个人而言，
也希望SQL能加入它们的战斗行列。实际上，SQL和函数式语言有很多
注0
的共同点，作为编程语言，它们的发展方向也很相近。已经双双离世的
请参考 26 节。 业外, Joe Delko
性曾多次提到两者的共同点,请
约翰·巴克斯和Codd应该不会反对笔者这样的说法吧？
参考（50L.解感（第2涨1)谜题
61“对字拍串排序”。
声明式语言SQL和函数式语言Lisp在当今的编程世界里都处于边缘，
而且从来没有成为主流语言过。但是最近SQL中增加了许多丰富的功能，
渐渐到了需要重新评价SQL和函数式语言优点的时候了。“地址的解放战
争”最终有怎样的归宿，现在还不好预测，但是笔者期待能够在不久的将
来写一写它。
---
## Page 251
238-
第2章关系数据库的世界
GROUPBY和PARTITIONBY
物以“类”聚
在SQL的功能中，GROUPBY和PARTITIONBY非常相似—也可以说几乎一样。而且，两者
都有数学的理论基础。本节将以集合论和群论中的“类”这一重要概念为核心，闸明GROUPBY和
PARTITION BY的意义。
在使用SQL进行各种各样的数据提取时，一个需用的操作是按照某
种标准为数据分组。不仅是使用SQL的时候，在日常生活中整理或者分
析数据时，我们也经常需要给数据分组。
SQL的语句中具有分组功能的是GROUP BY和PARTITIONBY，它们
都可以根据指定的列为表分组。区别仅仅在于，GROUPBY在分组之后会
把每个分组聚合成一行数据。
例如，有下面这样一张存储了几个团队及其成员信息的表。
Teams
大木
28
选见
19
新蒂
4
23
山田
40
久本
29
桥田
30
野野宫
28
鬼深
O
28
加蒂
24
新城
D
22
对这张表使用GROUPBY或者PARTITIONBY，可以获取以团队为单
位的信息。无论使用哪一个，都可以将原来的表Teams分割成下面几个子
集，然后通过SUM函数进行聚合，或者通过RANK函数计算位次。
---
## Page 252
25 GROUP BYi PARTITION BY -
239
SELBcT menber, tean, age .
RANK() OVER(FARTITION BY tean ORDER BY age DESCI rn,
ROM_NUMBER() OVER (PARTITION BY team ORDER BY age DESC) rov_mun
DENSE_RABB.() OVER (FARTITIOB BY tean ORDER BY age DESC) denSe_rn,
PROM Menbers
ORDER BY tesn, rn/
■执行结果
menber
tean
age
unu nox uxosuepux
==
大木
28
新幕
A
23
1
1
A
逸见
A
19
山田
3
3
久本
4 0
B
29
桥田
C
DE
2
野野宫
鬼坏
2 8
28
加幕
D
24
新城
22
分割后的子集如下图所示。