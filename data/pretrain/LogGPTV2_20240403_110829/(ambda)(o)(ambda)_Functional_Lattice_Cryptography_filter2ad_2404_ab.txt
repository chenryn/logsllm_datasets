5.2.2 Generic Language Components
. . . . . . . . . . . . . . . . . . . 145
Plaintext DSL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
5.2.3
. 151
5.3.1 BGV-style SHE in Î›âˆ˜ğœ† . . . . . . . . . . . . . . . . . . . . . . . . 151
Interpreters
. 155
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
5.4.1
5.4.2 Expression Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
5.4.3 Expression Duplicator
. . . . . . . . . . . . . . . . . . . . . . . . 157
. . . . . . . . . . . . . . . . . . . . . . . . . 159
5.4.4 Logging Error Rates
5.5 Plaintext-to-Ciphertext Compiler . . . . . . . . . . . . . . . . . . . . . . . 163
5.5.1
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
5.5.2 Tracking Noise, Statically . . . . . . . . . . . . . . . . . . . . . . 165
5.5.3
Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
. 170
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 Ciphertext DSL .
.
. .
.
Pretty-printer
5.6 Future Work . .
Interface .
.
.
5.4
6.1 Homomorphic Evaluation of Symmetric-Key Primitives . . . . . . . . . .
Chapter 6: Fast Homomorphic Evaluation of Symmetric Key Primitives . . . . . 172
. 172
6.1.1 Homomorphic Evaluation of AES . . . . . . . . . . . . . . . . . . 174
6.1.2
In Search of Efï¬cient Alternatives . . . . . . . . . . . . . . . . . . 175
6.1.3 Our Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
. 178
6.2 Homomorphic Computation of Ring Rounding . . . . . . . . . . . . . . .
6.3 Rounding Circuit for Small Moduli . . . . . . . . . . . . . . . . . . . . .
. 180
6.4 Homomorphic Computation of the BPR Weak PRF . . . . . . . . . . . . . 183
6.4.1 BPR Weak PRF . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
6.4.2
PRF Instantiation . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
6.4.3 Homomorphic Evaluation . . . . . . . . . . . . . . . . . . . . . . . 186
. 187
Security of PRF . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
Security of Homomorphic Evaluation . . . . . . . . . . . . . . . . 190
6.6 ALCHEMY Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . 191
6.6.1
. . . . . . . . . . . . . . . . . . . . . . . 191
6.6.2 Ring Rounding . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
6.6.3 BPR PRF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
6.5 Security of the PRF Instantiation . . . . . . . . . . . . . . . . . . . . . .
Integer Rounding Circuit
6.5.1
6.5.2
viii
6.7 ALCHEMY Evaluation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
.
7.1 Contributions
7.2 Cut-and-Choose Protocol
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Protocol Description and Properties
. . . . . . . . . . . . . . . . . . . . . . . . . .
Chapter 7: Challenges for Ring-LWE . . . . . . . . . . . . . . . . . . . . . . . . 199
. 201
7.1.1 Challenge Instantiations
. . . . . . . . . . . . . . . . . . . . . . . 204
7.1.2 Other Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . 210
7.1.3 Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
. 212
7.2.1
. . . . . . . . . . . . . . . . . 213
7.2.2 Alternative Protocols . . . . . . . . . . . . . . . . . . . . . . . . . 216
7.2.3 Veriï¬er and Error Bounds . . . . . . . . . . . . . . . . . . . . . . . 218
. 221
7.3.1 Error Parameter . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
7.3.2 Modulus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
7.4 Hardness Estimates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 225
7.4.1 Ring-LWE/LWR as BDD . . . . . . . . . . . . . . . . . . . . . . . 226
7.4.2 Root-Hermite Factor
. . . . . . . . . . . . . . . . . . . . . . . . . 229
7.4.3 BKZ Block Size . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
. 231
Implementation Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
7.3 Parameters .
.
.
.
7.5
References
.
. .
. .
. .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
ix
LIST OF TABLES
4.1 Source lines of code for Î›âˆ˜ğœ† and HElib+NTL. . . . . . . . . . . . . . . . . 117
4.2 Number of functions per argon grade: cyclomatic complexities of 1â€“5 earn
an â€˜A,â€™ 6â€“10 a â€˜B,â€™ and 11 or more a â€˜C.â€™ . . . . . . . . . . . . . . . . . . . 118
4.3 Runtimes (in microseconds) for conversion between the powerful (P) and
CRT (C) bases, and between the decoding (D) and powerful bases (P). . . . . 121
4.4 Runtimes (in microseconds) for multiplication by ğ‘” in the powerful (P) and
CRT (C) bases, division by ğ‘” in the powerful and decoding (D) bases
. . . . 121
4.5 Runtimes (in microseconds) of twace and embed for UCyc . . . . . . . . . . 122
4.6 Runtimes (in milliseconds) for basic SHE functionality, including encrypt,
decrypt, ciphertext multiplication . . . . . . . . . . . . . . . . . . . . . . 122
4.7 Runtimes (in milliseconds) for SHE noise and ciphertext management oper-
ations
.
.
.
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
4.8 Runtimes (in milliseconds) for ring tunneling . . . . . . . . . . . . . . . . 124
6.1 Performance comparison with prior homomorphic evaluations of AES [GHS12c;
Che+13]. .
.
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
6.2 Sequence of plaintext (PT) and ciphertext (CT) cyclotomic ring indices used
for ring tunneling from ğ‘… = ğ’ª128 to ğ‘† = ğ’ª7,680. . . . . . . . . . . . . . . . 190
7.1 Hardness estimates for a selection of our continuous Ring-LWE challenges . 227
7.2 Hardness estimates for a selection of our Ring-LWR challenges . . . . . . . 228
7.3 Root-Hermite factor thresholds for our qualitative hardness estimates . . .
. 230
x
LIST OF FIGURES
3.1 Representative methods from the Tensor class . . . . . . . . . . . . . . . . 58
3.2 Representative functions for the Cyc data type . . . . . . . . . . . . . . . . 83
4.1 Representative (and approximate) code from our implementation of an SHE
.
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
scheme in Î›âˆ˜ğœ†.
4.2 Comparison of ring hopping and ring tunneling from a ring ğ» to a ring ğ»â€²
. 97
4.3 Cyclomatic complexity (CC) of functions in Î›âˆ˜ğœ† and HElib+NTL . . . . . 119
4.4 A real-world example of hybrid plaintext/ciphertext rings that could be used
to efï¬ciently tunnel from ğ‘… = ğ’ª128 to ğ‘† = ğ’ª4,095. . . . . . . . . . . . . . . 124
7.1 The canonical embedding of: (in dark blue) the dual ideal ğ‘…âˆ¨ of the 3rd
cyclotomic ring ğ‘… = Z[ğœ3], (in light blue) its â€œdecodingâ€ Z-basis {ğ‘‘0, ğ‘‘1},
and (in red) the continuous spherical Gaussian ğ·ğ‘Ÿ of parameter ğ‘Ÿ =
âˆš
2.
. . 207
xi
SUMMARY
Lattice cryptography has many compelling features, like security under worst-case hard-
ness assumptions, apparent security against quantum attacks, efï¬ciency and parallelism, and
powerful constructions like fully homomorphic encryption. While standard constructions
such as lattice-based key exchange are starting to be deployed in real-world scenarios, the
most powerful lattice cryptosystems are still limited to research prototypes. This is due in
part to the difï¬culty of implementing, instantiating, and using these schemes.
In this work we present a collection of tools to facilitate broader use of lattice cryp-
tography by improving accessibility and usability. The foundation of this work is Î›âˆ˜ğœ†, a
general-purpose software framework for lattice cryptography. The Î›âˆ˜ğœ† library has several
features which distinguish it from prior implementations, including high-level abstractions
for lattice operations, advanced functionality needed for applications like homomorphic
encryption, and safe interfaces.
Many efï¬cient lattice cryptosystems are based on the relatively new Learning With
Errors over Rings (Ring-LWE) problem. In order to attract cryptanalytic effort and improve
concrete security estimates for this widely used problem , we publish challenges for Ring-
LWE and the related Learning With Rounding over Rings problem. Unlike challenges for
other cryptographic problems like integer factorization, a dishonest challenger can make
Ring-LWE challenges which are much harder to solve than properly generated ones. Thus
we propose and implement a non-interactive, publicly veriï¬able cut-and-choose protocol
which provides reasonably convincing evidence that the challenges are properly generated.
Finally, we introduce ALCHEMY, a domain-speciï¬c language and compiler for homo-
morphic computations. In existing implementations of homomorphic encryption, users must
manually represent a desired plaintext computation as a much more complex sequence of
operations on ciphertexts. ALCHEMY automates most of the steps in this process, which
dramatically reduces the expertise needed to use homomorphic encryption.
xii
CHAPTER 1
INTRODUCTION
The ï¬eld of cryptography is concerned with all aspects of information security in the
presence of an untrusted or malicious party. There are a host of cryptographic primitives
such as hash functions, pseudo-random functions, public- and private-key encryption,
signature schemes, which can be used to solve particular problems in cryptography. At their
core, all cryptographic primitives rely on a computationally intractable or â€œhardâ€ problem.
Typically these problems are well-studied and believed to be computationally intractible,
e.g., mathematical problems like factoring [RSA78; Rab79], quadratic residuocity [GM84],
decoding error correcting codes [McE78], and computing discrete logarithms [DH76]. Since
Ajtaiâ€™s seminal work in 1996 [Ajt04], cryptographers have additionally created primitives
which derive their security from hard problems on lattices.
1.1 Advantages of Lattice Cryptography
Lattice cryptography refers to a diverse set of cryptographic constructions that derive their
security from hard problems on point lattices in Rğ‘›, i.e., a discrete additive subgroup of Rğ‘›.
These objects have been studied since 1842 by the likes of Dirichlet and Minkowski [Ajt04].
Lattice cryptography has many features which make it a compelling alternative to number-
theoretic cryptography. Among these are its apparent quantum security, its ability to
have security from worst-case hardness assumptions, and powerful constructions like fully
homomorphic encryption. We explore the many advantages in more detail below.
Performance. Early lattice cryptosystems [AD97; GGH97] were impractical due to large
keys and ciphertexts. In particular, the [AD97] public-key encryption scheme had public
keys of size Ëœğ’ª(ğ‘›4) and ciphertexts of size Ëœğ’ª(ğ‘›2), with similar runtimes for encryption and
1
decryption, respectively. However, the NTRU public-key encryption scheme introduced
by [HPS98] demonstrated how the use of algebraically structured lattices (corresponding
to polynomial rings) can lead to very efï¬cient cryptography using lattices. Efï¬ciency was
further improved with the introduction of the Learning with Errors (LWE) problem [Reg09].
These two improvements were eventually combined into the ï¬‚exible and efï¬cient Ring-LWE
problem [LPR13b], which has been widely used in lattice cryptosystems. These efï¬cient
schemes are broadly known as ring-based cryptography.
Parallelism. Most modern hardware supports some form of parallelism, e.g., via vector
instruction sets, multiple cores, or graphics processing units (GPUs). Lattice cryptosystems
are well-poised to take advantage of this hardware parallelism because lattice operations in
Rğ‘› can be performed in ğ’ª(log ğ‘›) or even ğ’ª(1) parallel operations on ğ‘› processors. This has
the potential to make expensive applications, like fully homomorphic encryption, usable in
practice. Parallelism in lattice cryptography has only recently been explored using hardware
vector instructions [Alk+16; Bou+17] and GPUs [Wan+12].
Quantum Security.
In some cryptographic applications (like message authentication), we
only need to consider the current computational abilities of an adversary. With applications
like encryption though, we might require that an adversary who collects encrypted data today
should not be able to read it for (say) the next 100 years. This means we must account for
computational and algorithmic advances which may take place over that period, including
the possibility that future attackers may have access to more powerful computational models
that do not exist today.
One such model that has been widely studied is the quantum computer. Considerable
work been done towards actually constructing a large-scale quantum computer. Further-
more, it appears that quantum computers offer additional computation power compared
to classical devices. In particular, Peter Shor [Sho97] showed that cryptography relying
on the intractibility of factoring large numbers or computing discrete logarithms would be
2
insecure with mature quantum computing (though these problems are apparently secure
against a classical adversary). Researchers have also tried to attack lattice problems with
quantum algorithms, but have so far come up empty handed. This gives lattice cryptography
the distinguished property of having (apparent) quantum security, which has led to interest