# lsns -t net            NS TYPE NPROCS   PID USER    NETNSID NSFS COMMAND    4026531992 net     283     1 root unassigned      /usr/lib/systemd/systemd --switched-root --system --deserialize 16    4026532241 net       1  7734 root unassigned      ./clone-ns    
# nsenter -t 7734 -n ip addr    1: lo:  mtu 65536 qdisc noop state DOWN group default qlen 1000        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00解决问题那理解了 Network Namespace 之后，我们再来看看这一讲最开始的问题，我们应该怎么来设置容器里的网络相关参数呢？首先你要避免走入误区。从我们一开始的例子里，也可以看到，容器里Network Namespace 的网络参数并不是完全从宿主机 Host Namespace里继承的，也不是完全在新的 Network Namespace建立的时候重新初始化的。其实呢，这一点我们只要看一下内核代码中对协议栈的初始化函数，很快就可以知道为什么会有这样的情况。在我们的例子里 tcp_congestion_control 的值是从 Host Namespace里继承的，而 tcp_keepalive相关的几个值会被重新初始化了。在函数tcp_sk_init() 里，tcp_keepalive的三个参数都是重新初始化的，而 tcp_congestion_control 的值是从 HostNamespace 里复制过来的。    static int __net_init tcp_sk_init(struct net *net)    {    …            net->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;            net->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;            net->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;         …            /* Reno is always built in */            if (!net_eq(net, &init_net) &&                try_module_get(init_net.ipv4.tcp_congestion_control->owner))                    net->ipv4.tcp_congestion_control = init_net.ipv4.tcp_congestion_control;            else                    net->ipv4.tcp_congestion_control = &tcp_reno;         …         }那么我们现在知道 Network Namespace的网络参数是怎么初始化的了，你可能会问了，我在容器里也可以修改这些参数吗？我们可以启动一个普通的容器，这里的"普通"呢，我指的不是\"privileged\"的那种容器，也就是在这个容器中，有很多操作都是不允许做的，比如mount 一个文件系统。这个 privileged容器概念，我们会在后面容器安全这一讲里详细展开，这里你有个印象。那么在启动完一个普通容器后，我们尝试一下在容器里去修改\"/proc/sys/net/\"下的参数。这时候你会看到，容器中\"/proc/sys/\"是只读 mount的，那么在容器里是不能修改\"/proc/sys/net/\"下面的任何参数了。    
# docker run -d --name net_para centos:8.1.1911 sleep 3600    977bf3f07da90422e9c1e89e56edf7a59fab5edff26317eeb253700c2fa657f7    
# docker exec -it net_para bash    [root@977bf3f07da9 /]
# echo 600 > /proc/sys/net/ipv4/tcp_keepalive_time    bash: /proc/sys/net/ipv4/tcp_keepalive_time: Read-only file system    [root@977bf3f07da9 /]
# cat /proc/mounts | grep "proc/sys"    proc /proc/sys proc ro,relatime 0 0为什么"/proc/sys/" 在容器里是只读 mount 呢？ 这是因为 runC当初出于安全的考虑，把容器中所有 /proc 和 /sys 相关的目录缺省都做了read-only mount 的处理。详细的说明你可以去看看这两个commits: 1.  [Mount /proc and /sys read-only, except in privileged    containers            2.  [Make /proc writable, but not /proc/sys and    /proc/sysrq-trigger            那我们应该怎么来修改容器中 Network Namespace的网络参数呢？当然，如果你有宿主机上的 root权限，最简单粗暴的方法就是用我们之前说的\"nsenter\"工具，用它修改容器里的网络参数的。不过这个方法在生产环境里显然是不会被允许的，因为我们不会允许用户拥有宿主机的登陆权限。其次呢，一般来说在容器中的应用已经启动了之后，才会做这样的修改。也就是说，很多tcp链接已经建立好了，那么即使新改了参数，对已经建立好的链接也不会生效了。这就需要重启应用，我们都知道生产环境里通常要避免应用重启，那这样做显然也不合适。通过刚刚的排除法，我们推理出了网络参数修改的"正确时机"：想修改Network Namespace里的网络参数，要选择容器刚刚启动，而容器中的应用程序还没启动之前进行。其实，runC 也在对 /proc/sys 目录做 read-only mount之前，预留出了修改接口，就是用来修改容器里\"/proc/sys\"下参数的，同样也是 sysctl的参数。 而 Docker 的--sysctl或者 Kubernetes里的allowed-unsafe-sysctls特性也都利用了 runC 的 sysctl参数修改接口，允许容器在启动时修改容器 Namespace里的参数。 比如，我们可以试一下 docker --sysctl，这时候我们会发现，在容器的Network Namespace 里，/proc/sys/net/ipv4/tcp_keepalive_time这个网络参数终于被修改了！    
# docker run -d --name net_para --sysctl net.ipv4.tcp_keepalive_time=600 centos:8.1.1911 sleep 3600    7efed88a44d64400ff5a6d38fdcc73f2a74a7bdc3dbc7161060f2f7d0be170d1    
# docker exec net_para cat /proc/sys/net/ipv4/tcp_keepalive_time    600重点总结好了，今天的课我们讲完了，那么下面我来给你做个总结。今天我们讨论问题是容器中网络参数的问题，因为是问题发生在容器里，又是网络的参数，那么自然就和Network Namespace 有关，所以我们首先要理解 NetworkNamespace。 Network Namespace 可以隔离网络设备，ip 协议栈，ip路由表，防火墙规则，以及可以显示独立的网络状态信息。我们可以通过 clone() 或者 unshare() 系统调用来建立新的 NetworkNamespace。 此外，还有一些工具\"ip\"\"netns\"\"unshare\"\"lsns\"和\"nsenter\"，也可以用来操作Network Namespace。这些工具的适用条件，我用表格的形式整理如下，你可以做个参考。![](Images/297628570c36c17bf078c8dde883f99f.png)savepage-src="https://static001.geekbang.org/resource/image/38/b1/387b7ce34968ec60d01db859f32ef2b1.jpg"}接着我们分析了如何修改普通容器（非privileged）的网络参数。由于安全的原因，普通容器的 /proc/sys 是 read-only mount的，所以在容器启动以后，我们无法在容器内部修改 /proc/sys/net下网络相关的参数。这时可行的方法是**通过 runC sysctl相关的接口，在容器启动的时候对容器内的网络参数做配置。**这样一来，想要修改网络参数就可以这么做：如果是使用Docker，我们可以加上\"---sysctl\"这个参数；而如果使用 Kubernetes的话，就需要用到\"allowed unsaftsysctl\"这个特性了。思考题这一讲中，我们提到了可以使用\"nsenter\"这个工具，从宿主机上修改容器里的/proc/sys/net/下的网络参数，你可以试试看具体怎么修改。欢迎你在留言区分享你的收获和疑问。如果这篇文章对你有帮助，也欢迎转发给你的同事和朋友，一起交流探讨。
# 16 \| 容器网络配置（1）：容器网络不通了要怎么调试?你好，我是程远。在上一讲，我们讲了 Network Namespace 隔离了网络设备，IP协议栈和路由表，以及防火墙规则，那容器 Network Namespace里的参数怎么去配置，我们现在已经很清楚了。其实对于网络配置的问题，我们还有一个最需要关心的内容，那就是容器和外面的容器或者节点是怎么通讯的，这就涉及到了容器网络接口配置的问题了。所以这一讲呢，我们就来聊一聊，容器 Network Namespace里如何配置网络接口，还有当容器网络不通的时候，我们应该怎么去做一个简单调试。问题再现在前面的课程里，我们一直是用 `docker run`这个命令来启动容器的。容器启动了之后，我们也可以看到，在容器里面有一个\"eth0\"的网络接口，接口上也配置了一个IP 地址。 不过呢，如果我们想从容器里访问外面的一个 IP 地址，比如说39.106.233.176（这个是极客时间网址对应的 IP），结果就发现是不能 ping通的。 这时我们可能会想到，到底是不是容器内出了问题，在容器里无法访问，会不会宿主机也一样不行呢？所以我们需要验证一下，首先我们退出容器，然后在宿主机的 NetworkNamespace 下，再运行 `ping 39.106.233.176`，结果就会发现在宿主机上，却是可以连通这个地址的。    
# docker run -d --name if-test centos:8.1.1911 sleep 36000    244d44f94dc2931626194c6fd3f99cec7b7c4bf61aafc6c702551e2c5ca2a371    
# docker exec -it if-test bash         [root@244d44f94dc2 /]
# ip addr    1: lo:  mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00        inet 127.0.0.1/8 scope host lo           valid_lft forever preferred_lft forever    808: eth0@if809:  mtu 1500 qdisc noqueue state UP group default        link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0        inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0           valid_lft forever preferred_lft forever         [root@244d44f94dc2 /]