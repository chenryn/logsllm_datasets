Figure 8: Evaluation of our snapshot() system call against fork() sys-
tem call and pthread_create() function. Figure 8(a) shows the impact
of snapshot() system call while fuzzing the libpng library. Figure 8(b)
shows the scalability of all the primitives that are used to create a
new process along with the optimized AFL case while fuzzing the
libpng library.
800k
700k
600k
500k
400k
300k
200k
100k
0k
c
e
s
/
s
c
e
x
E
HDD
SSD
tmpfs
ptmpfs
1
2
4
15
30
45
60
75
90
105
120
Figure 9: Impact of the file system on our optimized version of AFL
for the libpng library.
allowed number of snapshotted processes is sufficient to handle the
executions that AFL can have concurrently in practice.
6.3.3
File-system Overhead. Most existing fuzzers save inter-
esting test cases as well as the crash information in a directory
specified by a user. Figure 9 presents the impact of the physical
medium while fuzzing the libpng library with our optimized AFL,
which clearly illustrates that AFL does a lot of file system-specific
operations and is affected by the physical medium as well as the file
system overhead. For example, by changing the physical medium
from HDD to SSD, the scalability of AFL improves by 1.7×, which fur-
ther improves by §3.2 while switching from SSD to an in-memory
file system (tmpfs). However, even with tmpfs, the most trimmed
version of a file system, we observe that its performance is satu-
rated at 60 cores, which happens because opening and closing files
in a shared directory is not a scalable operation [32]. To mitigate
this problem, we use a partitioned (ptmpfs) approach to partially
mitigate the scalable bottleneck of the file system, which improves
the performance by 1.9×, 6.3×, and 10.8× over simple tmpfs, SSD, and
HDD, respectively. In summary, by using our partitioned approach,
we improve the scalability of AFL by 24.3× over the stock version of
AFL on 120 cores.
13
Session K2:  Fuzzing Finer and FasterCCS’17, October 30-November 3, 2017, Dallas, TX, USA23257 RELATED WORK
Our work is motivated by previous research on fuzzing techniques [7,
12, 13, 21, 23, 27, 29, 34, 36, 41], which aim to explore program paths
wisely, and large-scale fuzzing [20, 22, 31], which aims to explore
program paths faster using many, networked machines. Our goal in
this work is improving the performance and scalability of fuzzing
in a single, multi-core machine so our techniques can be orthog-
onally used with previous work. We also influenced by previous
work on OS scalability [4, 5, 8–10, 16–18, 26, 32] and solutions
to improve scalability [6, 15, 19, 28, 30, 33] but we analyzed OS
scalability bottlenecks with interactions of fuzzers and proposed
practical solutions for scalable, performant fuzzing.
Fuzzing. Existing fuzzing techniques strive to mutate input wisely
for a better exploration of target programs and the earlier detection
of bugs. For instance, feedback-driven fuzzers [12, 21, 23, 29, 34, 41]
profile various runtime characteristics of past fuzzing runs and
the profiled results directs the generation of the following inputs.
More specifically, coverage-driven fuzzers [23, 29, 41] use past code
coverage to determine whether or not a mutated input is interesting.
Some fuzzers [12, 34] retrieve more advanced knowledge such as
code- and data- flow feature, or various metrics to catalyze the
evolution of input. Honggfuzz [21] uses hardware features (e.g., Intel
PT, Intel BTS) as a more general solution to execution tracing than
software instrumentation. Fuzzing is likely to stuck at particular
branches with complex conditions for uncertain time due to its
randomness. Existing research addresses this issue by either wisely
scheduling the sequence of the test cases in the waiting queue [7]
or combining fuzzing with symbolic execution [13, 27, 36]), which
was originally proposed to solve sophisticated condition checks.
Note that our research on solving the performance bottleneck
of fuzzing is orthogonal to the previous works mentioned above.
What we propose are fuzzer-agnostic primitives from the operating
system side to speed up fuzzing, especially with a number of fuzzer
instances running concurrently.
In recent years, serious vulnerabilities in
Large-scale fuzzing.
modern software and OS exploited by attackers for profit are on a
rapid increase. As a response, large companies and organizations
expend a huge amount of hardware resources on automated fuzzing
to discover bugs in their own products. For example, the fuzzing in-
frastructure ClusterFuzz [20] by Google consists of several hundred
virtual machines running around 6,000 Chrome instances simulta-
neously. It also powers project OSS-Fuzz [22] to process trillions of
test cases targeting open source software. Furthermore, Microsoft
provides a cloud-based fuzzing service called Project Springfield [31]
for developers to find security bugs in the software. Our proposed
operating primitives can help boost the fuzzers deployed on large
clusters of cloud servers with abundant hardware resources and
thus save significant cost.
Process snapshot. Recent research works [6, 15, 28] propose sev-
eral OS primitives based on process snapshot to provide a temporary
and isolated execution context for running particular code flexibly.
lwCs (light-weight contexts) [28] provides independent units of
protection, privilege, and execution state within a process. The
lwCreate call creates an in-process child lwC with an identical
copy of the calling lwC’s states. Different from the snapshot() sys-
tem call, the new lwC gets a private copy of per-thread register
14
values, virtual memory, file descriptors, and credentials for isolation
purpose. Shreds [15] provide an in-process execution context for
a flexibly defined segment with private memory access. After the
code enters a sensitive section, it is granted a private memory pool
isolated from the virtual memory space while all the other process
states remain the same. Wedge [6] is another similar system used for
splitting complex applications into fine-grained and least-privilege
compartments. Note that the goal of these works is to create a
lightweight execution context for sandboxing. As a result, the new
execution context possesses private memory space, credentials, and
other system states that are isolated from the calling context. By
contrast, the execution context before and after the snapshot()
system call is completely the same for fuzzing purposes.
OS scalability. Researchers have been optimizing existing OSes [4,
8–10, 16, 17, 26] or completely rewriting them based on new design
principles [5, 18]. Our design decisions for fuzzing are inspired by
these prior works and concurrent programming in general. For
instance, while Wickizer et al. [4] improved the performance of
the Linux fork() in general, we resolve the issue by designing a
lightweight process spawning API that is specific to applications
like fuzzing. In addition, prior works have used in-memory file
systems to hide the file system overhead; instead we use it in the
form of two-level caching to provide a required file system interface
as well as the memory bandwidth.
OS specialization. Prior research works [19, 30, 33] have also
focused on removing the underlying overhead of OS in both the
bare metal and cloud environments. Even though, our work on
specializing OS for fuzzing ventures into a similar direction, it is
still generic from an OS perspective compared with library OS,
which has focused on rewriting the application for performance.
8 DISCUSSION AND FUTURE WORK
Applicable fuzzers. We only analyze and improve performance
and scalability of the general application fuzzers that natively exe-
cute the target with concrete input values in round. Our operating
primitives may bring less benefit to many other fuzzing tools which
rely on symbolic execution, taint analysis or instruction emula-
tion to find security bugs. OS kernel fuzzers are also out-of-scope.
These fuzzers may suffer from different performance bottlenecks
and require corresponding solutions.
Cross-platform implementation. We implemented the work-
ing prototype of our design choices on Linux platform. However,
there is a greater demand on finding bugs in MacOS and Windows
applications because of their popularity. We will port our imple-
mentation to these two platforms in the near future.
Scalable fuzzing on VM clusters. The scalability of fuzzers de-
pends not just on the design of fuzzers. As the cloud provider starts
adopting fuzzing as one of its major services (e.g., Project Springfield
on Microsoft Azure [31]) or abstracting fuzzing instances inside
a VM or container (e.g., OSS-Fuzz by Google [22]), the scalability
of underlying abstractions plays an important role in determining
the fuzzing performance. Our goal in this work is to improve the
performance and scalability of fuzzing in a multi-core machine.
However, there may exist different bottlenecks when fuzzing with
a large-scale VM cluster because of the semantic gap between a VM
and the hypervisor. Efficient and scalable hypervisor primitives are
Session K2:  Fuzzing Finer and FasterCCS’17, October 30-November 3, 2017, Dallas, TX, USA2326required to bridge the semantic gap between a hypervisor, a guest
OS, and all the way up to the fuzzing instance.
9 CONCLUSION
Fuzzing is now one of the most critical tools to find several security
bugs in various organizations and communities. However, with
increasing code bases and trivial bugs vanishing out of air, fuzzers
nowadays spend days, weeks or even months to find critical bugs
that not only requires large computing resources but also results in
monetary expenditure. Till now, prior works have only focused on
producing interesting input test cases to find new bugs quickly, but
have forgo the design aspects from a system’s perspective. In this
work, we carefully study and profile the various components of
two state-of-the-art fuzzers and their interaction with the OS and
find three design flaws, which we address for two fuzzers: AFL and
LibFuzzer. With our proposed operating primitives, AFL has at most
7.7×, 25.9×, and 28.9× improvement on the number of executions per
second on 30, 60, and 120 cores, respectively. Meanwhile, LibFuzzer
can speed up by at most 170.5×, 134.9×, and 735.7× on 30, 60, and
120 cores respectively.
10 ACKNOWLEDGMENT
We thank the anonymous reviewers for their helpful feedback.
This research was supported, in part, by the NSF award DGE-
1500084, CNS-1563848, CNS-1704701 and CRI-1629851, ONR under
grant N000141512162, DARPA TC (No. DARPA FA8650-15-C-7556),
and XD3 programs (No. DARPA HR0011-16-C-0059), and ETRI
IITP/KEIT[B0101-17-0644], and gifts from Facebook, Mozilla and
Intel.
REFERENCES
[1] Nightmare, 2014. https://github.com/joxeankoret/nightmare.
[2] zzuf, 2016. https://github.com/samhocevar/zzuf.
[3] Pwn2Own 2017: Chrome Remains the Winner in Browser Security, 2017. https://
securityzap.com/pwn2own-2017-chrome-remains-winner-browser-security/.
[4] B. Wickizer, S., Kaashoek, M. F., Morris, R., and Zeldovich, N. OpLog: a
library for scaling update-heavy data structures. CSAIL Technical Report (2013).
[5] Baumann, A., Barham, P., Dagand, P.-E., Harris, T., Isaacs, R., Peter, S.,
Roscoe, T., Schüpbach, A., and Singhania, A. The Multikernel: A New OS
Architecture for Scalable Multicore Systems. In Proceedings of the 8th USENIX
Symposium on Operating Systems Design and Implementation (OSDI) (San Diego,
CA, Dec. 2008).
[6] Bittau, A., Marchenko, P., Handley, M., and Karp, B. Wedge: Splitting Appli-
cations into Reduced-Privilege Compartments. In Proceedings of the 5th USENIX
Symposium on Networked Systems Design and Implementation (NSDI) (San Fran-
cisco, CA, Apr. 2008).
[7] Böhme, M., Pham, V.-T., and Roychoudhury, A. Coverage-based greybox
fuzzing as markov chain. In Proceedings of the 23rd ACM Conference on Computer
and Communications Security (CCS) (Vienna, Austria, Oct. 2016).
[8] Boyd-Wickizer, S., Chen, H., Chen, R., Mao, Y., Kaashoek, M. F., Morris, R.,
Pesterev, A., Stein, L., Wu, M., Dai, Y., Zhang, Y., and Zhang, Z. Corey: An
Operating System for Many Cores. In Proceedings of the 8th USENIX Symposium
on Operating Systems Design and Implementation (OSDI) (San Diego, CA, Dec.
2008).
[9] Boyd-Wickizer, S., Clements, A. T., Mao, Y., Pesterev, A., Kaashoek, M. F.,
Morris, R., and Zeldovich, N. An Analysis of Linux Scalability to Many Cores.
In Proceedings of the 9th USENIX Symposium on Operating Systems Design and
Implementation (OSDI) (Vancouver, Canada, Oct. 2010).
[10] Boyd-Wickizer, S., Kaashoek, M. F., Morris, R., and Zeldovich, N. Non-
scalable locks are dangerous. In Proceedings of the Linux Symposium (Ottawa,
Canada, July 2012).
[11] Boyd-Wickizer, S., Kaashoek, M. F., Morris, R., and Zeldovich, N. OpLog: a
library for scaling update-heavy data structures.
[12] CENSUS. Choronzon - An evolutionary knowledge-based fuzzer. ZeroNights
Conference.
[13] Cha, S. K., Avgerinos, T., Rebert, A., and Brumley, D. Unleashing MAYHEM
on binary code. In Proceedings of the 33rd IEEE Symposium on Security and Privacy
(Oakland) (San Francisco, CA, May 2012).
[14] Chang, O., Arya, A., Serebryany, K., and Armour, J. OSS-Fuzz: Five months
later, and rewarding projects, 2017. https://security.googleblog.com/2017/05/
oss-fuzz-five-months-later-and.html.
[15] Chen, Y., Reymondjohnson, S., Sun, Z., and Lu, L. Shreds: Fine-grained execu-
tion units with private memory. In Proceedings of the 37th IEEE Symposium on
Security and Privacy (Oakland) (San Jose, CA, May 2016).
[16] Clements, A. T., Kaashoek, M. F., and Zeldovich, N. Scalable Address Spaces
Using RCU Balanced Trees. In Proceedings of the 17th ACM International Confer-
ence on Architectural Support for Programming Languages and Operating Systems
(ASPLOS) (London, UK, Mar. 2012).
[17] Clements, A. T., Kaashoek, M. F., and Zeldovich, N. RadixVM: Scalable
Address Spaces for Multithreaded Applications. In Proceedings of the 8th European
Conference on Computer Systems (EuroSys) (Prague, Czech Republic, Apr. 2013).
[18] Clements, A. T., Kaashoek, M. F., Zeldovich, N., Morris, R. T., and Kohler,
E. The Scalable Commutativity Rule: Designing Scalable Software for Multicore
Processors. In Proceedings of the 24th ACM Symposium on Operating Systems
Principles (SOSP) (Farmington, PA, Nov. 2013).
[19] Engler, D. R., Kaashoek, M. F., and O’Toole, Jr., J. Exokernel: An Operating
System Architecture for Application-level Resource Management. In Proceedings
of the 15th ACM Symposium on Operating Systems Principles (SOSP) (Copper
Mountain, CO, Dec. 1995), pp. 251–266.
Fuzzing for Security, 2012.
https://blog.chromium.org/2012/04/
[20] Google.
fuzzing-for-security.html.
[21] Google. Honggfuzz, 2016. https://google.github.io/honggfuzz/.
[22] Google. OSS-Fuzz - Continuous Fuzzing for Open Source Software, 2016. https:
//github.com/google/oss-fuzz.
[23] Google.
syzkaller.
syzkaller - linux syscall fuzzer, 2016. https://github.com/google/
[24] Google. fuzzer-test-suite: Set of tests for fuzzing engines, 2017. https://github.
com/google/fuzzer-test-suite.
[25] iSEC. PeachFarmer, 2014. http://github.com/iSECPartners/PeachFarmer.
[26] Kashyap, S., Min, C., and Kim, T. Scalable NUMA-aware Blocking Synchroniza-
tion Primitives. In Proceedings of the 2017 USENIX Annual Technical Conference
(ATC) (Santa Clara, CA, July 2017).
[27] Kim, S. Y., Lee, S., Yun, I., Xu, W., Lee, B., Yun, Y., and Kim, T. CAB-Fuzz: Practical
Concolic Testing Techniques for COTS Operating Systems. In Proceedings of the
2017 USENIX Annual Technical Conference (ATC) (Santa Clara, CA, July 2017).
[28] Litton, J., Vahldiek-Oberwagner, A., Elnikety, E., Garg, D., Bhattacharjee,
B., and Druschel, P. Light-weight contexts: an OS abstraction for safety and
performance. In Proceedings of the 12th USENIX Symposium on Operating Systems
Design and Implementation (OSDI) (Savannah, GA, Nov. 2016).
[29] LLVM. libFuzzer - a library for coverage-guided fuzz testing, 2017. http://llvm.
org/docs/LibFuzzer.html.
[30] Madhavapeddy, A., Mortier, R., Rotsos, C., Scott, D., Singh, B., Gazagnaire,
T., Smith, S., Hand, S., and Crowcroft, J. Unikernels: Library Operating
Systems for the Cloud. In Proceedings of the 18th ACM International Conference on
Architectural Support for Programming Languages and Operating Systems (ASPLOS)
(Houston, TX, Mar. 2013), pp. 461–472.
[31] Microsoft.
bug
microsoft-previews-project-springfield-cloud-based-bug-detector.
Microsoft previews Project Springfield, a cloud-based
2016.
https://blogs.microsoft.com/next/2016/09/26/
detector,
[32] Min, C., Kashyap, S., Maass, S., Kang, W., and Kim, T. Understanding Manycore
Scalability of File Systems. In Proceedings of the 2016 USENIX Annual Technical
Conference (ATC) (Denver, CO, June 2016).
[33] Porter, D. E., Boyd-Wickizer, S., Howell, J., Olinsky, R., and Hunt, G. C.
Rethinking the Library OS from the Top Down. In Proceedings of the 16th ACM
International Conference on Architectural Support for Programming Languages and
Operating Systems (ASPLOS) (Newport Beach, CA, Mar. 2011), pp. 291–304.
[34] Rawat, S., Jain, V., Kumar, A., Cojocar, L., Giuffrida, C., and Bos, H. VUzzer:
Application-aware Evolutionary Fuzzing.
In Proceedings of the 2017 Annual
Network and Distributed System Security Symposium (NDSS) (San Diego, CA,
Feb.–Mar. 2017).
[35] Ruderman, J. Releasing jsfunfuzz and domfuzz, 2015. http://www.squarefree.
com/2015/07/28/releasing-jsfunfuzz-and-domfuzz/.
15
Session K2:  Fuzzing Finer and FasterCCS’17, October 30-November 3, 2017, Dallas, TX, USA2327[39] Zalewski, M. Fuzzing random programs without execve(), 2014. https://lcamtuf.
blogspot.com/2014/10/fuzzing-binaries-without-execve.html.
[40] Zalewski, M. AFL starting test cases), 2017. https://github.com/mirrorer/afl/
tree/master/testcases.
[41] Zalewski, M. american fuzzy lop (2.41b), 2017. http://lcamtuf.coredump.cx/afl/.
[42] Zalewski, M. Technical "whitepaper" for afl-fuzz), 2017. https://github.com/
mirrorer/afl/blob/master/docs/technical_details.txt.
[43] Zalewski, M. Tips for performance optimization, 2017. https://github.com/
mirrorer/afl/blob/master/docs/perf_tips.txt.
[36] Stephens, N., Grosen, J., Salls, C., Dutcher, A., Wang, R., Corbetta, J., Shoshi-
taishvili, Y., Kruegel, C., and Vigna, G. Driller: Augmenting fuzzing through
selective symbolic execution. In Proceedings of the 2016 Annual Network and
Distributed System Security Symposium (NDSS) (San Diego, CA, Feb. 2016).
[37] The Clang Team. Clang 5 documentation - SanitizerCoverage, 2017. http:
//clang.llvm.org/docs/SanitizerCoverage.html.
[38] Veggalam, S., Rawat, S., Haller, I., and Bos, H.
IFuzzer: An Evolutionary
Interpreter Fuzzer Using Genetic Programming. In Proceedings of the 21th Eu-
ropean Symposium on Research in Computer Security (ESORICS) (Crete, Greece,
Sept. 2016).
16
Session K2:  Fuzzing Finer and FasterCCS’17, October 30-November 3, 2017, Dallas, TX, USA2328