title:Large-scale malware indexing using function-call graphs
author:Xin Hu and
Tzi-cker Chiueh and
Kang G. Shin
Large-Scale Malware Indexing Using Function-Call Graphs∗ †
Xin Hu
University of Michigan
Michigan, USA
PI:EMAIL
Tzi-cker Chiueh
Stony Brook University
New York, USA
PI:EMAIL
Kang G. Shin
University of Michigan
Michigan, USA
PI:EMAIL
ABSTRACT
A major challenge of the anti-virus (AV) industry is how to ef-
fectively process the huge inﬂux of malware samples they receive
every day. One possible solution to this problem is to quickly de-
termine if a new malware sample is similar to any previously-seen
malware program. In this paper, we design, implement and evaluate
a malware database management system called SMIT (Symantec
Malware Indexing Tree) that can efﬁciently make such determina-
tion based on malware’s function-call graphs, which is a structural
representation known to be less susceptible to instruction-level ob-
fuscations commonly employed by malware writers to evade detec-
tion of AV software. Because each malware program is represented
as a graph, the problem of searching for the most similar malware
program in a database to a given malware sample is cast into a
nearest-neighbor search problem in a graph database. To speed
up this search, we have developed an efﬁcient method to compute
graph similarity that exploits structural and instruction-level infor-
mation in the underlying malware programs, and a multi-resolution
indexing scheme that uses a computationally economical feature
vector for early pruning and resorts to a more accurate but com-
putationally more expensive graph similarity function only when it
needs to pinpoint the most similar neighbors. Results of a compre-
hensive performance study of the SMIT prototype using a database
of more than 100,000 malware demonstrate the effective pruning
power and scalability of its nearest neighbor search mechanisms.
Categories and Subject Descriptors
D.4.6 [Operating System]: Security and Protection—Invasive soft-
ware
General Terms
Design, Security
Keywords
Malware Indexing, Graph Similarity, Multi-resolution Indexing
∗
A large portion of this work was done while Xin Hu and Tzi-cker
Chiueh were at Symantec Research Labs
†
The work was supported in part by the NSF under Grant No. CNS-
0523932, by the ONR under Grant No. N000140911042, and by
the AFOSR under Grant No. FA9550-07-1-0423.
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’09, November 9–13, 2009, Chicago, Illinois, USA.
Copyright 2009 ACM 978-1-60558-352-5/09/11 ...$10.00.
1.
INTRODUCTION
With the advent of automated malware development toolkits,
creating new variants of existing malware programs to evade the
detection of anti-virus (AV) software has become relatively easy
even for un-skilled aggressors. This has led to a huge surge in
the number of new malware threats in recent years. According
to Symantec’s latest Internet Threat Report [30], the company re-
ceived 499,811 new malware samples in the second half of 2007
alone. The ﬁrst step to process any received malware sample is to
determine if the sample is indeed malicious. Currently, this step
is largely done manually and thus is a major bottleneck of the
malware processing workﬂow. Because most new malware sam-
ples are variants of previously-known samples through mutation of
their source or binary code, one way to ascertain the maliciousness
of a sample is to check if the sample is sufﬁciently similar to any
previously-seen malware program. We describe the design, imple-
mentation and evaluation of a graph-based malware database man-
agement system, called SMIT (Symantec Malware Indexing Tree)
that is developed speciﬁcally to perform such checks efﬁciently.
Most existing malware-detection methods treat malware programs
as sequences of bytes, and ignore their high-level internal struc-
tures, such as basic blocks and function calls. These methods are
generally ineffective against recent malware threats for the follow-
ing reasons. First, since most modern malware programs are writ-
ten in high-level programming languages, a minor modiﬁcation in
source codes can lead to a signiﬁcant change in binary codes. Sec-
ond, the availability of automated obfuscation tools that implement
techniques such as instruction reordering, equivalent instruction se-
quence substitution, and branch inversion, allows malware writers
to easily generate new malware versions that are syntactically dif-
ferent from, but semantically equivalent to, the original version.
One way to overcome the difﬁculties of recognizing syntactically
different and semantically identical variants of a malware program
is to base the recognition algorithm on a high-level structure that
is less susceptible to minor or local modiﬁcations. One example of
such high-level structure is a program’s function-call graph, which
abstracts away byte- or instruction-level details and is thus more
resillient to byte- or instruction-level obfuscations commonly em-
ployed by malware writers or malware development tools. More-
over, because a program’s functionality is mostly determined by
the library or system calls it invokes, its function-call graph pro-
vides a reasonable approximation to the program’s run-time behav-
ior. Therefore, the function-call graphs of the malware variants that
are derived from the same source or binary code are often similar to
one another. By representing each malware program in terms of its
function-call graph, we translate the problem of ﬁnding a malware
sample’s closest kin in a malware database into one that searches
for a graph’s nearest neighbor in a graph database.
Our work is unique and different from the previous work on
graph database query processing for the following three reasons.
First, most previous graph database research focused on exact graph
611or subgraph matching, which requires a solution to the graph or
subgraph isomorphism problems (both are well-known NP prob-
lems). However, since malware variants are rarely subgraphs of
one another, exact graph or subgraph matching is too restricted
to be useful for identifying malware variants. Instead, SMIT sup-
ports graph-similarity search, which, given a query graph, pinpoints
graphs in a database that are most similar to the query graph. Sec-
ond, because the cost of computing a graph-similarity score, for
example, the graph-edit distance, is exponential in the number of
nodes/edges, most existing graph-similarity query methods assume
that the number of nodes in the graphs is on the order of 10s. They
are not directly applicable to SMIT because the number of nodes
in a malware’s function-call graph ranges from 100s to 1000s. For
example, a variant of the Agobot family has 2,759 nodes and 5,851
edges in its function-call graph. Third, many existing graph-similarity
query processing methods cannot scale to a large graph database;
their applicable size are mostly on the order of 1000s. Consider-
ing the enormous number of malware samples that the AV industry
receives every year, the main goal of SMIT is to support efﬁcient
similarity queries for databases of the size that is at least 100,000
and up to a million.
SMIT features a unique combination of techniques to address the
scalability challenge associated with graph-similarity search. First,
SMIT incorporates a polynomial-time graph-similarity computa-
tion algorithm whose result closely approximates the inter-graph
edit distance. This algorithm exploits the structural and instruction-
level information associated with the malware programs underlying
the input graphs. Second, SMIT applies an optimistic vantage point
tree [9] to index a graph database to speed up nearest-neighbor
graph-similarity search. Third, SMIT employs multi-resolution in-
dexing that uses a computationally economical feature vector for
early pruning and resorts to a more accurate but computationally
more expensive graph similarity function only when it needs to
pinpoint the most similar neighbors. We have successfully built a
SMIT prototype and tested its performance using a test database
containing more than 100,000 distinct malware programs. Our
evaluation results demonstrate that SMIT exhibits effective pruning
power and scales to large graph databases in that the query service
time grows slowly with the number of graphs in the database.
The remainder of this paper is organized as follows. Section 2
reviews previous related work. Section 3 and Section 4 present
SMIT’s graph-similarity algorithms. Section 5 describes the multi-
resolution indexing scheme used in SMIT. Evaluation results for
the current SMIT prototype are presented in Section 6. Section 7
discusses SMIT’s limitations and Section 8 concludes this paper.
2. RELATED WORK
Most existing work detects or classiﬁes malware based on either
byte-level signature or malware run-time behavior. For example,
Kolter and Maloof used n-gram of byte codes as features to train the
classiﬁer [19]. Rieck et al. [27] monitored the malware behavior
(e.g., changes to ﬁle system and registry) in a sandbox and used su-
pervised learning to predict malware families. Lee and Mody [32]
collected sequences of system-call events and applied clustering
algorithms to group malware families. Bailey et al. [4] deﬁned
malware behavior as non-transient state changes on the system and
applied hierarchical clustering algorithms for malware grouping.
More recently, Bayer et al. [5] applied Locality Sensitive Hashing
on the behavior proﬁles to achieve efﬁcient and scalable malware
clustering. Both signature- and behavior-based approaches have
their own limitations. The former is vulnerable to obfuscation and
ineffective in identifying new malware samples. The latter, on the
other hand, incurs expensive runtime overhead and tends to gener-
ate many false positives. SMIT differs from both in that it builds
a large malware database based on their function-call graphs and
supports efﬁcient indexing techniques that allow malware analysts
to quickly determine whether a new binary ﬁle is malicious or not,
based on a nearest-neighbor search through the database.
Use of graphs is becoming prevalent in depicting structural in-
formation. There exist several methods in the database ﬁeld for
indexing and querying graph databases. Most of them focused on
exact graph or subgraph matching, i.e., graph or subgraph isomor-
phism. However, because both graph and subgraph isomorphism
are NP problems [11], existing algorithms are prohibitively expen-
sive to use for querying a large graph database. To reduce the search
space, several indexing techniques have been proposed, including
GraphGrep [29], Tree+Δ [39] and TALE [31], which use paths,
trees and important nodes, respectively, as the main frequent fea-
ture to remove graphs that do not match the query. Subgraph iso-
morphism is then used to prune false positives from the answer set.
Several disadvantages of these approaches make them unsuitable
for a malware database that contains hundreds of thousands large
graphs. First, some of them rely on expensive isomorphism algo-
rithms and thus are only applicable to small graphs. Second, these
approaches require all the indexing features to be matched exactly
with the query and thus, cannot effectively capture the similarity
among malware variants. For example, malware writers often cre-
ate malware variants by adding new features (e.g., logging) or some
cosmetic changes without affecting the essence of the original mal-
ware. However, a new variant created this way will not be isomor-
phic to the original one even though they are similar.
In this paper, we take an approximate graph-matching approach
and index the malware graph database using graph similarity. Re-
cently, several indexing methods for similarity queries have also
been proposed [14, 34]. Most of them are still built upon ex-
act subgraph isomorphism and therefore, only apply to relatively
small graphs, allowing limited approximation. Another widely-
used graph similarity metric is the graph-edit distance, which has
shown to be suitable for many error-tolerant graph-matching appli-
cations [24]. However, because computing graph-edit distance is
NP-hard [38], using exact graph-edit distance is feasible only for
small graphs. To reduce the computational cost, several methods
have been proposed to calculate approximate edit distance [18, 23,
28]. Riesen et al.
[28] developed a polynomial-time algorithm
to compute approximate graph-edit distance using Bipartite Graph
Matching. SMIT adopts this approach and tailors it to measure dis-
tances between malware call graphs. To support similarity queries
(e.g., K Nearest Neighbor query), several techniques for metric
space search have also been developed. Yianilos [35] proposed the
original Vantage Point Tree (VPT) structure for multi-dimensional
nearest-neighbor search. Later, several extensions to VPT have
been made to improve its efﬁciency, such as Multi-way VPT [6],
Optimistic VPT [9], and M-tree [37]. They have been success-
fully applied to various applications, for example, content-based
retrieval on multimedia data repositories.
Function-call and control-ﬂow graphs have also been used fre-
quently for malware analysis. Carrera and Erdélyi [8] applied graph
theory to function-call graphs for clustering existing malware ﬁles.
Kruegel et al. [20] constructed control-ﬂow graphs from network
streams and detected polymorphic worms by identifying structural
similarities. Briones and Gomez [7] combined function-call graphs,
control-ﬂow graphs and entropy of data blocks to automatically
classify malware samples. SMIT differs from others in that it pro-
poses a function-call graph indexing approach towards the impor-
tant problem of malware classiﬁcation. It focuses on developing
an efﬁcient indexing structure to organize and query large mal-
ware databases. In addition, SMIT utilizes a graph similarity metric
612based on an optimal bipartite matching algorithm which can better
capture the internal structure of the call graphs.
3. FUNCTION-CALL GRAPH EXTRACTION
A binary program’s function-call graph is a directed graph con-
sisting of a set of vertices (corresponding to functions), a set of
directed edges (corresponding to caller–callee relationships) and a
set of labels, one for each vertex (containing the attributes of the
associated function). To facilitate matching between two function-
call graphs, we classify a program’s functions into three categories:
(1) Local functions are functions written by malware writers and
usually shared only by malware variants within the same family;
(2) Statically-linked library functions are library functions that
are statically linked into the ﬁnal distributed binary, such as Libc,
MFC, etc.; (3) Dynamically-imported functions are DLL func-
tions that are linked at run- or load-time, e.g., functions in Ker-
nel32.dll, User32.dll, etc. Since these functions are dynamically
linked, their bodies do not appear in malware binaries. Both library
and imported functions tend to be shared across malware families.
Given an incoming malware sample, SMIT extracts its function-
call graph as follows. First, SMIT uses PEiD [2] and TrID [3] to
check if the malware ﬁle is packed. If so, SMIT applies SymPack
(an unpacker developed inside Symantec) to unpack or decrypt the
malware ﬁle. To handle multi-layer packing, SMIT applies this step
recursively until the ﬁle is completely unpacked. Then, SMIT uses
the popular disassembler IDA Pro [15] to disassemble the malware
and identify the function boundaries. It then labels each identiﬁed
function with a symbolic name. For dynamically-imported func-
tions, their names can be found by parsing the IAT (Import Address
Table) in the PE header [25] of the malware ﬁle. For statically-
linked library functions, e.g., strcmp and iota, SMIT utilizes IDA
Pro’s FLIRT (Fast Library Identiﬁcation and Recognition Technol-
ogy) [17] to recognize their original names. Because the import and
library functions are standard routines, their names are consistent
throughout all the programs. However, for local functions, since
most malware samples do not come with their symbol tables, their
names are in general unavailable. As a result, we assign all local
functions with the same name (sub_) whenever their true sym-
bolic names are unavailable in the input binary. These local func-
tions will later be matched based on their mnemonic sequences or
call-graph structures.
To facilitate matching of local functions, SMIT extracts from
each local function the sequence of call instructions it contains,
and a mnemonic or opcode sequence from instructions in its body.
For example, “mov" is the mnemonic for the instruction “mov eax,
[0x403FBB]". Such mnemonic sequences are more robust than in-
struction sequences because they ignore offsets that may change
due to code relocation. They are used in the graph-similarity com-
putation as a coarse-grained ﬁlter to identify functions from two
programs that are likely to be matched. That is, if two functions
have similar mnemonic sequences, they are likely to be the same
function. SMIT also computes the CRC of mnemonic sequences
to speed up the exact matching between sequences. More formally,
SMIT deﬁnes a program’s function-call graph as follows.
Deﬁnition (Function-Call Graph): A function-call graph g is a di-
rected graph deﬁned by 4 tuples g = (Vg, Eg, Lg, Lg), where
Vg is the ﬁnite set of vertices, each corresponding to a function;
Eg ⊆ Vg × Vg is the set of directed edges where an edge from
f1 to f2 implies that f1 contains a function call to f2, but not vice
versa; Lg is the set of labels each of which is comprised of 3 el-
ements: symbolic function name, mnemonic sequence and CRC
value of the mnemonic sequence; Lg : Vg → Lg is the labeling
function that assigns labels to vertices.
4. GRAPH-SIMILARITY METRIC
The central component of SMIT is a graph database engine that
ﬁnds the nearest neighbors of a given query graph in a graph database.
For this, SMIT uses a graph-similarity metric that aims to capture
the similarity among variants within the same malware family, and
that can be computed at low cost. Here we give details of this met-