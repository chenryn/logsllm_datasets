须为每个未指定的参数加上一个逗号。例如~F指令，它是另一个用来打印浮点值的指令，也接受
使用一个格式化参数并将其值用作前置参数，而前置参数#将被求值为剩余的格式化参数的个数。
接想要的字符。前置参数的值还可以通过两种方式从格式化参数中获得：前置参数v导致FORMAT
认情况下在小数点之后打印两位数字。
在打印浮点数时小数点后打印多少位之类的事情。例如~$指令，它是用来打印浮点值的指令，默
某些指令带有前置参数（prefixparameter），它们紧跟在波浪线后面，由逗号分隔，用来控制诸如
例如：
18.2
你也可以完全省略前置参数。不过，如果你想要指定一个参数但不指定它前面的那个，你必
所有的指令都以一个波浪线（～）开始并终止于单个字符。字符可以使用大写或小写来书写。
NIL
CL-USER>（formatt"~:d"1000000)
CL-USER>
你还可以使用冒号和e修饰符（modifier）来调整某些指令的行为，它放在前置参数之后、指
CL-USER>（formatt“~,5f"pi)
我将在18.7节中给出一些如何使用#参数的实际例子。
CL-USER>(format t “~#$"pi)
前置参数的值既可以是写成十进制的数字，也可以是字符，字符的书写形式是一个单引号后
NIL
CL-USER>(format t“~5$"pi)
不过，通过使用前置参数，可以指定它打印出的小数位数，比如五位小数，像下面这样：
NIL
3.14
CL-USER>(format t “~S" pi)
1,000,000
NIL
1000000
NIL
3.14159
NIL
.1
.142
FORMAT指令
（formatt“~a"1000000)
www.TopSage.com
---
## Page 211
过一个数字来参数化地控制产生多少个波浪线。
n-1或n个换行，具体取决于它是否在一行的开始处输出。
输出，那么当依次调用它们的时候就不必担心会产生一个额外的空行。这两个指令都可以接受单
数特别有用，其中每个函数都生成一块输出，然后这些输出需要以不同方式组合在一起。例如，
~总是产生换行，而~&只在当前没有位于一行开始处时才产生换行。这对于编写松散耦合的函
些参数只在生成表格数据时才是真正有用的。
置参数，它们用于控制是否在值的后面（或者当使用@修饰符时在值的前面）添加占位符，但这
个冒号修饰符，~A和~S指令都可以将NIL输出成（)而不是NIL。~A和~S指令也都接受最多四个前
的时候是包限定的，等等。那些不带有可读表示的对象将被打印成不可读对象语法#<>。使用一
图将输出生成为可被READ读回来的形式。这样，字符串将被包围在引用标记中，而符号在必要
是想产生一个人能看懂的值，那么这个指令是最合适的。
式。例如，字符串输出成没有引用标记或转义字符的形式，而数字输出成正常的方式。如果你只
18.3
的，要么给出第三个含义。
18.4
其他两个最常用的指令是用来产生换行的~%，以及用来产生新行的~&。两者的区别在于
194
不太常用的相关指令是～～，它导致FORMAT产生一个字面波浪线。与～%和~&相同，它可以通
除通用指令~A和~S外，FORMAT还支持一些指令用来以特定方式输出指定类型的值。这些指
一个紧密相关的指令是~S，它同样使用一个任何类型的格式化参数并输出它。不过，~S试
最通用的指令是~A，它使用一个任何类型的格式化参数，并将其输出成美化（人类可读）形
现在来看特定指令。我将从几个最常用的指令开始，包括一些前面章节里已经提到的。
在两个修改行为不能有意义地组合在一起的那些指令中，同时使用两个修饰符要么是未定义
+1,000,000
(0000001 P@: 7 1101)  (format t "~@d" 1000000)
format
format
(format nil "The value is: ^a" 10)
字符和整数指令
基本格式化
第18章
nil
nil
"The value
一些FORMAT 秘诀
is:
www.TopSage.com
～a"
ra
(list 1 2 3))-
"foo")
→"The value
→ "The value is: 10"
The
value
is:
(123)"
too
---
## Page 212
而使用@修饰符，它总是打印一个正负符号。
以十进制输出整数。
数值指令可以分成两个子类别：用来格式化整数值的指令以及用来格式化浮点值的指令。
出数字，但如果想要更好地控制它们被打印的形式，那么就需要使用特定于字符的指令了。这些
不是精确的。例如，如果在SLIME中运行OpenMCL，那么C-@键组合将被Emacs劫持，并调用
信息：
符编码为O的字符)。在OpenMCL中，如果使用～：@C指令来打印空字符，那么它将告诉你下面的
按下Control键，然后输人@来键人一个空字符（在ASCII或ISO-8859-1和Unicode等ASCII超集中字
那么在键盘上输入该字符的方式也将打印出来。例如，在Macintosh上，在特定应用中可以通过
使用@修饰符，~@c将按Lisp的字面字符语法输出字符。
可以产生下面的信息
形式
名字输出。当你想要向用户输出关于某些字符的信息时，这个指令是非常有用的。例如，下面的
加有用。使用冒号修饰符，～：C可以将诸如空格、制表符和换行符这些不可打印的字符按它们的
在不进行修改的情况下，除了它只能工作在字符上以外，其行为和~A没有区别。修改后的版本更
令中最简单的是~C指令，它用来输出字符。它不接受前置参数，但可用冒号和@修饰符进行修改。
①~C指令的这个变体在像Lisp Machine这样的平台上更有意义，其中键击事件是由Lisp字符所表示的。
那些致力于输出数字的格式化指令构成了另一个重要的分类。尽管你可以使用~A和~S来输
 Syntax error. Unexpected character: Space
(format t "Syntax error. Unexpected character: ~:c" char)
"0000001+= ← (0000001 "@~： 1Tu 2eu1o3)
"000'000'。←(000000 "p:~ 1u ewxo)
如同我前面提到的，使用冒号修饰符会在输出中添加逗号。
000000（(000000P~：U21101)
尽管如此，并非所有的Lisp都实现了~C指令的这个方面。而且就算它们实现了，结果也可能
(format nil "~:@c" (code-char O)) → "^@ (Control @)" 
同时使用冒号和@修饰符，~C指令可以打印出额外的信息：如果该字符要求特殊的按键组合，
(#~  ） <-
但也可以像下面这样：
Syntax error. Unexpected character: a
#\a
www.TopSage.com
18.4字符和整数指令
195
---
## Page 213
的数位数量。此外，~F指令在数字特别大或特别小时允许使用科学计数法。而~E指令在输出数
从而使得其只在生成表格输出时才真正有意义。
你可以使用~F、~E和~$指令将浮点值插入到文本中。通用浮点指令~G组合了~F和~E指令的特性
的指令。它们多数用于以表格形式格式化浮点值，所以我将跳过这些指令的多数细节。尽管如此，
殊行为。我将在18.6节里讨论它。
并且冒号和e修饰符也以相同的方式修改其行为。当不使用任何前置参数时，~R指令还有一些特
的数字，用来指示所使用的进制。其余的参数与~D、~X、~O和~B指令所接受的四个参数一样，
方式相同。
默认值。
改成句点并将分组从3调整到4。
字符，而第四个参数指定了每组中数位的数量。这些参数默认为逗号和数字3。这样，你可以使
默认的占位符是空格，而占位符总是插入在数字之前。
18.5
并且这两个修饰符可以组合使用。
~F指令以十进制格式输出其参数（该参数应当是一个数字"），并可以控制十进制小数点之后
196
① 技术上来讲，如果该参数不是一个实数，那么~F应当像使用~D指令那样来格式化它，而如果该参数根本不是一
最后，~R指令是通用的进制输出指令。它的第一个参数是一个介入2和36（包括2和36）之间
第三和第四个参数是与冒号修饰符配合使用的：第三个参数指定了用作数位组之间分隔符的
注意，你必须使用逗号来保留未指定的宽度和占位符参数的位置，从而允许它们保持各自的
这些参数在格式化日期这样的固定宽度格式时是很有用的。
(format nil "~12d" 1000000)
第一个前置参数可以指定输出的最小宽度，而第二个参数可以指定一个用作占位符的字符。
“0000001001000010111 ←(0000001=q~αTTu 41ux0g)
(format nil "~:d" 100000000)
(format ni1 "~4,'0d-~2,'0d-~2,'0d" 2005 6 10) → "2005-06-10" 
"000'000'1+（(0000001 P@~ ITu 4e4103)
个数字，其行为应当像~A指令那样，但并非所有实现都很好地遵守了这一约定。
format
(format nil
(format nil 
浮点指令
第18章 
nil
一些FORMAT秘诀
1000000）-
www.TopSage.com
→"3641100"
→"f4240"
→"100,000,000"
1000000*
---
## Page 214
就简单地输出一个s。
马数字，其中4和9被写成IⅢ和VⅡ而不是IV和IX。
而当使用@修饰符时，它将数字输出成罗马数字。同时使用@和冒号时，它产生“旧式风格”的罗
使用冒号修饰符，它将数字输出成序数。
马数字。当不带前置参数和修饰符使用时，它将数字输出成基数词。
出分段应用大小写转换。
些指令允许将数字输出成英语单词，基于格式化参数的值来输出复数标识，并且.为FORMAT的输
18.6
而第二个参数用来控制十进制小数点之前所打印的最小位数。
它控制在十进制小数点之后打印的位数。
字时总是使用科学计数法。这两个指令都接受一些前置参数，但你需要关注的只有第二个参数，
我在18.4节中所讨论的~R指令，当不指定输出进制来使用时，它将数字打印成英语单词或罗
① 这只是语言标准里所说的。出于一些原因，可能是源自于同一份古老的基础代码，一些Common Lisp实现并没有
{format nil "~r" 1234) → "one thousand two hundred thirty-four"
用来生成人类可读消息的最有用的一-些FORMAT指令，是那些用来产生英文文本的指令。这
不过，一般情况下你将使用带有冒号修饰符的~P，这会使它重新处理前一个格式化参数。
(format nil "file^p" 1)
为了生成带有正确复数化单词的消息，FORMAT提供了~P指令。如果某对应的参数不是1，它
对于那些以给定形式无法表示的过大数字，~R将回退到与~D相同的行为。
(format nil "~@r" 1234) 
~F、~E和~$三个指令都可以通过使用@修饰符来使其总是打印一个正负号。
~$指令和~F指令相似，但更简单一些。如同其名字所示，它用于输出货币单位。不带有参
正确地实现~F指令的这个方面。
(format nil "file^p"
(formatI
(format nil "$" pi) 
(format nil "~,4e" pi) → "3.1416d+0"
(format n
format
英语指令
n11
nil
lerp"
pi}
01
（OL
→ "3.141592653589793d+0"
→"3.141592653589793d0"
→ "file"
↑
→"MCCXXXIV"
"3.14"
"files'
www.TopSage.com
18.6英语指令
197
---