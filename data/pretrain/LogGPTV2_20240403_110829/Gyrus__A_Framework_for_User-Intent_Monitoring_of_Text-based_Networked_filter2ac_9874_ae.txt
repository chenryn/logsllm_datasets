be
button,
the
application
Constructing Signature The event
to LCLICK,
domain
and
www.paypal.com and whether
tree-structure
has all participating text boxes as siblings. The trafﬁc
trap condition for the Network Monitor should be set as
condition will
the UI
is set
check
Activity
Send or read e-mail
Buy a product
Use a social networking site
Buy or make a reservation for travel
Do any banking online
Send instant messages
Pay to access or download digital content
Post a comment to online news groups
Use Twitter
Buy or sell stocks, bonds, or mutual funds
% of Users
88
71
67
65
61
46
43
32
16
11
TABLE I.
LIST OF ACTIVITIES WHERE GYRUS CAN HELP TO PROTECT
THE CORRESPONDING NETWORK TRANSACTIONS, FROM THE SURVEY
‘WHAT INTERNET USERS DO ONLINE [29]’, BY PEW RESEARCH CENTER.
https://www.paypal.com/us/cgi-bin/webscr,
its POST
parameter named cmd=_flow. Finally, variables for captured
text for amount of money and recipient will be linked to the
POST parameters amount and email.
and
H. Discussion
In cases where the same protocol
is used by multiple
applications, we need one User-Intent Signature for each
application using that protocol. While this may seem a lot of
work, deﬁning the correct behavior of applications of interest
is still much more scalable than endlessly (re)modeling (new)
attack/malware behavior.
As we’ve shown in the examples above, the language we
have devised not only allows us to easily support new applica-
tions, it also cleanly separates the per-application logic from
the core Gyrus framework. With this language, the process of
specifying the user intent signature for an application only
requires knowledge about the UI (and the structure of the
UI object tree exposed by the UI Automation library for that
application, which can be obtained using standard tools like
Inspect [25] from Microsoft) and some knowledge about the
network protocol used by the application, but no further details
about the internals of the application (as compared to if we
used VM introspection techniques to extract user intent).
Although it
is very easy to construct a signature for
supporting a new application, managing a large collection of
signatures could cause overhead. However, we argue that its
overhead is far less than that of traditional IDS and anti-virus
software. While traditional approaches require following up all
newly discovered attacks, Gyrus deﬁnes user-intended, correct
system behaviors and is therefore attack-agnostic. The term
attack-agnostic here does not mean that Gyrus is immune to
all kinds of attacks. Gyrus only makes assumptions about the
attacker’s goal, but not how they achieve this goal. That is,
once a user intent signature is deﬁned, no matter how the attack
evolves, the protection mechanism of Gyrus still works. In
this paper, we focus on protecting the integrity of text content
that is typed by the user, while other kinds of attacks such as
conﬁdentiality of data are out of scope.
In terms of application support, Gyrus can generally sup-
port any application that sends user-generated text content from
the monitored host, if its network trafﬁc has a direct or simple
mapping with on-screen text content. Table I shows the result
of survey that indicates what typical users are doing on the
Internet, done by Pew Internet. According to the survey results,
88% of users send e-mail, 67% of them send their text content
12
to online social network (OSN) sites, and 61% of users use
online banking. Moreover, all activities listed in Table I can be
supported by Gyrus. Clearly, Gyrus can protect a large portion
of day-to-day user activities on the Internet and can have a
large impact on security.
While the focus of Gyrus is text-based applications, it
can be easily extended to handle image/video attachments. In
particular, we can use Access Control Gadgets [30] to capture
the user’s intent to attach a particular ﬁle, compute a checksum
of that ﬁle and have our network proxy match any attached ﬁle
against the checksum. The only way this mechanism would fail
is when an attacker/malware knows a priori which ﬁle the user
will attach and changes it in advance, which we consider to
be unrealistic.
One limitation of Gyrus is that it cannot protect an appli-
cation where user-intended text is represented in a proprietary
format or in some complicated encoding on the trafﬁc. At
least, not without signiﬁcantly more effort to reverse engineer
the format. This can be a problem when extending Gyrus
to more general
transactions such as writing data on the
ﬁlesystem. There have been recent and promising advances
in veriﬁable computation and tools such as probabilistically
checkable proofs (PCP) and fully-homomorphic encryption
(FHE) are becoming practical. When these technologies come
to practice, Gyrus can verify if the result of the trafﬁc is
actually from user-intended input, by running application logic
along with these computation proof mechanisms. In addition,
for applications with complex encodings mentioned above, we
believe that it would be possible to have Gyrus perform the
slightly more complicated transformation on the captured user
intent and match the result with the outgoing trafﬁc. Though
we should be careful not to expand the TCB too signiﬁcantly,
adding the support of the speciﬁc transformations of some of
the most popular applications should be quite doable.
In our threat model, Gyrus only protects the integrity of
the text based on a user’s intent, and it does not protect
conﬁdentiality. An attacker could steal a user’s credentials (e.g,
Cookie, ID/Password), and then perform protected transactions
on a different host without Gyrus protections. Thus, Gyrus
works better when the host is equipped with Hardware Security
Module (HSM) such as Trusted Platform Module (TPM) and
a Smartcard, and the server-side of the application supports
mutual authentication. However, while we consider the defense
against stealing credential to be out of scope, we would point
out that this problem can be solved by using Gyrus in dom-0
to intercept and modify the password that the user has just
entered (and so malware in dom-U can only get the incorrect
password), and correct the subsequent outgoing trafﬁc for the
actual login to use the unmodiﬁed, correct password.
Finally, a point worth noting here is that like any other
system that tries to model benign behavior, Gyrus is vulnerable
to false positives caused by errors in the user intent signatures
(false negatives are also possible, but should be a lesser
concern, as we will argue in the next section); however, false
positives only happen when we fail to specify in our signatures
some of the user actions that signiﬁes the intent to generate
outgoing trafﬁc, or if our signatures specify a wrong way for
capturing user intent. We believe both scenarios should be
rare, since for usability purposes, an application should not
have too much variance in its UI, nor should it provide too
many ways for performing the same operation; similarly, the
correctness of the way we capture user intent for an application
should be easy to establish with simple testing and this should
sufﬁce to guarantee we will continue to capture user intent
correctly, unless the application changes its UI (which, again,
for usability reasons, is less likely to happen).
VI. EVALUATION
In this section, we present the results of our evaluation on
the security, usability and performance of Gyrus when using
it to protect the applications studied in Section V.
A. Security
New security frameworks should be secure against both
current ant future attacks. Here, we consider both scenarios
for Gyrus by running existing attack samples and by analyzing
the framework’s security properties.
1) Resilience Against Existing Attacks: Gyrus is attack-
agnostic by design, however, to demonstrate that we imple-
mented the system correctly, we tested Gyrus’ ability to stop
attacks against the speciﬁc applications discussed in Sect. V.
For Windows Live Mail, we executed Win32:MassMail-A,
a mail spammer malware, while the mail client
is un-
der Gyrus’ protection. The dom-0 network monitor success-
fully catches, and blocks all outgoing SMTP trafﬁc gener-
ated by the malware. For Yahoo! Messenger protocol, we
ran ApplicUnwnt.Win32.SpamTool.Agent.˜BAAE, a
messenger spamming malware. All of the messages generated
by this malware are blocked by Gyrus. For Facebook, we exe-
cuted a comment spamming malware TROJ_GEN.RFFH1G1,
and it has no success in sending out attack trafﬁc. We have
also tested the effectiveness of Gyrus against Javascript-based
attacks (like XSS, CSRF) targeting web applications. In partic-
ular, we injected forged Javascript code that automatically sub-
mits malicious content into the GMail, Facebook and Paypal
pages; in all cases, Gyrus successfully blocked all malicious
trafﬁc from these attacks. Finally, for each tested application,
we tried to perform the normal operations protected by Gyrus
with the corresponding attacks running in the background. In
each case, Gyrus allows the legitimate, user generated trafﬁc
to go through while stopping all attacks.
2) Resilience Against Future Attacks: Next, we will evalu-
ate how well Gyrus can handle future attacks designed against
it. All security guarantees will be void if assumptions in
our threat model are violated. However, we believe those are
standard assumptions widely accepted by the security commu-
nity, thus we will not discuss violations of the assumptions.
However, we do note that even though existing hypervisors
are becoming more complicated, it is possible – and, in fact,
encouraged – to build custom hypervisors or security operating
systems for use with Gyrus to achieve higher assurance [20],
[5], [40].
The next avenue for attack is against the UI monitor that
runs in the untrusted dom-U. However, we believe Gyrus is
quite robust against errors in the UI monitor. First of all,
thanks to the secure overlay, attackers are limited to misplacing
user-generated, albeit unintended content in trafﬁc allowed by
Gyrus (e.g., switching the subject and content of an email, take
users comment to one story on Facebook as his/her outgoing
comment on another story), and thanks to our policy of only
displaying on the overlay the content of the window which
current have focus, the mistakenly sent out content must be
from the “correct” application. Also, we believe we can further
harden Gyrus against such attacks by specifying a restriction
on the position of the content to be sent out in relation to the
event that triggers the outgoing trafﬁc (e.g., the text displayed
on the overlay cannot be too far away from the coordinate of
the mouse click). A compromised UI monitor can also mislead
Gyrus to believe a mouse click signiﬁes the user’s intent to
send out something (i.e. stealing a click); however, once again
thanks to the secure overlay, the unintended outgoing trafﬁc
will have its content entirely entered by the user (i.e., this
could cause a premature output of the content). Therefore, the
attacker will have very little control over what is sent. Finally,
we believe our policy concerning what kind of update to text
boxes the UI monitor can report provides very good protection
to data that are currently off-screen.
Similarly, poorly written user intent signatures can be
problematic; however, thanks to the use of the secure overlay,
we believe problems with a user intent signature are limited to
mistaking hardware events as user intent to send something,
and will have the same adverse effect as a misbehaving UI
monitor stealing a click. In conclusion, we believe the secure
overlay (and the WYSIWYS policy) leaves an attacker with
very limited options for attacking Gyrus. Anything sent out
by a protected application using a targeted protocol must be
typed, and seen by the user. All the attacker can do is to use
content intended for one purpose (under the same application)
for another, and the cases where this can cause a user any real
harm should be very rare.
B. Usability
From our experience of protecting the applications stud-
ied in Section V, Gyrus has no noticeable effect on their
usability. In Gyrus, user-interaction is mediated by the internal
components of Gyrus: Input handler, and Secure Overlay. For
interposing user input before delivering it to the application,
Gyrus does not incur noticeable delay (see Section VI-C1 for
the evaluation results). Since Gyrus only overlays text boxes in
our target applications, it will not change the user’s workﬂow
or the look-and-feel of the other parts of the application.
Furthermore, Gyrus displays (on the secure overlay) text
with the same font face, size, and color as the underlying
application. Finally, we have conﬁrmed that the edit box drawn
by Gyrus not only supports simple text editing like typing,
selection, and copy & paste, but also application-speciﬁc text
editing features like auto-completion and spelling correction.
So we are conﬁdent that Gyrus will not affect the user’s
experience with the application being monitored. Furthermore,
since Gyrus only checks (and potentially blocks) trafﬁc that
perform speciﬁc actions under speciﬁc protocols of interest
12, our experience shows that Gyrus does not interfere with
background networking programs such as BitTorrent and RSS
feeds. Gyrus can also handle scheduled jobs that have a time
gap between a user’s interaction and the resulting generation of
network trafﬁc, thanks to our use of the Authorization DB for
the capturing of user intent from the actual inspection of trafﬁc.
12For example, Gyrus only checks HTTP trafﬁc for sending emails under
GMail, but not that for reading emails.
13
Actions
Typing
ENTER
LCLICK
Focus Change
Move & Resize
Average
39ms
19ms
43ms
21ms
21ms
STDV Median
34ms
21ms
17ms
6ms
15ms
41ms
17ms
19ms
16ms
16ms
Max
128ms
43ms
79ms
158ms
85ms
TABLE II.
LATENCY INTRODUCED BY GYRUS WHILE PROCESSING
THE INPUT. USER-INTERACTION DATA WAS COLLECTED DURING THE USE
CASE EVALUATION.
Cases
Single (A)
Single (B)
Web Page
Download
KVM
101.7ms
31.20ms
897.5ms
51.1MB/s
Gyrus
102.3ms
32.30ms