总的来说，Rust 在调用库函数 `asctime` 和 `mktime` 时，必须处理以下两个问题：
* 将裸指针作为唯一参数传递给每个库函数。
* 把从 `asctime` 返回的 C 字符串转化为 Rust 字符串。
### Rust 调用 asctime 和 mktime
工具 `bindgen` 会根据类似 `math.h` 和 `time.h` 之类的 C 头文件生成 Rust 支持的代码。下面这个简化版的 `time.h` 就可以用来做例子，简化版与原版主要有两个不同：
* 内置类型 `int` 被用来取代别名类型 `time_t`。工具 bindgen 可以处理 `time_t` 类，但是会生成一些烦人的警告，因为 `time_t` 不符合 Rust 的命名规范：`time_t` 以下划线区分 `time` 和 `t`；Rust 更偏好驼峰式命名方法，比如 `TimeT`。
* 出于同样的原因，这里选择 `StructTM` 作为 `struct tm` 的别名。
以下是一份简化版的头文件，`mktime` 和 `asctime` 在文件底部：
```
typedef struct tm {
  int tm_sec;  /* 秒 */
  int tm_min;  /* 分钟 */
  int tm_hour;   /* 小时 */
  int tm_mday;   /* 日 */
  int tm_mon;  /* 月 */
  int tm_year;   /* 年 */
  int tm_wday;   /* 星期 */
  int tm_yday;   /* 一年中的第几天 */
  int tm_isdst;  /* 夏令时 */
} StructTM;
extern int mktime(StructTM*);
extern char* asctime(StructTM*);
```
`bindgen` 安装好后，`mytime.h` 作为以上提到的头文件，以下命令（`%` 是命令行提示符）可以生成所需的 Rust 代码并将其保存到文件 `mytime.rs`：
```
% bindgen mytime.h > mytime.rs
```
以下是 `mytime.rs` 中的重要部分：
```
/* automatically generated by rust-bindgen 0.61.0 */
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
  pub tm_sec: ::std::os::raw::c_int,
  pub tm_min: ::std::os::raw::c_int,
  pub tm_hour: ::std::os::raw::c_int,
  pub tm_mday: ::std::os::raw::c_int,
  pub tm_mon: ::std::os::raw::c_int,
  pub tm_year: ::std::os::raw::c_int,
  pub tm_wday: ::std::os::raw::c_int,
  pub tm_yday: ::std::os::raw::c_int,
  pub tm_isdst: ::std::os::raw::c_int,
}
pub type StructTM = tm;
extern "C" {
  pub fn mktime(arg1: *mut StructTM) -> ::std::os::raw::c_int;
}
extern "C" {
  pub fn asctime(arg1: *mut StructTM) -> *mut ::std::os::raw::c_char;
}
#[test]
fn bindgen_test_layout_tm() {
  const UNINIT: ::std::mem::MaybeUninit = ::std::mem::MaybeUninit::uninit();
  let ptr = UNINIT.as_ptr();
  assert_eq!(
  ::std::mem::size_of::(),
  36usize,
  concat!("Size of: ", stringify!(tm))
  );
  ...
```
Rust 结构体 `struct tm`，跟原本在 C 中的一样，包含了 9 个 4 字节的整型字段。这些字段名称在 C 和 Rust 中是一样的。`extern "C"` 区域声明了库函数 `astime` 和 `mktime` 分别需要只一个参数，一个指向可变实例 `StructTM` 的裸指针。（库函数可能会通过指针改变作为参数传递的结构体。）
`#[test]` 属性下的其余代码是用来测试 Rust 版的时间结构体的布局。通过命令 `cargo test` 可以进行这些测试。问题在于，C 没有规定编译器应该如何对结构体中的字段进行布局。比如说，C 的 `struct tm` 以字段 `tm_sec` 开头用以表示秒；但是 C 不需要编译版本遵循这个排序。不管怎样，Rust 测试应该会成功，而 Rust 对库函数的调用也应如预期般工作。
### 设置好第二个案例并开始运行
从 `bindgen` 生成的代码不包含 `main` 函数，所以是一个天然的模块。以下是一个 `main` 函数初始化了 `StructTM` 并调用了 `asctime` 和 `mktime`：
```
mod mytime;
use mytime::*;
use std::ffi::CStr;
fn main() {
  let mut sometime  = StructTM {
    tm_year: 1,
    tm_mon: 1,
    tm_mday: 1,
    tm_hour: 1,
    tm_min: 1,
    tm_sec: 1,
    tm_isdst: -1,
    tm_wday: 1,
    tm_yday: 1
  };
  unsafe {
    let c_ptr = &mut sometime; // 裸指针
    // 调用，转化，并拥有
    // 返回的 C 字符串
    let char_ptr = asctime(c_ptr);
    let c_str = CStr::from_ptr(char_ptr);
    println!("{:#?}", c_str.to_str());
    let utc = mktime(c_ptr);
    println!("{}", utc);
  }
}
```
这段 Rust 代码可以被编译（直接用 `rustc` 或使用 `cargo`）并运行。输出为：
```
Ok(
    "Mon Feb  1 01:01:01 1901\n",
)
2120218157
```
对 C 函数 `asctime` 和 `mktime` 的调用必须再一次被放在 `unsafe` 区域内，因为 Rust 编译器无法对这些外部函数的潜在内存安全风险负责。此处声明一下，`asctime` 和 `mktime` 并没有安全风险。调用的两个函数的参数是裸指针 `ptr`，其指向结构体 `sometime` （在 栈   stack 中）的地址。
`asctime` 是两个函数中调用起来更棘手的那个，因为这个函数返回的是一个指向 C `char` 的指针，如果函数返回 `Mon` 那么指针就指向 `M`。但是 Rust 编译器并不知道 C 字符串 （`char` 的空终止数组）的储存位置。是内存里的静态空间？还是 堆   heap ？`asctime` 函数内用来储存时间的文字表达的数组实际上是在内存的静态空间里。无论如何，C 到 Rust 字符串转化需要两个步骤来避免编译错误：
* 调用 `Cstr::from_ptr(char_ptr)` 来将 C 字符串转化为 Rust 字符串并返回一个引用储存在变量 `c_str` 中。
* 对 `c_str.to_str()` 的调用确保了 `c_str` 是所有者。
Rust 代码不会增加从 `mktime` 返回的整型值的易读性，这一部分留作课外作业给感兴趣的人去探究。Rust 模板 `chrono::format` 也有一个 `strftime` 函数，它可以被当作 C 的同名函数来使用，两者都是获取时间的文字表达。
### 使用 FFI 和 bindgen 调用 C
Rust FFI 和工具 `bindgen` 都能够出色地协助 Rust 调用 C 库，无论是标准库还是第三方库。Rust 可以轻松地与 C 交流，并透过 C 与其他语言交流。对于调用像 `sqrt` 一样简单的库函数，Rust FFI 表现直截了当，这是因为 Rust 的原始数据类型覆盖了它们在 C 中的对应部分。
对于更为复杂的交流 —— 特别是 Rust 调用像 `asctime` 和 `mktime` 一样，会涉及到结构体和指针的 C 库函数 —— `bindgen` 工具是优秀的帮手。这个工具会生成支持代码以及所需要的测试。当然，Rust 编译器无法假设 C 代码对内存安全的考虑会符合 Rust 的标准；因此，Rust 必须在 `unsafe` 区域内调用 C。
---
via: 
作者：[Marty Kalin](https://opensource.com/users/mkalindepauledu) 选题：[lkxed](https://github.com/lkxed) 译者：[yzuowei](https://github.com/yzuowei) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出