4. Read Array
5. Get member on user object
6. Set member on user object
7. Invoke member on user object
8. String Splitting
9. String Replacing
10. DOM Operation getElementById
11. DOM Operation createElement
12. With Statement
13. Eval Statement with Simple String
Web Sandbox Virtual Browser
492ms
515ms
1019ms
1610ms
589ms
566ms
605ms
466ms
475ms
707ms
673ms
N/A
N/A
480ms
525ms
621ms
1217ms
416ms
500ms
523ms
532ms
577ms
757ms
822ms
333ms
2867ms
Table 2: 10K Atomic Operations’ Speed Comparison of Web Sandbox and Virtual Browser
)
B
K
(
e
g
a
s
U
y
r
o
e
m
e
M
8
6
4
2
0
4
x 10
With Virtual Browser
Without Virtual Browser
Poker
Bounce Connect 4
Types of Games
Figure 8: Memory Usage
can feel only a little additional delay. Our system will not be
able to support larger animation JavaScripts. However, for
common third-party JavaScripts which do not involve very
frequent events and are also not very large, the comparative
slowness of our system should not pose a problem at all. We
believe the situation is similar to Java and Python being
preferred for some applications than C and C++ owing to
their ease of programming despite their not being eﬃcient
enough. Virtual Browser provides an easy way to handle
all kinds of third-party scripts, even those using complex
and unsafe functions like eval and yet without any security
glitches.
6.1.1 Memory Usage
Figure 8 compares memory usage of third-party Java-
Script applications running in Virtual Browser to that when
they are running in a native browser. We choose third-party
JavaScript games from a popular web site[5]. Connect 4 and
poker are two games with user interaction. Users need to
move and click the mouse to play these games. These two
games’ memory usage with Virtual Browser is about 2%
higher than that without Virtual Browser. Bounce is a game
with substantial animation and user interaction in which the
user can see a ball bouncing in the screen. Bounce takes
about 20% more memory when running in Virtual Browser.
This is because high animation programs require more re-
source from Virtual Browser.
6.1.2 Parsing Latency
We measure parsing latency of the virtual HTML and
JavaScript parsers in Figure 9 and Figure 10 by parsing a
1000
800
600
400
200
)
s
m
(
e
m
T
i
0
0
100
200
300
Number of Lines
Figure 9: Latency of JavaScript Parsing
game web site [5] and a JavaScript game, Connect 4 from it.
Both of these parsers are written in JavaScript. In Figure 9,
JavaScript parsing rates decrease slightly when the number
of lines increases (as shown in [9], top-down parsing is a
polynomial time process). As seen in Figure 10, HTML
parsing is faster than JavaScript parsing because JavaScript
language with more types of AST nodes is more complex
than HTML.
The JavaScript parser written in JavaScript is not very
fast. An alternative of this virtual JavaScript parser would
be to pre-parse ﬁrst-order JavaScript and HTML code at
server side, generate a JavaScript Object (parsing results)
that our execution engine requires, and transmit JSON for-
mat to the client. JSON parsing speed is fast enough at
about 600K/s. However, this may be vulnerable because
the JSON generator at the server side and the JSON parser
at the client side may interpret JSON diﬀerently. Due to
the simplicity and well-formatted-ness of the JSON proto-
col, the chance of diﬀerent interpretations is low; so we can
still consider this approach as an alternative. We still exe-
cute third-party JavaScript on the virtual JavaScript engine
(and not on the native JavaScript engine) and even if we
adopt this alternative, our approach will still be more se-
cure than other runtime approaches.
Unlike ﬁrst-order JavaScript, high-order JavaScript and
HTML (generated by scripts dynamically), like the scripts
introduced by innerHTML and document.write, have to be
parsed in the parser written in JavaScript. Compared to
ﬁrst-order JavaScript, the amount of these kinds of codes is
relatively small. Thus, using our parser will not introduce
too much delay and the JSON approach remains viable.
80
60
40
20
)
s
m
(
e
m
T
i
0
0
50
100
150
200
Number of Lines
Figure 10: Latency of HTML Parsing
6.2 Browser Quirks Compatibility
Since we parse scripts only once at the virtual JavaScript
engine, and do not rely on the native parsers, we are not vul-
nerable to browser quirks. Additionally, scripts cannot leak
from our system to the native JavaScript engine. We evalu-
ate our system with 113 browser quirks’ examples listed in
the XSS Cheat Sheet [11]. The XSS Cheat Sheet contains
mostly examples of XSS attacks that are caused by browser
quirks. The results show that none of the 113 browser quirks
lets third-party JavaScript codes bypass the virtual Java-
Script engine, regardless whether the language features are
supported by Virtual Browser.
6.3 Robustness to Unknown Native JavaScript
Engine Bugs
We evaluate the robustness of Virtual Browser to un-
known native JavaScript engine bugs. In this experiment,
we use an old version (before 2009) of Firefox. All the bugs
(14 in totals) recorded in CVE [2] related to SpiderMonkey
JavaScript engine in the year of 2010 and 2009 are evalu-
ated. The results are the same as we discussed in Section
2. Running of example exploits in the database does not
trigger those vulnerabilities in Virtual Browser.
Furthermore, our implementation of Virtual Browser does
not satisfy the preconditions for triggering any of those vul-
nerabilities. We illustrate three as examples. Others are
similar.
• CVE-2010-0165: Native eval is required to trigger this
vulnerability. Virtual browser source code does not use
native eval statement.
• CVE-2009-2466: The vulnerability is triggered by the
statement with(document.all){}. Virtual browser source
code does not use with statement.
• CVE-2009-1833: The prototype of an object is set to
be null inside the prototype function. Virtual browser
source code does not use prototype in this way.
6.3.1 Discussion
How does Virtual Browser deal with bugs in Vir-
tual JavaScript engine? The experiment of this section
is performed to prove the hardness of circumventing vir-
tual JavaScript engine to exploit native JavaScript engine.
The security of virtual engine is fully analyzed in Section
4. Moreover, virtual JavaScript engine of Virtual browser
is written in JavaScript, a type safe language that does not
have vulnerabilities like buﬀer overﬂow in native JavaScript
engine.
Where does the robustness come from? Virtual Browser
is implemented by a type safe language, which gradually re-
duces the number of possible vulnerabilities. However, the
enhanced security does not only come from type safe lan-
guage but also the virtualization technique.
Browser virtualization adds another layer that increases
security assurance.
In particular, Virtual Browser utilizes
virtualization to isolate JavaScript codes. Attackers need
to break Virtual Browser ﬁrst and then native browser to
steal information. Similar to a virtual machine that has
higher security assurance than other native sandboxes, Vir-
tual Browser with another virtualization layer has its advan-
tages.
6.4 Completeness of Virtual Browser Imple-
mentation
We evaluate the completeness of our prototype of Virtual
Browser in order to show that our other experimental results
are convincing. We use test cases of ECMA-262 Edition 1
from Mozilla [7]. The results show that we can pass 96% of
the test cases. For some categories, such as JavaScript State-
ment, String, Expressions, Types, etc., we can pass 100% of
the test cases. The worst of all is Object Objects, for which
we can only pass 72% test cases. The incomplete implemen-
tation will only aﬀect the functionality of Virtual Browser
but not the security of Virtual Browser because we intro-
duce the data ﬂows after isolation. Security is always the
most important concern in Virtual Browser.
When we are trying to run the same test in Web Sandbox
[27], Web Sandbox cannot even run the test itself because
Web Sandbox does not have full support of eval. However,
eval is required in the driver of these test cases. This also
proves the importance of eval without which we cannot per-
form the tests. Therefore, we have to give up running the
test for Web Sandbox. Our manual check shows that they
do not have complete implementation either.
7. CONCLUSIONS
In this paper, we propose the concept of browser virtu-
alization, and we designed and implemented a prototype
of Virtual Browser in JavaScript. With Virtual Browser,
we allow unmodiﬁed full-featured third-party JavaScripts to
run on Virtual Browser and enforce secure constraints on
its privileges and communication with the JavaScripts from
the web site. In our design, we ﬁrst build an isolated virtual
browser layer without any possible communication channel
with the native browser resources and with the JavaScript
from the web site. Then, we introduce the necessary data
ﬂows explicitly. Compared with existing eﬀorts with simi-
lar goal, such as Web Sandbox, our scheme can allow full-
featured JavaScript execution instead of limiting a subset of
JavaScript functionalities. Fundamentally, it is much eas-
ier for any unmodiﬁed third-party JavaScript code to run
on our scheme directly. Performance evaluation shows our
prototype has a similar performance as Web Sandbox.
8. ACKNOWLEDGEMENTS
This work was supported by US NSF CNS-0831508. Opin-
ions, ﬁndings, and conclusions are those of the authors and
do not necessarily reﬂect the views of the funding sources.
9. REFERENCES
[1] AD Safe. http://www.adsafe.org/.
[2] Common vulnerabilities and exposures.
[23] Kikuchi, H., Yu, D., Chander, A., Inamura, H.,
http://cve.mitre.org/.
[3] Doxygen. http://www.stack.nl/~dimitri/doxygen/.
[4] FBJS. http:
//wiki.developers.facebook.com/index.php/FBJS.
[5] Javascript game site.
http://javascript.internet.com/games/.
[6] JavaScript reference. https://developer.mozilla.
org/en/Core_Javascript_1.5_Reference.
[7] Javascript test cases. http://mxr.mozilla.org/
mozilla/source/js/tests/ecma/.
[8] Mozilla rejects native code approach of chrome’s nacl.
http://css.dzone.com/articles/
mozilla-rejects-native-code.
[9] Parsing time complexity.
http://en.wikipedia.org/wiki/Top-down_parsing.
[10] Webkit source codes.
http://webkit.org/building/checkout.html.
[11] XSS Cheat Sheet. http://ha.ckers.org/xss.html.
[12] Acker, S. V., Ryck, P. D., Desmet, L., Piessens,
F., and Joosen, W. Webjail: Least-privilege
integration of third-party components in web
mashups. In Annual Computer Security Applications
Conference (ACSAC) (2011).
[13] Barth, A., Jackson, C., and Li, W. Attacks on
javascript mashup communication. In W2SP: Web 2.0
Security and Privacy (2009).
[14] Barth, A., Jackson, C., and Mitchell, J. C.
Securing frame communication in browsers. In 17th
USENIX Security Symposium (2008).
[15] Barth, A., Weinberger, J., and Song, D.
Cross-origin javascript capability leaks: Detection,
exploitation, and defense. In 18th USENIX Security
Symposium (2009).
[16] Crites, S., Hsu, F., and Chen, H. Omash: enabling
secure web mashups via object abstractions. In CCS:
Conference on Computer and Communication Security
(2008).
[17] De Keukelaere, F., Bhola, S., Steiner, M.,
Chari, S., and Yoshihama, S. Smash: secure
component model for cross-domain mashups on
unmodiﬁed browsers. In WWW: Conference on World
Wide Web (2008).
[18] Dong, X., Tran, M., Liang, Z., and Jiang, X.
Adsentry: Comprehensive and ﬂexible conﬁnement of
javascript-based advertisements. In Annual Computer
Security Applications Conference (ACSAC) (2011).
[19] Finifter, M., Weinberger, J., and Barth, A.
Preventing capability leaks in secure javascript
subsets. In NDSS: Network and Distributed System
Security Symposium (2010).
[20] Google. Google Caja.
http://code.google.com/p/google-caja/.
[21] Guarnieri, S., and Livshits, B. Gatekeeper: Mostly
static enforcement of security and reliability policies
for JavaScript code. In 18th USENIX Security
Symposium (2009).
[22] Huang, Y.-W., Yu, F., Hang, C., Tsai, C.-H.,
Lee, D.-T., and Kuo, S.-Y. Securing web application
code by static analysis and runtime protection. In
WWW: Conference on World Wide Web (2004).
and Serikov, I. Javascript instrumentation in
practice. In APLAS: Asian Symposium on
Programming Languages and Systems (2008).
[24] Maffeis, S., Mitchell, J., and Taly, A. Run-time
enforcement of secure javascript subsets. In W2SP:
Web 2.0 Security and Privacy (2009).
[25] Meyerovich, L., Felt, A. P., and Miller, M.
Object views: Fine-grained sharing in browsers. In
WWW: Conference on World Wide Web (2010).
[26] Meyerovich, L., and Livshits, B. ConScript:
Specifying and enforcing ﬁne-grained security policies
for Javascript in the browser. In IEEE Symposium on
Security and Privacy (2010).
[27] Microsoft Live Labs. WebSandbox.
http://websandbox.livelabs.com/.
[28] Mozilla. Narcissus javascript engine.
http://mxr.mozilla.org/mozilla/source/js/narcissus/.
[29] Nadji, Y., Saxena, P., and Song, D. Document
structure integrity: A robust basis for cross-site
scripting defense. In NDSS: Network and Distributed
System Security Symposium (2009).
[30] Politz, J. G., Eliopoulos, S. A., Guha, A., and
Krishnamurthi, S. ADsafety: type-based veriﬁcation
of JavaScript sandboxing. In Proceedings of the 20th
USENIX conference on Security (Berkeley, CA, USA,
2011), SEC’11, USENIX Association, pp. 12–12.
[31] Reis, C., Dunagan, J., Wang, H. J., Dubrovsky,
O., and Esmeir, S. Browsershield:
vulnerability-driven ﬁltering of dynamic html. In
OSDI (2006).
[32] Resig, J. HTML Parser written in JavaScript. http:
//ejohn.org/blog/pure-javascript-html-parser/.
[33] Senocular. CSSParser.
http://www.senocular.com/index.php?id=1.289.
[34] Sotirov, A. Blackbox reversing of XSS ﬁlters.
RECON (2008).
[35] Ter Louw, M., Ganesh, K. T., and
Venkatakrishnan, V. Adjail: Practical enforcement
of conﬁdentiality and integrity policies on web
advertisements. In 19th USENIX Security Symposium
(2010).
[36] Ter Louw, M., and Venkatakrishnan, V.
Blueprint: Precise browser-neutral prevention of
cross-site scripting attacks. In SP: 30th IEEE
Symposium on Security and Privacy (2009).
[37] Wang, H. J., Fan, X., Jackson, C., and Howell,
J. Protection and communication abstractions for web
browsers in MashupOS. In SOSP: ACM Symposium
on Operating Systems Principles (2007).
[38] Yee, B., Sehr, D., Dardyk, G., Chen, J. B.,
Muth, R., Ormandy, T., Okasaka, S., Narula,
N., and Fullagar, N. Native client: A sandbox for
portable, untrusted x86 native code. In SP: IEEE
Symposium on Security and Privacy (2009).
[39] Yu, D., Chander, A., Islam, N., and Serikov, I.
Javascript instrumentation for browser security. In
POPL (2007).
[40] Yue, C., and Wang, H. Characterizing insecure
javascript practices on the web. In WWW: Conference
on the World wide web (2009).