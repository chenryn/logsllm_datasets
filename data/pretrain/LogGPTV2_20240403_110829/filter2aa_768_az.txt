《软件调试》补编 
- 95 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
2. 
创建一个__Win32Provider 类的实例。__Win32Provider 是一个内部类，用于描述提供
器对象。可以把创建一个__Win32Provider 实例的过程理解成是在 CIM 对象数据库的
__Win32Provider 数据表中增加一行。每个属性的值就是这一行对应列的值。 
instance of __Win32Provider as "$Reg ; 
{ 
Name = "RegProv"; 
CLSID = "{fe9af5c0-d3b6-11ce-a5b6-00aa00680c3f}"; 
HostingModel = “NetworkServiceHost:LocalServiceHost” 
}; 
以上语句实质上会在提供器表中增加一行新的记录，该行 Name 列、CLSID 列和
hostingMode 列的内容分别等于指定的值。Name 即该提供器的名称，不需解释。CLSID
是该提供器的 COM 组件的 GUID。COM 注册时，该 GUID 会被写入注册表。WMI 就是
通过提供器的 GUID 找到它，然后借助 COM 技术加载对应的模块和创建提供器对象。
HostingModel 用来指定提供器的宿主（host）特征，即 WMI 应该以什么样的环境来加载
和运行提供器，包括以什么帐号来加载它以及将其加载到哪个进程。目前 WMI 支持如下
几种 HostingModel： 
 SelfHost：提供器运行在自己的本地 COM 服务器进程（EXE）中。 
 LocalSystemHost 
、
LocalSystemHostOrSelfHost
、
NetworkServiceHost
和
LocalServiceHost：如果提供器是以进程内 COM 服务器的方式实现的，那么便运
行在共享的提供器宿主进程（wmiprvse.exe）中。否则提供器便是运行在自己的本
地 COM 服务器进程（EXE）中。这几个选项的差异是宿主进程是以哪个帐号运
行的，LocalSystem 的权限最高，应该仅在当提供器需要访问特权信息时才使用。
NetworkService 和 LocalService 的权限都是受限的（limited），如果提供器需要访
问远程的机器，那么推荐使用 NetworkService，如果所有操作都是在本地机器上
完成，那么推荐使用 LocalService。 
 Decoupled:Com：提供器运行在隔离的 WMI 客户进程中。 
需要说明的是，HostingModel 设置只适用于 Windows 2000 只后的 Windows，对
于 Windows 2000 来说，说有进程内提供器（DLL 形式的提供器）都运行在 winmgmt
进程内。 
3. 
创 建 __ProviderRegistration
类 或 其 派 生 类 的 实 例 。 WMI
提 供 了 六 个
__ProviderRegistration 类__ClassProviderRegistration、__InstanceProvider- Registration、
__EventProviderRegistration
、
__EventConsumerProviderRegistration
、
__MethodProviderRegistration、__PropertyProviderRegistration 分别用来注册 6 种类型
的提供器。如果一个提供器实现了多个角色，那么便要分别创建多个实例。比如如下
语句为 StdRegProv 提供器注册了实例提供器和方法提供器两种身份。 
instance of __InstanceProviderRegistration 
{ 
provider = "$Reg"; 
SupportsDelete = FALSE; 
SupportsEnumeration = TRUE; 
SupportsGet = TRUE; 
SupportsPut = TRUE; 
}; 
instance of __MethodProviderRegistration 
{ 
provider = "$Reg"; 
}; 
4. 
将以上内容保存到一个 MOF 文件中并放在一个安全的位置。然后使用 mofcomp 命令
编译并执行以上语句。如果一切顺利，那么提供器便顺利注册了。 
《软件调试》补编 
- 96 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
5. 
接下来可以使用我们前面介绍的 WMI CIM Studio 在第一步指定的命名空间中寻找刚
注册的提供器（类和实例），检验其是否工作正常。要提醒大家的是，如果遇到
0x80041013 错误，那么其含义是 Provider load failure，即加载提供其失败，这时首先
应该检查提供器的 COM 组件是否成功注册以及对应的模块文件是否存在。 
31.4.3  WMI 提供器进程 
所谓 WMI 提供器进程就是指 WMI 提供器所处的进程，因为少量的 EXE 形式的提供
器运行在自己的进程中，不需要 WMI 为其提供宿主进程，所以很多时候（包括本书），
WMI 提供器进程是用来泛指承载（host）DLL 形式的 WMI 提供器的进程。 
在 Windows 2000 中，WMI 的服务进程（winmgmt.exe）同时承担提供器进程的角色。
这样的做的问题是如果某个提供器中的代码发生了错误，那么可能导致整个进程崩溃。
Windows XP 对此做了改进，使用 wmiprvse.exe 进程来加载和运行提供器模块。
wmiprvse.exe 进程的个数是不确定的，WMI 服务进程会根据需要动态创建 wmiprvse.exe
进程，当不需要时，wmiprvse.exe 进程会退出。所以在任务列表中，有时我们可能看不到
wmiprvse.exe 进程，但是如果运行一个使用 WMI 服务的程序，那么就可以看到这个进程
了，过一回可能又会发现这个进程不见了。wmiprvse.exe 进程和 WMI 服务进程之间也是
使用 RPC 机制进行通行。清单 31-9 的函数调用序列显示了当执行枚举 InstProvSamp 类实
例的脚本时，wmiprvse.exe 进程内的 WMI 提供器类（CInstPro）的方法被调用的过程。 
清单 31-9  运行在 wmiprvse.exe 进程内的 InstProvSamp 提供器类被远程调用的典型过程 
instprov!CreateInst+0x10 
instprov!CInstPro::CreateInstanceEnumAsync+0xd3  
wmiprvse!CInterceptor_IWbemSyncProvider::Helper_CreateInstanceEnumAsync+0x152 
wmiprvse!CInterceptor_IWbemSyncProvider::CreateInstanceEnumAsync+0x70 
RPCRT4!CheckVerificationTrailer+0x75 
RPCRT4!NdrStubCall2+0x215 
RPCRT4!CStdStubBuffer_Invoke+0x82 
FastProx!CBaseStublet::Invoke+0x22 
ole32!SyncStubInvoke+0x33 
ole32!StubInvoke+0xa7 
[以下省略多行] 
如此看来，在 Windows XP，WMI 应程序和 WMI 提供器之间的通信大多要经历两次
基于 RPC 机制的进程间通信（参见图 31-11），RPC 通信为分布式管理提供了支持，有着
很高的灵活性，但是这也是有代价的，要进行比较复杂的安全检查和数据整理工 
WMI应用
程序
WMI服务
进程
(hostsvc.exe
)
WMI提供
器进程
(wmiprvse.e
xe)
图 31-11   WMI 应程序和提供器间的通信过程（Windows XP） 
作，因此比一般的本地进程间通信速度要慢很多。另外，因为提供器进程是动态创建的，
创建和初始化该进程也需要一些时间。这些因素导致执行到调用 WMI 服务的代码时，有
时可以感觉到明显的时间延迟。 
《软件调试》补编 
- 97 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
31.5  WMI 应用程序 
WMI 应用程序通常是指利用 WMI 服务提供各种管理功能的软件工具。WMI 应用程
序使通过 WMI 技术构建的管理服务为用户所用、发挥价值。从消耗和提供的角度来看，
WMI 应用程序消耗（Consume）WMI 服务提供器提供的信息，因此属于消耗器。 
简单来说，Windows 提供了以下四种方式供不同类型的应用程序使用 WMI 服务： 
1. 
COM/DCOM 接口，C/C++程序可以通过这些接口与 WMI 的核心组件通信并调用所需
的服务。 
2. 
ActiveX 控件，各种脚本程序可以通过进一步封装过的 ActiveX 控件来调用 WMI 服务。 
3. 
ODBC 适配器（ODBC Adaptor），通过该适配器，可以像访问数据库那样访问 WMI
中的信息。 
4. 
.Net 框架中的 System.Management 类库，.Net 程序可以通过该类库中的各个类使用
WMI 服务。 
下面我们分别进行介绍。 
31.5.1  通过 COM/DCOM 接口使用 WMI 服务 
使用 C/C++调用 WMI 服务是其前面介绍的四种方式中最复杂的一种，因为需要在应
用程序中自己初始化 COM 库、创建组件实例、并完成琐碎的清理工作。但是这种方式的
优点是灵活性高，执行速度也会快一些。 
使用 C/C++调用 WMI 服务的过程归纳为以下几个步骤。 
初始化
初始化
初始化
初始化 COM 库
库
库
库 
因为 WMI 服务都是以 COM 组件的形式建立的，所以访问 WMI 服务的过程实际上就
是创建和使用 COM 组件的过程。在使用 COM API 创建 COM 对象之前，必须进行初始化，
可以使用 CoInitializeEx 函数或 OleInitialize 函数来初始化 COM 库。 
初始化进程安全属性
初始化进程安全属性
初始化进程安全属性
初始化进程安全属性 
因为很多 WMI 服务都定义了安全控制，所以通常还需要调用 CoInitializeSecurity 来
设置当前进程的默认安全属性。 
    hres =  CoInitializeSecurity( 
        NULL,  
        -1,                           
// COM negotiates service 
        NULL,                         
// Authentication services 
        NULL,                         
// Reserved 
        RPC_C_AUTHN_LEVEL_DEFAULT,  
// Default authentication  
        RPC_C_IMP_LEVEL_IMPERSONATE, 
// Default Impersonation   
        NULL,                         
// Authentication info 
        EOAC_NONE,                    
// Additional capabilities  
        NULL                          
// Reserved 
        ); 
连接
连接
连接
连接 WMI 服务
服务
服务
服务 
在使用 WMI 服务（类或提供器）前，必须先与该服务所在的命名空间建立连接，目
的是获得一个实现了 IWbemServices 接口的 WBEM 服务实例。可以使用 IWbemLocator
接口的 ConnectServer 方法来实现这一目的。这先需要创建一个实现了 IWbemLocator 接口
《软件调试》补编 
- 98 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
的组件。 
IWbemLocator *pIWbemLocator = NULL; 
    if(CoCreateInstance(CLSID_WbemLocator, 
        NULL, CLSCTX_INPROC_SERVER, 
        IID_IWbemLocator, (LPVOID *) &pIWbemLocator) == S_OK) 
    { 
        // Using the locator, connect to CIMOM in the given namespace. 
        if(pIWbemLocator->ConnectServer(pNamespace, 
                                NULL,    
//using current account for simplicity 
                                NULL,     
//using current password for simplicity 
                                0L,        
// locale 
                                0L,         // securityFlags 
                                NULL,     
// authority (domain for NTLM) 
                                NULL,     
// context 
                                &m_pIWbemServices) != S_OK)  
        {     
            // error handling 
        } 
        pIWbemLocator->Release(); 
    } 
设置
设置
设置
设置 WMI 连接的安全等级
连接的安全等级
连接的安全等级
连接的安全等级（
（
（
（security level）
）
）
） 
因为 WMI 应用程序是通过 WMI 组件的代理（proxy）来访问进程外的 WMI 服务的，
所 以 应 该 设 置 合 适 的 认 证 信 息 供 代 理 进 行 RPC 调 用 时 使 用 。 这 可 以 通 过 调 用
CoSetProxyBlanket API 来完成。 
    hres = CoSetProxyBlanket( 
        pSvc,                            
// Indicates the proxy to set 
        RPC_C_AUTHN_WINNT,            
// RPC_C_AUTHN_xxx  