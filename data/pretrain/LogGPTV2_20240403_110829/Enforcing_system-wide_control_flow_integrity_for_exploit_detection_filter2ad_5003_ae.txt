### 动态污点分析
动态污点分析 [24, 39, 13] 是一种技术，其中输入数据被标记为“受污染”，并在内存中进行跟踪，以确保它们不会进入安全关键的数据结构。PVE 组件依赖于内核数据的完整性来保证在客户机内核中感知到的事件的正确性。由于 PVE 组件直接从客户机操作系统的内核数据结构中获取数据，因此篡改内核数据的攻击将误导 Total-CFI。

此外，非控制流侧信道攻击、物理攻击以及针对虚拟机监控器（VMM）的攻击也不在 Total-CFI 的保护范围内。过去已经证明了对 VMM 的攻击 [4]。

### 白名单中的漏洞
Total-CFI 将白名单中的条目视为间接分支操作的合法条目。因此，所有函数入口点（如 libc 函数）都属于白名单。这给攻击者提供了机会，使他们可以构造一个攻击，使得跳转/调用的目标位于白名单内。目前，Total-CFI 对这种跳转或调用至 libc 类型的攻击是脆弱的。需要注意的是，返回至 libc 的攻击会被 Total-CFI 捕获，因为其违反了影子调用栈的规则。

### 硬件集成
虽然在硬件层面实施 CFI 可以提供更好的性能和更严格的安全性，但低性能开销是功能在硬件上实现的主要要求。每个加载到内存中的二进制文件平均增加 7.46KB 的开销，允许硬件工程师为白名单缓存分配特定数量的内存（例如 8MB 或 16MB）。这使得系统级 CFI 实施在硬件上变得可行。CFIMon [36] 已经在这方面做出了努力。尽管 CFIMon 使用 CPU 中的性能计数器来辅助 CFI 实施，实际的 CFI 实施仍然发生在软件模块中。

通过直接访问客户机 CPU 和内存，可以实现核心功能，但需要客户机操作系统数据结构来重构客户机语义视图。可以设计一个系统，其中 PVE 组件和 CFIC 嵌入到客户机 CPU 中，并且用于 CFI 实施的模块白名单由特权内核模块检索并共享给 CPU。我们计划在未来的研究中探索这一方向。

### 相关工作
#### 漏洞检测与测试
已有许多工作 [21, 7, 32, 20] 通过静态分析或动态分析（或两者结合）发现二进制文件中的漏洞。从根本上说，我们的目标是动态识别特定漏洞何时被利用，而不是检测漏洞本身。然而，一旦检测到漏洞利用，Total-CFI 可以帮助分析漏洞利用并识别被利用的漏洞。

#### 漏洞利用诊断
漏洞利用诊断和缓解在过去吸引了许多研究工作 [40, 27, 30, 11, 14]。PointerScope [40] 定义了控制和数据类型，并执行指令级别的类型传播来识别类型误用，这通常是漏洞利用期间的情况。然而，PointerScope 存在严重的性能开销问题。另一方面，基于污点的方法 [27, 30, 39] 容易出现欠污点和过污点问题，导致误报。

#### 程序完整性模型
控制流完整性只是众多程序完整性模型之一，例如数据流完整性、软件故障隔离等。Abadi 等人 [2] 强调并形式化了二进制程序中的控制流完整性。他们在程序执行过程中通过嵌入 CFI 检查（以内联引用监视器的形式）来实施 CFI。

类似地，WIT [3] 使用指针分析在编译时识别程序可以写入的对象，并防止程序写入其他对象。[2, 3] 方法都依赖于程序源代码，而源代码并不总是可用的。Kiriansky 等人 [25] 提出了 Program Shepherding，其中根据控制转移的来源和目标限制控制流。他们的解决方案没有解决整个系统的 CFI 实施问题。

Davi 等人 [16] 在 ARM 上引入了 CFI。他们结合静态分析和动态二进制重写来适度控制流。另一方面，CFIMon [36] 使用硬件性能计数器来识别控制流违规。在离线模式下，它收集每个分支指令的合法目标地址；在线模式下，它收集并分析来自分支计数器的跟踪，并使用启发式方法来识别控制流违规。尽管它依赖于硬件进行跟踪收集，但实际的实施仍在软件中进行。一些先前的努力还使用了重定位表和导出地址表来验证间接跳转目标的合法性。HookScout [38] 跟踪内核中的函数指针并自动生成钩子检测策略。最近，FPGate [35] 从重定位表和导出表中检索间接代码目标列表，并进行二进制重写以验证间接跳转/调用目标，防止控制流劫持攻击。

为了应对数据攻击，DFI [8] 首先通过静态分析捕获合法的数据流（以数据流图的形式），然后确保运行时的数据流满足计算出的图。

软件故障隔离 [33] 专注于在一个地址空间内基于软件的不信任模块隔离。他们修改不受信任的二进制文件，防止其分支到或更改分配给它的内存区域之外的内存。这样，不受信任的模块无法利用其他模块。尽管这种解决方案对单个模块是可行的，但对系统范围的监控是不可行的。

#### 虚拟机内省
虚拟机内省通常需要解释客户机操作系统内核的低级位和字节，以获得高级语义状态。这是一个非平凡的任务，因为存在语义差距 [10]。Garfinkel 和 Rosenblum [19] 在入侵检测中引入了 VMI，Jiang 等人在恶意软件检测中使用了 VMI [23]。早期的方法（例如 [29, 23, 5, 39]）结合手动努力和在客户机操作系统中安装钩子来定位客户机操作系统中的内核对象。最近的进展大大自动化了这一过程 [17, 18]。在我们的工作中，我们直接从 CPU 识别进程、线程和模块等操作系统实体。我们还尽量减少对客户机内存的访问，以提高性能，并设计了一种新的线程堆栈识别算法以满足性能要求。

OS-Sommelier [22] 采用仅内存的方法来指纹识别云中的客户机操作系统。它识别内核代码并计算哈希值以指纹识别操作系统。尽管这种方法适用于不同的操作系统，但它更适合于内存取证而不是及时的操作系统视图提取。

### 结论
本文介绍了 Total-CFI，这是一种系统级 CFI 实施的概念验证实现。为了实现系统级 CFI，我们进行了 Punctual Guest OS View Extraction 并引入了一种新颖的 Thread Stack Layout Identification 算法，以便及时从客户机中收集语义信息。我们评估了 Total-CFI，发现没有误报和漏报。我们发现每个加载模块的内存开销为 7.46KB，执行开销为 64.1%，使其适合与硬件集成。

### 致谢
我们要感谢匿名审稿人的评论，特别是我们的指导者 Lenx Wei，他帮助我们解决了这些审稿人的关切。我们还要感谢雪城大学的硕士生 Shengming Xu 和 Haoru Zhao 对 Total-CFI 的评估帮助。这项研究得到了 McAfee Inc.、NSF 授予 #1018217、#1054605 以及新加坡教育部授予 R-252-000-460-112 的部分支持。表达的观点、发现、结论或建议仅代表作者个人观点，不一定代表资助机构的意见。

### 参考文献
[此处列出参考文献]

通过这种方式优化后的文本更加清晰、连贯和专业，同时也保持了原文的核心内容和结构。