title:Enforcing system-wide control flow integrity for exploit detection
and diagnosis
author:Aravind Prakash and
Heng Yin and
Zhenkai Liang
Enforcing System-Wide Control Flow Integrity for Exploit
Detection and Diagnosis
Aravind Prakash
Department of EECS
Syracuse University
PI:EMAIL
Heng Yin
Department of EECS
Syracuse University
PI:EMAIL
Zhenkai Liang
School of Computing
National Univ of Singapore
PI:EMAIL
ABSTRACT
Modern malware like Stuxnet is complex and exploits multi-
ple vulnerabilites in not only the user level processes but also
the OS kernel to compromise a system. A main trait of such
exploits is manipulation of control ﬂow. There is a press-
ing need to diagnose such exploits. Existing solutions that
monitor control ﬂow either have large overhead or high false
positives and false negatives, hence making their deploy-
ment impractical. In this paper, we present Total-CFI, an
eﬃcient and practical tool built on a software emulator, ca-
pable of exploit detection by enforcing system-wide Control
Flow Integrity (CFI). Total-CFI performs punctual guest OS
view reconstruction to identify key guest kernel semantics
like processes, code modules and threads.
It incorporates
a novel thread stack identiﬁcation algorithm that identiﬁes
the stack boundaries for diﬀerent threads in the system. Fur-
thermore, Total-CFI enforces a CFI policy - a combination
of whitelist based and shadow call stack based approaches
to monitor indirect control ﬂows and detect exploits. We
provide a proof-of-concept implementation of Total-CFI on
DECAF, built on top of Qemu. We tested 25 commonly
used programs and 7 recent real world exploits on Windows
OS and found 0 false positives and 0 false negatives respec-
tively. The boot time overhead was found to be no more
than 64.1% and the average memory overhead was found to
be 7.46KB per loaded module, making it feasible for hard-
ware integration.
Categories and Subject Descriptors
D.4.7 [Operating Systems]: Organization and Design; D.4.6
[Operating Systems]: Security and Protection, Invasive
software
Keywords
Exploit Diagnosis, Exploit Detection, Virtual Machine In-
trospection, Vulnerability Detection, Software Security
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIA CCS’13, May 8–10, 2013, Hangzhou, China.
Copyright 2013 ACM 978-1-4503-1767-2/13/05 ...$15.00.
1.
INTRODUCTION
Software exploiting attacks have become increasingly so-
phisticated in the past few years, due to the wide deployment
of various defense mechanisms (e.g., Non-Executable bit and
Address Space Layout Randomization). As an infamous ex-
ample, Stuxnet exploits multiple zero-day vulnerabilities to
successfully circumvent the existing defense mechanisms and
inﬁltrate into the victim computers [28]. Therefore, there
is a pressing need to eﬀectively detect and analyze newly
emerging exploit attacks.
Unfortunately, previous research eﬀorts on exploit detec-
tion and diagnosis either fall short in precision or incur pro-
hibitive performance overhead. Many prior exploit detec-
tion eﬀorts only detect single-stage exploit attacks, thus fall
short in analyzing sophisticated multi-stage attacks (e.g.,
Stuxnet [28]). To detect and analyze multi-stage exploit
attacks, PointerScope [40] takes a type inference approach.
It detects pointer misuses as key attack steps by inferring
pointer and non-pointer types through dynamic binary ex-
ecution. Although PointerScope has demonstrated to be a
feasible approach, it has two major limitations: 1) since it
performs type inference on an instruction trace, its analysis
overhead is prohibitively high and traces can be very large;
and 2) as type conﬂicts often appear in benign program ex-
ecution, PointerScope has considerable number of special
cases to handle.
In this paper, we aim to provide an accurate and eﬃcient
solution to the problem of exploit detection and analysis.
Such a solution should be accurate and have close to zero
false positive and false negative. It should also be eﬃcient
to keep up with highly interactive and computation inten-
sive program execution. To achieve these design goals, we
leverage control ﬂow integrity (CFI [2]). The notion of CFI
dictates that normal program execution should follow its
control ﬂow graph, which can be statically determined at
compilation time. It is widely accepted that the majority
of software exploit attacks (e.g., buﬀer overﬂow, return-to-
libc, ROP, use-after-free, etc.) violate this inherent program
property.
However, there are several key challenges to enforce CFI
in practice. (1) First of all, CFI requires a complete control-
ﬂow graph (CFG), which is computed from source code of
the whole program (including the main executable and the
shared libraries). In practice, we do not have access to the
source code of all these program components. (2) Moreover,
prior CFI enforcement eﬀorts primarily focus on monitoring
a single user-level process, however we often do not know the
vulnerable process or worse, processes that are exploited in
311a target system. System wide enforcement of CFI in the
operating system kernel has not received suﬃcient investi-
gation. As a result, kernel exploit detection and diagnosis is
still missing. Also, practical CFI enforcement needs to prop-
erly handle various special cases, such as dynamically gen-
erated code, setjmp/longjmp, user-level thread (or Fiber),
etc. Additionally, to be considered as a candidate for CFI
enforcement in the hardware, the system must not only be
robust but also provide strong performance guarantees.
In this paper, we present the design and implementation
of Total-CFI, which detects and provides a strong basis for
analyzing exploits by enforcing CFI for system-wide binary
execution. Total-CFI overcomes the ﬁrst challenge by com-
puting a conservative but complete CFG directly from bi-
nary code modules. Built on top of a CPU emulator, Total-
CFI monitors and validates every indirect control transi-
tion of the whole-system execution, thus addressing the sec-
ond challenge. Total-CFI also carefully copes with various
extraordinary control transfers to minimize false positives.
Furthermore, it leverages the hardware CR3 register to iden-
tify processes.
It introduces a novel algorithm to identify
thread stack layout by directly referring to the ESP register
in the CPU. Total-CFI relies directly on the hardware to
infer several key pieces of information required in CFI en-
forcement therefore making it viable to integrate Total-CFI
into the hardware.
To evaluate the eﬃcacy and performance of Total-CFI,
we have implemented it as a proof-of-concept plug-in on top
of DECAF [1, 37] in 3.7K lines of C code. We evaluated
Total-CFI in terms of accuracy in identifying the exploits
and in terms of performance overhead introduced on the sys-
tem. We performed experiments on 25 popular and widely
used programs on Windows XP and Windows 7 and found
0 false positives, while we were able to successfully identify
8 real world exploits including 1 kernel exploit, with 0 false
negatives. In terms of performance, Total-CFI introduced
boot time overhead of up to 64.1%. Moreover, we found
that on an average, Total-CFI requires 7.46KB of space per
module that is loaded in the guest OS. Such an acceptable
overhead allows for integration of Total-CFI into the hard-
ware. Furthermore, we ran Total-CFI on Pass Mark CPU
and memory benchmark. We report a CPU benchmark over-
head of 4.4% and a memory benchmark overhead of 19.8%
over Qemu [6], further supporting the possibility of integra-
tion into the hardware.
In summary, this paper makes the following contributions:
• We propose to enforce system-wide CFI to detect and
analyze exploit attacks.
• We manage to overcome several key challenges that
hinder CFI enforcement in practice.
• We propose Punctual OS View Extraction to extract
guest OS semantics in a timely manner.
• We propose a novel hardware based thread identiﬁca-
tion algorithm to identify the threads in the guest OS.
• We design and implement a prototype Total-CFI as a
plugin for DECAF, and demonstrate its eﬀectiveness
and eﬃciency.
In Section 2 we provide some insights into Stuxnet, a com-
plex malware and derive the design goals for Total-CFI. In
Section 2 we also provide the high level architecture of Total-
CFI. In Section 3 and Section 4 we discuss the internals of
the PVE component and the CFI component of Total-CFI.
We present the evaluation results in Section 5 followed by
related work in Section 7. Finally, we conclude with Sec-
tion 8.
2. PROBLEM MOTIVATION AND SOLUTION
OVERVIEW
Modern attacks are complex [28] and involve multiple ex-
ploits. To be able to successfully diagnose the multiple ex-
ploits involved, it is necessary to have robust and reliable
CFI enforcement which can capture cross-process control
ﬂow violations.
In this section, we motivate the problem
by ﬁrst providing some insights into a complex malware -
Stuxnet1 then, we highlight some concerns in existing CFI
techniques that make them unsuitable to detect state-of-the-
art malware. Finally, we derive some design goals to address
the challenges in system-wide CFI.
Stuxnet is a malware that targets SCADA systems run-
ning Siemens SIMATIC WinCC or Siemens SIMATIC Step
7, where SCADA in general refers to computer systems that
monitor and control industrial processes.
In a typical in-
fection scenario, the malware enters a network through an
infected usb drive and then spreads to diﬀerent systems in
the network via open network shares. The malware includes
a rootkit component that not only hides itself but also en-
ables the infected system to be remotely controlled by an
attacker. In summary Stuxnet:
1. Exploits the Microsoft Windows Shortcut LNK/PIF
Files Automatic File Execution Vulnerability (MS10-
046) to load a DLL into memory.
2. Exploits the Microsoft Windows Print Spooler Service
Remote Code Execution Vulnerability (MS10-061) to
spread to other vulnerable systems on the LAN.
3. Exploits the vulnerability in Microsoft Windows Share
Service (MS08-067) to spread through the Share Ser-
vice to all the shared drives on the network.
4. Exploits the undocumented Keyboard Layout File re-
lated vulnerability (or an undocumented vulnerability
in Task Scheduler) to escalate privilege and install a
rootkit.
It is worth noting that Stuxnet is system centric as opposed
to application centric. Modern malware exploit multiple vul-
nerabilities in one or more services/processes and they often
involve a rootkit component that is installed in the kernel.
Most previous eﬀorts are incapable of detecting exploits in-
volving multiple processes/services. Existing solutions ei-
ther focus on identifying if a given process has been exploited
or not [40], or they focus on hardening any given process to
prevent it from being exploited [2]. Knowing what processes
to monitor is a requirement for current exploit diagnosis so-
lutions. Scaling such solutions to monitor the entire system
imposes severe performance overhead hence making them
impractical. We can derive the following requirements for
1Here, we consider Stuxnet only as a representative. Mal-
ware such as Flamer, Gauss, etc. that followed Stuxnet are
equally complex and involve exploiting multiple vulnerabil-
ities spanning across multiple processes.
312an exploit diagnosis engine to be able to cope with the state-
of-the-art and emerging malware. Exploit diagnosis should:
1. Be system wide - to capture exploits involving multiple
processes and the OS kernel.
2. Be practical for deployment with reasonable overhead.
3. Have close to zero false positives and false negatives.
Total-CFI is built with the above design goals in mind. As
a proof-of-concept, we leverage the environment provided
by software emulation to perform whole system monitoring.
In the following section, we provide the high level details of
Total-CFI. Then, we present the technical details and design
choices behind the core components of Total-CFI.
2.1 Solution Overview
Total-CFI leverages full system emulation to monitor the
guest operating system from its inception. The overview of
Total-CFI can be found in Figure 1. At a high level, Total-
CFI consists of 2 components, CFI-enforCement (CFIC)
and Punctual OS View Extraction (PVE).
OS view extraction. The PVE component extracts se-
mantic information such as kernel objects from the guest,
captures events in the guest OS which are pertinent to CFI
enforcement, and supports opcode-speciﬁc interception of
guest OS execution. Here, we refer to events such as pro-
cess start, process exit, thread start and module load as
pertinent events, since such information is required in CFI
enforcement. Precise and timely identiﬁcation of such events
is crucial in order to ensure that there is no diﬀerence be-
tween the time the event actually occurs and the time the
semantic values are used by Total-CFI. Timing diﬀerences
lead to inaccurate assessment of exploit location and con-
text. Though it is possible to identify pertinent events by
installing hooks in the guest OS, such an approach is un-
suitable for system-wide CFI. Firstly, hooks are not scalable
across diﬀerent OSs since an expert will have to manually
identify the precise hooking points for each supported OS.
Secondly, hooks installed in the guest OS are prone to mod-
iﬁcation by a compromised kernel. Finally, capturing the
pertinent events directly at the hardware is closer to the
actual time of the event occurring as opposed to hooking.
At a high level, PVE component ﬁrst identiﬁes the guest
kernel load address and the global data structures. This
is important since most data structures in the kernel are
traversable from global data structures [26]. Then, PVE
component installs hooks in the VMM to intercept execution
whenever a new entry is added into the code cache of the
TLB in the CPU. By keeping track of the new entries to code
cache of the TLB, PVE component infers if a new module
has started.
Similarly, by checking for new entries in the CR3 register,
PVE component detects new processes, and by checking the
process list at regular intervals, it detects if a process is
active or has exited. PVE component also incorporates a
novel technique that instruments the VMM to intercept the
guest OS execution when instructions with speciﬁc opcodes
are encountered. This feature of PVE component is used by
CFIC to enforce control ﬂow integrity. Furthermore, PVE
component retrieves the running thread information by di-
rectly accessing the thread related data structures in the
guest OS. In fact, CFIC maintains a shadow call stack and
requires the currently executing thread information during
every indirect control transfer instruction to verify the con-
trol ﬂow integrity. However, performing such accesses fre-
quently can seriously impair the performance of the system.
PVE component implements a novel Stack Layout Identiﬁ-
cation algorithm to identify the stack layout of the currently
executing thread with minimized access to guest OS’s mem-
ory. More details about the algorithm and PVE component
are provided in Section 3.
CFI enforcement. CFIC acts on the semantic information
and event related information gathered by PVE component
and enforces the CFI model on the executing guest OS. In
a nutshell, CFIC via PVE component intercepts every in-
direct control transfer instruction and every call instruction
executed by the guest OS. CFIC maintains shadow memory
to reﬂect states of processes and threads in the guest OS,
both at the user level and the kernel level. When a call or
an indirect jmp instruction is encountered in a process ad-
dress space, CFIC ensures that the target address belongs to
a pre-determined whitelist. A whitelist for a speciﬁc module
consists of all the statically determinable target addresses for
indirect control ﬂow in the module, such as the elements of
relocation table and the export table. A whitelist for a pro-
cess is a union of all the whitelists of all the modules loaded
in the process address space. When a call instruction is
encountered, the address of the instruction succeeding the
call instruction becomes a valid target for a ret instruc-
tion and is therefore pushed onto the currently executing
thread’s shadow stack. Information regarding the currently
executing thread is obtained from PVE component.
When a ret instruction is encountered, CFIC pops the
target address from the thread’s shadow stack. However, if
the target address is not found on the shadow stack, CFIC
treats the access as a potential exploit and stops execution.
Section 4 details the internals of CFIC.
3. PUNCTUAL OS VIEW EXTRACTION (PVE)
PVE component builds a bottom-up semantic view of the
guest OS from the Virtual Machine Monitor (VMM) and
extracts the kernel data structures and deciphers process,
module and thread related information, which are necessary
to accurately pinpoint the exploit context during CFI en-