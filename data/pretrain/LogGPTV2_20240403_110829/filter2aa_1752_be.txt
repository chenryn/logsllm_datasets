signal (SIGALRM, alarm_handler);
alarm (5);
pause ();
}
10.9.2 间歇定时器
间时调出 4.2BSD  POSIX 
以提 alarm() 更的。
#include 
int getitimer (int which,
struct itimerval *value);
int setitimer (int which,
– 355 –
 10 
时间
const struct itimerval *value,
struct itimerval *ovalue);
间时 alarm() 的操作方式相能自自以
的式工作:
ITIMER REAL
  真 实 时 间。   的 真 实 时 间   内  将
SIGALRM 给进程。
ITIMER VIRTUAL 进程空间的时。的进程时间
内将 SIGVTALRM 给进程。
ITIMER PROF
进程以及内进程时（调
。的时间内将 SIGPROF 
给进程。式 ITIMER VIRTUAL 程
能进程的时间内时间。
ITIMER REAL 的时间 alarm() 相同式对程
。
itimeval 时或的时设
时:
struct itimerval {
struct timeval it_interval; /* next value */
struct timeval it_value; /* current value */
};
以提的 timeval 
struct timeval {
long tv_sec; /* seconds */
long tv_usec; /* microseconds */
};
settimer() 设时间 it value 的时。时超 it value内
 it interval 的时时。 it value  0 时时间间
设 it interval。时效 it interval  0 时。
的时的 it value 设 0时
。
– 356 –
 10 
时间
 ovalue  NULL which 的间时的。
getitimer()  which 的间时的。
时 0出时 -1设 errno 
EFAULT value 或 ovalue 。
EINVAL which 的间时。
的段 SIGALRM 处理程（将
间时的时间设 5 的时间 1 。
void alarm_handler (int signo)
{
printf (”Timer hit!\n”);
}
void foo (void) {
struct itimerval delay;
int ret;
signal (SIGALRM, alarm_handler);
delay.it_value.tv_sec = 5;
delay.it_value.tv_usec = 0;
delay.it_interval.tv_sec = 1;
delay.it_interval.tv_usec = 0;
ret = setitimer (ITIMER_REAL, &delay, NULL);
if (ret) {
perror (”setitimer”);
return;
}
pause ( );
}
– 357 –
 10 
时间
 Unix  SIGALRM 实 sleep()  usleep()。然 alarm()
 setitimer()  SIGALRM。程小调
。调的的。的程
 nanosleep() POSIX  nanosleep() 能。
时程 setitimer() 或 alarm()。
10.9.3 高级定时器
的时自 POSIX 的时。
POSIX 时的时实、以及时
 timer create() 时 timer settime() 时
timer delete() 。
POSIX 的时进的新
的（性同时的。
或性 setitimer() 更的。
10.9.3.1 建立一个定时器
 timer create() 时
#include 
#include 
int timer_create (clockid_t clockid,
struct sigevent *evp,
timer_t *timerid);
调 timer create()  POSIX 时 clockid 相的新时
 timerid 存的时 0。调设
时的件将的时
。
的子 POSIX 时 CLOCK PROCESS CPUTIME ID 上新
的时将时 ID 存 timer 。
timer_t timer;
int ret;
– 358 –
 10 
时间
ret = timer_create (CLOCK_PROCESS_CPUTIME_ID,
NULL,
&timer);
if (ret)
perror (”timer_create”);
时调 -1 timerid 调设 errno 
EAGAIN
的。
EINVAL
clockid 的 POSIX 时的。
ENOTSUP clockid 的 POSIX 时时作
时。 POSIX 实 CLOCK REALTIME 时作
时。的时同实。
evp  ( NULL 件) 时时的异步。文件
 。的内对程的以
段
#include 
struct sigevent {
union sigval sigev_value;
int sigev_signo;
int sigev_notify;
void (*sigev_notify_function)(union sigval);
pthread_attr_t *sigev_notify_attributes;
};
union sigval {
int sival_int;
void *sival_ptr;
};
时的 POSIX 时时内何进程的上
更的能进程内将的内
– 359 –
 10 
时间
新程时时的能。进程时时的
sigev notify 以
SIGEV NONE
空的。时时。
SIGEV SIGNAL
时时内给进程 sigev signo 的
。处理程 si value 设 sigev value。
SIGEV THREAD 时时内新程（进程内
 sigev notify function将 sigev value 的
。程时。 sigev notify attributes
 NULL pthread attr t 新程的。
的子的 evp  NULL时的将
设:sigev notify  SIGEV SIGNAL sigev signo  SIGALRM sigev value 
时的 ID。时以 POSIX 间时的方式进
。然自方式以更的工作
的子 CLOCK REALTIME 的时。时
时内出 SIGUSR1  si value 设存时 ID 的
struct sigevent evp;
timer_t timer;
int ret;
evp.sigev_value.sival_ptr = &timer;
evp.sigev_notify = SIGEV_SIGNAL;
evp.sigev_signo = SIGUSR1;
ret = timer_create (CLOCK_REALTIME,
&evp,
&timer);
if (ret)
perror (”timer_create”);
10.9.4 设置定时器
 timer create() 的时设的。以 timer settime() 将
时间时
– 360 –
 10 
时间
#include 
int timer_settime (timer_t timerid,
int flags,
const struct itimerspec *value,
struct itimerspec *ovalue);
  调  timer settime() 将 设  timerid   的  时  的   时 间 
value,value  timerspec 
struct itimerspec {
struct timespec it_interval; /* next value */
struct timespec it_value; /* current value */
};
 setitimer()  it value 时时间。时
时将 it interval 的更新 it value。 it interval  0时间
时 it value 。
提的内 timespec 以提
struct timespec {
time_t tv_sec; /* seconds */
long tv_nsec; /* nanoseconds */
};
 flags  TIMER ABSTIME value 的时间绝对时间（相对
时间的相。的操作以时间、
相对的时间、时间、以及设时时件。
以的方。
 ovalue  NULL时的时间将存 itimerspec 。
时设的将设 0。
 timer  timer create() 的时的
的周时
struct itimerspec ts;
– 361 –
 10 
时间
int ret;
ts.it_interval.tv_sec = 1;
ts.it_interval.tv_nsec = 0;
ts.it_value.tv_sec = 1;
ts.it_value.tv_nsec = 0;
ret = timer_settime (timer, 0, &ts, NULL);
if (ret)
perror (”timer_settime”);
10.9.4.1 取得定时器的过期时间
以何时 timer gettime() 时的时间
新设
#include 
int timer_gettime (timer_t timerid,
struct itimerspec *value);
调 timer gettime() 将 timerid 的时时间存 value 
的 0。时调 -1设 errno 
EFAULT value 。
EINVAL timerid 时。
子
struct itimerspec ts;
int ret;
ret = timer_gettime (timer, &ts);
if (ret)
perror (”timer_gettime”);
else {
– 362 –
 10 
时间
printf (”current sec=%ld nsec=%ld\n”,
ts.it_value.tv_sec, ts.it_value.tv_nsec);
printf (”next sec=%ld nsec=%ld\n”,
ts.it_interval.tv_sec,
ts.it_interval.tv_nsec);
}
10.9.4.2 取得定时器的超时值
POSIX 给时的超时
#include 
int timer_getoverrun (timer_t timerid);
时 timer getoverrun() 时实时 (
) 进程间的时。方我们的子 1 的
时 10 调 9。
  超 时      DELAYTIMER MAX调     DELAY-
TIMER MAX。
时 -1设 errno  EINVAL的
timerid 的时。
子
int ret;
ret = timer_getoverrun (timer);
if (ret == -1)
perror (”timer_getoverrun”);
else if (ret == 0)
printf (”no overrun\n”);
else
printf (”%d overrun(s)\n”, ret);
– 363 –
 10 
时间
10.9.4.3 删除定时器
时单
#include 
int timer_delete (timer_t timerid);
调 timer delete() 将 timerid 的时 0。
时调 -1设 errno  EINVAL的 timerid 
的时。
– 364 –
 A
GCC 对 C 的扩展
附录 A
GCC 对 C 语言的扩展
GCC（GNU 集, GNU Compiler Collection C 提扩
展能的扩展能对程。提的
C 能扩展提的能的
。以更效的。扩展对 C 
的的调方。
新的 C  —ISO C99 GCC 提的扩展能。
扩展能 C99 的扩展能 ISO C99 
同的实。新写的 ISO C99 。我们提
及扩展 GCC 的扩展能。
A.1 GNU C
GCC 的 C  GNU C 。 90  GNU C 
C 的提、零、内、
能。的展 C  ISO C99
GNU C 的扩展新的。然 GNU C 提的性
 Linux 程 C90 或 C99 的然 GNU C 的
性（扩展能。
的 GCC 扩展的子 Linux 的内内 GNU
C。 Intel 对 Intel C  (ICC, Intel C Compiler) 进
ICC 能理 (Linux) 内的 GNU C 扩展。扩展
 GCC 。
A.2 内联函数
将内（inline将的段
的调。将存调时
。处理以调的以调进
能的（能将调调进。
的调时时效。然将
– 365 –
 A
GCC 对 C 的扩展
调的方然。小单或
调的时以将内。
GCC  inline  inline 示将进
内。 C99  inline 
static inline int foo (void) { /* ... */ }
上 inline 提示对进内
。 GCC 上提扩展能以将进内
方
static inline __attribute__ ((
always_inline)) int foo (void){ /*...*/
} \right)}
内的的处理（preprocessor macro。 GCC
的内的以进。的
#define max(a,b) ({ a > b ? a : b; })
以以的内
static inline max (int a, int b)
{
if (a > b)
return a;
return b;
}
程内。的 x86 上
调的的。的内。
A.3 禁用内联
式 GCC 自内的对进内
。的处理方式时程能出内
工作。__builtin_return_address 时（
– 366 –
 A
GCC 对 C 的扩展
内能。 noinline 以内
__attribute_ _ ((noinline)) int foo (void) { /* ...
*/ }
A.4 纯函数
何的映的或
（nonvolatile的。对或的读的。对
以进（loop optimization子式（subexpression
elimination。 pure 
__attribute__ ((pure)) int foo (int val) { /*
... */ }
的子 strlen() 。相同的调
的以提出调即。
以
/* 的的写式p */
for (i=0; i < strlen (p); i++)
printf (”%c”, toupper (p[i]));
 strlen() 能调
的程写（将 strlen() 单
处理
size_t len;
len = strlen (p);
for (i=0; i < len; i++)
print (”%c”, toupper (p[i]));
更的程（的读能
while (*p)
– 367 –
 A
GCC 对 C 的扩展
printf (”%c”, toupper (*p++));
的的能 void 
的何的。
A.5 常函数
” ” 更的单。能将
作。的映以的方式进的。
的方式对以进。 abs()
的（进存或的小
作。 const 
__attribute__ ((const)) int foo (void) { /*
... */ }
 void 的。
A.6 不返回的函数
 (调 exit())程以 noreturn 
以
__attribute__ ((noreturn)) void foo (int
val) { /* ... */ }
调的以进的
。的能 void。
A.7 分配内存的函数
内存的∗（以
新的内存新内存的程以将 malloc 
以进的
∗内存或以上的同内存。内存我们
将的给的时内存。然能更的出
内存。的新的内存的同内存
。
– 368 –
 A
GCC 对 C 的扩展
__attribute__ ((malloc)) void * get_page (void)
{
int page_size;
page_size = getpagesize ();
if (page_size <= 0)
return NULL;
return malloc (page_size);
}
A.8 强制调用函数检查返回值
属性warn_unused_result 以示存或
件时能
__attribute__ ((warn_unused_result)) int foo
(void) { /* ... */ }
调的的时处理以程调
处理。 read() 的然
时warn_unused_result 属性。能
void。
A.9 将函数标记为 deprecated
deprecated 属性示调时