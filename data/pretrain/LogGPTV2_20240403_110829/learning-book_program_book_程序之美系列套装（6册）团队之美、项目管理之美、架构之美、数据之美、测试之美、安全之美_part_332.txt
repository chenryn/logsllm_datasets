版本编号每个版本的缺陷数量逃逸的缺陷
分析测试逃逸
TCE值（加权和未加权）
版本110
总共16个缺陷：
5个逃逸的缺陷：
不完整的测试用例TCE（加权）=63%
3个P2缺陷
1个P2缺陷
没有测试用例
TCE（未加权）=69%
8个P3缺陷
4个P3缺陷
测试执行问题
5个P4缺陷
版本111
总共20个缺陷：
2个逃逸的缺陷：
测试执行问题
TCE（加权）=92%
1个P2缺陷
1个P3缺陷
没有测试用例
TCE（未加权）=90%
7个P3缺陷
1个P5缺陷
11个P4缺陷
1个P5缺陷
版本112
总共8个缺陷：
1个逃逸的缺陷：
没有测试用例
TCE（加权）=83%
2个P2缺陷
1个P2缺陷
TCE（未加权）=87%
4个P3缺陷
2个P4缺陷
根据上表，版本108到版本112的TCE图形的趋势如图6-9所示。
测试用例有效性趋势
0.9
权
0.8
米
0.7
和TCE
0.6
0.5
0.4
号
0.3
0.2
0.1
0+
Build108
Build 109
Build 110
Build 111
Build 112
OpenSolaris DevelopmentBuild ID
■TCE（加权）·TCE（未加权）
图
6-9
测试用例有效性趋势
1895
---
## Page 1897
在图中，版本110的TCE值与其他版本相比略低。因此我们的目标就
是要通过分析版本110的每个逃逸的缺陷，以提高测试用例的有效
性。
总共有16个缺陷被提交：11个缺陷由QA在测试周期中发现，5个逃
逸的缺陷。缺陷6962——"6962P3normalgnome-terminalcannot
rememberSPWDwhenopenanewtab”（普通gnome终端在打开一个新
的标签页时无法记忆SPWD值）是一个典型的逃逸的缺陷，所以我们
就将它作为例子来审查。
该缺陷是由非QA团队的人在正式QA测试流程之外报告的。因此，
我们将它列为“逃逸的缺陷”。
在分析这个逃逸缺陷根源的过程中，我们审查了GNOM企测试用例
集，发现现有的测试用例都无法覆盖该缺陷。所以，测试逃逸原因
是“没有测试用例”，因为该缺陷是在测试周期结束以后在随意测试
(ad-hoctesting）中发现的。
纠止行动
在缺陷6962的例子中，纠正行动是审查GNOME终端的测试用例，以
及基于导致缺陷的功能设计新的测试用例。
这一纠正行动带来的结果是新的测试用例和对现有测试用例的修
改。
这里我们介绍了一个跨5个连续的版本分析缺陷的例子。我们的目标
是不断跟踪TCE的趋势图形。TCE方法旨在让QA团队在产品发布之
前更好地了解测试用例的有效性。通过这种方法，QA团队可以判断
出测试用例的问题并在该系统发布之前纠正测试流程。
结论
在这一章中，我们介绍了如何管理缺陷和衡量测试用例的有效性。
我们以基本概念开始，并解释了我们如何在OpenSolaris平台上实现
了这些概念。这些都是我们实际工作项目中真实的故事。我们将继
续在这些项目上工作，并在OpenSolaris的每个发布周期中改进工作
流程。我们推荐的技术可以应用到任何项目测试管理模式中。我们
1896
---
## Page 1898
希望你会发现这种方法比常用的偶然质量保证方法更加美好、简单
和准确。
[1] http://defect.opensolaris.org/bz/show_bug.cgi?id=6962
致谢
我们感谢DerekRafter为在OpenSolaris中引入TCE方法所做出的巨大
努力。感谢NigelSimpson对本章详细的审阅和评论。
参考文献
Chernak,Y.2001."Validating and Improving Test-Case Effectiveness." IEEE
Software,18(1):81-86
Kidwell,P.A.1998."Stalking the Elusive Computer Bug." Annals of the
History of Computing,20:5-9.
McPhee,N."Therac-25 accidents,"
http://www.morris.umn.edu/~mcphee/Courses/Readings/Therac_25_accid
ents.html.
Smithsonian National Museum of American History."Log Book With
key=35&objkey=30.
Tzu,Sun.The Art of War.Trans.Lionel
Giles.http:/www.gutenberg.org/etext/132
第7章漂亮的XMPP测试
Remko Troncon
我第一次工作面试的时候，一位面试官问我是否知道并使用过“单元
测试”。尽管我已经从事一款基于XMPP的即时通信（IM）客户端软
件的并发工作很多年了，但是不得不承认，我只是很粗浅地了解单
元测试，并没有写过任何自动测试程序。不过我有自己的理由。既
然XMPP客户端处理的都是关于XML数据、网络，以及用户交互的
工作，它们就不需要任何形式的自动测试。面试几个月以后，我在
1897
---
## Page 1899
一个敏捷环境中工作的经验告诉我，这个理由是多么的牵强。我只
花了几个月的时间就发现了测试代码的漂亮之处，特别是对于像
XMPP这样的环境，它完全出乎你的预料。
简介
可扩展消息处理现场协议（eXtensibleMessagingandPresence
Protocol,XMPP）是一个开放的、基于XML的网络协议，用于即时通
信。十年前诞生的时候，XMPP仅是Jabber里面用来进行即时通信的
方法。今天，它广泛存在于各种各样的网络应用中，并且很多已经
超出了即时通信的范畴。这些应用包括社交网络、多媒体交互（如
语音和视频）、微博、游戏等。
在这一章中，我会试着与大家分享我在XMIPP世界（特别是Swif即
时通信软件）里测试的热情。Swif只是众多XMPP应用中的一种，
或许并不是唯一一个使用这里所描述的测试方法的软件。但是，它
或许是测试得最漂亮的客户端软件。
那么，什么才是“漂亮的测试"呢？现在你可能已经发现，人们对这
个问题看法迥异。就我的观点来看，作为一个软件开发人员，测试
之美就是这些测试背后的代码之美。自然地，漂亮的测试从美学观
点上看也是漂亮的，所以布局也很重要。不过，我们都知道真正的
美源自内在。测试之美在于简约：测试之美在于一看代码就能理解
它（以及被测试的系统）做了些什么，即使我们对于被测的类别或
组件知之甚少；测试之美在于健壮，不需要跟着产品的变化而大幅
修改：测试之美在于阅读和编写测试都是一件快乐的事情。
正如你的预期，本章会有很多代码。既然我从Swif得到了启发，而
Swif文是用C++写的，所以本章的所有例子也会使用C++。使用诸如
Ruby或者Python这样的语言也许会让测试看起来更吸引人，但是我还
是坚持我的看法一—测试的真正之美远在其外表之下。
XMPP101
在对XMPP执行测试细节深入了解之前，让我们首先快速认识一下
XMPP是如何工作的。
XMPP网络由一系列相互连接的服务器构成，服务器上连接有客户
机，如图7-1所示。XMPP的工作就是网络的实体间寻路并传输这些
1898
---
## Page 1900
小的XML“分组”。例如，Alice连接到wonderland.lit服务器上，她想
给连接到realworld.lit服务器上的妹妹发送一条消息。她把她的消息
放到了下面这个XML代码片段中：
Hi there
接着，Alice把这个消息发送给她的服务器，她的服务器把消息转发
到realworld.lit服务器，然后这个服务器把消息送到了她妹妹的客户
端软件。
XMPP网络的每个实体都使用JabberID(JID)来寻址。JID的形式是
username@domain/resource，其中domain是XMPP服务器的域名，
username标识了这个服务器上的一个账号。一个用户可以通过客户机
的多个实例来与服务器连接；JID的resource部分为每一个相连的实
例提供了一个唯一的名字。在某些情况下，也可以没有resource部
分，这意味着服务器可以把消息投递给它最信任的一个实例。
网络中传输的这些小的XML分组称为"节”（Stanzas），分为三类：
message节、presence节和info/query节。服务器用不同的方式传输不
同类型的节，客户端软件也用不同的方式处理它们。
1899
---
## Page 1901
Alice
Rabbit
wonderland.1it
服务器