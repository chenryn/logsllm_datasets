turns a computational soundness result for the sealing-based
library. The advantage of this result is that programs using
σS can be analyzed using the F7 type-checker, since the li-
brary itself is type-checked with polymorphic typing anno-
tations1.
Note that this part of our paper is speciﬁc to the case of
encryptions and signatures. We believe, however, that the
proof can be easily extended to other primitives on a case-by-
case basis. Furthermore our proof also gives an additional
justiﬁcation to the approach of seals: We reduce security
with respect to seals to security with respect to a term-based
abstraction that is considerably simpler because it does not
rely on a shared state.
Restrictions. We brieﬂy discuss the limitations of our re-
sult and explain why they are present.
Security properties. We only consider safety properties
(described by authorization policies) that are eﬃciently de-
cidable (in the sense that for any given trace, it is eﬃciently
decidable whether the safety property is fulﬁlled). Both the
restriction to safety properties (as opposed to liveness prop-
erties) and the restriction to eﬃciently decidable properties2
are state of the art in computational soundness results. Com-
putational soundness results for properties based on obser-
vational equivalence exist [24]; applying these to RCF would
constitute an interesting extension to our work.
Protocol conditions. We impose certain conditions on our
protocols. Most prominently, we forbid to encrypt or send
secret keys. (As a side eﬀect, this also avoids so-called key-
cycles.) Again, these conditions are state of the art in com-
putational soundness results, and, if removed there, they can
also be removed from our result.
Authorization policies. Constructors that represent cryp-
tographic operations (such as encryptions) may not occur
in the formulae used to express authorization properties.
This is due to the fact that a statement such as ∃xyz.c =
enc(x, y, z) does not have a sensible computational interpre-
tation (there is no eﬃcient way to check it). Since our treat-
ment is generic, also constructors that represent “harmless”
primitives such as pairs are excluded from authorization poli-
cies; allowing them should be possible but would consider-
ably complicate our treatment. We believe, however, that
disallowing these constructors in authorization policies does
not constitute a big restriction. In most cases, an authoriza-
tion policy will deﬁne high-level rules (such as “if P has paid
for x, then P may download x”). Statements about the ac-
tual format of messages (e.g., “m is a pair”) will only be used
during the symbolic veriﬁcation of the high-level properties,
e.g., as part of a reﬁnement type. We do not impose any re-
strictions on the symbolic veriﬁcation techniques; arbitrary
formulae can be used there as long as they do not appear in
the ﬁnal authorization policy.
Network channels. We assume that there is only a single
public network channel (i.e., only a single channel to the
adversary). This is done for simplicity only, our results could
be easily extended to a setting with more channels. Or, one
might emulate several channels by adding a header to all
messages sent over the public channel.
Assumptions and assertions in libraries. One is not al-
1The F# code of the library with typing annotations is avail-
able at [8].
2By eﬃciently decidable properties, we do not mean that
it can be eﬃciently decided whether a protocol guarantees
that the property is satisﬁed, we only mean that it can be
eﬃciently decided whether in a given execution, the property
was satisﬁed.
389lowed to add assumptions and assertions (i.e., authorization
policies) in the code of the symbolic libraries themselves.
This is, however, not really a restriction since one may use a
wrapper library that adds these assumptions and assertions.
Alternative approaches. We brieﬂy discuss several possi-
ble alternatives to our approach and explain their diﬃculties.
Using CryptoVerif. Instead of doing a symbolic security
veriﬁcation and then applying a computational soundness
result, one could perform the analysis directly in the compu-
tational setting using a tool such as CryptoVerif [21]. Cryp-
toVerif is a tool that performs a security analysis directly
in the computational model. To follow this approach in our
setting, one would have to describe an encoding of RCF into
CryptoVerif’s calculus. Although this can easily be done for
a fragment of RCF, many features of RCF such as recursion,
authorization policies in ﬁrst-order logic, and concurrency3
are probably beyond what CryptoVerif can handle. Also,
CryptoVerif’s approach probably does not scale well to com-
plex programs. Finally, one needs to prove that the encod-
ing of RCF into CryptoVerif preserves all required security
properties; such a proof might be not much simpler than the
proofs in the present paper. [19] pursue this approach; they
do not, however, prove their encoding sound.
Reducing to the applied π-calculus. An alternative ap-
proach to obtain computational soundness would be to em-
bed F# into the applied pi-calculus and to exploit the com-
putational soundness result for the applied pi-calculus estab-
lished in [7]. However, establishing this embedding would
arguably not be easier than our approach: it requires to en-
code datastructures, recursion, the sealing mechanism, and
assertions/assumptions into the applied pi-calculus, includ-
ing the whole FOL/F logic. Moreover, the correctness of
the encoding has to be proven twice – once symbolically
(the proof would follow the same lines as the proof in [17])
and once with respect to the computational semantics.
Removing equality tests on lambda-expressions. A large
part of the technical diﬃculties in our proofs stem from
the fact that RCF allows to do syntactic equality tests on
lambda-abstractions. It is not, however, easily possible to
remove these tests:
If we change the semantics of RCF,
our results become incompatible with existing tools like the
F7 framework. A syntactic restriction that disallows com-
parisons of lambda-abstractions does not seem to be pos-
sible either; which variables are instantiated with lambda-
abstractions only becomes clear at runtime.
1.2 Related work
The problem of computational soundness was ﬁrst ad-
dressed by Abadi and Rogaway in [5] for passive adversaries
and symmetric encryption. The protocol language and secu-
rity properties handled there were extended in [4, 34, 31, 15,
1], but still apply only to passive adversaries. Subsequent
works studied computational soundness against active at-
tacks (e.g., cf. [13, 11, 12, 10, 41, 35, 38, 32, 7]). Recent
works also focused on computational soundness in the sense
of observational equivalence of cryptographic realizations of
processes (e.g., [6, 24, 23]). All these works do not tackle
the computational soundness of protocol implementations.
Concurrently with the announcement of this work at FCC
3CryptoVerif does support concurrency natively, but its
model of concurrency assumes a uniform random choice in
each scheduling decision which arguably is an unrealistic as-
sumption in most settings.
2009, [27] reported independent work in progress on a type
system for RCF that entails computational soundness.
The analysis of the source code of protocol implementa-
tions has recently received increasing attention. Goubault-
Larrecq and Parrennes developed a static analysis tech-
nique [29] for secrecy properties of cryptographic protocols
implemented in C. Chaki and Datta recently proposed a
technique [22] based on software model checking for the au-
tomated veriﬁcation of secrecy and authentication proper-
ties of protocols implemented in C. The analysis was ap-
plied to the SSL handshake protocol. Bhargavan et al. pro-
posed a technique [17, 19] for the veriﬁcation of F# protocol
implementations by automatically extracting ProVerif mod-
els [20]. The analysis was used to verify implementations of
real-world cryptographic protocols such as TLS [19]. None
of these analysis techniques enjoys computational soundness
guarantees. [19] also proposes an embedding of F# into the
calculus of CryptoVerif. The embedding is not, however,
proven to be sound; also, according to [19], it is diﬃcult to
analyze recursive functions with CryptoVerif.
1.3 Notation
Given a term t, we write t{t′/x} for the result of sub-
stituting all free occurrences of x by t′. We assume that
substitutions are capture avoiding, i.e., bound names are re-
named when necessary. We write t for a list t1, . . . , tn where
the length n of the list is left implicit. Given sets P, C of
logical formulae, we write P ⊢ C iﬀ for all F ∈ C, F is
entailed by P .
2. RCF (REVIEW)
This section outlines the Reﬁned Concurrent FPC [16], a
simple core calculus extending the Fixed Point Calculus [30]
with reﬁnement types and concurrency. Although very sim-
ple, this calculus is expressive enough to encode a large part
of F# [16].
2.1 Syntax and semantics
The set of values is composed of names, variables, unit,
functions, pairs, and type constructors (cf.
Figure 2).
Names are generated at run-time and are only used as chan-
nel identiﬁers, while variables are place-holders for values.
Unit, functions, and pairs are standard. While RCF orig-
inally includes only three type constructors (namely, intro-
duction forms for union and recursive types), we extend the
syntax of the calculus to an arbitrary set of constructors.
sugar:
Conditionals are
encoded using the
following syn-
tactic
and
if M = N then A else B abbreviates match M =
N with inl x then A else B for some fresh x.
true
:= inl(),
false
:= inr(),
An expression represents a concurrent computation that
may reduce to a value, or may diverge. The semantics of
expressions is deﬁned by a structural equivalence relation ≡4
and a reduction relation →. The former enables convenient
rearrangements of expressions, while the latter describes the
semantics of RCF commands.
Values are irreducible. The semantics of function applica-
tions, conditionals, let commands, pair splits, and construc-
4The equivalence relation ≡ considered in this paper is the
extension of the heating relation A ⇛ B proposed in [16]
where all heating rules are made symmetric. In the full ver-
sion [9], we prove that making the heating relation symmet-
ric is sound, i.e., it does not aﬀect the safety of expressions.
390a, b, c
h
name
constructor
M, N ::= value
x, y, z
()
λx.A
(M, N )
h M
variable
unit
function
pair
constructor application
A, B ::=
expression
value
function application
syntactic equality
let
pair split
M
M N
M = N
let x = A in B
let (x, y) = M in A
match M with h x then A else B constructor match
νa.A
A (cid:31) B
a!M
a?
assume F
assert F
restriction
fork
transmission of M on channel a
receive message oﬀ channel
assumption of formula F
assertion of formula F
Figure 2: Syntax of RCF values and expressions
tor matches is standard.
Intuitively, the restriction νa.A
generates a globally fresh channel a that can only be used in
A and the name a is bound in A. The expression A (cid:31) B eval-
uates A and B in parallel, and returns the result of B (the
result of A is discarded). The expression a!M outputs M on
channel a and reduces to the unit value (). The evaluation
of a? blocks until some message M is available on channel
a, removes M from the channel, and then returns M .
The expressions assume F and assert F represent logical
assumptions and assertions for modeling security policies.
The intended meaning is that at any point of the execution,
the assertions are entailed by the assumptions. The formulae
F are speciﬁed in FOL/F [16], a variant of ﬁrst-order logic.
RCF expressions can be transformed by structural equiv-
alence into a normal form, which is called a structure and
consists of a sequence of restrictions followed by a parallel
composition of assumptions, outputs, and lets. These as-
sumptions and the assertions ready to be reduced are called
active.
Intuitively, an expression is safe if all active asser-
tions are entailed by the active assumptions.
Definition 1
(→-safety). A structure S is statically
safe iﬀ P ⊢ C where P are the active assumptions and C
the active assertions of S.
An expression A is →-safe if for all structures S such that
⋄
A →∗ S, we have that S is statically safe.
When reasoning about implementations of cryptographic
protocols, we are interested in the safety of programs ex-
ecuted in parallel with an arbitrary attacker. This property
is called robust safety.
Definition 2
(Opponents and robust →-safety).
An expression O is an opponent if and only if O is closed
and O contains no assertions. A closed expression A is
robustly →-safe if and only if the application O A is →-safe
⋄
for all opponents O.
The notion of robust →-safety is the same as the robust
safety deﬁned in [16]. Robust →-safety can be automatically
veriﬁed using the F7 type checker.
In the following, we will sometimes need to restrict our
attention to programs that only use a certain subset of the
set of all constructors. For this, we assume that the set
of RCF constructors is partitioned into public constructors
and private constructors. Private constructors are usually
used inside a library. Note however, that the semantics
of RCF treats private and public constructors in the same
way. An RCF expression that does not contain private con-
structors (neither in constructor applications nor in pattern-
matches) is called pc-free. We call an RCF-expression
A mpc-free (for match-private-constructor-free) iﬀ pattern
matches against private constructors occur only as subterms
of A that are arguments of private constructors. We call
an RCF-expression pure if it does not contain assumptions,
assertions, outputs (M !N ), inputs (M ?), or forks (M (cid:31) N ).
Furthermore, we call a FOL/F-function symbol forbidden
if it is the function symbol representing an RCF-lambda-
abstraction5 or a private RCF-constructor.
3. COSP FRAMEWORK (REVIEW)
The computational soundness proof developed in this pa-
per follows CoSP [7], a general framework for conducting
computational soundness proofs of symbolic cryptography
and for embedding these proofs into process calculi. CoSP
enables proving computational soundness results in a con-
ceptually modular and generic way: every computational
soundness proof for a cryptographic abstraction phrased in
CoSP automatically holds for all embedded calculi, and the
process of embedding process calculi is conceptually decou-
pled from computational soundness proofs.
CoSP provides a general symbolic model for expressing
cryptographic abstractions. We ﬁrst introduce some central
concepts such as constructors, destructors, and deduction
relations.
Definition 3
(CoSP terms). A constructor f
is a
symbol with a (possibly zero) arity. We write f/n ∈ C to
denote that C contains a constructor f with arity n. A nonce
n is a symbol with zero arity. A message type T over C and
N is a set of terms over constructors C and nonces N. A
destructor d of arity n, written d/n, over a message type T
is a partial map Tn → T. If d is undeﬁned on t1, . . . , tn, we