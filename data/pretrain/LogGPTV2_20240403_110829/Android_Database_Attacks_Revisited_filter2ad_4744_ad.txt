Some of the parameters of the query API have array types.
In practice, reasoning about arrays symbolically is not trivial
and does not scale well. We only focus on the arrays which
are the source method parameters and keep track of their
elements in a separate pool. For the rest of the arrays, we do
not distinguish their elements and only propagate dataﬂow
facts for the base array object.
It is also possible to set all of the parameters of the query
API except the uri to null. If projection is null, all of the
columns and if the selection is null, all of the rows for the
given URI will be returned. If sortOrder is null, results will
return with the default sort order.
In order to perform the dynamic testing, we have created
a malware skeleton app for invoking the APIs of vulnerable
content providers with malicious arguments which are re-
solved from the static analysis. Our malware does not have
any permission granted from the user. Once the vulnerable
content provider is invoked, the validator component logs
the concrete execution trace using the Android debugger
to obtain the concrete values. Using these concrete values,
our analysis attempts to place them in the path constraints
generated by the static symbolic execution to create more
precise inputs if needed.
If the generated inputs do not
change anymore, our malware invokes the vulnerable con-
tent provider and validates the vulnerability using the fol-
lowing sample rules. We assume the openFile() and openAs-
setFile() APIs of a content provider are exploited if they re-
turn non-null ParcelFileDescriptor and AssetFileDescriptor
references respectively. Similarly, the query() API of a con-
tent provider should return a non-null Cursor reference; the
insert() API of a content provider should return a non-null
Uri reference; and the update() API of a content provider
should return a non-zero integer.
Private Database Attacks. The diﬀerence between pri-
vate and public databases is that public databases are ac-
cessed through content providers, while private databases
are accessed via Intent messages received by any of the
following components: activities, services or broadcast re-
ceivers. An input string obtained from an Intent which trig-
gers paths down to the SQLiteDatabase methods may allow
attackers to manipulate the database and compromise the
security of the app.
In order to trigger and validate the
private database attacks, the attacker should generate In-
tents which target the vulnerable component of the victim
app. For this purpose, the values generated by the symbolic
executor are embedded in an Intent message in the valida-
tion phase to construct an Intent exploit. A malware can
send explicit malicious Intents to a particular component
of an app by explicitly setting the target class name using
the Intent.setClass() API. Alternatively, it can construct
an Intent which conforms to the Intent ﬁlter of the target
component as shown at Line 13 in Listing 4. The validation
component collects information about the entry component
by parsing the manifest ﬁle and the results from the static
symbolic execution. It creates data parameters which match
the Intent ﬁlter and satisfy the path constraints in symbolic
execution. In Intent ﬁlters, path is one of the data elements
that is checked by the Android runtime for accepting an
Intent. The developer can specify a special form of regu-
632lar expressions as the path pattern. Some of these values
might also be obtained from the symbolic execution phase
in which case we directly use the values generated by our
symbolic executor.
Intent messages transmit data in the following ways: (i) a
data URI which references the data resources consists of the
scheme, host and path as well as query parameters which are
the key-value mappings preceded by the “?”; (ii) Intent ex-
tras, the key-value pairs whose type can also be speciﬁed in
the Intent (e.g, int, string, etc); (iii) other Intent parameters
such as categories, actions, etc., that can be sent as string
values. An Intent can be constructed as a Java object from
a malware app as discussed in this paper.
It can also be
represented as an Intent hyperlink and invoked from web as
explained in [12]. One diﬀerence between Intent objects and
Intent hyperlinks is that Intent objects can contain arrays
and parcelable extra parameters while Intent hyperlinks can
only contain primitive type extra parameters. Hence, it is
also possible for the attackers to send malicious data through
parcelable key-value pairs and the victim receives the mali-
cious inputs by invoking Intent.getParcelableExtra(). We
partially support this API for the parcelable types which
have been modeled by our system (e.g., Intent). For this pur-
pose, analysis should ﬁrst resolve the type of the parcelable
extra parameters received in the target app. For example, if
a cast operation is applied to the parcelable parameter, the
cast type will be used as the resolved type for the param-
eter. If the resolved type is supported by our analyzer, an
object will be instantiated in the malware program and set
as an extra parameter to the Intent object. Once the anal-
ysis framework generates the key-value pairs as explained
in [12] and other necessary inputs for the source-sink ﬂows
and the Intent ﬁlter speciﬁcations for the target component,
all of these elements are put together to generate an Intent
message.
In order to perform dynamic testing, we conﬁgure our mal-
ware to send out an Intent message with malicious parame-
ters. Once the target component gets invoked and receives
the Intent, the validator logs the execution trace to obtain
the concrete values. Similar to the public vulnerability vali-
dation, our analysis attempts to place these concrete values
in the path constraints generated by the static symbolic ex-
ecution to create more precise inputs if possible. If the sink
method is reached on the execution path and the malicious
Intent parameters are observed in the sink stack frame, our
validator conﬁrms that the vulnerability is exploitable.
5. MITIGATING DATABASE ATTACKS
We propose a protection mechanism to mitigate both pub-
lic and private database attacks. Although Android al-
ready provides a ﬁne-grained security mechanism for pub-
lic database attacks, here, we propose an even ﬁner-grained
manifest speciﬁcation. In order to protect public databases,
Android allows developers to protect the data referenced by
a particular path (pattern) accessible by a content provider.
Such path patterns are already enforced at runtime by An-
droid. We propose a generalization of the path patterns
in the manifest speciﬁcation for a content provider. For
private database attacks, the entry point components can
be protected by an all-or-nothing approach but this is too
inﬂexible. We propose a new association between Intents
and Android permissions which can make the use of Intents
closer to that of content providers and the public database
protection speciﬁcations.
Our analysis framework can be used to automatically gen-
erate the new proposed extensions to the manifest simply
by adding the path patterns or Intent permissions discussed
below to prevent the vulnerability leading to the generated
exploit. Also, sometimes the manifest ﬁle does not con-
tain any permissions for URI paths which lead to the public
database attacks but the code-base contains execution paths
which can be triggered and controlled by attackers. In such
cases, our analysis is able to identify the unprotected paths
for which appropriate path patterns can be added to the
manifest ﬁle. While the developer is best placed to make
use of our mitigations, since only the manifest is involved,
the user (security analyst) can also add the additional spec-
iﬁcations to the manifest, repackage and sign the APK ﬁle.
The red lines in Listing 5 show how the manifest ﬁle of the
vulnerable app in Listing 3 is extended to prevent public
and private database attacks.
Our mitigation is a conservative extension to the Android
manifest speciﬁcation, making use of the existing runtime
mechanisms. So, no changes to the code-base of the vulner-
able app are needed. The advantage of our proposed mitiga-
tion is that it integrates with our analysis to automatically
mitigate public and private database attacks. Our analysis
can generate proof-of-concept input parameters as part of
Intents and URIs which can be blacklisted in the manifest
ﬁle automatically to prevent the detected attacks.
Mitigating Public Database Attacks. We have ob-
served that Android permissions are limited to speciﬁc path
patterns supported by the existing implementation of an-
droid:pathPattern which neither accepts regular expressions
nor the syntax supported by URI-based libraries such as
UriMatcher. Hence, supporting special path patterns used
in such libraries is not provided by Android. For instance,
the developer can register a URI with "#" as a path in the
UriMatcher to accept a URI whose path pattern is ([0-9]+).
To address this mismatch, we propose to allow such pat-
terns in the path patterns in the manifest. For this pur-
pose, the implementation of the android:pathPattern in the
framework needs to be extended. We can then leverage our
analysis framework to ﬁnd the path patterns which need
to be protected. Naturally, the developer can also manu-
ally determine such ﬁne-grained path patterns. Next, we
add these patterns with the appropriate permissions to the
manifest ﬁle. For the vulnerable public database in List-
ing 1, our analysis ﬁnds that the URIs that have "#" path
pattern are vulnerable to pollution attacks. Therefore, we
add a new tag,  for the "#" path pattern
which is protected by writePermission (Line 5 in Listing 5).
Mitigating Private Database Attacks. We propose an
extension to the manifest speciﬁcation which allows us to
protect execution paths in the program that can be triggered
with a particular set of Intents. Since this does not exist in
Android, we extend the existing Android manifest speciﬁ-
cation to be able to protect execution paths by permissions
when a particular part of the incoming Intent follows a spe-
ciﬁc pattern. Such patterns can be obtained automatically
using our analysis framework.
The extension decomposes Intents into sub-parts which
have primitive types and enforces the access control on In-
tents matching the speciﬁed patterns. These parts include:
(1) the string representation of the data URI which includes
633
1 
2 
3 ...
4 
5
6
7 
8 
13
14
15
16
17 

Listing 5: We modify the manifest ﬁle of app A in Listing 3 with
our extension to protect against database attacks. The extended
speciﬁcations are colored in red.
the scheme, host, port, path and query parameters; (2)
the action; (3) the Intent type; (4) the Intent category;
(5) the primitive extra parameters, etc. We extend the
 tag in the manifest with a new sub-tag,
 (similar to  for con-
tent providers), e.g., Line 11 in Listing 5. This new ex-
tension allows us to protect apps against speciﬁc incoming
Intents with regular Android permissions which are cho-
sen based on the vulnerable sink method.8 The  can have its own sub-tags to identify speciﬁc
content patterns. The system checks the permission of the
requesting app if the incoming Intent matches the patterns
in all sub-tags of the . Listing 5 shows
how the speciﬁcation for the broadcast receiver of the vulner-
able app in Listing 2 is extended to protect against private
database attacks. We add a new tag, 
which protects the component with writePermission against
the set of Intents matching the  tags which
refer to the extra parameter of Intents. These tags could also
be  and . The 
can have attributes such as android:scheme. The  and  can have android:key and an-
droid:value attributes which can be determined by our anal-
ysis framework. For this particular example, the Intents can
be matched using  tags.
6. EVALUATION
We analyze real-world Android apps to detect and exploit
public and private database attack vulnerabilities. Our main
goal is not only to detect potential vulnerabilities but also to
conﬁrm them with successful zero-day exploits. We analyze
924 apps (the APK ﬁles) in total which belong to the top
8
E.g., writePermission for the SQLiteDatabase.insert() sink method.

Table 1: Overall statistics of apps vulnerable to the database attacks.
Category
Sub-Category
# of
Vulnerable Apps
Public
Databases
Private
Databases
Pollution
Leakage
File Access
Pollution
Leakage
File Access
19
27
26
12
14
5
100 apps across all categories in Google Play and candidate
apps analyzed in [31]. Of these apps, 133 apps have at least
one exposed and unprotected content provider and all 924
apps have at least one exposed and unprotected component
other than content providers.
We ran DBDroidScanner in Ubuntu 12.04 on an Intel
Core i5-4570 (3.20GHz) with 16GB of RAM. On average,
the static part of our analysis takes from tens to hundreds
of seconds. We found analyzing public vulnerabilities tends
to be faster than private, as private analysis is more com-
plex due to symbolic execution needing to traverse more and
longer paths. To validate the database exploits, our custom
malware app is conﬁgured to launch the components and
perform the privileged operations (e.g., inserting data into
the app’s database). Listing 4 shows a code fragment of the
malware app used to perform public and private database at-
tacks. The runtime execution of a single dynamic test varies
depending on the app from seconds to 1 minute. Although
DBDroidScanner is a prototype, we see that the times are
usable. The static analysis phase is comparable or faster
than dynamic execution.
6.1 Database Vulnerability Detection Results
We ran our analyzer on 924 apps where 133 apps have
unprotected content providers in the manifest. Hence, we
analyze 133 apps for public database attacks and all 924
apps for potential private database attacks which can be ex-
ploited via inter-app communication. As shown in Table 1,
we detect and conﬁrm 52 public and 23 private vulnerable
apps and 153 vulnerabilities in total. We also classiﬁed our
results based on the content leakage, pollution and ﬁle ac-
cess categories. More detailed case studies of representative
vulnerable apps in our dataset are given in Appendix B.
Our results show that modeling the URI-based libraries
are necessary to generate accurate exploits for both public
and private database attacks. Even though the mechanisms
through which the private database attacks are launched (In-
tents) are diﬀerent from the public database attacks (content
provider APIs), sometimes similar constraints are used by
the developers to validate the incoming input. In Appendix
B, we discuss two example apps to explain why a good model
of such libraries is needed for exploit generation.
6.2 Comparison with ContentScope
We also compare our system with ContentScope [31], the
closest related work. As their data set is not available, we
have tried to collect and analyze representative vulnerable
apps mentioned in the paper. Some of these apps are re-
moved or updated – the original versions are no longer avail-
able. Where possible, we analyze these apps under their
lower SDK assumption (Android 16 and below) to able to
compare with their results. Table 2 shows our results for
the representative apps analyzed by ContentScope which are
still available.
634For the available apps with the same version, our tool
is able to ﬁnd all public database vulnerabilities reported
by ContentScope. Additionally, we report private database
vulnerabilities in these apps (ContentScope is not designed
to ﬁnd them) and show that 5 of these apps are vulner-
able to both public and private database attacks. There
are also updated versions of apps in which we do not ﬁnd
public database vulnerabilities but are vulnerable to the
private database attacks. We detect and conﬁrm 8 apps
vulnerable to the private database vulnerabilities. Surpris-
ingly, there are some cases (mOffice - Outlook sync, Dolphin
Browser HD, Shady SMS 4.0 PAYG) where the private database
vulnerability allows the attacker to access the protected con-
tent providers and launch privilege escalation attacks.
In
some cases (Pansi SMS, mOffice - Outlook sync), even though
the vulnerabilities reported by ContentScope are no longer
applicable in the updated versions of the apps, we ﬁnd new