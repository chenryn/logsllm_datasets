### Parameters of the Query API

Some parameters in the query API are of array types. Symbolic reasoning about arrays is non-trivial and does not scale well. We focus on arrays that are method parameters, tracking their elements in a separate pool. For other arrays, we do not distinguish their elements and only propagate dataflow facts for the base array object.

It is also possible to set all parameters of the query API, except the `uri`, to `null`. If the `projection` is `null`, all columns will be returned. If the `selection` is `null`, all rows for the given URI will be returned. If `sortOrder` is `null`, results will be returned in the default sort order.

### Dynamic Testing with Malware Skeleton App

To perform dynamic testing, we created a malware skeleton app that invokes the APIs of vulnerable content providers with malicious arguments resolved from static analysis. This malware does not have any user-granted permissions. When the vulnerable content provider is invoked, the validator component logs the concrete execution trace using the Android debugger to obtain concrete values. These values are then used to refine the path constraints generated by static symbolic execution, creating more precise inputs if needed.

If the generated inputs no longer change, the malware invokes the vulnerable content provider and validates the vulnerability using the following rules:
- The `openFile()` and `openAssetFile()` APIs are considered exploited if they return non-null `ParcelFileDescriptor` and `AssetFileDescriptor` references, respectively.
- The `query()` API should return a non-null `Cursor` reference.
- The `insert()` API should return a non-null `Uri` reference.
- The `update()` API should return a non-zero integer.

### Private Database Attacks

The key difference between private and public databases is that public databases are accessed through content providers, while private databases are accessed via Intent messages received by activities, services, or broadcast receivers. An input string obtained from an Intent can trigger paths down to `SQLiteDatabase` methods, allowing attackers to manipulate the database and compromise the app's security.

To trigger and validate private database attacks, the attacker must generate Intents targeting the vulnerable component of the victim app. In the validation phase, the values generated by the symbolic executor are embedded in an Intent message to construct an Intent exploit. A malware can send explicit malicious Intents to a specific component by setting the target class name using the `Intent.setClass()` API. Alternatively, it can construct an Intent that conforms to the Intent filter of the target component. The validation component parses the manifest file and the results from static symbolic execution to create data parameters that match the Intent filter and satisfy the path constraints. In Intent filters, the path is one of the data elements checked by the Android runtime for accepting an Intent. Developers can specify regular expressions as path patterns, and some of these values may be obtained from the symbolic execution phase.

### Intent Messages and Data Transmission

Intent messages transmit data in three ways:
1. **Data URI**: Consists of the scheme, host, and path, as well as query parameters (key-value mappings preceded by "?").
2. **Intent Extras**: Key-value pairs whose type can be specified in the Intent (e.g., int, string).
3. **Other Intent Parameters**: Such as categories and actions, which can be sent as string values.

An Intent can be constructed as a Java object from a malware app or represented as an Intent hyperlink and invoked from the web. Intent objects can contain arrays and parcelable extra parameters, while Intent hyperlinks can only contain primitive type extra parameters. Attackers can send malicious data through parcelable key-value pairs, and the victim receives the malicious inputs by invoking `Intent.getParcelableExtra()`. Our system partially supports this for modeled parcelable types (e.g., Intent). The analysis first resolves the type of the parcelable extra parameters. If the resolved type is supported, an object is instantiated in the malware program and set as an extra parameter to the Intent object. Once the key-value pairs and necessary inputs for source-sink flows and Intent filter specifications are generated, they are combined to create an Intent message.

### Mitigating Database Attacks

We propose a protection mechanism to mitigate both public and private database attacks. For public databases, Android already provides a fine-grained security mechanism, but we propose an even finer-grained manifest specification. To protect public databases, developers can specify path patterns in the manifest, which are enforced at runtime. For private database attacks, we propose a new association between Intents and Android permissions, making the use of Intents closer to that of content providers.

Our analysis framework can automatically generate the proposed extensions to the manifest by adding path patterns or Intent permissions to prevent the vulnerability leading to the generated exploit. If the manifest file does not contain permissions for URI paths leading to public database attacks, our analysis identifies unprotected paths and adds appropriate path patterns to the manifest. The red lines in Listing 5 show how the manifest file of the vulnerable app in Listing 3 is extended to prevent public and private database attacks.

### Mitigating Public Database Attacks

Android permissions are limited to specific path patterns supported by `android:pathPattern`, which does not accept regular expressions or the syntax used by URI-based libraries like `UriMatcher`. To address this, we propose extending `android:pathPattern` to support such patterns. Our analysis framework can find the path patterns that need protection, and these patterns can be added to the manifest with appropriate permissions. For example, if our analysis finds that URIs with "#" path patterns are vulnerable, we add a new `<path>` tag for the "#" path pattern, protected by `writePermission`.

### Mitigating Private Database Attacks

We propose an extension to the manifest specification to protect execution paths that can be triggered with specific Intents. This extension decomposes Intents into sub-parts with primitive types and enforces access control on matching Intents. These parts include the string representation of the data URI, action, Intent type, category, and primitive extra parameters. We extend the `<intent-filter>` tag with a new `<intent-pattern>` sub-tag, similar to `<data>` for content providers. This new extension allows us to protect apps against specific incoming Intents with regular Android permissions chosen based on the vulnerable sink method. The `<intent-pattern>` can have its own sub-tags to identify specific content patterns. The system checks the permission of the requesting app if the incoming Intent matches the patterns in all sub-tags of the `<intent-pattern>`. Listing 5 shows how the specification for the broadcast receiver of the vulnerable app in Listing 2 is extended to protect against private database attacks.

### Evaluation

We analyzed real-world Android apps to detect and exploit public and private database attack vulnerabilities. Our goal is not only to detect potential vulnerabilities but also to confirm them with successful zero-day exploits. We analyzed 924 apps, of which 133 have at least one exposed and unprotected content provider, and all 924 apps have at least one exposed and unprotected component other than content providers.

We ran DBDroidScanner on an Intel Core i5-4570 (3.20GHz) with 16GB of RAM. On average, the static part of our analysis takes tens to hundreds of seconds, with public vulnerability analysis being faster than private due to the complexity of symbolic execution. To validate the database exploits, our custom malware app is configured to launch components and perform privileged operations. The runtime execution of a single dynamic test varies from seconds to one minute.

### Database Vulnerability Detection Results

We detected and confirmed 52 public and 23 private vulnerable apps, with 153 vulnerabilities in total. We classified our results based on content leakage, pollution, and file access categories. Modeling URI-based libraries is necessary for generating accurate exploits for both public and private database attacks. Even though the mechanisms for private database attacks (Intents) differ from public database attacks (content provider APIs), similar constraints are often used by developers to validate incoming input.

### Comparison with ContentScope

We compared our system with ContentScope, the closest related work. For the available apps with the same version, our tool found all public database vulnerabilities reported by ContentScope. Additionally, we reported private database vulnerabilities in these apps, showing that 5 of them are vulnerable to both public and private database attacks. In updated versions of some apps, we did not find public database vulnerabilities but detected private database vulnerabilities. We confirmed 8 apps vulnerable to private database vulnerabilities, with some cases (mOffice - Outlook sync, Dolphin Browser HD, Shady SMS 4.0 PAYG) allowing attackers to access protected content providers and launch privilege escalation attacks.