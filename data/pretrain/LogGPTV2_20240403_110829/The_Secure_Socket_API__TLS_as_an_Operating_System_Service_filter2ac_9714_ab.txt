the use cases for each of its symbols.
Immediately we found that 170 of the 504 API sym-
bols are not used by any application in our analysis. De-
spite this, we manually inspected every symbol in the
API to determine whether they offered an important use
case for the SSA. The highlights of our ﬁndings for select
categories are as follows.
USENIX Association
27th USENIX Security Symposium    801
Category
Symbols Uses
TLS Functionality
Version selection
Cipher suite selection
Extension management
Certiﬁcate/Key management
Certiﬁcate/Key validation
Session management
Conﬁguration
Other
Allocation
Connection management
Miscellaneous
Instrumentation
29
39
68
73
51
61
19
33
41
64
26
1306
1467
597
2083
3164
1155
1337
6087
5228
1468
232
Table 1: Breakdown of OpenSSL’s libssl symbols.
4.1 Version Selection
OpenSSL allows developers to specify the versions of
TLS which their connections should use, and retrieve this
information. Of calls that set a version, 459 (54%) are
functions preﬁxed with SSLv23, which default to the lat-
est TLS version supported by OpenSSL, but also allow
fallback to supported previous versions. The OpenSSL
documentation indicates that these functions are pre-
ferred [10]. Of the 388 (68%) calls that indicate a sin-
gular TLS version to use, only 60 (15%) use the latest
version of TLS (1.2), and 83 (21%) specify the use of the
vulnerable SSL 3.0. Another 190 (49%) directly specify
the use of TLS 1.0, through the use of TLSv1 method
settings. Our inspection of source code comments sur-
rounding these uses suggest that many developers er-
roneously believe that it selects the latest TLS version.
We also found that many uses of version selection func-
tions are determined by compile-time settings supplied
by package maintainers and system administrators.
In aggregate, these version selection behaviors suggest
that overwhelmingly developers want the system to se-
lect the version for them, directly or indirectly, or are
adopting lower versions erroneously. We therefore rec-
ommend that the SSA use the latest uncompromised TLS
versions by default, and that deviation from this be con-
trolled by the system administrator.
4.2 Cipher Suite Selection
In our dataset, 221 (54%) packages contain code that
sets the ciphers used by OpenSSL directly, using the
* set cipher list functions. Due to limitations in
how Joern performs static analysis, we are not able to
determine all of the parameter values provided to these
functions. However, a sample of applications with hard-
coded ciphers suggests some bad practice. Of note are
the uses of eNULL (5), NULL (10), COMPLEMENTOFALL
(3), RC4 (2), and MD5 (1), all of which enable vulnerable
ciphers or enable the null cipher, which offers no encryp-
tion at all. We manually analyzed an additional sample
of packages and found that many adopt default settings
or retrieve their cipher suite lists dynamically from envi-
ronment variables and conﬁguration ﬁles.
Our analysis indicates that, like with version selection,
developers want to let the system select cipher suites for
them, and that those who choose to hardcode behaviors
often make mistakes. We thus recommend that allowed
cipher suites be set by the system administrator. The SSA
could allow applications to further limit cipher suites, but
should not let them request suites that are not allowed by
the administrator.
4.3 Extension Management
OpenSSL exports explicit control of ten TLS extensions
through functions in the extension management cate-
gory. Only two extensions are used somewhat regularly –
Server Name Indication (SNI), in 77 (19%) applications,
and Next Protocol Negotiation (NPN) and its successor
Application-Layer Protocol Negotiation (ALPN), in 60
(15%) applications. Five other extensions–including On-
line Certiﬁcate Status Protocol (OCSP)– are used much
less often, and Heartbeats, PRF, Serverinfo, and Sup-
ported Curves are not used at all.
Our observation is that many extensions should be
conﬁgured by the system administrator. For example,
SNI and OCSP could be enabled system-wide so that all
applications use them. In addition, there are relatively
few cases where developers need to supply conﬁguration
for an extension, such as a hostname with SNI or a list
of protocols with ALPN. We therefore recommend that
the SSA implement extensions on behalf of the applica-
tion and expose an interface to developers for supplying
conﬁguration information.
4.4 Certiﬁcate/Key Management
Of the 73 API functions used for managing keys and cer-
tiﬁcates, 39 (54%) are unused. Another 17 (23%) are
used by less than ﬁve software packages. The remaining
functions are used heavily, with a combined call count of
2083 from hundreds of distinct packages. Most of these
are used to either specify a certiﬁcate or private key for
the TLS connection. However, one is used to verify that a
given private key corresponds to a particular certiﬁcate,
and two are used to provide decryption passphrases to
unlock private keys.
802    27th USENIX Security Symposium
USENIX Association
Given that most functions in this category are unused,
and that all but three of those that are used are for spec-
ifying the locations of certiﬁcates and private keys, we
recommend the SSA have simpliﬁed options for supply-
ing private key and certiﬁcate data. These options should
take both chains and leaf certiﬁcates as input, in keep-
ing with recommendations in the OpenSSL documenta-
tion. Additionally, the SSA can check whether a supplied
key is valid for supplied certiﬁcates on behalf of the de-
veloper, removing the need for developers to check this
themselves, reporting relevant errors through return val-
ues of key assignment functionality.
4.5 Certiﬁcate Validation
Under TLS, failure to properly validate a certiﬁcate pre-
sented by the other endpoint undermines authentication
guarantees. Previous research has shown that develop-
ers often make mistakes with validation [11, 4, 8]. Our
analysis indicates that the certiﬁcate validation functions
in OpenSSL are heavily used, but conﬁrms that develop-
ers continue to make mistakes. We found that 6 pack-
ages disable validation entirely and specify no callback
for custom validation, indicating the presence of a man-
in-the-middle vulnerability. We have notiﬁed the rele-
vant developers of these problems. A total of 7 pack-
ages use SSL get verify result, but neglect to en-
sure SSL get peer certificate returns a valid cer-
tiﬁcate. Neglecting this call is documented as a bug in
the OpenSSL documentation, because receiving no cer-
tiﬁcate results in a success return value.
Recent work has described the beneﬁts of handling
veriﬁcation in an application-independent manner and
under the control of administrator preferences [18, 3].
Given this work and the poor track record of applica-
tions, we recommend that validation be performed by
the SSA, which should implement administrator prefer-
ences and provide secure defaults. This includes the em-
ploy of strengthening technologies such as OSCP [22],
CRLs [6], etc. We make this recommendation with one
caveat: if an application would like to validate a certiﬁ-
cate based on a hard-coded set or its own root store, then
it can supply a set of trusted certiﬁcates to the SSA.
4.6 Session Management
Performing the TLS handshake requires multiple round
trips, which can be relatively expensive for latency-
sensitive applications. Session caching alleviates this by
storing TLS session data for resumption during an ab-
breviated handshake. Most of the analyzed packages,
299 (73%), do not make any changes to the default ses-
sion caching mechanisms of OpenSSL. Within the other
27%, the most common modiﬁcation is to simply turn
caching off entirely. The remaining uses disable indi-
vidual caching features or are calls to explicitly retain
default settings. There are 31 packages that implement
custom session cache handling. Manual inspection of
these packages found this was used for logging and to
pass session data to other processes, presumably to sup-
port load balancing for servers.
We recommend that session caching be implemented
by the SSA, relieving developers of this burden, with
options for developers to disable caching and customize
session TTLs. Because it operates as an OS service, the
SSA is uniquely positioned to allow sharing of session
state between processes of the same application. This
could be further adapted to support session sharing be-
tween instances of an application on different machines.
4.7 Conﬁguration
OpenSSL provides conﬁguration of various options that
control the behavior of TLS connections, along with
modes that allow ﬁne-tuning the TLS implementation,
such as indicating when internal buffers should be re-
leased or whether to automatically perform renegotia-
tion. Most calls in this category, 830 (62%), are used to
adjust options. The four most-used options disable vul-
nerable TLS features and older versions (e.g., compres-
sion, SSLv2, SSLv3), and enable all bug workarounds
(for interoperability with other TLS implementations).
An additional 337 (25%) calls in this category set var-
ious modes. Of these, 138 (41%) set a ﬂag that makes
I/O operations on a socket block if the handshake has
not yet completed, 189 (56%) set ﬂags that modify the
SSL write function to behave more like write, and 47
(14%) use a ﬂag that reduces the memory footprint of
idle TLS connections. Also present are 32 calls (2%) to
functions that change how many bytes OpenSSL reads
during receive operations. Through manual inspection
we ﬁnd that many of these conﬁgurations are set by com-
pilation parameters, suggesting that many developers are
leaving these decisions to administrators already.
Given that the uses of this category are primarily bug
workarounds and restricting the use of outdated proto-
cols, and that many of these are already set through
compilation ﬂags, we recommend leaving such conﬁg-
urations to the administrator. Software updates can ap-
ply bug workarounds and disable vulnerable protocols
in one location, deploying them to all applications au-
tomatically. Modes and other conﬁguration settings in
this category tend to control subtleties of read and write
operations. Under the SSA, I/O semantics are largely de-
termined by the existing POSIX socket standard, so we
ignore them.
USENIX Association
27th USENIX Security Symposium    803
4.8 Non-TLS Protocol Speciﬁc Functions
The remaining categories consist of functions not ap-
plicable to the SSA or those trivially mapped to it.
The allocation category contains functions such as
SSL library init and SSL free, whose existence is
obviated by the existence of the SSA because all rele-
vant memory allocation and freeing is performed as part
of calls such as socket and close. The connection
management category contains functions that perform
connection and I/O operations on sockets. All of these
have direct counterparts within the POSIX socket API,
or have combinations of symbols that emulate the be-
havior, such as SSL connect (connect), and SSL Peek
(recv with MSG PEEK ﬂag). Another example is that
of SSL get error, which when called returns a value
similar to errno. These functions should therefore
be mapped to their POSIX counterparts for the SSA.
The instrumentation and miscellaneous categories con-
tain functionality that monitors raw TLS messages, ex-
tracts information from internal data structures, is sched-
uled for deprecation, etc.
5 The Secure Socket API
We designed the SSA using lessons learned from our
study of libssl and its usage. The SSA is responsible
for automatic management of every TLS category dis-
cussed in the previous section, including automatic se-
lection of TLS versions, cipher suites, and extensions. It
also performs automatic session management and auto-
matic validation of certiﬁcates. By using standard net-
work send and receive functions, the SSA automatically
and transparently performs encryption and decryption
of data for applications, passing relevant errors through
errno. All of these are subject to a system conﬁgura-
tion policy with secure defaults, with customization abil-
ities exported to system administrators and developers.
Administrators set global policy (and can set policy for
individual applications), while developers can choose to
further restrict security. Developers can increase secu-
rity, but cannot decrease it.
5.1 Usage
Under the Secure Socket API, all TLS functionality is
built directly into the POSIX socket API. The POSIX
socket API was derived from Berkeley sockets and is
meant to be portable and extensible, supporting a vari-
ety of network communication protocols. As a result,
TLS ﬁts nicely within this framework, with support for
all salient operations integrated into existing functions
without the need for additional parameters, pursuant to
our ﬁrst design goal. When creating a socket, developers
select TLS by specifying the protocol as IPPROTO TLS.
Data is sent and received through the socket using stan-
dard functions such as send and recv, which will be
encrypted and decrypted using TLS, just as network
programmers expect their data to be placed inside and
removed from TCP segments under IPPROTO TCP. To
transparently employ TLS in this fashion, other functions
of the POSIX socket API have specialized TLS behav-
iors under IPPROTP TLS as well. Table 2 contains a brief
description of the POSIX socket API functions with the
speciﬁc behaviors they adopt under TLS.
To offer concrete examples of SSA utilization, we also
present code for a simple client and server in Figure 1.
Both the client and the server create a socket with the
IPPROTO TLS protocol. The client uses the standard
connect function to connect to the remote host, also em-
ploying the AF HOSTNAME address family to indicate to
which hostname it wishes to connect. The client sends
a plaintext HTTP request to the selected server, which
is then encrypted by the SSA before transmission. The
response received is also decrypted by the SSA before
placing it into the buffer provided to recv.
In the server case, the application calls bind to give
itself a source address of 0.0.0.0 (INADDR ANY) on port
443. Before it calls listen,