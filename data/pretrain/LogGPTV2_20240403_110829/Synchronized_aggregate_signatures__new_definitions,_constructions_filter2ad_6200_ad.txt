The simulator begins by making three guesses. First, it
guesses the time period s∗ in the range 1 to 2⌈lg(q)⌉ which the
adversary will use to forge. Second, it guesses an ℓ-bit mes-
sage chunk M ′. Third, it guesses a special message chunk β∗
in [1, k]. These individual guesses represent a single guess
that the β∗th chunk of the forgery message will diﬀer from
the value M ′ which will be the β∗th chunk of the message
that the adversary asks to sign at time period s∗.
Next, choose random values x0, . . . , xk ∈ Zp and set u0 =
g−bM ′
gx0 , uβ∗ = gb and ui = gxi for all other i from 1 to
k. Then choose random xw, xz, xh ∈ Zp and set w = gxw ,
z = gbgxz and h = g−bs∗
gxh .
The simulator outputs the public parameters as (g, u0, . . . ,
uk, w, z, h). For the challenge keys, it sets the public key
as pk 1 = ga,
implicitly sets the secret key as sk 1 = a,
and sets the internal time record as sprev = 1. For all
other keys i = 2 to N , it chooses a random ai ∈ Zp, sets
pk i = gai and sk i = ai. It outputs the key information as
(pk 1, (pk 2, sk 2), . . . , (pk N , sk N )).
Queries.
When the adversary asks for a signature on message M =
M1M2 . . . Mk ∈ {0, 1}Z , the simulator ﬁrst checks the clock
as s = clock(). If s ≤ sprev or s ≥ 2λ, it outputs ⊥. Other-
wise, it updates its time period recorder sprev := s. There
are now two ways the simulator will proceed.
If s = s∗, then check that Mβ∗ = M ′. If this is not true,
then the simulator’s guess was incorrect and it must abort.
Otherwise, let I := {1, . . . , k} −{ β∗}. It chooses a random
t ∈ Zp and sets
σ1 = (ga)x0+Pi∈I xiMi · (w⌈lg(s)⌉zsh)t
, σ2 = gt
, s.
To verify correctness, observe that we can rewrite σ1 as fol-
lows:
To verify correctness, notice that we can rewrite σ1 as:
σ1 = (gab)(Mβ∗ −M ′ ) · (gx0 Y
uMi
i
)a · (w⌈lg(s)⌉gxz sgxh )t
i∈I
· (gb)t′ (s−s∗ ) · (g−ab)(Mβ∗ −M ′ )
= (g−bM ′+x0 gbMβ∗ Y
uMi
i
)a · (w⌈lg(s)⌉gxz sgxh )t
i∈I
· (gb)t′ (s−s∗ ) · (g−ab)(Mβ∗ −M ′ )
= (u0
= (u0
k
Y
i=1
k
Y
i=1
uMi
i
)a · (w⌈lg(s)⌉gxz sgxh )t · (gb(s−s∗ ))t
uMi
i
)a · (w⌈lg(s)⌉zsh)t
Output.
Eventually, the type II adversary outputs a valid aggre-
gate signature ˜σ = ( ˜γ1, ˜γ2, ˜s) on a message sequence (M1, . . . ,
MN ) ∈ {0, 1}Z×N under public keys (pk 1, . . . , pk N ) such
that 0 < ˜s ≤ 2⌈lg(q)⌉ ≤ 2q. We parse each Mi in chunks as
Mi,1 . . . Mi,k, where each chunk is ℓ bits. From the veriﬁca-
tion equation, we see that
e( ˜γ1, g) =
N
e(
Y
i=1
gai , u0) · e( ˜γ2, w⌈lg(˜s)⌉z ˜sh) ·
k
N
Y
e(
Y
j=1
i=1
gaiMi,j , uj).
If s∗ = ˜s and M1,β∗ &= M ′, then the simulator guessed cor-
rectly. In this case, let J := {1, . . . , k} −{ β∗}. Interpreting
˜γ2 as gt, for some t ∈ Zp, it follows from the above equation
that
˜γ1 = (g−bM ′+x0 )PN
i=1 ai · gb PN
i=1 aiMi,β∗
i=1 ai Pj∈J xj Mi,j
· gPN
· ((gxw )⌈lg(˜s)⌉(gb+xz )˜s(g−bs∗+xh ))t
σ1 = (gab)−M ′+M ′
= (g−bM +x0 gbM ′
(ga)x0+Pi∈I xiMi · (w⌈lg(s)⌉zsh)t
gPi∈I xiMi )a · (w⌈lg(s)⌉zsh)t
= (u0
k
Y
i=1
uMi
i
)a · (w⌈lg(s)⌉zsh)t
If s &= s∗, then choose random t′ ∈ Zp and compute the
/(ga)(Mβ∗ −M ′ )/(s−s∗ ) = gt′−a(Mβ∗ −M ′ )/(s−s∗ ).
value V = gt′
Let I := {1, . . . , k} − {β∗}. Output (σ1, σ2, s) where
σ2 = V
σ1 = (ga)x0+Pi∈I xiMi · σxw ⌈lg(s)⌉+xz s+xh
2
· (gb)t′ (s−s∗ )
Let us implicitly set the randomness t = t′ − a(Mβ∗ −
M ′)/(s − s∗) (here t′ gives t the proper distribution) and
we have
= (g−bM ′+x0 )PN
i=1 ai · gb PN
i=1 aiMi,β∗
i=1 ai Pj∈J xj Mi,j
· gPN
· gt(xw ⌈lg(˜s)⌉+xz ˜s+xh )
= gab(M1,β∗ −M ′ ) · gax0 · (g−bM ′+x0 )PN
i=2 ai
i=2 aiMi,β∗
i=1 ai Pj∈J xj Mi,j · gt(xw ⌈lg(˜s)⌉+xz ˜s+xh )
= gab(M1,β∗ −M ′ ) · ga(x0+Pj∈J xj M1,j )
i=2 ai (Mi,β∗ −M ′ ))
· gb PN
· gPN
· gb(PN
· gPN
i=2 ai (x0+Pk
j=1 xj Mi,j ) · gt(xw ⌈lg(˜s)⌉+xz ˜s+xh )
The simulator computes
A = (ga)x0+Pj∈J xj M1,j
A′ = gPN
B = (gb)PN
i=2 ai (x0+Pk
i=2 ai (Mi,β∗ −M ′ )
j=1 xj Mi,j )
σ1 = (gx0 Y
uMi
i
)a · (w⌈lg(s)⌉gxz sgxh )t · (gb)t′ (s−s∗ )
i∈I
σ2 = gt
and outputs gab as
„
˜γ1
B · A · A′ · (gt)xw ⌈lg(˜s)⌉+xz ˜s+xh
1
M1,β∗ −M ′
«
.
480Otherwise, the simulator aborts. The probability it does not
abort at any point during the simulation is
1
k
·
1
2⌈lg q⌉
·
1
2ℓ =
1
k · 2⌈lg q⌉ · 2ℓ
≥
1
k · 2q · 2ℓ
Therefore, if a type II adversary can break this scheme with
probability of ǫ, then the simulator can solve the CDH prob-
lem with probability of at least ǫ/(2ℓ+1
· q · k).
Batch((pk 1
, M1, σ1), . . . , (pk N
, MN , σN )) The batch veri-
ﬁcation algorithm parses each signature σi = (σ1,i, σ2,i,
si) and checks that all 0 < si < 2λ. If this is false, it re-
jects. Let Mi = Mi,1Mi,2 . . . Mi,k, where each division
is ℓ bits. The algorithm extracts gai ∈ pk i and batch
veriﬁes the signatures by checking the group mem-
bership of all (σ1,i, σ2,i) values, choosing r1, . . . , rN ∈
{0, 1}
N
L and testing that:
N
N
5. DISCUSSION
e(
Y
σri
1,i
, g) = e(
Y
gairi , u0) · e(
Y
σri⌈lg(si )⌉
2,i
, w)
We discuss features and extensions of the construction.
i=1
In our scheme, anyone can
Aggregating Aggregates.
combine two aggregate signatures into a single aggregate sig-
nature simply by multiplying them together, provided that
the time periods match. This is also a useful property of
other existing schemes [11, 16, 6].
Self-Aggregation and Multiple Signatures per Pe-
riod. In Section 4, a signer can only issue one signature per
time period, however, this requirement can be relaxed if the
size of a user’s public key is allowed to grow in proportion to
the total number of messages to be signed in any time period.
The technique is based on the ability to self-aggregate. A
user who wishes to sign at most j messages per time period
must select a public key pk = (ga1 , . . . , gaj ). To sign δ (≤ j)
messages M1, M2, . . . , Mδ where Mi = Mi,1Mi,2 . . . Mi,k in
the current time period s, the signer can the generate an ag-
gregate signature on all δ messages, with randomness t ∈ Zp,
as:
δ
σ1 = (
Y
(u0
j=1
k
Y
i=1
u
Mj,i
i
)aj ) · (w⌈lg(s)⌉zsh)t,
σ2 = gt,
s.
If the
Most Signing Work Can Be Done Oﬄine.
signer knows a future time period s during which she wants
to issue a signature, then she can precompute the values
(w⌈lg(s)⌉zsh)t and gt. If we let messages chunks be bits and
the signer stores her secret key in the form ua
1 , . . . , ua
Z ,
then she can compute the signature once it is known using
Z + 1 multiplications to get (u0 QZ
)a and then one
ﬁnal multiplication to obtain
0 , ua
uMi
i=1
i
(u0
Z
Y
i=1
uMi
i
)a(w⌈lg(s)⌉zsh)t.
This might help a lower-resource device get its signatures oﬀ
quickly once the message value becomes known.
Batch Veriﬁcation. A batch veriﬁcation algorithm [5]
takes as input n signatures on n messages from n users and
outputs 1 if all individual signatures verify (with probabil-
ity 1) and 0 otherwise (with probability 1 − 2−L for security
parameter L.)
The same signatures we aggregated in Section 4 also batch
verify. The batching algorithm works even for diﬀerent sign-
ers on diﬀerent messages at diﬀerent time periods.
It re-
quires only k + 5 pairings for N signatures, where k is the
security parameter from before which in practice could be
5. Let L be a security parameter, which in practice could
be 80. It works as follows:
i=1
N
i=1
N
· e(
Y
σrisi
2,i
, z) · e(
Y
σri
2,i
, h)
i=1
i=1
k
N
·
Y
e(
Y
j=1
i=1
gairiMi,j , uj)
Theorem 5.1. The above algorithm is a batch veriﬁer for
the Section 4 signatures with error 2−L.
In many applications, signatures may be streaming into a
collector, who batch veriﬁes them, and then aggregates the
most interesting of them for storage or transmission pur-
poses. Even existing random oracle schemes do not provide
this functionality. The full aggregate signatures of [11, 6] do
not batch verify for diﬀerent signers on diﬀerent messages
and the (synchronized) signatures of [16] do not batch ver-
ify across synchronization values. The sequential signatures
of [23] also require Ω(N ) pairings to verify N signatures, as
they employ O(λ) diﬀerent group elements per signer.
One can extend this algorithm to batch verify a group
of aggregate signatures in a straightforward manner. Thus,
a central database could receive a group of aggregate signa-
tures at various times during the day and then quickly batch
verify them all together.
Better Eﬃciency in the Random Oracle Model. In
Appendix A, we provide a synchronized aggregate signature
construction in the random oracle model which is strictly
more eﬃcient than our standard model construction, but
also has properties which may make it more desirable for
some applications than existing random oracle schemes. Our
Section 4 scheme has O(λ) elements in the public parame-
ters, which results in veriﬁcation times of the same order
(although independent of N .) In our random oracle model
scheme, we require only 6 elements in the public parame-
ters, and both our signatures and aggregate signatures can
be veriﬁed using at most 4 pairings. Our random oracle
model scheme also batch veriﬁes eﬃciently.
In contrast, the Boneh et al. [11] scheme requires N + 1
pairings to verify an aggregate signature from N signers on
N diﬀerent messages. In Gentry and Ramzan’s synchronized
scheme [16], veriﬁcations require only 3 pairings. However,
all prior full or synchronized aggregate signatures [11, 16,
∗ → G, where G is
6] require a hash function H : {0, 1}
a bilinear group, where as our random-oracle construction
only requires a hash H ′ : {0, 1}
∗ → Zp. Since there are some
candidate elliptic curve implementations of bilinear groups