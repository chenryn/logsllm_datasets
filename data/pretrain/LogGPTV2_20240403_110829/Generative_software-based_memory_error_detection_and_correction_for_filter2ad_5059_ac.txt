->update(); } II generic advice 
->check(); }  }; 
: before()  { 
advice call(protectedClasses()) 
tjp->target() 
call(protectedClasses()) 
: after() 
Fig. 2: An implementation 
of the generic 
object-protection 
mechanism 
written 
in AspectC++. 
C =  {data members, R} 
sizeo! (R) =  r· sizeo! (C) 
compile-time 
is obviously 
a 
of the data members 
way to 
feature 
a template 
A solution 
there is no generic 
by the particular 
for this  problem 
The factor r is specified 
in plain CIC++, but  the 
of the AspectC++ compiler 
metaprogram 
EDMIERM, for 
as  a growth of C leads to a growth of R and the 
is to define the 
example, r is 2 for TMR. Such an equation 
paradox, 
other way around. 
size of R to  depend 
only on the  size 
of C without R. Unfortunately, 
express this solution 
introspection 
implement 
members prior to  the introduction 
means, the built-in 
data member independently 
the metaprogram. 
instance, 
The main benefit of this solution 
can be excluded 
data members as well as compiler-generated 
alignment 
inside  a 
data structure. 
C. Object Composition 
that iterates 
of redundancy. 
can be applied 
and, for 
of redundant 
from the size calculation,  for 
example public 
are added up by 
constant 
This sum is a compile-time 
can be used to introduce 
sizeof operator 
and the results 
is that unwanted 
over all data 
By this 
to every 
an  array 
allows to 
bytes. 
padding 
data members 
The  next 
challenge 
that we encountered 
is the composition 
a class-type member Csub 
C =  {Csub, ... , R}. Given this definition, 
twice, 
Rsub. Thus, we decided 
the 
of Csub - would be protected 
- an instance 
of objects. Let the class C contain 
plus redundancy: 
subobject 
both by R and its own redundancy 
to exclude subobjects 
from the generic 
that subobjects are only protected 
exclusion of subobjects 
template-based technique 
on types, for instance 
of class type (subobject), a pointer, 
Additionally, 
object protection 
instance 
opportunity 
this technique 
by testing 
yet. 
once. We implemented 
the 
by C++ type traits  [24], 
that allows to make decisions 
which is a 
based 
whether a data member is 
offers a way to tailor 
an integer, 
and so on. 
the generic 
to cover only particular 
data members, for 
just pointers. We have not further 
investigated 
this 
object protection,  so 
IV. DESIGN CHALLENGES AND DECISIONS 
This section 
discusses the challenges 
during design and implementation 
protection  algorithm.  These 
challenges 
details 
previous 
of the algorithm 
section. 
that have not been addressed in the 
of the generic object­
that we encountered 
relate to particular 
A. Selection 
of Data Members to Protect 
The fundamental 
idea of our approach  is 
to exploit 
that 
protection 
by arbitrary 
and writable 
need infonnation 
this is not the case for public 
3, and we are convinced 
that it 
object 
whether it is supposed to be covered by the 
This information 
AspectC++'s 
extensions: 
feature 
software
to exclude 
such members from the generic 
Therefore,  we 
about the 
public, protected or private) of each data mem­
data members are only accessed within member functions 
of the same class. However, 
data members, which are readable 
program statements. Anyway, public data members are rarely 
used in object-oriented 
is feasible 
protection. 
level  (either 
ber to determine 
object protection. 
compile-time 
JoinPoint: 
the target 
protection 
as well  as 
this introspection 
that iterates 
generative 
members of any class instance. Then, arbitrary 
- for example,  checksum 
additionally 
detection  (EDM) 
throughout 
metaprograms 
level  of 
a pointer to  the member can be obtained. 
out public data members. Thus, the error 
(ERM) used 
introspection 
: MEMBERS reflects 
class, and JoinPoint: 
and error-recovery 
this paper are formulated 
the number of data members of 
:prot encodes 
the 
as generative 
AspectC++'s introspection 
the I th member. In a similar 
calculations 
is provided by 
for structural 
information, 
that rest upon 
metaprogram 
it is feasible 
C++ template 
mechanisms 
to  write 
over all 
data 
template 
:Member: 
filtering 
a single 
way, its Type 
feature. 
Given 
computations 
- can be generated, 
B. Allocation 
of Redundancy 
The amount of redundancy 
needed for a particular  data 
EDM/ERM. To guarantee 
and correction 
depends on the deployed 
error detection 
structure 
a certain 
amount of redundancy 
size (in tenns of bits). Therefore, 
Section 
the redundancy 
size depends on the size of the target class: 
extension 
(see 
ill-B) of a target class C by a data member that holds 
-member's 
R implies 
has to grow with  the 
redundant-data
probability, 
the structural 
protected 
that  the 
the total 
data's 
3The object-oriented 
paradigm 
encourages 
data as protected or p ri vate to restrict 
modifications 
by other software 
components. 
developers 
access and prevent unwanted 
to declare 
important 
D. Static 
Call-site 
Analysis 
The fundamental 
idea of generic  object  protection  is 
to 
associate error-correction-and-detection with member 
of data structure
are performed, 
dundancy 
s. Before  a  member 
and after return from that function,  the  re­
is recalculated. 
function is called, 
information 
These actions 
functions 
can take 
checks 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:53:00 UTC from IEEE Xplore.  Restrictions apply. 
to omit checks/recalculations 
leads 
However, 
Consider 
knowledge 
complexity, 
the call-site 
whereas  the 
member functions 
offers the advantage 
The former approach 
in O( #call sites) 
latter 
number of 
are 
In general,  when the 
are unknown, 
both solutions 
approach 
about the caller. 
place either at the caller or the callee. 
results 
to O(#member functions). 
call sites and 
feasible. 
of providing 
functions II and 12 of the same data structure, 
12 at some point in the dynamic control 
0 -+ obj.hO. 
mainO -+ obj.1I 
from II to 12, any checks and 
be omitted, 
by the recalculation. The 
on such call sites can be taken at compile time by a static 
analysis 
callee 
structure, 
of the call relation
must be compared, 
the protection 
ships.  Basically, the caller 
and the 
and only if both refer to same data 
two member­
and II calls 
flow, for example: 
the check would immediately 
recalculations 
be succeeded 
Then, concerning 
can be skipped. 
redundancy 
mechanism 
decision 
because 
should 
the call 
The 10inPoint 
API of AspectC++  (see 
Section ill-B) 
the  class 
type of the 
the necessary information 
analysis. In the body of call-advice  code, 
such a static 
the class type 
to implement 
pointers 
(JoinPoint: 
(JoinPoint: 
on equality 
: Target) are exposed 
: That) as  well as 
provides 
call-site 
of the caller 
callee 
These class types can be tested 
Moreover, 
by tjp->that() and tjp->target() respectively, 
be compared 
compile-time 
testing 
when the result 
to exploit 
by choosing 
is known at compile 
information 
The comparison 
Comparing 
directly. 
decision. 
to the caller/callee 
this pointers, 
C++'s built-in 
the call-site 
object-pointers 
objects  can 
to minimize 
approach 
this static 
which can be optimized 
time.  Therefore, 
we decided 
checks 
analyses. 
paired with static 
the runtime 
of types is necessarily a 
boils down to 
out 
by the 10inPoint 
API. 
by C++ type traits. 
be obtained 
which  can 
This design decision 
further 
enables 
the minimization 
of the 
recalculations, 
calls that leave a protected 
data­
function 
can be handled as well. As an example, 
time window between checks and redundancy 
because outgoing 
structure 
member function f that calls the C-library 
Then, inside f, the call to p rintf () can be enclosed 
EDMlERM-actions: frecalcula
Thus, during the execution 
of f is safe. These additional 
increase 
greatly improve 
is especially 
and correction 
error detection 
true for  calls 
of our approach 
the overhead 
that block 
(mostly 
capabilit
the running process. 
by inverted 
teO -+ printfO -+ fcheckO· 
of p rintf ( ), the data structure 
clearly 
checks/recalculations 
code  size)
, but 
ies. This 
function printf(). 
consider a 
E. Inheritance 
Special attention 
has to be  paid 
to  the object-oriented 
class inherits 
of inheritance. 
class, and the derived 
In C++, a base class can be extended 
principle 
by a derived 
from the base class .  Members of the base class are directly 
accessible in the derived 
declared 
the data members of all its base classes have to be verified. 
classes Cyg_Scheduler 
This is the case for the aforementioned 
and Cyg_ Th read of eCos, which inherit 
from four base 
each. 
private). When a function of a derived class 
is called, 
for members that are 
class (except 
all members 
classes 
The information 
about base classes of an arbitrary 
C++, and again, requires 
in  plain 
for being implemented. 
a template-based 
list of all base classes 
The AspectC++ 
class 
compile­
cannot be retrieved 
time introspection 
compiler 
provides 
(JoinPoint: 
mation  about 
template 
generative  C++ 
classes and invoke check/recalculate 
Additionally, 
that is, to iterate 
actions  on 
has to be performed 
and so on. 
over the bases of the bases, 
such an iteration 
metaprogram 
can iterate 
over all base 
each of them. 
recursively, 
The second challenge 
with respect 
to inheritance 
is the 
functions. A virtual 
function, 
classes. When such a function is called, 
in a base class, can be overridden 
by several 
the actual 
is not chosen before runtime. Hence, 
the callee object type of a virtual­
at compile time. This uncertainty 
Therefore, 
call-site analysis approach. 
conflicts 
with 
we decided 
the static analysis by a dynamic dispatch 
actions. For classes with inheritance, 
of virtual 
to determine 
dynamic dispatch 
implemented 
derived 
function's implementation 
it is impossible 
function  call 
our static 
to complement 
of check/recalculate 
the functions 
virtual 
most derived 
dynamic dispatch 
base classes are processed 
data structures 
treated 
dispatch. 
the generic 
its inheritance 
relatio
such an inheritance 
call-site 
optimized 
F. Multi-threading 
holistically 
class belonging 
out for such cases. 
However, 
functions, so that their invocation 
that check/recalculate 
the redundancy 
become 
is dispatched 
to the 
object. After the 
to the most derived class happened, 
the 
above. In summary, 
base classes are 
to a  particular 
as described 
that are built from several 
by the base-class 
the decision 
object protection 
iteration 
plus dynamic 
whether a class is covered 
can be taken independently 
by 
of 
ns. Furthermore, 
hierarchy 
any function calls inside 
by the static 
can be detected 
analysis, and the object-protection 
mechanism 
can be 
An important 
requirement 
to the generic 
for multi-threading, 
as needed when applied 
object protection 
system. 
is the support 
the eCos operating 
mean that our approach works 
are used concurrently 
by multiple 
implementation 
duty in parallel. 
itself spawns several 
By support 
correctly for 
threads 
data structures 
-and not that our 
to perform its 
threads 
to 
we 
that 
for multi-threading 
Our first observation 
is that every EDM/ERM operation 
primitives, such as a semaphore/mutex, 
must  be serialized 
alter  the 
a 
ructures 
resumed, 
on shared data-st
data structure 
and its checksum, 
In the meanwhile, 
EDM/ERM operations 
other threads  could 
so that, when the 
it finds an inconsistent state. 
(check/recalculate) 
must be atomic, 
considering a thread that is  preempted  while 
verifying 
checksum. 
particular 
suspended thread  is 
Thus, concurrent 
by synchronization 
a kernel lock, or by suppressing interrupts. The choice of 
locking 
mechanism 
data structures 
them while performing 
data structure
a mutex, and obviously, 
synchronization 
by configurable 
is a textual 
covered 
case Cyg_Scheduler, 
by 
non-shared data structures 
need no 
by the user, of all classes that are 
mechanism -in our 
at all. We  implemented 
synchronized() 
depends on the actual data structure, 
e.g., 
s, on the other hand, can be synchronized 
Cyg_ Thread and their  base 
used during interrupts 
synchronization 
list,  provided 
by a  particular 
pointcuts
to suppress 
require 
classes. 
this differentiation 
4. Such a pointcut 
EDM/ERM actions .  User-level-only 
Our second observation 
is that, as soon as a data structure 
is being modified, its checksum is no longer valid, so  that 
: BaseClass<I» in a similar 
data members is provided. 
way as  the infor­
By this means, a 
4The definition 
of synch ronized () pointcuts 
is carried 
in Section 
III-B. 