title:A look in the mirror: attacks on package managers
author:Justin Cappos and
Justin Samuel and
Scott M. Baker and
John H. Hartman
A Look In the Mirror: Attacks on Package Managers
Justin Cappos
Justin Samuel Scott Baker
John H. Hartman
Department of Computer Science, University of Arizona
Tucson, AZ 85721, U.S.A.
{justin, jsamuel, bakers, jhh}@cs.arizona.edu
ABSTRACT
This work studies the security of ten popular package man-
agers. These package managers use diﬀerent security mech-
anisms that provide varying levels of usability and resilience
to attack. We ﬁnd that, despite their existing security mech-
anisms, all of these package managers have vulnerabilities
that can be exploited by a man-in-the-middle or a malicious
mirror. While all current package managers suﬀer from vul-
nerabilities, their security is also positively or negatively im-
pacted by the distribution’s security practices. Weaknesses
in package managers are more easily exploited when distri-
butions use third-party mirrors as oﬃcial mirrors. We were
successful in using false credentials to obtain an oﬃcial mir-
ror on all ﬁve of the distributions we attempted. We also
found that some security mechanisms that control where a
client obtains metadata and packages from may actually de-
crease security. We analyze current package managers to
show that by exploiting vulnerabilities, an attacker with a
mirror can compromise or crash hundreds to thousands of
clients weekly. The problems we disclose are now being cor-
rected by many diﬀerent package manager maintainers.
Categories and Subject Descriptors
K.6.5 [Security and Protection]: Invasive software; C.2.0
[Computer-Communication Networks]: General—Se-
curity and protection; K.4.1 [Social Issues]: Abuse and
Crime Involving Computers
General Terms
Security
Keywords
Package Management, Mirrors, Replay Attack
1.
INTRODUCTION
Package managers are a popular way to distribute software
(bundled into archives called packages) for modern operating
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’08, October 27–31, 2008, Alexandria, Virginia, USA.
Copyright 2008 ACM 978-1-59593-810-7/08/10 ...$5.00.
systems [1, 2, 3, 21, 22, 25, 26, 28, 31, 32]. Package managers
provide a privileged, central mechanism for the management
of software on a computer system. As packages are installed
by the superuser (root), their security is essential to the
overall security of the computer.
This paper evaluates the security of the eight most popu-
lar [9, 19] package managers in use on Linux: APT [1], APT-
RPM [2], Pacman [3], Portage [21], Slaktool [25], urpmi [28],
YaST [31], and YUM [32]. Also examined is the popular
package manager for BSD systems called ports [22] and a
popular package manager in the research community called
Stork [26]. These package managers use one of four diﬀer-
ent security models: no security, cryptographic signatures
embedded within packages, signatures on detached package
metadata, or signatures on the root metadata (a ﬁle that
contains the secure hashes of the package metadata).
This work demonstrates that there is an ordering to the
amount of security provided by the diﬀerent package man-
ager security models. This order is preserved even as other
security weaknesses in the package managers are corrected.
Having no signatures allows the most egregious attacks, fol-
lowed by having only package signatures, having signatures
on detached package metadata, and ﬁnally having signa-
tures on the root metadata, which provides the most secu-
rity. However, there are usability concerns with diﬀerent
signature mechanisms, most notably the ability to verify a
stand-alone package (a package obtained from a source other
than the main repository). Signatures on root metadata do
not provide a convenient way to verify stand-alone packages
and so the user is likely to install such packages without us-
ing security checks. In contrast, package managers that use
signatures on detached package metadata or signatures on
packages can verify stand-alone packages.
Because of the usability strengths and weaknesses of dif-
ferent techniques for providing security, this work recom-
mends a layered approach created by combining two tech-
niques: signatures on the root metadata and either signa-
tures on packages or package metadata. This technique pro-
vides the security strengths and the usability strengths of
both types of signatures with an overhead of between 2-5%.
The layered approach has been added to the Stork package
manager and is now in use by thousands of clients around
the world.
While we ﬁnd that vulnerabilities in package managers
do exist, vulnerabilities are not always exploitable in the
real world. We examine this by looking at the security of
popular distributions. We ﬁnd that it is trivial for an at-
tacker to control an oﬃcial package mirror for a popular
distribution (such as Ubuntu, Debian, Fedora, CentOS, and
openSUSE) and therefore to be in the position to launch at-
tacks on clients. To mitigate this threat, many distributions
use mechanisms to distribute requests to multiple mirrors
or provide certain information from a trusted source. We
show that some of these mechanisms actually decrease the
security of users by making it easier to target attacks.
2. BACKGROUND
2.1 Package Formats
Packages consist of an archive containing ﬁles and, in most
cases, additional embedded package metadata. For a given
package, the embedded package metadata contains informa-
tion about any other packages that must be installed in or-
der for it to operate (the dependencies), functionality the
package possesses (what the package provides), and various
other information about the package itself. The most popu-
lar package format, RPM [23], has space for one signature.
Other popular package formats have no standard ﬁeld for
signatures, although in some cases extensions exist to sup-
port signatures [8, 11].
2.2 Package Managers
Clients use a package manager to install packages on their
system. A package manager gathers information about pack-
ages available on package repositories. Almost all pack-
age managers automatically download requested packages as
well as any additional packages that are needed to correctly
install the software. This process is called dependency res-
olution. For example, a requested package foo may depend
on libc and bar. If libc is already installed, then libc is
a dependency that has been resolved (no package must be
installed to satisfy the dependency). If there is no installed
package that provides bar, then bar is an unresolved depen-
dency and a package that provides bar must be installed
before foo may be installed. The package manager may be
able to locate a package that provides bar on a repository.
The packages that are chosen to fulﬁll dependencies may
have unresolved dependencies of their own. Packages are
continually added to the list of packages to be installed until
either the package manager cannot resolve a dependency
(and produces an error) or all dependencies are resolved.
2.3 Repository
A package repository is usually an HTTP or FTP server
from which clients can obtain packages and package meta-
data. The package metadata is usually just a copy of the em-
bedded package metadata for all packages on the repository.
Package managers download the package metadata from a
repository so that they know which packages are available
from that repository. This also provides the package man-
ager with dependency information needed to perform de-
pendency resolution. To facilitate convenient downloading
of package metadata, most repositories store all of the pack-
age metadata in a small number of compressed ﬁles.
In addition to the package metadata, almost all reposito-
ries have a root metadata ﬁle. The name and location of the
root metadata ﬁle varies for diﬀerent repository formats, but
the contents are similar. The root metadata provides the lo-
cation and secure hashes of the ﬁles that contain the package
metadata.
Root Metadata
packagemetadata1
packagemetadata2
c302df...f8
hash:
hash: 192ee0...31
Root Metadata signature (optional)
Package
Metadata
packagemetadata1
A Package
foo−2.0.rpm
package contents
embedded package
metadata
Package
signature (optional)
A Package’s Metadata
name:’foo−2.0.rpm’(cid:10)
size:’56242’
hash:’74b5a1...c3’
...
Package Metadata
signature (optional)
Figure 1: Repository Layout. The root metadata,
package metadata, and packages may all optionally
have signatures depending on the support of the
package manager. Arrows point from a secure hash
to the ﬁle it references.
Figure 1 shows the layout of a typical repository. A pack-
age manager downloads the root metadata and uses that
to locate the ﬁles containing the package metadata. The
package manager then downloads the package metadata.
The package metadata is used to determine package avail-
ability as well as for dependency resolution. Packages are
then downloaded and installed. The root metadata, pack-
age metadata, and packages may be signed depending on
the security model of the package manager.
2.4 Mirror
It is common for a distribution to have more than one
server from which users can download packages and package
metadata. There is usually a main repository for a distribu-
tion whose contents are copied by many separate mirrors.
A mirror typically contains exactly the same content as the
main repository and is updated via rsync or a similar tool.
A mirror diﬀers from a main repository in that a mirror is
not intended to have packages directly added to it or re-
moved from it by its administrators. Packages are added or
removed only on the main repository and the mirrors later
obtain the changes when copying the main repository.
A mirror can be public (available for anyone to use) or
private (restricted to a speciﬁc organization). A mirror may
also be endorsed by a distribution for public use, typically
when that the distribution is in contact with the mirror
maintainers. This type of mirror is called an oﬃcial mirror
(the terminology used outside of this document varies by
the distribution). Oﬃcial mirrors are by deﬁnition public
because the distribution is endorsing their use to the public.
It should be noted that some distributions do not use of-
ﬁcial mirrors hosted by outside organizations. One example
is tiny distributions that can support all of their clients by
a small number of repositories that the distribution directly
controls. Another example is a distribution that requires
users to pay. These costs often are used to support a set of
internally maintained mirrors for the distribution. Alterna-
tively, a distribution may allow or require each organization
using the distribution to set up their own private mirrors for
the organization’s own use.
However, oﬃcial mirrors hosted by outside organizations
are the predominant mechanism for software distribution
with all but two popular distributions [9, 19] relying on oﬃ-
cial mirrors. Oﬃcial mirrors are essential for most distribu-
tions to reduce cost and management overhead.
3. THREAT MODEL
The threat model used in this paper involves an attacker
that can respond to requests made by a package manager.
This can be a man-in-the-middle, an attacker that has tricked
a client into contacting the wrong server (e.g. through DNS
cache poisoning), or an attacker who has gained control of
an oﬃcial mirror for a distribution. The threat model is as
follows:
• The attacker can serve the client arbitrary ﬁles.
• The attacker does not know what package the client
will request a priori.
• The attacker does not have a key trusted to sign pack-
ages, package metadata, or the root metadata. — Note
that mirrors do not usually possess the private key
used to sign ﬁles, they only copy previously signed ﬁles
from the main repository.
• The attacker has access to outdated packages, out-
dated package metadata, and outdated root metadata
ﬁles. — There are many outdated mirrors on the In-
ternet where an attacker can obtain these ﬁles.
• The attacker is aware of vulnerabilities in some out-
dated packages and is able to exploit those vulnera-
bilities. — This is possible by looking at change logs
and updates to software source ﬁles or downloading an
exploit toolkit [18].
• The attacker does not know of a vulnerability in the
latest version of any package. — Zero-day vulnerabil-
ities are unlikely to be known by many attackers.
• If a package manager supports signatures, signatures
are used. — If a client or distribution chooses not to
use signatures supported by their package manager,
they are as vulnerable as if they used a package man-
ager that does not support signatures.
• Expiration times in the root metadata are used, if sup-
ported, and current (un-expired) root metadata does
not contain any vulnerable versions of packages — The
root metadata is a single, small ﬁle so it is feasible for
the main repository to sign it relatively frequently with
short expiration times.
3.1 Attacks
Given this threat model, there are several attacks that
may be used on a client. The impact of these attacks varies,
but all allow the attacker to either crash or control the
client’s computer (possibly via exploiting a package with a
known vulnerability). Each of the following attacks is eﬀec-
tive on at least some of the package managers we studied:
• Arbitrary Package The attacker provides a package
they created in place of a package the user wants to
install.
the attacker can exploit. The attacker can then com-
promise the client by exploiting the vulnerable pack-
age. Note that most package managers will not down-
grade an existing package, so a replay attack only works
when the package manager installs a new package, not
when it updates an existing package.
• Freeze Attack Similar to a replay attack, a freeze at-
tack works by providing metadata that is not current.
However, in a freeze attack, the attacker freezes the
information a client sees at the current point in time
to prevent the client from seeing updates, rather than
providing the client older versions than the client has
already seen. As with replay attacks, the attacker’s
goal is ultimately to compromise a client who has vul-
nerable versions of packages installed. A freeze attack
may be used to prevent updates in addition to having
an installed package be out of date.
• Extraneous Dependencies The attacker rewrites the
package metadata to have additional packages installed
alongside a package the user intends to install. For
example, the attacker provides metadata that incor-
rectly states that package foo depends on bar. This
will cause bar to be installed when it is not desired or
needed. If bar has a security vulnerability, this allows
an attacker to compromise the client’s system.
• Endless Data This attack is performed by returning
an endless stream of data in response to any download
request. This may cause the package manager to ﬁll up
the disk or memory on the client and crash the client’s
system.
4. SECURITY OF PACKAGE MANAGERS
The security of a package manager varies depending on
how signatures are used to protect data. This section ex-
plores the security strengths and weakness of signatures on
diﬀerent data along with implementation pitfalls observed
in package managers (and how to ﬁx them). This section
then classiﬁes the security of diﬀerent signatures into a list
ordered by increasing security.
The discussion groups package managers with similar se-
curity characteristics together. The ﬁrst group of package
managers do not use signatures (Section 4.1). The second
group of package managers use signatures on packages but
do not use signatures on package metadata or root metadata
(Section 4.2). The third group of package managers use sig-
natures on package metadata but not on the root metadata
(Section 4.3). The ﬁnal group of package managers use sig-
natures on the root metadata (Section 4.4).
4.1 Package Managers Without Security
There are three popular package managers that do not
provide security: Pacman, ports1, and Slaktool. These pack-
age managers do not sign packages, package metadata, or the
root metadata ﬁle. As a result, any attacker that controls
a mirror can trivially launch an arbitrary package attack by
responding to client requests with malicious software.
• Replay Attack An attacker replays older versions of
correctly signed packages or metadata, causing clients