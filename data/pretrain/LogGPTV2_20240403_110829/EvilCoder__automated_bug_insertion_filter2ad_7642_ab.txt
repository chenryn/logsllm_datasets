e
n
l
y
l
l
a
i
t
n
e
t
o
p
d
n
F
i
l
u
v
Find security 
mechanisms
m
e
c
h
a
n
i
s
m
s
A
n
a
l
y
z
e
s
e
c
u
r
i
t
y
1. Invalidate security mechanisms: We can inten-
tionally weaken mechanisms, like sanitization or guard
statements, which protect a security sensitive API call.
This could mean to the protection altogether or to
modify a necessary length check to never trigger.
2. Using security anti patterns: We can leverage typ-
ical patterns of vulnerable code. For example, there
are a lot of faulty check patterns that do not actually
prevent and/or detect an integer overﬂow. One could
also transform printf("%s", buf) to printf(buf) to
introduce a format string vulnerability. Furthermore,
TOCTTOU races [3] could be introduced by altering
open()/access() or stat()/open() constructs.
We prevent syntactically incorrect code by applying our
instrumentations in a conservative manner, meaning that
we do not apply it if the speciﬁc instrumentation does not
“understand” every element of the security mechanism at
hand.
2.4 Workﬂow
Figure 1 shows the individual stages of our system, while
Listing 1 depicts a high-level description of our algorithm
for automatic insertion of security-critical bugs:
1. Preparing the analysis,
2. Enabling interprocedural analysis,
3. Finding potentially vulnerable paths and ﬁnally
4. Instrumenting potentially vulnerable paths to become
actually vulnerable.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
1
2
3
4
5
6
7
8
9
Listing 1: High-Level Description of our Algorithm for
Automatic Bug Insertion
Find a l l
s i n k s
f o r ( each found s e n s i t i v e
s e n s i t i v e
s i n k ) :
Trace data t o u s e r−c o n t r o l l e d s o u r c e
Find c o n t r o l
from s o u r c e t o s i n k
f l o w s
f o r ( each found c o n t r o l
f l o w ) :
Find r e l e v a n t
i f ( matches known v u l n e r a b i l i t y c l a s s ) :
s e c u r i t y mechanisms i n path
Find a p p l i c a b l e i n s t r u m e n t a t i o n s
Use randomly c h o s e n i n s t r u m e n t a t i o n
216
Listing 2: Running Example for Automatic Bug Insertion
i n t r e a d f r o m f i l e ( FILE ∗ f ) {
i n t l e n g t h ;
f r e a d ( ( c h a r ∗)& l e n g t h , s i z e o f ( i n t ) , 1 ,
r e t u r n l e n g t h ;
f ) ;
}
v o i d wrapper ( FILE ∗ f , i n t ∗ t h e l e n ) {
}
v o i d c o p y b u f f e r (
∗ t h e l e n = r e a d f r o m f i l e ( f ) ;
FILE ∗ f t r u e , FILE ∗ f
, c h a r ∗ buf , i n t w h i c h f i l e
, i n t u s e w r a p p e r ) {
f a l s e
i n t l e n ;
i f ( u s e w r a p p e r ) {
i f ( w h i c h f i l e ) wrapper ( f t r u e , &l e n ) ;
e l s e
wrapper ( f
f a l s e , &l e n ) ;
}
e l s e {
i f ( w h i c h f i l e )
e l s e
l e n = r e a d f r o m f i l e ( f t r u e ) ;
l e n = r e a d f r o m f i l e ( f
f a l s e ) ;
}
i f ( l e n > 2 5 6 ) {
p r i n t f ( " E R R O R : l e n i s t o o b i g . \ n " ) ;
e x i t ( 1 ) ;
}
c h a r l o c a l [ 2 5 6 ] ;
memcpy ( l o c a l , buf ,
memset ( buf , 0 , 5 1 2 ) ;
d o s o m e t h i n g w i t h ( l o c a l ) ;
l e n ) ;
}
Throughout this section, we will use the running example
depicted in Listing 2 to explain the individual steps. Es-
sentially, the shown program reads a length ﬁeld from a ﬁle
(line 3) and uses it to copy up to 256 bytes of data from
one buﬀer into another (line 30). Furthermore, it also in-
validates the original buﬀer (line 31) by calling memset().
For illustrative purposes, the function copy_buffer() has
switches to read from two diﬀerent ﬁles and optionally use a
wrapper function for doing so. While the function perform-
ing the reading returns the read value, the wrapper function
modiﬁes its argument to show another type of data transfer.
(cid:2)
(cid:3)
(cid:1)
(cid:1)
(cid:20)
(cid:19)
(cid:6)
(cid:18)
(cid:12)
(cid:7)
(cid:17)
(cid:18)
(cid:12)
(cid:17)
(cid:8)
(cid:3)
(cid:8)
(cid:15)
(cid:3)
(cid:16)
(cid:8)
(cid:3)
(cid:8)
(cid:1)
(cid:15)
(cid:14)
(cid:13)
(cid:2)
(cid:12)
(cid:2)
(cid:3)
(cid:12)
(cid:12)
(cid:4)
(cid:2)
(cid:11)
(cid:10)
(cid:3)
(cid:9)
(cid:6)
(cid:8)
(cid:7)
(cid:2)
(cid:1)
(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:5)
(cid:4)
(cid:3)
(cid:2)
(cid:1)
Figure 2: Topological sort of the functions in Listing 2
2.4.1 Preparing Analysis
Starting with the source code of the application, we ﬁrst
invoke the preprocessor to handle preprocessor directives,
which results in pure C source code.
In the next step,
we compute the code property graph [36] from the source
code. Essentially, this means to use robust, island-grammar-
based [27] parsing to put the source code into a graph database,
which represents the abstract syntax tree (AST), types, con-
trol ﬂow and data ﬂow as nodes and edges. All further anal-
ysis happens solely on this graph database and we only turn
to the source code ﬁles for later instrumentation.
2.4.2 Enabling Interprocedural Data Flow Analysis
The reference implementation of code property graphs
does not support interprocedural analysis out of the box.
This means for example that if a subfunction changes one of
its parameters, this is not reﬂected in the data-ﬂow graph of
the calling function, where the argument to the subfunction
should be marked as modiﬁed.
To rectify this, we ﬁrst compute the call graph of the appli-
cation. To establish which parameters a function modiﬁes,
it is necessary to know which subfunctions modify their pa-
rameters. Thus, we use a topological sorting of the graph
to analyze subfunctions ﬁrst. Figure 2 shows the exemplary
topological sort for the running example from Listing 2. In
this ﬁgure, all edges are left-facing, meaning that analyzing
the functions from left to right is a valid sequence. Once we
know which parameters a subfunction modiﬁes, the data-
ﬂow graph in the calling function can be adjusted accord-
ingly. Note that static analysis does not always allow to
precisely compute if parameters are modiﬁed or not, which
is why we allow a “maybe” state at this point.
In the running example, copy_buffer() has to be aug-
mented, because memset(), memcpy() and wrapper() each
modify one of their arguments. Furthermore, every function
calling copy_buffer() would have to be modiﬁed as well,
because it sets the value of buf.
In case of circular dependencies in the call graph, we follow
a best-eﬀort approach to break the circle by picking a func-
tion which has the least number of calls. We expect most
of those cases to stem from simple recursive functions (i. e.,
the circle has only two identical elements and it is irrelevant,
which is analyzed ﬁrst).
Naturally, we can only analyze code that is available, but
especially code from external libraries may not always be
present for analysis. Thus, we incorporate means to read
their parameter modiﬁcation status from a provided ﬁle. We
handle the standard C library glibc in this way, as it is
linked into virtually all C programs.
2.4.3 Finding Potentially Vulnerable Locations
Now that we have set up the source code for interproce-
dural analysis, recall that a taint-style vulnerability is de-
217
ﬁned by an insuﬃciently secured data ﬂow between a user-
controlled source and a sensitive sink. Thus, to insert a
vulnerability, we start by ﬁnding all sensitive sinks in the
application. For us, a sensitive sink is a certain parameter
of a given security-critical function, like the length ﬁeld of a
memcpy() in line 30 of Listing 2. Naturally, this depends on
the type of vulnerability: for buﬀer overﬂows, this could be
memcpy(), while for information leaks it could be printf().
To some extent, also functions like malloc() are sensitive,
as a user-controlled source deciding on the number of bytes
to allocate could easily lead to a denial of service attack or
maybe even cause more harm.
Next, we try to trace the data sources of a sensitive sink
to a user-controlled source. We currently deﬁne ﬁles, net-
work connections, command-line arguments, standard in-
put streams (stdin) and environment variables to be user-
controlled. Contrary to the sinks, the user-controlled sources
are not speciﬁc to the vulnerability, but to the application.
Our choice should cover most user-land use cases, but espe-
cially for kernels, where every piece of data from user-land
has to be regarded as potentially malicious, other functions
have to be added, such as copy_from_user() or get_user().
For now, we do not account for database interfaces, as the
types of interfaces are simply too diverse in practice. Note
that in contrast to bug ﬁnding, it is not necessary for bug in-
sertion to cover all possibilities, because a missed path does
not result in a vulnerability being undetected, but only in
one less opportunity for an inserted bug.
In the running example, possible data sources for the
length value in the memcpy() are in lines 16/17 (set by wrap-
per()), as well as in lines 20/21 (set by read_from_file()).