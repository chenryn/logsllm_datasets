### 优化后的文本

#### 4. 使用最先进的混淆工具
对于源代码混淆，我们使用了Semantic Designs Inc.的C语言混淆器，该工具基于抽象语法树（AST）进行代码转换。其功能包括但不限于标识符混淆、格式混淆、循环重写和if-then-else语句重写。对于二进制代码混淆，我们使用了基于Diablo链接时优化器[20]的Loco实现的控制流扁平化技术。控制流扁平化可以将语句`s1; s2;`转换为`i=1; while(i) { switch(i) { case 1: s1; i++; break; case 2: s2; i=0; break;}}`。我们使用这两种混淆器对之前使用的三个程序进行了混淆并编译。生成的可执行文件在相同的输入下运行，并记录了每个可执行文件的系统调用跟踪和SCDG。原始程序与混淆后的程序之间的系统调用跟踪和SCDG完全相同。这表明SCDG指纹对这两种最先进的混淆工具有很强的鲁棒性。

#### 5. 讨论
##### 5.1 鲁棒性
除了在第4.5节中测试的混淆技术外，SCDG指纹还对文献[11]中提到的大多数混淆技术具有鲁棒性，包括变量拆分或合并、标量提升为对象、静态数据转换为过程、编码更改、变量生命周期更改、数组拆分或合并、数组重新排序、循环展开、表达式重新排序、扩展循环条件、语句重新排序等。尽管这些技术可以显著改变源代码和二进制代码的外观，但它们不会改变系统调用及其依赖关系。因此，SCDG指纹对所有这些混淆技术都具有鲁棒性。

##### 5.2 对抗攻击
针对SCDG指纹的一种可能的对抗攻击是系统调用注入攻击。攻击者可以在抄袭程序中插入大量系统调用而不影响其原有行为。当使用较小的m值生成疑似指纹时，这种攻击可能会避免我们的检测。然而，这种攻击在实践中可能无效，因为：（1）这些注入的系统调用很可能会在噪声过滤阶段被滤除；（2）系统调用由于内核模式和用户模式之间的上下文切换非常昂贵。大量的注入系统调用会导致抄袭程序严重减速，从而阻止抄袭者使用这种攻击。此外，可以通过使用更大的m值来击败此类攻击。这是一个性能与鲁棒性之间的权衡。

另一种可能的对抗攻击是系统调用重排序攻击。虽然这种攻击会改变系统调用跟踪中的顺序，但它不会改变SCDG。只有当两个或多个系统调用之间没有依赖关系时，它们才能被重新排序。否则，重新排序可能会破坏依赖关系，导致行为变化或程序错误。因此，这种攻击无法逃避我们的检测。

可能存在其他彻底修改SCDG指纹的未知攻击。对于这些未知和意外的攻击，SCDG指纹在一定程度上仍然具有鲁棒性，因为它通过使用γ-同构可以容忍一定程度的修改。

##### 5.3 限制与未来工作
SCDG指纹存在以下基本限制。首先，如果感兴趣的程序不涉及任何系统调用或仅有很少的系统调用（例如，程序中只有算术运算），则SCDG指纹不适用。其次，对于没有独特系统调用行为的程序也不适用。例如，排序程序的行为只是读取未排序的文件并打印排序后的数据。这种行为在其他排序程序甚至无关程序中也很常见，因此不是唯一的。因此，我们的工具应谨慎使用，特别是对于仅有少量系统调用的小型通用程序。第三，作为检测系统，它具有入侵检测系统的同样限制，即存在误报和漏报之间的根本权衡。检测结果取决于用户定义的参数（m和γ）。为了获得更高的置信度，应使用较大的参数，但这可能会增加漏报。相反，减少这些参数可能会增加误报。不幸的是，由于缺乏大量实际的抄袭样本，我们无法展示具体的误报率，尽管我们已经展示了所研究的所有程序都存在SCDG指纹。因此，在实践中，与其用我们的工具“证明”软件抄袭，不如将其用于收集初步证据，然后再进行进一步调查，这些调查通常涉及非技术手段。

我们将在未来的工作中研究输入对SCDG指纹的影响。作为一种动态指纹，SCDG指纹要求原始程序和可疑程序使用相同的输入。这一要求有时难以满足。例如，一个软件抄袭者可能会非法使用实时计算机视觉库作为其运动理解软件的一部分，而原始程序则使用该库进行不同的目的，如面部识别。

我们还将研究软件组件版本升级对其指纹的影响。软件组件可能频繁更新，某些更新可能会显著改变组件的实现，包括完全重新设计编程接口。这些更改可能会使之前的指纹失效。这些更改是否有助于抄袭者通过窃取旧版本组件来逃避检测？为回答这个问题，我们将研究不同版本Gecko布局引擎的指纹相似性。

#### 6. 相关工作
我们将文献大致分为两类：软件指纹和克隆检测。

##### 软件指纹
有四类软件指纹：基于静态源代码的指纹[27]、基于静态可执行代码的指纹[22]、基于动态WPP的指纹[21]和基于动态API的指纹[26, 28]。

- **基于静态源代码的指纹**：Tamada等人[27]提出了四种类型的静态指纹：字段变量常量值指纹（CVFV）、方法调用序列指纹（SMC）、继承结构指纹（IS）和使用类指纹（UC）。这四种类型都容易受到[22]中提到的混淆技术的影响。此外，它们需要访问源代码且仅适用于面向对象编程语言。
- **基于静态可执行代码的指纹**：Myles和Collberg[22]提出了一种基于操作码级别的k-gram静态指纹。从程序中提取长度为k的操作码序列，并利用k-gram技术（最初用于文档相似性检测）应用于操作码序列。尽管k-gram静态指纹比Tamada的指纹更鲁棒，但它仍然容易受到一些常见的混淆技术的影响，如语句重新排序、垃圾指令插入和其他语义保持的转换技术（如编译器优化）。
- **基于动态WPP的指纹**：Myles和Collberg[21]提出了一种基于全程序路径（WPP）的动态指纹。WPP最初用于表示程序的动态控制流。WPP指纹对某些控制流混淆技术（如不透明预测）具有鲁棒性，但仍然容易受到许多语义保持的转换技术（如循环展开）的影响。此外，WPP指纹可能不适用于大规模程序，因为WPP跟踪的数量可能非常庞大。
- **基于动态API的指纹**：Tamada等人[28, 29]还为Windows应用程序引入了两种动态指纹：API函数调用序列指纹（EXESEQ）和API函数调用频率指纹（EXEFREQ）。在EXESEQ中，记录程序执行期间的Windows API调用序列，并直接比较这些序列以找到相似性。在EXEFREQ中，记录程序执行期间每个Windows API调用的频率，并使用频率分布作为指纹。Schuler等人[26]提出了一种用于Java的动态指纹。记录Java标准API调用序列，并使用对象级短序列作为指纹。他们的实验表明，在评估中API指纹比WPP指纹更鲁棒。与Java或Windows API指纹不同，系统调用指纹可以在任何平台上使用。此外，系统调用指纹比API指纹更能抵御对抗攻击。为了逃避API指纹，攻击者可能会通过嵌入自己的API例程实现来隐藏API调用。然而，没有简单的方法可以替换“系统调用”，因为系统调用是现代操作系统中获取特权的唯一方式。更重要的是，现有的API指纹尚未经过保护核心组件盗窃的评估。

##### 克隆检测
与软件指纹密切相关的一个研究领域是克隆检测。克隆检测是一种在大规模程序中查找重复代码（“克隆”）的技术。现有的克隆检测技术可以分为四类：基于字符串的[5]、基于AST的[7, 17]、基于Token的[15, 24, 25]和基于PDG的[18, 19]。

除了用于减小代码大小和便于维护外，克隆检测还可以用于检测软件抄袭。然而，现有的克隆检测技术对代码混淆并不鲁棒。基于字符串的方案即使只是简单地重命名程序中的标识符也非常脆弱。基于AST的方案对标识符重命名具有鲁棒性，但对语句重新排序和控制替换较弱。基于Token的方案对标识符重命名具有鲁棒性，但对垃圾代码插入和语句重新排序较弱。由于PDG包含程序的语义信息，基于PDG的方案比其他三种现有方案更鲁棒。然而，基于PDG的方案仍然容易受到许多语义保持的转换技术（如控制流扁平化和不透明谓词）的影响。此外，所有克隆检测技术都需要访问源代码。

#### 7. 结论
本文提出了SCDG软件指纹，并通过一组实际程序对其进行了评估。实验结果表明，所有由两种最先进的工具混淆的抄袭都能成功区分。与现有方案仅用小型或玩具软件进行评估不同，我们使用了一组大规模软件对我们的指纹进行了评估。结果表明，SCDG指纹在检测大规模程序组件盗窃方面是有效且实用的。

#### 8. 致谢
作者感谢根特大学的Jonas Maebe在编译和使用Loco和Diablo方面的帮助；感谢Semantic Designs, Inc.捐赠的C/C++混淆器。Wang和Zhu的工作得到了NSF-0643906的支持。Jhi和Liu的工作部分得到了AFOSR MURI拨款FA9550-07-1-0527、ARO MURI：计算机辅助的人为中心的网络态势感知以及NSF CNS-0905131的支持。

#### 9. 参考文献
[略]

希望这些改进能让你的文本更加清晰、连贯和专业！