of-the-art obfuscation tools. For source code obfuscation, we
used the commercial product Semantic Designs Inc’s C ob-
fuscator that implements abstract syntax tree (AST) based
code transformation. Its features include (but not limited
to) identiﬁer scrambling, format scrambling, loop rewriting,
and if-then-else rewriting. For binary code obfucation, we
used control ﬂow ﬂattening implemented in Loco based on
Diablo link-time optimizer [20]. Control ﬂow ﬂattening can
transform statements ‘s1; s2;’ into ‘i=1; while(i) { switch(i)
{ case 1: s1; i++; break; case 2: s2; i=0; break;}}’. We
used the two obfuscators to obfuscate and then compile each
of the three programs we used before. The generated exe-
cutables were executed with the same input and a system
call trace and SCDG were recorded for the each executable.
The system call traces and SCDGs between the original pro-
grams and obfuscated programs are exactly the same. This
results show that SCDG birthmark is robust to these two
state-of-the-art obfuscation tools.
5. DISCUSSION
5.1 Robustness
Besides those tested obfuscations in Section 4.5, SCDG
birthmark is robust to most types of obfuscation techniques
presented in [11] including split or merge variables, promote
scalars to objects, convert static data to procedure, change
encoding, change variable life, split or merge arrays, reorder
arrays, unroll loop, reorder expression, extend loop condi-
tion, reorder statements and so on. Although they can sig-
niﬁcantly alter the source code and binary code appearance,
they do not change system calls and dependence relations
between system calls. As a consequence, SCDG birthmark
is robust to the all these obfuscations.
5.2 Counterattacks
One of the possible counterattacks to SCDG birthmark is
the system call injection attack. An attacker may insert a
great number of system calls in the plagiarism program with-
out compromising its original behaviors. This counterattack
may avoid our detection when a small m is used for gener-
ating suspect birthmarks. However, this counterattack may
not work in practice because (1) these injected system calls
will most likely be ﬁltered out in the noise ﬁltering phase,
and (2) system calls are very costly due to context switching
between the kernel mode and the user mode. A large num-
ber of injected system calls will result in great slowdown of
the plagiarism program, which thwart a plagiarist from us-
ing this counterattack. Moreover, a bigger m can be always
used to defeat such counter attacks. It is a tradeoﬀ between
performance and robustness.
Another possible counterattack is the system call reorder
attack. Although this attack changes the order of system
calls in traces, it leaves SCDGs unaltered. Two or more sys-
tem calls can be reordered only when they are not bounded
by dependences. Otherwise, reordering could break depen-
dences, and thus cause behavior change or program errors.
As such, this counterattack can not evade our detection.
There may exist other counterattacks which overhaul SCDG
birthmarks. For these unknown and unexpected attacks,
SCDG birthmark is still robust to some extent, because it
is tolerant to a certain percentage overhauling by using γ-
isomorphism.
5.3 Limitations and Future Work
SCDG birthmark bears the following fundamental limita-
tion. First, it will not apply if the program of interest does
not involve any system calls or has very few system calls,
for example, when there are only arithmetic operations in
the program. Second, it is not applicable to the programs
which do not have unique system call behaviors. For ex-
ample, the only behavior of a sorting program is to read
an unsorted ﬁle and print the sorted data. This behavior,
which is common to other sorting programs or even irrel-
evant programs, is not unique. As such, our tool should
be used with caution, especially for tiny common programs
with few system calls. Third, as a detection system, it bears
the same limitation of intrusion detection systems; that is,
there exists a fundamental tradeoﬀ between false positives
and false negatives. The detection result of our tool de-
pends on the parameters (m and γ) a user deﬁnes. To have
higher conﬁdence, one should use large parameters, thus it is
likely to increase false negative. In contrast, reducing these
parameters may increase false positive. Unfortunately, with-
out many real-world plagiarism samples, we are unable to
show some concrete results on such false rates although we
have showed SCDG birthmarks exist for all the programs we
studied. As such, rather than applying our tool to “prove”
software plagiarisms, in practice one may use it to collect
some initial evidences before taking further investigations,
which often involve nontechnical actions.
We will study the impact of input on SCDG birthmarks as
our future work. As a dynamic birthmark, SCDG birthmark
requires the original program and the suspicious program to
be fed with the same input. This requirement sometimes
is diﬃcult to meet. For example, a software plagiarist may
illegally use a real time computer vision library as a part
of their motion understanding software, whereas the origi-
nal program uses the library for diﬀerent purposes, say face
recognition.
We will also examine how the birthmark of a component
changes over software versions. A component of software
might be upgraded frequently; some updates may change the
implementation of the component signiﬁcantly, which may
include totally redesigned programming interfaces. These
changes can invalidate the birthmarks computed before the
updates. Will these changes help a plagiarist evade the de-
tection by stealing an old version of the component? To an-
swer this question, we will investigate the similarity of the
birthmarks of diﬀerent versions of the Gecko layout engine
in the future.
6. RELATED WORK
We roughly group the literature into two categories: soft-
ware birthmark and clone detection.
Software Birthmark: There are four classes of software
birthmark: static source code based birthmark [27], static
executable code based birthmark [22], dynamic WPP based
birthmark [21], and dynamic API based birthmark [26, 28].
Static source code based birthmark: Tamada [27] et al.
proposed four types of static birthmark: Constant Values
in Field Variables Birthmark (CVFV), Sequence of Method
Calls Birthmark (SMC), Inheritance Structure Birthmark
(IS) and Used Classes Birthmark (UC). All of the four types
are vulnerable to obfuscation techniques mentioned in [22].
In addition, they need to access source code and only work
for object-oriented programming language.
Static executable code based birthmark: Myles and Coll-
berg [22] proposed a opcode-level k-gram based static birth-
mark. Opcode sequences of length k are extracted from
a program and k-gram techniques which were used to de-
tect similarity of documents are exploited to the opcode se-
quences. Although the k-gram static birthmark is more ro-
bust than Tamadas birthmark, it is still strongly vulnerable
to some well-known obfuscations such as statement reorder-
ing, junk instruction insertion and other semantic-preserved
transformation techniques such as compiler optimization.
Dynamic WPP based birthmark: Myles and Collberg [21]
proposed a whole program path (WPP) based dynamic birth-
mark. WPP is originally used to represent the dynamic con-
trol ﬂow of a program. WPP birthmark is robust to some
control ﬂow obfuscations such as opaque prediction, but is
still vulnerable to many semantic-preserving transformation
such as loop unwinding. Moreover, WPP birthmark may not
work for large-scale programs due to overwhelming volume
of WPP traces.
Dynamic API based birthmark: Tamada et al. [28,29] also
introduced two types of dynamic birthmark for Windows
applications: Sequence of API Function Calls Birthmark
(EXESEQ) and Frequency of API Function Calls Birth-
mark (EXEFREQ). In EXESEQ, the sequence of Windows
API calls are recorded during the execution of a program.
These sequences are directly compared to ﬁnd similarity. In
EXEFREQ, the frequency of each Windows API calls are
recorded during the execution of a program. The frequency
distribution is used as the birthmark. Schuler et al. [26]
proposed a dynamic birthmark for Java. The call sequences
to Java standard API are recorded and the short sequences
at object level are used as a birthmark. Their experiments
showed that API birthmarks are more robust to obfuscation
than WPP birthmark in their evaluation. Unlike the Java
or Windows API based birthmarks that are platform depen-
dent, system call birthmarks can be used on any platform. In
addition, system call birthmarks are more robust to counter-
attacks than API-based ones. To evade API-based birth-
marks, attackers may hide API calls by embedding their
own implementation of some API routines. However, there
are no easy ways to replace “system calls” without recom-
piling the kernel because because system call is the only
way to gain privilege in modern operating systems. More
importantly, existing API-based birthmarks have not been
evaluated to protect core components theft.
Clone Detection: A close research ﬁeld to software birth-
mark is clone detection. Clone detection is a technique to
ﬁnd the duplicate code (“clones”) in a large-scale program.
Existing techniques for clone detection can be classiﬁed as
four categories: String-based [5], AST-based [7, 17], Token-
based [15, 24, 25] and PDG-based [18, 19].
Besides to be used to decrease code size and facilitate
maintenance, clone detection can be also be used to de-
tect software plagiarism. However, existing clone detection
techniques are not robust to code obfuscation. String-based
schemes are fragile even by simply renaming identiﬁers in
programs. AST-based schemes are resilient to identiﬁer re-
naming, but weak against statement reordering and control
replacement. Token-based schemes are resilient to identiﬁer
renaming, but weak against junk code insertion and state-
ment reordering. Because PDGs contain semantic infor-
mation of programs, PDG-based schemes are more robust
than the other three types of existing schemes. However,
PDG-based is still vulnerable to many semantics-preserving
transformations such as control ﬂow ﬂattening and opaque
predicates. Moreover, all clone detection techniques need to
access source code.
7. CONCLUSION
In this paper, we proposed the SCDG software birthmark.
We evaluated it with a set of real world programs. Our ex-
periment results showed that all the plagiarisms obfuscated
by the two state-of-the-art tools were successfully discrimi-
nated. Unlike existing schemes that are evaluated with small
or toy software, we evaluate our birthmarks with a set of
large-scale software. The results showed that SCDG Birth-
mark is eﬀective and practical in detection of components
theft of large-scale programs.
8. ACKNOWLEDGMENT
The authors would like to thank Jonas Maebe of Univer-
sity of Ghent for his help in compiling and using Loco and
Diablo; Semantic Designs, Inc.
for donating C/C++ ob-
fuscators. The work of Wang and Zhu was supported by
CAREER NSF-0643906. The work of Jhi and Liu was sup-
ported in part by AFOSR MURI grant FA9550-07-1-0527,
ARO MURI: Computer-aided Human Centric Cyber Situa-
tion Awareness, and NSF CNS-0905131.
9. REFERENCES
[1] [online]Available from World Wide Web: http:
//news.zdnet.com/2100-3513_22-5629876.html.
[2] Elsa: An elkhound-based c++ parser,
http://www.cs.berkeley.edu/~smcpeak/elkhound.
[3] The gecko engine, http:
//en.wikipedia.org/wiki/Gecko_layout_engine.
[4] Khtml engine, http://en.wikipedia.org/wiki/KHTML.
[5] B. S. Baker. On ﬁnding duplication and near
duplication in large software systems. In Proc. of 2nd
Working Conf. on Reverse Engineering, 1995.
[6] H. G. Baker. Minimizing reference count updating
with deferred and anchored pointers for functional
data structures. ACM SIGPLAN Notices, 29:29–9,
1994.
[7] I. D. Baxter, A. Yahin, L. Moura, M. Sant’Anna, and
L. Bier. Clone detection using abstract syntax trees.
In Int. Conf. on Software Maintenance, 1998.
[8] M. Christodorescu, S. Jha, and C. Kruegel. Mining
speciﬁcations of malicious behavior. In Proceedings of
ESEC/FSE, 2008.
[16] E. Kirda, C. Kruegel, G. Banks, G. Vigna, and R. A.
Kemmerer. Behavior-based spyware detection. In
Proceedings of the 15th conference on USENIX
Security Symposium, 2006.
[17] K. Kontogiannis, M. Galler, and R. DeMori. Detecting
code similarity using patterns. In Working Notes of
3rd Workshop on AI and Software Engineering, 1995.
[18] J. Krinke. Identifying similar code with program
dependence graphs. In Proc. of 8th Working Conf. on
Reverse Engineering, 2001.
[19] C. Liu, C. Chen, J. Han, and P. S. Yu. Gplag:
detection of software plagiarism by program
dependence graph analysis. In Proceedings of the 12th
ACM SIGKDD international conference on Knowledge
discovery and data mining, 2006.
[20] M. Madou, L. Van Put, and K. De Bosschere. Loco:
An interactive code (de)obfuscation tool. In
Proceedings of ACM SIGPLAN 2006 Workshop on
Partial Evaluation and Program Manipulation (PEPM
’06), pages 140–144, 2006.
[21] G. Myles and C. Collberg. Detecting software theft via
whole program path birthmarks. In ISC, pages
404–415, 2004.
[22] G. Myles and C. S. Collberg. K-gram based software
birthmarks. In SAC, 2005.
[23] N. Nethercote and J. Seward. Valgrind: a framework
for heavyweight dynamic binary instrumentation. In
Proceedings of the 2007 ACM SIGPLAN conference
on Programming language design and implementation.
[24] L. Prechelt, G. Malpohl, and M. Philippsen. Finding
plagiarisms among a set of programs with jplag.
Universal Computer Science, 2000. Available from
World Wide Web: citeseer.ist.psu.edu/article/
prechelt01finding.html.
[25] S. Schleimer, D. S. Wilkerson, and A. Aiken.
Winnowing: local algorithms for document
ﬁngerprinting. In Proc. of ACM SIGMOD Int. Conf.
on Management of Data, 2003.
[9] C. Collberg, E. Carter, S. Debray, A. Huntwork,
[26] D. Schuler, V. Dallmeier, and C. Lindig. A dynamic
C. Linn, and M. Stepp. Dynamic path-based software
watermarking. In Proceedings of the Conference on
Programming Language Design and Implementation,
2004.
[10] C. Collberg and C. Thomborson. Software
watermarking: Models and dynamic embeddings. In
Principles of Programming Languages 1999, Jan. 1999.
[11] C. Collberg, C. Thomborson, and D. Low. A
taxonomy of obfuscating transformations. Technical
Report 148, The Univeristy of Auckland, July 1997.
[12] C. Hoﬀman. Group-theoretic Algorithms and Graph
Isomorphism. Springer Verlag, 1982.
birthmark for java. In ASE ’07: Proceedings of the
twenty-second IEEE/ACM international conference on
Automated software engineering, 2007.
[27] H. Tamada, M. Nakamura, A. Monden, and K. ichi
Matsumoto. Design and evaluation of birthmarks for
detecting theft of java programs. In Proc. IASTED
International Conference on Software Engineering,
2004.
[28] H. Tamada, K. Okamoto, M. Nakamura, and
A. Monden. Dynamic software birthmarks to detect
the theft of windows applications. In International
Symposium on Future Software Technology 2004.
[13] J. E. Hopcroft and J. K. Wong. Linear time algorithm
[29] H. Tamada, K. Okamoto, M. Nakamura, A. Monden,
for isomorphism of planar graphs. In ACM Symp. on
Theory of Computing, 1974.
[14] J. E. Hopcroft and J. K. Wong. Performance
evaluation of the vf graph matching algorithm. In
Processing of 10th Int. Conf. on Image Analysis and
Processing, 1999.
[15] T. Kamiya, S. Kusumoto, and K. Inoue. Ccﬁnder: a
multilinguistic token-based code clone detection
system for large scale source code. IEEE Trans. Softw.
Eng., 28(7), 2002.
and K. ichi Matsumoto. Design and evaluation of
dynamic software birthmarks based on api calls.
Technical report, Nara Institute of Science and
Technology, 2007.
[30] J. R. Ullmann. An algorithm for subgraph
isomorphism. Journal of the ACM, 23(1):31–42, 1976.
[31] X. Zhang, S. Tallam, and R. Gupta. Dynamic slicing
long running programs through execution fast
forwarding. In Processing of 14th ACM SIGSOFT
Symposium on Foundations of Softw. Eng., 2006.