we did not encounter a single popular library that had a
dedicated mailing list for security announcements (in fact,
most libraries we investigated did not have a mailing list for
announcements at all). Furthermore, only a few JavaScript
library developers provide a dedicated email address where
users can submit vulnerability reports. When the release notes
of libraries mention at all that a vulnerability has been ﬁxed,
they often do not provide any details about the affected code, or
which prior versions are vulnerable. This is problematic because
web developers using that library do not know whether the
vulnerable code is a function that they depend on, and whether
an update is required. Libraries can even silently reintroduce
vulnerabilities in order to remain backwards-compatible [12].
Although jQuery is an immensely popular library, the fact
that searching for “security” or “vulnerability” in the ofﬁcial
learning centre returns “Apologies, but nothing matched your
search criteria” is an excellent summary of the state of
JavaScript library security on the Internet, circa August 2016.
A similar lack of adequate information about security issues
has also been reported for the Android library ecosystem [3].
An additional complication is that patches are often supplied
only for the most recent versions of a library. Yet, these versions
are not necessarily backwards-compatible with the versions still
in use by many web developers. In fact, the short development
lifecycle common in web development can become a burden
for developers who need to keep up with frequent breaking
changes in libraries in order to maintain their websites up to
date and free of vulnerable libraries.
Third-Party Components: We observed that libraries in-
cluded by third-party components such as advertising, tracking
or social media widget code have a higher rate of vulnerability
than other inclusions. Such components are often hosted on
third-party servers and loaded dynamically through client-
side JavaScript. Additional libraries loaded at runtime by
these components do not appear in the website’s codebase,
and web developers may be unaware that they are indirectly
including vulnerable code into their website. Similarly, dynamic
inclusions of libraries by third-party components may explain
some of the same-document duplicate inclusions that we noticed.
In addition to keeping their library dependencies up to date,
developers of web services meant to be included into other
websites could avoid replacing an existing library instance
by using a methodology similar to ours to test whether the
library has already been loaded into the page before adding
their own copy. On the other hand, web developers who intend
to use third-party components such as advertising code for their
website can attempt to limit potential damage by isolating these
components in separate frames whenever this is feasible.
VI. RELATED WORK
Our work is related to prior studies on JavaScript security,
measurements of vulnerability patching and dependency man-
agement, a series of blog posts about inclusions of vulnerable
libraries that inspired our more in-depth analysis, and existing
tools that implement a subset of our detection methodology.
JavaScript Security: In [22], Nikiforakis et al. identify
the network sources of JavaScript inclusions in the Alexa
Top 10 k websites, without special consideration for libraries
or corresponding versioning semantics, and develop host-based
metrics for maintenance quality to assess whether remote code
providers could be compromised by attackers and subsequently
serve malicious JavaScript. Whereas Nikiforakis et al. study
where included code is hosted, we focus on the narrower but
semantically richer setting of libraries to investigate whether
included code is outdated or known to be vulnerable, and we
leverage our deep browser instrumentation to determine the
initiators and causes of such inclusions.
A separate class of related work examines speciﬁc at-
tack vectors in client-side JavaScript and conducts crawls
to estimate how many websites are subject to the attack:
Lekies and Johns [16] survey insecure usage of JavaScript’s
localStorage() function for code caching purposes, Son
and Shmatikov [31] examine vulnerabilities arising from
unsafe uses of the postMessage() function, Lekies et
al. [17] detect and validate DOM-based XSS vulnerabilities,
and Richards et al. [29] analyse websites’ usage patterns
of the problematic eval() API. Yue and Wang [39] study
several insecure practices related to JavaScript, namely cross-
domain inclusion of scripts as well as the execution and
rendering of dynamically generated JavaScript and HTML
through eval() and document.write(), respectively. Li
et al. [18] detect malicious redirection code hidden in JavaScript
ﬁles on compromised hosts by deriving signatures from the
differences between infected library ﬁles and the original,
benign copies. In contrast to the above work, we do not focus
on speciﬁc vulnerabilities, the use of security-critical functions,
or malicious ﬁles. Instead, we provide empirical results at a
more abstract level to highlight and explain the prevalence of
benign-but-vulnerable JavaScript libraries in the wild.
13
Vulnerability and Dependency Management: Four stud-
ies have examined vulnerability patching and dependency
management in large software ecosystems, although not with
respect to JavaScript or the Web. Sonatype Inc., the company
behind Maven, released a report [32] examining security
maintenance practices observed from the vantage point of
the largest repository of Java components. According to the
report, the mean time-to-repair of a security vulnerability in
component dependencies is 390 days, 51,000 of the components
in the repository have known security concerns, and 6.2 % of
downloaded components include known vulnerabilities. A key
observation in the report is that ﬁxing serious ﬂaws in open
source code does not stop vulnerable versions from being used.
Our work in this paper shows that there are similar trends with
respect to JavaScript library usage on the Web.
Nappa et al. analyse the patch deployment process for
1,593 vulnerabilities in 10 applications installed on 8.4 million
Windows hosts worldwide [21]. The authors show that the time
until a patch is released for different applications affected by
the same vulnerability in a shared library can differ by up to
118 days, with a median of 11 days. Furthermore, patching
rates vary among applications and depend, among other factors,
on the update mechanism. At most 14 % of vulnerable hosts
are patched before an exploit is released.
Thomas et al. propose an exponential decay model to
estimate patching delays of Android devices [35]. According
to the model, when a new version of the operating system is
released, it takes 3.4 years to reach 95 % of the devices.
Backes et al. build LIBSCOUT [3], a system to detect
third-party library code in Android applications using a static
approach based on abstracted package trees and method
signatures. They ﬁnd that 70.4 % of library inclusions in their
dataset include an outdated version, and it takes developers
an average of almost one year to migrate their applications to
a newer library version after the library has been updated. In
a case study of two vulnerabilities, the authors show that the
average update delay is 59 and 188 days after the library patch is
ﬁrst made available, while some applications remain without any
update. Furthermore, 10 out of 39 advertising libraries contain
one or more versions that improperly use cryptographic APIs.
In contrast to LIBSCOUT, our detection approach requires that
the library API methods used in our signatures not be renamed
or removed. While a theoretical possibility, we believe that such
eager miniﬁcation settings are exceedingly rare on the Web
since they would necessitate processing all code potentially
referencing the library, including in HTML attributes and inline
script. To the best of our knowledge, the default settings of
miniﬁers typically do not rename methods or remove dead
code in client-side JavaScript (see, for instance, the Closure
Compiler [9]). This assumption allows us to detect the version
of a JavaScript library more reliably since most libraries self-
identify via their version attribute or method.
Blog Posts: In 2014, a series of blog posts by Oftedal ([24],
[25], [26]) raised awareness about the use of outdated JavaScript
libraries on the Web, and the fact that many large companies
(including banks) use versions that are known to be vulnerable.
We complement this ﬁrst exploration of the issue with a more
comprehensive detection methodology and a more detailed
analysis. To the best of our knowledge, we are the ﬁrst to report
on the modality and causes of JavaScript library inclusions in
websites, uncovering issues such as duplicate library inclusions
as well as transitive (and on average more vulnerable) inclusions
of libraries by third-party modules such as advertising, tracking,
and social media widget code.
Tools: From the point of view of our library detection
methodology, we are aware of two open source tools with a
similar approach: Retire.js and the Library Detector extension.
Library Detector Chrome Extension. This browser exten-
sion [20] aims to detect the JavaScript libraries running on a
website. It injects a script into the website’s main document
to test for the presence of known libraries and extracts their
version, using dynamic detection code similar to the approach
presented in Section III-B. The extension does not warn against
known vulnerabilities, does not reveal how or why a library
was included, cannot reliably detect duplicate inclusions, and
does not analyse libraries loaded in frames.
Retire.js. Along with his blog posts, Oftedal released a tool [27]
to help web developers detect JavaScript libraries with known
vulnerabilities. In a nutshell, Retire.js is a browser extension
that intercepts network requests for JavaScript ﬁles while
a website is loading and detects libraries based on known
ﬁle hashes, regular expressions over the ﬁle contents, and
API method signatures dynamically evaluated in an empty
sandbox environment. While we also use dynamic detection
and hash detection approaches in our methodology, Retire.js
makes several simpliﬁcations that limit the tool’s utility for
our analysis. First, detecting a script as a library in an empty
sandbox fails when the library has unmet dependencies. jQuery-
UI, for instance, requires jQuery and hence cannot be detected
dynamically if jQuery is not present in the environment. Second,
intercepting requests only at the network level may miss inline
scripts, dynamically evaluated scripts, and duplicate inclusions
of cached scripts. Most importantly, Retire.js does not reveal
why a library was included, that is, whether the inclusion was
caused by advertising code, for instance. We support all of
these scenarios and found interesting results as a consequence,
such as the vulnerability rates per inclusion type in Table V,
and the duplicate inclusions observed in Section IV-G.
VII. CONCLUSION
Third-party JavaScript libraries such as Angular, Bootstrap
and jQuery are are frequently used on websites today. While
such libraries allow web developers to create highly interactive,
visually appealing websites, vulnerabilities in these libraries
might increase the attack surface of the websites that depend
on them. Hence, it is very important to ensure that only recent,
patched versions of these libraries are being utilised.
In this paper, we presented the ﬁrst comprehensive study on
the security implications surrounding JavaScript library usage
on real-world websites. We found that:
•
87.7 % of ALEXA Top 75 k websites and 46.5 % of
COM websites use at least one of the 72 JavaScript
libraries in our catalogue (Section IV-C);
• more than 37 % of websites use at least one library
version with a known vulnerability, and vulnerable
inclusions can account for a signiﬁcant portion of all
observed inclusions of a library (Section IV-D);
14
•
•
•
•
the median lag between the oldest library version used
on each website and the newest available version of
that library is 1,177 days in ALEXA and 1,476 days
in COM (Section IV-F), and development of some
libraries still in active use ceased years ago;
surprisingly often, libraries are not referenced directly
in a page, but also inlined, or included transitively by
other content such as advertising, tracking or social
media widget code (Table IV), and those inclusions
have a higher rate of vulnerability than other, direct
inclusions (Table V, Section IV-E);
composition of content modules or third-party content
in the same document can lead to duplicate inclusions
of a library and potentially nondeterministic behaviour
with respect to vulnerability (Section IV-G);
remediation efforts are hindered by a lack of backwards-
compatible patches (Section IV-H) and, more generally,
scant availability of information (Section V).
The results of this work highlight the need for more
library
thorough and systematic approaches to JavaScript
inclusion and dependency management on the Web.
The causality trees shown in this work can be viewed online:
https://seclab.ccs.neu.edu/static/projects/javascript-libraries/
ACKNOWLEDGEMENTS
This work was supported by the National Science Founda-
tion under grants CNS-1409738 and CNS-1563320.
REFERENCES
[1] S. Arshad, A. Kharraz, and W. Robertson, “Include Me Out: In-Browser
Detection of Malicious Third-Party Content Inclusions,” in Proc. of Intl.
Conf. on Financial Cryptography, 2016.
“Auditjs: Audits an NPM package.json ﬁle to identify known vulnera-
bilities,” GitHub, https://github.com/OSSIndex/auditjs.
[2]
[3] M. Backes, S. Bugiel, and E. Derr, “Reliable Third-Party Library
Detection in Android and its Security Applications,” in Proc. of CCS,
2016.
[4] A. Barth, C. Jackson, and J. C. Mitchell, “Robust Defenses for Cross-Site
Request Forgery,” in Proc. of CCS, 2008.
[5] M. A. Bashir, S. Arshad, W. Robertson, and C. Wilson, “Tracing
Information Flows Between Ad Exchanges Using Retargeted Ads,” in
Proc. of USENIX Security Symposium, 2016.
“Bower: A package manager for the web,” https://bower.io/.
[6]
[7] A. Cahn, S. Alfeld, P. Barford, and S. Muthukrishnan, “An Empirical
[8]
[9]
Study of Web Cookies,” in Proc. of WWW, 2016.
“Chrome Debugging Protocol,” https://developer.chrome.com/devtools/
docs/debugger-protocol.
“Closure Compiler Compilation Levels,” April 2015, https://developers.
google.com/closure/compiler/docs/compilation_levels.
[10] P. Gill, V. Erramilli, A. Chaintreau, B. Krishnamurthy, K. Papagiannaki,
and P. Rodriguez, “Follow the Money: Understanding Economics of
Online Aggregation and Advertising,” in Proc. of IMC, 2013.
“Google Hosted Libraries,”
libraries/, July 2016.
https://developers.google.com/speed/
[11]
[13]
[14]
[12] M. Heiderich, “jQuery Migrate is a Sink, too?! or How jQuery Migrate
un-ﬁxes a nasty DOMXSS without telling us.” April 2013, http://blog.
mindedsecurity.com/2013/04/jquery-migrate-is-sink-too.html.
jQuery, “Write less, do more.” 2016, https://jquery.com/.
“#9521 (XSS with $(location.hash) and $(#) is needed?) – jQuery
– Bug Tracker,” https://bugs.jquery.com/ticket/9521, June 2011.
[15]
“jQuery() | jQuery API Documentation,” https://api.jquery.com/jQuery/.
[16] S. Lekies and M. Johns, “Lightweight Integrity Protection for Web
Storage-driven Content Caching,” in 6th Workshop on Web 2.0 Security
and Privacy (W2SP 2012), 2012.
[17] S. Lekies, B. Stock, and M. Johns, “25 Million Flows Later – Large-scale
Detection of DOM-based XSS,” in Proc. of CCS, 2013.
[18] Z. Li, S. Alrwais, X. Wang, and E. Alowaisheq, “Hunting the Red Fox
Online: Understanding and Detection of Mass Redirect-Script Injections,”
in Proc. of IEEE Symposium on Security and Privacy, 2014.
“McAfee SmartFilter,” https://www.trustedsource.org/en/feedback/url?
action=checklist.
J. Michel, “Library Detector for Chrome,” GitHub, April 2016, https:
//github.com/johnmichel/Library-Detector-for-Chrome.
[19]
[20]
[21] A. Nappa, R. Johnson, L. Bilge, J. Caballero, and T. Dumitras, “The
Attack of the Clones: A Study of the Impact of Shared Code on
Vulnerability Patching,” in Proc. of IEEE Symposium on Security and
Privacy, 2015.
[22] N. Nikiforakis, L. Invernizzi, A. Kapravelos, S. Van Acker, W. Joosen,
C. Kruegel, F. Piessens, and G. Vigna, “You Are What You Include:
Large-scale Evaluation of Remote JavaScript Inclusions,” in Proc. of
CCS, 2012.
“NPM: The Node Package Manager,” https://www.npmjs.com/.
[23]
[24] E. Oftedal, “Scanning Alexa Top 100,000 for JavaScript libraries
with known vulerabilities,” February 2014, http://erlend.oftedal.no/blog/
?blogid=142.
[25] E. Oftedal, “Scanning Fortune 500 for JavaScript libraries with known
vulerabilities,” February 2014, http://erlend.oftedal.no/blog/?blogid=143.
[26] E. Oftedal, “Scanning Norway for JavaScript libraries,” January 2014,
http://erlend.oftedal.no/blog/?blogid=140.
[27] E. Oftedal, “Retire.js,” GitHub, April 2016, https://github.com/RetireJS/
retire.js.
[28] T. Preston-Werner, “Semantic Versioning 2.0.0,” http://semver.org/.
[29] G. Richards, C. Hammer, B. Burg, and J. Vitek, “The Eval That Men
Do,” in Proc. of ECOOP, 2011.
[30] P. Saxena, S. Hanna, P. Poosankam, and D. Song, “FLAX: System-
atic Discovery of Client-side Validation Vulnerabilities in Rich Web
Applications,” in Proc of NDSS, 2010.
[31] S. Son and V. Shmatikov, “The Postman Always Rings Twice: Attacking
and Defending postMessage in HTML5 Websites,” in Proc of NDSS,
2013.
[32] Sonatype, “The 2015 State of the Software Supply Chain Report: Hidden
Speed Bumps on the Road to “Continuous”,” Sonatype.com, 2015.
“SWFObject,” GitHub, https://github.com/swfobject/swfobject.
[33]
[34] Y. Takamatsu, Y. Kosuga, and K. Kono, “Automated Detection of Session
Fixation Vulnerabilities (Poster),” in Proc. of WWW, 2010.
[35] D. R. Thomas, A. R. Beresford, T. Coudray, T. Sutcliffe, and A. Taylor,
“The Lifetime of Android API Vulnerabilities: Case Study on the
JavaScript-to-Java Interface,” Lecture Notes in Computer Science, vol.
9379, 2015.
[36] P. Vogt, F. Nentwich, N. Jovanovic, C. Kruegel, E. Kirda, and G. Vigna,
“Cross-Site Scripting Prevention with Dynamic Data Tainting and Static
Analysis,” in Proc of NDSS, 2007.
[37] W3C, “Subresource Integrity,” https://www.w3.org/TR/SRI/, May 2016.
[38] Wappalyzer, “Sites using JavaScript Frameworks,” https://wappalyzer.
com/categories/javascript-frameworks.
[39] C. Yue and H. Wang, “A Measurement Study of Insecure JavaScript
Practices on the Web,” in ACM Transactions on the Web, 2013.
15