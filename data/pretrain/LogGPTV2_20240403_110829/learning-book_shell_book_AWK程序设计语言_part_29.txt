f,n,t){
（++0<（）=）
age[f] = t
# all existing files get an age
close("1s -t")
for (n in names)
if (1(n in age))
 if n has not been created
6666 =[u]abe
#make nreally old
function update(n,
changed,i,s){
if (I(n in age)) error(n " does not exist")
if (!(n in names)) return 0
changed = 0
visited[n] = 1
for (i = 1;i <= scnt[n]; i++) {
if (visited[s = slist[n, i]] == 0) update(s)
else if (visited[s] == 1)
error(s " and " n " are circularly defined")
if (age[s]<= age[n]) changed++
}
visited[n] = 2
if (changed || scnt[n]== 0) {
printf ("&s", cmd[n])
---
## Page 184
第七章算法实验
176
system(cmd[n])  # execute cmd associated with n
()sabe
recomputeallages
age[n]= 0
# make n very new
return 1
return 0
x
179
Exercise 7.11在示例中，函数ages会执行多少次？
Exercise7.12添加一些参数或宏替换功能，使得我们可以很容易地对规则进行修改.
Exercise7.13为常见的更新操作添加隐式规则，例如，使用cc编译，c文件来生成.o文件，你将用
什么方法来表示隐式规则，使得用户可以对这些规则进行修改？
7.5小结
这一章更多地是在讨论基本的算法知识，而不是awk，然而，算法的确是一门非常有用的知识，而且
我们也希望读者能够学习到如何使用awk来支持其他程序的实验工作.
我们还讨论了脚手架程序，通常来说，和执行一个单独的测试比起来，写一个小程序来生成和控制测
试（或调试）并不会多花很多时网，但是脚手架程序可以被重复地使用，因此可以把工作做得更加彻底，
最后一点则比较普通，我们已经在前面说过很多遍了，Awk经常用于从某个程序的输出中提取数
据，并转换成另一种格式，例如，读者已经见识过我们如何把排序的测试结果转换成grap的输入，以及
如何把计数语句插入到原始程序中.
参考资料
我们的快速排序，堆排序和拓扑排序程序来自于Jon Bentley，他网时也是脚手架和剖析程序的灵
感来源，关于这些，读者可以进一步阅读CommunicationsoftheACM6月和7月的Programming
Pearls专栏，关于排序和搜索算法的扩展讨论及分析，请阅读TheArt of Computer Programming第3
卷：搜索与排序(D.E.Knuth著，Addison-Wesley 1973年出版)，或者是TheDesign and Analysis of
Computer Algorithms (Aho, Hopcroft 和 Ullman 著, Addison-Wesley 1974 年出版).
Unix程序make最早由StuFeldman开发，关于该程序的首篇文章载于1979年4月的Softuware
—Practice andExperience.更多的关于make 的讨论，请参考W.Miller和E.Myers 撰写的“Side-
effect in Automatic File Updating*, 载于 Software —Practice and Experience, 1986 年 9 月.
---
## Page 185
第八章后记
181
能看到这里，说明读者在某种程度上已经是一个熟练的awk用户了，至少不再是一个笨拙的初学
者，当你在学习书中的示例程序时，以及自己写程序的过程中，可能想知道awk为什么会是现在这个样
子，是否还有需要改进的地方
本章的第一部分先讲一些历史故事，然后讨论一下作为编程语言使用时，awk有哪些优点和缺点，
第二部分探讨awk程序的性能，另外，如果某个问题过于庞大，以致于无法用一个单独的程序来解决时，
文章也提供了一些对问题进行重新规划的方法.
8.1作为语言的AWK
关于awk的工作开始于1977年.在邵时候，搜索文件的Unix程序（grep和sed)只支持正则表
达式模式，并且唯一能做的操作只有替换和打印一整行数据，还不存在字段和非数值操作，我们当时的目
标是开发一款模式识别语言，该语言支持字段，包括用模式来匹配字段，以及用动作来操作字段，最初，
我们只能想用它来转换数据，验证程序的输入，通过处理输出数据来生成报表，或对它们重新编排，以此
作为其他程序的输入，
1977年的awk只有很少的内建变量和预定义函数，当时只是用它来写一些很简短的程序，就像第
一章中出现的那些小程序，后来，我们写了一个小教程，来指导新来的同事如何使用awk.正则表达式
的表示法来源于lex和egrep，其他的表达式和语旬则来源于C语言.
我们希望程序能够尽量得简洁，最好只有一两行，这样就能够快速地输入并执行，跌认操作都是为
了向这个方向努力，具体来说，使用空格作为跌认的字段分隔符，隐式地初始化，变量的无类型声明，等
等，这些设计选择都使得单行程序变成可能.作为作者，我们非常清楚地“知道”awk将会被如何地使用，
所以我们通常只需要写单行程序就够了
182
Awk的快速传播强有力地推动了语言的发展，把awk作为一门通用编程语言来使用，而且能够这
么快速地流行起来，我们都感到非常的惊喜，当看到一个无法在一页内显示完毕的awk程序时，我们的
第一反应是震惊和惊异，之所以会出现这种情况是因为许多人在使用计算机时，仅限于shell（命令行语
言）和awk，而不是使用一门“真正”的编程语言来开发程序—他们经常过度伸展所喜爱的工具
为变量的值同时维护两种表示形式：字符串与数值，根据上下文来选择合适的形式一这只是一个实
验性设计，目的是为了尽可能地使用同一套述算符集合来写出简短的程序，在字符串与数值的齐限很模
糊的情况下，程序也要能正确地工作.最终目标完成地很好，但偶尔也会因为粗心而得到意料之外的运行
结果，第二章介绍的规则可以用来解决界限模糊的情况，它们都来源于用户的使用经验。
关联数组的灵感来源于SNOBOL4表格（虽然它们不具备SNOBOL4表格的通用性）.诞生awk
& 文 是 Our model was that an invocation would be one or two lines long,typed in and used immediately.
乐文& We, being the authors, knew* how the language was supposed to be used, and so we only wrote one-liners
177
---
## Page 186
第八章后记
178
的机器内存很小，而且速度很慢，正是这个环境造就了数组现在的性质，把下标类型限制为字符串是其中
一种表现，另外的限制还包括单维数组（虽然套了一层语法外衣，但本质上还是一维数组）.一个更加通用
的实现应该支持多维数组，至少支持数组元素可以是另外一个数组
Awk的主要特性在1985年被加入进来，主要是为了满足用户需求，添加的特性包括动态正则表达
式，新的内建变量与内建函数，多输入流，以及最重要的用户自定义函数，
match，动态正则表达式和新的字符事替换函数提供了非常有用的功能，而且对用户来说，只是稍微
增加了一点复杂度
在getline被引入之前，输入数据的唯一种类是模式-动作语句所隐含着的隐式输入循环，这个
限制条件确实太强了，在原来的awk版本中，对于具有多个输入数据源的程序（比如格式信函生成程序）
来说，必须通过设置一个标志变量（或其他类似的技巧）来读取数据源，而在新版的aWk中，多个输入数
据可以在BEGIN部分，用getline来读取，另一方面，getline是过载的，它的语法和其他表达式相
比并不一致，其中一个问题是getline需要返回它所读取到的数据，但同时也会返因表示成功或失败
的返回值
用户自定义函数的实现是一个折中方案，从awk的最初设计开始，出现了许多固难，我们并不打算
在语言中加入声明，这个设计造成的一个结果是声明局部变量的特殊方法一把局部变量写到参数列表
中.这种做法不仅看起来很阳生，而且会让大型程序更容易出错，另外，缺少显式的字符串拼接运算符可
以让程序更加萄短，但这同时也要求在调用函数时，必须在函数名之后案限上左括号，不管怎么说,新的
特性使得用awk编写大型程序变得更加容易.
183
8.2性能
在某种程度上，awk是很有吸引力的一通常情况下，用它来编写你所需要的程序非常客易，而且在
面对适当规模的数据时，处理起来也足够快，特别是在程序本身也会变化的情况下。
然而，当处理的数据规模越来越大时，awk程序就会越来越慢.从常理上讲，这种现象是很正常的，
但是等待结果的过程常常使人无法忍受，解决这种问题的办法都比较复杂，但是本节提出的一些建议或
许能对你产生一些帮助.
当程序的运行时间过长时，除了忍耐，可以试着从其他几个方面入手，首先，让程序运行得更快是可
能的一或者利用更好的算法，或者是把频繁执行的操作，用等价的，但是更轻量的操作替换掉，在第七
章读者已经见到了一个优秀的算法能够产生的巨大作用一即使是在数据规模只有适度增加的情况下，
线性算法和平方算法之间也会产生巨大的差距，然后，你可以限制awk程序的功能，而使用其他更快速
的程序和awk配合，最后，你也可以用其他编程语言重写程序。
在着手提高程序的性能之前，你必须知道程序的时间都花在了哪里，即使是在每种操作和底层硬件
非常接近的编程语言中，人们对时间开销的分布所作出的估计也会非常得不可靠，在awk中，这些估计
会显得更加狡猎，因为其中许多操作和侍统的机器操作并不对应，这些操作包括模式匹配，字段分割，字
符串拼接，和替换，在不同的机器上，awk所执行的用来实现这些操作的指令也会不同，因此awk程序
中相关操作的开销也就不同
Awk并没有内建的计时工具，因此在本地环境中，哪些操作属于高开销，哪些操作属于低开销一完
全取决于用户怎么理解，为了分辨出高开销和低开销操作，最简单的办法就是制作一份不同构造之间的
差异度量，例如，读取一行数据或递增一个变量的值需要多长时间？我们在多种不同的计算机平台上都
做了测量—从PC一直到大型机.用一个包含10,000行（500,000个字符）的文件作为输入数据，运行
---
## Page 187
第八章后记
179
3个程序，同时和Unix命令wc作对比.测试结果如下：
程序
AT&TDEC VAX
AT&T
SUN-3
DEC VAX
+0089
11-750
3B2/600
8550
END ( print NR }
08
17.4
5.9
4.6
1.6
{n++}; END (print n}
45
24.4
8.4
9'9
2.4
{ i =NF }
59
34.8
12.5
9.3
3.3
WC命令
30
8.2
2.9
3.3
1.0
第1个程序在DEVVAX8550中运行了1.6秒，也就是说读取一行数据平均消耗0.16微秒.第2个程
序表明在读取数据的同时，递增变量需要额外消耗0.08微秒，第3个程序表明把输入行切分成字段需要
0.33微秒.作为对比，用C程序（在这里是Unix命令wc）对10,000行数据进行计数需要1秒钟的时
184
网，也就是每行0.1微秒.
其他类似的测量表明字符串比较操作，例如$1=="xXx”所花费的时间，和正则表达式匹配
S1~/xXX/大致相同，正则表达式匹配的时阔开销基本上独立于表达式的复杂程度，但是当一个复合比
较表达式变得越来越复杂时，它的时间开销也会越来越高，动态正则表达式的开销可以变得很高，因为它
可能需要为每一个测试重新构造识别对象.
拼接多个字符串的代价比较昂责：
print S1""$2""$3""$4""$5
所花费的时间大概是
print $1,$2,$3, $4,$5
的2倍.
我们在前面说过，数组的行为比较复杂，只要数组中的元素不太多，则访问一个元素的时间开销就是
一定的，在这之后，随着元素个数的增加，时网开销大致按照线性增长，如果元素个数非常多，这时候程
序的性能也会受到操作系统的影响，因为操作系统需要分配内存来存放变量.因此，相对于小数组，在大
数组中访问一个元素需要付出更高的代价，如果你想在数组中存放一个大文件，那就必须牢记这些，
第2个手段是重新构造计算过程，使得其中一些工作可以通过其他程序来完成.例如在整本书中，
为了避免自己写一个排序用的awk程序，我们用了多次Bort命令，如果你需要从一个很大的文件中分
离出某些数据，可以用grep或egrep搜索数据，然后再交由awk来处理，如果你需要做大量的替换操
作（比如第五章的交叉引用程序），那么可以选择一种流式编辑器（比如sed)来完成这部分工作，简单
来说，就是把一个大任务切分成多个小任务，然后再针对每个小任务选择一个最合适的工具来处理，
最后一个办法是用其他编程语言重写程序，基本原则是把awk中比较有用的内建特性用子例程替
换掉，除此之外，尽量让新程序和原程序在结构上保持一致，不要试图完全模仿aWk的工作方式，相反，
尽量充分利用手中已有的程序。比较有用的练习是写一个小型函数库，函数库提供了字段分割，关联数
组，和正则表达式匹配，在某些不支持动态字符串的语言中（比如C语言），你可能还需要一些能够方便地
分配和释放字符串的子例程，有了这些库函数，把awk程序转换成其他更快的程序就方使多了
通过模式匹配，字段分割，关联数组等内建特性，awk把其他传统语言很难完成的工作都简单化了，
利用这些特性，awk程序虽然编写起来比较方便，但是和认真编写过的等价的C程序相比，在效率上会
185
差一点，一般来说，效率并不会成为什么大问题，所以awk既方便使用，运行起来也足够快，
° 乐 交 是 Instead provide just enough for the problem at hand.
---
## Page 188
第八章后记
180
当awk的效率成为一个问题时，就有必要测量一下程序中各个部分的运行时间，看看时间都花在了
哪里，虽然在不同的机器中，相关操作的开销都会有所不同，但是测量技术可以应用在任何一台机器中，
最后，虽然使用低级语言来编写程序比较麻烦，但是也要注意理解程序与时间，否则的话，新程序不仅难
以编写，效率还很低。
8.3结论
虽然awk不能解决所有的编程问题，但它却是程序员的必备工具之一，尤其是在Unix（在Unix中
要经常用到各种工具）也许书中的大程序给你留下了些不同的印象，但是大多数awk程序其实非常简
短，而且所执行的任务本来就是当初升发awk的目标：计数，数据格式转换，计算，以及从报表中提取信
息.
对于上一段中提到的任务，程序的开发时间比运行时间更加重妥，在这一方面awk难逢敌手，隐式
输入循环和模式-动作范式简化了（而且经常是完全消除了）流程控制语句.字段分割操作处理最常见
的输入数据形式，而数值和字符串，以及它们之间的类型转换处理最常见的数据类型，关联数组同时提供
了传统的数组存储功能和灵活的下标，正则表达式提供了描述文本的统一表示法，默认的初始化操作和
声明的缺少缩减了程序的规模.
我们没有预料到的是，在许多不太常见的应用中也用到了awk.比如，“非编程工作”到“编程工作”
的转换是一个渐变的过程：由于缺少传统语言（比如C和Pascal)所具有的语法包，所以awk学习起
来非常简单，它甚至是相当一部分人的第一门编程语言.③
在1985年加入的特性，尤其是自定义函数的支持，催生出了许多未曾预料到的应用，比如小型数据
库系统和小型语言编译器，在许多种情况下，awk只是用来构造原型，测试想法的可行性，以及对特性和
用户接口进行评测，即使如此，在莱些情况下，awk程序仍然可以被当作一件真正的产品来使用，Awk甚
至被用到了款件工程课程中，因为和大型语言相比，使用awk对设计进行实验可能会更加方使，
当然，我们要小心不能走得太远一任何工具都有极限一但是很多人已经发现，awk是解决许多问
题的有用工具，我们希望本书所介绍的使用方法，对读者来说同样有用，
186
参考资料
本书作者写的“AWK—a pattern scanning and processing language”描述了awk 的原始版本，
载于Softuware—Practice andExperience，1979年4月，这篇文章还包括了和语言设计有关的技术性
讨论
Awk 的大部分语法来源于C语言，The C Programming Language (B.W.Kernighan 和 D. M.
Ritchie 著，Prentice-Hall 1978 年出版)对C 语言进行了完整的讨论.egrep,lex和 sed 使用的正则
表达式在The UnixProgrammer'sManual的第2部分中讨论.Compilers:Principles,Techniques,
andTools（Aho,Seti,和Ulman著，Addision-Wesley 1986年出版）的第3章包含了一个关于正则表
达式模式匹配的讨论，新版本的awk就用到了该技术，
也许你会觉得把awk和其他类似的语言作对比会比较有趣，这些语言的元老当然是SNOBOL4，
The SNOBOL4 Programming Language (R. Griswold, J. Poage,  I Polonsky  , Prentice-Hall
°乐 文是 What we did not anticipate were the les conventional applications. For example, the transition from “not programming° to
“programming* is quite gradual: the absence of the syntatie baggage of conventional languages like C or Pascal makes awk easy enough
to learn that it has been the first language for a surprising number of people.
---
## Page 189
第八章后记
181
1971年版）对该语言进行了详细的讨论.虽然SNOBOL4苦于应付非结构化的输入语言，但它仍然
是一门非常强大，灵活的编程语言.ICON（详情见R.Griswold和M.Griswold所著的TheICON
ProgrammingLanguage，Prentice-Hall 1983年出版）是SNOBOL4的直系后代，它有者更友好的语
法规则，也集成了更多的模式设施.IBM系统的解释语言REXX是另一个例子，虽然它更想把自己当
作一个shell或命令解释器，详情请参考TheREXXLanguage（MF.Cowlishaw著，Prentice-Hall
1985年出版).
---
## Page 190
附录AAWK总结
187
这个附录包含了awk语言的一个总结，在句法规则上，如果某个成分被一对中括号【］包围，则表
示它们是可选的.
命令行
awk[ -Fs]-f progfile optional list of filenames
参数-Fs把字段分隔符FS设置成8，如果没有提供文件名，awk就从标准输入读取数据，文件名的形式
可以是uar=text，在这种情况下，相当于把text赋值给变量uar，当这个参数被当作一个文件而被访问
时，执行赋值操作，
AWK程序
一个awk程序由一系列的模式-动作语句和函数定义组成.一个模式-动作语句具有形式：
pattern {action}
如果某个动作省略了模式，则默认匹配所有输入行；如果某个模式省略了动作，则默认打印匹配行
一个函数定义具有形式：
function name(parameter-list)( statement )
模式-动作语句和函数定义由换行符或分号分隔，并且这两个字符可以混合使用，
模式
BEGIN
END
expression
/regular expression/
pattern && pattern
pattern || pattern
!pattern
(pattern)