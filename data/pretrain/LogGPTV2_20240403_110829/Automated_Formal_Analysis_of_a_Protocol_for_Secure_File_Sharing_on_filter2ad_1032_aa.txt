title:Automated Formal Analysis of a Protocol for Secure File Sharing on
Untrusted Storage
author:Bruno Blanchet and
Avik Chaudhuri
Automated Formal Analysis of a
Protocol for Secure File Sharing on Untrusted Storage
Bruno Blanchet
CNRS, ´Ecole Normale Sup´erieure, INRIA∗
PI:EMAIL
Avik Chaudhuri
University of California at Santa Cruz
PI:EMAIL
Abstract
We study formal security properties of a state-of-the-art
protocol for secure ﬁle sharing on untrusted storage, in the
automatic protocol veriﬁer ProVerif. As far as we know,
this is the ﬁrst automated formal analysis of a secure stor-
age protocol. The protocol, designed as the basis for the
ﬁle system Plutus, features a number of interesting schemes
like lazy revocation and key rotation. These schemes im-
prove the protocol’s performance, but complicate its secu-
rity properties. Our analysis clariﬁes several ambiguities
in the design and reveals some unknown attacks on the pro-
tocol. We propose corrections, and prove precise security
guarantees for the corrected protocol.
1. Introduction
Much research in recent years has focused on the secu-
rity analysis of communication protocols. In some cases,
attacks have been found on old, seemingly robust proto-
cols, and these protocols have been corrected [23, 33, 40]; in
other cases, the security guarantees of those protocols have
been found to be misunderstood, and they have been clari-
ﬁed and sometimes even formalized and proved [4, 33, 37].
More generally, this line of work has underlined the difﬁ-
culty of designing secure communication protocols, and the
importance of verifying their precise security properties.
While protocols for secure communication have been
studied in depth, protocols for secure storage have received
far less attention. Some of these protocols rely on secure
communication, and we expect the usual techniques for se-
cure communication to apply to such protocols as well. But
some distinctive features of storage pose problems for se-
curity that seem to go beyond those studied in the con-
text of communication protocols. Perhaps the most strik-
ing of these features is dynamic access control.
Indeed,
∗Bruno Blanchet’s work has been done within the INRIA ABSTRAC-
TION project-team (common with the CNRS and the ´ENS).
while most storage systems feature dynamic access control
in some form, its consequences on more abstract security
properties like secrecy and integrity are seldom evaluated
in detail.
In this paper, we show that protocols for secure stor-
age are worth analyzing, and study an interesting example.
Speciﬁcally, we analyze a state-of-the-art ﬁle-sharing proto-
col that exploits cryptographic techniques for secure storage
on an untrusted server. The protocol is the basis for the ﬁle
system Plutus [32]. This setting is interesting for several
reasons. First, compromise of storage servers is a reason-
ably common threat today, and it is prudent not to trust such
servers for security [34]. Next, the protocol we study has a
very typical design for secure ﬁle sharing on untrusted stor-
age, where data is stored encrypted and signed, and keys
for encrypting, signing, verifying, and decrypting such data
are managed by users. Several ﬁle systems follow this basic
design, including SNAD [35], SiRiUS [28], and other cryp-
tographic ﬁle systems since the 1990s [15]. Finally, beyond
the basic design, the protocol features some promising new
schemes like lazy revocation and key rotation that improve
the protocol’s performance in the presence of dynamic ac-
cess control, but in turn complicate its security properties.
These features are worthy of study. For instance, our analy-
sis reveals that lazy revocation allows more precise integrity
guarantees than the na¨ıve scheme in [28]. With lazy revo-
cation, if an untrusted writer is revoked, readers can dis-
tinguish contents that are written after the revocation from
previous contents that may have been written by that writer;
consequently, they can trust the former contents even if they
do not trust the latter contents. On a different note, the com-
putational security of key rotation schemes has generated a
lot of interest recently [6, 7, 26]. Our analysis reveals some
new integrity vulnerabilities in the protocol that can be ex-
ploited even if the key rotation scheme is secure.
Formal techniques play a signiﬁcant role in our analysis.
We model the protocol and verify its security properties in
the automatic protocol veriﬁer ProVerif. ProVerif is based
on solid formal foundations that include theory for the ap-
plied pi calculus and proof theory for ﬁrst-order logic. The
formal language forces us to specify the protocol precisely,
and prove or disprove precise security properties of the pro-
tocol. This level of rigor pays off in several ways:
• We ﬁnd a new integrity attack on the protocol, and
show that it can have serious practical consequences.
That this attack has eluded discovery for more than
four years is testimony to the difﬁculty of ﬁnding such
attacks “by hand”.
• We propose a ﬁx and prove that it corrects the proto-
col. Both the attack and the correction are relative to
a formal speciﬁcation of integrity that is not immedi-
ately apparent from the informal speciﬁcation in [32].
We also prove a weaker secrecy guarantee than the one
claimed in [32] (and show that their claim cannot be
true).
• The formal exercise allows us to notice and clarify
some ambiguities in [32]; it also allows us to ﬁnd some
new, simpler attacks where more complex ones were
known. These discoveries vastly improve our under-
standing of the protocol’s subtleties.
• Finally, the use of an automatic veriﬁer yields a much
higher level of conﬁdence in our proofs than manual
techniques, which have been known to be error-prone.
More generally, our results reconﬁrm that informal justiﬁca-
tions (such as showing resistance to speciﬁc attacks) are not
sufﬁcient for protocols. As far as we know, our study is the
ﬁrst automated formal analysis of a secure storage protocol;
we expect our approach to be fruitful for other protocols in
this area.
Related work There is a huge body of work on formal
methods for the veriﬁcation of security protocols, e.g., [1,
4, 8, 16, 29, 33, 37]. We refer the reader to [14] for more in-
formation on this work, and we focus here on more closely
related work on the design and veriﬁcation of secure ﬁle
systems.
In ﬁle systems based on the network-attached (object)
storage protocols (NASD, OSD) [27, 30], distributed access
control is implemented on trusted storage via cryptographic
capabilities. A semi-formal security analysis of this proto-
col appears in [30], while [19–21] present formal models
and manual security proofs for this protocol in the applied
pi calculus.
Among other protocols for secure ﬁle sharing on un-
trusted storage, the closest to the one we study here are
those behind the ﬁle systems Cepheus [25], SiRiUS [28],
and SNAD [35]. Lazy revocation ﬁrst appears in Cepheus;
see [31] for a summary of the origins of lazy revocation, and
its limitations. Keys for reading and writing ﬁles in SiRiUS
are the same as those in Plutus. However, those keys are
stored and distributed securely by the server (“in-band”), in-
stead of being directly distributed by users (“out-of-band”).
Moreover, revocation in SiRiUS is immediate, instead of
lazy. In SNAD, keys for reading ﬁles are distributed in-band
as in SiRiUS. However, unlike Plutus and SiRiUS, there are
no keys for writing ﬁles—any user can write contents by
signing those contents with its private key, and the storage
server is trusted to control access to writes.
While the protocol we study partially trusts the storage
server to prevent so-called rollback attacks (where contents
received from the ﬁle system are not the most recent con-
tents sent to the ﬁle system), the protocol behind the ﬁle sys-
tem SUNDR [34] speciﬁcally provides a guarantee called
fork consistency, that allows users to detect rollback attacks
without trusting the storage server. The correctness of that
protocol is formally proved in [34]. SUNDR does not focus
on other secrecy and integrity guarantees.
Recently several schemes for key rotation have been pro-
posed and manually proved in the computational model of
security [6, 7, 26], and various alternative schemes for key
distribution and signatures have been designed to eliminate
public-key cryptography in this context [36]. Mechanically
verifying these schemes should be interesting future work.
Finally, to guarantee stronger information-ﬂow proper-
ties than the ones studied in this paper, access control must
be complemented by precise code analysis. Recently, sev-
eral type systems have been designed for such purposes [18,
22, 38, 42]. The type system in [18] is particularly suitable
for proving such properties in the presence of dynamic ac-
cess control and untrusted storage.
Organization The rest of the paper is organized as fol-
lows. In Section 2, we outline the protocol behind Plutus.
In Section 3, we give an overview of ProVerif, and present
our model of Plutus in ProVerif.
In Section 4, we spec-
ify and analyze secrecy and integrity properties of Plutus in
ProVerif, and present our results and observations. Finally,
in Section 5, we discuss our contributions and conclude.
2. Plutus
The ﬁle system Plutus [32] is based on a storage design
that does not rely on storage servers to provide strong se-
crecy and integrity guarantees. Instead, contents of ﬁles are
cryptographically secured, and keys for writing and read-
ing such contents are managed by the owners of those ﬁles.
Special schemes are introduced to economize key distribu-
tion and cryptography in the presence of dynamic access
control; those schemes complicate the protocol and its se-
curity properties.
In Plutus, principals are qualiﬁed as owners, writers, and
readers. Every ﬁle belongs to a group1, and all ﬁles in a
1There is a difference between the informal interpretation of a group
group have the same writers and readers. The owner of a
group generates and distributes keys for writing and reading
contents for that group; those keys are shared by all ﬁles in
that group. Speciﬁcally, a write key is used to encrypt and
sign contents, while a read key is used to verify and decrypt
such contents. These keys can be revoked by the owner to
dynamically control access to those ﬁles; a new write key
and a new read key are then generated and distributed ap-
propriately. However, the new write key is used only for
subsequent writes: unlike SiRiUS [28], the ﬁles are not im-
mediately secured with the new write key, so that the previ-
ous read key can be used to verify and decrypt the contents
of those ﬁles until they are re-written. This scheme, called
lazy revocation, avoids redundant cryptography and is jus-
tiﬁed by the following observations:
• Encrypting the existing contents with the new write
key does not guarantee secrecy of those contents from
the previous readers, since those contents may have
been cached by the previous readers.
• More subtly, since the existing contents come from the
previous writers, signing those contents with the new
write key would wrongly indicate that they come from
the new writers.
Further, a scheme called key rotation allows the new read-
ers to derive the previous read key from the new read key,
avoiding redundant key distribution—the new readers do
not need to maintain the previous read key for reading the
existing contents. In contrast, the new read key cannot be
derived from the previous read key, so contents that are sub-
sequently written with the new write key can only be read
by the new readers.
Concretely, a write key is of the form (sk , lk), where
sk is part of an asymmetric key pair (sk , vk), and lk is a
symmetric encryption key; the complementary read key is
(vk , lk). Here sk, vk, and lk are a sign key, a verify key,
and a lockbox key. Contents are encrypted with lk 2 and
signed with sk; those contents are veriﬁed with vk and de-
crypted with lk. Plutus uses the RSA cryptosystem [39], so
we have sk = (d, n) and vk = (e, n), where the modulus
n is the product of two large primes p and q, and the expo-
nents d and e are inverses modulo (p − 1)(q − 1), that is,
ed ≡ 1 mod (p − 1)(q − 1). Thus, the functions x 7→ xd
mod n and y 7→ ye mod n are inverses. Given a hash
function hash, a message M is signed with sk by comput-
ing S = hash(M)d mod n, and S is veriﬁed with vk by
in [32], and the formal interpretation of a group in this paper. In fact, the
interpretation in [32] is inconsistent; see Section 4.4 for a more detailed
discussion of this issue.
2More precisely, contents are divided into blocks, and each block is
encrypted with a fresh key; these keys are in turn stored in a “lockbox”
that is encrypted with lk. In this paper, we consider for simplicity that the
contents are directly encrypted with lk; we have checked that our results
continue to hold with the details of the lockbox.
checking that Se mod n = hash(M). We call (p, q) the
RSA seed.
In general, e may be chosen randomly, rela-
tively prime to (p − 1)(q − 1), and d may be computed
from e, p, and q. However in Plutus, e is uniquely de-
termined by n and lk as follows: given a pseudo-random
sequence hrii generated with seed lk, e is the ﬁrst prime
ni. We denote this algo-
number in the sequence hri +
rithm by genExp(n, lk). To sum up, a sign/verify key pair
(sk , vk) is generated from a random RSA seed (p, q) and a
lockbox key lk, by computing n = pq, e = genExp(n, lk),
vk = (e, n), and sk = (d, n), where d is the inverse of e
modulo (p − 1)(q − 1).
√
The owner of a group distributes (sk , lk) to writers and
lk to readers; users can further derive vk from n and lk
using genExp. Note that n is already available to writers
from sk. Further, the owner distributes a signed n to writ-
ers, which they attach whenever they write contents to the
ﬁle system—so any user can obtain n from the ﬁle system
and verify its authenticity. Thus writers can act for readers
in Plutus, although in [32] it is wrongly claimed that writers
cannot derive vk (implying that read access is disjoint from
writer access). It is already known that writers can act for
readers in SiRiUS in a similar way [28, 36].
Let (D, N) and (E, N) be the private key and the public
key of the owner of a group. The initial and subsequent
versions of keys for writers and readers of that group are
generated as follows:
Version 0 The initial lockbox key lk 0 is random, and the
initial sign/verify key pair (sk 0, vk 0) is generated from
a random RSA seed (with modulus n0) and lk 0.
lk v+1 = lk D
v+1 mod N.
Version v to version v + 1 When keys for version v are
revoked, a new lockbox key lk v+1 is generated by
“winding” the previous lockbox key lk v with the
v mod N. The
owner’s private key:
previous lockbox key can be retrieved by “unwind-
ing” the new lockbox key with the owner’s public key:
lk v = lk E
In particular, a reader with
a lockbox key lk v0 for any v0 ≥ v can generate the
verify key vk v by obtaining the modulus nv from the
ﬁle system, recursively unwinding lk v0 to lk v, and de-
riving vk v from nv and lk v using genExp. The new
sign/verify key pair (sk v+1, vk v+1) is generated from
a random RSA seed (with modulus nv+1) and lk v+1.
While storage servers are not trusted to provide strong se-
crecy and integrity guarantees, there is still a degree of trust
placed on servers to prevent unauthorized modiﬁcation of
the store by a scheme called server-veriﬁed writes. Speciﬁ-
cally, the owner of a group generates a fresh write token for
each version, and distributes that token to the writers of that
version and to the storage server. The server allows a writer
to modify the store only if the correct write token is pre-
sented to the server; in particular, revoked writers cannot
revert the store to a previous state, or garbage the current
state.
3.2. A model of Plutus in ProVerif
3. ProVerif and a formal model of Plutus
In order to study Plutus formally, we rely on the auto-
matic cryptographic protocol veriﬁer ProVerif. We brieﬂy
present this veriﬁer next, and describe our model of Plutus
below.