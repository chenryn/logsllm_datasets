title:Using Predators to Combat Worms and Viruses: A Simulation-Based
Study
author:Ajay Gupta and
Daniel C. DuVarney
Using Predators to Combat Worms and Viruses:
A Simulation-Based Study
Ajay Gupta, Daniel C. DuVarney
Department of Computer Science
Stony Brook University
Stony Brook, NY 11794
{ajay,dand}@cs.sunysb.edu
Abstract
Large-scale attacks generated by fast-spreading or stealthy
malicious mobile code, such as ﬂash worms and e-mail
viruses, demand new approaches to patch management and
disinfection. Currently popular centralized approaches suf-
fer from distribution bottlenecks which cannot be solved by
merely increasing the number of servers, as the number
of servers required to eliminate all bottlenecks is imprac-
tically large. Recently, predators were proposed as a tech-
nique for eliminating automated mobile malware from com-
puter networks. Predators are benevolent, self-propagating
mobile programs which have the ability to clean up systems
infected by malignant worms/viruses. We propose a num-
ber of extensions to the original predator model, includ-
ing immunizing predators, persistent predators, and seeking
predators. We report on a set of simulations which explore
the effects of predators on small-scale (800 to 1600 node)
networks. Our results indicate that predators hold signiﬁ-
cant promise as an alternative to the centralized patch dis-
tribution mechanism. The results show that predators can
be used to disinfect systems and distribute patches rapidly
across the network, without suffering from bottlenecks or
causing network congestion. The results also show that the
new predator models provide signiﬁcant beneﬁts over the
original predator model. The simulation tool is also useful
for tuning predator behavior, so that an optimal tradeoff be-
tween the peak virus/worm infection rate and the overhead
generated by the predator can be chosen before a preda-
tor is released.
1. Introduction
Improving the defensive capabilities of computer net-
works from self-propagating attacks, such as worms and
e-mail viruses, is an urgent problem [4, 7, 6, 10, 8]. The
rate at which these types of attacks spread across networks
has been steadily increasing, to the point where some re-
cent worms, such as the Blaster worm [9], SoBig [12], Sir-
cam [5] and Code Red [11, 26, 32], have infected hundreds
of thousands of computers within a matter of a few hours.
The phenomenal propagation rates of these new worms
make a rapid response to self-propagating attacks critical.
The reaction to a self-propagating attack can be viewed
as a two phase process. In the ﬁrst phase, the attack is
detected, the vulnerability exploited by the attack is diag-
nosed, and a patch is developed. If the vulnerability is novel
(i.e., it was previously unknown), then a temporary patch
which disables the service targeted may be employed in or-
der to provide a timely response. Approaches such as auto-
matic patch generation [25] have the potential for quickly
generating patches, and other approaches, such as address
space randomization [2, 14], can slow down the propaga-
tion rate of attacks that exploit memory errors and cause
failed attacks to become conspicuous, making early detec-
tion more likely and buying time for a patch to be devel-
oped. These developments lend credence to the hope that,
in many cases, patches will be available before a worm has
penetrated much of the network.
In the second phase, malware installed by the worm must
be removed and the patch must be applied to all vulnerable
machines on the network. In this paper, we address the is-
sues involved in this latter phase.
Current approaches to patch distribution are primarily
centralized, and hence suffer from bottlenecks at the server
end. Both the server/push approach, in which servers broad-
cast patches to client machines, and the client/pull ap-
proach, in which clients download the patch from a server,
suffer from bottlenecks due to centralization. Consider a
typical patch of the size of 10Mb to be installed on 10 mil-
lion machines in an hour, which would require a net band-
width of 200 Gb/s. While these bottlenecks could poten-
tially be relieved by caching patches across the network,
such an approach is a complex solution which requires
many additional machines, and furthermore, only reduces
the distribution time by a linear amount of time, i.e., the
patch distribution time is essentially O(N/k), where N is
the number of clients and k is the number of server/cache
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
machines. Additionally, any centralized approach is vulner-
able to a denial-of-service attack which could be launched
by an attacker in order to delay patch distribution.
Recently, Toyozumi and Kara proposed the use of preda-
tors [28] as a defensive mechanism to protect networks from
worms and viruses. Predators are benevolent mobile pro-
grams that replicate and migrate from machine to machine
across a network, in a manner similar to a virus or worm,
disinfecting and immunizing each visited machine.Since
predators spread across the network in a tree-like fashion,
the patch time will be O(logkN ), where N is the number
of clients, and k is the fan-out factor of the predator.
Furthermore, predators have the potential of containing
the spread of a virus/worm before a patch is available, by
continually disinfecting machines until a stable infection
rate is reached. Our results show that, with proper preda-
tor design, the stable infection rate can usually be kept to
a small percentage of machines without excessive band-
width consumption. This would serve as a useful stopgap
measure for containment of worms/viruses until a patch be-
comes available. The patch could then be distributed by tra-
ditional means or by a second predator.
One issue involving the use of predators is whether or
not the predator exploits the existing vulnerability in order
to gain access to the system. In the original work on preda-
tors [28, 20, 17], this has been suggested as a technique. In-
truding into the systems of others without authorization is
not legal, and it seems likely that for predators to become
a practical technique, they should rely upon OS infrastruc-
ture rather than attempt to exploit vulnerabilities to enter
systems. More discussion on this topic is in Section 6.
One of the problems that will be faced in downloading
any mobile code using either predators propagation, server-
push or client-pull technologies is that of authentication of
the server and establishing a trusted source. The problem of
source authentication is only compounded in the case of a
predator, since it is an arbitrary, self-propagating code. The
problem can be solved if the vendor supplying the predator
signs the code, which can be veriﬁed by the recipient. In our
work, we have mainly concentrated on studying the effects
of a predator once it is accepted by a user machine, and how
it could patch and cleanup a network.
The base assumptions underlying our work are as fol-
lows. There is a network which is fully connected (any ma-
chine can connect to any other machine), there is a consen-
sus to allow predators on the network, and patches can be
made available before worms/viruses have penetrated the
entire network. Given these assumptions, our work builds
on the results of [28] in several ways.
First, in [28], the behavior of predators is predicted us-
ing equations from epidemiology [19]. We have developed
a discrete simulation tool which simulates the behavior of
predators and viruses on small scale (1600 node) networks.
We report on the simulation results and closely they match
the results predicted in [28].
Second, an important issue is the amount of network traf-
ﬁc generated by the predator. The simulations show that it is
possible to design predators so that worms and viruses are
eliminated without clogging the network.
Third, the simulation tool is valuable as a design tool for
predators, as it allows the predator’s behavior to be tuned
so that the predator is effective without overloading the
network. If predators are to become a practical technique,
then tools will be required which allow predator behavior to
be conﬁdently predicted before the predator is actually re-
leased. We report on the design and implementation of our
tool, which is a ﬁrst step in this direction.
Finally, in [28], in order to conform with biological mod-
els, a predator immediately dies when it propagates to an
uninfected host. In this paper, we extend the original preda-
tor model in three different directions:
(cid:127) We propose persistent predators, which improve the
original predator model by introducing a delay before
the predator dies.
(cid:127) We propose immunizing predators, which have the
ability to install patches as well as disinfect machines.
(cid:127) We propose seeking predators, which have the ability
to follow the same path as the virus from an infected
machine. This type of predator model is applicable in
particular to e-mail viruses, where it may be possible
to automatically inspect the mail server log and deter-
mine where viruses were sent to and came from.
Our simulations show that the above three predator mod-
els are more effective at combating automated attacks with-
out overloading the network.
The rest of this paper is organized as follows. In Sec-
tion 2, the simulation design, including the predator and
virus models, is presented. Section 3 describes the exper-
iments that were performed and the experimental results.
Section 4 discusses the implication of the experimental re-
sults on the design of predators. Section 5 summarizes re-
lated work, and Section 6 discusses broader issues involv-
ing the use of predators. Section 7 summarizes our results.
2. Simulation Design
In order to study the propagation of malicious mo-
bile code through a network, we developed a single
machine simulation testbed where the application of preda-
tors against different types of self-propagating malware
could be studied. The main advantages of such an ap-
proach over using a real network are ease of conﬁgura-
tion and low testbed cost. The obvious disadvantage is that
the simulation must be carefully designed in order to accu-
rately model real-world behavior.
The overall simulation works as follows. The network
consists of a ﬁxed set of fully interconnected nodes (any
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
routers that may connect nodes are ignored). Each node has
a single e-mail queue and a single user, modeled as a Pois-
son process, who randomly sends an e-mail (once every 5
minutes on average) or reads all queued e-mails (once every
10 minutes on average). When not performing e-mail func-
tions, users are in an idle state. The e-mail queue length dur-
ing the simulation is unbounded, although queues which ex-
ceed a length of 500 trigger an alert that the e-mail server is
overloaded. During the simulations reported on in this pa-
per, no overloading occurred.
At the start of the simulation, all e-mail queues are
empty. After the e-mail queues stabilize (which occurs af-
ter about 25 minutes of simulated time), a virus-carrying
e-mail is introduced into the system. The virus is allowed to
propagate until a threshold of infected systems is reached.
Once the infection threshold is reached, the predator is in-
troduced to the network. The threshold was varied in order
to explore the effectiveness of predators at disinfecting net-
works in different levels of virus infection. The simulation
then runs until some termination criteria is satisﬁed (e.g.,
less than 1% of the network is infected).
The simulation uses discrete time, where each cycle of
simulation was chosen to correspond to roughly 0.2 sec-
onds. This is a rather arbitrary number — our main concern
in this context was to choose a small enough granularity so
that the results would be essentially the same as with a sim-
ulation based on real time.
The simulation relies on abstract models of predator
and worm/virus behavior, which are based on state transi-
tions [18, 24]. The models encode the behavior of a mo-
bile program on a network as a timed ﬁnite state machine.
Model behavior is tuned by a set of parameters.
2.1. Predator Models
Two basic predator models were employed. The ﬁrst
model, depicted in Figure 1(a), is essentially the same as
the model used in [28]. The second model, depicted in
Figure 1(b), is an extension which can not only destroy a
worm, but can also deliver patches to an infected machine,
thereby immunizing the machine from future recurrences of
the same attack.
The purpose of the non-immunizing predator is to com-
bat a worm or virus for which no patch is yet available. The
non-immunizing predator has the capability to disinfect ma-
chines, but not to immunize them from future attacks. In
order to prevent the predator from ﬂooding the network,
the non-immunizing predator is prevented from propagat-
ing unless it ﬁnds a copy of the virus. When the predator
propagates to a machine which is not infected by the virus,
it waits for some time for the machine to be attacked. If no
worm or virus attempts to propagate to the machine dur-
ing the waiting period, the predator dies.
When the immunizing predator (Figure 1(b)) propagates
to a new machine, it disinfects the machine if necessary, and
then immunizes the machine by applying a security patch
regardless of whether or not the machine has ever been in-
fected. The predator then propagates to other machines in
the network.
The model states in Figure 1 represent speciﬁc phases of
the predator’s behavior:
(cid:127) Initial state: The predator has just arrived on a machine
in the network. The ﬁrst event that occurs during the
initial state is a delay which simulates the transmission
and execution time required by the predator. Once the
delay is ﬁnished, then the predator checks to see if a
virus/worm is present on the machine. If a virus is de-
tected, the predator moves to the disinfection state. If
no virus is present, then the behavior is dependent on
the type of predator: a non-immunizing predator en-
ters the waiting state, while an immunizing predator
enters the immunization phrase.
(cid:127) Waiting state (non-immunizing predator only): The
predator waits for the machine to become infected. If
the predator’s time-to-live clock expires before any in-
fection attempt occurs, the predator dies (i.e., it is de-
activated and deleted). If the machine is infected by
the virus, then the predator proceeds to the disinfec-
tion state.
(cid:127) Disinfection state: The predator removes any malware,
backdoors, virus copies etc. installed on the machine.
The next state is either the immunization state (in the
case of an immunizing predator), or the replication
state (in the case of a non-immunizing predator).
(cid:127) Immunization state (immunizing predator only): The
predator immunizes the machine, by installing rele-
vant security patches. The predator then proceeds to
the replication state.
(cid:127) Replication state: The predator generates a number of
copies of itself, and sends itself out as an attachment
in an email to various users on the network. The num-
ber of users are randomly generated, and are generally
more than the fan-out of the virus.
state transition system,
2.1.1. Predator Model Parameters In addition to the
predator behavioral
stochas-
tic and temporal aspects of predator behavior are deter-
mined by a set of parameters. The parameters are ﬁxed
prior to the start of the simulation and apply to all preda-
tors. The most important parameters are:
(cid:127) Fanout. The fanout determines how many copies of
a self-propagating program are made each time it
reaches a new node. The fanout parameters are up-
per and lower bounds, and the fanout for each
propagation is chosen randomly (using a uniform dis-
tribution) between the bounds.
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Propagate
REPLICATE
Generate
Target List
of Hosts
Initial
Injection
INIT
Find Virus
DISINFECT
WAIT
No Virus
DIE
Virus Arrives
No Virus
REPLICATE
P ro p a g ate
Generate
Target List
of Hosts
(a)
(b)
Initial
Injection
INIT
Find Virus
DISINFECT
Fix Vulnerability
IMMUNIZE
Figure 1. (a) Non-immunizing and (b) immunizing predator models.
No Virus
Send out Emails
containing Virus
INFECT
and
PROPAGATE
Recipient Target List
using Email
Address Book
Email containing
Virus Received
DORMANT
User Clicks on attachment
ACTIVE
Figure 2. Virus model.
(cid:127) Propagation Time. The delay between the time a
predator is sent to a new node and the time at which
it is activated. This delay is currently the same for all
predator propagation attempts.
(cid:127) Time-to-Live. For non-immunizing predators,
the
length of time that the predator will wait for a virus to
arrive before terminating.
2.2. Virus Model
The virus model used in the simulations appears in Fig-
ure 2.2. The virus model has three basic states:
(cid:127) Dormant. The virus is enqueued in the e-mail queue
for some node, waiting for the user to activate the
virus. The next time the user reads e-mail, the virus
will be activated and enter the active state.
(cid:127) Active. The virus accesses the users e-mail history,
and randomly chooses some nodes from the history as
propagation targets. The number of targets chosen is
based on the fan-out of the virus, which is one of the
simulation parameters (4 in most of the simulations).
(cid:127) Infect and Propagate. For each selected target user, a
copy of the virus is placed in the users e-mail queue.
Each of these new virus copies is initially in the dor-
mant state. The original virus then dies.
2.2.1. Virus Model Parameters Just like predators, the
behavior of viruses is tuned by a set of parameters which de-
termine the temporal and stochastic aspects. The most im-
portant of these are:
(cid:127) Fanout. The fanout is expressed as a uniform distribu-
tion with an upper and lower bound.
(cid:127) Incubation Time. The delay between the time a user
reads an e-mail containing a virus, and the time the
virus becomes active. This delay is also expressed as
upper and lower bounds, with the actual incubation
time being chosen uniformly randomly between these
two values for each virus attack attempt.
These parameters are sufﬁcient to model both ﬂash and
stealth viruses. Stealth viruses can be modeled by using a
very long incubation period, so that at any given time in-
stant, most of these viruses are in a dormant state, plus keep-
ing the fanout low, so that the percentage of virus-carrying
e-mails is kept very low. Flash viruses are characterized by
a high fanout and a short incubation time [27, 30].
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
2.3. Simulation Testbed
The simulator was implemented in Java. With 400
clients, about 800 frequency distributions were main-
tained, each over 8 time scales. Due to these struc-
tures,
the total memory use of the Java program was
30MB. When run on a Intel Pentium III system oper-
ating at 1GHz running RedHat Linux 9.0, Java2 SDK
1.4, it was able to simulate about 500 cycles per sec-
ond, i.e., simulate 100 seconds per one second of real
time.
3. Experimentation
Our experiments fall into three categories. The ﬁrst batch
of experiments were designed to compare the behavior of
the simulator results with the models presented in [28]. The
second batch of experiments were designed to test the clas-
sic predator model and the effect of various improvements
on the model, such as immunization. The effects of vary-
ing some parameters, such as the predator fanout and time-
to-live parameter, was also studied. The third set of exper-
iments were done to explore the effectiveness of predators
against rapidly-spreading worms.
3.1. Simulator vs. Other Models
As pointed out in [28], the interaction between viruses