0.01 (20/3,667)
0.00 (4/4,612)
JStap (Values)
0.62 (2,947/4,717)
0.98 (4,439/4,524)
0.56 (2,826/5,025)
0.66 (2,420/3,667)
0.08 (350/4,243)
it does not alter or remove the strings from the file. Using
the T1-StringLiteral transformation, the string literals can be
completely removed from the JavaScript file, reducing the
syntactic information available to the detectors.
3) Breakdown of Results by Malware Type: The malicious
datasets contain several different categories of malware, in-
cluding cryptominers, trojans, and droppers. We provide a
breakdown on the malware categories contained within our
dataset. VirusTotal provides the malware type reported by the
AV scanners. We reduce the number of malware categories
presented by merging similar groups together, e.g., merging
JS:Trojan.Gnaeus and JS:Trojan.Agent into a Trojan category.
For GeeksOnSecurity, we use the directory names to identify
which samples are exploits kits and which are JavaScript
droppers. The Hynek Petrak dataset does not provide metadata
on the samples, so we scan the files with ClamAV to obtain
the malware categories. To demonstrate the effectiveness of
Wobfuscator in obfuscating a diverse set of malware samples,
we measure the reduction in the recall of malware detectors for
different malware categories in the dataset. For space reasons,
we list only the minimum recall rates observed within the
malware categories among all of the transformations.
Results: Columns 5-9 of Table IX present the recall values
obtained by the malware detectors (columns) when samples
from each malware category (rows) are obfuscated. In addition
to the recall rate, each cell lists the number of files correctly
marked as malicious by the detector over the number of ma-
licious files the detector tested within that category. Columns
marked with ‘-’ signify that the detectors are unable to parse
any of the test files within the malware category. For the
Phishing malware category, no samples appear in our test
dataset, so no recall values are available. The results on the five
largest malware groups (Downloader, Misc., Trojan, Malware,
and Exploit) show that Wobfuscator can significantly reduce
recall rates across diverse malware categories.
C. Correctness of the Transformations (RQ2)
The transformations we apply change the syntactic structure
of the program. Naturally, such changes could affect program
semantics, potentially making the obfuscated program behave
differently from the original program and thus breaking func-
tional correctness. This gives rise to two questions, which are
in tension with each other: First, do we preserve functional
correctness of the input program, i.e., are our code trans-
formations semantics-preserving? Second, how often are the
transformations applied? To validate that the correctness of
the program is preserved, we leverage the comprehensive test
suites of existing widely used JavaScript projects. We apply
the transformations to the tested code and then validate if the
transformed code still passes its tests. Addressing the second
question, a trivial solution to correctness would be to transform
only a very small set of code locations, preserving semantics
at the expense of obfuscating less code. Thus, we also evaluate
how often each transformation rule is applied.
The validation setup differs between the synchronous and
asynchronous variants of the transformations. In the syn-
chronous case, we can simply apply the transformations to
any existing code. To validate the correctness of the asyn-
chronous transformations, the projects must be modified to
support asynchronous execution as described in Section IV-C.
Since automatically turning arbitrary JavaScript code into
asynchronous code is non-trivial, we instead focus on an NPM
project, node-fetch, that is already asynchronous, so applying
the asynchronous transformations is simplified. We use this
project to validate the asynchronous variants and use the other
five projects to validate the synchronous variants.
Results: The results for the test suite runs are shown in
Table V. This table lists the tested project, its version, and the
number of translation sites where rules T1–T7 are applied to.
The last two columns list the total number of tests in the test
suite, and the number of tests that are impacted by at least
one transformation. All tests in each project pass successfully,
showing that our obfuscations are semantics-preserving.
Columns 4-11 of Table V show the number of transformed
code locations that meet the preconditions of the transforma-
tion out of the total number of available code locations relevant
to the transformation, regardless of whether they satisfy the
preconditions. The last two columns of Table V show that
of the 2,017 unit tests in the five test suites, 1,844 of them
(91.42%) rely on a function that is impacted by at least one
transformation rule. The results show that our transformation
rules are applicable to code locations used in the real-world.
D. Efficiency in Terms of Runtime and Code Size (RQ3)
The Wobfuscator transformations we propose re-implement
native JavaScript functionalities in WebAssembly modules,
such as calling a function, performing a while loop, initializing
an array, etc. As a result, there will be an impact on the perfor-
mance of the translated programs. To quantify the performance
impact of our transformations, we use the test suites of the
six modules described in Section VI-C. In addition, the code
size increase caused by the transformations is also analyzed,
counting both added JavaScript and WebAssembly code.
1) Translation Runtime: First, we measure the time taken
for performing the transformations on the project files. The
times are measured with the time command available in
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:50 UTC from IEEE Xplore.  Restrictions apply. 
111584
TABLE V
CORRECTNESS VALIDATION RESULTS.
T5
T4(a)
T3
T2
T7
Total # of Tests
# of Tests Impacted
Project
Version
LoC
T1
Lodash
Chalk
Commander
Debug
Async
5.0.0
4.1.0
7.2.0
4.3.2
3.2.0
21,178
319
1,153
505
787
193/801
64/68
155/163
141/149
30/57
Node-Fetch
Total
3.0.0beta.10
-
970
4,152
174/212
757/1,450
160/208
0/23
0/28
2/8
0/21
T4(b)
Validation of synchronous transformations:
299/467
26/108
87/394
43/95
108/209
Validation of asynchronous transformations:
-
654/1,537
87/467
21/108
130/394
20/95
89/209
49/264
396/1,537
1/17
163/305
0/0
2/2
0/0
0/0
0/0
0/0
2/2
T6
0/0
1/1
4/4
2/5
5/6
38/61
2/2
2/3
0/0
5/8
47/187
4/25
91/153
16/29
31/86
26/94
189/480
0/0
12/16
0/0
47/74
408
54
632
14
675
234
2,017
322
54
592
13
659
204
1,844
TABLE VI
EFFICIENCY OF TRANSFORMATIONS.
Project
Translation time
Execution time
Code size (bytes)
Overhead Original Overhead
LoC
Lodash
Chalk
Commander
Debug
Async
21,178
319
1,153
505
787
Node-Fetch
Average
970
4,152
Time Original
Synchronous Validation
29.58s
0.81s
0.51s
1.14s
5.42s
Asynchronous Validation
16.03s
8.92s
4.11s
5.68s
+25.81% 135,402 +139.84%
3.51s
+7.01% 14,935 +166.70%
4.03s
+49.95% 74,269 +146.96%
3.97s
0.61s
+3.24% 21,395 +154.70%
16.83s +2079.21% 28,925 +363.52%
+14.76% 51,960
127.16%
+31.07% 54,481 +170.42%
Linux, averaged over ten repetitions. We compute the total
transformation time of a project by summing the times to con-
vert each JavaScript file used in the project. The transformation
time results are presented in Table VI. The table shows that
for the largest project, Lodash with 21,178 lines of code, the
average time to apply all of the synchronous transformations is
29.58 seconds. For the smallest project, Chalk with 319 lines
of code, the average time to apply the transformations is only
0.81 seconds. In addition, we find that among all the projects in
Table VI, the average time to apply all of the transformations
is only 8.92 seconds. These low transformation times show
that Wobfuscator is practical for JavaScript obfuscation.
2) Execution Time Overhead: The execution overhead time
is the increase in runtime to complete the execution of the test
suites of the transformed projects. We use the time command
to measure the runtime of the project test suite before and
after the transformations are applied, reporting averages over
ten repeated measurements. The execution time results are
presented in Table VI. Our transformations add a performance
overhead that ranges from an increase of 3.24% to an increase
of 2,079%. While the highest overhead number is large, it
is important to note that this large runtime originates from
one test within the async project that concurrently applies an
asynchronous function to a collection of 1,048,576 elements.
In most cases, it is unlikely that malware samples will follow
such an execution pattern that incurs this large overhead. On
average, Wobfuscator adds a performance overhead of 31.07%.
3) Code Size Overhead: The code size overhead is the
increase in code size between the original file and transformed
output among all code files within a project. Table VI lists the
percentage of growth in code size compared with the original
size. On average, applying all of the transformations among
the project, the code size increased by 170.42%. Overall, the
code size overhead is acceptable for practical applications.
VII. DISCUSSION
This section discusses the limitations and possible mitiga-
tions to defend against WebAssembly-based obfuscation.
A. Limitations
Wobfuscator
targets malware detectors based on static
analysis, and despite its effectiveness in bypassing them, is
unlikely to be equally effective for dynamic analysis-based
detectors. The transformations move some behavior into Web-
Assembly while leaving the ultimate runtime behavior intact.
That is, a dynamic detector that, e.g., observes browser API
calls made by a website will observe the same behavior
with and without our obfuscation. However, in practice static
detectors are much easier to deploy (e.g., as network proxies
or browser extensions), whereas observing dynamic behavior
is more complex to set up and expensive at runtime.
Another limitation is that the approach applies transforma-
tions only to some of the given code. If a code location does
not fulfill the preconditions for a specific transformation, then
it cannot be transformed. Conservatively guarding transfor-
mations is crucial to ensure that our approach preserves the
semantics of the given code, but also limits its applicability.
Finally, our obfuscation relies on WebAssembly being avail-
able in the browser. With WebAssembly support in 94% of all
installed browsers, this limitation is likely to be acceptable
in practice. To ensure that the obfuscated malware runs as
expected, an attacker could check for WebAssembly support
and load the obfuscated code only if the language is supported.
B. Mitigations
We discuss three mitigation strategies aimed at detecting
malware despite our obfuscation. The first is dynamic analysis-
based malware detection. Because our approach preserves
the original JavaScript behavior, many runtime characteristics
that dynamic detectors focus on [53] are not affected by the
obfuscation. WebAssembly code invokes web APIs through
JavaScript, which means the call will be visible to any runtime
analysis that wraps the API functions or intercepts them within
the browser. However, dynamic malware detectors often im-
pose a non-negligible runtime overhead and may miss malware
that hides its malicious behavior in specific configurations.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:59:50 UTC from IEEE Xplore.  Restrictions apply. 
121585
The second mitigation strategy is based on the defender
knowing the details of our obfuscation. Since the WebAssem-
bly usage in the obfuscated code, e.g., loading many small
modules, may be abnormal, it is possible to define heuristic
rules to detect that Wobfuscator was applied. In a similar
vein, one could include code obfuscated with our technique
in the training data used to learn a malware classifier. The
main drawback of these mitigations is that obfuscation does
not
imply maliciousness. There are legitimate reasons for
obfuscating code, e.g., protecting intellectual property. Hence,
classifying all code obfuscated by our technique, or any other
obfuscation technique, as malicious is likely to cause an
unacceptably high number of false positives.
Finally, the third mitigation strategy is to jointly analyze
JavaScript and WebAssembly. For detectors based on tradi-
tional program analysis, both static or dynamic, a joint analysis
would reason about how data and control flows between the
two languages. Likewise, learning-based detectors, such as
those used in our evaluation, could feed code in both languages
into their models. We are not aware of any existing malware
detector with support for WebAssembly but hope that our work
will raise awareness that a joint analysis would be useful.
VIII. RELATED WORK
Obfuscation Studies and Techniques: Obfuscation tech-
niques have been observed in various programming languages
and software domains for both malicious and benign purposes.
Previous works categorize obfuscation techniques applied on
malicious code [69] while others compare the effectiveness of
different obfuscation techniques [22], [32], [61]. Some studies