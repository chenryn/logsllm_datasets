### 优化后的文本

#### 概述
我们首先通过调用 `Runtime.enable` 来捕获 `Runtime.executionContextCreated` 事件，该事件在页面的 JavaScript 脚本上下文创建时触发。接着，通过调用 `Debugger.enable` 启用 `Debugger.scriptParsed` 事件，以便在脚本加载时能够查看感兴趣的函数并设置断点。同时，调用 `Network.enable` 可以让我们在新的 HTTP 请求出现时收到通知，从而发现包含“！”的数据（通过在 JavaScript 层拦截编码过的数据可以方便地将 .Proto 定义和 HTTP 请求地址联系起来）。最后，通过调用 `Page.navigate` 告诉浏览器我们要访问谷歌地图。

#### 调试过程
当新脚本被解析时，`Debugger.scriptParsed` 事件会被触发。此时，我们可以通过调用 `Debugger.getScriptSource` 获取脚本源代码，并使用正则表达式或字符串签名来识别相关的函数。然后，调用 `Debugger.setBreakpoint` 设置断点，指定脚本 ID、行号和列号。

具体来说，我们希望调试的函数接受两个参数：`b` 参数是一个定义了 Protobuf 消息的 JavaScript 对象，而 `a` 参数是包含消息数据的简单对象。该函数会使用这些结构序列化数据，并返回包含“！”的数据。

- `Fqa` 函数计算输出数组的大小（4 * 数据项的数量，每个数据项由分隔符、数据项 ID、字符类型和数据项数据组成）。
- `Gqa` 函数将数据写入数组。
- `String.prototype.join` 将数组转换为字符串。

接下来，我们将获取 `b` 并将其转换为可读格式，记录下 `c` 以备后续使用。在最后一行设置断点，观察发出的请求。通过调试器可以看到参数数据：

```javascript
// 示例调试器中的参数数据
```

通过一些推理，我们可以总结出 `b` 的数据结构。尽管已经展示了可读版本，但大多数对象属性仍然是压缩的，因此需要使用正则表达式来提取每个属性的具体信息。

#### 还原 .proto 文件
下一步是还原实际的 .proto 文件。有几种方法：
1. 直接从调试器中获取变量和对象属性，但这非常耗时。
2. 尝试将数据转换为 JSON 格式，但由于嵌套消息会导致循环引用，这种方法也不可行。
3. 正确的方法是通过注入 JavaScript 脚本来获取字符串信息（使用控制台 API）。

JavaScript 可以通过 `Debugger.evaluateOnCallFrame` 在本地调用，或者通过 `Runtime.evaluate` 全局调用。`Runtime.evaluate` 事件会通知我们控制台信息。为了更好地抓取网络请求，我们需要注入一些代码来 hook `history.replaceState()` 方法，这样当主页跳转到包含“！”参数的 URL 时，我们就能第一时间知道。

在与谷歌地图进行一些交互以收集数据后，我们现在拥有了三种关键元素：重构的 .proto 结构和一些包含序列化数据的 URL 示例。

#### 第二个程序
Protobuf 消息采用树形结构表示，手动处理较为复杂。在推断 Protobuf 数据项时，我们发现它们没有名称，因此可以使用一两个字母来命名（最好根据其功能命名，以便更快理解）。我们需要测试所有数据，了解其用途或检查谷歌是否引入了有趣的安全措施。

我打算使用 Python Qt 的 QTreeWidget 来处理消息，每个数据项都会获得一个子部件（例如，QLabel 代表 TEXT 文本，QSpinBox 代表整数等）。最终代码可能有些复杂，因为需要处理重复字段、选择状态和显示请求等。不过这有利于提高可读性和理解性。

#### 0day 漏洞
获取谷歌地图一块场景的请求大约涉及 730 个数据项和 125 个消息。从安全角度来看，这意味着大量的攻击面和许多未被其他人测试的隐藏点。

经过手工测试，我没有发现异常，但对重要的请求进行了分类。首先是地图坐标，有多种方式描述它们（通常是十进制 WGS84 或其他更精确的坐标单元，这对卫星视图很有用）。此外，还有多种方法定义视图，包括各种地图图层、选项、标签、标记位置和行程绘制等。

更重要的是，它不仅提供位图，还提供矢量图。Android 应用多年来一直在使用矢量图，最近 Web 请求也开始部分使用。矢量图有多种专有格式。

位图是常规的二进制格式（DRAT），使用简单的 RC4 密钥混淆（密钥由坐标信息、固定密钥和 ZLIB 组成）。Web 应用中的矢量图只使用二进制的 Protobuf，使用简单的 XOR 方法取代 RC4。二进制数据通过 AJAX 传输（封装在较小的“长度-值”容器中），含义与旧方式相同。

有一种特别有趣的版本，其响应头包含 `Content-Type: text/html`，尽管它是二进制数据。这种基于 Protobuf 的格式也有其他头部信息，通过 RC4 和 ZLIB 处理。它有许多有趣的安全选项，例如关闭加密和处理压缩，从而可以获得原始地图信息，包括地址和标记的原始字符串。

这是一个向谷歌地图插入任意字符串的好方法！通过编辑其他请求的数据域，可以设置标记。一旦尝试启用未文档化的格式，JavaScript 脚本就会弹出警告框。

为了绕过 Chrome 的 XSS 防护机制（或 Firefox 中的 NOSCRIPT 插件），我们需要找到一种编码方式。“！”分隔的数据解码程序接受两种数据格式对应的字符串（即使原来是 Protobuf 格式的一种）。“s” 类型可以将字符串原始数据编码为输出字符串的一部分（只有 `!` 和 `*` 被转义为 `*21` 和 `*2A`）。“z” 类型可以将字符串进行 base64 编码（无填充）。这意味着我们可以绕过 XSS 防御！

你可以进一步混淆数据，但服务器仍可以将“！”分隔的数据转换为原始二进制 Protobuf，并且大部分类型没有安全检查。同时，字符串和消息具有相同的五种二进制格式，因此可以将嵌套消息转换为二进制并作为字符串传递。

现在我们可以在 `www.google.com` 域名下执行任意浏览器的 XSS 攻击代码。进一步研究发现任何人都可以向谷歌地图提交新的地点信息，这些地点或多或少都会出现在地图上（已验证）。确实有一些中国人和印度人提交了地点信息，甚至提供了自己的头像！

#### 厂商回应
谷歌的漏洞奖励计划按照 `www.google.com` 域下的 XSS 漏洞标准给予了 5000 美元的奖金。

- Day 0 — 提交报告
- Day 0.54 — 报告被接受，进入流程
- Day 0.64 — 漏洞被确认
- Day 1 (or so) — 漏洞修复
- Day 1.84 — 

#### 总结
我发现许多 Android 项目都在使用 Protobuf，但可用的解析工具很少。因此，我做了一些收集和整理工作，更多信息请参阅相关文档（包括本文中的一些工具）。