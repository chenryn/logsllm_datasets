首先我们通过调用“Runtime.enable”来捕获“Runtime.executionContextCreated”事件，当一个页面的javascript脚本上下文创建时就会触发。然后，调用“Debugger.enable”,
使
“Debugger.scriptParsed”生效，这样当脚本被加载时我们就可以查看有兴趣的方法并设置断点。调用“Network.enable”，这样每当有新的HTTP请求出现时我们就会接收到通知，以便我们发现含有“！”的数据（通过在javascript层拦截编码过得数据可以方便的把.Proto定义和HTTP请求地址联系到一起）。最后调用“Page.navigate”，告诉浏览器我们要使用谷歌地图。
当一个新脚本出现时，“Debugger.scriptParsed”事件被触发，我们调用“Debugger.scriptParsed”和“Debugger.getScriptSource”，这样我们就可以通过正在表达和字符串签名发现相关的函数。然后我们调用“Debugger.setBreakpoint”来设置断点，指定脚本ID,行和列。
下面是我们希望断下的函数:
它接受两个参数：b参数是一个定义了Protobuf消息的javascript对象，a参数是定义了消息数据的简单对象。函数将会使用这个结构序列化数据，最后返回C（包含“！”的数据）。
“Fqa”函数计算输出数组的大小（4*数据项的个数，每个数据项由分隔符、数据项ID、字符类型、数据项数据等4个字符串组成），“Gqa”将数据写入数组，String.prototype.join将数组转换成字符串。
然后我们获得“b”并把它转换成可读的，记下“c”以留后用。我们在最后一行下一个断点，看看发出了什么请求。下面是调试器中的看到的参数数据：
通过一些推理，我们可以总结下“b”的数据结构了：
尽管我已经向你展示了一个可读的版本，但是大部分的对象属性仍然是压缩过的，所以我们需要使用正则表达式去发现每一个属性对应的具体信息。
我们已经明白了这些数据的含义，下一步是还原出正在的.proto文件。第一种方法是直接从调试器中获取变量和对象属性，但是这种方法实在是太慢了；第二种方法是尝试将数据转换成JSON格式，但是嵌套消息会导致循环应用，所以这种方法也不可行；正确的第三种方法是通过注入javascript脚本获取字符串信息（使用控制台的API）。
Javascript可以通过“Debugger.evaluateOnCallFrame”本地调用，“Runtime.evaluate”全局调用。“Runtime.evaluate”事件会通知我们控制台信息，为了更好地使用“Network.requestWillBeSent”抓取网络请求，我们需要注入一些代码hook
history.replaceState() API方法，这样当主页跳转到含有“！”参数的URL时我们就能第一时间知道了。
在和谷歌地图做一些交互以收集数据后，现在我们拥有了需要的三种元素：重新构造的.proto结构，一些含有序列化数据的URL例子。
**  
**
**第二个漂亮的程序**
Protobuf消息使用树形结构表达，所以想要在命令行里手工处理比较困难。当推断出Protobuf的数据项时，我们发现它们没有名字，这时可以通过一两个字母来命名它们（最好知道它们是干什么的再命名，这样我们在查看信息时就可以理解的更快）。我们同时需要测试所有的数据，这样我们就能知道它们是干什么的，或者看看谷歌是否引入了一些有趣的安全措施。
我打算使用Python Qt的QTreeWidget来处理消息，每个数据项都会获得一个下一级的QTreeWidgetItem（子部件中QLabel
代表TEXT文本, QSpinBox
代表整数等等）。最终的代码可能会有些纠结，因为我们我要处理重复的字段，数据项被选中的状态，显示request请求等等。但是这毕竟有利于可读性和便于理解。
下面就是程序运行后的样子：
**0day漏洞**
获取谷歌地图一块场景的请求大概有730个数据项，125个消息(
)。从安全角度看，这是很令人高兴地，这意味着大量的攻击界面，大量隐藏的未被其他人测试的点。
我持续做了一些手工测试，但是没有发现异常，所以我把重要的请求做了分类。
首先是地图上的坐标，有很多方式可以描述他们（通常是十进制WGS84，或者其他更大更精确的坐标单元，这对于卫星视图很有用）。如果你需要一个精确地地图，同样有其他方法来定义一个视图。这里基本上有你希望绘制地图的所有方式，有各种各样的地图图层、选项，可以在地图上显示标签，标记位置，绘制从一个方向到另一个的行程，涵盖所有服务器端有的地图绘制功能。
但更重要的是，它不仅提供bitmap。它也提供矢量图；Android应用程序已经使用矢量多年了，web请求最近也有部分在使用。有多种格式的矢量，所有这些都是专有的。
Bitmap是常规的二进制格式（DRAT），使用二进制格式可以方便的存储地图提供的数据，及决定什么时候地点出现，改变，消失的版本信息。数据是由一个简单的RC4
key混淆的（这个key由坐标信息，一个固定的key和ZLIB组成）。
已经集成到WEB应用中的矢量图方式只使用了二进制的Protobuf—再强调一遍，这是web应用中的PROTOBUF的第二种形式。这里更有效率的简单XOR方法取代了RC4，二进制数据通过我们之前提到的AJAX传输（封装在较小的“长度-值”容器里）,这些数据和老的方式含义一致。
你可以使用十几个版本格式里的任意一个，但是这里面有一个版本特别的有趣。它的response 头里含有“Content-Type: text/html”
头部，尽管它是二进制的数据。它是基于Protobuf的格式，它也有其他格式的头部，所以它也是通过RC4+ZLIB处理的。它有很多有趣的安全选项，一个是可以关闭加密选项，一个是处理压缩的。所以你将获得原始的地图信息，包括代表地址和标记原始的字符串，这些将以text/html的形式发送给你的浏览器。
这是一个向谷歌地图里插入任意字符串的好方法！通过编辑其他请求的数据域将允许你设置标记。
一旦你尝试启用我们发现的未在文档里说明的格式，javascript脚本就会弹框了！
为了绕过chrome的XSS防护机制（或者火狐中的NOSCRIPT插件），我们需要找到一种编码方式。“！”分隔的数据的解码程序接受两种数据格式对应的字符串（即使它原来是Protobuf格式的一种）。“s”类型可以将字符串原始数据编码为输出字符串的一部分（只有！和*被转义为“*21”和“*2A”）。“z”类型可以讲字符串做base64编码（非padding）。这意味着什么?XSS防御即将被绕过了！
你可以进一步的混淆数据，但是服务器仍可以讲“！”分隔的数据转换成原始的二进制PROTOBUF，并且大部分的类型没有做安全检查。同时字符串和消息拥有相同的二进制的五种数据格式，所以我们可以将嵌套消息转换成二进制，并且当成字符串传递。
现在我们可以拥有了www.google.com（maps.google.com已被放弃）域名下任意浏览器可执行的XSS 攻击代码。
进一步研究发现任何人都可以给谷歌地图提交新的地方信息，这些地方或多或少都会在地图上出现（已验证）。那么是否已经有人提交过到谷歌地图上了呢？是的，一些中国人和印度人做过，他们甚至提供了自己的头像！
**厂商回应**
谷歌的漏洞奖励计划按照www.google.com域下的XSS漏洞标准给我提供了5000$的奖金。
Day 0 — 提交报告
Day 0.54 — 报告被接受，进入流程
Day 0.64 — 漏洞被确认
Day 1 (or so) — 漏洞修复
Day 1.84 —
**总结**
我发现很多的Android项目都在使用Protobuf ，但是可用于解析Protobuf
的工具却很少。所以我做了一些收集和整理工作，更多信息请看 （包括本文中的一些工具）。