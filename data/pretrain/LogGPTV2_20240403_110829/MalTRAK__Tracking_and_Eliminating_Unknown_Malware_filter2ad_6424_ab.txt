ery and incorporates expensive snapshots of the system. Windows
System Recovery [32] is another approach which maintains peri-
odic absolute snapshots of the system to be able to restore to a
previously saved snapshot.
Current snapshot based approaches contain no state information
which can result in the user reverting to a snapshot that might cause
reinfection and/or resulting in the loss of too much clean data. It
also results in considerable overhead in terms of both time and
space during the snapshot.
Filesystem based approaches: These approaches implement
a seperate ﬁlesystem for crash recovery purposes. LFS [26] is a
ﬁlesystem which is structured like a log. This speeds up both ﬁle
writing and crash recovery. Reparirable File Service [33] uses a
similar idea to repair compromised ﬁle servers such as NFS. It
interposes a RFS server which implements logs to restore ﬁle op-
erations later.
Filesystem based approaches in general do not maintain any
state information about the ﬁles such as parent/child relationships
(Repairable File Service however uses client-side logging to track
parent/child relationship). Filesystem based approaches only pro-
vide unconditional restore feature. Further, they are tied only to
the ﬁlesystem and do not provide conﬁguration restoration such
as the registry. Finally, they are not designed to be implemented
on top of a regular ﬁle system such as those found in commodity
OSes such as Windows and Linux.
Behavior/Semantic based approaches: These approaches
employ a combination of static and dynamic techniques (disassem-
bly and monitoring) in order to characterize a program. Behavior
based spyware detection [15] uses detects known and unknown
spyware which use the Browser Helper Object (BHO) extensions.
It is based on the notion that such extensions normally do not leak
data beyond their operating space. However, it only detects spy-
ware and is not applicable to general malware. Gifﬁn et al. [6]
disassemble a binary to remotely detect manipulated system calls
in a malware. Kruegel et al. [17] employ static binary analysis
to detect kernel-level rootkits. SAFE [3] and Semantic-Aware Al-
gorithm [2] are other examples of malware detection algorithms
employing similar static analysis techniques. The problem with
the above approaches is that they incur considerable runtime over-
head to be deployed dynamically. While they can be used as a
passive component (to scan after an infection), they suffer from
limitations regarding disassembly (obfuscation [20] and instruc-
tion overlap [4]). Further, a malware could hide itself once active
and prevent such operations in the ﬁrst place.
In comparison, our framework does not require the user to make
distinction between untrusted and trusted and does not use virtual
machine based or absolute snapshots which take up too much re-
sources. It allows all processes to run to completion while at the
same time is capable of restoring a system back to a previous state
in case of any infection. It incurs very little or no perceptible over-
head as seen from our performance measurements. Last but not
the least, it tracks system operations from the lowest possible level
making it very difﬁcult to subvert.
3 Design
3.1 Overview
Figure 1 illustrates the components of our framework: a view
engine, a mapper engine, an interceptor engine and a disinfection
engine. The view engine maintains different logical states of the
system which can be switched to, back and forth. The mapper en-
gine ties the different views together with state information that is
used as an aid during disinfection. The interceptor engine endows
the framework with the ability to capture changes that occur to the
system state dynamically at the lowest possible level. The disin-
fection engine is responsible for removing the effects of malware
(if any) and revert the system back to a clean state. The following
sections describe our design goals and the framework components
in further detail.
Figure 1. Framework Overview
3.2 Design Principles, Assumptions and Goals
The design of our framework is based on the following core
principle: Design for Protection against Persistence. Our assump-
tion is that: The framework will initially be deployed on a clean
system.
From our design principle, our framework should prevent a
313313
              FrameworkUser-Mode Processes/ThreadsFrameworkDisinfection ConsoleKernel-Mode Threads/DriversIntercept EngineView EngineMapping EngineDisinfection EngineOS Core KernelOS User-Mode System InterfaceFile-System DriversUser-ModeKernel-Modemalware from persisting in the system. We argue that a malware,
in most if not all cases, will make an effort to remain persistent in
the system so that it can get control most of the time and propagate
and cause damage. We believe that our assumption is reasonable
since if a user already had an infection and an anti-virus tool is
unable to detect or clean the infection, the user would in any case
restore the system from a backup or a fresh installation. Note that,
from our principle we do not take into account the runtime in-
tegrity of the system. In other words, a malware is free to modify
the system or even grind it to a halt, however using our framework,
a simple restart will be capable of removing it from the system.
Given the above principle and assumption, the following are our
design goals:
• Ensure that the user can always revert back to a system state
that is devoid of any malicious footprints
• The user, most of the time, would ﬁnd no perceptible differ-
ence in system speed when running the framework as com-
pared to doing so without the framework.
• Ensure that the loss of clean data is minimized during disin-
fection.
• Ensure that the framework can capture all interactions that
modify system state at all times.
3.3 Views
A view is a logical representation of the state of the system at
any given point in time. By state we mean the persistent state (e.g
ﬁlesystem and conﬁguration information). It is represented as Vn
where n is the view identiﬁer.
Views are composed of objects. An object could be a ﬁle, a
folder or a conﬁguration key or value. An object view represents
the contents of the object that is visible to the entire system for a
given view. An object session is deﬁned as the time from when the
object is opened for access to when it is closed/deleted.
The framework creates a new view whenever a modiﬁcation
(write) is detected on the current view. This is similar to the copy-
on-write(COW) mechanism that is used in virtual memory sys-
tems. This approach has the advantage that we can track modiﬁca-
tions to the system state at a very ﬁne level. Note that, creation of
new objects within a view will not go through this COW mecha-
nism. The COW is only employed when a modiﬁcation is detected
to an existing object within a view. Further, the COW is performed
on an object session as a whole, which means that once the object
is opened, further accesses to it occur on the COWed copy.
While on the surface the COW mechanism might look like an
overkill, in fact it is not so. Consider the case when an object is
a ﬁle. Modiﬁcations are very seldom done to executable ﬁles but
only to data ﬁles in the normal course of system operation. Further,
typically an application opens a ﬁle during start, reads/writes to it
and closes it once it is done. These facts make our approach very
efﬁcient (see Section 5.2 for the framework performance evalua-
tion)
For an object On, the object view is denoted by: Om
n where m
represents the view level of the object. The current view level of
an object is essentially the number of times the object has been
COWed. The view level of an object On that has never been
COWed is 0 and is denoted using O0
n. For the rest of the paper,
314314
we will use Fn to denote a ﬁle object, Dn to denote a directory
object and Cn to denote a conﬁguration object and On to denote
an object in general.
Figure 2. Framework Design: Views; (a) System
Operations on a group of ﬁles, and (b) Correspond-
ing views (logical states) that can be switched to
back and forth
The concept of views and how they operate is best explained
using an example. Let us consider pseudo-code in Figure 2a. The
pseudo-code describes a system performing a set of operations on
a certain group of ﬁle objects F0, F1 and F2. Figure 2b shows the
resulting views within our framework.
0 , F 0
0 , F 0
1 and F 0
1 and F 0
View V0 consists of ﬁle object views F 0
2 . When
ﬁle object F0 is opened in line 1, Figure 2a, a new view V1 is
created consisting of ﬁle object views F 1
2 . Since, ﬁle
object F0 was opened for read and write, it is COWed within view
V1 resulting in the ﬁle object view F 1
0 . Operations in lines 3–9,
Figure 2a are then performed on ﬁle object views in V1. Note that
though these set of operations result in multiple writes to ﬁle object
F0, they do not result in the creation of new views since it is still
in the same ﬁle object session. When ﬁle object F1 is opened for
write in line 10, Figure 2a, a new view V2 with ﬁle object views
2 is created. The opening of ﬁle object F0 in line 13,
0 , F 1
F 1
Figure 2a results in the creation of a new view V3 with ﬁle object
views F 2
2 since ﬁle object F0 was closed and reopened
again for write signifying a new ﬁle session. Hence, it was COWed
within view V3 resulting in ﬁle object view F 2
0 .
1 and F 0
0 , F 1
1 and F 0
The views shown in ﬁgure 2b thus represent the various logical
states of the system — states that can be switched to and fro.
3.4 Mappings
Mappings are a mechanism which provide a way to link object
views within views. Essentially a mapping seeks to ﬁnd the object
n which is responsible for creating or modifying an object
view Om
view Ox
y . We write this relationship as:
p(Ox
y ) = Om
n
For example, let us consider a target code stream that results in the
creation of a ﬁle object view F x
y within a view Va. If the target
code stream resides in a regular executable, a user- or kernel-mode
dynamic library or, a kernel-driver, p(F x
y ) = F m
n is
the ﬁle object view for the executable image ﬁle.
If the target
code responsible for resides in an allocated range of memory, then
p(F x
n is the ﬁle object view of the executable
image ﬁle that allocated the range of memory.
n , where F m
n , where F m
y ) = F m
An object view Om
n can also have an indirect relationship with
n accessed an
y . This could be the case when Om
object view Ox
 1. OPEN F0 2. OPEN F2 3. READ F2AT OFFSET a 4. WRITE F0AT OFFSET b 5. READ F2AT OFFSET a+512 6. WRITE F0AT OFFSET b+512 7. READ F2AT OFFSET a+1024 8. WRITE F0AT OFFSET b+1024 9. CLOSE F010. OPEN F211. WRITE F2AT OFFSET c12. CLOSE F213. OPEN F014. WRITE F0AT OFFSET b+409615. CLOSE F0F00F10F20F01F10F20F01F11F20F02F11F20V0V1V2V3(a)(b)object view that was created or modiﬁed by object view Ox
vice versa. We write this relationship as:
y or
s(Ox
y ) = Om
n , s(Om
n ) = Ox
y
Let us consider Figure 3a which shows various views in a system.
Let us assume that within view V0 a malware comes as an email
attachment which consists of a ﬁle view object F 0
1 . When the user
clicks this attachment, the email client whose executable image
ﬁle object view is F 0
1 . Further, lets assume that F 0
1
2 and loads it into the system. This results
creates a kernel driver F 0
in the creation of view V1. Assume that F 0
2 now writes to an exe-
cutable F 0
3 . This results in the creation
of view V2. Then let us assume that the user runs an executable
compression program stored in F 0
3 and creates a
output executable F 0
5 , resulting in the creation of view V3.
3 and infects it creating F 1
4 which reads F 1
0 , executes F 0
Figure 3. Mappings; (a) Different views consisting
of ﬁle object views in the system, and (b) the rela-
tionship between the various ﬁle object views
Figure 3b shows the mapping for this scenario. The direct rela-
tionships are indicated via a single line whereas the indirect rela-
tionships are indicated via a double line. Further the arrows in the
indirect relationships signify the direction of access. In our exam-
ple, F 0
2 . Hence the arrowhead
points to F 0