mar.
3.2 Concurrent Input
A fundamental difference between a protocol parser and a yacc-
style parser is their input model. A protocol-parser has to parse
many connections simultaneously and, within each connection, the
two ﬂows on opposite directions, in parallel. For example, in per-
sistent HTTP connections each request needs to be associated with
the correct reply. Similarly, the syntax of a SUN/RPC reply de-
pends on program and procedure ﬁelds in the corresponding RPC
call [39].
Parsers generated by yacc/lex process input in a “pull” fash-
ion. That is, when input is incomplete, the parser blocks, waiting
for further input. Thus, a thread can handle only one input stream at
a time. To handle ﬂows simultaneously without spawning a thread
class HTTP Conn : public binpac::ConnectionAnalyzer
{
public:
// Virtual functions defined in ConnectionAnalyzer.
virtual void NewData(bool is orig,
const u char *begin,
const u char *end);
virtual void NewGap(bool is orig, int gap length);
virtual void FlowEOF(bool is orig);
};
Figure 1: The interface of a binpac-generated parser.
for each one, the parsers must instead process input incrementally
as it comes in, partially scanning and parsing incomplete input and
resuming where the analysis left off when next invoked.
3.3 Robustness
Parsing errors are inevitable when processing network trafﬁc. Er-
rors can be caused by irregularity in real-world trafﬁc data (protocol
deviations, corrupted contents) as well as by incomplete input due
to packet drops when capturing network trafﬁc, asymmetric rout-
ing (so that only one direction of a connection is captured), routing
changes, or “cold start” (a connection was already underway when
the monitor begins operation). Unlike compilers, protocol parsers
cannot simply complain and stop processing, but must robustly de-
tect and recover from errors. This is particularly important if we
consider the presence of adversaries: an attacker might specially
craft trafﬁc to lead a protocol parser into an error condition.
4. THE LANGUAGE
In the previous section we examined the grammatical character-
istics of network protocols. This section describes the design of the
binpac language and its compiler, which are speciﬁcally tailored
to address these properties.
Here we assume that a parser generated from the binpac lan-
guage receives data from a lower-level protocol (such as TCP) an-
alyzer, with the interface outlined in Figure 1. While one can also
use the binpac language to build parsers for TCP/IP packets, a de-
tailed description of a TCP analyzer—how to manage states of TCP
connections and invoke corresponding application analyzers—is
beyond scope of this paper. Instead we just assume existence of
lower-level analyzers and focus on application level parsers in fol-
lowing discussion.
We begin with a description of binpac’s data model in Sec-
tion 4.1, corresponding to production rules in BNF grammars. In
Section 4.2 we discuss state-holding, in Section 4.3 how to add
custom computation, and ﬁnally in Section 4.4 the “separation of
concerns” to provide reusability.
Throughout the discussion we will refer to the examples in Fig-
ures 2 and 3, which show speciﬁcations of HTTP and DNS parsers
in binpac, respectively. We use them to illustrate features of the
binpac language. Note that the HTTP parser shown in Figure 2
is complete by itself (though simpliﬁed from the fully-featured
one we built for Bro, and evaluate below), except for the MIME-
decoding of HTTP bodies and escape sequences for URIs.1 The
former takes signiﬁcant additional work to add; the latter can be
incorporated easily by processing the raw, extracted URI with an
additional function call. Due to space limitations, we only show an
excerpt of the DNS parser, though this includes the technically most
difﬁcult element of parsing the protocol, namely compression-by-
indirection of domain names.
1The string comparisons and has preﬁx() in Figure 2 are in fact case-
insensitive, but here simpliﬁed for presentation.
In the language,
text between %.*{ and %} (for example,
%header{ and %}) embeds C/C++ code. binpac keywords re-
ﬂecting optional attributes start with “&” (e.g., &oneline). Key-
words starting with “$”, such as $context and $element, are
macros instantiated during parsing. In the examples, we highlight
binpac keywords (except for elementary types, introduced be-
low) using bold slant fonts. Table 4 summarizes the binpac lan-
guage constructs.
4.1 Data Model
binpac’s data model provides integral and composite types
which allow us to describe basic patterns in protocol data lay-
out, parameterized types to pass information between grammar ele-
ments, and derivative data ﬁelds to store intermediate computation
results. We discuss these in turn.
4.1.1 Integral and Composite Types
A binpac type describes both the data layout of a consecutive
segment of bytes and the resulting data structure after parsing. Type
empty represents zero-length input. Elementary types int8,
int16, int32 represent 8-, 16-, and 32-bit integers, respectively,
and so do their unsigned counterparts, uint{8,16,32}. As the
speciﬁcation of HTTP ReplyLine shows (Figure 2), a string type
can be represented with a constant string (line 80), a regular ex-
pression (line 81), or a generic bytestring either of a speciﬁc
length (with &length, line 101) or running till the end of data
(with &restofdata, line 92).
Elementary integer and string types map naturally to their coun-
terparts in C++ (in the case of string, we deﬁne a simple C++
class to denote the begin and end of the string). This is how the
results are stored and accessed, with one exception. We allow
a string to be “chunked” to handle potentially very long byte se-
quences, such as HTTP bodies, with a &chunked attribute (Fig-
ure 2, line 100). A chunked string is not buffered. Rather, with the
&processchunk attribute one may deﬁne computation on each
chunk to process the byte sequence in a streaming fashion. For in-
stance, to compute a MD5 checksum for every HTTP body we may
add a &processchunk as follows (assuming compute md5
maintains intermediate results across chunks):
http_body: bytestring &chunked,
&length = $context.flow.content_length(),
&processchunk($context.flow.compute_md5($chunk));
External C++ types, including bool, int, and user-deﬁned
ones (declared with extern type), can be used in computation,
e.g., as types of parameters, but cannot appear as types of data ﬁelds
in protocol messages.
Users can deﬁne composite types: (1) record, a sequential
collection of ﬁelds of different types; (2) case, a union (in the
C-language sense) of different types; and (3) array, a sequence
of single-type elements. binpac generates a C++ class for each
user-deﬁned type, with data ﬁelds mapped as class members, and a
parse function to process a segment of bytes to extract various data
ﬁelds according to the layout speciﬁcation.
As we compare record and case types with context-free
grammar production rules, we can see a clear correspondence be-
tween them: a concatenation of symbols maps to a record type
and multiple production rules of a symbol map to a case type. But
there is a difference in the latter mapping. The case type corre-
sponds to a set of production rules with zero look-ahead. Instead, a
production rule is selected based on an explicit indexing expression
computed from other data ﬁelds or type parameters (Figure 2, line
=
Language Construct
%header{ ... %}
%code{ ...
%}
%member{ ... %}
analyzer ... withcontext
connection
upflow/downflow
flow
datagram = ... withcontext
flowunit = ... withcontext
enum
type ...
record
case ...
default
(cid:2)type(cid:3)[]
RE/.../
bytestring
extern type
function
refine typeattr
(cid:2)type(cid:3) withinput (cid:2)input(cid:3)
&byteorder
&check
&chunked
of
&exportsourcedata
&if
&length = ...
&let
&oneline
&processchunk
&requires
&restofdata
&transient
&until
Brief Explanation
Copy the C++ code to the generated header ﬁle
Copy C++ code to the generated source ﬁle
C++ declarations of private class members of connection or ﬂow
Declare the beginning of a parser module and the members of $context
Deﬁne a connection object
Declare ﬂow names for two ﬂows of the connection
Deﬁne a ﬂow object
Declare the datagram ﬂow unit type
Declare the byte-stream ﬂow unit type
Deﬁne a “enum” type
Deﬁne a binpac type
Record type
Case type—representing an alternation among case ﬁeld types
The default case
Array type
A string matching the given regular expression
An arbitrary-content byte string
Declare an external type
Deﬁne a function
Add a type attribute to the binpac type
Parse (cid:2)type(cid:3) on the given (cid:2)input(cid:3) instead of the default input
Deﬁne the byte order of the type and all enclosed types (unless otherwise speciﬁed)
Check a predicate condition and raise an exception if the condition evaluates to false
Do not buffer contents of the bytestring, instead, deliver each chunk as $chunk to &processchunk
(if any is speciﬁed)
Makes the source data for the type visible through a member variable sourcedata
Evaluate a ﬁeld only if the condition is true
Length of source data should be ...
Deﬁne derivative types
Length of source data is one line
Computation for each $chunk of bytestring deﬁned with &chunked
Introduce artiﬁcial data dependency
Length of source data is till the end of input
Do not create a copy of the bytestring
End of an array if condition (on $element or $input) is satisﬁed
Section
§4.2
§4.2.2
§4.2.1
§4.2.1
§4.2.1
§4.2.1
§4.2.1
§4.1.1
§4.1.1
§4.1.1
§4.1.1
§4.1.1
§4.1.1
§4.1.1
§4.1.1
§4.2
§4.4
§4.1.4
§4.1.3
§5.2.1
§4.1.1
§4.1.4
§4.1.1
§4.1.4
§5.1
§4.1.1
§4.1.1
§6
§4.1.1
Example
Fig. 2, #15
Figure 5
Fig. 2, #1
Fig. 2, #37
Fig. 2, #38
Fig. 2, #40
Fig. 3, #64
Fig. 2, #41
Fig. 2, #5
Fig. 2, #11
Fig. 2, #49
Fig. 2, #45
Fig. 2, #103
Fig. 2, #87
Fig. 2, #11
Fig. 2, #73
Fig. 2, #13
Fig. 3, #67
Fig. 6
Fig. 3, #59
Fig. 3, #7
Fig. 3, #34
Fig. 2, #100
Fig. 3, #7
Fig. 3, #16
Fig. 2, #101
Fig. 2, #63
Fig. 2, #63
Fig. 2, #73
Fig. 2, #87
Table 1: Summary of binpac language constructs.
99). This allows production rule selection to be based on external
information, and is in spirit similar to “predicated parsing” intro-
duced in ANTLR [30]. On the other hand, the zero-look-ahead re-
striction simpliﬁes parser construction, but at the same time poses
little limitation on the range of protocols that can be speciﬁed in
binpac. We believe that it is by design of protocols (rather than
by coincidence) that there are few syntax patterns that require look-
ahead. Since protocol data is generated and processed by programs,
it is usually organized in a way that simpliﬁes the (traditionally
hand-written) implementation.
Although an array can be deﬁned with recursive production
rules, we ﬁnd it a common enough idiom in protocol syntax that it
justiﬁes a separate abstraction. In binpac, the length of an array
can be speciﬁed with an expression containing references to other
data ﬁelds, as in the deﬁnition of DNS message (Figure 3, lines
3-6). An array can also be deﬁned without a length, but with some
“terminate condition” that indicates the end of array. Such a con-
dition is speciﬁed through the &until attribute with a conditional
expression. The expression can be computed from the input data
to each element ($input), as in HTTP Headers (Figure 2, line
87), or from a parsed element ($element), as in HTTP Chunks
(line 106).
4.1.2 Type Parameters
As the examples of HTTP and DNS parsers show, type param-
eters (e.g., in type HTTP Body, Figure 2, line 98) allow one to
pass information between types without resorting to keeping exter-
nal state. This is a powerful feature that can signiﬁcantly simplify
syntax speciﬁcation.
type NDR_Format = record {
# Note, field names taken from DCE/RPC spec.
intchar
: uint8;
floatspec : uint8;
reserved : padding[2];
} &let {
ndr_byteorder = (intchar & 0xf0) ?
littleendian : bigendian;
};
type DCE_RPC_Message = record {
: uint8 &check(rpc_vers == 5);
# Raise an exception if RPC version != 5
rpc_vers
rpc_vers_minor : uint8;
: uint8;
PTYPE
pfc_flags
: uint8;
# ‘drep’--data representation
packed_drep
...
: NDR_Format;
} &byteorder = packed_drep.ndr_byteorder;
Figure 4: Specifying dynamic byte order with &byteorder.
4.1.3 Byte Orders
For use with binary protocols, binpac allows the user to spec-
ify the byte order using a &byteorder attribute. Figure 4 shows
the speciﬁcation of dynamic byte-order in DCE/RPC, where at
the bottom the user speciﬁes that the byte-order is taken from the
ndr byteorder ﬁeld that is deﬁned earlier.2
In most cases we also want to propagate the byte-order speciﬁ-
cation along the type hierarchy to the other types. Conceptually
we can pass byte order between types as a parameter (see Sec-
tion 4.1.2), but in practice the byte order parameter is required
2We discuss the deﬁnition of “derivative ﬁelds” such as ndr byteorder
in Section 4.1.4.
2
3