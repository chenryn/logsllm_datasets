e3 and e4 to true and reaches step 3. Without loss of generality,
assume the core component ﬁrst tries true for e1. Beware that the
core can detect functionally equivalent terms, based on the theory
ConstraintsS3RegexReductionZ3SAT and a possible modelUNSATCongruence closure coreSAT solverString theory plug-inZ3-str-starBuilt-in theory solvers:-arithmetic, …of uninterpreted functions. Hence, it puts {x, y, “abc”· m, “ef g”·
n} into one equivalence class and notiﬁes the string theory plug-in.
We note that the plug-in string theory Z3-str can only know about
the equivalent terms that belong to its theory.
As a side remark, if we have an equation length(x) = 4, then
Z3-str is not aware of the fact that length(x) is equal to 4. How-
ever, if e2 were set to true, Z3-str would know that x is equiva-
lent to a constant string of length 4. Therefore, it can deduce that
length(x) is equal to 4, thus subsequently passing this informa-
tion to the arithmetic theory.
Back to the example, with the above equivalence class at step
3, Z3-str detects a conﬂict and then informs the core component
about the new ﬁnding through an axiom e3 ∧ e4 → ¬e1. With this
new axiom, the core component backtracks and tries false for
e1. When the core component backtracks, it discards the relevant
fact and any insertions into equivalence classes as the consequence
of the fact. The core then derives that e2 must be true and this
assignment is performed in step 4.
Based on the concatenation semantics, Z3-str can infer that n
must be “h”. This new ﬁnding is formulated by introducing a new
boolean variable e5 representing n = “h” and an axiom “ef gh” =
“ef g” · n ⇒ e5, which is sent back to the core. From the existing
facts and the new axiom, the core component derives e5 is true.
After all boolean expressions have been assigned consistently and
Z3-str can ﬁnd the satisfying values for string variables x, y, and n,
the search procedure terminates.
4.2
Improvement of Z3-str-(cid:63) over Z3-str
Z3-str-star (or Z3-str-(cid:63) for short), a component of our tool, is
responsible for solving equations between string expression and
recursively-deﬁned functions. It can be viewed as a signiﬁcant ex-
tension of Z3-str with the support of recursively-deﬁned functions,
introduced to facilitate representing and reasoning about the Kleene
star and commonly used high-level string operations.
As mentioned before, in its current implementation, Z3-str does
not know about equivalent terms that belong to other theories, es-
pecially the arithmetic theory. Another important improvement of
Z3-str-(cid:63) (over Z3-str) is its direct interactions with the Z3 core, to
query about the equivalence classes among multiple theories. More
speciﬁcally, it asks Z3 core two following questions:
• Is a string length “ground" with a non-negative constant?
• What is the relationship (=, ,≤,≥) between different
length variables?
To answer these questions, we extend Z3 API so that Z3-str-(cid:63) can
interact with the congruence closure core, similarly to other built-in
theory solvers. Moreover, the newly introduced API methods also
help us to query about other inequality relationship, if necessary.
Answers to these questions ultimately allow us to propagate the
information of string lengths to string theory solver so that string
and non-string constraints can be simultaneously reasoned about.
In short, this gives us a truly incremental solver for strings and non-
strings. We will revisit this side contribution in our experimental
evaluation – Section 6.
5. ALGORITHM
5.1 Top-level Algorithm
S3 ﬁnds a list of string assignments that satisﬁes the input for-
mula or decides that no satisfying assignment exists. Algorithm 1
summarizes its top level algorithm.
Input: F : Formula
(cid:87)n
Output: (IsSat : bool, Solutions : (variable, string) list)
reduced_F ← reduce(F);
i disjuncti ← normalize_to_DNF(reduced_F);
for i = 1 to n do
(Res, Sols) ← Z3-str-(cid:63)(disjuncti);
if Res = SAT then
return (true, Sols);
end
end
return (false, []);
Algorithm 1: Top-level Algorithm
Given an input formula F, S3 recursively reduces F into new
formula reduced_F, which may contain equations (among string
expressions and recursive functions such as star) and length con-
straints. Here we only take into consideration the string and length
constraints, non-string constraints will be unchanged unless other-
wise stated. Reduction rules may result in a disjunctive formula.
Thus, the next step is to normalize reduced_F into disjunctive nor-
mal form (DNF). To decide the satisﬁability of each disjunct, we
extend Z3-str [39] to support recursive functions. In particular, we
use the recursive function star to represent the Kleene star. For
presentation purpose, we ﬁrst only discuss how to handle the star
function, calling our extended component Z3-str-(cid:63). Similar treat-
ment for high-level operations such as replaceAll will be elabo-
rated later. If Z3-str-(cid:63) ﬁnds a satisﬁable disjunct, it stops and re-
turns the corresponding satisfying assignments. Otherwise, it de-
cides that no such assignment exists.
5.2 Reduction of Regular Expressions
Rule
[CONST]
[UNION]
[CONCAT]
[STAR]
Reduction
e ∈ s → e=s
e ∈ r1+r2 → e ∈ r1 ∨ e ∈ r2
e ∈ r1·r2 → e=e1·e2 ∧(cid:86)2
e ∈ r(cid:63) → e
∨
= star(r, n)
i=1 ei ∈ ri
Table 3: Reduction Rules
Given an input constraint formula, we ﬁrst reduce membership
predicates into equations among string expressions and star func-
tion. The reduction rules are summarized in Table 3. Our aim is
to obtain a list of new constraints of the form that can be solved
incrementally by Z3-str-(cid:63) — equations among string expressions
and recursively-deﬁned functions, along with length constraints.
These rules deal with constraints checking if a string expression
e (LHS) is in a regular expression (RHS). If the RHS is merely a
string constant, rule [CONST] will convert such membership con-
straint into an equality. The next two rules handle the case when the
RHS is constructed by union and concatenation operations. While
rule [UNION] ensures that the LHS expression e is a member of one
of the RHS sub-expressions (of the union), rule [CONCAT] splits e
into two fresh string variables, namely e1 and e2, and checks that
they satisfy the condition e1 ∈ r1 ∧ e2 ∈ r2 conjunctively.
The RHS regular expression can also be formed by repeating r
zero or more times (Kleene star). Rule [STAR] encodes such con-
straint as an equation, where the LHS is a string expression and the
RHS is a symbolic representation for a family of strings generated
by the Kleene star. The fresh (symbolic) integer variable n indi-
cates the frequency where r is repeated. This symbolic variable is
used to:
• Distinguish different star functions, which have the same
base regular expression (e.g. r).
• Guide the on-demand unfolding in the recursively-deﬁned
functions such as star or replaceAll (that will be discussed
later).
• Interact with the Arithmetic Solver module in Z3.
∨
When r is a constant string and n is a concrete value, the
= operator
is interpreted as equality operator =. For convenience, we overload
∨
= with the = notation.
In short, after the reduction for regular expressions, we have
equations among string expressions and recursively-deﬁned star
functions, along with length constraints. Z3-str-(cid:63) is then responsi-
ble for solving them.
5.3
star Functions
Z3-str-(cid:63) extends Z3-str [39] with the support for handling star
functions. The internal language is extended with the following:
Term:str
::= ConstString
|
|
...
star(Term:regexpr, Term:int)
Like Z3-str, Z3-str-(cid:63) also works as a plug-in of Z3. It is notiﬁed
by the Z3 core component when a string equation is asserted as part
of the try-and-backtrack process. In particular, the core component
invokes a callback function in the plug-in, providing the abstract
syntax tree (AST ) of the equation as an input parameter. The call-
back function inspects the AST , and if it involves string operations,
the function tries to reduce AST to a simpler abstract syntax tree,
say AST (cid:48). The reduction is conveyed to the core component by
adding an axiom with the form of AST ⇒ AST (cid:48). Recall that
since the core component does not understand the string domain, it
treats both AST and AST (cid:48) as independent boolean variables. Be-
cause AST has been assigned a true value, with the new axiom,
the core will assign true to AST (cid:48) as well, which is a new fact,
and in turn triggers further plug-in processing. Thus, to act as a
plug-in, we need to provide reduction rules for each callback from
Z3.
We list selected reduction rules in Table 4. There are 3 cases of
interest related to star functions:
• when star appears in one side of an equation,
• when star appears in both side of an equation and
• when star can be used to concretize other concatenations
based on its concrete string value.
The gist of our reduction rules is to make use of the semantics
of star functions (or their previous forms – regular expressions
with Kleene star). In fact, with a membership constraint such as
x ∈ (“ab”)(cid:63), we can directly make use Z3-str to generate the possi-
ble string assignments for x, then checking membership is straight-
forward since x is already ground. However, this naive approach is
likely to be inefﬁcient. Sometimes, it may be worse than Kaluza’s
approach, where the lengths are used to reﬁne the string constraints.
To deal with star functions effectively and efﬁciently, we propose
to reduce it lazily and only on demand. We call that technique
“unfold and consume". The basic principle is to lazily unfold its
semantics, until we ﬁnd a matching between constant string seg-
ments in the two sides of an equation. At that time, we can easily
to choose either consume these constants (of course with the capa-
bility of backtracking), or to ﬁnd a conﬂict between unmatchable
constants in the two sides.
r
Incremental Solving for star Functions
In Table 4 we introduce four auxiliary functions: csm_hd(s, r),
csm_tl(s, r),
csm_hd(r2, r1), and csm_all(s, r). The ﬁrst one
takes a constant string and a regular expression, and returns a list
of strings si such that: s ∈ r·si. Intuitively, this function aims to
consume the preﬁx of s matching r. Similarly, while the second,
csm_tl(s, r), consumes the sufﬁx of s matching r, the third one
applies to two regular expressions instead. Lastly, csm_all(s, r)
checks if s can be consumed completely by matching it with r.
Now, let us have a look at reductions rules in Table 4. The rule
[CON−(cid:63)] says about the case when star(r, n) equals to some con-
stant string s. As we explained above, method csm_all(s, r) is
used to decide whether s can be a member of r(cid:63). If yes, we can
update other string expressions that contain star(r, n). Otherwise,
it is a conﬂict and Z3 core component will need to backtrack. Note
that, in Table 4, all E1, E2 and E3 are concatenations among string
expressions and star functions.
The rules [HT−(cid:63)] and [HD−(cid:63)] are to handle the case when there
is a matching between star and a constant string. In the latter, the
matching is at the beginning of the LHS; while the former is a spe-
cial case of it, where the matchings occur at both ends. These two
rules will be elaborated more in the next example. Similarly, we
have the rule [TL−(cid:63)] for the matching at the end of the LHS.
r
The rule [HD−(cid:63)−(cid:63)] ([TL−(cid:63)−(cid:63)], [HT−(cid:63)−(cid:63)]) is applied when there
are two star function at the beginning (end or both) of each side
In the rule [HD−(cid:63)−(cid:63)], we assume that r1 can-
of the equation.
not be consumed by r2 so that we only need the auxiliary function
csm_hd(r2, r1).
The last rule [REP−(cid:63)] aims to replace all string variables by their
aliases, which are a concatenation among constant strings and star
functions.
To illustrate how these rules are applied, in Table 5, we present
running steps for solving the example in Fig. 3. Z3 core continually
sends the assignments to our Z3-str-(cid:63) (via its call back function)
from step 1 to step 5. At the same time, Z3 also maintains func-
tionally equivalent terms in their equivalence classes. From step 1
to step 4, we apply the rule [REP−(cid:63)] repetitively to replace a string
variable by a constant string, a star function or their concatenation
(shown in column 4, step 1-4). In step 5, we apply a specialized
version of rule [HT−(cid:63)], where we also make use of constraints on
variable n1 and n2. More speciﬁcally, for this running example,
we are able to force the unfolding of star(“bc”,n2) so that we can
ﬁnd a conﬂict between “bc” and “cc”. Finally, we give back the
new axiom (in column 4, step 5) to Z3 so that Z3 can conclude the
input formula is UNSAT.
5.4 String Operations
Operations
I=search(S, r)
Reduction Rules
(I<0 ∧ ¬(S ∈ (.(cid:63))·r·(.(cid:63)))) ∨ (I≥0 ∧
S=U·M1·M2·R ∧ M1·M2 ∈ r ∧ length(U)=I ∧
length(M2)=1 ∧ ¬(U·M1 ∈ (.(cid:63))·r·(.(cid:63))))
R=replaceAll(S, r, T) I=search(S, r) ∧ ((I<0 ∧ R=S) ∨
(I≥0 ∧ S=U·M·S1 ∧ R=U·T·R1 ∧ M ∈ r ∧
length(U)=I ∧ R1=replaceAll(S1, r, T)))
Table 7: Reduction Rules for search and replaceAll
Typically, the semantics of string operations such as replaceAll,
match, split, test, exec, are recursively deﬁned. As such, it is nat-
ural for us to interpret them as recursively-deﬁned functions, simi-
larly to our handling of star functions. In this Subsection, we only
Rule
[CON−(cid:63)]
star(r, n)=s
star(r, n)=s∧
(E1·star(r, n)·E2=E3)
Reduction
⇒ ¬star(r, n)=s
⇒ E1·s·E2=E3
[HT−(cid:63)]
star(r1, n1)·E1·star(r2, n2)
=s1·E2·s2
⇒
[HD−(cid:63)]
[TL−(cid:63)]
star(r, n)·E1=s·E2
E1·star(r, n)=E2·s
[HT−(cid:63)−(cid:63)]
star(r1, n1)·E1·star(r3, n3)=
star(r2, n2)·E2·star(r4, n4)
⇒
[HD−(cid:63)−(cid:63)]
star(r1, n1)·E1=
star(r2, n2)·E2
[TL−(cid:63)−(cid:63)]
E1·star(r1, n1)=
E2·star(r2, n2)
[REP−(cid:63)]
x=E∧ (E1·x·E2)
(E1=s1·E2·s2∧n1=0∧n2=0)∨
(
star(r1, n1−1)·E1=si·E2·s2∧n2=0)∨
E1·star(r2, n2−1)=s1·E2·sj∧n1=0)∨
i=1
(
k(cid:87)
l(cid:87)
k,l(cid:87)
j=1
star(r1, n1−1)·E1·star(r2, n2−1)=si·E2·sj
i,j
⇒ (E1=s·E2∧n=0)∨ k(cid:87)
⇒ (E1=E2·s∧n=0)∨ k(cid:87)
i=1
star(r, n−1)·E1=si·E2
E1·star(r, n−1)=E2·si
i=1
(n2=0∧n4=0∧star(r1, n1)·E1·star(r3, n3)=E2)∨
(n2=0∧star(r1, n1)·E1·star(r3, n3)=E2·star(r4, n4))∨
(n4=0∧star(r1, n1)·E1·star(r3, n3)=star(r2, n2)·E2)∨
i,j
star(r1, n1−1)·E1·star(r3, n3−1)=
si·star(r2, n2−1)·E2·star(r4, n4−1)·sj
(E1=E2∧n1=0∧n2=0)∨ (star(r1, n1)·E1=E2∧n2=0)∨
(E1=star(r2, n2)·E2∧n1=0)∨
star(r1, n1−1)·E1=si·star(r2, n2−1)·E2
i=1
(E1=E2∧n1=0∧n2=0)∨ (E1·star(r1, n1)=E2∧n2=0)∨
(E1=E2·star(r2, n2)∧n1=0)∨
E1·star(r1, n1−1)=E2·star(r2, n2−1)·si
k,l(cid:87)
k(cid:87)
k(cid:87)
⇒