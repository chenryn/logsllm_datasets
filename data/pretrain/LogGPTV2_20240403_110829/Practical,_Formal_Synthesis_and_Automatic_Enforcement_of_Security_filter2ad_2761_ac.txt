ﬂow path. The ICC mechanism augments both source and
destination sets. Note that to eliminate private components
from inter-app analysis, SEPAR considers the component’s
exported attribute. In fact, a component can receive Intents
from other applications, or is public, if its exported attribute
is set or contains at least one Intent ﬁlter. Such elimination of
private components from inter-app analysis also contributes
to the scalability of the approach (i.e., less components to be
analyzed).
The fact IFandComponent speciﬁes that each Intent-
Filter belongs to exactly one Component, and the fact
NoIFforProviders speciﬁes that out of four core component
types, only three of them can deﬁne IntentFilters; no Intent-
Filter can be deﬁned for Content Provider components.
An Intent belongs to one particular component sending
it, and may have one recipient component. Each Intent may
Fig. 4: Two model instances of the above Alloy speciﬁcation.
reusable constraints that are always evaluated to be either
true or false. Functions (fun) are parameterized expressions. A
function similar to a predicate can be invoked by instantiating
its parameter, but what it returns is either a true/false or a
relational value instead. An assertion (assert) is a formula
required to be proved. It can be used to check a certain
property of a model.
The Alloy language comes with a set of logical and rela-
tional operators. The dot (.) and tilde (∼) operators denote
a relational join of two relations and the transpose operation
over a binary relation, respectively. The transitive closure (ˆ)
of a relation is the smallest enclosing relation that is transitive.
The reﬂexive-transitive closure (*) of a relation is the smallest
enclosing relation that is both transitive and reﬂexive.
We will introduce additional details of the Alloy language as
necessary to present our policy synthesis approach. For further
information about Alloy, we refer the interested reader to [3].
Formal Model of Android Framework. Formal modeling
of the Android framework was the subject of earlier work [17].
To make this paper self-contained,
this subsection brieﬂy
reviews the model. Listing 3 shows (part of) the Alloy code
describing the meta-model for Android application models.
The complete version of all Alloy models that appear in this
paper are available at [10]. Our model is based on the ofﬁcial
Android documentation [34]. Android is a large and complex
operating system, and modeling it in its entirety would be
infeasible. Thus, we focused on the parts of Android that
are relevant to the inter-component communication and their
I n t e n t F i l t e r ,
IFandComponent{
i : I n t e n t F i l t e r | one i . ˜ i n t e n t F i l t e r s
a c t i o n s : some Action ,
dataType : set DataType ,
dataScheme : set DataScheme ,
c a t e g o r i e s : set Category
abstract sig Component{
app : one A p p l i c a t i o n ,
i n t e n t F i l t e r s : set
permissions : set Permission ,
paths : set DetailedPath
abstract sig I n t e n t F i l t e r{
1
2
3
4
5
6 }
7
8
9
10
11
12 }
13
14
15
16
17
18
19
20
21
22
23
24
25 }
Listing 3: Excerpts from the meta-model
application models in Alloy.
sender : one Component ,
r e c e i v e r :
a c t i o n :
c a t e g o r i e s : set Category ,
lone DataType ,
dataType :
dataScheme :
e x t r a : set Resource
fact
a l l
fact NoIFforProviders{
no i : I n t e n t F i l t e r |
abstract sig I n t e n t{
lone DataScheme ,
lone Component ,
lone Action ,
}
i . ˜ i n t e n t F i l t e r s in Provider }
for Android
519
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:14 UTC from IEEE Xplore.  Restrictions apply. 
also include an action, data (type and scheme) and a set
of categories.2 These elements are used to determine to
which component an implicit Intent—one that does not specify
any recipient component—should be delivered. Each of these
elements corresponds to a test, in which the Intent’s element
is matched against that of the IntentFilter. An IntentFilter may
have more actions, data, and categories than the Intent, but
it cannot contain less. The extra ﬁeld indicates the types of
resources carried by the Intent.
Formal Model of Apps. Listing 4 partially shows the Alloy
speciﬁcations for the apps shown in Listings 1 and 2. As
already mentioned (cf. Section IV), these app speciﬁcations
are automatically extracted by the AME component from each
Android application. Each app speciﬁcation starts by importing
the androidDeclaration module (cf. Listing 3). Among other
things, the LocationFinder component contains a sensitive
path (pathLocationFinder1),
that represents a data-ﬂow
from where the sensitive GPS data is retrieved, to an Intent
event message. The extra ﬁeld of the Intent in the generated
Alloy model (line 21) is accordingly set. The path ﬁeld of the
MessageSender in the generated Alloy model (lines 27, 30–
33) reﬂects another data-ﬂow path, started from an IntentFilter
and reaches to a node, which uses the data in the body of a
text message. Note that this component does not enforce any
access permission neither in the manifest ﬁle nor in the code
(line 28).
Formal Model of Vulnerabilities. To provide a basis for
precise analysis of app bundles against inter-app vulnerabilities
and further to automatically generate possible scenarios of
their occurrence given particular conditions of each bundle,
we designed speciﬁc Alloy signatures. Speciﬁcally, each vul-
nerability model captures a speciﬁc type of inter-component
communication security threat, according to those identiﬁed by
Chin et al. [24] and Bugiel et al. [21]. The security property
check is then formulated as a problem of ﬁnding a valid
trace that satisﬁes the vulnerability signature speciﬁcations.
If the Alloy Analyzer ﬁnds a solution to this problem, the
property is violated; the returned solution encodes an exact
scenario (states of all elements, such as components and
Intents) leading to the violation. As a concrete example, we
illustrate the semantics of one of these vulnerabilities in the
following. The others are evaluated similarly.
Listing 5 presents the GeneratedServiceLaunch signature
along with its signature fact that speciﬁes the elements in-
volved in, and the semantics of, a service launch exploit,
respectively. In short, a malicious component (malCmp) can
launch a component by sending an Intent (malIntent) to an
exported component (launchedCmp) that is not expecting In-
tents from that component. According to line 9, the launched-
Cmp component has a path from the exported interface to a
permission-required resource. It, thus, may leak information or
perform unauthorized tasks, depending on the functionalities
exposed by the victim component.
2The multiplicity keyword some in Alloy denotes that
the declared
IntentFilter.actions relation contains at
the key-
word set tells Alloy that categories map each IntentFilter object to
zero or more Category objects, and the keyword lone indicates that this
Intent.component is optional, and an Intent may have one or no declared
recipient component.
least one element;
I n t e n t
}{
sig GeneratedServiceLaunch{
launchedCmp , malCmp : one Component ,
d i s j
m a l I n t e n t :
m a l I n t e n t . sender = malCmp
launchedCmp in s e t E x p l i c i t I n t e n t [ m a l I n t e n t ]
no launchedCmp . app & malCmp . app
launchedCmp . app in device . apps
not
(malCmp . app in device . apps )
some launchedCmp . paths && launchedCmp . paths . source = ICC
some m a l I n t e n t . e x t r a
malCmp in A c t i v i t y
1
2
3
4
5
6
7
8
9
10
11
12 }
Listing
vulnerability in Android.
5: Alloy
speciﬁcations
of Service Launch
Generating possible exploit scenarios. We run the mod-
ules deﬁned above with a command that tries to satisfy the
vulnerabilities signature facts. Note that Alloy analysis must
be done within a given scope, which speciﬁes an upper bound
for, or an exact, number of instances per element signature.
In our case, the exact scope of each element, such as Appli-
cation and Activity, required to instantiate each vulnerability
is automatically derived from the speciﬁcation.
If an instance is found, SEPAR reports it along with the
information useful in ﬁnding the root cause of the violation,
from which ﬁne-grained security policies are then derived for
the given system. Given our running example, the analyzer
automatically generates the following scenario, among others:
The diagram is accurate for the result that the analyzer
computed, but we have edited it to omit some details for read-
ability. It essentially states the scenario represented in Figure 1,
in which a postulated malicious component, here the generated
App0/Service0 component, can send the device location data
captured from a vulnerable Intent, Intent1 (cf. Listing 4,
lines 14–22), to the desirable phone number via an explicit
Intent, Service0/Intent0, sent to the App2/MessageSender
component
is vulnerable to service launch. Here the
analysis has found that it is possible to devise a malicious
capability that can leverage the vulnerabilities in the apps
installed on the device for nefarious purposes. Given this,
SEPAR formulates a policy, as described next, that prevents
certain Intent-based interactions from occurring to prevent
the exploitation of vulnerabilities, thereby achieving proactive
defense if such a malicious capability were to be installed on
the device.
that
520
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:20:14 UTC from IEEE Xplore.  Restrictions apply. 
The next section describes how we can prevent occurrence
of such vulnerability exploits through generation and enforce-
ment of respective policies.
VI. APE: ANDROID POLICY ENFORCER
In the implementation of APE, we faced three possible
alternatives: (1) modify the Android OS to enforce the policies,
(2) modify an app through injection of policy enforcement
logic into the app’s implementation by instrumenting the APK
ﬁle, and (3) dynamic memory instrumentation of the app’s
process. We chose the third approach, as it allows SEPAR to
be used on an unmodiﬁed version of Android, thereby making
it widely applicable and practical for use by many.
Similar to a conventional access control model [49], our
approach is comprised of two elements: policy decision point
(PDP)—the entity which evaluates access requests against a
policy, and policy enforcement point (PEP)—the entity which
intercepts the request to a resource, makes a decision request
to the PDP, and acts on the received decision. The protected
resources in our research are mainly Android APIs that can
result in ICC calls.
Our Android policy enforcer relies on the Xposed [11]
framework for modifying the behavior of Android apps at
runtime, without making any changes in the apps’ APK ﬁles.
It provides mechanisms to “hook” method calls. A hook is
a method that
is called before or after a certain method,
making it possible to control pre/post method call activities,
by modifying a method’s parameters, its return values, or even
entirely skipping the call to the method.
The PDP is realized as an independent Android app that
stores the synthesized policies for preventing or allowing
ICC access. Our policies are in the form of event-condition-
action (ECA) rules. The PEP in our case corresponds to
an Xposed module to dynamically intercept event messages.
More speciﬁcally, each ICC method in an app’s APK ﬁle (e.g.,
startService(Intent)) is hooked, such that whenever it
is invoked, it is ﬁrst assessed to see whether the operation
should proceed (e.g., Intent to be delivered to its destination)
by calling the PDP. The major advantages of using run-
time process instrumentation over modifying individual apps
are scalability and framework generalization. Additionally,
instrumentation of APK ﬁles changes the signature of apps,
which might prevent their proper execution.
PEP hooks these operations and uses PDP to check whether
they are allowed to run or not. Whenever an application is
about to run a sensitive operation, it is checked against the
synthesized policies. The respective application is then allowed
to perform the given operation as long as it conforms to such
policies. Otherwise, the PDP prompts the user for consent
along with the information that would help the user in making
a decision, including the description of security threat as well
as the name and parameters of the intercepted event. Should
the user refuse, the application skips the given operation and
continues with running the subsequent one. As ICC mecha-
nisms in Android are essentially performed by asynchronous
API calls, inhibiting them implies that no response for the
event is ever received, without causing unexpected crashes.
Of course, preventing ICC calls would naturally force the app
to operate in a degraded mode.
Continuing with our running example, SEPAR generates the
following policy, where the conditions in the generated ECA
rule correspond to the properties of the malicious Intent in the
synthesized vulnerability model instance.
{ event
c o n d i t i o n :
:
ICC received ,
[{ I n t e n t . e x t r a : LOCATION} ,
{ I n t e n t . r e c e i v e r : MessageSender}] ,
a c t i o n : user prompt
}
It states that every attempt of sending device LOCATION
data through the MessageSender component must be manually
approved by the user. Observe that each app, such as App2
can, and in this case would, be guarded against more than one
policy at the same time. Indeed, App1 and App2 would also
be guarded with policies generated regarding Intent hijacking
and Service Launch, respectively.
VII. EVALUATION
This section presents the experimental evaluation of SEPAR.
We have implemented SEPAR’s static analysis capability on
top of the Soot [55] framework. We used Flowdroid for intra-
component taint analysis [13], and extended it to improve
precision of analysis especially to support complicated ICC
methods (cf. Section IV). The prototype implementation of
SEPAR only requires the APK ﬁles—not the original source
code—which is important, of course, for running it over non-
open source apps. The translation of captured app models
into the Alloy language is implemented using FreeMarker
template engine [6]. The core components of our analysis and
synthesis model are embedded in a relational logic language,
i.e., Alloy [3]. As a back-end analysis engine, SEPAR relies on
Aluminum [45], a recently developed principled scenario ex-