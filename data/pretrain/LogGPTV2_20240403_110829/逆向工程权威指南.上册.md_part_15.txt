70
逆向工程权威指南（上册）
了便于后期linker把这个字段与代码段一起放入ROM。
7.2.6ARM64
指令清单 7.7Non-optimizing GCC 4.9.1 ARM64
-conn
x, 4, 4 
2
.LC0:
3
-string “Enter X:*
4 ,IC1:
,string *ld*
6,IC2:
T
-string *You entered id...\n*
9 : save FP and LR in stack frame:
8 f5:
11 ; set stack 
10
stp
frame (FP=SP)
x29, x30,
[sp, -16]1
13 : load pointer to the *Enter X:" string:
12
add
x29, sp, 0
1.4
adrp
add
0x*0x
x0,.LC0
15
16
pointer
b1
to the
put8
*id* string:
1.8
adrp
add
x0, x0, :1012:.LC1
x0,
,LC1
20 ; form
19
address
of x globa1 variable:
21
22
adrp
add
×1,
×1, 
23
address of × global variable again:
b1
_i80c99_scanf
25
forn
26
adrp
add
:*0xx
x0,
27
value
from menory at this address1
29 : load pointer to the *You entered d..,\n* string:
8Z
zpT
￥1,[x0]
30
adrp
x0,,1C2
31
32
add
b1
printf
x0, x0,
:1012: .1C2
33 : retuzn 0
35 : restore FP and LR:
34
BoV
w0, 0
9C
d
37
x29,
x30, [sp], 16
在上述代码里变量x被声明为全局变量。程序通过ADRP/ADD指令对（第21行和第25行）计算它的指针。
7.2.7MIPS
无未初始值的全局变量
以变量x为全局变量为例。我们把它编译为可执行文件，然后使用IDA加载这个程序。因为程序在声明变
量x的时候没有对它进行初始化赋值，所以在IDA中变量x出现在sbssELF里（请参见3.5.1节的全局指针）。
指令清单 7.8Optimizing GCC 4.4.5（IDA)
-text:004006C0 main:
.text:004006c0 var_10
text:004006C0
= =0x10
,text:004006c0 var_4
= -4
function prologue:
,text:004006C0
. text:004006c0
text:004006C4
lu1
$gp,0x42
.text:004006C8
addiu $sp, -0x20
5gp,0x418940
---
## Page 89
第7章
scanfO)
-text:004006CC
SW
Sra, 0x20+var_4($sp)
-text: 004006D0
KS
$gp, 0x20+var_10($sp)
: cal1 puts () :
P0900+00:*x04*
La
sqnd *63$
.text: 004006DC
 text: 00400608
jalr
lui
$t9 : put8
$a0,
0x40
. text: 004006E0
La
$a0, aEnterx  *Enter X:" ; branch delay slot
 ca11 scanf () :
-text:004006E4
lui
1w
$gP.
$a0,
0x20+var_10 ($sp)
.text:004006E8
-text:004006EC
1a
$t9,
_isoc99_scanf
0x40
 prepare address of x:
-text:004006F0
1a
$a1,x
.text:004006F4
ja1r
$t9 ; 
.text:004006F8
1a
$a0, aD
 *id* : branch delay slot
 call printf():
28900#00:$x94*
1w
$gp。0x20+var_10($sp)
: get address of x:
.text:00400700
1u1
$a0, 0x40
- text:00400704
1a
$v0,x
.text:00400708
and pass it to printf () in $a1:
1a
: load value from *x*variable
-text:0040070C
.text:00400710
jalr
d 1 634
$a1,(x - 0x41099C) ($v0)
-text:00400714
1a
$a0, aYouEnteredD__ + *You entered Id.., \n" : bzanch delay slot
function epilogue:
,text:00400718
.text:0040071C
1v
$v0,Szero
Sra,
(dss)>"xea+02x0
.text:00400720
move
jr
Sra
. text:00400724
addiu
'ds$
0x20 : branch delay s1ot
sbss:0041099C
t type: Uninitialized
sbss
-sbss:0041099C
sbss:0041099C x1
-space 4
-glob1 x
,sbss:0041099C
IDA会精简部分指令信息。我们不妨通过objdump观察上述文件确切的汇编指令。
指令清单 7.9Optimizing GCC 4.4.5 （objdump)
2 : function prologue:
1 004006c0 Csain>:
4006c0:
3cle0042
lui
gp, 0x42
4006c4:
4006c8:
27bdffe0
279c8940
add1u
addiu
sp, sp, -32
5
4006cc:
afbf001c
9PgP, -30400
ra,28(sp)
4006d0 :
afbc0010
SV
9P, 16(sp)
8:
cal1 puts () :
4006d4:
0086678
1v
t9, 32716 (gp)
10
4006d8:
3c040040
Lu1
4006dc:
ja1r
a0, 0x40
11
4006e0:
0320f809
248408f0
addiu
t9
12
q 1 8822*0e*0e
delay slot
13
ca11 scanf (1:
14
4006e4:
8fbc0010
1
gp,16(sp)
15
4006e8:
3c040040
lui
4006ec:
8f998038
1v
t9, -32712 (gp)
a0, 0x40
1.6
17
18
prepare
4006f0:
address of x:
8f858044
a1, 32700 (gp)
19
4006f4:
0320f809
jalr
4006f8:
248408fc
addiu
a0,a0,2300 : branch delay s1ot
t9
20
21
call printf():
2.2
4006fc:
8fbc0010
1v
400700:
1ui
9p16(sp)
23
3c040040
a0,0x40
24;
get addres8 of x:
25
400704:
8f828044
vo,32700 (gp)
---
## Page 90
72
逆向工程权威指南（上册）
26
400708:
load value from *x*
20086618
* variable and pass it to print () in Sal:
1v
t9, 32708 (gp)
27 ;
28
40010c:
8c450000
29
400710:
0320f809
jalr
T
a1, 0 (v0)
30
400714:
24840900
addia
t9
function
ep11ogue:
40071c:
400718 :
8fbf001c
00001021
1v
ra, 28 (sp)
33
nove
v0, zero
34
400720:
03e00008
jr
SE
400724:
27bd0020
addiα
8p,sp, 32  branch delay s1ot
ra
36 ;
pack of NOPs
used for
aligning next functlon start on 16-byte boundary:
37
38
40072c:
400728 :
00200825
00200825
nove
nove
at, at
at., at
第18行处的指令对全局指针GP和一个负数值的偏移量求和，以此计算变量x在64KB数据缓冲区里
的访间地址。此外，
三个外部函数（putsO、scanfO、printfO）在64KB数据空间里的全局地址，也是借助
GP计算出来的（第9行、第16行、第26行）。GP指向数据空间的正中央。经计算可知，三个函数的地
址和变量x的地址都在数据缓冲区的前端。这并不意外，因为这个程序已经很短小了。
此外，值得一提的是函数结尾处的两条NOP指令。它的实际指令是空操作指令“MOVESAT，SAT”。
借助这两条NOP指令，后续函数的起始地址可向16字节边界对齐。
有初始值的全局变量
我们对前文的例子做相应修改，把有关行改为：
int x=10; // default value
则可得如下代码段。
指令清单7.10OptimizingGCC 4.4.5（IDA)
.text:004006A0 nain:
-text:004006A0
-text:004006A0
var_10
= -0x10
.text: 004006A0
var_B
text: 004006A0
var_4
= -4
8- ×
-text: 004006A0
text: 004006A0
lui
gp，0x42
- text:004006A8
.text: 004006A4
add1u
sp,
-0x20
1i
.text: 004006AC
SW
$s0,0x20+var_8（$sp）
$ra,
0x20+var_4 ($ap)
.text: 004006B0
- text:00400684
8W
.text: 004006B8
1a
RS
$t9,puts
$gp,
0x20+var_10 ($sp)
text: 004006BC
1u1
$a0,0x40
.text: 004006C0
jalr
$t9 : puts
.text: 004006C4
1a
$a0,
aEnterX
 *Enter X:"
-text:004006C8
: prepare high part of x address:
1×
$gp,
0x20+var_10 ($sp)
.text: 004006cc
1ui
$s0, 0x41
text: 00400600
1a
text: 00400604
$a0,0x40
$t9,
_1soc99_scanf
J add lov part
 of x address:
1ui
.text: 00400608
add1u
$a1, $s0,
: now address of x is in Sal.
(x - 0x410000)
.text: 004006DC
ja1r
$t91_isoc99_scanf
.text:00400684
.text: 004006E0
La
$gp, 0x20+var_10($sp)
$α0, aD
1 *id*
1v
J get a ord from 
,text:00400688
menory:
Jvalue of x is nou in fal.
T
$a1, x
.text: 004006Ec
.text:004006F0