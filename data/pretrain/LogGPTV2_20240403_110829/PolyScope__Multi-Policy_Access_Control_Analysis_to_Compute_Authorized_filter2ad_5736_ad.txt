it has difﬁculty obtaining ﬁles located in some directories like
/data. As shown in Table 1 of their paper [22], about 75%
of the ﬁles’ DAC conﬁguration in /data cannot be retrieved,
which we extract with our scripts.
USENIX Association
30th USENIX Security Symposium    2587
TE IV Computation: To compute per-subject adversaries in
Step 1 of Figure 2, PolyScope leverages the integrity wall [50]
and Android privilege levels [17], as described in Section 5.2.
We follow the procedure deﬁned in the integrity wall paper for
Linux [50], except we add objects upon which Android kernel
integrity depends (e.g., rootfs and selinuxfs) to the set of
kernel objects. Since the SEAndroid TE policy is immutable
(i.e., modulo system upgrades), Step 2 of Figure 2 is not re-
quired. In Step 3, PolyScope computes the integrity violations
authorized by the TE policy, as speciﬁed in Section 5.4.
TE IV Validation: After the TE IVs are identiﬁed, PolyScope
validates whether these TE IVs are also authorized for the
combination of remaining Android access control policies:
Unix DAC, SEAndroid MLS, and Android permissions. Step
1 of Figure 2 is not rerun. In Step 2, PolyScope converts An-
droid permissions to authorized DAC subgroups for adversary
expansion and identiﬁes the objects owned by each subject
for victim expansion, as described in Section 5.3. In Step 3,
PolyScope determines whether the SEAndroid MLS and DAC
policies also authorize the victim and adversary of each IVs.
As mentioned above, the set of TE IVs can be partitioned to
validate them in parallel.
Compute Attack Operations: PolyScope then computes the
attack operations for the IVs using the ﬁlesystem and pro-
gram conﬁgurations as described in Section 5.5. PolyScope
collects the relevant ﬁlesystem conﬁgurations by parsing the
associated mount options. PolyScope collects the relevant
program conﬁgurations (i.e., whether the victim includes a
recommended defense, the FileProvider class) by reverse en-
gineering the application’s apk package to detect the presence
of the FileProvider class. We validated the ability or inability
to perform attack operations and found no discrepancies.
Testing for Vulnerabilities: The ultimate goal is to deter-
mine whether the victim is vulnerable to any of the attack
operations. However, a key challenge is to determine whether
and when a victim may actually access a resource associated
with an attack operation. Just because a potential victim may
be authorized to use a resource, does not mean it ever uses
that resource. Even if a potential victim may use a resource
associated with an attack operation, we need to determine the
conditions when such an access is performed. Thus, detecting
vulnerabilities often requires runtime testing.
The major challenge is to drive the victim subjects’ pro-
grams to cause all ﬁle usage operations, akin to fuzz testing.
Developing a fuzz testing approach for ﬁle operations is out-
side the scope of this paper, so we simply drive programs with
available tools: (1) Android Exerciser Monkey; (2) Compati-
bility Testing Suite (CTS); and (3) Chizpurﬂe [23]. We use
the Android Exerciser Monkey and CTS to emulate normal
phone usage, and Chizpurﬂe to drive Android system services.
With this approach, we are able to ﬁnd the vulnerabilities de-
scribed in Section 7.6. We discuss how to employ runtime
systematically in the future in Section 8.1.
7 Evaluation
Table 2 summarizes the highlights of our evaluation for nine
fresh installs of Android releases, demonstrating the impor-
tance of computing per-victim adversaries, permission expan-
sion, and attack operations. Table 2 shows the relative effort
to vet Android releases for vulnerabilities using the output of
prior analyses [22, 10] (Authorized Data Flows), output of
a past analyses [25, 50] using PolyScope’s method for com-
puting adversaries (IVs for PolyScope Adversaries), and two
new analyses performed by PolyScope (PolyScope IVs after
Expansion and PolyScope IVs with Operations) that provide a
more accurate accounting of the threats victims may face. The
counts are shown in terms of subject-object pairs, as subjects
and objects are deﬁned in Section 5.1. For data ﬂows, we sum
of the objects that each subject is authorized to use (i.e., in a
read-like operation, see Section 2.2). For integrity violations
(IVs), we only count the data ﬂows to objects that another
subject classiﬁed as an adversary is authorized to modify (i.e.,
in a write-like operation, see Section 2.2).
The ﬁrst row of Table 2 lists the number of authorized data
ﬂows allowed by Android access control policies, showing
that analyses that only compute data ﬂows [22, 10] leave
OEMs with hundreds of thousands of cases to assess to detect
vulnerabilities. The second row in Table 2 shows that the
number of data ﬂows to consider can be reduced signiﬁcantly
by only considering those that cause integrity violations. The
way PolyScope computes adversaries per-victim (see Sec-
tion 5.2) for ﬁnding the IVs for PolyScope Adversaries results
in a reduction of the number of data ﬂows involved in integrity
violations by at least two orders of magnitude.
Additionally, PolyScope provides two new analysis steps to
detect threats more accurately. First, the third row of Table 2
shows the number of PolyScope IVs after expansion, which
shows the counts for IVs found using the rules deﬁned in
Section 5.4. In several cases, the number of integrity viola-
tions increases signiﬁcantly after accounting for expansion, in
some cases by more than 10x. Second, the fourth row of Ta-
ble 2 shows that the number of PolyScope IVs with operations
based on the rules in Section 5.5 may be signiﬁcantly reduced
(14-21% across these releases) because no attack operation
may be possible for some IVs given the ﬁlesystem and/or
victim subjects’ program conﬁgurations. We also consider the
impact of the Android scoped storage defense [19] applied to
Android 11 on PolyScope. Table 2 shows that number of IVs
increases greatly between Android 10 and 11. As discussed
in Section 8.2, we ﬁnd that the traditional access controls
were weakened when the new defense was added 7. The total
number of attack operations possible is shown in the ﬁfth row,
indicating the effort to test each release for vulnerabilities in
terms of the types of operations that must be tested.
In Sections 7.1 to 7.4, we examine how the PolyScope
7Android scoped storage was introduced as an option in Android 10 and
made mandatory in Android 11.
2588    30th USENIX Security Symposium
USENIX Association
Authorized Data Flows1
IVs for PolyScope Adversaries2
PolyScope IVs after Expansion3
PolyScope IVs with Operations4
Nexus 5x 7.0
Nexus 5x 8.0
204,241
166,027
167
372
297
350
80
478
387
417
Table 2: Summary of Impact of PolyScope Analyses
Google Devices
Pixel3a 9.0
Pixel3a 10.0
Pixel3a 11.0 Mate9 8.0 Mate9 9.0 Mix2 9.0 Galaxy S8 9.0
OEM Devices
156,315
69
1,139
927
962
161,689
71
1,059
898 6
997
169,884
264
2,127
1,7647
1,9997
240,916
860,508
289,238
259,992
223
1,682
1,331
2,160
166
1,566
1,327
1,777
192
2,304
1,979
2,137
628
4,377
3,736
5,063
Total Attack Operations5
Unit is the relation {Subject, Object}, where subjects and objects are deﬁned in Section 5.1
1 Objects authorized for use by Subjects
2 Authorized Data Flows where Object is modiﬁable by at least one PolyScope per-victim adversary, see Section 5.2
3 PolyScope Integrity Violations (sum for all types) as deﬁned in Section 5.4
4 PolyScope Integrity Violations in at least one Attack Operation, see Section 5.5
5 Sum of Attack Operations (in Table 4)
6 Assumes opting out of Android scoped storage, see Section 8.2
7 Does not account for cases blocked by Android scoped storage, see Section 8.2
implementation (see Section 6) impacts the analysts’ efforts to
vet their releases for vulnerabilities. In Section 7.5, we assess
the distribution of IVs across privilege levels. In Section 7.6,
we describe how we found two types of previously unknown
vulnerabilities using PolyScope output. Finally, we measure
PolyScope’s analysis performance in Section 7.7.
7.1 TE IV Computation
RQ1: How many integrity violations are found when using
the SEAndroid MAC TE policy alone in TE IV Computation?
PolyScope’s implementation computes IVs initially using
only the SEAndroid MAC TE policy. Android has relied
heavily on MAC TE to protect important daemons and system
services since its introduction in Android 5.0, as shown by
the number of MAC TE allow rules8 in Table 3. Due to its
immutable nature, the MAC TE policy provides a foundation
for Android access control that other policies can modify.
The three TE rows (rows 2-4) of Table 3 show the num-
ber of binding-IVs, write-IVs, and read-IVs for the MAC TE
policy using the rules in Section 5.4. We note that in count-
ing the TE IVs, we only use the MAC TE labels to identify
subjects and objects, which results in coarser-grained sub-
jects and objects than Section 5.1. Thus, the TE IV counts
presented represent a lower bound. We found this sufﬁcient
for the qualitative comparison with IV counts after TE IV
validation below. The pathname-IV count is not shown as it is
the same as the binding-IV count, as the TE policy produces
no additional pathname-IVs because permission expansion is
not allowed for the MAC TE policy.
7.2 TE IV Validation
RQ2: How are the number of integrity violations (IVs) re-
duced after TE IV Validation from those found in the TE IV
Computation? The next four rows (rows 5-8) in Table 3 show
the number of IVs for the four IV types in Section 5.4 after
considering TE IV Validation (Valid) using other Android
8The drastic increase of MAC allow rules from Android 7 to 9 can be
largely attributed to the effect of Google’s Project Treble [18] in Android 8,
which introduced many new MAC domains due to the decomposition of the
Hardware Abstraction Layer (HAL). TE rules leading to the use of scoped
storage (see Section 8.2).
access control policies9. We see that the number of TE IVs
(rows 2-4) is much greater than the number of valid IVs (rows
5-8), even accounting for the coarser subjects and objects
applied in the TE IV counts10.
Recall in Table 2 that the total IV counts after permission
expansion are much higher across every release, showing that
more testing to detect vulnerabilities is required than just
testing IVs from the current policy. However, we observed
that the SEAndroid MLS policy does effectively prevent sev-
eral opportunities for victim permission expansion for ob-
jects in application-private directories (e.g., /data/data). If
MLS can be effectively applied to Android ﬁlesystems more
broadly that may greatly reduce the opportunities for victim
permission expansion.
7.3
RQ3: How do OEM customizations impact the Android in-
tegrity violation counts across vendors? To make their prod-
ucts more attractive, OEMs customize Android images to
provide vendor-speciﬁc, value-added functionality and more
attractive user interfaces. We are interested to see how OEM
customization affects the number of integrity violations cre-
ated when the OEMs have to customize their Android access
control policies. The devices of choice are as follows: Huawei
Mate9 on Android O and Android P, Xiaomi Mix2 on An-
droid O and Android P, and Samsung Galaxy S8 on Android
P. The results are shown in the right half of Table 3.
IVs for OEM Customizations
We can see heavy customization of the MAC policy. Every
OEM has a signiﬁcantly greater number of MAC allow rules
than the Google MAC policies in the left half of Table 3.
This suggests OEMs have introduced many new domains for
their own services and apps, and granted them a wide variety
9Note that the total IV count shown in Table 2 for PolyScope IVs after
Expansion row is equal to the sum of Valid Read-IVs and Valid Pathname-IVs
rows in Table 3. The Write-IVs are a subset of the Read-IVs (i.e., all victims
have read access to IVs when they have write access) and the Binding-IVs
are a subset of the Pathname-IVs (i.e., victims can still access binding-IVs
through luring).
10In addition, 25% of TE IVs cannot be validated because the MAC-to-
DAC mapping for some subjects is not known, see Section 8.1. Although
this is a large number of TE IVs, the combination of policies still reduces the
Valid IV counts much more signiﬁcantly.
USENIX Association
30th USENIX Security Symposium    2589
Nexus 5x 7.0
Nexus 5x 8.0
64,830
133,545
Table 3: Integrity Violations across Vendor Releases
Google Devices
OEM Devices
Pixel3a 9.0
Pixel3a 10.0
Pixel3a 11.0 Mate9 8.0 Mate9 9.0 Mix2 8.01 Mix2 9.0 Galaxy S8 9.0
411
2,373
438
19
80
22
398
478
191,556
1,130
4,296
693
56
85
32
1,054
1,139
38,845
1,513
3,940
705
63
87
37
972
1,059
43,902
1,342
3,369
513
913
1,014
190
1,113
2,127
250,220
2,067