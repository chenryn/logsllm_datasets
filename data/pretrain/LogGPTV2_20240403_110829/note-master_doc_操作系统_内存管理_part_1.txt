---
tags: ['操作系统']
---
# 内存管理
**分层存储器体系**
**存储管理器**：操作系中管理分层存储器体系的部分，用来记录哪些内存正在使用，哪些内存空闲
## 无存储器抽象
IBM 360系统的不用交换运行多个程序，其通过对地址进行一个静态映射，来达到一个逻辑地址与物理地址的分离
![只有一个进程下的内存组织方案](/assets/2022425214727.png)
## 存储器抽象：地址空间
将物理地址直接暴露给进程，除非硬件能给予特殊的保护，否则进程可以任意对整个内存进行读写操作，不论有意无意，这是很危险的。另外一个问题就是这种抽象很难实现多道程序设计。
### 概念
所谓地址空间，就是一系列地址集合（内存地址0...内存地址n），而独立的地址空间则代表每个进程都有属于自己的地址空间，类似于编程语言中的命名空间，不同的命名空间下，可以有同名的标志符
运行多个程序互相不影响，需要解决两问题：
- 保护不属于该进程的内存
- 重定位
内存重定位可以通过两个寄存器来实现：
- **基址寄存器** 
- **界限寄存器**
相当于划定一个物理内存范围，进程的内存就分配在此区域之内，并且操作系统对内存地址做一次重定位
### 交换技术
> 把一个进程从磁盘完整调入内存，使该进程运行一段时间，再将其的内存写回磁盘
**内存紧缩**：将小空闲区合并成一大块
当频繁进行内存交换，内存就会之间就会出现空洞，就需要使用内存紧缩，确保能有较大的一片连续内存区域给后续内存分配
### 空闲内存管理
操作系统需要管理分配的动态内存
#### 使用位图的存储管理
![202242523157](/assets/202242523157.png)
通过一个bitmap的槽为0还是为1，代表某一块内存是否为空闲
当每一块内存单元越小，所需要的位图就需要越大，分配一整块大小为n连续的内存时，就需要搜索到连续出现了n个0的内存块
#### 使用链表
通过将不连续的内存块用链表连接起来
使用链表的内存分配算法：
- 首次适配算法：找到一个比所需内存大或者刚好等于的内存块，将其分配给进程，余下的内存加会到链表
- 下次适配算法：首次适配每次都从头找，而下次适配则从上次找到的地方开始找
- 最佳适配算法：找出最接近所需的内存的一个内存块，需要搜索整个链表
- 最差适配算法：每次都选择最大的一块空间
- 快速适配算法：维护常用大小的内存空间，4k 16k 之类的，这样就能快速分配
## 虚拟内存
> 地址空间被分为多块，每块称作**页** 页被映射到物理内存，如果程序引用不存在的物理内存 由操作系统负责将缺失的部分装入物理内存
### 分页
当虚拟地址空间是比物理地址空间大时，当程序请求一个不存在物理地址的虚拟地址时，MMU通过**缺页中断**：当访问的页没有映射到物理内存中时，操作系统会将其他的页写到磁盘，将空出来的内存映射给当前的页，**内存管理单元（MMU）** 则是执行这个映射的服务
![MMU将虚拟地址转为物理地址](/assets/202032184635.png)
### 页表
页表项的结构：
- 保护位：允许什么类型的访问（读、写、执行）
- 修改位：判断页面是否被写过
- 访问位：判断页面是否被访问过
- 高速缓存禁止位
### 加速分页过程
分页系统需要考虑的2个问题：
- 虚拟地址映射到物理地址必须非常快
- 如果虚拟地址空间很大，则页表也会很大
#### TLB
**转换检测缓冲区（TLB）**：小型硬件设备，本质就是个缓存，其可以通过并行的方式对虚拟地址进行查找，如果在缓冲区中命中，就直接返回，否则再去查找页表，是一种多级缓存架构
缓存存放了之前已经进行过地址转换的查询结果。这样，当同样的虚拟地址需要进行地址转换的时候，我们可以直接在 TLB 里面查询结果，而不需要多次访问内存来完成一次转换
![和 TLB 的访问和交互，由 MMU 控制](/assets/202275212618.webp)
#### 软件TLB管理
- 软失效：页表不在TLB里，但在内存中，需要少量的代价更新TLB
- 硬失效：页表也不在内存里，需要读取磁盘
### 针对大内存的页表
#### 多级页表
进行两次查找
![多级页表](/assets/202242621365.png)
多级页表由于二级三级项在没被使用的时候可以不创建，且二级三级项甚至可以不存在内存中，所以可以减少内存的使用
#### 倒排页表
需要使用TLB作为前置缓存，当TLB搜索不到，需要查找整个页表来找到所需的页表
为了避免对整个页表的搜索，可以使用对虚拟地址进行散列，使用散列值使用常数时间复杂度找到需要的页表
![倒排页表](/assets/2022426214059.png)
## 页面置换算法
**主要目的**：挑选出最不常使用的页面，本质就是缓存的淘汰
算法             | 注释
-------------- | ------------
最优算法           | 不可实现，但可用作基准
NRU (最近未使用)算法  | LRU的很粗糙的近似
FIFO (先进先出)算法  | 可能抛弃重要页面
第二次机会算法        | 比FIFO有较大的改善
时钟算法           | 现实的
LRU (最近最少使用)算法 | 很优秀，但很难实现
NFU (最不经常使用)算法 | LRU的相对粗略的近似
老化算法           | 非常近似LRU的有效算法
工作集算法          | 实现起来开销很大
工作集时钟算法        | 好的有效算法
### 最优页面置换算法（OPT, Optimal replacement algorithm）
_无法确定哪个页面未来最少被使用_ ，该算法只是一种理论算法，无法实现
### 最近未使用(NRU)页面置换算法
随机淘汰最近一个时钟周期没有访问、没有修改的最老的页面
### 先进先出页面置换算法（FIFO, First In First Out）
选择换出的页面是最老的页面
### 第二次机会页面置换算法
淘汰掉一个进入时间最长，且最久未被使用的页面