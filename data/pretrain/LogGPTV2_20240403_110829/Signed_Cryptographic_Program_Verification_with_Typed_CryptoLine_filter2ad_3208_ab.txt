umull Var Var Atom Atom |
|
uspl Var Var Atom Num
|
sspl Var Var Atom Num
::= Decl∗ Inst∗
Prog
uadcs Var Var Atom Atom Atom
sadcs Var Var Atom Atom Atom
usbbs Var Var Atom Atom Atom
ssbbs Var Var Atom Atom Atom
smull Var Var Atom Atom
ucshl Var Var Atom Atom Num
scshl Var Var Atom Atom Num
Figure 2: CryptoLine Syntax
Γ, v : τ ⊢ v : τ
Γ ⊢ E1 : τ
Γ ⊢ E0 : τ
Γ ⊢ E0 × E1 : τ
Γ ⊢ P0
Γ ⊢ P1
Γ ⊢ P0 ∧ P1
Γ ⊢ a1 : ρ
Γ ⊢ a0 : ρ
Γ, v : ρ ⊢ uadd v a0 a1
Γ ⊢ a0 : σ
Γ ⊢ a1 : σ
Γ, v : σ ⊢ sadd v a0 a1
Γ ⊢ a1 : ρ
Γ ⊢ a0 : ρ
Γ, v : ρ ⊢ usub v a0 a1
Γ ⊢ a0 : σ
Γ ⊢ a1 : σ
Γ, v : σ ⊢ ssub v a0 a1
Γ ⊢ a0 : ρ
Γ ⊢ a1 : ρ
Γ, v : ρ ⊢ umul v a0 a1
Γ, v : ρ ⊢ ushl v a n
Γ ⊢ aL : ρ
Γ ⊢ aH : ρ
Γ, v : 2 • ρ ⊢ ujoin v aH aL
Γ ⊢ P
Γ ⊢ Q
Γ ⊢ assert P ∧∧ Q
Γ ⊢ a : ρ
Γ ⊢ c@τ : τ
Γ ⊢ E0 : τ
Γ ⊢ E1 : τ
Γ ⊢ E0 = E1
Γ ⊢ a : τ
Γ, v : τ ⊢ mov v a
Γ ⊢ a1 : ρ
Γ ⊢ a1 : σ
Γ ⊢ a1 : ρ
Γ ⊢ a1 : σ
Γ ⊢ a0 : ρ
Γ ⊢ a0 : σ
Γ ⊢ a0 : ρ
Γ ⊢ a0 : σ
Γ, c : bit, v : ρ ⊢ uadds c v a0 a1
Γ, c : bit, v : σ ⊢ sadds c v a0 a1
Γ, c : bit, v : ρ ⊢ usubs c v a0 a1
Γ, c : bit, v : σ ⊢ ssubs c v a0 a1
Γ ⊢ a0 : σ
Γ ⊢ a1 : σ
Γ, v : σ ⊢ smul v a0 a1
Γ ⊢ a : σ
Γ, v : σ ⊢ sshl v a n
Γ ⊢ aH : σ
σ∥ρ
Γ, v : 2 • σ ⊢ sjoin v aH aL
Γ ⊢ aL : ρ
Γ ⊢ P
Γ ⊢ Q
Γ ⊢ assume P ∧∧ Q
Γ ⊢ aH : ρ
Γ, vH : ρ, vL : ρ ⊢ ucshl vH vL aH aL n
Γ, vH : ρ, vL : ρ ⊢ uspl vH vL a n
Γ ⊢ aL : ρ
Γ ⊢ a : ρ
Γ ⊢
Γ ⊢ E0 : τ
Γ ⊢ E1 : τ
Γ ⊢ E0 + E1 : τ
Γ ⊢ E2 : τ
Γ ⊢ a1 : τ
Γ ⊢ d : bit
Γ ⊢ d : bit
Γ ⊢ d : bit
Γ ⊢ d : bit
Γ ⊢ E0 : τ
Γ ⊢ c : bit
Γ ⊢ a0 : ρ
Γ ⊢ a0 : σ
Γ ⊢ a0 : ρ
Γ ⊢ a0 : σ
Γ ⊢ a0 : ρ
Γ ⊢ E0 ≡ E1 mod E2
Γ, v : τ ⊢ cmov v c a0 a1
Γ, v : ρ ⊢ uadc v a0 a1 d
Γ, v : σ ⊢ sadc v a0 a1 d
Γ, v : ρ ⊢ usbb v a0 a1 d
Γ, v : σ ⊢ ssbb v a0 a1 d
Γ, vH : ρ, vL : ρ ⊢ umull vH vL a0 a1
Γ ⊢ E1 : τ
Γ ⊢ a0 : τ
Γ ⊢ a1 : ρ
Γ ⊢ a1 : σ
Γ ⊢ a1 : ρ
Γ ⊢ a1 : σ
Γ ⊢ a1 : ρ
Γ ⊢ E1 : τ
Γ ⊢ E1 : τ
Γ ⊢ E0 : τ
Γ ⊢ E0 : τ
Γ, v : τ ⊢ cast v@τ a
Γ ⊢ E0 − E1 : τ
Γ ⊢ E0 < E1
Γ ⊢ a : τ ′
Γ ⊢ a1 : ρ
Γ ⊢ a1 : σ
Γ ⊢ a1 : ρ
Γ ⊢ a1 : σ
Γ ⊢ a1 : σ
Γ ⊢ aL : ρ
Γ ⊢ a0 : ρ
Γ ⊢ d : bit
Γ, c : bit, v : ρ ⊢ uadcs c v a0 a1 d
Γ ⊢ a0 : σ
Γ ⊢ d : bit
Γ, c : bit, v : σ ⊢ sadcs c v a0 a1 d
Γ ⊢ a0 : ρ
Γ ⊢ d : bit
Γ, c : bit, v : ρ ⊢ usbbs c v a0 a1 d
Γ ⊢ a0 : σ
Γ ⊢ d : bit
Γ, c : bit, v : σ ⊢ ssbbs c v a0 a1 d
Γ ⊢ a0 : σ
σ∥ρ
Γ, vH : σ , vL : ρ ⊢ smull vH vL a0 a1
Γ ⊢ aH : σ
Γ, vH : σ , vL : ρ ⊢ scshl vH vL aH aL n
Γ, vH : σ , vL : ρ ⊢ sspl vH vL a n
Γ ⊢ a : σ
σ∥ρ
σ∥ρ
Γ ⊢ inst
Γ ⊢ insts
Γ ⊢ inst insts
Figure 3: CryptoLine Type System
bit. uadcs c v a0 a1 d moreover requires the carry c to be of the type
bit. Signed addition instructions sadd, sadds, sadc, sadcs similarly
require sources and destinations are of the same signed type and
carries of the type bit. There is no surprise for subtraction instruc-
tions. Unsigned subtraction instructions usub, usubs, usbb, usbbs
are typable when sources and destinations have the same unsigned
type with additional borrow or borrowing bits if needed. Signed
subtraction instructions must have signed sources and destinations
instead. Unsigned half-multiplication umul v a0 a1 requires v, a0,
and a1 to have the same unsigned type. Signed half-multiplication
smul is typable if sources and destinations are of the same signed
type. The left-shift instructions ushl v a n and sshl v a n are as
expected. The destination v is required to have the same type as a.
Full multiplication however is slightly surprising. The unsigned
full-multiplication umull vH vL a0 a1 is typable if vH , vL, a0, a1
have the same unsigned type. Suppose a0 and a1 are of the type
uint w. Their product then needs bit length 2w. The w least signifi-
cant bits are put in vL and the remaining bits are stored in vH . Thus
both vH and vL are of the same unsigned type uint w. Now consider
the signed full-multiplication smull vH vL a0 a1. Suppose a0 and
a1 are of the signed type sint w. Their signed product therefore
has bit length 2w (2w − 1 bits for magnitude and 1 bit for sign).
The w least significant bits are unsigned and assigned to vL. The
Session 7D: Formal Analysis IIICCS ’19, November 11–15, 2019, London, United Kingdom1594w most significant bits are signed and stored in vH of the type
sint w. Using different interpretations for vH and vL maintains the
equation vH × 2w + vL = a0 × a1 (see Section 3.3 for details).
For the source a of the type uint w, the uspl vH vL a n instruction
splits the bit string for a. The w − n most significant bits are stored
in vH and the remaining n bits are in vL. Both vH and vL are
required to have the type uint w. To split a source a of the type
sint w, sspl vH vL a n is used. Similar to signed full-multiplication,
the w − n most significant bits are signed and put in vH ; the n least
significant bits are unsigned and stored in vL. Subsequently, vH
and vL must be of the types sint w and uint w respectively. For
sources aH and aL of the type uint w, ujoin v aH aL concatenates
the bit strings of aH and aL and requires v to have the type uint 2w.
Similarly, v must have the type sint 2w in sjoin v aH aL where aH
and aL are of the types sint w and uint w respectively.
Concatenation followed by left-shift instructions combine left-
shift and split instructions. The unsigned ucshl vH vL aH aL n
takes aH and aL of the type uint w and requires the destinations
vH and vL to have the same type. On the other hand, the signed
scshl vH vL aH aL n requires aH and aL to have the compatible
types sint w and uint w respectively. The destinations vH and vL
should also be of the types sint w and uint w respectively.
Finally, assert P ∧∧ Q and assume P ∧∧ Q require the algebraic
predicate P and range predicate Q to be typable in the given context.
A sequence of instructions is typable if each instruction is typable.
From Figure 3, it is not hard to see that types of destinations
are determined by instructions. It is subsequently not necessary
to declare types for all variables in a CryptoLine program. Types
of variables containing intermediate computation results can be
inferred automatically. Figure 4 gives a type inference algorithm
for CryptoLine type system.
Given a type context, each type inference rule updates the type
context with variable typing relations for destinations. For instance,
the [Cast] rule requires a to have the type τ ′ in the type context
Γ (Γ ⊢ a : τ ′). If so, the instruction cast v@τ a updates the type
context and obtains a new type context Γ ⊎ {v : τ}. Compared to
the corresponding rule in CryptoLine type system (Figure 3), the
inference rule does not require the destination v to be typable in
Γ. Rather, it updates Γ with the variable typing relation for v and
hence implicitly declares the type of v to be τ (Γ ⊢ cast v@τ a ⇒
Γ ⊎ {v : τ}). All type rules can be reformulated as inference rules
straightforwardly. We illustrate the basic ideas in selected examples.
In uadcs c v a0 a1 d, the sources a0, a1 need to have an unsigned
type ρ and d the type bit in the current type context. If so, the type
context is updated with the variable typing relations c : bit and
v : ρ. Thus c and v effectively have the respective types bit and ρ
afterwards. Similarly, smull vH vL a0 a1 requires a0, a1 to have a
signed type σ. After the instruction, the type context is updated
with the variable typing relations vH : σ and vL : ρ where types σ
and ρ are compatible. If aH : σ and aL : ρ with compatible types σ
and ρ are typable in the current type context, scshl vH vL aH aL n
adds vH : σ and vL : ρ to the type context. Finally, ujoin v aH aL
declares v to have the type 2 • ρ if aH and aL are of the type ρ.
Starting from the first instruction, the [Inst] rule updates the
given type context and uses the updated type context for the re-
maining instructions. With the type inference rules in Figure 4, it
suffices to declare types of uninitialized variables in the initial type
context. The type inference rules will annotate all variables used in
a CryptoLine program automatically without user intervention.
The type inference rules hence greatly improve the usability.
Our implementation goes even further. In Figure 3 and 4, it is
easily seen that types of sources determine the variant of instruc-
tions. Intended variants of CryptoLine instructions can hence be
decided automatically. Consider, for instance, a generic addition
instruction with two unsigned sources. The addition instruction
is easily seen to be unsigned because the signed addition requires
two signed sources. Subsequently, it suffices to write add v a0 a1.
CryptoLine type inference will determine whether the unsigned
uadd v a0 a1 or signed sadd v a0 a1 is needed. Users simply write
generic mnemonics for each instruction (say, add). CryptoLine
will choose the intended variant (uadd or sadd) automatically.
Allowing generic mnemonics in CryptoLine is more than for
users’ conveniences. When verifying cryptographic assembly pro-
grams, it is crucial to distinguish unsigned from signed interpre-
tations. Yet not all assembly instructions indicate variants of op-
erations clearly. The x86 add instruction, for example, is used for
both variants of addition. For such instructions, it is unclear which
variants of instructions are intended by programmers. CryptoLine
users of course could guess programmers’ intention and annotate
instructions accordingly, but they might also misinterpret program-
mers’ intention and verify incorrectly annotated programs. Generic
mnemonics in CryptoLine relieve tedious and possibly harmful an-
notations during verification. Users can greatly benefit from these
simple yet useful features in the CryptoLine type system.
3.3 Semantics
CryptoLine is designed to model cryptographic assembly pro-
grams. In order to model overflow, underflow, and even CPU flags
in such programs, we give a bit-accurate semantics for Crypto-
Line. Following the standard operational semantics of imperative
languages [12, 15], a program state is formalized by an environ-
ment. Formally, an environment ϵ is a mapping from variables to bit
strings. Note that variables are mapped to bit strings, not values.
Using bit strings can be tedious sometimes. A bit string may
denote different values in different interpretations. Conversely, a
value can be represented by different bit strings under different
interpretations. For instance, (1111)2 denotes 15 in uint 4 but −1 in
sint 4; −1 can be represented by (1111)2 in sint 4 or (11111111)2 in
sint 8. It is essential to specify interpretations before representing
values in the semantics. Particularly, it is ambiguous to update the
variable v in an environment ϵ with the value −1 since both (1111)2
and (11111111)2 represent −1 in sint 4 and sint 8 respectively. One
has to specify the type of v so as to update its bit string correctly.
The CryptoLine type system luckily provides the needed typing
information. Let ϵ be an environment, v a variable, and V a value.
We write ϵ[v (cid:55)→ V] for the environment obtained by updating the
bit string for v in ϵ with the bit string representing V (interpreted)
in the type of v. Thus ϵ[v (cid:55)→ −1](v) = (1111)2 when v : sint 4 but
ϵ[v (cid:55)→ −1](v) = (11111111)2 when v : sint 8.
Figure 5 gives the semantics for CryptoLine arithmetic instruc-
tions. Recall an atom a is either a variable v or a constant c@τ with
a type τ. When a : τ, [[a]]τ
ϵ denotes the value of a in ϵ interpreted
in the type τ. The mov v a instruction simply updates the bit string
Session 7D: Formal Analysis IIICCS ’19, November 11–15, 2019, London, United Kingdom1595Γ, v : τ ⊢ v : τ
Var
Mov
Γ ⊢ a : τ
Γ ⊢ mov v a ⇒ Γ ⊎ {v : τ}
Γ ⊢ a0 : σ
Γ ⊢ a1 : σ
Γ ⊢ sadd v a0 a1 ⇒ Γ ⊎ {v : σ}
Γ ⊢ a0 : ρ
SAdd
Γ ⊢ a1 : ρ
Γ ⊢ uadds c v a0 a1 ⇒ Γ ⊎ {c : bit, v : ρ}
Γ ⊢ a0 : ρ
Γ ⊢ uadcs c v a0 a1 d ⇒ Γ ⊎ {c : bit, v : ρ}
Γ ⊢ d : bit
Γ ⊢ a1 : ρ
Γ ⊢ a0 : ρ
Γ ⊢ a1 : ρ
USub
Γ ⊢ usub v a0 a1 ⇒ Γ ⊎ {v : ρ}
Γ ⊢ a0 : ρ
Γ ⊢ d : bit SSbb
Γ ⊢ a1 : ρ
Γ ⊢ a0 : σ
Γ ⊢ ssbb v a0 a1 d ⇒ Γ ⊎ {v : σ}
Γ ⊢ a1 : σ
Γ ⊢ a0 : ρ
Γ ⊢ a1 : ρ
Γ ⊢ d : bit
Γ ⊢ a : τ ′
Γ ⊢ c@τ : τ
Const
Γ ⊢ a0 : τ
Γ ⊢ c : bit
Γ ⊢ cmov v c a0 a1 ⇒ Γ ⊎ {v : τ}
Γ ⊢ a0 : ρ
Γ ⊢ uadc v a0 a1 d ⇒ Γ ⊎ {v : ρ}
Γ ⊢ a1 : ρ
Γ ⊢ cast v@τ a ⇒ Γ ⊎ {v : τ}
Γ ⊢ a1 : τ CMov
Γ ⊢ d : bit UAdc
Γ ⊢ a0 : σ
UAdds
Cast
Γ ⊢ a0 : ρ
Γ ⊢ a1 : ρ
Γ ⊢ uadd v a0 a1 ⇒ Γ ⊎ {v : ρ}
Γ ⊢ a0 : σ
Γ ⊢ sadc v a0 a1 d ⇒ Γ ⊎ {v : σ}
Γ ⊢ a1 : σ
Γ ⊢ a1 : σ
UAdd
Γ ⊢ d : bit SAdc
UAdcs
Γ ⊢ a0 : σ
Γ ⊢ ssub v a0 a1 ⇒ Γ ⊎ {v : σ}
Γ ⊢ a0 : σ
Γ ⊢ sadds c v a0 a1 ⇒ Γ ⊎ {c : bit, v : σ}
Γ ⊢ d : bit
Γ ⊢ sadcs c v a0 a1 d ⇒ Γ ⊎ {c : bit, v : σ}
Γ ⊢ a1 : ρ
Γ ⊢ a1 : σ
Γ ⊢ a1 : σ
SAdds
SAdcs
SSub
Γ ⊢ a0 : σ
Γ ⊢ a0 : ρ
Γ ⊢ usbb v a0 a1 d ⇒ Γ ⊎ {v : ρ}
Γ ⊢ a1 : σ
Γ ⊢ d : bit USbb
SSubs
Γ ⊢ usubs c v a0 a1 ⇒ Γ ⊎ {c : bit, v : ρ}
Γ ⊢ ssubs c v a0 a1 ⇒ Γ ⊎ {c : bit, v : σ}
USubs
Γ ⊢ a : ρ
Γ ⊢ ushl v a n ⇒ Γ ⊎ {v : ρ}
UShl
Γ ⊢ aH : ρ
Γ ⊢ usbbs c v a0 a1 d ⇒ Γ ⊎ {c : bit, v : ρ}
Γ ⊢ ucshl vH vL aH aL n ⇒ Γ ⊎ {vH : ρ, vL : ρ}
Γ ⊢ uspl vH vL a n ⇒ Γ ⊎ {vH : ρ, vL : ρ}
Γ ⊢ aL : ρ
Γ ⊢ a : ρ
Γ ⊢ a0 : ρ
Γ ⊢ a1 : ρ
Γ ⊢ umull vH vL a0 a1 ⇒ Γ ⊎ {vH : ρ, vL : ρ}
USbbs
UCShl
USpl
UMull
Γ ⊢ a : σ
Γ ⊢ sshl v a n ⇒ Γ ⊎ {v : σ}
SShl
Γ ⊢ a0 : σ
Γ ⊢ a1 : σ
Γ ⊢ d : bit
Γ ⊢ ssbbs c v a0 a1 d ⇒ Γ ⊎ {c : bit, v : σ}
Γ ⊢ aH : σ
Γ ⊢ aL : ρ
σ∥ρ
Γ ⊢ scshl vH vL aH aL n ⇒ Γ ⊎ {vH : σ , vL : ρ}
SSpl
Γ ⊢ sspl vH vL a n ⇒ Γ ⊎ {vH : σ , vL : ρ}