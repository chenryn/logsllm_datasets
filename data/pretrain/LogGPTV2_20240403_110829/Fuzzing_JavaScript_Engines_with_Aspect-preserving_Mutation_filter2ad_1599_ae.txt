seed corpus, DIE is the least distant from the corpus regarding
optimization invocations. The eight most notable optimization phases
are highlighted.
state-of-the-art JavaScript fuzzers that found JavaScript bugs
that are acknowledged as CVEs and uses the corpus for input
mutation and generation.
Aspect preserving presented as JIT invocations. We observe
in Table VI that DIE generates 1.12× and 1.61× more inputs
than Superion and CodeAlchemist that invokes JIT compilation.
The result shows that Superion also tends to maintain aspect
through mutation, but DIE is better than Superion because our
approach is aware of not only grammar but also semantics
for mutation. In addition, the approach of CodeAlchemist is
far from leveraging aspects because it breaks useful aspects
in the seed corpus while breaking corpora into code bricks.
Furthermore, comparison between DIE and DIEt shows the
importance of maintaining the structure in regard to aspect
preserving. Speciﬁcally, DIE invokes JIT compilation 1.9×
more times in the experiment.
Aspect preserving presented as optimization invocation. To
demonstrate the approach that DIE helps to preserve aspect
in a more ﬁne-grained way, we measured the number of
invoked optimization phases and compared it with the one
invoked by the ﬁles in the seed corpus. Figure 4 shows
that DIE modiﬁes the fewest aspects in the seed against
DIEt, Superion, and CodeAlchemist. DIE maintains the same
optimization invocation 1.53× and 4.29× more than DIEt
and CodeAlchemist, respectively. In particular, CodeAlchemist
makes the biggest difference for every optimization phase,
which means reassembling code bricks can totally break
the existing aspects in the seed corpus. Superion shows the
negligible difference from DIE because Superion fuzzes code
Fig. 5: The error rate of seed ﬁles and inputs generated by DIE without
coverage feedback (i.e., DIEc), DIE, Superion, CodeAlchemist, and
jsfunfuzz against ChakraCore for 12 hours. The y-axis represents the
rate of the generated inputs yielding runtime errors. Based on the
same seed corpus, both Superion and CodeAlchemist generate 2.31×
more runtime errors than DIE. In the meantime, jsfunfuzz generates
2.42× more runtime errors than DIE.
in a dumb manner, which is proven as it generates less diverse
bytecodes (see Table V) and higher syntax error (see Figure 5).
However, the dumb manner leaves JIT-affected code in the seed
corpus intact in many cases, so it does not hurt the optimization
invocation a lot.
Unique bytecode generation. DIE generates more diverse
bytecodes than the ones emitted by the seed corpus whether the
structure is preserved or not (see Table V). In contrast to DIE,
Superion and CodeAlchemist produce less diverse bytecodes
than the ones of the seed corpus, which indicates that both
fuzzers cannot fully utilize existing test cases. Also, the result
shows that DIE tends to explore the input space in a more
diverse way than the others.
E. Validity of Generated Input
As §III-B described, generating valid highly-structured input
is difﬁcult but important because early termination by invalid
input will hinder further exploring the input space, which
may include defects. To answer Q4, we measured the runtime
error rates while executing generated input by Superion [44],
CodeAlchemist [19], jsfunfuzz [39], and DIE. We slightly
modiﬁed the fuzzers to check the standard error streams of
executing the generated input with the JavaScript engine to
compare DIE against existing fuzzers.
3To conﬁrm the fairness of comparison, we conducted manual inspection of
root causes of high error rate generated by CodeAlchemist. We observed that
high error rate majorly stems from incorrect variable handling (i.e., redeclare
existing variables and redeﬁne them with wrong types) between assembled
code bricks.
)
%
(
e
t
a
R
h
t
a
P
d
e
r
e
v
o
C
23
22
21
20
19
18
17
16
15
Die
Diet
Superion
CodeAlchemist
0h
5h
10h
15h
20h
Time (h)
Fig. 6: The overall covered path rate of running DIE, DIE without
structure-preserving (i.e., DIEt), Superion, and CodeAlchemist against
ChakraCore for 24 hours. The solid lines represent mean and the
shades around lines are conﬁdence intervals for ﬁve runs. In the
process, DIE visits unique paths up to 1.16× more than Superion and
up to 1.29× more than CodeAlchemist. The unique paths visited by
DIEt slightly exceed the original DIE up to 1.01×.
JavaScript Engine
ChakraCore 1.11.10
JavaScriptCore 2.24.2
V8 7.7.100
DIE
17
2
2
DIEt
Superion
CodeAlchemist
7
0
1
0
0
1
3
0
0
TABLE VII: The number of unique crashes found by DIE, Superion
and CodeAlchemist for 24 hours on the latest engines of June, 2019.
All of the crashes were manually inspected to conﬁrm its uniqueness.
Figure 5 presents the error rate of generated input by DIE and
existing fuzzers. First, we measured the error rate of the intact
seed ﬁles (i.e., vanilla) for comparison. The set of seed ﬁles
originally generated an 11.20% error rate when we performed
a dry-run. With the seed set, the newly created inputs by DIE
produced an 18.88% error rate with coverage feedback. In
addition, Superion and CodeAlchemist generated a 43.54%
and 43.58% error rate with the same seed set, and jsfunfuzz
generated a 45.62% error rate, which means that the generated
inputs by both Superion and CodeAlchemist yield 2.31× more
runtime error 4and generated inputs by jsfunfuzz yield 2.42×
more runtime error than DIE. This result demonstrates the
effectiveness of DIE against existing JavaScript fuzzers with
regard to generating valid input, which is an important factor to
a fuzz structured target. Furthermore, we measured DIE without
coverage feedback to show the ability of DIE to construct valid
code. Without coverage feedback, DIE generated an 8.65%
error rate, which is less than the error rate of the original
seed set. The result indicates that DIE analyzes type correctly,
builds a valid typed AST node based on our type system, and
replaces the error-yielding AST node with the valid AST node.
F. Performance Comparison with Other Fuzzers
To compare performance in terms of exploring input space
and reaching crashes against state-of-the-art fuzzers, we ﬁrst ran
DIE, DIEt, Superion, and CodeAlchemist on the instrumented
JavaScript engine to measure code coverage. In addition, we
ran them in the same environment (see §VI-A) against the
latest versions of three major JavaScript engines and counted
the number of crashes they found. Both experiments lasted for
24 hours.
Exploring input space. Figure 6 illustrates that DIE explores
unique code paths up to 1.16× more than Superion and 1.29×
more than CodeAlchemist. Interestingly, DIEt visits slightly
more paths than the original DIE. This is because DIEt has
more chances to mutate diverse nodes in a more diverse manner,
which matches the result in Table V that it produces more
unique bytecodes.
Reaching crashes. Table VII summarizes the number of
unique crashes each fuzzer found. Note that DIE found the
most unique crashes 5 on the JavaScript engine, while Superion
and CodeAlchemist found fewer crashes. In particular, DIE
found 5.7× more than CodeAlchemist on the latest version of
ChakraCore, and Superion could not ﬁnd any crash over the
same period.
From the result, we observe that most code paths were
introduced within the ﬁrst
two hours, which shows that
leveraging aspects in the seed helps to boost exploring diverse
paths. More importantly, we conclude that code coverage tends
to show the ability of input-space searching, but it cannot be
the absolute metric to judge the ability of a JavaScript engine
fuzzer to ﬁnd bugs: (1) DIEt introduced more code coverage
than DIE, but found fewer crashes, and (2) 71.79% of the
crashes found by DIE in ChakraCore are generated after the
ﬁrst two hours.
VII. DISCUSSION
We have demonstrated that DIE effectively leverages the
aspects to discover bugs in the latest JavaScript engines. In
this section, we discuss the limitations of DIE and our future
directions.
Seed prioritization. The mutation approach of DIE highly
relies on the seed ﬁles, which means the quality of the starting
corpus is an important factor that determines the result. DIE
currently does not prioritize seeds for mutation, which may
make DIE waste time on mutating the seed ﬁles that do not have
valuable aspects and discourage DIE from exploring faceted
ones. We believe DIE beneﬁts from the state-of-the-art seed
selection algorithms [34, 43].
Generative rule-based builder. DIE generates typed nodes
based on the language rules. In particular, DIE includes most
operations allowed in JavaScript to generate diverse code
segments. However, DIE uniformly selects the generation rules
to build new nodes. Researchers can prioritize certain rules to
heavily test speciﬁc routines in JavaScript engines. Moreover,
5All crashes are manually inspected, suggested by [22], to conﬁrm their
distinctness instead of AFL’s coverage measure.
DIE can integrate several existing approaches to generate new
code such as utilizing code fragments [19, 20] or IR-based
generation [17].
Aspect annotation. Practically, DIE considers that the struc-
ture and type information of a test case form its aspects when
fuzzing JavaScript ﬁles. Basically, this information is feasible
and largely affects how a JavaScript engine JIT-compiles and
further optimizes a program. Nevertheless, one is free to
annotate the aspects of a seed ﬁle [30, 32] with different
semantic information and explore more speciﬁc code paths.
Aspect-preserving mutation beyond JavaScript. Although
DIE only focuses on fuzzing JavaScript engines now, the
concept of aspect-preserving mutation is generic enough to be
applied against any target. First, the core idea of DIE can be
ported to other language compilers or interpreters for other
contexts.
For example, Equivalence Modulo Inputs (EMI) [23, 24]
is proposed to validate optimizing compilers for differential
testing. Similar to DIE, it utilizes existing input corpora to
construct valid test programs. In addition, it selectively mutates
unexecuted code to fully exploit the existing semantics that
can correspond to the aspect of DIE. We believe that the
mutation algorithm of these works can beneﬁt from DIE by
cooperating with its type-preserving mutation based on structure
preserving. This is technically doable in C context with a
mutation skeleton [5]. Also, [45] proposes a marking algorithm,
which has a similar effect to preserve structure in DIE, to fuzz
an ActionScript virtual machine. Instead of marking only the
identiﬁer, our type-preserving mutation can help to improve
the marking algorithm in that context as well.
Furthermore, we can adopt
the concept of aspects for
applications that receive binary input by identifying the aspects
of a seed ﬁle. For instance, using taint analysis can deprioritize
the modiﬁcation of certain bytes of the ﬁle based upon the
analysis results. The notable bytes contribute to the aspects.
VIII. RELATED WORK
Syntax-aware fuzzing. The earliest fuzzers for structured
inputs worked for being aware of their syntax [3, 11, 41, 46–
48]. In JavaScript fuzzing, jsfunfuzz [39], and LangFuzz [20]
are frontiers in this line of work. jsfunfuzz generates various
JavaScript programs from scratch based on its pre-deﬁned
rules, while LangFuzz modiﬁes existing test cases by randomly
combining their code fragments. Unlike these approaches, DIE
considers not only syntax but also semantics to generate test
cases with fewer runtime errors.
Semantic-aware fuzzing. After proposing a line of syntax-
aware JavaScript engine fuzzers, researchers have started
to build semantic-aware ones [19, 31, 42, 43] for better
performance. Skyﬁre [43] is one of the earliest research efforts
that tackles the semantic problem in language fuzzing. Skyﬁre
learns the semantics of a language from existing test cases in the
form of probabilistic context-sensitive grammar (PCSG), which
is further used for fuzzing. Unlike Skyﬁre, CodeAlchemist [19]
focuses more on correctly using variables in the generated code
based on their types so as to create more semantically valid
inputs. Machine learning is also applied to master sophisticated
semantic rules from numerous seed ﬁles [8, 12], which are
used for generating more test cases. Not only aimed at building
semantically correct inputs like these works, DIE targetedly
stresses speciﬁc components in a JavaScript engine by fully
utilizing the overall semantic properties of each existing test
case (i.e., aspects).
Coverage-guided fuzzers. Starting from AFL [49], coverage-
guided fuzzing became very popular among general-purpose
fuzzers [7, 27, 36, 38] and also for JavaScript fuzzing [2, 44].
Superion [44] extends AFL to support additional muta-
tion strategies for grammar-based inputs such as XML and
JavaScript. As a result, Superion beneﬁts from coverage
feedback by better preserving the structure of a JavaScript
program. Similarly, Nautilus [2] leverages coverage feedback
with context-free-grammar-based input generation. Fuzzilli [17],
a recently introduced generative JavaScript fuzzer, also relies
on coverage feedback. Based on a specially designed Inter-
mediate Representation (IR), Fuzzilli builds syntactically and
semantically correct test cases from scratch. Different from
these approaches that arbitrarily modify test cases only for
maximizing code coverage, DIE limits its mutation for aspects
to meet the complex conditions of modern JavaScript bugs.
IX. CONCLUSION
In this paper, we propose DIE, a JavaScript engine fuzzer
that preserves the aspects of a pre-mutated test case, which are
the essential conditions for its original purpose. To this end,
DIE deliberately handles the structure of a given test case and
keeps its type information intact using our novel type analysis
in a static and dynamic manner. Our evaluation shows that DIE
can maintain 1.61× more aspects than state-of-the-art fuzzers,
including Superion and CodeAlchemist, resulting in 5.7× more
unique crashes. More importantly, DIE found 48 new bugs in
real-world JavaScript engines with 12 CVEs assigned.
X. ACKNOWLEDGMENT
We thank the anonymous reviewers, and Frank Piessens
especially, for their helpful feedback. This research was
supported, in part, by the NSF award CNS-1563848, CNS-
1704701, CRI-1629851 and CNS-1749711 ONR under grant
N00014-18-1-2662, N00014-15-1-2162, N00014-17-1-2895,
DARPA AIMEE, and ETRI IITP/KEIT[2014-3-00035], and
gifts from Facebook, Mozilla, Intel, VMware and Google.
REFERENCES
[1] Apple. JavaScriptCore, The built-in JavaScript engine for WebKit, 2019.
https://trac.webkit.org/wiki/JavaScriptCore.
[2] C. Aschermann, T. Frassetto, T. Holz, P. Jauernig, A.-R. Sadeghi, and
D. Teuchert. Nautilus: Fishing for deep bugs with grammars. In NDSS,
2019.
[3] O. Bastani, R. Sharma, A. Aiken, and P. Liang. Synthesizing program
input grammars. In ACM SIGPLAN Notices, volume 52, pages 95–110.
ACM, 2017.
[4] O. Chang, A. Arya, and J. Armour. OSS-Fuzz: Five Months Later, and
Rewarding Projects, 2018. https://security.googleblog.com/2017/05/oss-
fuzz-ﬁve-months-later-and.html.
[5] J. Chen, J. Han, P. Sun, L. Zhang, D. Hao, and L. Zhang. Compiler bug
isolation via effective witness test program generation. In Proceedings
of the 27th ACM SIGSOFT Symposium on the Foundations of Software
Engineering (FSE), Tallinn, Estonia, Aug. 2019.
[6] Y. Chen, Y. Jiang, F. Ma, J. Liang, M. Wang, C. Zhou, Z. Su, and
X. Jiao. Enfuzz: Ensemble fuzzing with seed synchronization among
diverse fuzzers. In Proceedings of the 28th USENIX Security Symposium
(Security), Santa Clara, CA, USA, Aug. 2019.
[7] N. Coppik, O. Schwahn, and N. Suri. Memfuzz: Using memory accesses
to guide fuzzing. In 2019 12th IEEE Conference on Software Testing,
Validation and Veriﬁcation (ICST), pages 48–58. IEEE, 2019.
[8] C. Cummins, P. Petoumenos, A. Murray, and H. Leather. Compiler
fuzzing through deep learning.
In Proceedings of the International
Symposium on Software Testing and Analysis (ISSTA), Amsterdam,
Netherlands, July 2018.
[9] ECMA. Standard ECMA-262. https://www.ecma-international.org/
publications/standards/Ecma-262.htm, 2019.
[10] J. Forcier. Fabric, High level python library designed to execute shell
commands remotely over SSH, 2019. http://www.fabﬁle.org/.
[11] P. Godefroid, A. Kiezun, and M. Y. Levin. Grammar-based whitebox
fuzzing. In Proceedings of the 2008 ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI), Tucson,
Arizona, June 2007.
[12] P. Godefroid, H. Peleg, and R. Singh. Learn&fuzz: Machine learning for
input fuzzing. In Proceedings of the 32nd IEEE/ACM International Con-
ference on Automated Software Engineering (ASE), Urbana-Champaign,
Illinois, USA, Nov. 2017.
[13] Google. Chrome Releases. https://chromereleases.googleblog.com, 2019.
[14] Google. project-zero. https://bugs.chromium.org/p/project-zero/issues/list,
2019.
[15] Google. Continuous fuzzing of open source software, 2019. https:
//opensource.google/projects/oss-fuzz.
[16] Google. V8, Open source JavaScript and WebAssembly engine for
Chrome and Node.js, 2019. https://v8.dev/.
[17] S. Groß. Fuzzil: Coverage guided fuzzing for javascript engines. Master’s
thesis, TU Braunschweig, 2018.
[18] C. Han. js-vuln-db, A collection of JavaScript engine CVEs with PoCs,
2019. https://github.com/tunz/js-vuln-db.
[19] H. Han, D. Oh, and S. K. Cha. Codealchemist: Semantics-aware code
generation to ﬁnd vulnerabilities in javascript engines. In Proceedings of
the 2017 Annual Network and Distributed System Security Symposium