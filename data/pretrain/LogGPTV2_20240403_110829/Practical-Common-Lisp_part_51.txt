### 第21章：Common Lisp包的各种疑难杂症

至此，你已经基本完成了对 Common Lisp 的了解。在下一章中，我将讨论扩展形式的 LOOP 宏的细节。

最后一个与包相关的疑难杂症相对来说比较简单，但它给大多数 Lisp 程序员带来了不少麻烦。当诸如 `DEFUN`、`DEFVAR` 和 `DEFCLASS` 这类定义形式所在的主包是当前包时，它们才能顺利通过。

---

### 第22章：高阶 LOOP

#### 22.1 引言

我将从头介绍 LOOP，系统化地介绍它的多个组成部分以及彼此间配合使用的方式。LOOP 宏由许多部分组成，这正是其反对者们批评它过于复杂的主要论点之一。然而，循环结构在程序中的各种用法表明，这样做是合理的。任何规模的程序都会包含相当数量的循环，而这些循环中有许多固定的编码模式。LOOP 语言捕捉了这些模式，让你可以直接表达各种循环。

#### 22.2 LOOP 的基本结构

LOOP 的基本结构是一个子句集合，其中每个子句都以一个循环关键字（loop keyword）开头。尽管被称为“循环关键字”，但它们并不是正常意义上的 KEYWORD 包中的关键字。事实上，LOOP 关键字只关心它们的名字。

LOOP 提供了以下功能：
- 在循环开始前和结束后运行任意 Lisp 表达式。
- 创建用于循环内部的局部变量。
- 条件执行上述内容。
- 决定何时终止循环。
- 执行任意 Lisp 表达式。
- 在循环过程中收集、计数、求和以及求最大值或最小值。
- 以数值或多种数据结构为步长进行循环。

#### 22.3 计数型循环

算术迭代子句可以控制循环体的执行次数，它通过在一个整数范围上步进来实现这一点。每次进一步就执行一次循环体。这些子句由 `for`（或 `as`）之后紧跟下列介词短语中的 1~3 个构成：起始短语、终止短语以及步长短语。

- **起始短语** 指定了该子句的变量初始值。它由介词 `from`、`downfrom` 或 `upfrom` 之一后接一个提供初值的形式所构成。
- **终止短语** 指定了循环的终止点。它由介词 `to`、`upto`、`below`、`downto` 或 `above` 之一后接一个提供终值的形式所构成。
- **步长短语** 由介词 `by` 和一个形式所构成，该形式必须求值为一个正数。变量将按照该数在每次迭代时步进（向上或向下，取决于其他短语）或是在其默认时每次步进 1。

例如：
```lisp
(loop for i from 0 to 10 collect i)  ; 收集从 0 到 10 的整数
```

#### 22.4 循环集合和包

LOOP 还支持在哈希表和包中迭代。对于哈希表来说，`things` 的可能值是 `hash-keys` 和 `hash-values`。对于包来说，`things` 可以是 `symbols`、`present-symbols` 和 `external-symbols`。

例如：
```lisp
(loop for k being the hash-keys in h using (hash-value v)
      collect (list k v))  ; 收集哈希表 h 中的键值对
```

#### 22.5 迭代控制

`for` 子句可以控制循环变量的步进方式。如果其他的 `for` 子句都无法确切支持你所需要的变量步进形式，那么你可以通过 `equals-then` 子句来完全控制步进的方式。

例如：
```lisp
(loop for x = 0 then (+ x 1) while (< x 10) collect x)  ; 收集从 0 到 9 的整数
```

#### 22.6 局部变量

尽管循环所需要的主要变量通常都在 `for` 子句中隐式声明，但有时也需要额外的变量。这些变量可以使用 `with` 子句来声明。

例如：
```lisp
(loop repeat 5
      with x = 0
      do (incf x)
      finally (return x))  ; 返回 5
```

#### 22.7 解构绑定

LOOP 还支持解构绑定，允许你将列表值解构到树形结构中的变量上。

例如：
```lisp
(loop for (a b . c) in '((1 2 3) (4 5 6))
      collect (list a b c))  ; 收集解构后的结果
```

通过这些详细的介绍，希望你能更好地理解和使用 LOOP 宏，从而编写出更简洁和高效的代码。