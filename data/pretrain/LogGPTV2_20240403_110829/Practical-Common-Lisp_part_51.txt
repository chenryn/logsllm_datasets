至此，你基本完成了对CommonLisp的了解。在下一章里，我将讨论扩展形式的LooP宏的细
最后一个包相关的疑难杂症相对来说比较简单，但它给多数Lisp程序员至少带来了几次麻
当诸如DEFUN、DEFVAR和DEFCLASS这类定义形式所在的主包是当前包时才能顺利通过。
www.TopSage.com
21.8包的各种疑难杂症 
239
---
## Page 257
包括for、collecting、summing、counting、do以及finally。
始。“每个子句被LOOP宏解析的方式取决于具体的关键字。第7章已经介绍了一些主要的关键字，
22.1
我将从头介绍LOOP，系统化地介绍它的多个组成部分以及彼此间配合使用的方式。
所需操作的模式。LOOP语言捕捉了这些模式，让你可以直接表达各种循环。
在循环前后包含代码时——为循环做准备的模式，确保循环过程所需的模式，以及当循环结束时
环。虽然它们不都是完全一样的，但也不是完全不同的。循环里有很多固定的编码模式，尤其是
在程序中的各种用法，就会发现事实上这样做是合理的。任何规模的程序都会包含相当数量的循
LOOP宏由许多部分组成——LOOP反对者们的一个主要论点就是说它过于复杂。在本章里，
①“循环关键字”这个名字取得并不是很好，因为循环关键字并不是正常意义下的KEYWORD包中的关键字。事实上，
Loop的基本结构是一个子句集合，其中每个子句都以一个循环关键字（loop keyword）开
口指定任意Lisp表达式在循环开始前和结束后运行。
口创建用于循环内部的局部变量；
另外，LOOP还提供了用于下列事务的语法：
口条件执行上述内容。
口决定何时终止循环;
口执行任意Lisp表达式；
口在循环的过程中收集、计数、求和以及求最大值或最小值;
口以数值或多种数据结构为步长来做循环；
你可以在一个LOOP中做下列事情：
这看起来可能有些无聊——发明一种全新的语言只为编写循环。但如果你深入思考循环结构
写成不带有包限定符的形式并在当前包下被读取(必要时会创建新符号)。
来自任何包的任何符号，只要有适当的名字就可以了，LOOP宏只关心它们的名字。不过，通常情况下它们都被
LOOP 的组成部分
高阶LOOP
www.TopSage.com
---
## Page 258
认值中的任何一个或全部。唯一需要注意的是如果要逐步递减的话，不存在默认的初始值，必须
或者更有可能的是直到其他某个子句终止了循环。你可以通过添加适当的介词短语来修改这些默
迭代时步进（向上或向下，取决于其他短语）或是在其默认时每次步进1。
以后不会再次求值循环体)；而当使用below和above时，它会提前一次迭代终止循环。
个提供终值的形式所构成。当使用upto和downto时，循环体将在变量通过终止点时终止（通过
提供初值（一个数字）的形式所构成。
始短语、终止短语以及步长短语。
进一步就执行一次循环体。这些子句由for（或as）之后紧跟下列介词短语中的1~3个构成：起
22.3
将迭代至多10次，但在list含有少于10项时会提前终止。
个for子句，其中任何一个子句达到结束条件循环都会终止。例如，下面的循环：
名字。变量名后面的内容取决于for子句的类型。
22.2
① 因为当初LOOP的目标之一就是允许循环表达式可以被写成类似英语的语法，所以许多关键字都有一些同义词,
你必须至少指定一个上述介词短语。默认值是从零开始，每次迭代时加1，然后一直加下去，
步长短语由介词by和一个形式所构成，该形式必须求值为--个正数。变量将按照该数在每次
终止短语指定了循环的终止点。它由介词to、upto、below、downto或above之一后接一
起始短语指定了该子句的变量初始值。它由介词from、downfrom或upfrom之一后接一个
大多数所谓的迭代控制子句都以循环关键字for或是它的同义词as?开始，后接一个变量的
算术迭代子句可以控制循环体的执行次数，它通过在一-个整数范围上步进来做到这点，每前
(loop
循环可以含有多个for子句，其中每个子句都可以命名其自己的循环变量。如果循环含有多
口对给定形式反复求值得到的结果。
口
口
口数字范围(以指定的间隔向上或向下)；
它们对于LOOP来说处理方法相同，但在不同的语境下可以更接近英语的语法习惯。
一个for子句的下级子句可以对下列内容进行迭代：
一个包中的符号；
or
哈希表的键值对；
向量的元素 (包括诸如字符串和位向量这样的向量子类型)；
计数型循环
构成列表的点对单元；
由单独的项组成的列表；
(something))
迭代控制
i from 1 to 10
item in list
www.TopSage.com
22.3计数型循环
241
---
## Page 259
将在求值list-form所产生的列表的所有元素上推动变量var。
22.4循环集合和包
替换成如下所示的一个repeat子句:
面这样收集一个列表中相隔的元素：
函数，其默认值是CDR，但它可以是任何接受一个列表并返回其子列表的函数。例如，可以像下
或是
根本不会执行。此时，你必须写成：
将不知道是从20向下数到10。更糟糕的是，它不会给你报错一
可以工作得很好，因为默认就是递增步进。但形式：
些形式的值来决定变量步进的方向，因为形式的值到运行期才会知道。因此，形式
以下是一种正确的写法：
会收集到11个整数（从零到十)，而下面这个形式的行为则是未定义的：
使用from或downfrom来指定一个。因此，形式:
(loop for i from 20 downto 10 ...)
242
有时这个子句会在一个by短语的辅助下使用，by短语指定了一个用来在列表中向下移动的
(loop for i from 20 to 10...)）
(loop for i downto -10 collect i)
(loop for i upto 10 collect i)
for var in list-form
用于选代列表的for子句比算术子句更简单一些。这种子句只支持两个介词短语，in和on。
这些子句在效果上是等价的，只是repeat子句没有创建显式的循环变量。
repeat number-form
for i from 1 to number-form
最后，如果你只是想让一个循环重复特定的次数，那么可以将下列形式中的一个子句
(loop for i from 10 to 20 ...)
( 0) ( 1,#  0 0 0 1)  1 0)
(loop for i in (list 10 20 30 40) collect i)
一个下列形式的短语
(loop for i downfrom 20 to 10 ...)
另外要注意，由于LOOP是一个宏，运行在编译期，
(loop for i from 0 downto -10 collect i)
第22章高阶LOOP
www.TopSage.com
； wrong
，它需要能够完全基于这些介词而不是--
一由于i已经大于10了，所以循环
→(10 20 30 40)
---
## Page 260
Algol语言的语法。完整的形式如下所示：
（equals-then）子句来完全控制步进的方式。这个子句跟Do循环中的绑定语句很相似，但更接近
22.5
的第一个元素必须写成单数形式。
using子句。
或symbol）。
置上可用each，你还可以用of来代替in，另外你也可以将things写成单数形式（例如，hash-key
导致用FIND-PACKAGE来查找）或包对象本身。for子句的许多部分也可用同义词。在the的位
号），或是每一个从该包中导出的符号上。hash-or-packge被求值并产生一个包的名字（这会
们使var被绑定到包的每个可访问的符号、当前存在的符号（即在包里创建的或导入进该包的符
连续的键或值绑定。hash-or-package形式只被求值一次并产生一个值，它必须是一个哈希表。
表中的键或值，以及包中不同类型的符号。两种迭代都遵循相同的模式。基本的模式如下所示：
来代替in。?例如：
②不要问我为什么LooP的设计者们没有使用不带括号的风格来表示using子句。
①你可能想知道为什么LOOP不使用同样的介词，然后自己检查当前究竟是循环列表还是向量。这是LOOP作为一个
如果其他的for子句都无法确切支持你所需要的变量步进形式，那么你可以通过等价-然后
最后，由于你经常需要在一个哈希表上同时迭代键和值，哈希表子句还在其结尾处支持
要想在包上选代，things可以是symbols、present-symbols和external-symbols，它
这两个循环都可以将k绑定到哈希表的每个键上，再把v绑定到对应的值上。注意using子句
对于哈希表来说，things的可能值是hash-keys和hash-values，
循环向量（包括字符串和位向量）的元素与循环列表的元素类似，只是要使用介词across
(loop for k being the hash-keys in h using (hash-value v)
(loop for var being the things in hash-or-package...)
(1oop for x across “abcd"collect x)→（#\a #\b #\c #\d)
（1oop forxon（1ist10203040)by#'cddrco11ectx)→（(10203040）（3040）)
该短语也接受一个介词by：
on介词短语被用来在构成列表的点对单元上步进变量var。
需要在编译期知道这个值在运行期将是一个向量。因此，需要采用不同的介词。
并且LOOP的设计者们想要它生成极其高效的代码。为了能够生成用来访问的高效的代码，比如说一个向量，它
宏所带来的另一个后果：列表或者向量的值直到运行期才会知道，但LOOP作为一个宏必须在编译期生成代码，
等价-然后迭代
www.TopSage.com
它们使var与哈希表中
---
## Page 261
全无关的变量可以用and连接每个声明并放在一个with子句中。
其值将在处理下一个子句之前完成赋值，从而允许后面的变量可以依赖于已经声明过的变量。完
=value-form部分，那么变量将会在循环的首次迭代之前初始化为value-form的值。
些变量可以使用with子句来声明。
22.6
两个例子的另一个变体：
部替换成and。你已经在第7章通过Loop计算Fibonacci的示例里见过它的公式了。这是基于前面
步进其变量的方式）。在这种情况下，你可以将多个for子句连在一起，将除第一个以外的for全
新值之和。如果for子句的顺序反过来，那么结果将会改变。
次迭代时x会在y改变（变成1）之前被设置为y的值。但是y随后会被设置为它的旧值（1）与x的
例如：
这和一个没有步长形式的DO绑定子句的行为是不同的。
子句中没有then部分，那么initial-value-form将在每次迭代中重新求值以提供新值。注意，
form而获取到。在每一次后续迭代中，step-form被求值，然后它的值成为了var的新值。如果
step-form可以引用其他的循环变量，包括由循环中其他后续for子句所创建的循环变量。
244
多个with子句可以同时出现在一个循环里。每个子句将根据其出现的顺序独立求值，并且
尽管循环所需要的主要变量通常都会在for子句中隐式声明，但有时也需要额外的变量，这
var将成为一个局部变量的名字，它会在循环结束时被删除。如果with子句含有一个
with var [ = value-form ］
(loop repeat 5
不过，通常你都想让多个变量的步长形式在任何变量被赋予新值之前计算完毕（类似于Do
(loop repeat 5
不过，每个for子句都是以它们各自出现的顺序来逐个求值的，因此在前面的循环中，第二
(loop repeat 5
和通常一样，var是需要步进的变量名。它的初值在首次迭代之前通过求值initial-value-
(loop for var = initial-value-form [ then step-form ] ...)
局部变量
第22章高阶LOOP
collect y) → (1 1 2 3 5)
andy：
for x = 0 then y 
collect y) → (1 1 2 4 8)
for x
for y = 1 then (+ x y)
collect y) → (1 2 4 8 16)
= 1 then
then
then
(+xy)
(+ xy)
www.TopSage.com
---
## Page 262
into子句，这些值被保存在名为var的变量里。该变量对于循环来说是局部的，就像它是被一个
个汇聚子句都以一个动词后接下列模式开始：
价的。
个表示循环基本结构的简洁的语法，但它们本质上与DO、DOLIST和DOTIMES所提供的机制是等
22.8
变量本质上都像是&optional参数。不过，没有任何跟&key参数等价的东西。
也可以写成这样：
个循环(第8章曾用它来输出一个逗号分隔的列表)：
列表的其余元素上。这对于for/on类循环来说特别有用，因为值总是一个列表。例如，下面这
下所示：
原本赋值到简单变量上的列表值将改为解构到以树中的符号所命名的变量上。一个简单的例子如
那么复杂。基本上，你可以将任何出现在for或with子句中的循环变量替换成一个符号树，这样，