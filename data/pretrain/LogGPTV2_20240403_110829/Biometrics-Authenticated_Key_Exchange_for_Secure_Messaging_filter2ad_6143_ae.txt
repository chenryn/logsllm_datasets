0
1
1
Claim 2.
|Adv
Hy1
A
(𝜆) − Adv
Hy2
A
(𝜆)| is negligible.
Proof. This indistinguishability proof is guaranteed by AFEM
that has been proved in Section 3.2.4, and under the decisional-
LWE assumption and random oracle, the adversary B cannot dis-
tinguish the public key 𝑝𝑘𝑖 for 𝑖 = 0, 1 generated in Hy.2 from
the public key 𝑝𝑘𝑖 for 𝑖 = 0, 1 generated in previous hybrid. Ad-
ditionally, the message 𝑠0 for P0 (vs. the message 𝑠1 for P1) is
encrypted under a dummy public key 𝑝𝑘𝑖 instead of the real 𝑝𝑘𝑖 ←
AFEM.PubGen(𝑠𝑘𝑖 ), thus, 𝑐0 ← AFEM.Enc(𝑝𝑘
, 𝑠0) for P0 (vs.
𝑐1 ← AFEM.Enc(𝑝𝑘
, 𝑠1) for P1). This is indistinguishability proof
under the semantic security property of the AFEM scheme, and
the adversary B cannot distinguish the encapsulated messages
(cid:2)
generated in Hy.2 and Hy.1.
1
0
Hy.3. In this hybrid, we continue to deal with passive attacks
between two incompatible users. Hy.3 is identical to Hy.2 except
that we modify the answered way of 𝐸𝑥𝑒𝑐𝑢𝑡𝑒 on how to compute
the session key. The transcript is computed in the same way as
Hy.2 but with independent two session keys. We use the secret
sampled 𝑘0 and 𝑘1 from a uniform to replace the random oracle
H for computing the session keys (i.e., 𝑘0 and 𝑘1) in all sessions
generated via 𝐸𝑥𝑒𝑐𝑢𝑡𝑒. Below, the record (𝑝𝑘0, 𝑝𝑘1, 𝑐0, 𝑐1, 𝑠0, 𝑠 (cid:4)
) is
1
truncated to (𝑠0, 𝑠 (cid:4)
) and for the sake of illustration, where 𝑠∗
1 is
1
) if 𝑐 (cid:4)
obtained from AFEM.Dec(𝑠𝑘 (cid:4)
, 𝑠1) can
0
1
be decrypted correctly, otherwise, 𝑠∗
1 is sampled from a uniform dis-
tribution. Then, the session key 𝑘0 = 𝐻 (𝑠0 (cid:12)𝑠∗
) for P0 is replaced by
1
a random ¯𝑘0 ← {0, 1}ℓ
. Likewise, we use ¯𝑘1 for the receiver instead
of 𝑘1 = 𝐻 (𝑠∗
) if
0
, 𝑠0) can be decrypted correctly, otherwise, 𝑠∗
𝑐 (cid:4)
0
0
is sampled from a uniform distribution. Thus, we have
(cid:12)𝑠1) at this stage, where 𝑠∗
0
← AFEM.Dec(𝑠𝑘 (cid:4)
1
← AFEM.Enc(𝑝𝑘
← AFEM.Enc(𝑝𝑘
, 𝑐 (cid:4)
0
, 𝑐 (cid:4)
1
0
1
Claim 3.
|Adv
Hy2
A
(𝜆) − Adv
Hy3
A
(𝜆)| is negligible.
𝑗
, P
1
𝑗
, 𝑝𝑘1)) and 𝑆𝑒𝑛𝑑2 (P
1
Proof. In the aforementioned hybrid, A’s probability of guess-
ing 𝑏 in 𝑇 𝑒𝑠𝑡 oracle is exactly 1/2 if 𝑇 𝑒𝑠𝑡 query is made to a fresh
instance that was activated via 𝐸𝑥𝑒𝑐𝑢𝑡𝑒. In the following Hybrids,
we deal with active attacks via 𝑆𝑒𝑛𝑑, where A has possibly gener-
ated the inputs of a 𝑆𝑒𝑛𝑑 query. To this end, 𝑆𝑒𝑛𝑑 is modified so that
its output is chosen uniformly at random and independently of the
biometric secret key. Notably, 𝑆𝑒𝑛𝑑0 (P𝑖
) is the start-query for
0
𝑗
, 𝑝𝑘0)
a user to initiate an execution of BAEK, followed by 𝑆𝑒𝑛𝑑1 (P
1
(vs. 𝑆𝑒𝑛𝑑1 (P𝑖
(cid:2)
, 𝑐1)).
0
, 𝑐0) (vs. 𝑆𝑒𝑛𝑑2 (P𝑖
0
𝑗
Hy.4. We deal with active attacks using 𝑆𝑒𝑛𝑑2 (P
1
, 𝑐0) between
𝑗
, 𝑐0) represents that
compatible users before corruption. 𝑆𝑒𝑛𝑑2 (P
1
0 to 𝑆𝑒𝑛𝑑2 (P𝑖
A sends 𝑐0 to P0. We modify the behavior of P𝑖
, 𝑐1). At
this stage, 𝑐1 for P𝑖
0 is adversarially generated without knowing the
secret 𝑠𝑘0. Upon receiving 𝑆𝑒𝑛𝑑2 (P𝑖
, 𝑐1), S checks whether 𝑐1 for
0
the instance P𝑖
0 is either valid or invalid. If 𝑐1 is valid, then outputs
𝑐0 and the session key 𝑘0 is assigned with a special value. If 𝑐1 is
invalid, then outputs 𝑐0 and S samples 𝑠 (cid:4)
0 from a uniform
and stores the record (𝑝𝑘0, 𝑝𝑘1, 𝑐0, 𝑐1, 𝑠0, 𝑠 (cid:4)
). The inconsistency
can be detected if H has been asked with same 𝑐1 and 𝑠 (cid:4)
1. More
generally, A wins if a collision occurs. 𝑆𝑒𝑛𝑑2 (P𝑖
, 𝑐1) queries are
0
proceeded in a similar way, and we omit it here. Thus,
1 and 𝑘 ∗
1, 𝑘 ∗
0
0
Claim 4.
|Adv
Hy3
A
(𝜆) − Adv
Hy4
A
(𝜆)| is negligible.
Proof. If 𝑐0 is generated by A who used the public key 𝑝𝑘1 with
an associated secret key 𝑠𝑘1, and the regenerated secret key is close
to the previous one, e.g., 𝑑𝑖𝑠 (𝑠𝑘1, 𝑠𝑘 (cid:4)
)  𝜏, and S declares that A succeeds and termi-
0
nates the hybrid if 𝑑𝑖𝑠 (𝑠𝑘0, 𝑠𝑘 (cid:4)
0
(6) At the end of this hybrid, S outputs 1 if and only if A succeeds.
Let 𝑏 be a choice bit defined in Equation.1. If 𝑏 = 0, then the view
of A in the above execution with S is identical to the view of A
in Hy.4. If 𝑏 = 1, the view of A in the above execution with S is
(cid:2)
identical to the view of A in Hy.5. Thus, this claim holds.
) < 𝜏.
𝑗
Hy.6. We modify 𝑆𝑒𝑛𝑑1 (P
1
, 𝑝𝑘0) between incompatible users
before a 𝐶𝑜𝑟𝑟𝑢𝑝𝑡 query, where the public key 𝑝𝑘0 is generated
by taking as input an incorrect secret key 𝑠𝑘0, and the output of
𝑗
𝑆𝑒𝑛𝑑1 (P
←
1
{0, 1}ℓ
, 𝑘 ∗
1
, 𝑝𝑘0) is proceeded in a similar manner. Thus,
← {0, 1}∗, we set the session keys 𝑘 ∗
0
, 𝑝𝑘0) is 𝑝𝑘
𝑗
. 𝑆𝑒𝑛𝑑1 (P
1
1
Claim 6.
|Adv
Hy5
A
(𝜆) − Adv
Hy6
A
(𝜆)| is negligible.
Proof. This proof is implied by Claim 2, the difference is that
the dummy 𝑝𝑘
1 here is sampled from a uniform distribution, but in
Claim 2 it is computed by inputting a random secret key. Thus, we
(cid:2)
omit the redundant analysis here.
Hy.7. The secret keys/public keys are not known at the beginning,
but just at the corruption time or to check whether A wins when
A guesses the correct secret key at the very end only.
𝑗
, P
1
.
𝑗
, P
1
• 𝐸𝑥𝑒𝑐𝑢𝑡𝑒 (P𝑖
0
): S randomly selects ¯𝑐0 (vs. ¯𝑐1) from a uniform
distribution. If they are compatible, they are given the same
random session key 𝑘0 = 𝑘1. Otherwise, they are given two
independent random keys 𝑘0, 𝑘1 ← {0, 1}ℓ
• 𝑆𝑒𝑛𝑑0 (P𝑖
0
) implies that the instance of P𝑖
0 initiates an execu-
tion of BAKE, and S selects a random 𝑠𝑘𝑖 from SK and calculates
the public key 𝑝𝑘𝑖 ← AFEM.PubGen(𝑠𝑘𝑖 ).
𝑗
, 𝑝𝑘0) (vs. 𝑆𝑒𝑛𝑑1 (P𝑖
• 𝑆𝑒𝑛𝑑1 (P
, 𝑝𝑘1)) simulates the behavior of
0
1
1 (vs. P𝑖
0) before a corruption. S selects the secret key 𝑠𝑘1
P
(vs. 𝑠𝑘0), and randomly selects a public key 𝑝𝑘1 ← {0, 1}∗ (vs.
𝑝𝑘0 ← {0, 1}∗). Otherwise, S selects 𝑠𝑘1 (vs. 𝑠𝑘0) and sets 𝑝𝑘1 ←
AFEM.PubGen(𝑠𝑘1) (vs. 𝑝𝑘0 ← AFEM.PubGen(𝑠𝑘0)).
𝑗
• 𝑆𝑒𝑛𝑑2 (P𝑖
0
𝑗
, 𝑐1) (vs. 𝑆𝑒𝑛𝑑2 (P
1
, 𝑐0)) simulates the behavior of P𝑖
0
𝑗
1 ) in the following cases.