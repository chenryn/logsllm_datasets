0
1
1
Claim 2.
|Adv
Hy1
A
(ğœ†) âˆ’ Adv
Hy2
A
(ğœ†)| is negligible.
Proof. This indistinguishability proof is guaranteed by AFEM
that has been proved in Section 3.2.4, and under the decisional-
LWE assumption and random oracle, the adversary B cannot dis-
tinguish the public key ğ‘ğ‘˜ğ‘– for ğ‘– = 0, 1 generated in Hy.2 from
the public key ğ‘ğ‘˜ğ‘– for ğ‘– = 0, 1 generated in previous hybrid. Ad-
ditionally, the message ğ‘ 0 for P0 (vs. the message ğ‘ 1 for P1) is
encrypted under a dummy public key ğ‘ğ‘˜ğ‘– instead of the real ğ‘ğ‘˜ğ‘– â†
AFEM.PubGen(ğ‘ ğ‘˜ğ‘– ), thus, ğ‘0 â† AFEM.Enc(ğ‘ğ‘˜
, ğ‘ 0) for P0 (vs.
ğ‘1 â† AFEM.Enc(ğ‘ğ‘˜
, ğ‘ 1) for P1). This is indistinguishability proof
under the semantic security property of the AFEM scheme, and
the adversary B cannot distinguish the encapsulated messages
(cid:2)
generated in Hy.2 and Hy.1.
1
0
Hy.3. In this hybrid, we continue to deal with passive attacks
between two incompatible users. Hy.3 is identical to Hy.2 except
that we modify the answered way of ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’ on how to compute
the session key. The transcript is computed in the same way as
Hy.2 but with independent two session keys. We use the secret
sampled ğ‘˜0 and ğ‘˜1 from a uniform to replace the random oracle
H for computing the session keys (i.e., ğ‘˜0 and ğ‘˜1) in all sessions
generated via ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’. Below, the record (ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1, ğ‘ 0, ğ‘  (cid:4)
) is
1
truncated to (ğ‘ 0, ğ‘  (cid:4)
) and for the sake of illustration, where ğ‘ âˆ—
1 is
1
) if ğ‘ (cid:4)
obtained from AFEM.Dec(ğ‘ ğ‘˜ (cid:4)
, ğ‘ 1) can
0
1
be decrypted correctly, otherwise, ğ‘ âˆ—
1 is sampled from a uniform dis-
tribution. Then, the session key ğ‘˜0 = ğ» (ğ‘ 0 (cid:12)ğ‘ âˆ—
) for P0 is replaced by
1
a random Â¯ğ‘˜0 â† {0, 1}â„“
. Likewise, we use Â¯ğ‘˜1 for the receiver instead
of ğ‘˜1 = ğ» (ğ‘ âˆ—
) if
0
, ğ‘ 0) can be decrypted correctly, otherwise, ğ‘ âˆ—
ğ‘ (cid:4)
0
0
is sampled from a uniform distribution. Thus, we have
(cid:12)ğ‘ 1) at this stage, where ğ‘ âˆ—
0
â† AFEM.Dec(ğ‘ ğ‘˜ (cid:4)
1
â† AFEM.Enc(ğ‘ğ‘˜
â† AFEM.Enc(ğ‘ğ‘˜
, ğ‘ (cid:4)
0
, ğ‘ (cid:4)
1
0
1
Claim 3.
|Adv
Hy2
A
(ğœ†) âˆ’ Adv
Hy3
A
(ğœ†)| is negligible.
ğ‘—
, P
1
ğ‘—
, ğ‘ğ‘˜1)) and ğ‘†ğ‘’ğ‘›ğ‘‘2 (P
1
Proof. In the aforementioned hybrid, Aâ€™s probability of guess-
ing ğ‘ in ğ‘‡ ğ‘’ğ‘ ğ‘¡ oracle is exactly 1/2 if ğ‘‡ ğ‘’ğ‘ ğ‘¡ query is made to a fresh
instance that was activated via ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’. In the following Hybrids,
we deal with active attacks via ğ‘†ğ‘’ğ‘›ğ‘‘, where A has possibly gener-
ated the inputs of a ğ‘†ğ‘’ğ‘›ğ‘‘ query. To this end, ğ‘†ğ‘’ğ‘›ğ‘‘ is modified so that
its output is chosen uniformly at random and independently of the
biometric secret key. Notably, ğ‘†ğ‘’ğ‘›ğ‘‘0 (Pğ‘–
) is the start-query for
0
ğ‘—
, ğ‘ğ‘˜0)
a user to initiate an execution of BAEK, followed by ğ‘†ğ‘’ğ‘›ğ‘‘1 (P
1
(vs. ğ‘†ğ‘’ğ‘›ğ‘‘1 (Pğ‘–
(cid:2)
, ğ‘1)).
0
, ğ‘0) (vs. ğ‘†ğ‘’ğ‘›ğ‘‘2 (Pğ‘–
0
ğ‘—
Hy.4. We deal with active attacks using ğ‘†ğ‘’ğ‘›ğ‘‘2 (P
1
, ğ‘0) between
ğ‘—
, ğ‘0) represents that
compatible users before corruption. ğ‘†ğ‘’ğ‘›ğ‘‘2 (P
1
0 to ğ‘†ğ‘’ğ‘›ğ‘‘2 (Pğ‘–
A sends ğ‘0 to P0. We modify the behavior of Pğ‘–
, ğ‘1). At
this stage, ğ‘1 for Pğ‘–
0 is adversarially generated without knowing the
secret ğ‘ ğ‘˜0. Upon receiving ğ‘†ğ‘’ğ‘›ğ‘‘2 (Pğ‘–
, ğ‘1), S checks whether ğ‘1 for
0
the instance Pğ‘–
0 is either valid or invalid. If ğ‘1 is valid, then outputs
ğ‘0 and the session key ğ‘˜0 is assigned with a special value. If ğ‘1 is
invalid, then outputs ğ‘0 and S samples ğ‘  (cid:4)
0 from a uniform
and stores the record (ğ‘ğ‘˜0, ğ‘ğ‘˜1, ğ‘0, ğ‘1, ğ‘ 0, ğ‘  (cid:4)
). The inconsistency
can be detected if H has been asked with same ğ‘1 and ğ‘  (cid:4)
1. More
generally, A wins if a collision occurs. ğ‘†ğ‘’ğ‘›ğ‘‘2 (Pğ‘–
, ğ‘1) queries are
0
proceeded in a similar way, and we omit it here. Thus,
1 and ğ‘˜ âˆ—
1, ğ‘˜ âˆ—
0
0
Claim 4.
|Adv
Hy3
A
(ğœ†) âˆ’ Adv
Hy4
A
(ğœ†)| is negligible.
Proof. If ğ‘0 is generated by A who used the public key ğ‘ğ‘˜1 with
an associated secret key ğ‘ ğ‘˜1, and the regenerated secret key is close
to the previous one, e.g., ğ‘‘ğ‘–ğ‘  (ğ‘ ğ‘˜1, ğ‘ ğ‘˜ (cid:4)
)  ğœ, and S declares that A succeeds and termi-
0
nates the hybrid if ğ‘‘ğ‘–ğ‘  (ğ‘ ğ‘˜0, ğ‘ ğ‘˜ (cid:4)
0
(6) At the end of this hybrid, S outputs 1 if and only if A succeeds.
Let ğ‘ be a choice bit defined in Equation.1. If ğ‘ = 0, then the view
of A in the above execution with S is identical to the view of A
in Hy.4. If ğ‘ = 1, the view of A in the above execution with S is
(cid:2)
identical to the view of A in Hy.5. Thus, this claim holds.
) < ğœ.
ğ‘—
Hy.6. We modify ğ‘†ğ‘’ğ‘›ğ‘‘1 (P
1
, ğ‘ğ‘˜0) between incompatible users
before a ğ¶ğ‘œğ‘Ÿğ‘Ÿğ‘¢ğ‘ğ‘¡ query, where the public key ğ‘ğ‘˜0 is generated
by taking as input an incorrect secret key ğ‘ ğ‘˜0, and the output of
ğ‘—
ğ‘†ğ‘’ğ‘›ğ‘‘1 (P
â†
1
{0, 1}â„“
, ğ‘˜ âˆ—
1
, ğ‘ğ‘˜0) is proceeded in a similar manner. Thus,
â† {0, 1}âˆ—, we set the session keys ğ‘˜ âˆ—
0
, ğ‘ğ‘˜0) is ğ‘ğ‘˜
ğ‘—
. ğ‘†ğ‘’ğ‘›ğ‘‘1 (P
1
1
Claim 6.
|Adv
Hy5
A
(ğœ†) âˆ’ Adv
Hy6
A
(ğœ†)| is negligible.
Proof. This proof is implied by Claim 2, the difference is that
the dummy ğ‘ğ‘˜
1 here is sampled from a uniform distribution, but in
Claim 2 it is computed by inputting a random secret key. Thus, we
(cid:2)
omit the redundant analysis here.
Hy.7. The secret keys/public keys are not known at the beginning,
but just at the corruption time or to check whether A wins when
A guesses the correct secret key at the very end only.
ğ‘—
, P
1
.
ğ‘—
, P
1
â€¢ ğ¸ğ‘¥ğ‘’ğ‘ğ‘¢ğ‘¡ğ‘’ (Pğ‘–
0
): S randomly selects Â¯ğ‘0 (vs. Â¯ğ‘1) from a uniform
distribution. If they are compatible, they are given the same
random session key ğ‘˜0 = ğ‘˜1. Otherwise, they are given two
independent random keys ğ‘˜0, ğ‘˜1 â† {0, 1}â„“
â€¢ ğ‘†ğ‘’ğ‘›ğ‘‘0 (Pğ‘–
0
) implies that the instance of Pğ‘–
0 initiates an execu-
tion of BAKE, and S selects a random ğ‘ ğ‘˜ğ‘– from SK and calculates
the public key ğ‘ğ‘˜ğ‘– â† AFEM.PubGen(ğ‘ ğ‘˜ğ‘– ).
ğ‘—
, ğ‘ğ‘˜0) (vs. ğ‘†ğ‘’ğ‘›ğ‘‘1 (Pğ‘–
â€¢ ğ‘†ğ‘’ğ‘›ğ‘‘1 (P
, ğ‘ğ‘˜1)) simulates the behavior of
0
1
1 (vs. Pğ‘–
0) before a corruption. S selects the secret key ğ‘ ğ‘˜1
P
(vs. ğ‘ ğ‘˜0), and randomly selects a public key ğ‘ğ‘˜1 â† {0, 1}âˆ— (vs.
ğ‘ğ‘˜0 â† {0, 1}âˆ—). Otherwise, S selects ğ‘ ğ‘˜1 (vs. ğ‘ ğ‘˜0) and sets ğ‘ğ‘˜1 â†
AFEM.PubGen(ğ‘ ğ‘˜1) (vs. ğ‘ğ‘˜0 â† AFEM.PubGen(ğ‘ ğ‘˜0)).
ğ‘—
â€¢ ğ‘†ğ‘’ğ‘›ğ‘‘2 (Pğ‘–
0
ğ‘—
, ğ‘1) (vs. ğ‘†ğ‘’ğ‘›ğ‘‘2 (P
1
, ğ‘0)) simulates the behavior of Pğ‘–
0
ğ‘—
1 ) in the following cases.