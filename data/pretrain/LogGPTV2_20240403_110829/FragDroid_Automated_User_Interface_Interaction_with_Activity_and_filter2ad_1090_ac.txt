404
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:48:55 UTC from IEEE Xplore.  Restrictions apply. 
and Java reﬂection mechanism. The Java reﬂection mechanism
offers the functionality of obtaining all inside information of
a known class, such as ﬁelds and methods, and it allows
to invoke any ﬁeld or method of a given object. With the
aid of reﬂecting the FragmentManager class in the target
Activity, the corresponding FragmentTransaction class
could be constructed. The sub-classes of Fragment involved
in the current Activity will be instantiated on Java Virtual
Machine by reﬂection, and then they are ﬁlled into the cor-
responding switch functions of FragmentTransaction
class. Finally the transition between Fragments could be
implemented by executing the method commit in the
FragmentTransaction class. Besides, if a new Fragment
could be visited through a clicking event, this explicit clicking
process will take the place of the implicit reﬂection mechanism
and is set as the initial operation for transition during element
generations.
Case 3 – Reaching a visited interface. If the testing app
reaches a visited interface, FragDroid will complete the input
ﬁelds and get all coordinates of the controls that can be clicked
on this interface. Then, clicking events will be injected by
FragDroid from top to bottom, from left to right automatically.
A clicking event may lead to the following situations: if the
interface doesn’t change, the clicking operation will move on;
if a dialog box or a menu pops up, it will be removed by
clicking on blank space and continues the clicking operation; if
the interface changes, the new interface will be terminated by
killing current execution and the testing app will be restarted
and execute under the click operation until all clicking events
are completed; if the app crashes, the testing app will be
restarted to the current interface and execute under clicking
operations.
B. Queue Generation & Test Case Generation
For the whole evolutionary test, the UI transition queue
is maintained on the basis of AFTM in a width-ﬁrst strat-
egy. Each dynamically generated item in the queue is the
information on the transition from one interface to another.
This procedure can be divided into two core modules – queue
update and test case generation.
In the beginning, FragDroid uses the original AFTM to ini-
tialize the UI transition queue. In the UI transition queue, the
data structure of each UI queue item contains four properties:
the way of reaching a certain interface (Activity or Fragment),
start interface, target interface, and an operation list storing
the concrete operations from the start interface to the target
interface. Once AFTM is updated, the queue will also be
updated.
The test case generation module transforms the items in
the UI queue into executable test cases. The template of
test case based on the library of Robotium is accomplished
with the information inside the items. One of the most
difﬁcult parts is to generate the test case of mandatory
switching to hidden or unvisited Fragments. In the pro-
cess of translating the operation list into Java code for test
cases,
if no explicit operation can be used for interface
the target Fragment belongs to,
the Java reﬂection mechanism will be utilized.
transition,
The concrete process of reﬂection is to reﬂect the Activity
class that
then determine
whether there exists getSupportFragmentManager()
or getFragmentManager() in that
class. Respec-
tively, the Activity inherits from android.app.Activity
or android.support.v4.app.Activity. The cor-
responding FragmentManager is obtained to execute
beginTransaction() and reﬂect the Fragment classes
to switch. Finally, the switching function is constructed and
executed with the Fragment container’s resource-ID.
C. Test Termination Condition
As shown in Figure 4, FragDroid generates items for the
UI queue based on AFTM. After that, the items are further
compiled to test cases and executed for dynamic testing. The
state information is extracted from the testing results to update
AFTM. The update of AFTM triggers the next round of
execution. Once the UI transition queue is empty, and AFTM
is no longer updated, it means all test cases have been tested,
that is the end of the loop.
To achieve a higher coverage rate and avoid omission, if
there are Activities that haven’t been visited (according to the
ﬁnal AFTM), FragDroid will forcibly invoke them through
empty Intents. If the invocation succeeds, these Activities will
be added into AFTM with normal processing as the second
loop phase. When this loop stops (empty UI queue and no
update for AFTM), the whole test terminates.
VII. EXPERIMENT AND EVALUATION
We have implemented a full-featured prototype of Frag-
Droid and carried out a series of experiments. Our experiments
primarily concentrate on the effectiveness of our framework.
Also, to better illustrate the practicability of our framework,
we choose the sensitive API call analysis as a showcase.
A. Dataset
We downloaded and analyzed 217 popular apps (more than
500,000 downloads) from 27 categories of Google Play. The
categories include Tools (21 apps), Entertainment (21 apps),
News Magazine (16 apps), Business Ofﬁce (15 apps), Books
and Reference (14 apps), etc. The preliminary code analysis
discovered 91% of them use Fragment components.
However, since some apps were encrypted or protected (with
packer), they cannot be analyzed and have to be ruled out in
the dependency extraction phase. Also, some apps failed in the
dynamic testing due to the issues of permissions. Nevertheless,
these problems are out of the scope of our framework, so
not all apps were considered in the experiment. Finally, we
selected 15 apps from these 217 apps for further analysis.
B. Coverage
In total, FragDroid successfully covered 66% Fragments and
71.94% Activities. Table I shows the coverage rate of Frag-
Droid in aspects of Activities, Fragments, and the Fragments
in visited Activities. In this table, each data column consists
405
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:48:55 UTC from IEEE Xplore.  Restrictions apply. 
TABLE I: Coverage of Activities and Fragments Detection
Rate
Visited
Sum
Fragments
Fragments in Visited Activities
Visited
Sum
Rate
Package Name*
au.com.digitalstampede.formula
com.adobe.reader
com.advancedprocessmanager
com.aircrunch.shopalerts
com.c51
com.cnn.mobile.android.phone
com.happy2.bbmanga
com.inditex.zara
com.mobilemotion.dubsmash
com.ovuline.pregnancy
com.weather.Weather
com.where2get.android.app
imoblife.toolbox.full
net.aviascanner.aviascanner
org.rbc.odb
Downloads
50,000+
100,000,000+
10,000,000+
1,000,000+
5,000,000+
10,000,000+
1,000,000+
10,000,000+
100,000,000+
1,000,000+
50,000,000+
500,000+
10,000,000+
1,000,000+
1,000,000+
Activities
Visited
Sum
1
7
5
7
28
16
2
7
10
17
13
9
14
7
4
2
5
10
13
3
10
5
15
3
37
1
8
9
4
8
* All APKs are available on Google Play Store
50.00%
53.85%
71.43%
70.00%
80.00%
69.57%
40.00%
77.78%
90.91%
62.96%
76.47%
56.25%
100.00%
100.00%
80.00%
2
13
7
10
35
23
5
9
11
27
17
16
14
7
5
2
5
10
8
2
3
3
7
0
8
1
4
8
4
5
Rate
100.00%
100.00%
100.00%
61.54%
66.67%
30.00%
60.00%
46.67%
0.00%
21.62%
100.00%
50.00%
88.89%
100.00%
62.50%
1
2
10
4
2
2
0
2
0
8
1
0
4
4
2
1
2
10
6
3
4
2
10
3
26
1
4
5
4
3
100.00%
100.00%
100.00%
66.67%
66.67%
50.00%
0.00%
20.00%
0.00%
30.77%
100.00%
0.00%
80.00%
100.00%
66.67%
of three sub-columns: Visited, Sum, and Rate. The data of the
“Visited” column records the number of the corresponding
elements (e.g., Activities) successfully tested by FragDroid
on each app; the column “Sum” summarizes the number of
such elements discovered in the phase of Static Information
Extraction, and the column “Rate” lists the ratio of visited
elements in all elements (i.e., the coverage rate) on a certain
level. Taking the category of Fragments in Visited Activities as
an example, it shows the result of testing apps via FragDroid
on the level of Fragments in Activities that are visited by
FragDroid, including the number of visited Fragments in tested
Activities, the number of all Fragments in tested Activities and
the percentage of visited Fragments in all Fragments in tested
Activities.
1) Activity Coverage Analysis: Activities are the primary
containers for UI layouts, and Fragments cannot live without
Activities. Although our analysis focus is not the level of
Activities but the level of Fragments, exploring more Activities
could lead to a higher coverage rate for Fragments. The list of
Activities of an app is extracted from its Manifest ﬁle during
the static analysis, and the isolated ones (which cannot be
switched to/from other interfaces) are excluded. FragDroid
gives the number of visited Activities and logs all visited
Activities.
However, there are some situations that decrease coverage
rate of FragDroid for Activities.
• Current developers usually use the material design
mode to develop apps, so that
the transition of Ac-
tivities in navigation view drawer cannot be operated
directly [18], such as com.cnn.mobile.android.phone and
com.aircrunch.shopalerts. To solve this problem, we have
applied the mandatory starting in the phase of evolution-
ary test case generation. However, since this operation
does not take the context and Intent into account, some
Activities are still not detected by FragDroid.
• Some Activities require strictly accurate input to move
to the next step. Some special inputs like address names
• There
are
like
apps
are not given manually in advance, as a result, some apps
(such as com.weather.Weather) cannot be tested smoothly.
com.aircrunch.shopalerts,
com.where2get.android.app, and com.inditex.zara, which
have action bars [19], and numerous pop operations are
triggered in the app bars, such as com.adobe.reader.
These operations usually lead to the changes of normal
interfaces and interrupt normal test case generation.
2) Fragment Coverage Analysis: The sum of Fragments is
found by FragDroid is based on the method of getting effective
Fragments introduced previously. Fragments rely on Activities.
A few Activities are inaccessible in some apps, and there
are some related research on the discovery of Activities, as
summarized in Section IX. Since this paper focuses on the
probability of exploring Fragments, our framework FragDroid
implements calculating and logging all
the Fragments of
visited Activities.
3) Fragment
However, there are several Fragments instantiated or loaded
directly without using FragmentManager. In this scenario,
FragDroid cannot determine whether the Fragment is a real
loading, as the failing case com.mobilemotion.dubsmash. Ad-
ditionally, another app com.inditex.zara failed due to the
missing parameters transmitted in the reﬂection mechanism.
in Visited Activity Coverage Analysis: As
discussed above, some of Activities are not accessible for
testing, which means the Fragments involved in such Activities
are also inaccessible. In the experiment, the average coverage
rate of FragDroid for Fragments in visited Activities is more
than 50%, and for a third of tested apps, this coverage rate
has reached 100%. It conﬁrms that the basic test unit of
FragDroid has been speciﬁed from Activity to Fragment.
Furthermore, this framework takes the additional logic caused
by the importing of Fragments into consideration, as a result,
it is of good compatibility with Fragments.
C. Sensitive API Invocation Analysis
The user privacy disclosure in Android is a common con-
cern, caused by the abuse of permissions and the transfer
of sensitive APIs. There are some solutions to solve this
406
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 10:48:55 UTC from IEEE Xplore.  Restrictions apply. 
problem such as native permission management and dynamic
permission reminder in Android 6.0 to remind the users, which
limits the abuse of authority. Nevertheless, most sensitive
operations are allowed by default at the time of installing an