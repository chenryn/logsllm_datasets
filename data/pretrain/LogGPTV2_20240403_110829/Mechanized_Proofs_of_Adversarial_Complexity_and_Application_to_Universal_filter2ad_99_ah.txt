and a module path p where:
Γ ⊢ p : sig S1; module x : M; _ restr _ end
We are going to assume that some kind of subject reduction property
holds for p. More precisely, we assume that:
f-resΓ(p) = (struct st1; module x = m; _ end)
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2557Memory restriction union ⊔
(+all mem\{v1, . . . , vn}) ⊔ (+all mem\{v
′
{v1, . . . , vn} ⊔ {v
m}
(+all mem\{v1, . . . , vn}) ⊔ {v
′
1, . . . , v
′
1, . . . , v
′
m}) = + all mem\({v1, . . . , vn} ∩ {v
′
= {v1, . . . , vn} ∪ {v
m}
= + all mem\({v1, . . . , vn}\{v
′
1, . . . , v
′
1, . . . , v
′
m})
′
1, . . . , v
′
m})
′
m}
′
1, . . . , v
Memory restriction intersection ⊓
(+all mem\{v1, . . . , vn}) ⊓ (+all mem\{v
′
m}
{v1, . . . , vn} ⊓ {v
(+all mem\{v1, . . . , vn}) ⊓ {v
′
1, . . . , v
′
1, . . . , v
′
1, . . . , v
′
m}) = + all mem\({v1, . . . , vn} ∪ {v
′
′
m}
1, . . . , v
′
m}\{v1, . . . , vn}
= {v1, . . . , vn} ∩ {v
= {v
′
1, . . . , v
′
m})
′
m}
′
1, . . . , v
Memory restriction subset ⊑
′
′
m}) = {v
1, . . . , v
′
1, . . . , v
(+all mem\{v1, . . . , vn}) ⊑ (+all mem\{v
′
{v1, . . . , vn} ⊑ {v
m}
′
′
(+all mem\{v1, . . . , vn}) ⊑ {v
m}
1, . . . , v
′
′
m})
{v1, . . . , vn} ⊑ (+all mem\{v
1, . . . , v
′
1, . . . , v
′
m}) ⊆ {v1, . . . , vn})
′
m}
′
1, . . . , v
= {v1, . . . , vn} ⊆ {v
= ⊥
= {v1, . . . , vn} ∩ {v
′
1, . . . , v
′
m}) = ∅
Figure 17: Memory restriction operations and type erasure functions.
and that we have a derivation:
Γ ⊢p
struct st1; module x = m; _ end :
sig S1; module x : M; _ restr _ end
Then, we know that p.x resolves to m, i.e. f-resΓ(p) = m. But we do
not have:
Γ ⊢p.x m : M
The problem is that the sub-module m may use sub-modules de-
clared in st1. Consequently, it is not well-typed in Γ, but in an
extended typing environment, where the sub-module declarations
in st1 (which have types S1) have been added to Γ. For example, we
can have:
st1 = (module z = m0)
m = z
Therefore, we cannot state a subject reduction property for the
module resolution function w.r.t. the typing judgment Γ ⊢p m : M.
Instead, we introduce another typing judgment, noted Γ ⊩ m : M,
which is similar to the typing judgment Γ ⊢p m : M of Figure 13,
but is used to type a module expression in an environment which
has already been typed, while Γ ⊢p m : M is used to type a module
declaration in an environment where some modules have not yet
been fully typed. We postpone its definition to the long version [5].
Using this alternative typing judgment notion, we can state the
subject reduction property we want (the proof is also in [5]).
Lemma C.1 (Subject reduction). If Γ ⊩ E and Γ ⊩ m : M then
Γ ⊩ resE(m) : M whenever resE(m) is well-defined.
D INSTRUMENTED SEMANTICS
We now define the denotational semantics of our programming
language and cost judgments. We quickly introduce the main as-
pects of our semantics below, before defining it formally in the rest
of the section. We use this semantics to state and prove our main
soundness theorem in Appendix E.
ν
Program semantics. The semantics(cid:74)s(cid:75)E, ρ
interpretation ρ of E’s abstract modules. Essentially,(cid:74)s(cid:75)E, ρ
of our language de-
pends on the initial memory ν, the environment E, and on the
is a
discrete distribution over M × N, where the integer component is
the cost of evaluating s in (E, ρ), starting from the memory ν. Then,
the E-cost of an instruction s under memory ν and interpretation
of E’s abstract modules ρ, denoted by costE, ρ
(s) ∈ N ∪ {+∞}, is
the maximum execution cost in any final memory, defined as:
ν
(s) = inf(cid:8)c′ | Pr(cid:0)(_, c) ←(cid:74)s(cid:75)E, ρ
ν
ν
; c ≤ c′(cid:1) = 1(cid:9)
costE, ρ
ν
Judgments semantics. Basically, the judgment E ⊢ {ϕ} s {ψ | t}
states that: i) the memory ν obtained after executing s in an initial
memory ν ∈ ϕ must satisfy ψ; ii) the complexity of the instruction s
is upper-bounded by the complexity of the concrete code in s, plus
the sum over all abstract oracles A.f of the number of calls to A.f
times the intrinsic complexity of A.f . Formally:
(s) ≤ t[conc] + A∈abs(E)
t[A.f ] · complE, ρ
A.f
costE, ρ
ν
f ∈procs(E(A))
where complE, ρ
A.f
i.e. its complexity excluding calls to A’s functor parameters.
is the intrinsic complexity of the procedure A.f ,
Outline of this Section. We present the semantics of our pro-
grams in Appendix D.1. Then, we define the semantics of our cost
judgments. This requires two additional complexity measures: the
number of calls a program execution makes to some abstract proce-
dure, and the intrinsic cost of a program execution (i.e. the cost of
the program without the cost of parameters calls). These additional
complexity measures are defined in Appendix D.2. Finally, we give
the semantics of our cost judgment in Appendix D.3.
s.t. µ is summable and |µ| =
D.1 Semantics
For any set A, we denote by D(A) the set of discrete sub-distributions
over A — i.e. the set of function µ : A → [0, 1] with discrete support
x µ(x) ≤ 1. For x ∈ A, the Dirac
distribution at x is written 1A
x or 1x when A is clear from the context.
Session 10B: Crypto and Protocol Security CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2558Module signature and structure sub-typing ⊢ M1 <: M2 and ⊢ S1 <: S2.
SubSig
⊢ S1 <: S2
⊢ θ1 <: θ2
⊢ sig S1 restr θ1 end <: sig S2 restr θ2 end
We omit the reflexivity and transitivity rules.
SubFunc
⊢ M′
⊢ M <: M′
⊢ func(x : M0) M <: func(x : M′
0 <: M0
0) M′
SubModDecl
⊢ M1 <: M2
⊢ module x : M1 <: module x : M2
T-Abort
Γ ⊢ abort
T-Skip
Γ ⊢ skip
Statements and function paths typing Γ ⊢ s and Γ ⊢ F : _.
T-Seq
Γ ⊢ s1
Γ ⊢ s2
Γ ⊢ s1; s2
T-Assign
Γ ⊢ x : τ
Γ ⊢ e : τ
Γ ⊢ x ← e
SubStruct
∀i ∈ {1; . . . ; n}, ⊢ Di <: D′
⊢ D1; . . . ; Dn <: D′
1; . . . ; D′
i
n
T-Rand
Γ ⊢ x : τ
Γ ⊢ x
Γ ⊢ d : τ
$←− d
T-Call
Γ ⊢ F : proc f ((cid:174)v : (cid:174)τ) → τr
Γ ⊢ x : τr
Γ ⊢ x ← call F((cid:174)e )
Γ ⊢ (cid:174)e : (cid:174)τ
T-Proc1
Γ ⊢ p : sig (S1; proc f ((cid:174)v : (cid:174)τ) → τr ; S2) restr θ end
Γ ⊢ p.f : (proc f ((cid:174)v : (cid:174)τ) → τr)
T-Proc2
Γ(p.f ) = (proc f ((cid:174)v : (cid:174)τ) → τr = _)
Γ ⊢ p.f : (proc f ((cid:174)v : (cid:174)τ) → τr)
T-If
Γ ⊢ e : bool
Γ ⊢ s1
Γ ⊢ s2
Γ ⊢ if e then s1 else s2
Expressions typing Γ ⊢ e : τ.
∀i ∈ {1; . . . ; n}, Γ ⊢ ei : τi
ExprApp
type(f ) = τ1 × · · · × τn → τ
Γ ⊢ f (e1, . . . , en) : τ
Restriction entailment ⊢ θ <: θ′.
We omit the transitivity and reflexivity rules for ⊢ θ <: θ′.
⊑-Proc
∀f ∈ dom(θ, θ
′),⊢ θ[f ] <: θ
′[f ]
⊢ θ <: θ
′
⊑-Split
⊢ λc <: λc′
⊢ λm <: λm′
⊢ λm ∧ λc <: λm′ ∧ λc′
⊑-Top
⊢ λ <: ⊤
T-While
Γ ⊢ e : bool
Γ ⊢ s
Γ ⊢ while e do s
ExprVar
Γ(v) = τ
Γ ⊢ v : τ
⊑-Mem
λm ⊑ λm′
⊢ λm <: λm′
⊑-MemTop
⊢ λc <: ⊤
⊑-Compl
⊢ compl[intr : k, x1.f1 : k1, . . . , xn .fn : kn] <: compl[intr : k
∀i, ki ≤ k
k ≤ k
′
i
′
Memory restriction.
′
, x1.f1 : k
′
1, . . . , xn .fn : k
′