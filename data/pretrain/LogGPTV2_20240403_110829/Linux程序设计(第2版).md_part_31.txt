TAB制表符延时选择。
·BSDLY
Backspace后退字符延时选择。
·VTDLY
垂直制表符延时选择。
·FFDLY
换页符延时选择。
如果OPOST标志浸有被设置，所有其他标志都将被忽略。
用到输出模式的情况也不是很多，所以我们也不在此做过多的讨论。
5.3.3控制模式
控制模式控制着终端的硬件特性。.我们通过设置termios结构里c_cflag成员中的标志对控制
模式进行配置。其中包括以下这些标志宏：
·CLOCAL
忽略一切调制解调器状态行。
·CREAD
激活字符接收回执功能。
· CS5
在发送和接收字符时使用五个二进制位。
· CS6
在发送和接收字符时使用六个二进制位。
·CS7
在发送和接收字符时使用七个二进制位。
在发送和接收字符时使用八个二进制位。
加入jaVa编程群：524621833
---
## Page 159
第5章终
141
·CSTOPB
每个字符使用两个而不是一个停止位。
·HUPCL
关闭操作时挂断调制解调器。
•PARENB
激活校验码的生成和检测功能。
·PARODD
使用奇校验而不是偶校验。
如果HUPCL标志被置位，在终端器动程序检测到与终端对应的最后一个文件描述
符被关闭的时候它会设置调制解调器的控制线挂断电话线路。
虽然控制模式也可以用来与终端进行“对话”。但它更主要地是用在串行线连接到一台调制
解调器上的情况里。一般说来，与使用termios的控制模式来改变缺省的线路连接行为相比，改
变终端的配置情况更容易一些。
5.3.4本地模式
本地模式控制着终端的许多特性。我们通过设置termios结构里c_Iflag成员中的标志对本地
工作模式进行配置，所用的标志宏有：
·ECHO
激活输人字符的本地回显功能。
·ECHOE
在接收到ERASE时执行后退、空格、后退动作组合。
·ECHOK
在接收到KILL字符时执行行删除动作。
ECHONL
回显换行字符。
NONVI.
激活授权输人处理（参见下面的说明）。
·IEXTEN
激活实现特定的函数功能。
DISI·
激活信号。
·NOFLSH
禁止清空队列的动作。
·TOSTOP
在试图进行写操作之前给后台进程发送一个信号。
这里，最常用的两个标志是ECHO和ICANON，前者的作用是强制回显用户敲入的字符；后
者的作用是在两个明显不同的接收字符处理模式之间对终端进行切换。如果ICANON标志被置
位，就表示该输人行是处于授权处理模式；否则，输人行处于非授权模式。
我们将在遇到能够用在这两种工作模式里的特殊控制字符时对授权和非授权模式做详尽的
解释。
5.3.5特殊的控制字符
这是一些通过键盘上的组合键得到的字符集合，比如“Curl-C”等。当用户输人它们的时候，
终端会采取一些特殊的动作来响应。这些由组合键输人的特殊字符通常被映射到相应的函数上
去，在termios结构的c_cc数组成员里包含着映射到各个函数的特殊字符。每个字符的位置（它
在数组里的下标）是由一个宏定义的，但并不要求它们必须是控制字符。
根据终端是否被设置为授权模式（即termios结构的c_lflag成员中的ICANON标志是否被置
位）、c_cc数组有两种差别很大的不同用法。
加入jaVa编程群：524621833
---
## Page 160
142
Linux程序设计
在这两种不同的模式里，数组下标值的使用方法有--定的重叠性，认清这一点是很重要的。
既然存在这样的情况，就一定要注意别把两种模式各自的下标值弄混了。
授权模式里使用的数组下标有：
·VEOF
EOF字符。
·VEOL
EOL字符。
·VERASE
ERASE字符。
•VINTR
INTR字符。
.VKILL
KILL字符。
·VQUIT
QUIT字符。
·VSUSP
SUSP字符。
•VSTART
START字符。
·VSTOP
STOP字符。
非授权模式里使用的数组下标有：
·VINTR
INTR字符。
·VMIN
MIN值。
·VQUIT
QUIT字符。
·VSUSP
SUSP字符。
•VTIME
TIME值。
•VSTART
START字符。
·VSTOP
STOP字符。
这些特殊字符和非授权模式里的MIN与TIME值对输人字符的高级处理功能来说意义非常重
要，我们对它们做一番认真研究。
1.字将
表5-3
兹本
说明
INTR
这个字符将引起终端驱动程序向与终端相连接的进程发送一个SIGINT信号。我们将
在第10章对信号做造一步介绍
QUTT
这个学游将引起终端氯动程序向与终端相连接的进程发送一个SIGQUIT信号
ERASE
这个字将使终端靶动程序剧除输人行中的最后一个字符
KILL
这个字符将使终端驱动程序删除整个输人行
EOF
这个字符将使终端驱动程序把输人行上的全部字符传递给读取输人的应用程序。如
果输人行是空的，read调用将返国零个字符，就好象read试图读文件尾一样
EOL
这个字符就象是一个输人行结束字符、和经常使用的换行符效果相同
SUSP
这个字符将引起终端醒动程序向与终端相连接的进程发送一个SIGSUSP信号。如果
读者的UNIX支持作业控制功能，当前应用程序就会被挂起
STOP
这个字符对应的动作是“截流”，即不再向终端输出任何字符。它被用来支持
XON/XOPF演控制，通常被设置为ASCHI的XOFF字符，“CrI-S”组合键
START
这个字符重新开启被STOP学符截流的输出，通常被设置为ASCII的XON字符
加入jaVa编程群：524621833
---
## Page 161
第5章终
143
2.TIME和MIN值
TIME值和MIN值只能用在非授权模式里，两者结合起来对输人的读取操作进行控制。此外，
如果两者一起使用，还能够控制程序试图读与某个终端相关联的一个文件描述符时将会发生怎
样的事情。
这两个值能够构成四种情况，它们是：
MIN = 0 和 TIME = 0
在这种情况下，read调用将立刻返回。如果有等待处理的字符，它们就会被返回；如果没有
可供处理的字符，read就会返回零，并且没有任何字符被读取。
MIN = 0 和 TIME > 0
在这种情况下，只要字符一出现，或者经过TIME个十分之一秒的时间间隔之后，read调用
就会立刻返回。如果因为超时而没有读到任何字符，read将返回零。否则它将返回读人的字符
个数。
MIN > 0 和 TIME = 0
在这种情况下，read将等到至少有MIN个字符可以被读取时才开始进行读操作，返回的也将
是MIN个字符。到达文件尾时返回零。
MIN > 0 和 TIME > 0
这是最复杂的情况。当read被调用的时候，它会等待接收一个字符，在接收到第一个字符及
后续的各个字符时，会启动一个字符时间间隔计时器（如果计时器已经启动，就重启它）。read
会在MIN个字符准备好或者两个字符之间的时间间隔超过TIME个十分之一秒时返画。它可以用
来区分“单独按下了Escape键”和“功能键转义序列的开始”这两种情况，是很有用的功能。
但网络通讯或高处理器负荷会把这种精细的时间安排清除掉，这一点请大家多多注意。
通过设置非授权模式与使用MIN值和TIME值，程序可以逐个字符地对输人进行处理。
3.从shell里访问终端的工作模式
如果读者在使用shell的时候想查看一下当前的termios设置值，可以用下面的命令得到一个
清单：
S atty -a
在我们的Linux系统上（它对标准的termios结构做了些扩展）这个命令的输出如下所示：
speed 38400 baud: rows 25+colunns 80; 1ine = 0;
intr=*C;quit =^\;erase^?;kil1sU;eof=D;eol=;
lnext =*V;flush=~0:min = 1;time ± 0;
parenb -parodd cs8 hupc1 -cstopb cread -c1oca1-crtscts
opost -olcuc -ocrnl onlcr -onocr -onlret-ofil1 -ofdel n10 cr0 tab0 bs0 vt0 ff0
isig icanon -iexten echo echoe echok -echonl -noflsh -xcsse -tostop -echoprt
ecboctl echoke
加入jaVa编程群：524621833
---
## Page 162
144Linux程序设计
在读者做终端控制练习的时候，很容易把终端搞成一个非标准状态，再要想使用它可就费劲了。
下面几个办法能够帮你摆脱这种困境。
使用下面的命令一这要求你的stty命令版本支持这种用法：
S stty sane
如果你把回车键与换行符（用来结束命令行）之间的映射关系搞乱了，就必须先敲人“sity
sane”，然后按下“Ctrl-J”组合键（这个组合键对应着换行符），而不是回车键。
第二种办法是先用“stty-g”命令把stty的当前设置值都保存起来，在必要的时候再从文件
里把原始设置值读出米进行恢复。命令行上的具体命令如下所示：
$ stty $(cat save_atty)
最后一条stty命令还是必须用“Ctrl-J”组合键来代替回车键。在shell脚本程序里也可以使用
同样的技巧：
(5- 
stty Ssave_stty
如果这些招数都不管用，还有第三个办法：到另外一台终端去，用ps命令找到被弄乱了的
提示符之前重置stty参数，所以你将能够在stty的初始设置情况里重新登录上机。
4.从命令提示符对终端的工作模式进行设置
stty命令还可以用来从命令行提示符处直接对终端的工作模式进行设置。
比如说，如果我们想在自己的shell脚本程序里把终端设置成“能够读取单字符输人”这样
一种工作模式，就需要关闭授权模式，把MIN设置为“1”，把TIME设置为“0”。这个命令如下
所示：
$ stty -1canon min 1 time 0
既然已经把终端设置成“立即读字符”了，我们再运行我们的第一个程序menul来看看会是
怎样的情况。你会发现它是按我们预想的路线前进的。
我们还可以对第2章里的口令字检查程序加以改进，在提示输人口令字之前把回显功能关闭
掉。这个命令如下所示：
S stty -echo
注意在实践之后用“sttyecho”命令把回显功能设置回开启状态。
5.3.6终端的速度
termios结构提供的最后一个功能是对线速度进行操控。termios结构里并没有与终端的数据
传输速度对应的数据成员，它是通过函数调用对它进行设置的。输人和输出速度是分开处理的：
加入jaVa编程群：524621833
---
## Page 163
第5章终端
145
下面是四个有关函数的定义：
#include 
speed.t cfgetiepeed（const struct termios *);
Int cfsetispeed（struct termios *,speed_t speed);
speed_t cfgetonpeed（const struct termios *):
int cfsetoupeed（struct termios *,speed_t speed);
注意，这些函数是对termios结构进行操作的，不育接作用于通信端LI。这就意味若要想设
置一个新的速度，就必须先用tcgetaitr函数读出当前设置值，用上面四个函数之-·设置好新速度，
再用tcsetatr函数写回termios结构。只有在tcsetanr函数结束之后，线速度才会改变、
上面四个函数中的speed参数允许使用各种各样的值，其中最重要的是：
•B0
挂断终端。
• B1200
1200波特。
·B2400
2400波特。
·B9600
9600波特。
• B19200
19200波特。
·B3840038400波特。
有关标准没有定义大于38400的速度，也没有支持串行口工作在这个速度以上的标准方法。