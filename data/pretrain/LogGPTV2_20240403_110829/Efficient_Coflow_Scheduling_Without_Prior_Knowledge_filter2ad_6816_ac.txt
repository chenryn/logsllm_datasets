…0∞Highest-PriorityQueueLowest-PriorityQueueQKQ2Q1FIFOFIFOFIFOE0Q1hiE0Q1hi1EQ1hiEK-2Q1hi397On-Arrival Knowledge
Coﬂow Size Information
Number of Queues (K)
Queue Thresholds
Queue Scheduling
Coﬂow Scheduling in Each Queue
Flow Scheduling
Work Conservation
Starvation Avoidance
HOL Blocking Avoidance
Orchestra [19]
Clairvoyant
Global
One
N/A
N/A
FIFO
WSS
Next Coﬂow
Varys [20]
Clairvoyant
Global
Num Coﬂows
Exact Size
Strict Priority
N/A
MADD
Next Queue
Promote to Q1
N/A
Baraat [25]
Non-clairvoyant
Local
One
N/A
N/A
FIFO
Max-Min
Next Coﬂow
Aalo
Non-clairvoyant
Global Approx.
logE(Max Size)
i+1 = E × Qhi
Qhi
Weighted
i
FIFO
Max-Min
Weighted Among Queues
N/A
N/A
Table 1: Qualitative comparison of coﬂow scheduling algorithms. Typically, E = 10 for D-CLAS.
Multiplexing
Multiplexing
N/A
N/A
Pseudocode 1 D-CLAS Scheduler to Minimize CCT
1: procedure RESCHEDULE(Queues Q, ExcessPolicy E(.))
2: while Fabric is not saturated do
3:
4:
5:
6:
7:
8:
9: end procedure
for all i ∈ [1, K] do
for all Coﬂow C ∈ Qi do
for all Flow f ∈ C do
f.rate = Max-min fair share
Update Qi.share based on f.rate
Distribute unused Qi.share using E(.)
(cid:46) Sorted by CoﬂowId
(cid:46) Fair schedule ﬂows
(cid:46) Work conserv.
(cid:46) Allocate
11: W =(cid:80) Qi.weight
10: procedure D-CLAS
for all i ∈ [1, K] do
12:
13: Qi.share = Qi.weight / W (cid:46) Weighted sharing b/n queues
14:
15: end procedure
reschedule(Q, Max-Min among Qj(cid:54)=i)
among queues, where queue weights decrease with lowered
priority; i.e., Qi.weight ≥ Qi+1.weight at line 13 in Pseu-
docode 1. Excess share of any queue is divided among unsat-
urated queues in proportion to their weights using max-min
fairness (line 14).
Within each queue, it uses FIFO scheduling (line 4) so
that coﬂows can proceed until they reach queue threshold or
complete. Minimizing interleaving between coﬂows in the
same queue minimizes CCTs, and large coﬂows are pre-
empted after crossing queue thresholds. Hence, D-CLAS
does not suffer from HOL blocking. As mentioned earlier,
without prior knowledge, ﬂows within each coﬂow use max-
min fairness (line 6).
Starvation Avoidance Given non-zero weights to each
queue, all queues are guaranteed to make progress. Hence,
D-CLAS is starvation free. We did not observe any perpetual
starvation in our experiments or simulations either.
4.5 Summary
Table 1 summarizes the key characteristics of the sched-
ulers discussed in this section. D-CLAS minimizes the av-
erage CCT by prioritizing signiﬁcantly different coﬂows
across queues and FIFO ordering similar coﬂows in the same
queue. It does so without starvation, and it approximates
FIFO schedulers for light-tailed and priority schedulers for
heavy-tailed coﬂow distributions.
(a) Query Plan
(b) Dependencies
(c) CoﬂowIDs
Figure 4: Coﬂow dependencies in TPC-DS query-42 [6]: (a)
Query plan generated by Shark [48]; boxes and arrows respectively
represent computation and communication stages. (b) Finishes-
Before relationships between coﬂows are represented by arrows.
(c) CoﬂowIds assigned by Aalo.
5 Handling Uncertainties
So far we have only considered “ideal” coﬂows from single-
stage, single-wave jobs without task failures or stragglers.
In this section, we remove each of these assumptions and
extend the proposed schedulers to perform well in realistic
settings. We start by considering multi-stage dataﬂow DAGs
(§5.1). Next, we consider dynamic coﬂow modiﬁcations due
to job scheduler events like multi-wave scheduling and clus-
ter activities like restarted and speculative tasks (§5.2).
5.1 Multi-Stage Dataﬂow DAGs
The primary concern in coﬂow scheduling in the context of
multi-stage jobs [30, 50, 3, 2] is the divergence of CCT and
job completion time. Minimizing CCTs might not always
result in faster jobs – one must carefully handle coﬂow de-
pendencies within the same DAG (Figure 4).
We deﬁne a coﬂow CF to be dependent on another coﬂow
CE if the consumer computation stage of CE is the producer
of CF . Depending on pipelining between successive compu-
tation stages, there can be two types of dependencies.
1. Starts-After (CE (cid:55)−→ CF ): In presence of explicit barri-
2. Finishes-Before (CE −→ CF ): With pipelining between
successive stages [30, 22], CF can coexist with CE but
it cannot ﬁnish until CE has ﬁnished.
ers [2], CF cannot start until CE has ﬁnished.
Note that coﬂows in different branches of a DAG can be un-
CA!CB!CC!CD!CE!CF!Input1!Input2!Input3!Output!CA!CB!CC!CD!CE!CF!C42.1!C42.1!C42.1!C42.2!C42.3!C42.4!CA!CB!CC!CD!CE!CF!Input1!Input2!Input3!Output!CA!CB!CC!CD!CE!CF!C42.1!C42.1!C42.1!C42.2!C42.3!C42.4!CY!CZ!CY Finishes-Before CZ!CA!CB!CC!CD!CE!CF!Input1!Input2!Input3!Output!CA!CB!CC!CD!CE!CF!C42.1!C42.1!C42.1!C42.2!C42.3!C42.4!CY!CZ!CY Finishes-Before CZ!C42.0!398(cid:46) Initialization
Pseudocode 2 Coﬂow ID Generation
1: NextCoﬂowID = 0
2: procedure NEWCOFLOWID(CoﬂowId pId, Coﬂows P)
if pId == Nil then
3:
newId = NextCoﬂowID++
4:
return newId.0
5:
else
6:
sId = 1 + max
7:
return pId.sId
8:
9: end procedure
C∈P C.sId
(cid:46) Unique external id
(cid:46) Ordered internal id
related to each other.
Job schedulers identify coﬂow dependencies while build-
ing query plans (Figure 4a). They can make Aalo aware of
these dependencies all at once, or in a coﬂow-by-coﬂow ba-
sis. Given coﬂow dependencies, we want to efﬁciently sched-
ule them to minimize corresponding job completion times.
We make two observations about coﬂow dependencies.
First, coﬂows from the same job should be treated as a sin-
gle entity. Second, within each entity, dependent coﬂows
must be deprioritized during contention. The former ensures
that minimizing CCTs directly affect job completion times,
while the latter prevents circular dependencies. For example,
all six coﬂows must complete in Figure 4a, and dependent
coﬂows cannot complete without their parents in Figure 4b.
We simultaneously achieve both objectives by encod-
ing the DAG identiﬁer and internal coﬂow dependencies
in the CoﬂowId. Speciﬁcally, we extend the CoﬂowId with
an internal component in addition to its external compo-
nent (Pseudocode 2). While the external part of a CoﬂowId
uniquely identiﬁes the DAG it belongs to, the internal part
ensures ordering of coﬂows within the same DAG (Fig-
ure 4c). Our schedulers process coﬂows in each queue in the
FIFO order based on their external components, and they
break ties between coﬂows with the same external compo-
nent using their internal CoﬂowIds (line 4 in Pseudocode 1).
Note that optimal DAG scheduling is NP-hard (§9). Our
approach is similar to the Critical-Path Method [33] and re-
solves dependencies in each branch of a DAG, but it does
not provide any guarantees for the entire DAG.
5.2 Dynamic Coﬂow Modiﬁcations
A ﬂow can start only after its source and destination tasks
have been scheduled. Tasks of large jobs are often scheduled
in multiple waves depending on cluster capacity [11]. Hence,
ﬂows of such jobs are also created in batches, and waiting
for all ﬂows of a stage to start only halts a job. Because the
number of tasks in each wave can dynamically change, Aalo
must react without a priori knowledge. The same is true for
unpredictable cluster events like failures and stragglers. Both
result in restart or replication of some tasks and correspond-
ing ﬂows, and Aalo must efﬁciently handle them as well.
Aalo can handle all three events without any changes to its
schedulers. As long as ﬂows use the appropriate CoﬂowId,
how much a coﬂow has sent always increases regardless of
multiple waves and tasks being restarted or replicated.
6 Design Details
We have implemented Aalo in about 4, 000 lines of Scala
code that provides a pipelined coﬂow API (§6.1) and imple-
ments (§6.2) the proposed schedulers.
6.1 Pipelined Coﬂow API
Aalo provides a simple coﬂow API that requires just
replacing
AaloOutputStream.
Any InputStream can be used in conjunction with
AaloOutputStream. It also provides two additional meth-
ods for coﬂow creation and completion – register() and
unregister(), respectively.
OutputStreams with
The InputStream-AaloOutputStream combination is
non-blocking. Meaning, there is no artiﬁcial barrier after
a coﬂow, and senders (receivers) start sending (receiving)
without blocking. As they send (receive) more bytes, Aalo
observes their total size, perform efﬁcient coﬂow scheduling,
and throttles when required. Consequently, small coﬂows
proceed in the FIFO order without coordination overhead.
The entire process is transparent to applications.
Usage Example Any sender can use coﬂows by wrapping
its OutputStream with AaloOutputStream.
For example, for a shufﬂe to use Aalo, the driver ﬁrst reg-
isters it to receive a unique CoﬂowId.
val sId = register()
Note that the driver does not need to deﬁne the number of
ﬂows before a coﬂow starts.
Later, each mapper must use AaloOutputStream
for
sending data. One mapper can create multiple
AaloOutputStream instances, one for each reducer con-
nection (i.e., socket sock), in concurrent threads.
val out = new AaloOutputStream(sock, sId)
Reducers can use any InputStream instances to receive
their inputs. They can also overlap subsequent computation
with data reception instead of waiting for the entire input.