(cid:12)(cid:12)(cid:12)(cid:12) = negl(λ) .
Advadaptc-h
A,SFPK (λ) =
adaptC-H
A
SFPK,R(λ) = 1
= (g1, gx·a−1
(cid:48)
) as this unique representative. We will call pk
In some applications it might be required that every equivalence class has a unique representative
that can act as a description of the class. For example let the public keys be of the form pk = (ga
1 , gx
1 )
and let the classes be induced by the relation Rexp. Since g1 is publicly known, we can deﬁne
(cid:48)
pk
a canonical representative. The
canonical representative can be scheme speciﬁc but using a publicly known element (in this case g1)
to ﬁx the ﬁrst element of the public key allows to ﬁx the structure of the representatives over all
equivalence classes. Later, we will assume that if a scheme has canonical representatives, there is an
eﬃcient algorithm IsCanonical which on input a public key will return 1 if and only if the public key
is canonical.
1
We further deﬁne the following useful property between signatures on equivalence classes and
signatures with ﬂexible public keys.
Deﬁnition 24 (SPS-EQ/SFPK Compatibility). An SPS-EQ scheme and an SFPK scheme are
compatible if the message space of the former is the same as the key space of the latter and they
share the same equivalence relation.
4.1 Our Signatures with Flexible Public Key
In this section we propose our signatures with ﬂexible public key. We propose a scheme that is closely
related to the ones proposed in [6]. However, security relies on the bilinear decisional Diﬃe-Hellman
assumption instead of the decisional linear assumption. This allows us to decrease the size of the
public key by 1 group element in G1, i.e. from 3 to 2. Unlike the schemes in [6], this scheme only has
adaptive class-hiding with key corruption but this is still suﬃcient for group signatures construction.
In our scheme we assume that both the SFPK.KeyGen and SFPK.TKeyGen output a public key
that is the canonical representative of its equivalence class. Further we assume that every user
has access to a collision resistant hash function H, which we express by including it in the output
of SFPK.CRSGen. The SFPK.ChgPK and SFPK.ChgSK algorithms work by drawing uniformly at
random an exponent r ∈ Zp and raising every component of the public key, or respectively the
secret key to the power of r. More details can be found in Scheme 2.
18
SFPK.CRSGen(1λ)
BG ←$ BGGen(λ); y, z ←$ Z∗
KPHF ←$ PHF.Gen(1λ)
Y1 ← gy
return (ρ := (BG, Y1, Y2, KPHF, ˆg, H),
1 ; Y2 ← gy
2 ; ˆg ← gz
p
1
SFPK.ChkRep(δSFPK, pkSFPK)
pkSFPK = (pk1, pk2); τSFPK = (τ )
if e(pk1, τ ) = e(pk2, g2)
return 1 else 0
SFPK.KeyGen(1λ)
x ←$ Z∗
return (pkSFPK := (g1, gx
p
1 ),
SFPK.TKeyGen(1λ)
x ←$ Z∗
return (pkSFPK := (g1, gx
p
1 ),
skSFPK := (Y x
1 , pkSFPK))
skSFPK := (Y x
1 , pkSFPK),
τSFPK := (gx
2 ))
δρ := (y, z))
SFPK.Sign(sk, m)
SFPK ← gr
SFPK||Sig3
skSFPK = (Z, pkSFPK);
r, s ←$ Z∗
p; Sig2
h ← H(m||Sig2
M ← gh
return (Z · (PHF.Eval(KPHF, M ))r, gr
1 ; Sig3
SFPK||pkSFPK)
SFPK ← gr
1 · ˆgs
2
1 , gr
2 , s)
SFPK.Verify(pkSFPK, m, SigSFPK)
pkSFPK = (·, X); SigSFPK = (Sig1
h ← H(m||Sig2
if e(Sig2
e(Sig1
return 1 else 0
SFPK||Sig3
SFPK, Sig2
SFPK, g2) = e(g1, Sig3
SFPK, g2) = e(X, Y2) · e(PHF.Eval(KPHF, M ), Sig3
SFPK) and
SFPK)
SFPK||pkSFPK); M ← gh
SFPK, s)
SFPK, Sig3
1 · ˆgs
Fig. 2. Our Flexible Signatures.
Theorem 1 (Unforgeability). Scheme 2 is strongly existential unforgeable under ﬂexible pub-
lic key in the common reference string model, assuming the bilinear decisional Diﬃe-Hellman as-
sumption holds (which implies that the discrete logarithm assumption holds) and that PHF is a
(1, poly(λ))-programmable hash function and H is collision-resistant.
SFPK) be the forgery returned by an adversary A, where Sig
∗
∗
∗
SFPK, m∗, pk
Proof. Let (Sig
SFPK =
3, s∗). We distinguish three types of strategies and will use A1, A2, A3 to denote
∗
(Sig
the corresponding adversaries:
∗
1, Sig
∗
2, Sig
Type 1 We call the adversary a type 1 adversary if there exists a public key pkSFPK and signature
3||pk
2||Sig
∗
∗
∗
SFPK) =
SigSFPK = (Sig1, Sig2, Sig3, s) on message m generated by oracle O1 or O2, where H(m∗||Sig
H(m||Sig2||Sig3||pkSFPK).
Type 2 We call the adversary a type 2 adversary if there exists a public key pkSFPK and signature
SigSFPK = (Sig1, Sig2, Sig3, s) on message m generated by oracle O1 or O2, where
but M∗ = ge∗
1 · ˆgs∗
e∗ = H(m∗||Sig
1 · ˆgs = M .
= ge
2||Sig
∗
3||pk
SFPK) (cid:54)= H(m||Sig2||Sig3||pkSFPK) = e
∗
∗
Type 3 We call the adversary a type 3 adversary in all other cases. In particular, we ensure that
M∗ is distinct from all M ’s used in the oracles O1 and O2.
Type 1 It is easy to see that the adversary broke the collision-resistance of function H and we can
build a reduction R that uses A1 to break collision-resistance of function H by simulating the system
and returning
(m∗||Sig
2||Sig
∗
3||pk
SFPK, m||Sig2||Sig3||pkSFPK)
∗
∗
as a valid collision.
19
Type 2 In this case we show that a type 2 can be used to break the discrete logarithm assumption.
We can apply the same reasoning as for Pedersen commitments, i.e. the reduction can set ˆg as the
element for which we want to compute the discrete logarithm in respect to g1. The reduction can
then simply simulate the whole system for A2 and output (e − e∗)/(s∗ − s).
1, gb
1, gc
2, gc
2, gd
2 , gb
1 , gd
1 , ga
First R prepares the common reference string ρ by setting Y1 = ga
Type 3 Let (BG, ga
2 ) be an instance of the bilinear decisional Diﬃe-Hellman
problem. We will show that we can use any eﬃcient adversary A3 can be used to break the above
problem instance. To do so, we will build a reduction algorithm R that uses A3 in a black box
manner, i.e. it plays the role of the challenger in the unforgeability experiment.
1 , Y2 = ga
1, for some
p and executes the trapdoor generation algorithm (KPHF, τPHF) ←$ PHF.TrapGen(1λ, ga
z ←$ Z∗
1 , g1).
Note that δρ is not publicly known, so R does not have to know the exponent a but still knows z.
Next R prepares the public key pkSFPK and the trapdoor τSFPK. For this it uses the values gb
1 and
To answer A’s signing queries for message m and randomness t1 (which is equal to 1 for oracle
2 , ˆg = gz
1) and τSFPK = (gb
gb
2 from the problem instance. It sets pkSFPK = (g1, gb
O1), the reduction R follows the following steps:
– it chooses random values t2 ←$ Z∗
p,
for some e(cid:48), s(cid:48) ←$ Z∗
– it computes M = ge(cid:48)
p.
– it computes (am, bm) ←$ PHF.TrapEval(τPHF, M ) and aborts if am = 0,
SFPK ←$ SFPK.ChgPK(pkSFPK, t1),
(cid:48)
– it computes pk
– it computes:
1 · ˆgs(cid:48)
2).
Sig2
Sig3
Sig1
SFPK = (gb
SFPK = (gb
SFPK = (ga
m ·t1 · gt2
1)−a−1
1 ,
m ·t1 · gt2
2)−a−1
2 ,
m ·t1) · gt2
1 )t2 · ((gb
1)(−a−1
1 ))bm,
e = H(m||Sig2
(cid:48)
SFPK, Sig3
SFPK, pk
SFPK),
s = ((e(cid:48) − e) + s(cid:48) · z)/z,
– set the signature SigSFPK = (Sig1
SFPK, Sig2
SFPK, Sig3
SFPK, s).
· ((ga
It is easy to see that this is a valid signature. Note that the a valid signature is of the form
m · b · t1 + t2 and this
1 . Note that this
cancels out and the reduction does not need to compute ga·b
2, s). In this case, the reduction has set r = −a−1
1 )r, gr
1
1
1, gr
1 )am · gbm
(ga·b·t1
means that the ga·b·t1
only works because am (cid:54)= 0. Otherwise, this would not work.
and aM∗ = 0, where M∗ = ge∗
reduction works as follows:
∗
SFPK as (Sig1
∗
SFPK, m∗, Sig
It follows that for the forgery (pk
and e∗ = H(m∗||Sig2
1 ˆgs∗
SFPK, s∗),
SFPK, Sig2
SFPK, Sig3
– parses Sig
– computes
SFPK, s∗) of A we require that (am∗ , bm∗ ) ←$ PHF.TrapEval(τPHF, M∗)
∗
SFPK||Sig3
SFPK||pk
∗
SFPK). In such a case, the
1
= Sig1
ga·b·t∗
1 )am∗ · gbm∗
· ((ga
SFPK ∈ [pkSFPK]R, we have pk
∗
∗
∗
– parses pk
SFPK and since for a valid forgery we have pk