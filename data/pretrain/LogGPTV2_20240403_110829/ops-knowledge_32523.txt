User: 请回答以下安全问题客户端密码哈希编辑：更新后更加强调目标——用户安心，而不是增强安全性。
在阅读了这里关于客户端哈希密码的一些讨论后，我仍然想知道在特定情况下使用它是否可以。
具体来说，我想让客户端——一个Java程序——使用类似PBKDF2的东西来散列他们的密码，将他们的电子邮件地址和特定于应用的恒定字节块的组合作为salt。其想法是，哈希可以用于身份验证，但如果服务器数据被泄露，则有望不受反向工程攻击（发现字面密码），而不是暴力攻击。
目标：
客户端哈希是为了让用户放心，服务器永远不会接收到他们的文字密码，即使无论如何都可以保证在存储中对其进行哈希。另一个附带的好处（或者可能是一种责任？）是迭代PBKDF2或类似程序的哈希成本由客户承担。
环境特征为：
所有客户端-服务器通信都是加密的。
不允许重播消息。即，从客户端发送的哈希不能被窃听者有效地用作密码。
在短时间内多次登录尝试失败时，可能会临时禁止IP并将其列入黑名单。这可以是每个用户帐户，也可以是整个系统。
关注点：
“避免设计自制的身份验证方案。”
salt对于每个用户来说都是确定的，即使由于salt中有（相同的）额外字节，所以生成的哈希将是特定于此应用的。这很糟糕吗？
服务器端的身份验证将在没有任何显著延迟的情况下进行，而不会产生哈希成本。这是否增加了分布式暴力身份验证攻击的漏洞？
流氓客户可以为自己的账户提供弱哈希。事实上，对此不太担心。
服务器是否应该在存储之前重新散列客户端散列？
想法？

Assistant: 客户端的哈希并不能解决密码哈希想要解决的主要问题——如果攻击者获得了对哈希密码数据库的访问权限，会发生什么。由于客户端发送的（散列）密码按原样存储在数据库中，因此此类攻击者可以通过按原样向服务器发送数据库中的散列密码来模拟所有用户。
另一方面，客户端的哈希很好，因为它可以确保用户服务器不知道密码——如果用户对多个服务使用相同的密码（就像大多数用户一样），这很有用。
一个可能的解决方案是在客户端和服务器端进行哈希。您仍然可以将繁重的PBKDF2操作卸载到客户端，并在服务器端执行单个哈希操作（在客户端PBKDF2哈希密码）。客户端中的PBKDF2将防止字典攻击，服务器端的单个哈希操作将防止按原样使用被盗数据库中的哈希密码。