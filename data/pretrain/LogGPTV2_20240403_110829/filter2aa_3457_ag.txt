spunnel_local x64 to run this agent and tunnel it back to Core Impact. 
We often use Cobalt Strike on an internet reachable infrastructure and Core Impact is often on a 
local Windows virtual machine. It's for this reason we have spunnel_local. We recommend that 
you run a Cobalt Strike client from the same Windows system that Core Impact is installed onto. 
In this setup, you can run spunnel_local x64 127.0.0.1 9000 c:\path\to\agent.bin. Once the 
connection is made, you will hear the famous "Agent Deployed" wav file. With an Impact agent 
on target, you have tools to escalate privileges, scan and information gather via many modules, 
launch remote exploits, and chain other Impact agents through your Beacon connection. 
9.5 Pivot Listeners 
It’s good tradecraft to limit the number of direct connections from your target’s network to your 
command and control infrastructure. A pivot listener allows you to create a listener that is bound 
to a Beacon or SSH session. In this way, you can create new reverse sessions without more direct 
connections to your command and control infrastructure. 
To setup a pivot listener, go to [beacon] -> Pivoting -> Listener…. This will open a dialog 
where you may define a new pivot listener.  
Figure 43. Configure a Pivot Listener 
A pivot listener will bind to Listen Port on the specified Session. The Listen Host value 
configures the address your reverse TCP payload will use to connect to this listener. 
Right now, the only payload option is windows/beacon_reverse_tcp.  
Pivot Listeners do not change the pivot host’s firewall configuration. If a pivot host has a host-
based firewall, this may interfere with your listener. You, the operator, are responsible for 
anticipating this situation and taking the right steps for it. 
www.cobaltstrike.com/
/
64/
To remove a pivot listener, go to Cobalt Strike -> Listeners and remove the listener there. 
Cobalt Strike will send a task to tear down the listening socket, if the session is still reachable. 
9.6 Covert VPN 
VPN pivoting is a flexible way to tunnel traffic without the limitations of a proxy pivot. Cobalt 
Strike offers VPN pivoting through its Covert VPN feature. Covert VPN creates a network 
interface on the Cobalt Strike system and bridges this interface into the target’s network. 
Figure 44. Deploy Covert VPN 
To activate Covert VPN, right-click a compromised host, go to [beacon] -> Pivoting -> Deploy 
VPN. Select the remote interface you would like Covert VPN to bind to. If no local interface is 
present, press Add to create one. 
Check Clone host MAC address to make your local interface have the same MAC address as the 
remote interface. It’s safest to leave this option checked.  
Press Deploy to start the Covert VPN client on the target. Covert VPN requires Administrator 
access to deploy. 
Once a Covert VPN interface is active, you may use it like any physical interface on your 
system. Use ifconfig to configure its IP address. If your target network has a DHCP server, you 
may request an IP address from it using your operating systems built-in tools.  
To manage your Covert VPN interfaces, go to Cobalt Strike -> Interfaces. Here, Cobalt Strike 
will show the Covert VPN interfaces, how they’re configured, and how many bytes were 
transmitted and received through each interface. 
Highlight an interface and press Remove to destroy the interface and close the remote Covert 
VPN client. Covert VPN will remove its temporary files on reboot and it automatically undoes 
any system changes right away.  
Press Add to configure a new Covert VPN interface. 
www.cobaltstrike.com/
/
65/
Figure 45. Setup a Covert VPN Interface 
Covert VPN interfaces consist of a network tap and a channel to communicate 65thernet frames 
through. To configure the interface, choose an Interface name (this is what you will manipulate 
through ifconfig later) and a MAC address.  
You must also configure the Covert VPN communication channel for your interface. Covert 
VPN may communicate Ethernet frames over a UDP connection, TCP connection, ICMP, or 
using the HTTP protocol. The TCP (Reverse) channel has the target connect to your Cobalt 
Strike instance. The TCP (Bind) channel has Cobalt Strike tunnel the VPN through Beacon. 
Cobalt Strike will setup and manage communication with the Covert VPN client based on the 
Local Port and Channel you select. 
The Covert VPN HTTP channel makes use of the Cobalt Strike web server. You may host other 
Cobalt Strike web applications and multiple Covert VPN HTTP channels on the same port. 
For best performance, use the UDP channel. The UDP channel has the least amount of overhead 
compared to the TCP and HTTP channels. Use the ICMP, HTTP, or TCP (Bind) channels if you 
need to get past a restrictive firewall. 
While Covert VPN has a flexibility advantage, your use of a VPN pivot over a proxy pivot will 
depend on the situation. Covert VPN requires Administrator access. A proxy pivot does not. 
Covert VPN creates a new communication channel. A proxy pivot does not. You should use a 
proxy pivot initially and move to a VPN pivot when it’s needed.  
www.cobaltstrike.com/
/
66/
10. SSH Sessions 
10.1 The SSH Client 
Cobalt Strike controls UNIX targets with a built-in SSH client. This SSH client receives tasks 
from and routes its output through a parent Beacon.  
Use ssh [target] [user] [password] to launch an SSH session from a Beacon. You may also use 
ssh-key [target] [user] [/path/to/key.pem] to authenticate with a key. 
These commands run Cobalt Strike’s SSH client. The client will report any connection or 
authentication issues to the parent Beacon. If the connection succeeds, you will see a new session 
in Cobalt Strike’s display. This is an SSH session. Right-click on this session and press Interact 
to open the SSH console.  
Type help to see a list of commands the SSH session supports. Type help followed by a 
command name for details on that command. 
10.2 Running Commands 
The shell command will run the command and arguments you provide. Running commands 
block the SSH session for up to 20s before Cobalt Strike puts the command in the background. 
Cobalt Strike will report output from these long running commands as it becomes available. 
Use sudo [password] [command + arguments] to attempt to run a command via sudo. This 
alias requires the target’s sudo to accept the –S flag. 
The cd command will change the current working directory for the SSH session. The pwd 
command reports the current working directory. 
10.3 Upload and Download Files 
The upload command will upload a file to the current working directory. The download 
command will download a file. Files downloaded with the download command are available 
under View -> Downloads. You may also type downloads to see file downloads in progress. 
The cancel command will cancel a download that’s in progress. 
10.4 Peer-to-peer C2 
SSH sessions can control TCP Beacons. Use the connect command to assume control of a TCP 
Beacon waiting for a connection. Use unlink to disconnect a TCP Beacon session. 
Go to [session] -> Listeners -> Pivot Listener… to setup a pivot listener tied to this SSH 
session. This will allow this compromised UNIX target to receive reverse TCP Beacon sessions. 
This option does require that the SSH daemon’s GatewayPorts option is set to yes or 
ClientSpecified. 
www.cobaltstrike.com/
/
67/
10.5 SOCKS Pivoting and Reverse Port Forwards 
Use the socks command to create a SOCKS server on your team server that forwards traffic 
through the SSH session. The rportfwd command will also create a reverse port forward that 
routes traffic through the SSH session and your Beacon chain.  
There is one caveat to rportfwd: the rportfwd command asks the SSH daemon to bind to all 
interfaces. It’s quite likely the SSH daemon will override this and force the port to bind to 
localhost. You need to change the GatewayPorts option for the SSH daemon to yes or 
clientspecified. 
www.cobaltstrike.com/
/
68/
11. Malleable Command and Control 
11.1 Overview 
Many Beacon indicators are controlled by a Malleable C2 profile. A Malleable C2 profile 
consists of settings and data transforms. A data transform is a simple program that specifies how 
to transform data and store it in a transaction. The same program that transforms and stores data, 
interpreted backwards, also extracts and recovers data from a transaction. 
To use a custom profile, you must start a Cobalt Strike team server and specify your profile at 
that time.  
./teamserver [external IP] [password] [/path/to/my.profile] 
You may only load one profile per Cobalt Strike instance. 
11.2 Checking for Errors 
Cobalt Strike’s Linux package includes a c2lint program. This program will check the syntax of 
a communication profile, apply a few extra checks, and even unit test your profile with random 
data. It’s highly recommended that you check your profiles with this tool before you load them 
into Cobalt Strike. 
./c2lint [/path/to/my.profile] 
11.3 Profile Language 
The best way to create a profile is to modify an existing one. Several example profiles are 
available on Github:  
• https://github.com/rsmudge/Malleable-C2-Profiles/
When you open a profile, here is what you will see: 
# this is a comment 
set global_option "value"; 
protocol-transaction { 
set local_option "value"; 
client { 
# customize client indicators 
} 
server { 
# customize server indicators 
} 
} 
www.cobaltstrike.com/
/
69/
Comments begin with a # and go until the end of the line. The set statement is a way to assign a 
value to an option. Profiles use { curly braces } to group statements and information together. 
Statements always end with a semi-colon. 
To help all of this make sense, here’s a partial profile: 
http-get { 
        set uri "/foobar"; 
        client { 
                metadata { 
                        base64; 
                        prepend "user="; 
                        header "Cookie"; 
                } 
        } 
This partial profile defines indicators for an HTTP GET transaction. The first statement, set uri, 
assigns the URI that the client and server will reference during this transaction. This set 
statement occurs outside of the client and server code blocks because it applies to both of them. 
The client block defines indicators for the client that performs an HTTP GET. The client, in this 
case, is Cobalt Strike’s Beacon payload. 
When Cobalt Strike’s Beacon “phones home” it sends metadata about itself to Cobalt Strike. In 
this profile, we have to define how this metadata is encoded and sent with our HTTP GET 
request. 
The metadata keyword followed by a group of statements specifies how to transform and embed 
metadata into our HTTP GET request. The group of statements, following the metadata keyword, 
is called a data transform.  
Step 
Action 
Data 
0. Start 
metadata 
1. base64 
Base64 Encode 
bWV0YWRhdGE= 
2. prepend "user=" 
Prepend String 
user=bWV0YWRhdGE= 
3. header "Cookie" 
Store in Transaction 
The first statement in our data transform states that we will base64 encode our metadata [1]. The 
second statement, prepend, takes our encoded metadata and prepends the string user= to it [2]. 
Now our transformed metadata is “user=“ . base64(metadata). The third statement states we will 
store our transformed metadata into a client HTTP header called Cookie [3].  That’s it.  
Both Beacon and its server consume profiles. Here, we’ve read the profile from the perspective 
of the Beacon client. The Beacon server will take this same information and interpret it 
www.cobaltstrike.com/
/
70/
backwards. Let’s say our Cobalt Strike web server receives a GET request to the URI /foobar. 
Now, it wants to extract metadata from the transaction.  
Step 
Action 
Data 
0. Start 
1. header "Cookie" 
Recover from Transaction 
user=bWV0YWRhdGE= 
2. prepend "user=" 
Remove first 5 characters 
bWV0YWRhdGE= 
3. base64 
Base64 Decode 
metadata 
The header statement will tell our server where to recover our transformed metadata from [1]. 
The HTTP server takes care to parse headers from the HTTP client for us. Next, we need to deal 
with the prepend statement. To recover transformed data, we interpret prepend as remove the 
first X characters [2], where X is the length of the original string we prepended. Now, all that’s 
left is to interpret the last statement, base64. We used a base64 encode function to transform the 
metadata before. Now, we use a base64 decode to recover the metadata [3]. 
We will have the original metadata once the profile interpreter finishes executing each of these 
inverse statements. 
Data Transform Language 
A data transform is a sequence of statements that transform and transmit data. The data transform 
statements are: 
Statement 
Action 
Inverse 
append "string" 
Append "string" 
Remove last LEN(“string”) characters 
base64 
Base64 Encode 
Base64 Decode 
base64url 
URL-safe Base64 Encode 
URL-safe Base64 Decode 
mask 
XOR mask w/ random key 
XOR mask w/ same random key 
netbios 
NetBIOS Encode ‘a’ 
NetBIOS Decode ‘a’ 
netbiosu 
NetBIOS Encode ‘A’ 
NetBIOS Decode ‘A’ 
prepend "string" 
Prepend "string" 
Remove first LEN(“string”) characters 
A data transform is a combination of any number of these statements, in any order. For example, 
you may choose to netbios encode the data to transmit, prepend some information, and then 
base64 encode the whole package. 
A data transform always ends with a termination statement. You may only use one termination 
statement in a transform. This statement tells Beacon and its server where in the transaction to 
store the transformed data. 
www.cobaltstrike.com/
/
71/
There are four termination statements.  
Statement 
What 
header “header” 
Store data in an HTTP header 
parameter “key” 
Store data in a URI parameter 
print 
Send data as transaction body 
uri-append 
Append to URI 
The header termination statement stores transformed data in an HTTP header. The parameter 
termination statement stores transformed data in an HTTP parameter. This parameter is always 
sent as part of URI. The print statement sends transformed data in the body of the transaction.  
The print statement is the expected termination statement for the http-get.server.output, http-
post.server.output, and http-stager.server.output blocks. You may use the header, parameter, 
print and uri-append termination statements for the other blocks.  
If you use a header, parameter, or uri-append termination statement on http-post.client.output, 
Beacon will chunk its responses to a reasonable length to fit into this part of the transaction. 
These blocks and the data they send are described in a later section. 
Strings 
Beacon’s Profile Language allows you to use “strings” in several places. In general, strings are 
interpreted as-is. However, there are a few special values that you may use in a string: 
Value 
Special Value 
“\n” 
Newline character 
“\r” 
Carriage Return 
“\t” 
Tab character 
“\u####” 
A unicode character 
“\x##” 
A byte (e.g., \x41 = ‘A’) 
“\\” 
\ 
Headers and Parameters 
Data transforms are an important part of the indicator customization process. They allow you to 