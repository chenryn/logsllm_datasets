作者：隐形人真忙  
作者博客：
#### 0x00 基础知识
EVM虚拟机在解析合约的字节码时，依赖的是ABI的定义，从而去识别各个字段位于字节码的什么地方。关于ABI，可以阅读这个文档：
一般ERC-20 TOKEN标准的代币都会实现transfer方法，这个方法在ERC-20标签中的定义为： `function
transfer(address to, uint tokens) public returns (bool success);`
第一参数是发送代币的目的地址，第二个参数是发送token的数量。
当我们调用transfer函数向某个地址发送N个ERC-20代币的时候，交易的input数据分为3个部分：
4 字节，是方法名的哈希：a9059cbb
32字节，放以太坊地址，目前以太坊地址是20个字节，高危补0  
`000000000000000000000000abcabcabcabcabcabcabcabcabcabcabcabcabca`
32字节，是需要传输的代币数量，这里是1*10^18 GNT  
`0000000000000000000000000000000000000000000000000de0b6b3a7640000`
所有这些加在一起就是交易数据：
`a9059cbb000000000000000000000000abcabcabcabcabcabcabcabcabcabcabcabcabca0000000000000000000000000000000000000000000000000de0b6b3a7640000`
#### 0x01 以太坊短地址
当调用transfer方法提币时，如果允许用户输入了一个短地址，这里通常是交易所这里没有做处理，比如没有校验用户输入的地址长度是否合法。
如果一个以太坊地址如下，注意到结尾为0：
`0x1234567890123456789012345678901234567800`
当我们将后面的00省略时，EVM会从下一个参数的高位拿到00来补充，这就会导致一些问题了。
这时，token数量参数其实就会少了1个字节，即token数量左移了一个字节，使得合约多发送很多代币出来。我们看个例子：
这里调用sendCoin方法时，传入的参数如下：
    0x90b98a11
    00000000000000000000000062bec9abe373123b9b635b75608f94eb8644163e
    0000000000000000000000000000000000000000000000000000000000000002
这里的0x90b98a11是method的hash值，第二个是地址，第三个是amount参数。
如果我们调用sendCoin方法的时候，传入地址0x62bec9abe373123b9b635b75608f94eb8644163e，把这个地址的“3e”丢掉，即扔掉末尾的一个字节，参数就变成了：
    0x90b98a11
    00000000000000000000000062bec9abe373123b9b635b75608f94eb86441600
    00000000000000000000000000000000000000000000000000000000000002  
                                                                                                                                ^^
                                                                 缺失1个字节
这里EVM把amount的高位的一个字节的0填充到了address部分，这样使得amount向左移位了1个字节，即向左移位8。
这样，amount就成了2 
  * 
  * 
* * *