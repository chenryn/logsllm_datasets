但是切片不能用作映射的键。
将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。
5
第 5 章 Go 语言的类型系统
第5章 Go语言的类型系统
本章主要内容
 声明新的用户定义的类型
 使用方法，为类型增加新的行为
 了解何时使用指针，何时使用值
 通过接口实现多态
 通过组合来扩展或改变类型
 公开或者未公开的标识符
Go 语言是一种静态类型的编程语言。这意味着，编译器需要在编译时知晓程序里每个值的
类型。如果提前知道类型信息，编译器就可以确保程序合理地使用值。这有助于减少潜在的内存
异常和bug，并且使编译器有机会对代码进行一些性能优化，提高执行效率。
值的类型给编译器提供两部分信息：第一部分，需要分配多少内存给这个值（即值的规模）；
第二部分，这段内存表示什么。对于许多内置类型的情况来说，规模和表示是类型名的一部分。
int64类型的值需要8字节（64位），表示一个整数值；float32类型的值需要4字节（32位），
表示一个IEEE-754定义的二进制浮点数；bool类型的值需要1字节（8位），表示布尔值true
和false。
有些类型的内部表示与编译代码的机器的体系结构有关。例如，根据编译所在的机器的体系
结构，一个int值的大小可能是8字节（64位），也可能是4字节（32位）。还有一些与体系结
构相关的类型，如Go语言里的所有引用类型。好在创建和使用这些类型的值的时候，不需要了
解这些与体系结构相关的信息。但是，如果编译器不知道这些信息，就无法阻止用户做一些导致
程序受损甚至机器故障的事情。
5.1 用户定义的类型
Go 语言允许用户定义类型。当用户声明一个新类型时，这个声明就给编译器提供了一个框
架，告知必要的内存大小和表示信息。声明后的类型与内置类型的运作方式类似。Go 语言里声
明用户定义的类型有两种方法。最常用的方法是使用关键字struct，它可以让用户创建一个结
构类型。
结构类型通过组合一系列固定且唯一的字段来声明，如代码清单5-1所示。结构里每个字段
都会用一个已知类型声明。这个已知类型可以是内置类型，也可以是其他用户定义的类型。
代码清单5-1 声明一个结构类型
01 // user在程序里定义一个用户类型
02 type user struct {
03 name string
04 email string
05 ext int
06 privileged bool
07 }
在代码清单5-1中，可以看到一个结构类型的声明。这个声明以关键字type开始，之后是
新类型的名字，最后是关键字struct。这个结构类型有4个字段，每个字段都基于一个内置类
型。读者可以看到这些字段是如何组合成一个数据的结构的。一旦声明了类型（如代码清单 5-2
所示），就可以使用这个类型创建值。
代码清单5-2 使用结构类型声明变量，并初始化为其零值
09 // 声明user类型的变量
10 var bill user
在代码清单5-2的第10行，关键字var创建了类型为user且名为bill的变量。当声明
变量时，这个变量对应的值总是会被初始化。这个值要么用指定的值初始化，要么用零值（即变
量类型的默认值）做初始化。对数值类型来说，零值是0；对字符串来说，零值是空字符串；对
布尔类型，零值是false。对这个例子里的结构，结构里每个字段都会用零值初始化。
任何时候，创建一个变量并初始化为其零值，习惯是使用关键字var。这种用法是为了更明
确地表示一个变量被设置为零值。如果变量被初始化为某个非零值，就配合结构字面量和短变量
声明操作符来创建变量。
代码清单5-3展示了如何声明一个user类型的变量，并使用某个非零值作为初始值。在第
13 行，我们首先给出了一个变量名，之后是短变量声明操作符。这个操作符是冒号加一个等号
（:=）。一个短变量声明操作符在一次操作中完成两件事情：声明一个变量，并初始化。短变量
声明操作符会使用右侧给出的类型信息作为声明变量的类型。
代码清单5-3 使用结构字面量来声明一个结构类型的变量
12 // 声明user类型的变量，并初始化所有字段
13 lisa := user{
14 name: "Lisa",
15 email: "PI:EMAIL",
16 ext: 123,
17 privileged: true,
18 }
既然要创建并初始化一个结构类型，我们就使用结构字面量来完成这个初始化，如代码清
单5-4所示。结构字面量使用一对大括号括住内部字段的初始值。
代码清单5-4 使用结构字面量创建结构类型的值
13 user{
14 name: "Lisa",
15 email: "PI:EMAIL",
16 ext: 123,
17 privileged: true,
18 }
结构字面量可以对结构类型采用两种形式。代码清单5-4中使用了第一种形式，这种形式在
不同行声明每个字段的名字以及对应的值。字段名与值用冒号分隔，每一行以逗号结尾。这种形
式对字段的声明顺序没有要求。第二种形式没有字段名，只声明对应的值，如代码清单5-5所示。
代码清单5-5 不使用字段名，创建结构类型的值
12 // 声明user类型的变量
13 lisa := user{"Lisa", "PI:EMAIL", 123, true}
每个值也可以分别占一行，不过习惯上这种形式会写在一行里，结尾不需要逗号。这种形式
下，值的顺序很重要，必须要和结构声明中字段的顺序一致。当声明结构类型时，字段的类型并
不限制在内置类型，也可以使用其他用户定义的类型，如代码清单5-6所示。
代码清单5-6 使用其他结构类型声明字段
20 // admin需要一个user类型作为管理者，并附加权限
21 type admin struct {
22 person user
23 level string
24 }
代码清单5-6展示了一个名为admin的新结构类型。这个结构类型有一个名为person的
user 类型的字段，还声明了一个名为level 的string 字段。当创建具有person 这种字段
的结构类型的变量时，初始化用的结构字面量会有一些变化，如代码清单5-7所示。
代码清单5-7 使用结构字面量来创建字段的值
26 // 声明admin类型的变量
27 fred := admin{
28 person: user{
29 name: "Lisa",
30 email: "PI:EMAIL",
31 ext: 123,
32 privileged: true,
33 },
34 level: "super",
35 }
为了初始化person字段，我们需要创建一个user类型的值。代码清单5-7的第28行就
是在创建这个值。这行代码使用结构字面量的形式创建了一个 user 类型的值，并赋给了 person
字段。
另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明。
当需要一个可以用已有类型表示的新类型的时候，这种方法会非常好用，如代码清单5-8所示。
标准库使用这种声明类型的方法，从内置类型创建出很多更加明确的类型，并赋予更高级的功能。
代码清单5-8 基于int64声明一个新类型
type Duration int64
代码清单5-8展示的是标准库的time包里的一个类型的声明。Duration是一种描述时间
间隔的类型，单位是纳秒（ns）。这个类型使用内置的 int64 类型作为其表示。在 Duration
类型的声明中，我们把 int64类型叫作 Duration的基础类型。不过，虽然 int64是基础
类型，Go并不认为 Duration和 int64是同一种类型。这两个类型是完全不同的有区别的
类型。
为了更好地展示这种区别，来看一下代码清单5-9所示的小程序。这个程序本身无法通过
编译。
代码清单5-9 给不同类型的变量赋值会产生编译错误
01 package main
02
03 type Duration int64
04
05 func main() {
06 var dur Duration
07 dur = int64(1000)
08 }
代码清单5-9所示的程序在第03行声明了Duration类型。之后在第06行声明了一个类型
为Duration 的变量 dur，并使用零值作为初值。之后，第 7 行的代码会在编译的时候产生编
译错误，如代码清单5-10所示。
代码清单5-10 实际产生的编译错误
prog.go:7: cannot use int64(1000) (type int64) as type Duration
in assignment
编译器很清楚这个程序的问题：类型int64的值不能作为类型Duration的值来用。换句
话说，虽然int64 类型是基础类型，Duration类型依然是一个独立的类型。两种不同类型的
值即便互相兼容，也不能互相赋值。编译器不会对不同类型的值做隐式转换。
5.2 方法
方法能给用户定义的类型添加新的行为。方法实际上也是函数，只是在声明时，在关键字
func和方法名之间增加了一个参数，如代码清单5-11所示。
代码清单5-11 listing11.go
01 // 这个示例程序展示如何声明
02 // 并使用方法
03 package main
04
05 import (
06 "fmt"
07 )
08
09 // user在程序里定义一个用户类型
10 type user struct {
11 name string
12 email string
13 }
14
15 // notify使用值接收者实现了一个方法
16 func (u user) notify() {
17 fmt.Printf("Sending User Email To %s\n",
18 u.name,
19 u.email)
20 }
21
22 // changeEmail使用指针接收者实现了一个方法
23 func (u *user) changeEmail(email string) {
24 u.email = email
25 }
26
27 // main是应用程序的入口
28 func main() {
29 // user类型的值可以用来调用
30 // 使用值接收者声明的方法
31 bill := user{"Bill", "PI:EMAIL"}
32 bill.notify()
33
34 // 指向user类型值的指针也可以用来调用
35 // 使用值接收者声明的方法
36 lisa := &user{"Lisa", "PI:EMAIL"}
37 lisa.notify()
38
39 // user类型的值可以用来调用
40 // 使用指针接收者声明的方法
41 bill.changeEmail("PI:EMAIL")
42 bill.notify()
43
44 // 指向user类型值的指针可以用来调用
45 // 使用指针接收者声明的方法
46 lisa.changeEmail("PI:EMAIL")
47 lisa.notify()
48 }
代码清单 5-11 的第 16 行和第 23 行展示了两种类型的方法。关键字 func 和函数名之间的
参数被称作接收者，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称
为方法。当运行这段程序时，会得到代码清单5-12所示的输出。
代码清单5-12 listing11.go的输出
Sending User Email To Bill
Sending User Email To Lisa
Sending User Email To Bill
Sending User Email To Lisa
让我们来解释一下代码清单5-13所示的程序都做了什么。在第10行，该程序声明了名为user
的结构类型，并声明了名为notify的方法。
代码清单5-13 listing11.go：第09行到第20行
09 // user在程序里定义一个用户类型
10 type user struct {
11 name string
12 email string
13 }
14
15 // notify使用值接收者实现了一个方法
16 func (u user) notify() {
17 fmt.Printf("Sending User Email To %s\n",
18 u.name,
19 u.email)
20 }
Go 语言里有两种类型的接收者：值接收者和指针接收者。在代码清单 5-13 的第 16 行，使
用值接收者声明了notify方法，如代码清单5-14所示。
代码清单5-14 使用值接收者声明一个方法
func (u user) notify() {
notify方法的接收者被声明为user类型的值。如果使用值接收者声明方法，调用时会使
用这个值的一个副本来执行。让我们跳到代码清单5-11的第32行来看一下如何调用notify方
法，如代码清单5-15所示。
代码清单5-15 listing11.go：第29行到第32行
29 // user类型的值可以用来调用
30 // 使用值接收者声明的方法
31 bill := user{"Bill", "PI:EMAIL"}
32 bill.notify()
代码清单5-15展示了如何使用user类型的值来调用方法。第31行声明了一个user类型
的变量bill，并使用给定的名字和电子邮件地址做初始化。之后在第32行，使用变量bill来
调用notify方法，如代码清单5-16所示。
代码清单5-16 使用变量来调用方法
bill.notify()
这个语法与调用一个包里的函数看起来很类似。但在这个例子里，bill不是包名，而是变
量名。这段程序在调用 notify 方法时，使用 bill 的值作为接收者进行调用，方法 notify
会接收到bill的值的一个副本。
也可以使用指针来调用使用值接收者声明的方法，如代码清单5-17所示。
代码清单5-17 listing11.go：第34行到第37行
34 // 指向user类型值的指针也可以用来调用
35 // 使用值接收者声明的方法
36 lisa := &user{"Lisa", "PI:EMAIL"}
37 lisa.notify()
代码清单5-17展示了如何使用指向user类型值的指针来调用notify方法。在第36行，