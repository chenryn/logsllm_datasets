3.1 Our Approach
Strider takes a conventional ﬁxed channel code and constellation
which works only above a particular threshold SNR, and makes it
rateless. In other words, it enables the ﬁxed channel code and con-
stellation to decode at any SNR. We refer to this ﬁxed channel code
and constellation as the static code in the rest of the paper. For ex-
position simplicity, we assume in this section that the static code is
using BPSK, but the actual implementation uses QPSK.
The key idea behind Strider’s rateless transformation is the con-
cept of minimum distance transformation (MDT). Intuitively, MDT
takes a batch of symbols from the static code and maps them to a
different space where the minimum distance between the two closest
points can be tuned to meet the static code’s requirements. To un-
derstand how MDT works, we begin with a simple (but suboptimal)
approach that demonstrates the basic idea. Assume we have a BPSK
symbol x from the static code. A simple approach to amplify the
minimum distance is to take the symbol x, and transmit it multiple
(M) times, but multiply each transmission by a complex number of
unit magnitude but random phase ri = ej(cid:18)i (so transmission power
does not change). The receiver therefore gets the following symbols
after noise gets added
~y = ~rx + ~n
(1)
where ~r is the M length vector of random complex numbers formed
by the coefﬁcients of each transmission, and ~n is the noise vector for
the M transmissions.
P ;(cid:0)p
The transmitter in essence has mapped a simple BPSK symbol x
to a random point ~y in a M-dimensional space. To see why this
ampliﬁes minimum distance, lets compute the Euclidean distance in
p
this new space between the original two BPSK constellation points
p
M P , which is
M times the original minimum distance, providing much higher
resilience to noise. At some value of M (i.e. after a certain M num-
ber of transmissions), the static code will meet its minimum distance
threshold and be able to decode.
P . The new distance is jj2
P ~rjj = 2
p
p
As the reader can tell, the above naive approach is quite inefﬁcient.
It increases the minimum distance in large increments, whereas the
static code itself might need a much smaller increment to decode.
Our key observation is that instead of operating over single symbols
as above, we can spread the transmission power over a batch of K
symbols belonging to K parallel blocks (each block is generated by
passing data through the static code). Speciﬁcally, instead of trans-
mitting the K symbols separately one by one, Strider transmits ran-
dom linear combinations of the K symbols
p
i=KX
!
(1=K)
rixi
i=1
p
(2)
(3)
where the
symbol has a power of P .
1=K factor is needed to ensure that every transmitted
The transmitter picks separate random coefﬁcients for each linear
combination. Assuming the transmitter has to send M such linear
combinations, the receiver receives the following system of linear
equations distorted by noise.
p
~y =
(1=K)R~x + ~n
where ~x is the K length vector corresponding to the batch of K static
code symbols, R is the M (cid:2) K matrix consisting of the random
phase coefﬁcients ri deﬁned above, and all the other deﬁnitions are
the same.
p
p
P=Kjj = 2
To understand how this technique achieves minimum distance trans-
formation, we can use the following visualization. Intuitively, this
operation is taking K dimensional vectors ~x and mapping it to ran-
dom points in a M dimensional space. As M increases, the minimum
distance between the two closest points in this new space increases.
When M = 1 the minimum distance is 2
P=K. For any value M,
the minimum distance between points in the M-dimensional space
corresponding to the closest constellation points for the static code
symbols xi (assuming BPSK) is jj2R(i)
M P=K,
where R(i) is the i’th column of matrix R. Thus the minimum dis-
tance increases monotonically with M. Hence, by controlling the
value of M (i.e. by controlling the number of transmissions), we can
control the minimum distance until the static code’s requirements for
each of the K blocks are met and they can decode. Thus, we can
keep on transmitting linear combinations until all the K blocks can
be decoded.
p
Stepping back, Strider’s technique has taken a static code that used
to operate at or above a ﬁxed SNR threshold, and converted it using
MDT to work at any SNR by adjusting the minimum distance. In
other words, we have converted the static code to be rateless. To
decode, the receiver estimates what are the likely symbols ~x given ~y
and the matrix R, and then passes the K symbols through the decoder
for the static code. In the following section, we describe the design
of an efﬁcient algorithm that realizes this insight, as well as extend it
to decode collided packets.
4. DESIGN
First, we describe the two main design goals for Strider, and dis-
cuss them in the context of how these goals ﬁt into the larger picture
of code design:
(cid:15) Complexity of the decoding algorithm: The efﬁciency of a
code (deﬁned as how close it’s achieved throughput is to the
Shannon capacity at any SNR) is typically proportional to the
computational complexity of the decoding algorithm. For ex-
ample, Shannon himself used a random codebook construction
that achieves channel capacity, but incurs exponential decoding
computational complexity. Algorithms such as sphere decod-
ing and maximum likelihood (ML) [14] decoders try to mimic
the random decoding structure of Shannon’s design and hence
perform quite well, but still require at least cubic complexity,
if not more. Recent code designs such as LDPC codes are the
one exception to the rule, since they come close to achieving
capacity yet only have linear decoding computational complex-
ity. For practical implementations, low complexity algorithms
are of course highly desirable. Our goal is to design an efﬁcient
code with linear decoding computational complexity.
(cid:15) Feedback from the receiver: In conventional code design,
feedback from the receiver is often quite helpful in improving
performance. For example, HARQ systems [29] use feedback
from the receiver to determine how many extra parity bits to
transmit and minimize wasteful transmission. Note that this
is not channel-state feedback, but rather feedback about what
data the receiver has already decoded. However, even such
feedback can be expensive in wireless since spectrum is scarce,
and can complicate protocol design since these feedback pack-
ets need to be scheduled and reliably delivered by the MAC
protocol. More importantly, such feedback goes against the
grain of rateless code designs [28, 19] which strive to operate
so that the receiver has to only send a single ACK packet when
all packets have been successfully decoded. Our goal is to de-
sign a code that requires the minimum possible feedback, i.e.
it requires only one bit of feedback from the receiver when it
has successfully decoded everything that was transmitted. The
negligible feedback requirement simpliﬁes protocol design.
Strider’s encoding and decoding algorithms meet the above two de-
sign goals. Before describing the algorithm however, we summarize
the operational algorithm in Strider to give the reader an overview
of the end-to-end protocol, and also to harmonize notation. When a
node has data to transmit, it uses the following four simple steps:
1. Data is divided into chunks of size 6KB. In each chunk we have
K = 33 data blocks of length M = 1500bits each.
2. Each of the K data blocks is passed through the static code
(currently we use a 1=5 rate channel code and a QPSK constel-
lation as the static code), to produce K blocks with L = 5M=2
complex symbols each.
3. The K blocks are passed through Strider to create a packet for
transmission.
4. Use the standard carrier sense mechanism to check if the medium
is idle, and if it is transmit the packet. After transmission, wait
for an ACK, which the receiver sends if it has successfully de-
coded the entire chunk consisting of K blocks. If no ACK is
received, go to step 3 and repeat. Move to step 1 when an ACK
is received.
We expand on Step 3 which is the core encoding step in Strider. To
produce a packet for transmission, Strider linearly combines the K
coded blocks from the static code to create one packet. For example
to create the ﬁrst symbol in the transmitted packet we would do the
following computation
s1 = r1x11 + r2x21 + : : : + rK xK1
(4)
where xi1 is the ﬁrst complex symbol in the i’th block, and ri is the
i’th complex coefﬁcient used to create the linear combination. The
computation is repeated with the same coefﬁcients for all L sym-
bols in each block. We assume that the random coefﬁcients have
been normalized so that the energy of the symbols is P , the trans-
mission power budget. The above technique produces one packet
for transmission. The header of each packet includes the coefﬁcients
used to create the linear combination of the blocks (i.e. the symbols
r1 : : : rK).
The sender creates packets using different linear combinations for
each packet, and transmits them until the receiver can decode all K
Figure 1: Strider’s decoding algorithm
blocks and ACKs. Lets assume the receiver requires M packets be-
fore it can decode all K blocks. We can express the i’th symbol in
each of the M packets received as:
~yi = R ~xi + ~n
(5)
where ~yi is the M length vector consisting of the received symbols at
the i’th position from the M received packets, and ~xi is the K length
input vector consisting of the i’th input symbols from the K coded
blocks. R is the M (cid:2) K matrix consisting of the coefﬁcients used
in creating the linear combinations for the M transmitted packets,
with each row corresponding to one received packet. Finally ~n is the
noise vector. Note that we did not include the channel attenuation in
the above equation, we assume that the noise power has been scaled
appropriately to account for channel attenuation.
4.1 Decoding Algorithm
As discussed before, we can visualize Strider as mapping K di-
mensional vectors ( ~xi) to M dimensional vectors that are distorted
by noise after they pass through the wireless channel to produce ~yi.
Since the components of ~xi can only take four discrete values (the
four points of a QPSK constellation), the vector ~xi can take at most
4K different values. Since R is known to the receiver, the receiver
can exactly estimate what 4K possible points could have been trans-
mitted. Hence one method to decode would be to calculate the closest
constellation point among the 4K possible points and then lookup the
corresponding input. From that point, we can apply the traditional
decoder for the static code to the K coded blocks and recover the
original data.
However, this naive technique quickly gets complicated. For ex-
ample, if K = 10 then the number of possible constellation points
is 410 = 1048576! To compute the closest point, the decoder would
require exponential memory and compute resources, which rules out
this naive method.
4.1.1 Stripping Decoder
Strider’s key insight is that instead of trying to decode the entire
vector ~xi at once which incurs exponential complexity, we can try to
decode it one component at a time. Since each component in ~xi can
at most take 4 discrete values (QPSK), the computational complexity
is signiﬁcantly lower. Hence, Strider ﬁrst decodes the ﬁrst coded
block’s components, and passes them through the decoder for the
static code to recover the original symbols. If decoding is successful,
we can re-encode the ﬁrst block and subtract it from the received
vectors (~yi) to remove the effect of the ﬁrst coded block. Next, we
can proceed to the second block and repeat the above process.
One way to visualize Strider’s decoder is as follows: remember the
received packets are each a linear combination of blocks belonging to
one chunk. Strider’s decoder is in effect trying to decode one block
at a time, strip it from the received signals, and then decode the next
block and strip it, and so on. Hence, we christen the scheme Strider
for stripping decoder.
Operationally, the above intuition implies that Strider attempts to
decode the ﬁrst block while treating the other K (cid:0) 1 blocks as inter-
ference. The algorithm would work as follows for the ﬁrst block:
Packet 1Packet 2Packet MReceiveR(xi)(yi)=+NoiseDecode oneblockSubtract decoded block from received packetsK Coded Blocks1. Take ~R1 (the ﬁrst column of matrix R) and form its complex
(cid:3)
transposed conjugate ~R
1.
(cid:3)
2. Take the dot product of ~yj with ~R
1 to obtain one symbol. Re-
peat for all j = 1 : : : L to obtain L complex symbols.
3. Attempt to decode the L symbols obtained in the previous step
using the decoder for the static code.
4. If decoding is successful 1, block 1 is obtained. Subtract the
symbols corresponding to block 1 from the received symbols,
0
i.e. subtract (x1j ~R1) from ~yj to obtain a new vector ~y
j, and
0
remove the ﬁrst column from R to obtain a new matrix R
. Go
to step 1 and attempt to decode the second coded block using
0
0
the same steps but with the new ~y
. Repeat until all
j and R
blocks are decoded.