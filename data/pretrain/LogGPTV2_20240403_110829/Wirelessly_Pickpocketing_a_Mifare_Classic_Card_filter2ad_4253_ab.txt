The physical layer and data link layer of the Mifare
family of cards are described in the ISO standard
7. http://www.proxmark.org/
8. http://www.libnfc.org/
3
that block. The access conditions determine which of
the two keys must be used. See Figure 2.1 for an
overview of the memory of a Mifare Classic tag.
2.3. CRYPTO1
After authentication, the communication between
tag and reader is encrypted with the CRYPTO1 stream
cipher. This cipher consists of a 48-bit linear feed-
back shift register (LFSR) with generating polynomial
x48+x43+x39+x38+x36+x34+x33+x31+x29+x24+
x23 + x21 + x19 + x13 + x9 + x7 + x6 + x5 + 1 and
a non-linear ﬁlter function f [NESP08]. Each clock
tick, twenty bits of the LFSR are put through the ﬁlter
function, generating one bit of keystream. Then the
LFSR shifts one bit to the left, using the generating
polynomial to generate a new bit on the right. See
Figure 2.2 for a schematic representation.
We let F2 = {0, 1} the ﬁeld of two elements (or
the set of Booleans). The symbol ⊕ denotes addition
(XOR).
Deﬁnition 2.1. The feedback function L : F48
2 → F2
is deﬁned by L(x0x1 . . . x47) := x0 ⊕ x5 ⊕ x9 ⊕ x10 ⊕
x12 ⊕ x14 ⊕ x15 ⊕ x17 ⊕ x19 ⊕ x24 ⊕ x25 ⊕ x27 ⊕ x29 ⊕
x35 ⊕ x39 ⊕ x41 ⊕ x42 ⊕ x43.
The speciﬁcs of
the ﬁlter
function are taken
from [GKM+08].
Deﬁnition 2.2. The ﬁlter function f : F48
deﬁned by
2 → F2 is
f (x0x1 . . . x47) := fc(fa(x9, x11, x13, x15),
fb(x17, x19, x21, x23), fb(x25, x27, x29, x31),
fa(x33, x35, x37, x39), fb(x41, x43, x45, x47)).
2 → F2 and fc : F5
Here fa, fb : F4
2 → F2 are deﬁned
by fa(y0, y1, y2, y3) := ((y0 ∨ y1) ⊕ (y0 ∧ y3)) ⊕ (y2 ∧
((y0 ⊕ y1) ∨ y3)), fb(y0, y1, y2, y3) := ((y0 ∧ y1) ∨
y2)⊕((y0⊕y1)∧(y2∨y3)), and fc(y0, y1, y2, y3, y4) :=
(y0 ∨((y1 ∨y4)∧(y3 ⊕y4)))⊕((y0 ⊕(y1 ∧y3))∧((y2 ⊕
y3)∨(y1∧y4))). Because f (x0x1 . . . x47) only depends
on x9, x11, . . . , x47, we shall overload notation and see
f as a function F20
2 → F2, writing f (x0x1 . . . x47) as
f (x9, x11, . . . , x47).
Note that fa and fb here are negated when compared
to [GKM+08] and fc is changed accordingly. The
expressions for fa, fb, and fc given here have the min-
imal number of logical operators in {∧, ∨, ⊕, ¬}; in
practice, this allows for a fast bitsliced implementation
of f [Bih97].
For future reference, note that each of the building
blocks of f (and hence f itself) have the property that
it gives zero for half of the possible inputs (respectively
one).
Theorem 2.3. Let Y0, Y1, . . . , Y4 be independent uni-
formly distributed variables over F2. Then
P [fa(Y0, Y1, Y2, Y3) = 0] = 1/2
P [fb(Y0, Y1, Y2, Y3) = 0] = 1/2
P [fc(Y0, Y1, Y2, Y3, Y4) = 0] = 1/2.
Proof. By inspection.
2.4. Tag nonces
For use in the authentication protocol, described
in Section 2.5 below, Mifare Classic tags possess a
pseudo-random generator. In [NP07] it was revealed
that the 32-bit tag nonces are generated by a 16-bit
LFSR with generating polynomial x16 + x14 + x13 +
x11 + 1. Every clock tick the LFSR shifts to the left
and the feedback bit is computed using L16.
Deﬁnition 2.4. The feedback function L16 : F16
of the pseudo-random generator is deﬁned by
2 → F2
L16(x0x1 . . . x15) := x0 ⊕ x2 ⊕ x3 ⊕ x5.
Let us deﬁne the function suc that computes the next
32-bit LFSR sequence of the 16-bit LFSR. This func-
tion is used later on in Section 2.5 in the authentication
protocol.
Deﬁnition 2.5. The successor function suc : F32
F32
2
is deﬁned by
2 →
suc(x0x1 . . . x31) := x1x2 . . . x31L16(x16x17 . . . x31) .
Because the period of the pseudo-random generator
is only 65535 and because it shifts every 9.44µs, it
cycles in 618ms.
Under similar physical conditions (i.e., do not move
the tag or the reader), the challenge nonce that the tag
generates only depends on the time between the mo-
ment the reader switches on the electromagnetic ﬁeld
and the moment it sends the authentication request. In
practice, this means that an attacker who has physical
control of the tag, can get the tag to send the same
nonce every time. To do so, the attacker just has to
drop the ﬁeld (for approximately 30µs) to discharge all
capacitors in the tag, switch the ﬁeld back on, and wait
for a constant amount of time before authenticating.
Alternatively, by waiting exactly the right amount
of time before authenticating again, the attacker can
control the challenge nonce that the tag will send. This
works whenever the tag does not leave the electromag-
netic ﬁeld in the mean time. On average, this takes
618ms/2 = 309ms.
4
0
1
2
3
4
5
6
7
8
9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
⊕
fa
fb
fb
fc
fa
fb
Figure 2.2. Structure of the CRYPTO1 stream cipher
2.5. Authentication protocol and initialization
Here the ai ∈ F2 are given by
The authentication protocol was reverse engineered
in [GKM+08]. During the anti-collision phase, the tag
sends its uid u to the reader. The reader then asks
to authenticate for a speciﬁc sector. The tag sends
a challenge nT . From this point on, communication
is encrypted, i.e., XOR-ed with the keystream. The
reader responds with its own challenge nR and the
answer aR := suc64(nT ) to the challenge of the tag;
the tag ﬁnishes with its answer aT := suc96(nT ) to
the challenge of the reader. See Figure 2.3. Note that
later on we will send messages aR that deviate from
this protocol; this will be explained in Section 4.
−−−−−−−−−−−−−−−−−−−−−−−−→
−−−−−−−−−−−−−−−−−−−−−−−−→
u
nT
←−−−−−−−−−−−−−−−−−−−−−−−−
{nR}{aR}
{aT }
Tag
Reader
−−−−−−−−−−−−−−−−−−−−−−−−→
Figure 2.3. Authentication protocol
During the authentication protocol, the internal state
of the stream cipher is initialized. It starts out as the
sector key k, then nT ⊕ u is shifted in, then nR is
shifted in. Because communication is encrypted from
nR onwards, the encryption of the later bits of nR
is inﬂuenced by the earlier bits of nR. Authentication
is achieved by reaching the same internal state of the
cipher after shifting in nR.
The following precisely deﬁnes the initialization of
the cipher and the generation of the LFSR-stream
a0a1 . . . and the keystream b0b1 . . . .
Deﬁnition 2.6. Given a key k = k0k1 . . . k47 ∈ F48
2 ,
a tag nonce nT = nT,0nT,1 . . . nT,31 ∈ F32
2 , a
uid u = u0u1 . . . u31 ∈ F32
2 , and a reader nonce
2 , the internal state of
nR = nR,0nR,1 . . . nR,31 ∈ F32
the cipher at time i is αi := aiai+1 . . . ai+47 ∈ F48
2 .
5
ai := ki
∀i ∈ [0, 47]
a48+i := L(ai, . . . , a47+i) ⊕ nT,i ⊕ ui ∀i ∈ [0, 31]
∀i ∈ [0, 31]
a80+i := L(a32+i, . . . , a79+i) ⊕ nR,i
a112+i := L(a64+i, . . . , a111+i)
∀i ∈ N.
Furthermore, we deﬁne the keystream bit bi ∈ F2 at
time i by
bi := f (aia1+i . . . a47+i)
∀i ∈ N.
denote
We
{nR,i}, {aR,i} ∈ F2 by
encryptions
by
{−}
and
deﬁne
{nR,i} := nR,i ⊕ b32+i
{aR,i} := aR,i ⊕ b64+i
∀i ∈ [0, 31]
∀i ∈ [0, 31].
Note that
the ai, αi, bi, {nR,i}, and {aR,i} are
formally functions of k, nT , u, and nR. Instead of
making this explicit by writing, e.g., ai(k, nT , u, nR),
we just write ai where k, nT , u, and nR are clear from
the context.
2.6. Rollback
For our attacks it is important to realize that to
recover the key, it is sufﬁcient to learn the internal state
of the cipher αi at any point i in time. Since an attacker
knows u, nT , and {nR}, the LFSR can then be rolled
back to time zero. This is explained in Section 6.2 of
[GKM+08]; below we show their method translated
into our notation.
Deﬁnition 2.7. The rollback function R : F48
2 → F2 is
deﬁned by R(x1x2 . . . x48) := x5 ⊕ x9 ⊕ x10 ⊕ x12 ⊕
x14 ⊕ x15 ⊕ x17 ⊕ x19 ⊕ x24 ⊕ x25 ⊕ x27 ⊕ x29 ⊕ x35 ⊕
x39 ⊕ x41 ⊕ x42 ⊕ x43 ⊕ x48.
If one ﬁrst shifts the LFSR left using L to generate
a new bit on the right, then R recovers the bit that
dropped out on the left, i.e.,
R(x1x2 . . . x47 L(x0x1 . . . x47)) = x0.
(1)
o
o


o
o




















































Theorem 2.8. In the situation from Deﬁnition 2.6, we
have
a64+i = R(a65+i . . . a112+i)
a32+i = R(a33+i . . . a80+i) ⊕ {nR,i} ⊕
f (0 a33+i . . . a79+i)
ai = R(a1+i . . . a48+i) ⊕ nT,i ⊕ ui
∀i ∈ N