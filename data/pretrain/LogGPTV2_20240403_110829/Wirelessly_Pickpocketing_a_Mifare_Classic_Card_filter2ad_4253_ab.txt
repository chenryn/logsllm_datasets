The physical layer and data link layer of the Mifare
family of cards are described in the ISO standard
7. http://www.proxmark.org/
8. http://www.libnfc.org/
3
that block. The access conditions determine which of
the two keys must be used. See Figure 2.1 for an
overview of the memory of a Mifare Classic tag.
2.3. CRYPTO1
After authentication, the communication between
tag and reader is encrypted with the CRYPTO1 stream
cipher. This cipher consists of a 48-bit linear feed-
back shift register (LFSR) with generating polynomial
x48+x43+x39+x38+x36+x34+x33+x31+x29+x24+
x23 + x21 + x19 + x13 + x9 + x7 + x6 + x5 + 1 and
a non-linear ï¬lter function f [NESP08]. Each clock
tick, twenty bits of the LFSR are put through the ï¬lter
function, generating one bit of keystream. Then the
LFSR shifts one bit to the left, using the generating
polynomial to generate a new bit on the right. See
Figure 2.2 for a schematic representation.
We let F2 = {0, 1} the ï¬eld of two elements (or
the set of Booleans). The symbol âŠ• denotes addition
(XOR).
Deï¬nition 2.1. The feedback function L : F48
2 â†’ F2
is deï¬ned by L(x0x1 . . . x47) := x0 âŠ• x5 âŠ• x9 âŠ• x10 âŠ•
x12 âŠ• x14 âŠ• x15 âŠ• x17 âŠ• x19 âŠ• x24 âŠ• x25 âŠ• x27 âŠ• x29 âŠ•
x35 âŠ• x39 âŠ• x41 âŠ• x42 âŠ• x43.
The speciï¬cs of
the ï¬lter
function are taken
from [GKM+08].
Deï¬nition 2.2. The ï¬lter function f : F48
deï¬ned by
2 â†’ F2 is
f (x0x1 . . . x47) := fc(fa(x9, x11, x13, x15),
fb(x17, x19, x21, x23), fb(x25, x27, x29, x31),
fa(x33, x35, x37, x39), fb(x41, x43, x45, x47)).
2 â†’ F2 and fc : F5
Here fa, fb : F4
2 â†’ F2 are deï¬ned
by fa(y0, y1, y2, y3) := ((y0 âˆ¨ y1) âŠ• (y0 âˆ§ y3)) âŠ• (y2 âˆ§
((y0 âŠ• y1) âˆ¨ y3)), fb(y0, y1, y2, y3) := ((y0 âˆ§ y1) âˆ¨
y2)âŠ•((y0âŠ•y1)âˆ§(y2âˆ¨y3)), and fc(y0, y1, y2, y3, y4) :=
(y0 âˆ¨((y1 âˆ¨y4)âˆ§(y3 âŠ•y4)))âŠ•((y0 âŠ•(y1 âˆ§y3))âˆ§((y2 âŠ•
y3)âˆ¨(y1âˆ§y4))). Because f (x0x1 . . . x47) only depends
on x9, x11, . . . , x47, we shall overload notation and see
f as a function F20
2 â†’ F2, writing f (x0x1 . . . x47) as
f (x9, x11, . . . , x47).
Note that fa and fb here are negated when compared
to [GKM+08] and fc is changed accordingly. The
expressions for fa, fb, and fc given here have the min-
imal number of logical operators in {âˆ§, âˆ¨, âŠ•, Â¬}; in
practice, this allows for a fast bitsliced implementation
of f [Bih97].
For future reference, note that each of the building
blocks of f (and hence f itself) have the property that
it gives zero for half of the possible inputs (respectively
one).
Theorem 2.3. Let Y0, Y1, . . . , Y4 be independent uni-
formly distributed variables over F2. Then
P [fa(Y0, Y1, Y2, Y3) = 0] = 1/2
P [fb(Y0, Y1, Y2, Y3) = 0] = 1/2
P [fc(Y0, Y1, Y2, Y3, Y4) = 0] = 1/2.
Proof. By inspection.
2.4. Tag nonces
For use in the authentication protocol, described
in Section 2.5 below, Mifare Classic tags possess a
pseudo-random generator. In [NP07] it was revealed
that the 32-bit tag nonces are generated by a 16-bit
LFSR with generating polynomial x16 + x14 + x13 +
x11 + 1. Every clock tick the LFSR shifts to the left
and the feedback bit is computed using L16.
Deï¬nition 2.4. The feedback function L16 : F16
of the pseudo-random generator is deï¬ned by
2 â†’ F2
L16(x0x1 . . . x15) := x0 âŠ• x2 âŠ• x3 âŠ• x5.
Let us deï¬ne the function suc that computes the next
32-bit LFSR sequence of the 16-bit LFSR. This func-
tion is used later on in Section 2.5 in the authentication
protocol.
Deï¬nition 2.5. The successor function suc : F32
F32
2
is deï¬ned by
2 â†’
suc(x0x1 . . . x31) := x1x2 . . . x31L16(x16x17 . . . x31) .
Because the period of the pseudo-random generator
is only 65535 and because it shifts every 9.44Âµs, it
cycles in 618ms.
Under similar physical conditions (i.e., do not move
the tag or the reader), the challenge nonce that the tag
generates only depends on the time between the mo-
ment the reader switches on the electromagnetic ï¬eld
and the moment it sends the authentication request. In
practice, this means that an attacker who has physical
control of the tag, can get the tag to send the same
nonce every time. To do so, the attacker just has to
drop the ï¬eld (for approximately 30Âµs) to discharge all
capacitors in the tag, switch the ï¬eld back on, and wait
for a constant amount of time before authenticating.
Alternatively, by waiting exactly the right amount
of time before authenticating again, the attacker can
control the challenge nonce that the tag will send. This
works whenever the tag does not leave the electromag-
netic ï¬eld in the mean time. On average, this takes
618ms/2 = 309ms.
4
0
1
2
3
4
5
6
7
8
9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
âŠ•
fa
fb
fb
fc
fa
fb
Figure 2.2. Structure of the CRYPTO1 stream cipher
2.5. Authentication protocol and initialization
Here the ai âˆˆ F2 are given by
The authentication protocol was reverse engineered
in [GKM+08]. During the anti-collision phase, the tag
sends its uid u to the reader. The reader then asks
to authenticate for a speciï¬c sector. The tag sends
a challenge nT . From this point on, communication
is encrypted, i.e., XOR-ed with the keystream. The
reader responds with its own challenge nR and the
answer aR := suc64(nT ) to the challenge of the tag;
the tag ï¬nishes with its answer aT := suc96(nT ) to
the challenge of the reader. See Figure 2.3. Note that
later on we will send messages aR that deviate from
this protocol; this will be explained in Section 4.
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’
u
nT
â†âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’
{nR}{aR}
{aT }
Tag
Reader
âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’âˆ’â†’
Figure 2.3. Authentication protocol
During the authentication protocol, the internal state
of the stream cipher is initialized. It starts out as the
sector key k, then nT âŠ• u is shifted in, then nR is
shifted in. Because communication is encrypted from
nR onwards, the encryption of the later bits of nR
is inï¬‚uenced by the earlier bits of nR. Authentication
is achieved by reaching the same internal state of the
cipher after shifting in nR.
The following precisely deï¬nes the initialization of
the cipher and the generation of the LFSR-stream
a0a1 . . . and the keystream b0b1 . . . .
Deï¬nition 2.6. Given a key k = k0k1 . . . k47 âˆˆ F48
2 ,
a tag nonce nT = nT,0nT,1 . . . nT,31 âˆˆ F32
2 , a
uid u = u0u1 . . . u31 âˆˆ F32
2 , and a reader nonce
2 , the internal state of
nR = nR,0nR,1 . . . nR,31 âˆˆ F32
the cipher at time i is Î±i := aiai+1 . . . ai+47 âˆˆ F48
2 .
5
ai := ki
âˆ€i âˆˆ [0, 47]
a48+i := L(ai, . . . , a47+i) âŠ• nT,i âŠ• ui âˆ€i âˆˆ [0, 31]
âˆ€i âˆˆ [0, 31]
a80+i := L(a32+i, . . . , a79+i) âŠ• nR,i
a112+i := L(a64+i, . . . , a111+i)
âˆ€i âˆˆ N.
Furthermore, we deï¬ne the keystream bit bi âˆˆ F2 at
time i by
bi := f (aia1+i . . . a47+i)
âˆ€i âˆˆ N.
denote
We
{nR,i}, {aR,i} âˆˆ F2 by
encryptions
by
{âˆ’}
and
deï¬ne
{nR,i} := nR,i âŠ• b32+i
{aR,i} := aR,i âŠ• b64+i
âˆ€i âˆˆ [0, 31]
âˆ€i âˆˆ [0, 31].
Note that
the ai, Î±i, bi, {nR,i}, and {aR,i} are
formally functions of k, nT , u, and nR. Instead of
making this explicit by writing, e.g., ai(k, nT , u, nR),
we just write ai where k, nT , u, and nR are clear from
the context.
2.6. Rollback
For our attacks it is important to realize that to
recover the key, it is sufï¬cient to learn the internal state
of the cipher Î±i at any point i in time. Since an attacker
knows u, nT , and {nR}, the LFSR can then be rolled
back to time zero. This is explained in Section 6.2 of
[GKM+08]; below we show their method translated
into our notation.
Deï¬nition 2.7. The rollback function R : F48
2 â†’ F2 is
deï¬ned by R(x1x2 . . . x48) := x5 âŠ• x9 âŠ• x10 âŠ• x12 âŠ•
x14 âŠ• x15 âŠ• x17 âŠ• x19 âŠ• x24 âŠ• x25 âŠ• x27 âŠ• x29 âŠ• x35 âŠ•
x39 âŠ• x41 âŠ• x42 âŠ• x43 âŠ• x48.
If one ï¬rst shifts the LFSR left using L to generate
a new bit on the right, then R recovers the bit that
dropped out on the left, i.e.,
R(x1x2 . . . x47 L(x0x1 . . . x47)) = x0.
(1)
o
o


o
o




















































Theorem 2.8. In the situation from Deï¬nition 2.6, we
have
a64+i = R(a65+i . . . a112+i)
a32+i = R(a33+i . . . a80+i) âŠ• {nR,i} âŠ•
f (0 a33+i . . . a79+i)
ai = R(a1+i . . . a48+i) âŠ• nT,i âŠ• ui
âˆ€i âˆˆ N