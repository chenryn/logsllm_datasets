• PspCidTable 
• Csrss.exe handle table 
• Csrss.exe internal linked list (unavailable Vista+) 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Takahiro Haruyama -- April 2014, discuss his BH 
Europe 2012 talk with respect to Abort Factors. 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
64bit Process Detection 
•
Earlier presentation for kernel code  
– E.g. CSW14 Diff CPU Page table & Logical kernel objects 
(to  detect  hidden  kernel  modules,  “rootkit  revealer”) 
•
Also uses page tables “Locating  x86 paging structures in 
memory  images”  
https://www.cs.umd.edu/~ksaur/saurgrizzard.pdf 
– Karla Saur, Julian B. Grizzard 
•
New process detection technique is faster - single pass 
– Similar  to  “pmodump”,  enhanced  with  64bit & additional 
checks (64bit scan has much more verifiability) 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
64bit Process Detection Integrity 
•
Not easily attacked 
– Many modifications result in BSOD 
– Able to extract candidate memory for integrity checking of 
memory pages to fully qualify 
• Can  make  “non-abortable”  if  willing  to  do  slower  check 
• Current check is really good 
– Always room to grow with respect to countermeasures 
and performance 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Physical/Virtual Memory 
1 
2 
4 
3 
… 
5 
6 
Page Frames 
4k physical blocks 
A Page Frame Number 
(PFN) is the physical 
memory  “address” 
0 
22000 
40000 
23000 
… 
41000 
42000 
Virtual Address/Pages 
Page protection is applied to 
virtual pages/address ranges  
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
A quick indirection 
•
Slides 37-39 from Dave Probert (Windows Kernel 
Architect, Microsoft) 
– Windows Kernel Architecture Internals 
•
Next  slide  show’s  a  big  hint,  can  you  guess?  It’s  an  
example of process page table layout/configuration. 
– You have  to  love  all  of  those  arrow’s   
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Self Map trick in Linux 
•
Virtual Memory in the IA-64 Linux Kernel 
– Stephane Eranian and David Mosberger 
• 4.3.2 Virtually-mapped linear page tables 
“linear  page tables are not very practical when implemented 
in physical memory” 
“The  trick that makes this possible is to place a self-mapping 
entry in the global directory.” 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Self Map process detection Windows 
AMD64 
•
Self Map exists for each process (not only kernel:)  
•
Examining a page table - !process 0 0  dirbase/cr3 
(e.g. 7820e000) 
!dq 7820e000   
#7820e000 00800000`60917867 
!dq 7820e000+0xf68 
#7820ef68 80000000`7820e863 
     ^-- current PFN found --^         (PFN FTW)  
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
PFN FTW Trick! (or Defensive exploit!!) 
#7820ef68 80000000`7820e863 
                   ^----------^ 
64Bit is a more powerful check 
Valid PFN will be bounded by system 
physical memory constraints 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
These  ARE  the  bit’s  your  looking  for… 
typedef struct _HARDWARE_PTE { 
    ULONGLONG Valid : 1; 
 Indicates hardware or software handling (mode 1&2) 
    ULONGLONG Write : 1;  
    ULONGLONG Owner : 1; 
    ULONGLONG WriteThrough : 1; 
    ULONGLONG CacheDisable : 1; 
    ULONGLONG Accessed : 1; 
    ULONGLONG Dirty : 1; 
    ULONGLONG LargePage : 1;  
 Mode2  
    ULONGLONG Global : 1; 
    ULONGLONG CopyOnWrite : 1; 
    ULONGLONG Prototype : 1;    
 Mode2 
    ULONGLONG reserved0 : 1; 
    ULONGLONG PageFrameNumber : 36;            PFN, always incrementing (mode 1&2) 
    ULONGLONG reserved1 : 4; 
ULONGLONG SoftwareWsIndex : 11;   
 Mode2  
ULONGLONG NoExecute : 1; 
} HARDWARE_PTE, *PHARDWARE_PTE; 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
These are the OFFSETS your looking for. 
•
512 way Table (512 * 8 = 0x1000, a page) 
– PFN Offset 0 configured and valid bit 
– PFN Offset 0x1ed  Point’s  to  self  and  valid  bit 
• This allows us to identify *current position 
•
Mode2 has more checks for typical page table  
•
Mode1 is for heightened assurance 
– Both work together to extract PFN & MEMORY_RUN 
gaps 
– http://blockwatch.ioactive.com/MProcDetect.cs  
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Self Map Detection Attacks 
•
Attacks against performance 
– If we de-tune performance we can validate spoof entries 
and various malformed cases 
– Windows  zero’s  memory  quickly  (no  exiting  processes,  so  
far:) 
•
!ed [physical] can be done to assess evasive 
techniques 
– Simply destroying self map results in BSOD!!  
– Looking for feedback testing to identify better more 
comprehensive PTE flag checks (edge cases, missed 
tables or extra checks) 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Implementation (basically in 1 line) 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Example execution (.vmem starts @0 offset), .DMP (0x2000+) 
or other autodetect header offset  
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Detected Memory Runs 
•
Round value by offset to find gap size, adjust to 
automate memory run detection 
– Takahiro Haruyama blog post on related issue (large 
memory) and also memory run detection issues from 
logical sources 
•
*previous slide, detecting gap, when offset changes; 
– ROUND_UP(0xb4b56000, 0x40000000) = first run end 
0xc0000.. 
–  ROUND_DOWN(0x1181f1000, 0x40000000) 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Detect processes of guests from host 
dump 
•
A host memory dump will include page tables for every 
guest VM process as well as host process entries 
– Lots of room to grow here, deep integration with 
HyperVisor page mapping data may be straight forward 
• E.g. parsing of MMInternal.h / MMPAGESUBPOOL in 
VirtualBox  
•
Issues 
– Hypervisor may not wipe when moving an instance or 
after  it’s  been  suspended  (ghost  processes) 
• I’d  rather  detect  ghosts  than  fail   
•
Nested paging not a problem 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Skew is evident for guest instances.  An typical kernel PFN is observed  
(scream 187 to a mo…) as the first (large jump 0x2..->0x4…)  in  a  range  
of skewed diff values (another layer of decoding to adjust, similar to what 
happens when snapshot is requested and disk memory is serialized) 
Initial values reflective of host system, consistent Diff values  
Final host processes identifiable by Diff realignment  
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Future Weird Machine overload  ?  
•
Microsoft Research 
– Tracking Rootkit Footprints with a Practical Memory 
Analysis System -- Weidong Cui, Marcus Peinado, Zhilei 
Xu, Ellick Chan 
– “The  goal  of  MAS  is  to  identify  all  memory  changes  a  
rootkit  makes….  MAS  does  so  in  three  steps:  static 
analysis, memory traversal and integrity checking” 
•
Seems really hard problem (source code used in MAS), 
how can we verify this level of state? 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Public symbols to the rescue’ish  
•
Public symbols, RTTI or other type inference technique 
to find/root(tree/linked) all pointers 
– Thread stack return into verifiable code 
• Anti RoP Attack 
– Advanced methods kernel pool (does not require source) 
verification 
• Integrity Checking of Function Pointers in Kernel Pools via 
Virtual Machine Introspection 
–
At least kernel alerts, logs and various tracing can be trusted if 
we have code integrity, process/thread detection. 
– Future is not too bad for Defense! 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Summary 
•
Attacks: WeIrD MaChInE 
– Worst case scenario most weird machine activity can 
hopefully be detected through simple tracing, logging and 
monitoring tools 
• What about the next GPU/UEFI backdoor?   use a 
hypervisor guest to establish device/low layer trust capability 
•
Defenses: Detecting hidden 64bit processes  
•
Deep future holds deep verifiability for more devices  (get free 
The Memory Cruncher™  TMC  &  BlockWatch ™  )   
–
Active Protection System (APS) 
•
FINALLY DEFENSIVE FUN & PROFIT! With the D! 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Summary 
•
Always use a VM 
– At least simplify memory dumping 
•
Use ProcDetect  
– Have fun detecting! 
– Process hiding rootkit is dead 
– 64bits helps peace of mind 
•
We can detect a process anywhere (host, guest, 
nested, on the network (probably)! 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Issues, Considerations Caveats 
•
Use a hypervisor – secure the guest/host (very hardened 
host) 
– Hypervisor  escape  ==  you’re  a  high  value  to  risk  nice  exploit 
• Probably NOT YOU! 
• BluePill type attacks, hopeful still to consider (but perf hit of 
nesting should be obvious) 
•
SefMap Detection relies on page table. 
– Maybe  “no paging process”– (same as x86 paging paper) 
– TSS considerations, monitor other tables with stacks? 
– Remote DMA? 
• Please no!  
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Attention Wikipedia editors DKOM   
“Not  only is this very difficult to..” 
We have a high assurance capability, applicable cross 64bit 
platforms (linux/freebsd also arm64,  etc…)  ,  for  process  
detection. 
Even though threads are distinct execution contexts, the 
property of shared MMU configuration establishes a 
verification capability that OS kernel object manipulation can 
not effect. 
IOActive, Inc. Copyright ©2014.  All Rights Reserved. 
Thank you & Questions 
•
I hope I referenced earlier works sufficiently, this topic is 
broad and expansive, thanks to the many security 
professionals who analyze memory, reverse-engineered, 
dove deep and discussed their understanding. 
•
References, follow embedded links and their links