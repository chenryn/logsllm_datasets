title:MPC-Friendly Symmetric Key Primitives
author:Lorenzo Grassi and
Christian Rechberger and
Dragos Rotaru and
Peter Scholl and
Nigel P. Smart
MPC-Friendly Symmetric Key Primitives
Lorenzo Grassi
Graz University of Technology.
Christian Rechberger
Graz University of Technology.
Dragos Rotaru
Dept. of Comp. Sci.,
University of Bristol.
Peter Scholl
Dept. of Comp. Sci.,
University of Bristol.
Nigel P. Smart
Dept. of Comp. Sci.,
University of Bristol.
ABSTRACT
We discuss the design of symmetric primitives, in partic-
ular Pseudo-Random Functions (PRFs) which are suitable
for use in a secret-sharing based MPC system. We consider
three diﬀerent PRFs: the Naor-Reingold PRF, a PRF based
on the Legendre symbol, and a specialized block cipher de-
sign called MiMC. We present protocols for implementing
these PRFs within a secret-sharing based MPC system, and
discuss possible applications. We then compare the per-
formance of our protocols. Depending on the application,
diﬀerent PRFs may oﬀer diﬀerent optimizations and advan-
tages over the classic AES benchmark. Thus, we cannot
conclude that there is one optimal PRF to be used in all
situations.
1.
INTRODUCTION
Secure multi-party computation (MPC) allows a set of
parties to jointly evaluate a function on private inputs, with
the guarantee that no party can learn anything more than
the output of the function.
In the last decade, MPC has
moved from a theoretical pursuit to a very practical ﬁeld, as
protocols have become more eﬃcient and many implemen-
tations been been developed.
For many years now, the de facto benchmark for MPC
systems has been secure computation of the AES function
[41, 23, 24, 39, 35]. Although the actual choice of this func-
tion was originally as a testbed for comparing protocols, it
has often been justiﬁed as “useful”; for example if an appli-
cation needs to evaluate a symmetric encryption scheme or
pseudorandom function (PRF) with a secret-shared key. If
this is indeed required, then there is no particular reason why
AES should be the best choice to work with MPC, compared
with other PRFs or symmetric ciphers. Indeed we contend
that AES is in many ways a very unnatural choice of a PRF
evaluation for use in MPC applications.
In this work, we
conduct a study of some PRFs for use in MPC, including
new protocols for evaluating number-theoretic PRFs, and
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS 2016 Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978332
implementation of “traditional” block cipher candidates de-
signed to have a low complexity in MPC.
1.1 Main Motivating Applications
Before proceeding, we ﬁrst outline some applications we
have in mind. Our focus is on secret sharing based MPC sys-
tems such as that typiﬁed by BDOZ [7], SPDZ [26, 25], and
VIFF [22]; or indeed any classical protocol based on Shamir
Secret Sharing. In such situations data is often shared as
elements of a ﬁnite ﬁeld Fp, of large prime characteristic.
Using such a representation one then has eﬃcient proto-
cols to compute relatively complex functions such as integer
comparison [21], ﬁxed point arithmetic [17], and linear pro-
gramming [16].
Indeed the most famous of such eﬃcient
high level protocols is that needed to compute the output of
an auction [8].
Given such applications, evaluated by an MPC “engine”,
the question arises as to how to get data securely in and out
of the engine. In traditional presentations the data is entered
by the computing parties, and the output is delivered to
the computing parties. However, this in practice will be a
simpliﬁcation. Input and output may need to be securely
delivered/received by third parties, in addition in a long
term reactive functionality the intermediate secure data may
need to be stored in a database, or other storage device.
If we examine the case of long term storage of data, which
is stored by the MPC engine only to be used again at a later
date, the trivial way to store such shared data is for each
party to encrypt their share with a symmetric key, and then
store each encrypted share. However, this incurs an N -fold
increase in storage at the database end (for N MPC servers),
which may be prohibitive. A similar trivial solution also
applies for data input and output, except data input is now
performed using N public keys (one for each MPC server)
and output is performed by each server producing a public
key encryption of its share to the recipient’s public key.
A more eﬃcient solution would be to use a direct eval-
uation of a symmetric key primitive within the MPC en-
gine. Such a symmetric key primitive should be able to
be eﬃciently evaluated by the MPC engine1. We call such
a symmetric key primitive “MPC-Friendly”. Given almost
all symmetric key primitives can be constructed easily from
1Note that public key encryption applications as mentioned
above can be built from the symmetric key key primitives
in the standard KEM-DEM manner. The KEM component
being relatively easy to implement, in most cases, in an MPC
friendly manner. Thus we focus on symmetric key primitives
in this paper.
Pseudo-Random Functions (PRFs), the goal is therefore to
produce an MPC-Friendly PRF.
The main problem of using “traditional” PRFs such as
AES is that these are built for computational engines which
work over data types that do not easily match the operations
possible in the MPC engine. For example AES is very much
a byte/word oriented cipher, which is hard to represent using
arithmetic in Fp. Thus we are led to a whole new area of
PRF design, with very diﬀerent eﬃciency metrics compared
to traditional PRF design.
1.2 Secondary Applications
A simple example application of MPC is to enable dis-
tributed secure storage of long-term cryptographic keys, by
secret-sharing the key and storing each share at a separate
server. When the key is required by an application such
as encryption or authentication, the MPC protocol is used
to compute this functionality.
If this cryptographic func-
tionality is a symmetric cipher, then this application would
be greatly enhanced by using an “MPC-Friendly” symmetric
primitive.
Using traditional symmetric cryptographic primitives di-
rectly on shared data can also improve eﬃciency for some
applications. For example, Laur et al. [33] used an obliv-
ious AES implementation to perform a secure join opera-
tion on a secret-shared database. After obliviously shuﬄing
the database, the (deterministic) AES encryptions are made
public to all parties, so that the join can then be performed
eﬃciently using standard database algorithms.
Lu and Ostrovsky [36] presented a distributed oblivious
RAM protocol, which achieves only O(log N ) overhead, bet-
ter than any ORAM scheme in the non-distributed setting.
This protocol could be combined with a secret-shared MPC
system to provide a mechanism to allow secure computa-
tion of RAM programs. However, the ORAM construction
of [36] makes heavy use of a PRF, so such an application
would require the use of an MPC-Friendly PRF.
For other operational reasons it may be useful to encrypt
data using a special form of encryption such as determin-
istic encryption, searchable symmetric encryption (SSE) or
(leaky) order-revealing encryption (ORE) [9, 10, 18, 6, 14],
under a secret-shared key. These algorithms can enable eﬃ-
cient queries on the encrypted data, whilst the query results
can then be decrypted into shares for more complex pro-
cessing using MPC. For transmission across the wire, to (or
from) an external application, a form of Authenticated En-
cryption (AE) is needed. We note that all of these symmet-
ric primitives (SSE, OPE, AE etc) can be built, in generic
ways, out of a PRF. Thus the main obstacle preventing such
applications is an eﬃcient MPC-Friendly PRF.
1.3 Related Work
Surprisingly there has been little direct work on this prob-
lem, despite the recent plethora of proposed MPC applica-
tions; indeed the only paper we know of which explicitly
designs PRFs for use in MPC, is [4], which we shall discuss
below. The three lines of work most related to the work in
this paper, apart from re-purposing designs from elsewhere,
are
• Low complexity, “lightweight” ciphers for use in IoT
and other constrained environments.
• Block and stream ciphers suited to evaluation by a
Fully Homomorphic/Somewhat Homomorphic encryp-
tion scheme. So called SHE-Friendly ciphers.
• Designs for use in SNARKs.
We now elaborate on the prior work in these areas.
Low Complexity Lightweight Ciphers: Block ciphers
often iterate a relatively simple round function a number of
times to achive security goals. Most early designs in this
domain focused on small area when implemented as a cir-
cuit in hardware. There, large depth (via a large number
of rounds) is of no concern as simply means clocking a cir-
cuit that implements a single round more times. Notable
exceptions are mCrypton[34] and Noekeon[19] which also
feature a relatively low depth. The more recent trend to
emphasize low latency (with designs like PRINCE[11]) ﬁts
much better with our requirement of having low-depth. A
property of all these designs is that they lend themselves
well to implementations where binary NAND gates, XOR
gates, or multiplexers are the basic building blocks in the
used libraries. As explained above the majority of secret
sharing based MPC applications require description via Fp.
Whilst bit operations are possible over Fp using standard
tricks (which alas turn XOR into a non-linear operation),
applying such ciphers would require the Fp data types to be
split into a shared bit representation over Fp to apply the
cipher. Such a conversion is expensive.
SHE-Friendly Ciphers: Perhaps due to the recent theo-
retical interest in SHE/FHE schemes this area has had more
attention than the more practical issues addressed in this pa-
per. The motivating scenario for a SHE-Friendly cipher is
to enable data to be securely passed to a cloud environment,
using a standard encryption scheme, which the cloud server
then homomorphically decrypts to obtain a homomorphic
encryption of the original data.
This line of work has resulted in a handful of designs.
A block cipher called LowMC [4], a stream cipher called
Kreyvium [13] (based on the Trivium stream cipher) and
FLIP [37] (based on a ﬁlter permutation)2. The block cipher
LowMC is designed for both MPC and FHE implementation,
but actually does not meet the MPC design goals we have
set. It does indeed have low depth, but it is a cipher based
on operations in characteristic two. The two SHE friendly
stream cipher designs of Kreyvium and FLIP also suﬀer from
the same problem as the lightweight designs describe above,
as they are also bit-oriented.
SNARK-Friendly Constructions: Being SNARK-friendly
means that the number of constraints is low. This generally
favours larger data types like Fp or F2n , and the depth of the
circuit is of no concern. MiMC [2] was originally designed
for this use case and seems to be the only one in this area.
As the depth is not too high either, we choose it for detailed
evaluation.
1.4 Contributions
The goal of this work is to investigate the eﬃcient evalu-
ation of PRFs in a secret-sharing based MPC setting. 3 We
2FLIP was recently cryptanalysed in [28].
3We leave the construction of the various higher level prim-
itives (SSE, ORE, AE etc.) to future work, although many
of these can easily be constructed directly from a PRF.
(cid:26)
form
F :
present new protocols for secure computation of PRFs, and
implementation results using an actively secure MPC proto-
col, which tolerates up to N − 1 out of N corrupted parties
(with an online phase based on the SPDZ protocol [26, 25]).
To ﬁx notation we will consider a PRF of the following
(Fp)(cid:96) × (Fq)n
(k1, . . . , k(cid:96), x1, . . . , xn)
−→
(cid:55)−→ Fk(x1, . . . , xn).
(Fr)m
The various ﬁnite ﬁelds Fp, Fq and Fr may be distinct. Our
MPC engine is assumed to work over the ﬁnite ﬁeld Fp, as
we always assume the key to the PRF will be a secret shared
value. As a benchmark, we compare all of our candidates
to the baseline AES example used in prior work, and to
implementations of the given PRFs on clear data.
Depending on the precise application, there are several
distinct design criteria which we may want to consider. Thus,
there will not be a one size ﬁts all PRF which works in all
applications. We then have various potential cases:
• In some applications the input is public and we need
to embed the public elements x1, . . . , xn ∈ Fq into Fp.
However, the more general case is when the input is
secret shared itself, and we have Fq = Fp.
• In some applications the output of the PRF will be
public, and thus Fr can be any ﬁeld. In other appli-
cations we also want the output to be secret shared,
so we can use it in some other processing such as a
mode of operation.
In this latter case we will have
Fr = Fp. In addition, some applications, such as when
using the (leaky) ORE scheme presented in [18] require
PRF outputs in {0, 1, 2}, and we may (or may not) re-
quire these to be secret shared (and hence embedded
in Fp).
• In some applications we would like a PRF which is
just eﬃcient in the MPC engine, and we do not care
whether the equivalent standard PRF is eﬃcient or
not.
In other applications we also require that the
standard PRF is also eﬃcient. For example when an
external third party is encrypting data for the MPC
engine to decrypt.
In this paper we consider four candidate PRFs for use in
MPC systems, as well as the comparison case of AES. Two
of these are number theoretic in nature (the Naor-Reingold
PRF, based on DDH, and a PRF based on the Legendre
symbol), whilst MiMC [2] and LowMC [4] are more akin to
traditional symmetric block cipher constructions.