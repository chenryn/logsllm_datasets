structs hmac(cid:48)||pad(cid:48) where pad(cid:48) consists of 32 0x1F bytes.
In the fourth step, it uses hmac(cid:48)||pad(cid:48) to validate contents
of the decrypted message. The validation is, however, per-
formed only over (maxpad + lhmac) = 32 decrypted bytes.
Even though OpenSSL internally computes an HMAC value
hmac(cid:48), this value is completely ignored during the valida-
tion process, the HMAC validation step succeeds, and the
decrypted message is processed further.9 See Figure 6.
in
the
is
processed
The above described functionality obviously results in a
diﬀerent timing behavior. However, further message pro-
cessing results even in a diﬀerent TLS alert message. The de-
crypted message
function
ssl3_get_record, which attempts to remove the padding
and HMAC bytes and computes the new plain message length
rr->length = lm − lhmac − lpad − 1, which is declared as
an unsigned integer. Note that in our case, the decrypted
message consists of 32 bytes, lhmac = 20 and lpad = 31.
Thus, the computation results in an integer underﬂow of
rr->length. This underﬂow is further caught by the valida-
tion of the maximum plaintext length in the same OpenSSL
method:
( r r−>l e n g t h > SSL3 RT MAX PLAIN LENGTH) {
i f
a l = SSL AD RECORD OVERFLOW ;
S S L e r r ( SSL F SSL3 GET RECORD ,
SSL R DATA LENGTH TOO LONG) ;
g o t o f e r r ;
}
This if branch results in a diﬀerent alert message, namely:
RECORD_OVERFLOW. TLS-Attacker detected that this alert mes-
9Note that the same behavior can be observed by sending 32
equal padding bytes pad where lpad > 0x1F. Even though the
padding is incomplete, the implementation only validates
the equality of the 32 decrypted message bytes.
sage diﬀered from the typical BAD_RECORD_MAC alert, and re-
ported a problem after executing the ﬁrst evaluation stage.
In order to trigger the RECORD_OVERFLOW alert, the at-
tacker needs to send a ciphertext which decrypts to 32 equal
bytes. The attacker can exploit this behavior in speciﬁc
BEAST scenarios [30] by controlling 31 bytes of the plaintext
data. In comparison to the previous Botan vulnerability, the
attacker is only able to recover at most 16 subsequent plain-
text data at most because of the CBC mode of operation
properties [52, 54].
The vulnerability was ﬁxed after our disclosure in OpenSSL
1.0.2h / 1.0.1t. It has been labeled CVE-2016-2107.10
Unlucky patch of Lucky 13 in MatrixSSL.
A similar problem with patching the Lucky 13 attack
could be observed in the MatrixSSL library. The develop-
ers of MatrixSSL, however, introduced a much more serious
buﬀer overﬂow vulnerability while attempting to implement
a Lucky 13 countermeasure.
The vulnerability has been patched after our disclosure in
MatrixSSL 3.8.2.
7.2 Bleichenbacher’s Attack on MatrixSSL
In 2014 Meyer et al. [44] analyzed vulnerabilities of TLS
libraries to Bleichenbacher attacks. Most libraries were only
vulnerable to timing attacks at that time.
In this work we could ﬁnd a direct Bleichenbacher vulner-
ability in MatrixSSL. The vulnerable server responds with
a diﬀerent TLS alert (ILLEGAL_PARAMETER) in case the de-
crypted ClientKeyExchange message is correctly formatted
but contains an invalid TLS version number. Otherwise, the
server responds with a DECRYPT_ERROR alert. This kind of
vulnerability was in a fact ﬁrst described by Klima et al. in
2003 [40].
The vulnerability has been patched after our disclosure in
MatrixSSL 3.8.2.
7.3 Missing Length Checks
Our analysis in phase 1 of the second stage revealed inter-
esting results regarding the checks of diﬀerent length vari-
ables. For example, GnuTLS 3.4.9 does not strictly check
the length variables in the following extensions: max frag-
ment length, elliptic curves, EC point format extension, and
signature and hash algorithms extension.
If an invalid length variable is contained in one of these
ﬁelds in the ClientHello message, GnuTLS just proceeds
with the TLS handshake without further message parsing.
We assume this behavior is caused by performance op-
timizations included in the evaluated library. An attacker
could use it for ﬁngerprinting of TLS server library. More-
over, this behavior becomes interesting in light of the very
recent SLOTH attack [20]. By performing this attack, the
attacker attempts to ﬁnd hash collisions for a transcript of
protocol messages. Thereby, he tampers selected handshake
message ﬁelds so that the messages remain valid. Not vali-
dating speciﬁc message ﬁelds gives the attacker more modi-
ﬁcation freedom and improves the attack.
10Commit
https://github.com/openssl/openssl/commit/
70428eada9bc4cf31424d723d1f992baﬀeb0dfb
70428eada9bc4cf31424d723d1f992baﬀeb0dfb:
MMMMMMMMMMMMMMMMMMMMM1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f15017.4 Overﬂows and Overreads
By fuzzing the variables in the ﬁrst and second phases, we
were also able to ﬁnd array boundary vulnerabilities.
Stack overﬂow in OpenSSL-1.1.0-pre1. By fuzzing the
ﬁrst pre-version of the OpenSSL 1.1.0 library (OpenSSL-
1.1.0-pre1), ASan reported a stack overﬂow vulnerability
and the server crashed. Our analysis of the vulnerability
revealed that the stack overﬂow is caused by sending an
overlong DH parameter in the DHClientKeyExchange mes-
sage. TLS-Attacker triggered this bug by a left shift of the
original BigInteger value, as we found in the resulting pro-
tocol ﬂow conﬁguration document:
. . .
41
. . .
When we found this vulnerability (February 2016),
OpenSSL has already published a new version, OpenSSL-
1.1.0-pre2, which did not include this vulnerability. The
OpenSSL security team mentioned in our email correspon-
dence that they knew about this vulnerability internally.11
Since the security vulnerabilities in OpenSSL pre-releases
are not public, we were not aware of this fact.
The vulnerability is not present in any of the newest
OpenSSL release versions (1.0.2g).
Potential buﬀer overread in Botan 1.11.28. Further-
more, we found a buﬀer overread vulnerability in Botan
1.11.28. This vulnerability was found by executing the sec-
ond phase of the fuzzing stage by modifying bytes in the
underlying record layer:
. . .
CLIENT
0
. . .
The resulting protocol ﬂow revealed that by sending an
empty TLS record, the server attempts to use an invalid
array index. The failure is triggered by a randomly selected
conﬁguration of the maximum record length, which is set to
zero with maxRecordLengthConfig.
Even though Botan 1.11.28 does not directly verify the
length of the incoming TLS records, further handshake han-
dlers can successfully reject the message and throw an error.
11The vulnerability has been ﬁxed in the
commit:
e2b420fdd708e14a0b43a21cd2377cafb0d54c02
following
https://github.com/openssl/openssl/commit/
These subsequent veriﬁcations turn the resulting vulnerabil-
ity into a rather harmless buﬀer overread, which only con-
ﬁrms the functionality of TLS-Attacker.
We reported the issue to Botan developers. It has been
patched in Botan 1.11.29.
8. BUILDING A TLS TEST SUITE
The uncovered vulnerabilities have strongly motivated de-
velopers to build TLS test suites with negative tests to val-
idate correct TLS behavior in speciﬁc cases. TLS negative
tests could then have mitigated several vulnerabilities found
in this paper. For example, a padding oracle test suite could
have sent encrypted records with modiﬁed padding contents
to trigger diﬀerent TLS alerts. Developers introducing new
functionality (e.g., Lucky 13 countermeasures) would have
been warned about invalid message processing before releas-
ing new library versions.
We have managed to extend TLS-Attacker with a Test-
Suite module allowing TLS developers to easily build pos-
itive and negative test suites.
In the following section we
describe the usage of assertions with our framework and
present an experimental test suite for cipher suite usage
across TLS protocols. Note that the TLS test suite is a work-
in-progress and this section aims at describing the suitability
of TLS-Attacker for this purpose.
8.1 Usage of Assertions
In order to build comprehensive TLS test suites, we have
extended the TLS-Attacker functionality with assertions. In
particular, we have extended modiﬁable variables with as-
serting values that allow developers to validate resulting con-
tents of modiﬁable variable ﬁelds after the TLS protocol is
executed.
The following listing gives an example of a TLS protocol
ﬂow containing assertions which detect the OpenSSL vul-
nerability:
. . .
CLIENT
3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F
3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F
SERVER
2
20
In this listing we can see a TLS protocol ﬂow setting the
explicit value of the plain padded TLS record to 32 0x3F
bytes. Thus, it potentially triggers a RECORD_OVERFLOW alert
in vulnerable OpenSSL implementations (CVE-2016-2107).
1502After executing the protocol ﬂow, we expect to receive a TLS
alert message. This TLS alert message contains assertions
for the level (2) and description (20) values. This ensures
that the protocol ﬂow only succeeds if the server correctly
responds with a BAD_RECORD_MAC alert message.
Similar test cases can be deﬁned for other cryptographic
attacks or protocol behaviors.
8.2 Experimental Test Suite for Correct Ci-
pher Suite Handling
We have created a proof-of-concept test suite for the val-
idation of correct cipher suite support in TLS protocols.
The test suite takes the available cipher suites and checks
whether they are available for correct protocol versions. For
example, TLS_RSA_WITH_AES_256_CBC_SHA256 must only be
accepted in TLS 1.2 but rejected in other protocol versions.
We also executed the tests with the analyzed frameworks,
detecting that Botan (1.11.30) is not standard-compliant
and that it incorrectly accepts TLS 1.2 cipher suites in TLS
1.0 and 1.1 protocols. This does not pose a direct security
risk. However, using secure cipher suites in older protocols
could possibly undermine their security and should be cor-
rectly handled with the TLS framework.