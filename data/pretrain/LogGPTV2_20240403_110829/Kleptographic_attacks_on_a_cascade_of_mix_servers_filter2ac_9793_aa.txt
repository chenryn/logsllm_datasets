title:Kleptographic attacks on a cascade of mix servers
author:Przemyslaw Kubiak and
Miroslaw Kutylowski and
Filip Zag&apos;orski
Kleptographic Attacks on a Cascade of Mix Servers∗
Przemysław Kubiak
Institute of Mathematics and
Mirosław Kutyłowski
Institute of Mathematics and
Filip Zagórski
Institute of Mathematics and
Computer Science
Wrocław University of
Technology
Computer Science
Wrocław University of
Technology
Computer Science
Wrocław University of
Technology
PI:EMAIL
PI:EMAIL
ﬁPI:EMAIL
ABSTRACT
A cascade of mix servers is a crucial part of e-voting protocols and
other schemes which aim for user’s anonymity. We present klep-
tographic attacks on such cascades. In order to show interesting
consequences, we focus on a cascade used as a building block of
a Prêt à Voter e-voting protocol. However, the attacks might be
generalized to any cascade of probabilistic mix servers.
Categories and Subject Descriptors
C.5 [Computer System Implementation]: Miscellaneous; E.3 [Data
Encryption]: Public key cryptosystems; K.4.1 [Computers and
Society]: Public Policy Issues—Abuse and crime involving com-
puters; K.6.5 [Management of Computing and Information Sys-
tems]: Security and Protection—Invasive software (e.g., viruses,
worms, Trojan horses)
General Terms
Security, Veriﬁcation
Keywords
Kleptography, Cascade of Mix Servers, Anonymity, Electronic Vot-
ing
1.
INTRODUCTION
Designing secure e-voting protocols is one of the most challeng-
ing problems for e-government systems. While there is political
pressure to design and deploy e-voting protocols, security demands
for such systems are particularly high. Even if e-voting has been
started in some countries, security of e-voting technology is still a
challenging problem. Vote selling, manipulation of results, and loss
of privacy become potential and quite probable dangers. Moreover,
the cases of this kind have been reported for many implemented
systems. One of the most important requirements from any elec-
tion protocol is to ensure that votes are cast anonymously.
∗The paper is partially supported by KBN grant 3T11C 011 26
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS’07, March 20-22, 2007, Singapore.
Copyright 2007 ACM 1-59593-574-6/07/0003 ...$5.00.
57
In this paper we focus on some issues that may be categorized as
problems with dishonest implementation of a cascade of anonymiz-
ing mix-servers. So, theoretically, they are irrelevant for people de-
signing e-voting protocols on a high level of abstraction. However,
the point is that such a “layered” approach may lead to severe faults
in e-voting systems. Even if a system is theoretically secure, the
protocol itself can contain some “features” that can lead to totally
insecure implementations. Examples of this kind are shown for in-
stance in [9]. The main corollary is that e-voting systems must be
designed as a whole, where high level and low level details are to
be co-designed.
Kleptography.
Kleptography [28], [29] (for more recent results see [30], [32]
and references given there) is one of the most dangerous generic
techniques of breaking security of cryptographic systems. It works
on code-level - a malicious implementation neither changes the
protocol executed nor can be detected without reverse engineering.
The system’s manufacturer exploits randomness used in the proto-
col to build a trapdoor. The point is that the resulting covert channel
is protected with manufacturer’s public key. Consequently, even if
one reveals a malicious code and data inside a device, encrypted in-
formation which has already been transpired remains inaccessible
to everybody except the holder of the secret key. This makes klep-
tographic attacks superior over a simple subliminal channel. Mind
that thorough reverse engineering of hardware or software might be
very costly, hence it is performed very rarely.
We focus our attention on recent Prêt à Voter (PaV) protocol [24]
(the same scheme is described in [25]). Exactly the same attacks
apply to [23] and [22] as well.
The reason for considering PaV scheme is that this protocol aims
to provide a simple, low cost, but still secure version of Chaum’s
visual voting scheme [4]. Moreover, in these versions of PaV a
cascade of mix servers is used also in ballot card generation proce-
dure, and trapdoors left in such a cascade seem to have even more
interesting consequences.
It is also worth mentioning that another version of PaV – [16],
with multi-party creation of ballots and elements of visual encryp-
tion, suffers from some serious drawback not related with kleptog-
raphy. Namely, the last authority which processes the picture sent
to the voting device for displaying on the screen obviously knows
that picture. This picture is the bottom half of a visual ciphertext of
a permuted list of candidates. The paper [16] states that the second,
complementary half of the ciphertext present on the ballot might be
left to the voter. In such a case trust is put in that last authority, be-
cause a coercer needs to collude only with the authority to be able
to check ballots taken/copied from the voters. Note that for a top
visual ciphertext it is easy to ﬁnd its complement held by the last
authority. All the top bits look random, but for any permutation of
the list of candidates there are some places that are always black
after superimposing the halves of a ciphertext. Hence the coercer
needs to send a sample of about log2 Nv voter’s bits from these
places, where Nv is a number of voters, to allow the colluding au-
thority to quickly identify the right complement, and send it to the
coercer.
PaV serves here as an example for describing our techniques;
most of the methods presented below might be generalized to any
probabilistic (ElGamal) mix-cascade whose mix-servers are sup-
plied by a single dishonest manufacturer.
In Sect. 6 some countermeasures are presented. The main solu-
tion is directly adapted from [2], and is far more ﬂexible than the
one given in [5]. The paper [5] aims for protecting a probabilistic
mix cascade against malware, and assumes that the manufacturer is
honest, so no trapdoor is implemented in the system. Consequently,
kleptographic attacks are not precluded in this model. Moreover,
the solution from [5] can be applied only to disposable mix servers,
i.e. to mix servers that are used to shufﬂe one batch only, not a few
consecutive batches. In Sect. 6 we also point out some small fault
of [5], which makes that solution useless.
Notation.
Throughout the paper Alice and Mallet are, respectively, a voter
and an adversary. BB stands for a bulletin board, N is the number
of elements in a single batch of a mix server, v is the number of
candidates. We use the symbol R to denote some cryptographi-
cally secure pseudorandom bit generator (cf. [18], Def. 5.8), and
H for a collision resistant hash function (cf. [18], Subsect. 9.2.2).
Consequently, R is a one-way deterministic function.
2. THE PRÊT À VOTER SCHEME
2.1 The Ballot Preparation Procedure
There are the following parties in the system [24]:
• clerks – authorities responsible for ballots generation, each
clerk leads a single re-encryption mix server; the paper [24]
implicitly does not distinguish between the clerks and the
servers they supervise; we shall make a distinction between
these two notions, thus we are able to take the role of sys-
tem’s manufacturer into account;
• tellers – authorities responsible for decoding ballots,
• registrars – authorities responsible for delivering lists of can-
didates.
The role of clerks is to provide a batch (or possibly many batches)
of pairs of ElGamal ciphertexts, i.e. of pairs of onions. The plain-
texts contained inside the ciphertexts of the same pair are the same.
Let λ denote the number of mix servers in the cascade. The
procedure of ballot generation looks as follows. The mix server
run by the ﬁrst clerk generates a batch of, say N, pairs of ElGamal
ciphertexts. A single pair has the following form
(gK1,j,R , S1,j · β
K1,j,R
R
) , (gK1,j,T , S1,j · β
K1,j,T
T
)
,
where j = 1, 2, . . . , N, S1,j = gs1,j for s1,j being integers
of small absolute value, and βR = gxR is the public key of the
registrars, βT is the public key of the tellers. More generally, the
mix server of the ith clerk outputs a batch of N pairs of the form:
(gKi,j,R , Si,j · β
Ki,j,R
R
) , (gKi,j,T , Si,j · β
Ki,j,T
T
)
“
“
”
”
.
(1)
58
For every i > 1, the ith server takes its input batch and for each
pair re-computes the ciphertexts:
α
α
gKi,j,α
βKi,j,α
α
Si,j
:= gKi−1,j,α · gki,j,α ,
· βki,j,α
:= βKi−1,j,α
,
:= Si−1,j · gsi,j
t=1 st,j , Ki,j,α =Pi
Pi
(2)
(3)
(4)
for α ∈ {R, T}, random ki,j,α, and small random si,j. Hence
t=1 kt,j,α. After performing steps
Si,j = g
(2) – (4), the last clerk λ sends the ﬁnal batch to election authorities.
Obviously, the correctness of the mixing must be veriﬁed, oth-
erwise the last clerk could, for example, replace the whole input
batch by own pairs of onions. There are a few possibilities to
perform such veriﬁcation: the RPC (Randomized Partial Checking
[13]), the Neff’s shufﬂe [21], or a checksum procedure described
in [10], which might involve the PET (Plaintext Equivalence Test
[12]). Each of these procedures should be performed in public (to
assure the voters of honesty of the whole procedure), and before
voting actually starts (to escape the danger of repeating elections in
the case when something goes wrong). Accordingly, the input and
the output batch of each mix server will be available on BB before
the elections.
2.2 An Attack on the PaV Cascade
We assume that all mix servers in a cascade are from the same
manufacturer, or use software from the same source. On the other
hand, we assume that output batches will be available on BB after
ballot cards generation. This reduces amount of information avail-
able for malicious mix servers (only to its input batch) and so makes
attacks performed during generating voting cards more difﬁcult.
Moreover, we assume that mix servers are run by honest parties.
The attack described in this section takes advantage of a basic
feature of the PaV protocol. Namely, the ﬁrst server generates the
input onions, hence for each entity it knows the whole initial ex-
ponent K1,j,α instead of an initial accretion k1,j,α only. A general
case is addressed in Sect. 3.
We assume that for the sake of kleptographic cooperation each
server holds an ElGamal “public” key Yi = Gxi (public in the
sense that each server i knows the keys Yi−1, Yi+1 of its neigh-
bors). Although multiplicative notation is used here, element G
might be a point of some elliptic curve, or may be freshly taken for
every next batch from a ﬁxed set of two points {G0, G1}, where
Ga ∈ Ea,b for a = 0, 1, and E0,b, E1,b are twisted elliptic curves
deﬁned over a binary ﬁeld (cf. [19], [33]). Such an elliptic curve
key ensures that the attack will not disturb statistical properties of
protocol’s output. If G is an element of some multiplicative group,
then the Probabilistic Bias Removal Method (PBRM) introduced
in [29] might be applied to subliminally transferred values Gk.
Twisted curves or PBRM are helpful, if the hash functions faddress,
fvalue (introduced below) are not protected with key K∗
i .
At ﬁrst we analyze a version of the PaV protocol presented in
Subsect. 7.3 of [23], for which an onion has the form
Oi,j = (gKi,j , Si,j · βKi,j
T
)
(5)
instead of a batch of pairs (1). In the attack each single onion sent
by server i to server i + 1 carries a piece of information on some
element a := Gk, where number k is chosen at random by server i
(Gk is never transmitted as such, for instance as one of two compo-
nents of ElGamal ciphertexts). If it succeeds, then both servers can
compute Gk·xi+1. Indeed, server i+1 gets it by rising Gk to power
i+1. Deﬁne n := blogb ac + 1
xi+1, while server i computes it as Y k
and let (an−1an−2 . . . a0)b be consecutive radix b digits of a. Ob-
i = Gxi·xi+1 is available to both servers
serve also that key K∗
i and i + 1 through Difﬁe-Hellman protocol [6], and an external
observer cannot derive K∗
i . Then also the values of functions
 faddress(x) = H1(x, K∗
fvalue(x) = H2(x, K∗
i ) mod n,
i ) mod b
(6)
for different hash functions H1, H2 are available to servers i and