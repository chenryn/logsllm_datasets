will be necessary to restrict the adversary A where its running time is less than the running
time of the extractor. To conclude, seed-dependent extractors stand for (a) unbounded family
of randomness source, (b) correlated seed and source and (c) limited adversary.
Suppose now that, as opposed to seeded extractors, we do not want to restrict the running time
of the adversary A. As pointed, we need to ensure that independence between the source and
the seed can be ensured. In addition, we want to use the ’extra’ randomness seed in Deﬁnition 4
as less as possible. This leads to the notion of strong extractors, given in Deﬁnition 7, where
the randomness seed is maintained by the extractor, and therefore (a) it can be reused through
successive calls to Extract and (b) it can be made public.
Deﬁnition 7 (Strong Extractors.). A function Extract : {0, 1}p × {0, 1}s → {0, 1}m is a strong
(k, ε)-extractor if for all probabilistic adversaries A who sample a distribution X of entropy
— 18 —
2.7. Leftover Hash Lemma
H∞(X) ≥ k, the distributions (seed, Extract(X, seed)) and (seed,Um) are ε-close, where seed ←
{0, 1}s and X is independent of seed.
This deﬁnition ensures that once random parameter seed is chosen, extraction is processed and
the same parameter can be reused for the next extraction.
Deﬁnition 7 can be expressed in terms of universal hash functions: The hash functions family H
is a (k, ε)-extractor if for any random variable I over {0, 1}p with H∞(I) ≥ k, the distributions
(seed, hseed(I)) and (seed,Um) are ε-close where seed is uniformly random over {0, 1}s. The
Leftover Hash Lemma (Lemma 4) constructively builds a strong extractor from a universal hash
functions family.
We summarize the diﬀerent notions of extractors seen in this section with Table 2.1. The ﬁve
extractor types are given (deterministic, resilient, seed-dependent, seeded, strong) and for each
type, we precise:
1. If the parameter seed shall be independent from the randomness source (which we denote
with symbol ) or can be correlated to it (which we denote with symbol ).
2. If the parameter seed shall remain secret (which we denote with symbol ) or can be made
public (which we denote with symbol ).
3. If existence of an extractor of a given type implies either restriction on the number of
randomness source or a restriction on the capacities of the adversary A (which we denote
with symbol ) or no restriction is needed (which we denote with symbol ).
As shown in Table 2.1, a consequence of Lemma 3 is the impossibility to build an randomness
extractor that posseses ’all’ the properties: for which (a) independence between seed and the
randomness source is not required, (b) secrecy of seed is not required, (c) a restriction on the
number of randomness source or a restriction on the capacities of the adversary A shall be
enforced. This table shows that the use of a randomness extractor in the design of security
Table 2.1 – Tradeoﬀ for Randomness Extractors
Extractor Type
Deterministic
Resilient
Seed-dependent
Seeded
Strong










Correlation Secrecy
seed
∅
Number of Attacker
Sources
Capacities












Impossible (Lemma 3)
∅: no parameter seed is used, : possible correlation, public seed / no restriction on the
source or on A, : independence required, private seed, restrictions on the source or on A.
scheme shall be done with care as any choice seems to have a drawback.
2.7 Leftover Hash Lemma
We present two versions of the Leftover Hash Lemma. The ﬁrst one constructively builds strong
extractors from universal hash functions families and the second one builds resilient extractors
from pairwise independant hash functions families. This important Lemma was ﬁrst formally
stated in [HILL99].
— 19 —
Chapter 2. Preliminaries
Lemma 4 (Leftover-Hash Lemma for Universal Hash Functions Family Family). Assume that
the hash functions family H = {h : {0, 1}p → {0, 1}m} is ρ-universal where ρ = (1 + α)2−m for
some α > 0. Then, for any k > 0, it is also a strong (k, ε)-extractor for ε = 1
2
Proof. We recall the proof described in [Vad12]. Fix any I 6= I0 ∈ {0, 1}p, with H∞(I) ≥ k
and H∞(I0) ≥ k. Fix X ∈ {0, 1}s independently of I and I0 and U
$← {0, 1}m. First consider
the statistical distance between (X, hX(I)) and (X,Um). As in [Vad12], we introduce a second
notion of distance between two random variables X and Y :
2m−k + α.
√
sX
∆2(X, Y ) =
| Pr[X = x] Pr[Y = x]|,
and we deﬁne the collision probability of a random variable X as the probability that two
independent samples of X are equal: CP(X) =P
x
Then we can bound the statistical distance between (X, hX(I)) and (X,Um) by their ∆2 distance:
x Pr[X = x]2.
SD((X, hX(I)), (X,Um)) ≤ 1
2
√
2s · 2m · ∆2((X, hX(I)), (X,Um)),
and we have ∆2((X, hX(I))2 = ∆2((X, hX(I)), (X,Um))2 + 2−m−s.
Now as ∆2((X, hX(I))2 ≤ CP(X) · (PrI[I = I0] + PrX [I 6= I0 | hX(I) = hX(I0)], and as I and
I0 are sampled independently of X, as H∞(I) ≥ k and H∞(I0) ≥ k and as H is 2−m · (1 + α)-
universal:
∆2((X, hX(I))2 ≤ 2−s · (2−k + 2−m · (1 + α))
Finally, with α = 4 · ε2 − 2m−k:
SD((X, hX(I)), (X, U)) ≤ 1
≤ ε
2 · √
2s · 2m ·
s
4 · ε2
2s · 2m
√
2m−k + α.
Following, the hash functions family H = {hX : {0, 1}p → {0, 1}m}X∈{0,1}s, is a (k, ε)-strong
extractor for ε = 1
2
As Lemma 4 shows, it is possible to construct strong extractors from universal hash functions
family. This results motivates the use of such functions to build security schemes that rely
on randomness. Note that in the proof of Lemma 4, the independence between the samples
I, I0 and seed is used to estimate the collision probability of the joint distribution (X, hX(I)):
CP(X, hX(I)) = ∆2((X, hX(I))2. In situations where the independence between the samples
I, I0 and seed can not be ensured, we can prove an alternative version of Lemma 4 with a
stronger requirement: we require that the hash functions family is pairwise independent, to
obtain a resilient extractor. The version of the Leftover-Hash Lemma for pairwise independent
hash functions family can be stated similarly as Lemma 4.
2.8 Pseudo-Random Number Generators
2.8.1 Standard Pseudo-Random Number Generator
A secure pseudo-random number generator is an extending function, that on input a random
bit string S (named a seed), outputs a longer bit string which is indistinguishable from random.
Note that the notion of seed shall not be confused with the notion of seed explained in the
previous section for randomness extractors. Here the parameter seed models a secret, random
input of the pseudo-random number generator.
— 20 —
2.8. Pseudo-Random Number Generators
S
G
R
Figure 2.5 – Standard Pseudo-Random Number Generator
Deﬁnition 8 (Standard Pseudo-Random Number Generator). Let p and ‘ be integers such that
p < ‘. A standard pseudo-random number generator is a function G : {0, 1}p → {0, 1}‘, that
takes as input a bit string S (called a seed), of length p and outputs bit string R, of length ‘ bits.
proc. next-ror
R0 ← G(S)
$← {0, 1}‘
R1
RETURN Rb
proc. initialize
S
$← {0, 1}p;
$← {0, 1};
b
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
Figure 2.6 – Procedures in Security Game PR
Consider the security game PR described in Figure 2.6. In this security game, the challenger
generates a random input S and challenges the adversary A on its capacity to distinguish the real
output of the pseudo-random number generator from random. Deﬁnition 9 formalizes security
for a standard pseudo-random number generator.
Deﬁnition 9 (Security of a Standard Pseudo-Random Number Generator). A standard pseudo-
random number generator is (t, ε)-secure if for any adversary A running in time at most t, the
advantage of A in game PR is at most ε.
2.8.2 Stateful Pseudo-Random Number Generator
A stateful pseudo-random number generator is an iterative and stateful algorithm, that at
each invocation produces some output bits as a function of the current seed and updates the
seed. The associated security property generalizes the security of a standard pseudo-random
number generator, as the adversary is challenged after several iterations of the generator on its
capability to distinguish the output of the generator from random, whereas in Deﬁnition 8, only
one iteration is considered.
Deﬁnition 10 (Stateful Pseudo-Random Number Generator). A stateful pseudo-random num-
ber generator is a couple of algorithms (key, next), where key is a probabilistic algorithm that takes
no input and outputs an initial state S ∈ {0, 1}p, next is a deterministic algorithm that, given
the current state S, outputs a pair (S0, R) ← next(S) where S0 is the new state and R ∈ {0, 1}‘
is the output.
The security game SPR uses procedures described in Figure 2.7. The procedure initialize sets the
ﬁrst internal state S with a call to algorithm key and sets the random parameter b. Procedure
next-ror challenges A on its capability to distinguish the output of the stateful pseudo-random
number generator from random, where the real output (R0) of the stateful pseudo-random
number generator is obtained with a call to algorithm next and the random string (R1) is picked
uniformly at random by the challenger. Attacker A responds to the challenge with a bit b∗. After
— 21 —
Chapter 2. Preliminaries
all oracle queries, A outputs a bit b∗, given as input to the procedure ﬁnalize, which compares
the response of A to the challenge bit b.
proc. next-ror
(S, R0) ← next(S)
$← {0, 1}‘
R1
OUTPUT Rb
proc. initialize
S
$← key;
$← {0, 1}
b
proc. ﬁnalize(b∗)
IF b = b∗ RETURN 1
ELSE RETURN 0
Figure 2.7 – Procedures in Security Game SPR
Deﬁnition 11 (Security of a Stateful Pseudo-Random Number Generator). A stateful pseudo-
random number generator G = (key, next) is (t, ε)-secure, if for any attacker A running in time
at most t, the advantage of A in game SPR is at most ε.
Bellare and Yee [BY03] proposed a new deﬁnition of a stateful pseudo-random number generator,
where the number of outputs the generator is allowed to produce is a parameter of the generator.
This deﬁnition is described inChapter 3.
2.8.3 Pseudo-Random Number Generator with Input
Consider now an iteration of the pseudo-random number generator where, at each iteration,
we let the pseudo-random number generator process a diﬀerent auxiliary input, in addition to
the key. This leads to the notion of pseudo-random number generator with input. Informally,
a pseudo-random number generator with input mixes two diﬀerent processes: the collection of
new inputs and the generation of the output. This idea is illustrated in Figure 2.8.
I0
K0
G
I1
K1
R1
G
. . .
Figure 2.8 – Pseudo-Random Number Generator with Input
Hence, pseudo-random number generators with input model situations where new inputs are
continuously used by the generator. We give in the chapter 3 diﬀerent deﬁnitions for pseudo-
random number generators with input, that we present brieﬂy here:
• In 1998, in two diﬀerent works, Gutmann (in [Gut98]), and Kelsey, Schneier, Wagner
and Hall, (in [KSWH98]) gave useful guidelines for the design of a secure pseudo-random
number generator with input.
• In 2002, in [DHY02], Desai, Hevia and Yin modelled a pseudo-random number generator
with input as an iterative algorithm, which in each iteration take three inputs: a key
K, an internal state S, and an auxiliary input I. The algorithm generates two outputs:
pseudo-random numbers R and a new state S0.
• In 2003, in [BST03], Barak, Shaltiel and Tromer proposed a security model for a pseudo-
random number generator with input where an attacker can have some control on the
— 22 —
2.9. Pseudo-Random Functions
inputs. As we explain, their deﬁnition of pseudo-random number generators with input is
based on the use of resilient extractors.
• In 2005, in [BH05] Barak and Halevi proposed a security model in which a pseudo-random
number generator with input is clearly deﬁned as a couple of deterministic polynomial-
time algorithms G = (refresh, next), where the ﬁrst algorithm refresh models the update of
the internal state S with an input I containing randomness (S ← refresh(S, I)) and the
second algorithm next models the output R generation and the update of the internal state
S during this generation ((S, R) ← next(S)). As before, their deﬁnition of pseudo-random
number generators with input is based on the use of resilient extractors.
In chapters 4, 5 and 6, we present the main contributions of this thesis, which are (a) a new
deﬁnition of pseudo-random number generator with input based on strong extractors and (b)
the formal statement of security properties for pseudo-random number generators with input.
2.9 Pseudo-Random Functions
We recall the deﬁnitions of a pseudo-random function from [BKR94]. A pseudo-random function
is a family of functions such that no adversary can computationally distinguish the input/output
behavior of a random instance from this family from the input/output behavior of a random
function.
Hence in this security model the adversary can give inputs to the function and gets the cor-
responding output in a black-box way. Note that the term random function means function
chosen at random.