As
the
C++
of
In this paper, we consider the type confusion bugs caused by
static_cast and reinterpret_cast. If a base-class
pointer is cast to a derived-class pointer when the underlying
object is incompatible with the derived class (at runtime), then
a type confusion bug is said to have occurred.
Type confusion bugs can be used to corrupt sensitive data,
code pointers or virtual table pointers. How to exploit these
vulnerabilities is beyond the scope of this paper.
B. Pointer Analysis
Pointer analysis, which is virtually the basis of all other
program analyses, determines statically the set of objects that
may be pointed to by a pointer. To achieve precision, a
pointer analysis is expected to be ﬁeld-sensitive [25] (by distin-
guishing different ﬁelds of an object), ﬂow-sensitive [26] (by
distinguishing the ﬂow of control), and context-sensitive [27]
(by distinguishing the calling contexts for a function). A
pointer analysis is a whole-program analysis if it computes the
points-to information for all the pointers and demand-driven
if it computes the points-to information only for some given
pointers in the program.
SVF [17] is an open-source pointer analysis platform for
C/C++ implemented in LLVM [19]. It has been used in a
number of research projects, including a framework for ana-
lyzing Linux kernels [28] and a directed grey-box fuzzer for
software testing [29]. SVF can perform both whole-program
and demand-driven pointer analyses for C/C++ programs [30].
As discussed in Section I, however, SVF cannot be used
directly in detecting type confusion bugs in C++ programs. In
this paper, SVF will be leveraged to accomplish this objective.
C++ Source Code
WLLVM
Type-Aware
Pointer Analysis
Points-to
Query
Points-to 
Information
Type-Casting-Preserving
C++ Compiler Front-End
LLVM-IR
Type Confusion
 Bug Detector
Report
Fig. 3. The TCD framework for detecting type confusion bugs for C++.
III. TCD: DESIGN AND IMPLEMENTATION
We have designed and implemented TCD in LLVM for
detecting type confusion bugs in C++ programs. As shown in
Figure 3, TCD consists of three components: a type-casting-
preserving C++ compiler front-end, a type-aware pointer anal-
ysis and a type confusion bug detector. Given a C++ program,
its source ﬁles are compiled and linked by the LLVM tool
chain into a single LLVM-IR (known as bitcode) with the
type annotations added for all cast-related expressions by our
modiﬁed C++ compiler front-end in LLVM. WLLVM [31], a
python-based compiler wrapper, is used to facilitate building
whole-program LLVM bitcode ﬁles. Our type confusion bug
detector issues a points-to query for a cast expression and then
reports whether the cast is safe or not based on the points-to
information computed on-demand by our type-aware pointer
analysis, which operates on the LLVM-IR of the program.
For a pointed object obj,
represented as (t,!n
ject containing obj and !n
its type information can be
1 offi), where t is the type of the ob-
1 offi is the sum of ﬁeld offsets
accumulated during ﬁeld-sensitive analysis. The code added
into LLVM is used to make sure that t is not missing during
compiling, as discussed in III-A. The code added into SVF will
initialize, accumulate and propagate type information such as
1 offi) during pointer analysis. We respect the negative
offsets caused by complex C++ language features such as
multiple inheritance, which are ignored in previous research.
A. Type-Casting-Preserving C++ Compiler Front-End
(t,!n
When translating a C++ program into LLVM-IR, LLVM
does not maintain all the type information required for de-
tecting type confusion bugs. Below we describe how to rely
on type-annotating stubs to provide such missing type infor-
mation. Without these modiﬁcations, some type information
would be lost. Similarly, we have also added corresponding
stubs for static_cast and reinterpret_cast. These
stubs are introduced to facilitate static analysis only and will
be removed during program execution.
Placement new is widely used in a variety of C++ libraries
and applications, by separating memory allocation from ini-
tialization. In Figure 4(a), ptr in line 6 points to a Derived
object, which is created by a placement new expression at
the speciﬁed memory location buf. However, in the LLVM-
IR in Figure 4(b), generated by the default LLVM even under
-O0, the type Derived for the object created is not available.
Thus, a pointer analysis cannot correctly model the types of
the objects created by such placement new expressions.
(cid:19)(cid:26)(cid:21)
1  struct Base{int x;};
2  struct Derived: public Base{int y;};
3  void test(Base * b);
4  char buf [1024];
5  int main (){
6     Base *ptr = new (buf)Derived;
7     test(ptr);  
8     return 0;
9  }
10 define i32 @main(){
11   call void @_Z4testP4Base(
        %struct.Base* bitcast (
  [1024 x i8]* @buf 
12   ret i32 0
13 }
   to %struct.Base*))
(a) C++ source code
(b) IR generated by the default LLVM
14 !3 = !{%struct.Derived* null}
15 define i32 @main(){
16   %0 = call i8* @__placement_new_stub(i8* getelementptr inbounds 
        ([1024 x i8], [1024 x i8]* @buf, i32 0, i32 0)) !DstTypeInfo !3
17   %1 = bitcast i8* %0 to %struct.Derived*
18   %2 = bitcast %struct.Derived* %1 to %struct.Base*
19   call void @_Z4testP4Base(%struct.Base* %2)
20   ret i32 0
21 }
(c) IR emitted by the modified LLVM
Fig. 4. Placement new stubs annotated with types.
Therefore, we have modiﬁed the LLVM C++ front-end
to emit the LLVM-IR code shown in Figure 4(c). The type
Derived is now made available as metadata (line 14) in a
call to __placement_new_stub() in line 16. This stub
can be modeled as a special memory allocator for a placement
new expression during the pointer analysis, so that an object
of an appropriate type can now be created for the placement
new expression.
B. Type-Aware Pointer Analysis
We have developed our type-aware pointer analysis on
top of the open-source SVF [17]. We describe only how to
enrich SVF with the type information required for ﬁnding type
confusion bugs.
1) Program Representation: For the purposes of perform-
ing pointer analysis, it sufﬁces to consider the following six
types of statements in LLVM-IR: p = &a (ADDROF), p = q
(COPY), p = ∗q (LOAD), ∗p = q (STORE), p = &(q → f ld)
(FIELD), and f p(a1,··· , an) (CALL). Note that f p represents
both a virtual and a static call. Passing arguments into and
returning results from functions are modeled by copies. For
an ADDROF statement p = &a, known as an allocation site, a
is a stack or global variable or a dynamically created abstract
heap object. An array object is analyzed with its elements
collapsed to a single ﬁeld, denoted arr. For example, x[i] = y
can be seen as x.arr = y. For ﬁeld accesses, p = &(q→ f ld)
is used. In LLVM-IR, x = y → f ld is decomposed into
tmp = &(y → f ld) and x = ∗tmp. Similarly, x→ f ld = y is
decomposed into tmp = &(x→ f ld) and ∗tmp = y.
SVF accelerates its analysis by computing the points-to
information along the def-use edges pre-computed by a pre-
v = &obj
t = DeclaredT ype(obj)
obj is a global/local object
{obj} ⊆ pt(v) P OS(obj, (t, 0))
v = &obj
t = Inf erT ype(obj)
obj is a heap object
{obj} ⊆ pt(v) P OS(obj, (t, 0))
p = &(q → ﬂd)
P OS(obj, (t, offl))
obj ∈ pt(q)
offr = Of f set(obj, ﬂd)
{obj.ﬂd} ⊆ pt(p)
P OS(obj.ﬂd, (t, offl + offr))
p = q
pt(q) ⊆ pt(p)
[GLOBAL/STACK]
[HEAP]
[FIELD]
[COPY]
P OS(obj, (t, off))
t′ = GetT ype(t, off)
Type(obj) = t′
[ASSIGNTYPE]
Fig. 5. Type-aware pointer analysis.
analysis rather than along the control ﬂow. Such def-use edges
are often known as value-ﬂow edges.
2) Rules: Figure 5 gives the rules for performing our type-
aware pointer analysis with respect to ADDROF and FIELD.
The rules for LOAD, STORE and CALL are the same as in
traditional pointer analyses such as SVF and thus omitted.
Once the analysis is completed, pt(v) gives the points-to set
(cid:19)(cid:26)(cid:22)
in
of v, i.e., set of objects obj pointed by v, where v is a variable
or a ﬁeld, and Type(obj) gives the type of obj discovered.
Before going through the rules, we will ﬁrst explain one key
notation used in enabling the types of objects to be tracked
in a ﬁeld-sensitive analysis. In C++, an object of a particular
type may contain multiple objects of different types residing
at its different offsets. P OS(obj, (t, off)) indicates that object
obj resides at an offset off in an object of type t, where P OS
is a shorthand for position.
rules
examine
our ﬁve
Below we will
turn.
[GLOBAL/STACK] and [HEAP] are responsible for identifying
the source of the type information. [FIELD] simply propagates
the type information ﬁeld-sensitively, by considering complex
C++ language features such as multiple inheritance. [COPY]
handles copy assignments in the standard way. Finally,
[ASSIGNTYPE] maps each object to its type discovered.
a) [GLOBAL/STACK]: For a global or stack object al-
location site, v = &obj, where obj is created in the global
area or on the stack, t = DeclaredT ype(obj) can be directly
read-off from the declared type of v. In this case, obj ∈ pt(v),
where P OS(obj, (t, 0)) records the type t of obj. For example,
given a local declaration “T x”, x will be made to point to a
stack object of type T in LLVM-IR.
b) [HEAP]: For a heap object allocation site, v =
&obj, where obj is created by calling a heap allocator (e.g.,
malloc()) in LLVM, we have obj ∈ pt(v). In addition,
t = Inf erT ype(obj) is the type of obj inferred as follows.
For standard allocators like malloc(), the types of their
allocated objects are discovered by performing a standard def-
use analysis [17]. For the objects created by placement new
expressions, their types can be discovered from the place-
ment new stubs introduced by our type-casting-preserving
C++ compiler front-end (Figure 4). Finally, the operator
new/new[] functions used in C++ classes will be recognized
as special heap allocators for their corresponding classes.
c) [FIELD]: This rule handles p = &(q → ﬂd). For
the
an object obj ∈ pt(q), suppose that f ld resides at
offset offr within obj, such that P OS(obj, (t, offl)) holds,
then the location of the sub-object obj.f ld in an object
of type t is identiﬁed by (t, offl + offr). So obj.f ld ∈
pt(p), where P OS(obj.ﬂd, (t, offl + offr)) holds. Note that
Of f set(obj, f ld) returns the offset of obj.ﬂd in obj.
In traditional ﬁeld-sensitive pointer analyses
such as
SVF [17], the byte offsets for accessing a ﬁeld in an object
are assumed to be non-negative. However, this assumption
does not hold in the case of multiple inheritance in C++.
Figure 6 illustrates the pointer adjustment that takes place due
to downcasting. A negative offset, −8, is generated. Our type-
aware pointer analysis will keep this negative offset and adjust
internal memory model of pointer analysis to make sure that
the accumulated offset is correct.
d) [COPY]: This rule handles p = q, which simply
propagates the points-to information from q to p, such that
pt(q) ⊆ pt(p) holds.
e) [ASSIGNTYPE]: Once our analysis is completed, the
type of obj, Type(obj), is given by GetT ype(t, off) (deﬁned
AA
BB
B* (cid:198) C*
CC
Downcast
// (B,-8)
%22 = bitcast %struct.B * %19 to i8 *
%23 = getelementptr i8 , i8 * %22 , i64 −8
%24 = bitcast i8 * %23 to %struct.C *
C *
B *
Pointer
Adjustment
0
8
12
Virtual Table 
Virtual Table 
Pointer
Pointer
int y
int y
int z
int z
 C  Object 
C *
B *
Pointer 
Adjustment
-8
0
Out-of-Bound
Out-of-Bound
int y
int y
B  Object
Fig. 6. Negative offsets for accessing ﬁelds in multiple inheritance.
below), where P OS(obj, (t, off)) holds.
In LLVM, inheritance in the high-level C++ source code
is translated into composition in LLVM-IR. Consider the
program in Figure 2 again. A is a base class of C. Thus,
an object of A is contained inside an object of C (with both
starting at the offset 0 as shown), implying that A is a type
nested inside C. Recursively, A can have its own element types.
Hence, at the offset 0 of a C object, its type can be treated