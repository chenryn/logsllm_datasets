21
Based on our analysis, we recommend that Tinkâ€™s streaming encryption follows SE3 instead of
SE1 to resist randomness failure. Moreover, if one has a header to authenticate, one should treat it
as a segmented AD, instead of feeding it to the key-derivation function KD. This also allows one to
instantiate KD via AES, and thus improve both code complexity and efficiency. Finally, one should
use a 256-bit master key to avoid key-collision attacks, but internally, one can still use AES-128 for
both KD (via the DESX1 paradigm) and GCM (by deriving a 128-bit subkey).
Acknowledgement
We thank CCS reviewers for useful feedback, especially for the information that a major application
of Tinkâ€™s streaming encryption is to encrypt large files, which requires random-access decryption.
Viet Tung Hoang was supported in part by NSF grants CICI-1738912 and CRII-1755539. Yaobin
Shen was supported in part by National Key Research and Development Program of China (No.
2019YFB2101601) and China Scholarship Council (No. 201806230107). Part of this work was done
while Yaobin Shen was visiting Florida State University.
References
1. M. Bellare and R. Impagliazzo. A tool for obtaining tighter security analyses of pseudorandom function based
constructions, with applications to PRP to PRF conversion. Cryptology ePrint Archive, Report 1999/024, 1999.
http://eprint.iacr.org/1999/024.
2. M. Bellare, T. Krovetz, and P. Rogaway. Luby-Rackoff backwards: Increasing security by making block ciphers
non-invertible. In K. Nyberg, editor, EUROCRYPTâ€™98, volume 1403 of LNCS, pages 266â€“280. Springer, Heidel-
berg, May / June 1998.
3. M. Bellare and P. Rogaway. The security of triple encryption and a framework for code-based game-playing
proofs. In S. Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 409â€“426. Springer, Heidelberg,
May / June 2006.
4. M. Bellare and B. Tackmann. The multi-user security of authenticated encryption: AES-GCM in TLS 1.3. In
M. Robshaw and J. Katz, editors, CRYPTO 2016, Part I, volume 9814 of LNCS, pages 247â€“276. Springer,
Heidelberg, Aug. 2016.
5. E. Biham. How to decrypt or even substitute DES-encrypted messages in 228 steps. Information Processing
6. P. Bose, V. T. Hoang, and S. Tessaro. Revisiting AES-GCM-SIV: Multi-user security, faster key derivation, and
Letters, 84(3):117â€“124, 2002.
better bounds. In EUROCRYPT 2018, 2018.
7. P. Bose, V. T. Hoang, and S. Tessaro. Revisiting AES-GCM-SIV: Multi-user security, faster key derivation, and
better bounds. In J. B. Nielsen and V. Rijmen, editors, EUROCRYPT 2018, Part I, volume 10820 of LNCS,
pages 468â€“499. Springer, Heidelberg, Apr. / May 2018.
8. S. Chen and J. P. Steinberger. Tight security bounds for key-alternating ciphers. In P. Q. Nguyen and E. Oswald,
editors, EUROCRYPT 2014, volume 8441 of LNCS, pages 327â€“350. Springer, Heidelberg, May 2014.
9. B. Cogliati. Tweaking a block cipher: multi-user beyond-birthday-bound security in the standard model. Designs,
Codes and Cryptography, 86(12):2747â€“2763, 2018.
10. W. Dai, V. T. Hoang, and S. Tessaro. Information-theoretic indistinguishability via the Chi-Squared method. In
CRYPTO 2017, 2017.
11. L. Dorrendorf, Z. Gutterman, and B. Pinkas. Cryptanalysis of the windows random number generator.
In
P. Ning, S. De Capitani di Vimercati, and P. F. Syverson, editors, ACM CCS 2007, pages 476â€“485. ACM Press,
Oct. 2007.
12. Google. Tink library, 2020. https://github.com/google/tink.
13. S. Gueron and Y. Lindell. Better bounds for block cipher modes of operation via nonce-based key derivation. In
B. M. Thuraisingham, D. Evans, T. Malkin, and D. Xu, editors, ACM CCS 2017, pages 1019â€“1036. ACM Press,
Oct. / Nov. 2017.
22
14. N. Heninger, Z. Durumeric, E. Wustrow, and J. A. Halderman. Mining your ps and qs: Detection of widespread
weak keys in network devices. In T. Kohno, editor, USENIX Security 2012, pages 205â€“220. USENIX Association,
Aug. 2012.
15. V. T. Hoang, R. Reyhanitabar, P. Rogaway, and D. VizÃ¡r. Online authenticated-encryption and its nonce-reuse
misuse-resistance. In R. Gennaro and M. J. B. Robshaw, editors, CRYPTO 2015, Part I, volume 9215 of LNCS,
pages 493â€“517. Springer, Heidelberg, Aug. 2015.
16. V. T. Hoang and S. Tessaro. Key-alternating ciphers and key-length extension: Exact bounds and multi-user
security. In M. Robshaw and J. Katz, editors, CRYPTO 2016, Part I, volume 9814 of LNCS, pages 3â€“32. Springer,
Heidelberg, Aug. 2016.
17. V. T. Hoang and S. Tessaro. The multi-user security of double encryption. In J. Coron and J. B. Nielsen, editors,
EUROCRYPT 2017, Part II, volume 10211 of LNCS, pages 381â€“411. Springer, Heidelberg, Apr. / May 2017.
18. V. T. Hoang, S. Tessaro, and A. Thiruvengadam. The multi-user security of GCM, revisited: Tight bounds for
nonce randomization. In CCS 2018, 2018.
19. A. Jha and M. Nandi. Tight security of cascaded lrw2. Journal of Cryptology, pages 1â€“46, 2020.
20. J. Kilian and P. Rogaway. How to protect DES against exhaustive key search. In N. Koblitz, editor, CRYPTOâ€™96,
volume 1109 of LNCS, pages 252â€“267. Springer, Heidelberg, Aug. 1996.
21. T. Krovetz and P. Rogaway. The software performance of authenticated-encryption modes. In A. Joux, editor,
FSE 2011, volume 6733 of LNCS, pages 306â€“327. Springer, Heidelberg, Feb. 2011.
22. A. K. Lenstra, J. P. Hughes, M. Augier, J. W. Bos, T. Kleinjung, and C. Wachter. Public keys. In R. Safavi-Naini
and R. Canetti, editors, CRYPTO 2012, volume 7417 of LNCS, pages 626â€“642. Springer, Heidelberg, Aug. 2012.
23. S. Lucks. The sum of PRPs is a secure PRF. In B. Preneel, editor, EUROCRYPT 2000, volume 1807 of LNCS,
pages 470â€“484. Springer, Heidelberg, May 2000.
24. D. A. McGrew and J. Viega. The security and performance of the Galois/counter mode (GCM) of operation. In
A. Canteaut and K. Viswanathan, editors, INDOCRYPT 2004, volume 3348 of LNCS, pages 343â€“355. Springer,
Heidelberg, Dec. 2004.
25. R. Motwani and P. Raghavan. Randomized algorithms. Cambridge University Press, 1995.
26. N. Mouha and A. Luykx. Multi-key security: The Even-Mansour construction revisited.
In R. Gennaro and
M. J. B. Robshaw, editors, CRYPTO 2015, Part I, volume 9215 of LNCS, pages 209â€“223. Springer, Heidelberg,
Aug. 2015.
27. J. Patarin. The â€œcoefficients Hâ€ technique (invited talk). In R. M. Avanzi, L. Keliher, and F. Sica, editors, SAC
2008, volume 5381 of LNCS, pages 328â€“345. Springer, Heidelberg, Aug. 2009.
28. J. Patarin. Introduction to mirror theory: Analysis of systems of linear equalities and linear non equalities for
cryptography. Cryptology ePrint Archive, Report 2010/287, 2010. http://eprint.iacr.org/2010/287.
29. P. Rogaway, M. Bellare, J. Black, and T. Krovetz. OCB: A block-cipher mode of operation for efficient authen-
ticated encryption. In M. K. Reiter and P. Samarati, editors, ACM CCS 2001, pages 196â€“205. ACM Press, Nov.
2001.
A nOAE Does Not Imply nOAE2
In this section, we will show a canonical online AE scheme ğ›±* that is nOAE-secure, but trivially
broken under the nOAE2 notion. In particular, ğ›± is a variant of the STREAM construction;
its procedures â„°.last and ğ’Ÿ.last are modified to preserve the nOAE security, but damage the
nOAE2 security. The code is given in Fig. 13. The change here is that in â„°.last, in addition to
the ciphertext segment ğ¶0 â† Eğ¾(âŸ¨ğ‘, ğ‘–, 1âŸ©, ğ´, ğ‘€), we will release an additional ciphertext segment
ğ¶1 â† Eğ¾(âŸ¨ğ‘, ğ‘– + 1, 0âŸ©, ğ´, ğ‘€). Procedure ğ’Ÿ.last will attempt to decrypt both ğ¶0 and ğ¶1, and if
both ciphertexts are valid then it returns the decrypted message of ğ¶0.
Releasing ğ¶1 does no harm to nOAE security. Indeed, as ğ¶1 can only be decrypted properly under
nonce âŸ¨ğ‘, ğ‘– + 1, 0âŸ©, the adversary can only use it in a decryption query Dec(ğ‘¢, ğ‘, ğ´, ğ¶, ğ‘) with
ğ¶[ğ‘–+1] = ğ¶1, where ğ‘¢ is the user of the corresponding encryption query. But since decryption is in
order, the adversary will never pass the decryption of ğ¶[ğ‘–], as it does not know any valid ciphertext
segment under nonce âŸ¨ğ‘, ğ‘–, 0âŸ© for user ğ‘¢.
23
procedure â„°.init(ğ¾, ğ‘)
return (ğ¾, ğ‘, 1)
procedure â„°.next(ğ‘†, ğ´, ğ‘€)
(ğ¾, ğ‘, ğ‘–) â† ğ‘†; ğ‘† â† (ğ¾, ğ‘, ğ‘– + 1)
ğ¶ â† Eğ¾(âŸ¨ğ‘, ğ‘–, 0âŸ©, ğ´, ğ‘€)
return (ğ¶, ğ‘†)
procedure â„°.last(ğ‘†, ğ´, ğ‘€)
(ğ¾, ğ‘, ğ‘–) â† ğ‘†
ğ¶0 â† Eğ¾(âŸ¨ğ‘, ğ‘–, 1âŸ©, ğ´, ğ‘€)
ğ¶1 â† Eğ¾(âŸ¨ğ‘, ğ‘– + 1, 0âŸ©, ğ´, ğ‘€)
return (ğ¶0, ğ¶1)
procedure ğ’Ÿ.init(ğ¾, ğ‘)
return (ğ¾, ğ‘, 1)
procedure ğ’Ÿ.next(ğ‘†, ğ´, ğ¶)
(ğ¾, ğ‘, ğ‘–) â† ğ‘†; ğ‘† â† (ğ¾, ğ‘, ğ‘– + 1)
ğ‘€ â† Dğ¾(âŸ¨ğ‘, ğ‘–, 0âŸ©, ğ´, ğ¶)
return (ğ‘€, ğ‘†)
procedure ğ’Ÿ.last(ğ‘†, ğ´, ğ¶)
(ğ¾, ğ‘, ğ‘–) â† ğ‘†; (ğ¶0, ğ¶1) â† ğ¶
ğ‘€ â† Dğ¾(âŸ¨ğ‘, ğ‘– + 1, 0âŸ©, ğ´, ğ¶1)
if ğ‘€ = âŠ¥ then return âŠ¥
else return Dğ¾(âŸ¨ğ‘, ğ‘–, 1âŸ©, ğ´, ğ¶0)
Fig. 13: A variant ğ›±* of the STREAM construction that is nOAE-secure, but trivially broken
under nOAE2. It is built on top of a conventional AE scheme ğ›± = (K, E, D).
In contrast, it is trivial to break the nOAE2 security of ğ›±*. The adversary first calls â„°.init(1, ğ‘),
for an arbitrary nonce ğ‘, to get an index ğ‘—. It then calls â„°.last(1, ğ‘—, ğ´, ğ‘€) for an arbitrary
AD ğ´ and message ğ‘€ to get a ciphertext segment (ğ¶0, ğ¶1). Finally, it makes a decryption query
Dec(1, ğ‘, ğ´, ğ¶,â„, 0), with ğ´ = (ğ´, ğ´) and ğ¶ = (ğ¶1, ğ¶1), and â„ = (2), meaning that it only asks
for a decryption of the second ciphertext segment. The adversary then outputs 1 if the decryption
oracle returns true, and outputs 0 otherwise. Note that in the real world, the first segment of ğ¶ is
invalid but it never gets checked, and the second segment of ğ¶ is decrypted properly. Hence the
adversary wins with advantage 1.
B Key-Collision Attacks
In this section we show how to use Bihamâ€™s key-collision attack on DES [5] to break the (multi-user)
PRF and AE security.
B.1 PRF Attack
Let ğ¹ : {0, 1}ğ‘˜ Ã— â„³ â†’ {0, 1}ğ‘› be a keyed function. Let ğ‘Ÿ be an arbitrary integer such that
ğ‘Ÿ â‰¥ âŒˆ(ğ‘˜ + 2)/ğ‘›âŒ‰. Let ğ‘, ğ‘ â‰¥ 1 be integers such that ğ‘ğ‘ â‰¤ 2ğ‘˜.
The attack. Adversary ğ’œ first picks arbitrary distinct messages ğ‘€1, . . . , ğ‘€ğ‘Ÿ âˆˆ â„³ and then
queries ğ¶ğ‘–,1 â† Eval(ğ‘–, ğ‘€1), . . . , ğ¶ğ‘–,ğ‘Ÿ â† Eval(ğ‘–, ğ‘€ğ‘Ÿ) for every ğ‘– = 1, . . . , ğ‘. It then picks arbitrary
distinct keys ğ¾1, . . . , ğ¾ğ‘ âˆˆ {0, 1}ğ‘˜, and computes ğ¶*
ğ‘—,ğ‘Ÿ â† ğ¹(ğ¾ğ‘—, ğ‘€ğ‘Ÿ) for
every ğ‘— = 1, . . . , ğ‘. If there are ğ‘– â‰¤ ğ‘ and ğ‘— â‰¤ ğ‘ such that ğ¶ğ‘–,â„“ = ğ¶*
ğ‘—,â„“ for every â„“ = 1, . . . , ğ‘Ÿ then the
adversary outputs 1, otherwise the adversary outputs 0.
Real worldâ€™s analysis. In the real world, if there is an adversarial key ğ¾ğ‘— that coincides with
the key of user ğ‘– then the adversary will output 1. Since the user keys are chosen uniformly at
random, this happens with probability
ğ‘—,1 â† ğ¹(ğ¾ğ‘—, ğ‘€1), . . . , ğ¶*
1 âˆ’(ï¸1 âˆ’ ğ‘
)ï¸ğ‘
.
2ğ‘˜
To simplify this bound, we need the following technical result from [17].
24
Lemma 4.
[17] Let ğ‘ â‰¥ 1 be an integer and 0 < ğ‘ â‰¤ 1/ğ‘. Then
(1 âˆ’ ğ‘)ğ‘ â‰¤ 1 âˆ’ ğ‘ğ‘/2 .
ğ‘ğ‘
2ğ‘˜+1 .
Using Lemma 4 with ğ‘ = ğ‘/2ğ‘˜ indicates that in the real world, the chance that the adversary
outputs 1 is at least
Ideal worldâ€™s analysis. Assume that there are no two keys ğ¾ğ‘– and ğ¾ğ‘— such that (ğ¶*
ğ‘–,ğ‘Ÿ) =
(ğ¶*
ğ‘—,ğ‘Ÿ). For real PRF constructions, this assumption is very likely to hold for an appro-
priately large ğ‘Ÿ. In the ideal world, the oracle answers are independent, truly random strings, and
thus the chance that the adversary outputs 1 is at most
ğ‘—,1, . . . , ğ¶*