we describe intuitively the eﬀects of this approximation. First, a send operation
on private channels is never blocking even in case of none matching operation.
This does not correctly model communication in the real system as it might
be reliable (for example transport over TCP). Second, the private channel is a
shared broadcast one. In our case, this is problematic as what is really needed
is a tunnel-like model of communication that simulates peer-to-peer (secure)
channels. The model provided by ProVerif is too broad allowing even honest
agents to read and use messages not destined to them. Therefore, false attack
traces sometimes appear.
4 Session Management
We consider now the procedures that take place after the terminal and MME
have established the KASME by AKA (see Fig. 2). Observe that the terminal has
also informed the MME about which security capabilities it supports (the ATT
message). The security capabilities include lists of encryption and integrity pro-
tection algorithms that the terminal supports. As a consequence, when analyzed
separately, some initialization steps are needed in the protocol models in order
to set up the required security context assumed to be established by AKA.
Formal Analysis of Security Procedures in LTE - A Feasibility Study
351
4.1 NAS Security
NAS security is enabled by a simple request-response procedure [1] (TS 24.301)
that we refer to as the NAS Security Control Procedure NAS SCP (see Fig. 2).
The procedure is initiated by the MME sending a security mode command mes-
sage (NSM) to the terminal. This message indicates the security algorithms cho-
sen by the MME. The message includes a special identiﬁer eksi indicating which
KASME to use as the basis for the key derivation. For various reasons there may
be more than one KASME known simultaneously to the terminal and network [1]
(TS 33.401). The message also contains the list of security capabilities provided
earlier by the terminal.
In response, the terminal veriﬁes that the received security capabilities are
consistent with what the terminal supports. If the veriﬁcation fails, the terminal
rejects the command thus preventing bidding-down attacks. If the veriﬁcation
succeeds, the terminal sends an encrypted and integrity protected completion
message (NSC). All NAS messages are protected from replay attacks by inclusion
of a sequence number (omitted in our models).
Model Description. Figure 4 shows a ProVerif model of the NAS SCP proto-
col. Compared to the AKA model, the novelty in the declaration part consists
in the use of predicates and clauses to model capability sets (lines 6-9). Predi-
cates are declared like constructors and clauses are needed in order to deﬁne the
meaning of the predicates. In our case, we declare a capability set constructor
together with a constant representing the empty set in line 6. Then we use the
predicate of line 7 to model the set membership test function which is deﬁned
below in the clauses of lines 8-9.
Furthermore, the functions used for the shared encryption scheme (lines 4-
5) have been modiﬁed in order to take into account an additional parameter
representing the algorithm to be used.
The main process executes some initialization events then expands and forks
in parallel unbounded number of sessions of two process macros representing
a UE (line 13) and an MME (20). The initialization steps consist in creating
a capability set of two arbitrary algorithms (lines 31-32), disclosing it to the
attacker (33), and ﬁnally creating a secret KASME key (34). The key is supposed
to have been created earlier during an AKA run, while the capabilities should
have been sent by the UE at startup in an attach request. Both parameters are
used as input arguments to the process macros.
The use of predicates is illustrated in line 23. This particular event binds the
variable a : alg to a value that satisﬁes the predicate mem(a, uecaps) in the rest
of the process. Intuitively, this models the MME choosing an algorithm among
the ones supported by the UE. During the analysis ProVerif considers all possible
choices.
Analysis and Discussion. The goal of NAS SCP is to establish the encryp-
tion and integrity keys, KNASenc and KNASint, that are to be used for the NAS
352
N.B. Henda and K. Norrman
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
t y p e i d .
[ p r i v a t e ] .
t y p e c a p s .
f r e e s e c c h : c h a n n e l
f r e e pubch : c h a n n e l .
t y p e k e y . t y p e a l g .
c o n s t NSM, NSC : m s g h e a d e r . c o n s t NASINT , NASENC : b i t s t r i n g .
f u n p s e n c ( a l g , b i t s t r i n g , k e y ) : b i t s t r i n g .
r e d u c f o r a l l a : a l g , x : b i t s t r i n g , y : k e y ; p s d e c ( a , p s e n c ( a , x , y ) , y ) = x .
f u n c o n s s e t ( a l g , c a p s ) : c a p s
p r e d mem( a l g , c a p s ) .
c l a u s e s
f o r a l l x : a l g , y : c a p s ; mem( x ,
f o r a l l x : a l g , y : c a p s , z : a l g ; mem( x , y ) −> mem( x ,
c o n s t e m p t y s e t : c a p s .
t y p e m s g h e a d e r .
c o n s s e t ( z , y ) ) .
c o n s s e t ( x , y ) ) ;
[ d a t a ] .
f u n k d f ( b i t s t r i n g , k e y ) : k e y .
f u n pmac ( a l g , b i t s t r i n g , k e y ) : b i t s t r i n g .
f r e e s e c r e t : b i t s t r i n g [ p r i v a t e ] .
l e t UE( u e c a p s : c a p s , kasme : k e y ) =
f u n k s i ( k e y ) :
i d .
i n ( pubch , (=NSM, =k s i ( kasme ) , =u e c a p s , a : a l g , nasmac : b i t s t r i n g ) ) ;
l e t k n a s i n t : k e y = k d f ( NASINT , kasme )
i f mem( a , u e c a p s ) && nasmac = pmac ( a ,
i n
(NSM, k s i ( kasme ) , u e c a p s , a ) ,
k n a s i n t )
then
l e t k n a s e n c : k e y = k d f (NASENC, kasme )
l e t msg : b i t s t r i n g = ( s e c r e t , pmac ( a ,
out ( pubch ,
i n
(NSC , p s e n c ( a , msg , k n a s e n c ) ) ) . (∗ s e c u r i t y mode c o m p l e t e ∗)
(NSC ,
s e c r e t ) , k n a s i n t ) )
i n
l e t MME( u e c a p s : c a p s , kasme : k e y ) =
i n
e k s i :
i d = k s i ( kasme )
l e t
l e t k n a s i n t : k e y = k d f ( NASINT , kasme )
i n
l e t a : a l g s u c h t h a t mem( a , u e c a p s )
l e t nasmac : b i t s t r i n g = pmac ( a ,
(NSM,
out ( pubch ,
i n ( pubch , (=NSC , p a y l o a d : b i t s t r i n g ) ) ;
l e t k n a s e n c : k e y = k d f (NASENC, kasme )
l e t
i f n a s m a c r = pmac ( a ,
(NSC ,
(NSM,
i n (∗ c o n f i d e n t i a l i t y ∗)
(= s e c r e t , n a s m a cr : b i t s t r i n g ) = p s d e c ( a , p a y l o a d , k n a s e n c )
i n
s e c r e t ) , k n a s i n t )
then 0 .
i n (∗ i n t e g r i t y p r o t e c t i o n ∗)
e k s i , u e c a p s , a , nasmac ) ) ; (∗ s e c u r i t y mode command ∗)
e k s i , u e c a p s , a ) , k n a s i n t )
i n
p r o c e s s
new a1 : a l g ; new a2 : a l g ;
l e t u e c a p s = c o n s s e t ( a1 ,
out ( pubch , u e c a p s ) ;
new kasme : k e y ;
( ( ! UE( u e c a p s , kasme ) )
|
c o n s s e t ( a2 , e m p t y s e t ) )
i n
( !MME( u e c a p s , kasme ) ) )
Fig. 4. NAS security establishment model
protocol between the UE and the MME. In addition to the secrecy and sanity
queries, we consider the following correspondence assertions in order to check
agreement on the established keys and the chosen algorithm.
e v e n t u eR u n n i n g ( a l g , key , key ) . e v e n t ueCommit ( a l g , key , key ) .
e v e n t mmeRunning ( a l g , key , key ) . e v e n t mmeCommit ( a l g , key , key ) .
q u e r y a : a l g , k1 : key , k2 : key ;
q u e r y a : a l g , k1 : key , k2 : key ;
e v e n t ( mmeCommit ( a , k1 , k2 ) ) ==> e v e n t ( u eR u n n i n g ( a , k1 , k2 ) ) .
i n j −e v e n t ( mmeCommit ( a , k1 , k2 ) ) ==> i n j −e v e n t ( u eR u n n i n g ( a , k1 , k2 ) ) .
q u e r y a : a l g , k1 : key , k2 : key ;
q u e r y a : a l g , k1 : key , k2 : key ;
e v e n t ( ueCommit ( a , k1 , k2 ) ) ==> e v e n t ( mmeRunning ( a , k1 , k2 ) ) .
i n j −e v e n t ( ueCommit ( a , k1 , k2 ) ) ==> i n j −e v e n t ( mmeRunning ( a , k1 , k2 ) ) .
ProVerif is able to solve all the properties. The reachability queries are all
falsiﬁed. The secrecy query and the basic correspondence assertions are proven
to hold. However ProVerif reports attack traces on the injective assertions. This
is not surprising as there is nothing in the protocol model that binds the runs
to unique names (no creation of fresh names within the replicated processes). In
fact the traces show that the attacker can falsify injection simply by duplicating
and dropping messages to obtain a run between multiple parallel instances of
MMEs against a single session of a UE and viceversa.
Formal Analysis of Security Procedures in LTE - A Feasibility Study
353
Modifying the model by moving the KASME key creation within the UE pro-
cess and making the MME process read the key from a table leads to ProVerif
proving that one of the direction holds. Intuitively, in the new model each run
of the UE process is bound to a unique fresh key. Observe that this is a diﬀerent
system model since each replication of UE represents a new device rather than
just a rerun of the same one. Furthermore, ProVerif is still able to report an
attack trace for the other direction. This is expected as the modiﬁcations can-
not prevent running in parallel multiple instances of MMEs that use the same
KASME key and that can be matched against a single UE session. Since the
KASME can only be present in one MME at a time, namely the one in which the
UE is registered, it is not possible that two well behaved MMEs would be run-
ning NAS SCP procedures simultaneously. Neither would a well behaved MME
run two NAS SCP procedures simultaneously by itself.
In fact well behaved agents would run the procedures sequentially. This we
could not express in ProVerif. Even if we can express this sequential behavior, the
injective agreement property will not hold. More precisely, assume the MME has
sent two security mode command messages in separate sequential sessions, then
it will not be able to distinguish to which session a reply belongs. This is because
there is no information in the messages that tie them together, like for example
a transaction identiﬁer. It should be pointed out, that if an MME sends the
same information repeatedly in diﬀerent sessions, then regardless of which reply
reaches the MME, the outcome of the whole procedure (algorithm negotiation
and necessary key derivation) will be the same. From this perspective, injective
agreement may not be necessary for this particular procedure.
4.2 RRC Security
Establishment of RRC security is achieved as follows: First, in order to send or
receive data, the terminal needs to establish bearers to carry it. This is achieved
by running a NAS Service Request Procedure with the network [1] (TS 24.301)
and to which we refer by NAS SRP (see Fig. 2). The terminal initiates the
procedure by sending a service request (NSR) to the MME via the eNB. The
radio channel between the UE and the eNB is not secured at this point, but this
is not a problem since the NAS protocol provides its own security.
Upon reception of the request, the MME derives a KeNB from the currently ac-
tive KASME and the message sequence number associated with the NAS message.
The latter parameter ensures that a fresh key is generated every time the pro-
cedure is run. This is necessary to prevent key stream re-use and replay attacks
against the RRC protocol. The MME transfers the KeNB together with the termi-
nal’s security capabilities to the eNB. The eNB sends a command message (RSM)
to the terminal. This command includes the chosen algorithms and is integrity
protected to prevent modiﬁcation of the algorithm selection [1](TS 36.331). When
the terminal receives the command, it derives the necessary keys and replies to the
eNB with an encrypted and integrity protected completion message (RSC). From
this point on, all RRC messages are integrity protected and encrypted, and all
user plane traﬃc is encrypted.
354
N.B. Henda and K. Norrman
Model and Analysis. A ProVerif model of the NAS SRP is provided in Fig. 5.
The declaration part has been removed as it is identical to that of the NAS SCP
model (see Fig. 4) except for some of the message headers and the constants
used in the key derivation function, easily found in the model.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19