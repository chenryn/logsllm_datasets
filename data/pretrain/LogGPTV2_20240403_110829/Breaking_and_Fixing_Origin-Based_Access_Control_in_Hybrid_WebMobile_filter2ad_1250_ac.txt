Web content, hybrid frameworks rely on several layers of
defense. The ﬁrst layer is the same origin policy (SOP) within
the embedded browser (see Section III-A): for example, ads
are conﬁned within iframes and thus prevented by the SOP
from accessing bridges in other frames. The second layer is
the bridge mechanism itself which may be difﬁcult to invoke
from inside an iframe. The third layer is the origin checks
used by the framework’s local half to block bridge access
initiated by unauthorized Web content (see Section VII-B).
The fourth layer is access control within the operating system
(see Section III-B).
A. Conceptual overview
We use the term fracking for any attack that allows
malicious foreign-origin JavaScript to “drill” through the de-
fense layers and gain unauthorized access to device resources.
Several features distinguish fracking vulnerabilities from other
security holes in hybrid and native mobile apps.
First, fracking attacks exploit the mismatches and semantic
gaps between the SOP-based security policy governing the
Web half of hybrid apps and the OS access-control policy gov-
erning their local half—in particular, the hybrid frameworks’
failure to correctly apply the SOP to bridges. Consequently,
fracking vulnerabilities are generic and affect all bridge mech-
anisms in all hybrid frameworks, all embedded browsers, and
all mobile and desktop platforms.
Second, fracking vulnerabilities are not caused by the well-
known weaknesses of access control based on user-granted
permissions, such as the tendency of apps to request
too
many permissions or the failure of users to understand the
consequences of indiscriminately granting permission requests.
Fracking affects hybrid frameworks even on desktop platforms
such as MacOS where access control is not based on user-
granted permissions. Even on Android, the problem is not
simply that the app requests too many permissions (in fact,
8http://comments.gmane.org/gmane.comp.handhelds.phonegap/16406
9http://stackoverﬂow.com/questions/5875083/possible-to-access-phonegap-
api-within-a-iframe
10http://hackerluddite.wordpress.com/2012/04/15/getting-access-to-a-
phones-camera-from-a-web-page/
many legitimate hybrid apps do need these permissions in
order to function correctly), but that these permissions get
exposed to untrusted Web content included in the app.
Third, fracking is not an instance of Android’s permission
re-delegation problem [7, 9]. Fracking vulnerabilities occur
at a different layer of the software stack, where permission-
based local access control meets origin-based Web access
control. Furthermore, hybrid frameworks such as PhoneGap
do not blindly delegate their permissions to untrusted Web
content. They deploy several defenses to prevent “confused
deputy” [14] attacks and to ensure that
local permissions
are only used from the origin to which they were delegated.
Unfortunately, in Section VII we show that these defenses are
largely ineffectual.
Fourth, there is an important distinction between conven-
tional and embedded Web browsers that makes defending
against fracking difﬁcult. Conventional browsers interact with
users. For example, Chrome’s implementation of the WebRTC
API [29], which allows Web content to access local resources
such as camera and microphone, pops a user dialog box every
time an access is attempted. This dialog shows the name of
the requesting domain and asks the user for permission. In
contrast, hybrid frameworks use embedded browsers so that
hybrid apps can automatically access local device resources.
They cannot afford to ask the user for permission on every
access and must rely on programmatic defenses.
B. Technical details
A fracking attack is performed by a malicious script con-
ﬁned within an iframe in the embedded browser. SOP prevents
it from accessing objects in other frames, but does not stop it
from including the hybrid framework’s JavaScript library or
even its own, arbitrarily modiﬁed clone of this library, crafted
to maliciously access the framework’s bridges.
Chosen-bridge attacks are devastating in this setting.
Frameworks like PhoneGap support multiple bridges to and
from local resources. Furthermore, they allow JavaScript on the
Web side to choose a bridge via ‘setNativeToJsBridgeMode’
and ‘setJsToNativeBridgeMode’ functions. These functions are
not intended to be called directly by hybrid apps, since apps are
supposed to access the framework only through the public API,
but they are not protected by the SOP. Therefore, a malicious
script is free to invoke them in order to select a vulnerable
bridge. Consequently, even if some bridges are secure, a single
vulnerable bridge is sufﬁcient to bypass all of the framework’s
defenses. Availability of bridges varies from version to version
even within the same framework, but malicious JavaScript can
determine the version (e.g., via ‘device.cordova’ in PhoneGap
and MoSync) and choose the attack adaptively.
Exploiting interface-based bridges. Any JavaScript object
added to the embedded browser by the framework’s local half
via functions such as ‘addJavascriptInterface’ in Android’s
WebView or ‘ScriptEngine.addExtension’ in BlackBerry is
available by default to JavaScript in any iframe, regardless of
its origin.
Frame
of
interface-based local-to-Web bridges on some platforms.
The
and
‘stringByEvaluatingJavaScriptFromString’
complicates
confusion
the
exploitation
by
used
functions,
‘WebBrowser.InvokeScript’
the
framework’s
local half on iOS and Windows Phone,
respectively,
to inject JavaScript
into browsers, execute it
in the main frame, not the iframe that invoked the bridge.
Therefore, malicious JavaScript inside an iframe cannot see
data returned from the device, but can still cause malicious
side effects through Web-to-local bridges without seeing the
return values, e.g., create or delete contacts, send SMS to
premium numbers, etc.
Exploiting event-based bridges. Event-based local-to-Web
bridges are difﬁcult to use if the framework’s JavaScript library
is running inside an iframe. The events that synchronize the
framework’s Web and local halves are always delivered to the
main frame, even if the handler had been registered from an
iframe, thus preventing the script in the iframe from learning
that the local half is ready with the results (see Section IV-B).
Furthermore, some of the utility JavaScript objects created
by the framework are not accessible to JavaScript
inside
iframes. Because of this, some analyses mistakenly concluded
that event-based bridges cannot be exploited by malicious
JavaScript [19].
This conclusion is false. Modiﬁed, malicious clones of the
framework’s JavaScript library can access local resources via
event-based bridges even when conﬁned in an iframe.
First, if the malicious script inside an iframe cannot receive
synchronization events from the framework’s local half, it can
simply block for a predeﬁned interval until the local half
is ready. In event-based bridges on Android, the Java side
transfers data to JavaScript through the return values of the
‘OnJsPrompt’ handler. Unlike synchronization events, these
values are correctly delivered by the embedded browser to
malicious JavaScript code inside the iframe.
Second, even if the framework’s utility objects are not
visible from an iframe, the main JavaScript objects implement-
ing the bridge are available, and malicious code can access
them directly. For instance, if malicious JavaScript wants to
access the contact list on an Android device via a PhoneGap
bridge, it can (1) call cordova.require(’cordova/exec’) to obtain
a reference to the exec function that invokes the bridge, and
(2) call cordova.require(’cordova/plugin/ContactFindOptions’)
to obtain a reference to the contacts search ﬁlter. The rest of
the code can be cloned from the framework’s own JavaScript
library and will work without modiﬁcations.
Exploiting URL interposition-based bridges. Both meth-
ods for asynchronous URL loading—fetching an invisible
iframe whose source URL encodes the message or issuing an
XMLHttpRequest to an encoded URL—work from inside any
iframe. Malicious JavaScript conﬁned in an iframe can use
either bridge to access the framework’s local half.
VI. FRACKING IN THE WILD
To estimate the prevalence of fracking vulnerabilities in
real-world hybrid applications, we analyzed 7,167 free An-
droid apps built using PhoneGap, currently the most popular
hybrid framework. These apps were identiﬁed in our dataset of
128,000 free apps collected from Google Play between January
18 and March 18, 2013, by the presence of “cordovaVersion”
or “phonegapVersion” in the dexdump of their APK (ﬁle
7
Fig. 3: Read Contacts
Fig. 4: Write Contacts
Fig. 5: Write External Storage
format for Android apps) and the presence of PhoneGap
plugins in “plugins.xml”, “cordova.xml”, or “phonegap.xml”.
We implemented a tool called GapFinder to automatically
extract from each PhoneGap app its (1) local permissions,
(2) a subset of the Web domains whose content is included
in the app, and (3) the domain whitelist, if any. To extract
permissions, GapFinder uses Android’s aapt (Android Asset
Packaging Tool). To ﬁnd domains contributing Web content
to the app, GapFinder uses apktool to reverse-engineer the
APK, extracts HTML ﬁles used by the app, and automatically
crawls each HTML ﬁle to depth 1 using Selenium with a
Google Chrome driver and the browser string overwritten to
mimic a Nexus 4 device. The resulting set of domains is a
conservative underestimate because the app may fetch content
from additional domains reached only by browsing to depth
2 or deeper. Also, with syndicated advertising,
the actual
domains may change from execution to execution.
3,794 apps do not include any external content (such as
iframes, scripts, etc.) in the HTML ﬁles extracted by our tool.
45 apps include only HTTPS content. The remaining 3,328
apps include content from at least one external domain via
HTTP. Their device resources are thus potentially vulnerable
to both Web attackers (hosted at any of these domains) and
network attackers.
Fig. 6: Access Fine Location
Figs. 3 through 6 estimate the exposure of speciﬁc sensitive
resources to Web attackers. For example, Fig. 3 shows that 20
PhoneGap apps expose the ability to read the contacts list on
the device to 20 or more Web domains each. Fig. 4 shows that
19 apps expose the ability to write the contacts list to 20 or
more domains each. Fig. 5 shows that each of 81 apps allows
at least 20 domains to write into the device’s external storage.
Fig. 6 shows that 407 apps expose ﬁne-grained location data
to at least 20 domains each.
All vulnerabilities were empirically conﬁrmed by randomly
sampling the set of vulnerable apps, injecting attack JavaScript
8
into one or more foreign origins included into the app, and
verifying that this JavaScript can successfully access local
device resources.
Figs. 7 and 8 estimate the extent of exposure, i.e., how
many Web domains can access device resources by fracking
a hybrid app. Fig. 7 shows that more than 150 apps expose
their resources to at least 50 Web domains each. Fig. 8 shows
that most external domains have access to between 4 and 6
resources, but some have access to all 16 resources available
in default PhoneGap.
Fig. 9 demonstrates that many apps use third-party plugins.
These plugins expose many more resources than default Phone-
Gap, including ﬁne-grained social-media permissions such as
access to the user’s Facebook and Twitter. More than half of
the apps in our survey incorporate at least 10 different plugins.
Examples of vulnerable PhoneGap apps include ForzeAr-
mate, an app for Italian servicemen which exposes the ability
to write into external storage (among other permissions) to any
domain advertising through Google syndication; the Edinburgh
by Bus app, which exposes external storage to a large number
of obscure Eastern European dating sites; and DrinkedIn
BarFinder, which exposes ﬁne geolocation to domains such as
freelifetimecheating.com, www.babesroulette.com, and many
adult sites. Furthermore, content from all of these domains is
loaded over HTTP and thus vulnerable to network attackers,
who automatically gain access to the app’s local permissions.
VII. EXISTING DEFENSES
A. Relying on the browser
Several hybrid frameworks, including MoSync and Web
Marmalade, rely on the embedded browser to prevent untrusted
Web content from accessing bridges to local resources. Be-
cause the bridges are added to the browser by local code,
they have no Web origin as far as the browser is concerned.
Therefore, malicious Web content from any origin can directly
invoke the bridges, as explained in Section V-B.
All hybrid apps based on any of these frameworks are
generically vulnerable to fracking.
B. Whitelisting authorized domains
Some hybrid frameworks, including PhoneGap and Black-
Berry WebWorks, implement defenses speciﬁcally to prevent
foreign-origin content from accessing bridges (i.e., fracking
attacks). The app creator supplies a whitelist of authorized do-
mains, e.g., the app’s own domain. In PhoneGap, the whitelist
Fig. 7: Foreign-origin content
Fig. 8: Exposure of device resources to for-
eign origins
Fig. 9: Hybrid apps with plugins
is speciﬁed via a platform-speciﬁc conﬁguration ﬁle such as
‘cordova.xml’ or ‘conﬁg.xml’.
Correctly implementing this defense is subtle and error-
prone. The right property is NoBridge (Section III-C): Web
content loaded by the hybrid app from a non-whitelisted origin
should not be able to access the bridge. Instead, the properties
enforced by the actual defenses differ from framework to
framework, platform to platform, and even from bridge to
bridge within the same framework. For example, some Phone-
Gap bridges aim to enforce NoBridge, while other parts of the
same framework aim to enforce a property we call NoLoad: the
hybrid app should not be able to load any Web content from a
non-whitelisted origin. Obviously, NoLoad implies NoBridge,
but it is much coarser and breaks both the user interface and
the business model of many free apps.
C. Enforcing NoLoad
PhoneGap on Android, iOS, and Windows Phone attempts
to enforce the NoLoad property: if the app fetches an HTML
element (e.g., an iframe) from a non-whitelisted domain, the el-
ement is simply not loaded. Main frames from non-whitelisted
domains are opened in the default system browser which
does not have any bridges. Interestingly, event-based bridges
in PhoneGap on Android attempt to enforce the NoBridge
property (see Section VII-E), too, even though NoLoad implies
NoBridge and, had it been implemented correctly, would have
rendered the NoBridge checks in the same code superﬂuous.
Implementations of the NoLoad defense are rife with
errors of two major types: incorrect URL interception and
incorrect URL matching against the domain whitelist.
Android (other than event-based bridges). Before version
2.6, PhoneGap on Android used a WebView callback ‘shoul-
dOverrideUrlLoading’ to intercept
the loading of foreign-
origin content. This callback is not invoked for iframe fetches
or XMLHttpRequests. Therefore, this defense cannot prevent a
hybrid app from loading unauthorized content as, for example,
an ad in an iframe. PhoneGap 2.6, released on April 9, 2013,
uses the ‘shouldInterceptRequest’ callback which correctly in-
tercepts the loading of iframes. This callback is only supported
by Android API 11 or later.
Unfortunately, this implementation intercepts and blocks
the loading of any content from non-whitelisted domains. The
problem is that URL interception in WebView does not provide
any way to distinguish between URLs loaded in the same
origin (e.g., via hscripti tags) and URLs loaded in a foreign
origin (e.g., via hiframei tags). The resulting policy is thus
stricter than the standard same origin policy! The hybrid app
is not only prevented from loading foreign-origin content, but
it cannot even include an external image or JavaScript library,
which is a very common practice.
All tested versions of PhoneGap for Android, including
2.6, incorrectly match intercepted URLs against the whitelist.
PhoneGap uses Java’s regular expression engine and anchors
the expression for each whitelisted domain only at the begin-
ning, but not the end:
this.whiteList.add(Pattern.compile("ˆhttps?://(.*\\.)?" +
origin));
For example, if foo.com is whitelisted, PhoneGap allows
to be loaded from foo.com.evil.com, violating the
content
desired property. A similar observation was made in [19].
HTTP/HTTPS is ignored when checking URLs against the
white list. A network attacker can thus downgrade connec-
tions from HTTPS to HTTP and inject malicious scripts into
whitelisted origins.
iOS. PhoneGap creates a subclass of NSURLProtocol named
CDVURLProtocol to intercept URLs loaded in UIWebView
and check whether the URL is whitelisted. UIWebView suffers
from the same problem as WebView and the resulting policy
is stricter than the same origin policy.
PhoneGap on iOS only allows domain names to be speci-