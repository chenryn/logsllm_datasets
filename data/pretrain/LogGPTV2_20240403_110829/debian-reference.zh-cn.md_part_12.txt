command1 || command2
command1或command2执行成功，返回success）
command > foo 将command的标准输出重定向到文件foo（覆盖）
command 2> foo 将command的标准错误重定向到文件foo（覆盖）
command >> foo 将command的标准输出重定向到文件foo（附加）
command 2>> foo 将command的标准错误重定向到文件foo（附加）
command > foo 2>&1 将command的标准输出和标准错误重定向到文件foo
command foo
$ exec 3bar # open files
$ cat &4 # redirect stdin to 3, stdout to 4
$ exec 3&- # close files
$ cat bar
Hello
预定义的文件描述符0-2。
设备 说明 文件描述符
stdin 标准输入 0
stdout 标准输出 1
stderr 标准错误 2
Table1.24: 预定义的文件描述符
1.5.9 命令别名
你可以为经常使用的命令设置一个别名。
尝试下列例子
$ alias la=’ls -la’
现在，“la”是“ls -al”的简写形式，并同样会以长列表形式列出所有的文件。
你可以使用alias来列出所有的别名（参见bash(1)中的“SHELLBUILTINCOMMANDS”）。
$ alias
...
alias la=’ls -la’
你可以使用type来确认命令的准确路径或类型（参见bash(1)中的“SHELLBUILTINCOMMANDS”）。
尝试下列例子
$ type ls
ls is hashed (/bin/ls)
$ type la
la is aliased to ls -la
$ type echo
echo is a shell builtin
$ type file
file is /usr/bin/file
ls在最近被使用过，而“file”没有，因此“ls”标记为“hashed”（被录入哈希表），即shell有一个内部的记录用
来快速访问“ls”所处的位置。
提示
参见第 9.3.6 节。
1.6 类 Unix 的文本处理
在类Unix的工作环境中，文本处理是通过使用管道组成的标准文本处理工具链完成的。这是另一个重要的Unix创新。
Debian参考手册 30/233
1.6.1 Unix 文本工具
这里有一些在类Unix系统中经常使用到的标准文本处理工具。
• 没有使用正则表达式：
– cat(1)连接文件并输出全部的内容。
– tac(1)连接文件并反向输出。
– cut(1)选择行的一部分并输出。
– head(1)输出文件的开头。
– tail(1)输出文件的末尾。
– sort(1)对文本文件的行进行排序。
– uniq(1)从已排序的文件中移除相同的行。
– tr(1)转换或删除字符。
– diff(1)对文件的行进行对比。
• 默认使用基础正则表达式（BRE）：
– ed(1)是一个原始行编辑器。
– sed(1)是一个流编辑器。
– grep(1)匹配满足pattern的文本。
– vim(1)是一个屏幕编辑器。
– emacs(1)是一个屏幕编辑器。（有些扩展的BRE）
• 使用扩展的正则表达式（ERE）：
– awk(1)进行简单的文本处理。
– egrep(1)匹配满足多个pattern的文本。
– tcl(3tcl)可以进行任何你想得到的文本处理：参见re_syntax(3)。经常与tk(3tk)一起使用。
– perl(1)可以进行任何你想得到的文本处理。参见perlre(1)。
– pcregrep软件包中的pcregrep(1)可以匹配满足Perl兼容正则表达式（PCRE）模式的文本。
– 带有re模块的python(1)可以进行任何你想得到的文本处理。参见“/usr/share/doc/python/html/index.html”。
如果你不确定这些命令究竟做了什么，请使用“man command”来自己把它搞清楚吧。
注意
排序的顺序和表达式的范围取决于语言环境。如果你想要获得一个命令的传统行为，可以使用“LANG=C”或
C.UTF-8语言环境代替原来的UTF-8语言环境（参见第 8.1 节）。
注意
Perl正则表达式（perlre(1)）、Perl兼容正则表达式（PCRE）和Python的 re模块提供的正则表达式与一般
的ERE相比多了许多通用的扩展。
Debian参考手册 31/233
BRE ERE 正则表达式的描述
\ . [ ] ^ $ * \ . [ ] ^ $ * 通用的元字符
\+ \? \( \) \{ \} \| BRE独有的“\”转义元字符
+ ? ( ) { } | ERE独有的不需要“\”转义的元字符
c c 匹配非元字符“c”
匹配一个字面意义上的字符“c”，即使
\c \c
“c”本身是元字符
. . 匹配任意字符，包括换行符
^ ^ 字符串的开始位置
$ $ 字符串的结束位置
\ \> 单词的结束位置
[abc…] [abc…] 匹配在“abc...”中的任意字符
[^abc…] [^abc…] 匹配除了“abc...”中的任意字符
r* r* 匹配零个或多个“r”
r\+ r+ 匹配一个或多个“r”
r\? r? 匹配零个或一个“r”
r1\|r2 r1|r2 匹配一个“r1”或“r2”
匹配一个“r1”或“r2“，并作为括号内
\(r1\|r2\) (r1|r2)
的正则表达式
Table1.25: BRE和ERE中的元字符
1.6.2 正则表达式
正则表达式被使用在许多文本处理工具中。它们类似shell的通配符，但更加复杂和强大。
正则表达式描述要匹配的模式，它是由文本字符和元字符构成的。
元字符仅仅是带有特殊含义的字符。它们有两种主要的形式，BRE和ERE，使用哪种取决于上述的文本工具。
emacs中的正则表达式基本上是BRE但含有ERE中的元字符“+”和“?”。因此，在emacs中没必要使用“\”来
转义它们。
grep(1)可以使用正则表达式来进行文本搜索。
尝试下列例子
$ egrep ’GNU.*LICENSE|Yoyodyne’ /usr/share/common-licenses/GPL
GNU GENERAL PUBLIC LICENSE
GNU GENERAL PUBLIC LICENSE
Yoyodyne, Inc., hereby disclaims all copyright interest in the program
提示
参见第 9.3.6 节。
1.6.3 替换表达式
对于替换表达式，一些字符有特殊的含义。
对Perl替换字符串来说，应使用“$&”而非“&”，应使用“$n”而非“\n”。
尝试下列例子
$ echo zzz1abc2efg3hij4 | \
sed -e ’s/\(1[a-z]*\)[0-9]*\(.*\)$/=&=/’
zzz=1abc2efg3hij4=
Debian参考手册 32/233
替换表达式 替换表达式替换的文本
& 正则表达式所匹配的内容（在emacs中使用\&）
\n 前n个括号的正则表达式匹配的内容（“n”是数字）
Table1.26: 替换表达式
$ echo zzz1abc2efg3hij4 | \
sed -e ’s/\(1[a-z]*\)[0-9]*\(.*\)$/\2===\1/’
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
perl -pe ’s/(1[a-z]*)[0-9]*(.*)$/$2===$1/’
zzzefg3hij4===1abc
$ echo zzz1abc2efg3hij4 | \
perl -pe ’s/(1[a-z]*)[0-9]*(.*)$/=$&=/’
zzz=1abc2efg3hij4=
请特别注意这些括号正则表达式的格式，以及这些被匹配的文本在不同的工具中是如何被替换的。
这些正则表达式在一些编辑器中也可以用来移动光标和替换文本。
在shell命令行行末的反斜杠“\”会跳脱一个换行符（作为空白符），并将光标移动到下一行的行首。
请阅读所有相关手册来学习这些命令。
1.6.4 正则表达式的全局替换
ed(1)命令可以在“file”中将所有的“FROM_REGEX”替换成“TO_TEXT”。
$ ed file <<EOF
,s/FROM_REGEX/TO_TEXT/g
w
q
EOF
sed(1)命令可以在“file”中将所有的“FROM_REGEX”替换成“TO_TEXT”。
$ sed -i -e ’s/FROM_REGEX/TO_TEXT/g’ file
vim(1)命令可以通过使用ex(1)命令在“file”中将所有的“FROM_REGEX”替换成“TO_TEXT”。
$ vim ’+%s/FROM_REGEX/TO_TEXT/gc’ ’+w’ ’+q’ file
提示
上面的“c”标志可以确保在每次替换时都进行交互式的确认。
多个文件（“file1”，“file2”和“file3”）可以使用vim(1)或perl(1)通过正则表达式进行类似的处理。
$ vim ’+argdo %s/FROM_REGEX/TO_TEXT/ge|update’ ’+q’ file1 file2 file3
提示