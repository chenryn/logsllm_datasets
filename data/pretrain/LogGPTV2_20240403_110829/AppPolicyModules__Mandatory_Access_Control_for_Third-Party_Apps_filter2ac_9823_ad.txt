shows two new avTypes dolphin app and dolphin app incogni-
to, associated with distinct privileges.
Requirement Req4 (S→A), Protection from external threats
is supported by the same example: without an explicit rule
giving permission, a process associated with untrusted app
is not authorized to access ﬁles associated with dolphin app.
7. MAPPING ANDROID PERMISSIONS
The introduction of appPolicyModules improves the deﬁ-
nition and enforcement of the security requirements associ-
ated with each app. However, in the approach presented in
the previous section, we assumed that the extension to the
MAC policy has to be deﬁned by the developer, who knows
the service provided by the app and its source code. Due
to the size of the community, we can expect that many app
developers will either be unfamiliar with the SELinux syn-
tax and semantics, or know SELinux but not want to use it,
avoiding the introduction of strict security boundaries to the
app beyond those associated with untrusted app. There is
also the risk generated by the presence in devices of a variety
of versions of the system policy and the need to guarantee
that the appPolicyModule is compatible with it.
However, we observe that the app developers that can be
expected to be most interested in using the services of the
MAC model are expert developers responsible for the con-
struction of critical apps (e.g., apps for secure encrypted
communication, or for key management, or for the access to
ﬁnancial and banking services). This community is possi-
bly small, but their role is extremely critical. They can be
expected to overcome the obstacles to the use of appPolicy-
Figure 2: Generation of the Dolphin browser app-
PolicyModule starting from the permissions in the
app manifest.
Modules. In addition, the deployment of the policy modu-
larity services opens the door to a number of other services.
We consider here how it is possible to use them to enforce a
stricter model on the management of Android permissions,
relying on the automatic generation of appModulePolicies,
solving all the issues identiﬁed above.
In fact,
Looking at the workﬂow to build an app, developers are
already familiar with the deﬁnition of security requirements
in the AndroidManifest.xml, through the use of the tag uses-
permission.
in order to access system resources
(e.g., access to the user’s current location) the app has to
explicitly request the associated Android permissions (e.g.,
android.permission-group.LOCATION), which correspond
both to a set of concrete actions at the OS level and to a set
of avPermissions granted at the SELinux level (e.g., open,
read on ﬁles and directories). The system already oﬀers both
a high-level representation and a low-level representation of
the privileges needed to access a resource, but they are not
integrated and what happens, in the absence of policy mod-
ularity, is that the app is associated with the untrusted app
domain, which is allowed to use all the actions that corre-
spond to the access to all the resources that are invokable
by apps, essentially using for protection only Android per-
missions. The integration of security policies at the Android
permission and MAC levels oﬀers a more robust enforcement
of the app policy.
This can be realized introducing a mechanism that bridges
the gap between diﬀerent levels, through the analysis of
the high-level policy (i.e., the permissions asked by the app
within the Android Permission Framework) and the auto-
matic generation of an appPolicyModule that maps those
Android permissions to a corresponding collection of SELinux
statements. The generator starts from the representation
of the app security requirements expressed in the Android-
Manifest.xml, builds a logical model of the structure of the
appPolicyModule, and it ﬁnally produces the concrete imple-
mentation of the appPolicyModule and veriﬁes that all the
security restrictions are satisﬁed.
A necessary step in the construction of the mechanism
is the identiﬁcation of a mapping between policies at the
distinct levels. The Android Permission Framework con-
tains more than 200 permissions and most of them present
a mapping between the Android permission and a dedicated
SELinux domain, already speciﬁed in the system policy. The
current system policy does not cover all the permissions; e.g.,
the downloads, calendar, and media content resources are
associated with the single platform app data ﬁle type. We
expect this aspect to be manageable with a revision of the
module dolphin 1.0.0;require {type untrusted_app;attribute domain;attribute appdomain;attribute netdomain; }type dolphin_app;typebounds dolphin_app untrusted_app;typeattribute dolphin_app, domain;typeattribute dolphin_app appdomain;typeattribute dolphin_app netdomain;AndroidManifest.xmlappPolicyModuleHEADBODYpolicy. However, there is a number of Android permissions
that can only be partially supported by this mechanism due
to current limitations in the security mechanisms provided
by internal components (e.g., SQLite).
To summarize, it is already possible to capture most An-
droid permissions in a precise way and some of them with
some leeway, leading in all cases to a signiﬁcant reduction in
the size of the MAC domain compared to what would other-
wise be associated with an app. We provide in Figure 2 an
example of the appPolicyModule that would be generated
for the Dolphin browser described in Section 3.1. We note
that every app will have to be associated with the domain
and appdomain attributes, which provide all the basic privi-
leges required to let an app execute in the system. The head
of the module will then have to introduce the require dec-
larations that specify this attribute, together with the un-
trusted app type and the netdomain attribute. The body of
the module introduces the dolphin app type, the typebounds
and all the MAC privileges required to access the network
and other resources/services. Due to the current SELinux
policy structure the access to the ACCOUNTS, LOCATION
MICROPHONE and CAMERA services are mitigated by
the system server. The system server is the core of the An-
droid system which manages most of the framework ser-
vices. The access to the requested services is granted by
the system server to the appdomain type and through the
use of the rule typeattribute dolphin app appdomain the dol-
phin app type inherits these privileges.
In general, with the availability of appPolicyModules, the
system could evolve from a scenario where each app is given
at installation time access at the SELinux layer to the whole
untrusted app domain, to a scenario where each app is as-
sociated with the portion of untrusted app domain that is
really needed for its execution, with a better support of the
classical “least-privilege” security principle.
8.
IMPLEMENTATION
The work done by Smalley et al.
in [15] represents the
basis for our work. We have introduced a set of extensions
in order to enrich the current implementation and manage
appPolicyModules. We now provide a description of the
challenges to enable the concrete use of appPolicyModules
in Android. The system has been implemented with an open
source license, extending the current version 4.4.4 of the
AOSP (link omitted for the anonymity constraints); adap-
tation to Android L is planned as soon as it will be released.
The current SELinux implementation for Android spans
diﬀerent levels of the Android stack. At the Application
Framework level, the SELinux class provides access to the
centralized Java Native Interface (JNI) bindings for SELinux
interaction. The android os SELinux.cpp ﬁle represents the
JNI bridge. At the Libraries level, the SELinux implemen-
tation consists of the libsepol and libselinux libraries. The
former provides an API for the manipulation of SELinux
binary policies. The latter provides the APIs to get and
set process and ﬁle security contexts and to obtain security
policy decisions.
The ﬁrst challenges to the integration of appPolicyMod-
ules in Android appeared in the adaptation of the current
SELinux libraries and in the addition of the libraries needed
to build, link and check the appPolicyModules. These li-
braries are part of the full SELinux environment and are in-
cluded in the major Linux distributions, but the activation
Figure 3: appPolicyModule Architecture.
of policy modules in SELinux for Android required more
than a simple cross-compilation.
8.1 Changes to SELinux
The work we did at the SELinux level can be structured
into four major activities.
First, the libselinux library was modiﬁed with the intro-
duction of additional features needed by the libsemanage
library, such as the selinux-conﬁg.c module. We modiﬁed
the checkpolicy tool in order to build automatically the bi-
nary policy at version 26 (standard SELinux implementa-
tions support version 29 of the binary policy). In the current
SEAndroid implementation the binary policy version range
is between 15 and 26. This constraint is enforced by the
load policy method when a policy reload is triggered.
Second, the libsemanage library, which provides APIs for
the manipulation of SELinux binary policies and binary pol-
icy modules, was adapted to fulﬁll the new requirements.
Due to the diﬀerences in scenario, architecture and require-
ments, some functions, such as the genhomedircon service,
were disabled. The genhomedircon service is used to gener-
ate ﬁle context conﬁguration entries for user home directo-
ries based on their default roles and is run when building the
policy. However, in Android, though there is the possibility
to create several users for a single device, they do not have
a home directory.
Third, the source code of the semodule executable was
extended in order to correctly interact with the modiﬁed
version of the libsemanage library. The semodule tool is used
to manage SELinux policy modules, including installation,
upgrade, listing and removal of modules. The semodule tool
may also be used to force a rebuild of the policy from the
module repository and/or to force a reload of the policy
without performing any other transaction.
Figure 3 shows an abstract representation of the complete
architecture introduced in order to manage the appPolicy-
Modules. Fourth, in addition to the modiﬁcations on the set
of SELinux libraries, to meet the requirements introduced in
Section 2 a pre-processing phase was introduced. This phase
supports the creation of constraints introduced in Section 4.
Thanks to the modularity provided by SELinux, we were
able to implement the pre-processing phase reusing several
SELinux components.
8.2 Changes to Android
The second set of challenges concerns the app installa-
tion process, which starts from the APK ﬁle that contains
the app. The PackageManagerService class provides the
APIs that actually manage app installation, uninstallation,
load_policySecurityServerAVCSELinux filesystemSELinuxMMACsemodulepre-processingseapp_contextskernel spaceuser spacePackageManagerServiceINSTALL_APPMODULE1)mac_permissions.xmlCheckseappCheckMMAC2)libsemanageappPolicyModule3)Modified componentAppPolicyModule componentAPKPolicyModuleInstallReceiverand update. The PackageManagerService component pro-
vides the functions to parse the APK ﬁle and to assign the
SELinux label to the app. The label is retrieved by the
SELinuxMMAC class from the mac permissions.xml ﬁle.
The ﬁle maps the app certiﬁcate to a SELinux label.
In
the current AOSP version, all third-party apps are assigned
to the default stanza of the mac permissions.xml ﬁle, re-
gardless of their certiﬁcate. To address this limitation and
assign to the app the right SELinux type, we introduced
a new install service, named PolicyModuleInstallReceiver.
This service is triggered by an Intent and manages the in-
stallation workﬂow of an appPolicyModule. The workﬂow
is structured as follows:
1. trigger the installation of the policy module, update
the SELinux policy and check its correctness;
2. update the seapp contexts ﬁle used to label app pro-
cesses and app package directories;
3. update the mac permissions.xml ﬁle used by SELin-
uxMMAC to retrieve the type to assign to the app.
This ﬁle is used in conjunction with seapp contexts.
8.2.1 Update SELinux policy
The use of the PolicyModuleInstallReceiver service requires
to broadcast an intent.action.INSTALL APPMODULE in-
tent. When the service receives the intent it performs a JNI
call to the libsemanage library, which validates (i.e., pre-
processing phase), links, expands the module (i.e., semodule
tool) and triggers the reload of the binary policy.
8.2.2 Update seapp_contexts
In order to meet the requirements Req3 and Req4 de-
scribed in Section 5 the app processes and the app package
directories have to be labeled accordingly to the appPolicy-
Module. In the current AOSP implementation the security
context assigned to app processes, respectively app package
directories, is retrieved from the seapp context ﬁle by the
selinux android setcontext, respectively selinux android
setﬁlecon2.
In order to manage the addition of new entries in the
seapp contexts ﬁle the checkseapp utility was extended. Cur-
rently, checkseapp is used during the AOSP build process to
validate the seapp contexts ﬁle against policy. The extension
permits to dynamically manage the addition/removal of an
entry in the seapp contexts according to the domains deﬁned
in the appPolicyModule.
To allow AOSP components such as Zygote to spawn ap-
plications in the correct domain, an update of the mac
permissions.xml is needed.
8.2.3 Update mac_permissions.xml
This ﬁle is used to conﬁgure the install MMAC policy.
More speciﬁcally this ﬁle is used in conjunction with the
seapp contexts ﬁle in order to determine the seinfo label to
assign to the app. The seinfo value is subsequently used
to determine the SELinux security context for the app pro-
cess and its /data/data directory based on the seapp contexts
conﬁguration.
The information needed to build a stanza for the mac
permissions.xml ﬁle are (i) the app’s X.509 certiﬁcate and
(ii) the seinfo label. The stanza is built on the ﬂy by the
checkMMAC Java class retrieving the information directly
from the parsed apk and the entry added to the seapp contexts
Figure 4: Installation time: comparison between the
full recompilation and the incremental approach.
ﬁle. After stanza creation, an update is triggered to in-
sert and refresh the whole mac permissions.xml ﬁle. This
is needed in order to let SELinuxMMAC retrieve the right
seinfo label for the new app.
8.3 Performance
As it was clearly expressed in the design of SEAndroid [15],
it is necessary to have a minimal overhead in terms of per-
formance, both at app installation time and during regular
system runtime. We executed a series of experiments for the
evaluation of the performance impact of the techniques pre-
sented in this paper. Experiments have been run on a Nexus
7 2013 aosp ﬂo userdebug 4.4.2 r2. The Android runtime
used was ART.
Installation time
8.3.1
We evaluated the performance overhead of our approach
at app installation time, due to the fact that the process
to install an app was extended in order to manage appPol-
icyModules. Two diﬀerent approaches were developed; the
ﬁrst one is consistent with the approach used for SELinux
in Fedora. When a new module is ready to be installed,
the libsemanage tool creates a new version of the policy and
re-installs all the old modules plus the new one. If the new
policy passes the checking step, then the new policy is stored
into the system, otherwise a rollback occurs. This approach
introduces a non negligible overhead, because it requires to