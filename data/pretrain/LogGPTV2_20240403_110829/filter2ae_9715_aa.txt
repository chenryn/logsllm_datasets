原文地址 ：
  * CVE-2018-7445是SMB服务二进制文件中的堆栈缓冲区溢出，存在于6.41.3 / 6.42rc27之前的所有RouterOS版本和体系结构中。
  * 它被发现使用哑声模糊辅助使用Cisco Talos的Mutiny Fuzzer工具并在大约一年前报告/修复。
  * 易受攻击的二进制文件没有使用stack canaries。
  * 利用ROP将堆标记为可执行文件并跳转到堆中的固定位置。堆基不是随机的。
  * 愚蠢的模糊测试仍然在2018年发现了有趣的目标中的错误（虽然我确信2019年肯定不会留下任何错误！）
  * 该帖子描述了从目标选择到识别漏洞然后产生有效漏洞的完整过程。
## 介绍
在过去几年中，MikroTik RouterOS设备中发现和报告的公共漏洞数量激增。从影响CIA Vault
7中包含的内置Web服务器的远程缓冲区溢出泄漏到可能安全的Kirils Solovjovs和Tenable的Jacob
Baines报告的大量其他漏洞导致完全远程攻击。
MikroTik最近被Zerodium维护的漏洞利用收购计划列入了符合条件的路由器品牌名单，其中包括以10万美元购买优先RCE
的一个月优惠。这可能反映出对MikroTik产品及其安全态势越来越感兴趣。
这篇博文旨在为正在进行的MikroTik RouterOS漏洞研究做出一点贡献。我将概述我们与我的同事Juan（感谢Juan！）在Core
Security一起寻找和利用CVE-2018-7445的步骤，这是MikroTik的RouterOS
SMB服务中的远程缓冲区溢出，可以从未经验证的攻击者。
漏洞很容易找到，利用很简单，因此我们的想法是提供详细的演练，希望（对于对内存损坏感兴趣的其他初学者）有用。我将尝试从“嘿！让我们来看看这个MikroTik的事情“实际上在网络服务中发现漏洞并为其编写漏洞。
最初的建议可以在这里找到。
强制性免责声明：我不再隶属于Core Security，因此本文的内容不反映其观点或以任何方式代表公司。
## 建立
在6.41.3 / 6.42rc27之前运行RouterOS的所有体系结构和设备中都存在此漏洞，因此第一步是使易受攻击的系统运行。
MikroTik通过维护所有以前发布的版本的存档使这变得非常容易。也可以下载RouterOS 的Cloud Hosted
Router版本，该版本可作为具有完整RouterOS功能的虚拟机提供。这允许使用流行的虚拟机管理程序在x86-64架构中运行RouterOS，而无需实际的硬件设备。
让我们从这里获得6.40.5版本的Cloud Hosted Router，并在VirtualBox上创建虚拟机。
默认管理员凭据由admin作为用户名和空密码组成。
RouterOS管理控制台
RouterOS控制台是受限制的环境，不允许用户在预定义的配置选项集之外执行任何命令。
要复制漏洞发现，需要启用SMB服务。这可以通过ip smb set enabled = yes命令来实现。
启用SMB并检查设备的IP地址
请注意，情况默认下未启用该服务的事实使得活动利用的可能性要小得多。此外，您可能不应该将您的SMB服务暴露给公共网络，但是，内部网络中始终存在可能有权访问此服务的那些讨厌的用户。
受限制的控制台不适合执行正确的调试，因此在查找漏洞之前，拥有完整的shell访问权限非常有用。Kirils
Solovjovs发表了关于越狱RouterOS的广泛研究，包括发布可用于越狱6.40.5的工具。重复这里的基本细节是没有意义的，所以前往Kirils的研究中心或更新近的Jacob
Baines的新版本的帖子，其中6.40.5的入口点已被修补。
越狱的RouterOS 6.40.5就像克隆
的交互式exploit-backup / exploit_full.sh漏洞一样简单。
越狱工具由0ki定位6.40.5
最后，从 下载预编译的GDB版本，并使用FTP将其上传到系统。
通过Telnet连接到设备将允许我们附加到正在运行的进程并正确调试它们。
我们现在准备开始寻找网络服务中的漏洞。
## 目标选择
在RouterOS中运行了很多服务。快速回顾显示常见服务，如HTTP，FTP，SSH和Telnet，以及一些其他特定于RouterOS的服务，例如在端口2000上运行的bandwidh测试服务器。
雅各布贝恩斯指出，通过使用Winbox协议可以达到90多种实现网络服务的不同二进制文件（参见他的优秀博客文章中的真实攻击曲面）。
当我们开始使用RouterOS并且没有花时间对使用Winbox的二进制文件进行反向工程时，我们并没有意识到所有可达到的功能，所以我们只是继续查看在网络上明确监听的几个二进制文件。
RouterOS中的大多数（全部？）服务似乎都是从头开始实现的，因此有数千行自定义低级代码等待审计。
我们的目标是实现未经身份验证的远程代码执行，初看起来，FTP或Telnet等常见服务的二进制文件在没有提供凭据的情况下无法提供太多可访问的功能。这使我们转向其他默认情况下可能未启用的服务，但需要实现丰富的功能集。默认情况下未启用这些服务这一事实意味着他们可能会被其他攻击者忽略，这些攻击者希望最大限度地提高影响RouterOS默认安装的漏洞的ROI，因此更有价值。
通过遵循这一基本原理并检查可用服务，我们决定查看SMB实施。
## 发现漏洞
我们知道我们想在SMB服务中发现漏洞。我们有虚拟机设置，服务运行，我们对设备有完全的shell访问权限，我们可以调试任何进程。我们如何找到漏洞？
一种选择是反汇编二进制文件并寻找不安全的编码模式。我们将识别有趣的操作，如strcpy，memcpy等，并查看是否有正确的大小检查。然后我们将看看是否可以通过用户控制的输入访问这些代码路径。我们可以将它与动态分析相结合，并使用我们的能力通过GDB连接到正在运行的进程，以便在运行时，内存位置等处检查寄存器。但是，这可能非常耗时，如果您没有经验，很容易感到沮丧进行逆向工程，特别是如果它是一个大型二进制文件。
另一个选择是模糊网络服务。此方法包括将数据发送到远程服务并检查它是否导致意外行为或崩溃。此数据将包含格式错误的邮件，无效的大小，非常长的字符串等。
进行模糊测试过程有不同的方法。两种最流行的策略是基于生成和基于变异的模糊测试。基于生成的模糊测试需要协议知识来构建符合协议规定格式的测试用例，并且（很可能）会导致更全面的覆盖。更多的覆盖意味着更多的机会击中易受攻击的代码路径，因此更多的错误。另一方面，基于突变的模糊测试假定没有关于协议被模糊化的先验知识，并且以可能较差的代码覆盖和在需要计算校验和以确保数据完整性的协议中的额外困难为代价而花费更少的努力。
我们决定用一个愚蠢的模糊器试试运气，并选择几个月前Cisco Talos团队发布的Mutiny
Fuzzer工具。Mutiny采用合法网络流量的样本，并通过突变模糊器重放它。特别是，Mutiny使用Radamsa来改变流量。
Radamsa变异的例子
执行这种模糊测试的好处是可以非常快速地开始运行，并且正如我们将看到的，如果我们有一系列强调各种功能的测试用例，可能会提供很好的结果。
综上所述，模糊网络服务的步骤是：
  * 捕获合法流量
  * 从生成的PCAP文件中创建Mutiny模糊器模板
  * 运行Mutiny来改变流量并将其重播到服务
  * 观察正在运行的服务会发生什么  
Mutiny确实提供了一个监控脚本，可用于监控服务并识别奇怪的行为。这可以通过实现monitorTarget函数来完成，如
中所述。样本检查可能是ping远程服务或连接到远程服务以评估其可用性，监视进程，日志或其他可能表示奇怪行为的信号。
在这种情况下，SMB服务在崩溃后需要一段时间才能重新启动并记录堆栈跟踪消息，因此我们认为不值得编写任何监控操作的脚本。相反，我们刚刚使用Wireshark捕获整个模糊过程中的流量，并依赖于Mutiny的默认行为，当请求因连接拒绝错误而失败时退出，这意味着服务已关闭。这是相当简陋的，并留下了很大的改进空间，但这对我们的测试来说已经足够了。
在我们启动模糊测试过程之前启用完整日志记录非常重要。这可能对跟踪可能发生的任何崩溃非常有用，因为完整堆栈跟踪将包含在/rw/logs/backtrace.log中的日志中。这可以通过RouterOS的Web界面进行配置。
启用所有日志以写入磁盘
另一件被证明有用的事情是在交互式控制台中运行二进制文件以实时获得调试输出。这可以通过终止正在运行的进程并从完整终端重新启动它来实现。将打印错误和已处理请求的一般状态。
在处理请求时获取调试输出
现在我们对所涉及的步骤进行了高级概述，让我们回顾一下并实际模糊SMB服务。
首先，我们克隆 并按照设置说明进行操作。
我们计划的下一步包括生成一些网络流量。为此，请打开Wireshark并尝试使用smbclient访问路由器上的资源。
Smbclient将向端口445 / TCP 发送协商协议请求，并收到我们不关心的响应。这可以在Wireshark捕获中观察到。
我们希望使用此请求作为产生（希望！）有意义的突变的起点。停止Wireshark捕获并保存请求数据包，方法是转到文件 ->导出指定数据包并选择请求数据包。输出格式应为PCAP。
一旦我们有包含模糊请求的PCAP，我们就会使用mutiny_prep.py交互式脚本准备Mutiny的 .fuzzer文件。
最好检查生成的文件，以确定转换过程中可能出现的任何奇怪现象。
在这里，我们可以将Mutiny配置为仅模糊消息的一部分。如果我们想要将我们的工作重点放在个别领域，这将是有用的。在这种情况下，我们将模糊整个消息。值得一提的是，Mutiny还可以处理多消息交换。
如果我们用作初始模板的测试用例包含不会导致程序采用不同路径的部分，那么我们对此数据所做的所有修改都不会增加代码覆盖率，从而导致浪费时间和低效的模糊测试。
在不详细讨论SMB协议的情况下，我们可以观察到该请求包含大约十二个请求方言的列表。每个方言对应于一组特定的支持命令。如果我们对一组特定的命令进行模糊测试，这可能会很有趣，但是现在我们并不关心这一点。
提供一个或两个方言的较短列表将导致Radamsa创建更有意义的突变并发送更多种类的SMB请求类型。我们的理由是，可能改变一种方言或另一种方言不会使应用程序在单个消息对话中采用截然不同的路径，因此我们这样做并编辑模板如下所示：
    >>> open(“req”).read()
    ‘\x81\x00\x00 \x00\x00 \x00\x00 \x00\x00 \x00\x00 \x00\x00 \x00\x00 \x00\x00 \x00\x00 \x00\x00 \x00\x00 \x00\x00’
有了模板，我们就可以开始模糊测试了。记得用Wireshark捕获完整的会话。Mutiny还可以记录发送的每个数据包，但是我们发现当服务器在崩溃后停止响应时，更容易查看Wireshark。
使用devel帐户打开与路由器的telnet连接并运行pkill smb; / nova / bin / smb启动新的SMB进程并观察其输出。
以下命令将指示Mutiny在数据包之间休眠半秒并记录所有请求： ./mutiny.py -s 0.5 - logAll
negotiate_protocol_request-0.fuzzer HOST
详细输出将显示正在发送的不同大小的数据包以及每个数据包的数字标识符。该值可用于重复完全相同的突变序列，并提供重现崩溃的方法。这很重要，因为即使我们发现崩溃，以前的请求也可能已经损坏了某些内容，或者以崩溃发生所需的方式更改了应用程序状态。如果我们无法在崩溃之前重新创建状态，即使我们确定哪个特定请求最终导致崩溃，我们也可能空手而归。
如果模糊测试会话中断并且我们不想重播先前的突变，则可以使用-r参数指示Mutiny开始从该迭代开始发送突变（例如：-r1500-将发送突变1500,1501， 1502，依此类推）。
如果我们在模糊器运行时观察Wireshark，我们将看到并非所有数据包都符合预期的格式，这对我们来说是件好事。当应用程序无法以正确的方式处理意外数据时，通常会出现漏洞。
我们运行SMB二进制文件的终端还将包含有用的数据，以确认我们实际上正在向服务提供格式错误的请求。
现在我们让模糊器运行。我们可以使用不同的延迟值来查看服务器是否可以快速处理请求，但是每秒两个请求对于此概念验证是可行的。
几分钟后，Mutiny在尝试连接服务后无法完成运行。
如果我们看一下运行二进制文件的终端，我们将收到一条Segmentation fault消息
如前所述，backtrace.log文件包含寄存器转储以及有关导致崩溃的更多信息。