Problem. DIKEUE aims to solve the following noncompliance prob-
lem. Given black-box access to a LTE control-plane protocol im-
plementation I of a UE, the noncompliance asks is there an input
sequence πi = σ1σ2σ3 . . . σm where σj ∈ Σ such that the output se-
quence generated by I after feeding πi as input, γi = λ1λ2λ3 . . . λm
in which λj ∈ Λ, is not the one prescribed by the standard.
Approach skeleton. For addressing the above noncompliance
problem, DIKEUE takes advantage of its black-box access to mul-
tiple UE implementations ⟨I1,I2, . . . ,In⟩. It also requires that the
Session 4B: Wireless, Mobile, and IoT CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1084Figure 1: Workflow of DIKEUE
j and M∗
input and output interfaces of these implementations are the same;
that is, the set of input and output symbols are Σ and Λ across all
implementations. Suppose the implementations simulate the fol-
lowing protocol state machines ⟨M1,M2, . . . ,Mn⟩, respectively.
DIKEUE’s approach has the following two steps: ❶ For each imple-
mentation Ij, using active automata learning, extract an approxima-
tion M∗
j of the underlying FSM Mj; ❷ For each pair of extracted
FSM M∗
j and M∗
k, find input sequences of the form πi such that
when it is fed as input to both M∗
k, the output sequences
they generate are γj and γk, respectively, and γj (cid:44) γk. In such a
case, πi is called a deviant-behavior-inducing input sequence,
and it also serves as an example of a noncompliant behavior.
3.3 Workflow of DIKEUE
DIKEUE (shown in Figure 1) works mainly with two components,
namely, the FSM inference module and the FSM equivalence checker
module. The FSM inference module requires black-box access to
one or more UE implementations to be checked for noncompliance.
For each of these implementations, it uses active automata learning
to extract a protocol state machine of the input UE implementation.
Once the protocol state machines of all the implementations have
been extracted, each pair of the state machines are fed into the FSM
equivalence checker module. The FSM equivalence checker module
then tries to identify a diverse set of deviant-behavior-inducing
input sequences. Each of these sequences denotes a sequence of
input protocol messages for which the two input state machines
disagree. For each such input sequence, the outputs of the two state
machines are manually compared to the standard to identify which
of these implementations deviate from the standard; identifying
the noncompliant behavior which is displayed as output.
3.4 Challenges and Insights
For realizing the skeleton approach for noncompliance detection
presented just above, DIKEUE has to address the following two sets
of challenges. In addition, we also discuss how we address these
challenges using existing approaches as well as novel insights.
3.4.1 Learning the 4G LTE Protocol State Machine of a UE. As we
have hinted before, we use an existing active automata learning
algorithm for extracting the 4G LTE protocol state machine of a UE.
Effectively applying active automata learning for 4G LTE protocol
machine has the following three classes of challenges.
Challenge C1: Satisfying Pre-requisites of Automata Learn-
ing Algorithms. The first challenge involves ensuring that the
(implicit) prerequisites for active automata learning are satisfied so
that one can apply L* like algorithms for learning the protocol state
machine. There are three prerequisites for applying L* like algo-
rithms, namely, (P1) identifying the input and output alphabet, (P2)
ensuring that the SUL is deterministic, and (P3) the membership
queries are run from the known initial state of the protocol.
First, the number of input symbols relies on the kinds of con-
sidered protocol messages, procedures, and also predicates over
messages. Once the input symbols are selected, then the output
symbols can be obtained from the protocol specification. Note
that, the considered input symbols are exponential to the num-
ber of considered predicates over messages and linear to the kinds
of messages. Let us consider an example protocol that has three
kinds of messages k1, k2, and k3, but the protocol transition con-
ditions also rely on two predicates over messages p1(·) and p2(·).
In this case, we can have a total of 12 (= 3 × 2 × 2) input symbols
based on which message kind (synonymously, message type) it
is and whether p1(·) and p2(·) are true. As an example, two dif-
ferent input symbols are needed to capture the following two
conditions, namely, messaдe_kind(m) = k1 ∧ p1(m) ∧ p2(m) and
messaдe_kind(m) = k1 ∧ ¬p1(m) ∧ p2(m) (m is a variable of type
message). There are 12 such possible conditions requiring 12 input
symbols. Note that, the size of the input alphabet impacts both ter-
mination of the learning and coverage of learned protocol behavior.
The larger the alphabet size the more of the protocol behavior will
be covered, but it will negatively impact the termination.
Second, despite the deterministic nature of the 4G LTE protocol
state machine of a UE, due to the unreliable over-the-air (OTA)
transmission, link-failures, re-transmissions, and timers, the out-
puts observed from the UE may not be deterministic, violating P2.
Such observational-nondeterminism causes the learned protocol
state machine to never converge as it spawns new states/transitions
with a new observation of nondeterministic behavior.
Finally, in case of 4G LTE, satisfying P3 requires deleting all the
keys, resynchronizing the USIM sequence number, and taking the
cellular device to the initial registration phase, which require time
and manual intervention to turn on/off the device and deleting
information from non-volatile memory.
LTE-specific Insight for P1. For input symbols, we consider a
total of 16 protocol message kinds and the following four unary
predicates over messages: is_replay(·), is_plain_text(·), is_plain_h−
eader(·), and is_null_security(·). This gives us a potential input
alphabet size of 256 (= 16 × 2 × 2 × 2 × 2). We also need to consider
an additional 5 input symbols that trigger different procedures. As
an example, one such input symbol is to induce the UE to send an
attach_request message and initiate the protocol session. The different
predicates we consider have the following semantics. is_replay(m)
is true iff m is replay of a previously sent message. is_plain_text(m)
is true iff the content of m is in clear. is_plain_header(m) is true iff
the content of m should be encrypted and integrity protected with
value of the message authentication code (MAC) to be set to 0 but
the value of security header refers to a plaintext message message.
Finally, is_null_security(m) is true iff null security is chosen as the
chosen ciphersuite in the sm_command message. The output symbols
are chosen accordingly from these possible input symbols.
Noncompliance instanceImplementation Mismatch(b) FSM Equivalence Checker ModuleHypothesis constructionHypothesisvalidationModel Learning(a) FSM inference moduleCross Validation of Protocol State Machine of ImplemantionsStandard documentCellular devices (UEs)iPhoneAndroid PhoneUSBDongleSession 4B: Wireless, Mobile, and IoT CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1085Existing insight on satisfying P2. For addressing the observa-
tional nondeterministic behavior of a UE, we conservatively pose
each membership query twice. In case the outputs for both these
membership queries agree, we update the observational table. In
case of a conflict, however, we use the existing approach of using a
majority voting scheme to resolve conflicting output sequences [44].
Novel LTE-specific insight on satisfying P3. For satisfying P3,
we discovered a protocol-specific behavior to transparently reset
the device and take it to an initial state. Having a software solution
allows us to avoid the expensive approach of manually rebooting
the device; positively impacting the termination of learning.
Challenge C2: Balancing Termination and Coverage of Learn-
ing. Another major challenging aspect of effectively applying au-
tomata learning for extracting the 4G LTE protocol state machine of
a UE is achieving the right balance between termination and cover-
age. On one hand, aiming to achieve a high coverage of the behavior
negatively impacts the termination. Premature termination, on the
other hand, negatively impacts coverage. The termination of the
learning algorithm is impacted by the following factors: (1) number
of posed membership queries (reliant on the input alphabet size); (2)
the time to run each membership query and obtaining a response;
(3) the time it takes to resolve observational nondeterminism.
Existing insight on caching results. Running a query in the
device is expensive. We thus follow an existing approach [11, 52]
of maintaining a cache of membership queries, i.e., input sequences
and their corresponding outputs encountered during the hypothesis
construction stage. Equivalence queries posed during model valida-
tion stage are first consulted with the cache. If the cache is hit, then
the response stored in the cache is used. Note that, the cache is not
used during the hypothesis construction stage.
Challenge C3: Designing a Protocol-specific Adapter. The final
challenge for applying active automata learning in the context of 4G
LTE protocol state machines involve developing a 4G LTE-specific
adapter. The adapter facilitates communication between the learner
and the UE device. It needs to convert the abstract input symbols
Novel LTE-specific insight of input alphabet selection. Al-
though we can potentially have a total of 261 (= 256 + 5) input
symbols, some of the input symbols are irrelevant. As an exam-
ple, consider a condition where messaдe_kind(m) (cid:44) sm_command in
which case the value of the predicate is_null_security(m) is not
relevant as it only applies to the sm_command message. In addition, to
reduce the model learning time, we heuristically prune away other
input symbols that may not trigger interesting security-sensitive
behavior. After pruning, we end up with a list of 35 input symbols
which is much smaller than the original set of 261.
Novel LTE-specific insight of context checker. We develop a
context-checker with a set of invariants to automatically deduce
outputs for certain input message sequences posed as membership
queries without having to run them in the UE. These invariants are
conservative rules (i.e., ruling out certain infeasible orderings of
protocol messages) that one can reasonably expect a UE to satisfy
(e.g., not receiving certain protocol packets without an established
connection). Input sequences violating these invariants can be con-
sidered to have the output sequence null_actionn where n is the length
of the input message sequence. Note that, null_action is a special out-
put symbol that refers to the UE not generating any outputs.
in the membership queries to concrete OTA packets and send them
to the UE. In the same vein, it also needs to decode the response
from the UE and convert it back to abstract output symbols compre-
hensible to the learner. Developing such a 4G LTE-specific adapter
is challenging because protocol layers are intertwined and have
strong temporal correlations among their operations. As an exam-
ple, some NAS layer messages can only be sent after particular RRC
layer messages, and vice versa. Also, messages of both layers con-
tain timers and re-transmissions but, internal protocol states, e.g.,
transmission failures and timeouts, are not observable from the in-
put/output messages. In addition, for analyzing communication and
mobility management protocols, the adapter needs to trigger certain
behavior and corner cases in the UE that pose physical constraints
on the UE. For instance, testing handover scenarios requires the UE
to be physically moved between multiple base stations, which is
not practical and non-trivial to test in any controlled environment.
LTE-specific adapter. We have developed a LTE-specific adapter
by enhancing an open-source protocol stack that can transparently
send and receive messages based on the directions of the learner.
The adapter can handle the complex multi-level, stateful interac-
tions in 4G LTE, including different error conditions.
Novel LTE-specific insight on triggering complex operations.
We developed an adapter that can trigger complex 4G LTE behavior
in the software that would otherwise require physically moving
the UE, e.g., similar to ones for analyzing the handover procedure.
Identifying Noncompliance from Protocol State Machines. Re-
3.4.2
call that, once we have extracted the protocol state machines of
the UE implementations under test, we use differential testing of
pairwise protocol state machines from different implementations
to identify deviant-behavior-inducing input sequences [24, 42]. We
use these input sequences as a proxy for noncompliant behavior.
The main challenge for achieving this goal is how to automatically
identify a diverse set of deviant-behavior-inducing input sequences.
Existing equivalence checking approaches are insufficient for our
purpose as they neither have the notion of diversity nor the capabil-
ity to provide multiple deviant-behavior-inducing input sequences.
Novel insight on differential testing. We propose a notion of
diversity classes for deviant-behavior-inducing input sequences (see
Section 5). We use this notion of diversity classes to develop a novel
approach that reduces identifying deviant-behavior-inducing input
sequences to a model checking problem. This approach enables us
to not only automatically identify deviant-behavior-inducing input
sequences from different diversity classes but also identify different
instances from the same class.
4 FSM INFERENCE MODULE
We now explain in details the components that leverage LTE-
specific insights to enable a practical FSM inference module.
4.1 Learner
Following the model learning algorithm [34], the learner systemat-
ically generates queries as sequences of input alphabets, and based
on the outputs, infers the underlying FSM.
4.1.1 Taming the time and state explosion with alphabet set opti-
mization: The time and the number of queries required to learn
the model are directly proportional to the number of input alpha-
bets. We, therefore, first leverage LTE-specific insights to reduce
Session 4B: Wireless, Mobile, and IoT CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1086Figure 2: Flow of query in DIKEUE’s FSM inference module
the potential input alphabet set of 261 input symbols (Section 3.4).
We discard the symbols that are irrelevant in the context of LTE.
For example, is_null_security(m) does not apply to messages other
than RRC and NAS layers’ sm_command messages. Also, some poten-
tial symbols generated by combining multiple predicates together
eventually refer to the same symbol. To illustrate, the following
two conditions yield the same input symbol: (1) messaдe_kind(m)=
identity_request∧¬is_replay(m)∧is_plain_text(m)∧¬is_plain_header
(m) ∧¬is_null_security(m); (2) messaдe_kind(m) = identity_request
∧is_replay(m) ∧ is_plain _text(m) ∧ ¬is_plain_header(m) ∧¬is
_null_security(m). Since plaintext messages do not have any re-
play protection, replaying a previously sent plaintext identity_request
message is equivalent to sending a new plaintext identity_request mes-
sage. As such, we prune these irrelevant and redundant messages to
reduce the alphabet set to 59 symbols (listed in column 2 in Table 9).
Since the predicates are common to most of the messages in both
NAS and RRC layers (except sm_command and RRC_sm_command), to fur-
ther minimize the input alphabet set, instead of considering these
variants for each input symbol, we consider testing one variant sym-
bol per layer. For instance, one replayed symbol in one RRC layer
message is enough to test RRC layer replay protection. Since NAS
and RRC layers’ sm_command are special message kinds in LTE as
they are used to navigate the protocol from an unprotected state to
security protected state and create dependencies among layers [7],
we consider these two messages separately and also include their
variants into the alphabet set. Hence, in total, our input alphabet
set includes 35, as shown in the third column of Table 9.
4.1.2 Balancing termination and coverage: When the SUL com-
pletes exploring the control-plane procedures of our interest, we
terminate the learning and take the last inferred model for equiva-
lence checking. From empirical evaluation, we observed the learner
needs running queries for up to length 12 to explore the procedures.
4.2 Adapter
The adapter acts as a glue between all the components of FSM
inference module (shown in Figure 2), and builds a reliable interface
from the learner to each control-plane layers we want to analyze.
4.2.1 Addressing multi-layer protocol: The adapter flattens the
multi-layer protocol interactions by combining all layers under
a central component and controls the interactions of two interfaces
between (i) base station and UE, and (ii) core network and UE. Based
on messages in queries issued by the learner, it directs the message
to appropriate interface and waits until the response or timeout
occurs. It thus enables learning multi-layer protocol.
Improving time of learning with context-checker: To enhance
4.2.2
the performance of the FSM inference, the adapter tries to minimize
the time-consuming OTA transmissions. For this, the adapter is
provisioned with a set of invariants extracted from cellular spec-
ifications [2, 8, 9], which are used to decide if an input symbol’s
communication context set by previous symbols in the query is
valid for OTA transmission. Whenever an input symbol violates
the context, it is dropped, and the default– null_action is returned im-
mediately. In case an input symbol passes all these context checks,
it is transmitted OTA. The invariants defined in the adapter are:
1 input symbols corresponding to common control-plane pro-
cedures cannot appear before connection establishment symbols.
For instance, for Q1 in Table 1, the input symbol attach_accept is
not propagated forward as the control-plane connection has not
been established yet with the connection initiation symbols (e.g.,
enable_RRC_con or enable_attach). 2 Lower layer connection (RRC) has
to be established before upper layer (NAS) connection establish-
ment. To illustrate, for Q2, the first enable_attach does not have any
semantic meaning and will be responded with the default null_action
symbol; all symbols prior to the first enable_RRC_con in a query will
thus result in null_action as responses. 3 Security protected messages
require proper security keys to be established. Turning to Table 1,
for Q3, the security protected GUTI_reallocation message requires key
for integrity and encryption. However, before the authentication
and security mode command procedures, session keys have not
been established. Therefore, this GUTI_reallocation violates the context
check and the context-checker will return the default output sym-
bol. 4 After a connection closing symbol, a new connection has
to be established before transmitting the subsequent symbols. For
example, in the query shown in Q4, after the RRC connection is
released, all other symbols do not have any semantic meaning and
will not be propagated further until a new connection has been
established with enable_RRC_con input symbol. 5 A replay symbol
has to come after its original counterpart. For instance, for Q5, the
first auth_request_replay does not correspond to anything and will be
discarded until an auth_request has been received.
4.2.3 Encoding and decoding custom NAS and RRC layer packets
containing predicates: For an input symbol forwarded by the con-
text checker, the packet converter builds the corresponding NAS
and RRC layer payload and header based on the current context. For
instance, it saves the previously sent packets so that it can replay
those packets later. For plain header, plaintext, and null security
packets, the packet converter creates the fields as per the input
symbol requirements. For example, if a plain header input symbol
is received, instead of the usual integrity protected and ciphered
header, the message is sent with plain header. For plaintext mes-
sages, the packet is crafted by removing the MAC and without
encryption. For null security packets, the integrity and encryp-
tion algorithms are set to null-integrity (EIA0) and null-encryption
(EEA0), respectively.
4.2.4 Triggering complex protocol interactions: The packet con-
verted in the adapter also has to automatically trigger certain com-
plex interactions, which are often hard to test as they require phys-
ical movements of the SUL or manual interventions. For instance,
testing handover requires the user to move from one cell/tracking