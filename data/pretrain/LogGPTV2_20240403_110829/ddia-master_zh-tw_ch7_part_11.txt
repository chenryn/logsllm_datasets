- 检测对旧 MVCC 物件版本的读取（读之前存在未提交的写入）
- 检测影响先前读取的写入（读之后发生写入）
#### 检测旧MVCC读取
回想一下，快照隔离通常是透过多版本并发控制（MVCC；见 [图 7-10](../img/fig7-10.png)）来实现的。当一个事务从 MVCC 资料库中的一致快照读时，它将忽略取快照时尚未提交的任何其他事务所做的写入。在 [图 7-10](../img/fig7-10.png) 中，事务 43 认为 Alice 的 `on_call = true` ，因为事务 42（修改 Alice 的待命状态）未被提交。然而，在事务 43 想要提交时，事务 42 已经提交。这意味著在读一致性快照时被忽略的写入已经生效，事务 43 的前提不再为真。
![](../img/fig7-10.png)
**图 7-10 检测事务何时从 MVCC 快照读取过时的值**
为了防止这种异常，资料库需要跟踪一个事务由于 MVCC 可见性规则而忽略另一个事务的写入。当事务想要提交时，资料库检查是否有任何被忽略的写入现在已经被提交。如果是这样，事务必须中止。
为什么要等到提交？当检测到陈旧的读取时，为什么不立即中止事务 43 ？因为如果事务 43 是只读事务，则不需要中止，因为没有写入偏差的风险。当事务 43 进行读取时，资料库还不知道事务是否要稍后执行写操作。此外，事务 42 可能在事务 43 被提交的时候中止或者可能仍然未被提交，因此读取可能终究不是陈旧的。透过避免不必要的中止，SSI 保留了快照隔离从一致快照中长时间读取的能力。
#### 检测影响之前读取的写入
第二种情况要考虑的是另一个事务在读取资料之后修改资料。这种情况如 [图 7-11](../img/fig7-11.png) 所示。
![](../img/fig7-11.png)
**图 7-11 在可序列化快照隔离中，检测一个事务何时修改另一个事务的读取。**
在两阶段锁定的上下文中，我们讨论了索引范围锁（请参阅 “[索引范围锁](#索引范围锁)”），它允许资料库锁定与某个搜寻查询匹配的所有行的访问权，例如 `WHERE shift_id = 1234`。可以在这里使用类似的技术，除了 SSI 锁不会阻塞其他事务。
在 [图 7-11](../img/fig7-11.png) 中，事务 42 和 43 都在班次 1234 查询值班医生。如果在 `shift_id` 上有索引，则资料库可以使用索引项 1234 来记录事务 42 和 43 读取这个资料的事实。（如果没有索引，这个资讯可以在表级别进行跟踪）。这个资讯只需要保留一段时间：在一个事务完成（提交或中止），并且所有的并发事务完成之后，资料库就可以忘记它读取的资料了。
当事务写入资料库时，它必须在索引中查询最近曾读取受影响资料的其他事务。这个过程类似于在受影响的键范围上获取写锁，但锁并不会阻塞事务直到其他读事务完成，而是像警戒线一样只是简单通知其他事务：你们读过的资料可能不是最新的啦。
在 [图 7-11](../img/fig7-11.png) 中，事务 43 通知事务 42 其先前读已过时，反之亦然。事务 42 首先提交并成功，尽管事务 43 的写影响了 42 ，但因为事务 43 尚未提交，所以写入尚未生效。然而当事务 43 想要提交时，来自事务 42 的冲突写入已经被提交，所以事务 43 必须中止。
#### 可序列化快照隔离的效能
与往常一样，许多工程细节会影响演算法的实际表现。例如一个权衡是跟踪事务的读取和写入的 **粒度（granularity）**。如果资料库详细地跟踪每个事务的活动（细粒度），那么可以准确地确定哪些事务需要中止，但是簿记开销可能变得很显著。简略的跟踪速度更快（粗粒度），但可能会导致更多不必要的事务中止。
在某些情况下，事务可以读取被另一个事务覆盖的资讯：这取决于发生了什么，有时可以证明执行结果无论如何都是可序列化的。PostgreSQL 使用这个理论来减少不必要的中止次数【11,41】。
与两阶段锁定相比，可序列化快照隔离的最大优点是一个事务不需要阻塞等待另一个事务所持有的锁。就像在快照隔离下一样，写不会阻塞读，反之亦然。这种设计原则使得查询延迟更可预测，波动更少。特别是，只读查询可以执行在一致快照上，而不需要任何锁定，这对于读取繁重的工作负载非常有吸引力。
与序列执行相比，可序列化快照隔离并不局限于单个 CPU 核的吞吐量：FoundationDB 将序列化冲突的检测分布在多台机器上，允许扩充套件到很高的吞吐量。即使资料可能跨多台机器进行分割槽，事务也可以在保证可序列化隔离等级的同时读写多个分割槽中的资料【54】。
中止率显著影响 SSI 的整体表现。例如，长时间读取和写入资料的事务很可能会发生冲突并中止，因此 SSI 要求同时读写的事务尽量短（只读的长事务可能没问题）。对于慢事务，SSI 可能比两阶段锁定或序列执行更不敏感。
## 本章小结
事务是一个抽象层，允许应用程式假装某些并发问题和某些型别的硬体和软体故障不存在。各式各样的错误被简化为一种简单情况：**事务中止（transaction abort）**，而应用需要的仅仅是重试。
在本章中介绍了很多问题，事务有助于防止这些问题发生。并非所有应用都易受此类问题影响：具有非常简单访问模式的应用（例如每次读写单条记录）可能无需事务管理。但是对于更复杂的访问模式，事务可以大大减少需要考虑的潜在错误情景数量。
如果没有事务处理，各种错误情况（程序崩溃、网路中断、停电、磁碟已满、意外并发等）意味著资料可能以各种方式变得不一致。例如，非规范化的资料可能很容易与源资料不同步。如果没有事务处理，就很难推断复杂的互动访问可能对资料库造成的影响。
本章深入讨论了 **并发控制** 的话题。我们讨论了几个广泛使用的隔离级别，特别是 **读已提交**、**快照隔离**（有时称为可重复读）和 **可序列化**。并透过研究竞争条件的各种例子，来描述这些隔离等级：
* 脏读
  一个客户端读取到另一个客户端尚未提交的写入。**读已提交** 或更强的隔离级别可以防止脏读。
* 脏写
  一个客户端覆盖写入了另一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写。
* 读取偏差（不可重复读）
  在同一个事务中，客户端在不同的时间点会看见资料库的不同状态。**快照隔离** 经常用于解决这个问题，它允许事务从一个特定时间点的一致性快照中读取资料。快照隔离通常使用 **多版本并发控制（MVCC）** 来实现。
* 丢失更新
  两个客户端同时执行 **读取 - 修改 - 写入序列**。其中一个写操作，在没有合并另一个写入变更情况下，直接覆盖了另一个写操作的结果。所以导致资料丢失。快照隔离的一些实现可以自动防止这种异常，而另一些实现则需要手动锁定（`SELECT FOR UPDATE`）。
* 写入偏差
  一个事务读取一些东西，根据它所看到的值作出决定，并将该决定写入资料库。但是，写入时，该决定的前提不再是真实的。只有可序列化的隔离才能防止这种异常。
* 幻读
  事务读取符合某些搜寻条件的物件。另一个客户端进行写入，影响搜寻结果。快照隔离可以防止直接的幻像读取，但是写入偏差上下文中的幻读需要特殊处理，例如索引范围锁定。