tions for its usage scenarios. However, instead of augment-
ing the existing protocol, the working group decided to alter
the speciﬁcation completely to create a diﬀerent protocol –
OAuth 2.0. This decision was the result of a “strong and
unbridgeable conﬂict” between diﬀerent interest groups, ac-
cording to a departing lead author of OAuth 1.0 [22].
One major change introduced by OAuth 2.0 was the con-
cept of bearer tokens [28]. That is, a user’s access token was
no longer bound to a relying party; any party in possession of
this token could freely access the user’s protected resource.
In addition, OAuth 2.0 also oﬀers four methods for exchang-
ing access token; these methods are referred to as grants and
they can be viewed as diﬀerent “versions” of OAuth 2.0. Our
study in Section 3 reveals that out of the four grant types
in OAuth 2.0, only two were used in practice for authoriza-
tion and authentication – implicit grant and authorization
code grant. We illustrate these two grants in Figure 2a and
Figure 2b, and brieﬂy describe them below.
Implicit grant
2.2.1
The implicit grant is the shortest of all OAuth ﬂows. It
consists of two steps. First, the user is redirected to the
service provider to grant the relying party access to his/her
protected resource. After the permission is granted, the ser-
vice provider redirects the user back to the relying party
along with an access token. The relying party can then
use this access token to exchange for the user’s protected
resource.
There are two core features that diﬀerentiate the implicit
grant from other OAuth ﬂows. First, with exception to the
ﬁnal protected resource request, every message in the proto-
col is exchanged through the user agent (e.g., using browser
redirection). Second, the implicit grant does not require
the relying party to present a shared secret to the service
provider. This is ideal for the mobile environment, where
the relying party resides on an untrusted device.
2.2.2 Authorization code grant
The authorization code grant augments the implicit grant
by adding an additional step to authenticate the relying
party. After the user grants permission to the relying party,
the service provider redirects the user back to the relying
Figure 1: OAuth 1.0 and OAuth 1.0a.
(a) Implicit grant
(b) Authorization code grant
Figure 2: Two grant types of OAuth 2.0
party with an authorization code (instead of an access to-
ken). Then, this authorization code is used to exchange for
the user’s access token through a direct server-to-server call.
In this access token exchange step the relying party has to
include its own identity, so the service provider can verify
that the authorization code is granted to the same party.
3. OUR STUDY
Our study consists of two main components, which are
explained in detail in the next two sections:
• We ﬁrst focus on understanding and comparing the
protocol speciﬁcations of OAuth 1.0 and 2.0 in order
to pinpoint their key steps in authentication and au-
thorization. Pinpointing these key steps plays an im-
portant role in our work because they are implemented
by diﬀerent mechanisms on the mobile platforms, as
compared to those on the web platform. Section 4.2
will elaborate on how such diﬀerences lead to secu-
rity issues which mobile application developers may
not foresee.
• In order to understand how real-world developers in-
terpret and implement OAuth, we conducted a com-
UserService ProviderRelying party1. [App ID]2. Req Token3. Req Token4. User grants permission5. Req Token, verifier 6. [Req Token, verifier]7. Access Token8. [Access token]9. Protected resourceVerifies signatureVerifies signatureVerifies signatureUserService ProviderRelying party2. User grants permission3. Access token4. Access token5. Protected resource1. App ID, redirect URIVerifies redirect URIUserService ProviderRelying party1. App ID, redirect URI3. Auth code2. User grants permission5. Access Token7. Protected resource6. Access token4. Auth code, redirect URI,app ID, app secretVerifies redirect URIAuthenticates relying partyprehensive study on 149 popular mobile applications.
These applications included 133 Android applications
from the following Google Play store categories: top
300 free applications in all categories, top 200 free ap-
plications in social and top 100 free applications in
communication. In addition, we manually selected 16
popular iOS and Android OAuth applications (e.g.,
Quora and Weibo) that were not included in the top
charts. 25 (16.8%) applications used in our study were
service providers, 126 (84.5%) were relying parties and
2 (1.3%) were both service providers and relying par-
ties. Furthermore, 52 (41.3%) of the relying parties
were using OAuth for authorization, the remaining 74
(58.7%) were using it for authentication. Our study
revealed that 59.7% of these protocol implementations
were faulty and vulnerable to attacks. These results
conﬁrm our suspicion that, for a large population of
developers, how to use OAuth securely on mobile ap-
plications is indeed unclear. Section 5 explains a set of
representative cases among the vulnerable applications
that we studied.
4. OAUTH SPECIFICATIONS AND MOBILE
PLATFORMS
In this section, we start by studying three canonical OAuth
protocol ﬂows: OAuth 1.0, OAuth 2.0 implicit grant and au-
thorization code grant, and their two use cases: authoriza-
tion and authentication. Since the use case of authentication
is largely unaddressed by the current OAuth speciﬁcations,
we oﬀer our insights on how to achieve it using diﬀerent ver-
sions of OAuth. Furthermore, we demonstrate key factors
that make the existing OAuth speciﬁcations error-prone (or
even insuﬃcient) for implementations on mobile platforms.
4.1 Dissecting the OAuth speciﬁcations
Our analysis is focused on authorization and authentica-
tion. For each of these two problems, we identify key el-
ements within the two speciﬁcations (OAuth 1.0 [26] and
OAuth 2.0 [27]) that account for their security. We focus on
three OAuth protocol ﬂows: OAuth 1.0 (Figure 1), OAuth
2.0 implicit grant (Figure 2a) and authorization code grant
(Figure 2b).
Note that, as a prerequisite of any OAuth protocol ﬂow,
the relying party must obtain an ID and a secret from the
service provider. This is typically done by registering the
relying party application through the service provider.
4.1.1 Authorization
Authorization is a process that enables an end-user to
grant a relying party access to his or her protected resource
stored on a service provider. The security audience for au-
thorization is the service provider. That is, the user’s sensi-
tive information is located on the service provider, and the
service provider must verify that the protected resource is
sent to the same party that the user had granted access to.
Although the descriptions of the three protocol ﬂows in
the OAuth speciﬁcations are fairly complicated, we believe
that each has a few key elements for secure authorization,
as we identify below.
OAuth 1.0 – The OAuth 1.0 speciﬁcation requires every
token request and protected resource request to be signed
by the relying party using the secret obtained during the
application registration stage. The security for authoriza-
tion is achieved between Steps 8 and 9 of the protocol (see
Figure 1) when the service provider veriﬁes the signature
of the protected resource request. Assuming that the rely-
ing party secret is only known to the relying party and the
service provider, this step ensures that the receiver of the
protected resource is the same party that the user granted
the request to.
OAuth 2.0 implicit grant – The OAuth 2.0 framework
requires the relying party to provide a redirection URI when
registering itself to the service provider. This redirection
URI is an essential element for achieving security for autho-
rization using the implicit grant. In Step 2 of the implicit
grant (see Figure 2a), the redirection URI provided by the
relying party is checked against the registered redirection
URI in the service provider’s database.
If the two URIs
match, it means that the user is granting access to the same
relying party that the access token is sent to.
OAuth 2.0 authorization code grant – The autho-
rization code grant augments the implicit grant by adding
an additional step that allows a service provider to verify
the identity of a relying party. Security for authorization is
achieved in between Step 4 and Step 5 of the protocol (see
Figure 2b). At this point, the service provider authenticates
the relying party using its application ID and secret pro-
vided in Step 4 (recall that this ID-secret pair is obtained by
the relying party during the application registration stage).
After authenticating the relying party, the service provider
must verify that this relying party is the same as the one
that the user had granted access to in Step 2 of the proto-
col. This step ensures that the protected resource is sent to
the correct relying party.
4.1.2 Authentication
Although many websites and applications use OAuth for
authentication, these use-cases are unspeciﬁed by both OAuth
standards (1.0 and 2.0). This section provides our insights
on the protocol details that are important to achieve secure
authentication.
Authentication is a process where an end-user signs onto
a relying party account by proving to the relying party that
he/she is a certain user on the service provider. Unlike au-
thorization, the security audience for authentication is the
relying party. That is, the protected resource is located on
the relying party (i.e., the user’s relying party account), not
the service provider.
To leverage OAuth for authentication, a relying party uses
the OAuth authorization ﬂow to request the user’s account
ID from the service provider. Once this account ID is re-
trieved from the service provider, it can be used to identify
the user on the relying party. However, because the secu-
rity goals of authentication are very diﬀerent from those of
authorization, not all OAuth protocol ﬂows are secure for
authentication.
In general, in order to determine whether an authorization
protocol ﬂow can be used for authentication, there are two
properties that the relying party must ensure. First, the
relying party must ensure that the user ID received from
the service provider cannot be tampered with by the user.
Otherwise, an adversary can impersonate arbitrary users.
Second, the relying party must check that OAuth tokens
used to retrieve the user ID is granted to the same relying
party.
If this check is not done, an adversary could use
tokens issued to a malicious application to sign onto users’
benign relying party account.
We now examine the three canonical OAuth protocol ﬂows
and analyze whether they can be used for authentication.
OAuth 1.0 – There are two aspects of the OAuth 1.0 pro-
tocol that make it secure for authentication. First, the user
ID exchange in Step 8 and 9 of the protocol (see Figure 1)
are done using server-to-server API calls. These calls can-
not be tampered by the user. Second, the signature check
in Step 8 ensures that the access token used to retrieve the
user ID is granted to the same relying party. That is, the
user is using this access token to sign onto the same relying
party.
OAuth 2.0 implicit grant – Unfortunately, the implicit
grant is insecure for authentication. Since access tokens in
OAuth 2.0 are no longer bound to relying parties (i.e., any-
one with a valid access token can use it to exchange for the
user ID), it is impossible to verify whether the user is using
an access token to sign onto the same relying party. A ma-
licious relying party could obtain access tokens from users
signing onto itself, then use these access tokens to log into
a benign relying party, impersonating these users.
OAuth 2.0 authorization code grant – We mentioned
previously that the reason why the implicit grant cannot be
used for authentication is because OAuth 2.0 access tokens
are not bound to relying parties they are issued to. This
problem is mitigated in the authorization code grant using
an additional parameter called the authorization code. A
service provider implementing the authorization code grant
does not send access tokens to relying parties using browser
redirection. Instead, access tokens are delivered using server-
to-server API calls (Steps 6 and 7 of Figure 2b), which can-
not be tampered by a malicious user. Access tokens are
exchanged using authorization codes (Steps 4 and 5 of Fig-
ure 2b), where each authorization code is bound to the re-
lying party it was issued to. By verifying the redirection
URI associated with the authorization code in Step 4 of the
protocol, the service provider can make sure that the access
token is always sent to the relying party that the user tries
to authenticate to.
4.2 Differences between mobile and web plat-
forms that affect OAuth security
The previous subsection showed that the three OAuth pro-
tocol ﬂows diﬀer signiﬁcantly. Each ﬂow is carefully designed
with unique checks (e.g., app secret or redirection check)
and message delivery methodologies (e.g., browser redirec-
tion or server-to-server API call) to provide security. In this
subsection, we shift our attention to mobile platforms and
identify key factors that make OAuth diﬃcult to adopt for
mobile applications. Speciﬁcally, we demonstrate that since
the OAuth speciﬁcations were written primarily for the web
community, many core concepts that are essential for secu-
rity cannot be trivially converted to the mobile world. This
causes mobile developers to frequently resort to their own
interpretations while implementing the protocol, making the
development process error-prone.
Diﬀerent redirection mechanisms – One web concept
that is heavily used throughout both OAuth speciﬁcations is
browser redirection (e.g., using the HTTP 302 status code).
This mechanism is used for directing a user to the service
provider and delivering OAuth tokens (e.g., request token
or access token) to the relying party.
While the process of handling HTTP 302 status code
is well deﬁned for browsers, it is unclear how to perform
the same redirection on mobile applications. Unfortunately,
both OAuth speciﬁcations ignore this factor by labeling the
methodology for performing redirection as an implementa-
tion detail. For example, the following excerpt was taken
from the OAuth 2.0 speciﬁcation [27].
This speciﬁcation makes extensive use of HTTP
redirections, ... any other method available via
the user-agent to accomplish this redirection is
allowed and is considered to be an implementa-
tion detail.
The closest concept related to browser redirection on mo-
bile platforms is the custom scheme mechanism on iOS and
the Intent mechanism on Android. They are used by mo-