Speciﬁcally, MassBrowser inspects every network request in-
dividually to decide how to best handle that request; this is in
contrast to standard circumvention systems that naively proxy
everything through their circumvention proxies. To perform
such per-request proxying, MassBrowser creates a content
whitelist, which speciﬁes how different content objects should
be handled. The whitelist is maintained by the Operator and
is regularly synced by all of the Buddies and Clients.
Creating the Whitelist: We create our list of censored
domains using the data released by several recent censorship
measurement studies, in particular, the IClab [51] and Great-
Fire [28], that have assembled lists of censored domains for
different censorship areas (note that we exclude controversial
censored webpages, such as adult content, from our list to
preemptively protect our Buddies; such objects are fetched
through Tor, as explained later). For each of the censored
domains in our list, we identify all of its web objects and create
rules for fetching each of those objects. This is done using our
automated technique that crawls each censored website using
the Chrome web browser and follows all of its inner links (with
a depth 3), then creates regular expressions to identify all the
corresponding domains/subdomains of that censored domain.
For each web object, our crawler creates one of the following
three rules:
• If the object
is not censored,
it will be assigned a
NonCensored tag; such objects will be fetched directly
through the Internet (without using a Buddy).
• If the object is censored, our crawler will check if it can
be browsed through CacheBrowser [30], [85]. If yes, it
will be assigned a CacheBrowsable tag, and it will
create rules on how to fetch it from CDNs (we use the
code from prior work [30], [85]).
• Finally, if the object is censored but not CacheBrowsable,
it will be assigned a MassBrowsable tag; such objects
will be fetched through a Buddy.
We perform a similar whitelisting mechanism for non-web
objects that are generated by other applications. For instance,
we have created rules for Telegram and Tor trafﬁc based on
the IP addresses of Telegram servers and public Tor relays.
Enforcing the Whitelist: Figure 4 demonstrates the selective
proxying process performed by a MassBrowser Client for each
requested object, based on the content whitelist. Note that,
in order to enforce such whitelisting policies, the Client’s
web browser delegates DNS resolution to MassBrowser’s
Client software (this requires disabling the browser’s DNS
caching); therefore, proxy destinations must be hostnames, not
IP addresses. This enables distinguishing requests to different
hosts that resolve to same (shared) IP addresses. For every web
request by a user, the Client software looks up the requested
destination hostname in the whitelist, identiﬁes which website
the hostname belongs to, identiﬁes whether the website is
censored, and determines the content types associated with
that website. If the request is censored and the Client already
has an open session with a Buddy that supports the required
content’s type, it will use the existing connection to proxy that
request. Otherwise, the Client will be assigned a Buddy who
has whitelisted the category of the requested content.
Maintaining the Whitelist: Note that the Operator regularly
updates its whitelists by adding/updating rules for censored
websites (e.g., based on the most recent measurement data).
The Operator regularly (once a day) pushes the changes of the
whitelist to all Clients and Buddies, which they incorporate
into their local whitelist databases.
Enforcing Buddy Preferences: Each whitelisted domain is
assigned a content category as shown in Table III. Each Buddy
is able to choose what categories of censored content she is
willing to proxy to (as shown in Figure 5). If a Buddy disallows
a category, it will not proxy any websites from that category.
As explained above, a Buddy is in charge of performing DNS
resolution for its Client requests; therefore the Buddy will be
able to ensure that the Client is not violating the Buddy’s
9
Fig. 4. Optimizing proxying load by a MassBrowser Client through selective proxying. The Client will check each requested object against the content
whitelist, as introduced in Section V-C, to decide how to handle the requested object. If the requested object is non-censored, it will be obtained directly; if
it is CacheBrowsable, it will be obtained from the corresponding CDN servers; otherwise, the object will be requested through a Buddy (if it is tagged as
MassBrowsable), or sent through Tor if no Buddy supports that censored object.
destination restrictions.
Note that to preemptively protect our Buddies, we have
excluded controversial webpages/categories (such as adult con-
tent) from the whitelist of Buddies. As shown in Figure 4, for
a requested domain that is not whitelisted, MassBrowser will
request it through a generic circumvention system; our current
design sends such connections through Tor. Note that in such
a setting, MassBrowser will act as a Tor bridge [14], so it is
not impacted by the potential censorship of Tor.
Fig. 5. The settings page in the MassBrowser Buddy software allowing the
user to select it’s allowed content types
The Complexity of Whitelisting: We store the whitelists
as regular expressions in a hashmap data structure in which
each key consists of the two right-most part of the domain
name, and its corresponding value is the regular expression.
Whenever a new connection arrives, the client extracts the two
right-most domain name of that connection, and checks against
the whitelist. If it is not found, it is considered to be non-
censored. If the domain is in the list, the client will check if the
whole domain matches the corresponding regular expression,
10
TABLE III.
CONTENT CATEGORIES IN MASSBROWSER
Category
News
Email
Search Engine
Gaming
Social Network
Sharing Platforms
Messaging
Tor
Example
CNN, BBC, ...
Gmail, Ymail, ...
Google, Bing, ...
Steam, Blizzard, ...
Facebook, Twitter, ...
Dropbox, Flicker, ...
Telegram, Whatsapp, ...
Tor
which has a time complexity of O(s), where s is the length
of the URL. Therefore, the worst case time complexity of our
whitelisting method is O(s), but s is small for most domains.
D. Encryption and Trafﬁc Obfuscation
In MassBrowser all of the communication between Clients
and Buddies are encrypted in order to resist DPI attacks de-
ployed by the censors. A matched pair of Client-Buddy encrypt
their messages using a symmetric cipher with a shared secret
key that they share through the Operator. Our implementation
currently uses AES 256 for Client-to-Buddy encryption.
We also implement trafﬁc obfuscation to protect Mass-
Browser’s trafﬁc against trafﬁc analysis attacks [31], [24], [76].
Particularly, we have built a custom implementation of the
obfsproxy [53] Tor pluggable transport tailored to work with
our MassBrowser implementation. The obfuscation algorithm
removes identiﬁable trafﬁc patterns, making the Client-Buddy
protocol look like benign peer-to-peer trafﬁc, e.g., p2p gaming
or ﬁle sharing trafﬁc.
E. Communication Sessions in MassBrowser
We deﬁne a MassBrowser session to be a connection
between a Client and a Buddy. Upon receiving a request from
the browser, the Client checks whether the request can be
handled with any of the currently active sessions the Client
has, i.e., whether any of the connected Buddies will accept
the request in their whitelisted categories. If no such session
is found, the Client will need to ask the Operator to assign it a
new session with a suitable Buddy that will accept the request.
NoConnectDirectlyIsCensored?YesIsCacheBrowsable?YesCacheBrowseProxy	throughBuddyContent PublisherCDN ServerBuddyEncryption and Obfuscation www.bbc.comClientOperatorHTTPS ChannelCacheBrowsingControlling signalsPolicyManagerSessionManagerAvailable SessionNoRequest a new SessionYesCDNYesNoIsMassBrowsable?Proxy	Torthrough	MassBrowserThe Operator will select a Buddy to assign to the Client
and will notify both parties to establish a new session. Each
session has the following attributes:
1) Allowed content types: This is the list of content types
that the Client is allowed to obtain through this session.
2) Shared Keys and Cipher Suite: All communications be-
tween the Client and Buddy are encrypted with a shared
key and cipher suite shared through the Operator.
3) Obfuscation method: In order to prevent ﬁngerprinting
attacks on the Client-Buddy communication protocol, the
Operator may instruct the users to use one of the available
obfuscation algorithms if the censoring region is known
to deploy DPI attacks.
4) Connection initiator: Based on NAT type of the peers,
the Operator will instruct one of the users to initiate
the connection with the other using an appropriate NAT
traversal technique, as described earlier.
5) Expiration time: Each session is only valid within a
deﬁned time period. The Client will have to ask to renew
the session if he wishes to continue using it beyond the
expiration time. This is to perform load balancing on
Buddies over time.
The Operator will send the details of each new session
to the corresponding Client and Buddy. The party who has
been selected as the connection initiator will then attempt
to establish a connection with the other party. The receiving
party will keep the session in a list of pending sessions until
either the connection is established or the session expires. Each
session can only be used once, and both parties will notify the
Operator once the session connection has been established.
Timeline of events: Figures 6, 7, and 8 depict the timelines of
communications between Buddies, Clients, and the Operator.
As shown in Figure 6, when a Buddy starts, it sends a request
to a STUN server to get its remote port and IP address. Then,
Buddy updates the Operator with its new IP address and port
number. Next, the Operator checks if the Buddy is reachable
(either using TCP or UDP). The Buddy regularly repeats these
steps to make sure that the Operator is up to date. Therefore,
the Operator keeps track of all of Buddies and their reachability
status.
Fig. 6. Each Buddy sends status updates to the Operator to keep it updated on
the Buddy’s connectivity. The Buddy regularly contacts some STUN servers
to check if it is behind NAT and to obtain its public ports. Then, it will send its
public port information to the Operator. Also, the Operator regularly checks
the reachability of each of the Buddies using their public port numbers.
Figure 7 illustrates the procedure for requesting a new
session by a Client through the Operator. Each Client pre-
emptively requests for sessions to reduce the overall waiting
times for session creation.
Finally, Figure 8 summarizes the overall timeline of com-
munications between MassBrowser parties. When an applica-
tion (e.g., a browser) sends a new request to MassBrowser, the
client will check if it has a session for that request (assuming
the request is for a censored content), and if so, the Client
starts using that speciﬁc session for the request. If not, the
Client will requests a new session for that speciﬁc content.
VI. PERFORMANCE EVALUATION
A. System Performance
We evaluated the performance of MassBrowser’s different
phases of operation. We used our own MassBrowser clients for
the measurement due to ethical reasons. Also, as mentioned
earlier, while the Operator uses domain fronting, it can be
11
Fig. 7.
Session creation procedure by a Client. When a Client decides to
create a new session for a requested object, it will contact the Operator to
ask for a Buddy that supports the requested object. The Operator assigns
a Buddy using its relay assignment mechanism in Section V-B (e.g., based
on the preferences of Buddies). Next, the Operator contacts the Buddy and
requests a new session, which the Buddy can reject or accept the new session.
If the selected Buddy rejects the session (e.g., is unreachable), the Operator
will assign another Buddy. Once a Buddy accepts the session, the Operator
will create a “session data” token that includes the cryptographic keys and
protocol speciﬁcations for that session; the session data token is sent to the
corresponding Client and Buddy. Finally, the Client initiates a connection to
the assigned Buddy using the information in the session data token.
OperatorBuddySTUN ServerWhat is my NAT port? NAT PortNat PortUpdate Buddy InformationCheck ReachbilityUpdate Buddy InformationloopClientOperatorBuddySTUN ServerRequest new BuddyAssign a Buddy Request Session Accept SessionSession DataSession DataInitiate ConnectionACKSession ConnectedEncrypted DataEncrypted Responseexpandable+Status Update (Fig. 6)Fig. 8. A typical MassBrowser communication session between a Client and a Buddy. Upon receiving an object request (from a web browser in this example),
the Client will check against the content whitelist (Section V-C) to decide how to handle that object. If the requested object is MassBrowsable (as deﬁned in
Section V-C), the Client will check if there already exists a session that can be used to fetch that object, otherwise she will request the Operator for a new
session (Figure 7). (“alt” refers to the different alternatives)
deployed using any high-latency boostrapping mechanism. To
demonstrate that, we artiﬁcially increase the latency of the
Operator’s responses in our performance measurement.
Software Boot Up: Whenever a user starts the Client, it
connects to the Operator to get the latest whitelisting rules
and updates. We ran 100 Clients and measured the average
boot up time. The average boot up latency for the very ﬁrst
run of Client is about 20 seconds (with a standard deviation 5
seconds), while future boot ups takes an average of 4 seconds
(with a standard deviation of 0.5 second). To demonstrate
the possibility of deploying the Operator using high-latency
channels (e.g., SWEET [35]), we artiﬁcially increased the
response time of the Operator to 5 minutes. And expected,
this slowed down the client’s start up accordingly. However, it
did not break nor interfered with the operation of the Client
software.
receives a connection to a destination not supported by the
existing session, the client will create a new session. In our
measurements, each session creation takes about 0.7 second
on average (with a standard deviation of 0.07 second). To
demonstrate the possibility of using a high-latency channel for
session creation, we artiﬁcially increased the response time of
Operator to 1 minute. Even with such a large latency, Client
is able to create sessions without breaking down.
Data Communication: MassBrowser uses a custom protocol
over TCP/UDP for the communications between Clients and
Buddies. We measure the throughput of this protocol using our
own Client and Buddy machines, connected through a 1Gbps
network: the throughput is 30MB/s over TCP and 10MB/s over
UDP.
Session Creation: A key phase of MassBrowser’s operation
is the session creation process. Each Client will preemptively
create a general session, but whenever the client software
Operator’s Capacity: Our current implementation of Op-
erator is deployed on AWS using a ’t2.large’ instance and
a ’t2.medium’ instance. We used the Apache HTTP server
12
FirefoxClientOperatorBuddySTUN ServerCensored WebsiteNew ConnectionIs MassBrowsable (Fig. 4)?Assign SessionAssign SessionDataEncrypted DataDataReposnseEncrypted Response DataResponseexpandable+Status Update (Fig. 6)expandable+New Session Request (Fig. 7)alt[Existing Session]expandable+New Session Request (Fig. 7)benchmarking tool4 to evaluate our current (light-weight)
deployment of Operator against 1,000,000 clients (100 con-
current clients), showing an average response time of 400ms
without any failed connections.
B. Buddy Bandwidth Contribution
Our analysis of the top 1000 Alexa website homepages [2]
ﬁnds the average size of each webpage to be 2.4 MB. We found
41% of the generated trafﬁc by these pages to be CacheBrows-
able, which is very promising for MassBrowser regarding load
optimization (note that most of the CacheBrowsable webpages
are partially CacheBrowsable [85],
therefore MassBrowser
needs to proxy only the non- CacheBrowsable components).
Therefore, in order to load a typical page through MassBrowser
the client will only need to proxy an estimated 1.4 MB through
the Buddies. The Akamai State of the Internet Connectivity
Report [1] estimates the Internet bandwidth of an average
user living in the United States in 2017 to be 18.7 Mbps.
Assuming volunteers will provide MassBrowser with 25% of
their unused bandwidth, an average Buddy in the United States
will contribute 4.7 Mbps when not using the Internet, which
translates into a page load every 2.5 seconds. Also, recall that
in MassBrowser, the bandwidth of Buddies is solely used for
loading censored content.
C. Costs of Operation
Ensuring low operational cost is one of the primary design
goals of MassBrowser. The (bulky) circumvention trafﬁc of
MassBrowser clients is handled by volunteer Buddies. There-
fore, the only operational cost of MassBrowser is imposed
by running the Operator. Recall that the Operator is deployed
as a domain fronted service, i.e., hosted on a CDN, in order
to allow unblockable access to the censored users. In this
section, we show that while domain fronting is known to be
prohibitively expensive for proxying [46], it imposes little costs
on MassBrowser as it is only used for its control trafﬁc.
There are three factors that contribute to the Operator’s
operational costs:
1) Number of Client-Requested Sessions Per Day: Each
session established between a Client and a Buddy is capable
of serving any volume of trafﬁc to different destinations as
long as they satisfy the content type restrictions imposed by the
Buddy. Therefore, it is unlikely that a Client will require more
than a few active sessions at any given time. Our evaluation
of a typical Client shows that 20 sessions per day is sufﬁcient
for typical web browsing.
2) Size of Session Objects: Upon creation of a new session
between a Client and a Buddy, the Operator will need to
exchange some protocol messages to the two parties. The
exchanged information is composed of a 500 byte ﬁxed-
size segment containing details about the IP addresses, ports,
NAT types, connection initiator, secret key, and the session
expiration date, along with a variable-size segment listing the
content types that will be accepted on the session (each content