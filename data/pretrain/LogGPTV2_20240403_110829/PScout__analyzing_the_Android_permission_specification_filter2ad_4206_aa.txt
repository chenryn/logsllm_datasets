title:PScout: analyzing the Android permission specification
author:Kathy Wain Yee Au and
Yi Fan Zhou and
Zhen Huang and
David Lie
PScout: Analyzing the Android Permission Speciﬁcation
Kathy Wain Yee Au, Yi Fan Zhou, Zhen Huang and David Lie
Dept. of Electrical and Computer Engineering
University of Toronto, Canada
ABSTRACT
Modern smartphone operating systems (OSs) have been de-
veloped with a greater emphasis on security and protecting
privacy. One of the mechanisms these systems use to pro-
tect users is a permission system, which requires developers
to declare what sensitive resources their applications will
use, has users agree with this request when they install the
application and constrains the application to the requested
resources during runtime. As these permission systems be-
come more common, questions have risen about their design
and implementation. In this paper, we perform an analysis
of the permission system of the Android smartphone OS in
an attempt to begin answering some of these questions. Be-
cause the documentation of Android’s permission system is
incomplete and because we wanted to be able to analyze sev-
eral versions of Android, we developed PScout, a tool that
extracts the permission speciﬁcation from the Android OS
source code using static analysis. PScout overcomes several
challenges, such as scalability due to Android’s 3.4 million
line code base, accounting for permission enforcement across
processes due to Android’s use of IPC, and abstracting An-
droid’s diverse permission checking mechanisms into a single
primitive for analysis.
We use PScout to analyze 4 versions of Android spanning
version 2.2 up to the recently released Android 4.0. Our
main ﬁndings are that while Android has over 75 permis-
sions, there is little redundancy in the permission speciﬁca-
tion. However, if applications could be constrained to only
use documented APIs, then about 22% of the non-system
permissions are actually unnecessary. Finally, we ﬁnd that
a trade-oﬀ exists between enabling least-privilege security
with ﬁne-grained permissions and maintaining stability of
the permission speciﬁcation as the Android OS evolves.
Categories and Subject Descriptors
D.4.6 [Security and Protection]: Access controls, Infor-
mation ﬂow controls
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$10.00.
General Terms
Design, Security
Keywords
Android, Permissions, Smartphone
1.
INTRODUCTION
One of the distinguishing and desirable characteristics of
smartphones over traditional feature phones is that they are
capable of running applications written by third party devel-
opers. This capability, combined with their highly personal
nature, has raised concerns about the threat that smart-
phones pose to the privacy and security of their users. To
address these concerns, many smartphone operating systems
(OS) implement some sort of permission system to control
access by third party applications to sensitive resources, such
as the user’s contact list or the phone’s microphone [1]1.
Because of the rapidly growing number of smartphone
users and the wide use of permission systems on these plat-
forms, it is important that we gain a better understanding
of the implementation and design of smartphone permission
systems.
In this paper, we take some ﬁrst steps towards
answering some of the key questions that have arisen about
the permission system of Android, which is the most widely
deployed smartphone OS at the time of writing. In particu-
lar:
• Is the plethora of permissions oﬀered by Android (79
permissions available to third party applications as
of Android 4.0) useful or would a smaller number of
coarser permissions provide an equal amount of pro-
tection [1, 3]?
• Android has many undocumented APIs that are used
by third party applications [14]. Do many of these
undocumented APIs require permissions and how com-
monly do third party applications use such undocume-
nted APIs?
• The large number of permissions and APIs in Android
suggests that the permission speciﬁcation for Android
will be very complicated. How complex is the speci-
ﬁcation and how heavily interconnected are diﬀerent
API calls with diﬀerent permissions?
1The notable exception is Apple’s iOS, which relies on man-
ual vetting of applications. Manual vetting may protect
against malicious applications, but does not prevent priv-
ilege escalation if a benign application is compromised.
217• Android has gone through several major revisions and
now has one of the more mature permission systems
among smartphone OSs. How has it evolved over time
and what might newer smartphone OSs such as Win-
dows Phone 7 and Boot to Gecko (B2G) learn from
this?
To perform such a study, we need a speciﬁcation for the
Android permission system that lists the permission require-
ments for every API call. More importantly, we also need
permission speciﬁcations for more than one version of An-
droid. Unfortunately, Google does not provide such a spec-
iﬁcation as the Android permission documentation is very
incomplete [21]. The Stowaway project currently lists the
permissions required for over 1,200 documented and un-
documented API calls for Android 2.2 [14]. To produce
valid results, Stowaway requires manually specifying some
API input arguments and sequences, which unfortunately,
must be re-speciﬁed for other versions of Android. Using a
slightly diﬀerent permission speciﬁcation extraction tool for
each Android version will introduce noise into any compar-
isons drawn across versions. The amount of manual eﬀort
required makes it infeasible to reuse Stowaway to generate
speciﬁcations for multiple Android versions. In addition, be-
cause Stowaway relies on feedback directed API fuzzing to
extract a speciﬁcation, its speciﬁcation is incomplete – Stow-
away can only exercise API calls it can ﬁnd, and of those, it
is only able to successfully execute 85% of them.
To perform our study, we needed a method of extracting
the permission speciﬁcation from Android that is applica-
ble to any Android version without modiﬁcation. The tool
should be able to capture permission requirement for every
documented and undocumented API calls. To accomplish
this, we implemented a static analysis tool called PScout
(short for Permission Scout), which performs a reachability
analysis between API calls and permission checks to pro-
duce a speciﬁcation that lists the permissions that every
Android API call requires. Because PScout examines the
entire source code implementing the Android API, it can
identify every Android API that can be called and produce
a mapping to the permissions that the API call may need.
An added beneﬁt of using reachability is that PScout also ex-
tracts information about the execution path an API takes to
reach a permission check, which we also use in our analysis.
PScout relies only on non-version speciﬁc Android functions
and components such as Binder, Intents, Content Providers
and permission check functions, allowing it be applied with-
out modiﬁcation to any version of Android.
We make the following contributions in this paper:
• We design and implement PScout, a version-indepen-
dent static analysis tool that extracts a permission
speciﬁcation from Android that is more complete than
existing speciﬁcations. PScout’s analysis ﬁnds over
17 thousand mappings between API calls and permis-
sions, which is considerably more than that found by
Stowaway.
• We measure the amount of imprecision introduced by
PScout’s scalable static analysis using an extensive
evaluation methodology that compares against appli-
cation developers. However, since developers them-
selves make errors in specifying permissions, we follow
up with an automated application UI fuzzer that val-
idates the permission mapping by exhaustively trying
to ﬁnd ﬂaws in it.
• We analyze the permission system of Android 4.0 as
well as how it has changed across 4 versions ranging
from Android 2.2 to 4.0. Our analysis shows that while
there is little redundancy in the permission speciﬁca-
tion, about 22% of the non-system permissions can be
hidden if applications only use documented APIs. We
also ﬁnd that while the Android permission speciﬁ-
cation is very broad, it is not very heavily intercon-
nected. More than 80% of API calls that may require
permissions check for at most one permission and 75%
of permissions are checked by fewer than 20 API calls.
Finally, we ﬁnd that across versions the amount of pro-
tection from permissions has remained relatively con-
stant to the increase in code size and functionality of
Android.
We begin with background on the Android OS in Sec-
tion 2. Readers familiar with Android may wish to start
at Section 3, which describes PScout’s static analysis and
method for extracting permission speciﬁcation. Section 4
evaluates the completeness and soundness of PScout’s ex-
tracted permission speciﬁcation. Section 5 describes our
analysis of the permission speciﬁcations of 4 Android ver-
sions. We discuss related work in Section 6 and conclude in
Section 7.
2. BACKGROUND
Android is a middleware OS implemented above a cus-
tomized Linux kernel. Android applications and system ser-
vices are all implemented in Java and make cross-domain
calls via a set of documented APIs exported by the An-
droid system services. We deﬁne the “Android Framework”,
as the set of Java libraries and system services that imple-
ment these Android APIs. However, rather than restricting
themselves to the documented Android APIs, third party
developers may use Java reﬂection or examine the source
code of Android to obtain references to any Java method
and use them in their code. We and others [14] have found
that applications do in fact use undocumented APIs, so we
include undocumented APIs in our analysis as well.
Android is characterized by the heavy use of IPC both
within applications and as a means of communication be-
tween applications and components of the OS. In addition to
traditional IPC mechanisms like shared memory and sockets,
Android introduces two Android-speciﬁc IPC mechanisms.
The ﬁrst are Intents, which is a uni-direction message with
an arbitrary action string that can be broadcasted to all
applications or sent to a speciﬁc application. Permissions
may be used to both restrict who may receive an intent sent
by an application, or to restrict who may send intents to a
particular application.
Android’s second IPC mechanism is Binder, which im-
plements Remote Procedure Calls (RPC). Once a remote
interface is properly deﬁned in an Android Interface Deﬁ-
nition Language (AIDL) ﬁle, it can be called just like any
other local method. System services accept asynchronous
Binder communication through the Message Handler class,
which wraps the Binder interface.
The Android framework also includes a set of system com-
ponents. One type of component is called a content provider,
218which implements databases that provide persistent data
storage for other application components. Applications spec-
ify which content provider they are addressing using Uniform
Resource Identiﬁers (URI) that start with content://. Con-
tent providers may require that applications hold certain
permissions to access them.
To access sensitive resources, users must grant the re-
quested permissions to applications. There are two ma-
jor types of permissions in Android: “Signature or system
permissions”, which are only available to privileged services
and content providers, and regular permissions, which are
available to all applications. Since third party applications
can only request regular permissions, we focus on extract-
ing a speciﬁcation for only the non-system permissions in
our analysis. Android developers manually declare all re-
quired permissions in the Android Manifest ﬁle (Android-
Manifest.xml). During installation, the Package Manager
Service, parses the Manifest ﬁle into a permission list. When-
ever the application tries to access a privileged system re-
source, the Android framework will query Package Manager
Service to check if the application has the necessary permis-
sion to do so.
3. PSCOUT DESIGN AND IMPLEMENTA-
TION
One of the challenges for PScout is the sheer size of the
Android framework. Table 1 (in Section 5) gives some statis-
tics across the diﬀerent Android versions to give the reader
an idea of the scale of the framework. Because of this,
PScout’s design is oriented towards making it scalable, with
only selective use of more detailed analysis to minimize loss
of precision.
PScout produces a permission speciﬁcation that is a set of
mappings between elements in the set of API calls and the
set of permissions that third party applications may request.
Because the mapping is produced between an API call and
a permission, it is necessarily an approximation – an API
may not require a particular permission in every context
it is invoked. In such cases, PScout returns a conservative
result – a mapping between an API call and a permission
is included in the speciﬁcation if the permission is required
on some execution of the API. In cases where PScout ﬁnds
that an API call may need more than one permission, it
assumes all permissions will be required when in fact only a
subset of those permissions may be needed on any particular
invocation of the API.
PScout leverages the Soot [20] Java bytecode analysis fra-
mework to perform static analysis. The extraction of the
permission speciﬁcation from the Android framework has
three phases. First, PScout identiﬁes all the permission
checks in the Android framework and labels them with the
permission that is being checked. Then, it builds a call
graph over the entire Android framework including IPCs and
RPCs. Finally, it performs a backwards reachability traver-
sal over the graph to identify all API calls that could reach
a particular permission check.
In some cases, the reacha-
bility traversal may ﬁnd additional permission checks that
were missed in the ﬁrst phase. As a result, the reachability
analysis is repeated until the number of permission checks
converges. Figure 1 gives a high level summary of the analy-
sis ﬂow in PScout and each phase is discussed in more detail
in the following Sections 3.1, 3.2 and 3.3.
Figure 1: PScout Analysis Flow.
PScout extracts a permission speciﬁcation from the An-
droid 4.0 Framework on an Intel Core 2 Duo 2.53 GHz CPU
with 4 GB of memory in 33 hours. The vast majority of
time is spent in two iterations of using Soot to extract in-
formation needed by PScout from the bytecode. Since each
bytecode ﬁle is analyzed independently, the total Soot anal-
ysis time scales linearly with the number of classes and each
ﬁle takes about 4 seconds to process. The rest of PScout’s
analysis completes within 30 minutes.
We restrict PScout’s analysis to only the non-system per-
missions implemented in the Android Open Source Project
(AOSP) that third party applications may hold. PScout’s
analysis only runs on the Android Framework where the
vast majority of permissions are checked in Java. PScout
cannot ﬁnd permission mappings for the four permissions
that are checked in native C/C++ code. As a result, we
handle these permissions by manually inspecting the source
code where these permission strings are used. In addition
to being enforced in the Java framework, some permissions
are also enforced by the kernel using Group IDs assigned
at installation time. PScout only captures the enforcement
done in the framework for these permissions and currently
does not capture the enforcement done in the kernel.
3.1 Permission Check Identiﬁcation
Android has three types of operations that will succeed or
fail depending on the permissions held by an application: (1)
an explicit call to checkPermission function that checks for
the presence of a permission, (2) methods involving Intents
and (3) methods involving Content Providers. We abstract
each of these into a permission check that indicates that a
certain permission must be held at that point by the ap-
plication. We describe how we abstract each of Android’s
permission check mechanisms below.
Explicit Functions: Permissions in Android appear as
string literals in the framework source code and values of the
permissions strings are documented by Google. The strings
are passed to the checkPermission function along with the
application’s user ID (UID) and the function checks if an
application with the UID holds the speciﬁed permission.
The ﬁrst step of identifying this type of permission check is
to ﬁnd all instances of permission string literals in the frame-
work source. In most cases, these are passed directly to a
Extract Android Source Information with Soot Identify Permission Checks: i) Explicit; ii) Intents; iii) Content Providers (Sec. 3.1) Generate Call Graph (Sec. 3.2) Refine Call Graph with IPC/RPC edges (Sec. 3.2) Perform Backward Reachability Analysis (Sec. 3.3) Found New Permission Check? Yes API Calls to Permission Mapping  No 219checkPermission function, which PScout then abstracts as
a permission check. However, in some cases, the permission
string is passed to a function that is not a checkPermis-
sion function. In these cases, PScout must determine if this
string is eventually passed to a checkPermission function or
not. To do this, PScout uses Soot’s def-use analysis to ﬁnd
all the uses of the string. If any of the uses is a checkPer-
mission function or a permission wrapper function, PScout
abstracts the function where the string literal appears as a
permission check. If no checkPermission function appears
in any of the uses of the literal, then PScout checks if it is
an Intent function, which we discuss below.
Finally, some functions use a permission string without
invoking a checkPermission function or an Intent function.
There were a few instances of such functions which we in-
spected manually. We found that none of these are per-
mission checks. For example, a permission string is used to
query whether the permission is listed for a particular ser-
vice; two permissions are implicitly added to applications
developed for older versions of the Android SDK for com-
patibility and a permission string is used to set an internal
ﬂag in a class.
Intents: Sending and receiving of Intents may require
permissions. This requirement can be expressed in two ways.
First, a requirement to hold a permission to send or receive
an Intent can be speciﬁed in the Manifest ﬁle. PScout ex-
tracts the Intent action strings associated with each permis-
sion from the Manifest ﬁle. Second, permission to send or
receive an Intent can be expressed programmatically when
the method to send or receive an Intent is called. To send
an Intent, an application may call sendBroadcast with an
optional permission string that speciﬁes that the receiver of
the Intent must hold that permission. Similarly, to receive