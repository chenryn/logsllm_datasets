The information service provides information about how
long certain cryptographic primitives and parameters are es-
timated to be secure. It is also possible to ask whether or not
a certain cryptographic method or parameter was considered
secure at a given point in time in the past. Supported cryp-
tographic primitives and parameters are hash functions as
well as signature schemes together with recommended key
lengths. In order to fulﬁll these tasks, the implementation
maintains an inventory showing for each of the supported
primitives and parameters until when they are expected to
be secure. These dates can be updated if new attacks are
discovered. This type of online service could, for instance,
be operated by governmental agencies such as NIST9.
Notarial Authority (NA).
The NA issues and renews notarial attestations, as de-
scribed in Section 6.1, which are transferred in the form of
XML documents. Our NA also supports the migration pro-
cess proposed in Section 5.2. This process requires sending a
MoPS ZIP ﬁle containing all documents together with their
proof of existence to the NA. The NA is in possession of mul-
tiple RSA signature keys with diﬀerent key lengths. Which
one is used depends on the hash function submitted in the
initialization or renewal request (see Table 4 in Appendix
A.1 for details).
6.3.2 Storage Service
The storage service provides a simple object storage solu-
tion: When uploading a ﬁle, it will be stored in a single folder
on the service host and a random string will be returned.
This string serves as an identiﬁer for further operations on
the object. In a cloud or enterprise deployment scenario, the
storage service could easily be adopted to work as a proxy
for Amazon S310 or a distributed network ﬁle system such
as Ceph11, thereby providing reliability and scalability for
extremely large data sets.
6.3.3 Core Service
The core service is responsible for performing operations
on evidence records: it a) initializes proofs of existence for
documents by creating new data structures according to a
9https://www.nist.gov/
10https://aws.amazon.com/s3/
11https://www.ceph.com/
given protection scheme conﬁguration, b) adds documents
to an existing data structure, c) migrates proofs of exis-
tence from one protection scheme conﬁguration to another,
d) updates proofs of existence according to the given update
parameters, and e) veriﬁes a complete proof of existence or
only a speciﬁc document protected by an evidence record.
For creating attestations, the core service relies on the
third-party TSAs and notarial authorities speciﬁed in the
update parameters. A storage service is used for hashing
objects referenced by proofs of existence and for reading
or writing evidence records. An information service is em-
ployed for getting information about cryptographic primi-
tives and parameters during veriﬁcation.
Following the only formally standardized protection
schemes AdES and ERS, MoPS stores proofs of existence
in the XML format. The XML schema deﬁning valid XML
evidence records can be found online at http://encrypto.
de/code/MoPS. The Java JDK comes with a binding com-
piler called xjc which was used to generate Java Architecture
for XML Binding (JAXB) annotated Java classes from the
XML schema. These annotations are then used to automati-
cally create XML representations from Java objects and vice
versa.
6.3.4 Protection System
The protection system is the service back-end for the Web
App. It is responsible for maintaining (i.e. creating, renam-
ing, updating, and deleting) information about protection
schemes and protected documents in a database. The pro-
tection system is also responsible for importing and export-
ing protected documents. For performing operations on ev-
idence records, the protection system uses the core service.
In addition, whenever a document or a folder of docu-
ments is imported or updated, the protection system per-
forms validity estimations in order to predict how long a
proof of existence is considered valid. To do so, the latest
attestation is extracted from the evidence record. Then, the
protection system sets the estimation value to the earliest
of the following dates obtained from an information service:
a) the date until which the hash function used for creating
the attestation is considered secure, b) the date until which
the signature scheme used for signing the attestation is con-
sidered secure, c) the date until which the key length of the
signature key for signing the attestation is considered secure,
and d) the date after which the certiﬁcate for the signature
key is no longer valid.
6.4 Performance Evaluation
In this section, we provide the results of a short perfor-
mance evaluation. It is not intended to be a comprehensive
comparison between diﬀerent protection schemes, as this
was done in [12, 10]. Instead, we want to give an intuition
for the additional computation time (given today’s hardware
and not considering potential increases of computer speed)
and storage space a user needs to invest in order to achieve
long-term protection using our implementation.
For the evaluation we run each data structure for 100 years
using the recommended access pattern for each of them. All
sequence-based data structures use signature-based times-
tamps, as our implementation does not support WVM-based
timestamps. For the public signature keys, we use certiﬁ-
cates with a lifetime of two years. Thus, signatures must be
renewed after two years by the latest. As to the selection of
446Table 3: Performance evaluation results. Runtimes
are given in ms and sizes in KB.
Data Structure
AS MTS MDS
SLS
NAW
Initialization
Updates
Attestation renewals
Hash renewals
Veriﬁcation
Proof of existence (size)
154
32 972
31 122
1 850
1 282
680
2 330
40 119
35 319
4 800
1 315
1 609
154
75 652
72 388
3 264
203
2 115
158
78 022
72 980
5 042
1 467
2 127
183
32 641
32 159
482
174
9
hash functions and key lengths, we follow the predictions by
Lenstra [7] and therefore use SHA-256 with RSA 2048 until
2038 before switching to SHA-384 with RSA 4096 until 2084
before ﬁnally switching to SHA-512 with RSA 8192. Thus,
in our evaluation there occur two hash renewals.
For AS and NAW, we protect and verify a single docu-
ment. MTS protects a set of 100 documents added during
initialization while only one of them is veriﬁed. For MDS
and SLS, we add a single document every year. For MDS,
we verify the last document, whereas for SLS we verify the
ﬁrst one. Each document is signed and has a size of 1 MB.
The evaluation test suite and all web services were hosted
on a single Tomcat 8 application server on Debian 8 powered
by an eight core AMD FXTM 8350 CPU @ 4.00 GHz with
16 GB of RAM. Therefore, the network connection between
the diﬀerent parties had minimal inﬂuence on the results.
More realistic measurements in a distributed environment
are part of future work.
The results are summarized in Table 3. The table shows
average values for 10 executions. Regarding initialization,
AS and MDS perform equally, as expected. SLS is a bit
slower, as initializing the parallel hash chains requires addi-
tional eﬀort. NAW is even slower than SLS, because the NA
performs a veriﬁcation step before creating its attestation.
Of course, MTS is the slowest data structure regarding ini-
tialization, as it creates a Merkle tree for 100 documents,
instead of protecting only one initial document. Regarding
veriﬁcation, MTS is a bit slower than AS as for MTS, au-
thentication paths must be used to reconstruct the attested
hash values. Although SLS contains twice as many attesta-
tions as AS and MTS, the veriﬁcation of the ﬁrst document
is only 14% and 12% slower, respectively. The reason why
MDS is slower than NAW is that for MDS a much larger
XML ﬁle needs to be opened and parsed before the actual
veriﬁcation procedure can start.
7. CONCLUSIONS AND FUTURE WORK
In this work we proposed the ﬁrst modular protection
scheme for long-term storage. More precisely, we provide
a set of techniques to build protection schemes which can
be plugged together, combined, and migrated. As a proof
of concept, we also implemented MoPS and provide perfor-
mance measurements.
For future work we plan to integrate techniques that pro-
vide long-term conﬁdentiality protection and to further im-
prove our implementation, e.g. by supporting automated re-
newals of proofs.
Acknowledgements
This work has been co-funded by the DFG as part of projects
S5 and S6 within the CRC 1119 CROSSING, by the Euro-
pean Union’s Horizon 2020 research and innovation program
under Grant Agreement No 644962, and by the German Fed-
eral Ministry of Education and Research (BMBF) as well as
by the Hessen State Ministry for Higher Education, Research
and the Arts (HMWK) within CRISP.
8. REFERENCES
[1] D. Bayer, S. Haber, and W. S. Stornetta. Improving
the Eﬃciency and Reliability of Digital
Time-Stamping. In Sequences II: Methods in
Communication, Security and Computer Science,
pages 329–334, 1993.
[2] A. J. Blazic, S. Saljic, and T. Gondrom. Extensible
Markup Language Evidence Record Syntax
(XMLERS), 2011.
[3] ETSI. XML Advanced Electronic Signatures (XAdES).
Number TS 101 903. 1.4.1 edition, 2009.
[4] T. Gondrom, R. Brandner, and U. Pordesch. Evidence
Record Syntax (ERS), 2007.
[5] S. Haber and P. Kamat. A Content Integrity Service
for Long-Term Digital Archives. In Archiving
Conference, pages 159–164. Society for Imaging
Science and Technology, 2006.
[6] D. Lekkas and D. Gritzalis. Cumulative Notarization
for Long-term Preservation of Digital Signatures.
Computers & Security, 23:413–424, 2004.
[7] A. K. Lenstra. Key lengths. In The Handbook of
Information Security, volume 2, pages 617–635. 2006.
[8] P. Maniatis and M. Baker. Secure History
Preservation Through Timeline Entanglement. In
USENIX Security ’02, pages 297–312, 2002.
[9] R. C. Merkle. A certiﬁed digital signature. In
CRYPTO ’89, pages 218–238.
[10] M. Vigil, J. Buchmann, D. Cabarcas, C. Weinert, and
A. Wiesmaier. Integrity, authenticity, non-repudiation,
and proof of existence for long-term archiving: A
survey. Computers & Security, 50(0):16–32, 2015.
[11] M. Vigil, D. Cabarcas, J. Buchmann, and J. Huang.
Assessing Trust in the Long-Term Protection of
Documents. In ISCC 2013, pages 185–191, 2013.
[12] M. Vigil, C. Weinert, K. Braden, D. Demirel, and
J. Buchmann. A Performance Analysis of Long-Term
Archiving Techniques. In HPCC 2014, pages 878–889,
2014.
[13] M. Vigil, C. Weinert, D. Demirel, and J. Buchmann.
An Eﬃcient Time-Stamping Solution for Long-Term
Digital Archiving. In IPCCC 2014, 2014.
447Table 4: The supported hash functions and corre-
spondingly used RSA key lengths.
Hash function RSA key length (in bit)
SHA-256
SHA-386
SHA-512
2048
4096
8192
A.2 Time-Stamping Authority (TSA)
The TSA service provides signature-based timestamps.
It behaves according to the Time-Stamp Protocol (TSP15).
That is, it receives binary encoded attestation requests and
returns binary encoded attestations in form of signature-
based timestamps. A timestamp request contains a hash to
be attested and the attestation returned contains a so-called
timestamp token which in turn contains the timestamped
hash, the time at which the timestamp was generated, the
TSA’s signature, and the TSA’s certiﬁcate. Just as the NA,
the TSA service is in possession of multiple RSA signature
keys with diﬀerent key lengths.
APPENDIX
A. ADDITIONAL THIRD-PARTY
SERVICES
Our MoPS prototype includes implementations for all re-
quired third-party services. In this section we provide details
regarding the CA and the TSA service.
A.1 Certiﬁcation Authority (CA)
The main purpose of the CA service in this context is
to oﬀer downloads of X.50912 certiﬁcates and CRLs. The
download URL of the former is embedded in the author-
ity information access (AIA) extension and of latter in the
CRL distribution point (CDP) extension. Downloading CA
certiﬁcates and CRLs is necessary for parties who need to
collect veriﬁcation data for certiﬁcates.
In addition, the CA prototype implementation fulﬁlls other
tasks which cannot be triggered via the service interface: it
issues certiﬁcates for services and users, revokes certiﬁcates
(e.g. after a key compromise), and updates CRLs. The cer-
tiﬁcates and CRLs are created and maintained using the
cryptography and SSL/TLS toolkit OpenSSL13.
Whereas in a real world deployment each CA hosts its own
dedicated service instance, our prototype provides certiﬁcate
and CRL downloads using a single service instance for three
hierarchical ordered CAs to simulate the existence of a real
PKI.
In fact, our implementation operates multiple PKIs with
the same entities and in the same hierarchy. Each of them
uses diﬀerent hash functions and RSA signatures with dif-
ferent signature key lengths. On the one hand, this allows
one to use the implementation for simulating the aging of
cryptography. On the other hand, end users can choose from
diﬀerent cryptographic primitives and parameters depend-
ing on the security level they feel most comfortable with.
For example, a user might want to use SHA-512 with RSA
8192 to sign an important document although SHA-256 with
RSA-2048 would be an appropriate choice according to all
current recommendations14. Table 4 shows the supported
hash functions and correspondingly used RSA key lengths.
Note that creating a signature using cryptographic primi-
tives with parameters which are expected to be still secure
for a very long time does not inevitably imply that less up-
dates are necessary to prolong the protection provided by
this signature: the lifetime of the corresponding certiﬁcates
is still a limiting factor.
12https://tools.ietf.org/html/rfc5280
13https://www.openssl.org/
14https://www.keylength.com/
15https://www.ietf.org/rfc/rfc3161.txt
448