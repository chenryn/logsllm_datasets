authorization grant request, as listed out in the following:
• 
grant_type: This is a required parameter, which defines the 
format of the assertion, as understood by the authorization 
server. The value of grant_type is an absolute URI, and it must be 
urn:ietf:params:oauth:grant-type:jwt-bearer.
• 
assertion: This is a required parameter, which carries the token. For 
example, in the case of JWT authorization grant type, the assertion 
parameter will carry the base64url-encoded JWT, and it must only 
contain a single JWT. If there are multiple JWTs in the assertion, then 
the authorization server will reject the grant request.
• 
scope: This is an optional parameter. Unlike in authorization code 
and implicit grant types, the JWT grant type does not have a way to 
get the resource owner’s consent for a requested scope. In such case, 
the authorization server will establish the resource owner’s consent 
via an out-of-band mechanism. If the authorization grant request 
carries a value for the scope parameter, then either it should exactly 
match the out-of-band established scope or less than that.
Note the oauth authorization server will not issue a refresh_token under the 
JWt grant type. if the access_token expires, then the oauth client has to get 
a new JWt (if the JWt has expired) or use the same valid JWt to get a new 
access_token. the lifetime of the access_token should match the lifetime of the 
corresponding JWt.
Chapter 12  Federating aCCess to apis
269
 Applications of JWT Grant Type
There are multiple applications of the JWT authorization grant type. Let’s have a look 
at one common use case, where the end user or the resource owner logs in to a web 
application via OpenID Connect (Chapter 6), then the web application needs to access 
an API on behalf of the logged-in user, which is secured with OAuth 2.0. Figure 12-3 
shows the key interactions related to this use case.
Figure 12-3. JWT grant type, a real-world example
The following lists out all the interactions as illustrated in Figure 12-3 by the number:
• 
The end user visits the web application (step 1).
• 
In step 2, the user gets redirected to the OpenID Connect server and 
authenticates against the Active Directory connected to it. After the 
authentication, the user gets redirected back to the web application, 
with an authorization code (assuming that we are using OAuth 2.0 
authorization code grant type).
• 
The web application talks directly to the OpenID Connect server 
and exchanges the authorization code from the previous step to an 
ID token and an access token. The ID token itself is a JWT, which is 
signed by the OpenID Connect server (step 3).
Chapter 12  Federating aCCess to apis
270
• 
Now the web application needs to invoke an API on behalf of the 
logged-in user. It talks to the OAuth authorization server, trusted by 
the API, and using the JWT grant type, exchanges the JWT from step 
3 to an OAuth access token. The OAuth authorization server validates 
the JWT and makes sure that it’s being signed by a trusted identity 
provider. In this case, the OAuth authorization server trusts the 
OpenID Connect identity provider (step 4).
• 
In step 5, the web application invokes the API with the access token 
from step 4.
• 
The application server, which hosts the API, validates the access 
token by talking to the OAuth authorization server, which issued the 
access token (step 6).
 JWT Client Authentication
The OAuth 2.0 core specification does not define a concrete way to authenticate OAuth 
clients to the OAuth authorization server. Mostly it’s the HTTP Basic authentication with 
client_id and the client_secret. The RFC 7523 defines a way to authenticate OAuth 
clients with a JWT. The JWT client authentication is not just limited to a particular grant 
type; it can be used with any OAuth grant types. That’s another beauty in OAuth 2.0—the 
OAuth grant types are decoupled from the client authentication. The following shows a 
sample request to the OAuth authorization server under the authorization code grant 
type, which uses JWT client authentication.
POST /token HTTP/1.1
Host: auth.bar.com
Content-Type: application/x-www-form-urlencoded
grant_type=authorization_code&
code=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&      
client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-
type%3Ajwt-bearer&
client_assertion=eyJhbGciOiJSUzI1NiIsImtpZCI6IjIyIn0.
eyJpc3Mi[...omitted for brevity...].
cC4hiUPo[...omitted for brevity...]
Chapter 12  Federating aCCess to apis
271
The RFC 7523 uses three additional parameters in the OAuth request to the token 
endpoint to do the client authentication: client_assertion_type, client_assertion, 
and client_id (optional). The Assertion Framework for OAuth 2.0 Client Authentication 
and Authorization Grants specification, which is the RFC 7521, defines these parameters. 
The following lists them out along with their definitions:
• 
client_assertion_type: This is a required parameter, which 
defines the format of the assertion, as understood by the OAuth 
authorization server. The value of client_assertion_type is an 
absolute URI. For JWT client authentication, this parameter must 
carry the value urn:ietf:params:oauth:client-assertion- 
type:jwt-bearer.
• 
client_assertion: This is a required parameter, which carries the 
token. For example, in the case of JWT client authentication, the 
client_assertion parameter will carry the base64url-encoded JWT, 
and it must only contain a single JWT. If there are multiple JWTs 
in the assertion, then the authorization server will reject the grant 
request.
• 
client_id: This is an optional parameter. Ideally, the client_id 
must be present inside the client_assertion itself. If this parameter 
carries a value, it must match the value of the client_id inside the 
client_assertion. Having the client_id parameter in the request 
itself could be useful, as the authorization server does not need to 
parse the assertion first to identify the client.
 Applications of JWT Client Authentication
The JWT client authentication is used to authenticate a client to an OAuth authorization 
server with a JWT, instead of using HTTP Basic authentication with client_id and 
client_secret. Why would someone select JWT client authentication over HTTP Basic 
authentication?
Let’s take an example. Say we have two companies called foo and bar. The foo 
company hosts a set of APIs, and the bar company has a set of developers who are 
developing applications against those APIs. Like in most of the OAuth examples we 
discussed in this book, the bar company has to register with the foo company to obtain 
Chapter 12  Federating aCCess to apis
272
a client_id and client_secret, in order to access its APIs. Since the bar company 
develops multiple applications (a web app, a mobile app, a rich client app), the same 
client_id and client_secret obtained from the foo company need to be shared 
between multiple developers. This is a bit risky as any one of those developers can pass 
over the secret keys to anyone else—or even misuse them. To fix this, we can use JWT 
client authentication. Instead of sharing the client_id and the client_secret with its 
developers, the bar company can create a key pair (a public key and a private key), sign 
the public key by the key of the company’s certificate authority (CA), and hand them 
over to its developers. Now, instead of the shared client_id and client_secret, each 
developer will have its own public key and private key, signed by the company CA. When 
talking to the foo company’s OAuth authorization server, the applications will use the 
JWT client authentication, where its own private key signs the JWT—and the token will 
carry the corresponding public key. The following code snippet shows a sample decoded 
JWS header and the payload, which matches the preceding criteria. Chapter 7 explains 
JWS in detail and how it relates to JWT.
{
  "alg": "RS256"
  "x5c": [
          "MIIE3jCCA8agAwIBAgICAwEwDQYJKoZIhvcNAQEFBQ......",
          "MIIE3jewlJJMddds9AgICAwEwDQYJKoZIhvUjEcNAQ......",
         ]
}
{
  "sub": "3MVG9uudbyLbNPZN8rZTCj6IwpJpGBv49",
  "aud": "https://login.foo.com",
  "nbf": 1457330111,
  "iss": "bar.com",
  "exp": 1457330711,
  "iat": 1457330111,
  "jti": "44688e78-2d30-4e88-8b86-a6e25cd411fd"
}
The authorization server at the foo company first needs to verify the JWT with the 
attached public key (which is the value of the x5c parameter in the preceding code 
snippet) and then needs to check whether the corresponding public key is signed by the 
Chapter 12  Federating aCCess to apis
273
bar company’s certificate authority. If that is the case, then it’s a valid JWT and would 
successfully complete the client authentication. Also note that the value of the original 
client_id created for the bar company is set as the subject of the JWT.
Still we have a challenge. How do we revoke a certificate that belongs to a given 
developer, in case he/she resigns or it is found that the certificate is misused? To facilitate 
this, the authorization server has to maintain a certificate revocation list (CRL) by the 
client_id. In other words, each client_id can maintain its own certificate revocation 
list. To revoke a certificate, the client (in this case, the bar company) has to talk to the 
CRL API hosted in the authorization server. The CRL API is a custom API that must 
be hosted at the OAuth authorization server to support this model. This API must be 
secured with OAuth 2.0 client credentials grant type. Once it receives a request to update 
the CRL, it will update the CRL corresponding to the client who invokes the API, and 
each time the client authentication happens, the authorization server must check the 
public certificate in the JWT against the CRL. If it finds a match, then the request should 
be turned down immediately. Also, at the time the CRL of a particular client is updated, 
all the access tokens and refresh tokens issued against a revoked public certificate must 
be revoked too. In case you worry about the overhead it takes to support a CRL, you 
probably can use short-lived certificates and forget about revocation.  Figure 12-4 shows 
the interactions between the foo and the bar companies.
Figure 12-4. JWT client authentication, a real-world example
Chapter 12  Federating aCCess to apis
274
 Parsing and Validating JWT
The OAuth authorization server must parse and validate the JWT, both in the JWT 
grant type and in the client authentication. The following lists out the criteria for token 
validation:
• 
The JWT must have the iss parameter in it. The iss parameter 
represents the issuer of the JWT. This is treated as a case-sensitive 
string value. Ideally, this represents the asserting party of the 
claims set. If Google issues the JWT, then the value of iss would be 
accounts.google.com. This is an indication to the receiving party 
who the issuer of the JWT is.
• 
The JWT must have the sub parameter in it. The token issuer or the 
asserting party issues the JWT for a particular entity, and the claims 
set embedded into the JWT normally represents this entity, which 
is identified by the sub parameter. The value of the sub parameter is 
a case-sensitive string value. For the JWT client authentication, the 
value of the sub parameter must carry the corresponding client_id, 
while for the authorization grant, it will be the authorized accessor or 
the resource server for which the access token is being requested.
• 
The JWT must have the aud parameter. The token issuer issues 
the JWT to an intended recipient or a list of recipients, which is 
represented by the aud parameter. The recipient or the recipient 
list should know how to parse the JWT and validate it. Prior to any 
validation check, the recipient of the token must first see whether 
the particular JWT is issued for its use and if not should reject 
immediately. The value of the aud parameter can be a case- sensitive 
string value or an array of strings. The token issuer should know, prior 
to issuing the token, who the intended recipient (or the recipients) of 
the token is, and the value of the aud parameter must be a pre-agreed 
value between the token issuer and the recipient. In practice, one can 
also use a regular expression to validate the audience of the token. 
For example, the value of the aud in the token can be ∗.apress.com,  
while each recipient under the apress.com domain can have its  
own aud values: foo.apress.com, bar.apress.com likewise.  
Chapter 12  Federating aCCess to apis
275
Instead of finding an exact match for the aud value, each recipient 
can just check whether the aud value in the token matches a regular 
expression: (?:[a-zA-Z0-9]∗|\∗).apress.com. This will make sure 
that any recipient can use a JWT, which is having any subdomain of 
apress.com.
• 
The JWT must have the exp parameter. Each JWT will carry an 
expiration time. The recipient of the JWT token must reject it, if that 
token has expired. The issuer can decide the value of the expiration 
time. The JWT specification does not recommend or provide any 
guidelines on how to decide the best token expiration time. It’s a 
responsibility of the other specifications, which use JWT internally, 
to provide such recommendations. The value of the exp parameter 
is calculated by adding the expiration time (from the token issued 
time) in seconds to the time elapsed from 1970-01-01T00:00:00Z UTC 
to the current time. If the token issuer’s clock is out of sync with the 
recipient’s clock (irrespective of their time zone), then the expiration 
time validation could fail. To fix that, each recipient can add a couple 
of minutes as the clock skew.
• 
The JWT may have the nbf parameter. In other words, this is not a 
must. The recipient of the token should reject it, if the value of the 
nbf parameter is greater than the current time. The JWT is not good 
enough to use prior to the value indicated in the nbf parameter. The 
value of the nbf parameter is calculated by adding the not before 
time (from the token issued time) in seconds to the time elapsed 
from 1970-01-01T00:00:00Z UTC to the current time.
• 
The JWT may have the iat parameter. The iat parameter in the JWT 
indicates the issued time of the JWT as calculated by the token issuer. 
The value of the iat parameter is the number of seconds elapsed 
from 1970-01-01T00:00:00Z UTC to the current time, when the token 
is issued.
• 
The JWT must be digitally signed or carry a Message Authentication 
Code (MAC) defined by its issuer.
Chapter 12  Federating aCCess to apis
276
 Summary
• 
Identity federation is about propagating user identities across 
boundaries. These boundaries can be between distinct enterprises 
or even distinct identity management systems within the same 
enterprise.
• 
Two OAuth 2.0 profiles—SAML 2.0 grant type and JWT grant type—
focus on building federation scenarios for API security.
• 
The SAML profile for OAuth 2.0, which is defined in the RFC 
7522, extends the capabilities of the OAuth 2.0 core specification. 
It introduces a new authorization grant type as well as a way of 
authenticating OAuth 2.0 clients, based on a SAML assertion.
• 
The JSON Web Token (JWT) profile for OAuth 2.0, which is defined 
in the RFC 7523, extends the capabilities of the OAuth 2.0 core 
specification. It introduces a new authorization grant type as well as a 
way of authenticating OAuth 2.0 clients, based on a JWT.
Chapter 12  Federating aCCess to apis
277
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4_13
CHAPTER 13
User-Managed Access
OAuth 2.0 introduced an authorization framework for access delegation. It lets Bob 
delegate read access to his Facebook wall to a third-party application, without sharing 
Facebook credentials. User-Managed Access (UMA, pronounced “OOH-mah”) extends 
this model to another level, where Bob can not only delegate access to a third-party 
application but also to Peter who uses the same third-party application.
UMA is an OAuth 2.0 profile. OAuth 2.0 decouples the resource server from the 
authorization server. UMA takes one step further: it lets you control a distributed set of 
resource servers from a centralized authorization server. Also the resource owner can 
define a set of policies at the authorization server, which can be evaluated at the time 
a client is granted access to a protected resource. This eliminates the need of having 
the presence of the resource owner to approve access requests from arbitrary clients or 
requesting parties. The authorization server can make the decision based on the policies 
defined by the resource owner.
The latest version of UMA, which we discuss in this chapter, is UMA 2.0. If you are 
interested in learning more about UMA evolution, please check Appendix D: UMA 
Evolution.
 Use Cases
Let’s say you have multiple bank accounts with Chase Bank, Bank of America, and Wells 
Fargo. You have hired a financial manager called Peter, who manages all your bank 
accounts through a personal financial management (PFM) application, which helps to 