overview of the universal composability framework.
2.1 Notation
Let k ∈ N denote the security parameter and a ∈ {0, 1}∗ denote an
input. Two binary distribution ensembles X = {X(k, a)}k ∈N,a∈{0,1}∗
and Y = {Y(k, a)}k ∈N,a∈{0,1}∗ are indistinguishable (X ≈ Y) if for
any c, d ∈ N there exists k0 ∈ N such that for all k > k0 and all
a ∈ ∪κ ≤kd {0, 1}κ, |Pr[X(k, a) = 1] − Pr[Y(k, a) = 1] | < k−c.
2.2 Bilinear Groups
Let 𝒢 be a bilinear group generator that takes as an input a security
parameter 1κ and outputs the descriptions of multiplicative groups
Λ = (q, G1, G2, Gt, e, д1, д2) where G1, G2, and Gt are groups of
prime order q, e is an efficient, non-degenerating bilinear map
e : G1×G2→Gt, and д1 and д2 are generators of the groups G1 and
G2, respectively. We denote Λ∗ = (q, G1, G2, Gt, e) as Λ without
group generators.
2.3 Zero-Knowledge Proofs
Feige, Fiat, and Shamir [24] were the first to formalize the proof of
knowledge, while the concept of zero-knowledge was introduced
by Goldwasser et al. [28]. When referring to the interactive proofs,
one usually uses the notation introduced by Camenisch and Stadler
[12] and formally defined by Camenisch, Kiayias, and Yung [9]. For
instance, PK{(a, b, c) : Y = дa1 Hb ∧ ˜Y = ˜д1a ˜Hc} denotes a “zero-
knowledge Proof of Knowledge of integers a, b, c such that Y = дa1 Hb
and ˜Y = ˜д1a ˜Hc holds,” where y, д, h, ˜Y , ˜д1, and ˜H are elements of
some groups G = ⟨д1⟩ = ⟨H⟩ and ˜G = ⟨ ˜д1⟩ = ⟨ ˜H⟩. The convention
is that the letters in the parenthesis (a, b, c) denote quantities of
which knowledge is being proven, while all other values are known
to the verifier. SPK{. . .}(m) denotes a signature proof of knowledge
on m, which is a non-interactive transformation of such proofs
using the Fiat-Shamir heuristic [25].
We can create similar proofs proving knowledge of group ele-
ments instead of exponents, e.g. SPK{a ∈ G1 : y = e(a, b)} by using
e(·, b) instead of b(·): Take r
$← G1, t ← e(r , b), c ← H(. . .) ∈ Zq,
and s ← r · ac. Verification computes ˆt = e(s, b) · y−c and checks
that the Fiat-Shamir hash [25] equals c. With the same mechanism
we can prove knowledge of elements in G2.
We use NIZK{w : s(w)} to denote a generic non-interactive
zero-knowledge proof proving knowledge of witness w such that
statement s(w) is true. Sometimes we need a witness to be online
extractable by a simulator, which we denote by drawing a box
around the witness: NIZK{ w : s(w)}.
2.4 Signature Schemes
A digital signature scheme Sig is a set of PPT algorithms Sig =
(Setup, Gen, Sign, Verify):
Sig.Setup(1κ) $→ sp : The setup algorithm takes as input a security
parameter and outputs public system parameters that also
specify a message space ℳ.
Sig.Gen(sp)
Sig.Sign(sk, m)
$→ (sk, vk) : The key generation algorithm takes as
input system parameters and outputs a verification key vk
and a corresponding secret key sk.
$→ σ : The signing algorithm takes as input a
private key sk and a message m ∈ ℳ and outputs a signature
σ.
Sig.Verify(vk, m, σ) → 1/0 : The verification algorithm takes as in-
put a public verification key vk, a message m and a signature
σ and outputs 1 for acceptance or 0 for rejection according
to the input.
Our generic construction is built from the structure-preserving
[1] signature schemes. A signature scheme Sig over a bilinear
Session C5:  Using BlockchainsCCS’17, October 30-November 3, 2017, Dallas, TX, USA685group Λ generated by 𝒢(1κ), that outputs system parameters Λ =
(q, G1, G2, Gt, e, д1, д2), is said to be structure preserving if:
(1) the verification key vk consists of the group parameters and
group elements in G1 and G2;
(2) the messages and the signatures consist of group elements in
G1 and G2, and
(3) the verification algorithm evaluates membership G1 and G2
and pairing product equations of the form


e(дi , hj)ai j = 1Gt ,
i
j
where a11, a12, . . . ∈ Zq are constants, д1, h1, . . . ∈ {G1, G2}∗
are group elements appearing in the group parameters, veri-
fication key, messages, and signatures.
2.4.1
Structure-Preserving Signature scheme by Groth (Asiacrypt
2015). We recall the structure-preserving signature scheme by Groth
[29], which we use in our instantiation and refer to as Groth. We
note that the original scheme supports signing blocks of messages
in a form of “matrix”, whereas we provide a simplified description
for “vectors” of messages only, since we use this version of the
signature scheme in our construction. Let a message be a vector
of group elements of length n: (cid:174)m = (m1, . . . , mn). We denote as
Groth1 signs messages in G1 with a public key in G2, while Groth2
signs messages in G2 with a public key in G1. We describe the
Groth2 scheme below. Groth1 follows immediately.
Groth2.Setup: Let Λ∗ = (q, G1, G2, Gt, e) and yi
$← Zq and set V
$← G2 for i =
$← дv1 . Output
Groth2.Gen(sp): Choose random v
Groth2.Sign(sk; (cid:174)m): To sign message (cid:174)m ∈ Gn2 choose a random
1, . . . , n. Output parameters sp = (Λ∗, {yi}i =1, ...,n).
public verification key vk = V and secret key sk = v.
r
q and set
$← Z∗
R ← дr1
· mi) 1
r .
Groth2.Verify(vk, σ , (cid:174)m) On input message (cid:174)m ∈ Gn2 and signature
r
i
S ← (y1 · дv2 ) 1
Ti ← (yv
Output signature σ = (R, S,T1, . . . ,Tn).
σ = (R, S,T1, . . . ,Tn) ∈ G1 × Gn+1
e(R, S) = e(д1, y1)e(V , д2) ∧ n
, output 1 iff
2
e(R,Ti) = e(V , yi)e(д1, mi)
Groth2.Rand(σ) To randomize signature σ = (R, S,T1, . . . ,Tn),
i =1
pick r′
$← Zq and set
′ ← Rr′
′ ← S
1
r′
R
.
Output randomized signature σ ′ = (R′, S′,T ′
T
S
i
′
i ← T
1
r′
1, . . . ,T ′
n).
2.5 Sibling Signatures
We introduce a new type of signatures that we call sibling signatures.
It allows a signer with one key pair to use two different signing
algorithms, each with a dedicated verification algorithm. In our
generic construction, this will allow a user to hold a single key pair
that it can use for both presentation and delegation of a credential.
A sibling signature scheme consists of algorithms Setup, Gen,
Sign1, Sign2, Verify1, Verify2.
Sib.Setup(1κ) $→ sp : The setup algorithm takes as input a security
parameter and outputs public system parameters that also
specify two message spaces ℳ1 and ℳ2.
Sib.Gen(sp)
$→ (sk, vk) : The key generation algorithm takes as
input system parameters and outputs a verification key vk
and a corresponding secret key sk.
Sib.Sign1(sk, m) $→ σ : The signing algorithm takes as input a pri-
vate key sk and a message m ∈ ℳ1 and outputs a signature
σ.
Sib.Sign2(sk, m) $→ σ : The signing algorithm takes as input a pri-
vate key sk and a message m ∈ ℳ2 and outputs a signature
σ.
Sib.Verify1(vk, m, σ) → 1/0 : The verification algorithm takes
as input a public verification key vk, a message m and a
signature σ and outputs 1 for acceptance or 0 for rejection
according to the input.
Sib.Verify2(vk, m, σ) → 1/0 : The verification algorithm takes
as input a public verification key vk, a message m and a
signature σ and outputs 1 for acceptance or 0 for rejection
according to the input.
We require sibling signatures to be complete and unforgeable.
Definition 2.1 (Completeness). A sibling signature scheme is com-
Pr(cid:2)Sib.Verifyb(vk, m, σ) = 1|sp
plete if for b ∈ {0, 1} and for all m ∈ ℳb we have
$← Sib.Setup(1κ),
$← Sib.Signb(sk, m)(cid:3) = 1.
(sk, vk) $← Sib.Gen(sp), σ
Definition 2.2 (Unforgeability). No adversary with oracle access
to Sign1 and Sign2 can create a signature that correctly verifies
with Verifyb, if no Signb query was made for message m. For every
such b ∈ {1, 2} we call it unforgeability-b. More precisely, a sibling
signature scheme is unforgeable-b if the probability
Pr(cid:2)Sib.Verifyb(vk, m, σ) = 1 ∧ m (cid:60) QSignb|
sp
$← Sib.Setup(1κ),(sk, vk) $← Sib.Gen(sp),
(σ , m) $← 𝒜𝒪Sib.Sign1(sk,·),𝒪Sib.Sign2(sk,·)(sp, vk)(cid:3)
is negligible in κ for every PPT adversary 𝒜 and b ∈ {1, 2}, where
oracle 𝒪Sib.Signb(sk,·) on input m stores m in QSignb
and returns
Sib.Signb(sk, m). A sibling signature scheme is unforgeable if it is
both unforgeable-1 and unforgeable-2.
2.5.1 Constructing Sibling Signatures. Note that one can trivially
construct a sibling signature scheme from two standard signature
schemes by setting the verification key vk as (vk1, vk2) and the
signing key as sk = (sk1, sk2), and simply using one signature
scheme as Sign1 and Verify1 and the other as Sign2 and Verify2.
However, this generalization also allows for instantiations that
securely share key material between the two algorithms.
We now show that one can combine Groth1 signatures with
Schnorr-signatures to form a sibling signature scheme we call
SibGS1. SibGS1 uses only a single key pair. It uses the Setup and
Gen algorithms of Groth1. Algorithm Sign1 is instantiated with
Groth1.Sign, and Sign2 creates a Schnorr signature. Let SibGS2
denote the analogously defined Groth-Schnorr sibling signature
where we use Groth2 instead of Groth1.
Session C5:  Using BlockchainsCCS’17, October 30-November 3, 2017, Dallas, TX, USA686Lemma 2.3. SibGSb is a secure sibling signature scheme in the
random oracle and generic group model.
Proof. Completeness of SibGSb directly follows from the com-
pleteness of Grothb and Schnorr signatures. We can reduce the
unforgeability-1 and unforgeability-2 of SibGSb to the unforgeabil-
ity of Grothb, which is proven to be unforgeable in the generic
group model. The reduction algorithm ℬ receives the Grothb verifi-
cation key vk from the challenger and has access to signing oracle
𝒪Grothb.Sign(sk,·) that creates signatures valid under vk. ℬ simulates
the random oracle honestly and must answer 𝒜’s signing queries
by simulating oracles 𝒪Sib.Sign1(sk,·) and 𝒪Sib.Sign2(sk,·). When 𝒜
queries 𝒪Sib.Sign1(sk,·) on m, ℬ queries σ ← 𝒪Grothb.Sign(sk,m) and
returns σ. When 𝒜 queries 𝒪Sib.Sign2(sk,·) on m, ℬ simulates a
Schnorr signature without knowledge of sk by programming the
random oracle.
Finally, 𝒜 outputs a forgery. Let us first consider the unforge-
ability-1 game, meaning that 𝒜 outputs forgery σ∗ on message m∗,
such that σ∗ is a valid Grothb signature on m∗ and 𝒪Sib.Sign1(sk,·)
was not queried on m∗. This means that ℬ did not query
𝒪Grothb.Sign(sk,·) on m∗, soℬ can break the unforgeability of Grothb
by submitting forgery (σ∗, m∗).
Next, consider the unforgeability-2 game. Forgery σ∗ is a Schnorr
signature on m∗ and 𝒜 did not query 𝒪Sib.Sign1(sk,·) on m∗. This
means that the Schnorr signature is not a simulated signature and
we use the forking lemma [4] to extract sk. Now, ℬ picks a new
message ˆm∗ for which it did not query 𝒪Grothb.Sign(sk,·), and uses
sk to create signature ˆσ∗ on ˆm∗. It submits (ˆσ∗, ˆm∗) as its forgery
to win the Grothb unforgeability game.
(cid:3)
2.6 Universal Composability
We define the security of delegatable credentials as an ideal function-
ality in the Universal Composability (UC) framework [14], which
follows the simulation-based security paradigm [8, 14, 30, 31, 33].
In UC, an environment ℰ gives input to the protocol participants
and receives their outputs. In the real world, honest parties execute
the protocol over a network controlled by an adversary 𝒜, who also
controls the corrupt parties while communicating freely with envi-
ronment ℰ. In the ideal world, honest parties are “dummy parties”
who forward their inputs to the ideal functionality ℱ. The ideal
functionality internally performs the desired task and generates
outputs for honest parties.
Informally, a protocol Π securely realizes an ideal functionality ℱ
if the real world is as secure as the ideal world. For every adversary
𝒜 attacking the real world, there exists a simulator 𝒮 that performs
an equivalent attack on the ideal world. As ℱ performs the task at
hand in an ideal fashion (ℱ is secure by construction) there are no
meaningful attacks on the ideal world, it follows that there are no
meaningful attacks on the real world. More precisely, Π securely
realizes ℱ if for every PPT adversary 𝒜 there exists a PPT simulator
𝒮 such that no PPT environment ℰ can distinguish the real world
(with Π and 𝒜) from the ideal world (with ℱ and 𝒮).
The UC framework comes with a composability theorem, which
gives composability guarantees for protocols proven secure in this
framework. Specifically, it proves that security is preserved while
running many instances of the same protocol in paralel, and when
using the protocol as a building block for more advanced protocols.
We consider only static corruptions in this paper.
We now formally define the ideal functionalities that we use in
our protocol.
Ideal Functionality ℱcrs. For the CRS functionality we use the
2005 version of UC [13]. Functionality ℱcrs is parametrized by a
distribution 𝒟, from which the CRS is sampled.
Functionality ℱcrs
(1) When receiving input (CRS, sid) from party 𝒫, first verify
that sid = ({𝒫}, sid′) where {𝒫} is a set of identities, and
that 𝒫 ∈ {𝒫}; else ignore the input. Next, if there is no
$← 𝒟. Finally,
value r recorded then choose and record r
send a public delayed output (CRS, sid, r) to 𝒫.
Ideal Functionality ℱca. We use the ideal certification authority