表2.7：内建字符串函数
函数
描述
gsub(r,s)
将S0中所有出现的r替换为s，返回替换发生的次数
gsub(r,s,t)
将字符串中所有出现的r替换为8，返回替换发生的次数
index(s,t)
返回字符串t在8中第一次出现的位置，如果t没有出现
的话，返因0.
length (s)
返回g包含的字符个数
match(s,)
测试8是否包含能被r匹配的子串，返因子串的起始位置
或0;设置RSTART与RLENGTH
split(8,α)
用FS将8分割到数组α中，返因字段的个数
split(s,α,fs)
用fs分割g到数组a中，返因字段的个数
sprint f (fmt ,expr-list)
根据格式字符串fmt返回格式化后的expr-list
sub (r,8)
将$0的最左最长的，能被r匹配的子字符串替换为8，返
因替换发生的次数
sub (r,s,t)
把的最左最长的，能被r匹配的子字符串替换为8，返回
替换发生的次数
substr (s,p)
返回s中从位置p开始的后照
substr (s,p,n)
返回s中从位置p开始的，长度为n的子字符串，
自从Unix文件编辑器ed的替换命令出现之后，sub与gsub 就已经被模式化了.sub(r,8,t）首
先在目标字符串t中我到能被r匹配的最左最长子串，再将这个子串替换为8.在ed中，“最左最长”意
味着先找到最左边的匹配，然后尽可能的延长匹配的长度，
如果目标字符串是banana,邢么anan 就是正则表达式（an）+的最左最长匹配，相反，（an）*的
最左最长匹配是b左边的空字符串.
sub 返回替换发生的次数.sub(r,s）等价于gsub(r,8,$0）.
gsub是类似的，但是它会连续地替换最左最长且不重叠的子串，而不是只替换子串的第一次出现；
函数返回值仍然是替换发生的次数（gsub的g是“global”的缩写，表示替换是全局的）.例如，程序
43
{gsub(/usA/, “United States"); print }
将输入行中的每一个“USA”替换为“United States”（在这祥的例子里，当$0发生改变时，字段与NF
也会跟老发生改变）程序
gsub(/ana/, "anda", "banana")
将banana 变为bandana，匹配是不重叠的
对一个由sub或gsub执行的替换来说，字符&在g中任意一次出现都会被替换为被r匹配的子
串，于是
gsub(/a/, "aba", “banana")
“在 mawk-1.3.3中,Bab 与 gsub 的第 3个参数函频是变量，—译者
---
## Page 47
第二章AWK语言
68
将banana变为babanabanaba;网样的效果也可用
gsub(/a/, "&b&", "banana")
来完成.在&的左边加上一个反斜杠就可以关闭它在替换字符串中的特殊意义。
substr（8,p）返回s从位置p开始的后缀，如果使用了substr(8,P),邪么只会返回后缀的前n
个字符；如果后缀的长度小于n，那么就会返回整个后缀，例如，我们可以将国家名缩写为名字的前三个
宇母，程序
{ $1 = substr($1, 1, 3); print $0 }
输出
USS 8649 275 Asia
Can 3852 25 North America
Chi 3705 1032 Asia
USA 3615 237 North America
Bra 3286 134 South America
Ind 1267 746 Asia
Mex 762 78 North America
Fra 211 55 Europe
Jap 144 120 Asia
Ger 96 61 Europe
Eng 94 56 Europe
修改S1使得awk重新计算$0，于是字段之间的分隔符就变成了空格（OFS的默认值），而不是制表符，
只要将字符串陆续写出来就可以将它们拼接在一起.例如，对于countries，程序
{s = s substr($1, 1, 3) " "}
END ( print s)
打印
44
USS Can Chi USA Bra Ind Mex Fra Jap Ger Eng
程序每一次只为s构造一小段.（如果你很在意s的末尾的空格，在END中使用
print substr(s, 1, length(s)-1)
替换print s)
数值还是字符串（NumberorString）.表达式的值可以自动从数值转换为字符串，或反之，具体取
决于该值将用于什么运算，算术表达式，例如
pop + $3
这个表达式要求pop与S3都必须是数值，如果它们原来不是数值的话，就会被强制转换成数值，类似
的，赋值语句
pop += $3
---
## Page 48
第二章AWK语言
40
也要求pop与$3是数值.字符串表达式，就像
$1$2
要求S1与S2必须是字符事才能进行拼接，所以如果必要的话，它们就会被强制转换成字符串
同样的运算符有时既可以用在数值上，也可以用在字符串，对于这种情况有一些特殊的规则，在赋值
语句u=e中，赋值语句本身与变量u都会对表达式e的类型有所要求，比较表达式，就像
 == X
如果两个操作数都是数值，那么比较就按照数值进行；否则，数值类型的操作数被强制转换成字符串，然
后再按字符串的方式进行比较.
现在让我们来查看一下这条规则具体应用时会产生什么影响，语句
$1 == $2
涉及到字段，在这个语句里，比较的类型取决于这两个字段是否包含数值或字符串，而这只有到程序运行
时才可以知道；对于不同的行，比较的类型可能是不一样的，当awk在运行状态下创建一个字段时，会自
动将它的类型设置为字符事；另外，如果字段包含一个机器可识别的数，它也会给这个字段设置一个数值
类型。
例如，比较S1==S2将会按照数值进行，并且比较结果为真，如果$1与$2的值是下面任意一种
的话，
11.0+1
1e0
0.1e+110E-1001
45
这些值都是数值1的不同表示方法，然而，这个表达式也可以是字符串比较，于是，该表达式对下面每对
值都会比较失数：
0
(null)
0.0
(null)
0
0a
le500
1 . 0e50 0
在前三对值中，第二个字段都不是一个有效的数值，最后一对值也会按照字符串来比较，这是因为如果将
它们转换成数值的话，其值大得无法在机器上表示，
输出语句
print $1
打印第1个字段的字符串值；于是，输出与输入是一样的，
未初始化的变量默认初始值为数值0或空字符串“"，不存在的，或显式为空的字段具有字符串值
""，它们不是数值，但是当强制转换为数值时，将会是0.我们将在本节的末尾看到，数组的下标是字符
串.
有两种惯用语法可以将表达式从一种类型转换成另一种类型：
number""将空字符串拼接到number可以将它强制转换成字符串；
string+0给字符串加上零可以把它强制转换成数值.
---
## Page 49
第二章AWK语言
41
于是，为了强制让两个字段之间的比较按照字符事来进行，我们可以把其中一个字段强制转换成字符串：
$1"" ==$2
为了让比较强制按照数值类型来进行，我们需要将两个字段都转换成数值：
$1 + 0 == $2 + 0
无论字段包含什么内容，这个方式总能奏效，
字符事的数值类型的值，等于字符事中最长的看起来像数值的前组的值，于是
输出
1001201
数值的字符串形式需要根据OFMT转换后才会输出，为了拼接，比较，与创建数组下标而需要把数值
转换成字符串时，OFMT也会影响转换的过程，OEMT的默认值是“名.6g".于是
BEGIN { print 1E2 "", 12E-2 "", E12 "", 1.23456789 "" }
输出
100 0.12 1.23457
46
向OFMT赋予新值就可以修改它的默认值，比如将OFMT改为"等.2f"，那么在打印数值，以及通过强制
转换而得到的数值之间进行比较时，小数点后将会保留两位小数，
运算将的总结（SummaryofOperators).可以出现在表达式中的运算符全部列在了表2.8中.将这
些运算符应用到常量，变量，字段，数组元素，函数，和其他表达式中，就可以构造出一个表达式。
运算符按照优先级的升序排列.优先级高的运算符优先求值；举例来说，乘法运算在加法运算之前
求值，所有的运算符都是左结合的，除了赋值运算符，条件运算符，指数运算，它们都是右结合的，左结
合性意味看相网优先级的运算符按照从左到右的顺序进行运算；于是3-2-1是指（3-2)-1，而不是
3  (21).
因为没有显式的拼接运算符，所以比较明智的做法是，在拼接运算中，将涉及到其他运算的表达式47
用括号括起来，考虑下面这个程序
{$-=（$）sqe。uxd）0>$
跟在print后面的表达式看起来像是拼接，实际上是一个减法运算，程序
(（s-）=（s）sqe。uxd）0>$
与
{$-=（s）sqeuxd）0>I$
都可以得到我们期望中的效果，
---
## Page 50
第二章AWK语言
42
表2.8:表达式运算符
操作
运算符
例子
例子的含义
赋值
★= /= =
X *= 2
X=x*2
条件表达式
x ? y : 2
若x为真，则y，否则z
逻辑或
1
x 1l y
若x或y为真，则为1,否则为0
逻辑与
&&
X && y
若x与y都为真，别为1,否则为0
数组成员
in
i in a
如果a[i]存在，则为1,否则为0
匹配
$1 -/x/
如果第一个字段包含x，则为1,否则为0
关系运算
X == y
如果x等于y，则为1，否则为0
拼接
"a"
"bc "
"abc"；不存在显式的拼接运算符
减法，加法
+x
x与y的和
乘法，除法，取模
x除以y的余数
单目加，单目减
-X
x的相反数
逻辑非
1$1
若$1为空或为0,则为1,否则为0
指数运算
xy
xY
自增，自减
++
++x, x++
为x加1
宇段
S
$i+1
1加上第i个字段的值
组合
（）
($i)++
给第i个字段的值加1
流程控制语句
Awk提供花括号用于语句组合，if-else用于决策，while，for,do语句用于循环，所有这些都来
源于C语言
一条单独的语句总是可以被替换为一个被花括号包围起来的语句列表，列表中的语句用换行符或分
号分开，换行符可以出现在任何左花括号之后，也可以出现在任何右花括号之前.
if-else其有形式：
if (expression)
statements
else
statements2
elsestatement8是可选的.右括号，statements，和关键词else后面的换行符是可选的.如果else
与statements，出现在网一行，并且statements是一条单独的语句，那么在statements的末尾必须使
用分号来终止语句.
在一个if-else 语句中，文本expression 先被求值，如果expression 为真（也就是非空或非零)，那
么statements;就会执行，如果expression为假（也就是空或零)，如果elsestatements2存在，那它就
会执行.
为了避免歧义，我们规定，else与最近一个未匹配的if匹配，举例来说，语句
if (e1) if (e2) s=1; else s=2
---
## Page 51
第二章AWK语言
43
中的else与第2个if匹配.（s=1后面的分号是必须的，因为else与s=1出现在同一行)
当条件为真时，while就会重复执行一条语句：
流程控制语句
1.{statements)
语句组
2. if (expression)statements
如果expression 为真，执行statements
3. if (expression) statements else statements2
如果expression 为真，执行statements，否别执行 statement82
4. while (expression) statements
如果expression 为真，执行statements;然后重复前面的过程
5.for (expression;expressionexpression) statements
等价于 expression; while(expression2）{ statements; expressions)
6. for (variable in array) statements
轮流地将uariable设置为array 的每一个下标，并执行statements
7. do statements while (expression)
执行statements;如果expression 为真就重复
8. break
马上离丹最内层的，包围break的 while,for或do
9.continue开始最内层的，包图continue 的 while，for，或do的下一次循环
10. next
开始输入主循环的下一次选代
11. exit
12. exit expression
马上执行END 动作；如果已经在END动作内，那就退出程序.将expression 作为程序的退出
状态返因，
48
while (expression)
statements
右括号后面的换行符是可选的，在这个循环语句里，expression被求值；如果它的值为真，statements就
会执行，然后expression再被求值，只要expression为真，循环就会一直持续下去，举例来说，下面这个
程序打印所有的输入字段，每行一个：
---
## Page 52
第二章AWK语言
44
i = 1
while (i <= NF){