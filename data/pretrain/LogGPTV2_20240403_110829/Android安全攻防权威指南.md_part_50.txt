分析漏洞的可利用性很大程度上取决于分析人员的经验和知识。为了作出正确的判断，分析
人员必须掌握最新的利用技术。他们必须熟悉目标平台上所有的利用缓解技术。即便是经验和知
识丰富的分析人员，在判断漏洞可利用性问题上依然会面临挑战。
证明一个漏洞是否可利用有时候很容易，但是很多时候是不可能的。例如，对于前面分析的
漏洞，程序的PC寄存器会被不确定的值污染。这个漏洞第一眼看起来很危险，但是在缓冲区被
释放后和重用前控制它的截率很低。如何利用此类漏润会在第8章中进行介绍。
7
7.10小结
在本章中，我们学习了Android平台上的调试和漏洞分析技术。本章包含了大量Dalvik和原
生代码的调试技术，包括如何使用常见的调试工具，如何利用自动化来提高效率，如何使用AOSP
支持的设备来进行源代码级别的调试，以及如何通过直接在真机上调试来提高性能。我们解释了
为什么符号在ARM平台上更加重要，说明了在非AOSP设备上调试所面临的困难，并提供了解
决这些问题的应对方案。
本章的最后讨论了漏洞分析的两个主要目标：分析漏洞产生的根源和判断漏洞的可利用性。
为读者介绍了一些漏润分析的常见工具和技术，以便深人理解漏洞。还带领读者分析了Android
浏览器中一个漏洞的成因，教会读者在判断漏洞可利用性方面应该怎样进行考量。
下一章考察Android系统用户空间中的漏润利用技术，涵盖了关键代码的构造，与利用代码
相关的操作系统特性，以及一些漏涧。
---
## Page 222
第8章
用户态软件的漏洞利用
本章主要介绍Android系统用户态软件中内存破坏漏洞的利用方法。我们会在ARM架构上
讨论常见的漏润类型，例如栈溢出。本章首先解释开发漏涧利用代码（exploit）中的相关实现细
节；然后以一些曾经公开的exploit为例，帮助理解前面介绍的概念；最后以WebKit浏览器引
中一个可远程利用的漏洞为例，介绍高级堆利用技术。
8.1内存破坏漏洞基础
要理解内存破坏漏洞的利用技术，最关键的是抽象。很重要的一点是，应当避免用C语言这
种高级语言的方式来思考问题。作为攻击者，只需要把目标机器的内存当作有限数量的内存单元，
由目标程序的语义进行操作。内存单元包括某些指令类型或者函数暗含的内存区域，例如栈和堆。
接下来的儿节会讨论内存最坏漏润的典型案例，以及它们在Android平台上是如何被利用的。
这些漏洞利用方法都有一个共同特点：攻击者利用目标代码破坏某些内存区域，使得目标程序转
人攻击者预期的状态。有的攻击方式比较直接，例如将原生代码的执行流转入攻击者所控制的内
存：有的则比较隐秘，攻击者可以让程序语义发生一些攻击者所设定的非预期变化（通常称之为
邪恶机器编程）
用户空间中堆和栈上的利用技术有非常多的细节，也有很多高级方法。需要采用的技术取决
于漏洞本身，本章无法一一介绍。网上有不计其数的资源介绍与具体架构相关的细节，本章仅专
注于介绍ARM设备的Android系统中最常见的漏洞利用相关概念。
8.1.1栈缓冲区溢出
就像其他体系架构中的应用程序二进制接口（ABI）一样，ARM嵌人式ABI（EABI）大量
使用了（特定于线程的）栈。下列是ARM使用的ABI规则：
口函数的参数如果超过4个，超过的部分会使用栈来传递；
口局部变量如果不能存储在寄存器中，则在当前栈赖中分配。特别是大于32比特的变量和
指针引用的变量；
非叶节点函数（Non-leafFunction）的返回地址存储在栈上，更多关于函数返回地址的细
节将在第9章中介绍。
---
## Page 223
8.1内存破坏漏洞基础207
如果一个函数中用到了栈，那么它通常会以prologue代码开始，以epilogue代码结束。prologue
代码用来初始栈帧，cpilogue代码则用来还原栈帧。prologue代码把函数执行过程中会遭到破坏
的寄存器值保存在栈上；函数返回时，epilogue代码就会恢复相应的寄存器值。prologue代码也
会通过调整栈指针来为栈上的局部变量分配空间。栈空间从虚拟内存高地址往低地址方向增长，
所以栈指针指向的地址会在prologue代码中变低，在epilogue代码中变高。嵌套的函数调用会产
生如图8-1所示的栈顿结构。
p
局邮变量
低地址
保存的栈械指针m
保存的程序计数器n
local variables1
saved frame pointerl
栈的开始位置一
saved program counter 1
高地址
图8-1多栈顿示例
注意，尽管在Thumb模式下有一些处理栈指针寄存器的特殊指令（push和pop），栈的本
质概念只是不同函数之间的ABI约定。栈指针寄存器也可以被用作其他目的。因此，在攻击者
看来，栈上分配的局部变量与其他内存并无本质区别。
如果漏洞与栈上的局部变量有关，就十分有关注的价值，因为其附近有与控制相关的数据：
已保存的函数返回地址。如图8-1所示，所有的局部变量都挨得很近，没有交错的控制数据。事
实上，这样的栈赖布局信息被隐式地编码在了编译器生成的原生代码中。
利用局部变量越界的漏洞，攻击者可以很容易地向其他局部变量或者控制数据写人想要的数
据。Alephl是第一位公开发表相关文章的人，这篇有较大影响的文章名为“Smashingthe Stackfor
Fun and Profit" ( Phrack 第 49 期,文章 14, htp:/phrack.org/issues/49/14.htmlarticle )。 由于临时字符
串或数组经常被分配在栈上，所以这是一种很常见的漏洞类型。下面这段代码是一个简单的例子。
·栈溢出代码科例
void getname()(
struet (
}info:
int age
info.age = 23;
---
## Page 224
208
第8章用户态软件的漏洞利用
gets(info.name) ;
info.age):
众所周知，gets函数不会进行边界检查。如果往标准输人stdin中输人超过32个字符，
程序行为就会出现异常。使用GCC 4.7.1加上选项-mthumb-mcpu=cortex-a9-02，生成的汇
编代码如下：
●栈溢出代码样例反汇编
0000000o 1
0: f240 0000 movw
r0, #0
在栈上保存返回地址
4:b500
6: 2317
push (1r)
movs
r3, #23
在栈上为局部变量预留空间
8:b08b
sub sp. #44
8.1
f2c0* 0000 :
novt r0, #0
！初始化变量age为围定值23，之前已经将r3赋为23
10: f7ff fffe b1 0 
e：
10E6
str r3.[sp, #36]
计算缓冲区地址，作为gets函数的第一个参数
14:
a802
add
16: f7ff fffe b1 0 
r0.sp.#4
1a: f240 0000
movw r0, #0
↓载入局部变量age，用于打印
1e: 9a01 1dr r2, [8p, 36]
---
## Page 225
8.1内存破坏漏润基础
209
↓再次计算缓冲区地址，用于打印
20:a902
add r1, sp. #4
26: f7ff fffe bl 0 
22: f2c0
0000
movt r0, #0
2a: b00b
add sp, 44
从栈上载入返回地址并返回
2e: bd00
pop (pc)
正如前面所说，函数代码定义了栈帧布局，或者说是定义了相对SP寄存器的偏移。栈布局
如图8-2所示。
name[32]
sp+36
age
保存的程序计数器
图8-2栈帧布局样例
当攻击者输入超过32字节的数据时，33到36字节会覆盖age这个局部变量，37到40字节
会覆盖栈上保存的返回地址。所以攻击者可以把程序执行流重定向到任意地址上，或者修改一个
原本不能修改的局部变量。
由于这种漏洞类型频繁出现.GNUC编译器实现了一种缓解措施，自从Android第一个版本
发布就默认开启了，具体请参考12.7节。即便有了栈cookie这个缓解措施，依然可以使用一些
与漏洞有关的技术来对程序发起攻击，例如马上介绍的zergRush漏洞利用案例中使用的技巧。
尽管存在缓解措施，本章中标准的栈缓冲区溢出依然是一个用来介绍内存破坏漏洞的好例子。
8.1.2堆的漏洞利用
生存域超过一个函数范围的非局部对象必须分配在堆上。堆上的数组和字符串与栈上的情况
相同，也会面临越界的问题。除了数据本身，堆上分配的每一个对象内还有控制元数据。与栈上
---
## Page 226
210第8章用户态软件的漏洞利用
的局部变量不同，堆分配变量的生命周期并非由编译器自动管理。这两个原因使堆上的漏洞变得
容易利用，攻击者可以利用的漏洞也就更多了。
1.释放后重用问题
释放后重用问题是指，应用程序使用指针访问了一个已经通过free函数或delete 操作符
释放过的对象。在复杂的软件中，这是一个很常见的bug，并且很难通过人工源代码审计发现。
因为delete操作符内部也依赖于free 函数释放内存，所以对delete和 free不作区分。
大部分堆分配器在释放一块分配过的内存时不会修改其内容，原先使用时的内存数据会保持
不变。很多分配器会在释放内存块最开始的地方存储一些控制信息，但是大多数内存块内的数据
依然保持原样。释放后的内存被使用时，会产生不同的情况。
口被释放的内存还没有被用作新的内存分配释放后的内存被使用时，它们的内容与释放前
的相同。在这种情况下，bug可能不会表现出来。但是有些时候，析构器可能会让对象的
内容失效，访问时就可能会造成程序前溃。除此之外，这种情况还可能会导致信息泄露，
攻击者可以因此获得敏感内存数据。
口被释放的内存已经被全部或部分用作新的内存分配在这种情况下，两个语义上完全不同
的指针指向同一内存地址，如果两种语义下的代码互相冲突，就会导致程序崩溃。例如，
一个函数可能会在分配的内存中写人数据，面这些数据在另一个函数中则被用作内存地
址。如图8-3所示。
class A[
int example_2;
int example_1;
example_1example_2
E"alduexa
class B[
[a]eadwexa e
图8-3堆上的释放后重用示意
如果没有被其他的内存分配使用，被释放的内存块就没有多大用处了（除非可以让程序再一
次释放这块内存）。如果能通过精心构造应用的输入来产生大小相同的内存块分配，释放点就可
以正好被新的分配所用。不过这种方法与特定的堆分配器实现相关。
2.自定义分配器
大多数开发者都认为堆分配器是操作系统的一部分，但事实并非如此。操作系统只提供了页
分配（大小通常是4KB）的机制，堆分配器负责将页划分成想要分配的大小。大多数人使用的是
C运行时库（libe）中的堆分配器，应用程序完全可以使用基于操作系统页分配机制的其他分配
器。事实上，大部分桌面浏览器出于性能的考虑而采取了该做法。