(b) # of key copies in memory
Figure 3. OpenSSH case
Figure 3(a) shows the locations of copies of the private
key in memory, where “×” represents a copy in allocated
user or kernel space, and “+” represents a copy in unal-
located memory. From this picture we draw the following
observations. (1) The OpenSSH private key is in memory at
time t=0, even though the OpenSSH server is not started un-
til time t=2. This is because the PEM-encoded ﬁle has been
loaded into memory by the Reiser ﬁle system. (2) When the
OpenSSH server is started at time t=2, the newly appearing
×’s are actually the d, P , and Q of the private key. (3) When
OpenSSH client requests begin to be issued at time t=6, the
number of copies of the private key increases abruptly. We
also begin to see copies of the private key in unallocated
memory. (4) When the client machines stop issuing requests
at time t=18, the number of copies of the private key in al-
located memory drops abruptly. We also observe that many
copies of the private key are not erased before entering un-
allocated memory. (5) When the OpenSSH server stops at
time t=22, d, P and Q exist only in unallocated memory,
except the PEM-encoded private key ﬁle that remains in the
Linux kernel’s page cache.
Figure 3(b) shows the total number of copies of the pri-
vate key in memory, where lightly shaded bars correspond
to copies of the private key in allocated memory, and dark
shaded bars correspond to copies of the private key in unal-
located memory.
Summary. In both OpenSSH and Apache HTTP servers
(details of the Apache case is deferred to [13]), many copies
of the private key can be found in both allocated memory
and unallocated memory. This conﬁrms our suspicion that
copies of cryptographic keys somewhat ﬂooded in mem-
ory when the number of SSH / HTTP connections increases
– even in newer operating systems, and explains why the
afore-experimented attacks were so powerful.
4 Countering Memory Disclosure Attacks
Analyses in the last section naturally suggest the follow-
ing countermeasures: We should ensure (i) a cryptographic
key only appears in allocated memory a minimal number
of times (e.g., one) as long as this does not downgrade sys-
tem performance, and (ii) unallocated memory (or any other
place with a disclosure potential such as swap space) does
not have a copy of a cryptographic key. For this purpose,
now we present a set of solutions at different layers, from
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:07 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007application down to operating system kernel.
Application level solution: First, utilize the “copy on
write” memory management policy [17] to avoid unneces-
sary duplications of cryptographic keys. Speciﬁcally, we
propose placing the private key into a special memory re-
gion, and guaranteeing that no process will write to that
memory region. This ensures that the private key will only
exist once in physical memory (in addition to the PEM-
encoded private key ﬁle), no matter how many processes
are forked. Second, avoid appearances of cryptographic
keys as follows: (1) Ensure the private key is not explic-
itly copied by the application or any involved libraries. (2)
Disable swapping of the memory that contains the key using
the appropriate system calls. This is because when memory
is swapped to disk, the memory is not immediately cleared
and the private key may appear in unallocated memory.
Library level solution: We suggest eliminating unneces-
sary duplications of cryptographic keys in allocated mem-
ory using the same measures suggested in application level
solution. This sufﬁces to prevent private keys from appear-
ing in memory other than the afore-mentioned special re-
gion and the PEM-encoded private key ﬁle.
Kernel level solution: We propose ensuring that the un-
allocated memory does not contain any private keys. This
can be fulﬁlled by having the kernel zero any physical pages
before they become unallocated.
Integrated library-kernel solution: We propose integrat-
ing the library and kernel level mechanisms together to ob-
tain strictly stronger protection. This way, unnecessary du-
plications of private keys in allocated memory and any ap-
pearances of private keys in unallocated memory are simul-
taneously eliminated. Moreover, this solution can even re-
move the PEM-encoded private key from allocated memory,
provided that the library instructs the kernel not to cache the
PEM-encoded private key ﬁle. Therefore, whenever possi-
ble, this solution should be adopted.
5 Protecting Keys of OpenSSH Servers
Implementing the application level solution. We in-
stantiate the above general solution with a function,
RSA memory align(), which should be called as soon
as OpenSSL’s RSA data structure contains the private key.
This ensures that exactly one copy of the private key ap-
pears in allocated memory, in addition to the PEM-encoded
ﬁle. Notice that we need to start OpenSSH with the undoc-
umented -r option to prevent the OpenSSH server from
re-executing itself after every incoming connection.
Speciﬁcally, RSA memory align() can be character-
ized as follows.
(1) It takes advantage of the “copy on
write” memory management policy as follows. First, it
uses posix memalign() to request one or more mem-
ory pages for fulﬁlling the afore-mentioned special mem-
ory region. Then, it copies the private key into the special
memory region, and zeros and frees the memory originally
containing the private key. Then, it updates the pointers in
the RSA data structure to point to the new location of the
private key. Finally, it sets the BN FLG STATIC DATA ﬂag
to inform OpenSSL that the private key is now exclusively
located at the special region.
(2) It prevents OpenSSL’s
RSA eay mod exp() from caching the private key by
unsetting the RSA FLAG CACHE PRIVATE ﬂag in the
flags member of the associated RSA data structure.
Moreover, RSA memory align() disables swapping of
memory that contains the private key by calling mlock()
on the memory allocated by posix memalign().
Implementing the library level solution. We mod-
ify
the OpenSSL function d2i PrivateKey(),
which is responsible for
translating a PEM-encoded
private key ﬁle into the RSA key parts by calling
d2i RSAPrivateKey().
The modiﬁcation is that
when the d2i RSAPrivateKey() method returns, we
immediately call
the function RSA memory align()
mentioned above.
Implementing the kernel level solution. We modify the
kernel function free hot cold page() to enforce that
memory pages are cleared, via clear highpage(), be-
fore they are added to one of the lists of free pages. Thus,
no private key will appear in unallocated memory.
Implementing the integrated library-kernel solution. In
addition to the modiﬁcations made in the library level so-
lution and in the kernel level solution mentioned above,
the PEM-encoded private key ﬁle can be removed from
allocated memory.
In order to do this, we introduce a
new ﬂag, O NOCACHE, to allow an application to instruct
the kernel to immediately remove this ﬁle from the “page
cache”. Speciﬁcally this is implemented as follows. When-
ever the PEM-encoded private key ﬁle is read, the kernel
gives the ﬁle contents to the requester and then checks if
the O NOCACHE ﬂag is speciﬁed.
If so, the kernel im-
mediately deletes the corresponding “page cache” entry
by calling remove from page cache() before calling
free page().
Experimental results. First, we re-examined the attack
based on [14] against the same vulnerable 2.6.10 Linux Ker-
nel, except that the system is now patched with our respec-
tive solutions. In no case were we able to recover any copy
of the private key.
Second, we re-examined the attack based on [10] against
the same vulnerable 2.6.10 Linux kernel, except that the
system is now patched with our solutions. For conciseness,
we only consider our integrated library-kernel solution. Fig-
ure 4(a) compares the average (over 20 attacks) number of
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:07 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007copies of the private key found in the USB device before
and after deploying our solution. It shows that the number
of copies of the private key recovered is reduced by our so-
lution because only one copy of the private key appears in
allocated memory, and no copies of the private key appear in
unallocated memory. Figure 4(b) compares the success rate
of attacks before and after deploying our integrated library-
kernel solution. While our solution does reduce the attack
success rate (from about 90% to about 50%), the attack still
succeeds with a probability about 50% because the attack
discloses on average about 50% of the memory. Thus, as
mentioned before, completely eliminating such powerful at-
tacks might have to resort to some special hardware devices.
Average OpenSSH RSA Private Keys Found Per Run
OpenSSH RSA Private Key Disclosure Rate
l
i
d
e
s
o
c
s
D
s
y
e
K
e
t
a
v
i
r
P
A
S
R
f
o
r
e
b
m
u
N
e
g
a
r
e
v
A
 35
 30
 25
 20
 15
 10
 5
 0
 0
"./data/plotssh-orig-totalexploit.dat"
"./data/plotssh-all-totalexploit.dat"
 20
 40
 60
 80
 100
 120
Total Connections
l
e
t
a
R
e
r
u
s
o
c
s
D
y
e
K
e
t
a
v
i
r
i
P
A
S
R
H
S
S
n
e
p
O
 1
 0.8
 0.6
 0.4
 0.2
 0
 0
[3] Bochs.
the bochs ia-32 emulator project. http://
bochs.sourceforge.net/.
[4] P. Broadwell, M. Harren, and N. Sastry. Scrash: A sys-
tem for generating secure crash information. In Usenix
Security Symposium’03.
[5] J. Chow, B. Pfaff, T. Garﬁnkel, K. Christopher, and
M. Rosenblum. Understanding data lifetime via whole
system simulation. In Usenix Security Symposium’04.
[6] J. Chow, B. Pfaff, T. Garﬁnkel, and M. Rosenblum.
Shredding your garbage: Reducing data lifetime. In
Proc.USENIX Security Symposium’05.
[7] G. Di Crescenzo, N. Ferguson, R. Impagliazzo, and
M. Jakobsson. How to forget a secret. In STACS’99.
[8] Y. Desmedt and Y. Frankel. Threshold cryptosystems.
In Proc. Crypto’89, pages 307–315.
"./data/plotssh-orig-freqexploit.dat"
"./data/plotssh-all-freqexploit.dat"
 20
 40
 60
 80
 100
 120
Total Connections
[9] Y. Dodis, J. Katz, S. Xu, and M. Yung. Key-insulated
public key cryptosystems. In Proc. EUROCRYPT’02.
(a) # of private keys found
(b) Attack success rates
Figure 4. OpenSSH effect of our library-
kernel solution countering the attack of [10]
As we show in [13] our solution does not impose any
performance penalty.
6 Conclusion
We investigated a set of mechanisms to deal with the ex-
posure of cryptographic keys caused by memory disclosure
attacks. Our mechanisms can eliminate attacks that disclose
unallocated memory, and can mitigate the damage due to
attacks that disclose a small portion of allocated memory.
Our result suggests that in order to eliminate powerful at-
tacks that can disclose a large portion of memory, one may
have to resort to special hardware devices.
Acknowledgement. We thank the anonymous reviewers
for their valuable comments, and our shepherd, Luigi Ro-
mano, for his constructive suggestions that improved the
paper.
This work was supported in part by ARO, NSF and
UTSA.
References
[1] R. Anderson. On the forward security of digital signa-
tures. Technical report, 1997.
[2] M. Bellare and S. Miner. A forward-secure digital sig-
nature scheme. In Proc. Crypto’99, pages 431–448.
[10] Georgi Guninski.
linux kernel 2.6 fun. windoze is a
http://www.guninski.com/where_
joke.
do_you_want_billg_to_go_today_3.
html (dated 15 February 2005).
[11] G. Itkis and L. Reyzin. Forward-secure signatures
with optimal signing and verifying. In Crypto’01.
[12] G. Itkis and L. Reyzin. Sibir: Signer-base intrusion-
resilient signatures. In Crypto’02.
[13] K. Harrison and S. Xu. Full version of the present
paper available at www.cs.utsa.edu/˜shxu.
[14] Mathieu Lafon and Romain Francoise.
Infor-
mation leak in the linux kernel ext2 implemen-
tation.
http://arkoon.net/advisories/
ext2-make-empty-leak.txt (Arkoon Secu-
rity Team Advisory - dated March 25, 2005).
[15] R. Ostrovsky and M. Yung. How to withstand mobile
virus attacks (extended abstract). In PODC’91.
[16] N. Provos. Encrypting virtual memory.
In Proc.
Usenix Security Symposium’00.
[17] A. Silberschatz, P. Galvin, and G. Gagne. Operating
System Concepts (sixth ed.). John Wiley & Sons.
[18] J. Viega.
Protecting sensitive data in mem-
http://www.cgisecurity.com/lib/
ory.
protecting-sensitive-data.html, 2001.
[19] J. Viega and G. McGraw. Building Secure Software.
Addison Wesley, 2002.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 20,2021 at 12:49:07 UTC from IEEE Xplore.  Restrictions apply. 
37th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN'07)0-7695-2855-4/07 $20.00  © 2007