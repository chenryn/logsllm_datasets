# 【漏洞分析】CVE-2017-0199：深入分析 Microsoft Office RTF 漏洞
|
##### 译文声明
本文是翻译文章，文章来源：fortinet.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
翻译：[ **lfty89**](http://bobao.360.cn/member/contribute?uid=2905438952)
预估稿费：190RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**  
**
**0x00 前言**
近日，研究人员又发现了数款CVE-2017-0199漏洞的样本。虽然微软在今年4月份已经发布了针对该漏洞的补丁，但由于其利用方式相对简单，全世界的使用率仍然很高，[这里](http://blog.fortinet.com/2017/05/30/spear-phishing-fileless-attack-with-cve-2017-0199)分享了一些钓鱼邮件样本的分析报告。目前大部分关于CVE-2017-0199漏洞的文章都将讨论的焦点放在如何构建POC上，本文另辟蹊径，从分析漏洞补丁出发，以一个较高层次的视角来解析漏洞原理，最后分享了一些分析样本的经验。
**0x01 漏洞补丁分析**
分析人员通常会构建一个黑盒测试环境来观察一个恶意代码样本的行为。这一思路同样可以用在漏洞补丁功能测试上，比如针对CVE-2017-0199漏洞，研究人员使用最新的Microsoft
Office套件，运行一些样本，观察补丁程序的工作模式。在测试时，研究人员在发现样本仍然能够成功地从远程服务器上下载payload并保存在Internet
Explorer的临时文件夹中，最后由于补丁的原因，payload并没有运行。
经过分析，发现漏洞补丁主要包括两个组件：
OLE32.dll：6.1.7601.23714 on Windows 7 x86
MSO.dll：14.0.7180.5002 on Microsoft Office 2010 on x86
首先对打过补丁和未打补丁的OLE32.dll文件做个对比分析：
图 1：OLE32.dll 6.1.7601.23714 (左) 和 6.1.7601. 23392 (右)
从图1中高亮部分可以看到函数的名称已经改变，推测可能是补丁新增的函数，接着使用IDA-Pro做进一步的分析：
图2：使用IDA交叉引用找到FilterActivation函数
通过交叉引用找到其调用函数FilerActivation，并发现其能被两个内部组件函数ICoGetClassObject和ICoCreateInstance调用，而这两个函数又被上层用于COM对象实例化的API如CoCreateInstance和CoGetClassObject封装。
对这些COM函数做对比分析，可以初步假设这个FilterActivation函数是一个用于应对CVE-2017-0199漏洞的一个新增函数。
图 3：ICoCreateInstance函数的比较结果
下面开始论证这一假设。
首先查看FilterActivation函数的伪代码：
图 4：FilterActivation伪代码
FilterActivation函数首先获取cisid参数的值，并将其传递给一个定义在全局变量g_ActvationFilter中的处理函数，而g_ActvationFilter是在COM初始化过程中被MSO.dll通过CoRegisterActivationFilter函数初始化的，同时MSO.dll也包含在漏洞补丁中。
下面再看一下MSO.dll的初始化过程，首先从OLE32.dll得到CoRegisterActivationFilter的API地址，然后使用g_pActivationFilter作为参数调用它：
图 5：MSO.dll初始化过程
我们知道g_pActivationFilter是一个指向IActivationFilter类型的指针，同时也保存在全局变量g_ActvationFilter中，最终通过静态分析和交叉引用找到其调用函数：mso_IActivationFilterHandleActivation()：
图 6：通过静态分析和交叉引用找到调用函数
通过查看该函数还可以发现一些与访问拒绝相关的代码：
CLSID_SCRIPTLET = {06290bd3-48aa-11d2-8432-006008c3fbfc}
CLSID_HTA = {3050f4d8-98b5-11cf-bb82-00aa00bdce0b}
CLSID_HTA是一个表示Microsoft HTML
Application（文件后缀.hta）的全局唯一标识符，由32个16进制字符组成，攻击者可以利用其结构达到远程代码执行的目的。例如，一个Microsoft
Office文档可以指定URL Moniker从远程服务器上下载该文档的嵌入式资源。
通过解读MSDN对MIME的[定义](https://msdn.microsoft.com/en-us/library/ms775147\(v=vs.85\).aspx)描述，如果远程服务器提供了“application/hta”的MIME类型，那么下载的文件就会被mshta.exe装载执行，在后台，HTA
COM对象的实例会在绑定操作过程中被创建，之后URLMON.dll会调用CoCreateInstance函数，后者初始化URL
Moniker。但是在最新版本的OLE32.dll中，FIlterActivation函数会在在COM对象被初始化之前对其CLSID值进行过滤检测，若值为CLSID_HTA则无法通过（见图7）。
图 7: 过滤检测
但从代码可看到，CLSID_SCRIPTLET值同样也无法通过。[这里](https://twitter.com/enigma0x3/status/859124491720458247)提供了一个能够初始化scriptlet
COM对象的POC，但是需要用户交互，如点击文档中的带“script:”或者“scriptlet:”的超链接。不过，就算是需要用户交互，“一个包含超链接内容的文档将导致代码执行”这一事实听起来仍然有点匪夷所思。
下面的栈结构反映了文档中的超链接被点击后的执行过程：
    //
    // Parse the moniker name "script:xxxxxx OR scriptlet:xxxxxx"
    //
    0:000> kb
    ChildEBP RetAddr  Args to Child             
    001e92fc 766cce60 159ceff8 1627cfc8 001eaa4c scrobj!ComMonikerFactory::ParseDisplayName
    001e9354 766ccf2c 1627cfc8 001eaa4c 001e9384 ole32!FindClassMoniker+0xf8 [d:w7rtmcomole32commoniker2cmonimp.cxx @ 1850]
    001e938c 7543655a 1627cfc8 001eaa4c 001ea484 ole32!MkParseDisplayName+0xbb [d:w7rtmcomole32commoniker2cmonimp.cxx @ 1467]
    001ea414 71b803c9 1627cfc8 001eaa4c 001ea484 urlmon!AppDataFolderList::GetPackageDependencyStateForIUri+0x17f3f
    001ea444 71b76421 00000001 106a6e74 00000000 hlink!HrParseDisplayNameEx+0x197
    001ea498 71b7681a 00000001 001eaa4c 00000000 hlink!HLNK::HrSetStringReference+0x91
    001ea4b0 61c08bd2 162daf28 00000001 001eaa4c hlink!HLNK::SetStringReference+0x25
    WARNING: Stack unwind information not available. Following frames may be wrong.
    001ea4cc 6181c47f 16298fd0 00000001 001eaa4c mso!Ordinal10017+0x2aa1
    001eba9c 61c1f384 16298fd0 00000000 00000000 mso!Ordinal8417+0x28a
    001ebac0 697b4415 16298fd0 00000000 00000000 mso!Ordinal2959+0x1c
    001ebb10 697b5377 00000000 00000000 0f5d0948 wwlib!DllGetLCID+0x7edf8f
    001ebbc4 697b7190 0f5d0948 00000000 0000008e wwlib!DllGetLCID+0x7eeef1
    001ebbec 69394c1d 69ca4400 0000008e 0000007e wwlib!DllGetLCID+0x7f0d0a
    001eda34 6938facc 0000008e 0000007e 00000000 wwlib!DllGetLCID+0x3ce797
    001eda64 692ebe3c 048c72b0 00000201 00000009 wwlib!DllGetLCID+0x3c9646
    001edaf0 68dc4acd 00350666 00000201 00000009 wwlib!DllGetLCID+0x3259b6
    001edb30 757ec4b7 00350666 00000201 00000009 wwlib!DllGetClassObject+0xf471
    001edb5c 757ec5b7 68dc4a8c 00350666 00000201 USER32!InternalCallWinProc+0x23
    001edbd4 757ecbe9 00000000 68dc4a8c 00350666 USER32!UserCallWinProcCheckWow+0x14b
    001edc34 757ecc40 68dc4a8c 00000000 001edc54 USER32!DispatchMessageWorker+0x357
    001edc44 68e1426d 69c9e630 69c9e630 001edc6c USER32!DispatchMessageW+0xf
    001edc54 68e13e05 69c9e630 757e2b1d 69c9e630 wwlib!GetAllocCounters+0x4da95
    001edc6c 68e13d4b 00000001 1311cfe4 12f10f8c wwlib!GetAllocCounters+0x4d62d
    001edc94 68e12cf0 68db517d 7728cebc 68db0000 wwlib!GetAllocCounters+0x4d573
    001efdf4 2fb91c68 2fb90000 00000000 0121ffd1 wwlib!GetAllocCounters+0x4c518