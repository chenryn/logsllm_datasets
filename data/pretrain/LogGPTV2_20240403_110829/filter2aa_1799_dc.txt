CHAPTER 10 Management, diagnostics, and tracing
already started for that ImagePath value. The existing SvcHost process reads the ServiceDll parameter 
in the service’s registry key, enables the new service group SID in its token, and loads the DLL into its 
process to start the service. 
Table 10-12 lists all the default service groupings on Windows and some of the services that are 
registered for each of them.
TABLE 10-12 Major service groupings
Service Group
Services
Notes
LocalService
Network Store Interface, Windows 
Diagnostic Host, Windows Time, 
COM+ Event System, HTTP Auto-
Proxy Service, Software Protection 
Platform UI Notification, Thread Order 
Service, LLDT Discovery, SSL, FDP 
Host, WebClient
Services that run in the local service 
account and make use of the network 
on various ports or have no network 
usage at all (and hence no restric-
tions).
LocalServiceAndNoImpersonation
UPnP and SSDP, Smart Card, TPM, 
Font Cache, Function Discovery, 
AppID, qWAVE, Windows Connect 
Now, Media Center Extender, 
Adaptive Brightness
Services that run in the local service 
account and make use of the network 
on a fixed set of ports. Services run 
with a write-restricted token.
LocalServiceNetworkRestricted
DHCP, Event Logger, Windows Audio, 
NetBIOS, Security Center, Parental 
Controls, HomeGroup Provider
Services that run in the local service 
account and make use of the network 
on a fixed set of ports.
LocalServiceNoNetwork
Diagnostic Policy Engine, Base 
Filtering Engine, Performance Logging 
and Alerts, Windows Firewall, WWAN 
AutoConfig
Services that run in the local service 
account but make no use of the net-
work at all. Services run with a write-
restricted token.
LocalSystemNetworkRestricted
DWM, WDI System Host, Network 
Connections, Distributed Link 
Tracking, Windows Audio Endpoint, 
Wired/WLAN AutoConfig, Pnp-X, HID 
Access, User-Mode Driver Framework 
Service, Superfetch, Portable Device 
Enumerator, HomeGroup Listener, 
Tablet Input, Program Compatibility, 
Offline Files
Services that run in the local system 
account and make use of the network 
on a fixed set of ports.
NetworkService
Cryptographic Services, DHCP Client, 
Terminal Services, WorkStation, 
Network Access Protection, NLA, DNS 
Client, Telephony, Windows Event 
Collector, WinRM
Services that run in the network 
service account and make use of the 
network on various ports (or have no 
enforced network restrictions).
NetworkServiceAndNoImpersonation
KTM for DTC
Services that run in the network ser-
vice account and make use of the net-
work on a fixed set of ports. Services 
run with a write-restricted token.
NetworkServiceNetworkRestricted
IPSec Policy Agent
Services that run in the network ser-
vice account and make use of the net-
work on a fixed set of ports.
CHAPTER 10 Management, diagnostics, and tracing
467
Svchost service splitting
As discussed in the previous section, running a service in a shared host process saves system resources 
but has the big drawback that a single unhandled error in a service obliges all the other services shared 
in the host process to be killed. To overcome this problem, Windows 10 Creators Update (RS2) has 
introduced the Svchost Service splitting feature. 
When the SCM starts, it reads three values from the registry representing the services global commit 
limits (divided in: low, medium, and hard caps). These values are used by the SCM to send “low resources” 
messages in case the system runs under low-memory conditions. It then reads the Svchost Service 
split threshold value from the HKLM\SYSTEM\CurrentControlSet\Control\SvcHostSplitThresholdInKB 
registry value. The value contains the minimum amount of system physical memory (expressed in KB) 
needed to enable Svchost Service splitting (the default value is 3.5 GB on client systems and around 
3.7 GB on server systems). The SCM then obtains the value of the total system physical memory using 
the GlobalMemoryStatusEx API and compares it with the threshold previously read from the registry. 
If the total physical memory is above the threshold, it enables Svchost service splitting (by setting an 
internal global variable).
Svchost service splitting, when active, modifies the behavior in which SCM starts the host Svchost 
process of shared services. As already discussed in the “Service start” section earlier in this chapter, the 
SCM does not search for an existing image record in its database if service splitting is allowed for a ser-
vice. This means that, even though a service is marked as sharable, it is started using its private hosting 
process (and its type is changed to SERVICE_WIN32_OWN_PROCESS). Service splitting is allowed only 
if the following conditions apply:
I 
Svchost Service splitting is globally enabled.
I 
The service is not marked as critical. A service is marked as critical if its next recovery action
specifies to reboot the machine (as discussed previously in the “Service failures” section).
I 
The service host process name is Svchost.exe.
I 
Service splitting is not explicitly disabled for the service through the SvcHostSplitDisable registry
value in the service control key.
Memory manager’s technologies like Memory Compression and Combining help in saving as much 
of the system working set as possible. This explains one of the motivations behind the enablement 
of Svchost service splitting. Even though many new processes are created in the system, the memory 
manager assures that all the physical pages of the hosting processes remain shared and consume as 
little system resources as possible. Memory combining, compression, and memory sharing are ex-
plained in detail in Chapter 5 of Part 1.
468 
CHAPTER 10 Management, diagnostics, and tracing
EXPERIMENT: Playing with Svchost service splitting
In case you are using a Windows 10 workstation equipped with 4 GB or more of memory, when you 
open the Task Manager, you may notice that a lot of Svchost.exe process instances are currently 
executing. As explained in this section, this doesn’t produce a memory waste problem, but you 
could be interested in disabling Svchost splitting. First, open Task Manager and count how many 
svchost process instances are currently running in the system. On a Windows 10 May 2019 Update 
(19H1) system, you should have around 80 Svchost process instances. You can easily count them by 
opening an administrative PowerShell window and typing the following command:
(get-process -Name "svchost" | measure).Count
On the sample system, the preceding command returned 85.
Open the Registry Editor (by typing regedit.exe in the Cortana search box) and navi-
gate to the HKLM\SYSTEM\CurrentControlSet\Control key. Note the current value of the 
SvcHostSplitThresholdInKB DWORD value. To globally disable Svchost service splitting, you 
should modify the registry value by setting its data to 0. (You change it by double-clicking the 
registry value and entering 0.) After modifying the registry value, restart the system and repeat 
the previous step: counting the number of Svchost process instances. The system now runs with 
much fewer of them:
PS C:\> (get-process -Name "svchost" | measure).Count 
26
To return to the previous behavior, you should restore the previous content of the 
SvcHostSplitThresholdInKB registry value. By modifying the DWORD value, you can also fine-tune 
the amount of physical memory needed by Svchost splitting for correctly being enabled.
Service tags
One of the disadvantages of using service-hosting processes is that accounting for CPU time and us-
age, as well as for the usage of resources by a specific service is much harder because each service is 
sharing the memory address space, handle table, and per-process CPU accounting numbers with the 
other services that are part of the same service group. Although there is always a thread inside the 
service-hosting process that belongs to a certain service, this association might not always be easy to 
make. For example, the service might be using worker threads to perform its operation, or perhaps the 
start address and stack of the thread do not reveal the service’s DLL name, making it hard to figure out 
what kind of work a thread might be doing and to which service it might belong.
Windows implements a service attribute called the service tag (not to be confused with the driver 
tag), which the SCM generates by calling ScGenerateServiceTag when a service is created or when the 
service database is generated during system boot. The attribute is simply an index identifying the ser-
vice. The service tag is stored in the SubProcessTag field of the thread environment block (TEB) of each 
thread (see Chapter 3 of Part 1 for more information on the TEB) and is propagated across all threads 
that a main service thread creates (except threads created indirectly by thread-pool APIs).
EXPERIMENT: Playing with Svchost service splitting
In case you are using a Windows 10 workstation equipped with 4 GB or more of memory, when you
open the Task Manager, you may notice that a lot of Svchost.exe process instances are currently
executing. As explained in this section, this doesn’t produce a memory waste problem, but you
could be interested in disabling Svchost splitting. First, open Task Manager and count how many
svchost process instances are currently running in the system. On a Windows 10 May 2019 Update
(19H1) system, you should have around 80 Svchost process instances. You can easily count them by
opening an administrative PowerShell window and typing the following command:
(get-process -Name "svchost" | measure).Count
On the sample system, the preceding command returned 85.
Open the Registry Editor (by typing regedit.exe in the Cortana search box) and navi-
gate to the HKLM\SYSTEM\CurrentControlSet\Control key. Note the current value of the 
SvcHostSplitThresholdInKB DWORD value. To globally disable Svchost service splitting, you 
should modify the registry value by setting its data to 0. (You change it by double-clicking the 
registry value and entering 0.) After modifying the registry value, restart the system and repeat 
the previous step: counting the number of Svchost process instances. The system now runs with 
much fewer of them:
PS C:\> (get-process -Name "svchost" | measure).Count
26
To return to the previous behavior, you should restore the previous content of the 
SvcHostSplitThresholdInKB registry value. By modifying the DWORD value, you can also fine-tune 
the amount of physical memory needed by Svchost splitting for correctly being enabled.
CHAPTER 10 Management, diagnostics, and tracing
469
Although the service tag is kept internal to the SCM, several Windows utilities, like Netstat.exe 
(a utility you can use for displaying which programs have opened which ports on the network), use 
undocumented APIs to query service tags and map them to service names. Another tool you can use 
to look at service tags is ScTagQuery from Winsider Seminars & Solutions Inc. (www.winsiderss.com/
tools/sctagquery/sctagquery.htm). It can query the SCM for the mappings of every service tag and 
display them either systemwide or per-process. It can also show you to which services all the threads 
inside a service-hosting process belong. (This is conditional on those threads having a proper service 
tag associated with them.) This way, if you have a runaway service consuming lots of CPU time, you can 
identify the culprit service in case the thread start address or stack does not have an obvious service 
DLL associated with it.
User services
As discussed in the “Running services in alternate accounts” section, a service can be launched using 
the account of a local system user. A service configured in that way is always loaded using the specified 
user account, regardless of whether the user is currently logged on. This could represent a limitation 
in multiuser environments, where a service should be executed with the access token of the currently 
logged-on user. Furthermore, it can expose the user account at risk because malicious users can po-
tentially inject into the service process and use its token to access resources they are not supposed to 
(being able also to authenticate on the network).
Available from Windows 10 Creators Update (RS2), User Services allow a service to run with the 
token of the currently logged-on user. User services can be run in their own process or can share a 
process with one or more other services running in the same logged-on user account as for standard 
services. They are started when a user performs an interactive logon and stopped when the user logs 
off. The SCM internally supports two additional type flags—SERVICE_USER_SERVICE (64) and SERVICE_
USERSERVICE_INSTANCE (128)—which identify a user service template and a user service instance.
One of the states of the Winlogon finite-state machine (see Chapter 12 for details on Winlogon 
and the boot process) is executed when an interactive logon has been initiated. The state creates the 
new user’s logon session, window station, desktop, and environment; maps the HKEY_CURRENT_USER 
registry hive; and notifies the logon subscribers (LogonUI and User Manager). The User Manager 
service (Usermgr.dll) through RPC is able to call into the SCM for delivering the WTS_SESSION_LOGON 
session event. 
The SCM processes the message through the ScCreateUserServicesForUser function, which calls 
back into the User Manager for obtaining the currently logged-on user’s token. It then queries the list 
of user template services from the SCM database and, for each of them, generates the new name of 
the user instance service. 
470 
CHAPTER 10 Management, diagnostics, and tracing
EXPERIMENT: Witnessing user services
A kernel debugger can easily show the security attributes of a process’s token. In this experi-
ment, you need a Windows 10 machine with a kernel debugger enabled and attached to a host 
(a local debugger works, too). In this experiment, you choose a user service instance and analyze 
its hosting process’s token. Open the Services tool by typing its name in the Cortana search box. 
The application shows standard services and also user services instances (even though it erro-
neously displays Local System as the user account), which can be easily identified because they 
have a local unique ID (LUID, generated by the User Manager) attached to their displayed names. 
In the example, the Connected Device User Service is displayed by the Services application as 
Connected Device User Service_55d01:
If you double-click the identified service, the tool shows the actual name of the user service 
instance (CDPUserSvc_55d01 in the example). If the service is hosted in a shared process, like the 
one chosen in the example, you should use the Registry Editor to navigate in the service root key 
of the user service template, which has the same name as the instance but without the LUID (the 
user service template name is CDPUserSvc in the example). As explained in the “Viewing privi-
leges required by services” experiment, under the Parameters subkey, the Service DLL name is 
stored. The DLL name should be used in Process Explorer for finding the correct hosting process 
ID (or you can simply use Task Manager in the latest Windows 10 versions).
After you have found the PID of the hosting process, you should break into the kernel de-
bugger and type the following commands (by replacing the  with the PID of the 
service’s hosting process):
!process  1
EXPERIMENT: Witnessing user services
A kernel debugger can easily show the security attributes of a process’s token. In this experi-
ment, you need a Windows 10 machine with a kernel debugger enabled and attached to a host 
(a local debugger works, too). In this experiment, you choose a user service instance and analyze 
its hosting process’s token. Open the Services tool by typing its name in the Cortana search box. 
The application shows standard services and also user services instances (even though it erro-
neously displays Local System as the user account), which can be easily identified because they 
have a local unique ID (LUID, generated by the User Manager) attached to their displayed names. 
In the example, the Connected Device User Service is displayed by the Services application as 
Connected Device User Service_55d01:
If you double-click the identified service, the tool shows the actual name of the user service 
instance (CDPUserSvc_55d01 in the example). If the service is hosted in a shared process, like the 
one chosen in the example, you should use the Registry Editor to navigate in the service root key 
of the user service template, which has the same name as the instance but without the LUID (the 
user service template name is CDPUserSvc in the example). As explained in the “Viewing privi-
leges required by services” experiment, under the Parameters subkey, the Service DLL name is 
stored. The DLL name should be used in Process Explorer for finding the correct hosting process 
ID (or you can simply use Task Manager in the latest Windows 10 versions).
After you have found the PID of the hosting process, you should break into the kernel de-
bugger and type the following commands (by replacing the  with the PID of the 
service’s hosting process):
!process  1
CHAPTER 10 Management, diagnostics, and tracing
471
The debugger displays several pieces of information, including the address of the associated 
security token object:
Kd: 0> !process 0n5936 1 
Searching for Process with Cid == 1730 
PROCESS ffffe10646205080 
    SessionId: 2  Cid: 1730    Peb: 81ebbd1000  ParentCid: 0344 
    DirBase: 8fe39002  ObjectTable: ffffa387c2826340  HandleCount: 313. 
    Image: svchost.exe 
    VadRoot ffffe1064629c340 Vads 108 Clone 0 Private 962. Modified 214. Locked 0. 
    DeviceMap ffffa387be1341a0 
    Token
ffffa387c2bdc060 
    ElapsedTime
00:35:29.441 
    ...     
To show the security attributes of the token, you just need to use the !token command fol-
lowed by the address of the token object (which internally is represented with a _TOKEN data 
structure) returned by the previous command. You should easily confirm that the process is 
hosting a user service by seeing the WIN://ScmUserService security attribute, as shown in the 
following output:
0: kd> !token ffffa387c2bdc060 
_TOKEN 0xffffa387c2bdc060 
TS Session ID: 0x2 
User: S-1-5-21-725390342-1520761410-3673083892-1001 
User Groups:  
 00 S-1-5-21-725390342-1520761410-3673083892-513 
    Attributes - Mandatory Default Enabled  
...  ... 
OriginatingLogonSession: 3e7 