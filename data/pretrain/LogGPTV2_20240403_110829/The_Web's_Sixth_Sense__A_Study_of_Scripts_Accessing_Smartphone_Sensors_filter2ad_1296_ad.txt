of raw sensor data it was not captured through our sensor spoof-
ing mechanism. We were only able to identify this via manually
debugging the script on a real smartphone (through USB debug-
ging features of the Chrome Devtool). We found doubleverify.com
scripts being loaded on 517 websites of which 7 appeared in the
Alexa top 1000 sites (in our US1 dataset). However, since doublev-
erify.com evaluates ad impressions the presence of these scripts
is dependent on the ads that are served on a website, and hence
we see it on different sites in different crawls. For instance, in US2
dataset we found 509 sites loading the script from doubleverify.com.
The union of these datasets results in 881 unique sites loading the
script, of which 145 sites were common (Jaccard index 0.16). In
the EU1 dataset (European crawl), however, doubleverify.com was
not present on any of the 100K sites, indicating that the loading of
scripts may depend on the location of the visitor.
Some sensor reading scripts are served from the first party’s
domain, making the attribution to specific providers more difficult.
For instance, a highly obfuscated script that is present on popular
sites like homedepot.com and staples.com is always served on
the /_bm/async.js path under the first party (e.g., m.staples.com/_-
bm/async.js). This script sends encoded sensor data in a POST
request to the endpoint _bm/_data on the first-party site. A code
snippet is provided in appendix B (Listing 4). The prevalence of
these scripts was more or less similar as it is site dependent rather
than being ad dependent. We found 173 sites loading such scripts in
the US1 dataset, 12 of which were ranked in the Alexa top 1000 sites.
For the US2 and EU1 dataset we found 140 and 158 sites loading
such scripts, respectively.
6 EFFICACY OF COUNTERMEASURES
In this section we study the overlap between scripts that access
sensors and scripts that perform fingerprinting. We then study the
effectiveness of privacy countermeasures such as ad blocking lists
as well as browser limitations on sensor APIs.
6.1 Fingerprinting Scripts
First, we will showcase to what extent scripts accessing sensor
APIs overlap with fingerprinting scripts. To detect fingerprinting
scripts we follow methodologies from existing literatures [1, 31],
which are also listed in Table 2. Table 8 highlights the percentage
of sensor accessing scripts that also utilize browser fingerprinting,
as captured by the features described in section 3.4. We calculate
the percentage of scripts accessing a given sensor that also perform
a particular type of fingerprinting. For example, 62.7% of scripts
that access motion sensors also engage in some form of browser
fingerprinting.
Table 8: Percentage of sensor accessing scripts that also en-
gage in fingerprinting. All columns except ‘Total’ are given
as percentage. The ‘Total’ column shows the number of dis-
tinct script URLs that access a certain sensor.
Canvas
FP
56.7
Motion
Orientation 36.2
2.1
Proximity
19.5
Light
Canvas
Font FP
0.2
3.4
0.0
1.2
Audio
FP
19.8
5.7
47.9
56.1
WebRTC
FP
6.8
6.2
0.0
15.9
Battery
FP
5.6
4.5
49.0
57.3
Any
FP
62.7
41.7
51.0
76.8
Total
501
650
96
82
Table 9 showcases the numbers from the other angle: the fraction
of fingerprinting scripts that access different sensor APIs. We list
the percentage of distinct script URLs that engage in a particular
form of fingerprinting while accessing any of the sensors explored
in our study. Both of these tables indicate that there is a significant
overlap between the fingerprinting scripts and the scripts accessing
sensor APIs.
6.2 Ad Blocking and Tracking Protection Lists
We next inspect what fraction of these sensor-accessing scripts
would be blocked by different well known filtering lists used for ad
blocking and tracking protection: EasyList [27], EasyPrivacy [28]
Table 9: Percentage of fingerprinting scripts that also access
sensors. All columns except ‘Total’ are given as percentage.
The ‘Total’ column shows the number of distinct fingerprint-
ing script URLs that use a particular fingerprinting method.
Motion Orien-
tation
1.5
1.4
Canvas FP
34.1
Canvas Font FP 32.9
20.0
20.7
Audio FP
10.9
10.5
WebRTC FP
4.5
4.6
Battery FP
Proxi-
mity
2.0
47.1
28.6
15.0
6.4
Light Any
sensor Total
1991
15.9
2.0
85
24.7
47.1
28.6
81.4
140
267
20.2
15.0
6.4
7.5
625
and Disconnect [25]. Table 10 highlight the percentage of tracking
scripts that would be blocked using each of these lists. In general,
we see that a significant portion of scripts that access sensors are
missed by the popular blacklists, which is in line with the previous
research on tracking protection lists [52].
Table 10: Percentage of script domains accessing device sen-
sors that are blocked by different filtering list.
Sensor
Disconnect
blocked
1.8%
Motion
Orientation 3.6%
6.0%
Proximity
2.9%
Light
2.9%
Any sensor
EasyList
blocked
1.8%
3.1%
2.0%
2.9%
2.5%
EasyPrivacy
blocked
2.9%
3.1%
4.0%
8.6%
3.3%
6.3 Difference in Browser Behavior
To determine browser support for different sensor APIs and po-
tential restrictions for scripts in cross-origin iframes, we set up a
test page that accesses all four sensor APIs. We tested the latest
version of nine browsers listed in Table 11 as of Jan, 2018. Browsers
have minor differences with regards to which sensor they support
and how they block access from scripts embedded in cross-origin
iframes. Table 11 summarizes our findings. As shown in the table,
proximity and light sensors are only supported by Firefox.8 For
privacy reasons, Firefox and Safari do not allow scripts from cross-
origin iframes to access sensor data, which is in line with W3C
recommendation [80]. Privacy-geared browsers such as Firefox Fo-
cus and Brave fare worse than Firefox and Safari, as they both allow
access to orientation data from cross-origin iframes, where Firefox
Focus further allows access to motion data.
Testing the sensor API availability on insecure (HTTP) pages, we
found no differences in browsers’ behavior. We also tested whether
browsers have any access restrictions when running in private
browsing mode, and we found no difference when comparing to
normal browsing mode.9 Finally, to test whether the underlying
mobile platform has any effect on sensor availability, we tested iOS
8As of May 9, 2018 Mozilla released Firefox version 60, which disables proximity and
light sensor APIs; we used an earlier version of Firefox in our study.
9Note that Firefox Focus always runs in private browsing mode, so it does not have a
separate normal browsing mode.
versions of the browsers. We found that all browsers behave identi-
cal to Safari, as Apple requires browsers to use WebKit framework
to be listed on their app store [21].
Table 11: Browser support for different sensor APIs.
Light∗
(✗, ✗)
(✗, ✗)
(✗, ✗)
(✓, ✗)
(✗, ✗)
(✗, ✗)
(✗, ✗)
(✗, ✗)
(✗, ✗)
Proximity∗
Browser
(✗, ✗)
Chrome
(✗, ✗)
Edge
(✗, ✗)
Safari
(✓, ✗)
Firefox
(✗, ✗)
Brave
(✗, ✗)
Focus
(✗, ✗)
Dolphin
(✗, ✗)
Opera Mini
UC Browser
(✗, ✗)
∗ Each tuple representing (third-party, iframe) access right
Orientation∗ Motion∗
(✓, ✓)
(✓, ✓)
(✓, ✓)
(✓, ✓)
(✓, ✗)
(✓, ✗)
(✓, ✗)
(✓, ✗)
(✓, ✗)
(✓, ✓)
(✓, ✓)
(✓, ✓)
(✓, ✓)
(✓, ✓)
(✓, ✓)
(✓, ✓)
(✓, ✓)
(✓, ✓)
We filed bug reports for Brave Android Browser, Firefox Focus
and Firefox for Android [12, 36–38] pointing out that they allow
sensor access on insecure pages, which is against W3C recommen-
dations. Firefox Focus engineers told us that they will have to wait
for Chromium/WebView to ship an update for this behavior to
change since Firefox Focus on Android uses Chromium under the
hood. Responding to the issue we filed for Firefox for Android,
Mozilla engineers briefly discussed the possibility of requiring user
permission for allowing sensor access. We did not get any response
to our issue from Brave engineers. We note that Brave Android is
also built on Chromium.
7 DISCUSSION AND RECOMMENDATIONS
Our analysis of crawling the Alexa top 100K sites indicates that
tracking scripts did not wait long to take advantage of sensor data,
something that is easily accessible without requiring any user per-
mission. By spoofing real sensor values we found that third-party
ad and analytics scripts are sending raw sensor data to remote
servers. Moreover, given that existing countermeasures for mo-
bile platforms are not effective at blocking trackers, we make the
following recommendations.
• W3C’s recommendation for disabling sensor access on cross-
origin iframes [80] will limit the access from untrusted third-
party scripts and is a step in the right direction. However,
Safari and Firefox are the only two browsers that follow this
recommendation. Our measurements indicate that scripts
that access sensor APIs are frequently embedded in cross-
origin iframes (67.4% of the 31 444 cases). This shows that
W3C’s mitigation would be effective at curbing the exposure
to untrusted scripts. Allowing sensor access on insecure
pages is another issue where browsers do not follow the
W3C spec: all nine browsers we studied allowed access to
sensors on insecure (HTTP) pages.
• Feature Policy API [16], if deployed, will allow publishers
to selectively disable JavaScript APIs. Publisher may disable
sensor APIs using this API to prevent potential misuses by
the third-party scripts they embed.
• Provide low resolution sensor data by default, and require
user permission for higher resolution sensor data.
• To improve user awareness and curb surreptitious sensor
access, provide users with a visual indication that the sensor
data is being accessed.
• Require user permission to access sensor data in private
browsing mode, limit resolution, or disable sensor access all
together.
8 LIMITATIONS
Our clustering analysis depends on OpenWPM’s instrumentation
data to attribute JavaScript behavior to individual scripts. There are
potential imperfections in this attribution task. First, some websites
concatenate several JavaScript files and libraries into a single file.
These scripts would be seen as one script (URL) to OpenWPM’s
instrumentation, potentially adding noise in the clustering stage.
Second, when attributing JavaScript function calls and property
accesses to individual scripts, we use the script URL that appears
at the top of the calling stack following the prior work done by
Englehardt and Narayanan [31]. Under some circumstances, this ap-
proach may be misleading. For instance, when a script uses jQuery
library to listen to sensor events, we attribute the sensor related
feature to jQuery as it appears at the top of the calling stack.
OpenWPM-Mobile uses OpenWPM’s JavaScript instrumenta-
tion, which captures function calls made and browser properties
accessed at runtime (Section 3.4). This approach has the advantage
of capturing the behavior of obfuscated code, but may miss code
segments that do not execute during a page visit.
We manually analyzed a random subsample of scripts instead
of studying all scripts per cluster. While this process may miss
some misbehaving scripts, we believe the outcomes will not be
affected as the average intra- and inter-cluster similarity scores are
significantly apart.
OpenWPM-Mobile does not store in-line scripts. We found that
only 12.1% (111 of 916) of the scripts were in-line. We were able to
re-crawl sites that included the in-line scripts and stored them for
the clustering step.
There are many ways in which trackers can exfiltrate sensor data,
for example, using encryption or computing and sending statistics
on the sensor data as we present in section 5.5. Therefore, our
results on sensor data exfiltration should be taken as lower bounds.
Using fingerprinting test suites fingerprintjs2 [84] and EFF’s
Panopticlick [30], we verified that OpenWPM-Mobile’s browser