title:Execute This! Analyzing Unsafe and Malicious Dynamic Code Loading
in Android Applications
author:Sebastian Poeplau and
Yanick Fratantonio and
Antonio Bianchi and
Christopher Kruegel and
Giovanni Vigna
Execute This!
Analyzing Unsafe and Malicious Dynamic Code
Loading in Android Applications
Sebastian Poeplau∗†, Yanick Fratantonio∗, Antonio Bianchi∗, Christopher Kruegel∗, Giovanni Vigna∗
∗UC Santa Barbara
Santa Barbara, CA, USA
Email: {yanick,antoniob,chris,vigna}@cs.ucsb.edu
†University of Bonn
Bonn, Germany
Email: PI:EMAIL
Abstract—The design of the Android system allows applica-
tions to load additional code from external sources at runtime. On
the one hand, malware can use this capability to add malicious
functionality after it has been inspected by an application store
or anti-virus engine at installation time. On the other hand,
developers of benign applications can inadvertently introduce vul-
nerabilities. In this paper, we systematically analyze the security
implications of the ability to load additional code in Android. We
developed a static analysis tool to automatically detect attempts
to load external code using static analysis techniques, and we
performed a large-scale study of 1,632 popular applications from
the Google Play store, showing that loading external code in
an insecure way is a problem in as much as 9.25% of those
applications and even 16% of the top 50 free applications. We
also show how malware can use code-loading techniques to avoid
detection by exploiting a conceptual weakness in current Android
malware protection. Finally, we propose modiﬁcations to the
Android framework that enforce integrity checks on code to
mitigate the threats imposed by the ability to load external code.
I.
INTRODUCTION
Recent years have seen the Android platform gain more and
more popularity, and a considerable number of mobile phones
and tablet computers ship with Android. Speciﬁcally, Google
announced at its developer conference Google I/O in May
2013 that 900 million Android installations have been activated
since the launch of the system in 2008. The large number of
devices running the Android operating system provides great
opportunities for developers to reach a broad audience while
only having to develop for a single platform. Unfortunately,
the same economic incentives appeal to criminals as well.
By targeting Android, they have the opportunity to conduct
malicious activity on millions of devices. Accordingly, the
amount of malware for and attacks against Android is steadily
Permission(cid:1) to(cid:1) freely(cid:1) reproduce(cid:1) all(cid:1) or(cid:1) part(cid:1) of(cid:1) this(cid:1) paper(cid:1) for(cid:1) noncommercial(cid:1)
purposes(cid:1) is(cid:1) granted(cid:1) provided(cid:1) that(cid:1) copies(cid:1) bear(cid:1) this(cid:1) notice(cid:1) and(cid:1) the(cid:1) full(cid:1) citation(cid:1)
on(cid:1)the(cid:1)ﬁrst(cid:1)page.(cid:1) Reproduction(cid:1)for(cid:1)commercial(cid:1)purposes(cid:1)is(cid:1)strictly(cid:1)prohibited(cid:1)
without(cid:1)the(cid:1)prior(cid:1)written(cid:1)consent(cid:1)of(cid:1)the(cid:1)Internet(cid:1)Society,(cid:1)the(cid:1)ﬁrst-named(cid:1)author(cid:1)
(for(cid:1) reproduction(cid:1) of(cid:1) an(cid:1) entire(cid:1) paper(cid:1) only),(cid:1) and(cid:1) the(cid:1) author’s(cid:1) employer(cid:1) if(cid:1) the(cid:1)
paper(cid:1) was(cid:1) prepared(cid:1) within(cid:1) the(cid:1) scope(cid:1) of(cid:1) employment.
NDSS(cid:1) ’14,(cid:1) 23-26(cid:1) February(cid:1) 2014,(cid:1) San(cid:1) Diego,(cid:1) CA,(cid:1) USA
Copyright(cid:1) 2014(cid:1) Internet(cid:1) Society,(cid:1) ISBN(cid:1) 1-891562-35-5
http://dx.doi.org/(cid:18)(cid:17)(cid:15)(cid:18)(cid:21)(cid:24)(cid:19)(cid:19)(cid:16)(cid:79)(cid:69)(cid:84)(cid:84)(cid:15)(cid:19)(cid:17)(cid:18)(cid:21)(cid:15)(cid:19)(cid:20)(cid:20)(cid:19)(cid:25)
increasing [24], [34]. For example, malicious applications steal
users’ private information or use cost-sensitive functionality
such as premium SMS to generate revenue for the attackers.
In order to counter the spread of malicious content in
the Google Play store,1
Android’s main application store,
Google introduced a vetting mechanism for applications in
2012 [21]. This system, called Google Bouncer, analyzes
every application for malicious functionality that is submitted
to Google’s store. The analysis is performed ofﬂine,
i.e.,
applications are analyzed in a centralized location before being
admitted to the store. The alternative would be to conduct the
application analysis online, i.e., directly on the users’ devices.
However, this is impractical due to the large importance of
battery life for mobile devices and the access restrictions
that the system enforces for all applications, including anti-
virus software. The inner workings of the Bouncer are not
precisely known to the public, but experiments by Oberheide
and Miller indicate that Google uses dynamic analysis to
examine applications [25].
A powerful way for malware to circumvent the Bouncer is
by loading external code at runtime. For example, imagine
an application that pretends to be a simple game. During
the Bouncer’s analysis, the application does not expose any
malicious behavior, and even its code does not contain any
malicious functionality. But once the application has been
approved by the Bouncer, admitted to the store and installed
by users, it starts to download and execute additional code that
performs harmful activities. We show that using this technique,
applications are able to evade detection by the Bouncer and
several mobile anti-virus products.
We would like to stress that such evasion techniques that
rely on the ability to load arbitrary code at runtime are more
powerful than the ones presented in the past. In fact, this
class of techniques exploits a conceptual problem of ofﬂine
vetting mechanisms: First, these mechanisms can never be sure
that they see all the code that an application will eventually
execute on users’ devices. The application could just download
additional code from the Internet on any device and at any
point in time. Secondly, techniques to load code at runtime are
1https://play.google.com/store/apps
often used by benign applications as well. Therefore, vetting
systems cannot use the mere presence of such functionality as
a feature to detect malware.
In this paper, we present a large-scale study that analyzes
the use of code-loading techniques in applications on Google
Play. We ﬁnd a surprisingly large number of applications
that use the techniques for a variety of legitimate reasons.
In particular, the results emphasize that the mere ability of
applications to load external code is not an indication of
malicious intentions.
Unfortunately,
the existence of mechanisms that allow
applications to load code from external sources in Android
introduces yet another problem: Benign applications use the
techniques for legitimate reasons, but their use is prone to
introducing vulnerabilities. In fact, we found that Android does
not enforce appropriate security checks on the external code,
and application developers are often unaware of the risks or
do not succeed in properly implementing custom protection
mechanisms.
As part of our experimental study, we apply static analysis
techniques to automatically detect if a given application is able
to retrieve and execute additional code and if it does so in an
unsafe way. To our surprise, we ﬁnd severe vulnerabilities both
in Android applications and in third-party frameworks. We
present two example exploits, which would enable an attacker
to mount code injection attacks against more than 30,000
applications on Google Play, affecting several tens of millions
of users. We notiﬁed the affected developers and collaborated
with one framework vendor in an effort to mitigate the risk to
the users as quickly as possible.
As a remedy to both types of attacks – malware escaping
ofﬂine analysis as well as code injection into benign appli-
cations – we propose a modiﬁcation of Android’s Dalvik
virtual machine. Our protection system aims to add the miss-
ing mandatory checks of code from external sources to the
operating system. The checks are computationally cheap and
do not require extensive changes to the Android system, while
effectively protecting the users from attacks that are currently
possible due to applications’ ability to load external code.
Our main contributions can be summarized as follows:
1) We systematically analyze the Android platform for
techniques that allow applications to load code at
runtime, and examine their respective security impli-
cations.
2) We develop an efﬁcient static-analysis tool that au-
tomatically detects problematic behavior associated
with dynamic code loading in applications. Our tool
can detect vulnerabilities in benign applications as
well as support the analysis of potentially malicious
applications.
3) We conduct an analysis of 1,632 popular applications
on Google Play, each with more than one million
installations, revealing that 151 (9.25%) of them are
vulnerable to code injection attacks.
4) We propose and implement a modiﬁcation to An-
droid’s Dalvik VM, which prevents all attacks that
are possible due to external code loading.
II. BACKGROUND AND THREAT MODEL
In this section, we introduce concepts and terminology
related to Android security on which we will rely in the
remainder of this paper, and we present the threat model that
our work is based on.
A. Android
The following concepts of the Android system in general,
and Android security in particular, are important in the context
of our work.
1) Android permissions: Android restricts the access of
applications to sensitive functionality by means of permissions.
Permissions regulate access to sensitive APIs that can cause
ﬁnancial damage (e.g., SMS services and phone calls), com-
promise the user’s privacy (e.g., record sound or video, use
the Internet) or negatively affect device usability (e.g., lock the
screen). Each application has to declare the set of permissions
that it requires.
Whenever an application is installed, Android presents
the user with a list of the requested permissions and asks
for approval. The user can either accept all permissions or
cancel the installation. It is not currently possible to selectively
remove permissions from applications.
Internally, Android enforces permissions by using high-
level checks in Java code as well as common Linux security
concepts, e.g., ﬁle permissions, user and group IDs.
2) Application stores: Applications are commonly installed
from stores, entities that offer large collections of applications
for users to download. The main application store is the Google
Play store – most Android devices have the application to
access this store preinstalled. At a press event in July 2013,
Google announced that the Google Play store offers more than
one million applications.
Android provides the option to install applications that
access alternative stores, such as the Amazon application
store. Note that the system treats the store that the device
manufacturer prefers differently from others: In order to install
APKs from other stores, users have to enable the so-called
sideloading setting, which allows the user to install APKs from
arbitrary sources, while otherwise the system rejects anything
that does not originate from the preferred store.
Since the amount of malware on Google Play was grow-
ing, Google introduced a system called Google Bouncer in
February 2012 [21]. The Bouncer checks every application
that is submitted to Google Play for malicious behavior. Its
internal workings are not precisely known, but there have been
successful attempts to circumvent or attack it, e.g., by ﬁnger-
printing the analysis system that the Bouncer is based on [25].
As mentioned previously, the experiments by Oberheide and
Miller suggest that the main component of the Bouncer is
dynamic analysis conducted in Qemu.
We will show that by loading code from the Internet at
runtime an attacker can circumvent the checks imposed by the
Bouncer.
2
3) Native code: Android applications are usually written
in Java and compiled to Dalvik bytecode. For computationally
expensive tasks, Android provides the option to run so-called
native code, i.e., machine code for the device’s processor. The
common way of invoking native code on Android is through
the Java Native Interface (JNI), a standardized interface for
interaction between Java and native code. At
the system
level, loading native code means that Dalvik, Android’s virtual
machine, loads a Linux shared object and allows Java code to
make calls to the contained native functions (and vice versa).
Native code runs in the same sandbox as Java code.
Speciﬁcally, the same permissions are enforced on native code
as on Java code.
4) Application frameworks: When developing applications,
many developers rely on frameworks. Such frameworks pro-
vide additional functionality, such as components that down-
load and display advertisements within the application.
Different developers usually maintain frameworks and ap-
plications, so that their update cycles generally do not coincide.
Updated applications can be published in application stores
and pushed to users immediately. New versions of frameworks,
however, ﬁrst need to be included in all affected applications
by the application developers before they can be installed on
the users’ devices with the next version of the application.
This means that it is considerably more difﬁcult for frame-
work developers to deploy updates than it is for application
developers.
B. Threat model
Before we examine the attacks and our proposed counter-
measures in more detail, we outline the threat model that our
work is based on. We consider two different attack scenarios:
1) Evasion of ofﬂine analysis systems: In this ﬁrst scenario,
an attacker creates a malicious application and tries to publish
it in an application store such as Google Play. In order to
avoid detection, she designs the application in such a way that
it does not contain any clearly malicious code itself, but rather
downloads additional code after being installed on a device.
Since most of the application analysis mechanisms work in
a central place, such as the various application stores, the
malicious code can easily circumvent the checks. Note how it
is conceptually impossible for ofﬂine analysis systems, such as
the Google Bouncer, to detect the malicious functionality: The
code that they analyze does not contain anything malicious,
and they have no way of knowing what additional code the
application might download at a later point in time. Since
benign applications use code-loading techniques as well, the
detection system cannot reject applications that load external
code per se. An analysis of a large corpus of Android malicious
applications conducted by Zhou and Jiang uncovered malware
samples that already use this technique to evade detection [37].
For demonstration purposes, we designed an application that
makes use of the same approach and uploaded it to Google
Play to conﬁrm that the application can be distributed without
Google checking the additional code that might be downloaded
later (see Section III-D1 for details).
2) Code injection against benign applications: The second
scenario involves applications that load additional code for
benign reasons (see Section III-B for a discussion of possible
motives). As the operating system does not enforce security
checks on the loaded code, an attacker could replace the
original code with malicious one. At this point, a vulnerable
application would load the malicious code, not recognizing
that it is different from the intended one, and executes it. This
gives attackers a way to run arbitrary code in the context of
an application on the user’s device (in particular, with the
application’s permissions and with full access to its data).
In Section III-D2, we discuss different ways to exploit such
vulnerabilities, and, in Section V-B, we present attacks against
two popular application frameworks.
The protection system that we propose is designed to defeat
both types of threats.
III.
INVESTIGATION OF CODE LOADING
In this section, we ﬁrst examine different techniques that
applications can use to load external code at runtime, and
brieﬂy outline why they can cause security issues. We then de-
scribe reasons for benign applications to load additional code.
Finally, we point out typical mistakes of benign applications
when using code-loading techniques.
A. Techniques to load code
We identiﬁed several ways to let Android load external
code on behalf of an application. These techniques can be
used by malware to avoid detection, and improper use can
make benign applications vulnerable.
1) Class loaders: Class loaders are Java objects that allow
programs to load additional classes, i.e., Java code. Android
applications can use class loaders to load classes from arbitrary
ﬁles. The Android class loaders support different ﬁle formats
(APK, JAR, pure dex ﬁles, optimized dex ﬁles). They do not
impose restrictions on the location or provenance of the ﬁle
containing the code. For instance, an application can download
an APK ﬁle from the Internet and use DexClassLoader to load
the contained classes. By invoking the classes’ methods, the
application executes the downloaded code.
Benign applications are at risk of code injection,
i.e.,
an attacker can replace the ﬁle that is to be loaded with a
malicious one, if it is stored in a writable location. The Android
system does not check the integrity of class ﬁles in any way. In
particular, running applications do not require a signature when
loading APKs. In Section V-B1, we present an exploit that
injects code into an application by hijacking the application’s
connection to the server that it downloads code from.
2) Package contexts: Whenever Android loads an applica-
tion, it associates it with a Context object. The context, among
other things, provides access to the application’s resources,
such as image ﬁles or code. Android provides applications