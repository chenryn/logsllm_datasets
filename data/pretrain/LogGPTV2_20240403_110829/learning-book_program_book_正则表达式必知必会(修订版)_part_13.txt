向前查找操作，它匹配（但不消费）。最终返回的匹配结果包
含且仅包含标题文字（用术语来说，就是只有标题文字被消费了）。
?
提示为减少歧义，在上面这个例子里，你应该对标签全都找出来：不仅如此，如果某个
---
## Page 102
92第10章嵌入条件
标签是一个链接（被括在和标签之间）的话，你还要把整个链接
标签匹配出来，
用来定义这种条件的语法是（?（backreference)true-regex），其中？
表明这是一个条件，括号里的backreference是一个回溯引用，true-regex
是一个只在backreference存在时才会被执行的子表达式。
请看下面这个例子：
文本
,T5 auou/se6euT/,=0HS 0W[>,ewou/,=38H V>
正则表达式
(s(t))(s\)
结果
分析
这个模式不解释是不容易看明白的。（]+>\s*）?将匹配
一个或标签（以及或标签的任意属性），这个标签可有可无
（因为这个子表达式的最后有一个？）。接下米，]+>
匹配个（大小写均可）及其任意属性。（?（1)\s*）是一
个回溯引用条件，？（1）的含义是：如果第一个回溯引用（具体到本例，
就是标签）存在，则使用\s*继续进行匹配（换句话说，
只有当前面的标签匹配成功，才继续进行后面的匹配）。如果（1）
---
## Page 103
10.2正则表达式里的条件
93
存在，\s*将匹配结束标签之后出现的任意空白字符。
注意？（1）检查第一个回潮引用是否存在。在条件里，回溯引
用编号（本例中的1）不需要被转义，因此，？（1）是正确的，?（\1）
不正确（但后者通常也能工作）。
我们刚才使用的模式只在给定条件得到满足时才执行一个表达式，条件
还可以有否则表达式，否则表达式只在给定的回溯引用不存在（也就是条件
没有得到满足）时才会被执行。用来定义这种条件的语法是（?（backre
ference)true-regex|false-regex)，这个语法接受一个条件和两个将分别
在这个条件得到满足和没有得到满足时执行的子表达式。
这个语法提供了电话号码问题的解决方案，如下所示；
文本
123 -456-7890
(123)456 -789
(123) -456-7890
(123 -456 ·7890
1234567896
123 456 7898
正则表达式
{p\- {p( -1((1))(c}p())
结果
123-456-7890
(123)456-7898
(123) -456 -7890
(123 -456 -789
1234567890
123 456 7890
分析
从结果看，这个模式解决了间题，但它是如何解决问题的呢？和前
面一样，（\（）?也匹配一个可选的左括号，但我们这次把它用括号括起
来得到了一个子表达式。随后的\d{3}匹配一位数字的区号。（?（1)\)1-）
是一个回测引用条件，它将根据条件是否得到满足而去匹配）或-：如果
---
## Page 104
94
第10章嵌入条件
（1）存在（也就是找到了一个左括号），\）必须被匹配：否则，-必须被
匹配。这样一来，只有配对出现的括号才会被匹配：如果没有使用括号
或括号不配对，电话号码中的区号和其余数字之间的-分隔符必须被
匹配。
?
提示嵌人了条件的模式看上去往往非常复杂，而这往往意味
着调试工作会变得非常困难，如果别无选择，先对整个模式的
各组成部分分别进行调试，再把它们拼装到一起，这通常是一
种比较好的办法。
10.2.2前后查找条件
前后查找条件只在一个向前查找或向后查找操作取得成功的情况下
才允许一个表达式被使用。定义一个前后查找条件的语法与定义一个回
溯引用条件的语法大同小异，只需把回溯引用（括号里的回溯引用编号）
替换为一个完整的前后查找表达式就行了。
注意对前后查我操作的详细讨论见第9章
作为一个例子，请你思考一下怎样匹配美国的邮政编码（简称ZIP编
码）。美国邮政编码有两种格式，一种是12345形式的ZIP格式，另一种是
12345-6789形式的ZIP+4格式。只有ZIP+4格式才必须使用连字符来分隔
前5位和后4位数字。下面是一种解决方法：