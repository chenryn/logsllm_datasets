       +0x1d0 OfsChain         : Ptr32 Void
       +0x1d4 PostBlockList    : _LIST_ENTRY
       +0x1dc TerminationPort  : Ptr32 _TERMINATION_PORT
       +0x1dc ReaperLink       : Ptr32 _ETHREAD
       +0x1dc KeyedWaitValue   : Ptr32 Void
       +0x1e0 ActiveTimerListLock : Uint4B
       +0x1e4 ActiveTimerListHead : _LIST_ENTRY
       +0x1ec Cid              : _CLIENT_ID
       +0x1f4 LpcReplySemaphore : _KSEMAPHORE
       +0x1f4 KeyedWaitSemaphore : _KSEMAPHORE
       +0x208 LpcReplyMessage  : Ptr32 Void
       +0x208 LpcWaitingOnPort : Ptr32 Void
       +0x20c ImpersonationInfo : Ptr32 _PS_IMPERSONATION_INFORMATION
       +0x210 IrpList          : _LIST_ENTRY
       +0x218 TopLevelIrp      : Uint4B
       +0x21c DeviceToVerify   : Ptr32 _DEVICE_OBJECT
       +0x220 ThreadsProcess   : Ptr32 _EPROCESS
       +0x224 StartAddress     : Ptr32 Void
       +0x228 Win32StartAddress : Ptr32 Void
       +0x228 LpcReceivedMessageId : Uint4B
       +0x22c ThreadListEntry  : _LIST_ENTRY
       +0x234 RundownProtect   : _EX_RUNDOWN_REF
       +0x238 ThreadLock       : _EX_PUSH_LOCK
       +0x23c LpcReplyMessageId : Uint4B
       +0x240 ReadClusterSize  : Uint4B
       +0x244 GrantedAccess    : Uint4B
       +0x248 CrossThreadFlags : Uint4B
       +0x248 Terminated       : Pos 0, 1 Bit
       +0x248 DeadThread       : Pos 1, 1 Bit
       +0x248 HideFromDebugger : Pos 2, 1 Bit
       +0x248 ActiveImpersonationInfo : Pos 3, 1 Bit
       +0x248 SystemThread     : Pos 4, 1 Bit
       +0x248 HardErrorsAreDisabled : Pos 5, 1 Bit
       +0x248 BreakOnTermination : Pos 6, 1 Bit
       +0x248 SkipCreationMsg  : Pos 7, 1 Bit
       +0x248 SkipTerminationMsg : Pos 8, 1 Bit
       +0x24c SameThreadPassiveFlags : Uint4B
       +0x24c ActiveExWorker   : Pos 0, 1 Bit
       +0x24c ExWorkerCanWaitUser : Pos 1, 1 Bit
       +0x24c MemoryMaker      : Pos 2, 1 Bit
       +0x250 SameThreadApcFlags : Uint4B
       +0x250 LpcReceivedMsgIdValid : Pos 0, 1 Bit
       +0x250 LpcExitThreadCalled : Pos 1, 1 Bit
       +0x250 AddressSpaceOwner : Pos 2, 1 Bit
       +0x254 ForwardClusterOnly : UChar
       +0x255 DisablePageFaultClustering : UChar
KTHREAD结构为：
    kd> dt _KTHREAD
    nt!_KTHREAD
       +0x000 Header           : _DISPATCHER_HEADER
       +0x010 MutantListHead   : _LIST_ENTRY
       +0x018 InitialStack     : Ptr32 Void
       +0x01c StackLimit       : Ptr32 Void
       +0x020 Teb              : Ptr32 Void
       +0x024 TlsArray         : Ptr32 Void
       +0x028 KernelStack      : Ptr32 Void
       +0x02c DebugActive      : UChar
       +0x02d State            : UChar
       +0x02e Alerted          : [2] UChar
       +0x030 Iopl             : UChar
       +0x031 NpxState         : UChar
       +0x032 Saturation       : Char
       +0x033 Priority         : Char
       +0x034 ApcState         : _KAPC_STATE
       +0x04c ContextSwitches  : Uint4B
       +0x050 IdleSwapBlock    : UChar
       +0x051 Spare0           : [3] UChar
       +0x054 WaitStatus       : Int4B
       +0x058 WaitIrql         : UChar
       +0x059 WaitMode         : Char
       +0x05a WaitNext         : UChar
       +0x05b WaitReason       : UChar
       +0x05c WaitBlockList    : Ptr32 _KWAIT_BLOCK
       +0x060 WaitListEntry    : _LIST_ENTRY
       +0x060 SwapListEntry    : _SINGLE_LIST_ENTRY
       +0x068 WaitTime         : Uint4B
       +0x06c BasePriority     : Char
       +0x06d DecrementCount   : UChar
       +0x06e PriorityDecrement : Char
       +0x06f Quantum          : Char
       +0x070 WaitBlock        : [4] _KWAIT_BLOCK
       +0x0d0 LegoData         : Ptr32 Void
       +0x0d4 KernelApcDisable : Uint4B
       +0x0d8 UserAffinity     : Uint4B
       +0x0dc SystemAffinityActive : UChar
       +0x0dd PowerState       : UChar
       +0x0de NpxIrql          : UChar
       +0x0df InitialNode      : UChar
       +0x0e0 ServiceTable     : Ptr32 Void
       +0x0e4 Queue            : Ptr32 _KQUEUE
       +0x0e8 ApcQueueLock     : Uint4B
       +0x0f0 Timer            : _KTIMER
       +0x118 QueueListEntry   : _LIST_ENTRY
       +0x120 SoftAffinity     : Uint4B
       +0x124 Affinity         : Uint4B
       +0x128 Preempted        : UChar
       +0x129 ProcessReadyQueue : UChar
       +0x12a KernelStackResident : UChar
       +0x12b NextProcessor    : UChar
       +0x12c CallbackStack    : Ptr32 Void
       +0x130 Win32Thread      : Ptr32 Void
       +0x134 TrapFrame        : Ptr32 _KTRAP_FRAME
       +0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE
       +0x140 PreviousMode     : Char
       +0x141 EnableStackSwap  : UChar
       +0x142 LargeStack       : UChar
       +0x143 ResourceIndex    : UChar
       +0x144 KernelTime       : Uint4B
       +0x148 UserTime         : Uint4B
       +0x14c SavedApcState    : _KAPC_STATE
       +0x164 Alertable        : UChar
       +0x165 ApcStateIndex    : UChar
       +0x166 ApcQueueable     : UChar
       +0x167 AutoAlignment    : UChar
       +0x168 StackBase        : Ptr32 Void
       +0x16c SuspendApc       : _KAPC
       +0x19c SuspendSemaphore : _KSEMAPHORE
       +0x1b0 ThreadListEntry  : _LIST_ENTRY
       +0x1b8 FreezeCount      : Char
       +0x1b9 SuspendCount     : Char
       +0x1ba IdealProcessor   : UChar
       +0x1bb DisableBoost     : UChar
0FFDFF124h+140h就是`PreviousMode`,意为先前模式。
保存老的先前模式，因为一段代码如果是0环执行和3环执行是不一样的，记录调用这段代码之前是0环的还是3环的。
    sub     esp, 48h
将esp指向`_Trap_Frame`的起始位置。
    mov    ebx, [esp+68h+arg_0]
    and     ebx, 1
这里arg_0是4
那么就是将esp+6c位置上的值赋给ebx，并与上1。esp+6c位置就是cs的值，主要是为了判断权限的问题，如果是3环来的，cs的值是11，如果是0环来的，cs的值是8。所以与后如果是0，那么就是0环来的，如果是1，那么就是3环来的。
    mov     [esi+140h], bl
esi是KTHREAD，esi+140偏移的地方正好是先前模式，将值赋给先前模式，“新的先前模式”。
    mov     ebp, esp
esp和ebp此时都指向Trap_Frame的首地址。
    mov     ebx, [esi+134h]
esi+134h是KTHREAD+134h偏移又是TrapFrame，这里也可以验证TrapFrame结构体实际上是一个线程一份，因为在KTHREAD这个线程结构体中有一份，而KTHREAD是每个线程一份。
    mov     [ebp+3Ch], ebx
    mov     [esi+134h], ebp
将老的TrapFrame的值存在一个位置上，然后将新的TrapFrame放到esi+134h这个位置。
    mov     ebx, [ebp+60h]
    mov     edi, [ebp+68h]
将原来三环的ebp放到ebx里，将三环eip放到了edi中
    mov     [ebp+0Ch], edx
进0环的时候，edx保存的是参数的地址，这里赋值给TrapFrame+0Ch偏移正好是`DbgArgPointer`。
    mov     [ebp+0], ebx
    mov     [ebp+4], edi
TrapFrame+0h 和TrapFrame+4h分别是DbgEbp和DbgEip。
    test    byte ptr [esi+2Ch], 0FFh
判断是否处于调试状态（DebugActive），如果是处于调试状态，才会把cr0-cr7存到TrapFrame结构体中，如果没处于调试状态就不存cr0-cr7的值。
## 分析KiFastCallEntry(Sysenter)中保存现场的代码
方法和分析KiSystemService差不多，这里就不一句一句分析了，凡是有push的代码，无法解释就注意和TRAP_FRAME结构体对照看。
## SystemServiceTable(系统服务表)
eax存着一个索引号，通过SystemServiceTable可以找到对应的0环函数。
这里有一个容易混淆的地方：误以为SystemServiceTable（SST）就是SSDT表，实际上是完全不一样的两张表，SST的结构为：
而可以看到SSDT是其中一个成员。
>
> 那么又思考：当我们从三环进入0环的时候传递了两个寄存器，一个就是eax，另一个是edx，而edx仅仅是存储了参数的地址，那如何知道参数有多少个呢？并且参数都在三环堆栈中，现在堆栈已经变成esp0，又如何拿到这些参数呢？
为了解决这些问题，我们先上一张关系图。
我们先说参数个数这个问题，参数个数可以从图中看出，哪个函数有多少个参数是写死的，对应的参数个数就写在SST的最后一个成员里（SSPT），这也是张表，存储的是参数个数。如eax==0x02，那么函数地址就为函数地址表的第二个成员，对应的参数在函数参数表的第二个成员。
ServiceLimit是描述函数地址表有多大。
> 从图中可以看出，有两张系统服务表。第一张是用来找内核函数的，第二张是找Win32k.sys驱动函数的。但是索引号只有一份，怎么确定我到底是找哪张表呢？
这里也相当于一个规定，如图所示：
如系统服务号为0x1002，那么12位为1，则应该找第二表的第二个函数。
如果系统服务好为0x0002，那么12位为0，那应该找第一个表的第二个函数。
> 如何才能找到SystemServiceTable？
通过_KTHREAD+0xE0可以找到。
有了SystemServiceTable的前置知识，我们能更好的分析接下来的汇编代码。