secure ASM scheme.
assumption, the above is a
See
the full version of this paper for the proof of this
theorem. Below we describe the two main ingredients of the
proof.
1. We use the “forking lemma” [11, 32] technique in order
to violate the DLP
assumption.
(cid:1)
Unlike the usual forking-lemma-based proofs, however,
we need to use the technique twice, because adversar-
ial players can participate in the forgery output by
the adversary. Thus, we use the forking lemma during
key generation to obtain the secret keys of the adver-
sarial players5, and again when the adversary outputs
a forged signature on (M, S) to compute the discrete
Pi∈S Ii. The secret keys of the adver-
logarithm α of
sarial players in S are then subtracted from α to get
the desired discrete logarithm.
(cid:9)
2. We use rewinding, not commonly used in similar ran-
dom oracle proofs, for reasons explained below.
In ASM schemes, as in single-signer signatures, the ad-
versary is entitled to a chosen message attack. That
is, it can ask for and receive the signature of any mes-
sage M it wants. However, this capability is much
more powerful and dangerous for ASM schemes than
for single-signer signatures.
In the single-signer Schnorr scheme (as in any other
Fiat-Shamir-like scheme in the random oracle model),
during a signature query the adversary can provide the
(single) signer only with a message M . The signer will
then select its own commitment X relative to which
it produces the signature of M (via the challenge e =
H(X, M )). Assume, however, that, in our DLP-based
ASM scheme, adversary F wishes that a good player i
in S to sign a message M as a member of S. Then, F
will ﬁrst receive i’s individual commitment, Xi. Now,
F can give player i a (fake) joint commitment (cid:1)X of its
choice. And it will be relative to this (cid:1)X that player i
will provide its own individual signature, yi, of (M, S).
In previous proofs, for single-signer random-oracle sig-
natures, answering signature queries was easy because
the simulator could imitate the oracle so as to produce
commitments and challenges “simultaneously.” In our
security proof, however, the simulator needs to rewind
the adversary (even though the simulator controls the
random oracle). This is so because the simulator must
commit to Xi before knowing what the challenge e
(which may be based on a previously asked (cid:1)X) will
actually be.
5Note that our deﬁnition does not require adversarial players
to participate in the key generation protocol, or to have any
secret keys at all. Our construction, however, ensures that
they will both participate and know their secret keys: oth-
erwise, their public keys will not be included in the Merkle
tree, and the forgery will not be deemed valid.
252Acknowledgements
The work of the second author was performed, in part, dur-
ing his visit to the MIT Laboratory for Computer science.
The work of the third author was performed at the MIT
Laboratory for Computer Science and was supported by the
National Science Foundation graduate research fellowship
and by a grant from the NTT corporation.
4. REFERENCES
[1] Proceedings of the Twentieth Annual ACM Symposium
on Theory of Computing, Chicago, Illinois, 2–4 May
1988.
[2] E. Bach. How to generate factored random numbers.
SIAM Journal on Computing, 17(2):179–193, Apr.
1988.
[3] M. Bellare and P. Rogaway. Random oracles are
practical: A paradigm for designing eﬃcient protocols.
In Proceedings of the 1st ACM Conference on
Computer and Communication Security, pages 62–73,
November 1993. Revised version appears in
http://www-cse.ucsd.edu/users/mihir/papers/
crypto-papers.html.
[4] M. Ben-Or, S. Goldwasser, and A. Wigderson.
Completeness theorems for non-cryptographic
fault-tolerant distributed computation (extended
abstract). In ACM [1], pages 1–10.
[5] G. Brassard, editor. Advances in
Cryptology—CRYPTO ’89, volume 435 of Lecture
Notes in Computer Science. Springer-Verlag, 1990,
20–24 Aug. 1989.
[6] J. Camenisch and M. Stadler. Eﬃcient group
signature schemes for large groups (extended
abstract). In B. S. Kaliski Jr., editor, Advances in
Cryptology—CRYPTO ’97, volume 1294 of Lecture
Notes in Computer Science, pages 410–424.
Springer-Verlag, 17–21 Aug. 1997.
[7] D. Chaum, C. Cr´epeau, and I. Damg˚ard. Multiparty
unconditionally secure protocols (extended abstract).
In ACM [1], pages 11–19.
[8] D. Chaum and E. van Heyst. Group signatures. In
Davies [9], pages 257–265.
[9] D. W. Davies, editor. Advances in
Cryptology—EUROCRYPT 91, volume 547 of Lecture
Notes in Computer Science. Springer-Verlag,
8–11 Apr. 1991.
[10] Y. Desmedt and Y. Frankel. Threshold cryptosystems.
In Brassard [5], pages 307–315.
[11] U. Feige, A. Fiat, and A. Shamir. Zero-knowledge
proofs of identity. Journal of Cryptology, 1(2):77–94,
1988.
[12] A. Fiat and A. Shamir. How to prove yourself:
Practical solutions to identiﬁcation and signature
problems. In A. M. Odlyzko, editor, Advances in
Cryptology—CRYPTO ’86, volume 263 of Lecture
Notes in Computer Science, pages 186–194.
Springer-Verlag, 1987, 11–15 Aug. 1986.
[13] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin.
Robust and eﬃcient sharing of RSA functions. In
Koblitz [20], pages 157–172.
[14] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin.
Robust threshold DSS signatures. In [23], pp. 354–371.
[15] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin.
Secure distributed key generation for discrete-log
based cryptosystems. In J. Stern, editor, Advances in
Cryptology—EUROCRYPT ’99, volume 1592 of
Lecture Notes in Computer Science, pages 295–310.
Springer-Verlag, 2–6 May 1999.
[16] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game or a completeness theorem for
protocols with honest majority. In Proceedings of the
Nineteenth Annual ACM Symposium on Theory of
Computing, pages 218–229, New York City, 25–27
May 1987.
[17] L. Harn. Group-oriented (t, n) threshold digital
signature scheme and digital multisignature. IEE
Proc.-Comput. Digit. Tech., 141(5), Sept. 1994.
[18] P. Horster, M. Michels, and H. Petersen.
Meta-multisignatures schemes based on the discrete
logarithm problem. In Information Security: The Next
Decade. Proceedings of the IFIP TC11 Eleventh
International Conference on Information Security,
IFIP/Sec ’95, pages 128–141. Chapman & Hall, 1995.
[19] K. Itakura and K. Nakamura. A public-key
cryptosystem suitable for digital multisignatures. NEC
Research & Development, (71):1–8, Oct. 1983.
[20] N. Koblitz, editor. Advances in
Cryptology—CRYPTO ’96, volume 1109 of Lecture
Notes in Computer Science. Springer-Verlag,
18–22 Aug. 1996.
[21] S. K. Langford. Weaknesses in some threshold
cryptosystems. In Koblitz [20], pages 74–82.
[22] C.-M. Li, T. Hwang, and N.-Y. Lee.
Threshold-multisignature schemes where suspected
forgery implies traceability of adversarial shareholders.
In A. De Santis, editor, Advances in
Cryptology—EUROCRYPT 94, volume 950 of Lecture
Notes in Computer Science, pages 194–204.
Springer-Verlag, 1995, 9–12 May 1994.
[23] U. Maurer, editor. Advances in
Cryptology—EUROCRYPT 96, volume 1070 of
Lecture Notes in Computer Science. Springer-Verlag,
12–16 May 1996.
[24] R. C. Merkle. A certiﬁed digital signature. In Brassard
[5], pages 218–238.
[25] S. Micali. CS proofs. SIAM Journal on Computing,
30(4):1253–1298, 2000.
[26] M. Michels and P. Horster. On the risk of disruption
in several multiparty signature schemes. In K. Kim
and T. Matsumoto, editors, Advances in
Cryptology—ASIACRYPT ’96, volume 1163 of Lecture
Notes in Computer Science, pages 334–345, Kyongju,
Korea, 3–7 Nov. 1996. Springer-Verlag.
[27] K. Ohta and T. Okamoto. A digital multisignature
scheme based on the Fiat-Shamir scheme. In H. I. H,
R. Rivest, and T. Matsumoto, editors, Advances in
Cryptology — ASIACRYPT 91, pages 139–148.
Spring-Verlag, 1993, 11–14 Nov. 1991.
[28] K. Ohta and T. Okamoto. On concrete security
treatment of signatures derived from identiﬁcation. In
H. Krawczyk, editor, Advances in
Cryptology—CRYPTO ’98, volume 1462 of Lecture
Notes in Computer Science, pages 354–369.
Springer-Verlag, 23–27 Aug. 1998.
253[29] K. Ohta and T. Okamoto. Multi-signature schemes
secure against active insider attacks. IEICE
Transactions on Fundamentals of Electronics
Communications and Computer Sciences,
E82-A(1):21–31, Jan. 1999.
[30] T. Okamoto. A digital multisignature schema using
bijective public-key cryptosystems. ACM Transatction
on Computer Systems, 6(4):432–441, Nov. 1988.
[31] T. P. Pedersen. A threshold cryptosystem without a
trusted party (extended abstract). In Davies [9], pages
522–526.
[32] D. Pointcheval and J. Stern. Security proofs for
signature schemes. In Maurer [23], pages 387–398.
[33] C.-P. Schnorr. Eﬃcient signature generation by smart
cards. Journal of Cryptology, 4(3):161–174, 1991.
APPENDIX
A. SIMPLIFYING THE ADVERSARY
The adversary F described in Section 2 is extremely pow-
erful. It can corrupt and attack arbitrary parties at arbi-
trary, adaptively determined times. The resulting notion of
security is, therefore, very compelling, but is also diﬃcult
to work with when analyzing a concrete implementation of
(cid:1)
ASM schemes. We will therefore deﬁne a weak adversary F
that operates in a rather simple and easy to analyze manner,
and prove that, despite such simplicity, an ASM scheme is
if and only if it is secure against F . In the
secure against F
sequel, therefore, we shall analyze the security of schemes in
terms of F
rather than F .
(cid:1)
(cid:1)
Unlike F , the weak adversary F
does not have the ability
to corrupt players. In fact, it does not even interact with
a network of players: at the outset (before key generation),
it has to pick one player Pi that it will be attacking. The
other players then cease to exist, and F
has to provide all
the inputs and network traﬃc for Pi. It can also see all the
outputs and network traﬃc coming out of Pi.
(cid:1)
After Pi generates its keys, F
is allowed to carry out
an adaptive chosen-message-and-subgroup attack on Pi, just
like F . The goal of F
is similar to that of F .
(cid:1)
(cid:1)
(cid:1)
Definition 2. An ASM scheme is called weakly secure
if, for all constants c > 0 and all suﬃciently large security
parameters k, no polynomial-time (in k) weak adversary has
−c chance of outputing a triple (σ, M, S) such
better than k
that:
• σ is a valid signature on the message M by the subgroup
• Pi ∈ S,
• Pi has not been asked by F
to execute the signing pro-
S of players
(cid:1)
tocol on M and S.
Because the other players don’t exist, in some sense, they
will now necessarily be “ﬁctitious.”
Note that the weak adversary can also be seen as the
strong adversary that is not allowed to adaptively corrupt
players: rather, it has to pick at the outset the L − 1 play-
ers it will corrupt. This observation leads to the following
theorem, whose proof will appear in the full version of this
work.
Theorem 2. Assume that there exists a polynomial Q
such that for any security parameter k, the size L of G is
bounded by L < Q(k). Then an ASM signature scheme is
weakly secure if and only if it is (strongly) secure.
B. MERKLE TREES
(The following description is taken almost verbatim from
[25].) Recall that a binary tree is a tree in which every
node has at most two children, hereafter called the 0-child
and the 1-child. A collision-free hash function is, informally
speaking, a polynomial-time computable function H map-
ping binary strings of arbitrary length into reasonably short
ones, so that it is computationally infeasible to ﬁnd any col-
lision (for H), that is, any two diﬀerent strings x and y for
which H(x) = H(y).
A Merkle tree [24] then is a binary tree whose nodes store
values, some of which computed by means of a collision-free
hash function H in a special manner. A leaf node can store
any value, but each internal node should store a value that
is the one-way hash of the concatenation of the values in its
children.6 Thus, if the collision-free hash function produces
k-bit outputs, each internal node of a Merkle tree, including
the root, stores a k-bit value. Except for the root value,
each value stored in a node of a Merkle tree is said to be
a 0-value, if it is stored in a node that is the 0-child of its
parent, a 1-value otherwise.
The crucial property of a Merkle tree is that, unless one
succeeds in ﬁnding a collision for H, it is computationally
hard to change any value in the tree (and, in particular, a
value stored in a leaf node) without also changing the root
value. This property allows a party A to “commit” to L
values, v1, . . . , vL (for simplicity assume that L is a power
of 2 and let d = log L), by means of a single k-bit value.
That is, A stores value vi in the i-th leaf of a full binary tree
of depth d, and uses a collision-free hash function H to build
a Merkle tree, thereby obtaining a k-bit value, V , stored in
the root. This root value V “implicitly deﬁnes” what the
L original values were. Assume in fact that, as some point
in time, A gives V , but not the original values, to another
party B. Then, whenever, at a later point in time, A wants
to “prove” to B what the value of, say, vi was, he may just
reveal all L original values to B, so that B can recompute the
Merkle tree and the verify that the newly computed root-
value indeed equals V . More interestingly, A may “prove”
what vi was by revealing just d + 1 (that is, just 1 + log L)
values: vi together with its authenticating path, that is, the
values stored in the siblings of the nodes along the path from
leaf i (included) to the root (excluded), w1, . . . , wd. Party
B veriﬁes the received alleged leaf-value Ii and the received
alleged authenticating path w1, . . . , wd as follows. She sets
u1 = vi and, letting i1, . . . , id be the binary expansion of i,
computes the values u2, . . . , ud as follows: if ij = 0, she sets
uj+1 = H(wjuj); else, she sets uj+1 = H(ujwj). Finally, B
checks whether the computed k-bit value ud equals V .
6I.e., if an internal node has a 0-child storing the value U
and a 1-child storing a value V , then it stores the value
H(U V ).
254