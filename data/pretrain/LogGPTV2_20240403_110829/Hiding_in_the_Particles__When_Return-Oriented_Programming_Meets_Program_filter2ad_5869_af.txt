以下是优化后的参考文献部分，使其更加清晰、连贯和专业：

[42] F. Peng, Z. Deng, X. Zhang, D. Xu, Z. Lin, and Z. Su, "X-Force: Force-executing binary programs for security applications," in *Proceedings of the 23rd USENIX Conference on Security Symposium (SEC '14)*, 2014, pp. 829–844.

[43] X. Ugarte-Pedrero, D. Balzarotti, I. Santos, and P. G. Bringas, "RAMBO: Run-time packer analysis with multiple branch observation," in *Proceedings of the 13th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA '16)*, 2016, pp. 186–206. [Online]. Available: https://doi.org/10.1007/978-3-319-40667-1_10

[44] S. Wang, P. Wang, and D. Wu, "UROBOROS: Instrumenting stripped binaries with static reassembling," in *IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER '16)*, 2016. [Online]. Available: https://doi.org/10.1109/SANER.2016.106

[45] S. Dinesh, N. Burow, D. Xu, and M. Payer, "Retrowrite: Statically instrumenting COTS binaries for fuzzing and sanitization," in *Proceedings of the 2020 IEEE Symposium on Security and Privacy (SP '20)*, 2020. [Online]. Available: https://doi.org/10.1109/SP40000.2020.00007

[46] D. Williams-King, H. Kobayashi, K. Williams-King, G. Patterson, F. Spano, Y. J. Wu, J. Yang, and V. P. Kemerlis, "Egalito: Layout-agnostic binary recompilation," in *Proceedings of the 25th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '20)*, 2020, pp. 133–147. [Online]. Available: https://doi.org/10.1145/3373376.3378470

[47] E. Bauman, Z. Lin, and K. Hamlen, "Superset disassembly: Statically rewriting x86 binaries without heuristics," in *Proceedings of the 25th Annual Network and Distributed System Security Symposium (NDSS '18)*, 2018. [Online]. Available: https://www.ndss-symposium.org/ndss-paper/superset-disassembly-statically-rewriting-x86-binaries-without-heuristics/

[48] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman, *Compilers: Principles, Techniques, and Tools (2nd Edition)*. Addison-Wesley, 2006.

[49] NSA, "Ghidra," https://ghidra-sre.org/, online; accessed June 11, 2020.

[50] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino, A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Krügel, and G. Vigna, "SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis," in *IEEE Symposium on Security and Privacy (SP '16)*, 2016, pp. 138–157. [Online]. Available: https://doi.org/10.1109/SP.2016.17

[51] S. Alvarez, "Radare2," https://rada.re/n/, online; accessed June 11, 2020.

[52] M. Probst, A. Krall, and B. Scholz, "Register liveness analysis for optimizing dynamic binary translation," in *Proceedings of the 9th Working Conference on Reverse Engineering (WCRE '02)*, 2002, pp. 35–44. [Online]. Available: https://doi.org/10.1109/WCRE.2002.1173062

[53] D. C. D'Elia and C. Demetrescu, "On-stack replacement, distilled," in *Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2018)*, New York, NY, USA, 2018, pp. 166–180. [Online]. Available: https://doi.org/10.1145/3192366.3192396

[54] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood, "Pin: Building customized program analysis tools with dynamic instrumentation," in *Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI '05)*, 2005. [Online]. Available: http://doi.acm.org/10.1145/1065010.1065034

[55] C. Collberg, S. Martin, J. Myers, and J. Nagra, "Distributed application tamper detection via continuous software updates," in *Proceedings of the 28th Annual Computer Security Applications Conference (ACSAC '12)*, 2012, pp. 319–328. [Online]. Available: https://doi.org/10.1145/2420950.2420997

[56] D. C. D'Elia, E. Coppa, S. Nicchi, F. Palmaro, and L. Cavallaro, "SoK: Using Dynamic Binary Instrumentation for Security (And How You May Get Caught Red Handed)," in *Proceedings of the 14th ACM ASIA Conference on Computer and Communications Security (ASIACCS '19)*, 2019, pp. 15–27. [Online]. Available: https://doi.org/10.1145/3321705.3329819

[57] Z. L. Nemeth, "Modern binary attacks and defenses in the Windows environment – fighting against Microsoft EMET in seven rounds," in *2015 IEEE 13th International Symposium on Intelligent Systems and Informatics (SISY)*, 2015, pp. 275–280.

[58] L. Davi, A.-R. Sadeghi, D. Lehmann, and F. Monrose, "Stitching the gadgets: On the ineffectiveness of coarse-grained control-flow integrity protection," in *Proceedings of the 23rd USENIX Security Symposium*, 2014, pp. 401–416.

[59] M. Elsabagh, D. Barbara, D. Fleck, and A. Stavrou, "Detecting ROP with statistical learning of program characteristics," in *Proceedings of the Seventh ACM on Conference on Data and Application Security and Privacy (CODASPY '17)*, 2017, pp. 219–226. [Online]. Available: https://doi.org/10.1145/3029806.3029812

[60] P. Larsen, S. Brunthaler, and M. Franz, "Automatic software diversity," *IEEE Security & Privacy*, no. 2, pp. 30–37, 2015. [Online]. Available: https://doi.org/10.1109/MSP.2015.23

[61] F. Biondi, S. Josse, A. Legay, and T. Sirvent, "Effectiveness of synthesis in concolic deobfuscation," *Computers & Security*, vol. 70, pp. 500–515, 2017. [Online]. Available: https://doi.org/10.1016/j.cose.2017.07.006

[62] M. I. Sharif, A. Lanzi, J. T. Griffin, and W. Lee, "Impeding malware analysis using conditional code obfuscation," in *Proceedings of the Network and Distributed System Security Symposium (NDSS '08)*, 2008. [Online]. Available: https://www.ndss-symposium.org/ndss-paper/impeding-malware-analysis-using-conditional-code-obfuscation/

[63] C. S. Collberg and J. Nagra, *Surreptitious Software - Obfuscation, Watermarking, and Tamperproofing for Software Protection*. Addison-Wesley, 2010.

[64] Y. Smaragdakis and G. Balatsouras, "Pointer analysis," *Foundations and Trends in Programming Languages*, vol. 2, no. 1, pp. 1–69, 2015. [Online]. Available: http://dx.doi.org/10.1561/2500000014

[65] G. Balakrishnan, R. Gruian, T. Reps, and T. Teitelbaum, "Codesurfer/x86 - A platform for analyzing x86 executables," in *Proceedings of the 14th International Conference on Compiler Construction (CC '05)*, 2005, pp. 250–254. [Online]. Available: https://doi.org/10.1007/978-3-540-31985-6_19

[66] M. Polychronakis and A. D. Keromytis, "ROP payload detection using speculative code execution," in *2011 6th International Conference on Malicious and Unwanted Software (MALWARE '11)*, 2011, pp. 58–65. [Online]. Available: https://doi.org/10.1109/MALWARE.2011.6112327

[67] H. Ma, K. Lu, X. Ma, H. Zhang, C. Jia, and D. Gao, "Software watermarking using return-oriented programming," in *Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security (ASIACCS '15)*, 2015, pp. 369–380. [Online]. Available: https://doi.org/10.1145/2714576.2714582

[68] K. Lu, S. Xiong, and D. Gao, "RopSteg: Program steganography with return oriented programming," in *Proceedings of the 4th ACM Conference on Data and Application Security and Privacy (CODASPY '14)*, 2014, pp. 265–272. [Online]. Available: https://doi.org/10.1145/2557547.2557572

[69] C. Domas, "M/o/Vfuscator," https://github.com/xoreaxeaxeax, 2015, online; accessed June 11, 2020.

[70] J. Kirsch, C. Jonischkeit, T. Kittel, A. Zarras, and C. Eckert, "Combating control flow linearization," in *Proceedings of the 32nd International Conference on ICT Systems Security and Privacy Protection (IFIP SEC '17)*, vol. 502, Springer, 2017, pp. 385–398. [Online]. Available: https://doi.org/10.1007/978-3-319-58469-0_26

[71] V. Chipounov, V. Kuznetsov, and G. Candea, "S2E: A platform for in-vivo multi-path analysis of software systems," in *Proceedings of the 16th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS XVI)*, 2011, pp. 265–278. [Online]. Available: https://doi.org/10.1145/1950365.1950396

[72] S. Bucur, J. Kinder, and G. Candea, "Prototyping symbolic execution engines for interpreted languages," in *Proceedings of the 19th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS '14)*, 2014, pp. 239–254. [Online]. Available: https://doi.org/10.1145/2541940.2541977

[73] I. Gouy, "The Computer Language Benchmarks Game," https://benchmarksgame-team.pages.debian.net/benchmarksgame/, 2018, online; accessed March 20, 2021.

[74] J. Castaños, D. Edelsohn, K. Ishizaki, P. Nagpurkar, T. Nakatani, T. Ogasawara, and P. Wu, "On the benefits and pitfalls of extending a statically typed language JIT compiler for dynamic scripting languages," in *Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA '12)*, 2012, pp. 195–212. [Online]. Available: https://doi.org/10.1145/2384616.2384631

[75] D. C. D'Elia and C. Demetrescu, "Flexible On-stack Replacement in LLVM," in *Proceedings of the 2016 International Symposium on Code Generation and Optimization (CGO '16)*, 2016, pp. 250–260. [Online]. Available: http://doi.acm.org/10.1145/2854038.2854061

[76] B. Trower, "base64," http://base64.sourceforge.net/b64.c, 2001.

[77] L. Borzacchiello, E. Coppa, D. C. D'Elia, and C. Demetrescu, "Memory models in symbolic execution: key ideas and new thoughts," *Software Testing, Verification and Reliability*, vol. 29, no. 8, 2019. [Online]. Available: https://doi.org/10.1002/stvr.1722

### 附录 A
#### 额外材料
我们报告了重写器实现的实用细节，以及评估中的附加设置和发现。

##### 实现方面
**Switch 表：** 编译器通过间接跳转来高效实现 switch 结构。我们使用控制流图（CFG）重建启发式方法来揭示可能的目标，然后利用原始目标计算序列来进行调度。在重写时，我们在相应位置存储链中对应代码块的 RSP 偏移量，然后在执行过程中使用调度序列计算的地址读取正确的偏移量。因此，在降低 jmp reg 指令时，重写器可以结合 gadget 来实现：
```assembly
movsx reg, byte ptr [reg]
shl reg, 0x3
add rsp, reg
```
其中 reg 包含原始程序的跳转目标地址。最终，在我们的 ROP 编码中，直接跳转与间接跳转的主要区别在于前者从链中检索要添加到 RSP 的偏移量（§IV-B2），而后者从原始代码块的位置检索偏移量。我们根据跳转站点到所需块在链中的位置使用 1 字节、2 字节或 4 字节的偏移量（示例中使用 1 字节值）。

**从原生代码到 ROP 及其反向转换：** 在生成 ROP 链后，重写器将程序中的原始函数实现替换为一个切换堆栈并激活链的存根（§IV-B3）。该切换存根执行三个步骤：
1. 在堆栈切换数组 ss 中保留一个新条目以存储 other_rsp。
2. 将 RSP 保存到 other_rsp。
3. 将要执行的函数链的地址（chain_address）加载到 RSP 并开始链的执行。

一个切换存根可以用 22 字节实现如下：
```assembly
push ss
pop rax
add qword ptr [rax], 0x8
add rax, qword ptr [rax]
mov qword ptr [rax], rsp
push chain_address
pop rsp
ret
```
此代码经过优化，仅使用一个调用者保存寄存器（例如 rax），并使用 push-pop 序列代替 mov 指令，以最小化编码所需的字节数。

当链到达尾声并且需要恢复原生函数时，对称的未切换序列会删除为活动链存储 other_rsp 创建的条目，并将原生堆栈指针恢复到 RSP。实现应实现如下操作：
```assembly
pop r11
sub qword ptr [r11], 0x8
add r11, qword ptr [r11]
add r11, 0x8
mov rsp, qword ptr [r11]
```
注意，只有寄存器 r11 会被此序列覆盖。此外，虽然切换序列由原生指令组成，但上述序列将由 gadget 实现。

**尾部跳转：** 为了处理优化后的尾部跳转实例，重写器使用一种未切换变体，而不是返回到调用函数，而是跳转到尾部跳转的目标：
```assembly
pop r11
sub qword ptr [r11], 0x8
add r11, qword ptr [r11]
add r11, 0x8
pop rax
mov rsp, qword ptr [r11]; jmp rax
```
最后一行代表一个 JOP gadget。

##### 评估补充
**用于混淆抵抗实验的函数：** 为了生成 §VII-B 中 G1 测试的 72 个哈希函数，我们使用了 Tigress 的 RandomFuns 功能，命令行如下：
```bash
tigress --Verbosity=1 --Seed={seed} \
--Environment=x86_64:Linux:Gcc:6.3.0 \
--Transform=RandomFuns \
--RandomFunsName=target \
--RandomFunsTrace=0 \
--RandomFunsType={data_type} \
--RandomFunsInputSize=1 \
--RandomFunsLocalStaticStateSize=1 \
--RandomFunsGlobalStaticStateSize=0 \
--RandomFunsLocalDynamicStateSize=1 \
--RandomFunsGlobalDynamicStateSize=0 \
--RandomFunsBoolSize=3 \
--RandomFunsLoopSize=25 \
--RandomFunsCodeSize=1000 \
--RandomFunsOutputSize=1 \
--RandomFunsControlStructures={control} \
--RandomFunsPointTest=true \
--out={output_file} {base_path}/empty.c
```

### 基准测试
| 基准 | N | ROP0.00 | ROP0.05 |
|------|---|---------|---------|
| B-TREES | 170 | 144 | 583 |
| FANNKUCH | 89 | 104 | 193 |
| FASTA | 256 | 226 | 733 |
| FASTA-REDUX | 263 | 246 | 670 |
| MANDELBROT | 135 | 143 | 323 |
| N-BODY | 288 | 260 | 680 |
| PIDIGITS | 144 | 120 | 462 |
| REGEX-REDUX | 162 | 147 | 522 |
| REV-COMP | 176 | 174 | 558 |
| SP-NORM | 115 | 119 | 329 |
| AVG / GEO. MEAN | 115 | 119 | 179.80 |