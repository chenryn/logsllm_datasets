[42] F. Peng, Z. Deng, X. Zhang, D. Xu, Z. Lin, and Z. Su, “X-Force: Force-
executing binary programs for security applications,” in Proc. of the 23rd
USENIX Conf. on Security Symp., ser. SEC ’14, 2014, pp. 829–844.
[43] X. Ugarte-Pedrero, D. Balzarotti, I. Santos, and P. G. Bringas, “Rambo:
Run-time packer analysis with multiple branch observation,” in Proc.
of
Intrusions and Malware,
and Vulnerability Assessment, ser. DIMVA ’16, 2016, pp. 186–206.
[Online]. Available: https://doi.org/10.1007/978-3-319-40667-1 10
the 13th Int. Conf. on Detection of
[44] S. Wang, P. Wang, and D. Wu, “UROBOROS: instrumenting stripped
binaries with static reassembling,” in IEEE 23rd Int. Conf. on Soft.
Analysis, Evol., and Reengineering, ser. SANER ’16, 2016. [Online].
Available: https://doi.org/10.1109/SANER.2016.106
[45] S. Dinesh, N. Burow, D. Xu, and M. Payer, “Retrowrite: Statically
instrumenting cots binaries for fuzzing and sanitization,” in Proceedings
of the 2020 IEEE Symposium on Security and Privacy, ser. SP ’20, 2020.
[46] D. Williams-King, H. Kobayashi, K. Williams-King, G. Patterson,
F. Spano, Y. J. Wu, J. Yang, and V. P. Kemerlis, “Egalito: Layout-
agnostic binary recompilation,” in Proc. of the 25th Int. Conf. on Arch.
Support for Prog. Lang. and Oper. Sys., ser. ASPLOS ’20, 2020, pp.
133–147. [Online]. Available: https://doi.org/10.1145/3373376.3378470
[47] E. Bauman, Z. Lin, and K. Hamlen, “Superset disassembly: Statically
rewriting x86 binaries without heuristics,” in Proc. of the 25th Annual
Network and Distributed System Security Symp., ser. NDSS ’18, 2018.
[48] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman, Compilers: Principles,
Techniques, and Tools (2nd Edition). Addison-Wesley, 2006.
[49] NSA, “Ghidra,” https://ghidra-sre.org/, online; accessed 11 June 2020.
[50] Y. Shoshitaishvili, R. Wang, C. Salls, N. Stephens, M. Polino,
A. Dutcher, J. Grosen, S. Feng, C. Hauser, C. Kr¨ugel, and G. Vigna,
“SOK: (state of) the art of war: Offensive techniques in binary analysis,”
in IEEE Symposium on Security and Privacy, ser. SP ’16, 2016, pp.
138–157. [Online]. Available: https://doi.org/10.1109/SP.2016.17
[51] S. Alvarez, “Radare2,” https://rada.re/n/, online; accessed 11 June 2020.
[52] M. Probst, A. Krall, and B. Scholz, “Register liveness analysis for
optimizing dynamic binary translation,” in Proc. of the 9th Working
Conf. on Rev. Engin., ser. WCRE ’02, 2002, pp. 35–44. [Online].
Available: https://doi.org/10.1109/WCRE.2002.1173062
[53] D. C. D’Elia and C. Demetrescu, “On-stack replacement, distilled,” in
Proceedings of the 39th ACM SIGPLAN Conference on Programming
Language Design and Implementation, ser. PLDI 2018. New York,
13
NY, USA: Association for Computing Machinery, 2018, pp. 166–180.
[Online]. Available: https://doi.org/10.1145/3192366.3192396
[54] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: Building customized
program analysis tools with dynamic instrumentation,” in Proceedings
of the 2005 ACM SIGPLAN Conference on Programming Language
Design and Implementation, ser. PLDI ’05, 2005. [Online]. Available:
http://doi.acm.org/10.1145/1065010.1065034
[55] C. Collberg, S. Martin,
J. Myers, and J. Nagra, “Distributed
application tamper detection via continuous software updates,” in
Proceedings of
the 28th Annual Computer Security Applications
Conference, ser. ACSAC ’12, 2012, pp. 319–328. [Online]. Available:
https://doi.org/10.1145/2420950.2420997
[56] D. C. D’Elia, E. Coppa, S. Nicchi, F. Palmaro, and L. Cavallaro,
“SoK: Using Dynamic Binary Instrumentation for Security (And
How You May Get Caught Red Handed),” in Proceedings of
the
14th ACM ASIA Conference on Computer and Communications
Security, ser. ASIACCS ’19, 2019, pp. 15–27. [Online]. Available:
https://doi.org/10.1145/3321705.3329819
[57] Z. L. Nemeth, “Modern binary attacks and defences in the Windows
environment – ﬁghting against Microsoft EMET in seven rounds,” in
2015 IEEE 13th International Symposium on Intelligent Systems and
Informatics (SISY), 2015, pp. 275–280.
[58] L. Davi, A.-R. Sadeghi, D. Lehmann, and F. Monrose, “Stitching the
gadgets: On the ineffectiveness of coarse-grained control-ﬂow integrity
protection,” in Proc. of the 23rd USENIX Security Symposium, 2014,
pp. 401–416.
[59] M. Elsabagh, D. Barbara, D. Fleck, and A. Stavrou, “Detecting ROP
with statistical learning of program characteristics,” in Proceedings of
the Seventh ACM on Conference on Data and Application Security and
Privacy, ser. CODASPY ’17, 2017, pp. 219–226. [Online]. Available:
https://doi.org/10.1145/3029806.3029812
[60] P. Larsen, S. Brunthaler, and M. Franz, “Automatic software diversity,”
IEEE Sec. and Priv., no. 2, pp. 30–37, 2015. [Online]. Available:
https://doi.org/10.1109/MSP.2015.23
[61] F. Biondi, S. Josse, A. Legay, and T. Sirvent, “Effectiveness of synthesis
in concolic deobfuscation,” Computers & Security, vol. 70, pp. 500–515,
2017. [Online]. Available: https://doi.org/10.1016/j.cose.2017.07.006
[62] M. I. Sharif, A. Lanzi, J. T. Gifﬁn, and W. Lee, “Impeding malware
analysis using conditional code obfuscation,” in Proc. of the Network
and Distributed System Security Symposium, ser. NDSS ’08, 2008.
[63] C. S. Collberg and J. Nagra, Surreptitious Software - Obfuscation, Wa-
termarking, and Tamperprooﬁng for Software Protection, ser. Addison-
Wesley Software Security Series. Addison-Wesley, 2010.
[64] Y. Smaragdakis and G. Balatsouras, “Pointer analysis,” Found. and
[Online].
Trends in Prog. Lang., vol. 2, no. 1, pp. 1–69, 2015.
Available: http://dx.doi.org/10.1561/2500000014
[65] G. Balakrishnan, R. Gruian, T. Reps, and T. Teitelbaum, “Codesurfer/x86
- A platform for analyzing x86 executables,” in Proceedings of the
14th International Conference on Compiler Construction, ser. CC
’05, 2005, pp. 250–254. [Online]. Available: https://doi.org/10.1007/
978-3-540-31985-6 19
[66] M. Polychronakis and A. D. Keromytis, “ROP payload detection using
speculative code execution,” in 2011 6th International Conference
on Malicious and Unwanted Software, 2011, pp. 58–65. [Online].
Available: https://doi.org/10.1109/MALWARE.2011.6112327
[67] H. Ma, K. Lu, X. Ma, H. Zhang, C. Jia, and D. Gao, “Software
watermarking using return-oriented programming,” in Proceedings of the
10th ACM Symposium on Information, Computer and Communications
Security, ser. ASIACCS ’15. ACM, 2015, pp. 369–380. [Online].
Available: https://doi.org/10.1145/2714576.2714582
[68] K. Lu, S. Xiong, and D. Gao, “RopSteg: Program steganography with
return oriented programming,” in Proc. of the 4th ACM Conf. on Data
and App. Sec. and Priv., ser. CODASPY ’14, 2014, pp. 265–272.
[Online]. Available: https://doi.org/10.1145/2557547.2557572
[69] Christopher Domas, “M/o/Vfuscator,” https://github.com/xoreaxeaxeax,
2015, online; accessed 11 June 2020.
[70] J. Kirsch, C. Jonischkeit, T. Kittel, A. Zarras, and C. Eckert, “Combating
control ﬂow linearization,” in Proceedings of the 32nd international
conference on ICT Systems Security and Privacy Protection, ser. IFIP
SEC ’17, vol. 502. Springer, 2017, pp. 385–398. [Online]. Available:
https://doi.org/10.1007/978-3-319-58469-0 26
[71] V. Chipounov, V. Kuznetsov, and G. Candea, “S2E: A platform for
in-vivo multi-path analysis of software systems,” in Proc. of the 16th
Int. Conf. on Architectural Support for Programming Languages and
Operating Systems, ser. ASPLOS XVI, 2011, pp. 265–278. [Online].
Available: https://doi.org/10.1145/1950365.1950396
[72] S. Bucur, J. Kinder, and G. Candea, “Prototyping symbolic execution
engines for interpreted languages,” in Proc. of
the 19th Int. Conf.
on Architectural Support for Programming Languages and Operating
Systems, ser. ASPLOS ’14, 2014, pp. 239–254. [Online]. Available:
https://doi.org/10.1145/2541940.2541977
[73] I. Gouy, “The Computer Language Benchmarks Game,” https://
benchmarksgame-team.pages.debian.net/benchmarksgame/, 2018, on-
line; accessed 20 March 2021.
[74] J. Castanos, D. Edelsohn, K. Ishizaki, P. Nagpurkar, T. Nakatani,
T. Ogasawara, and P. Wu, “On the beneﬁts and pitfalls of extending a
statically typed language jit compiler for dynamic scripting languages,”
in Proc. of the ACM Int. Conf. on Object Oriented Prog. Systems Lang.
and Applications, ser. OOPSLA ’12, 2012, pp. 195–212. [Online].
Available: https://doi.org/10.1145/2384616.2384631
[75] D. C. D’Elia and C. Demetrescu, “Flexible On-stack Replacement
in LLVM,” in Proceedings of the 2016 International Symposium on
Code Generation and Optimization, ser. CGO ’16, 2016, pp. 250–260.
[Online]. Available: http://doi.acm.org/10.1145/2854038.2854061
[76] B. Trower, “base64,” http://base64.sourceforge.net/b64.c, 2001.
[77] L. Borzacchiello, E. Coppa, D. C. D’Elia, and C. Demetrescu,
“Memory models in symbolic execution: key ideas and new thoughts,”
Soft. Testing, Veriﬁcation and Reliability, vol. 29, no. 8, 2019. [Online].
Available: https://doi.org/10.1002/stvr.1722
APPENDIX A
ADDITIONAL MATERIAL
We report practical details of the rewriter implementation,
and additional settings and ﬁndings from the evaluation.
Implementation Aspects
Switch Tables: As compilers recur to indirect jumps to
efﬁciently implement switch constructs, we use CFG recon-
struction heuristics to reveal possible targets, and then use the
original target calculation sequence used for the dispatching
to our advantage. Instead of jumping to the location corre-
sponding to the desired code block in the original program, at
rewriting time we store at such location the RSP displacement
in the chain for the corresponding code block, then during
execution we use the address computed by the dispatching
sequence to read the correct offset. Thus when lowering, e.g.,
a jmp reg the rewriter can combine gadgets to achieve:
movsx reg, byte ptr [reg]
shl reg, 0x3
add rsp, reg
## offset for RSP
where reg contains the jump target address for the original
program. In the end, the main difference in our ROP encoding
between a direct jump and an indirect jump is that the former
retrieves the offset to add to RSP from the chain (§IV-B2),
while the latter retrieves it from the location of the original
code block. We use offsets of 1, 2, o 4 bytes depending on
the position of the desired block in the chain from the jump
site (the example uses a 1-byte value).
From Native to ROP and Back: Upon generation of a ROP
chain the rewriter replaces the original function implementa-
tion in the program with a stub that switches the stack and
activates the chain (§IV-B3). The pivoting stub performs three
steps: (a) it reserves a new entry for storing other_rsp in
the stack-switching array ss, (b) it saves RSP in other_rsp,
(c) it loads the address of the chain (chain_address) for
the function to execute into RSP and starts the chain execution.
A pivoting stub can be implemented in 22 bytes as:
push ss
pop rax
add qword ptr [rax], 0x8
add rax, qword ptr [rax]
mov qword ptr [rax], rsp
push chain_address
pop rsp
ret
## step (a) ends
## step (b)
## step (c)
This code is optimized to use only a single caller-save register
(e.g., rax) and uses push-pop sequences in place of mov
instructions to minimize the number of bytes required to
encode the sequence.
When a chain reaches its epilogue and a native function has
to be resumed, a symmetric unpivoting sequence takes care of
removing the entry created for storing other_rsp for the
active chain and restores the native stack pointer into RSP.
The implementation should realize e.g.:
pop r11
sub qword ptr [r11], 0x8
add r11, qword ptr [r11]
add r11, 0x8
mov rsp, qword ptr [r11]
## ss
Notice that only register r11 will be clobbered by this
sequence. Also, while the pivoting sequence is made of native
instructions, the sequence above will be realized by gadgets.
Tail Jumps: To handle optimized tail jump instances the
rewriter uses an unpivoting variant that, instead of returning
to the calling function, jumps to the target of the tail jump:
## ss
pop r11
sub qword ptr [r11], 0x8
add r11, qword ptr [r11]
add r11, 0x8
pop rax
mov rsp, qword ptr [r11]; jmp rax
## jmp target
The last line represents a JOP gadget.
Evaluation Additions
Functions for Obfuscation Resilience Experiments: To pro-
duce the 72 hash functions for the G1 tests of §VII-B we used
the RandomFuns feature of Tigress with a command line:
tigress --Verbosity=1 --Seed={seed}
--Environment=x86_64:Linux:Gcc:6.3.0
--Transform=RandomFuns
--RandomFunsName=target
--RandomFunsTrace=0
--RandomFunsType={data_type}
--RandomFunsInputSize=1
--RandomFunsLocalStaticStateSize=1
--RandomFunsGlobalStaticStateSize=0
--RandomFunsLocalDynamicStateSize=1
--RandomFunsGlobalDynamicStateSize=0
--RandomFunsBoolSize=3
--RandomFunsLoopSize=25
--RandomFunsCodeSize=1000
--RandomFunsOutputSize=1
--RandomFunsControlStructures={control}
--RandomFunsPointTest=true
--out={output_file} {base_path}/empty.c
14
BENCHMARK
B-TREES
FANNKUCH
FASTA
FASTA-REDUX
MANDELBROT
N-BODY
PIDIGITS
REGEX-REDUX
REV-COMP
SP-NORM
AVG / GEO. MEAN
N
170
89
256
263
135
288
144
162
176
115
ROP0.00
B
144
104
226
246
143
260
120
147
174
119
A
583
193
733
670
323
680
462
522
558
329
179.80
505.30
168.30
ROP0.05
B