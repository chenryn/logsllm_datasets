boolean_t mach_trap_stack;
#else
mach_munge_t *mach_trap_arg_munge32;
mach_munge_t *mach_trap_arg_munge64;
#endif
#if !MACH_ASSERT
int mach_trap_unused;
#else
const char * mach_trap_name;
#endif
} mach_trap_t;
#define MACH_TRAP_TABLE_COUNT 128
extern mach_trap_t mach_trap_table[];
extern int mach_trap_count;
...
#if !MACH_ASSERT
#define MACH_TRAP(name, arg_count, munge32, munge64) \
{ (arg_count), (int (*)(void)) (name), (munge32), (munge64), 0 }
#else
#define MACH_TRAP(name, arg_count, munge32, munge64) \
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 60 of 137
{ (arg_count), (int (*)(void)) (name), (munge32), (munge64), #name }
#endif
...
The MACH_ASSERT compile-time configuration option controls the ASSERT() and assert() macros
and is used while compiling debug versions of the kernel.
The MACH_TRAP() macro shown in Figure 621 is used to populate the Mach trap table in
osfmk/kern/syscall_sw.cFigure 622 shows how this is done. Mach traps on Mac OS X have
numbers that start from -10, decrease monotonically, and go as high in absolute value as the highest
numbered Mach trap. Numbers 0 tHRough -9 are reserved for Unix system calls and are unused.
Note also that the argument munger functions are the same as those used in BSD system call
processing.
Figure 622. Mach trap table initialization
// osfmk/kern/syscall_sw.c
mach_trap_t mach_trap_table[MACH_TRAP_TABLE_COUNT] = {
MACH_TRAP(kern_invalid, 0, NULL, NULL), /* Unix */ /* 0 */
MACH_TRAP(kern_invalid, 0, NULL, NULL), /* Unix */ /* -1 */
... ... ...
MACH_TRAP(kern_invalid, 0, NULL, NULL), /* Unix */ /* -9 */
MACH_TRAP(kern_invalid, 0, NULL, NULL), /* -10 */
... ...
MACH_TRAP(kern_invalid, 0, NULL, NULL), /* -25 */
MACH_TRAP(mach_reply_port, 0, NULL, NULL), /* -26 */
MACH_TRAP(thread_self_trap, 0, NULL, NULL), /* -27 */
... ...
MACH_TRAP(mach_msg_trap, 7, munge_wwwwwww, munge_ddddddd), /* -31 */
... ...
MACH_TRAP(task_for_pid, 3, munge_www, munge_ddd), /* -46 */
MACH_TRAP(pid_for_task, 2, munge_ww, munge_dd), /* -47 */
... ...
MACH_TRAP(kern_invalid, 0, NULL, NULL), /* -127 */
};
int mach_trap_count = (sizeof(mach_trap_table) / \
sizeof(mach_trap_table[0]));
...
kern_return_t
kern_invalid(void)
{
if (kern_invalid_debug)
Debugger("kern_invalid mach_trap");
return KERN_INVALID_ARGUMENT;
}
...
The assembly stubs for Mach traps are defined in osfmk/mach/syscall_sw.h using the machine-
dependent kernel_trap() macro defined in osfmk/mach/ppc/syscall_sw.h. Table 611
enumerates the key files used in the implementation of these traps.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 61 of 137
Table 611. Implementing Mach Traps in xnu
File Contents
osfmk/kern/syscall_sw.h Declaration of the trap table structure
osfmk/kern/syscall_sw.c Population of the trap table; definitions of default error
functions
osfmk/mach/mach_interface.h Master header file that includes headers for the various Mach
APIsspecifically the kernel RPC functions corresponding to
these APIs (the headers are generated from MIG definition
files)
osfmk/mach/mach_traps.h Prototypes for traps as seen from user space, including
declaration of each trap's argument structure
osfmk/mach/syscall_sw.h Instantiation of traps by defining assembly stubs, using the
machine-dependent kernel_trap() macro (note that some
traps may have different versions for the 32-bit and 64-bit
system libraries, whereas some traps may not be available in
one of the two libraries)
osfmk/mach/ppc/syscall_sw.h PowerPC definitions of the kernel_trap() macro and
associated macros; definitions of other PowerPC-only system
calls
The kernel_trap() macro takes three arguments for a trap: its name, its index in the trap table, and
its argument count.
// osfmk/mach/syscall_sw.h
kernel_trap(mach_reply_port, -26, 0);
kernel_trap(thread_self_trap, -27, 0);
...
kernel_trap(task_for_pid, -45, 3);
kernel_trap(pid_for_task, -46, 2);
...
Let us look at a specific example, say, pid_for_task(), and see how its stub is instantiated.
pid_for_task() attempts to find the BSD process ID for the given Mach task. It takes two
arguments: the port for a task and a pointer to an integer for holding the returned process ID. Figure
623 shows the implementation of this trap.
Figure 623. Setting up the pid_for_task() Mach trap
// osfmk/mach/syscall_sw.h
kernel_trap(pid_for_task, -46, 2);
...
// osfmk/mach/ppc_syscall_sw.h
#include 
#define kernel_trap(trap_name, trap_number, trap_args) \
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 62 of 137
ENTRY(trap_name, TAG_NO_FRAME_USED) @\
li r0, trap_number @\
sc @\
blr
...
// osfmk/ppc/asm.h
// included from 
#define TAG_NO_FRAME_USED 0x00000000
#define EXT(x) _ ## x
#define LEXT(x) _ ## x ## :
#define FALIGN 4
#define MCOUNT
#define Entry(x,tag) .text@.align FALIGN@ .globl EXT(x)@ LEXT(x)
#define ENTRY(x,tag) Entry(x,tag)@MCOUNT
...
// osfmk/mach/mach_traps.h
#ifndef KERNEL
extern kern_return_t pid_for_task(mach_port_name_t t, int *x);
...
#else /* KERNEL */
...
struct pid_for_task_args {
PAD_ARG_(mach_port_name_t, t);
PAD_ARG_(user_addr_t, pid);
};
extern kern_return_t pid_for_task(struct pid_for_task_args *args);
...
// bsd/vm/vm_unix.c
kern_return_t
pid_for_task(struct pid_for_task_args *args)
{
mach_port_name_t t = args->t;
user_addr_t pid_addr = args->pid;
...
}
Using the information shown in Figure 623, the trap definition for pid_for_task() will have the
following assembly stub:
.text
.align 4
.globl _pid_for_task
_pid_for_task:
li r0,-46
sc
blr
Let us test the assembly stub by changing the stub's function name from _pid_for_task to
_my_pid_for_task, placing it in a file called my_pid_for_task.S, and using it in a C program.
Moreover, we can call the regular pid_for_task() to verify the operation of our stub, as shown in
Figure 624.
Figure 624. Testing the pid_for_task() Mach trap
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 63 of 137
// traptest.c
#include 
#include 
#include 
#include 
#include 
#include 
extern kern_return_t my_pid_for_task(mach_port_t, int *);
int
main(void)
{
pid_t pid;
kern_return_t kr;
mach_port_t myTask;
myTask = mach_task_self();
// call the regular trap
kr = pid_for_task(myTask, (int *)&pid);
if (kr != KERN_SUCCESS)
mach_error("pid_for_task:", kr);
else
printf("pid_for_task says %d\n", pid);
// call our version of the trap
kr = my_pid_for_task(myTask, (int *)&pid);
if (kr != KERN_SUCCESS)
mach_error("my_pid_for_task:", kr);
else
printf("my_pid_for_task says %d\n", pid);
exit(0);
}
$ gcc -Wall -o traptest traptest.c my_pid_for_task.S
$ ./traptest
pid_for_task says 20040
my_pid_for_task says 20040
In general, handling of Mach traps follows a similar path in the kernel as BSD system calls. shandler
() identifies Mach traps by virtue of their call numbers being negative. It looks up the trap handler in
mach_trap_table and performs the call.
Mach traps in Mac OS X support up to eight parameters that are passed in GPRs 3 through 10.
Nevertheless, mach_msg_overwrite_TRap() takes nine parameters, but the ninth parameter is not
used in practice. In the trap's processing, a zero is passed as the ninth parameter.
6.7.3. I/O Kit Traps
Trap numbers 100 through 107 in the Mach trap table are reserved for I/O Kit traps. In Mac OS X
10.4, only one I/O Kit trap is implemented (but not used): iokit_user_client_trap()
[iokit/Kernel/IOUserClient.cpp]. The I/O Kit framework (IOKit.framework) implements the
user-space stub for this trap.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 64 of 137
6.7.4. PowerPC-Only System Calls
The Mac OS X kernel maintains yet another system call table called PPCcalls, which contains a few
special PowerPC-only system calls. PPCcalls is defined in osfmk/ppc/PPCcalls.h. Each of its
entries is a pointer to a function that takes one argument (a pointer to a save area) and returns an
integer.
// osfmk/ppc/PPCcalls.h
typedef int (*PPCcallEnt)(struct savearea *save);
#define PPCcall(rout) rout
#define dis (PPCcallEnt)0
PPCcallEnt PPCcalls[] = {
PPCcall(diagCall), // 0x6000
PPCcall(vmm_get_version), // 0x6001
PPCcall(vmm_get_features), // 0x6002
... // ...
PPCcall(dis),
...
};
...
Call numbers for the PowerPC system calls begin at 0x6000 and can go up to 0x6FFFthat is, there can
be at most 4096 such calls. The assembly stubs for these calls are instantiated in
osfmk/mach/ppc/syscall_sw.h.
// osfmk/mach/ppc/syscall_sw.h
#define ppc_trap(trap_name,trap_number) \
ENTRY(trap_name, TAG_NO_FRAME_USED) @\
li r0, trap_number @\
sc @\
blr
...
ppc_trap(diagCall, 0x6000);
ppc_trap(vmm_get_version, 0x6001);
ppc_trap(vmm_get_features, 0x6002);
...
Note that the ppc_trap() macro is similar to the kernel_trap() macro used for defining assembly
stubs for Mach traps. shandler() passes most of these calls to ppscall()
[osfmk/hw_exception.s], which looks up the appropriate handler in the PPCcalls table.
Depending on their purpose, these calls can be categorized as follows:
Calls that are used for low-level performance monitoring, diagnostics, and power management
(Table 612)
Table 612. PowerPC-Only Calls for Performance Monitoring, Diagnostics, and Power Management
Call Number Call Name Purpose
0x6000 diagCall Calls the routines implemented in the kernel's
built-in diagnostics facility (see Section 6.8.8.2)
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 65 of 137
0x6009 CHUDCall Acts as a hook for the Computer Hardware
Understanding Development (CHUD)
interfacedisabled to begin with, but is set to a
private system call callback function when such a
callback is registered by CHUD
0x600A ppcNull Does nothing and simply returns (a null system
call); used for performance testing
0x600B perfmon_control Allows manipulation of the PowerPC
performance-monitoring facility
0x600C ppcNullinst Does nothing but forces various timestamps to be
returned (an instrumented null system call); used
for performance testing
0x600D pmsCntrl Controls the Power Management Stepper
Calls that allow a user program to instantiate and control a virtual machine using the kernel's
virtual machine monitor (VMM) facility (Table 613)
Table 613. PowerPC-Only Calls for the Virtual Machine Monitor
Call Number Call Name Purpose
0x6001 vmm_get_version Retrieves the VMM facility's version
0x6002 vmm_get_features Retrieves the VMM facility's supported features
0x6003 vmm_init_context Initializes a new VMM context
0x6004 vmm_dispatch Used as an indirect system call for dispatching
various VMM system callsis also an ultra-fast trap
(see Section 6.7.5)
0x6008 vmm_stop_vm Stops a running virtual machine
Calls that provide kernel assistance to the Blue Box (Classic) environment (Table 614)
Table 614. PowerPC-Only Calls for the Blue Box
Call Number Call Name Purpose
0x6005 bb_enable_bluebox Enables a thread for use in the Blue Box virtual
machine
0x6006 bb_disable_bluebox Disables a thread for use in the Blue Box virtual
machine
0x6007 bb_settaskenv Sets the Blue Box per-thread task environment
data
6.7.5. Ultra-Fast Traps
Certain traps are handled entirely by the low-level exception handlers in
osfmk/ppc/lowmem_vectors.s, without saving or restoring much (or any) state. Such traps also
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hh16A1.htm 20.08.2007
Chapter 6. The xnu Kernel Page 66 of 137
return from the system call interrupt very rapidly. These are the ultra-fast traps (UFTs). As shown in
Figure 613, these calls have dedicated handlers in the scTable, from where the exception vector at
0xC00 loads them. Table 615 lists the ultra-fast traps.
Table 615. Ultra-Fast Traps
Call Number Association Purpose
0xFFFF_FFFE Blue Box only Determines whether the given Blue Box task is
preemptive, and also loads GPR0 with the
shadowed task environment
(MkIsPreemptiveTaskEnv)