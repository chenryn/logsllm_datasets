uploading it directly to the client browser. Prefetching
requires the installation of a client-side software compo-
Table 6: Security cache hit (broadband). This table shows
the latency improvements gained when the security cache opti-
mization is enabled and the Web page hits in the cache.
nent, and it provides beneﬁts above staged release only
in a narrow set of circumstances (namely, pages that con-
tain very large embedded objects).
To better visualize the impact of staged release, Fig-
ure 4 depicts the sequence of Web object completion
events that occur during the download and rendering of a
page. Figure 4(a) shows completion events for the New
York Times page. The unoptimized SpyProxy (top) does
not transmit or release events to the client browser until
the full page has rendered in the VM. With staged re-
lease (4(a) bottom), as objects are rendered and checked
by the SpyProxy VM, they are released and transmitted
to the client browser and then rendered. Accordingly, the
sequence of completion events is pipelined between the
two browsers. This leads to much more responsive ren-
dering and an overall lower page load time.
Figure 4(b) shows a similar set of events for the MSN
blog page. Since this page consists of few large embed-
ded images, the dominant cost in both the unoptimized
and staged-release-enabled SpyProxy implementations is
the time to transmit the images to the client over broad-
band. Accordingly, though staged release permits the
client browser to begin rendering more quickly, most ob-
jects queue up for transmission over the broadband link
after being released by SpyProxy.
4.3.3 Caching
When a client retrieves a Web page using the opti-
mized SpyProxy, both the outcome of the security check
and the page’s content are cached in the proxy. When
a subsequent request arrives for the same page, if any
of its components are cached and still valid, our system
avoids communicating with the origin Web server. In ad-
dition, if all components of the page are cached and still
valid, the system uses the previous security check results
instead of incurring the cost of a VM-based evaluation.
In Table 6, we show the latency improvement of hit-
ting in the security cache compared with the unoptimized
SpyProxy. As with the other optimizations, the primary
beneﬁt of the security cache is to improve the latency un-
til the page begins rendering. Though the full page load
time improves slightly, the transfer time over the broad-
 Google NY Times MSN blog  render begins render ends render begins render ends render begins render ends unoptimized SpyProxy 0.79s 1.21s 3.37s 7.3s 2.7s 12.4s staged release only 0.64s (-0.15s) 1.13s (-0.08s) 0.92s (-2.45s) 5.2s (-2.1s) 1.3s (-1.4s) 11.3s (-1.1s)   Google NY Times MSN blog  render begins render ends render begins render ends render begins render ends unoptimized SpyProxy 0.79s 1.21s 3.37s 7.3s 2.7s 12.4s security cache hit 0.23s (-0.56s) 0.64s (-0.57s) 0.71s (-2.66s) 4.6s (-2.7s) 0.5s (-2.2s) 10.2s (-2.2s)  Figure 4: Timeline of events with staged release (broadband). The sequence of object rendering completion events that occur
over time for (a) the New York Times, and (b) MSN blog pages. The top ﬁgures show the sequence of events for the unoptimized
SpyProxy, while the bottom ﬁgures show what happens with staged release.
In each ﬁgure, the top series of dots represents
completions in the client browser and the bottom series in SpyProxy’s VM browser. Staged release is effective at the early release
of objects to the browser.
band connection still dominates. However, on a security
cache hit, the caching optimization is extremely effec-
tive, since it eliminates the need to evaluate content in a
VM.
4.4 Performance on a Realistic Workload
Previous sections examined the individual impact of
each of our optimizations. In the end, however, the ques-
tion remains: how does SpyProxy perform for a “typ-
ical” user Web-browsing workload? A more realistic
workload will cause the performance optimizations —
caching, static analysis, and staged release — to be exer-
cised together in response to a stream of requests.
To study the behavior of SpyProxy when confronted
with a realistic request stream, we measured the re-
sponse latencies of 1,909 Web page requests issued by
our broadband Web client. These requests were gener-
ated with a Zipf popularity distribution drawn from a list
of 703 different safe URLs from 124 different sites. We
chose the URLs by selecting a range of popular and un-
popular sites ranked by the Alexa ranking service. By
selecting real sites, we exercised our system with the dif-
ferent varieties and complexities of Web page content to
which users are typically exposed. By generating our
workload with a Zipf popularity distribution, we gave
our caching optimization the opportunity to work in a
realistic scenario. None of the sites we visited contained
attacks; our goal was simply to evaluate the performance
impact of SpyProxy on browsing.
Figure 5(a) presents a cumulative distribution func-
tion for the time to start page rendering in the client
browser. This is the delay the user sees before the
browser responds to a request. Figure 5(b) shows the
CDF for full-page-load latencies. Each ﬁgure depicts
distributions for three cases: (1) directly connecting to
the Web site without SpyProxy, (2) using the optimized
SpyProxy implementation, and (3) using SpyProxy with
optimizations disabled. We ﬂushed all caches before
gathering the data for each distribution.
Figure 5: Overall performance (broadband). These graphs
show the distributions of (a) render start latencies and (b) full
page load latencies for a workload consisting of 1,909 requests
issued to 703 pages from 102 Web sites. Each graph compares
the response time for a direct client, the unoptimized system,
and the fully optimized system. The artifact visible at low la-
tencies on the optimized line in (a) corresponds to hits in our
security cache.
Our results demonstrate that the optimized SpyProxy
system delivers content to browsers very quickly. The
median time until rendering began was 0.8 seconds in
the optimized system compared to 2.4 seconds in the un-
optimized system. There is still room to improve; the
median start time for the direct connection was 0.2 sec-
onds. However, the optimized system feels acceptably
fast to a user. In contrast, the unoptimized system seems
noticeably sluggish compared to the optimized system
and direct connections.
A typical request ﬂowing through the optimized sys-
0200040006000800010000Time (ms)  -- unoptimized SpyProxyclient VM0200040006000800010000Time (ms) -- staged release enabled VMclient020004000600080001000012000Time (ms) -- unoptimized SpyProxy VMclient020004000600080001000012000Time (ms) -- staged release enabled VMclient(a) New York Times(b) MSN Blog025507510025525102515252025252530253525402545255025552560256525702575258025852590259525render start latency (ms)CDFdirectoptimizedunoptimized025507510010011002100310041005100610071008100910010100111001210013100141001510016100171001810019100page load completion latency (ms)CDFdirectoptimizedunoptimized(a)(b)025507510025525102515252025252530253525402545255025552560256525702575258025852590259525render start latency (ms)CDFdirectoptimizedunoptimized025507510010011002100310041005100610071008100910010100111001210013100141001510016100171001810019100page load completion latency (ms)CDFdirectoptimizedunoptimized(a)(b)tem involves several potential sources of overhead, in-
cluding interacting with the Squid proxy cache and pre-
executing content in a virtual machine. In spite of this,
the optimized SpyProxy effectively masks latency, re-
sulting in an interactive, responsive system. In addition,
our system generated very few false positives: only 4 of
the 1,909 Web page requests resulted in an alarm being
raised. Even though the offending pages were benign,
they did in fact attempt to install software on the user’s
computer, albeit by requesting permission from the user
ﬁrst. For example, one of the pages prompted the user
to install a browser plug-in for the QuickTime media
player. We chose not to deal with such opt-in installers,
as SpyProxy is primarily intended for zero-day attacks
that never ask for permission before installing malware.
However, we do reduce the number of false positives by
including the most common browser plug-ins, such as
Flash, in the base VM image.
4.5 Scalability
SpyProxy is designed to service many concurrent
users in an organizational setting. Our implementation
runs on a cluster of workstations, achieving incremen-
tal scalability by executing VM workers on additional
nodes. We now provide some back-of-the-envelope es-
timations of SpyProxy’s scalability. We have not per-
formed an explicit scaling benchmark, but our calcula-
tions do provide an approximate indication of how many
CPUs would be necessary to support user population of
a given size.
Our estimate is based on the assumption that the CPU
is likely to be the bottleneck of a deployed system; for
this to be true, the system must be conﬁgured with an
adequate amount of memory and network bandwidth to
support the required concurrent virtual machines and
Web trafﬁc. While performing the evaluation in sec-
tion 4.4, we measured the amount of CPU time required
to process a Web page in SpyProxy. On a 2.8GHz Pen-
tium 4 machine with 4GB of RAM and a single 80GB
7200 RPM disk, we found the average CPU time con-
sumed per page was 0.35 seconds.
There is little published data on the number of Web
pages users view per day. In a study of Internet content-
delivery systems [38], users requested 930 HTTP ob-
jects per day on average, and another study found that
an average Web page contains about 15 objects [27].
Combining these, we conservatively estimate that a typ-
ical user browses through 100 pages per day. Assuming
this browsing activity is uniformly distributed over an 8-
hour workday, one CPU can process 82286 Web pages
per day, implying a single-CPU SpyProxy could support
approximately 822 users. A single quad-core machine
should be able to handle the load from an organization
containing a few thousand people.
4.6 Summary
This section evaluated the effectiveness and perfor-
mance of our SpyProxy prototype. Our measurements
demonstrated that SpyProxy effectively detects mali-
cious content. In our experiments, SpyProxy correctly
detected and blocked every threat, including several that
SiteAdvisor failed to identify. Our experiments with
fully optimized SpyProxy show that a proxy-based spy-
ware checker can be implemented with only minimal
performance impact on the user. On average, the use
of SpyProxy added only 600 milliseconds to the user-
visible latency before rendering starts. In our experience
using the system, this small additional overhead does not
noticeably degrade the system’s responsiveness.
5 Related Work
We now discuss related research on spyware detection
and prevention, intrusion detection and ﬁrewall systems,
and network proxies.
5.1 Spyware and Malware Detection
In previous work, we used passive network monitor-
ing to measure adware propagation on the University of
Washington campus [37]. In a follow-on study, we used
Web crawling to ﬁnd and analyze executable programs
and Web pages that lead to spyware infections [28]; the
trigger-based VM analysis technique in that work forms
the foundation for SpyProxy’s detection mechanism.
Strider HoneyMonkey [49] and the commercial
SiteAdvisor service [41] both use a VM-based technique
similar to ours to characterize malicious Web sites and
pages. Our work differs in two main ways: we show that
our VM-based technique can be used to build a transpar-
ent defense system rather than a measurement tool, and
we examine optimizations that enable our system to per-
form efﬁciently and in real time.
Our system detects malicious Web content by execut-
ing it and looking for evidence of malicious side-effects.
Other systems have attempted to detect malware by ex-
amining side-effects, including Gatekeeper [51], which
monitors Windows extensibility hooks for evidence of
spyware installation. Another recent detector identiﬁes
spyware by monitoring API calls invoked when sensi-
tive information is stolen and transmitted [20]. However,
these systems only look for malware that is already in-
stalled. In contrast, SpyProxy uses behavioral analysis
to prevent malware installation.
Other works have looked at addressing limitations
of signature-based detection. Semantics-aware malware
detection [8] uses an instruction-level analysis of pro-
grams to match their behavior against signature tem-
plates. This technique improves malware detection, but
not prevention. Several projects explore automatic gen-
eration of signatures for detection of unknown malware
variants [7, 29, 40, 46, 48]. These typically need at-
tack trafﬁc and time to generate signatures, leaving some
clients vulnerable when a new threat ﬁrst appears.
Some commercial client-side security tools have be-
gun to incorporate behavioral techniques, and two re-
cent products, Prevx1 [32] and Primary Response Safe-
Connect [35], use purely behavioral detection. How-
ever, these tools must run on systems packed with client-
installed programs, which limits their behavioral analy-
sis. In contrast, SpyProxy pre-executes content in a clean
sandbox, where it can apply a much stricter set of behav-
ioral rules.
Other approaches prevent Web-based malware infes-
tations by protecting the user’s system from the Web
browser using VM isolation [10], OS-level sandbox-
ing [16, 36], or logging/rollback [17]. Fundamentally,
this containment approach is orthogonal to our preven-
tion approach. Although these tools provide strong isola-
tion, they have different challenges, such as data sharing
and client-side performance overhead.
Remote playgrounds move some of the browser func-
tionality (namely, execution of untrusted Java applets)
away from the client desktop and onto dedicated ma-
chines [26]; the client browser becomes an I/O termi-
nal to the actual browser running elsewhere. Our archi-
tecture is different — SpyProxy pre-executes Web pages
using an unmodiﬁed browser and handles any form of
active code, allowing it to capture a wider range of at-
tacks. Nevertheless, SpyProxy could beneﬁt from this
technique in the future, for example by forwarding user
input to the VM worker in AJAX sites.
Several projects tackle the detection and prevention
of other classes of malware, including worms, viruses,
and rootkits [19, 39, 50]. SpyProxy complements these
defenses with protection against Web-borne attacks, re-
sulting in better overall desktop security.
5.2 Intrusion Detection and Firewalls
Intrusion detection systems (e.g., Bro [31] and
snort [42]) protect networks from attack by searching
through incoming packets for known attack signatures.
These systems are typically passive, monitoring trafﬁc as
it ﬂows into a network and alerting a system administra-
tor when an attack is suspected. More sophisticated in-
trusion detection systems attempt to identify suspicious
trafﬁc using anomaly detection [3, 4, 22, 23]. A related
approach uses protocol-level analysis to look for attacks
that exploit speciﬁc vulnerabilities, such as Shield [47].
The same idea has been applied at the HTML level in
client-side ﬁrewalls and proxies [25, 30, 33].
These systems typically look for attack signatures for
well-established protocols and services. As a result, they
cannot detect new or otherwise undiscovered attacks.
Since they are traditionally run in a passive manner, at-
tacks are detected but not prevented. Our system exe-
cutes potentially malicious content in a sandboxed envi-
ronment, using observed side-effects rather than signa-
tures to detect attacks and protect clients.
Shadow honeypots combine network intrusion detec-
tion systems and honeypots [2]. They route risky net-
work trafﬁc to a heavily instrumented version of a vulner-
able application, which detects certain types of attacks at
run-time. In contrast, SpyProxy does not need to instru-
ment the Web browser that it guards, and its run-time
checks are more general and easier to deﬁne.
5.3 Proxies
Proxies have been used to introduce new services be-
tween Web clients and servers. For example, they have
been used to provide scalable distillation services for mo-
bile clients [14], Web caching [1, 13, 15, 21, 52, 53], and
gateway services for onion-routing anonymizers [11].
SpyProxy builds on these advantages, combining active
content checking with standard proxy caching. Spy-