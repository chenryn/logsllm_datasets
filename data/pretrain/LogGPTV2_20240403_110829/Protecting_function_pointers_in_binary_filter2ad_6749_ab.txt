avoid conﬂicting with bytes in the application.
3.4 Encoding Legal Targets
Valid jump targets should be encoded to distinguish from
invalid targets. According to our observation, legal jump tar-
gets fall into the following categories:
(A) Hard-coded function pointers in the executable ﬁle,
such as those stored in the vtables and global variables.
(B) Entries in the import table.
(C) Function pointers generated at runtime by API, such
as GetProcAddress().
(D) Function pointers generated by setjmp().
For function pointers of kind (A), they are simply encoded
into a trampoline chunk pointer, as shown in Figure 1(e).
Considering the performance, hard-coded pointers which
are directly used in call/jmp instructions, e.g., call foo,
would not be encoded. Exception handlers used by the op-
erating system are skipped encoding too. Moreover, code en-
tries in switch tables [5] are not encoded. All these skipped
pointers are protected by SafeSEH [12] or DEP, and cannot
be tampered by attackers, and thus can be skipped safely.
The remaining cases B-D involve pointers from external
modules, even un-encoded pointers, and thus cause compati-
bility issues. Unlike existing protections (e.g., CFI), FPGate
can handle these issues with the extra trampoline layer.
3.5 Trampoline & Compatibility
FPWriter encodes each valid jump target into a pointer
to a chunk in the trampoline. Each of these chunks holds
a same ID and has 16 bytes. These chunks are continuous
and can pass the validations instrumented before indirect
jumps. As Figure 1(e) shows, the chunk will jump back to
the original target to ensure applications behave correctly.
In the case of (B), function pointers are imported from
external modules and will be updated when loading. As
shown in Figure 3(a), a wrapper section (.wrap) is intro-
duced to simulate the original IAT (Import Address Table,
.iat). Whereas the IAT stores imported function pointers,
the wrapper section stores pointers to trampoline chunks.
Then, all references to the IAT are replaced with references
to the wrapper section. Similarly, directly used imported
function pointers, such as call [imp_slot], are skipped en-
coding too in order to promote the performance.
For function pointers of kind (C), they are retrieved through
API GetProcAddress, so they need be encoded at runtime.
GetProcAddress is usually imported, and thus it can be pro-
cessed in a same way as (B), except that the trampoline
chunk for GetProcAddress does not jump back to original
imported GetProcAddress directly. In fact, it jumps to a
wrapper function for GetProcAddress (i.e. gpa_wraper), as
shown in Figure 3(b). The wrapper function will call original
GetProcAddress, and then stores the runtime retrieved func-
tion pointer into a preserved trampoline slot. And then the
pointer to the preserved slot is returned as the new return
value. As a result, the runtime retrieved function pointer is
also encoded. It is worth noting that, the wrapper function
has to set the preserved trampoline slots writable at runtime
and turn it oﬀ when the wrapper function exits, in order to
protect the preserved trampoline slots from tampering.
Function pointers of kind (D) are generated at runtime as
well. The function setjmp retrieves its caller’s (un-encoded)
return address from the stack and saves it into a jmp_buf
structure. Finally, this return address will be used by an
indirect jump instruction in another API longjmp through
querying the jmp_buf structure. We then replace each call
instruction which invokes setjmp with two instructions: PUSH
ret_addr; JMP setjmp;. The pushed return address ret_addr
is a trampoline slot pointer, and it will jump back to the
original return address, as shown in Figure 3(c).
As discussed above, the trampoline provides a demilita-
rized zone between hardened modules and un-hardened ones,
and thus can help overcome the compatibility issues. This
novel method can also be utilized and applied to other bi-
nary protection schemes, such as [21].
.iat:
imp_slot:  imp_foo
 mov ecx,[imp_slot]
Original
 call ecx
Hardened
.iat:
imp_slot:  imp_foo
.wrap:
imp_wrap:  wrap_foo
mov ecx,[imp_wrap]
 call ecx
.trampoline:
wrap_foo:
jmp [imp_slot]
6 dup (0xCC)
dd ID
.iat:
imp_slot:  imp_gpa
 mov ecx,[imp_slot]
 call ecx
.iat:
imp_slot:  imp_gpa
.wrap:
imp_wrap:  wrap_gpa
mov ecx,[imp_wrap]
 call ecx
.wrap_code:
gpa_wraper:
call [imp_gpa]
# fill new stub
# ret stub ptr
.trampoline:
wrap_gpa:
jmp gpa_wraper
6 dup (0xCC)
dd ID
 call setjmp
next:
longjmp():
 jmp [edx+14h]
push wrap_next
 jmp setjmp
next:
longjmp():
 jmp [edx+14h]
.trampoline:
wrap_next:
jmp next
7 dup (0xCC)
dd ID
(a) Imported function pointers
(b) Pointers retrieved through GPA()
(c) Pointers saved through setjmp()
Figure 3: Special function pointers and FPGate’s encoding countermeasures
4. EVALUATION
We implement a prototype of FPGate using C++ for the
Windows platform targeting x86 PE executables. BitCover
takes about 5K LOC and utilizes the Udis86 library (8K
LOC, [18]) to parse x86 instructions, while FPWriter takes
another 5K LOC and a custom PE ﬁle parser has 2K LOC.
We port PointGuard, EncodePointer and CFI discussed
in Section 2 using binary rewriting, and then evaluate and
compare their compatibility and performance with FPGate.
4.1 Correctness of FPGate
FPWriter encodes function pointers and instruments run-
time checks before indirect call/jmp instructions in the ex-
ecutable. If there is an error in this rewriting process, the
ﬁnal hardened application will fail or crash at runtime. For
example, if a function pointer fails to be identiﬁed by Bit-
Cover, then it will not be encoded by FPWriter, and ﬁnally
cannot pass the instrumented runtime check.
Two groups of experiments are made to evaluate FPGate’s
correctness. First, FPGate is tested with 11 applications
from the SPECint2006 benchmark [9]. Second, FPGate is
tested with two real world browsers, Firefox 3.6.16 (FF3)
and Internet Explorer 6 (IE6)1. In particular, the core mod-
ules xul.dll in FF3 and mshtml.dll in IE6 are hardened
by FPGate, and other modules are left intact. These exper-
iments show that hardened applications work correctly; i.e.,
they are semantically equivalent to original applications.
4.2 Compatibility Comparison
In this section, we discuss the compatibility of FPGate,
and make a comparison with the other three protection schemes,
i.e. PointGuard, EncodePointer and CFI-fp (a limited ver-
sion of original CFI which protects only function pointers).
4.2.1 Compatible with Binary Applications
FPGate can be applied directly on binaries containing re-
location tables, even without source-level information. For
(seldom) binaries without relocation tables, FPGate work
ﬁne with the help of other tools or experts. For example,
1Core modules of newer IE cannot be replaced with custom
modules because of the system protection. In addition, there
are no public available exploits for newer browsers. As a
result, we chose these two old softwares as a benchmark.
the commercial disassembler IDA Pro [10] can be easily uti-
lized to generate a fake relocation table and help FPGate to
be applied on these binaries.
On the other hand, original implementations of Point-
Guard and EncodePointer depend on source code, while the
CFI-fp depends on debug information. However, in our port-
ing, they are all ported successfully using binary rewriting.
4.2.2 Compatible with Un-hardened Modules
Function pointers may ﬂow from hardened modules to un-
hardened modules and vice-versa, and thus cause compati-
bility issues. With countermeasures presented in Section 3.5,
modules hardened by FPGate can work seamlessly with un-
hardened modules. The previous section which evaluates cor-
rectness of FPGate also proves this compatibility.
But for other three schemes, the compatibility issue is crit-
ical. Special eﬀorts are need to ﬁx this issue when porting.
In the case of PointGuard and EncodePointer, encoded
function pointers are not valid pointers, i.e. they cannot be
used directly in any un-hardened module. When porting, the
binary has to be rewritten in such a way that each function
pointer is decoded before it ﬂows into external modules. For
each speciﬁc application, lots of manual eﬀorts are needed
to identify and ﬁx such pointer ﬂows between modules.
On the other hand, function pointers from un-hardened
modules may fail the runtime checks of the hardened mod-
ules. For imported function pointers, a bootstrap code chunk
is inserted to encode them. For pointers retrieved by GetP-
rocAddress, similar wrappers as FPGate are provided too.
For setjmp and other cases, it is also handled like FPGate.
In the case of CFI-fp, compatibility issues occur when
computed jump targets fall into un-hardened modules. In
our porting, the error handler is set to be empty and will
redirect the control ﬂow to its original position.
In summary, FPGate has a good compatibility. Point-
Guard or EncodePointer needs a lot of manual eﬀort to
achieve a good compatibility. Compatibility issues of the
original CFI implementation are hard to be ﬁxed unless an-
other layer (like the trampoline in FPGate) is introduced.
4.3 Performance Comparison
The performance experiments are made on a Windows
7 32-bit system, with an Intel Core2 CPU of 3.00GHz. The
 PointGuard
 FPGate
 CFI
7.4%
7.2%
7.0%
3.0%
2.5%
2.0%
1.5%
1.0%
0.5%
0
-0.5%
d
a
e
h
r
e
v
O
e
c
m
a
r
o
f
r
e
P
p erlb e n c h
b zip 2
g c c
m cf
m k
g o b
m
h
er
m
sje n g
h 2 6 4ref
o
m
n etp p
a star
A v era g e
Figure 4: Overheads of PointGuard, FPGate and CFI-fp.
scripts in SPECint2006 are used to evaluate the original and
hardened versions of applications’ performance. And the av-
erage performance overheads are computed based on 9 trials.
Runtime overhead.
Figure 4 shows the performance overheads caused by FP-
Gate, PointGuard and CFI-fp. The average/maximum over-
head is about 0.11%/1% for PointGuard, about 0.42%/1.03%
for FPGate, and about 1.53%/7.23% for CFI-fp. For most
applications, the overhead brought by PointGuard is small-
est, while that brought by CFI-fp is largest.
In addition, EncodePointer’s performance is quite poor.
Its average/maximum overhead is about 92%/750%, not shown
in this ﬁgure due to the space limitation.
Statistics.
The upper half of Table 1 lists the count of modiﬁcations
made by FPGate to the SPECint2006 applications, and the
lower half for other real world applications.
More speciﬁcally, the columns under Encoded pointers in
the table represent the count of pointers encoded by FPGate,
including hard-coded function pointers, imported function
pointers, pointers returned by GetProcAddress and pointers
generated by setjmp functions.
The column under Checks records the count of indirect
call/jmp instructions which are instrumented by FPGate,
while the ﬁnal column (i.e. the column under Opt.) collects
the count of function pointers those are skipped encoding.
Performance Analysis.
PointGuard is fastest because it only needs one XOR in-
Table 1: Modiﬁcations made by FPGate to applications
#fp
Encoded pointers
Checks
#imp #GPA#setjmp #indirect
call/jmp
Opt.
#skipped
fp/import
1
0