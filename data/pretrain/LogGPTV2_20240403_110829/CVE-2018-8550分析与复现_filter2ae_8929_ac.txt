        shmBlock->_fReadWrite = 0;
      }
      else
      {
        shmBlock = 0;
      }
      shmBlockRef = shmBlock;
      // that->CSharedMemoryBlockObj(+0x4)偏移量 = shmBlock;
      that->CSharedMemoryBlockObj = shmBlock;
      if ( shmBlock )
      {
        if ( fUnmarshal )
        {
          hrTemp = CSharedMemoryBlock::InitUnMarshal(shmBlock, hMem, dwProcessId, 0x3FF8u);
          goto LABEL_13;
        }
    LABEL_20:
        hrTemp = CSharedMemoryBlock::Init(shmBlockRef, 0, 0x3FFFF8u, 0x3FF8u, 0, 0, 1);
    LABEL_13:
        sc = hrTemp;
        if ( hrTemp CSharedMemoryBlockObj = 0;
          return sc;
        }
        that->_cbSize = shmBlockRef->_culCommitSize - 8;
        // pMalloca的pbBase就是NtCurrentTeb()->ReservedForOle->pvThreadBase(0x0偏移量)值相等,shmBlockRef->_pbBase也就是共享内存分配的基址,其中pMalloca=CPerContext
        that->_pbBase = shmBlockRef->_pbBase + 8;
       .....
    }
    int __thiscall CSharedMemoryBlock::InitUnMarshal(CSharedMemoryBlock *this, void *hMem, unsigned int dwProcessId, unsigned int culCommitSize)
    {
      CSharedMemoryBlock *that; // esi
      int v5; // ebx
      signed int v6; // eax
      HANDLE v8; // eax
      int v9; // eax
      char *shareMemoryOffset; // eax
      int v11; // eax
      HANDLE hProcess; // [esp+18h] [ebp+Ch]
      that = this;
      v5 = 0;
      hProcess = OpenProcess(0x40u, 0, dwProcessId);
      if ( hProcess )
      {
        v8 = GetCurrentProcess();
        // &that->_hMem=0x偏移量
        if ( DuplicateHandle(hProcess, hMem, v8, &that->_hMem, 0, 0, 2u) )
        {
          shareMemoryOffset = (char *)MapViewOfFileEx(that->_hMem, 6u, 0, 0, 0, 0);
          // //pMalloca->_pbBase = shmBlockRef->_pbBase + 8; 其中的pMalloca->pbBase就是NtCurrentTeb()->ReservedForOle->pvThreadBase(0x0偏移量)值相等,shmBlockRef->_pbBase= that->_pbBase也就是共享内存分配的基址
          that->_pbBase = shareMemoryOffset;
    .....
    }
在windbg验证结论,共享内存CPerContext的地址为0617a350,可见它继承与CSmAllocator,它的CPerContext->CSharedMemoryBlockObj(+0x4)也就是CSharedMemoryBlock地址为060def40,CSharedMemoryBlock->_pbBase地址为03e40000,同时可以看到ReservedForOle指针指向的地址为03e40008,验证了结论.
    0:018> dt ntdll!_TEB ReservedForOle @$teb 
       +0xf80 ReservedForOle : 0x031a9e98 Void
    0:018> dc 0x031a9e98
    031a9e98  03e40008 0617a350 00000000 00001002  ....P...........
    031a9ea8  0000000c 02f86f80 00000000 00000000  .....o..........
    031a9eb8  00000001 03112648 0506e850 00000000  ....H&..P.......
    031a9ec8  00000000 00002f4c 03109f80 03109f80  ....L/..........
    031a9ed8  00000000 00000000 0000013c 00000000  ........ dps 0x031a9e98
    //ReservedForOle指针指向的地址=CSharedMemoryBlock->_pbBase+8
    031a9e98  03e40008
    //CPerContext的地址
    031a9e9c  0617a350
    031a9ea0  00000000
    031a9ea4  00001002
    031a9ea8  0000000c
    031a9eac  02f86f80
    ...
    //CPerContext的地址为0617a350
    0:018> dps  0617a350
    0617a350  750c11a8 coml2!CSmAllocator::`vftable'
    //CPerContext->_psmb也就是CSharedMemoryBlock地址
    0617a354  060def40
    //NtCurrentTeb()->ReservedForOle赋值成CPerContext->_pbBase
    0617a358  03e40008
    ....
    //CSharedMemoryBlock地址
    0:018> dps 060def40
    060def40  000010b8
    //CSharedMemoryBlock->_pbBase地址
    060def44  03e40000
    ...
设置好共享内存后会进入UnmarshalContext,其中先从SDfMarshalPacket->CBasedGlobalContextObj中通过CContextList::_Find找第一个CGlobalContext,其实CGlobalContext继承于CContextList结构,会根据CContextList->pctxNext找下一个CContextList直到CContextList->ctxid为要找的进程id为止.之后会验证下CPerContext句柄是否有效,其实只要构造一个名为”SessionsBaseNamedObjectsOleDfRoot%X%08lX”的内核Event通过NtCreateEvent,Bits服务的Sessions为0,详见poc代码.
    SDfMarshalPacket *__userpurge UnmarshalContext@(CPerContext **a1@, SDfMarshalPacket *pckfrom@, struct SDfMarshalPacket *pvkOrg, struct CPerContext **a4, unsigned int a5, int a6, int a7)
    {
      SDfMarshalPacket *pck; // edi
      CGlobalContext *pCGlobalContextOffset; // ecx
      CGlobalContext *pCGlobalContext; // esi
      unsigned int NowPid; // eax
      CPerContext *pCPerContextFound; // eax
      CContext *pContext; // ebx
      struct _GUID v13; // ST04_16
      struct CPerContext **v14; // ecx
      CPerContext *v15; // eax
      CSmAllocator *v17; // eax
      unsigned int NowPidNext; // eax
      int CBasedGlobalFileStreamBaseObjOffset; // edx
      CGlobalFileStream *pCBasedGlobalFileStreamBase; // ecx
      int v21; // eax
      char *v22; // edx
      int v23; // esi
      CGlobalFileStream *fstmFromGlobal; // ecx
      SDfMarshalPacket *v25; // eax
      char *v26; // edx
      CGlobalFileStream *v27; // ecx
      SDfMarshalPacket *v28; // eax
      struct ILockBytes *v29; // edi
      struct CFileStream *v30; // ebx
      struct ILockBytes *v31; // esi
      unsigned int v32; // edx
      void **v33; // [esp+0h] [ebp-44h]
      void **v34; // [esp+0h] [ebp-44h]
      void **v35; // [esp+0h] [ebp-44h]
      struct IMalloc *v36; // [esp+4h] [ebp-40h]
      unsigned int v37; // [esp+4h] [ebp-40h]
      unsigned int *v38; // [esp+4h] [ebp-40h]
      CPerContext **v39; // [esp+10h] [ebp-34h]
      CPerContext *v40; // [esp+14h] [ebp-30h]
      int v41; // [esp+18h] [ebp-2Ch]
      unsigned int v42; // [esp+1Ch] [ebp-28h]
      BOOL pCPerContextFoundRef; // [esp+20h] [ebp-24h]
      CGlobalContext *pCGlobalContextRef; // [esp+24h] [ebp-20h]
      struct CFileStream *v45; // [esp+28h] [ebp-1Ch]
      struct ILockBytes *ppvRet; // [esp+2Ch] [ebp-18h]
      struct ILockBytes *v47; // [esp+30h] [ebp-14h]
      struct CFileStream *v48; // [esp+34h] [ebp-10h]
      struct ILockBytes *v49; // [esp+38h] [ebp-Ch]
      SDfMarshalPacket *pckRef; // [esp+3Ch] [ebp-8h]
      v39 = a1;
      v42 = 0;
      pck = pckfrom;
      v41 = 0;
      pckRef = pckfrom;
      ppvRet = 0;
      v48 = 0;
      pCGlobalContextOffset = pckfrom->CBasedGlobalContextObj;
      v45 = 0;
      v49 = 0;
      v47 = 0;
      v40 = 0;
      if ( pCGlobalContextOffset )
      {
        pCGlobalContext = (pCGlobalContextOffset + *NtCurrentTeb()->ReservedForOle);
        v41 = ppvRet;
        v48 = v45;
        v49 = v47;
      }
      else
      {
        pCGlobalContext = 0;
      }
      pCGlobalContextRef = pCGlobalContext;
      NowPid = GetCurrentProcessId();
      // 找第一个PerContext
      pCPerContextFound = CContextList::_Find(&pCGlobalContext->CContextListbase, NowPid);
      pContext = &pCPerContextFound->baseclass_CContext;
      pCPerContextFoundRef = !pCPerContextFound
                          // 先验证下找到的PerContext必须成功
                          || (pContext = (CPerContext::IsHandleValid(pCPerContextFound) != 0 ? pCPerContextFound : 0)) == 0;
      // 如果不是当前进程检查CProcessSecret,不相符也没关系
      if ( GetCurrentProcessId() != pck->ProcessContextId )
      {
        *&v13.Data1 = *&pck->cntxkey.Data1;
        *v13.Data4 = *pck->cntxkey.Data4;
        if ( CProcessSecret::VerifyMatchingSecret(v13) CContextListbase, NowPidNext);
        if ( !pContext )
        {
          pckRef = 0x800300FD;
          goto LABEL_23;
        }
        CBasedGlobalFileStreamBaseObjOffset = pck->CBasedGlobalFileStreamBaseObj;
        if ( CBasedGlobalFileStreamBaseObjOffset )
        {
          pCBasedGlobalFileStreamBase = (CBasedGlobalFileStreamBaseObjOffset + *NtCurrentTeb()->ReservedForOle);
          v49 = v47;
        }
        else
        {
          pCBasedGlobalFileStreamBase = 0;
        }
        // 进入关键步骤
        hr = CFileStream::Unmarshal(&ppvRet, pCBasedGlobalFileStreamBase, pCBasedGlobalFileStreamBase, v33, v36);
       ....
    }
    struct CContext *__thiscall CContextList::_Find(CContextList *this, unsigned int pid)
    {
      CContext *HeadCtx; // eax
      char *HeadCtxFoundRet; // edx
      CContext *v4; // ecx
      CContext *HeadCtxlookup; // ecx
      CContext *v6; // ecx
      CContext *HeadCtxFound; // ecx
      HeadCtx = this->_pctxHead;
      HeadCtxFoundRet = 0;
      while ( 1 )
      {
        v4 = HeadCtx ? (HeadCtx + *NtCurrentTeb()->ReservedForOle) : 0;
        if ( !v4 )
          break;
        HeadCtxlookup = HeadCtx ? (HeadCtx + *NtCurrentTeb()->ReservedForOle) : 0;
        if ( HeadCtxlookup->ctxid )
        {
          v6 = HeadCtx ? (HeadCtx + *NtCurrentTeb()->ReservedForOle) : 0;
          if ( v6->ctxid == pid )
            break;
        }
        if ( HeadCtx )
          HeadCtxFound = (HeadCtx + *NtCurrentTeb()->ReservedForOle);