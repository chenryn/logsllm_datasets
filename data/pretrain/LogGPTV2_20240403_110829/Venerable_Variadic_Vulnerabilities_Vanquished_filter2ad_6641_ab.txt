controlled area and fall back to a regular format string
exploit.
3 Threat model
Programs frequently use variadic functions, either in the
program itself or as part of a shared library (e.g., printf
in the C standard library). We assume that the program
contains an arbitrary memory corruption, allowing the
adversary to modify the arguments to a variadic function
and/or the target of an indirect function call, targeting a
variadic function.
Our target system deploys existing defense mecha-
nisms like DEP, ASLR, and a strong implementation of
CFI, protecting the program against code injection and
control-ﬂow hijacking. We assume that the adversary
cannot modify the metadata of our runtime monitor. Pro-
tecting metadata is an orthogonal engineering problem
and can be solved through, e.g., masking (and-ing every
memory access), segmentation (for x86-32), protecting
the memory region [9], or randomizing the location of
sensitive data. Our threat model is a realistic scenario for
current attacks and defenses.
4 HexVASAN design
HexVASAN monitors calls to variadic functions and
checks for type violations. Since the semantics of how
arguments should be interpreted by the function are in-
trinsic in the logic of the function itself, it is, in general,
impossible to determine the number and type of argu-
ments a certain variadic function accepts. For this rea-
son, HexVASAN instruments the code generated by the
compiler so that a check is performed at runtime. This
check ensures that the arguments consumed by the vari-
adic function match those passed by the caller.
The high level idea is the following: HexVASAN
records metadata about the supplied argument types at
the call site and veriﬁes that the extracted arguments
match in the callee. The number of arguments and their
types is always known at the call site and can be encoded
efﬁciently. In the callee this information can then be used
to verify individual arguments when they are accessed.
To implement such a sanitizer, we must design a meta-
data store, a pass that instruments call sites, a pass that
instruments callers, and a runtime library that manages
the metadata store and performs the run-time type veriﬁ-
cation. Our runtime library aborts the program whenever
a mismatch is detected and generates detailed informa-
tion about the call site and the mismatched arguments.
186    26th USENIX Security Symposium
USENIX Association
source1.c
source2.cpp
source3.c
C frontend
C++ frontend
C frontend
IR
IR
IR
HexVASAN
instrumentation
HexVASAN
instrumentation
HexVASAN
instrumentation
IR
Compile
IR
Compile
IR
Compile
Object ﬁle
Object ﬁle
Object ﬁle
Link
hexvasan.a
output.elf
Figure 1: Overview of the HexVASAN compilation
pipeline. The HexVASAN instrumentation runs right
after the C/C++ frontend, while its runtime library,
hexvasan.a, is merged into the ﬁnal executable at link
time.
4.1 Analysis and Instrumentation
We designed HexVASAN as a compiler pass to be run
in the compilation pipeline right after the C/C++ fron-
tend. The instrumentation collects a set of statically
available information about the call sites, encodes it in
the LLVM module, and injects calls to our runtime to
perform checks during program execution.
Figure 1 provides an overview of the compilation
pipeline when HexVASAN is enabled. Source ﬁles are
ﬁrst parsed by the C/C++ frontend which generates the in-
termediate representation on which our instrumentation
runs. The normal compilation then proceeds, generating
instrumented object ﬁles. These object ﬁles, along with
the HexVASAN runtime library, are then passed to the
linker, which creates the instrumented program binary.
4.2 Runtime support
The HexVASAN runtime augments every va_list in the
original program with the type information generated by
our instrumentation pass, and uses this type information
to perform run-time type checking on any variadic argu-
ment accessed through va_arg. By managing the type in-
formation in a metadata store, and by maintaining a map-
ping between va_lists and their associated type infor-
mation, HexVASAN remains fully compatible with the
platform ABI. This design also supports interfacing be-
tween instrumented programs and non-instrumented li-
braries.
The HexVASAN runtime manages the type informa-
tion in two data structures. The core data structure, called
the variadic list map (VLM), associates va_list struc-
tures with the type information produced by our instru-
mentation, and with a counter to track the index of the
last argument that was read from the list. A second data
structure, the variadic call stack (VCS), allows callers of
variadic functions to store type information of variadic
arguments until the callee initializes the va_list.
Each variadic call site is instrumented with a call to
pre call, that prepares the information about the call
site (a variadic call site descriptor or VCSD), and a
call to post call, that cleans it up. For each vari-
adic function, the va start calls are instrumented with
list init, while va copy, whose purpose is to clone a
va list, is instrumented through list copy. The two
run-time functions will allocate the necessary data struc-
tures to validate individual arguments. Calls to va end
are instrumented through list end to free up the corre-
sponding data structures.
Algorithm 1 summarizes the two phases of our anal-
ysis and instrumentation pass. The ﬁrst phase identiﬁes
all the calls to variadic functions (both direct and indi-
rect). Note that identifying indirect calls to variadic func-
tions is straight-forward in a compiler framework since,
even if the target function is not statically known, its type
is. Then, all the parameters passed by that speciﬁc call
*/
*/
input: a module m
/* Phase 1
foreach function f in module m do
foreach variadic call c with n arguments in f do
vcsd.count ← n;
foreach argument a of type t do
vcsd.args.push(t);
end
emit call to pre call(vcsd) before c;
emit call to post call() after c;
end
end
/* Phase 2
foreach function f in module m do
foreach call c to va start(list) do
emit call to list init(&list) after c;
end
foreach call c to va copy(dst,src) do
emit call to list copy(&dst,&src) after c;
end
foreach call c to va end(list) do
emit call to list free(&list) after c;
end
foreach call c to va arg(list,type) do
emit call to check arg(&list,type) before c;
end
end
Algorithm 1: The instrumentation process.
USENIX Association
26th USENIX Security Symposium    187
site are inspected and recorded, along with their type in
a dedicated VCSD which is stored in read-only global
data. At this point, a call to pre call is injected before
the variadic function call (with the newly created VCSD
as a parameter) and, symmetrically, a call to post call
is inserted after the call site.
The second phase identiﬁes all calls to va start and
va copy, and consequently, the va list variables in the
program. Uses of each va list variable are inspected in
an architecture-speciﬁc way. Once all uses are identiﬁed,
we inject a call to check arg before dereferencing the
argument (which always resides in memory).
4.3 Challenges and Discussion
When designing a variadic function call sanitizer, several
issues have to be considered. We highlight details about
the key challenges we encountered.
Multiple va lists.
Functions are allowed to create
multiple va_lists to access the same variadic arguments,
either through va_start or va_copy operations. Hex-
VASAN handles this by storing a VLM entry for each
individual va_list.
Passing va_lists as function arguments. While un-
common, variadic functions are allowed to pass the
va_lists they create as arguments to non-variadic func-
tions. This allows non-variadic functions to access vari-
adic arguments of functions higher in the call stack. Our
design takes this into account by maintaining a list map
(VLM) and by instrumenting all va_arg operations, re-
gardless of whether or not they are in a variadic function.
Multi-threading support. Multiple threads are sup-
ported by storing our per-thread runtime state in a thread-
local variable as supported on major operating systems.
Metadata format. We use a constant data structure per
variadic call site, the VCSD, to hold the number of ar-
guments and a pointer to an array of integers identifying
their type. The check arg function therefore only per-
forms two memory accesses, the ﬁrst to load the number
of arguments and the second for the type of the argument
currently being checked.
To uniquely identify the data types with an integer, we
decided to build a hashing function (described in Algo-
rithm 2) using a set of ﬁxed identiﬁers for primitive data
types and hashing them in different ways depending on
how they are aggregated (pointers, union, or struct).
The last hash acts as a terminator marker for aggre-
gate types, which allows us to, e.g., distinguish between
{struct{ int }, int} and {struct {struct{ int,
int }}}. Note that an (unlikely) hash collision only re-
sults in two different types being accepted as equal. Such
a hashing mechanism has the advantage of being deter-
ministic across compilation units, removing the need for
input : a type t and an initial hash value h
output: the ﬁnal hash value h
h = hash(h, typeID(t));
switch typeID(t) do
case AggregateType
/* union, struct and pointer
foreach c in componentTypes(t) do
h = hashType(c, h);
*/
case FunctionType
h = hashType(returnType(t), h);
foreach a in argTypes(t) do
h = hashType(a, h);
end
end
end
endsw
h = hash(h, typeID(t));
return h
Algorithm 2: Algorithm describing the type hashing
function hashType. typeID returns an unique identiﬁer
for each basic type (e.g., 32-bit integer, double), type
of aggregate type (e.g., struct, union...) and functions.
hash is a simple hashing function combining two inte-
gers. componentTypes returns the components of an ag-
gregate type, returnType the return type of a function
prototype and argTypes the type of its arguments.
keeping a global map of type-unique id pairs. Due to
the information loss during the translation from C/C++
to LLVM IR, our type system does not distinguish be-
tween signed and unsigned types. The required meta-
data is static and immutable and we mark it as read-only,
protecting it from modiﬁcation. However, the VCS still
needs to be protected through other mechanisms.
Handling ﬂoating point arguments.
In x86-64 ABI,
ﬂoating point and non-ﬂoating point arguments are han-
dled differently.
In case of ﬂoating point arguments,
the ﬁrst eight arguments are passed in the ﬂoating point
registers whereas in case of non-ﬂoating point the ﬁrst
six are passed in general-purpose registers. HexVASAN
handles both argument types.
Support for aggregate data types.
According to
AMD64 System V ABI, the caller unpacks the ﬁelds of
the aggregate data types (structs and unions) if the argu-
ments ﬁt into registers. This makes it hard to distinguish
between composite types and regular types – if unpacked
they are indistinguishable on the callee side from argu-
ments of these types. HexVASAN supports aggregate
data types even if the caller unpacks them.
Attacks preserving number and type of arguments.
Our mechanism prevents attacks that change the num-
ber of arguments or the types of individual arguments.
188    26th USENIX Security Symposium
USENIX Association
Format string attacks that only change one modiﬁer can
therefore be detected through the type mismatch even if
the total number of arguments remains unchanged.
Non-variadic calls to variadic functions. Consider the
following code snippet:
typedef void (*non_variadic)(int, int);
void variadic(int, ...) { /* ... */ }
int main() {
non_variadic function_ptr = variadic;
function_ptr(1, 2);
}
In this case, the function call in main to function_ptr
appears to the compiler as a non-variadic function call,
since the type of the function pointer is not variadic.
Therefore, our pass will not instrument the call site, lead-
ing to potential errors.
To handle such (rare) situations appropriately, we
would have to instrument all non-variadic call sites too,
leading to an unjustiﬁed overhead. Moreover, the code
above represents undeﬁned behavior in C [27, 6.3.2.3p8]
and C++ [26, 5.2.10p6], and might not work on certain ar-
chitectures where the calling convention for variadic and
non-variadic function calls are not compatible. The GNU
C compiler emits a warning when a function pointer is
cast to a different type, therefore we require the devel-
oper to correct the code before applying HexVASAN.
Central management of the global state. To allow the
HexVASAN runtime to be linked into the base system li-
braries, such as the C standard library, we made it a static
library. Turning the runtime into a shared library is pos-
sible, but would prohibit its use during the early process
initialization – until the dynamic linker has processed all
of the necessary relocations. Our runtime therefore ei-
ther needs to be added solely to the C standard library
(so that it is initialized early in the startup process) or
the runtime library must carefully use weak symbols to
ensure that each symbol is only deﬁned once if multiple
libraries are compiled with our countermeasure.
C++ exceptions and longjmp.
If an exception is raised
while executing a variadic function (or one of its callees),
the variadic function may not get a chance to clean up the
metadata for any va_lists it has initialized, nor may the
caller of this variadic function get the chance to clean up
the type information it has pushed onto the VCS. Other
functions manipulating the thread’s stack directly, such
as longjmp, present similar issues.
C++ exceptions can be handled by modifying the
LLVM C++ frontend (i.e., clang) to inject an object
with a lifetime spanning from immediately before a vari-
adic function call to immediately after. Such an object
would call pre_call in its constructor and post_call in
the destructor, leveraging the exception handling mech-
anism to make HexVASAN exception-safe. Functions
like longjmp can be instrumented to purge the portions
of HexVASAN’s data structures that correspond to the
discarded stack area. We did not observe any such calls
in practice and leave the implementation of handling ex-
ceptions and longjump across variadic functions as future
engineering work.
5
Implementation
We implemented HexVASAN as a sanitizer for the
LLVM compiler framework [31], version 3.9.1. We
have chosen LLVM for its robust features on analyzing
and transforming arbitrary programs as well as extract-
ing reliable type information. The sanitizer can be en-
abled from the C/C++ frontend (clang) by providing the
-fsanitize=vasan parameter at compile-time. No an-
notations or other source code changes are required for
HexVASAN. Our sanitizer does not require visibility of
whole source code (see Section 4.3), but works on indi-
vidual compilation units. Therefore link-time optimiza-
tion (LTO) is not required and thus ﬁts readily into exist-
ing build systems. In addition, HexVASAN also supports
signal handlers.
HexVASAN consists of two components: a static in-
strumentation pass and a runtime library. The static in-
strumentation pass works on LLVM IR, adding the nec-
essary instrumentation code to all variadic functions and
their callees. The support library is statically linked to
the program and, at run-time, checks the number and
type of variadic arguments as they are used by the pro-
gram. In the following we describe the two components
in detail.
Static instrumentation.
The implementation of the
static instrumentation pass follows the description in
Section 4. We ﬁrst iterate through all functions, looking
for CallInst instructions targeting a variadic function
(either directly or indirectly), then we inspect them and
create for each one of them a read-only GlobalVariable
of type vcsd t. As shown in Listing 2, vcsd t is com-
posed by an unsigned integer representing the number
of arguments of the considered call site and a pointer to
an array (another GlobalVariable) with an integer el-
ement for each argument of type t. type t is an inte-
ger uniquely identifying a data type obtained using the
hashType function presented in Algorithm 2. At this
point a call to pre call is injected before the call site,
with the newly create VCSD as a parameter, and a call to
post call is injected after the call site.
During the second phase, we ﬁrst identify all va_start,
va_copy, and va_end operations in the program. In the IR