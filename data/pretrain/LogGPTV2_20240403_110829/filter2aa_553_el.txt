Pet: QUINCY             Kind: PIG
Nerfville Pet Club Membership Program
Enter the letter corresponding to your choice:
a) add a pet        l) show list of pets
n) number of pets     f) find pets
q) quit
q
Bye.
17.7.5 树的思想
二叉查找树也有一些缺陷。例如，二叉查找树只有在满员（或平衡）时
效率最高。假设要储存用户随机输入的单词。该树的外观应如图17.12所
示。现在，假设用户按字母顺序输入数据，那么每个新节点应该被添加到右
边，该树的外观应如图17.16所示。图17.12所示是平衡的树，图17.16所示是
不平衡的树。查找这种树并不比查找链表要快。
避免串状树的方法之一是在创建树时多加注意。如果树或子树的一边或
另一边太不平衡，就需要重新排列节点使之恢复平衡。与此类似，可能在进
1442
行删除操作后要重新排列树。俄国数学家Adel’son-Vel’skii和Landis发明了一
种算法来解决这个问题。根据他们的算法创建的树称为AVL树。因为要重
构，所以创建一个平衡的树所花费的时间更多，但是这样的树可以确保最大
化搜索效率。
你可能需要一个能储存相同项的二叉查找树。例如，在分析一些文本
时，统计某个单词在文本中出现的次数。一种方法是把 Item 定义成包含一
个单词和一个数字的结构。第一次遇到一个单词时，将其添加到树中，并且
该单词的数量加 
1。下一次遇到同样的单词时，程序找到包含该单词的节
点，并递增表示该单词数量的值。把基本二叉查找树修改成具有这一特性，
不费多少工夫。
考虑Nerfville宠物俱乐部的示例，有另一种情况。示例中的树根据宠物
的名字和种类进行排列，所以，可以把名为Sam的猫储存在一个节点中，把
名为Sam的狗储存在另一节点中，把名为Sam的山羊储存在第3个节点中。但
是，不能储存两只名为Sam的猫。另一种方法是以名字来排序，但是这样做
只能储存一个名为Sam的宠物。还需要把Item定义成多个结构，而不是一个
结构。第一次出现Sally时，程序创建一个新的节点，并创建一个新的列
表，然后把Sally及其种类添加到列表中。下一次出现Sally时，程序将定位
到之前储存Sally的节点，并把新的数据添加到结构列表中。
提示 插件库
读者可能意识到实现一个像链表或树这样的ADT比较困难，很容易犯
错。插件库提供了一种可选的方法：让其他人来完成这些工作和测试。在学
完本章这两个相对简单的例子后，读者应该能很好地理解和认识这样的库。
1443
图17.16 不平衡的二叉查找树
1444
17.8 其他说明
本书中，我们涵盖了C语言的基本特性，但是只是简要介绍了库。ANSI
C库中包含多种有用的函数。绝大部分实现都针对特定的系统提供扩展库。
基于Windows的编译器支持Windows图形接口。Macintosh C编译器提供访问
Macintosh 工具箱的函数，以便编写具有标准 Macintosh 接口或 iOS 系统的程
序产品，如iPhone或iPad。与此类似，还有一些工具用于创建Linux程序的图
形接口。花时间查看你的系统提供什么。如果没有你想要的工具，就自己编
写函数。这是C的一部分。如果认为自己能编写一个更好的（如，输入函
数），那就去做！随着你不断练习并提高自己的编程技术，会从一名新手成
为经验丰富的资深程序员。
如果对链表、队列和树的相关概念感兴趣或觉得很有用，可以阅读其他
相关的书籍，学习高级编程技巧。计算机科学家在开发和分析算法以及如何
表示数据方面投入了大量的时间和精力。也许你会发现已经有人开发了你正
需要的工具。
学会C语言后，你可能想研究C++、Objectiv 
C或Java。这些都是以C为
基础的面向对象（object-oriented）语言。C已经涵盖了从简单的char类型变
量到大型且复杂的结构在内的数据对象。面向对象语言更进一步发展了对象
的观点。例如，对象的性质不仅包括它所储存的信息类型，而且还包括了对
其进行的操作类型。本章介绍的ADT就遵循了这种模式。而且，对象可以继
承其他对象的属性。OOP提供比C更高级的抽象，很适合编写大型程序。
请参阅附录B中的参考资料I“补充阅读”中找到你感兴趣的书籍。
1445
17.9 关键概念
一种数据类型通过以下几点来表征：如何构建数据、如何储存数据、有
哪些可能的操作。抽象数据类型（ADT）以抽象的方式指定构成某种类型特
征的属性和操作。从概念上看，可以分两步把ADT翻译成一种特定的编程语
言。第1步是定义编程接口。在C中，通过使用头文件定义类型名，并提供
与允许的操作相应的函数原型来实现。第2步是实现接口。在C中，可以用
源代码文件提供与函数原型相应的函数定义来实现。
1446
17.10 本章小结
链表、队列和二叉树是ADT在计算机程序设计中常用的示例。通常用动
态内存分配和链式结构来实现它们，但有时用数组来实现会更好。
当使用一种特定类型（如队列或树）进行编程时，要根据类型接口来编
写程序。这样，在修改或改进实现时就不用更改使用接口的那些程序。
1447
17.11 复习题
1.定义一种数据类型涉及哪些内容？
2.为什么程序清单17.2 只能沿一个方向遍历链表？如何修改struct film定
义才能沿两个方向遍历链表？
3.什么是ADT？
4.QueueIsEmpty()函数接受一个指向queue结构的指针作为参数，但是也
可以将其编写成接受一个queue结构作为参数。这两种方式各有什么优缺
点？
5.栈（stack）是链表系列的另一种数据形式。在栈中，只能在链表的一
端添加和删除项，项被“压入”栈和“弹出”栈。因此，栈是一种LIFO（即后进
先出last in,first out）结构。
a.设计一个栈ADT
b.为栈设计一个C编程接口，例如stack.h头文件
6.在一个含有3个项的分类列表中，判断一个特定项是否在该列表中，
用顺序查找和二叉查找方法分别需要最多多少次？当列表中有1023个项时分
别是多少次？65535个项是分别是多少次？
7.假设一个程序用本章介绍的算法构造了一个储存单词的二叉查找树。
假设根据下面所列的顺序输入
单词，请画出每种情况的树：
a.nice food roam dodge gate office wave
b.wave roam office nice gate food dodge
c.food dodge roam wave office gate nice
1448
d.nice roam office food wave gate dodge
8.考虑复习题7构造的二叉树，根据本章的算法，删除单词food之后，
各树是什么样子？
1449
17.12 编程练习
1.修改程序清单17.2，让该程序既能正序也能逆序显示电影列表。一种
方法是修改链表的定义，可以双向遍历链表。另一种方法是用递归。
2.假设list.h（程序清单17.3）使用下面的list定义：
typedef struct list
{
Node * head;  /* 指向list的开头 */
Node * end;/* 指向list的末尾 */
} List;
重写 
list.c（程序清单 
17.5）中的函数以适应新的定义，并通过
films.c（程序清单 17.4）测试最终的代码。
3.假设list.h（程序清单17.3）使用下面的list定义：
#define MAXSIZE 100
typedef struct list
{
Item entries[MAXSIZE]; /* 内含项的数组 */
int items;       /* list中的项数 */
} List;
重写 
list.c（程序清单 
17.5）中的函数以适应新的定义，并通过
films.c（程序清单 17.4）测试最终的代码。
1450
4.重写mall.c（程序清单17.7），用两个队列模拟两个摊位。
5.编写一个程序，提示用户输入一个字符串。然后该程序把该字符串的
字符逐个压入一个栈（参见复习题5），然后从栈中弹出这些字符，并显示
它们。结果显示为该字符串的逆序。
6.编写一个函数接受 3 个参数：一个数组名（内含已排序的整数）、该
数组的元素个数和待查找的整数。如果待查找的整数在数组中，那么该函数
返回 1；如果该数不在数组中，该函数则返回 0。用二分查找法实现。
7.编写一个程序，打开和读取一个文本文件，并统计文件中每个单词出
现的次数。用改进的二叉查找树储存单词及其出现的次数。程序在读入文件
后，会提供一个有3个选项的菜单。第1个选项是列出所有的单词和出现的次
数。第2个选项是让用户输入一个单词，程序报告该单词在文件中出现的次
数。第3个选项是退出。
8.修改宠物俱乐部程序，把所有同名的宠物都储存在同一个节点中。当
用户选择查找宠物时，程序应询问用户该宠物的名字，然后列出该名字的所
有宠物（及其种类）。
1451
附录A 复习题答案
A.1 第1章复习题答案
1.完美的可移植程序是，其源代码无需修改就能在不同计算机系统中成
功编译的程序。
2.源代码文件包含程序员使用的任何编程语言编写的代码。目标代码文
件包含机器语言代码，它不必是完整的程序代码。可执行文件包含组成可执
行程序的完整机器语言代码。
3.（1）定义程序目标；（2）设计程序；（3）编写程序；（4）编译程
序；（5）运行程序；（6）测试和调试程序；（7）维护和修改程序。
4.编译器把源代码（如，用C语言编写的代码）翻译成等价的机器语言
代码（也叫作目标代码）。
5.链接器把编译器翻译好的源代码以及库代码和启动代码组合起来，生
成一个可执行程序。
A.2 第2章复习题答案
1.它们都叫作函数。
2.语法错误违反了组成语句或程序的规则。这是一个有语法错误的英文
例子：Me 
speak 
English 
good.。这是一个有语法错误的C语言例子：
printf"Where are the parentheses?";。
3.语义错误是指含义错误。这是一个有语义错误的英文例子：This
sentence isexcellent Czech.[1]。这是一个有语义错误的C语言例子： thrice_n =
3 + n;[2]。
4.第1行：以一个#开始；studio.h应改成stdio.h；然后用一对尖括号把
1452
stdio.h括起来。
第2行：把{}改成()；注释末尾把/*改成*/。
第3行：把(改成｛
第4行：int s末尾加上一个分号。
第5行没问题。
第6行：把:=改成，赋值用=，而不是用:=（这说明Indiana 
Sloth了解
Pascal）。另外，用于赋值的值56也不对，一年有52周，不是56周。
第7行应该是：printf("There are %d weeks in a year.\n", s);
第9行：原程序中没有第9行，应该在该行加上一个右花括号｝。
修改后的程序如下：
#include 
int main(void) /* this prints the number of weeks in a year */
{
int s;
s = 52;
printf("There are %d weeks in a year.\n", s);
return 0;
}
5.a.Baa Baa Black Sheep.Have you any wool?（注意，Sheep.和Have之间
没有空格）
1453
b.Begone!
O creature of lard!
c.What?
No/nfish?
（注意斜杠/和反斜杠\的效果不同，/只是一个普通的字符，原样打印）
d.2 + 2 = 4
（注意，每个%d与列表中的值相对应。还要注意，+的意思是加法，可
以在printf()语句内部计算）
6.关键字是int和char（main是一个函数名；function是函数的意思；=是
一个运算符）。
7.printf("There were %d words and %d lines.\n", words, lines);
8.执行完第7行后，a是5，b是2。执行完第8行后，a和b都是5。执行完
第9行后，a和b仍然是5（注意，a不会是2，因为在执行a = b;时，b的值已经
被改为5）。
9.执行完第7行后，x是10，b是5。执行完第8行后，x是10，y是15。执
行完第9行后，x是150，y是15。
A.3 第3章复习题答案
1.a.int类型，也可以是short类型或unsigned 
short类型。人口数是一个整
数。
b.float类型，价格通常不是一个整数（也可以使用double类型，但实际
上不需要那么高的精度）。
c.char类型。
1454
d.int类型，也可以是unsigned类型。
2.原因之一：在系统中要表示的数超过了int可表示的范围，这时要使用
long类型。原因之二：如果要处理更大的值，那么使用一种在所有系统上都
保证至少是 32 位的类型，可提高程序的可移植性。
3.如果要正好获得32位的整数，可以使用int32_t类型。要获得可储存至
少32位整数的最小类型，可以使用int_least32_t类型。如果要为32位整数提
供最快的计算速度，可以选择int_fast32_t类型（假设你的系统已定义了上述
类型）。
4.a.char类型常量（但是储存为int类型）
b.int类型常量
c.double类型常量
d.unsigned int类型常量，十六进制格式
e.double类型常量
5.第1行：应该是#include 
第2行：应该是int main(void)
第3行：把(改为｛
第4行：g和h之间的;改成,
第5行：没问题
第6行：没问题
第7行：虽然这数字比较大，但在e前面应至少有一个数字，如1e21或
1.0e21都可以。
1455
第8行：没问题，至少没有语法问题。
第9行：把)改成}
除此之外，还缺少一些内容。首先，没有给rate变量赋值；其次未使用h
变量；而且程序不会报告计算结果。虽然这些错误不会影响程序的运行（编
译器可能给出变量未被使用的警告），但是它们确实与程序设计的初衷不符
合。另外，在该程序的末尾应该有一个return语句。
下面是一个正确的版本，仅供参考：
#include 
int main(void)
{
float g, h;
float tax, rate;
rate = 0.08;