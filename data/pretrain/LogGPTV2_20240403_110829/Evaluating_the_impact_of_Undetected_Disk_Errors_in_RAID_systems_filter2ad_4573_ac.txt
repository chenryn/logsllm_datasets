three operating modes (illustrated in Figure 3), and allowing
the simulator to dynamically switch between modes to maxi-
mize efﬁciency while maintaining accuracy in estimating the
rate of undetected data corruption served to the user. The ﬁrst
operating mode, which is purely analytical, is also the sim-
plest. It takes the parameters of the system model, workload
model, and the rates entered for the various UDE types, and
from this estimates the UDE rate of the composed model and
DW ||
F−OTWH
N−OTW
N−OTW
||
F−OTWH
corrupt−stale
corrupt−good
N−OTW
GW
GW
F−OTWO
F−OTWO
N−OTW
N−OTW
N−OTW
DW
||
F−OTWH
GW
GW
stale
DW ||
F−OTWH
good
DW ||
F−OTWH
N−OTW
GW
N−OTW
F−OTWO
GW
F−OTWO
DW ||
F−OTWO
||
F−OTWH
corrupt
stale−good
N−OTW
F−OTWO
Figure 2. NFA representation of transitions in the block model.
generates an exponentially distributed interarrival time. The
internal clock which is used to determine the next event is then
advanced to the indicated time, our metrics are updated, and
we process the UDE as appropriate.
The second mode utilizes discrete event simulation to
model the interaction of the workload with the faults injected
into the storage system. In order to determine which events
occurring in the storage system cause a user level undetected
data corruption event, lists are maintained of both those chunks
being actively read and written, and the chunks in the storage
system which have suffered from a UDE. Only those events
which add or remove chunks from the active list, or access
faulty disk blocks are explicitly simulated. Since all other op-
erations will either read a chunk composed of good blocks,
or write a good block to a block which is already good, they
cannot affect the state of blocks within the system. When the
UDE can no longer manifest as a data corruption event, i.e.
when all active chunks which intersect with the faulty chunk
are no longer active, or when the faulty chunk is overwritten
with good data, we pass from discrete event simulation into
our simulator’s third operational mode.
The third mode is a hybrid of the ﬁrst two, and combines
discrete event simulation at a higher level of abstraction than
the second mode, with calculations which utilize a rate adjust-
ment to estimate the probability of a UDE before the next dis-
crete event. Despite the fact that by the third mode of our
solution technique the UDE can longer manifest we must be
careful to respect the dependency the system has with respect
to the last UDE injected into the system, for the admittedly un-
likely case that a second UDE might occur before the system
is no longer dependent on the events of the last UDE. This is
done by modeling the ﬂow of chunks into and out of the active
list, and calculating the probability of a UDE before the next
ﬂow of a chunk into or out of the list and adjusting the rate of
the next UDE based on the current composition of the active
list. The following sections describe the modes in more detail.
UDE
UDE can no longer manifest
as error
Block Level I/O Events
Model Flow of
Active Chunks for
Rate Tilting
Numerical Solution
Discrete Event Simulation
Hybrid Numerical
and Discrete Event
Figure 3. Simulator Architecture
3.3.1 Analytic Mode. Our simulator begins in its ﬁrst
mode, and calculates the expected rate of a UWE or URE. This
is done by ﬁrst ﬁnding the expected number of reads and writes
generated by an I/O operation to one of the RAID units. An
example of how this calculation is accomplished with RAID5
using read-modify-write is given in Figure 4. Given a RAID5
strip size of sizestrip, and a stripe width of w data disks plus
one parity, the expected number of writes for a read-modify-
write operation is equal to the number of required strips, plus
one write per stripe written to update parity. One read is like-
wise required for each strip written in a row, plus an additional
potential read if the write crosses a row boundary. On a read
to the RAID system, only a single read is performed.
Using the calculated values from Figure 4, it is possible to
ﬁnd the rate of UDEs, given an I/O rate of λIO of which pread
sizestrip(cid:25) +(cid:24) max(E[size], sizestrip) − sizestrip
E[writes/read-modify-write] = (cid:24) E[size]
(cid:24) E[size]
max(E[size], w · sizestrip) − sizestrip
w · sizestrip
w · sizestrip
+
sizestrip
(cid:25) +
(cid:25)
E[reads/read − modify − write] = E[writes/read-modify-write]
E[writes/read] = 0
E[reads/read] = 1.0
Figure 4. Actual writes and reads required to perform a RAID5 read-modify-write.
are reads, And it is possible, using these parameters to generate
a time to the next UDE (TUDE) as shown in Figure 5
Once we have determined a UDE will occur, we deter-
mine the type of UDE (UWE vs. URE) and the mechanism
(dropped, near-off track, far-off track) via uniformization [9].
In the case of a URE, the error is transient, and we remain
in numerical mode after handling the UDE. In the case of a
UWE, the error does not manﬁest immediately, and we switch
the simulator into the discrete event simulation mode.
3.3.2 Discrete Event Mode. The discrete event simulator
makes only slight modiﬁcations to methods discussed in [3].
Pseudo-code for a single pass through the main simulation
loop is illustrated in Figure 6. The primary modiﬁcation to
the standard algorithms is our creation and maintenance of two
lists, the active chunk list, CA, and the tainted chunk list CT .
The set CT is comprised of all chunks which have blocks af-
fected by a UDE that can still serve corrupted data to the user.
Between this set, and the set of all chunks being actively read
and written, CA, we can identify I/O events which do not af-
fect system state and safely discard them without updating the
state of the simulator beyond advancing the clock. This is be-
cause all events which do not modify the state of a block within
CT , or which do not alter the composition of CA or CT can-
not serve corrupted or stale data, or affect the rate at which
additional UDEs occur.
At each step in the simulator, we process one event, com-
paring it to CA and CT to see if our metric depends on the
event, processing it if it does, and modifying CA and CT if
necessary. We continue with discrete event simulation until
such a time as CT ∩ CA = ∅. When this occurs, all UDEs have
either been mitigated, or the chunks they occurred on will not
be read again until ﬁrst written, and we no longer need to sim-
ulate I/Os on a block level as they cannot result in a data cor-
ruption error. However, it is not enough to simply return to our
ﬁrst, analytic, mode. So long as CA,i 6= ∅ and CA,i∩CA,0 6= ∅,
where CA,0 was the active chunk list when it was ﬁrst true that
CT ∩ CA = ∅, and CA,i is the active chunk list at some time i,
we have a dependence on the state of the simulator during the
previous UDE, which must be maintained in the case that an-
other UDE were to occur before CA,i = ∅ or CA,i ∩ CA,0 = ∅,
nextEvent ← eventList.head()
clock ← clock + nextEvent.interarrivalTime
if nextEvent.io ∩(CA ∪ CT ) then
Process nextEvent
if nextEvent reads a block which suffered from a UDE
then
Record UDE, update MTTDC
else {nextEvent writes a set of blocks B which suf-
fered from a UDE}
CT ← CT ∪ B
end if
end if
if nextEvent is a chunk leaving CA then
CA ← CA \ nextEvent
end if
if nextEvent.io \ CA 6= ∅ then
CA ← CA ∪ nextEvent.io
CT ← CT ∪ nextEvent.io
end if
Schedule new event of the same type as nextEvent
Figure 6. Pseudo-code representation of a single pass
through the main loop of the discrete event simulator.
and thus we switch into our Hybrid mode instead of Analytic.
3.3.3 Hybrid Mode. The Hybrid mode of operation for
our simulator uses discrete event simulation to manage the
contents of CA. When a chunk leaves CA, it removes it from
the set, and when a chunk enters, it increments a counter of im-
plicitly simulated active chunks, active chunks represented by
this counter are treated as the expected value of an active chunk
from the workload. In between events which modify CA, the
hybrid mode acts in a manner similar to the analytic mode de-
scribed previously, calculating TUDE as shown in Figure 5.
Instead of using the parameters for the workload, however, it
takes a less general approach and estimates the same param-
eters from CA. It then uses these new estimates to perform
a rate adjustment calculation for TUDE, representing each of
the parameters used to calculate TUDE as a weighted average
TUDE = 1/(λIOpread(E[writes/read] + E[reads/read])
+λIO(1 − pread)(E[writes/read-modify-write] + E[reads/read-modify-write]))
Figure 5. Calculation of time to next UDE.
with the expected value of these parameters for the workload
in general. The weights used are simply the fraction of active
chunks in CA as compared to the total number |CA|+implicit.
When CA,i = ∅ or CA,i ∩ CA,0 = ∅, we return to the purely
numerical scheme as we are no longer dependent on the last
UDE scenario.
nextEvent ← eventList.head()
clock ← clock + nextEvent.interarrivalTime
if nextEvent is an addition to CA then
implicit ← implicit + 1
end if
if nextEvent is a chunk leaving CA then
if implicit > 0 and nextEvent /∈ CA then
implicit ← implicit - 1
else
CA ← CA \ nextEvent
end if
end if
if CA = ∅ then
Switch to Analytic mode
end if
Adjust the rate for UDEs based on CA and Implicit
Schedule next change in CA
Figure 7. Pseudo-code representation of a single pass
through the main loop of the hybrid discrete event simu-
lator.
3.4 Validation
Results of the simulator were validated using a simple nu-
merical model of a UDE process. The numerical model func-
tions the same as our simulator during the initial stage, but
once it has decided a UDE has occurred, instead of switch-
ing to discrete simulation, it utilizes the DTMC described in
Figure 1, using a Geometric distribution with parameter equal
to the transition probability to the opposite state to ﬁnd the
number of reads before a subsequent write event. After the
UDE has been resolved, it simply calculates the next UDE,
and continues as before. Comparing results for the propor-
tion of UDEs manifesting as undetected data corruptions, and
rates of user-level undetected data corruption errors from this
numerical model with results from the simulator (with parity
scrubbing and other such features switched off) helped us to
gain conﬁdence in our simulator and ensure it was generating
results which agreed with our numerical model. Estimation of
rates at which UDEs manifested as user level undetected data
corruption events by the simulator were within 4.6% of those
given by our numerical model, for 10 million simulated UDEs
with no scrubbing, and no mitigation.
4. Results
For this study we simulated three different example sys-
tems to ascertain the effect of UDEs in three settings, a large-
scale storage system, a large enterprise storage system, and
a small business storage system. The large-scalesystem was
modeled as a set 1000 disks each with a capacity of 1 terabyte,
the enterprise system was modeled as a set of 512 disks, each
with a capacity of 300 gigabytes, and the small business sys-
tem was modeled as a set of 32 disks, also with capacities of
300 gigabytes each. Each of the three modeled systems were
simulated with three different workloads, as discussed in Sec-
tion 3.1. The rate of I/O operations per second for each system-
workload pairing was calculated by multiplying the io/s pa-
rameter for the workload by the number of disks (excluding
those used for parity) in the system. All systems, including
those without mitigation, simulated a weekly parity scrub. A
weekly scrub [8] was chosen based on the existing literature,
which discusses a wide range of scrub intervals from every
few days [5] to at least every two weeks [11, 1]. A scrub in-
terval of one week was chosen as a representative rate, but is
not integral to our simulator, and can be easily altered. Each
of these systems was simulated with and without mitigation
techniques. UDE rates of three different orders of magnitude
(10−11, 10−12, 10−13) were considered. A total of 10 million
UDEs were simulated for each scenario.
Tables 4(a) and 4(b) summarize the proportion of UDEs
which actually manifest as an undetected data corruption event
for the simulated scenarios. As can be seen in Table 4(a) the
proportion of UDEs which manifest as an actual error does not
vary signiﬁcantly when varying system parameters. The var-
ious rates of UDEs/IO simulated are not listed as the results
were the same for all three parameters. Adding the mitigation
technique described in Section 2.3 had the effect of reducing
the proportion of UDEs which manifested as undetected data
corruption by two orders of magnitude. Table 4(b) shows the
effect that varying the workload can have on the proportion of
UDEs that manifest as an error. While both the Abstract work-
load and Write Heavy workload have similar rates of manifes-
tation, the Read Heavy workload has a much lower proportion
of UDEs which manifest as undetected data corruptions. In all
cases, adding mitigation had the effect of reducing the propor-
tion of UDEs manifesting as errors by two orders of magni-
Table 4. Estimated mean proportion of UDEs which manifest as undetected data corruption for various workloads and various
system models, with and without mitigation.
(a) Various systems with Abstract workload
(b) Various workloads on large system model
System
Workload
Mitigation Large Enterprise
No
Yes
0.718
0.0028
0.718
0.0028
Small Business
0.718
0.0028
Mitigation Abstract Read Heavy Write Heavy
No
Yes
0.275
0.0011
0.887