上面这个正则式组合了Unicode中的Separator（分隔符）属性，以及空白符号
的心s>简写。这是因为由和s匹配的字符并不会完全重叠。（s>中会包含位置从
0x09到0x0D（制表符、换行、垂直制表符、换页和回车）的字符，而这些字符并没有
在Unicode标准中赋予Separator属性。通过在一个字符类中把和s>组合起来，
你就可以确保能够匹配所有的空白字符。
在两个正则式中，区间量词{10,100都被应用到了它之前的非捕获分组上，而不是应
用到单个记号。该分组会匹配任意单个的非空白字符紧跟0个或多个空白字符。因为
每次循环会恰好匹配一个非空百字符，所以区间量词就会可靠地记录到底匹配了多少
个非空白字符。
限制单词的个数
下面的正则表达式与上一个例子中非常相似，区别只是每次重复会匹配整个单词，而
不是单个的非空白字符。它会匹配10～100个单词，并忽略任意非单词字符，其中包
括标点符号和空白：
^\W*(?:\w+\b\W*) (10,100}$
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
在Java、JavaScript、PCRE和Ruby中，单词字符记号只会匹配ASCII字符中的A～
Z、a～Z、0～9和_，因此这并不能正确地统计包含非ASCII字母和数字的单词个数。
在.NET和Perl中，会基于Unicode字符表（这也包括了和它相反的W>，以及单
词边界\b>），因此会匹配到所有Unicode字母表中的字符和数字。在Python中，你可
以通过在创建正则式的时候传递一个UNICODE或U标志来决定这些记号是否是基于
Unicode的。
如果你想要统计包含非ASCII字母和数字的单词，那么下面的正则表达式会为其他正
则流派提供这种能力：
[\p(L}\p{N}_] *(？:[\p{L}\pN}_]+\b[\p{L\p{N}_]*)(10,100}$
正则选项：无
正则流派：.NET、Java、Perl
合法性验证和格式化
235
www.TopSage.com
---
## Page 252
[^\p{L}\pN}_] *(?:[\p{L}\p{N)_]+(?:[\p{L}\p{N}_] +I$)){10, 100}$
正则选项：无
正则流派：.NET、Java、PCRE、Perl、Ruby1.9
在PCRE中必须使用UTF-8支持来进行编译才可以使用。在PHP中，需要使用模式
修饰符来打开UTF-8支持。
我们已经提到，之所以会有这么多不同（但是等价）的正则式，是因为对于单词字符
和单词边界记号存在不同的处理方法，这在实例2.6中的“单词字符”小节中有详细的
解释。
在最后两个正则式使用的字符类中为单词和字母使用了分别的Unicode属性（p{L)
和p(N)>)，并且手动在每个类中添加了下划线字符，从而它们可以同前面依赖于w）
和W的正则式保持等价。
在这3个正则式的前两个中，每次非捕获分组的重复都会匹配一个单词与其后跟着的0
个或多个非单词字符。在分组中的记号W）（或p{L)p(N)]）会被允许重复0次，
因为字符事可能会以一个单词学符结策。然而，因为这样就会使得非单词字符在整个
匹配过程中都变成了可选的，所以就需要在和）、老版本的MacOS（r>）和Unix/Linux/OSX（）中
的换行约定。
正则表达式
下列3个特定于流派的正则式包含两个区别。第一个正则式使用了原子分组，它的格
式是(?>...)，而没有使用？:...)格式的非捕获分组，因为如果正则流派支持前者，那
么它可能会带来性能上潜在的小幅提高。Python和JavaScript不支持原子分组，所以它
们就不能使用第一个正则式。另外一个区别是用来判断字符串开始和结束位置的记号
（A>或用于字符事的开始，z、Z>或S>用于结束）。这种变化的原因会在本实
例随后内容中深人进行讨论。所有这3个特定于流派的正则式都会匹配完全一样的字
符串：
z\{}（[\\]（u\1u\\(?>\r\n？1\n)？[^\r\n] *)(0,5}\z/'，$_POST[′subject'1）)
}else{
print 'Subject contains more than five lines';
合法性验证和格式化
237
www.TopSage.com
---
## Page 254
其他编程语言
如果读者想知道在其他编程语言中如何实现这些正则表达式，请参考实例3.5中的
讲解。
讨论
本实例中前面给出的所有正则表达式都使用了一个分组，来匹配MS-DOS/Windows、
legacyMacOS或者Unix/Linux/OSX中的一个换行序列，紧跟着任意个数的非换行字
符。分组会被重复0～5次，从而我们只能匹配最多5行。
在下面的例子中，我们把上面JavaScript版本的正则式拆分开来研究。我们之所以在这
里使用JavaScript的版本，是因为它的组成部分对于更多读者来说可能会更为熟悉。随
后我们会解释不同正则流派之间的区别：
判断字符串的开始位置
( ? :
分组但是并不捕获..·
(?:
分组但是并不捕获...
\r
#
匹配一个回车字符（CR，ASCII位置0xOD）
\n
鲁
匹配一个换行字符（LF，ASCII位置OxOA）..·
？
#
0次或1次
1
或者...
\n
匹配一个换行字符
）
非捕获分组的结束
？
#
重复之前的分组0次或1次
[^\r\n]
#
匹配除了CROrLF之外的任意单个字符..
#
0次或无限多次
）
#非捕获分组的结束
{0,5}
#重复之前的分组0~5次
$
#判断字符串的结束位置
正则选项：宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
最开始的个会匹配字符串的开始位置。这会有助于确保整个字符串中包含不多于5
行，因为除非正则式一定从字符事的并头并始匹配，否则它就可能会匹配一个更长字
符串中的任意5行内容。
接着，我们使用了一个非捕获分组来包括一个换行序列和任意个数的非换行字符的组
合。紧跟其后的量词会允许这个分组重复0～5次（0次重复会匹配-个全空字符串）。
在外层分组中，一个可选的子分组会匹配一个换行序列。后面跟着的是一个字符类，
它可以匹配任意个数的非换行字符。
再仔细看一下外层分组中元素的顺序（首先是一个换行符，然后是一个非换行字符序
列)。如果我们把顺序反过来，那么这个分组就会被写作(?:[^rin]*(?rlin?n)?)，这样
在第5次重复中会允许出现-一个拖尾的换行。实际上，这样改动之后就会允许出现一
238第4章
www.TopSage.com
---
## Page 255
个空的第6行。
子分组中充许出现下列三种换行序列：
·一个回车之后跟着一个换行（。虽然这两个定位符在所有的正则流派中都支持，但是在本节的其他正
则式中使用了A）、Z和。对此的简单解释是在不同的正则表达式流派之间这些
元字符的含义稍有区别。如果要详细解释的话，那么就需要深人了解一些正则表达式
的历史。
当使用Perl来从文件中读人一行的时候，得到的结果字符串会以换行符作为结束。因
此，Perl对S>的传统含义引I人了一个“改进”，而大多数其他正则流派也沿用了这种
改进。除了匹配-个字符串的绝对结束之外，Perl中的还会匹配结束字符串的换行
位置。Perl同时还引l人了两个断言来匹配字符串的结束：和。Perl中的定
位符与$拥有同样诡异的含义，但是当使用额外选项允许和$匹配换行处的时
候，前者并不会产生同样的变化。z>总是会只匹配字符串的绝对结束，从无例外。因
为这个实例中需要处理换行符来统计一个字符串中的行数，所以在支持z>的流派中
都使用了z断言，以确保不会匹配到一个空的第6行。
大多数其他正则流派都沿用了Perl中的行结束和字符串结束定位符。.NET、Java、PCRE
和Ruby都会支持Z>和z>，其含义与在Perl中是一样的。Python中只包含了大写形式
的Z>，但是却令人费解地把它的含义改变成了只匹配字符串的绝对结束，这与Perl中
小写形式的z>是一样的。JavaScript没有包括任何“z”定位符，但是与所有其他的正
则流派都不一样的是，它的$>定位符只会匹配字符串的绝对结束位置（在允许和$
匹配换行处的选项没有打开的前提下）。
对于A的情形会稍微简单一些。它总是会只匹配一个字符事的开始位置，它的含义在
我们讨论的除了JavaScript（不支持该定位符）之外的所有流派中都是一样的。
虽然存在这么多种令人容易混淆的跨流派的不一致性会带来很多不便，但是使用本书
中的正则表达式的好处之一就是你通常不用去担心这些区别。除非喜欢追根究底，否
合法性验证和格式化239
www.TopSage.com
---
## Page 256
则一般并不需要了解类似我们刚刚讨论的这样复杂的细节。
变体
处理奇怪的换行符
前面给出的正则式的支持只限于传统的MS-DOS/Windows、Unix/Linux/OSX和老版本
的MacOS中的换行序列。然而，你可能偶尔还会遇到一些较不常见的垂直空白字符。
下面的正则式会在把匹配限制为不超过5行文本的同时，考虑这些额外的字符。
\A（？>\R？\V*）{0,5}\z
正则选项：无
正则流派：PCRE7（使用PCRE_BSR_UNICODE选项）、Per15.10
\A(?>(?>\r\n？1[\n-\f\x85\x{2028}\x{2029)])?
[\n-\r\x85\x{2028}\x{2029}]*）{0,5}\z
正则选项：无