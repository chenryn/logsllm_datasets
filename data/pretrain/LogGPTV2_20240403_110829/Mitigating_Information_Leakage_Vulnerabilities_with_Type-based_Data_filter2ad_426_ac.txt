51053
void func(char *validPtr, size_t size) {
for (size_t n = 0; n 4GB, but TDI masks
the pointer arithmetic and mitigates the vulnerability.
B. Spectre-BCB
To ensure that our instrumentation is applied to potential
Spectre-BCB gadgets, we applied TDI to the corpus of 27
Spectre v1 variants provided by the authors of Spectector [27]
(including the 15 examples from Kocher [31]). TDI correctly
masks the potentially out-of-bounds loads for all 27 examples.
We also examined four Spectre demos from Google’s
Safeside [1] suite, which we modiﬁed to allocate the private
(secret) string using malloc. Originally, the public and private
strings were both static global strings, stored in the same
arena. We also made changes to prevent truncation or masking
when calculating cross-arena offsets, which would typically be
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:57:47 UTC from IEEE Xplore.  Restrictions apply. 
71055
attacker-supplied rather than calculated by the code itself, and
conﬁrmed that the examples work when TDI is not applied2.
We mitigate three of these four examples:
1) spectre v1 pht sa: This is a Spectre-BCB example,
which is covered by our threat model; as expected, the private
string no longer leaks when TDI is applied, since the array
access is correctly masked.
2) spectre v1 btb sa: This example uses a mispredicted
indirect branch to cause type confusion. Even though this is
not covered by our threat model, the private string no longer
leaks when TDI is applied. The transient (mispredicted) branch
target uses an out-of-bounds read and TDI prevents it from
accessing the private string. (If we modify the code to remove
the out-of-bounds read, the example leaks the private string
after TDI is applied, as expected.)
3) spectre v1 btb ca: This uses a mispredicted indirect
branch to transiently execute code to read the private string.
Since the transiently executed code is intended to be able to
read the private string, this is outside our threat model, and
the code leaks the private string even after TDI is applied.
4) spectre v4: This example is intended to demonstrate
Spectre-SSB. It causes an out-of-bounds array index to be
transiently used while waiting for a store to complete. Since
the array index is out-of-bounds, TDI masks the array access
and the private string no longer leaks.
C. SPEC CPU2006 and CPU2017
We evaluated the performance of TDI using SPEC
CPU2006, to aid comparison with previous work. We also
present results from SPEC CPU2017 (without OpenMP). We
ran these evaluations on Xeon E5-2630 v3 CPUs with 64GB of
RAM. Transparent Huge Pages were disabled and the bench-
marks were pinned to a single core. In both cases, we include
all C/C++ benchmarks and use the reference SPECspeed data.
We run each benchmark/conﬁguration at least 5 times; the
reported numbers are the median value from these runs.
We modiﬁed some of the benchmarks to make them build
and run successfully with TDI. We also applied these changes
to the baseline where relevant. These changes can be grouped
into three categories (details are in Appendix A):
• build problems: we added an #include to dealII’s code.
• undeﬁned pointer arithmetic: we apply gcc patches and
exclude one perlbench function.
• large allocations in CPU2017: we disable LTO (and thus
instrumentation) for the SPEC I/O wrapper for xz, which
allocates a >4GB array for one test. We also annotate one
struct type in deepsjeng (via ﬂags), which is used only
for a >4GB hash table (accessed via a masked index).
For our baseline, we compile the benchmarks using an
unmodiﬁed LLVM, and link against an unmodiﬁed version
of tcmalloc. We compiled all benchmarks with -O2, and PIE
ﬂags. All our benchmarks were compiled using LTO (via the
gold linker), and the same ﬂags were passed to the linker.
2We excluded the out-of-scope ret2spec demos since they do not leak any
data on our Cascade Lake machine, presumably due to hardware mitigations.
perlbench
bzip2
gcc
mcf
milc
namd
gobmk
dealII
soplex
povray
hmmer
sjeng
libquantum
h264ref
lbm
omnetpp
astar
sphinx3
xalancbmk
Typed allocation
Masking
Full protection
0%
5%
10%
15%
20%
25%
30%
35%
Fig. 4. CPU2006 runtime overhead
We did not use -fno-strict-aliasing; TBAA information im-
proves our pointer analysis, and we did not have miscompila-
tion issues in this version of LLVM. Otherwise, clang could
be modiﬁed to output TBAA metadata despite this ﬂag.
Figure 4 shows runtime overhead for our three basic con-
ﬁgurations. Geometric means are 2.5% for typed allocation,
5.8% for masking, and 8.4% for the combined full TDI
protection. This is signiﬁcantly more efﬁcient than prior load
pointer masking-based solutions with only two colors (e.g.,
over 17% on CPU2006 for [33]). We can see that overhead is
high (>15%) for two benchmarks, perlbench and xalancbmk,
due to the cost of typed allocation; perlbench’s overhead is
due to the type-safe stack (2% heap, 13.4% heap+stack),
while xalancbmk’s overhead is due to both (11.5% heap, 21%
heap+stack). Much of the perlbench overhead appears to be
due to LLVM register allocator issues [66], and could be
mitigated by limiting inlining.
We also evaluated runtime overhead for two alternatives
(full results can be found in Figure 11 in Appendix D):
(1) TDI without stores; here, we do not instrument pointers
used only by stores. Although the beneﬁt is signiﬁcant for
sjeng, hmmer suffers due to different base pointers being
masked on the hot path (which could be resolved with runtime
proﬁling). The geomean on CPU2006 is 8.1%, compared to
8.4% for full protection; the cost of reduced protection would
seem to outweigh this minor performance gain.
(2) TDI without dominator pointer access analysis. This
analysis signiﬁcantly beneﬁts some benchmarks (e.g., namd,
hmmer, sjeng and xalancbmk), and reduces the geomean