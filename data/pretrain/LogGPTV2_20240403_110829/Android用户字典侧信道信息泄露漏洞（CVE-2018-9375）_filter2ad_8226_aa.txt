# Android用户字典侧信道信息泄露漏洞（CVE-2018-9375）
|
##### 译文声明
本文是翻译文章，文章来源：ioactive.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 概述
前一段时间，我负责对Android智能手机进行审计，所有已安装的应用都在审计的范围之中。在要求的时间内，我决定对尽可能多的代码进行人工检查。正是在这次检查之中，我发现了一个漏洞，该漏洞在较新版本的Android系统上存在，允许我们与本应受到保护的内容提供者（Content
Provider）——个人字典进行交互，“个人字典”中保存了用户在输入过程中自定义的词语拼写。  
理论上，用户“个人字典”只应该允许特权账户访问，包括输入法编辑器（IME）和拼写检查程序。但事实上，我发现存在一种途径能够绕过限制，使恶意应用程序能够更新/删除个人字典中的内容，甚至还能够检索字典中的全部内容，这一过程无需任何权限，可以在用户不知情的情况下完成。  
该漏洞被评定为中危漏洞，归类为特权提升类，并在2018年6月完成修复，漏洞影响6.0、6.0.1、7.0、7.1.1、7.1.2、8.0和8.1版本的Android系统。
## 用户的个人字典
Android中提供了一个“自定义字典”，可以由用户手动定义，也可以从用户的输入过程中自动学习。通常，用户可以从“设置 – 语言和键盘 –
个人字典”中访问该字典。考虑到该字典可以根据用户的输入而自动生成，那么其中很有可能包含用户的敏感信息，包括姓名、地址、电话号码、电子邮件、密码、企业名称、特殊关键词（例如感染疾病名称、服用药品名称、专业术语等），甚至还有可能包括信用卡号码。  
用户还可以为每个单词或句子定义“快捷输入方式”，举例来说，在定义后，用户可以直接输入快捷方式名称（例如“myhome”），输入法就能自动识别并将其替换为完整的家庭地址。  
在内部，这些单词都保存在SQLite数据库中，除“android_metadata”之外，该数据库只包含一个名为“words”的表，该表的结构共包含6个字段：
    _id (INTEGER, PRIMARY KEY)
    word (TEXT)
    frequency (INTEGER)
    locale (TEXT)
    appid (INTEGER)
    shortcut (TEXT)
我们主要进行研究的对象就是其中的“word”字段，因为顾名思义，这一字段中包含了所有的自定义单词。但除此之外，其他的所有字段和表也都可以利用同样的方式访问。
## 漏洞的技术细节
在以前版本的Android中，对个人字典的读写访问权限受到以下权限保护：
    android.permission.READ_USER_DICTIONARY
    android.permission.WRITE_USER_DICTIONARY
然而，在新版本中，原有的保护机制将不再适用。根据官方文档中的说明，从API
23版本开始，用户字典只能通过IME和拼写检查程序访问。因此理论上，只有特权用户（例如root和system）的IME和拼写检查程序才能访问作为内容提供者的个人字典（content://user_dictionary/words）。  
我们可以检查AOSP代码库，重点分析修改后的版本中引入的名为canCallerAccessUserDictionary的新私有函数。此外，我们还关注从UserDictionary内容提供者进行调用的过程，以弄明白如何实现标准的查询、插入、更新和删除操作，以及如何防止未经授权的调用。  
根据我们的分析，授权检查能够有效地对查询和插入操作进行校验，但针对更新和删除操作则没有及时地进行校验，从而引入了一个安全漏洞。借助该漏洞，任意应用程序都能够通过公开的内容提供者调用受影响的函数，从而绕过不及时的授权检察。  
在UserDictionaryProvider class3的以下代码中，我们可以发现其中存在的问题，并且能够看到授权检查是在数据库已被更改后进行的：
    @Override
    public int delete(Uri uri, String where, String[] whereArgs) {
       SQLiteDatabase db = mOpenHelper.getWritableDatabase();
       int count;
       switch (sUriMatcher.match(uri)) {
          case WORDS:
              count = db.delete(USERDICT_TABLE_NAME, where, whereArgs);
              break;
          case WORD_ID:
              String wordId = uri.getPathSegments().get(1);
              count = db.delete(USERDICT_TABLE_NAME, Words._ID + "=" + wordId
                   + (!TextUtils.isEmpty(where) ? " AND (" + where + ')' : ""), whereArgs);
              break;
           default:
              throw new IllegalArgumentException("Unknown URI " + uri);
       }
       // Only the enabled IMEs and spell checkers can access this provider.
       if (!canCallerAccessUserDictionary()) {
           return 0;
       }
       getContext().getContentResolver().notifyChange(uri, null);
       mBackupManager.dataChanged();
       return count;
    }
    @Override
    public int update(Uri uri, ContentValues values, String where, String[] whereArgs) {
       SQLiteDatabase db = mOpenHelper.getWritableDatabase();
       int count;
       switch (sUriMatcher.match(uri)) {
          case WORDS:
             count = db.update(USERDICT_TABLE_NAME, values, where, whereArgs);
             break;
          case WORD_ID:
             String wordId = uri.getPathSegments().get(1);
             count = db.update(USERDICT_TABLE_NAME, values, Words._ID + "=" + wordId
    + (!TextUtils.isEmpty(where) ? " AND (" + where + ')' : ""), whereArgs);
             break;
          default:
             throw new IllegalArgumentException("Unknown URI " + uri);
       }
       // Only the enabled IMEs and spell checkers can access this provider.
       if (!canCallerAccessUserDictionary()) {
          return 0;
       }
       getContext().getContentResolver().notifyChange(uri, null);
       mBackupManager.dataChanged();
       return count;
    }
此外，AndroidManifest.xml文件也仅针对存在显式输出的内容提供者提供额外的保护（例如内容过滤器和授权检查），而“个人字典”则不在此列：
           <provider android:name="UserDictionaryProvider"
              android:authorities="user_dictionary"
              android:syncable="false"