in how to execute the interpreter inside the enclave, considering
the fact that enclaves cannot perform any system calls. Certain
system calls, such as those related to networking and file systems,
are crucial for the correct execution of many scripts.
At first it might appear that we would need to modify the source
code of each interpreter. While possible, this approach is quite
tedious and not scalable if we aim to support many interpreters.
Fortunately, an interpreter is typically dynamically linked to the
standard C libraries. Based on this observation, if we just statically
link the interpreter with a modified version of libc, then we do
not have to modify the interpreter. Therefore, the challenge now
becomes how to modify the way system calls are invoked in libc so
that we can statically link our modified libc with the enclave code
and execute it inside the enclave.
Identifying the points of system call invocation fpriat the
function level in libc would also be tedious. For instance, both
printf and fprintf will invoke the write system call. Directly
examining all of the standard library code, identifying functions
invoking system calls, and adding a bridge function for each of
these functions would require a lot of manual effort. Therefore, we
need a more systematic approach. Fortunately, we found that in
the musl-libc implementation of libc, all system calls are invoked
from a central location rather than independently. Therefore, by
directly patching the centralized system call code, there is no need
to examine and patch all libc functions.
More specifically, we just need to add a shim layer atop the
existing system call invocation point in musl-libc. At this shim
layer, based on the system call number we invoke the corresponding
bridge function (the ocall wrappers) and execute the system call
outside of the enclave. The interpreter can now be statically linked
with our modified C library and then executed inside the enclave.
Our Trusted Module also needs to decrypt the script. The
decryption key is passed by the client through the secure channel.
After decryption, the script can be executed. Considering that the
enclave does not trust the OS in our threat model, we cannot rely
on the return values from system calls, as a malicious OS can return
arbitrary values. This is a well-known class of attacks called Iago
attacks [5], in which malicious return values from system calls
could lead to arbitrary execution inside the enclave. Fortunately,
we are not the first to encounter this problem, and there is a known
defense: performing checks on the system call return values inside
the trusted component, as has been done in Haven [4]. For example,
for a read system call, the return value contains the number of
bytes read. However, one of the arguments is count, the number
of bytes to attempt to read. By checking that the return value is not
larger than count, we can verify the return value is in a legal range.
Therefore, we insert such verification code inside the enclave for
each system call in order to defend against Iago attacks.
5 EVALUATION
We have implemented ScriptShield1. In this section, we present
the evaluation results. Our performance experiments were executed
on a 14.04.1-Ubuntu system comprised of a 4-core Intel Core i7-
6700 CPU running at 3.40GHz, with 64GiB memory, and 1Gbit/s
Ethernet Connection I219-LM, running the latest Intel SDK and SGX
1The source code is available at https://github.com/osuseclab/scriptshield.
Session 2A: SGX-based SecurityAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand117Native
ScriptShield
140
130
120
110
100
)
%
(
d
a
e
h
r
e
v
O
d
e
z
i
l
a
m
r
o
N
randomreg
regexp
array
try
strict
continue
assign
empty-loopfib
mandel
jsonserialize
obj-garbage
call
compile
break
add
bitwise
Figure 2: Percentage overhead of running MuJS benchmarks
in ScriptShield normalized against native execution.
driver. We set up two environments for running our benchmarks:
(1) running natively, (2) running under ScriptShield. We measured
the execution time by utilizing the OS clock outside of the enclave.
In particular, we first start the clock outside an enclave, execute a
script inside the enclave, and then stop the clock to calculate the
total execution time.
We evaluated ScriptShield using three popular cross-platform
scripting languages: Lua, JavaScript (by running the MuJS inter-
preter), and Squirrel. We do not need to change any lines of code in
the interpreter when porting it to run in our enclave. What we must
do is (1) add an ecall as an entry point to call the interpreter, (2)
modify the interpreter makefiles to statically link musl-libc, and
(3) modify the enclave makefiles to integrate the statically linked
interpreter into the enclave and generate the final enclave.so with
the client’s hard coded public key.
Since ScriptShield is legacy code compatible, we can directly
run unmodified existing scripting language benchmarks to eval-
uate the performance impact of ScriptShield when running the
interpreter inside the enclave. To this end, we have selected the
following benchmark scripts for each of the tested interpreters:
• Lua. Our dataset includes 5 standard benchmarks used in the
Lua language evaluation, as shown in Figure 3.
• MuJS. MuJS is a lightweight JavaScript interpreter. There are
no specific benchmarks for the MuJS engine, so we used the
benchmarks from the performance tests in Duktape. We grouped
these benchmarks into 18 sets, shown in Figure 2. Each set
contains one or more JavaScript benchmarks and tests the
performance of the language feature specified by that group.
• Squirrel. Squirrel is a Lua-like language with a C-like syntax,
typically embedded in a host application. Unlike Lua, which is
written in C, Squirrel is implemented in C++ but exposes a C
API modeled after Lua’s stack-based API. We have 15 sample
benchmarks that we run, as shown in Figure 4. .
Results. Figure 2, Figure 3, and Figure 4 show the percentage
overhead of running the MuJS, Lua, and Squirrel benchmarks within
ScriptShield compared with native execution. We observe that
the overhead for the Lua benchmarks in Figure 3 is reasonable
except for k-nucleotide. However, this apparently high overhead
is due to the short runtime of the benchmark. Therefore, any fixed
Native
ScriptShield
)
%
(
d
a
e
h
r
e
v
O
d
e
z
i
l
a
m
r
o
N
350
300
250
200
150
100
n-body
fannkuch
spectral
fasta
k-nucleotide
Figure 3: Percentage overhead of running lua programs in
ScriptShield normalized against native execution.
Native
ScriptShield
500
400
300
200
100
)
%
(
d
a
e
h
r
e
v
O
d
e
z
i
l
a
m
r
o
N
0
array
generators
coroutines
flow
fibonacci
delegation
class
ackermann
classattributes
regex
matrix
list
loop
metamethods
tailstate
methcall
Figure 4: Percentage overhead of running Squirrel bench-
marks in ScriptShield normalized against native execution.
overhead (e.g. entering and exiting the enclave) may dominate the
runtime of the benchmark when running under ScriptShield. This
leads to a high overhead percentage, even though the actual time it
takes to execute is quite small, both natively and in ScriptShield.
The overheads for Squirrel scripts in Figure 4 appear high for the
same reason: the benchmarks’ very short runtimes result in higher
overhead. In contrast, the MuJS benchmarks take longer to execute
and have comparatively lower overhead, as shown in Figure 2.
6 LIMITATIONS AND FUTURE WORK
There are still limitations to ScriptShield. Currently, we only
support applications written purely in scripting languages. We do
not directly support applications with an interpreter depending on
native components (e.g., a web browser, in which both native code
and scripting code work together). We leave the additional porting
efforts to support the native components to future work.
We only ported three interpreters so far. While we do not have
to modify the interpreter source, we must recompile and statically
link it with our modified musl-libc. This process often involves
tedious engineering efforts. A next step is to investigate automatic
compilation dependency resolution and makefile patching, so we
can automatically recompile and statically link with our new library.
Finally, we did not implement bridge functions and ocalls for
every system call. Currently, we support 60 commonly used system
Session 2A: SGX-based SecurityAsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand118p p s
A
S crip ts
o
p atibility
m
C
B
w a r d
C
S m all T
B in a r y
B a c k
✓
✓
✓ ✓ ✓
✓ ✓ ✓
✓
✗
✗
✓ ✓
✗
✓
✓
✗
✓ ✓
✗
✗
✗
✗
✗
✓
✗
✗
✓
Systems
Haven [4]
Scone [2]
Panoply [20]
TrustJS [8]
Glamdring [15]
Graphene [21]
ScriptShield
Year
2015
2016
2017
2017
2017
2017
2019
Table 1: Comparing ScriptShield with the related works.
calls (all of which are used in our testing benchmarks). We plan to
add support for the rest of the system calls as future work.
7 RELATED WORK
Protecting Applications with SGX. Since SGX offers strong pro-
tection to applications, SGX has been used to build several security
systems. Haven [4] ports a Windows library OS to SGX to achieve
shielded execution of unmodified legacy applications. Haven has a
large TCB and thus a large attack surface. Panoply [20] provides a
micro-container isolating data and code with SGX. Panoply bridges
the gap between SGX-native abstractions and standard OS abstrac-
tions, but it must change the application code. Scone [2] isolates
docker containers running on a public cloud by using SGX enclaves.
Ryoan [11] protects secret data in a distributed sandbox while it is
processed by services on untrusted platforms, leveraging hardware
enclaves to protect sandbox instances from potentially malicious
platforms. SGX-Elide [3] protects the secrecy of SGX code itself by
enabling the dynamic update of the enclave code. Glamdring [15] au-
tomatically partitions applications into trusted and untrusted parts.
TrustJS [8] explored the direction of using SGX to protect
JavaScript. While it made a first step of using SGX to protect
scripting languages, their design requires script modifications. Also,
it does not attempt to provide a general execution framework to
execute legacy applications developed in scripting languages. In
contrast, ScriptShield aims to protect the confidentiality and
integrity of scripting languages without script modifications.
A comparison of ScriptShield with closely related works is
illustrated in Table 1. ScriptShield is the first scheme with both
a small TCB and backward compatibility, while all other schemes
either focus on binary applications or lack backward compatibility.
SGX Attacks and Defenses. One of the earliest attacks on SGX is
the controlled-channel attack [23], in which a malicious OS infers
the secrets of SGX applications by observing page fault patterns.
Recently, even higher resolution side channels have been found by
exploiting timer interrupts and cache misses [9]. Other attempts to
attack SGX include using ROP [13] or branch shadowing [14].
To counter controlled-channel attacks, T-SGX [18] leveraged
transactional memory and compiler extensions to instrument
enclave code and detect attack attempts. There are also other
solutions that mask page fault patterns by either determining
memory access behavior [19] or using large pages [7].
8 CONCLUSION
We have presented ScriptShield, a backwards compatible ap-
plication execution framework that automatically ensures the
confidentiality and integrity of scripts by executing scripting
language interpreters inside SGX enclaves. We have implemented
a prototype of our framework and tested with Lua, JavaScript and
Squirrel. Our experimental results show that ScriptShield does not
introduce noticeable overhead. We also demonstrate the benefits of
running interpreters inside SGX, such as only signing the trusted
enclave once while allowing execution of arbitrary scripts and
transparent protection of the confidentiality and integrity of scripts.
ACKNOWLEDGEMENT
We would like to thank the anonymous reviewers for their helpful
comments. This work was supported in part by the NSF grants
1750809, 1718084, 1834213, 1834215, and 1834216.
REFERENCES
[1] “Intel software guard extensions programming reference,” https://software.intel.
com/sites/default/files/managed/48/88/329298-002.pdf, Oct. 2014.
[2] S. Arnautov, B. Trach, F. Gregor, T. Knauth, A. Martin, C. Priebe, J. Lind,
D. Muthukumaran, D. O’Keeffe, M. Stillwell et al., “Scone: Secure linux containers
with intel sgx.” in OSDI, 2016.
[3] E. Bauman, H. Wang, M. Zhang, and Z. Lin, “Sgxelide: enabling enclave code
secrecy via self-modification,” in CGO. ACM, 2018, pp. 75–86.