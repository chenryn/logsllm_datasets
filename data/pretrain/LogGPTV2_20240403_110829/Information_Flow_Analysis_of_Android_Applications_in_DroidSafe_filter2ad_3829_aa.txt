title:Information Flow Analysis of Android Applications in DroidSafe
author:Michael I. Gordon and
Deokhwan Kim and
Jeff H. Perkins and
Limei Gilham and
Nguyen Nguyen and
Martin C. Rinard
Information-Flow Analysis of
Android Applications in DroidSafe
Michael I. Gordon∗, Deokhwan Kim∗, Jeff Perkins∗, Limei Gilham†, Nguyen Nguyen‡, and Martin Rinard∗
∗Massachusetts Institute of Technology
PI:EMAIL, PI:EMAIL, PI:EMAIL, PI:EMAIL
†Kestrel Institute
PI:EMAIL
‡UWIN Software, LLC
PI:EMAIL
Abstract—We present DroidSafe, a static information ﬂow
analysis tool that reports potential leaks of sensitive information
in Android applications. DroidSafe combines a comprehensive,
accurate, and precise model of the Android runtime with static
analysis design decisions that enable the DroidSafe analyses to
scale to analyze this model. This combination is enabled by
accurate analysis stubs, a technique that enables the effective
analysis of code whose complete semantics lies outside the scope
of Java, and by a combination of analyses that together can
statically resolve communication targets identiﬁed by dynamically
constructed values such as strings and class designators.
Our experimental results demonstrate that 1) DroidSafe
achieves unprecedented precision and accuracy for Android
information ﬂow analysis (as measured on a standard previously
published set of benchmark applications) and 2) DroidSafe detects
all malicious information ﬂow leaks inserted into 24 real-world
Android applications by three independent, hostile Red-Team
organizations. The previous state-of-the art analysis, in contrast,
detects less than 10% of these malicious ﬂows.
I.
INTRODUCTION
Sensitive information leaks, as implemented by malicious
or misused code (such as advertising libraries) in Android
applications, constitute one of the most prominent security
threats to the Android ecosystem [1, 2]. Android currently
supports a coarse-grain information security model in which
users grant applications the right to access sensitive informa-
tion [3]. This model has been less than successful at eliminat-
ing information leaks [1], in part because many applications
need to legitimately access sensitive information, but only for
a speciﬁc limited purpose — for example, an application may
legitimately need to access location information, but only with
the right to send the information to authorized mapping servers.
Motivated by this problem, researchers have developed a
variety of systems that are designed to analyze or explore the
information ﬂows in Android applications. Dynamic analysis
frameworks execute instrumented versions of Android appli-
cations and observe behaviors [4–6]. Potential downsides of
this approach include missed information ﬂows that are not
exercised during testing and, in some cases, the ability of
the malicious application to detect the testing and modify its
behavior to avoid exercising the malicious ﬂow [4]. They also
suffer from denial-of-service attacks if malware is activated
during application execution and the application is killed or
functionality is disabled.
Static analysis frameworks attempt to analyze the appli-
cation before it executes to discover all potential sensitive
ﬂows [7–13]. Standard issues that complicate the construction
of such systems are the challenges of 1) scaling to large
applications and 2) maintaining precision in the analysis such
that it does not report too many ﬂows that do not actually
exist in the application. One particularly prominent issue with
developing static analyses for Android applications is the size,
richness, and complexity of the Android API and runtime,
which typically comprises multiple millions of lines of code
implemented in multiple programming languages. Because
sensitive ﬂows are often generated by complex interactions
between the Android application, API, and runtime, any static
analysis must work with an accurate model of this runtime to
produce acceptably accurate results.
Accuracy is critical for a static analysis seeking to cal-
culate security properties of an application; any inaccuracies
in the execution model provide a motivated attacker with the
opportunity to insert malicious ﬂows that will not be captured
by an analysis. Also, imprecision in a model could lead to
results that are unusable due to too many false positives;
another target for a motivated attacker. To the best of our
knowledge, the difﬁculty of obtaining an acceptably accurate
and precise Android model has signiﬁcantly limited the ability
of previous systems to successfully detect the full range of
malicious information ﬂows in Android applications.
Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23089
DroidSafe
We present a new system, DroidSafe, for accurately and
precisely analyzing sensitive explicit
information ﬂows in
large, real-world Android applications. DroidSafe tracks in-
formation ﬂows from sources (Android API calls that inject
sensitive information) to sinks (Android API calls that may
leak information). We evaluate DroidSafe on 24 complete real-
world Android applications that, as part of the DARPA Auto-
mated Program Analysis for Cybersecurity (APAC) program,
have been augmented with malicious information ﬂow leaks
by three hostile Red Team organizations. The goal of these
organizations was to develop information leaks that would
either evade detection by static analysis tools or overwhelm
static analysis tools into producing unacceptable results (by, for
example, manipulating the tool into reporting an overwhelming
number of false positive ﬂows). DroidSafe accurately detects
all of the 69 malicious ﬂows in these applications (while
reporting a manageable total number of ﬂows). A current state-
of-the-art Android information-ﬂow analysis system, Flow-
Droid [8] + IccTA [14], in contrast, detects only 6 of the 69
malicious ﬂows, and has a larger ratio of total ﬂows reported
to true malicious ﬂows reported.
Additionally, we evaluate DroidSafe on DROIDBENCH, a
suite of 94 Android information-ﬂow benchmarks from the
developers of FlowDroid and IccTA, and report the highest
accuracy (most actual ﬂows reported) and highest precision
(fewest false positive ﬂows reported) for this benchmark
suite to date, 94.3% and 87.6% respectively. DroidSafe fails
to report only the implicit ﬂows in DROIDBENCH. Finally,
we evaluate DroidSafe on a suite of 40 Android explicit
information-ﬂow benchmarks developed by us to add coverage
to DROIDBENCH; DroidSafe achieves 100% accuracy and
precision for the suite, compared to FlowDroid + IccTA’s
34.9% accuracy and 79.0% precision.
One advantage of working with applications that contain
known inserted malicious ﬂows is the ability to characterize
the accuracy of our analysis (i.e., measure how many malicious
ﬂows DroidSafe was able to detect). As these results illustrate,
DroidSafe implements an analysis of unprecedented accuracy
and precision. To the best of our knowledge, DroidSafe pro-
vides the ﬁrst usable information-ﬂow analysis for Android
applications [7–14].
The Android Model and Analysis Co-design
Given the extensive and complex interactions between the
Android execution environment and Android applications, an
accurate and precise information-ﬂow analysis for Android ap-
plications requires a comprehensive and accurate model of the
Android environment. To obtain such a model, we started with
the Android Open Source Project (AOSP) [15] implementation,
which contains a Java implementation of much of the Android
environment. The goal was to maximize accuracy and precision
by directly analyzing as comprehensive a model of Android as
feasible.
As we worked with AOSP, it quickly became apparent
that
the size and complexity of the Android environment
made it necessary to develop the model and the analysis
together as an integrated whole, with the design decisions in
the model and the analysis working together synergistically to
enable an effective solution to the Android static information-
ﬂow analysis problem. The result is the ﬁrst accurate and
precise model of the Android environment and the ﬁrst analysis
capable of analyzing such a model.
Accurate Analysis Stubs: While the AOSP provides an
accurate and precise model for much of Android, it is missing
critical parts of the Android runtime. And for good reason —
it is currently not practical to implement much of the Android
runtime in Java. We therefore developed a novel technique,
accurate analysis stubs, to enable the effective analysis of code
whose full semantics lies outside the scope of AOSP. Each stub
is written in Java and only incompletely models the runtime
behavior of the modeled code. But the semantics of the stub
is complete for the abstractions that the analysis deploys (in
this case points-to and information-ﬂow analyses). Examples
of semantics missing in the AOSP and added via accurate
analysis stubs include native methods; event callback initiation
with accurate context; component life-cycle events; and hidden
state maintained by the Android runtime and accessible to the
application only via the Android API.
Accurate analysis stubs simplify the development of the
analysis — they eliminate any need to develop a library of
method summaries written in a different speciﬁcation lan-
guage [16, 17], any need to conservatively hard code policies
within the analysis that attempt to compensate for the missing
semantics [8], or any need to analyze code written in multiple
languages. They also simplify the development of the model
— they enable the developers of the model to work ﬂexibly
and efﬁciently within the familiar implementation language.
And they support the use of sophisticated language features
such as inheritance, polymorphic code reuse, exceptions, and
threads, all of which promote effective engineering of stubs
that accurately and precisely model key aspects of the Android
environment.
In addition to code, accurate analysis stubs also support the
use of Java objects to model otherwise hidden state maintained
by the Android runtime. Examples of such state include
Android Activity saved state,
the global Application
object, Intent, Parcel, shared preferences, and the ﬁle
system. Accurate analysis stubs enable DroidSafe to be the
ﬁrst analysis to accurately model these key Android features.
The AOSP implementation overlaid with our accurate anal-
ysis stubs represents our model of the Android API and run-
time. We call this model the Android Device Implementation
(ADI). Each application is analyzed in the context of the ADI,
approximately 1.3 MLOC. For the information-ﬂow analysis,
we manually identiﬁed and classiﬁed 4,051 sensitive source
methods and 2,116 sensitive sink methods in the Android API.
Scalable, Precise Points-To Analysis: Both our Android
model and Android applications heavily use sophisticated
language features (such as inheritance and polymorphic code
reuse) that are known to signiﬁcantly complicate static pro-
gram analyses. To preserve acceptable precision, DroidSafe
therefore deploys a modern global object-sensitive points-
to analysis speciﬁcally designed to analyze code that uses
such features [18]. DroidSafe further enhances scalability by
identifying classes that are not relevant to the information ﬂow
and eliminating object sensitivity for instances of these classes.
This Android-speciﬁc optimization enables our global points-
to analysis to achieve a context depth greater than what was
achieved in prior work [18, 19], delivering a precise analysis
appropriately tailored for solving Android information-ﬂow
problems.
Flow-Insensitive Analyses: DroidSafe employs a ﬂow-
insensitive information-ﬂow analysis. Many interactions be-
tween Android applications and the Android environment
2
are mediated by asynchronous callbacks. Because our Droid-
Safe implementation uses ﬂow-insensitive points-to and
information-ﬂow analyses, it accurately considers all possible
runtime event orderings that asynchronous callbacks can trig-
ger. Developers of ﬂow sensitive analyses, in contrast, have had
difﬁculty obtaining a model that correctly exposes all of these
event orderings to a ﬂow sensitive analysis (see Section VIII).
Because the analysis does not consider all event orderings, it
may miss sensitive ﬂows.
Critically, ﬂow insensitivity also enables the analysis to
scale to analyze an accurate and precise Android model and
therefore to accurately and precisely track information ﬂows
through the Android environment. Scalability issues restrict
ﬂow-sensitive analyses to signiﬁcantly less accurate and pre-
cise Android models characterized by imprecise conservative
ﬂow summaries and/or blanket policies for Android API meth-
ods [8, 9, 11]. Our results show that the ability to analyze an
accurate and precise model more than makes up for any loss
of precision caused by ﬂow insensitivity (see Section VIII).
Static Communication Target Resolution: Information ﬂows
in Android apps may involve inter-component (between ap-
plication components) and inter-application (between separate
installed apps) communication; communication targets are
identiﬁed by dynamically constructed values (such as String,
Uri, and class designators) packaged in an Intent object.
To precisely analyze such ﬂows, DroidSafe combines 1) ac-
curate analysis stubs, 2) a internal representation of all deﬁned
IntentFilter registrations, 3) an analysis of operations that
construct strings; this analysis delivers regular expressions that
accurately summarize the strings that the application will con-
struct when it runs, 4) a novel points-to analysis that precisely
tracks Strings, and 5) algorithms that rewrite the DroidSafe
intermediate representation to directly invoke resolved targets.
Because DroidSafe works with a comprehensive model of
the Android environment, it supports precise resolution of
communication targets whose identiﬁcation (typically via an
Intent) involves signiﬁcant interactions with the Android
API.
These techniques enable DroidSafe to precisely analyze
calls that start Activity components; start, stop, and bind
Service components; invoke RPC calls on Service com-
ponents; send and receive Service messages; broadcast
messages to BroadcastReceiver components; and per-
form operations on ContentProvider components (shared
databases). For Intent-based resolution, DroidSafe incorpo-
rates IntentFilter registrations deﬁned both in the Android
manifest and those deﬁned programmatically in app code. We
are aware of no other analysis that can provide comparable
or even usable levels of accuracy or precision for all of these
critical Android communication mechanisms.