the STAT core waiting for events to be processed. The core is connected to a
CommSTAT proxy, which, in turn, is connected to a MetaSTAT instance. This
initial “bare” conﬁguration, which is presented in Figure 2 (a), does not provide
any intrusion detection functionality.
The ﬁrst step is to provide a source of events. To do this, an event provider
module must be loaded into the sensor. An event provider collects events from
Designing a Web of Highly-Conﬁgurable Intrusion Detection Sensors
75
the external environment (e.g., by parsing the Apache server logs, or by obtaining
packets from the network driver), creates events as deﬁned in one or more STAT
language extensions (e.g., the Apache language extension), encapsulates these
events into generic STAT events, and inserts these events into the input queue
of the STAT core. Event providers can be dynamically added to and removed
from a STAT core, and more than one event provider can be active at one time.
For example, both an event provider for Apache events and a Solaris BSM audit
record provider may feed their event streams to the same core. An event provider
is implemented as a shared library. The activation of an event provider is done
through MetaSTAT by requesting the shipping of the event provider shared
library to the sensor and then requesting its activation. An event provider relies
on the event deﬁnitions contained in one or more language extension modules. If
these are not available at the sensor’s host, these have to be shipped there as well.
Once both the event provider and the language extensions are available at the
remote host, the event provider is activated. As a consequence, a dedicated thread
of execution is started to execute the event provider. The provider collects events
from the external source, ﬁlters out those that are not of interest, transforms
the remaining events into event objects (as deﬁned by the language extension),
encapsulates them into generic STAT events, and then inserts them into the core
input queue. The core, in turn, consumes the events and checks if there are any
STAT scenarios interested in the speciﬁc event types. At this point, the core is
empty, and therefore no actual processing is carried out. This conﬁguration is
described in Figure 2 (b).
To start doing something useful, it is necessary to load one or more scenario
plugins into the core. To do this, ﬁrst a scenario plugin module, in the form
of a shared library, is transferred to the sensor’s host. A plugin may need the
functions of one or more language extension modules. If these are not already
available at the destination host then they are shipped there as well. Once all
the necessary libraries have been transferred to the sensor’s host, the plugin is
loaded into the core, specifying a set of initial parameters. When a plugin is
loaded into the core an initial prototype for the scenario is created. The scenario
prototype contains the data structures representing the scenario’s deﬁnition in
terms of states and transitions, a global environment, and a set of activation
parameters. The prototype creates a ﬁrst instance of the scenario. This instance
is in the initial state of the corresponding attack scenario. The core analyzes the
scenario deﬁnition and subscribes the instance for the events associated with the
transitions that start from the scenario’s initial state.
At this point the core is ready to perform event processing. The events ob-
tained by the provider are matched against the subscriptions of the initial in-
stance. If an event matches a subscription, then the corresponding transition
assertion is evaluated. If the assertion is satisﬁed then the destination state as-
sertion is evaluated. If this assertion is also satisﬁed then the transition is ﬁred.
As a consequence of transition ﬁring the instance may change state or a new in-
stance may be created. Each scenario instance represents an attack in progress.
The details of scenario processing are described elsewhere [8]. This situation is
76
G. Vigna, R.A. Kemmerer, and P. Blix
presented in Figure 2 (c), where a scenario plugin has been loaded and there are
currently four active instances of the scenario.
As a scenario evolves from state to state, it may produce some output. A
typical case is the generation of an alert when a scenario completes. Another
example is the creation of a synthetic event. A synthetic event is a STAT event
that is generated by a scenario plugin and inserted in the core event queue. The
event is processed like any other event and may be used to perform forward
chaining of scenarios.
Apart from logging (the default action when a scenario completes) and the
production of synthetic events (that are speciﬁed internally to the scenario def-
inition), other types of responses can be associated with scenario states using
response modules. Response modules are collections of functions that can be used
to perform any type of response (e.g., page the administrator, reconﬁgure a ﬁre-
wall, or shutdown a connection). Response modules are implemented as shared
libraries. To activate a response function it is necessary to transfer the shared
library containing the desired response functionality to the sensor’s host, load
the library into the core, and then request the association of a function with a
speciﬁc state in a scenario deﬁnition. This allows one to specify responses for any
intermediate state in an attack scenario. Each time the speciﬁed state is reached
by any of the instances of the scenario, the corresponding response is executed.
Responses can be shipped, loaded, activated, and removed remotely through the
MetaSTAT component. Figure 2 (d) shows a response library and some response
functions associated with particular states in the scenario deﬁnition.
At this point, the sensor is conﬁgured as a full-ﬂedged intrusion detection
system. Event providers, scenario plugins, language extensions, and response
modules can be loaded and unloaded following the needs of the overall intrusion
detection functionality. As described above, these reconﬁgurations are subject to
a number of dependencies that must be satisﬁed in order to successfully load a
component into the sensor and to have the necessary inputs and outputs available
for processing. These dependencies are managed by the MetaSTAT component,
and they are discussed in the next section.
4 Module Dependencies and Sensor Conﬁgurations
The ﬂexibility and extendibility supported by the STAT-based approach is a ma-
jor advantage: the conﬁguration of a sensor can be reshaped in real-time to deal
with previously unknown attacks, changes in the site’s policy, diﬀerent levels
of concern, etc. Fine-grained conﬁgurability requires careful planning of module
installation and activation. This activity can be very complex and error-prone if
carried out without support. For this reason the MetaSTAT component main-
tains a database of modules and their associated dependencies and a database of
the current sensor conﬁgurations. These databases provide the support for con-
sistent modiﬁcations of the managed web of sensors. In the following, the term
module is used to denote event providers, scenario plugins, response modules,
and language extensions. The term external component is used to characterize
Designing a Web of Highly-Conﬁgurable Intrusion Detection Sensors
77
some host facility or service that is needed by an event provider as a source
of raw events or by a response function to perform some action. These compo-
nents are outside the control of MetaSTAT. For example, a BSM event provider
needs the actual BSM auditing system up and running to be able to access audit
records and provide events to the STAT core.
Dependencies between modules can be classiﬁed into activation dependen-
cies and functional dependencies. Activation dependencies must be satisﬁed for
a module to be activated and run without failure. For example, consider a sce-
nario plugin that uses predicates deﬁned in a language extension. The language
extension must be loaded into the core before the plugin is activated. Otherwise,
the plugin activation will fail with a run-time linking error. Functional depen-
dencies are associated with the inputs of a module. The functional dependencies
of a module are satisﬁed if there exist modules and/or external components that
can provide the inputs used by the module. Note that a module can success-
fully be activated without satisfying its functional dependencies. For example,
suppose that a scenario plugin that uses BSM events has been successfully acti-
vated, but there is no BSM event provider to feed the core with BSM events. In
this case, the scenario is active but completely useless. The inputs and outputs
of the diﬀerent module types, and the relative dependencies are summarized in
Table 1.
Table 1. Input and output, and dependencies of STAT sensor modules.
Module
Event Provider
Scenario Plugin
Inputs
External
event stream
STAT events,
synthetic
events
Response Module Parameters
from plugin
None
Language Exten-
sion
Outputs
Functional Deps
STAT events Extension modules External compo-
Activation Deps
Synthetic
events
External
response
None
nents
Extension modules Scenario plugins,
Event providers
Extension modules External compo-
nents
Extension modules None
Information about dependencies between modules is stored in MetaSTAT’s
Module Database. The schema of the Module Database is shown in Figure 3.
The functional dependencies for a module are partly modeled implicitly by
matching the inputs required by the module with the outputs provided by some
other module. Determining the functional dependencies on other modules re-
quires that two queries be made on the Module Database. The ﬁrst query gets
the inputs required by the module from the Module Input table. The second
query examines the Module Output table to determine which modules are gen-
erating the inputs that were returned from the ﬁrst query. The results returned
from the second query identify the modules that satisfy the functional depen-
dencies of the original module. The functional dependencies on external compo-
78
G. Vigna, R.A. Kemmerer, and P. Blix
Binary
module id
path
filename
module id
1:1
Module Index
module id
type
name
version
os platform
description
Plugin State
module id
state name
Plugin Parameter
module id
path
filename
conf id
Response Function
module id
function name
module id
N:1
module id
N:1
module id
N:1
module id
1:N
module id
1:N
module id
1:N
module id
1:N
Activation Dependency
module id
dep module id
Module Output
module id
output type
output id
Module Input
module id
input type
input id
Functional Dependency
module id
external component id
Dependency Information
Fig. 3. Schema for the Module Database.
nents are modeled explicitly by the Functional Dependency table. In addition
to dependencies, the Module Database also stores information such as version,
OS/architecture compatibility information, etc.
The Module Database is used by MetaSTAT to automatically determine the
steps to be undertaken when a sensor reconﬁguration is needed. Since sensors
do not always start from a “bare” conﬁguration, as shown in Figure 2 (a), it
is usually necessary to modify an existing sensor conﬁguration. Therefore, the
MetaSTAT component maintains a second database called the Sensor Database,
which contains the current conﬁguration for each sensor. A visualization of the
Sensor Database schema is given in Figure 4.
To be more precise, the term conﬁguration is deﬁned as follows: A STAT sen-
sor conﬁguration is uniquely deﬁned by a set of installed and activated modules
and available external components. The term installed is used to describe the
fact that a module has been transferred to and stored on a ﬁle system accessible
by the sensor and in a location known by the sensor. The term activated is used
to describe the fact that a module has been dynamically loaded in a sensor as
the result of a control command from MetaSTAT. The term loaded has the same
meaning as activated in relation to language extension modules.
Designing a Web of Highly-Conﬁgurable Intrusion Detection Sensors
79
Installed Plugin
Conf
sensor  id
module  id
conf  id
N:1
Installation Index
sensor id
module id
sensor id
N:1
sensor id
N:1
Sensor Index
sensor id
sensor address
sensor port
sensor platform
d
i
r
o
s
n
e
s
1
:
N
sensor id
1:N
External Component
sensor id
external component id
Activated module
sensor id
module id
module type
Activation information
Activated plugin
sensor id
module id
conf id
prototype id
1:N
Activated response function
sensor id
module id
function name
state name
plugin id
scenario prototype id
Fig. 4. Schema for the Sensor Database.
A conﬁguration can be valid and/or meaningful. A conﬁguration is valid if
all activated modules have all their activation dependencies satisﬁed. A conﬁgu-
ration is meaningful if the conﬁguration is valid and all functional dependencies
are also satisﬁed.
5 Automated Support for Sensor Reconﬁgurations