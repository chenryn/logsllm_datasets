## 进程树既然所有的进程都是从父进程 fork过来的，那总归有一个祖宗进程，这就是咱们系统启动的 init 进程。![](Images/1a06824dda6b10b5043e8e7bca0adec5.png){savepage-src="https://static001.geekbang.org/resource/image/4d/16/4de740c10670a92bbaa58348e66b7b16.jpeg"}在解析 Linux 的启动过程的时候，1 号进程是 /sbin/init。如果在 centOS 7里面，我们 ls 一下，可以看到，这个进程是被软链接到 systemd 的。    /sbin/init -> ../lib/systemd/systemd系统启动之后，init 进程会启动很多的 daemon进程，为系统运行提供服务，然后就是启动 getty，让用户登录，登录后运行shell，用户启动的进程都是通过 shell 运行的，从而形成了一棵进程树。我们可以通过 ps -ef 命令查看当前系统启动的进程，我们会发现有三类进程。    [root@deployer ~]
# ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0  2018 ?        00:00:29 /usr/lib/systemd/systemd --system --deserialize 21root         2     0  0  2018 ?        00:00:00 [kthreadd]root         3     2  0  2018 ?        00:00:00 [ksoftirqd/0]root         5     2  0  2018 ?        00:00:00 [kworker/0:0H]root         9     2  0  2018 ?        00:00:40 [rcu_sched]......root       337     2  0  2018 ?        00:00:01 [kworker/3:1H]root       380     1  0  2018 ?        00:00:00 /usr/lib/systemd/systemd-udevdroot       415     1  0  2018 ?        00:00:01 /sbin/auditdroot       498     1  0  2018 ?        00:00:03 /usr/lib/systemd/systemd-logind......root       852     1  0  2018 ?        00:06:25 /usr/sbin/rsyslogd -nroot      2580     1  0  2018 ?        00:00:00 /usr/sbin/sshd -Droot     29058     2  0 Jan03 ?        00:00:01 [kworker/1:2]root     29672     2  0 Jan04 ?        00:00:09 [kworker/2:1]root     30467     1  0 Jan06 ?        00:00:00 /usr/sbin/crond -nroot     31574     2  0 Jan08 ?        00:00:01 [kworker/u128:2]......root     32792  2580  0 Jan10 ?        00:00:00 sshd: root@pts/0root     32794 32792  0 Jan10 pts/0    00:00:00 -bashroot     32901 32794  0 00:01 pts/0    00:00:00 ps -ef你会发现，PID 1 的进程就是我们的 init 进程 systemd，PID 2的进程是内核线程kthreadd，这两个我们在内核启动的时候都见过。其中用户态的不带中括号，内核态的带中括号。接下来进程号依次增大，但是你会看所有带中括号的内核态的进程，祖先都是 2号进程。而用户态的进程，祖先都是 1 号进程。tty那一列，是问号的，说明不是前台启动的，一般都是后台的服务。pts 的父进程是 sshd，bash 的父进程是 pts，ps -ef 这个命令的父进程是bash。这样整个链条都比较清晰了。
## 总结时刻这一节我们讲了一个进程从代码到二进制到运行时的一个过程，我们用一个图总结一下。我们首先通过图右边的文件编译过程，生成 so文件和可执行文件，放在硬盘上。下图左边的用户态的进程 A 执行fork，创建进程 B，在进程 B 的处理逻辑中，执行 exec系列系统调用。这个系统调用会通过 load_elf_binary方法，将刚才生成的可执行文件，加载到进程 B 的内存中执行。![](Images/76e54b7d0032370ee85e0c0ee147b280.png){savepage-src="https://static001.geekbang.org/resource/image/db/a9/dbd8785da6c3ce3fe1abb7bb5934b7a9.jpeg"}
## 课堂练习对于 ELF，有几个工具能帮你看这些文件的格式。readelf 工具用于分析 ELF的信息，objdump 工具用来显示二进制文件的信息，hexdump工具用来查看文件的十六进制编码，nm工具用来显示关于指定文件中符号的信息。你可以尝试用这几个工具，来解析这一节生成的.o,.so 和可执行文件。欢迎留言和我分享你的疑惑和见解，也欢迎你收藏本节内容，反复研读。你也可以把今天的内容分享给你的朋友，和他一起学习、进步。![](Images/1a5564dd4e1c9f25d4772c7f844ca84a.png){savepage-src="https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg"}
# 11 \| 线程：如何让复杂的项目并行执行？上一节我们讲了如何创建进程，这一节我们来看如何创建线程。