# HWS计划2021硬件安全冬令营线上选拔赛部分Wp
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
二进制专场，Reverse做完了，内核安全做了1个，固件安全做了3个。总的来说，题目难度不是很大，但考点挺不错的，个人感觉还行。
## Reverse
###  decryption
拿了二血。逆向方向的签到题，直接穷举。
    #include 
    unsigned char enc[] =
    {
       18,  69,  16,  71,  25,  73,  73,  73,  26,  79, 
       28,  30,  82, 102,  29,  82, 102, 103, 104, 103, 
      101, 111,  95,  89,  88,  94, 109, 112, 161, 110, 
      112, 163
    };
    int main(void)
    {
        int i = 0, j = 0;
        for(i = 0; i 
    unsigned char op1[] =
    {
      198, 6, 38, 70, 102, 134, 166, 198, 231, 7, 
      38, 38, 70, 102, 134, 166
    };
    unsigned char op2[] =
    {
      42, 253, 103, 31, 159, 97, 45, 212, 252, 56, 
      118, 164, 182, 197, 194, 141
    };
    unsigned char mem[] =
    {
      33, 35, 47, 41, 122, 87, 165, 167, 67, 137, 
      74, 14, 74, 128, 31, 195
    };
    unsigned char xor1[] =
    {
      110, 214, 206, 97, 187, 143, 183, 243, 16, 183, 
      112, 69, 158, 252, 225, 177
    };
    unsigned char key[] =
    {
      140, 229, 31, 147, 80, 244, 69, 17, 168, 84, 
      225, 181, 240, 163, 251, 202
    };
    unsigned char xor2[] = {236, 251, 65, 89, 249, 231,
                     139, 18, 27, 63, 80, 130, 240, 163, 68, 43};
    unsigned char ans[] = {192, 92, 50, 87, 127, 219,
                     63, 77, 148, 184, 254, 19, 7, 227, 85, 38};
    int main(void)
    {
        int i = 0, j = 0;
        for(i = 0; i 
    int main(void)
    {    
        unsigned char a[16] = {0x2c, 0xa7, 0x73, 0xe, 0x86, 0x3c, 0xb4, 0x5f,
                     0x8f, 0x87, 0xae, 0x91, 0xf7, 0x40, 0x11, 0xd};
        int i = 0;
        unsigned char flag[16] = {0};
        flag[15] = (a[15] > 5)&7); 
        for(i = 0; i > 5)&7); 
        }
        for(i = 0; i  而一般程序中要么把设置的异常处理函数用来检测程序是否处于调试状态；要么隐藏程序的关键代码，让我们执行不到。
对于触发 **SetUnhandledExceptionFilter** 的条件，一般程序在调用
**SetUnhandledExceptionFilter**
后会有故意触发异常的代码，本题就是靠后面的执行无效指令进行触发。而程序是否处于调试状态其实是若出现的异常传递给了程序，程序先调用UnhandledExceptionFilter，而UnhandledExceptionFilter里面又调用了
**ZwQueryInformationProcess**
进行反调试检测，设置改函数的第二个参数为7，看执行完该函数后第三个参数指向的缓冲区是否为0，若不为0则程序处于调试状态，其实就是看有没有调试端口。
程序载入OD，设置忽略异常，ctrl+g，输入函数名字来到 **ZwQueryInformationProcess** 函数，然后下断。
从栈窗口看到第2个参数为7，那就是要找的了，回溯到调用处，在函数执行完后将相应的缓存区的值改为0即可（若程序多次出现这种触发异常的跳转，那我们简单在执行完这个函数后hook一下程序方便些，本题的话直接把后面的je改为jmp就好了）。继续执行，就到了我们想执行的函数了。
而我做本题的时候并没有去过这个反调试，使用的附加调试，然后简单调试了下那个设置为异常处理的函数，发现后面还要触发异常就开始静态分析。
首先找到引用最后存放加密数据数组的地方：很明显它上下其实是代码的。
手动转化一下上面的数据为代码，加上之前调试了下设置异常处理函数，然后很容易发现，代码中有很多用来触发异常的数据（0x0c7,
0xff，且后面跟着2个或3这操作数）。
又在分析循环代码是发现循环计数器每次没有变，那岂不无限循环，从这里又进而发现，程序每次触发异常跳到设置的异常处理函数的目的：获取当前的eip，修改寄存器的值，修改eip。
各种opcode的功能：
剩下的把相应的触发异常的代码替换为实际的操作，因为加密不复杂，直接看汇编代码分析下就好了。
首先一个通过指定的index进行一个置换操作，然后典型的移位或加密，最后一个异或。
    #include 
    unsigned char ind[50], ans[50], tmp;
    unsigned char enc[] = {147, 139, 143, 67, 18, 104, 247,
                         144, 122, 75, 110, 66, 19, 1, 180, 33, 32, 115, 141, 104,
                         203, 25, 252, 248, 178, 107, 196, 171, 200, 155, 141, 34};
    char key[] = "Bier";
    int main(void)
    {
        int i = 0;
        char flag[100] = {0};
        for(i = 0; i > 3) | (enc[31] > 3) | (enc[i-1] << 5);
        }
        /*for(i = 0; i < 32; i++)
        {
            printf("%02x ", ans[i]);
        }*/
        for(i = 0; i < 32; i += 2)
        {
            flag[ind[i+1]] = ans[ind[i]];
            flag[ind[i]] = ans[ind[i+1]];
        }
        puts(flag);
    } 
    //B0mb3_L0nd0n_m0rg3n_um_v13r_Uhr.
###  babyre
拿了二血。
程序其实利用调用号hook了系统调用r3到r0的转接层，所以从下图中的v11函数指针其实是去执行出题人自己设置的函数。
简单跟进行一下v11指向的函数：开始对字符解密得到模块和函数名，就是为了得到函数 **NtSetInformationThread** 来进行反调试。
对于这个反调试之前总结过：
这里要过它直接patch掉就好了。
然后就是一些加载dll和函数代码解密相关的操作，做题时节省时间没管，现在还是看看：
使用资源查看工具，找到程序资源中改dll，明显看到是需要进行解密的，也就是后面的操作。