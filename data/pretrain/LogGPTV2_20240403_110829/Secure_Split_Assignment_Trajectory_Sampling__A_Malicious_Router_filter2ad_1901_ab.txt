PR: a set of prime numbers, where primei  E PR is the i-th element 
Nrouter: the number of routers in Stotal 
N ~ m a l l  = Nrouter - 1; Niotal = N ~ m a l l l ~ s a m p ;  
Ntotal = rninz(primei), primei  2 Niotal; 
Nsmatl=L(Ntotal X  psamp)J; 
for each pair of routers (ri,rj),   ) 
Figure 3. Split Range Assignment algorithm. 
signed the same sampling range, such as the hash value 4 in 
{rz7 r6} in Figure 2.(b).  If all the routers have different sam- 
pling ranges (as with random sampling), we cannot compare 
samples from one router with samples from any other routers. 
We assign different sampling ranges as follows.  A router 
shares one hash value with each router in a network.  Thus, if 
there are Nroute, routers in the network, Nsmall = Nrouter - 
1 hash values are assigned to a router.  Given psamp, we find 
Nsmall and Ntotal  for the selection hash function as shown in 
= 6/31 and NrOuter = 7 
Figure 3. For cxample, with p,,,, 
routers in the network (Figure 2.@)), NtOtal = 31, which is 
the smallest prime number greater than or equal to (Nrouter - 
l ) / p s a m p  = 31. Then Nsmatt  = LNtotal  x ps,mP]  = 6 hash 
values are assigned to each router in a way that one router has 
one hash  value in common with each of  the other 6 routers. 
For instance, rl  shares the  hash values  13, 2, 25, 30, 5 and 
9 with rz, 7-3,  7-4, r g ,  1-6  and r 7 ,  respectively. We evaluate the 
detection rate of this assignment method in Section 6.1 and we 
show that the probability that an attacker can avoid detection 
is fairly low. 
Split Range Assignment also ensures that SATS is able to 
trace packets in case routing changes. On any given path, each 
pair of routers have at least one common hash value. Thus, we 
can compare samples from one router with samples from any 
other routers. 
4.3. Inconsistent Trajectories 
Split Range Assignment prevents malicious routers from 
tampering with  the sampling process.  Sampled packets  are 
then reported to the backend engine, where the trajectories of 
the packets  are reconstructed.  The trajectories are then  fed 
into the  SATS detection process.  We  first provide the main 
premise  of  the  SATS detection process.  We  then elaborate 
each step in detail in the following sections. 
The main premise of the SATS detection process is that if 
packets are manipulated, the resulting trajectories will not be 
consistent with the predicted trajectories. Figure 4 shows the 
predicted and resulting trajectories of a packetp, which is sup- 
posed to go from an ingress node ri-2  to an egress node ri+3. 
The label of p  is I  = htabel (p). The predicted trajectory of p 
is shown in Figure 4.(a).  If p  is dropped at a node ri (Figure 
4.@)),  the trajectory of p,  tnorm,l,  ends at r i  before reaching 
its egress node.  If p  is modified to pf at rc  (Figure 4.(c)), the 
trajectory for the label I, tnOr,,l, 
also ends prematurely at r i  
since the label is changed to I'  = h l a k l ( p f )  before p  is for- 
warded to ri+l. In the case of modification, a new trajectory, 
torphan. for the new label I'  starts from ri+l  if h s e l e d i m ( f l )  
falls in the sampling range.  We  refer to the new trajectory as 
an orplan trajectory as opposed to a normal trajectory since 
the new trajectory has no wigination point, that is, no ingress 
router reported the trajectory's label, 1'.  When torphan 
is dis- 
carded, the two early ended normal trajectories, tnOrmal 
's, in 
(b) and  (c) look  the same.  Consequently,  we use  the early 
ending of  a normal trajectory as a clue to detect both packet 
dropping and modification. Orphan trajectories are discarded 
since we already have a way to detect anomalies. Substitution 
of a packet for another packet yields two modified packets and 
is thus detected as well. 
In Split Range Assignment, a packet p sampled from a hash 
value h is not sampled at all the routers on the path. Thus, the 
trajectory t of p has holes on the routers with hash values other 
than IL. If t has a hole in any of the routers where h is assigned, 
the trajectory is inconsistent. t is an orphan trajectory if t has a 
hole in the first router where IL is assigned on p's path. In [lo], 
we have shown  that  SATS can perfonn  traffic measurement 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:59 UTC from IEEE Xplore.  Restrictions apply. 
rja 
6.1 
Ti 
~@j-.o"@-o+o+@$ 
r1+3 
ria 
+ 
Egress Router 
Ingress Router 
(a)  : 
1 
t: 
Figure  4.  The  predicted  trajectory  of  a  packet  p 
(a)  and the  resulting trajectories of  p  when p was 
dropped at node ri  (b) and when p was modified at 
node ri  (c). 
functions of TS even with holes in trajectories. 
Because of space, we focus on the detection of packet drop- 
ping,  modification  and substitution in  the rest  of  this paper. 
The detection of  routing loops and reordering attacks is de- 
scribed in  detail  in  the  technical report  version  of  this  pa- 
per [lo]. Briefly, if trajectories intersect themselves, we report 
them as routing loops; we detect packet reordering attacks by 
comparing the time-ordered list of  labels from a router with 
the list from another router with the same sampling range. 
4.4. Aggregation of Multiple Trajectories 
At the end of  each measurement interval, trajectories are 
aggregated into  the  same flow,  which is defined as the  tra- 
jectories with the same ingress router and destination routing 
prefix pair.  Based on each aggregation rather than each tra- 
jectory, we make a decision concerning anomalies.  The ag- 
gregation is done mainly for two reasons.  First, running one 
detection process for each set of aggregated trajectories scales 
better than running one detection process for each trajectory, 
especially in a high load situation where thousands of  pack- 
ets are sampled each second.  Second, the aggregation helps 
us  use  a threshold to differentiate between legitimate packet 
drops and malicious attacks. We do not raise an alarm for each 
inconsistent trajectory, which might be caused by congestion 
or an  error in the packet header1. Instead, we raise an  alarm 
only when the number of inconsistent trajectories in an aggre- 
gation is more than the threshold.  Setting the threshold de- 
pends on the network.  For example, legitimate packet losses 
in wireless networks are much more likely than in wired net- 
works.  Thus, the threshold must be determined accordingly. 
Also, the threshold has to be changed adaptively according to 
the average traffic volume.  The number of samples collected 
from a link and  the link capacity can help to predict the  le- 
gitimate packet loss ratio and can thus help to determine the 
threshold. 
In  order to identify the flow  of  a normal trajectory t, we 
'The  loss of report packets en route to the backend  engine can also cre- 
ate incomplete trajectories. [3] provides a way  to infer the packet  loss rate 
from the report loss rate. The report loss rate is estimated from the sequence 
numbers canied by report packets. 
ti [rj]: If a trajectory ti has s report from r j ,  ti[r.j] = 1. If not, ti [rj] = 0 .  
X ( i ) :  a set of NSmaa hash values in the sampling range assigned t o r i  
CPrim[hj][ri]: 
SslLspect: a set of slrspicious routers 
I/ Aggregation algorithm 
for each normal trajectory t i  sampled from a hash value h in a flow: 
the primary counter for the hash value hj of ri 
for each router rj on the path. 
if (ti[rj] = 1 and h E ?i(i)) then Cp,i,[h]lrj] = Cprim[h]brj] + 1; 
11 Detection and Pinpointing algorithm 
for each node rt in the flow: 
for each hash value hk  E 'H(1): 
if  ((Cprim [hk] [ ~ l ]  - Cprirn [hkl [rr]) > THprim) then 
11 rr is the closest node to rl  in the flow, where W(r)  3 hk and r > 1 
Ssuspect  = Ssuspect  U (7s  : 1 5 s I T I ;  
Figure 5. Aggregation and Detection algorithms. 
need to know both the ingress router and the destination rout- 
ing prefix.  We  use the key  reported from the ingress router 
since the key includes the destination routing prefix. However 
in Split Range Assignment, t may have a hole in the ingress 
router. Thus, we have all routers, not only the ingress routers, 
report a key for each sampled packet.  The key has to include 
the source IP and the destination routing prefix. We then iden- 
tify the ingress router of t through another trajectory t'  that 
does not have a hole in its ingress router.  The ingress router 
of t'  is the  same one for t if  t'  has the same source IP and 
destination prefix as those oft. 
Figure 5 shows the pseudo code of  the aggregation algo- 
rithm. The aggregation process can be thought of as overlay- 
ing of  trajectories one after another.  In the backend engine, 
we maintain a primary  counter, Cprim, for each hash  value 
assigned to each node on the path.  C,,i, 
[h] counts the num- 
ber of  normal trajectories sampled from a hash  value h in a 
node.  Thus, if  some of  the trajectories end prematurely at a 
node r, then Cpri, decreases for nodes beyond the node r in 
the path.  If  the decline is more than the threshold THPri,, 
the aggregation is marked as an anomalous one. Dropping of 
packets below the threshold can avoid detection, but the attack 
would not be more significant than temporary congestion. 
Figure  6 illustrates  an  example of  the  aggregation algo- 
rithm.  The number in  the parentheses next to a trajectory is 
the hash value where the trajectory is sampled.  The primary 
counter values are shown at the bottom.  We  assume that the 
hashes of the six trajectories are distributed into three differ- 
ent hash values, 3,s and 6. A trajectory sampled from a hash 
value  h has  "holes"  on  the routers where  h is not assigned. 
However, the aggregation of trajectories shows the complete 
path followed by the packets in the flow, which is the predicted 
trajectory of the packets. A malicious router, rg. modifies half 
of the packets, b, d and f .  The modified packets result in three 
orphan trajectories, {ti; ti; t;).  The orphan trajectories are 
then discarded during the aggregation, since we already have 
a way to detect anomalies as shown by the early ending of nor- 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:59 UTC from IEEE Xplore.  Restrictions apply. 
hash values in sampling range/  0.2a3) 
: 
l1,4.5) 
/ 
(2,4,6) 
j 
[3,5,6) 
: 
' 
tl  .5 
! t,forlaMG 
j  ta 
Trajectories for packet a (3) 
i . . .  1  ............. 1 ......................... i .........................  ......... t.1 ............. i 
................................................................ 
1 " for'abe' 
for'?@!.[" 
............. I4 
Trajectories for packet b (3) 
, 
......................................................... 
.......... 
i  to 
I  t,  for label Ii 
Traiectories tor DaCket c  (5) 
i 
...... : ......................... : ................... : ........ .; ............................ :. ....... +.! ............ i ........................... i ........ 1 .......... i 
Trajectories for packet d (5)  ; 
......-..... 
...................................................................... 
....................... 
! 
! 
/ 
.................. j ........................... i ........... +.? ........... ; ......... *I .......... 5 
Trajectories for packet e (6) 
.......................................................................... 
i 
Traiectories for ~acket f (6) 
i 
...........................  ...........................  ......... 
: tc forlabel LC: 
.
.
i td for label I 
i a1  ti. 
...... 
........ 
zb.for.!a_klIG 
........ 
......................... 
i  BQ 
it.forlabel1, 
it.forlabel1 
: : tr far labellt  i  tifor!akel1d 
....... 
.
n
.
j 
Primary Counter, cmm[5j 
Primarycoonter, Cm[6] 
' 
/ 
N,a 
i 
i 
M A  
i 
i 
j 
1 
2 
1 
i 
j 
Figure 6.  Aggregation of Trajectories. 
,Suspicious  Region 
Figure 7. An example of a suspicious region. 
rj reported correctly that it had not seen the packets.  rj did 
not report the dropped packets to the backend engine.  Alter- 
natively,  when  there are consecutive malicious routers,  one 
of  the previous nodes rl  E {r,  : 1  5  n  < i)  dropped the 
packets, the following nodes from rl+l to ri misinformed the 
backend engine that they had observed the packets and finally 
rj reported correctly. 
Scenario 2:  rj  is malicious.  ri  forwarded the packets cor- 
rectly, but rj did not report the packets to the backend engine. 
rj may or may not have dropped the packets. 
Scenario 3: One of the routers between ri and rj (i.e.,  r,  E 
{r, : i + 1 5 n j j - 1)) dropped the packets. The hashes of 
the dropped packets do not fall in the sampling ranges of any 
routers between r,  and rj, S,,,  = {r, : m 5 n < j - 1). In 
other words, the packets under attack are not supposed to be 
sampled at any of the routers in S,,,. 
for Snon 
do not decrease. On the other hand, the hashes of the packets 
fall in the sampling range of rj, and Cpri, for rj decreases. 
Thus, C,,i,'s 
In all three scenarios, one of the routers in SSuSPidOUS must 
be faulty. To further reduce the size of SSuSPidOUS, we assign 
the hash value h that is common in the sampling ranges of (ri, 
r j )  to the routers between (ri, r j )  [I 01. 
mal trajectories, itb7 td. t  ). As the normal trajectories of  b, 
d and f, {tb, t d ;  t f  ). end at rg, they do not increment Cprzm7s 
for nodes beyond 1-3.  Thus, when the normal trajectories are 