• Can suspend a process, freezing all its threads so they do nothing;
• Can see which thread in a process is maxing out the CPU.
NB: It is advisable to use Process Explorer alongside the Process Monitor because Process Explorer provides some features
which enable the analyst to interact with the process to analyse further the behaviour of the malicious process.
For a quick review of the system and the running processes, Process Explorer has an option enabling the
analyst to look up all hashes on VirusTotal and display the number of detections. For example, in the picture
presented below, the user can see that the process name ‘malware.exe’ (which is the child process of
‘explorer.exe’) has 61 out of 70 detections, showing a high probability that this application is malicious.
Examining the Properties windows (opened when the user double-clicks on the process), shown on the right side
of the picture, can provide another set of useful information, for example, the user under which the process is
running, strings in the memory, active threads, active network connections that the malware is initiating and the
full path of the executable on the disk.
FIGURE 22: PROCESS EXPLORER – ‘MALWARE.EXE’ PROPERTIES
Process Explorer is part of the SysInternals Suite package and, at the time of writing, can be downloaded
from the following website: https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer
28
Regshot
Regshot is a tool that allows an analyst to perform two snapshots of the Windows Registry (before and
after the infection) in order to identify what changes have been made in the registry or what files were dropped
by the malicious executable. Afterwards, the analyst can use this information to create an IoC.
The GUI of the Regshot tool is presented in the picture below:
Regshot usage steps:
1. Take the first shot of the system’s registry
when the system is clean.
2. Run the malware sample.
3. Take the second shot of the system’s registry
after infection.
4. Press the ‘Compare’ button in order to
compare the two generated snapshots.
5. Analyse the report generated.
6. Start over on a new, clean system.
FIGURE 23: REGSHOT – SNAPSHOT SEQUENCE
In the example presented below, after running and comparing the second shot with the first one made
when the system was clean, the analyst has identified that the executable ‘malware.exe’ creates data in the
registry at ‘HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\malware’:
‘C:\WINDOWS\SysWOW64\malware.exe’ to gain persistence on the system. Checking the entire registry report,
which keeps track of all changes that occur, will help to give the analyst a clear picture regarding the behaviour
of the malicious application.
FIGURE 24: REGSHOT – SNAPSHOT REPORT
At the time of writing, the Regshot tool can be downloaded from the following website:
https://sourceforge.net/projects/regshot
29
INetSim
INetSim is a Linux-based software suite that allows the user to simulate multiple standard Internet services
on a virtual machine used for investigations. By using this tool, the analyst can monitor the network behaviour
of the malware sample without connecting it to the Internet. If you are carrying out the investigations in
Windows, the easiest way of using this tool is to use the Linux VM (where the INetSim tool is configured and
running) as a gateway for the Windows VM. The setup of the tool is presented in the picture below:
FIGURE 25: INETSIM – SETUP
After running the tool, the image on the left illustrates
all the services emulated by INetSim, including their
default port.
In order to change the configuration setup of
the tool for adding or removing services, the user has
to modify the file ‘etc/inetsim/inetsim.conf’.
When running, INetSim records all
inbound/outbound connections, so the analyst can
build IOCs based on the connections that the
malicious file is trying to make.
FIGURE 26: INETSIM – RUNNING SERVICES OUTPUT
At the time of writing, the Regshot tool can be downloaded from the following website:
https://www.inetsim.org/downloads.html
30
5.3 Sandboxing
To limit the spread of infection and protect their environment, malware analysts run the malware sample
inside a sandbox solution. Sandbox tools usually offer the option to dump the process memory, so the analyst
can have a better picture of what is happening in the RAM.
Malware authors know that, if their malware sample is running inside a virtual machine or sandbox solution,
it is likely that the sample is being analysed by a reverse engineer or automated solution, so they usually
implement a different check. For more information regarding the types of checks that the malware may
implement, please check the section on malware self-protection in Chapter 2.
Multiple free sandboxing solutions, where an analyst can upload the sample and wait for the report, are
available on the Internet. At the time of writing, the best-known are:
- www.malwr.com
- www.hybrid-analysis.com
- www.any.run
- www.joesandbox.com
- www.cuckoosandbox.org
- www.sandbox.anlyz.io
- www.analyze.intezer.com
Cuckoo Sandbox
This handbook will present features and specifications of Cuckoo Sandbox because this sandbox is
known as the leading open-source automated malware analysis system. Using the sandbox, analysts can
automate the task of analysing any malicious file under Windows, macOS, Linux or Android. The sandbox can be
deployed locally and will require a host (the management software) and multiple sandbox clients (virtual
machines for analysis).
Cuckoo Sandbox features:
- Takes screenshots of the execution of the malware
- Intercepts deleted and downloaded files
- Dumps memory of the malware processes
- Runs concurrent analyses on multiple machines
- Dumps generated network traffic in PCAP format
- Recursively monitors newly spawned processes
- Traces relevant API calls for behavioural analysis
- Acquires full memory dumps of the VM
31
The following diagram shows Cuckoo's architecture:
14
FIGURE 27: CUCKOO – SANDBOX ARCHITECTURE
Due to its modular design, Cuckoo can be used as a standalone application or integrated into larger
frameworks. The sandbox is accessible using the web console from which the malware samples were submitted
for analysis. The web console is presented in the picture below:
FIGURE 28: CUCKOO – SANDBOX WEB CONSOLE
After the files are submitted to the sandbox using the web console, they are executed, with all activities
logged and included in the final report. The analyst can access and read the report by using the web console.
Cuckoo sandbox has several reporting formats, including human-readable format, MAEC (Malware Attribute
Enumeration and Characterization) format – a standard language developed by MITRE – and the ability to export
a data report to another format.
At the time of writing, more information regarding the installation and usage of the Cuckoo Sandbox solution
can be found on the webpage https://cuckoo.readthedocs.io/en/latest/installation/host/installation
14 https://cuckoo.readthedocs.io/en/latest/introduction/what/
32
Windows Sandbox
In Windows 10, Version 1903 (May 2019 Update), Windows included a new feature called Windows
Sandbox. The Sandbox environment does not require too many resources from the system and uses only around
100 MB of disk space.
The Windows Sandbox environment is presented in Figure 29 below.
FIGURE 29: WINDOWS – SANDBOX GUI
Windows Sandbox requirements:
• x64 architecture
• Virtualisation capabilities enabled in BIOS
• At least 4GB of RAM (8GB recommended)
• At least 1 GB of free disk space (SSD recommended)
• At least 2 CPU cores (4 cores with hyperthreading recommended)
Every time the analyst runs the Windows Sandbox Feature, it will create a new clean installation of
Windows 10. After the analysis of the binary is complete, and the analyst closes the Sandbox environment,
everything that was in the environment is deleted. By using this technique, the analyst can easily test malicious
or untrusted applications while ensuring the work environment remains safe and clean.
One important aspect of this solution is that it requires the user to activate Microsoft’s hypervisor15.
The Sandbox also offers the ability to customise different aspects of the environment, for example:
15 Windows Sandbox is available on 64-bit versions of Windows 10 Pro, Enterprise and Education. It is not
available for the Home edition (https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/about/)
33
• Enable or disable the virtualised GPU
• Enable or disable networking in the sandbox
• Share folders from the host
• Run a startup script or program
To enable this option, the Sandbox looks for a configuration file that has a ‘.WSB’ extension. More
information on how to enable and configure the Windows Sandbox can be found on the Microsoft Community
blog. 16
5.4 Debuggers
At first glance, a debugger seems much like a disassembler: both display examined specimens’ code in
assembly and they offer similar lists of functions, strings, etc. The difference is that a debugger offers the ability
to perform detailed monitoring of malicious code execution, including insight into memory, registers, stack and
control elements. The benefit of debugging is the opportunity to run the code, control the execution (instruction
by instruction, breakpoints, etc.) and see particular values in registers, parameters of functions, and their return
values, which gives a better understanding of the code.
There are several open-source debuggers for executables: WinDbg,17 x64dbg,18 Immunity Debugger,19
OllyDbg.20 The following examples are demonstrated using x64dbg.
Breakpoint
When a suspicious specimen was
analysed in IDA, the ‘InternetWriteFile’ API
function call was identified at addresses
‘0x004010D5’ and ‘0x004010E4’. The
function, as its name suggests, sends data via
the network. Parameters of the function
define the destination (‘hFile’), data to be
sent (‘lpBuffer’), length of data to be sent
(‘dwNumberOfBytesToWrite’) and amount of
data sent (‘lpdwNumberOfBytesWritten’).
The destination is hardcoded in the
executable and has already been discovered
(see IDA Chapter 4.1). It is obvious that the
function at address ‘0x004010E4’ sent the ‘\n’
FIGURE 30: IDA – PARAMETERS OF INTERNETWRITEFILE FUNCTION
character. But the kind of data sent at address
16 https://techcommunity.microsoft.com/t5/windows-kernel-internals/windows-sandbox/ba-p/301849
17 https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/
18 https://x64dbg.com/
19 https://www.immunityinc.com/products/debugger/index.html
20 http://www.ollydbg.de/
34
‘0x004010D5’ is still unknown.
The easiest way to analyse it is by monitoring it in the debugger. After opening the executable in x64dbg,
a breakpoint should be set at the address ‘0x004010D5’ (found in IDA, the address from which the function was
called):
1. Right-click in the code area and choose ‘Go to’ > ‘Expression’ (or press CTRL+G). A dialog box appears.
2. Fill in the address in the dialog box and click on OK.
3. Set the breakpoint at the required address by right-click > ‘Breakpoint’ > ‘Toggle’ (or press F2).
4. The address with the breakpoint is highlighted in red.
FIGURE 31: X64DBG – SETTING A BREAKPOINT ON THE SPECIFIC ADDRESS
35
Then enable the debugger to run the
executable by pressing F9 (or through menu
‘Debug’ > ‘Run’). The debugger reaches the
breakpoint and stops. The data sent by
‘InternetWriteFile’ is now visible in the stack area.
There is a high probability that API
functions related to networking and file
manipulation are called several times during
program execution (a loop transmitting more than
one data packet, a loop processing more than one
file, one row of a file, etc.). It is worth observing
what other data is processed by such API
functions. FIGURE 32: X64DBG – STACK MEMORY
Symbols and Intermodular calls
In the previous example, the address where the interest function was called from was known, telling us
where the breakpoint had to be set. If the address of interest is unknown, a survey of functions and their cross-
references must be carried out and x64dbg has built-in features for this: symbols and intermodular calls.
To
see a list of
symbols
(imported
external
functions),
switch to the
‘Symbols’ tab
and choose the
executable
name from all
modules (or
press CTRL+N).
The list does
not contain the
particular
addresses
from which
imports are
called. These
FIGURE 33: X64DGB - SYMBOLS
are available in
intermodular
calls.
36
Intermodular calls are shown via right-click > ‘Search for’ > ‘Current Module’ > ‘Intermodular calls’. A
table appears containing information about how (‘Disassembly’ column), where (‘Address’ column) and what
imported functions (‘Destination’ column) are called. It is possible to breakpoint interest calls by pressing F2 or
to investigate them in the code area where you can switch by double-clicking on them. A list of strings
occurrences can likewise be analysed (right-click in ‘CPU’ > ‘Search for’ > ‘Current Module’ > ‘String references’).
FIGURE 34: X64DBG - INTERMODULAR CALLS
Deobfuscation
Debuggers also help when tackling obfuscated, uncompiled scripts. The following example
demonstrates an analysis of an obfuscated javascript ‘malware.js’. The script is 10 pages long (Figure 35 is a
cut-out just for illustration), and manual deobfuscation would be quite challenging.
FIGURE 35: OBFUSCATED JAVASCRIPT
37
A javascript file needs to be executed by a script interpreter. Windows has a native script engine
‘wscript.exe’ located in the ‘C:\Windows\System32\’ directory. Usually, such obfuscated javascript is designed
to drop or download a new malicious file and execute it. It is difficult to estimate what exactly it might be and
what to focus on in the debugger, but it is most probably trying to execute an arbitrary command in the operating
system, so API functions from ‘shell32.dll’ (eg. ‘ShellExecute’) need to be monitored.
From a debugger perspective, this means loading ‘wscript.exe’, telling ‘wscript.exe’ to process the
malicious javascript file, setting a breakpoint at ‘ShellExecute’ and analysing its context when triggered:
1. Load ‘wscript.exe’ (‘File’ > ‘Open’ > ‘C:\windows\system32\wscript.exe’).
2. Add ‘malware.js’ as a parameter (‘File’ > ‘Change Command Line’ and add path to the malicious file; e.g.
‘"C:\Windows\system32\wscript.exe" C:\malware.js’).
3. Switch to ‘Breakpoints’ panel > right-click > ‘Add dll breakpoint’ and fill in ‘shell32.dll’.
4. Run the execution and wait until the ‘shell32.dll’ breakpoint is triggered (if triggered, it means the DLL
and its symbols were loaded).
5. Switch to ‘Symbols’ panel > choose ‘shell32.dll’ among modules > filter ‘Execute’ functions and
breakpoint them.
6. Switch back to ‘Breakpoints’ panel and disable the DLL breakpoint from step 4 (otherwise all actions
connected with the dll would be breakpointed, not just the required manually breakpointed functions).
7. Run the execution and wait for one of the ‘Execute’ breakpoints to be triggered to examine the
parameters in the stack memory.
38
FIGURE 36: X32DBG – JAVASCRIPT DEBUGGING AND DLL BREAKPOINT
One of the breakpoints stops code execution at the ‘ShellExecuteExA’ function. The function has only
one parameter according to the documentation21 – a pointer to the ‘SHELLEXECUTEINFOA’ structure. To examine
it, right-click on the pointer value > ‘Follow DWORD in Dump’ > ‘Dump 1’. The fifth item of the structure is a
file/object/command to be executed. For details, right-click on it in ‘Dump 1’ area > ‘Follow DWORD in Dump’ >
‘Dump 2’ and adjust the format by right-clicking > ‘Text’ > ‘Extended ASCII’. In this case, it is a command initiating