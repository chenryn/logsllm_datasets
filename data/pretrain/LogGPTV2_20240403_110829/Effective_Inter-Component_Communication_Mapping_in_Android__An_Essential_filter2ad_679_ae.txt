% Total
% Imprecise
86
2.35% 3,657
421 11.55% 3,646
19 40.43%
47
128 26.39% 485
8.35% 7,835
654
Popular
% Imprecise
1,637
1,525
Precise
27,753 94.43%
23,133 93.82%
509 85.12%
4,161 95.81%
55,556 94.18%
Table 1: Precision metrics
89 14.88%
182
3,433
% Total
5.57% 29,390
6.18% 24,658
598
4.19% 4,343
5.82% 58,989
than Intents: Intent Filters limiting access to dynamic re-
ceivers can deﬁne several actions, and receivers can be
protected by a permission (which we attempt to recover).
In the popular applications, we obtain a precise spec-
iﬁcation in over 94% of the 58,989 ICC locations in the
838 apps. Explicit ICC was slightly more precisely an-
alyzed than implicit ICC. Mixed ICC is again hard to
recover. This is not surprising, as mixed ICC involves
different Intent values on two or more branches, which is
indicative of a method more complex than most others.
A facet of the analysis not shown in the table is the
number of applications for which we could identify un-
ambiguous speciﬁcations for all ICC – called 100% pre-
cision. In the random sample, 56% of the applications
could be analyzed with 100% precision, 80% of the ap-
plications with 90% precision, and 91% of the applica-
tions with 80% precision.
In the popular applications,
23% could be analyzed with 100% precision, 82% could
be analyzed with 90% precision and 94% with 80% pre-
cision. Note that a less-than-100% precision does not
mean that the analysis failed. Rather, these are cases
where runtime context determines string arguments, and
thus any static analysis technique would fail.
6.2 Computation Costs
A second set of tests sought to ascertain the computa-
tional costs of performing the IDE analysis using Epicc.
For this task we collected measurements at each stage of
the analysis and computed simple statistics characteriz-
ing the costs of each task on the random sample and the
popular applications.
Experiment results show that ICC analysis in this
model is feasible for applications in the Google Play
store. We were able to perform analysis of all 348 ap-
plications in the random sample in about 3.69 hours of
compute time. On average, it took just over 38 seconds
to perform analysis for a single application, with a stan-
dard deviation of 99 seconds. There was high variance in
the analysis run times. A CDF (cumulative distribution
i
)
e
m
T
n
o
i
t
a
t
u
p
m
o
C
(
F
D
C
i
)
e
m
T
n
o
i
t
a
t
u
p
m
o
C
(
F
D
C
 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0
 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0
 1
 10
 100
Applications (logscale)
(a) Random sample
 1
 10
Applications (logscale)
(b) Popular applications
 100
Figure 8: CDF of computation time
function) of the analysis computation time for all 348 ap-
plications is presented in Figure 8(a). It is clear from the
ﬁgure that costs were dominated by a handful of appli-
cations; the top application consumed over 11% of the
time, the top 5 consumed over 25% of the total time, and
the top 29 consumed over 50% of the total time. These
applications are large with a high number of entry points.
Analyzing the 838 popular applications took 33.58
hours, that is, 144 seconds per application. The standard
deviation was 277 seconds. The average processing time
is signiﬁcantly higher than for the random sample. How-
ever, this is expected, as the average application size is
almost 1,500 classes, which is signiﬁcantly higher than
the random sample (less than 400 classes per applica-
tion). This is likely related to the popularity bias: one can
expect frequently downloaded applications to have fully
developed features as well as more complex/numerous
features, which implies a larger code base. A CDF of the
computation time for all 838 applications is presented in
Figure 8(b). Once again, analysis time is dominated by
a few applications. The top 5 consumed over 11% of the
analysis time and the top 83 (less than 10% of the sam-
ple) consumed over 50% of the analysis time.
Processing was dominated by the standard Soot pro-
cessing (e.g., translating classes to an intermediate repre-
sentation, performing type inference and points-to anal-
ysis, building a call graph). It consumed 75% of the pro-
cessing time in the random sample and 86% in the pop-
ular applications. It was itself dominated by the trans-
lation to Soot’s internal representation and by the call
graph construction. The second most time-consuming
task was the IDE analysis (which also includes the string
analysis in our implementation). It took 15% of the pro-
554  22nd USENIX Security Symposium 
USENIX Association
cessing time with the random sample and 7% with the
popular one. Finally, I/O operations accounted for most
of the remainder of the processing time. Loading classes
took 7% of the time in the random sample and 3% in the
popular one. Database operations accounted for 2% of
processing for the random sample and 3% for the popu-
lar applications. Other operations (e.g., parsing manifest
ﬁles) took less than 1% of processing time.
implicit Intents to address components within an appli-
cation, which is a potential security concern, since these
Intents may also be intercepted by other components.
Lastly, application entry points were relatively narrow
(with respect to intent types). Over 97% of the entry
points received one Intent type in the random sample.
Single Intent Filters were found in 94% of components
protected by Intent Filters in the popular applications.
6.3 Entry/Exit Point Analysis
This section brieﬂy characterizes the exit (source) and
entry (sink) points of Android applications in our data
sets. Note that this analysis is preliminary and will be
extended in future work.
An exit point is a location that serves as a source for
ICC; i.e., the sending of an Intent. In the random sample,
our analysis found 7,350 exit points which can transmit
10,035 unique Intent values. About 92% of these exit
points had a single Intent speciﬁcation, with the remain-
ing exit points being able to take on 2 or more values.
In two pathological cases, we noted an exit point that
could have 640 different Intent values (most likely the re-
sult of contrived control ﬂow or multiple aliasing for an
Intent value). The popular applications had 48,756 exit
points, associated with 316,419 Intent values. Single In-
tent speciﬁcations were found in 90% of exit points. We
found 10 pathological cases where an exit point was as-
sociated with 512 Intent values or more. The use of key
value data was more prevalent than we initially expected,
in about 36% of exit points in the random sample. Key-
value data was present in Intents in 46% of exit points in
the popular applications.
Our study of entry points focused on the sinks of
ICC that were either dynamically registered broadcast re-
ceivers or component interfaces (exported or not) identi-
ﬁed in the application manifest. In the random sample,
we were able to identify 3,863 such entry points associ-
ated with 1,222 unique intent ﬁlters. The popular appli-
cations comprised 25,291 entry points with 11,375 Intent
Filters. 1,174 components were exported (and thus avail-
able to other applications) in the random sample, 7,392
in the popular applications. Of those, only 6% (67) of
the exported components were protected by a permission
in the random sample and 5% (382) were protected in
the popular applications. This is concerning, since the
presence of unprotected components in privileged appli-
cations can lead to confused deputy [21] attacks [17].
Oddly, we also found 23 components that were ex-
ported without any Intent Filter in the random sample
and 220 in the popular sample. Conversely, we found 32
cases where a component had an Intent Filter but was not
exported in the random sample and 412 in the popular
one. The latter indicates that developers sometimes use
ICC Vulnerability Study
6.4
In this section, we perform a study of ICC vulnerabilities
in our samples using Epicc and compare our results with
ComDroid [6]. We look for the same seven vulnerabil-
ities as in [6]. Activity and Service hijacking can occur
when an Intent is sent to start an Activity or a Service
without a speciﬁc target. Broadcast thefts can happen
when an Intent is Broadcast without being protected by a
signature or signatureOrSystem permission7. In all three
cases, the Intent may be received by a malicious compo-
nent, along with its potentially sensitive data.
Malicious Activity or Service launch and Broadcast
injection are Intent spooﬁng vulnerabilities. They in-
dicate that a public component is not protected with a
signature or signatureOrSystem permission. It may be
started by malicious components. These vulnerabilities
can lead to permission leakage [17, 19, 25].
Finally, some Intent Broadcasts can only be sent by
the operating system, as indicated by their action ﬁeld.
Broadcast Receivers can register to receive them by spec-
ifying Intent Filters with the appropriate action. How-
ever, these public components can still be addressed di-
rectly by explicit Intents. That is why the target Re-
ceivers should check the action ﬁeld of the received In-
tent to make sure that it was sent by the system.
Table 2 shows the results of the study for the ran-
dom and the popular samples. The ﬁrst line shows the
number of vulnerabilities identically detected by both
analyses, the second line shows vulnerabilities detected
by ComDroid only and the third line shows vulner-
abilities detected by Epicc only. The last two lines
show the total number of vulnerabilities found by each
tool.
For the three unauthorized Intent receipt vul-
nerabilities (ﬁrst three columns), both ComDroid and
Epicc indicate whether the sent Intent has extra data
in the form of key-value pairs, and whether the In-
tent has the FLAG GRANT READ URI PERMISSION or the
FLAG GRANT WRITE URI PERMISSION. These ﬂags are
used in Intents which refer to Content Provider data and
may allow the recipient to read or write the data [6].
7The signature permission protection level only allows access to a
component from an application signed by the same developer. The
signatureOrSystem protection level additionally allows the operating
system to start the component.
USENIX Association  
22nd USENIX Security Symposium  555
Vulnerability
Activity
Hijacking
Sample
Identical
Broadcast
Theft
R
P
Service
Hijacking
R
P
P
78 1,200 503 4,825 179 1,731 23 263 273 3,503
18 104 1,684
78
3
1
43
Total ComDroid 3,507 22,931 156 1,735 721 7,679 191 1,900 25 281 377 5,187
R
30
3
77
33
81 1,351 526 5,122 183 1,751 23 264 277 3,546 107
Injection w/o action check vulnerabilities
P
R
126 3,677 26,862
20 1,333 12,997
580
3,171
146 5,010 39,859
706 3,969 30,033
Service Broadcast System Broadcast
Launch
P
Total Epicc
Table 2: ICC vulnerability study results for the random sample (R) and the popular applications (P)
2,772 17,293
535 218 2,854
151
297
23
R
P
2,591 15,214
7,717
2,079
916
181
Activity
Launch
R
ComDroid only
Epicc only
12
4
169
20
2
0
4
P R
Total