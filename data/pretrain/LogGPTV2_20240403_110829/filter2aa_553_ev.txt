1581
续表
1582
B.5.21 _Noreturn：stdnoreturn.h
stdnoreturn.h定义了noreturn宏，该宏展开为_Noreturn。
B.5.22 处理字符串：string.h
string.h库定义了size_t类型和空指针要使用的NULL宏。string.h头文件提
供了一些分析和操控字符串的函数，其中一些函数以更通用的方式处理内
存。表B.5.37列出了这些函数。
表B.5.37 字符串函数
1583
续表
1584
strtok()函数的用法有点不寻常，下面演示一个简短的示例。
1585
#include 
#include 
int main(void)
{
char data[] = " C is\t too#much\nfun!";
const char tokseps[] = " \t\n#";/* 分隔符 */
char * pt;
puts(data);
pt = strtok(data,tokseps);   /* 首次调用 */
while (pt)            /* 如果pt是NULL，则退出 */
{
puts (pt);          /* 显示记号 */
pt = strtok(NULL, tokseps);/* 下一个记号 */
}
return 0;
}
下面是该示例的输出：
C is too#much
fun!
1586
C
is
too
much
fun!
B.5.23 通用类型数学：tgmath.h（C99）
math.h和complex.h库中有许多类型不同但功能相似的函数。例如,下面6
个都是计算正弦的函数：
double sin(double);
float sinf(float);
long double sinl(long double);
double complex csin(double complex);
float csinf(float complex);
long double csinl(long double complex);
tgmath.h 头文件定义了展开为通用调用的宏，即根据指定的参数类型调
用合适的函数。下面的代码演示了使用sin()宏时，展开为正弦函数的不同形
式：
#include 
...
double dx, dy;
1587
float fx, fy;
long double complex clx, cly;
dy = sin(dx);          // 展开为dy = sin(dx) （函数）
fy = sin(fx);          // 展开为fy = sinf(fx)
cly = sin(clx);         // 展开为cly = csinl(clyx)
tgmath.h头文件为3类函数定义了通用宏。第1类由math.h和complex.h中定
义的6个函数的变式组成，用l和f后缀和c前缀，如前面的sin()函数所示。在
这种情况下，通用宏名与该函数double类型版本的函数名相同。
第2类由math.h头文件中定义的3个函数变式组成，使用l和f后缀，没有
对应的复数函数（如，erf()）。在这种情况下，宏名与没有后缀的函数名相
同，如erf()。使用带复数参数的这种宏的效果是未定义的。
第3类由complex.h头文件中定义的3个函数变式组成，使用l和f后缀，没
有对应的实数函数，如cimag()。使用带实数参数的这种宏的效果是未定义
的。
表B.5.38列出了一些通用宏函数。
表B.5.38 通用数学函数
在C11以前，编写实现必须依赖扩展标准才能实现通用宏。但是使用
1588
C11新增的_Generic表达式可以直接实现。
B.5.24 线程：threads.h（C11）
threads.h和stdatomic.h头文件支持并发编程。这方面的内容超出了本书
讨论的范围，简而言之，该头文件支持程序执行多线程，原则上可以把多个
线程分配给多个处理器处理。
B.5.25 日期和时间：time.h
time.h定义了3个宏。第1个宏是表示空指针的NULL，许多其他头文件中
也定义了这个宏。第2个宏是CLOCKS_PER_SEC，该宏除以clock()的返回值
得以秒为单位的时间值。第3个宏（C11）是TIME_UTC，这是一个正整型常
量，用于指定协调世界时 
[1]（即UTC）。该宏是timespec_get()函数的一个
可选参数。
UTC是目前主要世界时间标准，作为互联网和万维网的普通标准，广泛
应用于航空、天气预报、同步计算机时钟等各领域。
time.h头文件中定义的类型列在表B.5.39中。
表B.5.39 time.h中定义的类型
timespec结构中至少有两个成员，如表B.5.40所列。
表B.5.40 timespec结构中的成员
1589
日历类型的各组成部分被称为分解时间（broken-down time）。表B.5.41
列出了struct tm结构中所需的成员。
表B.5.41 struct tm结构中的成员
日历时间（calendar 
time）表示当前的日期和时间，例如，可以是从
1900年的第1秒开始经过的秒数。本地时间（local time）指的是本地时区的
日历时间。表B.5.42列出了一些时间函数。
表B.5.42 时 间 函 数
续表
1590
表B.5.43列出了strftime()函数中使用的转换说明。其中许多替换的值
（如，月份名）都取决于当前的本地化设置。
表B.5.43 strftime()函数中使用的转换说明
1591
续表
1592
B.5.26 统一码工具：uchar.h（C11）
C99 的 wchar.h 头文件提供两种途径支持大型字符集。C11 专门针对统
一码（Unicode）新增了适用于UTF-16和UTF-32编码的类型（见表
B.5.44）。
表B.5.44 uchar.h中声明的类型
该头文件中还声明了一些多字节字符串与char16_t、char32_t格式相互转
换的函数（见表B.5.45）。
表B.5.45 宽字符与多字节转换函数
1593
续表
B.5.27 扩展的多字节字符和宽字符工具：wchar.h（C99）
每种实现都有一个基本字符集，要求C的char类型足够宽，以便能处理
这个字符集。实现还要支持扩展的字符集，这些字符集中的字符可能需要多
字节来表示。可以把多字节字符与单字节字符一起储存在普通的 char 类型
数组，用特定的字节值指定多字节字符本身及其大小。如何解释多字节字符
取决于移位状态（shift state）。在最初的移位状态中，单字节字符保留其通
常的解释。特殊的多字节字符可以改变移位状态。除非显式改变特定的移位
状态，否则移位状态一直保持有效。
wchar_t类型提供另一种表示扩展字符的方法，该类型足够宽，可以表
示扩展字符集中任何成员的编码。用这种宽字符类型来表示字符时，可以把
单字符储存在wchar_t类型的变量中，把宽字符的字符串储存在wchar_t类型
的数组中。字符的宽字符表示和多字节字符表示不必相同，因为后者可能使
用前者并不使用的移位状态。
wchar.h 头文件提供了一些工具用于处理扩展字符的两种表示法。该头
文件中定义的类型列在表B.5.46中（其中有些类型也定义在其他的头文件
中）。
表B.5.46 wchar.h中定义的类型
1594
wchar.h头文件中还定义了一些宏，如表B.5.47所列。
表B.5.47 wchar.h中定义的宏
该库提供的输入/输出函数类似于stdio.h中的标准输入/输出函数。在标
准I/O函数返回EOF的情况中，对应的宽字符函数返回WEOF。表B.5.48中列
出了这些函数。
表B.5.48 宽字符I/O函数
1595
有一个宽字符I/O函数没有对应的标准I/O函数：
int fwide(FILE *stream, int mode)[2];
如果mode为正，函数先尝试把形参表示的流指定为宽字符定向（wide-
charaacter 
oriented）；如果 
mode为负，函数先尝试把流指定为字节定向
（byte oriented）；如果 mode为0，函数则不改变流的定向。该函数只有在
流最初无定向时才改变其定向。在以上所有的情况中，如果流是宽字符定
向，函数返回正值；如果流是字节定向，函数返回负值；如果流没有定向，
函数则返回0。
wchar.h 头文件参照 string.h，也提供了一些转换和控制字符串的函数。
一般而言，用 wcs 代替sting.h中的str标识符，这样wcstod()就是strtod()函数
的宽字符版本。表B.5.49列出了这些函数。
1596
表B.5.49 宽字符字符串工具
续表
该头文件还参照time.h头文件中的strtime()函数，声明了一个时间函数：
size_t wcsftime(wchar_t * restrict s, size_t maxsize,const wchar_t * restrict
format,
1597
const struct tm * restrict timeptr);
除此之外，该头文件还声明了一些用于宽字符字符串和多字节字符相互
转换的函数，如表B.5.50所列。
表B.5.50 宽字节和多字节字符转换函数
续表
1598
B.5.28 宽字符分类和映射工具：wctype.h（C99）
wctype.h 库提供了一些与 ctype.h 中的字符函数类似的宽字符函数，以
及其他函数。wctype.h还定义了表B.5.51中列出的3种类型和宏。
表B.5.51 wctpe.h中定义的类型和宏
1599
在该库中，如果宽字符参数满足字符分类函数的条件时，函数返回真
（非0）。一般而言，因为单字节字符对应宽字符，所以如果 ctype.h 中对应
的函数返回真，宽字符函数也返回真。表 B.5.52 列出了这些函数。
表B.5.52 宽字节分类函数
该库还包含两个可扩展的分类函数，因为它们使用当前本地化的
LC_CTYPE值进行分类。表B.5.53列出了这些函数。
表B.5.53 可扩展的宽字符分类函数
1600
wctype()函数的有效参数名即是宽字符分类函数名去掉 isw 前缀。例
如，wctype("alpha")表示的是 
iswalpha()函数判断的字符类别。因此，调用
iswctype(wc, wctype("alpha"))相当于调用iswalpha(wc)，唯一的区别是前者使
用LC_CTYPE类别进行分类。
该库还有4个与转换相关的函数。其中有两个函数分别与ctype.h库中
toupper()和tolower()相对应。第3个函数是一个可扩展的版本，通过本地化的
LC_CTYPE设置确定字符是大写还是小写。第4个函数为第3个函数提供合适
的分类参数。表B.5.54列出了这些函数。
表B.5.54 宽字符转换函数
1601
B.6 参考资料VI：扩展的整数类型
第3章介绍过，C99的inttypes.h头文件为不同的整数类型提供一套系统的
别名。这些名称与标准名称相比，能更清楚地描述类型的性质。例如，int类
型可能是16位、32位或64位，但是int32_t类型一定是32位。
更精确地说，inttypes.h头文件定义的一些宏可用于scanf()和printf()函数
中读写这些类型的整数。inttypes.h头文件包含的stdlib.h头文件提供实际的类
型定义。格式化宏可以与其他字符串拼接起来形成合适格式化的字符串。
该头文件中的类型都使用typedef定义。例如，32位系统的int可能使用这
样的定义：
typedef int int32_t;
用#define指令定义转换说明。例如，使用之前定义的int32_t的系统可以
这样定义：
#define PRId32 "d" // 输出说明符
#define SCNd32 "d" // 输入说明符
使用这些定义，可以声明扩展的整型变量、输入一个值和显示该值：
int32_t cd_sales; // 32位整数类型
scanf("%" SCNd32, &cd_sales);
printf("CD sales = %10" PRId32 " units\n", cd_sales);
如果需要，可以把字符串拼接起得到最终的格式字符串。因此，上面的
代码可以这样写：
int cd_sales; // 32位整数类型
1602
scanf("%d", &cd_sales);
printf("CD sales = %10d units\n", cd_sales);
如果把原始代码移植到16位int的系统中，该系统可能把int32_t定义为
long，把PRId32定义为"ld"。但是，仍可以使用相同的代码，只要知道系统
使用的是32位整型即可。
该参考资料的其余部分列出了扩展类型、转换说明以及表示类型限制的
宏。
B.6.1 精确宽度类型
typedef标识了一组精确宽度的类型，通用形式是intN_t（有符号类型）
和uintN_t（无符号类型），其中N表示位数（即类型的宽度）。但是要注
意，不是所有的系统都支持所有的这些类型。例如，最小可用内存大小是16
位的系统就不支持int8_t和uint8_t类型。格式宏可以使用d或i表示有符号类
型，所以PRIi8和SCNi8都有效。对于无符号类型，可以使用o、x或u以获
得%o、%x或%X转换说明来代替%u。例如，可以使用PRIX32以十六进制格
式打印uint32_t类型的值。表B.6.1列出了精确宽度类型、格式说明符和最小
值、最大值。
表B.6.1 精确宽度类型
B.6.2 最小宽度类型
1603
最小宽度类型保证一种类型的大小至少是某位。这些类型一定存在。例
如，不支持 8 位单元的系统可以把int_least_8定义为16位类型。表B.6.2列出
了最小宽度类型、格式说明符和最小值、最大值。
表B.6.2 最小宽度类型
B.6.3 最快最小宽度类型
对于特定的系统，用特定的整型更快。例如，在某些实现中
int_least16_t可能是short，但是系统在进行算术运算时用int类型会更快些。
因此，inttypes.h还定义了表示为某位数的最快类型。这些类型一定存在。在
某些情况下，可能并未明确指定哪种类型最快，此时系统会简单地选择其中
的一种。表B.6.3列出了最快最小宽度类型、格式说明符和最小值、最大
值。
表B.6.3 最快最小宽度类型
B.6.4 最大宽度类型
1604
有些情况下要使用最大整数类型，表B.6.4列出了这些类型。实际上，
由于系统可能会提供比所需类型更大宽度的类型，因此这些类型的宽度可能
比long long或unsigned long long更大。
表B.6.4 最大宽度类型
B.6.5 可储存指针值的整型
inttypes.h头文件（通过包含stdint.h即可包含该头文件）定义了两种整数