Author: **xd0ol1 (知道创宇404实验室)**
### 0x00 引子
最近开始要在部门内进行 WinDbg
漏洞分析方面的专题showcase，打算将每次分享的内容整理成文章，希望能写一个系列。另外，鉴于笔者还在学习中，不对的地方还望各位多多指正:D
### 0x01 概述
本文将作为此系列的开篇，首先会提及Windows进程的知识，而后就进入正式的漏洞分析，此次选的是一个IE漏洞（CVE-2012-1876）。需要说明一点，随着微软在自身安全上的不断改进，漏洞利用的难度也越来越大，出于学习目的这里主要关注比较经典的漏洞，虽然有些可能比较老了，但还是很有借鉴意义的。
### 0x02 Windows 进程
下面将通过实际例子对Windows进程做个概述，内容比较基础。
在逆向分析中，进程往往作为基本的调试单元，因此对其的理解是有必要的。这里我们先打开IE浏览器，可以知道对每个选项卡IE都会创建一个子进程来处理，接着我们打开WinDbg并附加到当前的IE页面进程，“|”和“~”命令可用于查看进程和线程的状态，注意前面有个小点的是此时所处的进程和线程，可以看到一个进程中包含有多个线程：
    0:012> |
    .  0  id: ed8   attach  name: C:\Program Files\Internet Explorer\iexplore.exe
    0:012> ~
       0  Id: ed8.edc Suspend: 1 Teb: 7ffde000 Unfrozen
       1  Id: ed8.ee0 Suspend: 1 Teb: 7ffdd000 Unfrozen
       2  Id: ed8.ee4 Suspend: 1 Teb: 7ffdc000 Unfrozen
       3  Id: ed8.ee8 Suspend: 1 Teb: 7ffdb000 Unfrozen
       4  Id: ed8.eec Suspend: 1 Teb: 7ffda000 Unfrozen
       5  Id: ed8.ef0 Suspend: 1 Teb: 7ffd9000 Unfrozen
       6  Id: ed8.ef4 Suspend: 1 Teb: 7ffd8000 Unfrozen
       7  Id: ed8.ef8 Suspend: 1 Teb: 7ffd7000 Unfrozen
       8  Id: ed8.efc Suspend: 1 Teb: 7ffd6000 Unfrozen
       9  Id: ed8.f00 Suspend: 1 Teb: 7ffd5000 Unfrozen
      10  Id: ed8.f04 Suspend: 1 Teb: 7ffd4000 Unfrozen
      11  Id: ed8.f08 Suspend: 1 Teb: 7ffd3000 Unfrozen
    . 12  Id: ed8.f4c Suspend: 1 Teb: 7ff9f000 Unfrozen
当然，如果需要WinDbg也是可以同时调试多个进程的，更详细的内容我们可以通过“!peb”和“!teb”命令来查看，其中PEB（Process
Environment Block）存放着进程信息，而TEB（Thread Environment
Block）则存放着线程信息。同时，通过“!address”命令可列出进程的地址空间信息，如下是用户模式下从地址0x00000000开始到0x80000000的信息，只给出部分：
    0:012> !address
      BaseAddr EndAddr+1 RgnSize     Type       State                 Protect             Usage
    -------------------------------------------------------------------------------------------    *        0    10000    10000             MEM_FREE    PAGE_NOACCESS                      Free 
    *    10000    20000    10000 MEM_MAPPED  MEM_COMMIT  PAGE_READWRITE                     MemoryMappedFile "PageFile"
    *    20000    27000     7000 MEM_MAPPED  MEM_COMMIT  PAGE_READONLY                      MemoryMappedFile "PageFile"
    ......
    *  12b0000  12b1000     1000 MEM_IMAGE   MEM_COMMIT  PAGE_READONLY                      Image "C:\Program Files\Internet Explorer\iexplore.exe"
    |- 12b1000  12bc000     b000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READ                  Image "C:\Program Files\Internet Explorer\iexplore.exe"
    |- 12bc000  12bd000     1000 MEM_IMAGE   MEM_COMMIT  PAGE_READWRITE                     Image "C:\Program Files\Internet Explorer\iexplore.exe"
    |- 12bd000  1356000    99000 MEM_IMAGE   MEM_COMMIT  PAGE_READONLY                      Image "C:\Program Files\Internet Explorer\iexplore.exe"
    *  1356000  1360000     a000             MEM_FREE    PAGE_NOACCESS                      Free 
    *  1360000  172d000   3cd000 MEM_MAPPED  MEM_COMMIT  PAGE_READONLY                      MemoryMappedFile "PageFile"
    *  172d000  1730000     3000             MEM_FREE    PAGE_NOACCESS                      Free 
    ......
    |- 3c0f000  3c10000     1000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE|PAGE_GUARD          Stack [ed8.f04; ~10]
    |- 3c10000  3c20000    10000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE                     Stack [ed8.f04; ~10]
    *  3c20000  3c21000     1000 MEM_MAPPED  MEM_COMMIT  PAGE_READONLY                      MemoryMappedFile "\Device\HarddiskVolume2\Windows\System32\ieapfltr.dat"
    |- 3c21000  3fa6000   385000 MEM_MAPPED  MEM_COMMIT  PAGE_WRITECOPY                     MemoryMappedFile "\Device\HarddiskVolume2\Windows\System32\ieapfltr.dat"
    |- 3fa6000  3fa7000     1000 MEM_MAPPED  MEM_COMMIT  PAGE_READONLY                      MemoryMappedFile "\Device\HarddiskVolume2\Windows\System32\ieapfltr.dat"
    *  3fa7000  4110000   169000             MEM_FREE    PAGE_NOACCESS                      Free 
    *  4110000  420a000    fa000 MEM_PRIVATE MEM_RESERVE                                    Stack [ed8.f4c; ~12]
    |- 420a000  420c000     2000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE|PAGE_GUARD          Stack [ed8.f4c; ~12]
    |- 420c000  4210000     4000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE                     Stack [ed8.f4c; ~12]
    *  4210000 5fff0000 5bde0000             MEM_FREE    PAGE_NOACCESS                      Free 
    * 5fff0000 60000000    10000 MEM_PRIVATE MEM_COMMIT  PAGE_EXECUTE_READ                   
    * 60000000 6af50000  af50000             MEM_FREE    PAGE_NOACCESS                      Free 
    * 6af50000 6af51000     1000 MEM_IMAGE   MEM_COMMIT  PAGE_READONLY                      Image "C:\Windows\System32\mshtml.dll"
    |-6af51000 6b488000   537000 MEM_IMAGE   MEM_COMMIT  PAGE_EXECUTE_READ                  Image "C:\Windows\System32\mshtml.dll"
    ......
    * 7ffde000 7ffdf000     1000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE                     TEB [ed8.edc; ~0]
    * 7ffdf000 7ffe0000     1000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE                     PEB [ed8]
    * 7ffe0000 7ffe1000     1000 MEM_PRIVATE MEM_COMMIT  PAGE_READONLY                       
    |-7ffe1000 7fff0000     f000 MEM_PRIVATE MEM_RESERVE PAGE_NOACCESS                       
可以看到用户进程空间中一般包含主模块、共享模块、堆栈资源等，相应的虚拟内存页也都有着各自的属性状态。
那么对于这样的进程是如何从无到有创建起来的呢？这就不得不提[PE格式](http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf)了，比如上面的exe、dll模块都是属于这种类型的文件，简单来看PE文件包含了DOS头、PE头、节表以及节数据，二进制数据将按装入内存后的页属性归类到不同的节中，而各个节中的数据按用途又可以被分为导出表、导入表、重定位表等数据块，通过“!dh
[标志]
模块地址”命令可以显示非常详细的PE头信息。当我们运行iexplore.exe的时候，操作系统将分配所需资源并按照此PE文件中的信息完成加载，即进程的创建。一般来说，PE文件的加载过程是由操作系统提供的PE
Loader功能实现的，但我们也可以自己手动实现此过程，比如[ReflectiveLoader](https://github.com/stephenfewer/ReflectiveDLLInjection)这个技术，它就能在当前进程中完成一个独立dll的加载，一些勒索病毒就是用的这个技巧来躲避杀软。我们可以由此技术大体了解下PE
Loader的功能，首先是查找kernel32等模块中的特定函数，即获取模块基址和处理PE格式，而后申请空间写入节数据、处理输入表和重定位表等，最后跳转到执行入口，即模拟原先操作系统的加载。
我们可以简单看下如何获取kernel32模块的基址，这里由查找LDR链实现，即FS:[30] -> _PEB_LDR_DATA ->
_LDR_DATA_TABLE_ENTRY：
    0:012> dd fs:[30] L1
    003b:00000030  7ffdf000
    0:012> dt ntdll!_PEB 7ffdf000
       ......
       +0x003 SpareBits        : 0y000
       +0x004 Mutant           : 0xffffffff Void
       +0x008 ImageBaseAddress : 0x012b0000 Void
       +0x00c Ldr              : 0x77797880 _PEB_LDR_DATA
       +0x010 ProcessParameters : 0x00341170 _RTL_USER_PROCESS_PARAMETERS
       ......
    0:012> dt ntdll!_PEB_LDR_DATA 0x77797880 
       +0x000 Length           : 0x30
       +0x004 Initialized      : 0x1 ''
       +0x008 SsHandle         : (null) 
       +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x3419d0 - 0x3b29d0 ]
       +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x3419d8 - 0x3b29d8 ]
       +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x341a60 - 0x3b29e0 ]
       +0x024 EntryInProgress  : (null) 
       +0x028 ShutdownInProgress : 0 ''
       +0x02c ShutdownThreadId : (null) 
    0:012> dt ntdll!_LDR_DATA_TABLE_ENTRY 0x3419d0
       +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x341a50 - 0x7779788c ]
       +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x341a58 - 0x77797894 ]
       +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]
       +0x018 DllBase          : 0x012b0000 Void
       +0x01c EntryPoint       : 0x012b1c9a Void
       +0x020 SizeOfImage      : 0xa6000
       +0x024 FullDllName      : _UNICODE_STRING "C:\Program Files\Internet Explorer\iexplore.exe"
       +0x02c BaseDllName      : _UNICODE_STRING "iexplore.exe"
       ......
    0:012> dt ntdll!_LDR_DATA_TABLE_ENTRY 0x341a50
       +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x341d48 - 0x3419d0 ]
       +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x341d50 - 0x3419d8 ]
       +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x341e40 - 0x7779789c ]
       +0x018 DllBase          : 0x776c0000 Void
       +0x01c EntryPoint       : (null) 
       +0x020 SizeOfImage      : 0x13c000
       +0x024 FullDllName      : _UNICODE_STRING "C:\Windows\SYSTEM32\ntdll.dll"
       +0x02c BaseDllName      : _UNICODE_STRING "ntdll.dll"
       ......
    0:012> dt ntdll!_LDR_DATA_TABLE_ENTRY 0x341d48
       +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x341e30 - 0x341a50 ]
       +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x341e38 - 0x341a58 ]
       +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x342688 - 0x341e40 ]
       +0x018 DllBase          : 0x76340000 Void
       +0x01c EntryPoint       : 0x7638bde4 Void
       +0x020 SizeOfImage      : 0xd4000
       +0x024 FullDllName      : _UNICODE_STRING "C:\Windows\system32\kernel32.dll"
       +0x02c BaseDllName      : _UNICODE_STRING "kernel32.dll"
       ......
这样我们就获取了kernel32模块的基址，接着就可以解析PE格式来继续后面的操作了。总体来看，要更好理解进程的创建需要了解相关的PE文件数据结构以及一些操作系统的数据结构，而WinDbg可以作为其中一个很好的学习工具，当然，完整的进程创建还是比较复杂的，除了这里关注的加载过程，还包括资源的分配管理等。
最后提一下WinDbg，它的相关命令可以参考[这里](http://www.yiiyee.cn/Blog/windbg/)，实际操作几次会熟悉的快点，此外，一定要设置好符号文件，毕竟在没有源码的情况下如果能有符号文件，那么对调试二进制文件来说将有莫大的帮助。
### 0x03 CVE-2012-1876 成因分析
接下来我们将借助WinDbg来详细跟一下CVE-2012-1876这个漏洞的成因，至于利用部分我们将在下回讨论。
1、漏洞简介
这是一个IE浏览器的漏洞，成功利用可实现远程代码执行，在Pwn2own
2012上VUPEN团队就用其攻陷了IE9。错误出在mshtml.dll这个模块的CTableLayout::CalculateMinMax函数里，程序在执行时会以HTML代码中\元素的span属性作为循环控制次数向堆空间写入数据，如果此span值设置的不当，那么就会引发堆溢出问题。
其中mshtml.dll模块是IE中的重要组件，它用来解析页面中的HTML和CSS，我们后续的分析也主要集中在此模块中。如下列出了IE中的主要组件，可参考微软的[说明](https://msdn.microsoft.com/en-us/library/aa741312\(v=vs.85\).aspx)：
 图0 Internet
Explorer的主要组件
2、漏洞成因
用到的分析环境为Win7 x86 - IE
8.0.7601.17514，装完系统后默认的就是此IE版本，后面的分析都是在此环境下进行的。这部分内容我们将通过如下的PoC代码来梳理：
            &nbsp 
        function over_trigger() {
            var obj_col = document.getElementById("132");
            obj_col.width = "42765";
            obj_col.span = 666;
        }