following properties: (1) given a device (under its factory setting),
the user can choose any of its supported DMCs; (2) any DMC she
opts for helps her fully control the device by coordinating security
policies across all DMCs. We discuss such a clean-slate design in
Section 6. In practice, however, achieving both goals can be hard in
the short term since different stakeholders — including providers
of third-party DMCs (e.g., Apple, Amazon, Google, Zigbee Alliance,
Z-Wave Alliance) and mainstream device manufacturers — need to
adopt a standardized cross-DMC management protocol. For this
purpose, they are expected to modify their current DMCs to enable
full interoperability of security policies between their respective
DMC protocols, which can be hard. Also making the task challeng-
ing are their heterogeneous architecture (their respective security
policies/enforcements span clouds, hubs, and devices) and implicit
security assumptions made by different vendors [69].
Practical mitigation goals. Before an ideal long-term solution
can be agreed upon, fully developed and deployed, we propose to
build practical, light-weight, and effective mitigation that can be
easily adopted by device manufacturers to mitigate Codema attacks
without requiring a change to the current third-party DMCs. We
summarize two design goals for such a mitigation:
• Control Goal (C-Goal): Give the user the option and tool to fully
control her devices (managing all DMCs’ accessibility status). Al-
lowing any DMC of the user’s choice to manage other DMCs is
hard, which requires a universal cross-DMC management protocol
adopted by many stakeholders. Instead, we seek an access control
mechanism that can be easily adopted by the device manufactur-
ers, and enable users to control (enable/disable/monitor) dangling
DMCs. This is possible by looking at the in-device technical stack
in Figure 1, where the manufacturer’s ALL logic is in the position
to oversee all DMCs and can be enhanced with a centralized access
control framework (see the design in Section 5.2).
• Usability goal (U-Goal): Despite the C-Goal, we envision that users
may not have to leverage the above capabilities. Hence, a mitigation
design should also offer the assurance that unused DMCs pose no
risks to a user’s device, at no additional cost to the user: that is, the
mitigation should have minimum impacts on usability. Note that, a
key usability benefit of the current multiple-DMC IoT paradigm is
that given a device under its factory setting, the users can choose
any DMC it supports [21, 46], for example, when she has already
used Apple Home to manage all her other devices. A mitigation
design should preserve such usability, as confirmed in our study
(see Section 5.4).
5.2 CGuard: Design of Codema Mitigation
This section presents Channel Guard (CGuard), a new, light-weight
access control framework for cross-DMC security management. De-
vice manufacturers can easily integrate CGuard into their firmware
to enable the m-DMC to achieve the above mitigation goals without
depending on all third-party DMC providers to fix their problems.
Figure 7: Architecture of CGuard.
Architecture. To achieve the C-Goal, our core idea is to have a cen-
tralized access control framework to oversee all DMCs and govern
the accessibility of all DMCs on a device. The insight is that unlike
the m-DMCs interfering with third-party DMCs’ state machines
and attempting to manage their individual policies and internal
states, which we show is error-prone (Flaw 3 to Flaw 5) in the
absence of a universal cross-DMC management protocol enabling
policy interoperability, we introduce an access control framework
(CGuard) that utilizes the device manufacturer’s Application Logic
Layer (ALL) in the device to control each DMC’s accessibility sta-
tus (enabled/disabled). CGuard helps ensure that no DMC is left
in an unexpected accessibility status, such as dangling or being
enabled/accessed stealthily by the attacker.
Session 5A: Control System SecurityCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1298At a lower level, CGuard wraps the underlying DMC libraries
on behalf of device manufacturers, exposing three universal, DMC-
agnostic APIs (detailed below) for the ALL program to enable, dis-
able, and monitor individual third-party DMCs. For this purpose,
we built into CGuard three key components:
• Policy Store. It stores the centralized policy that specifies each
DMC’s accessibility, either on or off.
• Channel Switch. It provides two APIs enableChannel(name) and
disableChannel(name) for the manufacturer’s ALL program to
enable/disable a third-party DMC by specifying a channel name.
The two APIs update the policy to the Policy Store and internally
invoke corresponding APIs in the DMC libraries to start/stop a
DMC’s operations (see implementation details in Section 5.3).
• Channel Monitor. It provides the getChannelStatus(name) API
for manufacturer’s ALL program to monitor/check the accessibility
status (on/off ) of each third-party DMC. The API reads the policy
from the Policy Store.
With CGuard, when a user wants to enable/disable a DMC (the
C-Goal), she needs to use the m-DMC (through the manufacturer
app) to set up and bind with the device. In the manufacturer app,
she can toggle on/off for individual third-party DMCs, and such a
command will be sent through the m-DMC to the ALL program,
which calls corresponding CGuard APIs for DMC control.
The principle of fail-safe default. For an owner who opts for
m-DMC, CGuard automatically closes third-party DMCs, until she
re-enables them using the manufacturer app. However, the above
channel control cannot be achieved if the user first opts for a third-
party DMC (requiring a universal cross-DMC management protocol,
as discussed earlier). If a user chooses HomeKit, for example, to set
up and use her devices, CGuard automatically closes all other DMCs
(including the m-DMC), since HomeKit cannot control/oversee
other DMCs. CGuard ensures that those DMCs remain silently
closed until the user factory-resets the device. This ensures no DMC
is dangling with minimum efforts from the users, in particular for
many who prefer not to manage DMCs at all. Our design is highly
acceptable to IoT users, as shown in our user study ( Section 5.4).
5.3 Implementation of CGuard
Overall, we implemented CGuard in 1381 line of C code (released
online [49]). To implement the Channel Switch APIs, we manually
inspected the third-party DMC libraries’ documentations, API lists,
and/or source code, including the HomeKit open-source ADK [20],
the Ti Z-stack [38] (Zigbee DMC), and the Amazon Alexa Gadgets
Toolkit [41] (smart speaker DMC). We identified their respective
APIs (Table 2) to start/stop their DMC’s execution (a typical manu-
facturer also leverages these APIs to run individual DMCs in the
devices). The Policy Store is very light-weight as well, recording
each DMC’s on/off designation in a few bytes.
An end-to-end deployment. We deployed CGuard to a proof-
of-concept smart LED light we built on Raspberry Pi 3b (running
Raspbian GNU/Linux 10), which is popularly used for IoT device de-
velopment. The smart light integrates a PoC m-DMC we developed
and multiple third-party DMCs including HomeKit (Wi-Fi), Zigbee
compatible DMC, and a smart-speaker DMC. For the manufacturer
DMC, we developed a prototype manufacturer app on Android
(developing an iOS app is similar and trivial). The communication
between our Android app and the light leverages a typical cloud-
based architecture (see Section 2): our app sends commands to an
IoT server (using MQTT protocol[43]) we deployed on AWS IoT
core [13], which forwards the commands to the LED light. To let
our light support third-party DMCs, we integrated their libraries
to the firmware, i.e. HomeKit open-source ADK, Z-Stack™, and the
Amazon Alexa Gadgets Toolkit.
Our light can be turned on/off using our Android app, Apple
Home app (on an iPhone), and other DMCs’ console (such as Alexa
for the smart speaker DMC). To use CGuard, our Android app
includes switches to allow the owner to turn on/off individual third-
party DMCs, whose commands go through CGuard in the device
and achieved the channel control. The source code of our PoC smart
light and mobile app (in two versions with and without CGuard)
is released online [49], along with a video demo showing how the
mobile app manages the light.
Table 2: Implementation of Channel Switch in CGuard
DMC Name
HomeKit
Smart Speaker (Alexa)
Zigbee DMC
DMC Library APIs Used (to enable/disable)
HAPAccessoryServerCreate()
HAPAccessoryServerStop()
AlexaGadget.set_discoverable()
AlexaGadget._bluetooth.unpair()
ZDOInitDevice()
ZDO_ProcessMgmtLeaveReq()
5.4 Evaluation
This section reports our evaluation of CGuard on its usability (for
end users), performance, the level of effort for the manufacturer to
integrate, and effectiveness in secure channel control.
5.4.1 Usability. To ensure that CGuard is easy to use for normal
IoT users (see U-Goal in Section 5.1), introducing minimum or no
impacts on usability, we performed a user study with 72 users
in North America and Asia including many with non-technical
backgrounds. The result demonstrates that our protection is well
received by users. We elaborate the study as follows.
Recruitment. Under the IRB approval of our universities, we
recruited 72 participants from three universities (in North America
and Asia) or from local communities. Their ages span a wide range
(18-20: 18 people; 21-30: 41 people; 31-40: 5 people; 40-50: 1 person;
50+: 7 people); 33/72 are female; 29/72 do not have an IT-related
education background; 57/72 had experience of using IoT devices.
Procedure of the user study. We interviewed 30 participants
on Zoom, interviewed 17 participants face-to-face and asked the
rest (25) to finish an online survey while practicing social distancing
following CDC guidelines due to COVID-19. During the interview,
each participant was asked to watch a short video that introduces
the Codema risks. The video includes less technical details to ensure
that non-technical participants can easily understand the Codema
risk (i.e., unused IoT channels can enable an attacker to control the
device). We have released the video online [49], which can also be
used to educate the general public. We then asked each participant
to finish a questionnaire, taking about 10-20 minutes with 15 USD
of Amazon gift card as compensation.
Session 5A: Control System SecurityCCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea1299The questionnaire includes the following key questions to better
understand the usability of CGuard for general users: (Q1) whether
the users believe that the Codema risks should be addressed; (Q2)
whether it is easy to use CGuard to enable/disable a DMC; (Q3)
whether the users favor CGuard’s automatic/default closing of un-
used DMCs; (Q4) whether it is important to freely choose any DMC
supported on a device. Further, in the questionnaire, we require
the participants to briefly explain each choice they made. The full
questions are presented in Appendix B.
Results. In general, the users agreed that it is imperative to
address the Codema risks, and favored the usability of CGuard:
Q1: All participants consider that the Codema risk is serious
and needs a serious fix. They all agree that there must be a way to
securely control the channels they do not use.
Q2: Almost all (69/72) participants agree that CGuard provides
an easy way (e.g., toggling a button in the manufacturer app) to
enable/disable a channel. The other 3 participants think the manu-
facturer should provide a fully automatic protection, rather than
relying on the users to perform any operation.
Q3: Almost all (70/72) participants favor CGuard’s automatic, de-
fault “off” status for unused channels (including both m-DMC and
third-party DMCs). In their explanations (required in the question-
naire), more than 52 participants proactively, explicitly commented
that automatic turning off needs the least user efforts and is pre-
ferred. In the meantime, 18 participants explicitly expressed that
they favor the capabilities and options CGuard offers to manually
control DMCs through the manufacturer app.
Q4: Most participants (58/72) indicate that it is very important
to freely choose any DMC supported on a device to set up and use
a new device. Such usability benefit is preserved by CGuard.
5.4.2 Performance overhead. Based on our end-to-end deployment
– the PoC smart light supporting multiple DMCs (see Section 5.3),
we evaluated the performance overhead of CGuard. We recorded
the run-time memory and binary file size of the implementation
with and without CGuard. Results show that it only uses 0.88%
(4KB/452KB) and 0.72% (4KB/556KB) of run-time memory and
storage, which is negligible. To evaluate the operation delay, we
recorded the time from a command is issued from our Android
app to it is executed by the device. We repeated the experiment 20
times: on average, it took 2094ms and 2088ms with and without
CGuard respectively for the command to reach the device. The
delay introduced by CGuard is negligible compared to the delay of
network and server processing.
5.4.3 The level of efforts for manufacturer adoption. Based on our
end-to-end deployment, we compared the amount of source code of
the manufacturer DMC with and without CGuard integrated to our
smart light. Results show that it requires little effort to integrate
CGuard.
The device firmware. To integrate CGuard, we added about
182 lines of C code to the ALL program (see Figure 7). The added
code is used to (1) process and interpret the commands (to en-
able/disable/monitor a DMC) received from the cloud, and (2) in-
voke the CGuard APIs to enable/disable/monitor the DMC.
The mobile app. To support CGuard, we added 448 lines of
Java code to our Android app. The added code is used to (1) add UI
switches to toggle on/off for third-party DMCs such as HomeKit,
(2) the code logic to respond to user actions on the switches; (3)
upon a user action on the switch, send commands to AWS IoT Core
by invoking APIs provided by AWS SDK.
5.4.4 Effectiveness. After the owner binds any channel, CGuard
proactively closes unused ones, leaving no channels dangling. Specif-
ically, if the owner uses m-DMC, he can use our Android app to
enable/disable any DMC on the device and check the status of all
DMCs (see the video demo online [49]).
Note that an attacker who is able to temporarily access the
device may try to factory-reset the device as an attempt to bypass
CGuard. However, the owner can easily observe such anomalies
since factory-resetting under CGuard resets all DMCs and causes
the owner to immediately lose control of the device (requiring a
fresh setup to re-gain control). Interestingly, some vendors (e.g.,
August) only allow the owner who sets up the m-DMC to factory-
reset the device, which can also mitigate factory-resetting attacks.
6 DISCUSSION
Lessons learnt. The most important lesson learnt from our re-
search is the caution one should take when integrating multiple
DMCs into a single device. In the absence of a standardized, fully co-
ordinated cross-DMC management, there is no guarantee that such
DMC integration would not inadvertently bring in new security
flaws, exposing the device to unauthorized access. More specifically,
without proper mediation on the different DMCs, which all have
a full and independent mandate on the device, there is a risk that
security policies configured and enforced through one DMC could
be violated by the access through another DMC, when they are
utilized by different users.
Actually, not only the DMCs from different parties failed to