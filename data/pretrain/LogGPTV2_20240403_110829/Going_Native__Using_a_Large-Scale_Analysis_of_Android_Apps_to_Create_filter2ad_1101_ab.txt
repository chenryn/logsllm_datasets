example Dalvik method signature would be: .method public native
example().
4
actions performed by the analyzed apps,
including system
calls, JNI calls, Binder transactions, calls to Exec methods,
loading of third-party libraries, calls to native activities’ native
callbacks, and calls to native methods. The system calls were
captured using the strace tool, and the other information we
obtained through instrumentation.
To monitor JNI calls, calls to native methods, and library
loading, we modiﬁed libdvm. However, we do not want to
monitor all JNI calls, just JNI calls to the app’s native code,
rather than calls to native code in the standard libraries that
Android includes. To avoid monitoring JNI calls in standard
libraries and calls to native methods in standard libraries,
we modiﬁed the “Method” structure to include a property
indicating whether it belongs to a third-party library or not.
When a third-party library is loaded,
this property is set
accordingly.
We modiﬁed libbinder to track and monitor Binder
transactions. We record the class of the remote function being
called and the number that identiﬁes the function. To map
the identiﬁers to function names, we parse the AIDL (Android
Interface Deﬁnition Language) ﬁles and source ﬁles that deﬁne
Binder interfaces. To ﬁnd ﬁles that have such deﬁnitions, we
search for uses of the macros DECLARE_META_INTERFACE
and IMPLEMENT_META_INTERFACE and classes that ex-
tend “IInterface.” Furthermore, to match identiﬁcation num-
bers to names, we search in “.cpp” ﬁles for enumerations
that use IBinder::FIRST_CALL_TRANSACTION and, in
“.java” ﬁles, for variables deﬁned using IBinder.FIRST_-
CALL_TRANSACTION. We use the names assigned FIRST_-
CALL_TRANSACTION as the functions with identiﬁer 1, the
ones assigned FIRST_CALL_TRANSACTION + NUM as the
functions with identiﬁer 1+NUM and, for the enumerations
that only use FIRST_CALL_TRANSACTION to deﬁne the
ﬁrst element, we consider they are increasing the identiﬁer
one by one.
Calls to Exec methods are identiﬁed by instrumenting
libjavacore. Finally, to monitor the use of native callbacks
in native activities, we modiﬁed libandroid_runtime.
We determine which actions were performed by native code
and which by Java code after the dynamic analysis. To make
this determination, we observe when threads change execution
context from Java to native and from native to Java. Thus,
we process all system calls, keeping a list of threads that
are executing native code. We add a thread to this list when
one of the following happens: Exec method is executed—we
add the child process, which is then used to call execve, a
custom (third-party) shared library is loaded, a native method
is executed, or a callback in the native component of a native
activity is executed. When these actions are completed and the
execution control changes back to Java, the thread is removed
from the list.
We also remove a thread from the list when one of the
JNI methods in Table II is executed. The Call*
functions are used to call Java methods, and the NewObject*
functions are used to create instances of classes, which results
in the execution of Java constructors. When these methods
return, the thread is placed back on the list. Additionally, we
remove a thread from the list when the clinit method, which
Ideally, it would have been possible to use more sophis-
ticated dynamic instrumentation systems. However, the large
scale of our analysis motivated our choice to use a simpler
approach, as it would have required a prohibitive amount of
resources to run on hundreds of thousand of apps. While
our dynamic instrumentation system is acceptable for the
purposes of understanding the lower bound on what behaviors
native code performs, the incompleteness inherent in dynamic
analysis can affect the native code policies generated by our
system. However, if Google or another large company were
to adopt
the idea of using a dynamic analysis system to
automatically generate a native code security policy,
they
could use substantial resources to run the applications for
longer periods of time, use sophisticated dynamic analysis
approaches [32], or even introduce the instrumentation into
the Android operating system and sample the behaviors from
real-world devices.
During dynamic analysis, 33.6% (149,949) of the apps
identiﬁed by static analysis as potentially having native code
actually executed the native code. Table III presents the number
of apps that executed each type of native code. These numbers
constitute a lower bound of the apps that could actually execute
native code.
In order to understand, for our study, why the native
code was not reached during dynamic analysis, we manually
analyzed, statically and dynamically, 20 random apps that were
statically determined to have native code. For 40% (8) of them,
we established through analysis of the decompiled code that
the native code was unreachable from Java code (also known
as deadcode). The remaining applications were too complex
to be manually inspected, and we were not able to ascertain
whether the native code components were not reached due
to deadcode. For this reason, we dynamically analyzed and
manually interacted with them and we did not ﬁnd any path
that led to the execution of the native code. Thus, we believe
that also in this case the native code component was not
reached due to deadcode, even if we were not able to be
completely certain, due to the incomplete nature of manual
analysis.
We further investigated why there was deadcode in these
apps. In each case, the native code was deadcode in third-party
libraries. In fact, in our experience, it often happens that an
app includes a third-party library, to then actively use only
a (sometimes very limited) subset of its functionality, thus
leading to deadcode. Hence, we expect this to be the case
for many apps where our analysis did not reach native code.
As an additional experiment, we also manually and extensively
dynamically exercised another 20 random apps. We observed
no cases of signiﬁcant changes in the results compared to the
Google Monkey automated analysis (neither additional native
code components were reached nor more syscalls were called).
To further understand the coverage of our dynamic anal-
ysis system we performed two additional experiments, one
measuring the Java method coverage and one measuring the
native code coverage. Section VII discusses these experiments
in depth.
Fig. 1. Possible transitions between native code and Java.
TABLE II.
JNI METHODS THAT CAUSE A TRANSITION FROM NATIVE
TO JAVA.  CAN BE THE FOLLOWING: OBJECT; BOOLEAN; BYTE;
CHAR; SHORT; INT; LONG; FLOAT; DOUBLE; VOID.
CallMethod
CallNonVirtualMethod
CallMethodA
CallNonVirtualMethodA
CallMethodV
CallNonVirtualMethodV
CallStaticMethod
CallStaticMethodA
CallStaticMethodV
NewObject
NewObjectV
NewObjectA
is the static initialization block of a class, is executed. Figure 1
presents all mentioned transitions.
To understand how isolating the native code from the Java
code would impact
the performance of the apps, we also
monitor the amount of data exchanged between native and Java
code. We measured the amount of data passed in parameters
of calls from native code to Java methods and vice versa, as
well as the size of the returned value. We also capture the size
of data used to set ﬁelds in Java objects. The results of this
analysis are presented in Section IV-B.
IV. EVALUATION AND INSIGHTS
We ran both the static pre-ﬁlter and dynamic analysis
across numerous physical machines and private-cloud virtual
machines. In total, we used 100 cores and 444 GB of memory.
Moreover, the analysis was run in parallel.
The dynamic analysis was performed using an instru-
mented Android emulator (as described in the previous sec-
tion), and to keep the analysis time feasible we limited the
analysis to two minutes for each app. To dynamically exercise
each application, we followed an approach similar to what is
used in Andrubis [40]: we used the Google Monkey [20] to
stimulate the app with random events, and we then automati-
cally generated a series of targeted events (by means of sending
properly-crafted intents) to stimulate all activities, services, and
broadcast receivers deﬁned in the application.
5
TABLE III.
THE NUMBER OF APPS THAT EXECUTED EACH TYPE OF
NATIVE CODE.
Apps
72,768
19,164
132,843
27,701
149,949
Type
Native method
Native activity
Load library
Call executable ﬁle (27,599 standard,
148 custom and 46 both)
At least one of the above
TABLE IV.
OVERVIEW OF ACTIONS PERFORMED BY CUSTOM SHARED
LIBRARIES IN NATIVE CODE.
Writing log messages
Performing memory management system calls, such as mmap
and mprotect
Reading ﬁles in the application directory
Calling JNI functions
Performing general multiprocess and multithread related system
calls, such as fork, clone, setpriority, and futex
Reading common ﬁles, such as system libraries, font ﬁles, and
“/dev/random”
Performing other operations on ﬁles or ﬁle descriptors, such as
lseek, dup, and readlink
Performing operations to read information about the system,
such as uname, getrlimit, and reading special ﬁles (e.g.,
“/proc/cpuinfo” and “/sys/devices/system/cpu/possible”)
Performing system calls to read information about the process
or the user, such as getuid32, getppid, and gettid
Performing system calls related to signal handling
Performing cacheflush or set_tls system calls or per-
forming nanosleep system call
Reading ﬁles under “/proc/self/” or “/proc//”, where PID
is the process’ pid
Creating directories
A. Native Code Behavior—An Overview
We present
in this section an overview of the actions
performed by native code on Android. We split the actions into
those performed by shared libraries (including those performed
during library loading, native methods, and native activities)
and those that are the result of invoking custom, executable,
and binaries through Exec methods. We also present the actions
performed using standard binaries (i.e., not created by the app),
but in this case based on their names and parameters, instead
of looking at the system calls.
94.2% (125,192) of the apps that used custom shared
libraries executed only a set of common actions in native code,
and Table IV contains the common actions.
TABLE V.
TOP FIVE MOST COMMON ACTIONS PERFORMED BY APPS IN
NATIVE CODE, THROUGH SHARED LIBRARIES (SL) AND CUSTOM
BINARIES (CB). FOR THE INTERESTED READER, WE REPORT THE FULL
VERSION OF THIS TABLE IN [1].
SL
3,261
1,929
1,814
1,594
1,242
CB
72
39
35
5
144
Description
ioctl system call
Write ﬁle in the app’s directory
Operations on sockets
Create network socket
Terminate process or thread group
TABLE VI.
TOP FIVE MOST COMMON ACTIONS PERFORMED BY APPS
THAT CALLED STANDARD BINARIES IN THE SYSTEM. FOR THE
INTERESTED READER, WE REPORT THE FULL VERSION OF THIS TABLE
IN [1].
Description
Read system information
Apps
19,749
3,384 Write ﬁle in the app’s directory or in the sdcard
3,362
1,041
861
List running processes
Read system property
Read logcat
The top ﬁve most common actions performed by apps in
native methods, native activities, and custom binaries called
through Exec are presented in Table V. Table VI presents the
top ﬁve most common actions performed by the apps that used
Exec to call standard (system) binaries.
By analyzing the system calls and the Java methods called
from native code, we identiﬁed 3,669 apps that perform
an action requiring Android permissions from native code.
Table VII presents the top ﬁve most popular permissions used,
how many apps use them, and how we detected its use. We
used PScout [6] to compute the permissions required by each
Java method. Comparing the permissions used in native code
with the permissions requested by the app, we found that only
81 apps use, in native code, all the permissions requested by
the app.
In addition to this being the ﬁrst concrete look into how
many apps use native code and what that native code does, we
can draw two important conclusions: (1) if the native code is
separated in a different process, it is necessary to give some
permissions to the native code and (2) the permissions of
the native code can be more strict (less permissive) than the
permissions of the Java code.
It is interesting to note how conclusion (1) shows that
the drastic measure adopted in NativeGuard [35], which
does not grant any permissions to the native code, would
break 3,669 of apps. This observation reinforces even
more our belief
that security policies should be gener-
ated following a data-driven approach. For instance, a rea-
sonable tradeoff would be to allow to the native code
only the INTERNET, WRITE_EXTERNAL_STORAGE, and
READ_EXTERNAL_STORAGE permissions (the three most
commonly used in native code),
thus blocking only 152
applications.
B. Java—Native Code Interactions
To better understand the performance implications of sep-
arating the native code from the Java code of the apps, we
measured the number of interactions per millisecond between
Java and native code, i.e., the number of calls to JNI functions,
calls to native methods, and Binder transactions.
The mean of interactions per millisecond is 0.00142,
whereas the variance is 0.00003 and the maximum value
is 0.22. NativeGuard’s [35] performance evaluation with the
Zlib benchmark shows a 34.36% runtime overhead for 9.81
interactions per millisecond and 26.64% for 3.96 interactions
per millisecond. Therefore, our experiment shows that isolating
6
TABLE VII.
THE FIVE MOST COMMON (BY NUMBER OF APPS) ACTIONS IN NATIVE CODE THAT REQUIRE ANDROID PERMISSION. FOR THE INTERESTED
READER, WE REPORT THE FULL VERSION OF THIS TABLE IN [1].
Permission
INTERNET
Apps
1,818
1,211 WRITE EXTERNAL STORAGE Write ﬁles to the sdcard
1,211
132
READ EXTERNAL STORAGE
READ PHONE STATE
methods
Description
Open network socket or call method java.net.URL.openConnection
79
ACCESS NETWORK STATE
Read ﬁles from the sdcard
Call
getSimSerialNumber
android.telephony.TelephonyManager or Binder
to
com.android.internal.telephony.IPhoneSubInfo.getDeviceId
Call method android.net.ConnectivityManager.getNetworkInfo
getDeviceSoftwareVersion,
class
call
getSubscriberId,
getDeviceId
transaction
from
or
TABLE VIII.
TOP FIVE MOST COMMON TYPES OF COMMAND PASSED
WITH THE “-C” ARGUMENT TO S U, SEPARATED BETWEEN THE APPS THAT
MENTION THEY NEED ROOT PRIVILEGES IN THEIR DESCRIPTION OR NAME
AND THE ONES THAT DO NOT MENTION IT. FOR THE INTERESTED READER,
WE REPORT THE FULL VERSION OF THIS TABLE IN [1].
Does not
Mention
Root
12
1
2
1
1
Does
Mention
Root
10
13
12
8
7
Description
(e.g.,
executable
Custom
su -c sh /data/data/com.test.etd062.ct/ﬁles/occt.sh)
Reboot
Read system information
Change permission of ﬁle in app’s direc-
tory
Remove ﬁle in app’s directory
native code in a different process should not have a substantial
performance impact on average.
Additionally, we measure the number of bytes exchanged
between the Java code and native code per second. The mean
of bytes exchanged per second is 1,956.55 (1.91 KB/s) and the
maximum value is 6,561,053.27 (6.26 MB/s). Only 11 apps
exchanged more than 1 MB/s. We believe the amount of data
exchanged between Java and native code would not incur a
signiﬁcant overhead, although it could vary greatly depending
on the speciﬁc app.
C. Usage of the su Binary
Unlike common Linux distributions, in Android, users do
not have access to a super user account and, therefore, are
prevented from performing certain actions, such as uninstalling
pre-installed apps. Thus,