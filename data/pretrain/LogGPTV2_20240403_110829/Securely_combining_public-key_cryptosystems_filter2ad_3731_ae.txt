then computes the signature in the usual way, except that
y is computed as
(cid:2))
(xhH(x
1/e = xe1···ei−1ei+1···e(cid:1)
)
0
(he1···ei−1ei+1···e(cid:1)
0
(cid:2))
)H(x
mod n.
This computation does not require knowledge of the factor-
ization of n. The view of the adversary is identical to its
view in interacting with the combined scheme.
4.3 The Gennaro-Halevi-Rabin Scheme
Gennaro, Halevi and Rabin proposed an eﬃcient and state-
less signature scheme secure against adaptive chosen-message
attacks, based on the strong RSA assumption in the stan-
dard model [14], and on the use of a “chameleon” hash func-
tion. Although the result is similar to the Cramer-Shoup
scheme, the construction is very diﬀerent, and it is worth-
while to examine our approach in relation to it. The scheme
operates in the following way. (We describe here the variant
that does not require the random-oracle assumption):
Key generation: The public key is composed of a random
RSA modulus n, a random value s ∈ (Z/nZ)
∗
, and a hash
function H. The private key is the factorization of n, namely
primes p, q such that pq = n. It is also assumed that p, q are
“safe”, so that ﬁnding an odd integer that is not co-prime
with φ(n) is as hard as factoring n.
Signature generation and veriﬁcation: To sign a message
m the signature algorithm ﬁrst chooses a random R and
hashes it together with m to get an exponent e = H(R, m).
It then uses p, q to compute σ = s1/e mod n. The signature
is (σ, R). To verify the signature the veriﬁer computes e =
H(R, m) and veriﬁes that σe = s mod n.
In order for the scheme to be secure in the standard model
the hash function must satisfy several properties. For our
purpose, it is only important to know that chameleon hash
functions [15] can be used by the scheme. In particular, we
use the fact that these functions have a trapdoor. With-
out knowledge of this trapdoor the function H is collision-
intractable. If the trapdoor is known then, given m1, R1, m2
it is easy to ﬁnd an R2 such that H(R1, m1) = H(R2, m2).
Relation between keys: As in §4.2 the public key n is
also the public key of the attacked cryptosystem, and there-
fore the simulator must forge signatures without knowing
the private key, which is the factorization of n. We require
that the public key s be random, as in the distribution of
the keys of the original system, but we provide the simula-
tor with additional useful information about s. We do this
with a technique that is similar to the method used to prove
the security of the scheme in [14]. The key s is chosen in
the following way: Suppose that the simulator expects to be
required to compute at most & signatures. In order to com-
pute s for the public key it chooses H, chooses in advance
(cid:1)
(cid:1)
(cid:1)
i, m
(cid:18), and sets ei = H(R
2& values R
i) for
1 ≤ i ≤ &. It then chooses a random r ∈ (Z/nZ)
∗
and sets
(cid:1)
1, . . . , R
(cid:1)
(cid:18), m
(cid:1)
1, m
the public key to contain s = re1···e(cid:1) and the function H.
The distributions of the public key generated by the simula-
tor, and the public key in the original scheme, are diﬀerent
only in case e1 ··· e(cid:18) is not co-prime to φ(n), but this event
happens with negligible probability.
Signature simulation: When it is required to sign a
message mi the simulator uses the trapdoor of H to ﬁnd a
(cid:1)
i) = ei. It com-
value Ri such that H(Ri, mi) = H(R
putes σ = re1···ei−1,ei+1···e(cid:1) mod n and publishes (σ, Ri) as
the signature. The view of the adversary diﬀers from its
view in interacting with the combined scheme only if the
simulator cannot ﬁnd a collision in H, which happens with
negligible probability.
(cid:1)
i, m
4.4 PSS Signatures
In [3], Bellare and Rogaway described an RSA-based sig-
nature scheme for which the ability to forge signatures is
tightly related to the ability to invert the RSA function, in
the random-oracle model. The scheme operates as follows.
Key generation: An ordinary RSA key (n, e, d) is gener-
ated, with n = pq, p and q prime, e relatively prime to
φ(n), and ed ≡ 1 mod φ(n). The modulus n is of length
k > k0 + k1. The public key is (n, e) and the private key is
d. The scheme also makes use of three hash functions, h, g1,
and g2, modeled as random oracles in reasoning about the
scheme’s security.
Signature generation: To sign a message m ∈ {0, 1}∗
,
choose r ∈R {0, 1}k0 ; compute w = h(m||r) and r
=
∗||g2(w); and return yd mod n as
g1(w) ⊕ r; let y = 0||w||r
the signature.
Signature veriﬁcation: To verify x ∈ (Z/nZ)
∗
as a valid
signature for a message m with respect to the public key
(n, e), compute y = xe mod n and parse y as b||w||r
∗||γ;
∗ ⊕ g1(w); and verify the conditions b = 0,
compute r = r
g2(w) = γ, and h(m||r) = w. The signature is valid iﬀ all
three of the conditions are satisﬁed.
∗
Relation between keys: We show that an instance of
this signature scheme with RSA modulus n may be com-
bined with any other cryptosystem that uses n as part of its
public key. As in §§4.2 and 4.3, our simulator must be able
to forge signatures without knowing the factorization of n.
Signature simulation: The simulator is given a message
m, for which it must compute a signature without being able
to compute dth roots mod n. It does this by choosing a ran-
dom point x ∈ (Z/nZ)
∗
, and then choosing random-oracle
responses appropriately so that y = xe mod n is a valid sig-
nature for m. The simulator begins by making sure that
the ﬁrst bit of y is 0; if not, then it chooses a new x at ran-
∗||γ;
dom, and repeats. The simulator parses y as y = 0||w||r
chooses r ∈R {0, 1}k0 ; and then makes the oracle-value as-
signments h(m||r) = w, g1(w) = r ⊕ r
, and g2(w) = γ.
(As usual, and in order to make sure that the functions are
consistent, the simulator must keep a list of previous input-
output pairs for which it has provided answers for h, g1 and
g2, and if any of these inputs occurs again it must choose a
new random x and repeat the process again.)
∗
4.5 El Gamal Signatures
Pointcheval and Stern [18] provide a version of the El Gamal
signature scheme [12] which is secure against adaptive chosen-
message attacks in the random-oracle model. The scheme is
deﬁned in the following way.
Key generation; The public key is (p, g, h), where p is
223∗
= (cid:15)g(cid:16), and h ∈ (Z/pZ)
∗
prime, g is an element with (Z/pZ)
.
The private key is x such that h = gx mod p. The system
∗ → (Z/(p− 1)Z),
also uses a hash function H : M × (Z/pZ)
where the message space is M .
Signature generation and veriﬁcation: To sign a message
m ∈ M , pick a random k ∈ (Z/pZ)
∗
, compute r = gk mod
−1(H(m, r) − xr) mod (p − 1), and output (r, s).
p,
(The only diﬀerence from the El Gamal signature scheme
is that gH(m,r) replaces gm.) To verify (r, s) as a signa-
ture for m with respect to (p, g, h), check whether hrrs =
gH(m,r) mod p.
s = k
Relation between keys: We consider an additional
cryptosystem whose private key contains the discrete log
x. Therefore, the only freedom that the simulator has is in
deﬁning the hash function H (modeled as a random oracle).
A signature simulator: The simulator is asked by the
adversary A to compute signatures, and should do so with-
out knowing x = logg(h). The simulator takes advantage of
the fact that since the hash function H is modeled as a ran-
dom oracle, A must compute each value of H independently,
and accepts any randomly chosen value as the output of H
for any speciﬁc query. The simulator can therefore observe
the queries that A makes to H, and can manipulate the out-
put of H while being assured that this will not be detected
by A. The only remaining problem is that the signature
requires gH(m,r) to have a speciﬁc value, and the simulator
does not know how to extract discrete logs in order to set
the output of H accordingly.
To overcome this problem and forge a signature for a mes-
sage m with respect to the public key (p, g, h), the simulator
chooses random u, v ∈ (Z/(p− 1)Z) with (v, p− 1) = 1, and
computes r = guhv mod p and s = −rv
−1 mod (p − 1). It
also sets H(m, r) = us mod (p − 1).
It outputs (r, s) as
the signature. This output is a valid signature for m since
−1) mod p. (This “forgery”
hrrs = hrgushvs = hrgushv(−rv
technique, adapted here for our simulation, is well known;
see e.g. [16], §11.5.2, Note 11.66 (iii).)1
5. ACKNOWLEDGEMENTS
We wish to thank Xavier Serret-Avila and Marius Schilder
for stimulating discussions that motivated this work.
6. REFERENCES
[1] M. Bellare, A. Desai, D. Pointcheval and P. Rogaway,
Relations Among Notions of Security for Public-Key
Encryption Schemes, Adv. in Cryptology – Proc. of
Crypto ’98, LNCS 1462, pp. 26-45.
[2] M. Bellare and P. Rogaway, Optimal Asymmetric
Encryption Adv. in Cryptology – Proc. of Eurocrypt
’94, Springer-Verlag LNCS 950, pp. 92-111.
[3] M. Bellare and P. Rogaway, The Exact Security of
Digital Signatures: How to Sign with RSA and Rabin,
Adv. in Cryptology – Proc. of Eurocrypt ’96,
Springer-Verlag LNCS 1070, pp. 399-416.
1The adversary may query the simulator for H(m, r) before
it asks the simulator to sign m. This happens with negligible
probability, since r is deﬁned by the simulator as a function
of u, v, which are chosen at random. In order to take care
of this event, the simulator keeps a list L of all the queries
to H that were asked by the adversary. If the simulator is
asked to sign m, and it happens to choose u, v that deﬁne
an r such that (m, r) ∈ L, then it chooses new values (u, v).
[4] E. Biham, New Types of Cryptanalytic Attacks Using
Related Keys, J. of Cryptology 7(4): 229-246 (1994).
[5] M. Blum, P. Feldman and S. Micali, Non-Interactive
Zero-Knowledge and Its Applications, STOC 1988,
103-112.
[6] D. Boneh, Simpliﬁed OAEP for the RSA and Rabin
functions, Adv. in Cryptology – Proc. of Crypto 2001.
[7] R. Cramer and V. Shoup, A Practical Public Key
Cryptosystem Provably Secure Against Adaptive
Chosen Ciphertext Attack, Adv. in Cryptology – Proc.
of Crypto ’98, Springer-Verlag LNCS 1462, 13-25.
[8] R. Cramer and V. Shoup, Signature Schemes Based
on the Strong RSA Assumption, ACM Conference on
Computer and Communications Security 1999, 46-51.
[9] G. Davida, Chosen Signature Cryptanalysis of the
RSA (MIT) Public Key Cryptosystem, TR-CS-82-2,
Dept. of EECS, Univ. of Wisconsin, Milwaukee, 1982.
[10] D. Dolev, C. Dwork and M. Naor, Non malleable
cryptography, SIAM J. Comput. 30(2), pp. 391-437.
[11] C. Dwork and M. Naor, An Eﬃcient Existentially
Unforgeable Signature Scheme and Its Applications,
Journal of Cryptology 11(3), pp. 187-208 (1998).
[12] T. El Gamal, A Public Key Cryptosystem and a
Signature Scheme Based on Discrete Logarithms, Adv.
in Cryptology – Proc. of Crypto ’84, Springer-Verlag
LNCS 196, pp. 10-18.
[13] E. Fujisaki, T. Okamoto, D. Pointcheval and J. Stern,
RSA-OAEP is Secure under the RSA Assumption,
Adv. in Cryptology – Proc. of Crypto ’2001.
[14] R. Gennaro, S. Halevi and Tal Rabin, Secure
Hash-and-Sign Signatures Without the Random
Oracle, Adv. in Cryptology – Proc. of Eurocrypt ’99,
Springer-Verlag LNCS 1592, pp. 123-139.
[15] H. Krawczyk and T. Rabin, Chameleon hash functions,
Theory of Cryptography Library: Record 98-10, 1998.
[16] A. Menezes, P. van Oorschot and S. Vanstone,
Handbook of Applied Cryptography, CRC Press,
October 1996.
[17] M. Naor and M. Yung, Public-key Cryptosystems
Provably Secure against Chosen Ciphertext Attacks,
STOC 1990, pp. 427-437.
[18] D. Pointcheval and J. Stern, Security Proofs for
Signature Schemes, Adv. in Cryptology – Proc. of
EUROCRYPT 1996, LNCS 1070, pp. 387-398.
[19] M. Rabin, Digitalized Signatures and Public-Key
Functions as Intractable as Factorization,
MIT/LCS/TR-212, 1979.
[20] C. Rackoﬀ and D. Simon, Noninteractive
zero-knowledge proof of knowledge and chosen
ciphertext attack, Adv. in Cryptology – Proc. of
Crypto ’91, pp. 433-444.
[21] C.-P. Schnorr, Eﬃcient Signature Generation by
Smart Cards, J. of Crypt. 4(3), 161-174 (1991).
[22] V. Shoup, Using hash functions as a hedge against
chosen ciphertext attacks, Adv. in Cryptology – Proc.
of Eurocrypt ’2000, LNCS 1807, pp. 275-288.
[23] V. Shoup, OAEP Reconsidered, Adv. in Cryptology –
Proc. of Crypto 2001. A more complete version is
available as: Cryptology ePrint Archive: Report
2000/060 (February 6, 2001).
224