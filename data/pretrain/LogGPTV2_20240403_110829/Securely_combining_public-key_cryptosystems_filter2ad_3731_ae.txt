### 4.3 The Gennaro-Halevi-Rabin Scheme

Gennaro, Halevi, and Rabin proposed an efficient and stateless signature scheme that is secure against adaptive chosen-message attacks. This scheme is based on the strong RSA assumption in the standard model [14] and utilizes a "chameleon" hash function. Although the result is similar to the Cramer-Shoup scheme, the construction is quite different, and it is worthwhile to examine our approach in relation to it.

#### Key Generation
- **Public Key:** The public key consists of a random RSA modulus \( n \), a random value \( s \in (Z/nZ)^* \), and a hash function \( H \).
- **Private Key:** The private key is the factorization of \( n \), i.e., primes \( p \) and \( q \) such that \( pq = n \). It is assumed that \( p \) and \( q \) are "safe," meaning that finding an odd integer that is not coprime with \( \varphi(n) \) is as hard as factoring \( n \).

#### Signature Generation and Verification
- **Signature Generation:**
  1. To sign a message \( m \), the signer first chooses a random value \( R \).
  2. Compute the exponent \( e = H(R, m) \).
  3. Use the private key \( p \) and \( q \) to compute \( \sigma = s^{1/e} \mod n \).
  4. The signature is the pair \( (\sigma, R) \).

- **Signature Verification:**
  1. To verify the signature \( (\sigma, R) \), the verifier computes \( e = H(R, m) \).
  2. Check if \( \sigma^e \equiv s \mod n \).

#### Security Requirements
For the scheme to be secure in the standard model, the hash function \( H \) must satisfy several properties. Specifically, chameleon hash functions [15] can be used. These functions have a trapdoor, which means that without knowledge of this trapdoor, the function \( H \) is collision-intractable. If the trapdoor is known, given \( m_1, R_1, m_2 \), it is easy to find an \( R_2 \) such that \( H(R_1, m_1) = H(R_2, m_2) \).

#### Relation Between Keys
As in §4.2, the public key \( n \) is also the public key of the attacked cryptosystem. Therefore, the simulator must forge signatures without knowing the private key, which is the factorization of \( n \). We require that the public key \( s \) be random, as in the distribution of the keys of the original system, but we provide the simulator with additional useful information about \( s \). This is done using a technique similar to the method used to prove the security of the scheme in [14].

The key \( s \) is chosen in the following way:
- Suppose the simulator expects to be required to compute at most \( \ell \) signatures.
- In advance, choose \( 2\ell \) values \( R_i \) and \( m_i \) for \( 1 \leq i \leq \ell \), and set \( e_i = H(R_i, m_i) \).
- Choose a random \( r \in (Z/nZ)^* \) and set the public key to contain \( s = r^{e_1 \cdots e_\ell} \) and the function \( H \).

The distributions of the public key generated by the simulator and the public key in the original scheme differ only if \( e_1 \cdots e_\ell \) is not coprime to \( \varphi(n) \), but this event happens with negligible probability.

#### Signature Simulation
When the simulator is required to sign a message \( m_i \):
- Use the trapdoor of \( H \) to find a value \( R_i \) such that \( H(R_i, m_i) = e_i \).
- Compute \( \sigma = r^{e_1 \cdots e_{i-1} e_{i+1} \cdots e_\ell} \mod n \) and publish \( (\sigma, R_i) \) as the signature.
- The view of the adversary differs from its view in interacting with the combined scheme only if the simulator cannot find a collision in \( H \), which happens with negligible probability.

### 4.4 PSS Signatures

In [3], Bellare and Rogaway described an RSA-based signature scheme where the ability to forge signatures is tightly related to the ability to invert the RSA function, in the random-oracle model.

#### Key Generation
- Generate an ordinary RSA key \( (n, e, d) \) with \( n = pq \), where \( p \) and \( q \) are prime, \( e \) is relatively prime to \( \varphi(n) \), and \( ed \equiv 1 \mod \varphi(n) \).
- The modulus \( n \) has length \( k > k_0 + k_1 \).
- The public key is \( (n, e) \) and the private key is \( d \).
- The scheme also uses three hash functions \( h, g_1, \) and \( g_2 \), modeled as random oracles.

#### Signature Generation
To sign a message \( m \in \{0, 1\}^* \):
1. Choose \( r \in_R \{0, 1\}^{k_0} \).
2. Compute \( w = h(m || r) \) and \( r' = g_1(w) \oplus r \).
3. Let \( y = 0 || w || r' \).
4. Return \( y^d \mod n \) as the signature.

#### Signature Verification
To verify \( x \in (Z/nZ)^* \) as a valid signature for a message \( m \) with respect to the public key \( (n, e) \):
1. Compute \( y = x^e \mod n \) and parse \( y \) as \( b || w || r' \).
2. Compute \( r = r' \oplus g_1(w) \).
3. Verify the conditions \( b = 0 \), \( g_2(w) = \gamma \), and \( h(m || r) = w \). The signature is valid if all three conditions are satisfied.

#### Relation Between Keys
We show that an instance of this signature scheme with RSA modulus \( n \) can be combined with any other cryptosystem that uses \( n \) as part of its public key. As in §§4.2 and 4.3, our simulator must be able to forge signatures without knowing the factorization of \( n \).

#### Signature Simulation
The simulator is given a message \( m \) and must compute a signature without being able to compute \( d \)-th roots mod \( n \). It does this by:
1. Choosing a random point \( x \in (Z/nZ)^* \).
2. Ensuring the first bit of \( y \) is 0; if not, choose a new \( x \) and repeat.
3. Parsing \( y \) as \( y = 0 || w || r' \).
4. Choosing \( r \in_R \{0, 1\}^{k_0} \).
5. Making the oracle-value assignments \( h(m || r) = w \), \( g_1(w) = r \oplus r' \), and \( g_2(w) = \gamma \).
6. Keeping a list of previous input-output pairs for \( h, g_1, \) and \( g_2 \) to ensure consistency.

### 4.5 El Gamal Signatures

Pointcheval and Stern [18] provide a version of the El Gamal signature scheme [12] that is secure against adaptive chosen-message attacks in the random-oracle model.

#### Key Generation
- **Public Key:** The public key is \( (p, g, h) \), where \( p \) is prime, \( g \) is an element with \( (Z/pZ)^* = \langle g \rangle \), and \( h \in (Z/pZ)^* \).
- **Private Key:** The private key is \( x \) such that \( h = g^x \mod p \).
- **Hash Function:** The system also uses a hash function \( H : M \times (Z/pZ)^* \to (Z/(p-1)Z) \), where the message space is \( M \).

#### Signature Generation and Verification
- **Signature Generation:**
  1. To sign a message \( m \in M \), pick a random \( k \in (Z/pZ)^* \).
  2. Compute \( r = g^k \mod p \).
  3. Compute \( s = k^{-1}(H(m, r) - xr) \mod (p-1) \).
  4. Output \( (r, s) \).

- **Signature Verification:**
  1. To verify \( (r, s) \) as a signature for \( m \) with respect to \( (p, g, h) \), check if \( h^r r^s = g^{H(m, r)} \mod p \).

#### Relation Between Keys
We consider an additional cryptosystem whose private key contains the discrete logarithm \( x \). Therefore, the only freedom the simulator has is in defining the hash function \( H \) (modeled as a random oracle).

#### Signature Simulation
The simulator is asked by the adversary \( A \) to compute signatures without knowing \( x = \log_g(h) \). The simulator takes advantage of the fact that since \( H \) is modeled as a random oracle, \( A \) must compute each value of \( H \) independently and accepts any randomly chosen value as the output of \( H \) for any specific query. The simulator can observe the queries that \( A \) makes to \( H \) and manipulate the output while ensuring it is not detected by \( A \).

To forge a signature for a message \( m \) with respect to the public key \( (p, g, h) \):
1. Choose random \( u, v \in (Z/(p-1)Z) \) with \( \gcd(v, p-1) = 1 \).
2. Compute \( r = g^u h^v \mod p \) and \( s = -rv^{-1} \mod (p-1) \).
3. Set \( H(m, r) = us \mod (p-1) \).
4. Output \( (r, s) \) as the signature.

This output is a valid signature for \( m \) since \( h^r r^s = h^r g^{us} h^{-rv^{-1}} = h^r g^{us} h^{-us} = h^r g^{us} h^{-us} = h^r \mod p \).

### 5. Acknowledgements

We wish to thank Xavier Serret-Avila and Marius Schilder for stimulating discussions that motivated this work.

### 6. References

[1] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway, Relations Among Notions of Security for Public-Key Encryption Schemes, Adv. in Cryptology – Proc. of Crypto '98, LNCS 1462, pp. 26-45.

[2] M. Bellare and P. Rogaway, Optimal Asymmetric Encryption, Adv. in Cryptology – Proc. of Eurocrypt '94, Springer-Verlag LNCS 950, pp. 92-111.

[3] M. Bellare and P. Rogaway, The Exact Security of Digital Signatures: How to Sign with RSA and Rabin, Adv. in Cryptology – Proc. of Eurocrypt '96, Springer-Verlag LNCS 1070, pp. 399-416.

[4] E. Biham, New Types of Cryptanalytic Attacks Using Related Keys, J. of Cryptology 7(4): 229-246 (1994).

[5] M. Blum, P. Feldman, and S. Micali, Non-Interactive Zero-Knowledge and Its Applications, STOC 1988, 103-112.

[6] D. Boneh, Simplified OAEP for the RSA and Rabin Functions, Adv. in Cryptology – Proc. of Crypto 2001.

[7] R. Cramer and V. Shoup, A Practical Public Key Cryptosystem Provably Secure Against Adaptive Chosen Ciphertext Attack, Adv. in Cryptology – Proc. of Crypto '98, Springer-Verlag LNCS 1462, 13-25.

[8] R. Cramer and V. Shoup, Signature Schemes Based on the Strong RSA Assumption, ACM Conference on Computer and Communications Security 1999, 46-51.

[9] G. Davida, Chosen Signature Cryptanalysis of the RSA (MIT) Public Key Cryptosystem, TR-CS-82-2, Dept. of EECS, Univ. of Wisconsin, Milwaukee, 1982.

[10] D. Dolev, C. Dwork, and M. Naor, Non-Malleable Cryptography, SIAM J. Comput. 30(2), pp. 391-437.

[11] C. Dwork and M. Naor, An Efficient Existentially Unforgeable Signature Scheme and Its Applications, Journal of Cryptology 11(3), pp. 187-208 (1998).

[12] T. El Gamal, A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms, Adv. in Cryptology – Proc. of Crypto '84, Springer-Verlag LNCS 196, pp. 10-18.

[13] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern, RSA-OAEP is Secure under the RSA Assumption, Adv. in Cryptology – Proc. of Crypto '2001.

[14] R. Gennaro, S. Halevi, and Tal Rabin, Secure Hash-and-Sign Signatures Without the Random Oracle, Adv. in Cryptology – Proc. of Eurocrypt '99, Springer-Verlag LNCS 1592, pp. 123-139.

[15] H. Krawczyk and T. Rabin, Chameleon Hash Functions, Theory of Cryptography Library: Record 98-10, 1998.

[16] A. Menezes, P. van Oorschot, and S. Vanstone, Handbook of Applied Cryptography, CRC Press, October 1996.

[17] M. Naor and M. Yung, Public-key Cryptosystems Provably Secure against Chosen Ciphertext Attacks, STOC 1990, pp. 427-437.

[18] D. Pointcheval and J. Stern, Security Proofs for Signature Schemes, Adv. in Cryptology – Proc. of EUROCRYPT 1996, LNCS 1070, pp. 387-398.

[19] M. Rabin, Digitalized Signatures and Public-Key Functions as Intractable as Factorization, MIT/LCS/TR-212, 1979.

[20] C. Rackoff and D. Simon, Noninteractive Zero-Knowledge Proof of Knowledge and Chosen Ciphertext Attack, Adv. in Cryptology – Proc. of Crypto '91, pp. 433-444.

[21] C.-P. Schnorr, Efficient Signature Generation by Smart Cards, J. of Crypt. 4(3), 161-174 (1991).

[22] V. Shoup, Using Hash Functions as a Hedge Against Chosen Ciphertext Attacks, Adv. in Cryptology – Proc. of Eurocrypt '2000, LNCS 1807, pp. 275-288.

[23] V. Shoup, OAEP Reconsidered, Adv. in Cryptology – Proc. of Crypto 2001. A more complete version is available as: Cryptology ePrint Archive: Report 2000/060 (February 6, 2001).