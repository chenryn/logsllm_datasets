### Discovering New CVEs through Comprehensive Data Flow Analysis
ARCUS is capable of identifying new Common Vulnerabilities and Exposures (CVEs) by analyzing all data flows over the executed path. This comprehensive approach ensures that no potential vulnerabilities are overlooked.

### Vulnerabilities Cascading into Zero-Day Exploits
An illustrative example from autotrace demonstrates how a single patch can address one bug but fail to fix related "downstream" bugs, providing ARCUS with an opportunity to uncover additional vulnerabilities. In version 0.31.1, autotrace contains a Use-After-Free (UAF) vulnerability (CVE-2017-9182) that can be exploited via a malformed input bitmap image header. ARCUS further identifies two additional downstream vulnerabilities: an integer overflow (CVE-2019-19004) and a double free (CVE-2019-19005). These vulnerabilities all stem from a lack of input file validation. Specifically, when the `bits_per_pixel` field in the image header is invalid, the UAF vulnerability can lead to an unreported integer overflow as autotrace calculates the number of bytes per row in the `input_bmp_reader` function. Additionally, ARCUS discovers a double free that releases the same buffer accessed by the UAF. All three vulnerabilities are triggered by the same malformed header field but reside in different code blocks, making it easy for developers to miss them when fixing one.

### Vulnerabilities Over Large Distances
In version 0.15 of PDFResurrect, there is a buffer overflow vulnerability (CVE-2019-14267) that can be exploited via a malformed PDF to achieve arbitrary code execution. The vulnerability occurs when the function encounters a '%%EOF' in the PDF and scans backward for an 'f' character, which should represent the end of 'startxref'. As it scans, a register representing `pos_count` is incremented. An attacker can create a malformed PDF without a 'startxref', causing `pos_count` to exceed 256, leading to a buffer overflow. Post-evaluation, we discovered that this vulnerability had been described in a previous bug report but was never assigned a CVE ID. Consequently, we were the first to report it to a CVE authority, resulting in the issuance of CVE-2019-17582.

### Performance and Robustness
**Performance Overhead and Storage Size:**
- **SPEC CPU Benchmark:** The average overhead is 7.21%, and the geometric mean is 3.81%. The average trace size is 110 MB, and the geometric mean is 38.2 MB.
- **Nginx Tracing:** The performance overhead is under 2%, and the maximum storage required is 1.6 MB per request.

**Robustness:**
- Recommendations made by ARCUS are based on constraints built from a single execution path, meaning completeness cannot be guaranteed. Human developers are expected to use ARCUS’s recommendations as a starting point for implementing official patches.
- ARCUS is not well-suited for building constraints within cryptographic procedures, making it less effective for handling bugs in libraries like OpenSSL (e.g., CVE-2010-2939). However, it can still analyze programs that import such libraries, as APIs can be modeled. Future work may incorporate tailored analysis techniques [83] to improve this.
- The current prototype is not optimized for heavily obfuscated binaries or virtual machines (e.g., JVM). The kernel module can trace programs that dynamically generate code, including just-in-time (JIT) compilation, but additional API modeling is required for angr to support web browsers.
- Despite these limitations, ARCUS has successfully handled complex programs like GIMP, which has 810,000 lines of C/C++ code, demonstrating its potential for future improvement.

### Cross-Platform Support
The current implementation of ARCUS is for x86-64 Linux, but with engineering effort, it can be extended to other platforms. The analysis uses VEX IR semantics, which is machine-independent, and angr can lift several hardware architectures. The "what-if" approach is also machine-independent. The integer overflow module leverages some x86-specific semantics to infer signedness but includes general techniques that can be extended in future work. The memory allocation and format string modules require the semantics for functions like `printf` and `malloc`, and the current prototype supports typical libraries like libc and jemalloc. Prior work proposes techniques for custom functions [84], which can be incorporated in future work.

### False Negatives and Positives
- **False Negatives:** Some modules in ARCUS can incur false negatives, as described in Subsection 3.3.
- **False Positives:** Only the integer overflow module can yield false positives due to its combination of forward analysis and heuristics. The sole case encountered occurs in libpng, where an overflowed value is passed to another function, triggering detection by ARCUS, but the receiving function performs additional checks, preventing exploitation. Such patterns of checking for overflows in the receiving function are atypical [58].

### Related Work
**Symbolic Execution:**
- Early work in symbolic execution demonstrated its utility in testing and debugging code [87]. As solvers became more efficient, symbolic execution was applied to replay protocols [88], detect vulnerabilities [89–92], side-channel research [93], firmware analysis [94], correctness of cryptography software [95], emulator testing [96], and automatic binary patching [97].
- Concolic execution, a subset of symbolic analysis, combines static and dynamic analysis to explore as many paths as possible [98–100, 80, 101]. Hybrid approaches [102, 103] alternate between fuzzing and symbolic exploration to manage state explosion.
- Single-path concolic execution, useful for generating exploits [101, 104, 105] and reverse engineering, sidesteps state explosion but relies on concrete executions covering interesting program behaviors. ARCUS distinguishes itself by providing concise root causes using execution traces without needing concrete inputs.

**Root Cause and Crash Dump Analysis:**
- Techniques like delta debugging [106, 107] compare program states between successful and failing inputs to narrow down relevant variables. Program slicing [108] extracts only the code contributing to the failure condition. Delta debugging struggles with generating enough inputs, while slicing requires tainting or lightweight replay.
- Failure sketching systems handle security bugs like overflows [109] but often focus on race conditions [110]. While races have serious security implications, they are not the only class of issues hindering modern programs.
- Crash dump analysis [111] aims to locate the cause of software crashes. Unlike ARCUS, crash dumps assume bugs will manifest as crashes, while ARCUS can detect non-crashing exploits. Crash dumps provide partial stack and memory info, whereas ARCUS uses PT traces and snapshots, ensuring data integrity.

### Conclusion
This work introduces ARCUS, a system for performing concise root cause analysis over traces flagged by end-host runtime monitors in production systems. Using a novel "what if" approach, ARCUS automatically pinpoints the root cause and recommends new constraints to block uncovered vulnerabilities, enabling system administrators to better inform developers. Leveraging hardware-supported Processor Trace (PT), ARCUS decouples the cost of analysis from end-host performance. Our evaluation against 27 vulnerabilities and over 9,000 Juliet and RIPE test cases shows that ARCUS can automatically identify the root cause of all tested exploits, uncovering 4 new vulnerabilities with zero false positives and negatives. ARCUS incurs a 7.21% performance overhead on the SPEC 2006 CPU benchmark and scales to large programs compiled from over 810,000 lines of C/C++ code.

### Acknowledgments
We thank the anonymous reviewers for their helpful and informative feedback. This material was supported in part by the Office of Naval Research (ONR) under grants N00014-19-1-2179, N00014-17-1-2895, N00014-15-1-2162, and N00014-18-1-2662, and the Defense Advanced Research Projects Agency (DARPA) under contract HR00112090031. Any opinions, findings, conclusions, or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of ONR or DARPA.

### References
[References listed as provided in the original text]