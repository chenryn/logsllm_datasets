transitions to the Second @ state. Otherwise, the system
transitions back to the Pass Input Unmodiﬁed state. The
keystroke is output to the legacy OS.
Second @. When in the Second @ state, the user has suc-
cessfully indicated that she is about to provide some sensi-
tive input using Bumpy. From this point forward, the only
way for the user to terminate the process of entering sen-
sitive input is to perform an action that will cause a blur
event in the current input ﬁeld. A blur event is an event in
the graphical user interface that indicates that a particular
component is becoming inactive, generally because the fo-
cus is now elsewhere. Relevant actions include clicking the
mouse or pressing Tab, Shift+Tab, Alt+Tab, or Enter. Note
that we explicitly do not listen for blur events from the web
browser, as a malicious browser would be able to terminate
secure input prematurely. If the user’s input does not repre-
sent a blur event, then the system transitions to the Enqueue
Input state.
Pass Input Unmodiﬁed. The common case for user input
is that it is non-sensitive, and does not require special pro-
tection by the PreP. Any existing queue of sensitive events
is discarded upon entry to this state. Unless e is a browser
which we describe in Appendix A.
Enqueue Input. For each PreP invocation in the Enqueue
Input state, the decrypted keystroke is ﬁltered before being
appended to State.Queue. The ﬁlter identiﬁes and drops
illegal password characters that would not cause a blur
event (e.g., meta-characters used for editing, such as ar-
rows, Backspace, and Delete). We discuss editable sensitive
input in Section 10. This process continues until the user
causes a blur event, e.g., presses Tab, Shift+Tab, Alt+Tab,
Enter, or clicks the mouse. A decoy input event is released
to the legacy OS: an asterisk. From the perspective of the
legacy OS, when the user types her sensitive input, she ap-
pears to be typing asterisks. This has the convenient prop-
erty of mimicking the usual functionality of input to pass-
word ﬁelds even if the current ﬁeld is a normal text ﬁeld:
all keystrokes appear as asterisks. Note that these asterisks
will eventually be discarded, as the PoPr provides the re-
mote webserver with the true input for the protected ﬁelds.
When the user causes a blur event, the system transitions to
the Invoke PoPr state.
Invoke PoPr. When the PreP state machine transitions to
the Invoke PoPr state, it means that the user successfully di-
rected the web browser’s focus to a particular ﬁeld, entered
@@ to signal the start of sensitive input, provided some sen-
sitive input, and then caused a blur event that signals the
end of sensitive input. This input will now be handed to the
PoPr for destination-speciﬁc processing (Section 5). First,
however, it is necessary to check that the PoPr provided as
an input to the PreP during the current Flicker session is the
same PoPr that was provided during the focus event that ini-
tiated this sensitive input. If the PoPr is changed, malicious
code may be trying to fool the user. In this case, the system
transitions directly back to Pass Input Unmodiﬁed where
the queue of sensitive input events is discarded. If the PoPr
is conﬁrmed to be the same, it is invoked. The PoPr also
runs with Flicker’s protections, but it is less trusted than the
PreP. Thus, PreP state is sealed and cleared before invoking
the PoPr with the queue of input events. This is essential, as
the PreP state includes the cryptographic secrets involved in
communication with the user’s physical input device(s). If
a PoPr could compromise this information, it might be able
to collude with a malicious OS and capture all subsequent
input on the user’s platform. Once the PoPr has executed,
its output is handed to the web browser via the legacy OS
for submission to the webserver from which the PoPr origi-
nated. If the PoPr considers these input events to be secret,
then they should be encrypted such that the legacy OS will
be unable to learn their values.
4.2 Associating the PreP and Input Device(s)
Bumpy depends on input devices capable of encrypting
input events generated by the user, so that the legacy OS can
pass the opaque events to the PreP without learning their
value. We now describe the process of establishing the nec-
essary cryptographic keys when input device(s) and a PreP
are ﬁrst associated.
The PreP is invoked with the command to establish a
new association with an input device. During this process,
the PreP:
1. Generates symmetric encryption and MAC keys
its own long-term state,
for
Klt enc, Klt mac, if they do not already exist.
the protection of
2. Generates an asymmetric keypair, Kinput , K −1
input , for
bootstrapping communication with the encrypting in-
put device, and adds the private key to its long-term
state. Note that no other software (not even a PoPr)
will ever be allowed to access K −1
input .
The public key Kinput is then conveyed to the input de-
vice. Given the complexity of equipping input devices with
root CA keys to verify certiﬁcates, we use a trust-on-ﬁrst-
use model where the input device simply accepts Kinput
and then prevents it from changing unexpectedly. Since
encryption-capable input devices like we require do not cur-
rently exist, we specify how the input device enters a state
where it is willing to accept a public encryption key. The
greatest challenge is to prevent key re-establishment from
being initiated in the presence of malicious code, whether
through a design or implementation failure or a social en-
gineering attack. One promising design may be a physi-
cal switch that must be placed into the “Establish Keys”
position before key establishment can commence. This
way, most users will establish keys once and forget about
it. Another alternative is to use a location-limited chan-
nel [3, 20, 33]. We describe input device key establishment
for our USB Interposer implementation in Section 8.
In the future, more sophisticated input devices may ver-
ify an attestation that the public key came from a known-
good PreP. Another promising alternative is that input de-
vice manufacturers imprint their devices with a certiﬁcate
establishing them as approved encrypting input devices,
though it can be challenging to establish that a certiﬁcate
corresponds to a particular physical device [22]. The PreP
can then verify the origin of input events as trustworthy,
provided that the PreP’s list of trusted CAs covers manu-
facturers’ signing keys.
Irrespective of the method of public-key exchange, sym-
metric keys for encryption and integrity protection should
be established to maximize performance. Additionally, we
require the use of sequence numbers so that the PreP can
detect if any keystrokes are dropped or reordered by the
legacy OS.
4.3 PreP State Freshness
The PreP must have the ability to protect its own state
when the legacy OS has control (i.e., across Flicker ses-
sions). The secrecy and integrity of the PreP’s state is en-
sured by encrypting it under a symmetric master key kept
in PCR-protected non-volatile RAM on the TPM chip. It is
PCR-protected under the measurement of the PreP itself, so
that no other code can ever unseal the master key. However,
protecting the freshness of the PCR-protected state is more
challenging. The risk is a state roll-back or replay attack
where, e.g., an attacker may try to keep the PreP in the Pass
Input Unmodiﬁed (Figure 3) state by perpetually providing
the same ciphertext of the PreP’s state as an input to the
PreP. The standard solution to this problem is to employ a
secure counter or other versioning scheme that can track the
latest version of the PreP’s state. While the TPM does im-
plement a monotonic counter [34], its speciﬁcation dictates
that the counter need only support incrementing every ﬁve
seconds. This is clearly insufﬁcient to keep up with per-
keystroke events. Our solution is to leverage the sequence
numbers associated with input events coming from the in-
put devices (Section 8.2.3).
5
Input Post-Processing and Attestation
We now detail the actions taken by the PoPr to Post-
Process sensitive input events enqueued by the PreP (Step 6
in Figure 2). Then, we describe the attestation process em-
ployed to convince the remote webserver (which is the PoPr
provider) that it is receiving inputs protected by Bumpy.
5.1 Post(cid:173)Processing Sensitive Input
The ﬁnal destination for sensitive input protected by
Bumpy is the webserver from which the current web page
originated. In Section 4.1, we describe how the PoPr is in-
voked by the PreP when the user has completed entering
sensitive input for a particular ﬁeld. The PoPr is provided
by the webserver hosting the current web page in the user’s
browser. The sensitive input is tagged with the name of
the ﬁeld that had focus when the input was entered, and
this {inputString, tag} pair is what the PoPr receives. The
PoPr can perform arbitrary, site-speciﬁc transformations on
the sensitive input before handing the (potentially opaque)
result to the web browser for transmission to the remote
webserver when the page is submitted.
5.1.1 Example Forms of Post-Processing
We consider two example forms of post-processing that we
believe to be widely useful on the web today, though there
may be many others. The ﬁrst is encryption of user in-
put such that only the webserver can process the raw in-
put, and the second is destination-speciﬁc hashing (with the
PwdHash algorithm [25]) so that, e.g., passwords cannot be
reused at multiple websites.
End-to-End Encryption. Encrypting sensitive inputs for
the webserver completely removes the web browser and
OS from the TCB of the input path for the ﬁeld accepting
the sensitive input, though it requires the webserver to be
Bumpy-aware. This capability is achieved on the user’s sys-
tem by embedding a webserver-generated public encryption
key in the PoPr. The PreP will automatically check that the
PoPr (and hence its encryption key) is certiﬁed by the web-
server from which it originated.
Note that it may seem tempting to have the input device
encrypt the user’s input all the way to the remote webserver,
removing the need for the PreP or PoPr. We prefer the ﬂex-
ibility afforded by the Flicker architecture to process input
in a PoPr on the user’s system in whatever way is appro-
priate for a given application or remote system. It is not
the duty of the input device manufacturer to foresee all of
these possible applications. Indeed, incorporating too much
programmability into the input device itself is sure to make
it a promising target for attack. Rather, the input device is
tasked solely with getting keystrokes securely to the PreP,
and websites concerned about the size of the input TCB can
supply their own minimized PoPr.
Destination-Speciﬁc Hashing with PwdHash. A second
form of post-processing – contained entirely within the
user’s system – is to perform a site-speciﬁc transformation
of certain ﬁelds before they are released to the web browser
for transmission to the webserver. For example, usernames
or passwords can be hashed along with the webserver’s do-
main name, thereby providing the user with additional pro-
tection when she employs the same username or password
at multiple websites. The domain name is obtained from the
webserver’s SSL certiﬁcate, which is veriﬁed by the PreP
before the PoPr begins executing. In Section 8, we describe
our implementation of the PwdHash [10, 11, 25] algorithm
within Bumpy.
5.1.2 Activating a PoPr
It is possible that malicious browser or OS code will in-
tentionally load the wrong PoPr for the current site. If the
PoPr is well-behaved (i.e., provided by a reputable web-
server), then it is unlikely to expose the user’s sensitive in-
put. However, attackers may intentionally use a PoPr from
a compromised server with a valid SSL certiﬁcate. In this
case, our defense is the Trusted Monitor, as it will display
the domain name and favicon4 of the website that has cer-
tiﬁed the current PoPr. It is the user’s responsibility to see
that the information on the Trusted Monitor corresponds to
the web page that she is browsing. We explain the detailed
operation of the Trusted Monitor, including the users’ re-
sponsibilities, and how secure communication between the
PreP and the Trusted Monitor is established, in Section 6.
4A favicon is an image associated with a particular website or web
page, installed by the web designer. It is commonly displayed alongside
the address bar and alongside a tab’s title for browsers that support tabs.
5.2 Attestation and Verifying Input Protections
• nonce – A nonce to provide replay protection for the
Flicker enables the computer using Bumpy to attest to
the PreP and PoPr that have run most recently. This attesta-
tion can be veriﬁed by a remote entity to ascertain whether
the user’s input received the intended protection. Though
there are no technical limitations governing which device
(or devices) perform the veriﬁcation, we proceed from the
perspective of the remote webserver as the veriﬁer. Insti-
tutions such as banks employ professional administrators
who are better suited than the average consumer to make
trust decisions in response to which PreP and PoPr are in
operation on the user’s computer. For certain types of trans-
actions (e.g., online banking), the webserver may be willing
to expose more services to a user whose computer can pro-
vide this assurance that the user’s input is being protected.
However, the user still must behave responsibly.
If veriﬁcation by the remote webserver succeeds, then
the requested web page can be served normally. However, if
veriﬁcation fails, then the software state of the user’s system
cannot be trusted, and the webserver should prevent access
to sensitive services. One option is to serve a web page with
an explanation of the error, though there is no guarantee that
the malicious (or unknown) software will display the error.
We discuss an extension to create a trusted path between
the Trusted Monitor and webserver for conveyance of such
error notiﬁcations in Section 10.
5.2.1 Establishing Platform Identity
TPM-based remote attestation is used to convince the web-
server that the user’s input is protected with Bumpy. How-
ever, the remote webserver must ﬁrst have a notion of the
identity of the user’s computer system. We use an Attesta-
tion Identity Key (AIK) generated by the TPM in the user’s
computer. Appendix A discusses known techniques for cer-
tifying an AIK, any of which can be applied to Bumpy.
Here, Bumpy beneﬁts from the property of the Flicker [18]
system that causes attestations to cover only the PreP and
PoPr code that was executed, and no other software at all.
5.2.2 The Attestation Protocol
Here, we describe the protocol between a user’s system
with Bumpy and a Bumpy-aware webserver when they con-
nect for the ﬁrst time. As an example, we consider a user
who is trying to login to a webserver’s SSL-protected login
page. The user’s browser sends a normal HTTPS request
for the login page.
In response, the webserver participates in an SSL con-
nection and delivers the login page. Embedded within the
page (e.g., in a hidden input element) are several Bumpy-
speciﬁc pieces of information, which must be signed by the
webserver’s private SSL key:
ensuing attestation.
• hash – The cryptographic hash of the PoPr. The PoPr
itself can be obtained with another HTTP request and
veriﬁed to match this hash.
• favicon – The favicon corresponding to the webserver.
• Cert ws enc – A public encryption key signed by the
webserver’s private SSL key.
A well-behaved browser then passes the newly received
PoPr, embedded information, and the webserver’s public
SSL certiﬁcate to the untrusted code module that manages
the invocation of Flicker sessions with the PreP. During
subsequent Flicker sessions, these data are provided as in-
put to the PreP. The PreP veriﬁes the webserver’s SSL cer-
tiﬁcate using its own list of trusted CAs, and veriﬁes that
the other input parameters are properly signed.
If all veriﬁcations succeed, an output message is pre-
pared for the webserver. This message requires the gen-
eration of an asymmetric keypair within the PoPr that will
serve to authenticate future encrypted strings of completed
input as having originated within this PoPr. This key is
generated and its private component is protected in ac-