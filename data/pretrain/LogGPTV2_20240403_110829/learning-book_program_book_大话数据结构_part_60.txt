10
k=2*k;
/子序列长度加倍
413
---
## Page 438
大话数据结
121
1.程序开始执行，数组L为{50,10,90,30,70,40,80,60,20），Lkength=9。
2.第3行，我们事先申请了额外的数组内存空间，用来存放归并结果。
3.第5~11行，是一个while循环，目的是不断地归并有序序列。注意k值的变
化，第8行与第10行，在不断循环中，它将由1→2→4一8→16，跳出循
环。
4.第7行，此时k=1，MergePass函数将原来的无序数组两两归并入TR（此函
数代码稍后再讲），如图9-8-11所示。
50
10
90
30
70
40
80
60
20
10
3090
40
70
60
08
20
图9-8-11
5.第8行，k=2。
6.第9行，MergePass函数将TR中已经两两归并的有序序列再次归并回数组Lr
中，如图9-8-12所示。
10
60
80
07
10
50
70
80
20
图9-8-12
7.第10行，k=4，因为k1ength）;
417
---
## Page 442
大话数保结构
又是一句代码，和归并排序一样，由于需要递归调用，因此我们外封装了一个函
数。现在我们来看QSort的实现。
/对顺序表L中的子序列L->r[1ow..high]作快速排序*/
void QSort（Sqlist *L,int low,int high)
int pivot;
if （lowr[1ow..high]-分为二，/
/算出枢轴值pivot·/
QSort（L,low,pivot-1）;
/*对低子表通细序·/
QSort（L,pivot+l,high）;
/对高子表远归排序/
F
从这里，你应该能理解前面代码“QSort（L1,L->length)：”中1和L->ength代码的
意思了，它就是当前待排序的序列最小下标值bw和最大下标值high。
这一段代码的核心是“pivot=Partition（Lbwhigh）：”在执行它之前，Lr的数组值
为{50,10,90,30,70,40.80,60,20}。Partition函数要做的，就是先选取当中的一个关键
字，比如选择第一个关键字50，然后想尽办法将它放到一个位置，使得它左边的值都
比它小，右边的值比它大，我们将这样的关键字称为枢轴（pivot）。
在经过Partition（L1,9）的执行之后，数组变成{20,10,40,30.5070,80.60,90}，并返
回值5给pivot，数字5表明50放置在数组下标为5的位置。此时，计算机把原来的
数组变成了两个位于50左和右小数组{20,10,40,30）和（70,80,60,90），而后的递归调用
“QSort（L,1,5-1）:和*QSort[L,5+1,9);*语句，其实就是在对{20,10,40,30}和{70,80,60,90}
分别进行同样的Partition操作，直到顺序全部正确为止。
到了这里，应该说理解起来还不算困难。下面我们就来看看快速排序最关键的
Partition函数实现。
/交换顺序表L中子表的记录，使枢轴记录到位，并返回其所在位置/
1此时在它之前（后）的记录均不大（小）于它。/
1int Partition（SqLiat *L,int low,int high）
2
3intpivotkey
418
---
## Page 443
第9章排序
4
pivotkey-L->r[low];
/用子表的第一个记录作相轴记录/
5
while(lowr[high]>=pivotkey)
high--!
9
swap（L，low，high）：/将比枢轴记录小的记录交换到低端·/
10
while（lowr[low]<-pivotkey)
11
low++;
12
swap（L，low,high）：/*将比枢轴记录大的记录交换到高端·/
13
14
return low;
/返回枢轴所在位置/
151
1.程序开始执行，此时bw=1，high=Llength=9。第4行，我们将
Lr[ow]=Lr[1]=50赋值给枢轴变量pivotkey，如图9-9-1所示。
下标
0
2
6
7
50
1090
30