将内存按容量划分为两块，每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。这样使得每次都是对半个内存区回收，也不用考虑内存碎片问题，简单高效。缺点需要两倍的内存空间。
3）标记-整理（Mark-Compact）
也分为两个阶段，首先标记可回收的对象，再将存活的对象都向一端移动，然后清理掉边界以外的内存。此方法避免标记-清除算法的碎片问题，同时也避免了复制算法的空间问题。
一般年轻代中执行GC后，会有少量的对象存活，就会选用复制算法，只要付出少量的存活对象复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外过多内存空间分配，就需要使用标记-清理或者标记-整理算法来进行回收。
**垃圾收集器：**
1）串行收集器（Serial）
比较老的收集器，单线程。收集时，必须暂停应用的工作线程，直到收集结束。
2）并行收集器（Parallel）
多条垃圾收集线程并行工作，在多核CPU下效率更高，应用线程仍然处于等待状态。
3）CMS收集器（Concurrent Mark Sweep）
CMS收集器是缩短暂停应用时间为目标而设计的，是基于标记-清除算法实现，整个过程分为4个步骤，包括：
-   初始标记（Initial Mark）
-   并发标记（Concurrent Mark）
-   重新标记（Remark）
-   并发清除（Concurrent Sweep）
其中，初始标记、重新标记这两个步骤仍然需要暂停应用线程。初始标记只是标记一下GC
Roots能直接关联到的对象，速度很快，并发标记阶段是标记可回收对象，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，这个阶段暂停时间比初始标记阶段稍长一点，但远比并发标记时间段。
由于整个过程中消耗最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，CMS收集器内存回收与用户一起并发执行的，大大减少了暂停时间。
4）G1收集器（Garbage First）
G1收集器将堆内存划分多个大小相等的独立区域（Region），并且能预测暂停时间，能预测原因它能避免对整个堆进行全区收集。G1跟踪各个Region里的垃圾堆积价值大小（所获得空间大小以及回收所需时间），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，从而保证了再有限时间内获得更高的收集效率。
G1收集器工作工程分为4个步骤，包括：
-   初始标记（Initial Mark）
-   并发标记（Concurrent Mark）
-   最终标记（Final Mark）
-   筛选回收（Live Data Counting and Evacuation）
初始标记与CMS一样，标记一下GC Roots能直接关联到的对象。并发标记从GC
Root开始标记存活对象，这个阶段耗时比较长，但也可以与应用线程并发执行。而最终标记也是为了修正在并发标记期间因用户程序继续运作而导致标记产生变化的那一部分标记记录。最后在筛选回收阶段对各个Region回收价值和成本进行排序，根据用户所期望的GC暂停时间来执行回收。
**了解了JVM基础知识，下面配置下相关Java参数，将下面一段放到catalina.sh里面：**
  -----------------------------------------------------------------------
  JAVA_OPTS=\"-server -Xms1024m -Xmx1536m -XX:PermSize=256m
  -XX:MaxPermSize=512m
  -XX:+UseConcMarkSweepGC -XX:+UseParallelGCThreads=8
  XX:CMSInitiatingOccupancyFraction=80 -XX:+UseCMSCompactAtFullCollection
  -XX:CMSFullGCsBeforeCompaction=0 -XX:-PrintGC -XX:-PrintGCDetails
  -XX:-PrintGCTimeStamps -Xloggc:../logs/gc.log\"
  -----------------------------------------------------------------------
  -----------------------------------------------------------------------
  ------------------------------------------------------------------------------------------------------------
  **参数**                                 **描述**
  ---------------------------------------- -------------------------------------------------------------------
  -Xms                                     堆内存初始大小，单位m、g
  -Xmx                                     堆内存最大允许大小，一般不要大于物理内存的80%
  -XX:PermSize                             非堆内存初始大小，一般应用设置初始化200m，最大1024m就够了
  -XX:MaxPermSize                          非堆内存最大允许大小
  -XX:+UseParallelGCThreads=8              并行收集器线程数，同时有多少个线程进行垃圾回收，一般与CPU数量相等
  -XX:+UseParallelOldGC                    指定老年代为并行收集
  -XX:+UseConcMarkSweepGC                  CMS收集器（并发收集器）
  -XX:+UseCMSCompactAtFullCollection       开启内存空间压缩和整理，防止过多内存碎片
  -XX:CMSFullGCsBeforeCompaction=0         表示多少次Full GC后开始压缩和整理，0表示每次Full
                                           GC后立即执行压缩和整理
  -XX:CMSInitiatingOccupancyFraction=80%   表示老年代内存空间使用80%时开始执行CMS收集，防止过多的Full GC
  ------------------------------------------------------------------------------------------------------------
**注意：**不是JVM内存设置越大越好，具体还是根据项目对象实际占用内存大小而定，可以通过Java自带的分析工具来查看。如果设置过大，会增加回收时间，从而增加暂停应用时间。
博客地址：http://lizhenliang.blog.51cto.com
QQ群：323779636（Shell/Python运维开发群）
**gzip压缩作用：**节省服务器流量和提高网站访问速度。客户端请求服务器资源后，服务器将资源文件压缩，再返回给客户端，由客户端的浏览器负责解压缩并浏览。
使用Apache与Tomcat整合，因为Tomcat处理静态文件能力远不足Apache，因此让Apache来处理静态文件，Tomcat处理动态jsp文件，可以有效提高处理速度。
在集群架构下，会涉及到一个问题，怎么保存Session？
**TomcatSessionID持久化三种方法：**
   Session粘性：通过浏览器Cookie绑定SessionID，通过sticky模式将同一Session请求分配到同一Tomcat上。
   Session复制：Tomcat通过广播形式将Session同步到其他Tomcat节点，并且Linux下要手动开启开放广播地址。不易后端节点过多
 Session保存数据库（memcache、redis）：将SessionID保存在共享的数据库中。
**OOM（Out of Memory）异常常见有以下几个原因：**
1）老年代内存不足：java.lang.OutOfMemoryError:Javaheapspace
2）永久代内存不足：java.lang.OutOfMemoryError:PermGenspace
3）代码bug，占用内存无法及时回收。
前两种情况通过加大内存容量，可以得到解决。如果是代码bug，就要通过jstack、jmap、jstat自带的工具分析问题，定位到相关代码，让开发解决。