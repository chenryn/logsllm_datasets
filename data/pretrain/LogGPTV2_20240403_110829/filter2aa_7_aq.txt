代码之城
  对于开发者来说，互联网软件与桌面软件最显著的区别就是，前者不是一个单独的代码块。它是许多不同种类程序的集合，而不是一个单独的巨大的二进制文件。设计桌面软件就像设计一幢大楼，而设计互联网软件就像设计一座城市：你不仅需要设计建筑物，还要设计道路、路标、公用设施、警察局、消防队，并且制定城市发展规划和紧急事件的应对方案。
  Viaweb的软件包括：与用户直接对话的一些大型应用程序、被这些大型程序使用的程序、常驻后台报告系统出错的程序、重新启动出错部分的程序、生成统计报告或数据库索引的程序（偶然运行）、回收资源或者移动及恢复数据的程序（手动运行）、伪装成用户的程序（为了测试系统和发现bug）、诊断网络故障的程序、完成备份的程序、对外提供服务界面的程序、实时显示服务器状态和访问数据的程序（很受用户欢迎，对我们也是必不可少的）、修改后的开源软件程序（包括修正bug）以及许许多多的配置和设定文件。在我们被雅虎买下以后，Trevor Blackwell写过一个令人叹为观止的程序，可以在不关闭网站的情况下，将网上商店转移到另一个机房的服务器上。此外，还有向系统管理员发出传呼信号的程序，向用户发传真和电子邮件的程序，引导完成信用卡交易的程序，在套接字、通信管路、HTTP请求、SSH、UDP数据包、共享内存、文件之间互相通信的程序。一部分Viaweb服务器上故意不安装某些程序，因为保证Unix系统安全的关键之一就是不运行那些不需要的东西，降低服务器被侵入的可能性。
  光有软件还不够，我们还花了许多时间琢磨服务器应该如何配置。我们自己搭服务器，不仅为了省钱，也是为了让机器完全满足我们的需要。我们还考虑哪些ISP连接主干网的带宽比较大。我们一直与RAID供应商保持联系。
  但是，硬件需要考虑的地方，不仅仅在于怎么才能避免出问题，还在于怎样才能最大地发挥它们的作用。只要你控制了硬件，就能为用户提供更多的功能。如果你的产品是桌面软件，你就只能规定硬件的最低配置，无法为了某一个功能而要求用户增加硬件。但是，如果你控制了服务器，你就能轻而易举地增加功能，使用户可以发出寻呼、发送传真、通过电话操作网站、使用信用卡付款等。你所需要做的只是安装相关的硬件。我们总是在寻找通过硬件增加新功能的方法，因为这可以赢得用户，还可以让我们超越那些不直接控制硬件的竞争者（他们要么出售桌面软件，要么通过ISP分销互联网软件）。
  由于互联网应用程序由多种软件而不是单独一个二进制文件构成，所以可以使用多种编程语言开发。如果你的产品是桌面软件，一般来说，你总是被迫采用与操作系统一致的语言，也就是C和C++。所以，这些语言就被认为是“正统的”软件开发语言（非技术人员尤其可能这样想，比如经理层和风险投资家）。但是，这其实是一个伪信号（artifact），不能因为桌面软件是这样开发的，就认定所有软件都是这样开发的。对于互联网软件，你可以使用任何你想用的语言^。当今，许多顶尖黑客使用的语言与C和C++大相径庭：Perl，Python，甚至还有Lisp。
^“1995年我们创立Viaweb的时候，Java applet被认为是互联网软件的解决方案。但是我们觉得，applet采用的还是过时的概念，它还是要求下载软件到客户端运行。更好更简单的方法，应该是所有的工作都放在服务器端完成。我们在applet上面浪费了一点时间，还好没延误什么，但是数不清的其他创业公司经不起引诱，掉进了这个泥潭，它们几乎都没有逃脱失败的命运。”
  对于互联网软件，没人规定只能使用某些语言开发，因为所有的硬件都控制在你手里，你想要用什么语言，就能用什么语言。不同的语言适合不同的任务，你应该根据不同场合，挑选最合适的工具。尤其是在竞争者存在的情况下，“可以这样做”就变成了“必须这样做”（详见后文），因为如果你不利用语言的优势，那就会听任对手超过你。
  我们的大多数竞争者使用C和C++，这使得他们的软件明显不如我们，因为（不考虑其他原因）他们无法解决CGI脚本不能识别用户状态的问题。如果用户想要修改表单的部分内容，你不得不把表单的所有内容都放在同一个页面上，然后在最下面放一个“更新”按钮。正如我将在第12章中解释的，通过使用Lisp这种许多人眼中的教学语言，我们使得Viaweb编辑器更接近桌面软件带给用户的体验。
软件的发布
  互联网软件带来的最大变化之一，就是软件发布方式的改变。对于桌面软件来说，发布新版本是一个很痛苦的过程，整个公司不得不使尽全力，满头大汗地挤出一大块巨型代码。从过程和结果上来看，无异于一次分娩。
  互联网软件则完全不同，就像你写给自己用的程序一样，修改起来很方便。软件的发布过裎可以分解为一系列的渐进式修改，而不是猛地推出一个大幅变动的版本。常见的桌面软件可能一年发布一到两个新版本，而我们在Viaweb经常是一天发布三到五个版本。
  一旦采用了这种新模式，你就会知道发布方式对软件开发的影响有多么重大。桌面软件开发之中的许多棘手问题，都是源自于它的那种灾难性的发布方式。
  如果一年发布一个新版本，你很可能会以打包方式处理bug，把它们留着，然后一次性全部解决。在发布新版本前，你可能会修改和更换一半的代码，从而又引入无数新的bug。接着，质量监控人员（Quality Assurance）开始测试新代码，逐一列出新发现的bug，你再按照这张清单把它们一个个消除。通常没办法把清单全部做完，它随时都在增长，说实话，谁也不确定它到底会有多长。这就好像在足球场上捡小石块一样费劲，你永远不知道为什么软件内部会出这么多问题。最好的结果也不过是，你得到了一个统计学意义上“合格”的版本。
  对于互联网软件来说，大部分的变化都是细微和渐进的，所以引入bug的机会比较小。而且，在发布前测试的时候，你知道应该最仔细地测试哪个部分——显然就是你修改过的部分。这使得你对代码的掌握变得牢固得多。一般来说，这时候你确实是对软件内部的情况一清二楚。当然，这不是说你把所有代码都装在了脑子里，而是说你阅读代码的时候，非常自如流畅，不会像侦探破案那样苦思冥想，而是像飞行员那样，瞄一眼仪表板，就对飞行状况胸有成竹。
  桌面软件导致了bug的宿命论。你很清楚，发布出去的软件肯定有bug，你甚至早就准备好了应对机制（比如发布补丁）。既然如此，bug再多一点又何妨？没过多久，你要发布下一个版本了，你明知其中某个操作完全不能使用，但还是照样发布。苹果公司前几年就干过这种事。他们必须发布新版操作系统了，压力越来越大，发布日期已经推迟了四次，无法再推了，可是有些部分还一点儿没写（比如CD和DVD操作的部分）。怎么办？他们就把没写完的操作系统发布出去了，用户必须日后自己动手安装缺失的部分。
  互联网软件的发布规则是：它运行不了，你就无法发布；一且它能运行了，你就可以立刻发布。
  这个行业的老手可能会想：你说得好听！软件运行不了，就不发布，但是如果你已经对外承诺了明确的发布日期，到时却没有准备好，怎么办？这个问题听起来有道理，但是事实上，你不会对互联网软件做出这样的承诺，因为它根本没有“版本”这个概念。你的软件是连续性渐变的，某些更新也许比较重大，但是“版本”这个概念不适用于互联网软件。
  如果你还没忘记Viaweb的旧事，你可能会觉得我这么说听上去很奇怪，因为那时我们总是宣布将有新版本推出。这只是公关伎俩啦，我们知道媒体喜欢听到版本号。如果你发布一个大的版本更新（版本号的第一位数发生变动），它们就会以大篇幅报道；如果你发布一个小的版本更新（版本号小数点后发生变化），它们最多只用一段话提一下。
  我们的一些竞争对手的产品是桌面软件，确实有版本号。对我们来说，这种发布方式只表明他们的落后，但是他们却因此把媒体的目光都吸引过去了。我们不想做局外人，所以也开始为自己的软件加上版本号。什么时候需要媒体宣传了，就开出一张单子，上面总结了自从上次“发布”以来，我们新增的所有功能，然后在上面填一个新的版本号，发出一个新闻稿，宣布新版本已经准备就绪了。真是神奇啊，从来没有人看穿我们的把戏。
  到被收购的时候，我们已经这样干了三次，所以已经到了第四版。如果我没记错的话，那时是4.1版。Viaweb变成Yahoo Store以后，媒体的曝光就没有那么必要了。所以，虽然软件一直没有中断开发，但是版本号却悄悄地被放弃了。
软件bug
  互联网软件的另一个技术优势在于，你能再现大部分的bug。用户的数据都在你的硬盘上。如果某个用户使用软件时出错了，你就不必像开发桌面软件那样苦苦猜测到底发生了什么事情。一般来说，只要用户通过电话向你描述一番，你就能把问题再现出来。如果你的程序中有自动侦测错误的代码，那么不用等到用户找上门，你可能已经知道哪里出错了。
  互联网软件每时每刻都在被使用。你的代码一上线，就会经历严酷考验。bug很快就会浮出水面。
  软件公司有时会受到指责，因为他们竟然把发现bug的任务交给用户去完成。说实话，我其实提倡这种做法。对于互联网软件，这样做的好处很多，因为它的bug相对比较少，而且处理周期比较短。我们连续不断地发布新版本，所以bug就比较少。我们能够再现用户遇到的问题，又能在修复后立刻发布，使得用户不用等很长时间，所以大部分bug的处理周期都比较短。我们的bug数量一直不多，以至于没有必要使用一个正式的bug追踪系统。
  当然，在发布之前，你应该对修改之处进行测试，避免出现重大的bug。难免会有一些bug成为漏网之鱼，不过它们纯属罕见情况下才会发生的个案，在真正接到用户投诉之前，几乎不会影响到什么人。只要你能立刻解决bug，对于普通用户来说，他们就会觉得你的软件几乎是亳无问题的。我觉得，普通的Viaweb用户可能一个bug都没遇到过。
  解决新代码的bug要比解决历史遗留代码的bug容易。在自己刚刚写好的代码中，找出bug往往会比较快。有时，你只要看到出错提示，就知道问题出在哪里，甚至都不用看源码，因为潜意识中你已经在担心那个地方可能会出错。如果你要解决的bug出自于6个月前写好的代码（假定你一年发布一个新版本，那么6个月就是发现bug的平均时间），那么就麻烦了，就要大费周章了。那时，你对代码也已经不熟悉了，就更可能采用危险的方式解决问题，甚至引入更多的bug^。
^“这个观点引申自特雷弗·布莱克韦尔（Trevor Blackwell）的话，他说：“随着软件规模的增大，开发成本指数式上升。这可能是因为修正旧bug的原因。如果bug都能被快速发现，成本的上升形态就能基本保持线性。””
  早一点发现bug就不容易形成复合式bug，也就是互相影响的两个bug。举例来说，一个bug是楼梯很滑，另一个bug是扶手松了，那么只有当这两个bug互相作用时，才会导致你从楼梯上摔下来。在软件中，复合式bug是最难发现的bug，往往也会导致最大的损失^。传统的方法是：“把软件彻底拆开，将所有bug统统清理干净。”这样做难免产生一大堆的复合式bug。如果软件是经常性发布，每次只有小幅度的变化，那么就不容易产生复合式bug。这就好比做扫除：你一直在打扫大厅，掉落在地板上的东西会被立刻清理，省得它们时间一长与其他东西粘在一起。
^“复合式bug有一个子类型：两个bug是互相弥补的，好比“负负得正”，软件反而能正常运行。这种bug可能才是最难发现的bug。当你修正了其中的一个bug，另一个bug才会暴露出来。这时对你来说，你会觉得刚才修正错了，因为那是你最后修改的地方，你就怀疑自己在那里做错了，但是你其实是对的。”
  有一种编程方法叫做“函数式编程”（functional programming），它对你会有帮助，可以避免一些副作用。函数式编程在学术文献中研究得比较多，在商业软件中用得比较少。但是，对于互联网软件，它却很有用。很难用纯粹的“函数式编程”完成整个程序，但是它可以用来编写一些重要的部分，使得这些部分易于调试，因为它们不包含“状态”（state），非常便于不断进行小幅的修改和测试。我大量使用这种方法开发Viaweb的编辑器，我们自己的脚本语言RTML就是一种纯粹的函数式编程语目。