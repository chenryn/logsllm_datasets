title:A Performance Study on the Signal-On-Fail Approach to Imposing Total
Order in the Streets of Byzantium
author:Qurat-ul-Ain Inayat and
Paul Devadoss Ezhilchelvan
A Performance Study on the Signal-On-Fail Approach to Imposing Total 
Order in the Streets of Byzantium 
Qurat-ul-Ain Inayat and Paul Devadoss Ezhilchelvan  
School of Computing Science 
University of Newcastle, Newcastle upon Tyne, UK 
{q.inayat, paul.ezhilchelvan}@ncl.ac.uk 
Abstract 
exposes 
the  well-known 
result.  This  paper 
Any  asynchronous 
circumvent 
that  paired  processes  do  not 
invoking 
total-order  protocol  must 
FLP 
somehow 
impossibility 
the 
performance gains obtained when this impossibility is 
dealt with through the use of abstract processes built 
to  have  some  special  failure  semantics.  Specifically, 
we build processes with signal-on-fail semantics by (i) 
having  a  subset  of  Byzantine-prone  processes  paired 
to check each other’s computational outputs, and (ii) 
assuming 
fail 
simultaneously.  By 
the 
construction of signal-on-fail processes, coordinator-
based total-order protocols which allow less than one-
third  of  processes  to  fail  in  a  Byzantine  manner  are 
developed.  Using  a  LAN-based 
implementation, 
failure-free order latencies and fail-over latencies are 
measured;  the  former  are  shown  to  be  smaller 
compared to the protocol of Castro and Liskov which 
is  generally  regarded  to  perform  exceedingly  well  in  
the best-case scenarios. 
1. Introduction 
dynamically 
Managing  service  or  state  machine  replication  in 
the  presence  of  faults  requires  that  the  non-faulty 
replicas be enabled to determine an identical order on 
client  requests  [18].  We  address 
this  ordering 
requirement when nodes hosting replicas can fail in a 
malicious, Byzantine manner and are connected by an 
asynchronous network, e.g., the Internet, wherein the 
message  transfer  delays  cannot  be  bounded  with 
certainty  by  a  known  constant.  In  particular,  we 
propose,  and  evaluate  the  benefits  of,  a  novel 
approach 
the  well-known  FLP 
impossibility  [5]  which  states  that  the  ordering 
requirement  cannot  be  met  deterministically  if  the 
network  is  asynchronous  and  if  replicas  fail  even 
to  circumvent 
merely  by  crashing,  i.e.  stopping  to  function  in  a 
quiescent manner.  
Several  order  protocols  appear  in  the  literature 
(e.g.,  [21,  16,  12,  3]),  circumventing 
the  FLP 
impossibility in distinct ways. Of them, the Byzantine 
Fault-Tolerant  order  protocol  by  Castro  and  Liskov 
[2],  denoted  here  as  BFT,  has  been  shown  to  have 
outstanding  performance,  particularly  when  there  are 
no failures. BFT is a co-ordinator based deterministic 
protocol and requires a partially synchronous network 
[4] wherein message delays eventually stabilise to an 
estimated bound for a sufficiently long period of time.  
The  protocols  developed  here  are  shown  to  perform 
faster  than  BFT  and  also  with  a  smaller  message 
overhead  in  failure-free  scenarios.  Furthermore,  they 
allow  most  of  the  replicas  to  be  connected  by  an 
asynchronous network. 
Our 
approach 
fail-signals 
latencies  and 
to  dealing  with 
the  FLP 
impossibility  is  to  dynamically  construct  an  abstract 
process  with  signal-on-crash  semantics:  it  fails  only 
by  crash  and  additionally 
its  own 
imminent  crash.  When  failures  are  signalled,  the 
impossibility result ceases to apply and when they do 
not  involve  producing  incorrect  outputs,  a  simplified 
protocol  structure,  smaller 
lower 
message  overhead  ensue.  Construction  of  such  a 
process however requires additional assumptions of a 
particular  class  not  uncommon  in  the  literature  (e.g., 
[19,  6,  13,  7]):  processes  of  the  system  are  grouped 
and  the  members  of  a  group  are  assumed  to  exhibit 
some  prescribed  failure  behaviour.  In  our  case,  a 
subset  of  processes  in  the  system  is  paired  and  the 
paired processes cannot fail at the same time. To this 
end,  we  consider  two  alternative  assumptions:  given 
that one process in a pair has failed, the other remains 
non-faulty (1) for some specified minimum amount of 
time (1_after_1) or (2) for ever (never_2_Fail).  
The  paired-up  processes,  on  being  called  upon, 
construct  an  abstract,  signal-on-crash  process  similar 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 04:20:38 UTC from IEEE Xplore.  Restrictions apply. 
the  signal-on-crash  process  and 
to  the  way  the  component  processes  of  the  abstract 
fail-stop  process  [19]  maintain  the  signal-on-crash 
property.  They  operate  in  parallel  and  endorse  each 
other’s  outputs if the latter are found consistent with 
own outputs. The endorsed outputs are treated as the 
outputs  of 
the 
endorsement  is  indicated  through  digital  signatures 
that  are  assumed  to  be  non-forgeable.  If  a  process 
within  a  pair  suspects  a  failure  of  its  counter-part,  it 
stops all activities related to implementing the signal-
on-crash process abstraction and indicate this stopping 
by outputting a fail-signal message. Thus, the signal-
on-crash  process  either  outputs  verifiably-endorsed 
messages of correct contents or stops functioning after 
signalling its stopping. That is, it can only crash and 
when it does, it fail-signals prior to doing so.  
A  requirement  for  failure  detection  within  a 
process pair is that each process be able to detect the 
absence  of  an  output  expected  from  the  other. 
Otherwise,  an  indefinite  waiting  will  result  if  the 
expected  output  is  not  produced.    So,  we  make 
assumptions  concerning  the  communication  delays 
and  the  relative  processing  delays  between  processes 
of  a  given  pair.  We  consider  two  delay  models:  the 
the  partially 
synchronous  model 
and 
synchronous  model  [4]  (PSync). 
  We  develop 
protocols  for 
two  combinations  of  assumptions, 
{1_after_1,  Sync}  and  {never_2_Fail,  PSync},  and 
study their performance.  
(Sync) 
The paper is structured as follows: the next section 
presents the system model and assumptions. Section 3 
describes the signal-on-crash process construction and 
Section 4 the order protocol for {1_after_1, Sync} first 
and  then  for  {never_2_Fail,  PSync}.  Section  5 
measures  and  presents 
the  protocols’  fault-free 
performance  in  relation  to  both  BFT  and  a  simple 
crash-tolerant  protocol,  and  the  fail-over  latencies. 
Section  6  concludes  the  paper  by  examining  the 
literature  for  related  work  and 
the 
limitations of our approach. 
2. System Model 
identifying 
We  suppose  that  a  service,  constructed  as  a 
deterministic state machine, is (as shown in Figure 1) 
replicated  over  (2f+1),  f  ≥  1,  nodes  connected  by  a 
network  that  is  reliable  and  also  asynchronous  (like 
the  Internet)  in  transferring  messages.  That  is,  every 
sent message is delivered uncorrupted at destination(s) 
and  message  transfer  delays  are  finite  but  cannot  be 
guaranteed to be bounded by a known constant.  
to 
fail 
independently of each other, and fr, 0 ≤ fr ≤ f, of them 
can  fail  in  a  (cryptography-constrained)  Byzantine 
replica  nodes 
assumed 
The 
manner. Despite this, the service is to be made fault-
tolerant  by  meeting  the  well-known  state  machine 
replication requirements [18]; the hardest one amongst 
them  is  to  ensure  that  non-faulty  replicas  process 
identical  sequence  of  requests  sent  by  the  clients  of 
this (replicated) service, and this will be the sole focus 
of  this  paper.  For  this  reason,  we  regard  that  the 
clients are correct and the processing of client requests 
is assumed not to require availing of services provided 
elsewhere.  (See  [11]  for  making  multi-tiered  service 
provisioning Byzantine fault tolerant.)  
Of  the  (2f+1)  replica  nodes,  at  least  f  nodes  are 
chosen to be supplemented with a shadow node solely 
for achieving fault-tolerant ordering of client requests 
over  an  asynchronous  network.  So,  as  in  [22],  these 
shadow nodes are a part of the Asynchrony-Byzantine 
(AB)  order  supplement  scheme  (See  Fig  1)  which  is 
distinct  from  the  Byzantine  fault-tolerant  service 
replication scheme (s1, s2, .. , s(2f+1)).   
Figure 1. System Architecture. 
replication  scheme.  Thus,  all 
We  will  denote  a  process  that  executes  the  order 
protocol in the ith replica node as pi, 1 ≤ i ≤ (2f+1), and 
adopt  the  convention  of  using  ′  to  denote  the  order 
process in a shadow node, e.g., p′i denotes the shadow 
of  pi.  Note  that  there  is  no  s′i.  The  paired  processes 
{pi,  p′i}  may  be  called  on  to  implement  signal-on-
crash  process;  to  this  end,  their  host  nodes  are 
connected to each other by a fast reliable network. The 
communication  between  any p′i  and pj  or  p′j,  i  ≠  j is 
over the reliable asynchronous network of the service 
level 
forms  of 
communication  in  our  system  except  those  between 
paired  nodes  conform  to  the  classical  asynchronous 
model.  We  make  three  major  assumptions  that  are 
stated below. The first two are commonly made in the 
known  Byzantine  fault-tolerant  solutions  to  message 
ordering in asynchronous networks.  
2.1. Assumptions 
Assumption  1.  Shadow  nodes  fail  independently  and 
also in a Byzantine manner. The total number of failed 
shadow nodes does not exceed fs, 0 ≤ fs ≤ f, such that 
are 
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 22,2021 at 04:20:38 UTC from IEEE Xplore.  Restrictions apply. 
the  total  number  of  failed  nodes  in  the  system  never 
exceeds f: fr+fs ≤ f.  
When  exactly  f  service  replica  nodes  are  paired 
with a shadow, we have the optimum requirement for 
Byzantine fault-tolerant ordering: n = 3f +1, where n is 
the total number of nodes in the system.  
Assumption  2.  We  assume 
the  known 
that 
cryptographic  techniques,  such  as  public-key  RSA 
signatures and message authentication codes [20], are 
robust  enough  to  prevent  message  spoofing  and 
replays and to detect message corruption. Specifically, 
a  non-faulty  process’  signature  for  a  given  message 
cannot  be  forged  and  any  attempt  to  alter  a  message 
signed  by  a  non-faulty  process  will  be  detected. 
Moreover, the hash-functions used are assumed to be 
1-way  and  collision-resistant:  it  is  not  possible  to 
compute information from the digests produced using 
these functions or to find more than one message with 
the  same  digest.  Finally,  we  assume  that  a  trusted 
dealer  initializes  the  system  and  the  nodes  with 
cryptographic keys and hash functions. 
2.1.1.  Assumptions  specific  to  signal-on-crash 
approach. Say, order processes p and p′ are paired to 
implement a signal-on-crash process. Essentially, each 
checks the other’s output from both value and timing 
perspectives  and  endorses  it  if  it  is  deemed  correct 
relative to the locally generated output or emits a fail-
signal  otherwise.  Constructing  a  signal-on-crash 
process  in  this  way  requires  making  assumptions 
about  two  timing-related  aspects.  The  first  aspect  is 
about  the  ability  to  accurately  estimate  a  differential 
delay bound within which one order process that has 
produced  an  output  can  expect  its  counter-part  to  do 
the  same,  if  the  counter-part  is  also  operating  in  a 
timely  manner  and  an  output  is  expected  as  per  the 
order protocol. Obviously, if an accurate estimation of 
this bound cannot be guaranteed, then correct  p and p′ 
can  falsely  suspect  each  other  of  untimely  behavior 
and  the  abstract  process  will  be  falsely  indicated  to 
have ‘crashed’. One could design protocols ruling out 
this false signaling altogether or by coping with it. The 
latter  will 
involve  making  a  relatively  weaker 
assumption on the bound estimation process. 
Signal-on-crash  semantics  cannot  be  realized  if 
both  p  and  p′  can  fail  simultaneously.  The  second 
aspect is therefore about eliminating this possibility by 
defining a minimum time interval in which one node 
remains  non-faulty  while  the  other  has  failed.  An 