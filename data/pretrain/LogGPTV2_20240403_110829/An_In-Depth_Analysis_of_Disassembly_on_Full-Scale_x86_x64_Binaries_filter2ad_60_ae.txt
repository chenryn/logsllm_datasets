rather than automated analysis. However, disassembly
errors can still affect the decompilation process itself,
especially in later passes (such as stack frame analysis
or data type analysis passes) over the raw decompiled
function. Such analysis phases, as well as human reverse
engineers, must take into account the high probability of
errors in function boundary and signature information.
4.3 Automatic Bug Search
The binary analysis requirements of automatic bug search
systems depend on the type of bug being searched for,
and the granularity of the search. In practice, many such
systems operate at the function level, both for ease of
analysis, and because it is a suitable search-granularity
for common bugs, such as stack-based bugs [14, 27, 50].
Operating at the function level is also useful for interop-
erability with other binary analysis primitives, such as
symbolic execution, which are powerful tools for seman-
tic analysis but do not scale to full binaries [14].
Thus, like decompilation, many automatic bug search
systems rely on accurate function boundary information
and per-function CFGs. Fortunately, despite the relatively
large inaccuracies in the input information, the output
of bug detection systems tends to degrade gracefully —
input inaccuracies may lead to bugs being missed, but
typically do not affect the correctness of the analysis for
other parts of the code. Quantifying the accuracy of the
inputs (disassembly, CFG, function boundaries) helps
users to determine the expected output completeness of
automatic bug search systems.
5 Disassembly in the Literature
Given our disassembly results, we studied recent binary-
based research to determine how well the capabilities
USENIX Association  
25th USENIX Security Symposium  595
13
Instructions
u
F
nctions
Signatures
G
F
C
h
Callgrap
Property
Subproperty
# %
# %
All papers
Top-tier
Windows PE x86/x64 (16 papers, 12 top-tier)
Papers
#
0
2
0
1
0
13
0
4
2
8
30
angr
BAP
ByteWeight
Dyninst
Hopper
IDA Pro
Jakstab
PSI/BinCFI
Linear
Other/Custom
Total
0
1
0
1
0
11
0
3
2
7
25
0
2
0
0
0
6
0
3
1
2
14
0
1
0
0
0
2
0
0
0
0
3
0
2
0
1
0
11
0
3
1
6
24
0
0
0
1
0
4
0
2
1
3
11
Obfuscated code
Optimized binaries
Stripped binaries
Recursive disassembly
Needs relocation info
Primitive errors discussed Instructions
Complex cases discussed
Primitive errors handled
Functions
Signatures
Callgraph
CFG
Overestimate
Underestimate
Runtime
31%
5
88%
14
15
94%
16 100%
12%
2
38% 5 (9)
20% 1 (4)
0% 0 (2)
80% 4 (5)
38% 5 (10)
31%
5
4
25%
2
19%
1
6%
81%
11
33%
4
92%
11
11
92%
12 100%
17%
56%
25%
0%
80%
50%
42%
33%
17%
8%
92%
2
5 (13)
1 (5)
0 (2)
4 (5)
5 (13)
5
4
3
1
13
Table 4: Primitives/disassemblers used in the literature.
Errors are fatal
of disassemblers match the expectations in the literature.
Our study covers research published between 2013 and
2015 in all top-tier systems security conferences, namely
S&P (Oakland), CCS, NDSS and USENIX Security. In
addition, we cover research published in these same years
at RAID and ACSAC, two other major conferences which
are popular targets for such research.
We found 30 papers on binary-based research published
in these venues, summarized in Table 6. The rest of this
section presents aggregated ﬁndings to provide a degree
of anonymization for these papers.
Table 4 shows the primitives and disassemblers used
in these papers. IDA Pro is by far the most popular, for
all primitives; our disassembly results (Section 3) justify
this choice. Despite its good accuracy, linear disassembly
is among the least used, even for papers that handle only
ELF binaries. This may result from the widespread belief
that inline data causes far more problems than we found.
Instructions are the most often needed primitive, used
by 25 of the 30 papers. It is followed by the CFG (24
papers) and function starts (14 papers). Function signature
information is needed by only 3 of the analyzed papers.
One paper used linear disassembly as a basis for building
a CFG and callgraph, and scanning for function starts.
Table 5 provides a more detailed insight into the prop-
erties of the papers we analyzed. We distinguish between
papers that target Windows PE binaries, and those that
target Linux ELF. This is because some complex cases,
such as inline data, are more often generated by Visual
Studio, deserving closer attention in Windows papers.
Most papers that support obfuscated binaries target
Windows (33% of papers versus 10% for Linux). This is
because obfuscation typically occurs in malware, which is
more prevalent on Windows. Though we do not consider
obfuscated binaries in our tests, it is still interesting to
know how many papers target such binaries. After all,
these papers should pay special attention to disassembly
errors and complex corner cases. Unfortunately, this is
not the case; only 50% of papers that support obfusca-
tion discuss potential errors, while 33% implement error
Linux ELF x86/x64 (14 papers, 10 top-tier)
Obfuscated code
Optimized binaries
Stripped binaries
Recursive disassembly
Primitive errors discussed Instructions
Functions
Signatures
Callgraph
CFG
Overestimate
Underestimate
Runtime
Complex cases discussed
Primitive errors handled
Errors are fatal
1
7%
9
93%
7
79%
86%
8
50% 6 (9)
33% 3 (6)
10%
1
90%
13
70%
11
80%
12
67%
6 (12)
50%
3 (9)
1 (1) 100% 1 (1) 100%
50%
2 (6)
62%
5 (11)
10%
1
30%
4
0%
0
1
10%
60%
8
33% 2 (4)
45% 5 (8)
1
3
0
1
6
7%
29%
0%
7%
57%
Table 5: Properties of binary-based papers (number and
percentage of papers). Numbers in parentheses indicate
the total number of papers that use this primitive.
handling. This is no better than the overall number. More-
over, only 17% of these papers explicitly discuss complex
cases; far below the overall rate for Windows.
Nearly all papers support optimized binaries (90% or
more for both Linux and Windows, overall as well as
top-tier). Stripped binaries are supported by an equally
large majority of papers on Windows, and by a slightly
smaller majority on Linux. Curiously, the number of top-
tier papers that support stripped binaries on Linux (70%)
is signiﬁcantly less than the overall number (79%).
The vast majority of papers use recursive disassembly
(100% on Windows and 86% on Linux), with IDA Pro
being the most popular disassembler. The few papers
that do use linear disassembly are based on objdump, and
augment it with a layer of error correction. Interestingly,
these papers claim perfect (100% accurate) or close to
perfect disassembly. As shown in Section 3.1.1, this
precision on Linux binaries owes entirely to the core linear
disassembly, making any error correction redundant other
than for a few corner cases in library code (and obfuscated
code, which these papers do not consider).
A relatively small percentage of Windows papers use
relocation information to ﬁnd disassembly starting points.
At 17%, this number is slightly higher for top-tier papers.
Discussion on disassembly errors and complex cases is
somewhat lacking in the analyzed papers. For most prim-
596  25th USENIX Security Symposium 
USENIX Association
14
Title
Authors
Venue
Year
Top-tier
A Principled Approach for ROP Defense [30]
Binary Code Continent: Finer-Grained Control Flow Integrity (...) [41]
Blanket Execution: Dynamic Similarity Testing for Program (...) [11]
BYTEWEIGHT: Learning to Recognize Functions in Binary Code [4]
CoDisasm: Medium Scale Concatic Disassembly of Self-Modifying (...) [6]
Control Flow and Code Integrity for COTS binaries [49]
Control Flow Integrity for COTS Binaries [48]
Cross-Architecture Bug Search in Binary Executables [27]
DUET: Integration of Dynamic and Static Analyses for Malware (...) [15]
Dynamic Hooks: Hiding Control Flow Changes within (...) [40]
Hardware-Assisted Fine-Grained Control-Flow Integrity (...) [10]
Heisenbyte: Thwarting Memory Disclosure Attacks using (...) [37]
High Accuracy Attack Provenance via Binary-based (...) [20]
Improving Accuracy of Static Integer Overﬂow Detection in Binary [50]
Leveraging Semantic Signatures for Bug Search in Binary Programs [28]
Native x86 Decompilation Using Semantics-Preserving (...) [33]
No More Gotos: Decompilation Using Pattern-Independent (...) [44]
Opaque Control-Flow Integrity [24]
Oxymoron Making Fine-Grained Memory Randomization Practical (...) [2]
Practical Context-Sensitive CFI [1]
Practical Control Flow Integrity & Randomization for (...) [46]
Reassembleable Disassembling [42]
Recognizing Functions in Binaries with Neural Networks [35]
ROPecker: A Generic and Practical Approach for Defending (...) [9]
StackArmor: Comprehensive Protection from Stack-based (...) [8]
Towards Automated Integrity Protection of C++ Virtual Function (...) [13]
Towards Automatic Software Lineage Inference [16]
vfGuard: Strict Protection for Virtual Function Calls (...) [29]
VTint: Protecting Virtual Function Tables’ Integrity [45]
X-Force: Force-Executing Binary Programs for Security (...) [26]
Qiao et al.
Wang et al.
Egele et al.
Bao et al.
Bonfante et al.
Zhang et al.
Zhang et al.
Pewny et al.
Hu et al.
Vogl et al.
Davi et al.
Tang et al.
Hyung Lee et al.
Zhang et al.
Pewny et al.
Schwartz et al.
Yakdan et al.
Mohan et al.
Backes et al.
Andriesse et al.
Zhang et al.
Wang et al.
Chul et al.
Cheng et al.
Chen et al.
Gawlik et al.
Jang et al.
Prakash et al.
Zhang et al.
Peng et al.
ACSAC
ACSAC
USENIX Sec
USENIX Sec
CCS
ACSAC
USENIX Sec
S&P
ACSAC
USENIX Sec
RAID
CCS
NDSS
RAID
ACSAC
USENIX Sec
NDSS
NDSS
USENIX Sec
CCS
S&P
USENIX Sec
USENIX Sec
NDSS