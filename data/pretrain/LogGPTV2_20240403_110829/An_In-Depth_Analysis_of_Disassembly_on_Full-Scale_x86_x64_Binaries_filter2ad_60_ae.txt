### 4.3 Automatic Bug Search
The requirements for binary analysis in automatic bug search systems vary depending on the type of bug being searched for and the granularity of the search. In practice, many such systems operate at the function level, both to simplify the analysis and because this granularity is suitable for detecting common bugs, such as stack-based vulnerabilities [14, 27, 50]. Operating at the function level also enhances interoperability with other binary analysis tools, such as symbolic execution, which are powerful for semantic analysis but do not scale well to entire binaries [14].

Similar to decompilation, many automatic bug search systems rely on accurate function boundary information and per-function Control Flow Graphs (CFGs). Despite the potential for significant inaccuracies in the input data, the output of these systems tends to degrade gracefully. Input inaccuracies may lead to some bugs being missed, but they typically do not compromise the correctness of the analysis for other parts of the code. Quantifying the accuracy of the inputs (disassembly, CFG, and function boundaries) helps users determine the expected completeness of the system's output.

### 5 Disassembly in the Literature
Given our disassembly results, we examined recent binary-based research to assess how well the capabilities of disassemblers match the expectations in the literature. Our study covers research published between 2013 and 2015 in top-tier systems security conferences, including S&P (Oakland), CCS, NDSS, and USENIX Security. We also included research from RAID and ACSAC, two other major conferences popular for such studies.

We identified 30 papers on binary-based research published in these venues, summarized in Table 6. The rest of this section presents aggregated findings to provide a degree of anonymization for these papers.

Table 4 shows the primitives and disassemblers used in these papers. IDA Pro is by far the most popular, across all primitives; our disassembly results (Section 3) justify this choice. Despite its high accuracy, linear disassembly is one of the least used, even for papers that handle only ELF binaries. This may be due to the widespread belief that inline data causes more problems than we found.

Instructions are the most frequently needed primitive, used by 25 out of 30 papers. The Control Flow Graph (CFG) follows closely, used in 24 papers, and function starts in 14 papers. Function signature information is required by only 3 of the analyzed papers. One paper used linear disassembly as a basis for building a CFG and callgraph, and for scanning function starts.

Table 5 provides a more detailed insight into the properties of the papers we analyzed, distinguishing between those targeting Windows PE binaries and those targeting Linux ELF binaries. This distinction is important because some complex cases, such as inline data, are more often generated by Visual Studio, making them more relevant in Windows papers.

Most papers that support obfuscated binaries target Windows (33% of papers versus 10% for Linux). This is because obfuscation is more common in malware, which is prevalent on Windows. Although we do not consider obfuscated binaries in our tests, it is still interesting to know how many papers target such binaries. Unfortunately, only 50% of papers that support obfuscation discuss potential errors, and 33% implement error handling. This is no better than the overall rate. Moreover, only 17% of these papers explicitly discuss complex cases, which is far below the overall rate for Windows.

Nearly all papers support optimized binaries (90% or more for both Linux and Windows, overall as well as top-tier). Stripped binaries are supported by a large majority of papers on Windows and by a slightly smaller majority on Linux. Curiously, the number of top-tier papers that support stripped binaries on Linux (70%) is significantly less than the overall number (79%).

The vast majority of papers use recursive disassembly (100% on Windows and 86% on Linux), with IDA Pro being the most popular disassembler. The few papers that use linear disassembly are based on objdump and augment it with a layer of error correction. Interestingly, these papers claim perfect (100% accurate) or near-perfect disassembly. As shown in Section 3.1.1, this precision on Linux binaries is primarily due to the core linear disassembly, making any error correction redundant except for a few corner cases in library code (and obfuscated code, which these papers do not consider).

A relatively small percentage of Windows papers use relocation information to find disassembly starting points. At 17%, this number is slightly higher for top-tier papers.

Discussion on disassembly errors and complex cases is somewhat lacking in the analyzed papers. For most primitives, the discussion is limited, and the implementation of error handling is insufficient. 

### Summary of Analyzed Papers
Table 6 summarizes the titles, authors, venues, years, and top-tier status of the 30 papers analyzed. This table provides a comprehensive overview of the research landscape in binary-based security analysis.

| Title | Authors | Venue | Year | Top-tier |
|-------|---------|-------|------|----------|
| A Principled Approach for ROP Defense | Qiao et al. | ACSAC | 2013 | No |
| Binary Code Continent: Finer-Grained Control Flow Integrity | Wang et al. | ACSAC | 2014 | No |
| Blanket Execution: Dynamic Similarity Testing for Program | Egele et al. | USENIX Sec | 2013 | Yes |
| BYTEWEIGHT: Learning to Recognize Functions in Binary Code | Bao et al. | USENIX Sec | 2014 | Yes |
| CoDisasm: Medium Scale Concatic Disassembly of Self-Modifying | Bonfante et al. | CCS | 2013 | Yes |
| Control Flow and Code Integrity for COTS binaries | Zhang et al. | ACSAC | 2013 | No |
| Control Flow Integrity for COTS Binaries | Zhang et al. | USENIX Sec | 2014 | Yes |
| Cross-Architecture Bug Search in Binary Executables | Pewny et al. | S&P | 2014 | Yes |
| DUET: Integration of Dynamic and Static Analyses for Malware | Hu et al. | ACSAC | 2013 | No |
| Dynamic Hooks: Hiding Control Flow Changes within | Vogl et al. | USENIX Sec | 2013 | Yes |
| Hardware-Assisted Fine-Grained Control-Flow Integrity | Davi et al. | RAID | 2013 | No |
| Heisenbyte: Thwarting Memory Disclosure Attacks using | Tang et al. | CCS | 2013 | Yes |
| High Accuracy Attack Provenance via Binary-based | Hyung Lee et al. | NDSS | 2014 | Yes |
| Improving Accuracy of Static Integer Overflow Detection in Binary | Zhang et al. | RAID | 2014 | No |
| Leveraging Semantic Signatures for Bug Search in Binary Programs | Pewny et al. | ACSAC | 2014 | No |
| Native x86 Decompilation Using Semantics-Preserving | Schwartz et al. | USENIX Sec | 2014 | Yes |
| No More Gotos: Decompilation Using Pattern-Independent | Yakdan et al. | NDSS | 2014 | Yes |
| Opaque Control-Flow Integrity | Mohan et al. | NDSS | 2014 | Yes |
| Oxymoron Making Fine-Grained Memory Randomization Practical | Backes et al. | USENIX Sec | 2014 | Yes |
| Practical Context-Sensitive CFI | Andriesse et al. | CCS | 2014 | Yes |
| Practical Control Flow Integrity & Randomization for | Zhang et al. | S&P | 2014 | Yes |
| Reassembleable Disassembling | Wang et al. | USENIX Sec | 2014 | Yes |
| Recognizing Functions in Binaries with Neural Networks | Chul et al. | USENIX Sec | 2014 | Yes |
| ROPecker: A Generic and Practical Approach for Defending | Cheng et al. | NDSS | 2014 | Yes |
| StackArmor: Comprehensive Protection from Stack-based | Chen et al. | NDSS | 2014 | Yes |
| Towards Automated Integrity Protection of C++ Virtual Function | Gawlik et al. | NDSS | 2014 | Yes |
| Towards Automatic Software Lineage Inference | Jang et al. | NDSS | 2014 | Yes |
| vfGuard: Strict Protection for Virtual Function Calls | Prakash et al. | NDSS | 2014 | Yes |
| VTint: Protecting Virtual Function Tablesâ€™ Integrity | Zhang et al. | NDSS | 2014 | Yes |
| X-Force: Force-Executing Binary Programs for Security | Peng et al. | NDSS | 2014 | Yes |

This structured and detailed approach provides a clearer and more professional presentation of the information.