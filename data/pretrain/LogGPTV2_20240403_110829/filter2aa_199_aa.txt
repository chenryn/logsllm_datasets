Monitoring Surveillance Vendors: A Deep 
Dive into In-the-Wild Android Full Chains in 
2021
Xingyu Jin
Christian Resell
Clement Lecigne
Richard Neal
#BHUSA  @BlackHatEvents 
#BHUSA   @BlackHatEvents 
Introduction
Xingyu 
@1ce0ear
Richard 
@ExploitDr0id
Christian 
@0xbadcafe1
#BHUSA   @BlackHatEvents 
Agenda
●
Examples of full-chains found in-the-wild by TAG
●
CVE-2021-0920 deep dive
●
Post exploitation
●
Exploit in Google Play
●
Defending Android
●
Conclusion
#BHUSA   @BlackHatEvents 
●
Goal: Protect Google and our users
●
Hunting for 0-days exploited in-the-wild
●
Tracking more than 30 surveillance vendors 
●
Exploits shared/sold between groups
●
Two Android full-chains found in 2021
○
From different surveillance vendors
Threat Analysis Group
#BHUSA   @BlackHatEvents 
●
Served to an up-to-date Android phone
●
Two 0-days were exploited:
○
CVE-2021-38003: Chrome renderer 0-day in JSON.stringify
○
CVE-2021-1048: epoll refcount bug
●
CVE-2021-1048 was fixed quickly in the upstream kernel
○
Not the first time we have seen this (e.g. CVE-2019-2215 aka Bad 
Binder)
Android Full-chain #1
#BHUSA   @BlackHatEvents 
Android Full-chain #1: Exploitation
void *libc_map = mmap(NULL, libc_size, PROT_READ, MAP_PRIVATE, libc_fd, 0);
int fd = socket(AF_LOCAL, SOCK_DGRAM, 0);
fput(fd);
usleep(500);
int mfd = memfd_create("foobar", 0);
void *rw_map = mmap(NULL, libc_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
close(fd);
close(mfd);
usleep(500);
int lfd = open(LIBC_PATH, O_RDONLY);
uint32_t foobar;
for (size_t i = 0; i  B is in the flight
A’s receiver queue
B is in gc_candidates
#BHUSA   @BlackHatEvents 
Linux Kernel Garbage Collection
●
Step2: Scanning inflight for gc_candidates: {A, B}
○
Since B is also a GC candidate, decrement B’s inflight count
#BHUSA   @BlackHatEvents 
Linux Kernel Garbage Collection
●
Step2: Scanning inflight for gc_candidates: {A, B}
○
Similarly, A’s inflight count is decremented to 0 too
#BHUSA   @BlackHatEvents 
●
Step 3: inflight(B) >0, B is not a garbage.
○
Recursively restore inflight process
Linux Kernel Garbage Collection
●
No one is considered as garbage
#BHUSA   @BlackHatEvents 
●
Let’s revisit the “unbreakable” cycle from garbage collector’s point of view:
○
gc_candidates: {A, B}
○
Scan inflight process
■
inflight(A) = 0, inflight(B) = 0 => All of them are garbage!
○
Purge garbage
Linux Kernel Garbage Collection
#BHUSA   @BlackHatEvents 
●
recvmsg without MSG_PEEK flag
○
Synchronize with GC (wait until GC finishes)
RECVMSG without MSG_PEEK
#BHUSA   @BlackHatEvents 
RECVMSG with MSG_PEEK
●
recvmsg with MSG_PEEK flag
○
File reference count is elevated
○
Not synchronized with GC
#BHUSA   @BlackHatEvents 
Vulnerability Scenario
●
Real world vulnerability scenario is quite … complex