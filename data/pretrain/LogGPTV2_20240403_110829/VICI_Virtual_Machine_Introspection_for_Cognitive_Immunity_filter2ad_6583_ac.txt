the overhead of Xen virtualization plus SecVisor on a
kernel build benchmark similar to the one described in
section 8 as being roughly 119%. Our equivalent mea-
surement for Xen plus VICI is only roughly 42%.
Grizzard [13] and Petroni and Hicks [21] have
explored hypervisor-based methods for countering at-
tempts to change the behavior of kernels by modifying
their control ﬂow. Grizzard modiﬁes the monitored ker-
nel’s code to cause it to ask the hypervisor to perform
a check whenever the kernel is about to jump or call to
an address stored in a function pointer. The hypervisor
checks to see whether or not the jump or call follows
a branch in the kernel’s proper control-ﬂow graph. If
a rootkit has modiﬁed the function pointer to cause a
jump not found in this graph, the hypervisor will detect
the diversion. Petroni and Hicks explored a technique
based on static analysis to achieve similar ends. We
have incorporated part of their technique into the VICI
Agent; it is described in section 9.
The above efforts use hypervisors to isolate their
monitors from the virtualized systems they monitor.
However, this virtualization reduces the systems’ per-
formance. Several projects have explored the possibil-
ity of using special hardware to provide isolation with-
out virtualization [31] by placing the monitor on a PCI
card [19] or on one CPU of a dual-CPU machine [15].
Although they avoid virtualization overhead, these solu-
tions cannot examine the registers of the CPU that runs
the monitored system. Their inability to monitor use-
ful rootkit targets such as CPU pointers to page tables
makes the monitors vulnerable to a “dummy kernel” at-
tack described in [27].
8. Performance
Table 1 compares the average time required to build
the Linux 2.6.24 kernel in its default conﬁguration un-
der three conditions. The “No Xen” results refer to
average
duration (s)
standard
deviation
penalty
vs. no Xen
penalty
vs. Xen
No Xen
Xen Xen + VICI
1782.17
2412.05
2537.35
4.64
3.34
3.89
35.34%
42.37%
5.19%
Table 1. Kernel compile durations compared.
builds on a Lenovo T60 laptop with an Intel T7200
Core Duo 2GHz CPU and 2GB RAM running Debian
GNU/Linux 4.0. The “Xen” results refer to building
the kernel in a Xen 3.1 virtual machine running De-
bian GNU/Linux with 128MB of virtual RAM hosted
on the same T60 laptop. The “Xen + VICI” results re-
fer to builds on the same virtual machine with the VICI
Agent running one scan every 50ms, no attacks, no re-
pairs. The averages are computed over ﬁve trials each.
The table addresses both the overhead associated
with virtualization and the additional overhead intro-
duced by the VICI Agent. The performance of the
VICI Agent’s diagnose–and–repair approach appears
to compare favorably with the performance of SecVi-
sor’s prevention-oriented alternative. Although our the
cost of virtualization makes the VICI Agent’s overhead
greater than that reported for hardware-based moni-
tors like Copilot, our hypervisor-based approach per-
mits us to examine CPU register state, thereby giving
us the potential to avoid the most severe shortcoming of
hardware-based schemes.
9. Limitations and future work
Although they have performed well in the labora-
tory, the diagnostics implemented in the present VICI
Agent prototype do not examine all of the aspects of
the virtual machine and kernel state that a rootkit might
modify to its own advantage. The VICI Agent misses
some aspects because the best diagnostic methods pub-
lished to date require more than 250 milliseconds to ex-
ecute (a time bound mandated by the project’s sponsor).
In other cases, efﬁcient diagnostic methods exist, but
we have not yet implemented them. In particular, we
have not yet implemented diagnostics to cover kernel
and process page tables in a way that would detect the
“dummy kernel” attack mentioned in section 7. Future
work could ignore the 250 millisecond bound and incor-
porate more diagnostic methods to increase coverage.
8494
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:01:14 UTC from IEEE Xplore.  Restrictions apply. 
In order to improve our diagnostic coverage of ker-
nel function pointers, we have used part of Petroni and
Hicks’ State-Based Control Flow Integrity static anal-
ysis technique [21] to produce a list of kernel function
pointers the VICI Agent’s diagnostics should examine.
This technique performs a static analysis of the Linux
kernel source and outputs both a list of the function
pointers that reside in the kernel’s data segments, but
also outputs C code that, when executed during a di-
agnostic, can ﬁnd additional function pointers dynami-
cally allocated in the kernel’s heap.
Unfortunately, using hardware similar to our own,
Petroni and Hicks reported that an average run of a pro-
totype diagnostic function based on their technique took
1.78 seconds to examine all of the function pointers in
the kernel’s data segments and heap—far more than the
VICI Agent’s 250 millisecond requirement will permit.
Consequently, we presently make use of only part of
their technique: the list of function pointers in the ker-
nel’s data segments, and do not examine the function
pointers in the heap.
Healthy kernels change the values of some of the
function pointers in this list during runtime. To prevent
our diagnostics from falsely reporting these changes as
rootkit tampering, we have attempted to identify the
changing function pointers by exercising the kernel and
removing them from the list. Our list of kernel function
pointers presently contains over 9000 entries.
In addition to its imperfect coverage,
the VICI
Agent is also hampered by the fact that it operates asyn-
chronously with the virtual machine’s kernel, and scans
periodically only once every so many milliseconds. It
is not hard to imagine a piece of malware that avoids
detection by exploiting one or both of these problems:
perhaps by making and immediately reversing a change
between scans, or by changing a function pointer out-
side of the VICI Agent’s present coverage. However,
the VICI Agent is not intended to be a general malware
detector. It is designed to detect and repair the effects
of kernel-modifying rootkits—a very speciﬁc kind of
malware whose purpose demands a set of peculiar at-
tributes.
Momentary kernel state modiﬁcations are not apt to
be of use to kernel-modifying rootkits, except perhaps
when combined with a small number of strategically-
placed long-term modiﬁcations. Adversaries intend
rootkits to hide their presence over days, weeks, or
months, and consequently rootkits must make at least
one persistent modiﬁcation to the kernel in order to gain
control whenever they need it. Furthermore, adversaries
depend on rootkits to hide their presence from all of the
system’s legitimate users. Peripheral, non-strategically-
placed changes are insufﬁcient for this task. In order to
hide the adversary’s ﬁles, processes, and other resources
from all other users at all times, we argue rootkits must
modify at least one of several strategic points along the
kernel’s system call control ﬂow path. Although the
VICI Agent’s diagnostic coverage is limited, we have
sought to cover all of these strategic points.
There are a number of additional diagnostic tech-
niques that could improve the effectiveness of the VICI
Agent prototype, particularly in the area of data struc-
tures whose values naturally change during runtime and
whose health consequently cannot be determined by a
simple comparison against a single known-good value.
Petroni and others’ notion of semantic integrity checks
may be applicable here, in particular their probabilistic
technique for ﬁnding processes that have been hidden
by strategic de-linking from kernel lists [20]. There is
also room for improvement in the present prototype’s
repair actions. The Checkpoint and Reboot repair ac-
tions, for example, cannot complete within the VICI
Agent’s 250 millisecond time bound.
Throughout its development, we have greatly im-
proved the VICI Agent capabilities by adapting and in-
corporating the techniques of others from a variety of
ﬁelds, and there appears to be considerable room for fu-
ture work in continuing to do so.
10. Conclusions
Systems that are under constant attack cannot wait
for manual intervention to remedy malware infections.
The VICI Agent uses a collection of novel repair ac-
tions to repair kernels modiﬁed by rootkits within mil-
liseconds of diagnosis.
The VICI Agent’s escalation and de-escalation be-
haviors enable it to reduce the negative impact of its
repairs on the system by saving its most expensive re-
pairs for extreme cases and relying on cheaper repairs
when they will do. In our experiments, the present VICI
Agent prototype’s simplest repair actions have proven
sufﬁcient to undo modiﬁcations of the kind made by the
well-known Adore-ng, Override, and SuKIT rootkits.
When conﬁgured to run its diagnostics once every
50 milliseconds, the VICI Agent reduces overall appli-
cation performance on the monitored system by slightly
more than 5% in comparison to an identical virtual-
ized system without the VICI Agent. This overhead is
less than half that of the only published measurements
for prevention-oriented alternatives. The VICI Agent
demonstrates the kind of rapid fully-automatic kernel
repair necessary to keep Internet-facing systems run-
ning and and free of kernel-modifying-rootkits despite
being under continuous attack.
The authors would like to thank Peter Ferrie,
8595
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:01:14 UTC from IEEE Xplore.  Restrictions apply. 
Michael Hicks, and Nick Petroni for their feedback
on earlier drafts of this paper. This work was sup-
ported by DARPA/AFRL contract number FA8750-07-
C-0008. The names of actual companies and products
mentioned herein may be the trademarks of their respec-
tive owners.
References
[1] J. A. Ambros-Ingerson and S. Steel.
Integrating plan-
ning, execution and monitoring. In Proc. of the Seventh
National Conference on Artiﬁcial Intelligence, 1988.
[2] K. Asrigo, L. Litty, and D. Lie. Using vmm-based sen-
sors to monitor honeypots. In 2nd International Confer-
ence on Virtual Execution Environments, 2006.
[3] A. Baliga, P. Kamat, and L. Iftode. Lurking in the Shad-
ows: Identifying Systemic Threats to Kernel Data (Short
Paper). In Proc. of the 2007 IEEE Symposium on Secu-
rity and Privacy, 2007.
[4] R. A. Brooks. A robust layered control system for a mo-
bile robot. IEEE Journal of Robotics and Automation,
(2), 1986.
[5] R. A. Brooks. Engineering approach to building com-
plete, intelligent beings. Proc. of the SPIE—the Interna-
tional Society for Optical Engineering, (1002), 1989.
[6] R. A. Brooks. Intelligence without representation. Arti-
ﬁcial Intelligence, 47(1–3), 1991.
[7] D. Brumley. invisible intruders: rootkits in practice. ;lo-
gin: The Magazine of USENIX and SAGE, Sept. 1999.
[8] J. Dean and S. Ghemawat. MapReduce: Simpliﬁed Data
In 6th USENIX Sympo-
Processing in Large Clusters.
sium on Operating System Design and Implementation,
2004.
[9] A. K. Dewdney.
In the game called Core War hostile
programs engage in a battle of bits, Computer Recre-
ations. Scientiﬁc American, May 1984.
[10] B. Dragovic, K. Fraser, S. Hand, T. Harris, A. Ho,
I. Pratt, A. Warﬁeld, P. Barham, and R. Neugebauer. Xen
and the Art of Virtualization. In Proc. of the ACM Sym-
posium on Operating Systems Principles, 2003.
[11] T. Garﬁnkel and M. Rosenblum. A Virtual Machine In-
trospection Based Architecture for Intrusion Detection.
In Proc. of the 10th Annual Network and Distributed
System Security Symposium, 2003.
[12] M. P. Georgeff and A. L. Lansky. Reactive Reasoning
and Planning. In Proceedings of the Sixth National Con-
ference on Artiﬁcial Intelligence, 1987.
[13] J. B. Grizzard.
Towards self-healing systems:
re-
establishing trust in compromised systems. PhD thesis,
Atlanta, GA, USA, 2006. Adviser-Henry L. Owen, III.
[14] G. Hoglund and J. Butler. Rootkits: Subverting the Win-
dows Kernel. Addison-Wesley Professional, 2005.
[15] D. Hollingworth and T. Redmond. Enhancing operating
system resistance to information warfare. In MILCOM
2000. 21st Century Military Communications Confer-
ence Proceedings, volume 2, 2000.
[16] X. Jiang, X. Wang, and D. Xu. Stealthy malware de-
8696
tection through vmm-based ”out-of-the-box” semantic
view reconstruction. In Proc. of the 14th ACM confer-
ence on Computer and communications security, 2007.
[17] S. T. Jones, A. C. Arpaci-Dusseau, and R. H. Arpaci-
Dusseau. Vmm-based hidden process detection and
identiﬁcation using lycosid. In Proc. of the fourth ACM
SIGPLAN/SIGOPS international conference on Virtual
execution environments, 2008.
[18] L. Litty and D. Lie. Manitou: a layer-below approach
In Proc. of the 1st workshop on
to ﬁghting malware.
Architectural and system support for improving software
dependability, 2006.
[19] N. L. Petroni, T. Fraser, J. Molina, and W. A. Arbaugh.
Copilot - a coprocessor-based kernel runtime integrity
monitor. In 13th USENIX Security Symposium, 2004.
[20] N. L. Petroni, T. Fraser, A. Walters, and W. A. Arbaugh.
An architecture for speciﬁcation-based detection of se-
mantic integrity violations in kernel dynamic data.
In
Proc. of the 15th USENIX Security Symposium, 2006.
[21] N. L. Petroni and M. Hicks. Automated detection of per-
sistent kernel control-ﬂow attacks. In 14th ACM confer-
ence on Computer and communications security, 2007.
[22] N. A. Quynh and Y. Takefuji. Towards a tamper-resistant
kernel rootkit detector. In Proc. of the 2007 ACM sym-
posium on Applied computing, 2007.
[23] S. regenerative Systems (SRS) Program Phase II. Cog-
In BAA 06-35 Pro-
nitive immunity and self-healing.
poser Information Pamphlet. Defense Advanced Re-
search Projects Agency, 2006.
[24] R. Rivest. The MD5 Message-Digest Algorithm. Tech-
nical Report Request For Comments 1321, Network
Working Group, April 1992.
[25] S. J. Russell and P. Norvig. Artiﬁcial Intelligence A
Modern Approach. Prentice Hall, 2nd edition, 2002.
[26] A. Seshadri, M. Luk, N. Qu, and A. Perrig. Secvisor: a
tiny hypervisor to provide lifetime kernel code integrity
for commodity oses. In 21st ACM symposium on Oper-
ating systems principles, 2007.
[27] A. Seshadri, M. Luk, E. Shi, A. Perrig, L. van Doorn,
and P. Khosla. Pioneer: verifying code integrity and en-
forcing untampered code execution on legacy systems.
In 20th ACM symposium on Operating systems princi-
ples, 2005.
[28] I. Stoica, R. Morris, D. Karger, M. F. Kaashoek, and
H. Balakrishnan. Chord: A scalable peer-to-peer lookup
service for internet applications. SIGCOMM Comput.
Commun. Rev., 31(4), 2001.
[29] Y.-M. Wang, D. Beck, B. Vo, R. Roussev, and C. Ver-
bowski. Detecting stealth software with Strider Ghost-
Buster. In Proc. of the International Conference on De-
pendable Systems and Networks, 2005.
[30] M. Xu, X. Jiang, R. Sandhu, and X. Zhang. Towards
a vmm-based usage control framework for os kernel in-
tegrity protection. In Proc. of the 12th ACM symposium
on Access control models and technologies, 2007.
[31] X. Zhang, L. van Doorn, T. Jaeger, R. Perez, and
R. Sailer. Secure Coprocessor-based Intrusion Detec-
tion. In 10th ACM SIGOPS European Workshop, 2002.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:01:14 UTC from IEEE Xplore.  Restrictions apply.