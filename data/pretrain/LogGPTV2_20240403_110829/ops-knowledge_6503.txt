User:  How to use thread pool to achieve parallel computing in C++?
Assistant: thread pool can be used to split a task into multiple threads to achieve parallel computing. Here is a simple example: ```c++ #include <iostream> #include <vector> #include <thread> #include <queue> #include <mutex> #include <condition_variable> #include <functional> class ThreadPool { public : explicit ThreadPool(size_t threadCount) : stop(false) { for (size_t i = 0; i < threadCount; ++i) workers. emplace_back( [this]() { for (;;) { std::function<void ()> task; { std::unique_lock<std::mutex> lock(this->queue_mutex); this->condition.wait(lock, [this] { return this->stop || !this->tasks. empty(); }); if (this->stop && this->tasks.empty()) return; task = std::move(this->tasks.front()); this->tasks.pop() ; } task(); } } ); } template <typename F, typename... Args> auto addTask(F&& f, Args&&... args) -> std::future<typename std::result_of<F(Args ...)>::type> { using return_type = typename std::result_of<F(Args...)>::type; auto task = std::make_shared<std::packaged_task<return_type()>>( std::bind(std::forward<F>(f), std::forward<Args>(args)...)); std::future<return_type> result = task->get_future(); { std ::unique_lock<std::mutex> lock(queue_mutex); if (stop) throw std::runtime_error("addTask on stopped ThreadPool"); tasks.emplace([task]() { (*task)(); } ); } condition.notify_one(); return result; } ~ThreadPool() { { std::unique_lock<std::mutex> lock(queue_mutex); stop = true; } condition.notify_all(); for (std:: thread& worker : workers) worker.join(); } private: std::vector<std::thread> workers; std::queue<std::function<void()>> tasks; std::mutex queue_mutex; std ::condition_variable condition; bool stop; }; int main() { ThreadPool pool(4); std::vector<std::future<int>> results; for (int i = 0; i < 8; ++i ) { results.emplace_back( pool.addTask([i] { std::cout << "working on task " << i << std::endl; std::this_thread::sleep_for(std::chrono::seconds (1)); return i * i; }) ); } for (auto&& result : results) std::cout << result.get() << ' '; std::cout << std::endl; return 0; } ``` In this example, we create a ThreadPool class to manage the thread pool, use std::function and std::packaged_task to package tasks, and use std::future to obtain task results. In the main function, we create a ThreadPool instance and add 8 tasks, each task is to calculate the square of i, and then wait for the task to complete and output the result. Since the ThreadPool waits for all tasks to complete when it is destructed, we don't need to explicitly wait for the tasks to complete. In addition, ThreadPool also provides an addTask member function, which can add new tasks to the thread pool at runtime. We can use this function to dynamically assign tasks during program execution.