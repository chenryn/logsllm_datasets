(cid:48)
1, cT ag = cT ag
(cid:48)
C7 = C
We let s(cid:48)
E0 = E
1, s(cid:48)
1 and s2 = s(cid:48)
2, t denote the randomization parameters of
the normal challenge ciphertext. This implicitly sets s1 =
−c2 + s(cid:48)
2 + c1 + c2. Therefore, if T equals to
νc1+c2 , B has properly simulated GameReal. Otherwise, if T
is a random value, it has simulated Game0,0, also properly
by letting νc1+c2 gκ denote T .
2
To achieve semi-functional key invariance, we designed a
nested duals system encryption. In our proof of lemma 2, the
independence of tags in the challenge key and the challenge
ciphertext is proved by n-wise independence [6]. In detail,
tags for Ax, kT agj,x ∀j ∈ [n] and a tag for the challenge
ciphertext, cT ag are generated as
−ρ(x)
−(ρ(x))2
1
1
...
−(ρ(x))n
. . .
···
0
1
2
h(cid:48)
h(cid:48)
h(cid:48)
...
h(cid:48)
 =
kT ag1,x
kT ag2,x
...
where cj is coeﬃcients of yj of (cid:81)
1
cn
c0
c1
c2
ρ(x)∈S∗ (y − ρ(x)) and S∗
is the target set of attributes for the challenge ciphertext.
kT agn,x
cT ag
n
To claim n-wise independence of tags, we show that they
satisfy two conditions following
1. h(cid:48)
0, ...h(cid:48)
versary.
n are information theoretically hidden to the ad-
2. ρ(x) is not in S∗.
In lemma 2, we must show that they appear only once
to suﬃce key elements for Ax for the ﬁrst condition. To do
this, we isolates kT agj,x ∀j ∈ [n] for Ax from the other tags
by utilizing a hybrid model. In the security proof, we show
the invariance of two games which have diﬀerent types of
key elements corresponding to Ax, not all key elements in
the kth key. Also, we do not apply semi-functionality for
the elements if a corresponding attribute of Ax is shared
between keys and the challenge ciphertext. Therefore, we
leave those key elements as normal type (i.e. without any
(cid:80)
change of type from the real game). This is because the
correlation can be detected to the adversary by checking
i∈[0,n] cikT agi,ρ(x) = cT ag if ρ(x) is in S∗ as the second
condition requires.
Lemma 2. (Semi-functional key invariance) Suppose
there exists a PPT algorithm A to distinguish between Gamek,θ−1
and Gamek,θ with a non-negligible advantage . Then we
can build an algorithm B breaking DLIN with the advan-
tage, , using A.
Proof: First, B takes (g, f, ν, gc1 , f c2 , T ) as an instance
from DLIN . It will simulate either Gamek,θ−1 or Gamek,θ
based on the value of T .
Setup: The algorithm selects α, a1, a2, yv1 , yv2 , yw, h(cid:48)
˜h0, ..., ˜hn from Zp, and sets
g = g, gb = f, v = ν
−a1·a2 , v1 = νa2 · gyv1 , v2 = νa1 · gyv2 ,
0, ..., h(cid:48)
n,
w = f gyw , h0 = f
−h(cid:48)
0 g
˜h0 , ..., hn = f
−h(cid:48)
n g
˜hn
We do not know hi, but we can calculate hi using g, f, h(cid:48)
i,
and ˜hi. It publishes the public parameter following
g, gb, gb·a1 = f a1 , gb·a2 = f a2 , gh0 , ..., ghn , w,
τ1 = gyv1 a1 , τ2 = gyv2 a2 , τ b
1 = f yv1 a1 , τ b
2 = f yv2 a2 ,
e(g, g)α·a1b = e(f, g)α·a1 .
B generates MSK= {gα, gα·a1 , v, v1, v2}. This is possible
because it knows a1 and α. We stress that B does not require
any information of the target set of attributes, S∗ for the
challenge ciphertext when it sets all parameters in Setup.
829Table 2: Summary of Security Games
Key Generation Algorithm
Encryption Algorithm
GameReal
Game0,0
Gameδ,0
Gameδ,θ
KeyGen
KeyGen
SFKeyGen ( δ)
Gameq,Θq
GameF inal
SFKeyGen
SFKeyGen
Enc
SFEnc
SFEnc
SFEnc
SFEnc
( δ): For all keys except the ﬁrst δ keys
SFEnc with a random message
2,xi · ga2γxi ,
(cid:48)
(cid:48)
5,xi ,
∀xi s.t. i  k), B runs the key
generation algorithm to generate normal keys. It is possible
since B knows all public parameters and MSK.
We let xi denote the index of the ith Ax of A such that
ρ(x) /∈ S∗. To generate the kth key with the index θ, for
A = (A, ρ), it ﬁrst generates {kT agj,x;∀j ∈ [n]} randomly
from Zp for each x s.t. x (cid:54)= xθ. For xθ, it sets
kT agj,xθ = h
(cid:48)
j + h
0ρ(xθ)j ∀j ∈ [n].
(cid:48)
Then, using {kT agj,x;∀j ∈ [n], ∀x ∈ [m]}, it generates a
normal key
(cid:48)
1,x, ..., D
7,x,{K
(cid:48)
j,x, kT agj,x;∀j ∈ [n]} ∀x ∈ [m].
(cid:48)
D
Finally, it selects γxi from Zp for each xi such that i  θ,
1,xθ , r(cid:48)
1,xθ , z(cid:48)
We let z(cid:48)
D1,xi = D
{Kj,xi = K
2,xθ , r(cid:48)
1,xθ − yv1 c2 and z2,xθ = z(cid:48)
2,xθ + c2 and r1,xθ = r(cid:48)
(cid:48)
(cid:48)
1,xi , ..., D7,xi = D
7,xi ,
j,xi , kT agj,xi ;∀j ∈ [n]}
(cid:48)
2,xθ , µ(cid:48) denote randomized pa-
rameters for Axθ in the normal key. This implicitly sets
2,xθ − yv2 c2. Also, it sets
z1,xθ = z(cid:48)
r2,xθ = r(cid:48)
If T equals to
1,xθ + c1.
νc1+c2 , this has properly simulated the semi-functional key
generated by SFKeyGen(cid:48)(MSK, PK, S∗, A, θ−1). Otherwise,
If T is a random value, and we denote it as νc1+c2 gγxθ , this
is properly simulated the semi-functional key generated by
SFKeyGen(cid:48)(MSK, PK, S∗, A, θ).
Challenge: When A requests the challenge ciphertext for
S∗ with two message, M0 and M1 B randomly selects β
from {0, 1}. Then, it sets cT ag = c0h(cid:48)
n. With
Mβ and cT ag, it generates a normal challenge ciphertext,
7, E0, EAtti ;∀Atti ∈ S∗). Then, it randomly
(C(cid:48), C(cid:48)
generates κ from Zp and sets
(cid:48)
1, C2 = C
0 + ... + cnh(cid:48)
4 · f a2κ,
(cid:48)
1, ..., C(cid:48)
, C1 = C
C = C
(cid:48)
(cid:48)
(cid:48)
3, C4 = C
2, C3 = C
5 · ga2κ, C6 = C
6 · va2κ
(cid:48)
(cid:48)
,
2
C5 = C
830C7 = C
E1 = E
7 · f yv2·κ·a2 ν