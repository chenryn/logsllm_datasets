no assumption about time at all, the coverage of the timing 
assumption appears much  bigger,  i.e., it  has the  potential 
to be justified  in a wider range of real-world environments. 
For our applications, which focus on the security of trusted 
services, the resulting lack of timeliness  seems tolerable. 
A  variation  of  the  asynchronous  model  is  to  assume 
probabilistic  behavior of  the  communication links [5, 251, 
where the probability  that a link is broken permanently  de- 
creases over time.  But since this involves a timing assump- 
tion, it is essentially a probabilistic synchronous model (per- 
haps  it  should  also  bear  that  name)  and  suffers  from  all 
the  problems  mentioned  before.  The model  investigated 
by  Moser and Melliar-Smith [25] assumes, additionally,  a 
fairness property  and a partial order imposed by the under- 
lying  communication  system,  but  such assumptions seem 
also difficult to justify on the Internet. 
A promising alternative to time-free models is to rely on 
a minimal,  trusted  time  service  provided  by  a  specialized 
subsystem, as proposed by  Verissimo,  Casimiro, and Fet- 
zer [35]. But apart from the open question of how to imple- 
ment such a “timely  computing base”  on the Internet, this 
approach is  so recent  that  its  implications for  secure state 
machine replication  in a Byzantine environment are not yet 
fully understood. 
Static Server Set.  Distributing  a  trusted  service  among 
a static set of  servers leverages the trust  in the availability 
and integrity of each individual  server to the whole system. 
This set is to remain fixed during the whole  lifetime of the 
system, despite observable corruptions.  The reason  is that 
all existing threshold-cryptographic protocols are based  on 
fixed parameters (e.g.,  n and t )  that  must  be known  when 
the key shares are generated. 
A corrupted server cannot be resurrected  easily because 
the intruder may have seen all its cryptographic secrets. Un- 
less specialized “proactive” protocols [9] are used to refresh 
all key shares periodically, the only way to clean up a server 
is to redistribute fresh keys.  However, dynamic groups and 
185 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:07:54 UTC from IEEE Xplore.  Restrictions apply. 
proactively secure cryptosystems in asynchronous networks 
are an open area of research (see Section 6). 
The  alternative  is  to  remove  apparently  faulty  servers 
from the system.  This is the paradigm  of view-based group 
communication systems in the crash-failure model (see the 
survey  in  [28]).  They  offer  resilience  against  crash  fail- 
ures by eliminating non-responding servers from the current 
view and proceeding without them to the next view.  Resur- 
rected servers may join again in later views. 
The Rampart  toolkit  [30] is  the  only  group communi- 
cation  system that  uses  views  and  tolerates  arbitrary  fail- 
ures.  But  since  it  builds  on  a  membership  protocol  to 
agree dynamically on the group’s composition, it easily falls 
prey  to an attacker  that  is able to delay  honest  servers just 
long enough until corrupted servers hold the majority in the 
group.  Because the  maintenance of  security  and integrity 
is the primary  application  of our protocols for trusted  ser- 
vices, we cannot tolerate such attacks and use a static group 
instead (but again, see Section 6). 
Related  Work.  The  use  of  cryptographic  methods  for 
maintaining consistent  state  in  a  distributed  system  has  a 
long history and originates with the seminal work of Pease, 
Shostak, and Lamport [26]. 
The pioneering work of Reiter and Birman [31] (abbre- 
viated  RB94  henceforth)  introduces  secure  state  machine 
replication  in  a  Byzantine  environment  and  a  broadcast 
protocol  based  on  threshold  cryptography  that  maintains 
causality  among the  requests.  Similar to  our architecture, 
it uses a static set of servers, who share the keys of a thresh- 
old signature scheme and a threshold  cryptosystem.  Thus, 
clients need only know the single public keys of the service, 
but not those of individual servers. 
In  order  to  obtain  a  fully  robust  system  for  an  asyn- 
chronous model with malicious faults, however, RB94 must 
be complemented with  robust  threshold  cryptography and 
secure atomic broadcast  protocols,  which  were not known 
at that time.  Our work builds on this and attempts to close 
this gap. 
Subsequent work  by  Reiter on Ranipart  [30] shares our 
focus  on  distributing  trusted  services,  but  assumes  a  dif- 
ferent model  as explained  in  the  previous sections:  it  im- 
plements atomic broadcast  on  top  of  a group membership 
protocol that dynamically removes apparently faulty servers 
from the set. 
The  broadcast  protocols  of  Malkhi,  Merritt,  and  Ro- 
deh [22] work again  with  a static group in  a model similar 
to  ours,  but  implement only  reliable  broadcast and do not 
guarantee a  total  order, as needed  for maintaining consis- 
tent state. 
Castro and Liskov [ 1 11 (called CL99 below) present  an 
interesting practical  algorithm  for distributed service repli- 
cation  that  is  very  fast  if  no failures  occur.  It  requires no 
explicit timeout values, but assumes that message transmis- 
sion  delays  do not  grow  faster  than  some  predetermined 
function for an indefinite duration. Since the CL99 protocol 
is deterministic, it can be blocked by a Byzantine adversary 
(i.e.,  violating  liveness),  but  it  will  maintain safety  under 
all  circumstances.  In contrast,  our approach satisfies  both 
conditions because it is based on probabilistic agreement. 
The Fleet  architecture  of  Malkhi  and  Reiter  [24]  sup- 
ports  loose coordination  in  large-scale  distributed  systems 
and  shares  some  properties  of  our  model. 
It  works  in 
a  Byzantine  environment  and  uses  quorum  systems  and 
threshold  cryptography  for  implementing  a  randomized 
agreement protocol  (in  the  form  of  “consensus objects”). 
However,  the  servers  do  not  directly  communicate  with 
each other for maintaining distributed state and merely help 
clients carrying out fault-tolerant  protocols.  Close coordi- 
nation of all servers is also not a primary  goal of Fleet.  Im- 
plementing distributed  state machine replication  on  top  of 
Fleet is possible, in principle, but needs additional steps. 
The  Total  family  of  algorithms  for  total  ordering  by 
Moser and Melliar-Smith  [25] implements atomic broadcast 
in  a  Byzantine environment, but  only  assuming a  benign 
network scheduler with some specific probabilistic  fairness 
guarantees.  Although  this may  be realistic  in  highly  con- 
nected environments with separate physical connections be- 
tween  all machines,  it  seems not  appropriate  for arbitrary 
Internet settings. 
SecureRing  [20]  and  the  very  recent  work  of  Doudou, 
Garbinato, and Guerraoui [ 141 (abbreviated as DGGOO) are 
two  examples  of  atomic  broadcast protocols  that  rely  on 
failure  detectors  in  the  Byzantine  model.  They  encapsu- 
late all time-dependent aspects and obvious misbehavior of 
a party  in  the  abstract notion  of a failure detector and per- 
mit clean, deterministic protocols (see also [ I]).  However, 
most implementations of failure detectors will use timeouts 
and  actually  suffer from some of  the  problems mentioned 
above. It also seems that Byzantine failure detectors are not 
yet well enough understood to allow for precise definitions. 
A comparison of systems for secure state machine repli- 
cation is shown in Figure  I .  The cryptographic model with 
randomized  Byzantine  agreement  seems  both  practically 
and theoretically attractive, although it appears to have been 
somewhat overlooked in  the  past.  (The fact  that  random- 
ized  agreement protocols  have  non-terminating runs  does 
not matter because their probability  is negligible; moreover, 
if  a  protocol  involves any cryptography, and  the  practical 
protocols  mentioned above do so, a negligible  probability 
of  failure  remains  anyway.)  Remarkably,  during the  two 
decades since the question of maintaining “interactive con- 
sistency” was first formulated [26], no secure system in our 
asynchronous model has been designed until now. 
186 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 04:07:54 UTC from IEEE Xplore.  Restrictions apply. 
Reference 
RB94 [31] 
Rampart [30] 
Total alg. [25] 
CL99 [ 1 I] 
Fleet [24] 
SecureRing [20] 
DGGOO [ 141 
this paper 
prob. async. 
Timing 
async. 
async. 
async. 
async. 
async. 
async. 
asvnc. 
Servers 
static 
dynamic 
static 
static 
static 
static 
static 
static 
BA? 
yes(’) 
no 
no 
no 
Remark 
crash-failures  only 
FD for liveness and safety 
needs causal order on links 
FD for liveness 
yes(2)  no state machine replication 
yes(3)  “Byzantine” FD 
“Byzantine” FD 
yes(3) 
yes(*) 
general adversaries (Q3) 
Figure 1. Systems for secure state machine replication (Fleet supports only loose coordination).  All systems 
achieve optimal resilience t  3t. 
Byzantine agreement  requires  all  parties  to  agree on  a 
binary  value  that  was  proposed  by  an  honest  party.  The 
protocol  of Cachin et al.  [8] follows the  basic  structure of 
all  randomized  solutions  (e.g.,  [3]) and  terminates  within 
an  expected constant  number  of  asynchronous rounds.  It 
achieves the  optimal resilience  n  > 3t  by  using  a robust 
threshold coin-tossing protocol, whose security is based  on 
the so-called Diffie-Hellman  problem.  It requires a trusted 
dealer for setup, but can process an arbitrary number of in- 
dependent agreements afterwards. 
Another primitive is multi-valued Byzantine  agreement, 
which  provides agreement on  values  from larger domains. 
Multi-valued agreement requires a non-trivial  extension of 
binary agreement. The difficulty in multi-valued  Byzantine 
agreement is  how  to  ensure the  “validity”  of  the  resulting 
value, which may come from a domain that has no a priori 
fixed size. Our approach to this is a new, “external” validity 
condition, using a global predicate with which every honest 
party  can determine the  validity  of  a proposed value.  The 
protocol  guarantees that  the system may  only  decide for a 
value acceptable to honest parties.  This rules out agreement 
protocols that decide on a value that no party proposed. Our 
implementation of multi-valued Byzantine agreement uses 
only a constant expected number of rounds. 
A  basic  broadcast protocol  in  a distributed  system  with 
failures  is  reliable broadcast,  which  provides a  way  for a 
party  to  send  a  message  to  all  other  parties. 
Its  specifi- 
cation  requires  that  all  honest parties  deliver  the  same set 
of messages and that this set includes all  messages broad- 
cast by  honest  parties.  However, it makes no assumptions 
if  the sender of a message is corrupted and  does not guar- 
antee anything about the order in  which  messages are de- 
livered.  The reliable  broadcast protocol  of our architecture 
is  an  optimized variant  of  the  elegant  protocol  by  Bracha 
and Toueg [5].  We also use a variation  of it, called  cnnsis- 
tent broadcast, which  is advantageous in certain  situations. 
It guarantees uniqueness of the delivered message (thus the 
name consistent broadcast), but relaxes the requirement that 
all honest parties actually deliver the message-a  party may 
still learn about the existence of the message by other means 
and ask for it.  A similar protocol  was used by Reiter [29]. 
An  atomic broadcast guarantees a  total  order  on  mes- 
sages  such  that  honest  parties  deliver  all  messages in  the 