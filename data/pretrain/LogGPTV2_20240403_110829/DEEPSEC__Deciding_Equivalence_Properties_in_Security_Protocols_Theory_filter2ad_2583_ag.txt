[10] M. Arapinis, L. Mancini, E. Ritter, M. Ryan, N. Golde, K. Redon,
and R. Borgaonkar. New privacy issues in mobile telephony: ﬁx and
veriﬁcation. In 19th Conference on Computer and Communications
Security (CCS’12), pages 205–216. ACM Press, 2012.
[11] A. Armando, D. A. Basin, Y. Boichut, Y. Chevalier, L. Compagna,
J. Cu´ellar, P. H. Drielsma, P.-C. H´eam, O. Kouchnarenko, J. Manto-
vani, S. M¨odersheim, D. von Oheimb, M. Rusinowitch, J. Santiago,
M. Turuani, L. Vigan`o, and L. Vigneron. The AVISPA tool for
the automated validation of internet security protocols and applica-
tions. In 17th International Conference on Computer Aided Veriﬁca-
tion (CAV’05), Lecture Notes in Computer Science, pages 281–285.
Springer, 2005.
[12] D. Baelde, S. Delaune, and L. Hirschi. Partial order reduction for
security protocols. In 26th International Conference on Concurrency
Theory (CONCUR’15), volume 42 of Leibniz International Proceed-
ings in Informatics, pages 497–510. Leibniz-Zentrum f¨ur Informatik,
Sept. 2015.
[13] D. A. Basin, J. Dreier, and R. Sasse. Automated symbolic proofs
of observational equivalence. In 22nd Conference on Computer and
Communications Security (CCS’15), pages 1144–1155. ACM Press,
2015.
[14] M. Baudet. Deciding security of protocols against off-line guessing
In 12th Conference on Computer and Communications
attacks.
Security (CCS’05), pages 16–25. ACM Press, 2005.
[15] B. Blanchet, M. Abadi, and C. Fournet. Automated Veriﬁcation of
Selected Equivalences for Security Protocols. In Symposium on Logic
in Computer Science (LICS’05), pages 331–340. IEEE Comp. Soc.
Press, June 2005.
[16] B. Blanchet and B. Smyth. Automated reasoning for equivalences
in the applied pi calculus with barriers. In 29th Computer Security
Foundations Symposium (CSF’16), pages 310–324. IEEE Comp. Soc.
Press, 2016.
[17] B. Blanchet, B. Smyth, and V. Cheval. Automatic Cryptographic
Protocol Veriﬁer, User Manual and Tutorial, 2016.
[18] M. Boreale and L. Trevisan. A complexity analysis of bisimilarity
for value-passing processes. Theor. Comput. Sci., 238(1-2):313–345,
2000.
[19] R. Chadha, V. Cheval, S¸. Ciobˆac˘a, and S. Kremer. Automated
veriﬁcation of equivalence properties of cryptographic protocol. ACM
Transactions on Computational Logic, 23(4):1–32, 2016.
[20] V. Cheval. Apte: an algorithm for proving trace equivalence. In 20th
International Conference on Tools and Algorithms for the Construc-
tion and Analysis of Systems (TACAS’14), volume 8413 of Lecture
Notes in Computer Science, pages 587–592. Springer, 2014.
[21] V. Cheval and B. Blanchet. Proving more observational equivalences
with ProVerif.
In Proc. 2nd Conference on Principles of Security
and Trust (POST’13), volume 7796 of Lecture Notes in Computer
Science, pages 226–246. Springer, 2013.
[22] V. Cheval, H. Comon-Lundh, and S. Delaune. Trace equivalence
decision: Negative tests and non-determinism. In 18th Conference on
Computer and Communications Security (CCS’11), pages 321–330.
ACM Press, 2011.
[23] V. Cheval, V. Cortier, and S. Delaune. Deciding equivalence-based
properties using constraint solving. Theoretical Computer Science,
492:1–39, Apr. 2013.
[24] Y. Chevalier and M. Rusinowitch. Decidability of equivalence of
symbolic derivations. Journal of Automated Reasoning, 48(2):263–
292, 2010.
[25] R. Chr´etien, V. Cortier, and S. Delaune. Decidability of trace
In Proceedings of the 28th
equivalence for protocols with nonces.
IEEE Computer Security Foundations Symposium (CSF’15), pages
170–184. IEEE Computer Society Press, 2015.
[26] R. Chr´etien, V. Cortier, and S. Delaune. From security protocols
to pushdown automata. ACM Transactions on Computational Logic,
17(3):1–45, November 2015.
[27] S¸. Ciobˆac˘a, S. Delaune, and S. Kremer. Computing knowledge in
security protocols under convergent equational theories. Journal of
Automated Reasoning, 48(2):219–262, 2012.
[28] H. Comon-Lundh and S. Delaune. The ﬁnite variant property: How to
get rid of some algebraic properties. In 16th International Conference
on Rewriting Techniques and Applications (RTA’05), volume 3467 of
Lecture Notes in Computer Science, pages 294–307. Springer, 2005.
[29] B. Conchinha, D. A. Basin, and C. Caleiro. Efﬁcient decision
procedures for message deducibility and static equivalence. In Proc.
7th International Workshop on Formal Aspects of Security and Trust
(FAST’10), volume 6561 of Lecture Notes in Computer Science, pages
34–49. Springer, 2010.
[30] V. Cortier, S. Delaune, and A. Dallon. Sat-equiv: an efﬁcient tool for
equivalence properties. In Proceedings of the 30th IEEE Computer
Security Foundations Symposium (CSF’17), pages 481–494. IEEE
Computer Society Press, 2017.
[31] V. Cortier, N. Grimm, J. Lallemand, and M. Maffei. A type system
for privacy properties. In 24th ACM Conference on Computer and
Communications Security (CCS’17), Dallas, USA, October 2017.
ACM. To appear.
[32] V. Cortier and B. Smyth. Attacking and ﬁxing helios: An analysis of
ballot secrecy. Journal of Computer Security, 21(1):89–148, 2013.
[33] C. J. F. Cremers. The scyther tool: Veriﬁcation, falsiﬁcation, and
analysis of security protocols. In Proc. 20th International Conference
on Computer Aided Veriﬁcation (CAV’08), volume 5123 of Lecture
Notes in Computer Science, pages 414–418. Springer, 2008.
[34] S. Delaune, S. Kremer, and M. D. Ryan. Verifying privacy-type prop-
erties of electronic voting protocols. Journal of Computer Security,
17(4):435–487, July 2009.
[35] D. Dolev and A. Yao. On the security of public key protocols. In Proc.
of the 22nd Symp. on Foundations of Computer Science (FOCS’81),
pages 350–357. IEEE Comp. Soc. Press, 1981.
542
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:38:36 UTC from IEEE Xplore.  Restrictions apply. 
[36] N. A. Durgin, P. Lincoln, and J. C. Mitchell. Multiset rewriting and
the complexity of bounded security protocols. Journal of Computer
Security, 12(2):247–311, 2004.
[37] P. T. Force. PKI for machine readable travel documents offering
ICC read-only access. Technical report, International Civil Aviation
Organization, 2004.
[38] L. Hirschi, D. Baelde, and S. Delaune. A method for verifying
privacy-type properties: the unbounded case. In 37th IEEE Sympo-
sium on Security and Privacy (S&P’16), pages 564–581, San Jose,
California, USA, 2016. IEEE Comp. Soc. Press.
[39] R. Milner, J. Parrow, and D. Walker. A calculus of mobile processes,
I. Inf. Comput., 100(1):1–40, 1992.
[40] C. Papadimitriou. Computational complexity. John Wiley and Sons
Ltd., 2003.
[41] P. Rønne. Personal communication, 2016.
[42] M. Rusinowitch and M. Turuani. Protocol insecurity with a ﬁnite
number of sessions, composed keys is np-complete. Theor. Comput.
Sci., 299(1-3):451–475, 2003.
[43] P. Y. A. Ryan and S. A. Schneider. Prˆet-`a-voter with re-encryption
mixes. In 11th European Symp. On Research In Computer Security
(ESORICS’06), volume 4189 of Lecture Notes in Computer Science,
pages 313–326. Springer, 2006.
[44] S. Santiago, S. Escobar, C. Meadows, and J. Meseguer. A formal
deﬁnition of protocol indistinguishability and its veriﬁcation using
Maude-NPA. In 10th International Workshop on Security and Trust
Management STM’14, volume 8743 of Lecture Notes in Computer
Science, pages 162–177. Springer, 2014.
[45] B. Schmidt, S. Meier, C. Cremers, and D. Basin. The TAMARIN
prover for the symbolic analysis of security protocols.
In 25th
International Conference on Computer Aided Veriﬁcation (CAV’13),
volume 8044 of Lecture Notes in Computer Science, pages 696–701.
Springer, 2013.
[46] A. Tiu and J. Dawson. Automating open bisimulation checking for
the spi-calculus. In 23rd Computer Security Foundations Symposium
(CSF’10), pages 307–321. IEEE Comp. Soc. Press, 2010.
[47] A. Tiu, N. Nguyen, and R. Horne. SPEC: an equivalence checker
for security protocols.
In 14th Asian Symposium on Programming
Languages and Systems (APLAS’16), volume 10017 of Lecture Notes
in Computer Science, pages 87–95. Springer, 2016.
Appendix A.
Encoding calculus extensions
In section 3.2 we introduced calculus extensions—sum,
guess, circuit—to make establishment of complexity lower
bounds easier. Here we present how the new operators can
be encoded within the original calculus. More precisely we
construct a translation (cid:2)·(cid:3) with the following properties:
Lemma 10. If P is a closed plain process in the extended
syntax, (cid:2)P (cid:3) is a closed plain process in the original syntax
computable in polynomial time in |P|. Besides, after casting
≈ ∈ {≈t,≈(cid:2)} to the extended semantics, we have
({{(cid:2)P (cid:3)}},∅) ≈ ({{P}},∅)
Since the extended semantics does not affect processes
in the original syntax, this lemma justiﬁes that equivalence
in the extended calculus reduces in polynomial
time to
equivalence in the original calculus. The construction of (cid:2)·(cid:3)
is detailed below and the proof of the above lemma can be
found in the technical report [2].
Sums. The non-deterministic choice can be implemented by
a standard encoding, using an internal communication on a
fresh private channel:
(cid:2)P + Q(cid:3) (cid:2) s(cid:5)s(cid:6) | s(x).(cid:2)P (cid:3) | s(y).(cid:2)Q(cid:3)
where s ∈ Nprv and x, y ∈ X 1 are fresh.
Guesses. Using the same mechanism as sums, we can
encode the binary guess.
(cid:2)Choose(x).P (cid:3) (cid:2) s(cid:5)0(cid:6) | s(cid:5)1(cid:6) | s(x).(cid:2)P (cid:3)
where s ∈ Nprv is fresh. We recall that 0 and 1 are two
constructor symbols of the signature.
Circuits. Seeing a circuit edge as a private channel, a circuit
computation can easily be simulated by internal communi-
cation. Let Γ : Bm → Bn be a circuit. For simplicity we
only consider the case where gates have two inputs and
two outputs: handling lower arities is straightforward. If
(c1, c2, g, c3, c4) ∈ Γ is such a gate, we ﬁrst deﬁne notation:
(cid:2)c1, c2, g, c3, c4(cid:3) (cid:2) c1(x).c2(y).
(cid:20)
(cid:2)∈B
b,b
P c3,c4
(cid:2)
g,b,b
(cid:2)
with P c,c
g,b,b
(cid:2) (cid:2) if x = b then
(cid:2)
if y = b
then
(c(cid:5)g(b, b
(cid:2))(cid:6) | c
(cid:2)(cid:5)g(b, b
(cid:2))(cid:6))
(cid:2)c1, c2, g, c3, c4(cid:3)
(c1,c2,g,c3,c4)∈Γ
(x1) . . . con
)n
k=1) are the isolated input (resp.
(xn).(cid:2)P (cid:3)
and Preturn = co1
)m
k=1 (resp. (cok
where (cik
output) edges of Γ.
Appendix B.
Full symbolic semantics
Now we present the remaining rules of the symbolic
semantics, partly presented in ﬁg. 4. Note the formula
introduced by the rule S-ELSE. It has to take into account
that an equality test fails if the compared terms are not
messages—even if they are syntactically equal. For that we
deﬁne, if σ is a substitution, the formula
x (cid:15)=?
¬σ (cid:2) ∀˜zδ.
(cid:21)
xσ
x∈dom(σ)
where ˜zδ = vars(σ) (cid:2) dom(σ). The rules can be found in
ﬁg. 8.
543
where c1, c2, c3, c4 ∈ Nprv. Note that g(b, b
(cid:2)) denotes the
(cid:2) ﬁxed:
boolean obtained from the truth table of g, for b, b
in particular g is not a function symbol of the signature F.
It ﬁnally leads to
(cid:2)(cid:10)x ← Γ((cid:10)b).P (cid:3) (cid:2) Pargs | Pcompute | Preturn
m(cid:20)
k=1
cik
(cid:5)bk(cid:6)
(cid:20)
where Pargs =
and Pcompute =
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:38:36 UTC from IEEE Xplore.  Restrictions apply. 
(cid:10)
if σ ∈ mguR(uμ↓ =? vμ↓)
¬δ))
ε−→s (P ∪ {{Q1}}, (Φ, D, E1 ∧ σ))
ε−→s (P ∪ {{Q2}}, (Φ, D, E1 ∧
(P ∪ {{0}},C) ε−→s (P,C)
(P ∪ {{if u = v then Q1 else Q2}}, (Φ, D, E1))
(P ∪ {{if u = v then Q1 else Q2}}, (Φ, D, E1))
(P ∪ {{u(cid:5)t(cid:6).Q1, v(x).Q2}}, (Φ, D, E1))
(P ∪ {{P | Q}}, (Φ, D, E1))
(P ∪ {{u(x).Q}}, (Φ, D, E1)) Y (X)−−−→s (P ∪ {{Q}}, (Φ, D ∧ X (cid:20)? x ∧ Y (cid:20)? y, E1 ∧ σ))
(P ∪ {{u(cid:5)t(cid:6).Q}}, (Φ, D, E1)) Y (cid:4)axn(cid:5)
ε−→s (P ∪ {{Q1, Q2{x → t}}}, (Φ, D, E1 ∧ σ))
ε−→s (P ∪ {{P, Q}}, (Φ, D, E1))
if σ ∈ mguR(y =? uμ↓, tμ↓ =? tμ↓), y is fresh, X ∈ X 2
−−−−→s (P ∪ {{Q}}, (Φ ∪ {axn (cid:9)→ tσ↓}, D ∧ Y (cid:20)? y, E1 ∧ σ))
Figure 8: Symbolic semantics (where μ = mgu(E1|=))
if σ ∈ mguR(y =? uμ↓) and X, Y ∈ X 2
:|Φ|
:n and n = |Φ| + 1
if σ ∈ mguR(uμ↓ =? vμ↓, tμ↓ =? tμ↓)
δ∈mguR(uμ↓,vμ↓)
(S-NULL)
(S-THEN)
(S-ELSE)
(S-COMM)
(S-PAR)
(S-IN)
(S-OUT)
Appendix C.
Overview of case-distinction rules
At the end of section 5.2, we mentioned the use of case-
distinction rules to generate the partition tree. We give here
more details about these rules. Their purpose is to transform
a set of extended symbolic process into sets of extended
symbolic process where the constraint systems in each set
have statically equivalence solutions. For this reason, case-
distinction rules are presented as (three) transition rules
operating on sets of sets of extended symbolic process.
Extended constraint systems. We need more formalism on
extended constraint systems. First, we consider that recipes
can now contain second-order variables; that is, the set of
recipes is T (F,Npub ∪ AX ∪ X 2). Besides, we extend
the notion of formula in several ways. Deduction fact are
generalised to the form ξ (cid:20)? u where ξ is a recipe. Besides,
we introduce two new atomic formulas:
and ξ =?
ξ =?
(recipe equation)
(equality fact)
(cid:2) are recipes. Recipe equations are similar to (ﬁrst-
where ξ, ξ
order) equations whereas equality facts state that two recipes
deduce the same term; namely
f ξ
ξ
(cid:2)
(cid:2)
(Φ, Σ, σ) |= ξ =?
f ξ
(cid:2) iff Msg(ξΣΦ), Msg(ξ
(cid:2)ΣΦ↓
and ξΣΦ↓ = ξ
(cid:2)ΣΦ),
Moreover, we distinguish two forms of ﬁrst-order for-
mulas called deduction (resp. equality) formulas:
∀S.H ⇐ C1 ∧ . . . ∧ Cn
where
• S is a set of (ﬁrst- and second-order) variables;
• H is a deduction (resp. equality) fact;
• for all i ∈ Nn, Ci is either a deduction fact of the form
X (cid:20)? u or an equation.
This intuitively states that the statement H holds un-
der premisses C1, . . . , Cn. We ﬁnally get to the notion of
extended constraint systems.
(cid:14)
Deﬁnition 14. An extended constraint system C is a tuple
(Φ, D, E1, E2, K, F) where
• (Φ, D, E1) is a constraint system;
• E2 is a conjunction of recipe equations or formulas of
j=1 ξj (cid:15)=? ζj;
the form ∀Y1, . . . , Yk.
• K is a conjunction of deduction facts;
• F is a conjunction of deduction or equality formulas.
E2 is similar to E1 but gathers constraints on recipes.
On the contrary, K and F are not constraints but represent
the attacker knowledge:
• deduction facts in K materialise the deduction capabil-
p