title:Preventing Memory Error Exploits with WIT
author:Periklis Akritidis and
Cristian Cadar and
Costin Raiciu and
Manuel Costa and
Miguel Castro
Preventing memory error exploits with WIT
Periklis Akritidis
∗
∗
Cristian Cadar
Costin Raiciu
∗
Manuel Costa
Miguel Castro
Microsoft Research, Cambridge UK
Abstract
code or the language runtime.
Attacks often exploit memory errors to gain control over
the execution of vulnerable programs. These attacks remain
a serious problem despite previous research on techniques
to prevent them. We present Write Integrity Testing (WIT), a
new technique that provides practical protection from these
attacks. WIT uses points-to analysis at compile time to
compute the control-ﬂow graph and the set of objects that
can be written by each instruction in the program. Then
it generates code instrumented to prevent instructions from
modifying objects that are not in the set computed by the
static analysis, and to ensure that indirect control transfers
are allowed by the control-ﬂow graph. To improve cover-
age where the analysis is not precise enough, WIT inserts
small guards between the original program objects. We de-
scribe an efﬁcient implementation with optimizations to re-
duce space and time overhead. This implementation can be
used in practice because it compiles C and C++ programs
without modiﬁcations, it has high coverage with no false
positives, and it has low overhead. WIT’s average runtime
overhead is only 7% across a set of CPU intensive bench-
marks and it is negligible when IO is the bottleneck.
1. Introduction
Attackers can exploit software errors to control vulnera-
ble programs. Programs written in unsafe languages like C
and C++ are particularly vulnerable because of memory er-
rors, for example, buffer overﬂows and underﬂows [5, 35],
dangling pointers [7], and double frees [26]. Despite pre-
vious research on techniques to prevent these attacks (see
Section 8), at least 40% of the vulnerabilities published by
US-CERT in the last six months are memory errors. We
believe there are two reasons for this: techniques that are
used to prevent these attacks fail to prevent many attacks;
and most techniques are not used because they have high
overhead or they require non-trivial changes to the source
∗
Work done while an intern at MSR Cambridge. Periklis Akritidis is
afﬁliated with the University of Cambridge, Cristian Cadar with Stanford
University, and Costin Raiciu with University College London.
We present Write Integrity Testing (WIT), a new tech-
nique to prevent memory error exploits that addresses the
problems with previous approaches. WIT can be applied to
C and C++ programs without modiﬁcations, it does not re-
quire changes to the language runtime, it has high coverage
with no false positives, and it has low overhead.
At compile time, WIT uses interprocedural points-to
analysis [23] to compute the control-ﬂow graph and the set
of objects that can be written by each instruction in the pro-
gram. At runtime, WIT enforces write integrity, that is, it
prevents instructions from modifying objects that are not
in the set computed by the static analysis. Additionally,
WIT inserts small guards between the original objects in
the program. Since the guards are not in any of the sets
computed by the static analysis, this allows WIT to prevent
sequential overﬂows and underﬂows even when the static
analysis is imprecise. WIT also enforces control-ﬂow in-
tegrity [6, 28], that is, it ensures that the control ﬂow trans-
fers at runtime are allowed by the control-ﬂow graph com-
puted by the static analysis.
WIT uses the points-to analysis to assign a color to each
object and to each write instruction such that all objects that
can be written by an instruction have the same color. It in-
struments the code to record object colors at runtime and to
check that instructions write to the right color. The color of
memory locations is recorded in a color table that is updated
when objects are allocated and deallocated. Write checks
look up the color of the memory location being written in
the table and check if it is equal to the color of the write
instruction. This ensures write integrity.
WIT also assigns a color to indirect call instructions and
to the entry points of functions that may be called indirectly
such that all functions that may be called by the same in-
struction have the same color. WIT instruments the code to
record function colors in the color table and to check indi-
rect calls. The indirect call checks look up the color of the
target address in the table and check if it matches the color
of the indirect call instruction. These checks together with
the write checks ensure control-ﬂow integrity. Control-ﬂow
integrity prevents the attacker from bypassing our checks
and provides an effective second line of defense against at-
tacks that are not detected by the write checks.
We developed several optimizations to reduce the space
and time overhead of our implementation. First, we use
static analysis to determine memory accesses and objects
that are safe, that is, accesses that cannot violate write in-
tegrity and objects that only have safe accesses. We only
instrument unsafe writes and we assign the same color to
all safe objects. This reduces the number of write checks
and also the overhead to maintain the color table. Addi-
tionally, it reduces the number of bits required to represent
colors. One byte was sufﬁcient to represent colors in all our
experiments. Second, we use a compact representation for
the color table that can be looked up efﬁciently. The color
table maintains one byte to represent the color of an eight
byte chunk of memory, which reduces space overhead to ap-
proximately 12.5%. Third, we reduce the cost of updating
color table entries on function calls. Since most local vari-
ables are safe, we only update entries for guards and unsafe
variables on function entry and we reset these entries to the
color of safe objects on function exit.
We evaluated the coverage of WIT using a suite of at-
tacks to test buffer overﬂow prevention techniques [43] and
ﬁve real attacks on SQL server, libpng, ghttpd, nullhttpd,
and stunnel. WIT can prevent all these attacks.
We also evaluated the overhead introduced by WIT using
SPEC CPU and Olden benchmarks. WIT’s average over-
head is 7% and the maximum overhead is 25%. In a Web
server running the SPEC Web 1999 benchmark, the over-
head is even lower: response times increase by 0.2% and
peak throughput decreases by 4.8%. We believe that WIT
can be used in practice to protect software from attacks that
exploit memory errors.
2. Overview
WIT has both a compile-time and a runtime component.
We will use the example in Figure 1 to illustrate how both
components work. The example is a simpliﬁed Web server
with a buffer overﬂow vulnerability. It is inspired by a vul-
nerability in nullhttpd [2] that can be exploited to launch a
non-control-data attack [15].
When the Web server in Figure 1 receives a CGI
command, it calls ProcessCGIRequest with the mes-
sage it received from the network and its size as argu-
ments. The function copies the command from the mes-
sage to the global variable cgiCommand and then calls
ExecuteRequest to execute the command. The vari-
able cgiDir contains the pathname of the directory with
the executables that can be invoked by CGI commands.
ExecuteRequest ﬁrst checks that cgiCommand does not
contain the substring "\\.." and then it concatenates
cgiDir and cgiCommand to obtain the pathname of the
executable to run. The problem is that there is a buffer
1: char cgiCommand[1024];
2: char cgiDir[1024];
3:
4: void ProcessCGIRequest(char* msg, int sz) {
5:
6:
7:
8:
9:
10:
11:
12: }
cgiCommand[i] = msg[i];
i++;
ExecuteRequest(cgiDir, cgiCommand);
int i=0;
while (i < sz) {
}
Figure 1. Example vulnerable code: simpliﬁed
Web server with a buffer overﬂow vulnerability.
if the message is
overﬂow vulnerability in lines 5 — 9:
too long, the attacker can overwrite cgiDir. This allows
the attacker to run any executable (for example, a command
shell) with the arguments supplied in the request message.
This is a non-control-data attack [15]: it does not violate
control-ﬂow integrity.
We start by using points-to analysis [23] to compute the
set of objects that can be modiﬁed by each instruction in the
program. For the example in Figure 1, the analysis com-
putes the set {i} for the instructions at lines 5 and 8, and
the set {cgiCommand} for the instruction at line 7.
To reduce space and time overhead at runtime, we also
perform a write safety analysis to compute instructions and
objects that are safe. An instruction is safe if it cannot vi-
olate write integrity and an object is safe if all instructions
that can modify the object (according to the points-to anal-
ysis) are safe. In our example, the write safety analysis de-
termines that instructions 5 and 8 are safe because they can
only modify i and, therefore, i is safe. It also determines
that the arguments to ProcessCGIRequest are safe.
In
contrast, instruction 7 is not safe because it may modify ob-
jects other than cgiCommand depending on i’s value.
The results of the points-to and write safety analysis are
used to assign a color to each write instruction and a color
to each object in the program. We attempt to assign dis-
tinct colors to each unsafe object under the constraint that
each instruction must have the same color as the objects it
can write. We assign color 0 to all safe objects and all safe
instructions to reduce the number of bits required to rep-
resent colors. In our example, variables msg, sz, and i
and instructions 5 and 8 are assigned color 0 because they
are safe. We assign color 3 to variable cgiCommand and
instruction 7, and color 4 to variable cgiDir.
To reduce the false negative rate due to imprecision of
the points-to analysis, we insert small guards between the
unsafe objects in the original program. Guard objects have
color 0 or 1. These colors are never assigned to unsafe in-
structions in the program to ensure that WIT can detect at-
tempts to overwrite guards or safe objects.
We also use the points-to analysis to compute the func-
tions that can be called by each indirect call instruction in
the program. We assign colors to indirect call instructions
and to the functions they can call. We attempt to assign
distinct colors to each function while ensuring that each in-
struction and the functions it can call have the same color.
The set of colors assigned to functions is disjoint from the
set of colors assigned to unsafe objects, to safe objects, and
to guards. This prevents unsafe instructions from overwrit-
ing code and prevents control transfers outside code regions.
WIT adds extra compilation phases that insert instru-
mentation to enforce write integrity and control ﬂow in-
tegrity. There are four types of instrumentation: to insert
guards, to maintain the color table, to check writes, and to
check indirect calls. Guards are eight bytes long. In our
example, we instrument the code to add guards just before
cgiCommand, between cgiCommand and cgiDir, and just
after cgiDir. We do not insert guards around the argu-
ments to ProcessCGIRequest and local variable i be-
cause they are safe.
WIT uses the color table to record the color of each
memory location. When an object is allocated, the instru-
mentation sets the color of the storage locations occupied
by the object to its color. In our example, WIT adds instru-
mentation at the beginning of main to set the color of the
storage locations occupied by cgiCommand to 3, the color
of the storage for cgiDir to 4, and the color of the storage
for the guards around them to 0.
We use an optimization to reduce the cost of updating the
color table. We initialize the color table to 0 for all memory
locations and we do not update the color table when safe
objects are allocated on the stack. Instead, we only update
the colors for locations corresponding to unsafe objects on
function entry. On function exit, we reset color table entries
that we updated on function entry to 0. Therefore, there
is no instrumentation to update the color table on function
entry or exit for ProcessCGIRequest.
The checks on writes compare the color of the instruc-
tion performing the write to the color of the storage loca-
tion being written. If the colors are different, they raise a
security exception. The color of each instruction is known
statically and write checks use the color table to lookup the
color of the location being written. We do not insert write
checks for safe instructions to improve performance. In the
example in Figure 1, WIT adds write checks only before in-
struction 7 to check if the location being written has color
3. It does not add write checks before lines 5 and 8 because
these instructions are safe.
WIT also records the color of each function that can be
called indirectly in the color table. It inserts instrumenta-
tion to update the color table at program start-up time and
to check the color table on indirect calls. The indirect call
checks compare the color of the indirect call instruction and
its target. If the colors are different, they raise an exception.
There are no indirect calls in our example.
WIT can prevent all attacks that violate write integrity
but the number of attacks that violate this property depends
on the precision of the points-to analysis. For example if
two objects have the same color, we may fail to detect at-
tacks that use a pointer to one object to write to the other.
Our results show that the analysis is sufﬁciently precise to
make this hard. Additionally, WIT can prevent many at-
tacks regardless of the precision of the points-to analysis.
For example, it prevents: attacks that exploit buffer over-
ﬂows and underﬂows by writing elements sequentially un-
til an object boundary is crossed (which are the most com-
mon); attacks that overwrite any safe object (which include
return addresses, exception handler pointers, and data struc-
tures for dynamic linking); and attacks that corrupt heap
management data structures.
Control-ﬂow integrity provides an effective second line
of defense when the write checks fail to detect an attack.
WIT prevents all attacks that violate control-ﬂow integrity
but the number of attacks that violate this property also de-
pends on the precision of the points-to analysis. For exam-
ple, if many functions have the same color as an indirect
call instruction, the attacker may be able to invoke any of
those functions. In the worst case, the analysis may assign
the same color to all functions that may be called indirectly.
Even in this worst case, an attacker that corrupts a func-
tion pointer can only invoke one of these functions. Fur-
thermore, these functions do not include library functions
invoked indirectly though the dynamic linking data struc-
tures. Therefore, the attacker cannot use a corrupt func-
tion pointer to jump to library code, to injected code or to
other addresses in executable memory regions. This makes
it hard to launch attacks that subvert the intended control
ﬂow, which are the most common.
WIT does not prevent out-of-bounds reads. These can
lead to disclosure of conﬁdential data but it is hard to ex-
ploit them to execute arbitrary code without violating write
integrity or control-ﬂow integrity in the process. Therefore,
we chose not to instrument reads to achieve lower overhead.
WIT can prevent attacks on our example Web server.
The write check before line 7 fails and raises an exception
if an attacker attempts to overﬂow cgiCommand. When i
is 1024, the color of the location being written is 0 (which
is the color of the guard) rather than 3 (which is the color
of cgiCommand). Even without guards, WIT would be able
to detect this attack because the colors of cgiCommand and
cgiDir are different.
3. Static analysis
We implemented the points-to and the write safety analy-
sis using the Phoenix compiler framework [30]. These anal-
ysis operate on Phoenix’s medium level intermediate repre-
sentation (MIR), which enables them to be applied to differ-
ent languages and target architectures. Figure 2 shows the
MIR for the vulnerable C code in Figure 1.
_i
$L6: t273
= ASSIGN 0
= COMPARE(LT) _i, _sz
CONDITIONALBRANCH(True) t273, $L8, $L7
$L8: t278
t276
[t276] = ASSIGN [t278]
= ADD _msg, _i
= ADD &_cgiCommand, _i
_i
= ADD _i, 1
GOTO $L6
#1
#2
#3
#4
#5
#6
#7
#8
$L7: CALL &_ExecuteRequest,&_cgiDir,&_cgiCommand
Figure 2. Example vulnerable code in medium-
level intermediate representation (MIR).
We use an inter-procedural points-to analysis due to An-
dersen [8] that is ﬂow and context insensitive but scales to
large programs. It computes a points-to set for each pointer,
which is the set of logical objects the pointer may refer
to. The logical objects are local and global variables and
dynamically allocated objects (for example, allocated with
malloc). We use a single logical object to represent all ob-
jects that are dynamically allocated at the same point in the
program but we do cloning of simple allocation wrappers to
improve analysis precision. Our implementation is similar
to the one described in [23] but it is ﬁeld-insensitive rather
than ﬁeld-based (i.e., it does not distinguish between the dif-