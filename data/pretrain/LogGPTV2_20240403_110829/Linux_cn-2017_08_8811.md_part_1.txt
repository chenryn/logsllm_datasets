---
author: Daniel J Walsh
category: 观点
comments_data: []
count:
  commentnum: 0
  favtimes: 2
  likes: 0
  sharetimes: 0
  viewnum: 7407
date: '2017-08-26 16:10:00'
editorchoice: true
excerpt: 我希望这份深入的介绍能够帮助你理解 Linux 容器的演化过程。Linux 容器曾经陷入一种各自为营的困境，Docker 建立起了镜像创建的事实标准，简化了容器的使用工具。OCI
  则意味着业界在核心镜像格式与运行时方面的合作。
fromurl: https://opensource.com/article/17/7/how-linux-containers-evolved
id: 8811
islctt: true
largepic: /data/attachment/album/201708/26/161009ab5ggfgbg0hb10f5.jpg
permalink: /article-8811-1.html
pic: /data/attachment/album/201708/26/161009ab5ggfgbg0hb10f5.jpg.thumb.jpg
related: []
reviewer: ''
selector: ''
summary: 我希望这份深入的介绍能够帮助你理解 Linux 容器的演化过程。Linux 容器曾经陷入一种各自为营的困境，Docker 建立起了镜像创建的事实标准，简化了容器的使用工具。OCI
  则意味着业界在核心镜像格式与运行时方面的合作。
tags:
- 容器
- OCI
- Docker
thumb: false
title: Linux 容器演化史
titlepic: true
translator: haoqixu
updated: '2017-08-26 16:10:00'
---
> 
> 容器在过去几年内取得很大的进展。现在我们来回顾它发展的时间线。
> 
> 
> 
![](/data/attachment/album/201708/26/161009ab5ggfgbg0hb10f5.jpg)
### Linux 容器是如何演变的
在过去几年内，容器不仅成为了开发者们热议的话题，还受到了企业的关注。持续增长的关注使得在它的安全性、可扩展性以及互用性等方面的需求也得以增长。满足这些需求需要很大的工程量，下面我们讲讲在红帽这样的企业级这些工程是如何发展的。
我在 2013 年秋季第一次遇到 Docker 公司（Docker.io）的代表，那时我们在设法使 Red Hat Enterprise Linux (RHEL) 支持 Docker 容器（现在 Docker 项目的一部分已经更名为 *Moby*）的运行。在移植过程中，我们遇到了一些问题。处理容器镜像分层所需的写时拷贝（COW）文件系统成了我们第一个重大阻碍。Red Hat 最终贡献了一些 COW 文件系统实现，包括 [Device Mapper](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Logical_Volume_Manager_Administration/device_mapper.html)、[btrf](https://btrfs.wiki.kernel.org/index.php/Main_Page)，以及 [OverlayFS](https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt) 的第一个版本。在 RHEL 上，我们默认使用 Device Mapper， 但是我们在 OverlayFS 上也已经取得了很大进展。
我们在用于启动容器的工具上遇到了第二个主要障碍。那时的上游 docker 使用 [LXC](https://linuxcontainers.org/) 工具来启动容器，然而我们不想在 RHEL 上支持 LXC 工具集。而且在与上游 docker 合作之前，我们已经与 [libvrit](https://libvirt.org/) 团队携手构建了 [virt-sandbox](http://sandbox.libvirt.org/) 工具，它使用 `libvrit-lxc` 来启动容器。
在那时，红帽里有员工提到一个好办法，换掉 LXC 工具集而添加桥接器，以便 docker 守护进程通过 `libvirt-lxc` 与 libvirt 通讯来启动容器。这个方案也有一些顾虑。考虑下面这个例子，使用 Docker 客户端（`docker-cli`）来启动容器，各层调用会在容器进程（`pid1OfContainer`）之前依次启动：
> 
> **docker-cli → docker-daemon → libvirt-lxc → pid1OfContainer**
> 
> 
> 
我不是很喜欢这个方案，因为它在启动容器的工具与最终的容器进程之间有两个守护进程。
我的团队与上游 docker 开发者合作实现了一个原生的 [Go 编程语言](https://opensource.com/article/17/6/getting-started-go) 版本的容器运行时，叫作 [libcontainer](https://github.com/opencontainers/runc/tree/master/libcontainer)。这个库作为 [OCI 运行时规范]的最初版实现与 runc 一同发布。
> 
> **docker-cli → docker-daemon @ pid1OfContainer**
> 
> 
> 
大多数人误认为当他们执行一个容器时，容器进程是作为 `docker-cli` 的子进程运行的。实际上他们执行的是一个客户端/服务端请求操作，容器进程是在一个完全单独的环境作为子进程运行的。这个客户端/服务端请求会导致不稳定性和潜在的安全问题，而且会阻碍一些实用特性的实现。举个例子，[systemd](https://opensource.com/business/15/10/lisa15-interview-alison-chaiken-mentor-graphics) 有个叫做套接字唤醒的特性，你可以将一个守护进程设置成仅当相应的套结字被连接时才启动。这意味着你的系统可以节约内存并按需执行服务。套结字唤醒的工作原理是 systemd 代为监听 TCP 套结字，并在数据包到达套结字时启动相应的服务。一旦服务启动完毕，systemd 将套结字交给新启动的守护进程。如果将守护进程运行在基于 docker 的容器中就会出现问题。systemd 的 unit 文件通过 Docker CLI 执行容器，然而这时 systemd 却无法简单地经由 Docker CLI 将套结字转交给 Docker 守护进程。
类似这样的问题让我们意识到我们需要一个运行容器的替代方案。
#### 容器编排问题
上游的 docker 项目简化了容器的使用过程，同时也是一个绝佳的 Linux 容器学习工具。你可以通过一条简单的命令快速地体验如何启动一个容器，例如运行 `docker run -ti fedora sh` 然后你就立即处于一个容器之中。
当开始把许多容器组织成一个功能更为强大的应用时，你才能体会到容器真正的能力。但是问题在于伴随多容器应用而来的高复杂度使得简单的 Docker 命令无法胜任编排工作。你要如何管理容器应用在有限资源的集群节点间的布局与编排？如何管理它们的生命周期等等？
在第一届 DockerCon，至少有 7 种不同的公司/开源项目展示了其容器的编排方案。红帽演示了 [OpenShift](https://www.openshift.com/) 的 [geard](https://openshift.github.io/geard/) 项目，它基于 OpenShift v2 的容器（叫作 gears）。红帽觉得我们需要重新审视容器编排，而且可能要与开源社区的其他人合作。
Google 则演示了 Kubernetes 容器编排工具，它来源于 Google 对其自内部架构进行编排时所积累的知识经验。OpenShift 决定放弃 Gear 项目，开始和 Google 一同开发 Kubernetes。 现在 Kubernetes 是 GitHub 上最大的社区项目之一。
#### Kubernetes
Kubernetes 原先被设计成使用 Google 的 [lmctfy](https://github.com/google/lmctfy) 容器运行时环境来完成工作。在 2014 年夏天，lmctfy 兼容了 docker。Kubernetes 还会在 kubernetes 集群的每个节点运行一个 [kubelet](https://kubernetes.io/docs/admin/kubelet/) 守护进程，这意味着原先使用 docker 1.8 的 kubernetes 工作流看起来是这样的：
> 
> **kubelet → dockerdaemon @ PID1**
> 
> 
> 
回退到了双守护进程的模式。
然而更糟糕的是，每次 docker 的新版本发布都使得 kubernetes 无法工作。Docker 1.10 切换镜像底层存储方案导致所有镜像重建。而 Docker 1.11 开始使用 `runc` 来启动镜像：
> 
> **kubelet → dockerdaemon @ runc @PID1**
> 
> 
> 
Docker 1.12 则增加了一个容器守护进程用于启动容器。其主要目的是为了支持 Docker Swarm （Kubernetes 的竞争者之一）：
> 
> **kubelet → dockerdaemon → containerd @runc @ pid1**