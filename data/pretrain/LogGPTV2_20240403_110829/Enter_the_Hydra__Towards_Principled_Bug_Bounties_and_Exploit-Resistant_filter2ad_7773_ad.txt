### Reveal Period and Anonymity Set

During the reveal period (e.g., 25 minutes), an anonymity set is formed, consisting of hundreds of transactions with a diverse range of values. The value $val is statistically hidden within this set. Notably, the anonymity set represents 2-3% of all transaction traffic over the commit-reveal window. Two specific Submarine Commitment constructions are detailed in Appendix B.

### Analysis of Submarine Commitments

We demonstrate that Submarine Commitments significantly mitigate bug withholding in BountyContract. Our analysis employs a game-based proof in the Fwithhold-hybrid world. Further details can be found in [13], though our model is understandable without in-depth knowledge of Fwithhold.

#### Withholding Game: ExpbntyraceA

Figure 4 illustrates the simple game used in our security analysis, denoted as \( \text{Expbntyrace}_A \). This game is played between an honest user \( P^* = P_0 \) and a user \( P_1 \) controlled by the adversary \( A \). Without loss of generality, \( P^* \) models a collection of honest players, while \( P_1 \) models players controlled by \( A \). \( A \) interacts with \( P^* \) in the ideal functionality \( F_{\text{withhold}} \). Let \( \Delta > \delta + \rho \), where \( \delta \) and \( \rho \) are the number of blocks by which \( A \) can delay or rewind in \( F_{\text{withhold}} \). The experiment considers an interval of \( n \) blocks in a blockchain \( B \) of length \( n' = n + \Delta \).

In this game, a player can send only two messages: ("commit", $deposit) and "reveal". To model Submarine Commitments, we assume that \( P^* \)'s commit message is opaque to \( A \), meaning \( A \) cannot detect its presence in a block and it does not count toward the block's size.

For clarity, we first analyze Submarine Commitments outside the Poisson framework of Section 4. Our results also hold in that setting, with a slightly tighter bound for Theorem 3 below (see [13] for a proof).

Instead, we consider a blockchain interval of \( n \) blocks, wherein \( P^* \) commits in a block chosen uniformly at random. That is, \( P^* \) posts ("commit", $deposit) in the block at index \( \text{commblock}_{P^*} \leftarrow [1, n] \). \( P^* \) then posts a "reveal" in block \( \text{revblock}_{P^*} = \text{commblock}_{P^*} + \rho \).

\( A \) wins the game if she posts a valid "commit" before \( P^* \) and also posts a corresponding "reveal" to claim the bounty. We let \( p_{\text{wins}} = \Pr[(\text{TRUE}, \cdot) \leftarrow \text{Expbntyrace}_A] \).

As a primary goal, an economically rational adversary \( A \) aims to maximize its expected payoff, given by:

\[ E[\$payoff] = p_{\text{wins}} \cdot \$bounty - E[\$cost]. \]

Of course, \( A \) can always post a "commit" in \( B_1 \) followed by a "reveal" within \( \Delta \) blocks, achieving \( p_{\text{wins}} = 1 \) with \( \$payoff = \$bounty - \$deposit \), which is optimal but achieves no withholding.

### Results

A compelling withholding strategy for \( A \) is to reveal a bug only by front-running \( P^* \), i.e., a pure front-running strategy. If \( P^* \) sends a "reveal" in block \( B_j \), then \( A \) learns that \( P^* \) posted a "commit" in block \( B_{j-\rho} \). \( A \) can rewind and post its own "reveal" earlier than \( P^* \). However, \( A \) can rewind at most \( \rho \) blocks, so \( A \) only succeeds if it has previously posted a "commit" in the interval \([B_{j-\rho-\Delta}, B_{j-\rho}]\).

We show that for natural parameters, \( A \) achieves no benefit, i.e., positive expected payoff, via pure front-running. Intuitively, front-running is expensive because \( A \) must post "commit" messages continuously to ensure it can front-run \( P^* \). The proof of the following theorem is in the extended version of this paper [13].

**Theorem 3.** Let \( \Delta \geq 4 \) and \( \$deposit > 10(\Delta+1) \cdot \$bounty \). Then a pure front-running adversary has \( E[\$payoff] < 0 \).

### Design and Implementation

We implemented a decentralized automated bug bounty for Ethereum smart contracts. We describe the main technical deployment challenges and explain our design.

#### The Ethereum Virtual Machine (EVM)

The EVM is a simple stack-based architecture [57]. Smart contracts can access three data structures: a stack, volatile memory, and permanent on-chain storage. Execution of a contract begins with a transaction sent to the blockchain, specifying the called contract, call arguments, and an amount of ether, Ethereum's currency. The EVM executes the contract's code in a sequential, deterministic, single-threaded fashion. Operations can read and write to the stack, memory, or storage, and spawn a new call frame (with a fresh memory region) by calling other contracts. Each instruction costs a fixed amount of gas, a special resource used to price transactions.

Contracts can exceptionally halt, revert all changes made in the current call frame (e.g., storage updates, transfers of ether), and report an exception to the caller.

#### EVM Execution Environment

To achieve the full power of our Hydra bug bounty, \( N \) smart contract versions are run on the blockchain. While we could also run a bounty program off-chain (for a single deployed contract), this would not provide an exploit gap, a key property in our analysis of attacker incentives.

The main challenge is the implementation of the "Execution Environment" [17, 6], the agent that coordinates the \( N \) heads and combines their outputs. Its complexity should be minimal, as it is part of the Trusted Computing Base (TCB) of our application: a bug in the coordinating agent is likely an exploit against the Hydra contract.

**Proxy Meta-Contract (MC):** As shown in Figure 2, the logical embodiment of a Hydra contract is a proxy meta-contract (MC), which coordinates \( N \) deployed contract versions (or heads). Clients and other contracts interact only with the MC. The heads respond only to calls from the MC and do not hold any ether themselves.

The MC delegates all incoming calls to each head and verifies that the obtained outputs match. If they do, it returns that output. Otherwise, it throws an exception, reverting all changes made by the heads. The TBounty transformation described in Section 3.3 is implemented as a simple wrapper around the MC, which catches the above exception, pays out a bounty, and enters an escape-hatch mode.

**Maintaining Consistent Blockchain Interactions:** Since EVM execution is deterministic, the result of a contract call is fully determined by the call's input, the contract code, and the current blockchain state. If smart contracts were executed in isolation, the above proxy contract would be sufficient. However, most smart contracts also interact with the blockchain, e.g., by accessing information about the current transaction (such as the sender's address) or by calling other contracts, and the MC must thus guarantee consistency among the heads.

We illustrate the issue in Figure 5 with a Solidity code snippet (top-left) and corresponding EVM opcodes (bottom-left). The function \( f(x) \) makes a call to \( g(x) \) in the calling contract (msg.sender) and reimburses any sent ether (msg.value). If used as a head in a Hydra contract, this code snippet presents multiple issues:

1. **CALLVALUE and CALLER Modification:** When the MC delegates a call to the head, CALLER will now be the MC's address, and CALLVALUE will be zero.
2. **Heads Cannot Send Ether:** The heads cannot send ether as they do not hold any.
3. **Multiple Calls to g(x):** With \( N \) heads, \( g(x) \) is called \( N \) times instead of once, and the heads might obtain different return values.

To resolve these issues, the heads are instrumented prior to deployment so that all interactions with the blockchain are mediated by the MC. These modifications could be made in a high-level language (e.g., Solidity), but we opt for a more generic, automated, and globally applicable solution that operates on the EVM opcodes of a compiled contract. The instrumentation is thus agnostic to the language used to develop the heads.

**Opcode Instrumentations:**

- **Environment Information:** We ensure that all heads share the view of a common Hydra contract. The ADDRESS opcode (which returns the current contract's address) is modified to return the MC's address. The heads reject all calls that do not emanate from the MC. The MC also forwards CALLVALUE and CALLER to the heads as extra call arguments, making the proxy delegation transparent. These opcodes are overwritten accordingly in the heads to read from the call data.
- **System Operations:** Opcodes that interact with other blockchain entities (e.g., calling a contract, reading account balances, or logging messages) are rewritten as callbacks to the MC. The MC checks consistency among the heads' callbacks and issues the required operations on their behalf. The instrumentation requires some extra volatile memory to store callback arguments, so all memory accesses in the original code are shifted by a fixed offset to create a scratch space.

The instrumented heads are independently deployed on the chain. We now discuss the callback mechanism, as well as the soundness and applicability of our approach.

**Callbacks:** Due to the sequential nature of the EVM, we designed the Hydra meta-contract to optimistically respond to callbacks. When the first head runs, the MC executes all callbacks (e.g., external calls) and records the callback arguments and return values. When the remaining heads run, the MC verifies consistency of requested callbacks and replays the responses. If heads request different callbacks, the MC throws an exception, reverting all changes and triggering the bounty payment.

To maintain consistency between heads and avoid potential read-write inversions, the program specification must define a total-ordering of the read and write operations issued by the heads.

**Tail-Call Optimization:** A design pattern for smart contracts ("Checks-Effects-Interactions" [23]) suggests that interactions with other blockchain entities should occur last in a call. For contracts that follow this paradigm, a tail-call optimization can be applied to callbacks. Instead of calling into the MC, the heads simply append any required call or log operations to the calls' return value. Operations that read blockchain state (e.g., balance checks) are not instrumented. The MC then collects the return values from all heads, verifies consistency, and executes all interactions before returning.

**Exception Handling:** Recall that the EVM halts when contracts perform illegal operations, e.g., explicitly throwing exceptions or running out of gas. Ideally, we would classify any divergence in the heads' behavior as a bug and pay a bounty. However, it is easy to set gas amounts so that one head runs out of gas, yet others succeed. Explicit exceptions are thus instrumented to return a special value to the MC, so as to be distinguished from an out-of-gas exception. If all heads throw an explicit exception, the MC propagates the exception to the caller.

### Limitations

Our Hydra head instrumenter, written in Haskell, applies simple opcode rewriting rules (see Figure 5), which are verified to preserve program invariants such as stack and memory layout. Our modifications impact the heads' gas consumption, but the overhead is minor (see Section 7). Rewriting opcodes also modifies the layout of the bytecode, so all JUMP instructions are updated accordingly.

The instrumentation applies to contracts written in any high-level language that compiles to the EVM and requires no changes to the EVM. We have not yet implemented callbacks for the infrequent CREATE and SELFDESTRUCT opcodes. We do not yet support opcodes that modify a head's code (e.g., DELEGATECALL), which are often used to load libraries into a contract.