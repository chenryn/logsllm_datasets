reveal period (e.g., 25 minutes), form an anonymity set
of hundreds of transactions with a diverse range of val-
ues among which $val is statistically hidden. Notably,
the anonymity set represents 2-3% of all transaction traf-
ﬁc over the commit-reveal window. Two concrete Sub-
marine Commitment constructions are in Appendix B.
5.4 Analysis of Submarine Commitments
We prove that Submarine Commitments strongly miti-
gate bug withholding in BountyContract. Our analysis
uses a game-based proof in the Fwithhold-hybrid world.
Details are in [13], although our model is understandable
without detailed knowledge of Fwithhold.
A
A
. Figure 4 shows the
Withholding game: Expbntyrace
simple game used in our security analysis, denoted by
Expbntyrace
. The game is played between an honest user
P∗ = P0, and a user P1 controlled by A. W.l.o.g., P∗
models a collection of honest players, while P1 models
players controlled by A. A interacts with P∗ in the ideal
functionality Fwithhold. Let ∆ > δ +ρ, where δ and ρ are
the number of blocks by which A can delay or rewind
in Fwithhold. The experiment considers an interval of n
blocks in a blockchain B of length n(cid:48) = n + ∆.
In this game, a player can send only two messages:
(“commit”,$deposit), and “reveal”. To model Subma-
rine Commitments, we assume that P∗’s commit mes-
sage is opaque to A, i.e., A cannot detect its presence in
a block and it does not count toward the block’s size.
For clarity’s sake, we ﬁrst analyze Submarine Com-
mitments outside the Poisson framework of Section 4.
Our results also hold in that setting, with a slightly tighter
bound for Theorem 3 below (see [13] for a proof).
Instead, we consider a blockchain interval of n blocks,
wherein P∗ commits in a block chosen uniformly at ran-
dom. That is, P∗ posts (“commit”,$deposit), in the block
at index commblockP∗ ←$ [1,n]. P∗ posts a “reveal” in
block revblockP∗ = commblockP∗ + ρ.
A wins the game if she posts a valid “commit” before
P∗ does, and also posts a corresponding “reveal” to claim
(n(cid:48),δ ,ρ,s;∆,$deposit,$bounty)
Experiment ExpbntyraceA
Init: n ← n(cid:48) − ∆,$cost ← 0, commblockP∗ ←$ [1,n]
A{B←Fwithhold({P0 =P∗ ,P1},n,δ ,ρ,s)} //A interacts with Fwithhold
for i = 1 to n
if (“commit”,$deposit) ∈ Bi then
$cost ← $cost + $deposit
if(cid:0)∃(1 ≤ i ≤ commblockP∗ ∧ i ≤ j ≤ min(i + ∆,n)) s.t.
∃ (τ = “reveal”) ∈ B j s.t. tag(τ) = ( j,P1)(cid:1) then
∃ (τ = “commit”) ∈ Bi s.t. tag(τ) = (i,P1) ∧
//Every commit costs $deposit
output(TRUE,$payoff := $bounty− $cost)
//A wins
output(FALSE,$payoff := −$cost)
Figure 4: Adversarial game Expbntyrace
A
the bounty. We let pwins = Pr[(TRUE,·) ← Expbntyrace
].
As a ﬁrst goal, an economically rational adversary A’s
aims to maximize its expected payoff, namely
A
E[$payoff] = pwins · $bounty− E[$cost].
(4)
Of course, A can always post a “commit” in B1 followed
by a “reveal” within ∆ blocks, in which case it achieves
pwins = 1 with $payoff = $bounty − $deposit, which is
optimal. But then it achieves no withholding.
Results. A compelling withholding strategy for A is to
reveal a bug only by front-running P∗, i.e., a pure front-
running strategy. That is, if P∗ sends a “reveal” in block
B j, then A learns that P∗ posted a “commit” in block
B j−ρ. A can rewind and post its own “reveal” earlier than
P∗. But A can rewind at most ρ blocks (i.e., block B j−ρ
cannot be erased), so A only succeeds if it has previously
posted a “commit” in the interval [B j−ρ−∆,B j−ρ ].
We show that for natural parameters, A achieves no
beneﬁt, i.e., positive expected payoff, via pure front-
running. Intuitively, this is because front-running is ex-
pensive: Since A observes a “commit” message from P∗
too late to remove it by rewinding, A must post “commit”
messages continuously to ensure that it can front-run P∗.
The proof of the following theorem is in the extended
version of this paper [13].
·$bounty.
Theorem 3. Let ∆ ≥ 4 and $deposit > 10(∆+1)
Then a pure front-running adversary has E[$payoff]  0).
USENIX Association
27th USENIX Security Symposium    1343
Of course, A could use other strategies.
In the ex-
tended version of this paper [13], we consider a gener-
alized α-revealing strategy that involves conditional pre-
emptive bug disclosure. We show that this strategy does
no better than pure front-running.
6 Design and Implementation
We implemented a decentralized automated bug bounty
for Ethereum smart contracts. We describe the main
technical deployment challenges, and explain our design.
The EVM. The Ethereum Virtual Machine (EVM) is
a simple stack-based architecture [57]. Smart contracts
can access three data structures: a stack, volatile mem-
ory, and permanent on-chain storage.
Execution of a contract begins with a transaction sent
to the blockchain, specifying the called contract, the call
arguments, and an amount of ether, Ethereum’s currency.
The EVM executes the contract’s code in a sequential,
deterministic, single-threaded fashion. Operations can
read and write to stack, memory or storage, and spawn a
new call frame (with a fresh memory region) by calling
other contracts. Each instruction costs a ﬁxed amount of
gas, a special resource used to price transactions.
Contracts can exceptionally halt, revert all changes
made in the current call frame (e.g., storage updates,
transfers of ether), and report an exception to the callee.
6.1 An EVM Execution Environment
To achieve the full power of our Hydra bug bounty, N
smart contract versions are run on the blockchain. While
we could also run a bounty program off-chain (for a sin-
gle deployed contract), this would not provide an exploit
gap, a key property in our analysis of attacker incentives.
The main challenge is the implementation of the “Ex-
ecution Environment” [17, 6], the agent that coordinates
the N heads and combines their outputs. Its complexity
should be minimal, as it is part of the Trusted Computing
Base (TCB) of our application: a bug in the coordinating
agent is likely an exploit against the Hydra contract.
A proxy meta-contract. As we showed in Figure 2,
the logical embodiment of a Hydra contract is a proxy
meta-contract (MC), which coordinates N deployed con-
tract versions (or heads). Clients and other contracts only
interact with the MC. The heads only respond to calls
from the MC, and do not hold any ether themselves.
The MC delegates all incoming calls to each head, and
veriﬁes that the obtained outputs match. If so, it returns
that output. Otherwise, it throws an exception, to revert
all changes made by the heads. The TBounty transforma-
tion described in Section 3.3 is implemented as a simple
wrapper around the MC, which catches the above excep-
tion, pays out a bounty, and enters an escape-hatch mode.
Maintaining consistent blockchain interactions. As
the EVM execution is deterministic, the result of a con-
tract call is fully determined by the call’s input, the con-
tract code and the current blockchain state. If smart con-
tracts were executed in isolation, the above proxy con-
tract would thus be sufﬁcient. However, most smart con-
tracts also interact with the blockchain, e.g., by access-
ing information about the current transaction (such as the
sender’s address) or by calling other contracts, and the
MC must thus guarantee consistency among the heads.
We illustrate the issue in Figure 5 with a Solidity
code snippet (top-left) and corresponding EVM opcodes
(bottom-left). The function f (x) makes a call to g(x) in
the calling contract (msg.sender) and reimburses any
sent ether (msg.value). If used as a head in a Hydra
contract, this code snippet presents multiple issues.
1. CALLVALUE and CALLER are modiﬁed when the MC
delegates a call to the head. CALLER will now be the
MC’s address, and CALLVALUE will be zero.
2. The heads cannot send ether as they do not hold any.
3. With N heads, g(x) is called N times instead of once.
The heads might also obtain different return values.
To resolve these issues, the heads are instrumented
prior to deployment so that all interactions with the
blockchain are mediated by the MC. While these mod-
iﬁcations could be made in a high-level language (e.g.,
Solidity), we opt for a more generic, automated, and
globally applicable solution that operates on the EVM
opcodes of a compiled contract (the instrumentation is
thus agnostic to the language used to develop the heads).
Opcode instrumentations are essentially of two types:
• Environment Information. We ensure that all heads
share the view of a common Hydra contract. The
ADDRESS opcode (which returns the current contract’s
address) is modiﬁed to return the MC’s address. The
heads reject all calls that do not emanate from the MC.
The MC also forwards CALLVALUE and CALLER to the
heads as extra call arguments, to make the proxy dele-
gation transparent. These opcodes are overwritten ac-
cordingly in the heads to read from the call data.
• System Operations. Opcodes that interact with other
blockchain entities (e.g., calling a contract, reading
account balances, or logging messages) are rewritten
as callbacks to the MC. The MC checks consistency
among the heads’ callbacks and issues the required op-
erations on their behalf. The instrumentation requires
some extra volatile memory to store callback argu-
1344    27th USENIX Security Symposium
USENIX Association
f u n c t i o n f ( int x ) payable {
// r e i m b u r s e s e n d e r and call g ( x )
( msg . sender ) . g . value ( msg . value ) ( x ) ;
f u n c t i o n f ( int x , addr sender , uint val ) {
// send all call args to meta - c o n t r a c t
MC . call ( bytes4 ( sha3 ( " g ( int256 ) " ) ) ,x , sender , val ) ;
}
}
⇓
MSTORE (M , 0 x 7 8 7 7 b 8 0 3 ) # s t o r e sig of g in m e m o r y
MSTORE ( M +4 , C A L L D A T A L O A D (4)) # s t o r e x
PUSH32 (0) # o u t p u t size and m e m o r y l o c a t i o n
PUSH32 (0) # o u t p u t m e m o r y
PUSH32 (36) # i n p u t size
PUSH32 ( M ) # i n p u t m e m o r y
C A L L V A L U E # use msg . v a l u e as the call v a l u e
CALLER # use msg . s e n d e r as the dest a d d r e s s
GAS
CALL # this o p c o d e will be i n s t r u m e n t e d
⇒
(⇑)
MSTORE ( M∗ , 0 x 7 8 7 7 b 8 0 3 ) # s t o r e sig of g in m e m o r y
MSTORE ( M∗ +4 , C A L L D A T A L O A D (4)) # s t o r e x
MSTORE ( M∗ +36 , C A L L D A T A L O A D (36)) # s t o r e s e n d e r
MSTORE ( M∗ +68 , C A L L D A T A L O A D (68)) # s t o r e v a l u e
PUSH32 (0) # o u t p u t size
PUSH32 (0) # o u t p u t m e m o r y
PUSH32 (100) # i n p u t size
PUSH32 ( M∗ ) # i n p u t m e m o r y
PUSH32 (0) # send 0 e t h e r
PUSH32 ( M C a d d r e s s ) # d e s t i n a t i o n a d d r e s s of the call
GAS
CALL # a f t e r call returns , c l e a n u p s t a c k
Figure 5: EVM instrumentation of Hydra heads (simpliﬁed example). (Top left) Solidity function that calls g(x) in the calling
contract (msg.sender) and sends back all ether (msg.value). (Bottom left) EVM bytecode for the call to g(x). MSTORE(a, v) is
syntactic sugar for {PUSH32(a), PUSH32(v), MSTORE} which writes value v to memory address a. CALL consumes 7 stack items:
gas amount, address to call, ether amount to send, and memory location and size for call arguments and outputs. (Bottom right)
Instrumented bytecode: CALLVALUE and CALLER are read from function arguments. All call data is stored in memory and used as
arguments for a callback to the MC. (Top right) Functionally equivalent Solidity code for the instrumented bytecode.
ments, so all memory accesses in the original code are
shifted by a ﬁxed offset to create a scratch space.
The instrumented heads are independently deployed
on chain. We now discuss the callback mechanism, as
well as the soundness and applicability of our approach.
Callbacks. Due to the sequential nature of the EVM,
we designed the Hydra meta-contract to optimistically
responds to callbacks. That is, when the ﬁrst head runs,
the MC executes all callbacks (e.g., external calls) and
records the callback arguments and return values. When
the remaining heads run, the MC veriﬁes consistency of
requested callbacks and replays the responses. If heads
request different callbacks, the MC throws an exception,
reverting all changes and triggering the bounty payment.
To maintain consistency between heads, and avoid po-
tential read-write inversions (e.g., if heads send ether and
read contract balances in different orders), the program
speciﬁcation is required to deﬁne a total-ordering of the
read and write operations issued by the heads.
Tail-call optimization. A design pattern for smart-
contracts (“Checks-Effects-Interactions” [23]) suggests
that interactions with other blockchain entities should oc-
cur last in a call. For contracts that follow this paradigm,
a tail-call optimization can be applied to callbacks.
Instead of calling into the MC, the heads simply ap-
pend any required call or log operations to the calls’ re-
turn value. Operations that read blockchain state (e.g.,
balance checks) are not instrumented. The MC then col-
lects the return values from all heads, veriﬁes consis-
tency, and executes all interactions before returning.
Exception handling. Recall that the EVM halts when
contracts perform illegal operations, e.g., explicitly
throwing exceptions or running out of gas. Ideally, we
would classify any divergence in the heads’ behavior as
a bug and pay a bounty. However, it is easy to set gas
amounts so that one head runs out of gas, yet others suc-
ceed. Explicit exceptions are thus instrumented to return
a special value to the MC, so as to be distinguished from
an out-of-gas exception. If all heads throw an explicit
exception, the MC propagates the exception to the caller.
6.2 Limitations
Our Hydra head instrumenter, written in Haskell, applies
simple opcode rewriting rules (see Figure 5), which are
veriﬁed to preserve program invariants such as stack and
memory layout. Our modiﬁcations impact the heads’ gas
consumption, yet the overhead is minor (see Section 7).
Rewriting opcodes also modiﬁes the layout of the byte-
code, so all JUMP instructions are updated accordingly.
The instrumentation applies to contracts written in
any high-level language that compiles to the EVM, and
requires no changes to the EVM. We have not yet
implemented callbacks for the infrequent CREATE and
SELFDESTRUCT opcodes. We do not yet support opcodes
that modify a head’s code (e.g., DELEGATECALL). These
are often used to load libraries into a contract. Using