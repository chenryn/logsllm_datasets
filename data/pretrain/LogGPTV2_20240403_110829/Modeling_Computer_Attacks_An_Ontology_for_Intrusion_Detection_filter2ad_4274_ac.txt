Error
Fig. 4. Our IDS Ontology
ii. System. This includes attributes representing the operating system of the host. It in-
cludes attributes representing overall memory usage (MEM TOTAL, MEM FREE,
MEM SWAP) and CPU usage (LOAD AVG). The class also contains attributes re-
ﬂective of the number of current users, disk usage, the number of installed kernel
modules, and change in state of the interrupt descriptor and system call tables.
iii. Process. This class contains attributes representing particular processes that are to
be monitored. These attributes include the current value of the instruction pointer
(INS P), the current top of the stack (T STACK), a scalar value computed from the
stream of system calls (CALL V), and the number of child processes (N CHILD).
The class Attack has the properties Directed to, Effected by, and Resulting in. This
construction is predicated upon the notion that an attack consists of some input which is
directed to some system component and results in some consequence. Accordingly, the
classes System Component, Input, and Consequence are the corresponding objects. The
class Consequence is comprised of several subclasses which include:
i. Denial of Service. The attack results in a Denial of Service to the users of the system.
The denial of service may be because the system was placed into an unstable state
or all of the system resources may be consumed by meaningless functions.
ii. User Access. The attack results in the attacker having access to services on the target
system at an unprivileged level.
iii. Root Access. The attack results in the attacker being granted privileged access to
the system, consequently having complete control of the system.
iv. Probe. This type of an attack is the result of scanning or other activity wherein a
proﬁle of the system is disclosed.
Modeling Computer Attacks: An Ontology for Intrusion Detection
125
Finally, the class Input has the predicates Received from and Causing where Causing
deﬁnes the relationship between the Means of attack and some input and Received from
deﬁnes the relationship between Input and Location. The class Location is an instance
of System Component and is restricted to instances of the Network and Process classes.
We deﬁne the following subclasses for Means of attack:
i. Input Validation Error. An input validation error exists if some malformed input
is received by a hardware or software component and is not properly bounded or
checked. This class is further sub-classed as:
(a) Buffer Overﬂow. The classic buffer overﬂow results from an overﬂow of a
static-sized data structure.
(b) Boundary Condition Error. A process attempts to read or write beyond a valid
address boundary or a system resource is exhausted.
(c) Malformed Input. A process accepts syntactically incorrect input, extraneous
input ﬁelds, or the process lacks the ability to handle ﬁeld-value correlation
errors.
ii. Logic Exploits. Logic exploits are exploited software and hardware vulnerabilities
such as race conditions or undeﬁned states that lead to performance degradation
and/or system compromise. Logic exploits are further subclasssed as follows:
(a) Exception Condition. An error resulting from the failure to handle an exception
condition generated by a functional module or device.
(b) Race Condition. An error occurring during a timing window between two op-
erations.
(c) Serialization Error. An error that results from the improper serialization of op-
erations.
(d) Atomicity Error. An error occurring when a partially-modiﬁed data structure is
used by another process; An error occurring because some process terminated
with partially modiﬁed data where the modiﬁcation should have been atomic.
As previously stated, the properties of Mutual Exclusion, Exhaustive, Non-ambiguity,
Usefulness, Objectivity, Determinism, Repeatability and Speciﬁcity are the overarching
requirements that determine the taxonomic characteristics of our ontology. We believe
that we have met these requirements predicated upon the following:
i. Mutual Exclusion. Each class in the ontology is disjoint from the other classes
because none share an identical set of properties.
ii. Exhaustive. Our analysis of the available data indicates that computer attacks and
intrusions are effected by some input, that is directed to some system component,
causing some heretofore unintended system response (means), and results in some
adverse system consequence. Our ontology captures these notions.
iii. Non-ambiguity. Each class in the ontology has a deﬁnite set of properties and
restrictions.
iv. Usefulness. As will be exempliﬁed in Section 5, Implementation, our ontology en-
ables the conclusion (entailment) of new knowledge from seemingly disassociated
facts.
126
J. Undercoffer, A. Joshi, and J. Pinkston
v. Objectivity. The properties of the classes of our ontology are directly derivable
from 190 distinct system features. This feature set characterizes system state at any
particular time.
vi. Deterministic. The properties of each class obtainable from metrics associated with
the Linux kernel.
vii. Repeatability. An instantiated object within our ontology will always be evaluated
to the identical conclusion. Moreover, the same object will be evaluated to the same
conclusions by any entity using the ontology.
viii. Speciﬁc. The property values for classes that deﬁne aberrant system behavior are
unique and are limited to a set of 190 attributes.
5 Implementation
There are several reasoning systems that are compatible with DAML+OIL[12,19,28,21],
which according to their functionality, may be classiﬁed as backward-chaining or forward-
chaining. Backward-chaining reasoners process queries and return proofs for the answers
they provide. Forward-chaining reasoners process assertions substantiated by proofs, and
draw conclusions.
We have prototyped the logic portion of our system using the DAMLJessKB [28]
reasoning system. DAMLJessKB is employed to reason over instances of our data model
that are considered to be suspicious. These suspicious instances are constrained according
to our ontology and asserted into the knowledge base.
Upon initialization of DAMLJessKB, we parse the DAML+OIL statements repre-
senting the ontology, converting them into N-Triples, and assert them into a knowledge
base as rules. The assertions are of the form:
(assert
(PropertyValue (predicate) (subject) (object)))
Once asserted, DAMLJessKB generates additional rules which include all of the chains
of implication derived from the ontology.
As will be illustrated shortly, additional information in the form of instances of the
ontology is asserted into the knowledge base as facts.
5.1 Querying the Knowledge Base
Once the ontology is asserted into the knowledge base and all of the derived rules
resulting from the chains of implication are generated, the knowledge base is ready to
receive instances of the ontology. Instances are asserted and de-asserted into/from the
knowledge base as temporal events dictate. The query language is of the form ((predicate)
(subject) (object)) where at least one of the three elements of the triple must be contain a
value. The other one or two elements may be left uninstantiated (signiﬁed by prefacing
them with a “?”). If there are any triples in the knowledge base that match the query
either as the result of an assertion of a fact or derived rules resulting from the chain of
implication, the value of those triples will be returned.
To query the knowledge base for the existence of an attack or intrusion, the query
could be so granular that it requests an attack of a speciﬁc type, such as a Syn Flood:
Modeling Computer Attacks: An Ontology for Intrusion Detection
127
(defrule isSynFlood
(PropertyValue
(p http://www.w3.org/1999/02/22-rdf-syntax-ns#type)
(s ?var)
(o http://security.umbc.edu/IntrOnt#SynFlood))
=>
(printout t ‘‘A SynFlood attack has occurred.’’
crlf
‘‘with event number: ‘‘ ?var))
The query could be of a medium level of granularity, asking for all attacks of a speciﬁc
class, such as denial of service. Accordingly, the following query will return all instances
of an attack of the class Denial of Service.
(defrule isDOS
(PropertyValue
(p http://www.w3.org/1999/02/22-rdf-syntax-ns#type)
(s ?var)
(o http://security.umbc.edu/IntrOnt#DoS))
=>
(printout t ‘‘A DoS attack has occurred.’’
crlf
‘‘with ID number: ‘‘ ?var))
Finally, the following rule will return instances of any attack, where the event numbers
that are returned by the query need to be iterated over in order to discern the speciﬁc
type of attack:
(defrule isConseq
(PropertyValue
(p http://www.w3.org/1999/02/22-rdf-syntax-ns#type)
(s ?var)
(o http://security.umbc.edu/IntrOnt#Conseq))
=>
(printout t ‘‘An attack has occurred.’’
‘‘with ID number: ‘‘ ?var))
crlf
These varying levels of granularity are possible because of DAML+OIL’s notion of
classes, subclasses, and the relationships that hold between them. The query variable
?var, which corresponds to the subject, contained in each of the queries, is instantiated
with the subject whenever a predicate and object from a matching triple is located in the
knowledge base.
6 Using the Ontology to Detect Attacks: Use Case Scenarios
To test our implementation and experiment with it, we created instances of our ontology
in DAML+OIL notation, and asserted them into the knowledge base. We then ran our
queries against the knowledge base.
6.1 Denial of Service – Syn Flood
The DAML+OIL representation of an instance of a Syn Flood attack is illustrated in
Figure 5. The ﬁrst statement indicates that an event numbered 00035 has occurred,
which has the resulting in property instantiated to an instance of a Syn Flood that is
uniquely identiﬁed as event number 00038.
128
J. Undercoffer, A. Joshi, and J. Pinkston
Fig. 5. DAML+OIL Notation for an Instance of a Syn Flood Attack
When the knowledge base was queried for instances of Denial of Service (DoS)
attacks, the following was returned:
The event number of the intrusion is:
http://security.umbc.edu/Intrusion#00038
The type of intrusion is:
http://security.umbc.edu/Intrusion#Syn_Flood
The victim’s IP address is:
130.85.112.231
The time and date of the event:
15:43:12 hours on 02/22/2003
It is important to note that we only queried for the existence of a Denial of Service
attack, we did not speciﬁcally ask for Syn Flood attacks. The instance of the Syn Flood
attack was returned because it is a subclass of Denial of Service.
6.2 The Classic Mitnick Type Attack
This subsection provides an example of using our ontology as it operates within a coali-
tion of distributed IDSs to detect the Mitnick attack. This particular attack is a distributed
attack consisting of a Denial of Service attack, TCP sequence number prediction and IP
spooﬁng.
The following example of a distributed attack illustrates the utility of our ontology.
The Mitnick attack is multi-phased; consisting of a Denial of Service attack, TCP
sequence number prediction and IP spooﬁng. When this attack ﬁrst occurred in 1994, a
Syn Flood was used to effect the denial of service; however, any denial of service attack
would have sufﬁced.
In the following example, which is illustrated in ﬁgure 6, Host B is the ultimate
target and Host A is trusted by Host B.
The attack is structured as follows:
i. The attacker initiates a Syn/Flood attack against Host A to prevent Host A from
responding to Host B.
ii. The attacker sends multiple TCP packets to the target, Host B, in order to be able
to predict the values of TCP sequence numbers generated by Host B.
Modeling Computer Attacks: An Ontology for Intrusion Detection
129
iii. The attacker then pretends to be Host A by spooﬁng Host A’s IP address, and sends
a Syn packet to Host B in order to establish a TCP session between Host A and
Host B.
iv. Host B responds with a SYN/ACK to Host A. The attacker does not see this packet.
Host A, since its input queue is full due to number of half open connections caused
by the Syn/Flood attack, cannot send a RST message to Host B in response to the
spurious Syn message.
v. Using the calculated TCP sequence number of Host B (recall that the attacker did
not see the Syn/ACK message sent from Host B to Host A) the attacker sends an Ack
with the predicted TCP sequence number packet in response to the Syn/Ack packet
sent to Host A.
vi. Host B is now in a state of belief that a TCP session has been established with a
trusted host Host A. The attacker now has a one way session with the target, Host
B, and can issue commands to the target.
Host A
Step  4.  Host B sends
SYN/ACK to Host A, in
response to step 3.
Host A’s input queue is
full and does not
receive the message
Host B
{Trusts
Host A}
Step 1.  Initiate Syn/Flood to
prevent Host A from Responding to
Host B
P
C
e   T
Attacker
e t e r m i n
e ri n
g
b
s t  B  t o   d
e   n
m
u
c
e
d
d
s  t o  t h
u l a t e
n
o
p
s
s
s t A ,
s t   B .
a lc
o
e   c
d  t h
e r r e
n
s   a
k
c
e   a tt a
d r e
d
s t B , t h
s t  B  i n   S t e
y   H
n t  b
o
p   4 ,
o
e   H
g  t o   b
n   W it h   H
s i o
s t  A ’s   a
e r  o f  H
K  s
C
b
o
o
e
g   H
u m
N / A
Y
S
o
e
n
e   H
u
q
p   2 .  P r o
b
e
s
S t e
n
p   3 .   P r e t e
P   s
C
d i n
s
e
i n iti a t e   a   T
S t e
S t e
e
P   s