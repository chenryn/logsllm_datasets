Summary 104
Chapter 5 Sandboxing 107
Understanding the Sandbox 108
Sandboxing Your Apps 109
Understanding the Sandbox Implementation 116
Understanding User Space Library Implementation 117
Into the Kernel 121
Implementing TrustedBSD 121
Handling Configuration from User Space 123
Policy Enforcement 125
How Profile Bytecode Works 126
How Sandboxing Impacts App Store versus
Platform Applications 133
Summary 137
Chapter 6 Fuzzing iOS Applications 139
How Fuzzing Works 139
The Recipe for Fuzzing 141
Mutation-Based (“Dumb”) Fuzzing 141
Generation-Based (“Smart”) Fuzzing 142
Submitting and Monitoring the Test Cases 143
Fuzzing Safari 144
Choosing an Interface 144
Generating Test Cases 144
Testing and Monitoring the Application 145
Adventures in PDF Fuzzing 148
Quick Look Fuzzing 153
Fuzzing with the Simulator 155
Fuzzing MobileSafari 158
Selecting the Interface to Fuzz 158
Generating the Test Case 158
Fuzzing and Monitoring MobileSafari 158
PPT Fuzzing Fun 160
SMS Fuzzing 162
SMS Basics 163
Focusing on the Protocol Data Unit Mode 165
Using PDUspy 167
Using User Data Header Information 167
Working with Concatenated Messages 168
Using Other Types of UDH Data 169
Generation-Based Fuzzing with Sulley 170
SMS iOS Injection 175
Monitoring SMS 177
SMS Bugs 182
Summary 184
ffttoocc..iinndddd xxii 44//44//22001122 1100::5511::4433 AAMM
xii Contents
Chapter 7 Exploitation 185
Exploiting Bug Classes 186
Object Lifetime Vulnerabilities 186
Understanding the iOS System Allocator 188
Regions 188
Allocation 189
Deallocation 189
Taming the iOS Allocator 190
Tools of the Trade 190
Learning Alloc/Dealloc Basics 191
Exploiting Arithmetic Vulnerabilities 195
Exploiting Object Lifetime Issues 198
Understanding TCMalloc 200
Large Object Allocation and Deallocation 201
Small Object Allocation 201
Small Object Deallocation 202
Taming TCMalloc 202
Obtaining a Predictable Heap Layout 202
Tools for Debugging Heap Manipulation Code 204
Exploiting Arithmetic Vulnerabilities with
TCMalloc – Heap Feng Shui 206
Exploiting Object Lifetime Issues with TCMalloc 211
ASLR Challenges 211
Case Study: Pwn2Own 2010 213
Testing Infrastructure 217
Summary 218
Chapter 8 Return-Oriented Programming 219
ARM Basics 220
iOS Calling Convention 220
System Calls Calling Convention 221
ROP Introduction 222
ROP and Heap Bugs 224
Manually Constructing a ROP Payload 225
Automating ROP Payload Construction 230
What Can You Do with ROP on iOS? 232
Testing ROP Payloads 232
Examples of ROP Shellcode on iOS 235
Exfi ltrate File Content Payload 235
Using ROP to Chain Two Exploits (JailBreakMe v3) 242
Summary 247
Chapter 9 Kernel Debugging and Exploitation 249
Kernel Structure 249
Kernel Debugging 250
Kernel Extensions and IOKit Drivers 256
Reversing the IOKit Driver Object Tree 257
ffttoocc..iinndddd xxiiii 44//44//22001122 1100::5511::4444 AAMM
Contents xiii
Finding Vulnerabilities in Kernel Extensions 261
Finding Vulnerabilities in IOKit Drivers 264
Attacking through Device Properties 265
Attacking through External Traps and Methods 266
Kernel Exploitation 269
Arbitrary Memory Overwrite 269
Patching a Vulnerability into the Kernel 270
Choosing a Target to Overwrite 271
Locating the System Call Table 272
Constructing the Exploit 273
Uninitialized Kernel Variables 274
Kernel Stack Buffer Overfl ows 279
Kernel Heap Buffer Overfl ows 285
Kernel Heap Zone Allocator 286
Kernel Heap Feng Shui 291
Detecting the State of the Kernel Heap 293
Exploiting the Kernel Heap Buffer Overflow 294
Summary 296
Chapter 10 Jailbreaking 297
Why Jailbreak? 298
Jailbreak Types 298
Jailbreak Persistence 299
Tethered Jailbreaks 299
Untethered Jailbreaks 299
Exploit Type 300
Bootrom Level 300
iBoot Level 300
Userland Level 301
Understanding the Jailbreaking Process 301
Exploiting the Bootrom 302
Booting the Ramdisk 303
Jailbreaking the Filesystem 303
Installing the Untethering Exploit 304
Installing the AFC2 Service 305
Installing Base Utilities 306
Application Stashing 307
Bundle Installation 307
Post-Installation Process 309
Executing Kernel Payloads and Patches 309
Kernel State Reparation 309
Privilege Escalation 310
Kernel Patching 312
security.mac.proc_enforce 312
cs_enforcement_disable (kernel) 313
cs_enforcement_disable (AMFI) 314
ffttoocc..iinndddd xxiiiiii 44//44//22001122 1100::5511::4444 AAMM
xiv Contents
PE_i_can_has_debugger 315
vm_map_enter 316
vm_map_protect 318
AMFI Binary Trust Cache 319
Task_for_pid 0 320
Sandbox Patches 322
Clearing the Caches 324
Clean Return 324
Summary 325
Chapter 11 Baseband Attacks 327
GSM Basics 329
Setting up OpenBTS 331
Hardware Required 331
OpenBTS Installation and Confi guration 332
Closed Configuration and Asterisk Dialing Rules 335
RTOSes Underneath the Stacks 335
Nucleus PLUS 336
ThreadX 337
REX/OKL4/Iguana 337
Heap Implementations 338
Dynamic Memory in Nucleus PLUS 338
Byte Pools in ThreadX 340
The Qualcomm Modem Heap 341
Vulnerability Analysis 342
Obtaining and Extracting Baseband Firmware 343
Loading Firmware Images into IDA Pro 344
Application/Baseband Processor Interface 345
Stack Traces and Baseband Core Dumps 345
Attack Surface 346
Static Analysis on Binary Code Like it’s 1999 347
Specifi cation-Guided Fuzz Testing 348
Exploiting the Baseband 348
A Local Stack Buffer Overfl ow: AT+XAPP 348
The ultrasn0w Unlock 350
An Overfl ow Exploitable 0ver the Air 356
Summary 362
Appendix References 365
Index 369
ffttoocc..iinndddd xxiivv 44//44//22001122 1100::5511::4444 AAMM
Introduction
Five years after its introduction, it is easy to forget exactly how revolutionary
the iPhone was. At that time, there were no smartphones as we know them
today. There were phones that made phone calls, and some phones that had
web browsers, but these browsers were not full featured. They could render
only the most basic of web pages and even then only at very low resolutions.
The iPhone changed the game.
Here was a device that was almost entirely screen, had a WebKit-based web
browser, and an operating system that you could upgrade yourself without
waiting for your carrier to do it for you. Combined with the capability to store
photos, play music, and send text messages, it was something people really
wanted to have (see Figure 1). At the same time, the iPhone wasn’t perfect. The
original iPhone had very slow data speeds, no support for third-party applica-
tions, and minimal security, but it was mostly responsible for the smartphone
and tablet revolution.
Since the original iPhone came out in 2007, a series of other Apple devices
have come along, all now running iOS. Of course back when the original iPhone
and some other devices came out, the operating system wasn’t called iOS. The
original iPhone was identifi ed by Apple as OS X, like its desktop brother, and
when the second iPhone came out in 2008 it was called iPhone OS. It couldn’t
be called iOS back then because IOS was what Cisco called its operating system,
which was designed for routers. Some money exchanged hands, and Apple
began calling its operating system iOS in 2010.
After the iPhone, the next iOS device was the iPod touch. This device was
basically an iPhone without the hardware to make phone calls or send text
messages. Other iOS devices include the second-generation Apple TV and the
iPad. Each newer version of these devices provided faster, sleeker products with
more features (see Figure 2).
xv
ffllaasstt..iinndddd xxvv 44//33//22001122 77::4477::5500 PPMM
xvi Introduction
Figure 1: A crowd of customers line up to buy the first iPhone.
Credit: Mark Kriegsman (www.flickr.com/photos/kriegsman/663122857/)
Figure 2: iPhone 4 vs. iPhone 1.
ffllaasstt..iinndddd xxvvii 44//1199//22001122 66::2222::3377 PPMM
Introduction xvii
Overview of the Book
However, while these devices were beautiful on the outside, there was little
known about how they worked on the inside. In particular, how secure were
these little devices that millions of people were carrying around fi lled with their
personal information? The information about how the security of iOS devices
operated was scattered in various talks given at security conferences, within
the jailbreak community, and in individual researchers’ personal journals. This
book is intended to bring all this knowledge about iOS internals to one central
location. Making this information accessible to everyone allows people and
enterprises to assess the risk of using these devices and how best to mitigate
this risk. It might even provide ideas on how to make the device safer and more
secure to use.
How This Book Is Organized
This book is split into functional subjects of iOS security. It can be read in a
couple of ways. For someone relatively new to the subject or for a reader who
doesn’t want to miss anything, it can be read from beginning to end. The book
is organized with the more basic and fundamental chapters at the beginning
and the more complex, esoteric chapters near the end. Alternatively, readers
who already have some knowledge of iOS internals can skip ahead and read
whatever chapters they fi nd interesting. Each chapter is mostly independent
of other chapters. When topics from other chapters come up, they are pointed
out for reference. The following is a list chapters and a brief description of the
contents of that chapter.
n Chapter 1 — The fi rst chapter contains an overview of iOS devices and the
iOS security architecture. It introduces most of the topics that are covered
in the rest of the book. It concludes by discussing some attacks that have
occurred against various versions of iOS, covering some of the earliest
attacks to those that have occurred against the security architecture in
place in iOS 5.
n Chapter 2 — This chapter covers the way iOS is used in the enterprise.
It addresses topics such as enterprise management and provisioning. It
also dives into how applications are developed for enterprise devices,
including how the developer certifi cates and provisioning profi les work.
n Chapter 3 — The third chapter contains information related to how iOS
handles encrypting sensitive data. It outlines how encryption keys are
derived for each iOS device as well as how they are used. It addresses
the different levels of encryption as well as which fi les fall under each.
It discusses how developers can use the Data Protection API to protect
ffllaasstt..iinndddd xxvviiii 44//33//22001122 77::4477::5555 PPMM
xviii Introduction
sensitive data in their apps. Finally, it demonstrates how it is possible to
break passcodes through brute force, and how ineffective numeric 4-digit
passcodes really are.
n Chapter 4 — This chapter dives into one of the primary security mechanisms
of iOS, code signing. It walks the reader through a tour of the relevant
source code and reverse engineered binaries responsible for ensuring
only code signed by a trusted party can run on the device. It highlights a
relatively new addition to iOS code signing that allows for unsigned code
to run in a very select, carefully controlled manner in order to allow just-
in-time-compiling. It concludes by describing a fl aw in the code-signing
mechanisms that was present for early version of iOS 5.
n Chapter 5 — This chapter moves into the mechanisms involved in sand-
boxing in iOS. It shows how the iOS kernel allows for hooks to be placed
at critical locations and discusses the hooks used specifi cally for sandbox-
ing. It then demonstrates how applications can do their own sandboxing
using examples and then how important iOS functions perform their
sandboxing. Finally, it discusses sandbox profi les, how they describe the
functions allowed by the sandbox, and how to extract them from iOS
binaries for examination.
n Chapter 6 — This chapter shows how to fi nd vulnerabilities in default iOS
applications using the technique known as fuzzing. It starts by a general
discussion of fuzzing followed by demonstrating how to fuzz the biggest
attack surface in iOS, MobileSafari. It highlights the different ways iOS
fuzzing can be performed including fuzzing in OS X, in the iOS simulator,
and on the device itself. It concludes by showing how to fuzz something
you won’t fi nd on a desktop computer, the SMS parser.
n Chapter 7 — This chapter shows how to take the vulnerabilities found
using the techniques of Chapter 6 and turn them into functioning exploits.
It includes a detailed look into the iOS heap management system and how
an exploit writer can manipulate it using the method of heap feng shui. It
then discusses one of the major obstacles of exploit development: address
space layout randomization (ASLR).
n Chapter 8 — This chapter takes it one step further and shows what you
can do once you get control of a process. After a quick introduction