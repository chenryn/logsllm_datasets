bootstrapped. This ensures that the calling processes com-
municate directly with the kernel module through our generic
API and that the kernel module can be called independently
of middleware services.
Life-cycle management. Every module must implement
functions for life-cycle management, such as initialization
or shutdown. This enables the framework to inform the
module when the system has reached a state during the boot
cycle from which on the module will be called or when the
system shuts down. Modules should use these functions, e.g.,
to initiate their policy engines or to save internal states to
persistent storage before the device turns oﬀ.
Event notiﬁcations. Event notiﬁcation interfaces are
used to propagate important system events to the module.
For instance, modules should be immediately informed when
an app was successfully installed, replaced, or removed. Al-
though this information is usually propagated via a broadcast
Intents, the time gap between package change and broadcast
delivery might cause inconsistencies in module states. Hence
these events must be delivered synchronously.
Framework Callbacks. The framework provides mod-
ules a callback interface for communicating in a more di-
rect manner with system services, such as the PackageMan-
agerService, and avoids the need to go through the Android
API. This is desirable for policy authors that want to leverage
the middleware internal information. Our current callback
interface, for instance, includes functions that allow modules
to eﬃciently resolve PIDs to application package names.
Proprietary protocols. We introduced in our frame-
work API a callModule() function that allows modules to
implement proprietary communication protocols with other
apps that are aware of this speciﬁc module, e.g., the front-
end apps (cf. Section 5.1). When using callModule(), these
protocols are based on Bundles and enable a protocol similar
to the Parcel-based Binder IPC: apps serialize function argu-
ments to a Bundle and add an identiﬁer for the proprietary
function the module should execute with the deserialized
arguments. It is the task of the module to verify that the
sender is suﬃciently privileged to send commands.
IRM Instrumentation. The framework provides an
instrumentation API that enables security modules to hook
any Java function within selected app processes. To the best
of our knowledge, ASF is the ﬁrst solution for Android to
provide a generic instrumentation API. Hooks injected via
the instrumentation API are local to the app process that the
API is called from. Therefore, all calls to the instrumentation
API need to be performed from within a target app’s process.
We solve this by placing an instrumentation hook in the
ActivityManagerService that is triggered when a new app
process is about to be launched. A module that implements
this hook has to return a Java class for the instrumentation
logic that will be executed within the app’s process. To
ensure that this code is executed before control ﬂow is passed
to the app itself, we modify the arguments passed to Zygote
to start this new app process via a special wrapper class that
loads and executes the instrumentation code ﬁrst.
5.4 Middleware Security Modules
We elaborate in more detail on the structure of security
modules. Again, we use Linux security modules as is [25]
Figure 3: Middleware security module structure.
and, thus, focus here on the Middleware Sub-Module. A
middleware module is simply a Jar ﬁle that is created with
an Android SDK that includes our new security API. It is
deployed to a protected location on the ﬁle system, from
where it is loaded during boot. This Jar ﬁle contains all the
module’s code, resources, and manifest ﬁle (cf. Figure 3):
Module Manifest. The manifest (formatted in XML)
declares properties such as the module author or code version,
and, more importantly, the name of the main Java class that
forms the entry point for the module.
Classes.dex. The classes.dex ﬁle contains, as in regular
Android apps, the Java code compiled to Dalvik executable
bytecode (DEX). It contains all Java classes that implement
the security module’s logic. During the load process of the
Middleware Sub-Module, the middleware framework uses
the Java reﬂection API to load the module’s main class
(as speciﬁed in the manifest) from classes.dex. To ensure
that the reﬂection works error-free, the main class must
implement the API as described in Section 5.3. Since the
API deﬁnes currently more than a hundred methods, but a
security module very likely requires only a subset of those,
our SDK provides an abstract class that implements the
API. That abstract class can be sub-classed by the module’s
main class, which then only needs to override the required
functions. The abstract class returns for each non-overridden
enforcement function an allow decision.
LSM interface. The proprietary interface between the
user-space processes and the Linux security module in the
kernel is implemented through a native library liblsm.so and
a corresponding Java class LSM.java, which exposes the na-
tive library via the Java Native Interface. LSM.java has
to implement the generic interface for the communication
with the kernel that was explained in the previous section.
The generic kernel module interface of ASF loads LSM.java
through the Java reﬂection API into Android’s application
framework. This allows apps and services to communicate
with the kernel module and avoids a policy-speciﬁc inter-
face. We exempliﬁed this mechanism by integrating SELinux
through API into Zygote (cf. Section 6.2).
Resources. Each module can ship with proprietary re-
sources, such as initial conﬁguration ﬁles or required binaries.
During module instantiation, the framework informs the
module about the ﬁlesystem location of its Jar ﬁle, enabling
the module to extract these resources on-demand from it.
5.5 Stackable and Dynamic Loadable Modules
Finally, two desirable properties for implementing an ex-
tensible security framework such as our ASF are dynamically
loadable policies and policy composition (i.e., stacking mod-
ules). In the following we explain why we chose, in contrast to
closest related work [20], to permit these features by design,
but not consider them a requirement for our solution.
Dynamically Loadable Modules. Being able to dy-
namically load and unload modules is desirable, for instance,
to speed up the development and testing cycles of modules
and, in fact, we used this feature during the development
of our example use-cases (cf. Section 6). However, the ar-
Middleware Sub-Modulemanifest.xmlclasses.dexLSM.java / liblsm.soResourcesguments to support dynamically loadable modules beyond
development (e.g., for security add-ons [20]) are disputed:
First, dynamic loading is not always technically possible.
A small set of static policy models, such as type enforce-
ment [36, 8], require that all subjects and objects are labeled
with a security context. Supporting such extensive labeling
operations at runtime is an intricate problem. Second, there
exist security considerations. The loading and unloading
of modules must be strictly controlled to ensure that only
integrity protected, trusted modules are loaded. Otherwise,
given the privileges of modules, this would open the way to
powerful malware modules. In our design we agree with the
conclusions of the various Linux security module authors [11]
and consider the drawbacks of dynamically loadable modules
to outweigh their beneﬁts. Therefore, we load the module
once during the system boot and permit users of our frame-
work to additionally activate dynamic unloading and loading
of modules. But we currently do not consider this feature a
requirement for our solution.
Stackable Modules. Composing the overall policy from
multiple, simultaneously loaded and independent policies is a
desirable feature, since usually no “one-size-ﬁts-all” policy ex-
ists. Android, for instance, implements currently a quadruple-
policy approach consisting of Permissions, SE Android type
enforcement, AppOps, and Linux capabilities—each being
responsible for a diﬀerent aspect of the overall access control
strategy. Multiple policies will naturally conﬂict and thus
require the security framework to support diﬀerent policy
composition and reconciliation strategies (e.g., consensus or
priority based) [32, 27]. However, supporting fully generic
policy composition is quite a challenge and has been shown to
be intractable [18]. Thus, despite its beneﬁts, we decided in
our design to follow the lessons learned by the LSM develop-
ers [40] and to only permit module developers to implement
stackable modules, but we do not provide explicit interfaces
for stacked modules in our framework infrastructure.
In
module combinations where policy consolidation is known
to be feasible, the approach to stacking modules would be
to provide a “composition module” that implements policy
reconciliation and composition logic and which in turn can
load other modules and multiplex API calls between them.
6. EXAMPLE SECURITY MODULES
In this section, we demonstrate the eﬃciency and eﬀec-
tiveness of our Android Security Framework by instan-
tiating diﬀerent security models from related work. To il-
lustrate the versatility of ASF, we chose models from the
areas of inlined reference monitoring, Android’s default secu-
rity architecture, and type enforcement. We present further
instantiations of other security models in our long version [2].
6.1 AppOps and IntentFirewall
Google introduced (unoﬃcially) with Android v4.3 the
AppOps infrastructure for dynamic, more ﬁne-grained Per-
missions. It added hooks in diﬀerent system services and
apps, which query a central AppOpsService whether an ap-
plication is allowed to perform an operation (e.g., retrieving
the location of the device or querying a ContentProvider).
The AppOps rules deﬁne a mapping from UID/package name
to allowed operations. AppOps oﬀers an interface to apps
to retrieve the current conﬁguration. Additionally, Google
introduced (again unoﬃcially) an IntentFirewall, which acts
as a reference monitor for certain Intent-based operations
Figure 4: AppOps and IntentFirewall module
like starting an Activity. The IntentFirewall rules describe
which caller is allowed to receive which kind of Intent object,
using the Intent’s attributes such as destination component.
Implementation as a module: We ported AppOps and
IntentFirewall (from Android v4.3) to a security module for
ASF (cf. Figure 4) by moving the AppOpsService and the
IntentFirewall classes into a module. Our module comprises
2290 lines of code and diﬀers in 33.71% of all LoC from the
original implementation. The bulk of the changes (520 LoC),
were required to move the hook logic of both services from
the system apps and services of Android into the module by
using our enforcement functions. For the IntentFirewall, this
was straightforward and we only had to substitute a direct
callback from IntentFirewall to the ActivityManagerService
by our framework callback mechanism. For the AppOpsSer-
vice, we had to add a mapping from caller PID to package
name. By default the hooks of AppOps determine the caller’s
package name and pass this information to the AppOpsSer-
vice for policy check. Since this is a policy-speciﬁc logic of
the hooks, our framework hooks do not (by default) provide
the caller’s package name and we re-implemented this logic
in our module by using our callback interface, which allows
us to retrieve the package name for app PIDs. Moreover, we
adapted the AppOpsService interface to retrieve/conﬁgure
the current policies via a Bundle-based communication. App-
Ops is, furthermore, partially integrated into the Settings
application to allow users to disable notiﬁcations from se-
lected apps. We replaced this policy-speciﬁc channel between
Settings and AppOps also with our policy-agnostic Bundle-
based communication. Modules that support this Settings
option, can return a value indicating whether notiﬁcations
are disabled or not. If the module does not support this
feature, Settings app by default allows notiﬁcations.
6.2 Type Enforcement [36, 8]
SE Android [36] brought SELinux type enforcement to
the Android kernel and established the required user space
support, e.g., it extended Zygote to label new app processes
with a security type. FlaskDroid [8], developed for Android
v4.0.3, extends SE Android’s type enforcement to Android’s
middleware. Building on SEAndroid’s kernel and low-level
patches, it adds policy-speciﬁc hooks as policy enforcement
points to various system services and apps in Android’s
middleware. The policy decisions at kernel level are made by
the SELinux kernel module, while the decisions at middleware
are made centrally in a policy server service. Both policy
decision points decide based on subject type, object type,
and object class reported by the hooks at their respective
layer whether control ﬂows should be truncated or not.
Implementation as module: We realized type enforce-
ment with our ASF by porting FlaskDroid1 as a module
(cf. Figure 5), in this context porting the currently hard-
1Source code retrieved from http://www.flaskdroid.org/
Middleware FrameworkAppOps ModuleAppOpsServiceIntentFirewallSettings AppcallModule(Bundle args)MiddlewareAPIExisting solution
AppGuard [3]
AppOps / Intent Firewall
FlaskDroid [8]
LoC of module policy engine
5059
2290
4968
LoC added/removed/edited (total delta)
+828/-79/○ 13 (18.18%)
+627/-106/○ 39 (33.71%)
+749/-32/○ 40 (16.53%)
Table 1: Eﬀort of porting diﬀerent security extensions as module on our Android Security Framework.
Figure 5: FlaskDroid module
coded SELinux support of Android’s middleware into an
ASF module. At kernel level, we use the SE Android kernel
and provide an SELinux-speciﬁc interface implementation
for the kernel module. Further, we moved the middleware
policy server and its dependencies into the middleware mod-
ule. Using the enforcement functions of our API, we moved
the policy-speciﬁc hook logic of FlaskDroid into the module
as well. Additionally, we used SE Android’s build system to
label the ﬁle-system with security types.
Our port of FlaskDroid’s middleware component as a
security module consists of 4968 LoC (cf. Table 1) and diﬀers
in only 16.53% of all LoC from the original code. The bulk
of these changes (550 LoC) is attributed to additions for
implementing a mapping from the enforcement functions of
our framework API to FlaskDroid’s type checks. To conﬁrm
the correct enforcement of policies, we used the policies
for middleware and kernel level that are provided with the
FlaskDroid source code. Additionally, we noticed during our
tests that the original implementation contains an error in
assigning middlware security types to processes. Additional
changes were necessary to ﬁx this error in our module.
6.3
Inlined Reference Monitoring [3]
We use AppGuard [3] as the use-case to illustrate the
applicability of our IRM instrumentation API, but similar
application rewriting approaches [21] are also feasible. App-
Guard is a privacy app for Android that enables end-users to
enforce ﬁne-grained access control policies on 3rd party apps
by restricting their ability to access critical system resources.
By injecting an IRM into apps, this approach supports se-
curity policies not easily enforceable by traditional external
reference monitors in the Android middleware or kernel, e.g.,
to enforce the use of https over http.
Implementation as a module: We ported AppGuard2
as a module for ASF by separating its privacy app into
three components: We adapted the (1) AppGuard reference
monitor with its dynamic hook placement and policy en-
forcement logic to use our IRM instrumentation API. The