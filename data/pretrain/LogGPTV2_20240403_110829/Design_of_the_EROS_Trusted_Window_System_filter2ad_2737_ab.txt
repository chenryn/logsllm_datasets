tion that might be blocked pending the completion
of some other request. An acceptable exception to
this rule is requests that explicitly request to block.
As discussed by Mercer [18], blocking or queueing
requests results in priority inversion, which in turn
creates a covert signalling opportunity.
2. Requests must be low latency.
Requests executed by the server run under a differ-
ent schedule than that of their client. Their latency
therefore can be seen as a source of variance in real-
time context switch latency. Given the design of the
EWS display server, it is more effective to establish
a small upper bound on request latency than to at-
tempt priority queueing solutions that might require
a operating system support for multilevel schedul-
ing.
3. Requests should not incur large variance in process-
ing latency. Variance of this form can be exploited
for both resource denial of service and covert sig-
nalling.
In the EWS design, the hardware frame buffer and hard-
ware input devices are “owned” by the display server pro-
cess (Figure 2). Each input device has an associated pro-
cess that blocks on that device waiting for a hardware-
level input event to occur. This event is reprocessed into
canonical form by the helper process, and the helper pro-
cess then invokes the display server to “post” the event
using a synchronous RPC operation. From the display
server perspective, all interactions arrive as remote pro-
cedure calls from some process. Requests from device
helpers and requests from generic clients arrive on distin-
guishable interfaces by virtue of the fact that the associ-
ated RPC invocations are performed on distinct capabili-
ties.
In contrast to many other display servers, incoming re-
quests are generally not queued by the display server.
Each is processed immediately and enqueued on the out-
bound event queue of the receiving client. In the case of
mouse events, the events are delivered to the client ses-
sion owning the window in which the event occurred. A
MouseDown event causes all subsequent mouse events
until the corresponding MouseUp to be delivered to the
window in which the MouseDown occurred (but see the
discussion of “drag and drop” in Section 6). In-order pro-
While the display server does not enqueue requests in gen-
eral, it does perform queueing in connection with client-
requested rendevous and client event delivery. When a
client issues a WaitMouseEvent request, the server checks
the per-client-session list of undelivered events (which is
bounded). If one exists, it is returned, otherwise the client
request is queued. EROS provides an operation, RETRY,
that allows the server to redirect the client to a kernel stall
queue whose wakeup is controlled by the display server.
At a later time, the desired input event will cause this
client to be awakened, whereupon it will reissue its re-
quest.
The difference between RETRY-based queueing and
application-level queueing is subtle but signiﬁcant. Be-
cause clients queued using RETRY are blocked on a ker-
nel queue, their reactivation honors the scheduling policy
of the operating system. Application level queue imple-
mentations, including the request dispatch queue of X11,
generally do not have access to OS-level priority informa-
tion. Even if they did, dynamic adjustments to priority
cannot safely be revealed to such applications.1 EROS di-
rectly exposes the operating system queueing mechanism
1 Revealing dynamic reprioritization supports efﬁcient covert channel
construction.
Session [parent]
Window
SessionCreator
Session [child]
Figure 3: Nested Sessions
via a capability-protected interface and provides opera-
tions that allow the display server to exploit it for queue-
ing purposes.
4 Sessions
Sessions serve both as the means by which windows are
created and as the unit of containment for mandatory ac-
cess controls. Sessions are hierarchical. A top-level appli-
cation running within one session can implement its own
mandatory control policy within that particular session if
desired. From a security standpoint, this is primarily use-
ful for debugging, but it also supports separation of con-
cerns. While the manager can ensure that the communi-
cation activity of a subordinate application across session
boundaries is restricted, the manager is not able to observe
the internal events and actions of that application.
4.1 The Session/Window Hierarchy
EWS associates each window with a unique client ses-
sion. Every EWS window is created by performing a
CreateWindow operation on some Session capability.
Every session has an associated containing window, and
the windows created using that Session capability are
created as child windows of the session’s parent window.
Client sessions are hierarchical: having created a window
W , the holder of a Session capability can create a new
SessionCreator capability whose parent window is
W . This new SessionCreator can be provided to
newly instantiated applications, and effectively deﬁnes the
context of the root window with respect to that applica-
tion. The SessionCreator can be used by the sub-
ortinate application to create new Session capabilities
(Figure 3).
Operations in one session are not observable by other ses-
sions – not even by parent sessions. Input events are de-
livered to the owning session of the window in which they
occur. The hierarchical session mechanism allows us to
construct graphical shells that appear to contain their ap-
plications. Interactions with these client applications are
not be observable by the shell.
The intermediate SessionCreator provides a mecha-
nism for validating isolation. The receiving client is able
to perform a test on the SessionCreator capability
verifying that it is really a capability to the display server.
The client is then assured that sessions created using this
SessionCreator are exclusively held by the client,
and cannot be spied on by the owner of the parent window.
Similarly, since the parent window owner never possesses
the Session capability, the parent cannot create windows
that might attempt to deceive input processing directed to
the client. As seen by the user, the resulting window struc-
ture appears entirely normal (Figure 4).2
4.2 Mandatory Controls
While EWS does not currently implement mandatory ac-
cess control, the session system has been designed with
mandatory controls in mind. The unit of mandatory con-
trol labeling is the session. Communication operations be-
tween two windows are permitted only if a label-checking
predicate indicates that the communication is permitted.
At present, we have implemente only the trivial predicate
that returns true in response to all requests. This amounts
to an entirely discretionary control policy.
However, the access predicate function need not be im-
plemented in the window server. If provided by a trusted
source – either at startup or statically at system design
time – an independent process can implement the manda-
tory control predicate. This allows the same mandatory
control agent to be used by many subsystems, and iso-
lates the two implementations for assurance purposes. It
also permits different subsystems to implement different
mandatory access control policies within their respective
compartments. Our intended usage model is that the top-
level “shell” is a trusted agent (it must be, since it is part
of the trusted path), and this shell is therefore permitted to
specify a mandatory control agent and a label when cre-
ating application sessions. The EROS IPC mechanism is
fast enough to make such an external access control agent
practical.
Because EROS is persistent, there is no need to reestablish
these session relationships each time the user logs in. In-
stead, each user account executes an independent copy of
2 We have not yet determined how best to display multilevel labeling.
Any labels of this sort would certainly depart from current user ex-
pectations.
EWS uses shared memory mappings between client and
server to represent window state. When a client wishes to
create a window, it supplies to the display server a read-
only shared memory region containing a bitmap. The dis-
play server maps this shared region, and subsequently per-
forms bitblt operations to transfer portions of the bitmap
to the physical display. The client renders directly into
the bitmap, and advises the server when changes have
occurred by issueing an UpdateRectangle request to the
server. Note that this reverses the ﬂow of traditional up-
date notiﬁcation, and eliminates the channel associated
with X11 update notices.
It also permits the server to
redraw the frame buffer at login time without communi-
cating to the clients. The resulting design is conceptually
similar to the Apple Quartz architecture [3], and can be
extended to encompass the high performance 3D pipeline
features of Quartz Extreme. A side beneﬁt of client-side
rendering is that the server is no longer responsible for
font handling. The EWS display server contains a single,
compiled-in font that is used for title bars. This allows us
to use bitblt for window titles without incorporating the
complexity of a complete font rendering system into the
server.
Given the underlying EROS primitives, it is possible for
the client to rescind the shared memory region without
notice to the display server. This may occur out of mal-
ice or because the client’s storage is revoked for reasons
beyond its immediate control. The display server bitblt
routine is the only routine in the display server that reads
the client memory region. It is wrapped by an exception
handling catch block. In the event of an invalid memory
reference, the display server assumes that the client has
reneged on its entire interaction contract and rescinds that
client session.
Note that the shared mapping contract ensures that a given
client can detect at most one bitblt operation performed
by the display server, and only by using a mechanism that
causes the client session to be severed.
5.1 Invisible Windows
To support isolation in nested client sessions, EWS pro-
vides restricted support for invisible windows. An invisi-
ble window has no backing bitmap, and is not a candidate
for input events. In order to receive input, a window must
be visible. The role of an invisible window is to provide
a coordinate space that contains a subordinate client ses-
sion.
We note that restricting invisible windows does not en-
tirely resolve problems of event hijacking. Pragmatically,
Figure 4: Windows in Multiple Sessions.
the entire window system. At login time, the login agent
connects the per-user window system to the frame buffer
and hardware input devices. On logout, these connections
are severed.
5 Rendering
In order to reduce the complexity of the server, EWS im-
plements drawing operations in the client rather than the
server. This is also motivated by issues of variance. In
the presence of clipping, operations such as DrawPoly-
gon may involve several orders of magnitude more pro-
cessing than line drawing. Further, in the absence of
“backing store,” server-side drawing necessitates that up-
date notices be sent from the display to the client when
portions of its windows are revealed. It is usually more
space-efﬁcient to have the application redraw than to save
the bits, and memory was precious on early workstations.
One hazard of this design is that a client can manipulate
the visibility of its windows so as to exploit expose events
as a signalling channel. A second hazard is that delivering
these expose events imposes signiﬁcant execution costs on
the display server.
To simplify the server, we initially considered restricting
the client to constructing complex structures using suc-
cessive DrawTriangle commands following the logic of
OpenGL [28], but abandoned this approach when a faster
and simpler method became apparent: shared memory.
there is no difference in appearance between an invisi-
ble window and a borderless visible window all of whose
pixels have fully or nearly transparent alpha values. At
present, EWS does not support borderless top-level win-
dows. This mitigates, but does not eliminate, the problem
of alpha transparency.
6 Interprocess Communication
Conventional window systems handle cut and paste in-
teractions using a broadcast communication mechanism.
When a user performs a “cut” operation, the application
performing the cut claims ownership of the cut buffer by
sending a message to the display server. The server re-
transmits this notiﬁcation to all clients who have regis-
tered an interest in clipboard notiﬁcations. This approach,
and the security issues that arise from it, are well docu-
mented [20].
In EWS, no events are transmitted to the
destination until the user performs a “paste” action, and
then only if the communication is permitted by applicable
mandatory access controls.
Tying the server paste logic back to a clearly identiﬁable
user action is necessary to limit certain types of covert
communication.
In the absence of a traceable user ac-
tion, any client could claim that a paste had occurred at
any time. Cut actions are similarly hazardous, because
a hostile client could interfere with permitted communi-
cation by falsifying cut events. Collectively, these con-
cerns motivate a desire to make “paste” into a traceable
atomic action. For keyboard-initiated cut or paste (e.g.
Control-V), traceability is not a signiﬁcant challenge. The
server maintains a key table indicating which well-known
keystrokes authorize cut and paste actions. The drag and
drop protocol similarly has clearly identiﬁable interaction
events.
Mouse-initiated cut and paste operations are trickier, be-
cause there is no simple way to relate mouse actions to
application claims that a cut or paste has been performed.
We considered moving menu management into the dis-
play server, but felt that this would both complicate the
display server and unnecessarily restrict application de-
signers. Further, it would require signiﬁcant changes in
existing graphical toolkits and would therefore present an
impediment to portability.
6.1 Traceable Cut and Paste
EWS resolves these problems by introducing a new type
of invisible window. We require that the visible regions
conveying cut and paste authority be identiﬁed by the ap-
plication. The cut and paste windows accept no events,
but clicks “passing through” these windows result in clip-
board authorization. For each of these special windows
there is a distinguished standard (server deﬁned) cursor
used to indicate when the mouse is above these regions.
When a MouseUp event occurs within one of these spe-
cial windows, the display server knows that an authorizing
user action has occurred. To ensure positive user feed-
back, the server will not perform a cut or paste operation
unless the distinguished cursor has been visible for a min-
imum amount of time. This prevents unintended cut or
paste actions that might result from randomized modiﬁca-
tions of the window positions, but allows the application
to simulate multiple active regions by relocating the active
region to fall under the mouse as the mouse moves.
Note that both the “cut” and the “paste” operation require
tracing. The user must know both where the data is com-
ing from and where the data is going to. The EWS display
server keeps a record of which windows own the cut and
paste contexts at any given time.
6.2 Drag and Drop
In general, the EWS design avoids situations where one
client gets notiﬁed of interaction sequences associated
with another. This was the motivation for directing mouse
sequences beginning with a MouseDown and ending with
a MouseUp to the MouseDown window.
There is one widely accepted user idiom that conﬂicts
with this handling of mouse events: drag and drop. We
have resolved this by providing direct support in the dis-
play server. At any time after receiving a MouseDown
followed by a MouseMove, the origin client window can