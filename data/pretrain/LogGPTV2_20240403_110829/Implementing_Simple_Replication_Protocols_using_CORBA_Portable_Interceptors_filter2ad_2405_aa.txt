title:Implementing Simple Replication Protocols using CORBA Portable Interceptors
and Java Serialization
author:Mohamed Taha Bennani and
Laurent Blain and
Ludovic Courtès and
Jean-Charles Fabre and
Marc-Olivier Killijian and
Eric Marsden and
François Ta&quot;ıani
Implementing Simple Replication Protocols using
CORBA Portable Interceptors and Java Serialization
Taha Bennani, Laurent Blain, Ludovic Courtes, Jean-Charles Fabre,
Marc-Olivier Killijian, Eric Marsden, François Taïani
LAAS-CNRS, 7, Avenue du Colonel Roche, 31077 Toulouse cedex 4 – France
Abstract
The goal of this paper is to assess the value of simple
features that are widely available in off-the-shelf CORBA
and Java platforms for the implementation of fault-
tolerance mechanisms in industry-grade systems. This
work builds on knowledge gained at LAAS from previous
work on the prototyping of reflective fault
tolerant
frameworks. We describe how we used the interception
and state capture mechanisms that are available in
CORBA and Java to implement a simple replication
strategy on a small middleware-based system built upon
GNU/Linux and JOrbacus. We discuss the benefits and
the limits of the resulting system from a practical point of
view.
1. Introduction
fault
the implementation of
The objective of this practical experience report is to
illustrate the extent
to which basic mechanisms like
CORBA Portable Interceptors and Java Serialization can
be used to implement simple replication protocols. The
portable interceptor mechanism introduced by recent
versions of the CORBA standard [1] offers a powerful
means to intercept interactions in a distributed system,
while Java’s serialization mechanisms [2] provide a
transparent and portable state capture facility. From a
practitioner’s point of view, however, the interest of these
features for
tolerance
mechanisms remains to be assessed. We should emphasize
that the objective of this paper is not to present a full-
fledged framework for distributed fault-tolerance. Many
works with industrial relevance already provide such
frameworks,
in particular the Fault-Tolerant CORBA
standard [3], and corresponding implementations such as
IRL [4] and Eternal [5]. Other existing approaches use
portable interceptors, such as the FTS [6] project., but
require the use of a non-standard object adapter to
implement the group communication routines, resulting in
heavyweight modifications of the underlying ORB. Our
primary goal is to investigate lightweight implementation
approaches based on standard off-the-shelf platforms and
to evaluate how far this line of attack can be pushed. I n
this paper, we investigate this question by reporting on
experiments performed on a prototype platform called
DAISY (Dependable Adaptive
Interceptors and
Serialization-based sYstem) that uses these technologies.
DAISY is based on our yearlong experience in the design
and validation of fault tolerant reflective platforms and
takes into account
the lessons learned from their
implementation [7].
The paper is organized as follows: In Section 2 we present
our motivations in this work and the basic elements of our
middleware-based platform. In Section 3 we describe how
portable interceptors were used to develop a simple
replication strategy. In Section 4 we discuss the benefits
and the limits of the current version of these basic off-the-
shelf mechanisms.
2. Motivations and platform
A computer system is said to be reflective if it can observe
and modify itself as part of its own computation [8]. The
use of reflection introduces a clean separation in a
system’s structure between what is called the base level,
where normal computation occurs, and the meta-level,
where computation about the system takes place. The
interactions between levels are categorized as reification
(when the meta-level is notified of a change occurring at
the base level), introspection (when the meta-level
observes the base level), and intercession (when the meta-
level modifies the structure or the behavior of the base
level).
These mechanisms are useful for separation of concerns
and have made reflective architectures particularly
attractive to implement non-functional mechanisms such
as fault tolerance and security in more transparent and
more adaptable ways. In the last decade, several projects
have investigated this issue (Maud [9], Garf [10], Friends
[7]). The Friends system for instance is a CORBA-
compliant reflective fault-tolerant platform, based on a
Meta Object Protocol that is built using open compilation
facilities [11]. Today, limited reflection capabilities have
made their way into some of
the most popular
development platforms, such as CORBA and Java. This
evolution highlights the increasing attractiveness of
reflection for
to dynamically adapt non-
functional requirements. To investigate the benefits and
limitations of these standard reflective facilities, we
describe here how passive replication of CORBA objects
industry,
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:07 UTC from IEEE Xplore.  Restrictions apply. 
can be implemented. This platform is currently being used
to develop other
replication strategies and more
importantly to implement reflection at various levels, both
at the middleware and the operating system levels, using
the concept of multi-layer reflection we presented at DSN
2003 [12].
client
PIC
GUI
JOrbacus
JVM
API/libc
Linux kernel
Power PC
PIS
server
Primary/backup
JOrbacus
JVM
API/libc
Linux kernel
Pentium II
Figure 1. Middleware-based platform
Our prototype platform (see Figure 1) is organized in a
layered architecture that integrates the middleware layers
ORBacus (JORBacus v4.1.2), and Sun’s Java v1.4.1, on
top of the GNU/Linux operating system (Linux 2.4 for
x86).
3. Implementation
the transfer of
Our implementation of the passive replication mechanism
combines Portable Interceptors, to synchronize remote
clients and the different server replicas, and the Java
Serialization mechanisms to obtain the internal state of
application objects.
We use two kinds of Portable Interceptors, according
whether they handle the client or the server side of the
interaction (Figure 2). On the client side, the PIClient
intercepts the outgoing requests issued by clients and
forwards them to the current primary replica. On the
server side, the PIServer has two running modes: primary
and backup. The PIServer handles the processing of
requests,
reply and state
information from the primary to the backup during fault-
free phases, and ensures smooth reconfiguration when one
of the replicas crashes. The PIServer of the primary
delivers requests to the backup replica. We do not assume
the availability of atomic multicast services.
The PIClient and PIServer work together to detect the
crash of the Primary server and switch from the primary to
the backup server. As crash detection is not the primary
focus of this paper, we choose to use a simple client-side
detection scheme that relies on the error detection
mechanisms of the underlying ORB. Clients first discover
crashes when the ORB raises an exception concerning the
connection with the primary. After retrying the request a
given number of times, a client
issues its following
requests to the backup replica. When the backup receives
request,
a request from a client, its PIServer checks that the
primary is down by sending a ping request to the primary,
then switches to primary mode. Duplicated requests on the
server side are discarded using a system-wide unique ID.
Remote requests through
banking system GUI
client
ORB
Optional JVM
IIOP requests
PIS
PIC
Checkpoints
Primary
server
Performs
Requested
Actions
ORB
Serialization Java
PIS
Handles
checkpoints
Backup
server
ORB
Serialization Java
Figure 2. Architecture with PIClient & PIServer for
primary-backup replication
Using these Portable Interceptors we can observe the
ongoing requests between clients and the server, and
trigger the different stages of the replication protocol
accordingly. However, except for a number of exception-
raising or
-resignaling techniques described below,
CORBA’s portable interceptors do not allow requests or
replies to be modified. In addition, a portable interceptor
inherits its concurrency model from the server that it is
attached to. Depending on this concurrency model,
requests can be served either sequentially or in parallel;
this is completely beyond the control of the PIs.
In this context,
the only possibilities for controlling
request handling from within a portable interceptor are
either to suspend the current thread, thus blocking the
request, or to throw an exception to prevent the request
from being processed. A portable interceptor can intercept
the sending and the receiving of a request, the reception of
a reply, and the reception of CORBA exceptions. This last
feature can be used to “transform” a CORBA exception,
by propagating a different exception from the intercepted
one (we use this technique, as we shall see).
3.1. Overview of the implementation
The behavior of the client’s interceptor (PIClient) is
shown by the pseudo-code below. The PIClient comprises
three entry points: the send_request method is called
by the ORB before an outgoing request is sent to the
transport layer; the receive_reply method is called
before an incoming request is handed to the application;
and the receive_exception method is called by the
ORB before a CORBA exception is delivered to the
application level.
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:07 UTC from IEEE Xplore.  Restrictions apply. 
Constructor:
the
obtain
backup
references through the name server,
determine the client unique ID
primary
and
send_request:
add the request unique ID for the
client
client
unique ID + request number)
request
the
to
(=
receive_reply:
increment request counter
receive_exception:
issue ForwardRequest exceptions to
the primary (twice), then the backup
the client
The core of the client-side interceptor’s role takes place in
the receive_exception method when the ORB
signals that a transient communications error has affected
a message sent to the server. A ForwardRequest is a
special kind of exception that a CORBA server can raise
to redirect a client to a different server. When it detects a
communication error,
interceptor raises a
ForwardRequest exception to tell the client to reissue
its request (this is a case of exception transformation, as
mentioned earlier). After two consecutive errors from the
primary, the client interceptor assumes that the primary
has failed and redirects further requests to the backup,
thus triggering a primary-backup switch.
On the server side, the primary and backup replicas each
contain a PIServer working in two different modes,
respectively primary and backup mode:
1.
state
In primary mode, the PIServer relays requests to the
primary server for processing, fetches the server’s
internal
after processing (using Java
serialization), and sends a checkpoint to the backup
replica. The checkpoint
includes the ID of the
corresponding request, the state information and a
copy of the reply message, if any.
In backup mode, the PIServer receives checkpoints
and uses them to update the state of the server replica
using Java serialization. When the backup receives a
primary failure notification, it switches to “primary
mode” and starts processing requests. The unique
request identifier included in both the requests and the
checkpoints is used to avoid processing the same
request twice when the backup switches to primary
mode.
2.
For clarity, we first show the pseudo-code for a scenario
with a single client
in the system. The interceptor’s
receive_request method is invoked by the ORB
before a request is transferred to the server object, and the
send_reply method is called before a reply is passed to
the transport layer. The modifications necessary in the
multi-client case are discussed later.
Constructor:
if (primaryRole)
obtain the reference of the backup
Determine server unique ID
receive_request:
if (primaryRole)
if first activation of PIServer
obtain the reference of
the Primary Server
/** will be used to issue direct
requests to the primary, like
getState for instance **/
else   /** backup role **/
if first activation of PIServer
obtain the references of the Primary
and the Backup Servers
if current request is 'set_state'
/** fault-free behavior **/
Backup.set_state(bufferedState)
bufferedState     := primaryState
bufferedRequestID := requestID
else  /** primary has crashed **/
primaryRole := true  ;
if (requestID==bufferedRequestID)
/** re-execution to produce reply
**/
bufferedState     := nil ;
bufferedRequestID := nil ;
else
/** the received state info
can be applied **/
Backup.set_state(bufferedState)
endIf
endIf
endIf
send_reply:
if(primaryRole)
state=Primary.get_state()
backup.set_state(state,)
The start of r e c e i v e _ r e q u e s t contains some
reference handling due to the fact
that a portable
interceptor is initialized before the CORBA server it is
attached to. Thus, the reference of the primary and the
backup cannot be obtained during the PI’s initialization
and must be obtained afterwards, once the system is
completely initialized.
In the receive_request code, set_state requests
received from the primary are not applied immediately by
the backup. They are buffered until a new set_state
request arrives (in which case they are applied), or until
the backup becomes primary. The set_state requests
must be buffered because an interceptor is not able to
modify a request, and in particular can’t force a request to
return a predefined result (this limitation will be discussed
in Section 4). When the primary crashes, the client and the
remaining backup must reach a common view on when the
crash occurred: (i) while the primary was idle, or (ii) while
just after a
a request was being handled, or
s e t _ s t a t e request was sent and b e f o r e
the
corresponding reply goes out. Cases (i) and (ii) are easy to
handle: the backup applies the last set_state request it
received, and takes over the primary’s role. Case (iii) is
(iii)
Proceedings of the 2004 International Conference on Dependable Systems and Networks (DSN’04) 
0-7695-2052-9/04 $ 20.00 © 2004 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 12:29:07 UTC from IEEE Xplore.  Restrictions apply. 
more difficult to tackle. In this case, the client re-issues its
request to the backup, although the primary has already
generated a set_state message for
this request.
Because we can’t impose a result on a request from within
a portable interceptor, the only possibility for the backup
to answer the client is to re-execute its request. For this
reason we must discard the last set_state request that
was received by the backup, otherwise, we would execute