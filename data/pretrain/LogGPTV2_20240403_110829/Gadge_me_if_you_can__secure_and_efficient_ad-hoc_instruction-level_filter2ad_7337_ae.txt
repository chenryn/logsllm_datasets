suite. The C++ benchmarks are listed in gray.
Exploit. To demonstrate the eﬀectiveness against an ex-
ploit, we constructed a sample program that is vulnerable to
code-reuse attacks. The code is shown in Appendix A. The
function foo() opens a ﬁle of which the path and length are
provided as parameters. Then, fgets() reads as many char-
acters as speciﬁed by the file_length parameter and copies
them into the local buﬀer buf without checking its bounds.
This in turn allows an adversary to divert the control-ﬂow by
overﬂowing the buﬀer and eventually overwriting the return
address of foo(), and inject a ROP payload on the stack.
We used ROPgadget to ﬁnd gadgets in the executable and
then successfully mounted a shellcode exploit.
After the randomized program has been started the ex-
ploit failed. Even intentionally disclosing addresses with
printf ("%x", &foo) no longer works as the relative oﬀsets
in the code segment have been changed.
6.2 Performance Evaluation
We evaluated the performance of XIFER on the Intel x86
platform and conducted micro benchmarks on the ARM
platform. To evaluate the eﬃciency, we used the SPEC
CPU2006 integer benchmark suite for the x86 version.
Runtime Overhead on Intel x86.
All benchmarks were performed on an Intel Core i7-2600
CPU running at 3.4 GHz with 8 GB of DDR3-SDRAM.
We excluded two of the total twelve benchmarks because
they use C++ exceptions (see section 4.5 CH3). We com-
piled all benchmarks using gcc-4.5.3 and the uClibc C li-
brary. All measurements include a complete randomization
of the entire address space including the executable and all
shared libraries. We examined three diﬀerent randomiza-
tion conﬁgurations: (Conﬁg-1) Maximum entropy of 52 bits,
(Conﬁg-2) Forcing a split of code after exactly 15 instruc-
tions (Conﬁg-3) Strict BBL permutation: all found BBls
are split into code pieces.
The results of our evaluation are summarized in Figure 9
and demonstrate that XIFER is highly eﬃcient and hence
addresses property P7 (see Section 3). For Conﬁg-1, which
already achieves an entropy of 52 bits, the overhead is only
5%.
Runtime Overhead on ARM.
In contrast to our evaluation on x86, we conducted mi-
cro benchmarks for ARM. In particular, we used an An-
droid Nexus S device running Android version 4.0.3. To
perform precise measurements, we leveraged the ARM hard-
Figure 9: Runtime Measurements with SPEC CPUint2006
ware clock cycle counter (CCNT) which is part of the system
co-processor (CP15). To measure the runtime overhead of
our prototype, we developed an application that calculates
10,000 times the SHA-1 hash of a 1K buﬀer with padding.
The second micro benchmark is a standard bubble sort al-
gorithm being run on an array of 1024 reverse-ordered el-
ements, so all elements in the array need to be touched
(worst-case scenario). Again, measured 10,000 times and
averaged. In average, the runtime overhead for the diversi-
ﬁed executable is only 1.52% for the SHA-1 benchmark, and
1.92% for the bubble sort algorithm.
Cache Miss Penalty. We also evaluated the cache eﬀects
of XIFER. Since wild jumping in the code due to the random-
ization thwarts the locality of code that a processor cache
assumes, it has negative impact. For this impact to be mea-
sured, we handcrafted code that consists of add-instructions
whose input depends on the prior output. These instructions
are aligned in memory so that they start at the beginning
of a cache line and re-occur in memory so that every cache
set and every cache line is ﬁlled after execution. The total
number of instructions exactly ﬁt the entire L1 cache of the
Intel Core i7 CPU.
We then split the instruction sequences by inserting jumps
between them while keeping the original number of interde-
pendent add instructions. This eﬀectively decreases the num-
ber of instructions that are executed per cache line before
jumping to the next location. As the jmp instructions are
inserted in equal distance to split the sequences, the total
number of instructions to execute grows larger than the L1
cache, which leads to cache misses and lines being evicted
from the cache in order to load new lines. The total runtime
of all instructions in the cache was measured 100,000 times.
For our benchmark system, equipped with an Intel Core
i7-2600 (32 KB L1 cache, 64 bytes per line), we found an
acceptable minimum length of 6 add instructions (12 bytes)
before a jump. This yields a negligible overhead of 0.4%. On
the other hand, smaller sizes induce a signiﬁcant number of
cache misses. For instance, when we lower the maximum
number of instructions between a jump to 2 instructions,
we notice 90.3% overhead due to cache misses as every 3rd
instruction is a jump instruction. Hence, we suggest not to
set the granularity of randomization to ≤ 6 since this still
achieves a very high entropy.
3086.3 Rewriting Time
Based on the SPEC CPUint2006 benchmarks we also eval-
uated the time XIFER requires to rewrite and randomize a
program.
In average, the throughput of the rewriting is
5500 kBit/s which demonstrates the eﬃciency of our ap-
proach.
6.4 Memory Overhead
The possibility to write out ELF executable or shared
library ﬁles might increase their ﬁle size compared to the
original, because the code is more bloated and additional
segment have been introduced to cope with the diﬀerent
load addresses.
File Size. Encapsulating each memory page in a separate
segment in the ELF ﬁle requires the allocation of one section
header and one program header per page. A section header
is 40 bytes and the ELF program header is 32 bytes which
leads to an overhead of 72 bytes per 4096 byte memory page,
or ≈ 1.76%. Figure 10 depicts both, the increase of instruc-
tions due the static translation as well as the increase of the
ELF section and program headers. librewrite.so itself oc-
cupies 72 kB when loaded.
ELF File (avg. 1.76%)
Instructions (avg. 12%)
25%
20%
15%
10%
5%
0%
Figure 10: Memory overhead after static translation.
Run-Time. During run-time, the librewrite.so has to
loaded once into the address space of a process. It is, how-
ever, unloaded after the .init section has ﬁnished and the
target program has been randomized. The code size of
librewrite.so that is temporarily mapped into an address
space is ≈ 90kB. The overhead due to the inserted instruc-
tion varies. On average, it increases the code by ≈ 5%.
In summary, our approach has a negligible impact on ﬁle-
crypts return addresses on the stack and proposes the con-
cept of return address stacks (i.e., shadow stacks) to keep
valid copies of return addresses in a protected memory area.
However, these defenses only focus on speciﬁc code reuse at-
tacks, and can typically be circumvented by a sophisticated
adversary. Another compiler-based solution against ROP
attacks was proposed by Onarlioglu et al. [27]. The authors
propose a compiler extension for Intel x86 to eliminate the
so-called unintended instruction sequences of a program.
A very well-known binary based solution against code-
reuse attacks is monitoring of the program ﬂow which has
been originally proposed by Kiriansky et al. [22]. In partic-
ular, control-ﬂow integrity (CFI) [3] ensures that a program
only follows legitimate execution paths. However, CFI in-
duces more performance overhead than randomization-based
proposals [3].
8. CONCLUSION
Runtime attacks that reuse existing code pieces (e.g., return-
oriented programming and return-into-libc) are a prevalent
attack vector against today’s applications. In this paper, we
tackle these attacks and present the design and implemen-
tation of an eﬃcient mitigation technique that is inspired
by the principle of software diversity. Our software diver-
sity tool XIFER accurately mitigates code-reuse attacks by
diversifying the structure of an application for each run by
means of binary rewriting at the load-time of the application.
At the heart of XIFER is our binary rewriter which disassem-
bles application binaries on-the-ﬂy, performs code transfor-
mations and assembles new application instances with new
memory layouts, while still covering the entire semantics
of the initial program. XIFER is fully dynamic, highly ef-
fective (provides a high randomization entropy based on a
security parameter), and eﬃcient (induces only 1.2% of run-
time overhead in average). Moreover, it requires no access
to source codes (which are rarely available in practice), and
is compatible to application signatures. Our reference im-
plementation targets both ARM and Intel x86 processors.
In order to achieve a highly eﬃcient and eﬀective dynamic
binary rewriter, we had to overcome a number of challenges
which we highlighted in this paper.
9. REFERENCES
[1] Dwarf 2.0 debugging format standard.
http://www.dwarfstd.org/doc/dwarf-2.0.0.pdf.
size and memory. Hence, we accurately address criterionP8.
[2] ROPgadget.
7. OTHER MITIGATION TECHNIQUES
In this paper we focused on randomization-based counter-
measures against code reuse attacks. The main advantage
of these defenses resides in the fact that they typically re-
quire no access to source code, perform eﬃciently, and are
already deployed in its basic form (ASLR) on today’s com-
modity systems. Nevertheless, and for the sake of complete-
ness, we brieﬂy elaborate on the most well-known counter-
measures against return-oriented programming like attacks
in the following.
One of the ﬁrst defense techniques against runtime attacks
(that are based on corrupting return addresses) is Stack-
Guard [8], a compiler extension which inserts random stack
canaries before return addresses on the stack. A more com-
prehensive defense is provided by StackGhost [10] which en-
http://shell-storm.org/project/ROPgadget/.
[3] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.
Control-Flow Integrity: Principles, Implementations,
and Applications. In ACM Conference on Computer
and Communications Security (CCS), 2005.
[4] S. Bhatkar, R. Sekar, and D. C. DuVarney. Eﬃcient
techniques for comprehensive protection from memory
error exploits. In USENIX Security Symposium.
USENIX Association, 2005.
[5] D. Bruenning. Eﬃcient, Transparent and
Comprehensive Run-time Code Manipulation. PhD
thesis, Massachusetts Institute of Technology, 2004.
[6] F. B. Cohen. Operating system protection through
program evolution. Computer & Security,
12(6):565–584, Oct. 1993.
[7] comex. http://www.jailbreakme.com//#.
309[8] C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole,
P. Bakke, S. Beattie, A. Grier, P. Wagle, and
Q. Zhang. StackGuard: Automatic Adaptive
Detection and Prevention of Buﬀer-Overﬂow Attacks.
In USENIX Security Symposium, 1998.
[9] R. Enderle. Windows 8: The app store to rule them
all?
http://www.conceivablytech.com/9973/products/
windows-8-the-app-store-to-rule-them-all.
[10] M. Frantzen and M. Shuey. StackGhost: Hardware
Facilitated Stack Protection. In USENIX Security
Symposium, 2001.
[11] M. Franz. E unibus pluram: massive-scale software
diversity as a defense mechanism. In Proceedings of
the 2010 workshop on New security paradigms, pages
7–16. ACM, 2010.
[25] C. Miller and D. Blazakis. Pwn2Own contest.
http://www.ditii.com/2011/03/10/pwn2own
-iphone-4-running-ios-4-2-1-successfully-hacked/,
2011.
[26] National Institute of Standards and Technology.
National vulnerability database statistics.
http://web.nvd.nist.gov/view/vuln/search.
[27] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and
E. Kirda. G-Free: defeating return-oriented
programming through gadget-less binaries. In
ACSAC’10, Annual Computer Security Applications
Conference, Dec. 2010.
[28] V. Pappas, M. Polychronakis, and A. D. Keromytis.
Smashing the gadgets: Hindering return-oriented
programming using in-place code randomization. In
IEEE Symposium on Security and Privacy, 2012.
[12] G. Fresi Roglia, L. Martignoni, R. Paleari, and
[29] PaX Team. PaX Address Space Layout
D. Bruschi. Surgically Returning to Randomized lib(c).
In ACSAC, 2009.
Randomization (ASLR).
http://pax.grsecurity.net/docs/aslr.txt.
[13] C. Giuﬀrida, A. Kuijsten, and A. S. Tanenbaum.
Enhanced operating system security through eﬃcient
and ﬁne-grained address space randomization. In
USENIX Security Symposium, 2012.
[30] M. J. Schwartz. Adobe Acrobat, Reader under attack
from zero-day exploit. http://www.informationweek.
com/news/security/vulnerabilities/227400016,
2010.
[14] D. Goodin. Apple QuickTime backdoor creates
[31] H. Shacham. The Geometry of Innocent Flesh on the
code-execution peril. http://www.theregister.co.
uk/2010/08/30/apple_quicktime_critical_vuln/,
2010.
[15] Google Play. https://play.google.com/store.
[16] J. D. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and
J. W. Davidson. ILR: Where’d My Gadgets Go? In
IEEE Symposium on Security and Privacy, 2012.
[17] V. Iozzo and R. Weinmann. PWN2OWN contest.
http://blog.zynamics.com/2010/03/24/
ralf-philipp-weinmann-vincenzo-iozzo-own-the-
iphone-at-pwn2own/, 2010.
Bone: Return-into-libc Without Function Calls (on
the x86). In ACM Conference on Computer and
Communications Security (CCS), 2007.
[32] H. Shacham, E. jin Goh, N. Modadugu, B. Pfaﬀ, and
D. Boneh. On the Eﬀectiveness of Address-space
Randomization. In ACM Conference on Computer and
Communications Security (CCS), 2004.
[33] M. Smithson, K. Anand, A. Kotha, K. Elwazeer,
N. Giles, and R. Barua. Binary rewriting without
relocation information. Technical report, University of
Maryland, 2010.
[18] T. Jackson, B. Salamat, A. Homescu, K. Manivannan,
[34] M. Tran, M. Etheridge, T. Bletsch, X. Jiang, V. Freeh,
G. Wagner, A. Gal, S. Brunthaler, C. Wimmer, and
M. Franz. Compiler-generated software diversity. In
Moving Target Defense. 2011.
[19] X. Jiang. GingerMaster: First android malware
utilizing a root exploit on Android 2.3 (Gingerbread).
http:
//www.csc.ncsu.edu/faculty/jiang/GingerMaster/,
2011.
and P. Ning. On the expressiveness of return-into-libc
attacks. In Proceedings of the 14th international
conference on Recent Advances in Intrusion Detection.
Springer-Verlag, 2011.
[35] P. Vreugdenhil. Pwn2Own 2010 Windows 7 Internet
Explorer 8 exploit. http://vreugdenhilresearch.nl/
Pwn2Own-2010-Windows7-InternetExplorer8.pdf,
2010.
[20] M. Keith. Android 2.0-2.1 Reverse Shell Exploit, 2010.
[36] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin.
http://www.exploit-db.com/exploits/15423/.
[21] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning.
Address space layout permutation (ASLP): Towards
ﬁne-grained randomization of commodity software. In
ACSAC, 2006.
[22] V. Kiriansky, D. Bruening, and S. P. Amarasinghe.
Secure Execution via Program Shepherding. In
USENIX Security Symposium, 2002.
[23] C. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,
G. Lowney, S. Wallace, V. Reddi, and K. Hazelwood.
Pin: building customized program analysis tools with
dynamic instrumentation. In ACM SIGPLAN Notices,
volume 40, pages 190–200. ACM, 2005.
[24] Mac App Store. http://itunes.apple.com/us/app/
apple-store/id375380948?mt=8.
3
4
5
6
7 }
char buf [ 8 ] ;
s F i l e = f o p e n ( path ,
f g e t s ( buf ,
f c l o s e ( s F i l e ) ;
‘ ‘ r ’ ’ ) ;
f i l e l e n g t h ,
s F i l e ) ;
Binary stirring: Self-randomizing instruction addresses
of legacy x86 binary code. In ACM Conference on
Computer and Communications Security (CCS), 2012.
APPENDIX
A. VULNERABLE PROGRAM
1 FILE ∗ s F i l e ;
2 void f o o ( char ∗ path ,
f i l e l e n g t h ) {
310