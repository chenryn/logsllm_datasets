# 37 \| 高级特性（二）：揭秘泛型编程的实现机制你好，我是宫文学。对泛型的支持，是现代语言中的一个重要特性。它能有效地降低程序员编程的工作量，避免重复造轮子，写很多雷同的代码。像C++、Java、Scala、Kotlin、Swift 和 Julia 这些语言都支持泛型。至于 Go语言，它的开发团队也对泛型技术方案讨论了很久，并可能会在 2021年的版本中正式支持泛型。可见，泛型真的是成为各种强类型语言的必备特性了。那么，**泛型有哪些特点？在设计和实现上有哪些不同的方案？编译器应该进行什么样的配合呢？**今天这一讲，我就带你一起探讨泛型的实现原理，借此加深你对编译原理相关知识点的认知，让你能够在自己的编程中更好地使用泛型技术。首先，我们来了解一下什么是泛型。什么是泛型？在日常编程中，我们经常会遇到一些代码逻辑，它们除了类型不同，其他逻辑是完全一样的。你可以看一下这段示例代码，里面有两个类，其中一个类是保存Integer 的列表，另一个类是保存 Student对象的列表。    public class IntegerList{        List data = new ArrayList();        public void add(Integer elem){            data.add(elem);        }        public Integer get(int index){            return (Integer) data.get(index);        }    }    public class StudentList{        List data = new ArrayList();        public void add(Student elem){            data.add(elem);        }        public Student get(int index){            return (Student) data.get(index);        }    }我们都知道，程序员是很不喜欢重复的代码的。像上面这样的代码，如果要为每种类型都重新写一遍，简直会把人逼疯！泛型的典型用途是针对集合类型，能够更简单地保存各种类型的数据，比如List、Map 这些。在 Java语言里，如果用通用的集合类来保存特定类型的对象，就要做很多强制转换工作。而且，我们还要小心地做类型检查。比如：    List strList = new ArrayList();       //字符串列表    strList.add("Richard");    String name = (String)strList.get(i); //类型转换    for (Object obj in strList){      String str = (String)obj;           //类型转换      ...    }    strList.add(Integer.valueOf(1));      //类型错误而 Java里的泛型功能，就能完全消除这些麻烦工作，让程序更整洁，并且也可以减少出错机会。    List strList = new ArrayList(); //字符串列表    strList.add("Richard");    String name = strList.get(i);                   //类型转换    for (String str in strList){                    //无需类型转换      ...    }    strList.add(Integer.valueOf(1));                //编译器报错像示例程序里用到的`List`，是在常规的类型后面加了一个参数，使得这个列表变成了专门存储字符串的列表。如果你再查看一下List 和 ArrayList的源代码，会发现它们比普通的接口和类的声明多了一个类型参数``，而这个参数可以用在接口和方法的内部所有需要类型的地方：变量的声明、方法的参数和返回值、类所实现的接口，等等。    public interface List extends Collection{      E get(int index);      boolean add(E e);      ...     }所以说，泛型就是把类型作为参数，出现在类 / 接口 / 结构体、方法 /函数和变量的声明中。**由于类型是作为参数出现的，因此泛型也被称作参数化类型。**参数化类型还可以用于更复杂的情况。比如，你可以使用 1个以上的类型参数，像 Map 就可以使用两个类型参数，一个是 key的类型（K），一个是 value的类型（V）。    public interface Map {      ...    }另外，你还可以对类型参数添加约束条件。比如，你可以要求类型参数必须是某个类型的子类，这是指定了上界（UpperBound）；你还可以要求类型参数必须是某个类型的一个父类，这是指定了下界（LowerBound）。实际上，从语言设计的角度来看，你可以对参数施加很多可能的约束条件，比如必须是几个类型之一，等等。**基于泛型的程序，由于传入的参数不同，程序会实现不同的功能。这也被叫做一种多态现象，叫做参数化多态（ParametricPolymorphism）。**它跟面向对象中的多态一样，都能让我们编写更加通用的程序。好了，现在我们已经了解了泛型的含义了。那么，它们是如何在语言中实现的呢？需要用到什么编译技术？泛型的实现接下来，我们一起来看一看几种有代表性的语言实现泛型的技术，包括Java、C#、C++ 等。类型擦除技术**在 Java 里，泛型是通过类型擦除（TypeErasure）技术来实现的。**前面在分析Java 编译器slate-object="inline"时，你就能发现，其实类型参数只存在于编译过程中，用于做类型检查和类型推断。在此之后，这些类型信息就可以被擦除。ArrayList和 ArrayList对应的字节码是一样的，在运行时没有任何区别。所以，我们可以说，在 Java语言里，泛型其实是一种语法糖，有助于减少程序员的编程负担，并能提供额外的类型检查功能。除了 Java 以外，其他基于 JVM 的语言，比如 Scala 和Kotlin，其泛型机制基本上都是类型擦除技术。**类型擦除技术的优点是实现起来特别简单。**运用我们学过的属性计算、类型检查和推断等相关技术基本就够用了。不过类型擦除技术也有一定的**局限性**。问题之一，是**它只能适用于引用类型**，也就是对象，而不适用于值类型，也就是 Java中的基础数据类型（PrimitiveType）。比如，你不能声明一个`List`，来保存单纯的整型数据，你在列表里只能保存对象化的Integer。而我们学习过 Java 对象的内存模型，知道一个 Integer对象所占的内存，是一个 int型基础数据的好几倍，因为对象头要有十几个字节的固定开销。再加上由此引起的对象创建和垃圾收集的性能开销，导致用Java的集合对象来保存大量的整型、浮点型等基础数据是非常不划算的。我们在这种情况下，还是要退回到使用数组才行。问题之二，就是因为类型信息在编译期被擦除了，所以**程序无法在运行时使用这些类型信息**。比如，在下面的示例代码中，如果你想要根据传入的类型 T创建一个新实例，就会导致编译错误。    public static  void append(ArrayList a) {      T b= new T(); // 编译错误      a.add(b);     }同样，由于在运行期没有类型信息，所以如果要用反射机制来调用程序的时候，我们也没有办法像在编译期那样进行类型检查。所以，你完全可以往一个旨在保存String 的列表里添加一个 Interger对象。而缺少类型检查，可能会导致程序在执行过程中出错。另外，还有一些由于类型擦除而引起的问题。比如，在使用参数化类型的情况下，方法的重载（Overload）会失败。再比如，下面的示例代码中，两个foo方法看似参数不同。但如果进行了类型擦除以后，它们就没什么区别，所以是不能共存的。    public void foo(List p) { ... }    public void foo(List p)  { ... }你要注意，不仅仅是 Java 语言的泛型技术有这样的缺点，其他基于 JVM实现的语言也有类似的缺点（比如没有办法在运行时使用参数化类型的信息）。这其实是由于JVM 的限制导致的。为了理解这个问题，我们可以看一下基于.NET 平台的语言，比如 C