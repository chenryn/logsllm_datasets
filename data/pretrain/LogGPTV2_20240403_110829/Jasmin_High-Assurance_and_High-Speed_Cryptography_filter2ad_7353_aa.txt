title:Jasmin: High-Assurance and High-Speed Cryptography
author:Jos&apos;e Bacelar Almeida and
Manuel Barbosa and
Gilles Barthe and
Arthur Blot and
Benjamin Gr&apos;egoire and
Vincent Laporte and
Tiago Oliveira and
Hugo Pacheco and
Benedikt Schmidt and
Pierre-Yves Strub
Jasmin: High-Assurance and High-Speed Cryptography
José Bacelar Almeida
Gilles Barthe
Manuel Barbosa
INESC TEC and FCUP
IMDEA Software Institute, Spain
INESC TEC and
Universidade do Minho, Portugal
Universidade do Porto, Portugal
Arthur Blot
ENS Lyon, France
Tiago Oliveira
INESC TEC and FCUP
Universidade do Porto, Portugal
Benjamin Grégoire
Inria Sophia-Antipolis, France
Vincent Laporte
IMDEA Software Institute, Spain
Hugo Pacheco
INESC TEC and
Universidade do Minho, Portugal
Pierre-Yves Strub
École Polytechnique, France
Benedikt Schmidt
Google Inc.
ABSTRACT
Jasmin is a framework for developing high-speed and high-assurance
cryptographic software. The framework is structured around the
Jasmin programming language and its compiler. The language is
designed for enhancing portability of programs and for simplifying
verification tasks. The compiler is designed to achieve predictability
and efficiency of the output code (currently limited to x64 platforms),
and is formally verified in the Coq proof assistant. Using the super-
cop framework, we evaluate the Jasmin compiler on representative
cryptographic routines and conclude that the code generated by the
compiler is as efficient as fast, hand-crafted, implementations. More-
over, the framework includes highly automated tools for proving
memory safety and constant-time security (for protecting against
cache-based timing attacks). We also demonstrate the effectiveness
of the verification tools on a large set of cryptographic routines.
CCS CONCEPTS
• Security and privacy → Software security engineering; Logic
and verification; Software security engineering;
KEYWORDS
cryptographic implementations, verified compiler, safety, constant-
time security
1 INTRODUCTION
Cryptographic software is pervasive in software systems. Although
it represents a relatively small part of their code base, cryptographic
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior specific permission
and/or a fee. Request permissions from permissions@acm.org.
CCS ’17, October 30-November 3, 2017, Dallas, TX, USA
© 2017 Copyright held by the owner/author(s). Publication rights licensed to Associa-
tion for Computing Machinery.
ACM ISBN 978-1-4503-4946-8/17/10...$15.00
https://doi.org/10.1145/3133956.3134078
software is often their most critical part, since it forms the back-
bone of their security mechanisms. Unfortunately, developing high-
assurance cryptographic software is an extremely difficult task.
Indeed, good cryptographic software must satisfy multiple proper-
ties, including efficiency, protection against side-channel attacks,
and functional correctness, each of which is challenging to achieve:
• Efficiency. Cryptographic software must imply minimal overhead
for system performance, both in terms of computational and
bandwidth/storage costs. These are first-class efficiency require-
ments during development: a few clock-cycles in a small crypto-
graphic routine may have a huge impact when executed repeat-
edly per connection established by a modern service provider;
• Protection against side-channel attacks. In-depth knowledge of
real-world attack models, including side-channel attacks, is fun-
damental to ensure that the implementation includes adequate
mitigation. For example, one must ensure that the observable
timing behavior of the compiled program does not leak sensitive
information to an attacker. Failing to address these considera-
tions is a major attack vector against cryptographic implementa-
tions [1, 12]. Indeed, one prevailing view is that critical code must
adhere to the “cryptographic constant-time” discipline, in partic-
ular its control flow and sequence of memory accesses should not
depend on secrets [12]. High-assurance cryptographic software
must be guaranteed to correctly adhere to this discipline.
• Functional correctness. Specifications of cryptographic compo-
nents are often expressed using advanced mathematical concepts,
and being able to bridge the enormous semantic gap to an effi-
cient implementation is a pre-requisite for the implementor of
a cryptographic component. Moreover, implementations may
involve unconventional tasks, such as domain-specific error han-
dling techniques. Guaranteeing functional correctness in these
circumstances is harder than for other software domains, but
it is critical that it is guaranteed from day 1—contrarily to the
usual detect-and-patch approach—as implementation bugs in
cryptographic components can lead to attacks [18, 23].
Efficiency considerations rule out using high-level languages, since
the code must be optimized to an extent that goes far beyond what is
achievable by modern, highly optimizing, compilers. Furthermore,
Session H4:  Formal VerificationCCS’17, October 30-November 3, 2017, Dallas, TX, USA1807Jasmin Certified Compiler
Certified in Coq
Programmed in Caml
Jasmin Source Analysis
Annotated Jasmin AST
Parser, typechecker, simplifier
Functional Embedding
CT Instrumentation
Inlining, unrolling
Jasmin source
Jasmin
Jasmin
Stack sharing
Linear scan
Dafny code
Dafny
Dafny code
Dafny
Lowering, reg. array exp.
Jasmin
Boogie code
Boogie code
Reg./stack alloc., lin.
Jasmin-low
Jasmin-lin
Asm
Linear scan
Boogie
Product generator
Boogie code
Boogie
Figure 1: Jasmin architecture.
there are concerns that highly optimizing compilers may intro-
duce security flaws [21, 26]. As a consequence, the development of
cryptographic software must be carried at assembly level, and is en-
trusted to a few select programmers. Moreover, these programmers
rely on rudimentary tooling, that is often co-developed with the im-
plementations themselves. For instance, security- and performance-
critical parts of the OpenSSL library result from an ad hoc combi-
nation of pseudo-assembly programming and scripting, known as
“perlasm”. Another alternative is to use the qhasm language [11],
that simultaneously elides low-level details that are inessential for
fine-grained performance tuning, and retains all performance- and
security-critical aspects of assembly programming. qhasm achieves
an excellent balance between programmability and efficiency, as
evidenced by a long series of speed-record-breaking cryptographic
implementations. Due to their nature, these approaches do not lend
themselves to being supported by formal verification.
Functional correctness and side-channel security requirements
for high-assurance cryptography impose going significantly be-
yond the current practices used for validating implementations,
namely code inspection, code testing (and in particular, fuzzing),
and even static analysis. Code inspection is time-consuming and
requires a high-level of expertise. Testing is particularly effective
for excluding errors which manifest themselves frequently, but
performs poorly at detecting bugs which occur with very low prob-
ability. Static analysis is useful for detecting programming errors,
but does not discover functionality bugs. A better alternative is to
create machine-assisted verification frameworks that can be used
for building rigorous proofs of functional correctness and side-
channel security. However, and as stated above, these frameworks
are not easily applicable to assembly languages.
Our contribution. We propose a tool-assisted framework, called
Jasmin, for high-speed and high-assurance cryptographic code. Jas-
min is inspired by qhasm, but it specifically addresses the lack of
independent validation that exists today and enables the creation
of high-assurance high-speed and high-security software that can
be used as a drop-in replacement for unverified routines in ex-
isting cryptographic libraries. Specifically, the Jasmin framework
goes significantly beyond current practices in cryptographic engi-
neering, by leveraging state-of-the-art methods from programming
languages, without sacrificing efficiency considerations.
More technically, we make the following contributions:
• we define the Jasmin programming language. Jasmin is designed
to significantly simplify the writing and verification of high-
speed cryptographic programs. In particular, Jasmin supports
within one single language: high-level features, including struc-
tured control flow such as loops and procedure calls, which lead
to compact code that is also easier to verify; and assembly-level
instructions (both generic and platform-specific), which give
programmers tight control over the generated code. We give a
formal, machine-checked, semantics of Jasmin in the Coq proof
assistant;
• we define and implement a formally verified compiler that trans-
forms Jasmin programs into assembly programs. The compiler
alternates between certified passes (function inlining, loop un-
rolling, constant propagation), which are proved and verified in
Coq, and passes by translation validation (register allocation),
which are programmed in a conventional programming language
and whose results are checked in Coq. The compiler is carefully
designed to achieve predictability, and to deliver efficient code;
• we define and implement a sound embedding of Jasmin programs
into Dafny [27], and use the embedding to support automated
proofs of memory safety, constant-time security, and (poten-
tially) functional correctness of Jasmin programs. The tool uses
Boogie [7] to generate verification conditions and Z3 [20] to
discharge them; for constant-time security, we use product pro-
grams as in [4]; we have also a proof-of-concept direct translation
to SMT-Lib which we have used to replicate the correctness proof
strategy of [19] using Boolector [30].
Session H4:  Formal VerificationCCS’17, October 30-November 3, 2017, Dallas, TX, USA1808• we validate our framework with an implementation of scalar
multiplication for Curve25519, the core cryptographic compo-
nent in key exchange and digital signature algorithms recently
adopted for widespread use in both TLS and the Signal protocol.
We prove that the Jasmin implementation is memory-safe and is
constant-time. This case study also serves as a point of compar-
ison with prior work [19], which pursues the same goal using
general-purpose verification tools; this comparison highlights
the advantages of having a single integrated formal verification
framework for high-speed cryptography.
• we carry a practical evaluation of our tools on a representative
set of examples, which comprises many qhasm implementations
included in the supercop framework. To this end, we created a
simple automatic translator from qhasm to Jasmin, which shows
that one can actually use Jasmin to program in a style very similar
to that used in qhasm. We benchmark the efficiency of the code
generated by the Jasmin compiler and show that its efficiency
matches the original implementations generated from qhasm.
Figure 1 provides a high-level view of the workflow of our
toolchain. On the left-hand side one can see the internal struc-
ture of the Jasmin compiler, which takes Jasmin code and produces
assembly code that can then be further compiled and linked to
larger programs/libraries. The various internal passes of the com-
piler will be explained in Section 5. On the right-hand side one can
see the tool-chain for reasoning about Jasmin at the source level.
This comprises a tool that can perform two types of translations
of Jasmin programs into Dafny [27], which will be described in
detail in Section 4. The first translation, which we call functional
embedding, translates Jasmin programs into Dafny programs with
consistent axiomatic semantics, including safety assertions that will
cause any unsafe Jasmin program to be rejected. This embedding
also permits translating typical functional correctness annotations
into the Dafny program and take advantage of the Dafny/Boogie
verification condition generator to discharge the associated proof
goals using the Z3 SMT solver;1 The second translation, which we
call CT instrumentation, creates a Dafny program that will be trans-
lated into a Boogie program with special annotations. These will
subsequently be intercepted by a sister program (product generator
in the figure), which produces a product program whose safety
implies the constant-time security of the original Jasmin program,
using essentially the same theoretical principles of ct-verif [4]. The
Jasmin compiler is proven in Coq to preserve safety and correctness
properties, and we sketch a manual proof in Section 5 that it also
preserves the constant-time property.
Trusted Computing Base. The Trusted Computing Base (TCB)
of the Jasmin framework currently includes Coq, the unverified
parts of the Jasmin compiler (limited to parsing, type-checking and
code pretty-printing), and the translator from Jasmin to Dafny code.
Because we currently rely on Dafny for source-level verification,
we also rely on the TCB of the Dafny verification infrastructure.
Using a verified verification condition generator, together with
foundational tools for constant-time and memory safety, would
eliminate Dafny from the TCB.
1we have also developed a proof-of-concept translator to SMT-Lib in order to experi-
ment with other SMT solvers, namely Boolector.
Limitations. The emphasis of this work is on providing an end-
to-end infrastructure for high-assurance and high-speed cryptogra-
phy, and to demonstrate the effectiveness of automated methods
for memory safety and constant-time security. We also provide
support for proving functional correctness, but do not exercise this
component of the framework over substantial examples, such as
scalar multiplication of Curve25519, for two main reasons. First,
verifying functional correctness with our current infrastructure
would replicate prior work—which we discuss in Section 2—and in
particular would involve a cumbersome, hand-managed, process of
combining SMT-based and interactive verification in the Coq proof
assistant. Second, we are developing a verified verification condi-
tion generator, in the spirit of the Verified Software ToolChain [6],
which provides an integrated and foundational environment for
managing such proofs, and eventually connecting with existing
mathematical formalizations of elliptic curves [9].
Moreover, Jasmin currently lacks features that are widely used
in cryptographic implementations, e.g. floating-point arithmetic
or vectorized instructions. Adding these instructions is orthogonal
to the main contributions of this paper and is left for future work.
Similarly, Jasmin currently supports a single micro-architecture,
in contrast to qhasm and “perlasm” which support multiple ones.
Nevertheless, we leave for further work to support different micro-
architectures, and to provide stronger evidence that Jasmin offers
(at least) the same level of portability.
Access to the development. The Jasmin framework can be ob-
tained from https://github.com/jasmin-lang/jasmin.
2 MOTIVATING EXAMPLE
We will illustrate the design choices of the Jasmin framework and its
workflow using a classic example from elliptic curve cryptography
which we briefly introduce below.
A primer on elliptic curve cryptography. Elliptic curve cryptog-
raphy [24] relies on hardness assumptions on algebraic groups