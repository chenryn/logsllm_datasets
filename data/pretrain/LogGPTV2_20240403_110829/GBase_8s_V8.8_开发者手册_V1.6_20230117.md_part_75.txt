 EXPLAINANALYZE_statement_：生成执行计划，进行执行，并显示执行的概要信息。
显示中加入了实际的运行时间统计，包括在每个规划节点内部花掉的总时间（以毫秒计）
和它实际返回的行数。
 EXPLAINPERFORMANCE_statement_：生成执行计划，进行执行，并显示执行期间的
全部信息。
为了测量运行时在执行计划中每个节点的开销，EXPLAIN ANALYZE 或 EXPLAIN
PERFORMANCE会在当前查询执行上增加性能分析的开销。在一个查询上运行EXPLAIN
ANALYZE或EXPLAIN PERFORMANCE有时会比普通查询明显的花费更多的时间。超支
的数量依赖于查询的本质和使用的平台。
因此，当定位SQL运行慢问题时，如果SQL长时间运行未结束，建议通过EXPLAIN
命令查看执行计划，进行初步定位。如果 SQL 可以运行出来，则推荐使用 EXPLAIN
ANALYZE或EXPLAIN PERFORMANCE查看执行计划及其实际的运行信息，以便更精准
地定位问题原因。
EXPLAINPERFORMANCE轻量化执行方式与EXPLAINPERFORMANCE保持一致，
在原来的基础上减少了性能分析的时间，执行时间与SQL执行时间的差异显著减少。
14.4.2.2 详解
如SQL执行计划概述节中所说，EXPLAIN会显示执行计划，但并不会实际执行SQL
南大通用数据技术股份有限公司
546
GBase 8s V8.8开发者手册
语句。EXPLAINANALYZE和EXPLAIN PERFORMANCE两者都会实际执行SQL 语句并
返回执行信息。在这一节将详细解释执行计划及执行信息。
14.4.2.2.1 执行计划
以如下SQL语句为例：
SELECT*FROMt1,t2WHEREt1.c1=t2.c2;
执行EXPLAIN的输出为：
执行计划层级解读（纵向）：
(1) 第一层：SeqScanont2
表扫描算子，用SeqScan的方式扫描表t2。这一层的作用是把表t2的数据从buffer或
者磁盘上读上来输送给上层节点参与计算。
(2) 第二层：Hash
Hash算子，作用是把下层计算输送上来的算子计算hash值，为后续hashjoin操作做数
据准备。
(3) 第三层：SeqScanont1
表扫描算子，用SeqScan的方式扫描表t1。这一层的作用是把表t1的数据从buffer或
者磁盘上读上来输送给上层节点参与hashjoin计算。
(4) 第四层：HashJoin
join算子，主要作用是将t1表和t2表的数据通过hashjoin的方式连接，并输出结果数
据。
执行计划中的关键字说明：
(1) 表访问方式
 SeqScan
南大通用数据技术股份有限公司
547
GBase 8s V8.8开发者手册
全表顺序扫描。
 IndexScan
优化器决定使用两步的规划：最底层的规划节点访问一个索引，找出匹配索引条件的行
的位置，然后上层规划节点真实地从表中抓取出那些行。独立地抓取数据行比顺序地读取它
们的开销高很多，但是因为并非所有表的页面都被访问了，这么做实际上仍然比一次顺序扫
描开销要少。使用两层规划的原因是，上层规划节点在读取索引标识出来的行位置之前，会
先将它们按照物理位置排序，这样可以最小化独立抓取的开销。
如果在 WHERE 里面使用的好几个字段上都有索引，那么优化器可能会使用索引的
AND或OR的组合。但是这么做要求访问两个索引，因此与只使用一个索引，而把另外一
个条件只当作过滤器相比，这个方法未必是更优。
索引扫描可以分为以下几类，他们之间的差异在于索引的排序机制。
 BitmapIndexScan
使用位图索引抓取数据页。
 IndexScanusingindex_name
使用简单索引搜索，该方式表的数据行是以索引顺序抓取的，这样就令读取它们的开销
更大，但是这里的行少得可怜，因此对行位置的额外排序并不值得。最常见的就是看到这种
规划类型只抓取一行，以及那些要求ORDERBY条件匹配索引顺序的查询。因为那时候没
有多余的排序步骤是必要的以满足ORDERBY。
(2) 表连接方式
 NestedLoop
嵌套循环，适用于被连接的数据子集较小的查询。在嵌套循环中，外表驱动内表，外表
返回的每一行都要在内表中检索找到它匹配的行，因此整个查询返回的结果集不能太大（不
能大于10000），要把返回子集较小的表作为外表，而且在内表的连接字段上建议要有索引。
 (Sonic)HashJoin
哈希连接，适用于数据量大的表的连接方式。优化器使用两个表中较小的表，利用连接
键在内存中建立hash表，然后扫描较大的表并探测散列，找到与散列匹配的行。Sonic和非
Sonic的HashJoin的区别在于所使用hash表结构不同，不影响执行的结果集。
 MergeJoin
归并连接，通常情况下执行性能差于哈希连接。如果源数据已经被排序过，在执行融合
南大通用数据技术股份有限公司
548
GBase 8s V8.8开发者手册
连接时，并不需要再排序，此时融合连接的性能优于哈希连接。
(3) 运算符
 sort
对结果集进行排序。
 filter
EXPLAIN输出显示WHERE子句当作一个“filter”条件附属于顺序扫描计划节点。这
意味着规划节点为它扫描的每一行检查该条件，并且只输出符合条件的行。预计的输出行数
降低了，因为有WHERE子句。不过，扫描仍将必须访问所有 10000 行，因此开销没有降
低；实际上它还增加了一些（确切的说，通过10000*cpu_operator_cost）以反映检查WHERE
条件的额外CPU时间。
 LIMIT
LIMIT限定了执行结果的输出记录数。如果增加了LIMIT，那么不是所有的行都会被检
索到。
14.4.2.2.2 执行信息
以如下SQL语句为例：
selectsum(t2.c1)fromt1,t2wheret1.c1=t2.c2groupbyt1.c2;
执行EXPLAINPERFORMANCE输出为：
14.4.3 调优流程
对慢SQL语句进行分析，通常包括以下步骤：
操作步骤
(1) 收集SQL中涉及到的所有表的统计信息。在数据库中，统计信息是规划器生成计划的
南大通用数据技术股份有限公司
549
GBase 8s V8.8开发者手册
源数据。没有收集统计信息或者统计信息陈旧往往会造成执行计划严重劣化，从而导致
性能问题。从经验数据来看，10%左右性能问题是因为没有收集统计信息。具体请参见
更新统计信息。
(2) 通过查看执行计划来查找原因。如果SQL长时间运行未结束，通过EXPLAIN命令查
看执行计划，进行初步定位。如果SQL可以运行出来，则推荐使用EXPLAINANALYZE
或EXPLAINPERFORMANCE查看执行计划及实际运行情况，以便更精准地定位问题
原因。有关执行计划的详细介绍请参见SQL执行计划介绍。
(3) 审视和修改表定义。
(4) 针对EXPLAIN或EXPLAINPERFORMANCE信息，定位SQL慢的具体原因以及改进
措施，具体参见典型SQL调优点。
(5) 通常情况下，有些SQL语句可以通过查询重写转换成等价的，或特定场景下等价的语
句。重写后的语句比原语句更简单，且可以简化某些执行步骤达到提升性能的目的。查
询重写方法在各个数据库中基本是通用的。经验总结：SQL语句改写规则介绍了几种
常用的通过改写SQL进行调优的方法。
14.4.4 更新统计信息
在数据库中，统计信息是规划器生成计划的源数据。没有收集统计信息或者统计信息陈
旧往往会造成执行计划严重劣化，从而导致性能问题。
背景信息
ANALYZE 语句可收集与数据库中表内容相关的统计信息，统计结果存储在系统表
PG_STATISTIC中。查询优化器会使用这些统计数据，以生成最有效的执行计划。
建议在执行了大批量插入/删除操作后，例行对表或全库执行ANALYZE语句更新统计
信息。目前默认收集统计信息的采样比例是30000行（即：GUC参数default_statistics_target
默认设置为100），如果表的总行数超过一定行数（大于1600000），建议设置 Guc参数
default_statistics_target为-2，即按2%收集样本估算统计信息。
对于在批处理脚本或者存储过程中生成的中间表，也需要在完成数据生成之后显式的调
用ANALYZE。
对于表中多个列有相关性且查询中有同时基于这些列的条件或分组操作的情况，可尝试
收集多列统计信息，以便查询优化器可以更准确地估算行数，并生成更有效的执行计划。
操作步骤
南大通用数据技术股份有限公司
550
GBase 8s V8.8开发者手册
使用以下命令更新某个表或者整个database的统计信息。
--更新单个表的统计信息。
ANALYZEtablename;
--更新全库的统计信息。
ANALYZE;
使用以下命令进行多列统计信息相关操作。
​ --收集tablename表的column_1、column_2列的多列统计信息。
ANALYZEtablename((column_1,column_2));
--添加tablename表的column_1、column_2列的多列统计信息声明。
ALTERTABLEtablenameADDSTATISTICS((column_1,column_2));
--收集单列统计信息，并收集已声明的多列统计信息。
ANALYZEtablename;
​ --删除tablename表的column_1、column_2列的多列统计信息或其声明。
ALTERTABLEtablenameDELETESTATISTICS((column_1,column_2));
在使用ALTERTABLEtablenameADDSTATISTICS语句添加了多列统计信息声明后，
系统并不会立刻收集多列统计信息，而是在下次对该表或全库进行ANALYZE时，进
行多列统计信息的收集。
如果想直接收集多列统计信息，请使用ANALYZE命令进行收集。
使用 EXPLAIN 查看各 SQL 的执行计划时，如果发现某个表 SEQ SCAN 的输出中
rows=10，rows=10是系统给的默认值，有可能该表没有进行ANALYZE，需要对该表
执行ANALYZE。
14.4.5 审视和修改表定义
14.4.5.1 审视和修改表定义概述
好的表定义至少需要达到以下几个目标：
 减少扫描数据数据量。通过分区的剪枝机制可以实现该点。
 尽量极少随机IO。通过聚簇/局部聚簇可以实现该点。
 表定义在数据库设计阶段创建，在SQL调优过程中进行审视和修改。
南大通用数据技术股份有限公司
551
GBase 8s V8.8开发者手册
14.4.5.2 选择存储模型
进行数据库设计时，表设计上的一些关键项将严重影响后续整库的查询性能。表设计对
数据存储也有影响：好的表设计能够减少I/O操作及最小化内存使用，进而提升查询性能。
表的存储模型选择是表定义的第一步。客户业务属性是表的存储模型的决定性因素，依
据下面表格选择适合当前业务的存储模型。
存储模型 适用场景
行存 点查询（返回记录少，基于索引的简单查询）。
增删改比较多的场景。
列存 统计分析类查询（group 、join多的场景）。
14.4.5.3 使用局部聚簇
局部聚簇（PartialClusterKey）是列存下的一种技术。这种技术可以通过min/max稀疏
索引较快的实现基表扫描的filter过滤。PartialClusterKey可以指定多列，但是一般不建议
超过2列。PartialClusterKey的选取原则：
(1) 受基表中的简单表达式约束。这种约束一般形如colopconst，其中col为列名，op为操
作符 =、>、>=、、=
操作符
 all_sublink：对应opALL(select…)语句，其中OP可以是IN、、=操
作符
 rowcompare_sublink：对应recordop(select …)语句