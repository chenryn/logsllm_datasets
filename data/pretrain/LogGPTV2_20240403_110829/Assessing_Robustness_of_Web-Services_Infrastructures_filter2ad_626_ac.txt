Therefore, the studies were reviewed again by author 1 to detect possible exclusions that could
be included or reexamined. The studies that could have been excluded by mistake were reviewed
again and if the initial judgment was not correct they were included.
In the next step, another 10% of the studies were screened by author 2 which resulted in no
inconsistencies. However, there were ﬁve studies that were accepted by author 2 at abstract level
that were rejected by author 1 in the full-text level. This means that these studies were accepted
by author 1 on abstract level as well.
Validity control II
To check the validity of categorization of results another control was performed. From the 144
accepted papers, 28 papers were randomly selected. Author 2 categorized the selected papers
without any communication and access to the rankings of author 1. In this case, there were six
deviations on ranking of evaluation of studies. After analyzing the deviations the reason was
found to be using diﬀerent deﬁnitions of the categories. Author 1 had ranked studies working
on commercial systems in an academic context as large academic while author 2 had ranked
them as industrial. This was discussed and clariﬁed between the two authors and the studies in
those categories were once again screened based on the deﬁnitions given in this paper. Two other
deviations were observed on the phase focus of the studies. Author 1 had ranked them in the
category design while author 2 had them in analysis. This also was found to be due to diﬀerent
deﬁnitions of the phase analysis. Clarifying our deﬁnitions of this category as presented in the
paper, the authors agreed that the initial classiﬁcation was correct. In three other cases author 2
had ranked the studies in more than one category, but on examining those papers the category
selected by author 1 proved to be the main contribution.
9
3.6. Threats to Validity
The most important threat with this result is the possibility of using other words than robust-
ness by some studies. However, since robustness is a commonly used term, the possibility of any
signiﬁcant contribution not mentioning the word in the title or abstract is minimal. The already
large scope of the study would not allow us to expand this study with more search terms. Fur-
thermore, all the results known to us during the years we have worked in the ﬁeld were included
in the ﬁnal set of studies.
A limitation in this study is that some methods that are mainly used in studies focusing on
concepts such as security and defensive programming, which can also be used for robustness
assurance and design are not included. This is a common problem for many systematic reviews
that deal with broad but important concepts such as robustness. In this study, we decided not to
include the papers which are not directly related to robustness to limit the already large scope of
the paper. However, future work could also consider techniques that indirectly or only partly has
eﬀects on software robustness.
Another threat that needs to be considered when conducting a systematic literature reviews is
the possibility of bias in selection. This concern was addressed as described in Section 3.5.1. The
selection phase was repeated by author 2 in two phases . The results show a satisfying validity
of the screening process.
The last validity threat was the possibility of existence of interesting studies in other fora.
However, the databases searched cover the area of software engineering well and we have no
reason to think that this does not apply for software robustness. Although the ACM digital
library was not fully searched, the search in this database provided no new papers in the top
10% most relevant results. Relevance has been a very accurate measure in all the other databases
and we assume that this rule applies to ACM digital library too. This control raises the level of
conﬁdence on the coverage of the most important results.
4. Results and Analysis
In this section we present the results of the systematic review. The subsections are structured
based on the research questions mentioned in Section 3.1. Section 4.1 presents our ﬁndings
regarding RQ1. This section provides a more detailed overview of the main studies found by
this review sorted after the focus area. Section 4.2 gives statistics and overview of the system
focus of the included studies to answer RQ2. Section 4.3 discusses the quality of the research,
contribution and evaluation in the selected studies to answer RQ3 and its sub-questions. The
results in this section are in the form of statistics. The quality of each single study is thereby not
presented here. The goal is to give an overview of the quality of studies in the ﬁeld and identify
gaps and weaknesses in the quality of the results.
4.1. Phase Focus of Studies
In this section, we present an overview of available literature in the ﬁeld of software robust-
ness based on the phase of software development in focus. The diﬀerent phases represented
in this study are analysis, requirements, design & implementation, veriﬁcation & validation,
evaluation and general. While the ﬁrst four categories are well-established phases of software
development, more theoretical papers that evaluate a hypothesis unrelated to a speciﬁc phase of
software engineering are categorized in the evaluation focus. The general category consists of
10
studies with clear contributions that do not have a certain phase focus and are general for the
ﬁeld of software engineering or are valid for all phases of software development.
In each subsection, results with strong contributions are discussed in more detail and an
overview of the discussed area is presented. The list of all papers in each subsection can be
found in Table 3.
Focus
Veriﬁcation & Validation
Design & Implementation
Analysis
Evaluation
General
Requirements
Table 3: Focus of the studies
Papers
[15] [18] [25] [26] [29] [30] [33] [35] [36] [37] [44] [45]
[51] [53] [57] [56] [61] [62] [65] [139] [79] [80] [81]
[83] [84] [85] [95] [94] [127] [93] [97] [100] [102] [107]
[109] [112] [113] [117] [118] [119] [120] [122] [123]
[125] [128] [129] [131] [137] [138] [140] [142] [143]
[145] [148] [150] [152] [158] [157] [161] [163] [162]
[167] [169] [104] [103] [59] [96] [101]
[2] [3] [4] [7] [10] [14] [24] [32] [40] [41] [42] [43] [52]
[54] [55] [58] [60] [67] [70] [110] [71] [72] [73] [74]
[160] [75] [78] [87] [88] [98] [108] [111] [115] [121]
[132] [133] [134] [135] [136] [141] [144] [149] [151]
[154] [156] [165] [166] [168] [46] [64] [153]
[6] [9] [17] [27] [28] [31] [63] [69] [105] [126] [164]
[8] [12] [16] [19] [39] [86] [114] [159]
[20] [68] [38]
[66] [77] [146]
68
51
11
8
3
3
An interesting point in this table is the lack of studies in requirements engineering and main-
tenance. The main areas of requirements,analysis, design & implementation, and veriﬁcation
& validation, are discussed in more detail in separate sections. The papers in general and the
evaluation category are discussed in section 4.1.5.
4.1.1. Requirements
According to our ﬁndings, the extent of published studies on software robustness require-
ments is very limited. No major study providing methods or tools on how to create requirements
to ensure robustness has been found in this study.
In an industrial experience report, Heimdahl and Czerny [66] discuss the importance of com-
pleteness in requirements engineering to achieve reliability and robustness, and provide analysis
on completeness of a large avionics system. Another contribution with the same focus is [77] that
discusses completeness of requirements as the main factor to achieve robustness in a software
system. In this study, Jaﬀe et al. suggests that for a system to be robust there should always be an
expected behavior to leave every failure state, even if that results in degrading the functionality of
the system. For this purpose, they propose a model that is evaluated in a large academic setting.
Another study with a certain focus on the requirements but main focus on testing is con-
ducted by Nebut et al. [123]. They introduce a technique “with a light declarative formalism to
express the mutual dependencies between the use cases, in terms of pre/post conditions (kind of
11
contracts). From these enhanced requirements, a labeled transition system is built to capture all
the possible valid sequences of use-cases from an initial conﬁguration” [123]. Here, the goal is
to improve the robustness by considered all the possible traces and sequences in the application.
Studies [66, 77] also propose that completeness of robustness requirements is important but
there are no further studies that present a systematic way of ensuring the completeness. In gen-
eral, there are very few studies regarding robustness requirements and there is a gap of knowledge
that needed to be addressed. In an attempt to bridge this gap we conducted a study to identify
diﬀerent types of robustness issues [146]. This study presents a framework called ROAST which
categorizes these robustness issues into patterns that can be used in the process of requirements
elicitation. Furthermore, ROAST suggests diﬀerent abstraction levels for speciﬁcation of robust-
ness requirements.
4.1.2. Analysis
Another major phase of software development is analysis. The identiﬁed studies in this
category focus on how robustness issues can be predicted and prevented early in the development
process.
For robustness analysis of web-based systems at an early stage of software development,
Calori et al. [28] propose a framework consisting of ﬁve steps:
1. Rank the severity of failure scenarios.
2. Capture system behavioral aspects and identify interface objects.
3. Examine potential failures and possible causes and eﬀects.
4. Create a model of the system failure states with probability and severity for nodes and
edges.
5. Evaluate the nodes by entering evidence about the state of a variable.
This approach can be used to compare the severities and probability of occurrence of failure
scenarios. “The most critical failures can be detected and targeted for prioritized remedial ac-
tions. Furthermore, the inﬂuence of a preventive action on the system being developed can be
estimated. This can represent a powerful tool for design trade-oﬀ decisions.” [28]
In a study with a more formal approach, [6] presents an abstract interpretation of the LUSTRE
language to study propagation of errors and provides an analysis method for checking robustness
of LUSTRE functions.
In [98], Kulkarni and Tripathi study robustness in context-aware software. The paper presents
a forward recovery model for robustness issues encountered when using their framework for
developing context-aware software. They categorize the major failures into service discovery and
reconﬁguration, service-level binding, service-level exceptions, and context invalidation failures.
On a more theoretical note, Laranjeiro et al. assess the eﬀectiveness of using text classiﬁ-
cation algorithms such as Support Vector Machines, Large Linear Classiﬁcation and K-nearest
neighbor for identifying robustness issues in web service responses [101]. The results suggest
that large linear classiﬁcation has a high precision in classifying robustness problems.
In another theoretical paper, Cheng-Ying and Yan-Sheng [31] claim that organizing excep-
tions into hierarchies can be of great beneﬁt to construct robust code. In this study they create a
model for exception analysis to improve robustness of the system.
Another method for robustness analysis is introduced by [27], which presents RATF, a method
for combining robustness analysis and technology forecasting.
12
Finally, Groot [63] proposes an approach called degradation studies for analysis of how
system output degrades as a function of degrading system input such as incomplete or incorrect
inputs.
4.1.3. Design & Architecture
After veriﬁcation and validation, with 51 included studies, design and implementation is the
largest focus group of the primary studies. One of the most discussed focus areas for design and
architecture is wrappers (encapsulation), which is used to mask and prevent the propagation of
robustness issues. Due to the large number of studies with focus on wrappers, these studies are
discussed in a separate subsection. Furthermore, some of the other contributions in the ﬁeld of
robustness design and implementation are discussed in this section.
For automatically generating interface properties from high-level robustness rules, Acharya
et al. [3, 4] propose a framework. They argue that related interfaces have “similar structural
elements (such as function parameters, return values on success/failure, and error ﬂags), when
speciﬁed at a certain abstraction level. The generic rules are translated into concrete properties
by a property engine that queries the speciﬁcation database for interface information and the
pattern database for source-code level, programming-language speciﬁc information.” [3]
In a series of studies Huhns et al. [70, 110, 69, 134, 71, 72] claim that redundancy increases
robustness of software. They “describe a methodology based on active, cooperative, and per-
sistent software components, i.e. agents, and show how the methodology produces robust and
reusable software.”
Papers [41, 42] present a programming language for robust software systems, Bristlecone.