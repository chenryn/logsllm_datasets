B. Non-persistent/DKOM Kernel Rootkit
Non-persistent kernel rootkits perform a one-time attack
to remove any traces of the
on the kernel and attempt
incident. If such an attack happens before enabling FACE-
CHANGE, then we have already missed the opportunity to
capture the attack.
For DKOM rootkits [15], which only manipulate kernel
data, FACE-CHANGE is unable to identify the attack because
it only monitors anomalies in kernel code execution. In order
to detect this kind of attack, we could integrate some existing
works [16], [17] into our system to check the kernel’s data
integrity. We leave this effort as future work.
C. Multiple-vCPU Support for Guest VM
Our current prototype supports guest VMs with a single
vCPU. In order to support multiple vCPUs per guest VM,
FACE-CHANGE will need to identify context switches on
every vCPU. Each process has its own page table and is
pinned to one CPU during execution, likewise each vCPU
has its own EPT maintained by the hypervisor. Like before,
FACE-CHANGE should manipulate each vCPU’s EPT to
perform per-vCPU kernel view switching. Extending FACE-
CHANGE to support multiple vCPUs per guest VM is our
future work.
VI. RELATED WORK
This work was inspired by two broad categories of related
works: kernel minimization and sandboxing. In this section,
we describe some representative works from each category
in detail.
A. Kernel Minimization
Earlier research on kernel minimization was not specif-
ically security oriented. The primary goal of these works
was to shrink the kernel’s in-memory size to adapt to the
limited hardware resources of embedded systems. Lee et
al. [2] used a call graph approach to eliminate redundant
code from the Linux kernel. Chanet et al. [4] applied link-
time compaction and specialization techniques to reduce the
Figure 7: I/O Performance Results for Apache Web Server
2) I/O Performance for Apache: In addition to measur-
ing overall system performance, we also evaluate FACE-
CHANGE’s inﬂuence on application’s I/O performance.
Speciﬁcally, we use httperf
to compare Apache’s perfor-
mance before and after enabling FACE-CHANGE. In this test,
we increase the request rate from 5 to 60 requests per second
(100 connections in total) to test the I/O performance. We
present the ratio of the I/O throughput after enabling FACE-
CHANGE to before in Figure 7. From Figure 7, we ﬁnd
that I/O throughput will not be affected below the threshold
rate of 55 reqs/second but may begin to degrade afterwards.
This indicates that our system has no inﬂuence on the
network throughput before the CPU becomes a bottleneck.
The reason is that the bursts of network trafﬁc cause frequent
kernel view switching in a short period of time. One solution
is to measure the rate of requests for an expected workload
of the server before enabling FACE-CHANGE. If the rate is
below the threshold rate, the application’s I/O throughput
should be unaffected by FACE-CHANGE. If the rate is far
over the threshold rate, FACE-CHANGE may require a more
powerful CPU to handle any trafﬁc peaks in the network
without slow-down.
V. DISCUSSION
In this section, we discuss the limitations of our current
approach and propose some potential directions for future
work.
A. Malicious Attack within the Application-speciﬁc Mini-
mized Kernel Attack Surface
Our approach aims to minimize the kernel attack surface
for each speciﬁc application. If a malicious attack breaks
the boundary of the kernel view generated in the proﬁling
phase, we can detect and report the violations. Compared to
system-wide minimization techniques, FACE-CHANGE en-
forces stricter constraints on kernel code visibility. It is still
possible, however, that the kernel code used by the malicious
attack is within the subset of the application’s kernel view.
500
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply. 
kernel memory. He et al. [3] reduced the memory footprint
by keeping infrequently executed code on disk and loading
it on demand.
Recent research has focused on minimizing the OS kernel
to reduce the attack surface exposed to applications. Kurmus
et al. [1] proposed a kernel reduction approach which
automatically generates kernel build conﬁgurations based
on proﬁling results of expected workloads. DRIP [18] is an
ofﬂine approach to purify trojaned kernel drivers via binary
rewriting. It leverages a functional test suite to proﬁle a
driver and reserve the minimal required set of kernel function
invocations.
Compared to previous kernel minimization works, FACE-
CHANGE dynamically presents a customized kernel view to
each individual application to minimize the kernel’s exposed
attack surface. In addition, our system is more ﬂexible and
can adapt
to changes in the execution environment and
support new applications without rebooting the system.
B. Sandboxing
Sandboxing is a general security mechanism that provides
a secure execution environment for running untrusted code.
One category of sandboxing works is to constrain the
untrusted code’s capabilities via predeﬁned security policies.
Janus [19] is a ﬁltering approach to perform system call
interposition based on the predeﬁned policy. Ostia [20]
proposed a delegating architecture to virtualize the system
call interface and provides a user level sandbox to control the
access of resources. Capsicum [21] extends the Unix API to
allow an application to perform self-compartmentalization,
i.e., conﬁning itself in a sandbox that only allows essen-
tial capabilities. Seccomp [22] is a sandboxing mechanism
implemented in the Linux kernel to constrain the system
call interface of process. If the process attempts to issue
the system call that is not allowed, it will be terminated by
the kernel. SELinux [23] is a security module in the Linux
kernel that enforces mandatory access-control policies on
applications. Similar to SELinux, AppArmor [24] restricts
the capabilities of a program through binding a security
proﬁle. TxBox [25] is based on system transactions to
speculatively execute an untrusted application and recover
from harmful effects. Process Firewalls [26] is a kernel-
base protection mechanism to avoid resource access attacks
through examining the internal state of a process and en-
forcing invariants on each system call.
Another category of sandboxing approaches is to enforce
access control through recompilation, binary rewriting and
instrumentation: PittSFIeld [27] extends software fault isola-
tion [28] (SFI) to x86. It checks unsafe memory writes and
constrains jump targets to aligned addresses. Vx32 [29] is a
sandbox that conﬁnes the system calls and data accesses of
guest plugins without kernel modiﬁcation. NaCl [30] lever-
ages SFI to provide a constrained execution environment for
the native binary code of browser-based application. TRuE
[31] replaces the standard loader with a security-hardened
loader and leverages SFI to run untrusted code. Program
shepherding [32] enforces security policies by monitoring
control ﬂow transfers during the execution of a program.
In the virtualization/emulation environment, a full system
is considered to be conﬁned in a sandbox and the protection
is provided at hypervisor level: Secvisor [33] ensures that
only approved code can be executed in kernel mode to
protect the kernel against code injection attacks. NICKLE
[34] enforces that only authorized kernel code can be fetched
for execution in kernel space. To guarantee the integrity of
kernel hooks, HookSafe [35] relocates hooks to a page-
aligned memory space and regulates accesses to them via
page-level protection. HUKO [36] is a hypervisor-based
approach to enforce mandatory access control policies on
untrusted kernel extensions. Gateway [37] isolates kernel
drivers in a different address space from the base kernel
and monitors their kernel API invocations.
FACE-CHANGE can also be considered a type of sandbox-
ing approach. The difference from these previous works is
that we sandbox each individual application by constraining
its reachability of kernel code. We also enforce our approach
at the hypervisor level to be transparent to the guest system.
VII. CONCLUSION
the kernel code re-
We make a key observation that
quired by applications of different
types varies tremen-
dously. Thus, generating a single system-wide minimized
kernel will enlarge the attack surface for all applications
involved. We develop FACE-CHANGE, a virtualization-based
system to facilitate dynamic kernel view switching among
individual applications executed in a VM. FACE-CHANGE
transparently presents a customized kernel view to each
application to conﬁne its reachability of kernel code and
switch this view upon context switches. In the event that a
process breaks its kernel view boundary, FACE-CHANGE is
able to recover the missing kernel code and backtrack this
anomaly via analysis of the execution history. Our evaluation
demonstrates the drastic difference in the size of kernel
views of multiple applications, the effectiveness of FACE-
CHANGE in revealing the attack patterns of both user and
kernel attacks, and the potential of enabling FACE-CHANGE
for production VMs.
ACKNOWLEDGMENT
We would like to thank the anonymous reviewers for
their insightful comments. This research has been supported
in part by the AFOSR under award FA9550-10-1-0099,
DARPA under Contract 12011593, and NSF under award
0855141. Any opinions, ﬁndings, and conclusions in this
paper are those of the authors only and do not necessarily
reﬂect the views of the sponsors above.
501
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply. 
REFERENCES
[1] A. Kurmus, R. Tartler, D. Dorneanu, B. Heinloth, V. Roth-
berg, A. Ruprecht, W. Schr¨oder-Preikschat, D. Lohmann, and
R. Kapitza, “Attack surface metrics and automated compile-
time os kernel tailoring,” in Proceedings of the 20th Network
and Distributed System Security Symposium, 2013.
[2] C. tai Lee, J. min Lin, Z. wei Hong, and W. tsong Lee, “An
application-oriented linux kernel customization for embedded
systems,” Journal of Information Science and Engineering,
1995.
[3] H. He, S. K. Debray, and G. R. Andrews, “The revenge of
the overlay: automatic compaction of os kernel code via on-
demand code loading,” in Proceedings of the 7th ACM &
IEEE international conference on Embedded software, 2007.
[4] D. Chanet, B. De Sutter, B. De Bus, L. Van Put, and
K. De Bosschere, “System-wide compaction and specializa-
tion of the linux kernel,” in Proceedings of the 2005 ACM
SIGPLAN/SIGBED Conference on Languages, Compilers,
and Tools for Embedded Systems, 2005.
[5] C. Cadar, D. Dunbar, and D. Engler, “Klee: Unassisted
and automatic generation of high-coverage tests for complex
systems programs,” in Proceedings of the 8th USENIX Con-
ference on Operating Systems Design and Implementation,
2008.
[6] P. Godefroid, N. Klarlund, and K. Sen, “Dart: Directed
automated random testing,” in Proceedings of the 2005 ACM
SIGPLAN Conference on Programming Language Design and
Implementation, 2005.
[7] K. Sen, D. Marinov, and G. Agha, “Cute: A concolic unit
testing engine for c,” in Proceedings of the 10th European
Software Engineering Conference Held Jointly with 13th
ACM SIGSOFT International Symposium on Foundations of
Software Engineering, 2005.
[8] F. Bellard, “Qemu, a fast and portable dynamic translator,”
in Proceedings of the Annual Conference on USENIX Annual
Technical Conference, 2005.
[9] “RUBiS,” http://rubis.ow2.org/.
[10] “injectso: Modifying and spying on running processes under
linux,” http://www.blackhat.com/presentations/bh-europe-01/
shaun-clowes/bh-europe-01-clowes.ppt.
[11] “Cymothoa - Stealth backdooring tool,” http://cymothoa.
[12] “Single Process Parasite,” http://www.phrack.org/issues.html?
sourceforge.net/.
issue=68&id=9#article.
[13] “Injected Evil(executable ﬁles infection),” http://z0mbie.host.
http://core.ipsecs.com/rootkit/kernel-rootkit/
sk/infelf.html.
[14] “kbeast-v1,”
kbeast-v1/.
[15] J. Butler, “DKOM (Direct Kernel Object Manipulation).”
[16] J. Rhee, R. Riley, D. Xu, and X. Jiang, “Kernel malware
analysis with un-tampered and temporal views of dynamic
kernel memory,” in Proceedings of the 13th International
Conference on Recent Advances in Intrusion Detection, 2010.
[17] J. Rhee, R. Riley, D. Xu, and X. Jiang, “Defeating dynamic
data kernel rootkit attacks via vmm-based guest-transparent
monitoring,” in Availability, Reliability and Security, 2009.
ARES ’09. International Conference on, 2009.
[18] Z. Gu, W. N. Sumner, Z. Deng, X. Zhang, and D. Xu,
“Drip: A framework for purifying trojaned kernel drivers,”
in Proceedings of the 43rd Annual IEEE/IFIP International
Conference on Dependable Systems and Networks(DSN),
2013.
[19] I. Goldberg, D. Wagner, R. Thomas, and E. A. Brewer, “A
secure environment for untrusted helper applications: Conﬁn-
ing the wily hacker,” in Proceedings of the Sixth USENIX
Security Symposium, 1996.
[20] T. Garﬁnkel, B. Pfaff, and M. Rosenblum, “Ostia: A dele-
gating architecture for secure system call interposition.” in
Proceedings of the 11th Annual Network and Distributed
System Security Symposium, 2004.
[21] R. N. Watson, J. Anderson, B. Laurie, and K. Kennaway,
“Capsicum: Practical capabilities for unix.” in Proceedings
of the 19th USENIX Security Symposium, 2010.
[22] “Seccomp and sandboxing,” http://lwn.net/Articles/332974/.
[23] P. Loscocco and S. Smalley, “Integrating ﬂexible support
for security policies into the linux operating system,” in
Proceedings of the FREENIX Track: 2001 USENIX Annual
Technical Conference, 2001.
[24] M. Bauer, “Paranoid penguin: An introduction to novell
apparmor,” Linux Journal, 2006.
[25] S. Jana, D. Porter, and V. Shmatikov, “Txbox: Building
secure, efﬁcient sandboxes with system transactions,” in Se-
curity and Privacy (SP), 2011 IEEE Symposium on, 2011.
[26] H. Vijayakumar, J. Schiffman, and T. Jaeger, “Process ﬁre-
walls: Protecting processes during resource access,” in Pro-
ceedings of the 8th ACM European Conference on Computer
Systems, 2013.
[27] S. McCamant and G. Morrisett, “Evaluating sﬁ for a cisc
architecture,” in Proceedings of the 15th USENIX Security
Symposium, 2006.
[28] R. Wahbe, S. Lucco, T. E. Anderson, and S. L. Graham,
“Efﬁcient software-based fault isolation,” in Proceedings of
the 14th ACM Symposium on Operating Systems Principles,
1993.
[29] B. Ford and R. Cox, “Vx32: Lightweight user-level sand-
boxing on the x86,” in USENIX 2008 Annual Technical
Conference on Annual Technical Conference, 2008.
[30] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Ormandy,
S. Okasaka, N. Narula, and N. Fullagar, “Native client: A
sandbox for portable, untrusted x86 native code,” in Security
and Privacy, 2009 30th IEEE Symposium on, 2009.
[31] M. Payer, T. Hartmann, and T. R. Gross, “Safe loading-a
foundation for secure execution of untrusted programs,” in
Security and Privacy (SP), 2012 IEEE Symposium on, 2012.
[32] V. Kiriansky, D. Bruening, and S. P. Amarasinghe, “Secure
execution via program shepherding,” in Proceedings of the
11th USENIX Security Symposium, 2002.
[33] A. Seshadri, M. Luk, N. Qu, and A. Perrig, “SecVisor:
A tiny hypervisor to provide lifetime kernel code integrity
for commodity OSes,” in Proceedings of twenty-ﬁrst ACM
SIGOPS symposium on Operating systems principles, 2007.
[34] R. Riley, X. Jiang, and D. Xu, “Guest-transparent prevention
of kernel rootkits with vmm-based memory shadowing,” in
Proceedings of the 11th International Symposium on Recent
Advances in Intrusion Detection, 2008.
[35] Z. Wang, X. Jiang, W. Cui, and P. Ning, “Countering kernel
rootkits with lightweight hook protection,” in Proceedings of
the 16th ACM conference on Computer and communications
security, 2009.
[36] X. Xiong, D. Tian, and P. Liu, “Practical Protection of Kernel
Integrity for Commodity OS from Untrusted Extensions,” in
Proceedings of the 18th Annual Network and Distributed
System Security Symposium, 2011.
[37] A. Srivastava and J. Gifﬁn, “Efﬁcient Monitoring of Untrusted
Kernel-Mode Execution,” in Proceedings of the 18th Annual
Network and Distributed Systems Security Symposium, 2011.
502
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 08:20:50 UTC from IEEE Xplore.  Restrictions apply.