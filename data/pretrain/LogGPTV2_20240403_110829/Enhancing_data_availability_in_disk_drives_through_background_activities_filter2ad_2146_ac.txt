### LengthParity Segment and Its Impact on MTTDL

The **LengthParity segment** refers to the number of sectors in each parity segment. The performance of the policy that schedules background requests during idle intervals determines the **RTupdate** and, consequently, affects the **Mean Time to Data Loss (MTTDL)**.

### Experimental Results for Traces T1 and T2

In the following sections, we present the results for traces T1 and T2. Traces T2 and T3 yield similar results due to their high variability in idle times. Additionally, for the finite work generated by parity updates, exploiting burstiness does not provide further improvement. We monitor the following four metrics:
1. **MTTDL improvement** via intra-disk parity.
2. **Ratio of completed parity updates** to the total trace WRITE traffic.
3. **Average time of parity updates**, which is the interval between the completion of a user-issued WRITE operation and the update of the parity.
4. **Overall system utilization** (foreground + background).

### 7.2 Parity Updates under Trace T1

Assuming a disk capacity of 40GB, the relative MTTDL improvement for parity updates under trace T1, which has nearly 40% user WRITEs, is presented in Table 5. The relative MTTDL improvement is defined as the difference between MTTDL with and without intra-disk parity. The improvement attributed to intra-disk parity is only two orders of magnitude, compared to the five orders of magnitude attributed to scrubbing. 

Table 5 shows that there is almost no difference between the MTTDL improvement achieved via instantaneous parity (IP) updates and delayed parity updates, strongly arguing in favor of delayed intra-disk parity. For finite background activities under trace T1, the tail-based policy achieves slightly better system reliability than the body-based policy.

| Policy | MTTDL Improvement (years) |
|--------|---------------------------|
| Body   | 0.481 x 10^2              |
| Tail   | 0.484 x 10^2              |
| IP     | 0.484 x 10^2              |

**Table 5: MTTDL improvement for trace T1 via intra-disk data redundancy, where IP is instantaneous parity update without delaying.**

### Performance Metrics for Trace T1

Table 6 further demonstrates that the tail-based scheduling performs better across all metrics. Specifically, the tail-based policy updates parities almost two orders of magnitude faster than the body-based policy. Quick parity update times are crucial because they directly affect data reliability. Note that system utilization is higher under the body-based policy, leading to more preemptions of parity updates by user requests, which results in wasted work.

| Metric | Body-Based | Tail-Based |
|--------|------------|------------|
| MTTDL Improvement | 0.481 x 10^2 | 0.484 x 10^2 |
| Ratio of Completed Parity Updates | - | - |
| Average Parity Update Time (s) | - | - |
| System Utilization (%) | - | - |

**Table 6: Parity update performance for trace T1 (low variability).**

### CDF of Parity Update Times for Trace T1

Figure 3 shows the distribution of parity update times. While about 68% of parity updates under the body-based policy are faster, the tail of parity update times is longer and dominates the average, resulting in a two orders of magnitude advantage for the tail-based policy.

### 7.3 Parity Updates under Trace T2

Trace T2 has only 1% user WRITEs. To experiment with higher WRITE traffic, we generate three additional traces with 10%, 50%, and 90% WRITEs, respectively. These traces are generated based on T2 by probabilistically selecting entries to be READ or WRITE.

Table 7 presents the relative MTTDL improvement via parity updates under four variants of trace T2 using the body-based and tail-based policies. This table also shows two different performances for the tail-based policy (marked as "tail-S" and "tail-L"). Both tail-based policies utilize the tail of the idle times, but "tail-S" has a shorter idle wait (approximately 40%) than "tail-L". Similar to the results for trace T1, all policies achieve two orders of magnitude MTTDL improvement. The difference between instantaneous parity (IP) updates and delayed parity updates is negligible, especially under the tail-based policy.

| Trace | Policy | MTTDL Improvement (years) |
|-------|--------|---------------------------|
| T2 (1% WRITEs) | Body | 0.484 x 10^2              |
| T2 (1% WRITEs) | Tail-S | 0.484 x 10^2              |
| T2 (1% WRITEs) | Tail-L | 0.484 x 10^2              |
| T2 (1% WRITEs) | IP | 0.484 x 10^2              |
| T2 (10% WRITEs) | Body | 0.466 x 10^2              |
| T2 (10% WRITEs) | Tail-S | 0.483 x 10^2              |
| T2 (10% WRITEs) | Tail-L | 0.484 x 10^2              |
| T2 (10% WRITEs) | IP | 0.484 x 10^2              |
| T2 (50% WRITEs) | Body | 0.386 x 10^2              |
| T2 (50% WRITEs) | Tail-S | 0.482 x 10^2              |
| T2 (50% WRITEs) | Tail-L | 0.483 x 10^2              |
| T2 (50% WRITEs) | IP | 0.484 x 10^2              |
| T2 (90% WRITEs) | Body | 0.351 x 10^2              |
| T2 (90% WRITEs) | Tail-S | 0.482 x 10^2              |
| T2 (90% WRITEs) | Tail-L | 0.483 x 10^2              |
| T2 (90% WRITEs) | IP | 0.484 x 10^2              |

**Table 7: MTTDL improvement for trace T2 via intra-disk data redundancy.**

### Performance Metrics for Trace T2

Table 8 shows that the tail-based policy outperforms the body-based one, particularly in terms of average parity update time. For example, the body-based policy performs at least seven times worse than the tail-based policy. The differences in performance increase as the amount of parity updates increases. Among the tail-based policies, "tail-L" achieves better update times, while "tail-S" completes more parity updates. When the amount of parity updates is small, both tail-based policies perform similarly.

| Trace | Policy | Parity Update Ratio (%) | Parity Update Time (s) | System Utilization (%) |
|-------|--------|-------------------------|------------------------|------------------------|
| T2 (1% WRITEs) | Body | 28.40 | 141.4 | 4.68 |
| T2 (1% WRITEs) | Tail-S | 66.40 | 25.4 | 4.57 |
| T2 (1% WRITEs) | Tail-L | 66.40 | 25.4 | 4.57 |
| T2 (10% WRITEs) | Body | 13.39 | 7,272.9 | 5.23 |
| T2 (10% WRITEs) | Tail-S | 33.20 | 194.3 | 5.03 |
| T2 (10% WRITEs) | Tail-L | 21.88 | 62.9 | 4.75 |
| T2 (50% WRITEs) | Body | 3.96 | 9,721.2 | 5.42 |
| T2 (50% WRITEs) | Tail-S | 21.57 | 69.2 | 6.36 |
| T2 (50% WRITEs) | Tail-L | 17.44 | 31.4 | 5.88 |
| T2 (90% WRITEs) | Body | 2.41 | 8,142.6 | 5.44 |
| T2 (90% WRITEs) | Tail-S | 18.36 | 48.6 | 7.36 |
| T2 (90% WRITEs) | Tail-L | 16.90 | 33.4 | 7.03 |

**Table 8: Performance of parity updates for trace T2 (high variability) and four different user WRITE traffic, i.e., 1%, 10%, 50%, and 90% (numbers in parenthesis indicate the absolute number of user WRITEs).**

### CDF of Parity Update Times for Trace T2

Figure 4 plots the CDFs of parity update times for all four variants of trace T2. Consistently with the results in Table 8, the body-based policy has a longer tail in the distribution of parity update times, indicating that the tail-based policy, especially "tail-L," provides the best average performance.

### Conclusion

Timely parity updates are critical for MTTDL. The tail-based policy, particularly "tail-L," consistently outperforms the body-based policy, especially in scenarios with high variability in idle times and a large number of parity updates.