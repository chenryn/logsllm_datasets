2.763 (0.265)
actions even in the absence of malware or policies (de-
noted “None” in Figure 2). This suggests that our modi-
ﬁcations to the underlying CRIU checkpoint and restore
methods do not have a signiﬁcant impact on their per-
formance in terms of duration. Furthermore, we see that
the time taken for the recovery process (see Table 1) is
mostly dominated by the checkpoint process, with the
restore process taking only about a ﬁfth of the total time.
5.2 Experiment II: Availability Impact
Next, we address the question of the recovery process’s
impact on the availability of trusted services running on
the host that is infected with malware. To evaluate this,
we measure the impact of removing malware on a web
server container with many active clients. For this, we
use the ab tool (Apache Benchmark), which is able to
simulate repeated HTTP connections and measure their
duration and the number of failed requests.
In order
to mimic a realistic setting with a variety of request/re-
sponse durations, we serve seven different pages ranging
in size from 1kB to 1GB by powers of 10. We execute
one instance of ab for each ﬁle size in parallel and vary
the number of concurrent requests per process at 1, 5, 10,
and 20 for a total concurrency across all processes of 7
to 140. For each experiment, we ﬁrst start the apache
benchmark script. After 30 seconds of normal execu-
tion of ab, we start the linux_lady malware on the host
Overall, our experiences using CRIU-MR conﬁrm that
it is a viable strategy for removing malware while pre-
serving a variety of services. For example, we manually
observed that ssh connections interrupted by the CRIU-
MR recovery process continue gracefully after the recov-
ery completes, even without the use of NFQUEUE. How-
ever, when the recovery process occurs during down-
loads of large ﬁles using curl or browsers, NFQUEUE
usage is required in order to preserve the download pro-
cess. We therefore conclude that our modiﬁcations for
CRIU-MR do not impact CRIU’s underlying TCP restore
abilities.
Beyond faster system restore, one beneﬁt of the CRIU-
MR method over methods which log every ﬁlesystem
modiﬁcation, such as Taser [20], is that there is no over-
head for writing to logs during normal execution of the
container. However, there is some performance over-
head associated with using Linux containers that should
be considered. Work comparing LXC to native perfor-
mance and other virtualization techniques reveals that it
often performs similarly to the native operating system
[37]. This is likely due to the fact that Linux containers
rely mostly on partitioning resources using Linux names-
paces and control groups instead of more complex solu-
tions, such as hardware virtualization used by conven-
tional VMs.
Another concern is the security of the container in
terms of isolation.
Is it possible to escape the Linux
container and infect the host operating system? Unfor-
tunately, some proof of concept attacks have been found
for Linux containers. Two whitepapers from the NCC
Group explore this problem, one focusing on attacks [23]
and one focusing mostly on mitigations [22]. This re-
search reveals that ptrace(2) can be used to escape
Linux containers, and an escape from the security bound-
ary of the container can be executed via direct com-
munication with the hardware. Fortunately, mitigations
for these attacks are available, and the simplest method
USENIX Association
27th USENIX Security Symposium    1205
NoneLinux.Agentlinux_ladygoahead_ldpreloadwipefsms_reverse_shellms_bind_shellMalware Removed2.02.22.42.62.83.03.23.43.6Duration (s)Time per Malware Removed (n=10)Table 2: Connection Stress Test
Max Request
Time (s)
Completed Requests
Concurrent Requests
7
35
70
140
File
Size
5,415
4
4
5
20
130
Median Re-
quest
Time
(s)
1
1 kB
1
10 kB
1
100 kB
4
1 MB
34
10 MB
100 MB 393
1 GB
1 kB
10 kB
100 kB
1 MB
10 MB
100 MB 1,256
12,482
1 GB
7
1 kB
7
10 kB
10
100 kB
1 MB
42
10 MB
242
100 MB 2,474
43,088
1 GB
1 kB
13
13
10 kB
19
100 kB
77
1 MB
10 MB
583
100 MB 5,712
1 GB
62,474
3,695
3,695
3,697
3,701
3,731
4,081
8,777
3,776
3,776
3,782
3,821
4,115
6,066
26,098
6,307
6,307
6,310
6,343
6,343
10,047
43,097
4,614
4,614
4,641
4,706
5,351
10,933
62,474
51,973
50,568
36,937
11,823
1,580
146
11
51,803
58,479
41,953
11,385
1,776
205
19
60,647
59,976
40,300
11,595
1,810
207
12
78,377
77,497
53,338
14,494
1,953
191
1
Failed Requests
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
(which will ﬁx both of these issues) is to simply use un-
privileged Linux containers.
As alluded to previously, the malware process that
triggered an intrusion detection alert might not be found
by the speciﬁed policies in some cases. For example,
if botnet malware is detected via an IDS based on a TCP
connection to a command and control server, the connec-
tion may end before the alert is processed and CRIU-MR
begins the checkpoint process, meaning the malware will
fail to be ﬂagged for omission during restore. In such a
case, if the malware runs from an executable placed on
the system via a malicious channel, CRIU-MR will still
successfully remove it from the container during the re-
store process since the botnet executable isn’t located on
the safe ﬁlesystem backup. Such an event can be veriﬁed
by checking the logs of CRIU-MR, which report which
policy elements were triggered and any missing ﬁles that
resulted in the removal of a process.
Nonetheless, the system may be infected with malware
that both runs entirely within memory via code injection
and evades being ﬂagged during a checkpoint event as
just described. In such an instance, it is prudent for the
user to not only restore the ﬁlesystem to a safe point but
to also restart the system and bring services back online.
Users with active connections to services may experience
an interruption in this case, but such mitigation will be
necssary if no malware process was found. Similarly,
there may exist malware which interfere with the mem-
ory and connections of other processes. These changes
will not be detected by the current CRIU-MR system as
they are not directly a part of the malware process (unless
the interference somehow triggers another policy rule).
The best solution for avoiding this issue is to use con-
tainers which have only one main service to reduce the
potential attack surface. Alternatively, assertions about
the memory spaces of benign processes could be checked
during the restore process to verify their integrity, an idea
we consider future work (§7).
This method is speciﬁc to Linux operating systems
as it relies heavily on CRIU and LXC, which are obvi-
1206    27th USENIX Security Symposium
USENIX Association
ously speciﬁc to that operating system. However, Linux
is a popular operating system for web servers, with ap-
proximately 66.8% of web servers from the Alexa top
ten million sites using some ﬂavor of it, according to a
survey conducted by W3Tech in February 2018 [12]. It
might also be possible to extend the main ideas of this
method using container technology for other operating
systems, such as Docker, by using or creating the appro-
priate checkpoint/restore methods.
Finally,
it is important to take appropriate actions
even after malware removal. Namely, any vulnerabil-
ity that resulted in a malware payload being delivered
or executed needs to be patched. For example,
the
goahead_ldpreload exploit can be immediately ex-
ploited again after the ﬁrst malware recovery if the GoA-
head web server is not patched. Therefore, CRIU-MR
needs to be coupled with a patching process in order to
avoid repeated exploitation of the same vulnerabilities.
7 Future Work
The next step in CRIU-MR’s development will be to add
alert validation to the recovery agent. By design, CRIU-
MR does not consider whether the alerts it receives may
be false positives; IDS and IPS systems should already
strive to minimize the generation of false positive alerts.
However, the current version does not yet ensure that any
malware alerts it receives come from an authentic IDS or
IPS system. Adding this feature will ensure that forged
alerts that might cause CRIU-MR to ﬂag important appli-
cations as malware or otherwise interrupt services cannot
be sent to the recovery agent.
Another avenue for future work is in the veriﬁcation
of the integrity of processes. We previously noted that it
is possible that malware may seek to change the memory
spaces of benign processes outside of its process tree.
One way to check if this has occurred is to instrument
these processes with additional code to verify they are
still executing properly. We refer to these checks as “dy-
namic assertions”, where the processes are expected to
dynamically respond to queries about execution state in
order to verify the integrity of the process. Research into
this area may reveal more robust ways of ensuring that
malware effects have been reverted even if it interfered
with other processes.
Because any maliciously uploaded ﬁles are archived
in a separate ﬁlesystem, CRIU-MR could also be used
as part of a framework which discovers and analyzes
new malware. For example, checkpointed malware pro-
cesses with corresponding executables could be executed
in sandboxes to collect more information. Cuckoo [4] is
one option for local analysis, or, if an external service is
preferred, VirusTotal [13] or Hybrid Analysis [5] can be
used to learn more about the nature of the collected pay-
load. These results could then be integrated into other
systems responsible for malicious activity alerts to more
rapidly detect attacks of this type.
In addition to improvements to this particular compo-
nent, we intend to explore how CRIU-MR can ﬁt into a