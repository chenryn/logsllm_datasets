### 6.1.4 Dynamically Loaded Libraries

As mentioned in the previous section, our current implementation is limited to a single program image, specifically the executable file. Most programs, however, load numerous additional dynamically linked libraries (DLLs) after the main executable file is loaded. Since a significant portion of the executed instructions often reside in these DLLs, their impact cannot be ignored. Additionally, the loading of DLLs can be delayed until they are actually used. Given that our proposal incurs considerable initial overhead, frequent loading of DLLs during execution could become problematic.

### 6.1.5 Execution Environment

The Pin module itself cannot be the target of code shedding and must be loaded into the same address space as the targeted software. This makes it vulnerable to attacks where an attacker returns into the Pin code. Therefore, it is more desirable to implement our solution in a more isolated layer, such as the operating system (OS) layer, the hypervisor layer, or even the hardware layer.

### 6.2 Related Works

In this section, we describe and compare other research works that share common ideas with our proposal.

#### Software Diversification

Software diversification involves changing the software and/or the execution environment to make it difficult for attackers to succeed unless they know how the changes were made. A well-known approach is instruction set randomization [3], which encodes instructions with a secret randomized key and decodes them just before execution, making injected code by the attacker undecodable. Other approaches, such as stack reversing [32], are effective against code injection but do not prevent control flow hijacking. Our approach is similar to software diversification in that it applies the idea to addresses, making overwriting or injecting addresses impossible.

#### ROP Prevention

The increasing number and complexity of return-oriented programming (ROP) attacks have led to many specialized defense proposals, such as monitoring the frequency of return instructions [31]. Recently, a method to eliminate ROP gadgets through static binary conversion has been proposed [23], which appears to be an effective and practical measure against ROP. Unlike these methods, our approach is not limited to ROP attacks and can prevent a broader range of attacks, including return-to-libc, ROP without returns [29], and other types of control flow hijacking attacks that may emerge in the future.

#### Pointer Encryption

The most similar and potentially competing approach to ours is the encryption of addresses [18]. While pointer encryption relies on a strong cryptographic base, it often incurs high overhead. In contrast, our approach encodes addresses in a form that remains directly usable by instructions, whereas encrypted addresses require decryption before use.

#### Shadow Stack

Another well-known approach is to maintain a shadow stack that emulates the real stack and compares return addresses upon function returns, as in ROPDefender [24]. The primary limitation of this approach, aside from requiring extra memory for the shadow stack, is that it only defends against attacks that modify return addresses. Extending the shadow stack to track other types of addresses is challenging because these addresses are frequently moved and copied to various locations, such as the heap, stack, and registers. Taint analysis, which is extremely performance-intensive, would be required to track these addresses. In contrast, our scheme contains self-contained information needed to validate addresses.

#### Control Flow Integrity (CFI)

Control flow integrity (CFI) generates a model of valid control flow graphs through static analysis of source code or binaries at runtime and enforces it during execution. While CFI provides a strict and deterministic defense, it incurs heavy runtime overhead and often suffers from false positives due to insufficient debug information, which is common in commercial off-the-shelf (COTS) software.

#### Other Defensive Approaches

**Code Pointer Masking** [15] is a probabilistic approach that verifies destination addresses at runtime. Before use, a code pointer is masked with a special mask generated by OR-ing valid destinations. This approach scrambles the pointer if it does not point to a valid destination. However, as the number of valid destinations increases, the mask becomes more tolerant, allowing more possible false negatives. In contrast, our approach's security strength is independent of the program content and can be increased by adding more segments, provided there is sufficient memory.

**In-OS Address Space Layout Randomization (ASLR)** [33] studies the recent work on live re-randomization, which could complement our system for further strengthening. Binary stirring [34] is another recent proposal for static binary randomization, which thoroughly examines transformation challenges and could help identify and fix our compatibility issues. Both of these works have a randomization granularity at the basic block level.

**Memory Sharing**

The idea of mapping a physical page to multiple pages in virtual memory was previously proposed by the PaX project as VMA mirroring [30] for Linux systems. The implementation details of VMA mirroring may be applicable when extending our work to Linux. A similar, more general, and transparent approach is implemented in some virtual machine monitors, such as KVM's Kernel Samepage Merging (KSM), which merges common pages across multiple VMs. However, KSM requires heavy scanning of memory, leading to long intervals between scans. It would be interesting to investigate the compatibility of such schemes with our system.

**Randomized Control Flow**

Finally, we mention Branch-on-Random [16], which, although not a security-related work, inspired our idea. It proposes a unique conditional branch instruction where the condition is determined probabilistically at the moment of branch instruction execution. This is similar to our approach in that the control flow proceeds randomly, though in our work, the destination is randomly determined before execution.

### 7. Conclusion

In this paper, we presented a novel approach to defending against control flow hijacking attacks. Many research works have addressed this problem, but our work stands out by focusing on both security and compatibility properties, such as not requiring recompilation, code analysis, or preserving the integrity of execution. This focus is derived from the insight that Address Space Layout Randomization (ASLR), the most widespread defense, sacrifices security for compatibility.

The main purpose of this paper is to propose an overview and design of our approach. We also implemented a prototype using Pin to evaluate its feasibility. Our conclusion is that this approach is expected to be feasible, although perfect compatibility may require modifying the compiler. Such changes should be simpler than those required by other proposed methods. Future work will include further refinements, optimizations for improving runtime performance, and compatibility improvements through crash analysis to support dynamically loaded images. Investigating the advantages and requirements for implementing this on hardware or applying it to Linux would also be interesting.

### 8. References

[1] MSDN Library, “Windows ISV Software Security Defenses," http://msdn.microsoft.com/en-us/library/bb430720.aspx

[2] Android Developers, “Android 4.0 Platform Highlights," http://developer.android.com/sdk/android-4.0-highlights.html

[3] G. S. Kc, Angelos D. Keromytis, and V. Prevelakis, “Countering code-injection attacks with instruction-set randomization," in Proc. of the 10th ACM conference on Computer and communications security (CCS ’03), 2003.

[4] c0ntex, “Bypassing non-executable-stack during exploitation using return-to-libc," http://www.infosecwriters.com/text_resources/pdf/return-to-libc.pdf

[5] H. Shacham, “The geometry of innocent flesh on the bone: Return-into-libc without function calls (on the x86)," in Proc. of the 14th ACM Conference on Computer and Communications Security (CCS ’07), 2007.

[6] Phrack Magazine, “Bypassing PaX ASLR protection," http://www.phrack.com/issues.html?issue=59&id=9/

[7] C. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation," Programming Language Design and Implementation (PLDI ’05), 2005.

[8] M. Chew and D. Song, “Mitigating buffer overflows by operating system randomization," Technical Report CMU-CS-02-197, Carnegie Mellon University, Dec. 2002.

[9] S. Forrest, A. Somayaji, and D. H. Ackley, “Building diverse computer systems," Workshop on Hot Topics in Operating Systems, 1997.

[10] D. Williams et al., “Security through Diversity: Leveraging Virtual Machine Technology," IEEE Security and Privacy 7, 2009.

[11] J. E. Just and M. Cornwell, “Review and analysis of synthetic diversity for breaking monocultures," in Proc. of the 2004 ACM workshop on Rapid malcode (WORM ’04), 2004.

[12] C. Wang, “Protection of software-based survivability schemes," Dependable Systems and Networks, 2001.

[13] M. Franz, “E unibus pluram: massive-scale software diversity as a defense mechanism," in Proc. of the 2010 workshop on New security paradigms (NSPW ’10), 2010.

[14] H. Shacham, M. Page, B. Pfaﬀ, E. Goh, N. Modadugu, and D. Boneh, “On the effectiveness of address-space randomization," in Proc. of the 11th ACM conference on Computer and communications security (CCS ’04), 2004.

[15] P. Philippaerts, Y. Younan, S. Muylle, F. Piessens, S. Lachmund, and T. Walter, “Code Pointer Masking: Hardening Applications against Code Injection Attacks," in Proc. of the 8th International Conference on Detection of Intrusions and Malware, and Vulnerability Assessment (DIMVA ’11), 2011.

[16] E. Lee and C. Zilles, “Branch-on-random," in Proc. of the 6th annual IEEE/ACM international symposium on Code generation and optimization (CGO ’08), 2008.

[17] C. Cowan, C. Pu, D. Maier, H. Hinton, P. Bakke, S. Beattie, A. Grier, P. Wagle, and Q. Zhang, “StackGuard: Automatic detection and prevention of buffer-overflow attacks," in Proc. of the 7th USENIX Security Symposium (Security ’98), 1998.

[18] C. Cowan, S. Beattie, J. Johansen, and P. Wagle, “Pointguard: protecting pointers from buffer overflow vulnerabilities," in Proc. of the 12th USENIX Security Symposium (Security ’03), 2003.

[19] “Bzip2 for Windows," http://gnuwin32.sourceforge.net/packages/bzip2.htm

[20] MSDN, “Dynamic-Link Libraries," http://msdn.microsoft.com/en-us/library/windows/desktop/ms682589%28v=vs.85%29.aspx

[21] Dionysus Blazakis, “Interpreter Exploitation: Pointer Inference and JIT Spraying," in BlackHat DC, 2010.

[22] A. Skaletsky, T. Devor, N. Chachmon, R. Cohn, K. Hazelwood, V. Vladimirov, and M. Bach, “Dynamic program analysis of Microsoft Windows applications," in Proc. of IEEE International Symposium on Performance Analysis of Systems & Software (ISPASS ’10), 2010.

[23] Vasilis Pappas, Michalis Polychronakis, and Angelos D. Keromytis, “Smashing the Gadgets: Hindering Return-Oriented Programming Using In-Place Code Randomization," in the Proc. of the 33rd IEEE Symposium on Security & Privacy (S&P ’12), 2012.

[24] L. Davi, A.-R. Sadeghi, and M. Winandy, “ROPdefender: A practical protection tool to protect against return-oriented programming," in Proc. of the 6th Symposium on Information, Computer and Communications Security (ASIACCS ’11), 2011.

[25] metasploit Exploit DB, “Windows ANI LoadAniIcon() Chunk Size Stack Buffer Overflow (SMTP)," http://www.metasploit.com/modules/exploit/windows/email/ms07_017_ani_loadimage_chunksize

[26] Bugzilla, “Mandatory ASLR on Windows for binary components," https://bugzilla.mozilla.org/show_bug.cgi?id=728429

[27] Microsoft TechNet Blogs, “Introducing EMET v3," http://blogs.technet.com/b/srd/archive/2012/05/15/introducing-emet-v3.aspx

[28] PaX Team, “Address Space Layout Randomization," http://pax.grsecurity.net/docs/aslr.txt

[29] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham, and M. Winandy, “Return-oriented programming without returns," in Proc. of the 17th ACM conference on Computer and communications security (CCS ’10), Oct 2010.

[30] PaX Team, “VMA Mirroring," http://pax.grsecurity.net/docs/vmmirror.txt

[31] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and L. Xie, “DROP: Detecting return-oriented programming malicious code," in Proc. of the 5th International Conference on Information Systems Security (ICISS ’09), 2009.

[32] B. Salamat, A. Gal, and M. Franz, “Reverse stack execution in a multi-variant execution environment," in Workshop on Compiler and Architectural Techniques for Application Reliability and Security (CATARS), 2008.

[33] C. Giuﬀrida, A. Kuijsten, and A. S. Tanenbaum, “Enhanced operating system security through efficient and fine-grained address space randomization," in Proc. of the 21st USENIX Security Symposium (Security ’12), 2012.

[34] R. Wartell, V. Mohan, K. W. Hamlen, Z. Lin, “Binary Stirring: Self-randomizing Instruction Addresses of Legacy x86 Binary Code," in Proc. of the 19th ACM conference on Computer and communications security (CCS ’12), 2012.