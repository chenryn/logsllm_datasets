cial applications and such (cid:192)aws should be (cid:191)xed independently. In
any case, for applying our proposal to programs with dynamically
generated codes in general, it needs to be implemented at the appli-
cation layer.
6.1.4 Dynamically Loaded Libraries
As stated in the previous section, our current implementation can
target only one program image, which is the executable (cid:191)le image.
Because most programs load tens of additional DLLs after the load-
ing of main executable (cid:191)le, and because in many cases majority of
executed instruction exist in DLLs, the eﬀect of this may not be
negligible. Also, the loading of DLLs is sometimes delayed until it
is actually used, and because our proposal incurs considerable ini-
tial overhead, this may become a problem if it occurs too frequently
during middle of execution.
6.1.5 Execution Environment
Because the Pin module itself cannot be the target of code shred-
ding and it will be loaded to the same address space as the targeted
software, the attacker may perform an attack by returning into Pin
code. Therefore, it is more preferable to implement it in a more
isolated layer such as the OS layer, the hypervisor layer, or even
the hardware layer.
6.2 Related Works
Here we describe and compare some other research works, which
share common ideas with our proposal.
Software Diversi(cid:191)cation
Software diversi(cid:191)cation changes the software and/or the execution
environment in such a way that the attacker cannot succeed the at-
tack unless he knows how it is changed. A well-known approach
is instruction set randomization[3] which encodes instructions with
a secret randomized key and decodes them right before execution
making code injected by the attacker not decodable. There are other
approaches such as stack reversing[32], but while such approaches
are valid for preventing code injection they do not prevent control
(cid:192)ow hijacking. Our approach is similar to software diversi(cid:191)cation
in the sense that similar idea is applied the addresses themselves,
making overwriting, or injection of addresses impossible.
ROP prevention
The recent increase in the number and complexity of ROP(return-
oriented programming) attacks have lead to many proposals spe-
cialized for defending against such attacks, for example by moni-
toring the frequency of return instructions[31]. Recently, a method
to eliminate ROP gadgets by static conversion of binaries has been
proposed[23], which seems to be a quite eﬀective and practical
measure against ROP. Our method is not limited to ROP attacks and
can prevent a more broad range of attacks which includes return-
to-libc, ROP without returns[29], and other type of control-(cid:192)ow
hijacking attacks that may be invented in the future.
Pointer Encryption
The most similar, and perhaps the most competing approach to
ours would be the defensive measures based on encryption of ad-
dresses[18]. While their security depends on a solid cryptographic
base instead of probability, encryption tend to cause high overhead.
Also, while our approach encodes an address in a form still directly
usable by instructions, such encrypted addresses require decryption
before usage.
Shadow Stack
Another well-known approach is to keep track of the return address
on a shadow stack which emulates the real stack, and upon func-
tion returns compare the return address to the saved values as in,
for example ROPDefender[24]. An obvious limitation of such ap-
proach, aside from requiring extra memory for shadow stack, is that
it can only defend against attacks that modify return addresses. One
might argue that other types of addresses can also be checked by
extending shadow stack to keep the copies of them; however, such
addresses do not always stay stay at the same location like return
addresses, and they are moved and copied to other places such as
heap, stack, and of course, registers. It is hard to track these with-
out applying a technique such as taint analysis which is extremely
performance-intensive. In contrast, in our scheme the information
needed to validate addresses are self-contained.
Control Flow Integrity
Control (cid:192)ow integrity(CFI) is an approach that generates a model of
valid control (cid:192)ow graph through static analysis of the source code
or binary at run-time, and enforces it during execution. While it
allows a more strict and deterministic defense, it incurs heavy run-
time overhead. Also, they tend to suﬀer from false positives when
analysis is not suﬃcient due to lack of debug information which is
common on COTS software.
Other Defensive Approaches
Code Pointer Masking[15] is an approach which is similar to ours
in the sense that it is a probabilistic approach that veri(cid:191)es desti-
nation addresses at runtime. Just before its use, a code pointer is
applied a special mask generated beforehand by OR-ing valid des-
tinations. Applying this mask scrambles the pointer only if it is not
pointing to a valid destination. The disadvantage of this approach,
besides requiring source code analysis, is that as the number of
valid destinations increases, the mask becomes more tolerant thus
allowing more possible false negatives. On the other hand, in our
approach the security strength is independent of the program con-
tent, and is controllable to a certain extent, i.e., the security strength
can be increased to a desired level by increasing the number of seg-
ments as long as memory allows.
In-OS address space layout randomization is studied in the re-
cent work[33] and it is claimed that information leakage is a more
serious issue in the kernel context which motivates our work. Also,
their idea of live re-randomization may be applied to complement
our system for further strengthening. Also, binary stirring[34] is
another recent proposal of static binary randomization, where chal-
lenges of transformation is studied throughly, which may be in-
spected to further identify and (cid:191)x our compatibility issues. While
both of these works have advantageous features, they have random-
ization granularity of basic block.
Memory Sharing
The idea of mapping a physical page to multiple pages in virtual
memory had also been proposed a while ago by the PaX project,
as VMA mirroring[30] for Linux systems. The implementation de-
tails of VMA mirroring itself, however may be applicable when ex-
tending our work to Linux. Also, a similar idea in a more general
and transparent manner is implemented on some virtual machine
monitors. For example, KVM provides KSM(Kernel Samepage
Merging) which merges common pages across multiple VMs (and
also common pages within a VM). However, such method requires
heavy scanning of memory and thus usually has long intervals be-
tween scans. It would be interesting to investigate if such scheme
works well with our system.
Randomized Control Flow
Lastly we mention the work Branch-on-Random[16] which, al-
though not a security related work, gave us an inspiration of our
idea. It proposes a unique conditional branch instruction, where
the condition is probability, i.e., decision to take the branch or not
is determined probabilistically at the moment of branch instruction
execution. It is similar to our approach in the sense that the control
(cid:192)ow proceeds in random manner, though in our work the destina-
tion is randomly determined before execution.
7. CONCLUSION
In this paper we presented our novel idea for defending against
control-(cid:192)ow hijacking attacks. This problem has been challenged
by many research works in the past, but what distinguishes our
work from the majority of them is the focus on making the approach
satisfy not only security property, but also compatibility properties
such as not requiring recompilation, code analysis, or preserving
integrity of execution. This focus is derived from the insight that
ASLR, which is the most widespread defense, satis(cid:191)es the latter
property sacri(cid:191)cing the former property.
The main purpose of this paper is the proposal of the overview
and design of this approach, though we also implemented a proto-
type implementation on Pin to perform a brief evaluation on of its
feasibility. We conclude that this approach is expected to be fea-
sible, while for perfect compatibility it may require modifying the
compiler, and such changes should be much simpler than other pro-
posed methods. This work is expecting many further re(cid:191)nements
and evaluation to be done in the future, which includes optimiza-
tions for improving runtime performance, compatibility improve-
ments through crash analysis towards full support for dynamically
loaded images. It would also be an interesting future work to in-
vestigate the advantages and requirements for implementing it on
hardware, or application to Linux.
317
8. REFERENCES
[1] MSDN Library, “Windows ISV Software Security
Defenses," http://msdn.microsoft.com/en-us/
library/bb430720.aspx
[2] Android Developers, “Android 4.0 Platform Highlights,"
http://developer.android.com/sdk/android-4.
0-highlights.html
[3] G. S. Kc, Angelos D. Keromytis, and V. Prevelakis,
“Countering code-injection attacks with instruction-set
randomization," in Proc. of the 10th ACM conference on
Computer and communications security (CCS ’03), 2003.
[4] c0ntex, “Bypassing non-executable-stack during exploitation
using return-to-libc", http://www.infosecwriters.com/
text_resources/pdf/return-to-libc.pdf
[5] H. Shacham, “The geometry of innocent (cid:192)esh on the bone:
Return-into-libc without function calls (on the x86)," in Proc.
of the 14th ACM Conference on Computer and
Communications Security (CCS ’07), 2007.
[6] Phrack Magazine, “Bypassing PaX ASLR protection",
http:
//www.phrack.com/issues.html?issue=59&id=9/
[7] C. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney,
S. Wallace, V. J. Reddi, and K. Hazelwood, “Pin: Building
Customized Program Analysis Tools with Dynamic
Instrumentation," Programming Language Design and
Implementation (PLDI ’05), 2005.
[8] M. Chew and D. Song,“Mitigating buﬀer over(cid:192)ows by
operating system randomization," Technical Report
CMU-CS-02-197, Carnegie Mellon University, Dec. 2002.
[9] S. Forrest, A. Somayaji, and D. H. Ackley, “Building diverse
computer systems," Workshop on Hot Topics in Operating
Systems, 1997.
[10] D. Williams et al. “Security through Diversity: Leveraging
Virtual Machine Technology," IEEE Security and Privacy 7,
2009.
[11] J. E. Just and M. Cornwell. “Review and analysis of synthetic
diversity for breaking monocultures," in Proc. of the 2004
ACM workshop on Rapid malcode (WORM ’04), 2004.
[12] C. Wang, “Protection of software-based survivability
schemes", Dependable Systems and Networks, 2001.
[13] M. Franz, “E unibus pluram: massive-scale software
diversity as a defense mechanism," in Proc. of the 2010
workshop on New security paradigms (NSPW ’10), 2010.
[14] H. Shacham, M. Page, B. Pfaﬀ, E. Goh, N. Modadugu, and
D. Boneh, “On the eﬀectiveness of address-space
randomization," in Proc. of the 11th ACM conference on
Computer and communications security (CCS ’04), 2004.
[15] P. Philippaerts, Y. Younan, S. Muylle, F. Piessens, S.
Lachmund, and T. Walter, “Code Pointer Masking:
Hardening Applications against Code Injection Attacks," in
Proc. of the 8th International Conference on Detection of
Intrusions and Malware, and Vulnerability Assessment
(DIMVA ’11), 2011.
[16] E. Lee and C. Zilles, “Branch-on-random," in Proc. of the
6th annual IEEE/ACM international symposium on Code
generation and optimization (CGO ’08), 2008.
[17] C. Cowan, C. Pu, D. Maier, H. Hinton, P. Bakke, S. Beattie,
A. Grier, P. Wagle, and Q. Zhang, “StackGuard: Automatic
detection and prevention of buﬀer-over(cid:192)ow attacks," in Proc.
of the 7th USENIX Security Symposium(Security ’98),
1998.
[18] C. Cowan, S. Beattie, J. Johansen, and P. Wagle,
“Pointguard: protecting pointers from buﬀer over(cid:192)ow
vulnerabilities," in Proc. of the 12th USENIX Security
Symposium(Security ’03), 2003.
[19] “Bzip2 for Windows," http:
//gnuwin32.sourceforge.net/packages/bzip2.htm
[20] MSDN, “Dynamic-Link Librariesk,"
http://msdn.microsoft.com/en-us/library/
windows/desktop/ms682589%28v=vs.85%29.aspx
[21] Dionysus Blazakis, “Interpreter Exploitation: Pointer
Inference and JIT Spraying," in BlackHat DC, 2010.
[22] A. Skaletsky, T. Devor, N. Chachmon, R. Cohn, K.
Hazelwood, V. Vladimirov, and M. Bach, “Dynamic program
analysis of Microsoft Windows applications," in Proc. of
IEEE International Symposium on Performance Analysis of
Systems & Software (ISPASS ’10), 2010.
[23] Vasilis Pappas, Michalis Polychronakis, and Angelos D.
Keromytis, “Smashing the Gadgets: Hindering
Return-Oriented Programming Using In-Place Code
Randomization," in the Proc. of the 33rd IEEE Symposium
on Security & Privacy (S&P ’12), 2012.
[24] L. Davi, A.-R. Sadeghi, and M. Winandy, “ROPdefender: A
practical protection tool to protect against return-oriented
programming," in Proc. of the 6th Symposium on
Information, Computer and Communications Security
(ASIACCS ’11), 2011.
[25] metasploit Exploit DB, “Windows ANI LoadAniIcon()
Chunk Size Stack Buﬀer Over(cid:192)ow (SMTP)",
http://www.metasploit.com/modules/exploit/
windows/email/ms07_017_ani_loadimage_chunksize
[26] Bugzilla, “Mandatory ASLR on Windows for binary
components," https:
//bugzilla.mozilla.org/show_bug.cgi?id=728429
[27] Microsoft TechNet Blogs, “Introducing EMET v3,"
http://blogs.technet.com/b/srd/archive/2012/
05/15/introducing-emet-v3.aspx
[28] PaX Team, “address space layout randomization,"
http://pax.grsecurity.net/docs/aslr.txt
[29] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H.
Shacham, and M. Winandy, “Return-oriented programming
without returns," in Proc. of the 17th ACM conference on
Computer and communications security (CCS ’10), Oct
2010.
[30] PaX Team, “vma mirroring,"
http://pax.grsecurity.net/docs/vmmirror.txt
[31] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and L. Xie,
“DROP: Detecting return-oriented programming malicious
code," in Proc. of the 5th International Conference on
Information Systems Security (ICISS ’09), 2009.
[32] B. Salamat, A. Gal, and M. Franz, “Reverse stack execution
in a multi-variant execution environment," in Workshop on
Compiler and Architectural Techniques for Application
Reliability and Security(CATARS), 2008.
[33] C. Giuﬀrida, A. Kuijsten, and A. S. Tanenbaum, “Enhanced
operating system security through eﬃcient and (cid:191)ne-grained
address space randomization," in Proc. of the 21st USENIX
Security Symposium(Security ’12), 2012.
[34] R. Wartell, V. Mohan, K. W. Hamlen, Z. Lin, “Binary
Stirring: Self-randomizing Instruction Addresses of Legacy
x86 Binary Code," in Proc. of the 19th ACM conference on
Computer and communications security (CCS ’12), 2012.
318