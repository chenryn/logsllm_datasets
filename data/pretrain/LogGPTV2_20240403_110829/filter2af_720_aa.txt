作者： [Hcamael@知道创宇404实验室](http://0x48.pw)  
发布时间：2017-03-20
上周末的0CTF出现了一个pyc的题目，但是Pyopcode损坏，于是手撸了一波
题目: 
通过pyc还原出py网上的资料挺多了，py也有专门的库可以还原，但是0CTF这题却无法还原，目测是opcode损坏，同时根据题目描述，也知道是要修复pyc文件。
这里用到两个库，一个`dis`，可以把二进制反编译CPython bytecode。一个是`marshal`，可以把字符串转换成pyopcode对象
    >>> import dis, marshal
    >>> f = open("crypt.pyc")
    >>> f.read(4)
    '\x03\xf3\r\n'               # magic number
    >>> f.read(4)                # time
    'f4oX'
    >>> code = marshal.load(f)
    # 对我们有用的属性有:
    >>> code.co_argcount          # 参数的个数
    0
    >>> code.co_varnames          # 局部变量
    ()
    >>> code.co_consts            # 常量 
    (-1, None, , )
    # 从这个常量中我们可以看出，该py文件中定义了两个函数，encrypt和decrypt
    >>> code.co_code                  
    '\x99\x00\x00\x99\x01\x00\x86\x00\x00\x91\x00\x00\x99\x02\x00\x88\x00\x00\x91\x01\x00\x99\x03\x00\x88\x00\x00\x91\x02\x00\x99\x01\x00S'
    # CPython bytecode的二进制, 可以通过dis反编译
    >>> dis.disassemble_string(code.co_code)
              0                0
              3                1
              6 MAKE_CLOSURE        0
              9 EXTENDED_ARG        0
             12                2
             15 LOAD_DEREF          0
             18 EXTENDED_ARG        1
             21                3
             24 LOAD_DEREF          0
             27 EXTENDED_ARG        2
             30                1
             33 RETURN_VALUE   
    # 发现bytecode损坏，根本无法阅读
二进制对应的bytecode可以参考:
从上面的参考连接可以得知153没有对应的bytecode，所以猜测bytecode损坏
每个bytecode所代表的意义: 
    >>> code.co_name              # 当前对象名 
    ''
    >>> code.co_names             # 当前对象中使用的对象名
    ('rotor', 'encrypt', 'decrypt')          
    # 从上可以看出，encrypt和decrypt是我们定义的两个函数，那么rotor我们可以猜测是通过import rotor得来的
rotor的使用可以参考: 
    # 我们可以通过以下方式查看两个函数中的信息
    >>> enc = code.co_consts[2]
    >>> dec = code.co_consts[3]
    >>> enc.co_argcount
    1
    >>> dec.co_argcount
    1
    # 两个函数中都有一个传入的参数
    >>> enc.co_varnames
    ('data', 'key_a', 'key_b', 'key_c', 'secret', 'rot')
    >>> dec.co_varnames
    ('data', 'key_a', 'key_b', 'key_c', 'secret', 'rot')
    # 两个函数中的局部变量, 我们可以猜测，data是传入的参数，需要加解密的数据
    >>> enc.co_consts
    (None, '!@#$%^&*', 'abcdefgh', '<>{}:"', 4, '|', 2, 'EOF')
    >>> dec.co_consts
    (None, '!@#$%^&*', 'abcdefgh', '<>{}:"', 4, '|', 2, 'EOF')
    # 两个函数中的常量，我们可以猜测key_a, key_b, key_c三个变量对应的值
    >>> enc.co_code
    "\x99\x01\x00h\x01\x00\x99\x02\x00h\x02\x00\x99\x03\x00h\x03\x00a\x01\x00\x99\x04\x00F\x99\x05\x00'a\x02\x00a\x01\x00'a\x03\x00'\x99\x06\x00F'\x99\x05\x00'a\x02\x00\x99\x06\x00F'\x99\x07\x00'h\x04\x00\x9b\x00\x00`\x01\x00a\x04\x00\x83\x01\x00h\x05\x00a\x05\x00`\x02\x00a\x00\x00\x83\x01\x00S"
    >>> dec.co_code
    "\x99\x01\x00h\x01\x00\x99\x02\x00h\x02\x00\x99\x03\x00h\x03\x00a\x01\x00\x99\x04\x00F\x99\x05\x00'a\x02\x00a\x01\x00'a\x03\x00'\x99\x06\x00F'\x99\x05\x00'a\x02\x00\x99\x06\x00F'\x99\x07\x00'h\x04\x00\x9b\x00\x00`\x01\x00a\x04\x00\x83\x01\x00h\x05\x00a\x05\x00`\x02\x00a\x00\x00\x83\x01\x00S"
    # 发现两个函数bytecode的二进制是一样的，操作是一样的？
    >>> enc.co_name
    'encrypt'
    >>> enc.co_names
    ('rotor', 'newrotor', 'encrypt')
    >>> dec.co_name
    'decrypt'
    >>> dec.co_names
    ('rotor', 'newrotor', 'decrypt')
    # 通过研究rotor的用法，猜测两个函数的区别可能是在于rotor.newrotor(key).encrypt(data)和rotor.newrotor(key).decrypt(data)
所以现在的问题就在于，`key`是怎么来的，然后就开始了手撸CPython bytecode
    >>> dis.disassemble_string(dec.co_code)
              0                1
              3 BUILD_SET           1
              6                2
              9 BUILD_SET           2
             12                3
             15 BUILD_SET           3
             18 STORE_GLOBAL        1 (1)
             21                4
             24 PRINT_EXPR     
             25                5
             28            
             29 STORE_GLOBAL        2 (2)
             32 STORE_GLOBAL        1 (1)
             35            
             36 STORE_GLOBAL        3 (3)
             39            
             40                6
             43 PRINT_EXPR     
             44            
             45                5
             48            
             49 STORE_GLOBAL        2 (2)
             52                6
             55 PRINT_EXPR     
             56            
             57                7
             60            
             61 BUILD_SET           4
             64                0
             67 DELETE_ATTR         1 (1)
             70 STORE_GLOBAL        4 (4)
             73 CALL_FUNCTION       1
             76 BUILD_SET           5
             79 STORE_GLOBAL        5 (5)
             82 DELETE_ATTR         2 (2)
             85 STORE_GLOBAL        0 (0)
             88 CALL_FUNCTION       1
             91 RETURN_VALUE   
右边的数字为操作数，括号里的是注释
因为题目啥信息也没给我们。。。所以修bytecode只能靠猜
我们先假设这里所有的153为同一个操作符，同理所有的39也为同一个
先看第一部分
              0                1
              3 BUILD_SET           1
              6                2
              9 BUILD_SET           2
             12                3
             15 BUILD_SET           3
这是最容易猜的地方，右边的操作数为123，在看常量和局部变量的tuple，可以猜测是:
    key_a = '!@#$%^&*'
    key_b = 'abcdefgh'
    key_c = '<>{}:"'
然后去上面给的参考文档里，查出对应的bytecode
              0 LOAD_CONST           1
              3 STORE_FAST           1
              6 LOAD_CONST           2
              9 STORE_FAST           2
             12 LOAD_CONST           3
             15 STORE_FAST           3
再去`opcode.h`中查其对应的值进行替换
    >>> dis.disassemble_string(dec.co_code.replace("\x99","\x64").replace("\x68","\x7d"))
              0 LOAD_CONST          1 (1)
              3 STORE_FAST          1 (1)
              6 LOAD_CONST          2 (2)
              9 STORE_FAST          2 (2)
             12 LOAD_CONST          3 (3)
             15 STORE_FAST          3 (3)
             18 STORE_GLOBAL        1 (1)
             21 LOAD_CONST          4 (4)
             24 PRINT_EXPR     