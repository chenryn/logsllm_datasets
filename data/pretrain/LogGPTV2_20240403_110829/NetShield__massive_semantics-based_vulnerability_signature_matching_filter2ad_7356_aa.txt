title:NetShield: massive semantics-based vulnerability signature matching
for high-speed networks
author:Zhichun Li and
Gao Xia and
Hongyu Gao and
Yi Tang and
Yan Chen and
Bin Liu and
Junchen Jiang and
Yuezhou Lv
NetShield: Massive Semantics-Based Vulnerability
Signature Matching for High-Speed Networks
Zhichun Li§ Gao Xia† Hongyu Gao§ Yi Tang† Yan Chen§ Bin Liu† Junchen Jiang† Yuezhou Lv†
§ Northwestern University
† Tsinghua University, China
ABSTRACT
Accuracy and speed are the two most
important metrics for
Network Intrusion Detection/Prevention Systems (NIDS/NIPSes).
Due to emerging polymorphic attacks and the fact that in many
cases regular expressions (regexes) cannot capture the vulnera-
bility conditions accurately, the accuracy of existing regex-based
NIDS/NIPS systems has become a serious problem. In contrast,
the recently-proposed vulnerability signatures [10, 29] (a.k.a. data
patches) can exactly describe the vulnerability conditions and
achieve better accuracy. However, how to efﬁciently apply vul-
nerability signatures to high speed NIDS/NIPS with a large ruleset
remains an untouched but challenging issue.
This paper presents the ﬁrst systematic design of vulnerability
signature based parsing and matching engine, NetShield, which
achieves multi-gigabit throughput while offering much better ac-
curacy. Particularly, we made the following contributions:
(i)
we proposed a candidate selection algorithm which efﬁciently
matches thousands of vulnerability signatures simultaneously re-
quiring a small amount of memory; (ii) we proposed an auto-
matic lightweight parsing state machine achieving fast protocol
parsing. Experimental results show that the core engine of Net-
Shield achieves at least 1.9+Gbps signature matching throughput
on a 3.8GHz single-core PC, and can scale-up to at least 11+Gbps
under a 8-core machine for 794 HTTP vulnerability signatures. We
release our prototype and sample signatures at www.nshield.org.
Categories and Subject Descriptors:
Communication Networks]: General - Security and protection
General Terms: Algorithms, Design, Performance, Security
Keywords: vulnerability signature, intrusion detection, signature
matching, deep packet inspection
C.2.0 [Computer-
1.
INTRODUCTION
Keeping networks safe has been a grand challenge for the current
Internet. The outbreak of the Conﬁcker worm/botnet [2] at the end
of 2008 shows that remote exploits are still a major threat to the
Internet today. The Conﬁcker worm mainly exploited a WINRPC
remote code execution vulnerability (MS08-067), infected 9 ∼ 15
million hosts [2]. For such attacks, network-based Intrusion Detec-
tion/Prevention Systems (NIDS/NIPSes) are of critical importance
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
SIGCOMM’10, August 30–September 3, 2010, New Delhi, India.
Copyright 2010 ACM 978-1-4503-0201-2/10/08 ...$10.00.
because they protect the enterprise or an ISP as a whole including
the users who do not apply patches or host-based defense schemes
for various reasons (reliability, overhead, conﬂicts, etc.). Operating
on routers/gateways, NIDS/NIPS can prevent attacks such as the
Conﬁcker worm from spreading.
Two metrics are extremely important
for signature-based
NIDS/NIPS: accuracy and speed. Accuracy is of particular impor-
tance, especially for an NIPS that throttles the connections which
are identiﬁed as malicious by matching pre-deﬁned signatures. It
requires the signatures to be accurate enough, so that the NIPS can
drop the packets with full conﬁdence. Meanwhile, NIDSes/NIPSes
have to maintain high speed (e.g., 10s of Gbps) nowadays.
1.1 State of the Art
For high speed NIDS/NIPSes, the de facto standard approach
is to employ regex (regular expression) based matching engines.
On the other hand, vulnerability signatures [9, 10, 29] have been
proposed, but still have not been used in NIDS/NIPSes due to the
low matching efﬁciency.
Regexes can be easily combined and matched simultaneously in
a single pass over the input. Given this nice feature, most commer-
cial NIDSes/NIPSes, e.g., the products from Cisco and Juniper, as
well as some open source ones, e.g., Bro [21], use a regex-based
matching engine to keep up with line speed. In such engines, each
signature is a regex. The content of a connection is treated as a
string and is matched against multiple regex signatures simultane-
ously. The latest research efforts [7, 8, 17, 25, 26, 30] assume regex
can provide enough accuracy and focus on increasing its speed
while reducing the memory occupation.
However, their assumption “regexes can provide enough accu-
racy” is questionable. Attackers have already developed polymor-
phic and metamorphic variations to evade detection [10]. In many
cases, the protocol/application semantics and states are required
to express the vulnerability conditions [29], which needs context-
sensitive parsing. To say the least, even context-free languages have
insufﬁcient expressive power. Therefore, theoretically, regexes are
infeasible to fully avoid false positives and false negatives, which
is indeed true in practice. For example, due to the complexity of
the NetBIOS/SMB/WINRPC protocol stack, it is almost impossi-
ble to write an accurate regex signature to detect the polymorphic
versions of the Blaster worm or the recent Conﬁcker worm. Be-
sides, we also ﬁnd many other similar cases in different protocols
such as HTTP and DNS.
In comparison, the seminal work [10, 29] proposed the concept
of vulnerability signatures (a.k.a., data patches [13]) that achieve
better accuracy than regex-based approaches. As advocated in [9,
29], a vulnerability signature is based on the thorough understand-
ing of both the network protocol and the application context.
It
leverages semantic information to exactly describe all the possible
ways in which a vulnerability can be exploited over the network.
279h
g
H
i
State of the 
art regex sig
IDSes
NetShield
d
e
e
p
S
Theoretical accuracy 
limitation of regex
w
o
L
Low
Existing 
Vulnerability 
sig IDSes
High
Accuracy
Figure 1: Comparing NetShield with existing approaches.
Most previous work on vulnerability signatures focuses on auto-
mated vulnerability signature generation [10, 12]. However, how
to match a large number of vulnerability signatures efﬁciently has
not been well studied. To the best of our knowledge, all the exist-
ing approaches [9, 22, 29] use sequential matching, i.e., matching
signatures one by one, leading to low speed.
Since a high-speed NIDS/NIPS protects a large number of di-
verse hosts, it usually has a large signature ruleset to cover all pos-
sible vulnerabilities. For example, Snort has more than 6,000 sig-
natures. Cisco IPS has about 2,000 signatures. For both systems,
even some single protocol, such as HTTP, has hundreds or even
thousands of signatures. Therefore, matching a large vulnerability
signature ruleset at high speed is a practical requirement.
In Figure 1, we compare our approach with existing ones in terms
of accuracy and speed. Due to the theoretical limitation, to improve
the accuracy of a regex-based approach is extremely hard. On the
other hand, the existing vulnerability signature approaches with se-
quential matching cause low throughput. The key challenge is how
to speed up vulnerability signature matching with large vulnerabil-
ity rulesets. Furthermore, another challenge is to parse the trafﬁc
and to recover the protocol semantic information fast enough for
signature matching.
1.2 Our Contributions
To address the challenges above, we design and implement a vul-
nerability based NIDS/NIPS prototype (named N etShield). Net-
Shield obtains high throughput comparable to that of the state-of-
the-art regex-based NIDS/NIPS while offering much better accu-
racy. In particular, we made the following contributions:
1) An efﬁcient multiple signature matching scheme for a large
number of vulnerability signatures. By formulating the multi-
ple vulnerability signature matching problem, we devise a tabular
presentation of vulnerability rulesets. This promotes us to design a
novel algorithm called Candidate Selection (in short, CS) to match
multiple vulnerability signatures simultaneously. The CS algorithm
enables high-speed massive vulnerability signature matching with
small memory requirement. As far as we know, this is the ﬁrst re-
search effort to formulate and solve the multiple vulnerability sig-
nature matching problem (§4).
2) Fast stream-fashioned lightweight parsing. We make two ob-
servations: (i) buffering and parse tree traversal are not necessary
when the parsing is solely for signature matching; and (ii) These
two overheads can be eliminated with proper design. We design
the UltraPAC, an automatic parsing state machine generator. The
generated parsing state machine can accurately parse out all the re-
quired ﬁelds avoiding unnecessary cost. Evaluation with real traces
shows UltraPAC parser is about 3 ∼ 12 times faster than the Bin-
PAC parser [20] (§5).
3) Evaluation and Methodology. By analyzing the vulnerabili-
ties that the Snort ruleset targets, we create the vulnerability signa-
tures for those vulnerabilities. We implement a software NetShield
prototype (§6) and release to public [4]. In §7, experimental re-
sults show that, on a single-core 3.8Ghz PC, our core engine can
BIND:
rpc_vers==5 && packed_drep==’\x10\x00\x00\x00’
&& abstract_syntax.uuid==UUID_IRemoteActivation
&& abstract_syntax.version=="0.0"
BIND-ACK:
rpc_vers==5
CALL:
rpc_vers==5 && packed_drep==’\x10\x00\x00\x00’
&& opnum==0x00 && stub.RAbody.actual_length>=40
&& matchRE(stub.RAbody.buffer,
/^\x5c\x00\x5c\x00/)
Figure 2: Vulnerability signature for MS03-026.
achieve 6.7+Gbps parsing speed on HTTP, and 1.9+Gbps parsing
plus matching speed for 794 HTTP vulnerability signatures with
2.3MB memory for the matching data structures. On a 8-core ma-
chine we boost the matching throughput to 11+Gbps.
After §7, we discuss related work in §8. Finally we present dis-
cussions and conclusions in §9 and §10 respectively.
2. BACKGROUND AND MOTIVATIONS
2.1 What Is a Vulnerability Signature?
Vulnerabilities that can be exploited remotely are the result of
faulty program logic. They may be triggered when the program
handles inputs from networks. Wang et al. ﬁrst propose the con-
cept of vulnerability signature [13, 29], and point out that protocol
semantic information is particularly useful for specifying such sig-
natures. Brumley et al. argue that a perfect vulnerability signature
has to be a Turing machine, but unfortunately matching such signa-
tures is undecidable in general [10]. They propose to use symbolic
constraints as vulnerability signatures. Similar to their deﬁnition,
in this paper, we deﬁne a vulnerability signature as a set of sym-
bolic predicates based on the protocol semantic information. This
form of vulnerability signatures can express most known vulner-
ability conditions precisely. Based on the principle of optimizing
common cases, our design mainly speeds up the matching speed of
symbolic predicate signatures. In §9, we show that NetShield can
be easily extended to support more complex cases.
To recover the protocol semantic information, we need to parse
the input. In addition, a protocol state machine (a.k.a., vulnera-
bility state machine in [29]) is required for adjusting the protocol
states when sending/receiving different protocol data units (PDUs).
PDUs are the atomic data units that are sent between two appli-
cation endpoints. A PDU can be dissected into multiple protocol
ﬁelds. Here, a ﬁeld means a sub-sequence of bytes inside the PDU
with certain semantic meaning or functionality. For a multi-PDU
protocol, the protocol parser associates the related PDUs to differ-
ent sessions. The PDUs in one session correspond to a single in-
stance of the protocol state machine. The predicates of vulnerabil-
ity signatures are deﬁned on the sequence of PDUs in one session,
one for each PDU. They are written as a set of conditions based
on the PDU’s protocol ﬁelds. If all the predicates required by the
vulnerability signature are true, the signature is matched.
An example for illustration: As an example, we consider the
MS03-026 vulnerability exploited by the Blaster worm.
It is a
stack buffer overrun vulnerability in the WINRPC protocol. WIN-
RPC is a stateful protocol. A typical WINRPC call starts with a
BIND PDU from the client side, asking to bind to a particular API.
The server receives the request and responds with the BIND-ACK
PDU for acknowledgement. After that, the client issues a remote
function call (CALL PDU) using opnum as the ID of the function,
followed by the required parameters.
If the length of the buffer
actual_length is longer than 40, a buffer overrun will be trig-
gered. Figure 2 shows the corresponding vulnerability signature1.
Since the signature captures the vulnerability conditions exactly,
1It is the same as the one generated in ShieldGen [13].
280Protocol
Vulnerability 
Spec.
Ruleset
UltraPAC
Rule Compiler
Traffic 
Capture
TCP 
Protocol 
Reassembly
Identification
Protocol 
Parser
Individual 
Matchers
CS Algorithm
Figure 3: NetShield System Architecture.
Core Engine
it can stop the Blaster worm in addition with all possible exploits
(including future ones) of this vulnerability.
Moreover, given vulnerability signatures are more expressive,
the number of signatures can be reduced when covering the same
vulnerability set. This is especially true for complex binary proto-
cols, which are harder to describe with regexes. For example, on
average 1.2 Snort HTTP signatures can be reduced to one vulnera-
bility signature, but for WINRPC the ratio is as high as 67.6:1. To
some extent, this reduction also helps to improve the performance
of signature matching.
2.2 Only Relying on Regex Is Insufﬁcient
Can we accurately express vulnerability signatures in regexes
only? The answer is no. The reason is twofold.
Regex cannot achieve accurate parsing: Fundamentally, to re-
cover protocol semantics requires context-sensitive parsing. Regex
language is a special subset of context-free language. Thus, in the-
ory, it lacks the expressive power to accurately parse complex pro-
tocol grammars. In practice, real-world protocols are sophisticated
enough to render regex incapable. For example, the HTTP pro-
tocol encodes the length of chunked HTTP body in another ﬁeld.
Regexes fail to identify the boundary of the body in this case. In
the DNS protocol, DNS labels can be either a string with variable
length or a pointer. Regexes cannot dereference a pointer. There
are similar cases in SSL, SNMP and other protocols.
Regex cannot help with multi-ﬁeld matching: Regexes assume
the input as one single raw byte string. In contrast, vulnerability
signatures need to match multiple protocol ﬁelds in different data
types (number or string) and combine the matching results to make
the decision. For the multi-PDU protocols, the protocol state ma-
chine further adds another layer of complexity. It is very hard to
extend any regex approaches for vulnerability signatures.
We argue that, although regexes are useful, only relying on them