### 1. Introduction

#### 1.1 Contribution

We present several key contributions in this work. First, we introduce a new class of attacks on key exchange protocols called "no-match attacks." In a no-match attack, the attacker slightly modifies the messages exchanged between two oracles such that the keys computed by these oracles remain equal. However, the critical point is that the oracles are not partnered due to the introduced modifications. In all existing security models, this can be exploited to break the security by revealing the session key of one oracle to answer the Test-query for the other. We use no-match attacks to demonstrate that providing sound security analyses for key exchange protocols under matching conversation (MC)-based definitions of partnering is challenging and error-prone.

In particular, we show that for a diverse collection of security protocols, the corresponding security proofs are flawed. To illustrate this, we provide detailed descriptions of successful adversaries. The set of protocols we consider is not exhaustive, and we believe many more security proofs to be flawed or at least incomplete, as they do not formally rule out no-match attacks (even though the protocol may protect against them).

We present three methods to counter no-match attacks. These solutions vary in the additional complexity added to the protocol and the additional theoretical assumptions required in the security proof compared to the original protocol. This allows for the selection of necessary modifications to the protocol (to make it provably secure) in a way that suits the application it is used in.

As our main solution and a major contribution, we introduce a new definition of partnering that precisely invalidates no-match attacks. We provide several arguments for why our notion is superior to previous notions of partnering:
1. Our definition can be generically integrated into all existing security definitions.
2. It is independent of the analyzed protocol, making it very general.
3. It can be verified easily, i.e., whether two oracles are partnered is decided solely by checking a single cryptographic value.
4. It supports efficient falsification, allowing us to determine if a protocol cannot provide a proof of security at all.
5. It formalizes and supports cryptographic intuition, unlike some existing definitions.
6. Our new definition of partnering supports a form of composability that MC-based notions lack, and even a slightly stronger form of it. Specifically, protocols proven secure under our definitions remain secure even if additional messages are exchanged that depend on the public values of the protocol.

Finally, we show how to address no-match attacks in security models that also formalize explicit authentication. We provide a new notion of explicit authentication that, similar to before, renders no-match attacks ineffective. This new definition again supports the basic form of composability that MC-based notions lack. As a stepping stone and of independent interest, we essentially decouple authentication from the used partnering definition.

#### 1.2 Related Work

The importance of precise security definitions for rigorous cryptographic analysis is well-recognized by cryptographers [25, 32] and cannot be overstated. Ultimately, one must first provide a precise definition of security before constructing a scheme that provably achieves it. No-match attacks highlight the difficulty in precisely defining trivial attacks for key exchange protocols. Similar observations have been made for other primitives. For instance, Bellare, Hofheinz, and Kiltz showed that for public key encryption schemes, there exist several non-equivalent variants for formalizing that the challenge ciphertext may not be asked to the decryption oracle [4]. Their analysis led to the isolation of the strongest existing definition and its recommendation for future use.

Our results are similar in that they analyze different ways to define trivial attacks for an important cryptographic primitive but go further. We not only show that the existing ways of formalizing trivial attacks are not equivalent; we also present new, subtle attacks that reveal flaws in formal security proofs that have been overlooked for years. Moreover, we demonstrate that the most popular definition of trivial attacks—via matching conversations—is unsuitable for cryptographic practice. Finally, we provide a new definition that addresses many of the problems of existing definitions (lack of composability, unrealistic no-match attacks) while retaining important advantages.

There are a few papers that consider attacks related to the definition of partnering in key exchange protocols. Notably, in 2005, Choo and Hitchcock [18] presented an attack on the Jeong-Katz-Lee protocol TS2 [30] and the three-party protocol 3PKD of Bellare and Rogaway [7]. Using our terminology, their attack on the 3PKD protocol can be interpreted as a simple no-match attack (without advice). In 2007, Bresson, Manulis, and Schwenk [13] showed that under the original security definition for group key exchange by Bresson, Chevassut, Pointcheval, and Quisquater [12], there exist protocols where the adversary may impersonate users or where two partnered oracles accept with different keys. However, the authors explicitly stated that these problems only appear in the group setting with at least three parties.

The authors of [29] were pointed to a subtle problem with the definition of partnering that, in retrospect, can be interpreted as a no-match attack (see the most recent full version [40]). This issue was also observed by [16]. We emphasize that the above works only consider attacks on single protocols. In contrast, our work provides a very general attack strategy that can be applied to a variety of protocols. We also introduce no-match attacks with advice, showing that no-match attacks can be much harder to avoid (and more subtle) when the adversary has access to strong queries, like in KCI attacks or when modeling forward secrecy.

In 2011, Cremers provided an in-depth analysis and comparison of three of the most widespread security models: the CK, the CK+ (or HMQV), and the eCK model [19]. He showed that these models are formally and practically incomparable, meaning that for every pair of models, one can find protocols that are secure in the first model but not in the second (and vice versa). Crucially, he exploited the fact that the security models have different ways to formalize partnering and, in particular, different ways of defining security for non-symmetric protocols. Moreover, Cremers showed that the proofs of several protocols are not complete. In some models, protocols may have computed distinct keys even though they are formally partnered. Our no-match attacks are orthogonal to this, where oracles have the same key but do not have matching conversations. This not only makes proofs incomplete but also allows us to describe concrete and often very subtle (no-match) attacks.

However, there is a more fundamental difference between our work and that of Cremers. Like some previous works, Cremers focuses on and suggests using definitions of partnering that guarantee that two oracles have computed the same key if and only if they are partnered. We show that this is not an appropriate way to deal with no-match attacks and propose a distinct and conceptually new definition of partnering. Our definition requires that two (or more) oracles have computed the same key and that this key must additionally be equal to a special (ideal) key that depends only on the two oracles, not the attacker. Our results are not restricted to certain security models but reveal a general problem (and possible solutions) when defining security in the realm of key exchange and authentication protocols.

The authors of [33] also introduce a new partnering definition that aims to fix the problem that occurs "if the partnering definition takes information into account that is irrelevant to the computation of the session key." This notion is incomparable to ours and all other existing notions and is, as sketched before, very counter-intuitive. Essentially, it defines that two oracles are partnered if they have the same key and no other oracle has that key. We also note that concentrating only on "irrelevant" information is not sufficient. Our results show that no-match attacks are also possible by modifying messages that are crucial to the computation of the message (also see Remark 1).

#### 1.3 Open Problems

In this paper, we provide a collection of flawed security analyses that show that the corresponding protocols fail to meet their stated security claims. We stress that our list is not exhaustive. We focus on protocols that are proven secure in widespread security models. Given the popular use of session identifiers based on matching conversations and the wide popularity of the original BR, CK+, eCK, and ACCE models, we believe that many other security proofs are vulnerable to no-match attacks. Furthermore, it remains an interesting open problem to more practically exploit a no-match attack in a real-world protocol, although we have little hope in this regard. Finally, in Section 7, we consider potential future relaxations of our new security notion and conceptual and technical obstacles towards them.

#### 1.4 A Note on Formalism

To focus on the subtle core problem surrounding no-match attacks, we aim to keep our results as light on key exchange formalism as possible. More rigorous, technical definitions can be found in the cited security models. A brief overview of key exchange models is given in Appendix A. We stress that in several ways, our results do not rely on concrete formalizations of security definitions. For example, for our purposes, it does not matter if we use the definition of matching conversations given in [6], [29], or the one given implicitly in [35]. For our purposes, these definitions can be regarded as equivalent, all essentially trying to capture that everything sent by one oracle is actually received by the second and vice versa. Our result relies on this conceptual core of the definition, not a concrete formalism. Therefore, we sometimes refrain from providing a concrete definition in this paper and base our reasoning on it, instead referring to the literature for concrete formalizations.

#### 1.5 Overview

We start with a gentle introduction to no-match attacks in Section 2. In Section 3, we present a diverse list of no-match attacks against existing security protocols, revealing subtle flaws in the security proofs of the protocols. A detailed, step-by-step example of such an attack can be found in Appendix B. Altogether, we provide three solutions to deal with no-match attacks. In Section 4, we present our first solution and main contribution: a new partnering notion that does not require any modification of the protocol implementation to deal with no-match attacks. We extend our results in Section 5 to provide a new definition of explicit authentication for key exchange that helps to deal with no-match attacks in security models with explicit authentication. In Section 6, we show how to use our new security notion as a more general tool to strengthen existing security definitions. Finally, Section 7 contains an outlook on how our new security notion might be extended further. Additionally, we present several arguments why such an extension may indeed be rather difficult to achieve when it adheres to the high standards that we require (and which are so common in most other fields of cryptography). In Appendix C, we show in a formal way that security models based on matching conversations cannot be composed with arbitrary random messages, even if those messages are independent of the protocol. Next, we show that, in contrast, our new notion of partnering does provably fulfill this and even a stronger form of composition (where the additional messages may even be generated from the public values of the protocol). Finally, in Appendix E, we describe two alternative approaches (and their limitations) to deal with no-match attacks in existing security models. These solutions either rely on a careful instantiation of the primitives or on a (slight) modification of the protocol layout.

### 2. No-Match Attacks

In this section, we introduce no-match attacks. To precisely capture no-match attacks, we first introduce the notion of original keys. This will also be central to the new partnering definitions we provide later.

#### 2.1 Definition of Original Key

**Definition 2.1 (Original Key):** The original key of a pair of communicating oracles is the session key that is computed by each of the oracles in a protocol run executed in the presence of an entirely passive adversary (which only relays the messages sent by the oracles).

We note that the original key of two oracles depends on the (secret) randomness available to the two oracles. We are now able to introduce no-match attacks.

#### 2.2 Definition of No-Match Attack

**Definition 2.2 (No-Match Attack):** An adversary has successfully launched a no-match attack if there is a pair of oracles such that each of them has computed their original key, but the two oracles are not partnered (do not have the same session identifier).

We clarify that in the above definition, we essentially consider two runs of the protocol under different conditions. The first one is imaginary and used to define the original key of the two oracles, assuming the adversary remains passive. In contrast, the real second run assumes an active adversary. We stress that in both runs, the oracles use the same randomness.

Defining no-match attacks relative to the original key is crucial (also see Figure 1). It is not sufficient that an adversary launches an attack that makes the two oracles accept with the same key, as some papers have suggested before [5]. For a no-match attack, this must additionally be the original key. This distinction will be important in Section 4 (and particularly in Section 4.3) when we propose several solutions to thwart protocols against no-match attacks. It is this subtle feature that solves many of the problems of previous definitions.

Finally, we emphasize that we have defined no-match attacks with a general partnering definition. Subsequently, we concentrate on partnering definitions based on (partial) matching conversations (including session identifiers based on matching conversations). We note that in the protocol, the ephemeral Diffie-Hellman keys are well-protected against adversarial modifications by the digital signatures. It is rather the digital signatures themselves that are not appropriately secured against altering.

#### 2.3 Warm-Up: No-Match Attacks without Advice

We start with an instructive example of a no-match attack. Imagine a key exchange protocol where, in the last protocol step, (an oracle of) Alice sends a message together with a signature on that message to (an oracle of) Bob. As a running example, we may use signed Diffie-Hellman (i.e., the basic Diffie-Hellman key exchange where each DH share is accompanied by a signature over that share and the identities of the communication parties). Recall that the standard security notion of digital signatures requires the adversary to output a forgery on a message that has not been queried before [27]. Also, assume that Alice uses a probabilistic signing algorithm. Now let us describe an attacker \( A \) that cannot be reduced to the security of the digital signature scheme. The attack proceeds in three steps:

1. \( A \) intercepts Alice’s last message in transit.
2. \( A \) computes a new signature on the last message, for example, by first brute-forcing Alice’s secret key and then reapplying the signature algorithm.
3. Finally, \( A \) sends the message and the new signature to Bob.

In many existing security protocols, only the last message is used in the derivation of the session key, but not the signature over that message. This crucially influences security. Observe that in the presence of the above attack, the communication transcripts computed by Alice and Bob are very similar. The only difference is that the last signature is different from the one produced by Alice. At the same time, Alice cannot recognize the modification introduced by \( A \), because:
a) There is no further message from Bob to Alice (in which he could inform her of the modified signature he received).
b) The signature is not used to derive the session key (so the fact that the signatures are distinct will not be reflected in the two parties computing distinct keys).

Now, any security proof in a model based on matching conversations is deemed to fail. In essence, the oracles compute the same key but are not partnered, leading to a successful no-match attack.