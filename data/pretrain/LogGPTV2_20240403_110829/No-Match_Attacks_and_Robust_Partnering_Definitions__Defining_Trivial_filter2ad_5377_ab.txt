of a secure protocol.
Taking stock, matching conversations excel in providing the
first set of desirable properties, 1)–6), while failing to support the
second, 7)–9). In contrast, the more general notions of partnering
like partial matching conversations, general session identifiers, and
partnering functions may be concretized such that they provide
the second set of properties, 7)–9). However, they usually do not
provide the features of the first set of properties, 1)–6).
1.1 Contribution
We provide several contributions. First, we present a new class of
attacks on key exchange protocols called no-match attacks. In a no-
match attack the attacker slightly modifies the message exchanged
between two oracles on transit such that the keys computed by
these oracles remain equal. However, the decisive point is that due
to the introduced modifications the oracles are not partnered. In all
existing security models, this can be exploited to break the security
by simply revealing the session key of one of the oracles to answer
the Test-query for the other. We use no-match attacks to show that
providing sound security analyses for key exchange protocols un-
der MC-based definitions of partnering is difficult and error-prone.
In particular, we show for a diverse collection of security protocols,
that the corresponding security proofs are flawed. To this end, we
present detailed descriptions of successful adversaries. The set of
protocols that we consider is not complete and we believe many
more security proofs to be flawed or at least incomplete in the sense
that they do not formally rule out no-match attacks (although the
protocol actually protects against them). We present three ways
to thwart no-match attacks. Our solutions vary in the additional
complexity added to the protocol and the additional theoretical
assumptions necessary in the security proof as compared to the
original protocol. This allows to choose the necessary modifications
to the protocol (for making it provably secure) in a way that suits
Session F3:  Crypto PitfallsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1345the application it is used in. As our main solution and as one of
our major contributions, we present a new definition of partnering
that precisely renders no-match attacks invalid. We provide several
arguments for why our notion is better than previous notions of
partnering. First, our definition can generically be plugged into
all existing security definitions. Second, it does not depend on the
analyzed protocol and thus is very general. In fact, it is independent
of the concrete messages that are exchanged between the parties.
Third, it can be verified very easily, i.e. whether two oracles are
partnered is decided solely by checking a single cryptographic
value. Forth, it supports efficient falsification making it possible to
decide whether for a protocol we cannot provide a proof of security
at all. Fifth, and in contrast to some of the existing definitions it
formalizes and supports cryptographic intuition. Finally, we stress
that our new definition of partnering supports the form of com-
posability that the MC-based notions provably lack and even a
slightly stronger form of it. In particular, protocols proven secure
under our definitions remain secure even if additional messages
are exchanged that do depend on the public values of the protocol.
As our last result, we show how to deal with no-match attacks in
security models that also, besides key indistinguishability, formal-
ize explicit authentication. In particular we provide a new notion
of explicit authentication that similar to before renders no-match
attacks useless. Advantageously, this new definition again supports
the basic from of composability that MC-based notions lack. As a
stepping stone and of independent interest, we essentially decouple
authentication from the used partnering definition.
1.2 Related Work
The importance of precise security definitions for rigorous cryp-
tographic analysis is well-recognized by cryptographers [25, 32]
and can hardly be overestimated. Ultimately, one first needs to pro-
vide a precise definition of security before constructing a scheme
that provably achieves it. No-match attacks show that it is hard to
precisely define trivial attacks for key exchange protocols. Similar
observations have been made for other primitives before. Most
notably, Bellare, Hofheinz, and Kiltz showed that for public key
encryption schemes there exists several non-equivalent variants for
formalizing that the challenge ciphertext may not be asked to the
decryption oracle [4]. As a result of their analysis, they isolate the
strongest of the existing definitions and recommend it for future
usage. Our results are similar in the sense that they also analyze dif-
ferent ways to define trivial attacks for an important cryptographic
primitive, but they go much further. We do not only show that
the existing ways of formalizing trivial attacks are not equivalent.
We present new, subtle attacks that reveal flaws in formal security
proofs which have been overlooked by cryptographers for many
years. Moreover, we show that the most popular definition of trivial
attacks – via matching conversations – is actually unsuited for
cryptographic practice. Finally, we provide a new definition that
solves many of the problems of the existing definitions (lack of com-
posability, unrealistic no-match attacks) while keeping important
advantages.
There exist few papers that consider attacks that are related to
the definition of partnering in key exchange protocols. Most note-
worthy, in 2005, Choo and Hitchcock [18] presented an attack on
the Jeong-Katz-Lee protocol TS2 [30] and on the three-party proto-
col 3PKD of Bellare and Rogaway [7]. In retrospect and using our
terminology, we can interpret the attack on the 3PKD protocol as a
simple no-match attack (without advice). In 2007, Bresson, Manulis,
and Schwenk [13] showed that under the original security defini-
tion for group key exchange by Bresson, Chevassut, Pointcheval,
and Quisquater [12] there exist protocols where the adversary may
impersonate users or where two partnered oracles accept with a dif-
ferent key. However, the authors explicitly state that these problems
only appear in the group setting with at least three parties. The
authors of [29] were pointed to a subtle problem with the defintion
of partnering that, in retrospect, can be interpreted as a no-match
attack (see the most recent full version [40]). This issue was also
observed by [16]. We stress that the above works only consider
attacks on single protocols. In contrast, our work provides a very
general attack strategy that can be applied on a variety of proto-
cols. We also introduce no-match attacks with advice showing that
no-match attacks can be much harder to avoid (and more subtle)
when the adversary is granted access to strong queries, like in KCI
attacks or when modeling forward secrecy.
In 2011, Cremers, provided an in-depth analysis and comparison
of three of the most wide-spread security models, the CK, the CK+
(or HMQV), and the eCK model [19]. As a result, he was able to
show that these models are formally and practically incompara-
ble to each other, meaning that for every pair of models one can
find protocols which are secure in the first model but not in the
second (and vice versa). Crucially, he exploited that the security
models have different ways to formalize partnering and, in particu-
lar, different ways of defining security for non-symmetric protocols.
Moreover, Cremers showed that the proofs of several protocols
are not complete. In particular, he showed that in some models
protocols may have computed distinct keys although they formally
are partnered.6 Our no-match attacks are rather orthogonal to this,
where oracles have the same key but do not have matching con-
versations. This not only makes proofs incomplete but also allows
us to describe concrete and often very subtle (no-match) attacks.
However, there is also a more fundamental difference between our
work and that of Cremers. Like some works before, Cremers focuses
on and suggests to use definitions of partnering that guarantee that
two oracles have computed the same key iff they are partnered.
Jumping ahead we show that this is actually not an appropriate way
to deal with no-match attacks and therefore we propose a distinct
and conceptually new definition of partnering. Crucially, and in
contrast to all other works that we are aware of, our definition of
partnering does not only require that two (or more) oracles have
computed the same key but that this key must additionally be equal
to a special (ideal) key which only depends on the two oracles but
not the attacker. Moreover, our results are not restricted to certain
security models but reveal a general problem (and possible solu-
tions to it) when defining security in the realm of key exchange
and authentication protocols.
6Intuitively, one can view this as a violation of correctness (in the presence of an
active attacker). However, since both oracles have computed distinct keys they will
not be able to exchange authenticated messages with that key. This will already
make the parties aware of a problem that has occurred in the key derivation phase.
(Arguably, this argumentation is central to the concept of implicit authentication.) Our
no-match attacks in contrast will make an attacker successfully break the secrecy of
the communication without any indication of its presence to the oracles.
Session F3:  Crypto PitfallsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1346The authors of [33] also introduce a new partnering definition
that aims to fix the problem that occurs “if the partnering definition
takes information into account that is irrelevant to the computation
of the session key”. This notion is incomparable to ours and all other
existing notions and, as sketched before, very counter-intuitive. In
essence, it defines that the fact that two oracles are partnered (or
not) depends on the (non-)existence of another oracle with some
related properties. (All other notions of partnering concentrate on a
relation between only two oracles.) More concretely, the definition
in [33] states that two oracles are partnered if they have the same
key and no other oracle has that key. We also remark that in general
concentrating only on “irrelevant” information is not sufficient.
Jumping slightly ahead, our results show that no-match attacks
are also possible by modifying messages that are crucial to the
computation of the message (also see Remark 1).
1.3 Open Problems
In this paper, we provide a collection of (flawed) security analyses
that show that the corresponding protocols fail to meet their stated
security claims. We stress that our list is by no means complete. We
remark that we concentrate on protocols that are proven secure in
widespread security models. Given the popular use of session iden-
tifiers based on matching conversations and the wide popularity of
the original BR, CK+, eCK, and ACCE model, we believe that many
other security proofs are vulnerable to no-match attacks. Further-
more, it remains an interesting open problem to more practically
exploit a no-match attack in a real-world protocol but we have
little hope in this regard. Finally, in Section 7 we consider potential
future relaxations of our new security notion and conceptual and
technical obstacles towards them.
1.4 A Note on Formalism
To focus on the subtle7 core problem surrounding no-match attacks
we try to keep our results as light on key exchange formalism as
possible. More rigorously, technical definitions can be found in
the cited security models. A very brief overview on key exchange
models is given in Appendix A. We stress that in several ways our
results do not rely on concrete formalizations of security definitions.
For example, for our purposes it does not matter if we use the
definition of matching conversations given [6], in [29], or the one
given implicitly in [35]. For our purposes these definitions can
be regarded as equivalent, all essentially trying to capture that
everything that is sent by one oracle is actually received by the
second and vice versa. It is this conceptual core of the definition
our result relies on, not a concrete formalism of it. We therefore
sometimes refrain from providing a concrete definition in this paper
and basing our reasoning on it but refer to the literature for concrete
formalizations.
1.5 Overview
We start with a gentle introduction to no-match attacks in Section 2.
In Section 3, we present a diverse list of no-match attacks against
existing security protocols. These attacks reveal subtle flaws in the
security proofs of the protocols. A detailed, step-by-step example
7Recall that despite being peer-reviewed and public, several existing protocols are still
susceptible to no-match attacks.
of such an attack can be found in Appendix B. Altogether we pro-
vide three solutions to deal with no-match attacks. In Section 4, we
present our first solution and main contribution: a new partnering
notion that does not require any modification of the protocol im-
plementation at all to deal with no-match attacks. We extend our
results in Section 5 to provide a new definition of explicit authenti-
cation for key exchange that helps to deal with no-match attacks
in security models with explicit authentication. In Section 6, we
show how to use our new security notion as a more general tool to
strengthen existing security definitions. Finally, Section 7 contains
an outlook on how our new security notion might be extended
further. Additionally, we present several arguments why such an
extension may indeed be rather difficult to achieve when it adheres
to the high standards that we require (and which are so common
in most other fields of cryptography). In Appendix C we show in a
formal way that security models based on matching conversations
cannot be composed with arbitrary random messages even if those
messages are independent of the protocol. Next we show that, in
contrast, our new notion of partnering does provably fulfill this
and even a stronger form of composition (where the additional mes-
sages may even be generated from the public values of the protocol).
Finally, in Appendix E we describe two alternative approaches (and
their limitations) to deal with no-match attacks in existing security
models. These solutions either rely on a careful instantiation of the
primitives or on a (slight) modification of the protocol layout.
2 NO-MATCH ATTACKS
In this section we introduce no-match attacks. To precisely capture
no-match attacks, we first introduce the notion of original keys.
It will also be central to the new partnering definitions that we
provide later on.
Definition 2.1 (Original Key). The original key of a pair of com-
municating oracles is the session key that is computed by each of
the oracles in a protocol run which is executed in the presence of
an entirely passive adversary (which only relays the messages sent
by the oracles).
We remark that the original key of two oracles depends on the
(secret) randomness available to the two oracles. We are now able
to introduce no-match attacks.
Definition 2.2 (No-Match Attack). We say, an adversary has suc-
cessfully launched a no-match attack if there is a pair of oracles
such that each of them has computed their original key but the two
oracles are not partnered (do not have the same session identifier).
We clarify that in the above definition we essentially consider
two runs of the protocol although under different conditions. The
first one is only imaginary and used to define the original key of
the two oracles while assuming the adversary remains passive. In
contrast, the real second run assumes an active adversary. We stress
that in both runs, the oracles use the same randomness.
We also remark that defining no-match attacks relative to the
original key is crucial (also see Figure 1). In particular, it is not
sufficient that an adversary launches an attack that makes the two
oracles accept merely with the same key, as some papers have
suggested before [5]. For a no-match attack this must additionally
be the original key. This distinction will be important in Section 4
Session F3:  Crypto PitfallsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1347(and in particular in Section 4.3) when we propose several solutions
to thwart protocols against no-match attacks. It is this (subtle)
feature that solves many of the problems of previous definitions.
Finally, we emphasize that we have defined no-match attacks
with a general partnering definition. Subsequently, we concentrate
on partnering definitions based on (partial) matching conversations
(including session identifiers based on matching conversations).
We note that in the protocol the ephemeral Diffie-Hellman keys
are well-protected against adversarial modifications by the digital
signatures. It is rather the digital signatures themselves that are
not appropriately secured against altering.
2.1 Warm-Up: No-Match Attacks without
Advice
We start with an instructive example of a no-match attack. Imagine a
key exchange protocol, where in the last protocol step, (an oracle of)
Alice sends a message together with a signature on that message to
(an oracle of) Bob. As a running example used here and later on we
may more concretely use signed Diffie-Hellman (i.e. the basic Diffie-
Hellman key exchange where each DH share is accompanied by a
signature over that share and the identities of the communication
parties). Recall that the standard security notion of digital signatures
requires the adversary to output a forgery on a message that has not
been queried before [27]. Also, assume that Alice uses a probabilistic
signing algorithm. Now let us describe an attacker A that cannot be
reduced to the security of the digital signature scheme. The attack
proceeds in three steps:
(1) A intercepts Alice’s last message on transit.
(2) A computes a new signature on the last message, for ex-
ample by first brute-forcing Alice’s secret key and then re-
applying the signature algorithm.
(3) Finally, A sends the message and the new signature to Bob.
In many existing security protocols, only the last message is used
in the derivation of the session key – but not the signature over
that message. This crucially influences security. Observe, that in
presence of the above attack the communication transcripts com-
puted by Alice and Bob are very similar. The only difference is that
the last signature is different from the one produced by Alice. At
the same time, Alice cannot recognize the modification introduced
by A, because a) there is no further message from Bob to Alice (in
which he could inform her of the modified signature he received)
and b) the signature is not used to derive the session key (so the fact
that the signatures are distinct will not be reflected in the two par-
ties computing distinct keys). Now, any security proof in a model
based on matching conversations is deemed to fail. In essence, the