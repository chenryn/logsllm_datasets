本文是[Reading privileged memory with a side-channel](https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html)的翻译文章。上篇见[这里](https://xz.aliyun.com/t/2273)
# 变体2：分支目标注入
## 从KVM guest虚拟机读取主机内存
### 找到主机内核
我们的PoC通过几个步骤来定位主机内核。下一步攻击所确定和必要的信息包括：
  * 低于kvm-intel.ko地址的20位
  * kvm.ko的完整地址
  * vmlinux的完整地址
回顾一下，这并不是必要的，但它很好地演示了攻击者可以使用的各种技术。 更简单的方法是首先确定vmlinux的地址，然后平分kvm.ko和kvm-intel.ko的地址。
第一步，kvm-intel.ko的地址被泄露。 为此，guest输入后的分支历史缓冲区状态被转出。然后，对于kvm-intel.ko的加载地址的位12..19的每个可能的值，历史缓冲区的预期最低16位是基于加载地址推测和guest入口之前的最后8个分支的已知偏移来计算的，并将结果与泄漏历史缓冲区状态的最低16位进行比较。
通过测量具有两个目标的间接调用的误预测速率，分支历史缓冲区状态以2位的步长泄漏。间接调用的一种方式是从vmcall指令开始，然后是一系列N个分支，其相关的源地址位和目标地址位均为零。间接调用的第二种方式来自用户空间中的一系列受控分支，可用于将任意值写入分支历史缓冲区。
错误预测率的测量方法与“逆向工程分支预测器内部”部分相同，使用一个调用目标加载缓存行，另一个检查是否加载了相同的缓存行。  
在N = 29的情况下，如果受控分支历史缓冲器值为零，则由于来自超级调用的所有历史缓冲器状态已被擦除，错误预测将以高速率发生。  
在N = 28的情况下，如果受控分支历史缓冲值为 0> 2)。  
通过重复此操作以减少N的值，可以确定N = 0的分支历史缓冲值。  
此时，kvm-intel.ko的低20位是已知的; 下一步是大致找到kvm.ko.  
为此，使用通用分支预测器，和从kvm.ko到kvm-intel.ko的间接调用插入到BTB中的数据，该数据发生在每个超级调用上;这意味着间接调用的源地址必须从BTB中泄漏出去。
kvm.ko可能位于从0xffffffffc0000000到0xffffffffc4000000的范围内，页面对齐（0x1000）。
这意味着“通用预测变量”一节中表中的前四项适用; 会有24-1 = 15个别名的地址。 但这也是一个优点：它将搜索空间从0x4000减少到0x4000 /
2^4 = 1024。
要找到源或其某个别名地址的正确地址，通过特定寄存器加载数据的代码被放置在所有可能的调用目标（kvm-intel.ko的泄漏低20位加上调用目标的模块内偏移加上220的倍数）并且间接呼叫被放置在所有可能的呼叫源。  
然后，交替执行超级调用，并通过不同的可能的非别名调用源执行间接调用，并使用随机历史缓冲区状态，防止专用预测工作。
在此步骤之后，kvm.ko的加载地址仍有216个可能性。
接下来，可以使用从vmlinux到kvm.ko的间接调用，以类似的方式确定vmlinux的加载地址。幸运的是，在vmlinux的加载地址中随机化的位没有一个被折叠在一起，所以与定位kvm.ko时不同，结果将直接是唯一的。vmlinux具有2MiB的对齐和1GiB的随机化范围，所以仍然只有512个可能的地址。  
因为（据我们所知），一个简单的超级调用实际上并不会导致从vmlinux到kvm.ko的间接调用，我们使用模拟串行端口的状态寄存器中的端口I /
O，该端口出现在使用virt-manager创建的虚拟机的默认配置中。
剩下的唯一信息是kvm.ko的16个别名加载地址中的哪一个实际上是正确的。  
因为对kvm.ko的间接调用的源地址是已知的，所以可以使用二分法来解决：将代码放置在各种可能的目标上，这取决于推测性地执行代码的哪个实例，加载两个缓存行中的一个，并检测哪一个缓存行被加载。
### 识别缓存集
PoC假定虚拟机无法访问超大页面。要发现具有相对于4KiB页面边界的特定对齐的所有L3高速缓存集合的驱逐集合，PoC将首先分配25600页内存。然后，在一个循环中，它选择所有剩余的未排序页面的随机子集，使得子集中包含驱逐集合的集合的期望数目为1，通过反复访问它的缓存行并测试缓存行是否总是被缓存（在这种情况下，它们可能不是驱逐集的一部分），从而将每个子集减少到驱逐集，并尝试使用新的驱逐集来驱逐所有剩余的未分类的缓存行，以确定它们是否在相同的缓存集中[12]。
### 查找guest页面的主机虚拟地址
由于此攻击使用FLUSH + RELOAD方法泄漏数据，因此需要知道一个guest页面的主机内核虚拟地址。 诸如PRIME +
PROBE等替代方法应该没有这个要求。
攻击这一步的基本思路是对管理程序使用分支目标注入攻击来加载攻击者控制的地址并测试是否导致加载客户拥有的页面。为此，可以使用从R8指定的内存位置进行简单加载的gadget
- 在此内核版本上达到guest退出后的第一个间接调用时，R8-R11仍包含guest控制值。
我们预计攻击者需要知道在这一点上必须使用哪个驱逐集或者同时暴力驱逐，但是，通过实验，使用随机驱逐集也可以。
我们的理论是观察到的行为实际上是L1D和L2驱逐的结果，这可能足以允许一些指令值的推测性执行。
主机内核映射（近似于）physmap区域中的所有物理内存，包括分配给KVM guest虚拟机的内存。
但是，physmap的位置是随机的（1GiB对齐），在大小为128PiB的区域。 因此，直接强制guest页面的主机虚拟地址需要很长时间。 这是可能的;
作为估计值，假设每秒12000次成功注入和30个并行测试的guest页面，应该可能在一天左右或更短的时间内完成; 但不像几分钟内那么令人印象深刻。
为了优化这个问题，可以将问题分解：首先，使用可以从物理地址加载的小工具蛮力物理地址，然后蛮力施加physmap区域的基地址。  
因为通常可以假定物理地址远远低于128PiB，所以它可以更有效地暴力破解，并且之后暴力破坏physmap区域的基地址也更容易，因为可以使用1GiB对齐的地址猜测。
要强制使用物理地址，可以使用以下gadget：
    ffffffff810a9def:      4c 89 c0                mov    rax,r8
    ffffffff810a9df2:      4d 63 f9                movsxd r15,r9d
    ffffffff810a9df5:      4e 8b 04 fd c0 b3 a6    mov    r8,QWORD PTR [r15*8-0x7e594c40]
    ffffffff810a9dfc:      81
    ffffffff810a9dfd:      4a 8d 3c 00            lea    rdi,[rax+r8*1]
    ffffffff810a9e01:      4d 8b a4 00 f8 00 00    mov    r12,QWORD PTR [r8+rax*1+0xf8]
    ffffffff810a9e08:      00
这个gadget允许通过适当地设置R9来加载内核文本部分周围8字节对齐的值，尤其允许加载physmap的起始地址page_offset_base。
然后，原来在R8中的值 - 物理地址推测值减去0xf8 - 被添加到先前加载的结果中，将0xfa加入其中，并且结果被解除引用。
### 缓存集选择
为了选择正确的L3驱逐集，来自下一节的攻击基本上以不同的驱逐集执行，直到它工作。
### 数据泄露
在这一点上，通常有必要在主机内核代码中定位可用于实际泄漏数据的小工具，方法是从攻击者控制的位置读取数据，对结果进行适当的移位和掩码，然后将结果作为抵消攻击者控制地址的负载。但是将gadget拼凑在一起，弄清楚哪些在推测环境中起作用看起来很烦人。  
所以作为替代，我们决定使用eBPF解释器，它是内置于宿主内核的 -虽然没有合法的方式从虚拟机内部调用它，但主机内核的文本部分中代码的存在足以使其可用于攻击，就像普通的ROP gadget一样。
eBPF解释器入口点具有以下函数签名：
    static unsigned int __bpf_prog_run(void *ctx, const struct bpf_insn *insn)
第二个参数是指向要执行的静态预验证eBPF指令数组的指针 - 这意味着__bpf_prog_run（）不会执行任何类型检查或边界检查。
第一个参数只是作为初始模拟寄存器状态的一部分存储，所以它的值并不重要。
eBPF解释器提供了以下内容：
  * 多个仿真的64位寄存器
  * 64位立即写入仿真寄存器
  * 内存从存储在仿真寄存器中的地址读取数据
  * 按位操作（包括位移）和算术运算
要调用解释器入口点，需要一个给定R8-R11控制和受控数据在已知内存位置的RSI和RIP控制的gadget。 以下gadget提供了此功能：
    ffffffff81514edd:       4c 89 ce                mov    rsi,r9
    ffffffff81514ee0:       41 ff 90 b0 00 00 00    call   QWORD PTR [r8+0xb0]
现在，通过将R8和R9指向physmap中客户拥有页面的映射，可以在主机内核中推测性地执行任意未验证的eBPF字节码。
然后，可以使用相对简单的字节码将数据泄漏到缓存中。
# 变体3：恶意数据缓存加载
基本上看Anders Fogh的博文就够了： 
总之，使用此问题变体的攻击尝试从用户空间读取内核内存，而不会误导内核代码的控制流。  
这通过使用用于以前变体的代码模式，但是是在用户空间中作用。  
其基本思想是，访问地址的权限检查可能不是关于从内存向寄存器读取数据的关键路径，权限检查可能会对性能产生重大影响。相反，内存读取可以使读取的结果立即可用于以下指令，并且只是异步执行权限检查，如果权限检查失败，则在重新排序缓冲区中设置一个标志，导致引发异常。
我们对Anders Fogh的博文有一些补充：
> “想象一下在usermode中执行的以下指令  
>  mov rax，[somekernelmodeaddress]  
>  它在退出时会导致中断，[...]“
还可以在高延迟预测错误分支后面执行该指令以避免发生页面错误。 也可以通过增加从内核地址读取和传送相关异常之间的延迟来扩大推测窗口。
> “首先，我调用一个系统调用触及这个内存，其次，我使用prefetcht0指令来提高我在L1中加载地址的几率。”
当我们在系统调用之后使用预取指令时，攻击停止了对我们的工作，我们不知道为什么。