creates a child with it.

var s b c o n t e n t ="" ;
s b c o n t e n t +="" ;
s b c o n t e n t +="" ;
// the baseurl is current window uri
//so that relative URIs work
s b c o n t e n t +="" ;
// contents of app.txt
s b c o n t e n t += a p p l i c a t i o n c o d e ;
// attribute values are URI - decoded
// by HTML parser
s b c o n t e n t =encodeURIComponent ( s b c o n t e n t ) ;
var f r = document . c r e a t e E l e m e n t ( "iframe" ) ;
f r . s r c ="data:text/html; charset =utf -8,"+
s b c o n t e n t ;

// sandboxed frames run in fresh origin
f r . s e t A t t r i b u t e ( ’sandbox ’ , ’allow - scripts ’ ) ;
document . body . a p p e n d C h i l d ( f r ) ;
Listing 1: Bootstrap Code (JavaScript)
Implementation
4
As outlined in Section 3, the parent code executes when
the user navigates to the application. The bootstrap code
is in charge of creating an unprivileged sandbox and ex-
ecuting the unprivileged application code in it. The shim
code and policy also run in the parent, but we focus on
the bootstrap and shim code implementation in this sec-
tion. The unprivileged child code and the security policy
vary for each application, and we discuss these in our
case studies (Section 5).
Figure 3 outlines the steps involved in creating one
unprivileged child. First, the user navigates to the ap-
plication and the parent’s bootstrap code starts executing
(Step 1 in Figure 3). In Step 2, the parent’s bootstrap
code retrieves the application HTML code (as plain text
ﬁles) as well as the security policy of the application. For
client-side platforms like Chrome and Windows 8, this is
a local ﬁle retrieval.
Browser PageParentChild IframeBootstrap CodePolicy CodeApplication CodeSHIM1. Bootstrap Code2. Application Code and Policy4. Source Policy Code3. Create ChildSHIM
tabs . c a p t u r e V i s i b l e T a b =
f u n c t i o n ( windowid , options , c a l l b a c k ) {
var id = c a l l b a c k c t r ++;
c a c h e d _ c a l l b a c k s [ id ] = c a l l b a c k ;
s e n d T o P a r e n t ({
" type " : " tabs . c a p t u r e V i s i b l e T a b " ,
" w i n d o w i d " : windowid ,
" options " : options ,
" c a l l b a c k i d " : id
}) ;
Listing 2: Child shim for captureVisibleTab
};

// m is the a r g u m e n t given to
// s e n d T o P a r e n t in the child shim
if ( m . type === ’ tabs . c a p t u r e V i s i b l e T a b ’)
{ // fail if policy does not allow
if (! policy . a l l o w C a l l ( m ) { return ;}
tabs . c a p t u r e V i s i b l e T a b (
m . windowid ,
m . options ,
f u n c t i o n ( imgData ) {
s e n d T o C h i l d ({
type : " cb_tabs . c a p t u r e V i s i b l e T a b " ,
id : m . callbackid ,
imgData : imgData
}) ;
}
}) ;




Listing 3: Parent shim for captureVisibleTab
cation can continue calling the privileged API as before.
Parent Shim. On receiving the message, the parent’s
shim ﬁrst checks with the policy (Step 4 in Fig. 4 and
line 5 in Listing 3) and if the policy allows it, the parent
shim makes the requested privileged call.
In case of ScreenCap, a simple policy could disallow
captureVisibleTab call if the request came from the
image editor, and allow the call if the request came from
the screenshot component. Such a policy unbundles the
two components. If a network attacker compromises one
of the two components in ScreenCap, then it only gains
the ability to make request already granted to that com-
ponent. As another example, the application can enforce
a policy to only allow one captureVisibleTab call af-
ter a user clicks the ‘capture’ button. All future requests
during that execution of the application are denied until
the user clicks the ‘capture’ button again.
Note that the privileged call is syntactically the same
as what the child would have made, except for the call-
back. The modiﬁed callback (lines 9-14 in Listing 3)
forwards the returned image data to the child (Step 6),
the original callback still executes in the child.
Child Callback The message handler on the child re-
ceives the forwarded arguments from the parent and exe-
cutes the saved callback with the arguments provided by
the parent. (Step 7 in Figure 4 and line 6 in Listing 4).
The saved callback is then deleted from the cache (Line
Figure 4: Typical events for proxying a privileged API call.
The numbered boxes outline the events. The event boxes span
the components involved. For example, event 4 involves the
parent shim calling the policy code.
time) to the child shim, and the child shim executes the
original callback.
code
examples of
the
for
shims
Continuing with our
running example, we give
the
concrete
chrome.tabs.captureVisibleTab function,
used
to capture a screenshot. captureVisibleTab takes
three arguments: a windowID, an options object, and
a callback parameter. On successfully capturing a
screenshot of the given window, the chrome runtime
executes the callback with the encoded image data as
the only argument. Note that the callback parameter is a
ﬁrst-class function; our invariants do not allow exchange
of a function across the privilege boundary.
Child Shim. The child shim creates a stub implemen-
tation of the privileged API. In the unprivileged child, a
privileged call would fail since the child does not have
privileges to execute it.
Instead, the stub function de-
ﬁned by the child function is called. This stub func-
tion marshals all the arguments and sends it to the par-
ent. Listing 2 is the child shim implementation for the
captureVisibleTab function.
No code is passed across the privilege boundary. In-
stead, the child saves the callback (Step 2 in Fig. 4) and
forwards the rest of the argument list to the parent (Step
3). The callback is stored in a cache and a unique iden-
tiﬁer is sent to the parent. The parent uses this identiﬁer
later.
We stress that this process is transparent to the applica-
tion: the parent code ensures that the child shim is loaded
before any application code starts executing. The appli-
8
Browser PageParentChild IframeBootstrap CodeSHIMPolicy CodeApplication CodeSHIM1. Privileged Call2. Save Callback3. Parent Request4. CheckPolicy5. Make PrivilegedCall6. Forward Callback Arguments7. Execute Saved Callback
if (
m . type === ’ cb_tabs . c a p t u r e V i s i b l e T a b ’
) {
var cb_id = m . c a l l b a c k i d ;
var savedCb = c a c h e d _ c a l l b a c k s [ cb_id
savedCb . call ( window , m . imgData ) ;
delete c a c h e d _ c a l l b a c k s [ cb_id ];
];
}
Listing 4: Child shim for captureVisibleTab: Part 2




7).
Persistent State. We take a different approach to
data persistence APIs like window.localStorage and
document.cookie. It is necessary that the data stored
using these APIs is also stored in the parent since the next
time a child is created, it will run in a fresh origin and the
previous data will be lost. We point out that enabling per-
sistent storage while maintaining compatibility requires
some changes to code. Persistent storage APIs (like
window.localStorage) in today’s platforms are syn-
chronous; our proxy mechanism uses postMessage to
pass persistent data, but postMessage is asynchronous.
To facilitate compatibility, we implement a wrapper for
these synchronous API calls in the child shim code and
asynchronously update the parent via postMessage un-
derneath. For example, a part of the localStorage child
shim is presented in Listing 5. The shim creates a
wrapper for the localStorage API using an associa-
tive array (viz., data). On every update, the new as-
sociative array is sent to the parent. On receiving the
localStorage save message, the parent can save the
data or discard it per policy.
We observe that in our transformation, calls to API
that access persistent state become asynchronous which
contrasts the synchronous API calls in the original code.
To preserve the application’s intended behavior, in prin-
ciple, it may be necessary to re-design parts of the code
that depend on the synchronous semantics of persistent
storage APIs—for example, when more than one unpriv-
ileged children are sharing data via persistent state simul-
taneously. In our case studies so far, however, we ﬁnd
that the application behavior does not depend on such se-
mantics. In future work, we plan to investigate transfor-
mation mechanisms that can provide reasonable memory
consistency properties in accessing persistent local stor-
age.
5 Case Studies
We retroﬁt our design onto three HTML5 applications
to demonstrate that our architecture can be adopted by
applications today:
• As an example of browser extensions, we retroﬁt
our design to Awesome Screenshot, a widely used
9


setItem : f u n c t i o n ( key , value ) {
data [ key ] = value + ’ ’;
s a v e T o M a i n C a c h e ( data ) ;
} ,
s a v e T o M a i n C a c h e : f u n c t i o n ( data ) {
s e n d T o P a r e n t ({
" type " : " l o c a l S t o r a g e _ s a v e " ,
" value " : data
}) ;
} ,
Listing 5: localStorage Shim in the Child Frame
chrome extension (802,526 users) similar to Screen-
Cap.
• As an example of emerging packaged HTML5 web
applications, we retroﬁt our design to SourceKit, a
full-ﬂedged text editor available as a Chrome pack-
aged web application. SourceKit’s design is similar
to editors often bundled with online word proces-
sors and web email clients. These editors typically
run with the full privileges of the larger application
they accompany.
• As an example of traditional HTML5 web appli-
cations, we retroﬁt our design to SQL Buddy, a
PHP web application for database administration.
Web interfaces for database administration (notably,
PHPMyAdmin) are pervasive and run with the full
privileges of the web application they administer.
Our goal in this evaluation is to measure (a) the reduc-
tion in TCB our architecture achieves, (b) the amount of
code changes necessary to retroﬁt our design, and (c) per-
formance overheads (user latency, CPU overheads and
memory footprint impact) compared to platform redesign
approaches. Table 1 lists our case studies and summa-
rizes our results. First, we ﬁnd that the TCB reduction
achieved by our redesign ranges from 6x to 10000x. Due
to the prevalence of miniﬁcation, we believe LOC is not
a useful metric for JavaScript code and, instead, we re-
port the size of the code in KB. Second, we ﬁnd that we
require minimal changes, ranging from 0 to 13 lines, to
port the case studies to our design. This is in addition to
the application independent shim and bootstrap code that
we added.
We also demonstrate examples of expressive policies
that these applications can utilize. The focus of this paper
is on mechanisms, not policies, and we do not discuss
alternative policies in this work.
Finally, we also quantify the reduction in privileges
we would achieve in the 50 most popular Chrome exten-
sions with our architecture. We also ﬁnd that in half the
extensions studied, we can move 80% of the functions
out of the TCB. This quantiﬁes the large gap between
the privileges granted by Chrome extensions today and
what is necessary. In addition, we also analyze the top
20 Chrome extensions to determine the number of com-
ponents bundled in each. We ﬁnd that 19 out of the top
20 extension exhibit bundling, and estimate that we can
separate these between 2 to 4 components, in addition to
the three components that Chrome enforces.
To facilitate further research and adoption of our tech-
niques, we make all the application independent compo-
nents of the architecture and the SQL Buddy case study
available online [22]. Due to licensing restrictions, we
are unable to release the other case studies publicly.
Table 1: Overview of case studies. The TCB sizes are in KB.
The lines changed column only counts changes to application
code, and not application independent shims and parent code.
Application Number
of users
Initial
TCB
(KB)
New
Lines
TCB Changed
(KB)
Awesome
Screenshot
SourceKit
SQL Buddy
802,526
580
14,344
45,419
15,000
100
16.4
5.38
2.67
0
13
11
5.1 Awesome Screenshot
The Awesome Screenshot extension allows a user to cap-
ture a screenshot of a webpage similar to our running
example [35]. A rudimentary image editor, included in
the extension, allows the user to annotate and modify the
captured image as he sees ﬁt. Awesome Screenshot has
over 800,000 users.3
of
three
The
extension
consists
components:
background.html, popup.html, and editor.html.
A typical
interaction involves the user clicking the
Awesome Screenshot button, which opens popup.html.
The user selects her desired action; popup.html
forwards the choice to background.html, which
captures a screenshot and sends it to the image editor
(editor.html) for post-processing. All components
communicate with each other using the sendRequest
API call.
Privilege
redesigned Awesome
Screenshot following the model laid out in Section 3
(Figure 2). Each component runs in an unprivileged tem-
porary origin. The parent mediates access to privileged
APIs, and the policy keeps this access to the minimum
required by the component in question.