Our experience using SELINKS to write these applica-
tions has been quite positive. The access control policies
were easy to deﬁne and to use, with policy code consisting
of roughly 200 lines of code total (including helper func-
tions). The access control and login policy code was mod-
ular enough to be shared in its entirety by the two applica-
tions. The provenance policy consists of about 100 lines of
code, and was also straightforward to use. Unlike the prove-
nance policy from Section 3.2, SEWIKI provenance labels
essentially track only direct data ﬂows to and from other
documents. This makes them much easier to program with
since far fewer program operations need to be mediated by
the policy. To support richer policies while easing the pro-
gramming burden we are investigating an approach related
to weaving in aspect-oriented programming [21] that, given
a policy speciﬁcation, automatically transforms a program
to insert the appropriate label manipulations. We also plan
to include limited support for type inference to better inte-
grate the use of FABLE-style dependent types with standard
LINKS types in SELINKS.
5 Related Work
Dependently-typed languages have found use in a wide
variety of applications [44, 43, 3, 5]. In the context of secu-
rity, Zheng and Myers [46] formalize support for dynamic
security labels that can be associated with data to express
information ﬂow policies. The technical machinery for as-
sociating labels to terms in their system is similar to ours.
There are two main differences. First, the security policy—
an information ﬂow policy with a particular label model—
is expressed directly in the type system whereas in FABLE
both the security policy and the label model are customiz-
able. As discussed in Section 3.3, dynamic labels for infor-
mation ﬂow policies can be encoded in FABLE as a com-
bination of our dynamic provenance and static information
ﬂow policies. Second, FABLE allows non-values to appear
in types, e.g., lub l m in Figure 7. This permits a combina-
381
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply. 
tion of static and dynamic policy checking, but at the cost
of potentially undecidable type checking. Our SELINKS
implementation uses heuristics to ensure that type-checking
never diverges.
Walker’s “type system for expressive security poli-
cies” [42] is also dependently typed. Labels in Walker’s lan-
guage are uninterpreted predicates rather than arbitrary ex-
pressions. Walker’s system can enforce policies expressed
as security automata, which can capture any safety property.
This kind of policy is also enforceable in FABLE when ex-
tended with substructural types. However, in Walker’s sys-
tem, the policy is always enforced by means of a runtime
check. In order to recover some amount of static checking,
Walker suggests that a user might add additional rules to the
type system, though he is not speciﬁc about how this would
be done. These additional rules would have to be proved
correct with respect to a desired security property.
It has been observed that dependent types can be used
to express a kind of customized type system [43], and FA-
BLE’s policy functions ﬁt this description. For example,
the sub function in the policy of Figure 7 effectively intro-
duces a subsumption rule into the type system. Researchers
have explored how user-deﬁned type systems can be sup-
ported directly via customizable type qualiﬁers. Shankar et
al. [35] have used lattice-based type qualiﬁers in CQual [13]
to track dataﬂow properties like taintedness [35], and Zhang
et al. [45] and Fraser et al. [15] have used qualiﬁers to check
complete mediation in access control systems. Millstein et
al [8, 1] have developed an approach in which programmers
can indicate data invariants that custom type qualiﬁers are
intended to signify. In some cases, they are able to auto-
matically verify that these invariants are correctly enforced
by the custom type rules. While their invariants are rela-
tively simple, we ultimately would like to develop a frame-
work in a similar vein, in which correctness properties for
FABLE’s enforcement policies can be at least partially au-
tomated. Marino et al. [27] have proposed using proof as-
sistants for this purpose, and we plan to explore this idea in
the context of FABLE policies.
Li and Zdancewic show how to encode information ﬂow
policies in Haskell [25]. They deﬁne a meta-language that
makes the control-ﬂow structure of a program available for
inspection within the program itself. Their enforcement
mechanism relies on the lazy evaluation strategy of Haskell
that allows the control ﬂow graph to be inspected for in-
formation leaks prior to evaluation. While their encoding
permits the use of custom label models, they only show an
encoding of an information ﬂow policy. It is not clear their
system could be used to encode the range of policies dis-
cussed here.
In other work, Li and Zdancewic [24] have proposed la-
beling types with functions that describe conditions under
which a type is allowed to be relabeled. Their goal is to con-
trol what information is declassiﬁed by a program, whereas
we aim to enforce a variety of policies.
Our technique of separating the enforcement policy from
the rest of the program is based on Grossman et al’s col-
ored brackets [18]. They use these brackets to model type
abstraction, whereas we use them to ensure that the priv-
ilege of unlabeling and relabeling terms is not mistakenly
granted to application code. As a result, we do not need to
specially designate application code that may arise within
policy terms, keeping things a bit simpler. We plan to in-
vestigate the use of different colored brackets to distinguish
different enforcement policies, following Grossman et al.’s
support for multiple agents.
Finally, inasmuch as we have targeted the LINKS web-
programming language [12] as the platform on which to
build FABLE, our work is related to Swift [9] and SIF [11],
two Jif-based projects that aim to secure web applications.
The former is a technique that permits a web application to
be split according to a policy into JavaScript code that runs
on the client and Java code on the server, while the latter
is a framework in which to build secure servlets. As dis-
cussed in Section 4, LINKS provides similar functionality,
except it additionally integrates database access code into
the framework. With our new security checking features in
SELINKS, as in Swift, practical, veriﬁed, end-to-end secu-
rity for multi-tiered applications is within reach.
6 Conclusions
This paper has presented FABLE, a core formalism for a
programming language in which programmers may specify
security policies and reason that these policies are properly
enforced. We have shown that FABLE is ﬂexible enough
to implement a wide variety of security policies, includ-
ing access control, provenance, and static information ﬂow,
among other policies. We have also argued that FABLE’s
design simpliﬁes proofs that programs using these policies
do so correctly. We have implemented FABLE as part of
the LINKS web programming language, and we have used
the resulting language, which we call SELINKS, to build
two substantial applications, a secure wiki and a secure on-
line store. While more work remains to make SELINKS a
fully satisfactory platform, to our knowledge, no existing
framework enables the enforcement of such a wide variety
of security policies with an equally high level of assurance.
Acknowledgements: We thank Jeff Foster, Boniface
Hicks, Polyvios Pratikakis, Peter Sewell and the anonymous
reviewers for helpful comments on a draft of this paper. The
views and conclusions contained in this document are those
of the authors and should not be interpreted as represent-
ing the ofﬁcial policies, either expressed or implied, of the
Army Research Laboratory or the U. S. Government.
382
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply. 
References
[1] C. Andreae, J. Noble, S. Markstrum, and T. Millstein. A
In
framework for implementing pluggable type systems.
OOPSLA ’06. ACM Press, 2006.
[2] D. Aspinall and M. Hoffmann. Advanced Topics in Types and
Programming Languages, chapter Dependent Types. MIT
Press, 2004.
[3] L. Augustsson. Cayenne–a language with dependent types.
In ICFP ’98, New York, NY, USA, 1998. ACM Press.
[4] L. Badger, D. F. Sterne, D. L. Sherman, and K. M. Walker. A
domain and type enforcement UNIX prototype. Computing
Systems, 9(1):47–83, 1996.
[5] Y. Bertot and P. Cast´eran. Interactive Theorem Proving and
Program Development. Coq’Art: The Calculus of Inductive
Constructions. Springer Verlag, 2004.
[6] M. Bishop. Computer Security: Art and Science. Addison
Wesley, 2003.
[7] J. Cheney, A. Ahmed, and U. Acar. Provenance as depen-
dency analysis. Database Programming Languages, 2007.
[8] B. Chin, S. Markstrum, and T. Millstein. Semantic type qual-
iﬁers. In PLDI ’05. ACM Press, 2005.
[9] S. Chong, J. Liu, A. C. Myers, X. Qi, K. Vikram, L. Zheng,
and X. Zheng. Secure web application via automatic parti-
tioning. In SOSP ’07. ACM Press, 2007.
[10] S. Chong, A. C. Myers, N. Nystrom, L. Zheng, and
S. Zdancewic. Jif: Java + information ﬂow. Software release.
Located at http://www.cs.cornell.edu/jif, July 2006.
[11] S. Chong, K. Vikram, and A. C. Myers. Sif: Enforcing con-
In USENIX
ﬁdentiality and integrity in web applications.
Security ’07, 2007.
[12] E. Cooper, S. Lindley, P. Wadler, and J. Yallop. Links: Web
programming without tiers. In FMCO ’06, 2006.
[13] J. S. Foster, T. Terauchi, and A. Aiken. Flow sensitive type
qualiﬁers. In PLDI ’02. ACM Press, 2002.
[14] C. Fournet and A. D. Gordon. Stack inspection: theory and
variants. In POPL ’02. ACM Press, 2002.
[15] T. Fraser, J. Nick L. Petroni, and W. A. Arbaugh. Applying
ﬂow-sensitive CQUAL to verify MINIX authorization check
placement. In PLAS. ACM Press, 2006.
[16] J.-Y. Girard.
Interpr´etation fonctionelle et ´elimination des
coupures de l’arithm´etique d’ordre sup´erieur. PhD thesis,
Universit´e Paris VI I, 1972.
[17] L. Gong. Inside Java 2 platform security architecture, API
design, and implementation. Addison-Wesley, 1999.
[18] D. Grossman, G. Morrisett, and S. Zdancewic. Syntactic type
abstraction. ACM TOPLAS, 22(6):1037–1080, 2000.
[19] R. Harper and G. Morrisett. Compiling polymorphism using
intensional type analysis. In POPL ’95. ACM Press, 1995.
[20] B. Hicks, D. King, P. McDaniel, and M. Hicks. Trusted
declassiﬁcation: high-level policy for a security-typed lan-
guage. In PLAS ’06. ACM Press, 2006.
[21] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda,
C. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-oriented pro-
gramming. In ECOOP ’07. Springer-Verlag, 1997.
[22] C. E. Landwehr. The best available technologies for com-
puter security. IEEE Computer, 16(7):89–100, July 1983.
[23] N. Li, J. C. Mitchell, and W. H. Winsborough. Design of
a Role-Based Trust-Management Framework. In S&P ’02.
IEEE Computer Society Press, 2002.
[24] P. Li and S. Zdancewic. Downgrading policies and relaxed
noninterference. In POPL ’05. ACM Press, 2005.
[25] P. Li and S. Zdancewic. Encoding information ﬂow in
Haskell. In CSFW ’06. IEEE Computer Society Press, 2006.
Integrating ﬂexible support
In
for security policies into the Linux operating system.
FREENIX 2001. USENIX Association, 2001.
[26] P. Loscocco and S. Smalley.
[27] D. Marino, B. Chin, T. Millstein, G. Tan, R. J. Simmons,
and D. Walker. Mechanized metatheory for user-deﬁned type
extensions. In WMM ’06, 2006.
[28] J. C. Mitchell. Foundations of Programming Languages.
MIT Press, 1996.
[29] Perl 5.8.8 documentation - perlsec.
http://perldoc.
perl.org/perlsec.html.
[30] F. Pottier and V. Simonet.
Information ﬂow inference for
ML. ACM TOPLAS, 25(1), Jan. 2003.
[31] Reuters, October 2006. U.S. Intelligence Unveils Spy Ver-
sion of Wikipedia.
[32] A. Sabelfeld and A. C. Myers. Language-based information-
ﬂow security. JSAC, 21(1):5–19, Jan. 2003.
[33] A. Sabelfeld and D. Sands. Dimensions and principles of de-
classiﬁcation. In CSFW ’05. IEEE Computer Society, 2005.
[34] SecurityFocus: Access control bypass vulnerabilities.
http://search.securityfocus.com/swsearch?
metaname=alldoc&query=access+control+bypass.
[35] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. Detect-
In
ing Format String Vulnerabilities with Type Qualiﬁers.
USENIX Security ’01. USENIX Association, 2001.
[36] R. E. Strom and S. Yemini. Typestate: A programming
IEEE
language concept for enhancing software reliability.
Trans. Softw. Eng., 12(1):157–171, 1986.
[37] Z. Su and G. Wassermann. The essence of command injec-
tion attacks in web applications. In POPL ’06. ACM Press.
[38] N. Swamy, B. J. Corcoran, and M. Hicks. Fable: A language
for enforcing user-deﬁned security policies. Technical Re-
port CS-TR-4895, Depart. Comp. Sci., U. Maryland, 2007.
Veriﬁed enforcement of
automaton-based information release policies. Technical Re-
port CS-TR-4906, Dept. Comp. Sci., U. Maryland, 2008.
[39] N. Swamy and M. Hicks.
[40] S. Tse and S. Zdancewic.
Information-ﬂow Type Systems.
puter Society Press, 2004.
Run-time Principals in
In S&P ’04. IEEE Com-
[41] D. Volpano, G. Smith, and C. Irvine. A sound type sys-
tem for secure ﬂow analysis. Journal of Computer Security,
4(3):167–187, 1996.
[42] D. Walker. A type system for expressive security policies. In
POPL ’00. ACM Press, 2000.
[43] H. Xi. Applied Type System (extended abstract). In TYPES
2003. Springer-Verlag LNCS 3085, 2004.
[44] H. Xi and F. Pfenning. Dependent types in practical pro-
gramming. In POPL ’99. ACM Press, 1999.
[45] X. Zhang, A. Edwards, and T. Jaeger. Using CQUAL for
static analysis of authorization hook placement. In USENIX
Security, 2002.
[46] L. Zheng and A. C. Myers. Dynamic security labels and
noninterference. In FAST ’04. Springer, 2004.
383
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply.