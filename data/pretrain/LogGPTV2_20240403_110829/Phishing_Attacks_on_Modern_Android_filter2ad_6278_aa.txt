title:Phishing Attacks on Modern Android
author:Simone Aonzo and
Alessio Merlo and
Giulio Tavella and
Yanick Fratantonio
Phishing Attacks on Modern Android
Simone Aonzo, Alessio Merlo, Giulio Tavella
DIBRIS - University of Genoa, Italy
{simone.aonzo,alessio}@dibris.unige.it
PI:EMAIL
ABSTRACT
Modern versions of Android have introduced a number of features
in the name of convenience. This paper shows how two of these fea-
tures, mobile password managers and Instant Apps, can be abused
to make phishing attacks that are significantly more practical than
existing ones. We have studied the leading password managers
for mobile and we uncovered a number of design issues that leave
them open to attacks. For example, we show it is possible to trick
password managers into auto-suggesting credentials associated
with arbitrary attacker-chosen websites. We then show how an
attacker can abuse the recently introduced Instant Apps technology
to allow a remote attacker to gain full UI control and, by abusing
password managers, to implement an end-to-end phishing attack re-
quiring only few user’s clicks. We also found that mobile password
managers are vulnerable to “hidden fields” attacks, which makes
these attacks even more practical and problematic. We conclude
this paper by proposing a new secure-by-design API that avoids
common errors and we show that the secure implementation of
autofill functionality will require a community-wide effort, which
this work hopes to inspire.
KEYWORDS
Mobile Security, Phishing, Password Managers, Instant Apps
ACM Reference Format:
Simone Aonzo, Alessio Merlo, Giulio Tavella and Yanick Fratantonio. 2018.
Phishing Attacks on Modern Android. In Proceedings of 2018 ACM SIGSAC
Conference on Computer and Communications Security (CCS ’18). ACM, New
York, NY, USA, 14 pages. https://doi.org/10.1145/3243734.3243778
1 INTRODUCTION
The role mobile devices have in our lives has been exponentially
increasing in the last decade. Recent reports have shown that more
than half worldwide website traffic has been generated via mo-
bile devices [41]. Users take advantage of these devices not only
to browse websites, but also to access social networks and other
online services, such as online banking. Thus, to improve user expe-
rience, developers of web services often implement native Android
apps, making mobile devices portals to their associated web back-
ends. For example, a vast portion of Facebook accesses in the US
is performed via mobile device [14]. According to these reports,
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ’18, October 15–19, 2018, Toronto, ON, Canada
© 2018 Association for Computing Machinery.
ACM ISBN 978-1-4503-5693-0/18/10...$15.00
https://doi.org/10.1145/3243734.3243778
Yanick Fratantonio
EURECOM, France
PI:EMAIL
this trend is forecasted to only increase in the future, and users
are going to perform more and more often one of the most basic
security-sensitive action: authenticate to mobile apps backends by
inserting their credentials. On the one hand, this shift towards the
mobile world pushed Google and platform developers to design new
technologies and mechanisms to decrease the friction of these user
interactions. On the other hand, unfortunately, the more frequently
users will be asked to insert credentials on their mobile devices, the
more attackers will find mobile phishing attacks rewarding.
In this paper, we take a look at new features introduced in mo-
dern versions of Android, and we show that while they do simplify
both users’ and developers’ lives, their weak design and imple-
mentation allow attackers to abuse them, making mobile phishing
attacks significantly more practical than what previously thought.
Mobile password managers. The first aspect we look at is the
growing popularity of mobile password managers. Password man-
agers have been initially developed for the web, and the security
community has long praised their many benefits. For example, they
provide a practical way for users to use different pseudo-random
passwords for each web service they interact with, thus discourag-
ing the use of simple, easy-to-guess, and shared passwords across
accounts. In fact, the user has a chance to store her credentials and
to associate them to specific websites: when the user later navigates
to the same website, the password manager identifies the website
through its domain name, and it then suggests (and in some cases
automatically fills) the right credentials on behalf of the user.
As a way to support the increasing amount of mobile users, pass-
word managers are now also available for mobile devices. Mobile
password managers are developed as apps, and they include ad-
vanced sync features, which allow suggesting (and filling) website-
related credentials to their associated apps.
From a technical standpoint, these password manager apps either
need to have support from the Android Framework, or they require
modifications to their potential “clients” (e.g., the Facebook app).
In fact, Android apps sandboxing mechanism prevents them to
interact with external apps programmatically. To date, there are
three mechanisms that act as necessary basic blocks to allow for
their implementation. The first is the Accessibility Service [21]
(a11y, in short): while, in theory, a11y is a mechanism to allow apps
to be “accessible” to users with disabilities, it also allows apps to
interact with others programmatically, and it thus provides the
technical capability needed by password managers to implement
their functionality. Since recent works have shown how a11y can
be abused [5, 6, 18, 31, 34, 35, 43], Google has recently implemented
the Autofill Framework [22], a new component of the Android
Framework specifically developed to allow password managers
to suggest and autofill credentials to mobile apps (without the
need to rely on a11y). The third mechanism is called OpenYOLO,
the user is just asked to allow password managers to autofill the
credentials on her behalf.
It is interesting to note how, on the web, password managers
do not ease phishing attacks, but quite the opposite. In fact, web
password managers check the current website domain name to
determine whether to auto-fill (or auto-suggest) credentials: if the
domain name does not match the expectations, no credentials are
suggested. Thus, an attacker that uses particular Unicode characters
to create a facebook.com-looking domain name may fool a human,
but not a password manager: the malicious domain name will be
different from the legitimate one, and the password manager sug-
gestion will not trigger. We thus argue that the mere fact that a
mobile password manager is suggesting credentials associated with
the target website inherently adds legitimacy to the attack, making
it even more effective.
Instant Apps. The second modern feature we explore in this pa-
per is called Instant Apps. This technology, implemented by Google,
allows users to “try” Android apps at the touch of a click, without
the need to fully install the app. Under the hood, the system works
by asking developers to upload small portions of their Android
app, called Instant Apps, and to associate a URL pattern to it. The
developer needs first to prove that she controls the domain name
of the URL pattern. This is carried out through a multi-step pro-
cedure called App Link Verification [29] which relies on Digital
Asset Links [19] protocol (it makes possible to associate an app
with a website and vice versa, via verifiable statements). After this
deployment step, the user will be able to click on a link (pointing to
the specified URL), and, after a one-time confirmation, the Instant
App is automatically downloaded and executed on the user’s device.
In this paper, we show that this technology, while indeed a very
useful Android feature, can make phishing attacks more practical.
The key observation is that Instant Apps provide an attacker the
ability to gain full control over the device UI, without the need of
installing an app. In a browser-only phishing scenario, the user
would have a chance to notice the green lock and inspect the domain
name. However, in an Instant Apps-based attack, the attacker has
full capabilities to deceive the user. For example, an attacker could
create a full-screen Facebook login view (as the real Facebook app
would do). As reported in existing works [4, 8, 9, 38], users cannot
distinguish between these. As another example, an attacker could
simulate the view of a full browser; as the attacker controls every
pixel of the screen, nothing prevents her to show the user a browser-
like view with a spoofed facebook.com domain name and a green
lock: once again, this attack is indistinguishable from a legitimate
scenario. As highlighted by several recent works, the key insight is
that the UI on mobile devices cannot be trusted, and Instant Apps
provide a technical way for an attacker to move from a scenario
where she does not fully control it (like a web page somehow
constrained by the web browser security mechanisms) to a scenario
where she fully does.
End-to-end attack. The combination of flawed mobile password
managers and Instant Apps allow attackers to develop and mount
mobile phishing attacks that are much more practical than what pre-
viously known [8, 9, 18, 38]. In fact, we have found that, although
Instant Apps are not “fully installed” apps, 1) password managers
currently do not notice the difference, and that 2) their package
(a)
(b)
Figure 1: Android password managers (1a) Dashlane and (1b)
Keeper, suggesting Facebook credentials to a fake malicious
app.
a recently-proposed protocol for storing and updating credentials
for mobile apps [20]. This mechanism is developed by Google and
Dashlane, and it follows a different paradigm: it does not affect the
Android Framework, but it requires modifications of each “client”
(e.g., Facebook) and “server” app (e.g., the password manager).
In this paper, we show that all these three mechanisms are af-
fected by design and implementation issues. At the root of the
problems is the need to bridge the mobile world with the web world:
given an app with a login form, how can a password manager
know whether this app is the legitimate Facebook app (and it is
thus entitled to access Facebook credentials) or whether this is a
malicious app attempting to appear as the legitimate one? How is
it possible to know which app is linked to which domain name?
The key design issue is that all these three mechanisms use the app
package name as the main abstraction to identify an app. Password
managers thus need to somehow map package names to associated
websites.
While a technical solution to securely implement such mapping
exists, this work shows that the poor design choices of the underly-
ing mechanisms push to the implementation of vulnerable solutions.
In particular, we have investigated the four leading third-party mo-
bile password managers app (Keeper [26], Dashlane [2], LastPass [3],
1Password [1]), as well as Google Smart Lock (GSL) [24]: we have
found that only GSL is securely implemented. Moreover, we have
found that Keeper, Dashlane, and LastPass all implement various
(vulnerable) heuristics, each of which misplaces trust in an app
package name or other metadata. The net result is that it is possible
for a malicious app to systematically lure these password managers
to leak credentials associated with arbitrary attacker-chosen websites.
To make it worse, we note that these attacks also work for websites
for which an associated mobile app does not exist. These attacks
effectively make mobile phishing more practical: differently than all
previous works, the user is not even asked to type her credentials;
name is the same as the associated full app. This means that the
package name of the Instant App is attacker-controlled, and that
it is thus possible to trick password managers to auto-fill credentials
for an attacker-chosen website even without requiring the installa-
tion of an additional app. This allows an attacker to bootstrap an
end-to-end phishing attack by luring the victim into visiting a ma-
licious webpage: such webpage may contain, for example, a fake
Facebook-related functionality. Upon clicking on it, the Instant App
mechanism is triggered, the attacker can spoof a full-screen Face-
book login form, at which point the password manager would offer
to automatically fill the credentials on behalf of the victim.
To make things worse, we found that current password managers
fill hidden fields as well. An attacker could thus create a form with
a visible username field but a hidden password field: while the
unsuspecting user thinks she is autofilling only the username, her
password manager will silently leak her password to the attacker.
To the best of our knowledge, the attacks presented in this paper
are the most advanced and practical phishing attack techniques
to date. In fact, all existing approaches assume a malicious app in-
stalled on the user’s device, ask the user to manually insert her cre-
dentials (which although not technically problematic, may reduce
the attack success rate), or fall back to web-based phishing attacks
(that are noticeable at least from the browser bar) [8, 9, 18, 38].
A look to the future. The future of these problems does not look
encouraging. The current API has a design that is error-prone and
does not force developers to take all necessary steps to avoid severe
vulnerabilities. In this paper we discuss the design of a new API,
called getVerifiedDomainNames(), that uses domain names as the
main abstraction level (instead of package names, which should not
be trusted), and it hides behind a single, central implementation the
necessary logic and security steps to establish that a requesting app
does have authority over the credentials it is requesting. Internally,
this new API relies on an existing technical solution based on
Digital Asset Links [19] verification. This solution requires websites
owners to publish an “assets” file on their website so that an app-
website “link” can be established.1 This is the same mechanism that
Autofill Framework and OpenYOLO suggest developers to use: the
difference is that our API forces them to use it, instead of leaving
them open to implement vulnerable solutions—as they did.
Unfortunately, although we believe that this solution is tech-
nically sound, the current ecosystem is far from being ready. In
fact, the App Link Verification requires collaboration from websites
owners, as they would need to upload the appropriate assets file to
their website. To determine the readiness of the ecosystem to this
mechanism, we first built a dataset of 8,821 domain names extracted
from the password managers we have analyzed (given the source
of this dataset, these domain names are guaranteed to have at least
one login form, otherwise they would not be relevant to password
managers). We then checked how many websites already link them-
selves to an app: to our surprise, only 178 of them currently have
an assetlinks.json compatible with the proposed solution, which
is around 2%. This means that, to date, password managers deve-
lopers do not have the necessary information to securely implement
their functionality, even if they wanted to. One may then wonder
1Such “assets” file needs to be placed at a specific location: https://domain.name/.well-
known/assetlinks.json
how Google Smart Lock, which we found to be secure, implements
such mapping. We found that, although a technical solution exists,
this process is not automatic: according to the official documenta-
tion [25], the last step of the process requires developers to manu-
ally fill a Google Form [28] to provide the needed information. We
conclude that the adoption of a secure mapping cannot be easily ad-
dressed by the single actors alone, but it requires a community-wide
effort, which this work hopes to inspire.
In summary, this paper provides the following contributions:
• We performed the first security analysis of mobile password
managers and the three core technologies they rely on: a11y,
Autofill Framework, and OpenYOLO; we have uncovered de-
sign and implementation issues that allow attackers to trick
password managers to leak to malicious apps credentials
associated to arbitrary attacker-chosen websites;
• We show how Instant Apps can be abused to gain full UI
control and how they can be used to lower the bar for stealthy
and practical phishing attacks;
• We present an end-to-end phishing attack that abuses pass-
word managers and Instant Apps, and we show that current
implementations automatically fill hidden password fields.
We believe this to be the most advanced and practical phish-
ing attack to date;
• We propose a new secure-by-design API that moves the
• We provide empirical evidence that the current ecosystem is
not ready yet to support secure autofill on mobile devices,
and that a community-wide effort is required to address
these issues.
abstraction from package names to domain names;
2 BACKGROUND
Android mobile apps are compiled and distributed as self-contained
files, called APKs. Apps are usually distributed via app stores. One
main distribution option is the official Google store, called Play
Store. Alternatively, a developer can upload her app to so-called
third-party markets. Although very popular in some countries (e.g.,
China, India), these markets are traditionally perceived as less se-
cure. For this reason, to install apps hosted outside the Play Store,
users need to manually enable a security option called side-loading
(off by default).