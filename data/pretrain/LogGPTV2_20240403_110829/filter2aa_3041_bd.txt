 log.Println(m.name) 
30 
 time.Sleep(time.Second) 
31 } 
32 
33 // main 是所有 Go 程序的入口 
34 func main() { 
35 
 // 使用两个 goroutine 来创建工作池 
36 
 p := work.New(2) 
37 
38 
 var wg sync.WaitGroup 
39 
 wg.Add(100 * len(names)) 
40 
41 
 for i := 0; i < 100; i++ { 
42 
 // 迭代 names 切片 
43 
 for _, name := range names { 
44 
 // 创建一个 namePrinter 并提供 
45 
 // 指定的名字 
46 
 np := namePrinter{ 
47 
 name: name, 
48 
 } 
49 
50 
 go func() { 
51 
 // 将任务提交执行。当 Run 返回时 
52 
 // 我们就知道任务已经处理完成 
53 
 p.Run(&np) 
54 
 wg.Done() 
55 
 }() 
56 
 } 
57 
 } 
58 
59 
 wg.Wait() 
60 
61 
 // 让工作池停止工作，等待所有现有的 
62 
 // 工作完成 
63 
 p.Shutdown() 
64 } 
代码清单 7-34 展示了使用 work 包来完成名字显示工作的测试程序。这段代码一开始在第
14 行声明了名为 names 的包级的变量，这个变量被声明为一个字符串切片。这个切片使用 5 个
名字进行了初始化。然后声明了名为 namePrinter 的类型，如代码清单 7-35 所示。
代码清单 7-35  work/main/main.go：第 22 行到第 31 行
22 // namePrinter 使用特定方式打印名字 
23 type namePrinter struct { 
24 
 name string 
25 } 
26 
27 // Task 实现 Worker 接口 
28 func (m *namePrinter) Task() { 
29 
 log.Println(m.name) 
30 
 time.Sleep(time.Second) 
31 } 
在代码清单 7-35 的第 23 行，声明了 namePrinter 类型，接着是这个类型对 Worker 接口
的实现。这个类型的工作任务是在显示器上显示名字。这个类型只包含一个字段，即 name，它
包含要显示的名字。Worker 接口的实现 Task 函数用 log.Println 函数来显示名字，之后等
待 1 秒再退出。等待这 1 秒只是为了让测试程序运行的速度慢一些，以便看到并发的效果。 
有了 Worker 接口的实现，我们就可以看一下 main 函数内部的代码了，如代码清单 7-36
所示。 
代码清单 7-36  work/main/main.go：第 33 行到第 64 行
33 // main 是所有 Go 程序的入口 
34 func main() { 
35 
 // 使用两个 goroutine 来创建工作池 
36 
 p := work.New(2) 
37 
38 
 var wg sync.WaitGroup 
39 
 wg.Add(100 * len(names)) 
40 
41 
 for i := 0; i < 100; i++ { 
42 
 // 迭代 names 切片 
43 
 for _, name := range names { 
44 
 // 创建一个 namePrinter 并提供 
45 
 // 指定的名字 
46 
 np := namePrinter{ 
47 
 name: name, 
48 
 } 
49 
50 
 go func() { 
51 
 // 将任务提交执行。当 Run 返回时 
52 
 // 我们就知道任务已经处理完成 
53 
 p.Run(&np) 
54 
 wg.Done() 
55 
 }() 
56 
 } 
57 
 } 
58 
59 
 wg.Wait() 
60 
61 
 // 让工作池停止工作，等待所有现有的 
62 
 // 工作完成 
63 
 p.Shutdown() 
64 } 
在代码清单 7-36 第 36 行，调用 work 包里的 New 函数创建一个工作池。这个调用传入的参
数是 2，表示这个工作池只会包含两个执行任务的 goroutine。在第 38 行和第 39 行，声明了一个
WaitGroup，并初始化为要执行任务的 goroutine 数。在这个例子里，names 切片里的每个名字
都会创建 100 个 goroutine 来提交任务。这样就会有一堆 goroutine 互相竞争，将任务提交到池里。 
在第 41 行到第 43 行，内部和外部的 for 循环用来声明并创建所有的 goroutine。每次内部
循环都会创建一个 namePrinter 类型的值，并提供一个用来打印的名字。之后，在第 50 行，
声明了一个匿名函数，并创建一个 goroutine 执行这个函数。这个 goroutine 会调用工作池的 Run
方法，将 namePrinter 的值提交到池里。一旦工作池里的 goroutine 接收到这个值，Run 方法
就会返回。这也会导致 goroutine 将 WaitGroup 的计数递减，并终止 goroutine。
一旦所有的 goroutine 都创建完成，main 函数就会调用 WaitGroup 的 Wait 方法。这个调
用会等待所有创建的 goroutine 提交它们的工作。一旦 Wait 返回，就会调用工作池的 Shutdown
方法来关闭工作池。Shutdown 方法直到所有的工作都做完才会返回。在这个例子里，最多只会
等待两个工作的完成。 
7.4  小结 
可以使用通道来控制程序的生命周期。
带 default 分支的 select 语句可以用来尝试向通道发送或者接收数据，而不会阻塞。 
有缓冲的通道可以用来管理一组可复用的资源。
语言运行时会处理好通道的协作和同步。
使用无缓冲的通道来创建完成工作的 goroutine 池。
任何时间都可以用无缓冲的通道来让两个 goroutine 交换数据，在通道操作完成时一定保
证对方接收到了数据。 
第 8 章  标准库 
本章主要内容 
输出数据以及记录日志
对 JSON 进行编码和解码
处理输入/输出，并以流的方式处理数据
让标准库里多个包协同工作
什么是 Go 标准库？为什么这个库这么重要？Go 标准库是一组核心包，用来扩展和增强语
言的能力。这些包为语言增加了大量不同的类型。开发人员可以直接使用这些类型，而不用再写
自己的包或者去下载其他人发布的第三方包。由于这些包和语言绑在一起发布，它们会得到以下
特殊的保证： 
每次语言更新，哪怕是小更新，都会带有标准库；
这些标准库会严格遵守向后兼容的承诺；
标准库是 Go 语言开发、构建、发布过程的一部分；
标准库由 Go 的构建者们维护和评审；
每次 Go 语言发布新版本时，标准库都会被测试，并评估性能。
这些保证让标准库变得很特殊，开发人员应该尽量利用这些标准库。使用标准库里的包可以
使管理代码变得更容易，并且保证代码的稳定。不用担心程序无法兼容不同的 Go 语言版本，也
不用管理第三方依赖。 
如果标准库包含的包不够好用，那么这些好处实际上没什么用。Go 语言社区的开发者会比
其他语言的开发者更依赖这些标准库里的包的原因是，标准库本身是经过良好设计的，并且比其
他语言的标准库提供了更多的功能。社区里的 Go 开发者会依赖这些标准库里的包做更多其他语
言中开发者无法做的事情，例如，网络、HTTP、图像处理、加密等。 
本章中我们会大致了解标准库的一部分包。之后，我们会更详细地探讨 3 个非常有用的包：
log、json 和 io。这些包也展示了 Go 语言提供的重要且有用的机制。
8
第 8 章  标准库 
8.1  文档与源代码 
标准库里包含众多的包，不可能在一章内把这些包都讲一遍。目前，标准库里总共有超过
100 个包，这些包被分到 38 个类别里，如代码清单 8-1 所示。 
代码清单 8-1  标准库里的顶级目录和包 
archive   bufio 
 bytes 
 compress   container   crypto    database 
debug 
 encoding   errors    expvar 
 flag    
 fmt 
 go 
hash 
 html 
 image 
 index 
 io    
 log 
 math 
mime 
 net 
 os 
 path 
 reflect 
 regexp    runtime 
sort 
 strconv    strings   sync 
 syscall 
 testing   text 
time 
 unicode    unsafe 
代码清单 8-1 里列出的许多分类本身就是一个包。如果想了解所有包以及更详细的描述，Go
语言团队在网站上维护了一个文档，参见 http://golang.org/pkg/。 
golang 网站的 pkg 页面提供了每个包的 godoc 文档。图 8-1 展示了 golang 网站上 io
包的文档。 
图 8-1  golang.org/pkg/io/#Writer 
如果想以交互的方式浏览文档，Sourcegraph 索引了所有标准库的代码，以及大部分包含 Go
代码的公开库。图 8-2 是 Sourcegraph 网站的一个例子，展示的是 io 包的文档。
图 8-2  sourcegraph.com/code.google.com/p/go/.GoPackage/io/.def/Writer 
不管用什么方式安装 Go，标准库的源代码都会安装在$GOROOT/src/pkg 文件夹中。拥有标
准库的源代码对 Go 工具正常工作非常重要。类似 godoc、gocode 甚至 go build 这些工具，
都需要读取标准库的源代码才能完成其工作。如果源代码没有安装在以上文件夹中，或者无法通
过$GOROOT 变量访问，在试图编译程序时会产生错误。
作为 Go 发布包的一部分，标准库的源代码是经过预编译的。这些预编译后的文件，称作归
档文件（archive file），可以 在$GOROOT/pkg 文件夹中找到已经安装的各目标平台和操作系统的
归档文件。在图 8-3 里，可以看到扩展名是.a 的文件，这些就是归档文件。 
图 8-3  pkg 文件夹中的归档文件的文件夹的视图 
这些文件是特殊的 Go 静态库文件，由 Go 的构建工具创建，并在编译和链接最终程序时被
使用。归档文件可以让构建的速度更快。但是在构建的过程中，没办法指定这些文件，所以没办
法与别人共享这些文件。Go 工具链知道什么时候可以使用已有的.a 文件，什么时候需要从机器
上的源代码重新构建。 
有了这些背景知识，让我们看一下标准库里的几个包，看看如何用这些包来构建自己的程序。 
8.2  记录日志 
即便没有表现出来，你的程序依旧可能有 bug。这在软件开发里是很自然的事情。日志是一
种找到这些 bug，更好地了解程序工作状态的方法。日志是开发人员的眼睛和耳朵，可以用来跟
踪、调试和分析代码。基于此，标准库提供了 log 包，可以对日志做一些最基本的配置。根据
特殊需要，开发人员还可以自己定制日志记录器。 
在 UNIX 里，日志有很长的历史。这些积累下来的经验都体现在 log 包的设计里。传统的
CLI（命令行界面）程序直接将输出写到名为 stdout 的设备上。所有的操作系统上都有这种设
备，这种设备的默认目的地是标准文本输出。默认设置下，终端会显示这些写到 stdout 设备上
的文本。这种单个目的地的输出用起来很方便，不过你总会碰到需要同时输出程序信息和输出执
行细节的情况。这些执行细节被称作日志。当想要记录日志时，你希望能写到不同的目的地，这
样就不会将程序的输出和日志混在一起了。 
为了解决这个问题，UNIX 架构上增加了一个叫作 stderr 的设备。这个设备被创建为日志
的默认目的地。这样开发人员就能将程序的输出和日志分离开来。如果想在程序运行时同时看到
程序输出和日志，可以将终端配置为同时显示写到 stdout 和 stderr 的信息。不过，如果用
户的程序只记录日志，没有程序输出，更常用的方式是将一般的日志信息写到 stdout，将错误
或者警告信息写到 stderr。
8.2.1  log 包 
让我们从 log 包提供的最基本的功能开始，之后再学习如何创建定制的日志记录器。记录
日志的目的是跟踪程序什么时候在什么位置做了什么。这就需要通过某些配置在每个日志项上要
写的一些信息，如代码清单 8-2 所示。 
代码清单 8-2  跟踪日志的样例 
TRACE: 2009/11/10 23:00:00.000000 /tmpfs/gosandbox-/prog.go:14: message 
在代码清单 8-2 中，可以看到一个由 log 包产生的日志项。这个日志项包含前缀、日期时间
戳、该日志具体是由哪个源文件记录的、源文件记录日志所在行，最后是日志消息。让我们看一
下如何配置 log 包来输出这样的日志项，如代码清单 8-3 所示。
代码清单 8-3  listing03.go 
01 // 这个示例程序展示如何使用最基本的 log 包 
02 package main 
03 
04 import ( 
05 
 "log" 
06 ) 
07 
08 func init() { 
09 
 log.SetPrefix("TRACE: ") 
10 
 log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile) 
11 } 