The create trustpolicy statement is represented as a trig-
ger whose condition is the condition speciﬁed in the policy.
The trigger event reacts to the insertion of a tuple in the
trust table referred in the condition. The trigger action
grants the session a privilege to activate the role (and acti-
vates it automatically if the autoactivate clause is speci-
ﬁed).
6. PROTOTYPE IMPLEMENTATION
To demonstrate the realizability within current DBMSs of
the proposed trust management model, a related project is
currently producing an implementation in the PostgreSQL
system. PostgreSQL is a well-known open-source DBMS,
already chosen as a testbed for the implementation of novel
database technologies by many other research initiatives.
The ﬁrst design issue was the choice of the component re-
sponsible for the cryptographic functions used for the ver-
iﬁcation of certiﬁcates. The OpenSSL system has been se-
lected, which is one of the most used implementations of the
SSL protocol. The PostgreSQL distribution already oﬀers
the possibility to integrate the OpenSSL system, but it only
uses it for the realization of a dialog between a client and
the PostgreSQL server using an SSL connection. Since Post-
greSQL does not support global temporary tables5, trust
tables have been managed by regular tables that explicitly
represent the session identiﬁer together with the attributes
obtained by certiﬁcates. The model presented in the pa-
per restricts the use of trust table attributes to two situ-
ations: the deﬁnition of trust policies and the deﬁnition of
views. The management of create trustpolicy statements
is based on the use of triggers. The management of the
create view statement follows the same approach used in
PostgreSQL for the management of views, which uses rules.
PostgreSQL rules are rewriting rules that capture references
to views and replace each occurrence of the view in a SQL
statement with the corresponding query. PostgreSQL rules
can be immediately adapted to the representation of views
using certiﬁcate attributes. Starting from a view deﬁnition,
a rule is produced that replaces the view occurrence with
the query that deﬁned the view, extended with the pred-
icate that restricts the evaluation of certiﬁcate attributes
only to the tuples of the trust table that refer to the session
in which the SQL command is executed.
Example 6. Consider the following view, which uses an
attribute of trust table Physicians.
create view PatientView as
select Patients.*
from Patients, Physicians
where Physicians.code = Patients.doctor_code
The system produces the following PostgreSQL rule.
create rule PatietViewsSelect as
on select to PatientView
do
select Patients.*
from Patients, Physicians
where Physicians.code = Patients.doctor_code
and Physicians.SessionId = session_identifier()
7. RELATED WORK
Trust management has received considerable interest in the
research community. Much of this research, however, focuses
on the formalization and analysis of the expressive power of
authorization systems, without addressing the practical de-
tails and strategies for integrating and implementing trust
management in the DBMS. In contrast, our approach can
be easily incorporated into a DBMS, increasing the expres-
siveness of the access control model in terms of protection
requirements that can be supported.
The term trust management was ﬁrst introduced in [3] by
Blaze, Feigenbaum, and Lacy, where the authors presented
5Note that temporary tables in PostgreSQL are only local,
that is, they have to be created with a create table state-
ment within a session, and are dropped at the end of the
session.
157
a trust management system, called PolicyMaker, where au-
thorizations are associated with keys rather than with users’
identities. An application sends to the execution environ-
ment a request for actions, a policy, and a set of credentials
and the execution environment returns an answer to the
question of whether the credentials prove that the request
complies with the policy. The KeyNote system [2], the suc-
cessor of PolicyMaker, reﬁnes the idea of PolicyMaker into
a more practical system. REFEREE (Rule-controlled Envi-
ronment For Evaluation of Rules, and Everything Else) [5] is
a trust management system for Web applications. Like Poli-
cyMaker, it supports full programmability of assertions (i.e.,
policies and credentials). While these approaches provide an
interesting framework for reasoning about trust between un-
known parties, the ﬂexibility of the delegation mechanism is
diﬃcult to integrate with a DBMS, and suggests an access
control model which strictly merges authentication and pol-
icy evaluation, in a way that is diﬃcult to integrate with
database access control.
Other approaches use digital certiﬁcates to establish prop-
erties of their holder, delegation and revocation of creden-
tials, and evaluation of credential chains [8, 12, 15]. In [12]
the authors present an algorithm for discovering credential
chains expressed using a role-based trust management lan-
guage, called RT0. Wang et. al [15] propose a framework
that models an attribute-based access control system using
logic programming with set constraints of a computable set
theory. The Simple Public Key Infrastructure (SPKI) 2.0 [8]
is a digital-certiﬁcate schema where SPKI certiﬁcates can be
seen as tuples that can bind names to keys, names to priv-
ileges, and privileges to keys. All these proposals permit
a powerful representation of privileges based on the infor-
mation presented in certiﬁcates, but none of them is able
to oﬀer guarantees on the computational eﬀort required for
certiﬁcate veriﬁcation.
X.509 [9] focused on the deﬁnition of a binding between keys
and names, and X.509 v.3 certiﬁcates extended this binding
to general attributes. X.509 is currently the most successful
solution, but its delegation model and certiﬁcate structure
are quite rigid. The model proposed in this paper permits to
exploit the existing X.509 infrastructure for the realization
of ﬂexible policies.
Other complementary approaches (e.g., [4, 10, 11, 13, 16,
17, 18, 19]) propose solutions for specifying and enforcing
access control policies based on certiﬁed attributes. These
proposals focus in particular on the assumption that parties
may be unknown a-priori and therefore propose approaches
and strategies for parties to communicate to each other their
policies as well as releasing their certiﬁcates, possibly under-
taking a multi-step negotiation process. In this paper, we
have assumed the client to present all certiﬁcates needed
for an access at the request time. This does not rule out
compatibility with the diﬀerent proposals supporting trust
negotiation. Our assumption is essentially that the negotia-
tion is completed before the trust management service starts
the veriﬁcation process.
8. CONCLUSIONS
Even if trust management mechanisms have been proposed
a few years ago, their adoption has until now been limited.
This is mostly due to the obstacles arising in the implemen-
tation of a working infrastructure for the management and
exchange of certiﬁcates, as testiﬁed by the time and eﬀort
spent for the realization of the current infrastructure based
on X.509 certiﬁcates. Part of the responsibility can also be
assigned to the absence of a clear strategy for the integration
of these services with database servers, which today manage
most of the information for which it is important to deﬁne a
rich and ﬂexible access control model. Many trust manage-
ment proposals present mechanisms that are quite powerful,
but that are diﬃcult to integrate with current DBMSs. In-
deed, most previous proposals had as main aim the increase
in expressive power, in order to represent evermore complex
and sophisticated scenarios.
Our approach has set as the primary requirement its com-
patibility with consolidated DBMS practices. The strict in-
tegration with the full set of current DBMS services provides
to our model a considerable expressive power. Exploiting
the integration of the policy with the active components
(triggers, procedures, constraints, roles, transactions) and
rich storage services oﬀered by SQL, we were able to ade-
quately represent all the scenarios that we analyzed. The so-
lution presented in this paper is designed to be immediately
implemented by DBMS producers and used by DBAs. We
believe that our solution represents a good trade oﬀ between
functionality and applicability. Indeed, while not enjoying
the complete functionality of trust management approaches,
it captures their essential features and functions thus en-
abling the use of trust management concepts in practice.
9. ACKNOWLEDGMENTS
This work was supported in part by the European Union
within the PRIME Project in the FP6/IST Programme un-
der contract IST-2002-507591.
10. REFERENCES
[1] C. Ardagna, E. Damiani, S. De Capitani di Vimercati,
S. Foresti, and P. Samarati. Trust management. In
Security, Privacy and Trust in Modern Data
Management. Springer, 2006.
[2] M. Blaze, J. Feigenbaum, J. Ioannidis, and
A. Keromytis. The KeyNote Trust Management
System (Version 2), internet rfc 2704 edition, 1999.
[3] M. Blaze, J. Feigenbaum, and J. Lacy. Decentralized
trust management. In Proc. of the 17th Symposium on
Security and Privacy, Oakland, California, USA, May
1996.
[4] P. Bonatti and P. Samarati. A uniﬁed framework for
regulating access and information release on the web.
Journal of Computer Security, 10(3):241–272, 2002.
[5] Y. Chu, J. Feigenbaum, B. LaMacchia, P. Resnick,
and M. Strauss. REFEREE: Trust management for
web applications. The World Wide Web Journal,
2(3):127–139, 1997.
[6] Database language SQL – part 2: Foundation
(SQL/foundation). ISO International Standard,
ISO/IEC 9075:1999, 1999.
[7] S. De Capitani di Vimercati, S. Foresti, S. Jajodia,
and P. Samarati. Access control policies and languages
in open environments. In Security in Decentralized
Data Management. Springer, 2006.
158
[8] C. Ellison, B. Frantz, B. Lampson, R. Rivest,
B. Thomas, and T. Ylonen. SPKI certiﬁcate theory.
RFC2693, September 1999.
[9] R. Housley, W. Ford, W. Polk, and D. Solo. Internet
X.509 Public Key Infrastructure Certiﬁcate and CRL
Proﬁle, rfc 2459 edition, January 1999.
http://www.ietf.org/rfc/rfc2459.txt.
[10] K. Irwin and T. Yu. Preventing attribute information
leakage in automated trust negotiation. In Proc. of the
12th ACM CCS, Alexandria, VA, USA, Nov. 2005.
[11] N. Li, J. Mitchell, and W. Winsborough. Beyond
proof-of-compliance: Security analysis in trust
management. Journal of the ACM, 52(3):474–514,
May 2005.
[12] N. Li, W. Winsborough, and J. Mitchell. Distributed
credential chain discovery in trust management.
Journal of Computer Security, 11(1):35–86, February
2003.
[13] J. Ni, N. Li, and W. Winsborough. Automated trust
negotiation using cryptographic credentials. In Proc.
of the 12th ACM CCS, Alexandria, VA, USA, Nov.
2005.
[14] P. Samarati and S. De Capitani di Vimercati. Access
control: Policies, models, and mechanisms. In
R. Focardi and R. Gorrieri, editors, Foundations of
Security Analysis and Design, LNCS 2171.
Springer-Verlag, 2001.
[15] L. Wang, D. Wijesekera, and S. Jajodia. A logic-based
framework for attribute based access control. In Proc.
of the 2004 ACM Workshop on Formal Methods in
Security Engineering, Washington DC, USA, October
2004.
[16] J. Warner, V. Atluri, and R. Mukkamala. An
attribute graph based approach to map local access
control policies to credential based access control
policies. In Proc. of the International Conference on
Information Systems Security (ICISS 2005), Kolkata,
India, December 2005.
[17] M. Winslett, N. Ching, V. Jones, and I. Slepchin.
Using digital credentials on the World-Wide Web.
Journal of Computer Security, 1997.
[18] T. Yu and M. Winslett. A uniﬁed scheme for resource
protection in automated trust negotiation. In Proc. of
the IEEE Symposium on Security and Privacy,
Oakland, CA, USA, May 2003.
[19] T. Yu, M. Winslett, and K. Seamons. Supporting
structured credentials and sensitive policies through
interoperable strategies for automated trust
negotiation. ACM Transactions on Information and
System Security, 6(1):1–42, February 2003.
159
APPENDIX
A. TRANSLATION OF SQL TRUST STATEMENTS
SQL trust statement
SQL statement
create authority AuthorityName
public_key = PublicKeyValue
insert into Authority values(AuthorityName,PublicKeyValue)
create authorityclass AuthorityClassName
create global temporary table AuthorityClassName
[authoritative
AuthorityClassOrName [with [no] delegation]
{,AuthorityClassOrName [with [no] delegation]}]
[except AuthorityName{, AuthorityName}]
( AttrName AttrDomain [check (Condition)]
{,AttrName AttrDomain [check (Condition)]}
[, check (Condition)])
create trusttable TrustTableName
[authoritative
( AttrName AttrDomain [check (Condition)]
{,AttrName AttrDomain [check (Condition)]}
[, check (Condition)])
For AuthorityClassOrName in authoritative and with delegation do
insert into AuthorityClass
values(AuthorityClassName,AuthorityClassOrName,true )
For AuthorityClassOrName in authoritative and with no delegation do
insert into AuthorityClass
values(AuthorityClassName,AuthorityClassOrName,false )
For AuthorityName in except do
insert into NotAuthorityClass
values(AuthorityClassName,AuthorityName)
create global temporary table TrustTableName
( AttrName AttrDomain [check (Condition)]
AuthorityClassOrName [with [no] delegation]
{,AuthorityClassOrName [with [no] delegation]}]
{,AttrName AttrDomain [check (Condition)]}
[, check (Condition)])
[except AuthorityName{, AuthorityName}]
( AttrName AttrDomain [check (Condition)]
{,AttrName AttrDomain [check (Condition)]}
[, check (Condition)])
create trustpolicy PolicyName
for Role autoactivate as
Condition
/* Condition on trust table TrustTableName */
For AuthorityClassOrName in authoritative and with delegation do
insert into AuthorityTT
values(TrustTableName,AuthorityClassOrName,true)
For AuthorityClassOrName in authoritative and with no delegation do
insert into AuthorityTT
values(TrustTableName,AuthorityClassOrName,false)
For AuthorityName in except do
insert into NotAuthorityTT
values(TrustTableName,AuthorityName)
create trigger PolicyName
after insert on TrustTableName
for each row
when Condition
grant Role to session id
set role Role
160