**作者：wh1t3Pig  
原文链接：[《基于代码属性图的自动化漏洞挖掘实践》](https://blog.0kami.cn/blog/2023/%E5%9F%BA%E4%BA%8E%E4%BB%A3%E7%A0%81%E5%B1%9E%E6%80%A7%E5%9B%BE%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%AE%9E%E8%B7%B5/
"《基于代码属性图的自动化漏洞挖掘实践》")**
## 0 前言
应用程序分析技术挖掘应用漏洞一直以来都是学术界和工业界的研究重点之一。从最初的正则匹配到最近的代码属性图挖掘方案，国内外有很多来自不同阶段的安全工具或商业产品来发掘程序代码的安全问题。在
Java 语言方面，业界已经有了不少出色的产品，如 CodeQL
等，但是，多数产品考虑的角度是从甲方视角或开源视角出发的，也就是产品的输入大部分是以源码为主。然而，我们安全研究人员更多面对地是编译后的项目，比如编译后的
WAR、第三方依赖 JAR 等形式。对于此类形式目标的漏洞挖掘，当前存在的审计产品或多或少都有一些限制，比如最近几年很火的 CodeQL
就无法直接处理此类形式的目标代码。当前，安全研究人员大多以人工或一些辅助工具来完成此类形式项目的漏洞挖掘。很明显，这种方式审计效率是非常低的，而且，审计结果也很容易遗漏。为此，需要一款能解决此类问题的工具。
## 1 方案介绍
为了更好地辅助安全研究人员进行漏洞挖掘，我设计了基于代码属性图的自动化漏洞挖掘方案，并开发了 tabby
项目用于解决此类问题，旨在更简单更全面地挖掘更多的安全问题。方案通过整合代码语义信息和图数据库相关技术，使得单一项目（编译后的目标文件）分析后可多次重复分析，而无需重复进行繁重的程序语义分析。这种方式带来了分析成本上的优势。并且图数据库自身所擅长的路径检索能力也能充分发挥在漏洞调用链路的挖掘上。
方案将传统的程序分析流程拆分成了两个阶段，包括代码属性图生成阶段和漏洞发现阶段。由代码属性图生成阶段生成的带污点信息的代码属性图将作为漏洞发现阶段的基础，用于动态查询分析具体漏洞细节。
从开发实现上看，主要为 tabby 核心项目和用于跟踪数据流的 neo4j 扩展 tabby path finder，如下图所示：
接下来，将详细介绍我们是怎么设计和实现这个方案的。
### 1\. 针对面向对象语言的代码属性图实现方案
首先，最基础的是如何设计一个能在图数据库中直接进行代码分析的图结构。为此，我们调研了一些学术界的代码属性图实现方案，如下几篇重要的论文
    [1] Martin M, Livshits B, Lam M S. Finding application errors and security flaws using PQL: a program query language[J]. Acm Sigplan Notices, 2005, 40(10): 365-383.
    [2] Yamaguchi F, Golde N, Arp D, et al. Modeling and discovering vulnerabilities with code property graphs[C]//2014 IEEE Symposium on Security and Privacy. IEEE, 2014: 590-604.
    [3] Backes M, Rieck K, Skoruppa M, et al. Efficient and flexible discovery of php application vulnerabilities[C]//2017 IEEE european symposium on security and privacy (EuroS&P). IEEE, 2017: 334-349.
上面三篇论文在代码属性图的设计上做了一些尝试，但是他们主要针对的对象是面向过程语言，这其中不涉及解决一些面向对象语言的特性，比如多态特性。举个实际例子
    interface IFace {
        void test();
    }
    class A implements IFace {
        public void test(){}
    }
    class B implements IFace {
        public void test(){}
    }
    class Main {
        public static void test(IFace iFace){
            iFace.test();
        }
        public static void main(String[] args) {
            IFace a = new A();
            test(a);
            IFace b = new B();
            test(b);
        }
    }
如果采用论文中所设计的代码属性图，简化分析 `Main#test` 函数，我们可以得到这样一个指向关系
在面向过程语言中，这样分析是没有问题的，因为 `IFace` 对象的指向是固定的，而在面向对象语言中，由于 IFace 是一个接口 interface
类型，它实际的代码实现是空的，我们需要找到对应的具体实现该接口的对象才能进行相应分析。比如上述的代码表示，我们需要从分析过程中，推算出当前执行的
`iFace.test()` 可能是 `A.test` 或 `B.test`。很明显，此类代码属性图是不符合分析面向对象语言的。
此外，上述论文中的代码属性图都保留了 AST、CFG，但是，实际上如果当前函数内容和分析算法均不发生改变，不管是第一次分析也好，还是第 n
次分析也好，其分析结果是固定的，那么保留 AST、CFG 结构除了更好的展示代码结构外，并没有起到多大的用处。当然，假设分析算法也同时开放给用户的情况另算。
为了能契合面向对象语言，我们重新设计了面向对象语言的代码属性图实现方案。我们的方案摒弃了多余的数据结构（AST、CFG），新增了针对面向对象语言的特殊数据结构。
该代码属性图实现方案由类关系图 ORG、函数别名图 MAG、函数调用图 MCG 3 种子图组合而成。图中共有 Class 和 Method 两种实体节点，5
种关系边，下文将详细叙述这三种子图构成及作用。
#### 类关系图 Object Relation Graph
类关系图用于描述对象自身的相关语义信息和对象之间的语义关系，共三种关系
  * 类与函数之间的归属关系 HAS 边 
  * 类与接口之间的实现关系 INTERFACE 边 
  * 类与类之间的继承关系 EXTENDS 边 
通过串联类与类、类与函数之间的关系边，我们可以得到一颗颗独立对象函数继承树。 利用 Neo4j 的查询语法，我们可以动态查询符合条件的类和函数。
#### 函数别名图 Method Alias Graph
在前文中，提到了三篇论文设计的代码属性图没有考虑面向对象语言，导致在图中函数调用之间是相互割裂的。还是用上文提到的这个例子，我们没有办法在图数据库中直接找到一个从
`Main#test` 函数到 `A#test` 或 `B#test` 的一条通路，也就意味着我们不能通过类似 Neo4j
的查询语法来直接完成函数调用链路的输出。这显然是不符合我们的实际需求的，为此，我们设计了函数别名图来解决这个问题。
函数别名图描述了某一函数所有具体实现的语义图，主要用于面向对象语言多态特性在图数据库中的表达。该图由描述函数与函数之间的别名关系 ALIAS
边连接而成，类似 ORG 图，函数别名图也会产生一颗颗独立的函数树，树顶为 interface 或顶层类型，树枝为当前树顶函数的具体实现。
以上文中的代码为例，通过 MAG 图，我们可以找到一条从 `Main#main` 到 `A#test` 或 `B#test`
的函数调用通路。有了通路之后，我们就可以通过 Neo4j 的查询语法来查询此类函数调用路径。而且，MAG
图可以使得程序分析过程中的函数枚举实现下方到图数据库中进行，在一定程度上，可以缓解程序分析过程中的路径爆炸问题，详见 ppt 12。
#### 函数调用图 Method Call Graph
函数调用图主要用于描述函数与函数之间的调用关系图，利用该有向的调用关系可以查询出一条有效的函数调用路径。同时，我们也保留了 PDG 图，在 CALL
边上保留了污点信息用于后续的过程间数据流分析。更近一步的是，通过污点分析，我们可以保留受污染的调用边，减少后续图数据库中无用边的枚举递归查找。
通过组合上述三个子图，我们最终可以达到 2 个效果 1. 直接利用 Neo4j 的查询语法即可完成有效路径枚举工作 2.
可以将“有效”路径的判别下放到图数据库中完成（即过程间数据流分析）
### 2\. 结合图数据库的污点分析引擎