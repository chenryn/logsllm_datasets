!
1!
WRITING!YOUR!FIRST!EXPLOIT!
LECTURE!NOTES!
!
Robert!Olson!
Lecturer!
Dept.!of!Computing!&!Info!Sciences!
SUNY!at!Fredonia!
PI:EMAIL!
@nerdprof!
https://github.com/nerdprof/Writing-Your-First-Exploit!
!
!
!
!
!
1. Laboratory!Setup!
a. Virtual)Machines)
i. Windows!VM!
!
!
!
!
A!Windows!virtual!machine!can!be!downloaded!from!the!!
!
!
!
following!link:!
!
!
!
https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/!
!
!
!
!
!
!
!
!
Note:!Some!students!reported!problems!when!using!a!!
!
!
!
Windows!10!virtual!machine!during!the!Circle!City!Con!2016!!
!
!
!
workshop.!
!
ii. Kali!VM!
!
!
!
!
Kali!Linux!–!or!a!Kali!Linux!virtual!machine!-!can!be!!
!
!
!
!
downloaded!from:!
!
!
!
https://www.kali.org/downloads/!
!
b. Software)Installs)
i. Downloading!VulnServer!on!Windows!VM!
!
!
!
!
VulnServer!can!be!downloaded!at:!
!
!
!
http://www.thegreycorner.com/2010/12/introducing-vulnserver.html!
!
ii. Downloading!Immunity!on!Windows!VM!
!
!
!
!
Immunity!Debugger!can!be!downloaded!at:!
!
!
!
http://debugger.immunityinc.com/ID_register.py!
!
!
2!
iii. Downloading!mona.py!on!WindowsVM!
!
!
!
!
The!mona.py!script!can!be!downloaded!from:!
!
!
!
https://github.com/corelan/mona/blob/master/mona.py!
!
!
!
!
Once!downloaded,!it!should!be!placed!at:!
!
!
!
!
C:\Program!Files\Immunity!Inc\Immunity!Debugger\PyCommands!
!
iv. Downloading!arwin.exe!on!Windows!Vm!
!
!
!
!
The!arwin!application!can!be!downloaded!from:!
!
!
!
http://www.fuzzysecurity.com/tutorials/expDev/tools/arwin.rar!
!
2. Buffer!Overflows!in!C!
a. Simple)C)Programming)
i. Printf!
!
!
!
!
!
printf()!is!a!function!that!prints!data!to!the!screen,!often!using!!
!
!
!
substitution!symbols.!
!
!
!
!
printf(“Hello”);)would!print!Hello!to!the!screen!while!the!lines:!
!
!
!
!
char)name[5])=)“Rob”;)
)
)
)
printf(“Hello)%s”,)name);)
)
!
!
!
would!cause!Hello)Rob!to!be!printed!to!the!screen.!
!
!
!
!
ii. Strcpy!
!
!
!
!
strcpy()!is!a!function!that!copies!one!character!array!into!!
!
!
!
another.!!This!function!does!not!check!that!the!size!of!the!!
!
!
!
destination!in!relation!to!the!size!of!the!source.!If!the!source!!
!
!
!
material!takes!up!more!space!than!the!destination,!the!copy!!
!
!
!
will!still!occur!and!the!excess!data!will!be!written!past!the!end!!
!
!
!
of!the!destination.!
!
b. Buffer)Overflow)Example)
i. simpleoverflow.c!
!
c. Function)Calls)&)The)Stack)
i. The!stack!after!a!function!call!
!
!
!
!
The!term!stack!refers!to!a!section!of!a!program’s!memory!that!!
!
!
!
is!statically!allocated.!The!same!amount!of!memory!will!be!!
!
!
!
allocated!in!the!same!way!each!time!the!program!is!run.!!!
!
3!
!
!
!
The!program’s!stack!is!divided!up!into!a!local!stack!for!each!!
!
!
!
function!in!the!program.!A!function’s!local!stack!will!be!created!
!
!
!
and!destroyed!in!the!same!way!each!time!the!program!is!run.!
!
!
!
!
Variables!on!the!stack!are!referenced!in!terms!of!an!offset!to!!
!
!
!
the!base!of!a!function’s!stack.!The!base!of!a!function’s!stack!can!!
!
!
!
be!found!in!a!register!known!as!the!base)pointer)register)or!ebp.!
!
!
!
In!the!pseudo-code!below,!the!offset!of!the!variable!x!would!be!!
!
!
!
0!as!it!is!the!first!variable!on!the!function’s!stack.!That!is,!the!!
!
!
!
location!of!x)on!the!stack!could!described!as!ebp)+)0)bytes.!If!we!!
!
!
!
assume!integers!are!four!bytes!long,!the!offset!to!the!next!!
!
!
!
variable!–!a!character!named!c!–!would!be!4.!Similarly,!if!we!!
!
!
!
assume!that!characters!are!one!byte!long,!the!offset!of!z!would!!
!
!
!
be!5.!
!
!
!
!
When!a!function!!is!called!-!like!function!f!is!inside!of!main!!
!
!
!
below)–)control!will!be!transferred!to!function!f.!However,!the!!
!
!
!
main!function!still!needs!to!complete.!Main!must!be!resumed!at!
!
!
!
instruction!I1!with!the!local!stack!in!tact.!As!such,!the!address!!
!
!
!
of!I1!and!an!address!pointing!at!the!base!of!main’s!local!stack!!
!
!
!
must!be!saved!prior!to!transferring!control!to!the!function!f.!If!!
!
!
!
the!address!of!I1!is!not!saved,!main)cannot!resume.!If!the!base!!
!
!
!
pointer!is!not!saved,!main)cannot!resume!with!access!to!the!!
!
!
!
same!data!it!had!before!the!function!call!to!f.!
!
!
!
!
g(){)
)
)
)
)
int)x)
)
)
)
)
char)c)
)
)
)
)
int)z)
)
)
)
)
some)code)
)
)
)
)
)
)
)
)
)
more)code)
)
)
)
})
)
)
)
)
f(){)
)
)
)
)
some)code)
)
)
)
)
g())
)
)
)
)
)
)
)
)
)
some)code)
)
)
)
})
)
)
)
)
main())
)
)
)
{)
)
)
)
)
f())
)
)
)
)
)
)
)
)
})
!
4!
!
!
!
At!the!point!I3,!the!program’s!stack!would!resume!the!! !
!
!
!
following!diagram.!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
!
ii. Overwriting!Saved!Register!Values!
!
!
!
!
Because!each!!variable!“faces!away”!from!the!base!of!the!stack,!!
!
!
!
data!put!into!Z!will!be!written!towards!the!base!of!the!stack.!In!!
!
!
!
the!above!diagram,!it!is!relatively!easy!to!observe!the!!
!
!
!
!
consequences!of!overflowing!the!contents!of!Z.!Excess!data!!
!
!
!
from!Z!will!overflow!into!c!and!x.!If!enough!data!is!put!it,!it!will!!
!
!
!
even!overflow!into!the!control!information!saved!during!the!!
!
!
!
function!call.!
!
!
!
!
This!is!the!goal!of!a!buffer!overflow!exploit.!Want!to!put!so!!
!
!
!
much!data!into!a!vulnerable!variable!that!it!overflows!over!the!!
!
!
!
return!address.!Once!we!can!predict!where!that!return!address!
!
!
!
is,!we!can!place!the!address!of!a!jump!instruction!that!will!!
!
!
!
redirect!program!execution!to!our!payload!once!g()!finishes.!!
!
!
!
We!are!basically!hijacking!the!stack!surrounding!the!function!!
!
!
!
call!to!g()!to!ensure!execution!of!our!payload.!
!
!
!
!
Base!pointer!of!f’s!local!stack!
Address!of!I2!
f’s!local!stack!
Base!pointer!of!main’s!local!stack!
Address!of!I1!
Main’s!local!stack!
Created!when!
control!is!
transferred!to!
g()!
Z!
C!
X!
Created!when!
control!is!
transferred!to!
f()!
!
5!
!
3. Simple!Socket!Programming!in!Python!
a. Basic)script)structure)
i. import)
)
)
)
)
The!import!command!will!load!a!library.!We!will!be!using!the!!
!
!
!
socket!and!sys!libraries.!
)
ii. Indentation!carries!semantic!content)
)
)
)
)
Tabs!in!Python!serve!the!same!function!as!curly!braces!do!in!!
!
!
!
many!other!programming!languages:!the!specify!the!!
!
!
!
!
instructions!to!be!included!in!the!body!of!a!control!structure.!
)
b. socket.socket())
)
!
The!line:!
!
!
)
conn)=)socket.socket(socket.AF_INET,)socket.SOCK_STREAM))
!
!
creates! an! instance! of! type! socket! named! conn.! The! constant!
socket.AF_INET)indicates!that!it!will!be!an!IPv4!socket.!The!constant!
socket.SOCK_STREAM!indicates!that!it!will!be!a!TCP!socket.!
)
c. socket.connect())
)
!
The!line:!
!
!
)
conn.connect((“192.168.1.2”,)80))!
!
!
causes!an!instance!of!type!socket!to!initiate!a!three-way!handshake!
with!the!specified!IP!and!port.!Note!that!the!specified!IP!is!a!string!
while! the! specified! port! is! an! integer.! Also! note! the! double! set! of!
parentheses;!the!connect!function!expects!one!argument!–!an!ordered!
pair.!
)
)
d. socket.recv())
)
)
!
The!line:!
!
)
)
conn.recv(1024)!
!
!
will! attempt! to! read! 1024! bytes! of! data! from! the! socket.! This! is! a!
blocking!read;!the!script!will!hang!until!1024!bytes!have!been!read!or!
until!a!null!character!–!indicating!the!end!of!a!buffer!–!has!been!read.!!
!
6!
)
)
e. Writing)a)banner)grabber)
i. See!bannergrabber.py)
)
4. !Useful!Socket!Programming!in!Python!
a. sys.argv)
)
)
)
A!developer!can!get!command!line!arguments!from!a!user!by!making!!
!
!
use!of!the!sys!library.!!sys.argv[]!is!an!array!of!data!retrieved!from!the!!
!
!
command!line.!!