```
user@docker1:~$ docker exec web2 printenv
……
WEBSERVER_PORT=tcp://172.17.0.2:80
WEBSERVER_PORT_80_TCP=tcp://172.17.0.2:80
WEBSERVER_PORT_80_TCP_ADDR=172.17.0.2
……
user@docker1:~$
```
另外需要指出的是，链接只是一种方式。也就是说，该链接不会导致容器`web1`意识到`web2`容器。`Web1`将不接收引用`web2`容器的主机记录或环境变量:
```
user@docker1:~$ docker exec -it web1 ping web2
ping: unknown host
user@docker1:~$
```
提供链接的另一个原因是当您使用设置为`false`的 Docker **容器间连接** ( **ICC** )模式时。正如我们之前讨论过的，ICC 防止同一桥上的任何容器直接相互对话。这迫使他们只能通过已发布的端口相互对话。链接提供了一种覆盖默认 ICC 规则的机制。为了演示，让我们停止并移除主机`docker1`上的所有容器，然后将以下 Docker 选项添加到 systemd 插件文件中:
```
ExecStart=/usr/bin/dockerd --icc=false
```
现在重新加载系统配置，重新启动服务，并启动以下容器:
```
docker run -d -P --name=web1 jonlangemak/web_server_1
docker run -d -P --name=web2 jonlangemak/web_server_2
```
打开 ICC 模式后，您会注意到容器之间无法直接对话:
```
user@docker1:~$ docker exec web1 ip addr show dev eth0
87: eth0@if88:  mtu 1500 qdisc noqueue state UP
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe11:2/64 scope link
       valid_lft forever preferred_lft forever
user@docker1:~$ docker exec -it web2 curl http://172.17.0.2
user@docker1:~$
```
在上例中，`web2`无法访问`web1`上的网络服务器。现在，让我们删除并重新创建`web2`容器，这次将它链接到`web1`:
```
user@docker1:~$ docker stop web2
web2
user@docker1:~$ docker rm web2
web2
user@docker1:~$ docker run -d -P --name=web2 --link=web1 \
jonlangemak/web_server_2
4c77916bb08dfc586105cee7ae328c30828e25fcec1df55f8adba8545cbb2d30
user@docker1:~$ docker exec -it web2 curl http://172.17.0.2
    Web Server #1 - Running on port 80
user@docker1:~$
```
我们可以看到，有了链接，通信就像预期的那样被允许了。同样，就像链接一样，这种访问只允许一个方向。
需要注意的是，当使用用户定义的网络时，链接的工作方式是不同的。在这个食谱中，我们介绍了现在被命名为**的遗产链接**。与用户定义网络的链接将在接下来的两个食谱中介绍。
# 利用 Docker 域名系统
用户定义网络的引入标志着 Docker 网络的巨大变化。虽然提供定制网络的能力是个大新闻，但名称解析也有重大改进。用户定义的网络可以从名为“T3”的嵌入式域名系统“T4”中受益。Docker 引擎本身现在能够为所有容器提供名称解析。这是对传统解决方案的显著改进，在传统解决方案中，名称解析的唯一方法是外部域名系统或链接，这依赖于`hosts`文件。在本食谱中，我们将介绍如何使用和配置嵌入式域名系统。
## 做好准备
在本食谱中，我们将在单个 Docker 主机上演示配置。假设该主机安装了 Docker，并且 Docker 处于默认配置。我们将更改主机上的名称解析设置，因此您将需要根级访问权限。
## 怎么做…
如上所述，嵌入式 DNS 系统只在用户定义的 Docker 网络上工作。也就是说，让我们提供一个用户定义的网络，然后在其上启动一个简单的容器:
```
user@docker1:~$ docker network create -d bridge mybridge1
0d75f46594eb2df57304cf3a2b55890fbf4b47058c8e43a0a99f64e4ede98f5f
user@docker1:~$ docker run -d -P --name=web1 --net=mybridge1 \
jonlangemak/web_server_1
3a65d84a16331a5a84dbed4ec29d9b6042dde5649c37bc160bfe0b5662ad7d65
user@docker1:~$
```
正如我们在前面的配方中看到的，默认情况下，Docker 从 Docker 主机中提取名称解析配置，并将其提供给容器。可以通过在服务级别或容器运行时提供不同的 DNS 服务器或搜索域来改变这种行为。在容器连接到用户定义的网络的情况下，提供给容器的 DNS 设置略有不同。例如，让我们看看刚刚连接到用户定义的桥`mybridge1`的容器的`resolv.conf`文件:
```
user@docker1:~$ docker exec -t web1 more /etc/resolv.conf
search lab.lab
nameserver 127.0.0.11
options ndots:0
user@docker1:~$ 
```
注意这个容器的名称服务器现在是怎样的`127.0.0.11`。该 IP 地址代表 Docker 的嵌入式 DNS 服务器，将用于连接到用户定义网络的任何容器。要求任何连接到用户定义网络的容器都应该使用嵌入式 DNS 服务器。
最初未在用户定义的网络上启动的容器将在连接到用户定义的网络时得到更新。例如，让我们启动另一个名为`web2`的容器，但让它使用默认的`docker0`桥:
```
user@docker1:~$ docker run -dP --name=web2 jonlangemak/web_server_2
d0c414477881f03efac26392ffbdfb6f32914597a0a7ba578474606d5825df3f
user@docker1:~$ docker exec -t web2 more /etc/resolv.conf
::::::::::::::
/etc/resolv.conf
::::::::::::::
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
nameserver 10.20.30.13
search lab.lab
user@docker1:~$
```
如果我们现在将`web2`容器连接到用户定义的网络，Docker 将更新名称服务器以反映嵌入式 DNS 服务器:
```
user@docker1:~$ docker network connect mybridge1 web2
user@docker1:~$ docker exec -t web2 more /etc/resolv.conf
search lab.lab
nameserver 127.0.0.11
options ndots:0
user@docker1:~$ 
```
由于我们的两个容器现在都连接到同一个用户定义的网络，它们现在可以通过名称相互联系:
```
user@docker1:~$ docker exec -t web1 ping web2 -c 2
PING web2 (172.18.0.3): 48 data bytes
56 bytes from 172.18.0.3: icmp_seq=0 ttl=64 time=0.107 ms
56 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.087 ms
--- web2 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.087/0.097/0.107/0.000 ms
user@docker1:~$ docker exec -t web2 ping web1 -c 2
PING web1 (172.18.0.2): 48 data bytes
56 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.060 ms
56 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.119 ms
--- web1 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.060/0.089/0.119/0.030 ms
user@docker1:~$
```
你会注意到名称解析是双向的，并且它在不使用任何链接的情况下固有地工作。也就是说，使用用户定义的网络，我们仍然可以定义链接来创建本地别名。例如，让我们停止并移除两个容器`web1`和`web2`，并按如下方式重新配置它们:
```
user@docker1:~$ docker run -d -P --name=web1 --net=mybridge1 \
--link=web2:thesecondserver jonlangemak/web_server_1
fd21c53def0c2255fc20991fef25766db9e072c2bd503c7adf21a1bd9e0c8a0a
user@docker1:~$ docker run -d -P --name=web2 --net=mybridge1 \
--link=web1:thefirstserver jonlangemak/web_server_2
6e8f6ab4dec7110774029abbd69df40c84f67bcb6a38a633e0a9faffb5bf625e
user@docker1:~$
```
首先要指出的有趣的一点是，Docker 允许我们链接到一个尚不存在的容器。当我们运行容器`web1`时，我们要求 Docker 将其链接到容器`web2`。那时，`web2`还不存在。这是链接与嵌入式域名系统服务器之间的显著区别。在传统链接中，Docker 需要在创建链接之前知道目标容器信息。这是因为它必须手动更新源容器的主机文件和环境变量。第二个有趣的项目是别名不再列在容器的`hosts`文件中。如果我们查看每个容器上的`hosts`文件，我们会看到链接不再生成条目:
```
user@docker1:~$ docker exec -t web1 more /etc/resolv.conf
search lab.lab
nameserver 127.0.0.11
options ndots:0
user@docker1:~$ docker exec -t web1 more /etc/hosts
…… 
172.18.0.2      9cee9ce88cc3
user@docker1:~$
user@docker1:~$ docker exec -t web2 more /etc/hosts
…… 
172.18.0.3      2d4b63452c8a
user@docker1:~$
```
所有的解决方案现在都在嵌入式域名系统服务器中进行。这包括跟踪已定义的别名及其范围。因此，即使没有主机记录，每个容器也能够通过嵌入式 DNS 服务器解析其他容器的别名:
```
user@docker1:~$ docker exec -t web1 ping thesecondserver -c2
PING thesecondserver (172.18.0.3): 48 data bytes
56 bytes from 172.18.0.3: icmp_seq=0 ttl=64 time=0.067 ms
56 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.067 ms
--- thesecondserver ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.067/0.067/0.067/0.000 ms
user@docker1:~$ docker exec -t web2 ping thefirstserver -c 2
PING thefirstserver (172.18.0.2): 48 data bytes
56 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.062 ms
56 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.042 ms
--- thefirstserver ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.042/0.052/0.062/0.000 ms
user@docker1:~$
```
创建的别名有一个容器本身的局部范围。例如，同一用户定义网络上的第三个容器无法解析作为链接一部分创建的别名:
```
user@docker1:~$ docker run -d -P --name=web3 --net=mybridge1 \
jonlangemak/web_server_1
d039722a155b5d0a702818ce4292270f30061b928e05740d80bb0c9cb50dd64f
user@docker1:~$ docker exec -it web3 ping thefirstserver -c 2
ping: unknown host
user@docker1:~$ docker exec -it web3 ping thesecondserver -c 2
ping: unknown host
user@docker1:~$
```
您会记得，遗留链接还在源容器上自动创建了一组环境变量。这些环境变量引用了目标容器及其可能公开的任何端口。用户定义网络中的链接不会产生这些环境变量:
```
user@docker1:~$ docker exec web1 printenv
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=4eba77b66d60
APACHE_RUN_USER=www-data
APACHE_RUN_GROUP=www-data
APACHE_LOG_DIR=/var/log/apache2
HOME=/root
user@docker1:~$ 
```
正如我们在前面的食谱中所看到的，即使使用遗留链接，保持这些变量的最新也是不可实现的。也就是说，当处理用户定义的网络时，功能不存在并不完全令人惊讶。