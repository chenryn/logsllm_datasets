## 我的账号
**用户名:**

在类似于 Basic 认证的例子中，用户可以随意输入 ID 和密码通过认证。页面跳转流程如图 3-20 所示。

![示例应用的页面跳转](Image00032.jpg)
**图 3-20 示例应用的页面跳转**

当最初显示 31-020.php 的 ID 和密码输入页面时，返回的响应消息如下（仅列出要点）：
```
HTTP/1.1 200 OK
Set-Cookie: PHPSESSID=gg5144avrhmdiaelvh80l4lb53; path=/
Content-Length: 279
Content-Type: text/html; charset=UTF-8

  请登录 
【以下略】
```

通过 `Set-Cookie` 响应头信息，Web 服务器指示浏览器记住此 Cookie 值。

在登录页面上输入 ID 和密码后点击“登录”按钮，浏览器会向服务器发送如下请求：
```
POST /31/31-021.php HTTP/1.1
Referer: http://example.jp/31/31-020.php
Content-Type: application/x-www-form-urlencoded
Host: example.jp
Content-Length: 18
Cookie: PHPSESSID=gg5144avrhmdiaelvh80l4lb53
ID=user1&PWD=pass1
```

记住了 Cookie 值的浏览器，在向相同网站（例如 example.jp）发送请求时，会同时发送该 Cookie 值（PHPSESSID=...）。Cookie 可以设置有效期限，未设置有效期限的 Cookie 在浏览器关闭前一直有效。

Cookie 中的 PHPSESSID 值被称为会话 ID，它是访问会话信息的关键。在 31-021.php 中，认证成功后的用户 ID 被保存在会话变量 `$_SESSION['ID']` 中。随后程序在 31-022.php 中取得此用户 ID。保存在会话变量中的信息，在会话失效之前随时都能被访问。

### 使用 Cookie 的会话管理
Cookie 允许浏览器记忆少量数据，但几乎不会用于保存应用程序的数据，原因如下：
- Cookie 能保存的值的数量和字符串长度有限。
- Cookie 的值能被用户看到或更改，不适合存储敏感信息。

因此，通常采用在 Cookie 中保存类似于“受理编号”的会话 ID，实际对应的值则保存在服务器端的方法。这种方法被称为“使用 Cookie 的会话管理”，目前有着非常广泛的应用。主流 Web 应用开发工具（如 PHP）已经提供了这种会话管理机制。

### 会话管理的拟人化解说
将 Basic 认证时使用的银行窗口业务比喻转换为会话管理版本，其详情如下：
```
顾客：你好。
柜员：您的受理编号为 005。请提供您的银行卡号和密码。
顾客：受理编号为 005。卡号为 12345，密码为 9876，请确认。
柜员：身份核实完毕。
顾客：受理编号为 005。请帮我查下余额。
柜员：余额为 5 万元。
顾客：受理编号为 005。请向卡号 23456 的账户转账 3 万元。
柜员：转账完毕。
```

对话中的受理编号即为会话 ID。顾客每次都要向柜员汇报受理编号，正如浏览器每次都自动向服务器发送 Cookie 一样。

但是，005 这个受理编号让人感到不安，因为随便换一个相近的号码就可能假冒他人。例如：
```
恶人：你好。
柜员：您的受理编号为 006。请提供您的银行卡号和密码。
恶人将受理编号减去 1 变成了 005。假设受理编号为 005 的顾客已经通过了身份核实。
恶人：受理编号为 005。请向卡号 99999 的账户转账 3 万元。
柜员：转账完毕。
```

由此可见，会话 ID 需要满足以下需求：
- **需求 1**：会话 ID 不能被第三方推测。
- **需求 2**：会话 ID 不能被第三方劫持。
- **需求 3**：会话 ID 不能向第三方泄漏。

**需求 1** 的会话 ID 不能被推测，要求的是随机数的质量问题。如果随机数存在规律性，就能够通过收集足够多的会话 ID 来推测别人的会话 ID。因此，会话 ID 的随机数可以使用密码学级别的伪随机数生成器生成。但实际开发过程中，应使用 Web 应用开发工具提供的会话 ID 机制，避免自行实现。

**需求 2** 的会话 ID 不能被劫持，可以通过认证后改变会话 ID 来防止会话固定攻击。例如：
```
有顾客进入银行时，恶人冒充银行柜员向顾客搭话。
恶人：您的受理编号为 9466ir8fgmmk1gn6raeo7ne71。
顾客：知道了。
顾客走向柜台。
顾客：我的受理编号为 9466ir8fgmmk1gn6raeo7ne71。
柜员：请提供您的银行卡号和密码。
顾客：受理编号为 9466ir8fgmmk1gn6raeo7ne71。卡号为 12345，密码为 9876，请确认。
柜员：身份核实完毕。您新的受理编号为 eut1j15a058pm8gapa87l937h6。
顾客执行完本人身份确认后恶人也走向了柜台。
恶人：受理编号为 9466ir8fgmmk1gn6raeo7ne71。请向卡号 99999 的账户转账 3 万元。
柜员：您还没有进行身份核实。请提供您的银行卡号和密码。
```

**需求 3** 的防止会话 ID 泄漏，主要有以下几种原因：
- 发行 Cookie 时的属性指定有问题。
- 会话 ID 在网络上被监听。
- 通过跨站脚本漏洞等应用中的安全隐患被泄漏。
- 由于 PHP 或浏览器等平台存在安全隐患而被泄漏。
- 会话 ID 保存在 URL 中的情况下，会通过 Referer 消息头泄漏。

为了保护会话 ID 不被监听，采用 SSL 加密是行之有效的方法，但发行 Cookie 时也需要注意属性的指定。

### Cookie 的属性
生成 Cookie 时可以设置很多属性。先前看到的 PHPSESSID 在生成时指定了 "path=/"，这就是一个属性。生成 Cookie 时的主要属性如表 3-3 所示。

| 属性 | 含义 |
| --- | --- |
| Domain | Cookie 发送对象服务器的域名 |
| Path | Cookie 发送对象 URL 的路径 |
| Expires | Cookie 的有效期限。未指定则表示至浏览器关闭为止 |
| Secure | 仅在 SSL 加密的情况下发送 Cookie |
| HttpOnly | 指定了此属性的 Cookie 不能被 JavaScript 访问 |

其中，涉及安全性的三个重要属性为 Domain、Secure 和 HttpOnly。

- **Cookie 的 Domain 属性**
  - Cookie 在默认情况下只能被发送到与其绑定的服务器。虽然从安全性方面考虑这样是最安全的，但有时也需要能向多个服务器发送的 Cookie，这时就要用到 Domain 属性。
  - 图 3-21 展示了指定 Domain 属性后的 Cookie 被发送给服务器的情况。由于指定了 Domain=example.jp，因此，Cookie 就被发送给了 a.example.jp 和 b.example.jp，而 a.example.com 则因为域名不同而没有发送。
  - 如果 a.example.jp 的服务器在 Set-Cookie 时指定了 Domain=example.com，此 Cookie 将被浏览器忽略。这是因为如果可以在 Cookie 中指定不同域名，就可能发生前述的会话固定攻击，所以 Cookie 是不能指定不同域名的。
  - 未指定 Domain 属性时，Cookie 只被发送至生成它的服务器。换言之，未指定 Domain 属性的 Cookie 发送范围最小，最安全。而设置 Domain 属性时稍有疏忽，就会产生安全隐患。