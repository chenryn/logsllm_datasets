title:Automatic Generation of String Signatures for Malware Detection
author:Kent Griffin and
Scott Schneider and
Xin Hu and
Tzi-cker Chiueh
Automatic Generation of String Signatures for
Malware Detection
Kent Griﬃn, Scott Schneider, Xin Hu, and Tzi-cker Chiueh
Symantec Research Laboratories
Abstract. Scanning ﬁles for signatures is a proven technology, but ex-
ponential growth in unique malware programs has caused an explosion
in signature database sizes. One solution to this problem is to use string
signatures, each of which is a contiguous byte sequence that potentially
can match many variants of a malware family. However, it is not clear
how to automatically generate these string signatures with a suﬃciently
low false positive rate. Hancock is the ﬁrst string signature generation
system that takes on this challenge on a large scale.
To minimize the false positive rate, Hancock features a scalable model
that estimates the occurrence probability of arbitrary byte sequences in
goodware programs, a set of library code identiﬁcation techniques, and
diversity-based heuristics that ensure the contexts in which a signature
is embedded in containing malware ﬁles are similar to one another. With
these techniques combined, Hancock is able to automatically generate
string signatures with a false positive rate below 0.1%.
Keywords: malware signatures, signature generation, Markov model,
library function identiﬁcation, diversity-based heuristics.
1 Introduction
Symantec’s anti-malware response group receives malware samples submitted
by its customers and competitors, analyzes them, and creates signatures that
could be used to identify instances of them in the ﬁeld. The number of unique
malware samples that Symantec receives has grown exponentially in the recent
years, because malware programs are increasingly customized, targeted, and in-
tentionally restricted in distribution scope. The total number of distinct malware
samples that Symantec observed in 2008 exceeds 1 million, which is more than
the combined sum of all previous years.
Although less proactive than desired, signature-based malware scanning is
still the dominant approach to identifying malware samples in the wild because
of its extremely low false positive (FP) rate, i.e., the probability of mistaking
a goodware program for a malware program is very low. For example, the FP
rate requirement for Symantec’s anti-malware signatures is below 0.1%. Most
signatures used in existing signature-based malware scanners are hash signatures,
each of which is the hash of a malware ﬁle. Although hash signatures have a
low false positive rate, the number of malware samples covered by each hash
E. Kirda, S. Jha, and D. Balzarotti (Eds.): RAID 2009, LNCS 5758, pp. 101–120, 2009.
c(cid:2) Springer-Verlag Berlin Heidelberg 2009
102
K. Griﬃn et al.
signature is also low – typically one. As a result, the total size of the hash
signature set grows with the exponential growth in the number of unique malware
samples. This creates a signature distribution problem for Symantec: How can
we distribute these hash-based malware signatures to hundreds of millions of
users across the world several dozen times per day in a scalable way?
One possible solution is to replace hash signatures with string signatures, each
of which corresponds to a short, contiguous byte sequence from a malware bi-
nary. Thus, each string signature can cover many malware ﬁles. Traditionally,
string signatures are created manually because it is diﬃcult to automatically de-
termine which byte sequence in a malware binary is less FP-prone, i.e., unlikely
to appear in any goodware program in the world. Even for manually created
string signatures, it is generally straightforward for malware authors to evade
them, because they typically correspond to easy-to-modify data strings in mal-
ware binaries, such as names of malware authors, special pop-up messages, etc.
Hancock is an automatic string signature generation system developed in
Symantec Research Labs that automatically generates high-quality string sig-
natures with minimal FPs and maximal malware coverage. i.e. The probability
that a Hancock-generated string signature appears in any goodware program
should be very, very low. At the same time each Hancock-generated string sig-
nature should identify as many malware programs as possible. Thus, although
one string signature takes more space than one hash signature, it uses far less
space than all of the hash signatures it replaces.
Given a set of malware samples, Hancock is designed to create a minimal
set of N-byte sequences, each of which has a suﬃciently low false positive rate,
that collectively cover as large a portion of the malware set as possible. Based on
previous empirical studies, Hancock sets N to 48. It uses three types of heuristics
to test a candidate signature’s FP rate: probability-based, disassembly-based,
and diversity-based. The ﬁrst two ﬁlter candidate signatures extracted from
malware ﬁles and the last selects good signatures from among these candidates.
Hancock begins by recursively unpacking malware ﬁles using Symantec’s un-
packing engine. It rejects ﬁles that are packed and cannot be unpacked, according
to this engine, PEiD [1], and entropy analysis, and stores 48-byte sequences from
these ﬁles in a list of invalid signatures. Hancock does this because signatures
produced on packed ﬁles are likely to cover the unpacking code. Blacklisting
certain packers should only be done explicitly by a human, rather than through
automated signature generation.
Hancock then examines every 48-byte code sequence in unpacked malware
ﬁles. It ﬁnds candidate signatures using probability-based and disassembly-based
heuristics: it ﬁlters out byte sequences whose estimated occurrence probability
in goodware programs, according to a pre-computed goodware model, is above
a certain threshold; that are considered a part of library functions; or whose as-
sembly instructions are not suﬃciently interesting or unique, based on heuristics
that encode malware analysts’ selection criteria. It examines only code so that
disassembly-based heuristics can work and because malware authors can more
easily vary data.
Automatic Generation of String Signatures for Malware Detection
103
Among those candidate signatures that pass the initial ﬁltering step, Hancock
further applies a set of selection rules based on the diversity principle: If the
set of malware samples containing a candidate signature are similar, then they
are less FP-prone. A candidate signature in a diverse set of malware ﬁles is
more likely to be a part of a library used by several malware families. Though
identifying several malware families seems like a good idea, if a signature is part
of library code, goodware ﬁles might use the same library. On the other hand, if
the malware ﬁles are similar, they are more likely to belong to one family and
the candidate signature is more likely to be code that is unique to that family.
Finally, Hancock is extended to generate string signatures that consist of mul-
tiple disjoint byte sequences rather than only one contiguous byte sequence.
Although multi-component string signatures are more eﬀective than single-
component signatures, they also incur higher run-time performance overhead
because individual components are more likely to match goodware programs.
In the following sections, we will describe the signature ﬁlter algorithms, the
signature selection algorithms, and the multi-component generalization used in
Hancock.
2 Related Work
Modern anti-virus software typically employ a variety of methods to detect
malware programs, such as signature-based scanning [2], heuristic-based detec-
tion [3], and behavioral detection [4]. Although less proactive, signature-based
malware scanning is still the most prevalent approach to identify malware be-
cause of its eﬃciency and low false positive rate. Traditionally, the malware
signatures are created manually, which is both slow and error-prone. As a re-
sult, eﬃcient generation of malware signatures has become a major challenge for
anti-virus companies to handle the exponential growth of unique malware ﬁles.
To solve this problem, several automatic signature generation approaches have
been proposed.
Most previous work focused on creating signatures that are used by Network
Intrusion Detection Systems (NIDS) to detect network worms. Singh et al. pro-
posed EarlyBird [5], which used packet content prevalence and address dispersion
to automatically generate worm signatures from the invariant portions of worm
payloads. Autograph [6] exploited a similar idea to create worm signatures by
dividing each suspicious network ﬂow into blocks terminated by some breakmark
and then analyzing the prevalence of each content block. The suspicious ﬂows are
selected by a port-scanning ﬂow classiﬁer to reduce false positives. Kreibich and
Crowcroft developed Honeycomb [7], a system that uses honeypots to gather
inherently suspicious traﬃc and generates signatured by applying the longest
common substring (LCS) algorithm to search for similarities in the packet pay-
loads. One potential drawback of signatures generated from previous approaches
is that they are all continuous strings and may fail to match polymorphic worm
payloads. Polygraph [8] instead searched for invariant content in the network
ﬂows and created signatures consisting of multiple disjoint content substrings.
104
K. Griﬃn et al.
Polygraph also utilized a naive Bayes classiﬁer to allow the probabilistic match-
ing and classiﬁcation, and thus provided better proactive detection capabilities.
Li et al. proposed Hasma [9], a system that used a model-based algorithm to
analyze the invariant contents of polymorphic worms and analytically prove
the attack-resilience of generated signatures. PDAS (Position-Aware Distribu-
tion Signatures) [10] took advantage of a statistical anomaly-based approach to
improve the resilience of signatures to polymorphic malware variants. Another
common method for detecting polymorphic malware is to incorporate semantics-
awareness into signatures. For example, Christodorescu et al. proposed static
semantics-aware malware detection in [11]. They applied a matching algorithm
on the disassembled binaries to ﬁnd the instruction sequences that match the
manually generated templates of malicious behaviors, e.g., decryption loop. Yeg-
neswaran et al. developed Nemean [12], a framework for automatic generation
of intrusion signatures from honeynet packet traces. Nemean applied cluster-
ing techniques on connections and sessions to create protocol-semantic-aware
signatures, thereby reducing the possibility of false alarms.
Hancock diﬀers from previous work by focusing on automatically generating
high-coverage string signatures with extremely low false positives. Our research
was based loosely on the virus signature extraction work [13] by Kephart and
Arnold, which was commercially used by IBM. They used a 5-gram Markov chain
model of good software to estimate the probability that a given byte sequence
would show up in good software. They tested hand-generated signatures and
found that it was quite easy to set a model probability threshold with a zero false
positive rate and a modest false negative rate (the fraction of rejected signatures
that would not be found in goodware) of 48%. They also generated signatures
from assembly code (as Hancock does), rather than data, and identiﬁed candidate
signatures by running the malware in a test environment. Hancock does not do
this, as dynamic analysis is very slow in large-scale applications.
Symantec acquired this technology from IBM in the mid-90s and found that
it led to many false positives. The Symantec engineers believed that it worked
well for IBM because IBM’s anti-virus technology was used mainly in corporate
environments, making it much easier for IBM to collect a representative set of
goodware. By contrast, signatures generated by Hancock are mainly for home
users, who have a much broader set of goodware. The model’s training set cannot
possibly contain, or even represent, all of this goodware. This poses a signiﬁcant
challenge for Hancock in avoiding FP-prone signatures.
3 Signature Candidate Selection
3.1 Goodware Modeling
The ﬁrst line of defense in Hancock is a Markov chain-based model that is trained
on a large goodware set and is designed to estimate the probability of a given
byte sequence appearing in goodware. If the probability of a candidate signature
appearing in some goodware program is higher than a threshold, Hancock rejects
Automatic Generation of String Signatures for Malware Detection
105
it. Compared with standard Markov models, Hancock’s goodware model has two
important features:
– Scalable to very large goodware set. Symantec regularly tests its anti-
virus signatures against several terabytes of goodware programs. A standard
Markov model uses linear space [14] in the training set size, with a large con-
stant factor. Hancock’s goodware model focuses only on high-information-
density byte sequences so as to scale to very large goodware training sets.
– Focusing on rare byte sequences. For a candidate signature to not cause
a false positive, its probability of appearing in goodware must be very, very
low. Therefore, the primary goal of Hancock’s model is to distinguish between
low-probability byte sequences and very rare byte sequences.
Basic Algorithm. The model used in Hancock is a ﬁxed-order 5-gram Markov
chain model, which estimates the probability of the ﬁfth byte conditioned on the
occurrence of the preceding four bytes. Training consists of counting instances
of 5-grams – 5-byte sequences – as well as 4-grams, 3-grams, etc. The model
calculates the probability of a 48-byte sequence by multiplying estimated prob-
abilities of each of the 48 bytes. A single byte’s probability is the probability of
that byte following the four preceding bytes. For example, the probability that
“e” follows “abcd” is
p(e|abcd) =
∗ (1 − (count(abcd))) + p(e|bcd) ∗ (count(abcd))
count(abcde)
count(abcd)
In this equation, count(s) is the number of occurrences of the byte sequence s
in the training set. We limit overtraining with (count(s)), the escape mass of
s. Escape mass decreases with count. Empirically, we found that a good escape
mass for our model is (c) =
√
32√
√
32+
c .
Model Pruning. The memory required for a vanilla ﬁxed-order 5-gram model
is signiﬁcantly greater than the size of the original training set. Hancock re-
duces the memory requirement of the model by incorporating an algorithm that
prunes away less useful grams in the model. The algorithm looks at the relative
information gain of a gram and eliminates it if its information gain is too low.
This allows Hancock to keep the most valuable grams, given a ﬁxed memory
constraint.
Consider a model’s grams viewed as nodes in a tree. The algorithm considers
every node X, corresponding to byte sequence s, whose children (corresponding
to sσ for some byte σ) are all leaves. Let s(cid:4) be s with its ﬁrst byte removed.
For example, if s is “abcd”, s(cid:4) is “bcd”. For each child of X, σ, the algorithm
compares p(σ|s) to p(σ|s(cid:4)). In this example, the algorithm compares p(e|abcd) to
p(e|bcd), p(f|abcd) to p(f|bcd), etc. If the diﬀerence between p(σ|s) and p(σ|s(cid:4))
is smaller than a threshold, that means that X is does not add that much value
to σ’s probability and the node σ can be pruned away without compromising
the model’s accuracy.
106
K. Griﬃn et al.
To focus on low-probability sequences, Hancock uses the diﬀerence between
the logs of these two probabilities, rather than that between their raw probability
values. Given a space budget, Hancock keeps adjusting the threshold until it hits
the space target.
Model Merging. Creating a pruned model requires a large amount of interme-
diate memory, before the pruning step. Thus, the amount of available memory
limits the size of the model that can be created. To get around this limit, Han-
cock creates several smaller models on subsets of the training data, prunes them,
and then merges them.
Merging a model M1 with an existing model M2 is mostly a matter of adding
up their gram counts. The challenge is in dealing with grams pruned from M1
that exist in M2 (and vice versa). The merging algorithm must recreate these
gram counts in M1. Let sσ be such a gram and let s(cid:4) be s with its ﬁrst byte
removed. The algorithm estimates the count for sσ as count(s) ∗ p(σ|s(cid:4)). Once
these pruned grams are reconstituted, the algorithm simply adds the two models’
gram counts.
Experimental Results. We created an occurrence probability model from a
1-GByte training goodware set and computed the probability of a large number
of 24-byte test sequences, extracted from malware ﬁles. We checked each test
byte sequence against a goodware database, which is a large superset of the
training set, to determine if it is a true positive (a good signature) or a false
positive (which occurs in goodware). In Figure 1, each point in the FP and TP
curves represents the fraction (Y axis value) of test byte sequences whose model
probability is below the X axis value.
As expected, TP signatures have much lower probabilities, on average, than
FP signatures. A small number of FP signatures have very low probabilities –
below 10−60. Around probability 10−40, however, the model does provide excel-