

Fig. 2. Unauthorized (a) direct and (b) indirect transfers.



	







1. No authorization. The Ô¨Årst column identiÔ¨Åes several buses
that completely fail to authorize transfers; e.g., neither se-
lectively associate individual devices with isolated-application
objects nor enforce read-write permissions for I/O transfers.
A device can access another device‚Äôs data registers without
providing its identity in the I/O transfers. For example, PCI
buses, the System Management Buses, CAN buses, and ARM
Advanced High-performance Bus (AHB) buses do not require
I/O requests to include device identities for senders‚Äô authen-
tication [24], [25], [26], [27], and yet allow device peer-to-
peer (P2P) transfers. Sender devices always have the same
privilege as the bus controllers in accessing conÔ¨Åguration and
data registers of recipient devices. This enables unauthorized
transfers to these objects; i.e., a write over the recipient device
data registers or a read from the recipient device. When
devices are connected to these buses, isolated but malicious
drivers can manipulate them to perform unauthorized direct
and indirect P2P transfers to other devices, as illustrated below.
transfers. As shown in
Figure 2(a), a malicious driver i can conÔ¨Ågure its device
i to perform a device P2P transfer and access device j of
another isolated application without any authorization, thereby
breaking I/O separation.
Example 1. Unauthorized direct
Example 2. Unauthorized indirect transfers. Figure 2(b)
shows Indirect Transfer 1 whereby a PCI device i conÔ¨Ågures
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
573
Malicious
Driver i
Red partition
Green partition
DMA mem DMA mem
Driver j
Malicious
Driver 
Red partition Green partition
DMA mem.
DMA mem.
Driver 
IOMMU
PCIe-PCI Bridge
PCI
Device i
Device j
. . . . .
.
deferred
IOTLB
clearing
page table
page table
ppppp
t bl
pagppppppp e table
page table
IOMMU
PCIe bus, ACS
Device 
Device 
on demand
Fig. 3. Non-selective authorization of I/O transfers.
Fig. 4. Unauthorized transfer caused by deferred IOTLB clearing.
another PCI device h via a P2P transfer and enables it to
read/write I/O objects of otherwise isolated device j on i‚Äôs
behalf. Here the device i can embed the identity of an I/O
object of device j into its maliciously conÔ¨Ågured device h,
instead of issuing reads/writes to the I/O object directly. Thus,
direct transfers of device i to device h do not break I/O
separation. Instead, transfers of device h to device j do. In
Indirect Transfer 2 of Figure 2(b), device i writes over one of
its own transfer descriptors, which enables device i to issue
an unauthorized cross-boundary transfer to device j.
2. Non-selective authorization. The second column of Fig-
ure 1 shows I/O buses that fail to support individual device
association with isolated-driver objects and enforce their read-
write permissions; i.e., access authorization is non-selective.
Instead, these commodity bus controllers can only associate
buses with these objects and enforce read-write permissions
for buses. For example, some IOMMUs [9], [10] authorize
accesses at the granularity of PCI bus controllers via PCIe-
to-PCI bridges instead of individual devices. Similarly, when
issuing requests on behalf of their individual DMA devices,
USB host controllers [8] use their own identities instead those
of individual devices. In both cases, the IOMMU regards
all DMA device transfers as originating from the I/O bus
controller. Hence, it cannot authorize transfers selectively per
individual device.
Example 3. Non-selective authorization of
transfers. As
shown in Figure 3, device i is manipulated by malicious driver
i to read or write a DMA memory region of another device
j across an isolation boundary, even though the IOMMU is
correctly conÔ¨Ågured. For selective authorization of transfers,
devices of different isolated applications must be connected
to different PCIe-to-PCI bridges yielding restricted hardware
conÔ¨Ågurations [4]. ARM TrustZone authorizes I/O transfers
selectively between the normal and secure world, but it cannot
authorize transfers selectively within a single world.
3. Selective-authorization failure from optimization. The
last column of Figure 1 illustrates the best hardware for
selective (per device) authorization. Unfortunately, commodity
OS kernels using this hardware often have to trade transfer-
authorization assurance for added performance. For example,
to decrease the signiÔ¨Åcant cost of selective authorization via
an IOMMU [28], commodity OS kernels perform all transfers
into one shared kernel buffer-pool, and then authorize kernel
Example
transfer
enabled
4. Unauthorized
transfers to/from isolated applications [11]. This works well
for low-assurance kernels (e.g., Linux), but adds substantially
more complex code to high-assurance micro-hypervisors [13],
[14] or micro-kernels [12], [15] and causes signiÔ¨Åcant perfor-
mance degradation due to frequent switches to/from them.
by
a
performance‚ÄìI/O isolation trade-off. Figure 4 illustrates
the vulnerability of
this performance-isolation assurance
trade-off via an attack that breaches DMA memory isolation
by exploiting the deferred clearing of IOMMU‚Äôs IOTLB
entries up to 10 ms [28], [11]. During this delay, the DMA
device is allocated to a malicious (red) driver, which is
isolated in another application, on demand. The malicious
(red) driver instructs the DMA device to issue a transfer
whose target virtual address is translated using the undeleted
IOTLB entry (green circle), breaching red-green separation.
Similar vulnerabilities can be caused by green applications,
which could breach the isolation of other green applications.
C. Threats
The examples above show how an adversary can breach
conÔ¨Ådentiality and/or integrity of sensitive I/O data across
isolated applications. The emerging attack pattern is simple:
the adversary either compromises an OS driver or provides
an isolated application containing a deliberately compromised
driver. Then the compromised driver can mis-conÔ¨Ågure its
device to setup unauthorized I/O transfers either directly or
indirectly. These attacks appear in all commodity OSes‚Äîeven
when they beneÔ¨Åt from formally veriÔ¨Åed micro-hypervisors
and micro-kernels that isolate device drivers.
We assume that attackers control drivers of their devices.
Note that an attacker need not corrupt device Ô¨Årmware to
launch the I/O separation attacks; e.g., surreptitiously modify
the device controller‚Äôs Ô¨Årmware by re-Ô¨Çashing [29], [30],
[31] or by supply-chain compromise [32], [33], [34], [35].
Techniques to verify the correct device Ô¨Årmware and register
contents after re-Ô¨Çashing are known [36] and hence are not
addressed here. Also, we assume that legitimate backdoors are
disabled before system operation; e.g., hardware debugging
interfaces for privileged access to I/O devices [37]. As cus-
tomary, we also assume that device hardware is non-malicious.
Denial-of-service and covert-channel attacks in I/O transfers
are also irrelevant to the I/O separation model.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
574
III. MODEL MOTIVATION AND LAYERED APPROACH
The challenges of building an I/O separation model are
to provide security guarantees for (1) different I/O hardware
designs, different types of I/O accesses (e.g., P2P, broadcast),
direct and indirect transfers; and (2) different I/O kernels,
ranging from high-assurance, such as Wimpy kernel (WK) [21]
and the GPU separation kernel (GSK) [38], to low-assurance
OS kernels (Linux) [28], [11]. The model must apply to
all trusted execution environments and hardware-supported
enclaves. We outline why these challenges are important and
how to meet them via a layered modeling approach.
A. Motivation
Application to Different I/O Hardware Designs. It must be
possible to instantiate the formal model on any commodity
I/O conÔ¨Ågurations regardless of the hardware ability, or lack
thereof, to authorize I/O transfers. The reality is that a large
variety of commodity processors which support application
isolation (e.g., via trusted execution environments [39], par-
titions [16], [17], pieces of application logic [40], [13], [14],
and enclaves [41], [15]) will continue to be interconnected
to I/O hardware that fails to adequately authorize separate
device transfers. This is both for high-performance and low-
cost; e.g., in cyber-physical systems (CPS) [42] and vehicular
computing [42], [26]. Our formalism suggests speciÔ¨Åc ways
to handle inadequate I/O hardware.
1. No authorization. In this case, an I/O kernel deÔ¨Ånes
separate device-driver associations and transfer permissions.
Driver code is either (a) formally veriÔ¨Åed not to violate the
deÔ¨Åned authorizations or (b) de-privileged, exported to isolated
applications, and have all its device accesses authorized by the
I/O kernel at run time, or a mixture of both (a) and (b). In case
(a), veriÔ¨Åed drivers are authenticated at boot time (via secure
and trusted boot) and conÔ¨Ågured within the I/O kernel. This
is practical only for systems with few devices; e.g., CPS [42]
and vehicular computing [42], [26]. In case (b), unveriÔ¨Åed
driver accesses to devices could incur substantial overhead,
and hence could only be used for drivers that access devices
infrequently. In both cases, the model shows how authorization
is formally speciÔ¨Åed and veriÔ¨Åed; using transitive closures of
transfer descriptors; see Section IV-B.
2. Non-selective authorization. In this case, the I/O kernel
has two non-exclusive options, and is more scalable than the
no-authorization remedy above. First, only the driver code of
devices connected to the same PCI bus needs to be formally
veriÔ¨Åed to satisfy individual device-transfer authorization, and
only these drivers need to be authenticated and conÔ¨Ågured
within the I/O kernel during boot. Second, whenever practical,
I/O conÔ¨Ågurations are restricted to a single device per PCI bus
and this is enforced at boot time. The drivers of these devices
are untrusted and can be exported to isolated applications.
3. Selective-authorization failure. Here, a formal model
applied to micro-hypervisors and I/O kernel veriÔ¨Åcation shows
that all separated but malicious drivers are de-privileged and
safely exported to isolated applications along with their lo-
cal buffers. This solves the I/O separation breaches shown
in Example 4 of Section II-B, and substantially simpliÔ¨Åes
both formal micro-hypervisor and I/O kernel veriÔ¨Åcation and
naturally avoids performance penalties (Section VIII-B). To
enable this,
the I/O kernel relies on the I/O hardware to
enforce transfer authorization late, and the beneÔ¨Åts of late
authorization are discussed in Section IV-D.
Application to Different I/O Kernels. Different I/O kernels
isolate drivers in different ways: some isolate them within the
I/O kernels themselves, while others isolate them within appli-
cations; e.g., in partitions of separation kernels, isolated pieces
of application logic supported by micro-hypervisors, trusted
execution environments, or hardware-isolated enclaves. Some
I/O kernels support device activation on demand whereas oth-
ers support only static activation during system boot. Despite
their differences, all I/O kernels support a notion of separation
to encapsulate drivers and their associated I/O objects (e.g.,
data buffers and conÔ¨Åguration registers) and devices of isolated
applications. Hence, any model must support
this notion,
and we do this via I/O partitions; i.e., at any given time,
each device, driver, and object belongs to one and only one
partition, and they can move from one partition to another.
Then two security policy properties that an I/O separation
model should naturally enforce are, at a high level: (1) no
cross-partition transfers, and (2) no object data reuse in a
new partition in on-demand I/O. We will make these more
concrete in Section IV. The formal application of the model
to an I/O kernel is discussed in Section V whereas the informal
application to other I/O kernels is in Section VIII-A.
B. Layered Modeling
Figure 5 illustrates our layered modeling approach that
yields a veriÔ¨Åed assembly implementation of Wimpy kernel.
We use Dafny and start from an abstract I/O separation model
and use a hierarchy of veriÔ¨Åed reÔ¨Ånements. The abstract I/O
separation model speciÔ¨Åes key device and driver components
and operations, formalizes the notion of I/O partitions, and
speciÔ¨Åes I/O authorization and properties.
The second layer comprises Concrete I/O models, which
are obtained from (veriÔ¨Åed) reÔ¨Ånement of the abstract model,
have more details, including speciÔ¨Åc types of I/O hardware au-
thorization capabilities and I/O separation policy, as discussed
above. The soundness of a Concrete I/O model is proven by
leveraging the simulation relation between the abstract I/O
separation model and the Concrete I/O model.
The third layer is I/O kernel designs whose formal spec-
iÔ¨Åcations represent the (veriÔ¨Åed) reÔ¨Ånement of the Concrete
I/O model in different device classes, whereby some or all
mechanisms for device identiÔ¨Åcation, initialization, transfer
authorization may differ among these classes. This allows
the instantiation of different I/O kernels for typical OS de-
vice classes: a Wimpy kernel, a GPU separation kernel (see
Figure 5), a NIC kernel, etc. Then soundness of an I/O
kernel design speciÔ¨Åcation is proven by the simulation relation
between the Concrete I/O model and the I/O kernel design
speciÔ¨Åcations.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:32:26 UTC from IEEE Xplore.  Restrictions apply. 
575
Abstract model
specification
Concrete model
specification
Kernel design
specification
I/O Separation Model 
Dafny
on-demand, red/green partitions
static allocation
multiple partitions
on-demand OS DMA
multiple partitions
Wimpy kernel [21]
GPU separation 
kernel (GSK) [38]
Separation 
kernels [16,17]
OS kernels with 
Intra-OS protection 
[11,28] 
Kernel implementation
specification
Wimpy kernel 
Vale/Dafny
Automated generation
of C/Assembly code
Wimpy kernel code 
GSK code
Refinement proof
Informal refinement argument
Fig. 5. Model ReÔ¨Ånements and Automated Code Generation
Using an intermediate concrete-model speciÔ¨Åcation reduces
the proof effort for different I/O kernels reÔ¨Åned from the same
concrete model. Further, kernel-design speciÔ¨Åcations are nec-
essary for three practical reasons. First, design speciÔ¨Åcations
and (failure of) their soundness proofs enable early detection
of security vulnerabilities before any effort for implementation
speciÔ¨Åcations, code generation, and their testing is expanded;
e.g., vulnerabilities of the original Wimpy-kernel design [21]
in Section VI-B. Second, the different I/O kernel designs (e.g.,
Wimpy kernel, GPU separation kernel, and NIC separation
kernel) obtained by device class partitioning can be provably
composed within a secure I/O subsystem. This can further lead
to the sound composition of implementation speciÔ¨Åcations;
e.g., composition is facilitated by the sound correspondence
between individual I/O kernel designs and their implementa-
tion speciÔ¨Åcations. Thus, the much more complex provable
implementation- and code-composition effort can be avoided.
Third, design changes for a device class often retain the same
I/O kernel design speciÔ¨Åcations and avoid constructing new
soundness proofs; e.g., USB 3.0 on-demand time-multiplexing
mechanism does not change USB 2.0 I/O kernel speciÔ¨Åcations.
The last layer of speciÔ¨Åcations is I/O kernel implementations
in Vale/Dafny [15], so x86 assembly code can be automatically
generated and the implementations can be proven correct in
Dafny. This reÔ¨Ånement proof shows that the Wimpy kernel
implementation correctly reÔ¨Ånes its design speciÔ¨Åcation.
C. Code sizes, level of effort, and model reusability
All the models and reÔ¨Ånement proofs shown in the gray box
of Figure 5 are formally speciÔ¨Åed and veriÔ¨Åed.
Code sizes. The I/O separation model takes 28,518 lines of
Dafny code (LOC) the concrete model takes 47,120 LOC, the
WK design takes 55,426 LOC, and the WK implementation
takes 136,815 of Dafny and Vale LOC. The WK implementa-
tion are more than double the size of the design speciÔ¨Åcations
because it requires formal reÔ¨Ånement of subjects, objects,
and operations for x86 platforms. The automatically generated