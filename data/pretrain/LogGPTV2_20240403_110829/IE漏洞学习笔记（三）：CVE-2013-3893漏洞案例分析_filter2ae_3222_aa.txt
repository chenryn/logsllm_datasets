# IE漏洞学习笔记（三）：CVE-2013-3893漏洞案例分析
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
调试环境：
Windows 7 SP1
IE8
漏洞编号:CVE-2013-3893
摘要：
该漏洞是的原理是，IE下的mshtml动态连接库将TreeNode对象从Dom树释放后，又重新调用对象的任意代码执行。该漏洞覆盖的IE版本从IE6到IE11，是一个典型的浏览器UAF漏洞，最后使用精准堆喷射完成利用。
因为本文作者调试实例漏洞的功底有限，所以会漏洞如何发现以及利用部分，漏洞的原理和挖掘的讲解可能达不到高水平读者的要求。文章比较长，希望感兴趣的读者能耐心读下去。
## 1.1漏洞分析
可以通过msf/exploit-db获取这个漏洞的POC，我们对其进行一些修改，方便我们的分析。
调试的poc代码如下
POC.html
    ​    Migraine
    ​    Hello World!
###  1.1.1 基于POC的流程分析
首先要清楚POC的运行流程，通过createElement创建两个对象father和child
接着为两个对象分别创建两个结点。效果如图所示，标签下创建了和标签。同时也会创建一个TreeNode对象。
将child作为father的子结点
father[‘outerText’]=””将元素本身赋值为空对象，这句会导致DOM树中所有father的子孙结点都被析构（fahter、child）也就是说TreeNode会从DOM上脱离。
father.setCapture();child.setCapture();father鼠标指针聚焦，child鼠标指针聚焦，导致father失焦，会触发father.onlosecapture=function()
document.write(“”);
漏洞触发的位置
在调用document.write(“”);时候，释放了TreeNode对象，但是在程序之后运行的函数中，使用了这个被释放的对象，导致了释放后重用漏洞。
POC调试
程序断点在了CTreeNode::GetInterface函数，call ecx指向的地址。
使用kv可以追踪函数的流程。按照这样的回溯也是可以分析漏洞的。不过为了更精确地找到造成中断的根源，我们开启页堆（page
heap），这样程序在遇到堆结构被破坏时会更即使地断下。
使用Windbg的Global Flags工具开启page heap（页堆），选择Enable page heap选项。
不建议开启左下角的Enable heap tagging，会导致后面调试经常出问题。
再次运行POC，程序断点在了HasContainerCapture+0x14的位置。根据栈回溯，可以发现比之前的断点位置更靠前了一些。
使用kv查看栈回溯，使用ub查看具体触发的代码。
我们再次查看HasContainerCapture+0x14的位置，发现他实际调用了一个已经被释放到对象TreeNode，从而造成了释放后重用（UAF）漏洞。
继续向下看，我们分析此时造成崩溃的EDI参数，!heap -p -a edi查看edi所在堆的状态。
可以看到EDI所指向的堆已经在!CTreeNode::Release被释放了。
重新调试一遍，查看TreeNode对象（地址和上一次调试不同）在被释放前的空间为0x4c，所以只需要在被释放之后，用js立即分配一块相同大小的堆就能进行占位。
虽然知道POC触发了UAF漏洞，但是我们对这个漏洞的具体细节还一无所知，更不用提利用了。所以我们要从程序流程的角度来分析一下漏洞触发的原因。
接下来关闭页堆，进一步调试整个POC的触发的程序流程，以及UAF是如何造成影响的。
修改一下poc（增加了一段js，创建了一个div对象，具体原因下文会说明），继续调试。
    ​    Migraine
    ​    Hello World!
    ​        function trigger()
    ​        {
    ​            Math.tan(2,1);
    ​            var father=document.createElement("father");
    ​            var child=document.createElement("child");
    ​            Math.tan(1,2);
    ​            document.body.appendChild(father);
    ​            document.body.appendChild(child);
    ​            Math.sin(1,2);
    ​            child.applyElement(father);
    ​            
    ​            father.onlosecapture=function() {
    ​                document.write("");
    ​                Math.cos(1,2);
    ​                tt = new Array(20);
    ​                for(i = 0; i 
首先对几个关键部分下断点，在POC中写入一些三角函数，例如tan、sin、cos这几个JS的函数主要是帮助我们判断程序运行到哪个位置，因为在程序汇总我们下断点到函数会反复地运行，可能会多次断下，但是不一定是我们需要到断点。（比如调试时候，tan还没断下来，CElement就断了好几次，这个断点就需要我们跳过）
下面是我下的断点，仅供参考。（到后期调试最后两个断点可以去掉）
    0:016> bl
     0 e 6d86d898     0001 (0001)  0:**** jscript!tan
     2 e 6d86d6e9     0001 (0001)  0:**** jscript!sin
     3 e 6d86d657     0001 (0001)  0:**** jscript!cos
     4 e 6ba49fd3     0001 (0001)  0:**** mshtml!CElement::CElement
     5 e 6b9caed1     0001 (0001)  0:**** mshtml!CMarkup::InsertElementInternal
     6 e 6b9e5acf     0001 (0001)  0:**** mshtml!CElement::appendChild
首先断点在了tan，三角函数断点并不是必须的，但是在调试IE这样程序流复杂的对象时，可以帮助我们判断程序运行的位置。
第一个CElement::CElement断点，当然直接给createElement下断点也是可以的，但是要获取这个对象的指针，需要运行CElement+0x18的位置。此时EDI存放的便是Element对象的指针。
即var father=document.createElement(“father”);中的father
为什么我们能判断此时的EDI是Element的对象指针呢，其实分析0x6ba49feb地址的这句语句，将C++的虚函数表地址放入了[EDI]的位置，这不就是C++
初始化对象的行为嘛。对象的头部就是虚函数表。
第二个断点，也是同理，var child=document.createElement(“child”);中的child对象指针为2eebd88.
中途再次断在tan，g继续运行
创建子结点father
document.body.appendChild(father);
创建了一个TreeNode对象，指针默认通过EAX值返回。
同理第二个子结点，也可以获取它的指针（child）
运行结束之后，可以看一下目前的内存结构，发现已经形成了一个类似链表的结构。
查看内存空间，下图中从上到下分别是
Element对象father
子节点
Element对象child
Element对象child
结构图为
    Element对象father(2eec048)    Element对象child(2eebd88)
    ​      |                                  |
    ​      V                                  V
    子节点(2ee8ac0)         子节点(2ee8388)
           ^                                 ^
           |                                  |
           ------------------------------------    
                             |
    ​             CBody_TreeNode(02f123a8)
而TreeNode则为我们这次释放后重用漏洞的利用对象，通过链表关系我们其实可以知道，调试过程中只需要获取fahter对象的指针，就能通过链表关系获取到TreeNode指针，下一次调试就会节省很多时间。
接下来程序断点在了sin函数，继续g运行，child.applyElement(father)，直到运行到cos函数。
此时查看内存，能发现变成了的子结点。
结构图为