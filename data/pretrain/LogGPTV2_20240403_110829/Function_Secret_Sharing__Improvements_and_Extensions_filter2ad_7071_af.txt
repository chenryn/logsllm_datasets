soundness of the above MPC protocol crucially depends on
the fact that the client cannot predict the inputs for the
protocol in case y is invalid. In the full version, we describe
a diﬀerent technique for the case where the inputs are fully
known to the client. Concretely, the technique is used to
make the client prove that the value β of a point function
fα,β has a special structure. A particularly useful instance
is where β is of the form (γ, γ2, . . . , γd) ∈ Fd for a ﬁnite ﬁeld
F. A β vector of this form can be used to decode a set of
messages that match the same search criterion in “reading”
applications or are written to the same bin in “writing” ap-
plications [15, 11]. The idea is to make the client help the
parties verify the validity of β by secret-sharing a suitable
1301proof between the parties. The proof can be viewed as a
special case of the so-called Hadamard-PCP that has been
previously used in the context of sublinear-communication
arguments for NP [22, 6], exploiting the simple algebraic
structure of the statement for better eﬃciency.
4.5 Putting the Pieces Together
We conclude by summarizing the type of FSS veriﬁcation
enabled by combining the above sketching schemes and MPC
protocols.
Theorem 4.5
(Verifiable FSS). For each function fam-
ily Fi speciﬁed below, the following holds. For every m-party
FSS scheme Π = (Gen, Eval) for Fi, there is an m-party ver-
iﬁable FSS scheme Π(cid:48) = (Gen(cid:48), Eval, Ver) for Fi such that
keys generated by Gen(cid:48) include keys of Gen and a constant
number of additional ﬁeld elements, and in Ver parties in-
voke Eval once on each x ∈ D(cid:48), perform O(|D(cid:48)|) additional
ﬁeld operations, and communicate a constant number of ﬁeld
elements with each other.
The function families Fi are:
• All point functions fα,β;
• All point functions fα,β with β ∈ {0, 1} (alternatively,
with β = 1 or β ∈ {1,−1} if D(cid:48) = D);
• All interval functions f[a,b] and their negations −f[a,b].
• All point functions fα,β for β of the special form (γ,
γ2, . . . , γd) ∈ Fd; here the keys produced by Gen include
O(d) additional ﬁeld elements.
Acknowledgements. Research done in part while visit-
ing the Simons Institute for the Theory of Computing, sup-
ported by the Simons Foundation and by the DIMACS /
Simons Collaboration in Cryptography through NSF grant
#CNS-1523467. Supported by ERC starting grant 259426.
The ﬁrst author additionally supported by ISF grant 1709/14
and ERC starting grant 307952. The second author addi-
tionally supported by ISF grant 1638/15, a grant by the
BGU Cyber Center, the Israeli Ministry Of Science and
Technology Cyber Program and by the European Union’s
Horizon 2020 ICT program (Mikelangelo project). The third
author was additionally supported by DARPA Brandeis pro-
gram under Contract N66001-15-C-4065, ISF grant 1709/14,
BSF grant 2012378, a DARPA/ARL SAFEWARE award,
NSF Frontier Award 1413955, NSF grants 1228984, 1136174,
1118096, and 1065276. This material is based upon work
supported by the Defense Advanced Research Projects Agency
through the ARL under Contract W911NF-15-C-0205. The
views expressed are those of the author and do not reﬂect
the oﬃcial policy or position of the Department of Defense,
the National Science Foundation, or the U.S. Government.
5. REFERENCES
[1] D. Beaver. Eﬃcient multiparty protocols using circuit
randomization. In CRYPTO ’91, pages 420–432, 1991.
[2] D. Beaver. Correlated pseudorandomness and the
complexity of private computations. In STOC 1996,
pages 479–488, 1996.
[3] A. Beimel, Y. Ishai, E. Kushilevitz, and I. Orlov.
Share conversion and private information retrieval. In
CCC 2012, pages 258–268, 2012.
[4] M. Ben-Or, S. Goldwasser, and A. Wigderson.
Completeness theorems for non-cryptographic
fault-tolerant distributed computation (extended
abstract). In STOC, pages 1–10, 1988.
[5] R. Bendlin, I. Damg˚ard, C. Orlandi, and S. Zakarias.
Semi-homomorphic encryption and multiparty
computation. In Eurocrypt 2011, pages 169–188, 2011.
[6] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and
O. Paneth. Succinct non-interactive arguments via
linear interactive proofs. In TCC, pages 315–333, 2013.
[7] E. Boyle, N. Gilboa, and Y. Ishai. Function secret
sharing. In EUROCRYPT 2015, pages 337–367, 2015.
[8] B. Chor and N. Gilboa. Computationally private
information retrieval (extended abstract). In STOC
1997, pages 304–313, 1997.
[9] B. Chor, N. Gilboa, and M. Naor. Private information
retrieval by keywords. IACR Cryptology ePrint
Archive, 1998:3, 1998.
[10] B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan.
Private information retrieval. J. ACM, 45(6):965–981,
1998.
[11] H. Corrigan-Gibbs, D. Boneh, and D. Mazi`eres.
Riposte: An anonymous messaging system handling
millions of users. In IEEE Symposium on Security and
Privacy, pages 321–338, 2015.
[12] I. Damg˚ard, V. Pastro, N. P. Smart, and S. Zakarias.
Multiparty computation from somewhat homomorphic
encryption. In CRYPTO 2012, pages 643–662, 2012.
[13] G. Di Crescenzo, T. Malkin, and R. Ostrovsky. Single
database private information retrieval implies
oblivious transfer. In EUROCRYPT 2000, pages
122–138, 2000.
[14] Y. Dodis, S. Halevi, R. D. Rothblum, and D. Wichs.
Spooky encryption and its applications. In CRYPTO
2016, pages 93–122, 2016.
[15] M. Finiasz and K. Ramchandran. Private stream
search at the same communication cost as a regular
search: Role of LDPC codes. In ISIT 2012, pages
2556–2560, 2012.
[16] D. Genkin, Y. Ishai, M. Prabhakaran, A. Sahai, and
E. Tromer. Circuits resilient to additive attacks with
applications to secure computation. In STOC 2014,
pages 495–504, 2014.
[17] N. Gilboa. Two party RSA key generation. In
CRYPTO ’99, pages 116–129, 1999.
[18] N. Gilboa and Y. Ishai. Distributed point functions
and their applications. In Advances in Cryptology -
EUROCRYPT, pages 640–658, 2014.
[19] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game or a completeness theorem for
protocols with honest majority. In STOC, pages
218–229, 1987.
[20] T. Gupta, N. Crooks, W. Mulhern, S. Setty, L. Alvisi,
and M. Walﬁsh. Scalable and private media
consumption with popcorn. In NSDI 2016, 2016.
[21] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank.
Extending oblivious transfers eﬃciently. In CRYPTO
2003, pages 145–161, 2003.
[22] Y. Ishai, E. Kushilevitz, and R. Ostrovsky. Eﬃcient
arguments without short PCPs. In 22nd CCC, pages
278–291, 2007.
1302[23] Y. Ishai, M. Prabhakaran, and A. Sahai. Secure
arithmetic computation with no honest majority. In
TCC 2009, pages 294–314. Springer, 2009.
[24] E. Kushilevitz and R. Ostrovsky. Replication is NOT
needed: SINGLE database, computationally-private
information retrieval. In 38th FOCS, pages 364–373,
1997.
[25] C. A. Melchor, J. Barrier, L. Fousse, and M. Killijian.
XPIR : Private information retrieval for everyone.
PoPETs, 2016(2):155–174, 2016.
[26] R. Ostrovsky and V. Shoup. Private information
storage (extended abstract). In STOC 1997, pages
294–303, 1997.
[27] R. Ostrovsky and W. Skeith III. Private searching on
streaming data. In CRYPTO 2005, pages 223–240,
2005.
[28] E. Shi, J. Bethencourt, H. T. Chan, D. X. Song, and
A. Perrig. Multi-dimensional range query over
encrypted data. In 2007 IEEE Symposium on Security
and Privacy, pages 350–364, 2007.
APPENDIX
A. APPLICATIONS OF FSS
In this section we describe some representative applica-
tions of FSS beyond those described in the Introduction.
For simplicity we restrict attention to 2-party FSS.
Private keyword search. Suppose that each of two servers
holds a database of keywords with corresponding payloads
X = {(x1, p1), . . . , (xN , pN )} where xj ∈ {0, 1}n and pj ∈
{0, 1}m. We further assume that no payload pj is the all-0
string. The client would like to privately test whether some
secret keyword x is in the database, and obtain the corre-
sponding payload if it is. To this end, the client uses a DPF
to split the point function fx,1 : {0, 1}n → Z2 into f1, f2,
sending each key to the corresponding server. Server i sends
j=1 pjfi(xj), where each pj is viewed as an
element in Zm
2 be the answers received from
the two servers. The client lets p = a1 + a2, and outputs “no
match” if p = 0 or p otherwise.
back the sum(cid:80)N
2 . Let a1, a2 ∈ Zm
i returns (cid:80)N
Generalized keyword search. In the case of a general-
ized keyword search, where the search predicate f : {0, 1}n →
{0, 1} is taken from a class F, the client can count the num-
ber of entries j satisfying f (xj) = 1 by viewing the range of
f as the group G = ZN +1. Splitting f into f1 + f2, server
j=1 fi(xj), and the client can recover the ex-
act number of matches by adding the two answers in G. A
bounded number of matching payloads can be retrieved by
using sketching or coding techniques [27, 15].
Private updates. Consider the following application sce-
nario for a writing analogue of PIR [26]. A user owns N
ﬁles (x1, . . . , xN ) where xj ∈ {0, 1}m. For backup purposes,
the ﬁles are secret-shared between two cloud servers, namely
every xj is split into xj,1 and xj,2 such that xj,1 ⊕ xj,2 = xj.
The user would like to update ﬁle xα to a new version x(cid:48)
α
without revealing any information about the update (includ-
ing the identity α of the ﬁle that has been updated) to any
individual server. To this end, the client lets β = xj ⊕ x(cid:48)
and uses a DPF to split the point function fα,β : [N ] → Zm
2
into f1, f2, sending each key to the corresponding server.
j
Each server i updates its shares of the N ﬁles by letting
j,i ← xj,i ⊕ fi(j), for 1 ≤ j ≤ N .
x(cid:48)
B. CONCRETE EFFICIENCY OF PIR
Since the introduction of Private Information Retrieval
(PIR), there have been three diﬀerent models for PIR. The
ﬁrst, presented in the original PIR work of Chor et al. [10],
assumes that the database is replicated in k ≥ 2 non-colluding
servers and requires that the protocol be information theo-
retically secure. The second, proposed by Chor and Gilboa [8],
assumes two non-colluding servers but relaxes the security
requirement to hold against computationally bounded ad-
versaries. The third model, introduced in [24], assumes that
the database is held by a single server and security is again
computational.
In the application of DPF to PIR, as described in the In-
troduction, the query size is the DPF key, which is roughly
of size λ·(n−log λ) for a database of size N = 2n records (im-
proving over the previous best DPF-based solution from [7]
by roughly a factor of 4). Using Theorem 3.3, the DPF key
requires approximately N/64 AES operations. In addition
to this cost, each server should take the inner product of
a (pseudo-)random N -bit vector with the database, eﬀec-
tively amounting to computing the XOR of roughly half the
records in the database. The latter cost is common to all
multi-server PIR protocols that have 1-bit answers.2
Chor et al. [10] present a simple 2-server information-
theoretic PIR protocol with N -bit queries and 1-bit an-
swers.This protocol provides good concrete eﬃciency in ap-
plications that involve a small number of records (e.g., see
[20]). The optimized DPF protocol in this paper leads to
better communication complexity for databases that have
400 items or more.
Information-theoretic PIR protocols
with k ≥ 3 servers achieve better communication complex-
ity than two-server protocols. However, employing an addi-
tional server may be costly, and moreover, even the best pub-
lished schemes for practical parameters (e.g., the 3-server
protocol in [3] with communication complexity 14N 1/4) have
higher communication than our construction for large enough
databases, e.g. four billion items for [3]. In terms of com-
putation, all multi-server PIR protocols require each server
to expand a received key to a string of N elements and
then compute the inner product of the database with the ex-
panded key. In the two-server solution of [10] the expanded
string is explicitly sent to each server; other information-
theoretic PIR protocols require several ﬁeld or ring opera-
tions per database bit to perform this expansion. We note
that all of the alternative approaches do not natively gen-
eralize to more general types of searches, such as keyword
search or range queries, without a signiﬁcant overhead in-
troduced by the use of data structures.
Single-server PIR with sublinear communication is known
to imply public-key encryption [13]. Indeed all known single-
server PIR protocols require (additively homomorphic) public-
key encryption of the whole database to evaluate a PIR
query (cf. [25] and references therein). This is typically sev-
eral orders of magnitude slower than the solution we present.
2To simplify the exposition we restrict our attention to pro-
tocols that have 1-bit answers, since these seem to be the
most attractive from a concrete eﬃciency point of view.
1303