### Soundness of the MPC Protocol

The soundness of the described MPC (Multiparty Computation) protocol hinges on the client's inability to predict the inputs for the protocol when \( y \) is invalid. In the full version, we introduce a different technique for scenarios where the inputs are fully known to the client. Specifically, this technique requires the client to prove that the value \( \beta \) of a point function \( f_{\alpha, \beta} \) has a special structure. A particularly useful instance is when \( \beta \) is of the form \( (\gamma, \gamma^2, \ldots, \gamma^d) \in F^d \) for a finite field \( F \). Such a \( \beta \) vector can be used to decode a set of messages that match the same search criterion in "reading" applications or are written to the same bin in "writing" applications [15, 11]. The idea is to have the client assist the parties in verifying the validity of \( \beta \) by secret-sharing a suitable proof among them. This proof can be seen as a special case of the Hadamard-PCP (Probabilistically Checkable Proof), which has been previously used in the context of sublinear-communication arguments for NP [22, 6], leveraging the simple algebraic structure of the statement for better efficiency.

### Combining Sketching Schemes and MPC Protocols

We conclude by summarizing the type of verifiable FSS (Function Secret Sharing) enabled by combining the above sketching schemes and MPC protocols.

#### Theorem 4.5: Verifiable FSS
For each function family \( F_i \) specified below, the following holds: For every \( m \)-party FSS scheme \( \Pi = (Gen, Eval) \) for \( F_i \), there exists an \( m \)-party verifiable FSS scheme \( \Pi' = (Gen', Eval, Ver) \) for \( F_i \) such that:
- Keys generated by \( Gen' \) include keys of \( Gen \) and a constant number of additional field elements.
- In \( Ver \), parties invoke \( Eval \) once on each \( x \in D' \), perform \( O(|D'|) \) additional field operations, and communicate a constant number of field elements with each other.

The function families \( F_i \) are:
- All point functions \( f_{\alpha, \beta} \).
- All point functions \( f_{\alpha, \beta} \) with \( \beta \in \{0, 1\} \) (alternatively, with \( \beta = 1 \) or \( \beta \in \{1, -1\} \) if \( D' = D \)).
- All interval functions \( f_{[a, b]} \) and their negations \( -f_{[a, b]} \).
- All point functions \( f_{\alpha, \beta} \) for \( \beta \) of the special form \( (\gamma, \gamma^2, \ldots, \gamma^d) \in F^d \); here, the keys produced by \( Gen \) include \( O(d) \) additional field elements.

### Acknowledgements

This research was conducted in part while visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and the DIMACS / Simons Collaboration in Cryptography through NSF grant #CNS-1523467. Additional support was provided by ERC starting grant 259426. The first author was also supported by ISF grant 1709/14 and ERC starting grant 307952. The second author received additional support from ISF grant 1638/15, a grant by the BGU Cyber Center, the Israeli Ministry of Science and Technology Cyber Program, and the European Union’s Horizon 2020 ICT program (Mikelangelo project). The third author was additionally supported by the DARPA Brandeis program under Contract N66001-15-C-4065, ISF grant 1709/14, BSF grant 2012378, a DARPA/ARL SAFEWARE award, NSF Frontier Award 1413955, and NSF grants 1228984, 1136174, 1118096, and 1065276. This material is based upon work supported by the Defense Advanced Research Projects Agency through the ARL under Contract W911NF-15-C-0205. The views expressed are those of the authors and do not reflect the official policy or position of the Department of Defense, the National Science Foundation, or the U.S. Government.

### References

[1] D. Beaver. Efficient multiparty protocols using circuit randomization. In CRYPTO '91, pages 420–432, 1991.
[2] D. Beaver. Correlated pseudorandomness and the complexity of private computations. In STOC 1996, pages 479–488, 1996.
[3] A. Beimel, Y. Ishai, E. Kushilevitz, and I. Orlov. Share conversion and private information retrieval. In CCC 2012, pages 258–268, 2012.
[4] M. Ben-Or, S. Goldwasser, and A. Wigderson. Completeness theorems for non-cryptographic fault-tolerant distributed computation (extended abstract). In STOC, pages 1–10, 1988.
[5] R. Bendlin, I. Damgård, C. Orlandi, and S. Zakarias. Semi-homomorphic encryption and multiparty computation. In Eurocrypt 2011, pages 169–188, 2011.
[6] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth. Succinct non-interactive arguments via linear interactive proofs. In TCC, pages 315–333, 2013.
[7] E. Boyle, N. Gilboa, and Y. Ishai. Function secret sharing. In EUROCRYPT 2015, pages 337–367, 2015.
[8] B. Chor and N. Gilboa. Computationally private information retrieval (extended abstract). In STOC 1997, pages 304–313, 1997.
[9] B. Chor, N. Gilboa, and M. Naor. Private information retrieval by keywords. IACR Cryptology ePrint Archive, 1998:3, 1998.
[10] B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan. Private information retrieval. J. ACM, 45(6):965–981, 1998.
[11] H. Corrigan-Gibbs, D. Boneh, and D. Mazières. Riposte: An anonymous messaging system handling millions of users. In IEEE Symposium on Security and Privacy, pages 321–338, 2015.
[12] I. Damgård, V. Pastro, N. P. Smart, and S. Zakarias. Multiparty computation from somewhat homomorphic encryption. In CRYPTO 2012, pages 643–662, 2012.
[13] G. Di Crescenzo, T. Malkin, and R. Ostrovsky. Single database private information retrieval implies oblivious transfer. In EUROCRYPT 2000, pages 122–138, 2000.
[14] Y. Dodis, S. Halevi, R. D. Rothblum, and D. Wichs. Spooky encryption and its applications. In CRYPTO 2016, pages 93–122, 2016.
[15] M. Finiasz and K. Ramchandran. Private stream search at the same communication cost as a regular search: Role of LDPC codes. In ISIT 2012, pages 2556–2560, 2012.
[16] D. Genkin, Y. Ishai, M. Prabhakaran, A. Sahai, and E. Tromer. Circuits resilient to additive attacks with applications to secure computation. In STOC 2014, pages 495–504, 2014.
[17] N. Gilboa. Two party RSA key generation. In CRYPTO '99, pages 116–129, 1999.
[18] N. Gilboa and Y. Ishai. Distributed point functions and their applications. In Advances in Cryptology - EUROCRYPT, pages 640–658, 2014.
[19] O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game or a completeness theorem for protocols with honest majority. In STOC, pages 218–229, 1987.
[20] T. Gupta, N. Crooks, W. Mulhern, S. Setty, L. Alvisi, and M. Walfish. Scalable and private media consumption with popcorn. In NSDI 2016, 2016.
[21] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank. Extending oblivious transfers efficiently. In CRYPTO 2003, pages 145–161, 2003.
[22] Y. Ishai, E. Kushilevitz, and R. Ostrovsky. Efficient arguments without short PCPs. In 22nd CCC, pages 278–291, 2007.
[23] Y. Ishai, M. Prabhakaran, and A. Sahai. Secure arithmetic computation with no honest majority. In TCC 2009, pages 294–314. Springer, 2009.
[24] E. Kushilevitz and R. Ostrovsky. Replication is NOT needed: SINGLE database, computationally-private information retrieval. In 38th FOCS, pages 364–373, 1997.
[25] C. A. Melchor, J. Barrier, L. Fousse, and M. Killijian. XPIR: Private information retrieval for everyone. PoPETs, 2016(2):155–174, 2016.
[26] R. Ostrovsky and V. Shoup. Private information storage (extended abstract). In STOC 1997, pages 294–303, 1997.
[27] R. Ostrovsky and W. Skeith III. Private searching on streaming data. In CRYPTO 2005, pages 223–240, 2005.
[28] E. Shi, J. Bethencourt, H. T. Chan, D. X. Song, and A. Perrig. Multi-dimensional range query over encrypted data. In 2007 IEEE Symposium on Security and Privacy, pages 350–364, 2007.

### Appendix

#### A. Applications of FSS

In this section, we describe some representative applications of FSS beyond those mentioned in the Introduction. For simplicity, we focus on 2-party FSS.

**Private Keyword Search:**
Suppose two servers each hold a database of keywords with corresponding payloads \( X = \{(x_1, p_1), \ldots, (x_N, p_N)\} \) where \( x_j \in \{0, 1\}^n \) and \( p_j \in \{0, 1\}^m \). We assume no payload \( p_j \) is the all-0 string. The client wants to privately test whether a secret keyword \( x \) is in the database and obtain the corresponding payload if it is. The client uses a DPF (Distributed Point Function) to split the point function \( f_{x, 1} : \{0, 1\}^n \rightarrow \mathbb{Z}_2 \) into \( f_1 \) and \( f_2 \), sending each key to the corresponding server. Server \( i \) returns \( \sum_{j=1}^N p_j f_i(x_j) \), where each \( p_j \) is viewed as an element in \( \mathbb{Z}_2^m \). Let \( a_1, a_2 \in \mathbb{Z}_2^m \) be the answers received from the two servers. The client computes \( p = a_1 + a_2 \) and outputs "no match" if \( p = 0 \) or \( p \) otherwise.

**Generalized Keyword Search:**
For a generalized keyword search where the search predicate \( f : \{0, 1\}^n \rightarrow \{0, 1\} \) is from a class \( F \), the client can count the number of entries \( j \) satisfying \( f(x_j) = 1 \) by viewing the range of \( f \) as the group \( G = \mathbb{Z}_{N+1} \). Splitting \( f \) into \( f_1 + f_2 \), each server \( i \) returns \( \sum_{j=1}^N f_i(x_j) \), and the client recovers the exact number of matches by adding the two answers in \( G \). A bounded number of matching payloads can be retrieved using sketching or coding techniques [27, 15].

**Private Updates:**
Consider a writing analogue of PIR [26]. A user owns \( N \) files \( (x_1, \ldots, x_N) \) where \( x_j \in \{0, 1\}^m \). For backup, the files are secret-shared between two cloud servers, so \( x_j \) is split into \( x_{j,1} \) and \( x_{j,2} \) such that \( x_{j,1} \oplus x_{j,2} = x_j \). The user wants to update file \( x_\alpha \) to a new version \( x'_\alpha \) without revealing any information about the update (including the identity \( \alpha \) of the updated file) to any individual server. The client lets \( \beta = x_j \oplus x'_j \) and uses a DPF to split the point function \( f_{\alpha, \beta} : [N] \rightarrow \mathbb{Z}_2^m \) into \( f_1 \) and \( f_2 \), sending each key to the corresponding server. Each server \( i \) updates its shares of the \( N \) files by letting \( x'_{j,i} \leftarrow x_{j,i} \oplus f_i(j) \) for \( 1 \leq j \leq N \).

#### B. Concrete Efficiency of PIR

Since the introduction of Private Information Retrieval (PIR), there have been three different models:
1. **Replicated Database Model:** Assumes the database is replicated in \( k \geq 2 \) non-colluding servers and requires information-theoretic security [10].
2. **Two-Server Computational Model:** Assumes two non-colluding servers but relaxes the security requirement to computational security [8].
3. **Single-Server Computational Model:** Assumes the database is held by a single server with computational security [24].

In the application of DPF to PIR, as described in the Introduction, the query size is the DPF key, which is approximately \( \lambda \cdot (n - \log \lambda) \) for a database of size \( N = 2^n \) records (improving over the previous best DPF-based solution from [7] by roughly a factor of 4). Using Theorem 3.3, the DPF key requires approximately \( N/64 \) AES operations. Additionally, each server should take the inner product of a (pseudo-)random \( N \)-bit vector with the database, effectively computing the XOR of roughly half the records in the database. This cost is common to all multi-server PIR protocols with 1-bit answers.

Chor et al. [10] present a simple 2-server information-theoretic PIR protocol with \( N \)-bit queries and 1-bit answers, providing good concrete efficiency for small databases (e.g., see [20]). The optimized DPF protocol in this paper leads to better communication complexity for databases with 400 items or more.

Information-theoretic PIR protocols with \( k \geq 3 \) servers achieve better communication complexity than two-server protocols. However, employing an additional server may be costly, and even the best published schemes for practical parameters (e.g., the 3-server protocol in [3] with communication complexity \( 14N^{1/4} \)) have higher communication than our construction for large enough databases, e.g., four billion items for [3]. In terms of computation, all multi-server PIR protocols require each server to expand a received key to a string of \( N \) elements and then compute the inner product of the database with the expanded key. In the two-server solution of [10], the expanded string is explicitly sent to each server; other information-theoretic PIR protocols require several field or ring operations per database bit to perform this expansion. These alternative approaches do not natively generalize to more general types of searches, such as keyword search or range queries, without significant overhead introduced by the use of data structures.

Single-server PIR with sublinear communication is known to imply public-key encryption [13]. Indeed, all known single-server PIR protocols require (additively homomorphic) public-key encryption of the whole database to evaluate a PIR query (cf. [25] and references therein). This is typically several orders of magnitude slower than the solution we present.

To simplify the exposition, we restrict our attention to protocols with 1-bit answers, as these seem to be the most attractive from a concrete efficiency point of view.