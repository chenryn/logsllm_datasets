title:ObliviStore: High Performance Oblivious Cloud Storage
author:Emil Stefanov and
Elaine Shi
2013 IEEE Symposium on Security and Privacy
ObliviStore: High Performance Oblivious Cloud Storage
Emil Stefanov
University of California, Berkeley
PI:EMAIL
Elaine Shi
University of Maryland, College Park
PI:EMAIL
Abstract. We design and build ObliviStore, a high performance,
distributed ORAM-based cloud data store secure in the malicious
model. To the best of our knowledge, ObliviStore is the fastest
ORAM implementation known to date, and is faster by 10X or
more in comparison with the best known ORAM implementation.
ObliviStore achieves high throughput by making I/O operations
asynchronous. Asynchrony introduces security challenges, i.e., we
must prevent information leakage not only through access patterns,
but also through timing of I/O events. We propose various practical
optimizations which are key to achieving high performance, as well
as techniques for a data center to dynamically scale up a distributed
ORAM. We show that with 11 trusted machines (each with a
modern CPU), and 20 Solid State Drives, ObliviStore achieves a
throughput of 31.5MB/s with a block size of 4KB.
I. INTRODUCTION
Cloud computing provides economies of scale for im-
plementing a broad range of online services. However, due
to concerns over data privacy, “many potential cloud users
have yet to join the cloud, and many are for the most part
only putting only their less sensitive data in the cloud” [10].
It is well-known that encryption alone is not sufﬁcient for
ensuring data privacy, since data access patterns can also
leak a considerable amount of sensitive information. For
example, Islam et. al. demonstrate that access patterns can
leak (through statistical inference) up to 80% of the search
queries made to an encrypted email repository [21].
Oblivious RAM (or ORAM for short) [9, 11, 13–16, 18,
23, 28, 29, 31, 43, 46], originally proposed by Goldreich
and Ostrovsky [14], is a cryptographic construction that
allows a client
to access encrypted data residing on an
untrusted storage server, while completely hiding the access
patterns to storage. Particularly, the sequence of physical
addresses accessed is independent of the actual data that
the user is accessing. To achieve this, existing ORAM
constructions [9, 11, 13–16, 18, 23, 28, 29, 31, 43, 46]
continuously re-encrypt and and reshufﬂe data blocks on
the storage server, to cryptographically conceal the logical
access pattern.
Aside from storage outsourcing applications, ORAM (in
combination with trusted hardware in the cloud) has also
been proposed to protect user privacy in a broad range of
online services such as behavioral advertising, location and
map services, web search, and so on [8, 25].
While the idea of relying on trusted hardware and obliv-
ious RAM to enable access privacy in cloud services is
promising, for such an approach to become practical, a
key challenge is the practical efﬁciency of ORAM. ORAM
was initially proposed and studied mostly as a theoretic
concept. However, several recent works demonstrated the
potential of making ORAM practical in real-world scenar-
ios [25, 40, 46, 47].
A. Our Contributions
We design and build ObliviStore, an efﬁcient ORAM-
based cloud data store, securing data and access patterns
against adversaries in the malicious model. To the best of our
knowledge, ObliviStore is the fastest ORAM implementation
that has ever been built.
Our evaluation suggests that in a single client/server set-
ting with 7 rotational hard disk drives (HDDs), ObliviStore
is an order of magnitude faster than the independent work
PrivateFS by Williams et. al. [47] – with parameters chosen
to best replicate their experimental setup (Section VII-E).
As
solid-state drive (SSD) prices drop faster
than
HDDs [30], cloud providers and data centers embrace SSD
adoption [4]. In addition to HDDs, we also evaluate Oblivi-
Store with SSDs in a distributed setting on Amazon EC2.
With 11 trusted nodes (each with a modern CPU), we
achieve a throughput of 31.5MB/s with a block size of 4KB.
Our technical contributions include the following:
Making ORAM operations asynchronous. We propose
novel techniques for making the SSS ORAM [40] asyn-
chronous and parallel. We chose the SSS ORAM since it
is one of the most bandwidth efﬁcient ORAM constructions
known to date. Due to ORAM’s stringent security re-
quirements, making ORAM operations asynchronous poses
unique challenges. We must prevent information leakage not
only through access patterns as in traditional synchronous
ORAM, but also through the timing of I/O events. To address
this issue, we are the ﬁrst to formally deﬁne the notion of
oblivious scheduling. We prove that our construction satis-
ﬁes the oblivious scheduling requirement. Particularly, our
ORAM scheduler relies on semaphores for scheduling. To
satisfy the oblivious scheduling requirement, operations on
semaphores (e.g., incrementing, decrementing) must depend
only on information observable by an adversary who is not
aware of the data request sequence.
Distributed ORAM. Typical cloud service providers have
a distributed storage backend. We show how to adapt our
ORAM construction for a distributed setting.
Note that naive methods of partitioning and distributing
an ORAM may violate security. For example, as pointed
out in [40], even if each block is assigned to a random
1081-6011/13 $26.00 © 2013 IEEE
DOI 10.1109/SP.2013.25
253
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:55:02 UTC from IEEE Xplore.  Restrictions apply. 
UNTRUSTED CLOUD
UNTRUSTED CLOUD
ORAM node
ORAM node
ORAM node
Oblivious load balancer
...
Client Client Client Client
Client
PRIVATE CLOUD
Trusted 
hardware
ORAM node
ORAM node
ORAM node
Oblivious load balancer
...
Client Client Client
Client
Client
(a) Scenario 1: private + public cloud.
(b) Scenario 2: trusted hardware in the cloud.
Figure 1: Architecture and deployment scenarios.
partition when written, accessing the same block twice in
a row (read after write) can leak sensitive information. Our
distributed ORAM construction applies the SSS partitioning
framework [40] twice to achieve secure partitioning of an
ORAM across multiple servers.
We also propose a novel algorithm for securely scaling
up a distributed ORAM at run-time. Our techniques allow
additions of new processors and storage to an existing
distributed ORAM without causing service interruption. As
mentioned in Section VI, naive techniques for supporting
dynamic node joins can easily break security. Non-trivial
techniques are therefore required to securely handle dynamic
node joins.
Practical optimizations. ObliviStore is designed to take
into account many practical considerations (see full ver-
sion [39]). For example, we use batch shufﬂing to boost the
parallelism of the construction (Section V-C). We reorder
and coalesce asynchronous I/O requests to storage to opti-
mize the number of seeks on rotational drives.). We achieve
parallelism through asynchronous operations with callbacks
(rather than using more threads) to reduce thread scheduling
contention. Read accesses have higher scheduling priority
to minimize blocking on shufﬂing I/O’s, and hence result
in a lower overall response time, yet we make sure that the
shufﬂing always keeps up with the accesses (Section V-D).
√
In ObliviStore, our oblivious load balancer stores about 4
bytes of metadata per data block. While the metadata size is
linear in theory, its practice size is typically comparable to or
N ) data blocks. For theoretic inter-
smaller than storing O(
est, with suitable modiﬁcations to the scheme, it is possible
to achieve sublinear client storage by recursively outsourcing
the metadata to the untrusted storage as well [25, 35, 40].
In practice, however, the recursion depth is typically 1 to 3
(see [25, 35]) — we use a value of 1, i.e., no recursion.
II. ARCHITECTURE AND TRUST MODEL
Abstractly, all ORAM schemes assume a trusted client,
and an untrusted storage provider. In our distributed ORAM,
the trusted client consists of an oblivious load balancer and
multiple ORAM nodes – we will explain the role of each in
detail in Section VI. In practice, this means that we need
to trust the part of the software implementing the oblivious
load balancer and ORAM nodes. However, the rest of the
system need not be trusted – speciﬁcally, we do not trust the
network, the storage arrays, or the remainder of the software
stack (other than the part that implements the oblivious load
balancer and ORAM node algorithms).
ObliviStore is designed with two primary deployment
scenarios in mind (Figure 1). The 1st scenario (hybrid cloud)
is immediately deployable today, and PrivateFS [47] also
considers a similar scenario. While the 2nd scenario (trusted
hardware in the cloud) may not be immediately practical
today, we envision it as a promising direction for building
future privacy-preserving cloud services.
Hybrid cloud. One deployment scenario is corporate storage
outsourcing. Suppose a company or government agency
would like to outsource or backup its databases or ﬁle
systems to untrusted cloud storage providers. In these cases,
they may wish to separate the trusted components from the
untrusted components, and host the trusted components in
a private cloud in house, while outsourcing the untrusted
storage to remote cloud providers. For example, Zhang et.
[48] and others [41] describe such a hybrid cloud
al.
scenario in their paper. With ObliviStore, the oblivious load
balancer and the ORAM nodes would reside in house, while
the storage is provided by untrusted cloud providers. This
scenario is also similar to that considered by Williams et.
al. in their PrivateFS system [47].
Trusted hardware in the cloud. We envision a sec-
ond deployment strategy as a promising direction to build
a next generation of privacy-preserving cloud services.
254
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:55:02 UTC from IEEE Xplore.  Restrictions apply. 
ObliviAd [8] and Shroud [25] consider a similar scenario.
In various online services such as behavioral advertising
and web search, access patterns reveal a great deal of
sensitive information. For example, retrieving information
about a certain drug can reveal a users medical condition;
and retrieving information about a restaurant in New York
can reveal the user’s current location.
Several prior works [7, 8, 20, 25, 37, 43] have outlined
the vision using trusted hardware [2, 5] to establish a
“trust anchor” [34] in the cloud, which in turn relies on
Oblivious RAM to retrieve data from untrusted storage while
providing access privacy. For example, in S & P’12, Backes
et. al. [8], propose to use Oblivious RAM in combination
with trusted hardware, to ensure access privacy in online
behavioral advertising. We can rely on Trusted Platform
Modules (TPMs) [5, 26, 27] or secure co-processors [36, 38]
to establish a Trusted Computing Base (TCB) at the cloud
service provider. To achieve scalability, a distributed TCB is
needed, and can be established through techniques such as
in Excalibur [33].
In this scenario, our ORAM load balancer and ORAM
node algorithms will be implemented as part of the dis-
tributed TCB, and will be in charge of encryption and pri-
vatizing access patterns. Other than the TCB, the remainder
of the software stack on the cloud is untrusted. Existing
work has also discussed how minimize the TCB to reduce
the attack surface, and in some cases make it amenable to
formal veriﬁcation [22, 24, 42].
Using TPMs and Trusted Computing, we expect the dis-
tributed ORAM performance to be similar to the evaluations
shown in this paper, since Trusted Execution imposes rela-
tively small computational overhead. Moreover, this work
shows that computation is not the bottleneck for ObliviStore
when implemented on modern processors. On the other
hand, off-the-shelf secure co-processors such as IBM 4768
may offer the additional beneﬁt of physical security – but
they are constrained (e.g., in terms of chip I/O, computation
power, and memory) and would thus pose a bottleneck for
an ORAM implementation, as demonstrated by Lorch et.
al. [25]. However, it is conceivable that high performance
secure co-processors suitable for ORAM can be built [12].
III. PRELIMINARIES
A. Partitioning Framework
Stefanov, Shi, and Song propose a new paradigm for
constructing practical ORAM schemes [40], consisting of
two main techniques, partitioning and eviction. Through
partitioning,
they divide a bigger ORAM instance into
multiple smaller ORAM instances. Let N denote the total
ORAM capacity. The ORAM server storage is divided into
O(
√
N ) partitions, each with capacity O(
N ).
√
At any point of time, a block resides in a random partition.
The client stores a local position map to keep track of
which partition each block resides in. To access a block
The partitioning framework [40]
√
// Divide the ORAM into
N partitions each of capacity
√
N.
Read(blockid):
• Look up position map and determine that blockid is assigned
to partition p.
• If blockid is not found in eviction caches:
– ReadPartition(p, blockid)
Else if blockid is found in local eviction caches:
– ReadPartition(p,⊥)
//read dummy
• Pick a random partition p(cid:2)
, add the block identiﬁed by blockid
to the eviction caches, and logically assign blockid to partition
p(cid:2)
• Call Evict ν times where ν > 1 is the eviction rate.
Evict:
• Pick a random partition p.