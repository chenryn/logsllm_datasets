sions, we split the deﬁnitions of incompatible types such as
TLS 1.2
TLS 1.3
struct {
struct {
HandshakeType type;
uint24 length;
select (type) {
case hello_request:
Empty;
case certificate:
Certificate12;
/* ... */
case finished:
Finished;
} m[length];
} Handshake12;
HandshakeType type;
uint24 length;
select (msg_type) {
case eoed:
Empty;
case certificate:
Certificate13;
/* ... */
case key_update:
KeyUpdate;
} m[length];
} Handshake13;
Figure 6: Specialized Handshake types for TLS 1.2 and 1.3
Certificate and we deﬁne version-speciﬁc variants of the
handshake message type, shown in Figure 6. Before version
negotiation, hello messages are parsed using a third, version-
agnostic Handshake type. We then switch to parsers for the
negotiated version, thus ensuring that the following messages
are parsed using precise, version-speciﬁc types.
To address the problem of untagged unions, we introduce
an /*@implicit*/ attribute for tags, which instructs Quacky-
Ducky to generate an interface where the value of the tag is
passed as an additional argument to the parser and formatter.
This approach is not compositional, and comes with a restric-
tion: if a type that contains an implicit tag appears in another
type, it must appear at a location that includes an explicit
length. The parsing will be staged: when it reaches the sur-
rounding length, it skips its contents, leaving it uninterpreted.
The application needs to manually call the parser for the un-
tagged union by providing the tag value. The presence of
untagged unions is a clear mistake in message formats, as the
application is responsible for providing the correct tag when
it calls the parser, and thus, we only provide a conditional
security guarantee in this case.
Similarly to what we did with message types, we split and
specialize the deﬁnition of extension types for each message
that may include them (hellos, hello retry, encrypted exten-
sions, certiﬁcate, certiﬁcate request, new session ticket). This
also reveals some interesting mistakes in RFCs. For instance,
in [41, Appendix A], the authors fail to understand the pur-
pose of the explicit length around extensions, and incorrectly
believe it is redundant with the length of the list in the exten-
sion contents. They claim merging the two lengths makes the
extension less ambiguous; in reality, their change makes the
format more ambiguous: it is no longer possible to distinguish
between receiving no ticket and receiving an empty ticket. To
handle such corner cases, we add support in QuackyDucky
to coerce opaque arrays with explicit lengths to opaque lists
after parsing.
1470    28th USENIX Security Symposium
USENIX Association
4 Compiling Message Format Descriptions
We now present our compiler from the message formats of §3
to parsers and serializers for processing these messages in
Low(cid:63) [38]. We brieﬂy review F(cid:63) and Low(cid:63) (§4.1), then ex-
plain the code generated by QuackyDucky in three parts:
datatypes and parser speciﬁcations for veriﬁcation purposes
(§4.2); high-level functional parsers and serializers (§4.3);
and lower-lever code for reading (§4.4) and writing (§4.5)
messages.
QuackyDucky recursively descends through the structure of
the format description, generating parsers and serializers for
compound types from those previously generated, while keep-
ing track of their properties (notably their length boundaries).
QuackyDucky mostly composes the combinators provided by
LowParse, described in §5. In contrast with this library, which
involves complex proofs for a few generic combinators, the
generated code is verbose but shallow, enabling us to auto-
matically verify its safety, correctness, and non-malleability
using the properties veriﬁed in LowParse.
4.1 Veriﬁed Programming in Low(cid:63) (Review)
The F(cid:63) language and proof assistant We carry out our
speciﬁcation, implementation and proofs using F(cid:63) [48], a
functional language and proof assistant based on dependent
types. A simple form of dependent types supported in F(cid:63)
is reﬁnement types, to represent types of values satisfying
additional properties: whereas int is the F(cid:63) type of mathe-
matical integers, the type nat of non-negative mathematical
integers is deﬁned as the reﬁnement type (x: int { x ≥ 0 }). F(cid:63)
supports types that depend on other types and values. It
also supports functions where argument types can depend
on the values of the previous arguments and the type of the
return value of a function can depend on the values of its
arguments. For instance, the integer division function, which
would have a simple type int → int → int in a functional lan-
guage such as OCaml, can be given a more precise type,
such as (a: int) → (b: int {b > 0}) → (q: int { 0 ≤ a − b ∗ q  0). Conversely, the caller can use the postcondition
on its return value 0 ≤ a − b ∗ q ;
CipherSuite cipher_suites;
Compression compressions;
ClientHelloExtension extensions;
} ClientHello;
This message includes a 2-byte protocol version, a 32-byte
random nonce, a variable-length session identiﬁer for resump-
tion, and variable-length list of proposed cipher suites, com-
pression methods, and extensions. QuackyDucky translates it
to a corresponding F(cid:63) record type:
let in_range x min max = min ≤ x ∧ x ≤ max
type clientHello = {
version : protocolVersion;
random : (b:bytes {Bytes.length b == 32});
session_id : (b:bytes{in_range (Bytes.length b) 0 32});
cipher_suites : (l:list cipherSuite{in_range (List.length x) 1 32767});
compressions : (l: list compression{in_range (List.length l) 1 255});
extensions : (l: list extension{in_range (extensions_bytesize l) 0 65535});}
This high-level type includes precise length information,
coded as reﬁnements. Since the elements of the ﬁrst three
lists have constant binary lengths, QuackyDucky computes
precise bounds on their numbers of elements. Conversely, the
extensions in the last list are themselves of variable lengths,
hence QuackyDucky captures the bounds on its total binary
size using an auxiliary function extension_list_bytesize previously
deﬁned from the extension serializer. The main beneﬁt of cap-
turing these constraints is to ensure that all messages of type
clientHello can be serialized to a standard-compliant bytestring.
QuackyDucky also generates the corresponding metadata,
parser and serializer speciﬁcations.
let clientHello_meta = {low=43;high=131396; ...}
val clientHello_parser: parser clientHello_meta clientHello
val clientHello_serializer: serializer clientHello_parser
The parser metadata is exposed in the generated interface
(indicating, e.g., that the shortest TLS clientHello body message
takes 43 bytes) whereas the parser and serializer specs are kept
abstract—the interface gives their types, but hides the details
of their wire format. Thus, the three lines above state the
abstract, joint properties of our generated parser and serializer
specs (including non-malleability and round-trip properties)
and typechecking these specs ensures these properties hold.
Anticipating on the combinators deﬁned in §5, we give
below an outline of the generated deﬁnition of clientHello_parser,
which parses our sample message by successively calling the
parsers corresponding to each of its ﬁelds:
let clientHello_parser =
((protocolVersion_parser × clientHello_random_parser) × ...)
synth (fun ((pv, r), ...) → { protocolVersion = pv; random = r; ... })
These deﬁnitions are used only as reference implementa-
tions and are not extracted to C. In a second stage, Quacky-
Ducky generates actual parsers and serializers, and typecheck-
ing their code ensures they safely implement these specs.
4.3 Functional Parsers and Serializers
QuackyDucky generates high-level functional parsers and
serializers, with the following interface. (The “32” sufﬁx in-
dicates that their code uses 32-bit machine integers instead of
the unbounded integers in their specs.)
val clientHello_parser32: parser32 clientHello_parser
val clientHello_serializer32: serializer32 clientHello_serializer
We systematically index our implementations by their speciﬁ-
cations. Here, for instance, the type deﬁnition parser32 p used
above simply states that a high-level parser for the parser-
speciﬁcation p is a pure function that takes a (bounded, im-
mutable) F(cid:63) bytestring and returns the same result as p on the
corresponding sequence of bytes except that the consumed
length is an unsigned 32-bit integer.
We give below an F(cid:63) code sample illustrating their use: a
‘reader’ function that counts the number of cipher suites in
a given ClientHello message in wire format, and a ‘writer’
function that builds a message given a conﬁguration.
1472    28th USENIX Security Symposium
USENIX Association