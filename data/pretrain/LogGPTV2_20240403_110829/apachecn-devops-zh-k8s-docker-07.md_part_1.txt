# 七、将认证集成到您的集群中
一旦构建了集群，用户就需要安全地与之交互。对于大多数企业来说，这意味着对单个用户进行认证，并确保他们只能访问完成工作所需的内容。对于 Kubernetes，这可能很有挑战性，因为集群是 API 的集合，而不是具有可以提示认证的前端的应用。
在本章中，您将学习如何使用 OpenID Connect 协议和 Kubernetes 模拟将企业认证集成到集群中。我们还将介绍几种反模式，并解释为什么应该避免使用它们。
在本章中，我们将涵盖以下主题:
*   理解 Kubernetes 如何知道你是谁
*   了解 OpenID 连接
*   还有其他选择吗？
*   正在为 OpenID Connect 配置 KinD
*   云·Kubernetes 斯怎么知道你是谁
*   为模拟配置集群
*   在没有 OpenUnison 的情况下配置模拟
*   我们开始吧！
# 技术要求
要完成本章中的练习，您将需要以下内容:
*   拥有 8 GB 内存的 Ubuntu 18.04 服务器
*   使用第 5 章*中的配置运行的 KinD 集群，使用 KinD* 部署集群
您可以在以下 GitHub 存储库中访问本章的代码:[https://GitHub . com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter 7](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter7)。
# 了解 Kubernetes 如何知道你是谁
没有勺子
–矩阵，1999 年
在 1999 年的科幻电影*《黑客帝国》*中，尼奥在一个孩子等着看神谕的时候，和他聊起了黑客帝国。孩子向他解释操纵矩阵的诀窍是意识到*“没有勺子”*。
这是一个观察 Kubernetes 用户的好方法，因为他们不存在。除了我们稍后将讨论的服务帐户之外，Kubernetes 中没有称为“用户”或“组”的对象。每个应用编程接口交互都必须包含足够的信息，以告诉应用编程接口服务器用户是谁以及用户是哪个组的成员。这个断言可以采取不同的形式，这取决于您计划如何将认证集成到集群中。
在本节中，我们将详细介绍 Kubernetes 将用户与集群相关联的不同方式。
## 外部用户
从集群外部访问 Kubernetes API 的用户通常会使用以下两种认证方法之一:
*   **证书**:您可以使用包含您信息的客户端证书来声明您使用的是谁，例如您的用户名和组。该证书被用作 TLS 协商过程的一部分。
*   **承载令牌**:嵌入在每个请求中，承载令牌可以是包含验证自身所需的所有信息的自包含令牌，也可以是可以由 API 服务器中的网络钩子交换该信息的令牌。
您也可以使用服务帐户来访问集群外的应用编程接口服务器，尽管强烈建议不要这样做。我们将在*中介绍使用服务帐户的风险和顾虑，还有哪些选择？*节。
## Kubernetes 族
不同的用户可以被分配相同的权限，而无需通过组为每个用户单独创建`RoleBinding objects`。Kubernetes 包括两种类型的组:
*   **系统分配**:这些组以`system:`前缀开始，由 API 服务器分配。一个示例组是`system:authenticated`，它被分配给所有经过认证的用户。系统分配组的其他示例有`system:serviceaccounts:namespace`组，其中`Namespace`是命名空间的名称，包含组中命名空间的所有服务帐户。
*   **用户声明的组**:这些组由认证系统在提供给应用编程接口服务器的令牌中或通过认证网络挂钩来声明。这些团体的命名没有标准或要求。就像用户一样，组在应用编程接口服务器中不作为对象存在。外部用户在认证时声明组，并在本地跟踪系统生成的组。当断言用户的组时，用户的唯一标识和组之间的主要区别是唯一标识应该是唯一的，而组不是。
您可能被授权按组访问，但所有访问仍会根据您用户的唯一标识进行跟踪和审核。
## 服务账户
服务账户是存在于应用编程接口服务器中的对象，用于跟踪哪些吊舱可以访问各种应用编程接口。服务帐户令牌被称为 **JSON 网络令牌**，或 **JWTs** 。根据令牌的生成方式，有两种方法可以获得服务帐户:
*   第一个是服务帐户创建时由 Kubernetes 生成的一个机密。
*   第二种是通过`TokenRequest`应用编程接口，用于通过挂载点将机密注入吊舱或从集群外部使用。所有服务帐户都是通过将令牌作为请求头注入到应用编程接口服务器中来使用的。API 服务器将其识别为服务帐户，并在内部对其进行验证。
与用户不同，服务帐户可以**而不是**分配给任意组。服务帐户是预建组的成员，但是您不能为分配角色创建一组特定的服务帐户。
既然我们已经探索了 Kubernetes 如何识别用户的基本原理，我们将探索这个框架如何适应**OpenID Connect**(**OIDC**)协议。OIDC 提供了大多数企业所需的安全性，并且是基于标准的，但是 Kubernetes 并没有像许多网络应用那样使用它。了解这些差异以及 Kubernetes 需要它们的原因是将集群集成到企业安全环境中的重要一步。
# 了解 OpenID 连接
OpenID Connect 是一个标准身份联邦协议。它建立在 OAuth2 规范的基础上，具有一些非常强大的特性，使其成为与 Kubernetes 集群交互的首选。
OpenID Connect 的主要好处如下:
*   **短命令牌**:如果令牌被泄露，例如通过日志消息或漏洞，您希望令牌尽快过期。使用 OIDC，您可以指定可存活 1-2 分钟的令牌，这意味着当攻击者试图使用令牌时，令牌可能会过期。
*   **用户和组成员身份**:当我们开始谈论授权时，我们会很快看到按组管理访问很重要，而不是直接引用用户来管理访问。OIDC 令牌可以嵌入用户的标识符和他们的组，从而更容易进行访问管理。
*   **刷新超时策略范围内的令牌**:对于短期令牌，您需要能够根据需要刷新它们。刷新令牌的有效时间可以限定在您企业的 web 应用空闲超时策略的范围内，从而使您的集群与其他基于 web 的应用保持一致。
*   **kube CTL**不需要插件:`kubectl`二进制支持 OpenID Connect 原生，所以不需要任何额外的插件。如果因为无法将**命令行界面** ( **CLI** )工具直接安装到工作站上而需要从跳转框或虚拟机访问集群，这尤其有用。
*   **更多多因素认证选项**:很多最强的多因素认证选项都需要网络浏览器。例子包括使用硬件令牌的 FIDO U2F 和 WebAuth。
OIDC 是一个同行评审的标准，已经使用了几年，并正在迅速成为身份联盟的首选标准。
重要说明
身份联合是一个术语，用于描述身份数据的断言和认证，而不共享用户的机密机密或密码。身份联盟的一个经典示例是登录您的员工网站，无需再次登录即可访问您的福利提供商。您的员工网站没有与福利提供商共享您的密码。相反，你的员工网站*断言*你在某个日期和时间登录，并提供了一些关于你的信息。这样，您的帐户将跨两个孤岛(您的员工网站和福利门户)进行*联合*，而您的福利门户不知道您的员工网站密码。
## 开放身份连接协议
正如你所看到的，OIDC 有多个组成部分。为了完全理解 OIDC 是如何工作的，让我们开始 OpenID 连接协议。
我们将重点关注《OIDC 议定书》的以下两个方面:
*   使用带有`kubectl`和应用编程接口服务器的令牌
*   刷新令牌以使您的令牌保持最新
我们不会太专注于获取代币。虽然获取令牌的协议确实遵循标准，但登录过程并不遵循标准。根据您选择如何实现 OIDC **身份提供者** ( **境内流离失所者**)，您从身份提供者处获取令牌的方式会有所不同。
OIDC 登录过程生成了三个令牌:
*   `access_token`:这个令牌是用来对你的身份提供者可能提供的 web 服务进行认证请求，比如获取用户信息。是**不是**Kubernetes 用的，可以丢弃。
*   `id_token`:这个令牌是一个 JWT，它封装了你的身份，包括你的唯一标识符(sub)、组和关于你的到期信息，API 服务器可以使用这些信息来授权你的访问。JWT 是由您的身份提供者的证书签署的，Kubernetes 斯只需检查 JWT 的签名即可验证。这是您传递给 Kubernetes 的令牌，用于每个验证自己身份的请求。
*   `refresh_token` : `kubectl`知道如何在到期后自动为你刷新`id_token`。为此，它会使用`refresh_token`呼叫您的 IdP 令牌端点，以获取新的`id_token`。A `refresh_token`只能使用一次且不透明，意味着你作为代币持有者，对代币的格式没有可见性，对你来说真的无所谓。它要么起作用，要么不起作用 *refresh_token 从不去 Kubernetes(或任何其他应用)。它仅用于与 IdP 的通信。*
一旦您有了令牌，就可以使用它们向应用编程接口服务器进行认证。使用令牌最简单的方法是使用命令行参数将它们添加到`kubectl`配置中:
```
kubectl config set-credentials username --auth-provider=oidc --auth-provider-arg=idp-issuer-url=https://host/uri --auth-provider-arg=client-id=kubernetes --auth-provider-arg=refresh-token=$REFRESH_TOKEN --auth-provider-arg=id-token=$ID_TOKEN 
```
`config set-credentials`有几个选项需要提供。我们已经解释了`id-token`和`refresh_token`，但是还有两个额外的选项:
*   `idp-issuer-url`:这就是我们将用来配置 API 服务器的同一个 URL，并且指向用于 IdP 的发现 URL 的基本 URL。
*   `client-id`:这是您的 IdP 用来识别您的配置。这是 Kubernetes 部署独有的，不被视为机密信息。
OpenID 连接协议有一个可选元素，称为`client_secret`，即 OIDC 客户端和 IdP 之间共享的。它用于在发出任何请求(如刷新令牌)之前“验证”客户端。虽然 Kubernetes 支持它作为一个选项，但它的建议不要使用它，而是将您的 IdP 配置为使用公共端点(根本不使用机密)。
客户端机密没有实际价值，因为您需要与每个潜在用户共享它，并且因为它是一个密码，所以您企业的法规遵从性框架可能需要定期轮换，从而导致支持问题。总的来说，就安全性而言，它不值得任何潜在的负面影响。
重要说明
Kubernetes 要求您的身份提供者支持发现 URL 端点，这是一个提供一些 JSON 的 URL，告诉您在哪里可以获得密钥来验证 JWTs 和各种可用的端点。取任意发行人网址，添加`/.well-known/openid-configuration`即可查看该信息。
## 跟随 OIDC 和 API 的互动
一旦`kubectl`已经被配置，您的所有应用编程接口交互将遵循以下顺序:
![Figure 7.1 – Kubernetes/kubectl OpenID Connect sequence diagram ](img/Fig_7.1_B15514.jpg)
图 7.1-立方体/立方体 OpenID 连接顺序图
上图来自[https://Kubernetes . io/docs/reference/access-authn-authz/authentication/# OpenID-connect-token](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens)的 Kubernetes 认证页面。验证请求包括执行以下操作:
1.  **登录您的身份提供者(IdP)** :这对于每个 IdP 都是不同的。这可能涉及为网络浏览器中的表单、多因素令牌或证书提供用户名和密码。这对于每个实现都是特定于实现的。
2.  **向用户**提供令牌:一旦通过认证，用户需要一种方式来生成`kubectl`访问 Kubernetes APIs 所需的令牌。这可以采取应用的形式，使用户可以轻松地将它们复制并粘贴到配置文件中，也可以是新的下载文件。
3.  这一步是将`id_token`和`refresh_token`添加到`kubectl`配置中。如果令牌在浏览器中呈现给用户，则可以手动将其添加到配置中。如果提供了新的配置以便可以下载，则可以。还有`kubectl`插件，它会启动一个网络浏览器来启动认证过程，一旦完成，就会为你生成你的 c 配置。
4.  **注入 id_token** :一旦调用了`kubectl`命令，每个 API 调用都包含一个添加头，称为`Authorization`头，其中包含`id_token`。
5.  **JWT 签名验证**:一旦 API 服务器收到来自 API 调用的`id_token`，它就根据身份提供者提供的公钥验证签名。应用编程接口服务器还将验证发行者是否与应用编程接口服务器配置的发行者匹配，以及接收者是否与应用编程接口服务器配置的客户端标识匹配。
6.  **检查 JWT 的有效期**:代币只在有限的时间内有效。应用编程接口服务器确保令牌没有过期。
7.  **授权检查**:现在用户已经通过认证，API 服务器将通过将用户的标识符和断言的组与内部策略进行匹配，来确定所提供的`id_token`所标识的用户是否能够执行所请求的动作。
8.  **执行 API** :所有检查完成，API 服务器执行请求，生成响应，发送回`kubectl`。
9.  **Format the response for the user**: Once the API call is complete (or a series of API calls), the JSON is formatted for the user by `kubectl`.
    重要说明
    一般来说，认证是验证你是不是你的过程。当我们将用户名和密码放入网站时，大多数人都会遇到这种情况。我们在证明我们是谁。在企业世界中，授权成为我们是否被允许做某事的决定。首先，我们验证，然后授权。围绕 API 安全性构建的标准没有假设认证，而是直接基于某种令牌进行授权。这并不是说必须要识别打电话的人。例如，当你用实体钥匙开门时，门不知道你是谁，只知道你有正确的钥匙。这个术语可能会变得非常混乱，所以如果你有点迷路了，不要感到难过。你有好伙伴！
`id_token`是自足的；API 服务器需要知道的关于您的一切都在那个令牌中。API 服务器使用身份提供者提供的证书验证`id_token`，并验证令牌没有过期。只要一切正常，API 服务器就会根据自己的 RBAC 配置来授权您的请求。我们将在后面介绍这个过程的细节。最后，假设您获得授权，应用编程接口服务器会提供响应。
注意 Kubernetes 永远看不到你的密码或者任何其他你知道的机密信息，只有你知道。唯一共享的是`id_token`，那是短暂的。这引出了几个要点:
*   由于 Kubernetes 永远看不到您的密码或其他凭据，因此无法泄露它们。这可以为您节省大量与安全团队合作的时间，因为所有与保护密码相关的任务都可以跳过！
*   `id_token`是自包含的，这意味着如果它被泄露，除了重新键入您的身份提供者，您无能为力来阻止它被滥用。这就是为什么你的`id_token`寿命短如此重要。在 1-2 分钟内，攻击者能够获得`id_token`，意识到它是什么，并滥用它的可能性非常低。
如果`kubectl`在执行呼叫时发现`id_token`已过期，它将尝试使用`refresh_token`调用 IdP 的令牌端点来刷新它。如果用户的会话仍然有效，IdP 将生成新的`id_token`和`refresh_token`，它们将在`kubectl`配置中为您存储。这在没有用户干预的情况下自动发生。此外，`refresh_token`具有一次性使用，因此如果有人试图使用以前使用的`refresh_token`，您的 IdP 将无法通过刷新过程。
重要说明
这是必然会发生的。有人可能需要立即被锁在外面。可能是他们被解雇了，也可能是他们的会话被破坏了。这取决于您的 IdP，因此在选择 IdP 时，请确保它支持某种形式的会话撤销。
最后，如果`refresh_token`已经过期或者会话已经被撤销，API 服务器将返回 **401 未授权**消息，以指示它将不再支持令牌。
我们已经花了相当多的时间来研究 OIDC 协议。现在，让我们深入了解一下`id_token`。
### id_token
一个`id_token`是一个 JSON 网络令牌，它是 base64 编码的并且是数字签名的。在 OIDC，JSON 包含一系列属性，称为声明。i `d_token`中有一些标准的索赔，但大部分情况下，您最关心的索赔如下:
*   `iss`:发行人，在你的库比特配置中**必须与发行人**一致
*   `aud`:你的客户 ID
*   `sub`:您的唯一标识符
*   `groups`: Not a standard claim, but should be populated with groups specifically related to your Kubernetes deployment
    重要说明
    许多部署试图通过您的电子邮件地址来识别您。这是一种反模式，因为您的电子邮件地址通常基于您的姓名，并且姓名会改变。子声明应该是一个唯一的标识符，它是不可变的，永远不会改变。这样，即使你的电子邮件因为你的名字改变而改变也没关系。这可就更难调试*“谁是 cd25d 24d-74 b8-4c 4-8 b8c-116 bf4 abb d26？”*但将提供更干净和更容易维护的集群。