and, (2) an attacker is unable to calculate any preceding
guard as this would imply inverting the hash function.
3.3 ChkPassword: A Running Toy Example
Guaranteeing state-continuity is non-trivial and can only
be accomplished by a module provider taking the required
safety precautions. We only provide a library oﬀering state-
continuous storage. To demonstrate the subtle vulnerabili-
ties that need to be resolved, consider as a running example
ChkPassword, a password-checking module displayed in list-
ing 1. It exposes an interface of two functions: set_passwd
that modiﬁes the user’s password and check_passwd2 that
handles login attempts. To prevent dictionary attacks, Chk-
Password will lock out a user indeﬁnitely after 3 incorrect
attempts. We assume that when the module is created, the
INIT function is called before any service call is handled.
When ChkPassword executes on the platform for the ﬁrst
time, a default password is selected (line 7), otherwise its
previous state is restored (line 10).
To ensure state continuity, ChkPassword needs to fulﬁll
three requirements. First, it must protect against subtle
timing attacks. When an attacker is able to infer that the
provided password is incorrect based on timing diﬀerences
between a correct and incorrect password3, she may be able
to crash the system before the login attempt could be re-
corded. Ensuring that each execution path takes exactly
the same amount of CPU cycles is hard. Similar to Parno
et al. [20], we take a much simpler approach and store the
state with the newly provided input before it is used in any
computation. Hence, ChkPassword stores its current state
2Calling ChkPassword from unprotected memory would en-
able an attacker to intercept the provided password before
it reaches the module. Users of ChkPassword should estab-
lish a secure channel from another module before exchanging
sensitive data [2, 28]. Such considerations are out of scope.
3A similar attack exists when a (unique) callback to unpro-
tected memory is made before an undesirable state is stored.
(cid:20)(cid:19)(cid:27)
1 s t a t i c
i n t a t t em p t s l e f t ;
s t a t i c c h a r ∗ password ;
v o i d INIT ( v o i d ) {
S t a t e ∗ s t a t e ;
i f
( r e t r i e v e ( &s t a t e ) == UNINITIALIZED ){
password = ” d e f a u l t ” ;
a t t em p t s l e f t = 3 ;
} e l s e
r e s t o r e a n d r e s t a r t (
11 }
13 i n t ENTRY POINT c h e c k p a s s w d ( c h a r ∗ g u e s s ) {
s t a t e ) ;
S t a t e ∗ s t a t e = new S t a t e ( ) ;
3
5
7
9
15
17
19
21
23
25
27
29
// s t o r e ( input ,
c o l l e c t s t a t e (
c o l l e c t e n t r y (
c o l l e c t i n p u t (
s t o r e (
s t a t e ) ;
s t a t e )
t u p l e
s t a t e ) ;
s t a t e , ”CHECK PASSWD” ) ;
s t a t e , g u e s s
) ;
// che ck passwd
i f
( a t t e m p t s l e f t > 0 &&
strcm p ( password , g u e s s
) == 0 ) {
} e l s e {
a t t em p t s l e f t = 3 ;
r e t u r n OK;
a t t em p t s l e f t = max( a t t e m p t s l e f t −1 ,0) ;
r e t u r n INCORRECT;
}
31 }
33 i n t ENTRY POINT s e t p a s s w d ( c h a r ∗ oldpwd ,
c h a r ∗newpwd ) { . . . }
Listing 1: ChkPassword: A running example
(the number of attempts left and the correct password) to-
gether with the provided guess (line 17-20) before checking
the provided password. An unexpected crash while the pass-
word is being veriﬁed (i.e., after line 20), will then result in
the current state being restored and execution is restarted;
another attempt is made to check the same provided pass-
word. We assume restore_and_restart restores the cur-
rent state and restarts execution of the last called entry
point (line 10). Alternatively, if the system crashed before
the input could be recorded and thus was never used in any
meaningful computation (i.e., before line 20), the provided
guess can simply be discarded.
Second, in order to guarantee that re-execution of the
same input on the same state always leads to an identi-
cal result, modules must be deterministic. This implies that
modules must consider all sources of non-determinism (e.g.,
the result of a random number generator) as input and thus
store such data before using it in any computation.
Third, an attacker must not be able to infer any value
from the size of the stored states on disk; modules must
ensure that all cubes are equal in size.
3.4 ICE Libraries
We will provide state-continuous storage in two steps. In
Section 3.4.1 we introduce libice0, a library providing sup-
port at the cost of scarce platform resources for every in-
stance. Then in Section 3.4.2, we present libicen that al-
leviates resource pressure by storing freshness information
(cid:20)(cid:19)(cid:28)
1 v o i d s t o r e ( S t a t e ∗ s t a t e ) {
s w i t c h ( i c e . mode ) {
3
5
7 } }
c a s e C l e a r :
r e t u r n
i n i t s t a t e (
s t a t e ) ;
c a s e A c t i v a t e d :
r e t u r n
u p d a t e s t a t e (
s t a t e ) ;
9 i n t
r e t r i e v e ( S t a t e ∗∗ s t a t e ) {
s w i t c h ( tpm . mode ) {
11
13
15
} }
c a s e C l e a r :
c a s e A c t i v a t e d :
r e t u r n UNINITIALIZED ;
∗ s t a t e = r e c o v e r y s t e p ( ) ;
r e t u r n RECOVERED;
Listing 2: libice0 relies on tpm.mode and ice.mode
to distinguish between storing an initial state,
updating a stored state and recovery
in a single, state-continuous module ice0. As all libicen
library instances connect to the same, unique ice0 instance,
a virtually unlimited number of modules is supported.
Both libice0 and libicen provide the same interface:
store(State *) and retrieve(State **). To avoid re-
peated TPM or ice0 accesses, libice0 and libicen keep
a cached copy. In order to distinguish between these copies
and explicitly state where they are stored, we will reference
them similarly to ﬁelds of a struct. For example, the en-
cryption and MAC keys stored in the TPM chip will be
referenced as tpm.keys. The variables used by the ICE
algorithm are referenced as ice.keys and so on. Besides
storing keys and the guard we also keep track of the state
of the algorithm using a mode variable. Stored inside the
TPM chip (tpm.mode), this variable indicates whether ICE
was once initiated correctly.
In libice0 (ice.mode) this
variable is used to indicate whether ICE was initiated or
recovered since reboot. We assume that when a module is
resurrected after a crash, ice.mode is initialized with value
Clear. As a shorthand, we also assume that setting this
variable takes exclusive access of guarded memory. Listing 2
uses these variables to diﬀerentiate between an initial state
being stored and a state being updated. Similarly, tpm.mode
is used to determine whether a state was ever stored.
3.4.1 libice0: State-Cont. Storage for One Module
In order to provide state continuity, we must guarantee
that an attacker is not able to fabricate recorded states
(called cubes) and that no stale cubes can be provided as
being fresh. The former is trivially guaranteed by including
a message authentication code in each cube. Guaranteeing
freshness is more challenging, but as modules maintain their
state between invocations, we only need to consider power
oﬀ and reboot events. Let’s call events during such power
cycles an execution stream. An execution stream starts by
either storing an initial state of a module or when the state
of a module is recovered after a crash.
It ends when the
system crashes or when it is shut down properly.
To keep track of the fresh cube, we will generate a (base)
guard when the execution stream starts and store it securely
in TPM NVRAM. For every state the module requests stor-
age of in the current execution stream, we will increment the
v o i d
i n i t s t a t e ( S t a t e ∗ s t a t e ) {
i c e . guard = g e n g u a r d ( ) ;
i c e . k e y s = g e n k e y s ( ) ;
hdd . w r i t e ( new Cube (
i c e . guard ,
i c e . keys ,
2
4
6
8
10 }
s t a t e ) ) ;
i c e . mode = A c t i v a t e d ;
gmem . guard = i c e . guard ;
tpm . guard = i c e . guard ;
tpm . k e y s = i c e . k e y s ;
tpm . mode = A c t i v a t e d ;
Listing 3: libice0: Storing the initial state
v o i d
u p d a t e s t a t e ( S t a t e ∗ s t a t e ) {
i c e . guard = ++i c e . guard ;
hdd . w r i t e ( new Cube (
i c e . guard ,
s t a t e ) ) ;
gmem . guard = i c e . guard ;
2
4
}
i c e . keys ,
19
5
7
9
11
13
15 }
25
27
29 }
Listing 4: libice0: Updating a state
guard and include it in the generated cube. Using guarded
memory we will ensure that only the guard included in the
last (and thus fresh) cube is leaked at the moment the sys-
tem crashes. As no preceding guards were leaked (and can-
not be calculated), it serves as a pointer to the fresh cube.
Upon recovery, knowledge of the guard4 that is stored in the
provided cube, proves that the cube is fresh.
Creation of an Initial State.
When storage of the initial state of the module is re-
quested, a new base guard and keys are generated (see list-
ing 3). Next, a new cube is constructed and written to disk.
Exclusive access of guarded memory is taken by setting the
ice.mode variable to Activated and the fresh guard is writ-
ten to guarded memory. In case exclusive access cannot be
assigned (i.e., another module already received it), the mod-
ule simply stops its execution. For clarity, such error han-
dling is not displayed. Finally the keys and guard are stored
in the TPM’s NVRAM and tpm.mode is set to Activated,
committing the start of a new execution stream.
Updating a State.
When storage of a new input-state pair is requested in the
same execution stream, the previously used guard and keys
are still stored in libice0’s memory and no TPM accesses
are required. To safely store the input-state pair, a new
cube is created with the subsequent guard and stored on
disk (listing 4). Finally the fresh guard is written to guarded
memory, committing the step.
Recovering from a Crash.
Recovering from a crash ism ore challenging and is per-
formed in two steps (see listing 5, error handling is omitted
for clarity). First, the last stored cube is read from disk. By
verifying three properties its freshness is ensured:
1 S t a t e ∗ r e c o v e r y s t e p ( ) {
Cube cube = hdd . r e a d ( ) ;
i f
i s f r e s h ( &cube )
3
) {
(
S t a t e ∗ s t a t e = e x t r a c t ( cube , tpm . k e y s ) ;
i c e . guard = g e n g u a r d ( ) ;
i c e . k e y s = tpm . k e y s ;
hdd . w r i t e ( new Cube (
i c e . guard ,
i c e . keys ,
s t a t e )
) ;
i c e . mode = A c t i v a t e d ;
gmem . guard = i c e . guard ;
tpm . guard = i c e . guard ;
r e t u r n s t a t e ;
}
e l s e a b o r t ( ) ;
17 b o o l
r e t u r n ( check mac ( cube , tpm . k e y s
i s f r e s h ( Cube ∗ cube ) {
) &&
tpm . guard ≤ cube−>guard &&
gmem . guard . v a l u e == cube−>guard . v a l u e ) ;
21 }
23 b o o l o p e r a t o r≤ ( Guard g1 , Guard g2 ) {
w h i l e ( g1 . i n d e x < g2 . i n d e x ) {
g1 . v a l u e = Hash ( g1 . v a l u e ) ;
++g1 . i n d e x ;
}
r e t u r n g1 . v a l u e == g2 . v a l u e ;
Listing 5: libice0: Recovering from a crash.
• Validity: Cubes must not have been forged. This is
ensured by the MAC stored in each cube and the ac-
companying key stored securely in the TPM (line 17).
• Correct execution stream: The cube received from the
untrusted OS must have been created during the last
execution stream. Starting each execution stream, a
new base guard is generated and stored safely in TPM
NVRAM. All guards used during this execution stream
are successors of this base guard. Hence, the cube was
created during the last execution stream iﬀ (line 18):
tpm.guard ≤ cube.guard
• Public guard: libice0 ensures that guarded memory
always contains the same guard as the last (fresh) cube
stored on disk5, and that no preceding guards leak
or can be calculated. Hence, if the guard stored in
guarded memory matches the guard included in the
cube at hand and the two previous properties hold as
well, it is guaranteed that the cube is fresh (line 19).
In the second step the fresh state is re-stored as part of
a new execution stream: libice0’s variables are restored
from TPM NVRAM, a new base guard is generated, the
fresh state packaged in a new cube and the base guard is
written to guarded and TPM NVRAM memory. To ensure
that after an unexpected crash during the execution of this
step, recovery can be restarted, libice0 must (1) backup
the previous fresh guard before overwriting it in guarded
4We must also check that this guard was created during the
last execution stream as a matching guard/cube is found at
the end of every execution stream.
5There is one exception as writing cubes to disk and updat-
ing guarded memory cannot be executed atomically. This
exception is resolved later in this section.
(cid:20)(cid:20)(cid:19)
memory. As this value is public, any persistent storage can