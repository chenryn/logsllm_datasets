2. 系统的性能考虑：
由于分区将数据集中在某个柱面的区段，例如上图当中第一个分区位于柱面号码1~100号，如此一来当有数据要读取自该分区时， 磁盘
只会搜寻前面1~100的柱面范围，由于数据集中了，将有助于数据读取的速度与性能！所以说，分区是很重要的！
既然分区表只有记录四组数据的空间，那么是否代表我一颗硬盘最多只能分区出四个分区？当然不是啦！有经验的朋友都知道， 你可以
将一颗硬盘分区成十个以上的分区的！那又是如何达到的呢？在Windows/Linux系统中， 我们是通过刚刚谈到的延伸分区（Extended）的方式
来处理的啦！延伸分区的想法是： 既然第一个扇区所在的分区表只能记录四笔数据， 那我可否利用额外的扇区来记录更多的分区信息？实际
上图示有点像下面这样：
图2.2.3、磁盘分区表的作用示意图
Tips
实际上延伸分区并不是只占一个区块，而是会分布在每个分区的最前面几个扇区来记载分区信息的！只是为了方便读者记忆， 鸟哥在上图就将他
简化了！有兴趣的读者可以到下面的链接瞧一瞧实际延伸分区的纪录方式：
http://en.wikipedia.org/wiki/Extended_boot_record
在上图当中，我们知道硬盘的四个分区记录区仅使用到两个，P1为主要分区，而P2则为延伸分区。请注意， 延伸分区的目的是使用额
外的扇区来记录分区信息，延伸分区本身并不能被拿来格式化。 然后我们可以通过延伸分区所指向的那个区块继续作分区的记录。
如上图右下方那个区块有继续分区出五个分区， 这五个由延伸分区继续切出来的分区，就被称为逻辑分区（logical partition）。 同时注
意一下，由于逻辑分区是由延伸分区继续分区出来的，所以他可以使用的柱面范围就是延伸分区所设置的范围喔！ 也就是图中的101~400啦！
同样的，上述的分区在Linux系统中的设备文件名分别如下：
P1:/dev/sda1
P2:/dev/sda2
L1:/dev/sda5
L2:/dev/sda6
L3:/dev/sda7
L4:/dev/sda8
L5:/dev/sda9
仔细看看，怎么设备文件名没有/dev/sda3与/dev/sda4呢？因为前面四个号码都是保留给Primary或Extended用的嘛！ 所以逻辑分区的设
备名称号码就由5号开始了！这在 MBR 方式的分区表中是个很重要的特性，不能忘记喔！
MBR 主要分区、延伸分区与逻辑分区的特性我们作个简单的定义啰：
主要分区与延伸分区最多可以有四笔（硬盘的限制）
延伸分区最多只能有一个（操作系统的限制）
逻辑分区是由延伸分区持续切割出来的分区；
能够被格式化后，作为数据存取的分区为主要分区与逻辑分区。延伸分区无法格式化；
逻辑分区的数量依操作系统而不同，在Linux系统中SATA硬盘已经可以突破63个以上的分区限制；
事实上，分区是个很麻烦的东西，因为他是以柱面为单位的“连续”磁盘空间， 且延伸分区又是个类似独立的磁盘空间，所以在分区的时
候得要特别注意。我们举下面的例子来解释一下好了：
例题：
在Windows操作系统当中，如果你想要将D与E盘整合成为一个新的分区，而如果有两种分区的情况如下图所示， 图中的特殊
颜色区块为D与E盘的示意，请问这两种方式是否均可将D与E整合成为一个新的分区？
图2.2.4、磁盘空间整合示意图
答：
上图可以整合：因为上图的D与E同属于延伸分区内的逻辑分区，因此只要将两个分区删除，然后再重新创建一个新的分区， 就
能够在不影响其他分区的情况下，将两个分区的容量整合成为一个。
下图不可整合：因为D与E分属主分区与逻辑分区，两者不能够整合在一起。除非将延伸分区破坏掉后再重新分区。 但如此一来
会影响到所有的逻辑分区，要注意的是：如果延伸分区被破坏，所有逻辑分区将会被删除。 因为逻辑分区的信息都记录在延伸
分区里面嘛！
由于第一个扇区所记录的分区表与MBR是这么的重要，几乎只要读取硬盘都会先由这个扇区先读起。 因此，如果整颗硬盘的第一个扇
区（就是MBR与partition table所在的扇区）物理实体坏掉了，那这个硬盘大概就没有用了！ 因为系统如果找不到分区表，怎么知道如何读取柱
面区间呢？您说是吧！下面还有一些例题您可以思考看看：
例题：
如果我想将一颗大硬盘“暂时”分区成为四个partitions，同时还有其他的剩余容量可以让我在未来的时候进行规划， 我能不能分
区出四个Primary？若不行，那么你建议该如何分区？
答：
由于Primary+Extended最多只能有四个，其中Extended最多只能有一个，这个例题想要分区出四个分区且还要预留剩余容量，
因此P+P+P+P的分区方式是不适合的。因为如果使用到四个P，则即使硬盘还有剩余容量， 因为无法再继续分区，所以剩余容
量就被浪费掉了。
假设你想要将所有的四笔记录都花光，那么P+P+P+E是比较适合的。所以可以用的四个partitions有3个主要及一个逻辑分区，
剩余的容量在延伸分区中。
如果你要分区超过4个以上时，一定要有Extended分区，而且必须将所有剩下的空间都分配给Extended， 然后再以logical的分区
来规划Extended的空间。 另外，考虑到磁盘的连续性，一般建议将Extended的柱面号码分配在最后面的柱面内。
例题：
假如我的PC有两颗SATA硬盘，我想在第二颗硬盘分区出6个可用的分区（可以被格式化来存取数据之用）， 那每个分区在
Linux系统下的设备文件名为何？且分区类型各为何？至少写出两种不同的分区方式。
答：
由于P（primary）+E（extended）最多只能有四个，其中E最多只能有一个。现在题目要求6个可用的分区，因此不可能分出四
个P。 下面我们假设两种环境，一种是将前四号全部用完，一种是仅花费一个P及一个E的情况：
P+P+P+E的环境：
图2.2.5、分区示意图
实际可用的是/dev/sdb1, /dev/sdb2, /dev/sdb3, /dev/sdb5, /dev/sdb6, /dev/sdb7这六个，至于/dev/sdb4这个延伸分区本身
仅是提供来给逻辑分区创建之用。
P+E的环境：
图2.2.6、分区示意图
注意到了吗？因为1~4号是保留给主要/延伸分区的，因此第一个逻辑分区一定是由5号开始的！再次强调啊！ 所
以/dev/sdb3, /dev/sdb4就会被保留下来没有用到了！
MBR 分区表除了上述的主分区、延伸分区、逻辑分区需要注意之外，由于每组分区表仅有 16Bytes 而已，因此可纪录的信息真的是相
当有限的！ 所以，在过去 MBR 分区表的限制中经常可以发现如下的问题：
操作系统无法抓取到 2.2T 以上的磁盘容量！
MBR 仅有一个区块，若被破坏后，经常无法或很难救援。
MBR 内的存放开机管理程序的区块仅 446Bytes，无法容纳较多的程序码。
这个 2.2TB 限制的现象在早期并不会很严重。但是，近年来硬盘厂商动不对推出的磁盘容量就高达好几个 TB 的容量！目前 （2015）
单一磁盘最大容量甚至高达 8TB 了！ 如果使用磁盘阵列的系统，像鸟哥的一组系统中，用了 24 颗 4TB 磁盘搭建出磁盘阵列，那在 Linux 下面
就会看到有一颗 70TB 左右的磁盘！ 如果使用 MBR 的话...那得要 2TB/2TB 的割下去，虽然 Linux kernel 现在已经可以通过某些机制让磁盘分
区高过 63 个以上，但是这样就得要割出将近 40 个分区～ 真要命... 为了解决这个问题，所以后来就有 GPT 这个磁盘分区的格式出现了！
GUID partition table, GPT 磁磁盘盘分分区区表表[1]
因为过去一个扇区大小就是 512Bytes 而已，不过目前已经有 4K 的扇区设计出现！为了相容于所有的磁盘，因此在扇区的定义上面，
大多会使用所谓的逻辑区块位址（Logical Block Address, LBA）来处理。GPT 将磁盘所有区块以此 LBA（默认为 512Bytes 喔！） 来规划，
而第一个 LBA 称为 LBA0 （从 0 开始编号）。
与 MBR 仅使用第一个 512Bytes 区块来纪录不同， GPT 使用了 34 个 LBA 区块来纪录分区信息！同时与过去 MBR 仅有一的区块，被
干掉就死光光的情况不同， GPT 除了前面 34 个 LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为另一个备份！这样或许会比较安全些吧！
详细的结构有点像下面的模样：
图2.2.7、GPT 分区表的结构示意图
上述图示的解释说明如下：
LBA0 （MBR 相容区块）
与 MBR 模式相似的，这个相容区块也分为两个部份，一个就是跟之前 446 Bytes 相似的区块，储存了第一阶段的开机管理程序！
而在原本的分区表的纪录区内，这个相容模式仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式之意。而不懂 GPT 分区表的磁
盘管理程序， 就不会认识这颗磁盘，除非用户有特别要求要处理这颗磁盘，否则该管理软件不能修改此分区信息，进一步保护了此磁盘
喔！
LBA1 （GPT 表头纪录）
这个部份纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区 （就是前面谈到的在最后 34 个 LBA 区块） 放置的位
置， 同时放置了分区表的检验机制码 （CRC32），操作系统可以根据这个检验码来判断 GPT 是否正确。若有错误，还可以通过这个纪
录区来取得备份的 GPT（磁盘最后的那个备份区块） 来恢复 GPT 的正常运行！
LBA2-33 （实际纪录分区信息处）
从 LBA2 区块开始，每个 LBA 都可以纪录 4 笔分区纪录，所以在默认的情况下，总共可以有 4*32 = 128 笔分区纪录喔！因为每
个 LBA 有 512Bytes，因此每笔纪录用到 128 Bytes 的空间，除了每笔纪录所需要的识别码与相关的纪录之外，GPT 在每笔纪录中分别
提供了 64bits 来记载开始/结束的扇区号码，因此，GPT 分区表对于单一分区来说， 他的最大容量限制就会在“ 264 * 512Bytes = 263 *
1KBytes = 233*TB = 8 ZB ”，要注意 1ZB = 230TB 啦！ 你说有没有够大了？
现在 GPT 分区默认可以提供多达 128 笔纪录，而在 Linux 本身的核心设备纪录中，针对单一磁盘来说，虽然过去最多只能到达 15 个分
区，不过由于 Linux kernel 通过 udev 等方式的处理，现在 Linux 也已经没有这个限制在了！ 此外，GPT 分区已经没有所谓的主、延伸、逻辑
分区的概念，既然每笔纪录都可以独立存在， 当然每个都可以视为是主分区！每一个分区都可以拿来格式化使用喔！
Tips
鸟哥一直以为核心认识的设备主要/次要号码就一定是连续的，因此一直没有注意到由于新的机制的关系，分区已经可以突破核心限制的状况！
感谢大陆网友微博代号“学习日记博客”的提醒！此外，为了查询正确性，鸟哥还真的有注意到网络上有朋友实际拿一颗磁盘分区出 130 个以上的分区，
结果他发现 120 个以前的分区均可以格式化使用，但是 130 之后的似乎不太能够使用了！或许跟默认的 GPT 共 128 个号码有关！
虽然新版的 Linux 大多认识了 GPT 分区表，没办法，我们 server 常常需要比较大容量的磁盘嘛！不过，在磁盘管理工具上面， fdisk 这
个老牌的软件并不认识 GPT 喔！要使用 GPT 的话，得要操作类似 gdisk 或者是 parted 指令才行！这部份我们会在第二篇再来谈一谈。 另
外，开机管理程序方面， grub 第一版并不认识 GPT 喔！得要 grub2 以后才会认识的！开机管理程序这部份则第五篇再来谈喔！
并不是所有的操作系统都可以读取到 GPT 的磁盘分区格式喔！同时，也不是所有的硬件都可以支持 GPT 格式喔！是否能够读写 GPT
格式又与开机的检测程序有关！ 那开机的检测程序又分成啥鬼东西呢？就是 BIOS 与 UEFI 啦！那这两个又是啥东西？就让我们来聊一聊！
我们在计算机概论里面谈到了，没有执行软件的硬件是没有用的，除了会电人之外...， 而为了计算机硬件系统的资源合理分配，因此有
了操作系统这个系统软件的产生。由于操作系统会控制所有的硬件并且提供核心功能， 因此我们的计算机就能够认识硬盘内的文件系统，并且
进一步的读取硬盘内的软件文件与执行该软件来达成各项软件的执行目的。
问题是，你有没有发现，既然操作系统也是软件，那么我的计算机又是如何认识这个操作系统软件并且执行他的？ 明明开机时我的计算
机还没有任何软件系统，那他要如何读取硬盘内的操作系统文件啊？嘿嘿！这就得要牵涉到计算机的开机程序了！ 下面就让我们来谈一谈这个
开机程序吧！
基本上，目前的主机系统在载入硬件驱动方面的程序，主要有早期的 BIOS 与新的 UEFI 两种机制，我们分别来谈谈啰！
BIOS 搭搭配配 MBR/GPT 的的开开机机流流程程
在计算机概论里面我们有谈到那个可爱的BIOS与CMOS两个东西， CMOS是记录各项硬件参数且嵌入在主板上面的储存器，BIOS则是
一个写入到主板上的一个固件（再次说明， 固件就是写入到硬件上的一个软件程序）。这个BIOS就是在开机的时候，计算机系统会主动执行
的第一个程序了！
接下来BIOS会去分析计算机里面有哪些储存设备，我们以硬盘为例，BIOS会依据使用者的设置去取得能够开机的硬盘， 并且到该硬盘
里面去读取第一个扇区的MBR位置。 MBR这个仅有446 Bytes的硬盘容量里面会放置最基本的开机管理程序， 此时BIOS就功成圆满，而接下
来就是MBR内的开机管理程序的工作了。