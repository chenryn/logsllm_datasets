**作者：启明星辰ADLab  
原文链接：**
### 一、漏洞背景
近日，国外安全研究人员披露一个Linux eBPF
verifier组件错误验证漏洞，此漏洞源于bpf验证系统在Linux内核中没有正确计算某些操作的寄存器边界跟踪，导致本地攻击者可以利用此缺陷进行内核信息泄露或特权提升，该漏洞编号为CVE-2020-27194。
### 二、影响范围与防护措施
**影响范围**
  * Linux-5.7 ~ Linux-5.8.14
  * Ubuntu 20.10
**防护措施**
  * 及时更新升级内核
  * 将kernel.unprivileged_bpf_disabled.sysctl设置为1，临时限制普通用户权限
### 三、漏洞原理与调试分析
**漏洞原理**
该漏洞和Pwn2own2020比赛中使用的CVE-2020-8835漏洞原理一致，均是错误计算了寄存器边界跟踪，导致可以绕过验证器检查达到越界读写。缺陷代码出现在kernel/bpf/verifier.c的scalar32_min_max_or()函数中，该函数是在commit_id：3f50f132d840中引入的，该功能实现了显式的ALU32(32位计算类操作)寄存器边界跟踪，处理OR运算时，调用scalar32_min_max_or()函数进行32位寄存器边界跟踪，该函数实现如下：
行5365和行5366，直接将dst_reg寄存器中的64位无符号值赋值给32位有符号值，这明显是错误的。例如设置dst_reg->umin_value=1，dst_reg->umax_value=0x600000001，当进行如上操作后，dst_reg->s32_min_value为1，但是dst_reg->s32_max_value也将是1，因为0x600000001的高位将被截断，这时dst_reg寄存器的范围从[1,0x600000001]变成了[1,1]，这会被验证器识别为常数1，进而绕过验证器检查。漏洞补丁中，进行了正确的32位有符号值赋值操作，如下所示：
**调试分析**
首先将寄存器的umin_value设置为0x1，可以通过如下BPF指令实现：
此时寄存器的状态如下所示：
设置完umin_value后，设置umax_value为0x600000001，可以通过如下BPF指令实现：
断点命中后，调用栈如下所示：
执行完BPF_JMP_REG(BPF_JLT,BPF_REG_6,BPF_REG_5,1)指令后，将R6寄存器范围设置为0x1到0x600000001之间。R6寄存器状态如下所示：
接着设置R6寄存器中32位的无符号最小值和最大值，
设置完之后，R6寄存器状态如下所示：
红框中设置的值是必须要保证的，需要提前进行设置，方便后面绕过if判断进入缺陷代码块中。接着设置R6寄存器32位有符号最小值和最大值，代码如下所示：
行5355，if语句判断不成立，会走到行5362分支中，调试情况如下所示：
触发漏洞后，R6寄存器状态如下：
此时s32_min_value和s32_max_value都为0x1，在验证器中，R6寄存器的32位有符号取值为常数1。但R6寄存器的取值实际是有范围的。接着将R6寄存器进行32位MOV到R7寄存器中，执行到如下代码所示：
此时，src_reg寄存器如下所示：
执行MOV操作之前，R7寄存器状态如下所示：
执行MOV操作后，R7寄存器状态如下所示：
R7寄存器为常量1，实际运行情况下是有范围的，可以设置为2。 执行BPF_ALU64_IMM(BPF_RSH,BPF_REG_7,1)后，即R7 >>=
1，R7寄存器如下所示：
此时umin_value和umax_value为0，即为R7寄存器进行右移操作后，在验证器中被识别为常数0，此时R7寄存器进行加减运算都不会发生越界，绕过了验证器的边界检查。但是如果R7寄存器实际设置为2，2>>1为1，R7寄存器为1，此时和R7寄存器进行加减运算，达到越界读写。
### 四、漏洞复现
在Linux-5.7.7版本中进行漏洞利用，成功提权。
### 五、参考链接
* * *