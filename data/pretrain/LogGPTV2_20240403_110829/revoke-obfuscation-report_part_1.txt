Revoke-­‐Obfuscation: PowerShell
Obfuscation Detection Using Science
Daniel Bohannon @danielhbohannon | Lee Holmes @Lee_Holmes
Revoke-­‐Obfuscation is the result of industry research collaboration between Daniel Bohannon -­‐ Senior
Applied Security Researcher at Mandiant/FireEye, and Lee Holmes – Lead Security Architect of Azure
Management at Microsoft.
Background
By far the most prevalent delivery and execution vehicle for malware in the industry today is basic
malicious executables and malicious documents. While not represented accurately by its popularity in
the news, a small portion of the current malware ecosystem leverages PowerShell as part of its attack
chain. Of malware that uses PowerShell, the most prevalent use is the garden-­‐variety stager: an
executable or document macro that launches PowerShell to download another executable and run it.
Despite its relative statistical rarity, development of malicious and offense-­‐focused PowerShell
techniques has been a rich field of innovation. Commercial products have started to react to these
techniques in several ways. Because they are often delivered as script files, Antivirus vendors have long
had the ability to write signatures that block malicious PowerShell scripts. With the release of Windows
10, some vendors have additionally begun to implement support for Windows’ Antimalware Scan
Interface. This interface gives Antivirus vendors the ability to implement deep content scanning,
providing visibility as each stage of malware fetches and dynamically executes new instructions from a
remote network location.
In addition to antivirus signatures, many SIEM vendors have started to implement alerting based on
command-­‐line parameters that are frequently used in malicious contexts. Palo Alto provides an
excellent survey of commonly-­‐used malicious PowerShell command-­‐line arguments in their post, Pulling
Back the Curtains on EncodedCommand PowerShell Attacks.
As with any ecosystem, parts of the malicious and offense-­‐focused community have started to adapt
their tooling to avoid signature-­‐based detections. Part of this response has come through an increased
use of content obfuscation – a technique long employed at both the binary and content level by
traditional malware authors.
In the Wild: FIN8
One example of threat actors using obfuscation techniques in the wild is FIN8, a financially-­‐motivated
targeted attacker. They use a handful of techniques to avoid traditional static detection.
Mandiant provides an excellent overview of FIN8’s use of obfuscation in their post, Obfuscation in the
Wild: Targeted Attackers Lead the Way in Evasion Techniques.
Before You Begin
Detecting obfuscated PowerShell requires that you have set up your environment to collect and process
PowerShell logs. The three primary steps you should take are:
1) Process Auditing and Command Line Logging. Event ID 4688 on Windows gives you access to
the command-­‐line arguments used when processes are launched, such as the –
EncodedCommand argument to PowerShell.exe. The OS capabilities required to support this
feature were added to Windows 8.1 and Windows 2012r2, but can also be added by installing
KB3004375. Another useful source of this data is Sysmon.
2) PowerShell Module, Script Block, and Transcription Logging. You can configure PowerShell to
log all commands that it invokes, as well all script blocks that it invokes. As with the content
stream exposed to the Antimalware Scan Interface, this logging also includes code generated or
transformed at runtime. You can learn more about PowerShell’s logging capabilities from the
PowerShell Blog, PowerShell (cid:0) the Blue Team.
3) Centralized Event Log Collection / Forwarding. There are many techniques to collect and
forward event logs across an organization. An excellent introduction, using Windows Event
Forwarding, can be found at: Monitoring what matters -­‐ Windows Event Forwarding for
everyone (even if you already have a SIEM).
Most detection that attempts to uncover malicious use of PowerShell does so today by taking these two
major event sources and applying static signatures to them. This is usually simple string matches and
regular expressions.
Invoke-­‐Obfuscation: A Treatise on the Folly of Static Signatures
The most common focus for the detection of malicious PowerShell is the initial download cradle. One
example of this could be script in a malicious Office document that runs PowerShell to download and
launch additional malware components.
Many have written regular expressions to try to detect these, but there are challenges with this
approach.
Launch Techniques
Some organizations and SIEM vendors rely entirely on command-­‐line logging (4688) event rather than
PowerShell script block logs (4104) to detect malicious PowerShell. If the process name is “PowerShell”
and the command-­‐line arguments match some specific patterns, they flag that input as malicious.
There are two main ways that attackers can avoid this form of 4688-­‐based command line logging:
obscuring the name of the PowerShell executable, and breaking the link between PowerShell and the
code it invoked as viewed from the command line logs.
To obscure the name of the PowerShell executable, some attackers will create (or include) a copy of
PowerShell.exe, but rename it to something less suspicious – such as Firefox.exe, or Chrome.exe. The
4688 command line logs, then, would show something similar to:
After obscuring the name of the launching executable, the second primary mechanism to break 4688-­‐
based logging is to unlink the command-­‐line arguments from the code they deliver. An example of this
comes from PowerShell’s (like most management / automation programs) ability to consume commands
from the Standard Input stream.
Two examples of this are:
When viewed in the event log, the arguments to PowerShell.exe are no longer directly visible:
For some of these launch techniques, reviewing the command line arguments of the parent process can
be fruitful:
However, when this technique is chained several times, you must correlate several layers of process
command lines to understand the code that was invoked.
Another technique, employed by the Kovter family of malware and others, is to store the malicious
PowerShell commands in an environment variable and have PowerShell execute the content of that
variable. Malwarebytes Labs gives an example of this approach in their post, Untangling Kovter.
The content of the variable is a base64 encoded PowerShell script:
In addition to storing content in environment variables, it is also possible to deliver content so that
reassembling the command lines from the chain of parent processes offers little to no insight. For
example, one process could write a file while a second process – launched as a sibling process – reads
from it.
While these launch techniques do not evade PowerShell script block logging, they are challenging
behaviours to detect through command-­‐line logging alone.
Obfuscating the Cradle
In addition to evasions of process command line logging, obfuscation of the PowerShell script text itself
can prove very effective against static signature-­‐based detections. This is a common battle ground
between malware authors and antivirus vendors for all scripting languages, and this battle continues
when applied to PowerShell scripts.
For the purposes of discussion, we will focus on an example download cradle as well as the static
signatures that might be used to detect it.
An initial detection approach might attempt to match all of the following terms:
-­‐ Invoke-Expression
-­‐ New-Object
-­‐ System.Net.WebClient
-­‐ DownloadString(‘http
Most of the obfuscation techniques that follow are automatically countered by PowerShell’s script block
and module logging, as well as the Antimalware Scan Interface. However, they are very effective when
applied to content in transit – such as intercepted network requests, or files on disk.
-­‐ The URL is just a string, so can be concatenated and written in other ways such as “h” +
“ttp”. Additional string obfuscation techniques are covered below.
-­‐ System is optional in PowerShell type names, so System.Net.WebClient can be written as
Net.WebClient
-­‐ PowerShell can use either single or double quotes in strings. Whitespace can be added almost
anywhere, so DownloadString(‘ could just as easily be written as DownloadString( “
-­‐ The WebClient class offers many methods to download content in addition to DownloadString,
such as DownloadFile, DownloadData, and OpenReadAsync
-­‐ Method names such as DownloadString can be included in quotes and have escape characters
included to create a syntax like
System.Net.WebClient).”`D`o`wn`l`oa`d`Str`in`g”. Because it can be treated
as a string, string-­‐based obfuscation techniques such as concatenation and reordering can also
be used on the method name.
-­‐ Similar to method names, the Net.WebClient argument to New-­‐Object can be obfuscated
with escape characters, string-­‐based obfuscation techniques, and concatenation across multiple
variables. That can produce a result like: $var1="`N`et.";
$var2="`W`eb`C`l`ient"; (New-Object $var1$var2)
-­‐ PowerShell command names often have aliases. For example, Invoke-­‐Expression can also be
referred to as iex.
-­‐ Even when commands do not have aliases, the Get-Command command lets a script author
query the PowerShell command list and invoke the result. This query can include wildcards, so
invoking New-­‐Object can look like this: & (Get-Command *w-O*). The invocation (&)
operator in this example has an alternative, which is the dot (.) operator. The Get-­‐Command
cmdlet has an alias and can be dynamically invoked similarly, so is not safe to key on.
-­‐ In addition to Get-­‐Command as a mechanism to query command names, PowerShell offers
several API-­‐style methods to query command names – such as
$executionContext.InvokeCommand.GetCommand().
-­‐ The invocation (& and .) operators support string arguments. These can be easily obscured
using obfuscation techniques such as string concatenation and string reordering.
-­‐ Detection of Invoke-­‐Expression suffers from the same challenges of command obfuscation that
New-­‐Object and Get-­‐Command suffer from. It is also popular in non-­‐malicious contexts, making
false positives based on this indicator a significant challenge.
-­‐ Invoke-­‐Expression is not the only cmdlet or technique that can be used to invoke dynamically-­‐
generated code. Other alternatives are Invoke-Command, Script Block invocation (such as &
[Scriptblock]::Create("Write-Host Script Block Conversion") ), and
dynamic script invocation APIs such as
$ExecutionContext.InvokeCommand.InvokeScript("Write-Host
EXPRESSION").
String Obfuscation
Anything that allows a string as an argument can be obfuscated using string obfuscation techniques.
-­‐ String concatenation is a common way to break up identifiable strings. If a signature is written
for the term, “http”, it can also be written as “h” + “ttp”. The most common form of
concatenation is the ‘+’ operator, but PowerShell’s –join operator can also be used. In
addition to PowerShell techniques, the String.Join() and String.Concat() methods
from .NET can accomplish the same goals.
-­‐ PowerShell’s –f string formatting operator, based on the C# String.Format method, can
create strings at runtime. The format operator uses format tokens like {0} and {1} to identify
the order of replacement strings, so obfuscating the invocation of New-­‐Object might look like
this with format operator obfuscation applied: & ("{1}{0}{2}" -f 'w-
Ob','Ne','ject').
-­‐ Strings can be reversed through several mechanisms, such as PowerShell’s array slicing operator
(-join "detacsufbO"[9..0]), Array.Reverse ($a = [char[]]"detacsufbO";
[Array]::Reverse($a); -join $a), reverse regular expression matching (-join
[RegEx]::Matches("detacsufbO",'.','RightToLeft')), and others.
-­‐ Strings can be split by an arbitrary delimiter, and then rejoined: -join
("Obf~~usc~~ated" -split "~~")
-­‐ Through the –replace operator or the String.Replace() method, strings can be
replaced either to remove delimiters, or change the meaning of a string:
"System.SafeClass" -replace "Safe","Unsafe"
While this depth of obfuscation may seem unlikely in reality, several automated toolkits exist today that
can apply these techniques automatically. Two examples of this are ISE Steroids and Invoke-­‐Obfuscation.
Each will take any PowerShell content and return an obfuscated version of that content. For example,
the automated obfuscation of the example download cradle above can generate the following result,
among many possible options:
The output of both toolkits have been observed in obfuscated malware in the wild.
Changing the Cradle
Up to this point, we’ve discussed the many ways to obfuscate a simple, static, well-­‐known download
cradle. As touched on in the discussion of detecting the DownloadString() method, there are an
enormous number of alternate ways to accomplish the goal of downloading and executing code.
A sister project to Invoke-­‐Obfuscation, Invoke-­‐CradleCrafter automates the generation of obscure or
esoteric download cradles. Here is one example:
As mentioned earlier, PowerShell module and script block logging unravels most of these obfuscation
techniques. Here’s an example of obfuscation that goes through three stages of de-­‐obfuscation while
running:
However, the range of obfuscation opportunities available to attackers paints a very bleak picture when
it comes to detecting malicious PowerShell.
Detecting Obfuscated PowerShell
While the situation may appear dire when it comes to detecting malicious PowerShell due to the vast
range of obfuscation opportunities, in fact the opposite is true. This very mix of obfuscation-­‐fueled
obscurity is an incredibly strong signal that we can use to convert this cloak of invisibility into a blazing
beacon of detection.