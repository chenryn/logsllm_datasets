近期同事遇到一个金融站点的前端加签验证问题，找到本菜鸡一起帮忙分析。经过测试发现，客户端每次请求都会对数据包进行加签，然后服务端会对数据包进行验签。  
解决大概思路：确定加签关键字->分析前端代码获取加签算法->使用burpy插件调用前端加密函数自动对数据包进行加签操作  
Burpy：一款burp插件，可自定义python脚本对数据包进行加解密。
  1. 确定加签关键字  
开局一个登录框  
通过测试得知，服务端会对每个请求数据包的"_msgid"和"_sign"参数进行验签，一但数据包被修改或者重复发送相同数据包，服务端则会返回"验证签名失败！"  
  2. 分析js获取加签算法  
首先F12全局搜索查找"_msgid"的生成算法  
找到对应的uuid()算法逻辑  
把js加密代码抠出来复制到sign.js文件  
使用python的execjs模块调用sign.js的uuid函数,编写demo测试没问题，加签字段"_msgid"搞定  
接下来分析加签字段"_sign"的加密逻辑，通过sign关键字定位到getSign函数  
此处对前端代码进行调试，得知传入的参数requestObject为字典格式,通过对字典数据进行处理后得到参数"sb"的值，最终将"sb"的值MD5加密后得到加签字段"_sign"的值  
"_sign"的大致加密逻辑有了，那么就需要查看前端调用栈来查看传入参数"requestObject"的字典数据是如何生成的。  
分析后得知"requestObject"由两部分组成，一部分为不固定参数，根据业务功能点不同传入不同的参数字典，另一部分为固定参数token、msgid、app_id、redisIdBindCustno添加到字典数据的尾部，然后传入getSign获取加签参数"_sign"的值  
  3. 编写加签脚本  
大致的加签数据生成流程已经理清楚，接下来就需要编写burpy脚本搞定"_sign"加签参数，首先把getSign()函数的加密算法抠出来复制到sign.js文件中  
编写脚本调用sign函数获取加签参数"_msgid、_sign"的值，从而实现自动化对数据包进行加签。(注意：传入的encrypt函数的body为str类型，返回时也必须为str类型)  
接下来可以开启burpy插件，即可自动替换数据包中的加签参数