Circuit
The public statement of the universal circuit Cuniv itself
includes the speciﬁcation of the custom circuit, the custom
statement, r1 and r2. In other words, the statement of the
universal circuit will be the following set of wires (Ispec ∪
IZio ∪ IR). The set J in Protocol 2 will be equal to IZw ∪ IZ(cid:48).
Protocol 3 A zk-SNARK for Cuniv
Setup:
• Universal
PARAMETERS ←
PARAMGEN(C ,1λ) This phase generates a uni-
versal circuit Cuniv
the operations
of any circuit C ∈ C . The key generation phase
PARAMGEN(C ,1λ) will call the setup algorithm in
Protocol 2 {vrkCuniv ,prkCuniv} ← Setup(Cuniv,1λ), while
setting J = IZw ∪ IZ(cid:48),I = Iaux, i.e.,
Choose α,β,γ,δ,δ(cid:48),s ← Fq. Construct the public proving
key prkCuniv as follows:
1 ,gβ
that captures
2
1 ,gδ(cid:48)
◦ gα
1 ,gβ
2 ,gδ
1 ,gδ
1 }i∈{0,..,d−1},{gsi
◦ {gsi
◦ {gsit(s)/δ
}i∈{0,..,d−2}
◦ {g(βvk(s)+αwk(s)+yk(s))/δ(cid:48)
◦ {g(βvk(s)+αwk(s)+yk(s))/δ
1
1
1
2 }i∈{0,..,d−1}
}k∈IZw∪IZ(cid:48)
}k∈Iaux
Construct the veriﬁcation key vrkCuniv as
1 ,gβ
2 ,gγ
1 ,gβ
◦ gα
◦ {g(βvk(s)+αwk(s)+yk(s))/γ
2 ,gδ(cid:48)
2,gδ
2
1
}k∈Ispec∪IZio∪IR
Set PARAMETERS = {vrkCuniv,prkCuniv}
• Derive (Custom circuit Speciﬁcation):
{VRKC, PRKC} ← DERIVE(C, PARAMETERS)
A party sets the values of each li and l(cid:48)
i (besides any func-
tionality selectors in the general case) according to the
speciﬁcation of the custom circuit C. The party then com-
putes vrkC based on the items in vrkCuniv. More speciﬁcally,
vrkC will include the following,
USENIX Association
29th USENIX Security Symposium    2143
Table 6: The functionalities corresponding to the opcodes described in Section 5, Figures 2 and 3
Opcode
Opcode 1
Opcode 2
Opcode 3
Opcode 4
Supported Operations
- Arithmetic and Boolean Operations: Multiplication (AND), Addition, Subtraction, XOR, OR.
- Conditionals: Equality/non-equality testing.
- Bitwise operations on 32-bit words (XOR, OR, AND).
- Verifying constraints on ranges (Useful for comparisons, mod/division operations, etc).
- Bit extraction, Packing bits into one 32-bit values, or bytes.
- Weighted sums of bits or native elements (This supports bitwise rotation and shifting using static parameters).
- Random memory access: Reading from or writing to variable array indices.
2 ,gγ
1 ,gβ
1 ,gβ
– gα
– {g(βvk(s)+αwk(s)+yk(s))/γ
2,gδ
2 ,gδ(cid:48)
1
2 (Copied directly from vrkCuniv.)
}k∈IZio∪IR (Copied directly from
vrkCuniv.)
– vkspec = ∏
k∈Ispec
gck(βvk(s)+αwk(s)+yk(s))/γ
1
, where ck is the
value of the wire k in the universal circuit.
The derivation of vrkC does not need to happen in a
trusted manner. It will be straightforward to verify the
computation of the ﬁrst set in linear time. The prov-
ing key of the custom circuit C will be the same as the
proving key of the universal circuit besides vkspec, i.e.,
prkC = prkCuniv ∪{vkspec}.
• Prove π ← PROVE(C,{zi}i∈{1,..,ns+3n∗+3n+}, PRKC):
– The prover samples three random values κ1, κ2 and κ3
from Fq. κ1 and κ2 will be later used as in the original
version of the protocol for zero-knowledge, and κ3 will
be used to make our commitment zero-knowledge.
– The prover commits to the values of {zi} and its per-
i}, via computing:
gck(βvk(s)+αwk(s)+yk(s))/δ(cid:48)
gck(βvk(s)+αwk(s)+yk(s))/γ
mutation {z(cid:48)
◦ cm1 = ∏
k∈IZw∪IZ(cid:48)
◦ cm2 = ∏
k∈IZio
◦ cm = gδκ3
1 cm1cm2
1
1
– The prover computes the random values r1 and
r2 using the previous commitment, e.g., r1 =
Hash(0||vkspec||cm) and r2 = Hash(1||vkspec||cm),
and continues evaluating the circuit. The prover then
computes h(x) = p(x)
◦ πa = gα+v(s)+κ1δ
◦ πb = gβ+w(s)+κ2δ
◦ πc = gh(s)t(s)/δ
a Bκ1
πκ2
t(x) , and computes the proof as:
1 g−κ1κ2δ−κ3δ(cid:48)
X
1
2
1
1
◦ πd = gδκ3
1 ∏
k∈IZw∪IZ(cid:48)
gck(βvk(s)+αwk(s)+yk(s))/δ(cid:48)
1
wires in the circuit).
where
◦ v(x) = ∑k∈{0,..,m} ckvk(x) (m is the total number of
◦ w(x) = ∑k∈{0,..,m} ckwk(x)
◦ B1 = gβ+w(s)+κ2δ
◦ X = ∏
k∈Iaux
gck(βvk(s)+αwk(s)+yk(s))/δ
1
1
• Verify {0,1} ← VERIFY({zi}i∈{1,..,ns},π, VRKC):
– First, the veriﬁer computes the IO component of the
commitment: ψ = ∏
k∈IZio
gck(βvk(s)+αwk(s)+yk(s))/γ
.
1
– The veriﬁer computes the commitment: cm = ψ.πd.
– The veriﬁer then computes the random values r1
and r2 using the previous commitments, i.e., r1 =
Hash(0||vkspec||cm) and r2 = Hash(1||vkspec||cm),
and computes ν = ∏
k∈IR
gck(βvk(s)+αwk(s)+yk(s))/γ
.
1
– The veriﬁer then does the following check:
e(πa,πb) = e(gα
1 ,gβ
2 )e(vkspec.ν.ψ,gγ
2)e(πc,gδ
2 )e(πd,gδ(cid:48)
2 )
1 ,gβ
Note that e(gα
2 ) can be hardcoded in advance. The total
number of pairings done by the veriﬁer for each instance is 4
pairings, and the proof size is 3 elements in G1 and 1 element
in G2, i.e. our protocol adds 1 element to the proof and 1
pairing to the veriﬁcation equation.
B Multi-opcode Circuit (Supplementary)
Figures 2 and 3 illustrates the detailed design of the multi-
opcode circuit presented in Section 5. Table 6 illustrates which
basic operations each opcode can be used to verify.
2144    29th USENIX Security Symposium
USENIX Association
Setup Parameters
Universal Circuit Detailed Description (1/2)
• ns: Number of entries (li,zi) representing the public statement.
• {n j}: Number of times each opcode j appears in the circuit, 1 ≤ j ≤ 4.
• {u j}: Number of entries used by each opcode j, 1 ≤ j ≤ 4.
Circuit input
• Statement entries: (li,zi) for all i ∈ {1,2, . . . ,ns}.
• Operation entries: (li,zi) for all i ∈ {ns + 1,ns + 2, . . . ,ns + ∑ j≤4 n ju j}.
• Permuted entries: (l(cid:48)
i ,z(cid:48)
• Random values: r1, r2
• Functionality selectors as speciﬁed for each instruction (set during computation speciﬁcation)
• Memory consistency subcircuit witnesses
i) for all i ∈ {1,2, ...,ns + ∑ j≤4 n ju j}.
OpCode 1 (Generic Opcode) (repeated n1 times, u1 = 3)
• Operates on: ((li,zi), (li+1,zi+1), (li+2,zi+2)) for all i ∈ {ns + 1,ns + 4, ...,ns + n1u1 − 2}
• Functionality selectors for each instruction (instruction indices omitted for brevity) :
– Coefﬁcient vector: (c1,c2,c3,c4,c5,c6,c7), where c j ∈ Fq for all j
– Operation bit selectors: {opeq,op1,op2,usePrev}
• Circuit:
– Compute t1 = (c1 + c2zi)(c3 + c4zi+1) + c5
– Compute t2 = (c1 + c2zi) + (c3 + c4zi+1) + c5
– Compute t3 = (zi ==? zi+1), t4 = 1−t3
– Compute k1 = t2 + op1 · (t1 −t2)
– Compute k2 = t4 + op1 · (t3 −t4)
– Compute result1 = k1 + opeq · (k2 − k1)
– Compute t5 = result1 · (c6 + zi−1) + c7
– Compute t6 = result1 + (c6 + zi−1) + c7
– Compute result2 = t6 + op2 · (t5 −t6)
– Assert usePrev· (result2 − result1) = (zi+2 − result1)
• Usage notes: The coefﬁcient set can be chosen to support various operations, e.g., for multiplication, op1 = c2 = c4 = 1, the rest are
zeros; for xor (assuming that zi are bits), op1 = c2 = c3 = 1, c4 = −2, c1 = −2−1,c5 = 2−1, the rest are zeros.
OpCode 2 (Bitwise Operations) (repeated n2 times, u2 = 3)
• Operates on: ((li,zi), (li+1,zi+1), (li+2,zi+2)) for all i ∈ {ns + ∑ j<2 n ju j + 1,ns + ∑ j<2 n ju j + 4, ..,ns + ∑ j≤2 n ju j − 2}
• Functionality selectors for each instruction (instruction indices omitted for brevity)
– Operation selectors: op a vector of 12 bits. (Only one of them will be active during run time. See Section 5.2)
• Circuit:
– Extract bit vectors b1, b2 from zi and zi+1 (assuming 32 is the bit length)
– Compute b = b1 (cid:12) b2 ((cid:12) refers to the Hadamard product)
– (AND-bitwise cases) Compute a1 = pack32(b),a2 = pack32(b2 − b),a3 = pack32(b1 − b),a4 = pack32(1− b1 − b2 + b)
– (XOR-bitwise cases) Compute x1 = pack32(b1 + b2 − 2b),x2 = pack32(1− b1 − b2 + 2b),x3 = x2,x4 = x1
– (OR-bitwise cases) Compute o1 = pack32(b1 +b2−b),o2 = pack32(1−b1 +b),o2 = pack32(1−b2 +b),o4 = pack32(1−b)
– Assert
zi+2 = op· (a1,a2,a3,a4,x1,x2,x3,x4,o1,o2,o3,o4)
• Other modes: This opcode also behaves similar to opcode 1 supporting native operations when needed (details omitted)
Figure 2: A detailed description of our universal circuit with multiple opcodes (Part 1). See Section 5 and Table 6 for an intuition
and high-level description for each opcode circuit design. Note: Functionality selector inputs are added to the specC vector
(Section 4), and set at the computation speciﬁcation stage.
USENIX Association
29th USENIX Security Symposium    2145
OpCode 3 (Split/Pack Operations) (repeated n3 times, u3 = 38)
• Operates on the following (for all i ∈ {ns + ∑ j<3 n ju j + 1,ns + ∑ j<3 n ju j + 39, ..,ns + ∑ j≤3 n ju j − 37} ):
Universal Circuit Detailed Description (2/2)
– Element (Bit) vector:
e = ((li,zi), (li+1,zi+1), ..., (li+31,zi+31))
– Byte vector: ((li+32,zi+32), (li+33,zi+33), ..., (li+35,zi+35))
– Packed elements: ((li+36,zi+36), (li+37,zi+37))
• Functionality selectors for each instruction (instruction indices omitted for brevity)
– Force bit assertions: checkb
– Coefﬁcient vector 1: s1 = (c1,1,c1,2, ...,c1,32)
– Coefﬁcient vector 2: s2 = (c2,1,c2,2, ...,c2,32)
• Circuit:
– Assert z j(1− z j)checkb = 0 for all i ≤ j ≤ i + 31
– Assert zi+36 = e· s1, Assert zi+37 = e· s2
– Assert zi+32+ j = ∑k∈{1+8 j,...,8+8 j} c1,k.zi+k−1 for all j ∈ {0,1,2,3}
• Usage notes: Packing or splitting into bits can be done by setting s1 to contain powers of two, and setting checkb = 1. Shifting and
rotation (static parameters) can be done by setting s2 to be a permutation of powers of two.
• Other modes: This opcode can be used to compute weighted sums of native ﬁeld elements.
OpCode 4 (Runtime memory access) (repeated n4 times, u4 = 3)
• Operates on: ((li,zi), (li+1,zi+1), (li+2,zi+2)) for all i ∈ {ns + ∑ j<4 n ju j + 1,ns + ∑ j<4 n ju j + 4, ..,ns + ∑ j≤4 n ju j − 2}
• Circuit:
– Parse zi,zi+1,zi+2 as isW ritek, indexk, valuek, for all k = (i− (ns + ∑ j<4 n ju j + 1))/3
– Add the tuple reck = (opCounterk = k, isW ritek, indexk, valuek) to the memory consistency check circuit
Memory consistency check circuit
• The subcircuit operates on the tuples reck for all k = {0,1, ..,n4 − 1} deﬁned in OpCode 4.
• The subcircuit accepts additional witness inputs from the prover rec(cid:48)
k = (opCounter(cid:48)
{0,1, ..,n4 − 1}. (Note that the prover will commit to this input in the ﬁrst stage before knowing the randomness)
• Permutation Veriﬁcation:
k,isW rite(cid:48)
k,index(cid:48)
k,value(cid:48)
k) for all k =
– Compute p1 = ∏k(r2 − (1,r1,r2
– Compute p2 = ∏k(r2 − (1,r1,r2
– Assert p1 = p2
1,r3
1,r3
1)· reck)
1)· rec(cid:48)
k)
• Consistency Veriﬁcation: This applies the memory consistency checks similar to TinyRAM [3].
Global consistency checks across the universal circuit
• Permutation Veriﬁcation:
– Compute p1 = ∏i(r2 − (zi + lir1)) for all i ∈ {1,2, ..,ns + ∑ j≤4 n ju j}
– Compute p2 = ∏i(r2 − (z(cid:48)
ir1)) for all i ∈ {1,2, ..,ns + ∑ j≤4 n ju j}
– Assert p1 = p2
i + l(cid:48)
• Consistency Veriﬁcation:
– Assert (1− (l(cid:48)
i − l(cid:48)
i−1))(z(cid:48)
i − z(cid:48)
i−1) = 0 for all i ∈ {2,3, ..,ns + ∑ j≤4 n ju j} (Note since l(cid:48)
will be sorted and increasing by steps of 1.)
i are set by the computation speciﬁer, they
Figure 3: A detailed description of our universal circuit with multiple opcodes (Part 2). See Section 5 and Table 6 for an intuition
and high-level description for each opcode circuit design. Note: Functionality selector inputs are added to the specC vector
(Section 4), and set at the computation speciﬁcation stage.
2146    29th USENIX Security Symposium
USENIX Association