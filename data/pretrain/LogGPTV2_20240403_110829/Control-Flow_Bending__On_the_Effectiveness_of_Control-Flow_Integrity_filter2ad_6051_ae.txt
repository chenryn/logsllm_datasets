tem that the user could. This program is a demonstration
that on some programs, CFI provides essentially no value
due to the expressiveness of the original application.
This is one of the most difﬁcult cases for CFI. The
only value CFI adds to a binary is restricting it to its
CFG: however, when the CFG is easy to traverse and
gives powerful functions, CFI adds no more value than
a system call ﬁlter.
7.2.4 Evaluation of wireshark
An attacker who controls memory can write to any ﬁle
that the current user has access to. This gives power
equivalent to arbitrary code execution by, for example,
overwriting the authorized keys ﬁle. This is possible
because wireshark can save traces, and an attacker who
controls memory can trivially overwrite the ﬁlename be-
ing written to with one the attacker picks.
If the attacker waits for the user to click save and sim-
ply overwrites the ﬁle argument, this would be a data-
only attack under our deﬁnitions. It is also possible to
use control-ﬂow bending to invoke file save as cb()
directly, by returning into the GTK library and overwrit-
ing a code pointer with the ﬁle save method, which is
within the CFG.
7.2.5 Evaluation of xpdf
Similar to wireshark, an attacker can use xpdf to write
to arbitrary ﬁles using memcpy() as a dispatcher gadget
when there is no shadow stack. When a shadow stack is
present, we are limited to a printf-oriented programming
attack and we can only write ﬁles with speciﬁc exten-
sions, which does not obviously give us ability to run
arbitrary code.
7.2.6 Evaluation of mysql
When no shadow stack is present, attacks are trivial.
A dispatcher gadget lets us return into do system(),
do exec(), or do perl() from within the mysql client.
(For this attack we assume a vulnerable client to connects
to a malicious server controlled by the attacker.) When a
shadow stack is present the attacker is more limited, but
we still can use printf-oriented programming to obtain
arbitrary computation on memory. We could not obtain
arbitrary execution with a shadow stack.
7.3 Combining attacks
As these six case studies indicate, control-ﬂow bending
is a realistic attack technique. In the ﬁve cases where CFI
does not immediately stop the exploit from occurring, as
it does for Apache, an attacker can use the vulnerabil-
ity to achieve arbitrary writes in memory. From here, it
is possible to mount traditional data-only attacks (e.g.,
by modifying conﬁguration data-structures). We showed
that using control-ﬂow bending techniques, more power-
ful attacks are possible. We believe this attack technique
is general and can be applied to other applications and
vulnerabilities.
8 Related work
Control-ﬂow integrity. Control-ﬂow integrity was orig-
inally proposed by Abadi et al. [1, 15] a decade ago.
Classical CFI instruments indirect branch target loca-
tions with equivalence-class numbers (encoded as a la-
bel in a side-effect free instruction) that are checked at
branch locations before taking the branch. Many other
CFI schemes have been proposed since then.
The most coarse-grained policies
(e.g., Native
Client [40] or PittSFIeld [20]) align valid targets to the
beginning of chunks. At branches, these CFI schemes
ensure that control-ﬂow is not transferred to unaligned
addresses. Fine-grained approaches use static analy-
sis of source code to construct more accurate CFGs
(e.g., WIT [2] and HyperSafe [39]). Recent work by
Niu et al. [27] added support for separate compilation
and dynamic loading. Binary-only CFI implementa-
tions are generally more coarse-grained: MoCFI [13] and
BinCFI [44] use static binary rewriting to instrument in-
direct branches with additional CFI checks.
CFI evaluation metrics. Others have attempted to cre-
ate methods to evaluate practical CFI implementations.
The Average Indirect target Reduction (AIR) [44] metric
172  24th USENIX Security Symposium 
USENIX Association
12
was proposed to measure how much on average the set of
indirect valid targets is reduced for a program under CFI.
We argue that this metric has limited utility, as even high
AIR values of 99% are insecure, allowing an attacker to
perform arbitrary computation and issue arbitrary system
calls. The gadget reduction metric is another way to eval-
uate CFI effectiveness [27], by measuring how much the
set of reachable gadgets is reduced overall. Gadget ﬁnder
tools like ROPgadget [34] or ropper [33] can be used to
estimate this metric.
CFI security evaluations. There has recently been a
signiﬁcant effort to analyze the security of speciﬁc CFI
schemes, both static and dynamic. G¨oktas¸ et al. [16] an-
alyzed the security of static coarse-grained CFI schemes
and found that the speciﬁc policy of requiring returns to
target call-preceded locations is insufﬁcient. Following
this work, prevent-the-exploit-style coarse-grained CFI
schemes with dynamic components that rely on runtime
heuristics were defeated [5, 14]. The attacks relied upon
the fact that the attacks could hide themselves from the
dynamic heuristics, and then reduced down to attacks on
coarse-grained CFI. Our evaluation of minimal programs
builds on these results by showing that coarse-grained
CFI schemes which have an AIR value of 99% are still
vulnerable to attacks on trivially small programs.
Non-control data attacks. Attacks that target only sen-
sitive data structures were categorized as pure data at-
tacks by Pincus and Baker [32]. Typically, these at-
tacks would overwrite application-speciﬁc sensitive vari-
ables (such as the “is authenticated” boolean which exists
within many applications). This was expanded by Chen
et al. [8] who demonstrated that non-control data attacks
are practical attacks on real programs. Our work general-
izes these attacks to allow modiﬁcations of control-ﬂow
data, but only in a way that follows the CFI policy.
Data-ﬂow integrity. Nearly as old of an idea as CFI,
Data-Flow Integrity (DFI) provides guarantees for the in-
tegrity of the data within a program [6]. Although the
original scheme used static analysis to compute an ap-
proximate data-ﬂow graph — what we would now call
a coarse-grained approach — more reﬁned DFI may be
able to protect against our attacks. We believe security
evaluation of prevent-the-corruption style defenses such
as DFI is an important future direction of research.
Type- and memory-safety. Other defenses have tried
to bring type-safety and memory-safety to unsafe lan-
guages like C and C++. SoftBound [22] is a compile-
time defense which enforces spatial safety in C, but at
a 67% performance overhead. CETS [23] extends this
work with a compile-time defense that enforces tempo-
ral safety in C, by protecting against memory manage-
ment errors. CCured [24] adds type-safe guarantees to
C by attempting to statically determine when errors can-
not occur, and dynamically adding checks when nothing
can be proven statically. Cyclone [17] takes a more rad-
ical approach and re-designs C to be type- and memory-
safe. Code-Pointer Integrity (CPI) [18] reduces the over-
head of SoftBound by only protecting code pointers.
While CPI protects the integrity of all indirect control-
ﬂow transfers, limited control-ﬂow bending attacks using
conditional jumps may be possible by using non-control-
data attacks. Evaluating control-ﬂow bending attacks on
CPI would be an interesting direction for future work.
9 Conclusion
Control-ﬂow integrity has historically been considered a
strong defense against control-ﬂow hijacking attacks and
ROP attacks, if implemented to its fullest extent. Our re-
sults indicate that this is not entirely the case, and that
control-ﬂow bending allows attackers to perform mean-
ingful attacks even against systems protected by fully-
precise static CFI. When no shadow stack is in place, dis-
patcher functions allow powerful attacks. Consequently,
CFI without return instruction integrity is not secure.
However, CFI with a shadow stack does still provide
value as a defense, if implemented correctly. It can sig-
niﬁcantly raise the bar for writing exploits by forcing at-
tackers to tailor their attacks to a particular application; it
limits an attacker to issue only system calls available to
the application; and it can make speciﬁc vulnerabilities
unexploitable under some circumstances.
Our work has several implications for design and de-
ployment of CFI schemes. First, shadow stacks appear
to be essential for the security of CFI. We also call for
adversarial analysis of new CFI schemes before they are
deployed, as our work indicates that many published CFI
schemes have signiﬁcant security weaknesses. Finally, to
make control-ﬂow bending attacks harder, deployed sys-
tems that use CFI should consider combining CFI with
other defenses, such as data integrity protection to en-
sure that data passed to powerful functions cannot be cor-
rupted in the presence of a memory safety violation.
More broadly, our work raises the question: just how
much security can prevent-the-exploit defenses (which
allow the vulnerability to be triggered and then try to pre-
vent exploitation) provide? In the case of CFI, we argue
the answer to this question is that it still provides some,
but not complete, security. Evaluating other prevent-the-
exploit schemes is an important area of future research.
We hope that the analyses in this paper help establish
a basis for better CFI security evaluations and defenses.
10 Acknowledgments
We would like to thank Jay Patel and Michael Theodor-
ides for assisting us with three of the case studies. We
USENIX Association  
24th USENIX Security Symposium  173
13
would also like to thank Scott A. Carr, Per Larsen, and
the anonymous reviewers for countless discussions, feed-
back, and suggestions on improving the paper. This
work was supported by NSF grant CNS-1513783, by the
AFOSR under MURI award FA9550-12-1-0040, and by
Intel through the ISTC for Secure Computing.
References
[1] ABADI, M., BUDIU, M., ERLINGSSON, U., AND LIGATTI, J.
Control-ﬂow integrity. In CCS’05 (2005).
[2] AKRITIDIS, P., CADAR, C., RAICIU, C., COSTA, M., AND
CASTRO, M. Preventing memory error exploits with WIT. In
IEEE S&P’08 (2008).
[3] BLETSCH, T., JIANG, X., AND FREEH, V. Mitigating code-
reuse attacks with control-ﬂow locking. In ACSAC’11 (2011).
[4] BLETSCH, T., JIANG, X., FREEH, V. W., AND LIANG, Z.
Jump-oriented programming: a new class of code-reuse attack.
In ASIACCS’11 (2011).
[5] CARLINI, N., AND WAGNER, D. ROP is still dangerous: Break-
ing modern defenses. In USENIX Security’14 (2014).
[6] CASTRO, M., COSTA, M., AND HARRIS, T. Securing software
by enforcing data-ﬂow integrity. In OSDI ’06 (2006).
[7] CHECKOWAY, S., DAVI, L., DMITRIENKO, A., SADEGHI, A.-
R., SHACHAM, H., AND WINANDY, M. Return-oriented pro-
gramming without returns. In CCS’10 (2010), pp. 559–572.
[8] CHEN, S., XU, J., SEZER, E. C., GAURIAR, P., AND IYER,
R. K. Non-control-data attacks are realistic threats. In USENIX
Security’05 (2005).
[9] CHENG, Y., ZHOU, Z., YU, M., DING, X., AND DENG,
R. H. ROPecker: A generic and practical approach for defending
against ROP attacks. In NDSS’14 (2014).
[10] COWAN, C., PU, C., MAIER, D., HINTONY, H., WALPOLE, J.,
BAKKE, P., BEATTIE, S., GRIER, A., WAGLE, P., AND ZHANG,
Q. StackGuard: automatic adaptive detection and prevention of
buffer-overﬂow attacks. In USENIX Security’98 (1998).
[11] COX, M. CVE-2006-3747: Apache web server off-by-one buffer
http://cve.mitre.org/cgi-bin/
overﬂow vulnerability.
cvename.cgi?name=CVE-2006-3747, 2006.
[12] CRISWELL, J., DAUTENHAHN, N., AND ADVE, V. KCoFI:
Complete control-ﬂow integrity for commodity operating system
kernels. In IEEE S&P’14 (2014).
[13] DAVI, L., DMITRIENKO, R., EGELE, M., FISCHER, T., HOLZ,
T., HUND, R., NUERNBERGER, S., AND SADEGHI, A. MoCFI:
A framework to mitigate control-ﬂow attacks on smartphones. In
NDSS’12 (2012).
[14] DAVI, L., SADEGHI, A.-R., LEHMANN, D., AND MONROSE,
F. Stitching the gadgets: On the ineffectiveness of coarse-grained
control-ﬂow integrity protection. In USENIX Security’14 (2014).
[15] ERLINGSSON, ´U., ABADI, M., VRABLE, M., BUDIU, M., AND
NECULA, G. C. XFI: Software guards for system address spaces.
In OSDI’06 (2006).
[16] GOKTAS, E., ATHANASOPOULOS, E., BOS, H., AND POR-
TOKALIDIS, G. Out of control: Overcoming control-ﬂow in-
tegrity. In IEEE S&P’14 (2014).
[18] KUZNETSOV, V., PAYER, M., SZEKERES, L., CANDEA, G.,
SEKAR, R., AND SONG, D. Code-pointer integrity. In OSDI’14
(2014).
[19] MACMANUS, G. CVE-2013-2028: Nginx http server chunked
encoding buffer overﬂow. http://cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-2013-2028, 2013.
[20] MCCAMANT, S., AND MORRISETT, G. Evaluating SFI for a
CISC architecture. In USENIX Security’06 (2006).
[21] MEHTA, N., RIKU, ANTTI, AND MATTI. The Heartbleed bug.
http://heartbleed.com/, 2014.
[22] NAGARAKATTE, S., ZHAO,
J., MARTIN, M. M., AND
ZDANCEWIC, S. SoftBound: Highly compatible and complete
spatial memory safety for C. In PLDI’09 (2009).
[23] NAGARAKATTE, S., ZHAO,
J., MARTIN, M. M., AND
ZDANCEWIC, S. CETS: Compiler enforced temporal safety for
C. In ISMM’10 (2010).
[24] NECULA, G., CONDIT, J., HARREN, M., MCPEAK, S., AND
WEIMER, W. CCured: Type-safe retroﬁtting of legacy soft-
ware. ACM Transactions on Programming Languages and Sys-
tems (TOPLAS) 27, 3 (2005), 477–526.
[25] NERGAL. The advanced return-into-lib(c) exploits. Phrack 11,
58 (Nov. 2007), http://phrack.com/issues.html?issue=
67&id=8.
[26] NISSL, R. CVE-2009-1886: Formatstring vulnerability in sm-
http://cve.mitre.org/cgi-bin/cvename.cgi?
bclient.