title:MalTRAK: Tracking and Eliminating Unknown Malware
author:Amit Vasudevan
2008 Annual Computer Security Applications Conference
2008 Annual Computer Security Applications Conference
MalTRAK: Tracking and Eliminating Unknown Malware
CyLab, Carnegie Mellon University
5000 Forbes Ave., Pittsburgh, PA 15213, USA
Amit Vasudevan
PI:EMAIL
Abstract
Malware or malicious code is a rapidly evolving threat to the
computing community. Zero-day malware are exploiting vulnera-
bilities very soon after being discovered and are spreading quickly.
However, anti-virus tools, which are the most widely used counter-
ing mechanism [30], are unable to cope with this. They are based
on signatures which need to be computed for new malware strains.
After a new malware strikes and before the signature is found al-
lows sufﬁcient time for the malware to perform its damage.
We propose a new framework, codenamed MalTRAK, which
,when deployed on a clean system, guarantees that any effects of
a known or unknown malware can always be reversed and the
system can be restored back to a prior clean state. Our frame-
work also maintains detailed dependency lists of system opera-
tions which can be used for further forensic analysis. We are able
to achieve this without imposing any restrictions on the nature of
programs that can be executed by the user and without the user
noticing any perceptible system slowdown due to the framework.
Furthermore, we are able to track modiﬁcations to the system at a
level that ensures that we can always monitor any changes to the
system state even if a malware modiﬁes the system during execu-
tion.
We implemented and evaluated MalTRAK on Windows, us-
ing 8 known malware assuming they were unknown strains. We
then compared our results with two popular commercial anti-virus
tools. We were able to successfully restore all the effects of the
8 malware, while the commercial tools, on an average were only
able to restore 36% of all their effects put together. For one of
the malware samples, the commercial tools could only detect it but
could not repair any of its damage. Further, for two of the malware
samples, the commercial tools were completely unable to detect or
restore any of their effects. Our results show that signature based
mechanisms in addition to not being able to prevent infection by
new malware strains, are not very effective in removing an infec-
tion even after a signature has been developed. Our experience
shows that non-signature based approaches, such as MalTRAK,
are the next step towards combating the threat of ever-evolving
malware.
1. Introduction
Malware, or malicious code, is widespread today and have dev-
astating effects. They propagate by infecting a target system. Anti-
virus software today are the most widely used tools to detect and
counter malware [30]. They work by employing signatures- a
unique form of identiﬁcation of a malware and its related strains.
The contents of the system (typically the ﬁlesystem and memory)
are then checked against a database of such signatures to detect
and remove any infection.
The ﬁrst line of defense anti-virus tools provide is a real-time
system monitoring mechanism which can automatically detect a
malware before it can infect a system. They monitor the under-
yling ﬁlesystem for access/modiﬁcations and perform ﬁle scan-
ning the moment it is modiﬁed or before it is executed. While
real-time monitoring is an effective tool against known signatures
of malware, they are rendered useless against new malware or vari-
ants of the malware whose signature is not within the tools signa-
ture database.
The number of new malware or malware strains are rapidly in-
creasing year after year. A recent report showed an increase of
more than 50% from the latter half of 2006 to the ﬁrst half of 2007
for new malware being discovered [8]. Zero-day malware are be-
coming more and more prevalent, exploiting vulnerabilities within
moments of their discovery and spreading quickly [27]. With un-
derground exploit tools such as MPack [16] being constantly de-
veloped and reﬁned, malware writers do not have to write code to
discover the vulnerabilties themselves, but rather rely on a tool
that is constantly developed in order to churn out malware by
the numbers. This situation is further worsened by the fact that
the major cause of malware proliferation are the end users them-
selves [23]. Users either disable anti-virus programs, install appli-
cations downloaded off the internet or execute attachments within
emails which can potentially contain malicious software. Thus
before the signature of an unknown malware is discovered , the
malware can do most of its damage.
To this end, anti-virus tools provide a passive component which
can scan the system after an infection has taken place in order to
detect and remove it. However, this approach has serious limita-
tions. Only previously recognized and analyzed malware can be
detected and removed. Further, even if a malware is detected, it
could do irreversible damage to the system by deleting ﬁles or
overwriting them beyond repair. While the percentage of such
malware in existence today are relatively small, a recent report
from a leading anti-virus vendor suggests that the number of such
malware are increasing [21]. Also signature-based approaches are
not very effective in the realm of coding techniques such as poly-
morphism and metamorphism (which most if not all current gener-
ation malware employ) which are used by malware to hide them-
selves in memory.
There have been a few recent works geared towards a solution
1063-9527/08 $25.00 © 2008 IEEE
1063-9527/08 $25.00 © 2008 IEEE
DOI 10.1109/ACSAC.2008.44
DOI 10.1109/ACSAC.2008.44
311
311
to this problem [9, 28, 19] which attempt to detect and remove
malware without employing signatures. However they have one or
more of the following limitations: (a) they entail the user to place
a policy (rule) or rely on an external system to classify trusted vs
untrusted programs, based on which the system attempts to defend
against unknown malware. This can be potentially dangerous as a
user can place a policy which can allow a malware to get into the
system or an external system can classify an application as trusted,
but a malware can exploit a vulnerability in that application, (b)
they incur considerable runtime overhead which makes them un-
suitable for end system deployment, and (c) they do not capture
the modiﬁcations to the system at all times and may miss changes.
Section 2 discusses these approaches and other related work in
more detail.
We propose a new framework, codenamed MalTRAK, which
when deployed on a clean system, guarantees that any effects of
a known or unknown malware can always be reversed thereby al-
lowing the system to be restored back to a prior clean state. The
salient features of our framework are: (a) it does not require the
user to place any policy beforehand. In other words the user can
run any applications without worrying about a possible infection,
(b) the user notices very minmal or no perceptible difference in
the system speed due to our framwork, (c) the framework monitors
system operations at a level that makes it very difﬁcult to subvert
and (d) the framework maintains state information regarding the
system modiﬁcation. This information is used to revert the system
to a prior clean state as well as provide the user with a detailed
dependency information. This information can then be used for
forensic analysis as well as salvage more clean data if necessary.
A user typically interacts with MalTRAK when malware effects
are being perceived (either via recurrent crashes, system slow-
down, network trafﬁc, or exhaustion of system resources etc.) or
on a routine basis in order to make sure that the system has not
been infected (this would be the case where the user is an admin-
istrator and the system is a server). Disinfection of an infected
system typically involves the user to select an operation or a group
of operations whose cascading effects are then removed automat-
ically by our framework while preserving most of the clean data.
While at the outset, the selection of an operation might seem a
daunting task, our framework provides what we call alerts to as-
sist the user. Alerts are framework determined possible starting
operations (e.g a system driver that has been writen to the system
folder whose entry is then set in the conﬁguration to autoload the
driver on system startup). Alerts are based on the notion that there
are only a ﬁnite number of ways a malware could try to remain
persistent and active on a given OS (see Section 4.4.1).
We summarize the major contributions of our paper:
• We propose a mechanism which dynamically maintains var-
ious states of the system with minimal overhead in terms of
both disk space and runtime latency. This mechanism allows
us to execute any code on the system without prior knowl-
edge of its integrity while enabling us to track the changes it
makes to the system. This allows us to capture any form of
malicious activity either as a process in itself or by exploiting
another process.
• We propose a new mechanism which captures modiﬁcations
to the system at the lowest possible level while still being able
to maintain high level mappings. Thus, while existing ap-
proaches cannot handle malware such as Rustock and Nailuj
(which are using techniques that are touted to become stan-
dard pretty soon [11]), we are able to easily capture their be-
havior.
• We propose a mechanism which maintains a mapping be-
tween code and its interaction with the system and allows
restoration without the risk of reinfection. We leverage this
mechanism in order to detect probable malicious activity at
runtime, to allow the activity to take place and restore the
sytem to a prior good state later.
• We have implemented a prototype of MalTRAK on the Win-
dows OS and have evaluated it using 8 known malware as-
suming they were unknown strains. We then compared our
results with two popular commercial anti-virus tools. We
were able to successfully restore all the effects of the 8 mal-
ware, while the commercial tools, on an average were only
able to restore 36% of their effects put together. For one of
the malware samples, the commercial tools could only detect
it but could not repair any of its damage. Further, for two of
the malware samples, the commercial tools were completely
unable to detect or restore any of their effects.
The rest of the paper is organized as follows: We ﬁrst present
some background and related work in Section 2. In Section 3 we
present the design of our framework. We follow that by discussing
our implementation under the Windows OS in Section 4. In Sec-
tion 5 we present the evaluation of MalTRAK. This is followed
by a discussion on the security aspects of the framework in Sec-
tion 6. We then conclude the paper in Section 7 summarizing our
contributions.
2 Related Work
There have been several works related to the area of logging
and recovery in general. Broadly they can be categorized into:
(a) trusted/untrusted code execution approaches, (b) VM/Snapshot
based approaches, (c) ﬁlesystem based approaches and (d) behav-
ior/semantic based approaches.
Trusted vs Untrusted code execution: These approaches re-
quire running processe(s) to be categorized into trusted and un-
trusted. Trusted procese(s) are allowed to run as is while the un-
trusted processes are run in a sandbox like environment which em-
ploys some tainting analysis to track trustworthiness of the data.
SEE [28, 19] proposed the idea of one-way isolation where
untrusted processes modify a temporary copy of the ﬁlesystem
rather than the original. SEE allows the commit of such operations
once the untrusted processe(s) complete. SEE allows an untrusted
program to run to completion but might not be able to commit
changes. Back to the Future [9] is a framework for automatic mal-
ware removal and system repair. Unlike SEE it allows untrusted
processe(s) to write to the ﬁlesystem immediately but might not be
able to run the process to completion.
The Taser [7] intrusion recovery system logs all processes, ﬁles
and network operations.
It then uses this information to revert
changes to the ﬁle system depending on a signal from a IDS. Since
the IDS may have false positives, Taser may never respond to a
trusted process being tainted. Moreover, it results in the loss of
312312
too much clean data in the event that the IDS does not respond
immediately after intrusion happens.
This approach has several limitations: (a) classifying processes
as untrusted and trusted is not a trivial task, (b) a user may mis-
classify a process as trusted, but a malware could exploit a vulner-
ability in the process which goes undetected and (c) the runtime
latency of running an untrusted process is typically in the order of
2 times or more than its normal execution speed. This increases
as more processes are being run as untrusted. Further, since there
is no guarantee that a trusted process cannot have exploits, a user
most of the time may tend to mark processes as untrusted which
lead to latency that are unsuitable for normal system operation.
Virtual Machine and Snapshot based approaches: These ap-
proaches use a virtual machine container or periodically take snap-
shots of the whole system for recovery purposes. King et. al [14]
add support for virtual machine monitor in the Linux kernel to
achieve high performance. Revirt [5] runs applications inside a
virtual machine to log their events. Then it analyzes the intrusion
by replaying the logged events. TTVM [13] runs the operating
system inside a virtual machine for debugging purposes. Back-
tracker [12] identiﬁes potential sequence of steps that occured in
an intrusion. It runs the operating system as a guest and uses a
virtual machine monitor to log events.
Using virtual machines to run untrusted programs has its short-
comings. First untrusted processes cannot access resources created
by program running out of the virtual machine, which may break
many programs, secondly virtual machines are resource expensive.
ROC is a framework for recovering from system component
failure and operator errors [1, 25]. It contains three stages: rewind,
repair and replay. It has a large overhead for logging and recov-