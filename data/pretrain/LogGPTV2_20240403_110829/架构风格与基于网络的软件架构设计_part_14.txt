REST使用一个资源标识符来标识组件之间交互所涉及到的特定资源。REST连接器提
供了访问和操作资源的值集合的一个通用的接口，而无须关心其隶属函数（membership
function）是如何定义的，或者处理请求的软件是何种类型。由命名权威（naming
authority）来为资源分配资源标识符，使得引用资源成为可能。由同样的命名权威来负责维
护映射的语义有效性（例如，确保隶属函数不会改变）。
传统的超文本系统[61]通常只在一个封闭的或局部的环境中运行，它们使用随信息的变
化而改变的唯一节点或文档标识符，并依赖链接服务器（link server）以独立于内容的方式
来维护引用[135]。因为集中式的链接服务器无法满足Web的超大规模和多个组织领域的需
求，所以REST采用了其他的方式——依赖资源的创作者来选择最符合被标识的概念本质的
资源标识符。很自然，标识符的质量常常与为保持其有效性所花费的金钱成正比，因此随着
暂时性的（或未被良好支持的资源）信息移动或消失，会导致出现破损的链接。
5.2.1.2 表述（Representations）
REST组件通过以下方式在一个资源上执行动作：使用一个表述来捕获资源的当前的或
预期的状态、在组件之间传递该表述。一个表述是一个字节序列，以及描述这些字节的表述
元数据。表述的其他常用但不够精确的名称包括：文档、文件、HTTP消息实体、实例或变
量。
表述由数据、描述数据的元数据、以及（有时候存在的）描述元数据的元数据组成（通
常用来验证消息的完整性）。元数据以名称-值对的形式出现，其中的名称对应于一个定义
值的结构和语义的标准。响应消息可以同时包括表述元数据和资源元数据（关于资源的信息，
并不特定于所提供的表述）。
控制数据定义了组件之间的消息的用途，例如被请求的动作或响应的含义。它也被用来
提供请求的参数，以及覆盖某些连接元素（connecting elements）的默认行为。例如，可以
使用包括在请求或响应消息中的控制数据来修改缓存的行为。
依赖于消息中的控制数据，一个特定的表述可能表示的是被请求资源当前的状态或预期
的状态，或者某个其他资源的值，例如一个客户端查询表单中的输入数据的表述，或通过一
个响应返回的某种出错状况的表述。例如，对一个资源的远程创作需要创作者将资源的表述
第5章 表述性状态转移（REST） 49
发送到服务器，这就为该资源创建了一个以后的请求可以获取的值。如果一个资源在特定时
刻的值集合由多个表述组成，可以使用内容协商来选择将包括在一个特定消息中的最佳表述。
表述的数据格式被称为一种媒体类型[48]。一个表述能够被包括在一个消息中，并由接
收者根据消息的控制数据和媒体类型的性质来做处理。媒体类型有些是用来做自动处理的，
有些是用来呈现给用户来查看的，还有少数是可以同时用于两种用途的。组合的媒体类型能
够被用来将多个表述封装在单个消息之中。
媒体类型的设计能够直接影响到一个分布式超媒体系统的用户可觉察的性能。在接收者
能够开始对表述做呈现之前必须要接收到的任何数据都会增加交互的延迟。一种数据格式如
果将最重要的呈现信息放在前面，允许正在接收剩余的信息的同时对最初的信息进行增量地
呈现，这样将导致的用户可觉察的性能要比那些必须在呈现开始前接收全部信息的数据格式
好得多。
例如，即使在网络性能相同的情况下，能够在接收信息的同时增量地呈现大型HTML
文档的Web浏览器所提供的用户可觉察性能，要比那些在呈现之前要等待整个文档完全接
收的浏览器好得多。需要注意的是，表述的呈现能力也会受到对于内容的选择的影响。如果
动态尺寸的表格的尺寸及其内嵌的对象必须要在它们能够被呈现之前确定，那么它们出现在
一个超媒体页面的显示区域中就会增加显示该表格的延迟。
5.2.2 连接器（Connectors）
如表5-2所总结的那样，REST使用多种不同的连接器类型来对访问资源和转移资源表
述的活动进行封装。连接器代表了一个组件通信的抽象接口，通过提供清晰的关注点分离、
并且隐藏资源的底层实现和通信机制，从而改善了架构的简单性。接口的通用性也使得组件
的可替换性成为了可能：如果用户对系统的访问仅仅是通过一个抽象的接口，那么接口的实
现就能够被替换，而不会对用户产生影响。由于组件的网络通信是由一个连接器来管理的，
所以在多个交互之间能够共享信息，以便提高效率和响应能力。
表5-2 REST的连接器
连接器 现代Internet实例
客户端 libwww、libwww-perl
服务器 libwww、Apache API、NSAPI
缓存 浏览器缓存、Akamai缓存网络
解析器（resolver） 绑定（DNS查找库）
隧道（tunnel） SOCKS、HTTP连接之后的SSL
所有的REST交互都是无状态的。也就是说，无论之前有任何其他请求，每个请求都包
含了连接器理解该请求所必需的全部信息。这个约束能够实现四个功能：1）它使得连接器
无需保存请求之间的应用状态，从而降低了物理资源的消耗并改善了可伸缩性；2）它允许
对交互进行并行处理，处理机制无需理解交互的语义；3）它允许中间组件孤立地查看并理
解一个请求，当需要对服务作出动态安排时，这是必需要满足的；4）它强制每个请求都必
须包含可能会影响到一个已缓存响应的可重用性的所有信息。
连接器接口与过程调用有些类似，但是在参数和结果的传递方式上有着重要的区别。其
传入参数由请求的控制数据、一个表示请求的目标的资源标识符、以及一个可选的表述组成。
其传出参数由响应的控制数据、可选的资源元数据、以及一个可选的表述组成。从一种抽象
第5章 表述性状态转移（REST） 50
的观点来看，调用是同步的，但是传入参数和传出参数都可以作为数据流来传递。换句话说，
处理可以在完全知道参数的值（译者注：即数据流的全部数据）之前进行，从而避免了对于
大量数据转移进行批量处理而产生的延迟。
主要的连接器类型是客户端和服务器。两者之间的本质区别是：客户端通过发送请求来
发起通信；服务器侦听连接并对请求作出响应，以便为其服务提供访问的途径。一个组件可
能包括客户端和服务器两种连接器。
第三种连接器类型是缓存连接器，可以位于客户端或服务器连接器的接口处，以便保存
当前交互的可缓存的响应，这样它们就能够被以后的请求交互来重用。客户端可以使用缓存
来避免重复的网络通信，服务器可以使用缓存来避免重复执行生成响应的处理，这两种情况
都可以减小交互的延迟。一个缓存通常在使用它的连接器的地址空间内实现。
某些缓存连接器是共享的，这意味着它所缓存的响应可以被最初获得该响应的客户端以
外的其他客户端所使用。共享缓存可以有效地减少受欢迎的服务器的负载出现“闪电拥塞”，
的几率，尤其是当缓存以分等级的形式来安排，以便覆盖大量用户的时候，例如在公司的
Intranet中、Internet服务提供商的用户、或共享国家网络主干的大学。然而，如果被缓存的
响应不能与新的请求原本应该获得的响应相匹配的话，共享缓存就会导致出错。REST试图
在透明的缓存行为和高效地使用网络这两个想要得到的属性之间取得平衡，而不是假设无论
何时都需要绝对的透明性。
一个缓存有能力确定一个响应的可缓存性（cacheability），因为接口是通用的而不是特
定于每个资源的。在默认情况下，数据获取请求（retrieval request）的响应是可缓存的，其
他类型的请求的响应是不可缓存的。如果请求中包含了某种形式的用户认证信息，或者响应
明确表示它不应该被共享，那么该响应就只能被缓存在非共享缓存中。一个组件能够通过包
括控制数据来覆盖这些默认的行为，使得交互变成是可缓存的、不可缓存的、或者仅在有限
时间内是可缓存的。
一个解析器负责将部分或完整的资源标识符翻译成创建组件间连接所需的网络地址信息。
例如，大多数URI都包括一个DNS主机名，作为一种机制来标识该资源的命名权威。为了
发起一个请求，一个Web浏览器会从URI中提取出主机名，并利用DNS解析器来获得该权
威的Internet协议（IP）地址。另一个例子是某些识别模式（例如URN[124]）要求一个中间
组件将一个永久标识符翻译为一个更加短暂的地址，以便访问被标识的资源。使用一个或多
个中间解析器（intermediate resolvers）能够通过增加间接层的方式来延长资源引用的寿命，
尽管这样做会增加请求的延迟。
连接器类型的最后一种形式是隧道，它简单地跨连接的边界对通信进行中继，例如一个
防火墙或更低层的网关。隧道作为REST的一部分来建模，而不是作为网络基础设施的一部
分来进行抽象，唯一的原因是某些REST组件可能会动态地从主动的组件行为切换到一个通
道。主要的例子是当响应一个CONNECT方法请求时，HTTP代理会切换到一个隧道[71]，
从而允许其客户使用一种不同的协议（例如TLS）来直接与不支持代理的远程服务器通信。
当两端终止通信时，隧道就会消失。
5.2.3 组件（Components）
REST组件根据它们在整个的应用动作（application action）中的角色来进行分类，总结
于表5-3。
第5章 表述性状态转移（REST） 51
表5-3 REST的组件
组件 现代Web实例
来源服务器（origin server） Apache httpd、微软IIS
网关（gateway） Squid、CGI、反向代理
代理（proxy） CERN代理、Netscape代理、Gauntlet
用户代理（user agent） Netscape Navigator、Lynx、MOMspider
一个用户代理使用一个客户端连接器发起请求，并成为响应的最终接收者。最常见的例
子是一个Web浏览器，它提供了对信息服务的访问途径，并且根据应用的需要呈现服务的
响应。
一个来源服务器使用一个服务器连接器管理被请求资源的名字空间。来源服务器是其资
源表述的权威数据来源，并且必须是任何想要修改资源的值的请求的最终接收者。每个来源
服务器都为其服务提供了一个以资源的层次结构形式出现的通用的接口。资源的实现细节被
隐藏在这一接口的背后。
为了支持转发，可能还要对请求和响应进行转换，中间组件同时扮演了客户端和服务器
两种角色。一个代理组件是由客户端选择的中间组件，用来为其他的服务、数据转换、性能
增强（performance enhancement）、或安全保护（security protection）提供接口封装。一个
网关（也叫作反向代理）组件是由网络或来源服务器强加的中间组件，用来为其他的服务、
数据转换、性能增强，或安全增强（security enforcement）提供接口封装。需要注意的是，
代理和网关之间的区别是，何时使用代理是由客户端来决定的。
5.3 REST架构的视图
现在我们已经孤立地了解了REST的架构元素，我们能够使用架构视图[105]来描述这些
元素如何协作以形成一个架构。为了展示REST的设计原则，需要使用三种视图——过程视
图、连接器视图、数据视图。
5.3.1 过程视图（Process View）
架构的过程视图的主要作用是，通过展示数据在系统中的流动路径，得出组件之间的交
互关系。不幸的是，一个真实系统的交互通常会涉及到大量的组件，导致整体的视图因受到
细节的干扰而模糊不清。图5-10提供了一个基于REST的架构的过程视图，其中包括了对三
个并行请求的处理。