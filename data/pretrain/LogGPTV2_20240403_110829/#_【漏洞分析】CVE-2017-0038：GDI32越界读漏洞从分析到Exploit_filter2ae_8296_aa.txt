# 漏洞分析：CVE-2017-0038 - GDI32 越界读漏洞从分析到Exploit

## 译文声明
本文是翻译文章，原文来源：安全客。译文仅供参考，具体内容及含义以原文为准。

## 作者信息
- 作者：[k0shl](http://bobao.360.cn/member/contribute?uid=1353169030)
- 稿费：600 RMB
- 投稿方式：发送邮件至 linwei#360.cn 或登录网页版在线投稿

## 前言
在之前的一篇博客中，我讨论了 CVE-2017-0037 类型混淆漏洞，并完成了在关闭 DEP 情况下的 Exploit。当时，我认为由于利用面的限制，该漏洞似乎无法绕过 ASLR 和 DEP。随后，我注意到 Google Project Zero 公开的另一个漏洞 CVE-2017-0038，这是一个由 EMF 文件格式引起的越界读漏洞。众所周知，在漏洞利用中，越界读可以轻易导致信息泄露。因此，我当时考虑是否可以通过这个 EMF 越界读漏洞进行信息泄露，从而获取内存基址，并在 CVE-2017-0037 漏洞利用中构造 ROP 链（但事实证明这并不容易实现）。

漏洞曝光后，有人使用 0patch 对此进行了修补。PJ0 关于 CVE-2017-0038 的说明地址（含 PoC EMF）：
- [PJ0 关于 CVE-2017-0038 的说明](链接)
- [0patch 修补 CVE-2017-0038](链接)
- [安全客翻译地址](链接)

在这篇文章中，我将首先对 CVE-2017-0038 这个 GDI32.dll 的越界读漏洞进行分析；接着，我将分享用 JavaScript 编写一个浏览器可用的 Exploit，并探讨其限制（为什么无法通过浏览器进行信息泄露），解释 0patch 文章中提到的 0xFF3333FF；然后，我将分享用 C 语言完成的 Exploit，并展示实际泄露的内存内容；最后，我会将 JavaScript 和 C 语言的 Exploit 放在 GitHub 上与大家分享。

调试环境如下：
- Windows 10 x86_64 build 10240
- IE 11
- GDI32.dll Version 10.0.10240.16384

欢迎大家交流，感谢阅读！

## CVE-2017-0038 PoC 与漏洞分析
如我在前文中所提到的测试环境图片所示，同样在 0patch 的文章中也能看到，每次浏览器加载 poc.emf 时，都会产生不同的图片，只有左下角的一个小红点是固定不变的。实际上，除了左下角四个字节外，其他内容都是泄露的内存，这一点将在后续分析中得到验证。

### 加载 PoC 图片
我们需要解决的问题是如何加载这张图片。为此，我们使用 JavaScript 的画布功能来构造 PoC 并成功加载 poc.emf。

1. 定义一个 canvas 画布。
2. 通过 `getElementById` 获取画布对象。
3. 使用 `Image()` 函数初始化 image 对象并加载 poc.emf。
4. 通过 `drawImage` 将 poc.emf 打印在画布上。`drawImage` 的后两个参数是 image 在 canvas 画布上的坐标，这里设置为 (0,0)。

完成构造后，我们稍微修改一下 poc.emf 的文件结构，然后打开 IE11 浏览器，通过 Windbg 附加进程，并在 `gdi32!MRSETDIBITSTODEVICE::bPlay` 函数位置下断点。这个过程会在 poc.emf 映射到画布上时发生，允许 JavaScript 执行之后，Windbg 命中断点。

```plaintext
0:022> x gdi32!MRSETDIBITSTODEVICE::bPlay
00007ff8`2a378730 GDI32!MRSETDIBITSTODEVICE::bPlay = 
0:022> bp gdi32!MRSETDIBITSTODEVICE::bPlay
Breakpoint 0 hit
GDI32!MRSETDIBITSTODEVICE::bPlay:
00007ff8`2a378730 48895c2408      mov     qword ptr [rsp+8],rbx ss:00000034`93cef6f0={GDI32!MRMETAFILE::bPlay (00007ff8`2a320950)}
0:027> kb
RetAddr:ArgstoChild: Call Site
00007ff8`2a2ff592 : 00007ff8`2a320950 00007ff8`2a2f8ed1 00000000`00000008 ffffffff`8f010c40 : GDI32!MRSETDIBITSTODEVICE::bPlay//到达目标断点
00007ff8`2a2ff0a8 : 0000002c`8f00be8c 00000000`00000000 00000000`00000000 00000000`00000000 : GDI32!PlayEnhMetaFileRecord+0xa2
00007ff8`2a327106 : 00000034`92acee00 00007ff8`2a2ff8f3 00000034`90380680 00000034`93cef988 : GDI32!bInternalPlayEMF+0x858
00007ff8`08650a70 : 00007ff8`08061010 00007ff8`08061010 00000034`93cefa10 00000000`000000ff : GDI32!PlayEnhMetaFile+0x26//关键函数调用 PlayEnhMetaFile
```

现在我们开始单步跟踪这个关键函数的执行流程。以下是整个函数的伪代码，相应的注释已写在 `//` 后面。

```plaintext
0:027> p
GDI32!MRSETDIBITSTODEVICE::bPlay+0x1b:
00007ff8`2a37874b 488bd9          mov     rbx,rcx
0:027> r rcx
rcx=0000002c8f00be8c
0:027> dt vaultcli!EMRSETDIBITSTODEVICE 0000002c8f00be8c
   +0x000 emr              : tagEMR
   +0x008 rclBounds        : _RECTL
   +0x018 xDest            : 0n0
   +0x01c yDest            : 0n0
   +0x020 xSrc             : 0n0
   +0x024 ySrc             : 0n0
   +0x028 cxSrc            : 0n1
   +0x02c cySrc            : 0n1
   +0x030 offBmiSrc        : 0x4c
   +0x034 cbBmiSrc         : 0x28
   +0x038 offBitsSrc       : 0x74
   +0x03c cbBitsSrc        : 4
   +0x040 iUsageSrc        : 0
   +0x044 iStartScan       : 0
   +0x048 cScans           : 0x10
```

这里 `rcx` 传递的指针是 `MRSETDIBITSTODEVICE::bplay` 的第一个参数，这个参数是一个非常重要的结构体 `EMRSETDIBITSTODEVICE`。正是对该结构体中几个成员变量的控制没有进行严格的判断，从而导致了越界读漏洞的发生。

### EMF 文件格式
接下来，我对 poc.emf 进行了修改，修改了 `cxSrc` 和 `cySrc` 的值，这样在最后向 HDC 拷贝图像时，就不会读取多余的内存信息。这个结构体的变量需要记录，因为接下来在跟踪函数内部逻辑时，会涉及很多关于这个结构体成员变量的偏移。关于这个结构体变量的解释，可以参考 MSDN。

继续单步跟踪，首先函数会命中一个叫做 `pvClientObjGet` 的函数，这个函数会根据 Handle 获取 EMF 头部 section 的一个标识并对标识进行判断。

```plaintext
0:027> p
GDI32!pvClientObjGet+0x2a:
00007ff8`2a301d5a 488d0daf141400  lea     rcx,[GDI32!aplHash (00007ff8`2a443210)]
0:027> p
GDI32!pvClientObjGet+0x31:
00007ff8`2a301d61 83e07f          and     eax,7Fh
0:027> p
GDI32!pvClientObjGet+0x34:
00007ff8`2a301d64 48833cc100      cmp     qword ptr [rcx+rax*8],0 ds:00007ff8`2a443218=0000003492a60080//获取特殊 handle object
0:027> p
GDI32!pvClientObjGet+0x39:
00007ff8`2a301d69 488d3cc1        lea     rdi,[rcx+rax*8]
0:027> p
GDI32!pvClientObjGet+0x70://获得当前 EMF 头部 section 标识 ENHMETA_SIGNATURE
00007ff8`2a301da0 488b4718        mov     rax,qword ptr [rdi+18h] ds:00000034`92a60098=0000003492ac5280
0:026> r rax
rax=00000296033d3d30
0:026> dc 296033d3d30 l1
00000296`033d3d30  0000464d                             MF..
```

可以看到，最后函数会读取一个名为 `MF` 的标识，这是 EMF 文件的头部。这里识别的是 `ENHMETA_SIGNATURE` 结构。

返回后继续单步跟踪，接下来会命中 `bCheckRecord` 函数，这个函数主要负责检查 `EMRSETDIBITSTODEVICE` 中成员变量的信息是否符合要求。

```plaintext
0:027> p
GDI32!MRSETDIBITSTODEVICE::bPlay+0x3f:
00007ff8`2a37876f 498bd6          mov     rdx,r14
0:027> p
GDI32!MRSETDIBITSTODEVICE::bPlay+0x42:
00007ff8`2a378772 488bcb          mov     rcx,rbx
0:027> p
GDI32!MRSETDIBITSTODEVICE::bPlay+0x45:
00007ff8`2a378775 e8a6dbffff      call    GDI32!MRSETDIBITSTODEVICE::bCheckRecord (00007ff8`2a376320)
0:027> r rcx
rcx=0000002c8f00be8c//检查 vaultcli!EMRSETDIBITSTODEVICE 结构
```

可以看到，`EMRSETDIBITSTODEVICE` 结构保存在 `rcx` 中，并作为第一个参数传入函数。接下来跟入函数中。

```plaintext
0:027> p//接下来检查 tagEMR 的 nSize
```

通过上述步骤，我们可以逐步了解 CVE-2017-0038 漏洞的具体细节和利用方法。希望这篇文章能为大家提供有价值的参考。