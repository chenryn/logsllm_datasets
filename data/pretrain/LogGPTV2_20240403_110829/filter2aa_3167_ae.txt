u 适当减少堆碎片的产生
u 加上一丢丢的安全机制
u 为了减少系统调用的次数,heap allocator充当了中间层的作用
u 从前没有堆,brk之后就有了堆
u 这一片连续空间叫做arena,因为是主线程创建的arena,所以被称为main_arena
PWN基础入门
Ø 堆漏洞
l 堆基础
l 堆漏洞原理
l 堆漏洞防护与利用(PWN中堆利用是王道!)
PWN基础入门
堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（之所
以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进
行调整，这也导致可利用的字节数都不小于用户申请的字节数），因而导致了数据
溢出，并覆盖到物理相邻的高地址的下一个堆块。
不难发现，堆溢出漏洞发生的基本前提是
• 程序向堆上写入数据。
• 写入的数据大小没有被良好地控制。
对于攻击者来说，堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流
程。
堆溢出是一种特定的缓冲区溢出（还有栈溢出， bss 段溢出等)。但是其与栈溢出所不同的
是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直
接通过堆溢出来控制 EIP 。一般来说，我们利用堆溢出的策略是：
1.覆盖与其物理相邻的下一个 chunk 的内容(prev_size、size、chunk content)，从而
改变程序固有的执行流。
2.利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）
或控制堆块中的内容等效果，从而来控制程序的执行流。
Ø 堆漏洞原理
l 堆溢出(unlink)
PWN基础入门
Ø 堆漏洞原理
l 释放后重用(Use After Free)
简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被
使用。但是其实这里有以下几种情况:
•
内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。
•
内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没
有代码对这块内存块进行修改，那么程序很有可能可以正常运转。
•
内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代
码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的
问题。
而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被
设置为 NULL 的内存指针为 dangling pointer。
PWN基础入门
Ø 堆漏洞原理
l 重复释放(Double Free)
Double Free其实就是同一个指针free两次。free函数在释放堆块时，会通过隐式链表判断相邻前、后堆块
是否为空闲堆块；如果堆块为空闲就会进行合并，然后利用Unlink机制将该空闲堆块从Unsorted bin中取
下。如果用户精心构造的假堆块被Unlink，很容易导致一次固定地址写，然后转换为任意地址读写，从而
控制程序的执行。
对一个指向malloc分配的heap内存的指针p进行free之后，并没有将该指针置NULL。导致，即使free之后
指针p仍然指向heap内存，潜在着利用的可能。
l Off By One
严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入
的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节，影响了下一个内存
块的头部信息，进而造成了被利用的可能。
off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当
然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括
•
使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导
致多写入了一个字节。
•
字符串操作不合适
一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松
散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。 此外，需要说明的
一点是 off-by-one 是可以基于各种缓冲区的，比如栈、bss 段等等，但是堆上（heap based） 
的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。
PWN基础入门
Ø 堆漏洞原理
l Chunk Extend and Overlapping
https://www.cnblogs.com/hac425/p/941679
2.html  
chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk 
overlapping 的效果。这种利用方法需要以下的时机和条件：
•
程序中存在基于堆的漏洞(如off-by-one、UAF等)
•
漏洞可以控制 chunk header 中的数据
ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块
进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨
越块操作从而导致 overlapping 的。
chunk overlap 堆块重叠，是一种用于漏洞利用的堆排布技术，无论是能够造成
8~16字节以上的大范围溢出，还是仅溢出一个字节的off-by-one，都有可能造成
chunk overlap，灵活运用堆排布构造chunk overlaping 能够得到很powerful的漏洞
利用效果。chunk overlap 堆块重叠，其目的是通过修改chunk->size使得heap部分
的chunk重叠出现混乱，从中作梗。之所以会出现chunk overlaping，是由于
ptmalloc中对chunk的识别使用的边界标记法，是通过size，prev_size来上下计算确
定chunk边界而无论是size还是prev_size都容易oveflow，size的修改会造成堆空间
的分配与释放混乱.
PWN基础入门
Ø 堆漏洞原理
l Chunk Extend and Overlapping
https://www.cnblogs.com/hac425/p/941679
2.html  
2次malloc
free(ptr)
malloc(0x30)
(ptr-0x8)=0x41
Chunk Extend/Shrink 可
以做什么?
一般来说，这种技术并不能
直接控制程序的执行流程，
但是可以控制 chunk 中的
内容。如果 chunk 存在字
符串指针、函数指针等，就
可以利用这些指针来进行信
息泄漏和控制执行流程。此
外通过 extend 可以实现 
chunk overlapping，通
过 overlapping 可以控制 
chunk 的 fd/bk 指针从而
可以实现 fast bin 
attack 等利用。
PWN基础入门
Ø 堆漏洞
l 堆基础
l 堆漏洞原理
l 堆漏洞利用(PWN中堆利用是王道!)
PWN基础入门
Ø 堆漏洞
l 堆漏洞利用
堆漏洞利用一览图 待补充
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
unlink的目的:把一个双向链表中的空闲块拿出来，然后和目前物理相邻的 free 
chunk 进行合并。这实际上是对chunk的fd和bk指针的操作，fd_nextsize和
bk_nextsize只有在chunk是large bins chunk时才会用到，而一般情况下很少
用到。
unlink攻击的前提条件:程序必须有个地方存储着malloc返回的地址，例如bss
段中存放chunk地址的全局变量数组
unlink攻击的本质:是对fd和bk这两个指针的利用
当需要合并相邻的free chunk时用到unlink,在free的链表中把chunk块
脱下来，然后可以把新的free的chunk块放到bins中管理~合并主要分为
2种情况:
1、向后合并
2、向前合并
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
1、向后合并
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
1、向后合并
当chunk2 free完了，发现上一个块chunk1也是free状态的，就抱大腿合并起来，指挥权交给
chunk1，指向chunk2的ptr指针现在指向chunk1，size也变为size+presize,如右图所示:
接着因为使用完了会进行分箱式管理，因此这个新的free的chunk1不会很快回到操作系统，于是
需要从所在的free的chunk链中进行unlink（有fd指针和bk指针）再放到unsorted bin中保存。
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
2、向前合并
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
2、向前合并
当chunk1 free完了，发现相邻的chunk2也是free的，会先进行unlink(让chunk2先脱链，有fd
和bk指针)，然后再进行合并：size = size + nextsize，ptr指向不变，还是自己：
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
从左边的漏洞源程序可以看出，用户输入argv[1]复制给了堆
缓冲区first，没有任何大小限制,因此，当用户输入大于 
666 字节时，它就会覆盖下一个chunk的chunk header——这
可以导致任意代码执行,gdb跟踪调试得到first chunk、
second chunk、top chunk等堆块的size分别是0x2a1、
0x11、0x20d51
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
从左边的漏洞源程序可以看出，用户输
入argv[1]复制给了堆缓冲区first，没
有任何大小限制,因此，当用户输入大于 
666 字节时，它就会覆盖下一个chunk
的chunk header——这可以导致任意代码
执行,而攻击的核心思路就是利用glibc 
malloc的unlink机制。gdb跟踪调试得
到first chunk、second chunk、top 
chunk等堆块的size分别是0x2a1、
0x11、0x20d51
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
unlink攻击技术就是利用”glibc malloc”的内存回
收机制，将左图中的second chunk给unlink掉，并
且，在unlink的过程中使用shellcode地址覆盖掉
free函数(或其他函数也行)的GOT表项。这样当程
序后续调用free函数的时候(如上面代码[5])，就转
而执行我们的shellcode了。显然，核心就是理解
glibc malloc的free机制。
问题: 怎么触发unlink？
制造堆块合并的场景:
•
strcpy进行second chunk header覆盖
•
free(first)触发unlink进行堆块向前合并
•
free(second)触发shellcode执行
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
值
说明
Prev_size = 偶数
这样其PREV_INUSE位等于0，表明前一个chunk处
于free状态,可以引发向前合并(调用unlink函数)
Size = -4
next-next chunk size -> next chunk prev_size
Fd = free_addr -12
free函数的got表地址address – 12
Bk = shellcode_addr
shellcode的地址
构造覆盖第二个chunk的chunk header数据如下:
那么当程序在[4]处调用free(first)后会发生什么呢？
一、向后合并
       鉴于first的前一个chunk非free的，所以不会发生向后合并操作。
二、向前合并
       先判断后一个chunk是否为free，前文已经介绍过，glibc malloc通过如下代码
判断：
PWN基础入门
Ø 堆漏洞利用
堆溢出利用--unlink
从上面代码可以知道，它是通过将nextchunk + nextsize计算得到指向下下一个chunk的指
针，然后判断下下个chunk的size的PREV_INUSE标记位。在本例中，此时nextsize被我们设
置为了-4，这样glibc malloc就会将next chunk的prev_size字段看做是next-next chunk
的size字段，而我们已经将next chunk的prev_size字段设置为了一个偶数，因此此时通过
inuse_bit_at_offset宏获取到的nextinuse为0，即next chunk为free！既然next chunk
为free，那么就需要进行向前合并，所以就会调用unlink(nextchunk, bck, fwd)函数。真
正的重点就是这个unlink函数！