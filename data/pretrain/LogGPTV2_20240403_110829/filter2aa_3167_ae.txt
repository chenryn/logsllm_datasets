# PWN基础入门：堆漏洞原理与利用

## 1. 堆碎片管理
- **减少堆碎片**：通过合理分配和释放内存，适当减少堆碎片的产生。
- **安全机制**：加入必要的安全机制以增强系统的安全性。

## 2. 堆分配器的作用
- **中间层角色**：为了减少系统调用次数，堆分配器（heap allocator）作为中间层发挥作用，优化内存管理。

## 3. 堆的基本概念
- **堆的起源**：在使用`brk`系统调用之前，并不存在堆；而通过`brk`系统调用后，便有了堆空间。
- **Arena定义**：由主线程创建的一片连续空间被称为arena，特别地，如果是由主线程创建，则称为main_arena。

## 4. 堆漏洞类型
### 4.1 堆溢出
- **定义**：当程序向某个堆块中写入的数据超过该堆块实际可使用的字节数时，就会发生堆溢出。这种情况下，数据会覆盖到相邻高地址的下一个堆块。
- **前提条件**：
  - 程序需要向堆上写入数据。
  - 写入的数据大小没有得到有效控制。
- **潜在影响**：轻则导致程序崩溃，重则使攻击者能够控制程序执行流程。
- **利用策略**：
  1. 覆盖相邻chunk的内容，包括prev_size、size以及chunk content，从而改变程序行为。
  2. 利用堆内机制如unlink实现任意地址写或控制堆内容，进一步操控程序执行。

### 4.2 释放后重用 (Use After Free, UAF)
- **描述**：UAF发生在一块已释放的内存被重新引用的情况下。根据具体情况分为几种情形：
  - 释放后指针置为NULL，再次使用时程序崩溃。
  - 释放后指针未置为NULL但无修改，程序可能正常运行。
  - 释放后指针未置为NULL且有修改，再次使用可能导致异常问题。
- **重点**：通常讨论的是后两种情况，其中未置为NULL的指针被称为dangling pointer。

### 4.3 重复释放 (Double Free)
- **定义**：同一指针被多次free。
- **利用方式**：通过构造假堆块并触发unlink操作，可以实现固定地址写进而转换为任意地址读写。

### 4.4 单字节溢出 (Off By One)
- **概述**：一种特殊类型的缓冲区溢出，只越界一个字节，但仍能影响下一内存块头部信息。
- **成因**：边界验证不严或字符串操作不当。
- **特点**：尽管看似难以利用，但在Linux下由于ptmalloc的松散性，其利用相对简单且威力巨大。

### 4.5 Chunk Extend and Overlapping
- **概念**：通过控制chunk header中的数据（如size和prev_size），实现chunk overlapping效果，从而达到控制堆布局的目的。
- **应用场景**：常用于基于堆的各种漏洞利用场景中，例如off-by-one、UAF等。

## 5. 堆漏洞利用技术
### 5.1 Unlink攻击
- **目标**：从双向链表中移除空闲chunk，并将其与物理相邻的空闲chunk合并。
- **前提条件**：存在存储malloc返回地址的地方，比如全局变量数组。
- **核心**：对fd和bk这两个指针的操作。
- **合并类型**：
  - 向后合并：当前chunk与后续chunk均为free状态时进行合并。
  - 向前合并：当前chunk与前驱chunk均为free状态时进行合并。

### 5.2 实例分析
- **示例程序**：用户输入超出限制覆盖了下一个chunk的header，利用unlink机制替换函数GOT表项，最终执行shellcode。
- **触发方法**：通过strcpy覆盖second chunk header，随后free(first)触发unlink向前合并，最后free(second)触发shellcode执行。

以上是对PWN基础入门中关于堆漏洞及其利用技术的一个简要介绍。希望这些信息对你有所帮助！