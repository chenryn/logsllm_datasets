4.42
5.40
13.65
17.63
(b)
Table 1: (a) Running time of forward algorithm vs. number
of mixed roles with |R| = 32.
(b) Running time of forward
algorithm vs. number of roles with 5 mixed roles.
|goal|
1
2
3
4
Nodes
30
377
2128
14395
Trans
125
3022
23744
215396
Time
0.01
0.14
2.59
97.95
(a)
Roles
100
200
300
400
500
Nodes
78
124
242
329
401
Trans
360
539
1095
1459
1789
(b)
Time
0.02
0.03
0.10
0.13
0.25
Table 2: Performance of backward algorithm for (a) varying
goal size and (b) varying number of roles with |Irrev|/|R| =
0.05 and |goal| = 1.
stant. Table 2(b) shows that the analysis cost grows very slowly as
a function of the number of roles (and rules), when the percentage
of irrevocable roles and the goal size are held constant (at 5% and
1, respectively).
The reduction technique for backward algorithm reduces the state
space and the running time of policies used in Table 2(a) by 24%
and 19% on the average, respectively. It does not affect the state
space and running time of policies used in Table 2(b).
Forward Algorithm with Slicing vs. Backward Algorithm. We
applied the forward algorithm with slicing to the same policies used
for the experiments reported in Table 2(a). The average execution
times were 0.04 sec, 0.38 sec, 0.87 sec and 1.08 sec when |goal|
is 1, 2, 3, and 4, respectively. Observe that the average execution
time for the forward algorithm increases slightly with |goal|, while
the corresponding increase in the execution time for the backward
algorithm is much more signiﬁcant.
Note that slicing does not change the worst-case complexity of
the forward algorithm. When |goal| = 1 and |Irrev| ≤ 1, the
backward algorithm has better time complexity than the forward al-
gorithm, except when |NR| = 0 and both algorithms have similar
(polynomial) complexity. For a set of randomly-generated policies
with |goal| = 1, |Irrev| = 2, |R| = 50, and |NR| varying be-
tween 0.6|R| and 0.9|R|, the backward algorithm is 11 to 30 times
faster than the forward algorithm. We observe that when |goal| and
|Irrev| are small and ﬁxed, the backward algorithm is superior to
the forward algorithm in terms of analysis time and the size of the
explored state space.
9. RELATED WORK
Policy Analysis. We classify related work on security policy anal-
ysis into three categories.
The ﬁrst, and largest, category is analysis (including enforce-
ment) of a ﬁxed security policy. Some representative papers in this
category include [15, 2, 11, 16, 10, 13]. Work in this category is
less closely related to our work, so we do not discuss it further.
The second category is analysis of a single change to a ﬁxed
policy or, similarly, analysis of the differences between two ﬁxed
policies. Jha and Reps present algorithms to analyze the effects
of a speciﬁed change to a SPKI/SDSI policy [16]. Fisler et al. [8]
give algorithms to compute the semantic difference of two XACML
policies and check properties of the difference.
Work in the ﬁrst two categories differs signiﬁcantly from our
work (and other work in the third category) by not considering the
effect of sequences of changes to the policy.
The third category is analysis that considers sequences of changes
to a policy; the allowed changes are determined by parts of the pol-
icy that we call “administrative policy”. Harrison, Ruzzo, and Ull-
man [12] present an access control model based on access matrices,
which can express administrative policy, and show that the safety
analysis problem is undecidable for that model. 5 Following this,
a number of access control models were designed in which safety
analysis is more tractable, e.g., [22, 24]. While those models were
designed mainly with tractability in mind, we aim to provide more
practical results, by starting with more a realistic model, based on
ARBAC97 [25], and identifying properties of typical policies that
can be exploited for efﬁcient analysis. Our framework allows fea-
tures not considered in those papers, such as negative precondi-
tions.
Finally, we focus on prior work on analysis of ARBAC policies.
Schaad and Moffett [29] use the Alloy analyzer [14] to check
separation of duty properties for ARBAC97. They do not consider
preconditions for any operations; this greatly simpliﬁes the analysis
problem. Since they leave the analysis to the Alloy analyzer, they
do not present analysis algorithms or complexity results.
Li and Tripunitara [20] give algorithms and complexity results
for various analysis problems—primarily safety, availability, and
containment—for two restricted versions of ARBAC97, called AATU
and AAR. Their results are based on Li, Mitchell, and Winsbor-
ough’s results for analysis of trust management policies [19]. Our
work goes signiﬁcantly beyond their analyses for both AATU and
AAR by allowing negative preconditions and thereby SMER (static
mutually exclusive roles) constraints. This forces us to consider
other (more realistic) restrictions, such as bounds on the size of pre-
conditions, and to use ﬁxed-parameter tractability to characterize
the complexity of our algorithms. In addition, our work in Section
5 goes signiﬁcantly beyond their analysis for AAR by dropping the
separate administration restriction. Sistla and Zhou [30], like [19],
consider trust management policies changing in accordance with
role restrictions that indicate, for each role, whether arbitrary rules
deﬁning that role may be added, and whether they may be removed.
The administrative policies we consider are ﬁner-grained than such
role restrictions.
Sasturkar et al. [27] present algorithms and complexity results
for analysis of ARBAC policies subject to a variety of restrictions.
Our work goes beyond theirs by providing efﬁcient algorithms for
larger and more realistic classes of policies, providing ﬁxed-parameter
tractability results to more accurately characterize the complexity
of those algorithms, and giving analysis algorithms that do not rely
on the the separate administration restriction, which is implicitly
adopted throughout their paper. Also, they do not consider contain-
ment analysis.
Case Studies. Our ARBAC policy for a university contains signif-
icantly more can_assign rules than the ARBAC policies presented
in [25, 28, 23, 29, 17, 5, 27, 20, 18], which typically contain about
4 administrative roles and the equivalent of 4 to 7 can_assign
rules.6 Some papers, such as [28, 17], sketch the general struc-
5That result does not apply to ARBAC policy analysis, because the
HRU model allows creation of subjects and objects, while ARBAC
does not allow creation of users, roles, or permissions.
6In some cases, a few rules are duplicated, e.g., copied with change
only to the name of the department; we did not count the duplicates,
since we did not include such duplicates in our university policy.
Also, we did not count other kinds of rules, e.g., can_assignp; there
are only a few of those, too.
[16] S. Jha and T. Reps. Model-checking SPKI-SDSI. Journal of
Computer Security, 12:317–353, 2004.
[17] A. Kern, A. Schaad, and J. Moffett. An administration
concept for the enterprise role-based access control model. In
Proc. 8th ACM Symposium on Access Control Models and
Technologies (SACMAT). ACM Press, 2003.
[18] N. Li and Z. Mao. Administration in role based access
control. In Proc. ACM Symposium on InformAtion, Computer
and Communications Security (ASIACCS), Mar. 2007.
[19] N. Li, J. C. Mitchell, and W. H. Winsborough. Beyond
proof-of-compliance: Security analysis in trust management.
Journal of the ACM, 52(3):474–514, 2005.
[20] N. Li and M. V. Tripunitara. Security analysis in role-based
access control. ACM Transactions on Information and
System Security, 9(4):391–420, Nov. 2006.
[21] R. J. Lipton. Reduction: A method of proving properties of
parallel programs. Communications of the ACM,
18(12):717–721, 1975.
[22] R. J. Lipton and L. Snyder. A linear time algorithm for
deciding subject security. J. ACM, 24(3):455–464, July 1977.
[23] S. Oh and R. S. Sandhu. A model for role administration
using organization structure. In Proc. 7th ACM Symposium
on Access Control Models and Technologies (SACMAT).
ACM Press, 2002.
[24] R. Sandhu. The typed access matrix model. In Proc. IEEE
Symposium on Security and Privacy, pages 122–136, 1992.
[25] R. Sandhu, V. Bhamidipati, and Q. Munawer. The ARBAC97
model for role-based administration of roles. ACM
Transactions on Information and Systems Security (TISSEC),
2(1):105–135, Feb. 1999.
[26] R. Sandhu, E. Coyne, H. Feinstein, and C. Youman.
Role-based access control models. IEEE Computer,
29(2):38–47, Feb. 1996.
[27] A. Sasturkar, P. Yang, S. D. Stoller, and C. Ramakrishnan.
Policy analysis for administrative role based access control.
In Proc. 19th IEEE Computer Security Foundations
Workshop (CSFW), July 2006.
[28] A. Schaad, J. Moffett, and J. Jacob. The role-based access
control system of a European bank: A case study and
discussion. In Proc. 6th ACM Symposium on Access Control
Models and Technologies (SACMAT), pages 3–9. ACM
Press, 2001.
[29] A. Schaad and J. D. Moffett. A lightweight approach to
speciﬁcation and analysis of role-based access control
extensions. In Proc. 7th ACM Symposium on Access Control
Models and Technologies (SACMAT), pages 13–22. ACM
Press, 2002.
[30] A. P. Sistla and M. Zhou. Analysis of dynamic policies. In
Joint Workshop on Foundations of Computer Security and
Automated Reasoning for Security Protocol Analysis
(FCS-ARSPA), Aug. 2006. Full version to appear in
Information & Computation.
[31] www.cs.stonybrook.edu/~stoller/ccs2007/.
ture of RBAC and ARBAC policies of very large organizations, but
only a few speciﬁc administrative roles and rules are presented in
the paper (or otherwise made publicly available), and no analysis
algorithms were applied to those policies. We analyzed our AR-
BAC policy for a university. The policy contains 11 administrative
roles, 21 other roles, 28 can_assign rules (106 rules after the trans-
formation to eliminate role hierarchy), etc.
10. REFERENCES
[1] American National Standards Institute (ANSI), International
Committee for Information Technology Standards (INCITS).
Role-based access control. ANSI INCITS Standard
359-2004, Feb. 2004.
[2] A. K. Bandara, E. C. Lupu, and A. Russo. Using event
calculus to formalise policy speciﬁcation and analysis. In
Proc. 4th IEEE Workshop on Policies for Distributed Systems
and Networks (Policy 2003), 2003.
[3] M. Y. Becker. Cassandra: Flexible Trust Management and
its Application to Electronic Health Records. PhD thesis,
University of Cambridge, Oct. 2005.
[4] E. M. Clarke, Jr., O. Grumberg, and D. A. Peled. Model
Checking. MIT Press, 1999.
[5] J. Crampton. Understanding and developing role-based
administrative models. In Proc. 12th ACM Conference on
Computer and Communications Security (CCS), pages
158–167. ACM Press, 2005.
[6] R. G. Downey and M. R. Fellows. Fixed-parameter
tractability and completeness I: Basic results. SIAM Journal
on Computing, 24(4):873–921, 1995.
[7] M. Evered and S. Bögeholz. A case study in access control
requirements for a health information system. In Proc.
Australasian Information Security Workshop 2004 (AISW),
volume 32 of Conferences in Research and Practice in
Information Technology, 2004.
[8] K. Fisler, S. Krishnamurthi, L. A. Meyerovich, and M. C.
Tschantz. Veriﬁcation and change-impact analysis of
access-control policies. In International Conference on
Software Engineering (ICSE), pages 196–205, 2005.
[9] P. Godefroid. Partial-Order Methods for the Veriﬁcation of
Concurrent Systems, volume 1032 of Lecture Notes in
Computer Science. Springer-Verlag, 1996.
[10] J. D. Guttman, A. L. Herzog, J. D. Ramsdell, and C. W.
Skorupka. Verifying information ﬂow goals in
Security-Enhanced Linux. Journal of Computer Security,
13(1):115–134, 2005.
[11] J. Y. Halpern and V. Weissman. Using ﬁrst-order logic to
reason about policies. In Proc. 16th IEEE Computer Security
Foundations Workshop (CSFW), pages 187–201. IEEE
Computer Society Press, 2003.
[12] M. A. Harrison, W. L. Ruzzo, and J. D. Ullman. Protection in
operating systems. Communications of the ACM,
19(8):461–471, 1976.
[13] K. Irwin, T. Yu, and W. H. Winsborough. On the modeling
and analysis of obligations. In In Proc. 13th ACM
Conference on Computer and Communications Security
(CCS), pages 134–143, Nov. 2006.
[14] D. Jackson, I. Schechter, and I. Shlyakhter. Alcoa: the alloy
constraint analyzer. In Proc. 22nd International Conference
on Software Engineering (ICSE), pages 730–733, June 2000.
[15] S. Jajodia, P. Samarati, and V. S. Subrahmanian. A logical
language for expressing authorizations. In Proc. 1997 IEEE
Symposium on Security and Privacy, pages 31–42, 1997.