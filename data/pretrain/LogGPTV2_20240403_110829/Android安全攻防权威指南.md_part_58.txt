文件。
·索尼
索尼使用索尼更新服务（SUS）工具来发布固件。另外，社区XperiaFirmware提供了很多设
备的固件镜像下载。索尼设备的固件使用FTF格式，事实上只是一个zip文件。然面，固件的很
多组件都有专有的文件格式，我们最关注的文件是kemel.sin。与其他OEM不同，索尼并不使用
boot.img的格式。一个叫作Andoxyde的工具尽管非常庞大，但是支持从这个格式中提取内核。
另外，Binwalk和dd工具也能够做到这一点。Binwalk工具可以从中提取出一个ELF文件和两个
gzip文件流，第一个gzip文件流就是你想要的zlmage文件。
10.2.2从设备中提取内核
与从原厂固件中提取内核不同，不管是什么设备类型（型号、厂商、运营商等）直接从设
备中提取内核的方法都大致相同。通用的步骤包括：找到对应的分区，把内容dump出来，然后
进行提取。
有很多方法可以找到哪个分区中有bootimg的数据。首先，可以使用/dev/block/platform中
SoC特性条目中的by-name目录：
she119android: /data/1oca1/tmp $ cd /dev/block/platform/*/by-name
she118android:/dev/block/platform/msm_sdcc. 1/by-name $ 1s -1 boot
lrwxrwxrwx root root
1970-01-02 11:28 boot -> /dev/b1ock/mmcb1k0p20
10
警告一些设备在by-name目录中也有一个aboot条目。写boot分区的时候，小心别写入这
个aboot分区，这会让你的设备变砖。
可以直接使用这个软链接目录，也可以使用它指向的块设备。另外一种方法是，根据每个分
区的前几字节来判断：
rootBandroid:/data/local/tsp/keznel  for ii in /dev/bloek/m*: Go 1
dd if=$ii of=$BASE count=1 2> /dev/nu11: \
BAsg=* ./bueybox basenane SI1* :\
done
---
## Page 262
246
第10章攻击内核
rootfandroid:/data/local/tmp/kernel + grep ANDROID *
Binary fi1e mmcblk0p21 satches
Binary file mmcb1k0p20 matches
不幸的是，这样会找到两个匹配结果（可能更多）boot和recovery分区使用了相同的格式，
可以根据头部信息区分出boot分区，因为与rcovery分区相比，boot分区的ramdisk_size更小。
现在就可以从设备分区中dump数据了。要注意的是，从分区中dump出来的数据中包含一
些无用数据，面从原厂固件中提取出来的镜像才是有用的。所以，从分区中直接dump出的文件
要比出厂的 boot.img大一些。可以使用 dd工具来dump分区：
root9android:/data/1oca1/tmp/kernel # dd \
1f=/dev/block/platform/omap/omap_hsrmc,0/byname/boot of=curboot. img
16384+0 records in
8388608 bytes transferred in 1.635 secs (5130647 bytes/sec)
16384+0 records out
root9android:/data/1oca1/tmp/kernel 1 chmod 644 *.img
rootBandroid:/data/1oca1/tmp/kernel #
从 boot分区中dump出cur-bootimg文件后，使用chmod 修改权限，让ADB用户可以从设
备中取出文件，取出的命令如下：
dev:~/android/src/kernel/omap $ mkdir staging && cd $_
dev:~/android/src/kernel/omap/staging $ adb pu11 1
2379 KB/s (8388608 bytes in 3.442s)
/Gata/1ocal/tsp/kernel/curboot.ing
最后一步是从启动镜像中提取内核。
10.2.3从启动镜像中提取内核
Android设备启动Linux内核的时候有两种模式：第一种是正常的启动过程，使用boot分区；
第二种是启动恢复过程，使用recovery分区。这两种分区的底层结构是相同的，都有一个短的头
部，一个压缩后的内核，以及一个内存盘（initrd）镜像。在正常启动过程中，压缩的内核对于系
统安全来说是至关重要的，所以重点在于获得这个内核。
boot.img和recovery.img文件由三个部分组成。文件的最前面是一个头部，包含用于识别文
件格式的信息，以及文件其余部分的基本信息。关于这个头部结构的更多信息，请查看AOSP代
码仓库中的 system/core/mkboot img/bootimg.h文件。这个结构中的page_size域非常重要，因
为内核和initd镜像会与这个大小的块边界对齐。
压缩的内核就位于头部之后的下一个块边界。它的大小存储在头部结构的kernel_size域
当中。initrd镜像则开始于之后的块边界。
手动提取这些部分是很乏味的。AOSP中的mkbootimg工具可以用来从源码构建系统镜像
但是并不能用来提取镜像。于是，基于mkbootimg的工具abootimg诞生了，它能够解开镜像
文件，如下所示：
dev:~/android/n5 /hammerheadkrt16m/Lmg S mikdix boot && cd $_
dev:~/android/n5/hammerheadkrt16m/img/boot $ abootimg -X  ./boot.img
---
## Page 263
10.3运行自定义内核代码247
writing boot inage config in booting.cfg
extracting kernel in zImage
extracting ramdisk in initrd.ing
这样就可以得到想要的zlmage文件。
10.2.4解压内核
进一步分析内核二进制文件，就需要解压zImage。Linux内核支持三种不同的压缩算法：gzip、
lzma和Izo。总的来说，大多数Android内核使用传统的gzip算法。Linux内核中包含一个脚本
scripts/extxact-vmlinux，但是它在Android内核上不起作用，所以必须手动解压内核。感
谢Binwalk工具，大大简化了这个过程：
dev:~/android/n5/hammerhead-krt16m/img/boot $ binwa1k zInage 1 head
[ - - - ]
21981
0x48B4
date: Wed Dee 31 18:00:00 1969, max comgres8ion
gzip compressed data, from Unix, NULL
dev:~/android/n5/hammerhead-krt16m/img/boot $ dd if=zImage bs=18612 \
[ - - - ]
A66fd < po- dtz5 1t=dyxs
上面第二个命令把dd的输出传给gzip命令来解压缩。得到解压后的镜像，就可以从中提
取细节，或者使用IDAPro来分析内核代码。本章后面的几节会讨论如何从解压后的内核中提取
特定信息。
10.3运行自定义内核代码
在攻击内核时，如果能在其中引人一些新的代码，会非常有用。你可以使用自定义的内核模
块来监控内核的行为。修改内核的选项，可以开启一些强大的特性，例如远程调试。不管处于哪
种情况，如果不利用内核漏洞，都需要使用Android和Linux内核工具来编译新的代码。本节会
带你了解获取内核源代码，配置编译环境，配置内核，编译自定义内核模块，再把新代码加载到
基于AOSP以及由 OEM提供的 Android设备的整个过程。本章以基于AOSP的Galaxy Nexus 和
Sprint版三星Galaxy S3手机作为示例。
10.3.1获取源代码
在为设备编译自定义的模块或内核之前，必须获得源代码。得到源代码的方式多种多样，取
决于设备的内核由谁负责。谷歌提供了AOSP支持设备的内核Git仓库，而OEM可能使用了不
同的方法来分发内核源代码。因为Linux内核以GNU公开许可证（GPL）第二版来发布，所以
发布源代码，包括对内核进行修改，是厂商的法定义务。
注意找不到内核源代码时，可以直接联系厂商要求其发布源代码。如果需要，提醒他们要合
法遵守Linux内核的GPL协议。
---
## Page 264
248
第10章攻击内核
在大多数情况下，都能直接获取特定设备的内核源代码，但有一些情况会比较困难。例如
OEM和谷歌在发布新设备的时候，很晚才会提供内核源代码。一般来说，暂时无法获得少数内
核源代码的时候，只要耐心等待即可。
1.获取AOSP内核源代码
谷歌的Nexus系列Android产品线已经成为了开发者的参考实现。可以获得系统中几乎所有
的源代码，包括内核。Nexus设备的源代码能够非常直接地得到；找到设备使用哪一个版本的内
核源代码也很容易、但并不是一步就能做到的。在AOSP当中两个特定的地方，可以找到内核相
关的信息：第一个地方包含了跟设备家族相关的内核信息：第二个包含了不同的内核源代码树。
本节会以搭载Android4.2.2系统的GalaxyNexus为例，介绍如何根据这两个地方来找到准确的
内核源代码。
谷歌把设备相关的代码仓库放在AOSP中的device目录。这些仓库包含Makefile、overlay、
头文件、配置文件，还有名为kermel的内核二进制文件一这个文件特别重要，因为根据它的历
史就能找到编译时使用的源代码。关于这些仓库，谷歌在AOSP文档中提供了相关信息，地址为
http://source.android.com/source/building-kemels.html。在这些仓库中，kernel 文件的 commit 信息
和文档，都要落后于新设备的发布，因此这些仓库仅用来建立设备到芯片的关联。图10-1提供
了一些AOSP支持设备到芯片的映射关系，包括内核。
机型
Nexus 7 2013 Wi-F1
MSM
Nexus 7 2013 Mobile
MSM
Nexus 10
Exynos 5
Nexus 4
Tegra
MSM
Nexus 7 2012 Wi-Fi
Galaxy Nexus
Nexus 7 2012 Mobile
Tegra
OMAP
Galaxy Nexus CDMA/LTE
OMAP
Pandaboard
Tegra
OMAP
Motorola Xoom Verizon
Motorola Xoom Wi-Fi
Exynos3
Tegm
Nexas S
Nexus S 4G
Exynos 3
图10-1AOSP设备到芯片的映射
正如第3章中提到的，通常可以使用/dev/block/platform目录下的条目，来确定设备使用的
芯片。
she11eandroid: /dev/block/platform S 18
onap
知道了设备的SoC制造商之后，就能用Git来从谷歌获得内核源代码。AOSP为每一个支持
的SoC设置了一个Git仓库。图10-2展示了谷歌支持的每一个SoC内核树的仓库名称。
---
## Page 265
10.3运行自定义内核代码
249
SoC
内核名称
MSM
Exynos 5
tegra
sou(x3
Tegra
OMAP
samsung
omap
Exynos 3
Emulator
_goldfish
图10-2SoC的内核名称
在图10-1中，可以看到目标设备是基于OMAPSoC的，下面的命令展示了如何clone对应
的内核源代码：
dev:~/android/sre $ mikdir kernel && cd S_
dev:~/android/sre/keznel $ git clone \
https://android.googlesource,com/kezne1l/omap .git
Cloning into 'omap'...
renote: Counting objects: 41264, done
renote: Finding sources: 100t (39/39)
remote: Getting sizes: 100s (24/24)
renote: Compressing objects: 100% (24/24)
Receiving objects: 100e (2117273/2117273), 441.45 MiB | 1.79 MiB/s, done
remote: Total 2117273 (delta 1769060), reused 2117249 (delta 1769054)
Reso1ving delta8: 100s (1769107/1769107), done.
clone操作完成后，就在master分支得到了一个仓库。然面，你会注意到在当前工作目录下
没有文件。