### Adversary Learning in Multi-Query Notion

In each query, the adversary learns either the homomorphically evaluated ciphertext (from Add) or the simulated ciphertext (from S). This multi-query notion is particularly useful for arguing multi-theorem zero-knowledge when compiling a linear PCP into a preprocessing SNARG [30]. Definition C.3 implies this multi-query variant through a standard hybrid argument.

### Linear PCP Implementation Details

This section provides a detailed description of our multi-point evaluation and interpolation approach, as outlined in Section 4.1. Following [20], for a polynomial \( A(z) \) of degree less than \( |D| \), we denote the vector of evaluations \( (A(\alpha))_{\alpha \in D} \) by \( \text{FFT}_D(A(z)) \). Similarly, \( \text{FFT}^{-1}_D((A'(\alpha))_{\alpha \in D}) \) denotes the coefficients of the polynomial \( A \) (of degree less than \( |D| \)) where \( A(\alpha) = A'(\alpha) \) for all \( \alpha \in D \).

Let \( \omega \in \mathbb{F} \) be a primitive \( 2d \)-th root of unity, and let \( H = H_1 = \langle \omega \rangle \subset \mathbb{F} \) be the subgroup of order \( 2d \) generated by \( \omega \) (consisting of the \( 2d \)-th roots of unity). Let \( \xi_1 = 1 \) and take \( \xi_2, \ldots, \xi_i \in \mathbb{F}^* \setminus H_1 \) such that the cosets \( H_i = \xi_i H_1 \) are all pairwise disjoint. We define the domain to be \( D = \bigcup_{i \in [k]} H_i \). For a set \( S \subset \mathbb{F} \), let \( V_S \in \mathbb{F}^{|D| \times |D|} \) be the Vandermonde matrix associated with evaluating a polynomial of degree up to \( |D| - 1 \) on the points in \( D \). Let \( \hat{V}_H \in \mathbb{F}^{2d \times 2d} \) be the Vandermonde matrix associated with evaluating a polynomial of degree up to \( 2d \) on \( H \) (i.e., the roots of unity). Then, we have:

\[
\Xi_2 V_S = 
\begin{pmatrix}
\hat{V}_H & \hat{V}_H \cdot \xi_2 & \cdots & \hat{V}_H \cdot \xi_k \\
\hat{V}_H \cdot \xi_2^{2d} & \hat{V}_H \cdot \xi_2^{2d+1} & \cdots & \hat{V}_H \cdot \xi_k^{2d+1} \\
\vdots & \vdots & \ddots & \vdots \\
\hat{V}_H \cdot \xi_2^{(k-1)2d} & \hat{V}_H \cdot \xi_2^{(k-1)2d+1} & \cdots & \hat{V}_H \cdot \xi_k^{(k-1)2d+1}
\end{pmatrix}
\]

Given any input \( a \in \mathbb{F}^{k \cdot 2d} \), and for \( i \in [k] \), let \( \hat{a}_i = (a_{(i-1)2d+1}, \ldots, a_{i \cdot 2d}) \in \mathbb{F}^{2d} \). We describe an algorithm to compute \( a' = V_S a \):

1. **Compute \( \hat{a}'_i \):**
   \[
   \hat{a}'_i = \hat{V}_H \cdot \left( \sum_{j \in [k]} \xi_j^{(j-1)2d} \Xi_i \hat{a}_j \right)
   \]
   By construction,
   \[
   \hat{a}'_i = \hat{V}_H \cdot \left( \sum_{j \in [k]} \xi_j^{(j-1)2d} \Xi_i \hat{a}_j \right)
   \]

2. **Compute \( \hat{b}_i \):**
   \[
   \hat{b}_i = \sum_{j \in [k]} \xi_j^{(j-1)2d} \Xi_i \hat{a}_j \in \mathbb{F}^{2d}
   \]
   Given \( \hat{b}_i \), computing \( \hat{a}_i = \hat{b}_i \) can be done using a standard radix-2 FFT in \( O(d \cdot 2d) \) time.

3. **Efficient Computation:**
   Naïvely, we can compute \( \hat{b}_i \) in \( O(k \cdot 2d) \) time, so computing all \( b = (\hat{b}_1^T | \cdots | \hat{b}_k^T)^T \in \mathbb{F}^{k \cdot 2d} \) requires \( O(2d k^2) \) time. However, we can do so more efficiently as follows. By definition,
   \[
   \hat{b}_{i,j} = \sum_{\ell \in [k]} \xi_\ell^{(\ell-1)2d} \xi_j^{j-1} \hat{a}_{\ell,j}
   \]
   Now, define \( \tilde{b}_j = (\hat{b}_{1,j}, \ldots, \hat{b}_{k,j}) \in \mathbb{F}^k \), and similarly, let \( \tilde{a}_j = (\hat{a}_{1,j}, \ldots, \hat{a}_{k,j}) \in \mathbb{F}^k \). Then,
   \[
   \tilde{b}_j = \text{diag}(\xi_1^{j-1}, \ldots, \xi_k^{j-1}) \cdot \Xi' \cdot \tilde{a}_j
   \]
   where \( \Xi' \in \mathbb{F}^{k \times k} \) is itself a Vandermonde matrix corresponding to evaluating a degree \( (k-1) \) polynomial on the points \( \xi_1^{2d}, \ldots, \xi_k^{2d} \). While \( \xi_1^{2d}, \ldots, \xi_k^{2d} \) are not roots of unity (so standard FFTs cannot be used here), we can still solve this problem efficiently if \( \xi_1, \ldots, \xi_k \) form a geometric sequence (i.e., \( \xi_i = \alpha \xi_{i-1} \) for some fixed \( \alpha \in \mathbb{F} \)) [39]. Using the Bostan-Schost algorithms, multipoint evaluation on \( k \) values in a geometric sequence requires computing 2 degree-\( k \) polynomial multiplications and \( O(k) \) additional work. In the case where \( k < 2^{d-1} \), we can use standard radix-2 FFTs to implement the degree-\( k \) polynomial multiplications in \( O(k \log k) \) time. Thus, computing each \( \tilde{b}_j \) can be done in just \( O(k \log k) \) time. Repeating this for all \( j \in [2d] \) yields an algorithm to compute \( b \) in \( O(2d k \log k) \) time. The overall running time of this algorithm is \( O(2d k (d + \log k)) \), which matches the running time of a standard FFT over a domain of size \( k \cdot 2d \). While the concrete efficiency of the algorithm is worse than a standard radix-2 FFT, in fields with insufficient roots of unity, this provides an efficient algorithm to implement the linear PCP prover. In all of our experiments, \( k \leq 64 \).

### Implementation Details

In our implementation, we set \( \xi_i = g^{2(i-1)\omega} \) for \( i \in [k] \), where \( g \) is a multiplicative generator of \( \mathbb{F}^* \). This enables efficient implementation of multipoint evaluation over the set \( D \) as well as the set \( gD = \{g^h \mid h \in D\} \) (needed for efficient implementation of the linear PCP prover algorithm; see [20] for further details).

**Lagrange Interpolation and Inverse FFTs:**
In addition to computing \( \text{FFT}_D \), the linear PCP prover needs to compute the inverse operation \( \text{FFT}^{-1}_D \). This follows immediately from our algorithm above by inverting each of the steps (i.e., replace both sets of FFTs with their corresponding inverse FFTs).

The query-generation algorithm QLPCP in Claim A.6 (Construction B.1) essentially reduces to multiple Lagrange polynomial evaluations (with basis \( D \)) at a random field element. Ben-Sasson et al. [20] described an efficient implementation of this when the domain \( D \) is the roots of unity. In our setting (working over a field with insufficient roots of unity), we augment \( D \) with cosets of the roots of unity. The Ben-Sasson et al. algorithm directly generalizes to this setting, and we refer to [20, Appendix E] for the details.

### The Power Diffie-Hellman Assumption Over Small Fields

In this section, we briefly recall the \( q \)-power Diffie-Hellman assumption introduced by Groth [74] and subsequently used as the basis for both pairing-based SNARKs [64, 87] as well as lattice-based SNARKs [65]. Following [65], we formulate the assumption with respect to a linear encoding scheme, which captures both the pairing-based instantiation as well as the lattice-based instantiation.

**Definition E.1 (Linear Encoding Scheme):**
A (secret-key) linear encoding scheme \( \Pi_{\text{Enc}} \) over a finite field \( \mathbb{F} \) is a tuple of algorithms \( \Pi_{\text{Enc}} = (\text{Setup}, \text{Encode}, \text{Add}) \) with the following properties:
- **Setup(1\(\lambda\)) → (pk, sk):** On input the security parameter \( \lambda \), the setup algorithm outputs a public evaluation key \( pk \) and a secret encoding key \( sk \).
- **Encode(sk, \( x \)) → enc\( x \):** On input the secret key \( sk \) and an element \( x \in \mathbb{F} \), the encoding algorithm outputs an encoding \( \text{enc}_x \) of \( x \).
- **Add(pk, (enc1, …, encd), (α1, …, αd)) → enc′:** On input the public key \( pk \), encodings \( \text{enc}_1, \ldots, \text{enc}_d \) and coefficients \( \alpha_1, \ldots, \alpha_d \in \mathbb{F} \), the add algorithm outputs a new encoding \( \text{enc}' \).

The encoding scheme is \( d \)-linear if for all values \( k \leq d \), values \( x_1, \ldots, x_k \in \mathbb{F} \), scalars \( \alpha_1, \ldots, \alpha_k \in \mathbb{F}^d \), and sampling \( (pk, sk) \leftarrow \text{Setup}(1\lambda) \), \( \text{enc}_i \leftarrow \text{Encode}(sk, x_i) \) for all \( i \in [k] \), we have that
\[
\Pr[\text{Add}(pk, (\text{enc}_1, \ldots, \text{enc}_k), (\alpha_1, \ldots, \alpha_k)) \in S] = 1 - \text{negl}(\lambda),
\]
where \( S \) denotes the support of \( \text{Encode}(sk, \sum_{i \in [k]} \alpha_i x_i) \).

**Definition E.2 (q-Power Diffie-Hellman Assumption [65, 74]):**
Fix a parameter \( q \in \mathbb{N} \). A linear encoding scheme \( \Pi_{\text{Enc}} = (\text{Setup}, \text{Encode}, \text{Add}) \) over a field \( \mathbb{F} \) satisfies the \( q \)-power Diffie-Hellman assumption (q-PDH) if for all efficient adversaries \( A \), and sampling \( r \leftarrow \mathbb{F} \), \( \text{enc}_i \leftarrow \text{Encode}(sk, s_i) \) for all \( i \in \{0, \ldots, 2q\} \), \( \sigma \leftarrow (pk, \text{enc}_0, \ldots, \text{enc}_q, \text{enc}_{q+2}, \ldots, \text{enc}_{2q}) \), we have that
\[
\Pr[A(1\lambda, \sigma) \in S] = \text{negl}(\lambda),
\]
where \( S \) is the set of encodings in the support of \( \text{Encode}(sk, s_{q+1}) \).

**Lemma E.3 (q-PDH Assumption over Small F):**
Let \( \Pi_{\text{Enc}} = (\text{Setup}, \text{Encode}, \text{Add}) \) be a \( d \)-linear encoding scheme over a finite field \( \mathbb{F} \). If \( d \geq 2q \), there exists an adversary that runs in time \( \text{poly}(q, \log |\mathbb{F}|) \) and wins the \( q \)-PDH security game for \( \Pi_{\text{Enc}} \) with advantage \( 2q/|\mathbb{F}| \).

**Proof:**
The adversary \( A \) starts by choosing \( 2q \) distinct points \( z_1, \ldots, z_{2q} \in \mathbb{F} \), and forms the polynomial \( f(x) = \prod_{i \in [2q]} (x - z_i) \). Write this as \( f(x) = \sum_{i=0}^{2q} \alpha_i x^i \). Then, for all \( i \in [2q] \), \( z_{q+1} = -\alpha_{q+1}^{-1} \sum_{j \neq q+1} \alpha_j z_j \). Let \( (pk, \text{enc}_0, \ldots, \text{enc}_q, \text{enc}_{q+2}, \ldots, \text{enc}_{2q}) \) be the \( q \)-PDH challenge. Here, \( \text{enc}_i \) is an encoding of \( s_i \), where \( s \in \mathbb{F} \) is sampled by the \( q \)-PDH challenger at the beginning of the experiment. Since \( d \geq 2q \), the adversary can homomorphically compute an encoding of \( -\alpha_{q+1}^{-1} \sum_{i \neq q+1} \alpha_i s_i \). By the above analysis, if \( s \in \{z_1, \ldots, z_{2q}\} \), then this quantity is exactly \( s_{q+1} \). Since \( s \) is uniform and independent of \( z_1, \ldots, z_{2q} \), the probability that \( s \in \{z_1, \ldots, z_{2q}\} \) is exactly \( 2q/|\mathbb{F}| \), which proves the claim.
\[
\blacksquare
\]

**Remark E.4 (q-Power Diffie-Hellman Assumption over Small F):**
When the \( q \)-PDH assumption is used for constructing pairing-based zkSNARKs [64, 74, 87], the size of the underlying field \( \mathbb{F} \) is super-polynomial (i.e., \( |\mathbb{F}| = 2^{\Omega(\lambda)} \)). In this case, the attack in Lemma E.3 has negligible advantage. Indeed, the \( q \)-PDH assumption plausibly holds over standard pairing-based groups and holds unconditionally in the generic (bilinear) group model [74].

In the lattice-based zkSNARK of Gennaro et al. [65], they consider fields of polynomial size. Unfortunately, Lemma E.3 shows that the \( q \)-PDH assumption does not hold for encoding schemes over fields of polynomial size. For the specific instantiation proposed by Gennaro et al., \( q \approx 2^{16} \) and \( |\mathbb{F}| \approx 2^{32} \), so Lemma E.3 gives an attack on \( q \)-PDH with advantage \( 2q/|\mathbb{F}| = 2^{-15} \). Since their zkSNARK relies on the hardness of the \( q \)-PDH assumption for soundness, this means that their suggested parameters provide at best 15 bits of provable soundness. To obtain 128-bits of soundness, it would be necessary to either apply soundness amplification (which increases all parameters by a factor of \( 128/15 \approx 8.5 \)) or instantiate the Regev-based encoding scheme over a super-polynomial size field (which would also incur additional overhead).

In this work, we work over small (polynomial-size) fields and use parallel repetition (at the linear PCP level) for soundness amplification (see Remark A.7). This increases the number of linear PCP queries, but since we encrypt vectors of queries, the overhead for parallel amplification is additive rather than multiplicative in the number of repetitions. This yields a much more efficient construction.