on each query, the adversary learns either the homomorphically-
evaluated ciphertext (from Add) or the simulated ciphertext (from
S). This multi-query notion is useful to argue multi-theorem zero
knowledge when compiling a linear PCP into a preprocessing
SNARG [30]. Definition C.3 implies this multi-query variant by
a standard hybrid argument.
D LINEAR PCP IMPLEMENTATION DETAILS
In this section, we provide a more detailed description of our multi-
point evaluation and interpolation approach outlined in Section 4.1.
Following [20], for a polynomial ğ´(ğ‘§) of degree less than |ğ·|, we
write FFTğ·(ğ´(ğ‘§)) to denote the vector of evaluations (ğ´(ğ›¼))ğ›¼âˆˆğ·.
Similarly, we write FFTâˆ’1
ğ· ((ğ´â€²(ğ›¼))ğ›¼âˆˆğ·) to denote the coefficients
of the polynomial ğ´ (of degree less than |ğ·|) where ğ´(ğ›¼) = ğ´â€²(ğ›¼)
for all ğ›¼ âˆˆ ğ·.
Let ğœ” âˆˆ F be a primitive 2ğ‘‘-th root of unity and ğ» = ğ»1 = âŸ¨ğœ”âŸ© âŠ‚
F be the subgroup of order 2ğ‘‘ generated by ğœ” (consisting of the
2ğ‘‘-th roots of unity). Let ğœ‰1 = 1 and take ğœ‰2, . . . , ğœ‰ğ‘– âˆˆ Fâˆ— \ ğ»1 such
that the cosets ğ»ğ‘– = ğœ‰ğ‘–ğ»1 are all pairwise disjoint. We define the
domain to be ğ· =ğ‘–âˆˆ[ğ‘˜] ğ»ğ‘–. For a set ğ‘† âŠ‚ F, let Vğ‘† âˆˆ F|ğ·|Ã—|ğ·| be
the Vandermonde matrix associated with evaluating a polynomial
of degree up to |ğ·| âˆ’ 1 on the points in ğ·. Let Ë†Vğ» âˆˆ F2ğ‘‘Ã—2ğ‘‘ be the
Vandermonde matrix associated with evaluation a polynomial of
degree up to 2ğ‘‘ on ğ» (i.e., the roots of unity). Then, we have that
...
Î2
Vğ‘† =
Ë†Vğ»
2
Ë†Vğ» Â· Îğ‘˜
Ë†Vğ»
Ë†Vğ» Â· Î2
Ë†Vğ» Â· ğœ‰ (ğ‘˜âˆ’1)2ğ‘‘
Ë†Vğ»
Ë†Vğ» Â· ğœ‰2ğ‘‘
2 Î2
...
Ë†Vğ» Â· ğœ‰2ğ‘‘
Îğ‘˜
ğ‘– , . . . , ğœ‰2ğ‘‘âˆ’1
Â· Â· Â·
Â· Â· Â·
. . .
Â· Â· Â·
). Take any input a âˆˆ Fğ‘˜Â·2ğ‘‘ , and
where Îğ‘– = diag(1, ğœ‰ğ‘–, ğœ‰2
for ğ‘– âˆˆ [ğ‘˜], let Ë†ağ‘– = (ğ‘(ğ‘–âˆ’1)2ğ‘‘+1, . . . , ğ‘ğ‘–Â·2ğ‘‘) âˆˆ F2ğ‘‘ . We describe an
algorithm to compute aâ€² = Vğ‘† a:
(ğ‘–âˆ’1)2ğ‘‘+1, . . . , ğ‘â€²
â€¢ Let Ë†aâ€²
ğ‘–Â·2ğ‘‘
Ë†Vğ» Â· ğœ‰ (ğ‘˜âˆ’1)2ğ‘‘
Îğ‘˜
...
ğ‘˜
ğ‘˜
ğ‘–
 ,
(cid:1). By construction,

Îğ‘– Ë†ağ‘—(cid:170)(cid:174)(cid:172) .
ğœ‰ ( ğ‘—âˆ’1)2ğ‘‘
ğ‘–
Ë†aâ€²
ğ‘– =(cid:0)ğ‘â€²
ğ‘– = Ë†Vğ» Â·(cid:169)(cid:173)(cid:171)
Let Ë†bğ‘– =ğ‘— âˆˆ[ğ‘˜] ğœ‰ ( ğ‘—âˆ’1)2ğ‘‘
the entries in b =(cid:2)Ë†bT1 | Â· Â· Â· | Ë†bT

ğ‘–
Ë†ğ‘ğ‘–,ğ‘— =
ğ‘— âˆˆ[ğ‘˜]
Îğ‘– Ë†ağ‘— âˆˆ F2ğ‘‘ . Given Ë†bğ‘–, computing Ë†ağ‘– =
Ë†bğ‘– can be done using a standard radix-2 FFT in ğ‘‚(ğ‘‘ Â· 2ğ‘‘) time.
Ë†Vğ»
â€¢ NaÃ¯vely, we can compute Ë†bğ‘– in ğ‘‚(ğ‘˜ Â· 2ğ‘‘) time, so computing all of
(cid:3)T âˆˆ Fğ‘˜Â·2ğ‘‘ requires ğ‘‚(2ğ‘‘ğ‘˜2) time.
However we can do so more efficiently as follows. By definition,
ğ‘˜
ğœ‰ (â„“âˆ’1)2ğ‘‘
ğ‘–
ğœ‰ ğ‘—âˆ’1
ğ‘–
Ë†ğ‘â„“,ğ‘— .
â„“âˆˆ[ğ‘˜]
Now, define Ëœbğ‘— = ( Ë†ğ‘1,ğ‘— , . . . , Ë†ğ‘ğ‘˜,ğ‘—) âˆˆ Fğ‘˜, and similarly, let Ëœağ‘— =
( Ë†ğ‘1,ğ‘— , . . . , Ë†ğ‘ğ‘˜,ğ‘—) âˆˆ Fğ‘˜. Then,
ğœ‰
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
ğœ‰2ğ‘‘
1
...
ğœ‰2ğ‘‘
ğ‘˜
2ğ‘‘ (ğ‘˜âˆ’1)
ğ‘˜
2ğ‘‘ (ğ‘˜âˆ’1)
1
Â· Â· Â·
. . .
Â· Â· Â·
Îâ€²
1
...
1
...
ğœ‰
Ëœağ‘— .
Ëœbğ‘— = diag(ğœ‰ ğ‘—âˆ’1
1
, . . . , ğœ‰ ğ‘—âˆ’1
ğ‘˜
)
ğ‘˜
ğ‘˜
. While ğœ‰2ğ‘‘
1 , . . . , ğœ‰2ğ‘‘
1 , . . . , ğœ‰2ğ‘‘
Observe now that Îâ€² âˆˆ Fğ‘˜Ã—ğ‘˜ is itself a Vandermonde matrix
corresponding to evaluating a degree (ğ‘˜ âˆ’ 1) polynomial on
the points ğœ‰2ğ‘‘
are not roots of unity
(so standard FFTs cannot be used here), we can still solve this
problem efficiently if ğœ‰1, . . . , ğœ‰ğ‘˜ form a geometric sequence (i.e.,
ğœ‰ğ‘– = ğ›¼ğœ‰ğ‘–âˆ’1 for some fixed ğ›¼ âˆˆ F) [39]. In particular, using the
Bostan-Schost algorithms, multipoint evaluation on ğ‘˜ values in
a geometric sequence requires computing 2 degree-ğ‘˜ polynomial
multiplications and ğ‘‚(ğ‘˜) additional work. In the case where ğ‘˜ <
2ğ‘‘âˆ’1, we can use standard radix-2 FFTs to implement the degree-ğ‘˜
polynomial multiplications in ğ‘‚(ğ‘˜ log ğ‘˜) time. Thus, computing
each Ëœbğ‘— can be done in just ğ‘‚(ğ‘˜ log ğ‘˜) time. Repeating this for all
ğ‘— âˆˆ [2ğ‘‘] yields an algorithm to compute b in ğ‘‚(2ğ‘‘ğ‘˜ log ğ‘˜) time.
The overall running time of this algorithm is ğ‘‚(2ğ‘‘ğ‘˜(ğ‘‘ + log ğ‘˜)),
which matches the running time of a standard FFT over a domain
of size ğ‘˜ Â·2ğ‘‘. While the concrete efficiency of the algorithm is worse
than a standard radix-2 FFT, in fields where there are insufficient
roots of unity (such as the ones we consider), this provides an
efficient algorithm to implement the linear PCP prover. In all of our
experiments, ğ‘˜ â‰¤ 64.
Session 1C: Zero Knowledge I CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea231In our implementation, we set ğœ‰ğ‘– = ğ‘”2(ğ‘–âˆ’1)ğœ” for ğ‘– âˆˆ [ğ‘˜], where
ğ‘” is a multiplicative generator of Fâˆ—. This enables efficient imple-
mentation of multipoint evaluation over the set ğ· as well as the
set ğ‘”ğ· = {ğ‘”â„ | â„ âˆˆ ğ·} (needed for efficient implementation of the
linear PCP prover algorithm; see [20] for further details).
Lagrange interpolation and inverse FFTs. In addition to computing
FFTğ·, the linear PCP prover needs to compute the inverse opera-
tion FFTâˆ’1
ğ· . This follows immediately from our algorithm above by
inverting each of the steps (i.e., replace both sets of FFTs with their
corresponding inverse FFTs).
The query-generation algorithm QLPCP in Claim A.6 (Construc-
tion B.1) essentially reduces to multiple Lagrange polynomial evalu-
ations (with basis ğ·) at a random field element. Ben-Sasson et al. [20]
described an efficient implementation of this when the domain ğ·
is the roots of unity. In our setting (of working over a field with
insufficient roots of unity), we augment ğ· with cosets of the roots
of unity. The Ben-Sasson et al. algorithm directly generalizes to
this setting and we refer to [20, Appendix E] for the details.
E THE POWER DIFFIE-HELLMAN
ASSUMPTION OVER SMALL FIELDS
In this section, we briefly recall the ğ‘-power Diffie-Hellman as-
sumption introduced by Groth [74] and subsequently used as the
basis for both pairing-based SNARKs [64, 87] as well as lattice-
based SNARKs [65]. Following [65], we formulate the assumption
with respect to a linear encoding scheme, which captures both the
pairing-based instantiation as well as the lattice-based instantiation.
Definition E.1 (Linear Encoding Scheme). A (secret-key) linear
encoding scheme Î Enc over a finite field F is a tuple of algorithms
Î Enc = (Setup, Encode, Add) with the following properties:
â€¢ Setup(1ğœ†) â†’ (pk, sk): On input the security parameter ğœ†, the
setup algorithm outputs a public evaluation key pk and a secret
encoding key sk.
â€¢ Encode(sk, ğ‘¥) â†’ encğ‘¥: On input the secret key sk and an element
ğ‘¥ âˆˆ F, the encoding algorithm outputs an encoding encğ‘¥ of ğ‘¥.
â€¢ Add(pk, (enc1, . . . , encğ‘‘), (ğ›¼1, . . . , ğ›¼ğ‘‘)) â†’ encâ€²: On input the
public key pk, encodings enc1, . . . , encğ‘‘ and coefficients ğ›¼1, . . . , ğ›¼ğ‘‘ âˆˆ
F, the add algorithm outputs a new encoding encâ€².
The encoding scheme is ğ‘‘-linear if for all values ğ‘˜ â‰¤ ğ‘‘, values
ğ‘¥1, . . . , ğ‘¥ğ‘˜ âˆˆ F, scalars ğ›¼1, . . . , ğ›¼ğ‘˜ âˆˆ Fğ‘‘, and sampling (pk, sk) â†
Setup(1ğœ†), encğ‘– â† Encode(sk, ğ‘¥ğ‘–) for all ğ‘– âˆˆ [ğ‘˜], we have that
Pr[Add(pk, (enc1, . . . , encğ‘˜), (ğ›¼1, . . . , ğ›¼ğ‘˜)) âˆˆ ğ‘†] = 1 âˆ’ negl(ğœ†),
where ğ‘† denotes the support of Encode(sk,ğ‘–âˆˆ[ğ‘˜] ğ›¼ğ‘–ğ‘¥ğ‘–).
Definition E.2 (ğ‘-Power Diffie-Hellman Assumption [65, 74]). Fix
a parameter ğ‘ âˆˆ N. A linear encoding scheme Î Enc = (Setup,
Encode, Add) over a field F satisfies the ğ‘-power Diffie-Hellman
assumption (ğ‘-PDH) if for all efficient adversaries A, and sampling
râ† F, encğ‘– â† Encode(sk, ğ‘ ğ‘–) for all ğ‘– âˆˆ
(pk, sk) â† Setup(1ğœ†), ğ‘ 
{0, . . . , 2ğ‘}, ğœ â† (pk, enc0, . . . , encğ‘, encğ‘+2, . . . , enc2ğ‘), we have
that
Pr[A(1ğœ†, ğœ) âˆˆ ğ‘†] = negl(ğœ†),
where ğ‘† is the set of encodings in the support of Encode(sk, ğ‘ ğ‘+1).
ğ‘§1, . . . , ğ‘§2ğ‘ âˆˆ F, and forms the polynomial ğ‘“ (ğ‘¥) =ğ‘–âˆˆ[2ğ‘](ğ‘¥ âˆ’ ğ‘§ğ‘–).
Write this as ğ‘“ (ğ‘¥) = 2ğ‘
ğ‘+1ğ‘—â‰ ğ‘+1 ğ›¼ ğ‘—ğ‘§ ğ‘—
Lemma E.3 (ğ‘-PDH Assumption over Small F). Let Î Enc = (Setup,
Encode, Add) be a ğ‘‘-linear encoding scheme over a finite field F. If
ğ‘‘ â‰¥ 2ğ‘, there exists an adversary that runs in time poly(ğ‘, log |F|)
and wins the ğ‘-PDH security game for Î Enc with advantage 2ğ‘/|F|.
Proof. The adversary A starts by choosing 2ğ‘ distinct points
ğ‘–=0 ğ›¼ğ‘–ğ‘¥ğ‘–. Then, for all ğ‘– âˆˆ [2ğ‘], ğ‘§ğ‘+1
=
âˆ’ğ›¼âˆ’1
ğ‘– . Let (pk, enc0, . . . , encğ‘, encğ‘+2, . . . , enc2ğ‘) be
the ğ‘-PDH challenge. Here, encğ‘– is an encoding of ğ‘ ğ‘–, where ğ‘  âˆˆ F
is sampled by the ğ‘-PDH challenger at the beginning of the experi-
ment. Since ğ‘‘ â‰¥ 2ğ‘, the adversary can homomorphically compute
an encoding of âˆ’ğ›¼âˆ’1
{ğ‘§1, . . . , ğ‘§2ğ‘}, then this quantity is exactly ğ‘ ğ‘+1. Since ğ‘  is uniform
and independent of ğ‘§1, . . . , ğ‘§2ğ‘, the probability that ğ‘  âˆˆ {ğ‘§1, . . . , ğ‘§2ğ‘}
is exactly 2ğ‘/|F|, which proves the claim.
â–¡
ğ‘+1ğ‘–â‰ ğ‘+1 ğ›¼ğ‘–ğ‘ ğ‘–. By the above analysis, if ğ‘  âˆˆ
ğ‘–
Remark E.4 (ğ‘-Power Diffie-Hellman Assumption over Small F).
When the ğ‘-PDH assumption is used for constructing pairing-based
zkSNARKs [64, 74, 87], the size of the underlying field F is super-
polynomial (i.e., |F| = 2Î©(ğœ†)). In this case, the attack in Lemma E.3
has negligible advantage. Indeed, the ğ‘-PDH assumption plausibly
holds over standard pairing-based groups, and holds uncondition-
ally in the generic (bilinear) group model [74].
In the lattice-based zkSNARK of Gennaro et al. [65], they consider
fields of polynomial size. Unfortunately, Lemma E.3 shows that
the ğ‘-PDH assumption does not hold for encoding schemes over
fields of polynomial size. For the specific instantiation proposed by
Gennaro et al., ğ‘ â‰ˆ 216 and |F| â‰ˆ 232, so Lemma E.3 gives an attack
on ğ‘-PDH with advantage 2ğ‘/|F| = 2âˆ’15. Since their zkSNARK
relies on hardness of the ğ‘-PDH assumption for soundness, this
means that their suggested parameters provide at best 15 bits of
provable soundness. To obtain 128-bits of soundness, it would be
necessary to either apply soundness amplification (which increases
all parameters by a factor of 128/15 â‰ˆ 8.5) or instantiate the Regev-
based encoding scheme over a super-polynomial size field (which
would also incur additional overhead).
In this work, we work over small (polynomial-size) fields and
use parallel repetition (at the linear PCP level) for soundness ampli-
fication (see Remark A.7). This increases the number of linear PCP
queries, but since we encrypt vectors of queries, the overhead for
parallel amplification is additive rather than multiplicative in the
number of repetitions. This yields a much more efficient construc-