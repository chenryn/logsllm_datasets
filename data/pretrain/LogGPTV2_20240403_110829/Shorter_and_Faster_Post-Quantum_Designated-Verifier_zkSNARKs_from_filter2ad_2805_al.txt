on each query, the adversary learns either the homomorphically-
evaluated ciphertext (from Add) or the simulated ciphertext (from
S). This multi-query notion is useful to argue multi-theorem zero
knowledge when compiling a linear PCP into a preprocessing
SNARG [30]. Definition C.3 implies this multi-query variant by
a standard hybrid argument.
D LINEAR PCP IMPLEMENTATION DETAILS
In this section, we provide a more detailed description of our multi-
point evaluation and interpolation approach outlined in Section 4.1.
Following [20], for a polynomial 𝐴(𝑧) of degree less than |𝐷|, we
write FFT𝐷(𝐴(𝑧)) to denote the vector of evaluations (𝐴(𝛼))𝛼∈𝐷.
Similarly, we write FFT−1
𝐷 ((𝐴′(𝛼))𝛼∈𝐷) to denote the coefficients
of the polynomial 𝐴 (of degree less than |𝐷|) where 𝐴(𝛼) = 𝐴′(𝛼)
for all 𝛼 ∈ 𝐷.
Let 𝜔 ∈ F be a primitive 2𝑑-th root of unity and 𝐻 = 𝐻1 = ⟨𝜔⟩ ⊂
F be the subgroup of order 2𝑑 generated by 𝜔 (consisting of the
2𝑑-th roots of unity). Let 𝜉1 = 1 and take 𝜉2, . . . , 𝜉𝑖 ∈ F∗ \ 𝐻1 such
that the cosets 𝐻𝑖 = 𝜉𝑖𝐻1 are all pairwise disjoint. We define the
domain to be 𝐷 =𝑖∈[𝑘] 𝐻𝑖. For a set 𝑆 ⊂ F, let V𝑆 ∈ F|𝐷|×|𝐷| be
the Vandermonde matrix associated with evaluating a polynomial
of degree up to |𝐷| − 1 on the points in 𝐷. Let ˆV𝐻 ∈ F2𝑑×2𝑑 be the
Vandermonde matrix associated with evaluation a polynomial of
degree up to 2𝑑 on 𝐻 (i.e., the roots of unity). Then, we have that
...
Ξ2
V𝑆 =
ˆV𝐻
2
ˆV𝐻 · Ξ𝑘
ˆV𝐻
ˆV𝐻 · Ξ2
ˆV𝐻 · 𝜉 (𝑘−1)2𝑑
ˆV𝐻
ˆV𝐻 · 𝜉2𝑑
2 Ξ2
...
ˆV𝐻 · 𝜉2𝑑
Ξ𝑘
𝑖 , . . . , 𝜉2𝑑−1
· · ·
· · ·
. . .
· · ·
). Take any input a ∈ F𝑘·2𝑑 , and
where Ξ𝑖 = diag(1, 𝜉𝑖, 𝜉2
for 𝑖 ∈ [𝑘], let ˆa𝑖 = (𝑎(𝑖−1)2𝑑+1, . . . , 𝑎𝑖·2𝑑) ∈ F2𝑑 . We describe an
algorithm to compute a′ = V𝑆 a:
(𝑖−1)2𝑑+1, . . . , 𝑎′
• Let ˆa′
𝑖·2𝑑
ˆV𝐻 · 𝜉 (𝑘−1)2𝑑
Ξ𝑘
...
𝑘
𝑘
𝑖
 ,
(cid:1). By construction,

Ξ𝑖 ˆa𝑗(cid:170)(cid:174)(cid:172) .
𝜉 ( 𝑗−1)2𝑑
𝑖
ˆa′
𝑖 =(cid:0)𝑎′
𝑖 = ˆV𝐻 ·(cid:169)(cid:173)(cid:171)
Let ˆb𝑖 =𝑗 ∈[𝑘] 𝜉 ( 𝑗−1)2𝑑
the entries in b =(cid:2)ˆbT1 | · · · | ˆbT

𝑖
ˆ𝑏𝑖,𝑗 =
𝑗 ∈[𝑘]
Ξ𝑖 ˆa𝑗 ∈ F2𝑑 . Given ˆb𝑖, computing ˆa𝑖 =
ˆb𝑖 can be done using a standard radix-2 FFT in 𝑂(𝑑 · 2𝑑) time.
ˆV𝐻
• Naïvely, we can compute ˆb𝑖 in 𝑂(𝑘 · 2𝑑) time, so computing all of
(cid:3)T ∈ F𝑘·2𝑑 requires 𝑂(2𝑑𝑘2) time.
However we can do so more efficiently as follows. By definition,
𝑘
𝜉 (ℓ−1)2𝑑
𝑖
𝜉 𝑗−1
𝑖
ˆ𝑎ℓ,𝑗 .
ℓ∈[𝑘]
Now, define ˜b𝑗 = ( ˆ𝑏1,𝑗 , . . . , ˆ𝑏𝑘,𝑗) ∈ F𝑘, and similarly, let ˜a𝑗 =
( ˆ𝑎1,𝑗 , . . . , ˆ𝑎𝑘,𝑗) ∈ F𝑘. Then,
𝜉
(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)
𝜉2𝑑
1
...
𝜉2𝑑
𝑘
2𝑑 (𝑘−1)
𝑘
2𝑑 (𝑘−1)
1
· · ·
. . .
· · ·
Ξ′
1
...
1
...
𝜉
˜a𝑗 .
˜b𝑗 = diag(𝜉 𝑗−1
1
, . . . , 𝜉 𝑗−1
𝑘
)
𝑘
𝑘
. While 𝜉2𝑑
1 , . . . , 𝜉2𝑑
1 , . . . , 𝜉2𝑑
Observe now that Ξ′ ∈ F𝑘×𝑘 is itself a Vandermonde matrix
corresponding to evaluating a degree (𝑘 − 1) polynomial on
the points 𝜉2𝑑
are not roots of unity
(so standard FFTs cannot be used here), we can still solve this
problem efficiently if 𝜉1, . . . , 𝜉𝑘 form a geometric sequence (i.e.,
𝜉𝑖 = 𝛼𝜉𝑖−1 for some fixed 𝛼 ∈ F) [39]. In particular, using the
Bostan-Schost algorithms, multipoint evaluation on 𝑘 values in
a geometric sequence requires computing 2 degree-𝑘 polynomial
multiplications and 𝑂(𝑘) additional work. In the case where 𝑘 <
2𝑑−1, we can use standard radix-2 FFTs to implement the degree-𝑘
polynomial multiplications in 𝑂(𝑘 log 𝑘) time. Thus, computing
each ˜b𝑗 can be done in just 𝑂(𝑘 log 𝑘) time. Repeating this for all
𝑗 ∈ [2𝑑] yields an algorithm to compute b in 𝑂(2𝑑𝑘 log 𝑘) time.
The overall running time of this algorithm is 𝑂(2𝑑𝑘(𝑑 + log 𝑘)),
which matches the running time of a standard FFT over a domain
of size 𝑘 ·2𝑑. While the concrete efficiency of the algorithm is worse
than a standard radix-2 FFT, in fields where there are insufficient
roots of unity (such as the ones we consider), this provides an
efficient algorithm to implement the linear PCP prover. In all of our
experiments, 𝑘 ≤ 64.
Session 1C: Zero Knowledge I CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea231In our implementation, we set 𝜉𝑖 = 𝑔2(𝑖−1)𝜔 for 𝑖 ∈ [𝑘], where
𝑔 is a multiplicative generator of F∗. This enables efficient imple-
mentation of multipoint evaluation over the set 𝐷 as well as the
set 𝑔𝐷 = {𝑔ℎ | ℎ ∈ 𝐷} (needed for efficient implementation of the
linear PCP prover algorithm; see [20] for further details).
Lagrange interpolation and inverse FFTs. In addition to computing
FFT𝐷, the linear PCP prover needs to compute the inverse opera-
tion FFT−1
𝐷 . This follows immediately from our algorithm above by
inverting each of the steps (i.e., replace both sets of FFTs with their
corresponding inverse FFTs).
The query-generation algorithm QLPCP in Claim A.6 (Construc-
tion B.1) essentially reduces to multiple Lagrange polynomial evalu-
ations (with basis 𝐷) at a random field element. Ben-Sasson et al. [20]
described an efficient implementation of this when the domain 𝐷
is the roots of unity. In our setting (of working over a field with
insufficient roots of unity), we augment 𝐷 with cosets of the roots
of unity. The Ben-Sasson et al. algorithm directly generalizes to
this setting and we refer to [20, Appendix E] for the details.
E THE POWER DIFFIE-HELLMAN
ASSUMPTION OVER SMALL FIELDS
In this section, we briefly recall the 𝑞-power Diffie-Hellman as-
sumption introduced by Groth [74] and subsequently used as the
basis for both pairing-based SNARKs [64, 87] as well as lattice-
based SNARKs [65]. Following [65], we formulate the assumption
with respect to a linear encoding scheme, which captures both the
pairing-based instantiation as well as the lattice-based instantiation.
Definition E.1 (Linear Encoding Scheme). A (secret-key) linear
encoding scheme ΠEnc over a finite field F is a tuple of algorithms
ΠEnc = (Setup, Encode, Add) with the following properties:
• Setup(1𝜆) → (pk, sk): On input the security parameter 𝜆, the
setup algorithm outputs a public evaluation key pk and a secret
encoding key sk.
• Encode(sk, 𝑥) → enc𝑥: On input the secret key sk and an element
𝑥 ∈ F, the encoding algorithm outputs an encoding enc𝑥 of 𝑥.
• Add(pk, (enc1, . . . , enc𝑑), (𝛼1, . . . , 𝛼𝑑)) → enc′: On input the
public key pk, encodings enc1, . . . , enc𝑑 and coefficients 𝛼1, . . . , 𝛼𝑑 ∈
F, the add algorithm outputs a new encoding enc′.
The encoding scheme is 𝑑-linear if for all values 𝑘 ≤ 𝑑, values
𝑥1, . . . , 𝑥𝑘 ∈ F, scalars 𝛼1, . . . , 𝛼𝑘 ∈ F𝑑, and sampling (pk, sk) ←
Setup(1𝜆), enc𝑖 ← Encode(sk, 𝑥𝑖) for all 𝑖 ∈ [𝑘], we have that
Pr[Add(pk, (enc1, . . . , enc𝑘), (𝛼1, . . . , 𝛼𝑘)) ∈ 𝑆] = 1 − negl(𝜆),
where 𝑆 denotes the support of Encode(sk,𝑖∈[𝑘] 𝛼𝑖𝑥𝑖).
Definition E.2 (𝑞-Power Diffie-Hellman Assumption [65, 74]). Fix
a parameter 𝑞 ∈ N. A linear encoding scheme ΠEnc = (Setup,
Encode, Add) over a field F satisfies the 𝑞-power Diffie-Hellman
assumption (𝑞-PDH) if for all efficient adversaries A, and sampling
r← F, enc𝑖 ← Encode(sk, 𝑠𝑖) for all 𝑖 ∈
(pk, sk) ← Setup(1𝜆), 𝑠
{0, . . . , 2𝑞}, 𝜎 ← (pk, enc0, . . . , enc𝑞, enc𝑞+2, . . . , enc2𝑞), we have
that
Pr[A(1𝜆, 𝜎) ∈ 𝑆] = negl(𝜆),
where 𝑆 is the set of encodings in the support of Encode(sk, 𝑠𝑞+1).
𝑧1, . . . , 𝑧2𝑞 ∈ F, and forms the polynomial 𝑓 (𝑥) =𝑖∈[2𝑞](𝑥 − 𝑧𝑖).
Write this as 𝑓 (𝑥) = 2𝑞
𝑞+1𝑗≠𝑞+1 𝛼 𝑗𝑧 𝑗
Lemma E.3 (𝑞-PDH Assumption over Small F). Let ΠEnc = (Setup,
Encode, Add) be a 𝑑-linear encoding scheme over a finite field F. If
𝑑 ≥ 2𝑞, there exists an adversary that runs in time poly(𝑞, log |F|)
and wins the 𝑞-PDH security game for ΠEnc with advantage 2𝑞/|F|.
Proof. The adversary A starts by choosing 2𝑞 distinct points
𝑖=0 𝛼𝑖𝑥𝑖. Then, for all 𝑖 ∈ [2𝑞], 𝑧𝑞+1
=
−𝛼−1
𝑖 . Let (pk, enc0, . . . , enc𝑞, enc𝑞+2, . . . , enc2𝑞) be
the 𝑞-PDH challenge. Here, enc𝑖 is an encoding of 𝑠𝑖, where 𝑠 ∈ F
is sampled by the 𝑞-PDH challenger at the beginning of the experi-
ment. Since 𝑑 ≥ 2𝑞, the adversary can homomorphically compute
an encoding of −𝛼−1
{𝑧1, . . . , 𝑧2𝑞}, then this quantity is exactly 𝑠𝑞+1. Since 𝑠 is uniform
and independent of 𝑧1, . . . , 𝑧2𝑞, the probability that 𝑠 ∈ {𝑧1, . . . , 𝑧2𝑞}
is exactly 2𝑞/|F|, which proves the claim.
□
𝑞+1𝑖≠𝑞+1 𝛼𝑖𝑠𝑖. By the above analysis, if 𝑠 ∈
𝑖
Remark E.4 (𝑞-Power Diffie-Hellman Assumption over Small F).
When the 𝑞-PDH assumption is used for constructing pairing-based
zkSNARKs [64, 74, 87], the size of the underlying field F is super-
polynomial (i.e., |F| = 2Ω(𝜆)). In this case, the attack in Lemma E.3
has negligible advantage. Indeed, the 𝑞-PDH assumption plausibly
holds over standard pairing-based groups, and holds uncondition-
ally in the generic (bilinear) group model [74].
In the lattice-based zkSNARK of Gennaro et al. [65], they consider
fields of polynomial size. Unfortunately, Lemma E.3 shows that
the 𝑞-PDH assumption does not hold for encoding schemes over
fields of polynomial size. For the specific instantiation proposed by
Gennaro et al., 𝑞 ≈ 216 and |F| ≈ 232, so Lemma E.3 gives an attack
on 𝑞-PDH with advantage 2𝑞/|F| = 2−15. Since their zkSNARK
relies on hardness of the 𝑞-PDH assumption for soundness, this
means that their suggested parameters provide at best 15 bits of
provable soundness. To obtain 128-bits of soundness, it would be
necessary to either apply soundness amplification (which increases
all parameters by a factor of 128/15 ≈ 8.5) or instantiate the Regev-
based encoding scheme over a super-polynomial size field (which
would also incur additional overhead).
In this work, we work over small (polynomial-size) fields and
use parallel repetition (at the linear PCP level) for soundness ampli-
fication (see Remark A.7). This increases the number of linear PCP
queries, but since we encrypt vectors of queries, the overhead for
parallel amplification is additive rather than multiplicative in the
number of repetitions. This yields a much more efficient construc-