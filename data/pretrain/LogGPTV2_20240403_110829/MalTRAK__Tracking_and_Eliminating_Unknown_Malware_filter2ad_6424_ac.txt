4 signifying that it is the consumer of the data.
3 which was created by F 0
4 reads F 1
Mappings are useful in two ways: the ﬁrst is to aid in disinfec-
tion in order to remove the effects of a starting operation automati-
cally. The second is to provide the user with a detailed dependency
list of all the object views that were created/modiﬁed in the sys-
tem and in order to minimize the amount of clean data that could
be lost during disinfection.
3.5 Intercepts
Intecepts provide a uniﬁed mechanism by which system opera-
tions can be redirected for purposes of tracking modiﬁcation to the
system state.
Contemporary operating systems (e.g Windows and Linux) pro-
vide a layered architecture for access to various system compo-
nents. Figure 4a depicts the layering on the Windows OS. For a
system operation, the applications typically interact with a user-
mode components, which invoke a kernel-mode OS front end (the
system call layer) and the request is either handled in the core OS
kernel (e.g a conﬁguration operation) or passed on to supporting
components such as a ﬁlesystem driver (e.g ﬁle operation) which
support the desired ﬁlesystem (fat32, ntfs, ext3 etc.)
The reference to a ﬁle or a conﬁguration entry is mostly done
via what are termed handles. These are external interfaces to OS
deﬁned structure of maintaing information about a particular ﬁle or
315315
Figure 4. Intercepts: (a) Layering of System Opera-
tions on the Windows OS, and (b) Redirecting con-
trol at the lowest possible level in order to track
modiﬁcations to the system state
conﬁguration entry (such as the name, attributes etc.). The OS uses
the structure on the lower levels of its implementation (e.g ﬁlesys-
tem driver or the core kernelponent) and employs the handles on
the higher levels (e.g system call interface) and user-mode. Appli-
cations use ﬁle/conﬁguration names to obtain a handle and use the
handle to communicate with the OS components thereafter.
Figure 4b), illustrates the intercept mechanism. Our framework
interposes itself directly at the lowest possible levels in order to
capture ﬁlesystem and conﬁguration operations. This is the ﬁle
system driver (FSD) for the ﬁlesystem and the kernel conﬁguration
manager in case where the conﬁguration is supported in memory
and disk (e.g windows registry).For systems that maintain conﬁg-
uration information using the ﬁlesystem (e.g Linux) it will still be
routed through the FSD itself. This ensures that our framework
always gets control irrespective of which points a code invokes
access to the ﬁlesystem/conﬁguration. This is unlike previous ap-
proaches which interpose at the system call level or the ﬁlter level.
A code stream could directly invoke the ﬁle system driver bypass-
ing all of the rest thereby evading monitoring.
When a request arrives at the FSD or at the kernel conﬁgura-
tion manager, the framework gets control ﬁrst. It then determines
the name of the ﬁle/conﬁguration item and uses the OS allocated
structure to store the corresponding ﬁle/conﬁguration object view
information and stores the original ﬁle/conﬁguration name in its
internal memory. Thus, from the code-stream’s perspective, the
handle refers to the original ﬁle/conﬁguation name, whereas from
the OS perspective it refers to the current ﬁle/conﬁguration object
view name. This scheme ensures that the same OS structure is
used throught the system and does not entail modiﬁcation at dif-
ferent points with the kernel code. This is of greater importance
in systems that are not open sources (such as Windows). Any re-
quest which results in the OS allocating a handle (create and open
operation) are intercepted to perform this functionality. For any
query on the ﬁle name (query operation), the framework replaces
the original name within the request buffer so that the application
does not see the difference. The rest of the read/write and other
functionalities that employ the handle are directly passed on to the
respective component (the FSD or the kernel conﬁguration man-
ager). This model also allows us to invoke the original code for the
F00   F10F30   F40F00   F10F30   F40F20F00   F10F31   F40F20F00   F10F31   F40F20   F50V0V1V2V3(a)F00F10F20F31F40F50(b)ppppsApplicationWrapper LibrariesOS User-Mode InterfaceOS System-call LayerOS Core KernelFilter DriversFile-system Drivers (FSD)Disk DriversHardwareUser-ModeKernel-Mode(a)OS Core KernelFrameworkFSDFrameworkObjectHandleObject Structure{… , NAME, …}FnmFn0(b)meat of the functionality while maintaining a minimal information
for the intercepts.
A point to note that, the disk driver is the lowest level in the
layers of system operations. However, we do not intercept at the
disk driver since at that point there is no longer enough information
that is passed to the driver which helps us to tie the disk request
to a given ﬁle. We would then have to deal raw disk blocks which
would result in a COW everytime a disk block is modiﬁed and
result in increased space and time cost.
3.6 Disinfection
Removing the effects of malware in our framework requires the
system to be reverted to a previous state. The step of reverting
back to a previous system state can be done in two ways using our
framework: (a) by switching unconditionally to a different view
from the list of views maintained or (b) by switching conditionally
to a system state comprising of various views depending upon a
starting operation.
In most cases, a user would go with option
(b) as it completely eliminates the effect of the starting operation
on the system. However, in certain cases, the user might chose
a more ﬁne-grained manual approach by trying to eliminate one
view at a time in order to try and salvage some important clean data
that might be missed if option (b) is employed. The choice of (a)
and/or (b) depends upon a particular scenario and the malware(s)
but based on our experience we ﬁnd that option (b) works in most
cases.
The starting operation for option (b) is usually selected from the
framework alerts. Once this point is selected, the framework auto-
mates the process of removing all the effects of that operation on
the system. Alerts are nothing but possible starting points that the
framework automatically generates and records, which could have
a malicious effect on the system. They are based on the notion that
for a particular operating system, there are only a ﬁnite number of
ways in which a malware could try to remain persistent. Section x
lists various scenarios that our prototype implementation employs
for the Windows OS. Alerts can be active or passive. If active, the
user is immediately given a chance to either continue or abort the
operation and in the passive mode, the framework simply records
the information for use during disinfection if needed.
Figure 5 illustrates the disinfection options (a) and (b) for the
scenario as discussed in Section 3.4. In both cases the disinfection
engine computes two lists. The ﬁrst list is called a delete list and
the second a active list. The delete list represents the list of ﬁle
views that need to be deleted from the current view while the active
list represents the list of ﬁle views that need to be made active in
order to switch to a view that represents a clean system state.
Using option (a) the user can go from view V3 to any of the
possible views V2 through V0. The framework will automatically
compute the active and delete lists to switch to the target view. As
an example, as shown in Figure 5b, the user moves from view V3 to
V1 and then to V0 resulting in the corresponding active and delete
lists. This form of view switching is called unconditional since the
user is switching from view n to view m without any knowledge
of the relationship between the ﬁles in the view.
However, in option (b) the user selects a starting point, in this
case the creation of ﬁle object view F 0
1 (which causes an alert as
it is a kernel mode driver that has been linked to start up auto-
matically on the next boot) and the framework uses the mapping
information to conditionally switch from V3 to V0 automatically,
Figure 5. Disinfection:
(a) Views of the system,
(b) Conditional view switching switches to a view
by eliminating required view objects, and (b) Con-
ditional view switching uses relationships and
switches to a view by eliminating the effects of a
starting operation.
eliminating all effects of the ﬁle object view F 0
1 in the system (Fig-
4 might read something that
ure 5c). Note that using option (b), F 0
5 , how-
2 produced, that might not be directly incorporated into F 0
F 0
ever disinfecion will result in F 0
5 being deleted. While this might
be thought of as losing more clean data, in practice it is not. If an
application reads contents of an executable, chances are that it is
using it for packing or encrpytion in which case the resulting exe-
cutable should be deleted in any case. If an application is reading
data that is written by a possible malware, and is writing output
data, there is a good chance that the input information will be em-
bedded in some form in the output, in which case it is a good idea
to remove those effects. However, there might always be situa-
tions where an application reads data that is written to but does not
use that data for some of its outputs. In this case, disinfecting the
system using option (b) will result in the loss of some clean data
using our framework which needs to be salvaged using option (a)
if desired.
4 Implementation
To evaluate our framework we have developed a prototype im-
plementation for the Windows XP operating system. The imple-
mentation consists of a kernel mode driver and a user-mode appli-
cation. The kernel-mode driver is the framework which encom-
passes all the four subsystems: the view, mapping, intercept and
recovery engines while the user-mode application is the recovery
console that interacts with the user to deliver alerts and to perform
recovery.
For implementation purposes, our prototype modiﬁes different
parts of the Windows OS kernel and supporting components. Since
Windows is a commercial OS, such modiﬁcations have to be done
in binary. We use redirection, a method similar to target function
overwriting with trampolines [31, 10]. The basic idea is to dis-
assemble enough instructions and implant a series of instructions
on the target intercept location which ultimately transfer control
to our framework internal function. This allows us to invoke the
original internal function within our framework. Thus we can per-
form framework speciﬁc operations while chaining to the original
316316
F00   F10F30   F40F00   F10F30   F40F20F00   F10F31   F40F20F00   F10F31   F40F20   F50V0V1V2V3(a)F00F10F20F31F40F50(b)ppppsV3V1V1V0Active List = { F30 }Delete List = { F50 }Active List = { }Delete List = { F20}Starting Operation = { F10 }Active List = { F30 }Delete List = { F50 , F20  , F10}F00   F30   F40V(c)internal functions for the meat of the processing.
4.1 Views
Views are implemented by using object view stacks. A object
view stack is a collection of object views for a particular type of
object (such as a ﬁle, conﬁguration key etc.). A object view stack
is a LIFO structure that operates in the same way as a program
stack, where information can be pushed into and popped out of the
stack. Each object view stack has a top of stack pointer called the
object view stack pointer.
A view is then deﬁned to be the list of all objects that do not
have a object view stack (i.e they have not been modiﬁed) and the
set of object views which form the top of stack element of their
respective object view stacks. We call this list the access vector
for the corresponding view. Thus, for a given view, simply by
looking at the access vector, the framework can determine which
physical ﬁle the requests must be routed to.
4.2 Mappings
The framework uses call-chains and call-contexts in order to
implement mappings.
A call-chain is simply a list of function entry points that ulti-
mately lead to the actual functionality. In our case we use call-
chains only for ﬁlesystem and conﬁguration functionalities. For
example, if one considers the CreateFileA API, it follows a series
of API invocation until it reaches the FSD with the request to cre-
ate a ﬁle. A call chain is only created comprising of modules which
are always visible in the address space of every process. Thus, we
do not take into account dlls that might wrap around the APIs.
A call-context essentially describes information about the orig-
inator of a particular call to either the ﬁle system or the conﬁgura-
tion manager. This is used to identify the target ﬁle fmn which is
responsible for the invocation. The framework establishes several
hooks within the host OS kernel in order to build call-contexts.
It intercepts process/thread initiation and termination APIs
in both user and kernel-mode. More speciﬁcally it hooks
ZwCreateProcess, ZwCreateThread, ZwTerminateProcess, and
PsCreateSystemThread calls in order to keep track of the pro-
cesses/threads that are being created. The framework also inter-
cepts APIs such as ZwReadProcessMemory, KeStackAttachPro-
cess and ZwWriteProcessMemory in order to keep track of inter-
process memory writes and maintains a list of memory regions
and the originating process/module information. This ensures that
a situation where a malicious process injects code into a benign
process in order to create ﬁles on its behalf [18] is properly tack-
led.
The framework also intercepts APIs such as LdrLoadLibrary,
LdrFreeLibrary, LdrGetModuleHandle, LdrGetProcAddress in or-
der to keep track of the modules that are being loaded/ unloaded
in user-mode. It also intercepts ServiceManager APIs as well as
ZwLoadDriver in order to keep track of the kernel-mode drivers
and modules that are being loaded.
The framework intercepts calls to ExAllocPool and ZwVirtu-
alAlloc in order to track memory regions that are being allocated
by the running code-streams in both user and kernel-mode. Thus
it is able to track if a given request is coming from code being exe-
cuted in these memory regions. Finally, the framework also hooks
all the entrypoints within the ﬁlesystem/conﬁguration call-chains
and keeps track of the return address.
We hook entry points within the host OS and do not modify the
host OS structures directly for two reasons. First, from an imple-
mentation perspective we would like to stay as much close to doc-
umentedness as possible. The kernel structures for the above oper-
ations keep changing and messing with them only leads to system
instability. Second, even if a malware hooks the above functions, it
still needs to chain to it since implementing these functions is not
a trival task for malware writers. So we ensure that we always get
control while keeping our implementation as stable as possible.
Figure 6. Mappings: Generating Object View Rela-
tionships
When a ﬁlesystem or conﬁguration object is created, opened,