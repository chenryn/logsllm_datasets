challenge correctly for subprotocol c∗.
j that matches πs
i ; and
(A) as |p−1/2|, where p is the probability that A answers the encryption
i .α = accept;
i .c = c∗;
• πs
• πs
• no Corrupt(i, c∗) query was ever issued, nor Corrupt(i, d) for any d such that δi,{c∗,d} = 1;
• no Corrupt(j, c∗) query was ever issued for any j such that πt
i , nor Corrupt(j, d)
j matches πs
NP(cid:107) (cid:126)SP,c∗
Deﬁne Advmcs-acce-so-aenc
(A) as |p − 1/2|, where p is the probability that A answers the
i .ρ = resp and
encryption challenge correctly for subprotocol c∗ and either πs
there exists a session that matches πs
i .
Deﬁnition 7 (Multi-ciphersuite-ACCE-secure). A multi-ciphersuite protocol NP(cid:107) (cid:126)SP is (cid:126)-multi-
ciphersuite-ACCE-secure against an adversary A if, for all c∗, we have that Advmcs-acce-auth
(A) ≤
(A) ≤ c∗. We deﬁne an analogous notion for server-only authentication.
c∗ and Advmcs-acce-aenc
i .ρ = init or both πs
NP(cid:107) (cid:126)SP,c∗
NP(cid:107) (cid:126)SP,c∗
When nSP = 1, the multi-ciphersuite ACCE protocol and security deﬁnitions are equivalent
to the original ACCE deﬁnitions (albeit with slightly diﬀerent notation), except for the change
to buﬀered stateful authenticated encryption. For simplicity, we explicitly give those deﬁnitions:
Deﬁnition 8 (Mutual authentication ACCE-secure). A (single-ciphersuite) protocol P = NP(cid:107)SP
is -ACCE-secure (with mutual authentication) against an adversary A if Advacce-auth
(A) ≤ 
and Advacce-aenc
Deﬁnition 9 (Server-only-ACCE-secure). A (single-ciphersuite) protocol P = NP(cid:107)SP is -server-
only-ACCE-secure against adversary A if Advacce-so-auth
(A) ≤  and Advacce-so-aenc
(A) ≤ .
(A) ≤ .
NP(cid:107)SP
NP(cid:107)SP
NP(cid:107)SP
NP(cid:107)SP
4 The SSH protocol
In this section, we describe the SSH protocol using signed Diﬃe–Hellman.
There are several cryptographic components that may be negotiated in SSH, and the collective
choice of these components constitutes a ciphersuite. A party’s preferences are represented as
a vector (cid:126)sp, and the initiator and responder preferences (cid:126)spC, (cid:126)spS are inputs to the negotiation
function neg( (cid:126)spC, (cid:126)spS) → c speciﬁed by the standard [40, §7.1] which selects the ﬁrst element in
(cid:126)spC that is also in (cid:126)spS.
Each ciphersuite SSHc can use diﬀerent cryptographic components. The signature scheme
SIGc for server and client authentication may be either RSA, DSA, ECDSA [32], or Ed25519.
The key exchange method is Diﬃe–Hellman over either a ﬁnite ﬁeld or elliptic curve cyclic group
Gc of prime order qc generated by gc. The hash function Hc can be either SHA-1 or SHA-256.
The buﬀered stateful encryption scheme StEc can be composed of a variety of encryption and
MAC algorithms, including TripleDES in CBC mode or AES in CBC or CTR mode and HMAC
with MD5, SHA-1, SHA-256, or SHA-512; or ChaCha20 with Poly1305.
During the negotiation phase, KEXINIT and KEXREPLY exchange nonces and negotiate the
ciphersuite. During the key-exchange portion of the sub-protocol phase, KEXDH INIT and
KEXDH REPLY exchange key-material, generate session keys and authenticate the responder to
the initiator via the negotiated digital certiﬁcates and ciphersuites. During the authentication
portion of the sub-protocol phase, the responder veriﬁes if the chosen authentication mode is
authorised for the given initiator, and authenticates the initiator via passwords, public-keys or
no client authentication at all.
13
Negotiation
1. init → resp: KEXINIT
$← {0, 1}µ=128
1. rC
2. send KEXINIT ← (rC, (cid:126)spC)
3. π.ρ ← init
4. π.α ← in-progress
2. resp → init: KEXREPLY
$← {0, 1}µ
1. rS
2. send KEXREPLY ← (rS, (cid:126)spS)
3. π.ρ ← resp
4. π.α ← in-progress
5. π.c ← neg( (cid:126)spC, (cid:126)spS)
3. init
1. π.c ← neg( (cid:126)spC, (cid:126)spS)
Signed-Diﬃe–Hellman
sub-protocol, server-only
authentication mode
7. init → resp: AUTHREQUEST
1. send AUTHREQUEST ← username
(cid:107)service(cid:107)none
8. resp → init:
AUTHSUCCESS or AUTHFAILURE
1. if none authentication is autho-
rised for username for service
then
2.
3. else
4.
π.α ← accept;
send AUTHSUCCESS
π.α ← reject;
send AUTHFAILURE
11. init
1. if AUTHFAILURE then
2.
3. else if AUTHSUCCESS then
4.
π.α ← reject and terminate
π.α ← accept
Signed-Diﬃe–Hellman sub-protocol (common to all authentication modes)
π.c
4. init → resp: KEXDH INIT
1. x $← Zqπ.c
2. e ← gx
3. send KEXDH INIT ← e
5. resp → init: KEXDH REPLY and NEWKEYS
1. y $← Zqπ.c
2. f ← gy
3. K ← ey
4. (π.sid, π.k) ← PRFπ.c(K,
π.c
VC(cid:107)VS(cid:107)KEXINIT(cid:107)KEXREPLY(cid:107)pkS,π.c(cid:107)e(cid:107)f )
6. init → resp: NEWKEYS
1. K ← f x
2. (π.sid, π.k) ← PRFπ.c(K,
VC(cid:107)VS(cid:107)KEXINIT(cid:107)KEXREPLY(cid:107)pkS,π.c(cid:107)e(cid:107)f )
π.α ← reject and terminate
3. if SIGπ.c.Vfy(pkS,π.c, σS, π.sid) = 0 then
4.
5. π.pid ← S, where PS has public key pkS,π.c
6. send NEWKEYS
5. σS ← SIGπ.c.Sign(skS,π.c, π.sid)
6. send KEXDH REPLY ← (f, pkS,π.c, σS)
7. send NEWKEYS
Note VC and VS are client and server version
strings.
Signed-Diﬃe–Hellman sub-protocol, mutual authentication mode
7. init → resp: AUTHREQUEST
1. send AUTHREQUEST ← username(cid:107)service
(cid:107)public-key(cid:107)0(cid:107)alg(cid:107)pkC,π.c (where alg is
the name of the public key algorithm (RSA,
DSA, ECDSA) and pkC,π.c is the client’s
public key for this ciphersuite)
8. resp → init: AUTHOK or AUTHFAILURE
1. if username is not allowed access to service
by public-key authentication then
π.α ← reject and terminate
2.
3. if π.α = in-progress then
send AUTHOK ← alg(cid:107)pkC,π.c
4.
5. if π.α = reject then
6.
send AUTHFAILURE and terminate
9. init → resp: AUTHREQUEST
1. A ← username(cid:107)service(cid:107)public-key
2. σC ← SIGπ.c.Sign(skC,π.c, π.sid, A)
3. send AUTHREQUEST ← A(cid:107)σC
(cid:107)1(cid:107)alg(cid:107)pkC,π.c
10. resp → init: AUTHSUCCESS or AUTHFAILURE
1. A(cid:48) ← username(cid:107)service(cid:107)public-key
2. if A(cid:48) (cid:54)= A then
π.α ← reject
3.
4. if SIGπ.c.Vfy(pkC,π.c, σC, π.sid, A) = 0
(cid:107)1(cid:107)alg(cid:107)pkC,π.c
then
π.α ← reject
π.α ← accept
5.
6. if π.α = in-progress then
7.
8. if π.α = accept then
9.
10. else if π.α = reject then
11.
send AUTHSUCCESS
send AUTHFAILURE and terminate
11. init
1. if AUTHFAILURE then
2.
3. else if AUTHSUCCESS then
4.
π.α ← reject and terminate
π.α ← accept
Figure 4: SSH handshake phase protocol: negotiation protocol and signed-Diﬃe–Hellman
sub-protocol
The basic outline of the SSH protocol is given in Figure 1 in the introduction; the detailed
message ﬂow and processing for the signed-Diﬃe–Hellman handshake phase with server-only or
mutual public key authentication can be found in Figure 4and Appendix A. For details on the
authenticated encryption we refer to the standard [40] and Albrecht et al. [1].
4.1 The SSH PRF
The PRFc function described in Figure 5 is used in the SSH protocol to compute two values:
H, which will be used as the session ID (this value is later signed in the KEXDH REPLY and
AUTHREPLY messages); and k1(cid:107)k2(cid:107)k3(cid:107)k4(cid:107)k5(cid:107)k6 (which are later used as encryption keys, IVs,
and authentication keys). PRFc computes these values using the hash function Hc negotiated
by the ciphersuite. While PRFc is superﬁcially similar to HMAC, it varies suﬃciently that it
merits independent analysis.
We cannot prove security for SSH from the assumption that Hc is a collision-resistant hash
function: in SSH the hash value H to be signed by both parties not only contains a transcript of
the most important exchanged messages, but also the secret Diﬃe-Hellman key K computed by
both parties. If Hc leaks information about K, the protocol cannot be proven secure. Therefore
we need the assumption that PRFc is a secure PRF, which is how our security proof of SSH
14
PRFc(K, x):
1. H ← Hc(x(cid:107)K)
2. label ← [A, B, C, D, E, F ]
3. for i ∈ {1, . . . , 6} do
5. return (H, k1(cid:107)k2(cid:107)k3(cid:107)k4(cid:107)k5(cid:107)k6)
ki ← Hc(K(cid:107)H(cid:107)labeli(cid:107)H)
4.
Figure 5: Computation of PRFc using Hc.
proceeds in the rest of this section.
Under the assumption that Hc is a random function, it is straightforward to see that PRFc
is a secure PRF.
Analysis of PRFc under weaker, standard-model assumptions on Hc is more challenging.
One way of analyzing key derivation functions is Krawczyk’s extract-then-expand paradigm
[25]. In this paradigm, ﬁrst a pseudorandom key K ← H(SKM ) is extracted from the secret
key material (such as the Diﬃe–Hellman shared secret) SKM using a hash function H, then
application keying material KM ← F (K, “1”(cid:107)info)(cid:107)F (K, “2”(cid:107)info)(cid:107) . . . is expanded from the
pseudorandom key K using a PRF F . Although PRFc does seemingly have an extract phase (line
1) and then an expand phase (line 4), the extract-then-expand paradigm does not directly apply
because the pseudorandom key (H, in the case of PRFc) is subsequently used in another area of
the SSH protocol: H is signed by the signature scheme and the signature is transmitted over
the channel. Thus H and the signature on H must not leak anything about the Diﬃe–Hellman
shared secret.
It may be possible to adapt extract-then-expand to analyze the SSH PRF, but we leave
that as future work. Our main security proof of SSH is entirely standard model, so any future
work improving the analysis of PRFc from random oracle model to standard model immediately
yields a full standard model proof of SSH.
5 ACCE security of SSH
In this section, we analyze the security of single signed-DH SSH ciphersuites, in isolation. We
ﬁrst note a few challenges we faced in the proofs, then show authentication and channel security
in the server-only and mutual authentication modes.
5.1 Challenges with security proofs for SSH
ACCE. As noted in the Introduction, challenges are often encountered when trying to analyze
real-world protocols. The ﬁrst problem that arises when analyzing SSH is the fact that the
messages needed for client authentication are sent encrypted, allowing the adversary to trivially
win key indistinguishability in a standard authenticated key exchange security experiment; this
is resolved by switching to ACCE.
Collision-free hash function must be non-leaking. One feature of SSH is the fact that
the hash value to be signed by both parties not only contains a transcript of the most important
exchanged messages, but also the secret Diﬃe-Hellman key computed by both parties. This
poses a non-standard problem with the deﬁnition of collision-free hash functions. To understand
the problem, consider the following function, constructed from a collision-resistant hash function
H:
(1)
If the length of k is ﬁxed, the function H∗ also is a hash function with constant output length
|H()| + |k|, and it is collision-free since the preﬁx H(m||k) is collision-free. However, this
counter-intuitive, but deﬁnition-conforming collision-free hash function may compromise the
H∗(m||k) := H(m||k)||k .
15
security of the protocol: If the signature scheme used has message recovery (e.g. plain RSA
Signatures), a (passive) adversary may learn the secret Diﬃe-Hellman key by verifying the
signature. We solve this problem by requiring that the ﬁrst hash value computation must be