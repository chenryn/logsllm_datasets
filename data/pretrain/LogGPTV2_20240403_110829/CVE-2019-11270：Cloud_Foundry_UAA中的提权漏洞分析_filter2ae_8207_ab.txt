### 作用域与客户端创建

此作用域是创建和修改客户端所必需的。作用域以作用域持有者的客户端ID为前缀。例如，`id: testclient, authority: client.write` 允许创建具有 `testclient.` 前缀的作用域的客户端。授权仅限于 `uaa.resource`。

因此，只允许创建具有以创建客户端的 ID 为前缀的作用域的客户端。例如，ID 为 `app123` 且权限为 `clients.write` 的客户端只能注册带有前缀为 `app123` 的作用域的新客户端（如 `app123.read` 或 `app123.admin`）。

这些限制的目的在于防止客户端使用 `clients.write` 作用域创建具有特权 UAA 管理作用域的客户端（例如 `uaa.admin`），从而提权。

### ‘Client.write’ 使用示例

`clients.write` 作用域用于管理资源服务器。为了管理数据库应用程序，UAA 管理员可以创建一个 ID 为 `db` 的客户端，并为其提供 `clients.write` 权限。`db` 客户端现在可以创建新客户端并为它们提供前缀为 `db` 的作用域，例如 `db.read`、`db.create` 或 `db.admin`。`db` 客户端实际上是数据库应用程序的管理客户端，可以创建对应用程序具有细粒度权限的其他客户端。

由于创建的客户端只能注册作用域而不是权限，因此它们都需要用户对其进行授权才能接收访问令牌。在生产环境中，可以为 `db` 客户端提供 `scim.write` 和 `scim.read` 权限，这样它就能够创建具有适当组成员身份的用户（例如 `db.read`），以便可以授权新客户端。

### 漏洞

检查强制执行上述限制的 UAA 代码，特别是 `ClientAdminEndpointValidator` 的 [验证函数](https://github.com/cloudfoundry/uaa/blob/a7012a7c57ec2a6c26f4cc23febf573a96aff52d/server/src/main/java/org/cloudfoundry/identity/uaa/client/ClientAdminEndpointsValidator.java#L175)，发现 `clients.write` 作用域**没有按照文档实现**：

在上述代码中，`caller` 指的是用于创建的客户端（即拥有 `clients.write` 作用域的客户端），而 `client` 指的是被创建的客户端。除了允许以创建客户端 ID 为前缀的作用域（如文档所示）之外，该函数还允许以被创建的客户端 ID 为前缀的作用域。此实现缺陷允许创建者创建具有任意作用域的客户端（因为其可以控制创建的客户端 ID）。

例如，具有 `clients.write` 权限的恶意客户端可以创建一个 ID 为 `zones` 的客户端，因此可以使用带有 `zones` 前缀的任何作用域，例如 `zones.uaa.admin`，这是一个可以实现 UAA 服务器完全管理控制的作用域。

作为旁注，在第 182 行，您可以看到创建客户端也可以分配他自己的任何作用域。这是有道理的，因为创建客户端已经具有这些作用域了，因此将它们提供给新客户端并没有提权的风险。

### 漏洞利用

如前所述，客户端需要得到具有匹配组成员资格的用户授权才能对其作用域采取行动。例如，利用此漏洞创建具有 ID：`zones` 和作用域：`zones.write` 的客户端的攻击者，需要 `zones.write` 组成员的用户授权这个新的 `zones` 客户端。

如果攻击者控制了这样的用户，则攻击变得很容易。如果攻击者具有 `scim` 特权，即 `scim.write` 和 `scim.read`，将允许他创建所需的用户，攻击也会很容易实现。

[这个视频](https://www.twistlock.com/wp-content/uploads/2019/02/uaa_blog_clients_write_scim_exploit.mp4?_=1) 演示了此攻击，其中“evil”客户端利用此漏洞获取具有 `clients.admin` 作用域的访问令牌，从而获得对 UAA 服务器的完全控制权。

这是攻击的最理想情况，除了具有易受攻击的 `clients.write` 作用域之外，攻击者还可以访问能授权使用此漏洞创建的客户端的用户。

让我们稍微限制一下攻击者，如果仅有存在漏洞的作用域，攻击者能做什么呢？在这种情况下，漏洞是否还能不能发挥作用？

### 自动批准的作用域

对于受限的攻击者，`clients.write` 作用域还允许使用 UAA 的自动批准功能，这听起来很愚蠢。通常，当用户授权客户代表他行事时，会向他提供批准或拒绝客户端作用域请求的选项。

如上图所示，用户选择仅批准 `database.read` 作用域。如果客户的其中一个作用域设置为自动批准，则会在用户不知情或未经用户同意的情况下自动授权。例如，在上图中，`database.admin` 作用域自动获得批准，可以看到用户对此没有任何指示。

### 自动批准漏洞利用

如前所述，`clients.write` 作用域允许将创建的客户端的作用域设置为自动批准。让我们看看攻击者如何利用此功能在模拟真实生产环境的场景中完全控制 CF 部署。

在之前的漏洞利用视频中，攻击者可以使用 `clients.write` 权限以客户端的形式访问 `clients.write` 作用域。对于这种情况，攻击者可以利用经典的 OAuth2 用户-客户端对的形式访问 `clients.write` 作用域：

- `twist` 用户是 `clients.write` 作用域的成员
- 具有 `clients.write` 作用域的 `evil` 客户端，以及 `some.arbitrary` 作用域（下文将进行解释）

以下是生产环境的其他参与者：

- `some-fake` 应用程序 – 一种资源服务器，它信任 UAA 访问令牌以管理对其资源的访问。它要求令牌包含 `some.arbitrary` 作用域
- `victim` 用户 – `some.arbitrary` 和 `cloud_controller.admin` 组的成员

`victim` 用户经常批准 `evil` 客户端使用 `some.arbitrary` 作用域并代表他访问 `some-fake` 应用程序。

攻击者的目标是利用此漏洞将 `cloud_controller.admin` 作用域添加到 `evil` 客户端并将其设置为自动批准。

### 攻击步骤

1. **开始攻击**：攻击者使用 `twist` 用户和 `evil` 客户端来获取具有易受攻击的 `clients.write` 作用域的访问令牌。然后，他利用此漏洞创建名为 `cloud_controller` 的客户端，并为其提供 `cloud_controller.admin` 作用域。攻击者还为 `cloud_controller` 客户端提供所有邪恶的作用域。

2. **修改客户端**：接下来，攻击者使用 `twist` 用户和 `cloud_controller` 客户端来修改 `evil` 客户端以获得 `cloud_controller.admin` 作用域，并将其设置为自动批准。

3. **自动批准**：在下一次 `victim` 授权 `evil` 客户端使用 `some.arbitrary` 作用域时，`cloud_controller.admin` 作用域将在未经受害者同意的情况下自动获得批准（！）。

此攻击在 [这一视频](https://www.twistlock.com/wp-content/uploads/2019/02/uaa_blog_clients_write_autoapprove_exploit.mp4?_=2) 中成功执行。

执行攻击后，`evil` 客户端对 `cloud_controller` 具有管理控制权，这意味着可以完全控制 CF 部署。

在视频中，我使用了 `uaac`，一个用于 UAA 服务器的 CLI。在真实的攻击场景中，“evil”客户端可能会有一个 Web 界面，“victim”用户将被重定向到 UAA 身份验证和授权页面。