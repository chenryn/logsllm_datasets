USB stacks lack a software-emulated bridge between the host
and gadget stacks. Thus, we emulated the hardware bridge from
scratch to handle underlying UDC hardware, and established
a virtual connection from the USB host. Based on this, we
applied our fuzzing system equipped with our stateful input
Fig. 15: Coverage breakdown by the type of channels. While
presenting unique coverage contribution from host and gadget
channels, combination represents the coverage from the both
channels.
mutation engine to FreeBSD gadgets. Using 7 gadgets, we
carried out experiments under the same mutation ruleset used
in §VI-B. Note that there is no explicit user-side input channel
because FreeBSD gadget drivers are self-contained without
user-specified configurations (e.g., device setup inputs). Hence,
we focus on host channel fuzzing guided by the extracted
gadget state machines. We achieve this by adjusting the algo-
rithm to recognize the FreeBSD-specific transition and gadget
entry functions, such as usb_request_callback(). For
comparison, we designed a basic FreeBSD gadget fuzzer as
the baseline using typical code coverage instead of stateful
fuzzing on par with G-FUZZER.
Evaluation. Based on the experimental setup, we evaluate
several aspects of FUZZUSB on FreeBSD. In particular, we
examine the bug-finding efficiency and coverage. Similar to
§A, we measured the detection time of a given bug (crash)
compared with the baseline. Since there are no available bug
reports for the FreeBSD gadgets in testing [47], we introduced a
previously-known memory corruption security bug by reverting
a commit fixing it (i.e., one safety check against invalid memory
access [43]). As shown in Table VIII, FUZZUSB led the
executions to the bug quickly while the baseline cannot discover
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:39:18 UTC from IEEE Xplore.  Restrictions apply. 
122223
hidmassprinteracmecmncmeemrndissubsetmidiuac1uac1_legacyuac2serialobextcmloopbacksourcesinkphonetaccessoryaudio_srcmtpconncdevptpccidlafhw_acm1500 1000 500 0Explored blocksG-fuzzerFuzzUSB-SLFuzzUSB: state transition point!!0.511.522.53025hidhostchannelgadgetchannelcombination0.511.522.53025mass0.511.522.53Time (hour)025ecmCoverage contribution (%)ID
Bug type
Gadget Kernel
CVE-2019-14763 [41]
CVE-2018-20961 [42]
commit-9c847ff [43]
Deadlock
Double-free
Invalid access
hid
midi
eem
linux-4.16
linux-4.16
FreeBSD
G-fuzzer
✗
✗
✗
Detection time
FUZZUSB-SL
2.51 mins
4 days
N/A
FUZZUSB
2.24 mins
3.5 hours
1.18 mins
TABLE VIII: Detection time for previously-known USB gadget bugs (✗: detection failure).
Fig. 16: Per-gadget coverage in FreeBSD after 50-hour run.
the bug due to stateless fuzzing that unlikely reaches deep code
paths. Furthermore, we carry out fuzzing campaigns for 50
hours and collect execution coverage. The result in Figure 16
shows that FUZZUSB outperformed the baseline coverage.
Specifically, it achieves 2.2× improvement of coverage. The
performance improvement is larger in large codebase gadgets
(e.g., eth). Such results imply the advantage of the state-
aware fuzzing of FUZZUSB. To highlight the improvement
contributed by our stateful input mutation, similar to Figure 14,
we demonstrate the coverage improvement rate during the
first 5 minutes of the execution. Figure 17 depicts the mass
gadget as an example and the average result of our targeted 7
FreeBSD USB gadgets. As expected, each state change directly
contributed to a higher coverage increase, especially during
the early time of the execution.
Takeaway. As demonstrated by the evaluation above, we
can apply FUZZUSB to other operating system kernels for
USB gadget stack fuzzing, provided that a software bridge is
available to establish a virtual USB connection. The fact that
no USB gadget bugs are ever reported, and our fuzzing did not
find any USB gadget bugs either in FreeBSD may suggest some
efficient ways to reduce the attack surface of USB gadget stacks,
that are, 1) limiting the number of gadgets, 2) simplifying the
implementation of each gadget, and 3) disabling user-space
configurations.
VII. DISCUSSION
Bug reproducibility. Among our new bug findings, we
observe a number of them being race conditions bugs. As
a result, we notice that around 30% of our findings could
be reproduced deterministically, while the rest could not
be reproduced due to the non-deterministic nature of race
conditions. This is also a known issue of syzkaller when
reproduced programs fail to reproduce bugs. One possible
way to increase the bug reproducibility is to record and replay
the runtime state of a gadget driver within the kernel, which
requires a unified design and implementation of a gadget state.
Fig. 17: Coverage improvement rate for 7 FreeBSD gadgets on average.
Similar to Figure 14, a state transition is triggered every 30 seconds
for 5 minutes.
Optimal mutation strategy. As mentioned in §VI, we used
the fixed rules for the stateful mutation in FUZZUSB by default,
assuming that they can help maximize the performance in
coverage extension. However, the optimal mutation strategy
might be gadget-dependent and need to be changed over time
depending on the status of a gadget. For example, complex gad-
gets with a large codebase, such as mass_storage, should
be extensively targeted and fuzzed in the data communication
phase to be more effective. We leave such exploration for our
future work.
Android USB gadget fuzzing. To fuzz Android-specific
gadget drivers, we manually looked into Android kernels from
different Android OEMs and ported the unique drivers into the
corresponding mainline kernels. Ideally, fuzzing an Android
kernel within QEMU directly without any change would be the
best way. Unfortunately, due to hardware diversity, we could
not find one emulation environment supporting all different
Android kernels. For the same reason, existing Android USB
fuzzing still relies on physical Android devices [48].
USB gadget stack coverage. Although we have been focusing
on USB gadget drivers, such as CDC, HID, and MSC,
FUZZUSB covers the whole USB gadget stack fuzzing because
of the connections between USB gadget drivers and other layers
as shown in Figure 1 except UDC drivers. To fuzz UDC drivers
in a scalable fashion, we need to emulate the physical layer of
UDC hardware in QEMU, which unfortunately only provides
the basic HCD hardware (e.g., xHCI) evaluation. Consequently,
the current UDC driver fuzzing requires the corresponding
hardware, such as a RaspPi Zero or an Android phone [20].
USB gadget stacks in other OSes. The USB gadget stack
in the Linux kernel might be the most widely used due to
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:39:18 UTC from IEEE Xplore.  Restrictions apply. 
132224
audioethmodemmousekeyboardeemmass0250Explored blocksG-fuzzerFuzzUSBAndroid and Embedded Linux adoption. Beside Linux gadgets,
we additionally evaluate FUZZUSB with the USB gadget stack
in the FreeBSD kernel to present the generality of our approach.
Hence, we believe FUZZUSB is also applicable to other open-
source gadget stacks, such as Zephyr [49] and Mbed [50],
which usually have limited functionalities, e.g., supporting a
limited number of USB classes, although maybe non-trivial,
requiring an emulation environment for the corresponding OS,
e.g., QEMU, a USB host environment provided by the target OS
or another OS, e.g., Linux, a virtual USB connection between
the USB host and the corresponding USB gadget stack, and a
means to collect code coverage from within the target OS.
Imprecise static analysis.
Static analysis is known to
potentially cause imprecise analysis results [51]. Specifically,
false positives can be introduced by over-approximation of
static analysis encompassing infeasible indirect call targets.
In contrast, false negatives can be introduced by under-
approximation caused by missing indirect call targets. For-
tunately, we did not observe any specific problems caused by
imprecise static analysis in our experiments, as its analysis
scope is bounded within explicit gadget entry and transition
points. Meanwhile, we could mitigate the aforementioned
limitations by leveraging existing techniques aiming at reducing
the false positives [52, 53] or false negatives [54]. Moreover,
symbolic analysis can compensate for such limitations. For
example, as our path exploration analysis is achieved through
symbolic execution, we can handle indirect branches as long
as the corresponding function pointers are symbolically tainted.
Although we may miss untainted indirect branches, they can
be ignored safely because such branches are not part of state
machines controlled by fuzzing inputs.
VIII. RELATED WORK
USB vulnerability detection. Despite the consistent efforts
to reveal USB vulnerabilities for many years [14–19, 55–
57], USB still has been shown to be vulnerable to various
attacks. Relying on software testing technique, one side of
the efforts [18, 19, 48] takes a hardware-based approach,
leveraging dedicated hardware boards to support essential
functions of USB devices. Another large body of works [14–
17, 55, 57] examines USB stacks using software emulated
USB devices without physical peripheral devices. Either way,
as discussed in §III, existing USB fuzzers are not suited for
fuzzing USB gadget stacks as they are originally designed
to test USB host drivers. In particular, they do not much
take the key features of USB protocols into account: multiple
input channels and statefulness. Thus, their fuzzing efficiency
is limited significantly. FirmUSB [56] exercises symbolic
execution with USB domain knowledge and finds security
bugs in USB device firmware. However, it cannot tackle the
statefulness and multiple channel challenges either, and suffers
from other issues, such as path explosion.
Stateful fuzzing. Modern fuzzers often increase the efficiency
by taking the statefulness of programs under test [8–10, 58–63].
Commonly, OS kernel fuzzers [8–10, 58] try to resolve the
dependencies of system calls (and APIs), to generate better test
cases that fit into the input format specific to the target domain.
Despite such efforts to understand stateful kernel execution, it
cannot represent the accurate internal states of the target system,
thereby making stateful fuzzing less efficient. Known network
protocol fuzzers [60–62] or mobile application fuzzers [59]
also rely on stateful communication with explicit state ma-
chines. However, they require either network traces or mobile
communication logs in order to infer their state machines which
cannot accurately represent actual state machines of the target
system. More importantly, the aforementioned stateful fuzzers
must be customized significantly to fuzz USB software stacks
with multi-channel inputs. A recent work [63] devises stateful
fuzzing by taking advantage of good human oracle rules to
explore untested state space, but its mutation fully relies on
manual annotations. Consistent with their claim, we leverage
USB states as an oracle specialized in USB gadget fuzzing,
which existing works have not accomplished. Furthermore, our
oracles require in-depth analysis of complex USB software
stacks to define input spaces and automatically build state
machines.
IX. CONCLUSION
In this paper, we present FUZZUSB, the first USB fuzzing
technique for a USB gadget system. FUZZUSB achieves state-
guided fuzzing upon gadget-specific state machines, which
effectively addresses the multi-channel and stateful nature of
USB communication. FUZZUSB found 34 previously unknown
vulnerabilities with security impacts in the latest Linux and
Android kernels, and outperformed the baseline fuzzers with
3× higher code coverage, 50× improved bug-finding efficiency
for Linux USB gadget stacks, 2× higher code coverage for
FreeBSD USB gadget stacks, and reproducing known bugs
that the baseline fuzzers could not detect.
ACKNOWLEDGMENTS
We thank the anonymous reviewers for the valuable com-
ments and suggestions. This work was supported in part by
ONR under grants N00014-20-1-2128 and N00014-20-1-2205,
and NSF under grant CNS-1815883. This material is also based
on research sponsored by AFRL under contract number AFRL
FA8650-19-1-1741. Any opinions, findings, and conclusions
or recommendations expressed in this paper are those of the
authors and do not necessarily reflect the views of our sponsors.
REFERENCES
[1] “Usb
3.2
specifications,” USB
Implementers
https://www.usb.org/document-library/usb-
Forum
32-specification-released-september-22-2017-and-ecns,
2017.
[2] “Usb type-c® cable and connector specification,” USB
Implementers Forum https://www.usb.org/usb-type-cr-
cable-and-connector-specification, 2019.
[3] R. Langner, “Stuxnet: Dissecting a cyberwarfare weapon,”
IEEE Security & Privacy, vol. 9, no. 3, pp. 49–51, 2011.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:39:18 UTC from IEEE Xplore.  Restrictions apply. 
142225
[4] D. Kierznowski, “Badusb 2.0: Usb man in the middle
attacks,” Retrieved from RoyalHolloway, 2016.
[5] D. J. Tian, G. Hernandez, J. I. Choi, V. Frost, C. Raules,
P. Traynor, H. Vijayakumar, L. Harrison, A. Rahmati,
M. Grace et al., “Attention spanned: Comprehensive
vulnerability analysis of {AT} commands within the an-
droid ecosystem,” in 27th {USENIX} Security Symposium
({USENIX} Security 18), 2018, pp. 273–290.
[6] BlackHat, “Mactans: Injecting malware into ios devices
via malicious chargers,” https://media.blackhat.com/us-
13/US-13-Lau-Mactans-Injecting-Malware-into-iOS-
Devices-via-Malicious-Chargers-WP.pdf.
[7] S. Schumilo, C. Aschermann, R. Gawlik, S. Schinzel,
and T. Holz, “kafl: Hardware-assisted feedback fuzzing
for os kernels,” in Proceedings of the 26th USENIX
Security Symposium (Security), Vancouver, BC, Canada,
Aug. 2017.
[8] S. Pailoor, A. Aday, and S. Jana, “Moonshine: Optimiz-
ing os fuzzer seed selection with trace distillation,” in
Proceedings of the 27th USENIX Security Symposium
(Security), Baltimore, MD, USA, Aug. 2018.
[9] K. Kim, D. R. Jeong, C. H. Kim, Y. Jang, I. Shin, and
B. Lee, “Hfl: Hybrid fuzzing on the linux kernel,” in
Proceedings of the 2020 Annual Network and Distributed
System Security Symposium (NDSS), San Diego, CA, Feb.
2020.
[10] H. Han and S. K. Cha, “Imf: Inferred model-based fuzzer,”
in Proceedings of the 24th ACM Conference on Computer
and Communications Security (CCS), Dallas, TX, Oct.–
Nov. 2017.
[11] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida,
and H. Bos, “Vuzzer: Application-aware evolutionary
fuzzing,” in Proceedings of the 2017 Annual Network
and Distributed System Security Symposium (NDSS), San
Diego, CA, Feb.–Mar. 2017.
[12] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang,
J. Corbetta, Y. Shoshitaishvili, C. Kruegel, and G. Vigna,
“Driller: Augmenting fuzzing through selective symbolic
execution.” in Proceedings of the 2016 Annual Network
and Distributed System Security Symposium (NDSS), San
Diego, CA, Feb. 2016.
[13] D. R. Jeong, K. Kim, B. Shivakumar, B. Lee, and I. Shin,
“Razzer: Finding kernel race bugs through fuzzing,” in
Proceedings of the 38th IEEE Symposium on Security
and Privacy (Oakland), San Francisco, CA, May 2019.
[14] H. Peng and M. Payer, “Usbfuzz: A framework for fuzzing
usb drivers by device emulation,” in 25th USENIX Security
Symposium (USENIX Security 20), 2020, pp. 397–414.
[15] J. Patrick-Evans, L. Cavallaro, and J. Kinder, “Potus:
Probing off-the-shelf usb drivers with symbolic fault
injection,” in 11th USENIX Workshop on Offensive
Technologies (WOOT 17), 2017.
[16] D. Vyukov,
“Syzkaller,” https://github.com/google/
syzkaller, 2015.
[17] S. Schumilo, R. Spenneberg, and H. Schwartke, “Don’t
trust your usb! how to find bugs in usb device drivers,”
kcov.html, 2018.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:39:18 UTC from IEEE Xplore.  Restrictions apply. 
152226
Blackhat Europe, 2014.
“Umap2,”
[18] NCCGroup,
umap2.
https://github.com/nccgroup/
[19] T. Goodspeed and S. Bratus, “Facedancer usb: Exploiting
the magic school bus,” in Proceedings of the REcon 2012
Conference, 2012.
[20] Syzkaller, “Linux kernel usb bugs found by syzkaller,”
https://github.com/google/syzkaller/blob/master/docs/
linux/found_bugs_usb.md.
[21] Https://github.com/purseclab/fuzzusb.
[22] “Usb on the go and embedded host,” USB Implementers
Forum https://www.usb.org/usb-on-the-go.
[23] J. Hyde, “Usb multi-role device design by example,”
Comissioned by Cypress Semiconductors, 2003.
[24] “Class definitions for communication devices (1.2),”
USB Implementers Forum https://www.usb.org/document-
library/class-definitions-communication-devices-12.
[25] “Usb human interface device (hid) information,” USB
Implementers Forum https://www.usb.org/hid.
[26] “Mass
storage class
specification overview (1.4),”
USB Implementers Forum https://www.usb.org/document-
library/mass-storage-class-specification-overview-14.
[27] J. Becker,
“Configfs,”
https://www.kernel.org/doc/
Documentation/filesystems/configfs/configfs.txt.
[28] J. Corina, A. Machiry, C. Salls, Y. Shoshitaishvili, S. Hao,
C. Kruegel, and G. Vigna, “Difuze: Interface aware
fuzzing for kernel drivers,” in Proceedings of the 24th
ACM Conference on Computer and Communications
Security (CCS), Dallas, TX, Oct.–Nov. 2017.
[29] M. Xu, S. Kashyap, H. Zhao, and T. Kim, “Krace: Data
race fuzzing for kernel file systems,” in 2020 IEEE
Symposium on Security and Privacy (SP), 2020.
[30] “Usb gadget api for linux,” The Linux Kernel https://www.
kernel.org/doc/html/v4.17/driver-api/usb/gadget.html.
[31] M. Weiser, “Program slicing,” IEEE Transactions on
software engineering, no. 4, pp. 352–357, 1984.
[32] I. Yun, S. Lee, M. Xu, Y. Jang, and T. Kim, “Qsym: a
practical concolic execution engine tailored for hybrid
fuzzing,” in Proceedings of the 27th USENIX Security
Symposium (Security), Baltimore, MD, USA, Aug. 2018.
[33] M. Chalupa, “dg,” https://github.com/mchalupa/dg, 2016.
[34] C. Cadar, D. Dunbar, D. R. Engler et al., “Klee: Unas-
sisted and automatic generation of high-coverage tests for
complex systems programs.” in Proceedings of the 8th
USENIX Symposium on Operating Systems Design and
Implementation (OSDI), San Diego, CA, Dec. 2008.
[35] L. De Moura and N. Bjørner, “Z3: An efficient smt solver,”
in International conference on Tools and Algorithms for
the Construction and Analysis of Systems.
Springer,
2008, pp. 337–340.
[36] C. Lattner and V. Adve, “Llvm: A compilation frame-
work for lifelong program analysis & transformation,”
in International Symposium on Code Generation and
Optimization, 2004. CGO 2004.
IEEE, 2004, pp. 75–86.
[37] “Kcov,” https://www.kernel.org/doc/html/v4.15/dev-tools/
[38] “Kernel address sanitizer,” https://github.com/google/
kasan/wiki, 2018.
[39] “Undefined behavior sanitizer,” https://clang.llvm.org/
docs/UndefinedBehaviorSanitizer.html, 2018.
[40] “Kernel memory leak detector,” https://www.kernel.org/
doc/html/v4.10/dev-tools/kmemleak.html, 2018.
[41] MITRE, “CVE-2019-14763.” https://cve.mitre.org/cgi-
bin/cvename.cgi?name=CVE-2019-14763, 2019.
[42] ——, “CVE-2018-20961.” https://cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-2018-20961, 2018.
[43] FreeBSD,
https://cgit.freebsd.org/src/commit/?id=
9c847ffd743b4f68af56c5069da401bd1831efcb, 2020.
[44] T. F. Project, “Freebsd,” https://www.freebsd.org/.
[45] TechRadar, “Security holes put 100 million iot devices
at risk,” https://www.techradar.com/news/security-holes-
put-100-million-iot-devices-at-risk.
[46] S. I. E. Inc., “Open source software used in playstation
3,” https://doc.dl.playstation.net/doc/ps3-oss/index.html.
[47] F. bug report, https://bugs.freebsd.org/bugzilla/, 2020.
[48] Syzkaller,
“Syzkaller
android
for
device,”
https://android.googlesource.com/platform/external/
syzkaller/+/HEAD/docs/linux/setup_linux-host_android-
device_arm64-kernel.md.
[49] L. F. Projects, “Zephyr rtos,” https://www.zephyrproject.
org/.
[50] ARM, “Mbed os,” https://os.mbed.com/mbed-os/.
[51] T. Kim, V. Kumar, J. Rhee, J. Chen, K. Kim, C. H. Kim,
D. Xu, and D. J. Tian, “Pasan: Detecting peripheral access
concurrency bugs within bare-metal embedded applica-
tions,” in 30th USENIX Security Symposium (USENIX