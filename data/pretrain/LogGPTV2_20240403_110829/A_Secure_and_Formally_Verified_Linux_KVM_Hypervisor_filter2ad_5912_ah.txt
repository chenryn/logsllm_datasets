extern void set_s2pg_owner(uint pfn, uint owner);
// Primitive provided by NPTOps
void set_npt(uint vmid, uint gfn, uint pfn) {
acq_lock_npt(vmid);
uint pte = pt_load(vmid, pgd_offset(gfn));
pt_store(vmid, pte_offset(pte,gfn), pfn);
rel_lock_npt(vmid);
}
return None) if the event is not valid with respect to the current
state. For example, the replay function returns the load result for
a page table pool load event P_LD, but the event is only allowed
if the lock is held by the current CPU:
Definition replay_event (e: Event) (obj: SharedObj) :=
match e with
| (P_LD vmid ofs, cpu) =>
match ZMap.get vmid (pt_locks obj) with
| Some cpu’ => (*the pt lock of vmid is held by cpu’*)
if cpu =? cpu’ (* if cpu = cpu’ *)
then let pool := ZMap.get vmid (pt_pool obj) in
Some (obj, Some (ZMap.get ofs pool))
else None (* fails when held by a different cpu *)
| None (* fails if not already held *)
end
// Primitive provided by MemOps
uint assign_to_vm(uint vmid, uint gfn, uint pfn) {
uint res = 1;
acq_lock_s2pg();
uint owner = get_s2pg_owner(pfn);
if (owner == KSERV) {
set_npt(KSERV, pfn, 0);
set_s2pg_owner(pfn, vmid);
set_npt(vmid, gfn, pfn);
} else res = 0; // pfn is not owned by KSERV
rel_lock_s2pg();
return res;
}
// Primitive provided by TrapHandler
void run_vcpu(uint vmid) {
...
assign_to_vm(vmid, gfn, pfn);
...
}
Fig. 8: Simplified implementation for handling a stage 2 page fault.
Primitives from four layers are called. For simplicity, other primitives in
the layers are omitted and only two levels of paging are shown.
doracle_counter: Z; (* data oracle query counter *)
...
}.
(* Abstract state *)
Record AbsSt := {
log: Log;
cid: Z; (* local CPU identifier *)
vid: Z; (* vmid of the running principal on CPU cid *)
lstate: ZMap.t LocalState; (* per-VM local state *)
}.
The abstract state does not contain shared objects, which are
constructed using the log through a replay function:
(* Shared objects constructed using replay function *)
Record SharedObj := {
mem: ZMap.t Z; (* maps addresses to values *)
s2pg_lock: option Z; (* s2pg lock holder *)
pt_locks: ZMap.t (option Z); (* pt lock holders *)
pt_pool: ZMap.t (ZMap.t Z); (* per-VM page table pool *)
(* s2pg_array maps pfn to (owner, share, gfn) *)
s2pg_array: ZMap.t (Z * Z * Z);
}.
Fixpoint replay (l: Log) (obj: SharedObj) :=
match l with
| e::l’ => match replay l’ obj with
| Some (obj’, _) => replay_event e obj’
| None => None
end
| _ => Some st
end.
The replay function recursively traverses the log to reconstruct
the state of shared objects, invoking replay_event to handle each
event and update shared object state; this update may fail (i.e.,
| ... (* handle other events *)
end.
We then define NPTWalk’s layer interface as a map from function
names to their specifications defined upon the abstract state:
Definition NPTWalk: Layer AbsSt :=
acq_lock_npt
⊕ rel_lock_npt
⊕ pt_load
⊕ pt_store
⊕ acq_lock_s2pg
⊕ rel_lock_s2pg
⊕ get_s2pg_owner
⊕ set_s2pg_owner
(cid:55)→ csem acq_lock_npt_spec
(cid:55)→ csem rel_lock_npt_spec
(cid:55)→ csem pt_load_spec
(cid:55)→ csem pt_store_spec
(cid:55)→ csem acq_lock_s2pg_spec
(cid:55)→ csem rel_lock_s2pg_spec
(cid:55)→ csem get_s2pg_owner_spec
(cid:55)→ csem set_s2pg_owner_spec.
These primitives are defined in a language-independent way and
are lifted to C-level semantics through a wrapper function csem, so
that arguments and return values are passed according to C calling
conventions. As discussed in Section III-A, MicroV supports
CPU-local reasoning, using event oracles to encapsulate events
generated by other CPUs. A primitive accessing shared objects
can be specified in a CPU-local manner. For example, pt_load’s
specification queries event oracle o to obtain events from other
CPUs, appends them to the logical log (producing l0), checks the
validity of the load and calculates the load result using replay,
then appends a load event to the log (producing l1):
(* Event Oracle takes the current log and produces
a sequence of events generated by other CPUs *)
Definition EO := Log -> Log.
Definition pt_load_spec
(o: EO) (st: AbsSt) (vmid ofs: Z) :=
let l0 := o (log st) ++ log st in (*query event oracle*)
(* produce the P_LD event *)
let l1 := (P_LD vmid ofs, cid st) :: l0 in
match replay l1 with
(* log is valid and P_LD event returns r *)
| Some (_, Some r) => Some (st {log: l1}, r)
| _ => None
end.
pt_load_spec relies on the assumption that events generated by
other CPUs are valid with respect to the replay function—a rely
condition. When rely conditions hold for all other CPUs, we can
prove that all events generated by the local CPU are also valid—a
guarantee condition. Since each CPU’s rely condition follows from
the guarantee conditions of other CPUs, the execution of all CPUs
can be soundly composed.
Data oracles can be used for primitives that declassify data,
as discussed in Section III-B. For example, set_s2pg_owner
changes the ownership of a page. When the owner is changed
from KServ to a VM vmid, the page contents owned by KServ is
declassified to VM vmid, so a data oracle is used in the specification
of set_s2pg_owner to mask the declassified contents:
1798
Definition set_s2pg_owner_spec
(o: EO) (st: AbsSt) (pfn vmid: Z) :=
let l0 := o (log st) ++ log st in
let l1 := (SET_OWNER pfn vmid, cid st) :: l0 in
match replay l1 with
| Some _ => (* log is valid and lock is held *)
let st’ := st {log: l1}) in
if vid st =? KSERV && vmid != KSERV
then (* pfn is transferred from KServ to a VM *)
mask_with_doracle st’ vmid pfn
else Some st’
| _ => None
end.
We introduce an auxiliary Coq definition mask_with_doracle to
encapsulate the masking behavior:
Definition mask_with_doracle (st: AbsSt) (vmid pfn: Z) :=
let local := ZMap.get vmid (lstate st) in
let n := doracle_counter local in
let val := data_oracle local n in
let l := (SET_MEM pfn val, cid st) :: log st in
let local’ := local {doracle_counter: n+1} in
st {log: l, lstate: ZMap.set vmid local’ (lstate st)}
mask_with_doracle queries the local data oracle of VM vmid
with a local query counter, generates an event to mask the
declassified content with the query result, then updates the local
counter. Since each principal has its own data oracle based on its
own local state, the behavior of other principals cannot affect the
query result. set_s2pg_owner_spec only queries the data oracle
when the owner is changed from KServ to a VM. When the owner
is changed from a VM to KServ, the page is being freed and KCore
must zero out the page before recycling it; masking is not allowed.
We also introduce auxiliary definitions to mask other declassified
data, such as page indices and scheduling decisions proposed by
KServ, which are not shown in this simplified example.
Layer 2: NPTOps. This layer introduces the set_npt primitive
for higher layers to update page table entries, and hides page table
structures and page walk details by removing NPTWalk’s primitives
related to page table pools. Other primitives are passed through.
Definition NPTOps: Layer AbsSt :=
set_npt
⊕ acq_lock_s2pg
⊕ rel_lock_s2pg
⊕ get_s2pg_owner
⊕ set_s2pg_owner
(cid:55)→ csem set_npt_spec
(cid:55)→ csem acq_lock_s2pg_spec
(cid:55)→ csem rel_lock_s2pg_spec
(cid:55)→ csem get_s2pg_owner_spec
(cid:55)→ csem set_s2pg_owner_spec.
set_npt’s specification simply generates an atomic event SET_NPT:
Definition set_npt_spec
(o: EO) (st: AbsSt) (vmid gfn pfn: Z) :=
let l0 := o (log st) ++ log st in
let l1 := (SET_NPT vmid gfn pfn, cid st) :: l0 in
match replay l1 with
| Some _ => Some (st {log: l1})
| _ => None
end.
To show set_npt meets the above specification, we prove that its C
code implementation running over NPTWalk faithfully implements
set_npt_spec for all possible interleavings across CPUs:
∀EO, ∃EO’, Mset_npt(EO)@NPTWalk (cid:118)R set_npt_spec(EO’)
This says that, for any valid event oracle EO of NPTWalk, there
exists a valid event oracle EO’ for NPTOps such that, starting from
two logs related R, the logs generated by the implementation and
specification, respectively, are still related by R. Here, R is the re-
finement relation, which maps the SET_NPT event to the following
four consecutive events and maps other events to themselves:
ACQ_NPT
P_LD
P_ST
REL_NPT
To prove this refinement, MicroV first uses CompCert’s
ClightGen to parse the C implementation to its Clight representation
Mset_npt, a C abstract syntax tree defined in Coq. Based on the
semantics of Clight, we can show that, for event oracle EO and log
l, the updated log after executing Mset_npt is:
[l, EO1, ACQ_NPT, EO2, P_LD, EO3, P_ST, EO4, REL_NPT, EO5]
where EOn represents other CPUs’ events, from the event oracle.
Since the lock_npt spinlock enforces WDRF over VM vmid’s
shared page table pool pt_poolvmid, events generated by other CPUs
can be safely shuffled across events in the same observer group
over pt_poolvmid using transparent trace refinement. For example,
EO3 can be shuffled to the left of P_LD since the replayed state
before and after P_LD share the same pt_poolvmid, but cannot be
shuffled to the right of P_ST, which belongs to a different observer
group. Thus, we can shuffle the above log to the following:
[l, EO1, EO2, EO3, ACQ_NPT, P_LD, P_ST, REL_NPT, EO4, EO5]
We can then prove that this log transparently refines the log
generated by the specification:
when the input logs and oracle EO’ satisfy R, i.e., R l l(cid:48),
R [EO1’] [EO1, EO2, EO3], and R [EO2’] [EO4, EO5].
[l(cid:48), EO1’, SET_NPT, EO2’]
We can also show that the following log generated by the insecure
implementation shown in Section III-A cannot be transparently
refined to the specification’s log, because EO4 cannot be shuffled
across observer groups:
[l, EO1, ACQ_NPT, EO2, P_LD, EO3, P_ST, EO4, P_ST, EO5, ...]
Layer 3: MemOps. This layer introduces the assign_to_vm
primitive to transfer a page from KServ to a VM, and hides NPTOps
primitives:
Definition MemOps: Layer AbsSt :=
assign_to_vm
(cid:55)→ csem assign_to_vm_spec.
assign_to_vm’s specification has a precondition that it must be
invoked by KServ and the vmid must be valid:
Definition assign_to_vm_spec
(o: EO) (st: AbsSt) (vmid gfn pfn: Z) :=
if vid st =? KSERV && vmid != KSERV
then
let l0 := o (log st) ++ log st in
let l1 := (ASG_TO_VM vmid gfn pfn, cid st) :: l0 in
match replay l1 with
| Some (_, Some res)) => (* res is the return value *)
let st’ := st {log: l1} in (* update the log *)
if res =? 1 (* if pfn is owned by KSERV *)
then mask_with_doracle st’ vmid pfn
else Some st’ (* return without masking the page *)
| _ => None
end
(*get stuck if it’s not transferred from KServ to a VM*)
else None.
It transfers a page from KServ to a VM via set_s2pg_owner, so the
contents are declassified and must be masked using the data oracle.
Layer 4: TrapHandler. This top layer interface introduces
run_vcpu, which invokes assign_to_vm and context switches
from KServ to the VM. We first prove that run_vcpu does
not violate the precondition of assign_to_vm. We then prove
noninterference as discussed in Section V-B. We can see here why
the page content will be masked with the same data oracle query
results in the proof of Lemma 3 for run_vcpu in Section V-B. Two
indistinguishable states will have the same VM local states, and
therefore the same local data oracle and counter. Thus, the data
oracle query results must be the same.
1799