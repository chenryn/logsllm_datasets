    QjYxMUI5QThEMUExRTU4MjFFMkEyQjAzQjQ0NjBFQjgwREQ3NTU5MEY5QzAxQzk1NkRFNjA3MkQyNjI=
    N0I5REU5NjdEMDMyRkVCQUQ5QzY3MjQxODdFMEU5NTU0ODVBNEM4RDgwOTk5NkZCODZDODQxOTM3Qzi=
    REVDNjY3QTYxM0Y0MUM0QTE5QkE4NUVCN0FGNDY5MkM0N0VFREI2RUE3NTJGN0VBMTczQ0VBRUU5MTV=
    MzY4N0U3QzJFMTM3MzUxRjYzQUY5MEExRDM2RjQ3MkU1NjcxOUI2MzI5RjE4NEY4QkQ0RDRGMDE4N0R=
    REU5MDc5NzkzRTgzMTNENUU1NDMzOUY3MEZBNTNBRjg3QTAzNUZCODM3QjIwNjMwOTUxMTU5QUM1MEP=
    NDExQTIyQzVCODVCQzIwMjdDODNEMkE4QkZFNDE5M0U3MjNCQUNFRkQxOUU4QzNGQTUyOUE1QjM0QUP=
    RTI5RURENzMxOUEwNjc3RkM3Nzg3QzJFQjIxNUZENDE0NjFBNjg1MDBEMDg1RUYzQzg5MDRFQ0MxQjd=
    RTgwOTEzNUIzNDREMkY5RUNBRTZDRTM4NUIxREQ0MTQyREUzRjMyOTZFRDE2MTE3RjgyRUVDODMzRjO=
    QTkyRUUwQzU4RTlGNENBRkU1RjlEMzBFREQ4NzFFNTVGRjBBREEyM0VEQ0IyN0VFNzNDQjVDRTBBMTA=
    MjBFMkZCNkUxQkUzNDNDQUY0MjFFOTc0Njc5N0MwNjIzNzkyMjc4NUFGNkY3M0M5M0I5MjEyN0NBNDF=
    RjRBQUJFMDE1QTk4N0Y3NTYwNUNFODM2NkNEQkQwNjk5NTYwQkVFMzE5MTc3RjQ3NkZBMUUzQjY4MUJ=
    QjM1Q0ZFQTFFNEEwMTFCMzZGNDMwNThDQjlDOUI4OUQ3MTUwRTY4RDQ3NEU4MEI3N0YzNkI5Qjc5NEW=
    MDFCRkQ1NTE2NDcxNkVCRjQ0MUNCRjJEMDMzQUIzRkJBREFFNzQ5RjdGODZCQTIyMTdEODg4QUE1MTD=
    NkY3QzgyQTM0REFGNkE1MDJCQjJBRTU1NTk5NTM0RjZCRTgwOTM2MkYxMzk4MERFREE2Q0JCMTFDOUW=
    QTY3MkZBMDdGMEY5RUJCMTdDRjNFRkJGMkIxRkRGNkQzQzlCNkJCMTBGMTgwQ0FFOUZDQjAwN0YxMUF=
    QUQyREQ3MTdGRTdDRDZCQ0EzRUNDMkUyQkY3ODNCM0UwRTQ1NkY2NUI1QjQ2MzA3QTNCODMwNUQzQTG=
    OUNDQTJEQjc5OEUwNkQxNzVDNTkyNjZEOEFCNjA0REUzMTQ3QjE3MzNCRjEzQUI2NDBCQzlGRTY4RkU=
    NTA2MTk0N0JDRDAwN0U2Q0IxOEI2QUUyRDM3RENFQkQ4RENGMURFQTU3QzgyRUZCN0U4NUMzNUEwQjN=
    NEZEODQ2NkNENEEyM0NBMkVDQjJCMDkzOTcxNUVGODk5N0Q4RDY4QTMxNjkwMThFMTdFRUM1NzM3NzB=
    Rjc1MTlDRjNDODMyMTU1MDA1QkI1RjFBMTFFQ0MxODNGMzBBRjFCRjQwMkJDRTVCM0U1MEU0Qzg2RDe=
    NkRDREY4Q0E2N0M4RDVBN0IyRjZFOEUyQ0I1MkZBM0RCMkNERkQyQTMwNzBENTk2NENDODNDNzI3OEP=
    QkYzMUUxRjZFQ0FGREVGRkQ1NkU5MzJCRjg1MzE2MDJCQzE4NkQzRkI5N0YyRERERjYyNjNDM0Q1MUY=
    QkY3RUZDRkFGMUVCQzdBRjFGQkY3RUZDRkFGMUVCM0ZBOEFGMUYxRDgwMUZCRjdFRkNGQUYxRUJDN0F=
    RjFGQkY3RUZDRkEwRkYwRUI0NzA3RTBDN0FGMUZCRjdFRkNGQUYxRUJDN0FGMUZCRkZFMDNGQ0ZBRDH=
    MDFGOEYxRUJDN0FGMUZCRjdFRkNGQUYxRUJDN0FGRkYwMEJGOUE1RkZENzc3RkY0RDYyMjlGRkFGMkG=
    OTJDQ0JBOUQ0MTYzNjU1NEI1OTE3NEJCMTRFNjUyOTg3RDJBQzRERDk3ODdGNkJGQjE0QTNBQzk3NkJ=
    ODk1MDRFNDcwRDBBMUEwQTAwMDAwMDBENDk0ODQ0NTIwMDAwMDIwMDAwMDAwMjAwMDgwNjAwMDAwMEZ=
    NDc4RDRGQTAwMDAwMDAxNzM1MjQ3NDIwMEFFQ0UxQ0U5MDAwMDAwMDQ2NzQxNEQ0MTAwMDBCMThGMEL=
    RkM2MTA1MDAwMDAwMjA2MzQ4NTI0RDAwMDA3QTI2MDAwMDgwODQwMDAwRkEwMDAwMDA4MEU4MDAwMDc=
    NTMwMDAwMEVBNjAwMDAwM0E5ODAwMDAxNzcwOUNCQTUxM0MwMDAwMDAwOTcwNDg1OTczMDAwMDBFQzT=
    MDAwMDBFQzQwMTk1MkIwRTFCMDAwMEZGNzk0OTQ0NDE1NDc4NUVFQ0ZEQzk5MjZDNTk3NkE2ODlFRER=
    M0FCNUE3QkVGNzVGN0YwODg0MEEwQUQ4RTk5QTQ5MEE4MkFDOTRBNjZCMjgwNDQwNTkwQUMyMjFGQTS=
    NjYyNTU5MDg4MDQzOEE1QzBFMzlFMDJCNzA1MjEzOEUzOEUwN0I1MDg0MTMwRTk4QzgwNDA0MDFDMDN=
    REJDQjk5RDk5Njk3NzVBN0VERkFGOEU3QTg5NzRCQjZFNkU2NkFBNDdDRkQ5N0IzNUZGNkFGNkRBNkJ=
    NTdCRkZFQkZGRTlGQjdDMkQ3NTI3NkE1NkM1MzY5RUE3MzI5QTdCOUQ0RkJBMTZDNzM1NTRBREY5NDd=
    NTNFOTc2NjFCQ0FDMkZCRUJGQzVDOUFGRDZENTk3ODZGMURDNzUyM0FCRTk3QUU1NDAzOUZBRjJFQTX=
    N0E5OTc4NkQyRUQ1QjJGMDMyOUY1OTJBRUVEOTk0N0E5OTRBM0QxRENCREM3REM5NzM4RTY1NUI2RjT=
    QUQzQkU5NDdBMUVDQjNBRjRBNTE5Qjk3RTc4NTVFQUY1NThFQURCQkI1MjlGQkUyRkY1RjBEOUY1OUV=
看到这么多行以及这么多等号，易得是base64隐写，脚本一把梭，得到flag
`Dozerctf{itis_e4sy_4U2_analyse}`
## CRYPTO
###  真·签到
先改文件名后缀为txt，然后b64decode->b32decode->b16decode->b58decode
###  eazy_bag
knapsack problem
[安全客的文章](https://www.anquanke.com/post/id/206493#h3-11)就是我写的
直接脚本一把梭
    a = #填入序列a
    s = #填入密文值
    m=[]
    for i in range(len(a)):
        b=[]
        for j in range(len(a)):
            if i == j:
                b.append(1)
            else:
                b.append(0)
        m.append(b)
    b=[]
    for i in range(len(a)):
        m[i].append(2**350*a[i])
        b.append(1/2)
    b.append(2**350*s)
    m.append(b)
    #print(len(m[0])) 
    M = matrix(QQ, m)
    v = M.LLL()[0]
    print(v)
    flag=''
    for i in v[:-1]:
        if i 
首先交互拿到数据
    import os
    import string
    from hashlib import sha256
    from pwn import *
    context.log_level='debug'
    def dopow():
        chal = c.recvline()
        post = chal[12:28]
        tar = chal[33:-1]
        c.recvuntil(':')
        found = iters.bruteforce(lambda x:sha256(x+post).hexdigest()==tar, string.ascii_letters+string.digits, 4)
        c.sendline(found)
    def doxor(ss,dd):
        res = ''
        for i in range(8):
            res += chr(ord(ss[i])^dd[i])
        return res
    def tonum(x):
        return (u32(x[:4])
    #include 
    #include 
    #define MAX_CHOSEN_PAIRS 10000
    #define ROTATE_LEFT(x, n) (((x) > (32-(n))))
    int winner = 0;
    int loser = 0;
    unsigned long subkey[6];
    unsigned long statickey[6] = { 0x6bb508a,0xd72eaec0,0x71d88eee,0xa5da0171,0x3139398f,0x2ccdf0f0 };
    unsigned char rotl2(unsigned char a) { return ((a > 6)); }
    unsigned long leftHalf(unsigned long long a) { return (a >> 32LL); }
    unsigned long rightHalf(unsigned long long a) { return a; }
    unsigned char sepByte(unsigned long a, unsigned char index) { return a >> (8 * index); }
    unsigned long combineBytes(unsigned char b3, unsigned char b2, unsigned char b1, unsigned char b0)
    {
        return b3 << 24L | (b2 << 16L) | (b1 << 8L) | b0;
    }
    unsigned long long combineHalves(unsigned long leftHalf, unsigned long rightHalf)
    {
        return (((unsigned long long)(leftHalf)) << 32LL) | (((unsigned long long)(rightHalf)) & 0xFFFFFFFFLL);
    }
    unsigned char gBox(unsigned char a, unsigned char b, unsigned char mode)
    {
        return rotl2(a + b + mode);
    }
    unsigned long fBox(unsigned long plain)
    {
        unsigned char x0 = sepByte(plain, 0);
        unsigned char x1 = sepByte(plain, 1);
        unsigned char x2 = sepByte(plain, 2);
        unsigned char x3 = sepByte(plain, 3);
        unsigned char t0 = (x2 ^ x3);
        unsigned char y1 = gBox(x0 ^ x1, t0, 1);
        unsigned char y0 = gBox(x0, y1, 0);
        unsigned char y2 = gBox(t0, y1, 0);
        unsigned char y3 = gBox(x3, y2, 1);
        return combineBytes(y0, y1, y2, y3);
        //return combineBytes(y3, y2, y1, y0);
    }
    unsigned long long encrypt(unsigned long long plain)
    {
        unsigned long left = leftHalf(plain);
        unsigned long right = rightHalf(plain);
        //printf("%x,%xn",left,right);
        left = left ^ subkey[4];
        right = right ^ subkey[5];
        right = right ^ left;
        //printf("%x,%xn",left,right);
        unsigned long round2Right = left;
        unsigned long round2Left = right ^ fBox(left ^ subkey[0]);
        //printf("after k0: %x,%xn",round2Left,round2Right);
        unsigned long round3Right = round2Left;
        unsigned long round3Left = round2Right ^ fBox(round2Left ^ subkey[1]);
        //printf("after k1: %x,%xn",round3Left,round3Right);
        unsigned long round4Right = round3Left;
        unsigned long round4Left = round3Right ^ fBox(round3Left ^ subkey[2]);
        //printf("after k2: %x,%xn",round4Left,round4Right);
        left = round4Right ^ fBox(round4Left ^ subkey[3]);
        right = round4Left;