may refresh at different rates.
2) Upgrading (2, n) Schemes. We show how to upgrade (2,
n) threshold Schnorr-like signature schemes to proactive
security tailored for use with a threshold wallet, in that
it makes use of transactions posted to the blockchain
for synchronization purposes. We make the case in Sec-
tion IV-B that the power of a ledger is necessary for
this task. Our refresh protocol adds no extra assumptions,
incurs very little overhead as compared to running the
threshold signature itself, and exactly matches the ideal
communication pattern outlined in the previous section.
3) Proactive Multiplication. We construct a mechanism
to proactivize OT Extension state. This allows us to
proactivize even threshold ECDSA protocols, which are
sophisticated due to the non-linear signing equation. We
prove the efﬁciency of our construction by means of
an implementation, speciﬁcally the overhead incurred in
computational time of our refresh procedure is roughly
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
609
24% for the ECDSA protocol of Doerner et al. [7] and
14% in the case of Gennaro and Goldfeder [5], while the
communication round overhead is zero in both cases.
4) Impossibility of Online Dishonest Majority for (3, n)
and Beyond. Intuition would strongly suggest that any (t,
n) threshold scheme could also be upgraded to proactive
security with ofﬂine refresh in the presence of a dishonest
majority online using sufﬁciently heavy cryptographic
hammers. However, surprisingly we show this intuition to
be false; i.e. even assuming arbitrary trusted setup/random
there must be an honest
oracle and an ideal
majority online to refresh the system. We prove this result
by developing new elegant techniques to reason about
security in this setting.
ledger,
We therefore formulate the problem of ofﬂine refresh and
address the most pressing practical and theoretical questions:
the honest majority online case is simple, the (2, n) case
permits a novel efﬁcient protocol with a ledger which we
implement, and the (t, n) case for t > 2 must necessarily
have an honest majority of participants online.
Broader Implications: Our results can be interpreted
as positive for small-scale decentralization, eg. 2FA across
personal devices. In particular the (2, n) refresh protocol is
readily compatible with existing implementations of threshold
wallets, and essentially comes at only the cost of implementing
forward-secure channels. However our impossibility result
rules out this strong form of security for larger scale systems,
where many servers hold shares of a secret with a high
reconstruction threshold. In those cases system designers who
desire proactive security must account for the cost of either
bringing an honest majority online, or waiting to hear from
all parties before progressing epochs.
D. Our Techniques
Below we sketch the ideas behind our (2, n) construction,
and later we discuss the general (t, n) case and show an
impossibility for it. Recall that (t, n) means that at most t− 1
parties may be corrupt among the set of n at any given time,
online or not (since by deﬁnition any set of t parties should
jointly have enough information to access the secret key).
1) (2, n) Construction: Roughly, our approach is to use
private channels to communicate candidate refresh packages,
and the public ledger to achieve consensus on which one to
use. We note that to perform “spend” transactions, the wallets
are already required to post signatures on the ledger as part of
the transaction; we take advantage of this fact and use the exact
same signatures posted on the ledger to coordinate refreshes,
without the need to modify their content. Let each party Pi
own point f (i) on a shared polynomial f where f (0) = sk (i.e.
standard Shamir sharing of the secret key sk). We have parties
generate a candidate refresh polynomial f(cid:48) when they sign a
message, associate each signature with f(cid:48), and “apply” the
refresh (i.e. replace f (i) with f(cid:48)(i)) when the corresponding
signature appears on the blockchain. While this handles the
coordination part, the major issue of veriﬁably communicating
f(cid:48)(j) to ofﬂine party Pj remains a challenge. To solve this,
we have the online refreshing parties jointly generate a local
threshold signature authenticating f(cid:48) when communicated to
each ofﬂine party; such a signature can only be produced by
two parties working together, so any candidate f(cid:48) received
when ofﬂine must have been created with the approval of an
honest party.
a) Working Around Unfairness: Note that this approach
is still vulnerable to attacks where the adversary withholds the
threshold signature from an honest party in the protocol; if an
online signing protocol aborts, how does an honest party know
if its (possibly malicious) signing counterparty sent f(cid:48) and the
corresponding signature to ofﬂine parties? This is an issue that
stems from the inherent unfairness of two-party computation.
While this is impossible to solve in general, we observe
that most threshold ECDSA/Schnorr signature protocols are
simulatable so the signing nonce R is leaked, but the signature
itself stays hidden until the ﬁnal round. We exploit this fact
to bind each f(cid:48) to R instead of the signature itself; so our
proactive version of threshold ECDSA/Schnorr will proceed
as follows:
i. Run the ﬁrst half of threshold ECDSA/Schnorr to obtain
ii. Sample candidate f(cid:48), bind it to R, threshold-sign these
R.
values and send them to ofﬂine parties.
iii. Continue with threshold ECDSA/Schnorr to produce the
signature itself.
Correspondingly when any signature under R appears on the
blockchain, each party searches for a bound f(cid:48) that it can
apply. With overwhelming probability there will never be two
independently generated signatures that share the same R
nonce throughout the lifetime of the system.
a
require use of
b) Threshold ECDSA and Multipliers:
secure
Threshold
ECDSA protocols
two-party
multiplication functionality FMUL (or equivalent protocol) due
to its non-linear signing equation. Indeed, recent works [5],
[6], [7] have constructed practical threshold ECDSA protocols
that make use of multipliers that can be instantiated with
either Oblivious Transfer or Paillier encryption. Using these
multipliers is signiﬁcantly more efﬁcient in the ofﬂine-online
model where parties run some kind of preprocessing in parallel
with key generation, and make use of this preprocessed state
for efﬁcient FMUL invocation when signing a message (this
is done by all cited works). However as this preprocessed
state is persistent across FMUL invocations, it becomes an
additional
to defend from a mobile adversary. We
show how to efﬁciently re-randomize this preprocessed
state for OT-based instantiations of FMUL, and therefore get
ofﬂine-refresh proactive security for (2, n) threshold ECDSA
in its entirety. Our proactivization of FMUL makes novel
use of the classic technique of Beaver [15] to preprocess
oblivious transfer, in combination with the mechanism we
build to deliver updates securely.
target
2) General (t, n) Impossibility: We develop a novel tech-
nique to reason about the security of protocols that tolerate
mobile corruptions. We ﬁrst prove that any refresh protocol
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
610
that tolerates an online dishonest majority must have the prop-
erty that a minority of online parties holds enough information
to allow any ofﬂine party to refresh. Subsequently we show
that a mobile adversary can exploit this property to derive
the refreshed private state of a previously corrupt ofﬂine party
even after it is un-corrupted. The proof is built up from this
underlying insight, discussed further in Section X.
E. Related Work
The notion of mobile adversaries with a corresponding
realization of proactive MPC was ﬁrst introduced by Ostrovsky
and Yung [12]. Herzberg et al. [16] devise techniques for
proactive secret sharing, subsequently adapted for use in
proactive signature schemes by Herzberg et al. [17]. Cachin
et al. [18] show how to achieve proactive security for a
shared secret over an asynchronous network. Maram et al. [19]
construct a proactive secret sharing scheme that supports
dynamic committees, with a portion of the communication
done through a blockchain. For a more comprehensive survey,
we refer the reader to the works of Maram et al. [19] and
Nikov and Nikova [20].
The work of Canetti et. al. [21] solves the problem of an
ofﬂine node regaining the ability to authenticate its communi-
cation after having suffered a break-in. However the settings
are incomparable; our network model is stronger in that we
assume authenticated communication (details in Section IV),
but weaker in another dimension as we do not rely on an
honest majority among online parties. Our use of the ledger is
merely as a passive public signalling mechanism, and not as
interactive party-speciﬁc storage (eg. no issuing of certiﬁcates
to individual parties).
As discussed earlier, every existing work (including those
since the above mentioned surveys) assumes either that all par-
ties come online [22], an honest majority of parties collaborate
in order to proactivize the system [23], [24], or that corruptions
are passive [25]. Additionally they require this honest majority
of parties to come online simultaneously at pre-speciﬁed points
in time to run the refresh protocol. As the entire premise of
the (t, n) threshold signature setting is that only t parties need
be online simultaneously to use the system,
• For the (2, n) case we impose as a strict requirement that
only two parties be sufﬁcient to proactivize the system.
As it is meaningless to have an honest majority among
two parties, we can not directly apply techniques from
previous works to our setting. To our knowledge the
conceptual core of our protocol– a threshold signature
(internal
to the system) interleaved with a threshold
signature that appears on the blockchain, is novel.
• For the general t > 2 case, we prove that the weakest
possible notion of dishonest majority for proactivization,
i.e. refresh with 2t − 1 online parties, is impossible to
achieve.
Therefore we give a comprehensive treatment of proactiviza-
tion with an online dishonest majority, which has not previ-
ously been studied in the literature.
F. Organization
We ﬁrst present the deﬁnitions we use in Section II. We
then give our formalization of mobile adversaries and ofﬂine
refresh in Section III, following which we detail our threshold
signature abstraction in Section V. We begin by introduc-
ing the protocol to coordinate simple (2,2) key refresh in
Section VI, and then give the extension to (2, n) proactive
threshold signatures in Section VII. Following this, we show
how to proactivize every component of the more sophisticated
recent ECDSA protocols in Section VIII. We demonstrate the
practicality of our protocols by implementation to augment
two different ECDSA protocols,
the results of which we
present
in Section IX. Finally we prove the impossibility
of ofﬂine refresh with a dishonest online majority for larger
thresholds in Section X.
II. PRELIMINARIES
Throughout this paper, we ﬁx the corruption threshold as
t = 1 and hence formulate all of our deﬁnitions assuming one
malicious adversarial corruption.
a) Network Model: We assume a synchronous network,
as already required by recent threshold signature schemes [5],
[6], [7]. For the blockchain model, we follow the synchronous
functionality of Kiayias et al. [26]. In this functionality, the
blockchain only progresses after all parties ﬁnish their current
round, therefore parties are always synchronized during the
protocol run.
Additionally, we make the necessary assumption of proac-
tive channels that support delivery to ofﬂine parties, discussed
further in Section IV-A.
b) Protocol Input/Output Notation for (2, n) setting: The
(2, n) protocols in this paper are described for any pair of
parties indexed by i, j ∈ [n]. In particular, any two parties
Pi, Pj out of a group of n parties (cid:126)P can run a protocol π with
private inputs xi, xj to get their private outputs yi, yj respec-
tively. For ease of notation since all of our protocols have the
same instructions for each party, we choose to describe them
as being run by Pb with P1−b as the counterparty. The general
format will be
yb ← π(1 − b, xb)
to denote that Pb gets output yb by running protocol π with
input xb and counterparty P1−b. For instance if π is run
between P2 and P6, the protocol as described from the point
of view of P6 is interpreted with b ≡ 6 and 1 − b ≡ 2.
c) Ideal Functionalities: We assume access to a number
of standard ideal functionalities: FCom (commitment), F RDL
Com-ZK
(commited proof of knowledge of discrete logarithm), FCoin
(coin tossing), FMUL (two-party multiplication) given formally
in Appendix C.
d) Adversarial Model: We prove our protocols secure in
the Universal Composability (UC) framework of Canetti [14].
We give the speciﬁcs of our modelling in Section III.
A. Blockchain Model
We detail here the relevant aspects of the underlying
blockchain system that is required for our (2, n) protocol.
611
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:17:03 UTC from IEEE Xplore.  Restrictions apply. 
a) A Transaction Ledger Functionality: A transaction
ledger can be seen as a public bulletin board where users
can post and read transactions from the ledger. As it was
shown in [27], a ledger functionality must intuitively guarantee
the properties of persistence and liveness, that we informally
discuss next.
• Persistence: Once a honest user in the system announces
a particular transaction as ﬁnal, all of the remaining users
when queried will either report the transaction in the
same position in the ledger or will not report any other
conﬂicting transaction as stable.
• Liveness: If any honest user in the system attempts to
include a certain transaction into their ledger, then after
the passing of some time, all honest users when queried
will report the transaction as being stable.
We encapsulate the ledger in a functionality GLedger inspired
by the functionality of [26].
b) On the Supported Type of Ledgers.: For simplicity, we
present our results on a synchronous public transaction ledger
(e.g., Bitcoin [28] or Ethereum [29]) where there is a known
delay for the delivery of messages. We note however that
synchrony of the ledger is not a necessary assumption for our
protocol. In fact, any ledger satisfying the standard properties
of persistence and liveness as deﬁned in [27] can be employed
by our protocol. As it was shown in [27], Bitcoin satisﬁes both
properties for an honest majority of mining power under the
assumption of network synchrony. However, if one is willing
to trade off the honest majority assumption for a partially
synchronous network,1 we point out that partially synchronous
Byzantine Fault Tolerant (BFT) ledgers such as Algorand [33]
can also be employed by our protocol due to how we deﬁne
the corruption model, where the adversary “waits” for a full
refresh before changing corruptions.
Without loss of generality we assume that every transaction
that is included in the chain becomes ﬁnal and will not be
rolled-back. For a more detailed discussion we refer the reader
to [34]. As our protocols’ use of GLedger is straightforward
(simply submitting and reading transactions) we defer a formal
deﬁnition of GLedger to the full version of this paper.
Global Functionality: The simulator for our protocol
will not be able to act on behalf of GLedger. In particular the
simulator is only able to use the functionality with the same
priviliges as a party running the real protocol.
B. Miscellaneous
We use (G, G, q) to denote a curve group; the curve G is
generated by G and is of order q. Throughout the paper we
use additive notation for curve group operations.
a) Lagrange Coefﬁcients: λj
j(x) are the Lagrange
coefﬁcients for interpolating the value of a degree-1 polyno-
mial f at location x using the evaluation of f at points i and
j. In particular,
i (x), λi
i (x) · f (i) + λi
λj
j(x) · f (j) = f (x)
∀x, i, j ∈ Zq
1It is a well known fact that it is impossible to achieve consensus on
partially synchronous networks under honest majority [30].
i (x) is easy to compute once i, j, x are speciﬁed.
Each λj