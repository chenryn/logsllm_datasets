title:Malton: Towards On-Device Non-Invasive Mobile Malware Analysis for
ART
author:Lei Xue and
Yajin Zhou and
Ting Chen and
Xiapu Luo and
Guofei Gu
Malton: Towards On-Device Non-Invasive Mobile 
Malware Analysis for ART
Lei Xue, The Hong Kong Polytechnic University; Yajin Zhou, unaffiliated;  
Ting Chen, University of Electronic Science and Technology of China; 
Xiapu Luo, The Hong Kong Polytechnic University; Guofei Gu, Texas A&M University
https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/xue
This paper is included in the Proceedings of the 26th USENIX Security SymposiumAugust 16–18, 2017 • Vancouver, BC, CanadaISBN 978-1-931971-40-9Open access to the Proceedings of the 26th USENIX Security Symposium is sponsored by USENIXMalton: Towards On-Device Non-Invasive Mobile Malware Analysis for ART
Lei Xue†, Yajin Zhou(cid:2), Ting Chen†‡, Xiapu Luo†∗, Guofei Gu§
†Department of Computing, The Hong Kong Polytechnic University
(cid:2)Unafﬁliated
‡Cybersecurity Research Center, University of Electronic Science and Technology of China
§Department of Computer Science & Engineering, Texas A&M University
Abstract
It’s an essential step to understand malware’s behaviors
for developing effective solutions. Though a number of
systems have been proposed to analyze Android mal-
ware, they have been limited by incomplete view of in-
spection on a single layer. What’s worse, various new
techniques (e.g., packing, anti-emulator, etc.) employed
by the latest malware samples further make these system-
s ineffective. In this paper, we propose Malton, a nov-
el on-device non-invasive analysis platform for the new
Android runtime (i.e., the ART runtime). As a dynam-
ic analysis tool, Malton runs on real mobile devices and
provides a comprehensive view of malware’s behaviors
by conducting multi-layer monitoring and information
ﬂow tracking, as well as efﬁcient path exploration. We
have carefully evaluated Malton using real-world mal-
ware samples. The experimental results showed that
Malton is more effective than existing tools, with the ca-
pability to analyze sophisticated malware samples and
provide a comprehensive view of malicious behaviors of
these samples.
1
Introduction
To propose effective solutions, it is essential for malware
analysts to fully understand malicious behaviors of An-
droid malware. Though many systems have been pro-
posed, malware authors have quickly adopted advanced
techniques to evade the analysis. For instance, since
the majority of static analysis tools inspect the Dalvik
bytecode [2], malware circumvent them by using vari-
ous obfuscation techniques to raise the bar of code com-
prehension [61], implementing malicious activities in na-
tive libraries to evade the inspection [13, 59, 70, 92], and
leveraging packing techniques to hide malicious pay-
loads [82,85,88]. For example, the percentage of packed
∗The corresponding author.
Android malware has increased from 10% to 25% [36],
and 37.0% of the Android apps execute native code [11].
These sophisticated techniques employed by the latest
malware also make the dynamic analysis systems inef-
fective. First, malicious behaviors usually cross sever-
al system layers (e.g., the Android runtime, the Android
framework, and native libraries, etc.). However, the ma-
jority of dynamic analysis systems [34, 46, 73, 91] lack
of the capability of cross-layer inspection, and thus pro-
vide incomplete view of malicious behaviors. For exam-
ple, CopperDroid [73] monitors malware behaviors main-
ly through the trace of system calls (e.g., sys sendto()
and sys write()). Thus, it is hard to expose the execution
details in the Android framework layer and the runtime
layer, due to the well-known semantic gap challenge.
Second, the anti-debug and anti-emulator techniques em-
ployed by malware [44, 47, 56, 74] as well as the new
Android runtime (i.e., the ART runtime) further limit the
usage of many dynamic analysis systems. For example,
in [14], 98.6% malware samples were successfully ana-
lyzed on the real smartphone, whereas only 76.84% mal-
ware samples were successfully inspected using the em-
ulator. Most of the existing tools either rely on emulators
(e.g., DroidScope [83]) or modify the old Android run-
time (i.e., Dalvik Virtual Machine, or DVM for short) to
monitor malware behaviors (e.g., TaintDroid [38]). Third,
it is a common practice that malware executes differen-
t payloads according to the commands from the remote
command and control (i.e., C&C) servers. However, ex-
isting systems are not effective in capturing the execu-
tion of all malicious payloads, because they are impaired
by the inherent limitation of dynamic analysis (i.e., low
code coverage) and the lack of efﬁcient code path explo-
ration technique.
In this paper, we propose Malton, a novel on-device
non-invasive analysis platform for the ART runtime.
Compared with other systems, Malton employs two im-
portant capabilities, namely, a) multi-layer monitoring
and information ﬂow tracking, and b) efﬁcient path ex-
USENIX Association
26th USENIX Security Symposium    289
ploration, to provide a comprehensive view of malware
behaviors. Moreover, Malton does not need to modify
malware’s bytecode for conducting static instrumenta-
tion. To our best knowledge, Malton is the ﬁrst system
with such capabilities. Table 7 in Section 6 illustrates the
key differences between Malton and other systems.
Malton inspects Android malware on different layer-
s.
It records the invocations of Java methods, includ-
ing sensitive framework APIs and the concerned meth-
ods of the malware, in the framework layer, and captures
stealthy behaviors, such as dynamic code loading and JNI
reﬂection, in the runtime layer. Moreover, it monitors
library APIs and system calls in the system layer, and
propagates taint tags and explores different code paths
in the instruction layer. However, multi-layer monitor-
ing is not enough to provide a comprehensive view of
malware behaviors, because malicious payloads could be
conditionally executed. We deal with this challenge with
the capability to efﬁciently explore code paths. First, to
trigger as many malicious payloads as possible, we pro-
pose a multi-path exploration engine based on the con-
colic execution [27] to generate concrete inputs for ex-
ploring different code paths. Second, to conduct efﬁcient
path exploration on mobile devices with limited compu-
tational resources, we propose an ofﬂoading mechanism
to move heavy-weight tasks (e.g., solving constraints) to
resourceful desktop computers, and an in-memory opti-
mization mechanism that makes the execution ﬂow re-
turn to the entry point of the interested code region im-
mediately after exiting the code region. Third, in case the
constraint solver fails to ﬁnd a solution to explore a code
path, we equip Malton with a direction execution engine
to forcibly execute a speciﬁed code path. Since Malton
requires the necessary human annotations of the interest-
ed code regions, it is most useful in the human-guided
detailed exploration of Android malware.
We have implemented a prototype of Malton based on
the binary instrumentation framework Valgrind [53]. S-
ince both the app’s code and the framework APIs are
compiled into native code in the ART runtime, we lever-
age the instrumentation mechanism of Valgrind to intro-
spect apps and the Android framework. We evaluated
Malton with real-world malware samples. The experi-
mental results show that Malton can analyze sophisticat-
ed malware samples and provide a comprehensive view
of their malicious behaviors.
In summary, we make the following contributions.
• We propose a novel Android malware analysis system
with the capability to provide a comprehensive view
of malicious behaviors.
It has two major capabili-
ties, including multi-layer monitoring and information
ﬂow tracking, and efﬁcient path exploration.
• We implement the system named Malton by solv-
ing several technical challenges (e.g., cross-layer taint
propagation, on-device Java method tracking, execu-
tion path exploration, etc.). To the best of our knowl-
edge, it is the ﬁrst system having such capabilities.
To engage the whole community, we plan to release
Malton to the community.
• We carefully evaluate Malton with real-world mal-
ware samples. The results demonstrated the effective-
ness of Malton in analyzing sophisticated malware.
The rest of this paper is organized as follows. Sec-
tion 2 introduces background knowledge and describes a
motivating example. Section 3 details the system design
and implementation. Section 4 reports the evaluation re-
sults. Then, we discuss Malton’s limitations and possible
solutions in Section 5. After presenting the related work
in Section 6, we conclude the paper in Section 7.
2 Background
2.1 The ART Runtime
ART is the new runtime introduced in Android version
4.4, and becomes the default runtime from version 5.0.
When an app is being installed, its Dalvik bytecode in
the Dex ﬁle is compiled to native code1 by the dex2oat
tool, and a new ﬁle in the OAT format is generated includ-
ing both the Dalvik bytecode and native code. The OAT
format is a special ELF format with some extensions.
The OAT ﬁle has an oatdata section, which contains
the information of each class that has been compiled into
native code. The native code resides in a special sec-
tion with the offset indicated by the oatexec symbol.
Hence, we can ﬁnd the information of a Java class in the
oatdata section and its compiled native code through
the oatexec symbol.
When an app is launched, the ART runtime parses the
OAT ﬁle and loads the ﬁle into memory. For each Java
class object, the ART runtime has a corresponding in-
stance of the C++ class Object to represent it. The ﬁrst
member of this instance points to an instance of the C++
class Class, which contains the detailed information of
the Java class, including the ﬁelds, methods, etc. Each
Java method is represented by an instance of the C++
class ArtMethod, which contains the method’s address,
access permissions, the class to which this method be-
longs, etc. The C++ class ArtField is used to represent
a class ﬁeld, including the class to which this ﬁeld be-
longs, the index of this ﬁeld in its class, access rights, etc.
We can leverage the C++ Object, Class, ArtMethod
and ArtField to ﬁnd the detailed information of the Ja-
va class, methods and ﬁelds of the Java class.
1Native code denotes the native instructions that could directly run
with a particular processor.
290    26th USENIX Security Symposium
USENIX Association
Listing 1: A motivating example
if(cmd == 1) {
reply("Unknown command!");
}
return false;
Context.TELEPHONY_SERVICE);
} else if(cmd == 3) {
} else if(cmd == 4) {
rebootDevice();
// Reboot the device
} else if(cmd == 5) {
readSMS();
// Read SMS content
} else if(cmd == 2) {
TelephonyManager telephonyManager =
(TelephonyManager) getSystemService(
parseMSG(msg);
// Parse msg in native code
readContact();
// Read Contact content
readIMSI();
// Read device IMSI information
} else { // The command is unrconginized.
String imsi = telephonyManager.getSubscriberId();
// Send back data through SMTP protocol
smtpReply(imis);
1 public static native void readContact();
2 public static native void parseMSG(String msg);
3 private void readIMSI(){
4
5
6
7
8
9
10 }
11 private void procCMD(int cmd, String msg){
12
13
14
15
16
17
18
19
20
21
22
23
24
25 }
26 public boolean equals(String s1, String s2) {
27
28
29
30
31
32
33
34
35 }
36 public void onReceiver(Context context, Intent intent){
37
38
39
40
41
42
43
44
45 }
String body = smsMessage.getMessageBody();
// Get the telephone of the sender
String sender = smsMessage.getOriginatingAddress();
// Check if the SMS is sent form the controller
if(equals(sender, "6223**60")) {
if(s1.hashCode() != s2.hashCode())
if (s1.charAt(i) != s2.charAt(i))
procCMD(Interger.parseInt(body), body);
for(int i = 0; i < count; ++i)
return false;
return true;
if(s1.count != s2.count)
return false;
}
...
The Android framework is compiled into an OAT
ﬁle named “system@PI:EMAIL”. This ﬁle is
loaded to the ﬁxed memory range for all apps running on
the device without ASLR enabled [69].
2.2 Motivating Example
We use the example in Listing 1 to illustrate the usage of
Malton. In this example, the method onReceiver() is an
SMS listener and it is invoked when an SMS arrives. In
this method, the telephone number of the sender is ﬁrst
acquired (Line 39) for checking whether the SMS is sent
from the controller (Tel: 6223**60). Only the SMS from
the controller will be processed by the method procCMD()
(Line 42). There are 5 types of commands, each of which
leads to a special malicious behavior (i.e., Line 13, 15,
17, 19 and 21). Reading contact and parsing SMS are
implemented in the JNI methods readContact() (Line 1)
and parseMSG() (Line 2), respectively.
Existing malware analysis tools could not construct a
complete view of the malicious behaviors. For example,
when cmd equals 3 (Line 16), IMSI is obtained by in-
voking the framework API getSubscriberId() (Line 7), and
then leaked through SMTP protocol (Line 9). Although
existing tools (e.g., CopperDroid [73]) can ﬁnd that the
malware reads IMSI and leaks the information by sys-
tem call sys sendto(), they cannot locate the method used
to get IMSI and how the IMSI is leaked in detail, be-
cause sys sendto() can be called by many functions (e.g.,
JavaMail APIs, Java Socket methods and C/C++ Socket
methods) from both the framework layer and the native
layer. Malton can solve this problem because it performs
multi-layer monitoring.
When cmd equals 5, the content of SMS, which is
obtained from the framework layer (Line 37), will be
parsed in the JNI method parseMSG() (Line 2) by native
code. Although taint analysis could identify this infor-
mation ﬂow, existing static instrumentation based tools
(e.g., TaintART [71] and ARTist [21]) cannot track the in-
formation ﬂow in the native code. Malton can tackle this
issue since it offers cross-layer taint analysis.
Moreover,
as shown in the method procCMD()
(Line 11), the malware performs different activities ac-
cording to the parameter cmd. Due to the low code cov-
erage of dynamic analysis, how to efﬁciently explore all
the malicious behaviors with the corresponding inputs is
challenging. Malton approaches this challenge by con-
ducting concolic execution with in-memory optimization
and direct execution. Furthermore, we propose a new of-
ﬂoading mechanism to avoid overloading the mobile de-
vices with limited computational resources. Since some
constraints may not be solved (e.g., the hash functions at
Line 29), we develop a direct execution engine to cover
speciﬁed branches forcibly.
3 Design and Implementation
In this section, we ﬁrst illustrate the design of our ap-
proach, and then detail the implementation of Malton.
Framework API invocations
Runtime function invocations
Library function invocations