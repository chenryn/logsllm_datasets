Bounds Check Bypass. CoRR abs/1805.08506 (2018).
com/vcblog/2018/01/15/spectre-mitigations-in-msvc/.
[54] Vineet Rajani, Deepak Garg, and Tamara Rezk. 2016. On Access Control, Capa-
bilities, Their Equivalence, and Confused Deputy Attacks. In Proceedings of the
29th IEEE Computer Security Foundations Symposium (CSF). IEEE.
[55] Gabriel Scherer, Max New, Nick Rioux, and Amal Ahmed. 2018. Fabous Interop-
erability for ML and a Linear Language. In FOSSACS ’18. 146–162.
[56] Daniel Schoepe, Musard Balliu, Benjamin Pierce, and Andrei Sabelfeld. 2016.
Explicit Secrecy: A Policy for Taint Tracking. In Proceedings of the 1st IEEE
European Symposium on Security and Privacy (EuroS&P). IEEE.
[57] Michael Schwarz, Martin Schwarzl, Moritz Lipp, Jon Masters, and Daniel Gruss.
2019. Netspectre: Read arbitrary memory over network. In Proceedings of the
24th European Symposium on Research in Computer Security (ESORICS). Springer.
[58] Lau Skorstengaard, Dominique Devriese, and Lars Birkedal. 2020. Reasoning
about a Machine with Local Capabilities: Provably Safe Stack and Return Pointer
Management. ACM Transactions on Programming Languages and Systems 42, 1
(2020).
[59] Julian Stecklina and Thomas Prescher. 2018. LazyFP: Leaking FPU Register State
using Microarchitectural Side-Channels. CoRR abs/1806.07480 (2018).
[60] David Swasey, Deepak Garg, and Derek Dreyer. 2017. Robust and Compositional
Verification of Object Capability Patterns. Proceedings of the ACM on Programming
Languages 1, OOPSLA (2017).
[61] Tachio Terauchi and Alex Aiken. 2005. Secure Information Flow as a Safety
Problem. In Proceedings of the 12th International Symposium on Static Analysis
(SAS). Springer.
[62] Caroline Trippel, Daniel Lustig, and Margaret Martonosi. 2018. MeltdownPrime
and SpectrePrime: Automatically-Synthesized Attacks Exploiting Invalidation-
Based Coherence Protocols. CoRR abs/1802.03802 (2018).
[63] Stephan van Schaik, Alyssa Milburn, Sebastian Österlund, Pietro Frigo, Giorgi
Maisuradze, Kaveh Razavi, Herbert Bos, and Cristiano Giuffrida. 2019. RIDL:
Rogue In-flight Data Load. In Proceedings of the 40th IEEE Symposium on Security
and Privacy (S&P ’19). IEEE.
[64] Marco Vassena, Craig Disselkoen, Klaus von Gleissenthall, Sunjay Cauligi,
Rami Gökhan Kıcı, Ranjit Jhala, Dean Tullsen, and Deian Stefan. 2021. Au-
tomatically Eliminating Speculative Leaks from Cryptographic Code with Blade.
Proceedings of the ACM on Programming Languages 5, POPL (2021).
[65] Guanhua Wang, Sudipta Chattopadhyay, Ivan Gotovchits, Tulika Mitra, and
Abhik Roychoudhury. 2018. oo7: Low-overhead Defense against Spectre Attacks
via Binary Analysis. CoRR abs/1807.05843 (2018).
Session 2B: Formal Analysis and Verification CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea459A TAINT TRACKING OVERVIEW
The language semantics we devise contains two kinds of semantics
that operate in parallel: the operational semantics, presented in
the paper, and the taint tracking semantics, presented here. Thus,
technically, the top-level semantics is parametric in the taint track-
ing semantics. The semantics of strong languages L and T uses the
strong form of taint tracking while the semantics of weak languages
L- and T- uses the weak form of taint tracking. We now give an
in-depth overview of our taint-tracking semantics; see [52] for the
full models.
To add taint-tracking to our semantics, we enrich the program
state with taint information and devise a taint-tracking semantics
that determines how taint is propagated. The top-level semantic
judgement is then expressed in terms of the extended program
states. An extended state steps if its operational part steps according
to the semantics of Section 2.4 and if its taint part steps according
to the rules of the taint semantics.
We now define all the elements needed to define the extended
program states: extended heaps and extended bindings. In this
appendix, we indicate the heap, state, and bindings used by the
operational semantics with a v suffix, so the H, Ω and B from
Section 2.4 are denoted as Hv, Ωv and Bv respectively. Formally, we
indicate taint as σ ::= S | U . Extended heaps He extend heaps with
the taint of each location, whereas taint heaps Ht only track the
taint. Extended heaps He can be split/merged in their value-only
part Hv (used for the language semantics) and their taint-only part
Ht (used for taint-tracking). We denote this split as He ≡ Hv + Ht.
Just like heaps, extended variable bindings Be extend the binding
with the taint of the variable, whereas taint bindings Bt only track
the taint. Still like heaps, bindings can be split/merged as Be ≡
Bv + Bt.
Extended Heaps He ::= ∅ | He; n (cid:55)→ v : σ where n ∈ Z
Taint Heaps Ht ::= ∅ | Ht; n (cid:55)→ σ where n ∈ Z
Extended Bindings Be ::= ∅ | Be; x (cid:55)→ v : σ
Taint Bindings Bt ::= ∅ | Bt; x (cid:55)→ σ
Exended Prog. States Ωe ::= C, He, Be ▷ (s)f
Taint States Ωt ::= C, Ht, Bv ▷ (s)f
t
The taint semantics follows two judgements:
• Judgment Bt ▷ e ↓ σ reads as “expression e is tainted as σ
according to the variable taints Bt ”.
σ′−−−→ Ω′
• Judgement σ; Ωt
σ, state Ωt single-steps to Ω′
action with taint σ ′”.
reads as “when the pc has taint
producing a (possibly empty)
Below are the most representative rules for the taint tracking used
by strong languages:
Be ▷ e ↓ n : σ
σpc; C, Ht, Be · Be ▷ e :=pr e′
B ▷ e ↓ n : σ′
na = −|n|
t = Ht ∪ −|n| (cid:55)→ σ′′
H′
t , Be · Be ▷ skip
σ = σ′′ ⊓ σ′
σ ⊔ σpc
−−−−−−−−→ C, H′
Ht (na ) = σ′′
Be ▷ e′ ↓ _ : σ′′
(T-write-prv)
(T-read-prv)
t
σpc; C, Ht, Be · Be ▷ let x = rdpr e in s
σ ⊔ σpc
−−−−−−−−→
C, Ht, Be · Be ∪ x (cid:55)→ 0 : U ▷ s
Writing to the private heap (Rule T-write-prv) taints the location
(−|n|) with the taint of the written expression (σ ′′). In contrast,
reading from the private heap (Rule T-read-prv) taints the variable
where the content is stored as unsafe (U) and the read value is set
to 0 (this information is not used by the taint-tracking).
For taint-tracking of the weak languages, we replace Rule T-read-
prv with the one below that taints the read variable with the glb of
the taints of the pc and of the read value (σ ′ ⊔ σpc) instead of U.
B ▷ e ↓ n : σ′
na = −|n|
(T-read-prv-weak)
Ht (na ) = σ′′
σ = σ′′ ⊓ σ′
σpc; C, Ht, B · B ▷ let x = rdpr e in s
σ ⊔ σpc
−−−−−−−−→
C, Ht, B · B ∪ x (cid:55)→ 0 : σ′ ⊔ σpc ▷ s
To correctly taint memory accesses, we need to evaluate ex-
pression e to derive the accessed location |n|; see, for instance,
Rule T-write-prv. This is why taint-tracking states Ωt contain the
full stack of bindings Bv and not just the taints Bt. The rules above
rely on a judgement Be ▷ e ↓ n : σ which is obtained by joining
the result of the expression semantics on the values of Be and of
the taint-tracking semantics on the taints of Be.
Bv + Bt ≡ Be
(Combine-B)
Bv ▷ e ↓ v
Be ▷ e ↓ v : σ
Bt ▷ e ↓ σ
The operational and taint single-steps from Section 2.4 are com-
bined according to the judgement Ωe
λσ−−−−→ Ω′
e below.
Ωv + Ωt ≡ Ωe
Ω′
v + Ω′
λ−−→ Ω′
v
S; Ωt
σ−−−→ Ω′
t
(Combine-s-L)
e
t ≡ Ω′
Ωv
λσ−−−−→ Ω′
Ωe
v + Bt ≡ Be
B′
(Merge-Ω)
e
Hv + Ht ≡ He
C; Hv; Bv ▷ s + C; Ht; Be ▷ s′ ≡ C; He; B′
Bv + Bt ≡ B′
e ▷ s
e
t
σ−−−→ Ω′
λ−−→ Ω′
The operational semantics determines how states reduce (Ωv
v),
whereas the taint-tracking semantics determines the action’s la-
bel and how taints are updated (S; Ωt
). As already men-
tioned, the pc taint is always safe since there is no speculation in
L. Moreover, merging states Ωv + Ωt results in ignoring the value
information accumulated in Ωt since we rely on the computation
performed by the operational semantics for values (Rule Merge-Ω).
In the speculative semantics, as for the non-speculative one, we
decouple the operational aspects from the taint-tracking ones. At
the top level, speculative program states (Σe) are defined as stacks
of extended speculation instances (Φe), which can be merged/split
in their operational (Φv) and taint (Φt) sub-parts. The operational
part (Φv) was presented in Section 2. The taint part (Φt) keeps track
of the taint part of the program state (Ωt) and the taint of the pc
(σ). As before, Φv and Φt can be split/merged as Φe ≡ Φv + Φt.
Speculative States Σe ::= Φe
Extended Speculation Instance Φe ::= (Ωe, w, σ )
Speculation Instance Taint Φt ::= (Ωt, σ )
In the taint tracking used by the speculative semantics, similarly
to the operational one, reductions happen at the top of the stack:
Φt σ Φ′
. Selected rules are below:
t
Session 2B: Formal Analysis and Verification CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea460(T-T-speculate-action)
Ωt ≡ C, Ht, B ▷ s; s′
σ′; Ωt
s (cid:46) ifz _ then _ else _ and s (cid:46) lfence
σ−−−→ Ω′
t
Φt · (Ωt, σ ) σ′ ⊓ σ Φt · (Ω′
t, σ )
Ωt ≡ C, Ht, B · B ▷ (s; s′)f·f
(T-T-speculate-if)
s ≡ ifz e then s′′ else s′′′
σ−−−→ Ω′
t
σ′; Ωt
if B ▷ e ↓ 0 : σ then Ω′′
C ≡ F; I
f (cid:60) I
t ≡ C, Ht, B · B ▷ s′′′; s′
if B ▷ e ↓ n : σ and n > 0 then Ω′′
Φt · (Ω′
t ≡ C, Ht, B · B ▷ s′′; s′
t, σ′) · (Ω′′
Φt · (Ωt, σ′) σ ⊓ σ′
t , U)
In these rules, σ is the program counter taint which is com-
bined with the action taint σ′ (Rules T-T-speculate-action and T-
T-speculate-if). Mis-speculation pushes a new state on top of the
stack whose program counter is tainted U denoting the beginning
of speculation (Rule T-T-speculate-if).
The two operational and taint-tracking single steps from Sec-
tion 2.6 are combined in a single reduction as follows:
Φv + Φt ≡ Σe
Φ′
v + Φ′
(Combine-T)
t ≡ Σ′
Σe λσ
e
Σ′
e
Φv λ Φ′
v
Φt σ Φ′
t
====⇒ Σ′
This reduction is used by the big-step semantics Σe
e that
concatenates single labels into traces, which, as before, do not
contain microarchitectural actions generated by the attacker.
λσ
Session 2B: Formal Analysis and Verification CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea461