> 
> 
> 
就像在函数 `SetGpio` 中所做的第一件事情是检查给定的针脚号是否有效一样。我们需要同样的方式去将 `pinNum`（`r0`）与 53 进行比较，如果它大于 53 将立即返回。一旦我们想要再次调用 `GetGpioAddress`，我们就需要将 `lr` 推送到栈上来保护它，将 `pinNum` 移动到 `r2` 中。然后我们使用 `.unreq` 语句来删除我们给 `r0` 定义的别名。因为针脚号现在保存在寄存器 `r2` 中，我们希望别名能够反映这个变化，因此我们从 `r0` 移走别名，重新定义到 `r2`。你应该每次在别名使用结束后，立即删除它，这样当它不再存在时，你就不会在后面的代码中因它而产生错误。
然后，我们调用了 `GetGpioAddress`，并且我们创建了一个指向 `r0`的别名以反映此变化。
将下面的代码复制粘贴到上述代码的后面位置。
```
pinBank .req r3
lsr pinBank,pinNum,#5a
lsl pinBank,#2
add gpioAddr,pinBank
.unreq pinBank
```
> 
> `lsr dst,src,#val` 将 `src` 中二进制表示的数右移 `val` 位，并将结果保存到 `dst`。
> 
> 
> 
对于打开和关闭 GPIO 针脚，每个针脚在 GPIO 控制器上有两个 4 字节组。第一个 4 字节组每个位控制前 32 个针脚，而第二个 4 字节组控制剩下的 22 个针脚。为了判断我们要设置的针脚在哪个 4 字节组中，我们需要将针脚号除以 32。幸运的是，这很容易，因为它等价于将二进制表示的针脚号右移 5 位。因此，在本案例中，我们将 `r3` 命名为 `pinBank`，然后计算 `pinNum` ÷ 32。因为它是一个 4 字节组，我们需要将它与 4 相乘的结果。它与二进制表示的数左移 2 位相同，这就是下一行的命令。你可能想知道我们能否只将它右移 3 位呢，这样我们就不用先右移再左移。但是这样做是不行的，因为当我们做 ÷ 32 时答案有些位可能被舍弃，而如果我们做 ÷ 8 时却不会这样。
现在，`gpioAddr` 的结果有可能是 20200000 16（如果针脚号介于 0 到 31 之间），也有可能是 20200004 16（如果针脚号介于 32 到 53 之间）。这意味着如果加上 28 10，我们将得到打开针脚的地址，而如果加上 40 10 ，我们将得到关闭针脚的地址。由于我们用完了 `pinBank` ，所以在它之后立即使用 `.unreq` 去删除它。
将下面的代码复制粘贴到上述代码的下面位置。
```
and pinNum,#31
setBit .req r3
mov setBit,#1
lsl setBit,pinNum
.unreq pinNum
```
> 
> `and reg,#val` 计算寄存器 `reg` 中的数与 `val` 的布尔与。
> 
> 
> 
该函数的下一个部分是产生一个正确的位集合的数。至于 GPIO 控制器去打开或关闭针脚，我们在针脚号除以 32 的余数里设置了位的数。例如，设置 16 号针脚，我们需要第 16 位设置数字为 1 。设置 45 号针脚，我们需要设置第 13 位数字为 1，因为 45 ÷ 32 = 1 余数 13。
这个 `and` 命令计算我们需要的余数。它是这样计算的，在两个输入中所有的二进制位都是 1 时，这个 `and` 运算的结果就是 1，否则就是 0。这是一个很基础的二进制操作，`and` 操作非常快。我们给定的输入是 “pinNum and 31 10 = 11111 2”。这意味着答案的后 5 位中只有 1，因此它肯定是在 0 到 31 之间。尤其是在 `pinNum` 的后 5 位的位置是 1 的地方它只有 1。这就如同被 32 整除的余数部分。就像 31 = 32 - 1 并不是巧合。
![binary division example](/data/attachment/album/201902/08/230000ps9989cmnb8lrs0y.png)
代码的其余部分使用这个值去左移 1 位。这就有了创建我们所需要的二进制数的效果。
将下面的代码复制粘贴到上述代码的下面位置。
```
teq pinVal,#0
.unreq pinVal
streq setBit,[gpioAddr,#40]
strne setBit,[gpioAddr,#28]
.unreq setBit
.unreq gpioAddr
pop {pc}
```
> 
> `teq reg,#val` 检查寄存器 `reg` 中的数字与 `val` 是否相等。
> 
> 
> 
这个代码结束了该方法。如前面所说，当 `pinVal` 为 0 时，我们关闭它，否则就打开它。`teq`（等于测试）是另一个比较操作，它仅能够测试是否相等。它类似于 `cmp` ，但它并不能算出哪个数大。如果你只是希望测试数字是否相同，你可以使用 `teq`。
如果 `pinVal` 是 0，我们将 `setBit` 保存在 GPIO 地址偏移 40 的位置，我们已经知道，这样会关闭那个针脚。否则将它保存在 GPIO 地址偏移 28 的位置，它将打开那个针脚。最后，我们通过弹出 `pc` 返回，这将设置它为我们推送链接寄存器时保存的值。
### 5、一个新的开始
在完成上述工作后，我们终于有了我们的 GPIO 函数。现在，我们需要去修改 `main.s` 去使用它们。因为 `main.s` 现在已经有点大了，也更复杂了。将它分成两节将是一个很好的设计。到目前为止，我们一直使用的 `.init` 应该尽可能的让它保持小。我们可以更改代码来很容易地反映出这一点。
将下列的代码插入到 `main.s` 文件中 `_start:` 的后面：
```
b main
.section .text
main:
mov sp,#0x8000
```
在这里重要的改变是引入了 `.text` 节。我设计了 `makefile` 和链接器脚本，它将 `.text` 节（它是默认节）中的代码放在地址为 8000 16 的 `.init` 节之后。这是默认加载地址，并且它给我们提供了一些空间去保存栈。由于栈存在于内存中，它也有一个地址。栈向下增长内存，因此每个新值都低于前一个地址，所以，这使得栈顶是最低的一个地址。
![Layout diagram of operating system](/data/attachment/album/201902/08/230000r540p85w8jz5hmmj.png)
> 
> 图中的 “ATAGs” 节的位置保存了有关树莓派的信息，比如它有多少内存，默认屏幕分辨率是多少。
> 
> 
> 
用下面的代码替换掉所有设置 GPIO 函数针脚的代码：
```
pinNum .req r0
pinFunc .req r1
mov pinNum,#16
mov pinFunc,#1
bl SetGpioFunction
.unreq pinNum
.unreq pinFunc
```
这个代码将使用针脚号 16 和函数编号 1 去调用 `SetGpioFunction`。它的效果就是启用了 OK LED 灯的输出。
用下面的代码去替换打开 OK LED 灯的代码：
```
pinNum .req r0
pinVal .req r1
mov pinNum,#16
mov pinVal,#0
bl SetGpio
.unreq pinNum
.unreq pinVal
```
这个代码使用 `SetGpio` 去关闭 GPIO 第 16 号针脚，因此将打开 OK LED。如果我们（将第 4 行）替换成 `mov pinVal,#1` 它将关闭 LED 灯。用以上的代码去替换掉你关闭 LED 灯的旧代码。
### 6、继续向目标前进
但愿你能够顺利地在你的树莓派上测试我们所做的这一切。到目前为止，我们已经写了一大段代码，因此不可避免会出现错误。如果有错误，可以去查看我们的排错页面。
如果你的代码已经正常工作，恭喜你。虽然我们的操作系统除了做 [课程 2：OK02](/article-10478-1.html) 中的事情，还做不了别的任何事情，但我们已经学会了函数和格式有关的知识，并且我们现在可以更好更快地编写新特性了。现在，我们在操作系统上修改 GPIO 寄存器将变得非常简单，而它就是用于控制硬件的！
在 [课程 4：OK04](https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/ok04.html) 中，我们将处理我们的 `wait` 函数，目前，它的时间控制还不精确，这样我们就可以更好地控制我们的 LED 灯了，进而最终控制所有的 GPIO 针脚。
---
via: 
作者：[Robert Mullins](http://www.cl.cam.ac.uk/%7Erdm34) 选题：[lujun9972](https://github.com/lujun9972) 译者：[qhwdw](https://github.com/qhwdw) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出