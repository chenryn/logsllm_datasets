Libgcrypt (version 1.6.1), our study shows that they have
been ﬁxed in version 1.7.3. Without secret-dependent
memory accesses,
implementation of
Libgcrypt 1.7.3 is generally accepted as safe regarding our
threat model. Our evaluation reports consistent ﬁndings
that no leak is detected regarding our threat model on
secret-dependent cache-line accesses (but we do ﬁnd secret-
dependent control ﬂows, see Sec. 8.5).
Computing Resource. Our evaluation is launched on a ma-
chine with 2.90 GHz Intel Xeon(R) E5-2690 CPU and 128
GB memory. For each context-sensitive analysis campaign,
Table 2 presents the covered functions, contexts, and pro-
cessed IR instructions. We report that CacheS takes less than
1700 CPU seconds to process all the test cases, and on av-
erage the peak memory usage to evaluate one case is less
than 5 GB. Overall, CacheS ﬁnished all the analysis cam-
paigns with reasonable amount of computing resources, and
we interpret that the promising results demonstrate the high
scalability of CacheS in analyzing real-world cryptosystems.
Modeling Program Semantics with Logic Formulas. As
noted in Sec. 3, we tentatively implement the idea of mod-
eling program concrete semantics with logic formulas. Note
that in addition to the semantics modeling, all the design and
evaluation settings are unchanged.
USENIX Association
28th USENIX Security Symposium    665
Table 2: Evaluation result overview. We compare the identiﬁed information leakage sites by CacheS with a recent research
(CacheD [77]), and we report CacheS can identify all the leakage sites reported by CacheD. A summary of all leaks can be
found at the extended version of this paper [76].
Sites (known/unknown) Procedures
Contexts
(CPU Seconds) REIL Instructions Usage (MB) Leakage Units Leakage Sites Processing Time Leakage Units
# of Analyzed # of Analyzed Processing Time
# of Processed
Peak Memory
Information
Results Reported in CacheD [77]
Algorithm Implementation Information Leakage
RSA/ElGamal Libgcrypt 1.6.1
RSA/ElGamal Libgcrypt 1.7.3
RSA/ElGamal OpenSSL 1.0.2k
RSA/ElGamal OpenSSL 1.0.2f
mbedTLS 2.5.1
OpenSSL 1.0.2k
OpenSSL 1.0.2f
mbedTLS 2.5.1
22/18
0/0
2/3
2/4
0/29
32/0
32/0
64/0
154/54
RSA
AES
AES
AES
Total
60
59
71
68
29
1
1
1
290
81
59
81
72
36
1
1
1
332
228.8
182.2
179.2
169.5
775.9
33.2
35.8
32.8
1,637.4
50,436
33,386
83,183
80,096
35,963
3,748
3,748
4,803
295,363
7,749
5,823
6,134
6,113
9,654
620
578
619
37,290
11
0
2
3
2
1
1
1
21
22
0
N/A
2
N/A
N/A
32
N/A
56
14293.6
11626.0
N/A
165.6
N/A
N/A
48.5
N/A
26,133.7
5
0
2
1
8
N/A
N/A
N/A
N/A
Table 3: Model program semantics in the logic formulas l ∈
L and SAS and test OpenSSL 1.0.2k. The second and third
rows report the modeling results with logic formulas, while
the last row reports results in SAS. The comparison of these
two program modelings is given in Sec. 3.
Algorithm
Execution Time
(CPU Second)
RSA/ElGamal timeout (> 5 CPU hours)
timeout (> 5 CPU hours)
RSA/ElGamal timeout (> 5 CPU hours)
AES
RSA/ElGamal
AES
AES
115.8
179.2
33.2
Context
Function
Usage (MB)
# of Processed # of Processed Peak Memory Detected
Leaks
N/A
N/A
N/A
32
5
32
7,283
47,798
53,054
621
6,134
620
15
1
28
1
71
1
28
1
85
1
81
1
The ﬁrst two rows of Table 3 give the evaluation results for
the AES and RSA/ElGamal implementations in OpenSSL
1.0.2k, both of which report a “timeout” after 5 CPU hours.
As explained in Sec. 3, we extend the prototype with loop
induction variable detection, and the third row reports the re-
sults of the re-launched tests. Still, the RSA/ElGamal case
throws a timeout (a reﬂection on this tentative evaluation is
given in Sec. 3). In summary, we interpret that the SAS pro-
posed in this research has largely improved the analysis scal-
ability, which serves as an indispensable component to pin-
point cache-based timing channels in real-world cryptosys-
tems.
Comparison with CacheAudit.2 Besides CacheD [77], we
also compare our results with CacheAudit [32]. CacheAudit
failed on all of our test cases for two reasons. First, two of
our cases contain some x86 instructions that are not handled
by CacheAudit. Second, CacheAudit refuses to analyze indi-
rect function calls when constructing the control ﬂow graph.
In addition, we also describe the key differences between
CacheS and CacheAudit in Sec. 10.
Identifying Information Leakage Units. Considering some
occurrences of information leaks are on adjacent lines of a
code component (a summary of all leaks can be found at the
extended version of this paper [76]), once a leak is ﬂagged by
CacheS, presumably any competent programmer shall spot
and remove all the related defects. Therefore, we group the
ﬂagged information leaks to assess the utility of CacheS and
also estimate the bug ﬁxing effort. Though it can be slightly
subjective, we propose a metric according to the source code
locations of defects: information leaks will be grouped to-
2https://github.com/cacheaudit/cacheaudit
gether as a “leakage unit” if they are within the same or ad-
jacent C statements (e.g., within the same loop or adjacent if
branches). Also, if a macro is expanded at different program
points (e.g., the macro MPN COPY which contains informa-
tion leaks in Libgcrypt 1.6.1), we count it only once.
As reported in Table 2, CacheS identiﬁed 21 units of infor-
mation leaks. We also grouped the ﬁndings of CacheD with
the same metric. We have conﬁrmed that CacheS covered all
leakage units reported in CacheD, and further revealed new
leakage units within statements or functions not covered by
CacheD (e.g., 6 new leakage units in Libgcrypt 1.6.1). Over-
all, we interpret the evaluation results as promising; trace-
based analysis, like CacheD, is incapable of modeling the
program collecting semantics, and therefore underestimates
the attack surface.
Conﬁrmation with Library Authors. As shown in Ta-
ble 2, we found unknown information leaks from OpenSSL
(versions 1.0.2f and 1.0.2k) and mbedTLS (version 2.5.1).
Our ﬁndings were reported and promptly conﬁrmed by the
OpenSSL developers [4];
the latest OpenSSL has been
patched to eliminate these leaks (the leaks are discussed
shortly in Sec. 8.4). At the time of writing, we are waiting
for responses from the mbedTLS developers.
8.2 Exploring the Leaks in mbedTLS
Although mbedTLS developers have not conﬁrmed our ﬁnd-
ings, we conduct further study of the 29 ﬂagged information
leakage sites from this library to check whether they can lead
to cache-based side channels.
As mentioned above, the constraint solver provides at least
one pair of satisﬁable solutions (a pair of secrets k and k(cid:48)) to
each leakage site (Sec. 5). To verify one leak, we instrument
the program source code and modify secrets with k and k(cid:48).
We then compile the instrumented programs into two bina-
ries and monitor the execution of each binary executable via
a widely-used hardware simulator (gem5 [18]). The com-
piled code is fed with test cases shipped with the cryptosys-
tems, and we use the full-system simulation mode of gem5
to monitor the execution of the instrumented program. The
full-system simulation mode uses 64-bit Ubuntu 12.04 (this
mode only supports 64-bit OS) to host the application code.
We compile the instrumented source code into 64-bit bina-
ries since executing 32-bit binaries on the 64-bit OS throws
some TLB translation exceptions (this issue is also reported
in [77]). The conﬁguration of gem5 is reported in Table 4. At
666    28th USENIX Security Symposium
USENIX Association
Table 4: gem5 conﬁgurations.
ISA
Processor type
L1 Cache
L2 Cache
Cache line size
Cache replacement policy
x86
single core, out-of-order
4-way, 32KB, 2-cycle latency
8-way, 1MB, 50-cycle latency
64 Bytes
LRU
Table 5: Hardware simulation results.
# of CacheS Detected
Leakage Sites
29
# of Executed
Leakage Sites Access Variants
Cache Line
14
14
Cache Status
Variants
6
the leakage point, we intercept the cache access from CPU
to L1 Data Cache; the accessed cache line and corresponding
cache status (hit vs. miss) are recorded.
As shown in Table 5, among 29 information leakage sites
found in mbedTLS, 14 sites are covered during simulation.
We observe that different cache lines are accessed at these
leakage points, when instrumenting the program with secrets
k and k(cid:48). In other words, by observing the access of different
cache lines, attackers will be able to infer a certain amount
of secret information. In addition, we report that cache status
variants (in terms of cache hit vs. miss) are observed in sev-
eral cases. In summary, we interpret the veriﬁcation results
as highly promising; we have conﬁrmed that all the executed
information leakages are true positives since cache line ac-
cess variants are observed.
Although the employed program inputs cannot lead to the
full coverage of every leakage site, we manually checked all
the uncovered cases, and we found that these cases share the
same pattern as the covered leaks. For instance, the cov-
ered and uncovered leaks are the same inline assembly se-
quences residing within different paths. Overall, we interpret
it as convincing to conclude that all the detected information
leaks in mbedTLS are true positives.
8.3 Case Study of Leaks in mbedTLS
This section presents a thorough case study of several infor-
mation leaks identiﬁed by our tool. As presented in Table 2,
we identiﬁed 29 information leakage points in mbedTLS
2.5.1.
In particular, the ﬁrst four leaks were found in the
function mpi montmul (source code is given in Fig. 6(a)),
which is a major component of the modular exponentiation
implementation in mbedTLS. The value of function parame-
ter B is derived from a window size of the secret key (line 2).
In mpi montmul, B is used as a pointer to access elements
in a C struct (line 6, line 10, line 11). We envision that dif-
ferent program secrets would derive into different values of
B, which further lead to the access of different cache lines in
secret-dependent memory accesses.