support the following higher-order controls for tuning the
whitelist. Ads are text-only by default; to enable images,
the enable-images permission can be set to allow,
thus expressing a publishers content restrictions policy on
the use of third-party images. Another content restric-
tions permission is the enable-flash permission, that
allows Flash ads to be displayed. Since our framework
doesn’t address security threats from opaque content such
as Flash (§2.1), a publisher must exercise severe caution
in enabling this permission. Also  elements
can be allowed via enable-iframe. However, allowing
 elements can facilitate attacks such as click-
jacking [17] and drive-by downloads [36].
The max-height, max-width and overflow permis-
sions control how the ad appears on the page. If an el-
ement’s size surpasses the max-width or max-height
dimension and the overflow permission is set to deny,
then excess content is hidden. Otherwise the excess con-
tent will overlap other parts of the page. The overﬂow per-
mission is useful because some ads consume a small area
when not in use, but may overlap non-ad content when
engaged by the user (e.g., expanding menus). Publish-
ers may wish to disallow expanding ads because they can
overlap trusted page content.
The link-target permission controls the HTML
target attribute of all  elements (and  el-
ements, if allowed by whitelist) in mirrored content. By
setting this permission, the publisher can specify that ac-
tivated links or submitted forms must be directed to a new
browser tab / window (if set to blank), or directed to
the tab / window hosting the real page (if set to top).
Whether links open in the same or new window is of-
ten agreed to between the publisher and ad network. The
link-target permission can be used to protect the pub-
lisher from ad script that mistakenly creates content that
does not adhere to the agreed upon link behavior.
Policy speciﬁcation The publisher can annotate any
HTML element of the real page with a policy at-
tribute. The policy attribute contains a set of state-
ments, each terminated by a semicolon. Each state-
ment speciﬁes the value of a particular permission in
the form, permission: value;. Acceptable values for
permission and value are listed in Table 1.
Permissions granted in an element’s policy attribute
are inherited by descendants in the HTML document hi-
erarchy. That is, the scope of a permission P is the
HTML subtree rooted at the element whose policy at-
tribute grants P.
7
Algorithm 1: ComputePolicy( targetElement )
1 policy ← new Object();
2 WABef oreAppend ← undefined;
3 foreach element from root to targetElement do
4
5
6
if policy[ “write-access” ] = “append” then
policy[ “write-access” ] ← WABef oreAppend
statements ←Parse(
element.getAttribute( “policy” ));
foreach stmt in statements do
policy ← ComposePolicies( policy,
stmt );
7
8
9
10
if policy[ “write-access” ] (cid:54)= “append” then
WABef oreAppend ← policy[ “write-access” ];
11 foreach permission in all permissions do
12
13
if permission is not deﬁned in policy then
policy[ permission ] ← GetDefaultValue(
permission );
14 return policy;
Policy composition Multiple policy statements may as-
sign different values to a single permission. This can oc-
cur within a single policy attribute or through inheri-
tance. We resolve the ambiguity of multiple permission
values through a composition process. The composition
algorithm, given in Algorithm 1, takes a target element as
input and derives an assignment of values to each of the
permissions listed in Table 1.
We can describe the composition algorithm intuitively
as follows. The effective value for a permission is the
most restrictive value speciﬁed for that permission across
all composed policy statements. That is, if a permission
appears in multiple statements (either within an element’s
policy attribute or in separate inherited policies), we
take the intersection of all speciﬁed values for the per-
mission. After all statements have been composed, any
permissions left unspeciﬁed are set to their most restric-
tive values.
First,
To enhance usability we introduced three minor ex-
ceptions to the above.
the max-height and
max-width permissions default to their least restrictive
value (i.e., none). We chose this default because a deﬁni-
tive maximum height and width will not be satisfactory
for every type of ad.
It is better for each publisher to
explicitly declare these values if such restrictions are de-
sired. The policy semantics is still default-deny, because
write permissions must ﬁrst be granted before restric-
tions on the size of written content can have any im-
pact. For the same reasons, our second exception defaults
link-target permission to its least restrictive value.
The third exception is we prevent inheritance of append
write permissions. This is important as append speciﬁ-
cally does not grant access to existing children of an el-
8
(a)
google_ad_client = "pub-...";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text";
1 
8 
src="http://pagead2.googlesyndi
↵
cation.com/pagead/show_ads.js"
(b)
1
2
Figure 4:
page. (b) Tunnel Script B, added to real page.
(a) Google AdSense ad script, removed from real
ement; thus any existing children should not inherit the
append permission.
4.2 Real and Shadow pages
The architecture of our implementation requires changes
to the original web page (real page) and creation of a cor-
responding shadow page as described in §3.1. The shadow
page is hosted on a web server having an origin different
from the real page, thus the browser’s same-origin pol-
icy ensures the shadow page by default has no access to
the cookies, content or other data belonging to the real
page. Deploying our implementation requires a publisher
to conﬁgure their DNS and web server to support the
shadow page origin domain. Care must be exercised in
the selection of the shadow page domain (one for each ad-
vertiser) in order to ensure that there is no reuse or overlap
of domains.
To facilitate voluntary communication between the two
pages, we leverage the window.postMessage() brow-
ser API. postMessage() is an inter-origin frame com-
munication mechanism that enables two collaborating
frames to share data in a controlled way, even when SOP
is in effect [1].
Construction of the real page The real page is a ver-
sion of the publisher’s original page modiﬁed in three
ways. The ﬁrst modiﬁcation is to remove the ad script
(Figure 4a). Second, we add the tunnel script (Figure 4b)
to the end of the page. The third modiﬁcation to the orig-
inal page is annotation of HTML elements with policies,
which we discussed at length in §4.1. Only two annota-
tions, illustrated in §3.2.3, are required for the webmail
example.
The real page tunnel script has an initialization
routine that ﬁrst scans the real page to ﬁnd all el-
ements with policies granting the following permis-
sions:
read-access: subtree;, write-access:
append;, and write-access: subtree;. All match-
ing elements are converted into models (i.e., JavaScript
tagName: "div", syncId: 0,
top: y, left: x, width: w, height: h,
attributes: {
id: "MessageBody",
policy: "read-access: subtree;"
nodeType: "TEXT NODE",
nodeValue: "Message body text here..."
1 { nodeType: "ELEMENT NODE",
2
3
4
5
6
7
8
9
10
11
12
13
14
15 }
}
],
computedStyle: { ... }
},
children: [
{
Figure 5: Model of MessageBody element (as deﬁned in
§3.2.3) sent from real page to shadow page
data structures) that will be sent to the shadow page in
a later stage. Script nodes are omitted from models be-
cause we can not guarantee their semantics are preserved
on the shadow page. An example model is shown in Fig-
ure 5, which models the readable Message Body 
element in the webmail page (corresponding HTML given
in §3.2.3).
Of the elements found in the initial scan, those with
read permission are modeled by encoding (non-script) el-
ement attributes and readable child nodes into the model.
The remaining elements (i.e., those having write access
but no read access) are modeled as empty containers. That
is, any attributes and child nodes are omitted from the
model.
All elements with a policy annotation and their descen-
dant elements are assigned a unique syncId attribute dur-
ing initialization. The sync ID is used to match elements
on the real page with their corresponding elements on the
shadow page as content is kept synchronized between the
two pages. As the ﬁnal step of initialization, the tunnel
script creates and embeds the hidden  element
for the shadow page.
Construction of the shadow page The shadow page be-
gins as a template web page containing only the tunnel
script. As the template page is rendered, the shadow
page tunnel script receives content models (described
above) from the real page’s tunnel script. The model
data is sent as a character string in JSON [7] syntax via
postMessage(). Once received by the shadow page,
models are converted into HTML constructs using the
browser’s DOM interfaces. This results in a web page
environment containing all the non-sensitive content and
constructs of the real page, in which we will allow the ad
script to execute.
To support ads (such as inline text ads) that appear or
behave differently depending on where content is posi-
tioned, the shadow page is virtually sized to the dimen-
9
sions of the real page, and content models are rendered
in the same absolute position and size of their real page
counterpart. Position and size information is depicted in
Figure 5 as top, left, width and height properties.
Throughout dynamic updates these attributes are kept syn-
chronized by an approach given in §4.3.4.
Next, we install wrappers around several DOM API
methods to interpose between the ad script and the
DOM. Although ad script can circumvent our wrappers
in Mozilla browsers by using the JavaScript delete op-
erator [35], we do not rely on wrappers to enforce policies
or security properties. Wrappers are used to monitor page
updates and provide transparency with regard to the num-
ber of impressions generated by ads, which we discuss at
length in §4.3.
Default ad zone Lastly, the ad script is embedded in the
shadow page inside a container  element, which we
automatically map to a corresponding  on the real
page. We refer to these linked elements as the default ad
zone. Automatic mapping is required because many ad
scripts, such as Google AdSense, will not independently
ﬁnd and inject ads into the content imported from the real
page. Rather they simply write ad content into the element
containing the ad script. To support these ad scripts, the
publisher indicates the default ad zone element on the real
page by setting its HTML class attribute to include the
class AdJailDefaultZone and ensuring the element’s
policy grants subtree write access. If the real page has
no valid and unique default zone, content written to the
shadow page default zone will not appear on the real page.
4.3 Synchronization
After initial rendering of the real and shadow pages in the
browser, the two pages are kept synchronized by exchang-
ing the messages listed in Table 2. We conserve the total
number of generated ad impressions, using an approach
given in §4.3.1. Content written by ad script to the shadow
page is mirrored to the real page by a process described
in §4.3.2. User interface events are forwarded from the
real page to the shadow page as detailed in §4.3.3. Lastly,
§4.3.4 describes how content position and style is kept
synchronized on both pages as needed by some ad scripts.
4.3.1 DOM interposition
A primary goal of our approach is to conserve the num-
ber of ad impressions detected by an ad server, which we
achieve using DOM interposition. Ad networks bill ad-
vertisers, and in turn pay publishers, based in part on the
number of ad impressions. Impression counts are corre-
lated to the number of requests for ad resources submitted
to the web server [18]. When ad content is rendered on
the real page, any external resources not available in the
browser’s cache will be requested, causing an impression.
This may occur for several possible reasons out of our
control, such as: the user disabled the cache, the ad net-
(a) Real page to shadow page:
DispatchEvent( event )
Dispatch event to shadow page.
SetScrollPos( x, y )
Scroll hidden shadow page to coordinates ( x, y ).
SetStyle( syncId, properties )
Set style of shadow page element identiﬁed by syncId as
speciﬁed in properties.
(b) Shadow page to real page:
Initialize( step )