(cid:101)ğ¶âˆ—
ğ‘’ğ‘£ğ‘ğ‘™ and a garbled circuit(cid:101)ğ¶âˆ—
ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’) : It takes as input a garbled circuit
ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’, then outputs a transac-
and a updated oblivious database ODBâˆ—.
next round.
ğ‘–
,(cid:101)ğ¶âˆ—
ğ‘’ğ‘£ğ‘ğ‘™
ğ‘–
tion ğ‘‡ğ‘ˆ .
3.1.4 User-side. The specific algorithms on the local-side are for-
mal described as follows:
â€¢ DB-KeyGen(1ğ›¿) : It takes as input a security parameter 1ğ›¿,
then outputs a secret key k.
â€¢ DataRec(k, {ğµğ‘›} , ğ‘¡ğ‘–ğ‘‘): It takes as input a secret key k, a set
of cipher-text data blocks {ğµğ‘›} and target dataâ€™s ID ğ‘¡ğ‘–ğ‘‘, then
outputs a set of the userâ€™s personal data and corresponding
IDs {(ğ‘–ğ‘‘ğ‘›, ğ‘ğ‘›)}
â€¢ DataEnc(k, {(ğ‘–ğ‘‘ğ‘›, ğ‘ğ‘›)}): It takes as input a secret key k, a set
of plain-text data blocks and corresponding IDs {(ğ‘–ğ‘‘ğ‘›, ğ‘ğ‘›)},
then outputs a set of cipher-text data blocks {ğµğ‘›}.
â€¢ CreateGC(1ğœ†, ğ¶): It takes as input a security parameter ğœ†
and a circuit ğ¶, then outputs a garbled circuit(cid:101)ğ¶ and(cid:101)ğ‘¤, which
â€¢ IDGarble(ğ‘¡ğ‘–ğ‘‘,(cid:101)ğ‘¤): It takes as input the target dataâ€™s ID ğ‘¡ğ‘–ğ‘‘
and a set of labels(cid:101)ğ‘¤, then outputs a garbled ID(cid:101)ğ‘¤ğ‘–ğ‘‘.
is a set of input labels for each input wire of ğ¶.
â€¢ PosRefresh(1ğ›¾ , ğ‘›) : It takes as input a security parameter ğ›¾
and the number ğ‘› of path, then outputs a set of random path
{ğ‘ğ‘›}.
â€¢ PosCreate({ğ‘–ğ‘‘ğ‘›} , {ğ‘ğ‘›}) : It takes as input the IDs of the
userâ€™s data {ğ‘–ğ‘‘ğ‘›} and a set of random path {ğ‘ğ‘›}, then outputs
a position map ğ‘ğ‘œğ‘ .
â€¢ PosGarble(ğ‘ğ‘œğ‘ ,(cid:101)ğ‘¤) : It takes as input the position map ğ‘ğ‘œğ‘ 
and a set of labels(cid:101)ğ‘¤, then outputs the garbled position map
(cid:103)ğ‘ğ‘œğ‘ .
Poster Session ASIA CCS '20, October 5â€“9, 2020, Taipei, Taiwan8963.2 Full Construction
Combining the technology above, we propose the oblivious ac-
cess system. First of all, the user creates an Ethereum account by
SC-KeyGen, then generates the key pair ğ‘ ğ‘˜ğ‘ˆ and ğ‘ğ‘˜ğ‘ˆ for signing
and verifying. Moreover, the user generates the secret key k for
encryption and decryption of data blocks by DB-KeyGen. In this
system, the user must sign on every transaction by SC-Sign, and it
will generate the digital signature ğœ of the transaction. After the
transaction is sent to Ethereum blockchain, miners have to verify it
by SC-Vrfy, and it will generate the verification ğ‘£. If the verification
is legal, the transaction will be automatic executed. Besides, each
transaction on the blockchain will be compiled with PSC model. It
invokes TransSplit to generate the transaction sets ğ‘‡ğ‘†ğ‘’ğ‘¡1
, . . . ,ğ‘‡ğ‘†ğ‘’ğ‘¡ğ‘
and generates the threads ğ‘¡â„1, . . . , ğ‘¡â„ğ‘ to execute ğ‘‡ğ‘†ğ‘’ğ‘¡1
, . . . ,ğ‘‡ğ‘†ğ‘’ğ‘¡ğ‘
parallelly by MultiProcess. In a nutshell, the oblivious access sys-
tem consists of three main functions:Initialization,DataAccess and
DataUpload. The specific steps of the functions are described as
follows:
â€¢ Initialization : The user encrypts the userâ€™s data and the
corresponding IDs {(ğ‘–ğ‘‘ğ‘›, ğ‘ğ‘›)} by DataEnc and generates
the cipher-text data blocks {ğµğ‘›}. Besides, the user has to
build the position map by PosRefresh and PosCreate. In or-
der to use the garbled circuit scheme on SC, the user has
to do some preprocessing locally. The user generates the
garbled circuit(cid:101)ğ¶ğ‘’ğ‘£ğ‘ğ‘™ for evaluation and the corresponding
garbled labels(cid:101)ğ‘¤ğ‘’ğ‘£ğ‘ğ‘™ by CreateGC. After generating(cid:101)ğ‘¤ğ‘’ğ‘£ğ‘ğ‘™,
ğ‘ğ‘œğ‘  will be replaced by(cid:101)ğ‘¤ğ‘’ğ‘£ğ‘ğ‘™ and ğ‘ğ‘œğ‘  will become garbled
position map(cid:103)ğ‘ğ‘œğ‘ . Thus, the dataâ€™s ID will not be learned
the user has to update the labels on(cid:103)ğ‘ğ‘œğ‘ . The user needs
(cid:101)ğ¶ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ which is generated by CreateGC for replacing la-
ğ‘ğ‘œğ‘ , and uploads(cid:103)ğ‘ğ‘œğ‘ ,(cid:101)ğ¶ğ‘’ğ‘£ğ‘ğ‘™,(cid:101)ğ¶ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ to SC. Therefore, the
bels. Finally, the user builds the oblivious structure which
is show in Fig. 1 on SCand stores {ğµğ‘›} in it according to
by SC. Since the garbled circuit can only be used one time,
the user invokes PosGarble to garble ğ‘ğ‘œğ‘ . The ID field of
ğ‘¡ğ‘–ğ‘‘ will not be learned by SC. The user evaluates the target
user deploys SCto Ethereum blockchain by ğ‘‡ğ‘–ğ‘›ğ‘–ğ‘¡ğ‘–ğ‘ğ‘™ğ‘–ğ‘§ğ‘’, and
SCprovide the service-side algorithm mentioned in section
3.1.3 to the user. Next, it will generate the corresponding
transaction ğ‘‡ğ¼ and the oblivious database ODB.
â€¢ DataAccess : Before accessing the data on SC, the user gar-
the corresponding transaction ğ‘‡ğ¸. After that, the user gets
a set of cipher-text data blocks {ğµğ‘–} which contains the tar-
get data by ğ‘‡ğ‘Ÿğ‘’ğ‘ğ‘‘, and it will generates the corresponding
bles the target dataâ€™s ID ğ‘¡ğ‘–ğ‘‘ into(cid:101)ğ‘¤ğ‘–ğ‘‘ by IDGarble. Therefore,
dataâ€™s location ğ‘™ğ‘œğ‘ğ‘–ğ‘‘ on(cid:103)ğ‘ğ‘œğ‘  by ğ‘‡ğ‘’ğ‘£ğ‘ğ‘™, and it will generates
transaction ğ‘‡ğ‘…. After the labels on(cid:103)ğ‘ğ‘œğ‘  is used, the user has
(cid:103)ğ‘ğ‘œğ‘ âˆ— which is generated by ğ‘‡ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’, and it will generate
(cid:9). In
encrypts {(ğ‘–ğ‘‘ğ‘–, ğ‘ğ‘–)} by DataEnc, and it will generate(cid:8)ğµâˆ—
to update the labels by the updated garbled position map
the corresponding transaction ğ‘‡ğ‘…ğ‘ƒ. After getting {ğµğ‘–}, the
user recovers the data blocks by DataRec and gets {(ğ‘–ğ‘‘ğ‘–, ğ‘ğ‘–)}.
Next, the user obtains a target data according to ğ‘¡ğ‘–ğ‘‘.
â€¢ DataUpload : Before uploading the data on SC, the user re-
order to hide the data access pattern, the user has to refresh
ğ‘–
ğ‘–
will generate the corresponding transaction ğ‘‡ğ‘Š . Because
the path on the position map. Therefore, the user gener-
ates the random path ğ‘âˆ— by PosRefresh. After re-encrypting
the data and generating the random path, the user uploads
(cid:8)ğµâˆ—
(cid:9) and ğ‘âˆ— by ğ‘‡ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’, and ODB becomes ODBâˆ—. Next, it
(cid:101)ğ¶ğ‘’ğ‘£ğ‘ğ‘™ and(cid:101)ğ¶ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ which on SChave been used by the user,
invokes CreateGC to generate(cid:101)ğ¶âˆ—
uploads(cid:101)ğ¶âˆ—
the user has to re-generate them for the next round and
ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’. After re-
generating the garbled circuits for the next round, the user
ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’ by ğ‘‡ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’. Next, it will generate the
ğ‘’ğ‘£ğ‘ğ‘™ and(cid:101)ğ¶âˆ—
,(cid:101)ğ¶âˆ—
ğ‘’ğ‘£ğ‘ğ‘™
corresponding transaction ğ‘‡ğ‘ˆ .
4 IMPLEMENTATIONS
We implement our system on Ethereum Blockchain through Ganache
and the costs of transactions in this system are show in Table 1. As
can be seen from the table, ğ‘‡ğ‘–ğ‘›ğ‘–ğ‘¡ğ‘–ğ‘ğ‘™ğ‘–ğ‘§ğ‘’ which is the deployment of
the smart contract is the most expensive, but it is one-off which
differs from other transactions.
Table 1: Costs of transactions in this system
ğ‘‡ğ‘’ğ‘£ğ‘ğ‘™
Transaction Gas Used
4607129
ğ‘‡ğ‘–ğ‘›ğ‘–ğ‘¡ğ‘–ğ‘ğ‘™ğ‘–ğ‘§ğ‘’
483250
483250
295445
295445
2877953
ğ‘‡ğ‘Ÿğ‘’ğ‘ğ‘™ğ‘ğ‘ğ‘’
ğ‘‡ğ‘Ÿğ‘’ğ‘ğ‘‘
ğ‘‡ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’
ğ‘‡ğ‘¢ğ‘ğ‘‘ğ‘ğ‘¡ğ‘’
Fee(ETH)
0.0741
0.0077
0.0077
0.0047
0.0047
0.0463
Time(ms)
125
329
79
69
70
518
ACKNOWLEDGEMENTS
This work was supported in part by Ministry of Science and Tech-
nology of Taiwan, under grants 106-2218-E-115-008-MY3 and 109-
2628-E-155-001-MY3.
REFERENCES
[1] Nimar S Arora, Robert D Blumofe, and C Greg Plaxton. 2001. Thread scheduling
for multiprogrammed multiprocessors. Theory of computing systems 34, 2 (2001),
115â€“144.
[2] Oded Goldreich and Rafail Ostrovsky. 1996. Software protection and simulation
on oblivious RAMs. Journal of the ACM (JACM) 43, 3 (1996), 431â€“473.
[3] Eyal Kushilevitz, Steve Lu, and Rafail Ostrovsky. 2012. On the (in) security
of hash-based oblivious RAM and a new balancing scheme. In Proceedings of
the twenty-third annual ACM-SIAM symposium on Discrete Algorithms. SIAM,
143â€“156.
[4] Steve Lu and Rafail Ostrovsky. 2013. Distributed oblivious RAM for secure two-
party computation. In Theory of Cryptography Conference. Springer, 377â€“396.
[5] Satoshi Nakamoto and A Bitcoin. 2008. A peer-to-peer electronic cash system.
Bitcoin.â€“URL: https://bitcoin. org/bitcoin. pdf (2008).
[6] Emil Stefanov, Marten Van Dijk, Elaine Shi, Christopher Fletcher, Ling Ren,
Xiangyao Yu, and Srinivas Devadas. 2013. Path ORAM: an extremely simple
oblivious RAM protocol. In Proceedings of the 2013 ACM SIGSAC conference on
Computer & communications security. ACM, 299â€“310.
[7] Nick Szabo. 1997. Formalizing and securing relationships on public networks.
First Monday 2, 9 (1997).
[8] Xiao Wang, Hubert Chan, and Elaine Shi. 2015. Circuit oram: On tightness of
the goldreich-ostrovsky lower bound. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications Security. ACM, 850â€“861.
[9] Andrew C Yao. 1982. Protocols for secure computations. In 23rd annual sympo-
sium on foundations of computer science (sfcs 1982). IEEE, 160â€“164.
[10] Wei Yu, Kan Luo, Yi Ding, Guang You, and Kai Hu. 2018. A Parallel Smart Contract
Model. In Proceedings of the 2018 International Conference on Machine Learning
and Machine Intelligence. ACM, 72â€“77.
Poster Session ASIA CCS '20, October 5â€“9, 2020, Taipei, Taiwan897