## 异步是怎么实现的？你是不是有个疑问，指令交代的任务是怎么完成的？异步的实现，依赖于底层的硬件和操作系统；如果操作系统不支持，异步也可以通过线程来模拟。即便是只能通过线程来模拟，异步编程也简化了线程管理的难度。甚至能够把线程管理变透明，隐藏起来。比如我们上面使用的HttpClient 接口的代码，就没有线程的影子，看起来像一个单线程程序。异步编程对性能的爆炸性的提升来自于硬件和操作系统对异步的支持。比如说，早期传统的套接字编程，应用程序需要等待下一个连接的到来，然后等待连接数据的传输......这些等待，都需要耗费很多资源。这些被占用的资源，在连接和数据到来之前，都是没有被充分利用的资源。如果操作系统能够主动告诉应用程序，什么时候有一个连接请求，这个连接里什么时候有数据。应用程序就可以在连接和数据到来之后，再分配资源进行处理。操作系统在合适的时间，遇到触发事件，主动调用设置的应用程序，执行相关的操作。这就是操作系统对异步I/O 的支持。比如说，如果一个简单的服务就返回一个\"Hello,World!\"，它能够同时接受多少用户访问呢？如果使用传统的一个线程一个用户的模式，这个用户数量完全取决于线程的效率和容量。随着用户数的增加，线程数量也线性增加，线程管理也越来越复杂，线程的效率也加速下降，线程处理能力决定了系统最大可承载的用户数。如果使用异步 I/O，每一个 CPU分派一个线程就足以应付所有的连接。这时候，连接的效率就主要取决于硬件和操作系统的能力了。根据常见的数据，这种效率的提升通常可以达到几百倍。下面的例子，就是一个简单异步服务的框架。你可以比较一下，它和传统服务器代码的差异。    final AsynchronousServerSocketChannel listener =        AsynchronousServerSocketChannel                .open()                .bind(new InetSocketAddress("localhost", 6789)); listener.accept(null, new CompletionHandler() {    @Override    public void completed(AsynchronousSocketChannel ch, Void att) {        // accept the next connection, non-blocking        listener.accept(null, this);         // handle this connection        handle(ch);    }     @Override    public void failed(Throwable exc, Void att) {        // snipped    }});
## 零拷贝，进一步的性能提升异步编程的性能并没有止步于异步 I/O，它还有提升的空间。前面，我们讨论了减少[内存使用的两个大方向](https://time.geekbang.org/column/article/83045)，减少实例数量和减少实例的尺寸。使用共享内存，减少内存拷贝，甚至是零拷贝，可以减少CPU 消耗，也是减少实例数量和减少实例尺寸的一个办法。下面的例子中，我们使用了 ByteBuffer.allocateDirect()方法分配了一块内存空间。这个方法的实现，会尽最大的努力，减少中间环节的内存拷贝，把套接字的缓存数据，直接拷贝到应用程序操作的内存空间里。这样，就减少了内存的占用、分配、拷贝和废弃，提高了内存使用的效率。    listener.accept(null, new CompletionHandler() {    @Override    public void completed(AsynchronousSocketChannel ch, Void att) {        // accept the next connection, non-blocking        listener.accept(null, this);         // handle this connection        ByteBuffer bbr = ByteBuffer.allocateDirect(1024);        ch.read(bbr, null, new CompletionHandler() {@Overridepublic void completed(Integer result, Object attachment) {                    // snipped                } @Overridepublic void failed(Throwable exc, Object attachment) {                    // snipped}});    }     @Override    public void failed(Throwable exc, Void att) {        // snipped    }});需要注意的是，这种方式分配的内存，分配和废弃的效率一般比常规的 Java内存分配差一些。所以，只建议用在数据量比较大，存活时间比较长的情况下，比如网络连接的I/O。而且，一个连接最多只用一个读、一个写两块空间。这样，才能把它的效率充分发挥出来。
## 小结今天，我们主要讨论了异步的一些基本概念，以及异步对于效率提升的作用。异步编程，常见的模型是事件驱动的。我们通过使用有序的代码，调动独立的事件，来更有效地利用计算资源。
## 一起来动手这一次的几个例子，大致提供了异步连接编程的一个基本框架。你可以试着把这些代码丰富起来，组成一个可以运行的客户端和服务端。客户端使用HttpClient 接口发起 HTTP 连接；服务端使用异步的模式，把客户端的 HTTP请求数据原封不动发回去。下一篇文章，我会介绍一个简单的测试代码性能的工具。如果有兴趣，你可以继续测试下你编写的代码的性能，是不是比同步的编程模式有所提高。欢迎你把你的代码公布在讨论区，我们一起来学习，一起来进步。如果你想和朋友或者同事比试一下，不妨把这篇文章分享给他们，互相切磋。![](Images/64444bae3ac90f82cb45ef5f1bc68d94.png){savepage-src="https://static001.geekbang.org/resource/image/5a/98/5a96a612403912b80de030e742e2e598.jpg"}
# 26 \| 有哪些招惹麻烦的性能陷阱？前面，我们讨论了改善代码性能的最基本的办法。接下来，我们讨论一些最佳实践，让我们先从一些容易被忽略的性能陷阱开始。
## 使用性能测试工具今天我们的讲解需要用到一个工具，它就是 JMH。JMH 是为 Java语言或者其他基于 JVM的编程语言设计的一个基准测试工具。这一节，我们会使用这个工具来分析一些性能的陷阱。这里我们简单地介绍下，这个工具该怎么使用。第一步，使用 Maven 工具建立一个基准测试项目（需要使用 Maven 工具）：    $ mvn archetype:generate \          -DinteractiveMode=false \          -DarchetypeGroupId=org.openjdk.jmh \          -DarchetypeArtifactId=jmh-java-benchmark-archetype \          -DgroupId=com.example \          -DartifactId=myJmh \          -Dversion=1.0这个命令行，会生成一个 myJmh的工程目录，和一个基准测试模板文件（myJmh/src/main/java/com/example/MyBenchmark.java）。通过更改这个测试模板，就可以得到你想要的基准测试了。比如，你可以使用后面我们用到的基准测试代码，替换掉模板中的基准测试方法（measureStringApend）。    package com.example; import org.openjdk.jmh.annotations.Benchmark; public class MyBenchmark {    @Benchmark    public String measureStringApend() {        String targetString = "";        for (int i = 0; i `{=html}    Benchmark                Mode  Cnt        Score          Error  UnitsMyBenchmark.testMethod  thrpt   25        35.945 ▒       0.694  ops/s这是 JMH工具基本的使用流程，有关这个工具更多的选项和更详细的使用，需要你参考 JMH的相关文档。下面，我们通过字符串连接操作和哈希值的例子，来谈论一下这个工具要怎么使用，以及对应的性能问题。同时，我们再看看其他影响性能的一些小陷阱，比如内存的泄露、未关闭的资源和遗漏的hashCode。
## 字符串的操作在 Java 的核心类库里，有三个字符串操作的类，分别问 String、StringBuilder和StringBuffer。通过下面的基准测试，我们来了解下这三种不同的字符串操作的性能差异。为了方便，我把JMH 测试的数据，标注在每个基准测试的方法注释里了。        // JMH throughput benchmark: about 32 operations per second    @Benchmark    public String measureStringApend() {        String targetString = "";        for (int i = 0; i , CharSequence {    // snipped     @Override    @HotSpotIntrinsicCandidate    public synchronized StringBuffer append(String str) {        toStringCache = null;        super.append(str);        return this;    }     //  snipped}    public final class StringBuilder    extends AbstractStringBuilder    implements java.io.Serializable, Comparable, CharSequence {    // snipped     @Override    @HotSpotIntrinsicCandidate    public StringBuilder append(String str) {        super.append(str);        return this;    }     // snipped}JMH 的基准测试，并没有涉及到线程同步问题，难道使用 synchronized关键字也会有性能损耗吗？我们再来看看另外一个基准测试。这个基准测试，使用线程不安全的StringBuilder 以及同步的字符串连接，部分模拟了线程安全的StringBuffer.append()方法的实现。为了方便你对比，我把没有使用同步的代码也拷贝在下面。        // JMH throughput benchmark: about 21,000 operations per second    @Benchmark    public String measureStringBuilderApend() {        StringBuilder builder = new StringBuilder();        for (int i = 0; i          staticCachedObjects = new LinkedList<>(); // snippedstaticCachedObjects.add(...);长寿的缓存：    final List        longLastingCache = new LinkedList<>(); // snippedlongLastingCache.add(...);解决这个问题的办法通常是使用 SoftReference 和 WeakReference来存储对象的引用，或者主动地定期清理。静态的集合：    static final List>        staticCachedObjects = new LinkedList<>(); // snippedstaticCachedObjects.add(...);长寿的缓存：    final List>        longLastingCache = new LinkedList<>(); // snippedlongLastingCache.add(...);需要注意的是，缓存的处理是一个复杂的问题，使用 SoftReference 和WeakReference未必能够满足你的业务需求。更有效的缓存解决方案，依赖于具体的使用场景。