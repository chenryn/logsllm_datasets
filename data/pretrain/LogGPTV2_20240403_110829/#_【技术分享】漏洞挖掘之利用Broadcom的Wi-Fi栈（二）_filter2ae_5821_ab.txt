图7
虽然支持的事件代码多达144种，但是Android的主机驱动程序bcmdhd只支持其中很小的一部分。尽管如此，驱动程序中支持大约35个事件，每个事件都包含自己精心设计的处理程序。
现在我们已确信攻击面足够大，所以我们可以开始寻找bug了！不巧的是，Wi-Fi芯片似乎被认为是“受信任的”，因此，主机驱动程序中的一些验证是不够的。事实上，通过审查上面列出的相关处理函数和辅助协议处理程序，我们发现了[大量的漏洞](https://bugs.chromium.org/p/project-zero/issues/detail?id=1064)。
**漏洞**
仔细研究我们发现的漏洞，我们可以看到这些漏洞彼此间均略有不同。一些允许较强的原语，一些允许较弱的原语。但是，最重要的是，其中很多有各种先决条件，满足后方可成功触发，一些仅限于某些物理接口，其他的仅在一定的驱动程序配置下有效。不过，有[一个漏洞](https://bugs.chromium.org/p/project-zero/issues/detail?id=1061)似乎在所有版本的bcmdhd和所有的配置中存在——如果能成功利用该漏洞，那就搞定了。
我们来仔细看看讨论中的事件帧。"WLC_E_PFN_SWC"类型的事件用于指示固件中发生了“重要Wi-Fi改动”（SWC），且必须由主机处理。主机的驱动程序不是直接处理这些事件，而只是从固件中收集所有传输的数据，并通过Netlink向[cfg80211](https://wireless.wiki.kernel.org/en/developers/documentation/cfg80211)层广播“供应商事件”数据包。
更具体而言，由固件发送的每个[SWC事件帧](https://android.googlesource.com/kernel/common.git/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/include/wlioctl.h#2653)均包含一个事件数组（类型为[wl_pfn_significant_net_t](https://android.googlesource.com/kernel/common.git/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/include/wlioctl.h#2646)）、总计数（total_count）及数组中的事件数（pkt_count）。由于事件总数可能相当大，所以其可能无法容纳在一个帧中（即其可能大于[最大MSDU](https://en.wikipedia.org/wiki/Maximum_transmission_unit#MTUs_for_common_media)）。在这种情况下，可以连续发送多个SWC事件帧——其内部数据将由驱动程序累积，直到达到总计数，此时，驱动程序将处理整个事件列表。
图8
通读驱动程序的代码，我们可以看到，当接收到此事件代码时，将触发一个初始处理程序来处理该事件。然后处理程序内部调用“[dhd_handle_swc_evt](https://android.googlesource.com/kernel/common.git/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/dhd_pno.c#3569)”函数来处理事件的数据。我们来仔细看看：
图9
（其中“event_data”是封装在从固件传入的事件中的任意数据）
从上面可以看到，如上所述，函数首先分配一个数组来保存事件的总计数（如果之前未分配），然后继续从缓冲区中相应的索引（results_rxed_so_far）开始连接封装的数据。
但是，处理程序无法验证total_count和pkt_count之间的关系！其只是“信任”“total_count足够大，可以保存所有后续传入的事件”之断言。因此，能够注入任意事件帧的攻击者可以指定一个小的total_count和一个较大的pkt_count，从而可触发一个简单的内核堆溢出。
**远程内核堆整形**
一切都没有问题，但是我们如何从远程有利位置来利用该原语？因为我们不在设备的本地位置，所以我们无法收集有关堆的当前状态的任何数据，也没有与地址空间相关的信息（除非我们能以某种方式泄漏此信息）。针对内核堆溢出的许多经典利用依赖于对内核堆进行整形的能力，即确保在触发溢出之前处于某种状态——我们目前也缺乏这一能力。
我们对分配算符本身有什么了解？kmalloc分配算符（[SLAB](https://en.wikipedia.org/wiki/Slab_allocation)、[SLUB](https://en.wikipedia.org/wiki/SLUB_\(software\))、[SLOB](https://en.wikipedia.org/wiki/SLOB)）有一些可能的底层实现，可在构建内核时配置。但是，在绝大多数设备上，kmalloc使用“SLUB”——一种未队列化的per-CPU高速缓存“[slab分配算符](https://en.wikipedia.org/wiki/Slab_allocation)”。
每个“slab”只是一个小区域——从该区域雕刻相同大小的分配。每个slab中的第一个块包含其元数据（例如slab的freelist），后续块包含分配本身，没有内联元数据。有一些预定义的由kmalloc使用的slab大小类，大小通常小至64字节，大至约8KB。不出所料，分配算符为每个分配使用最适合的slab（足够大的最小slab）。最后，slab的freelist被线性消耗——连续的分配占用连续的内存地址。但是，如果对象在slab中被释放，则其可能变得碎片化——导致后续的分配填入slab中的“孔”中，而非线性进行。
图10
考虑到这一点，让我们后退一步，分析一下手头的原语。首先，由于我们能够任意指定total_count中的任何值，所以我们可以选择溢出缓冲区的大小作为sizeof（wl_pfn_significant_net）的任何倍数。这意味着我们可以使用我们选择的任何slab缓存大小。因此，我们可以瞄准溢出的对象的大小没有限制。但是，这还不够。我们对slab的目前状态仍然一无所知，也不能触发我们选择的slab中的远程分配。
似乎我们首先需要找到一个方法来对slab进行远程整形。但是回想一下，我们需要克服一些障碍。由于SLUB保持per-CPU高速缓存，所以执行分配的内核线程的亲和性必须与分配溢出缓冲区的内核线程相同。在不同的CPU内核上获取堆整形原语将导致从不同的slab进行分配。解决这个问题的最简单的方法是将我们限制在可以从发生溢出的同一个内核线程中触发的堆整形原语。这是一个相当大的限制，实质上，这强制我们忽略由于事件处理本身外部的进程所导致的分配。
无论如何，有了具体目标后，我们可以开始在每个事件帧的注册处理程序中寻找堆整形原语了。幸运的是，审查过每个处理程序后，我们找到了非常适合的一个。
“WLC_E_PFN_BSSID_NET_FOUND”类型的事件帧由处理函数dhd_handle_hotlist_scan_evt处理。该函数累积扫描结果的链表。每次接收到一个事件时，其数据被附加到列表中。最后，当一个带标记（表明事件是链中的最后一个事件）事件到达时，该函数传递收集的待处理事件列表。我们来仔细看看：
图11
太棒了——看看上面的函数，似乎我们可以反复导致大小分配{ sizeof(gscan_results_cache_t) + (N-1) *
sizeof(wifi_gscan_result_t) | N > 0 }
（其中N表示结果->计数）。此外，这些分配是在同一个内核线程中执行，其生命周期完全由我们控制！只要我们不发送具有PFN_COMPLETE状态的事件，则不会释放任何分配。
在我们继续之前，我们需要选择一个目slab大小。理想情况下，我们要寻找一个相对不活跃的slab。如果同一CPU上的其他线程选择从同一个slab分配（或释放）数据，这将增加该slab的状态的不确定性，并可能使我们无法成功对其进行整形。在查看/proc/slabinfo并跟踪具有与我们的目标内核线程相同的亲和性的每个slab的kmalloc分配后，我们发现似乎kmalloc-1024
slab最不活跃。因此，我们将选择在我们的利用方法中瞄准这一slab大小。
通过使用上面的堆整形原语，我们可以开始使用“gscan”对象填充任何给定大小的slab。每个“gscan”对象都有一个包含与扫描有关的元数据的短header，和一个指向链表中下一个元素的指针。对象的其余部分然后由“扫描结果”的内联数组填充，携带此节点的实际数据。
图12
回到手头的问题——我们如何使用这个原语制作可预测的布局？
通过将堆整形原语与溢出原语相结合，我们应该能够在触发溢出之前对任何大小类的slab进行正确整形。回想一下，最初任何给定的slab均可能是碎片化的，如下所示：
图13
但是，在用我们的堆整形原语触发足够的分配（比如(SLAB_TOTAL_SIZE / SLAB_OBJECT_SIZE) –
1）后，当前slab中的所有孔（若有）应该被填充，导致后续相同大小类的分配连续进行。
图14
现在，我们可以发送一个特制的SWC事件帧，指示一个total_count——导致从同一个目标slab进行的分配。但是，我们还不想触发溢出。在我们这样做之前，我们还必须对当前的slab进行整形。为了防止溢出发生，我们将提供一个小的pkt_count，从而仅部分填充缓冲区。
图15
最后，再次使用堆整形原语，我们可以用更多的“gscan”对象填充slab的其余部分，这使我们获得以下堆状态：
图16
我们快要到达目的地了！从上面可以看到，如果我们在这一点上选择使用溢出原语，我们就可以用我们自己的任意数据覆盖其中一个“gscan”对象的内容。但是，我们还没有明确确定这会产生什么样的结果。
**分析限制**
为了确定覆盖“gscan”对象的效果，我们来看看处理一连串“gscan”对象的流程（即接收到标记有“完成”的事件之后执行的操作）。该处理由[wl_cfgvendor_send_hotlist_event](https://android.googlesource.com/kernel/common/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/wl_cfgvendor.c#234)处理。该函数检查列表中的每个事件，将事件的数据打包到SKB中，然后通过Netlink将SKB广播到任何潜在的监听器。
但是，该函数确实有一定的障碍需要克服，任何给定的“gscan”节点均可能大于SKB的最大大小。因此，需要将节点分成若干个SKB。为了跟踪该信息，使用了“gscan”结构中的“tot_count”和“tot_consumed”字段。“tot_count”字段表示在节点内联数组中嵌入的扫描结果条目的总数，“tot_consumed”字段表示到目前为止消耗（传输）的条目数。
因此，该函数在处理列表时对其内容进行了略微修改。其实质上执行不变量，每个处理节点的“total_consumed”字段将被修改，以匹配其“tot_count”字段。至于正在传输的数据及其打包方法，为简洁起见，我们将跳过这些细节。然而，重要的是要注意，除了上述副作用之外，该函数的危害似乎微乎其微（也就是说，无法从其“开采”进一步的原语）。在所有事件均被打包到SKB中并被传送到任何监听器后，就可以将其回收了。这可以通过审查列表并在每个条目上调用“kfree”来实现。
总而言之，这使我们在利用方面处于何种位置？假设我们选择使用溢出原语覆盖其中一个“gscan”条目，那我们可以修改其“next”字段（或者说必须，因为其是结构中的第一个字段），并将其指向任意地址。这将导致处理函数将该任意指针视作列表中的一个元素而予以使用。
图17
由于处理函数的不变量——在处理特制的条目之后，其第7个字节（“tot_consumed”）将被修改，以匹配其第6个字节（“tot_count”）。此外，处理链之后，指针将被kfreed。更重要的是，回想一下，处理函数迭代整个条目列表。这意味着，特制条目（其“next”字段）中的前四个字节必须指向包含“有效”列表节点的另一个内存位置（随后必须满足相同的约束），或必须保持值0（
NULL）——表示这是列表中的最后一个元素。
这看起来不容易…有很多限制我们需要考虑。如果我们故意选择忽略kfree一段时间，我们可以尝试搜索前四个字节为零、有利于修改第七个字节（以匹配第六个字节）的内存位置。当然，这只是冰山一角，我们可以反复触发相同的原语，从而将字节反复向左复制一位。或许，如果我们能找到一个有足够的零字节和足够的我们选择的字节的内存地址，我们就可以通过连续使用这两个原语来制作一个目标值。
为了衡量这种方法的可行性，我已经在一个小的SMT实例中对上述限制进行了编码（使用[Z3](https://github.com/Z3Prover/z3)），并提供了来自内核的实际堆数据，以及各种目标值及其对应的位置。此外，由于内核的转换表存储在内核VAS中的一个不变地址，对其进行略微修改也可能导致可利用的条件，所以其内容（以及相应的目标值）也被添加到了SMT实例中。当且仅当任何目标值可在不超过十个“步骤”（每一步都是原语的调用）内占用任何目标位置时，该实例满足条件。不幸的是，结果相当严峻…似乎这种方法不够强大。
此外，虽然这个想法在理论上可能很好，但实际上并不奏效。要知道，在任意地址调用kfree并不是没有其副作用。包含内存地址的页面必须标记为“slab”页面或“compound”。这通常仅适用于slab分配算符实际使用的页面。尝试在没有标记为此的页面中的地址调用kfree会触发内核恐慌（从而会导致设备崩溃）。
也许，相反，我们可以选择忽略其他约束并专注于kfree？实际上，如果我们始终能找到一个其数据可用于利用目的分配，那么我们就可以尝试释放该内存地址，然后使用我们的堆整形原语“重新捕获”它。然而，这又引起了几个其他问题。首先，我们始终能找到一个常驻slab地址吗？其次，即使我们能找到这样一个地址，其肯定与per-CPU缓存相关联，意味着释放它不一定能让我们可以稍后回收。最后，无论我们选择瞄准哪个分配，都必须满足上面的约束——即前四个字节必须为零，第7个字节将被修改为与第6个字节匹配。
然而，这正是我们可以巧妙利用之处。回想一下，kmalloc保持一些固定大小的缓存。然而，当请求更大的分配时会发生什么？事实证明，在这种情况下，kmalloc只返回一连串的空闲页面（使用[__get_free_pages](http://lxr.free-electrons.com/source/mm/page_alloc.c#L3869)）并将其返回给调用者。这是在没有任何per-CPU缓存的情况下完成的。因此，如果我们能够释放一个大的分配，那我们应该能够在不必首先考虑哪个CPU进行的分配的情况下回收它。