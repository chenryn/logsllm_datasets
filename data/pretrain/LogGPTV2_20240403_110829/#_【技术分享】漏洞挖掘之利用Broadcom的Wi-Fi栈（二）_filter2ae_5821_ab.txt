### 优化后的文本

#### 图7
尽管Android的主机驱动程序bcmdhd支持多达144种事件代码，但实际支持的事件仅有约35种。每种事件都有其专门设计的处理程序。鉴于此攻击面已足够大，我们开始寻找潜在的安全漏洞。

不幸的是，Wi-Fi芯片被视作“受信任”的组件，因此主机驱动程序中的一些验证措施并不充分。通过审查相关的处理函数和辅助协议处理程序，我们发现了一些显著的漏洞（[详情](https://bugs.chromium.org/p/project-zero/issues/detail?id=1064)）。

**漏洞分析**

我们发现的这些漏洞各有特点。一些漏洞允许较强的原语操作，而另一些则较为有限。许多漏洞需要特定的先决条件才能触发，比如某些物理接口或特定的驱动程序配置。然而，有一个漏洞（[详情](https://bugs.chromium.org/p/project-zero/issues/detail?id=1061)）在所有版本的bcmdhd和所有配置中都存在，如果能成功利用该漏洞，将带来重大安全风险。

让我们详细探讨一下涉及的事件帧。“WLC_E_PFN_SWC”类型的事件用于指示固件中的“重要Wi-Fi改动”（SWC），并需要主机进行处理。主机驱动程序不会直接处理这些事件，而是从固件收集所有传输的数据，并通过Netlink向[cfg80211](https://wireless.wiki.kernel.org/en/developers/documentation/cfg80211)层广播“供应商事件”数据包。

具体来说，每个由固件发送的[SWC事件帧](https://android.googlesource.com/kernel/common.git/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/include/wlioctl.h#2653)包含一个事件数组（类型为[wl_pfn_significant_net_t](https://android.googlesource.com/kernel/common.git/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/include/wlioctl.h#2646)）、总计数（total_count）及数组中的事件数（pkt_count）。由于事件总数可能较大，无法容纳在一个帧中（即大于[最大MSDU](https://en.wikipedia.org/wiki/Maximum_transmission_unit#MTUs_for_common_media)），因此可以连续发送多个SWC事件帧。驱动程序会累积这些帧中的数据，直到达到总计数，然后处理整个事件列表。

图8
查看驱动程序代码，当接收到此事件代码时，会触发一个初始处理程序来处理该事件。处理程序内部调用“[dhd_handle_swc_evt](https://android.googlesource.com/kernel/common.git/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/dhd_pno.c#3569)”函数来处理事件的数据。我们来看一下这个函数：

图9
（其中“event_data”是封装在从固件传入的事件中的任意数据）

如上所述，该函数首先分配一个数组来保存事件的总计数（如果之前未分配），然后从缓冲区中的相应索引（results_rxed_so_far）开始连接封装的数据。

但是，处理程序没有验证total_count和pkt_count之间的关系！它只是“信任”total_count足够大，可以保存所有后续传入的事件。因此，能够注入任意事件帧的攻击者可以指定一个小的total_count和一个较大的pkt_count，从而触发内核堆溢出。

**远程内核堆整形**

尽管发现了漏洞，但我们如何从远程位置利用这一原语？因为不在设备本地，我们无法获取有关堆当前状态的数据，也无法获取地址空间信息（除非以某种方式泄漏这些信息）。许多经典的内核堆溢出利用依赖于对内核堆进行整形的能力，即确保在触发溢出前处于某种状态——目前我们缺乏这种能力。

关于分配算符本身，kmalloc有几种可能的底层实现，如[SLAB](https://en.wikipedia.org/wiki/Slab_allocation)、[SLUB](https://en.wikipedia.org/wiki/SLUB_\(software\))和[SLOB](https://en.wikipedia.org/wiki/SLOB)，可在构建内核时配置。但在绝大多数设备上，kmalloc使用“SLUB”——一种未队列化的per-CPU高速缓存“[slab分配算符](https://en.wikipedia.org/wiki/Slab_allocation)”。

每个“slab”是一个小区域，从中雕刻相同大小的分配。每个slab的第一个块包含元数据（例如slab的freelist），后续块包含分配本身，没有内联元数据。kmalloc使用的slab大小类通常从小至64字节到大至约8KB。分配算符为每个分配选择最适合的slab（足够大的最小slab）。最后，slab的freelist被线性消耗——连续的分配占用连续的内存地址。但如果对象在slab中被释放，则可能导致碎片化——导致后续的分配填入slab中的“孔”中，而非线性进行。

图10
考虑到这一点，让我们后退一步，分析手头的原语。首先，由于我们可以任意指定total_count，因此可以选择溢出缓冲区的大小作为sizeof(wl_pfn_significant_net)的任何倍数。这意味着我们可以选择任何slab缓存大小。因此，我们可以瞄准溢出的对象的大小没有限制。但这还不够，我们对slab的当前状态仍然一无所知，也不能触发我们选择的slab中的远程分配。

似乎我们需要找到一种方法来对slab进行远程整形。由于SLUB保持per-CPU高速缓存，执行分配的内核线程的亲和性必须与分配溢出缓冲区的内核线程相同。解决这个问题的最简单方法是将我们限制在可以从发生溢出的同一个内核线程中触发的堆整形原语。这是一个相当大的限制，实质上，这强制我们忽略由于事件处理外部的进程所导致的分配。

有了具体目标后，我们可以开始在每个事件帧的注册处理程序中寻找堆整形原语。幸运的是，审查过每个处理程序后，我们找到了非常适合的一个。

“WLC_E_PFN_BSSID_NET_FOUND”类型的事件帧由处理函数dhd_handle_hotlist_scan_evt处理。该函数累积扫描结果的链表。每次接收到一个事件时，其数据被附加到列表中。最后，当一个带标记（表明事件是链中的最后一个事件）的事件到达时，该函数传递收集的待处理事件列表。我们来看一下这个函数：

图11
太棒了——看看上面的函数，似乎我们可以反复导致大小分配{ sizeof(gscan_results_cache_t) + (N-1) * sizeof(wifi_gscan_result_t) | N > 0 }（其中N表示结果->计数）。此外，这些分配是在同一个内核线程中执行，其生命周期完全由我们控制！只要我们不发送具有PFN_COMPLETE状态的事件，则不会释放任何分配。

在继续之前，我们需要选择一个目标slab大小。理想情况下，我们要寻找一个相对不活跃的slab。如果同一CPU上的其他线程选择从同一个slab分配（或释放）数据，这将增加该slab的状态的不确定性，并可能使我们无法成功对其进行整形。在查看/proc/slabinfo并跟踪具有与我们的目标内核线程相同的亲和性的每个slab的kmalloc分配后，我们发现kmalloc-1024 slab最不活跃。因此，我们将选择在我们的利用方法中瞄准这一slab大小。

通过使用上述堆整形原语，我们可以开始使用“gscan”对象填充任何给定大小的slab。每个“gscan”对象都有一个包含与扫描有关的元数据的短header，和一个指向链表中下一个元素的指针。对象的其余部分由“扫描结果”的内联数组填充，携带此节点的实际数据。

图12
回到手头的问题——我们如何使用这个原语制作可预测的布局？

通过将堆整形原语与溢出原语相结合，我们应该能够在触发溢出之前对任何大小类的slab进行正确整形。回想一下，最初任何给定的slab均可能是碎片化的，如下所示：

图13
但是在用我们的堆整形原语触发足够的分配（比如(SLAB_TOTAL_SIZE / SLAB_OBJECT_SIZE) – 1）后，当前slab中的所有孔（若有）应该被填充，导致后续相同大小类的分配连续进行。

图14
现在，我们可以发送一个特制的SWC事件帧，指示一个total_count——导致从同一个目标slab进行的分配。但是，我们还不想触发溢出。在我们这样做之前，我们还必须对当前的slab进行整形。为了防止溢出发生，我们将提供一个小的pkt_count，从而仅部分填充缓冲区。

图15
最后，再次使用堆整形原语，我们可以用更多的“gscan”对象填充slab的其余部分，这使我们获得以下堆状态：

图16
我们快要到达目的地了！从上面可以看到，如果我们在这一点上选择使用溢出原语，我们就可以用我们自己的任意数据覆盖其中一个“gscan”对象的内容。但是，我们还没有明确确定这会产生什么样的结果。

**分析限制**

为了确定覆盖“gscan”对象的效果，我们来看看处理一连串“gscan”对象的流程（即接收到标记有“完成”的事件之后执行的操作）。该处理由[wl_cfgvendor_send_hotlist_event](https://android.googlesource.com/kernel/common/+/bcmdhd-3.10/drivers/net/wireless/bcmdhd/wl_cfgvendor.c#234)处理。该函数检查列表中的每个事件，将事件的数据打包到SKB中，然后通过Netlink将SKB广播到任何潜在的监听器。

但是，该函数确实有一定的障碍需要克服，任何给定的“gscan”节点均可能大于SKB的最大大小。因此，需要将节点分成若干个SKB。为了跟踪该信息，使用了“gscan”结构中的“tot_count”和“tot_consumed”字段。“tot_count”字段表示在节点内联数组中嵌入的扫描结果条目的总数，“tot_consumed”字段表示到目前为止消耗（传输）的条目数。

因此，该函数在处理列表时对其内容进行了略微修改。其实质上执行不变量，每个处理节点的“total_consumed”字段将被修改，以匹配其“tot_count”字段。至于正在传输的数据及其打包方法，为简洁起见，我们将跳过这些细节。然而，重要的是要注意，除了上述副作用之外，该函数的危害似乎微乎其微（也就是说，无法从其“开采”进一步的原语）。在所有事件均被打包到SKB中并被传送到任何监听器后，就可以将其回收了。这可以通过审查列表并在每个条目上调用“kfree”来实现。

总而言之，这使我们在利用方面处于何种位置？假设我们选择使用溢出原语覆盖其中一个“gscan”条目，那我们可以修改其“next”字段（或者说必须，因为其是结构中的第一个字段），并将其指向任意地址。这将导致处理函数将该任意指针视作列表中的一个元素而予以使用。

图17
由于处理函数的不变量——在处理特制的条目之后，其第7个字节（“tot_consumed”）将被修改，以匹配其第6个字节（“tot_count”）。此外，处理链之后，指针将被kfreed。更重要的是，回想一下，处理函数迭代整个条目列表。这意味着，特制条目（其“next”字段）中的前四个字节必须指向包含“有效”列表节点的另一个内存位置（随后必须满足相同的约束），或必须保持值0（NULL）——表示这是列表中的最后一个元素。

这看起来不容易…有很多限制我们需要考虑。如果我们故意选择忽略kfree一段时间，我们可以尝试搜索前四个字节为零、有利于修改第七个字节（以匹配第六个字节）的内存位置。当然，这只是冰山一角，我们可以反复触发相同的原语，从而将字节反复向左复制一位。或许，如果我们能找到一个有足够的零字节和足够的我们选择的字节的内存地址，我们就可以通过连续使用这两个原语来制作一个目标值。

为了衡量这种方法的可行性，我已经在一个小的SMT实例中对上述限制进行了编码（使用[Z3](https://github.com/Z3Prover/z3)），并提供了来自内核的实际堆数据，以及各种目标值及其对应的位置。此外，由于内核的转换表存储在内核VAS中的一个不变地址，对其进行略微修改也可能导致可利用的条件，所以其内容（以及相应的目标值）也被添加到了SMT实例中。当且仅当任何目标值可在不超过十个“步骤”（每一步都是原语的调用）内占用任何目标位置时，该实例满足条件。不幸的是，结果相当严峻…似乎这种方法不够强大。

此外，虽然这个想法在理论上可能很好，但实际上并不奏效。要知道，在任意地址调用kfree并不是没有其副作用。包含内存地址的页面必须标记为“slab”页面或“compound”。这通常仅适用于slab分配算符实际使用的页面。尝试在没有标记为此的页面中的地址调用kfree会触发内核恐慌（从而会导致设备崩溃）。

也许，相反，我们可以选择忽略其他约束并专注于kfree？实际上，如果我们始终能找到一个其数据可用于利用目的分配，那么我们就可以尝试释放该内存地址，然后使用我们的堆整形原语“重新捕获”它。然而，这又引起了几个其他问题。首先，我们始终能找到一个常驻slab地址吗？其次，即使我们能找到这样一个地址，其肯定与per-CPU缓存相关联，意味着释放它不一定能让我们可以稍后回收。最后，无论我们选择瞄准哪个分配，都必须满足上面的约束——即前四个字节必须为零，第7个字节将被修改为与第6个字节匹配。

然而，这正是我们可以巧妙利用之处。回想一下，kmalloc保持一些固定大小的缓存。然而，当请求更大的分配时会发生什么？事实证明，在这种情况下，kmalloc只返回一连串的空闲页面（使用[__get_free_pages](http://lxr.free-electrons.com/source/mm/page_alloc.c#L3869)）并将其返回给调用者。这是在没有任何per-CPU缓存的情况下完成的。因此，如果我们能够释放一个大的分配，那我们应该能够在不必首先考虑哪个CPU进行的分配的情况下回收它。