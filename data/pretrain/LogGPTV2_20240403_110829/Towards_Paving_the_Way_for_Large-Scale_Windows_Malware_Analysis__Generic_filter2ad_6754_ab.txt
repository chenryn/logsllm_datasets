more difficult because of instruction size explosion [63]. Worse still,
some anti-analysis tricks try to nullify the “written-then-executed”
feature of memory pages [60] or attack the heuristics of original
code identification [51]. In our comparative evaluation with other
three recent unpacking tools, no single previous work could cope
with all of the tested packers.
2.2 API Call Resolution
Binary packing technique keeps evolving itself to counter reverse
engineering. But one thing maintains stable; that is, malware pay-
load still needs to interact with Windows OS (via calling Win-
dows APIs) to fulfill diversified malicious intents, such as process
injection [30], C&C communication [26], and document encryp-
tion [43]. As compiler is unaware of DLL API addresses at compile
time, a PE (Portable Executable) file has to resolve DLL API ad-
dresses dynamically, which comes in two major ways: 1) Type I:
standard API resolution, a.k.a. implicit linking [59]; 2) Type II: dy-
namic API resolution, a.k.a. explicit linking [58]. Type I, the most
prevalent way, accesses PE file header’s import address table (IAT)
Session 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada397Figure 1: The unpacking process goes through multiple “written-then-executed” layers. The first layer contains anti-analysis
code such as integrity check and anti-debugging, and the deepest layer does not consist of the malware payload but junk code.
to obtain an API address [84]. IAT entries list the function names
or ordinals that need to be imported from a specific DLL. When
a PE file is loaded, Windows loader is responsible for loading and
linking required DLLs, and it also fills in the IAT entries with the
virtual addresses of each imported function. The PE file refers to
IAT by using indirect control flow instructions to call the DLL APIs.
As a contrast, Type II has to make function calls to explicitly load
the DLL and obtain an import function address at run time. The
most convenient way is to explicitly invoke “LoadLibrary”8 and
“GetProcAddress”9. This means at least these two APIs are kept in
IAT for Type II.
There are two exceptions to Type I & II in which IAT is not
required. The first one is that API addresses can be hard-coded
in binary. However, diversified Windows OS versions and address
space layout randomization have put this exception into a dead end.
The second exception happens at shellcode. As shellcode is not dy-
namically loaded by Windows loader but injected into the process
space of victim program at run time, shellcode has to acquire the
needed APIs’ addresses without visiting IAT. Shellcode can first
get the address of kernel32.dll from structured exception handling
(SEH) or process environment block (PEB) structure [12], and it
then searches the addresses of “LoadLibrary” and “GetProcAddress”
from kernel32.dll’s export directory. However, developing compli-
cated malicious behavior using shellcode has many constraints and
lacks compatibility [89]. That is the reason why shellcode is typi-
cally small and target-specific, and it is mainly used in the early
stage of malware infection such as exploiting the vulnerability and
bypassing the protection of data execution prevention. In addition,
there are already mature solutions to prevent shellcode from obtai-
ning the DLL address via SEH and PEB [92]. Therefore, we do not
consider these two corner cases as practical.
2.3 Import Address Table Rebuilding
To complicate reverse engineering, packers obfuscate API call re-
solution by erasing the IAT of original code. Then the attached
unpacking routine will rebuild a new IAT at run time, before resu-
ming the original code execution. Rebuilding IAT means unpacking
routine, like a custom dynamic loader, has to recover the connection
from an API call name to its virtual address. This can be achieved
by explicitly calling the API “LoadLibrary” and “GetProcAddress”
(Type II). Note that a local IAT is attached to unpacking routine
as well, as the unpacking routine itself has to call APIs for various
8It maps a DLL into a process’s address space during execution.
9It returns an API call’s virtual address.
purposes, such as detecting debugging/emulation environment and
rebuilding the IAT of original code.
From code obfuscation viewpoint, removing IAT offers many
benefits. First, many Windows APIs are abused for malicious pur-
pose [20, 68, 88]. For example, “WriteProcessMemory” and “Crea-
teRemoteThread” are often used together by malware authors to
complete process injection [30]. Removing payload’s IAT prevents a
deep insight into the high-level semantics of malware. We manually
modify an open source packer so that it does not remove the IAT
of malware payload. The consequence is that another 14 additional
anti-virus scanners are able to recognize this malware. The second
benefit is to impede the reconstruction of a fully functional version
of the original binary. In addition to removing IAT, many advanced
packers go one step further to apply API redirection [39] during IAT
rebuilding. For example, the address in IAT does not directly point
to an API function but another memory region that has a direct
jump to that API. API redirection hinders the perfect reconstruction
of IAT, and therefore the unpacked code cannot function correctly.
Another byproduct of deleting IAT is that it can further reduce the
packed code size [82]. Several previous work has reported such IAT
erasing and rebuilding behavior [17, 44, 82, 86, 97], but our work
focuses on using these common features for generic unpacking.
2.4 Motivating Example
We use a malware sample hupigon.eyf10 protected by FSG packer
to illustrate the process of IAT rebuilding. Hupigon family was once
notorious for the back doors they left on the compromised machine.
Original hupigon.eyf contains 575 APIs, and it makes indirect calls
to the API names stored in IAT (see Figure 2(a)). For the FSG packed
version, FSG compresses code and data sections, erases the origi-
nal IAT, and attaches an IAT to unpacking routine. As shown in
Figure 2(b), the unpacking routine IAT contains only two API calls
from kernel32.dll: “LoadLibrary” and “GetProcAddress”, which are
capable of rebuilding the IAT. Figure 2(c) is the memory view of
FSG packed version at run time, and it also shows the common
features that BinUnpack relies on. When the control flow arrives
at OEP, the packed code and data sections have been restored, and
the payload IAT, containing the same 575 APIs and their addresses,
is reconstructed as well. Note that the reconstructed payload IAT
is different from the unpacking routine IAT in two ways. 1) As the
functionality of unpacking routine is relatively simple, it typically
has much fewer imported APIs than the reconstructed payload IAT.
2) They reside in different memory regions. Recall that program
10MD5:09457821763329501273aa4659292401
Unpacking Routine……(N-5) layersTimelineEntry PointPacked MalwareWritten-then-ExecutedLayer 1Layer N-2Junk CodeLayer N-1Malware PayloadLayer NJunk CodeIntegrity Check & Anti-DebuggingSession 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada398Figure 2: FSG packer removes the malware’s original IAT from the packed version. The attached unpacking routine IAT only
contains two APIs: “LoadLibrary” and “GetProcAddress”, and they are enough to rebuild the original IAT.
refers to IAT via indirect calls (e.g., call [f1]). Deliberately over-
lapping the payload IAT to the unpacking routine IAT’s memory
region is particularly challenging, because packers have to perform
binary rewriting on the just recovered payload code and make sure
all related indirect call addresses (e.g.,f1 ∼ f119) are redirected to
the new locations. BinUnpack takes advantage of these differences
to detect the end of unpacking.
avoids the high runtime overhead caused by monitoring multiple
“written-then-executed” layers. However, several other challenges
are raised when we design BinUnpack’s API monitor with existing
methods [2, 101, 105]. All of them place BinUnpack in a dilemma:
they either can be easily evaded or are unaware of user-level API
semantics. Next section will discuss how we manage to address this
dilemma in a hybrid way.
3 OVERVIEW
From the packers’ pervasive IAT rebuilding behavior, we uncover
two clues to help us determine the end of unpacking: 1) the recon-
struction of payload IAT happens ahead of the jump to OEP; 2)
at run time, if an API is called through a rebuilt IAT rather than
the unpacking routine IAT, it indicates that malware payload has
been restored. BinUnpack’s key idea is to capture such “rebuilt-
then-called” feature.
Figure 3 shows the architecture of BinUnpack. BinUnpack ex-
tracts the unpacking routine IAT of packed malware via static analy-
sis, and then it monitors the dynamic execution of packed malware.
The core of BinUnpack is “Hook-evasion Resistant API Monitor”. It
monitors API calls, find the related IAT to an API call, and compa-
res the related IAT with the unpacking routine IAT (“Compare” in
Figure 3). If the current related IAT is different from the unpacking
routine IAT, that means the related IAT is rebuilt at run time. Next,
BinUnpack halts the execution of packed malware and traces back
to OEP (“OEP Search”). After that, we dump the memory of cur-
rent process (“Process Dump”) as BinUnpack’s output (“Malware
Payload”), which can be used for further malware analysis. Our
design presents a distinct competitive advantage; that is, BinUnpack
4 HOOK-EVASION RESISTANT API MONITOR
Another major contribution of BinUnpack is that our API moni-
tor combines the existing two methods to achieve complete DLL
hijacking. We rely on kernel-level hooking (method 1) to inter-
cept an indispensable DLL loading function and load home-made
DLL rather that target DLL (DLL hijacking, method 2). Our de-
sign amplifies the advantages of these two techniques and avoid
their limitations. In addition, BinUnpack integrates several existing
work [42, 87, 90] to defeat possible evasions and attacks.
4.1 API Hooking and Limitations
API hooking intercepts a call to an API function. The normal invoca-
tion flow will be rerouted to a different location where the hooking
function resides. Existing API hooking methods [2, 101, 105] can be
divided into two types: user-level and kernel-level hooking. User-
level API hooking, such as IAT hooking and export address table
(EAT) hooking, works at the user-level of OS and is process-specific.
It has been adopted by many prevalent sandboxes [71, 101] to ex-
tract the user-level API semantics of malware. However, user-level
hooking has to modify the target process space, which can be easily
detected and countered by hook-evasion techniques [53]. Table 1
(a) Original hupigon.eyf (disk view)Entry PointCode Section    Original Entry Point   …….    call [f1]     …….Data Section IAT Sectionkernel32.dlluser32.dll…(b) Packed hupigon.eyf by FSG (disk view)Enrty PointUnpacking Routine (c) Packed hupigon.eyf at run time (memory view)Enrty PointOriginal Code Section    Original Entry Point     …….    call [f1]     …….Original Data Section Original IAT  Sectionkernel32.dlluser32.dll…f1:7C801A28…f119: …Unpacking Routine    Unpack Original Code;     ...     Rebuild Original IAT;    Jump to OEPUnpacking Routine IAT  kernel32.dll        g1,    g2Total: 575 APIs  Total: 575 APIs  Unpacking Routine IAT  kernel32.dll       g1,  g2Total: 2 APIs  Packed Code & Data  f1: CreatFile f2: DeleteFile…f119:    … …           7C801A28: (offset)     CreatFile  …                  …           7C801D7B: (offset)     LoadLibrary  …           7C80AE30: (offset)     GetProcAddress  …          kernel32.dllControl flowFunction referenceSession 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada399Figure 3: The Architecture of BinUnpack.
Table 1: Common user-level API hooking evasions adopted by
packers.
Evasion Type
Stolen code
Child process
Process hollowing
Crash hooking module
Packers
Asprotect, Pelock, Yoda’s Protector,
Yoda’s Crypter, Enigma, Themida,
Private exe Protector (PEP)
Armadillo, Pespin
Ransomware custom packer
presents the most common user-level API hooking evasions and
representative packers we have encountered in our experiment. We
divide them into three categories.
Stolen Code Stolen code [38, 82] copies some instructions from
an API to an allocated memory in malware process. When a pac-
ked malware attempts to call the API, it first executes the copied
instructions instead; and then the control flow jumps back to the
API instruction which just follows the copied instructions. Stolen
code happens at run time, after DLL has been loaded [82]. As many
user-level API hooking techniques identify their target API calls
by matching the virtual addresses where these APIs are expected
to locate, stolen code will make such API hooking tools miss the
target.
Child Process & Process Hollowing These two evasions are used
to hide the presence of a malicious process. Child process means
packed malware forks a child process, in which the malware execu-
tes unpacking routine and payload. User-level API monitoring is
typically process-specific; that is, they only work at a specific pro-
cess where the IAT or EAT is hooked. Some ransomware’s custom
packer has applied a more advanced technique, called “process hol-
lowing” [48]. The effect of process hollowing is unpacking routine
and original code execution will be decoupled into two processes.
Any generic unpacking tool that does not have full control over
multiple processes will be circumvented [44, 76].
Crash Hooking Module Some ransomware’s custom packers
have adopted a powerful anti-hooking technique: crash the hooking
module [41]. The packer tries to create an access violation exception
by arbitrarily calling APIs with invalid arguments. In a non-hooking
environment, Windows OS default exception handlers can handle
such errors, so packed ransomware can run properly. However,
it is quite complicated to develop exception handlers for an API
hooking system, and therefore it will crash when the access viola-
tion exception is raised. Security vendor VMRay [27] in May 2017
reported that the custom packer adopted by Cerber ransomware
can crash all API hooking based sandbox solutions.
In contrast, kernel-level hooking of native API, is more difficult
to be tampered with than user-level hooking, and it also has a global
view over multiple processes. Unfortunately, kernel-level hooking
does not suffice for BinUnpack, because there is no bijective map-
ping between user-level APIs and kernel-level native APIs [5]. Some
user-level APIs such as path-related APIs and DLL management
APIs (e.g., “GetProcAddress”) provide user-level service exclusively.
That means they do not invoke any native API at all. When Bin-
Unpack is searching OEP (see Figure 6), we need to accurately hook
“GetProcAddress” API so that we can limit the OEP search scope.
Kernel-level hooking alone may miss the first API that is invoked
from a rebuilt IAT or render the OEP search inaccurate.
4.2 DLL Hijacking
The limitations of user-level and kernel-level API hooking turn our
attention to another API monitoring method: DLL hijacking [79].
As developers often load a common DLL by its name rather than its
absolute path, DLL hijacking exploits the DLL path search order to
load a custom-made DLL instead of the original DLL11. Compared
to API hooking, DLL hijacking is more compatible with the target
process. DLL hijacking withstands the evasion of stolen code. The
reason is DLL hijacking does not modify the target process space,
and the subject process has already loaded the custom-made DLL
into its own space, before API instruction stealing occurs at run time.
Therefore, the effect of stolen code is just like calling the custom-
made API. Besides, DLL hijacking is immune to crash hooking
module attack as it can naturally deliver runtime errors to Windows
OS’s exception handlers. However, given DLL hijacking’s robust
resilience, another problem rears its head.
Microsoft has realized that the default DLL path search order can
be misused to load malicious component, so a more strict restriction
comes up for core system DLLs such as kernel32.dll and advapi32.dll.
The set of core DLLs and their full paths are explicitly specified
by a particular Registry key [46]. We overcome the challenge of
hijacking Windows core DLL by combining DLL hijacking and
kernel-level hooking.
11Windows OS’s standard DLL path search order and DLL hijacking example are
shown in Appendix Table 5 and Appendix Figure 9.
Unpacking RoutinePacked MalwareCompareOEP SearchBinUnpackHooked API & Related IATMalware PayloadKernel-level DLL HijackingMalGene [42]Shadow Walker [90]BinShape [87]Hook-evasion Resistant API MonitorProcess Dump Scylla [1]Unpacking Routine IAT   kernel32.dll       g1,  g2Session 3A: Binary Analysis CCS’18, October 15-19, 2018, Toronto, ON, Canada400Figure 4: BinUnpack’s kernel-level DLL hijacking.
LdrpMapDll()
{
//initialization code preparing for mapping DLL
initialization code here;
//map the DLL in the address of "BaseAddress"
NTSTATUS St= NtMapViewOfSection(...,∗BaseAddress,...)
If(St==STATUS_IMAGE_NOT_AT_BASE)
{
//the DLL is not at base, relocate it.
relocation code here;
//initialization code preparing for mapping DLL
initialization code here;
/∗ map the dll in the address of "BaseAddress"
again, the "BaseAddress" may be modified by the
previous call of "NtMapViewOfSection" ∗/
NtMapViewOfSection(...,∗BaseAddress,...)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
}
}
Figure 5: The interaction between LdrpMapDll and NtMap-
ViewOfSection. “BaseAddress” is the pointer to a base ad-
dress where the DLL is mapped to.
4.3 Kernel-level DLL Hijacking
Standard DLL loading is mainly by means of calling “LoadLibrary” [46,
61], including implicit linking [59] and most cases of explicit lin-
king [58]. This fact inspires us to bypass Windows path search
order restriction. Particularly, we hook “LoadLibrary” and replace
the core DLL with our custom-made DLL to achieve the goal of
hijacking. As user-level API hooking does not resist to evasions,
we switch to kernel-level hooking to intercept “LoadLibrary”. We
reverse-engineer Windows kernel with WinDbg [80] and find out a
call chain from “LoadLibrary” to its related native API: “NtMapVie-
wOfSection” in ntoskrnl.exe (the call chain is shown in Appendix
Figure 10). The last user-level API before this call chain goes into
kernel is “NtMapViewOfSection” function in ntdll.dll. “NtMapVie-
wOfSection” in ntoskrnl.exe is the native API corresponding to “Nt-
MapViewOfSection” in ntdll.dll. “NtMapViewOfSection” in ntdll.dll
only forward all its parameters to “NtMapViewOfSection” in ntos-
krnl.exe. Thus, we can use kernel-level hooking of “NtMapViewOf-
Section” in ntoskrnl.exe to intercept the “NtMapViewOfSection” in
ntdll.dll. Figure 5 shows how “LdrpMapDll” interacts with “NtMap-