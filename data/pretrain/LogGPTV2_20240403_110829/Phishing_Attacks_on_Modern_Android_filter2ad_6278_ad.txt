implementation.
5.4 LastPass
LastPass has been installed by more than one million users and
it supports a11y, Autofill Framework, and OpenYOLO. With a11y,
LastPass uses a permanent notification to alert the user if the cur-
rently active app has some form to fill; thus, she has to tap the
notification to show a popup window with her credential; with the
Autofill Framework, the user does not need to tap the notification
and she will directly see the pop up window, as in Dashlane. This un-
derlines that the support to OpenYOLO is still immature. However,
the current implementation allows the user to select credentials
and send them to any unidentified requesting app.
Mapping implementation. LastPass relies on two mappings. The
first one is, once again, heuristic-based, and it works as follows.
Given a package name, e.g., aaa.bbb.ccc, LastPass splits it in compo-
nents separated by the dots (e.g., aaa, bbb, and ccc), and it builds a
domain name pattern by using the first two in reversed order (e.g.,
bbb.aaa). LastPass will then suggest to the user all the credentials
associated with domain names that end such pattern.
In case an entry does not exist, LastPass allows the user to
search among her locally stored credentials and select (in case)
one of them, thereby defining a new entry for the mapping. As
such entries may be useful for other users worldwide, LastPass
allows the user to share them with the community. This sharing
step is at the basis of the second mapping, a crowdsourced mapping.
LastPass downloads this global database at the first installation.
At the time of writing, we found 19,273 crowdsourced mapping
entries with repeated package names and domains, mostly many-
to-one. For instance, we found a mapping between package names
com.tinder and com.tinderautoliker2 associated to the web domain
facebook.com: Tinder is a dating app that needs Facebook creden-
tials to authenticate the user, while TinderAutoLiker is an app
available on alternative markets that automates some actions on
Tinder services. It is also worth noting that the crowdsourced map-
ping contains errors, like invalid domains, domains with typos, and
IP addresses belonging to local networks.
Exploitation. To exploit the first mapping strategy, the attacker
can create an app with a package name beginning with the reverse
of the target domain name. For example, we created an app with
package name com.facebook.evil and we were able to upload it to
the Play Store without problems: when the user opens this app,
LastPass automatically suggests credentials related to facebook.com.
From the conceptual point of view, an attacker could exploit
the second mapping as well. In fact, if the attacker is able to inject
an arbitrary association, she can directly indicate to LastPass that,
for example, her own package name should be associated to, say,
facebook.com. For the sake of completeness, we tried to share with
LastPass an association from one of our package name app to one of
our test websites. However, this association did not become public
to all users. We assume that LastPass make these “new” associations
available to all its users only when a number higher than a threshold
suggested them. An attacker could try to create a high number of
fake accounts and to automatically share these fake associations.
However, we have opted not to do it for ethical reasons. Moreover,
an attacker can already game LastPass suggestion mechanism by
exploiting the first mapping.
5.5 1Password
1Password has been installed by more than one million users and
it supports a11y, Autofill Framework and OpenYOLO. Differently
from previously analyzed PMs, 1Password organizes its entries in
categories (e.g., credit card, database, driver license, login, wire-
less router, etc.). We focused on the login category. Once the user
selects a form, 1Password behaves differently with respect to the
supporting methodology: on Autofill Framework, it shows a small
windows bearing the imprint “Autofill with 1Password”. Clicking
on it, the user must insert the 1Password master password and
search through all its previously saved credentials. With a11y, it
directly loads the windows for searching among credentials. Al-
beit 1Password adopts the OpenYOLO library, the implementation
contains just a stub that always returns empty credentials.
Mapping. 1Password does not provide any mapping, but it trivially
suggests each stored credential through a searchable list, delegating
the choice to the user. In other words, it is possible to autofill any
requesting app with any stored credential.
Exploitation. The exploitation of 1Password was straightforward
and did not require any further customization of the app. However,
this attack is less practical than the other ones as the attacker does
not have fine-grained control over the list of credentials that are
auto-suggested.
5.6 Google Smart Lock
Google Smart Lock (GSL) is part of Google Play Services for An-
droid. It was created to automatically keep the device locked when
the user is not around and unlock it when specific user-defined con-
straints are met. For instance, the user can choose to have her device
unlocked according to the presence of specific wireless connections,
trusted locations, or when it recognizes the user’s face or voice, or
while the user is carrying the device. GSL has been equipped with
the PM originally integrated into the Chrome browser. For this rea-
son, GSL also offers a password-saving feature, taking advantage of
Autofill Framework (which works just with compatible apps), and
a synchronization mechanism with the Chrome desktop browser.
Mapping. We believe that GSL mapping is securely implemented.
However, the burden of mapping creation is delegated to the devel-
oper who has to provide all the necessary information to Google.
In particular, the official documentation describes a multi-step pro-
cess [25]. From the technical standpoint, this process is based on
Digital Asset Links [19], through which an app can be verifiably
linked to a website (see Section 4.3, “Secure mapping”). However,
this procedure is not fully automated, and developers are requested
to fill a Google Form manually and to provide a set of information.
We argue that such a process hardly scales, as it is centralized and
it requires the manual intervention of the developer. To improve
the current approach, Google should push the Digital Asset Links
adoption and verify that it is correctly implemented. Moreover, we
believe that Google would greatly benefit the community if it could
make its current mapping database publicly available.
6 INSTANT APPS FOR FULL UI CONTROL
The attacks presented so far require a malicious app to be installed
on the victim’s device. This section discusses how this prerequisite
can be waived by abusing the recently introduced Instant Apps. This
technology, implemented by Google, allows users to “try” Android
apps at the touch of a click, without the need for a full installation.
This mechanism works in several steps. First, the developer
builds an Instant App, a small-but-functional version of her app,
and she uploads it to the Play Store. The developer is also asked
to associate a URL pattern to it (pointing to a domain name she
controls). The idea is that when the user browses to a URL satis-
fying this pattern, the Android framework starts the process of
downloading and running the Instant App associated with it. Of
course, for security reasons, the app developer needs to first prove to
Google that she controls the target domain name. This is carried out
through a multi-step procedure called App Link Verification [29],
which relies on Digital Asset Links [19] protocol (this makes possi-
ble to associate an app with a website and vice versa, via verifiable
statements).
From the developers and users’ usability perspective, Instant
Apps is a great feature as it significantly lowers the friction for a
user to test (and possibly fully install) an app. However, from the
security point of view, Instant Apps provide a venue for attackers to
greatly facilitate phishing attacks.
The key observation is that Instant Apps allow an attacker to
move from web phishing to mobile phishing. Nowadays, web phish-
ing is significantly more challenging than mobile phishing. On
the web, the user can clearly see which website she is interacting
with: she has the chance to check the domain name, whether the
connection is done via HTTPS, and whether there is a valid SSL
certificate. In the mobile world, however, there are no such indica-
tors. In fact, as previous works have pointed out [8, 9, 38], there is
currently no “green lock” or any space for any trusted indicator:
these previous works have shown that a malicious app spoofing
the Facebook UI can be made indistinguishable from the legitimate
Facebook app—even for a security-savvy user. The key requirement
for these pixel-perfect attacks is the ability to control all the pixels
on the screen. A website cannot achieve that, but an attacker can
use Instant Apps to do just that: gain code execution on the device
outside the browser’s JavaScript sandbox and gain the ability to
fully control the UI (without requesting any permission).
Once the attacker has gained full UI control, there are many
possibilities. One first example is that the Instant App could resem-
ble the real Facebook app, which can be made indistinguishable
from the legitimate one. A second example would be to resemble the
browser app itself : as the attacker controls every pixel of the screen,
nothing prevents her from showing the user a browser-like view
with a spoofed facebook.com domain name and a green lock. Once
again, this attack can be made indistinguishable from a legitimate
scenario.
7 PRACTICAL PHISHING ATTACKS
The password managers flaws and Instant Apps “features” we have
highlighted thus far are independent of each other. However, we
found that for what concerns phishing attacks, these two tech-
nologies are, in fact, complementary. In fact, we have shown that
password managers can be tricked into revealing users’ credentials,
but these attacks require a malicious app (with an attacker-chosen
package name) to be installed on the victim’s phone: Instant Apps
can be used to do just that.
We have found that Instant Apps, although they are not fully
installed apps, do appear as they were to the Android framework
and the components relying on it. The key insight is that even if
the Instant App is not fully installed, the app somehow lives on the
Android device, and its package name, application name, and icon
are attacker-controlled (they are, in fact, the same as its associated
full app on the Play Store). To make it worse, password managers
currently do not notice the difference between full and Instant Apps,
and they can thus be tricked to leak credentials even to them.
To make things worse, we have found that current password
managers autofill hidden fields as well. This yet another “feature”
that opens the possibility for a stealthy and practical end-to-end
phishing attack, which we describe next.
7.1 End-to-end proof-of-concept
Consider a scenario where the user visits a website showing a
spoofed Facebook “like” button, as in Figure 3a. Such button links
to an attacker-controlled URL that is associated with her Instant
point, since our app was created with a package name following
the com.facebook.* pattern (see Section 5.4), LastPass is tricked to
automatically suggest the real Facebook credentials to the user:
With a click on the autofill popup, the full credentials are leaked to
the attacker.
We note that our app is a clearly “fake” Facebook app, just for
clarity sake and for ethical and copyright concerns: as this is a “live”
PoC (to test the Instant Apps we needed to publish it to the Play
Store), we preferred to avoid having a real spoofed Facebook UI.
Practicality considerations. We have shown how the user can be
lured to leak her credentials in just a few clicks. We also note that
the click on “Open app” (3b) and the “Loading” view (3c) are only
shown the first time. That is, an attacker could make this attack
even more practical by luring the user to approve and download
the Instant App beforehand and for phishing-unrelated, seemingly
innocuous reasons, to then make the transition from “Click to the
like button” to “Spoofed Facebook UI” really seamless. We believe
this attack strategy significantly lowers the bar, with respect to
all known phishing attacks on the web and mobile devices: to the
best of our knowledge, this is the first attack that does not assume
a malicious app already installed on the phone and that does not
even require the user to insert her credentials. These attacks are
strictly more practical than all currently known mobile phishing
works [8, 9, 18, 38].
7.2 Hidden Password Fields
We have carried out further experiments with the aim of assessing
whether current mobile password managers are vulnerable to auto-
matically filling hidden fields. We refer to fields as hidden if the field
is, for one reason or another, not visible to a user. This is relevant
because an attacker could create a form with a username field and
a hidden password field: if the victim uses her password manager
to autofill this form, her password will be silently leaked to the
attacker. This is similar to what previous research has attempted
with web-based password managers [39]: To the best of our knowl-
edge, we are the first to show that these attacks work with mobile
password managers as well. For this work, we considered four dif-
ferent techniques to make a password-related EditText seemingly
invisible: 1) transparency, 2) small size, 3) same-color background
and foreground, and 4) the invisible flag.
Transparency. To create a transparent EditText in Android, it
is possible to set its alpha value accordingly (via the setAlpha()
API). We note that if the alpha value is set to zero, both the a11y
and Autofill Service cannot autofill the EditText because it is not
visible anymore. However, setting an alpha value of 0.01 is enough
to keep the field invisible and make the autofill mechanisms work.
Small size. One other venue to make a field invisible to the human
eye is to make it very small. We found that password managers
autofill password fields even if their size is 1dp × 1dp, independently
from whether they are using a11y or Autofill Service.
Same-color background and foreground. If the text color is the
same of the background color, the field (and its content) will not
be visible. This technique works well with a11y. However, unex-
pectedly, it is not enough to trick Autofill Service. In fact, upon
autofilling, the Autofill Service would overlay the autofilled fields
(a) Phishing website
(b) Instant App popup
(c) Instant App loading
(d) LastPass is tricked
Figure 3: Instant Apps phishing attack PoC
App. Once the user clicks on the like button, the Instant Apps
mechanism is triggered: the popup asking the user confirmation
to start the Instant App is shown, as in Figure 3b. This popup
shows the application name and the icon, which, however, are fully
attacker-controlled. The reader can see from Figure 3b how it is
easy to mislead the user: for this PoC we used “Open With” as
the name of the app and a fully white square as the app’s icon
(“showed” on the left of the application name). Upon the user’s
click on the “Open app” button, the Instant App is automatically
downloaded, while the user is shown for few moments (about one
second) the view in Figure 3c. At this point, the malicious Instant
App is running on the user’s device, as shown in Figure 3d. At this
with a yellow overlay, thus making the hidden field visible to the
user. However, it would be possible for an attacker to create in-app
overlays (which do not require additional permissions) to cover this
yellow overlay, thus making this artifact not visible to the user.
Invisible flag. It is possible to make a field hidden by setting its
visibility to View.INVISIBLE. We found that a11y-based password
managers do not autofill these “invisible” fields, but those ones
using Autofill Service do so.
Discussion. We believe these additional techniques make end-to-
end phishing attacks even more practical and problematic. While
the unsuspecting user will use password managers and instant apps
to quickly provide her email address or username, her credentials
could be silently leaked to the attacker, with only few clicks. We
also note that while some of the above techniques are not working
with both a11y and Autofill Service, there is nothing preventing an
attacker to combine these techniques at her will and adapt given
the attack scenario. Finally, we note that these password-stealing
attacks are possible only because current password managers imple-
ment a vulnerable mapping algorithm: without such vulnerability,
no credentials can ever be leaked to non-legitimate apps.
8 A SECURE-BY-DESIGN API
We believe that the attacks presented in this paper are due to design
problems of the current mechanisms to support autofill, from a11y,
to the more recent Autofill Framework and OpenYOLO. The key
design issue is that all these mechanisms use package names as
the main abstraction to work with, thus leaving developers of pass-
word managers with the daunting task of mapping apps to their
associated domain names. Given the number of security issues and
misplaced trust assumptions we have identified in leading password
managers, we believe third-party developers should not be asked
to implement this critical step.
The getVerifiedDomainNames() API. We propose a new API that
implements a secure-by-design mechanism by using domain names
as the only abstraction that password managers need to interact
with. Since credentials are created for websites, we argue this is a
better abstraction level. In stark difference concerning existing pro-
posals, this API, called getVerifiedDomainNames(), would directly
provide to password managers a list of domain names that a given
app is legitimately associated to. The API internal implementation
would then be responsible for performing all the needed security
checks. We envision this API to be used following the paradigm
of OpenYOLO (as in Figure 2). The main difference is that pass-
word managers would directly query for domain names, and not
for package names.
Integration and implementation. The request for auto-filling a
form follows several steps. First, the client sends an Intent to the