title:Dynamic Searchable Encryption via Blind Storage
author:Muhammad Naveed and
Manoj Prabhakaran and
Carl A. Gunter
2014 IEEE Symposium on Security and Privacy
Dynamic Searchable Encryption via Blind Storage
Muhammad Naveed, Manoj Prabhakaran, Carl A. Gunter
University of Illinois at Urbana-Champaign
Abstract—Dynamic Searchable Symmetric Encryption allows
a client to store a dynamic collection of encrypted documents with
a server, and later quickly carry out keyword searches on these
encrypted documents, while revealing minimal information to the
server. In this paper we present a new dynamic SSE scheme that is
simpler and more efﬁcient than existing schemes while revealing
less information to the server than prior schemes, achieving fully
adaptive security against honest-but-curious servers.
We implemented a prototype of our scheme and demonstrated
its efﬁciency on datasets from prior work. Apart from its concrete
efﬁciency, our scheme is also simpler: in particular, it does not
require the server to support any operation other than upload and
download of data. Thus the server in our scheme can be based
solely on a cloud storage service, rather than a cloud computation
service as well, as in prior work.
In building our dynamic SSE scheme, we introduce a new
primitive called Blind Storage, which allows a client to store a set
of ﬁles on a remote server in such a way that the server does not
learn how many ﬁles are stored, or the lengths of the individual
ﬁles; as each ﬁle is retrieved, the server learns about its existence
(and can notice the same ﬁle being downloaded subsequently), but
the ﬁle’s name and contents are not revealed. This is a primitive
with several applications other than SSE, and is of independent
interest.
I.
INTRODUCTION
In recent years, searchable symmetric encryption (SSE)
has emerged as an important problem at the intersection of
cryptography, cloud storage, and cloud computing. SSE allows
a client to store a large collection of encrypted documents with
a server, and later quickly carry out keyword searches on these
encrypted documents. The server is required to not learn any
more information from this interaction, beyond certain patterns
(if two searches involve the same keyword, and if the same
document appears in the result of multiple searches, but not
the actual keywords or the contents of the documents).
A long line of recent work has investigated SSE with
improved security, more ﬂexible functionality and better ef-
ﬁciency [23], [10], [18], [17], [6]. The techniques in all
these works build on the early work of [10], [9]. In this
work we present a radically different approach that achieves
stronger security guarantees and ﬂexibility, with signiﬁcant
performance improvements. In particular, our construction
enjoys the following features:
• Dynamic SSE, which supports adding and removing docu-
• The server is “computation free”. Indeed, the only opera-
tions that need to be supported by the server are uploading
and downloading blocks of data, if possible, parallelly. This
makes our system highly scalable, and any optimizations in
these operations (e.g., using a content delivery network) will
be directly reﬂected in the performance of the system.
ments at any point during the life-time of the system.
• The information revealed to the server (“leakage functions”)
is strictly lesser than in all prior Dynamic SSE schemes
except [24]. Scheme of [24] reveals less information to the
server at the expense of poly-logarithmic overhead on top of
Dynamic SSE overhead of other schemes (including ours).
• Satisﬁes a fully adaptive security deﬁnition, allowing for
the possibility that the search queries can be adversarially
inﬂuenced based on the information revealed to the server
by prior searches.
• Security is in the standard model, rather than the heuristic
Random Oracle Model; relies only on the security of block
ciphers and collision resistant hash functions.
• Optional document-set privacy. The number of documents
in the system and their lengths can be kept secret, revealing
the existence of a document only when it is accessed by
the client (typically after learning that a keyword appears
in that document). This allows one, for instance, to archive
e-mail with support for keyword searching, while keeping
the number and lengths of e-mails hidden from the server
(until each one is retrieved).
A simple prototype has been implemented to demonstrate the
efﬁciency of the system.
Blind Storage. An important contribution of this work is to
identify a more basic primitive that we call Blind Storage, on
which our Dynamic SSE scheme is based. A Blind Storage
scheme allows a client to store a set of ﬁles on a remote
server in such a way that the server does not learn how many
ﬁles are stored, or the lengths of the individual ﬁles; as each
ﬁle is retrieved, the server learns about its existence (and can
notice the same ﬁle being downloaded subsequently), but the
ﬁle’s name and contents are not revealed. Our Blind Storage
scheme also supports adding new ﬁles and updating or deleting
existing ﬁles. Further, though not needed for the Dynamic SSE
construction, our Blind Storage scheme can be used so that the
actual operation — whether it is reading, writing, deleting or
updating — is hidden from the server.
Though not
the focus of this work, we remark that a
Blind Storage system would have direct applications in itself,
rather than as a tool
in constructing ﬂexible and efﬁcient
Dynamic SSE schemes. As our Blind Storage scheme does
not make requirements on the server other than storage, it can
be used with commodity storage systems such as Dropbox.
This enables a wide range of simple applications that can
take advantage of modular privacy protections to operate at a
large scale and low expense but with strong privacy guarantees.
Applications can range from backing up a laptop to archiving
patient records at a hospital. Further, in our dynamic SSE
scheme, document set privacy with relatively low overhead is
made possible because we can simply store all the documents
in the same Blind Storage system that is used to implement
the SSE scheme.
© 2014, Muhammad Naveed. Under license to IEEE.
DOI 10.1109/SP.2014.47
639
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:59:56 UTC from IEEE Xplore.  Restrictions apply. 
II. RELATED WORK
The problem of searching on encrypted data has received
increasing attention from the security and cryptography com-
munity, with the growing importance of cloud storage and
cloud computation. One of the major hurdles in outsourcing
data storage and management for businesses has been security
and privacy concerns [15], [21], [3]. Theoretical cryptography
literature offers an extremely powerful and highly secure
solution in the form of Oblivious Random Access Memory
(ORAM) [20], [13], which addresses almost all of the security
concerns related to storing data in an untrusted server. How-
ever, this solution remains very inefﬁcient for several important
applications, despite signiﬁcant recent
improvements [22],
[26], [25]. The notion of Symmetric Searchable Encryption
(SSE) — investigated in a long line of works including [23],
[11], [7], [10], [27], [8], [19], [18], [17], [24], among others
— attempts to strike a different balance between efﬁciency
and security, by letting the server learn just the pattern of
data access (and ideally, nothing more), in return for a simpler
and faster construction; further, one often settles for security
against passively corrupt (honest-but-curious) servers. The
scheme of [24] also provides a notion of forward privacy,
which prevents leaking whether a newly added document
contains the keywords the user has already searched for.
The approach in [10] formed the basis for many subsequent
works. The basic idea is to use an index that maps each search
keyword to the list of documents that contains it. This list is
kept as an encrypted linked list, with each node containing the
key to decrypt next node. The nodes of all the linked lists are
kept together, randomly sorted. Until the head of a linked list is
decrypted, it is virtually invisible to the server; in particular, the
number of linked lists and their lengths remain hidden from
the server. This construction provided non-adaptive security
(which assumes that all the search queries are generated at
once); efﬁciently achieving adaptive security has been the
subject of much research starting with [10].
An important aspect of SSE is whether it is dynamic or not:
i.e., whether the client can update the document collection after
starting to search on it. Dynamic SSE schemes were presented
in [11], [27], [18], [17], [5], [24].
Finally, we mention a few variants of the SSE problem that
are not considered in this work. One could require security
against actively corrupt servers, rather than just honest-but-
curious servers. Another variant requires more expressive
searches, involving multiple keywords (e.g., [14], [6], [5]).
One could also require that many clients can perform searches
on a document collection created by a single data-owner
[16]. While we do not consider these problems in this work,
the main new tool we build — namely, a Blind Storage
system — is a general-purpose tool and is likely to be useful
for expressive search queries. Indeed, it could be used to
implement components like the “T-sets” of [6] more efﬁciently.
These and other extensions are subject of on going work.
III. TECHNICAL OVERVIEW
Fig. 1: Contrasting the architecture of existing SSE Schemes (on the
left) with that of the proposed scheme.
our scheme, and in particular, as depicted in Figure 1, from
the fact that our server is computation free.
Techniques. Our main construction is that of a versatile tool
called Blind Storage, which is then used to build a full-ﬂedged
SSE scheme. A Blind Storage scheme lets the client keep all
information — including the number and size — about ﬁles
secret from the server storing them, until they are accessed. In
building the SSE scheme, the search index entries for all the
keywords are stored as individual ﬁles in the Blind Storage
scheme (with care taken to facilitate updates).
Our Blind Storage scheme, called SCATTERSTORE,
is
constructed using a simple, yet powerful technique: each ﬁle is
stored as a collection of blocks that are kept in pseudorandom
locations; the server sees only a super-set of the locations
where the ﬁle’s blocks are kept, and not the exact set of
locations.1 The key security property this yields us is that, from
the point of view of the server, each ﬁle is associated with a
set of locations independent of the other ﬁles in the system.
(Indeed, the sets of locations for two ﬁles can overlap.)
A rigorous probabilistic analysis shows that for appropriate
the probability that any information
choice of parameters,
about ﬁles not yet accessed is leaked to the server can be
made negligible (say, 2−40 or 2−80), with a modest blow-up
in the storage and communication costs (e.g., by a factor of 4)
over unprotected storage.
The only cryptographic tools used in our scheme are block
ciphers (used for standard symmetric key encryption as well as
for generating pseudorandom locations where the data blocks
are kept) and collision resistant hash functions. The security
parameters for these tools are chosen independently of the
other parameters in the scheme.
Architecture. Most of the previous SSE schemes were pre-
sented as using a dedicated server, that performed both storage
and computation. (See Figure 1.) The computation typically
involved an (unparallelizable) sequence of decryptions. To
deploy such a scheme using commodity services, one would
need to rely not only on cloud storage services, but also
cloud computation services. This presents several limitations.
Firstly, this limits the choice of service providers available to a
user: one could use Amazon EC2 for computation, combined
with Amazon S3 for storage; however, it is not viable to
use Dropbox for persistent storage and Amazon EC2 for
computation, as this would incur high costs for communication
between these two services. Storage and compute clusters are
physically separated in modern data centers. This would add
additional latency in all dynamic SSE schemes except ours, as
data needs to be transmitted from storage nodes to compute
nodes over the data center network. In contrast, our system
In this section, we brieﬂy discuss our techniques and the
advantages of our scheme compared to prior SSE construc-
tions. Most of the advantages follow from the simplicity of
1To the extent that extra blocks are read, our scheme is similar to existing
Oblivious RAM constructions. However, in our case, the overhead of extra
blocks is bounded by a constant factor.
640
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:59:56 UTC from IEEE Xplore.  Restrictions apply. 
StorageProcessingcommand/dataresponseStorageuploaddownloadStorageProcessingcommand/dataresponseStorageuploaddownloadcan be easily implemented using Dropbox or other similar
services which provide only storage. Secondly, relying on
cloud computation makes the deployment less ﬂexible, as it
is harder to change choices like that of the operating system
(due to pricing changes or technical support, for instance).
Another important issue in existing schemes is that one
relies on availability and trust assumptions (e.g., honest-but-
curious) for both computation and storage. Clearly, it is desir-
able to trust storage alone, as is the case in our scheme. Fur-
ther, in ongoing work, we consider obtaining security against
actively corrupt (rather than honest-but-curious) servers; this is
easier and more efﬁcient to achieve starting from our scheme,
since we need to enforce honest behavior on part of a server
that provides storage alone.
Finally, it is signiﬁcantly cheaper to rely on a cloud-storage
service alone than on cloud computation (plus persistent stor-
age).
Security deﬁnition. An important feature of our schemes