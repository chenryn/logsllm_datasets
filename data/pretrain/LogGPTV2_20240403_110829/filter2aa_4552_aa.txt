# 进程
> 注 : 笔记中拓扑图 drawio 源文件在其图片目录下
---
---
## 基础
### 线程和进程的关系
多进程和多线程都是并发，都可以提高处理器的利用效率,但在 Linux 系统中，进程和线程几乎没有区别。
编译好的可执行程序只是一个文件，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等等，进程创建好之后，读入你的程序，你的程序才被系统执行。
对于操作系统，进程就是一个数据结构.
从 Linux 内核的角度来看，并没有把线程和进程区别对待。系统调用 `fork()` 可以新建一个子进程，函数 `pthread()` 可以新建一个线程。但无论线程还是进程，都是用 task_struct 结构表示的，唯一的区别就是共享的数据区域不同。
换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享。
所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。
那么你可能问，既然进程和线程差不多，而且多进程数据不共享，即不存在数据错乱的问题，为什么多线程的使用比多进程普遍得多呢？
因为现实中数据共享的并发更普遍呀，比如十个人同时从一个账户取十元，我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一个账户的拷贝，每个拷贝账户减少十元。
### 文件描述符
```c++
struct task_struct {
    // 进程状态
    long              state;
    // 虚拟内存结构体
    struct mm_struct  *mm;
    // 进程号
    pid_t             pid;
    // 指向父进程的指针
    struct task_struct __rcu  *parent;
    // 子进程列表
    struct list_head        children;
    // 存放文件系统信息的指针
    struct fs_struct        *fs;
    // 一个数组，包含该进程打开的文件指针
    struct files_struct     *files;
};
```
task_struct 就是 Linux 内核对于一个进程的描述，也可以称为“进程描述符”。
其中比较有意思的是 mm 指针和 files 指针。mm 指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方；files 指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。
一般来说，一个进程会从 `files[0]` 读取输入，将输出写入 `files[1]`，将错误信息写入 `files[2]`。
举个例子，以我们的角度 C 语言的 printf 函数是向命令行打印字符，但是从进程的角度来看，就是向 `files[1]` 写入数据；同理，scanf 函数就是进程试图从 `files[0]` 这个文件中读取数据。
每个进程被创建时，files 的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的“文件描述符”就是指这个文件指针数组的索引，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。
对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的进程需要通过“系统调用”让内核进程访问硬件资源。
如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到 files 的第 4 个位置：
明白了这个原理，输入重定向就很好理解了，程序想读取数据的时候就会去 `files[0]` 读取，所以我们只要把 `files[0]` 指向一个文件，那么程序就会从这个文件中读取数据，而不是从键盘：
```bash
command  file.txt
```
错误重定向也是一样的，就不再赘述。
管道符其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条“管道”，数据就在其中传递：
```bash
cmd1 | cmd2 | cmd3
```
不管是设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，统一装进一个简单的 files 数组，进程通过简单的文件描述符访问相应资源，具体细节交于操作系统
### 孤儿进程
一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。
由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。
init 进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为 init，而 init 进程会循环地 `wait()` 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。
任何一个子进程(init 除外)在 `exit()` 之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在 `exit()` 之后，父进程没有来得及处理，这时用 ps 命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用 ps 命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由 init 接管。init 将会以父进程的身份对僵尸状态的子进程进行处理。
### 僵尸进程
一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 `wait()` 或 `waitpid()` 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 `wait()` 或 `waitpid()`，那幺子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。
僵死进程通过 ps 命令显示出来的状态为 Z。
unix 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号 the process ID,退出状态 the termination status of the process,运行时间t he amount of CPU time taken by the process等)。直到父进程通过 wait / waitpid 来取时才释放。 但这样就导致了问题，如果进程不调用 wait / waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。
要消灭系统中大量的僵死进程，只需要将其父进程杀死，此时所有的僵死进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵死进程所占有的资源，从而结束僵死进程。
### PID
每一个进程都有唯一的 ID（PID），是在进程表中识别进程的标识
### PPID
这个进程的父进程
父进程跟子进程:
Linux 下，进程的创建，采用的是 Fork（派生）：用一个程序创建一个新进程的方法 。比如我创建一个进程 `ping`，必须通过另外的一个进程来派生，另外的进程就叫做父进程。比如
`ping` 在控制台下运行，是 bash 派生的
fork-exec：先用 fork 生成一个子进程,然后利用 exec 函数族用新进程映像取代调用进程映像。这时候 shell 将等待 fork-exec 子进程执行完毕，并重新显示 shell 提示信息。
### EUID（effective user id）
uid 和 euid 的区别：uid 就是你 login 的时候使用的 id，而 euid 则是你当前的有效 id。比如在 setuid 的程序里面去执行的时候会暂时性将 euid 变成文件所有者的 sid,但是 sid 没变
Linux 进程在运行时有三个 UID
- Real UID 执行该进程的用户实际的UID
- Effective UID 程序实际操作时生效的UID（比如写入文件时，系统会检查这个 UID 是否有权限）
- Saved UID 在高权限用户降权后，保留的其原本 UID
通常情况下 Effective UID 和 Real UID 相等，所以普通用户不能写入只有 UID=0 号才可写的 `/etc/passwd`；有suid 的程序启动时，Effective UID 就等于二进制文件的所有者，此时 Real UID 就可能和 Effective UID 不相等了。