# 字符编码
> 注 : 笔记中拓扑图 drawio 源文件在其图片目录下
---
## 基本原理
**数据宽度**
数学上的数字可以无限大，但计算机中受硬件的制约，数据是有长度限制的。
4位宽度
- 0-F
8位宽度
- 00-FF
16位宽度
- 0000-FFFF
32位宽度
- 00000000-FFFFFFFF
**逻辑运算**
- 或(or |) 只要有一个为1就是1
  ![](../../../assets/img/Develop/计算机基础/字符编码/4.png)
- 与(and &) 两个都为1才是1
  ![](../../../assets/img/Develop/计算机基础/字符编码/5.png)
- 异或(xor ^) 不一样为1
  ![](../../../assets/img/Develop/计算机基础/字符编码/6.png)
- 非(not !) 1是0 0是1
  ![](../../../assets/img/Develop/计算机基础/字符编码/7.png)
- CPU计算2+3
  ![](../../../assets/img/Develop/计算机基础/字符编码/8.png)
**真值**
真值就是所表示数的大小,一般用10进制表示。
**机器数**
原码、补码、反码都是机器数的一种表示形式，或者说都属于机器数。
**原码**
原码的表示范围 - 127~-0, +0~+127, 共 256 个数字。
最高位为符号位,"0" 表示正,"1" 表示负,其余位表示数值的大小
```
X=+101011 , [X] 原 = 00101011    X=-101011 , [X] 原 = 10101011
```
位数不够的用 0 补全.
- 小数原码的定义
    ```
    X=+0.1011 , [X] 原 = 0.1011
    X=－0.1011 [X] 原 = 1.1011
    ```
**反码**
反码就是在原码的基础上,符号位不变其他位按位取反 (就是 0 变 1,1 变 0) 就可以了.
```
X=-101011 , [X] 原 = 10101011 ,[X] 反 = 11010100
```
**补码**
反码的基础上按照正常的加法运算加 1.
```
X=-101011 , [X] 原 = 10101011 ,[X] 反 = 11010100,[X] 补 =11010101
```
PS:0 的补码是唯一的,如果机器字长为 8 那么 [0] 补 = 00000000.
![](../../../assets/img/Develop/计算机基础/字符编码/2.png)
在计算机中，负数以其正值的补码形式表达。
**移码**
不管正负数,只要将其补码的符号位取反即可.
```
X=-101011 , [X] 原 = 10101011 ,[X] 反 = 11010100,[X] 补 = 11010101,[X] 移 = 01010101
```
**有符号数和无符号数**
在计算机中，可以区分正负的类型，称为有符类型（signed），无正负的类型（只有正值），称为无符类型。
当我们指定一个数量是无符号类型时，那么其最高位的1或0，和其它位一样，用来表示该数的大小。
当我们指定一个数量是无符号类型时，此时，最高数称为“符号位”。为1时，表示该数为负值，为0时表示为正值。
无符号数中，所有的位都用于直接表示该值的大小。有符号数中最高位用于表示正负，所以，当为正值时，该数的最大值就会变小。
无符号数
- 0~255
- 11111111 值：255
- 1* 27 + 1* 26 + 1* 25 + 1* 24 + 1* 23 + 1* 22 + 1* 21 + 1* 20
有符号数
- -128~127
- 01111111 值：127
- 1* 26 + 1* 25 + 1* 24 + 1* 23 + 1* 22 + 1* 21 + 1* 20
**大端存储和小端存储**
- https://www.ruanyifeng.com/blog/2022/06/endianness-analysis.html
大端存储与小端存储模式主要指的是数据在计算机中存储的两种字节优先顺序。
* 小端存储 : 高位字节放在高地址，低位字节存放在低地址。
* 大端存储 : 高位字节放在低地址，低位字节存放在高地址。
采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。
例如要表示 0x12345678
```
偏移地址:  0x 00   01   02   03
大端存储:     12   34   56   78
小端存储:     78   56   34   12
```
如果将一个16位的整数0x1234存放到一个短整型变量（short）中。这个短整型变量在内存中的存储在大小端模式由下表所示。
```
偏移地址:  0x 00   01
大端存储:     12   34
小端存储:     34   12
```
* 各自优点：
  * 小端存储 : 便于数据之间的类型转换，例如：long 类型转换为 int 类型时，高地址部分的数据可以直接截掉。
  * 大端存储 : 便于数据类型的符号判断，因为最低地址位数据即为符号位，可以直接判断数据的正负号。
* 用途：
  * 小端存储 : 常见于本地主机上(也有部分类型主机为大端存储)和 x86 平台。
  * 大端存储 : 常见于网络通信和 arm/移动平台上，网际协议 TCP/IP 在传输整型数据时一般使用大端存储模式表示,例如 TCP/IP 中表示端口和 IP 时，均采用的是大端存储
有的处理器系统采用了小端方式进行数据存放，如 Intel 的奔腾。有的处理器系统采用了大端方式进行数据存放，如 IBM 半导体和 Freescale 的 PowerPC 处理器。不仅对于处理器，一些外设的设计中也存在着使用大端或者小端进行数据存放的选择。
因此在一个处理器系统中，有可能存在大端和小端模式同时存在的现象。这一现象为系统的软硬件设计带来了不小的麻烦，这要求系统设计工程师，必须深入理解大端和小端模式的差别。大端与小端模式的差别体现在一个处理器的寄存器，指令集，系统总线等各个层次中。
---
## 运算符
`这里以 C 的常用运算符为例`
**算数运算**
```
+-*/    加、减、乘、除
%       取模运算    N=5,Y=N%3,Y=2
```
**逻辑运算**
```C
&&      逻辑与      A=TRUE,B=FALSE,C=A&&B,C=FALSE
||      逻辑或      A=TRUE,B=FALSE,C=A||B,C=TRUE
!       逻辑非      A=TRUE,B=!A,B=FALSE
```
**关系运算**
```C
>       大于        A=1,B=2,C=A>B,C=FALSE
=      大于等于    A=2,B=2,C=A>=B,C=TRUE
>      右移        A=0b11110000,A>>2=0b00111100
&       按位与      A=0b1010,B=0b1000,A&B=0b1000
!       按位或      A=0b1010,B=0b1000,A!B=0b1010
~       按位取反     A=0b00001111,B=~A,B=0b11110000
^       按位异或    A=0b1010,B=0b1000,A^B=0b0010
```