# Slot Machine Reloaded
Category: Reversing, 300 Points
## Description
> Remember the Slot Machine from CSA 2019?
> 
> Well, this one is a little harder...
```python
#!/usr/bin/env python3
import random
import collections
import math
from .secret import flag
PRINTABLE = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+-/:.;?@[]^_`{}"
flag_len = len(flag)
NO_COINS = "NO MORE COINS! GOODBYE."
NOT_ENOUGH_COINS = "YOU DON'T HAVE ENOUGH COINS!"
INVALID_COIN_NUMBER = "COIN NUMBER CAN'T BE NEGATIVE"
INITIAL_COINS = 10
class Slotmachine(object):
    def __init__(self):
        seed = random.SystemRandom().getrandbits(64) # Using SystemRandom is slow, use only for seed.
        self.random = random.Random(seed) # This will make sure no one messes with my seeds!
        self.slots = [list(PRINTABLE) for i in range(flag_len)]
        self.attempt_num = 0
        self.total_coins = INITIAL_COINS
        self.last_result = ""
        self.last_gamble = 0
    def get_prize(self):
        result = self.last_result
        prize = sum([x for x in collections.Counter(result).values() if x > 2])
        prize *= self.last_gamble
        self.total_coins += prize
        return prize
    def prepend_flag(self):
        for i in range(flag_len):
            self.slots[i].remove(flag[i])
            self.slots[i] = [flag[i]] + self.slots[i]
    def check_invalid_input(self, coins):
        if self.total_coins  **Warning**: The pseudo-random generators of this module should not be used for security purposes. For security or cryptographic uses, see the `secrets` module.
> 
> See also M. Matsumoto and T. Nishimura, “Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator”, ACM Transactions on Modeling and Computer Simulation Vol. 8, No. 1, January pp.3–30 1998.
We are warned not to use `random` for anything important, and informed that Python's `random` uses an algorithm called *Mersenne Twister* - A 623-dimension PRNG. A short research about [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) reveals that:
> Is not cryptographically secure (...). The reason is that observing a sufficient number of iterations (624 in the case of MT19937, since this is the size of the state vector from which future iterations are produced) allows one to predict all future iterations.
So it's possible to predict the next random numbers even if we don't have the original seed, provided that we can identify `624` DWORDs generated by the PRNG. There's even a [Python library](https://github.com/kmyk/mersenne-twister-predictor) that wraps the whole thing in a nice API. Now what?
Let's take a closer look at the slot machine. It starts by initializing the slots in a predictable way:
```python
self.slots = [list(PRINTABLE) for i in range(flag_len)]
```
Then, for each iteration, it scrambles the slots using this horrible function:
```python
    # My cat wrote this function
    def choice(self):
        rand_num = format(self.random._randbelow((1 KNLZTE]T]Z0>> import random
>>> import math
>>> PRINTABLE = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+-/:.;?@[]^_`{}"
>>> rand = random.Random(random.SystemRandom().getrandbits(64))
>>> def choice(flag_len):
...     rand_num = format(rand._randbelow((1 >> for i in range(1, 40):
...     assert(i == choice(i))
...
>>>
```
It looks like the length of the result is equal to the flag length, so we know that `flag_len == len("K^U[0P}JA89P}^_;>KNLZTE]T]Z0>> flag_len = 32
>>> ((1 >> '#0%db' % (flag_len*int(math.log(len(PRINTABLE), 2)) + 2)
'#0194b'
>>> bin(6277101735386680763835789423207666416102355444464034512895)