符号执行使用符号值作为程序的输入,将程序的执行转变为相应符号表达式的操作,通过系统地遍历程序的路径空间,实现对程序行为的精确分析。因此，符号执行不会使用输入的实际值，而是采用抽象化符号的形式来表示程序中的表达式和变量。因此，这种分析方法不是跟踪变量的值，而是用代表变量值的符号来生成算术表达式，这些表达式可以用于检查条件分支等。
另一方面，抽象解释是基于这样的思想的——程序的分析可以在一定抽象级别上进行。因此，不需要跟踪每个变量的精确值，并且语义可以替换为描述指令对变量的影响的抽象语义。例如，变量可以由它们的符号来定义。对于加法指令来说，可以通过检查操作数的符号来设置结果的符号。因此，如果操作数的符号是+，那么结果的符号也是+，但是永远不会计算变量的确切值。除符号之外，我们还可以定义其他各种抽象域。例如，可以通过一个内存位置（全局，堆和栈）上的值区间来跟踪变量的值。值集分析（VSA）就是一种基于这种表示方法的分析技术。
举例来说，monoREIL框架就是一个基于REIL IR的VSA引擎。它极大地简化了VSA算法的开发工作，使开发人员能够在自己的抽象域上执行VSA。
**分析中间表示形式**
下一个问题是如何通过CFG时实现分析算法。同样，这里也有两种方式：
过程内分析，限于当前函数的范围
过程间分析，能够进入子函数
不用说，程序内分析要比程序间分析简单得多。然而，当一个人想要检测UAF漏洞时，他必须能够一直跟踪内存块：从这些内存块的分配到释放…，所以，有时候会涉及多个函数。
这就是为什么论文[Gol10]提出首先进行过程内分析，然后将其扩展到全局的过程间分析的原因。如图2所示，对于每个函数，都创建一个相应的方框。这些方框用来总结函数的行为，连接它们的输出与输入。因此，当将分析扩展到过程间分析时，每个函数调用都会被这个函数的过程内分析的结果代替。这种方法的主要优点是函数只需要分析一次即可，即使它们被调用了很多次也是如此。此外，在进行过程内分析时，即使非常小的代码块也不会放过，因此这种方法是非常精确的。
图2：由诸多过程内分析合并而成的过程间分析
此外，在论文[Fei14]中还提出了另一种解决方案。第二种方法（如图3所示）会将被调用函数内联到调用函数中。因此，函数调用不再是一个问题。虽然该解决方案更加容易实现，但是它有一个缺点，即如果一个函数被调用两次的话，则该函数将被分析两次。因此，该方法更加耗时，对内存的需求也更大。
图3：通过将函数内联到单一函数中的过程间分析
**检测UAF漏洞**
在上文中，我们介绍了分析二进制代码语义的不同方法，以及遍历控制流图的各种方法。下面，我们开始介绍如何检测UAF模式。首先让我们UAF的定义，我们知道UAF是通过两个不同的事件来进行刻画的：
创建一个悬空指针，
访问该指针指向的内存。
为了检测这种模式，论文[Fei14]跟踪所有已经释放的内存堆区域，并且在每次使用指针时都会检查它是否指向这些已经释放的内存区。
下面，让我们拿下面的伪代码为例进行说明。注意，为了简单起见，该示例没有提供复杂的CFG。事实上，CFG的处理方法取决于所选择的分析方法及其实现…这个例子的目的，只是展示一种通过分析代码检测Use-After-Free的方法。
1\. malloc(A);
2\. malloc(B);
3\. use(A);
4\. free(A);
5\. use(A);
上面的伪代码分配了两个内存块，并且可以通过名称A和B来引用这两个内存块。然后，访问（Use(A)）了一次内存块A之后，接着释放（Free(A)）该内存块。之后，又再次访问了该内存块。
通过定义两个域（一组分配的堆元素和一组释放的堆元素），可以在每个指令处更新这些集合，并检查它访问的内存是否属于已分配的内存块集合，具体如图4所示。
图 4：通过域检测机制挖掘Use-After-Free漏洞
当内存块A被再次访问时，它已经在上一步中被注册为已释放的内存块，因此分析程序就会发出警报：检测到Use-After-Free漏洞。
在论文[Ye14]中，它提出的另一种检测目标模式的方法，但是它使用的是简单状态机。该方法的思路是，在分配内存之后，指向该内存块的指针被设置为“分配”状态，并且该状态在相应的内存块未被释放之前保持不变。当内存块被释放时，它们就会转换为“释放”状态。当处于释放状态的指针被使用的时候，就会导致“Use-After-Free”状态。然而，如果指针及其别名被删除并且不再引用内存块的话，则它们就是无害的，这时就会进入“结束”状态。这个简单的状态机如图5所示。
图5：用于检测Use-After-Free漏洞的简单状态机
此外，在论文[Gol10]中也提出一个不同的解决方案，但是它使用的工具是图论。在这篇论文中，作者会对使用指针的语句进行检查，看看它是在释放内存的语句之后还是之前。如果是之后的话，就检测出了UAF漏洞。
图6：具有潜在Use-After-Free漏洞的图
在任何情况下，只要检测到悬空指针，分析的最后阶段必须通过提取导致该指针的子图来表征UAF漏洞。这个子图必须包含所有必要的元素，来让人类手动检查，以避免真阳性。
**总结**
我们在这里介绍了几种通过基于静态分析的二进制代码Use-After-Free漏洞检测方法。同时，我们也对这种分析触发器的不同问题进行了详细的介绍，阅读之后您就不难理解为什么在检测这种bug的时候没有简单的解决方案了。
我们在开展这项工作中还发现，只有少数研究人员将其成果作为开源项目发布。Veribag团队的Josselin
Feist开发的GUEB项目就是其中之一。如果对这个课题感兴趣的话，我们鼓励你访问他的Github。
**参考文献**
**[Lee15]** Preventing Use-after-free with Dangling Pointers Nullification.
Byoungyoung Lee, Chengyu Song, Yeongjin Jang, Tielei Wang. s.l. : NDSS
Symposium 2015, 2015.
**[Cab12]** Early Detection of Dangling Pointers in Use-after-Free and Double
Free Vulnerabilities. Juan Cabaleero, Gustavo Grieco, Mark Marron, Antionia
Nappa. IMDEA Software Institute, Madrid; Spain : ISSTA 2012, 2012.
**[Ye14]** UAFChecker: Scalable Static Detection or Use-After-Free
Vulnerabilities. Jiay Ye, Chao Zhang, Xinhui Han. s.l. : CCS'14, 2014.
**[Gol10]** Gola, Vincenzo Iosso. Detecting aliased stale pointers via static
analysis. s.l. : Politecnico di Milano, 2010.
**[Fei14]** Statically detecting use after free on binary code. Josselin
Feist, Laurent Mounier, Marie-Laure Potet. s.l. : Journal of Computer Virology
and Hacking Techniques, 201
**[Bru11]** Brumley, D., Jager, I., Avgerinos, T., Schwartz, E.J.: Bap: a
binary analysis platform. In: Proceedings of the 23rd International Conference
on Computer Aided Verification. CAV’11, pp. 463–469. Springer, Heidelberg
(2011)
**[Bar11]** Bardin, S., Herrmann, P., Leroux, J., Ly, O., Tabary, R.,Vincent,
A.:The bincoa framework for binary code analysis. In: Proceedings of CAV’11,
pp. 165–170. Springer, Berlin (2011)