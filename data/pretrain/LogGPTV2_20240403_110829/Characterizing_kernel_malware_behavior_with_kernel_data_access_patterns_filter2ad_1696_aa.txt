title:Characterizing kernel malware behavior with kernel data access patterns
author:Junghwan Rhee and
Zhiqiang Lin and
Dongyan Xu
Characterizing Kernel Malware Behavior
with Kernel Data Access Patterns
Junghwan Rhee, Zhiqiang Lin, Dongyan Xu
Department of Computer Science and CERIAS, Purdue University
West Lafayette, IN 47907
{rhee,zlin,dxu}@cs.purdue.edu
ABSTRACT
Characterizing malware behavior using its control ﬂow faces
several challenges, such as obfuscations in static analysis and
the behavior variations in dynamic analysis. This paper in-
troduces a new approach to characterizing kernel malware’s
behavior by using kernel data access patterns unique to the
malware. The approach neither uses malware’s control ﬂow
consisting of temporal ordering of malware code execution,
nor the code-speciﬁc information about the malware. Thus,
the malware signature based on such data access patterns is
resilient in matching malware variants.
To evaluate the eﬀectiveness of this approach, we ﬁrst
generated the signatures of three classic rootkits using their
data access patterns, and then matched them with a group
of kernel execution instances which are benign or compro-
mised by 16 kernel rootkits. The malware signatures did not
trigger any false positives in benign kernel runs; however,
kernel runs compromised by 16 rootkits were detected due
to the data access patterns shared with the compared sig-
nature(s). We further observed similar data access patterns
in the signatures of the tested rootkits and exposed popular
rootkit attack operations by ranking common data behavior
across rootkits. Our experiments show that our approach
is eﬀective not only to detect the malware whose signature
is available, but also to determine its variants which share
kernel data access patterns.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—In-
vasive software
General Terms
Security
Keywords
Kernel Malware Analysis, Kernel Malware Signature, Kernel
Data Access Patterns
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ASIACCS’11, March 22–24, 2011, Hong Kong, China
Copyright 2011 ACM 978-1-4503-0564-8/11/03 ...$10.00.
1.
INTRODUCTION
Characterizing malware behavior is a non-trivial research
problem and there have been many approaches to address
its challenges. A large body of work uses malware’s control
ﬂow patterns, such as instruction sequences or system-call
sequences, to detect or analyze malware [2, 3, 9, 14, 15]. In
response to such approaches, malware often employs various
obfuscation techniques to confuse malware analyzers [8, 10,
25, 26]. Meanwhile, these approaches face challenges arising
from execution dynamics, such as dynamic code paths and
the impact of other system components (e.g., network la-
tency and signals), which can cause variations in the charac-
terized malware patterns. The situation is more complicated
in the kernel space because operating system (OS) kernels
have a highly dynamic workload, including interrupts, the
coordination of user processes, and the management of low
level resources (e.g., page tables).
For detection and prevention of kernel malware, there is
another collection of work called the code integrity-based ap-
proach [23, 24]. This approach allows only authorized code
for execution and considers any code outside the white list
as malicious. Therefore, this approach is eﬀective for ker-
nel rootkits that introduce new code to kernel space. How-
ever, other advanced rootkits perform the attacks by exploit-
ing only legitimate kernel code (e.g., the usage of memory
devices [20], kernel bugs, and return-oriented programming
[13]); and such attacks are not properly handled by this ap-
proach. In addition, this approach authorizes kernel driver
code based on policies trusting OS developers or venders
without systematic examination of the code. For example,
existing code integrity-based approaches [24, 23] allow the
kernel text and a list of benign kernel modules included in
the OS distributions. These policies do not provide safety
from hidden malicious code inside the authorized code. Thus
the capability of examining kernel drivers for potentially ma-
licious behavior regardless of such policies is desirable.
In this paper, we introduce an alternative approach that
characterizes kernel malware behavior by using its data ac-
cess patterns. The idea is that when kernel malware tampers
with core kernel data, there exist unique kernel data access
patterns. As such, we could take a subset of data access pat-
terns that consistently appears in multiple kernel execution
instances only when the malware is active and generate the
malware signature using the subset.1 These patterns un-
der constraints neither include malware’s temporal control
1We use the terms “a kernel execution instance” and “a ker-
nel run”, to represent an instance of the OS kernel execution,
which starts from its booting and ends at its shutdown.
Figure 1: Overview of DataGene.
ﬂow information, nor the code-speciﬁc information about
the malware. Therefore, this approach is less susceptible to
obfuscations and more eﬀective for matching malware vari-
ants.
To evaluate the eﬀectiveness of our approach, we gener-
ated the signatures of three classic rootkits and matched
them with benign kernel runs and malicious kernel runs
where the rootkits are active. This experiment did not trig-
ger any false positives in benign runs, but it did detect the
presences of the 16 kernel rootkits which have a variety of
attack goals and mechanisms. We further analyzed the data
behavior of such rootkits and found that a majority of them
exhibit shared behaviors to one another. We argue that such
common behavior can be used to eﬀectively detect malware
variants (e.g., polymorphic rootkits, diﬀerent versions, and
similar rootkits). Also, if an unknown malware shares a
data operation with any data behavior of existing rootkits,
its presence can be determined.
The contributions of this paper are as follows:
• We present a complementary approach that charac-
terizes kernel malware behavior by using its unique
data access patterns. This approach can be applied to
detect kernel rootkits that do not violate kernel code
integrity.
• This approach can automatically construct malware
signatures by using a binary-only malware program.
Malware behavior is extracted by capturing a subset of
kernel behavior that consistently appears across kernel
execution instances only when the malware is active.
• This signature uses data behavior with generalized code
information and does not involve control ﬂow of mal-
ware code execution. Hence it can detect the variants
of kernel malware by exposing similar data behavior
across kernel malware.
We have implemented a prototype called DataGene based
on our approach. DataGene is mainly designed for non-
production systems such as a honeypot for kernel malware
and a malware analysis system. For instance, when a new
proprietary driver is deployed, DataGene can inspect it for
potential hidden malicious behavior similar to the behav-
ior observed in existing kernel malware. Also for a newly
distributed kernel malware sample, if it shares any data be-
havior with existing kernel malware, DataGene can detect it
and extract its data behavior, which can be used to detect
this malware and its variants. In addition, DataGene can
detect challenging kernel rootkits that do not violate ker-
nel code integrity. Therefore, this data-oriented approach
can complement the code integrity-based approach in the
defense against kernel malware.
2. DESIGN OF DATAGENE
In this section, we present the design of DataGene that
characterizes the behavior of kernel malware and determines
its presence based on data access patterns. As DataGene
uses information regarding memory accesses, for convenience
our design employs virtual machine techniques to capture
the accesses. The overview of DataGene is presented in Fig-
ure 1, and the components of this system are as follows.
As a basic unit to represent the kernel’s data behavior,
DataGene generates a summary of the access patterns for
all kernel objects accessed in a kernel execution instance. To
identify dynamic kernel memory objects, this process takes
advantage of a kernel memory mapping process (shown as
The Kernel Memory Mapper in Figure 1). For each access on
kernel memory in the guest OS, the virtual machine monitor
(VMM) intercedes and records the information of the ker-
nel memory access, such as the accessing code, the accessed
memory type, and the accessed oﬀset (The Data Behavior
Aggregator).
To determine the malware behavior, the memory access
patterns for two kinds of kernel execution instances are gen-
erated: benign kernel runs and malicious kernel runs where
kernel malware is active. By taking the diﬀerence between
the two sets of memory access patterns, we estimate the
unique data behavior incurred from the kernel malware and
generate its signature (Data Behavior Signature).
In or-
der to detect a kernel malware, the generated signature is
compared to the memory access patterns of a tested kernel
execution instance (Checking Kernel Execution).
2.1 Data Behavior Proﬁle Approach
In this section, we present basic terminologies that repre-
sent the memory access patterns of kernel execution. A data
behavior proﬁle (Dr) is a set of memory access patterns for
kernel data structures accessed in a kernel execution instance
r. An element of this set is called a data behavior element
or simply an element (e), and it is deﬁned as a quintuple (5-
tuple): the address of the code that accesses memory (c), the
kind (read or write) of memory access (o), the kind (static
or dynamic) of the accessed memory (m), the class of the
accessed memory (i), and the accessed oﬀset(s) (f ) inside
the memory of the class i.
e = (c, o, m, i, f ) , Dr = {e|e for static and dynamic kernel objects}
c is the address of the kernel code that reads or writes ker-
nel memory. o represents the kind of memory access which
is 0 for a memory read and 1 for a memory write.
The kind of the accessed memory, m, is 0 for a dynamic
object and 1 for a static object. The class i is deﬁned diﬀer-
ently, depending on the memory kind. Static objects are
known at compile time; therefore, we are able to assign
unique numbers as their identiﬁers. A class of a static object
can represent either a static data object or a kernel function
in the kernel text. In the case of dynamic kernel objects,
there are multiple memory instances for the same data type
at runtime. Dynamic kernel objects allocated by the same
code correspond to the data instances of the speciﬁc data
type used in the allocation code. Thus, we aggregate the
access patterns of dynamic kernel objects that share the al-
location code. The address of this code (called an allocation
code site) is used as a unique class for such objects.
f is an oﬀset, or a range of oﬀsets, accessed by the code
at c. We allow a range of oﬀsets because if this object is an
Figure 2: An example of kernel code in benign and
malicious kernel runs.
array, the accessed oﬀsets can vary for the same accessing
code. Handling them as separate data behavior elements
can cause a high number of elements with slightly diﬀerent
oﬀsets for the same accessing code. To avoid this problem,
we use a threshold to convert a list of elements whose oﬀ-
sets are diﬀerent (but with the same accessing code) to an
element with an oﬀset range.
Figure 2 presents kernel code showing the examples of
data behavior elements. The rounded box in the middle of
Figure 2 shows a dynamic kernel object allocated by the
code at the address c1. This ﬁgure shows how this object
is accessed by several code sites in kernel execution. Two
ﬁelds, next_task (oﬀset 80) and prev_task (oﬀset 84), are
written by the code at c2. The code at c3 reads the pid ﬁeld
(oﬀset 120). Therefore, the data behavior elements for this
code example are as follows.
(c2, 1, 0, c1, 80) , (c2, 1, 0, c1, 84) , (c3, 0, 0, c1, 120)
These elements are the access patterns in a benign kernel
If kernel malware is active in this kernel, the access
run.
patterns can be extended due to the malware behavior. For
instance, if kernel rootkits hp and fuuld are active as shown
in the right-hand section of Figure 2, there would be ad-
ditional accesses to the next_task and the prev_task ﬁelds
by the code at c4 and c5. Consequently, the data behavior
proﬁle is extended with the additional elements as follows.
(c4, 1, 0, c1, 80) , (c4, 1, 0, c1, 84) , (c5, 1, 0, c1, 80) , (c5, 1, 0, c1, 84)
Here c4 represents the code of the hp rootkit, which is
in the form of a kernel driver. The code integrity-based
rootkit defense approach [23, 24] can determine this access
as malicious based on the fact that this driver code is not
in the authorized code list.
In contrast, the code at c5 is
part of legitimate kernel code which is indirectly exploited
to overwrite this data structure. This rootkit case does not
violate kernel code integrity; therefore, the approach based
on code integrity cannot detect this attack behavior.
In both cases, malware behavior uniquely appears only
when the malware runs. Our approach aims to capture such
unique behavior to determine the presence of malware.
2.2 Generating a Data Behavior Proﬁle
In this section, we present the process for generating a
data behavior proﬁle, which summarizes the access patterns
for all kernel objects accessed in a kernel run. Based on
this information, we generate the signature of malware and
inspect a kernel run for malicious data access patterns. A
Figure 3: Aggregating memory accesses on dynamic
kernel objects regarding their classes (allocation
sites) c1 and c2.
data behavior proﬁle is generated based on two underlying
functions. First, kernel objects should be identiﬁed with
their unique classes. Second, the access patterns on numer-
ous (e.g., tens of thousands in modern OSes) dynamic data
instances should be summarized regarding their classes. We
present two system components to provide these functions.
The Kernel Memory Mapper.
DataGene uses the
patterns of memory accesses on kernel objects and requires
a kernel memory mapping mechanism [1, 7, 19, 21, 22, 27]
to identify the targets of kernel memory accesses. Among
such approaches, LiveDM [21] provides runtime kernel mem-
ory mapping which enables the identiﬁcation of a memory
access’ target. LiveDM identiﬁes kernel objects by trans-
parently capturing the allocation and deallocation events of
kernel memory. The generated map maintains the alloca-
tion code for each dynamic object as its runtime identiﬁer.
In oﬄine static analysis, this identiﬁer can be automatically
translated into a data type by traversing kernel source code.
We implemented the kernel memory mapper by employing
LiveDM’s approach.
The Data Behavior Aggregator.
In a kernel ex-
ecution instance, there exist a varying number of dynamic
kernel data instances. To compare the access patterns of dy-
namic kernel objects in diﬀerent kernel runs, it is necessary
to aggregate the memory accesses on such objects regarding
their classes. The allocation code represents the instantia-
tion of a data type at a speciﬁc code position. By using a
memory allocation code site as the classiﬁer of dynamic ker-
nel objects, we can aggregate the access patterns of dynamic
instances of the same type and of a similar usage.
Figure 3 illustrates this aggregation process. When a dy-
namic kernel object is allocated in a guest OS kernel, the
kernel memory mapper stores its address range and the al-
location code site as the class information in the kernel mem-
ory map. We have a memory mapping layer to aggregate the
memory accesses on dynamic kernel objects regarding their
data classes. Whenever kernel code reads or writes any dy-
namic kernel object, the VMM intercedes and identiﬁes the
targeted object by using its class information from the ker-
nel memory map. If this memory access pattern is new, it
is recorded in the aggregated memory proﬁle.
2.3 Characterizing Malware Data Behavior
In this section we demonstrate how we characterize the
behavior of kernel malware based on data behavior proﬁles.
We ﬁrst present the challenges and describe how we address
them. Then, we describe the generalization process in the
malware behavior to match similar behavior across diﬀerent
kernel malware. Next, we present an algorithm to match a
malware signature with the data behavior proﬁle of a kernel
execution instance.
Challenges and Our Solutions.
DataGene character-
izes malware behavior by using the memory access patterns
uniquely observed in malware execution. To estimate such
information without requiring speciﬁc knowledge of mal-
ware, DataGene compares two kinds of kernel execution in-
stances: benign kernel runs and malicious kernel runs with
malware. This approach faces several challenges:
• Variations in the Runtime Kernel Behavior.
Generally, the diﬃculty in obtaining a complete set of
kernel execution paths is a well-known challenge for an
approach based on dynamic execution. If we focus on
the data behavior in benign execution, it is in fact a
problem because the runtime kernel behavior is highly
dynamic across diﬀerent runs. However, we focus on
the data behavior of kernel malware that consistently
appears only when the malware is active. This be-
havior is a closed set of malware activity, and we use
multiple instances of malicious kernel execution to cap-
ture the subset of malicious behavior that meets such
constraints.
• Irregular Access Patterns on Kernel Stacks.
Kernel stacks are kernel objects that have irregular ac-
cess patterns. Whenever a kernel function is called or
returns, the stack is accessed for various purposes such
as return values, function arguments, and local vari-
ables. Since the kernel control ﬂow is highly dynamic,
the set of code sites that access the stack and the ac-
cessed oﬀsets within the stack vary signiﬁcantly. Also,
the contents of kernel stacks are irregular at diﬀerent
runs. As such, a simple way to handle this problem is
to exclude stacks from our analysis. The kernel mem-
ory mapper provides the identiﬁer for kernel stacks and
we solve this problem by removing the information for
such dynamic objects from the analysis.
• Varying Oﬀsets in Arrays.
Some data structures
(e.g., arrays and buﬀers) have a range of space, a part
of which can be used at runtime. For example, the
accessed oﬀsets of a buﬀer can be diﬀerent depending
on the data contained in it. This problem is handled
by using multiple instances of kernel execution. If the
accessed oﬀset of memory is diﬀerent in each execution,
it is not used for a malware signature because it may
not be used in another run. Only the data behavior
that occurs in a consistent pattern when malware is
active becomes the candidate for the signature.
Characterizing Malicious Data Behavior.
In order
to reliably characterize the data behavior of kernel malware
in dynamic execution, we use multiple kernel runs. DM,j
is a data behavior proﬁle for a malicious kernel run j with
malware M . DB,k represents a data behavior proﬁle for a
benign kernel execution k. We apply the set operations on
n malicious kernel runs and m benign runs as follows. The
generated signature is called a data behavior signature for
the malware M and shown as SM .
SM = \
j∈[1,n]
DM,j − [
k∈[1,m]
DB,k
benign runs. The underlying observation from this formula
is that kernel malware will consistently perform malicious
operations during attacks so we estimate malware behavior
by taking the intersection of malicious runs. Such behavior
should not occur in benign runs. Therefore, we subtract the
union of benign runs from the derived malware behavior.
False positives may occur if a part of a signature is ob-
served in a new tested benign run. The cause of this prob-
lem is not unknown kernel behavior, but rather a part of
a signature not being properly pruned out in the signature
generation. By exercising a variety of workloads in multi-
ple kernel execution instances, we expect that such potential
behavior for this error can be signiﬁcantly reduced due to
such constraints.
Generalizing Malware Code Identity.
DataGene
aims at a solution that can handle rootkits regardless of their
attack vectors and can match the variants of rootkits whose
signatures are available. For example, DataGene can be used
to inspect suspicious data activity in the execution of new
signed drivers (which may include hidden malicious code),
the execution of an unknown driver (which may be malware
or its variant), or kernel execution (where legitimate kernel
code can be exploited indirectly for attacks).
In order to cover variants of malicious code, DataGene
does not use speciﬁc identiﬁcation of kernel drivers. When
we generate or test signatures, we generalize the informa-
tion speciﬁc to kernel drivers, thus allowing signatures to
be tested against any driver from new signed drivers to new
driver-based rootkits. Speciﬁcally, when the signature for a
driver-based rootkit is generated, all code sites in this ma-
licious driver are substituted by a single anonymous code
site, ε. Some rootkits allocate memory and place their code
on it, and any code site in such memory is also generalized
as ε.
In this process, we also generalize all benign kernel
modules in the same way and subtract their memory access
patterns from the candidates for the signature to collect only
the behavior unique to the malware.
We preserve the code sites in the kernel text. The mal-
ware exploiting the legitimate kernel code (e.g., the rootkits
using memory devices or return-oriented rootkits) is han-
dled by unique access patterns of legitimate code that are
not observed in benign runs. In addition, when we match a
malware signature with the data behavior proﬁle of a kernel
run, we generalize the driver code in the tested run similarly
for comparison.
Matching a Malware Signature with a Kernel Run.
The likelihood that a malware program M is present in a
tested run r is determined by deriving a set of data behavior
elements in SM which belong to the data behavior proﬁle,
Dr. This set I corresponds to the intersection of SM and
2 (i.e., I = {i|i ∈ SM ∧ i ∈ Dr}); however, this set
Dr
may not be symmetric for SM and Dr because we allow two
representations (i.e., an oﬀset and a range of oﬀsets) for the
f ﬁeld of a data behavior element. Algorithm 1 presents
how this set I is generated.
Speciﬁcally, a data behavior signature SM and a data be-
havior proﬁle Dr consist of data behavior elements for all
of the static and dynamic data structures. The CheckSig-
nature function in Algorithm 1 compares each element of
This formula represents that SM is the set of data behavior
that consistently appears in n malware runs. However, this
is also a set of unique behavior that never appears in m
2The data behavior signature (SM ) is a data behavior proﬁle
(i.e., a set of data behavior elements) because it is derived