### Criteria Matching and Default Type Assignment
When criteria are met, a default type is assigned to applications (line 1) and Intents (line 2), respectively.

### Context Definitions and Awareness
We extend the policy language to include the option to declare contexts, enabling context-aware policies. Each declared context can be either activated or deactivated by a dedicated Context Provider (refer to Section 4.2).

To enable context-aware policies, we introduce `switchBoolean` statements in our policy language. These statements map contexts to boolean values, which in turn provide dynamic policies. Listing 2 presents the definition of booleans and `switchBoolean` statements. For example, the `switchBoolean` statement in lines 4-9 defines that as soon as the `phoneBooth_con` context is active, the `phoneBooth_b` boolean must be set to `true`. When the `phoneBooth_con` context is deactivated, the `phoneBooth_b` boolean should be reset to its initial value (line 6). To map contexts to the kernel level, we introduce `kbool` definitions (line 2), which point to a boolean at the kernel level instead of adding a new boolean at the middleware level. Changes to such kernel-mapped boolean values triggered by `switchBoolean` statements will call the SELinux kernel module to update the corresponding values.

### Consensus Approach for System Policy Checks
We have adopted a consensus approach where system policy checks are mandatory and must always agree for an operation to succeed.

### Support for Multiple Stakeholders
A key requirement in the design of FlaskDroid is the protection of different stakeholders' interests. This requires that policy decisions consider the policies of all involved stakeholders. These policies can be pre-installed (i.e., system policy), delivered with apps (i.e., app developer policies), or configured by the user (e.g., User Policy App in Figure 1).

In FlaskDroid, third-party app developers may optionally ship app-specific policies with their application packages and choose to instrument their app components as Userspace Object Managers for their own data objects. FlaskDroid provides the necessary interfaces to query the Userspace Security Server for policy decisions as part of the SDK. These decisions are based on the app-specific third-party policy, which defines custom `appType` statements to label subjects (e.g., other apps) and declares app-specific object types. To register app-specific policies, the `PackageManagerService` is instrumented to extract policy files during app installation and inject them into the USSS.

A significant challenge when supporting multiple stakeholders is reconciling the various stakeholders' policies. Different strategies for reconciliation are possible [43, 35] and are generally supported by our architecture, based on namespaces and global/local type definitions. For instance, as discussed in [43], strategies include "all-allow" (i.e., all stakeholder policies must allow access), "any-allow" (i.e., only one stakeholder policy must allow access), "priority" (i.e., higher-ranked stakeholder policies override lower-ranked ones), or "consensus" (i.e., at least one stakeholder policy allows and none denies, or vice versa). However, choosing the right strategy strongly depends on the use case. For example, on a pure business smartphone without a user-private domain, the system (i.e., company) policy always has the highest priority, while on a private device, a consensus strategy may be preferable.

### Use-cases / Instantiations
In the following sections, we will demonstrate how FlaskDroid can instantiate certain privacy and security-protecting use cases. More use cases and concrete examples are provided in our technical report [11].

#### 5.1 Privacy Enhanced System Services and Content Providers
System Services and ContentProviders are integral parts of the Android application framework. Prominent Services include the `LocationManager` and `AudioServices`, while prominent ContentProviders include the contacts app and SMS/MMS app. By default, Android enforces permission checks on access to these Services and Providers.

**Problem Description:**
The default permissions are non-revocable and too coarse-grained, protecting access only to the entire Service/Provider but not to specific functions or data. Thus, the user cannot control in a fine-grained manner which sensitive data can be accessed, how, when, and by whom. Apps such as Facebook and WhatsApp have access to the entire contacts database, although only a subset of the data (i.e., email addresses, phone numbers, and names) is required for their correct functioning. On the other hand, recent attacks have demonstrated how even seemingly unrelated and unprotected data (e.g., accelerometer readings) can be misused against the user's security and privacy [53, 12].

**Solution:**
Our modified AIDL tool automatically generates policy checks for each Service interface and function in the system. We tagged selected query functions of the `AudioService`, `LocationManager`, and `SensorManager` with specific security contexts (e.g., `fineGrainedLocation_t` as `object_type`, `locationService_c` as `object_class`, and `getLastKnownLocation` as `operation`) to achieve fine-grained access control. Our policy states that calling functions of this object type is prohibited while the phone is in a security-sensitive state. Thus, retrieving accelerometer information or recording audio is not possible when, e.g., the virtual keyboard/PIN pad is in the foreground or a phone call is in progress.

In Section 4.2.3, we explained how ContentProviders (e.g., `ContactsProvider`) can act as Userspace Object Managers. As an example, users can refine the system policy to further restrict access to their contacts' data. A user can, for instance, grant the Facebook app read access to their "friends" and "family" contacts' email addresses and names, while prohibiting it from reading their postal addresses and any data of other groups such as "work".

#### 5.2 App Developer Policies (Saint)
Ongtang et al. present in [39] an access control framework called Saint, which allows app developers to ship their apps with policies that regulate access to their apps' components.

**Problem Description:**
The concrete example used to illustrate this mechanism consists of a shopping app whose developer wants to restrict the interaction with other third-party apps to only specific payment, password vault, or service apps. For instance, the developer specifies that the password vault app must be at least version 1.2 or that a personal ledger app must not hold the Internet permission.

The policy rules for the runtime enforcement of Saint on Inter-Component communication (ICC) are defined as the tuple (Source, Destination, Conditions, State). `Source` defines the source app component of the ICC and optional parameters for an Intent object (e.g., action string). `Destination` describes similarly the destination app component of the ICC. `Conditions` are optional conjunctional conditions (e.g., permissions or signature key of the destination app), and `State` describes the system state (e.g., geolocation or Bluetooth adapter state).

**Solution:**
Instantiating Saint's runtime access control on FlaskDroid is achieved by mapping Saint's parameters to the type enforcement implemented by FlaskDroid. Thus, `Source`, `Destination`, and `Conditions` are combined into security types for the subject (i.e., source app) and object (i.e., destination app or Intent object). For instance, a specific type is assigned to an app with a particular signature and permission. If this app is the source in the Saint policy, it is used as the subject type in FlaskDroid policy rules; and if it is the destination, it is used as the object type. The object class and operation are directly derived from the destination app. The system state can be directly expressed by booleans and `switchBoolean` statements in the policy and an appropriate Context Provider. Appendix A provides a concrete policy example for the instantiation of the above shopping app example.

### Evaluation and Discussion
In this section, we evaluate and discuss our architecture in terms of policy design, effectiveness, and performance overhead.

#### 6.1 Policy
To evaluate our FlaskDroid architecture, we derived a basic policy that covers the pre-installed system USOMs introduced in Section 4.2.3.

**Policy Assessment:**
For FlaskDroid, we are primarily interested in generating a basic policy to estimate the inherent access control complexity, i.e., the number of new types, classes, and rules required for the system Userspace Object Managers. This basic policy is intended to lay the foundation for developing a good policy, i.e., a policy that covers safety, completeness, and effectiveness properties. However, developing a security policy that fulfills these properties is highly complex. For instance, on SELinux-enabled systems, policies were incrementally developed and improved after the SELinux module was introduced, even inducing research on verifying these properties [24]. A similar development can be observed for the SE Android policies, which are written from scratch [48]. We envision similar research on the development and verification of FlaskDroid policies.

**Basic Policy Generation:**
To generate our basic policy, we opted for an approach that follows the concepts of TOMOYO Linux's learning phase [4] and other semi-automatic methods [42]. The underlying idea is to derive policy rules directly from observed application behavior. To generate a log of system application behavior, we leveraged FlaskDroid's audit mode, where policy checks are logged but not enforced. Under the assumption that the system contained only trusted apps during this auditing phase, this trace can be used to derive policy rules.

To achieve high coverage of app functionality and log all required access rights, we opted for testing with human user trials for the following reasons: First, automated testing has been shown to exhibit potentially very low code coverage [24], and second, Android's extremely event-driven and concurrent execution model complicates static analysis of the Android system [56, 24]. However, in the future, static analysis-based (or aided) generation of access control rules is more preferable to cover corner cases of applications' control flows.

The users' task was to thoroughly use the pre-installed system apps by performing various everyday tasks (e.g., maintaining contacts, writing SMS, browsing the Internet, or using location-based services). To analyze interaction between apps, a particular focus of the user tasks was to leverage inter-app functionality like sharing data (e.g., copying notes from a website into an SMS). For testing, the users were handed out Galaxy Nexus devices running FlaskDroid with a No-allow-rule policy. This is a manually crafted policy containing only the required subject/object types, classes, and operations for the USOMs in our architecture, but no allow rules. The devices were also pre-configured with test accounts (e.g., Email) and test data (e.g., fake contacts).

Using the logged access control checks from these trials, we derived 109 access control rules required for the correct operation of the system components (as observed during testing), which we learned to be partially operationally dependent on each other. Our pre-installed middleware policy contained 111 types and 18 classes for fine-granular access control to the major system Services and ContentProviders (e.g., `ContactsProvider`, `LocationManager`, `PackageManagerService`, or `SensorManager`). These rules (together with the above-stated type and object definitions) constitute our basic policy. Although SELinux policies cannot be directly compared to our policy, since they target desktop operating systems, the difference in policy complexity (which is in the order of several magnitudes [11]) underlines that the design of mobile operating systems facilitates a clearer mandatory access control architecture (e.g., separation of duties). This benefits easier policy design, as supported by experiences from [54, 36].

**Third-Party Policies:**
The derived basic policy can serve as the basis on top of which additional user, third-party, and use-case-specific policies can be deployed (refer to Section 5). In particular, we are currently working on extending the basic policy with types, classes, and allow rules for popular apps, such as WhatsApp or Facebook, which we further evaluated regarding user privacy protection (refer to Section 6.2). A particular challenge is to derive policies that protect the user's privacy while preserving the intended functionality of the apps. Since user privacy protection strongly depends on the subjective security objectives of the user, this approach requires further investigation on how the user can be involved in the policy configuration [58]. However, as discussed in Sections 3 and 4.2.2, multiple policies by different stakeholders with potentially conflicting security objectives require a reconciliation strategy. Devising a general strategy applicable to all use cases and satisfying all stakeholders is very difficult, but use-case-specific strategies are feasible [44, 29]. In our implementation, we opted for a consensus approach, which we successfully applied during the implementation of our use cases (refer to Section 5). We explained further strategies in Section 4.3.2.

#### 6.2 Effectiveness
We decided to evaluate the effectiveness of FlaskDroid based on empirical testing using the security models presented in Section 5, as well as a testbed of known malware retrieved from [55, 3] and synthetic attacks (refer to Table 1). Alternative approaches like static analysis [18] would benefit our evaluation but are out of scope of this paper and will be addressed separately in future work.

**Root Exploits:**
SE Android successfully mitigates the effect of the mempodroid attack. While the exploit still succeeds in elevating its process to root privileges, the process is still constrained by the underlying SE Android policy to the limited privileges granted to the root user [48].

**Malicious Apps Executed by Root:**
While SE Android constrains the file-system privileges of an app process executed with root UID, this process still inherits all Permissions at the middleware level. In FlaskDroid, the privileges of apps running with this omnipotent UID are restricted to the ones granted by the system policy to root (refer to `aid_root_t` in Section 4.2.3). During our user tests, we had to define only one allow rule for the `aid_root_t` type on the middleware layer, which is not surprising, since usually Android system or third-party apps are not executed by the root user. Thus, a malicious app gaining root privileges despite SE Android, e.g., using the mempodroid exploit [48], is in FlaskDroid restricted at both the kernel and middleware levels.

**Over-privileged and Information-Stealing Apps:**
We verified the effectiveness of FlaskDroid against over-privileged apps using a) a synthetic test app and b) known malware.