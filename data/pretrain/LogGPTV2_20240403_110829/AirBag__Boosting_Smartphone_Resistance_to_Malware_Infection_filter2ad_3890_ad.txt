 toolbox removes file
unlink("/system/bin/logcat")
close(3); close(4)
exit(0)
(a) Payload Execution
(b) /system/bin/rm Execution
Fig. 6. DKFBootKit Analysis
1) GoldDream Experiment: This malware [4] infected An-
droid systems by hiding in popular game apps. It spies on
SMS messages received by users, monitors incoming/outgoing
phone calls, and then stealthily uploads them as well as
device information to a remote server without user’s awareness.
Speciﬁcally, by registering a receiver for various system events
(e.g., when a SMS message is received), GoldDream launches a
background service without user’s knowledge to monitor and
upload private information.
With AirBag, this malware is automatically dispatched to
run inside the isolated AIR, instead of the native runtime. Also,
the spying activities are effectively blocked as various system-
wide events are by default isolated from the native runtime to
AIR. In Figure 5, we show how the incognito mode is helpful
to prevent real phone information from being leaked by a
GoldDream-infected game app com.rainbw.Fish. In this experi-
ment, we capture incoming/outgoing network trafﬁc of AirBag
with tcpdump when the malware runs. From the dumped log,
we observed the collected IMEI number and phone number
were being uploaded in an HTTP message to a remote server.
Figure 5(a) shows the recorded malware behavior of retrieving
the phone number (faked to be 0123456789 in our prototype).
Figure 5(b) highlights the collected (fake) phone number being
reported back to a remote server.
2) DKFBootKit Experiment: The previous experiment effec-
tively blocks malware’s spying behavior and prevents private
information from being leaked. In this experiment, we further
demonstrate how AirBag can prevent the ﬁrmware from being
manipulated by malware. In this case, we experimented with
DKFBootKit [14], an Android malware that infects the boot
sequence of Android (not the bootloader) and replaces a few
system utilities such as ifconfig, rm, and mount under the
system partition.
With AirBag, DKFBootKit will not be able to cause any
damage to our system. First, the native ﬁlesystem is completely
isolated from the AIR on which the DKFBootKit runs. Second,
the changes inﬂicted by DKFBootKit, while visible inside
AirBag, are automatically copy-on-written to a separate ﬁle.
With that, we can not only conveniently analyze the contam-
ination from the malware (Section III-C), but also apply “re-
store to default” feature to undo the changes. Moreover, with
proﬁling mode, we collected syscalls from AirBag including
Benchmarks
History
Download
Help
(a) A screenshot of HippoSMS-
infected video browser
(b) A pop-up alert on background
SMS behavior
Fig. 7. HippoSMS Analysis
TABLE III.
BENCHMARKS USED IN OUR EVALUATION
Benchmark Name
Version Workload Type
AnTuTu Benchmark [5]
BrowserMark [7]
NenaMark2 [11]
Neocore [12]
SunSpider [15]
2.8.3
2.0
2.3
1.9.35
0.9.1
Combination
CPU/IO
GPU
GPU
CPU/IO
conﬁned processes to monitor the detailed infection sequence.
From the infection sequence, we notice that DKFBootKit will
release at runtime a payload ﬁle named a.exe, which when
executed will copy it to /system/lib/libd1.so and further
replace a few other ﬁles, such as rm and mount (Figure
6(a)). It turns out the replacement of rm is to protect various
malware ﬁles. In Figure 6(b), we report the internal logic
of the replaced rm, which basically checks arguments and
avoids removing infected ﬁles. (For other ﬁles, the compro-
mised rm proceeds normally by invoking /system/xbin/rm or
/system/bin/toolbox.)
3) HippoSMS Experiment: In this experiment, we present
the capability of exposing stealthy malware behavior and how
users can dynamically block them. Speciﬁcally, we run an
Android malware HippoSMS [3] inside AirBag. As the name
indicates, this particular malware sends text messages to a
premium-rate number that incurs additional phone charges.
Notice that the only interface to access the telephony hardware
is the rild daemon running in the native runtime. And any
telephony-related operation inside AirBag will be tunneled
out to native runtime. The user will then have the option to
either allow or disallow it. By doing so, we can effectively
expose any background behavior that is often go unnoticed in
a normal system (without AirBag). In Figure 7(a), we show
a screenshot of a HippoSMS-infected video browser that is
involved in background SMS behavior. The background SMS-
sending behavior is intercepted and reported to user in a pop-up
window – Figure 7(b). The user then has the option to permit
or deny it.
B. Performance Impact
To evaluate AirBag’s impact on performance, we have
performed benchmark-based measurements on three supported
9
Normalized Nexus One Results (%)
Normalized Nexus 7 Results (%)
Normalized Galaxy S3 Results (%)
 100
 80
 60
 40
 20
 0
Neocore
SunSpider
BrowserMark
Baseline
Busy−NA
Busy−Idle
Idle−Busy
NenaMark2
SunSpider
BrowserMark
NenaMark2
SunSpider
BrowserMark
Fig. 8. Performance Measurement of AirBag on Google Nexus One, Nexus 7, and Samsung Galaxy S III
 100
 80
 60
 40
 20
 0
Normalized Nexus 7 Results (%)
Baseline
Busy−NA
Busy−Idle
Idle−Busy
RAM
cpuint
cpufp
2D
3D
Fig. 9. AnTuTu Measurement Results
devices – with and without AirBag. Table III shows the list of
benchmarks used in our measurement.
These benchmark programs are designed to measure var-
ious aspects of system performance. For each benchmark
program run, we have measured the performance in four
different settings: (1) “Baseline” means the results obtained
from a stock mobile device without AirBag support; (2) “Busy-
NA” means the results from a mobile device with our OS kernel
extension for AirBag but without activating the AirBag; (3)
“Busy-Idle” means results from an AirBag-enhanced system
by running the benchmark program in the native runtime
while keeping AirBag idle; and (4) “Idle-Busy” means results
from an AirBag-enhanced system by running the benchmark
program inside the AirBag while keeping the native runtime
idle. All
the performance results are normalized with the
“Baseline” system to expose possible overhead introduced
by AirBag. Figure 8 summarizes the measurement results.
Overall, our benchmark experiments show that AirBag incurs
minimal impact on system performance (with around 2.5%) in
both GPU-intensive workloads (Neocore and NenaMark2) and
CPU/IO-intensive workloads (SunSpider and BrowserMark).
We also run AnTuTu [5], a comprehensive benchmark that
reported similar small performance overhead (with around
2% – Figure 9). We point out that our experiments so far
are conducted by entering the default incognito mode. When
we turn the proﬁling mode on, the evaluation with Neocore
benchmark indicates that our system introduces additional 10%
overhead. We are not concerned as the proﬁling mode is only
turned on when performing a forensics-style investigation of
an untrusted app.
C. Power Consumption and Memory Usage
Beside the performance overhead, we also evaluate the
impact of AirBag on battery use. With two concurrent names-
paces, our system likely incurs additional battery drains. In
our measurement, we perform two sets of experiments. In the
ﬁrst set, we start from a fully-charged Nexus 7 device, wait
for 24 hours without running any workload, and then check
its battery level. The stock system reports 91%, and AirBag-
enhanced system shows 89%, indicating 2% more battery use.
In the second set, we also start from a fully-charged Nexus
7 device, wait for 24 hours while keeping playing an audio
ﬁle, and then check its battery level. The stock system reports
66%, and AirBag-enhanced system shows 63%, indicating 3%
more battery use.
Finally, we also measure the memory footprint of AirBag.
Speciﬁcally, we examine the percentage of in-use memory
(by reading /proc/meminfo) of the Nexus 7 by repeating the
previous two sets of experiments. Instead of waiting for 24
hours, we collect our measurement results in 4 hours. The
results from the ﬁrst set of experiments indicate that our system
increases the percentage of in-use memory from 59.31% to
60.87%, an addition of 1.56%. In the second set of experiments
(with repeated playing of an audio ﬁle), the percentage of
in-use memory is increased from 60.25% to 63.70%. The
additional memory consumption is due to the reserved memory
blocks in OS kernel (e.g., for second framebuffer).
V. DISCUSSION
In this section, we re-visit our system design and imple-
mentation for possible improvements. First, the current usage
model of AirBag is to isolate untrusted apps when they are
being installed. While it achieves our design goals, it can
still be improved with a unique capability to dynamically
migrate apps between native and AirBag-conﬁned runtime
environments. For example, users may want to try the new
features of newly released apps in the AirBag without affecting
the native environment but “move” it to the native runtime
environment when the app is considered safe and stable. On the
other hand, when an app is reported to have malicious behavior
(e.g., sending text messages in the background), users can still
use the app by limiting its capabilities within the AirBag.
Obviously, one solution will be simply uninstalling the app in
one runtime and then re-install it in another runtime. However,
it will
internal states accumulated from previous
installation. A better solution might lively migrate it from one
to another. This is possible as both runtime environments share
the same trusted OS kernel, though in different namespaces.
Possible challenges however may include handling dependent
libraries that may be inconsistent in different runtimes as well
as other currently interacting apps in the previous namespace.
lose all
Second, to conﬁne untrusted app execution, our prototype
disallows conﬁned apps to communicate with other legitimate
apps and service daemons running on the native runtime and
vice versa. As a result, various system events are isolated
at the AirBag boundary. In other words, when there is an
incoming SMS or phone call on the native runtime, such an
event will not be propagated to the AIR runtime, which will
affect certain functionality of untrusted apps. Also, automatic
updates on AirBag-conﬁned apps may also break because of
10
the current AirBag conﬁnement. While an intuitive solution is
to allow these events to cross the AirBag boundary, it may
however break the isolation AirBag is designed to enforce.
From another perspective, we are motivated to explore a
hybrid approach, which might be ideal in selectively white-
listing certain events to pass through (so that we can support
legitimate feature needs such as automatic updates) without
unnecessarily compromising AirBag isolation. On the other
hand, if AirBag is conﬁgured to deny all permissions, our
system could be considered to be replaced by a customized
Android system. However, with our system, users can still run
apps normally in the native runtime on the same mobile device
which cannot be achieved by customized Android systems.
Third, our current prototype is still limited in supporting
one single AirBag instance and multiple untrusted apps will
need to run within the same instance. This leads to problems
when all apps are installed as untrusted. In particular, AirBag
does not provide inter-app isolation within itself. Naturally,
we can improve the scalability of AirBag by dynamically
provisioning multiple AirBag instances with one for each
untrusted app. It does raise challenging requirements for
more efﬁcient and lightweight AIRs. Note that our AirBag
ﬁlesystem already made use of copy-on-write to keep all
the updates in a separate data ﬁle, which should be scalable
to multiple AirBag instances. However, context-aware device
virtualization requires additional memory to be reserved (e.g.,
for smooth framebuffer support – Section III-B). It remains an
interesting challenge and we plan to explore possible solutions
in our future work (e.g., by leveraging hardware virtualization
support in latest ARM processors).
Fourth, as an OS-level kernel extension, our approach
requires updating the smartphone OS image for the enhanced
protection against mobile malware infection. While this may
be an obstacle for its deployment, we argue that our system
does not require deep modiﬁcations in smartphone OS kernel.
In fact, our kernel patch has less than 2K lines of source code
and most of them are related to generic Linux drivers, not tied
to speciﬁc hardware devices in different smartphone models.
Furthermore, we can improve the portability of our system by
implementing a standalone loadable kernel module that can be
conveniently downloaded and installed.
Fifth, for simplicity, our current prototype does not provide
the same runtime environment as the original one. Because
of that, a malicious app can possibly detect the existence of
AirBag and avoid launching their malicious behaviors. In fact,
as an OS-level virtualization solution, our system shares with
other virtualization approaches [43], [19], [35], [40], [49] by
possibly exposing virtualization-speciﬁc artifacts or footprints.
Note that with the capability of arbitrarily customizing the
isolated runtime environment (AIR), we are able to further
improve the ﬁdelity of AirBag runtime and make it harder to
be ﬁngerprinted. However, this situation could lead to another
round of “arms race.” From another perspective, if a mobile
malware attempts to avoid launching its attacks in a virtualized
environment, our system does achieve the intended purpose by
resisting or deterring its infection.
Last but not least, with a decoupled app isolation runtime
to transparently support untrusted apps, AirBag opens up new
opportunities that are not previously possible. For example,
our current proﬁling mode basically collects logcat output
as well as various syscalls from AirBag. However, it does
not need to be limited in basic log collection. For example,
recent development on virtual machine introspection [35],
[40], [29], [36], [56] can be applied in AirBag to achieve
better introspection and monitoring capabilities. Moreover, it
also provides better avenues to integrate with current mobile
anti-virus software so that they can reliably monitor runtime
behavior without being limited in only statically scanning
untrusted apps.
VI. RELATED WORK
In this section, we categorize related work into different
research areas and compare our system with them.
Server-side protection
The ﬁrst category of related work
include systems that are designed to improve the walled garden
model in detecting and pruning questionable apps (including
malicious ones) from centralized mobile marketplaces. For
example, Google introduces the bouncer service in February,
2012. Besides smartphone vendors, researchers also endeavor
to develop various systems to expose potential security risks
from untrusted apps. PiOS [30] statically analyzes mobile
apps to detect possible leaks of sensitive information; Enck
et al. [32] studies free apps from the ofﬁcial Google Play
with the goal of understanding broader security characteristics
of existing apps. Our system is different by proposing a
complementary client-side solution to protect mobile devices
from being infected by mobile malware.
Client-side protection
The second category aims to
develop mitigation solutions on mobile devices. For example,
mobile anti-malware software scan the apps on the devices
based on known malware signatures, which limit their capabil-
ity in detecting zero-day malware. MoCFI [27] provides a CFI
enforcement framework to prohibit runtime and control-ﬂow
attacks for Apple iOS. TaintDroid [31] extends the Android
framework to monitor the information ﬂow of privacy-sensitive