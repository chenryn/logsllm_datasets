use cases where on-device instrumentation may not be a concern, a TZ-M pro-
tected shadow stack could be utilized with binary patching. This approach would
have the advantage of not requiring Branch Monitor logic in the supervisor call
handler.
7 Related Work
Code-reuse attack countermeasures have been a focal topic of research for the
past decade. The most widely used mitigation technique against this class of
attack is Address Space Layout Randomization (ASLR) [13,34]). ASLR relies
on shuﬄing the executable (and the stack and heap) base address around in
virtual memory, thus requiring an attacker to successfully guess the location of
the target code (or data). This makes ASLR impractical for constrained devices
that lack MMUs and where memory is a scarce resource.
Dang et al. [14] conduct a comprehensive evaluation of shadow stacks schemes
in the face of diﬀerent adversarial models. Dang et al.’s parallel shadow stack [14]
and many traditional shadow stacks [24,25,38] are based on unprotected shadow
stacks, e.g., their integrity can be compromised if the shadow stack location is
known as they are located in the same address space as the vulnerable appli-
cation. Shadow stacks protected by canary values [20,42] can withstand attacks
that are limited to sequantial writes, but not arbitrary writes to speciﬁc memory
addresses. Dang et al. identify only two schemes that operate under an equivalent
adversary model as CaRE, in particular with regard to the ability to withstand
disclosure of the shadow stacks location; Chiueh and Hsus Read-Only RAD [10]
and Abadi et al.’s CFI scheme [2]. Read-Only RAD incurs a substantial overhead
in the order of 1900%–4400% according to benchmarks by the authors. Abadi
et al.’s protected shadow stack achieves a modest overhead between 5%–55%
(21% on average). However, it makes use of x86 memory segments, a hardware
feature not available on low-end MCUs. In contrast, CaRE provides equiva-
lent security guarantees without requiring hardware features unique to high-end
general purpose processors and compared to previous work on software-only
protected shadow stacks, CaRE performs better.
In addition, we consider an even stronger adversary who can exploit interrupt
handling to undermine CFI protection; this has been largely ignored in previous
CFI works. Prior work, most notably ROPDefender [17] and PICFI [39] support
software exception handling, particularly C++ exceptions. To the best of our
knowledge, CaRE is the ﬁrst scheme to protect hardware interrupts initiated
by the CPU, a necessity for CFI in bare-metal programs. We make no claim
regarding software exceptions, as our system model assumes C programs.
280
T. Nyman et al.
The prevalence of ROP and JOP exploitation techniques in runtime attacks
on modern PC platforms has also prompted processor manufacturers to pro-
vide hardware support for CFI enforcement. In June 2016, Intel announced
its Control-ﬂow Enforcement Technology [30] that adds support for shadow
call stacks and indirect call validation to the x86/x84 instruction set archi-
tecture. Similarly the ARMv8.3-A architecture provides Pointer Authentication
(PAC) [43] instructions for ARM application processors that can be leveraged in
the implementation of memory corruption countermeasures such as stack pro-
tection and CFI. Countermeasures suitable for resource-constrained embedded
devices, however, have received far less attention to date. Kumar et al. [33] pro-
pose a software-hardware co-design for the AVR family of microcontrollers that
places control-ﬂow data to a separate safe-stack in protected memory. Francillon
et al. [22] propose a similar hardware architecture in which the safe-stack is
accessible only to return and call instructions. AVRAND by Pastrana et al. [41]
constitutes a software-based defense against code reuse attacks for AVR devices.
HAFIX [16] is a hardware-based CFI solution for the Intel Siskiyou Peak and
SPARC embedded system architectures. SOFIA [11] is a hardware-based security
architecture for the LEON3 soft microprocessor that provides software integrity
protection and CFI through instruction set randomization.
8 Conclusion
Security is paramount for the safe and reliable operation of connected IoT
devices. It is only a matter of time before the attacks against the IoT device
evolve from very simple attacks such as targeting default passwords to advanced
exploitation techniques such as code-reuse attacks. The introduction of light-
weight trust anchors (such as TrustZone-M) to constrained IoT devices will
enable the deployment of more advanced security mechanisms on these devices.
We show why and how a well understood CFI technique needs to be adapted
to low-end IoT devices in order to improve their resilience against advanced
attacks. Leveraging hardware assisted security is an important enabler in CaRE,
but it also meets other requirements important for practical deployment on small
devices, such as interrupt-awareness, layout-preserving instrumentation and the
possibility for on-device instrumentation. For small, interrupt-driven devices, the
ability to ensure CFI in both interruptible code, as well for the code executing
in interrupt contexts is essential.
Acknowledgments. This work was supported by the German Science Foundation
(project S2, CRC 1119 CROSSING), Tekes—the Finnish Funding Agency for Innova-
tion (CloSer project), and the Intel Collaborative Research Institute for Secure Com-
puting (ICRI-SC).
References
1. ARM compiler version 6.4 software development guide. http://infocenter.arm.com/
help/topic/com.arm.doc.dui0773e (2015)
CFI CaRE: Hardware-Supported Call and Return Enforcement
281
2. Abadi, M., Budiu, M., Erlingsson, U., Ligatti, J.: Control-ﬂow integrity principles,
implementations, and applications. ACM Trans. Inf. Syst. Secur. 13(1), 4:1–4:40
(2009). http://doi.acm.org/10.1145/1609956.1609960
3. ARM Ltd.: Procedure Call Standard for the ARM Architecture (2009). http://
infocenter.arm.com/help/topic/com.arm.doc.ihi0042d
4. ARM Ltd.: ARMv8-M Architecture Reference Manual.(2016). http://infocenter.
arm.com/help/topic/com.arm.doc.ddi0553a.b
5. Brown, N.: Control-ﬂow Integrity for Real-time Embedded Systems. Master’s the-
sis, Worcester Polytechnic Institute, Worcester, MA, USA (2017)
6. Buchanan, E., Roemer, R., Shacham, H., Savage, S.: When good instructions go
bad: generalizing return-oriented programming to risc. In: Proceedings of the 15th
ACM Conference on Computer and Communications Security. CCS 2008, pp. 27–
38. ACM, New York (2008). http://doi.acm.org/10.1145/1455770.1455776
7. Carlini, N., Barresi, A., Payer, M., Wagner, D., Gross, T.R.: Control-ﬂow bending:
on the eﬀectiveness of control-ﬂow integrity. In: Proceedings of the 24th USENIX
Conference on Security Symposium. SEC 2015, pp. 161–176. USENIX Association,
Berkeley (2015). http://dl.acm.org/citation.cfm?id=2831143.2831154
8. Checkoway, S., Davi, L., Dmitrienko, A., Sadeghi, A.R., Shacham, H., Winandy,
M.: Return-oriented programming without returns. In: Proceedings of the 17th
ACM Conference on Computer and Communications Security. CCS 2010, pp. 559–
572. ACM, New York (2010). http://doi.acm.org/10.1145/1866307.1866370
9. Checkoway, S., Feldman, A.J., Kantor, B., Halderman, J.A., Felten, E.W.,
Shacham, H.: Can dres provide long-lasting security? the case of return-oriented
programming and the AVC advantage. In: Proceedings of the 2009 Conference on
Electronic Voting Technology/Workshop on Trustworthy Elections. EVT/WOTE
2009, p. 6. USENIX Association, Berkeley (2009). http://dl.acm.org/citation.cfm?
id=1855491.1855497
10. Chiueh, T.C., Hsu, F.H.: Rad: a compile-time solution to buﬀer overﬂow attacks.
In: 21st International Conference on Distributed Computing Systems, pp. 409–417,
April 2001
11. de Clercq, R., Keulenaer, R.D., Coppens, B., Yang, B., Maene, P., d. Bosschere,
K., Preneel, B., De Sutter, B., Verbauwhede, I.: Soﬁa: software and control ﬂow
integrity architecture. In: 2016 Design, Automation Test in Europe Conference
Exhibition (DATE), pp. 1172–1177, March 2016
12. de Clercq, R., Piessens, F., Schellekens, D., Verbauwhede, I.: Secure interrupts
on low-end microcontrollers. In: 2014 IEEE 25th International Conference on
Application-Speciﬁc Systems, Architectures and Processors, pp. 147–152, June
2014
13. Cohen, F.B.: Operating system protection through program evolution. Comput.
Secur. 12(6), 565–584 (1993). http://dx.doi.org/10.1016/0167-4048(93)90054–9
14. Dang, T.H., Maniatis, P., Wagner, D.: The performance cost of shadow stacks
and stack canaries. In: Proceedings of the 10th ACM Symposium on Information,
Computer and Communications Security. ASIA CCS 2015, pp. 555–566. ACM,
New York (2015). http://doi.acm.org/10.1145/2714576.2714635
15. Davi, L., Dmitrienko, A., Egele, M., Fischer, T., Holz, T., Hund, R., N¨urnberger,
S., Sadeghi, A.R.: MoCFI: a framework to mitigate control-ﬂow attacks on smart-
phones. In: 19th Annual Network and Distributed System Security Symposium.
NDSS 2012, February 5–8, San Diego, USA (2012). http://www.internetsociety.
org/mocﬁ-framework-mitigate-control-ﬂow-attacks-smartphones
282
T. Nyman et al.
16. Davi, L., Hanreich, M., Paul, D., Sadeghi, A.R., Koeberl, P., Sullivan, D., Arias,
O., Jin, Y.: Haﬁx: hardware-assisted ﬂow integrity extension. In: Proceedings of
the 52Nd Annual Design Automation Conference. DAC 2015, pp. 74:1–74:6. ACM,
New York (2015). http://doi.acm.org/10.1145/2744769.2744847
17. Davi, L., Sadeghi, A.R., Winandy, M.: Ropdefender: a detection tool to defend
against return-oriented programming attacks. In: Proceedings of the 6th ACM
Symposium on Information, Computer and Communications Security. ASIACCS
2011, pp. 40–51. ACM, New York (2011). http://doi.acm.org/10.1145/1966913.
1966920
18. Eldefrawy, K., Francillon, A., Perito, D., Tsudik, G.: SMART: secure and mini-
mal architecture for (Establishing a Dynamic) root of trust. In: 19th Annual Net-
work and Distributed System Security Symposium. NDSS 2012, February 5–8, San
Diego, USA, February 2012. http://www.eurecom.fr/publication/3536
19. Ericssson: Ericsson Mobility Report (2015). http://www.ericsson.com/res/docs/
2015/mobility-report/ericsson-mobility-report-nov-2015.pdf
20. Erlingsson, U., Abadi, M., Vrable, M., Budiu, M., Necula, G.C.: Xﬁ: software
guards for system address spaces. In: Proceedings of the 7th Symposium on Oper-
ating Systems Design and Implementation. OSDI 2006, pp. 75–88. USENIX Asso-
ciation, Berkeley (2006). http://dl.acm.org/citation.cfm?id=1298455.1298463
21. Francillon, A., Castelluccia, C.: Code injection attacks on harvard-architecture
devices. In: Proceedings of the 15th ACM Conference on Computer and Commu-
nications Security. CCS 2008, pp. 15–26. ACM, New York (2008). http://doi.acm.
org/10.1145/1455770.1455775
22. Francillon, A., Perito, D., Castelluccia, C.: Defending embedded systems against
control ﬂow attacks. In: Proceedings of the First ACM Workshop on Secure Exe-
cution of Untrusted Code. SecuCode 2009, pp. 19–26. ACM, New York (2009).
http://doi.acm.org/10.1145/1655077.1655083
23. Gartner: Gartner Says Managing Identities and Access Will Be Critical to the
Success of the Internet of Things (2015). http://www.gartner.com/newsroom/id/
2985717
24. Giﬃn, J.T., Jha, S., Miller, B.P.: Detecting manipulated remote call streams. In:
Proceedings of the 11th USENIX Security Symposium, pp. 61–79. USENIX Asso-
ciation, Berkeley (2002). http://dl.acm.org/citation.cfm?id=647253.720282
25. Giﬃn, J.T., Jha, S., Miller, B.P.: Eﬃcient context-sensitive intrusion detection. In:
Proceedings of the Network and Distributed System Security Symposium. NDSS
2004 (2004)
26. Eclipse IoT Working Group, IEEE IoT, AGILE IoT and IoT Council: IoT
Developer Survey 2017 (2017). https://ianskerrett.wordpress.com/2017/04/19/
iot-developer-trends-2017-edition/
27. Habibi, J., Panicker, A., Gupta, A., Bertino, E.: DisARM: mitigating buﬀer
overﬂow attacks on embedded devices. In: Qiu, M., Xu, S., Yung, M., Zhang,
H. (eds.) NSS 2015. LNCS, vol. 9408. Springer, Cham (2015). doi:10.1007/
978-3-319-25645-0 8
28. Hewlett-Packard: Data Execution Prevention (2006). http://h10032.www1.hp.
com/ctg/Manual/c00387685.pdf
29. Hu, H., Shinde, S., Adrian, S., Chua, Z.L., Saxena, P., Liang, Z.: Data-oriented
programming: on the expressiveness of non-control data attacks. In: IEEE Sympo-
sium on Security and Privacy, SP 2016, San Jose, CA, USA, May 22–26, 2016, pp.
969–986 (2016). http://doi.ieeecomputersociety.org/10.1109/SP.2016.62
CFI CaRE: Hardware-Supported Call and Return Enforcement
283
30. Intel: Control-ﬂow Enforcement Technology Preview (2016). https://software.intel.
com/sites/default/ﬁles/managed/4d/2a/control-ﬂow-enforcement-technology-
preview.pdf
31. Koeberl, P., Schulz, S., Sadeghi, A.R., Varadharajan, V.: TrustLite: a security
architecture for tiny embedded devices. In: Proceedings of the Ninth European
Conference on Computer Systems. EuroSys 2014, pp. 10:1–10:14. ACM, New York
(2014). http://doi.acm.org/10.1145/2592798.2592824
32. Kornau, T.: Return Oriented Programming for the ARM Architecture. Mas-
ter’s thesis, Ruhr-University Bochum (2009). http://static.googleusercontent.com/
media/www.zynamics.com/en//downloads/kornau-tim-diplomarbeit-rop.pdf
33. Kumar, R., Singhania, A., Castner, A., Kohler, E., Srivastava, M.: A system for
coarse grained memory protection in tiny embedded processors. In: Proceedings of
the 44th Annual Design Automation Conference. DAC 2007, pp. 218–223. ACM,
New York (2007). http://doi.acm.org/10.1145/1278480.1278534
34. Larsen, P., Homescu, A., Brunthaler, S., Franz, M.: Sok: automated software diver-
sity. In: Proceedings of the 2014 IEEE Symposium on Security and Privacy, SP
2014, pp. 276–291. IEEE Computer Society, Washington, DC (2014). http://dx.
doi.org/10.1109/SP.2014.25
35. Le, L.: ARM Exploitation ROPMap. BlackHat USA (2011)
36. Lian, W., Shacham, H., Savage, S.: Too LeJIT to quit: extending JIT spraying to
ARM. In: Kirda, E. (ed.) Proceedings of NDSS 2015. Internet Society, February
2015
37. Microsoft: Enhanced Mitigation Experience Toolkit
(2016). https://www.
microsoft.com/emet
38. Nebenzahl, D., Sagiv, M., Wool, A.: Install-time vaccination of windows executa-
bles to defend against stack smashing attacks. IEEE Trans. Dependable Secur.
Comput. 3(1), 78–90 (2006). http://dx.doi.org/10.1109/TDSC.2006.14
39. Niu, B., Tan, G.: Per-input control-ﬂow integrity. In: Proceedings of the 22nd ACM
SIGSAC Conference on Computer and Communications Security. CCS 2015, pp.
914–926. ACM, New York (2015). http://doi.acm.org/10.1145/2810103.2813644
40. Noorman, J., Agten, P., Daniels, W., Strackx, R., Van Herrewege, A., Huygens, C.,
Preneel, B., Verbauwhede, I., Piessens, F.: Sancus: low-cost trustworthy extensible
networked devices with a zero-software trusted computing base. In: Proceedings
of the 22nd USENIX Conference on Security. SEC 2013, pp. 479–494. USENIX
Association, Berkeley (2013). http://dl.acm.org/citation.cfm?id=2534766.2534808
41. Pastrana, S., Tapiador, J., Suarez-Tangil, G., Peris-L´opez, P.: AVRAND: a
software-based defense against code reuse attacks for AVR embedded devices. In:
Caballero, J., Zurutuza, U., Rodr´ıguez, R.J. (eds.) DIMVA 2016. LNCS, vol. 9721,
pp. 58–77. Springer, Cham (2016). doi:10.1007/978-3-319-40667-1 4
42. Prasad, M., Chiueh, T.: A binary rewriting defense against stack based overﬂow
attacks. In: Proceedings of the USENIX Annual Technical Conference, pp. 211–224
(2003)
43. Qualcomm Technologies Inc: Pointer Authentication on ARMv8.3.
https://www.qualcomm.com/media/documents/ﬁles/whitepaper-pointer-
authentication-on-armv8-3.pdf
(2017).
44. Shacham, H.: The geometry of innocent ﬂesh on the bone: return-into-libc with-
out function calls (on the x86). In: Proceedings of the 14th ACM Conference on
Computer and Communications Security. CCS 2007, pp. 552–561. ACM, New York
(2007). http://doi.acm.org/10.1145/1315245.1315313
45. Designer, S.: lpr LIBC RETURN exploit (1997). http://insecure.org/sploits/linux.
libc.return.lpr.sploit.html
284
T. Nyman et al.
46. Szekeres, L., Payer, M., Wei, T., Song, D.: Sok: eternal war in memory. In: Proceed-
ings of the 2013 IEEE Symposium on Security and Privacy. SP 2013, pp. 48–62.
IEEE Computer Society, Washington, DC (2013). http://dx.doi.org/10.1109/SP.
2013.13
47. Weicker, R.P.: Dhrystone: a synthetic systems programming benchmark. Commun.
ACM 27(10), 1013–1030 (1984). http://doi.acm.org/10.1145/358274.358283
48. Yiu, J.: ARMv8-M architecture technical overview (2015). https://community.arm.
com/docs/DOC-10896