for the reduction to be more eﬃcient. Once C is computed,
the reduction function as described in Section 4 (with some
optimizations tailored towards ProVerif) is applied to T , i.e.,
T + is computed. Now, T + together with the rest of the
original input is passed on to ProVerif. This tool then does
the rest of the work, i.e., it checks the goals for T +. This
is possible since, due the reduction, the XOR operator in
T + can now be considered to be an operator without any
algebraic properties.
6.2 Experiments
We applied our method to a set of (⊕-linear) protocols.
The results, obtained by running our implementation on a
2,4 Ghz Intel CoreTM 2 Duo E6700 processor with 2GB
RAM, are depicted in Figure 3, where we list both the time
of the reduction and the time ProVerif needed for the anal-
ysis of the output of the reduction. We note that except for
certain versions of the CCA protocol, the other protocols
listed in Figure 3 are out of the scope of the implementa-
tion in [14], the only other implementation that we know
of for cryptographic protocol analysis w.r.t. an unbounded
number of sessions that takes XOR into account. As men-
tioned in the introduction, the method in [14] is especially
tailored to the CCA protocol. It can only deal with sym-
metric encryption and the XOR operator, but, for example,
cannot deal with protocols that use public-key encryption
or pairing. Let us discuss the protocols and settings that we
analyzed in more detail.
protocol
NSL⊕
NSL⊕-ﬁx
NSL⊕-auth-A
NSL⊕-auth-A-ﬁx
NSL⊕-auth-B
SK3
RA
RA-ﬁx
CCA-0
CCA-1A
CCA-1B
CCA-2B
CCA-2C
CCA-2E
correct
no
yes
no
yes
yes
yes
no
yes
no
yes
yes
yes
yes
yes
reduction time ProVerif time
0.006s
0.09s
0.16s
0.02s
0.5s
0.3s
0.17s
0.27s
109s
0.7s
1.3s
7.1s
58.0s
1.42s
0.02s
0.04s
0.03s
0.03s
0.04s
0.05s
0.05s
0.05s
0.15s
0.06s
0.07s
0.14s
0.15s
0.07s
Figure 3: Experimental Results.
By NSL⊕ we denote our running example. Since there is
an attack on this protocol, we also propose a ﬁx NSL⊕-ﬁx
in which the message {|(cid:104)M, N ⊕ B(cid:105)|}pub(skA) is replaced by
{|(cid:104)M, h((cid:104)N, M(cid:105)) ⊕ B(cid:105)|}pub(skA) for a hash function h(·). We
analyze both authentication and secrecy properties for these
(⊕-linear) protocols.
The (⊕-linear) protocol SK3 [18] is a key distribution pro-
tocol for smart cards, which uses the XOR operator. RA
denotes an (⊕-linear) group protocol for key distribution [6].
Since there is a known attack on this protocol, we proposed
a ﬁx: a message kA,B⊕h((cid:104)key(A), N(cid:105)) sent by the key distri-
bution server to A is replaced by kA,B ⊕ h((cid:104)key(A),(cid:104)N, B(cid:105)(cid:105)).
CCA stands for Common Cryptographic Architecture
(CCA) API [1] as implemented on the hardware security
module IBM 4758 (an IBM cryptographic coprocessor). The
CCA API is used in ATMs and mainframe computers of
many banks to carry out PIN veriﬁcation requests. It ac-
cepts a set of commands, which can be seen as receive-send-
actions, and hence, as cryptographic protocols. The only key
stored in the security module is the master key km. All other
keys are kept outside of the module in the form {k}km⊕type ,
where type ∈ {data, imp, exp, pin} denotes the type of the
key, modeled as a constant. The commands of the CCA API
include the following: Commands for encrypting/decrypting
data using data keys. Commands to export/import a key
to/from another security module. This is done by encrypt-
ing/decrypting the key by a key-encryption-key. The prob-
lem is to make the same key-encryption-key available in dif-
ferent security modules. This is done by commands that
are based on some kind of secret sharing scheme and allow
individuals to import their share of the key-encryption-key
into a security module (key-part-import).
These commands can conveniently be modeled as Horn
clauses. However, some of the Horn clauses which model the
commands in the key-part-import process are not ⊕-linear.
Fortunately, one can apply a standard unfolding technique
for Horn clauses together with straightforward simpliﬁca-
tions in order to obtain an equivalent Horn theory with only
⊕-linear Horn clauses.
There are several known attacks on the CCA API, which
concern the key-part-import process. One attack is by Bond
[5]. As a result of this attack the intruder is able to obtain
PINs for each account number by performing data encryp-
tion on the security module. A stronger attack was found
by IBM and is presented in [8] where the intruder can ob-
tain a PIN derivation key, and hence, can obtain PINs even
without interacting with the security module. However, the
IBM attack depends on key conjuring [14], and hence, is
harder to carry out. Using our implementation (together
with ProVerif) and the conﬁguration denoted by CCA-0 in
Figure 3, we found a new attack which achieves the same as
the IBM attack, but is more eﬃcient as it does not depend
on key conjuring. In response to the attacks reported in [5],
IBM proposed two recommendations.
Recommendation 1. As mentioned, the attacks exploit
problems in the key-part-import process. To prevent these
problems, one IBM recommendation is to replace this part
by a public-key setting. However, as shown in [14], further
access control mechanisms are needed, which essentially re-
strict the kind of commands certain roles may perform. Two
cases, which correspond to two diﬀerent roles, are consid-
ered, and are denoted CCA-1A and CCA-1B in Figure 3. We
note that the Horn theories that correspond to these cases
are ⊕-linear, and hence, our tool can be applied directly, no
changes are necessary; not even the transformations men-
tioned above. Since public-key encryption (and pairing) can-
not be directly handled by the tool presented by Cortier et
al. [14], Cortier et al. had to modify the protocol in an ad
hoc way, which is not guaranteed to yield an equivalent pro-
tocol. This is also why the runtimes of the tools cannot be
compared directly.
Recommendation 2.
Here additional access control
mechanisms are assumed which ensure that no single role
is able to mount an attack. We analyzed exactly the same
subsets of commands as the ones in [14]. These cases are
denoted CCA-2B, -2C, and -2E in Figure 3, following the no-
tation in [14] . The runtimes obtained in [14] are comparable
to ours: 333s for CCA-2B, 58s for -2C, and 0.03s for -2E.
7. REFERENCES
[1] CCA Basic Services Reference and Guide: CCA Basic
Services Reference and Guide, 2003. Available at
http:
//www-306.ibm.com/security/cryptocards/pdfs/
CCA_Basic_Services_241_Revised_20030918.pdf.
[2] B. Blanchet. An Eﬃcient Cryptographic Protocol
Veriﬁer Based on Prolog Rules. In Proc. of CSFW-14,
pages 82–96. IEEE Comp. Soc. Press, 2001.
[3] Bruno Blanchet. Automatic veriﬁcation of
correspondences for security protocols, 2008. Report
arXiv:0802.3444v1. Available at
http://arxiv.org/abs/0802.3444v1.
[4] Bruno Blanchet, Mart´ın Abadi, and C´edric Fournet.
Automated veriﬁcation of selected equivalences for
security protocols. Journal of Logic and Algebraic
Programming, 75(1):3–51, 2008.
[5] Mike Bond. Attacks on cryptoprocessor transaction
sets. In Proc of CHES 2001, vol. 2162 of LNCS, pages
220–234. Springer, 2001.
[6] J.A. Bull and D.J. Otway. The authentication
protocol. Technical Report
DRA/CIS3/PROJ/CORBA/SC/1/CSM/436-04/03,
Defence Research Agency, Malvern, UK, 1997.
[7] Y. Chevalier, R. K¨usters, M. Rusinowitch, and
M. Turuani. An NP Decision Procedure for Protocol
Insecurity with XOR. In Proc. of LICS 2003, pages
261–270. IEEE, Comp. Soc. Press, 2003.
[8] J. Clulow. The design and analysis of cryptographic
APIs for security devices, 2003. Master’s thesis,
University of Natal, Durban.
[9] H. Comon-Lundh and V. Cortier. New Decidability
Results for Fragments of First-order Logic and
Application to Cryptographic Protocols. In Proc. of
RTA 2003, vol. 2706 of LNCS, pages 148–164.
Springer, 2003.
[10] H. Comon-Lundh and V. Shmatikov. Intruder
deductions, constraint solving and insecurity decision
in presence of exclusive or. In Proc. of LICS 2003,
pages 271–280. IEEE Comp. Soc. Press, 2003.
[11] Hubert Comon-Lundh and V´eronique Cortier.
Security properties: two agents are suﬃcient. Sci.
Comput. Program., 50(1-3):51–71, 2004.
[12] Hubert Comon-Lundh and St´ephanie Delaune. The
ﬁnite variant property: How to get rid of some
algebraic properties. In Proc. of RTA 2005, vol. 3467
of LNCS, pages 294–307. Springer, 2005.
[13] V. Cortier, S. Delaune, and G. Steel. A formal theory
of key conjuring. In Proc. of CSF 2006, pages 79–93.
IEEE Comp. Soc. Press, 2007.
[14] V. Cortier, G. Keighren, and G. Steel. Automatic
Analysis of the Security of XOR-Based Key
Management Schemes. In Proc. of TACAS 2007, vol.
4424 of LNCS, pages 538–552. Springer, 2007.
[15] R. K¨usters and T. Truderung. On the Automatic
Analysis of Recursive Security Protocols with XOR. In
Proc. of STACS 2007, vol. 4393 of LNCS, pages
646–657. Springer, 2007.
[16] R. K¨usters and T. Truderung. Reducing Protocol
Analysis with XOR to the XOR-free Case in the Horn
Theory Based Approach. Implementation, 2008.
Available at
http://infsec.uni-trier.de/software/
KuestersTruderung-XORPROVERIF-2008.zip.
[17] R. K¨usters and T. Truderung. Reducing Protocol
Analysis with XOR to the XOR-free Case in the Horn
Theory Based Approach. Report arXiv:0808.0634v1,
2008. Available at
http://arxiv.org/abs/0808.0634v1.
[18] V. Shoup and A. Rubin. Session key distribution using
smart cards. In Proc. of EUROCRYPT 1996, vol.
1070 of LNCS, pages 321–331. Springer, 1996.
[19] Graham Steel. Deduction with XOR constraints in
security API modelling. In CADE, vol. 3632 of LNCS,
pages 322–336. Springer, 2005.
[20] K.N. Verma, H. Seidl, and T. Schwentick. On the
complexity of equational Horn clauses. In Proc. of
CADE 2005, vol. 3328 of LNCS, pages 337–352.
Springer, 2005.