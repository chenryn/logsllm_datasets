title:An empirical characterization of IFTTT: ecosystem, usage, and performance
author:Xianghang Mi and
Feng Qian and
Ying Zhang and
XiaoFeng Wang
An Empirical Characterization of IFTTT:
Ecosystem, Usage, and Performance
Feng Qian
Xianghang Mi
Indiana University Bloomington
PI:EMAIL
Ying Zhang
Facebook Inc.
PI:EMAIL
Indiana University Bloomington
PI:EMAIL
XiaoFeng Wang
Indiana University Bloomington
PI:EMAIL
ABSTRACT
IFTTT is a popular trigger-action programming platform whose
applets can automate more than 400 services of IoT devices and
web applications. We conduct an empirical study of IFTTT using
a combined approach of analyzing data collected for 6 months
and performing controlled experiments using a custom testbed.
We profile the interactions among different entities, measure
how applets are used by end users, and test the performance of
applet execution. Overall we observe the fast growth of the IFTTT
ecosystem and its increasing usage for automating IoT-related tasks,
which correspond to 52% of all services and 16% of the applet usage.
We also observe several performance inefficiencies and identify
their causes.
CCS CONCEPTS
• Networks → Home networks; Network performance evaluation;
• Computer systems organization → Embedded systems;
KEYWORDS
IFTTT, IoT, Measurement
ACM Reference Format:
Xianghang Mi, Feng Qian, Ying Zhang, and XiaoFeng Wang. 2017. An
Empirical Characterization of IFTTT: Ecosystem, Usage, and Performance.
In Proceedings of IMC ’17. ACM, New York, NY, USA, 7 pages. https://doi.
org/10.1145/3131365.3131369
1 INTRODUCTION
Consumer Internet of Things (IoT) devices such as smart home
gadgets are becoming increasingly popular. For example, Amazon
has sold more than 5 million Amazon Echo devices in just two
years since their debut in late 2014 [1]. Among many challenges
faced by today’s consumer IoT systems, policy management plays a
critical role in ensuring scalable, automated, secure, and resource-
efficient interactions among devices. Take smart home as an
example. In our measurement (§3), we observe more than 20 types
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
IMC ’17, November 1–3, 2017, London, UK
© 2017 Association for Computing Machinery.
ACM ISBN 978-1-4503-5118-8/17/11...$15.00
https://doi.org/10.1145/3131365.3131369
of smart home devices such as light, security camera, thermostat,
A/C, washing machine, sprinkler, doorbell, garage door, lock,
refrigerator, and even smart egg tray [6]. These devices are highly
heterogeneous in terms of their vendors, form factors, computation
power, networking capabilities, and programming interfaces. It
is non-trivial to manage each device separately, letting alone
managing proper policies to coordinate them to accomplish complex
tasks.
In this paper, we conduct an empirical characterization of IFTTT
(IF This Then That [4]), a task automation platform for IoT and
web services. Through IFTTT, end users can easily create policies
that connect IoT devices or bridge IoT devices with web services
such as “add ‘buying eggs’ to my iPhone reminder when there are
no more than 3 eggs in the fridge”. We select IFTTT because it
is the most popular one among a plethora of commercial task
automation platforms [2, 10, 11, 13–15]. As of early 2017, IFTTT
has more than 320,000 automation scripts (called “applets”) offered
by more than 400 service providers. The applets have been installed
more than 20 million times. More importantly, unlike other task
automation platforms that are mainly dedicated to web services,
more than half of IFTTT services are IoT devices related, as to be
measured in §3.2. This makes IFTTT a perfect platform to profile
the interactions between web services and IoT devices. The success
of IFTTT is attributed to several technical factors. First, it employs
very simple trigger-action API (TAP [18, 23]); end users only need
to specify a trigger and an action to construct an applet. Second,
IFTTT supports both IoT and non-IoT services using a unified
HTTP RESTful interface. Third, it uses crowdsourcing to enrich
the applet library by allowing users to create applets and sharing
them with other users.
Despite the popularity of IFTTT, there is a lack of systematic
understanding of its ecosystem, usage, and performance. The
goal of this paper is thus to perform in-depth studies of these
important aspects. However, our measurement study faces several
challenges. First, the IFTTT ecosystem involves multiple policy
stakeholders (e.g., end users, IoT devices, service providers, web
applications, and the IFTTT engine itself) incurring complex
interactions. Second, observing only from end users’ perspective
has limited visibility, and thus is challenging to gain insights
into what happens “under the hood” for applet execution. Third,
conducting long-term measurement against IFTTT faces several
practical challenges such as automation.
To address the above challenges, we built a testbed to automat-
ically monitor and profile the whole process of applet execution.
IMC ’17, November 1–3, 2017, London, UK
Xianghang Mi et al.
To further explore potential performance bottlenecks and to char-
acterize interactions between different entities, we launched our
own IFTTT service that controls our home-deployed IoT devices
and third-party web services. The testbed along with our own
IFTTT service enable us to interact with IFTTT from both end
users’ and service providers’ perspectives, and to instrument the
applet execution at multiple vantage points.
We then study the usage of IFTTT in the wild by collecting and
analyzing its services and applets for six months. We found that
52% of services and 16% of applet usage are IoT-related. With more
than 200 IoT services identified, IFTTT indeed provides a way to
identify popular smart home and wearable devices on the market
in a “centralized” manner. We further provide detailed taxonomies
of services and their interactions, as well as characterize how users
contribute to IFTTT’s applet library.
We further go beyond passive measurements by conducting
in-lab controlled experiments to understand the applet execution
performance. Our results suggest that actions of many applets
(including some “realtime” applets such as turning on the light
using a smart switch) cannot be executed in real time when their
triggers are activated. The delays are long (usually 1 to 2 minutes)
with huge variance (up to 15 minutes). We found the delay is caused
by IFTTT’s long polling interval. We also study the scenarios when
multiple applets execute sequentially and concurrently, and find
their performance is often suboptimal. For example, chained applets
can form explicit and implicit “infinite loops”, causing resource
waste or even damage of the physical devices.
Overall, this paper makes three major contributions: (1) de-
veloping a measurement testbed with self-implemented IFTTT
service and using them to profile the IFTTT ecosystem (§2), (2)
conducting an in-depth characterization of service and applet
usage (§3), and (3) using the testbed to measure the IFTTT applet
execution performance (§4). Based on our findings, we provide
recommendations in §6. We summarize related work and conclude
the paper in §5. All data and code in this project can be found at:
https://www.cs.indiana.edu/~fengqian/ifttt_measurement
2 UNDERSTANDING THE ECOSYSTEM
IFTTT is a trigger-action programming (TAP) platform [18, 23]
that allows end users to create conditional rules in the form of “if
A then B” where A is called a trigger, B is called an action, and
the entire rule is called an applet. Triggers and actions are often
provided by IoT vendors and web service providers. The applets are
constructed by users via picking triggers and actions from (usually
different) third-party partner services (or services for short)1. A
service abstracts functionalities provided by web applications or
IoT devices, and it usually provides multiple triggers and actions.
For example, consider the following applet: automatically turn your
hue lights blue whenever it starts to rain. In this applet, the trigger
(raining) is from the weather service and the action (changing the
hue light color) belongs to the service provided by Philips Hue [8], a
smart LED lamp vendor. A service usually exposes multiple triggers
and/or actions. Both the trigger and action may have fields (i.e.,
parameters) that customize the applet, such as the light color.
1Historically, an applet and a service in IFTTT were called “recipe” and “channel”,
respectively. We do not use these old names.
Figure 1: Our IFTTT testbed.
2.1 The Measurement Testbed
Multiple entities play roles in the IFTTT ecosystem: the centralized
IFTTT engine executes the applet by contacting and coordinating the
services; partner services (such as Philips Hue) respond to IFTTT’s
requests by testing the trigger condition or executing the action;
IoT devices and web applications are controlled by the services
to implement the policy; finally, end users can define the applets
through IFTTT’s mobile app or web interfaces.
The above players incur potentially complex interactions. To
understand them, we set up a measurement testbed using IFTTT,
commodity IoT devices, and commercial web apps. From the
measurement perspective, a challenge here is that an end user is
sitting at the “edge” of the ecosystem and henceforth does not have
visibility of how partner services interact with the IFTTT engine.
To overcome this limitation, we obtained a service provider testing
account from IFTTT. By doing so, we essentially become a service
provider partnering with IFTTT and can publish our own services.
Our services support triggers and actions for both IoT devices and
web applications. For the former, we purchased four popular off-
the-shelf smart home devices: Philips Hue smart lights, WeMo Light
Switch (programmatically controlling any home light), and Amazon
Echo Dot (smart speaker connecting to Alexa, Amazon’s personal
assistant service), and Samsung SmartThings Hub (controlling
various home appliances). Our testbed also supports several web
applications such as Gmail and Google Drive.
For each of the above smart devices and web apps, our service
leverages its API to get and set its states. We illustrate this using
Philips Hue as an example. As shown in Figure 1, we run our service
on a server ❺ in our lab. The actual Hue lamp ❶ and its hub (i.e.,
controller, ❷) are located at an author’s home. For security, most
home deployed devices only accept access from a 3rd-party host
in the same LAN so we deployed in the home LAN a local proxy
❸ which acts as a bridge for communication between our service
server and local devices. Our local proxy communicates with the
devices through different protocols such as the Hue RESTful Web
API [9] for the Hue hub and UPnP (Universal Plug and Play) [? ] for
the Wemo Switch. We design a custom protocol between the local
proxy ❸ and our service server ❺ both of which we have control.
Then, The communication path between the lamp and our service
is thus Hue Lamp ❶–Hue Hub ❷–Local Proxy ❸–Gateway Router
❹–Our Service Server ❺. Note that for the official Hue service ❻, it
can directly talk to the hub using a proprietary protocol so the path
is Hue Lamp ❶– Hue Hub ❷– Gateway Router ❹– Hue Service ❻.
Our service server ❺ and the IFTTT engine ❼ communicate using
the IFTTT’s web-based protocol [5]. The services for other smart
home devices are developed in a similar manner. For web apps, our
1234567Our testServiceOfficial Philips Hue ServiceIFTTTEngineHome Gateway RouterHueHubHueLampProxyLAN LinkWANPathUser89Test ControllerAn Empirical Characterization of IFTTT: Ecosystem, Usage, and Performance
IMC ’17, November 1–3, 2017, London, UK
service directly talks with Google using its App API [3]. Our overall
implementation efforts for the testbed involve 1620 LoCs in PHP
and 2900 LoCs in Python. The Test Controller ❾ automates the
controlled experiments to be described in §4.
2.2 Profiling Interactions Among Entities
We leveraged the testbed and self-implemented IFTTT service
to profile the interactions among the entities within the IFTTT
ecosystem. The high-level approach is to monitor the message
exchanges at our vantage points (e.g., Our service server ❺ and the
local proxy ❸ in Figure 1). It seems that the interactions can be
obtained from the IFTTT documentation. However, we emphasize
that an experimental approach is necessary for several reasons: it
helps verify the actual system behavior and detect any deviation or
unexpected behaviors; it provides details not revealed by the spec; it
also quantifies the system performance and pinpoints inefficiencies
as to be detailed in §4 and §6. We next describe our observations.
• To publish our service, our service server ❺ exposes to IFTTT ❼
a base URL such as https://api.myservice.com and other options
such authentication configurations. Each trigger or action has a
unique URL under the base URL, such as https://api.myservice.com/
ifttt/actions/turn_on_light. IFTTT will generate for the service a
key, which will be embedded in future message exchanges between
our service server ❺ and IFTTT ❼ for authentication.
• To construct an applet, the user ❽ directly visits IFTTT ❼ using
web or smartphone app, and selects the trigger/action services,
the trigger/action, and their fields. Many triggers/actions need to
authenticate the user. This is done using the OAuth2 framework [7].
The user will be directed to the authentication page that is usually
hosted by service providers and asked for her credentials. An access
token will be generated and cached at IFTTT ❼ to make future
applet execution fully automated.
• In the online applet execution phase, IFTTT ❼ periodically polls
the trigger service (e.g., Our service server ❺). The polling query is
encapsulated into an HTTPS POST message (with the access token,
the service key, and a random request ID) sent to the trigger URL.
The trigger service will then determine if the trigger condition
is met by either active polling or having the target device/app
push trigger events (our testbed uses the push approach for IoT
devices and the polling approach for web apps). If the trigger is
activated, the trigger service will notify IFTTT ❼ (passively through
responding the poll from IFTTT ❼), which will, in turn, contact the
action URL. Finally, the action service will execute the action.
3 UNDERSTANDING IFTTT USAGE
To gain a holistic view of IFTTT usage, we crawl its services,
triggers, actions, and applets. We describe the data collection
methodology in §3.1 and our findings in §3.2.
3.1 Data Collection Methodology
To begin with, we parse the IFTTT partner service index page
to get a list of all services. Then through reverse engineering
the URLs of applets’ pages, we observe that the URLs can be
systematically retrieved by enumerating a six-digit applet ID. Using
this method, we managed to fetch more than 300K published applets.
For each applet, we retrieved the following information from its
page: applet name, description, trigger, trigger service (the service
0.8%
1.0%
9.3%
2.7%
2.0%
3.7%
2.5%