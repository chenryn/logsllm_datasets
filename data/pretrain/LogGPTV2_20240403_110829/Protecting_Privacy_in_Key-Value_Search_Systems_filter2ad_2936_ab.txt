s)
Ks
If Ki matches Ks
r ← (cid:1)Ri, Rs
(cid:2)
Figure 4. The basic Peekaboo protocol
Registration stage:
Step 1: To publish a key-value pair (cid:1)Ki, Vi(cid:2), Alice en-
crypts the key Ki with the K-server’s public key pk, and
submits the encryption αi ← Epk(Ki) and the correspond-
ing value Vi to the V-server:
Alice → V-server : αi, Vi
Step 2: On reception of the registration request, the V-
server extracts Vi and the owner identity “Alice”, generates
a unique rendezvous number Ri, and stores the following
entry locally:
V-server : (cid:1)Alice, Vi, Ri(cid:2)
The V-server then forwards αi to the K-server, attaching Ri:
V-server → K-server : αi, Ri
Step 3: The K-server extracts Ki ← Dpk(αi) from the
message, where Dpk(αi) denotes the decryption of αi using
the private key corresponding to the K-server’s public key
pk. It then registers the tuple (cid:1)Ki, Ri(cid:2) locally:
K-server : (cid:1)Ki, Ri(cid:2)
Query stage:
Step 1: To search based on a key Ks, the client Charlie
encrypts Ks with the K-server’s public key pk, and submits
the encryption αs ← Epk(Ks) as the query to the V-server:
Charlie → V-server : αs
Step 2: The V-server generates a unique rendezvous
number Rs for the query, and registers the tuple of the client
identity “Charlie” and Rs locally:
V-server : (cid:1)Charlie, Rs(cid:2)
The V-server then attaches Rs to the original query αs, and
submits a search request to the K-server:
V-server → K-server : αs, Rs
Step 3: On reception of the search request, the K-server
extracts the queried key Ks ← Dpk(αs) using its private
key. The K-server then performs search locally. If a key Ki
matches the query Ks based on the predeﬁned application
match criteria (e.g., numerically equal or string match), the
K-server returns the tuple r ← (cid:1)Ri, Rs(cid:2) as the query result
to the V-server, meaning the key with rendezvous number
Ri matches the key with rendezvous number Rs:
K-server → V-server : r
Step 4: The V-server extracts (cid:1)Ri, Rs(cid:2) ← r, looks up
the corresponding value Vi and the owner identity “Alice”
using Ri, and returns the ﬁnal query result γ ← (cid:1)Alice, Vi(cid:2)
to Charlie:
V-server → Charlie : γ
We note that in the query stage, no owner participation is
needed to perform search. Because the K-server has access
to both the keys stored by the owners and the keys submit-
ted as queries, it can search all key-value pairs registered by
different owners using application speciﬁc matching crite-
ria.
This basic protocol provides the desired privacy protec-
tion from the K-server, which has no information about the
values, the data ownership, or the client identities. However,
it does not provide privacy against the V-server. Although
the V-server has no access to the keys that are encrypted
under the K-server’s public key, it may infer the key-value
bindings based on the values returned from client queries.
3.1 Supporting Advanced Queries
In many applications, a client may not only want to get
a list of values matching the query, but also be interested
in seeing the matched keys as well. For example, in a ser-
vice discovery system, a client searching for printers will
be interested in getting all the attributes regarding the list of
printers in order to make the best selection. Another exam-
ple is keyword search where a client is searching for all ﬁle
names containing the substring “app”.
The basic search protocol can support such advanced
queries with a slight modiﬁcation.
In order to obtain
matched keys in the query results, the client can attach a
one-time encryption key protected by the K-server’s public
key in the query. For better performance, we can use sym-
metric keys instead of public keys. As shown in Figure 5,
before returning the query results, the K-server encrypts the
matched keys using the client-provided encryption key sk,
and sends the encryption together with the query results to
the V-server.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:33:41 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Charlie: Query stage
α
s
← Epk((cid:1)Ks, sk(cid:2))
α
s
γ
(cid:2) ← γ
(cid:127) (cid:1)Alice,Vi,α
← Dsk(α
r)
(cid:127) Ki
r
V-Server
(cid:1)Alice, Vi, Ri
(cid:2)
K-Server
(cid:1)Ki, Ri
(cid:2)
Store (cid:1)Charlie,Rs
(cid:2)
α
s,Rs
(cid:1)Ks ,sk(cid:1)←Dpk(α
s)
(cid:127) (cid:1)Ri, Rs, α
(cid:2) ← r
(cid:127) γ ← (cid:1)Alice,Vi,α
r
(cid:2)
r
r
If Ki matches Ks
α
← Esk(Ki)
r
r ← (cid:1)Ri, Rs, α
r
(cid:2)
Figure 5. Supporting advanced queries (sk is
a one time encryption key generated by Char-
lie.)
K-Server
V-Server-1
V-Server-2
… …
V-Server-n
(V’1 = )
(V’2 = )
(V’n = )
owner/client
Figure 6. An example Peekaboo search sys-
tem with a single K-server and n V-servers
4 The Peekaboo Search System
We now consider how we can use the basic protocol to
construct a Peekaboo search system with privacy guarantees
against both the K-servers and the V-servers. Speciﬁcally,
we would like to protect the values from being exposed to
the V-servers. One option is for each data owner to encrypt
the values using a secret key, and store the encryptions at
the V-server to return as query results. While clients can
still perform search using keys, they need to contact the
corresponding owners after search in order to decrypt the
returned query results. This increases not only the search
latency perceived by clients, but also the processing over-
head of data owners, who will be involved in every query
that results in a hit from their key-value pairs.
Instead, our idea for preventing the V-servers from ac-
cessing the values is to divide every value V in the key-
value pairs into n (n >1) pieces, and store them across
n V-servers, as shown in Figure 6. Each individual piece
Vi(1 ≤ i ≤ n) reveals no information about V , but the
knowledge of t or more pieces can be easily used to recon-
struct the original V using a reconstruction function F . One
choice of F is an XOR function with t = n, which offers
not only true information-theoretic privacy, but also fast re-
construction due to its simplicity. More generally, we can
adopt (t, n) threshold schemes (e.g., [28]) for choosing F .
To register a key-value pair (cid:1)K, V (cid:2) in a Peekaboo sys-
tem with n V-servers, the owner ﬁrst decomposes V into
n different pieces of encodings V1, V2, . . . , Vn, so that a
client can reconstruct V using t out of the n pieces later.
To bind the n different pieces of encodings, the owner as-
signs a unique identiﬁcation ID to this key-value pair, and
1(cid:2),(cid:1)K, V (cid:1)
2(cid:2),
composes a set of n new key-value pairs {(cid:1)K, V (cid:1)
i = (cid:1)ID, Vi(cid:2) (1 ≤ i ≤ n). Finally,
. . ., (cid:1)K, V (cid:1)
the owner communicates with all the n V-servers in parallel
using the basic protocol described in Section 3, and registers
i (cid:2) by communicating with the i-th V-server
each tuple (cid:1)K, V (cid:1)
(1 ≤ i ≤ n).
n(cid:2)}, where V (cid:1)
Similarly, to perform search using key K, the client sub-
mits the same query of K to randomly selected t V-servers
in parallel using the basic protocol. After retrieving the t
different pieces of encodings for V from the selected V-
servers, the client reconstructs V using the predeﬁned F .
The minimum number of V-servers to be contacted for
retrieving and reconstructing a value V in the system should
be determined based on the level of privacy required by the
corresponding data owner. To prevent the K-server from
becoming the system bottleneck, we can also conﬁgure the
system with multiple K-servers to balance both the registra-
tion and query workload.
The storage overhead at each server, determined by the
requirement of the basic protocol, is linear in the number
of owners and the number of key-value pairs in total. The
communication overhead is linear in the number of query
results. Both overheads are comparable to legacy servers.
Since a client will talk to multiple V-servers in parallel, the
search latency will be slightly higher with public key en-
cryption/decryption and one more round-trip communica-
tion between the V-servers and the K-server. We will eval-
uate the system overhead in Section 7.
5 Access Control and User Authentication
In many applications, data owners would like to control
which clients can search which data items. For example,
in stock quote dissemination, quotes should be searched
by paying customers only. More seriously, without access
control and authentication, a malicious user can carefully
perform on-line dictionary attacks by searching all possible
keys to ﬁnd out all the registered key-value pairs. We focus
on the environments where both users and servers may be-
long to different organizations and administrative domains.
Unlike traditional mechanisms, Peekaboo access control
and authentication should be both privacy-preserving and
convenient for search to be used frequently. Our design is
guided by the following principles:
• Inter-operability and expressivity. The system should
support users from different organizations or domains.
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:33:41 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006Given a query, servers should return all query results
(which may be from different owners) that the client
is authorized to see. Each owner should be able to
specify which client can access which key-value pairs
based on different levels of data sensitivity.
• Privacy non-disclosure. Servers should not be able to
infer the key-value pairs from the access control and
user authentication information.
• Convenience to the user. For convenient practical use,
clients should not need to know which data owners can
potentially satisfy their queries prior to search. Owners
should be able to revoke existing access permissions of
their data easily.
With all users talking only to the V-servers, the natural
choice is to authenticate users at the V-servers. Access con-
trol can be enforced at both the K-servers and the V-servers.
For inter-operability, Peekaboo access control and user au-
thentication are based on public key cryptography and we
assume an available public key infrastructure (e.g., [22]).
5.1 V-server based Access Control
Given a query, V-servers can perform access control by
jointly returning only the values that a client is authorized
to see.
In the registration stage, each owner creates an
Access Control List (ACL) for every (cid:1)K, V (cid:2) of their key-
value pairs, specifying a list of clients that can access the
pair. The owner then splits V into n pieces V1, V2, . . . , Vn,
attaches the ACL with every Vi, and registers the tuple
(cid:1)K,{Vi, ACL}(cid:2) by communicating with the i-th V-server
using the basic protocol. During the query stage, given
all the matched rendezvous numbers returned from the K-
server, each V-server returns to a client only the value pieces
that the client is allowed to access based on the correspond-
ing ACLs.
However, such V-server based access control may create
a side channel of information leakage, where the V-servers
may infer the corresponding queried keys based on the num-
ber of entries matched and returned from the K-servers. For
example, the V-servers can guess whether a searched key is
about a popular product with many matching results.
5.2 K-server based Access Control
The K-servers can perform access control as well to pre-
vent the aforemention side channel of information leakage
and thus provide a stronger privacy guarantee. By returning
only the entries that a client is authorized to access, the K-
servers prevent the V-servers from learning the exact num-
bers of matched results.
However, because the K-servers do not have access to
the client identity information, they cannot perform permis-
sion checks directly by attaching an owner speciﬁed ACL
for every stored key. We thus need a solution that can hide
client identities in ACLs while still enforcing access con-
trol.
Our key idea is to let each owner create a pseudonym
C(cid:1)
for a client C whom the owner is granting access.
Every such (cid:1)C, C(cid:1)(cid:2) client-pseudonym mapping is split in
half and stored at different types of servers. In particular,
the V-servers authenticate clients with their identity infor-
mation, while the K-servers check access permission using
client pseudonyms to preserve privacy. To prevent a mali-
cious client from forging pseudonyms or using other peo-
ple’s pseudonyms, we use noninteractive zero-knowledge
proofs so that the V-servers can ensure the client-submitted
pseudonyms are indeed those speciﬁed by the data owners,
even though the V-servers themselves do not have access to
the pseudonyms. We describe the modiﬁed protocol with
access control between a K-server and a V-server using the
same example described in Section 3. The scheme can be
easily generalized to a system with multiple V-servers.
Registration stage:
Step 1: For each key-value pair (cid:1)Ki, Vi(cid:2), the owner Alice
creates an access control list ACLi consisting of a list of
clients {C1, C2, . . .} that can search the pair:
Alice
:
(cid:1)Ki, Vi, ACLi(cid:2)
ACLi = {C1, C2, . . .}
For each client Ci in ACLi, Alice creates a pseudonym C(cid:1)
i,
and replaces Ci with C(cid:1)
i in ACLi:
i = {C(cid:1)
Alice : ACL(cid:1)
1, C(cid:1)
2, . . .}
To register (cid:1)Ki, Vi(cid:2) with access control information, Al-
ice encrypts both the key Ki and the corresponding
i using the K-server’s public key pk into αi ←
ACL(cid:1)
Epk(Ki, ACL(cid:1)
i), so that only the K-server will be able to
see the key and the access control speciﬁcation.
For each client Ci, Alice constructs a tuple mi =
(cid:1)Ci, ei, hi(cid:2), where ei ← Epci
i) is an encryption of
the client pseudonym C(cid:1)
i using Ci’s public key pci, and
hi ← H(C(cid:1)
i) is generated using a one-way hash function
H. This tuple mi allows the V-server to verify the client
Ci’s input later (we discuss how to choose the hash func-
tion later).
Finally, Alice submits αi, the corresponding value Vi,
and the set of tuples M = {m1, m2, . . . ,} to the V-server:
(C(cid:1)
Alice → V-server
: αi, Vi, M
Step 2: On reception of the registration request, the V-
server generates a rendezvous number Ri, and registers the
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:33:41 UTC from IEEE Xplore.  Restrictions apply. 
Proceedings of the 22nd Annual Computer Security Applications Conference (ACSAC'06)0-7695-2716-7/06 $20.00  © 2006following tuple locally:
:
V-server
(cid:1)Alice, Vi, Ri, M(cid:2)
where M = {(cid:1)C1, e1, h1(cid:2),(cid:1)C2, e2, h2(cid:2), . . .}
The V-server then forwards the encryption αi as well as the
rendezvous number Ri to the K-server:
V-server → K-server : αi, Ri
Step
decrypts
The K-server
3:
the message
i(cid:2) ←D pk(αi), and registers the data and
(cid:1)Ki, ACL(cid:1)
the access control information locally:
K-server : (cid:1)Ki, ACL(cid:1)
i, Ri(cid:2)
Query stage:
Step 1: To search based on a key Ks, the client Char-
lie ﬁrst submits a “ready-to-search” request to the V-server
with his identity Ic = “Charlie”:
Charlie → V-server : Ic
Step 2: Given the “ready-to-search” request from
“Charlie” = Ic, the V-server extracts Charlie’s pseudonym
from the tuple (cid:1)Charlie, ec, hc(cid:2) where ec = Epc(C(cid:1)) and
hc = H(C(cid:1)) if one exists, and presents ec and hc to Char-
lie:
V-server → Charlie : ec, hc
C(cid:1) ← Dpc(ec).
Step 3: Charlie decrypts ec and ﬁnds out his pseudonym
To send his query Ks and his pseudonym C(cid:1)
to the