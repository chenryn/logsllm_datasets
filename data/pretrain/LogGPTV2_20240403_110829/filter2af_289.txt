# 12.PHP反序列化
## 1.PHP反序列化概述
在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。
序列化serialize()
序列化说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象:
    class S{
        public $test="pikachu";
    }
    $s=new S(); //创建一个对象
    serialize($s); //把这个对象进行序列化
    序列化后得到的结果是这个样子的:O:1:"S":1:{s:4:"test";s:7:"pikachu";}
        O:代表object
        1:代表对象名字长度为一个字符
        S:对象的名称
        1:代表对象里面有一个变量
        s:数据类型
        4:变量名称的长度
        test:变量名称
        s:数据类型
        7:变量值的长度
        pikachu:变量值
反序列化unserialize()
就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。
    $u=unserialize("O:1:"S":1:{s:4:"test";s:7:"pikachu";}");
        echo $u->test; //得到的结果为pikachu
序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题
    常见的几个魔法函数:
    常见的几个魔法函数:
            __construct()当一个对象创建时被调用
            __destruct()当一个对象销毁时被调用
            __toString()当一个对象被当作一个字符串使用
            __sleep() 在对象在被序列化之前运行
            __wakeup将在序列化之后立即被调用
漏洞举例:
    class S{
        var $test = "pikachu";
        function __destruct(){
            echo $this->test;
        }
    }
    $s = $_GET['test'];
    @$unser = unserialize($a);
    payload:O:1:"S":1:{s:4:"test";s:29:"";}
## 2.PHP反序列化漏洞
根据序列化的原理
首先我们在本地写一个serialize.php文件，进行序列化
代码如下
在本地程序执行，得到序列化的结果
    O:1:"S":1:{s:4:"test";s:29:"";}
将这一结果填入到具有反序列化漏洞的网站中，成功触发xss漏洞
# 13.XXE
## 1.XXE -xml external entity injection
XXE -"xml external entity injection"
既"xml外部实体注入漏洞"。
概括一下就是"攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题"
也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。
具体的关于xml实体的介绍,网络上有很多,自己动手先查一下。
现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的,从而也就直接避免了这个漏洞。
以PHP为例,在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。
本章提供的案例中,为了模拟漏洞,通过手动指定LIBXML_NOENT选项开启了xml外部实体解析。
## 2.XXE漏洞
首先写入一个合法的xml文档
    ]>
    &gfzq;
发现成功解析
这个xml文档payload中&gfzq;是用来将gfzq这个实体进行调用，gfzq实体成功在前端回显。
外部实体，”SYSTEM”关键词导致 XML 解析器可以从本地文件或者远程 URI 中读取数据。所以攻击者可以通过 XML
实体传递自己构造的恶意值，是处理程序解析它。当引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。
外部实体payload
    ]>
    &gfzq;
成功读取到文件
    ]>
    &gfzq;
# 14.URL重定向
## 1.不安全的url跳转
不安全的url跳转
不安全的url跳转问题可能发生在一切执行了url地址跳转的地方。
如果后端采用了前端传进来的(可能是用户传参,或者之前预埋在前端页面的url地址)参数作为了跳转的目的地,而又没有做判断的话
就可能发生"跳错对象"的问题。
url跳转比较直接的危害是:
\-->钓鱼,即攻击者使用漏洞方的域名(比如一个比较出名的公司域名往往会让用户放心的点击)做掩盖,而最终跳转的确实钓鱼网站
## 2.不安全的url跳转
首先点击页面上的链接，观察url
直接修改url为
成功跳转到百度
文笔生疏，措辞浅薄，望各位大佬不吝赐教，万分感谢。
免责声明：由于传播或利用此文所提供的信息、技术或方法而造成的任何直接或间接的后果及损失，均由使用者本人负责， 文章作者不为此承担任何责任。
转载声明：儒道易行
拥有对此文章的修改和解释权，如欲转载或传播此文章，必须保证此文章的完整性，包括版权声明等全部内容。未经作者允许，不得任意修改或者增减此文章的内容，不得以任何方式将其用于商业目的。