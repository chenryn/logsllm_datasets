Ëœğ‘‰ : Fâ„“ â†’ F such that Ëœğ‘‰ (ğ‘¥1, ğ‘¥2, ..., ğ‘¥â„“) = ğ‘‰ (ğ‘¥1, ğ‘¥2, ..., ğ‘¥â„“) for all
ğ‘¥1, ğ‘¥2, . . . , ğ‘¥â„“ âˆˆ {0, 1}. Ëœğ‘‰ can be expressed as:
Ëœğ‘‰ (ğ‘¥1, ğ‘¥2, ..., ğ‘¥â„“) =
â„“
ğ‘–=1((1 âˆ’ ğ‘¥ğ‘–)(1 âˆ’ ğ‘ğ‘–) + ğ‘¥ğ‘–ğ‘ğ‘–)) Â· ğ‘‰ (ğ‘) ,
Ëœğ›½(ğ‘¥, ğ‘) Â· ğ‘‰ (ğ‘)
ğ‘âˆˆ{0,1}â„“
where ğ‘ğ‘– is ğ‘–-th bit of b.
Multilinear extensions of arrays and matrices. Inspired by the
closed-form equation of the multilinear extension given above,
we can view an array a = (ğ‘0, ğ‘1, . . . , ğ‘ğ‘âˆ’1) as a function ğ‘ :
{0, 1}log ğ‘ â†’ F such that âˆ€ğ‘– âˆˆ [0, ğ‘ âˆ’ 1], ğ‘(ğ‘–1, . . . , ğ‘–log ğ‘) = ğ‘ğ‘–.
Here we assume ğ‘ is a power of 2. Therefore, in this paper, we
abuse the use of multilinear extension on an array as the multilin-
ear extension Ëœğ‘ of ğ‘. Similarly, we use the multilinear extension


=
ğ‘âˆˆ{0,1}â„“
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2971on an ğ‘ Ã— ğ‘€ matrix ğ´ as the multilinear extension of the function
ğ´ : {0, 1}log ğ‘+log ğ‘€ â†’ F defined by the matrix.
2.2.2 GKR Protocol. Using the sumcheck protocol as a building
block, Goldwasser et al. [26] showed an interactive proof protocol
for layered arithmetic circuits. Let ğ¶ be a layered arithmetic circuit
with depth ğ‘‘ over a finite field F. Each gate in the ğ‘–-th layer takes
inputs from two gates in the (ğ‘– + 1)-th layer; layer 0 is the output
layer and layer ğ‘‘ is the input layer. Following the convention in
prior work [20, 41, 48, 52, 53], we denote the number of gates in the
ğ‘–-th layer as ğ‘†ğ‘– and let ğ‘ ğ‘– = âŒˆlog ğ‘†ğ‘–âŒ‰. (For simplicity, we assume ğ‘†ğ‘– is a
power of 2, and we can pad the layer with dummy gates otherwise.)
: {0, 1}ğ‘ ğ‘– â†’ F that takes a binary
We then define a function ğ‘‰ğ‘–
string ğ‘ âˆˆ {0, 1}ğ‘ ğ‘– and returns the output of gate ğ‘ in layer ğ‘–, where
ğ‘ is called the gate label. With this definition, ğ‘‰0 corresponds to the
output of the circuit, and ğ‘‰ğ‘‘ corresponds to the input layer. Finally,
: {0, 1}ğ‘ ğ‘–âˆ’1+2ğ‘ ğ‘– â†’
we define two additional functions ğ‘ğ‘‘ğ‘‘ğ‘–, ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–
{0, 1}, referred to as wiring predicates in the literature. ğ‘ğ‘‘ğ‘‘ğ‘– (ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–)
takes one gate label ğ‘§ âˆˆ {0, 1}ğ‘ ğ‘–âˆ’1 in layer ğ‘– âˆ’ 1 and two gate labels
ğ‘¥, ğ‘¦ âˆˆ {0, 1}ğ‘ ğ‘– in layer ğ‘–, and outputs 1 if and only if gate ğ‘§ is an
addition (multiplication) gate that takes the output of gate ğ‘¥, ğ‘¦ as
input. Taking the multilinear extensions of ğ‘‰ğ‘–, ğ‘ğ‘‘ğ‘‘ğ‘– and ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–, for
any ğ‘” âˆˆ Fğ‘ ğ‘– ,
Ëœğ‘‰ğ‘–(ğ‘”) =


ğ‘¥,ğ‘¦âˆˆ{0,1}ğ‘ ğ‘–+1
ğ‘¥,ğ‘¦âˆˆ{0,1}ğ‘ ğ‘–+1 ( Ëœğ‘ğ‘‘ğ‘‘ğ‘–+1(ğ‘”, ğ‘¥, ğ‘¦)( Ëœğ‘‰ğ‘–+1(ğ‘¥) + Ëœğ‘‰ğ‘–+1(ğ‘¦))
ğ‘“ğ‘–(ğ‘”, ğ‘¥, ğ‘¦)
=
+ Ëœğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–+1(ğ‘”, ğ‘¥, ğ‘¦) Ëœğ‘‰ğ‘–+1(ğ‘¥) Ëœğ‘‰ğ‘–+1(ğ‘¦)) ,
(3)
With Equation 3, the GKR protocol proceeds as follows. The prover
P first sends the claimed output of the circuit to V. From the
claimed output, V defines polynomial Ëœğ‘‰0 and computes Ëœğ‘‰0(ğ‘”) for
a random ğ‘” âˆˆ Fğ‘ 0. V and P then invoke a sumcheck protocol on
Equation 3 with ğ‘– = 0. As described in Section 2.2.1, at the end of
the sumcheck, V needs an oracle access to ğ‘“ğ‘–(ğ‘”, ğ‘¢, ğ‘£), where ğ‘¢, ğ‘£
are randomly selected in Fğ‘ ğ‘–+1. To compute ğ‘“ğ‘–(ğ‘”, ğ‘¢, ğ‘£), V computes
Ëœğ‘ğ‘‘ğ‘‘ğ‘–+1(ğ‘”, ğ‘¢, ğ‘£) and
Ëœğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–+1(ğ‘”, ğ‘¢, ğ‘£) locally (they only depend on the
wiring pattern of the circuit, not on the values), asks P to send
Ëœğ‘‰1(ğ‘¢) and Ëœğ‘‰1(ğ‘£) and computes ğ‘“ğ‘–(ğ‘”, ğ‘¢, ğ‘£) to complete the sumcheck
protocol. In this way, V and P reduce a claim about the output to
two claims about values in layer 1. V and P then combines the
two claims into one through a random linear combination, and
run a sumcheck protocol on Equation 3 for layer ğ‘– + 1, and then
recursively all the way to the input layer. The formal GKR protocol
and its properties are presented in Protocol 2 in Appendix A.
2.3 Zero Knowledge Arguments
A zero knowledge argument scheme is a protocol between a PPT
prover P and a verifier V, where at the end of the protocol, V is
convinced by P that the result of a computation ğ¶ on a public input
ğ‘¥ and proverâ€™s secret witness ğ‘¤ is ğ‘¦ = ğ¶(ğ‘¥, ğ‘¤). A zero knowledge
argument has (1) correctness: V always accepts if the result and the
proof are honestly computed by P; (2) soundness: V rejects with all
but negligible probability if the result is not correctly computed; (3)
zero knowledge: the proof leaks no information about the witness
ğ‘¤ beyond the fact the ğ¶(ğ‘¥, ğ‘¤) = ğ‘¦. We give the formal definitions
of zero knowledge arguments in Definition B.1 of Appendix B.
ğ‘).
Following the framework in [44, 48, 52, 53], the GKR protocol
can be lifted to a zero knowledge argument scheme using zero
knowledge polynomial commitments. The observation is that in the
last round of the GKR protocol 2, the verifier needs the multilinear
extension of the input of the circuit evaluated at two random points.
To allow secret witness from the prover, it suffices for the prover
to commit to the multilinear extension of the witness, and later
opens the polynomial evaluations to complete the reduction of the
GKR protocol. We follow the same framework to build our zero
knowledge CNN, and we give the formal definitions in Appendix B.
In our implementation, we use the polynomial commitment
scheme in [39, 44]. The security is based on the discrete-log as-
sumption and the scheme does not require trusted setup. For a
polynomial of size ğ‘ , the prover time is ğ‘‚(ğ‘) modular exponenti-
ation, and the proof size and the verifier time are ğ‘‚(âˆš
3 NEW SUMCHECK FOR CONVOLUTIONS
Convolution is undoubtedly the most important layer of CNNs
and takes the most computational resources in CNN predictions.
There are three existing approaches to support convolutions in zero
knowledge proof schemes. The first one is to implement convolu-
tions naively using addition and multiplication gates. Though the
circuit, and thus the ZKP backend, is very simple, the size of the
circuit is big, which is ğ‘‚(ğ‘›2 Â· ğ‘¤2) for a 2-D convolution between
two inputs of ğ‘› Ã— ğ‘› and ğ‘¤ Ã— ğ‘¤. The second approach is to compute
convolutions using FFT implemented as a circuit. The circuit is of
ğ‘‚(ğ‘›2 log ğ‘›) size and ğ‘‚(log ğ‘›) depth (assuming ğ‘¤ < ğ‘›), and there
are candidates of ZKP on the butterfly circuit of FFT (e.g., [52]).
Though asymptotically better, for typical convolutions in CNNs
usually ğ‘¤ << ğ‘› and the circuit size of FFT is comparable or even
larger than the first naive approach, with an overhead on the depth.
The third approach relies on the fact that convolution is equiva-
lent to the polynomial multiplication between the two polynomials
represented by the inputs. Instead of computing the convolution,
given the result of the convolution we can test the equality of the
polynomial multiplication at a random point and the security is
guaranteed by the Schwartz-Zipppel lemma [38, 57]. The circuit or
ZKP to evaluate polynomials at a random point is of size ğ‘‚(ğ‘›2+ğ‘¤2).
vCNN [34] took this approach and further improves the check by
combining a regular QAP and a polynomial-QAP. However, in this
approach the prover has to additionally commit to the result of
the convolution. As the commitments are usually the bottleneck of
ZKP schemes, the overhead of this approach is still high in practice.
In this section, we propose a new protocol to verify the correct-
ness of convolutions. The additional prover time is ğ‘‚(ğ‘›2), which is
asymptotically optimal and is even faster than computing the con-
volution. The protocol does not involve additional commitments
from the prover and can be embedded in general-purpose ZKP
schemes based on the GKR protocols. The key ingredient of our
scheme is a new sumcheck protocol for FFT with linear prover time.
3.1 New Sumcheck for Fast Fourier Transform
FFT transforms a polynomial from its coefficients to its evalua-
tions at powers of the root of unity. Formally speaking, let c =
(ğ‘0, ğ‘1, . . . , ğ‘ğ‘âˆ’1) be the vector of coefficients of a polynomial, a =
(ğ‘0, ğ‘1, . . . , ğ‘ğ‘€âˆ’1) be the vector of evaluations at (ğœ”0, ğœ”1, . . . , ğœ”ğ‘€âˆ’1),
Session 11B: Zero Knowledge II CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea2972By the definition of polynomial evaluations, ğ‘ ğ‘— =ğ‘âˆ’1
where ğœ” is the ğ‘€-th root of unity such that ğœ”ğ‘€ = 1 mod ğ‘. We
always work in a finite field and we omit mod ğ‘ in the following.
Here the length of c and a are padded to the nearest powers of 2.
ğ‘–=0 ğ‘ğ‘–ğœ” ğ‘—ğ‘– for
ğ‘— = 0, 1, . . . , ğ‘€ âˆ’ 1, which can also be written as a matrix-vector
multiplication a = ğ¹ Â· c, where ğ¹ is the standard Fourier matrix:
(cid:169)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:173)(cid:171)
ğ¹ =
1
ğœ”1
ğœ”2
...
1
1
1
...
1 ğœ”ğ‘€âˆ’1 ğœ”2(ğ‘€âˆ’1)
1
ğœ”2
ğœ”4
...
. . .
. . .
. . .
1
ğœ” ğ‘âˆ’1
ğœ”2(ğ‘âˆ’1)
...
. . . ğœ” (ğ‘€âˆ’1)(ğ‘âˆ’1)
(cid:170)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:174)(cid:172)
(4)
The key property of the FFT algorithm is that as ğœ”ğ‘€ = 1, there
are only ğ‘€ distinct values in the Fourier matrix ğ¹ and a can be
computed in quasi-linear time using the divide-and-conquer tech-
nique [19]. We omit the algorithm of FFT, but will utilize the same
property in the design of our sumcheck protocol.
In our setting, given the multilinear extension of a evaluated at
a random point, we want to reduce its correctness to the evaluation
of the multilinear extension of c. The evaluations can either be
computed directly on c and a, or be given by the prover during the
GKR protocols. To do so, we first turn the equation of polynomial
evaluation to the form of multivariate polynomials:
Ëœğ‘(ğ‘¥) Ëœğ¹(ğ‘¦, ğ‘¥) ,

Ëœğ‘(ğ‘¦) =
(5)
ğ‘¥âˆˆ{0,1}log ğ‘
for ğ‘¦ âˆˆ {0, 1}log ğ‘€. Here Ëœğ‘(Â·) and Ëœğ‘(Â·) are multilinear extensions of a
and c, and Ëœğ¹(Â·, Â·) is the multilinear extension defined by the Fourier
matrix ğ¹ such that Ëœğ¹(ğ‘¦, ğ‘¥) is the (ğ‘¦, ğ‘¥)-th entry in ğ¹. As ğ‘¥, ğ‘¦ are
binary strings, we further denote the values represented by ğ‘¦, ğ‘¥ as
Y,X âˆˆ F, and thus Ëœğ¹(ğ‘¦, ğ‘¥) = ğœ”YX. The equation basically replaces
the univariate indices ğ‘– âˆˆ [ğ‘], ğ‘— âˆˆ [ğ‘€] by ğ‘¥ âˆˆ {0, 1}log ğ‘ , ğ‘¦ âˆˆ
{0, 1}log ğ‘€. To run the sumcheck protocol on Equation 5, we rely on
the algorithm proposed in [41, 48]. Given the evaluation Ëœğ‘(ğ‘¢) of Ëœğ‘(Â·)
at a random point ğ‘¢ âˆˆ Flog ğ‘€, if the prover can initialize the values
of Ëœğ‘(ğ‘¥) and Ëœğ¹(ğ‘¢, ğ‘¥) on all ğ‘¥ âˆˆ {0, 1}log ğ‘ , there is an algorithm for
the prover to generate all messages in the sumcheck protocol in
ğ‘‚(ğ‘) time. The algorithm applies dynamic programming [41] and
the initialization is referred as the bookkeeping tables in [48]. We
give the algorithm for our particular sumcheck on Equation 5 in
Algorithm 1 for completeness.
In the input of Algorithm 1, the array Ağ‘ is simply c itself by
the definition of the multilinear extension. The challenging part is
to calculate Ağ¹ , i.e., Ëœğ¹(ğ‘¢, ğ‘¥) âˆ€ğ‘¥ âˆˆ {0, 1}log ğ‘ . Existing techniques
in [48, 51] cannot be applied here, as Ëœğ¹(ğ‘¦, ğ‘¥) is not sparse. It is the
multilinear extension defined by the Fourier matrix ğ¹ in Equation 4
with ğ‘‚(ğ‘€ğ‘) nonzero values. Computing Ağ¹ naively would take
ğ‘‚(ğ‘€ğ‘) time in total.
In order to reduce the prover time, we write Ëœğ¹(ğ‘¢, ğ‘¥) as:
Ëœğ¹(ğ‘¢, ğ‘¥) =
Ëœğ›½(ğ‘¢, ğ‘§) Ëœğ¹(ğ‘§, ğ‘¥)

ğ‘§âˆˆ{0,1}log ğ‘€