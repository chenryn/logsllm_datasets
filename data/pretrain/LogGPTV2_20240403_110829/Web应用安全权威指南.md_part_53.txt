也许大家听说过"在网络上不要使用半角片假名"这种说法，其由来也和
ISO-2022-JP 编码有关，因为 ISO-2022-JP 编码中并不支持半角片假名（JIS X
0201）。
以上我们已经针对 Shift_JIS、EUC-JP、ISO-2022-JP 等基于 JIS
系列字符集的编码方式进行了相应的说明，下面开始我们再来看看 Unicode
编码的两种主要编码方式：UTF-16 和 UTF-8。
-   **UTF-16**
    Unicode 在最初设计的时候曾想使用 16
    比特的长度来容纳世界上所有的字符，所以当时直接使用 16 比特码位（Code
    Point）的编码方式 USC-2，这也是当时使用最普及的 Unicode
    编码方式。但是之后 Unicode 长度扩展到了 21 比特，随之出现的是 UTF-16
    编码方式。这种编码方式在兼容 UCS-2 的同时，也支持 BMP 之外的字符。
    UTF-16 通过使用代理对（Surrogate Pair）技术来实现支持 BMP
    之外的字符。它通过在 16 比特的 Unicode 范围内预留两个 1024（2 的 10
    次方）字符长度的区域（0xD800～0xDBFF 以及
    0xDC00～0xDFFF），这两个区域组合的话则一共可以表示 2 的 20
    次方（大约 100 万）个字符。
    我们来看一下具体的实例，比如 BMP
    以外的日语汉字"𠮷"，这个汉字读作"つちよし"， Unicode 编码为
    U+20BB7，转换为代理对之后，其存储结构为
    D842-DFB7，如下图所示，图中显示的是"𠮷田"用 UTF-16
    进行编码后的样子。
    ![{%}](Image00228.jpg)
    **图 6-16 将"𠮷田"进行 UTF-16 编码的结果**
-   **UTF-8**
    UTF-8 是和 US-ASCII 保持兼容的 Unicode 的一种编码方式。UTF-8 按照表
    6-3 的规则根据 Unicode
    的码位范围不同采用不同的方法进行编码，最终编码后的字节长度为 1
    字节到 4 字节的可变长度。
    **表 6-3 UTF-8 编码比特位模式**
    ![{%}](Image00229.jpg)
    图 6-17 显示的是 UTF-8 编码后各字节的分布示意图。
    ![{%}](Image00230.jpg)
    **图 6-17 UTF-8 编码后各字节分布**
    从图 6-17 中我们可以看到，用 UTF-8
    方式编码后各前置字节和后置字节不存在重合的部分，给定某一字符串中的任一字节，立刻就可以知道这一字节是字符编码后的首字节还是后置字节。因此
    UTF-8 不会像 Shfit_JIS 那样发生"5C"问题，也不存在像 Shift_JIS 和
    EUC-JP 那样在字符匹配时从字符中间开始匹配的问题。
    使用 UTF-8 编码方式对日语字符进行编码的时候，JIS X0208
    规定的汉字基本上都会编码为 3 字节长，JIS X 0213 规定的第 3 基准和第
    4 基准汉字会有部分编码为 4 字节。比如前面说道的"𠮷"（U+20BB7），在
    UTF-8 里会编码为"F0 A0 AE B7"4 个字节。下图 6-18
    显示的是"𠮷"字编码后的结果。
    ![{%}](Image00231.jpg)
    **图 6-18 将"𠮷田"进行 UTF-8 编码的结果**
    从整体上来说，UTF-8
    是现在字符编码里使用最方便也是最安全的编码方式，但是它也有需要注意的地方，那就是非最短形式的问题。
    -   **UTF-8 的非最短形式（non-shortest form）问题**
        我们再看一下表 6-3。在 UTF-8 里 U+007F 之前的字符都可以用 1
        个字节来表现，但是从形式上说，本来应该用 1
        个字节表示的字符，用两个字节也可以表示。接着我们可以看个具体的例子，比如表
        6-4 是把斜线"/"（U+002F）编码为 1 字节～4 字节的结果。
        **表 6-4 "/"的非最短形式**
        ![{%}](Image00232.jpg)
    -   **UTF-8 非最短形式引起的漏洞**
        有时候 UTF-8
        的非最短形式编码的数据可能会引起系统的漏洞。系统出现漏洞的流程如下。
        -   安全检查的时候并未将非最短形式 0xC0 0xAF 识别为斜线 0x2F
        -   而后续处理中将输入数据作为文件名等处理，误将 0xC0 0xAF
            作为斜线来看待
        之所以出现上面这样的结果，是因为将用 UTF-8 的非最短形式编码的
        0xC0 0xAF 机械地转换为其他编码方式（Shift_JIS、UTF-16
        等）的时候，会被转换为普通的斜线。也就是用非最短形式编码的斜线在安全检查时被遗漏，而在打开文件操作时非最短形式的斜线被当作普通的斜线处理了。如果将上面的描述画成一张图进行说明的
        话，可以参考图 6-19。
        ![{%}](Image00233.jpg)
        **图 6-19 安全检查中非最短形式编码数据被漏 掉的例子**
        由于这个问题的存在，所以在 UTF-8
        的最新标准（RFC3629）里规定必须将非最短形式的编码数据作为非法数据进行处理。然而实际上根据实际情况不同，还有很多允许非最短形式编码数据存在的系统，需要格外注意。
        下面是最近出现的允许非最短形式编码的 UTF-8
        处理而导致出现问题的例子。当然实际上出现的问题不只这些，需要我们注意时常更新软件。
        -   Java SE6 Update 10 之前的 JRE（Java 运行时环境）
        -   PHP5.3.1 以前的 `htmlspecialchars` 函数
    -   **其他非法的 UTF-8 编码**
        ISO/IEC 10646 是和 Unicode 非常相像的国际标准，在 2006
        改版之前它使用比 Unicode 更宽阔的 31
        比特空间来容纳各种字符，如果用 UTF-8 进行编码的话，1
        个字符最大可能需要 6 个字节的存储空间。但是随着 ISO/IEC 10646 在
        2006 年的改版，实质上它已经和 Unicode 是相同的字符集了，UTF-8
        编码后的最大长度也变为 4 字节了。
        但是 PHP 的字符编码方式检查函数 `mb_check_encoding`
        非常重视对老标准的兼容性，即使是 UTF-8 编码后长度为 5
        个字节的数据都认为是正常的编码数据 [11]{.注释编号} 。
        另外，如果将代理对的预分配范围（0xD800～0xDBFF 和
        0xDC00～0xDFFF）内的码位机械变换为 UTF-8 的话，会占用 3
        个字节。比如将 U+D800 机械地变成 UTF-8 编码的话会得到"ED A0
        80"，但是作为 UTF-8 来讲这个数据是非法的 UTF-8
        编码数据。在将代理对表示的字符转换为 UTF-8
        的时候，需要先将原数据进行 UTF-32 编码为 32
        位的形式，然后在转换为 UTF-8 的形式，最终编码后的长度应该为 4
        个字节。
        在 PHP5.2 之前版本的 `mb_check_encoding`
        会把上面说的直接将代理对表示的字符机械地转换为 UTF-8
        得到的数据看作是正常的数据，这个问题在 5.3.0
        及以后的版本已经被修正了。在 PHP5.2
        分支中，官方已经宣布最终支持的版本为 5.2.17
        了，所以强烈推荐升级到 5.3 以后的新版本。
-   **GB2312**
    GB2312 中对所收录的汉字进行了"分区"处理，每区含有 94 个汉字 /
    符号，这种表示方式也称为区位码。具体分区情况如下。
    -   01～09 区为符号和数字
    -   16～55 区为一级汉字，按拼音排序
    -   56～87 区为二级汉字，按部首 / 笔画排序
    -   88～94 区为有待进一步标准化的空白区
    在 GB2312
    编码中，每个汉字及符号使用两个字节来表示。其中第一个字节称为"高位字节"，第二个字节称为"低位字节"。
    高位字节的编码范围为 0xA1～0xF7（将 01～87 区的区号加上
    0xA0），低位字节则使用了 0xA1～0xFE。由于一级汉字从 16
    区起始，因此汉字区的高位字节的范围是 0xB0～0xF7，低位字节的范围是
    0xA1～0xFE。
    以"安"字为例，它在 GB2312 字符集中的区位码为 1618，分别加上 0xA1
    后，就可以得到它在 GB2312 中的编码为 0xB0B2（0xB0 = 0xA1 + 16，0xB2
    = 0xA1 + 18）。
    -   **对字符匹配的影响**
        GB2312 编码也存在和 EUC-JP
        类似的问题，即它的第一个字节和第二个字节的范围是互相重叠的。我们也可以参考上面的例子，编写如下测试代码。
        ``` 代码无行号
         1\. 字符编码方式中非法数据导致的漏洞