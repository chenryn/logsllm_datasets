Application Report
SPRAAO8–April 2009
Common Object File Format
.....................................................................................................................................................
ABSTRACT
The assembler and link step create object files in common object file format (COFF).
COFF is an implementation of an object file format of the same name that was
developed by AT&T for use on UNIX-based systems. This format encourages modular
programming and provides powerful and flexible methods for managing code segments
and target system memory.
This appendix contains technical details about the Texas Instruments COFF object file
structure. Much of this information pertains to the symbolic debugging information that
is produced by the C compiler. The purpose of this application note is to provide
supplementary information on the internal format of COFF object files.
Topic ..................................................................................................
Page
1
COFF File Structure .................................................................... 2
2
File Header Structure .................................................................. 4
3
Optional File Header Format ........................................................ 5
4
Section Header Structure............................................................. 5
5
Structuring Relocation Information............................................... 7
6
Symbol Table Structure and Content........................................... 11
SPRAAO8–April 2009
Common Object File Format
1
Submit Documentation Feedback
1
COFF File Structure
Fileheader
Optionalfileheader
Section1header
Section n header
Section1
rawdata
Section n
rawdata
Section1
relocationinformation
Section n
relocationinformation
Symboltable
Stringtable
Sectionheaders
Rawdata
(executablecodeand
initializeddata)
Relocation
information
COFF File Structure
www.ti.com
The elements of a COFF object file describe the file's sections and symbolic debugging information. These
elements include:
•
A file header
•
Optional header information
•
A table of section headers
•
Raw data for each initialized section
•
Relocation information for each initialized section
•
A symbol table
•
A string table
The assembler and link step produce object files with the same COFF structure; however, a program that
is linked for the final time does not usually contain relocation entries. Figure 1 illustrates the object file
structure.
Figure 1. COFF File Structure
Figure 2 shows a typical example of a COFF object file that contains the three default sections, .text,
.data, and .bss, and a named section (referred to as ). By default, the tools place sections into
the object file in the following order: .text, .data, initialized named sections, .bss, and uninitialized named
sections. Although uninitialized sections have section headers, notice that they have no raw data,
relocation information, or line number entries. This is because the .bss and .usect directives simply
reserve space for uninitialized data; uninitialized sections contain no actual code.
Common Object File Format
2
SPRAAO8–April 2009
Submit Documentation Feedback
Fileheader
.text
sectionheader
.data
sectionheader
.bss
sectionheader
section
sectionheader
.text
rawdata
.data
rawdata
section
rawdata
.text
relocationinformation
.data
relocationinformation
section
relocationinformation
Symboltable
Stringtable
Sectionheaders
Rawdata
Relocation
information
www.ti.com
COFF File Structure
Figure 2. Sample COFF Object File
SPRAAO8–April 2009
Common Object File Format
3
Submit Documentation Feedback
2
File Header Structure
File Header Structure
www.ti.com
The file header contains 22 bytes of information that describe the general format of an object file. Table 1
shows the structure of the COFF file header.
Table 1. File Header Contents
Byte Number
Type
Description
0-1
Unsigned short
Version ID; indicates version of COFF file structure
2-3
Unsigned short
Number of section headers
4-7
Integer
Time and date stamp; indicates when the file was created
8-11
Integer
File pointer; contains the symbol table's starting address
12-15
Integer
Number of entries in the symbol table
16-17
Unsigned short
Number of bytes in the optional header. This field is either 0 or 28; if it is 0, there is no
optional file header.
18-19
Unsigned short
Flags (see Table 2)
20-21
Unsigned short
Target ID; magic number (see Table 3) indicates the file can be executed in a specific TI
system
Table 2 lists the flags that can appear in bytes 18 and 19 of the file header. Any number and combination
of these flags can be set at the same time.
Table 2. File Header Flags (Bytes 18 and 19)
Mnemonic
Flag
Description
F_RELFLG
0001h
Relocation information was stripped from the file
F_EXEC
0002h
The file is relocatable (it contains no unresolved external references)
F_LNNO(1)
0004h
For TMS430 and TMS470 only: Line numbers were stripped from the file. For
other targets: Reserved
F_LSYMS
0008h
Local symbols were stripped from the file
F_LITTLE
0100h
The target is a little-endian device
F_BIG(1)
0200h
For C6000, MSP430, and TMS470 only: The target is a big-endian device. For
other targets: Reserved
F_SYMMERGE(1)
1000h
For C2800, MSP430, and TMS470: Duplicate symbols were removed. For
C6000: Reserved
(1)
No mnemonic is defined when the flag value is reserved.
Table 3 lists the magic number for each Texas Instruments device family.
Table 3. Magic Number
Magic Number
Device Family
0097h
TMS470
0098h
TMS320C5400
0099h
TMS320C6000
009Ch
TMS320C5500
009Dh
TMS320C2800
00A0h
MSP430
00A1h
TMS320C5500+
4
Common Object File Format
SPRAAO8–April 2009
Submit Documentation Feedback
3
Optional File Header Format
4
Section Header Structure
www.ti.com
Optional File Header Format
The link step creates the optional file header and uses it to perform relocation at download time. Partially
linked files do not contain optional file headers. Table 4 illustrates the optional file header format.
Table 4. Optional File Header Contents
Byte Number
Type
Description
0-1
Short
Optional file header magic number (0108h)
2-3
Short
Version stamp
4-7
Long(1)
Size (in bytes) of executable code
8-11
Long(1)
Size (in bytes) of initialized data
12-15
Long(1)
Size (in bytes) of uninitialized data
16-19
Long(1)
Entry point
20-23
Long(1)
Beginning address of executable code
24-27
Long(1)
Beginning address of initialized data
(1)
For C6000 the type is integer.
COFF object files contain a table of section headers that define where each section begins in the object
file. Each section has its own section header. Table 5 shows the structure of each section header.
Table 5. Section Header Contents
Byte Number
Type
Description
0-7
Character
This field contains one of the following: 1) An 8-character section name padded
with nulls. 2) A pointer into the string table if the symbol name is longer than
eight characters.
8-11
Long(1)
Section's physical address
12-15
Long(1)
Section's virtual address
16-19
Long(1)
Section size in bytes (C6000, C55x, TMS470 and TMS430) or words (C2800,
C5400)
20-23
Long(1)
File pointer to raw data
24-27
Long(1)
File pointer to relocation entries
28-31
Long(1)
Reserved
32-35
Unsigned long(2)
Number of relocation entries
36-39
Unsigned long(2)
For TMS470 and TMS430 only: Number of line number entries. For other
devices: Reserved
40-43
Unsigned long(2)
Flags (see Table 7)
44-45
Unsigned short
Reserved
46-47
Unsigned short
Memory page number
(1)
For C6000 the type is integer.
(2)
For C6000 the type is unsigned integer.
For C5400 only, object files can be produced in either of two formats: COFF1 or COFF2. For all other
device families all COFF object files are in the COFF2 format. The COFF1 and COFF2 file types contain
different section header information. Table 6 shows the section header contents for COFF1 files. Table 5
shows the section header contents for COFF2 files.
SPRAAO8–April 2009
Common Object File Format
5
Submit Documentation Feedback
Section Header Structure
www.ti.com
Table 6. Section Header Contents for COFF1
Byte Number
Type
Description
0-7
Character
An 8-character section name padded with nulls.
8-11
Long
Section's physical address
12-15
Long
Section's virtual address
16-19
Long
Section size in words
20-23
Long
File pointer to raw data
24-27
Long
File pointer to relocation entries
28-31
Long
Reserved
32-33
Unsigned short
Number of relocation entries
34-35
Unsigned short
Reserved
36-37
Unsigned short
Flags (see Table 7)
38
Char
Reserved
39
Char
Memory page number
Table 7 lists the flags that can appear in bytes 40 through 43 (36-37 for COFF1) of the section header.
Table 7. Section Header Flags
Mnemonic
Flag
Description (1)
STYP_REG
00000000h
Regular section (allocated, relocated, loaded)
STYP_DSECT
00000001h
Dummy section (relocated, not allocated, not loaded)
STYP_NOLOAD
00000002h
Noload section (allocated, relocated, not loaded)
STYP_GROUP(2)
00000004h
Grouped section (formed from several input sections). Other devices:
Reserved
STYP_PAD(2)
00000008h
Padding section (loaded, not allocated, not relocated). Other devices:
Reserved
STYP_COPY
00000010h
Copy section (relocated, loaded, but not allocated; relocation entries
are processed normally)
STYP_TEXT
00000020h
Section contains executable code
STYP_DATA
00000040h
Section contains initialized data
STYP_BSS
00000080h
Section contains uninitialized data
STYP_BLOCK(3)
00001000h
Alignment used as a blocking factor.
STYP_PASS(3)
00002000h
Section should pass through unchanged.
STYP_CLINK
00004000h
Section requires conditional linking
STYP_VECTOR(4)
00008000h
Section contains vector table.
STYP_PADDED(4)
00010000h
section has been padded.
(1)
The term loaded means that the raw data for this section appears in the object file. Only allocated sections are written to target
memory.
(2)
Applies to C2800, C5400, and C5500 only.
(3)
Reserved for C2800, C5400, and C5500.
(4)
Applies to C6000 only.
The flags listed in Table 7 can be combined; for example, if the flag's word is set to 060h, both
STYP_DATA and STYP_TEXT are set.
Bits 8-11 of the section header flags are used for defining the alignment. The alignment is defined to be
2^(value of bits 8-11). For example if bits 8-11 are 0101b (decimal integer 5), then the alignment is 32
(2^5).
For MSP430 and TMS470, alignment is indicated by the bits masked by 0xF00. Alignment is the value in
the bits raised to a power equal to the bit value. Alignment is 2 raised to the same power. For example, if
the value in these 4 bits is 2, the alignment is 2 raised to the power 2 (or 4).
Figure 3 illustrates how the pointers in a section header point to the elements in an object file that are
associated with the .text section.
6
Common Object File Format