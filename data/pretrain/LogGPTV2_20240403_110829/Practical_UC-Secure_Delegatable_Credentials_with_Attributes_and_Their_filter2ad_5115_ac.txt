functionality ℱca as defined in [15].
Functionality ℱca
(1) Upon receiving the first message (REGISTER, sid, v) from
party 𝒫, send (REGISTERED, sid, v) to the adversary 𝒜;
upon receiving OK from 𝒜, and if sid = 𝒫 and this is the
first request from 𝒫, then record the pair (𝒫, v).
(2) Upon receiving a message (RETRIEVE, sid) from party
𝒫′, send (RETRIEVE, sid,𝒫′) to 𝒜, and wait for an OK
from 𝒜. Then, if there is a recorded pair (sid, v) output
(RETRIEVE, sid, v) to 𝒫′. Else output (RETRIEVE, sid,⊥)
to 𝒫′.
Ideal Functionality ℱsmt. We use the secure message transmis-
sion functionality as defined in the 2005 version of UC [13]. Func-
is parameterized by a leakage function l : {0, 1}∗ →
tionality ℱ l
{0, 1}∗ that leaks information about the transmitted message, for
example a message length.
smt
Functionality ℱsmt
(1) On input (SEND, sid, m) from a party 𝒫, abort if sid (cid:44)
(𝒮,ℛ, sid′), send (SEND, sid, l(m)) to the adversary, gen-
erate a private delayed output (SENT, sid, m) to ℛ and
halt.
3 DEFINITION OF DELEGATABLE
CREDENTIALS
We now define delegatable credentials in the form of an ideal func-
tionality ℱdac. For simplicity we consider the functionality with a
single root delegator (issuer), but using multiple instances of ℱdac
allows for many issuers. ℱdac allows for multiple levels delegation.
A Level-1 credential is issued directly by the issuer. Any further
Session C5:  Using BlockchainsCCS’17, October 30-November 3, 2017, Dallas, TX, USA687(1) Setup. On input (SETUP, sid, ⟨ni⟩i) from ℐ.
• Verify that sid = (ℐ, sid′).
• Output (SETUP, sid, ⟨ni⟩i) to 𝒜 and wait for response
(SETUP, sid, Present, Ver, ⟨Ai⟩i) from 𝒜.
• Store algorithms Present and Ver and credential pa-
rameters ⟨Ai⟩i , ⟨ni⟩i, initialize ℒde ← ∅ ; ℒat ← ∅.
• Output (SETUPDONE, sid) to ℐ.
(2) Delegate. On input(DELEGATE, sid, ssid, (cid:174)a1, . . . , (cid:174)aL,𝒫j)
from some party 𝒫i, with (cid:174)aL ∈ AnL
• If L = 1, check sid = (𝒫i , sid′) and add an entry
⟨𝒫j , (cid:174)a1⟩ to ℒde.
• If L > 1, check that an entry ⟨𝒫i , (cid:174)a1, . . . , (cid:174)aL−1⟩ exists
in ℒde.
• Output (ALLOWDEL, sid, ssid,𝒫i ,𝒫j , L) to 𝒜 and
wait for input (ALLOWDEL, sid, ssid) from 𝒜.
• Add an entry ⟨𝒫j , (cid:174)a1, . . . , (cid:174)aL⟩ to ℒde.
• Output (DELEGATE, sid, ssid, (cid:174)a1, . . . , (cid:174)aL,𝒫i) to 𝒫j.
L
.
(3) Present. On input (PRESENT, sid, m, (cid:174)a1, . . . , (cid:174)aL) from
some party 𝒫i, with (cid:174)ai ∈ (Ai ∪ ⊥)ni for i = 1, . . . , L.
• Check that an entry ⟨𝒫i , (cid:174)a′
L⟩ exists in ℒde such
′ for i = 1, . . . , L.
that (cid:174)ai ≼ (cid:174)ai
• Set at ← Present(m, (cid:174)a1, . . . , (cid:174)aL) and abort
if
Ver(at, m, (cid:174)a1, . . . , (cid:174)aL) = 0.
• Store ⟨m, (cid:174)a1, . . . , (cid:174)aL⟩ in ℒat.
• Output (TOKEN, sid, at) to 𝒫i.
1, . . . , (cid:174)a′
(4) Verify. On input (VERIFY, sid, at, m, (cid:174)a1, . . . , (cid:174)aL) from
some party 𝒫i.
• If there is no record ⟨m, (cid:174)a1, . . . , (cid:174)aL⟩ in ℒat, ℐ is honest,
and for i = 1, . . . , L, there is no corrupt 𝒫j such that
⟨𝒫j , (cid:174)a′
i⟩ ∈ ℒde with (cid:174)aj ≼ (cid:174)a′
for j = 1, . . . , i,
set f ← 0.
• Else, set f ← Ver(at, m, (cid:174)a1, . . . , (cid:174)aL).
• Output (VERIFIED, sid, f ) to 𝒫i.
1, . . . , (cid:174)a′
j
Figure 1: Ideal functionality for delegatable credentials with attributes ℱdac
delegations are done between users: the owner of a Level-(L − 1)
credential can delegate it further, giving the receiver a Level L cre-
dential. ℱdac supports attributes on every level; attributes can be
selectively disclosed during credential presentation. A presentation
of a delegated credential creates a so-called attribute token, which
can be verified with respect to the identity of the issuer, hiding the
identity of the delegators.
ℱdac interacts with the issuer ℐ and parties 𝒫i who can delegate,
present, and verify the credentials through the following four in-
terfaces: SETUP, DELEGATE, PRESENT, VERIFY, that we describe
here. The formal definition is presented in Fig. 1, where we use
two conventions that ease the notation. First, the SETUP interface
can only be called once, and all other interfaces ignore all input
until a SETUP message has been completed. Second, whenever
ℱdac performs a check, it means that if the check fails, it aborts by
outputting ⊥ to the caller.
Setup. The SETUP message is sent by the issuer ℐ, whose identity
is fixed in the session identifier sid: ℱdac first checks that sid =
(ℐ, sid′), which guarantees that each issuer can initialize its own
instance of the functionality. The issuer defines the number of
attributes for every delegation level i by specifying ⟨ni⟩i. This can
be done efficiently by describing a function f (i). We fix the number
of attributes on the same delegation level since different number of
attributes used by different delegators on the same level may leak
information about the delegators. ℐ does not need to specify the
maximum number of the delegation levels.
ℱdac then asks the adversary for algorithms and credential pa-
rameters. The adversary provides algorithms Present, Ver for pre-
senting and verifying attribute tokens, respectively, and specifies
the attribute spaces ⟨Ai⟩i for different credential levels. ℱdac stores
Present, Ver, ⟨Ai⟩i , ⟨ni⟩i and initializes two empty sets: ℒde for
delegation and ℒat for presentation bookkeeping.
Delegate. The DELEGATE message is sent by a user 𝒫i with a
Level-(L − 1) credential to delegate it to a user 𝒫j, giving 𝒫j a
Level-L credential. 𝒫i specifies a list of attribute vectors for all the
previous levels in the delegation chain (cid:174)a1, . . . , (cid:174)aL−1 and the vector
of attributes (cid:174)aL to certify in a freshly delegated Level-L credential.
All attribute vectors should satisfy the corresponding attribute
space and length requirements. We use subsession identifiers in this
interface since multiple delegation sessions might be interleaved
due to the communication with the adversary. If this delegation
gives 𝒫j a Level-1 credential, then ℱdac verifies that party 𝒫i is
the issuer by checking the sid and adds an entry ⟨𝒫j , (cid:174)a1⟩ to ℒde.
If this is not the first level delegation (L > 1), ℱdac checks if 𝒫i
indeed has a Level-(L − 1) credential with the specified attributes
(cid:174)a1, . . . , (cid:174)aL−1 by looking it up in ℒde. ℱdac then asks the adversary
if the delegation should proceed and, after receiving a response
from 𝒜, adds the corresponding delegation record to ℒde and sends
the output that includes the full attribute chain to 𝒫j, notifying it
of the successful delegation.
Note that in contrast to previous work on delegatable credentials,
we model no privacy in delegation. That is, 𝒫i and 𝒫j will learn
the identity of eachother during delegation. While this is a weaker
privacy definition than previous definitions, we think privacy for
delegation is not neccesary. in real-world scenarios, the delegator
and delegatee will typically know eachother when a credential with
attributes is delegated.
Present. The PRESENT message is sent by a user 𝒫i to create
an attribute token. A token selectively reveals attributes from the
delegated credential and also signs a message m, which can be an
arbitrary string. 𝒫i inputs attribute vectors by specifying only the
values of the disclosed attributes and using special symbol ⊥ to
indicate the hidden attributes. ℱdac checks if a delegation entry
exists in ℒde such that the corresponding disclosed attributes were
indeed delegated to 𝒫i. For this, it uses the following relation for
Session C5:  Using BlockchainsCCS’17, October 30-November 3, 2017, Dallas, TX, USA688attribute vectors: We say that for two vectors (cid:174)a = (a1, . . . , an) ; (cid:174)b =
(b1, . . . , bn) : (cid:174)a ≼ (cid:174)b if ai = bi or ai = ⊥ for i = 1, . . . , n.
If this is the case it runs the Present algorithm to generate the
attribute token. The Present algorithm does not take the identity
of the user and the non-disclosed attributes as input - the attribute
token is computed independently of these values. This ensures the
user’s privacy and hiding the non-disclosed attributes on all levels
of the delegated credential chain. Next, it checks that the computed
attribute token is valid using the Ver algorithm, which ensures
completeness. It outputs the token value to user 𝒫i.
Verify. The VERIFY message is sent by a user 𝒫i to verify an at-
tribute token. Message m and the disclosed attribute values are also
provided as input for verification. ℱdac performs the unforgeability
check: if the message together with the corresponding disclosed
attribute values were not signed by calling the PRESENT interface
(there is no corresponding bookkeeping record), the issuer is hon-
est, and on any delegation level there is no corrupted party with
the matching attributes, then ℱdac outputs a negative verification
result; otherwise, ℱdac runs the verification algorithm and outputs
the result to 𝒫i.
Our ideal functionality ℱdac can be easily extended to also accept
as input and output commitments to attribute values, following the
recent work by Camenisch et al. [7], which would allow extending
our delegatable credential scheme with existing revocation schemes
for anonymous credentials in a hybrid protocol.
4 A GENERIC CONSTRUCTION FOR
DELEGATABLE CREDENTIALS
In this section, we provide a generic construction for delegatable
anonymous credentials with attributes. We first explain the intu-
ition behind our construction, then present a construction based on
sibling signatures defined in Section 2.5 and non-interactive zero-
knowledge proofs. Then we prove that our generic construction
securely realizes ℱdac. We provide an efficient instantiation of our
generic construction in the next section.
4.1 Construction Overview
Recall that our definition of delegatable credentials allows for multi-
ple levels of delegation. There is a root delegator (also called issuer)
that issues Level-1 credentials to users. Users can delegate their
Level-L credential, resulting in a Level-(L + 1) credential. We now
explain on a high level how a user obtains a Level-1 credential and
then that credential is delegated. It is then easy to see how a Level-L
credential is delegated (this is also depicted in Fig. 2).
The issuer first generates a signing key isk and corresponding
verification key ipk and publishes ipk, after which it can issue a
Level-1 credential to a user. The user, to get Level-1 credential
issued, generates a fresh secret and a public key (csk1, cpk1) for this
credential and sends public key cpk1 to the root delegator. The root
delegator signs this public key together with a set of attributes (cid:174)a1
and sends the signature σ1 back to the user. A Level-1 credential
cred1 consists of the signature σ1, attributes (cid:174)a1, and credential keys
(cpk1, csk1).
The user can delegate cred1 further to another user by issu-
ing a Level-2 credential. The receiver generates a fresh key pair
(csk2, cpk2) for the Level-2 credential. The delegation is done by
signing public key cpk2 and a set of attributes (cid:174)a2 (chosen by the
delegator) with the Level-1 credential secret key csk1. The resulting
signature σ2 is sent back together with the attributes (cid:174)a2 and the orig-
inal signature σ1, and the corresponding attributes (cid:174)a1. The Level-
2 credential consists of both signatures σ1, σ2, attributes (cid:174)a1, (cid:174)a2,
and keys cpk1, cpk2, csk2. Note that the Level-2 credential is a
chain of two so-called credential links. The first link, consisting of
(σ1, (cid:174)a1, cpk1) proves that the delegator has a Level-1 credential con-
taining attributes (cid:174)a1. The second link, (σ2, (cid:174)a2, cpk2), proves that this
delegator issued attributes (cid:174)a2 to the owner of cpk2. The key csk2
allows the user to prove he is the owner of this Level-2 credential.
Note, that the Level-1 credential secret key csk1 is not sent together
with the signature and the credential link, so that it is impossible
for a user who owns the Level-2 credential to present or delegate
the Level-1 credential.
The Level-2 credential can be delegated further in the analogous
way by generating a signature on attributes and a public key and
sending them together with lower-level credential links. A Level-L
credential is therefore a chain of the L credential links, where every
link adds a number of attributes (cid:174)ai, and a secret key cskL that allows
the owner to present the credential or to delegate it further.
A credential of any level can be presented by its owner by gener-
ating a NIZK proof proving a possession of all credential links back
to the issuer and selectively disclosing attributes from the corre-
sponding signatures. This proof, that we call an attribute token, can
be verified with the public key of only the issuer. The public keys of
all the credential links remain hidden in the zero-knowledge proof
and, therefore, the identities of all the intermediate delegators are
not revealed by the attribute token.
4.2 Generic Construction
Our generic construction Πdac is based on secure sibling signature
schemes, where Sign1 signs vectors of messages. We allow different
Figure 2: Our Generic Construction: Delegation
Issueripk,isk~a1012L−1Lcpk1,csk1σ1=Signisk(cpk1,~a1)Level~a2cpk2,csk2σ2=Signcsk1(cpk2,~a2)cpkL,cskLcpkL−1,cskL−1~aLcredL=(hσi,~ai,cpkiiLi=1,cskL)σL=SigncskL−1(cpkL,~aL).........Session C5:  Using BlockchainsCCS’17, October 30-November 3, 2017, Dallas, TX, USA689sibling signature schemes to be used at different delegation levels.
Let Sibi denote the scheme used by the owners of Level-i credentials.
As we sign public keys of another signature scheme and the attribute
values, the different signature schemes must be compatible with
each other: The public key space of Sibi +1 must be included in the
message space ℳ1 of Sibi. It follows that the attribute space Ai is
the message space of Sibi−1.
The required system parameters for the signature schemes are
taken from ℱcrs. We implicitly assume that every protocol par-
ticipant queries ℱca to retrieve the issuer public key and ℱcrs to
retrieve the system parameters, and that the system parameters
are passed as an implicit input to every algorithm of the signature
schemes.
Setup. In the setup phase, the issuer ℐ creates his key pair and
registers this with the CA functionality ℱca.
(1) ℐ, upon receiving input (SETUP, sid, ⟨ni⟩i):
• Check that sid = ℐ, sid′ for some sid′.
• Run (ipk, isk) ← Sib0.Gen(1κ) and compute proof πisk ←
NIZK{ isk : (ipk, isk) ∈ Sib0.Gen(1κ)}. Register public key
(ipk, πisk) with ℱca. Let cpk0 ← ipk.
• Output (SETUPDONE, sid).
Delegate. Any user 𝒫i with a Level-L − 1 credential can delegate
this credential to another user 𝒫j, giving 𝒫j a Level-L credential.
Delegator 𝒫i can choose the attributes he adds in this delegation.
Note that only the issuer ℐ can issue a Level-1 credential, so we
distinguish two cases: issuance (delegation of a Level-1 credential)
and delegation of credential of level L > 1.
(2) 𝒫i on input (DELEGATE, sid, ssid, (cid:174)a1, . . . , (cid:174)aL,𝒫j) with (cid:174)aL ∈
AnL
• If L = 1, 𝒫i only proceeds if he is the issuer ℐ with sid =
L
(ℐ, sid′). If L > 1, 𝒫i checks that he possesses a credential
chain that signs (cid:174)a1, . . . , (cid:174)aL−1. That is, he looks up a record
cred = (⟨σi , (cid:174)ai , cpki⟩L−1
i =1 , cskL−1) in ℒcred.
• Send (sid, ssid, (cid:174)a1, . . . , (cid:174)aL) to 𝒫j over ℱsmt.
• 𝒫j, upon receiving (sid, ssid, (cid:174)a1, . . . , (cid:174)aL) to 𝒫j over ℱsmt from
𝒫i, generate a fresh credential specific key pair(cpkL, cskL) ←
SibL .Gen(1κ).
• Send cpkL to 𝒫i over ℱsmt.
• 𝒫i, upon receiving cpkL from 𝒫j over ℱsmt, computes σL ←
SibL−1.Sign1(cskL−1; cpkL, (cid:174)aL) and sends ⟨σi , cpki⟩L
i =1 to 𝒫j