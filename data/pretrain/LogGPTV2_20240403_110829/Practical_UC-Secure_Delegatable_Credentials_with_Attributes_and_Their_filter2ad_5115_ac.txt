functionality â„±ca as defined in [15].
Functionality â„±ca
(1) Upon receiving the first message (REGISTER, sid, v) from
party ğ’«, send (REGISTERED, sid, v) to the adversary ğ’œ;
upon receiving OK from ğ’œ, and if sid = ğ’« and this is the
first request from ğ’«, then record the pair (ğ’«, v).
(2) Upon receiving a message (RETRIEVE, sid) from party
ğ’«â€², send (RETRIEVE, sid,ğ’«â€²) to ğ’œ, and wait for an OK
from ğ’œ. Then, if there is a recorded pair (sid, v) output
(RETRIEVE, sid, v) to ğ’«â€². Else output (RETRIEVE, sid,âŠ¥)
to ğ’«â€².
Ideal Functionality â„±smt. We use the secure message transmis-
sion functionality as defined in the 2005 version of UC [13]. Func-
is parameterized by a leakage function l : {0, 1}âˆ— â†’
tionality â„± l
{0, 1}âˆ— that leaks information about the transmitted message, for
example a message length.
smt
Functionality â„±smt
(1) On input (SEND, sid, m) from a party ğ’«, abort if sid (cid:44)
(ğ’®,â„›, sidâ€²), send (SEND, sid, l(m)) to the adversary, gen-
erate a private delayed output (SENT, sid, m) to â„› and
halt.
3 DEFINITION OF DELEGATABLE
CREDENTIALS
We now define delegatable credentials in the form of an ideal func-
tionality â„±dac. For simplicity we consider the functionality with a
single root delegator (issuer), but using multiple instances of â„±dac
allows for many issuers. â„±dac allows for multiple levels delegation.
A Level-1 credential is issued directly by the issuer. Any further
Session C5:  Using BlockchainsCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA687(1) Setup. On input (SETUP, sid, âŸ¨niâŸ©i) from â„.
â€¢ Verify that sid = (â„, sidâ€²).
â€¢ Output (SETUP, sid, âŸ¨niâŸ©i) to ğ’œ and wait for response
(SETUP, sid, Present, Ver, âŸ¨AiâŸ©i) from ğ’œ.
â€¢ Store algorithms Present and Ver and credential pa-
rameters âŸ¨AiâŸ©i , âŸ¨niâŸ©i, initialize â„’de â† âˆ… ; â„’at â† âˆ….
â€¢ Output (SETUPDONE, sid) to â„.
(2) Delegate. On input(DELEGATE, sid, ssid, (cid:174)a1, . . . , (cid:174)aL,ğ’«j)
from some party ğ’«i, with (cid:174)aL âˆˆ AnL
â€¢ If L = 1, check sid = (ğ’«i , sidâ€²) and add an entry
âŸ¨ğ’«j , (cid:174)a1âŸ© to â„’de.
â€¢ If L > 1, check that an entry âŸ¨ğ’«i , (cid:174)a1, . . . , (cid:174)aLâˆ’1âŸ© exists
in â„’de.
â€¢ Output (ALLOWDEL, sid, ssid,ğ’«i ,ğ’«j , L) to ğ’œ and
wait for input (ALLOWDEL, sid, ssid) from ğ’œ.
â€¢ Add an entry âŸ¨ğ’«j , (cid:174)a1, . . . , (cid:174)aLâŸ© to â„’de.
â€¢ Output (DELEGATE, sid, ssid, (cid:174)a1, . . . , (cid:174)aL,ğ’«i) to ğ’«j.
L
.
(3) Present. On input (PRESENT, sid, m, (cid:174)a1, . . . , (cid:174)aL) from
some party ğ’«i, with (cid:174)ai âˆˆ (Ai âˆª âŠ¥)ni for i = 1, . . . , L.
â€¢ Check that an entry âŸ¨ğ’«i , (cid:174)aâ€²
LâŸ© exists in â„’de such
â€² for i = 1, . . . , L.
that (cid:174)ai â‰¼ (cid:174)ai
â€¢ Set at â† Present(m, (cid:174)a1, . . . , (cid:174)aL) and abort
if
Ver(at, m, (cid:174)a1, . . . , (cid:174)aL) = 0.
â€¢ Store âŸ¨m, (cid:174)a1, . . . , (cid:174)aLâŸ© in â„’at.
â€¢ Output (TOKEN, sid, at) to ğ’«i.
1, . . . , (cid:174)aâ€²
(4) Verify. On input (VERIFY, sid, at, m, (cid:174)a1, . . . , (cid:174)aL) from
some party ğ’«i.
â€¢ If there is no record âŸ¨m, (cid:174)a1, . . . , (cid:174)aLâŸ© in â„’at, â„ is honest,
and for i = 1, . . . , L, there is no corrupt ğ’«j such that
âŸ¨ğ’«j , (cid:174)aâ€²
iâŸ© âˆˆ â„’de with (cid:174)aj â‰¼ (cid:174)aâ€²
for j = 1, . . . , i,
set f â† 0.
â€¢ Else, set f â† Ver(at, m, (cid:174)a1, . . . , (cid:174)aL).
â€¢ Output (VERIFIED, sid, f ) to ğ’«i.
1, . . . , (cid:174)aâ€²
j
Figure 1: Ideal functionality for delegatable credentials with attributes â„±dac
delegations are done between users: the owner of a Level-(L âˆ’ 1)
credential can delegate it further, giving the receiver a Level L cre-
dential. â„±dac supports attributes on every level; attributes can be
selectively disclosed during credential presentation. A presentation
of a delegated credential creates a so-called attribute token, which
can be verified with respect to the identity of the issuer, hiding the
identity of the delegators.
â„±dac interacts with the issuer â„ and parties ğ’«i who can delegate,
present, and verify the credentials through the following four in-
terfaces: SETUP, DELEGATE, PRESENT, VERIFY, that we describe
here. The formal definition is presented in Fig. 1, where we use
two conventions that ease the notation. First, the SETUP interface
can only be called once, and all other interfaces ignore all input
until a SETUP message has been completed. Second, whenever
â„±dac performs a check, it means that if the check fails, it aborts by
outputting âŠ¥ to the caller.
Setup. The SETUP message is sent by the issuer â„, whose identity
is fixed in the session identifier sid: â„±dac first checks that sid =
(â„, sidâ€²), which guarantees that each issuer can initialize its own
instance of the functionality. The issuer defines the number of
attributes for every delegation level i by specifying âŸ¨niâŸ©i. This can
be done efficiently by describing a function f (i). We fix the number
of attributes on the same delegation level since different number of
attributes used by different delegators on the same level may leak
information about the delegators. â„ does not need to specify the
maximum number of the delegation levels.
â„±dac then asks the adversary for algorithms and credential pa-
rameters. The adversary provides algorithms Present, Ver for pre-
senting and verifying attribute tokens, respectively, and specifies
the attribute spaces âŸ¨AiâŸ©i for different credential levels. â„±dac stores
Present, Ver, âŸ¨AiâŸ©i , âŸ¨niâŸ©i and initializes two empty sets: â„’de for
delegation and â„’at for presentation bookkeeping.
Delegate. The DELEGATE message is sent by a user ğ’«i with a
Level-(L âˆ’ 1) credential to delegate it to a user ğ’«j, giving ğ’«j a
Level-L credential. ğ’«i specifies a list of attribute vectors for all the
previous levels in the delegation chain (cid:174)a1, . . . , (cid:174)aLâˆ’1 and the vector
of attributes (cid:174)aL to certify in a freshly delegated Level-L credential.
All attribute vectors should satisfy the corresponding attribute
space and length requirements. We use subsession identifiers in this
interface since multiple delegation sessions might be interleaved
due to the communication with the adversary. If this delegation
gives ğ’«j a Level-1 credential, then â„±dac verifies that party ğ’«i is
the issuer by checking the sid and adds an entry âŸ¨ğ’«j , (cid:174)a1âŸ© to â„’de.
If this is not the first level delegation (L > 1), â„±dac checks if ğ’«i
indeed has a Level-(L âˆ’ 1) credential with the specified attributes
(cid:174)a1, . . . , (cid:174)aLâˆ’1 by looking it up in â„’de. â„±dac then asks the adversary
if the delegation should proceed and, after receiving a response
from ğ’œ, adds the corresponding delegation record to â„’de and sends
the output that includes the full attribute chain to ğ’«j, notifying it
of the successful delegation.
Note that in contrast to previous work on delegatable credentials,
we model no privacy in delegation. That is, ğ’«i and ğ’«j will learn
the identity of eachother during delegation. While this is a weaker
privacy definition than previous definitions, we think privacy for
delegation is not neccesary. in real-world scenarios, the delegator
and delegatee will typically know eachother when a credential with
attributes is delegated.
Present. The PRESENT message is sent by a user ğ’«i to create
an attribute token. A token selectively reveals attributes from the
delegated credential and also signs a message m, which can be an
arbitrary string. ğ’«i inputs attribute vectors by specifying only the
values of the disclosed attributes and using special symbol âŠ¥ to
indicate the hidden attributes. â„±dac checks if a delegation entry
exists in â„’de such that the corresponding disclosed attributes were
indeed delegated to ğ’«i. For this, it uses the following relation for
Session C5:  Using BlockchainsCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA688attribute vectors: We say that for two vectors (cid:174)a = (a1, . . . , an) ; (cid:174)b =
(b1, . . . , bn) : (cid:174)a â‰¼ (cid:174)b if ai = bi or ai = âŠ¥ for i = 1, . . . , n.
If this is the case it runs the Present algorithm to generate the
attribute token. The Present algorithm does not take the identity
of the user and the non-disclosed attributes as input - the attribute
token is computed independently of these values. This ensures the
userâ€™s privacy and hiding the non-disclosed attributes on all levels
of the delegated credential chain. Next, it checks that the computed
attribute token is valid using the Ver algorithm, which ensures
completeness. It outputs the token value to user ğ’«i.
Verify. The VERIFY message is sent by a user ğ’«i to verify an at-
tribute token. Message m and the disclosed attribute values are also
provided as input for verification. â„±dac performs the unforgeability
check: if the message together with the corresponding disclosed
attribute values were not signed by calling the PRESENT interface
(there is no corresponding bookkeeping record), the issuer is hon-
est, and on any delegation level there is no corrupted party with
the matching attributes, then â„±dac outputs a negative verification
result; otherwise, â„±dac runs the verification algorithm and outputs
the result to ğ’«i.
Our ideal functionality â„±dac can be easily extended to also accept
as input and output commitments to attribute values, following the
recent work by Camenisch et al. [7], which would allow extending
our delegatable credential scheme with existing revocation schemes
for anonymous credentials in a hybrid protocol.
4 A GENERIC CONSTRUCTION FOR
DELEGATABLE CREDENTIALS
In this section, we provide a generic construction for delegatable
anonymous credentials with attributes. We first explain the intu-
ition behind our construction, then present a construction based on
sibling signatures defined in Section 2.5 and non-interactive zero-
knowledge proofs. Then we prove that our generic construction
securely realizes â„±dac. We provide an efficient instantiation of our
generic construction in the next section.
4.1 Construction Overview
Recall that our definition of delegatable credentials allows for multi-
ple levels of delegation. There is a root delegator (also called issuer)
that issues Level-1 credentials to users. Users can delegate their
Level-L credential, resulting in a Level-(L + 1) credential. We now
explain on a high level how a user obtains a Level-1 credential and
then that credential is delegated. It is then easy to see how a Level-L
credential is delegated (this is also depicted in Fig. 2).
The issuer first generates a signing key isk and corresponding
verification key ipk and publishes ipk, after which it can issue a
Level-1 credential to a user. The user, to get Level-1 credential
issued, generates a fresh secret and a public key (csk1, cpk1) for this
credential and sends public key cpk1 to the root delegator. The root
delegator signs this public key together with a set of attributes (cid:174)a1
and sends the signature Ïƒ1 back to the user. A Level-1 credential
cred1 consists of the signature Ïƒ1, attributes (cid:174)a1, and credential keys
(cpk1, csk1).
The user can delegate cred1 further to another user by issu-
ing a Level-2 credential. The receiver generates a fresh key pair
(csk2, cpk2) for the Level-2 credential. The delegation is done by
signing public key cpk2 and a set of attributes (cid:174)a2 (chosen by the
delegator) with the Level-1 credential secret key csk1. The resulting
signature Ïƒ2 is sent back together with the attributes (cid:174)a2 and the orig-
inal signature Ïƒ1, and the corresponding attributes (cid:174)a1. The Level-
2 credential consists of both signatures Ïƒ1, Ïƒ2, attributes (cid:174)a1, (cid:174)a2,
and keys cpk1, cpk2, csk2. Note that the Level-2 credential is a
chain of two so-called credential links. The first link, consisting of
(Ïƒ1, (cid:174)a1, cpk1) proves that the delegator has a Level-1 credential con-
taining attributes (cid:174)a1. The second link, (Ïƒ2, (cid:174)a2, cpk2), proves that this
delegator issued attributes (cid:174)a2 to the owner of cpk2. The key csk2
allows the user to prove he is the owner of this Level-2 credential.
Note, that the Level-1 credential secret key csk1 is not sent together
with the signature and the credential link, so that it is impossible
for a user who owns the Level-2 credential to present or delegate
the Level-1 credential.
The Level-2 credential can be delegated further in the analogous
way by generating a signature on attributes and a public key and
sending them together with lower-level credential links. A Level-L
credential is therefore a chain of the L credential links, where every
link adds a number of attributes (cid:174)ai, and a secret key cskL that allows
the owner to present the credential or to delegate it further.
A credential of any level can be presented by its owner by gener-
ating a NIZK proof proving a possession of all credential links back
to the issuer and selectively disclosing attributes from the corre-
sponding signatures. This proof, that we call an attribute token, can
be verified with the public key of only the issuer. The public keys of
all the credential links remain hidden in the zero-knowledge proof
and, therefore, the identities of all the intermediate delegators are
not revealed by the attribute token.
4.2 Generic Construction
Our generic construction Î dac is based on secure sibling signature
schemes, where Sign1 signs vectors of messages. We allow different
Figure 2: Our Generic Construction: Delegation
Issueripk,isk~a1012Lâˆ’1Lcpk1,csk1Ïƒ1=Signisk(cpk1,~a1)Level~a2cpk2,csk2Ïƒ2=Signcsk1(cpk2,~a2)cpkL,cskLcpkLâˆ’1,cskLâˆ’1~aLcredL=(hÏƒi,~ai,cpkiiLi=1,cskL)ÏƒL=SigncskLâˆ’1(cpkL,~aL).........Session C5:  Using BlockchainsCCSâ€™17, October 30-November 3, 2017, Dallas, TX, USA689sibling signature schemes to be used at different delegation levels.
Let Sibi denote the scheme used by the owners of Level-i credentials.
As we sign public keys of another signature scheme and the attribute
values, the different signature schemes must be compatible with
each other: The public key space of Sibi +1 must be included in the
message space â„³1 of Sibi. It follows that the attribute space Ai is
the message space of Sibiâˆ’1.
The required system parameters for the signature schemes are
taken from â„±crs. We implicitly assume that every protocol par-
ticipant queries â„±ca to retrieve the issuer public key and â„±crs to
retrieve the system parameters, and that the system parameters
are passed as an implicit input to every algorithm of the signature
schemes.
Setup. In the setup phase, the issuer â„ creates his key pair and
registers this with the CA functionality â„±ca.
(1) â„, upon receiving input (SETUP, sid, âŸ¨niâŸ©i):
â€¢ Check that sid = â„, sidâ€² for some sidâ€².
â€¢ Run (ipk, isk) â† Sib0.Gen(1Îº) and compute proof Ï€isk â†
NIZK{ isk : (ipk, isk) âˆˆ Sib0.Gen(1Îº)}. Register public key
(ipk, Ï€isk) with â„±ca. Let cpk0 â† ipk.
â€¢ Output (SETUPDONE, sid).
Delegate. Any user ğ’«i with a Level-L âˆ’ 1 credential can delegate
this credential to another user ğ’«j, giving ğ’«j a Level-L credential.
Delegator ğ’«i can choose the attributes he adds in this delegation.
Note that only the issuer â„ can issue a Level-1 credential, so we
distinguish two cases: issuance (delegation of a Level-1 credential)
and delegation of credential of level L > 1.
(2) ğ’«i on input (DELEGATE, sid, ssid, (cid:174)a1, . . . , (cid:174)aL,ğ’«j) with (cid:174)aL âˆˆ
AnL
â€¢ If L = 1, ğ’«i only proceeds if he is the issuer â„ with sid =
L
(â„, sidâ€²). If L > 1, ğ’«i checks that he possesses a credential
chain that signs (cid:174)a1, . . . , (cid:174)aLâˆ’1. That is, he looks up a record
cred = (âŸ¨Ïƒi , (cid:174)ai , cpkiâŸ©Lâˆ’1
i =1 , cskLâˆ’1) in â„’cred.
â€¢ Send (sid, ssid, (cid:174)a1, . . . , (cid:174)aL) to ğ’«j over â„±smt.
â€¢ ğ’«j, upon receiving (sid, ssid, (cid:174)a1, . . . , (cid:174)aL) to ğ’«j over â„±smt from
ğ’«i, generate a fresh credential specific key pair(cpkL, cskL) â†
SibL .Gen(1Îº).
â€¢ Send cpkL to ğ’«i over â„±smt.
â€¢ ğ’«i, upon receiving cpkL from ğ’«j over â„±smt, computes ÏƒL â†
SibLâˆ’1.Sign1(cskLâˆ’1; cpkL, (cid:174)aL) and sends âŸ¨Ïƒi , cpkiâŸ©L
i =1 to ğ’«j