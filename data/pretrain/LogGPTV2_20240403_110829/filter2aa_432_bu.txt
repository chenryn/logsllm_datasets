/* 字典中字母数 */
int
nwords = 0 ;
int  nextin ( char* cmd, char* word) ;
int  initw() ;
int  insertw ( const char* word ) ;
int  deletew ( const char* word ) ;
int  lookupw ( const char* word ) ;
/*********************************************************
initw  初始化字典，清空所有数据                    *
 *********************************************************/
int  initw()
{
nwords = 0 ;
return 1 ;
}
- 282 -
Linux网络编程
/*********************************************************
insertw  将一个单词插入字典                        *
 *********************************************************/
int  insertw ( const char* word )
{
strcpy ( dict[nwords], word ) ;
nwords ++ ;
return nwords ;
}
/*********************************************************
deletew  在字典中删除一个单词                      *
 *********************************************************/
int  deletew ( const char* word )
{
int 
i ;
for ( i=0 ; i i ;i++ )
{
if ( 0 == strcmp(word, dict[i]) )
{
return 1 ;
}
}
return 0 ;
第十二章  远程过程调用
- 283 -
}
我们这样来编译它：
gcc –c rdict_srp.c
然后，我们可以将所有的目标程序链接成一个可执行文件：
gcc –o rdictd rdict_svc.o rdict_sif.o rdict_srp.o
或
gcc –o rdictd rdict_svc.c rdict_sif.c rdict_srp.c
运行该命令时，它将可执行代码写入文件 rdictd 中。
8．启动服务器和执行客户机
我们现在开始对程序进行测试。正如我们上面说的，我们在同一台机器上面运行服务
器和客户机。
在运行我们的 rdict 客户机之前，我们必须要先运行 rdictd 服务器。否则你将看到下面
的错误信息：
Could not contact remote program.
我们要启动 rdictd 服务器程序：
./rdictd &
然后我们在启动 rdict 客户机就可以交互的进行客户机的操作。
12.9  小结
用 rpcgen 构造一个分布式程序由八个步骤组成。程序员由一个解决该问题的常规应用
程序开始，决定如何将程序划分为本地构建和远程执行构建，将应用划分成两个物理的部
分，创建一个描述远程过程的规格说明文件，运行 rpcgen 产生所需要的文件。接着程序员
编写客户机端和服务器端的接口例程，并将它们与 rpcgen 所产生的代码相结合。最后，程
序员编译并链接客户机端和服务器端的文件，以便产生可执行的客户机和服务器程序。
尽管 rpcgen 免除了 RPC 所要求的大部分编写代码的工作，但编写一个分布式程序还
是要认真思考的。在考虑如何将程序划分成本地构建和远程构建时，程序员必须检查被每
个程序片段要访问的数据，以便使数据的移动最小。程序远还必须要考虑到每个远程过程
所引入的延时，以及各个程序片段将如何访问 I/O 设施。
本章所给的字典应用的例子展示了将一个简单的应用转变为一个分布式的程序要花费
很多的精力。更复杂的应用程序要求更加复杂的规格说明和接口过程。
- 284 -
Linux网络编程
第十三章  远程磁带的访问
13.1  简介
远程介质访问主要是指远程磁盘和远程磁带的访问，这里主要以远程磁带的访问为例
来讲述远程介质的访问（简称远程带驱的访问）。
大多数的计算机用户都知道做备份的重要性。一旦存储着大量信息的系统由于发生了
故障而造成数据丢失，其损失将是十分巨大的，或者是几天，或者是几个月，甚至是几年
的工作成果，转眼之间就全部化为乌有。由于系统错误而丢失珍贵数据的风险永远不可接
受，因此，养成做备分的习惯对于计算机用户来说是十分重要的，但做备分的时候经常会
发现外存不够用，如在一个多用户系统中，做一次备分将用掉几百兆、几 G 的空间，这就
不是仅仅使用软盘或者硬盘所能满足的，而必须使用另外一种外存—磁带。虽然磁带的存
取速度比软、硬盘慢，在访问方式上只能顺序存取，不如软、硬盘方便，但它有一个最大
的好处，即存储容量大、成本低。随着技术的进步，现在已经出现了光盘，其容量更大，
速度更快，相信在不久的将来可以取代磁带作为常用备份介质。
一般而言，使用几个小的备份比用一个大的备份要好一些。小的备份查找速度快而且
易于使用，用户也不会忽视它们；更重要的是，若一个大型的备份（通常在一个磁带或者
磁盘中容纳不下，而由访问裸设备的 cpio 命令像 DOS 中的 backup 命令那样顺序的“ 倒”
出来后放在若干磁盘或者磁带中）中的某一环节由于某种原因损坏了，那么剩余的部分也
就不能读取了。这样，使用几个小的备份就明显的改善了备份过程的可靠性，并且在发生
意外的时候可以减少损失。因此，我们建议用户在做备份的时候尽可能的多做一些小的备
份。
一般的，在一个局部网络如 Ethernet 中，许多工作站都没有配备磁带驱动器，甚至在
整个网络中也没有配置带驱，这就使得我们只能通过 LAN 将数据在远程系统的带驱上备份
到磁带上。本节将要讨论的 4.3 BSD rmt 协议就是用于这个目的，该协议由 4.3 BSD 中的
rdump 和 rrestore 命令使用。
要使用磁带设备来备份系统，就应该首先了解磁带设备是如何存取的，应该采用什么
系统调用，按什么数据结构存取等等。目前用户使用磁盘较为频繁，相对来说使用磁带就
少的多了，这也是客观上造成了用户对于磁带设备理解甚少的缘故。因此，熟悉磁带设备
的存取方法是设计程序要做的第一步。
Rmt 协议是远程带驱访问所遵循的协议，它定义了远程带驱访问所需信息量的格式。
该协议实际上描述了 Linux 系统上的远程带驱的访问过程。在 Linux 系统中提供了一个称
为 rmt 调度进程的远程磁带服务器，它通常存放在文件 /etc/rmt 中，由 rshd 或者 rexecd 启
动，它遵循 rmt 协议，我们自己编写的客户程序要与 rmt 调度进程通信，因此也应该遵循
这个协议。
要访问远程带驱，用户只需要将必要的参数传递给远程系统上的 rmt 调度进程，具体
的访问过程由远程 rmt 进程执行，本地进程只需要关心数据通信就可以了。
在了解远程带驱的访问过程后，我们就可以着手建立程序框架，编写具体的应用程序。
客户程序由于只关心数据的发送和接收，因此比较简单，只要清楚了 rmt 协议，编写应用
程序应该没有问题。
我们后面将主要介绍 rmt 服务器程序。
第十三章 远程磁带的访问
- 285 -
13.2  Linux 磁带驱动器的处理
在 Linux 系统中的术语“ 介质” 代表磁盘和磁带。在磁带中可建立文件系统，并且可
以像磁盘那样安装，它们唯一的区别在于磁带驱动器的设备文件名。
某些磁带部件是不可安装的，只能用于裸设备，生产厂商在用户指南中已经说明了磁
带驱动器的有关信息，用户必须根据其中定义的存取方法来存取。通常盒式磁带驱动器是
可安装的，而大型 9 道卷轴磁带是不可安装的。
Linux 系统给出了用户进程和磁带驱动器之间的一个简单接口函数，即 read()/write() 系
统调用。使用 read()从磁带驱动器中读一个整块，该调用返回读到的实际字节数；使用 write
系统调用写一个指定大小的块到磁带驱动器。用户应该保证有足够大小的读缓冲区来处理
磁带上的最大块，否则会出错。在关闭磁带驱动器的时候，如果最后的操作是一个 write，
则向磁带写两个文件结束标记。
4.3 BSD 中的磁带驱动器是通过名字来访问的。如将/dev/rmt8 作为参数传递给 open 系
统调用，指定一个磁带驱动器。在名字 /dev/nrmt8 中，前缀“ n” 指明磁带在关闭的时候
不能倒带。
Linux 提供的这种磁带读取方法使得用户可以很方便的对磁带设备进行读写，其具体
的实现由 Linux 系统去做，用户不需要了解磁带设备的各种控制。这也充分体现了 Linux
的优点，用户只需要在 Linux 系统提供的平台上应用就可以了，不必要陷入繁琐的硬件控
制。
4.3 BSD 另外还为磁带设备提供了 ioctl 命令，它允许对磁带进行一些控制属性的操作：
写文件结束标记，指定记录或者文件数的空间，使磁带驱动器脱线等等。通常情况下 System
V 也为盒式磁带提供了一个 cpio 版本，它是专门为磁带操作而开发的，不能用于磁盘。除
此之外用户还可以使用 tar 命令( tape archive，磁带归档)。Tar 命令最初就是用于支持大型
磁带的，但现在也可以用于软盘和小型磁带。
13.3  rmt 协议
4.3 BSD 提供了一个称为 rmt 调度进程的远程磁带服务器，程序放在 /etc/rmt 中，由远
程 shell 服务器 rshd 启动，也可由 rexecd 服务器启动，这两个服务器之间的区别就在于确
认方式的不同。
客户与服务器通过 TCP 连接通信的时候，必须遵守一个应用协议，该协议主要由 ASCII
串组成，以换行符结束。
客户发出请求后，服务器根据情况给予相应的应答。
应答有两种：
Aretval \n（A 返回值\n）和 Eerrornum\nerrorstring\n（E 错误号\n 错误信息\n）
第一种应答是 ASCII 字符“ A” 后跟一个 ASCII 数码，再紧跟一个换行符，表示该请
求已经成功完成。第二种应答是在出现错误的时候由服务器产生的，它由 ASCII 字符“ E”
后跟一 ASCII 出错号（Linux 错误号）及换行符，再加上一个错误信息串及一个换行符组
成。
客户的所有请求也都以一个 ASCII 字符开始，其格式有如下几种：
1．Opathname\nmode\n (O 路径名\n 模式\n)
打开指定路径名为 pathname 的设备，模式 mode 是一个十进数值，由它说明 open 系统
调用的方式，通常 mode 值为 0 表示读，为 1 表示写，为 2 表示读和写。打开成功的时候，
应答为：
A0\n
- 286 -
Linux网络编程
2．Cpathname\n（C 路径名\n）
关闭当前已经打开的设备。路径名 pathname 参数虽然要求提供，但在服务器中被忽略，
并不使用。关闭成功的时候，应答为：
A0\n
3．Loffset\nwhence\n（L 偏移量\n 偏移起始\n）
如果设备支持随机访问，那么在当前已经打开的设备上执行一次 lseek 操作的结果将使
读写指针指向要读写的位置。Lseek 操作成功的时候，返回的 retval 值是一个由 lseek 返回
的长整型值。
4．Wcount\ndata（W 计数值\n 数据）
表明将要对当前打开的设备写入 count 个字节，要写入的数据与客户在此命令和换行
符后面立即发送。在执行 write 系统调用成功以后，retval 为该系统调用的返回值，它应与
指定的 count 值相等。
5．Rcount\n（R 计数值\n）
表明将从当前打开的设备中读取不多于 count 字节的数据。如果 read 系统调用成功，
应答为：
Acount\ndata
6．Ioperation\ncount\n（I 操作\n 计数值\n）
表明要在磁带驱动器上执行一次 ioctl 操作。操作 operation 所允许的值可以在头文件
中找到。如表 13-1 所示。Operation 同时还可以有其它一些值，但它们与硬件
无关。该操作的返回值 retval 在 4.3 BSD 中没有定义。
表 13-1  /etc/rmt 的 ioctl 操作
操  作
描                  述
0
           写 count 个 EOF 标志
1
           向后覆盖 count 个 EOF 标志
2
           向前覆盖 count 个 EOF 标志
3
           向后覆盖 count 个记录
4
           向前覆盖 count 个记录
5
           卷带（忽略 count）
6
           卷带（忽略 count）并脱离驱动器
7．s\n（S\n）
返回当前打开设备的状态。用户应该尽量避免使用此要求，这是因为该请求返回的值
是含有硬件相关信息的二进制结构。
在通常的操作中使用到的命令仅仅有 open，close，read 和 write，除了 I 和 S 以外，该
协议并没有假定远程设备就是磁带设备，因此该协议也可以用于其它的远程设备访问。
13.4  rmt 服务器设计分析
前面已经介绍了 rmt 协议，它定义了各种请求以及应答报文格式，因此 rmt 服务器可
以根据各种请求分别予以处理。
从总体上看，服务器程序可以看成一个无限循环，在循环过程中检测是否有请求到来。
如有，则根据不同的请求类型（由请求的第一个 ASCII 字符如 O，L，C 等判别）给予相
应的处理，这可以用 C 语言的 Switch 分支语句实现。下面将介绍各种请求的处理过程。
1．open 请求
该请求的格式是：
第十三章 远程磁带的访问
- 287 -
Opathname\nmode\n（O 路径名\n 模式\n）
由于是请求打开一个磁带设备，因此，如果原来已经打开了一个设备，这个时候就必
须首先关闭这个设备。磁带描述符 Tapefd 大于或者等于 0 的时候表示已经打开了一个设备，
用 close 系统调用关闭之：
close (Tapefd);
这个时候可‘以用 open 系统调用打开请求的磁带设备：
Tapefd =open(pathname,atoi(mode));
若打开设备失败（Tapefd=0)，则应答 A0\n：
ResponVal(oL);
这里，ResponErr(ErrNo)函数可以简单实现如下：
char ErrMsg[100];
sprintf (ErrMsg，“E%%d\n”，Errno,ErrString[errno]);
write (sockfd2,ErrMsg,strlen(ErrMsg) );
ResponVal （longval）函数也可以简单的实现如下：