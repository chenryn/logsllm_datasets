In this paper, we proposed a context-aware architecture that provides information about
the network states and their changes for enterprise security applications. We described
how this architecture converts network data from infrastructure devices, network ser-
vices, and passive probes to a uniform representation stored in the network state database.
Then we introduced CANVuS, a context-aware vulnerability scanning system built
upon this architecture that triggers scanning operations based on changes indicated by
network activities. We experimentally evaluated the system by deploying it in a college-
level academic network and comparing CANVuS against an existing system. We found
that this approach outperforms existing models in low detection latency, while consum-
ing fewer network resources.
Acknowledgments
The authors wish to gratefully acknowledge the following colleagues at the University
of Michigan for their assistance in performing this work: Paul Howell, Kirk Soluk,
Dawn Isabel, Dan Maletta, Kevin Cheek, and Donald Winsor. This work was sup-
ported in part by the Department of Homeland Security (DHS) under contract numbers
NBCHC080037, NBCHC060090, and FA8750-08-2-0147, the National Science Foun-
dation (NSF) under contract numbers CNS 091639, CNS 08311174, CNS 0627445, and
CNS 0751116, and the Department of the Navy under contract N000.14-09-1-1042.
References
1. Abedin, M., Nessa, S., Al-Shaer, E., Khan, L.: Vulnerability analysis for evaluating quality
of protection of security policies. In: Proceedings of the 2nd ACM Workshop on Quality of
Protection (QoP 2006), Alexandria VA (October 2006)
2. Ahmed, M.S., Al-Shaer, E., Khan, L.: Towards autonomic risk-aware security conﬁguration.
In: Proceedings of the 11th IEEE/IFIP Network Operations and Management Symposium
(NOMS 2008), Salvador, Bahia, Brazil (April 2008)
3. Allman, M., Kreibich, C., Paxson, V., Sommer, R., Weaver, N.: Principles for developing
comprehensive network visibility. In: Provos, N. (ed.) Proceedings of 3rd USENIX Work-
shop on Hot Topics in Security, San Jose, CA, USA, July 29, USENIX Association (2008)
4. Allman, M., Paxson, V.: A reactive measurement framework. In: Claypool, M., Uhlig, S.
(eds.) PAM 2008. LNCS, vol. 4979, pp. 92–101. Springer, Heidelberg (2008)
5. Ammann, P., Wijesekera, D., Kaushik, S.: Scalable, graph-based network vulnerability analy-
sis. In: Proceedings of the 9th ACM Conference on Computer and Communications Security
(CCS 2002), Washington DC (November 2002)
6. Bau, J., Bursztein, E., Gupta, D., Mitchell, J.: State of the art: Automated black-box web
application vulnerability testing. In: Proceedings of the 31st IEEE Symposium on Security
& Privacy (S&P 2010), Oakland, CA (May 2010)
156
Y. Xu et al.
7. Beattie, S., Arnold, S., Cowan, C., Wagle, P., Wright, C., Shostack, A.: Timing the application
of security patches for optimal uptime. In: Proceedings of the 16th Annual LISA System
Administration Conference, Philadelphia, PA, USA (November 2002)
8. Edward Bjarte. Prads - passive real-time asset detection system,
http://gamelinux.github.com/prads
9. Cheswick, W.R., Bellovin, S.M.: Firewalls and Internet Security; Repelling the Wily Hacker.
Addison Wesley, Reading (1994)
10. Cooke, E., Bailey, M., Jahanian, F., Mortier, R.: The dark oracle: Perspective-aware unused
and unreachable address discovery. In: Proceedings of the 3rd USENIX Symposium on Net-
worked Systems Design and Implementation (NSDI 2006) (May 2006)
11. eEye Digital Security. Retina - network security scanner,
http://www.eeye.com/Products/Retina.aspx
12. Ilya Etingof. Pysnmp, http://pysnmp.sourceforge.net/
13. Ingols, K., Lippmann, R., Piwowarski, K.: Practical attack graph generation for network
defense. In: Proceedings of the 22nd Annual Computer Security Applications Conference,
ACSAC 2006 (December 2006)
14. Kreibich, C., Sommer, R.: Policy-controlled event management for distributed intrusion de-
tection. In: ICDCS Workshops, pp. 385–391. IEEE Computer Society, Los Alamitos (2005)
15. McAllister, S., Kirda, E., Kruegel, C.: Leveraging user interactions for in-depth testing of
web applications. In: Lippmann, R., Kirda, E., Trachtenberg, A. (eds.) RAID 2008. LNCS,
vol. 5230, pp. 191–210. Springer, Heidelberg (2008)
16. Mehta, V., Bartzis, C., Zhu, H., Clarke, E., Wing, J.: Ranking attack graphs. In: Zamboni, D.,
Kr¨ugel, C. (eds.) RAID 2006. LNCS, vol. 4219, pp. 127–144. Springer, Heidelberg (2006)
17. Microsoft. Watcher - web security testing tool and passive,
http://websecuritytool.codeplex.com
18. Oberheide, J., Cooke, E., Jahanian, F.: Cloudav: N-version antivirus in the network cloud. In:
Proceedings of the 17th USENIX Security Symposium (Security 2008), San Jose, CA (July
2008)
19. Oberheide, J., Cooke, E., Jahanian, F.: If It Ain’t Broke, Don’t Fix It: Challenges and New
Directions for Inferring the Impact of Software Patches. In: 12th Workshop on Hot Topics in
Operating Systems (HotOS XII), Monte Verita, Switzerland (May 2009)
20. Ou, X., Boyer, W.F., McQueen, M.A.: A scalable approach to attack graph generation. In:
Proceedings of the 13th ACM Conference on Computer and Communications Security (CCS
2006), Alexandria, VA (October 2006)
21. Ou, X., Govindavajhala, S., Appel, A.W.: Mulval: A logic-based network security analyzer.
In: Proceedings of the 14th USENIX Security Symposium (USENIX Security 2005), Balti-
more, MD (August 2005)
22. Paxson, V.: Bro: A System for Detecting Network Intruders in Real-Time. Computer Net-
works 31(23-24), 2435–2463 (1999)
23. Roesch, M.: Snort: Lightweight intrusion detection for networksx. In: Proceedings of the
13th Systems Administration Conference (LISA), pp. 229–238 (1999)
24. Sawilla, R.E., Ou, X.: Identifying critical attack assets in dependency attack graphs. In: Jajo-
dia, S., Lopez, J. (eds.) ESORICS 2008. LNCS, vol. 5283, pp. 18–34. Springer, Heidelberg
(2008)
25. Tenable Network Security. Nessus - vulnerability scanner, http://www.nessus.org
26. Tenable Network Security. Nessus passive vulnerability scanner,
http://www.nessus.org/products/pvs/
27. Sheyner, O., Haines, J., Jha, S., Lippmann, R., Wing, J.M.: Automated generation and anal-
ysis of attack graphs. In: Proceedings of 2002 IEEE Symposium on Security and Privacy
(S&P 2002), Oakland, CA (May 2002)
CANVuS: Context-Aware Network Vulnerability Scanning
157
28. Sinha, S., Bailey, M., Jahanian, F.: Shedding light on the conﬁguration of dark addresses. In:
Proceedings of Network and Distributed System Security Symposium (NDSS 2007) (Febru-
ary 2007)
29. Sinha, S., Bailey, M.D., Jahanian, F.: One Size Does Not Fit All: 10 Years of Applying Con-
text Aware Security. In: Proceedings of the 2009 IEEE International Conference on Tech-
nologies for Homeland Security (HST 2009), Waltham, Massachusetts, USA (May 2009)
30. Sinha, S., Jahanian, F., Patel, J.M.: Wind: Workload-aware intrusion detection. In: Zam-
boni, D., Kr¨ugel, C. (eds.) RAID 2006. LNCS, vol. 4219, pp. 290–310. Springer, Heidelberg
(2006)
31. Sourceﬁre. Sourceﬁre rna - real-time network awareness,
http://www.sourcefire.com/products/3D/rna
32. Sourceﬁre, Inc. Clamav antivirus (2008), http://www.clamav.net/
33. University of Michigan. University of Michigan — ITS — Safe Computing — IT Security
Services Ofﬁce (April 2010), http://safecomputing.umich.edu/about/
34. Vallentin, M.: VAST: Network Visibility Across Space and Time. Master’s thesis, Technische
Universitat Munchen (January 2009)
HyperCheck: A Hardware-Assisted Integrity Monitor
Jiang Wang, Angelos Stavrou, and Anup Ghosh
Center for Secure Information Systems
George Mason University, VA, USA
{jwanga,astavrou,aghosh1}@gmu.edu
Abstract. Over the past few years, virtualization has been employed to environ-
ments ranging from densely populated cloud computing clusters to home desktop
computers. Security researchers embraced virtual machine monitors (VMMs) as
a new mechanism to guarantee deep isolation of untrusted software components.
Unfortunately, their widespread adoption promoted VMMs as a prime target for
attackers. In this paper, we present HyperCheck, a hardware-assisted tampering
detection framework designed to protect the integrity of VMMs and, for some
classes of attacks, the underlying operating system (OS). HyperCheck leverages
the CPU System Management Mode (SMM), present in x86 systems, to securely
generate and transmit the full state of the protected machine to an external server.
Using HyperCheck, we were able to ferret-out rootkits that targeted the integrity
of both the Xen hypervisor and traditional OSes. Moreover, HyperCheck is ro-
bust against attacks that aim to disable or block its operation. Our experimental
results show that HyperCheck can produce and communicate a scan of the state
of the protected software in less than 40ms.
Keywords: Hypervisor, Protection framework, System Management Mode.
1 Introduction
Hypervisors1 have become the de facto standard in server consolidation because they
decrease the energy footprint and cost of management of modern computing clusters.
In addition, hypervisors are increasingly used as components to enforce system security
and resilience [22, 28, 16, 38, 21, 36, 31]. This widespread adoption of virtualization
has attracted the attention of the attackers towards VMM vulnerabilities. Indeed, re-
cently, there has been a surge in the reported vulnerabilities for commercial and open
source hypervisors [27]. Moreover, the number and nature [40, 6] of attacks against the
hypervisors are poised to grow.
This increasing attack trend has spurred research towards reducing the hypervisor
Trusted Code Base (TCB) of current commercial hypervisors [26]. Others developed
new specialized prototype hypervisors [36, 24]. However, having a small code base can
only limit the code exposure and thus the attack surface of the hypervisor – it cannot
provide strong guarantees about the code integrity of all the hypervisor components.
To address these limitations and to complement the existing protection mechanisms,
we designed a hardware-assisted tampering detection framework called HyperCheck.
1 Also called Virtual Machine Monitors VMMs.
S. Jha, R. Sommer, and C. Kreibich (Eds.): RAID 2010, LNCS 6307, pp. 158–177, 2010.
c(cid:2) Springer-Verlag Berlin Heidelberg 2010
HyperCheck: A Hardware-Assisted Integrity Monitor
159
HyperCheck is designed to protect the integrity of VMMs and, for some classes of
attacks, the underlying operating system (OS). To achieve that, HyperCheck harnesses
the CPU System Management Mode (SMM) which is present in all x86 commodity
systems to create a snapshot view of the current state of the CPU and memory registers
of the protected machine. This information is securely and veriﬁably transmitted using a
network card to a remote analysis server. Using that information, the analysis server can
identify any tampering by comparing the newly generated view with the one recorded
when the machine was initialized. If the two views do not match, a human operator is
notiﬁed. As shown in Figure 1, HyperCheck works at the BIOS level and can protect the
software above it. Our assumptions are that the attacker does not have physical access
to the machine and that the SMM BIOS is locked and thus cannot be altered during run.
We do not explicitly require trusted boot to initialize HyperCheck [23, 24]. However,
having a machine equipped with trusted boot can prevent attacks against HyperCheck
that simulate a hardware reset.2
Unlike previous work [30] that use special-
ized PCI hardware, we are able to acquire a
complete view of the target machine’s state
including the entire memory and CPU regis-
ters. In addition, our approach is able to thwart
attacks aimed at disabling, blocking, or even
taking over PCI devices. To evaluate the va-
lidity and performance of our approach, we
implemented two prototypes for HyperCheck.
HyperCheck-I uses QEMU [3] – a fully sys-
tem emulator – to emulate the PCI NIC, while
HyperCheck-II is based on an Intel e1000 phys-
ical NIC. Using our prototypes, we were able to ferret-out rootkits aimed at Xen [11]
hypervisor, Xen Domain 0, Linux, and Windows. Our experimental results indicate that
HyperCheck does not cause prohibitive performance overhead requiring only a few
milliseconds to completely transmit each snapshot.
Fig. 1. HyperCheck can offer protection
to services running above BIOS
In summary, we make the following contributions:
1. Designed a novel hardware-assisted tampering detection framework that creates a
complete snapshot of the state of the system with commercial hardware and no
modiﬁcation to the installed software.
2. Implemented two prototypes: one based on QEMU and the other based on the real
hardware. The latter has overhead in the order of few milliseconds. Using our pro-
totype, we demonstrate that we can successfully detect rootkits and code integrity
attacks against the Xen VMM, Xen Domain 0, Linux, and Windows.
2 Related Work
Protecting software from integrity attacks using hardware-assisted techniques is not
new: researchers used a special-purpose PCI device to acquire the physical memory
2 As we discuss in Section 7, the same can be accomplished using a management interface.
160
J. Wang, A. Stavrou, and A. Ghosh
either for rootkit detection [30, 2] or for forensic purpose [8] in the past. The closest
system to our work is Copilot [30]. Copilot employed a special PCI device to poll the
physical memory of the host and send it to an admin station periodically. In Hyper-
Check, we do not require specialized hardware – only an out-of-the-box network card.
We also offer a complete view of the CPU state including its registers. Such view is
important to prevent copy-and-change attacks that can mislead the PCI card to scan the
wrong regions of memory and report erroneously that the system is not affected.
Another closely related work is HyperGuard [33]. Rutkowska et al. suggested using
SMM of the x86 CPU to monitor the integrity of the hypervisors. Although we have
similar goals as the HyperGuard project, the use of a network card allows us to out-
source the analysis of the state snapshot. This results in a drastic improvement in the
performance of the system reducing the system busy time from seconds to millisec-
onds. Due to its low performance overhead, HyperCheck can also monitors the code
and data of the privileged domain and underlying OSes. Another difference is that the
monitoring machine can be used to detect the DoS attacks to the SMM code.
DeepWatch [6] also offers detection of hypervisor rootkits, called virtualization
malware in DeepWatch, by using the embedded micro-controller(s) in the chipset. Deep-
Watch is signature based and used to detect rootkits relying on hardware-assisted virtu-
alization technologies such as Intel VT-d [18]. Contrary, HyperCheck performs anomaly
detection and thus can identify a larger class of software rootkits.
Flicker [23] uses a TPM based method to provide a minimum Trusted Code Base
(TCB), which can be used to detect the modiﬁcation to the kernels. Flicker requires
advanced hardware features such as Dynamic Root of Trust Measurement (DRTM) and
late launch. In contrast, HyperCheck uses the static Platform Conﬁguration Registers
(PCRs) to secure the booting process. In addition, by sending out the data, HyperCheck
has a lower overhead on the target machine compared to Flicker. To reduce the overhead
of Flicker, TrustVisor [24] has a small footprint hypervisor to perform some cryptogra-
phy operations. However, all the legacy applications should be ported for TrustVisor to
work. In addition, TrustVisor requires DRTM.
Another branch of research tries to improve the security of the hypervisor by adding
hooks [10] and enforcing security policies between virtual machines [34]. These meth-
ods are hypervisor speciﬁc and run as the same level as the hypervisor. HyperCheck
monitors the hypervisor state from a lower level and thus, is complementary to these
methods.
Furthermore, there is a plethora of research aimed towards protecting the Linux ker-
nel [2, 22, 16, 38, 21, 36, 31]. Baliga [2] et al. use a PCI device to acquire the memory
and automatically derive the kernel invariance. Currently, we discover the kernel invari-
ance manually but we could employ their techniques directly and without modiﬁcations.
Litty [22] et al. developed a technique to discover the address of key data structures that
are instantiated during run-time by relying on processor hardware and executable ﬁle
speciﬁcations. But they also rely on the integrity of the underlying hypervisors. Hyper-
Check ﬁrst obtains the virtual addresses of those symbols through the symbol ﬁle, but
then calculates the physical addresses through CPU registers. Therefore, HyperCheck
can get the correct view of the system memory even if the underlying OS or hypervisor
is compromised and page tables are altered. Other existing research [38, 21, 36, 31],
HyperCheck: A Hardware-Assisted Integrity Monitor
161
including work by Jiang et al., depend on the integrity of the hypervisor to protect the
kernel. Our work is complementary and can be employed as a meta-protection mecha-
nism to guard the integrity of OS-level defenses. A lot of recent work has gone towards
using SMM to generate efﬁcient rootkits [39, 5, 15, 12]. These rootkits can be used
either to get root privilege or as a key-stroke loggers. We use SMM to offer integrity
protection by monitoring the state of hypervisors and operating systems.
3 Threat Model
3.1 Background of System Management Mode
System Management Mode (SMM) was introduced in the Intel386 SL and Intel486 SL
processors. It became a standard IA-32 feature in the Pentium [20] processor. SMM is a
separate CPU mode besides the protected and real mode. The original purpose of SMM
was to provide a transparent mechanism for implementing platform speciﬁc functions
such as power management and system security. The processor enters SMM when the
external SMM interrupt pin (SMI#) is activated or a SMI is received from the advanced
programmable interrupt controller (APIC) [20].
In SMM, the processor switches to a separate address space, called system manage-
ment RAM (SMRAM). In addition, all hardware context of the currently running code
is saved in SMRAM. Then, the CPU, being in SMM, executes transparently code that
is usually a part of BIOS and resides in SMRAM. The SMRAM can be made inacces-
sible from other CPU operating modes. Therefore, it can act as trusted storage, sealed
from being accessed from any device or even the CPU (while not in SMM mode). In
HyperCheck, we modify the SMM code to execute our monitoring functions. This mod-
iﬁcation of SMM code can be integrated into the BIOS. Another way is to use a trust
boot mechanism or a management interface to upload the code to SMM (when SMRAM
is not locked) and then lock the SMRAM. Upon returning from SMM, the processor is
placed back into its state prior to enter SMM.
3.2 Attacker’s Capabilities
We assume that the adversary has following capabilities: she is able to exploit vulner-
abilities in any software running in the machine after bootup. This includes the VMM
and all of its privileged components. For instance, the attacker can compromise a guest
domain and escape to the privileged domain. In Xen 3.0.3, pygrub [9] allows local users
with elevated privileges in the guest domain (Domain U) to execute arbitrary commands
in Domain 0 via a crafted grub.conf ﬁle [25]. Also, the attacker can modify the hypervi-
sor code or data using any known or zero-day attacks. For instance, the DMA attack [40]
hijacks a device driver to perform unauthorized DMA to the hypervisor’s code or data.
3.3 General Assumptions
The attacker cannot tamper with, or replace the installed PCI NIC with a malicious NIC
using the same driver interface. Also, if the SMM code is integrated with BIOS, we
162
J. Wang, A. Stavrou, and A. Ghosh
assume the SMRAM is properly setup by BIOS upon boot time. If the SMM code is not
included in the BIOS, it has to be reliably uploaded to the SMRAM during boot. This
can be done by either using trusted boot or using the management interface to bootstrap
the computer. In this case, to initialize the SMM code, a trusted bootstrap mechanism
has to be employed. The SMRAM is locked once it is properly set up. Once it is locked,
we assume it cannot be subverted by the attacker (an assumption supported by current
hardware). Attacks that attempt to modify the SMM code [41, 13, 14] are beyond the
scope of this paper.
3.4 In-Scope Attacks
HyperCheck aims to detect the in-memory, Ring-0 level (hypervisor or general OS)
rootkits and rootkits in privileged domains of hypervisors. A rootkit is a set of programs
and code that allows a permanent or consistent, undetectable presence on a computer
[19]. One kind of rootkits only modiﬁes the memory and/or registers and runs in the
kernel level. For example, the idt-hook rootkit [1] modiﬁes the interrupt descriptor table
(IDT) in the memory and then gains the control of the complete system. An stealthier
version of the idt-hook rootkit could keep the original IDT unchanged by copying it to a
new location and altering it. Next, the attacker could change the IDTR register to point
to the new location. When it comes to the hypervisor level rootkit, there is yet another
kernel: the hypervisor kernel which runs underneath the operating system kernel. There
are existing methods to detect in-memory, kernel-level rootkits. We try to bridge this
gap by introducing HyperCheck.
3.5 Limitations
Currently, our analysis cannot protect against attacks that modify dynamic data. There
are two types of threats: modiﬁcation to the dynamically generated function pointers
and return-oriented attacks. In these attacks, the control ﬂow is redirected to memory
location controlled by the attacker. There are techniques to thwart such attacks: the non-
executable bit in new CPUs and Address Space Layout Randomization to name a few.
HyperCheck can leverage and integrate those techniques to provide full protection but
it was not part of our implementation in this paper. Having said that, we can still detect
the presence of the malfease if it tries to interfere with the VMM code or statically
deﬁned function pointer.
4 System Architecture
HyperCheck is composed of three key components: the physical memory acquiring
module, the analysis module and the CPU register checking module. The memory ac-
quiring module reads the contents of the physical memory of the protected machine
and sends them to the analysis module. Then, the analysis module checks the memory
contents and veriﬁes if anything is altered. The CPU register checking module reads
HyperCheck: A Hardware-Assisted Integrity Monitor
163
Analysis
Module
Monitor
Machine
OS 1
OS 2
Hypervisor
PCI NIC
(1)
Hardware
SMM
(2)
(1) Acquiring module
(2) Register Checking module
Fig. 2. The architecture of HyperCheck
the registers and validates their integrity. The overall architecture of HyperCheck is