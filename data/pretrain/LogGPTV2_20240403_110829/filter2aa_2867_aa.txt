程聪 阿里云安全-系统安全专家
基 于 硬 件 虚 拟 化 技 术 的 新 一 代 二 进 制 分 析 利 器
自我介绍
现就职于阿里云安全-系统安全团队
主要研究方向:
•
病毒检测
•
主机安全
•
内核安全
•
虚拟化安全
•
二进制攻防
演讲内容
•
背景介绍
•
QEMU/KVM简介
•
无影子页ept hook
•
虚拟化调试器
•
内核级trace
•
总结
背景介绍
大家先来看下左边这张图片，搞内核安全的应该不陌
生。windows x64内核引入patchguard后，对内核
敏感部分，进行patch、hook，修改msr、IDT表等
操作，都会触发蓝屏
从PatchGuard谈起
但是有很多场景还是需要对内核进行hook，安全研
究人员发现可以借助硬件虚拟化特性，实现ept hook，
来兼容patchguard
传统的ept hook一般使用影子页来实现，我们发现这
种方法存在一些问题。本次分享会介绍一种新方法，
巧妙解决这些问题
要实现ept hook，首先需要一个类似左图的虚拟化平
台，提供整体的框架
虚拟化平台
从图中能看出，开发一个完整的vmm工作量太大，所
以我们选择基于现有的虚拟化平台进行二次开发，但
一些专注安全领域的开源平台如hyperplatform，或
多或少都存在各种各样的问题，最终我们选择了基于
qemu\kvm做二次开发
本次分享会介绍如何基于qemu\kvm，快速打造无影
子页ept hook，虚拟化调试器、内核级trace工具
vcpu manager
memory manager
device manager
interrupts
paravirtualization
vmm
…
•
代码完善度高，鲁棒性好，稳定性高，性能开销小
•
支持windows、linux等多种guest os
•
背靠linux内核，各种基础设施齐全，方便二次开发
•
在云上广泛使用，环境不会被特殊针对
•
支持gpu透传和虚拟化，可以运行图形化程序
•
支持嵌套虚拟化，可以运行vmm程序
为什么选择QEMU/KVM
相比于hyperplatform等虚拟化平台，qemu\kvm有以下优势
QEMU/KVM简介
QEMU/KVM整体架构
如左图所示，guest操作系统在(ring 0)上运行，同时
vmm运行在具有更高特权级别(ring -1) 上。执行系
统调用等不涉及关键指令的指令，vmm不会介入。这
样guest操作系统就可以为其应用程序提供高性能的
内核服务。当guest使用特权指令(比如cpuid)，或者
发生异常时会产生vmexit，从guest退出到host中，
host处理完成后，再通过vmentry回到guest
cpu虚拟化
HPA
PA
HVA
G
内存虚拟化
没有虚拟化的情况下，内存地址翻译如左图所示，只有VA->PA
virtual machine1
process1
VA
G
qemu
linux host
在存在虚拟化的情况下，GVA->GPA的翻译发生在虚拟机内部
GPA并不是最终的物理内存，还需要通过EPT翻译成HPA，才完
成整个内存访问
qemu的HVA也映射为HPA，所以一般来
说GPA对应着qemu的HVA
EPT翻译过程跟普通页表类似，也是通过多
级页表实现，手动去掉页表项某些权限，就
可以达到监控和欺骗的目的
EPT相关操作都在host上进行，对guest内核
和应用程序不可见，从而可以进行降维打击
无影子页ept hook
影子页ept hook
•
如右图，我们在原始页页面的基础上，创建
一个只有X权限影子页，原始页保留RW权限，
并在影子页上进行hook，修改头部指令为jmp
•
当有cpu执行此页时，就会触发hook逻辑
•
当有cpu读取此页时，由于影子页只有X权限，
会产生ept violation，从而vmexit到host，host
将页面切换成原始页(RW)进行读写，cpu会读取到
原始的内容，我们达到了欺骗(无痕)的效果
•
下次cpu再执行原始页(RW)时，同样会触发异常
，我们再将页面切换回影子页(X)执行
这种方法存在什么问题？
存在的问题
•
在影子页(X)上执行mov rcx,[rip]时，会读
取当前页面，由于当前页面只有X权限，
会产生异常并切换到原始页(RW)去执行
读取，由于RW页没有X权限，又会产生异
常并切换回影子页(X)，来回切换进入死锁
遇到右图自己读写自身页面的指令会怎么样？
这种读写自身页面的场景很常见，比如
•
switch case语句，在某些情况下会在当前
代码页面，编译生成jump table，这种情
况在windows内核中很常见
•
代码自修改，这种在用户态中比较常见，
比如一些壳、对抗代码中
我们如何改进？
改进后的解决方案
如右图所示，改进后的方案不去除原始页的X权
限，遇到页面自读写的指令，从X切换到RWX，
原始页可顺利执行此指令
在执行完此指令后，我们需要切换回影子页(X)，
否则后续cpu执行时hook逻辑不再生效，这个
切换回去的方法一般通过设置MTF来实现
MTF:全称是Monitor Trap flag，可以理解为单
步异常，当host设置该标志位时，回到guest执
行完一条指令后会触发vmexit，exit理由为
MTF
改进后还有什么问题？
依旧存在的问题
如右图，由影子页(X)切换到原始页
(RWX)单步执行时，如果其他核正在执
行此页面，会出现hook失效
如何规避这种情况？
出现这个问题的主要是因为一个核的页
面权限影响了另外一个核，可以给每个
核设置一套自己的EPT页表来规避，但
是这种方法内存占用多，性能损耗很大
类似kvm这种商业化落地的vmm，由于
性能等因素一般都是共用一套EPT页表，
这种情况下，我们如何解决这个问题？
思考
从前面可以看到，进行ept hook最核心的点是要页面切换，为什么要切换，是为了欺骗cpu读写
，让其读写到修改前的页面内容
答案是模拟执行
有没有不切换页面，同时可以欺骗cpu读写的方法？
总结来说就是，涉及非ept异常的页面如
mov rbx,[0x2000]，使用真实执行，涉
及到ept异常页面，如mov rax,[0x1000]，
会产生读取异常并触发模拟执行
模拟执行
引入了模拟执行，整个过程就变得非常
容易，不再需要影子页
大家看右图，我们将原始页面的RW权
限去掉只保留X权限，假设我们的页面地
址是0x1000，我们修改头部指令为jmp
就可以实现hook。当有cpu执行mov 
rax,[0x1000]读取页面时，产生异常并
vmexit，host接管并模拟执行此指令，
模拟涉及到被修改的指令都用原始指令
替换，这样cpu读到的就是修改前的sub 
rsp,88h指令
模拟器选择
其实KVM本身就自带了一个x86模拟器，我们可以直接使用
具体的代码在arch\x86\kvm\emulate.c
只需要对其中的部分模拟函数进行修改，在读取某些指令时，用原始指令替换即可
这样我们就通过ept + 模拟器实现了无影子页ept hook，解决了影子页存在的问题
有了前面模拟执行的方案，我们选择什么模拟器呢？unicorn?bochs？
基于这种软硬结合的思路，我们还很容易就能实现虚拟化调试器、内核级指令trace等其他工具
虚拟化调试器
什么是虚拟化调试器
断点机制
调试管理程序
异常事件分发
断点管理
模块管理
符号管理
…
虚拟化加持
这里所说的虚拟化调试器指的就是将调试框
架中，易被对抗的部分使用虚拟化来实现，
比如断点机制、异常事件分发，使用虚拟化
加持后，传统的反调试方法对我们完全无效
异常事件分发涉及的点比较多，我们今天重
点来介绍下虚拟化实现断点机制，断点分为
软件和硬件断点，我们先来介绍下软件断点