### 个人简介

**姓名**: 程聪  
**职位**: 阿里云安全-系统安全专家

### 演讲主题
基于硬件虚拟化技术的新一代二进制分析利器

### 自我介绍
目前在阿里云安全团队担任系统安全专家，主要研究方向包括：
- 病毒检测
- 主机安全
- 内核安全
- 虚拟化安全
- 二进制攻防

### 演讲内容概要
1. 背景介绍
2. QEMU/KVM简介
3. 无影子页EPT Hook
4. 虚拟化调试器
5. 内核级Trace
6. 总结

### 背景介绍
首先，请大家看左边这张图片。对于从事内核安全研究的人来说，这张图应该并不陌生。Windows x64内核引入PatchGuard后，对内核敏感部分进行patch、hook、修改MSR或IDT表等操作都会触发蓝屏。

#### 从PatchGuard谈起
尽管如此，在许多场景下仍需对内核进行hook。研究人员发现可以借助硬件虚拟化特性实现EPT hook来兼容PatchGuard。传统的EPT hook通常使用影子页来实现，但这种方法存在一些问题。本次分享将介绍一种新方法，巧妙地解决这些问题。

### 虚拟化平台
为了实现EPT hook，我们需要一个如左图所示的虚拟化平台提供整体框架。开发一个完整的VMM工作量巨大，因此我们选择基于现有的虚拟化平台进行二次开发。经过对比，最终选择了QEMU/KVM。

### 为什么选择QEMU/KVM
相比于HyperPlatform等其他虚拟化平台，QEMU/KVM具有以下优势：
- **代码完善度高**：鲁棒性强，稳定性好，性能开销小。
- **多操作系统支持**：支持Windows、Linux等多种Guest OS。
- **基础设施齐全**：背靠Linux内核，方便二次开发。
- **广泛使用**：在云上广泛应用，环境不会被特殊针对。
- **GPU透传与虚拟化**：支持运行图形化程序。
- **嵌套虚拟化**：支持运行VMM程序。

### QEMU/KVM简介
QEMU/KVM的整体架构如下：
- Guest操作系统在Ring 0级别运行。
- VMM运行在更高特权级别的Ring -1。
- 对于不涉及关键指令的系统调用，VMM不会介入，从而保证高性能。
- 当Guest使用特权指令（如cpuid）或发生异常时，会产生vmexit，从Guest退出到Host中处理，然后再通过vmentry返回Guest。

### CPU虚拟化
在没有虚拟化的情况下，内存地址翻译只有VA->PA。而在存在虚拟化的情况下，GVA->GPA的翻译发生在虚拟机内部。GPA并不是最终的物理内存，还需要通过EPT翻译成HPA。QEMU的HVA也映射为HPA，因此GPA通常对应着QEMU的HVA。

### EPT翻译过程
EPT翻译过程类似于普通页表，通过多级页表实现。手动去掉某些页表项权限，可以达到监控和欺骗的目的。所有EPT相关操作都在Host上进行，对Guest内核和应用程序不可见，从而可以进行降维打击。

### 无影子页EPT Hook
#### 影子页EPT Hook
- 在原始页基础上创建一个只有X权限的影子页，原始页保留RW权限。
- 在影子页上进行hook，修改头部指令为jmp。
- 当CPU执行此页时，会触发hook逻辑。
- 当CPU读取此页时，由于影子页只有X权限，会产生ept violation并vmexit到Host，Host将页面切换成原始页(RW)进行读写，CPU读取到原始内容，实现欺骗效果。
- 下次CPU再执行原始页(RW)时，同样会触发异常，再将页面切换回影子页(X)执行。

#### 存在的问题
- 在影子页(X)上执行`mov rcx, [rip]`时，会读取当前页面，由于当前页面只有X权限，会产生异常并切换到原始页(RW)去执行读取。由于RW页没有X权限，又会产生异常并切换回影子页(X)，来回切换进入死锁。
- 这种读写自身页面的场景很常见，例如switch case语句或代码自修改。

#### 改进后的解决方案
- 不去除原始页的X权限，遇到页面自读写的指令，从X切换到RWX，原始页可顺利执行此指令。
- 执行完此指令后，通过设置MTF（Monitor Trap Flag）切换回影子页(X)。

#### 依旧存在的问题
- 由影子页(X)切换到原始页(RWX)单步执行时，如果其他核正在执行此页面，会出现hook失效。
- 可以给每个核设置一套自己的EPT页表来规避，但这会导致内存占用多，性能损耗大。

### 模拟执行
- 通过模拟执行，不再需要影子页。
- 将原始页面的RW权限去掉只保留X权限，假设页面地址是0x1000，修改头部指令为jmp。
- 当CPU执行`mov rax, [0x1000]`读取页面时，产生异常并vmexit，Host接管并模拟执行此指令，模拟涉及到被修改的指令都用原始指令替换，这样CPU读到的就是修改前的指令。

### 模拟器选择
- KVM本身自带了一个x86模拟器，可以直接使用。
- 具体代码在`arch\x86\kvm\emulate.c`，只需对部分模拟函数进行修改，在读取某些指令时用原始指令替换即可。

### 虚拟化调试器
- **定义**：将调试框架中易被对抗的部分使用虚拟化来实现，如断点机制、异常事件分发。
- **优点**：传统的反调试方法对我们无效。
- **重点介绍**：虚拟化实现断点机制，分为软件和硬件断点。

### 总结
通过结合硬件虚拟化技术和模拟执行，我们实现了无影子页EPT Hook，并解决了传统方法中存在的问题。此外，基于这种软硬结合的思路，我们还可以轻松实现虚拟化调试器、内核级指令trace等其他工具。