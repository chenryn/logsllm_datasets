hence the expected number of transmissions to deliver a packet is
reduced to 1.14. Opportunistic routing protocols exploit this property
to decrease loss rates and increase mesh throughput.
However, the same property means that, half the time, multiple
routers will receive the packet from the source. Further, the proba-
bility of such an event, i.e., multiple routers hearing the same packet
increases with the size and density of the network. Existing protocols
cannot exploit this property. In contrast, SourceSync can leverage
the fact that multiple routers in a mesh overhear the same packet to
have these routers transmit the packet simultaneously towards the
destination. This form of cooperative forwarding increases the effec-
tive transmission power, enabling the packet to make longer jumps
towards its destination. Additionally, since the channels from the
concurrent transmitters to a downstream node router are unlikely to
experience simultaneous deep fading, overall loss rate is reduced.
In the rest of this section, we will describe how to integrate
SourceSync with ExOR to provide an opportunistic routing pro-
tocol that exploits both sender diversity and receiver diversity. At a
high level, ExOR works as follows. Given the link loss probabilities,
ExOR computes the ETX metric [8] of each link, and then arranges
the nodes in decreasing order of ETX distance from the destination.
ExOR is designed for bulk transport. The source operates in batches,
and starts by broadcasting all packets in the batch. Any node that
overhears the packet can potentially forward it towards its destina-
tion. ExOR has a priority scheduler that ensures that each packet is
forwarded by the node closest to the destination that has the packet.
We refer the reader to [4] for the details of the scheduling algorithm.
MAC: SourceSync retains ExOR’s MAC and extends it to allow si-
multaneous transmission from multiple forwarders. Similar to ExOR,
the potential forwarders for a transmission are determined based on
ETX measurements, and included in the packet header of a trans-
mission. However, unlike ExOR, SourceSync ensures that when an
ExOR forwarder transmits a packet, other nearby forwarders who
happen to have overheard this packet join the transmission. This
is similar to how neighboring APs join the transmission of a lead
AP to provide lasthop diversity as described in §7.1. There is one
key difference, however. Unlike in the last-hop scenario where AP
transmissions need to be aligned at one receiver, in opportunistic
178routing, transmissions from multiple forwarders need to be aligned
at multiple receivers. Hence, SourceSync uses the SLS described
in §4 to determine both the wait compensation at the forwarders,
and the minimum necessary increase in the CP to compensate for
misalignment between the receivers. This computation requires for-
warders to know the delay differences between various nodes in their
neighborhood, and the set of concurrent forwarders and potential
receivers for each transmission.
SourceSync computes the delay differences between nodes by
running periodic measurements, similar to existing loss rate mea-
surements by mesh routing protocols. SourceSync however does not
need to perform delay measurements between all node pairs. A node
needs to compute delay differences only to nodes that are potential
co-forwarders or potential nexthops. The size of this set dictates
the measurement overhead. So, in SourceSync, only nodes that are
connected by links with loss probability below a threshold perform
pairwise delay measurements. Further, SourceSync leverages data
packets from concurrent forwarders to keep updating its estimates of
delay differences as described in §4.5.
What happens when all forwarders do not hear a transmission?
It is likely that not all forwarders selected during the measurement
phase hear all of their intended transmissions. Exchanging infor-
mation for every packet about exactly which forwarders heard that
packet in order to determine the increase in CP, as well as the trans-
mission codeword and wait time to be used by each forwarder will
introduce high overhead. SourceSync eliminates the need for such
exchanges by leveraging the measurement phase to pick the required
wait time and additional CP assuming all forwarders hear a transmis-
sion, and also determines the ordering (and therefore codeword) of
the forwarders. After this assignment, whenever the lead forwarder
transmits, other forwarders hear the synchronization header, which
contains the additional CP and identiﬁer of the packet to the transmit-
ted. If a node is in the set of co-forwarders and has the transmitted
packet, it joins the transmission using the appropriate wait-time com-
pensation. The node also knows exactly which codeword to use for
its transmission based on the precomputed ordering of co-forwarders.
For example, say the lead forwarder is node i , and the size of the
co-forwarder set is k . The lead forwarder then uses the ﬁrst codeword,
node i − 1 uses the second codeword, and so on. Of course, not all
nodes in the set of potential co-forwarders might hear the packet,
or the transmission of the lead forwarder. Note that this does not
affect the correctness of SourceSync; a receiver can still decode the
concurrent transmission, and garner the beneﬁts of sender diversity
from co-forwarders that actually join the transmission.
8 Performance
We have implemented a prototype of SourceSync in FPGA using the
WiGLAN radio platform [10] and evaluated it in a wireless testbed.
(a) Hardware: The radio board of our transceiver platform connects
to the PC via the PCI bus, and acts like a regular network card. The
radio operates in the 802.11a spectrum, has a maximum operating
bandwidth of 128 MHz and a symbol time of 1 µs. We conﬁgure the
radio to use 20 MHz of bandwidth, which is the bandwidth of 802.11
channels. The FPGA is clocked at 128 MHz, and the implementation
supports standard 802.11 transmit and receive chains.
(b) Implemented Infrastructure: We implement the components
of SourceSync and an infrastructure to evaluate it for last-hop diver-
sity and opportunistic routing. Since symbol-level synchronization
requires ﬁne-grained sample level timing, we implement SourceSync
in the FPGA, using a combination of Verilog and Simulink. In order
Figure 11: Testbed map. Node locations are highlighted.
to evaluate last-hop and opportunistic diversity, we also implement
the following additional components:
(a) SampleRate: We implement SampleRate in our driver, using
MadWiﬁ as a reference. We modify SampleRate for SourceSync
last-hop diversity to perform rate adaptation only on the lead AP.
(b) ExOR: We use the reference ExOR code and implement a simpli-
ﬁed version for our topology, including ETX measurement, forwarder
computation, and a priority scheduler.
We evaluate SourceSync in an indoor testbed. Fig. 11 shows the
node locations in the experimental environment, which exhibits high
diversity due to the presence of walls, metal cabinets, desks, and
various combinations of line-of-sight and non-line-of-sight conﬁgu-
rations. The exact evaluation methodology and topologies used for
each experiment are described below.
8.1 Symbol Level Synchronization
In this section, we show that SourceSync can provide tight sym-
bol level synchronization across nodes, and that without such tight
synchronization the system may suffer signiﬁcant reduction in SNR.
8.1.1 SourceSync provides tight synchronization
First, we investigate whether SourceSync provides accurate symbol-
level synchronization across transmitters.
Method.
In this experiment, we place a pair of SourceSync
nodes acting as lead sender and co-sender, and one node acting
as a SourceSync receiver at three randomly chosen locations in our
testbed. We synchronize the two transmitters at the receiver using
SourceSync, as described in §4.4 and §4.5. Next, we want to measure
the resulting synchronization error (i.e., the time difference between
transmitters’ symbol boundaries). Recall, however, that SourceSync
works by measuring synchronization errors and feeding them back
to the transmitters in the ACK so they can synchronize their next
transmissions, as explained in §4.5. Thus, to measure SourceSync’s
synchronization error, we need an algorithm that is more accurate
than SourceSync in measuring synchronization errors. How do we
ﬁnd such an algorithm? And if such an accurate algorithm exists,
why don’t we use it in SourceSync?
We can obtain such a highly accurate algorithm if we incur very
large overhead. Speciﬁcally, instead of computing synchronization
errors using only a few symbols at the beginning of each packet, as
in SourceSync, we can replace all the data in the packet with known
symbols and use the full packet to compute synchronization errors. A
SourceSync packet starts with an initial header consisting of the lead
sender’s synchronization header followed by the co-sender’s chan-
nel estimation symbols, after which the two senders jointly transmit
their data. The regular SourceSync algorithm obtains an estimate
179 
e
l
i
t
n
e
c
r
e
p
r
o
r
r
e
n
o
i
t
i
a
z
n
o
r
h
c
n
y
s
h
t
5
9
 20
 15
 10
 5
 0
 0
 5
 10
 15
 20
 25
SNR (dB)
Figure 12: 95th percentile synchronization error. SourceSync
ensures that the synchronization error is less than 20 ns across the
operational range of 802.11 SNRs.
)
B
d
(
R
N
S
 30
 25
 20
 15
 10
 5
 0
Baseline Synchronization
SourceSync
 0
 100  200  300  400  500  600  700  800
CP (ns)
Figure 13: CP reduction with SourceSync. SourceSync enables
concurrent transmissions to achieve high SNR with a signiﬁcantly
lower CP than an unsynchronized baseline that does not compensate
for delay differences.
of the synchronization error using only the lead sender’s synchro-
nization header and the co-sender’s channel estimation symbols, as
described in §4.4 and §4.5. The error estimation algorithm, on the
other hand, replaces the data in each packet with 200 repetitions of
the initial header (i.e., the lead sender’s synchronization header and
the co-sender channel estimation symbols). Since the synchroniza-
tion error does not change within a packet, the new algorithm can
obtain 200 estimates of the synchronization error for each estimate
of SourceSync. By taking the average of these 200 estimates, the
new algorithm dramatically reduces the estimation noise, and hence
obtains an almost error free estimate of synchronization error for
that packet. Such an algorithm is ﬁne to evaluate the extent of syn-
chronization error, but its overhead precludes its use in a practical
system. For every set of locations, we transmit 2000 such packets and
measure the average SNR from the two transmitters, as well as the
transmitters’ synchronization errors using both SourceSync and the
new algorithm. We consider the new algorithm as the ground truth
and compute SourceSync’s synchronization errors with respect to the
new algorithm. We repeat the experiment with multiple randomly
chosen location triplets in our testbed.
Results. Fig. 12 shows the synchronization error between the
two transmitters when using SourceSync, as a function of the av-
erage SNR. The graph shows that SourceSync’s synchronization
algorithm is robust across a wide range of SNRs. Speciﬁcally, the
95th percentile of the synchronization error is less than 20 ns for the
operational range of 802.11 SNRs. Thus, SourceSync’s estimates can
be used to perform highly accurate symbol level synchronization.
|
2
H
|
 2.5
 2
 1.5
 1
 0.5
 0
 0
 10
 20
 30
 40
 50
 60
 70
Tap Index
Figure 14: Delay spread of a single sender. The OFDM channel in
the time domain has 15 signiﬁcant taps, which corresponds to the CP
length required with synchronization.
8.1.2 The need for accurate synchronization
SourceSync’s compensates for delays at senders to synchronize sym-
bols at the receiver, and so that the multipath tolerance of the joint
transmission is as good as with a single transmitter. In this section,
we evaluate the consequences of loose vs. tight synchronization.
Method. We place two transmitters and the receiver in a random
line-of-sight conﬁguration in our testbed. We label one transmitter
a lead sender, and the other a co-sender. Both transmitters have
identical hardware, and hence the same hardware turnaround delay.
The only difference in delays between the transmitters is due to
propagation. We compare two schemes: a baseline scheme where
the lead sender transmits a synchronization header, and the co-sender
joins the transmission without compensating for delay differences,
and SourceSync’s symbol level synchronization scheme where the
co-sender joins the transmission after an appropriate wait time as
described in §4.4. For both schemes, we calculate the average receiver
SNR of a joint transmission, and perform this calculation for various
values of the cyclic preﬁx (CP).
Results. Fig. 13 plots the SNR of the joint transmission as a
function of CP, for SourceSync, and for the baseline. We see that
SourceSync requires a far lower CP to achieve the peak SNR of
the combined transmission, in comparison with the baseline.
In
particular, SourceSync requires only a CP of 117 ns (15 samples in
our system) to achieve an SNR within 95% of the maximum, whereas
the baseline requires a CP of 469 ns (60 samples in our system).
Two points are worth noting. First, even when the transmitters have
identical turnaround times, the baseline increases the required CP
by 352 ns (45 samples) over what is required by SourceSync. By
compensating for delay differences, SourceSync can operate with a
much smaller CP, thus signiﬁcantly increasing the beneﬁts of sender
diversity. Second, the baseline has no mechanism to identify the
required increase in CP. Without this knowledge, one may pick a
CP that is too small, in which case the communication system stops
working. To prevent this scenario from occurring, one cannot simply
set the CP to 469 ns since this value may not work for a different
set of senders and receivers. One has to pick a conservative CP that
works for any network, and hence incur a large overhead.
Finally, it might seem that SourceSync’s SNR decreases at a CP
lower than 15 samples due to residual synchronization error. However,
this is not the case. The SNR reduction is due to the multipath delays
in the channel. One can see this by looking at the time domain
representation of the channel from one of the transmitters. Fig. 14
shows the magnitude of the time domain channel as a function of
tap index. We see that the channel has around 15 signiﬁcant taps.
Reducing the CP below 15 samples causes symbols to leak into each
other, and hence reduces the maximum achievable SNR of the system.
180Single Sender
SourceSync
)
B
d
(
R
N
S
e
g
a
r
e
v
A
 20
 15
 10
 5
 0
s
t
n
e
i
l