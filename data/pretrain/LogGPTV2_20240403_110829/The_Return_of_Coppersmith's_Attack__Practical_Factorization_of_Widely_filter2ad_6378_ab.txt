scribed in [73]. When compared to other implementations and
theoretical expectations on distribution of prime numbers, the keys
exhibited a non-uniform distribution of (p mod x ) and (N mod x )
for small primes x. In this work, we recovered the structure re-
sponsible for the properties. All RSA primes (as well as the moduli)
generated by the RSALib have the following form:
p = k ∗ M + (65537a mod M ).
(1)
the (cid:128)rst n successive primes Pn# = (cid:81)n
(cid:140)e integers k, a are unknown, and RSA primes di(cid:130)er only in
their values of a and k for keys of the same size. (cid:140)e integer M
is known and equal to some primorial M = Pn# (the product of
i =1 Pi = 2 ∗ 3 ∗ · · · ∗ Pn).
(cid:140)e value of M is related to the key size, where the key size is a
multiple of 32 bits for keys generated by the RSALib. (cid:140)e value
n = 39 (i.e., M = 2 ∗ 3 ∗ · · · ∗ 167) is used to generate primes for an
RSA key with a key size within the [512, 960] interval. (cid:140)e values
n = 71, 126, 225 are used for key sizes within intervals [992, 1952],
[1984, 3936], [3968, 4096].
(cid:140)e most important property of the keys is that the size of M is
large and almost comparable to the size of the prime p (e.g., M has
219 bits for the 256-bit prime p used for 512-bit RSA keys). Since
M is large, the sizes of k and a are small (e.g., k has 256 − 219 = 37
bits and a has 62 bits for 512-bit RSA). Hence, the resulting RSA
primes su(cid:130)er from a signi(cid:128)cant loss of entropy (e.g., a prime used in
512-bit RSA has only 99 bits of entropy), and the pool from which
primes are randomly generated is reduced (e.g., from 2256 to 299 for
512-bit RSA).
(cid:140)e speci(cid:128)c format of the primes has two main consequences:
1. Fingerprinting: (cid:140)e keys are (cid:128)ngerprinted based on the
existence of a discrete logarithm log65537 N mod M. While the
size of M is large, the logarithm can be computed easily since M
has small factors only. (cid:140)e keys generated by the RSALib can be
identi(cid:128)ed with a negligible error and within microseconds.
2. Factorization: During the factorization of N , we are looking
for values of a, k. A na¨ıve approach would iterate through di(cid:130)erent
values of a (treating the value of 65537a mod M as the “known bits”)
and apply Coppersmith’s algorithm to (cid:128)nd the unknown k, but the
number of a(cid:138)empts is infeasibly large, as shown in Table 1. We
found an alternative representation of the primes in question using
smaller M(cid:48) values (divisors of M), leading to a feasible number of
guesses of the value a(cid:48). (cid:140)e reduction of M is possible since the en-
tropy loss is su(cid:129)ciently high to have more than enough known bits
for the application of Coppersmith’s algorithm to lengths including
1024 and 2048 bits.
2.2 Fingerprinting
(cid:140)e public RSA modulus N is a product of two primes p, q. (cid:140)e
RSALib generates primes of the described form (1). (cid:140)e moduli
have the corresponding form:
(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)
(k ∗ M + 65537a mod M ) ∗
p
(cid:122)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:125)(cid:124)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:32)(cid:123)
(l ∗ M + 65537b mod M ),
q
(2)
N =
for a, b, k, l ∈ Z. (cid:140)e previous identity implies
N ≡ 65537a+b ≡ 65537c mod M,
(3)
for some integer c. (cid:140)e public modulus N is generated by 65537
in the multiplicative group Z∗
M . (cid:140)e existence of the discrete loga-
rithm c = log65537 N mod M is used as the (cid:128)ngerprint of the public
modulus N generated by the RSALib.
M
2.2.2
2.2.1 E(cid:128)iciency. Although the discrete logarithm problem is a
hard problem in general, in our case, it can be computed within mi-
croseconds using the Pohlig-Hellman algorithm [64]. (cid:140)e algorithm
can be used to e(cid:129)ciently compute a discrete logarithm for a group
G, whose size |G| is a smooth number (having only small factors).
(cid:140)is is exactly our case with the group G = [65537] (subgroup of
Z∗
generated by 65537). (cid:140)e size of G is a smooth number (e.g.,
M
|G| = 24 ∗ 34 ∗ 52 ∗ 7 ∗ 11 ∗ 13 ∗ 17 ∗ 23 ∗ 29 ∗ 37 ∗ 41 ∗ 53 ∗ 83 for
512-bit RSA) regardless of the key size. (cid:140)e smoothness of G is a
direct consequence of the smoothness of M. Since M is smooth
(M is a primorial, M = 2 ∗ 3 ∗ 5 ∗ · · · ∗ Pn), the size of Z∗
is even
“smoother” (|Z∗
M| = φ(M )). (cid:140)e size |G| is a divisor of |Z∗
M| (from
Lagrange’s theorem), and it is therefore smooth as well.
False positives. (cid:140)e existence of the discrete logarithm
serves as a very strong (cid:128)ngerprint of the keys. (cid:140)e reason is that
while random primes/moduli modulo M cover the entire Z∗
, the
M
RSALib generates primes/moduli from the group G – a tiny portion
of the whole group. (cid:140)e sizes |G| of the group G are listed in Table 1
in the Na¨ıve brute force (BF) column. (cid:140)e size of Z∗
is equal to
M
φ(M ). For example, |G| = 262.09 while |Z∗
M| = φ(M ) = 2215.98 for
512-bit RSA. (cid:140)e probability that a random 512-bit modulus N is
an element of G is 262−216 = 2−154. (cid:140)is probability is even smaller
for larger keys. Hence, we can make the following conclusion with
high con(cid:128)dence: an RSA key was generated by the RSALib if and
only if the Pohlig-Hellman algorithm can (cid:128)nd the discrete loga-
rithm log65537 N mod M. Our theoretical expectation was veri(cid:128)ed
in practice (see Section 3.1) with no false positives found within a
million of tested keys.
2.3 Factorization – attack principle
Our method is based on Coppersmith’s algorithm, which was origi-
nally proposed to (cid:128)nd small roots of univariate modular equations.
In [22], Coppersmith showed how to use the algorithm to factorize
RSA modulus N when high bits of a prime factor p (or q) are known.
We slightly modi(cid:128)ed the method to perform the factorization with
known p mod M (= 65537a mod M).
2.3.1 Coppersmith’s algorithm. Coppersmith’s algorithm is used
as a parametrized black box in our approach. Parameters a(cid:130)ect
the success rate and running time of the algorithm. In order to
optimize the entire factorization process, we optimized the parame-
ters of Coppersmith’s algorithm. We choose parameters so that the
Session H1:  Crypto AttacksCCS’17, October 30-November 3, 2017, Dallas, TX, USA1633algorithm will certainly (cid:128)nd unknown bits of the factor and so the
computation time will be minimal. (cid:140)e fraction of known bits of the
factor determines the optimal parameters (100% success rate, best
speed) of the algorithm. Coppersmith’s algorithm is slowest when
using the required minimum of known bits (half of the bits of the
factor). With more bits known, the running time of the algorithm
decreases.
2.3.2 Na¨ıve algorithm. For N of the form (2), we look for factor
p or q. In order to (cid:128)nd a prime factor (say, p), one has to (cid:128)nd the
integers k, a. A na¨ıve algorithm would iterate over di(cid:130)erent options
of 65537a mod M and use Coppersmith’s algorithm to a(cid:138)empt to
(cid:128)nd k. (cid:140)e prime p (q, respectively) is found for the correct guess of
parameter a (b). (cid:140)e cost of the method is given by the number of
guesses (ord) of a and the complexity of Coppersmith’s algorithm.
(cid:140)e term ord represents the multiplicative order of 65537 in the
group Z∗
(ord = ordM (65537)) and can be computed simply using
M
the technique described in Section 2.6. In practice, ord determines
the running time of the entire factorization. (cid:140)e number of a(cid:138)empts
is too high (see Table 1, Na¨ıve BF # a(cid:136)empts) even for small key
sizes. Decreasing the number of a(cid:138)empts is necessary to make the
method practical.
2.3.3 Main idea. A crucial observation for further optimization
is that the bit size of M is analogous to the number of known bits
in Coppersmith’s algorithm. It is su(cid:129)cient to have just lo❕2(N )/4
bits of p for Coppersmith’s algorithm [22]. In our case, the size of
M is much larger than required (lo❕2 (M ) > lo❕2(N )/4). (cid:140)e main
idea is to (cid:128)nd a smaller M(cid:48) with a smaller corresponding number
of a(cid:138)empts ordM(cid:48) (65537) such that the primes are still of the form
(1), with M replaced by M(cid:48) and a, k replaced by a(cid:48), k(cid:48). (cid:140)e form
of the primes p, q implies that the modulus N is of the form (2)
and (3) also for M(cid:48) – of course with new corresponding variables
a(cid:48), b(cid:48), c(cid:48), k(cid:48), l(cid:48).
In order to optimize the na¨ıve method, we are looking for M(cid:48)
such that:
(1) primes (p, q) are still of the form (1) – M(cid:48) must be a divisor
of M;
(2) Coppersmith’s algorithm will (cid:128)nd k(cid:48) for correct guess of
a(cid:48) – enough bits must be known (lo❕2 (M(cid:48)) > lo❕2(N )/4);
(3) overall time of the factorization will be minimal – number
of a(cid:138)empts (ordM(cid:48) (65537)) and time per a(cid:138)empt (running
time of Coppersmith’s algorithm) should result in a mini-
mal time.
For practical factorization, there is a trade-o(cid:130) between the num-
ber of a(cid:138)empts and the computational time per a(cid:138)empt as Cop-
persmith’s algorithm runs faster when more bits are known (see
Figure 2). In fact, we are looking for an optimal combination of
value M(cid:48) and parameters (m, t – for more details, see Section 2.7)
of Coppersmith’s algorithm. It should be noted that the search for
value of M(cid:48) is needed only once for each key size. (cid:140)e optimal pa-
rameters M(cid:48), m, t along with N serve as inputs to our factorization
Algorithm 1.
2.3.4 Results. (cid:140)e optimized values of M(cid:48) for di(cid:130)erent key
lengths were found along with parameters m, t using a local brute
force search optimized by the results of a greedy heuristic. (cid:140)e
size of the resulting M(cid:48) is more than the bound lo❕2 (N )/4 but is
: N , M(cid:48), m, t
(cid:102)
Input
Output:p – factor of N
(cid:103)
c(cid:48) ← log65537 N mod M(cid:48)
ord(cid:48) ← ordM(cid:48) (65537)
forall a(cid:48) ∈
c(cid:48)
2 , c(cid:48)+ord(cid:48)
2
do
(cid:46) Use Pohlig–Hellman alg;
(cid:46) See Section 2.6 for method;
f (x ) ← x + (M(cid:48)−1 mod N ) ∗ (65537a(cid:48) mod M(cid:48)) (mod N );
(β, X ) ← (0.5, 2 ∗ N β /M(cid:48))
k(cid:48) ← Coppersmith( f (x ), N , β, m, t, X );
p ← k(cid:48) ∗ M(cid:48) + (65537a(cid:48) mod M(cid:48)) (cid:46) Candidate for a factor;
if N mod p = 0 then
end
(cid:46) Se(cid:138)ing parameters;
return p
end
Algorithm 1: (cid:140)e factorization algorithm for RSA public keys N
generated by the RSALib. (cid:140)e input of the algorithm is a modu-
lus N of the form (1) with M(cid:48) as a product of small primes and
optimized parameters m, t for Coppersmith’s method.
relatively close to it. (cid:140)e resulting order (Table 1, Optimized BF
# a(cid:136)empts) is small enough for the factorization of 512, 1024 and
2048-bit RSA to be practically feasible. Figure 1 summarizes the
factorization complexity and relevant parameters for all key lengths
between 512 and 4096 bits with 32-bit steps. (cid:140)e search space of
a(cid:48) can be trivially partitioned and parallelized on multiple CPUs.
We veri(cid:128)ed the actual performance of the proposed factorization
method on multiple randomly selected public keys.
2.4 Coppersmith’s algorithm in detail
(cid:140)ere are various a(cid:138)acks on RSA based on Coppersmith’s algorithm
(for a nice overview, see [57]). (cid:140)e algorithm is typically used in
scenarios where we know partial information about the private key
(or message) and we want to compute the rest. (cid:140)e given problem
is solved in the three steps:
problem → f (x ) ≡ 0 mod p → ❕(x ) = 0 → x0
First, we transform the given problem to the modular polynomial
equation f (x ) ≡ 0 mod p with an unknown p (divisor of some
known N ) and the small root x0 (f (x0) ≡ 0 mod p) we are looking
for. (cid:140)e root x0 should be smaller than some su(cid:129)ciently small
constant X (i.e., |x0| < X). (cid:140)e polynomial f (x ) ∈ Z[x] should be
constructed so that the root x0 solves the problem. In the second
step, Coppersmith’s algorithm eliminates the unknown p by trans-
forming the modular equation to the equation ❕(x ) = 0 over the
integers that have the same roots (i.e., x0 is a root of ❕(x )). In the
third step, all roots x0 of the integer polynomial ❕(x ) are found eas-
ily by standard methods (e.g., the Berlekamp-Zassenhaus algorithm
[8, 21]).
as a linear combination ❕(x ) =(cid:80)
(cid:140)e polynomial ❕(x ) is constructed in Coppersmith’s algorithm
i ai ∗ fi (x ), ai ∈ Z of some poly-
nomials fi (x ) derived from f (x ). (cid:140)e polynomials fi are chosen so
that fi (x ) and f (x ) have the same roots modulo p. (cid:140)is implies that