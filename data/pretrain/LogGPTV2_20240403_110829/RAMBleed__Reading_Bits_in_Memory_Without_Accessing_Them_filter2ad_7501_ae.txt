in which a 0-1-0 stripe refuses to Ô¨Çip. We can then template
with the opposite stripe pattern (1-0-1) and achieve a 95%
accuracy rate on the zero-valued bits.
VII. ATTACKING OPENSSH
To demonstrate the practical risk that RAMBleed poses to
memory conÔ¨Ådentiality, in this section we present an end-to-
end attack against OpenSSH 7.9 that allows an unprivileged
attacker to extract the server‚Äôs 2048-bit RSA private signing
key. This key is what allows an SSH server to authenticate
itself to incoming connections. As such, a break of this key
enables the attacker to masquerade as the server,
thereby
allowing her to conduct man-in-the-middle (MITM) attacks
and decrypt all trafÔ¨Åc from the compromised sessions.
At a high level, our attack operates by coercing the server‚Äôs
SSH daemon to repeatedly allocate and place its private key
material at vulnerable physical locations. We then use double-
sided RAMBleed to recover a portion of the bits that make
up the server‚Äôs RSA key. Finally, we utilize the mathematical
redundancy in RSA keys to correct for errors in extracted
bits, as well as recover missing bits that we were unable to
read directly. Before describing our attacks, we now describe
how OpenSSH manages and uses its keys in response to
incoming SSH requests, and how we adapted the techniques
from Section V to speciÔ¨Åcally target OpenSSH.
A. Overview of OpenSSH
The OpenSSH daemon is a root-level process that binds to
port 22 and has access to a root-accessible Ô¨Åle, which stores
the server‚Äôs RSA private key. As shown in Figure 5, when a
TCP connection arrives on port 22, the daemon spawns a child
process that handles the authentication phase of incoming SSH
connections. The child is responsible for both authenticating
the server to the client as well as authenticating the client
to the server. While the latter can be done either via public-
private key pair, or by supplying a password, the former is
done by having the server use its RSA private key to sign a
challenge issued by the client. Finally, once authentication is
complete, the child process spawns an unprivileged grandchild
for handling the user‚Äôs connection. See Figure 5.
Key Memory Management.
The child process that is
spawned by the SSH demon for mutually authenticating an
incoming SSH request must Ô¨Årst read in the server‚Äôs private
key from the key Ô¨Åle into a temporary buffer. At this point,
the key will actually be located in memory in two places:
namely, the temporary buffer and the OS‚Äô page cache. Un-
fortunately, we cannot read either of these memory locations
via RAMBleed. For the former, this buffer gets overwritten
immediately, before we have any chance to read even a single
bit using RAMBleed. The latter copy is also inaccessible as it
is stored inside the OS‚Äô page cache, which is located in a static
region of physical memory that is not moved around. Luckily,
OpenSSH‚Äôs authentication process then proceeds to copy the
keys into a new buffer maintained by a global structure,
aptly named ‚Äúsensitive data‚Äù. This buffer remains in physical
memory for the duration of the connection. Thus, our attack
aims to read the private key material from this structure.
We now proceed to describe our attack on OpenSSH.
B. Attack Overview
Our Ô¨Årst step is to proÔ¨Åle memory, looking for Ô¨Çippable
bits. We do this in the same manner described in Section V-B.
After Ô¨Ånding a sufÔ¨Åcient number of Ô¨Çips, we begin the reading
phase, in which we perform RAMBleed to leak a single bit at
a time. At a high level, for each templated bit, we use Frame
Feng Shui to place private key material in the conÔ¨Åguration
shown in Figure 3, where A1 is the page containing the
Ô¨Çippable bit. We then perform double-sided RAMBleed to leak
the bit‚Äôs value and proceed to the next bit.
C. Overcoming OpenSSH‚Äôs Memory Allocation Pattern
To use Frame Feng Shui against OpenSSH, we must
determine the value n, which is the number of pages we
must unmap after vacating the target frame in order to cause
OpenSSH to place the secret in the targeted frame location.
Examining the behavior of OpenSSH 7.9 on our system, we
found that its allocations pattern is predictable, which allows
us to use Frame Feng Shui with a high success rate. More
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:39:51 UTC from IEEE Xplore.  Restrictions apply. 
704




	


""
	




 #

	






	















	






	






 
 !
(a) The attacker initially owns both target pages T0 and T1.
(b) The attacker makes an SSH connection and performs Frame Feng
Shui to land the secret S in the target page T0, which lies above the
sampling page (A1).
!""
	




#

	






	



	













	





	



 

(c) The attacker repeats the Frame Feng Shui process to land S in
the target page T1, below the sampling page (A1).
(d) After achieving the double-sided RAMBleed position, the attacker
now hammers the activation pages (A0 and A2) to induce Ô¨Çips in the
sampling page (A1).
Fig. 5: Overview of our attack on OpenSSH
speciÔ¨Åcally, we found that OpenSSH uses the default RSA
key size of 2048 bits, with the following allocation pattern.
‚Ä¢ First, the page containing d, the RSA private exponent, is
allocated 101 pages after the daemon accepts a new TCP
connection. See Section II-D for RSA notation.
‚Ä¢ Next, a single page containing both p and q is allocated 102
pages after the daemon accepts a new connection.
‚Ä¢ Finally, a single page that contains both dp and dq is
allocated 104 pages after accepting a new connection.
Furthermore, all the private key values mentioned above are lo-
cated at the same offset within their page upon every incoming
connection. Thus, we Ô¨Åx n = 100, 101, and 104 respectively
for d, p and q, and dp, dq. Next, to obtain the conÔ¨Åguration in
Figure 3, we call munmap on the page above A1 and follow
it with n munmaps on random pages. We then immediately
make a TCP connection, causing the SSH daemon to make n
allocations, followed by allocating the secret-containing page,
which will then be placed in the target frame. By holding the
TCP connection open, we can repeat the process to place the
page in the frame below A1, thereby creating two copies of
the secret in memory to facilitate double-sided RAMBleed.
Accounting for Allocation Noise. The memory placement
technique described above is much more susceptible to noise,
as many CPU cycles pass between the point of the original
unmapping by the attacker and when the victim maps the
key-containing page. Thus,
if any pages are allocated or
deallocated in that time frame by another process, the key-
containing pages will not be placed in the desired locations.
To minimize this noise, the attacker yields the scheduler before
performing the page deallocaitons, allowing other scheduled
system activity to execute. Next, we also use a busy loop after
unmapping the pages and before reading the bits, waiting a
Ô¨Åxed amount of time for OpenSSH to perform the required
allocations. We note here that if we replace the busy loop
with a sleep operation, this will likely cause the system to
schedule another process and destroy the memory layout. After
using RAMBleed to read the bit(s), we close the connections,
triggering the daemon to kill the two children.
After mitigating noise in this manner, the memory place-
ment process succeeds against OpenSSH with 83% probability.
This means that we will be in the double-sided-RAMBleed sit-
uation 0.832 = 68.89% of the time, in single-sided RAMBleed
2 ¬∑ 0.83 ¬∑ 0.17 = 28.22% of the time, and 0.172 = 2.39% of
the time we will be unable to place the target page near the
Ô¨Çipping row, resulting in random guessing. This, along with
potential for RAMBleed to misread bits, gives us an overall
accuracy of 82% when reading the OpenSSH host key.
Key Recovery. To recover the key from the noisy bits, we
use a variant of Paterson et al. [46]‚Äôs algorithm, an adaptation
of the Heninger-Shacham algorithm [24] for the case that key
bits are only known with some probability. SpeciÔ¨Åcally, the
algorithm aims to reconstruct the key, bit by bit, starting from
the least signiÔ¨Åcant bit. By relating the public (N, e) and
private (d, p, q, dp, and dq) key components, the algorithm
prunes potential keys and dramatically reduces the search
space. The algorithm explores a search tree of potential keys
while pruning branches that contradict known bits or have a
large number of mismatches with probabilistically recovered
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:39:51 UTC from IEEE Xplore.  Restrictions apply. 
705
Type
Double-sided RAMBleed
Single-sided RAMBleed
Unable to place victim
Probability
68.89%
28.22%
2.39%
TABLE II: Probability of OpenSSH placing pages containing
private key material into double-sided, single-sided, or unable-
to-place situations.
bits. Our approach is similar to Paterson et al. [46], but instead
uses a depth-Ô¨Årst search in place of a bread-Ô¨Årst search.
Through a series of simulations on random RSA 2048
bit keys, we empirically found that our amended Heninger-
Shacham algorithm requires 68% recovery of the private key
material (d, p, q, dp, dq) with an 82% accuracy. This implies
that 4200 distinct bits of private key material is sufÔ¨Åcient to
extract the complete key.
D. Overall Attack Performance
Memory Templating. We begin our attack by locating the
Ô¨Çippable bits in the memory of the target machine. Using the
techniques presented in Sections IV and V, we proÔ¨Åled the
machine‚Äôs memory to locate Rowhammer induced bit Ô¨Çips. We
note here that the time required to template memory and Ô¨Ånd
the required Ô¨Çips is entirely dependent upon the susceptibility
of underlying DIMMs to Rowhammer attacks. While [21, 37]
report Ô¨Ånding thousands of Ô¨Çips within minutes, we found
Ô¨Çips at a more modest rate of 41 Ô¨Çips per minute, giving us a
running time of 34 hours to locate the 84K bit Ô¨Çips required
for the next phase of the attack.2
32768 = 3