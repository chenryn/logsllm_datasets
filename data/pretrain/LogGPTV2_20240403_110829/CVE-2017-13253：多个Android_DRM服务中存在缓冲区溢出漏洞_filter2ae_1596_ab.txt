之前，我提到了不同的DRM方案。在Android官方术语中，每种DRM方案的处理程序都称为是插件，或者在一些特定情况下会被称为加密插件。供应商负责提供这些插件，但是AOSP中还有一些提供给销售商使用的有效代码。例如，AOSP包含ClearKey
DRM方案插件的完整开源实现方式。通常，设备将具有开源的ClearKey插件和闭源的Widevine插件（例如Nexus/Pixel设备）。  
上述Treble项目发生变化导致的一个问题是，目前插件接收了HAL格式的数据。为了让转换过程更为简单，我们并不需要对每个插件都进行更新，默认的CryptoPlugin实现已经添加到AOSP中，可以让供应商使用。这一实现会将数据从HAL格式转换为传统的格式，并将其传递给原始插件代码。如果不出所料的话，这一解决方案只是暂时性的，后续还会对插件进行更新。否则，系统将会出现冗余格式转换的问题。
###  针对源代码的研究
在介绍ICrypto解密方法的一般过程之后，我们来仔细看看共享内存缓冲区的验证代码。正如读者可能已经猜到的那样，这正是发现漏洞的地方。  
如前所述，验证通常从Bn*类开始，在我们的例子中就是ICrypto接口的“服务器端”BnCrypto。
首先，代码会检查子采样大小的总和是否有效，并确保其不会溢出。请注意，在这里是要复制的数据的大小。  
它还会检查这一总和是否与totalSize匹配。通过Binder传递的另一个参数非常多余，我们可以完全通过子样本的总和来得知总大小。  
接下来的检查是数据大小不能超过源缓冲区的大小。  
最后，它还会检查数据大小加上偏移量之后是否仍然不超过源缓冲区。  
在这里，CryptoHal会将数据转换为HAL格式并发送给相关的插件，这里并没有有趣的验证代码。  
接下来，默认的Crypto Plugin实现会将数据转换回传统格式，并继续对其进行验证。
通过仔细阅读这个代码，我发现代码中有一些混乱。其中有多个“dest”和“source”变量，但实质上sourceBase与destBase是完全相同的，并且没有任何注释能帮助我们理解。考虑到Android
8.0中进行了相应更新，所以我非常怀疑是这一更新导致了该漏洞的存在，使得整个验证代码工作更为完整。  
在这里，首先要检查偏移量与缓冲区大小的总和应该不超过堆大小。SourceBase是堆，而源是之前的source.mSharedMemory。如果读者对两个偏移量比较困惑，记住mSharedMemory包含一个偏移量，并且解密方法也有一个不同的偏移量参数。  
其他的检查与上述类似，但是是在目标缓冲区上进行。destBuffer的堆与destination.mSharedMemory相同，只是这次不涉及到偏移量参数。  
在最后，每个缓冲区都会简化为一个指向内存的指针，而偏移量现在是指针的一部分，缓冲区大小则被省略。为了确定数据大小，插件使用subSamples数组。
上述代码展现了最后一部分，希望能帮助读者们理解相关的流程。当数据未加密时，它只是从一个地方复制到另一个地方。  
截至目前，我已经提供了挖掘漏洞所需的足够信息，理论上大家可以按照我的上述内容去发现这个漏洞。
## 漏洞详情
该漏洞的原因在于，没有验证被复制的数据是否超过了目标缓冲区。由于该过程中只对源缓冲区进行了一次检查，对目标缓冲区进行检查默认是Crypto
Plugin的第二次检查，确保缓冲区位于堆内并且不超过边界，但这是远远不够的。  
我们来看一个例子。假设我们要复制的数据大小为0x1000。由于这个大小是由subsamples数组表示的，因此在该数组中将会有一个条目，其中包含0x1000个字节（以及0个加密字节）。堆的大小也是0x1000字节，源缓冲区将指向整个堆（偏移量
= 0，大小 =
0x1000）。目标缓冲区是出现问题的地方，我们假设偏移量是0x800，大小为0x800，这仍然可以通过默认加密插件的检查。但在这种情况下会出现溢出的情况，0x800字节将被写入在堆的后面。
###  PoC
请注意，MemoryBase对象是IMemory
libbinder接口的实现。这是一个使用Binder将引用传递给其他Binder对象的例子。这也是Binder角色反过来的一个例子。特权流程是“客户端”，因此它会通过Binder请求信息，并对其进行验证。
###  漏洞产生的影响
该漏洞允许攻击者使用任意数据覆盖目标进程中的内存。由于这是内存页级别的溢出，因此暂时没有任何缓解措施可以阻止这一漏洞的利用。由于默认Crypto
Plugin的检查，数据必须从共享内存开始，这一点仍然受到限制。这也就意味着，只有位于共享内存之后的内存才可以被覆盖。此外，内存中的许多部分通常是未分配或不允许写入的，如果尝试在其中进行写入将导致出现段错误。  
受影响的进程取决于供应商的设置。如果供应商不将HAL分成不同的进程，那么mediadrmserver会受到影响；如果供应商将它们分开，那么Crypto
Plugin的每个HAL服务都会受到影响。由于默认的Crypto
Plugin代码仅仅会留下指向目标缓冲区的指针，并且大小仅有子样本决定，供应商的代码并不能发现它接收到了格式错误的数据。这一点说明，供应商编写的这一部分代码仍然是脆弱的。理论上，供应商可能会忽略AOSP的默认加密插件代码，并利用自己的代码来检测格式错误的数据，但实际上，我没有发现任何供应商能这么做。
###  可能产生的影响
假设攻击者设法利用此漏洞将特权提升为易受攻击服务的特权，那么让我们来看看他可以实现的功能。请注意，这部分大多是推测性的。我没有编写漏洞利用表，但是我对于如何借助该漏洞升到具有完整root权限有一些思路。  
现在，就是Android的SELinux规则发挥作用的地方。即使易受攻击的服务拥有更多的权限，SELinux仍会严重限制它们。尽管如此，即使在限制之后，我们仍然留下了一个非常有趣的权限：完全访问TEE设备。  
在这种情况下，
Treble项目的额外隔离几乎没有任何作用。易受攻击的进程将是可以访问TEE设备的进程，无论是否它存在分离到多个进程。在分离的情况下保护的唯一过程是中介服务器。  
那么，我们可以通过完全访问TEE来做些什么？ 根据Gal
Beniamini的研究表明，许多设备无法正确吊销旧的易受攻击的TEE信任。这意味着，如果我们攻击具有旧的易受攻击的Trustlet的设备，则可以使用TEE设备的访问权限，加载Trustlet并将其用于TEE上的代码执行。更重要的是，Gal
Benimaini此前也展示过基于Qualcomm设备的TEE代码执行如何实现root特权。
###  漏洞成因
前面，我已经多次提到Treble项目中是如何对代码的部分区域进行重大修改。在修改之前，目标缓冲区甚至无法以这样的格式设置。就在这一修改之后，引入了此漏洞。  
正如前文所说，重构的这部分代码中，有很多地方都比较混乱，也存在一些冗余的内容。尽管代码混乱或出现冗余并不一定会使代码易受攻击，但它确实提高了这种可能性，因为它使代码更难以审计。因此，虽然有时我们难以发现漏洞，但却更容易发现混乱或冗余的代码。尽管我深知，与实际编写出好的代码相比，对不好的代码进行批评是更加容易的，但我要坚持提出，我认为这部分的代码应该进行改进。
## 结论
尽管Google声称，Treble项目有助于提升Android的安全性，但在这个例子中却完全相反。Treble项目本身并没有什么问题，但关键问题是其实现的过程处理的不是非常好。  
大家可以在GitHub上面找到触发漏洞的PoC的完整源代码，同时还有一些额外的信息。
## 时间线
2017年12月20日 发现漏洞  
2017年12月28日 将漏洞详情和PoC提交给Google  
2017年12月29日 收到Google的初步回应  
2018年3月5日 Google发布补丁