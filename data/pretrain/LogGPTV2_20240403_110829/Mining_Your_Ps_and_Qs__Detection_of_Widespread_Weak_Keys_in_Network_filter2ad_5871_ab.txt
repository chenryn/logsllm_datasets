Our TLS scan
(10/2011)
28,923,800
12,828,613
5,656,519
6,241
5,847,957
1,956,267
Our SSH scans
(2-4/2012)
23,237,081
10,216,363
3,821,639
2,789,662
—
—
Table 1: Internet-wide scan results — We exhaustively scanned the public IPv4 address space for TLS and SSH
servers listening on ports 443 and 22, respectively. Our results constitute the largest such network survey reported to
date. For comparison, we also show statistics for the EFF SSL Observatory’s most recent public dataset [18].
protocol handshakes using libevent. Initially, we ran the
fetcher from an EC2 Large instance in a run that started
on February 12, 2012. This run targeted only RSA-based
host keys. In two later runs, we targeted DSA-based host
keys, and rescanned those hosts that had offered DSA
keys in the ﬁrst SSH scan. For these, we also stored the
authentication signature provided by the server; we varied
the client string to ensure that each signature would be
distinct. The ﬁrst DSA run started on March 26, 2012
from a host at UCSD. The second run, from a host at the
University of Michigan, started on April 1, 2012; it took
3 hours to complete.
TLS certiﬁcate processing
For TLS, we performed a
third processing stage in which we parsed the previously
fetched certiﬁcate chains and generated a database from
the X.509 ﬁelds. We implemented a certiﬁcate parser in
Python and C primarily based on the M2Crypto SWIG
interface to the OpenSSL library.
3.2 Identifying vulnerable device models
We attempted to determine what hardware and software
generated or served the weak keys we identiﬁed using
manual detective work. The most straightforward method
was based on TLS certiﬁcate information—predominately
the X.509 subject and issuer ﬁelds. In many cases, the
certiﬁcate identiﬁed a speciﬁc manufacturer or device
model. Other certiﬁcates contained less information; we
attempted to identify these devices through Nmap host
detection or by inspecting the public contents of HTTPS
sites or other IP services hosted on the IP addresses.
When we could identify a pattern in vulnerable TLS
certiﬁcates that appeared to belong to a device model or
product line, we constructed regular expressions to ﬁnd
other similar devices in our scan results. Under the theory
that the keys were vulnerable because of a problem with
the design of the devices (where they were most likely
generated), this allows us to estimate the total population
of devices that might be potentially vulnerable, beyond
those serving immediately compromised keys.
Identifying SSH devices was more problematic, as SSH
keys do not include descriptive ﬁelds and the server iden-
tiﬁcation string used in the protocol often indicated only
a common build of a popular SSH server. We were able
to classify many of the vulnerable SSH hosts using a
combination of TCP/IP ﬁngerprinting and examination of
information served over HTTP and HTTPS.
The device names and manufacturers that we report
here have been identiﬁed with moderate or high conﬁ-
dence given the available information. However, because
we do not have physical access to the hosts, we cannot
state with certainty that all our identiﬁcations are correct.
3.3 Efﬁciently computing all-pairs GCDs
We now describe how we efﬁciently computed the pair-
wise GCD of all distinct RSA moduli in our multimillion-
key dataset. This allowed us to calculate RSA private
keys for 66,540 vulnerable hosts that shared one of their
RSA prime factors with another host in our survey.
The fastest known factoring method for general integers
is the number ﬁeld sieve, which has heuristic complex-
ity O(2n1/3(logn)2/3
) for n-bit numbers [30]. In contrast
to factoring, the greatest common divisor (GCD) of two
integers can be computed very efﬁciently using Euclid’s
algorithm. Using fast integer arithmetic, the complexity
of GCD can be improved to O(n(lgn)2 lglgn) [7]. Com-
puting the GCD of two 1024-bit RSA moduli using the
GMP library [20] takes approximately 15 µs on a current
mid-range computer.
The naïve way to compute the GCDs of every pair of
integers in a large set would be to apply a GCD algorithm
to each pair individually. There are 6 × 1013 distinct
pairs of RSA moduli in our data; at 15 µs per pair, this
calculation would take 30 years. We can do much better
by using a more efﬁcient algorithm.
To accomplish this, we implemented a quasilinear-time
algorithm for factoring a collection of integers into co-
primes, based on Bernstein [6]. The relevant steps, illus-
trated in Figure 1, are as follows:
4 Vulnerabilities
We analyzed the data from our TLS and SSH scans and
identiﬁed several patterns of vulnerability that would have
been difﬁcult to detect without a macroscopic view of
the Internet. This section discusses the details of these
problems, as summarized in Table 2.
4.1 Repeated keys
We found that 7,770,232 of the TLS hosts (61%) and
6,642,222 of the SSH hosts (65%) served the same key
as another host in our scans. To understand why, we
clustered certiﬁcates and host keys that shared the same
public key and manually inspected representatives of the
largest clusters. In all but a few cases, the TLS certiﬁcate
subjects, SSH version strings, or WHOIS information
were identical within a cluster, or pointed to a single
manufacturer or organization. This sometimes suggested
an explanation for the shared keys.
Not all of the repeated keys were due to vulnerabili-
ties. For instance, many of the most commonly repeated
keys appeared in shared hosting situations. Six of the ten
most common DSA host keys and three of the ten most
common RSA host keys were served by large hosting
providers (see Figure 2). Another frequent reason for
repeated keys was distinct TLS certiﬁcates all belonging
to the same organization. For example, TLS hosts at
google.com, appspot.com, and doubleclick.net all served
distinct certiﬁcates with the same public key. We excluded
these cases and attributed remaining clusters of shared
keys to several classes of problems.
Default keys A common reason for hosts to share
the same key that we do consider a vulnerability is
Figure 2: Commonly repeated SSH keys — We investi-
gated the 50 most repeated SSH host keys for both RSA
and DSA. Nearly all of the repeats appeared to be due
either to hosting providers using a single key on many IP
addresses or to devices that used a default key or gener-
ated keys using insufﬁcient entropy. Note log scale.
Figure 1: Computing all-pairs GCDs efﬁciently — We
computed the GCD of every pair of RSA moduli in our
dataset using an algorithm due to Bernstein [6].
Algorithm 1 Quasilinear GCD ﬁnding
Input: N1, . . . ,Nm RSA moduli
1: Compute P = ∏Ni using a product tree.
2: Compute zi = (P mod N2
i ) for all i
using a remainder tree.
Output: gcd(Ni,zi/Ni) for all i.
A product tree computes the product of m numbers by
constructing a binary tree of products. A remainder tree
computes the remainder of an integer modulo many inte-
gers by successively computing remainders for each node
in their product tree. For further discussion, see [7].
The ﬁnal output of the algorithm is the GCD of each
modulus with the product of all the other moduli. We
are interested in the moduli for which this GCD is not 1.
However, if a modulus shares both of its prime factors
with two other distinct moduli, then the GCD will be
the modulus itself rather than one of its prime factors.
This occurred in a handful of instances in our dataset; we
factored these moduli using the naïve quadratic algorithm
for pairwise GCDs.
We implemented the algorithm in C using the GMP
library for the arithmetic operations and ran it on the
11,170,883 distinct RSA moduli from our TLS and SSH
datasets and the EFF SSL Observatory [18] dataset.
The entire computation ﬁnished in 5.5 hours using a
single core on a machine with a 3.30 GHz Intel Core i5
processor and 32 GB of RAM. The remainder tree took
approximately ten times as long to process as the product
tree. Parallelized across sixteen cores on an EC2 Cluster
Compute Eight Extra Large Instance with 60.5 GB of
RAM and using EBS-backed storage for scratch data, the
same computation took 1.3 hours at a cost of about $5.
N1N2N3N4×N4N3×N2N1N1N2N3N4modN21N22modN21/N1·modN22/N2·modN23N24modN23/N3·modN24/N4·gcd(,N1)gcd(,N2)gcd(,N3)gcd(,N4)producttreeremaindertree10410550mostrepeatedRSASSHkeysNumberofrepeatsDevicesHostingprovidersUnknown/otherNumber of live hosts
. . . using repeated keys
. . . using vulnerable repeated keys
. . . using default certiﬁcates or default keys
. . . using low-entropy repeated keys
. . . using RSA keys we could factor
. . . using DSA keys we could compromise
. . . using Debian weak keys
. . . using 512-bit RSA keys
. . . identiﬁed as a vulnerable device model
. . . model using low-entropy repeated keys
Our TLS Scan
Our SSH Scans
12,828,613 (100.00%)
(60.50%)
7,770,232
(5.57%)
714,243
670,391
(5.23%)
(0.34%)
43,852
64,081
(0.50%)
4,147
123,038
985,031
314,640
(0.03%)
(0.96%)
(7.68%)
(2.45%)
10,216,363 (100.00%)
(65.00%)
6,642,222
981,166
(9.60%)
2,459
105,728
53,141
8,459
1,070,522
(0.03%)
(1.03%)
(0.52%)
(0.08%)
(10.48%)
Table 2: Summary of vulnerabilities — We analyzed our TLS and SSH scan results to measure the population of
hosts exhibiting several entropy-related vulnerabilities. These include use of repeated keys, use of RSA keys that were
factorable due to repeated primes, and use of DSA keys that were compromised by repeated signature randomness.
Under the theory that vulnerable repeated keys were generated by embedded or headless devices with defective designs,
we also report the number of hosts that we identiﬁed as these device models. Many of these hosts may be at risk even
though we did not speciﬁcally observe repeats of their keys.
manufacturer-default keys. These are preconﬁgured in
the ﬁrmware of many devices, such that every device of
a given model shares the same key pair unless the user
changes it. The private keys to these devices may be
accessible through reverse engineering, and published
databases of default keys such as littleblackbox [24] con-
tain private keys for thousands of ﬁrmware releases.
At least 670,391 (5.23%) of the TLS hosts appeared
to serve manufacturer-default certiﬁcates or keys. We
classiﬁed a certiﬁcate as a manufacturer default if nearly
all the devices of a given model used identical certiﬁcates,
or if the certiﬁcate was labeled as a default certiﬁcate.
The most common default certiﬁcate that we could
ascribe to a particular device belonged to a model of
consumer router. Our scan uncovered 90,779 instances
of this device model sharing a single certiﬁcate. We also
found a variety of enterprise products serving default keys,
including server management devices, network storage
devices, routers, remote access devices, and VoIP devices.
For most of the repeated SSH keys, the lack of uniquely
identifying host information prevents us from distinguish-
ing default keys from keys generated with insufﬁcient
entropy, so we address these together in the next section.
Repeated keys due to low entropy Another common
reason that hosts share the same key appears to be entropy
problems during key generation. In these instances, when
we investigated a key cluster, we would typically see
thousands of hosts across many address ranges, and, when
we checked the keys corresponding to other instances of
the same model of device, we would see a long-tailed
distribution in their frequencies. Intuitively, this type of
distribution suggests that the key generation process may
be using insufﬁcient entropy, with distinct keys due to
relatively rare events. For TLS, our investigations began
with the keys that occurred in at least 100 distinct self-
signed certiﬁcates. For SSH, we started from the 50 most
commonly repeated keys for each of RSA (appearing on
more than 8000 hosts) and DSA (more than 4000 hosts).
With this process, we identiﬁed 43,852 TLS hosts
(0.34%) that served repeated keys due apparently to low
entropy during key generation. 27,545 certiﬁcates (98%)
containing these repeated keys were self-signed; all 577
CA-signed certiﬁcates identiﬁed Iomega StorCenter net-
work storage devices. For most SSH hosts we were unable
to distinguish between default keys and keys repeated
due to entropy problems, but 981,166 of the SSH hosts
(9.60%) served keys repeated for one of these reasons.
We used the techniques described in Section 3.2 to iden-
tify apparently vulnerable devices from 27 manufacturers.
These include enterprise-grade routers from Cisco and
Juniper; server management cards from Dell, Hewlett-
Packard, and IBM; virtual-private-network (VPN) de-
vices; building security systems; network attached storage
devices; and several kinds of consumer routers and VoIP
products.
Duplicated keys are a red ﬂag that calls the security
of the device’s key generation process into question, and
all keys generated with the same model device should be
considered suspect. For 14 of the TLS devices generating
repeated keys, we were able to infer a ﬁngerprint for the
device model and estimate the total population of the de-
vice in our scan. The prevalence of duplicated keys varied
greatly for different device models, from as low as 0.2%
(a) Primes generated by Juniper SSG 20 ﬁrewall
(b) Primes generated by IBM Remote Supervisor Adapter
Figure 3: Visualizing RSA common factors — Different implementations displayed different patterns of vulnerable
keys. These plots depict the distribution of vulnerable keys divisible by common factors generated by two different
device models. Each column represents a collection of RSA moduli divisible by a single prime factor p. The color
and internal rectangles show, for each p, the frequencies of each distinct prime factor q. The Juniper device (left; note
log-log scale) follows a long-tailed distribution that is typical of many of the devices we identiﬁed. In contrast, the IBM
remote access device (right) was unique among those we observed in that it generates RSA moduli roughly uniformly
distributed among nine distinct prime factors.
in the case of one router to 98% for one thin client. The
total population of these identiﬁed, potentially vulnerable
TLS devices was 314,640 hosts, which represents 2.45%
of the TLS hosts in our scan.
In the above analyses, we excluded repeated keys that
were due to the infamous Debian weak-key vulnerabil-
ity [5, 37], which we report separately in Table 2.
4.2 Factorable RSA keys
A second way that entropy problems might manifest them-
selves during key generation is if an RSA modulus shares
one of its prime factors p or q with another key. As ex-
plained in Section 2.1, ﬁnding such a pair immediately
allows an adversary to efﬁciently factor both moduli and
obtain their private keys. In order to ﬁnd such keys, we
computed the GCD of all pairs of distinct RSA moduli by
applying the algorithm described in Section 3.3.