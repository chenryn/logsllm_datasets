title:Extending the Java Virtual Machine to Enforce Fine-Grained Security
Policies in Mobile Devices
author:Iulia Ion and
Boris Dragovic and
Bruno Crispo
Extending the Java Virtual Machine to Enforce Fine-Grained
Security Policies in Mobile Devices
Iulia Ion, Boris Dragovic
Create-Net, Trento, Italy.
Bruno Crispo∗
University of Trento, Italy
ﬁPI:EMAIL
PI:EMAIL
November 14, 2007
Abstract
The growth of the applications and services market for mobile devices is currently slowed down
by the lack of a ﬂexible and reliable security infrastructure. The development and adoption of a
new generation of mobile applications depends on the end user’s ability to ﬁnely manage system
security and control application’s behavior. The virtual execution environment for mobile software
and services should support the security needs of users and applications. This paper proposes an
extension to the security architecture of the Java Virtual Machine for mobile systems, to support
ﬁne-grained policy speciﬁcation and run-time enforcement. Access control decisions are based on
system state, application and system history data, as well as request speciﬁc parameters. The
prototype implementation is running on desktops, as emulator, and on mobile devices, proving
the high level of ﬂexibility and security, with excellent performance provided by the extended
architecture.
1 Introduction
Mobile computing and communications technology has evolved tremendously over the last decade.
New mobile computing devices with better design and increased capabilities are released frequently
on the market. A smart phone has more computing power than a PC of 15 years ago. Consequently,
rich mobile services such as e-mail, scheduler, contact synchronization and even scaled-down versions of
word processors, spreadsheets and presentation software have become more and more common among
mobile users, especially in the business sector. Market analysts are repeatedly re-enforcing the estimate
that the business opportunity for services and application developers is to expand tremendously in
the coming years.
However, the security model prevailing at mobile platforms does not oﬀer the ﬂexibility required
to support the market expansion. The trust model implemented at mobile platforms currently is
binary: trusted applications are given all requested rights while the untrusted ones are locked out
of the platform completely. To be deemed as trusted, an application must carry a valid certiﬁcate,
provided by the platform provider or network operator. This means that application developers must
have direct agreements with the certifying parties. As a consequence, the market for mobile software
development is inherently closed to third-party developers. Furthermore, the current security models
lack the ability for ﬁne-grained, user-deﬁned security policy deﬁnition and enforcement - e.g. to control
the number of SMSs (Short Message Service) sent, limit the bandwidth used by an application, etc.
∗This work has been supported partly by the EU project S3MS IST-STREP-27004 and the EU project Re-Trust
contract N 021186-2
1
The main reason behind the rigidity of the security model is found in stringent resource constraints
of initial mobile computing devices and also in certain market forces.
In this paper, we propose an extended security architecture and policy model to address the lack
of ﬂexibility of the current security model employed at mobile computing platforms. The proposed
model has the potential to open up the mobile device software market to third-party developers and it
also empowers the users to tailor security policies to their requirements in a ﬁne-grained, personalized
manner. Our work focuses on the Java 2 Micro Edition (J2ME) - one of the most widely used virtual
machine execution environments for mobile computing devices today.
Our main contribution is the design and implementation of an extended version of the current
J2ME, which we baptize xJ2ME, from extended J2ME. xJ2ME enables run-time enforcement of a
much more expressive class of security policies compared to the current state-of-the-art, allowing for
a ﬁne-grained behavior control of individual applications. Furthermore, initial evaluations show no
signiﬁcant, even noticeable, performance overheads. Overall, the paper makes the following contribu-
tions:
• Analyzes the limitations of the current J2ME and emphasizes its constrained, inﬂexible security
model,
• Proposes ﬁne-grained security policies for mobile devices and shows how they can be speciﬁed,
• Designs an extended version of the J2ME security architecture to enforce ﬁne-grained policies
at run-time, and
• Demonstrates the ﬂexibility, portability and excellent performance of the solution through a
running prototype.
The rest of the paper is organized as follows. Section 2 motivates this work with an example
scenario, and Section 3 reviews the related work. In Section 4, we give a brief overview of the Java
architecture for mobile devices and its security architecture with the current limitations. In Section 5
we describe our proposed solution, Section 6 introduces the policy language we use, and we present
the implementation in Section 7. Section 8 evaluates the prototype while Section 9 concludes and
outlines future works.
2 Motivation
To better illustrate the limitations of the existing security model for mobile applications and clarify
the motivation for the work presented in this paper, we present the following example.
Alice is traveling with her new car equipped with an infotainment system (GPS 1 navigator,
multimedia services etc.) which is connected to the outside world via a UMTS (Universal Mobile
Telecommunications System) connection. As she enters Florence, her mobile phone detects a turist
guide service provided by the local tourist information oﬃce.
If Alice allows her mobile phone to
connect to the service and download the corresponding applet, the navigation system will be able to
show sites of historical interest, restaurants or wineries in close proximity, and download additional
information.
However, the attestation service of her trusted computing platform does not recognize the signature
of the applet and, therefore, sandboxes it from the navigation system. Annoyed by the fact that the
applet became basically useless, she forces the platform to treat it as a trusted application and enjoys
the tourist sites in the area. Afterwards, Alice regrets her choice when she discovers that the applet did
not only retrieve the information needed, but in addition it downloaded numerous pictures, causing
an undesired, costly amount of network bandwidth consumption. Furthermore, in a few areas without
direct UMTS connectivity, the applet used the costly Multimedia Messaging Service (MMS) service
to transfer information.
1Global Positioning System
2
Although all the technology for supporting advanced use-scenarios is available, the lack of trust and
security for mobile services makes complex applications unusable. The execution environment should
allow users to control the behavior of the applications running on their devices on a much ﬁner grain.
Some concrete examples of such security policies, none of which are currently enforceable are: (1) The
application can only send SMS to speciﬁc phone numbers, and for a value that does not exceed 3 Euro
per day; (2) The application cannot make international calls, nor phone calls on a data connection to
a premium phone number. Normal phone calls are allowed only on weekends and after-work hours; (3)
The application may not generate more than 300Kb of traﬃc per session, over the UMTS connection;
(4) Set up maximum number of MMS to be sent per unit of time (hour/day/month/etc.).
The solution that we propose not only allows users to deﬁne their own policies for each of the
applications to be executed on the platform, but also allows for ﬁne-grained behavior control of those
applications. We accomplish this by deﬁning a suitable policy model and by extending the current
security architecture of J2ME to provide for ﬂexible run-time policy evaluation and enforcement.
3 Related Work
Two most widely deployed mobile execution environments are .NET and Java frameworks. The former
is supported only by Windows-based platforms, which restricts the portability of the applications
written for the .NET framework. This is not the case with the applications developed for the Java
framework.
In the case of .NET framework, application code is translated into Common Language Runtime
(CLR) and executed under the security policies of the underlying operating system. The security
policy on the device is usually set by the service provider (e.g. Cingular, Sprint, T-Mobile). To
provide a diﬀerent device policy, a special agreement with the service provider is necessary. This
eﬀectively locks out small software developers from the market since the process is lengthy and costly.
Windows Mobile Security Model is based on a three permission tier, which are granted per application:
• Privileged: can call any API, have full access to the registry, ﬁle system, and can install certiﬁ-
cates. Very few applications need to run as privileged.
• Normal: cannot access the privileged areas deﬁned in [1]
• Blocked: does not allow application execution.
The Security Policy model of mobile devices running Windows OS oﬀers no mechanisms to set ﬁne-
grained access control for system resources. As far as we know, no work has been done in extending
the .NET Security Policy model for mobile applications.
As with respect to the Java framework, ﬂexible security models have gathered considerable atten-
tion in the past. Few of these eﬀorts, however, have been targeted at mobile computing platforms.
Hashii et al. [2] introduce an infrastructure to dynamically change security policies of mobile programs
and enforce them by instrumenting the bytecode of protected classes. However, the authors do not
address the speciﬁc challenges raised by mobile platforms such as resource constraints. Pandey et
al. [3] also use binary editing to provide ﬁne-grained access control for Java programs. This work tar-
gets mobile programs running on servers and it does not address the challenges raised by restrictive,
compact environments.
Bauer et al. [4] propose the Polymer language and system that supports deﬁnition and composition
of complex run-time security policies for Java applications. The system is very powerful and ﬂexible.
However, Polymer requires bytecode rewriting of the target application prior to its execution in order
to insert calls to the run-time monitor in relevant places. We believe this approach would be too
resource costly for deployment on mobile computing and communications platforms.
In the context of Java framework and security on mobile systems, limited amount of exploratory
eﬀort has been conducted in the past. Paal [5] investigates and gives an overview of the Java 2
Platform Micro Edition and its security capabilities. Ghosh and Swaminatha [6] examine software
security and privacy risks in mobile e-commerce. Although the authors emphasize the need for new
3
and better security mechanisms and argue for building security into the systems, they do not propose
any solutions.
With Java 2 Standard Edition it is possible to use alternative Security Managers - classes imple-
menting security-relevant operations. However, due to the limited capabilities of mobile devices, the
J2ME security architecture is, by design, not extensible, and therefore does not support this func-
tionality. Users cannot specify alternative Security Managers; they cannot extend nor customize the
predeﬁned security policies. No work has been done in the direction of ﬁne-grained security policy
speciﬁcation and monitoring for the Java 2 Micro Edition.
In this paper, we discuss policy enforcement through run-time monitoring [7]. Alternative ap-
proaches such as static code analysis and inline reference monitors [8, 9] also exist. However, while the
former is insuﬃcient to control dynamic, context-dependent application behavior, the latter requires
modiﬁcations to the target application at the mobile platform. The run-time monitoring approach
leaves target application intact and, as shown, poses no signiﬁcant performance overheads.
4 Java Security Architecture
The two most popular platforms for mobile application development today are Java and .NET. The
former, however, still tends to be more widely deployed. In order to set the foundation of our contri-
bution and support the material presented in the following sections, we start by brieﬂy overviewing
the Java architecture with a focus on Java 2 Mobile Edition. Next we present the principles of the
Java Security architecture, with a focus on the mobile edition.
4.1 Java Architecture
Since the version 2, Java technologies are divided into three editions: Enterprise Edition (J2EE),
Standard Edition (J2SE) and Micro Edition (J2ME). Each caters for a diﬀerent deployment platform.
Figure 1(a) contrasts the high level architecture and context of the three editions. J2EE is intended to
support multi-tier enterprise applications, J2SE provides for basic Java applications while the J2ME is
targeted at resource constrained environments such as PDAs (Personal Digital Assistant) and mobile
phones. At the bottom of each of the editions lies a Virtual Machine runtime environment - JVM for
J2EE and J2SE, KVM and Card VM for highly constrained platforms.
To support various target platforms and their capabilities, J2ME deﬁnes the notions of conﬁgura-
tions and proﬁles. A J2ME conﬁguration speciﬁes the features and requirements of the Java runtime
environment and its APIs that correspond to diﬀerent classes of devices. The current J2ME speciﬁ-
cation deﬁnes two main conﬁgurations: Connected Device Conﬁguration (CDC) [10] and Connected
Limited Device Conﬁguration (CLDC) [11]. The former targets high-end mobile devices with richer
features. CLDC, on the other hand, is aimed at highly constrained consumer devices. It supports
only a subset of a JVM (including APIs, libraries etc.), called KVM.
As depicted in Figure 1(a), the layer above CLDC is the Mobile Information Device Proﬁle
(MIDP) [12]. J2ME proﬁles have the role of deﬁning API libraries that enable speciﬁc type of ap-
plications to be developed for the target platform - in accordance with the underlying conﬁguration.
In conjunction, MIDP and CLDC represent application execution environment and provide for the
related functionality. The standardized J2ME environment for highly constrained consumer devices
consists of MIDP, CLDC and supporting libraries.
Applications running on top of MIDP are referred to as MIDlets. The various ﬁles representing
MIDlet code (a JAR ﬁle), application supporting data and other resources are bundled together in
MIDlet suites. Namely, a MIDlet suite is comprised of: (1) a single JAR ﬁle containing the Java
class (MIDlet), the manifest ﬁle, and application resources (images, etc.), and (2) Java Application
Descriptor ﬁle (JAD) which speciﬁes information related to the application.
The contribution of this paper builds on the principles of the Java security architecture [13]. To
outline those principles, we refer to the generalized security setting as provided in J2SE (Java 2
4
(a)
(b)
Figure 1: (a)Java technology overview. (b)Java 2 Platform security architecture.
Standard Edition). This gives us grounds to introduce the constrained model of J2ME (Java 2 Micro
Edition) and clearly position our contribution relative to it.
4.2 J2SE Security Architecture
The fundamental concept in the generalized Java security architecture is the sandbox. Sandbox repre-
sents an execution environment with strict, policy-based resource access control and strong isolation
properties. Code executing within a sandbox (i.e. the sandbox itself) is associated with a protection
domain which, in turn, determines the permission set granted to the application2.
Protection domains and permissions represent the basic elements of the Java 2 security archi-
tecture. Protection domains allow groups of classes and instances to be associated with a set of
permissions to resources on the host platform. Permissions essentially specify whether access to a
resource of the Java Virtual Machine (JVM) is granted or denied. In order for a resource access to be
allowed, the corresponding permission must be explicitly granted to the code requesting the access.
The Java security policy deﬁnes protection domains for a Java run-time environment - i.e. for all
running Java code. The deﬁnition of a protection domain encapsulates the identiﬁers for a target set
of classes and the corresponding granted set of permissions. Generally, JVMs allow the deﬁnition of
protection domains through Java security policy ﬁles. The static sets of permissions thus speciﬁed are
dynamically mapped at run-time by the JVM. The policy ﬁle entries specifying permissions are referred
to as grant entries. A policy ﬁle for a J2SE run-time environment is fully externally conﬁgurable by the
platform users and administrators. This includes the freedom to deﬁne and specify both permissions
and domains in J2SE. Figure 1(b) shows Java 2 security architecture.
The trust model of Java 2 distinguishes between two main classes of applications: trusted and
untrusted. The former represent code stored on the local ﬁle system. Although it is generally allowed
to run unrestricted (an equivalent of “grant-all” protection domain), it may also be associated with a
policy. Untrusted applications (applets and remote code) are always subjected to the security policy.
Since JDK 1.1, remote applications whose signature is veriﬁed are considered trusted.
Architecture-wise, J2SE run-time environment controls and enforces the security policy through
the entity called Security Manager. The security manager can be regarded as a run-time monitor
within a JVM. Java 2 also provides for the ability of speciﬁcation of custom security managers.
2Note that we use the term application in its most general sense.
5
4.3 J2ME Security Architecture
Due to the limited capabilities of the devices running Java 2 Micro Edition (J2ME), the corresponding
security architecture has been considerably simpliﬁed. While solving the resource consumption issue,