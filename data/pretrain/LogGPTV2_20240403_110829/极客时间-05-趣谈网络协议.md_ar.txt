## 小结 {#14.html#-}好了，这一节就到这里了，我们来总结一下：-   你需要记住 TCP 和 UDP 的 Socket    的编程中，客户端和服务端都需要调用哪些函数；-   写一个能够支撑大量连接的高并发的服务端不容易，需要多进程、多线程，而    epoll 机制能解决 C10K 问题。最后，给你留两个思考题：1.  epoll 是 Linux 上的函数，那你知道 Windows    上对应的机制是什么吗？如果想实现一个跨平台的程序，你知道应该怎么办吗？2.  自己写 Socket 还是挺复杂的，写个 HTTP 的应用可能简单一些。那你知道    HTTP 的工作机制吗？欢迎你留言和我讨论。趣谈网络协议，我们下期见！![](Images/55417b60e9c8040807daf07e6bd9cb4b.png){savepage-src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg"}
# 第14讲 \| HTTP协议：看个新闻原来这么麻烦前面讲述完**传输层**，接下来开始讲**应用层**的协议。从哪里开始讲呢，就从咱们最常用的HTTP 协议开始。HTTP协议，几乎是每个人上网用的第一个协议，同时也是很容易被人忽略的协议。既然说看新闻，咱们就先登录  。 是个URL，叫作**统一资源定位符**。之所以叫统一，是因为它是有格式的。HTTP称为协议，www.163.com 是一个域名，表示互联网上的一个位置。有的 URL会有更详细的位置标识，例如 。正是因为这个东西是统一的，所以当你把这样一个字符串输入到浏览器的框里的时候，浏览器才知道如何进行统一处理。
## HTTP 请求的准备 {#15.html#http-}浏览器会将 www.163.com 这个域名发送给 DNS 服务器，让它解析为 IP地址。有关 DNS 的过程，其实非常复杂，这个在后面专门介绍 DNS的时候，我会详细描述，这里我们先不管，反正它会被解析成为 IP地址。那接下来是发送 HTTP 请求吗？不是的，HTTP 是基于 TCP 协议的，当然是要先建立 TCP连接了，怎么建立呢？还记得第 11 节讲过的三次握手吗？目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了Keep-Alive 的，这样建立的 TCP 连接，就可以在多次请求中复用。``{=html}学习了 TCP 之后，你应该知道，TCP的三次握手和四次挥手，还是挺费劲的。如果好不容易建立了连接，然后就做了一点儿事情就结束了，有点儿浪费人力和物力。
## HTTP 请求的构建 {#15.html#http-}建立了连接以后，浏览器就要发送 HTTP 的请求。请求的格式就像这样。![](Images/22c944f84f686c424277aae8b15336cb.png){savepage-src="https://static001.geekbang.org/resource/image/10/74/10ff27d1032bf32393195f23ef2f9874.jpg"}HTTP的报文大概分为三大部分。第一部分是**请求行**，第二部分是请求的**首部**，第三部分才是请求的**正文实体**。
### 第一部分：请求行 {#15.html#-}在请求行中，URL 就是  ，版本为 HTTP1.1。这里要说一下的，就是方法。方法有几种类型。对于访问网页来讲，最常用的类型就是**GET**。顾名思义，GET就是去服务器获取一些资源。对于访问网页来讲，要获取的资源往往是一个页面。其实也有很多其他的格式，比如说返回一个JSON 字符串，到底要返回什么，是由服务器端的实现决定的。例如，在云计算中，如果我们的服务器端要提供一个基于 HTTP 协议的API，获取所有云主机的列表，这就会使用 GET 方法得到，返回的可能是一个JSON 字符串。字符串里面是一个列表，列表里面是一项的云主机的信息。另外一种类型叫做**POST**。它需要主动告诉服务端一些信息，而非获取。要告诉服务端什么呢？一般会放在正文里面。正文可以有各种各样的格式。常见的格式也是JSON。例如，我们下一节要讲的支付场景，客户端就需要把"我是谁？我要支付多少？我要买啥？"告诉服务器，这就需要通过POST 方法。再如，在云计算里，如果我们的服务器端，要提供一个基于 HTTP协议的创建云主机的 API，也会用到 POST方法。这个时候往往需要将"我要创建多大的云主机？多少 CPU多少内存？多大硬盘？"这些信息放在 JSON 字符串里面，通过 POST的方法告诉服务器端。还有一种类型叫**PUT**，就是向指定资源位置上传最新内容。但是，HTTP的服务器往往是不允许上传文件的，所以 PUT 和 POST就都变成了要传给服务器东西的方法。在实际使用过程中，这两者还会有稍许的区别。POST往往是用来创建一个资源的，而 PUT 往往是用来修改一个资源的。例如，云主机已经创建好了，我想对这个云主机打一个标签，说明这个云主机是生产环境的，另外一个云主机是测试环境的。那怎么修改这个标签呢？往往就是用PUT 方法。再有一种常见的就是**DELETE**。这个顾名思义就是用来删除资源的。例如，我们要删除一个云主机，就会调用DELETE 方法。
### 第二部分：首部字段 {#15.html#-}请求行下面就是我们的首部字段。首部是 keyvalue，通过冒号分隔。这里面，往往保存了一些非常重要的字段。例如，**Accept-Charset**，表示**客户端可以接受的字符集**。防止传过来的是另外的字符集，从而导致出现乱码。再如，**Content-Type**是指**正文的格式**。例如，我们进行 POST的请求，如果正文是 JSON，那么我们就应该将这个值设置为 JSON。这里需要重点说一下的就是**缓存**。为啥要使用缓存呢？那是因为一个非常大的页面有很多东西。例如，我浏览一个商品的详情，里面有这个商品的价格、库存、展示图片、使用手册等等。商品的展示图片会保持较长时间不变，而库存会根据用户购买的情况经常改变。如果图片非常大，而库存数非常小，如果我们每次要更新数据的时候都要刷新整个页面，对于服务器的压力就会很大。对于这种高并发场景下的系统，在真正的业务逻辑之前，都需要有个接入层，将这些静态资源的请求拦在最外面。这个架构的图就像这样。![](Images/ea54c678e33b057202af7591b6999a7d.png){savepage-src="https://static001.geekbang.org/resource/image/c8/ac/c81af7a52305f7de27e32e34a02d0eac.jpg"}其中 DNS、CDN 我在后面的章节会讲。和这一节关系比较大的就是 Nginx这一层，它如何处理 HTTP 协议呢？对于静态资源，有 Vanish缓存层。当缓存过期的时候，才会访问真正的 Tomcat 应用集群。在 HTTP头里面，**Cache-control**是用来**控制缓存**的。当客户端发送的请求中包含max-age指令时，如果判定缓存层中，资源的缓存时间数值比指定时间的数值小，那么客户端可以接受缓存的资源；当指定max-age 值为 0，那么缓存层通常需要将请求转发给应用集群。另外，**If-Modified-Since**也是一个关于缓存的。也就是说，如果服务器的资源在某个时间之后更新了，那么客户端就应该下载最新的资源；如果没有更新，服务端会返回"304Not Modified"的响应，那客户端就不用下载了，也会节省带宽。到此为止，我们仅仅是拼凑起了 HTTP请求的报文格式，接下来，浏览器会把它交给下一层传输层。怎么交给传输层呢？其实也无非是用Socket这些东西，只不过用的浏览器里，这些程序不需要你自己写，有人已经帮你写好了。