先简单介绍一下CAF文件格式，我这里画了一幅简化版的CAF文件格式图。CAF文件开头是File
Header，之后是由各种不同类型的Chunk组成，每个Chunk都有一个Chunk Header，记录了该Chunk的大小。
Desc Chunk主要存储了文件的一些元数据，Data Chunk里面存储了所有的Packet，Packet Table
Chunk则记录了每一个Packet的size。在解析的时候会先读取Packet Table Chunk，获取每一个Packet的大小，然后再去Data
Chunk里面读取。
为了分析这个漏洞，我特意编写了一个010 Editor模板来对CAF文件进行解析。
然后我们分析一下造成crash的CAF文件，用010 editor的模板文件跑一下，可以看到如下输出：
第一列是packet的序号，第二列是packet的size。可以看到，第114个packet的size是负数，可以推测程序在处理size为负的packet的时候出了问题。接下来就是如何利用这个漏洞了。
## 将越界写漏洞转化为任意地址写
这里我首先对相关代码做了逆向分析，被越界写的buffer是存在于ACOpusDecoder这个结构体的内部，这个结构体的字段如下所示：
被越界写的是buf字段，共有1500个字节，后面的buf_size，controled_field, log_obj, controled
这几个字段都是我们可以控制的。通过一定的调试加逆向，可以发现log这个对象在后面有用到，而且可以造成任意地址写。
接下来我们的目标有两个，一是走到任意地址写的位置，并且写的值要满足一定的条件；二是在造成任意地址写之后程序不会立马崩溃。第一步的话我们通过控制一些变量的值就可以做到。
第二步发生了点波折。任意地址写之后，会发现程序总会在opus_decode_frame中崩溃，按照常规的思路分析，如果造成了任意地址写就会导致崩溃，如果不崩溃，又没法造成任意地址写。但是我在逆向的过程中发现，opus_packet_parse_impl这个函数在解析packet的时候没有判断packet的长度，会越界解析到packet+4的位置。所以我构造了两个互相重叠的packet。
Packet 1是两个字节， 在解析的时候会越界解析到Packet 2中，把Packet 2中的0xf8当成是Packet
1中的TOC字段，最后绕过opus_decode_frame中会导致崩溃的逻辑，具体细节不表。
## 堆喷，攻破ASLR！
通常即使有了任意地址写的能力，如果程序的ASLR防护做的比较好的话，想要利用该漏洞还得找一个信息泄漏。但是Safari的堆的实现上有些问题，导致我们可以通过堆喷的手段在某个固定的地址喷上我们控制的值。
有了任意地址写，首先想到的就是覆盖JSArray中的length字段，或者是ArrayBuffer中的length字段，ArrayBuffer由于Safari的Gigacage机制，即使覆盖了length字段也无法越界读写到有用的内容，所以我最后选择了JSArray。
Safari中JSArray使用了Butterfly来存储JSArray的长度以及内容，如果覆盖掉其中一个JSArray的长度，那么就可以越界读写到下一个JSArray的内容，就可以构造fakeobj以及addrof两个原语，用于后续的漏洞利用。
我先尝试喷了2个G的内存，发现我的Butterfly有时喷射在 0x800000000 - 0x1000000000 之间，有时喷射在
0x1800000000 - 0x1c00000000
之间。Safari由于堆隔离机制，不同类型的对象在不同的堆，Butterfly是在Safari中一个叫做Gigacage的堆里面的，对Gigacage堆做了一些研究发现，Gigacage的基地址是可以预测的，Gigacage的类型有两种，一种可以存储Bufferfly，一种可以存储ArrayBuffer。
对于这两种类型的堆，Gigacage做了一个小小的随机化，一种情况是Bufferfly在上面，另一种情况是ArrayBuffer在上面。如下图所示。情况一下，从0x800000000开始，会随机生成一块0-4G的未映射的区域，之后就是Bufferfly的堆了。第二种情况是从0x1800000000开始，会随机生成一块0-4G的未映射的区域，之后就是Bufferfly的堆。无论是哪种情况，基地址的随机化程度都很小。
我一开始测试的时候是在16G内存的机器上，为了提高成功率，
喷了4个G，但是后来发现Safari对每个render进程占用的内存有监控，如果内存过大，会把他杀掉。所以最后我选择喷2.5个G，但是这会导致成功率有一定程度的下降。解决方法是多次触发任意地址写来提高成功率。
## 感谢多线程！在程序崩溃前让利用代码有足够的时间执行
下面这张时序图解释了整个漏洞利用过程，刚开始只有一个JS线程，我们先堆喷，并且在内存中构造音频文件，随后调用decodeAudioData函数，由于Safari是在单独的线程里解码音频的，所以这里会启动Audio
A线程，我们先假设堆喷后的内存布局是上面的情况1，那么Audio
A线程在解码音频文件的时候就会往0x80开头的地方写数据，JS线程在2s之后检测JSArray的length是否被改掉，如果被改掉，说明堆布局确实是情况1，接着就可以执行后续的exploit代码了，如果没有被改掉，说明堆布局是情况2，那么第二次调用decodeAudioData()函数，启动Audio
B线程解码音频，这次是往0x180开头的地址写数据。JS线程循环检查JSArray的length是否被改掉，如果成功，则调用执行后续的exploit，如果失败，说明整个利用失败。
此外还有一个问题需要解决，就是音频文件解码完之后，调用free函数对资源进行清理的时候，会触发崩溃。有几种方式可以解决这一问题，一种就是对损坏的堆进行修复，第二种就是让音频解码的时间非常非常的长，在解码结束之前我们的利用过程就结束了。
第一种由于需要对堆进行搜索，过于复杂，而且其实你要修复堆，其实也是需要一定的时间的，那其实还是要和第二种手段结合起来，那还不如直接粗暴一点，就选取第二种方法。我构造了一个600M的CAF文件，里面有七千多万个packet，要全部把这些packet解码完大概要花费50s左右的时间，完全足够我的漏洞利用了。
## Old school，任意地址读写原语到任意代码执行
当覆盖了JSArray的长度字段后，我们就可以构造fakeobj和addrof原语，然后就可以用这两个原语构造任意地址读写原语，再将shellcode写入JIT区域就可以任意代码执行了。这些都是属于浏览器利用的常规套路，对此感兴趣的读者可以阅读google的saelo写的文章《Attacking
JavaScript Engines》，在这里我们就不细细展开了。
## 尾声
光年实验室的 100 余处 Apple
漏洞（含47项致谢及50+项在途）的背后仅仅是两名安全研究员以及一台服务器。其中，高效高产的自动化漏洞挖掘平台AntFuzz居功至伟。
**蚂蚁安全光年实验室负责人曲和认为：自动化漏洞挖掘能力的建设与安全研究同学的培养同等重要。自动化能力通过实战不断加以演进，与安全研究同学两者相辅相成，实现漏洞挖掘的成果最大化，并在实战中加以证明。我们也将持续推进安全研究能力赋能变革，加速研究能力更好的连接基础业务。同时期待更多有志于从事漏洞研究、
Fuzzing 研究、程序分析方向的同学加入光年实验室，一起为基础设施提供更多安全保障。**
**蚂蚁安全光年实验室：**
隶属于蚂蚁安全实验室。通过对基础软件及设备的安全研究，达到全球顶尖破解能力，致力于保障蚂蚁集团及行业金融级基础设施安全。因发现并报告行业系统漏洞，上百次获得Google、Apple等国际厂商致谢。
扫码关注蚂蚁安全实验室微信公众号，干货不断！
* * *