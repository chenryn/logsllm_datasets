People have proposed to use PDAs as touchpads before
(e.g., [17]), but mostly for reasons of convenience. In our
case, we use the PDA as a touchpad to create a trusted input
path. Furthermore, we have augmented a PDA with (parts
of) an optical mouse (see Figure 1). This allows the PDA to
be used as a mouse, not just as a touchpad.
Balfanz and Felten [3] point out that PDAs can provide
a trusted input and output path when used with an untrusted
host. We also use a PDA as a trusted input device, and ﬁnd
it more trustworthy than a public terminal for the same rea-
sons given in [3]. They, however, use the PDA to provide
cryptographic functions that the host cannot be trusted with.
This method would completely fail in our case – the amount
of framebuffer data that needs to be decrypted by the un-
trusted host is much too large to be handled by the PDA.
Consequently, we do let the untrusted host handle its own
decryption, albeit with rapidly expiring keys.
Finally, our work has some similarity to SSL-Splitting
[16]. There, untrusted proxy servers are given only encryp-
tion, but not MAC keys to serve out Web content over an
SSL connection. Here, we give the untrusted terminal de-
cryption and MAC keys to receive data over an SSL con-
nection. There, clients connect to untrusted proxy servers
while requiring assurance from the server that the content
served out is authentic. Here, the clients are the untrusted
entities, and it is the server that requires assurance that the
input events are authentic.
3. Preliminaries and Goals
The goal of our system is to allow a user in the posses-
sion of a small, trusted device to access sensitive informa-
tion stored on his home computer in a secure manner. We
provide that access in the form of a “remote desktop” ap-
plication, giving the user any access he desires to his home
computing environment. The user holds certain capabili-
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:36:42 UTC from IEEE Xplore.  Restrictions apply. 
ties on the trusted device and delegates some of them, tem-
porarily, to an untrusted host that displays the sensitive in-
formation from the home environment. We emphasize that
in our system, the input and output paths are clearly sepa-
rated: all the input comes from the trusted device, whereas
the output goes to the untrusted host. In other words, the un-
trusted host has “read-only” access to just that part of the
home computing environment that the user chooses to dis-
play. The untrusted host is trusted to some extent to display
correctly the information it receives.
3.1. Model
The players in the secure remote terminal application
are: the home computer (HC) holding sensitive information,
that acts as the remote terminal server; the untrusted termi-
nal (UT) to which the user delegates the capability of act-
ing as the remote terminal output; the user with its trusted
PDA from which the input to the remote terminal server is
sent.
We are assuming that all the devices from the user home
network (all the devices that are trusted to the user and form
the trusted computing base) are given certain credentials. In
our particular implementation, the credentials take the form
of certiﬁcates signed by a root home certiﬁcation authority.
The root home certiﬁcation authority might be the PDA it-
self or any other trusted device. Any two devices from the
home network use these certiﬁcates to mutually authenti-
cate. The communication between devices from the home
network (in particular, between the PDA and the home com-
puter) is always done over SSL with client authentication
enabled.
The PDA and the untrusted terminal communicate
through a secure channel. In our prototype, we phys-
ically plug the PDA into the untrusted terminal, but
we could also imagine a wireless connection authenti-
cated through a location-limited channel [4] such as in-
frared.
Our security goals are the following:
1. All the input events (mouse and keyboard) to the re-
mote terminal server come from the trusted device on
a secure communication channel.
2. All the output goes to the untrusted host on a secure
communication channel.
3. The untrusted host can access sensitive information
only when the trusted device is in its proximity.
We need to clarify an aspect related to our third secu-
rity goal: there is a timeout between the moment in which
the PDA stops delegating the credentials and the time the
host computer is actually denied access to the sensitive in-
formation. We think that values on the order of seconds, and
even minutes, are reasonable for the timeout. Such a time-
out is important, as the user may choose to display on the
host computer time-varying information whose future con-
tents may be sensitive. For instance, the user may open a
window showing the contents of his most recent e-mail, that
automatically updates as new messages arrive. Or, the user
may display the current output of his home video surveil-
lance system. It is important, therefore, that the untrusted
host’s access to the home environment is time-limited and
tied to the presence of the user, as evidenced by the pres-
ence of his trusted device.
A straightforward solution that one might think of de-
ploying for the delegation of capabilities is the following:
the trusted device hands its certiﬁcate (and private key) to
the untrusted host. There are two problems with this ap-
proach: (1) The certiﬁcate is likely a coarse-grained capa-
bility, i.e., it authorizes its bearer for all kinds of access
to the home network and (2) the certiﬁcate may not ex-
pire soon enough, and leave the untrusted computer with the
ability to access the user’s home network long after the user
has walked away. Therefore, we need to ﬁnd lower-privilege
credentials to delegate (i.e., credentials that do not give full
access to the user’s home network), and we need a mech-
anism to ensure that the delegation is temporary, i.e., just
for the period when the user is in the proximity of the un-
trusted device.
Another, perhaps even simpler solution to this problem
would be to avoid the delegation of capabilities at all: sim-
ply provide secure remote access to the home environment
to just the trusted device, which can then forward any subset
of the information it receives to the untrusted terminal. Un-
fortunately, this places unreasonable bandwidth and compu-
tation demands on the trusted device, which we would like
to allow to be as small and inexpensive as possible.
3.2. Overview of SSL
SSL (Secure Socket Layer) [14] is a transport level se-
curity protocol that creates a secure transparent tunnel be-
tween a client and a server. The protocol consists of two
phases: an initial handshake initiated by the client and a data
transfer phase. In the handshake phase, the server authenti-
cates to the client (client authentication is optional); then the
parties establish the cryptographic algorithms used for con-
ﬁdentiality and data integrity(ciphers, MAC algorithms); ﬁ-
nally, the client and server derive the cryptographic keys.
After verifying the server’s certiﬁcate, the client and
server agree on a shared secret – the “pre-master secret”. If
the server authenticates with an RSA public key, the client
simply generates a random value to be the pre-master se-
cret, and encrypts it with the public key of the server. From
this pre-master secret, both the client and server can derive a
master secret. All the cryptographic keys are generated from
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:36:42 UTC from IEEE Xplore.  Restrictions apply. 
the master secret using cryptographically secure hash func-
tions MD5 and SHA-1. The keys generated by the client
and server are: (1) the client write MAC key (the key used
by the client to compute MACs), (2) the server write MAC
key (the key used by the server to compute MACs), (3) the
client write key (the key used by the client to encrypt) and
(4) the server write key (the key used by the server to en-
crypt). After the key computation, both the client and server
compute a MAC of all the handshake messages and verify
that the corresponding MAC computed by the other party is
correct.
In the data transfer phase, SSL breaks the data sent
in both directions into SSL records of variable size. The
records are encrypted with the write key of the party that
sends the message. The sender of the message computes a
MAC for each record, using its secret MAC key and adds a
header specifying the length of the packets and the SSL ver-
sion used. The use of SSL is transparent to the application
level, so any application running over TCP can be modi-
ﬁed to run over SSL.
3.3. Virtual Network Computing (VNC)
Virtual Network Computing [18] is an open-source re-
mote display system developed by AT&T that allows a re-
mote terminal (VNC viewer) to access the graphical inter-
face of a VNC server. The protocol is platform-independent
and is designed such that the viewer is a lightweight appli-
cation that can run on various hardware conﬁgurations.
VNC is based on the Remote FrameBuffer (RFB) proto-
col [19], a protocol for encoding screen images as rectan-
gles. It supports several encodings of these images, and ne-
gotiates the one to be used in a particular connection in the
initial phase of the protocol. The input to the VNC server
comes from the client, which encodes keyboard and mouse
events and transmits them to the server. The protocol is
adaptive in that an update is sent by the server only when
explicitly requested by the client . Thus, the update rate can
be adjusted dynamically by the client according to its capa-
bilities and network characteristics. This means that a VNC
client sends two kinds of messages to the server – one con-
taining traditional input (keyboard and mouse) events, the
other containing simple requests for display update. An ap-
plication such as ours which wishes to separate the dis-
play and input components of the VNC client must there-
fore provide the display component a channel back to the
VNC server, over which it can only request display updates.
VNC authentication is password-based. The VNC server
is conﬁgured by the administrator with a password and the
VNC viewer has to prove knowledge of that password when
it initiates a connection. The proof is done via a challenge-
response protocol: the server sends a challenge, and the
viewer replies with a DES encryption of the challenge with
a key derived from the password supplied by the user.
4. A Secure Remote Terminal Application
We present an overview of our system and then explain
the roles of the three parties (untrusted terminal, PDA, and
home computer) in the remote terminal application. We then
report on some issues that we encountered when designing
our system, and describe a speciﬁc implementation before
evaluating its performance.
For our prototype, we chose to modify an existing open-
source remote desktop application, VNC [18] (see Sec-
tion 3.3 for details of the VNC protocol). We secure all com-
munication between trusted device, home computer, and un-
trusted terminal using SSL/TLS.
4.1. The Three-Party Secure Remote Termi-
nal Protocol
Below we describe the secure remote terminal protocol.
• I: The PDA contacts the home computer (PDA ↔ HC)
The PDA initiates an SSL session with the home
computer in which they both authenticate using the
certiﬁcates signed by the home root certiﬁcation au-
thority. They also compute the master secret ms of the
SSL session and negotiate the length of the time inter-
val t.
In our implementation, the PDA needs to be con-
nected to the untrusted terminal to perform this step
(the untrusted terminal provides network connectiv-
ity). If the PDA has its own network connection, then
this step can be performed before coming in contact
with the untrusted terminal.
• II: The PDA contacts the untrusted terminal (PDA ↔
UT)
The PDA sends to the untrusted terminal the name
of the home computer, the home certiﬁcation author-
ity’s root certiﬁcate, and the VNC password derived
from ms.
Again, in our implementation, the destination of
this information is implicitly given by the fact that the
untrusted terminal and PDA are connected by a wire.
In general, a PDA that has its own network connec-
tion could learn the identity of the untrusted terminal
through a location-limited handshake as in [4].
• III: VNC connection initiation (UT ↔ HC)
The untrusted terminal starts an SSL session with
the home computer in which client authentication is
disabled . Over this session, it starts a VNC connec-
tion to the home computer with the password provided
by the PDA. The input of this VNC client (i.e., mouse
Proceedings of the 20th Annual Computer Security Applications Conference (ACSAC’04) 
1063-9527/04 $ 20.00 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 11:36:42 UTC from IEEE Xplore.  Restrictions apply. 
Untrusted Terminal 
(UT)
Home Computer 
(HC)
Eki
(m1)
Eki
(m2)