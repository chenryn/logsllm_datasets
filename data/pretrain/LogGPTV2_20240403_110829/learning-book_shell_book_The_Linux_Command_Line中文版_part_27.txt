:pronssed s,s.s-opouoxgou
sftp> 1s
ubumtu=8.04deslctop-i386.iso
sftp> 1cd Desktop
sftp> get ubuntu-8.04-desktop-i386.iso
Fetching /hone/ne/ubuntu-8.04-desktop-i386.iso to ubuntu-8.04-
desktop-i386.iso
/home/me/ubuntu-8.04-desktop1386.iso 100%, 699MB 7.4MB/s 01:35
sftp> bye
小贴示：SFTP协议被许多Linux发行版中的图形化文件管理器支持。使用Nautilus
（GNOME），或者是Konqueror（KDE），我们都能在位置栏中输入以sftp://开头的URI，来操
作存储在运行着SSH服务端的远端系统中的文件。
Windous 中的 SSH客户端
比方说你正坐在一台Windows机器前面，但是你需要登录到你的Linux服务器
中，去完成一些实际的工作。那该怎么办呢？当然是找一个Windows平台下的SSH
客户端！有很多这样的工具。最流行的可能就是由SimonTatham和他的团队开发
的PuTTY了。PuTTY程序能够显示一个终端窗口，而且允许Windows用户在远
端主机中打开一个SSH（或者telnet）会话。这个程序也提供了scp和sftp程序的
类似物。
PuTTY可在链接http://www.chiark.greenend.org.uk/~sgtatham/putty/处得
到。
17.4拓展阅读
·Linux文档项目提供了Linux网络管理指南，可以广泛地（虽然过时了）了解网络管理方
面的知识。
213
---
## Page 215
http:/ /tldp.org/LDP/nag2/index.html
·Wikipedia上包含了许多网络方面的优秀文章。这里有一些基础的：
http://en.wikipedia.org/wiki/Intermet_protocol_address
http://en.wikipedia.org/wiki/Host_name
http://en.wikipedia.org/wiki/Uniform_Resource_Identifier
214
---
## Page 216
18
查找文件
随着我们在Linux系统中的不断探索，一件事已经变得非常清楚：一个典型的Linux系统包含
很多文件！这就引发了一个问题，“我们怎样查找东西？”。虽然我们已经知道Linux文件系统
已经根据类Unix系统的代代相传的惯例而被良好地组织起来了。但是海量的文件会引起一个
可怕的问题。在这一章中，我们将察看两个用来在系统中查找文件的工具。这些工具是：
·locate一通过名字来查找文件
·find一在一个目录层次结构中搜索文件
我们也将看一个经常与文件搜索命令一起使用的命令，它用来处理搜索到的文件列表：
·xargs一从标准输入生成和执行命令行
另外，我们将介绍两个命令以便在我们探索的过程中协助我们：
·touch一更改文件时间
·stat一显示文件或文件系统状态
18.1locate－查找文件的简单方法
这个locate程序会执行一次快速的路径名数据库搜索，并且输出每个与给定子字符申相匹配的
路径名。比如说，例如，我们想要找到所有名字以“zip”开头的程序。因为我们正在查找程序
可以假定包含程序的目录以“bin/”结尾。因此，我们试着以这种方式使用locate命令，来找
到我们的文件：
[neglinuxbox -]$ locate bin/zip
locate命令将会搜索它的路径名数据库，输出任一个包含字符申“bin/zip”的路径名：
215
---
## Page 217
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipeplit
如果搜索要求没有这么简单，locate可以结合其它工具，比如说grep命令，来设计更加有
趣的搜索：
[nellinuxbox -]$ locate zip1grep bin
/bin/bunzip2
/bin/bzip2
/bin/bzip2recover
/bin/gunzip
/bin/gzip
/usr/bin/funzip
/usr/bin/gpg=zip
/usr/bin/preunzip
/usr/bin/prezip
/usr/bin/prezip-bin
/usr/bin/unzip
/usr/bin/unzipsfx
/usr/bin/zip
/usr/bin/zipcloak
/usr/bin/zipgrep
/usr/bin/zipinfo
/usr/bin/zipnote
/usr/bin/zipeplit
这个locate程序已经存在了很多年了，它有几个不同的变体被普遍使用着。在现在Linux
发行版中两个最常见的变体是slocate和mlocate，尽管它们通常被名为locate的符号链接访
一章中讨论）和通配符支持。可以查看locate命令的手册来确定安装了哪个版本的locate程
序。
216
---
## Page 218
locate数据库来自何方？
你可能注意到了，在一些发行版中，仅仅在系统安装之后，locate不能工作，但
是如果你第二天再试一下，它就正常工作了。怎么回事呢？locate数据库由另一个
叫做updatedb的程序创建。通常，这个程序作为一个定时任务（jobs）周期性运转；
也就是说，一个任务在特定的时间间隔内被cron守护进程执行。大多数装有locate
的系统会每隔一天运行一回updatedb程序。因为数据库不能被持续地更新，所以
当使用locate时，你会发现目前最新的文件不会出现。为了克服这个问题，通过更
改为超级用户身份，在提示符下运行updatedb命令，可以手动运行updatedb程
序。
18.2find-查找文件的复杂方式
locate程序只能依据文件名来查找文件，而find程序能基于各种各样的属性搜索一个给定目录
（以及它的子目录），来查找文件。我们将要花费大量的时间学习find命令，因为它有许多有趣
的特性，当我们开始在随后的章节里面讨论编程概念的时候，我们将会重复看到这些特性。
在它的最简单的使用方式中，find命令接收一个或多个目录名来执行搜索。例如，输出我们
的家目录的路径名列表（包括文件及目录，译者注）。
[ne@linuxbox -]$ find
在最活跃的用户帐号中，这将产生一张很大的列表。因为这张列表被发送到标准输出，我们
可以把这个列表管道到其它的程序中。让我们使用wc程序来计算出文件的数量：
[- oa | - putg s[- xoqxnuteou]
47068
哇，我们一直很忙（在home路径下执行了很多操作，译者注）！find命令的魅力所在就是
它能够被用来找到符合特定标准的文件。它通过（有点奇怪）应用选项，测试条件，和操作来
做到这一点。我们先看一下测试条件：
217
---
## Page 219
18.2.1 Tests
比如说我们想在我们的搜索中得到目录列表。我们可以添加以下测试条件：
[- on 1p odfq-- putg $[-xoqxnutoou]
1695
添加测试条件-typed限制了只搜索目录。相反地，我们可以使用这个测试条件来限定搜索
普通文件：
[nellinuxbox -]$ find - =type f 1 vc -1
38737
这里是find命令支持的常见文件类型测试条件：
文件类型
描迹
b
块特殊设备文件
C
字符特殊设备文件
d
目录
f
普通文件
1
符号链接
表18-1:find文件类型
我们也可以通过加入一些额外的测试条件，根据文件大小和文件名来搜索：让我们查找所有
文件名匹配通配符模式“*JPG”和文件大小大于1M的普通文件
[ne@linuxbox -]$ find - -type f -nane "*,JPC" -size +1X I vc -1
840
在这个例子里面，我们加入了-name测试条件，后面跟通配符模式。注意，我们把它用
双引号引起来，从而阻止shell展开路径名。紧接着，我们加入-size测试条件，后跟字符串
“+1M”。开头的加号表明我们正在寻找文件大小大于指定数的文件。若字符串以减号开头，则
218
---
## Page 220
意味着查找小于指定数的文件。若没有符号意味着“精确匹配这个数”。结尾字母“M”表明测
量单位是兆字节。下面的字符可以被用来指定测量单位：
字符
单位
b
512个字节块。如果没有指定单位，则这是默认值。
C
W
两个字节的字
k
千字节（1024个字节单位）
M
兆字节（1048576个字节单位）
G
千兆字节（1073741824个字节单位）
表18-2:find大小单位
find命令支持大量不同的测试条件。下表是列出了一些常见的测试条件。请注意，在需要
数值参数的情况下，可以应用以上讨论的“+”和“”符号表示法：
测试条件
描远
-cmin n
匹配内容或属性最后修改时间正好在n分钟之前的文件或
目录。指定少于n分钟之前，使用-n，指定多于n分钟之
前，使用+n°
-cnewer file
匹配内容或属性最后修改时间晚于file的文件或目录。
-ctime n
匹配内容和属性最后修改时间在n*24小时之前的文件和目
录。
-empty
匹配空文件和目录。
-group name
匹配属于一个组的文件或目录。组可以用组名或组ID来表
示。
-iname pattern
就像-name测试条件。但是不区分大小写。
-inum n
匹配inode号是n的文件。这对于找到某个特殊inode的
所有硬链接很有帮助。
-mmin n
匹配内容被修改于n分钟之前的文件或目录。
-mtime n
匹配的文件或目录的内容被修改于n*24小时之前。
-name pattern
用指定的通配符模式匹配的文件和目录。
219
---
## Page 221
-newer file
匹配内容晚于指定的文件的文件和目录。这在编写执行备
份的shell脚本的时候很有帮。每次你制作一个备份，更新
文件（比如说日志），然后使用find命令来判断哪些文件自
从上一次更新之后被更改了。
-nouser
匹配不属于一个有效用户的文件和目录。这可以用来查找
属于被删除的账户的文件或监测攻击行为。
-nogroup
匹配不属于一个有效的组的文件和目录。
apou tuad-
匹配权限已经设置为指定的mode的文件或目录。mode可
以用八进制或符号表示法。
-samefile name
类似于-inum测试条件。匹配和文件name享有同样inode
号的文件。
-size n
匹配大小为n的文件
> ad&q-
匹配文件类型是c的文件。
-user name
匹配属于某个用户的文件或目录。这个用户可以通过用户
名或用户ID来表示。
表18-3:find 测试条件
这不是一个完整的列表。find命令手册有更详细的说明。
18.2.2操作符
即使拥有了find命令提供的所有测试条件，我们还需要一个更好的方式来描述测试条件之间的
逻辑关系。例如，如果我们需要确定是否一个目录中的所有的文件和子目录拥有安全权限，怎
么办呢？我们可以查找权限不是0600的文件和权限不是0700的目录。幸运地是，find命令提
供了一种方法来结合测试条件，通过使用逻辑操作符来创建更复杂的逻辑关系。为了表达上迹
的测试条件，我们可以这样做：
(\ 00z0 mrod- ou-p od≤q-)\ xo- (\ o09o uxod- qou- odf-)\- putz s[- xoqxnutgou]
呀！这的确看起来很奇怪。这些是什么东西？实际上，这些操作符没有那么复杂，一旦你知
道了它们的原理。这里是操作符列表：
操作符
描远
220
---
## Page 222
and
如果操作符两边的测试条件都是真，则匹配。可以简写为
a。注意若没有使用操作符，则默认使用-and。
-or
若操作符两边的任一个测试条件为真，则匹配。可以简写为
-O °
-not
若操作符后面的测试条件是假，则匹配。可以简写为一个感
叹号（！）。
()
把测试条件和操作符组合起来形成更大的表达式。这用来
控制逻辑计算的优先级。默认情况下，find命令按照从左到
右的顺序计算。经常有必要重写默认的求值顺序，以得到期
望的结果。即使没有必要，有时候包括组合起来的字符，对
提高命令的可读性是很有帮助的。注意因为圆括号字符对
于shell来说有特殊含义，所以在命令行中使用它们的时候，
它们必须用引号引起来，才能作为实参传递给find命令。
通常反斜杠字符被用来转文圆括号字符。
表18-4:find命令的逻辑操作符
通过这张操作符列表，我们重建find命令。从最外层看，我们看到测试条件被分为两组
由一个-or操作符分开：
(expression 1 )-or ( expression 2 )
这看起来合理，因为我们正在搜索具有不同权限集合的文件和目录。如果我们文件和目录
两者都查找，那为什么要用-or来代替-and呢？因为find命令扫描文件和目录时，会计算每
一个对象，看看它是否匹配指定的测试条件。我们想要知道它是具有错误权限的文件还是有错
误权限的目录。它不可能同时符合这两个条件。所以如果展开组合起来的表达式，我们能这样
解释它：
( file vith bad perns ) -or ( directory with bad perns )
下一个挑战是怎样来检查“错误权限”，这个怎样做呢？事实上我们不从这个角度入手。我
们将测试“不是正确权限”，因为我们知道什么是“正确权限”。对于文件，我们定义正确权限