funcmain(){
varpasswordstring
iflen(os.Args)!=2{
log.Fatalln("Usage:bcryptpassword")
}
password=os.Args[1]
❸hash,err:=bcrypt.GenerateFromPassword(
[]byte(password),
bcrypt.DefaultCost,
)
iferr!=nil{
log.Fatalln(err)
}
log.Printf("hash=%s\n",hash)
❹err=bcrypt.CompareHashAndPassword([]byte(storedHash),
[]byte(password))
iferr!=nil{
log.Println("[!]Authenticationfailed")
return
}
log.Println("[+]Authenticationsuccessful")
}
Listing11-2:Comparingbcrypthashes(/ch-11/bcrypt/main.go)
Formostofthecodesamplesinthisbook,we’veomitted
thepackageimports.We’veincludedtheminthisexampleto
explicitlyshowthatyou’reusingthesupplementalGo
package,golang.org/x/crypto/bcrypt❶,becauseGo’sbuilt-incrypto
packagedoesn’tcontainthebcryptfunctionality.Youthen
initializeavariable,storedHash❷,thatholdsaprecomputed,
encodedbcrypthash.Thisisacontrivedexample;ratherthan
wiringoursamplecodeuptoadatabasetogetavalue,we’ve
optedtohardcodeavaluefordemonstrativepurposes.The
variablecouldrepresentavaluethatyou’vefoundina
databaserowthatstoresuserauthenticationinformationfora
frontendwebapplication,forinstance.
Next,you’llproduceabcrypt-encodedhashfroma
cleartextpasswordvalue.Themainfunctionreadsapassword
valueasacommandlineargumentandproceedstocalltwo
separatebcryptfunctions.Thefirstfunction,
bcrypt.GenerateFromPassword()❸,acceptstwoparameters:abyte
slicerepresentingthecleartextpasswordandacostvalue.In
thisexample,you’llpasstheconstantvariablebcrypt.DefaultCost
tousethepackage’sdefaultcost,whichis10atthetimeof
thiswriting.Thefunctionreturnstheencodedhashvalueand
anyerrorsproduced.
Thesecondbcryptfunctionyoucallis
bcrypt.CompareHashAndPassword()❹,whichdoesthehash
comparisonforyoubehindthescenes.Itacceptsabcrypt-
encodedhashandacleartextpasswordasbyteslices.The
functionparsestheencodedhashtodeterminethecostand
salt.Itthenusesthesevalueswiththecleartextpasswordvalue
togenerateabcrypthash.Ifthisresultinghashmatchesthe
hashextractedfromtheencodedstoredHashvalue,youknowthe
providedpasswordmatcheswhatwasusedtocreatethe
storedHash.
Thisisthesamemethodyouusedtoperformyour
passwordcrackingagainstSHAandMD5—runagiven
passwordthroughthehashingfunctionandcomparetheresult
withthestoredhash.Here,ratherthanexplicitlycomparing
theresultinghashesasyoudidforSHAandMD5,youcheck
whetherbcrypt.CompareHashAndPassword()returnsanerror.Ifyou
seeanerror,youknowthecomputedhashes,andthereforethe
passwordsusedtocomputethem,donotmatch.
Thefollowingaretwosampleprogramruns.Thefirst
showstheoutputforanincorrectpassword:
$gorunmain.gosomeWrongPassword
2020/08/2508:44:01hash=
$2a$10$YSSanGl8ye/NC7GDyLBLUO5gE/ng51l9TnaB1zTChWq5g9i09v0AC
2020/08/2508:44:01[!]Authenticationfailed
Thesecondshowstheoutputforthecorrectpassword:
$gorunmain.gosomeC0mpl3xP@ssw0rd
2020/08/2508:39:29hash=
$2a$10$XfeUk.wKeEePNAfjQ1juXe8RaM/9EC1XZmqaJ8MoJB29hZRyuNxz.
2020/08/2508:39:29[+]Authenticationsuccessful
Thoseofyouwithakeeneyefordetailmaynoticethatthe
hashvaluedisplayedforyoursuccessfulauthenticationdoes
notmatchthevalueyouhardcodedforyourstoredHashvariable.
Recall,ifyouwill,thatyourcodeiscallingtwoseparate
functions.TheGenerateFromPassword()functionproducesthe
encodedhashbyusingarandomsaltvalue.Givendifferent
salts,thesamepasswordwillproducedifferentresulting
hashes.Hencethedifference.TheCompareHashAndPassword()
functionperformsthehashingalgorithmbyusingthesamesalt
andcostasthestoredhash,sotheresultinghashisidenticalto
theoneinthestoredHashvariable.
AUTHENTICATINGMESSAGES
Let’snowturnourfocustomessageauthentication.When
exchangingmessages,youneedtovalidateboththeintegrity
ofdataandtheauthenticityoftheremoteservicetomakesure
thatthedataisauthenticandhasn’tbeentamperedwith.Was
themessagealteredduringtransmissionbyanunauthorized
source?Wasthemessagesentbyanauthorizedsenderorwas
itforgedbyanotherentity?
YoucanaddressthesequestionsbyusingGo’scrypto/hmac
package,whichimplementstheKeyed-HashMessage
AuthenticationCode(HMAC)standard.HMACisa
cryptographicalgorithmthatallowsustocheckformessage
tamperingandverifytheidentityofthesource.Itusesa
hashingfunctionandconsumesasharedsecretkey,which
onlythepartiesauthorizedtoproducevalidmessagesordata
shouldpossess.Anattackerwhodoesnotpossessthisshared
secretcannotreasonablyforgeavalidHMACvalue.
ImplementingHMACinsomeprogramminglanguagescan
bealittletricky.Forexample,somelanguagesforceyouto
manuallycomparethereceivedandcalculatedhashvalues
bytebybyte.Developersmayinadvertentlyintroducetiming
discrepanciesinthisprocessiftheirbyte-by-bytecomparison
isabortedprematurely;anattackercandeducetheexpected
HMACbymeasuringmessage-processingtimes.Additionally,
developerswilloccasionallythinkHMACs(whichconsumea
messageandkey)arethesameasahashofasecretkey
prependedtoamessage.However,theinternalfunctionalityof
HMACsdiffersfromthatofapurehashingfunction.Bynot
explicitlyusinganHMAC,thedeveloperisexposingthe
applicationtolength-extensionattacks,inwhichanattacker
forgesamessageandvalidMAC.
LuckilyforusGophers,thecrypto/hmacpackagemakesit
fairlyeasytoimplementHMACfunctionalityinasecure
fashion.Let’slookatanimplementation.Notethatthe
followingprogramismuchsimplerthanatypicalusecase,
whichwouldlikelyinvolvesometypeofnetwork
communicationsandmessaging.Inmostcases,you’d
calculatetheHMAConHTTPrequestparametersorsome
othermessagetransmittedoveranetwork.Intheexample
showninListing11-3,we’reomittingtheclient-server
communicationsandfocusingsolelyontheHMAC
functionality.
varkey=[]byte("somerandomkey")❶
funccheckMAC(message,recvMAC[]byte)bool{❷
mac:=hmac.New(sha256.New,key)❸
mac.Write(message)
calcMAC:=mac.Sum(nil)
returnhmac.Equal(calcMAC,recvMAC)❹
}
funcmain(){
//Inrealimplementations,we'dreadthemessageandHMACvaluefrom
networksource
message:=[]byte("Theredeaglefliesat10:00")❺
mac,_:=
hex.DecodeString("69d2c7b6fbbfcaeb72a3172f4662601d1f16acfb46339639ac8c10c8da64631d")
❻
ifcheckMAC(message,mac){❼
fmt.Println("EQUAL")
}else{
fmt.Println("NOTEQUAL")
}
}
Listing11-3:UsingHMACformessageauthentication(/ch-11/hmac/main.go)
Theprogrambeginsbydefiningthekeyyou’lluseforyour
HMACcryptographicfunction❶.You’rehardcodingthe
valuehere,butinarealimplementation,thiskeywouldbe
adequatelyprotectedandrandom.Itwouldalsobeshared
betweentheendpoints,meaningboththemessagesenderand
receiverareusingthissamekeyvalue.Sinceyouaren’t
implementingfullclient-serverfunctionalityhere,you’lluse
thisvariableasifitwereadequatelyshared.
Next,youdefineafunction,checkMAC()❷,thatacceptsa
messageandthereceivedHMACasparameters.Themessage
receiverwouldcallthisfunctiontocheckwhethertheMAC
valuetheyreceivedmatchesthevaluetheycalculatedlocally.
First,youcallhmac.New()❸,passingtoitsha256.New,whichisa
functionthatreturnsahash.Hashinstance,andthesharedsecret
key.Inthiscase,thehmac.New()functioninitializesyourHMAC
byusingtheSHA-256algorithmandyoursecretkey,and
assignstheresulttoavariablenamedmac.Youthenusethis
variabletocalculatetheHMAChashvalue,asyoudidinthe
earlierhashingexamples.Here,youcallmac.Write(message)and
mac.Sum(nil),respectively.Theresultisyourlocallycalculated
HMAC,storedinavariablenamedcalcMAC.
Thenextstepistoevaluatewhetheryourlocallycalculated
HMACvalueisequaltotheHMACvalueyoureceived.Todo
thisinasecuremanner,youcallhmac.Equal(calcMAC,recvMAC)❹.
Alotofdeveloperswouldbeinclinedtocomparethebyte
slicesbycallingbytes.Compare(calcMAC,recvMAC).Theproblemis,
bytes.Compare()performsalexicographicalcomparison,walking
andcomparingeachelementofthegivenslicesuntilitfindsa
differenceorreachestheendofaslice.Thetimeittakesto
completethiscomparisonwillvarybasedonwhether
bytes.Compare()encountersadifferenceonthefirstelement,the
last,orsomewhereinbetween.Anattackercouldmeasurethis
variationintimetodeterminetheexpectedHMACvalueand
forgearequestthat’sprocessedlegitimately.Thehmac.Equal()
functionsolvesthisproblembycomparingtheslicesinaway
thatproducesnearlyconstantmeasurabletimes.Itdoesn’t
matterwherethefunctionfindsadifference,becausethe
processingtimeswillvaryinsignificantly,producingno
obviousorperceptiblepattern.
Themain()functionsimulatestheprocessofreceivinga
messagefromaclient.Ifyouwerereallyreceivingamessage,
you’dhavetoreadandparsetheHMACandmessagevalues
fromthetransmission.Sincethisisjustasimulation,you
insteadhardcodethereceivedmessage❺andthereceived
HMAC❻,decodingtheHMAChexstringsoit’srepresented
asa[]byte.YouuseanifstatementtocallyourcheckMAC()
function❼,passingityourreceivedmessageandHMAC.As
detailedpreviously,yourcheckMAC()functioncomputesan
HMACbyusingthereceivedmessageandthesharedsecret
keyandreturnsaboolvalueforwhetherthereceivedHMAC
andcalculatedHMACmatch.
AlthoughtheHMACdoesprovidebothauthenticityand
integrityassurance,itdoesn’tensureconfidentiality.Youcan’t
knowforsurethatthemessageitselfwasn’tseenby
unauthorizedresources.Thenextsectionaddressesthis
concernbyexploringandimplementingvarioustypesof
encryption.
ENCRYPTINGDATA
Encryptionislikelythemostwell-knowncryptographic
concept.Afterall,privacyanddataprotectionhavegarnered
significantnewscoverageduetohigh-profiledatabreaches,
oftenresultingfromorganizationsstoringuserpasswordsand
othersensitivedatainunencryptedformats.Evenwithoutthe
mediaattention,encryptionshouldsparktheinterestofblack
hatsanddevelopersalike.Afterall,understandingthebasic
processandimplementationcanbethedifferencebetweena
lucrativedatabreachandafrustratingdisruptiontoanattack
killchain.Thefollowingsectionpresentsthevaryingformsof
encryption,includingusefulapplicationsandusecasesfor
each.
Symmetric-KeyEncryption
Yourjourneyintoencryptionwillstartwithwhatisarguably
itsmoststraightforwardform—symmetric-keyencryption.In
thisform,boththeencryptionanddecryptionfunctionsusethe
samesecretkey.Gomakessymmetriccryptographypretty
straightforward,becauseitsupportsmostcommonalgorithms
initsdefaultorextendedpackages.
Forthesakeofbrevity,we’lllimitourdiscussionof
symmetric-keyencryptiontoasingle,practicalexample.Let’s
imagineyou’vebreachedanorganization.You’veperformed
thenecessaryprivilegeescalation,lateralmovement,and
networkrecontogainaccesstoane-commercewebserver
andthebackenddatabase.Thedatabasecontainsfinancial
transactions;however,thecreditcardnumberusedinthose
transactionsisobviouslyencrypted.Youinspectthe
applicationsourcecodeonthewebserveranddeterminethat
theorganizationisusingtheAdvancedEncryptionStandard
(AES)encryptionalgorithm.AESsupportsmultipleoperating
modes,eachwithslightlydifferentconsiderationsand
implementationdetails.Themodesarenotinterchangeable;
themodeusedfordecryptionmustbeidenticaltothatusedfor
encryption.
Inthisscenario,let’ssayyou’vedeterminedthatthe
applicationisusingAESinCipherBlockChaining(CBC)
mode.So,let’swriteafunctionthatdecryptsthesecreditcards
(Listing11-4).Assumethatthesymmetrickeywashardcoded
intheapplicationorsetstaticallyinaconfigurationfile.As
yougothroughthisexample,keepinmindthatyou’llneedto
tweakthisimplementationforotheralgorithmsorciphers,but
it’sagoodstartingplace.
funcunpad(buf[]byte)[]byte{❶
//Assumevalidlengthandpadding.Shouldaddchecks
padding:=int(buf[len(buf)-1])
returnbuf[:len(buf)-padding]
}
funcdecrypt(ciphertext,key[]byte)([]byte,error){❷
var(
plaintext[]byte
iv[]byte
blockcipher.Block
modecipher.BlockMode
errerror
)
iflen(ciphertext)<aes.BlockSize{❸
returnnil,errors.New("Invalidciphertextlength:tooshort")
}
iflen(ciphertext)%aes.BlockSize!=0{❹
returnnil,errors.New("Invalidciphertextlength:notamultipleofblocksize")
}
iv=ciphertext[:aes.BlockSize]❺
ciphertext=ciphertext[aes.BlockSize:]
ifblock,err=aes.NewCipher(key);err!=nil{❻
returnnil,err
}
mode=cipher.NewCBCDecrypter(block,iv)❼
plaintext=make([]byte,len(ciphertext))
mode.CryptBlocks(plaintext,ciphertext)❽
plaintext=unpad(plaintext)❾
returnplaintext,nil
}
Listing11-4:AESpaddinganddecryption(/ch-11/aes/main.go)
Thecodedefinestwofunctions:unpad()anddecrypt().The
unpad()function❶isautilityfunctionscrapedtogetherto
handletheremovalofpaddingdataafterdecryption.Thisisa
necessarystep,butbeyondthescopeofthisdiscussion.Do
someresearchonPublicKeyCryptographyStandards(PKCS)
#7paddingformoreinformation.It’sarelevanttopicforAES,
asit’susedtoensurethatourdatahasproperblockalignment.
Forthisexample,justknowthatyou’llneedthefunctionlater
tocleanupyourdata.Thefunctionitselfassumessomefacts
thatyou’dwanttoexplicitlyvalidateinareal-worldscenario.
Specifically,you’dwanttoconfirmthatthevalueofthe
paddingbytesisvalid,thatthesliceoffsetsarevalid,andthat
theresultisofappropriatelength.
Themostinterestinglogicexistswithinthedecrypt()function
❷,whichtakestwobyteslices:theciphertextyouneedto
decryptandthesymmetrickeyyou’llusetodoit.The
functionperformssomevalidationtoconfirmthatthe
ciphertextisatleastaslongasyourblocksize❸.Thisisa
necessarystep,becauseCBCmodeencryptionusesan
initializationvector(IV)forrandomness.ThisIV,likeasalt
valueforpasswordhashing,doesn’tneedtoremainsecret.The
IV,whichisthesamelengthasasingleAESblock,is
prependedontoyourciphertextduringencryption.Ifthe
ciphertextlengthislessthantheexpectedblocksize,you
knowthatyoueitherhaveanissuewiththeciphertextorare
missingtheIV.Youalsocheckwhethertheciphertextlength
isamultipleoftheAESblocksize❹.Ifit’snot,decryption
willfailspectacularly,becauseCBCmodeexpectsthe
ciphertextlengthtobeamultipleoftheblocksize.
Onceyou’vecompletedyourvalidationchecks,youcan
proceedtodecrypttheciphertext.Asmentionedpreviously,
theIVisprependedtotheciphertext,sothefirstthingyoudo
isextracttheIVfromtheciphertext❺.Youusethe
aes.BlockSizeconstanttoretrievetheIVandthenredefineyour
ciphertextvariabletotheremainderofyourciphertextvia
ciphertext=[aes.BlockSize:].Younowhaveyourencrypteddata
separatefromyourIV.
Next,youcallaes.NewCipher(),passingityoursymmetric-key
value❻.ThisinitializesyourAESblockmodecipher,
assigningittoavariablenamedblock.Youtheninstructyour
AESciphertooperateinCBCmodebycalling
cipher.NewCBCDecryptor(block,iv)❼.Youassigntheresulttoa
variablenamedmode.(Thecrypto/cipherpackagecontains
additionalinitializationfunctionsforotherAESmodes,but
you’reusingonlyCBCdecryptionhere.)Youthenissueacall
tomode.CryptBlocks(plaintext,ciphertext)todecryptthecontentsof
ciphertext❽andstoretheresultintheplaintextbyteslice.Lastly,
you❾removeyourPKCS#7paddingbycallingyourunpad()
utilityfunction.Youreturntheresult.Ifallwentwell,this
shouldbetheplaintextvalueofthecreditcardnumber.
Asamplerunoftheprogramproducestheexpectedresult:
$gorunmain.go
key=
aca2d6b47cb5c04beafc3e483b296b20d07c32db16029a52808fde98786646c8
ciphertext=
7ff4a8272d6b60f1e7cfc5d8f5bcd047395e31e5fc83d062716082010f637c8f21150eabace62
--snip--
plaintext=4321123456789090
Noticethatyoudidn’tdefineamain()functioninthissample
code.Whynot?Well,decryptingdatainunfamiliar
environmentshasavarietyofpotentialnuancesandvariations.
Aretheciphertextandkeyvaluesencodedorrawbinary?If
they’reencoded,aretheyahexstringorBase64?Isthedata
locallyaccessible,ordoyouneedtoextractitfromadata
sourceorinteractwithahardwaresecuritymodule,for
example?Thepointis,decryptionisrarelyacopy-and-paste
endeavorandoftenrequiressomelevelofunderstandingof
algorithms,modes,databaseinteraction,anddataencoding.
Forthisreason,we’vechosentoleadyoutotheanswerwith
theexpectationthatyou’llinevitablyhavetofigureitout
whenthetimeisright.
Knowingjustalittlebitaboutsymmetric-keyencryption
canmakeyourpenetrationstestsmuchmoresuccessful.For
example,inourexperiencepilferingclientsource-code
repositories,we’vefoundthatpeopleoftenusetheAES
encryptionalgorithm,eitherinCBCorElectronicCodebook
(ECB)mode.ECBmodehassomeinherentweaknessesand
CBCisn’tanybetter,ifimplementedincorrectly.Cryptocan
behardtounderstand,sooftendevelopersassumethatall
cryptociphersandmodesareequallyeffectiveandare
ignorantoftheirsubtleties.Althoughwedon’tconsider
ourselvescryptographers,weknowjustenoughtoimplement
cryptosecurelyinGo—andtoexploitotherpeople’sdeficient
implementations.
Althoughsymmetric-keyencryptionisfasterthan
asymmetriccryptography,itsuffersfrominherentkey-
managementchallenges.Afterall,touseit,youmust
distributethesamekeytoanyandallsystemsorapplications
thatperformtheencryptionordecryptionfunctionsonthe
data.Youmustdistributethekeysecurely,oftenfollowing
strictprocessesandauditingrequirements.Also,relyingsolely
onsymmetric-keycryptographypreventsarbitraryclients
from,forexample,establishingencryptedcommunications
withothernodes.Thereisn’tagoodwaytonegotiatethe
secretkey,norarethereauthenticationorintegrityassurances