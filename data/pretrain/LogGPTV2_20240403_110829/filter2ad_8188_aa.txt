# 密码学基本原理（下）
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
**连载系列——It works,why?**
在做密码学相关项目的时候，经常可以看到很多程序员，对密码学有哪些技术，每个技术怎么用一无所知。在选择合适的密码学技能来达成目标的时候，总是选择自己最熟悉的方案，这不一定是最好的方案，甚至不一定是合格的方案。后果往往有两个：一个是很多代码潜伏着安全隐患；另一个则是，很多算法并不如想象中那样工作。我们时时可以见到程序员对着电脑沉思，这个算法不能工作，Why？又时时可以见到，这个算法能工作，Why？因此我将在“It
works,why?”系列文章中，论述常见的算法和常见应用，其中的“Why”。
《密码学基本原理（下）》本文简述了公钥密码学的常见算法和相关特征。
## Public-key signature
公钥签署为三个函数：生成G，签署为S，校验为V。对任意数据d和密钥p：
  1. G可以生成私钥和公钥。即s,p=G()，其中s为私钥，p为公钥。公钥可以公开；
  2. 对于签署获得的v=S(d, s)，可以用V(d, v, p)来检验d和v是否成对；
  3. 攻击者在得知S，V，v，d，p的情况下，无法反推s。
## 单向陷门函数与DH密钥交换问题
上面说了公钥密码系统的目标，下面我们说说公钥系统的一般规律。公钥系统的一般原则是，用户持有私钥s，公开公钥p，然后利用单向陷门函数完成特定密码学目标。
假定我们有一个集合G， _是集合G上的一个运算，满足交换率和结合率，O是集合G上的一个特定元素(或更普遍的，一类元素)，同时_ 具有一个特点，求y=x
_O非常简单，求x使得对已知y有y=x_ O非常困难。
Kx的普遍算法，就是A和B各自随机生成一个元素ka和kb，计算pa=ka _O和pb=kb_ O，再计算k=kb _pa=ka_ pb。由于kb
_pa=kb_ (ka _O)=(kb_ ka) _O=(ka_ kb) _O和ka_ pb=ka _(kb_ O)=(ka _kb)_
O，因此k相等。同时由于*求逆非常困难，因此攻击者无法推出ka或kb，从而无法推出k。
### Integrated Encryption Scheme
IES是一种基于Kx的加密算法，这种算法是非确定性的。
基于某种单项陷门函数，假设我们有某人A的公钥pa，如何利用pa加密数据，使得只有A能解开？
首先，生成随机密钥kb和公钥pb，而后计算k=kb
_pa，再用k生成密钥k’，用k’加密数据，并将pb和秘密数据c一同发送。接收者使用pb和ka计算k=ka_
pb，进而可以得知密钥k’，从而可以解出明文。在IES体系中，用k获得k’的算法一般是某种KDF。
IES是一种非确定性加密，他很大程度上依赖于生成的随机密钥的安全，一旦有了随机密钥kb，就可以根据pa算出k，进而算出k’，如果随机密钥生成过程很容易被攻破，那么算法上再保障安全性也是没用的。
### MQV
MQV是一种基于DH的带认证Kx算法。他首先假定Alice和Bob互相可信的持有对方的公钥，而后讨论如何在非可信信道上生成一个临时的公共秘密。注意这是一种非确定性算法(几乎所有的Kx都应该是非确定性算法，否则有被攻击导致前向安全性问题的可能性)。而且该算法不需要公钥系统带有签署能力(DH_RSA实际上是利用签署互信的非认证性Kx算法)，验证能力在算法内部。
### Diffie-Hellman key exchange
Diffie-Hellman算法是密钥交换算法中最典型的一个，其依赖的是求离散对数问题(DLP)的复杂性。抽象的说，就是设定集合G为正整数集合，
_运算为s_ g = g^s mod p，其中p为预先约定变量，具体算法如下：
通信双方 Alice 和 Bob 需要约定好算法参数：一个素数 p 作为模数，一个素数 g 作为基数（生成元），可对外公开。
对 Alice 来说，先想好一个自然数 a 作为私钥，然后计算 pa = g^a mod p 作为公钥；
对 Bob 来说，先想好一个自然数 b 作为私钥，然后计算 pb = g^b mod p 作为公钥。
之后互换公钥，然后
Alice 计算出 k = pb^a mod p；
Bob 计算出 k = pa^b mod p。
我们取wiki上的例子：
  1. Alice和Bob约定p=23，g=5；
  2. Alice选取a=4，计算pa=5^4mod23=4。Alice将4发送给Bob；
  3. Bob选取b=3，计算pb=5^3mod23=10。Bob将10发送给Alice；
  4. Alice计算k=10^4mod23=18；
  5. Bob计算k=4^3mod23=18。
算法可以确保以下几点：
Alice 与 Bob 计算出的 k 必定是一致的；
双方都无法根据已知的数来推算对方私钥；
第三方可以看到 p、g、pa、pb、但无法推算出 a 与 b ，因此也无法推算 k。
## RSA系列算法
RSA是非对称密码算法中最著名的一项。这个算法包含了以下功能：
  1. 生成算法G
  2. 加密算法E
  3. 解密算法D
  4. 签署算法S
  5. 验证算法V
  6. 密钥交换算法
特别需要注意一点，RSA的加密算法并没有使用IES体制，RSA算法族里自带了加解密和签署。从某种意义上说，RSA其实和上面说的一般性单向陷门函数算法为基础的算法有所区别。
### 生成算法
  1. 首先有素数p和q，称为prime1和prime2；
  2. 计算n=p*q，称为modulus；
  3. 求n的Euler totient functionφ(n)=(p-1)*(q-1)；
  4. 选择一个和φ(n)互素的数e，称为public exponent；
  5. 计算e对欧拉函数φ(n)的模反元素d，使得ed = 1 mod φ(n)。d称为private exponent。基于欧拉公式我们可知e^φ(n) = 1 mod φ(n)，即e*e^(φ(n)-1) = 1 mod φ(n)。因此可以取d = e^(φ(n)-1) mod φ(n)；
  6. 公开modulus和public exponent，为公钥。保留modulus和private exponent，作为私钥，其余需要保密（因为可以推出整套公私钥）。
PS: 3中说是Euler function，实际上Carmichael
function（[https://en.wikipedia.org/wiki/Carmichael_function）就行，欧拉函数总是其整数倍，因此也能工作，就是数字比较大。Carmichael函数λ(n)=lcm(p-1](https://en.wikipedia.org/wiki/Carmichael_function%EF%BC%89%E5%B0%B1%E8%A1%8C%EF%BC%8C%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%80%BB%E6%98%AF%E5%85%B6%E6%95%B4%E6%95%B0%E5%80%8D%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B9%9F%E8%83%BD%E5%B7%A5%E4%BD%9C%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%95%B0%E5%AD%97%E6%AF%94%E8%BE%83%E5%A4%A7%E3%80%82Carmichael%E5%87%BD%E6%95%B0%CE%BB\(n\)=lcm\(p-1),
q-1)=(p-1)*(q-1)/gcd(p-1, q-1)=φ(n)/gcd(p-1, q-1)。
例如取wiki上的例子：
  1. p=61，q=53；
  2. n=61*53=3233；
  3. φ(n)=60*52=3120（原文里，取的是Carmichael函数，λ(n)=3120/gcd(61,53)=780）；
  4. e=17（在实践中，这个值一般都是65537）；