vide excellent protection in conjunction with our CFI.
If, on the other hand, we assume that randomization of
ASLR can be defeated, then there is no good reason to
believe that a randomization component added to a CFI
technique won’t be defeated either. Thirdly, the util-
ity of randomization is increasingly called into question
by advances in information leakage attacks. Recent ex-
ploits [37, 16] show that strong information leakage at-
tack could help bypass ASLR with high entropy. More-
over, just-in-time code reuse attacks [39] discover gad-
gets using repeated information leakage attacks and are
able to defeat even ﬁne-grained code randomization.
8.2 Control Flow Integrity
Control-ﬂow integrity (CFI) was introduced by Abadi et
al [1]. The basic idea was to use a static analysis to com-
pute a control-ﬂow graph, and enforce it at runtime. En-
forcement was based on matching constants (called IDs)
between the source and target of each ICF transfer. How-
ever, due to difﬁculties in performing accurate points-
to analysis, and because of so-called destination equiv-
alence problem, their implementation resorts to coarse
granularity enforcement, wherein any indirect call is per-
mitted to target any function whose address is taken. Li
et al.
[22] implement a compiler based CFI that uses
a similar policy for coarse-grained CFI. While they can
also support ﬁner-granularity CFI, this requires runtime
proﬁling to compute possible targets of indirect calls, and
can hence be prone to false positives.
Control-ﬂow locking (CFL) [6] improves signiﬁcantly
on the performance of Abadi et al, while simultaneously
tightening the policy, especially for returns. But this
tighter policy poses challenges in the presence of indi-
rect tail calls. Another difference between their work and
ours is that they operate on assembly code generated by
the compiler, whereas our work targets binaries.
MoCFI [13] presents a design and implementation
of CFI for mobile platforms. The mobile environment
presents a unique set of challenges, including an instruc-
tion set that does not have explicit returns, a closed plat-
form (iOS), and so on. An important characteristic of
their approach is that they aggressively prune possible
targets of each ICF transfer. While this can provide bet-
ter protection, it leads to false positives in some cases
(e.g., when large jump tables are involved). In contrast,
our approach emphasizes handling of large binaries, in-
cluding shared libraries, that are not handled by their ap-
proach. We discussed how this requirement dictates the
use of coarser granularity CFI in our technique.
CCFIR [48], like the work presented in this paper,
targets binaries. The main insight in their work is that
most binaries on Windows support ASLR, which re-
quires relocation information to be included in the bi-
nary. They leverage this information for accurate dis-
assembly and static rewriting. Moreover, since reloca-
tion information effectively identiﬁes all code pointers,
they can avoid runtime address translation, which en-
ables them to achieve better performance. The ﬂipside
of this performance improvement is that the technique
can’t be used on most UNIX systems, as UNIX binaries
rarely contain the requisite relocations.
CFI has been used as the basis for untrusted code
sandboxing. PittSFIeld [27] implements SFI on top of
instruction bundling, a weaker CFI model. XFI [15]
presents techniques that are based on CFI and SFI to
conﬁne untrusted code in shared-memory environments.
Zeng et al [47] improve the performance of SFI using
CFI and static analysis. Native client [46] is aimed at
running native binaries securely in a browser context,
and relies on instruction bundling. PittSFIeld, Native
Client, and many other works [22, 3, 4, 42, 21, 36, 34, 20]
that enforce CFI rely on compiler-provided information
and even hardware support. In contrast, bin-CFI operates
on COTS binaries without support from compiler, OS or
hardware.
9 Conclusions
In this paper, we developed a notion of control-ﬂow in-
tegrity that can be effectively enforced on binaries. We
developed analysis techniques to compute possible ICF
targets, and instrumentation techniques that limit ICF
transfers to these targets. The resulting implementa-
tion defeats most common control-ﬂow hijack attacks,
and greatly reduces the number of possible gadgets for
ROP attacks. We presented a robust implementation that
scales to large binaries as well as complex, low-level
libraries that include hand-coded assembly. Our tech-
nique is modular, supporting independent transformation
of shared libraries.
It also provides very good perfor-
mance.
Our results realize one of central beneﬁts of the CFI
property, i.e., it can be applied to protect low-level code
that is available only in the form of binaries. Although
the lack of high-level information can degrade the pre-
cision of static analysis, our results demonstrate that the
reduction is small; and overall, there is only a modest re-
duction in the strength of protection as compared to pre-
vious techniques that required source code, relocation in-
formation, or relied on compiler-based implementations.
350  22nd USENIX Security Symposium 
USENIX Association
14
10 Acknowledgements
We are very grateful to the developers of Katana, es-
pecially James Oakley for his quick and very helpful
responses to our questions. Also we thank Edward
Schwartz for his technique support.
References
[1] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.
In the 12th ACM conference on
Control-ﬂow integrity.
Computer and communications security (CCS), 2005.
[2] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.
Control-ﬂow integrity principles, implementations, and
applications. ACM Transactions on Information and Sys-
tem Security (TISSEC), (1), Nov. 2009.
[3] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and M. Cas-
tro. Preventing memory error exploits with WIT.
In
the 29th IEEE Symposium on Security and Privacy (Oak-
land), 2008.
[4] J. Ansel, P. Marchenko, U. Erlingsson, E. Taylor, B. Chen,
D. L. Schuff, D. Sehr, C. L. Bifﬂe, and B. Yee. Language-
independent sandboxing of just-in-time compilation and
self-modifying code. In the 32nd ACM SIGPLAN confer-
ence on Programming language design and implementa-
tion (PLDI), 2011.
[5] S. Bhatkar, D. C. DuVarney, and R. Sekar. Address obfus-
cation: an efﬁcient approach to combat a board range of
memory error exploits. In the 12th conference on USENIX
Security Symposium, 2003.
[6] T. Bletsch, X. Jiang, and V. Freeh. Mitigating code-
reuse attacks with control-ﬂow locking. In the 27th An-
nual Computer Security Applications Conference (AC-
SAC), 2011.
[7] T. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang. Jump-
oriented programming: a new class of code-reuse attack.
In the 6th ACM Symposium on Information, Computer
and Communications Security (ASIACCS), 2011.
[8] D. L. Bruening. Efﬁcient, transparent, and comprehensive
runtime code manipulation. PhD thesis, MIT, 2004.
[9] E. Buchanan, R. Roemer, H. Shacham, and S. Savage.
When good instructions go bad: generalizing return-
oriented programming to RISC. In the 15th ACM confer-
ence on Computer and communications security (CCS),
2008.
[10] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi,
H. Shacham, and M. Winandy. Return-oriented program-
ming without returns.
In the 17th ACM conference on
Computer and communications security (CCS), 2010.
[11] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and L. Xie.
DROP: Detecting return-oriented programming malicious
code. In the 5th International Conference on Information
Systems Security (ICISS), 2009.
[12] C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole,
P. Bakke, S. Beattie, A. Grier, P. Wagle, and Q. Zhang.
StackGuard: automatic adaptive detection and preven-
tion of buffer-overﬂow attacks. In the 7th conference on
USENIX Security Symposium, 1998.
[13] L. Davi, R. Dmitrienko, M. Egele, T. Fischer, T. Holz,
R. Hund, S. Nrnberger, and A. reza Sadeghi. MoCFI:
A framework to mitigate control-ﬂow attacks on smart-
phones. In the 19th Network and Distributed System Se-
curity Symposium (NDSS), 2012.
[14] L. Davi, Ahmad-Reza Sadeghi, and M. Winandy. ROPde-
fender: a detection tool to defend against return-oriented
programming attacks. In the 6th ACM Symposium on In-
formation, Computer and Communications Security (ASI-
ACCS), 2011.
[15] U. Erlingsson, S. Valley, M. Abadi, M. Vrable, M. Budiu,
and G. C. Necula. XFI: software guards for system ad-
dress spaces. In the 7th USENIX Symposium on Operating
Systems Design and Implementation (OSDI), 2006.
[16] C. Evans.
Exploiting 64-bit
linux like a boss.
http://scarybeastsecurity.blogspot.com/2013/02/exploiting-
64-bit-linux-like-boss.html.
[17] M. Frantzen and M. Shuey. StackGhost: Hardware facili-
tated stack protection. In the 10th conference on USENIX
Security Symposium, 2001.
[18] J. Hiser, A. Nguyen-Tuong, M. Co, M. Hall, and J. W.
Davidson.
In the 33th
IEEE Symposium on Security and Privacy (Oakland),
2012.
ILR: Where’d my gadgets go?
[19] R. Hund, T. Holz, and F. C. Freiling. Return-oriented
rootkits: bypassing kernel code integrity protection mech-
anisms. In the 18th conference on USENIX security sym-
posium, 2009.
[20] M. Kayaalp, M. Ozsoy, N. Abu-Ghazaleh, and D. Pono-
marev. Branch regulation: low-overhead protection from
code reuse attacks. In the 39th Annual International Sym-
posium on Computer Architecture (ISCA), 2012.
[21] V. Kiriansky, D. Bruening, and S. P. Amarasinghe. Secure
execution via program shepherding. In the 11th confer-
ence on USENIX Security Symposium, 2002.
[22] J. Li, Z. Wang, T. Bletsch, D. Srinivasan, M. Grace,
and X. Jiang. Comprehensive and efﬁcient protection of
kernel control data.
IEEE Transactions on Information
Forensics and Security, (4), Dec. 2011.
[23] J. Li, Z. Wang, X. Jiang, M. Grace, and S. Bahram. De-
feating return-oriented rootkits with ”return-less” kernels.
In the 5th European conference on Computer systems (Eu-
roSys), 2010.
[24] the PaX team.
Address space layout randomization.
http://pax.grsecurity.net/docs/aslr.txt, 2001.
[25] Tool Interface Standard. Executable and linking format
(ELF) speciﬁcation. http://www.uclibc.org/docs/elf.pdf,
1995.
[26] UNIX International Programming Languages SIG.
DWARF debugging
//www.dwarfstd.org/doc/dwarf-2.0.0.pdf, 1993.
information
format.
http:
USENIX Association  
22nd USENIX Security Symposium  351
15
[27] S. McCamant and G. Morrisett. Evaluating SFI for a CISC
architecture. In the 15th conference on USENIX Security
Symposium, 2006.
[28] Nergal. The advanced return-into-lib(c) exploits: PaX
case study. Phrack Magazine, 2001.
[29] J. Oakley and S. Bratus. Exploiting the hard-working
DWARF: trojan and exploit techniques with no native ex-
ecutable code. Technical report, Computer Science De-
partment, Dartmouth College, 2011.
[30] J. Oakley and S. Bratus. Exploiting the hard-working
DWARF: trojan and exploit techniques with no native ex-
ecutable code. In the 5th USENIX conference on Offensive
technologies (WOOT), 2011.
[31] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and
E. Kirda. G-Free: defeating return-oriented programming
through gadget-less binaries.
In the 26th Annual Com-
puter Security Applications Conference (ACSAC), 2010.
[32] V. Pappas. kBouncer: Efﬁcient and transparent ROP mit-
igation. Technical report, Columbia University, 2012.
[33] V. Pappas, M. Polychronakis, and A. D. Keromytis.
Smashing the gadgets: Hindering return-oriented pro-
gramming using in-place code randomization.
In the
33th IEEE Symposium on Security and Privacy (Oak-
land), 2012.
[34] A. Prakash, H. Yin, and Z. Liang. Enforcing system-wide
control ﬂow integrity for exploit detection and diagnosis.
In the 8th ACM SIGSAC symposium on Information, com-
puter and communications security (ASIACCS), 2013.
[42] Z. Wang and X. Jiang. HyperSafe: A lightweight ap-
proach to provide lifetime hypervisor control-ﬂow in-
tegrity. In the 31th IEEE Symposium on Security and Pri-
vacy (Oakland), 2010.
[43] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin. Binary
stirring: self-randomizing instruction addresses of legacy
x86 binary code. In the 19th ACM conference on Com-
puter and communications security (CCS), 2012.
[44] wikipedia. Open addressing hashing. http://en.wikipedia.
org/wiki/Open addressing, 2012.
[45] J. Wilander, N. Nikiforakis, Y. Younan, M. Kamkar, and
W. Joosen. RIPE: runtime intrusion prevention evaluator.
In the 27th Annual Computer Security Applications Con-
ference (ACSAC), 2011.
[46] B. Yee, D. Sehr, G. Dardyk, J. B. Chen, R. Muth, T. Or-
mandy, S. Okasaka, N. Narula, and N. Fullagar. Native
client: A sandbox for portable, untrusted x86 native code.
In the 30th IEEE Symposium on Security and Privacy
(Oakland), 2009.
[47] B. Zeng, G. Tan, and G. Morrisett. Combining control-
ﬂow integrity and static analysis for efﬁcient and validated
data sandboxing. In the 18th ACM conference on Com-
puter and communications security (CCS), 2011.
[48] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. Mc-
Camant, D. Song, and W. Zou. Practical control ﬂow in-
tegrity & randomization for binary executables.
In the
34th IEEE Symposium on Security and Privacy, 2013.
[49] D. D. Zovi. Practical return-oriented programming. Tech-
[35] J. Salwan. ROPGadget. http://shell-storm.org/project/
nical report, SOURCE, 2010.
ROPgadget.
[36] D. Sehr, R. Muth, C. Bifﬂe, V. Khimenko, E. Pasko,
K. Schimpf, B. Yee, and B. Chen. Adapting software fault
isolation to contemporary cpu architectures. In the 19th
conference on USENIX Security Symposium, 2010.
[37] F. J. Serna. CVE-2012-0769, the case of the perfect info
leak, 2012.
[38] H. Shacham. The geometry of innocent ﬂesh on the bone:
return-into-libc without function calls (on the x86). In the
14th ACM conference on Computer and communications
security (CCS), 2007.
[39] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko,
C. Liebchen, and A.-R. Sadeghi. Just-in-time code reuse:
On the effectiveness of ﬁne-grained address space layout
randomization. In the 34th IEEE Symposium on Security
and Privacy, 2013.
[40] R. Strackx, Y. Younan, P. Philippaerts, F. Piessens,
S. Lachmund, and T. Walter. Breaking the memory se-
crecy assumption. In the 2nd European Workshop on Sys-
tem Security (EUROSEC), 2009.
[41] M. Tran, M. Etheridge, T. Bletsch, X. Jiang, V. Freeh, and
P. Ning. On the expressiveness of return-into-libc attacks.
In the 14th international conference on Recent Advances
in Intrusion Detection (RAID), 2011.
352  22nd USENIX Security Symposium 
USENIX Association
16