# 全局锁和表级锁：给表加字段的挑战

## 全局锁

全局锁是对整个数据库实例进行锁定的一种机制。MySQL 提供了 `Flush tables with read lock (FTWRL)` 命令来实现这一功能。当需要将整个数据库置于只读状态时，可以使用此命令。执行该命令后，其他线程的数据更新语句（如数据的增删改）、数据定义语句（例如建表或修改表结构）以及更新类事务的提交语句都会被阻塞。

### 典型应用场景
全局锁的一个典型应用场景是进行全库逻辑备份。即通过 `select` 语句导出所有表的数据并保存为文本文件。传统做法是在备份前执行 `FTWRL` 以确保没有其他线程对数据库进行写操作，从而保证备份的一致性。然而，在备份过程中，整个数据库将处于完全只读状态，这可能带来以下风险：
- 如果在主库上执行备份，则在此期间业务几乎无法运行。
- 若选择从库作为备份目标，那么备份期间从库不能应用主库同步过来的 binlog，导致主从延迟增加。

尽管如此，我们仍需理解为何要在备份过程中使用全局锁。如果不加锁会有什么问题呢？假设你正在维护一个在线教育平台“极客时间”的购买系统，其中包含用户账户余额表 (`u_account`) 和已购课程表 (`u_course`)。如果在未加锁的情况下进行逻辑备份，可能会遇到如下情况：

1. 备份开始时先复制了 `u_account` 表。
2. 之后某用户购买了一门新课程，系统自动扣除其账户余额，并在 `u_course` 中添加一条记录。
3. 最后备份完成 `u_course` 表。

这种情况下，最终备份结果将是不一致的——用户 A 的账户余额未减少但已购课程列表中却多出了一个条目。若日后基于此备份恢复数据，将会出现错误。

为了避免此类问题发生，必须确保备份过程中的数据一致性。对于支持事务隔离级别的存储引擎（如 InnoDB），可以通过开启一个事务来获取一致性视图。具体来说，在可重复读隔离级别下启动事务即可达到目的。MySQL 官方提供的逻辑备份工具 `mysqldump` 在使用 `--single-transaction` 参数时，会在导出数据前启动一个事务，利用 MVCC 特性保证备份期间的数据一致性。

然而，并非所有存储引擎都支持事务处理。对于 MyISAM 这样的非事务型引擎，任何更新操作都将破坏备份的一致性，因此在这种情况下仍然需要使用 `FTWRL` 方法来锁定数据库。

此外，虽然设置 `set global readonly=true` 也能使整个数据库进入只读模式，但出于兼容性和异常处理方面的考虑，推荐采用 `FTWRL` 方式来进行全局锁定。

## 表级锁

在 MySQL 中，表级别的锁主要分为两类：表锁与元数据锁（MDL）。

### 表锁
表锁可通过 `lock tables ... read/write` 语法来实现。类似于 `FTWRL`，表锁可以在客户端断开连接时自动释放。需要注意的是，执行 `lock tables` 不仅会影响其他线程对该表的操作权限，还会限制当前会话后续能够访问的对象范围。例如，如果某个会话中执行了 `lock tables t1 read, t2 write;`，则该会话只能对 `t1` 执行读取操作、对 `t2` 执行读写操作，直到显式地调用 `unlock tables` 为止。

对于支持行级锁定的 InnoDB 引擎而言，通常不需要使用 `lock tables` 来控制并发访问，因为锁定整张表所带来的影响过于广泛。

### 元数据锁（MDL）
MDL 是一种自动附加于表上的锁类型，用于保护表结构免受并发修改的影响。每当有查询访问某张表时，系统会自动为其加上 MDL 读锁；而当尝试更改表结构时，则需获得 MDL 写锁。读锁之间相互独立，允许多个线程同时进行读取；但读写锁及写锁之间互斥，确保了表结构调整的安全性。

#### 实际案例
假设有三个会话分别尝试访问同一张小表 `t`，其中 session A 已经获得了 MDL 读锁，session B 也可以顺利获取相同的锁类型，但由于 session C 需要申请 MDL 写锁以便修改表结构，它将被阻塞直至所有先前持有的 MDL 读锁被释放。此时，如果有新的请求试图再次获取 MDL 读锁，它们同样会被 session C 挡住，从而形成死锁局面。这种情况尤其容易发生在热点表上，频繁的读写活动可能导致整个数据库陷入停滞状态。

为了避免上述问题，在进行 DDL 操作之前应检查是否存在长时间运行的事务，并尽可能缩短变更窗口期。另外，还可以考虑使用 NOWAIT/WAIT N 选项指定等待超时时间，一旦超过设定值便立即放弃本次操作，留待稍后再试。

## 小结
本文探讨了 MySQL 中的全局锁与表级锁机制及其应用场景。对于完全基于 InnoDB 引擎构建的数据库系统，建议优先选用 `--single-transaction` 参数来进行逻辑备份。至于表锁，则主要用于那些不具备行级锁定能力的老式存储引擎。而在实际开发过程中，务必谨慎处理 MDL 锁，避免因不当配置而导致生产环境下的性能瓶颈或服务中断。

最后，请思考这样一个问题：如果你正在从库上使用 `--single-transaction` 方法执行逻辑备份，而此时主库对一个小表进行了 DDL 变更（比如添加了一个新列），那么从库上会发生什么现象呢？欢迎在评论区分享你的见解！