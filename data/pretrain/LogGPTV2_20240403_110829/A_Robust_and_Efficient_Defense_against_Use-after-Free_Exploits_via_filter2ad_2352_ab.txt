check with one single memory read.
However, this implementation is still inefficient. First, it incurs
high overhead to set and clear shadow heap in setFreed() and
clearFreed(). Second, it doubles memory consumption. To opti-
mize, we leverage the observation that pragmatic memory alloca-
tors usually enforce object size and alignment. For example, the
base and size of small and large objects (based on a predefined size
threshold) are usually aligned to multiples of the pointer and page
size, respectively. Therefore, the MAS table only requires 1-byte for
every page or 8-byte on x64 (4-byte on x86).
For isPointer(), setPointer(), and clearPointer(), we im-
plement a pointer location mark (PLM) table similar to the MAS
table. PLM represents every 8-byte on x64 and 4-byte on x86 to
1-byte, but PLM cannot compress a memory page to 1-byte.
4.2 Locating Live Pointers
pSweeper first statically identifies pointer variables at compile time,
and instrument code to bookmark live pointers at runtime. Pointers
can be on stack, data, and heap segments. Dangling pointers on all
three regions can be exploited.
4.2.1 Pointers on Data Segment.
Pointers can reside in data segments, including global and static
variables2. These pointers can generally be identified at compile
time. For each global pointer variable, we instrument a store instruc-
tion to log its address to a buffer denoted as globalptr. globalptr
is library-specific, i.e., every library as well as the executable has a
dedicated buffer. pSweeper instruments .init and .fini sections
to every executable and library so that globalptr is (de)allocated
upon (un)loading.
4.2.2 Pointers on Stack.
pSweeper handles the pointers in function parameters and local
variables in a similar way as global variables. However, due to
the asynchronous design of pSweeper, pointers on stack need to
be specially handled. Consider the dangling pointer p in Figure 4,
before pSweeper neutralizes p, function f unc1 returns and f unc2
is subsequently invoked. Previously storing pointer p, the stack slot
now contains a non-pointer variable i. If i by chance has a value
Figure 3: The architecture of pSweeper.
API
setFreed(addr )
clearFreed(addr )
isFreed(addr )
setPointer(addr )
clearPointer(addr )
isPointer(addr )
Parameter
A virtual address
A virtual address
A virtual address
A virtual address
A virtual address
A virtual address
Table 1: Auxiliary APIs used in pSweeper.
Description
Return TRUE if addr is not allocated.
Set the freed flag for addr .
Clear the freed flag for addr .
Set pointer flag for addr .
Clear pointer flag for addr .
Return TRUE if addr is a pointer.
the dangling ones. The asynchronous nature of CPW requires ob-
ject frees to be deferred (§4.3). Otherwise, when a memory block
is freed, it may get reused before CPW threads can neutralize all
dangling pointers. The main challenge of CPW lies in efficiently
handling races among pSweeper and application threads. In partic-
ular, dangling pointers can propagate during concurrent sweeping.
To this end, we devise a simple and efficient mechanism to prevent
dangling pointer propagation (§4.5) so that dangling pointers are
guaranteed to be neutralized in one single round of sweeping.
Object origin tracking (OOT). Finally, pSweeper encodes ob-
ject origin information into dangling pointers so that once they are
dereferenced, pSweeper can inform developers how corresponding
objects are allocated and freed (§4.7).
4 SYSTEM DESIGN AND IMPLEMENTATION
In this section, we detail the design of pSweeper. Due to the asyn-
chronous design, we need to efficiently handle the entangled races
between application and pSweeper threads. In particular, we aim
to address these races with lock-free algorithms, which can highly
correlate with the memory model of multicore processors. Our cur-
rent design is built upon the memory model of x86 [7], AMD64,
and SPARC1.
4.1 Memory Allocation Status Table
To clearly describe the design of pSweeper’s core components, we
first define a list of APIs in Table 1. The first set of three APIs track
the allocation status of a virtual address. The other set of three APIs
can facilitate pSweeper to efficiently determine if a virtual address
contains a pointer.
1The default mode of SPARC is Total Store Order (TSO).
2We use “global variables” for short in the remainder of the paper.
Pointer Address Identification (§4.2)Compile-time PhaseRuntime Phase at User-siteApp Thread#1Concurrent Pointer Sweeping Thread (§4.4)live pointersMAS Table (§4.1)Source CodeBinary CodePrevent Dangling Pointer Propagation (§4.5)……App Thread#Ndeferred free (§4..3)UaF ExploitObject Origin Tracking (§4.7)Figure 4: Race conditions of pointers on stack.
Algorithm 1 Compile-time store instruction instrumentation for
pointer address identification.
1: function Bookmark_Heap_Pointer( )
2:
3:
4:
5:
if onDataOrStack(storeinst.dest) then
Instrument Bookmark_Ptr() after storeinst.
for each storeinst do
continue
equal to the address of a freed memory slot, pSweeper can falsely
neutralize it and thus corrupt application data.
To efficiently handle this race, pSweeper relocates all pointers on
stack to a dedicated stack denoted as stackptr. In this way, every
variable in stackptr is of pointer type. Thus, pSweeper can safely
sweep and neutralize them. However, pointers in complex data
types like struct and class cannot be easily moved to stackptr
without losing compatibility. We therefore simply allocate all such
variables on the heap.
4.2.3 Pointers on Heap.
Similar to previous works [36, 54, 58], we also rely on the types
of operands in store instructions to track pointer addresses at
runtime. The main difference lies in what task is performed at
each pointer store instruction. All previous systems require to
synchronously track (1) in which object a pointer is located and (2)
which object a pointer is pointing to. This inevitably incurs high
overhead due to the expensive range-based searches. In contrast,
pSweeper simply bookmarks the addresses of live pointers. This,
however, is still non-trivial to implement efficiently.
An assignment operation LHS=RHS is usually transformed to
a compiler intermediate representation (IR) store  ,
* , where val is the value in RHS and ptr is the memory
address of LHS. If the type  of val is a pointer, LHS is a pointer.
However, its address should not be naively bookmarked for three
considerations. First, we must ensure the pointer is not on data or
stack segments. Second, we should ignore duplicate bookmarks for
the same pointer. Finally, the pointer might be in a freed object.
Algorithm 1 and 2 show how pSweeper bookmarks live pointers.
Excluding global/local pointers. We exclude global/local point-
ers in two steps. First, we identify store instructions for non-heap
pointers at compile time and do not instrument them (Algorithm 1).
Second, at runtime, we check if the address of a pointer is indeed
in range of heap (Line 2 Algorithm 2).
Skipping duplicate bookmarks. Once a new pointer is en-
countered, we set the pointer flag using the API setPointer(&ptr).
In this way, when the pointer is encountered again, we can simply
omit it.
Validity of pointer address. We next use the API isFreed()
to check if the object where the pointer is contained has been freed
(Line 7 Algorithm 2). Note that, there is a potential race that the
object where ptr is contained gets freed and reused by another
Algorithm 2 Bookmark live pointer addresses.
PtrList: live pointer list
return
1: function Bookmark_Ptr( &ptr )
2:
3:
4:
5:
6:
7:
8:
9:
10:
if notOnHeap(&ptr) then
if isPointer(&ptr) then
setPointer(&ptr)
if isFreed(&ptr) then
clearPointer(&ptr)
return
appendToList(&ptr, PtrList)
return
1
2
3
4
5
6
7
struct LiveObjNode {
obj_addr ;
freeflag ;
scanflag ;
slotid ;
struct LiveObjNode * prev , * next ;
// object address
// Section §4.3
// Section §4.4
// Section §4.7
};
Figure 5: Metadata of live objects.
application thread after the check but before Line 10 Algorithm 2.
We discuss this race further in §4.4.
Live pointer list. We simply use a double-linked list (PtrList)
to maintain all live pointers. As a result, appendToList() is quite
efficient. Further, in order to avoid races among application threads
which can concurrently operate on PtrList, we use a separate list
for each thread. Note that, since we assume no concurrency bugs
in applications, it’s impossible that different application threads
concurrently invoke appendToList() for the same pointer. Therefore,
a thread-local PtrList is safe.
Removing stale pointers. Here we have described how to
bookmark live pointers. When an object is freed, all pointers con-
tained in it should be removed from PtrList. This is achieved in
CPW (§4.4).
4.3 Deferred Free
pSweeper requires object frees to be deferred to the end of a sweep-
ing round. To this end, pSweeper maintains live objects in a double-
linked list (ObjList) and adds metadata freeflag for each object
(Figure 5). In the hooked malloc(), pSweeper first sets freeflag
to zero (Line 5 Algorithm 3) and then appends the new object to
ObjList (Line 6 Algorithm 3). When free() is invoked in applica-
tions, we simply set freeflag as in Algorithm 4. Similar to PtrList,
each application thread uses a thread-local list to maintain objects
and nodes in ObjList are removed by CPW (§4.4).
4.4 Concurrent Pointer Sweeping (CPW)
CPW consists of two components, dedicated CPW threads and
dangling pointer propagation instrumentation. Dedicated CPW
threads are the core of CPW and they iteratively sweep live pointers
to find and neutralize dangling ones. One challenge here is that
application threads can propagate dangling pointers to the pointers
that have been neutralized by CPW threads. We devise a simple and
efficient mechanism (§4.5) to prevent dangling pointer propagation
App Threadcall func1(*p){ free(p); } call func2(i){}                                          OOT(&p)pSweeperAlgorithm 3 Hooked malloc().
1: function malloc( size )
2:
3:
4:
5:
6:
7:
obj ← real_malloc(size)
clearFreed(obj)
obj.scan f laд ← 0
obj.f ree f laд ← 0
appendToObjList(obj, ObjList)
mfence
◃ Memory barrier
Algorithm 4 Deferred free() invoked in applications.
1: function free( obj )
2:
3:
4:
assertDoubleFree(obj)
setFreed(obj)
obj.f ree f laд ← 1
◃ Abort upon double free.
in application threads. Next, we describe each component in details.
We first assume one CPW thread is spawned for a multi-threaded
application and extend to multiple CPW threads in §4.6.
Algorithm 5 presents the pseudocode of CPW thread whose body
is an infinite loop (Line 2) implementing iterative sweeping. CPW
takes a list of live objects and pointers as input. In every round of
sweeping, CPW threads execute in three steps.
• Step 1 (Lines 4 ∼ 9)
This step traverses live object list and if an object’s freeflag is set,
another field of metadata scanflag is set. scanflag is initialized
as 0 in malloc() (Line 4 Algorithm 3). fillWithSlotIndex() is
used by OOT which will be described in §4.7. Step 1 is required
to guarantee that an object whose freeflag is set during pointer
sweeping is not prematurely freed.
• Step 2 (Lines 11 ∼ 18)
This step sweeps all live pointers and checks if a pointer is dangling
(Line 15). Dangling pointers are then neutralized with a value con-
taining object origin information (Line 16). However, this step has a
time of check to time of neutralization race as illustrated in Figure 6.
To be specific, the value of p can be modified by application threads
after the isDangling() check.
To address this, we observe that if a dangling pointer is modi-
fied by application threads between isDangling() and OOT(), we
should preserve the value written by application threads and the
neutralization by pSweeper can fail safely. On the one hand, if the
new value written by application threads points to a live object, the
dangling pointer is eliminated by application threads and we must
preserve the value for correct execution. On the other hand, if the
new value points to a freed object, this propagation will be han-
dled by our mechanism that prevents dangling pointer propagation
(§4.5). Fortunately, modern processors provide efficient hardware
instructions such as lock cmpxchg that exactly meet our needs.
In addition, CPW threads skip stale pointers, i.e., whose contain-
ing objects have been freed, and remove them from PtrList (Lines
12∼14). To demonstrate that the race mentioned in §4.2.3 does not
cause failures in CPW, we consider two cases.
Case 1: Line 7 in Algorithm 2 returns true. In this case, pSweeper
always correctly skips stale pointers. In particular, no live pointer is
Figure 6: Time of check to time of neutralization race.
Figure 7: Dangling pointers can propagate to swept ones in
application threads.
missed when objFreed() returns true but the memory has been al-
located in a different application thread (due to inconsistency MAS
table seen by different cores). This is because the store instruction
must be executed after the hooked malloc() has returned. Other-
wise, there is a concurrency bug in applications, which violates our
assumptions in §2. Line 7 Algorithm 3 enforces that objFreed()
must return false when the hooked malloc() returns.
Case 2: Line 7 in Algorithm 2 returns false. The only problem
here lies in the possibility that the object where ptr is contained
can get freed and reused before Line 10 Algorithm 2. In this case,
the stale pointer will be appended to PtrList. However, this can
happen only if there is a concurrency bug in applications, which
violates our assumptions in §2.
• Step 3 (Lines 19 ∼ 25)
CPW threads now traverse object list again to free objects whose
scanflag is set and remove them from the list. In order to avoid
locks between insertion by applications and deletion by CPW, the
tail node in ObjList is delayed until more nodes have been ap-
pended.
Avoiding endless sweeping rounds. Since new objects and
pointers are created continuously by application threads, the while-
loops in the above three steps may not terminate if they are not
handled specially. To this end, CPW threads enforce that every
round of sweeping terminates at the tail nodes of the lists (Lines 8,
17, and 25) that are recorded at the beginning of the loops (Lines
3 and 10). For Step 1 and 3, this enforcement is required because
only objects that have been checked against every live pointer can
be safely freed. For Step 2, this strategy is correct and safe because
pSweeper prevents dangling pointer propagation (§4.5) and thus
newly added pointers can be deemed as already swept.
4.5 Preventing Dangling Pointer Propagation
As shown in Algorithm 5, CPW threads sweep every live pointer
only once in each round. Unfortunately, dangling pointers can
propagate to the swept ones in application threads, as illustrated in
Figure 7. Basically, pointers can propagate in three ways, assign-
ment (e.g., q = p), function arguments (e.g., func(p)), and returns
(e.g., p = getPtr()). In this section, we only describe how pointer
assignment is handled because the other two ways are essentially
also assignments.
Figure 8 presents how pSweeper handles pointer assignments. A
pointer assignment q = p is usually compiled to two instructions,