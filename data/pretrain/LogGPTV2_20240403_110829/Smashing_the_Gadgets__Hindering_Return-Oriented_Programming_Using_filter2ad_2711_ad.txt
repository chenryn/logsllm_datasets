Table III
RESULTS OF RUNNING Q [26] AND MONA [27] ON THE ORIGINAL
NON-ASLR DLLS LISTED IN TABLE II, AND THE UNMODIFIED PARTS OF
THEIR RANDOMIZED VERSIONS. IN ALL CASES, BOTH TOOLS FAILED TO
GENERATE A ROP PAYLOAD USING SOLELY NON-RANDOMIZED GADGETS.
Application/DLL
Orig.
Rand.
Q success
Mona success
Orig.
Rand.
Adobe Reader
Integard Pro
Mplayer
msvcr71.dll
mscorie.dll
mfc71u.dll
✔
✔
✔
✔
✘
✔
✘
✘
✘
✘
✘
✘
✔ (VA)
✘
✔ (VA)
✘
✘
✘
✘
✘
✘
✘
✔ (VA,VP) ✘
tools from automatically constructing reliable ROP code, this
favorable outcome does not exclude the possibility that a
functional payload could still be constructed based solely on
non-randomized gadgets, e.g., in a manual way or using an
even more sophisticated ROP compiler. However, it clearly
demonstrates that in-place code randomization signiﬁcantly
raises the bar for attackers, and makes the construction of
reliable ROP code much harder, even in an automated way.
This is reﬂected on the reduction in the number of avail-
able (non-randomized) gadgets after code randomization. Both
tools operate in two phases: gadget discovery and code com-
pilation. During the ﬁrst phase, they search for useful gadgets
and categorize them according to their functionality. Tables IV
and V show the number of useful gadgets as reported by Q
and Mona, respectively, that are available before and after
randomization. As shown by the percentage of the remaining
gadgets (last column), many gadget
types have very few
available gadgets or are eliminated completely, which makes
the construction of reliable ROP code much harder.
VI. DISCUSSION
In-place code randomization may not always randomize
a signiﬁcant part of the executable address space, and it is
hard to give a deﬁnitive answer on whether the remaining
unmodiﬁable gadgets would be sufﬁcient for constructing
useful ROP code. This depends on the code in the non-
ASLR address space of the particular vulnerable process, as
well as on the actual operations that need to be achieved
using ROP code. Note that Turing-completeness is irrelevant
for practical exploitation [26], and none of the gadget sets
used in the tested ROP payloads is Turing-complete. For this
reason, we emphasize that in-place code randomization should
be used as a mitigation technique, in the same fashion as
application armoring tools like EMET [51], and not as a
complete prevention solution.
As previous studies [2], [5], [26] have shown, though, the
feasibility of building a ROP payload is proportional to the
size of the non-ASLR code base, and reversely proportional
to the complexity of the desired functionality. Our experi-
mental evaluation shows that in all cases, the space of the
remaining useful gadgets after randomization is sufﬁciently
small to prevent the automated generation of a ROP payload.
At the same time, the tested ROP payloads are far from the
complexity of a fully blown ROP-based implementation of the
operations required for carrying out an attack, such as dumping
a malicious executable on disk and executing it. Currently, this
functionality is handled by the embedded shellcode, which in
essence allows us to view these ROP payloads as sophisticated
versions of return-to-libc. We should stress that the random-
ization coverage of our prototype implementation is a lower
bound for what would be possible using a more sophisticated
code extraction method [41], [49]. In our future work, we also
plan to relax some of the conservative assumptions that we
have made in instruction reordering and register reassignment,
using data ﬂow analysis based on constant propagation.
Given its practically zero overhead and direct applicability
on third-party executables, in-place code randomization can be
readily combined with existing techniques to improve diversity
and reduce overheads. For instance, compiler-level techniques
against ROP attacks [15], [16] increase signiﬁcantly the size
of the generated code, and also affect the runtime overhead.
Incorporating code randomization for eliminating some of the
gadgets could offer savings in code expansion and runtime
overheads. Our technique is also applicable in conjunction
with randomization methods based on code block reorder-
ing [17]–[19], to further increase randomization entropy.
the binary level
In-place code randomization at
is not
applicable for software that performs self-checksumming or
other runtime code integrity checks. Although not encountered
in the tested applications, some third-party programs may
use such checks for hindering reverse engineering. Similarly,
packed executables cannot be modiﬁed directly. However, in
most third-party applications, only the setup executable used
for software distribution is packed, and after installation all
extracted PE ﬁles are available for randomization.
VII. RELATED WORK
Almost a decade after the introduction of the return-to-libc
technique [28], the wide adoption of non-executable memory
page protections in popular OSes sparked a new interest in
more advanced forms of code-reuse attacks. The introduction
of return-oriented programming [2] and its advancements [3]–
[6], [8], [26], [33], [67]–[69] led to its adoption in real-
world attacks [10], [11]. ROP exploits are facilitated by the
lack of complete address space layout randomization in both
Linux [12], and Windows [6], which otherwise would prevent
or at least hinder [14] these attacks.
Besides address space randomization, process diversity can
also be increased by randomizing the code of each executable
segment, e.g., by permuting the order of functions or basic
blocks [17]–[19]. However, these techniques are applicable
only if the source code or the symbolic debugging information
of the application to be protected is available. Our approach
is inspired by these works, and attempts to bring the beneﬁts
of code randomization on COTS software, for which usually
no source code or debugging information is available.
Return-oriented code disrupts the normal control ﬂow of a
process by diverting its execution to (potentially unintended)
code fragments, most of which otherwise would never be tar-
gets of control transfer instructions. Enforcing the integrity of
612
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:49:51 UTC from IEEE Xplore.  Restrictions apply. 
NUMBER OF USEFUL GADGETS IDENTIFIED BY Q [26] IN THE ORIGINAL CODE SEGMENTS / IN THEIR UNMODIFIABLE PARTS AFTER IN-PLACE
RANDOMIZATION WAS APPLIED.
Table IV
Gadget Type
Reader
Integard
Mplayer
msvcr71
mscorie
mfc71u
total
(%)
Pivots
Storemem
Move
ArithmeticStore
ArithmeticLoad
JumpConsts
SwitchStack
Loadmem
LoadConst
Arithmetic
171/27
162/11
57/7
89/8
587/23
1/1
171/27
657/79
424/36
409/49
55/11
14/4
25/13
7/3
26/8
1/1
55/11
18/0
121/20
59/10
156/48
105/7
68/35
90/6
1194/40
1/1
156/48
314/129
621/138
517/66
89/18
33/6
31/12
31/4
147/24
1/1
89/18
71/36
155/23
167/41
13/5
1/1
7/3
-
-
1/1
13/5
-
14/3
8/2
65/20
69/15
62/60
16/8
549/129
384/44
250/130
233/29
290/104
2244/199
1/1
65/20
761/690
175/67
347/190
6/6
549/129
1821/934
1510/287
1507/358
(23.50)
(11.46)
(52.00)
(12.45)
(8.87)
(100.00)
(23.50)
(51.29)
(19.01)
(23.76)
control transfers [20] can effectively protect against code-reuse
attacks. Compile-time techniques also prevent the construction
of ROP code by generating machine code that does not
contain unintended instruction sequences ending with indirect
control transfer instructions, and by safeguarding any indirect
branches in the actual code using canaries or additional
indirection [15], [16]. In contrast to the above approaches,
although in-place code randomization does not completely
preclude the possibility that working ROP code can be con-
structed, it can be applied directly on third-party software
without access to source code or debugging information.
Another line of defenses are based on runtime solutions
that monitor either the frequency of ret instructions [22],
[23], or the integrity of the stack [21]. Besides the fact these
techniques are ineffective against ROP code that uses indirect
control transfer instructions other than ret, their increased
runtime overhead limits their adoption.
VIII. CONCLUSION
The increasing number of exploits against Windows appli-
cations that rely on return-oriented programming to bypass ex-
ploit mitigations such as DEP and ASLR, necessitates the de-
ployment of additional protection mechanisms that can harden
imminently vulnerable third-party applications against these
threats. Towards this goal, we have presented in-place code
randomization, a technique that offers probabilistic protection
against ROP attacks, by randomizing the code of third-party
applications using various narrow-scope code transformations.
Our approach is practical: it can be applied directly on
third-party executables without relying on debugging infor-
mation, and does not introduce any runtime overhead. At
the same time, it is effective: our experimental evaluation
using in-the-wild ROP exploits and two automated ROP code
construction toolkits shows that in-place code randomization
can thwart ROP attacks against widely used applications,
including Adobe Reader on Windows 7, and can prevent the
automated generation of ROP code resistant to randomization.
Our prototype implementation is publicly available, and as
part of our future work, we plan to improve its randomization
coverage using more advanced data ﬂow analysis methods,
and extend it to support ELF and 64-bit executables.
AVAILABILITY
Our prototype implementation is publicly available at http:
//nsl.cs.columbia.edu/projects/orp
ACKNOWLEDGEMENTS
We are grateful to the authors of Q for making it available to us,
and especially to Edward Schwartz for his assistance. We also thank
´Ulfar Erlingsson and Periklis Akritidis for their valuable feedback on
earlier versions of this paper. This work was supported by DARPA
and the US Air Force through Contracts DARPA-FA8750-10-2-0253 and
AFRL-FA8650-10-C-7024, respectively, and by the FP7-PEOPLE-2009-
IOF project MALCODE, funded by the European Commission under
Grant Agreement No. 254116. Any opinions, ﬁndings, conclusions, or
recommendations expressed herein are those of the authors, and do not
necessarily reﬂect those of the US Government, DARPA, or the Air Force.
REFERENCES
[1] M. Miller, T. Burrell, and M. Howard, “Mitigating software vulnera-
bilities,” Jul. 2011, http://www.microsoft.com/download/en/details.aspx?
displaylang=en&id=26788.
[2] H. Shacham, “The geometry of innocent ﬂesh on the bone: return-into-
libc without function calls (on the x86),” in Proceedings of the 14th ACM
conference on Computer and Communications Security (CCS), 2007.
[3] S. Checkoway, A. J. Feldman, B. Kantor, J. A. Halderman, E. W. Felten,
and H. Shacham, “Can DREs provide long-lasting security? the case of
return-oriented programming and the AVC advantage,” in Proceedings
of the 2009 conference on Electronic Voting Technology/Workshop on
Trustworthy Elections (EVT/WOTE), 2009.
[4] R. Hund, T. Holz, and F. C. Freiling, “Return-oriented rootkits: bypass-
ing kernel code integrity protection mechanisms,” in Proceedings of the
18th USENIX Security Symposium, 2009.
[5] T. Dullien, T. Kornau, and R.-P. Weinmann, “A framework for automated
the 4th
architecture-independent gadget search,” in Proceedings of
USENIX Workshop on Offensive Technologies (WOOT), 2010.
[6] D. A. D. Zovi, “Practical return-oriented programming.”
Boston, 2010.
SOURCE
[7] P. Sol´e, “Hanging on a ROPe,” http://www.immunitysec.com/downloads/
DEPLIB20 ekoparty.pdf.
[8] D. A. D. Zovi, “Mac OS X return-oriented exploitation.”
RECON,
2010.
[9] P. Vreugdenhil, “Pwn2Own 2010 Windows 7 Internet Explorer
http://vreugdenhilresearch.nl/Pwn2Ownl2010-Windows7-
8 exploit,”
InternetExplorer8.pdf.
[10] K. Baumgartner, “The ROP pack,” in Proceedings of the 20th Virus
Bulletin International Conference (VB), 2010.
[11] M. Parkour, “An overview of exploit packs (update 9) April 5 2011,”
http://contagiodump.blogspot.com/2010/06/overview-of-exploit-packs-
update.html.
[12] G. Fresi Roglia, L. Martignoni, R. Paleari, and D. Bruschi, “Surgically
returning to randomized lib(c),” in Proceedings of the 25th Annual
Computer Security Applications Conference (ACSAC), 2009.
[13] H. Li, “Understanding and exploiting Flash ActionScript vulnerabilities.”
CanSecWest, 2011.
613
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 11:49:51 UTC from IEEE Xplore.  Restrictions apply. 
[14] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D. Boneh,
“On the effectiveness of address-space randomization,” in Proceedings
of the 11th ACM conference on Computer and Communications Security
(CCS), 2004.
[15] J. Li, Z. Wang, X. Jiang, M. Grace, and S. Bahram, “Defeating return-
oriented rootkits with “return-less” kernels,” in Proceedings of the 5th
European conference on Computer Systems (EuroSys), 2010.
[16] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda, “G-Free:
defeating return-oriented programming through gadget-less binaries,”
in Proceedings of
the 26th Annual Computer Security Applications
Conference (ACSAC), 2010.
[17] S. Forrest, A. Somayaji, and D. Ackley, “Building diverse computer sys-
tems,” in Proceedings of the 6th Workshop on Hot Topics in Operating
Systems (HotOS-VI), 1997.
[18] S. Bhatkar, R. Sekar, and D. C. DuVarney, “Efﬁcient techniques for
comprehensive protection from memory error exploits,” in Proceedings
of the 14th USENIX Security Symposium, August 2005.
[19] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning, “Address space
layout permutation (ASLP): Towards ﬁne-grained randomization of
commodity software,” in Proceedings of the 22nd Annual Computer
Security Applications Conference (ACSAC), 2006.
[20] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-ﬂow
integrity,” in Proceedings of the 12th ACM conference on Computer
and Communications Security (CCS), 2005.
[21] L. Davi, A.-R. Sadeghi, and M. Winandy, “ROPdefender: A practical
to protect against return-oriented programming,” in
the 6th Symposium on Information, Computer and
protection tool
Proceedings of
Communications Security (ASIACCS), 2011.
[22] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and L. Xie, “DROP:
Detecting return-oriented programming malicious code,” in Proceedings
of the 5th International Conference on Information Systems Security
(ICISS), 2009.
[23] L. Davi, A.-R. Sadeghi, and M. Winandy, “Dynamic integrity measure-
ment and attestation: towards defense against return-oriented program-
ming attacks,” in Proceedings of the 2009 ACM workshop on Scalable
Trusted Computing (STC), 2009.
[24] G. S. Kc, A. D. Keromytis, and V. Prevelakis, “Countering code-
injection attacks with instruction-set randomization,” in Proceedings of
the 10th ACM conference on Computer and Communications Security
(CCS), 2003.
[25] E. G. Barrantes, D. H. Ackley, T. S. Palmer, D. Stefanovic, and D. D.
Zovi, “Randomized instruction set emulation to disrupt binary code
injection attacks,” in Proceedings of
the 10th ACM conference on
Computer and Communications Security (CCS), 2003.
[26] E. J. Schwartz, T. Avgerinos, and D. Brumley, “Q: Exploit hardening
made easy,” in Proceedings of the 20th USENIX Security Symposium,
2011.
[27] Corelan Team, “Mona,” http://redmine.corelan.be/projects/mona.
[28] S. Designer, “Getting around non-executable stack (and ﬁx),” http:
//seclists.org/bugtraq/1997/Aug/63.
[29] T. Newsham, “Non-exec stack,” 2000, http://seclists.org/bugtraq/2000/
May/90.
[30] Nergal, “The advanced return-into-lib(c) exploits: PaX case study,”
Phrack, vol. 11, no. 58, Dec. 2001.
[31] S. Krahmer, “x86-64 buffer overﬂow exploits and the borrowed code
chunks exploitation technique,” http://www.suse.de/∼krahmer/no-nx.
pdf.
´U. Erlingsson, “Low-level software security: Attack and defenses,”
Microsoft Research, Tech. Rep. MSR-TR-07-153, 2007, http://research.
microsoft.com/pubs/64363/tr-2007-153.pdf.
[32]
[33] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham,
and M. Winandy, “Return-oriented programming without returns,” in
Proceedings of the 17th ACM conference on Computer and Communi-
cations Security (CCS), 2010.
[34] F. B. Cohen, “Operating system protection through program evolution,”
Computers and Security, vol. 12, pp. 565–584, Oct. 1993.
[35] P. Sz¨or, The Art of Computer Virus Research and Defense. Addison-
Wesley Professional, February 2005.
[36] E. Bhatkar, D. C. Duvarney, and R. Sekar, “Address obfuscation: an
efﬁcient approach to combat a broad range of memory error exploits,”
in In Proceedings of the 12th USENIX Security Symposium, 2003.
[37] “/ORDER (put functions in order),” http://msdn.microsoft.com/en-us/
library/00kh39zz.aspx.
[38] “Syzygy - proﬁle guided, post-link executable reordering,” http://code.
google.com/p/sawbuck/wiki/SyzygyDesign.
[39] “Proﬁle-guided optimizations,” http://msdn.microsoft.com/en-us/library/
e7k32f4k.aspx.
[40] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna, “Static disassembly
of obfuscated binaries,” in Proceedings of the 13th USENIX Security
Symposium, 2004.
[41] M. Smithson, K. Anand, A. Kotha, K. Elwazeer, N. Giles, and
R. Barua, “Binary rewriting without relocation information,” Univer-
sity of Maryland, Tech. Rep., 2010, http://www.ece.umd.edu/∼barua/
without- relocation-technical-report10.pdf.
[42] P. Saxena, R. Sekar, and V. Puranik, “Efﬁcient ﬁne-grained binary
instrumentation with applications to taint-tracking,” in Proceedings of
the 6th annual IEEE/ACM international symposium on Code Generation
and Optimization (CGO), 2008.
[43] Skape, “Locreate: An anagram for relocate,” Uninformed, vol. 6, 2007.
[44] M. Pietrek, “An in-depth look into the Win32 portable executable ﬁle
format, part 2,” http://msdn.microsoft.com/en-us/magazine/cc301808.
aspx.
[45] I. Guilfanov, “Jump tables,” http://www.hexblog.com/?p=68.
[46] ——, “Decompilers and beyond.” Black Hat USA, 2008.
[47] Hex-Rays, “IDA Pro Disassembler,” http://www.hex-rays.com/idapro/.
[48] X. Hu, T.-c. Chiueh, and K. G. Shin, “Large-scale malware indexing
using function-call graphs,” in Proceedings of the 16th ACM conference
on Computer and Communications Security (CCS), 2009.
[49] S. Nanda, W. Li, L.-C. Lam, and T.-c. Chiueh, “Bird: Binary interpre-
tation using runtime disassembly,” in Proceedings of the International
Symposium on Code Generation and Optimization (CGO), 2006.
[50] L. C. Harris and B. P. Miller, “Practical analysis of stripped binary code,”
SIGARCH Comput. Archit. News, vol. 33, pp. 63–68, December 2005.
[51] Microsoft, “Enhanced Mitigation Experience Toolkit v2.1,” http://www.
microsoft.com/download/en/details.aspx?id=1677.