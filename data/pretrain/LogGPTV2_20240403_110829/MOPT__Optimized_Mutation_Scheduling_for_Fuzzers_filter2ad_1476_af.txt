the Internet. For example, we download mp3 ﬁles from the
music download websites. Then, we split the input ﬁles (of
format PDF and mp3) into a reasonable size if they are too
large. Further, we utilize AFL-cmin [16] to evaluate each
input ﬁle’s coverage, and remove the inputs that have redun-
dant coverage.
In the remaining input ﬁles, we randomly
select 20 (i.e., for the second group) or 200 (i.e., for the third
group) seeds for the corresponding objective program.
Evaluation metrics. We measure the widely adopted met-
rics, i.e., number of unique crashes and number of unique
1960    28th USENIX Security Symposium
USENIX Association
Figure 10: The boxplot generated by the number of unique crashes from 30 trials, which are found by AFL, MOPT-AFL-ever,
Angora and VUzzer on ﬁve programs when fed with an empty seed, with 20 well-formed seed inputs and with 200 well-formed
seed inputs. Y-axis: the number of unique crashes discovered in 24 hours.
bugs, to compare the performance of each fuzzer. To ob-
tain the unique bugs, we recompile objective programs with
the AddressSanitizer [24] instrumentation, and reevaluate the
programs with the discovered crash inputs. If the top three
source code locations of the stack trace provided by Address-
Sanitizer are unique, we consider the corresponding crash
input triggers a unique bug of the objective program. This is
a common way to ﬁnd unique bugs in practice and has been
used to calculate the stack hashing in [25].
Note that we do the statistical tests and use the p value
[30] to measure the performance of the three fuzzers (sug-
gested by [25]). In particular, p1 is the p value yielded from
the difference between the performance of MOPT-AFL-ever
and AFL, p2 is the p value yielded from the difference be-
tween the performance of MOPT-AFL-ever and Angora, and
p3 is the p value generated from the difference between the
performance of MOPT-AFL-ever and VUzzer.
We further validate the reliability of our p value analy-
sis leveraging the Benjamini-Hochberg (BH) procedure [31].
For the details, please refer to the technical report [20].
Results and analysis. The number of unique crashes and
unique bugs are shown in Fig. 10 and Fig. 11, respectively.
From the results, we can learn the following facts.
• As shown in Fig. 10, among all the 13 evaluation set-
tings, MOPT-AFL-ever discovers more unique crashes than
the other fuzzers in 11 evaluations.
In these 11 evalua-
tions, p1, p2 and p3 are smaller than 10−5, meaning that
the distribution of the number of unique crashes discovered
by MOPT-AFL-ever and the other fuzzers is widely differ-
ent, which demonstrates a signiﬁcant statistical evidence for
MOPT’s improvement. Therefore, according to the statisti-
cal results of 30 trials, MOPT-AFL-ever performs better than
AFL, Angora and VUzzer in most cases.
• As for the number of discovered unique bugs, MOPT-
AFL-ever still performs signiﬁcantly better than AFL, An-
gora and VUzzer in most cases. For instance, the mini-
mum number of unique bugs discovered by MOPT-AFL-
ever among the 30 runs is more than the maximum number of
that discovered by other fuzzers when fuzzing objdump and
jead with 20 ﬁles as the initial seed set. Further, we ﬁnd
that both Angora and VUzzer discover more unique crashes
but fewer unique bugs than MOPT-AFL-ever when fuzzing
mp3gain with the 20 ﬁles. This indicates that their dedupli-
cation strategies do not work well in this evaluation.
• When using an empty seed as the initial seed set to
fuzz pdfimages, all the fuzzers cannot discover any unique
crash. The reason is that PDF ﬁles have complex structures.
The test cases mutated from an empty seed are hard to gener-
ate such complex structures, which leads to the poor fuzzing
performance. This reminds us the motivation of generation-
based fuzzers and shows that: although fuzzers like AFL
may perform better with an empty seed, they cannot discover
more crashes on the programs that require complex input for-
mats when using an empty seed.
6.2 Stepwise Analysis of MOPT Main Frame-
work and Pacemaker Fuzzing Mode
To validate the effectiveness of MOPT main framework
and the pacemaker fuzzing mode, we implement MOPT-
AFL-off (that is based on MOPT-AFL-ever while disabling
the pacemaker fuzzing mode) and AFL-ever (that is based on
AFL and only implements the pacemaker fuzzing mode). We
re-evaluate AFL, MOPT-AFL-off, AFL-ever and MOPT-
AFL-ever on pdfimages, w3m, objdump and infotocap for
240 hours. The results are shown in Table 8.
MOPT Main Framework (without Pacemaker Fuzzing
Mode). We can learn from Table 8 that MOPT-AFL-off dis-
covers more crashes than AFL. For instance, on w3m, AFL
cannot discover any crash in 240 hours, while MOPT-AFL-
off discovers 74 unique crashes. Note that if without the
pacemaker fuzzing mode, MOPT-AFL-off uses the havoc
stage less frequently and iterates the selection distribution
USENIX Association
28th USENIX Security Symposium    1961
(a) mp3gain-empty seed0100200300Crashes foundp1<10-10 p2=7*10-10 p3<10-10MOPT-AFL-ever AFLAngora VUzzer(b) pdfimages-empty seed-2024Crashes foundp1 N.A.p2 N.A.p3 N.A.MOPT-AFL-ever AFLAngora VUzzer(c) objdump-empty seed0100200300Crashes foundp1<10-10   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(d) jhead-empty seed0204060Crashes foundp1=2.3*10-6 p2=4.6*10-7 p3=6.5*10-8MOPT-AFL-ever AFLAngora VUzzer(e) infotocap-empty seed0100200300400Crashes foundp1<10-10   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(f) mp3gain-20 files05001,0001,5002,0002,500Crashes foundp1<10-10  p2=4.1*10-3 p3=1.2*10-2MOPT-AFL-ever AFLAngora VUzzer(g) pdfimages-20 files0100200300400Crashes foundp1<10-10 p2<10-10    p3<10-10MOPT-AFL-ever AFLAngora VUzzer(h) objdump-20 files050100150200250Crashes foundp1<10-10   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(i) jhead-20 files050100150200250Crashes foundp1<10-10   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(j) infotocap-20 files0200400600Crashes foundp1=2.1*10-8   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(k) mp3gain-200 files05001,0001,500Crashes foundp1<10-10p3=2.0*10-8MOPT-AFL-ever AFLVUzzer(l) pdfimages-200 files0100200300400Crashes foundp1<10-10p3<10-10MOPT-AFL-ever AFLVUzzer(m) objdump-200 files020406080Crashes foundp1<10-10p3<10-10MOPT-AFL-ever AFLVUzzerFigure 11: The boxplot generated by the number of unique bugs from 30 trials, which are found by AFL, MOPT-AFL-ever,
Angora and VUzzer on ﬁve programs when fed with an empty seed, with 20 well-formed seed inputs and with 200 well-formed
seed inputs. Y-axis: the number of unique bugs discovered in 24 hours.
Table 8: The results of AFL, MOPT-AFL-off, AFL-ever and MOPT-AFL-ever on 4 target programs.
MOPT-AFL-ever
MOPT-AFL-off
AFL-ever
AFL
Program
Unique crashes
Unique paths
Unique crashes
Unique paths
Unique crashes
Unique paths
Unique crashes
Unique paths
pdﬁmages
w3m
objdump
infotocap
total
16
0
5
86
107
10,027
3,250
11,163
3,179
27,619
18
74
77
97
266
12,129
3,835
15,032
4,112
35,108
43
44
170
436
693
9,906
5,007
23,392
6,808
45,113
322
138
239
687
1,386
24,306
5,227
24,918
7,109
61,560
more slowly, which limits the performance of the MOPT
main framework. Comparing MOPT-AFL-ever with AFL-
ever, we can learn that MOPT-AFL-ever has a better capa-
bility to explore unique crashes than AFL-ever. As for the
coverage, MOPT-AFL-off discovers more unique paths than
AFL, and the same situation applies for MOPT-AFL-ever
and AFL-ever. As a conclusion, both two comparison groups
demonstrate that the MOPT scheme without the pacemaker
fuzzing mode can also improve the performance of AFL on
exploring unique crashes and paths, but a better performance
can be achieved if integrating the pacemaker fuzzing mode.
For discovering unique
crashes, AFL-ever discovers 165 more unique crashes than
AFL on objdump. Additionally, MOPT-AFL-ever ﬁnds
1,120 more unique crashes than MOPT-AFL-off on the 4
programs in total. As for the coverage, AFL-ever is better
than AFL on w3m, objdump and infotocap. MOPT-AFL-
ever ﬁnds nearly twice as many unique paths as MOPT-AFL-
off on all the programs except w3m. As a conclusion, the ex-
periments demonstrate that the pacemaker fuzzing mode can
help fuzzers ﬁnd much more unique crashes and paths.
Pacemaker Fuzzing Mode.
In summary, both the MOPT main framework and pace-
maker fuzzing mode can improve the fuzzing performance
signiﬁcantly, while the combination of both parts would re-
sult in an even better performance (corresponding to MOPT-
AFL-ever). To further clarify this point, we use the num-
ber of unique crashes discovered by MOPT-AFL-ever as the
baseline and observe the approximate fuzzing performance
Figure 12: The ratio of the unique crashes discovered by 4
fuzzers, with MOPT-AFL-ever as the baseline.
of each part. The results are shown in Fig. 12.
From the results,
the improvement of the pacemaker
fuzzing mode is relatively limited for fuzzing; however,
without the pacemaker fuzzing mode, MOPT cannot con-
verge fast to the proper selection probability distribution,
which on the other hand limits the fuzzing performance ei-
ther. Nevertheless, the performance can be signiﬁcantly im-
proved if we combine AFL with the complete MOPT scheme.
6.3
Iteration Analysis of Selection Probability
To demonstrate the effectiveness of MOPT in obtaining
the proper selection probability for the mutation operators,
we record the probability of bitflip 1/1, arith 8/8 and
interest 16/8 obtained by the particles in one swarm
when using MOPT-AFL-ever to fuzz w3m and pdfimages.
The results are shown in Fig. 13, from which we have the
following observations.
• Different mutation operators have different proper se-
lection probabilities on each program. Moreover, the proper
1962    28th USENIX Security Symposium
USENIX Association
(a) mp3gain-empty seed05101520Bugs foundp1<10-10   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(b) pdfimages-empty seed-2024Bugs foundp1  N.A.p2  N.A.p3  N.A.MOPT-AFL-ever AFLAngora VUzzer(c) objdump-empty seed020406080Bugs foundp1<10-10   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(d) jhead-empty seed02468Bugs foundp1=2.3*10-6 p2=4.9*10-7 p3=6.3*10-8MOPT-AFL-ever AFLAngora VUzzer(e) infotocap-empty seed0246Bugs foundp1=4.2*10-8   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(f) mp3gain-20 files05101520Bugs foundp1<10-10   p2<10-10p3<10-10MOPT-AFL-ever AFLAngora VUzzer(g) pdfimages-20 files04812Bugs foundp1=2.6*10-2 p2=1.3*10-4   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(h) objdump-20 files020406080Bugs foundp1=3.3*10-5 p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(i) jhead-20 files0102030Bugs foundp1<10-10   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(j) infotocap-20 files02468Bugs foundp1=2.3*10-8   p2<10-10   p3<10-10MOPT-AFL-ever AFLAngora VUzzer(k) mp3gain-200 files05101520Bugs foundp1<10-10p3<10-10MOPT-AFL-ever AFLVUzzer(l) pdfimages-200 files02468Bugs foundp1=5.3*10-2p3<10-10MOPT-AFL-ever AFLVUzzer(m) objdump-200 files05101520Bugs foundp1<10-10p3<10-10MOPT-AFL-ever AFLVUzzerpdfimagesw3minfotocap00.20.40.60.81AFLMOPT-AFL-offAFL-everMOPT-AFL-everobjdumptest case is different, and thus the test cases with slow ex-
ecution speed will take more time consumption. When the
fuzzing queue of AFL contains slow test cases, it will gener-
ate a number of test cases mutated from the slow test cases in
the deterministic stage, which may also be executed slowly
with a high probability and decrease AFL’s execution efﬁ-
ciency. As for MOPT-AFL fuzzers, they will generate much
fewer mutated cases from the slow test cases since they tend
to disable the deterministic stage when it is not efﬁcient.
Therefore, MOPT-AFL fuzzers will spend much less time
on the slow test cases, followed by yielding a high execution
efﬁciency.
Figure 13: The probability when using MOPT-AFL-ever to fuzz w3m and pdfimages. X-axis: time (over 240 hours). Y-axis:
the selection probability of the corresponding mutation operator. Green line: xnow. Red line: Gbest. Blue line: Lbest.
selection probability of one mutation operator varies with the
objective programs. The results are consistent with our mo-
tivation that it is desired to dynamically determine the selec-
tion probability of operators during the fuzzing process.
• Gbest and Lbest quickly converge to the proper values.
For instance, it only takes an hour for Gbest and Lbest to con-
verge to the proper values when fuzzing w3m. When the
proper values of Gbest and Lbest are the same, xnow will con-
verge to this value and oscillate around. Otherwise, xnow will
oscillate between Gbest and Lbest to explore whether there is
a better selection probability.
• We can learn from Fig. 13 that MOPT iterates slowly at
ﬁrst and iterates fast later on pdfimages. The reasons are
that (1) the deterministic stage is effective at ﬁnding interest-
ing test cases in the early fuzzing time; (2) the fuzzer spends
a long time on the deterministic stage of one test case when
fuzzing pdfimages. When the efﬁciency of the determin-
istic stage decreases, i.e., it cannot discover any new crash
or path for a long time, MOPT-AFL-ever enters the pace-
maker fuzzing mode and will not use the deterministic stage
again. Then the selection probability converges quickly and
MOPT iterates fast. The results demonstrate that the design
of the pacemaker fuzzing mode is reasonable and meaning-
ful, which exploits the deterministic stage at ﬁrst and avoids
repeating its high computation when it is inefﬁcient.
6.5 Long Term Parallel Experiments
We run the long term parallel experiments in order to
verify the performance of MOPT-AFL in parallel for a
long time. In each experiment, AFL, MOPT-AFL-tmp and
MOPT-AFL-ever, are employed to fuzz pdfimages in paral-
lel. Each experiment has three instances denoted by Fuzzer1,
Fuzzer2 and Fuzzer3, with 20 carefully selected PDF ﬁles ﬁl-
tered from AFL-cmin [16] as the initial seed set. According
to the parallel design of AFL and MOPT-AFL, the Fuzzer1
of AFL, MOPT-AFL-tmp and MOPT-AFL-ever will still
perform the deterministic stage, while their Fuzzer2 and
Fuzzer3 will disable it in the parallel experiments. Each
experiment runs on a virtual machine conﬁgured with four
CPU cores of 2.40Ghz E5-2640 V4, 4.5 GB RAM and the
OS of 64-bit Ubuntu 16.04 LTS. The total CPU time of each
experiment exceeds 70 days till the writing of this report
and AFL, MOPT-AFL-tmp and MOPT-AFL-ever discover
1,778, 2,907 and 2,702 unique crashes, respectively.
The results are shown in Table 10, from which we can
see that AFL’s performance of discovering unique crashes
is obviously inferior to MOPT-AFL’s. Fuzzer1 of AFL en-
ables the deterministic stage all the time and only discov-
ers 11 unique crashes in more than 23 days, demonstrating
the inefﬁciency of the deterministic stage. What’s more, the
performance of Fuzzer1 of MOPT-AFL-tmp is much better
than that of MOPT-AFL-ever and AFL. We conjecture the
reasons as follows. Since PDF ﬁles require the strict ﬁle for-
mat, there are many unique execution paths in pdfimages
that contain strict magic byte checks. The operators, e.g.,
bitflip 1/1, in the deterministic stage are better at gen-
6.4 Overhead Analysis
In order to compare the execution efﬁciency of each fuzzer
in Section 5.3, we collect the total execution times of each
fuzzer, which are the times a fuzzer uses the generated test
cases to test an objective program, within 240 hours. The
results are shown in Table 9, from which we learn the fol-
lowing conclusions.
Although MOPT fuzzers take partial computing power to
improve the mutation scheduler, the execution efﬁciency of
MOPT-AFL-tmp and MOPT-AFL-ever is still comparable
with AFL on most programs. In many cases, although the
MOPT-AFL fuzzers test the objective programs for fewer
times, they ﬁnd much more crashes and paths than AFL.
Interestingly, MOPT-AFL can execute the tests faster than
AFL on several programs. Moreover, the MOPT-AFL yields
a better average execution efﬁciency on the 13 programs. We
analyze the reasons as follows. The execution speed of each
USENIX Association
28th USENIX Security Symposium    1963
80160200240120 0.050.0550.060.0650.07040bitflip 1/1 (w3m)80160200240120 0.030.040.050.060.07040arith 8/8 (w3m)80160200240120 0.030.040.050.060.07040interest 16/8 (w3m)801602002401200.0450.0550.0650.0750.0850.095040bitflip 1/1 (pdfimages)4016020024012000.020.040.060.080.09080arith 8/8 (pdfimages)80120160200240interest 16/8 (pdfimages)0.0350.0550.0750.0950.115040Table 9: The total execution times and executions per second of AFL, MOPT-AFL-tmp and MOPT-AFL-ever.
Program
mp42aac
exiv2
mp3gain
tiff2bw
pdﬁmages
sam2p
avconv
w3m
objdump
jhead
mpg321
infotocap
podofopdﬁnfo
average
AFL
Total execution
times
127.1M
35.1M
182.2M
906.7M
91.7M
42.6M
48.6M
104.4M
383.7M
418.5M
119.7M
218.1M
379.6M
254.8M
Executions
per second
Total execution
times
MOPT-AFL-tmp
Executions
per second
147.12
40.58
210.90
1,049.43
106.17
49.34
56.27
120.78
444.13
484.41
138.52
252.41
439.37
294.95
126.8M
27.6M
117.2M
613.2M
88.8M
52.3M
43.3M
123.2M
436.7M
1,372.6M
158.1M
157.1M
411.3M
310.7M
146.71
31.89
135.60
709.74
102.80
60.58
50.08
142.64
505.42
1,588.63
182.94
181.88
476.05