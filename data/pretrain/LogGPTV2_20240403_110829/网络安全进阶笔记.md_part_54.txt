（2）然后，加密c=memodn：脱密m=cdmodn。其中将加密密钥e和模数n公开，将
私钥d保密，丢弃p和q。在A与B进行通信的过程中，如果第三方进行窃听，将获得密文c，
和公钥e、n，为了得到明文，他将是非常困难并且是不现实的。
3.RSA的安全性及其应用的注意事项
RSA的基础是数论的欧拉定理，它的安全性依赖于大数的因数（sqrt（In（n）Inln（n)).RSA的
发明者Rivest、Shamir和Adleman建议取p和q为100位以上的十进制数，这样，n为200位
的十进制数。按每秒109次运算的高速计算机也要计算106年。估计对200位十进制数的因数
分解，在上亿次的计算机上要进行55万年。
RSA的安全性完全依赖于分解大数的难度，这从技术上来说是不正确的，这只是一种推论。
从数学上从没有证明过需要分解n才能从c和e中计算出m。不过，用一种完全不同的方法来
对RSA进行密码分析还是一种想象，如果这种新方法能让密码分析者推算出d，它也可以作为
分解大数的一种新方法。尽管如此，目前根本没有必要过于担忧。
也可以通过猜测（p-1)q-1）的值来攻击RSA，但这种攻击没有分解n容易。
另外，大多数用于计算大素数p和q的算法都是有概率的，假如p或q不是素数，就不能
得到正确的结果。还好，我们可以首先找出这件事发生的尽可能小的概率。如果它不是素数，
255
---
## Page 264
网络安全进阶笔记
就意味着加密和脱密均不能正确地工作，马上就可以放弃它，基于可信度的素数检测法得到的
素数在绝大多数的情况下都是可靠的，没有必要因废食。
基于安全性考虑，一般在应用RSA时，必须做到以下几点：
绝对不要对一个陌生人提交给的随机消息进行签名。
不要在一组用户间共享n
。
加密之前要用随机值填充消息，以确保m和n的大小一样。
·：目前，129位十进制数字的模数是能够分解的临界数，因此，n应该大于这个数。
4.RSA的速度
由于RSA中大量用到大数的模幂运算，在现有的计算能力上是很费时的，尽管应用中国
剩余定理和Montgomery算法可以大大地提高效率，但是RSA比起DES来，速度还是相差很
远。在硬件实现时，RSA比DES慢大约1000倍。最快的具有512位模数的VLSI硬件实现吞
吐量为64kbps。但也有一些实现1024位RSA的加密芯片，最近设计的512位模数的芯片可达
到1Mbps。在智能卡中已大量实现了RSA，这些实现都比较慢。目前，国内只有中兴生产出了
模幂运算的芯片，该芯片在1024位的RSA应用中，签名速度可达到66次每秒。软件实现时，
RSA比DES慢大约100倍。
5.5.3精彩案例：一个RSA算法实现的演示
下面介绍一个基本的混合密码系统。这个系统产生RSA密钥对的速度非常快，一般在3
秒以内，产生后，用户可以将密钥对导出到文本文件。下面我们来看看这个教件的实现过程。
主界面如图5.41所示，
PR
WR
图5.41RSA算法的主界面
256
---
## Page 265
第5章趣解加密与解密
密钥对产生界面如图5.42所示，其中包括RSA算法的相关参数，如p、q等。
PTRAERH
产（100)
严生（100)
生
产宝E
注意：为了银证最大的使全性，建家物s，的质相间
C
图5.42产生RSA密钥对
框如图5.43所示。
区
1加或功用时移。
图5.43使用RSA算法加密后的提示
5.6Hash算法基础知识
在电子商务应用中，最常见的是管理用户的账户，尽管有些应用服务器提供了相应的基本
组件，但很多应用开发者为了设计和管理的方便，还是喜欢采用Access、SQLServer等数据库
来管理用户，比较常见的微法是用户的密码往往使用明文或简单的变换后直接保存在数据库
中。比如使用很广泛的动网论坛（http:/www.aspsky.net）)的较低版本就是采用了这种做法，这些
用户的密码对软件开发者或系统管理员来说毫无保密性可言，如果恶意攻击者获取数据库文件
后，可以轻面易举地破解。
5.6.1Hash算法简介
Hash技术也称为杂淡（哈希、散列）技术，这是一个简单的不可逆过程。Hash技术原来是
用于计算机中作索引的，但Hash算法在保证文件的完整性和不可改性上也有很好的用途，
257
---
## Page 266
网络安全进阶笔记
般用法是明文后加一段由明文Hash面成的密文，由于Hash过程需要一个密钥，虽然明文修改
很容易，但要修改Hash后的密文就不那么容易了，由此来保证文件的完整性和不可改性。
Hash（哈希）函数提供了这样一种计算过程：输入一个长度不固定的字符串，返回一串定长
度的字符串，又称Hash值。单向Hash函数用于产生信息摘要。Hash函数主要可以解决以下
两个间题：在某一特定的时间内，无法查找经Hash操作后生成特定Hash值的原报文：也无法
查找两个经Hash操作后生成相同Hash值的不同报文。这样在数字签名中就可以解决验证签名
和用户身份验证、不可抵赖性的问题。
Hash算法主要有SHA、RIPEMD-160、MD2.MD4.MD5等。下面我们来讲解比较典型的
MD5算法。
5.6.2MD5算法的基础知识
Laboratory for Computer Science和 RSA Data Security Inc 的 Ronald L.Rivest 开发出来，经MD2.
MD3和MD4发展而米。它的作用是让大容量信息在用数字签名软件签署私人密钥前被“压缩”
成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。不管是MD2.MD4
还是MD5，它们都需要获得一个随机长度的信息并产生一个128位的信息摘要，虽然这些算
法的结构或多或少有些相似，但MD2的设计与MD4和MD5完全不同，那是因为MD2是为8
位机器做过设计优化的，面MD4和MD5却是面向32位的电脑。这3个算法和C语言源代码
在InternetRFCs1321中有详细的描述(htp://www.ietforg/rfe/rfc1321.txt)，这是一份最权威的文
档，由RonaldL.Rivest在1992年8月向IEFT提交。
Rivest在1989年开发出MD2算法。在这个算法中，首先对信息进行数据补位，使信息的
字节长度是16的倍数。然后，以一个16位的检验和追加到信息末尾。并且根据这个新产生的
信息计算出散列值。后来，Rogier和Chauvaud发现如果忽略了检验和将产生MD2冲突。MD2
算法的加密后结果是唯一的—既没有重复。
为了加强算法的安全性，Rivest在1990年又开发出MD4算法。MD4算法同样需要填补
信息以确保信息的字节长度加上448后能被512整除（信息字节长度mod512=448）。然后，
个以64位二进制表示的信息的最初长度被添加进来。信息被处理成512位Damg？rd/Merkle选
代结构的区块，面且每个区块要通过3个不同步骤的处理，DenBoer和Bossclaers以及其他人
很快地发现了攻击MD4版本中第一步和第三步的漏洞。Dobbertin向大家演示了如何利用一部
普通的个人电脑在儿分钟内找到MD4完整版本中的冲突（这个冲突实际上是一种漏洞，它将导
致对不同的内容进行加密却可能得到相同的加密后结果）。毫无疑间，MD4就此被淘汰掉了。
1991年，Rivest开发出技术上更为趋近成熟的MD5算法。MD5比MD4更为安全。这个
大小和填充的必要条件与MD4完全相同.DenBoer和Bosselaers曾发现MD5算法中的假冲突
(Pseudo-Collisions），但除此之外就没有其他被发现的加密后结果了。
MD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符
串变换算法，换句话说就是，即使黑客看到源程序和算法描述，也无法将一个MD5的值变换
回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，其功能类似不存在反函
数的数学函数。
258
---
## Page 267
第5章趣解加密与解密
关于MD5算法的测试，有这样一个故事。1994年，两位科学家VanOorschot和 Wiener
曾经考虑过一个在散列中暴力搜寻冲突的函数（Brute-ForceHashFunction），而且他们猜测一个
被设计专门用来搜索MD5冲突的机器（这台机器在1994年的制造成本大约是一百万美元）可以
平均每24天就找到一个冲突。但单从1991年到2001年这10年间，竞没有出现替代MD5算
法的MD6或被叫做其他什么名字的新算法这一点，我们就可以看出这个瑕疣并没有太多地影
响MD5的安全性。上面所有这些都不足以成为MD5在实际应用中的问题。并且，由于MD5
算法的使用是不需要支付任何版权费用的，所以在一般的情况下（非绝密应用领域。但即便是
应用在绝密领域内，MD5也不失为一种非常优秀的中间技术），MD5怎么都应该算得上是非常
安全的了。
5.6.3MD5算法实现过程描述
对MD5算法简要的叙述可以是：MD5以512位分组来处理输入的信息，且每一分组又被
划分为16个32位子分组，经过了一系列的处理后，算法的输出由4个32位分组组成，将这4
个32位分组级联后将生成一个128位散列值。在MD5算法中，首先需要对信息进行填充，使
其字节长度对512求余的结果等于448。因此，信息的字节长度（BitsLength）将被扩展至
N*512+448，即N*64+56个字节（Bytes），N为一个正整数。填充的方法如下，在信息的后面填
充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。然后，在这个结果后
面附加一个以64位二进制表示的填充前信息长度。经过这两步的处理，现在的信息字节长度
-N*512+448+64=(N+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中
对信息长度的要求。
MD5中有4个32位被称作链接变量（ChainingVariable）的整数参数，他们分别为
A0x01234567、B=0x89abedef、C=0xfedcba98、D=0x76543210.
关于算法的步骤说明如下。
(1)补位。
MD5算法是对输入的数据进行补位，使得数据位长度LEN对512求余的结果是448。即
数据扩展至K*512+448位。即K*64+56个字节，K为整数。具体补位操作：补一个1，然后
补0至满足上述要求。
(2）补数据长度。
用一个64位的数字表示数据的原始长度B，把B用两个32位数表示。这时，数据就被填
补成长度为512位的倍数。
（3）初始化MD5参数。
4个32位整数（A、B、C、D）用来计算信息摘要，初始化使用的是十六进制表示的数字：
●A=0X01234567
B=0X89abcdef
C=0Xfedcba98
D0X76543210
（4）处理位操作函数。
X、Y、Z为32位整数：
250
---
## Page 268
网络安全进阶笔记
F(X, Y,Z) =X& Y|NOT(X)& Z
G(X, Y,Z)=X&Z|Y & not(Z)
H(X, Y,Z) = X xor Y xor Z
I(X, Y,Z) = Y xor (X |not(Z)
（5）主要变换过程。
使用常数组T[164]，T为32位整数，用16进制表示，数据用16个32位的整数数组
MD表示。具体过程如下：
·处理数据原文·
Fori=0toN/16-1do
/*每一次，把数据原文存放在16个元素的数组x中*/
Porj-0to15do
Setx[5] to M[i*16+j]
end/结束对J的循环
/Save AasAA.Bas BB.Cas CC.and Das DD*/
AA=A
=
CC-C
DD-D
第1轮·
以[abcdk8i]表示如下操作
.（0>（-[x]x-(Doqa））+q=∞
/*Do the following16operations*/
[ABCD071][DABC1122]（CDAB2173][BCDA3224]
第2轮*/
/以[abcdksi]表示如下操作