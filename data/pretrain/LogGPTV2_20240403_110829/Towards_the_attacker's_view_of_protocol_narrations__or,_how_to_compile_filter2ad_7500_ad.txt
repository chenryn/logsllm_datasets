only ground substitutions and thus σ =X
E θ. Consider now
(cid:126)K(tr) ↓ts= (cid:126)K(tr0) ↓ts= T and (cid:126)K(tr) ↓subs= σ =X
E θ ≈E,T
(cid:126)K(tr0) ↓subs, we have tr ≈E tr0 and thus T R0 (cid:32)E tr. The
reverse direction can be shown in a similar way.
(“Only if” part) We will show that if (cid:126)S contains free vari-
able(s), then the ideal implementation does not exist. The
main reason is that, when an ideal semantics contains free
variable(s), it is impossible to use even an inﬁnite set of
equality and/or inequality checks to establish operational
equivalence.
For equality check, we note that constraints are implied
by operational equivalence σ0 ≈E,T σ. They, however, do
not suﬃce to characterize operational equivalence. In other
words, we cannot base operational equivalence on a possibly
inﬁnite set of equations. Here is an example to show why.
Let T = {Nb, x} and σ0 = [{Nb}Kas /x], and suppose that
σ0 ≈Edy ,T σ. It is clear that there is no constraint of (cid:104)T, σ0(cid:105).
However, it does not follow that σ0 ≈Edy ,T σ holds for an
arbitrary substitution σ. For instance, by letting σ = [Nc ·
Nc/x], we get fst(x)σ =Edy snd(x)σ and fst(x)σ0 (cid:54)=Edy
snd(x)σ0. So, σ0 (cid:54)≈Edy σ.
Incorporating inequality checks may not help either. As
an example, let us we consider a substitution σ that satis-
ﬁes σ ≈Edy ,{Na,K+
a ,x} [Nb/x]. To establish the operational
equivalence, we have to check xσ (cid:54)=Edy tσ for every term t
such that {Na, K +
a , x} (cid:96) t.
5.2 Coarse and Prudent Implementations
is a protocol implementation P such that (cid:126)S ⊆E P.
A coarse implementation of an ideal protocol semantics (cid:126)S
Deﬁnition 5.4 (Prudent Implementation). Given an ideal
protocol semantics (cid:126)S, we deﬁne a prudent implementation
of (cid:126)S as a protocol implementation P such that
(i). (cid:126)S ⊆E P;
(ii). P does not contain any inequality check event;
(iii). there does not exist an implementation P(cid:48) that satis-
ﬁes (i), (ii), and P(cid:48) ⊂E P.
Making Checks Explicit. As we have seen, the constraint
base maximizes the chance to check non-trivial equalities im-
plied by a protocol narration. It can be used to construct
check events in strands. Suppose that C is a constraint base
of markup term set (cid:126)T , which models a principal’s knowledge
after completing a protocol. Then, whenever possible, the
principal should check each constraint (u, v) in a constraint
base and abort upon constraint violation (i.e., uσ (cid:54)=E vσ).
Note that a principal might not be able to check those con-
strains all at once. Let (cid:126)Ti = (cid:104)Ki, σi(cid:105) be a principal’s knowl-
edge after the i-th step of a protocol. Then, he can check a
constraint (u, v) whenever Ki (cid:96) {u, v}.
For example, at step 2 of the ASW protocol, Alice is able
to check constraint (u1, u2) but not (u3, u4), which becomes
checkable only after she receives the last message. So, the
strand of role A becomes:
b , K
A[M, A, B, Na, x2, x4]
a , Na},
(cid:104){M, A, B, K +
−
a , K +
+ {K +
a · K +
b · M · hash(Na)}K
, −x2,
−
a
b )) = {K +
a · K +
check(fst(pdec(x2, K +
+ Na, −x4, check(snd(pdec(x2, K +
b · M · hash(Na)}K
b )) = hash(x4))(cid:105)
),
−
a
Interpreting Outgoing Messages. The above example
of the ASW protocol is too restrictive, because both terms
in the send events are deducible from the principal’s initial
knowledge and thus avoid dealing with outgoing messages,
which is not always the case. For instance, the third message
(i.e., M · {Na · Kab}Kas · {Nb · Kab}Kbs ) in the Otway-Reese
protocol, which contains nonces generated by A and B, is
obviously not deducible from S. Consequently, we need to
be clear on the interpretation of outgoing messages as well
when specifying the implementation.
Algorithm 2
Derive-Prudent-Implementation
a set of narrative traces T R0, equational theory E
Input:
Output: a protocol implementation P
(cid:126)S ← ∅
1:
for each narrative trace tr0 ∈ T R0
2:
3:
obtain a constraint base C of (cid:126)K(tr0) (under E)
/* construct an implementation strand (cid:126)p */
(cid:126)p ← (cid:104)tr0[0](cid:105)
for i = 1 to length(tr0)
by the incoming message */
/* ﬁnd all new constraints that are enabled
if tr0[i] = −t for some term t then
append strand (cid:126)p with node −xi
for each (u, v) ∈ C such that K((cid:126)p) (cid:96) {u, v}
and Kl−1((cid:126)p) (cid:48) {u, v} where l = length((cid:126)p) do
append strand (cid:126)p with node check(u, v)
/* choose an arbitrary recipe as an interpretation
of the outgoing message */
if tr0[i] = +t for some term t then
append strand (cid:126)p with node +t(cid:48)
where t(cid:48) is a recipe of t
(cid:126)S ← (cid:126)S ∪ {(cid:126)p}
12:
13: return (cid:126)S
4:
5:
6:
7:
8:
9:
10:
11:
Although strands are assumed to be well-formed, how to
generate the outgoing messages is unspeciﬁed. To see this,
let us consider a narrative trace (cid:126)s. Without loss of generality,
assume that (cid:126)s[i] = +t and (cid:126)Ki((cid:126)s) = (cid:104)Ti, σi(cid:105). The meaning
of well-formedness is twofold. First, we get Ki((cid:126)s) (cid:96)E t in
terms of the original narrative trace (cid:126)s. Second, we should
also achieve Ti (cid:96) t(cid:48) and t(cid:48)σi =E t in the new compiled
strand. This accords with Proposition 2.1, as Tiσi = Ki((cid:126)s),
and t(cid:48) is a recipe of t.
The key to our interpretation is therefore to ﬁnd a recipe
for each outgoing message. Unfortunately, the recipe may
not be unique, posing a major hurdle in interpreting an out-
going message.
Example 5. To make this more concrete, let us consider a
very simple protocol.
1. A → B : {Kab}K+
2. B → A : {M}Kab
b
Suppose that the initial knowledge of B is Tb0 = {A, B, M, K +
a ,
b , Kab}. The narrative trace of role B is (cid:126)s = (cid:104)Tb0,
−
K +
b , K
, +{M}Kab(cid:105) Then, K2((cid:126)s) = Tb0 ∪{{M}Kab} and
−{Kab}K+
1 =s {M}Kab
(cid:126)K2((cid:126)s) = (cid:104)Tb0∪{x1}, [{Kab}K+
2}
1, t(cid:48)
and t(cid:48)
2 =s penc(M, pdec(x1, K
and
/x1](cid:105). By letting t(cid:48)
b ), we get Tb0∪{x1} (cid:96) {t(cid:48)
−
b
b
b
t
2[{Kab}K+
(cid:48)
/x1] =Edy t
1[{Kab}K+
(cid:48)
2 are recipes of {M}Kab , corresponding
Here, both t(cid:48)
to two diﬀerent ways of generating the message {M}Kab . If
we admit t(cid:48)
1 as the recipe, then the compiled strand of role
B is
/x1] =Edy {M}Kab
1 and t(cid:48)
b
(cid:126)s1 = (cid:104)Tb0,−x1, check(pdec(x1, K
−
b ) = Kab),
+ {M}Kab(cid:105)
2 as the recipe), the compiled strand becomes
(1)
Otherwise (t(cid:48)
(cid:126)s2 = (cid:104)Tb0,−x1, check(pdec(x1, K
b )(cid:105)
−
+ penc(M, pdec(x1, K
−
b ) = Kab),
(2)
Due to the check events, (cid:126)s1 and (cid:126)s2 are equivalent in a sense
that no ambiguity arises from the choice of recipe. On the
contrary, if we eliminate the check events, then the imple-
mentations deﬁned by (cid:126)s1 and (cid:126)s2 diﬀer signiﬁcantly.
Thanks to the internal checks, we make the following
claim, which allows us to choose any recipe of an outgoing
message without aﬀecting the result of the implementation.
Claim 5.5. The prudent implementation remains invariant
under diﬀerent interpretations of outgoing messages.
Incorporating the above considerations, we obtain the fol-
lowing algorithm to derive a prudent implementation from
a set of narrative traces T R0.
The algorithm creates an implementation strand for each
narrative trace. The construction starts by using the nar-
rative trace to compute a constraint base. For a node with
receive event, from line 6 to line 9, it updates knowledge
and construct a new equality check event whenever it be-
comes feasible. For a node with send event, from line 10 to
line 11, the algorithm simply chooses an arbitrary recipe of
the outgoing message due to Claim 5.5.
Theorem 5.6. Let T R0 be a set of narrative traces and
(cid:126)S be an ideal semantics of T R0. Then, Derive-Prudent-
Implementation(T R0) returns an prudent implementation
of (cid:126)S.
5.3 Reﬁned Implementation
To illustrate the idea of implemention reﬁnement, let us
reexamine the motivating example given in Section 1. We
recapitulate the well-known type ﬂaw attack here.
1. A → B
4. I(B) → A
: M, A, B,{Na, M, A, B}Kas
: M,{Na, M, A, B}Kas
After initiating the ﬁrst message, A is expecting from B the
message M ·{Na· Kab}Kas , which is forged by an intruder I.
The intruder I impersonates B and then replays an inter-
cepted message to A. It is not hard to see that the narrative
trace for role A is
trA =A[M, A, B, S, Na, Kas, Kab]
(cid:104){M, A, B, S, Na, Kas},
+ M · A · B · {Na · M · A · B}Kas ,
− {Na · Kab}Kas(cid:105)
Likewise, we get narrative trace trI describing the attack
scenario.
trI =A[M, A, B, S, Na, Kas]
(cid:104){M, A, B, S, Na, Kas},
+ M · A · B · {Na · M · A · B}Kas ,
− {Na · M · A · B}Kas(cid:105)
Thus, trA (cid:54)≈E trI . Speciﬁcally, A can observe the following
diﬀerence (cid:40){Na · M · A · B}Kas σ0 (cid:54)=Edy xσ0
{Na · M · A · B}Kas σ1 =Edy xσ1
where σ0 = [{Na · Kab}Kas /x] and σ1 = [{Na · M · A ·
B}Kas /x]. This diﬀerence suggests that we can simply add
a new check event immediately after the receive event to
prevent the attack. Thus, the new implementation strand
of role A becomes
A[M, A, B, S, Na, Kas, x]
(cid:104){M, A, B, S, Na, Kas},
+ M · A · B · {Na · M · A · B}Kas ,
− x4, check({Na · M · A · B}Kas (cid:54)= x)(cid:105)
The core innovation of our reﬁnement is to add inequal-
ity check events to disallow such execution traces in T RI
that are not in compliance with protocol narration T R0.
Nonetheless, not all attack scenarios are useful to reﬁne a
protocol implementation, especially if the execution traces
of the attack are in compliance with the protocol narration.
For instance, the well-known man-in-the-middle attack due
to Lowe [25] on the Needham-Schroeder public-key authen-
tication protocol [31] can not be thwarted by adding any
check event(s).
In general, a known attack can be categorized into the
following three types:
• type-I attack, if all execution traces are in compliance
with the ideal implementation. From a protocol imple-
mentor’s point of view, this type of attack cannot be
detected/prevented unless the design of the protocol is
changed;
• type-II attack, if all execution traces are in compliance
with the prudent implementation, and there exists an
execution trace that is not in compliance with the ideal
implementation;
• type-III attack, if there exists an execution trace that
is in compliance with the coarse implementation, but
not in compliance with the prudent implementation;
To the end of this section, we draw a picture of the classi-