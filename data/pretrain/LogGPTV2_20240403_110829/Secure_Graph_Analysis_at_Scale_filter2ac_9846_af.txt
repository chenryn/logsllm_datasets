9
Table 1: Maximum number of rounds for finding MIS, when
choosing random values in each round [38], and with a fixed
order [7].
(b) If r(v) is smaller than the numbers received from all neigh-
bors of 𝑣, then 𝑣 inserts itself into 𝐼, informs its neighbors
about this, and becomes inactive.
(c) If 𝑣 heard that one of its neighbors was inserted into 𝐼,
then 𝑣 becomes inactive.
(3) Return 𝐼
Luby’s algorithm is a message-passing algorithm where each round
can be implemented using two scatter/gather steps – one for send-
ing 𝑟(𝑣) to 𝑣’s neighbors, and one in which nodes that joined the
MIS tell their neighbors to become inactive. It is possible to imple-
ment this algorithm in our framework, but this requires using a
gather circuit comparing 𝑟(𝑣) to the 𝑟 values of its neighbors. This
circuit will be larger, by at least a factor of 𝑟(𝑣)(> log |𝑉 |), than
the BFS gather circuit which only computes an OR of bits.
Luckily, a result of Blelloch et al. suggested running Luby’s
algorithm using a single initial assignment of random values to
nodes [7], and a recent analysis showed that this variant, too, finds
the MIS whp in 𝑂(log 𝑛) rounds [18]. We ran 1,000 experiments
for random graphs of various sizes, which showed that using a
fixed assignment of random values works almost as well as Luby’s
algorithm. This is expressed in two properties which are of interest
to us: (1) The expected size of the MIS is increased by about 0.5%.
(2) The maximum number of rounds, described in Table 1, increases
by very little (and is ≪ log 𝑛). A secure implementation must run
for a constant number of rounds, which we set to be 8 or 9.
The variant of the algorithm due to Blelloch et al. [7] lends itself
to a much more efficient implementation in our framework:
(1) In an initial phase each node is assigned a random id, and
edges are directed towards the node with the higher id among
their two endpoints. (2) Each node is assigned a MIS bit, initial-
ized to 0, and an “active” bit initialized to 1. (3) In a scatter step,
each node pushes its activity bit on all outgoing edges. (4) In a
gather step, each active node which has no incoming edges from
active nodes, sets its MIS bit to 1. (5) In a scatter step, each node
in the MIS sends “inactive” on all outgoing edges. (6) In a gather
step, each node which received an “inactive” message becomes
inactive. (7) Go back to Step 3.
This algorithm enables to implement scatter and gather using
OR operations, instead of comparisons. The resulting circuits are
therefore much more compact. We implemented this functionality
and report the results in Appendix A.4.
9 IMPLEMENTATION AND EVALUATION
A detailed description of the implementation, optimization, and
evaluation of the protocols appears in Appendix A.
Session 2D: Secure Multiparty Computation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea6221983, pp. 1–9.
REFERENCES
[1] M. Ajtai, J. Komlós, and E. Szemerédi, “An O(n log n) sorting network,” in STOC,
[2] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, and
A. Watzman, “Optimized honest-majority mpc for malicious adversaries - break-
ing the 1 billion-gate per second barrier,” in IEEE Symposium on Security and
Privacy, SP, 2017.
[3] T. Araki, A. Barak, J. Furukawa, T. Lichter, Y. Lindell, A. Nof, K. Ohara, A. Watz-
man, and O. Weinstein, “Optimized honest-majority MPC for malicious adver-
saries - breaking the 1 billion-gate per second barrier,” in 2017 IEEE Symposium
on Security and Privacy, 2017, pp. 843–862.
[4] T. Araki, J. Furukawa, Y. Lindell, A. Nof, and K. Ohara, “High-throughput
semi-honest secure three-party computation with an honest majority,” in ACM
Conference on Computer and Communications Security CCS, 2016, pp. 805–817.
[5] A. Barak, M. Hirt, L. Koskas, and Y. Lindell, “An end-to-end system for large
scale P2P mpc-as-a-service and low-bandwidth MPC for weak participants,” in
ACM Conference on Computer and Communications Security, CCS, 2018, pp.
695–712.
[6] M. Ben-Or, S. Goldwasser, and A. Wigderson, “Completeness theorems for non-
cryptographic fault-tolerant distributed computation (extended abstract),” in
STOC, 1988, pp. 1–10.
[7] G. E. Blelloch, J. T. Fineman, and J. Shun, “Greedy sequential maximal independent
set and matching are parallel on average,” in SPAA. ACM, 2012, pp. 308–317.
[8] E. Boyle, N. Gilboa, Y. Ishai, and A. Nof, “Practical fully secure three-party com-
putation via sublinear distributed zero-knowledge proofs,” in ACM Conference
on Computer and Communications Security, CCS, 2019, pp. 869–886.
[9] M. Byali, C. Hazay, A. Patra, and S. Singla, “Fast actively secure five-party com-
putation with security beyond abort,” in ACM Conference on Computer and
Communications Security, CCS, 2019, pp. 1573–1590.
[10] R. Canetti, “Security and composition of multiparty cryptographic protocols,”
[Online]. Available:
J. Cryptology, vol. 13, no. 1, pp. 143–202, 2000.
http://dx.doi.org/10.1007/s001459910006
[11] O. Catrina and A. Saxena, “Secure computation with fixed-point numbers,”
in International Conference on Financial Cryptography and Data Security.
Springer, 2010, pp. 35–50.
[12] D. Chaum, C. Crépeau, and I. Damgård, “Multiparty unconditionally secure
protocols (extended abstract),” in STOC, 1988, pp. 11–19.
[13] K. Chida, D. Genkin, K. Hamada, D. Ikarashi, R. Kikuchi, Y. Lindell, and A. Nof,
“Fast large-scale honest-majority MPC for malicious adversaries,” in CRYPTO
2018, 2018, pp. 34–64.
[14] K. Chida, K. Hamada, D. Ikarashi, R. Kikuchi, N. Kiribuchi, and B. Pinkas, “An
efficient secure three-party sorting protocol with an honest majority,” Cryptology
ePrint Archive, Report 2019/695, 2019, https://eprint.iacr.org/2019/695.
[15] R. Cohen, abhi shelat, and D. Wichs, “Adaptively secure MPC with sublinear
communication complexity,” in CRYPTO, 2019, pp. 30–60.
[16] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein, Introduction to
Algorithms, Third Edition, 3rd ed. The MIT Press, 2009.
[17] I. Damgård, D. Escudero, T. K. Frederiksen, M. Keller, P. Scholl, and N. Volgushev,
“New primitives for actively-secure MPC over rings with applications to private
machine learning,” in IEEE Symposium on Security and Privacy, SP, 2019, pp.
1102–1120.
[18] M. Fischer and A. Noever, “Tight analysis of parallel randomized greedy MIS,” in
SODA.
SIAM, 2018, pp. 2152–2160.
[19] J. Furukawa and Y. Lindell, “Two-thirds honest-majority MPC for malicious
adversaries at almost the cost of semi-honest,” in ACM Conference on Computer
and Communications Security CCS, 2019, pp. 1557–1571.
[20] J. Furukawa, Y. Lindell, A. Nof, and O. Weinstein, “High-throughput secure
three-party computation for malicious adversaries and an honest majority,” in
EUROCRYPT 2017, 2017, pp. 225–255.
[21] O. Goldreich, S. Micali, and A. Wigderson, “How to play any mental game or A
completeness theorem for protocols with honest majority,” in STOC, 1987, pp.
218–229.
[22] M. T. Goodrich, “Randomized shellsort: A simple data-oblivious sorting algorithm,”
J. ACM, vol. 58, no. 6, pp. 27:1–27:26, 2011.
[23] ——, “Zig-zag sort: a simple deterministic data-oblivious sorting algorithm run-
ning in o(n log n) time,” in STOC, D. B. Shmoys, Ed., 2014, pp. 684–693.
[24] S. D. Gordon, S. Ranellucci, and X. Wang, “Secure computation with low commu-
nication from cross-checking,” 2018, pp. 59–85.
[25] V. Goyal, Y. Liu, and Y. Song, “Communication-efficient unconditional MPC with
guaranteed output delivery,” in CRYPTO 2019, pp. 85–114.
[26] K. Hamada, R. Kikuchi, D. Ikarashi, K. Chida, and K. Takahashi, “Practically
efficient multi-party sorting protocols from comparison sort algorithms,” in
ICISC, ser. LNCS, vol. 7839.
Springer, 2012, pp. 202–216.
[27] C. Hong, J. Katz, V. Kolesnikov, W. Lu, and X. Wang, “Covert security with public
verifiability: Faster, leaner, and simpler,” in EUROCRYPT 2019, 2019, pp. 97–121.
[28] D. Ikarashi, K. Hamada, R. Kikuchi, and K. Chida, “A design and an implementa-
tion of super-high-speed multi-party sorting:the day when multi-party computa-
tion reached scripting languages,” in Computer Security Symposium 2017.
[29] M. Keller, E. Orsini, and P. Scholl, “MASCOT: faster malicious arithmetic secure
computation with oblivious transfer,” in ACM Conference on Computer and
Communications Security, 2016, pp. 830–842.
[30] M. Keller, P. Scholl, and N. P. Smart, “An architecture for practical actively
secure MPC with dishonest majority,” in ACM Conference on Computer and
Communications Security, CCS, A. Sadeghi, V. D. Gligor, and M. Yung, Eds., 2013,
pp. 549–560.
[31] D. E. Knuth, The art of computer programming,
, Volume III, 2nd Edition.
Addison-Wesley, 1998.
[32] E. Larraia, E. Orsini, and N. P. Smart, “Dishonest majority multi-party computa-
tion for binary circuits,” in CRYPTO 2014, J. A. Garay and R. Gennaro, Eds., pp.
495–512.
[33] S. Laur, J. Willemson, and B. Zhang, “Round-efficient oblivious database manipu-
lation,” in ISC, 2011, pp. 262–277.
[34] Y. Lindell, “How to simulate it - A tutorial on the simulation proof technique,” in
Tutorials on the Foundations of Cryptography.
Springer, 2017, pp. 277–346.
[35] Y. Lindell and A. Nof, “A framework for constructing fast MPC over arithmetic
circuits with malicious adversaries and an honest-majority,” in ACM Conference
on Computer and Communications Security, CCS, 2017, pp. 259–276.
[36] C. Liu, X. S. Wang, K. Nayak, Y. Huang, and E. Shi, “Oblivm: A programming
framework for secure computation,” in 2015 IEEE Symposium on Security and
Privacy, SP, 2015, pp. 359–376.
[37] Y. Low, J. Gonzalez, A. Kyrola, D. Bickson, C. Guestrin, and J. M. Hellerstein,
“Distributed graphlab: A framework for machine learning in the cloud,” PVLDB,
vol. 5, no. 8, pp. 716–727, 2012.
[38] M. Luby, “A simple parallel algorithm for the maximal independent set problem,”
in STOC. ACM, 1985, pp. 1–10.
[39] G. Malewicz, M. H. Austern, A. J. C. Bik, J. C. Dehnert, I. Horn, N. Leiser, and
G. Czajkowski, “Pregel: a system for large-scale graph processing,” in ACM
SIGMOD, 2010, pp. 135–146.
[40] S. Mazloom and S. D. Gordon, “Secure computation with differentially private ac-
cess patterns,” in ACM Conference on Computer and Communications Security.
ACM, 2018, pp. 490–507.
[41] S. Mazloom, P. H. Le, S. Ranellucci, and S. D. Gordon, “Secure parallel computation
on national scale volumes of data,” in USENIX Security Symposium. USENIX
Association, 2020, pp. 2487–2504.
[42] P. Mohassel and P. Rindal, “Aby3: A mixed protocol framework for machine
learning,” in ACM Conference on Computer and Communications Security, CCS,
2018, pp. 35–52.
[43] K. Murphy, Y. Weiss, and M. I. Jordan, “Loopy belief propagation for approximate
inference: An empirical study,” arXiv preprint arXiv:1301.6725, 2013.
[44] K. Nayak, X. S. Wang, S. Ioannidis, U. Weinsberg, N. Taft, and E. Shi, “Graphsc:
Parallel secure computation made easy,” in 2015 IEEE Symposium on Security
and Privacy, SP, 2015, pp. 377–394.
[45] V. Nikolaenko, S. Ioannidis, U. Weinsberg, M. Joye, N. Taft, and D. Boneh, “Privacy-
preserving matrix factorization,” in ACM CCS. ACM, 2013, pp. 801–812.
[46] M. Paterson, “Progress in selection,” in Algorithm Theory - SWAT, 1996, pp.
[47] T. Rabin and M. Ben-Or, “Verifiable secret sharing and multiparty protocols with
honest majority,” in STOC, 1989, pp. 73–85.
[48] S. Sahu, A. Mhedhbi, S. Salihoglu, J. Lin, and M. T. Özsu, “The ubiquity of large
graphs and surprising challenges of graph processing: extended survey,” VLDB
J., vol. 29, no. 2-3, pp. 595–618, 2020.
[49] A. Sangers, M. van Heesch, T. Attema, T. Veugen, M. Wiggerman, J. Veldsink,
O. Bloemen, and D. Worm, “Secure multiparty pagerank algorithm for collabora-
tive fraud detection,” in Financial Cryptography, 2019, pp. 605–623.
[50] T. Schneider and M. Zohner, “GMW vs. Yao? efficient secure two-party computa-
tion with low depth circuits,” in Financial Cryptography, 2013, pp. 275–292.
[51] A. C. Yao, “How to generate and exchange secrets (extended abstract),” in FOCS,
1986, pp. 162–167.
[52] J. S. Yedidia, W. T. Freeman, and Y. Weiss, “Understanding belief propagation
and its generalizations,” Exploring artificial intelligence in the new millennium,
vol. 8, pp. 236–239, 2003.
[53] B. Zhang, “Generic constant-round oblivious sorting algorithm for MPC,” in
Springer, 2011, pp.
ProvSec, ser. Lecture Notes in Computer Science, vol. 6980.
240–256.
368–379.
A IMPLEMENTATION AND EVALUATION
Our experiment testbed We implemented the protocols on AWS
c5.9xlarge servers, connected over a 10Gb network. The servers
are Intel Xeon Platinum 8000 series (Skylake-SP) processor with a
Session 2D: Secure Multiparty Computation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea623sustained all core Turbo CPU clock speed of up to 3.5 GHz. The im-
plementation was multi-threaded and used 32 cores. The machines
had 72GB of memory.
A.1 Optimizations of the Shuffle and Sort
Algorithms
We used the following optimizations for the implementations of
the secure shuffle and sort protocols.
• Parallelization and multi-threading The sorting protocol
implements the quicksort algorithm, which selects a pivot
item, compares all items to this pivot, partitions the input
set to two subsets based on this comparison, and proceeds
recursively to operate on the subsets. The comparisons of
all items in a layer can be performed in parallel, where layer
𝑖 has at most 2𝑖 partitions and pivots.
• Vectorization The comparisons are implemented using a bi-
nary circuit operating on single bits of the items. Combining
multiple comparison operations we can utilize the proces-
sor’s SIMD (single instruction multiple data) vectorization
to perform the same bit operation on multiple arguments in
parallel. Using Intel’s AVX512 instructions we can operate
on 512 bits simultaneously.
• A shallow comparison circuit The MPC protocol runs
a communication round for each layer of AND gates. The
major operation implemented by the protocol is comparison,
and therefore it is preferable to reduce the depth of the ba-
sic sub-circuit computing comparisons. A straightforward
comparison circuit between two ℓ-bit words uses ℓ − 1 AND
gates and is of depth ℓ−1. A more careful construction yields
a circuit of depth log ℓ + 1, and uses 3ℓ − 3 AND gates [50].
Our experiments were run between servers that are in the
same network which has a small latency. The experiments
showed that when computing a large number of compar-
isons (and thus throughput is more important than latency),
it is preferable to use the deep and small circuit, and when
the number of comparisons is relatively small it is better to
use the shallow and large circuit. We therefore implemented
a “tradeoff” solution which in most steps uses the deep and
small circuit, and when the number of comparisons that need
to be computed in parallel drops below a threshold uses the
shallow and large circuit.
• Choosing the pivot Choosing the median as the pivot en-
sures that sorting is computed in log 𝑛 rounds. Since com-
puting the median using a circuit is complex, it is possible
to sample a random item from the table as the pivot. This
variant has an expected number of 𝑂(log 𝑛) rounds (see [16]
Section 7.4.2). However, the actual number of rounds is larger
than log 𝑛. In order to choose a pivot which is closer to the
median item, the protocol that we implemented samples 𝑠
items, computes their median by comparing in parallel all
pairs of these items, and uses this median as the pivot. It is
well known that for a good approximation the sample size
should be about 𝑠 = 2 log 𝑛 [46]. In our implementation we
compute the pivot as the median of a sample of 3,5 or 7 items.
• Handling small subsets The naive version of the sorting
algorithm continues to recursively divide the input two sub-
sets until the size of each subset is 1. Instead, it is possible
to stop the recursion when the size of the subset is reduced
to some threshold of 𝑡 items, do a parallel comparison of all
pairs of items in this subset, and based on the results (using
a precomputed lookup table, as in the median computation)
output the items in sorted order.
A.2 Shuffling and Sorting Experiments
We ran separate experiments to analyze the performance of the
secure shuffle and sort protocols, since these protocols might be
useful for a wide range of secure algorithms beyond secure graph
analysis. The shuffle and sorting algorithms were implemented
using the MPC library described in the paper of Araki et al. [4].
The results of the experiments are detailed in Table 2. The num-
ber of elements in the experiments ranges between 1M to 50M. All
the results are the average of five executions. They refer to tables