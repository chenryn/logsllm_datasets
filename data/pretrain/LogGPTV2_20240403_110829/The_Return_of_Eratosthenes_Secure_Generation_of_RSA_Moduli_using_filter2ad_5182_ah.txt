cobi test, we can assume that Ëœğ‘ =(ğ‘ âˆ’ğ‘âˆ’ğ‘+1)/4â‰ 0 modğœ™(ğ‘) and
that the adversary introduced an error Î”ğ‘— such that ğ‘¦â€² =ğ›¾
Ëœğ‘+Î”ğ‘— =Â±1
modğ‘ . When the adversary cheats in the broadcast of the consis-
tencycheck,thesimulatorcomputesğ›¾ğ‘¡Int+Î”ğ‘¡ ,where Î”ğ‘¡ â‰ 0represents
the error introduced by A. Thus, for the equality to hold, A needs
to commit to Î”ğ‘¡ during the broadcast, such that ğ›¾ğ‘¥ Ëœğ‘+Î”ğ‘¡ =ğ‘¦ğ‘¥ =ğ›¾ğ‘¥ Ëœğ‘
modğ‘ . Since the distribution of ğ‘¥ Ëœğ‘ is uniform with a min-entropy
of 2âˆ’ğœ, because of the sampling of ğ‘¥,A has probability at most 2âˆ’ğœ+1
of finding the correct Î”ğ‘¡. We finally note that Î”ğ‘¡ cannot simply be
the right value in the group of exponents with higher probability
than this, because Rosser and Schoenfeld [34] showed that
ğœ™(ğ‘) >
ğ‘
ğ‘’ğ›¾loglogğ‘
,
where ğ›¾ is the Eulerâ€“Mascheroni constant. This gives us that
log2(ğœ™(ğ‘)) > ğœ, when log2(ğ‘) >2048 and ğœ âˆ¼80.
ğ‘—=1(ğ‘£ ( ğ‘—),â„“gcd), and stores them.
ğ‘—=1(ğ‘( ğ‘—),â„“gcd), and stores them.
GCD Test:
(1) When all parties call FAdvMPCâˆ’CRT.Rand2k in Step 2, S
samples a random ğ‘  ğ‘; thus, by sampling a random Ëœğ‘§ such that
gcd(ğ‘ ,Ëœğ‘§) =max{ğ‘,ğ‘â€²}, the simulator remains consistent with both ğ‘
and the probability that gcd(ğ‘ ,ğ‘) =ğ‘â€² >ğ‘ occurs, since ğ‘ is sampled
identically. By adding a sufficiently random ğ‘£ to ğ‘§ any information
about ğ‘+ğ‘âˆ’1 other than ğ‘ is masked, therefore the distribution of
the modified Ë†ğ‘§ output by the simulator is both statistically close to
the distribution of Ë†ğ‘§ in the protocol, and consistent with the (ğ‘ ,ğ‘,ğ‘)
values generated by FRSAGen.
â–¡
Lemma A.1. In Step 5 of the Sampling Phase of Î RSAGen,
the distribution of each ğ‘( ğ‘—) value is within statistical distance
(1âˆ’ğœ–)ğœ–ğ‘€sample/ğ‘† of uniform over [2ğœ†,2ğœ†+ğœ), where ğ‘† = 2ğœ†+ğœ âˆ’2ğœ† is
the size of the range and ğœ– = ğ‘†/ğ‘€sampleâˆ’(cid:4)ğ‘†/ğ‘€sample
(cid:5) âˆˆ [0,1) is the
decimal remainder in the division of the range size by ğ‘€sample.
Proof. We can write ğ‘† =ğ‘€sample(âŒŠğ‘†/ğ‘€sampleâŒ‹+ğœ–) with 0â‰¤ ğœ– <1.
When dividing the range of size ğ‘† into blocks of size ğ‘€sample, the
last block will not be complete (if ğ‘€sample does not divide ğ‘†). When
reducing the elements of [2ğœ†,2ğœ†+ğœ) modulo ğ‘€sample, some residue
classes will therefore be present one more time than others: those
classes which have representatives in the included portion of the last
block. Let ğ‘‹1 denote the subset of ğ‘¥ âˆˆ [2ğœ†,2ğœ†+ğœ), whose residue class
is more present, and let ğ‘‹2 =[2ğœ†,2ğœ†+ğœ)\ğ‘‹1 be those elements, whose
residue class does not have a representative in the included portion.
Let ğ‘¥ âˆˆ [2ğœ†, 2ğœ†+ğœ), by Euclidean division, ğ‘¥ can be uniquely
written as ğ‘¥ = ğ‘ğ‘€sample+ğ‘ with ğ‘ âˆˆ N and ğ‘ âˆˆ [0,ğ‘€sample). As ğ‘( ğ‘—)
is computed as ğ‘( ğ‘—) =ğ‘â€²( ğ‘—)+ğ‘Ÿ ( ğ‘—) Â·ğ‘€sample in Step 5 of the sampling
phase, this implies:
Pr(cid:104)ğ‘( ğ‘—) =ğ‘¥(cid:105)
ğ‘€sample
ğ‘€sample
=
1
1
=Pr(cid:104)ğ‘â€²( ğ‘—) =ğ‘âˆ§ğ‘Ÿ ( ğ‘—) =ğ‘(cid:105)
Â·
Â·
1
1
âŒŠğ‘†/ğ‘€sampleâŒ‹+1
âŒŠğ‘†/ğ‘€sampleâŒ‹
ğ‘¥ âˆˆğ‘‹1,
ğ‘¥ âˆˆğ‘‹2,
[0, ğ‘€sample),
ğ‘â€²( ğ‘—)
is
uniform in
of
as
FABBWithErrors.Share(ğ‘â€²) and ğ‘Ÿ ( ğ‘—)
is uniform subject to the
condition that ğ‘( ğ‘—) âˆˆ [2ğœ†,2ğœ†+ğœ). Let ğ‘ƒ denote the above probability
distribution. To compute the statistical distance between ğ‘ƒ and
uniform, we compute the size of both ğ‘‹1 and ğ‘‹2, which is
because
(cid:18)(cid:22)
This yields the following distance calculation:
Î”(ğ‘ƒ,ğ‘ˆ) =
|Pr[ğ‘ƒ =ğ‘¥]âˆ’Pr[ğ‘ˆ =ğ‘¥]|
|ğ‘‹1| =ğœ–ğ‘€sampleÂ·
ğ‘†
ğ‘€sample
|ğ‘‹2| =(1âˆ’ğœ–)ğ‘€sampleÂ·
ğ‘†
1
2
|ğ‘‹1|Â·
ğ‘¥âˆˆ[2ğœ†,2ğœ†+ğœ)
âˆ‘ï¸
(cid:12)(cid:12)(cid:12)(cid:12)Pr[ğ‘ƒ =ğ‘¥ | ğ‘¥ âˆˆğ‘‹1]âˆ’ 1
(cid:12)(cid:12)(cid:12)(cid:12)+|ğ‘‹2|Â·
(cid:18)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)ğœ–âˆ’ ğœ–ğ‘€sample
(cid:107)+1(cid:17)
(cid:16)(cid:106)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(1âˆ’ğœ–)âˆ’
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(cid:106)
(cid:107)
(cid:12)(cid:12)(cid:12)(cid:12) (1âˆ’ğœ–)ğœ–ğ‘€sample
(cid:18)(cid:12)(cid:12)(cid:12)(cid:12)ğœ–ğ‘€sample(ğœ–âˆ’1)
(1âˆ’ğœ–)ğ‘€sample
ğ‘†
ğ‘€sample
ğ‘†
(cid:12)(cid:12)(cid:12)(cid:12)+
ğ‘€sample
ğ‘†
ğ‘†
ğ‘†
(cid:12)(cid:12)(cid:12)(cid:12)(cid:19)
1
2
1
2
=
=
+1
2
1
2
(1âˆ’ğœ–)ğœ–ğ‘€sample
ğ‘†
.
=
=
ğ‘†
(cid:23)
(cid:19)
+1
(cid:22)
and
(cid:23)
.
ğ‘†
ğ‘€sample
(cid:12)(cid:12)(cid:12)(cid:12)Pr[ğ‘ƒ =ğ‘¥ | ğ‘¥ âˆˆğ‘‹2]âˆ’ 1
ğ‘†
(cid:12)(cid:12)(cid:12)(cid:12)(cid:19)
â–¡
B STANDARD FUNCTIONALITIES
We include standard functionalities for MPC for reference.
C UNAUTHENTICATED
ARITHMETIC BLACK BOX PROTOCOLS
We include standard protocols for MPC for reference.
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea608Î InputTuple
Input: On Input (Input,ğ‘ƒ ğ‘—) from all parties do the following:
(1) ğ‘ƒ ğ‘— samples ğ‘Ÿ
(2) All parties output [ğ‘Ÿ] and ğ‘ƒ ğ‘— outputs ğ‘Ÿ.
$â† F
Figure 18: Protocol for passively secure Input Tuples as
presented in MASCOT [27].
Î TripleGeneration
Multiply:
(1) Each party samples ğ‘(ğ‘–) $â† F,ğ‘(ğ‘–) $â† F.
(2) Every ordered pair of parties ğ‘ƒğ‘–,ğ‘ƒ ğ‘— does the following:
, where ğ‘ƒğ‘– inputs (ğ‘(ğ‘–)
(a) Both parties call Fğ‘˜,ğ‘˜
ROT
1,â„ âˆˆ F, and ğ‘ƒğ‘– receives ğ‘ (ğ‘–,ğ‘—)
,ğ‘( ğ‘—,ğ‘–)
gâˆ’1(ğ‘(ğ‘–)) âˆˆ Fğ‘˜
2 .
(b) ğ‘ƒ ğ‘— receives ğ‘( ğ‘—,ğ‘–)
0,â„
1 , ... , ğ‘(ğ‘–)
= ğ‘( ğ‘—)
ğ‘(ğ‘–)
â„
ğ‘˜ ) =
,
,â„
â„
for â„ =1,...,ğ‘˜.
(c) ğ‘ƒ ğ‘— sends ğ‘‘ ( ğ‘—,ğ‘–)
â„
(d) ğ‘ƒğ‘– sets ğ‘¡ (ğ‘–,ğ‘—)
=ğ‘( ğ‘—,ğ‘–)
= ğ‘ (ğ‘–,ğ‘—)
â„ =1,...ğ‘˜. Set ğ‘( ğ‘—,ğ‘–)
â„
â„
â„
0,â„ âˆ’ğ‘( ğ‘—,ğ‘–)
1,â„ +ğ‘( ğ‘—) ,â„ âˆˆ [ğ‘˜].
= ğ‘( ğ‘—,ğ‘–)
+ ğ‘(ğ‘–) Â· ğ‘‘ ( ğ‘—,ğ‘–)
=ğ‘( ğ‘—,ğ‘–)
0,â„
â„
.
0,â„ + ğ‘(ğ‘–)
â„ Â· ğ‘( ğ‘—) , for
(ğ‘–)
ğ‘–,ğ‘— = âŸ¨g,tâŸ© âˆˆ F, for t the above ğ‘˜-element vector.
( ğ‘—)
ğ‘–,ğ‘— =âˆ’âŸ¨g,qâŸ© âˆˆ F, for q the above ğ‘˜-element vector.
(e) ğ‘ƒğ‘– sets c
(f) ğ‘ƒ ğ‘— sets c
(g) Now we have: c
(3) Each party ğ‘ƒğ‘– computes: c(ğ‘–) =ğ‘(ğ‘–) Â·ğ‘( ğ‘—) +ğ‘—â‰ ğ‘– (c
( ğ‘—)
ğ‘–,ğ‘— =ğ‘(ğ‘–) Â·ğ‘( ğ‘—) âˆˆ F
(ğ‘–)
ğ‘–,ğ‘— +c
(ğ‘–)
ğ‘–,ğ‘— +c
(ğ‘–)
ğ‘—,ğ‘– )
Combine:
(1) Sample ğ‘Ÿ,Ë†ğ‘Ÿ
(2) Each party ğ‘ƒğ‘– sets:
$â† FRand(F).
(a) ğ‘(ğ‘–) = âŸ¨ğ‘(ğ‘–) ,ğ‘ŸâŸ©,ğ‘(ğ‘–) = âŸ¨ğ‘(ğ‘–) ,ğ‘ŸâŸ©, and
(b) Ë†ğ‘(ğ‘–) = âŸ¨ğ‘(ğ‘–) ,Ë†ğ‘ŸâŸ©,Ë†ğ‘(ğ‘–) = âŸ¨ğ‘(ğ‘–) ,Ë†ğ‘ŸâŸ©
Output: ([ğ‘],[ğ‘],[ğ‘]) as a valid triple.
Figure 19: Protocol for Triple Generation adjusted for passive
security from MASCOT [27].
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea609