接下来，提交这个镜像到注册服务器：
# docker push 127.0.0.1:5000/my_image:v1
本节仅仅介绍了注册服务器的基础知识，更详细的介绍和操作将在第10章展开。
4.1 容器网络基础 49
1
第 4 章 2
数据卷及容器连接
3
4
5
应用在容器中运行，总会用到或者产生一些数据，那么这些数据是如何保存的呢？外部又是
如何使用这些数据的呢？在本章中，我们将说明容器的数据管理相关的议题，主要包含如下内容。 6
 容器网络基础：容器通过对外暴露端口向外提供服务。
 数据卷的概念和使用：通过数据卷来存储和共享数据。 7
 容器连接：通过互联让一个容器安全地使用另一个容器已有的服务。
9
4.1 容器网络基础
8
作为一个寄宿在宿主主机上的容器，我们要想办法让外部网络能够访问到它，这样才能够使
用其提供的服务。当Docker启动时，它会在宿主主机上创建一个名为docker0的虚拟网络接口。通 10
过ifconfig命令，可以看到本机的网络接口情况：
10
$ ifconfig
docker0 Link encap:以太网 硬件地址 56:84:7a:fe:97:99
inet 地址:172.17.42.1 广播:0.0.0.0 掩码:255.255.0.0 11
inet6 地址: fe80::5484:7aff:fefe:9799/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 跃点数:1
接收数据包:114 错误:0 丢弃:0 过载:0 帧数:0 13
发送数据包:72 错误:0 丢弃:0 过载:0 载波:0
碰撞:0 发送队列长度:0
接收字节:8314 (8.3 KB) 发送字节:8673 (8.6 KB) 14
...
eth1 Link encap:以太网 硬件地址 b8:ee:65:d5:5a:71
inet 地址:192.168.222.224 广播:192.168.222.255 掩码:255.255.255.0 15
inet6 地址: fe80::baee:65ff:fed5:5a71/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 跃点数:1
接收数据包:1448650 错误:0 丢弃:0 过载:0 帧数:13734576
16
发送数据包:645668 错误:0 丢弃:0 过载:0 载波:0
碰撞:0 发送队列长度:1000
接收字节:797901530 (797.9 MB) 发送字节:91342786 (91.3 MB)
17
中断:17
...
18
可以看到，在宿主主机上有一个名为docker0的网络接口，其地址是172.17.42.1，这是Docker
50 第4章 数据卷及容器连接
默认分配的地址。关于Docker网络更多高级的主题，我们会在第5章中讲解。接下来，我们概要
介绍一些数据管理涉及的网络基础，例如暴露网络端口和查看网络配置等。
4.1.1 暴露网络端口
当在Docker中运行网络应用时，我们需要在外部访问Docker中运行的应用，这时需要通过-P
或者-p参数来指定端口映射。通过端口映射来实现端口暴露是容器对外提供服务的基础方法。
 -P（大写）参数。使用-P参数，Docker会在宿主主机上随机为应用分配一个49000～49900
内的未被使用的端口，并将其映射到容器开放的网络端口。
接下来，举一个这方面的例子，这里需要用到Docker官方提供的一个培训示例镜像
training/webapp。由于本地并没有这个镜像，所以需要去搜索和下载。首先，通过如下命
令来搜索：
$ docker search training/webapp
NAME DESCRIPTION STARS OFFICIAL AUTOMATED
training/webapp 8 [OK]
amouat/webapp-training 0 [OK]
可以看到，第一个是我们想要的镜像。接下来，我们需要运行这个镜像，Docker会自动
为我们下载它：
$ docker run -d -P training/webapp python app.py
micall@micall-ThinkPad:~/docker$ docker run -d -P training/webapp python app.py
Unable to find image 'training/webapp' locally
Pulling repository training/webapp
31fa814ba25a: Download complete
511136ea3c5a: Download complete
...
Status: Downloaded newer image for training/webapp:latest
45fd5b0fc80413484da26bb68640b8794dc5409d0ff1bcab8a60c5541205592a
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
45fd5b0fc804 training/webapp:latest "python app.py" 8 minutes ago
Up 8 minutes 0.0.0.0:49153->5000/tcp condescending_kirch
这时以training/webapp镜像为基础的容器已经在后台运行起来了，Docker为它起了一个随
机的名字condescending_kirch。这里注意一下PORTS列，可以看到其值为0.0.0.0:491543->
5000/tcp，Docker将宿主主机的49153端口映射到了容器的5000端口，并且遵守的协议是
TCP协议。
有了这个端口映射，我们就可以通过Web浏览器来访问，如图4-1所示。
4.1 容器网络基础 51
1
2
3
图4-1 Web应用测试主页
4
可以看到，这里可以正常显示“Hello world!”，这说明这个Web应用运行正常。我们可以用
docker logs命令来查看日志输出，相关代码如下： 5
$ docker logs -f suspicious_stallman
6
* Running on http://0.0.0.0:5000/
172.17.42.1 - - [16/Dec/2014 09:01:10] "GET / HTTP/1.1" 200 -
172.17.42.1 - - [16/Dec/2014 09:01:10] "GET /favicon.ico HTTP/1.1" 404 -
172.17.42.1 - - [16/Dec/2014 09:02:17] "GET / HTTP/1.1" 200 - 7
172.17.42.1 - - [16/Dec/2014 09:02:17] "GET /favicon.ico HTTP/1.1" 404 -
172.17.42.1 - - [16/Dec/2014 09:02:17] "GET /favicon.ico HTTP/1.1" 404 -
9
可以看出，我们对该网址进行了两次访问。
 -p（小写）参数。它可以指定宿主主机上的端口映射到容器内部指定的开放端口，格式 8
有如下3种：
10
ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort
-p（小写）的情况比-P（大写）要复杂，下面我们分情况来说明一下。
10
 hostPort:containerPort：当使用这种格式时，宿主主机中的所有网络接口都会被绑定。
例如，我们想把宿主主机中所有网络接口的80端口映射到容器的5000端口： 11
$ docker run -d -p 80:5000 training/webapp python app.py
c56833c127474cac15fe7ce111057c35f32b5023b623ae3ea221d7b0f3a38af5 13
2014/12/16 17:24:31 Error response from daemon: Cannot start container
c56833c127474cac15fe7ce111057c35f32b5023b623ae3ea221d7b0f3a38af5: Error starting userland proxy:
listen tcp 0.0.0.0:80: bind: address already in use 14
可以发现，绑定失败！仔细看出错信息，是绑定失败，80端口已经被使用。通过netstat
命令，我们发现该端口被宿主主机的Apache程序占用了。我们把绑定换成和容器内部 15
端口一样的5000，重新指定一遍，操作如下：
16
$ docker run -d -p 5000:5000 training/webapp python app.py
791116a0598ec3a90c8a24ecd2264c4455cd92f8ce3a944f815ddb0ba04eefbf
17
结果返回成功，我们可以通过docker ps命令查看一下具体情况：
$ docker ps 18
CONTAINER ID IMAGE COMMAND CREATED
52 第4章 数据卷及容器连接
STATUS PORTS NAMES
791116a0598e training/webapp:latest "python app.py" 22 seconds ago
Up 22 seconds 0.0.0.0:5000->5000/tcp agitated_galileo
可以看到，宿主主机的5000端口已经正确映射到了容器的5000开放端口。
除了可以使用docker ps命令查看正在运行的容器外，还可以使用 docker port命令查看
一个容器的端口，相关代码如下：
$ docker port agitated_galileo 5000
0.0.0.0:5000
可以看到，容器的5000端口被宿主主机的5000映射。
 ip:hostPort:containerPort：指定IP地址的指定端口和容器的指定开放端口映射。例如，
我们可以将环回地址上的5000端口映射到容器的5000端口，具体如下：
$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py
3dd912f95d222d9f9a0331db688c9ed2b58b450637851d32baa43a1908271bd9
这里成功返回容器ID，说明执行正确。通过docker ps命令，我们可以查看具体情况：
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
3dd912f95d22 training/webapp:latest "python app.py" 30 seconds ago
Up 29 seconds 127.0.0.1:5000->5000/tcp backstabbing_turing
这里我们将宿主主机的环回地址上的5000端口和容器的5000端口进行映射。
 ip::containerPort：指定IP的随机端口映射到容器的指定端口。例如，我们想把容器内
的5000端口和环回地址上的随机端口进行映射，可以这么做：
$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py
8ea0edbe514c0a7a65cdeef1f7b66113d4aa52a2bb3a3a19dade1b320a236e29
我们发现映射成功。通过docker ps命令查看详情：
$ docker ps
CONTAINER ID IMAGE COMMAND CREATED
STATUS PORTS NAMES
8ea0edbe514c training/webapp:latest "python app.py" 16 seconds ago
Up 16 seconds 127.0.0.1:49153->5000/tcp drunk_ptolemy
可以发现，Docker为我们随机分配了环回地址上的49153端口和容器的5000端口进行绑
定。我们可以将环回地址替换成宿主主机上的其他IP地址。
当容器暴露多个端口的时候，我们可以对每个端口一一进行映射。
例如，我们想将宿主主机上的5000端口和容器内的5000端口映射，4000端口和容器内的80
端口映射，具体为：
4.1 容器网络基础 53
$ docker run -d -p 5000:5000 -p 4000:80 training/webapp python app.py
1
cf9c2732c68ee862faa5ba6c237c48491312b96448cbabcadf67a979da2d07dc
成功返回后，使用docker ps命令查看映射详情：
2
docker ps
CONTAINER ID IMAGE COMMAND CREATED
3
STATUS PORTS NAMES
cf9c2732c68e training/webapp:latest "python app.py" 11 seconds ago
Up 10 seconds 0.0.0.0:4000->80/tcp, 0.0.0.0:5000->5000/tcp hopeful_kirch
4
可以看到，4000端口和80端口映射，5000端口和5000端口映射。
5
4.1.2 查看网络配置
6
在第2章中，我们介绍过，通过docker inspect命令可以查看容器的配置信息。这里我们可以
根据格式化过滤查看容器中网络相关的配置，相关代码如下：
7
$ docker inspect --format '{{.NetworkSettings}}' cf9c27
map[PortMapping: Ports:map[5000/tcp:[map[HostIp:0.0.0.0 HostPort:5000]]
9
80/tcp:[map[HostIp:0.0.0.0 HostPort:4000]]] Bridge:docker0 Gateway:172.17.42.1 IPAddress:172.17.0.12
IPPrefixLen:16 MacAddress:02:42:ac:11:00:0c]
可以看到端口映射、网桥、网关、IP以及物理地址等信息。 8
此外，也可以直接使用docker inspect命令找到相应的字段，操作为：
10
$ docker inspect cf9c27
得到的输出如下： 10
"NetworkSettings": {
"Bridge": "docker0", 11
"Gateway": "172.17.42.1",
"IPAddress": "172.17.0.12",
"IPPrefixLen": 16, 13
"MacAddress": "02:42:ac:11:00:0c",
"PortMapping": null,
"Ports": {
14
"5000/tcp": [
{
"HostIp": "0.0.0.0",
15
"HostPort": "5000"
}
],
"80/tcp": [ 16
{
"HostIp": "0.0.0.0",
"HostPort": "4000" 17
}
]
} 18
},
54 第4章 数据卷及容器连接
这种JSON形式的数据展示层次相对清晰，更为易读。但直接使用docker inspect命令就意味
着所有信息都将列出，所以两种方式各有所长和不足。
如果你仅仅需要查看该容器的IP地址，可以这样：
$ docker inspect --format '{{.NetworkSettings.IPAddress}}' cf9c27
172.17.0.12
我们可以在宿主主机ping该地址：
$ ping 172.17.0.12
PING 172.17.0.12 (172.17.0.12) 56(84) bytes of data.
64 bytes from 172.17.0.12: icmp_seq=1 ttl=64 time=0.069 ms
64 bytes from 172.17.0.12: icmp_seq=2 ttl=64 time=0.039 ms
64 bytes from 172.17.0.12: icmp_seq=3 ttl=64 time=0.050 ms
64 bytes from 172.17.0.12: icmp_seq=4 ttl=64 time=0.043 ms
^C
--- 172.17.0.12 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 2997ms
rtt min/avg/max/mdev = 0.039/0.050/0.069/0.012 ms
网络可达。
4.2 数据卷
数据卷是一个可供一个或多个容器使用的特殊目录，使用它可以达到如下目的。
 绕过“拷贝写”系统，以达到本地磁盘I/O性能。
 绕过“拷贝写”系统，有些文件不需要在docker commit的时候打包进镜像中。
 在多个容器之间共享目录。
 在宿主和容器之间共享目录。
 在宿主和容器之间共享单个文件（可以是socket）。
在这一节中，我们将讲解如何创建一个数据卷、共享一个数据卷以及在多个容器之间共享宿
主主机目录。
4.2.1 创建数据卷
可以通过两种方式来创建数据卷，具体如下所示。
 在Dockerfile中，使用VOLUME指令，如：
...
VOLUME /var/lib/postgresql
...
 在命令行中使用docker run时，使用-v参数来创建数据卷并将其挂载到容器中，具体操作为：
4.2 数据卷 55
$ docker run -d -P -v /webapp training/webapp python app.py
1