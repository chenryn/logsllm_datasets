    LOAD:0A04B0EB loc_A04B0EB:                      ; CODE XREF: LOAD:0A04B098↑ j
    LOAD:0A04B0EB                mov     edi, 0C7810D98h
这个例子执行了一次调用（➊，使用跳转会更加方便），调用对象在现有指令的中间（➋）。由于IDA 认为这个函数调用将会返回，它继续反汇编地址 0A04B0D6
 （➋）处的指令（并不正确）。调用指令的真正目标——loc_A04B0D6+1(0A04B0D7) ——
 将不会被反汇编，因为相关字节已经作为0A04B0D6
 处的 5 字节指令的一部分分配。如果注意到这种情况，剩下的反汇编代码清单应引起我们的怀疑。其他证据包括出人意料的用户空间指令（➌，这里为 iret
2
 ）及杂项数据类型（➍）。
2. x86 iret
 指令用于从一个中断处理例程返回。中断处理例程最常见于内核空间。
注意，这种行为并不仅限于 IDA 。无论它们使用的是递归下降算法还是线性扫描算法，几乎所有反汇编器都会成为这种技巧的受害者。
处理这种情况的正确方法是对包含调用目标字节的指令取消定义，然后在调用目标地址处定义一条指令，以重新同步反汇编代码清单。当然，使用交互式反汇编器可大大简化这个过程。使用IDA ，将光标放在处，应用 Edit ▶Undefine（热键 U），然后将光标放在0A04B0D7
 地址处，应用Edit ▶Code（热键C），可以得到下面的代码：
   LOAD:0A04B0D1                 call    loc_A04B0D7  
   LOAD:0A04B0D1 ;------------------------------------------------------------  
➊  LOAD:0A04B0D6                 db 0C7h ; ¦  
   LOAD:0A04B0D7 ;------------------------------------------------------------  
   LOAD:0A04B0D7  
   LOAD:0A04B0D7 loc_A04B0D7:                     ; CODE XREF: start+11↑ p  
➋  LOAD:0A04B0D7                 pop     eax  
   LOAD:0A04B0D8               lea     eax, [eax+0Ah]  
   LOAD:0A04B0DB  
   LOAD:0A04B0DB loc_A04B0DB:                     ; CODE XREF: start:loc_A04B0DB ↑ j
➌  LOAD:0A04B0DB                jmp     short near ptr loc_A04B0DB+1  
   LOAD:0A04B0DB start          endp  
   LOAD:0A04B0DB  
   LOAD:0A04B0DB ;------------------------------------------------------------  
   LOAD:0A04B0DD                db 0E0h ; a
从这个代码段中，我们发现，很明显，地址0A04B0D6
 （➊）处的字节从未执行。地址 0A04B0D7
 （➋）（调用目标）的指令用于从栈上删除返回地址（来自虚假调用），然后执行继续。值得注意的是，不久之后，我们这里讨论的反逆向工程技巧又被重新利用，这次它使用的是地址0A04B0DB
 （➌）处的一个 2 字节跳转指令，它实际上跳转到自身之中。这时，我们同样必须取消一条指令的定义，以到达下一条指令的开始位置。再一次应用取消定义（地址 0A04B0DB
 处）和重新定义（地址 0A04B0DC
 处）过程，得到下面的反汇编代码清单：
➋  LOAD:0A04B0D7                 pop     eax  
➌  LOAD:0A04B0D8                 lea     eax, [eax+0Ah]  
   LOAD:0A04B0D8 ; --------------------------------------------------------------  
   LOAD:0A04B0DB                 db 0EBh ; d  
   LOAD:0A04B0DC ; -------------------------------------------------------------- 
➊  LOAD:0A04B0DC                 jmp     eax  
   LOAD:0A04B0DC start           endp
结果，跳转指令的目标是另一条跳转指令（➊）。但是，反汇编器不可能跟踪这里的跳转（分析人员也会感到困惑），因为跳转的目标包含在寄存器（EAX）中，并在运行时计算。这是另一种类型的反静态分析技巧，将在 21.1.2 节中讨论。在这个例子中，鉴于在跳转之前的指令序列相对简单，确定 EAX寄存器包含的值并不是非常困难。➋处的pop
 指令将前一个例子中调用指令（0A04B0D6
 ）的返回地址加载到 EAX寄存器中，随后的指令（➌）再给 EAX加上 10。因此，跳转指令的目标为 0A04B0E0
 ，我们必须从这个地址恢复反汇编过程。
最后一个去同步的例子摘自一个不同的二进制文件，它说明如何使用处理器标志将条件跳转转换成绝对跳转。下面的反汇编代码清单说明如何使用 x86 Z 标志实现这个目的：
➊  .text:00401000                 xor     eax, eax  
➋  .text:00401002                 jz      short near ptr loc_401009+1  
➌  .text:00401004                 mov     ebx, [eax]  
➍  .text:00401006                 mov     [ecx-4], ebx  
  .text:00401009  
  .text:00401009 loc_401009:                      ; CODE XREF: .text:00401002↑ j
➎  .text:00401009                 call    near ptr 0ADFEFFC6h  
  .text:0040100E                 ficom   word ptr [eax+59h]
这里的xor 指令（➊）用于清零 EAX寄存器和设置 x86 Z 标志。知道设置 Z 标志后，程序员利用一个始终被接受的“遇零跳转”（jz）指令（➋）实现无条件跳转。因此，跳转与跳转目标之间的指令➌和➍从未执行，仅起到迷惑分析人员的作用。值得注意的是，这个例子同样通过跳转到一条指令中间（➎），隐藏了真实的跳转目标。正确反汇编后的代码如下所示：
  .text:00401000                 xor     eax, eax  
  .text:00401002                 jz      short loc_40100A  
  .text:00401004                 mov     ebx, [eax]  
  .text:00401006                 mov     [ecx-4], ebx  
  .text:00401006 ; -------------------------------------------------------------  
➋  .text:00401009                 db 0E8h ; F  
  .text:0040100A ; -------------------------------------------------------------  
  .text:0040100A  
  .text:0040100A loc_40100A:                       ; CODE XREF: .text:00401002↑ j
➊  .text:0040100A                 mov     eax, 0DEADBEEFh  
  .text:0040100F                 push    eax  
  .text:00401010                 pop     ecx  
由于额外的字节（➋）首先导致了去同步，跳转的真实目标（➊）已经显露出来。当然，在执行条件跳转之前，你可以使用更加迂回的方式设置和检查标志。在检查CPU 标志位的值之前，影响标志位的操作数量越多，分析这类代码的困难程度就越大。
21.1.2 动态计算目标地址
请不要将本节的标题与反动态分析技巧混淆。这里的“动态计算”指接下来的执行地址在运行时计算得出。在本节中，我们讨论几种获取这种地址的方法。这类技巧的目的是隐藏（模糊）一个二进制文件的真实控制流路径，以阻止他人进行静态分析。
上一节中有一个应用这种技巧的例子。这个例子使用一个 call
 语句将一个返回地址压入栈中。然后，这个返回地址直接由栈进入寄存器，再给寄存器加上一个常量值，得到最后的目标地址。最终，通过执行一个跳转指令，跳转到寄存器内容指定的位置，再到达目标地址。
我们可以开发无数类似的代码序列，获得一个目标地址，并将控制权转交给这个地址。下面的代码将最初的启动顺序包装在 Shiva中，提供了另一种动态计算目标地址的方法：
    LOAD:0A04B3BE                 mov     ecx, 7F131760h  ; ecx = 7F131760  
    LOAD:0A04B3C3                 xor     edi, edi        ; edi = 00000000  
    LOAD:0A04B3C5                 mov     di, 1156h       ; edi = 00001156  
    LOAD:0A04B3C9                 add     edi, 133AC000h  ; edi = 133AD156  
    LOAD:0A04B3CF                 xor     ecx, edi        ; ecx = 6C29C636  
    LOAD:0A04B3D1                 sub     ecx, 622545CEh  ; ecx = 0A048068  
    LOAD:0A04B3D7                 mov     edi, ecx        ; edi = 0A048068  
    LOAD:0A04B3D9                 pop     eax  
    LOAD:0A04B3DA                 pop     esi  
    LOAD:0A04B3DB                 pop     ebx  
    LOAD:0A04B3DC                 pop     edx  
    LOAD:0A04B3DD                 pop     ecx  
➊  LOAD:0A04B3DE                 xchg    edi, [esp]      ; TOS = 0A048068  
    LOAD:0A04B3E1                 retn                    ; return to 0A048068
右边的注释记录了每一条指令对各种 CPU 寄存器所做的更改。这个过程以一个获取到的值被移入栈顶部（TOS
 ）而告终（➊ ），从而使返回指令将控制权转交给计算得出的位置（这里为0A04B068
 ）。这样的代码序列能够显著增加静态分析的工作量，因为分析人员必须动手运行代码，才能确定程序的具体控制流路径。
近些年来，我们已经开发并利用更加复杂的控制流隐藏技巧。在最复杂的情形中，一个程序将使用多个线程或子进程计算控制流信息，并通过某种形式的进程间通信（对于子进程）或线程同步（对于多线程）接收这些信息。在这类情况下，进行静态分析将会非常困难，因为你不仅需要理解多个可执行实体的行为，而且需要了解这些实体交换信息的方式。例如，一个线程在一个共享的semaphore3
 对象上等待，而第二个线程则计算值或修改代码，一旦第二个线程通过semaphore 发出操作完成的信号，第一个线程将利用第二个线程的操作结果。
3. 可以把一个semaphore 看成是一个令牌，在进入一个房间执行某种操作之前，你必须拥有这个令牌。如果你拥有这个令牌，其他人将不能进入房间。当你在房间中完成任务后，你可以离开，并将令牌交给其他人，然后，这个人将进入房间，并利用你刚刚完成的工作（你并不知道这一点，因为你这时并不在房间内）。semaphore 常用于对程序的代码或数据实施互斥锁。
另一种技巧常用在面向 Windows 的恶意软件中，它配置一个异常处理程序4
 ，并有意触发一个异常，然后在处理异常时操纵进程的寄存器的状态。下面的例子被tElock 反逆向工程工具用于隐藏程序的真实控制流：
4. 有关 Windows结构化异常处理（SEH ）的更多信息，参见 http://www.microsoft.com/msj/0197/exception/exception.aspx
 。
➊  .shrink:0041D07A        call    $+5  
➋  .shrink:0041D07F        pop     ebp  
➌  .shrink:0041D080        lea     eax, [ebp+46h]  ; eax holds 0041D07F + 46h  
  .shrink:0041D081        inc     ebp  
➍  .shrink:0041D083        push    eax  
  .shrink:0041D084        xor     eax, eax  
➎  .shrink:0041D086        push    dword ptr fs:[eax] 
➏  .shrink:0041D089        mov     fs:[eax], esp
➐  .shrink:0041D08C        int     3               ; Trap to Debugger
  .shrink:0041D08D        nop
  .shrink:0041D08E        mov     eax, eax
  .shrink:0041D090        stc
  .shrink:0041D091        nop
  .shrink:0041D092        lea     eax, ds:1234h[ebx*2]
  .shrink:0041D099        clc
  .shrink:0041D09A        nop
  .shrink:0041D09B        shr     ebx, 5
  .shrink:0041D09E        cld
  .shrink:0041D09F        nop
  .shrink:0041D0A0        rol     eax, 7
  .shrink:0041D0A3        nop
  .shrink:0041D0A4        nop
➑  .shrink:0041D0A5        xor     ebx, ebx
➒  .shrink:0041D0A7        div     ebx             ; Divide by zero
  .shrink:0041D0A9        pop     dword ptr fs:0
首先，这段代码使用一个调用指令（➊）调用下一条指令（➋），这个调用指令将 0041D07F
 作为返回地址压入栈中，随后这个返回地址立即由栈进入 EBP 寄存器（➋）。接下来（➌），EAX寄存器被设置为 EBP 和46h
 的和，即0041D0C5
 ，并将这个地址作为一个异常处理函数的地址压入栈中（➍ ）。剩下的异常处理程序设置在➎ 和➏ 处发生，它们将新的异常处理程序链接到由fs:[0]
5
 引用的现有异常处理程序链中。下一步是有意生成一个异常（➐），这里为 int 3
 ，它是调试器使用的一个软件陷阱（中断）。在 x86 程序中，int 3
 指令被调试器用于实现一个软件断点。正常情况下，这时一个依附于进程的调试器将获得控制权。实际上，如果一个调试器已经依附于进程，它将有机会第一个处理异常（把它看成是一个断点）。在这个例子中，程序已做好处理异常的准备，因此，任何依附的调试器应将异常递交给程序处理。无法使程序处理异常可能会导致错误操作，甚至会使程序崩溃。如果不了解如何处理int 3
 异常，你将无法知道这个程序下一步将如何执行。如果我们假定程序会在int 3
 后继续执行，那么最终指令➑和➒将触发一个“除以零”异常。
5. Windows 配置FS寄存器指向当前线程环境块（TEB ）的基址。TEB 中的第一项（偏移量为 0）是一个指向异常处理函数的指针链接表中的第一个指针，如果程序中出现异常，即调用上面的异常处理函数。
与前面的代码有关的异常处理程序从地址 0041D0C5
 开始。这个函数的第一部分如下所示：
    .shrink:0041D0C5 sub_41D0C5      proc near     ; DATA XREF: .stack:0012FF9C ↑o  
    .shrink:0041D0C5  
  .shrink:0041D0C5 pEXCEPTION_RECORD  = dword ptr  4  
  .shrink:0041D0C5 arg_4               = dword ptr  8  