port [38].
378
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply. 
3.4. Proofs of Security Properties in FABLE
As mentioned in the introduction, FABLE does not, in
and of itself, guarantee that well-typed programs implement
a particular security policy’s semantics correctly. That said,
FABLE has been designed to facilitate proof of such theo-
rems. To illustrate how, we chose to use three very differ-
ent techniques for each of the correctness results reported
here. We conclude from our experience that the metatheory
of FABLE provides a useful repository of lemmas that can
naturally be applied in showing the correctness of various
policy encodings. As such, we believe the task of construct-
ing a correctness proof for a FABLE policy to be no more
onerous, and possibly considerably simpler, than the corre-
sponding task for a special-purpose calculus that “bakes in”
the enforcement of a single security policy. In the remain-
der of this section, we report on our experience with each of
the three proofs and discuss preliminary progress towards
reasoning about proofs involving multiple policies.
In all our proofs, two key features of FABLE play a cen-
tral role. First, dependent typing in FABLE allows a pol-
icy analyst to assume that all policy checks are performed
correctly. For instance, when calling the access function
to access a value v of type t{acl}, the label expressing v’s
security policy must be acl, and no other. The type sys-
tem ensures that the application program cannot construct a
label, say ACL(Public), and trick the policy into believing
that this label, and not acl, protects v; i.e., dependent typing
rules out confused deputies [6]. Second, the restriction that
application code cannot directly inspect labeled resources
ensures that a policy function must mediate every access of
a protected resource. Assuring complete mediation is not
unique to FABLE— Zhang et al. [45] used CQual to check
that SELinux operations on sensitive objects are always pre-
ceded by policy checks and Fraser [15] did the same for
Minix. However, the analysis in both these instances only
ensures that some policy check has taken place, not neces-
sarily the correct one. As such, these other techniques are
vulnerable to ﬂaws due to confused deputies.
When combined with these two insights, our proof of
non-observability for the access control policy (in our tech-
nical report [38]) is particularly simple. In essence, the FA-
BLE system ensures that a value with labeled type must be
treated abstractly by the application program. With this ob-
servation, the proof proceeds in a manner very similar to a
proof of value abstraction [18]. This is a general semantic
property for languages like FABLE that support parametric
polymorphism or abstract types. Indeed, the policy as pre-
sented in Figure 3 could have been implemented in a lan-
guage like ML, which also has these features. For instance,
an integer labeled with an access control list could be rep-
resented in ML as a pair consisting of an access control list
and an integer with type (string list ×int). A policy module
could export this pair as an abstract type, preventing ap-
plication code from ever inspecting the value directly, and
provide a function to expose the concrete type only after
a successful policy check. While such an encoding would
sufﬁce for the simple policy of Figure 3, it would not work
for other idioms like the function access cap of Section 3.1,
which reveals some of the structure of a label to avoid the
need for additional checks. Abstract types on their own are
also insufﬁcient to support static checking of policies, as in
the case of information ﬂow.
To show dependency correctness (in our technical re-
port [38]) we followed a proof technique used by Tse and
Zdancewic [40]. This technique involves deﬁning a logical
relation [28] that relates terms whose set of provenance la-
bels include the same label l. Recall that our goal in this
theorem is to show that given x:Prov t (cid:96)c e : t that σ1(e) is
related to σ2(e), where σi substitutes a provenance labeled
value vi for x in e. The crux of this proof involves showing
that the logical relation is preserved under substitution—
i.e., a form of substitution lemma for the logical relation.
While constructing the infrastructure to deﬁne the logical
relation requires some work, strategic applications of stan-
dard substitution lemma for FABLE can be used to discharge
the proof without much difﬁculty.
While it would be possible to reuse our infrastructure
for the dependency correctness proof to show the nonin-
terference result for the static information ﬂow policy (as
in Tse and Zdancewic), we choose instead to use another
technique, due to Pottier and Simonet [30] (in our technical
report [38]). This technique involves representing a pair of
executions of a FABLE program within the syntax of a sin-
gle program and showing a subject reduction property holds
true. As with the logical relations proof, once we had con-
structed the infrastructure to use this technique, the proof
was an easy consequence of FABLE’s preservation theorem.
All our correctness theorems impose the condition that
an application program be “([])-free”. That is, these theo-
rems apply only to situations where a single policy is in ef-
fect within a program. However, in practice, multiple poli-
cies may be used in conjunction and we would like to reason
that interactions between the policies do not result in viola-
tions of the intended security properties. To characterize
the conditions under which a policy can deﬁnitely be com-
posed with another, we deﬁned a simple type-based crite-
rion, which when satisﬁed by two (or more) policies πP and
πQ, implies that neither policy will interfere with the func-
tioning of the other policy when applied in tandem to the
same program.
Intuitively, a policy can be made composable by enclos-
ing all its labels within a unique top-level label constructor
that can be treated as a namespace. A policy that only ma-
nipulates labels and labeled terms that belong to its own
namespace can be safely composed with another policy.
379
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply. 
The main beneﬁt of compositionality is modularity; when
multiple composable policies are applied to a program, one
can reason about the security of the entire system by con-
sidering each policy in isolation. Policy designers that are
able to encapsulate their policies within a namespace can
package their policies as libraries to be reused along with
other policy libraries.
Our notion of composition is a noninterference-like
property—a policy is deemed composable if it can be shown
not to depend on, or inﬂuence the functioning of another
policy. As with noninterference properties in other contexts,
this condition is often too restrictive for many realistic ex-
amples in which policies, by design, must interact with each
other. We ﬁnd that policies that do not compose according
to this deﬁnition perform a kind of declassiﬁcation (or en-
dorsement) by allowing labeled terms to exit (or unlabeled
terms to enter) the policy’s namespace. We conjecture that
the vast body of research into declassiﬁcation [33] can be
brought to bear here in order to recover a degree of modu-
larity for interacting policies. Our technical report [38] con-
tains the formal statement and proof of the policy noninter-
ference theorem and further discussion of the applicability
of this condition.
Finally, although we have focused on bisimulation prop-
erties in this paper, we believe that our approach is also
likely to be useful in proving other kinds of security prop-
erties. For instance, we have recently begun investigating
the enforcement of information release protocols by adding
afﬁne types to FABLE [39]. We formulate these protocols in
terms of security automata used as a kind of typestate [36].
We have been able to prove that type-correct programs pro-
duce execution traces that contain event sequences in com-
pliance with speciﬁc information release protocols. We
have also found other forms of substructural types to be
useful. Our technical report [38] sketches the use of rele-
vant types to track side-effects in programs that manipulate
references to mutable state.
4 SELINKS: FABLE for Web Programming
We have implemented FABLE as an extension to the
LINKS functional web-programming language [12]; we
call our extension Security-Enhanced LINKS, or SELINKS.
This section brieﬂy describes our SELINKS implementation
and presents our experience using it to build two applica-
tions, a wiki SEWIKI and an on-line store SEWINESTORE.
4.1. SELINKS
LINKS is a new programming language with which a
programmer can write an entire multi-tier web application
as a single program. The compiler splits that program into
components to run on the client (as JavaScript), server (as a
local fragment of LINKS code), and database (as SQL). By
extending LINKS with FABLE’s label-based security poli-
cies, we can build applications that police data within and
across tiers, up to the level of trust we have in those tiers. In
our test applications we assume the server and database are
trusted but the client is not.
LINKS is a functional programming language equipped
with standard features such as recursive variant types, pat-
tern matching, parametric polymorphism, and higher-order
functions. As such, the FABLE policies we have presented
so far transliterate naturally into SELINKS. One difference
is that rather than deﬁne a special type lab as in FABLE, in
SELINKS we allow arbitrary expressions to be treated as
labels. The examples in this paper can be represented in
SELINKS using expressions with a variant type as a label.
Our applications make use of variants, strings, integers, lists
and records to more easily construct and inspect labels.
SELINKS also provides native support for the syntac-
tic shorthands shown in Figure 2. Type abbreviations in
LINKS have been extended in SELINKS to support abbrevi-
ations of dependent types. Policy functions are designated
by the qualiﬁer policy, as in the examples of this paper. We
also provide native support for dependent tuples in terms
of existential packages rather than requiring the program-
mer to encode them with higher-order functions. While this
makes dependent tuples easier to use, existential packages
in SELINKS must still be carefully manipulated using ex-
plicit pack and unpack operations.
Finally, although LINKS makes heavy use of type infer-
ence, in SELINKS we rely on annotations to check code that
manipulates security labels and labeled types. However, we
provide limited but convenient forms of inference to sim-
plify programming and cut down on annotations. For in-
stance, instantiations of phantom label variables are always
inferred and, in many common cases, pack and unpack op-
erations can also be inferred. Additionally, code that does
not use our type extensions can still beneﬁt from standard
LINKS type inference.
4.2. SEWIKI and SEWINESTORE
SEWIKI is an on-line document management system in-
spired by Intellipedia, a set of web applications designed to
promote information sharing throughout the United States
intelligence community [31]. SEWIKI consists of approx-
imately 3500 lines of SELINKS code. It enforces a ﬁne-
grained combination of a group-based access control pol-
icy and a provenance policy on documents. A document is
represented as a n-ary tree according to the following type
deﬁnition:
typename Doc = Node of [Doc] | Leaf of String
| Labeled of (l:DocLabel ×Doc{l})
380
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply. 
Here, [t] is SELINKS notation for a list of t-typed values.
The Labeled constructor allows nodes to have a security la-
bel according to the dependent pair (l:DocLabel × Doc{l}).
The type DocLabel is the type of security labels for docu-
ments.
typename Group = Authors | Auditors | Administrators
typename Acl = ( read:[Group], write:[Group] )
typename DocLabel = ( acl: Acl, prov: Prov )
DocLabel is a record with the ﬁelds acl and prov for storing
access control and provenance labels respectively. The type
Acl is itself a record containing two ﬁelds, read and write,
that maintain the list of groups authorized to read and mod-
ify a document node, respectively. At the moment, we have
three groups: Authors, in which all document authors are
members; Auditors, the group of users that are trusted to au-
dit a document; and Administrators, which include only the
system administrators. We implement authentication cre-
dentials as terms of the type Cred (not shown). This type is
similar to the type of credentials produced by login in the
FABLE access control policy (Figure 3) except that Cred in-
cludes additional useful information such as the user’s name
and unique identiﬁer.
Possible document modiﬁcations are mediated by the
write access policy function, which has the following type:
write access:∀ α,β . Cred →(f:α →β ) →(l:Acl) →α{l} →β{l}
This function allows a caller to pass in a user’s credential
and a function f that is intended to modify a resource α
labeled with an access control label l. If write access de-
termines that the user is in the writer’s group of the Acl l,
the function f is applied and the policy relabels the modiﬁed
resource with the (access control) label of the original.
SEWIKI also includes a revision history tracking pol-
icy, similar in spirit to the provenance tracking policy of
Section 3.2. We track provenance through all operations
that alter a document while still enforcing the access con-
trol policy. We represent provenance information using the
Prov type shown below and store this information in the
prov ﬁeld of a DocLabel.
typename Op = Create | Edit | Delete | Restore | Copy | Relabel
typename Prov = [(oper:Op, user:User)]
The provenance label of a document node consists of a list
of operations performed on that node together with the iden-
tity of the user that authorized that operation. Tracked oper-
ations are of type Op and include document creation, modi-
ﬁcation, deletion and restoration (documents are never com-
pletely deleted in SEWIKI), copy-pasting from other doc-
uments, and document relabeling. For the last, authorized
users are presented with an interface to alter the access con-
trol labels that protect a document.
Policy functions that enforce this composite policy are
fairly modular. For instance, a policy function that medi-
ates modiﬁcation of a document ﬁrst projects out the acl
component of the label and calls write access to ensure that
the modiﬁcation is authorized. It then records the Edit op-
eration in the prov ﬁeld of the edited document’s label.
In addition to building SEWIKI, we extended the “wine
store” e-commerce application that comes with LINKS by
creating labels to represent users and associating such la-
bels with orders in a shopping cart and order history. This
helps ensure that an order is only accessed by the customer
who created it. As in the SEWIKI, the user’s credential is
represented using Cred; order information is deﬁned below.
The policy functions to view and add items to an order are
implemented as simple wrappers around the same read and
write access policies used in the SEWIKI.
typename Order = (l:Acl ×List(CartItem){l})