状况系统（condition system）。由于前者的存在，只需花较少的时间就能让编译器把代码跑起来，
周期而停滞下来。?
程序交互。编写新函数、测试它、修改它、尝试不同的实现方法，从而使思路不会因漫长的编译
工作机制还不甚明了，CommonLisp提供了一些特性可以有助于实现递进的交互式开发。
不必再花时间在语言的限制里寻求更简洁的方式来表达想法了。
通过对实际代码作相对少量的修改来实现。这也意味着可以更快速地开发，编写更少的代码，也
因为不必在每次修改之前都先复查大量的相关代码。甚至，对程序行为的系统化调整也经常可以
上。想法永远不会被过于紧凑的代码和不断重复的模式搞得含糊不清。这将使代码更加易于维护，
编写的特性，因为正如你将在本书中看到的，你可以为语言添加任何想要的特性。
用CommonLisp编程的时候，你永远不会遇到这种情况：语言里刚好缺乏某些可能令程序更容易
他任何语言都更加遵循一种哲学一
些，但这句话却道出了CommonLisp至今仍然雄踞其他语言之上的最大优势。CommonLisp比其
感受它。眼下，我只想让你先对Lisp哲学有个大致的感受。
③至少对某些人来说，这个观点很可能有争议。静态和动态类型的信仰之争在编程领域由来已久。如果你信奉C+
①遗憾的是，在不同语言的生产力方面几乎没有实际的研究。
其他支持连贯的交互式编程风格的语言特性，还包括Lisp的动态类型机制以及CommonLisp
比如，将在下一章介绍的交互式“读-求值-打印”循环，它可以让你在开发过程中持续地与
CommonLisp也是一门适合做探索性编程的优秀语言。如果在刚开始编写程序的时候对整个
?
因此，CommonLisp程序倾向于把关于程序如何工作的想法更清楚地映射到实际所写的代码
我描述的。另一方面，信奉SmallTalk、Python、Perl或者Ruby的人们应该会对CommonLisp的这方面感觉良好。
C++ApplicationsUsingtheBoochMethod(PrenticeHall，1995年）的作者]以及C++和Java领域的作者Bruce
可能会就此合上本书了。不过，在此之前，你最好先查查“静态类型偏执狂”RobertMartin[DesignObjectOriented
该了解它的一个理由。
能跟吵闹的电话铃或者爱管闲事的老板同样有害。因此，Lisp作为一种可以令你保持连贯状态的语言，也是你应
都很反感诸如电话铃和老板的贸然来访这类破坏连贯性的打岔。较少被考虑到但可能对程序员同样重要的是我们
Hourse，1987年）里讨论过。连贯性的两个关键因素是人们需要15分钟才能进入连贯性状态，而即便短暂的打岔
有成果的项目和团队》（Peopleware：ProductiveProjectsandTeams，TomDemarco和TimothyLister著，Dorset
对于编程的重要性在近二十年以前就已经被认识到了，其最早在一本经典的关于编程的人为因素的书《人件：富
心理学家已经鉴别出大脑的一种称为连贯性（flow）的状态，这时我们可以产生高度的注意力和生产力。连贯性
于C++和Java脱颖而出的报告在http://www.norvig.com/java-lisp.html上有所讨论。
（http://www.artima.com/weblogs/viewpost.jsp?thread=4639和http://www.mindview.net/WebLog/log-0025）上是怎样自
Eckel[ThinkinginC++（PrenticeHall,1995年）和ThinkinginJava(PrenticeHall,1998年）的作者]在他们的博客
和Java（或者是诸如Haskell和ML的静态类型函数式编程语言），并且拒绝生活在没有静态类型检查的环境里，你
工具所造成的打岔，例如，那些在你测试最新代码之前需要经历长的编译过程的语言，其对于连贯性的影响可
也会使人完全退出这一状态，从而需要另外15分钟才能重新进入状态。DeMarco和Lister，以及多数后来的作者，
—凡利于语言设计者的也利于语言使用者。这就意味着，当使
www.TopSage.com
。一份阐明了在程序员和程序效率的组合上，Lisp相比
---
## Page 21
码总是要耗费大量的计算资源，而如果按照摩尔定律倒推20年，你就可以想象20世纪80年代的计
自身需要。
自动规划以及自然语言接口等问题。这些研究人员也在使用Lisp并且持续地对其进行改进以满足
高级研究规划局（DARPA）投人了大量资金，其中的相当一部分用于研究诸如大规模战场模拟
言，而他们就将Lisp发展成了这样一门语言。另外，冷战也起了积极的作用——五角大楼向国防
觉在内的各种难题。这些问题都需要大量难于编写的软件，为此，AI程序员们需要一门强大的语
程序员们所偏爱的工具，广泛用于编写软件来求解包括自动定理证明、规划和调度以及计算机视
里内置的很多特性，使其成为了AI编程的绝佳语言。在AI繁荣昌盛的20世纪80年代，Lisp始终是
怎么会进化出如此装备精良的语言来呢？
大的面向对象编程支持，以及其他编程语言里完全不存在的一些语言机制。这一切怎么可能呢？
19章里介绍的状况系统提供了Java、Python和C++等语言的异常系统里所没有的充分灵活性，强
从那时起，Lisp得到了长足的发展。Common Lisp引人瞩目地具备一系列现代数据类型：将在第
“符号数据处理”?，而Lisp这个名字本身就来源于其最擅长的工作：列表处理（LISt Processing)。
1.2Lisp 的诞生
Lisp将可以直接支持它而无需对基础语言作任何修改，并且也不需要额外的预处理器和编译器。
CommonLisp增加了对面向方面编程（AOP）的支持。?如果AOP将主宰编程的未来，那么Commor
核心部分的情况下将其吸纳进来。例如，最近有个Lisp程序员写了一个叫做AspectL的库，它为
其实际功能了。
移植的Common Lisp写成的库。而在这个库正式成为语言的一部分之前，Lisp程序员就可以体验
Common Lisp强大的对象系统CLOS（Common Lisp Object System），其最初的实现就是一个用可
地编写某些程序之外，对于那些从根本上改变编程方式的新思想的支持也是绰绰有余的。例如，
推动Lisp特性进化的动力也同样推动了其他相关领域的发展—大型的AI问题无论如何编
原来，McCarthy曾经是（现在也是）一名人工智能（AI）研究者，他在Lisp语言的最初版本
① AspectL是一个跟它的Java版前任Aspect同样有趣的项目，后者由Common Lisp对象和元对象系统的设计者之一
目前来看，无论下一个流行的编程范例是什么，Common Lisp都极有可能在无需修改其语言
③Lisp 1.5 Programmer's Manual （麻省理工学院出版社,1962年）
②
Common Lisp是1956年John McCarthy发明的Lisp语言的现代版本。Lisp在1956年被设计用于
作为一门“可编程的编程语言”，Common Lisp除了支持各种小修小补以便开发人员更容易
言的编译器。
或者我们可以从另一个技术上更精确的方面来看待这件事：CommonLisp提供了内置的功能以方便集成嵌人式语
Protocol）具有难以想象的灵活性。为了实现Aspect，Kiczales不得不写了一个单独的编译器，将一种新语言编译
然，他能够将AspectL以库的形式实现的根本原因在于，Kiczales所设计的CommonLisp元对象协议（Meta Object
植到了Java。尽管如此，AspectL的作者Pascal Costanza认为，AOP许多有趣的思想可能对Common Lisp有用。当
GregorKiczales所作。对许多Lisp程序员来说，Aspectu看起来就像是Kiczales尝试将其思想从Common Lisp向后移
第1章绪言：为什么是Lisp
www.TopSage.com
---
## Page 22
的。
那么一定要问问他们究竞在谈论哪种Lisp方言，以及他们是否是在计算机远古时代学到这些东西
些方面。如果有人告诉你Lisp只能被解释执行，因此会很慢，或者你不得不用递归来干每件事，
他们可能只是在McCarthy发明Lisp以来的近半个世纪中的某些特定时刻接触到了这门语言的某
问题的实用主义观点。Lisp“经典”遗产的唯一缺点是，许多人仍然生活在片面的Lisp背景之下，
想之上。°另一方面，它完全是一门现代的通用语言，其设计反映了尽可能高效可靠地求解实际
开放给其他人使用。在过去的几年里，开源Lisp库领域尤为活跃。
接字等。今天的Common Lisp则进化得更像其他的开源语言—用户可以编写他们所需要的库并
方式。一个完整的Lisp实现将带有丰富的运行时环境，并提供GUI微件、多线程控制和TCP/IP套
束：跟此前的CLL一样，ANSI标准有意为语言实现者保留一定的空间，以试验各种最佳的工作
展的Common Lisp标准，其中增加了一些主要的新特性，包括CLOS和状况系统。但事情还没结
言的基础上写成的。1996年，美国国家标准学会（ANSI）发布了一个建立在CLL之上并加以扩
（CLtL，Digital press，1984年）一书里，该书相当于Lisp的圣经。
Lisp的标准化Lisp语言。最后，他们的工作成果记录在了Guy Steele的Common Lisp the Language
黑客组成的草根组织于1981年成立，旨在结合既有Lisp方言之所长，定义一种新的称为Common
众多的Lisp系统和方言让DARPA开始担心Lisp社区可能走向分裂。为了应对这些担忧，一个由Lisp
编辑器、编译器，以及Lisp机上的大量其他软件。
以在芯片上直接运行Lisp的计算机系统。Lisp因此成了系统编程语言，被广泛用于编写操作系统、
的Lisp编译器所生成的机器码，完全可以跟C编译器生成的机器码相媲美。
来说再也不是问题了。不过，你在第32章可以看到，通过使用适当的（可选）变量声明，一个好
谢摩尔定律，今天我们从任何纯解释型语言里也能获得可接受的性能了，性能对于CommonLisp
Lisp实现就是这些早期工作的结晶，它们通常都带有相当专业的可产生原生机器码的编译器。感
算资源是何等的贫乏了。Lisp工作者们不得不想尽办法从实现中获得更多的性能。现代Common
事实上，到了20世纪80年代早期，几家AI实验室和Lisp机厂商都提供了他们自己的Lisp实现
20世纪80年代也是Lisp机的年代，当时好几家公司（其中最著名的是Symbolics）都在生产可
① 首先由Lisp引进的编程思想包括if/then/else控制结构、递归函数调用、动态内存分配、垃圾收集、第一类（first-class）
量上的显著增长。
力的是承载开源Common Lisp项目的Web站点Common-Lisp.net的成长，以及各种本地Lisp用户组过去几年里在数
有自动机器人真空吸尘器Roomba，其软件是用L语言写的，后者是Common Lisp的向下兼容子集。也许最有说服
上是用Naughty Dog发明的一种称为GOAL的特定领域Lisp方言写成的，其编译器本身是用Common Lisp写的：还
等使用的ITA Software的航空票务系统QPX；Naughty Dog运行在PlayStation 2上的游戏Jak and Daxter，在很大程度
泛，但把一个继续用于新的开发并且继续吸引新用户的语言描述成“已死”看起来有些奇怪。一些近期的Lisp成
关于Lisp的一个最常见的说法是该语言“已死”。虽然Common Lisp确实不如VisualBasic或者Java这些语言使用广
函数、词法闭包、交互式编程、增量编译以及动态类型。
www.TopSage.com
1.2
Lisp 的诞生
5
---
## Page 23
为已经确信Lisp并不比已知的其他语言更好，但由于不熟悉它而无法反驳那些Lisp程序员。如果
言都有哪些优势，那么本书应该可以提供一些思路。或者你根本就没打算使用Lisp—可能是因
好可以帮你走上正途。而另一方面，你也不必带着学以致用的目的来阅读本书。
书都挺适合你的。
1.3本书面向的读者
们无论与Scheme还是CommonLisp相比都是相当过时的Lisp方言了。如果你曾经用过这些方言
经写出了超过任何其他方言的代码行数，但它们都不能用在各自的宿主应用程序之外，而且它
Autolisp是Autodesk的AutoCAD计算机辅助设计工具的扩展语言。尽管用Elisp和Autolisp可能已
日后随着讨论的深入，我将指出其中最重要的差别。
犯错。这些差别也是Common Lisp和Scheme社区的狂热分子之间一些长期信仰之争的导火索。
如果学过Scheme，也应该当心，Scheme和CommonLisp之间的许多细微差别可能会使人
了，后者专门被设计成真实世界的工程语言，而不是一种理论上的“纯”语言。
Scheme具有这样的特征并不是很公正，只不过同样的说法用在CommonLisp身上更加不合适罢
里学过Lisp并且感觉它只是一种没有现实应用的学术语言，那你八成是学了Scheme。
写可移植的Common Lisp代码更加困难。
定的实现方式提供了这些特性，但它们在标准中的缺失则使得编写可移植的Scheme代码比编
问题是缺失了许多在CommonLisp里已经标准化了的有用特性。个别的Scheme实现者可能以特
地证明语言本身的有关命题。
核心尽可能地小而简单。这对作为教学语言来说非常有用，编程语言研究者们也很容易形式化
位成一种与CommonLisp有所不同的语言。特别是Scheme的设计者们将注意力集中在使其语言
Lisp从Scheme那里吸收了一些重要的特性，但从未试图取代它。
在何时何地认识Lisp的，很有可能你学的是某种其他方言。
CommonLisp取代了大多数它所继承下来的方言，但它并非仅存的Lisp方言。你要清楚自己是
如果你是个顽强的实用主义者，想知道Common Lisp相比Perl、Python、Java、C和C#这些语
如果你已经学会了一些Lisp，但却难于跨越从学术训练到真实程序之间的鸿沟，那么本书刚
这样设计的另一个好处是使得通过标准规范理解整个语言变得相对简单，但这样做带来的
如果你对Common Lisp感兴趣，那么无论是否已经确定要使用它或者只是想一窥其门径，本
Scheme同样强调函数式的编程风格，并且使用了比Common Lisp更多的递归。如果在大学
Scheme最早在MIT设计出来，然后很快用作本科计算机科学课程的教学语言，它一直被定
另外两种仍然广泛使用的Lisp方言是Elisp和Autolisp。Elisp是Emacs编辑器的扩展语言，而
如果你以前用过Lisp，你对Lisp的认识很可能对学习CommonLisp没什么帮助。尽管
第1章绪言：为什么是Lisp
www.TopSage.com
当然，说
---
## Page 24
上路吧。
每个人的Lisp之路都有所不同，但我还是希望本书可以帮助你少走些弯路。那么，让我们就此
已经用Common Lisp写出了一些非凡的程序，并且可以凭借自身力量继续探索该语言了。尽管
解析二进制文件、分类MP3、通过网络播放MP3流媒体，以及为MP3目录和服务器提供Web接口。
个更实用的章节，帮助你编写一些中等大小的程序来做一些你可能认为有用的事：过滤垃圾邮件、
述了该语言的绝大部分内容后一一包括某些在其他书里往往留给你自己去考查的内容，将给出九
部分，我将谈及语言本身，同时穿插一些实践性章节，展示如何编写真实的代码。接着，在我阐
Common Lisp赶不上自己当前喜爱的其他语言，那么你将有充分理由来说明自己的观点了。
是这样，本书将给你一个直奔CommonLisp主题的介绍。如果在读完本书以后，你仍然认为
我不但介绍了该语言的语法和语义，还讲述了如何使用它来编写有用的软件。在本书的第一
读完本书后，你将熟悉该语言的所有最重要的特性以及它们是如何组织在一起的，而且你
www.TopSage.com
1.3本书面向的读者
L
---
## Page 25
更进一步，对标准的改动必须在标准化组织美国国家标准学会（ANSI）所控制的程序下进行。
那样是由某个公司控制的公认实现。任何打算阅读标准并实现该语言的人都可以自由地这样做。
标准化的，既不像Perl和Python那样是由善良的专制者所控制的某个实现，也不像VB、C#和Java
C#和Java语言的人来说，可能有些奇怪。CommonLisp和这些语言的区别在于，CommonLisp是
2.1选择一个Lisp实现
的困难。
集成开发环境（IDE）还是基于其他编辑器的环境，在应用本书的内容时应该都不会有较大
aBox环境。而那些想要探索其他开发环境的人，无论是使用某些商业Lisp供应商的图形化
和CommonLisp实现无关。为了能有一个具体的开发环境来进行讲解，我将使用这个Lispin
是Lisp编程所特有的。SLIME环境提供了一个完全统一的用户接口，跟你所选择的操作系统
forEmacs）—构建在Emacs之上的CommonLisp开发环境。
且对Lisp较为友好的文本编辑器）的CommonLisp实现，以及SLIME（SuperiorLispInteractionMode
上述组合提供了一个全新的CommonLisp开发环境，可以支持增量、交互式的开发风格，这
①如果你之前不喜欢用Emacs，那你应该把LispinaBox当作一个刚好使用类Emacs编辑器作为文本编辑器的IDE，
首要的问题是选择一个Lisp实现。这对那些曾经使用诸如Perl、Python、
Initially。后来的版本使用了ZWEI的一个派生版，其名字ZMACS也缺乏想象力。
式沿用了使用递归缩略语的黑客传统，分别是EINE和ZWEI，意思是EINEIsNotEmacs以及ZWEIWasEINE
程序员们写成的。Lisp机上的编辑器是完全用Lisp写成的某些版本的Emacs。最早的两种Lisp机Emacs，其命名方
Lisp的历史和Lisp黑客的文化中：最初的Emacs和它的前身TECMACS和TMACS，是由麻省理工学院（MIT）的Lisp
是用一种叫做Elisp的Lisp方言写成的，所以它在相当程度上支持编辑Lisp代码。Emacs也在很大程度上参与到了
情。至少，你需要一个可以帮你自动匹配括号并且知道如何自动缩进Lisp代码的编辑器。因为Emacs本身大部分
你不需要先成为Emacs大师再写Lisp程序。不过，使用一个基本支持Lisp的编辑器来编写Lisp程序将是件有趣的事
θ
第2章
周而复始：REPL简介
www.TopSage.com
VisualBasic（VB)
---
## Page 26
产生稍有不同的错误信息或调试输出。
本书里给出的程序输出来自运行在GNU/Linux上的Allegro平台。在某些情况下，其他Lisp可能会
上，而SLIME通过为我们提供一个与Lisp交互的通用接口也可以消除不同实现之间的某些差异。
还有另外一些开源和商业实现，参见第32章以获取更多相关资源的信息。
择，它可编译到机器码、支持线程，并且可以跟Mac OS X的Carbon和Cocoa工具箱很好地集成。
更容易安装并且现在支持21位Unicode。?而对于Mac OSX用户来说，OpenMCL?是一个极佳的选
量代码采用伯克利软件分发（BSD）风格的协议。CMUCL本身也是个不错的选择，尽管SBCL
一种Common Lisp，并且像CMUCL那样，大部分源代码都处于公共域（public domain），只有少
Linux和Mac OS X。SBCL来源于CMUCL（CMU Common Lisp），最早由卡内基-梅隆大学开发的
是一个高质量的开源实现，它将程序编译成原生代码并且可以运行在广泛的Unix平台上，包括