program 
instance
Web application:  the union of a client-side browser instance and a remote Web service that cooperate to provide the user with 
some application function (e.g., online banking, Webmail)
distributed
application
Table 1. Terminology. This table explains key terms in the Tahoma architecture, and provides the closest analogous
term in a conventional operating system environment.
ifest includes several key pieces of information. First, it
presents a digital signature authenticating the Web service
to the client. Second, it speciﬁes the code that will run in the
browser instance; it can name a conventional Web browser,
or it can specify arbitrary code and data to be downloaded,
as described above. Third, it speciﬁes Internet access poli-
cies to be enforced by a reverse ﬁrewall. These network
policies deﬁne the set of Web sites or URLs that the browser
instance is allowed to access.
Network policies protect the Web application from com-
promised browsers. Browsers are easily compromised by
malicious plug-ins or through active Web content that ex-
ploits security holes in the browser or its extensions. A com-
promised browser could capture conﬁdential data ﬂowing
between the browser instance and its Web service and send
that information to an untrusted Internet site, or it could use
the browser instance as a base to attack other Internet hosts.
The network policy and reverse ﬁrewall aim to prevent these
attacks by restricting communication from the browser in-
stance to legitimate sites within the Web service.
Users accessing a Web application for the ﬁrst time must
approve its installation. Only then will Tahoma create a new
virtual machine, install within it the browser code and data,
and execute the new browser instance. The BOS caches ap-
provals, so the user need not re-approve a Web application
on subsequent executions.
2.2 The Browser Operating System
The browser operating system is the trusted computing
base for the Tahoma browsing system. It instantiates and
manages the collection of browser instances executing on
the client. To do this, it must multiplex the virtual screens
of each browser instance onto the client’s physical display,
enforce the network policies of each instance, and durably
store state associated with browser instances, bookmarks,
and manifests.
Figure 3 shows a detailed architectural view of the
browser operating system. The ﬁgure contains three Web
applications and their isolated browser instances. Two of
the browser instances contain conventional browsers, while
the third is executing a custom radio application instead of
a conventional Web browser.
The BOS provides the highest level user interface, let-
ting users manipulate the virtual screens of each browser
instance. In addition, it wraps each virtual screen with a bor-
der that the browser instance cannot occlude. In the border,
the BOS provides trusted information to the user, such as
the name and credentials of the Web application with which
the screen is associated. The BOS routes input events to
the appropriate browser instance, similar to the way con-
ventional window systems operate.
The BOS also provides users with control panels and
bookmark management tools. These let the user install, ex-
ecute, and uninstall Web applications, or create bookmarks
that point to documents within a Web application. A book-
mark has a familiar meaning in the context of a conventional
Web browser. However, a Web application that provides its
own custom browser instance may co-opt bookmarks for its
own purposes. For example, a streaming radio service could
use bookmarks to implement radio channels.
The BOS mediates all network interactions between a
browser instance and remote Web sites. To access the Web,
a browser instance invokes a BOS system call that fetches
Web documents over HTTP. The BOS will service the con-
nection only if the document falls within the network policy
speciﬁed in the instance’s manifest. If not, the BOS refuses
the request. If the document is allowed by the manifest of a
different Web application, the BOS gives the user the option
of loading it into that Web application’s browser instance.
Web applications have durable state that the BOS must
manage. Sandboxes provide private virtual disks to browser
instances, and the BOS maintains the state of these disks
between invocations of the Web application. It also stores a
set of “stock” browser instances (e.g., Mozilla) that can be
cloned when installing a Web application. Finally, the BOS
stores manifests and bookmarks associated with Web appli-
cations. It treats all long-term storage as a soft-state cache.
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:31 UTC from IEEE Xplore.  Restrictions apply. 
Bank
Web Mail
Radio
Mozilla
Konqueror
radio client
software
network
policy
network
policy
network
policy
screen
screen
screen
system
services
screen
aggregator
storage
manifests
bookmarks
sandbox state
Internet
sandbox
syscalls
Browser
Operating
System
physical
display
Figure 3. The browser operating system (BOS).
The BOS instantiates and manages sandboxes,
stores long-term state associated with browser in-
stances, enforces the network access rights of
browser
instances, and aggregates their virtual
screens into the client’s physical display.
Accordingly, durable state can be evicted, but at the cost
of having to re-download manifests or re-install browser in-
stances when the user next accesses a Web application.
We describe our implementation choices in Section 3.
However, the BOS is designed to be implementable in dif-
ferent ways. For example, it could run in its own virtual
machine, with browser instances running in separate virtual
machines with their own guest operating systems. Alterna-
tively, it could be implemented as a virtual machine monitor
running directly on the physical hardware, with browser in-
stances running in VMs above it.
2.3 Summary
The Tahoma architecture is driven by the principles de-
scribed in Section 1: distrust of Web browsers and appli-
cations, and the empowerment of users. The resulting ar-
chitecture isolates Web applications, protecting other ap-
plications and client resources from malicious downloaded
code.
In addition, it permits Web services to build safer,
more powerful Web applications. Overall, our goal is to ac-
cept the enhanced role of modern browsers in managing the
client-side components of complex, non-trusted, distributed
applications.
3
Implementation
This section describes the central components of our
Tahoma prototype implementation. These components in-
clude: the browser operating system, which consists of a
domain 0 VM
(domain 1 VM)
(domain 2 VM)
(domain 3 VM)
browser instance
browser instance
browser instance
BOS
WinMgr
tiny
tiny
tiny
proxy
proxy
proxy
BOS
“kernel”
Konqueror
Konqueror
l
i
b
B
O
S
l
i
b
Q
T
l
i
b
B
O
S
l
i
b
Q
T
Media
browser
l
i
b
B
O
S
l
i
b
Q
T
Linux
Linux
Linux
NetBSD
XML RPC
HTTP/TCP
Xen VMM
Internet
disk
memory
mouse
keyboard
screen
Figure 4. The Tahoma implementation. The
Xen virtual machine monitor isolates browser in-
stances by sandboxing them in virtual machines.
Processes running within the privileged “domain 0”
VM provide BOS services. Additional services are
provided by libraries embedded in browsers.
BOS kernel, a network proxy, and a window manager; the
browser instances; and the underlying Xen virtual machine
monitor.
3.1 Xen and the Browser Operating Sys-
tem
The Tahoma browser operating system is a trusted layer
that executes multiple browser instances, each within a
private, sandboxed execution environment. As shown in
Figure 4, our Tahoma implementation uses the Xen vir-
tual machine monitor (VMM) [4]. Xen is an open-source
VMM that provides para-virtualized x86 virtual machines.
It executes in the most privileged mode on bare hardware,
as shown in the ﬁgure. Above the VMM are individ-
ual virtual machines, which Xen names Domain0 through
DomainN. Each domain executes a guest operating sys-
tem, such as Linux, which runs at a lower privilege level
than the VMM. User-mode applications run on the guest
OS at the lowest privilege level.
Xen’s Domain0 is special;
it performs many of the
management functions for Xen, but outside of the VMM.
Domain0 has access to all physical memory. It can cre-
ate and destroy other domains, make policy decisions for
scheduling and memory allocation, and provide access to
network devices. In this way, many VMM supervisor func-
tions can be programmed as user-mode code on top of the
Domain0 guest operating system.
We implemented the Tahoma browser operating system
as a collection of processes that execute on Linux in the
Proceedings of the 2006 IEEE Symposium on Security and Privacy (S&P’06) 
1081-6011/06 $20.00 © 2006 IEEE 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 02:51:31 UTC from IEEE Xplore.  Restrictions apply. 
privileged Xen Domain0 VM, as shown in the upper left
of Figure 4. The three main BOS processes are: the BOS
kernel, which manages browser instances and the durable
storage of the system; the network proxy, a reverse ﬁre-
wall that enforces network access policies for Web applica-
tions; and the window manager, which aggregates browser
instance windows into the physical screen.
Each Tahoma browser instance executes in its own Xen
virtual machine. In Figure 4, the ﬁrst two browser instances
are running versions of the Konqueror Web browser, which
we ported to Tahoma, on top of a Linux guest OS. The third
browser instance is executing a custom multimedia browser
on a NetBSD guest OS. The browser instances interface to
the BOS through libraries linked into the browser that pro-
vide access to BOS system functions (libBOS) and graph-
ics functions (libQT). We describe libBOS below, libQT
in Section 3.4, and the browsers we implemented in Sec-
tion 3.5.
Browser instances must be able to communicate with the
Domain0 BOS processes, and vice versa. We use the term
browser-calls to refer to instance-to-BOS communications.
In the other direction, BOS-to-instance notiﬁcations are de-
livered as upcalls to the instances. Browser-calls are im-
plemented as XML-formatted remote procedure calls, car-
ried over a TCP connection. A point-to-point virtual net-
work link carries the RPCs between each instance and a
Domain0 BOS process. Because Xen restricts access to
point-to-point links to the two VMs involved, the BOS can
safely assume messages arriving on these links are authen-
tic; this resembles the way a traditional kernel uses the cur-
rent process ID to determine the origin of a system call. The
library libBOS contains RPC stubs that expose browser-
calls to applications as high-level function calls.
Most communication in Tahoma occurs within a Web ap-
plication, between a browser instance and its Web service.
However, the BOS provides three inter-application commu-
nication paths – fork, BinStore, and BinFetch – that are
implemented through browser-calls. Applications may fork
other applications. The fork browser-call includes the target
URL to be forked as an argument. Based on this URL, the
BOS kernel examines (or downloads) the appropriate man-
ifest and determines which browser instance should handle
the request. It then launches the browser instance, if needed,
and delivers the URL to the instance through an upcall.
The BOS supports strong VM-based isolation between
browser instances. However, it must also permit the con-
trolled transfer of objects outside of a VM. For example, a
user must be able to copy a photo from a Web-mail appli-
cation into a photo album, or vice versa. For this purpose,
the BOS kernel implements a private “holding bin” for each
browser instance. To manipulate the holding bin, the ker-
nel provides two browser-calls – BinStore and BinFetch.
A browser instance copies an object to its holding bin by
invoking the BinStore browser-call, specifying the object’s
URL, an object name, and a MIME type. Similarly, the
BinFetch browser-call lets the browser instance ﬁnd and re-
trieve an object from the holding bin. However, a transfer
between the holding bin and the host OS must be initiated
explicitly by a user through a trusted Tahoma tool; it can-
not be initiated by the browser instance. In this way, we
permit controlled transfers but prohibit code in the browser
instance from directly manipulating host OS resources.
3.2 Xen and the Browser Instance
Browser instances execute in Xen VMs, with Xen han-
dling the low-level details of CPU and memory isola-
tion. The BOS augments Xen by enforcing the manifest-
speciﬁed network policy of each browser instance. Browser
instances are therefore not provided with an unfettered In-
ternet link. Instead, a Xen (virtual) point-to-point network
link is established between the browser instance and the
Domain0 VM. In Domain0, we run an HTTP proxy pro-