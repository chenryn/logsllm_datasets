# 04 \| TCP三次握手：怎么使用套接字格式建立连接？你好，我是盛延敏，这里是网络编程实战第 4 讲，欢迎回来。在上一讲里我们介绍了 IPv4、IPv6以及本地套接字格式，这一讲我们来讲一讲怎么使用这些套接字格式完成连接的建立，当然，经典的TCP 三次握手理论也会贯穿其中。我希望经过这一讲的讲解，你会牢牢记住 TCP三次握手和客户端、服务器模型。让我们先从服务器端开始。
## 服务端准备连接的过程
### 创建套接字要创建一个可用的套接字，需要使用下面的函数：    int socket(int domain, int type, int protocol)domain 就是指 PF_INET、PF_INET6 以及 PF_LOCAL 等，表示什么样的套接字。type 可用的值是：-   **SOCK_STREAM: 表示的是字节流，对应 TCP；**-   **SOCK_DGRAM： 表示的是数据报，对应 UDP；**-   **SOCK_RAW: 表示的是原始套接字。**参数 protocol原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成。protocol目前一般写成 0 即可。
### bind: 设定电话号码创建出来的套接字如果需要被别人使用，就需要调用 bind函数把套接字和套接字地址绑定，就像去电信局登记我们的电话号码一样。调用 bind 函数的方式如下：    bind(int fd, sockaddr * addr, socklen_t len)我们需要注意到 bind函数后面的第二个参数是通用地址格式`sockaddr * addr`。这里有一个地方值得注意，那就是虽然接收的是通用地址格式，实际上传入的参数可能是IPv4、IPv6 或者本地套接字格式。bind 函数会根据 len 字段判断传入的参数addr 该怎么解析，len 字段表示的就是传入的地址长度，它是一个可变值。``{=html}这里其实可以把 bind 函数理解成这样：    bind(int fd, void * addr, socklen_t len)不过 BSD 设计套接字的时候大约是 1982 年，那个时候的 C语言还没有`void *`的支持，为了解决这个问题，BSD的设计者们创造性地设计了通用地址格式来作为支持 bind 和 accept等这些函数的参数。对于使用者来说，每次需要将 IPv4、IPv6或者本地套接字格式转化为通用套接字格式，就像下面的 IPv4套接字地址格式的例子一样：    struct sockaddr_in name;bind (sock, (struct sockaddr *) &name, sizeof (name)对于实现者来说，可根据该地址结构的前两个字节判断出是哪种地址。为了处理长度可变的结构，需要读取函数里的第三个参数，也就是len 字段，这样就可以对地址进行解析和判断了。设置 bind 的时候，对地址和端口可以有多种处理方式。我们可以把地址设置成本机的 IP 地址，这相当告诉操作系统内核，仅仅对目标IP 是本机 IP 地址的 IP包进行处理。但是这样写的程序在部署时有一个问题，我们编写应用程序时并不清楚自己的应用程序将会被部署到哪台机器上。这个时候，可以利用**通配地址**的能力帮助我们解决这个问题。通配地址相当于告诉操作系统内核："Hi，我可不挑活，只要目标地址是咱们的都可以。"比如一台机器有两块网卡，IP地址分别是 202.61.22.55 和 192.168.1.11，那么向这两个 IP请求的请求包都会被我们编写的应用程序处理。那么该如何设置通配地址呢？对于 IPv4 的地址来说，使用 INADDR_ANY 来完成通配地址的设置；对于 IPv6的地址来说，使用 IN6ADDR_ANY 来完成通配地址的设置。    struct sockaddr_in name;name.sin_addr.s_addr = htonl (INADDR_ANY); /* IPV4 通配地址 */除了地址，还有端口。如果把端口设置成0，就相当于把端口的选择权交给操作系统内核来处理，操作系统内核会根据一定的算法选择一个空闲的端口，完成套接字的绑定。这在服务器端不常使用。一般来说，服务器端的程序一定要绑定到一个众所周知的端口上。服务器端的 IP地址和端口数据，相当于打电话拨号时需要知道的对方号码，如果没有电话号码，就没有办法和对方建立连接。我们来看一个初始化 IPv4 TCP 套接字的例子:    #include #include #include #include   int make_socket (uint16_t port){  int sock;  struct sockaddr_in name;    /* 创建字节流类型的 IPV4 socket. */  sock = socket (PF_INET, SOCK_STREAM, 0);  if (sock `{=html}乍一看，两者的表现形式是一样，内在的区别还是很不一样的。对于普通文件描述符而言，一个文件描述符代表了打开的一个文件句柄，通过调用write函数，操作系统内核帮我们不断地往文件系统中写入字节流。注意，写入的字节流大小通常和输入参数size 的值是相同的，否则表示出错。对于套接字描述符而言，它代表了一个双向连接，在套接字描述符上调用 write写入的字节数**有可能**比请求的数量少，这在普通文件描述符情况下是不正常的。产生这个现象的原因在于操作系统内核为读取和发送数据做了很多我们表面上看不到的工作。接下来我拿write 函数举例，重点阐述发送缓冲区的概念。
### 发送缓冲区你一定要建立一个概念，当 TCP 三次握手成功，TCP连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如**发送缓冲区**。发送缓冲区的大小可以通过套接字选项来改变，当我们的应用程序调用 write函数时，实际所做的事情是把数据**从应用程序中拷贝到操作系统内核的发送缓冲区中**，并不一定是把数据通过套接字写出去。这里有几种情况：第一种情况很简单，操作系统内核的发送缓冲区足够大，可以直接容纳这份数据，那么皆大欢喜，我们的程序从write 调用中退出，返回写入的字节数就是应用程序的数据大小。第二种情况是，操作系统内核的发送缓冲区是够大了，不过还有数据没有发送完，或者数据发送完了，但是操作系统内核的发送缓冲区不足以容纳应用程序数据，在这种情况下，你预料的结果是什么呢？报错？还是直接返回？操作系统内核并不会返回，也不会报错，而是应用程序被阻塞，也就是说应用程序在write函数调用处停留，不直接返回。术语"挂起"也表达了相同的意思，不过"挂起"是从操作系统内核角度来说的。那么什么时候才会返回呢？实际上，每个操作系统内核的处理是不同的。大部分 UNIX系统的做法是一直等到可以把应用程序数据完全放到操作系统内核的发送缓冲区中，再从系统调用中返回。怎么理解呢？别忘了，我们的操作系统内核是很聪明的，当 TCP连接建立之后，它就开始运作起来。你可以把发送缓冲区想象成一条包裹流水线，有个聪明且忙碌的工人不断地从流水线上取出包裹（数据），这个工人会按照TCP/IP 的语义，将取出的包裹（数据）封装成 TCP 的 MSS 包，以及 IP 的 MTU包，最后走数据链路层将数据发送出去。这样我们的发送缓冲区就又空了一部分，于是又可以继续从应用程序搬一部分数据到发送缓冲区里，这样一直进行下去，到某一个时刻，应用程序的数据可以完全放置到发送缓冲区里。在这个时候，write阻塞调用返回。注意返回的时刻，应用程序数据并没有全部被发送出去，发送缓冲区里还有部分数据，这部分数据会在稍后由操作系统内核通过网络发送出去。![](Images/29114aa797d6541ec793b1318be5c8d9.png){savepage-src="https://static001.geekbang.org/resource/image/fd/dc/fdcdc766c6a6ebb7fbf15bb2d1e58bdc.png"}
## 读取数据我们可以注意到，套接字描述本身和本地文件描述符并无区别，**在 UNIX的世界里万物都是文件**，这就意味着可以将套接字描述符传递给那些原先为处理本地文件而设计的函数。这些函数包括read 和 write 交换数据的函数。
### read 函数让我们先从最简单的 read 函数开始看起，这个函数的原型如下：    ssize_t read (int socketfd, void *buffer, size_t size)read 函数要求操作系统内核从套接字描述字socketfd**读取最多多少个字节（size），并将结果存储到 buffer中。返回值告诉我们实际读取的字节数目，也有一些特殊情况，如果返回值为0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN包，要处理断连的情况**；如果返回值为 -1，表示出错。当然，如果是非阻塞I/O，情况会略有不同，在后面的提高篇中我们会重点讲述非阻塞 I/O 的特点。注意这里是最多读取 size 个字节。如果我们想让应用程序每次都读到 size个字节，就需要编写下面的函数，不断地循环读取。    /* 从 socketfd 描述字中读取 "size" 个字节. */ssize_t readn(int fd, void *vptr, size_t size){    size_t  nleft;    ssize_t nread;    char    *ptr;     ptr = vptr;    nleft = size;        while (nleft > 0) {        if ( (nread = read(fd, ptr, nleft)) ");     sockfd = socket(AF_INET, SOCK_STREAM, 0);     bzero(&servaddr, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_port = htons(SERV_PORT);    inet_pton(AF_INET, argv[1], &servaddr.sin_addr);    connect(sockfd, (SA *) &servaddr, sizeof(servaddr));    send_data(stdin, sockfd);    exit(0);} 
# define MESSAGE_SIZE 10240000void send_data(FILE *fp, int sockfd){    char * query;    query = malloc(MESSAGE_SIZE+1);    for(int i=0; i`{=html}这两个简单的例子，道出了 UDP 和 TCP 之间最大的区别。TCP 是一个面向连接的协议，TCP 在 IP报文的基础上，增加了诸如重传、确认、有序传输、拥塞控制等能力，通信的双方是在一个确定的上下文中工作的。而 UDP 则不同，UDP没有这样一个确定的上下文，它是一个不可靠的通信协议，没有重传和确认，没有有序控制，也没有拥塞控制。我们可以简单地理解为，在IP 报文的基础上，UDP 增加的能力有限。UDP 不保证报文的有效传递，不保证报文的有序，也就是说使用 UDP的时候，我们需要做好丢包、重传、报文组装等工作。既然如此，为什么我们还要使用 UDP 协议呢？答案很简单，因为 UDP 比较简单，适合的场景还是比较多的，我们常见的 DNS服务，SNMP 服务都是基于 UDP协议的，这些场景对时延、丢包都不是特别敏感。另外多人通信的场景，如聊天室、多人游戏等，也都会使用到UDP 协议。
## UDP 编程UDP 和 TCP 编程非常不同，下面这张图是 UDP 程序设计时的主要过程。![](Images/b80353da512811bc885413c91829cd77.png){savepage-src="https://static001.geekbang.org/resource/image/84/30/8416f0055bedce10a3c7d0416cc1f430.png"}\我们看到服务器端创建 UDP 套接字之后，绑定到本地端口，调用 recvfrom函数等待客户端的报文发送；客户端创建套接字之后，调用 sendto函数往目标地址和端口发送 UDP报文，然后客户端和服务器端进入互相应答过程。recvfrom 和 sendto 是 UDP 用来接收和发送报文的两个主要函数：    #include  ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags,           struct sockaddr *from, socklen_t *addrlen);  ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags,                const struct sockaddr *to, socklen_t *addrlen); 我们先来看一下 recvfrom 函数。sockfd、buff 和 nbytes 是前三个参数。sockfd是本地创建的套接字描述符，buff 指向本地的缓存，nbytes表示最大接收数据字节。第四个参数 flags 是和 I/O 相关的参数，这里我们还用不到，设置为 0。后面两个参数 from 和addrlen，实际上是返回对端发送方的地址和端口等信息，这和 TCP非常不一样，TCP 是通过 accept 函数拿到的描述字信息来决定对端的信息。另外UDP报文每次接收都会获取对端的信息，也就是说报文和报文之间是没有上下文的。函数的返回值告诉我们实际接收的字节数。接下来看一下 sendto 函数。sendto 函数中的前三个参数为 sockfd、buff 和 nbytes。sockfd是本地创建的套接字描述符，buff 指向发送的缓存，nbytes表示发送字节数。第四个参数 flags 依旧设置为 0。后面两个参数 to 和 addrlen，表示发送的对端地址和端口等信息。函数的返回值告诉我们实际接收的字节数。我们知道， TCP 的发送和接收每次都是在一个上下文中，类似这样的过程：A 连接上: 接收→发送→接收→发送→...B 连接上: 接收→发送→接收→发送→ ...而 UDP 的每次接收和发送都是一个独立的上下文，类似这样：接收 A→发送 A→接收 B→发送 B →接收 C→发送 C→ ...
## UDP 服务端例子我们先来看一个 UDP 服务器端的例子：    #include "lib/common.h" static int count; static void recvfrom_int(int signo) {    printf("\nreceived %d datagrams\n", count);    exit(0);}  int main(int argc, char **argv) {    int socket_fd;    socket_fd = socket(AF_INET, SOCK_DGRAM, 0);     struct sockaddr_in server_addr;    bzero(&server_addr, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    server_addr.sin_port = htons(SERV_PORT);     bind(socket_fd, (struct sockaddr *) &server_addr, sizeof(server_addr));     socklen_t client_len;    char message[MAXLINE];    count = 0;     signal(SIGINT, recvfrom_int);     struct sockaddr_in client_addr;    client_len = sizeof(client_addr);    for (;;) {        int n = recvfrom(socket_fd, message, MAXLINE, 0, (struct sockaddr *) &client_addr, &client_len);        message[n] = 0;        printf("received %d bytes: %s\n", n, message);         char send_line[MAXLINE];        sprintf(send_line, "Hi, %s", message);         sendto(socket_fd, send_line, strlen(send_line), 0, (struct sockaddr *) &client_addr, client_len);         count++;    } }程序的 12～13行，首先创建一个套接字，注意这里的套接字类型是"SOCK_DGRAM"，表示的是 UDP数据报。15～21 行和 TCP 服务器端类似，绑定数据报套接字到本地的一个端口上。27行为该服务器创建了一个信号处理函数，以便在响应"Ctrl+C"退出时，打印出收到的报文总数。31～42 行是该服务器端的主体，通过调用 recvfrom函数获取客户端发送的报文，之后我们对收到的报文进行重新改造，加上"Hi"的前缀，再通过sendto 函数发送给客户端对端。