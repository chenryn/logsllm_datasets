encryption footer. We use a randomly generated hidden key
383
to encrypt the hidden volume, and use the hidden password
to encrypt the hidden key. The encrypted hidden key will
be stored at a secret oﬀset which is generated by the hidden
password. To achieve “ﬁle system friendly” PDE, we create
thin volumes in the public volume and the hidden volume
respectively. Upon booting, the password will be used to de-
crypt the key and the decrypted key will be used to decrypt
the corresponding volume. Speciﬁcally, if the owner provides
the decoy password, the system will boot into public mode,
in which the content of the public volume will be present.
The hidden volume part of the storage looks no diﬀerence
from random data. In this fashion, an ordinary observer will
be convinced no sensitive data exists. To process sensitive
data, the owner should use the hidden password and boot
into PDE mode, in which the hidden volume will be located
(i.e., the oﬀset of the hidden volume can be generated based
on the hidden password) and decrypted by the hidden key.
A more sophisticated adversary may try to examine the
utilization of the entire storage space and its availability.
Thus, the entire storage space should remain allocatable and
usable in the public mode. This can be handled in Mobi-
Pluto, as thin provisioning allows dynamically scaling, i.e.,
we can specify the size of a thin volume that exceeds its
allocated capacity.
Note that in the public mode, the system can allocate the
entire storage and the storage area that contains the hidden
volume just looks like random noise. The adversary cannot
infer the existence of hidden volume without knowing the
hidden key.
Compared to the existing deniable encryption schemes for
mobile devices [15, 33, 36], MobiPluto has a salient advan-
tage: it is ﬁle system friendly, i.e., any block-based ﬁle sys-
tems can be deployed on top of each thin volume. Thus, we
can deploy MobiPluto on the internal storage of most mobile
devices.
4.2 File System Friendly Deniability
Diﬀerent ﬁle systems may use diﬀerent allocation strate-
gies (e.g., FAT32 prefers linear allocation [11] and Ext4
prefers random allocation [15]). FAT32 has the nature of
supporting hidden-volume mechanism due to its concentrated
metadata and sequential allocation. For a FAT32 formatted
device, we can simply place the hidden volume somewhere in
the second half of the storage medium, by which the data in
the hidden volume will not be easily overwritten by the data
in the public volume, as the public volume grows sequen-
tially from the beginning of the storage medium. However,
it is problematic to place hidden volumes in an Ext4 format-
ted device, because: Firstly, the data in the hidden volumes
may overwrite all or part of the public volume’s metadata.
By observing this abnormal overwrite, the adversary may
suspect the existence of hidden volumes; Secondly, the data
from the public volume may easily overwrite the data in
the hidden volumes. In general, if the device is formatted
with a ﬁle system having similar characteristics like Ext4,
we cannot simply create hidden volumes within it.
Thin provisioning can help address the aforementioned
concern. By using thin provisioning, we can ﬁrst create a
thin pool and then create thin volumes in the thin pool. The
thin pool ties together a small metadata device and a data
device, and the latter occupies most of the storage space.
Interestingly, the data device in thin provisioning is used
linearly (i.e., the space maps allocate space linearly from
front to back). To avoid fragmenting free space, the alloca-
tion always goes back and ﬁlls the gaps in the data device.
In this way, thin provisioning can transform the possibly
non-sequential allocation on the thin volume to sequential
allocation on the data device. This renders it possible to
combine hidden volumes and thin provisioning to achieve a
PDE solution that allows any block-based ﬁle systems to be
deployed.
Thin provisioning provides a logical block device (a thin
volume), which allows to deploy an arbitrary block-based
ﬁle system. No matter how the ﬁle system uses the logical
device, the changes on the data device are linear (see Fig-
ure 2). On the thin volume, the non-sequential addresses are
mapped to sequential addresses on the data device through
mappings in the metadata device. For example, the meta-
data of an Ext4 ﬁle system is evenly distributed on the thin
volume [10], but through mapping, the metadata is written
on the data device sequentially. As a result, we can create
hidden volumes on the second half of the public volume’s
data device. Since the data in the public volume are al-
ways written sequentially to the data device (regardless of
the allocation strategies of the deployed ﬁle system on the
thin volume), it is very unlikely that they will overwrite the
hidden volumes. In other words, the “ﬁle system friendly”
feature can be achieved. Note that we write random noise
to the storage when initializing and encrypting the hidden
volume with dm-crypt and thus in the public mode, the
adversary cannot diﬀerentiate the hidden volume from the
random noise.
Another beneﬁt oﬀered by thin provisioning is that the
size of a thin volume can be set larger than or equal to the
entire storage space. Since the label, the metadata of LVM
and the metadata device of thin pool will occupy space, the
thin volume usually cannot use the entire space. However,
in the public mode, we can set the thin volume size equal to
the size of the entire storage space, by which the adversary
will observe the entire space is usable and will not suspect
the existence of PDE. Additionally, as thin provisioning is
a kernel feature, its existence will not become a clue of the
existence of PDE.
4.3 Storage Layout
For the public volume, we use the decoy key to create an
encrypted block device over the entire disk. We then use
LVM to create a physical volume on the encrypted block
device. A physical volume label will be placed in the second
512-byte sector and the ﬁrst 512-byte sector remains unused
according to the default LVM conﬁguration [9]. We further
create a volume group within this physical volume. The
metadata of the volume group will be placed right after the
physical volume label (see Figure 1).
Next, we create a thin volume (used for storing the regular
data) in this volume group. We ﬁrst create a small ordinary
logical volume, which is used as the metadata device for the
thin pool. We then create a large ordinary logical volume
in the remaining space of the volume group. This volume
is used as the data device for the thin pool, on which we
can create thin volumes. LVM allocates the space in the
data device to thin volumes according to the mappings in
the metadata device. On thin volumes, we can deploy any
block-based ﬁle systems (e.g., Ext4).
For the hidden volume, we ﬁrst calculate an oﬀset using
the hidden password and create another encrypted block de-
384
(cid:62)(cid:258)(cid:271)(cid:286)(cid:367)
(cid:115)(cid:39)(cid:3)(cid:68)(cid:286)(cid:410)(cid:258)(cid:282)(cid:258)(cid:410)(cid:258)
(cid:68)(cid:286)(cid:410)(cid:258)(cid:282)(cid:258)(cid:410)(cid:258)(cid:3)(cid:24)(cid:286)(cid:448)(cid:349)(cid:272)(cid:286)
(cid:24)(cid:258)(cid:410)(cid:258)(cid:3)(cid:24)(cid:286)(cid:448)(cid:349)(cid:272)(cid:286)
(cid:28)(cid:374)(cid:272)(cid:396)(cid:455)(cid:393)(cid:410)(cid:286)(cid:282)(cid:3)(cid:346)(cid:349)(cid:282)(cid:282)(cid:286)(cid:374)(cid:3)(cid:364)(cid:286)(cid:455)
(cid:62)(cid:258)(cid:271)(cid:286)(cid:367)
(cid:115)(cid:39)(cid:3)(cid:68)(cid:286)(cid:410)(cid:258)(cid:282)(cid:258)(cid:410)(cid:258)
(cid:68)(cid:286)(cid:410)(cid:258)(cid:282)(cid:258)(cid:410)(cid:258)(cid:3)(cid:24)(cid:286)(cid:448)(cid:349)(cid:272)(cid:286)
(cid:24)(cid:258)(cid:410)(cid:258)(cid:3)(cid:24)(cid:286)(cid:448)(cid:349)(cid:272)(cid:286)
(cid:28)(cid:374)(cid:272)(cid:396)(cid:455)(cid:393)(cid:410)(cid:349)(cid:381)(cid:374)(cid:3)(cid:38)(cid:381)(cid:381)(cid:410)(cid:286)(cid:396)
(cid:381)(cid:296)(cid:296)(cid:400)(cid:286)(cid:410)
(cid:87)(cid:437)(cid:271)(cid:367)(cid:349)(cid:272)(cid:3)(cid:115)(cid:381)(cid:367)(cid:437)(cid:373)(cid:286)(cid:3)(cid:894)(cid:286)(cid:374)(cid:272)(cid:396)(cid:455)(cid:393)(cid:410)(cid:286)(cid:282)(cid:3)(cid:449)(cid:349)(cid:410)(cid:346)(cid:3)(cid:410)(cid:346)(cid:286)(cid:3)(cid:282)(cid:286)(cid:272)(cid:381)(cid:455)(cid:3)(cid:364)(cid:286)(cid:455)(cid:895)
Figure 1: MobiPluto Storage Layout
(cid:87)(cid:437)(cid:271)(cid:367)(cid:349)(cid:272)(cid:3)(cid:68)(cid:381)(cid:282)(cid:286)(cid:3)(cid:38)(cid:349)(cid:367)(cid:286)(cid:3)(cid:94)(cid:455)(cid:400)(cid:410)(cid:286)(cid:373)
(cid:87)(cid:24)(cid:28)(cid:3)(cid:68)(cid:381)(cid:282)(cid:286)(cid:3)(cid:38)(cid:349)(cid:367)(cid:286)(cid:3)(cid:94)(cid:455)(cid:400)(cid:410)(cid:286)(cid:373)
(cid:44)(cid:349)(cid:282)(cid:282)(cid:286)(cid:374)(cid:3)(cid:115)(cid:381)(cid:367)(cid:437)(cid:373)(cid:286)(cid:3)(cid:894)(cid:286)(cid:374)(cid:272)(cid:396)(cid:455)(cid:393)(cid:410)(cid:286)(cid:282)(cid:3)(cid:449)(cid:349)(cid:410)(cid:346)(cid:3)(cid:410)(cid:346)(cid:286)(cid:3)(cid:346)(cid:349)(cid:282)(cid:282)(cid:286)(cid:374)(cid:3)(cid:364)(cid:286)(cid:455)(cid:895)
(cid:100)(cid:346)(cid:349)(cid:374)(cid:3)(cid:87)(cid:396)(cid:381)(cid:448)(cid:349)(cid:400)(cid:349)(cid:381)(cid:374)(cid:349)(cid:374)(cid:336)
(cid:94)(cid:410)(cid:381)(cid:396)(cid:258)(cid:336)(cid:286)
Figure 2: Thin Provisioning and the Hidden Volume
vice within the space between the oﬀset and the end of the
storage medium (Figure 1). We then create a thin volume
(used for storing the sensitive data) following the aforemen-
tioned steps. Note that any block-based ﬁle systems can also
be deployed on this thin volume.
4.4 Size Calculation
In this section, we describe how to calculate the size of the
hidden volume, the metadata device and the data device.
For deniability purpose, the thin volume size should be set
the same as the total disk size in the public mode.
The hidden volume starts at a speciﬁc oﬀset on the stor-
age medium. MobiPluto generates this oﬀset using hidden
password in the following way [33]:
oﬀset = 0.75 × vlen − (H(pwd||salt) mod (0.25 × vlen))
Here, vlen denotes the number of 512-byte sectors on the
physical block device; H is a PBKDF2 iterated hash func-
tion [17]; pwd is the hidden password; salt is a random salt
value for PBKDF2 and it is the same as the one stored in the
encryption footer. Thus, we do not need to store another
salt.
The hidden volume is stored after the encrypted hidden
key (stored at the oﬀset). The hidden volume size can be
calculated as follows:
Shid = vlen − oﬀset − Skey − Sf ooter
Here, Skey and Sf ooter denote the size of the encrypted hid-
den key and of the encryption footer respectively.
The amount of metadata will vary according to the block
size of the thin provisioned devices, the size of the thin
provisioning pool and the maximum number of overall thin
provisioned devices and snapshots. There is a tool named
“thin metadata size” in the thin provisioning tools and it
can return the size of thin metadata according to the above
input. However, it is space-consuming to add this tool to
“boot.img” and our scenario is very simple as we only have
one thin volume and no snapshots. We give a calculation of
thin metadata device size:
Smeta = Sreq × vlen/Sblock
Here, Sblock is the block size of the thin provisioned devices.
Sreq denotes the average space needed by each data device
block in thin metadata device. After the thin metadata de-
vice is created, the free space in the volume group is used to
create the data device. Note that the size of thin metadata
device is the same in both the public volume and the hidden
volume.
5.
IMPLEMENTATION
We implement a prototype of MobiPluto on a LG Nexus
4 device and its Android version is 4.2.2. The source code
. We
of the implementation has been released on GitHub
add about 1000 lines of C code into the Android volume
mounting daemon (VOLD). We also change some of the de-
fault kernel conﬁgurations so that we could use the required
features (e.g., thin provisioning in kernel). In addition, we
1
1
https://github.com/FengweiZhang/MobiPluto
385
compile Logical Volume Manager (LVM) and thin provision-
ing tools [34] for Android and put them in a boot image.
5.1 Thin Provisioning on Android
In this section, we describe how we run thin provision-
ing on Android. Thin provisioning is available in the Linux
kernel since version 3.2. Android 4.2.2 uses the Linux ker-
nel 3.4, but the default conﬁguration disables this feature.
Therefore, we have to enable it and recompile the kernel.
In addition, since we use AES-XTS, the xts and gf128mul
kernel crypto modules should be enabled, too.
It is not enough to enable only the thin provisioning fea-
ture in the kernel. We have to use LVM to setup logical
volumes. Furthermore, we use thin provisioning tools to ac-
tivate the thin volumes. Thus, we compile LVM and thin
provisioning tools for Android. The compiling process re-
quires a speciﬁc environment for Android. Besides gcc and
g++ tool chains for Android, both tools need to be statically
linked. For static compiling, we add “–enable-static link”
when conﬁguring LVM and we add “LDFLAGS= -static” to
the makeﬁle of thin provisioning tools. Furthermore, the
default LVM conﬁguration does not enable the thin pro-
visioning, so we add “–with-thin = internal” in the LVM
conﬁguration for that.
Next, we add both tools to the boot.img using unpack-
bootimg and mkbootimg which are provided by AOSP [8].
Note that we modify the access permissions of these ﬁles by
adding “chmod” command to mako.init in the boot.img.
Otherwise, we are not able to use them. After enabling thin
provisioning feature in the kernel and adding the tools to
the boot.img, we can use thin provisioning on Android.
5.2 User Interface and Pre-boot Authentica-
tion
Users can use a command-line utility, vdc, to activate Mo-
biPluto PDE; the command is as follows: “vdc cryptfs pde
  ”. The default An-
droid shell does not maintain history, thus the commands or
the passwords cannot be retrieved from a captured Android
device.
To make the hidden volume indistinguishable, we ﬁrst
wipe the entire internal storage with random noise. For the
public volume of MobiPluto, we use a random key to create
an encrypted block device and store the encrypted key and
the salt in the encryption footer. We then create a thin vol-
ume on the encrypted block device and create an Ext4 ﬁle
system on the thin volume. We have described the proce-
dure of initializing a public volume and a hidden volume in
Section 4.3. The size of the metadata device is calculated
according to Section 4.4. Sreq is chosen as 50 for now, and a
more accurate value will be investigated in our future work.
When the device is booted but fails to ﬁnd a valid Ext4
ﬁle system on the userdata partition, the system will ask the
user to enter a password. The default Android will use this
password to decrypt the key in the footer and decrypt the
storage medium with this key. If a valid Ext4 ﬁle system can
be mounted, the system will continue to boot. However, Mo-
biPluto creates a thin volume instead of an Ext4 ﬁle system
on the encrypted block device. It would be time consuming
if MobiPluto enables the thin volume to check the existence
of Ext4 ﬁle system by mounting it. To reduce the time of
checking, we use a Message Authentication Code (MAC) in
the following way: 1) We calculate a master secret S with
the corresponding password and the salt in the encryption
footer using PKCS5 PBKDF2 HMAC SHA1 function. 2)
The encryption key of the volume key is derived from S
and a character string “encryption key”. 3) The MAC key
is derived from S and another character string “mac key”.
4) We use the MAC key to compute a MAC for the entire
volume header (this header is stored in the second 512-byte
sector of the volume). 5) We store the MAC in the ﬁrst
512-byte sector of the volume, which remains unused when
we use LVM. When the user enters a password, the system
will check the MAC of the public volume. If it is matched,
the password is the decoy password and the system will boot
into the public mode. Otherwise, the system will calculate
an oﬀset and check the MAC of the hidden volume. If this
MAC is matched, the password is the hidden password and
the system will boot into the PDE mode. Otherwise, the
system asks for another password.
6. EVALUATION RESULTS
6.1 Security Analysis
Deniability provided by hidden volumes. In general,
storage units are not ﬁlled with random data when coming
from the manufacturers. In addition, the operating system
installation procedures do not ﬁll the entire storage with ran-
dom data. Thus, the adversary may suspect the existence of
PDE after decrypting the disk with a decoy key, as it can ﬁnd
out random data which is not “accounted for” (Sec. 2.1). A
plausible explanation from the device owner can be, he/she
always ﬁlls the disk with random data before putting ﬁle
systems on it. Although the adversary has the full knowl-
edge of MobiPluto design (Sec. 3.3), without knowing the
secrets, it cannot prove the existence of hidden volumes, as
they are encrypted by FDE and are indistinguishable from
the initially ﬁlled random data (Note that MobiPluto uses
the encryption function for FDE as the pseudorandom num-
ber generator).
To prevent the adversary from identifying hidden volumes
without recovering any hidden plaintexts, MobiPluto uses
XTS as the block cipher mode, which has been designed
for disk encryption, and is able to prevent attacks such as
ciphertext manipulation and cut-and-paste [27].
Thin provisioning/LVM speciﬁc security issues. Mo-
biPluto uses both thin provisioning and LVM tools. Thin
provisioning/LVM in either the public mode or the hidden
mode will have its own label, VG metadata, metadata device
and data device (Sec. 4), which are stored in its own userdata
partition, encrypted by dm-crypt with diﬀerent keys (i.e.,
decoy key and hidden key). For the hidden mode speciﬁ-
cally, the location of the userdata partition is secret and can
only be derived when knowing the hidden password. Thus,
when the adversary looks into the public volume (i.e., in the
public mode), it will not have any clues of the data related
to thin provisioning/LVM in the hidden volumes.
Other security issues. We require device owners to choose
strong passwords resilient to guessing. The data and exis-
tence leakage of hidden ﬁles into temporary ﬁles, swap space,
or OS logs can be mitigated by the two modes of MobiPluto
[33]. MobiPluto is built for mobile devices, which usually
use ﬂash storage. An analysis of leakage from ﬂash storage
can be found in Mobiﬂage [33]. However, it is still not clear
386
s
/
B
K
n
i
t
u
p
h
g
u
o
r
h
T
l