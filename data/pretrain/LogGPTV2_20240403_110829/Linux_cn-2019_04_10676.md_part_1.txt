---
author: Alex Chadwick
category: 树莓派
comments_data: []
count:
  commentnum: 0
  favtimes: 0
  likes: 0
  sharetimes: 0
  viewnum: 5958
date: '2019-04-02 12:23:00'
editorchoice: false
excerpt: 这是第一堂输入课，会教授一些关于驱动和链接的理论，同样也包含键盘的知识，最后以在屏幕上显示文本结束。
fromurl: https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/input01.html
id: 10676
islctt: true
largepic: /data/attachment/album/201904/02/120425uxwkwx1x00k5bb91.jpg
permalink: /article-10676-1.html
pic: /data/attachment/album/201904/02/120425uxwkwx1x00k5bb91.jpg.thumb.jpg
related:
- displayorder: 0
  raid: 10605
- displayorder: 0
  raid: 10700
reviewer: wxy
selector: lujun9972
summary: 这是第一堂输入课，会教授一些关于驱动和链接的理论，同样也包含键盘的知识，最后以在屏幕上显示文本结束。
tags:
- 键盘
- 树莓派
thumb: false
title: 计算机实验室之树莓派：课程 10 输入01
titlepic: true
translator: oska874
updated: '2019-04-02 12:23:00'
---
![](/data/attachment/album/201904/02/120425uxwkwx1x00k5bb91.jpg)
欢迎进入输入课程系列。在本系列，你将会学会如何使用键盘接收输入给树莓派。我们将会从揭示输入开始本课，然后转向更传统的文本提示符。
这是第一堂输入课，会教授一些关于驱动和链接的理论，同样也包含键盘的知识，最后以在屏幕上显示文本结束。
### 1、开始
希望你已经完成了 OK 系列课程，这会对你完成屏幕系列课程很有帮助。很多 OK 课程上的文件会被使用而不会做解释。如果你没有这些文件，或者希望使用一个正确的实现，可以从该堂课的[下载页](https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/downloads.html)下载模板。如果你使用你自己的实现，请删除调用了 `SetGraphicsAddress` 之后全部的代码。
### 2、USB
如你所知，树莓派 B 型有两个 USB 接口，通常用来连接一个鼠标和一个键盘。这是一个非常好的设计决策，USB 是一个非常通用的接口，很多种设备都可以使用它。这就很容易为它设计新外设，很容易为它编写设备驱动，而且通过 USB 集线器可以非常容易扩展。还能更好吗？当然是不能，实际上对一个操作系统开发者来说，这就是我们的噩梦。USB 标准太大了。我是说真的，在你思考如何连接设备之前，它的文档将近 700 页。
> 
> USB 标准的设计目的是通过复杂的软件来简化硬件交互。
> 
> 
> 
我和很多爱好操作系统的开发者谈过这些，而他们全部都说几句话：不要抱怨。“实现这个需要花费很久时间”，“你不可能写出关于 USB 的教程”，“收益太小了”。在很多方面，他们是对的，我不可能写出一个关于 USB 标准的教程，那得花费几周时间。我同样不能教授如何为全部所有的设备编写外设驱动，所以使用自己写的驱动是没什么用的。然而，即便不能做到最好，我仍然可以获取一个正常工作的 USB 驱动，拿一个键盘驱动，然后教授如何在操作系统中使用它们。我开始寻找可以运行在一个甚至不知道文件是什么的操作系统的自由驱动，但是我一个都找不到，它们都太高层了，所以我尝试写一个。大家说的都对，这耗费了我几周时间。然而我可以高兴的说我做的这些工作没有获取操作系统以外的帮助，并且可以和鼠标和键盘通信。这绝不是完整的、高效的，或者正确的，但是它能工作。驱动是以 C 编写的，而且有兴趣的可以在下载页找到全部源代码。
所以，这一个教程不会是 USB 标准的课程（一点也没有）。实际上我们将会看到如何使用其他人的代码。
### 3、链接
既然我们要引进外部代码到操作系统，我们就需要谈一谈 链接   linking 。链接是一种过程，可以在程序或者操作系统中链接函数。这意味着当一个程序生成之后，我们不必要编写每一个函数（几乎可以肯定，实际上并非如此）。链接就是我们做的用来把我们程序和别人代码中的函数连结在一起。这个实际上已经在我们的操作系统进行了，因为链接器把所有不同的文件链接在一起，每个都是分开编译的。
> 
> 链接允许我们制作可重用的代码库，所有人都可以在他们的程序中使用。
> 
> 
> 
有两种链接方式：静态和动态。静态链接就像我们在制作自己的操作系统时进行的。链接器找到全部函数的地址，然后在链接结束前，将这些地址都写入代码中。动态链接是在程序“完成”之后。当程序加载后，动态链接器检查程序，然后在操作系统的库找到所有不在程序里的函数。这就是我们的操作系统最终应该能够完成的一项工作，但是现在所有东西都将是静态链接的。
> 
> 程序经常调用调用库，这些库会调用其它的库，直到最终调用了我们写的操作系统的库。
> 
> 
> 
我编写的 USB 驱动程序适合静态编译。这意味着我给你的是每个文件的编译后的代码，然后链接器找到你的代码中的那些没有实现的函数，就将这些函数链接到我的代码。在本课的 [下载页](https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/downloads.html) 是一个 makefile 和我的 USB 驱动，这是接下来需要的。下载并使用这个 makefile 替换你的代码中的 makefile， 同事将驱动放在和这个 makefile 相同的文件夹。
### 4、键盘
为了将输入传给我们的操作系统，我们需要在某种程度上理解键盘是如何实际工作的。键盘有两种按键：普通键和修饰键。普通按键是字母、数字、功能键，等等。它们构成了键盘上几乎全部按键。修饰键是多达 8 个的特殊键。它们是左 shift、右 shift、左 ctrl、右 ctrl、左 alt、右 alt、左 GUI 和右 GUI。键盘可以检测出所有的组合中那个修饰键被按下了，以及最多 6 个普通键。每次一个按钮变化了（例如，是按下了还是释放了），键盘就会报告给电脑。通常，键盘也会有 3 个 LED 灯，分别指示大写锁定，数字键锁定，和滚动锁定，这些都是由电脑控制的，而不是键盘自己。键盘也可能有更多的灯，比如电源、静音，等等。
对于标准 USB 键盘，有一个按键值的表，每个键盘按键都一个唯一的数字，每个可能的 LED 也类似。下面的表格列出了前 126 个值。
表 4.1 USB 键盘值
| 序号 | 描述 | 序号 | 描述 | 序号 | 描述 | 序号 | 描述 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 4 | `a` 和 `A` | 5 | `b` 和 `B` | 6 | `c` 和 `C` | 7 | `d` 和 `D` |
| 8 | `e` 和 `E` | 9 | `f` 和 `F` | 10 | `g` 和 `G` | 11 | `h` 和 `H` |
| 12 | `i` 和 `I` | 13 | `j` 和 `J` | 14 | `k` 和 `K` | 15 | `l` 和 `L` |
| 16 | `m` 和 `M` | 17 | `n` 和 `N` | 18 | `o` 和 `O` | 19 | `p` 和 `P` |
| 20 | `q` 和 `Q` | 21 | `r` 和 `R` | 22 | `s` 和 `S` | 23 | `t` 和 `T` |
| 24 | `u` 和 `U` | 25 | `v` 和 `V` | 26 | `w` 和 `W` | 27 | `x` 和 `X` |
| 28 | `y` 和 `Y` | 29 | `z` 和 `Z` | 30 | `1` 和 `!` | 31 | `2` 和 `@` |
| 32 | `3` 和 `#` | 33 | `4` 和 `$` | 34 | `5` 和 `%` | 35 | `6` 和 `^` |
| 36 | `7` 和 `&` | 37 | `8` 和 `*` | 38 | `9` 和 `(` | 39 | `0` 和 `)` |
| 40 | `Return`（`Enter`） | 41 | `Escape` | 42 | `Delete`（`Backspace`） | 43 | `Tab` |
| 44 | `Spacebar` | 45 | `-` 和 `_` | 46 | `=` 和 `+` | 47 | `[` 和 `{` |
| 48 | `]` 和 `}` | 49 | `\` 和 `|` | 50 | `#` 和 `~` | 51 | `;` 和 `:` |
| 52 | `'` 和 `"` | 53 | ``` 和 `~` | 54 | `,` 和 `` |
| 56 | `/` 和 `?` | 57 | `Caps Lock` | 58 | `F1` | 59 | `F2` |
| 60 | `F3` | 61 | `F4` | 62 | `F5` | 63 | `F6` |
| 64 | `F7` | 65 | `F8` | 66 | `F9` | 67 | `F10` |
| 68 | `F11` | 69 | `F12` | 70 | `Print Screen` | 71 | `Scroll Lock` |
| 72 | `Pause` | 73 | `Insert` | 74 | `Home` | 75 | `Page Up` |
| 76 | `Delete forward` | 77 | `End` | 78 | `Page Down` | 79 | `Right Arrow` |
| 80 | `Left Arrow` | 81 | `Down Arrow` | 82 | `Up Arrow` | 83 | `Num Lock` |
| 84 | 小键盘 `/` | 85 | 小键盘 `*` | 86 | 小键盘 `-` | 87 | 小键盘 `+` |
| 88 | 小键盘 `Enter` | 89 | 小键盘 `1` 和 `End` | 90 | 小键盘 `2` 和 `Down Arrow` | 91 | 小键盘 `3` 和 `Page Down` |
| 92 | 小键盘 `4` 和 `Left Arrow` | 93 | 小键盘 `5` | 94 | 小键盘 `6` 和 `Right Arrow` | 95 | 小键盘 `7` 和 `Home` |
| 96 | 小键盘 `8` 和 `Up Arrow` | 97 | 小键盘 `9` 和 `Page Up` | 98 | 小键盘 `0` 和 `Insert` | 99 | 小键盘 `.` 和 `Delete` |
| 100 | `\` 和 `|` | 101 | `Application` | 102 | `Power` | 103 | 小键盘 `=` |
| 104 | `F13` | 105 | `F14` | 106 | `F15` | 107 | `F16` |
| 108 | `F17` | 109 | `F18` | 110 | `F19` | 111 | `F20` |
| 112 | `F21` | 113 | `F22` | 114 | `F23` | 115 | `F24` |
| 116 | `Execute` | 117 | `Help` | 118 | `Menu` | 119 | `Select` |
| 120 | `Stop` | 121 | `Again` | 122 | `Undo` | 123 | `Cut` |
| 124 | `Copy` | 125 | `Paste` | 126 | `Find` | 127 | `Mute` |
| 128 | `Volume Up` | 129 | `Volume Down` |  |  |  |  |
完全列表可以在[HID 页表 1.12](https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/downloads/hut1_12v2.pdf)的 53 页，第 10 节找到。
### 5、车轮后的螺母
通常，当你使用其他人的代码，他们会提供一份自己代码的总结，描述代码都做了什么，粗略介绍了是如何工作的，以及什么情况下会出错。下面是一个使用我的 USB 驱动的相关步骤要求。
> 
> 这些总结和代码的描述组成了一个 API - 应用程序产品接口。
> 
> 
> 
表 5.1 CSUD 中和键盘相关的函数
| 函数 | 参数 | 返回值 | 描述 |
| --- | --- | --- | --- |
| `UsbInitialise` | 无 | `r0` 是结果码 | 这个方法是一个集多种功能于一身的方法，它加载 USB 驱动程序，枚举所有设备并尝试与它们通信。这种方法通常需要大约一秒钟的时间来执行，但是如果插入几个 USB 集线器，执行时间会明显更长。在此方法完成之后，键盘驱动程序中的方法就可用了，不管是否确实插入了键盘。返回代码如下解释。 |
| `UsbCheckForChange` | 无 | 无 | 本质上提供与 `UsbInitialise` 相同的效果，但不提供相同的一次初始化。该方法递归地检查每个连接的集线器上的每个端口，如果已经添加了新设备，则添加它们。如果没有更改，这应该是非常快的，但是如果连接了多个设备的集线器，则可能需要几秒钟的时间。 |
| `KeyboardCount` | 无 | `r0` 是计数 | 返回当前连接并检测到的键盘数量。`UsbCheckForChange` 可能会对此进行更新。默认情况下最多支持 4 个键盘。可以通过这个驱动程序访问多达这么多的键盘。 |
| `KeyboardGetAddress` | `r0` 是索引 | `r0` 是地址 | 检索给定键盘的地址。所有其他函数都需要一个键盘地址，以便知道要访问哪个键盘。因此，要与键盘通信，首先要检查计数，然后检索地址，然后使用其他方法。注意，在调用 `UsbCheckForChange` 之后，此方法返回的键盘顺序可能会改变。 |
| `KeyboardPoll` | `r0` 是地址 | `r0` 是结果码 | 从键盘读取当前键状态。这是通过直接轮询设备来操作的，与最佳实践相反。这意味着，如果没有频繁地调用此方法，可能会错过一个按键。所有读取方法只返回上次轮询时的值。 |
| `KeyboardGetModifiers` | `r0` 是地址 | `r0` 是修饰键状态 | 检索上次轮询时修饰键的状态。这是两边的 `shift` 键、`alt` 键和 `GUI` 键。这回作为一个位字段返回，这样，位 0 中的 1 表示左控件被保留，位 1 表示左 `shift`，位 2 表示左 `alt` ，位 3 表示左 `GUI`，位 4 到 7 表示前面几个键的右版本。如果有问题，`r0` 包含 0。 |
| `KeyboardGetKeyDownCount` | `r0` 是地址 | `r0` 是计数 | 检索当前按下键盘的键数。这排除了修饰键。这通常不能超过 6。如果有错误，这个方法返回 0。 |
| `KeyboardGetKeyDown` | `r0` 是地址，`r1` 键号 | `r0` 是扫描码 | 检索特定按下键的扫描码（见表 4.1）。通常，要计算出哪些键是按下的，可以调用 `KeyboardGetKeyDownCount`，然后多次调用 `KeyboardGetKeyDown` ，将 `r1` 的值递增，以确定哪些键是按下的。如果有问题，返回 0。可以（但不建议这样做）在不调用 `KeyboardGetKeyDownCount` 的情况下调用此方法将 0 解释为没有按下的键。注意，顺序或扫描代码可以随机更改（有些键盘按数字排序，有些键盘按时间排序，没有任何保证）。 |
| `KeyboardGetKeyIsDown` | `r0` 是地址，`r1` 扫描码 | `r0` 是状态 | 除了 `KeyboardGetKeyDown` 之外，还可以检查按下的键中是否有特定的扫描码。如果没有，返回 0；如果有，返回一个非零值。当检测特定的扫描码（例如寻找 `ctrl+c`）时更快。出错时，返回 0。 |
| `KeyboardGetLedSupport` | `r0` 是地址 | `r0` 是 LED | 检查特定键盘支持哪些 LED。第 0 位代表数字锁定，第 1 位代表大写锁定，第 2 位代表滚动锁定，第 3 位代表合成，第 4 位代表假名，第 5 位代表电源，第 6 位代表 Shift ，第 7 位代表静音。根据 USB 标准，这些 LED 都不是自动更新的（例如，当检测到大写锁定扫描代码时，必须手动设置大写锁定 LED）。 |
| `KeyboardSetLeds` | `r0` 是地址， `r1` 是 LED | `r0` 是结果码 | 试图打开/关闭键盘上指定的 LED 灯。查看下面的结果代码值。参见 `KeyboardGetLedSupport` 获取 LED 的值。 |
有几种方法返回“返回值”。这些都是 C 代码的老生常谈了，就是用数字代表函数调用发生了什么。通常情况， 0 总是代表操作成功。下面的是驱动用到的返回值。
> 
> 返回值是一种处理错误的简单方法，但是通常更优雅的解决途径会出现于更高层次的代码。
> 
> 
> 
表 5.2 - CSUD 返回值
| 代码 | 描述 |
| --- | --- |
| 0 | 方法成功完成。 |
| -2 | 参数：函数调用了无效参数。 |
| -4 | 设备：设备没有正确响应请求。 |
| -5 | 不匹配：驱动不适用于这个请求或者设备。 |
| -6 | 编译器：驱动没有正确编译，或者被破坏了。 |
| -7 | 内存：驱动用尽了内存。 |
| -8 | 超时：设备没有在预期的时间内响应请求。 |
| -9 | 断开连接：被请求的设备断开连接，或者不能使用。 |
驱动的通常用法如下：
1. 调用 `UsbInitialise`