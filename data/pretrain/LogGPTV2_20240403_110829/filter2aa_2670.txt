MITM插件：SSRF公⽹出⽹检测
依赖条件：
需要配置 yak bridge 公⽹部署⽅案详情⻅https://github.com/yaklang/yak-bridge-docker
1.
使⽤Yakit配置好公⽹镜像
2.
SSRF检测原理：
触发条件：
流经MITM的流量，应该过滤⼀下参数，疑似SSRF参数应该参与测试
1.
参数条件：
2.
参数名直接相关 redirect / url / url_callback / webhook  / target 
.... 等
a.
参数值为 http(s?):// 开头的，可以直接替换成我们想要的SSRF⽬标
b.
yaklang.io公⽹镜像反连体系
基础知识：https://www.yaklang.io/products/professional/yakit-in-practice-reverse
1.
当yak镜像服务器映射在公⽹的时候，任何连⼊镜像服务器的请求将会被记录下来，如果携带
Token，也会被记录并且直接被对应到SSRF的漏洞中。
2.
上述经过替换的携带SSRFPayload的请求触发了请求，将会直接在数据库中记录下详细的请求
反连情况，对应的Token也会对应到漏洞上。
3.
案例：
搭建靶场
我们在本地构建⼀个SSRF的靶站，代码⾮常简单
当我们运⾏我们的靶站在 http://127.0.0.1:8084/ssrf?url=http://www.baidu.com 
的时候，浏览器返回内容如下：
测试过程
我们打开Yakit的中间⼈劫持平台
点击“被动扫描模式”
我们构建⼀个请求，以MITM设置为代理：
Go
rsp, err := http.Get(
    `http://127.0.0.1:8084/ssrf?url=https://baidu.com`, 
    http.proxy("http://127.0.0.1:8083"),
)
die(err)
http.show(rsp)
1
2
3
4
5
6
7
当我们执⾏该请求的时候，MITM劫持平台将会收到该请求，并且在请求流经过程中，会镜像⼀份出
来到SSRFHTTPPublic插件，SSRF插件执⾏之后将会在右边输出结果：
发送到代理⼀个请求：
查看结果：
当我们打开反连之后：
核⼼原理
核⼼代码
其实⼤家观察上述内容，发现我们引⽤⼀个SSRF插件即可解决这个问题，那么这个插件是如何编写
并且发挥作⽤的呢？
我们在这⾥可以看到插件源码，接下来就插件源码的核⼼原理给⼤家做简要描述
代码的结构⾮常⾮常简单：
我们关注参数列表规则和镜像流量函数：
核⼼流程
我们发现检测的步骤其实可以⾮常简单对应到我们的检测思路中。如果⼤家⽆法很容易理解代码中的
内容，我总结了⼀个基本的测试流程。
扩展与Bypass：
当然熟悉的同学，很容易发现，插件的代码并不完美，仍然有许多需要改进的地⽅：⽐如
Host混淆技术（与127.0.0.1混淆来bypass各种检查）
1.
使⽤schema混淆bypass检查
2.
⾮标准位置的测试：JSON中的SSRF检测
3.
....
4.
我们发现如果需要覆盖上⾯内容，插件仍然有很⼤的进步和发展空间，但是相应的发包量就会变⼤。
如果需要找到⼀个均衡的点，则需要更细节的控制，完善脚本的检测逻辑。