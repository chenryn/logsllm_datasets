次了。
，时间复杂度是θ(n)，而现在MAx是这样一个函数式宏定义，
例21.1.函数式宏定义
if (n >)
#define device_init_wakeup(dev,val)
#define device_init_wakeup(dev,val)
一种是宏定义实现，这一点以后还要详细解释。
int main(void)
int a[] = { 9， 3， 5， ２， 1， ０， ８， 7， ６， ４ };
#define MAx(a, b) ((a)>(b)?(a):(b))
 device_init_wakeup(d, v);
int
} while(0)
do{
 max(int n)
return 0;
max(9);
return n == 0 ? a[0] : MAX(a[n], max(n-1));
 device_can_wakeup(dev)
，使用函数式宏定义也往往会导致较低的代码执行效率。下面举一个
但只要小心使用还是会显著提高代码的执行效
=
..................................................
，思考一下这个算法的时间复杂度
，这个算法就是从前到后遍历一遍
 因此那些简短并且被频繁调用的
—........-..-.....-.....--
，一种是真正的函
362
---
## Page 363
展开的办法实现。我们做个实验，把上一
inline关键字告诉编译器,
C99引入一个新关键字inline，
2.2.内联函数 请点评
如：
如果需要重新定义一个宏，和原来的定义不同，可以先用#undef取消原来的定义，
是不同的，所以这样的重复定义是不允许的：
格）没有关系,
在定义的前后多些空白（这里的空白包括空格、Tab、注释，
重复定义是允许的：
如果在一个程序文件中重复定义一个宏，C语言规定这些重复的宏定义必须一模一样。例如这样的
可如果写了这个;号，宏展开之后就有语法错误，
块不行吗？
见
 static inline void down_read(struct rw_semaphore *sem)
#undef
#define X 3
#define
#define OBJ_LIKE
else
if (n >0)
#define device_init_wakeup(dev,val)
 在定义中间连续多个空白等价于-
might_sleep();
continue;
 device_init_wakeup(d, v);
 这个函数的调用要尽可能快，
用于定义内联函数（inline function）。这种用法在内核代码中很常
v);末尾的;号，
1
1)
一节的例子改-
，if语句被这个;号结束掉了，没法跟else配对。因
一个空白，但在定义中间有空白和没有空白被认为
如果不允许写这个;号,
下:
，可以当普通的函数调用实现，也可以用宏
= !!(val);,
因为前一步预处理要把注释替换成空
看起来不像个函数调用
，再重新定义，
363
例
---
## Page 364
可以看到MAx是作为普通函数调用的。如果指定优化选项编译，然后反汇编：
按往常的步骤编译然后反汇编：
例21.2.内联函数
0x804!
84889518
E:
88
804836c:
804836a:
888
8
8
8
8
888
8
8
8048369:
nt max(int n)
304839d:
3048399:
3048380
304838
04838
304837a:
3048373:
·
 max(int n)
5
8
8
8
int main(void)
int
int a[] = { 9， 3， 5， 
inline int MAx(int a, int b)
C
２
d
8
5
c0(,%eax,4)
return n :
：
：
：
 max(int 
return 
return a > b ? a : b;
-0
e88
9
 8.
e８８８
a8
87
8
5
9b
8
6
8
6
ｂb3
6L
35
6
5
n)
,%eax
0
54
08
4
C
５９５８
n n == 0 ? a[0] : MAx(a[n], I
0
a
好好开
记记
86
00
0
0408
ff
00
c0
ff
95
2，１，0，
ff
ff
]: MAX(a[n],
50408
call
mov
sub
mov
jne
cmp1
 sub
push
mov
 max(n-1)
6，4};
%edx,0x4(%esp)
$0xl,%eax
0x8(%ebp),%eax
804837f 
$0x0,0x8(%ebp)
%ebp
max(n-1));
364
---
## Page 365
在宏定义中可以用##运算符把前后两个预处理Token连接成一个预处理Token，和#运算符不
在函数式宏定义中，#运算符用于创建字符串，#运算符后面应该跟一个形参（中间可以有空格
2.3.#、#运算符和可变参数请点评
串中的\和"字符要替换成\\和\"。
再比如：
连续多个空白字符被替换成一
或Tab）
可以看到,
STR(hello
#define STR(s) # s
int max(int n)
8048380:
804837e:
inline int MAX(int
8048387
8
8048375:
8048368:
8048363:
8
804835f:
804835c:
8048359:
8048358
8048356
8048355:
，并没有cal1指令调用MAx函数，
304838
304837c:
304836
61:
6
return n == 0 ? a[0] : MAx(a[n], max(n-l));
return a
8
9
=
：O）STR（:
'6}
world)
83 c4 04
3
 8b
al
85
5５
89
√
8
8
eb
8
５８５
一个空格。
8
6
5
3
3
59
5，
%
%edx
ao
@\n),
e0
8
２，１，０，８，７，６，
记孖
950408
04
8
，则宏展开之后字符串的界定符"要替换成\"，
ff
自动用号把实参括起来成为一个字符串，并且实参中的
，MAx函数的指令是内联在max函数中的，由于源代码和指
ff
"abc",
‘\4"`)
一起显示。
R
add
4
test
 qns.
push
push
mov
mov
D
+
d
{
e
$0x4,%esp
%edx,%eax
8048382
%edx,%eax 
%ebx,%ebx 
$0x4,%esp
%esp,%ebp
%ebp
oe
8048382
0x80495a0,%eax
%ebx
%esp)
，字符常量或字
s);，
365
注意
符
---
## Page 366
Foo在定义时带一个参数，在调用时必须传一个参数给它，如果不传参数则表示传了一个空参数。
预处理之后变成:
预处理之后变成foo。roo在定义时不带参数，在调用时也不允许传参数给它。
调用函数式宏定义允许传空参数，这一点和函数调用不同，通过下面几个例子理解空参数的用法。
在宏定义中，
预处理之后变成:
我们知道printf函数带有可变参数，函数式宏定义也可以带可变参数，
中间的##是运算符，宏展开时前后两个#号被这个运算符连接在一起。注意中间的两个空格是不可
预处理之后是concat。再比如，要定义一个宏展开成两个#号，可以这样定义:
理Token，不能出现在宏定义的开头或末尾，所以会报错。
少的，如果写成##，
同，#运算符不仅限于函数式宏定义，变量式宏定义也可以用。例如：
#define FOO(a, b, c） a##b##c
#define Foo(a) foo##a 
FOO()
report(x>y; 
#define showlist(...) printf(#
foo
foobar
#define Foo(） foo 
#define
#define HASH_HASH # ## #
CONCAT(con,
可变参数的部分用_
 report(test,
printf(
会被划分成##和##两个Token，
cat)
 second,
_VA_ARGS_表示，实参中对应...的几个参数可以看成一个参数替
........
((test)?printf(#test):\
.and third items.);
"x is 
%d"
VA ARGS
Y);
而根据定义##运算符用于连接前后两个预处
，同样是在参数列表中
8
---
## Page 367
以上举的宏展开的例子都是最简单的，有些宏展开的过程要做多次替换，例如：
2.4.宏展开的步骤请点评
的,号“吃"掉了。
1)。也可以这样调用：DEBUGP（"info"）。后者相当于可变参数部分传了-
数，
gcc有一种扩展语法，如果#运算符用在_VA_ARGS_前面，
F00(1)这个调用相当于可变参数部分传了一个空参数，r00(1,2,3,)这个调用相当于可变参数部分传
预处理之后变成:
三个参数，F00(1,2)这样的调用是错误的。
Foo在定义时带三个参数，在调用时也必须传三个参数给它，空参数的位置可以空着，但必须给够
预处理之后变成:
2．n#x要替换成nsub_z。
1．#x要替换成"sub_z"。
3.
除了带#和##运算符的参数之外，其它参数在替换之前要对实参本身做充分的展开，所以应该
#define 
#define DEBUGP(format,·..） printk(format, ## 
F00(,,3)
sh(sub_z)
 sub_z
，也带有格式化字符串和可变参数，
，除了起连接作用之外还有特殊的含义
_VA_ARGS_
，由于内核不能调用iibc的函
一个空参数，但展开后并不
367
---
## Page 368
展开的步骤是:
再举一个例子：
1.预处理的步骤
上一页
1．先把g展开成再替换到#define t(a）a中，得到t(f(0）＋t)(1);。
宏定义，
把x替换成2,
先把sub_z展开成26再替换到alt[x]中x的位置。
成2了，
遇到就不展开了
t(t(g)(0) +t)(1);
#define 
#define
#undef x 
#define f(a) f(x * (a))
#define x 3 
-..-..-..-..-..-..--
所以用2来替换。还要注意一点，
，这时会进一步展开。
又重新定义x为2。
2f
，这样规定可以避免无穷展开（类似于无穷递归），
"sub_z"
全国嵌入式人才培训基地
起始页
上一级
所以不能再展开了。
，注意，
，一开始定义x为3，
，这时不能再展开t(1)了，
，但是后来用#undef x取
，因此我们可以放心地
所有参数都替换完
3.条件预处理指示
，因为这里
这里面
下一页
但
---
## Page 369
个*号），然后保存退出，会生成一个名为.config的隐藏文件，其内容类似于：
在Linux内核源代码的目录下运行make menuconfig命令可以出来一个配置菜单，在其中配置的选项
2、在所有需要配置的源文件开头包含一个头文件，在头文件中定义#define MACHINE 8086，