(cid:69)(cid:73)
(cid:100)(cid:60)(cid:115)(cid:89)(cid:93)(cid:60)(cid:71)(cid:3)(cid:89)(cid:73)(cid:91)(cid:79)(cid:106)(cid:80)(cid:143)(cid:3)(cid:197)
(cid:100)(cid:60)(cid:115)(cid:89)(cid:93)(cid:60)(cid:71)(cid:143)(cid:3)(cid:193)(cid:201)(cid:69)(cid:69)(cid:202)(cid:201)(cid:194)(cid:201)
(cid:193)(cid:201)(cid:69)(cid:69)(cid:202)(cid:201)(cid:194)(cid:201)
(cid:106)(cid:93)(cid:106)(cid:60)(cid:89)(cid:3)(cid:89)(cid:73)(cid:91)(cid:79)(cid:106)(cid:80)(cid:143)(cid:3)(cid:197)(cid:197)
(cid:69)(cid:93)(cid:90)(cid:100)(cid:103)(cid:73)(cid:104)(cid:104)(cid:73)(cid:71)(cid:143)(cid:3)(cid:22)(cid:60)(cid:89)(cid:104)(cid:73)
(cid:90)(cid:104)(cid:79)(cid:25)(cid:71)(cid:143)(cid:3)(cid:193)
(cid:91)(cid:107)(cid:90)(cid:143)(cid:3)(cid:194)
(cid:90)(cid:73)(cid:104)(cid:104)(cid:60)(cid:79)(cid:73)(cid:3)(cid:106)(cid:115)(cid:100)(cid:73)(cid:143)(cid:3)
(cid:33)(cid:104)(cid:79)(cid:162)(cid:23)(cid:195)(cid:13)(cid:162)(cid:49)(cid:100)(cid:71)(cid:60)(cid:106)(cid:73)(cid:25)(cid:106)(cid:73)(cid:90)
(cid:100)(cid:60)(cid:115)(cid:89)(cid:93)(cid:60)(cid:71)(cid:3)(cid:89)(cid:73)(cid:91)(cid:79)(cid:106)(cid:80)(cid:143)(cid:3)(cid:194)(cid:198)
(cid:100)(cid:60)(cid:115)(cid:89)(cid:93)(cid:60)(cid:71)(cid:143)(cid:3)
(cid:193)(cid:201)(cid:193)(cid:195)(cid:194)(cid:195)(cid:193)(cid:68)(cid:193)(cid:201)(cid:202)(cid:68)(cid:73)(cid:73)(cid:194)(cid:60)(cid:194)(cid:193)(cid:202)(cid:193)(cid:197)(cid:73)(cid:194)(cid:201)(cid:73)
(cid:193)(cid:201)(cid:193)(cid:195)(cid:194)(cid:195)(cid:193)(cid:68)(cid:193)(cid:201)(cid:202)(cid:68)(cid:73)(cid:73)(cid:194)(cid:60)(cid:194)(cid:193)(cid:202)(cid:193)(cid:197)(cid:73)(cid:194)(cid:201)(cid:73)
(cid:194)(cid:202)(cid:193)(cid:193)(cid:202)
(cid:194)(cid:202)(cid:193)(cid:193)(cid:202)
(cid:43)(cid:103)(cid:93)(cid:106)(cid:93)(cid:69)(cid:93)(cid:89)(cid:68)(cid:107)(cid:78)(cid:3)
(cid:100)(cid:60)(cid:115)(cid:89)(cid:93)(cid:60)(cid:71)(cid:3)(cid:71)(cid:73)(cid:69)(cid:93)(cid:71)(cid:81)(cid:91)(cid:79)
(cid:194)(cid:143)(cid:3)(cid:196)(cid:202)(cid:199)(cid:196)(cid:199)(cid:197)
(cid:196)(cid:202)(cid:199)(cid:196)(cid:199)(cid:197)
(cid:12)(cid:107)(cid:81)(cid:89)(cid:71)(cid:81)(cid:91)(cid:79)(cid:3)(cid:25)(cid:15)
(cid:194)(cid:143)(cid:3)(cid:195)(cid:3)(cid:106)(cid:115)(cid:100)(cid:73)(cid:159)(cid:3)(cid:107)(cid:100)(cid:71)(cid:60)(cid:106)(cid:73)
(cid:195)(cid:3)(cid:169)
(cid:3)(cid:3)(cid:194)(cid:143)(cid:3)(cid:197)(cid:197)(cid:193)(cid:193)(cid:202)(cid:194)
(cid:3)(cid:3)(cid:195)(cid:143)(cid:3)(cid:194)(cid:193)(cid:193)(cid:193)(cid:193)(cid:3)
(cid:3)(cid:3)(cid:196)(cid:143)(cid:3)(cid:194)(cid:197)(cid:202)(cid:199)(cid:193)(cid:194)(cid:3)(cid:3)
(cid:194)(cid:197)(cid:202)(cid:199)(cid:193)(cid:194)(cid:3)
(cid:170)
(cid:33)(cid:93)(cid:91)(cid:73)(cid:115)(cid:3)(cid:91)(cid:107)(cid:90)(cid:68)(cid:73)(cid:103)(cid:3)
(cid:33)(cid:73)(cid:104)(cid:104)(cid:60)(cid:79)(cid:73)(cid:3)(cid:195)(cid:143)(cid:3)(cid:13)(cid:93)(cid:81)(cid:91)(cid:3)(cid:69)(cid:93)(cid:89)(cid:89)(cid:73)(cid:69)(cid:106)(cid:81)(cid:93)(cid:91)(cid:3)(cid:103)(cid:73)(cid:104)(cid:100)(cid:93)(cid:91)(cid:104)(cid:73)
Figure 6: Decoding traﬃc of Army of Toys: message 1 and 2.
We analyzed the decompiled code to ﬁgure out the encoding
protocols of two layers. Here we zoom in the message 1 and
2 in Figure 5 to explain how the server maintains the coins
the gamer can collect and how the server informs the client
about the coins update.
As a concrete example, we describe our observations about
Army of Toys, which is a multi-player strategy game. The
game uses a special message format, and we managed to
reverse engineer its encoding protocols by decompiling the
code. It took us a considerable amount of eﬀort to under-
stand the message format of their communication. As shown
in Figure 6, we observed from the decompiled source code
that Army of Toys uses two layers of encoding. We ﬁrst de-
code the TCP payload (the left textbox). According to the
decoding protocol we found from the decompiled code, we
obtain the content in the middle textbox. We see that even
this decoded content still constains an encoded payload. Af-
ter further investigation, we found that the second encoding
is in protobuf format [21], and we were able to further de-
code the payload to obtain the content in the right textbox.
This multi-step analysis and decoding process allows us to
understand the traﬃc, but with signiﬁcant eﬀort.
5.3 Code Obfuscation and Hiding
Code obfuscation and hiding are commonly used by games
developed with the Google SDK, which provides obfuscation
functionality. As we discussed earlier, our hacking eﬀort suc-
ceeded in many of the studied cases because we were able
to ﬁgure out the program logic. If done eﬀectively, code ob-
fuscation and hiding can be a suﬃcient (though not perfect)
deterrent to game hackers who try to reverse engineer the
game.
5.3.1 Code Obfuscation
Kill Shot is a shooting game developed using Android
SDK and NDK. We did not succeed in hacking the game
by local resource editing or traﬃc analysis, so we attempted
to decompile the code. We found that class names and vari-
able names of the program are obfuscated, which makes it
very diﬃcult to ﬁgure out how to take control of sensitive
data that attackers want to manipulate.
5.3.2 Code Hiding
A number of games try to hide the existence of important
code components, rather than obfuscate them. For exam-
ple, Army of Toys mentioned earlier does not load certain
important libraries when the game starts. Instead, it down-
loads these compressed libraries at certain points during the
game.
5.4 Compilation into Native Code
Implementing important game logic in native code is an-
other approach to increase the diﬃculty of reverse engineer-
ing. Once compiled into native code, a program has lost
most compile-time information, such as variable names and
type information. Moreover, native code instructions are
much harder to be reverted to their source code statements.
If compiler optimizations are applied, then the code is even
harder to understand. For this reason, developers can take
advantage of this feature of native code compilation to de-
fend against game hacking attempts. This approach can be
further combined with code obfuscation techniques.
For example, the game Angry Birds hides the local stor-
age protection inside a native code library libAngryBird-
sClassic.so. We did not get suﬃcient information from
decompilation to recover the logic. However, we found an
encrypted ﬁle named highscores.lua and used a debug-
ging tool to analyze it. We recovered the symbol table for
function names and then tried to use the GDB debugger to
follow the interesting functions for the game logic. Angry
Birds is time-consuming to analyze because the game has
many functions related to security. We had to debug many
encryption functions to get their parameters and test if each
parameter is the right key for decrypting highscore.lua.
After much eﬀort, we were able to get the right key from
the function AES::StartEncryption. This step is shown in
Figure 7. Using the key, we were able to decrypt, modify,
and re-encrypt the highscore.lua ﬁle, which resulted in a
modiﬁed in-game score.
5.5 Client-Server Sync
A small number of games implement client-server sync.
The eﬀectiveness of protection comes from the fact that the
computation is performed on the server-side, and the client
is forced to synchronize state with the server. We explained
in Section 5.2.4 that the client-server sync can be eﬀective
if the client side code is basically a “renderer”, whereas all
the game states are computed and maintained by the server.
Figure 7: Debugging Angry Birds for recovering the keys.
We try many functions for encryptions to recover the key,
and ﬁnally get it in AES:StartEncryption from libAngry-
BirdsClassic.so. The ﬁgure is a screenshot when the game
hits the breakpoint in AES:StartEncryption and R1 stores
the key as is shown in the red box.
Figure 8: Developers of Trivia Crack try to maintain player
status on the server side and sync with client side, but they
fail because they still trust the client to compute important
logic such as whether gamers have enough coins or when the
gamers use power-ups. Therefore, we can modify message
2 to increase coins and use the coins locally, also tamper
message 3 not to report using powder-ups.
However, some games still depend on the client side to do
sensitive computations, such as those about coins and battle
results. These games are vulnerable to hacks. Below are the
details about some of these games.
5.5.1 Partial Client-Server Sync
Trivia Crack is a game in which a gamer competes with
friends in answering multiple-choice questions. The gamer
can purchase coins using in-app purchases and use “power-
ups” to eliminate some wrong options. We use traﬃc anal-
ysis to get a rough understanding of the program’s logic.
When one gamer answers a question, Trivia Crack sends a
message to its server, including question id, the chosen op-
tion, and the power-ups that the gamer uses for this ques-
tion; the process is shown in Figure 8. Trivia crack com-
putes the score on the server side according to the mes-
sage. A direct memory modiﬁcation would fail to change
the score because the authoritative copy of the score is not
in the client’s memory. However, Trivia Crack still depends
on the client to do important computations such as decid-
ing whether the gamer has enough coins to use power-ups
and whether power-ups have been used to remove incorrect
options. Therefore, the server to client message can be mod-
393
iﬁed to trick the client to believe that the gamer has more
coins (message 2 in Figure 8). Similarly, the client-to-server
message can be modiﬁed to persuade the server that the
gamer did not use power-ups (message 3 in Figure 8). There
are several other weaknesses of this nature in Trivia Crack.
For example, it judges whether the gamer is right on the
client side, so a hacker can just switch the device to the of-
ﬂine mode after the question is loaded and answer it many
times until he gets the correct answer. Then, he can switch
the device back to the online mode to update the result.
5.5.2 Full Client-Server Sync
Unlike the partial client-server sync, if the game does not
depend on the client side to do any important computa-
tion, the program will be very robust against hacks. We
only see a few examples of such games, all in the multi-
player game category. Army of Toys uses encoded traﬃc
as a protection, as we discussed previously.
It also uti-
lizes encoded communication for synchronizing client states
with the server. All the game logic is maintained on the
server side, which only exposes the display interfaces to the
client-side code. Every action the gamer performs triggers
a number of messages exchanged between the server and
the client. For example, as shown in Figure 5, when a
gamer collects coins from a factory, the client sends a packet
“Msg C2G GatherResource” to inform the server that the
gamer wants to collect resources from the factory build-
ing. Server replies with “Msg G2C UpdateItem” to update
the coins that the gamer should be able to collect. The
server also sends building information to control the display
of buildings, such as what time will the gamer be able to
collect coins again, in packet “Msg G2C AskBuildingInfo”.
Because the server performs all the sensitive logic compu-
tations, gamers cannot hack the client or traﬃc to fool the
server. Although we spent eﬀorts to decode two layers of
payload and understand every ﬁelds in its traﬃc (see Fig-
ure 6), our eﬀorts to hack this game were unsuccessful.
6. SUGGESTIONS TO MOBILE GAME DE-
VELOPERS
The previous sections focused on understanding various
protection mechanisms. Following the understanding, a prac-
tical question to ask is how game developers should consider
adopting these protections. The consideration is a judge-
ment about the cost of each mechanism and the protection
strength.
6.1 Cost of Protection
The cost of each protection mechanism includes the de-
veloper’s eﬀort and the runtime cost, which are the two di-
mensions shown in Figure 9. Based on our studied cases, we
place the protection mechanisms in this space.
Local resource protection is easy to implement because
it does not aﬀect the game’s logic. A developer just de-
cides which sensitive variables need protection, and applies
encryption or encoding on them. The runtime cost is also
low.
Code obfuscation is easy on Android SDK/NDK – the
developers only need to conﬁgure the project to enable Pro-
Guard [19]. However, if the platform does not support ob-
fuscation, developers’ eﬀort will be signiﬁcantly higher. Sim-
ilarly, the developer’s eﬀort for native code compilation also
(cid:25)(cid:26)(cid:24)(cid:25)(cid:1)
(cid:9)(cid:30)(cid:29)(cid:26)(cid:34)(cid:30)(cid:32)(cid:26)(cid:29)(cid:24)(cid:1)
(cid:31)(cid:32)(cid:30)(cid:18)(cid:20)(cid:33)(cid:33)(cid:1)
(cid:4)(cid:27)(cid:26)(cid:20)(cid:29)(cid:34)(cid:45)(cid:33)(cid:20)(cid:32)(cid:39)(cid:20)(cid:32)(cid:1)(cid:33)(cid:41)(cid:29)(cid:18)(cid:1)
(cid:1)
(cid:34)
(cid:33)
(cid:30)
(cid:18)
(cid:1)
(cid:20)
(cid:28)
(cid:36)
(cid:29)
(cid:38)
(cid:13)
(cid:14)(cid:20)(cid:18)(cid:38)(cid:32)(cid:20)(cid:1)
(cid:38)(cid:31)(cid:19)(cid:16)(cid:36)(cid:29)(cid:24)(cid:1)
(cid:4)(cid:38)(cid:33)(cid:34)(cid:30)(cid:28)(cid:26)(cid:42)(cid:20)(cid:19)(cid:1)(cid:34)(cid:32)(cid:16)(cid:23)(cid:18)(cid:1)
(cid:31)(cid:32)(cid:30)(cid:34)(cid:20)(cid:18)(cid:36)(cid:30)(cid:29)(cid:1)
(cid:11)(cid:17)(cid:21)(cid:38)(cid:33)(cid:18)(cid:16)(cid:36)(cid:30)(cid:29)(cid:1)(cid:46)(cid:30)(cid:34)(cid:25)(cid:20)(cid:32)(cid:1)
(cid:31)(cid:27)(cid:16)(cid:35)(cid:30)(cid:32)(cid:28)(cid:33)(cid:47)(cid:1)
(cid:11)(cid:17)(cid:21)(cid:38)(cid:33)(cid:18)(cid:16)(cid:36)(cid:30)(cid:29)(cid:1)
(cid:46)(cid:2)(cid:29)(cid:19)(cid:32)(cid:30)(cid:26)(cid:19)(cid:44)(cid:1)(cid:12)(cid:4)(cid:47)(cid:1)
(cid:3)(cid:16)(cid:33)(cid:26)(cid:18)(cid:1)
(cid:6)(cid:15)(cid:15)(cid:12)(cid:14)(cid:1)
(cid:8)(cid:30)(cid:18)(cid:16)(cid:27)(cid:1)(cid:32)(cid:20)(cid:33)(cid:30)(cid:38)(cid:32)(cid:18)(cid:20)(cid:1)
(cid:31)(cid:32)(cid:30)(cid:34)(cid:20)(cid:18)(cid:36)(cid:30)(cid:29)(cid:1)
(cid:10)(cid:16)(cid:36)(cid:39)(cid:20)(cid:1)(cid:18)(cid:30)(cid:19)(cid:20)(cid:1)
(cid:46)(cid:2)(cid:29)(cid:19)(cid:32)(cid:30)(cid:26)(cid:19)(cid:1)(cid:10)(cid:5)(cid:7)(cid:1)(cid:30)(cid:32)(cid:1)
(cid:18)(cid:30)(cid:18)(cid:30)(cid:33)(cid:48)(cid:19)(cid:45)(cid:40)(cid:47)(cid:1)
(cid:10)(cid:16)(cid:36)(cid:39)(cid:20)(cid:1)(cid:18)(cid:30)(cid:19)(cid:20)(cid:1)(cid:46)(cid:30)(cid:34)(cid:25)(cid:20)(cid:32)(cid:1)
(cid:31)(cid:27)(cid:16)(cid:35)(cid:30)(cid:32)(cid:28)(cid:33)(cid:47)(cid:1)
(cid:25)(cid:26)(cid:24)(cid:25)(cid:1)
(cid:5)(cid:20)(cid:39)(cid:20)(cid:27)(cid:30)(cid:31)(cid:20)(cid:32)(cid:1)(cid:20)(cid:22)(cid:30)(cid:32)(cid:34)(cid:1)
Figure 9: Protection cost comparison.
depends on the platform support. It is easier for games de-
veloped using Android SDK/NDK or cocos2d-x(a game de-
velopment engine in C++) to include native code libraries
than those using other platforms. Usually, compilation to
native code does not incur much runtime cost. In fact, the
code might run even slightly faster as a result.
Traﬃc protection can be an easy job if it uses standard
protocols, such as basic HTTPS. However, developing a cus-
tomized traﬃc protection requires much more eﬀort.
Client-server sync is most diﬃcult because it is game spe-
ciﬁc. Developers need to consider carefully about the game
logic so that they can make sure all important logic are com-
puted correctly in the server side. The runtime cost is also
high, because it incurs a large amount of traﬃc for synchro-
nizing the game states. For light-traﬃc games, this protec-
tion is not a reasonable choice. Only multi-player games that
already have frequent network communications are suitable
for client-server sync.
6.2 Strength of Protection
Software development involves many aspects of consider-
ation, such as the go-to-market schedule, the available man-
power, and the budget constraints. We believe that mobile
game development is no exception. Every game is devel-
oped under a speciﬁc set of time pressures and ﬁnancial con-
straints. It would be biased for us, as security researchers, to
suggest that protecting against game-hacks is of paramount
importance over all other considerations. Nevertheless, the
knowledge obtained through our study can help developers
make more informed decisions about which mechanisms to
adopt.
Speciﬁcally, Table 3 shows all combinations of protections
that we observe in the studied games. We rank their pro-
tection strengths using a 5-level rating. Level 1 is weakest.
The hacker can use general tools to hack the game. Level
2 can resists the general tools, but is vulnerable to traﬃc
analysis. Level 3 forces the hacker to do decompilation to
understand the game’s logic. Level 4 requires even manual
debugging eﬀort. Level 5 is assigned to those that we have
not found vulnerabilities in the principles of their protec-
tion approaches. Levels 1 - 4 consist of sub-levels indicated
by letters in an ascending order of strength. The right-most
two columns show the number of games in each sub-level and
how many of them we have successfully hacked. In total, we
have succeeded in 77 cases, including every game below the
4B rating and 7 games with 4B - 4D ratings. There are 18
games that we do not think vulnerable (i.e., with rating 5)in
394
Protection
Level
1A
1B
2A
2B
2C
3A
3B
4A
4B
4C
4D
5
Local resource
protection
Code obfusca-
tion
NA
Partial
Full
Full
NA
Full
NA
Full
Full
Full
NA
*
*
*
*