# CVE-2021-3156调试分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
最近才爆出的sudo提权漏洞，危害十分大，能够影响到20.04版本。本文是根据原作者文章学习所得，如有错误，敬请各位大佬斧正，万分感谢。
## 漏洞环境
**操作系统** ：ubuntu 18.04.1  
 **sudo** ：1.8.21p2  
 **glibc** ：2.27  
 **exp** ：
## 漏洞分析
CVE-2021-3156 ——sudo在处理单个反斜杠结尾的命令时，发生逻辑错误，存在堆溢出漏洞。当 sudo通过 -s 或 -i命令行选项在
shell模式下运行命令时，他将在命令参数中使用反斜杠转义特殊字符。但使用 -s或 -i标志运行 sudoedit时，实际上并未进行转义，从而导致堆溢出。
###  代码分析
sudo加上 -s选项会设置 MODE_SHELL，加上 -i选项会设置 MODE_SHELL和 MODE_LOGIN_SHELL。在
main()（sudo.c）函数中调用了parse_args()，parse_args()会连接所有命令行参数，并给元字符加反斜杠来重写 argv。
    //sudo.c 
    /* Parse command line arguments. */
        sudo_mode = parse_args(argc, argv, &nargc, &nargv, &settings, &env_add);
        sudo_debug_printf(SUDO_DEBUG_DEBUG, "sudo_mode %d", sudo_mode);
parse_args()下面一段代码的主要功能是先判断是否启用了 -s或 -i的 MODE_SHELL，如果启用了就对参数前面加上反斜杠重写参数。
    //parse_args.c   parse_args()
    /*
         * For shell mode we need to rewrite argv
         */
        if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {    //检查是否开启 MODE_SHELL
        char **av, *cmnd = NULL;
        int ac = 1;
        if (argc != 0) {
            /* shell -c "command" */
            char *src, *dst;
            size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) +
            strlen(argv[argc - 1]) + 1;
            cmnd = dst = reallocarray(NULL, cmnd_size, 2);
            if (cmnd == NULL)
            sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
            if (!gc_add(GC_PTR, cmnd))
            exit(1);
            for (av = argv; *av != NULL; av++) {
            for (src = *av; *src != '\0'; src++) {
                /* quote potential meta characters */
                if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$')
                *dst++ = '\\';    //添加反斜杠
                *dst++ = *src;    //原参数
            }
            *dst++ = ' ';
            }
            if (cmnd != dst)
            dst--;  /* replace last space with a NUL */
            *dst = '\0';
            ac += 2; /* -c cmnd */
        }
在sudoers_policy_main()中调用了 set_cmnd()函数
    //sudoers.c sudoers_policy_main()
        /* Find command in path and apply per-command Defaults. */
        cmnd_status = set_cmnd();
        if (cmnd_status == NOT_FOUND_ERROR)
        goto done;
在 set_cmnd()函数中，首先根据参数使用 strlen()函数计算了参数的 size，再调用 malloc()函数分配了 size大小的堆空间
user_args 。随后判断是否开启了 MODE_SHELL，如果开启了将会 连接命令行参数并存入堆空间 user_args。
    // sudoers.c set_cmnd()    
    /* set user_args */
        if (NewArgc > 1) {
            char *to, *from, **av;
            size_t size, n;
            /* Alloc and build up user_args. */
            for (size = 0, av = NewArgv + 1; *av; av++)
            size += strlen(*av) + 1;
            if (size == 0 || (user_args = malloc(size)) == NULL) {
            sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
            debug_return_int(-1);
            }
            if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {    //检查是否开启 MODE_SHELL或MODE_LOGIN_SHELL
            /*
             * When running a command via a shell, the sudo front-end
             * escapes potential meta chars.  We unescape non-spaces
             * for sudoers matching and logging purposes.
             */
            for (to = user_args, av = NewArgv + 1; (from = *av); av++) {    //from指向 命令参数
                while (*from) {
                if (from[0] == '\\' && !isspace((unsigned char)from[1]))
                    from++;
                *to++ = *from++;    //将from拷贝到 user_args
                }
                *to++ = ' ';
            }
            *--to = '\0';
            } else {
            for (to = user_args, av = NewArgv + 1; *av; av++) {
                n = strlcpy(to, *av, size - (to - user_args));
                if (n >= size - (to - user_args)) {
                sudo_warnx(U_("internal error, %s overflow"), __func__);
                debug_return_int(-1);
                }
                to += n;
                *to++ = ' ';
            }
            *--to = '\0';
            }
        }
        }
上面将命令行参数拷贝给堆空间的逻辑，如果命令行参数以1个反斜杠结尾例如 `$ sudo -s / 112233` ：
     from[0]是反斜杠，from[1]是 null 结束符（非空格），满足如下要求  if (from[0] == '\\' && !isspace((unsigned char)from[1]))   ；
    所以，from 加1，指向 null 结束符；
    null 结束符被拷贝到 user_args堆缓冲区， from又加1，from指向了null结束符后面第1个字符（超出参数的边界，此时为 1）；
    随后会继续循环将越界字符拷贝到 user_args堆缓冲区，发生了堆溢出漏洞
###  漏洞触发
上面指出，在 parse_args()会对启用了 -s或 -i的 MODE_SHELL和 MODE_RUN 的 sudo的参数加上 反斜杠 转义。
    //parse_args.c parse_args()
        /*
         * For shell mode we need to rewrite argv
         */
        if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
        ...
而 set_cmnd()函数中触发堆溢出前，会判断是否启用了 MODE_SHELL 和 MODE_RUN、MODE_EDIT、MODE_CHECK
中的一个。那么就存在一个矛盾，如果要触发漏洞就需要启用 MODE_SHELL，但是如果启用了 MODE_SHELL，在
parse_args()函数中就会对所有参数转义，触发漏洞的 \，将会被转义为 \\\，这样就无法触发漏洞了。
    //sudoers.c set_cmnd()
        if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {    
        ...
        if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
        ...
所以这里 并没有使用 sudo，而是使用 sudoedit。原因在于如果使用 sudoedit，其还是会被软链接到使用 sudo命令，但是在
parse_args()函数中会自动设置 MODE_EDIT和不会重置 valid_flags，则 MODE_SHELL仍然在 valid_flags中
，而且不会设置 MODE_RUN,这样就能跳过 parse_args()函数中转义参数的部分，同时满足 set_cmnd()函数中漏洞触发的部分。
    //parse_args.c parse_args()
    #define DEFAULT_VALID_FLAGS     (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL) 
    ... 
    int valid_flags = DEFAULT_VALID_FLAGS;     //valid_flags默认参数包含MODE_SHELL，不包含MODE_RUN
    ...
    /* First, check to see if we were invoked as "sudoedit". */
        proglen = strlen(progname);
        if (proglen > 4 && strcmp(progname + proglen - 4, "edit") == 0) {
        progname = "sudoedit";
        mode = MODE_EDIT;    //设置MODE_EDIT
        sudo_settings[ARG_SUDOEDIT].value = "true";
        }
注意：这里还要解释一下该漏洞可利用的几个有利点（参考该文）：
    user_agrs堆空间的 size是可控的，就是我们输入的 命令参数合并后的长度；
    我们溢出的内容是可控的，取决于我们输入的 \后的字符内容，该字符会全部被溢出写到堆块后；
    可以写 null字节到 user_args，每个以单反斜杠结尾的命令行参数或环境变量，都能往user_args写1个null字节
    可以写连续多个 null，环境变量并不一定得是env_name=XXX这种形式，环境变量可以是字符串数组。C代码中用execve执行shell命令，环境变量设置2个连续的\即可插入2个连续的null字节。
    char *env[] = { "AAA", "\\", "\\", "BBB", NULL };
    execve("/usr/bin/sudoedit", argv, env);
## 漏洞调试
###  漏洞触发点
最开始想自己编译一个 sudo，带符号的调试更方便。但是这样会导致漏洞执行不成功。所以就只有用系统自带的无符号的sudo进行调试。
首先使用如下命令运行 exp:
    sduo gdb --args ./sudo-hax-me-a-sandwich 0
随后，在 execve下断点：
    catch exec
再运行该 `continue`。
随后，gdb会断在 execve函数。我们在下断点 b setlocale，在继续运行，此时就会停在 setlocale函数。该函数是我们在执行
sudo最开始时会调用的。我们 finish后，就能够进入 sudo的 main函数中。
    //sudo.c
    int
    main(int argc, char *argv[], char *envp[])
    {
        int nargc, ok, status = 0;
        char **nargv, **env_add;
        char **user_info, **command_info, **argv_out, **user_env_out;
        struct sudo_settings *settings;
        struct plugin_container *plugin, *next;
        sigset_t mask;
        debug_decl_vars(main, SUDO_DEBUG_MAIN)