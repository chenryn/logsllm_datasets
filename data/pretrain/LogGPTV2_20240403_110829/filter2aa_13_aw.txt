查看颜色的确变成粉色了，再看看imei值的修改：
imei值也Hook成功了。到这里就用Cydia Substrate框架Hook了Java层功能。之前提到的Xposed框架也是可以做到这些功能的。
19.3 Hook Native层功能
下面继续来看如何Hook Native层的功能，也是本章的重点。
第一步：创建一个Native项目
这里用Eclipse操作，简单便捷，有很多人问为什么不用AS，这要看每个人的使用习惯。虽然AS工具是主流，不过本人还是习惯用Eclipse，如图19-5所示。
第二步：导入Substrate的Native功能包
需要导入一个substrate.h头文件，和两个so功能包。Native层应用都是这么操作的，提供一个头文件告诉你API，具体实现在so包中。
图19-5 创建Native项目
第三步：寻找Hook的函数名
这里网上没有好的hook代码，为了更好的了解这个工具的厉害之处，弄一个比较实际的案例就是hook系统加载dex的函数，这样就可以获取到每个应用的dex文件了，这种方式对于早期加固是一个比较好的脱壳方案。在之前介绍脱壳会使用IDA在指定函数处下个断点，这里如果要hook的话，就需要找到这个加载dex的函数名称，一定要记的是导出的函数名。
下面就用IDA来查找需要Hook的函数名，首先导出设备的libdvm.so文件：system/lib/libdvm.so
然后使用IDA打开，寻找加载dex函数，如图19-6所示。
图19-6 寻找加载dex函数
切换到Exports视图页面，然后搜索dexFileParse函数，点进去：
需要得到的是EXPORT函数，需要Hook的是它，一定要注意函数，不然Hook没效果的。找到函数之后还得获取函数的参数类型和返回类型，这个也好办，因为有Android源码，所以直接在源码中找这个函数参数说明、已经返回值说明即可。因为Native层Hook的其实是函数指针的替换，所以如果想Hook原来的函数，必须新建一个和原来一样的函数功能，然后传递函数指针即可。这个函数的参数和返回值定义如下：
参数含义非常简单，第一个参数表示dex文件的起始地址，第二个参数是dex文件的长度，有这两个参数就可以写入文件了。这里需要获取DexFile类型，这个直接在Android源码目录下找到这个头文件DexFile.h即可。然后导入工程中。这样就找到了需要hook的函数，下面就开始编写hook代码了。
第四步：编写hook代码
在编写hook代码之前，需要考虑这几件事：
·hook之后的dex存在哪？怎么存？这里直接通过当前的pid值获取进程名，然后将其作为dex的文件名，这样每个进程的dex文件名就不会冲突了。这里要理解一点：一个进程对应一个DVM，加载一个dex文件。所以这里hook其实就是注入每个进程，在每个进程中hook每个函数功能。
·需要过滤系统进程，并不是所有的进程都是想要hook的，而且这些进程未必有dex文件，比如鼻祖进程zygote，而这些进程过滤规则，需要自己打印看结果，然后构造。
下面开始写代码了，首先定义想要hook的so文件：
主要是第二个参数，是需要hook的so路径。然后在入口处开始hook代码：
这里找到so中需要hook函数符号，然后直接调用MSHookFunction传入符号，新函数地址，旧函数地址。可以看到在C中指针是多么强大，实现了函数的回调机制，而且非常方便。然后继续来看新定义的hook函数功能：
这里先获取当前进程名称，然后构造dex文件名，保存dex文件，最后一定要记得返回原始的函数功能，不能影响正常的流程。还要记得过滤规则，不要对每个进程都进行操作，并不是每个进程都是有效的。而这些过滤规则是根据自己打印进程名来自行添加即可。
第五步：编写MK文件
上面代码已经编写完成了，下面来编写编译脚本吧。注意编译之后的文件名一定要以cy结尾，不然是hook是失败的，然后就是需要导入substrate的so库文件：
第六步：安装并运行
和之前一样，运行之后，需要重启设备，然后先看看native层的log信息：
然后再去目录中查看保存的dex文件信息，如图19-7所示。
图19-7 dex文件
dex文件都保存成功了，这样会发现如果对于早期的加壳应用，可以采用这种方式进行脱壳操作。也不需要用IDA进行调试dump出dex文件了。
19.4 框架使用事项说明
关于Native层Hook就介绍完了，这里还是需要说明几点：
·Hook之前需要分析so文件获取需要Hook的函数名称，参数返回值定义，这个和Hook Java层一样，必须先找到突破点才能进行下一步。
·Hook可能会有一些错误，因为native层比java层错误信息难发现，所以最好是在某些地方加一些日志观察结果。
如果在使用过程中发现Hook失败，注意检查如下个条件：
·XML中是否配置了权限和入口。
·编译脚本MK中的后缀名是否为cy。
项目下载地址：https://github.com/fourbrother/CydiaSubstrateHook
19.5 本章小结
本章主要从Hook Java层和Native层两个方面介绍了Cydia Substrate框架，关于Hook Java层功能Xposed框架也可以做到，但是对于Native层功能的Hook操作，还是Cydia Substrate框架比较好用，有了这个框架再也不畏惧Hook了，Native层代码也可以一览无余。
操作篇
第20章 静态方式逆向应用
第21章 动态调试smali源码
第22章 IDA工具调试so源码
第23章 逆向加固应用软件技术分析
第24章 逆向应用经典案例分析
第25章 Android中常见漏洞分析
第26章 文件加密病毒Wannacry样本分析
第20章 静态方式逆向应用
本章主要介绍Android中如何使用静态方式逆向apk，学习逆向前，需要了解smali语法和arm指令，本章先介绍这两个知识点，然后介绍如何使用IDA工具来分析so文和工具，最后会通过一个案例来分析静态方式逆向apk的流程和注意事项。
20.1 smali语法
smali、baksmali分别是指安卓系统里的Java虚拟机（Dalvik）所使用的一种，dex格式文件的汇编器、反汇编器，其语法是一种宽松式的Jasmin/dedexer语法，而且实现了.dex格式所有功能（注解、调试信息、线路信息等）。
当对apk文件进行反编译后，便会生成此类的文件，其中在Davlik字节码中，寄存器都是32位的，能够支持任何类型，64位类型（Long/Double）用2个寄存器表示；Dalvik字节码有两种类型：原始类型、引用类型（包括对象和数组）。
1.smali指令
部分smali指令如下：
.field private isFlag：z 定义变量
.method 方法
.parameter 方法参数
.prologue 方法开始
.line 12 此方法位于第12行
invoke-super 调用父函数
const/high16 v0，0x7fo3 把0x7fo3赋值给v0
invoke-direct 调用函数
return-void 函数返回void
.end method 函数结束
new-instance 创建实例
iput-object 对象赋值
iget-object 调用对象
invoke-static 调用静态函数
条件跳转分支指令如下：
"if-eq vA，vB，：cond_**" 如果vA等于vB则跳转到：cond_**
"if-ne vA，vB，：cond_**" 如果vA不等于vB则跳转到：cond_**
"if-lt vA，vB，：cond_**" 如果vA小于vB则跳转到：cond_**
"if-ge vA，vB，：cond_**" 如果vA大于等于vB则跳转到：cond_**
"if-gt vA，vB，：cond_**" 如果vA大于vB则跳转到：cond_**
"if-le vA，vB，：cond_**" 如果vA小于等于vB则跳转到：cond_**
"if-eqz vA，：cond_**" 如果vA等于0则跳转到：cond_**
"if-nez vA，：cond_**" 如果vA不等于0则跳转到：cond_**
"if-ltz vA，：cond_**" 如果vA小于0则跳转到：cond_**
"if-gez vA，：cond_**" 如果vA大于等于0则跳转到：cond_**
"if-gtz vA，：cond_**" 如果vA大于0则跳转到：cond_**
"if-lez vA，：cond_**" 如果vA小于等于0则跳转到：cond_**
2.smali语法案例分析
下面是一个简单方法：
上面代码反编译之后对应的smali语法如下：
如果符合if分支则程序往下走，最终return；而如果条件不符合则会走到：cond_0分支，最终执行goto：goto_0走回到：goto_0返回。
20.2 手动注入smali语句
有时候破解应用时，需要通过全局搜索一些关键的字符串来找突破点，但是这招有时候不好使，所以这时需要加一些代码来观察信息了，这里有一个通用的方法就是加入自己的log代码，来追踪代码的执行逻辑，因为这里讲的是静态分析技术，所以就用代码注入技术来跟踪执行逻辑，后面介绍了动态分析技术之后，那就简单了，可以随意打断点来进行调试。这里的添加代码，就是修改smali代码，添加日志信息即可，下面会用例子来进行讲解，这也是最常用的一种技术。
20.3 ARM指令
逆向者必须能看懂汇编代码，就类似于在调试Java层代码的时候一样，必须会smali语法。庆幸的是，这两种语法都不是很复杂，知道一些大体的语法和指令就可以了，下面来看看ARM指令中的寻址方式、寄存器、常用指令，了解这三个知识点，就会对ARM指令有一个大体的了解。
1.ARM指令中的寻址方式
·立即数寻址
立即数寻址也叫立即寻址，是一种特殊的寻址方式。操作数本身包含在指令中，只要取出指令也就取到了操作数。这个操作数叫做立即数，对应的寻址方式叫作立即寻址。例如：
·寄存器寻址
寄存器寻址是利用寄存器中的数值作为操作数，也称为寄存器直接寻址。例如：
·寄存器间接寻址
寄存器间接寻址就是把寄存器中的值作为地址，再通过这个地址去取得操作数，操作数本身存放在存储器中。例如：
·寄存器偏移寻址
这是ARM指令集特有的寻址方式，它是在寄存器寻址得到操作数后再进行移位操作，得到最终的操作数。例如：
·寄存器基址变址寻址
寄存器基址变址寻址又称为基址变址寻址，是在寄存器间接寻址的基础上扩展来的。它将寄存器（该寄存器一般称作基址寄存器）中的值与指令中给出的地址偏移量相加，从而得到一个地址，通过这个地址取得操作数。例如：
·多寄存器寻址
这种寻址方式可以一次完成多个寄存器值的传送。例如：