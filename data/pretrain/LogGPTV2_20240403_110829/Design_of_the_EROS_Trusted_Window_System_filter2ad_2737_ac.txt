optionally inform the display server that this mouse se-
quence is a drag action. In that case, subsequent Mouse-
Move events may be delivered to other windows in the
form of DragOver events, and the ﬁnal MouseUp event
(which completes the drag and drop idiom) is delivered to
both the originating and the destination window.
Two points should be noted here with regard to covert
channels and multilevel security:
(cid:15) The display server is aware that the drag and drop
idiom is a precursor step to an act of communica-
tion. DragOver and MouseUp events are delivered
to the window under the mouse only if that window
would be permitted to receive the data transfer im-
plied by the drag and drop idiom.
(cid:15) DragOver events are not a signiﬁcant covert chan-
nel, because they are limited by the rate of user in-
put.
the deallocation of the memory region by the receiver and
can use observation of deallocation latency for signalling
purposes.3
6.3 MLS Format Negotiation
In MLS systems, a problem with both “cut and paste” and
“drag and drop” can arise from format negotiation. The
client is prepared to provide some number of different for-
mats, but does not wish to render all of them because most
of them will not be used. The recipient has a (hopefully
intersecting) set of formats that it wishes to receive. At a
minimum, this set includes the native format (e.g. so that
the drawing can be transferred back to the original ap-
plication for subsequent editing) and at least one common
format that the recipient can render. The usual approach to
negotiating formats is that the sender sends a list of trans-
missable formats and the recipient replies with the subset
that it wants. This is acceptable in a single-compartment
environment, but in an MLS environment, this downward
communication is not permitted.
An elegant way of eliminating the downward communica-
tion problem is feasible in systems that, like EROS, pro-
vide a conﬁnement mechanism [17, 30]. The EROS oper-
ating system provides a utility service called a constructor
that instantiates new programs. Among the services pro-
vided by the constructor are the ability to verify that newly
instantiated programs created by that constructor have no
outward communication channels. Building on this this
utility, we can divide the problem into two parts: (1) trans-
mitting the singleton “native” format of the sender and (2)
transmitting a set of conﬁned converters that know how to
translate from this native format to other formats that the
client knows how to produce.
The main problem with transmitting the memory region
containing the singleton native format is durability. The
memory region containing the native format material will
be needed for an unbounded amount of time, and a re-
cipient in a higher-level compartment is not permitted to
inform the sender in a lower-level compartment that it is
done with the data. Our solution is to require every sender
to supply a constructor for initially empty, conﬁned mem-
ory regions that are built from sender storage. The native
format is serialized to this region, the region is frozen (to
prevent further modiﬁcation by either party), and a capa-
bility to it is transferred to the recipient. The recipient is
hazarded by the fact that the sender can reclaim the stor-
age at any time. A recipient wishing to retain the memory
region for any length of time is therefore well-motivated
to copy its content into a recipient-supplied memory re-
gion. In the current implementation, the sender can detect
Unfortunately, we cannot simply transfer a vector of con-
structor capabilities for the converter programs. While
the display server could verify that each member capabil-
ity is a leak-free constructor capability, the sender could
subsequently alter some vector element to be a capability
to be something else. Instead, we have the sender trans-
mit a constructor to a single, conﬁned conversion agent.
The conversion agent can be asked for the set of formats
it knows how to produce and can then be asked to pro-
duce each desired format in turn. This is most easily im-
plemented by having each converter be a separately con-
structable utility application. A hidden advantage in this
design is that the storage needed to perform the conversion
is provided by the recipient rather than the sender. Note
that all the constructors involved are created at the time
the application is installed. No paste-time instantiation of
converters is required.
The ﬁnal cut and paste transfer protocol, including format
negotiation, goes as follows:
1. The display server instantiates a new memory re-
gion using the region constructor supplied by the
sender. It provides the resulting region capability to
the sender.
2. The sender writes its native paste format to the new
memory region and informs the display server when
it has completed doing so. During this step, it also
provides a capability to the converter constructor.
3. The display server now “freezes” the resulting
memory region, preventing either sender or receiver
from performing further modiﬁcations.
4. The display server now provides both the native
memory region capability and the capability to the
converter constructor to the recipient.
The resulting cut and paste interaction supports full for-
mat negotiation with no downward channel.
3 To limit this hazard, we will shortly introduce a secure storage ex-
change operation by which ownership of the storage is transferred to
the recipient at the time of the paste operation and the sender imme-
diately sees their free resource pool restored. Secure resource inter-
change of this form is generically useful in many other circumstances.
7 User Interaction
Because the window system is the primary mediator of
user input, there are certain operations users perform that
it must assure. Most of these can be viewed as trusted path
issues, and we will consider three here: title bars, window
labeling, and pass phrase entry.
7.1 The Title Bar
The title bar problem is a problem of control: does “min-
imize” mean “inform the application that we would like
to minimize”, or does it mean “tell the application that
we have minimized it?” Indeed, should we tell the appli-
cation of such actions at all? The decision matters pri-
marily because it determines who is responsible for ren-
dering and interpreting the title bar. Our policy in EWS is
that these functions are directives rather than requests, and
in consequence that the display server must handle these
functions. In the work reported here, title bar and border
rendering are performed by the display server.
A second concern with the title bar is the problem of font
forgery. If applications are permitted to set the title bar
font, they are in a position to alter the information dis-
played. In EWS, title display is managed by the display
server using a ﬁxed, compiled-in font. In a production im-
plementation, we would probably allow the user to select
from a number of predeﬁned fonts using a privileged ap-
plication, but eliminating the need to render fonts within
the display server provided a signiﬁcant reduction of code.
7.2 Window Labeling
In a multilevel secure environment, window security la-
bels are required, and the requirements speciﬁed for Com-
partmented Mode Workstations [33] are generally taken
to be deﬁnitive. Unfortunately, these requirements are in-
complete. There is no label that the display server can
apply on a window border that cannot be visually forged
by a client. Using alpha blending to “dim down” non-
focus windows or identify trusted windows is insufﬁcient:
an application can implement a visibly indistinguishable
child window and dim it’s own primary window using the
same algorithm.
The EWS display server defeats this attack by promi-
nently featuring the border of the focus window using a
bright color while dimming non-focus windows. A bright
border color is chosen because dimming of darker col-
ors using alpha blending is less easily noticed by the eye.
Separately, the EWS display server reserves a band at the
bottom of the display that is used to provide labeling feed-
back.
7.3 Pass Phrase Entry
Pass phrases present a particular challenge in a windowed
environment. Because the input is inherently sensitive, it
is important for the user to know that they are providing it
to the intended application.
Because EROS is a capability system, many operations
that initially appear to require trusted path interaction do
not. For example, there is no need for a trusted path to
support a trusted SaveAs agent. The protection in the
SaveAs case devolves from the fact that only the SaveAs
agent holds a capability to the user’s ﬁle system. An ap-
plication might forge the appearance of a SaveAs dialog,
but cannot forge possession of the necessary ﬁle system
capability.
When the “protection by guardianship” design pattern
is widely applied, the only remaining requirements for
trusted path interactions arise in three cases:
(cid:15) Password prompts
(cid:15) Cryptographic key pass phrases
(cid:15) Login authentication
This list is small enough and specialized enough that it
is reasonable to declare that these components must be
trusted subsystems. A client application may indepen-
dently instantiate many copies of the trusted password val-
idator, but the interaction between client and validator is
restricted: the client supplies a user name and the valida-
tor returns true or false depending on whether the user
typed the correct password. Similarly, there may be many
instantiations of our equivalent to Factotum [6], but none
of these reveal decrypted cryptographic key bits to their
client applications.
In the context of a capability-based system, it appears pos-
sible to impose the restriction that all trusted paths are
connections between the display and a small number of
trusted applications. If these applications are trusted, then
in particular they can be trusted to identify themselves
honestly. We have therefore resolved the trusted path
problem in EWS by providing a distinguished “trusted
client session” interface. A trusted client session is one
whose client is a trusted application.
It otherwise im-
plements the same operations as a normal client session.
When a window associated with a trusted client session is
active, all other windows are overlayed with a red alpha-
blended overlay, and the reserved labeling region at the
bottom of the display is distinctively marked.
8 Vulnerability Analysis
The vulnerability of the EROS Window System is drasti-
cally smaller than that of X11 or Trusted X as the result
of four architectural decisions:
(cid:15) The removal of general rendering responsibility
from the display server. Our server implements
only bitblt and rectfill operations, both of
which have mature, well-tested implementations.
(cid:15) The simpliﬁcation of the event handling logic.
(cid:15) The elimination of authentication and network
communication responsibilities from the server.
(cid:15) Our abandonment of
the X11 communication
model in favor of accountable, conﬁned informa-
tion transfer.
We suspect, but have not endeavoured to prove, that the
covert channel bandwidth available through EWS is less
than that of X11. There are clearly fewer points of im-
plicit rendezvous, and generally reduced variance across
EWS operations that might be exploited for timing mea-
surement. The absence of server-side queueing also helps.
While these changes clearly reduce the vulnerability of
the server, it is important to ask what new responsibilities
have been imposed on clients that might have security im-
plications. Clients now carry two blocks of content that
were not required in the X11 design:
(cid:15) A code library implementing rendering, which may
be compromised.
(cid:15) A font library, which is probably shared across mul-
tiple applications.
Our feeling is that the rendering library does not introduce
a substantial new threat. Applications already depend ex-
tensively on widget libraries; the introduction of the ren-
dering library into the build does not introduce any new
problems that were not already present.
The font library is a greater concern, though fonts were
not really protected under the X11 design either. We
do not know of any technique capable of preventing font
forgery by the font distributor. The EROS capability sys-
tem provides sufﬁcient protections that fonts cannot prac-
tically be modiﬁed after installation, and there are no dis-
play operations that allow one client to modify the fonts
used by another.
The current EWS prototype is vulnerable to resource ex-
haustion. A hostile client could create enough windows
to exhaust the virtual memory of the display server. Our
plan for this is to restrict the total number of simultaneous
windows (say, to 65,536), and reserve a subset of this for
allocation by trusted applications. We can then construct
a trusted usage reporting agent that would alert the user
to this abuse and allow the user to destroy the offending
application.
9 Usability
While a full usability test is beyond the scope of this pa-
per, we did perform a very informal usability test using
a paint program that we constructed as an early testing
tool. Wesley Vanderburgh, age 4, created the drawing in
Figure 5. The resulting ﬁgure was enhanced by his father
for publication. Wesley is in many respects representative
of potential end users for EWS. He is completely com-
fortable using the Microsoft system, largely impervious
to training, and eager to get on to useful work without in-
terruption or distraction – play time is valuable! While the
image did take a while for Wesley to generate, our unbi-
ased observer (his father) reported that this appears to be
due to the immaturity of the test subject’s ﬁne motor func-
tions rather than any deﬁciency in the window system. We
note that this test is inconclusive, as four year olds exhibit
considerably greater adaptability and ﬂexibility than ma-
ture computer users.
On a more serious note, the window system described
here has been used in presentations to DARPA without
difﬁculty or noticeable interactive performance deﬁcien-
cies. Our limiting factor in testing is the immaturity of
the EROS runtime environment and the consequent difﬁ-
culty of bringing up commonly used applications. A port
of the Gtk graphics toolkit is currently in progress, which
we hope will resolve this.
10 Related Work
Considering the importance of window systems in modern
computing, there has been surprisingly little work on se-
curity in window systems. We have discussed throughout
several categories of vulnerabilities that can arise from
such mechanisms [32]. Effective use of the EWS mech-
anisms in concert with the capability underpinnings of
EROS eliminate many of these vulnerabilities.
Ka Ping Yee has considered various concerns in secure
usability design [35]. Yee’s work in this area has been
strongly inﬂuenced by years of exposure to the EROS
community and the E capability-based scripting language
of Mark Miller. The reverse is also true; EWS contains
elements that are included speciﬁcally to support some of
the idioms proposed by Yee.
The PERSEUS project is attempting to provide security
guarantees in the context of mobile devices that are com-
parable to those of the EROS project. Their architectural
overview paper [19] provides an overview of both the de-
sign issues and some of the possible techniques that might
serve as solutions. A challenge facing the PERSEUS
project today is that they have implemented their proto-
type on top of the FIASCO kernel [13], which is an im-
plementation of the experimental L4x2 architecture [16].
While acceptable for research purposes, this decision was
problematic in a system that was created with the goal
of ultimate commercial deployment: the L4 architecture
did not (and does not) provide sufﬁcient security at the
microkernel level to be adequate for use in a secure sys-
tem. This critique was raised by one of the authors at the
time the PERSEUS project was ﬁrst proposed, and has
yet to be addressed. Recently, collaboration has started
between the L4 community and the EROS community to