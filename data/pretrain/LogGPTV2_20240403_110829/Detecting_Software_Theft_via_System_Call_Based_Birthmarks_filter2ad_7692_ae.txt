### Resiliency and Credibility of SCSSB System Call Birthmark

**Compiler Comparison:**
We compared the resiliency and credibility of the SCSSB system call birthmark using three compilers: GCC, TCC, and Watcom. For each of the three programs (e.g., bzip2-gcc, bzip2-tcc), we generated executables using these compilers. The generated executables were executed with the same input, and the system call sequences were recorded for each executable.

- **GCC vs. TCC:** The system call sequences generated by GCC and TCC (both with default optimization levels) were identical.
- **GCC vs. Watcom:** The system call sequences generated by GCC and Watcom differed. This difference was attributed to the different standard C libraries used by the compilers. GCC and TCC use glibc, while Watcom uses its own implementation. Despite these differences, our system call abstraction component could remove them, ensuring that our proposed birthmarks remain effective under different compilers.

### SCSSB Experiment I: M1, M3, M4

To demonstrate the resiliency of the SCSSB birthmark to obfuscation techniques in whole program theft, we used JLex and JFlex, two Java programs designed for the same purpose. Both programs understand the same input syntax and generate similar lexical analyzers. The authors of each program claim that there is no shared code, which we verified using SandMark's code comparison features.

- **Comparison with Obfuscated Versions:** Each program was compared to its obfuscated versions using SCSSB with 5-long system call sequences. As a dynamic analysis, SCSSB may not reliably justify (non-)theft based on a single high containment score. Therefore, we used 20 different inputs and computed the average containment scores. The results are shown in Figure 4, where the x-axis represents 34 obfuscation techniques, and the y-axis shows the containment scores.
- **Results:** From Figure 4(a) and Figure 4(c), the containment scores between the original program and its obfuscated versions were over 90%.

**Credibility Verification:**
To verify the credibility of system call birthmarks on independently developed but similar software, JLex was compared to both the original and obfuscated JFlex, and vice versa. Additionally, JLex and JFlex were compared to five other programs (grep, gunzip, gzip, sort, and wc).

- **Results:** From Figure 4(b) and Figure 4(d), the containment scores between JLex and JFlex (obfuscated versions) were less than 67%, and between JLex/JFlex and other different programs, the scores were no more than 20%. This indicates that with appropriate detection thresholds, the detection system based on SCSSB can accurately report the detection results.

### Multiple Obfuscation Techniques Applied to JLex and JFlex

A code plagiarist might attempt to hide by heavily transforming a stolen program through a series of obfuscators. We evaluated the resiliency of SCSSB against multiple obfuscation techniques applied to a single program. Although it is theoretically possible to transform a program using many obfuscators, practical issues such as maintaining the correctness and efficiency of the target program arise. We selected obfuscation techniques from two groups: data obfuscation and control obfuscation, following the classification by Collberg et al. [7].

- **Obfuscation Techniques:** Table I shows the obfuscation techniques applied to JLex and JFlex. We could apply eight control obfuscators and seven data obfuscators to JLex, and seven control obfuscators and five data obfuscators to JFlex.
- **Results:** The containment scores of JLex to control-obfuscated JLex and data-obfuscated JLex were 87.9% and 85.2%, respectively. The containment scores of control and data-obfuscated JFlex compared to original JFlex were both 96%. This experiment demonstrates that SCSSB is effective in detecting heavily obfuscated programs.

### SCSSB Experiment II: M2

In this experiment, we demonstrated SCSSB’s ability to detect stolen components using layout engines in web browsers. A layout engine renders web content combined with formatting information. Gecko, used in all Mozilla software and its derivatives, was chosen for this test.

- **Containment Scores:** We computed the containment of Gecko in several browsers using both SCSSB birthmarks with and without noise. The first five browsers (Epiphany, Firefox, Flock, Songbird, Kazehakase) are Gecko-based, while the other three (Amaya, Konqueror, Dillo) are not. Table II shows their relation with the Gecko engine.
- **Results:** To feed the web browsers the same input, we launched a web browser, opened the website "http://en.wikipedia.org/wiki/Rome," and recorded the system call sequence. Figure 5(a) shows the SCSSB containment scores of Gecko, with the x-axis representing the lengths of system call sequences. The containment of Gecko in Gecko-based browsers was larger than in non-Gecko browsers, but the difference was not significant enough to draw a conclusion. This indicates that two different programs may overlap significantly in their system call sequence sets, necessitating noise removal to obtain a useful SCSSB.

**Noise Removal:**
To address the noise issue, we used a set of different programs (Table II(b)) to prune the noisy system call sequences commonly found in other programs. Figure 5(b) shows the containment of Gecko in these browsers, using SCSSB with noise removal. The results show significant differences between Gecko-based and non-Gecko browsers, indicating that noise removal is essential for accurate detection.

### IDSCSB Experiment I: M1, M3, M4

In the third experiment, we used JLex and JFlex again to show the obfuscation resiliency of IDSCSB in whole program plagiarism. Each program was compared to its obfuscated versions using IDSCSB.

- **Results:** The containment scores between original and obfuscated JLex and JFlex were 100%. We also conducted similar experiments using SCSSB, and the containment scores between JLex and obfuscated JFlex or between JFlex and obfuscated JLex were less than 46%, and between JLex/JFlex and other programs, they were no more than 7%. With appropriate thresholds, the detection system based on IDSCSB can accurately report plagiarism.

**Multi-Obfuscated Programs:**
We compared the four multi-obfuscated JLex and JFlex (data-obfuscated JLex, control-obfuscated JLex, data-obfuscated JFlex, and control-obfuscated JFlex) to their original programs using IDSCSB. The containment scores of the multi-obfuscated JLex/JFlex compared to corresponding original versions were all 100%. This experiment shows that IDSCSB is very effective in detecting heavily obfuscated plagiarisms, outperforming SCSSB.

### IDSCSB Experiment II: M2

Next, we evaluated IDSCSB on web browsers and their layout engines. There are three steps to generate input-dependent system call sequence birthmarks:

1. **Generate System Call Sequence:** For an input, we launched the web browser, visited the website "http://en.wikipedia.org/wiki/Germany," and quit. To remove noise, we ran the program three times with the same input to find the common subsequence of the three system call traces.
2. **Generate Another Input Sequence:** We generated a system call sequence for another input, "http://www.us.gov," using the same method to remove noise.
3. **Compare Results:** The result from the above two steps was compared, and the input-dependent system call sequence birthmark was generated by extracting system calls that appear only in the result from the first step.

We also generated IDSCSB for inputs "http://www.cnn.com" and "http://www.msnbc.com." The results, shown in Figure 6, indicate significant differences between Gecko-based and non-Gecko browsers.

### Discussion

**Counterattacks:**
One possible counterattack is the system call injection attack, where an attacker inserts arbitrary system calls to reduce the containment score of SCSSB without compromising its original semantics. However, this attack would not bypass the detection of IDSCSB because (1) injected system calls are likely filtered out, and (2) IDSCSB uses the longest common subsequence (LCS) to identify similarity, making it robust to noise injection.

Another type of attack is the system call reordering attack. An attacker may change the order of system calls to fool SCSSB and IDSCSB. However, reordering system calls often affects the semantics of the machine instructions surrounding the system calls, making the attack difficult to accomplish.

**Limitations:**
Both SCSSB and IDSCSB have fundamental limitations:
1. They do not apply if the program does not involve any system calls or has very few system calls.
2. They are not applicable to programs that do not have unique system call behaviors.
3. As a detection system, they bear the same limitation as intrusion detection systems, with a tradeoff between false positives and false negatives. The detection result depends on the threshold defined by the user.

### Related Work

**Software Birthmarks:**
There are four classes of software birthmarks:
- **Static Source Code Based Birthmark:** Proposed by Tamada et al. [3], these birthmarks are vulnerable to obfuscation techniques.
- **Static Executable Code Based Birthmark:** Proposed by Myles and Collberg [8], these birthmarks are more robust but still vulnerable to some obfuscations.
- **Dynamic WPP Based Birthmark:** Proposed by Myles and Collberg [5], these birthmarks are robust to some control flow obfuscations but are still vulnerable to semantic-preserving transformations.
- **Dynamic API Based Birthmark:** Proposed by Tamada et al. [6] and Schuler et al. [4], these birthmarks are platform-dependent and more robust to obfuscation than WPP birthmarks.

**Clone Detection:**
Clone detection techniques can be classified into four categories: String-based, AST-based, Token-based, and PDG-based. These techniques are not robust to code obfuscation, and all require access to source code.

### Conclusion

In this paper, we propose two system call-based software birthmarks: SCSSB and IDSCSB. Our experimental results show that all plagiarisms obfuscated by the SandMark tool were successfully discriminated. Unlike existing schemes, we evaluated our birthmarks with large-scale software (web browsers). The results demonstrate that SCSSB and IDSCSB are effective and practical in detecting core component theft in large-scale programs.

### Acknowledgment

The authors would like to thank Jonas Maebe of the University of Ghent for his help in compiling and using Loco and Diablo; Semantic Designs, Inc. for donating C/C++ obfuscators.

### References

[1] C. Collberg and C. Thomborson, “Software watermarking: Models and dynamic embeddings,” in Principles of Programming Languages 1999, Jan. 1999.

[2] C. Collberg, E. Carter, S. Debray, A. Huntwork, C. Linn, and M. Stepp, “Dynamic path-based software watermarking,” in Proceedings of the Conference on Programming Language Design and Implementation, 2004.

[3] H. Tamada, M. Nakamura, A. Monden, and K. ichi Matsumoto, “Design and evaluation of birthmarks for detecting theft of java programs,” in Proc. IASTED International Conference on Software Engineering, 2004.

[4] D. Schuler, V. Dallmeier, and C. Lindig, “A dynamic birthmark for java,” in ASE ’07: Proc. of the twenty-second IEEE/ACM international conference on Automated software engineering, 2007.

[5] G. Myles and C. Collberg, “Detecting software theft via whole program path birthmarks,” in ISC, 2004, pp. 404–415.

[6] H. Tamada, K. Okamoto, M. Nakamura, and A. Monden, “Dynamic software birthmarks to detect the theft of windows applications,” in International Symposium on Future Software Technology 2004 (ISFST 2004), 2004.

[7] C. Collberg, C. Thomborson, and D. Low, “A taxonomy of obfuscating transformations,” The Univeristy of Auckland, Tech. Rep. 148, Jul. 1997.

[8] G. Myles and C. S. Collberg, “K-gram based software birthmarks,” in SAC, 2005.

[9] E. Kirda, C. Kruegel, G. Banks, G. Vigna, and R. A. Kemmerer, “Behavior-based spyware detection,” in Proceedings of the 15th conference on USENIX Security Symposium, 2006.

[10] M. Christodorescu, S. Jha, and C. Kruegel, “Mining specifications of malicious behavior,” in Proc. of ESEC/FSE, 2008.

[11] “Gecko,” http://en.wikipedia.org/wiki/Gecko_layout_engine.

[12] “KHTML,” http://en.wikipedia.org/wiki/KHTML.

[13] C. Collberg, G. Myles, and A. Huntwork, “Sandmark–a tool for software protection research,” IEEE Security and Privacy, vol. 1, no. 4, pp. 40–49, 2003.

[14] S. Forrest, S. A. Hofmeyr, A. Somayaji, and T. A. Longstaff, “A sense of self for Unix processes,” in Proceedinges of the 1996 IEEE Symposium on Research in Security and Privacy, 1996.

[15] N. Nethercote and J. Seward, “Valgrind: a framework for heavyweight dynamic binary instrumentation,” in Proceedings the 2007 ACM SIGPLAN conference on Programming language design and implementation.

[16] “Elsa: An Elkhound-based C++ parser,” http://scottmcpeak.com/elkhound/.

[17] X. Wang, Y.-C. Jhi, S. Zhu, and P. Liu, “Behavior based software theft detection,” in Proc. of the 16th ACM Conference on Computer and Communications Security (CCS’09), 2009.

[18] H. Tamada, K. Okamoto, M. Nakamura, A. Monden, and K. ichi Matsumoto, “Design and evaluation of dynamic software birthmarks based on api calls,” Nara Institute of Science and Technology, Technical Report, 2007.

[19] B. S. Baker, “On finding duplication and near duplication in large software systems.” in Proc. of 2nd Working Conf. on Reverse Engineering, 1995.

[20] I. D. Baxter, A. Yahin, L. Moura, M. Sant’Anna, and L. Bier, “Clone detection using abstract syntax trees.” in Int. Conf. on Software Maintenance, 1998.

[21] K. Kontogiannis, M. Galler, and R. DeMori, “Detecting code similarity using patterns.” in Working Notes of 3rd Workshop on AI and Software Engineering, 1995.

[22] T. Kamiya, S. Kusumoto, and K. Inoue., “CCFinder: a multilingual token-based code clone detection system for large scale source code.” IEEE Trans. Softw. Eng., vol. 28, no. 7, 2002.

[23] L. Prechelt, G. Malpohl, and M. Philippsen, “Finding plagiarisms among a set of programs with jplag,” Universal Computer Science, 2000.

[24] S. Schleimer, D. S. Wilkerson, and A. Aiken, “Winnowing: local algorithms for document fingerprinting.” in Proc. of ACM SIGMOD Int. Conf. on Management of Data, 2003.

[25] C. Liu, C. Chen, J. Han, and P. S. Yu, “Gplag: detection of software plagiarism by program dependence graph analysis,” in Proceedings of the 12th ACM SIGKDD international conference on Knowledge discovery and data mining, 2006.

[26] J. Krinke, “Identifying similar code with program dependence graphs.” in Proc. of 8th Working Conf. on Reverse Engineering, 2001.

Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:05:20 UTC from IEEE Xplore. Restrictions apply.