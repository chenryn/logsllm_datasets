Thankfully, there are many ways to obfuscate the type of file we’re 
exfiltrating, ranging from encrypting the contents of the file to simply trim-
ming off the magic bytes before transmitting the file and then appending 
them again after the file is received. For human-readable file types, I prefer 
Evading EDR (Early Access) © 2023 by Matt Hand
Case Study: A Detection-Aware Attack   261
encryption, since there may be monitoring in place for a specific string in 
an outbound connection request. For other types of files, I’ll usually either 
remove, mangle, or falsify the magic bytes for the file if detection at this 
stage is a concern.
When we’re ready to exfiltrate the file, we can use our agent’s built-in 
download functionality to send it over our established command-and-con-
trol channel. When we do this, we are going to make a request to open the 
file so that we can read its contents into memory. When this happens, the 
EDR’s filesystem minifilter driver will receive a notification and may look 
at certain attributes associated with the event, such as who the requestor is. 
Since the organization itself would have to build a detection from this data, 
the likelihood of an EDR having a detection here is relatively low.
Once we’ve read the contents of the file into our agent’s address 
space, we can close the handle to the file and start the transfer. 
Transmitting data over HTTP or HTTPS channels will cause related ETW 
providers to emit events, but these typically don’t include the message 
contents if the channel is secure, as with HTTPS. So, we shouldn’t have 
any issue getting our design plans out. Once we have the file downloaded, 
we simply add back the magic bytes and open the file in the 3D modeling 
software of choice (Figure 13-1).
Figure 13-1: The Binford 6100  
left-handed screwdriver
Conclusion
We’ve completed the engagement objective: accessing the design informa-
tion for Binford’s revolutionary product (pun intended). While executing 
this operation, we used our knowledge of an EDR’s detection methods to 
make educated choices about how to move through the environment.
Bear in mind that the path we took may not have been the best 
(or only) way to reach the objective. Could we have outpaced Binford’s 
Evading EDR (Early Access) © 2023 by Matt Hand
262   Chapter 13
defenders without considering the noise we were making? What if we 
decided not to work through Active Directory and instead used a cloud-
based file-hosting application, such as SharePoint, to locate the design 
information? Each of these approaches significantly alters the ways in which 
Binford could detect us.
After reading this book, you should be armed with the information 
you need to make these strategic choices on your own. Tread carefully, and 
good luck.
Evading EDR (Early Access) © 2023 by Matt Hand
Modern EDRs sometimes make use of 
less popular components not covered in 
this book so far. These auxiliary telemetry 
sources can provide immense value to the 
EDR, offering access to data that would otherwise be 
unavailable from other sensors.
Because these data sources are uncommon, we won’t take a deep dive 
into their inner workings. Instead, this appendix covers some examples of 
them, how they work, and what they can offer an EDR agent. This is by no 
means an exhaustive list, but it shines a light on some of the more niche 
components you may encounter during your research.
Alternative Hooking Methods
This book has shown the value of intercepting function calls, inspecting the 
parameters passed to them, and observing their return values. The most 
prevalent method of hooking function calls at the time of this writing relies 
A PPE N DI X:  AU X IL I A RY SO U RCE S
Evading EDR (Early Access) © 2023 by Matt Hand
264   Appendix: Auxiliary Sources 
on injecting a DLL into the target process and modifying the execution 
flow of another DLL’s exported functions, such as those of ntdll.dll, forcing 
execution to pass through the EDR’s DLL. However, this method is trivial 
to bypass due to weaknesses inherent in its implementation (see Chapter 2).
Other, more robust methods of intercepting function calls exist, such 
as using the Microsoft-Windows-Threat-Intelligence ETW provider to indi-
rectly intercept certain syscalls in the kernel, but these have their own limi-
tations. Having multiple techniques for achieving the same effect provides 
advantages for defenders, as one method may work better in some contexts 
than others. For this reason, some vendors have leveraged alternative hook-
ing methods in their products to augment their ability to monitor calls to 
suspicious functions.
In a 2015 Recon talk titled “Esoteric Hooks,” Alex Ionescu expounded 
on some of these techniques. A few mainstream EDR vendors have imple-
mented one of the methods he outlines: Nirvana hooks. Where garden-
variety function hooking works by intercepting the function’s caller, this 
technique intercepts the point at which the syscall returns to user mode 
from the kernel. This allows the agent to identify syscalls that didn’t origi-
nate from a known location, such as the copy of ntdll.dll mapped into a 
process’s address space. Thus, it can detect the use of manual syscalls, a tech-
nique that has become relatively common in offensive tools in recent years.
There are a few notable downsides to this hooking method, though. 
First, it relies on an undocumented PROCESS_INFORMATION_CLASS and associated 
structure being passed to NtSetInformationProcess() for each process the 
product wishes to monitor. Because it isn’t formally supported, Microsoft 
may modify its behavior or disable it entirely at any time. Additionally, the 
developer must identify the source of the call by capturing the return con-
text and correlating it to a known good image in order to detect manual 
syscall invocation. Lastly, this hooking method is simple to evade, as adver-
saries can remove the hook from their process by nulling out the callback 
via a call to NtSetInformationProcess(), similarly to how the security process 
initially placed it.
Even if Nirvana hooks are relatively easy to evade, not every adversary 
has the capability to do so, and the telemetry they provide might still be 
valuable. Vendors can employ multiple techniques to provide the coverage 
they desire.
RPC Filters
Recent attacks have rekindled interest in RPC tradecraft. Lee Christensen’s 
PrinterBug and topotam’s PetitPotam exploits, for example, have proven 
their utility in Windows environments. In response, EDR vendors have 
begun paying attention to emerging RPC tradecraft in hopes of detecting 
and preventing their use.
RPC traffic is notoriously difficult to work with at scale. One way EDRs 
can monitor it is by using RPC filters. These are essentially firewall rules based 
on RPC interface identifiers, and they’re simple to create and deploy using 
Evading EDR (Early Access) © 2023 by Matt Hand
Appendix: Auxiliary Sources    265
built-in system utilities. For example, Listing A-1 demonstrates how to ban all 
inbound DCSync traffic to the current host using netsh.exe interactively. An 
EDR could deploy this rule on all domain controllers in an environment.
netsh> rpc filter
netsh rpc filter> add rule layer=um actiontype=block
Ok.
netsh rpc filter> add condition field=if_uuid matchtype=equal \
data=e3514235-4b06-11d1-ab04-00c04fc2dcd2
Ok.
netsh rpc filter> add filter
FilterKey: 6a377823-cff4-11ec-967c-000c29760114
Ok.
netsh rpc filter> show filter
Listing all RPC Filters.
-----------------------------
filterKey: 6a377823-cff4-11ec-967c-000c29760114
displayData.name: RPCFilter
displayData.description: RPC Filter
filterId: 0x12794
layerKey: um
weight: Type: FWP_EMPTY Value: Empty
action.type: block
numFilterConditions: 1
filterCondition[0]
fieldKey: if_uuid
matchType: FWP_MATCH_EQUAL
conditionValue: Type: FWP_BYTE_ARRAY16_TYPE Value: e3514235 11d14b06 c00004ab d2dcc24f
Listing A-1: Adding and listing RPC filters using netsh
These commands add a new RPC filter that specifically blocks any com-
munications using the Directory Replication Service RPC interface (which has 
the GUID E3514235-4B06-11D1-AB04-00C04FC2DCD2). Once the filter is installed 
via the add filter command, it is live on the system, prohibiting DCSync.
Whenever the RPC filter blocks a connection, the Microsoft-Windows-
RPC provider will emit an ETW similar to the one shown in Listing A-2.
An RPC call was blocked by an RPC firewall filter.
ProcessName: lsass.exe
InterfaceUuid: e3514235-4b06-11d1-ab04-00c04fc2dcd2
RpcFilterKey: 6a377823-cff4-11ec-967c-000c29760114
Listing A-2: An ETW event showing activity blocked by a filter
While this event is better than nothing, and defenders could theoreti-
cally use it to build detections, it lacks much of the context needed for a 
robust detection. For example, the principal that issued the request and the 
direction of traffic (as in, inbound or outbound) are not immediately clear, 
making it difficult to filter events to help tune a detection.
Evading EDR (Early Access) © 2023 by Matt Hand
266   Appendix: Auxiliary Sources 
A better option may be to consume a similar event from the Microsoft-
Windows-Security-Auditing Secure ETW provider. Since this provider is 
protected, standard applications can’t consume from it. It is, however, fed 
into the Windows Event Log, where it populates Event ID 5157 whenever the 
base filtering engine component of the Windows Filtering Platform blocks a 
request. Listing A-3 contains an example of Event ID 5157. You can see how 
much more detailed it is than the one emitted by Microsoft-Windows-RPC.
5157
1
0
12810
0
0x8010000000000000
11289563
Security
sun.milkyway.lab
644
\device\harddiskvolume2\windows\system32\lsass.exe
%%14592
192.168.1.20
62749
192.168.1.5
49667
6
75664
%%14610
46
S-1-0-0
S-1-0-0
Listing A-3: An event manifest for the Microsoft-Windows-Security-Auditing Secure ETW provider
While this event contains much more data, it also has some limita-
tions. Notably, although the source and destination ports are included, the 
interface ID is missing, making it difficult to determine whether the event 
is related to the filter that blocks DCSync attempts or another filter entirely. 
Additionally, this event operates inconsistently across Windows versions, 
generating correctly in some and completely missing in others. Therefore, 
some defenders might prefer to use the less-enriched but more consistent 
RPC event as their primary data source.
Evading EDR (Early Access) © 2023 by Matt Hand
Appendix: Auxiliary Sources    267
Hypervisors
Hypervisors virtualize one or more guest operating systems, then act as an 
intermediary between the guest and either the hardware or the base oper-
ating system, depending on the hypervisor’s architecture. This intermedi-
ary position provides EDRs with a unique opportunity for detection.
How Hypervisors Work
The inner workings of a hypervisor are relatively simple once you under-
stand a few core concepts. Windows runs code at several rings; the code 
running in a higher ring, such as ring 3 for user mode, is less privileged 
than code running at a lower one, such as ring 0 for the kernel. Root mode, 
where the hypervisor resides, operates at ring 0, the lowest architecturally 
supported privilege level, and limits the operations that the guest, or non-
root mode system, can perform. Figure A-1 shows this process.
Guest 2
Guest 1
Hypervisor
VMCS
VMEXIT 
VMENTER 
VMEXIT 
VMENTER 
VMCS
Figure A-1: The operation of VMEXIT  
and VMRESUME
When a virtualized guest system attempts to execute an instruction or 
perform some action that the hypervisor must handle, a VMEXIT instruction 
occurs. When this happens, control transitions from the guest to the hyper-
visor. The Virtual Machine Control Structure (VMCS) preserves the state of the 
processor for both the guest and the hypervisor so that it can be restored 
later. It also keeps track of the reason for the VMEXIT. One VMCS exists for 
each logical processor of the system, and you can read more about them in 
volume 3C of the Intel Software Developer’s Manual.
N O T E 
For the sake of simplicity, this brief exploration covers the operation of a hypervisor 
based on Intel VT-x, as Intel CPUs remain the most popular at the time of this writing.
When the hypervisor enters root-mode operation, it may emulate, 
modify, and log the activity based on the reason for the VMEXIT. These exits 
may occur for many common reasons, including instructions such as RDMSR, 
for reading model-specific registers, and CPUID, which returns information 
about the processor. After the completion of the root-mode operation, 
execution is transferred back to non-root-mode operation via a VMRESUME 
instruction, allowing the guest to continue.
There are two types of hypervisors. Products such as Microsoft’s 
Hyper-V and VMware’s ESX are what we call Type 1 hypervisors. This means 
the hypervisor runs on the bare metal system, as shown in the Figure A-2.
Evading EDR (Early Access) © 2023 by Matt Hand
268   Appendix: Auxiliary Sources 
Guest
Guest
Hypervisor
Hardware
Type 1
Figure A-2: A Type 1  
hypervisor architecture
The other kind of hypervisor, Type 2, runs in an operating system 
installed on the bare metal system. Examples of these include VMware’s 
Workstation and Oracle’s VirtualBox. The Type 2 architecture is shown in 
Figure A-3.
Guest
Guest
Hypervisor
Base operating system
Hardware
Type 2
Figure A-3: A Type 2  
hypervisor architecture
Type 2 hypervisors are interesting because they can virtualize a system 
that is already running. Thus, rather than requiring the end user to log in 
to their system, start an application such as VMware Workstation, launch 
a virtual machine, log in to the virtual machine, and then do their work 
from that virtual machine, their host is the virtual machine. This makes 
the hypervisor layer transparent to the user (and resident attackers) while 
allowing the EDR to collect all the telemetry available.
Most EDRs that implement a hypervisor take the Type 2 approach. 
Even so, they must follow a complicated series of steps to virtualize an exist-
ing system. Full hypervisor implementation is far beyond the scope of this 
book. If this topic interests you, both Daax Rynd and Sina Karvandi have 
excellent resources for implementing your own.
Security Use Cases
A hypervisor can provide visibility into system operations at a layer deeper 
than nearly any other sensor. Using one, an endpoint security product can 
detect attacks missed by the sensors in other rings, such as the following:
Virtual Machine Detection
Some malware attempts to detect that it is running in a virtual machine 
by issuing a CPUID instruction. Since this instruction causes a VMEXIT, the 
hypervisor has the ability to choose what to return to the caller, allow-
ing it to trick the malware into thinking it isn’t running in a VM.
Evading EDR (Early Access) © 2023 by Matt Hand
Appendix: Auxiliary Sources    269
Syscall Interception
A hypervisor can potentially leverage the Extended Feature Enable 
Register (EFER) function to exit on each syscall and emulate its 
operation.
Control Register Modification
A hypervisor can detect the modification of bits in a control register 
(such as the SMEP bit in the CR4 register), which is behavior that could be 
part of an exploit. Additionally, the hypervisor can exit when a control 
register is changed, allowing it to inspect the guest execution context to 
identify things such as token-stealing attacks.
Memory Change Tracing
A hypervisor can use the page-modification log in conjunction with 
Extended Page Tables (EPT) to track changes to certain regions of 
memory.
Branch Tracing
A hypervisor can leverage the last branch record, a set of registers used to 
trace branches, interrupts, and exceptions, along with EPT to trace the 
execution of the program beyond monitoring its syscalls.
Evading the Hypervisor
One of the difficult things about operating against a system onto which a 
vendor has deployed a hypervisor is that, by the time you know you’re in a 
virtual machine, you’ve likely already been detected. Thus, malware devel-
opers commonly use virtual-machine-detection functions, such as CPUID 
instructions or sleep acceleration, prior to executing their malware. If the 
malware finds that it is running in a virtual machine, it may opt to termi-
nate or merely do something benign.
Another option available to attackers is unloading the hypervisor. 
In the case of Type 2 hypervisors, you might be able to interact with the 
driver via an I/O control code, by changing the boot configuration, or by 
directly stopping the controlling service in order to cause the hypervisor 
to devirtualize the processors and unload, preventing its ability to monitor 
future actions. To date, there are no public reports of a real-world adversary 
employing these techniques.
Evading EDR (Early Access) © 2023 by Matt Hand
Evading EDR (Early Access) © 2023 by Matt Hand
Never before has the world relied so heavily on the Internet 
to stay connected and informed. That makes the Electronic 
Frontier Foundation’s mission—to ensure that technology 
supports freedom, justice, and innovation for all people—
more urgent than ever.
For over 30 years, EFF has fought for tech users through 
activism, in the courts, and by developing software to overcome 
obstacles to your privacy, security, and free expression. This 
dedication empowers all of us through darkness. With your help 
we can navigate toward a brighter digital future.
LEARN MORE AND JOIN EFF AT EFF.ORG/NO-STARCH-PRESS
Evading EDR (Early Access) © 2023 by Matt Hand
Evading EDR (Early Access) © 2023 by Matt Hand