>
>     -   安全性公告 MS10-070"ASP.NET
>         的安全漏洞可能引发信息泄漏（2418042）"
>
>         
[48]{.注释编号下} Padding Oracle 是一个解密手段的名称，与著名的数据库
Oracle 没有关系。
### **4.8.2 Cookie 的安全属性设置不完善** {#text00000.html#nav_point_40}
#### **概要**
正如第 3 章中介绍的那样，Cookie 中含有名为 Secure
的属性（以下记为安全属性），指定了安全属性的 Cookie 仅在 HTTPS
传输的情况下才会被浏览器发送至服务器。而如果 Cookie
没有指定安全属性，那么即使应用中使用了 HTTPS 传输，Cookie
也仍然有可能会以明文的方式传输，这样就会有被监听的风险。
Cookie 中通常保存了会话 ID
等事关安全性的重要信息，因此一旦被窃听就会直接导致伪装攻击。
为了解决 Cookie 的安全属性设置不完善这一问题，最直接的对策就是设置
Cookie 的安全属性。然而，有些网站同时使用 HTTP 与 HTTPS
两种传输方式，如果在存有会话 ID 的 Cookie
中设置了安全属性，应用就可能会运行不正常。这种情况下可以采取以下解决方法，即除了使用会话
ID，再生成一个令牌作为设有安全属性的 Cookie，并在每个 HTTPS
页面中确认该令牌值。详情请参考本节的"对策"。
**Cookie 的安全属性设置不完善总览**
![{%}](Image00119.jpg)
#### **攻击手段与影响**
下面我们就来看一下针对 Cookie
的安全属性设置不完善这一问题的攻击模式与其造成的影响。本书事先为读者在网络上准备了使用
HTTPS 并且生成不带安全属性的
Cookie（PXPSESID）的网页（
）。源代码如下。
> **代码清单 set_non_secure_cookie.php**
``` 代码无行号
会话已经开始 
PXPSESID =
```
此页面被托管在笔者所在企业的主页上，为了防止被恶意使用，这里采取了限定
Cookie 的路径和更改默认会话 ID 名称等方法。
接下来，我们就来体验一下如何使用这个页面窃听不带安全属性的 Cookie。
> 1\. 启动 Fiddler
>
> 2\. 用户浏览上述页面后，浏览器中就被设置了 Cookie（PXPSESID）
>
> 3\. 访问恶意网页
>
> 4\. 在 Fiddler 中能看到恶意网站发送的请求中附带了 Cookie 信息
下面我们来讲解具体的流程。在  的菜单（下记为"/48/
菜单"）中点击"1.HTTPS 中设置 Cookie（无安全属性）"链接，进入设置 Cookie
的页面。如图 4-72 所示。
![{%}](Image00120.jpg)
**图 4-72 设置 Cookie 的页面**
此时，浏览器中就被设置了不带安全属性的 Cookie。
接着返回到 /48/ 菜单，点击"2.48-900: 浏览恶意网站"链接。也可以直接输入
URL 
进入。此页面上有一个看不见的图像（高度和宽度都设置为 0），它的引用地址为
 。下面是 HTML 代码。
``` 代码无行号
恶意网页
```
URL 中的端口号 443 是 HTTPS 的默认端口，但由于指定的协议为
http:，因此该请求在被发送时并没有进行加密。另外，虽然此 URL
指定的目标中不存在图像，但由于目的是让浏览器发送
Cookie，所以就算没有图像，攻击也照样能成功。
浏览恶意网页后，Fiddler 会弹出警告（下图），这里不用管它直接点击 OK 按钮
[49]{.注释编号} 。
[49]{.注释编号下} 使用 Wireshark 确认数据包后，Host
消息头中的端口号（:443）设置没有问题，因此该警告或许是 Fiddler 的 Bug。
![{%}](Image00121.jpg)
**图 4-73 Fiddler 弹出警告后点击 OK 按钮**
通过下图就能够查看发向目标网站的 HTTP 消息。
![{%}](Image00122.jpg)
**图 4-74 从恶意网站发出的请求中附带了 Cookie**
在恶意网站使用 443 端口发送 HTTP 请求（明文）之后，原本应该使用 HTTPS
进行传输的 Cookie
值在未经加密的情况下开始在网络上传输。其情形如下图所示。
![{%}](Image00123.jpg)
**图 4-75 针对 Cookie 的安全属性不完善实施攻击**
而一旦攻击者成功窃取未经加密的 Cookie 值，就能用它来实施会话劫持。
-   **关于抓包方法的注意点**
    此处讲述的监听方法中网络传输经过了代理，这与不经过代理时的条件略有不同。
    没有经过代理时，浏览器与 Web
    服务器直接通信，因此要让浏览器发送请求，就需要指定 Web
    服务器上开放的端口。就像上面的试验中指定了端口号 443。
    而通信经过代理时，浏览器的所有请求都会先发送到代理服务器。因此，使用身为代理的
    Fiddler 观测时，可以发现指定 443
    以外的端口号也能够发送请求。具体情形如下图所示。
    ![{%}](Image00124.jpg)
    **图 4-76 有代理和无代理时的 HTTP 请求观测**
    不经过代理的 HTTP 请求无法通过 Fiddler
    等代理工具进行观测，观测时可以使用 Wireshark
    等嗅探器（抓包软件）。使用嗅探器进行数据包解析的技术方法请参考 Chris
    Sanders 著的《Wireshark 数据包分析实战》\[1\]。
#### **安全隐患的产生原因**
Cookie 的安全属性设置不完善的直接原因显而易见，就是没有给 Cookie
设置安全属性，以笔者多年来诊断安全隐患的经验来看，不给 Cookie
设置安全属性的主要原因有如下两类。
> -   开发者对安全属性毫不知情
>
> -   设置安全属性后应用无法运行
经过本书的学习后，相信第一类原因就能够得到解决。因此，下面我们来主要讲述设置安全属性后应用无法运行的情况。
-   **什么样的应用程序不能在 Cookie 中设置安全属性**
    有些 Web 应用同时使用 HTTP 和
    HTTPS，典型例子为电子商务网站。多数电子商务网站中，用户浏览商品页面时使用的是
    HTTP 传输，而当用户选择完商品进入支付阶段时使用的则是 HTTPS。图 4-77
    即展示了同时使用 HTTP 和 HTTPS 的电子商务网站的页面跳转情况。
    ![{%}](Image00125.jpg)
    **图 4-77 同时使用 HTTP 和 HTTPS 的网站的页面跳转**
    Web 应用中同时使用 HTTP 和 HTTPS 时，为保存会话 ID 的 Cookie
    设置安全属性是非常困难的。因为设置了安全属性后，HTTP
    传输的页面就无法接收到 Cookie 中的会话
    ID，因此也就无法利用会话管理机制。由于使用 HTTP
    的网页为了实现购物车等功能也需要利用会话管理机制，因此当前很多使用
    HTTPS 的网站都没有设置 Cookie 的安全属性。
    这种情况下，使用令牌是一种行之有效的对策。详情会在稍后讲述。
#### **对策**
为了解决 Cookie 的安全属性设置不完善这一问题，最直接的对策就是要设置
Cookie 的安全属性。
-   **给保存会话 ID 的 Cookie 设置安全属性的方法**
    在 PHP 中给保存会话 ID 的 Cookie 设置安全属性，只需在 php.ini
    中设置如下。
    ``` 代码无行号
    session.cookie_secure = On
    ```
    Apache Tomcat 中使用 HTTPS 传输请求时，会自动给保存会话 ID 的 Cookie
    设置安全属性。
    而使用 ASP.NET 时，则需要如下编辑 web.config 文件。
    ``` 代码无行号
     **代码清单 /48/48-001.php**
         **代码清单 /48/48-002.php**
    ``` 代码无行号
     检验令牌，确认通过认证。  
    ```
    为了确认上面的脚本，接下来我们使用以下 URL 来浏览页面。
    ``` 代码无行号
    https://example.jp/48/48-001.php
    ```
    或者在 /48/ 菜单中点击"3.48-001:
    生成令牌（SSL）"链接。这时页面显示如下。