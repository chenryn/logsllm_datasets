H & A
H & A
H & A
H
H
H
H
H
H
H
H
H
H
H
H
H & A
H & A
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
[16, 24) ≤ 4096
[40, 44) (cid:44) 0
[16, 24) (cid:44) 0
[112, 116)>0
[800, 808)  0, [12, 16) < 4097
[32, 36) (cid:44) 2
[24, 28) == 32
p (cid:44) null, [80, 81)+[81, 82) ≤ 252
[56, 64) ≤ uio.2
[48, 52) ≤ uio.3
[20, 22) ≤ Arg
[8, 10)≤ aac_softc.61
p (cid:44) null,[16, 20) ≥ 1024
∅
∅
∅
∅
∅
∅
∅
∅
∅
∅
Table 6: Elastic kernel objects identified and confirmed in FreeBSD. For a detailed explanation of the listed results, readers
could refer to the corresponding text in the Appendix. For the discussion of the results, readers should refer to the text in
Section 5.
left to the right) indicate (1) the caches/zones to which each elastic
object belongs, (2) the structural type of each elastic object, (3) the
offset of the length field in each elastic object and, if applicable, that
of the pointer referencing the elastic buffer, (4) the security capa-
bilities that each object could potentially provide, (5) the privilege
needed for using each elastic object to perform exploitation, (6) the
constraints that an adversary has to satisfy in order for using each
object for disclosing critical kernel data successfully.
In Table 4∼6, for clarification, we mark all the special caches/-
zones with a triangle symbol △ and highlight with a star symbol ⋆
CVE-ID or
Syzkaller-ID
2019-5603
2019-5596
2016-1887
Type
UAF
UAF
OOB
OOB
1379... [71]
OOB
3d67... [68]
OOB
422a... [69]
UAF
5bb0... [76]
UAF
6a6f... [73]
OOB
a84d... [67]
UAF
bf96... [74]
OOB
e4be... [70]
UAF
e928... [72]
UAF
ebeb... [75]
UAF
2018-6555
OOB
2018-5703
UAF
2018-18559
OOB
2018-12233
DF
2017-8890
OOB
2017-7533
OOB
2017-7308
OOB
2017-7184
DF
2017-6074
DF
2017-2636
DF
2017-17053
UAF
2017-17052
UAF
2017-15649
2017-10661
UAF
2017-1000112 OOB
OOB
UAF
UAF
UAF
UAF
OOB
2016-6187
2016-4557
2016-10150
2016-0728
2014-2851
2010-2959
2019-8605
2019-6225
2018-4243
2018-4241
2017-2370
2017-13861
UAF
UAF
OOB
OOB
OOB
DF
Capability
FreeBSD
file_zone:[40, 44)=*
file_zone:[40, 44)=*
zone_mbuf:[0, 256)=*
Suitable
objects #
Security
Impact
0
0
1
NA
NA
BA & AR 7
10 + (1)
SC, HC, BA
kmalloc-192:[16, 24)=0, kmalloc-192:[48, 56)=kaddr
Linux
kmalloc-512:[0, 512)=*
NA
kmalloc-64:[0, 4)=0x8
kmalloc-1024:[0, 8)=kaddr
kmalloc-32:[0, 4)=*
ip_dst_cache:[64, 68)=*
kmalloc-64:[0, 16)=*, [16, 24)=192, [24, 64)=0
kmalloc-256:[120, 128)=kaddr
kmalloc-1024:[15, 24)=kaddr
kmalloc-96:[0, 8)=kaddr, kmalloc-96:[8, 16)=kaddr
kmalloc-2048:[1328, 1336)=*
0
0
1
3
1
0
6
1
1
3
0
0
0
2
4
3
0
0
0
0
0
5
3
NA
NA
HC, BA
HC, BA
HC, BA
NA
SC, HC, BA
HC, BA, AR
HC, BA
SC, HC, BA
NA
NA
NA
HC, BA
SC, HC, BA
SC, HC, BA, AR
SC, HC, BA
HC, BA
SC, HC, BA
SC, HC, BA
NA
NA
NA
24 + (2)
SC, HC, BA, AR
3
3
2
2
11 + (1)
SC, HC, BA, AR
HC, BA
HC, BA
HC, BA
SC, HC, BA
4 + (1)
HC, BA, AR
NA
NA
HC, BA
HC, BA
4 + (1)
HC, BA, AR
kmalloc-64:[0, 8)=kaddr:[8, 16)=kaddr:[16, 18)<46:[18, 64)=*
kmalloc-96:[0, 11)=*:[11, 12)=’\0’
kmalloc-1024:[0, 1024)=*, kmalloc-2048:[0, 2048)=*
kmalloc-32:[0, 32)=*, kmalloc-64:[0, 64)=*, kmalloc-96:[0, 96)=*, kmalloc-128:[0, 128)=*
kmalloc-196:[0, 192)=*, kmalloc-256:[0, 256)=*, kmalloc-512:[0, 512)=*
kmalloc-256:[0, 8)=kaddr:[8, 16)=kaddr:[16, 18)<238:[18, 256)=*
kmalloc-8192:[0, 8)=kaddr:[8, 16)=kaddr:[16, 18)<8174:[18, 8192)=*
12 + (1)
SC, HC, BA, AR
12 + (1)
22 + (2)
11 + (1)
10 + (1)
kmalloc-16:[0, 8)=*
kmalloc-256:[0, 8)=kaddr, kmalloc-256:[8, 16)=kaddr
kmalloc-4096:[2160, 2168)=*
kmalloc-256:[192, 200)=kaddr, kmalloc-256:[200, 208)=kaddr
kmalloc-8:[0, 8)=*, kmalloc-16:[0, 16)=*, kmalloc-32:[0, 32)=*
kmalloc-64:[0, 64)=*, kmalloc-128:[0, 128)=*
kmalloc-256:[56, 64)=*, kmalloc-256:[64, 72)=*
kmalloc-64:[24, 32)=*, kmalloc-64:[32, 40)=*
NA
NA
NA
kmalloc-256:[0, 8)=*
kmalloc-192:[0, 8)=*
kmalloc-256:[0, 256)=*
XNU
kalloc.192:[0, 192)=*
kalloc.96:[8, 16)=*
kalloc.16:[0, 8)=0
kalloc.2048:[0, 2048)=*
kalloc.256:[0, 256)=*
kalloc.192:[0, 192)=*
Table 7: The exploitability summary of kernel vulnerabilities. For a detailed explanation of the listed results, readers could
refer to the corresponding text in the Appendix. For the discussion of the results, readers should refer to the text in Section 5.
symbol † to indicate the objects the constraint sets of which involve
the objects that could belong to all the caches/zones greater than
they are specified in the table. Besides, we utilize the symbol ∅ to
variables.
signify no privilege is required if an attacker performs exploitation
with the corresponding object. Similarly, the same symbol ∅ in
the constraint column indicates no restriction is imposed on the
manipulated elastic object. In the struct column, we use the dagger
For the mathematical notations depicted in the constraint col-
umn, Arg signifies the argument of a system call, the value of which
is under the attacker’s control. p(cid:44)null indicates that a pointer p
(cid:44)→ referencing the elastic object should not equal to a null value.
The notations compat_getdents_callback.3, msgrcv_nocancel_args.7, and
cache_detail.20 all represent variables, the values of which are un-
decidable through static analysis. For example, cache_detail.20 indi-
cates the 20th field of the object in the structual type cache_detail.
The notation kaddr represents a valid kernel address. The formula
[768,776]== kaddr, for example, indicates the value at the mem-
ory range [768,776] has to be a valid kernel address.
Last but not least, in the potential column, we use three different
characters to represent the potential capability of an elastic object.
The characters H and S indicate the object could potentially allow
an adversary to leak data from heap and stack, respectively. The
character A denotes the potential of performing an arbitrary kernel
read.
Kernel vulnerabilities and their exploitability. Table 7 lists all
the kernel vulnerabilities used for our evaluation. From the column
on the left to the right, the results shown in the table indicate
(1) the CVE-ID associated with the kernel vulnerability, (2) the
vulnerability type into which the vulnerability was categorized, (3)
the capability of the vulnerability summarized manually, (4) the
total number of elastic kernel objects useful for the exploitation of
the vulnerability, (5) the security implication tied to the exploitation.
In the capability column of Table 7, as is specified in Section 3.3,
the capability of each vulnerability is represented in the format
of cache:[range|operator|value, · · · ]. For example, the formula
kmalloc-96:[0,8)=kaddr indicates the vulnerability offers the
ability to manipulate the first byte of an elastic kernel object, and the
manipulated value is a valid kernel address. As we can observe from
the table, in addition to using the notation kaddr to denote a valid
kernel address, we introduce the symbol ∗ indicating an arbitrary
value. For example, kmalloc-2048:[1328,1336)=* signifies the
vulnerability allows an attacker to assign an arbitrary value to the
memory region [1328,1336).
In the column marked with “Suitable object #”, we specify the