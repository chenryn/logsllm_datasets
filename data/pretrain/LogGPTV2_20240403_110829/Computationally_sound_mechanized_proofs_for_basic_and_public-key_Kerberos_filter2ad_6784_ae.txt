the process calculus formalizing solely the AS exchange of
basic Kerberos and let QPKINIT be the game formalizing the
public-key mode of PKINIT. Furthermore, let keyAK de-
note in QK5 1R and in QPKINIT , respectively, the authenti-
cation key received by an honest client from the KAS and
generated by the KAS for the use between the client and an
honest TGS. Then QK5 1R and QPKINIT preserve the secrecy
of keyAK.
Remark 2 For the ﬂawed draft version of PKINIT, Cryp-
toVerif was not able to produce a positive proof of either the
secrecy of the key AK or the authentication of K to C. In
fact, neither property holds for the ﬂawed protocol, due to
a known attack [19].
We formalize Property 2(b) as the following theorem.
Theorem 7 (Secrecy of SK) Let QK5 2R be the game in
the process calculus formalizing the AS and the TG exchange
( i.e., the ﬁrst two rounds) of basic Kerberos and let QPK 2R
be the game formalizing the ﬁrst two rounds of public-key
Kerberos. Furthermore, let keySK denote in QK5 2R and in
QPK 2R , respectively, the service key received by an honest
client from an honest TGS and generated by the TGS for
the use between the client and an honest server. Then QK5 2R
and QPK 2R preserve the secrecy of keySK .
Proof. For both basic Kerberos and public-key Kerberos:
when the client process completes its participation in a TG
exchange with an honest TGS it stores the session key SK in
keySK . CryptoVerif can then prove the query: secret keySK ,
where in the public-key Kerberos case, the same commands
as in the public-key Kerberos case from Theorem 1 are
used.
We note that cryptographic secrecy, i.e., indistinguisha-
bility from random, which follows for the keys AK and SK
from Theorems 6 and 7, respectively, does not hold any
longer once AK is used in a TS request or SK is used in
a CS request, as shown in [4]. This is due to the fact that
AK and SK are used to encrypt the authenticators in the
TG and CS exchange, respectively, which contain a par-
tially known plaintext; namely the client name and a times-
tamp which was generated during a bounded time period
that is typically known to the adversary.
If an adversary
tries to distinguish either AK or SK from random keys, he
just needs to attempt to decrypt the appropriate authenti-
cator and makes his guess dependent on whether the adver-
sary sees the client’s name and a timestamp generated in
the bounded time period or not. This gives the adversary
an overwhelming advantage of guessing correctly. However,
Kerberos allows for the generation of an optional sub-session
key [34], which is intended for the encryption of subsequent
communication (instead of the session key). This optional
sub-session key may be generated by either the client or the
server in the CS exchange and included in the message which
the client or the server send to each other encrypted under
the session key. In [4] it was noted that the optional sub-
session key satisﬁes the notion of cryptographic key secrecy,
independent of whether it is generated by the client or the
server.
K5
PK
and QOpt,C
Theorem 8 (Secrecy of Optional Sub-Session Key)
Let QOpt,C
be the games in the process calculus
formalizing basic Kerberos and public-key Kerberos, where
in both cases an optional subsession key is generated by the
client. And let QOpt,S
be the games in the process
calculus formalizing basic Kerberos and public-key Kerberos,
when an optional subsession key is generated by the server.
If OPkeyC and OPkeyS denote in all cases the sub-session
keys an honest client and an honest server, respectively, pos-
sess after having communicated via a Kerberos session in-
volving an honest TGS, then
and QOpt,S
PK
K5
preserve the secrecy of OPkeyC and
K5
• QOpt,C
• QOpt,S
K5
and QOpt,C
PK
and QOpt,S
PK
the one-session secrecy of OPkeyS .
the one-session secrecy of OPkeyC .
preserve the secrecy of OPkeyS and
Proof. For both basic Kerberos and public-key Kerberos:
when the client process completes its participation in a CS
exchange with an honest server and involving an honest
TGS it stores the optional sub-session key in OPkeyC , and,
likewise, the server process stores the optional sub-session
key in OPkeyS .
If the optional sub-session key is gener-
ated by the server, then CryptoVerif can prove the queries:
secret1 OPkeyC and secret OPkeyS , if the commands in the
public-key Kerberos case are the same as in the proof of
Theorem 1. The appropriate queries are proved by Cryp-
toVerif if the optional sub-session key is generated by the
client.
In order to understand why CryptoVerif can in some in-
stances only prove one-session secrecy but not secrecy, we
distinguish the cases in which a server receives an optional
sub-session key generated by the client from the cases in
which the client receives a sub-session key generated by a
server. In the ﬁrst case, an adversary can force the server
to accept the same sub-session key in multiple sessions that
use the same session key SK , by replaying the 5th message
of Kerberos. This replay allows an adversary to distinguish
these sub-session keys from independent random keys. How-
ever, in practice, this replay should be prevented by an anti-
replay cache of the server [34], which is not included in our
model. The second case stems, again, from the fact that our
CryptoVerif model allows two timestamps to be equal with
a non-neglible probability (see discussion at the end of Sec-
tion 4.2). This makes it possible for an adversary to launch
a similar attack as above by replaying the response from a
server in multiple sessions that use the same key SK and
the same timestamp t(cid:48)
C . If we treat timestamps as nonces
96
so that two timestamps can be equal only with a negligi-
ble probability, then CryptoVerif can prove secrecy of the
sub-session in the second case.
4.3.2 Key Usability
Weaker than key indistinguishability, the notion of key
usability [21] aims to capture whether an exchanged key, al-
though possibly not indistinguishable from random, is still
“good” to be used subsequently for certain cryptographic op-
erations, e.g., IND-CCA secure encryption. An exchanged
key, which is indistinguishable from random, can be used
just as a freshly generated key for any cryptographic opera-
tions. This notion, however, could sometimes be considered
as a too strong since, e.g., keys that are used for encryption
of a partially known payload during a key exchange protocol,
as is the case in Kerberos, involuntarily become distinguish-
able. Nonetheless, a dinstinguishable key may still be usable
and leave an adversary with an at most negligible advantage
at winning, e.g., an IND-CCA attack game.
Paralleling the deﬁnition of key indistinguishability, the
deﬁnition of key usability by Datta et al. [21] involves a
two-phase attacker A = (Ae,Ac). Informally, given a key
exchange protocol Σ and a class of applications S, in the key
exchange phase, honest parties ﬁrst run (multiple) sessions
of the protocol over a network that is controlled by Ae. Af-
terwards the attacker Ae chooses a session and hands the
session id together with the information she collected over
to Ac. Now the challenge phase begins where Ac is trying
to win an attack game against a scheme Π ∈ S which uses
keys from the session previously picked by Ae. The syntax
of the process calculus used by CryptoVerif does not allow
us to formalize a sequence consisting of an exchange phase
followed by an challenge phase, nor does it allow us to di-
rectly formalize a two-phase attacker who picks a session ID
and its key to play the attack game against. Therefore we
use an ‘auxiliary construction’ to prove key usability results
for Kerberos using CryptoVerif, which in fact enables us to
prove a stronger version of key usability in the case of Ker-
beros, as we describe in the following, and which, therefore,
may contribute to future discussions on the notion of key us-
ability. Our construction involves two aspects that address
the syntactical obstacles mentioned above: Firstly, the syn-
tax of the process calculus used by CryptoVerif forces us
to let the processes formalizing the exchange phase and the
challenge phase run in parallel, i.e., an attacker playing, e.g.,
an IND-CCA2 game against a symmetric encryption scheme
which uses the session key SK , is still able to interact with
Kerberos protocol sessions and could utilize these protocol
sessions in order to win the IND-CCA2 attack game. How-
ever, we make some restriction in deﬁnition 1 below which
implies, for instance, that if the adversary is trying to win an
IND-CCA2 attack game against the symmetric encryption
scheme under the cryptographic assumptions in Section 4.1
using the session key SK , then we do not allow the adver-
sary to send any output of the encryption oracle to sessions
of the honest protocol principals that are carrying out the
CS exchange (i.e., the third round). Secondly, instead of
letting the adversary choose the session ID and the key for
the attack game, the key is drawn at random from the poly-
nomially many sessions and keys.
Deﬁnition 1 (Strong Key Usability)
=
(K,E,D) ∈ S be a symmetric encryption scheme, b ∈ {0, 1},
Let Π
Σ a key exchange protocol, and A an adversary. We
consider the following experiment Exp∗bA,Σ,Π(η):
• First, A is given the security parameter η and A can
interact, as an active adversary, with polynomially many
protocol sessions of Σ.
• At some point, at the request of A, a session identiﬁer
sid is drawn at random and A is given access to a left-
right encryption oracle Ek(LR(., ., b)) and an decryption
oracle Dk(.) both keyed with a key k locally output in
session sid.
– where A submits same-length message pairs (m0,
– A never queries Dk(.) on a ciphertext output by
– and A may interact with uncompleted protocol ses-
m1) to Ek(LR(., ., b)), which returns Ek(mb),
Ek(LR(., ., b)),
• Adversary A plays a variant of an IND-CCA2 game
sions,
– all sessions of the protocol do not accept ciphertexts
output by the encryption oracle when they reach a
point of the protocol at which at least one session
expects to receive a message encrypted under the
key k.
the output of the experiment.
• At some point, A outputs a guess bit d, which is also
We deﬁne the advantage of an adversary A by Adv∗keA,Σ,Π =
| Pr(Exp∗1A,Σ,Π(η) = 1) − Pr(Exp∗0A,Σ,Π(η) = 1)| and say
that keys exchanged through protocol Σ are strongly usable
for schemes in S if for all Π ∈ S and any probabilistic,
polynomial-time adversary A, the advantage Adv∗keA,Σ,Π is
negligible.
It is clear that allowing the adversary to interact with pro-
tocol sessions during the attack game gives the adversary
more power compared to a two-phase attacker as in [21].
Not letting the adversary pick the session ID (which corre-
sponds to a replication index in CryptoVerif’s process calcu-
lus), on the other hand, restricts the adversary’s capabilities.
However, since the number of sessions is polynomial (in the
security parameter), a non-negligible advantage of winning
an attack game for a two-phase adversary as in [21] implies
a non-negligible advantage for the adversary we described
above.
Furthermore, an attacker in [21] may be more restricted
than necessary in order to model many realistic settings.
For instance, if a key k is exchanged through protocol Σ1
to be used in an application protocol Σ2, then usability of
k with respect to the deﬁnition in [21] guarantees k to be
good for, say, encryption in Σ2 under the condition that all
users on the network stop running protocol Σ1, which is gen-
erally not very realistic. On the other hand, if one requires
that messages encrypted under k during a run of Σ1 diﬀer
syntactically from messages encrypted in Σ2 then messages
encrypted under k in Σ2 will be rejected from participants
of Σ1. Therefore a restriction on the adversary like the one
in deﬁnition 1 could be realized and k can be securely used
in Σ2 if it satisﬁes strong key usability. This example sug-
gests yet another deﬁnition of key usability; one which comes
with a composition theorem for protocols Σ1 and Σ2. We
intend to explore in subsequent work such a variant deﬁni-
tion of key usability and how one could utilize CryptoVerif
to prove that an exchanged key satisﬁes that notion.
We formalize Property 2(c) as the following theorem. We
omit its proof and detail only the proof of the more impor-
97
tant result on usability of SK (Theorem 11 below), which is
similar.
be
Σ ,X
Let QAK ,use
Theorem 9 (Usability of AK)
the
game in the process calculus formalizing the experiment
Exp∗b1A,Σ,Π(η), where Σ is basic or public-key Kerberos in-
volving client C, TGS T , and KAS K, Π is the symmet-
ric encryption scheme of Kerberos, and the left-right oracle
uses an authentication key AK that was locally output after
a completed process of X ∈ {C, T, K}. If C, T , and K are
honest, then QAK ,use
preserves the secrecy of b1 .
Σ ,X
Corollary 10 Basic and public-key Kerberos satisfy IND-
CCA2 (strong) key usability for the authentication key AK ,
for the symmetric encryption scheme of Kerberos.
We formalize Property 2(d) as the following theorem.
Σ ,X
Let QSK ,use
Theorem 11 (Usability of SK)
be the
game in the process calculus formalizing the experiment
Exp∗b1A,Σ,Π(η), where Σ is basic or public-key Kerberos in-
volving client C, KAS K, TGS T , and server S, Π is the
symmetric encryption scheme of Kerberos, and the left-right
oracle uses an authentication key SK that was locally output
after a completed process of X ∈ {C, S, T}. If C, K, T , and
S are honest, then QSK ,use
preserves the secrecy of b1 .
Σ ,X