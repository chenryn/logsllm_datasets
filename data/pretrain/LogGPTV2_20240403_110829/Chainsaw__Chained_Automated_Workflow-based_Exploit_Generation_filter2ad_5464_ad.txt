Eve
schoolmate
geccbblite
faqforge
webchess
Total
24
0
4
42
5
51
3
4
15
148
21
0
1
40
5
49
3
4
13
136
1
1
1
7
2
5
0
4
12
33
1
1
1
7
2
5
0
4
12
33
7
0
0
0
0
0
3
0
3
13
0
1
3
0
2
2
4
2
3
17
29
2
5
47
9
56
10
10
31
199
Table 2: Summary of results for automatic exploit generation.
1 $name = $_POST["name"]; //no sanitization
2 $comment = $_POST["comment"];//no sanitization
3 ....
4 mysql_query ("UPDATE MembersMain SET Name = ’".$name."’, Division =
’".$division."’, RankCorp = ’".$rankcorp."’, Vacation =
’".$vacation."’, Comment = ’".$comment."’, Deleted =
’".$deleted."’ WHERE MemberID = ’".$memberid."’");
Listing 12: Vulnerable query in member.php, EVE.
Chainsaw also generated two XSS exploits for member.php.
Listing 13 shows the vulnerable sink (corresponding exploit
string is shown in Listing 22 in the appendix.
1 $nname = $_GET["nname"]; //no XSS sanitization
2 echo "User ";
Listing 13: Vulnerable XSS sink in member.php, EVE.
5.3 Selected Second-Order Exploits
For myBloggie, Chainsaw generated 7 second-order SQLI
exploits. One of these exploits is demonstrated in listings
14 and 15. The ﬁrst step exploits the vulnerable insert
query in adduser.php (Listing 14) where $user is not suﬃ-
ciently sanitized for SQLI vulnerabilities. The second step
retrieves user data from USER_TBL without sanitization (see
Listing 15). Without our comprehensive modeling of PHP
functions, constraints that include calls to isset, intval,
md5 and htmlspecialchars would not captured correctly and
that could result in false positive or negative. The number
of generated constraints is 250 with exploit generation time
of 174 sec. The exploit string for this sequence is shown in
Listing 23 in the Appendix. The navigation to reach and
execute the queries in Listings 14 and 15 are as follows:
$user=htmlspecialchars($_POST[’user’]);//insufficient sanitization
1 if (isset($_POST[’user’]))
2
3 $password = $_POST[’password’];
4 $repassword = $_POST[’repassword’];
5 $level = intval($_POST[’level’]); //strong sanitization
6 $password = md5(trim($password)); //strong sanitization
7 if ($level==1 or $level==2) {
8
$sql = "INSERT INTO ".USER_TBL." SET user=’$user’,
password=’$password’, level=’$level’";
9
$result = $db->sql_query($sql); }
Listing 14: Step 1 (insert) in adduser.php.
1 $sql = "SELECT * FROM ".USER_TBL." WHERE id=’$id’";
Listing 15: Step 2 (select) in edituser.php, myBloggie.
For geccBBlite Chainsaw generated 7 second-order ex-
ploits in the modules scrivi.php and rispondi.php. The
following discusses one stored XSS exploit, as the other ex-
ploits are similar to this one. Listing 16 shows the ﬁrst step of
this exploit where the malicious XSS payload is written to the
database without suﬃcient sanitization for $titolo variable.
The second step occurred in leggi.php where all messages
stored in the geccBB_forum table are retrieved and rendered
to users without sanitization as in Listing 17. This exploit
has a navigation length of 2 (rispondi.php and leggi.php).
The number of generated constraints is 40 with exploit gen-
eration time of 13 sec. The corresponding exploit string is
shown in Listing 24 in the Appendix.
1 $titolo=$_POST[titolo];...
2 $query_ins_risposta="INSERT INTO geccBB_forum VALUES (’’,
’$postatoda’,’$data’,’$titolo’,’$testonuovo’,’$rispostadel’)";
3 $r=mysql_query($query_ins_risposta);
Listing 16: Step 1 (insert) in rispondi.php.
1 $rd=$_GET[rd];
2 if($rd)
3
$query_caga_messaggio="SELECT * FROM geccBB_forum WHERE id=$rd";
...
echo "re: " . $leggi[titolo];
4
5
Listing 17: Step 2 (select and then echo) in leggi.php.
On Schoolmate, our tool generated 2 stored XSS exploits.
Listings 18 and 19 show one of these exploits. In the ﬁrst
step, the attacker can execute the update query without any
authentication or authorization. The application receives
the attacker’s input and stores it in schoolinfo table in
which two columns schoolname and sitetext are of type
varchar (i.e., allows malicious characters if no sanitization
applied in the source code). In the second step, the malicious
payload is executed when any user of the site visits login.php.
This exploit has a navigation length of 2 (header.php and
login.php). The number of generated constraints is 150 with
exploit generation time of 98 sec. The exploit string is shown
in Listing 25 in the Appendix.
or die("Unable to retrieve school name: " . mysql_error());
1 $query = mysql_query("select schoolname from schoolinfo")
2
3 $schoolname = mysql_result($query,0);
4 if($_POST["infoupdate"] == 1)
5
$query = mysql_query("UPDATE schoolinfo SET schoolname=
".htmlspecialchars($_POST["schoolname"]).",address=
’$_POST[schooladdress]’, phonenumber=
’$_POST[schoolphone]’,sitetext=’$_POST[sitetext]’,
sitemessage= ’$_POST[sitemessage]’, numsemesters=
’$_POST[numsemesters]’, numperiods= ’$_POST[numperiods]’,
apoint= ’$_POST[apoint]’,bpoint= ’$_POST[bpoint]’,cpoint=
’$_POST[cpoint]’,dpoint= ’$_POST[dpoint]’,fpoint=
’$_POST[fpoint]’ where schoolname = ’$schoolname’ LIMIT 1");
Listing 18: Step 1 (update) in header.php.
1 $query = mysql_query("select sitetext from schoolinfo");
WebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!login.phpadmin.phpformadduser.phpincludeWebGraphviz is Graphviz in the BrowserEnter your graphviz data into the Text Area:(Your Graphviz data is private and never harvested)Sample 1 Sample 2 Sample 3 Sample 4 Sample 5 digraph G {  "Welcome" -> "To"  "To" -> "Web"  "To" -> "GraphViz!"}Generate Graph!login.phpadmin.phpformedituser.phpinclude6492 $text = mysql_result($query,0);
3 print("... $text  ...);
Listing 19: Step 2 (select and print) in login.php.
5.4 Effect of Database Schema Analysis
Table 3 shows the contribution of the database schema
analysis we implemented in Chainsaw. Overall, Chainsaw
reduced the false positive rate on exploit seed generation by
an average of 16% per application on 8 of the 9 applications
in our dataset. For WeBid, Chainsaw’s DB-schema analysis
reduced the false positive rate on SQLI seed generation by
nearly 60%. Note that for Scarf the entries are zero because
we have not found SQLI seeds for it.
App.
Without Schema With Schema Conﬁrmed
myBloggie
scarf beta
DNScript
WeBid
Eve
schoolmate
geccbblite
faqforge
webchess
24
0
4
99
6
60
3
4
28
24
0
4
40
5
51
3
4
15
21
0
1
40
5
49
3
4
15
Table 3: Eﬀect of DB schema analysis on SQLI seed exploits
5.5 Overhead and Analysis Complexity
Table 4 summarizes the runtime overhead of Chainsaw
for exploit generation. The analysis time ranges from 10
to 600 minutes. For small applications such as geccbblite,
solving the ﬁnal exploit formula took less than a minute
while in big applications such as WeBid it took about 42
minutes. Generally, the increase in the number of possible
execution paths in each module and number of modules in
each application increases the analysis time. The maximum
length of navigation sequences traversed by the generated
exploits ranges from 2 to 5 modules. Note that for Webid,
schoolmate, and webchess, the analysis time and solving time
are exceptionally long because Chainsaw has to traverse
1.09 million, 1.93 million, and 1.5 million execution paths
respectively. For each execution path, our system has to
compute the symbolic formula and invoke the solver —thus
contributing to the analysis and solving overheads.
Analysis
Time
(m)
Solving
Time
(m)
Expl.
Gen.
Time
(m)
Max. Len. of
Nav. Seq.
Application
myBloggie
scarf
DNScript
WeBid
Eve
schoolmate
geccbblite
faqforge
webchess
125
10
20
600
19
400
10
20
136
95
39
120
345
5
159
10
8
120
20
2
4
42
3
23
<1
3
14
3
2
2
5
2
4
2
2
3
Table 4: Runtime summary of Chainsaw. Analysis Time:
total time before invoking solver. Solving Time: total
time to solve all SMT formulas (including unsatisﬁable ones).
Expl. Gen. Time: total time for solving satisﬁable SMT
formulas that represent exploits. Max. Len. of Nav.
Seq.: maximum length of navigation sequences for exploits.
5.6 Comparison with Related Work
Note that one-to-one comparison of Chainsaw with prior
work is not easy due to (i) absence of working tools for some
prior work (ii) outdated test subjects and (iii) lack of clarity
on how results are counted. Nevertheless, wherever we could
ﬁnd a common ground (e.g., common subject applications,
same attack types), we compare Chainsaw with prior work.
Regarding seed generation, we compare seeds generated by
Chainsaw with vulnerabilities reported in [8], [9], and [26].
On the exploit generation front, we compare Chainsaw
with [19] and [16] since both of their datasets are subsumed
by the test subjects in Chainsaw. Tables 5 and 6 show
the summary of Chainsaw’s comparison with these works.
Note that diﬀerent from some of these works, we count the
number of seeds based on the number of unique sinks not
per path. For instance, for n vulnerable paths leading to a
sink, Chainsaw reports only one seed for this sink.
Seed generation: Wassermann and Su [26] identiﬁed 5
SQLI vulnerabilities in EVE whereas Chainsaw generated 7
SQLI exploit seeds, all of which have been transformed into
working exploits. RIPS [8] identiﬁed 8 SQLI vulnerabilities
in myBloggie while Chainsaw generated 24 SQLI exploit
seeds (3 times more exploits than RIPS ) since it performs
path-sensitive analysis, which in RIPS is not available.
Exploit generation: Ardilla [19] generated 60 attacks (23
SQLI and 37 XSS) on a dataset of 5 applications (see Table
5). On the same dataset, Chainsaw generated 116 (56
more) working exploits, which shows that Chainsaw has