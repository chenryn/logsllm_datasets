          cbName = strlen(srcRef->lpszAnsiClassName) + 1;
          lpszAnsiClassNameAlloced = ClassAlloc((__int64)hheapDesktop, cbName);
          pclsClone->lpszAnsiClassName = (char *)lpszAnsiClassNameAlloced;
          if ( !lpszAnsiClassNameAlloced )
          {
    LABEL_10:
            ClassFree((__int64)hheapDesktop, pclsClone);
            return 0i64;
          }
          lpszMenuNameRef = srcRef->lpszMenuName;
          if ( (unsigned __int64)lpszMenuNameRef & 0xFFFFFFFFFFFF0000ui64 )
          {
            menuSizeIndex = -1i64;
            do
            {
              if ( !menuSizeIndex )
                break;
                //如果遇到字符串终止就结束循环
              v11 = *lpszMenuNameRef == 0;
              //menu字符串长度
              ++lpszMenuNameRef;
              --menuSizeIndex;
            }
            while ( !v11 );
            menuSizeIndexRet = 2 * ~(_DWORD)menuSizeIndex;
            //这里为lpszMenuNameCopy重新申请了内存
            lpszMenuNameCopy = (unsigned __int16 *)ExAllocatePoolWithQuotaTag((POOL_TYPE)41, menuSizeIndexRet, 0x78747355u);
            pclsClone->lpszMenuName = lpszMenuNameCopy;
            if ( !lpszMenuNameCopy )
            {
              ClassFree((__int64)hheapDesktop, pclsClone->lpszAnsiClassName);
              goto LABEL_10;
            }
          }
          else
          {
            menuSizeIndexRet = v17;
          }
          pclsClone->rpdeskParent = 0i64;
          LockObjectAssignment(&pclsClone->rpdeskParent, hheapDesktop);
          v14 = srcRef->pclsClone;
          pclsClone->pclsClone = 0i64;
          pclsClone->pclsNext = v14;
          v15 = srcRef->lpszAnsiClassName;
          srcRef->pclsClone = pclsClone;
          memmove(pclsClone->lpszAnsiClassName, v15, (unsigned int)cbName);
          v16 = (unsigned __int64)pclsClone->lpszMenuName;
          if ( v16 & 0xFFFFFFFFFFFF0000ui64 )
            memmove((void *)v16, srcRef->lpszMenuName, menuSizeIndexRet);
          pclsClone->spcur = 0i64;
          pclsClone->spicnSm = 0i64;
          pclsClone->spicn = 0i64;
          HMAssignmentLock(&pclsClone->spicn, srcRef->spicn);
          HMAssignmentLock(&pclsClone->spicnSm, srcRef->spicnSm);
          HMAssignmentLock(&pclsClone->spcur, srcRef->spcur);
          pclsClone->spcpdFirst = 0i64;
          pclsClone->cWndReferenceCount = 0;
        }
        ++srcRef->cWndReferenceCount;
        ++pclsClone->cWndReferenceCount;
        pwndRef->pcls = pclsClone;
        return 1i64;
      }
      ++Src->cWndReferenceCount;
      return 1i64;
    }
可见更新后为克隆tagCLS结构的lpszMenuName重新申请了重新申请了pool内存,在调用DestroyWindow和NtUserUnregisterClass释放tagCLS结构时,导致每次释放释放的都是是新申请的内存,修复了Double-free问题.
其实这个lpszMenuName对象在调用SetClassLongPtrA函数时已经被被释放和重新申请了一次,而在ReferenceClass克隆tagCLS结构指向的还是原来的lpszMenuName对象,结构又被释放了一次.下面通过分析代码来解释释放过程.
    __int64 __fastcall NtUserSetClassLongPtr(tagWND *a1, unsigned int nidx, __int64 *dwNewLong, unsigned int true)
    {
        if ( nidxRef == -26 )
        {
          .....
        }
        else if ( nidxRef == -8 )
        {
          // 就是poc中的GCLP_MENUNAME类型
          v20 = dwNewLongRef;
          v11 = dwNewLongRef;
          if ( dwNewLongRef >= W32UserProbeAddress )
            v11 = (__int64 *)W32UserProbeAddress;
          v17 = *v11;
          v18 = v11[1];
          v19 = (__m128i *)v11[2];
          v12 = v19;
          if ( v19 >= W32UserProbeAddress )
            v12 = (const __m128i *)W32UserProbeAddress;
          _mm_storeu_si128(&v16, _mm_loadu_si128(v12));
          v13 = v16.m128i_u64[1];
          if ( v16.m128i_i64[1] & 0xFFFFFFFFFFFF0000ui64 )
          {
            if ( v16.m128i_i8[8] & 1 )
              ExRaiseDatatypeMisalignment();
            v14 = v16.m128i_u16[0] + v13 + 2;
            if ( v14 >= (unsigned __int64)W32UserProbeAddress
              || (unsigned __int16)v16.m128i_i16[0] > v16.m128i_i16[1]
              || v14 = W32UserProbeAddress )
            dwNewLongRef = (__int64 *)W32UserProbeAddress;
          *dwNewLongRef = v17;
          dwNewLongRef[1] = v18;
          dwNewLongRef[2] = (__int64)v19;
          goto LABEL_21;
        }
        //调用xxxSetClassLongPtr
        v10 = xxxSetClassLongPtr(v9, nidxRef, (__int64)dwNewLongRef, v4);
    .
    }
    //xxxSetClassLongPtr接着会调用xxxSetClassData这里略过..
    __int64 __fastcall xxxSetClassData(tagWND *pwnd, int nidx, unsigned __int64 dwData, unsigned int bAnsi)
    {
        ....
        switch ( nidx )
      {
           // 就是poc中的GCLP_MENUNAME类型
          case -8:
          lpszMenuNameRef = pCls->lpszMenuName;
          DataFrom = dwData[2];
          buffCheck = DataFrom->Buffer;
          if ( !((unsigned __int64)buffCheck & 0xFFFFFFFFFFFF0000ui64) )
          {
            pCls->lpszMenuName = buffCheck;
            goto Free_MenuName;
          }
          // 重新申请MenuName内存
          RtlInitUnicodeString(&DestinationString, DataFrom->Buffer);
          if ( !DestinationString.Length )
          {
            pCls->lpszMenuName = 0i64;
    Free_MenuName:
            *(_QWORD *)&v5[1].Length = 0i64;
            if ( (unsigned __int64)lpszMenuNameRef & 0xFFFFFFFFFFFF0000ui64 )
              // 这里释放lpszMenuName
              ExFreePoolWithTag(lpszMenuNameRef, 0);
            dwOld = pCls->lpszClientAnsiMenuName;
            pCls->lpszClientAnsiMenuName = *(char **)&v5->Length;
            *(_QWORD *)&v5->Length = dwOld;
            OldClientUnicodeMenuName = (char *)pCls->lpszClientUnicodeMenuName;
            pCls->lpszClientUnicodeMenuName = v5->Buffer;
            v5->Buffer = (unsigned __int16 *)OldClientUnicodeMenuName;
            if ( v4 )
              OldClientUnicodeMenuName = *(char **)&v5->Length;
            return (__int64)OldClientUnicodeMenuName;
          }
          if ( !(unsigned int)AllocateUnicodeString(&pszMenuNameNew, &DestinationString) )
            return 0i64;
          // 赋值新申请的MenuName
          pCls->lpszMenuName = pszMenuNameNewRet;
          goto Free_MenuName;
      }
      }
      ....
    }
此时原pCls->lpszMenuName第一次释放,在poc中调用NtGdiSetLinkedUFIs占位释放的内存.
接着调用DestroyWindow第二次释放对象,以NtUserDestroyWindow->xxxDestroyWindow->
xxxFreeWindow->DereferenceClass->DestroyClass的顺序最后释放克隆的pCls对象
接着调用NtUserUnregisterClass->UnregisterClass->DestroyClass顺序释放原pCls对象,原pCls->lpszMenuName和克隆的pCls->lpszMenuName指向的是同一内存区域,所以肯定会被释放,是否3次释放??
## 池风水布局调试分析
在poc中先申请了10000个100大小的AcceleratorTable(以下简称acc),然后释放前3000个,并创建3000个e00大小的acc,部分e00和2个100的acc会占满一页,然后再释放1500个100的acc和创建1500个200大小acc,这样原释放100和新创建的200会填满池空隙,有些e00和200的acc会占满一页,也存在e00和2个100的acc占满一页情况,又由于e00的acc数量大于200的acc,会出现大量的e00和200大小free的页面空洞,用于放置poc中要创建的lpszMenuName,最后又把最后4000个100的acc释放,导致更多相同空洞出现.效果如下图:
下面我们来看下poc运行过程内核对象池风水的实际布局情况,具体过程如图:
对于这个漏洞关键对象pCls->lpszMenuName内核地址获取可以通过以下方式查看:
bp win32k!ReferenceClass+0x6b “p;”
也就是ReferenceClass函数中其中
pclsClone = (tagCLS *)ClassAlloc((__int64)hheapDesktop, (Src->CSF_flags & 8u)
+ Src->cbclsExtra + 160)这行代码,采用调试脚本如下:
    r;
    r $t0=rax;
    .printf"t0=%pn",@$t0;
    //这里pCls->lpszMenuName=0x88偏移量
    gu;r $t1=poi(@$t0+88);
    .printf"t1=%pn",@$t1;
    !pool @$t1;
poc运行流程顺序如图:
来看具体windbg调试过程:
    在执行完这行代码后
    hWndCloneCls = CreateWindowA("WNDCLASSMAIN", "CVE", WS_DISABLED, 0, 0, 0, 0, nullptr, nullptr, hInst, nullptr);
    //在win32k!ReferenceClass函数触发断点,此时我们查看pool的分配情况
    kd> bp win32k!ReferenceClass+0x6b "p;"
    WARNING: Software breakpoints on session addresses can cause bugchecks.
    Use hardware execution breakpoints (ba e) if possible.
    kd> bl
     0 e fffff960`0012fcab     0001 (0001) win32k!ReferenceClass+0x6b "p;"
    kd> g
    win32k!ReferenceClass+0x70:
    fffff960`0012fcb0 488bf0          mov     rsi,rax
    //运行调试脚本
    kd> $$ r;
    rax=fffff900c3c013d0 rbx=fffffa80042b6f20 rcx=fffff900c3c01470
    rdx=0000000000000000 rsi=0000000000000000 rdi=fffff900c0c4ccc0
    rip=fffff9600012fcb0 rsp=fffff88004de2670 rbp=fffff900c0c4ccc0
     r8=0000000000000000  r9=0000000000000000 r10=00000000000000fe
    r11=fffff88004de2610 r12=fffff900c3c012a0 r13=fffff88004de0000
    r14=0000000000000000 r15=fffff88004de29a8
    iopl=0         nv up ei ng nz na po nc
    cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00000286
    win32k!ReferenceClass+0x70:
    fffff960`0012fcb0 488bf0          mov     rsi,rax
    kd> r $t0=rax;
    kd> .printf"t0=%pn",@$t0;
    t0=fffff900c3c013d0
    kd> gu;r $t1=poi(@$t0+88);
    kd> .printf"t1=%pn",@$t1;
    t1=fffff900c566de20