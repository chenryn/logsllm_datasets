ﬁle write bandwidth
pagefault
UDP latency
TCP latency
RPC/udp latency
RPC/tcp latency
TCP/IP connection cost
Base
0.6492
0.8483
0.7726
2.8257
1.0139
3.7906
21.7686
37.8027
1.2346
2.3954
0.3994
6.4345
1310.19 MB/sec
8.2
1472.10 MB/sec
116.5581
484.3333
1413.25
16997 KB/sec
1.3288
14.4036
17.1356
24.6433
29.7117
64.5465
Enforcing
0.6492
1.0017
0.8981
2.8682
1.0182
4.0608
21.8458
37.9795
1.2346
2.4079
0.3872
6.2065
1292.54 MB/sec
8.9418
1457.57 MB/sec
120.3478
500.1818
1444.25
16854 KB/sec
1.3502
14.6798
18.3555
24.8790
32.4626
64.8352
Overhead (%)
0
18
16
1.5
0.4
7
0.3
0.5
0
0.5
-3
-3
7
9
9
3
3
2
0.8
2
2
7
1
9
1
SELinux(%)
28
27
12
19
1
3
10
15
9
18
9
9
Figure 5. The performance results of lmbench 3 measurements (in microseconds).
13
icy model that achieves a high degree of protection with-
out getting in the way of normal operations. Both sys-
trace and LIDS require intimate familiarity with UNIX in-
ternals for conﬁguration. SELinux adopts the approach that
MAC information is independent from DAC. For example,
the users in SELinux are unrelated with the users in DAC,
each ﬁle needs to be given a label. This requires the ﬁle
system to support additional labeling, and limits the appli-
cability of the approach. Furthermore, labeling ﬁles is a
labor-intensive and error-prone process. Each installation
of a new software requires update to the policy to assign ap-
propriate labels to the newly added ﬁles and possibly add
new domains and types. SELinux policies are difﬁcult to
understand by human administrators because of the size of
the policy and the many levels of indirection used, e.g., from
programs to domains, then to types, and then to ﬁles. Our
protection system, on the other hand, utilizes existing valu-
able DAC information, requires much less conﬁguration,
and has policies that are easy to understand.
AppArmor [8, 1] is a Linux protection system that has
similarities with our work. It conﬁnes applications by creat-
ing security proﬁles for programs. A security proﬁle identi-
ﬁes all capabilities and ﬁles a program is allowed to access.
Similar to our approach, AppArmor also uses ﬁle paths to
identify programs and ﬁles in the security proﬁles. Regard-
ing policy design, AppArmor uses the same approach as
the Targeted Policy in Fedora Core Linux, i.e., if a program
has no policy associated with it, then it is by default not
conﬁned, and if a program has a policy, then it can access
only the objects speciﬁed in the policy. This approach vio-
lates the fail-safe defaults principle [20], as a program with
no policy will by default run unconﬁned. By not conﬁn-
ing high-integrity processes and allowing low-integrity pro-
cesses to access unprotected ﬁles, UMIP can afford to fol-
low the fail-safe default principle and only specify excep-
tions for programs. AppArmor does not maintain integrity
levels for processes or ﬁles, and thus cannot differentiate
whether a process or a ﬁle is contaminated or not. For ex-
ample, without tracking contamination, one cannot specify
a policy that system administration through X clients are al-
lowed as long as the X server and other X clients have not
communicated with the network. Also, AppArmor cannot
protect users from accidentally downloading and executing
malicious programs.
Securelevel [11] is a security mechanism in *BSD ker-
nels. When the securelevel is positive, the kernel restricts
certain tasks; not even the superuser (i.e., root) is allowed
to do them. Any superuser process can raise securelevel,
but only the init process can lower it. The weakness of
securelevel is clearly explained in the FreeBSD FAQ [11]:
“One of its biggest problems is that in order for it to be at
all effective, all ﬁles used in the boot process up until the
securelevel is set must be protected. If an attacker can get
the system to execute their code prior to the securelevel be-
ing set [...], its protections are invalidated. While this task
of protecting all ﬁles used in the boot process is not techni-
cally impossible, if it is achieved, system maintenance will
become a nightmare since one would have to take the sys-
tem down, at least to single-user mode, to modify a conﬁg-
uration ﬁle.” UMIP enables system administration through
high-integrity channels, thereby avoiding the difﬁculty se-
curelevel has. UMIP also tracks ﬁle contamination to en-
sure that all ﬁles read during booting are high integrity for
the system to end up in a high-integrity state.
In UMIP, a program may be partially trusted in the sense
that it is allowed to violate the default contamination rule
and/or the limitations on low-integrity processes. Such trust
is necessary for ensuring that existing applications and ad-
ministration practices can be used. However, in UMIP pro-
grams are viewed as blackboxes, and the trust on them is
not justiﬁed. The CW-Lite work [22] addresses this issue
of trust by explicitly analyzing source code of programs.
One identiﬁes inputs into programs and annotates the source
code with indications where ﬁltering occurs. One then
checks whether low-integrity inputs are properly ﬁltered be-
fore they ﬂow into high-integrity objects. This process en-
ables one to discover bugs in the policy conﬁguration or in
the program source code. The CW-Lite work is thus com-
plementary to UMIP.
6 Conclusions
We have identiﬁed six design principles for designing
usable access control mechanisms. We have also intro-
duced the UMIP model, a simple, practical MAC model for
host integrity protection, designed using these principles.
The UMIP model defends against attacks targeting network
server and client programs and protects users from careless
mistakes. It supports existing applications and system ad-
ministration practices, and has a simple policy conﬁgura-
tion interface. To achieve these, we introduced in UMIP
several novel features in integrity protection. We have also
reported the experiences and evaluation results of our im-
plementation of UMIP under Linux. We plan to continue
testing and improving the code and release it to the open-
source community in near future. We also plan to develop
tools that help system administrators analyze a UMIP con-
ﬁguration and identify channels through which an attacker
may get a high-integrity process (e.g., by exploiting a re-
mote administration point).
Acknowledgement This work is supported by NSF CNS-
0448204 and by sponsors of CERIAS. We thank Xuxian
Jiang for helpful discussions and suggestions on approaches
to evaluate the UMIP implementation under Linux. We also
thank the anonymous reviewers and shepherd of our paper
14
[13] LIDS:
http://www.lids.org/.
Linux
intrusion
detection
system.
[14] P. Loscocco and S. Smalley.
Integrating ﬂexible
support for security policies into the Linux operat-
ing system.
In Proceedings of the FREENIX track:
USENIX Annual Technical Conference, pages 29–42,
June 2001.
[15] M. D. Mcllroy and J. A. Reeds. Multilevel security
in the unix tradition. Software—Practice and Experi-
ence, 22(8):673–694, Aug. 1992.
[16] NSA.
Security
http://www.nsa.gov/selinux/.
enhanced
linux.
[17] N. Provos. Improving host security with system call
policies. In Proceedings of the 2003 USENIX Security
Symposium, pages 252–272, August 2003.
[18] N. Provos, M. Friedl, and P. Honeyman. Prevent-
ing privilege escalation. In Proceedings of the 2003
USENIX Security Symposium, pages 231–242, August
2003.
[19] E. S. Raymond.
The Art of UNIX Programming.
Addison-Wesley Professional, 2003.
[20] J. H. Saltzer and M. D. Schroeder. The protection of
information in computer systems. Proceedings of the
IEEE, 63(9):1278–1308, September 1975.
[21] R. Sandhu. Good-enough security: Toward a prag-
matic business-driven discipline. IEEE Internet Com-
puting, 7(1):66–68, Jan. 2003.
[22] U. Shankar, T. Jaeger, and R. Sailer. Toward au-
tomated information-ﬂow integrity veriﬁcation for
security-critical applications.
In Proceedings of the
2006 ISOC Networked and Distributed Systems Secu-
rity Symposium, February 2006.
[23] D. R. Wichers, D. M. Cook, R. A. Olsson, J. Cross-
ley, P. Kerchen, K. N. Levitt, and R. Lo. Pacl’s: An
access control list approach to anti-viral security. In
Proceedings of the 13th National Computer Security
Conference, pages 340–349, Oct. 1990.
[24] C. Wright, C. Cowan, J. Morris, S. Smalley, and
G. Kroah-Hartman. Linux security modules: General
security support for the linux kernel. In Proc. USENIX
Security Symposium, pages 17–31, 2002.
Trent Jaeger for valuable comments that have greatly im-
proved the paper.
References
[1] Apparmor
application
security
for
linux.
http://www.novell.com/linux/security/apparmor/.
[2] L. Badger, D. F. Sterne, D. L. Sherman, K. M. Walker,
and S. A. Haghighat. A domain and type enforcement
UNIX prototype. In Proc. USENIX Security Sympo-
sium, June 1995.
[3] L. Badger, D. F. Sterne, D. L. Sherman, K. M. Walker,
and S. A. Haghighat. Practical domain and type en-
forcement for UNIX.
In Proc. IEEE Symposium on
Security and Privacy, pages 66–77, May 1995.
[4] K. J. Biba.
Integrity considerations for secure com-
puter systems. Technical Report MTR-3153, MITRE,
April 1977.
[5] D. Brumley and D. Song. PrivTrans: Automatically
partitioning programs for privilege separation. In Pro-
ceedings of the USENIX Security Symposium, August
2004.
[6] H. Chen, D. Dean, and D. Wagner. Setuid demys-
In Proc. USENIX Security Symposium, pages
tiﬁed.
171–190, Aug. 2002.
[7] D. D. Clark and D. R. Wilson. A comparision of com-
mercial and military computer security policies.
In
Proceedings of the 1987 IEEE Symposium on Security
and Privacy, pages 184–194. IEEE Computer Society
Press, May 1987.
[8] C. Cowan, S. Beattie, G. Kroah-Hartman, C. Pu,
P. Wagle, and V. D. Gligor. Subdomain: Parsimonious
server security. In Proceedings of the 14th Conference
on Systems Administration (LISA 2000), pages 355–
368, Dec. 2000.
[9] DOD. Trusted Computer System Evaluation Criteria.
Department of Defense 5200.28-STD, Dec. 1985.
[10] T. Fraser. LOMAC: Low water-mark integrity protec-
tion for COTS environments. In 2000 IEEE Sympo-
sium on Security and Privacy, May 2000.
[11] Frequently Asked Questions for FreeBSD 4.X, 5.X, and
http://www.freebsd.org/doc/en US.ISO8859-
6.X.
1/books/faq/.
[12] I. Goldberg, D. Wagner, R. Thomas, and E. A. Brewer.
A secure environment for untrusted helper applica-
tions: Conﬁning the wily hacker.
In Proc. USENIX
Security Symposium, pages 1–13, June 1996.
15