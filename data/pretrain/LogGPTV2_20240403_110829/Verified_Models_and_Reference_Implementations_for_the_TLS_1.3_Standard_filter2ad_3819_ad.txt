group, a strong hash function, and a strong authenticated
encryption algorithm.
If we further assume that TLS 1.3 clients and servers only
support strong algorithms, we can simplify the above query
to show that all messages sent between uncompromised
principals are kept secret. In the rest of this paper, we
assume that TLS 1.3 only enables strong algorithms, but
that earlier versions of the protocol may continue to support
weak algorithms.
Messages m1 from the client to the server enjoy strong
authentication and protection from replays:
• 1-RTT Authentication (and Replay Prevention): If a
message m is accepted by S over a session with an honest
(cid:2)
C, then this message corresponds to a unique message
sent by the C over a matching session.
However
the authentication guarantee for messages
m0.5, m1 received by the client is weaker. Since the client
does not know whether the server sent this data before or
after receiving the client’s second ﬂight, the client and server
sessions may disagree about the client’s identity. Hence, for
these messages, we can only verify a weaker property:
• 0.5-RTT Weak Authentication (and Replay Preven-
tion): If a message m is accepted by C over a session with
an honest S, then this message corresponds to a unique
message sent by S over a server session that matches all
values in the client session except (possibly) the client’s
public key pk C, the resumption master secret psk
, and
the channel identiﬁer cid.
We note that by allowing the server to send 0.5-RTT data,
Draft-18 has weakened the authentication guarantees for all
data received by an authenticated client. For example, if a
client requests personal data from the server over a client-
authenticated 1-RTT session, a network attacker could delay
the client’s second ﬂight (Certificate− Finished) so
that when the client receives the server’s 0.5-RTT data, it
thinks that it contains personal data, but the server actually
sent data intended for an anonymous client.
Verifying TLS 1.3 1-RTT composed with TLS 1.2. We
combine our model with the TLS 1.2 model described at
the end of §II so that each client and server supports both
versions. We then ask the same queries as above, but only
for sessions where the server chooses TLS 1.3 as the version
in mode S. Surprisingly, ProVerif ﬁnds two counterexamples.
First, if a server supports WeakRSADecryption with RSA
key transport in TLS 1.2, then the attacker can use the RSA
decryption oracle to forge TLS 1.3 server signatures and
hence break our secrecy and authentication goals. This attack
found by ProVerif directly corresponds to the cross-protocol
Bleichenbacher attacks described in [47], [7]. It shows that
removing RSA key transport from TLS 1.3 is not enough,
one must disable the use of TLS 1.2 RSA mode on any
server whose certiﬁcate may be accepted by a TLS 1.3 client.
Second, if a client or server supports a weak hash function
for signatures in TLS 1.2, then ProVerif shows how the
attacker can exploit this weakness to forge TLS 1.3 signa-
tures in our model, hence breaking our security goals. This
attack corresponds to the SLOTH transcript collision attack
on TLS 1.3 signatures described in [23]. To avoid this attack,
TLS 1.3 implementations must disable weak hash functions
in all supported versions, not just TLS 1.3.
After disabling these weak algorithms in TLS 1.2, we can
indeed prove all our expected security goals about Draft-18
1-RTT, even when it is composed with TLS 1.2.
We may also ask whether TLS 1.3 clients and servers can
be downgraded to TLS 1.2. If such a version downgrade
takes place, we would end up with a TLS 1.2 session, so
we need to state the query in terms of sessions where mode S
contains TLS 1.2. ProVerif ﬁnds a version downgrade attack
on a TLS 1.3 session,
if the client and server support
weak Difﬁe-Hellman groups in TLS 1.2. This attack closely
mirrors the ﬂaw described in [14]. Draft-13 introduced a
490
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
countermeasure in response to this attack, and we verify that
by adding it to the model, the downgrade attack disappears.
Although our models of TLS 1.3 and 1.2 are individually
veriﬁed in a few seconds each,
their composition takes
several minutes to analyze. As we add more features and
modes to the protocol, ProVerif takes longer and requires
more memory. Our ﬁnal composite model for all modes of
TLS 1.3+1.2 takes hours on a powerful workstation.
IV. 0-RTT WITH SEMI-STATIC DIFFIE-HELLMAN
In earlier versions of TLS, the client would have to wait
for two round-trips of handshake messages before sending
its request. 1-RTT in TLS 1.3 brings this down to one
round trip, but protocols like QUIC use a ”zero-round-
trip” (0-RTT) mode, by relying on a semi-static (long-term)
Difﬁe-Hellman key. This design was adapted for TLS in the
OPTLS proposal [52] and incorporated in Draft-7 (along
with a ﬁx we proposed, as described below).
Protocol Flow. The protocol is depicted in Figure 3. Each
server maintains a Difﬁe-Hellman key pair (s, gs) and
publishes a signed server conﬁguration containing gs. As
usual, a client initiates a connection with a ClientHello
containing its ephemeral key gx. If a client has already
obtained and cached the server’s certiﬁcate and signed
conﬁguration (in a prior exchange for example), then the
client computes a shared secret gxs and uses it to derive
an initial set of shared keys which can then immediately be
used to send encrypted data. To authenticate its 0-RTT data,
the client may optionally send a certiﬁcate and a signature
over the client’s ﬁrst ﬂight.
The server then responds with a ServerHello mes-
sage that contains a fresh ephemeral public key gy. Now,
the client and server can continue with a regular 1-RTT
handshake using the new shared secret gxy in addition to
gxs.
The 0-RTT protocol continued to evolve from Draft-7 to
Draft-12, but in Draft-13, it was removed in favor of a PSK-
based 0-RTT mode. Even though Difﬁe-Hellman-based 0-
RTT no longer exists in Draft-18, we analyze its security in
this section, both for posterity and to warn protocol designers
about the problems they should watch our for if they decide
to reintroduce DH-based 0-RTT in a future version of TLS.
Veriﬁcation with ProVerif. We modeled the protocol in
ProVerif and wrote queries to check whether the 0-RTT data
m0 is (forward) secret and authentic. ProVerif is able to
prove secrecy but ﬁnds that m0 is not forward secret if the
semi-static key s is compromised once the session is over.
ProVerif also ﬁnds a Key Compromise Impersonation attack
on authentication: if gs is compromised, then an attacker
can forge 0-RTT messages from C to S. Furthermore, the
0-RTT ﬂight can be replayed by an attacker and the server
will process it multiple times, thinking that the client has
initiated a new connection each time. In addition to these
three concerns, which were documented in Draft-7, ProVerif
also ﬁnds a new attack, explained below, that breaks 0-RTT
authentication if the server’s certiﬁcate is not included in the
0-RTT client signature.
C
S
Knows (sk C, pk S)
Knows (sk S, pk S), (s, gs)
Certificate(pk S)
sign
sk S (H(ServerConfig(gs)))
Generates x
log 1
ClientHello(nC, oﬀer C[G, gx])
log 1
h, k0
k0
m, k0
Computes:
c = kdfss (gxs, log 1)
h, k0
k0
m, k0
Computes:
c = kdfss (gxs, log 1)
log 2
log 3
log 4
enck0
h (CertVerify(sign
h (Finished(mack0
enck0
enck0
h (Certificate(pk C))
sk C (H(log 2))))
m (H(log 3))))
enck0
c (Data(m0))
ServerHello(nS, mode S[G, gy])
(Continue 1-RTT Exchange)
log 2
log 3
log 4
New client session:
C = C (cid:2) cid (cid:3)→ (oﬀer C, mode S,
pk C, pk S, psk ,
kc, ks, psk
(cid:2))
New server session:
S = S (cid:2) cid (cid:3)→ (oﬀer C, mode S,
pk C, pk S, psk ,
kc, ks, psk
(cid:2))
enckc (Data(m1))
Application Data Stream:
cid←→ S : m0, m1, . . .
C
Application Data Stream:
cid←→ S : m0, m1, . . .
C
Figure 3: DH-based 0-RTT in TLS 1.3 Draft-12, inspired by
QUIC and OPTLS.
Unknown Key Share Attack on DH-based 0-RTT in
QUIC, OPTLS, and TLS 1.3. We observe that in the 0-
RTT protocol, the client starts using gs without having any
proof that the server knows s. So a dishonest server M can
claim to have the same semi-static key as S by signing gs
under its own key sk M . Now, suppose a client connects to
M and sends its client hello and 0-RTT data; M can simply
forward this whole ﬂight to S, which may accept it, because
the semi-static keys match. This is an unknown key share
(UKS) attack where C thinks it is talking to M but it is, in
fact, connected to S.
In itself, the UKS attack is difﬁcult to exploit, since M
does not know gxs and hence cannot decrypt or tamper
with messages between C and S. However, if the client
authenticates its 0-RTT ﬂight with a certiﬁcate, then M can
forward C’s certiﬁcate (and C’s signature) to S, resulting in
a credential forwarding attack, which is much more serious.
Suppose C is a browser that has a page open at website
M; from this page M can trigger any authenticated 0-RTT
HTTPS request m0 to its own server, which then uses the
credential forwarding attack to forward the request to S,
who will process m0 as if it came from C. For example, M
may send a POST request that modiﬁes C’s account details
at S.
The unknown key share attack described above applies to
both QUIC and OPTLS, but remained undiscovered despite
several security analyses of these protocols [42], [56], [52],
491
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:28:27 UTC from IEEE Xplore.  Restrictions apply. 
because these works did not consider client authentication,
and hence did not formulate an authentication goal that
exposed the ﬂaw. We informed the authors of QUIC and
they acknowledged our attack. They now recommend that
users who need client authentication should not use QUIC,
and should instead move over to TLS 1.3. We also informed
the authors of the TLS 1.3 standard, and on our suggestion,
Draft-7 of TLS 1.3 included a countermeasure for this attack:
the client signature and 0-RTT key derivation include not just
the handshake log but also the cached server certiﬁcate. With
this countermeasure in place, ProVerif proves authentication
for 0-RTT data.
V. PRE-SHARED KEYS FOR RESUMPTION AND 0-RTT
Client C
Server S
Knows (sk C, pk C), (psk , enckt (psk ))
Knows (sk S, pk S), kt
Generates x and computes:
es, kb = kdfes (psk )
log 1
mackb (ClientHello(nC, oﬀer C[G, gx, enckt (psk )]))
log 1
Computes:
k0
c = kdf0RTT (es, log 1)
Generates y, decrypts psk, and computes:
es, kb = kdfes (psk )
k0
c = kdf 0RTT (es, log 1)
enck0
c (Data(m0))
ServerHello(nS, mode S[G, gy])
(Continue 1-RTT Exchange)
New client session:
C = C (cid:2) cid (cid:3)→ (oﬀer C, mode S,
pk C, pk S, psk ,
kc, ks, psk
(cid:2))
New server session:
S = S (cid:2) cid (cid:3)→ (oﬀer C, mode S,
pk C, pk S, psk ,
kc, ks, psk
(cid:2))
enckc (Data(m1))
encks (Data(m2))
Application Data Stream:
cid←→ S : m0, m1, m2, . . .
C
Application Data Stream:
cid←→ S : m0, m1, m2, . . .
C
Figure 4: TLS 1.3 Draft-18 PSK-based Resumption and 0-
RTT.
Aside from the number of round-trips, the main cryp-
tographic cost of a TLS handshake is the use of public-
key algorithms for signatures and Difﬁe-Hellman, which
are still signiﬁcantly slower than symmetric encryption and
MACs. So, once a session has already been established
between a client and server, it is tempting to reuse the
symmetric session key established in this session as a pre-
shared symmetric key in new connections. This mechanism
is called session resumption in TLS 1.2 and is widely used in
HTTPS where a single browser typically has many parallel
and sequential connections to the same website. In TLS 1.2,
pre-shared keys (PSKs) are also used instead of certiﬁcates
by resource-constrained devices that cannot afford public-
key encryption. TLS 1.3 combines both these use-cases in
a single PSK-based handshake mode that combines resump-
tion, PSK-only handshakes, and 0-RTT.
Protocol Flow. Figure 4 shows how this mode extends the
regular 1-RTT handshake; in our analysis, we only consider
492
PSKs that are established within TLS handshakes, but sim-
ilar arguments apply to PSKs that are shared out-of-band.
We assume that the client and server have established a pre-
shared key psk in some earlier session. The client has cached
psk, but in order to remain state-less, the server has given the
client a ticket containing psk encrypted under an encryption
key kt. As usual, the client sends a ClientHello with
its ephemeral key share gx and indicates that it prefers to
use the shared PSK psk. To prove its knowledge of psk and
to avoid certain attacks (described below), it also MACs
the ClientHello with a binder key kb derived from
the psk. The client can then use psk to already derive an
encryption key for 0-RTT data m0 and start sending data
without waiting for the server’s response. When the server
receives the client’s ﬂight, it can choose to accept or reject
the offered psk. Even if it accepts the psk, the server may
choose to reject the 0-RTT data, it may choose to skip
certiﬁcate-based authentication, and (if it does not care about
forward secrecy) it may choose to skip the Difﬁe-Hellman
exchange altogether. The recommended mode is PSK-DHE,
where psk and gxy are both mixed into the session keys. The
server then sends back a ServerHello with its choice and
the protocol proceeds with the appropriate 1-RTT handshake
and completes the session.
Verifying PSK-based Resumption. We ﬁrst model
the
PSK-DHE 1-RTT handshake (without certiﬁcate authenti-
cation) and verify that it still meets our usual security goals:
• PSK-DHE 1-RTT (Forward) Secrecy Any message m
sent over a PSK-DHE session in 1-RTT is secret as long
as the PSK psk and the ticket encryption key kt are not
compromised until the end of the session.
• PSK-DHE 1-RTT Authentication and Replay Protec-
tion Any message m received over a PSK-DHE session