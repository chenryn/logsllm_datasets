列值当作标识符值进行查找，可以让查找速度更快。
216
量以及为处理行而发生的磁盘I/O数量。即使对于NULL值，CHAR也会占用n个字符空间，因
是如此。
VARCHAR（或者是选用BINARY，还是选用VARBINARY）来改变这一情况。在空间和时间之
一步验证某种格式是否真的比另一个更优秀。
固定长度的格式。这样能够减少主表里的碎片，并且可以让你享受到行固定长度所带来的好
在合成索引列中，会很有帮助。可以先搜索列，以确定想要的行；然后再从这些行里把那些
InnoDB并不会区别对待固定长度列和可变长度列（所有行都使用一个指向列值的头指针）
把 BLOB或TEXT列剥离出来形成一个单独的表。在某些场合，把表里的 BLOB或TEXT列剥
会毫无目的地通过网络拉取一些很大的值。此时，把BLOB或TEXT值的散列标识符信息
如果所有列的长度固定，那么MyISAM存储引擎默认会使用固定长度的行，但如果任何一
避免检索很大的BLOB或TEXT值，除非迫不得已。
口对于带有长BLOB或TEXT值的表，DYNAMIC行格式最有效。
当创建InnoDB表时，请选择其特性与存储在表中的数据完美匹配的行存储格式。
对于有许
由于 MEMORY表使用的是固定长度的行，而且其中的CHAR 和VARCHAR列都被隐式地当
口对于变长行，由于各行的大小不一，因此当执行过多的删除或更新操作时，会产生更
有些存储引擎实现了多种存储格式，其中每一种都有其自己的性能特性。
合成散列索引对 BLOB 和 TEXT 列非常有用。与直接搜索 BLOB 或TEXT 列自身相比，把散
口
没有用。
间，远远超过解压它所需的CPU时间。压缩格式对于存储随机值或已压缩过的值的表
的空间更少（从而减少了读取它的那些I/O操作的数量），而节省下来的读取数据的时
对于包含重复数据的表，使用COMPRESSED 行格式，能带来更多的好处。这种表占用
默认情况下，InnoDB会使用COMPACT行格式。这种选择适合于大部分的情形。
题与查询处理的性能无关，但是它可以加速表的修复过程。
置都是确定的，因为它们都是行大小的倍数，而对于变长行，情况则有所不同。这个问
当表崩溃时，具有固定长度行的表更易于重建。对于固定长度的行，每一行的开始位
一点不是问题。
多的碎片。为维护好性能，你需要定期运行OPTIMIZETABLE。对于固定长度的行，这
选择利于高效查询的表存储格式
第5章
许多NULL值的列，使用VARCHAR的优势会更加明显。
查询优化
。例如，只有在确定WHERE子句所限制的
下列建议为选择
用
---
## Page 237
INSERT语句；此外，还会启用一些其他选项，使得在重新加载转储文件时，能更高效地处理转
语句：启用--opt（优化）选项，此选项会打开--extended-insert 选项，产生可插入多行的
务器在处理多行插入语句时，需要的索引刷新次数会更少。
INSERT 语句相比，使用单条可插入多个行的INSERT语句，总体上花费的时间会更短，而且服
原则看上去与之存在矛盾。但实际上并不矛盾。这里强调的是：与使用一组等效的插入单行的
少索引刷新的次数。
慢
DATA LOCAL,
到服务器上，并且必须要有FILE权限，这时，服务器可以直接从磁盘读取这个文件。对于LOAD
才会需要刷新，而
能解析和解释一条
以得出几个有关如何快速加载数据的实用结论。
所述。
据库则较为简单。尽管如此，还是有许多策略可用于提高数据加载的效率。这些基本原则如下
查询语句，并且想要弄明白如何优化它们并不总是件简单的事情。相比之下，将数据加载到数
5.5
小节。
innodb_file_per_table 和 innodb_file_format。更多相关信息请参考 12.5.3.1 节的第 4
使用ALTER TABLE：
如果使用mysqldump程序来生成数据库备份文件,那么它会默认生成可插入多行的INSERT
一些。
LOADDATA在不带LOCAL的情况下效率会更高。如果不带LOCAL，那么数据文件必须加载
LOAD DATA（包括各种形式）的效率比INSERT 的高，因为它是批量加载行。服务器一次只
在这种语句里，指定的行越多，效果越好。这样可以减少总的所需要语句数量，并大大减
如果必须使用INSERT，那么请尝试使用那种允许在单条语句里插入多个行的格式：
那么即使很小的效率影响因素也会造成很大的影响。依据这里讨论的一般性原则，我们可
在大部分时间里，你最关心的问题很可能是对SELECT语句的优化，因为它们是最常用的
口把数据从缓存刷新到磁盘的次数越少，那么数据加载的速度就越快。因此，批量加载
行格式 COMPRESSED 和 DYNAMIC 需要 Barracuda文件格式，而它又要求正确设置系统变量
INSERT INTO tbl_name VALUES(...),(...),...
在上面这几个因素中，有的看上去微不足道（尤其是最后一个)。但是如果加载的数据量很
ALTER TABLE t1 ROW_FORMAT=DYNAMIC;
口
想要检查已有表的行存储格式，可以使用 SHOW TABLE STATUS。想要更改表的格式，可以
CREATE TABLE t1（...）ENGINE=InnoDB ROW_FORMAT=COMPRESSED;
想要为新的 InnoDB表指定行格式，可以使用ROW_FORMAT表选项。例如：
口
作会更少，并且它们可以更加快速地通过网络从客户端发送到服务器。
与长SQL语句相比，短语句的数据加载速度更快。这是因为它们在服务器上的解析操
要的引索，或者，如果这些索引已存在，请删除它们。
里，而且要修改每个索引，这样才能反映出有新的行加人。因此，请不要创建毫无必
表的索引越少，
刷新到磁盘。与逐行刷新到磁盘相比，在加载结束时一次性刷新，能够显著地减少磁
的效率比单行加载的效率更高，因为插入的行可以先缓存，然后在加载操作结束时再
高效加载数据
盘IO操作。
客户端程序会先读取文件，然后通过网络将它发送到服务器。因此，这种方式会
而不是在每个行处理完之后，便立即去刷新。
一条语句，而不会同时处理几条语句。另外，只有在所有行都处理完之后，索引
与前面讨论过的那条原则（即短语句处理起来比长语句更快）相比，这条
加载速度越快。如果有多个索引，那么不仅要把行的内容添加到表
5.5高效加载数据
217
---
## Page 238
会更快。
的表，
MyISAM表的索引刷新，不管它们在主服务器上是如何创建的。
值的丢失。这并不是一个致命问题，因为MyISAM表的索引可以根据其数据行进行修复。为
迟到执行FLUSHTABLES 语句为止，或者延迟到表被关闭为止。
锁定时，才会出现第二种情况。
无论哪种情况，你都能获得同样的好处：只有在所有语句都执行完以后，MySQL才会刷新一次
对于不支持事务的存储引擎，可以先占用对表的写入锁，然后在表被锁定时，执行INSERT
因
值
客
要
包
确
索
先
使
索
来执行：
支持事务的存储引擎，则可以在单个事务里执行这些INSERT 语句，而不要以自动提交的方式
语句将是针对单行的，与可插入多行的语句相比，它们更长，且需要执行更多的解析处理。
储文件。
218
对于MyISAM表，如果你需要将大量的数据加载到某个新表里，那么可以先创建不带索引
因为这些语句包含的值较少，所以服务器执行解析和值转换的操作也会较少。
客户端程序，都可以使用--compress 命令行选项来指定。通常情况下，这种做法只适合用在
自动修复它们。
含FORCE选项的值。这个选项会强制服务器在打开MyISAM表时对它们进行检查，并根据需
角保真的进行修复，在启动服务器时，可以把myisam_recover_options系统变量设置成某
引块写入操作，延迟到为了给其他索引值腾出空间而必须把存储块刷新到磁盘为止，或者
用这个选项，行便可以像往常一样被立刻写入数据文件，但键缓存只有在必要时才会刷新一
引；而不是在每个INSERT语句执行完之后都刷新一次。当在自动提交模式下，或者表未被
对于复制机制中的从服务器，你可能会把 delay_key_write 设置成 ALL，以延迟所有
对于MyISAM表，减少索引刷新次数的另一种策略是，使用DELAY_KEY_WRITE表选项。
如果必须使用多条INSERT 语句，则请尽可能把它们分组，以减少刷新索引的次数。对于
如果要删除和重建索引，可以使用 DROP INDEX 和 CREATE INDEX 语句，或者使用 ALTER
要避免在 mysqldump 程序里使用--complete-insert 选项。否则，最终生成的 INSERT
平均起来看，你的语句会更短一些，从而可以减少通过网络发往服务器的字符数。此外，
让MySQL插入默认值。也就是说，不在INSERT语句里指定各个列，让其随意分配为默认
使用压缩的客户端/服务器协议，可以减少通过网络传送的数据量。对于大部分的MySQL
而不是每次插入之后都会立刻刷新。为了在服务器范围的基础上使用延迟索引刷新，可以
速率较低的网络上，因为压缩过程会占用一部分处理器的时间。
UNLOCK
INSERT
INSERT
LOCKTABLES
COMMIT;
INSERT INTO
INSERT
STARTTRANSACTION;
然后再创建索引。一次性创建全部的索引要比逐行修改它们更快一些。对于已带有索引
第5章查询优化
TABLES;
INTOtbl_name
INTO
INTO
INTO
tbl_name
tbl_name
tbl_name
tbl_name WRITE;
tbl_name
tbl_name
...
延
个
---
## Page 239
读取操作。
获得锁定，而在不需要时，解除它们。所需的锁定类型取决于客户端执行的是写入操作，还是
语句可以显式地获得和解除锁定。但在通常情况下，服务器的锁定管理器都可以在需要时自动
因此，就竞争管理而言，它们具有完全不同的性能特征。只要客户端访问表，就必须要先锁定
锁定行。在许多情况下，如只读的操作完成之时，InnoDB 根本不使用锁定操作。
的客户端定义为写入者。
SELECT)的客户端定义为读取者，把修改表(操作语句为 DELETE、INSERT、REPLACE 或UPDATE)
一种存储引擎比其他引擎更适合用于处理它。为了方便讨论，我们把负责检索（操作语句为
存储引擎时，可以参考一下本节的信息。对于给定应用里处于主导地位的查询类型，可能会有
存储引擎锁定层在多个客户端之间的并发性方面所具有的常规影响。当需要针对具体应用选择
5.6
库。此时，确定哪些条目需要立即进入主表，可能就不是一件需要优先考虑的事情。
的速度更快。
从辅助表里把行批量加载到主表，总体来讲，会比单独加载各行更省时，因为大批量加载操作
这种方法。但是，如果你能保证在较短时间内不去访问它们，那么使用辅助表会有两个好处。
助表里，然尺
长时间运行 SELECT 查询。
型操作的多个客户端程
不做任何特殊处理只是
行仔细评估，看看
这种做法并不适用于主（集群）索引，因此请不要删除和添加那个索引。
执行索引关闭和激活。另外，mysqldump 默认也会添加 ALTER TABLE语句。
DISABLEKEYS和 ENABLE KEYS形式，它们可以分别打开和关闭表的非唯一性索引：
TABLE语句与索引有关的形式。如果要关闭索引或重新激活它，那么可以使用ALTER TABLE 的
首
分
存储引擎MyISAM、MERGE和MEMORY，实现锁定操作的层级有所不同，使用了表锁定。
先，可以减少发生在主表上的多条SELECT查询语句之间的竞争，让它们执行得更快。其次，
的写人动作都是INSERT
前面所讨论的那些数据加载原则，也适用于混合查询环境：其中涉及需要执行多种不同类
如果你正在考虑使
对于 InnoDB表，
口为把数据写入表，客户端必须具有对表进行互斥访问的锁定。在写入操作处理的过程
前面几节的重点是如何加快单个查询的速度。本节将深入了解MySQL的调度策略，以及
InnoDB 存储引擎利用行级的锁定操作，实现这种调度策略，但 InnoDB 只有在必要时才会
MySQL的调度策略总结如下
此策略的一种应用场景是：你想要把Web页面的访问记录从Web服务器写入MySQL数据
如果使用LOAD DATA语句来把数据加载到一个空白的MyISAM表里，那么服务器会自动
口可以同时处理多个对同一个表的读取操作。
ALTER TABLE tbl_name DISABLE KEYS;
口
调度、
表的写入操作一次只能进行一个，
写入的优先级比读取的高。
TABLEtbl
后再将这些行定期地添加到主表。如果你需要能够立即访问新行，那么就不能使月
条用于加载表内容的语句
锁定和并发
看是否
程序。
是加载数据相比，重建索引可能会花费更长的时间。
否能从中获得某些好处。如果只是加载少量的数据到某个大表里，那么与
使用这种删除或关闭索引的策略来把数据加载到表，那么请对总体情况进
，删除和添加附表的速度很快，因此在加载大量数据之前可以考虑这样做。
name
T操作，那么这个问题也许能这样解决：先把各个新行添加到一个辅
。例如，你通常会希望尽量避免对那些经常会变化（即写入）的表，
因为那样做会造成多个写入者之间的竞争，会降低性能。如果大部
，多个写入请求按其到达的先后顺序依次处理。
5.6调度、锁定和并发
219
用
---
## Page 240
需要的锁定。这就会导致死锁，并且只有服务器中止其中一个事务才能解决此问题。
占用的锁定被解除。结果，每一个客户端都在它能继续下一步操作之前，占据着其他客户端月
事实上，在事务处理过程中，只有在必要时才需要获得锁定。因此，有可能出现这种情况，即
表，可能会出现死锁问题，因为在事务开始的时候，该存储引擎还没有获得所有必要的锁定。
问题。服务器可以通过查看语句来确定需要哪些表，并提前把它们全部都锁定。对于InnoDB
查询语句混合情况。
分，那么可以让更多的客户端同时使用这个表。实际的影响是：不同的存储引擎适合于不同的
成为止。
引擎会为第一个客户端获得表锁定，从而导致第二个客户端阻塞，一直到第一个客户端操作完
客户端不会同时更新同一行，那么两个更新操作就可以同时处理。对于MyISAM表，其存储
此时，InnoDB表的并发性明显要比MyISAM表的并发性好很多。对于InnoDB表，只要两
们各自都想要在给定的表里更新某行。为完成这个更新，每个客户端都会需要一个写入锁定。
220
就死锁防止而言，表锁定能比更精细的锁定带来更多的好处。使用表锁定，不会出现死锁
一般情况下，更精细的锁定会有更好的并发性，因为如果各个客户端使用的是表的不同部
口MyISAM表的检索速度极快。但是，在有多个检索和更改操作混杂在一起的环境里，
口
存储引擎使用的锁定级别，对客户端之间的并发性有显著的影响。假设有两个客户端，
口
更新操作可能需要等待很长时间才能得到处理。
特别是当检索需要运行较长时间时，