LLVM IR. We construct the call graph in an on-demand manner. We
compile each source code ﬁle separately into LLVM IR and traverse
from the ﬁrst function on the recovered stack trace to the crash point.
Whenever a function is directly called, we include that function and
expand the call graph. If that function is in a different IR ﬁle, we
search for it in other compile units by its name and linkage type.
With the call graph and the intra-procedure CFG natively provided
by LLVM, we essentially have the inter-procedure CFG.
To the CFG, we apply LLVM’s built-in basic alias analysis to
get intra-procedure point-to results. To ensure the soundness of
the analysis, our implementation takes may-alias relation as
must-alias relation. Though the conservativeness theoretically
limits the analysis capability of CREDAL, our case studies in Sec-
tion 6 demonstrate that this implementation can work well in prac-
tice. LLVM also provides intra-procedural reaching deﬁnition re-
sults through its use-def chain data structures. With these two
pieces of information, we further implemented a simple summary-
based inter-procedural analysis as described in Section 4.
As is discussed in Section 4, CREDAL examines variables in
LLVM IR, the values of which are preserved in the core dump. Our
implementation utilizes debugging information in the IR to achieve
mapping between source code variables and LLVM IR variables
and we again leverages debugging information in the binary to
compute the locations of source code variables in the core dump. We
highlight the code segment for data dependency mismatch in LLVM
IR, which is also mapped to source code segment via debugging
information in the IR ﬁle. Source code of CREDAL is available at
https://github.com/junxzm1990/credal.git.
6. CASE STUDY
In this section, we demonstrate the utility of CREDAL using the
crashes attributable to memory corruption vulnerabilities. In par-
ticular, we describe the collection of crashes and present the ef-
fectiveness of CREDAL. We also discuss those memory corruption
vulnerabilities, the crashes of which CREDAL fails to handle.
Constraints: {a@foo = 1; d@foo = [valid]; aa@crash = 1; bb@crash = aa@crash+5}bar1_entryfoo()foo_entrycrash_entryaa = 1;sub()sub_entrybar()bar_entrybb = aa + 5;  ...func()foo2()foo2_entry...return 1crash_exitreturn 1;b = 2; c = &b; d = &b;  *d = 5;  local_func = &foo1;  glob = 0;glob_func(c)a=1;scanf("%s", buf)scanf bodycrash(local_func)foo_exitbar1_exitbar2_exit...sub_exit...bar_exit...foo2_exitbar2_entryfoo()535ProgramProgram Size (LOC)CVE-IDVulnerability TypeEDB-IDEIP# of FrameFull StackArea (LOC)Root Cause# of Functiontack 1.0.720979NABSS/Data Overﬂow38685√2√27√1picpuz 2.1.16345NABSS/Data Overﬂow10634√2√25√22Fax 32664NABSS/Data Overﬂow24984√4√NANANAytree 1.9414010NABSS/Data Overﬂow39406√5√NANANAnullhttpd 0.5.01849NAHeap Overﬂow218181√6X15√1make 3.8.124151NAHeap Overﬂow34164√1X12√1xrdp 0.4.1339952008-5904Heap Overﬂow8469√14X224√3libsndﬁle 1.0.25510642015-7805Heap Overﬂow38447√26√280√3ntpd 4.2.6152433NAHeap Overﬂow39445X4√33X7php 5.3.6 8056402012-2386Heap Overﬂow17201√10√NANANAinetutils 1.898941NAHeap Overﬂow15705√3√NANANAnginx 1.4.01002552013-2028Integer Overﬂow25775√1X36X30verkill 0.16163612006-2971Integer Overﬂow1894√5√4X1php 5.165618202007-1001Integer Overﬂow29823√14√46√3ImageMagick 6.2.02148002006-4144Internet Overﬂow28283√5√110√2php 4.4.43672952007-1777Integer Overﬂow29788√6√NANANApython 2.24160602007-4965Integer Overﬂow30592√11√NANANAClamAV 0.88.2421602006-4182Integer Overﬂow2587√1XNANANAmcrypt 2.5.8103632012-4409Stack Overﬂow22938√1X2√1putty 0.66901652016-2563Stack Overﬂow39551√1X3√1php 5.3.48034862011-1938Stack Overﬂow17318√1X43√1rsync 2.5.7194872004-2093Stack Overﬂow152X1X27√1corehttp 0.5.3a9352007-4060Stack Overﬂow4243√2X6√1aireplay-ng 1.2-beta3626562014-8322Stack Overﬂow35018X1X124√1No-IP DUC 2.19-12578NAStack Overﬂow25411X1X87√1opendchub 0.8.1110212010-1147Stack Overﬂow11986X1X22√1unrar 3.9.317575NAStack Overﬂow17611X1X2X2peercast 0.1214171932006-1148Stack Overﬂow1574X1X52X13peercast 0.1214171932006-1148Stack Overﬂow1578X1X52X13peercast 0.1214171932006-1148Stack Overﬂow16855X1X52X13peercast 0.1214171932007-6454Stack Overﬂow30894√9√261√6ettercap 0.7.5.1531752013-0722Stack Overﬂow23945√2X32√1prozilla 1.3.6130702004-1120Stack Overﬂow652√2X17√2prozilla 1.3.6130702004-1120Stack Overﬂow1238X1X35√1sftp 1.1.01559NAStack Overﬂow9264√6√102X27fbzx 2.5.015341NAStack Overﬂow38681√5√144√5Conquest 8.21057842007-1371Stack Overﬂow29717√1X54√1 tiffsplit 3.8.2477692006-2656Stack Overﬂow1831√2√21√2alsaplayer 0.99.76268342007-5301Stack Overﬂow5424√3√13X6xmp 2.5.1454042007-6731Stack Overﬂow30942X1X4√1proftpd 1.3.0a 1118392006-6563Stack Overﬂow3730X1X79√1proftpd 1.3.0a 1118392006-6563Stack Overﬂow2928X1X79√1proftpd 1.3.0a 1118392006-6563Stack Overﬂow3330X1X79√1proftpd 1.3.0a 1118392006-6563Stack Overﬂow3333X1X79√1vfu 4.1 18734NAStack Overﬂow35450√3X85√1LibSMI 0.4.8 804612010-2891Stack Overﬂow15293√3X23√2FENIX 0.9225236NAStack Overﬂow37987√3√1√1gif2png 2.5.213312009-5018Stack Overﬂow34356√1√7√1hexchat 2.10.0681812016-2233Stack Overﬂow39657√1X80√1Binutils 2.156973542006-2362Stack Overﬂow27856√4X44√3alsaplayer 0.99.76268342007-5301Stack Overﬂow5424√3X13X6glibc 2.12.908433482015-7547Stack Overﬂow39454√4X230X4gas 2.125955042005-4807Stack Overﬂow28397√1X4√1nasm 0.98.38335532004-1287Stack Overﬂow25005X1X12√1ringtonetools 2.2265072004-1292Stack Overﬂow25015√2X6√1abc2mtex 1.6.14052NAStack Overﬂow25018√1X7√1JPegToAvi 1.5580NAStack Overﬂow24981√3X17√3536Table 1: The list of the program crashes corresponding to memory corruption vulnerabilities. CVE-ID and EDB-ID specify the IDs of the CVE and corresponding
PoC, respectively. EIP indicates the validity of the program counter at the crash. # of Frame and # of Functions describe the number of stack frames CREDAL
identiﬁes as well as the number of functions one needs to examine when locating the corresponding vulnerability. The numbers in Area (LOC) indicate the lines
of code corresponding to data dependency mismatch.
6.1 Setup
To demonstrate the utility of CREDAL, we must collect program
crashes contributed by memory corruption vulnerabilities. We ex-
haustively searched memory corruption vulnerabilities on Offensive
Security Exploit Database Archive [14]. Our goal is to gather the
crashes by exploiting memory corruption vulnerabilities with corre-
sponding PoCs.
As an outdated vulnerability typically associates with an obsolete
program, and such a program may be no longer available, we only
gathered memory corruption vulnerabilities archived over the past
twelve years. Because we implement CREDAL for Linux operating
system, we further narrowed down our searches on the vulnerabili-
ties identiﬁed on software running on Linux. In total, we obtained
392 memory corruption vulnerabilities bundled with at least one
PoC. We compiled and conﬁgured vulnerable programs based on the
description of the collected vulnerabilities, and successfully produce
80 crashes using the PoCs corresponding to 73 vulnerabilities. The
experiments are conducted on a machine with Intel Xeon E5-2560
2.30GHz and 2GB memory running Ubuntu 14.04. The average
time to analyze a core dump is 0.21 seconds.
Table 1 lists the aforementioned crashes and summarizes the
corresponding vulnerabilities across 5 different categories, including
use-after-free as well as overﬂow on stack, heap, integer and bss/data.
These vulnerabilities are identiﬁed on 62 distinct software, ranging
from sophisticated programs like PHP and Binutils with lines
of code over 670K to lightweight programs such as o3read and
corehttp with lines of code less than one thousand.
Note that we discard a large fraction of vulnerabilities for three
reasons. First, the program corresponding to a vulnerability is obso-
lete and we cannot ﬁnd its source code for showcasing the utility of
CREDAL (e.g., Gaim [7] and Abc2midi [1]). Second, compiling
a vulnerable program requires an obsolete external library that we
cannot discover (e.g., Asterisk [4] and Blender [5]). Third, a
vulnerable program is close-source (e.g., Apple Quicktime [3],
Sun Java Runtime Environment [16] and Safari [15]).
6.2 Results
To demonstrate the utility of CREDAL, we manually analyze the
crashes shown in Table 1, and compare our manual analysis with that
of CREDAL. More speciﬁcally, we evaluate the utility of CREDAL
as follow. First, we verify if CREDAL can restore a program counter
and correctly identify the crash point when that is overwritten and
set to an invalid value. Second, we examine if CREDAL can unwind
a crashing stack and pinpoint a full (or partial) stack trace in an
accurate manner. Last but not least, we investigate how effective
CREDAL can enclose a memory corruption vulnerability within the
functions and code fragment that it highlights.
6.2.1 Pinpointing Crash Point & Stack Trace
Table 1 speciﬁes the validity of a program counter at the time of
the crash. We observe 21 crashes for which the core dumps carry
a program counter with an invalid value. Among these crashes,
CREDAL is able to restore program counters for 20 crashes, and the
program counters recovered all point to crash points correctly.
O3read 0.039322004-1288Stack Overﬂow25010√5√7X2LateX2tf 1.9.15144732004-2167Stack Overﬂow24622√2X1√1libpng 1.2.5336812004-0597Stack Overﬂow389√1X1X2unrtf 0.19.35039NAStack Overﬂow25030√7√7√1Sox 12.17.4257362004-0557Stack Overﬂow369√4√83√1Sox 12.17.4257362004-0557Stack Overﬂow374√1X1X2psutils-p171736NAStack Overﬂow890√2X1√2streamripper 1.61.25273042006-3124Stack Overﬂow2274√3X7X3Newspost 2.148652005-0101Stack Overﬂow25077√3√7X16Unalz 0.5285462005-3862Stack Overﬂow26601√1X1√1proftpd 1.3.0a 722332006-5816Stack Overﬂow2856√1X36√1proftpd 1.3.3a1118392010-4221Stack Overﬂow16878√1XNANANAht-editor 2.0.18119236NAStack Overﬂow17083X1XNANANA0verkill 0.16163612004-0238Stack Overﬂow23634X1XNANANAht-editor 2.0.20119688NAStack Overﬂow22683X1XNANANAcoreutils 8.41381352013-0221Stack Overﬂow38232√5XNANANAvfu 4.118734NAStack Overﬂow36229X3XNANANAmutt 1.4.2.2619132007-2683Stack Overﬂow30093√1XNANANAfontforge 201005015510832010-4259Stack Overﬂow15732√1XNANANAcompface 1.5.215742009-2286Stack Overﬂow8982X0XNANANAopenlitespeed 1.3.1997241NAUse After Free37051√15√26√1lighttpd 1.4.15381022007-3947Use After Free30322√6√456X28python 2.7 1009752009-2286Use After Free100975√16√NANANAProgramProgram Size (LOC)CVE-IDVulnerability TypeEDB-IDEIP# of FrameFull StackArea (LOC)Root Cause# of Function537Table 1 also indicates the quantity of the stack frames that CREDAL
identiﬁes. We discovered that CREDAL can fully (or partially) un-
wind a crashing stack when a crash point is successfully pinpointed.
The reason is that the crash point reveals the crash function in a
binary, and even in the worst case, CREDAL can leverage debugging
information to identify the stack frame of the crash function.
We examined the crash for which CREDAL fails to restore the pro-
gram counter, particularly the crash of vulnerable program compface
1.5.2. In the actual crash function, we observed that the function
employs setjmp() to save its calling environment before transfer-
ring its execution to a subroutine. The subroutine contains a stack
overﬂow vulnerability. When exploited, it overﬂows the current
stack frame as well as those at the higher memory address. The over-
ﬂow does not block the program execution immediately. Instead,
the subroutine invokes longjmp() which transfers its execution
to a predetermined location in the crash function. In this case, the
instruction at the predetermined location causes an unexpected crash
because of the data corruption on the stack.
Performing analysis for this crash, CREDAL can only discover the
stack frame of longjmp() from the remnants in the core dump.
Recall that CREDAL identiﬁes a crash point using the function that
was just called but silently returned before the crash. In this case, the
execution of the crash function is not returned from its child function
but a descendant function – longjmp(). As such, the displace-
ment veriﬁcation of a stack pointer fails and CREDAL conservatively
produces no information about the crash point.
6.2.2 Locating Vulnerability
In Table 1, we also show the lines of code that CREDAL high-
lights corresponding to data dependency mismatch. For 63 crashes,
CREDAL successfully identiﬁes dependency mismatch in memory.
Among these crashes, we observe 47 crashes for which CREDAL
can enclose the memory corruption vulnerability (i.e., root cause)
within the code fragment highlighted. As is shown in Table 1, a code
fragment highlighted typically covers the statements with only tens
of lines (in about 90% cases). This indicates CREDAL has a high
potential to reduce manual efforts for locating a memory corruption
vulnerability in a crash.
Within the batch of the crashes shown in Table 1, there are 16
crashes for which CREDAL identiﬁes dependency mismatch but not
encloses the root cause within the code fragment highlighted. For
these crashes, we manually examined the code fragment highlighted
and the function calls it encloses by imitating the way a security
analyst locates a vulnerability. In particular, we started from the code
fragment and traversed the enclosed calls in a breadth-ﬁrst manner.
Except for integer overﬂow in nginx 1.4.0 and overkill
0.1.6, we successfully identiﬁed all vulnerabilities in the enclosed
function calls. Table 1 speciﬁes the number of functions that we
walked through when locating a vulnerability. We observe the
numbers of the functions we looked into are relatively small, with
an average of 3.46. Again, this indicates CREDAL is potentially
effective in locating memory corruption vulnerabilities.
In general, overﬂowing an integer variable does not directly cor-
rupt data in the function where it is enclosed. Rather, it indirectly
incurs a buffer overﬂow and data corruption in a descendant func-
tion. For the aforementioned integer overﬂow, we therefore dis-
covered the overﬂow vulnerabilities lie outside the code fragment
that CREDAL highlights. However, this does not mean CREDAL is
less effective in helping security analysts locate integer overﬂow
vulnerabilities. Considering CREDAL typically encloses overﬂowed
buffers in the code fragment, we therefore believe a security analyst
can quickly track down integer overﬂow using the linkage between
the overﬂowed integer variable and the overﬂowed buffer.
Last but not least, we also manually examined the remaining
crashes for which CREDAL fails to identify data dependency mis-
match. Except for the one that CREDAL fails to restore the program
counter, Table 1 speciﬁes 17 crashes in this category. For 9 of
them, the failure of CREDAL results from the conservative design
of identifying data dependency mismatch.
For 6 of the crashes, the failure of CREDAL can be attributed
to one of the following. First, data corruption occurs in the stack
area that CREDAL cannot unwind (e.g., ht-editor 2.0.18 &
2.0.20). Second, the corrupted data was sited in local variables
that were overwritten by variable assignment operations in consecu-
tive execution (e.g., proftpd 1.3.3 a and vfu 4.1). Third,
data corruption occurs at a certain memory area in which the cor-
rupted data has not yet been initialized before the crash (e.g., 2Fax
3 and ytree 1.94).
For the remaining 2 crashes that CREDAL fails to ﬁnd dependency
mismatch, the overﬂow corresponding to the crashes represents two
special cases. In one case, a PoC exploits vulnerable program mutt
1.4.2.2 and underﬂows the data on stack. At the crash, the pro-
gram counter points to a call to memmove(). As CREDAL lacks
sufﬁcient information to unwind the stack at the higher frame level,
and function memmove() does not carry local variables, CREDAL
produces no dependency constraint and thus provides less infor-
mation for locating the overﬂow vulnerability.
In another case
corresponding to clamv 0.88.2, CREDAL fails to identify data
corruption simply because the crash occurs in advance of data cor-
ruption. More speciﬁcally, the exploit attempts to overﬂow a buffer
by copying a large data chunk from an invalid memory address.
7. RELATED WORK
This research work mainly focuses on analyzing program crashes.
Thus, the line of work most closely related to our own is crash
analysis, in which program instrumentation, program analysis and
core dump forensics are typically used to track down a particular
fault resided in a program. In this section, we summarize previous
studies and discuss their limitation in turn.
Program instrumentation To spot program faults, a large amount
of research focuses on failure reproduction using execution traces
(e.g., [23, 31, 32, 35, 44, 45]). Technically speaking, the typical
approach along this line is to instrument a program, so that it can
automatically generate execution traces at run time. By analyzing
these execution traces, one can derive control and data ﬂow and thus
identify the faults in software. Since this run-time recording scheme
provides more information about program execution, it is effective
in locating program faults.
Many other works instead instrument programs to spot mem-
ory corruptions at run-time, such as AddressSanitizer [39], Soft-
Bound [29], and Code-Pointer Integrity [25]. AddressSanitizer uses
shadow memory to record whether a memory access is safe, and
relies on instrumentation to verify the shadow memory in load
or store; SoftBound inserts run-time bounds checks to enforce
spatial safety using customized disjoint memory metadata; Code-
Pointer Integrity would detect when a code pointer is overwritten
and terminate the execution. With Code-Pointer Integrity, a core
dump will be generated before any illegal control ﬂow transfer
and thus, involves less uncertainty for analysis by CREDAL. These
techniques aim at detecting corruptions instead of pinpointing the
vulnerability areas.
In practice, many of these approaches introduce high overhead
during normal operation, which greatly affects their deployment.
Considering practicality, our work does not instrument programs,
nor rely upon the availability of existing program logging or exe-
538cution traces. Rather, our technical approach facilitates program
failure diagnosis by using more generic information, i.e. the core
dump that operating system automatically captures every time a
process has crashed or otherwise terminated abnormally.
Program analysis Over the past decades, there is a rich collection
of literature on using program analysis techniques along with crash
reports to identify faults in software (e.g., [17, 22, 27, 28, 34, 36,
41, 46]). These existing techniques are designed to identify some
speciﬁc software defects. In adversarial settings, an attacker exploits
a variety of software defects and thus they cannot be used to analyze
a program crash caused by a security defect such as buffer overﬂow
or unsafe dangling pointer. For example, Manevich et al. [27] pro-
posed to use static backward analysis to reconstruct execution traces
from a crash point and thus spot software defects, particularly types-
tate errors [42]. Similarly, Strom and Yellin [41] deﬁned a partially
path-sensitive backward dataﬂow analysis for checking typestate
properties, speciﬁcally uninitialized variables. While demonstrated
to be effective, these two studies only focus on speciﬁc typestate
problems.
Liblit et al.also proposed a backward analysis technique for crash
analysis [26]. In particular, they introduce an efﬁcient algorithm that
takes as input a crash point as well as a global control ﬂow graph, and
computes all the possible execution paths that lead to the crash point.
In addition, they discussed how to narrow down the set of possible
execution paths using a wide variety of post-crash artifacts, such as