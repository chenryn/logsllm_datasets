within eps ([a:b:rest])=if abs (a-b) [Double]—>Double。
不是每个人都能习惯将多参数函数替换为返回函数的函数（就像医
学文献中所说的“疯狂的嵌套综合症（RCS）”那样，也就是在那篇
关于金融契约的文章中所使用的诸如（a→b→c）→Obsa→Obs
b→Obsc之类的函数签名）。
1236
---
## Page 1238
不过，保持表示法的简洁在设计和架构层面上也是一种美德，而函
数式编程语言也有一些关于其他设计表示法的经验教训。
第二个优点（SimonPeytonJones和DiomidisSpinellis在对本章的早期
版本提建议时强调了这一点）也与表示法有关，即定义对象的组合
子表达式（combinatorexpression）的优雅性。在强制的面向对象语
言中，与下面的组合表达式：
on_top_of topping main_part
对应的应该是一条创建指令：
create pudding.make_top (topping,main_part)
并带有一个创建过程（构造方法）make_top，通过指定的参数来初
始化base和top属性。组合子的形式是描述式的，而不是强制式的。
但在实践中，在面向对象编程中使用组合子的变种，利用“工厂方
法"而不是显式地创建指令，是很容易也是很常见的。另外两个优
点则更为基础。第一个是能够让操作成为“一等公民”，这是一个很
常用的说法，就像我们说“程序中的对象"或者“数据"是Lisp语言中
的“一等公民”，也就是它是最能够被高效处理的部分。许多主流的
语言都能够支持将一个例程作为另一个例程的参数，但这不能够被
视为基础性的设计技术，而且实际上经常被视为自修改代码所带来
的各种不确定性的根源。现代的函数式语言都将高级的函数视为常
规的程序对象，并并发了相关的类型系统，以体现其强大。这也是
函数式编程的一部分，它在采用主流编程方法的并发过程中展现了
直接的效果；正如我们稍后将看到的那样，与代理相关的表示法是
直接从这些函数式编程概念中派生的，这是在面向对象框架中很受
欢迎的新机制。
函数式编程的第四个主要的优点是延迟计算（lazyevaluation）：它
都将是有限的。早先对within的定义就假定采用了延迟计算：这在
repeat的定义中则更加清晰（在此使用的是Haskell的list表示法，而
非Hughes原先采用的cons）：
1237
---
## Page 1239
[（（ ) ]=d
谁负责处理（在普通的函数式应用程序表示法中）无限序列
a,f（a），f（f（a））......（nextNx的定义为（x+N/x）/2）呢，
within的定义将会在处理了有限个元素之后，停正对该序列的处
理。这是一个很不错的想法。它在软件设计中的通用应用程序会带
来两个观测结论。
首先，这里存在正确性问题。这种可能出现无限循环的程序虽然容
易编写，但它掩盖了确保其不会永远无法终止的困难。我们看到
within中假定了一个前置条件，虽然没有直接描述出来，但该前置
条件要求使该元素的值小于eps，在无限序列（它是半可判定的）上
是无法执行有限计算的。这对于设计师而言是一种比较麻烦的技
术，这也是为什么许多采用函数式编程方法的程序员想寻找新的
“明灯"的原因。（这是很难预先知道的。当有任何采用函数式编程
方法的程序员改变时，就可能尝试换一盏“灯”，如果失败了，则还
会尝试另一盏。）
第二个也是最后一个问题，可能会在非函数式的设计环境中对无限
结构采用延迟计算，不需要任何特殊的语言支持。而抽象数据类型
方法（也就是众所周知的面向对象设计）则提供了合适的解决方
案。在Eiffel程序库中，有限序列和列表都可以通过API来访问，这
种访问是基于"光标（cursor）”这一表示法的。
Before
After
1
index
uno
item
+
Forth
Start
光标
Finish
图13-2：Eiffel列表中的光标
移动光标的命令包括start（移动到第一项）、forth（移动到下一
项）和finish。布尔型查询before和after用来确认当前光标是否在第
1238
---
## Page 1240
一个元素之前，或者在最后一个元素之后。如果不是以上两种情
况，那么item将返回当前光标位置的元素，而index将返回其索引
值。
我们很容易将这种方式移植到无限序列中：只要去除finish和after命
令即可（当然还有计算项目总数的count）。这也就是Eiffei程序库中
的派生（抽象）类COUNTABLE的规约。它的派生类包括PRIMES、
FIBONACCI和RANDOM；这些派生类都提供了自己的start、forth和
item命令实现（在最后一个派生类中，还提供了plus方法，用来为随
机数生成器设置一个种子）。要获得这些无限序列中的后续元素，
可以先使用start命令，然后向前查询后续有限个元素即可。
任何无限序列结构都需要提供能够以该风格建模的有限计算。虽然
这并未覆盖各种延迟计算的应用场景，但它的优点在于使无限结构
更加清晰，也更易于构建正确的延迟计算。
13.3.5状态调停
函数式方法旨在直接依赖于数学函数的属性，而且拒绝采用假定：
并且隐含着命令式方法，其计算操作除了生成结果（数学函数常见
的功能）之外，还能够修改计算的状态：可能是修改全局状态，也
可能只是修改状态的一部分（在更模块化的方法中），例如某个特
定对象的内容。
尽管在各种函数式编程的文章中都强调了这一点，但该属性在本例
中却没有涉及，或许因为根据最初问题分析，已经将状态从函数式
的结构中去除了。这也是可能的，例如，在一个用来计算金融契约
的非函数模型表示法中，操作可能只是将状态转换为对值的更新，
而不是基于一个序列（值处理序列）实现的函数。
在任何系统模型（无论是否为计算机系统）中，状态的概念总是难
以避免的。甚至有观点认为它是计算的核心概念。（有人辩称
[PeytonJones2007]无状态编程有助于解决并发编程的一些问题，但
是还没有足够的证据能得出一般性结论。）世界不会因每次重要事
件而克隆自己我们的计算机内存也是这样，而只是覆盖其单元格而
已。我们总是可以对这样的状态改变进行建模，例如通过设置一个
值序列的方法，不过这些都是人造的（作为前一个疑问的备选回
答，采用函数式编程的程序员并没有换“灯泡”，而是买了一个带有
1239
---
## Page 1241
新插槽、新电缆、新灯泡的“灯”）。由于我们认识到作为这些操作
的输入和输出的状态是不可能忽略的，加上之前的一些笨拙的尝试
（PeytonJones和Wadler1993），因此在现代的函数式语言（特别是
Haskell1）中引入了monad的概念（Wadler1995），它可以将最初的
函数插入到高阶函数中，并且使用了更为复杂的签名；新添加的签
名部分可以用来记录状态信息，以及其他一些额外的元素，诸如错
误状态（用来对错误进行建模）或输入/输出结果。
使用monad整合状态处理的想法，与上一小节中通过将无限序列建
模为一个抽象数据类型来实现延迟计算行为所采用技术的想法是相
似的，只不过它是一种反向应用而已：在框架A中模拟一个框架B中
隐含的技术T，然后在A中编程实现一个T的显式版本，或者实现一
个实现T的关键机制。对于第一个示例而言，T就是无限列表（关键
机制就是对无限列表的有限计算）；对于第二个示例而言，T就是
状态。
对于编程语言的语义描述（例如，用来简化标记理论）而言，
monad的概念是十分漂亮和十分有用的。不过，有人可能不会关心
它是否是程序员直接使用的合适的解决方案。在此，我们必须关注
于正确的观点。monad也有明显的非直接相关的缺陷，那就是普通
的程序员很难学会它；创新的想法，很难在最初引入时就融入到主
流的教育体系中。（递归式编程和面向对象编程都曾经被视为超出
了“Joe程序员"的范畴。）其中最重要的问题是这个麻烦的方法是否
有价值。通过monad为函数式编程引入状态机制，就像在你确认大
家信奉贞洁之后，告诉你的追求者，你有孩子。
真是需要首先把状态排除在外？以下两个观测结论就足以引发这一
怀疑：
基本的状态改变操作，如简单的赋值操作，都有清晰的数据模型
（）
程所预期的主要好处：简化与程序相关的数学推理。
针对与确保设计或实现的正确性相关的更复杂方面而言，函数式方
法的优势并不清晰。例如，校验有特定的属性和终止条件的一个递
归定义（需要循环不变量和变量）。有效的函数式程序也未必能够
不使用链接的数据结构，尽管其导致的问题（如别名混淆）都是与
底层的编程模型无关的挑战。
1240
---
## Page 1242
如果对于确保程序正确这一任务而言，函数式编程未能显著简化，
那么就将遗留一个主要的实际问题：引用透明。这就是等价替代性
的概念：在数学领域中，f（a）始终意味着与指定的f和a相关的某
种事情。这在纯函数式方法中也是正确的。但在函数可能带有副作
用的编程语言中，f（a）在连续调用时可能会返回不同的结果。通
过保留语义推理的常用模式来消除这种可能性，会使程序文本更易
于理解；例如，我们都认为g+g和2xg具有相同的意义，但如果g是