independently of the
crawler’s coverage. Table VII details the distribution of attack
vectors per XS-Leak for each attack type and browser pair.
XS-Leak prevalence widely varies. Most attack vectors use
EventsFired, Object Properties, and CSPViolation XS-Leaks.
Our novel postMessage XS-Leak ranks sixth out of eight XS-
Leaks, producing attack vectors on 11 different sites including
blogger.com, ebay.com, reddit.com, and youtube.com. The
least prevalent XS-Leak is CSSPropRead for which Basta-
COSI does not ﬁnd any attack vector, showing that SD-URLs
on CSS content that leak user state are not common. The
comparison also shows that Chrome has a larger attack surface,
ranking ﬁrst in number of attack vectors in all eight XS-Leaks.
C. Example Attacks
This section details some of the attacks Basta-COSI found
that involve more than two states. All attacks work on the three
tested browsers, unless speciﬁcally noted.
HotCRP. Basta-COSI found an attack for determining whether
the victim is a reviewer of a speciﬁc paper, which we have used
as running example. The attack page (Listing 1) uses three
attack vectors, one for login detection on all three browsers,
and two (one for Chrome and another for Firefox/Edge)
to identify if the victim submitted a review for the target
paper. To launch the attack, the attacker collects the email
addresses of the program committee members and sends them
a spear-phishing email to convince them to click on the attack
page URL. Since the attack was found on a local HotCRP
installation, to test it on conferences hosted at hotcrp.com,
we had to update the SD-URLs with the proper domain and
conference name. We veriﬁed the attack and reported it to the
HotCRP developer, who conﬁrmed the issue and has released
a patch [10].
GitLab and GitHub. Attacks are found in both GitLab and
github.com that allow determining if the victim is the owner
of a repository (or of a snippet). Both attacks ﬁrst use a login
11
detection attack. If the victim is logged in, the attack page
uses an EventFire attack class using a SD-URL for editing
the repository settings (or the snippet) to detect if the victim
has administrative rights. For GitHub Enterprise installations,
another attack allows distinguishing the administrator from
other users by including the URL for accessing staff tools.
LinkedIn. A CSPViolation attack allows distinguishing the
account type (free or premium) using the SD-URL https:
//www.linkedin.com/cap/. This attack has already been ﬁxed
following our disclosure. A second attack allows determining
if the victim owns a speciﬁc LinkedIn proﬁle using the OP-
WindowProperties attack class. The underlying cause of this
attack is that the number of frames in a LinkedIn proﬁle page
is 3 when visited by the owner of the proﬁle, and 4 otherwise.
Blogger. Multiple deanonymization attacks are found for de-
termining if the victim is the owner of a speciﬁc blog. The
attacker needs to know the blogID of the target victim, which
can be found on the HTML source of the target blog. The
attacks combine a CSPViolation login detection attack vector
with another deanonymization attack vector from different
attack classes (e.g., postMessage, EF-CtMismatchScript). This
shows how attacks can combine multiple attack vectors using
different XS-Leaks, highlighting the value of our generic
approach not being speciﬁc to any XS-Leak.
IMDB. A deanonymization attack allows determining if the
victim owns a speciﬁc IMDB account using a SD-URL that
contains the user identiﬁer. This attack can determine if the
visitor is a speciﬁc person from the ﬁlm industry by including
the user identiﬁer obtained from the proﬁle for that person.
Amazon. CSPViolation attacks are found that
leak if the
victim is using the Amazon Kindle Direct Publishing (KDP)
service, or has accepted the KDP terms and policies. That
information could be used for targeted advertising, e.g., to
show advertisements of kindle books to the victim.
Pornhub. Attacks are found using the OP-Window-Properties
and OP-FrameCount for determining if the victim is the owner
of a speciﬁc username, thus enabling deanonymization of the
account in a closed-world setting. The underlying reason for
the OP-FrameCount attack is similar to that of the LinkedIn
attack, but mounted on Pornhub’s playlist URLs.
Pinterest. A CSPViolation attack can be mounted with the
Facebook SSO initiation URL for determining whether the
victim authenticated into Pinterest using its Facebook account.
A similar attack was found for Google’s SSO.
Imgur. An attack based on EF-StatusErrorScript can be used
to determine if the victim uploaded an image (e.g., copy-
righted, taken without permission) to this image sharing site.
The vendor has awarded us a bug bounty for this report [46].
VII. DEFENSES AGAINST COSI ATTACKS
This section discusses existing and upcoming defenses
against COSI attacks.
SameSite cookies. COSI attacks leverage the automatic
inclusion of HTTP cookies [19], client-side certiﬁcates [45],
and HTTP Authentication credentials [30] in requests sent by
web browsers, known as the ambient authority problem in
browsers [25]. Web sites can use the SameSite attribute
in a Cookie header to prevent the browser from sending
that cookie in cross-site requests [43], [67]. This defense
disables SD-URLs whose responses are based on states saved
in cookies. On the other hand, it does not prevent leakage by
HTTP Authentication credentials and client-side certiﬁcates,
it needs to be set for each cookie; it may be challenging to
deploy in web sites with legitimate cross-origin requests [58];
and its implementation in browsers can have ﬂaws [29]. When
we disclosed our results to the browser vendors, we were told
they plan to address COSI attacks by marking all cookies by
default as SameSite=Lax, unless the site speciﬁcally dis-
ables them with SameSite=None, or makes it stricter with
SameSite=Strict [69]. This change is already planned
for Chrome [11] and Firefox [12]. However, this defense will
initially ship behind a conﬁguration option since it may affect
functionality that requires cross-origin requests.
Session-speciﬁc URLs. Web sites can use URLs that include
a session-speciﬁc, non-guessable, token. The token must be
cryptographically bound to the session identiﬁer (e.g., the hash
of the identiﬁer), and the web site must verify this relationship
for all HTTP requests. Session-speciﬁc URLs prevent
the
attacker from identifying SD-URLs for the victim’s session,
avoiding COSI attacks. This defense does not depend on
browser vendors and can be deployed right away. On the other
hand, it can be costly to deploy, increases complexity, may
impact performance, and the web site must ensure that the
tokens cannot be leaked or brute forced [25].
Cross-Origin-Resource-Policy. An emerging HTTP response
header that allows web sites to ask browsers to disallow cross-
origin requests to speciﬁc resources [2]. The request is not
prevented, rather the browser avoids leakage by stripping the
response body. Currently supported by Chrome and Safari.
Fetch metadata. An emerging set of HTTP request headers
that send additional provenance data about a request [68], e.g.,
the HTML element triggering a cross-site request. Currently
supported by Chrome. A web site can use this information to
design policies that block potentially malicious requests. e.g.,
inclusion of a non-image resource with an img tag.
Cross-Origin-Opener-Policy. There is ongoing discussion on
a new HTTP response header to prevent malicious web sites
from abusing other web sites by opening them in a window [3].
This defense could protect against COSI attack classes that use
the window.open inclusion method (e.g. OP-Window Proper-
ties, postMessage).
Tor Browser. The Tor Browser takes preventive measures
against timing-based COSI attacks [54]. Additionally, it iso-
lates the browser’s state based on the URL in the address bar.
Therefore, it does not attach cookies and Authorization
header values to cross-origin HTTP requests generated by
inclusions using HTML tags. However, the state isolation is
not enforced for the window.open method, so authentication
headers are still attached to HTTP requests generated using
this inclusion method. Therefore, Tor Browser users are still
vulnerable to OP-WindowProperties and the new postMessage
attack class we discovered.
12
SD-URL patching. When reporting our attacks, we mentioned
SameSite cookies as a good defense in terms of protection,
since it
tackles the root cause of COSI attacks, and cost
to deploy. However, the developers that already patched our
attacks did not take that suggestion and instead applied a ﬁx
speciﬁc to the reported SD-URLs. For example, the HotCRP
developer mentioned that SameSite cookies is not available
in PHP until PHP 7.3, and instead modiﬁed the code to
always return a 200 HTTP status code with JSON content.
This ﬁxes our attack, but it will not ﬁx future attacks on other
status codes and content types. In another example, LinkedIn
patched our reported user deanonymization OP-FrameCount
attack by making sure that the reported SD-URL returned the
same number of frames for all users. These examples show
that developers currently consider URL-speciﬁc ﬁxes a quick
solution, despite its lack of generality.
VIII. DISCUSSION
This section discusses limitations of our approach and
possible future improvements.
Preparation overhead. To use Basta-COSI, the tester ﬁrst
needs to create accounts at the target site and provide state
scripts that use those accounts. Similar overhead is required by
other web security testing tools, when they need to examine
the logged in parts of a web site. Furthermore, Basta-COSI
is designed for web site administrators to test their own sites.
We believe the cost of creating test accounts for your own site
is a reasonable one-time effort, as these accounts can then be
reused for other tests. In fact, we expect many sites to already
have such test accounts in place for other types of testing.
Support for other browsers. Basta-COSI currently supports
the three most popular browsers: Chrome, Firefox, and Edge.
We did not include support for Safari because we run our
experiments on Windows and Apple stopped releasing Safari
for Windows in 2012. Adding support for other browsers is
a matter of additional engineering work. Of particular interest
would be adding support for mobile platform browsers given
their popularity and that COSI attacks on those browsers
have been little explored. Support for mobile browsers in
Basta-COSI could be achieved by integrating a mobile testing
platform, e.g., Appium [1].
Support for other crawlers. Basta-COSI uses ZAP’s Spider
module [7] for crawling the target site. The coverage of this
crawler may be limited on JavaScript-intensive web sites. It is
likely that some SD-URLs were not discovered by the crawler
for this reason, which may have caused COSI attacks to go
unnoticed. Basta-COSI’s modular design should easily allow
to integrate other crawlers to increase coverage. Still, despite
the potentially limited crawling, Basta-COSI was able to ﬁnd
COSI attacks in all tested targets.
Dynamic page element detection. To identify SD-URLs,
Basta-COSI removes dynamic page elements from HTTP
responses. Our detection of some dynamic page elements, e.g.,
CSRF tokens, is based on heuristics that could introduce errors.
However, there are a couple of mitigating reasons, which may
explain why we did not observe such errors in our testing.
First, even if a URL is wrongly identiﬁed as a SD-URL, Basta-
COSI may later discard it as non-exploitable. Second, dynamic
elements often do not impact the leak methods (e.g., events
ﬁred, properties read).
Timing. Basta-COSI supports the timing XS-Leak through the
video parsing technique described in [64]. However, we did
not use the timing XS-Leak in our experiments, which may
have prevented Basta-COSI from ﬁnding further attacks. The
main reason for disabling the timing XS-Leak is that in order
to attain the same level of reliability as other attack classes,
it requires sending hundreds [64], or even thousands [13], of
HTTP requests per SD-URL. This increases the load at the
target and causes some web sites to respond with defenses
(e.g., CAPTCHAs, blocking) that hamper the testing. We
noticed this initially on linkedin.com. In addition to the high
load, we observed another three challenges in using the timing
XS-Leak. First, we cannot generalize a timing attack. With
timing, we always need to measure the timing for each URL
in the target site; we cannot reuse what we learn from one
attack in new attacks. Second, timing information is harder to
use as the number of states increases. For example, if a URL
allows downloading a ﬁle only to its owner, there may not be
a clear timing difference between an unauthenticated user and
an authenticated one that is not the owner. Finally, it is hard
to combine in the same attack timing with the non-timing XS-
Leaks. Due to these challenges by default Basta-COSI does
not use the timing XS-Leak. We leave applying timing leaks
to more than two states for future work.
Discovering new XS-Leaks. We have systematically explored
existing COSI attacks and the XS-Leaks they use, generalizing
them into COSI attack classes. In this process, we have
discovered a novel postMessage XS-Leak. However, it is very
likely that there exist more, currently unknown, XS-Leaks
leveraging other browser APIs. Systematically exploring the
browser API surface to identify all possible XS-Leaks remains
an open challenge, which we plan to explore in future work.
IX. RELATED WORK
Prior COSI attack instances. Table VIII summarizes the
23 prior works proposing COSI attack instances we have
identiﬁed. The ﬁrst instance of a COSI attack was proposed in
2006 by Grossman and Hansen [36]. It was a login detection
attack using the img tag and the EventsFired XS-Leak (EF-
CtMismatchImg attack class). Since then, EventFired attacks
have been shown to apply to other HTML tags and content
types [22], [34], [35], [65]. Recently, Staicu and Pradel [61]
showed that EventsFired attacks can be combined with share-
able images to deanonymize users of image sharing services.
In another blog post in 2006, Grossman [33] introduced
the ﬁrst instance of the JSError attack class that leverages the
type and line number of errors triggered when a JavaScript
resource is included using the script tag. This attack was then
demonstrated on popular sites like Amazon [59]. Inspired by
Grossman’s attacks, Evans [26] presented the ﬁrst instance
of the CSSPropRead attack class, leveraging the presence of
certain objects and variables from an included JS resource. In
a 2012 post Grossman presented multiple attack instances in-
cluding the ﬁrst instances of the JSObjectRead attack class and
the ﬁrst attack using the readable object properties XS-Leak
[35]. Lekies et al. [50] extended the JSObjectRead class with
more techniques such as prototype tampering and showed that
13
Reference
Year
Type
Attack Classes
Browsers
2006
Blog
EF-CtMismatchImg
-
Grossman &
Hansen [36]
Grossman [33]
Shiﬂett [59]
Bortz et al. [21]
Grossman [34]
Evans [26]
Evans [27]
Cardwell [22]
2006
2006
2007
2008
2008
2009
2011
Blog
Blog
Paper
Blog
Blog
Blog
Blog
F
F
F, S
F
F
-
C, F, IE
F
C, F, IE
-
C
C
C
IE, E
C
F
C
C, F
C, F
C
C
C, F, E
JSError
JSError
Timing
EF-CtMismatchScript,
EF-CtMismatchImg
CSSPropRead
Timing
EF-StatusErrorScript,
EF-CtMismatchImg
EF-StatusErrorIFrame,
EF-CtMismatchScript,
OP-
OP-LinkSheet,
FrameCount,
EF-
CtMismatchImg,
JSObjectRead
CSPViolation
Timing
Timing, EF-
CtMismatchVideo
JSObjectRead
AppCacheError
OP-LinkSheet
OP-WindowProperties
CSPViolation
CSPViolation
OP-MediaStatus
EF-CtMismatchImg
OP-WindowProperties
Timing
EF-CtMismatchImg,
OP-FrameCount,
CSPViolation, Timing,
EF-CtMismatchObject,
OP-ImgDimension,
OP-MediaDuration,
OP-WindowProperties,
EF-CacheLoadCheck
Grossman [35]
2012
Blog
Homakov [40]
Gelernter &
Herzberg [31]
Goethem et al. [64]
2013
2015