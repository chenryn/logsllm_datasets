而不被进程的环境观察到或是受其控制。设C是用这个办法屏截
实际上，我们是要这些动作自动发生，而且以最快的速度进行，
组成部分的结构；并且还希望屏蔽掉装置内部发生的所有动作。
X4）和2.6.2节中X3。这类装置构成之后，我们就屏蔽掉它的
发组成部分之间的相互作用和通信联系，例如CHAIN2（2.6节
部转换的事件。这类事件可能代表着构成这个机械装置的各个
有关的事件，而且它们的发生还需环境的同时参予。但在描逮一
L1t
个机械装置的内部行为时，我们经常需要考虑那些代表该装置内
L10
6
举例
一般说来，一个进程的字母表仅包含那些我们认为是与进程
{}∈refusals(P)
X∈refusals(P)>(XU{x))∈refusals(P)
(XUY)Erefusals(P)>X∈refusals(P)
NOISYVM\(elink,clunk}
a(P\C)=aP-C
3.5
V∈traces(P)
P\C
屏
群
xEaP
---
## Page 117
3.5.1法则
动作c同在P和Q的字母表中，因此它被看作是一个内部动作而
X2 设 αP={a,0}， αQ={b,c},
两个进程字母表的交集中的符号。
威知，也不让环境对它们进行干预。因此需要屏蔽的正是属于这
相互作用自主发生，而且速度越快越好，而不让系统的外部环境
的相互作用看做是它们所组成的系统的内部动作，我们希望这种
被屏蔽的先后次序也无影响。这组法则中其余的说明屏蔽对其它
被屏，有
要使外界完全看不到它们的发生。没被屏蔽的事件仍然不变。故
屏藏的目的在于让任何被屏蔽的事件自动地在一瞬间发生，而且
屏藏不影响已停止的进程的行为，
屏蔽对非确定性选择有分配律
L2 (P\B)\C=P\(BLC)
一个--个地屏符号集合，和将它们同时屏蔽是－-回事
算子有分配律。
L3 (PO)\C=(P\C)(Q\C)
前儿条法则将陈迹屏一个空集亳无效用，而且集合中符号
什么都不屏蔽的话，就等于将－切暴露给环境，即
当两个进程被组合到一起并发运行时，我们通常把它们之间
Q=(c-+b→→Q)
VMS = NoisyVM\fclink,clunk,toffee)
(P0)\{c) =(a→c→μX.(a→b-→c-→X
=α-=μx.(a-=b+x
[b-=4-=x)
只影响它的字母表
P=(4→→c→P)
（参见2.3.1节X1)
口
---
## Page 118
这条法则不是很有川的，因为我们通常是希望把并发进程间的相
L6设 αP∩αQ∩C={}
的并发组合有分配律
如果C只包含P和Q各自独立参予的事件，则C的屏蔽对P和Q
组成。屏蔽后的事件成为进程的内部动作，
L9如梁BC，且B是非空的有限集合
发生：但不论哪个真发生了，都要被屏蔽掉。
的被屏蔽的事件都能够发生时，我们不能确定它们中的哪个将要
L8若B∩C={}
选择仍.与屏蔽前的一样
G
的发生是需要这两个并发进程共同参加的。
工作用屏蔽掉，也就是说屏蔽掉属于αP个αQ的事件，这类事件
5
有
这一进程的行为由
邢么
那么
象选择算子口一样，屏蔽也可以引入非确定性。当几个不同
如果供选择的可能初始事件部没被屏薇，那么屏蔽后的初始
f(P\C) = f(P)\f(C)
屏蔽显然对1-1符号变换函数有分配律
(x-→P)\C=x-→(P\C)
有一部分没被屏蔽时，情况就耍更复杂些了。;考虑如下进程
那么（xc:B→P(x))\C=[
(PIQ)\C=(P\C)(Q\C)
(x:B→P(x))\C=(x:B-→(P(x)\C))
(e-→P1d-→Q)\C
=P\C 
(P\C) 和(d→(Q\C))
[(P(x)\C)
若x∈
若xC
εC,amα
，它自动地而且极其
95
1.：1
1:1
1
---
## Page 119
的行为是一样的，即有
集合B中的事件是不会实际发生的，所以P+的行为实质上与P
的符号并到P的字母表中来。合
一个使进程P字母表扩大的操作，
(0-+STOPDd→STOP)\{c}
说明 
以上法则的图示说明将在3.5.4节中给出。
170如果C∩B是非空有限集合
类似的推理可论证一个更普退的法则
而不是
这两部分行为组成的整体行为是
(P/C)交互作用时，这种选择总是成功的，不应被拒绝。这样，
适速地发生，井导致进程的后续行为如（P\C)。故在环境选择与
其中
6
要注意的是，\C对口抖不能后溯分配。我们举个反例即可
屏蔽会使进程的字母表缩小，
那么(x:B-→P(x))\C=Q(QD(x:(B-C)-=P(x)\C))
(c→P[4Q)\C= (P\C)((P\C)D(d→(Q\C)))
= ((c→STOP)\(C))D((4STOP)\[c})
= STOP[(d→STOP)
≠d→STOP
- STOP(d→STOP)
= STOP[(STOPU(4→STOP))
Q= 
(P+a)=αPUθ
(((0)+()()
 P(x)\C
((00)p)(d)
，扩大的方法是把某个集合B中
与之相对应我们还可以再定义
B∩aP={}
3.3,1节L4
L10
---
## Page 120
匿动作4，但它却不能坚持非要非藏匿事件发生不可。如果环境
这说明一个进程，尽管它可以提供环境选择被藏匿动作。或非藏
设d∈aR，考虑进程
还要更严格地讨论发散的问题。
非确定性的公平性的决定与之也有一定关系。在3.8书中，我们
乎有助于得到最高效的实施方法。我们在3.2.1节中不坚持要求
阻止进程去执行被藏匿的事件，而不执行4。但是这一可能性微
境似乎可以无止境地提供选中事件d的这种可能机会，它却无法
这里的递归式叉是非卫式的，因而趋于发散。由此看出，尽管环
上问题还是会出现的。例如
或是非卫式的递归式这种不幸的结果。这个现象统称为进程的爱
因此，屏截连续发生的无穷多个事件的序列，就会导致无穷循环
能解决。一些简单情况下，屏蔽对递归式是有分配律的。如
L12 (P+)\B=P
由此推得，屏蔽\B与用B扩大字母表互为逆运算
散性。
L11
对藏匿实际上是公平的，这个事实是具有重要意义的。
但是即使该发散进程能无限多次执行没有被屏蔽的事件，以
在这里我们要适时地提出一个问题，这个问题要在3.8节求
((c-→a-→P|d--STOP)\{c})I(a-+R)
traces(P+a)= traces(P)
= (a→PV(c})I(a-→R)(a→P\{c}D4-STOP)I(a--R)
=((a-→P>{c})fl(a->P\{c}[d-STOP))I(a-→R) L10
=a-→((PV(o})1R)
(μX,(c-→XD4-=P))\{e}
=μX.(X\{e})((XVe})Dd-→(P\V{c}))
=μX.((c-X[4-→P)\{c})
=uX:(A-{0}).X
L12,L5
97
L10
---
## Page 121
那么hide(hide(P,c),d)=hide(hide(STOP,e),d)
很重要，举例说明如下，设
的通信。这个结果是对企图实施-·个发散进程的行为的惩罚。
这个递归循环是无法退出的，因而也就不可能与外界发生进一步
在这种情况下，检验（P(c)="BLEEP)时，总是产生FALSE，
行无穷多个被贼匿事件的进程时，·将会发生什么样的结果，例如
最简单的实施方法是让被藏匿的事件在可能发生时，以最快的速
地藏匿起来，因为有
对含两个或两个以上符号的集合，进程可以将其符号一个接一个
·！·为简便起见，我们实施一次只藏匿一个符号的逃程，今
3.5.2实施
（a→P\{c})）发生相互作用。
事件·就必须发生，以便使环境还能有机会与结果进程（即
葡 
所以函数hide就总是选择eIse子句，随后立即执行递归调用。
度悄悄地发生，即
（在本例中是a→R）没有为4的发生做好准备，那么被藏匿的
6
屏蔽运算的实施并不遵从L2：因为它藏匿符号的顺序确实
我们来讨论一下，当这个藏匿函数作用于某--个能够连续执
hide(P,c)=if P(c)="BLEEP then
hide(hide(P,d),c)=hide(hide((a→STOP),d),c)
P\{c1,c2,·,cn)=(.·((P\e1))\o2))\·)\on)
P=(c-STOP|d-a→STOP)
hide(μX.(o→X[d-→P),c)
(Ax.if P(x) ="BLEEP then "BLEEP
hide(P,c)=P\{c}
=STOP
eise hide(P(o),0)
else hide(P(x),c))
---
## Page 122
中我们将看到一-个更为完善的发散性处理方法。
续行为来完全确定，叙述为法则为
继s之后，（P\C)的后续行为也不-定能由P的某一个可能的后
迹t，这些迹经过删除运算后结果都一样，即t(aP-C)=9。故
列。因此我们定义如下
发散；.也就是说，它能够执行被删除事件所组成的一个无穷序
为我们在定义进程过程中，总是设法避免发散现象的。在3.8节
1.2
L1
由P的某个迹，经过这类运算得到的。我们叙述如下
去掉，就能得到相应的P\C的迹。反之，P\C的每个迹一定是
的实施。
满足的结论是，上逃的两个结果都被允许作为同一进程
其中 T=traces(P)∩{tt ↑(aP-C)=s}
某个具体实施不-定非要遵守非确定性算子的一般法则。使我们
但是正如我们在3.2.2带中已经解释过的那样，非确定性算子的
这些法则仅适用子不发散的进程。但这种限制无伤大雅，因
T为存穷集合，且s∈traces(P\C)则
如果 V s:traces(P).-diverges(P/s,C)
条件：diverges（P,C）的含义是，只要C一被删去，就导致P
如果是P的一-个迹，我们只要将中出现的C的符号统统
与P\C的一个迹&相对应的，可能有多个P的可能行为的
diverges(P,C)=Vn.3s:traces(P)∩C*.#s>n
traces(P\C)={t ↑(aP-C)|t:traces(P)}
P\{e,d} = (STOP[(a→STOP))
=a-STOp
99
---
## Page 123
合律。
等效性，如图3.2解释了门的结
3.1。有关非确定性的代数法则
3.5.4示意图
消去。
如果我们把示意图重画成如图3.4的形式，就可以将这样的节点
种节点的含义是什么呢？这个间题的答案由3.5.1节中L10给出。
的箭头了。这样做的结果自然就会产生非确定性，见图3.3。
号从标记中抹去，因此所有用他们作为标记的箭头都变成无标记
说明如何推断不同示意图之间的
行。
程就沿着某个引出的箭头向下通
是非确定的，外界未督觉察，进
到该节点时，通行路径的选择又
由这种节点出发引出了两个或两个以上不带标记的箭头，当执行
100
但是如果一个节点的有些弧有标记，而另一些没有，那么这
我们在示意图中可以用这样一种节点来代表非确定性选择，
符号屏藏的运算可以被看作是这样一种操作，它把屏蔽的符
因此P门Q表示为示意图
圈3.2
1
.
---
## Page 124
理解；而不是用于大型进程的实际变形或处理。
3.6)。
引出线。消除这类节点可用3.3节结束部分给出的法则（见图
们已决定把发散看做是进程定义中的错误了。
则是行不通的，但这种图形只在进程发散的情况下才出现，而我
行的。对含有无标记的无穷路径，例如图3.5所示，上述消去法
图，只要它不包含无标记箭头构成的无穷路径，该消去法也是可
用图示法表示进程及它们所遵从的法则，是为了帮助记忆和
使用变形法则L10，可能导致一个节点具有两个标记相同的
显然，这类消去法对有穷树形图总是可行的。而对无努示意