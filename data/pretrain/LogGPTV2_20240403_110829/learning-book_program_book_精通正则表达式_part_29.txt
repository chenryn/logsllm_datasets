备用状态
Saved States
记：在需要的时候，匹配可以从这里重新开始尝试。它们保存了两个位置：正则表达式中
的位置，和未尝试的分支在字符串中的位置。因为它是NFA匹配的基础，我们需要再看一
追某些已经出现过的简单但详细的例子，说明这些状态的意义。如果你觉得现有的内容都
不难懂，请继续阅读。
---
## Page 186
160
第4章：表达式的匹配原理
未进行回溯的匹配
来看个简单的例子，用ab?c匹配abc。a匹配之后，匹配的当前状态如下：
'abc'
ab?cs
现在轮到b?了，正则引擎需要决定：是需要尝试‘b呢，还是跳过？因为？是匹配优先的，
它会尝试匹配。但是，为了确保在这个尝试最终失败之后能够恢复，引擎会把：
‘abc'
[ab？C)
添加到备用状态序列中。也就是说，稍后引擎可以从下面的位置继续匹配：从正则表达式
中的b？之后，字符串的b之前（也就是当前的位置）匹配。这实际上就是跳过bi的匹配，
而问号容许这样做。
引擎放下面包屑之后，就会继续向前，检查bi。在示例文本中，它能够匹配，所以新的当
前状态变为：
“abc”
ab?C
最终的c也能成功匹配，所以整个匹配完成。备用状态不再需要了，所以不再保存它们。
进行了回溯的匹配
如果需要匹配的文本是‘ac”，在尝试bi之前，一切都与之前的过程相同。显然，这次b
配失败”并不会导致整体匹配失败。引擎会进行回溯，也就是说，把“当前状态”切换为
最近保存的状态。在本例中，情况就是：
'ac'
ab?C)
在b尝试之前保存的尚未尝试的选项。这时候，c可以匹配c，所以整个匹配宣告完成。
不成功的匹配
现在，我们用同样的表达式匹配‘abx'。在尝试b以前，因为存在问号，保存了这个备用
状态：
'abx'
ab?Cs
---
## Page 187
回溯
161
b:能够匹配，但这条路往下却走不通了，因为c无法匹配x。于是引擎会回溯到之前的状
态，“交还”b给'c来匹配。显然，这次测试也失败了。如果还有其他保存的状态，回溯会
继续进行，但是此时不存在其他状态，在字符串中当前位置开始的整个匹配也就宣告失败。
事情到此结束了吗？没有。传动装置会继续“在字符串中前行，再次尝试正则表达式”，这
可能被想象为一个伪回溯（pseudo-backtrack)。匹配重新开始于：
xqe，
从这里重新开始整个匹配，如同之前一样，所有的道路都走不通。接下来的两次（从abX
到abx）都告失败，所以最终会报告匹配失败。
忽略优先的匹配
现在来看最开始的例子，使用忽略优先匹配量词，用ab??ci来匹配‘abc”。ai匹配之后的
状态如下：
ae,
a'e,
接下来轮到b？？，引擎需要进行选择：尝试匹配b，还是忽略？因为？?是忽略优先的，它
会首先尝试忽略，但是，为了能够从失败的分支中恢复，引擎会保存下面的状态：
`abc'
abc!
到备用状态列表中。于是，引擎稍后能够用正则表达式中的b来尝试匹配文本中的b（我
们知道这能够匹配，但是正则引擎不知道，它甚至都不知道是否会要用到这个备用状态）。
状态保存之后，它会继续向前，沿着忽略匹配的路走下去：
oge,
oqe
ci无法匹配‘b”，所以引擎必须回溯到之前保存的状态：
“abc'
'abcs
显然，此时匹配可以成功，接下来的c匹配‘c”。于是我们得到了与使用匹配优先的ab?ci
同样的结果，虽然两者所走的路不相同。
---
## Page 188
162
第4章：表达式的匹配原理
回溯与匹配优先
Bncktracking and Greediness
如果工具软件使用的是NFA正则表达式主导的回溯引擎，理解正则表达式的回溯原理就成
了高效完成任务的关键。我们已经看到？的匹配优先和？？的忽略优先是如何工作的，现
在来看星号和加号。
星号、加号及其回溯
如果认为x*基本等同于x？x?x?x?x?x？…（或者更确切地说是（x（x（x（x·？）？）?）？）？）1）
（注5)，那么情况与之前没有大的差别。每次测试星号作用的元素之前，引擎都会保存一
个状态，这样，如果测试失败（或者测试进行下去遭遇失败），还能够从保存的状态开始匹
配。这个过程会不断重复，直到包含星号的尝试完全失败为止。
所以，如果用（0-9}+来匹配‘a·1234·num’，[0-9]遇到4之后的空格无法匹配，而此时
加号能够回溯的位置对应了四个保存的状态：
a 1.234 num
a 1234num
a 1234num
a 1234num
也就是说，在每个位置，[0-9]：的尝试都代表一种可能。在[0-9]遇到空格匹配失败时，
引擎回溯到最近保存的状态（也就是最下面的位置），选择正则表达式中的[0-9]+和文
本中的‘a'1234num’。当然，到此整个正则表达式已经结束，所以我们知道，整个匹配宜
告完成。
请注意，‘a·1234“num”并不在列表中，因为加号限定的元素至少要匹配一次，这是必要条
件。那么，如果正则表达式是[0-91，这个状态会保存吗？（提示：这个问题得动点脑筋）。
要知道答案，请翻到下一页。
重新审视更完整的例子
有了更详细的了解之后，我们再来看看第152页的^.*（[0-9][0-9】）：的例子。这一次，
我们不是只用“匹配优先”来解释为什么会得到那样的匹配结果，我们能够根据NFA的匹
配机制做出精确解释。
以‘CA·95472·USA’为例。在.*成功匹配到字符串的末尾时，星号约束的点号匹配了13
注5：作为比较，请记住DFA并不关心表达式的形式，对DFA来说，这3个例子是无差别的。
---
## Page 189
关于匹配优先和回溯的更多内容
163
个字符，同时保存了许多备用状态。这些状态表明稍后的匹配开始的位置：在正则表达式
中是^.*，（[0-9][0-9]），在字符串中则是点号每次匹配时保存的备用状态。
现在我们已经到了字符串的末尾，并把控制权交给第一个[0-9]，显然这里的匹配不能成
功。没问题，我们可以选择一个保存的状态来进行尝试（实际上保存了许多的状态）。现在
回溯开始，把当前状态设置为最近保存的状态，也就是.*匹配最后的A之前的状态。忽
但这同样会失败。
这种“回溯-尝试”的过程会不断循环，直到引擎交还2为止，在这里，第一个[0-9]可以
匹配。但是第二个[0-9]仍然无法匹配，所以必须继续回溯。现在，之前尝试中第一个[0-9]
是否匹配与本次尝试并无关系了，回溯机制会把当前的状态中正则表达式内的对应位置设
置到第一个“[0-91以前。我们看到，当前的回溯同样会把字符串中的位置设置到7以前，
所以第一个‘[0-9]可以匹配，而第二个[0-9]也可以（匹配2）。所以，我们得到一个匹
配结果‘CA·95472·USA'，$1得到72。
需要注意的是：第一，回溯机制不但需要重新计算正则表达式和文本的对应位置，也需要
维护括号内的子表达式所匹配文本的状态。在匹配过程中，每次回溯都把当前状态中正则
表达式的对应位置指向括号之前，也就是.*，（{0-9）[0-9））。在这个简单的例子中，所
回“万[6-0]√-集用。[6-0]6-0]
括号的这种处理，不但需要同时维护S1的状态，也会影响匹配的效率。
最后需要注意的一点也许读者早就了解：由星号（或其他任何匹配优先量词）限定的部分
不受后面元素影响，而只是匹配尽可能多的内容。在我们的例子中，.*在点号匹配失之
前，完全不知道，到底应该在哪个数字或者是其他什么地方停下来。在.*（[0-91+）的例
子中我们看到，[0-9】+只能匹配一位数字（153）。
关于匹配优先和回溯的更多内容
More Afout Greerdiness and Bncktracking
NFA和DFA都具备许多匹配优先相关的特性（也从中获益）。（DFA不支持忽略优先，所以
我们现在只关注匹配优先）。我将考察两种引擎共同支持的匹配优先特性，但只会用NFA
来讲解。这些内容对DFA也适用，但原因与NFA不同。DFA是匹配优先的，使用起来很
---
## Page 190
164
第4章：表达式的匹配原理
测试答案
162页测试的答案
答案是否定的。之所以提这个问题，是因为这种错误很常见。记得吗，由星号限定的
部分总是能够匹配。如果整个表达式都由星号控制，它就能够匹配任何内容。在宇符
串的开始位置，传动机构对引擎进行第一次尝试时的状态，当然算匹配成功。在这种
情况下，正则表达式匹配“a'1234·num”，而且在此处结尾一-它根本没有触及到那
些数宇。
如果没答对也不要紧，因为这种情况还是有可能发生的。如果在表达式中、[0-91*1
之后还出现了某些元素，因为它们的存在，引擎在达到下面状态之前无法获得全局匹
配：
‘a1234...”
[....（6-0]
那么，尝试1会生成下面的状态：
“a1234...
.[6-0],
方便，这一点我们只需要记住就够了，而且介绍起来也很乏味。相反，NFA的匹配优先就
很值得一谈，因为NFA是表达式主导的，所以匹配优先的特性能产生许多神奇的结果。除
了忽略优先，NFA还提供了其他许多特性，比如环视、条件判断（conditions）、反向引用，
以及固化分组。最重要的是NFA能让使用者直接操控匹配的过程，如果运用得当，这会带
来很大的方便，但也可能带来某些性能问题(具体见第6章)。
不考虑这些差异的话，匹配的结果通常是相通的。我介绍的内容适用于两种引擎，除了使
用表达式主导的NFA引擎。读完本章，读者会明白，在什么情况下两种引擎的结果会不一
样，以及为什么会不一致。
匹配优先的问题
Problems of Greediness
在上例中已经看到，.*经常会匹配到一行文本的末尾（注6)。这是因为.*匹配时只从自
身出发，匹配尽可能多的内容，只有在全局匹配需要的情况下才会“被迫”交还一些字符。
注6：如果工具软件或匹配模式设置了点号通配模式，.*能够匹配包含多行数据的字符串，包
含所有的逻辑行，直到整个字符串的末尾。
---
## Page 191
关于匹配优先和回溯的更多内容
165
有些时候问题很严重。来看用一个匹配双引号文本的例子。读者首先想到的可能是”.*"
那么，请运用我们刚刚学到的关于.*的知识，猜一猜用它匹配下面文本的结果：
The name "McDonald's" is said "makudonarudo*in Japanese
既然知道了匹配原理，其实我们并不需要猜测，因为我们“知道”结果。在最开始的双引
号匹配之后，.*能够匹配任何字符，所以它会一直匹配到字符串的末尾。为了让最后的双
引号能够匹配，.*会不断交还字符（或者，更确切地说，是正则引擎强迫它回退），直到
满足为止。最后，这个正则表达式匹配的结果就是：
The name "McDonald's"is_said"makudonarudo* in Japanese
这显然不是我们期望的结果。我之所以提醒读者不要过分依赖.*，这就是原因之一，如果
不注意匹配优先的特性，结果往往出乎意料。
那么，我们如何能够只取得“McDonald's"呢？关键的问题在于要认识到，我们希望匹配的
就不会出现上面的向题。
[^"]*会匹配尽可能多的字符。在本例中，就是McDonald's，因为'[^"]无法匹配之后
的双引号。此时，控制权转移到正则表达式末尾的”。而它刚好能够匹配，所以获得全局
匹配：
The name*McDonald's"is said“makudonarudo"in Japanese
事实上，可能还存在一种出乎读者预料的情况，因为在大多数流派中，"]能够匹配换行
符，而点号则不能。如果不想让表达式匹配换行符，可以使用[^"\n]。
多字符“引文”
Multi-Character"Quotes”
成了多字符构成的和。与双引号字符串的例子一样，使用".*匹配多字符“引文”
也会出错：
Billions and Zi1lions of suns.
.*中匹配优先的.*会一直匹配该行结尾的字符，回溯只会进行到能够匹
配为止，也就是最后-个，而不是与匹配开头的B>i对应的l。
---
## Page 192
166
第4章：表达式的匹配原理
不幸的是，因为结束tag不是单个字符，所以不能用之前的办法，也就是“排除型字符组”
来解决，即我们不能期望用[]*解决问题。字符组只能代表单个字符，而
我们需要的是一组字符。请不要被[^]迷惑，它只是表示一个不等于、/、
B的字符，等价于[~/<>B]，而这显然不是我们想要的“除结构之外的任何内容”（当
然，如果使用环视功能，我们可以规定，在某个位置不应该匹配，下一节会出现这种
应用)。
使用忽略优先量词
Ulsing Lazy Qnantifiers
上面的问题之所以会出现，原因在于标准量词是匹配优先的。某些NFA支持忽略优先的量
词（141），*？就是与*对应的忽略优先量词。我们用.*?来匹配：
"Billions and Zillions of suns"
开始的匹配之后，.*？首先决定不需要匹配任何字符，因为它是忽略优先的。于是，
控制权交给后面的Bi1lions.*
.*？1
此时Billions中带下画线的B。此时，*?又必须选择，是继续尝试匹配，还是忽略？因为
匹配的分支。在这个过程重复8次之后，.*？最终匹配了Billions，此时，解下来的）都能匹配：
"Billions and Zillionsof suns
所以我们知道了，星号之类的匹配优先量词有时候的确很方便，但有时候也会带来大麻烦。
这时候，忽略优先的量词就能派上用场了，因为它们做到其他办法很难做到（甚至无法做
到）的事情。当然，缺乏经验的程序员也可能错误地使用忽略优先量词。事实上，我们刚
刚做的或许就不正确。如果用.*？来匹配：
"Billions and Zillions of suns..
结果如上图，虽然我假设匹配的结果取决于具体的需求，但我仍然认为，这种情况下的结
果不是用户期望的。不过，.*？必然会匹配Zillions左边的，一直到。
---
## Page 193
关于匹配优先和回溯的更多内容
167