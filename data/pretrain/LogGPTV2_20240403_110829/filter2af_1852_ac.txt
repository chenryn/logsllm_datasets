反射型XSS(按ctrl键点我跳转)
## 5.2.BeEF
这个工具在kali上有集成。
该使用工具在freebuf上有一个系列文章，写的非常好，这里分享一下：[BeEF](https://www.freebuf.com/sectool/178512.html)
我这里就简单介绍下如何使用吧。
先打开kali，这里打开beef的方式有两种，第一种是以下这种：
在这里搜索beef，点击其中的`beef xss framework`或者`beef start`任选一个
[
第二种是直接命令行中敲`beef-xss`。
[
然后都是在命令行上，等待上面的秒数从5到1后，会跳出一个页面让我们登录
[
这里如果不知道用户名和密码的话，可以在命令行敲这个命令：`vim /etc/beef-xss/config.yaml`，在里面可以进行查看。如果想修改的话也可以自行修改，修改了密码则要重新启动BeEF进行登录(如果登录不了，则kali重启再重新启动程序)
登录成功，里面是长这个样子
[
这时候啥都干不了，是因为你有一步很重要的操作没做。这里需要把图中红框中的payload复制粘贴到你的目标xss的位置，然后将其中的``改成你这台kali的IP地址，最终payload为：``
[
这里我用dvwa来模拟场景。将payload插入其中，点击submit
[
这时候再回到BeEF中查看，会发现online browers中多了点东西，这时候就可以开始操作了
[
我这里介绍下这个主页面：
其中最左边的是`Hooked Browers`
  * online browers：在线浏览器
  * offline browers：离线浏览器
`Current Browser`中的这几栏分别有：
`Detials`
  * 浏览器、插件版本信息，操作系统信息
`Logs`
  * 浏览器动作：焦点变化，鼠标单击，信息输入
`commands`
  * 绿色模块：表示模块适用当前用户，并且执行结果对用户不可见
  * 红色模块：表示模块不适用当前用户，有些红色模块也可以执行
  * 橙色模块：模块可用，但结果对用户可见
  * 灰色模块：模块为在目标浏览器上测试过
介绍完之后，再回到刚才的场景。这里在BeEF中的`Current Browser`中点击其中的`Commnads`，其中就可以选择许多模块来对目标进行攻击
这里举波例子：
选择 `Brower`下面的`Hooked Domain`中的`Create Alert Dialog`（创造一个弹窗
），点击右下角的`Execute`运行。
[
然后看看dvwa的状态，成功弹窗
[
这里再举个获取cookie的例子：
选择 `Brower`下面的`Hooked Domain`中的`Get Cookie`，点击右下角的`Execute`运行。
然后就会返回目标的cookie
[
这里我模拟管理员，我的cookie就被窃取走了。可是这里来到浏览器按F12打开开发者工具比对完发现少了两个，这里来看下
[
原来是因为这里的另外两个cookie带有`HttpOnly`，所以获取不到。这点我在最后的 **修复** 中会有提及。
# 6.挖掘XSS
之前说过了修改输入框和URL参数来实现XSS。我在这里深入一点说明下。
修改URL参数的时候，你看到的只是用GET来传输数据的，还有隐形的数据，他们是用POST来传输数据，只有在数据包里才可以看到。
废话不多说，下面进入正题：
## 6.1.方法
### 6.1.1.手工检测XSS
使用手工检测Web应用程序是否存在XSS漏洞时，最重要的是考虑哪里有输入、输入的数据在什么地方输出。
使用手工检测XSS时，一定要选择有特殊意义的字符，这样可以快速测试是否存在XSS。比如，测试某输入框是否存在XSS漏洞时，不要直接输入XSS跨站语句测试，应该一步一步地进行，这样更有利于测试。
#### 6.1.1.1.可得知输出位置
输入一些敏感字符，例如``、`"`、`'`、`()`等，在提交请求后查看HTML源代码，看这些输入的字符是否被转义。
在输出这些敏感字符时，很有可能程序已经做了过滤，这样在寻找这些字符时就不太容易了，这时就可以输入`AAAA<>'''&`字符串，然后在查找源代码的时候直接查找`AAAA`这样或许就会比较方便了。
#### 6.1.1.2.无法得知输出位置
非常多的Web应用程序源代码是不对外公开的，这时在测试XSS时就有可能无法得知输入数据到底在何处显示，比如，测试某留言板是否存在XSS，那么在留言之后，可能需要经过管理员的审核才能显示，这时无法得知输入的数据在后台管理页面处于何种状态，例如：
​ 在``标签中：`XSS Test`
​ 在``标签中：``
​ 对于这种情况，通常会采用输入`"/>XSS Test`来测试。
### 6.1.2.全自动检测XSS
AWVS、APPSCAN等软件都可以有效地检测XSS漏洞，但是这些大型漏洞扫描工具不仅会检测XSS漏洞外，还会检测像SQL注入漏洞等其他漏洞。虽然这些漏洞扫描工具可以配置只检测XSS漏洞，但是却比如专门的XSS检测工具效率高。
专门的XSS扫描工具有很多，像XSSER、XSSF等都很好用。也有大牛自己制作的扫描XSS漏洞的工具等等。
检测XSS一定要工具和手工并进，这样才能更好地检测XSS。比如在扫描XSS时，很多漏洞扫描器一般都无法检测非常规的XSS漏洞，例如在提交留言时可能需要短信验证、验证码填写等，这些工具是无法做到的。
### 6.1.3.骚操作
我们都知道当你浏览网站的时候，对方的服务器会记录下你的IP地址。如果我们伪造IP为XSS代码呢？这里说的修改IP为XSS不是说修改PC端的，而是在浏览器也就是网页上的客户端进行修改。
#### 6.1.3.1.使用工具
这里需要使用firefox浏览器和两个附件（用一个就行）
**附件一：X-Forwarded-For Header**
因为PHP获取IP有3个函数。而X-Forwarded-For
Header就是对其中一个函数X_FORWARDED_FOR起作用，X_FORWARDED_FOR有个缺陷可以使客户端伪造任意IP，当然包括字符串，但是对其他两个函数就不行了。
[
**附件二：Modify Headers**
`Modify Headers`可以伪造数据包内容，当然也可以伪造`HTTP_CLIENT_IP`来更改IP。
那还有一个`REMOTE_ADDR`获取IP函数，这个怎么修改呢？答案是无法修改。
`REMOTE_ADDR`是由 nginx 传递给 php 的参数，所以就是当前 nginx 直接通信的客户端的 IP
，而我们无法插手。所以一旦对方使用了`REMOTE_ADDR`函数来获取IP，那就没办法了。不过不要紧，一共3个函数，2个函数可以伪造，我们还是有很大的成功率的。好了，开始伪造。
[
这里 **Modify Headers** 的用法就是点击左上角`Select action`，选择`Add`，就可以加了。`X-Forwarded-For`得用`Modify`，这样才能填`Header value`，最后还要记得点击左上角的Start。
#### 6.1.3.2.结果
伪造好后，就打开[www.ip138.com](https://link.zhihu.com/?target=http%3A//www.ip138.com/)
[
成功弹窗了。因为我当时在`X-Forwarded-For
Header`里配置的是``；而在`Modify
Headers`里面没有配置`X-Forwarded-For函数`，只配置了`Client-IP函数`，值为``。也就是说[www.ip138.com](https://link.zhihu.com/?target=http%3A//ip138.com/)当时使用的是`X_FORWARDED_FOR函数`来获取IP的。
现在在去尝试已经不行了，估计已经修改了吧。
#### 6.1.3.1.使用前提
1.服务器要有获取你的ip的需求，不然不会触发。
2.即使有获取你的ip的需求，也要使用那几个指定函数来获取。
3.没有过滤。像DZ等著名CMS不存在，他们都过滤了。
# 7.修复
XSS漏洞最终形成的原因是对输入与输出没有严格的过滤，在页面执行JavaScript等客户端脚本，这就意味着只要将敏感字符过滤，即可修补XSS漏洞。但是这个过程是十分复杂的，很多情况下无法识别哪些是正常的字符，哪些是非正常的字符。
## 7.1.输入与输出
在HTML中，``、`"`、`'`、`&`都有比较特殊的意义，因为HTML标签、属性就是由这几个符号组成的。如果直接输出这几个特殊字符，极有可能破坏整个HTML文档的结构。所以，一般情况下，XSS将这些特殊字符转义。
在PHP中提供了`htmlentities()`、`htmlspecialchars()`函数可以把一些预定义的字符转换为HTML实体。
预定义的字符有这些：
1.`&`(和号)成为`&amp`；
2.`"`(双引号)成为`&quot`;
3.`'`(单引号)成为`&#039`;
4.``(大于)成为`&gt`。
当字符传经过这类函数处理后，敏感字符将会被一 一转义。
## 7.2.HttpOnly
严格地说，`HttpOnly`对防御XSS漏洞不起作用，它的主要目的是为了解决XSS漏洞后续的cookie劫持攻击。
`HttpOnly`是微软公司的Internet Explorer 6
SP1引入的一项新特性。这个特性为cookie提供了一个新的属性，用以阻止客户端脚本访问cookie。至今已经成为了一个标准，几乎所有的浏览器都会支持`HttpOnly`。
如何使用JavaScript获取cookie前面也有介绍和演示，我相信大家都会了，这里就不赘述了。一个服务器可能会向服务器端发送多条cookie，但是带有`HttpOnly`的cookie，JavaScript将不能获取。
这里举个例子：
比如我访问某网页，然后查看cookie，可以看到`ASP.NET_SessionId`字段后面有了`HttpOnly`
[
这样就代表JavaScript将不能获取被`HttpOnly`标注的cookie值。清空浏览器地址栏，在其中输入`javascript:alert(document.cookie)`语句测试的话，在弹出的对话框中只有其它字段，就不会看到`ASP.NET_SessionId`字段，这就是`HttpOnly`的作用。
在身份标识字段使用`HttpOnly`可以有效地阻挡XSS会话劫持攻击，但却不能完全阻挡XSS攻击。因为XSS攻击手段很多：模拟用户“正常”操作、盗取用户信息、钓鱼等，仅靠`HttpOnly`是不够的，防御的关键还是要靠过滤输入与输出，要进行代码修复（自定义过滤，自带函数）。
# 8.总结
对于XSS漏洞，它的攻击手段的确很多，层出不穷的，但是其实都可以彻底解决，最关键的是要能够真正的掌控"输入与输出"。