# 【技术分享】IoTroop：一个正快速扩张的新 IoT僵尸网络分析
|
##### 译文声明
本文是翻译文章，文章来源：checkpoint.com
原文地址：
译文仅供参考，具体内容表达以及含义原文为准。
****
译者：[blueSky](http://bobao.360.cn/member/contribute?uid=1233662000)
预估稿费：200RMB
投稿方式：发送邮件至linwei#360.cn，或登陆网页版在线投稿
**前言**
上周，我们的安全研究人员发现了IoT_reaper这个庞大的僵尸网络。一经发现，我们就很快发布了关于该僵尸网络的[初步分析](https://research.checkpoint.com/new-iot-botnet-storm-coming/)，用以提醒网络安全社区。在本文我们将对IoT_reaper僵尸网络进行详细的研究和分析，现阶段我们的主要研究结果包括以下几个方面：
**整个僵尸网络军团已被揭开。**
**我们观察到两组不同的僵尸网络军团：**
**其中一组是C2服务器和样本,主要用于感染和传播。**
**另一组用于第二阶段payload。**
**攻击者能够通过Lua脚本快速灵活地控制被感染的设备。**
**  
**
**僵尸网络军团**
该僵尸网络军团中的每台服务器在恶意软件传播和漏洞利用过程中都扮演着重要的角色，我们已经发现了整个僵尸网络传播的基础设施，具体如下图所示：
恶意软件传播基础设施图
**  
**
**IoTroop恶意软件概述**
IoTroop是IoT_reaper
Botnet在网络攻击活动中第一阶段使用的主要payloads，该恶意软件借用了mirai的源代码，但是在几个关键行为上显著区别于mirai，包括：
1\. C&C服务器已经完全被重新设计，并使用了新的后台。 另外，IoTroop的C&C服务器是用PHP编写的，而原来的Mirai
C&C服务器是用GO编写的。
2\. 随着C&C后台的变化，C&C通信协议也发生了变化，IoTroop恶意软件使用了全新的C&C通信方式。
3\. IoTroop恶意软件不再使用弱口令猜测、而是使用IoT设备漏洞，扫描效率大大提高。
4\.
IoTroop恶意软件不包含任何DDoS功能，实际上我们也没有观察到与该恶意软件有关的任何DDoS攻击，但所有与DDoS相关的功能都由C&C后台进行协调和管理，并作为单独的模块下载。
**  
**
**恶意软件操作细节**
我们检测到IoTroop恶意软件使用的几个变种，虽然这几个变种之间的差异很小，但其却包含完全相同的功能。通常，根据被攻击设备的架构不同，所有变种可以被分为MIPS变种和ARM变种这两类。
**初始化**
一旦IoTroop将其payload在被感染设备上执行，初始化操作步骤与Mirai所采用的步骤相同，主要有：
**混淆初始化字符串**
**阻止系统服务重启（通过发送特定的IOCTL）**
**确保只有一个IoTroops的实例正在运行**
**隐藏argv[0]**
**隐藏进程名称**
然而，IoTroop恶意软件从控制流开始会执行其自己独特的功能，那就是：
通过向eth0，br0，eth1和eth2设备发送IOCTL
0x8927来查询和存储设备的MAC地址。如果恶意软件当前运行的设备运行GoAhead嵌入式Web服务器，则执行以下shell命令：
    ·rm -f /tmp/ftpupload.sh n
    ·ln -s /dev/null /tmp/ftpupload.sh n
    ·rm -r /var /log n
这些操作用于删除与WIFICAM漏洞利用相关的shell脚本，并创建一个到/dev/null的符号链接，以及从设备中清除所有日志文件。  
**禁用其他恶意软件**
IoTroop占用TCP
23端口并禁用任何打开telnet的进程。然后，它扫描设备内存以查找其他IoT恶意软件是否使用以下字符串，如果找到相同的字符串，那么IoTroop将会停止该进程的运行。
    ·   .anime
    ·   REPORT %s:%s
    ·   HTTPFLOOD
    ·   LOLNOGTFO
    ·   zollard
    ·   x58x4Dx4Ex4Ex43x50x46x22 (The word ‘zollard’ Xored with 0x22)
**漏洞扫描**
为了进行漏洞扫描，IoTroop恶意软件会生成一批随机IP，负责生成IP地址的代码与Mirai的代码相同，示例代码如下图所示：
恶意软件会对每个生成的IP地址进行一组漏洞测试，测试以下任何设备或基础设施中是否存在漏洞：
具体的漏洞扫描流量如下所示：
下图是从其中一个漏洞扫描获取的PCAP的示例：
**C＆C通信**
IoTroop的C&C后台服务器由几个组件组成，每个组件负责一个独特的目的。
**reporter 服务器**
reporter
服务器用于接收Bot扫描到的易感染设备信息，该服务器使用字母“f”作为子域名的前缀，通过我们的研究，我们能够识别出两个存活的reporter
服务器，域名如下：
    l  hl852.com（222.112.82.231）
    l  ha859.com（222.112.82.231）
一旦Bot扫描到易感染设备，IoTroop将以下列方式将其数据发送到reporter 服务器：
以下参数被用作上述HTTP GET请求的一部分：
Controller 服务器用于控制所有受感染的设备，并负责执行第二阶段恶意payload以及更新当前的恶意软件。
**Controller 服务器**
每个受感染的设备不断地从控制C&C服务器获取命令，通过我们的研究，我们能够识别出两个存活的Controller 服务器，如下所示：
    ·ha859.com（27.102.101.121）
    ·hl852.com（27.102.101.121）
Controller 服务器以JSON格式向IoTroop客户端发送命令和参数，具体参数如下表所示：
一旦收到命令，IoTroop Bot首先解析该命令然后执行并将执行结果返回给C2服务器。
**downloader**
如果端口存在且为80，则构造格式为“http://
”的字符串，否则将其设置为”http://:”，并将ip，port和path的值填入字符串中。如果C2服务器发来的JSON值为完整路径，那么恶意文件将被保存到命令参数的目录中，否则它将放在/
tmp目录下。在处理构造的URL之前，bot将尝试通过“killall ”命令来停止所有与其名称类似的进程，其中参数取自上述“name”键值。
最后，该URL将被传递给一个download函数，该函数会首先使用lstat检查文件的状态，以验证其是否存在，然后计算该文件内容的哈希值。在打开文件并读取文件后，根据每个操作的状态，构建一个格式为“open：errorsuccess”或“read：errorsuccess”的报告或日志记录字符串，我们观察到该字符串从未被使用过，因此我们猜测该恶意软件仍在进行调整，并处于开发阶段。
在获取到散列值之后，该散列值将与controller
提供的散列值进行比较，以验证磁盘上文件的版本（如果存在）与服务器提供的版本是否不同。如果文件版本不同，Bot将以”r-xrwxrwx”权限生成一个新文件，并与C2服务器建立socket连接。IoTroop将构造一个HTTP
GET请求并将其写入socket，之后它尝试以128个字节的大小块（在请求成功的情况下）从socket中读取其内容，读取到的内容将被写入新创建的文件，并再次检查MD5，以验证是否获取到正确的内容。完成通信后，bot会向controller
发出“FINn”字符串。
**Execute**
文件的具体执行具体取决于“runtype”和“runport”键的值，这两个键值位于“mysel”字符串中。其中，第二个参数表示设备类型，第三个表示TCP端口。在任何情况下，下载的文件都将以给定的“runtype”和“runport”参数执行。
一般地，执行操作可能对应两种情况：一是对应于bot的软件更新事件，用以提示其在未来的进一步变化；另一种情况将对应于任意模块或插件的执行，这可能是Slowloris
DDoS实用程序（在C2服务器上发现）或其他任何应用程序，而且Bot使用“/bin/sh sh -c 
 ”命令产生新的进程，具体如下图所示：
在我们的研究中，我们发现IoTroop恶意软件在其控制流程的不同阶段使用了以下示例。
**  
**
**第二阶段payload**
**概述**
我们观察到另外一个与之相关的样本和C&C服务器，该C2也在[奇虎360的](http://blog.netlab.360.com/iot_reaper-a-rappid-spreading-new-iot-botnet-en/)一篇文章中提到，这些样本似乎用于第二阶段的payload。这些恶意软件可以由downloader服务器的IoTroop恶意软件下载并执行，样本描述如下表所示：
这些样本与不同的C&C服务器通信以报告感染的设备以及从C2下载命令，这些服务器是以域名或者IP地址的形式在样本中进行硬编码的，有时候会有不同的端口，这取决于具体的样本，具体如下表所示：
**  
**
**Lua综合恶意软件分析**
我们从其中一个reporter服务器收集到了大约4700个感染设备的信息，分析过程如下所示。
**概述**
恶意代码中集成了Lua执行环境，从而支持通过Lua脚本编写复杂的攻击指令。 此外，它还复用了Mirai
的代码，由于代码中存在调试字符串，因此我们猜测它是使用Debug模式编译的。但是，除了代码引用的一个调试字符串之外，我们分析的样本似乎没有使用Mirai
代码，这可能是由于编译器优化的原因。多个调试字符串以及详细的输出信息使我们相信这些样本仍在测试或初始部署阶段。
**功能分析**
样本的主要功能的核心部分如下所示：
恶意软件使用Lua解释器的内部函数来初始化Lua引擎，加载LuaSocket库并定义一些在稍后代码会使用的Lua全局变量，具体如下图所示：
之后，将一个功能推送到Lua引擎堆栈，并定义为“attack”，这相当于在Lua脚本中定义一个名为“attack”的函数，“attack”字符串来自Mirai
源代码的调试字符串，具体如下图所示：
恶意软件然后利用内部的Lua函数来执行以下Lua脚本，该脚本以字符串形式嵌入在恶意软件中，具体如下图所示：
该脚本与恶意软件的C&C地址进行通信，首先，它使用以前定义的全局变量将感染细节报告给reporter
C&C（bbk80.com）。然后它进入一个无限循环，并从命令C&C服务器（cbk99.com）下载Lua脚本并执行它们，它通过从C＆C下载“run.lua”文件并将其作为参数传递给以前在main中定义的“attack”函数，“attack”函数会在子进程中执行脚本，具体如下所示：
如果脚本加载或执行失败，恶意软件将以中文显示错误字符串：
目前C＆C服务器上发现的“run.lua”脚本只是打印字符串“Just Test”：
我们可以在名为“run.bak.txt”的Web服务器上看到另一个Lua脚本，它看起来像一个数据收集或者更新脚本，具体如下所示：
攻击者可以轻松更新脚本，轻松指示僵尸网络执行任务。
这个强大的设置使攻击者能够灵活和动态地控制受感染的设备，使他们能够轻松地定制任何具有自定义，可更新的攻击代码，并更改恶意软件的行为，而无需更新二进制本身。
**  
**
**易受攻击的IoT设备**
**  
**
**IOCs**