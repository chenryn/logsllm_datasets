# 【技术分享】IoTroop：一个正快速扩张的新 IoT 僵尸网络分析

## 译文声明
本文为翻译文章，原文来源：checkpoint.com  
原文地址：[请提供具体链接]  
译文仅供参考，具体内容表达及含义以原文为准。

## 译者信息
- 译者：[blueSky](http://bobao.360.cn/member/contribute?uid=1233662000)
- 预估稿费：200 RMB
- 投稿方式：发送邮件至 linwei#360.cn 或登录网页版在线投稿

## 前言
上周，我们的安全研究人员发现了名为 IoT_reaper 的庞大僵尸网络。一经发现，我们迅速发布了初步分析报告，以提醒网络安全社区。在本文中，我们将对 IoT_reaper 僵尸网络进行详细的研究和分析。现阶段的主要研究结果包括以下几个方面：

- 整个僵尸网络已被揭示。
- 我们观察到两组不同的僵尸网络：
  - 一组是 C2 服务器和样本，主要用于感染和传播。
  - 另一组用于第二阶段的 payload。
- 攻击者能够通过 Lua 脚本快速灵活地控制被感染的设备。

## 僵尸网络概述
该僵尸网络中的每台服务器在恶意软件传播和漏洞利用过程中都扮演着重要角色。我们已经发现了整个僵尸网络传播的基础设施，如下图所示：

![恶意软件传播基础设施图](请提供图片链接)

## IoTroop 恶意软件概述
IoTroop 是 IoT_reaper 僵尸网络在网络攻击活动中第一阶段使用的主要 payload。该恶意软件借用了 Mirai 的源代码，但在几个关键行为上与 Mirai 有显著区别，包括：

1. **C&C 服务器**：已完全重新设计，并使用了新的后台。IoTroop 的 C&C 服务器用 PHP 编写，而原来的 Mirai C&C 服务器用 GO 编写。
2. **C&C 通信协议**：随着 C&C 后台的变化，C&C 通信协议也发生了变化，IoTroop 恶意软件使用了全新的 C&C 通信方式。
3. **扫描效率**：IoTroop 恶意软件不再使用弱口令猜测，而是利用 IoT 设备漏洞，从而大大提高了扫描效率。
4. **DDoS 功能**：IoTroop 恶意软件不包含任何 DDoS 功能，但所有与 DDoS 相关的功能由 C&C 后台协调和管理，并作为单独的模块下载。

## 恶意软件操作细节
我们检测到 IoTroop 恶意软件使用的几个变种，尽管这些变种之间的差异很小，但它们包含完全相同的功能。根据被攻击设备的架构不同，所有变种可以分为 MIPS 变种和 ARM 变种两类。

### 初始化
一旦 IoTroop 将其 payload 在被感染设备上执行，初始化步骤与 Mirai 所采用的步骤相同，主要包括：
- 混淆初始化字符串
- 阻止系统服务重启（通过发送特定的 IOCTL）
- 确保只有一个 IoTroop 实例正在运行
- 隐藏 `argv[0]`
- 隐藏进程名称

然而，IoTroop 恶意软件从控制流开始会执行其独特功能：
- 通过向 `eth0`、`br0`、`eth1` 和 `eth2` 设备发送 `IOCTL 0x8927` 来查询和存储设备的 MAC 地址。
- 如果恶意软件当前运行的设备运行 GoAhead 嵌入式 Web 服务器，则执行以下 shell 命令：
  ```sh
  rm -f /tmp/ftpupload.sh
  ln -s /dev/null /tmp/ftpupload.sh
  rm -r /var/log
  ```
  这些操作用于删除与 WIFICAM 漏洞利用相关的 shell 脚本，并创建一个到 `/dev/null` 的符号链接，以及从设备中清除所有日志文件。

### 禁用其他恶意软件
IoTroop 占用 TCP 23 端口并禁用任何打开 telnet 的进程。然后，它扫描设备内存以查找其他 IoT 恶意软件是否使用以下字符串，如果找到相同的字符串，IoTroop 将停止该进程的运行：
- `.anime`
- `REPORT %s:%s`
- `HTTPFLOOD`
- `LOLNOGTFO`
- `zollard`
- `x58x4Dx4Ex4Ex43x50x46x22` (The word ‘zollard’ Xored with 0x22)

### 漏洞扫描
为了进行漏洞扫描，IoTroop 恶意软件会生成一批随机 IP，负责生成 IP 地址的代码与 Mirai 的代码相同。示例代码如下：

```c
// 示例代码
```

恶意软件会对每个生成的 IP 地址进行一组漏洞测试，测试以下设备或基础设施中是否存在漏洞。具体的漏洞扫描流量如下所示：

![漏洞扫描流量示例](请提供图片链接)

## C&C 通信
IoTroop 的 C&C 后台服务器由几个组件组成，每个组件负责一个独特的目的。

### Reporter 服务器
Reporter 服务器用于接收 Bot 扫描到的易感染设备信息。该服务器使用字母“f”作为子域名的前缀。通过我们的研究，我们能够识别出两个存活的 reporter 服务器，域名如下：
- `hl852.com` (222.112.82.231)
- `ha859.com` (222.112.82.231)

一旦 Bot 扫描到易感染设备，IoTroop 将以下列方式将其数据发送到 reporter 服务器：
- HTTP GET 请求参数

### Controller 服务器
Controller 服务器用于控制所有受感染的设备，并负责执行第二阶段恶意 payload 以及更新当前的恶意软件。通过我们的研究，我们能够识别出两个存活的 controller 服务器，如下所示：
- `ha859.com` (27.102.101.121)
- `hl852.com` (27.102.101.121)

Controller 服务器以 JSON 格式向 IoTroop 客户端发送命令和参数，具体参数如下表所示：

| 参数 | 描述 |
|------|------|
| `ip` | 目标 IP 地址 |
| `port` | 目标端口 |
| `path` | 文件路径 |

一旦收到命令，IoTroop Bot 首先解析该命令然后执行并将执行结果返回给 C2 服务器。

### Downloader
如果端口存在且为 80，则构造格式为 `http://<ip>:<port>/<path>` 的字符串，否则将其设置为 `http://<ip>:<port>/`。如果 C2 服务器发来的 JSON 值为完整路径，那么恶意文件将被保存到命令参数的目录中，否则它将放在 `/tmp` 目录下。在处理构造的 URL 之前，bot 将尝试通过 `killall` 命令来停止所有与其名称类似的进程，其中参数取自上述 `name` 键值。

最后，该 URL 将被传递给一个 download 函数，该函数会首先使用 `lstat` 检查文件的状态，以验证其是否存在，然后计算该文件内容的哈希值。在打开文件并读取文件后，根据每个操作的状态，构建一个格式为 `open: error/success` 或 `read: error/success` 的报告或日志记录字符串。我们观察到该字符串从未被使用过，因此我们猜测该恶意软件仍在进行调整，并处于开发阶段。

在获取到散列值之后，该散列值将与 controller 提供的散列值进行比较，以验证磁盘上文件的版本（如果存在）与服务器提供的版本是否不同。如果文件版本不同，Bot 将以 `r-xrwxrwx` 权限生成一个新文件，并与 C2 服务器建立 socket 连接。IoTroop 将构造一个 HTTP GET 请求并将其写入 socket，之后它尝试以 128 个字节的大小块（在请求成功的情况下）从 socket 中读取其内容，读取到的内容将被写入新创建的文件，并再次检查 MD5，以验证是否获取到正确的内容。完成通信后，bot 会向 controller 发出 `FINn` 字符串。

### Execute
文件的具体执行取决于 `runtype` 和 `runport` 键的值，这两个键值位于 `mysel` 字符串中。其中，第二个参数表示设备类型，第三个表示 TCP 端口。在任何情况下，下载的文件都将以给定的 `runtype` 和 `runport` 参数执行。

一般地，执行操作可能对应两种情况：一是对应于 bot 的软件更新事件，用以提示其在未来的进一步变化；另一种情况将对应于任意模块或插件的执行，这可能是 Slowloris DDoS 实用程序（在 C2 服务器上发现）或其他任何应用程序。Bot 使用 `/bin/sh sh -c` 命令产生新的进程，具体如下图所示：

![执行过程示例](请提供图片链接)

在我们的研究中，我们发现 IoTroop 恶意软件在其控制流程的不同阶段使用了以下示例。

## 第二阶段 Payload
### 概述
我们观察到另一个与之相关的样本和 C&C 服务器，该 C2 也在 [奇虎360的文章](http://blog.netlab.360.com/iot_reaper-a-rappid-spreading-new-iot-botnet-en/) 中提到。这些样本似乎用于第二阶段的 payload。这些恶意软件可以由 downloader 服务器的 IoTroop 恶意软件下载并执行，样本描述如下表所示：

| 样本 | 描述 |
|------|------|
| 样本 A | 用于执行特定任务 |
| 样本 B | 用于执行更新操作 |

这些样本与不同的 C&C 服务器通信以报告感染的设备以及从 C2 下载命令，这些服务器是以域名或 IP 地址的形式在样本中进行硬编码的，有时会有不同的端口，具体如下表所示：

| C&C 服务器 | 端口 |
|------------|------|
| example1.com | 80 |
| example2.com | 8080 |

## Lua 综合恶意软件分析
我们从其中一个 reporter 服务器收集到了大约 4700 个感染设备的信息，分析过程如下所示。

### 概述
恶意代码中集成了 Lua 执行环境，从而支持通过 Lua 脚本编写复杂的攻击指令。此外，它还复用了 Mirai 的代码。由于代码中存在调试字符串，我们猜测它是使用 Debug 模式编译的。但是，除了代码引用的一个调试字符串之外，我们分析的样本似乎没有使用 Mirai 代码，这可能是由于编译器优化的原因。多个调试字符串以及详细的输出信息使我们相信这些样本仍在测试或初始部署阶段。

### 功能分析
样本的主要功能的核心部分如下所示：
- 恶意软件使用 Lua 解释器的内部函数来初始化 Lua 引擎，加载 LuaSocket 库并定义一些在稍后代码中会使用的 Lua 全局变量。
- 之后，将一个功能推送到 Lua 引擎堆栈，并定义为 `attack`，这相当于在 Lua 脚本中定义一个名为 `attack` 的函数。
- 恶意软件然后利用内部的 Lua 函数来执行以下 Lua 脚本，该脚本以字符串形式嵌入在恶意软件中。

该脚本与恶意软件的 C&C 地址进行通信，首先，它使用以前定义的全局变量将感染细节报告给 reporter C&C (bbk80.com)。然后它进入一个无限循环，并从命令 C&C 服务器 (cbk99.com) 下载 Lua 脚本并执行它们。它通过从 C&C 下载 `run.lua` 文件并将其作为参数传递给以前在 main 中定义的 `attack` 函数，`attack` 函数会在子进程中执行脚本。

如果脚本加载或执行失败，恶意软件将以中文显示错误字符串。目前 C&C 服务器上发现的 `run.lua` 脚本只是打印字符串 "Just Test"。

我们可以在名为 `run.bak.txt` 的 Web 服务器上看到另一个 Lua 脚本，它看起来像一个数据收集或更新脚本。攻击者可以轻松更新脚本，轻松指示僵尸网络执行任务。这个强大的设置使攻击者能够灵活和动态地控制受感染的设备，使他们能够轻松地定制任何具有自定义、可更新的攻击代码，并更改恶意软件的行为，而无需更新二进制本身。

## 易受攻击的 IoT 设备
[请提供详细列表]

## IOCs
[请提供详细列表]