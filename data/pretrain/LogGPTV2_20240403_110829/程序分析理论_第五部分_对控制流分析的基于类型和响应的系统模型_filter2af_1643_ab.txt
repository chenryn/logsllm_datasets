e_1 —> v_1 e_2 —> v_2 / e_1 op e_2 — v (v_1 op v_2 = v)
依旧是上面的例子
let in结构g为fun返回值
—> fun_F f x => f (fn_Y y => y) fn_z z => z
—>递归函数为 fn_F x => ((fun_F f x => f (fn_Y y => y)) fn_Y y => y)
—> v g返回值为v
## 推理算法 Inference Algorithms
明确了模型，接下来我们要选择算法实现模型。
首先，对于类型而言，除了明确定义与常数的类型确定，有些函数或语句的返回结果无法确定，所以在实际运用中，我们添加α用来表示这些类型的集合，对于一个返回值，我们与α一个类型建立映射。而这个类型我们用断点去命名。
虽然表示了类型，但是类型依旧不能明确，所以需要通过上下文加以限制从而使用算法去判断数据类型。因此我们增加新的语法：U
U是用于建立上下文联系的工具，对于U(int,int) 和U(bool,bool)，我们保持原有id集合记录类型，对于U(t_1 -> t_2 , t’_1
->t’_2)记作θ_1 o θ_2 。θ_1要满足θ_1 t_1 -> θ_1 t’_1 θ_2要满足θ_2(θ_1 t_2) ->θ_2(θ_1
t’_2)。即要想t_1 -> t_2 , t’_1 ->t’_2等价，需要满足t_1和t’_1存在映射， t_2和t’_2存在映射，最终实现 t_1 ->
t_2 和 t’_1 ->t’_2存在映射。而映射关系就是θ_1 o θ_2。对于U(α , t) 和U(t , α)则需要α 是 t 或者 α 是
t没有表示的类型。记作[α -> t]
例子
U(a -> a,(b -> b) -> c)
存在θ_1满足a和b->b存在类型映射，θ_2满足a和c存在类型映射。除此之外，还需要b -> b和c存在类型映射关系，即[a|-> b->b] [a
|-> c] [c |-> b->b]
接下来我们对所有语句类型进行语法描述
W(Γ , c) = (t_c ,id) 对于常数 c ，数据类型为 t_c 保存在 id集合中
W(Γ , x) = (Γ(x) ,id) 对于变量 x ，数据类型为 Γ(x) 保存在 id集合中
W(Γ , fn_π x => e_0) = let α_x be fresh (t_0 ,θ_0 ) = W(Γ[x->α_x] , e_0) in
((θ_0,α_x) -> t_0 , θ_0) 对于函数fn ，将 x 的数据类型先设为空，判断e_0语句中变量的数据类型，和 x 建立映射，保存在θ中。
W(Γ , fun_π f x => e_0) = let α_x α_0 be fresh (t_0 ,θ_0 ) = W(Γ[x->α_x ->
α_0][x -> α_x] , e_0) θ_1 = U(t_0,θ_0,α_0) in (θ_1(θ_0,α_x) ->θ_1 t_0 , θ_1 o
θ_0) 对于递归函数fun f，将 x 和输出的数据类型先设为空，判断e_0语句中变量的数据类型，和 输出 建立映射，保存在θ_0中。将 x
和输出进行复制保存在θ_1中。
W(Γ , e_1 e_2) = let (t_1, θ_1) = W(Γ,e_1) (t_2, θ_2) = W(θ_1 Γ,e_2) α be
fresh θ_3 = U (θ_2 t_1,t_2 -> α ) in (θ_3 α,θ_3 o θ_2 o θ_1 ) 对于e_1 e_2 ，将 返回值
的数据类型先设为空，判断e_1 e_2语句中变量的数据类型，和 返回值 建立映射，保存在θ_3 o θ_2 o θ_1中。
W(Γ , if e_0 then e_1 else e_2) = let (t_0, θ_0) = W(Γ,e_0) (t_1, θ_1) = W(θ_0
Γ,e_1) (t_2, θ_2) = W(θ_1(θ_0 Γ) ,e_2) θ_3 = U (θ_2(θ_1 t_0),bool ) θ_4 = U
(θ_3 t_2,θ_3(θ_2 t_2) ) in (θ_4(θ_3 t_2) , θ_4 o θ_3 o θ_2 o θ_1 ) 对于if，判断e_1
e_2语句中变量的数据类型，根据e_0选择e_1 或 e_2和 返回值 建立映射，保存在θ_4 o θ_3 o θ_2 o θ_1中。
W(Γ , let x = e_1 in e_2) = let (t_1, θ_1) = W(Γ,e_1) (t_2, θ_2) = W((θ_1
Γ)[x->t_1,e_2) in (t_2 , θ_2 o θ_1 ) 对于let in ，判断e_1
语句中变量的数据类型,代入到e_2中判断返回值数据类型，保存在 θ_2 o θ_1中。
W(Γ , e_1 op e_2) = let (t_1, θ_1) = W(Γ,e_1) (t_2, θ_2) = W(θ_1 Γ,e_2) θ_3 =
U (θ_2 t_1,t_op ) θ_4 = U (θ_3 t_2,t_op ) in (t_op,θ_4 o θ_3 o θ_2 o θ_1)
对于e_1 op e_2 ，判断e_1 e_2语句中变量的数据类型，建立类型映射保存到到θ_4 θ_3中 ，将t_op保存在θ_4 o θ_3 o θ_2
o θ_1中。
上面是基于类型的系统模型的算法语法，接下来是基于响应的系统模型。
对于响应系统的拓展，我们用β表示响应集合，用数字区分各个响应。和上面语法类似，我们要建立类型统一：对于U(int,int)和U(bool,bool)没有区别，对于U(t_1
-β-> t_2,t’_1 -β‘->t’_2 )，除了之前的t_1和t’_1 ,t_2和t’_2存在映射外，β和β’也要存在映射。
例子
U(a -1-> a,(b -2->b) -3-> c)
1和3存在映射 [3 |->1]
其余和基于类型的结果一样[a |-> b-2->b][c |-> b -2-> b]
最终得到[3 |->1][a |-> b-2->b][c |-> b -2-> b]
除此之外，我们1 ，2，3进行约束，即与实际建立联系。
例子
(fn_X x=>x) (fn_Y y=>y)
对于上面的例子，我们可以抽象成a -1-> a,(b -2->b) -3-> c
其中，我们将1和X建立联系，2和Y建立联系。从而明确调用内容。
最后我们对之前的例子完整应用上面的算法。
对于let in结构，我们直接将g替换
(fun_F f x => f (fn_Y y => y)) (fn_Z z=>z)
对于(fun_F f x => f (fn_Y y => y))我们可以抽象成g |-> (a -2-> a) -1->b 其中1是F 2是Y
对于(fn_Z z=>z)我们抽象成c -3-> c -4->d
(fun_F f x => f (fn_Y y => y)) (fn_Z z=>z)是 e_1 e_2的结构，所以存在类型匹配，即 a -> c b ->d
1->4 2->3
所以4包含F，3包含Y，同时由于3本身是fn_Z z=>z，所以3包含Z
也就是这一段代码我们可以简化成 (a->a) ->b，其中 a->a的处理机制2和3，也就是YZ机制，->b包含F机制和输出机制。
## 最后
欢迎指教  
 _DR[@03](https://github.com/03 "@03")@星盟_