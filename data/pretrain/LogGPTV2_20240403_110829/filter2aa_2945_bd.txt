The first version of the Min method is used when it’s called using two
int arguments. The second version is used if any other number of int
arguments is supplied. This includes the case in which the method is
called with no arguments. Adding the non-params array method might
be a useful optimization technique because the compiler won’t have to
create and populate so many arrays.
Using params object[ ]
A parameter array of type int is very useful. With it, you can pass any number
of int arguments in a method call. However, what if not only the number of
arguments varies but also the argument type? C# has a way to solve this
problem, too. The technique is based on the facts that object is the root of all
classes and that the compiler can generate code that converts value types
(things that aren’t classes) to objects by using boxing, as described in Chapter
8, “Understanding values and references.” You can use a parameters array of
type object to declare a method that accepts any number of object arguments,
allowing the arguments passed in to be of any type. Look at this example:
Click here to view code image
Download from finelybook PI:EMAIL
400
class Black
{
    public static void Hole(params object[] paramList)
    ...
}
I’ve called this method Black.Hole because no argument can escape from
it:
You can pass the method no arguments at all, in which case the
compiler will pass an object array whose length is 0:
Click here to view code image
Black.Hole(); // converted to Black.Hole(new object[0]);
You can call the Black.Hole method by passing null as the argument.
An array is a reference type, so you’re allowed to initialize an array
with null:
Black.Hole(null);
You can pass the Black.Hole method an actual array. In other words,
you can manually create the array normally generated by the compiler:
Click here to view code image
object[] array = new object[2];
array[0] = "forty two";
array[1] = 42;
Black.Hole(array);
You can pass the Black.Hole method arguments of different types and
these arguments will automatically be wrapped inside an object array:
Click here to view code image
Black.Hole("forty two", 42);
//converted to Black.Hole(new object[]{"forty two", 42});
The Console.WriteLine method
The Console class contains many overloads for the WriteLine method.
One of these overloads looks like this:
Click here to view code image
public static void WriteLine(string format, params object[]
Download from finelybook PI:EMAIL
401
arg);
Although string interpolation has very nearly made this version of
the WriteLine method redundant, this overload was frequently used in
previous editions of the C# language. This overload enables the
WriteLine method to support a format string argument that contains
numeric placeholders, each of which can be replaced at runtime with a
variable of any type that is specified as a list of parameters (placeholder
is replaced with the ith variable in the list that follows). Here’s an
example of a call to this method (the variables fname and lname are
strings, mi is a char, and age is an int):
Click here to view code image
Console.WriteLine("Forename:, Middle Initial:, Last name:,
Age:", fname, mi, lname, age);
The compiler resolves this call into the following:
Click here to view code image
Console.WriteLine("Forename:, Middle Initial:, Last name:,
Age:", new object[4]{fname, mi, lname, age});
Using a params array
In the following exercise, you will implement and test a static method named
Sum. The purpose of this method is to calculate the sum of a variable number
of int arguments passed to it, returning the result as an int. You will do this
by writing Sum to take a params int[] parameter. You will implement two
checks on the params parameter to ensure that the Sum method is completely
robust. You will then call the Sum method with a variety of different
arguments to test it.
Write a params array method
1. Start Microsoft Visual Studio 2017 if it is not already running.
2. Open the ParamsArray solution, which is located in the \Microsoft
Press\VCSBS\Chapter 11\ParamsArray folder in your Documents
folder.
Download from finelybook PI:EMAIL
402
The ParamsArray project contains the Program class in the Program.cs
file, including the doWork method framework that you have seen in
previous chapters. You will implement the Sum method as a static
method of another class called Util (short for “utility”), which you will
add to the project.
3. In Solution Explorer, right-click the ParamsArray project in the
ParamsArray solution, point to Add, and then click Class.
4. In the Add New Item—ParamsArray dialog box, in the middle pane,
click the Class template. In the Name box, type Util.cs, and then click
Add.
The Util.cs file is created and added to the project. It contains an empty
class named Util in the ParamsArray namespace.
5. Add a public static method named Sum to the Util class. This method
should return an int and accept a params array of int values named
paramList. It should look like this:
Click here to view code image
public static int Sum(params int[] paramList)
{
}
The first step in implementing the Sum method is to check the paramList
parameter. Apart from containing a valid set of integers, it can also be
null or it can be an array of zero length. In both of these cases, it is
difficult to calculate the sum, so the best option is to throw an
ArgumentException exception. (You could argue that the sum of the
integers in a zero-length array is 0, but you’ll treat this situation as an
exception in this example.)
6. Add the following code shown in bold to Sum. This code throws an
ArgumentException exception if paramList is null. The Sum method
should now look like this:
Click here to view code image
public static int Sum(params int[] paramList)
{
    if (paramList == null)
    {
Download from finelybook PI:EMAIL
403
        throw new ArgumentException("Util.Sum: null parameter
list");
    }
}
7. Add code to the Sum method to throw an ArgumentException exception
if the length of the parameter list array is 0, as shown here in bold:
Click here to view code image
public static int Sum(params int[] paramList)
{
    if (paramList == null)
    {
       throw new ArgumentException("Util.Sum: null parameter
list");
    }
    if (paramList.Length == 0)
    {
      throw new ArgumentException("Util.Sum: empty parameter
list");
    }
}
If the array passes these two tests, the next step is to add together all the
elements inside the array. You can use a foreach statement to do this,
and you will need a local variable to hold the running total.
8. Declare an integer variable named sumTotal and initialize it to 0,
directly following the code from the preceding step.
Click here to view code image
public static int Sum(params int[] paramList)
{
    ...
    if (paramList.Length == 0)
    {
       throw new ArgumentException("Util.Sum: empty parameter
list");
    }
    int sumTotal = 0;
}
9. Add a foreach statement to the Sum method to iterate through the
paramList array. The body of this foreach loop should add each element
in the array to sumTotal. At the end of the method, return the value of
sumTotal by using a return statement, as shown in bold here:
Download from finelybook PI:EMAIL
404
Click here to view code image
public static int Sum(params int[] paramList)
{
    ...
    int sumTotal = 0;
    foreach (int i in paramList)
    {
        sumTotal += i;
    }
    return sumTotal;
}
10. On the Build menu, click Build Solution, and then confirm that your
solution builds without any errors.
Test the Util.Sum method
1. Display the Program.cs file in the Code and Text Editor window.
2. In the Code and Text Editor window, delete the // TODO: comment and
add the following statement to the doWork method:
Click here to view code image
Console.WriteLine(Util.Sum(null));
3. On the Debug menu, click Start Without Debugging.
The program builds and runs, writing the following message to the
console:
Click here to view code image
Exception: Util.Sum: null parameter list
This confirms that the first check in the method works.
4. Press the Enter key to close the program and return to Visual Studio
2017.
5. In the Code and Text Editor window, change the call to
Console.WriteLine in doWork as shown here:
Console.WriteLine(Util.Sum());
This time, the method is called without any arguments. The compiler
translates the empty argument list into an empty array.
Download from finelybook PI:EMAIL
405
6. On the Debug menu, click Start Without Debugging.
The program builds and runs, writing the following message to the
console:
Click here to view code image
Exception: Util.Sum: empty parameter list
This confirms that the second check in the method works.
7. Press the Enter key to close the program and return to Visual Studio
2017.
8. Change the call to Console.WriteLine in doWork as follows:
Click here to view code image
Console.WriteLine(Util.Sum(10, 9, 8, 7, 6, 5, 4, 3, 2, 1));
9. On the Debug menu, click Start Without Debugging.
Verify that the program builds, runs, and writes the value 55 to the
console.
10. Press Enter to close the application and return to Visual Studio 2017.
Comparing parameter arrays and optional parameters
Chapter 3, “Writing methods and applying scope,” illustrates how to define
methods that take optional parameters. At first glance, it appears there is a
degree of overlap between methods that use parameter arrays and methods
that take optional parameters. However, there are fundamental differences
between them:
A method that takes optional parameters still has a fixed parameter list,
and you cannot pass an arbitrary list of arguments. The compiler
generates code that inserts the default values onto the stack for any
missing arguments before the method runs, and the method is not
aware of which of the arguments are provided by the caller and which
are compiler-generated defaults.
A method that uses a parameter array effectively has a completely
Download from finelybook PI:EMAIL
406
arbitrary list of parameters, and none of them has a default value.
Furthermore, the method can determine exactly how many arguments
the caller provided.
Generally, you use parameter arrays for methods that can take any number
of parameters (including none), whereas you use optional parameters only
where it is not convenient to force a caller to provide an argument for every
parameter.
There is one further situation worth pondering. If you define a method that
takes a parameter list and provide an overload that takes optional parameters,
it is not always immediately apparent which version of the method will be
called if the argument list in the calling statement matches both method
signatures. You will investigate this scenario in the final exercise in this
chapter.
Compare a params array and optional parameters
1. Return to the ParamsArray solution in Visual Studio 2017 and display
the Util.cs file in the Code and Text Editor window
2. Add the following Console.WriteLine statement shown in bold to the
start of the Sum method in the Util class:
Click here to view code image
public static int Sum(params int[] paramList)
{
    Console.WriteLine("Using parameter list");
    ...
}
3. Add another implementation of the Sum method to the Util class. This
version should take four optional int parameters, each with a default
value of 0. In the body of the method, output the message “Using
optional parameters,” and then calculate and return the sum of the four
parameters. The completed method should look like the following code
in bold:
Click here to view code image
class Util
{
    ...
    public static int Sum(int param1 = 0, int param2 = 0, int
Download from finelybook PI:EMAIL
407
param3 = 0, int param4 = 0)
    {
        Console.WriteLine("Using optional parameters");
        int sumTotal = param1 + param2 + param3 + param4;
        return sumTotal;
    }
}
4. Display the Program.cs file in the Code and Text Editor window.
5. In the doWork method, comment out the existing code then add the
following statement:
Click here to view code image
Console.WriteLine(Util.Sum(2, 4, 6, 8));
This statement calls the Sum method, passing four int parameters. This
call matches both overloads of the Sum method.
6. On the Debug menu, click Start Without Debugging to build and run the
application.
When the application runs, it displays the following messages:
Using optional parameters
20
In this case, the compiler-generated code that called the method that
takes four optional parameters. This is the version of the method that
most closely matches the method call.
7. Press Enter and return to Visual Studio.
8. In the doWork method, change the statement that calls the Sum method
and remove the final argument (8), as shown here:
Click here to view code image
Console.WriteLine(Util.Sum(2, 4, 6));
9. On the Debug menu, click Start Without Debugging to build and run the
application.
When the application runs, it displays the following messages:
Click here to view code image
Download from finelybook PI:EMAIL
408
Using optional parameters
12
The compiler still generated code that called the method that takes
optional parameters, even though the method signature does not exactly
match the call. Given a choice between a method that takes optional
parameters and a method that takes a parameter list, the C# compiler
will use the method that takes optional parameters.
10. Press Enter and return to Visual Studio.
11. In the doWork method, change the statement that calls the Sum method
again and add two more arguments:
Click here to view code image
Console.WriteLine(Util.Sum(2, 4, 6, 8, 10));
12. On the Debug menu, click Start Without Debugging to build and run the
application.
When the application runs, it displays the following messages:
Click here to view code image
Using parameter list
30
This time, more arguments are provided than the method that takes
optional parameters specifies, so the compiler-generated code that calls
the method that takes a parameter array.
13. Press Enter and return to Visual Studio.
Summary
In this chapter, you learned how to use a params array to define a method
that can take any number of arguments. You also saw how to use a params
array of object types to create a method that accepts any number of
arguments of any type. Also, you saw how the compiler resolves method
calls when it has a choice between calling a method that takes a parameter
array and a method that takes optional parameters.
Download from finelybook PI:EMAIL
409
If you want to continue to the next chapter, keep Visual Studio 2017
running and turn to  Chapter 12, “Working with inheritance.”
If you want to exit Visual Studio 2017 now, on the File menu, click
Exit. If you see a Save dialog box, click Yes and save the project.
Quick reference
To
Do this
Write a method that
accepts any number
of arguments of a
given type
Write a method whose parameter is a params array
of the given type. For example, a method that
accepts any number of bool arguments is declared
like this:
Click here to view code image
someType Method(params bool[] flags)
{
.    ..
}
Write a method that
accepts any number
of arguments of any
type
Write a method whose parameter is a params array
whose elements are of type object. For example:
Click here to view code image
someType Method(params object[] paramList)
{
    ...
}
Download from finelybook PI:EMAIL
410
CHAPTER 12
Working with inheritance
After completing this chapter, you will be able to:
Create a derived class that inherits features from a base class.
Control method hiding and overriding by using the new, virtual, and
override keywords.
Limit accessibility within an inheritance hierarchy by using the
protected keyword.
Define extension methods as an alternative mechanism to using
inheritance.
Inheritance is a key concept in the world of object-oriented programming.
You can use inheritance as a tool to avoid repetition when defining different
classes that have some features in common and are quite clearly related to
one another. Perhaps they are different classes of the same type, each with its
own distinguishing feature—for example, managers, manual workers, and all
employees of a factory. If you were writing an application to simulate the
factory, how would you specify that managers and manual workers have
some features that are the same but also have features that are different? For
example, they all have an employee reference number, but managers have
different responsibilities and perform tasks different from those of manual
workers.
This is where inheritance proves useful.
Download from finelybook PI:EMAIL
411
What is inheritance?
If you ask several experienced programmers the meaning of the term
inheritance, you will typically get different and conflicting answers. Part of
the confusion stems from the fact that the word inheritance itself has several
subtly different meanings. If someone bequeaths something to you in a will,
you are said to inherit it. Similarly, we say that you inherit half of your genes
from your mother and half of your genes from your father. Both of these uses
of the word have very little to do with inheritance in programming.
Inheritance in programming is all about classification—it’s a relationship
between classes. For example, when you were at school, you probably
learned about mammals, and you learned that horses and whales are
examples of mammals. Each has every attribute that a mammal does (it
breathes air, it suckles its young, it is warm-blooded, and so on), but each
also has its own special features (a horse has hooves, but a whale has flippers
and a fluke).
How can you model a horse and a whale in a program? One way is to
create two distinct classes named Horse and Whale. Each class can
implement the behaviors that are unique to that type of mammal, such as Trot
(for a horse) or Swim (for a whale), in its own way. But how do you handle
behaviors that are common to a horse and a whale, such as Breathe or
SuckleYoung? You can add duplicate methods with these names to both
classes, but this situation becomes a maintenance nightmare, especially if you
also decide to start modeling other types of mammals, such as Human and
Aardvark.
In C#, you can use class inheritance to address these issues. A horse, a
whale, a human, and an aardvark are all types of mammals, so you can create
a class named Mammal that provides the common functionality exhibited by
these types. You can then declare that the Horse, Whale, Human, and
Aardvark classes all inherit from Mammal. These classes then automatically
include the functionality of the Mammal class (Breathe, SuckleYoung, and so
on), but you can also augment each class with the functionality unique to a
particular type of mammal—the Trot method for the Horse class and the
Swim method for the Whale class. If you need to modify the way in which a
common method such as Breathe works, you need to change it in only one
place, the Mammal class.
Download from finelybook PI:EMAIL
412
Using inheritance
You declare that a class inherits from another class by using the following
syntax:
Click here to view code image
class DerivedClass : BaseClass