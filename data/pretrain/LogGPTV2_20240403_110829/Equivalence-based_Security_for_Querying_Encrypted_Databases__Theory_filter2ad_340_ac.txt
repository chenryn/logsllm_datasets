tionality (the keyed hash value could be used to check for
equality). However, this design incurs higher space overhead
than our design with deterministic encryption.
Technically, EunomiaDET contains the following three al-
gorithms: KeyGenDET(1κ, S, δ), EncryptLogDET(L, S, K), and
EncryptPolicyConstantsDET(ϕ, K).
Key generation. The probabilistic algorithm KeyGenDET(·,
·, ·) takes as input the security parameter κ, the plaintext
log schema S, and an equality scheme δ. It returns a key set
K. The key set K is a set of triples of the form hp, a, ki. The
triple means that all cells in column a of table p must be en-
crypted (deterministically) with key k. The constraints on K
are that (a) if p.a contains timestamps, then k = Ktime, and
(b) if hp1.a1, p2.a2i ∈ δ, hp1, a1, k1i ∈ K and hp2, a2, k2i ∈ K,
then k1 = k2.
Encrypting the log. The algorithm EncryptLogDET(·, ·, ·)
takes as input a plaintext log L, its schema S, and the key set
K generated by KeyGen(). It returns a pair eL = heDB, eT i
1134where, eDB is the cell-wise encryption of L with appropriate
keys from K and eT is the mOPED encoding.
Encrypting constants in the policy. To audit over logs
encrypted with EunomiaDET, constants in the policy must
be encrypted too (else, we cannot check whether or not an
atom mentioning the constant appears in the encrypted log).
The algorithm EncryptPolicyConstantsDET(·, ·) takes as input
a plaintext policy ϕ, and a key set K, and returns a policy
ϕ′ in which constants have been encrypted with appropriate
keys. The function works as follows: If, in ϕ, the constant c
appears in the ith position of predicate p, then in ϕ′, the ith
position of p is c deterministically encrypted with the key of
the ith column of p (as obtained from K). Other than this,
ϕ and ϕ′ are identical.
Remarks. The process of audit on a log encrypted with
EunomiaDET requires no cryptographic operations. Com-
pared to an unencrypted log, we only pay the overhead
of having to compare longer ciphertexts and some cost for
looking up the mOPED encoding to compare timestamps.
However, auditing for a policy that requires equality tests
beyond those prescribed by an equality scheme δ is impos-
sible on a log encrypted for δ. To do so, we would have
to re-encrypt parts of the log, which is a slow operation.
Our second log encryption scheme, EunomiaKH, represents a
diﬀerent trade-oﬀ.
4.3 EunomiaKH
EunomiaKH relies on the adjustable keyed hash (AKH)
scheme [35, 34] to support equality tests. We review AKH
and then describe how we build EunomiaKH on it.
1
Abstractly, AKH provides three functions: Hash(k, v) =
P × DET(kmaster, v) × k (P is a point on an elliptic curve,
DET(·, ·) is the deterministic encryption function, and kmaster
is a master encryption key), Token(k1, k2) = k2 × k−1
and
Adjust(w, ∆) = w × ∆. Hash(k, v) returns a keyed hash of
v with key k on a pre-determined elliptic curve with public
parameters. Token(k1, k2) returns a token ∆k1 7→k2 , which
allows transforming hashes created with key k1 to corre-
sponding hashes created with k2. The function Adjust(w, ∆)
performs this transformation: If w = Hash(k1, v) and ∆ =
∆k1 7→k2 , then Adjust(w, ∆) returns the value Hash(k2, v).
The AKH scheme allows the adversary to compare two val-
ues hashed with keys k1 and k2 for equality only when it
knows either ∆k1 7→k2 or ∆k2 7→k1 . Popa et al. prove this
security property, reducing it to the elliptic-curve decisional
Diﬃe-Hellman assumption [35].
To encrypt a log in EunomiaKH, we generate two keys
kh, ke for each column. These are called the hash key and
the encryption key, respectively. Each cell v in the col-
umn is transformed into a pair hHash(kh, v), Encrypt(ke, v)i.
Here, Hash(kh, v) is the AKH hash of v with key kh and
Encrypt(ke, v) is a standard probabilistic encryption of v
with key ke.1 Columns do not share any keys. If audit on
a policy requires testing columns t1.a1 and t2.a2 for equality
and these columns have hash keys kh1 and kh2 , then the
audit algorithm is given one of the tokens ∆kh1
and
∆kh2
. The algorithm can then transform hashes to
test for equality. Each execution of the audit process can be
7→kh2
7→kh1
1The Encrypt(ke, v) component of the ciphertext is returned
to the client Cl as part of the audit output. Cl then decrypts
it to obtain concrete policy violations.
given a diﬀerent set of tokens depending on the policy being
audited and, hence, unlike EunomiaDET, the same encrypted
log supports audit over any policy. However, equality test-
ing is more expensive now as it invokes the Adjust() function.
This increases the runtime overhead of audit.
Formally, EunomiaKH contains the following four algorithms:
KeyGenKH(1κ, S), EncryptLogKH(L, S, K), EncryptPolicyConsta
ntsKH(ϕ, K), and GenerateToken(S, δ, K).
Key generation. The probabilistic key generation algo-
rithm KeyGenKH(·, ·) takes as input a security parameter and
a log schema S and returns a key set K. K contains tuples
of the form hp, a, kh, kei, meaning that column p.a has hash
key kh and encryption key ke. The only constraint is that if
p.a contains timestamps, then kh = Ktime.
Encrypting the log. The algorithm EncryptLogKH(·, ·, ·)
takes as arguments a plaintext log L, its schema S and a
key set K. It returns a pair eL = heDB, eT i where, eDB is
the cell-wise encryption of L with appropriate keys from K
and eT is the mOPED encoding. Because each cell maps
to a pair, each table has twice as many columns in eDB as
in L.
Encrypting policy constants. To audit over EunomiaKH
encrypted logs, constants in the policy must be encrypted.
The algorithm EncryptPolicyConstantsKH(·, ·) takes as input
a plaintext policy ϕ, and a key set K, and returns a policy
ϕ′ in which constants have been encrypted with appropriate
keys taken from K: If constant c appears in the ith position
of predicate p in ϕ and the hash and encryption keys of the
ith column of p in K are kh and ke, respectively, then the
constant c is replaced by hHash(kh, v), Encrypt(ke, v)i in ϕ′.
Generating tokens. GenerateToken(·, ·, ·) is used to gen-
erate tokens that are given to the audit algorithm to enable
it to test for equality on the encrypted log. For each tu-
ple hp.a1, q.a2i in δ, the algorithm GenerateToken(S, δ, K) re-
turns the tuple hp.a1, q.a2, ∆k1 7→k2 i, where hp, a1, k1, i ∈ K
and hq, a2, k2, i ∈ K.
7→kh1
7→kh2
or ∆kh2
Remarks. From the perspective of conﬁdentiality, the same
amount of information is revealed irrespective of whether the
audit algorithm (which may be compromised by the adver-
sary) is given ∆kh1
, because each token
can be computed from the other. However, the actual token
used for comparison by the audit algorithm can have a sig-
niﬁcant impact on its performance. Consider Policy 1 from
Section 1, which stipulates that each name appearing in ta-
ble T1 appears in T2 with the role Doctor. The audit process
will iterate over the names in T1 and look up those names in
T2. Consequently, for performance, it makes sense to index
the hashes of the names in T2 and for the audit algorithm to
use the token ∆k1 7→k2 , where k1 and k2 are the hash keys of
names in T1 and T2, respectively. If, instead, the algorithm
uses ∆k2 7→k1 , then indexing is ineﬀective and performance
suﬀers. The bottom line is that directionality of information
ﬂow during equality testing matters for EunomiaKH. Our
policy analysis, which determines the columns that may be
tested for equality during audit (Section 7) takes this di-
rectionality into account. The equality scheme δ returned
1135by this analysis is directional (even though the use of δ in
EunomiaDET ignored this directionality): if hp1.a1, p2.a2i ∈ δ,
and p1.a1 and p2.a2 have hash keys k1 and k2, then the audit
algorithm uses the token ∆k1 7→k2 , not ∆k2 7→k1 .
4.4 Mutable Order Preserving Encoding with
Displacements (mOPED)
We now discuss the mOPED scheme which produces a
data structure, eT , that allows computation of the boolean
value t1 + d1 ≤ t2 + d2 on the cloud, given only Enc(t1),
Enc(t2), Enc(d1) and Enc(d2). Here, Enc(t) denotes the de-
terministic encryption of t (in the case of EunomiaDET) or
the AHK hash of t (in the case of EunomiaKH) with the ﬁxed
key Ktime. The scheme mOPED extends a prior scheme
mOPE [33], which is a special case d1 = d2 = 0 of our
scheme.
Consider ﬁrst the simple case where the log L and the
policy ϕ are ﬁxed. This means that the set T of values of
the form t + d that the audit process may compare to each
other is also ﬁxed and ﬁnite (because t is a timestamp on
the ﬁnite log L and d ∈ D is a displacement occurring in
the ﬁnite policy ϕ). Suppose that the set T has size N
(note that N ∈ O(|D| · |L|). Then, the client can store on
the cloud a map eT : EncTimeStamp × EncD → {1, . . . , N },
which maps each encrypted timestamp Enc(t) and each en-
crypted displacement Enc(d) to the relative order of t + d
among the elements of T . To compute t1 + d1 ≤ t2 + d2, the
audit process can instead compute eT (Enc(t1), Enc(d1)) ≤
eT (Enc(t2), Enc(d2)). The map eT can be represented in
many diﬀerent ways. In our implementation, we use nested
hash tables, where the outer table maps Enc(t) to an inner
hash table and the inner table maps Enc(d) to the relative
order of t+d. For audit applications where the log and policy
are ﬁxed upfront, this simple data structure eT suﬃces.
The scheme mOPED is more general and allows the
client to incrementally update eT on the cloud. This is
relevant when either the policy or the log changes often. A
single addition or deletion of t or d can cause the map eT to
change for potentially all other elements and, hence, a naive
implementation of eT may incur cost linear in the current
size of T for single updates. Popa et al. show how this cost
can be made logarithmic by interactively maintaining a bal-
anced binary search tree over encrypted values Enc(t) and
using paths in this search tree as the co-domain of eT . We
extend this approach by maintaining a binary search tree
over pairs (Enc(t), Enc(d)), where the search order reﬂects
the natural order over t + d. Since the cloud never sees
plaintext data, the update of this binary search tree and the
map eT must be interactive with the client. We omit the
details of this interactive update and refer the reader to [33]
for details. As the cloud may be compromised, the security
property we prove of mOPED (Section 5.1) holds despite
the adversary observing every interaction with the client.
We note that an audit algorithm never updates eT , so its
execution remains non-interactive.
5. SECURITY ANALYSIS
We now prove that our schemes EunomiaDET, EunomiaKH
and mOPED are secure. We start with mOPED, because
EunomiaDET and EunomiaKH rely on it.
5.1 Security of mOPED
We formalize the security of mOPED as an indistin-
guishability game in which the adversary provides two se-
quences of timestamps and a set of displacements D, then
observes the client and server construct the mOPED data
structure eT on one of these sequences chosen randomly and
then tries to guess which sequence it is. We call this game
IND-CDDA (indistinguishability under chosen distances with
displacement attack). This deﬁnition is directly based on the
IND-OCPA (indistinguishability under ordered chosen plain-
text attack) deﬁnition by Boldyreva et al. [10] and the LoR
security deﬁnition by Pandey and Rouselakis [31]. Because
eT intentionally reveals the relative order of all timestamps
after displacement with constants in D, we need to impose
a constraint on the two sequences chosen by the adversary.
Let ~u[i] denote the ith element of the sequence ~u. We say
that two sequences of timestamps ~u and ~v are equal up
to distances with displacements D, written EDD(~u, ~v, D) iﬀ
|~u| = |~v| and ∀d, d′ ∈ D, i, j. (~u[i]+d ≥ ~u[j]+d′) ⇔ (~v[i]+d ≥
~v[j] + d′). We describe here the IND-CDDA game and the
security proof for mOPED with deterministic encryption;
the case of mOPED with AKH hashes is similar.
IND-CDDA game. The IND-CDDA security game between
a client or challenger Cl (i.e., owner of the audit log) and
an adaptive, probabilistic polynomial time (ppt) adversary
Adv for the security parameter κ proceeds as follows:
1. Cl generates a secret key Ktime using the probabilistic
$← KeyGen(1κ).
key generation algorithm KeyGen. Ktime
$← {0, 1}.
3. Cl creates an empty eT on the cloud.
2. Cl chooses a random bit b. b
4. Adv chooses a set of distances D = {d1, . . . , dn} and
sends it to Cl.
5. Cl and Adv engage in a polynomial of κ number of
rounds of interactions. In each round j:
(a) Adv selects two values v0
j and v1
j and sends them
to Cl.
j , vb
values vb
j + d1, vb
j + d2, . . . , vb
(b) Cl deterministically encrypts the following n + 1
j + dn using Ktime.
(c) Cl interacts with the cloud to insert DET(Ktime, vb
j )
and {DET(Ktime, vb
i=1 into eT . The ad-
versary observes this interaction and the cloud’s
complete state, but not Cl’s local computation.
j + di)}n
6. Adv outputs his guess b′ of b.
Adv wins the IND-CDDA security game iﬀ:
1. Adv guesses b correctly (i.e., b = b′);
2. EDD([v0
0, . . . , v0
0, . . . , v1
m], [v1
m], D) holds, where m is the
number of rounds played in the game.
Let winAdv,κ be a random variable which is 1 if the Adv
wins and 0 if Adv loses. Recall that a function f : N → R is
negligible with respect to its argument κ, if for every c ∈ N
there exists another integer K such that for all κ > K,
f (κ) < x−c. We write negl(κ) to denote some negligible
function of κ.
Theorem 1 (Security of mOPED with deterministic
encryption) Assuming that deterministic encryption is a
1136pseudorandom function, our mOPED scheme is IND-CDDA
secure, i.e., Pr[winAdv,κ = 1] ≤ 1
2 + negl(κ) where the proba-
bility is taken over the random coins used by Adv as well as
the random coins used in choosing the key and the bit b.
Proof. By a hybrid argument. We augment a similar
proof of security for the mOPE scheme [33] to also take
displacements D into account.
mOPED’s security degrades with the size of the con-
stants’ set D occurring in the audited policies. If a system’s
policies do not use constants, mOPED is as secure as its
predecessor mOPE.
Security of mOPED with AKH hash. The security
game for mOPED with AKH hashes is very similar to
IND-CDDA. We replace DET(·, ·) with Hash(·, ·) in the game.