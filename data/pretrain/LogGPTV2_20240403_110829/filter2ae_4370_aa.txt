# 背景
虽然官方文档(man capabilities)和《Linux
内核安全模块深入剖析》书的第六章对"能力"有很全面详细的描述，但是我之前遇到了两个和能力有关的案例，从文档中看不出来原因，只好猜测原因并从源码中确认结论。
本文记录这两个特殊案例，加深自己对"能力"概念的理解，也希望能对linux安全有兴趣的读者有点帮助。
第一个案例是普通用户执行`dumpcap`时可以按照预期运行，而`strace dumpcap`时提示权限不足。如下
更详细的问题背景可以见正文，或者看我提的issue： 
第二个案例是我好奇root用户执行`su - test`变成非root用户后会有哪些能力？
先来看第一个案例。
# 普通用户执行`strace dumpcap`时提示权限不足
## 研究这个问题的起因
在 [基于netfilter的后门](https://mp.weixin.qq.com/s/UL7Rd56MtSB6If_Tu_2N7w)
文章中，我最早是用`dumpcap -i nflog:2333`代替`tcpdump -i nflog:2333`抓包的。
我在安装dumpcap命令、添加x权限后，发现非root用户也可以用dumpcap抓整个主机上的包。如下
    [root@instance-h9w7mlyv ~]# yum install wireshark -y    // 安装dumpcap命令
    [root@instance-h9w7mlyv ~]# chmod +x /usr/bin/dumpcap   // 添加执行权限
    [test@instance-h9w7mlyv ~]$ dumpcap -i eth0     // 抓eth0网卡的包
    Capturing on 'eth0'
    File: /var/tmp/wireshark_eth0_20220907165305_9Quu6X.pcapng
    Packets captured: 17
    Packets received/dropped on interface 'eth0': 17/0 (pcap:0/dumpcap:0/flushed:0/ps_ifdrop:0) (100.0%)
一个普通用户能够获取主机上的所有流量，听着就很不安全，所以我就想看看为什么非root用户可以用dumpcap命令监听网卡流量。
    [test@instance-h9w7mlyv ~]$ getcap /usr/bin/dumpcap
    /usr/bin/dumpcap = cap_net_admin,cap_net_raw+ep
如上，可以看到dumpcap有`cap_net_raw`文件能力。或许你知道只要线程有`cap_net_raw`能力，就可以用`socket(AF_PACKET,
SOCK_RAW, htons(ETH_P_ALL))`创建socket来抓包。
所以可以猜测dumpcap也是用`AF_PACKET socket`抓包的，于是我想执行`strace
dumpcap`看一下系统调用中是否有创建`AF_PACKET socket`。然后发现普通用户执行`strace dumpcap`时提示报错，如下
    [test@instance-h9w7mlyv ~]$ strace -o strace.log dumpcap
    Capturing on 'eth0'
    dumpcap: The capture session could not be initiated on interface 'eth0' (You don't have permission to capture on that device).
    Please check to make sure you have sufficient permissions.
    ...
这里就让我感觉很奇怪：为什么普通用户执行`dumpcap`时可以按照预期运行，而`strace dumpcap`时提示权限不足？
> 还有类似的现象：普通用户`strace ping www.baidu.com`也会提示权限不足
## 为什么普通用户执行`strace dumpcap`时提示权限不足？
`man execve`看到下面一段文档
    The aforementioned transformations of the effective IDs are not performed (i.e., the set-user-ID and set-group-ID bits are ignored) if any of the following is true:
     *  the no_new_privs attribute is set for the calling thread (see prctl(2));
     *  the underlying filesystem is mounted nosuid (the MS_NOSUID flag for mount(2)); or
     *  the calling process is being ptraced.   // 进程正在被ptrace
    The capabilities of the program file (see capabilities(7)) are also ignored if any of the above are true.
[`man capabilities`](https://man7.org/linux/man-pages/man7/capabilities.7.html)看到下面一段文档
    Note: the capability transitions described above may not be performed (i.e., file capabilities may be ignored) for the same reasons that the set-user-ID and set-group-ID bits are ignored; see
    execve(2).
从文档得出结论：只要进程被ptrace，那么execve时就会忽略文件能力和set-uid/set-gid等。因为strace底层就是ptrace，所以似乎这个结论可以解释我遇到的现象。
但是当用root用户给strace文件添加能力后，普通用户运行`strace dumpcap`又可以正常工作，上面的结论就解释不通了。如下
    [root@instance-h9w7mlyv ~]# setcap cap_net_admin,cap_net_raw+ep /usr/bin/strace   // 给strace文件添加能力
    [root@instance-h9w7mlyv ~]#
    [root@instance-h9w7mlyv ~]# su - test     // 切换到普通用户
    ...
    [test@instance-h9w7mlyv ~]$ getcap /usr/bin/strace
    /usr/bin/strace = cap_net_admin,cap_net_raw+ep
    [test@instance-h9w7mlyv ~]$ getcap /usr/bin/dumpcap
    /usr/bin/dumpcap = cap_net_admin,cap_net_raw+ep
    [test@instance-h9w7mlyv ~]$ strace -o strace.log dumpcap      // strace dumpcap现在可以抓包
    Capturing on 'eth0'
    File: /var/tmp/wireshark_eth0_20220908182215_A7Uikl.pcapng
    Packets captured: 11
    Packets received/dropped on interface 'eth0': 11/0 (pcap:0/dumpcap:0/flushed:0/ps_ifdrop:0) (100.0%)
所以看起来，普通用户执行`strace dumpcap`后dumpcap进程的有效能力集是strace文件能力和dumpcap文件能力交集。
那到底是不是这样呢？
## 是不是交集?
`strace dumpcap`时,从用户态看strace原理大概如下
    // fork后，strace子进程能力集和strace进程是相同的
    pid_t pid = fork();
    // 子进程
    if (pid == 0) {
        ptrace(PTRACE_TRACEME,0,NULL,NULL);
        // 加载被调试的程序
        execve("/usr/bin/dumpcap", NULL, NULL);
    }
> 参考 [Linux ptrace 的实现](https://zhuanlan.zhihu.com/p/441291330)
内核在执行execve时，会执行到cap_bprm_set_creds函数，函数栈如下
    [root@instance-h9w7mlyv ~]# bpftrace -e 'kprobe:cap_bprm_set_creds {printf("%s\n",kstack)}'
    Attaching 1 probe...
            cap_bprm_set_creds+1
            security_bprm_set_creds+34
            prepare_binprm+299
            do_execveat_common.isra.37+1274
            __x64_sys_execve+50   // execve系统调用入口
            do_syscall_64+91
            entry_SYSCALL_64_after_hwframe+101
代码位置在：
可以看到cap_bprm_set_creds函数会对能力做交集
    int cap_bprm_set_creds(struct linux_binprm *bprm)
    {
        const struct cred *old = current_cred();
        struct cred *new = bprm->cred;
        ...
      ret = get_file_caps(bprm, &effective, &has_fcap);    // 会从文件扩展属性中找到能力集合，赋值给brpm->cred相应字段
      ...
        if ((is_setid || __cap_gained(permitted, new, old)) &&