We say that an administrative role r is “available” in a state if
some user in U0 is a member of r in that state.
The separate administration restriction simpliﬁes policy analysis
primarily because it ensures that the set of available administrative
roles does not change. Here, we identify a condition under which
changes to the set of available administrative roles, although possi-
ble, are not useful (for reaching a goal) and hence can be ignored.
The condition ensures that, in the initial state, the users in U0
already have all of the administrative permissions of administrative
roles to which they could assign themselves. This is achieved by
requiring that the users in U0 are implicit or explicit members of all
those administrative roles in the initial state.
A miniARBAC policy has hierarchical role assignment with re-
spect to a set A of administrative roles if: for all (cid:104)ar, c, r(cid:105) in can_assign,
if ar is in A and r is an administrative role,4 then ar (cid:23) r. This
implies that a user who can assign users to r is an implicit member
of r. We call this property “hierarchical role assignment” because
it relates the role hierarchy with the can_assign relation.
THEOREM 5. Let I = (cid:104)γ0, ψ, U0, ut, goal(cid:105) be a reachability
problem instance. Let A be the available administrative roles in γ0.
If the miniARBAC policy ψ has hierarchical role assignment with
respect to A, then the goal is reachable iff the goal is reachable via
a plan in which all assign and revoke actions act on the target user.
PROOF:
It is not useful for a user u1 in U0 to assign a user u2 other
than ut in U0 to an administrative role ar, because u1 is already
an implicit member of ar, and making another user a member of
r provides no additional administrative permissions to the group
U0 of users. Note that we allow assignment of administrative roles
to ut, because such assignments can truthify the precondition of a
can_assign rule, and this might enable addition of ut to a regular
role in the goal.
It is not useful to assign a user u2 other than
ut to a regular role, or to revoke u2 from any role, because the
only potential beneﬁt of such administrative actions would be to
truthify the precondition of a rule allowing u2 to be assigned to
an administrative role, and we already showed that the latter role
assignment would be useless.
2
Our analysis algorithms in Sections 3 and 4 exploit separate ad-
ministration only to avoid considering administrative actions that
act on users other than the target user. Therefore, Theorem 5 im-
plies that those algorithms work correctly for problem instances
that satisfy hierarchical role assignment.
4Recall that the concept of administrative role is well-deﬁned even
without the separate administration restriction.
The same idea can be used to optimize reachability analysis for
problem instances I with “partially hierarchical” role assignment,
i.e., when I satisﬁes hierarchical role assignment for a subset A(cid:48)
of the set A of available administrative roles in the initial state.
Administrative actions of roles in A \ A(cid:48) might be useful in reach-
ing the goal. By starting with those actions, and adding additional
actions based on the dependencies induced by the can_assign re-
lation, we can identify a set of administrative actions on non-target
users that might be useful in reaching the goal; other administrative
actions on non-target users can be eliminated.
6. OTHER ANALYSIS PROBLEMS
This section presents algorithms for some other analysis prob-
lems. These algorithms use algorithms for user-role reachability
as a subroutine, so our results from Sections 3–5 are useful here.
These algorithms can invoke specialized algorithms for reachability
when the latter algorithm’s restrictions are satisﬁed (e.g., |ppre| ≤
1). It is straightforward to obtain ﬁxed-parameter tractability re-
sults for these algorithms, based on our complexity results for user-
role reachability.
Role containment. Role containment problem instances have the
form [20]:
in every state reachable from a given initial state, is
every member of role r1 also a member of role r2? This problem
can be reduced to user-role reachability by adding a new role r and
adding a can_assign rule with precondition r1 ∧ ¬r2 and target r.
The containment property holds iff, for every user u, there is not a
reachable state in which u is a member of r. As an optimization,
only users with distinct sets of initial roles need to be considered.
Weakest Preconditions. Weakest precondition queries return the
minimal sets of initial role memberships of the target user for which
a given reachability goal is achievable (for these queries, the initial
state does not specify the initial roles of the target user). An exam-
ple query is: what are the weakest preconditions for a user initially
in DeptChair to assign the target user to HonorsStudent? For poli-
cies satisfying the conditions of the backward algorithm in Section
4, that algorithm can be modiﬁed to efﬁciently answer such queries.
For each leaf node UA in the graph, we compute airs(goal ) taking
UA as the only initial node, and if airs(goal ) is non-empty, then
UA is a weakest precondition, unless we ﬁnd another one that is a
subset of UA.
7. CASE STUDIES
This section brieﬂy describes the ARBAC policies that we used
as case studies. Details of both policies are available from [31].
Our main case study is an ARBAC policy for selected aspects of
a university. The policy includes rules for assignment of users to
various student and employee roles. Student roles are undergradu-
ate student, graduate student, teaching assistant, research assistant,
grader, honors student, graduate student ofﬁcer, graduate educa-
tion committee (which has a student member), etc. Employee roles
are admissions ofﬁcer, assistant professor, dean, dean of admis-
sions, department chair, facilities committee, graduate admissions
committee, graduate education committee, honors program direc-
tor, president, professor, provost, etc. The role hierarchy includes
the relationships President (cid:23) Provost (cid:23) Dean (cid:23) DeptChair (cid:23)
Professor. Sample can_assign rules are: the honors program di-
rector can add undergraduates to the honors student role; the pres-
ident can assign a professor who is not a department chair to the
provost role.
The policy has some limitations. Our ARBAC framework does
not support parameters (of role, permissions, etc.), so the policy is
for a single department, a single class, etc. With a framework that
does, we could easily add parameters (such as department name
and class number) to the policy. We could analyze the resulting
policy by instantiating the parameters with appropriate sets of val-
ues and then applying our current analysis algorithms; we plan to
develop algorithms that handle parameters directly for efﬁciency.
The current policy is only for user-role assignment; this seems like
a good place to start, since the user assignment changes more of-
ten. Policies for administration of the permission-role assignment
and the role hierarchy will be added later. Despite these limitations,
this ARBAC policy is a substantial case study compared to others
in the literature, as discussed in Section 9.
These limitations do not signiﬁcantly affect the characteristics
of the policy that guided this work, such as the size of precondi-
tions. Experience with this policy guided our choice of complexity
parameters and restrictions for the analysis algorithms in Sections
3–4 and suggested realistic values for some of the parameters used
in random policy generation in Section 8. In particular, we note the
following characteristics of the policy:
• Every can_assign rule has at most one positive precondi-
tion, so the analysis algorithm in Section 3 applies.
• The policy does not satisfy separate administration, but it has
hierarchical role assignment with respect to most sets of ad-
ministrative roles, so most reachability properties of the pol-
icy can be analyzed using the algorithms in Sections 3 and 4;
the others can be analyzed using the algorithms in Section 5.
• About 1/3 of the roles are administrative (i.e., have at least
one administrative permission). After the transformation to
eliminate role hierarchy (cf. ﬁrst paragraph of Section 3),
about 1/4 of the roles are negative, about 1/4 are mixed, and
about 2/3 are positive. Since about 3/4 of the roles are non-
negative, the reduction in Section 3 should be effective.
• Problem instances with hierarchical role assignment have at
most two irrevocable roles, because admissions ofﬁcers and
the graduate admissions committee can accept but not expel
students.
Formulating and checking properties of the policy helped uncover
some ﬂaws in it, for example, a place where we accidentally used
Student instead of Undergrad, and places where we forgot to take
role hierarchy into account, e.g., places where we were thinking of
Provost and President as Faculty only, forgetting that these roles
also inherit (indirectly) from Staff.
Here are sample user-role reachability problem instances (with
answers!) for this policy. Can a user initially in DeptChair and
a user initially in Undergrad reach a state in which the latter user
is in HonorsStudent? Yes, because the user in DeptChair can as-
sign himself to HonorsProgramDirector, and then assign the un-
dergrad to HonorsStudent. Can a user initially in Provost and a
user initially in DeptChair reach a state in which latter user is in
Dean? No, because the rule for assignment to Dean has precondi-
tion Professor∧¬DeptChair. The Provost can remove users from
DeptChair, but the Provost cannot add users to Professor (only the
President can do that).
A sample role containment problem instance is: Is TA (i.e., teach-
ing assistant) contained in Grad (i.e., graduate student)? No. Al-
though Grad is a precondition for assignment to TA, a user can be
revoked from Grad while remaining in TA. (This example illus-
trates that preconditions are not necessarily invariants.)
Our second case study is an ARBAC policy for a health care in-
stitution, based on the policy in [7], extended with some aspects
of the policy in [3]. This case study is smaller, but we note that it
shares most of the above characteristics of the university policy. In
particular, every can_assign rule has at most one positive precon-
dition, separate administration is not satisﬁed, about 1/3 of roles are
negative, and problem instances with hierarchical role assignment
have at most one irrevocable role. One difference is less hierarchi-
cal role assignment (i.e., there are more sets of administrative roles
for which the policy does not have hierarchical role assignment).
8. EXPERIMENTAL RESULTS
This section presents the results of experiments done to evalu-
ate the performance of the forward and backward reachability al-
gorithms. The forward algorithm always uses the reduced tran-
sition relation; the backward algorithm includes the partial-order
reduction only when stated explicitly. The algorithms were applied
to the case studies in Section 7 and randomly generated ARBAC
policies. Our algorithm for random policy generation has several
parameters, allowing control over the number of roles, percentage
of negative roles, percentage of irrevocable roles, average number
of positive and negative preconditions per rule, average number of
rules per target role, etc. Generally, we used parameter values (e.g.,
for number of roles) and distributions of values (e.g., for number of
rules per target role) similar to those in the university policy as a
baseline, and then varied selected parameters to explore the effect.
Each data point reported for randomly generated policies is an av-
erage over 32 policies generated using the same parameter values.
In many cases, the standard deviation is comparable in magnitude
to the average; this suggests that statistical ﬂuctuations cause the
observed aberrations in the trends (e.g., there are fewer states and
transitions for |R| = 300 than |R| = 200 in Table 1(b)) and sug-
gests seeking additional parameters to control random policy gen-
eration more tightly. Running times were measured on a 2.8 GHz
Pentium D with 1 GB RAM running Linux 2.6.20. All reported
running times are measured in seconds.
Case Studies. Both policies satisfy the restriction |ppre| ≤ 1
and hence both forward and backward reachability algorithms are
applicable for queries satisfying hierarchical role assignment. For
a variety of reachability queries with |goal| ≤ 2, forward with
slicing terminates in at most 0.01sec and backward with reduction
terminates in at most 0.19sec. For each goal, the forward algorithm
generates at most 2 states and 1 transition, and the backward algo-
rithm with reduction generates at most 5 nodes and 4 transitions.
Evaluation of the Forward Algorithm. Table 1(a) shows the
number of explored states, number of explored transitions, and
running time of the forward algorithm (without slicing) on ran-
domly generated policies with varying number of mixed roles and
with other parameters held constant. All three cost metrics grow
quickly as a function of the number of mixed roles. Table 1(b)
shows the performance of the forward algorithm (without slicing)
on randomly generated policies where the number of roles varies
(the number of rules varies with it, since average number of rules
per role is held constant), and the number of mixed roles is held
constant. In this case, the cost grows much more slowly.
Slicing signiﬁcantly improves the typical performance of the for-
ward algorithm, although it does not change the worst-case perfor-
mance. For most policies, the algorithm explored just one or two
states after slicing, terminating within 0.04 sec.
Evaluation of the Backward Algorithm. We evaluated the back-
ward algorithm on randomly generated policies satisfying |ppre| ≤
1. Table 2(a) shows that the analysis cost grows quickly as a func-
tion of the size of the goal when other parameters are held con-
Mixed
3
5
7
9
11
13
State
8
33
187
350
1404
5593
Trans
18
122
960
2238
10699
50511
(a)
Time
0.07
0.32
2.60
5.62
24.7
128.10
Roles
100
200
300
400
500
State
42
54
41
57
74
Trans
152
193
159
218
266
time
1.09