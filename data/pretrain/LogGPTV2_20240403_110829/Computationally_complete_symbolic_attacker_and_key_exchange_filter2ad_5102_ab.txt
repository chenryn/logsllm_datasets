are uncompromised (with respect to CCA2 security). The rest of
the axioms, such as the one expressing that encryption with un-
compromised key hides the plaintext, or the one expressing non-
malleability are immediate consequences of the computational se-
mantics of the derivability and key-compromise predicates.
We emphasize that we introduce axioms for KDM-CCA2 secu-
rity to be able to analyze protocols for which KDM security is com-
putationally necessary: Unlike [2], in our case, for those protocols
that do not require KDM security for their computational sound-
ness, the use of our IND-CCA2 axioms is sufﬁcient.
After presenting the axioms and their soundness proofs, we look
at three simple examples in Section 11 to illustrate how the axioms
work with special focus on comparing how the IND-CCA2 and the
KDM-CCA2 axioms are applied to key cycles. We show security
in a case when there are no key cycles, then we present a case when
there is a key cycle and the IND-CCA2 axioms provide an attack
while KDM-CCA2 axioms still prove security. Finally we show a
case when there is a key cycle, but as it is under another encryption
it does not danger security even in the IND-CCA2 case and the
security proof goes through. We also show that the axioms in [5]
without key compromise are not sufﬁcient to treat these examples.
Finally, we present the result of our proof of the Amended Sym-
metric Needham-Schroeder Protocol. This protocol ﬁrst distributes
a session key, and then uses the distributed key to share a secret.
Using the IND-CCA2 and INT-CTXT axioms, we proved that the
key is securely distributed, that the shared nonce remains secret,
and that agreement and authentication hold. It is posted online at
the ﬁrst author’s homepage.
The technique of [7] and also this work allows to avoid all re-
strictions mentioned before on the computational world. Once a
protocol is proven secure in our symbolic model with respect to a
set of axioms, then all properties that the computational implemen-
tation has to satisfy for computational security are included in the
axioms. Any number of bad keys are allowed to be generated by the
adversary; any number of corrupted, uncorrupted, or dynamically
corrupted parties can be present. As for parsing of bit strings into
terms, previous soundness results relied on unambiguous parsing.
Within this framework, there is no need for such an assumption. We
do not even need the condition that encryptions, pairing are length
regular (i.e. encryption, pairing of inputs that have the same length
output bit strings of the same length).
As long as indistinguishability properties are not concerned, the
only signiﬁcant restriction remains that the technique is not capable
to detect computational attacks for which the PPT attacker needs
the number of sessions to grow indeﬁnitely as the security param-
eter increases. (It is the general soundness theorem that requires
bounded number of sessions, not the axioms.) However, the usual
Dolev-Yao technique is not capable of doing this either. (ProVerif
for example is unbounded only in the sense that it works for ar-
bitrary number of sessions, but still, if an attack is found, that,
and the corresponding computational attack uses a given number
of sessions independently of the security parameter.) Nevertheless,
it would still be nice to have conditions under which the absence of
successful symbolic BC adversaries means that there are no compu-
tational attacks even if unbounded number of sessions are allowed.
For example, if only CCA2 encryptions and pairings are used to
construct messages, we believe that this statement holds. Analysis
of this is left for future work.
The contributions of this paper include (i) relating the BC tech-
nique to Fitting’s embedding, (ii) syntax and computational seman-
tics of key compromise and derivability with oracle access, (iii) a
library of axioms for symmetric and asymmetric IND-CCA2 and
KDM-CCA2 encryptions and INT-CTXT encryptions as well, (iv)
soundness result of the axioms, (v) short examples to illustrate how
the axioms are used with an emphasis on key-cycles, (vi) summary
of the veriﬁcation of the symmetric Needham-Schroeder protocol
with this tool as a proof of concept. (The NSL proof in [5] can also
be done with the current set of axioms the same way as it was done
there, with minor modiﬁcations only.)
The paper is organized as follows: In Section 2, we give the in-
tuitive description of our new predicates. In Section 3, we present
our ﬁrst-order language, which is an extension of that of BC. We
then summarize in Sections 4 and 5 how Bana and Comon treated
the symbolic and computational executions in [7], deﬁne compu-
tational semantics, and present the general soundness theorem. In
Section 6, we show how the BC technique is related to Fitting’s em-
bedding of classical logic in S4, and show how the general sound-
ness result of Bana and Comon-Lundh follows from Fitting’s theo-
rem. Section 7 is devoted to the semantics of the new derivability
predicates with oracles and their axioms, and Section 8 is the same
for key usability. In Section 9 we discuss congruence of the equal-
ity predicate. In Section 10 we state and prove our soundness theo-
rem for the axioms. In Section 11, we show a few simple examples
of how inconsistency of certain formulas with the axioms can be
proven. Finally, in Section 12, we state the result of the veriﬁcation
of the amended symmetric NS protocol with our tool.
We thank Pedro Adão, Bruno Blanchet, Rohit Chadha and Hu-
bert Comon for helpful suggestions and valuable discussions.
2. DERIVABILITY, KEY COMPROMISE
The most important new aspect of the symbolic execution in [7]
was to replace the DY technique’s ﬁxed deﬁnition of what the sym-
bolic adversary can deduce, x1, ..., xn (cid:96) y, with a derivability
predicate1 x1, ..., xn  y for which the symbolic semantics is not
ﬁxed. Namely, while in the DY technique, x1, ..., xn (cid:96) y meant
that using only the DY rules y can be computed from x1, ..., xn, in
the BC case x1, ..., xn y is given some unﬁxed symbolic interpre-
tation in an abstract model M for which they only require to satisfy
some (computationally sound) axioms. That is, the axioms express
what the symbolic adversary cannot violate. They do imply that
from DY deducibility, satisfaction of the derivability predicate fol-
lows, for example, {y}K , K  y. But in the BC system these rules
are not what the adversary can at most do, but what it can certainly
at least do (in other words, the adversary is not allowed to be unable
to do it). The idea is that symbolic interpretation of x1, ..., xn  y
1Note, that in [7] Bana and Comon-Lundh denoted this predicate
as x1, ..., xn (cid:96) y although (cid:96) is usually reserved for denoting de-
ducibility in a proof system. We ﬁnd that somewhat confusing, so
we use the notation x1, ..., xn  y to emphasize that we do not
mean some speciﬁc deducibility by it, it is a predicate.
1233should be at least as powerful as computability of y from x1, ..., xn
by some probabilistic polynomial time algorithm, and so the only
limitations that we want to put on symbolic satisfaction of  are
limitations that are derived from computational computability.
One of the major innovations we propose here is that axioms be-
come simpler if we allow the use of some oracles for the adversary.
For example, considering IND-CCA2 public key encryption, it is
better to introduce a new derivability predicate, x1, ..., xn aic2 y
with the computational semantics meaning that the interpretation of
y can be derived from the interpretation of x1, ..., xn by a PPT ad-
versary with the help of decryption oracles that decrypt everything
that are not results of encryptions on the left hand side. Similarly,
for the symmetric case, we can introduce x1, ..., xn sic2 y mean-
ing that y can be derived from x1, ..., xn with the help of decryp-
tion oracles and encryption oracles. That is, the algorithm trying
to compute y from the x1, ..., xn is allowed to submit strings to
the oracles for encryption and also for decryption. The decryption
oracle decrypts as long as the submitted string is not an encryp-
tion from x1, ..., xn or an encryption produced by the encryption
oracle. The encryption oracles here are needed, because the adver-
sary cannot himself do encryptions (he does not know the key), and
for this reason the IND-CCA2 deﬁnition for symmetric encryption
allows the submission to the encryption oracle multiple times. In
fact, for uniformity, we allow it for the public case too, as IND-
CCA2 is equivalent for the case of multiple submissions to encryp-
tion oracles [11]. Similarly, we will also deﬁne derivation with
oracle accessibility for KDM-CCA2 encryptions, which is some-
what more tricky. But encryption oracles using which keys? The
answer is, keys honestly generated by the agents during the execu-
tion. We will use the notation Ofor such derivability with O being
either aic2, sic2, akc2, skc2 or nothing, depending on whether we
want asymmetric or symmetric IND-CCA2 oracles, or asymmetric
or symmetric KDM-CCA2 oracles, or no oracles. (O is Fraktur O.)
Our next innovation is key usability for the case when keys are
sent around. More precisely, to match the notation of derivability,
we consider key compromise, which is the negation of key usabil-
ity. We use the notation x1, ..., xn (cid:73)O K, where O again indexes
whether we are talking about IND-CCA2, KDM-CCA2, symmetric
or asymmetric encryption (there is always some oracle here). The
intuitive meaning is that if x1, ..., xn are given to the adversary with
access to the given oracles, then K becomes compromised, encryp-
tion with K is not secure against the adversary any more. For ex-
ample, K, x2 (cid:73)OK. Or, {K}K(cid:48) , K(cid:48) (cid:73)OK. Or, if x1, ..., xn OK,
then x1, ..., xn (cid:73)O K. But, presumably, if x1 is just the ﬁrst half
of K, then x1 (cid:73)O K may still hold, while x1 OK does not. That
is, while x1, ..., xn OK clearly implies x1, ..., xn (cid:73)OK, the other
way is not necessarily true. Nevertheless the two properties, as we
will see, behave very similarly, so we chose similar notation for
them. We also consider key usability for INT-CTXT unforgeabil-
ity.
3. LANGUAGE
The core of the framework used in this paper was introduced by
Bana and Comon-Lundh in [7]. Along with our new innovations,
we present a brief summary of the original system of Bana and
Comon-Lundh as well.
3.1 Terms, Predicates, Formulas
Terms are built out of a set of function symbols F that contains
an unbounded set of names N and an unbounded set of handles
H. Names and handles are constants (zero-arity function symbols).
We use names to denote items honestly generated by agents, while
handles denote inputs of the adversary. Let X be an unbounded set
of variables. A ground term is without variables.
Let P be a set of predicate symbols over terms. We assume here
that P contains the binary predicate = and is used as t1 = t2 and
the following families of of (n + 1)-ary predicates meaning various
sorts of derivability:
t for derivability of the rhs from the lhs with
access to IND-CCA2 oracles in asymmetric case
• t1, ..., tnnt for derivability of the rhs from the lhs
• t1, ..., tn aic2
• t1, ..., tn sic2
• t1, ..., tn akc2
• t1, ..., tn skc2
access to KDM-CCA2 oracles in asymmetric case
access to IND-CCA2 oracles in symmetric case
access to KDM-CCA2 oracles in symmetric case
n
n
n
n
t for derivability of the rhs from the lhs with
t for derivability of the rhs from the lhs with
t for derivability of the rhs from the lhs with
and the following key compromise predicates:
• t1, ..., tn (cid:73)aic2
• t1, ..., tn (cid:73)sic2
• t1, ..., tn (cid:73)akc2
n K meaning the lhs compromises (with oracle
access) secure asymmetric IND-CCA2 encryption with K
n K meaning the lhs compromises (with oracle
access) secure symmetric IND-CCA2 encryption with K
n K meaning the lhs compromises (with ora-
cle access) secure asymmetric KDM-CCA2 encryption with
K• t1, ..., tn (cid:73)skc2
n K meaning the lhs compromises (with or-
acle access) secure symmetric KDM-CCA2 encryption with
K• t1, ..., tn (cid:73)ic
access) INT-CTXT unforgeability of encryptions with K.
We always drop the index n: t1, ..., tn Ot and t1, ..., tn (cid:73)OK.
n K meaning the lhs compromises (with oracle
4. SYMBOLIC EXECUTION
In case of the Dolev-Yao adversary, derivability predicates would
have ﬁxed interpretations. For example,  holds in case of a DY
adversary, if the right-hand side can be computed from the left-hand
side with the DY rules. However, for the symbolic execution, the
BC technique allows any interpretation of the predicates (including
=) that does not contradict some axioms (introduced later).
Accordingly, let M be any ﬁrst-order structure that interprets the
function and predicate symbols of the logic. We denote by DM the
domain of interpretation, and by OM, (cid:73)OM and =M the relations
on DM interpreting O, (cid:73)O, and = respectively. Given an assign-
ment σ of elements in DM to the free variables of term t, we write
[[t]]σM for the interpretation of tσ in M ([[_]]σM is the unique exten-
sion of σ into a homomorphism of F-algebras). For any ﬁrst-order
formula θ, for any ﬁrst-order structure M over the functions F and
predicates P, and any assignment σ of the free variables of θ in
the domain of M, the satisfaction relation M, σ |= θ is deﬁned as
usual in ﬁrst-order logic from the satisfaction of predicates.
4.1 Protocols
Bana and Comon-Lundh set up their technique to be convenient