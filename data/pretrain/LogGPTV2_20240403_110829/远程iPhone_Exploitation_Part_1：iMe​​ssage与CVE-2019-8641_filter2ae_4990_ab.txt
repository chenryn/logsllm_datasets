        # The value of the first (and only) key
        4 => "the_key"
        # ObjC classes are stored in this format
        5 => {
          "$classes" => [
            0 => "NSArray"
            1 => "NSObject"
          ]
          "$classname" => "NSArray"
        }
        6 => {
          "$classes" => [
            0 => "NSSharedKeySet"
            1 => "NSObject"
          ]
          "$classname" => "NSSharedKeySet"
        }
        7 => {
          "$classes" => [
            0 => "NSSharedKeyDictionary"
            1 => "NSMutableDictionary"
            2 => "NSDictionary"
            3 => "NSObject"
          ]
          "$classname" => "NSSharedKeyDictionary"
        }
      ]
      # A reference to the root object in the archive
      "$top" => {
        "root" => {value = 1}
      }
      "$version" => 100000
    }
这里需要注意的一点是，这种序列化格式支持通过`CFKeyedArchiverUID`值引用其中包含的对象。在解档（unarchiving）期间，`NSKeyedUnarchiver`将保留UID与对象的映射，以便可以从同一归档中的多个其他对象引用单个对象。此外，在调用对象的`initWithCoder`方法（在解档期间使用的构造函数）之前，会将引用添加到映射中。这样，可以对对象图进行解码，在这种情况下，可以在当前调用堆栈中进一步解档时引用该对象。有趣的是，在这种情况下，第一个对象在被引用时可能尚未完全初始化。这会产生潜在的BUG，而CVE-2019-8641正是这种情况。
下面是Objective-C
(ObjC)伪代码，由`NSSharedKeyDictionary`和`NSSharedKeySet`类的`initWithCoder`实现。不熟悉ObjC的读者可以想到以下代码结构：
    [obj doXWith:y and:z];
作为对象的方法调用，类似于
    obj->doX(y, z);
在C++中
    -[NSSharedKeyDictionary initWithCoder:coder] {
      self->_keyMap = [coder decodeObjectOfClass:[NSSharedKeySet class]
                             forKey:"NS.skkeyset"];
      // ... decode values etc.
    }
    -[NSSharedKeySet initWithCoder:coder] {
      self->_numKey = [coder decodeInt64ForKey:@"NS.numKey"];
      self->_rankTable = [coder decodeBytesForKey:@"NS.rankTable"];
      // ... copy more fields from the archive
      self->_subSharedKeySet = [coder 
                                decodeObjectOfClass:[NSSharedKeySet class]
                                forKey:@"NS.subskset"]];
      NSArray* keys = [coder decodeObjectOfClasses:[...] 
                             forKey:@"NS.keys"]];
      if (self->_numKey != [keys count]) {
        return fail(“Inconsistent archive);
      }
      self->_keys = calloc(self->_numKey, 8);
      // copy keys into _keys
      // Verify that all keys can be looked up
      for (id key in keys) {
        if ([self indexForKey:key] == -1) {
          NSMutableArray* allKeys = [NSMutableArray arrayWithArray:keys];
          [allKeys addObjectsFromArray:[self->_subSharedKeySet allKeys]];
          return [NSSharedKeySet keySetWithKeys:allKeys];
        }
      }
    }
`indexForKey`的routine实现在下面的initWithCoder(第20行)末尾调用。
它使用键的hash来索引到`_rankTable`，并使用结果作为索引到`_keys`。它递归搜索`subSharedKeySet`中的key，直到找到它或不再有`subSharedKeySet`可用：
    -[NSSharedKeySet indexForKey:] {
      NSSharedKeySet* current = self;
      uint32_t prevLength = 0;
      while (current) {
        // Compute a hash from the key and other internal values of    
        // the KeySet. Convert the hash to an index and ensure that it 
        // is within the bounds of rankTable
        uint32_t rankTableIndex = ...;
        uint32_t index = self->_rankTable[rankTableIndex];
        if (index _numKey) {
          id candidate = self->_keys[index];
          if (candidate != nil) {
            if ([key isEqual:candidate]) {
              return prevLength + index;
            }
          }
        prevLength += self->_numKey;
        current = self->_subSharedKeySet;
      }
      return -1;
    }
根据上面的逻辑，下面的对象图在反序列化时会导致内存损坏:
取消存档期间会发生以下情况：
  * 1.未对`NSSharedKeyDictionary`进行存档，然后对`SharedKeySet`进行解档
  * 2.SharedKeySet1的`initWithCoder`运行到解压它的subSharedKeySet(第6行)的位置 
    * `_numKey` 受到攻击者的完全控制，因为尚未对其进行任何检查（只有在取消存档`_keys`之后才会发生此检查）
    * `_rankTable` 也被完全控制
    * `_keys`仍然是nullptr(因为ObjC对象是通过calloc分配的)
  * 3.SharedKeySet2完全未存档。它的`subSharedKeySet`是对SharedKeySet1的引用（仍在未归档中）。最后，它为`_keys`数组中的所有键调用`indexForKey`：（第20行）
  * 4.由于SharedKeySet2的`rankTable`都为零，所以只有第一个key可以自己查找（请参阅indexForKey：中的第8至15行）。然后在SharedKeySet1上查找第二个key,在这里，由于`_numKey`和`_rankTable`的内容被完全控制，代码将在第10行使用受的控索引对`_keys`（为nullptr）进行索引，从而导致崩溃。
下图显示了崩溃时简化的调用堆栈：
因此，现在取消了大部分任意地址的引用（在本例中是0x414140，因为索引乘以8，即元素大小），并将结果用作ObjC对象指针（“id”）。
但是，对于可以使用此BUG访问的地址有两个限制：
  * 1.该地址必须被8整除（因为_keys数组存储指针大小的值）
  * 2.必须小于32G，因为索引是4字节无符号整数
幸运的是，在iOS上，内存中最有用的Things都位于0x800000000 (32G)以下，因此可以使用这个原语(primitive)进行访问。
事实证明，在适当的情况下，即使是看似无用的空指针解引用，也可以变为功能强大的exploit原语。
此时，没有相关目标进程的地址空间信息。因此，必须要先构造某种信息泄漏。这将是下一篇文章的主题。