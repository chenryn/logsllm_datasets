Therefore, FraudDetective is able to connect multiple ST s
fragmented over different threads that share one thread pool.
The middle example in Figure 4 corresponds to this case. The
parent ST 3 is linked to ST 4 because the thread is invoked
upon receiving a URL via queue, a shared priority queue.
The third case involves using the android.os.Handler
class. Developers usually use this class to make a scheduled
runnable thread. This runnable thread is later invoked upon the
delivery of messages over an android.os.MessageQueue
class instance. Because an ST in this type of invoked runnable
thread is separate from the ST of the parent thread send-
ing a wake-up signal, we revised the AOSP code of an-
droid.os.MessageQueue and android.os.Message
as follows. We modiﬁed android.os.Message to store
the ST of the thread that enqueues a message to an an-
droid.os.MessageQueue instance. When the message
is dequeued, the ST in this message is also delivered to
the recipient
thread that dequeued the message. For the
above process, we modiﬁed the enqueue and dequeue func-
tions, android.os.MessageQueue.enqueueMessage
and android.os.MessageQueue.next. The right side
of Figure 4 represents this last case, which links ST 5 and ST 6
via android.os.Handler.
The last case involves a Chromium WebView instance,
which is not a part of the AOSP. Android apps often
instantiate a Chromium WebView instance via the
an-
droid.webkit.WebView interface and load a web page
that involves loading various sub-resources, including JavaScript
ﬁles, web pages within iframe instances, images, and others.
Unfortunately, the augmenting AOSP cannot capture these sub-
resources loading within this given web page because such
loading occurs in Chromium WebView. To connect the ST
of a thread that loads a web page to an F C that fetches sub-
resources in Chromium WebView, we revised the Android
Chromium and WebView client source code as follows. We
Fig. 5: FraudDetective considers three types of ad fraud, each
of which occurs without user interaction. Type-1 ad fraud
programmatically generates a forged click and lets the app
send click URL requests. Type-2 ad fraud occurs when the
fraud code calls HttpURLConnection to generate an ad
click URL request without any user interactions. Type-3 ad
fraud forcibly causes the victim to visit a target URL using
YouTube or web browsers via an Android intent.
revised the OnLoadResource function in both Chromium
and Android WebView, which is always invoked when loading
resources, to collect the URL of each loaded resource. We also
revised the loadUrl, goBack, reload, and postUrl
methods of the android.webkit.WebView AOSP class
to capture the ST of a thread in which the app loads a web
page. In order to map this ST to a sub-resource loaded in
Chromium, we created an interface that sends and receives
data between android.webkit.WebViewClient in
AOSP and chromium.WebViewContentsClientAdapter
in Chromium. We have FraudDetective to send the ST for
each sub-resource to the AOSP side and then connect this ST
to the ST that invoked a web page loading via a Chrome API
invocation.
D. Detecting ad fraud activities
For a given pair of an F C and its F ST , FraudDetective
identiﬁes an F . To this end, the ad fraud detector checks
whether the F ST originates from a forged interaction or a
genuine user interaction, such as user touch or drag. In this
paper, a forged interaction refers to an artiﬁcial interaction
via programmatic dispatchTouchEvent invocations that
mimic a genuine user touch.
We designed the ad fraud detector to identify three types
of ad fraud activities, as shown in Figure 5. A Type-1 F refers
to a click URL transmission triggered by a forged user click
on a WebView instance rendering ad impressions. A Type-2 F
7
Stack Trace Connection Example 3Stack Trace Connection Example 2classMainActivity{voidclickGeneration() {…Thread t = new Worker();t.start();…} }ST1classWorker extendsThread {@overridevoidrun() {…HttpURLConnectionc =               URL.openConnection();c.getResponseCode();…} }ST2classMainActivity{ThreadPoolpool;voidclickGeneration() {…pool.queue.add(URL);…}}ST3classThreadPoolextends Thread{PriorityBlockingQueuequeue;@overridevoidrun() {…Request req= queue.poll();req.process();…}}ST4classMainActivity{CustomHandlermHandler;voidclickGeneration() {…mHandler.sendMessage(URL);…}}ST5classCustomHandlerextendsHandler {@overridehandleMessage(Message m) {…makeRequest(m.URL);…}}ST6Stack Trace Connection Example 1Stack Trace propagation via a new threadStack Tracepropagation via PriorityBlockingQueueStack Tracepropagation via Android HandlerAd Click URLHttpURLConnection.open(Ad Click URL);Type-2 ad fraudWebView.dispatchTouchEvent(MotionEvent.obtain(…));Click TrafficAd WebViewClickType-1 ad fraudWithout user interactionApplication ChangeWeb BrowserIntent.setAction(VIEW);Intent.setExtra(URL);startActivity(intent);Type-3 ad fraudYouTubeAd NetworkAd Networkis a click URL transmission triggered without user interaction.
Lastly, a Type-3 F is an invocation of other mobile apps via a
cross-app Intent, which brings them into the foreground without
user interaction.
To identify a Type-1 F , FraudDetective checks all the
methods in ST ∈ F ST to see whether there exists a
dispatchTouchEvent invocation. If so, FraudDetective
then checks all the source classes of the method calling this
invocation. When any of these classes is not an Android
internal class, FraudDetective determines that the F ST has
been triggered by a mimicked interaction because either the app
itself or one of its libraries has forged this touch interaction.
For a given pair of an F C and its F ST , FraudDetective
classiﬁes the F ST as a Type-2 or Type-3 AF ST when there is
no user interaction event handler in the F ST . This means that
this F ST does not originate from any user interaction. When
an F occurs via sending a click URL request, FraudDetective
labels this F ST as a Type-2 AF ST . A Type-2 AF ST contains
only the last ST . When an F ST is to send a cross-app
Intent and the argument of this Intent invocation calls other
apps, FraudDetective labels this F ST as a Type-3 AF ST .
FraudDetective only collects the last ST in the F ST when
there is no user interaction.
Interestingly, we observed several ad libraries that invoke
not only mobile browsers, including the Chrome and Samsung
mobile browsers, but also a mobile app associated with a
popular portal website, Naver [61]. The goal of these ad
libraries is to cause users to search using certain keywords in
the Naver mobile app, thus manipulating portal search rankings
by exploiting victims’ mobile devices (§VII-B).
Modules responsible for detected ad fraud. Remind that
FraudDetective computes an AF ST for each detected F . From
this AF ST , FraudDetective classiﬁes whether the app or its
embedded third-party module is responsible for executing the F .
FraudDetective ﬁrst checks whether the app itself invokes the F .
It ﬁrst computes the longest common preﬁx between the source
class that invoked the F and the app package name. When the
namespace nesting of this common preﬁx is two or deeper, such
as com.musicpackage, FraudDetective classiﬁes that the
given F occurs due to the app itself. Otherwise, FraudDetective
deems that the F is due to a third-party library. The employed
heuristic can produce false reports when a hosting app or third-
party libraries obfuscate their class names via ProGuard [45].
To validate the efﬁcacy of this simple policy, we manually
conﬁrmed whether third-party modules were indeed responsible
for executing the fraud detected by FraudDetective in the
73 apps that FraudDetective detected (§VI-B). However, it
is possible for malicious ad-serving web pages to exploit such
third-party modules to initiate ad fraud (§VII-A). In this case,
FraudDetective is still able to attribute an exploited module
within the app to the observed ad fraud, thereby helping auditors
to investigate root causes external to the app itself.
For each AF ST , we extracted three classes within the
AF ST that appear ahead of triggering the F . We then checked
whether these identiﬁed classes were from third-party libraries
via the following three methods: 1) we decompiled each
identiﬁed class and manually checked whether each matched
open-sourced ad SDKs; 2) we checked whether the decompiled
code of each identiﬁed class appeared across the 74 apps
that FraudDetective detected; and 3) we conﬁrmed that each
identiﬁed class did not reference any classes that belonged to
the app itself.
When matching classes to conﬁrm their equivalence, we
compute signatures for these classes based on the argument and
return types of member functions in the classes. For a given
class, we extract the argument and return the value types of all
the member functions and then concatenate these types for its
signature. Note that Bakes et al. [19] suggested the employed
signature-based method for identifying third-party libraries and
claimed its resiliency to common code obfuscations, including
ProGuard.
E. Task scheduling and dynamic testing
The Task Scheduler assigns an analysis task to each analysis
worker. An analysis worker conducts dynamic testing as the
task describes.
Task scheduling. In the default setting, a task speciﬁes ﬁve
Android APKs to test with a testing duration of 1,500 seconds.
To reﬂect app usage patterns of real users, all workers rotate
apps in the foreground every 15 seconds. This means that
one in ﬁve applications is always running in the foreground
while the other applications run in the background. Thus, each
application has 20 chances to run in the foreground, where it
runs for 300 seconds. This round-robin testing strategy helps
cover realistic usage scenarios, such as the execution of apps
in the background and multiple executions of the same app.
Analysis worker. A worker manages an ADB USB connection
with each mobile device. Because this ADB connection can be
disconnected due to the long testing time, the worker monitors
its USB connection status and reconnects when a disconnection
occurs.
A worker also conducts dynamic testing while executing
a testing process. FraudDetective leverages an Android UI
Automator [9] to perform user interactions. FraudDetective
also uses ADB commands in order to trigger certain device
events, such as battery status changes. The testing process
performs the following six actions in random order.
•
•
•
•
•
•
Turn off the screen, wait for two seconds, and then
turn on the screen.
Press the home/back button, wait for one second,
and then press the recent button to go back to the
application [6].
Press the volume down button once, wait for one
second, and then press the volume up button once.
Repeat this procedure ﬁve times.
Change the battery charging status (charge off and on,)
and change the value to 50%, 15%, and 5% at two
seconds intervals.
Open the Android notiﬁcation bar and close it in one
second.
Rotate the screen 90 degrees left, 90 degrees right, and
to the up-side-down landscape position at two second
intervals.
Note that Android malware checks whether the underlying
Android OS is on an emulator, and it often reveals its ill
intent behaviors when it is highly likely that authentic users
are using their devices [1], [51], [77]. Thus, we mimicked
8
# of
5K
∼
100K
500K
∼
1M
100K
∼
500K
download ∼5K
10M
∼
50M
# of apps 7,368 10,828 8,573 5,311 8,793 3,877 2,426
48,172
TABLE II: Number of collected Android apps with download
numbers.
50M∼ Total
5M
∼
10M
1M
∼
5M
996
normal use cases using real Pixel 2 devices and invoked daily
system events, such as volume down/up and battery charging
alerts. Also, Shirazi et al. demonstrated that device users often
watch their smartphones in mobile and trigger the landscape
mode [68]. Thus, we also included such behaviors for testing.
Furthermore, to increase dynamic testing coverage, FraudDe-
tective automatically passes any system/custom consent or full-
screen consent panels by pushing the consent or close buttons
in the current activity. Because a system consent (Android
permission consent) or full-screen consent panel often blocks
the execution of a target app, FraudDetective uses the UI
Automator to parse the current screen’s UI information and
push buttons with “consent,” “yes,” “ok,” “agree,” “conﬁrm,”
“go,” “continue,” “start” and ohter messages to pass pop-up
dialog panels. Note that this ability to conduct dynamic testing
stems from FraudDetective computing of F ST s. Each F ST
carries its user interaction source, which enables FraudDetective
to identify the F .
VI. EVALUATION
A. Experimental setup
We conducted experiments on two host machines running
64-bit Ubuntu 18.04 LTS with Intel i7 8700 (3.2GHz) CPUs
and 16GB of main memory. One host implemented the Task
Scheduler, which distributes analysis tasks. The other one was
an analysis worker that detects ad fraud activities by testing
apps speciﬁed in assigned tasks. This worker was connected
with eight Pixel 2 devices.
Crawled mobile apps. We collected 48,172 Android apps
from Google Play Store. We collected these apps via two
crawling methods. The ﬁrst method is to use the Google Play
unofﬁcial Python API [31], which enables crawling the top 100
ranked apps from each of the 35 Google Play categories. From
April 2019 to September 2020, we collected 10,024 apps. To
cover less popular apps, we also randomly sampled additional
38,148 apps from APK mirror sites [13], [14], [15]. Note that
we deliberately selected these mirror sites because they only
mirror authentic apps from Google Play Store. Table II shows
the popularity of the crawled mobile apps.
B. Ad fraud
FraudDetective classiﬁed each identiﬁed F as one of the
three ad fraud types (§V-D). To test a total of 48,172 apps,
FraudDetective took approximately 36 days with eight Pixel 2
devices. Table III shows the number of detected mobile apps
that commit ad fraud with their fraud types. Speciﬁcally, Fraud-
Detective found 34,232 Type-2 fraud activities, corresponding
to the existence of 34,232 click URL requests triggered without
user interaction. From each app that committed ad fraud,
FraudDetective detected an average of 497 ad fraud requests
per app.
Responsible module
Type
Type-3
# of records
(# of apps)
0 (0)
Type-2
Type-1
Library
Module
# of apps
Ratio
0%
0%
1.5%
98.5%
0%
100%
TABLE III: Number of detected apps of each fraud type and
responsible modules.
0
0
1
65
0
8
34,232 (66)
221 (8)
Library
Library
App
App
App
Fig. 6: Fraudulent app distribution by ad libraries committing
ad fraud.
Table III also presents the number and percentage of
libraries that are responsible for each type of identiﬁed ad fraud.
A responsible module refers to a class within an app committing
observed ad fraud activities (§V-D). Of 66 apps committing
Type-2 ad fraud, FraudDetective reported that 98.5% of the
observed fraud activities stemmed from third-party libraries.
Figure 6 shows the distribution of third-party libraries that
intentionally or unintentionally committed ad fraud in the 73
apps, which include eight apps that committed Type-3 ad fraud,
while the others committed Type-2 ad fraud.
FraudDetective reported that click URL requests originated
from Library A without user interaction in 26 apps. Considering
that Library A is a popular ad service provider with a large
user audience, we further analyzed the reported AF ST s
in these 26 apps and found a new fraud case that abuses
Library A. FraudDetective reported that click URL requests
originated web pages from Library A WebView instances
without user interaction. The web pages included 
tags that generated more than 40 ad click URLs. That is, the
abuser designed an ad campaign that serves ad impressions that
generate click requests, thus committing ad fraud without user
interaction. We describe this in greater detail in Section VII-A.
Meanwhile, Library B and C intentionally committed ad
fraud by creating an ad WebView instance that does not
display on the main screen. This invisible WebView instance
loads click URLs, thereby sending click requests to various
ad services without user interaction. Section VII-B provides
further details. Libraries D, G, J, and K also intentionally
committed ad fraud by generating ad click requests using