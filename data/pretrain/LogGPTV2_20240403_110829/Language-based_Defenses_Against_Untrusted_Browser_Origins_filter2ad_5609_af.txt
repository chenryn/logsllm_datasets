USENIX Association  
22nd USENIX Security Symposium  665
13
666  22nd USENIX Security Symposium 
USENIX Association
policiesthatspecifywhichoriginscanprovidescriptstoawebpagecannotdifferentiatebetweenscriptsoncetheyareloadedintothepage.WeproposeanewdesignthatusesDJStoenforceﬁne-grainedscript-levelaccesscontrolforwebsitese-cretslikeaccesstokensandCSRFtokens.WeimplementitbymodifyingtheFacebookJavaScriptSDKasfollows.WeassumethatthewebsitehasregisteredadedicatedTokenOrigin(e.g.open.login.yahoo.com)withFacebookwhereitreceivestheaccesstoken.Weassumethatthetokenisobtainedandstoredsecurelybythisorigin.Website Origin Facebook Server Token Origin Facebook API Trusted Scripts Access Token XHR Proxy DJS FB.api DJS header id, token API key FB.api() Thetokenoriginthenprovidesaproxyframetothemainwebsite(e.g.*.yahoo.com)thatonlyallowsautho-rizedscriptstousethetoken.Theframelistensforre-questssignedwithJWTusinganAPIkey;ifthesigna-tureisvalid,itwillinjecttheaccesstokenintotherequestandforwardittothenetwork(usingXHR,orJSONPforFacebook),andreturntheresult.Anusefulexten-siontothismechanismwhenprivacyisimportantistoacceptencryptedJWErequestsandencrypttheirresult(weleavethisoutforsimplicity).Onthemainwebsite,weuseaslightlymodiﬁedver-sionoftheFacebookSDKthathasnoaccesstotherealaccesstoken,butstillprovidesthesameclient-sideAPItothewebpage.Wereplacethefunctionthatperformsnetworkrequests(FB.api)withaDJSfunctionthatcon-tainsthesecretAPIkey,hencecanproducesignedre-questsfortheproxyframe.Thisfunctiononlyacceptsrequestsfrompre-authorizedscripts;itexpectsasitsar-gumentaserializedJSONWebToken(JWT)thatcon-tainstherequest,anidentiﬁerforthesourcescript,andasignaturewithascript-speciﬁckey(inpractice,derivedfromtheAPIkeyandthescriptidentiﬁer).Ifthesig-natureisvalid,theAPIrequestissignedwiththeAPIkeyandforwardedtotheproxyframe.Thisfunctioncanalsoenforcescript-levelaccesscontrol;forinstance,itmayallowcross-originscriptstoonlyrequesttheusernameandproﬁlepicture,butnottopostmessages.Forthisdesigntowork,theAPIkeymustbefreshforeachuser,whichcanbeachievedusingtheuser’sses-sionoracookie.Suchkeysshouldhavealifetimelimitcorrespondingtothecachelifetimeofthescriptsthatareinjectedwithsecrettokens.Onemayalsowanttoaddfreshnesstothesignedrequeststoavoidthembeingre-playedtotheproxyframe.Finally,each(trusted)scriptthatrequiresaccesstotheFacebookAPIisinjectedwithaDJSheaderthatpro-videsafunctionabletosigntherequeststoFB.apius-ingitsscriptidentiﬁerandasecrettokenderivedfromtheidentiﬁerandAPIkey.WeprovideasampleoftheDJScodeinjectedintotrustedscriptsbelow,forbasicFacebookAPIaccess(/me)withno(optional)parame-ters.Notethatonlythesign_requestfunctionisdefen-sive;weputitinthescopeofuntrustedcodeusingwithbecauseitpreventsthecallstackissuesofclosures:1with({sign_request:(function(){2vardjcl={/*...*/};3varid="me.js",tok="1f3c...";4var_=function(s){5returns=="/me"/*||s=="..."*/?6djcl.jwt.create(7djcl.djson.stringify({jti:id,req:s}),tok8):""};9returnfunction(s){10if(typeofs=="string")return_(s)}11})(),__proto__:null})12{13//Trustedscript14FB.api(sign_request("/me"),15function(r){alert("Hello,"+r.name)});16}Evaluation.Besidesallowingwebsitestokeeptheac-cesstokensecret,ourdesignletsthemcontrolwhichscriptscanuseitandhow(aformofAPIconﬁnement).Ofcourse,ascriptthatisgivenaccesstotheAPI(viaascriptkey)mayunintentionallyleakthecapability(butnotthekey),inwhichcaseourdesignallowstheweb-sitetoeasilyrevokeitsaccess(usingaﬁlterinFB.api).OurproposalsigniﬁcantlyimprovesthesecurityofFace-bookclients,inwaysitwouldbedifﬁculttoreplicatewithstandardbrowsersecuritymechanisms.WeonlychangeonemethodfromtheFacebookAPIwhichaccountsforlessthan0.5%ofthetotalcode.OurdesignmaintainsDOMaccesstotheAPI,whichwouldbedifﬁculttoachievewithframes.WithouttakingDJCLintoaccount,eachoftheDJSfunctionsaddedtotrustedscriptsislessthan20linesofcode.Wetypecheckedourcodefordefensiveness,andveriﬁedwithProVerifthatitprovidestheexpectedscript-levelauthorizationguaran-tees,andthatitdoesnotleakitssecrets(APIkey,scripttokens)tothebrowser.6.3AnAPIforClient-sideEncryptionInSection2weshowedthatencryptedcloudstorageap-plicationsarestillvulnerabletoclient-sidewebattackslikeXSS(e.g.ConﬁChair,Mega)thatcanstealtheirkeysandcompletelybreaktheirsecurity.Findingandelimi-natinginjectionattacksfromeverypageisnotalways14easy or feasible. Instead, we propose a robust design for
client-side crypto APIs secure despite XSS attacks.
First, we propose to use a defensive crypto library
rather than Java applets (Helios, Wuala, and ConﬁChair)
or non-defensive JavaScript libraries (Mega, SpiderOak).
In the case of Java applets, this also has the advantage of
signiﬁcantly increasing the performance of the applica-
tion (DJCL is up to 100 times faster on large inputs) and
of reducing the attack surface by removing the Java run-
time from the trusted computing base.
Second, we propose a new encrypted local storage
mechanism for applications that need to store encryption
keys in the browser. This mechanism relies on the avail-
ability of an embedded session key that is speciﬁc to the
browser session and is embedded into code served by the
script server, but not given to the host page.
As a practical example, we show how to use both
these mechanisms to make the ConﬁChair conference
management system more resilient against XSS attacks.
ConﬁChair uses the following cryptographic API (types
shown for illustration):
derive_secret_key
//:(input:string,salt:string)->key:string
base64_encode, base64_decode //:string->string
encryptData, decryptData
//:(data:string,key:string)->string
encryptKeypurse//:(key:string,keypurse:json)->string
decryptKeypurse//:(key:string,string)->keypurse:json
When the user logs in, a script on the login page calls
derive_secret_key with the password to compute a se-
cret user key which is stored in localStorage. When the
user clicks on a particular document to download (a pa-
per or a review), the conference page downloads the en-
crypted PDF along with an encrypted keypurse for the
user. It decrypts the keypurse with the user key, stores it
in localStorage, and uses it to decrypt the PDF. The main
vulnerability here is that any same-origin script can steal
the user key (and keypurse) from local storage.
We write a drop-in replacement for this API in DJS.
Instead of returning the real user key and keypurse in
derive_secret_key and decryptKeypurse, our API returns
keys encrypted (wrapped) under a sessionKey. When
decryptData is called, it transparently unwraps the pro-
vided key, never exposing the user key to the page. Both
the encrypted user key and keypurse can be safely stored
in localStorage, because it cannot be read by scripts that
do not know sessionKey. We protect the integrity of these
keys with authenticated encryption.
Our design relies on a secure script server that can de-
liver defensive scripts embedded with session keys. Con-
cretely, this is a web service running in a trusted, isolated
origin (a subdomain like secure.confichair.org)
that accepts GET requests with a script name and a target
origin as parameters. It authenticates the target origin by
verifying the Origin header on the request, and may re-
ject requests for some scripts from some origins. It then
generates a fresh sessionKey, embeds it within the defen-
sive script and sends it back as a GET response. The
sessionKey remains the same for all subsequent requests
in the same browsing session (using cookies).
Evaluation. Our changes to the ConﬁChair website
amount to replacing its Java applet with our own cryp-
tographic API and rewriting two lines of code from the
login page. The rest of the website works without further
modiﬁcation while enjoying a signiﬁcantly improved se-
curity against XSS attacks. Using ProVerif, we analyzed
our API (with an idealized model of the script server and
login page) and veriﬁed that it does not leak the user
key, keypurse, or sessionKey. Our cryptographic API
looks similar to the upcoming Web Cryptography API
standard, except that it protects keys from same-origin
attackers, whereas the proposed API does not.
7 Related Work
Attacks similar to the ones we describe in Section 2 have
been reported before in the context of password manager
bookmarklets [1], frame busting defenses [35], single
sign-on protocols [6, 36, 41], payment processing com-
ponents [42], smartphone password managers [9], and
encrypted cloud storage [5, 10]. These works provide
further evidence for the need for defensive programming
techniques and automated analysis for web applications.
A number of works explore the use of frames and
inter-frame communication to isolate untrusted compo-
nents on a page or a browser extension by relying on
the same origin policy [2, 7, 8, 27, 44]. Our approach
is orthogonal; we seek to protect scripts against same-
origin attackers using defensive programming in stan-
dard JavaScript. Moreover, DJS scripts require fewer
privileges than frames (they cannot open windows, for
example) and unlike components written in full HTML,
DJS programs can be statically analyzed for security.
A variety of JavaScript subsets attempt to protect
trusted web pages from untrusted [20, 26, 28, 29, 31, 32,
34, 39]. Our goal is instead to run trusted components
within untrusted web pages, hence our security goals are
stronger, and our language restrictions are different. For
example, these subsets rely on ﬁrst-starter privilege, that
is, they only offer isolation on web pages where their
setup code runs ﬁrst so that it can restrict the code that
follows. Our scripts do not need such privileges.
[21] proves full abstraction for a compiler from f* (a
subset of ML) to JavaScript. Their theorem ensures that
programmers can reason about deployed f* programs en-
tirely in the semantics of the source language, ignoring
JavaScript-speciﬁc details. As such, their translation is
USENIX Association  
22nd USENIX Security Symposium  667
15
also robust against corruption of the JavaScript environ-
ment. However, there are also some signiﬁcant limita-
tions.
In particular, their theorems do not account for
HTML-level attackers who can, say, open frames and
call their functions. We also reported ﬂaws in their trans-
lation (since ﬁxed in their online version). In compar-
ison, our programs are written directly in a subset of
JavaScript and can defend themselves against stronger
threats, including full HTML adversaries that may exe-
cute before, after, and concurrently with our programs.
Dynamic information ﬂow analyses for various sub-
sets of JavaScript [3, 17, 24] enforce a security property
called noninterference. Our static type system enforces
defensiveness and we analyze security by model extrac-
tion. Relating defensiveness to noninterference remains
future work; we conjecture that DJS may be more suit-
able than JavaScript to static information ﬂow analysis.
8 Conclusion
Given the complexity and heterogeneity of the web pro-
gramming environment and the wide array of threats it
must contend with, it is difﬁcult to believe that any web
application can enjoy formal security guarantees that do
not break easily in the face of concerted attack. Instead
of relying on the absence of web vulnerabilities, this pa-
per presents a defense-in-depth strategy. We start from a
small hardened core (DJS) that makes minimal assump-
tions about the browser and JavaScript runtime, and then
build upon it to obtain defensive security for critical com-
ponents. We show how this strategy can be applied to ex-
isting applications, with little change to their code but a
signiﬁcantly increase in their security. We believe our
methods scale, and lifting these results to protect full
websites that use HTML and PHP is ongoing work.
Acknowledgements The authors would like to thank
David Wagner, Nikhil Swamy and the anonymous re-
viewers for their helpful comments leading to signiﬁ-
cant improvements to this paper. We would also like to
acknowledge the Mozilla and Facebook security teams
for prompt and constructive discussions about our at-
tacks. Bhargavan and Delignat-Lavaud are supported by
the ERC Starting Grant CRYSP. Maffeis is supported by
EPSRC grant EP/I004246/1.
References
[1] B. Adida, A. Barth, and C. Jackson. Rootkits for
JavaScript environments. In WOOT, 2009.
[2] D. Akhawe, P. Saxena, and D. Song. Privilege sep-
aration in HTML5 applications. In USENIX Secu-
rity, 2012.
[3] T. Austin and C. Flanagan. Multiple facets for dy-
namic information ﬂow. In POPL, pages 165–178,
2012.
[4] M. Avalle, A. Pironti, D. Pozza, and R. Sisto.
JavaSPI: A framework for security protocol imple-
mentation.
International Journal of Secure Soft-
ware Engineering, 2:34–48, 2011.
[5] C. Bansal, K. Bhargavan, A. Delignat-Lavaud, and
S. Maffeis. Keys to the cloud: Formal analysis
and concrete attacks on encrypted web storage. In
POST, 2013.
[6] C. Bansal, K. Bhargavan, and S. Maffeis. Discov-
ering concrete attacks on website authorization by
formal analysis. In CSF, pages 247–262, 2012.
[7] A. Barth, C. Jackson, and W. Li. Attacks on
In W2SP,
JavaScript mashup communication.
2009.
[8] A. Barth, C. Jackson, and J.C. Mitchell. Securing
browser frame communication. In USENIX Secu-
rity, 2008.
[9] A. Belenko and D. Sklyarov.
“Secure pass-
word managers” and “Military-grade encryption”
on smartphones: Oh, really? Technical report, El-
comsoft Ltd., 2012.
[10] K. Bhargavan and A. Delignat-Lavaud. Web-based
attacks on host-proof encrypted storage. In WOOT,
2012.
[11] K. Bhargavan, A. Delignat-Lavaud, and S. Maf-
feis. Defensive JavaScript website with testbed,
technical report and supporting materials.
http:
//www.defensivejs.com, 2013.
[12] K. Bhargavan, C. Fournet, A. D. Gordon, and
S. Tse. Veriﬁed interoperable implementations of
security protocols. In CSFW, pages 139–152, 2006.
[13] B. Blanchet and B. Smyth.
ProVerif: Auto-
matic Cryptographic Protocol Veriﬁer, User Man-
ual and Tutorial.
http://www.proverif.inria.fr/
manual.pdf.
[14] P. Canning, W. Cook, W. Hill, W. Olthoff, and
J. Mitchell. F-bounded polymorphism for object-
oriented programming. In FPCA, pages 273–280,
1989.
[15] L. Cardelli.
Extensible records in a pure cal-
culus of subtyping.
In In Theoretical Aspects
of Object-Oriented Programming, pages 373–425.
MIT Press, 1994.
668  22nd USENIX Security Symposium 
USENIX Association
16
[16] D. Crockford. ADsafe: Making JavaScript safe for
advertising. http://www.adsafe.org/, 2008.
[17] W. De Groef, D. Devriese, N. Nikiforakis, and
F. Piessens. FlowFox: a web browser with ﬂexi-
ble and precise information ﬂow control. In CCS,
pages 748–759, 2012.
[18] D. Dolev and A.C. Yao. On the security of public
key protocols. IEEE Transactions on Information
Theory, IT–29(2):198–208, 1983.
[19] M. Finifter, A. Mettler, N. Sastry, and D. Wagner.
Veriﬁable functional purity in Java. In CCS, pages
161–174. ACM, 2008.
[20] M. Finifter, J. Weinberger, and A. Barth. Preventing
Capability Leaks in Secure JavaScript Subsets. In
BDSS, 2010.
[21] C. Fournet, N. Swamy, J. Chen, P. Dagand, P. Strub,
Fully abstract compilation to
and B. Livshits.
JavaScript. In POPL’13, 2013.
[22] P. Haack.
JSON hijacking. http://hhacked.com/
2009/06/25/json-hijacking.aspx, 2009.
[23] D. Hardt. The OAuth 2.0 authorization framework.
IETF RFC 6749, 2012.
[24] D. Hedin and A. Sabelfeld. Information-ﬂow secu-
rity for a core of JavaScript. In CSF, pages 3–18,
2012.
[25] IETF. JavaScript Object Signing and Encryption
http://tools.ietf.org/wg/
(JOSE), 2012.
jose/.
[26] S. Maffeis, J. C. Mitchell, and A. Taly.
Isolating
JavaScript with ﬁlters, rewriting, and wrappers. In
ESORICS’09, 2009.
[27] L. Meyerovich, A. Porter Felt, and M. Miller. Ob-
In
ject views: Fine-grained sharing in browsers.
WWW, 2010.
[28] L. Meyerovich and B. Livshits. ConScript: Spec-
ifying and enforcing ﬁne-grained security policies
for JavaScript in the browser. In IEEE S&P, 2010.
[29] J. Mickens and M. Finifter. Jigsaw: Efﬁcient, low-
effort mashup isolation. In USENIX Web Applica-
tion Development, 2012.
[30] R. Milner. Functions as processes.
In Automata,
Languages and Programming, volume 443, pages
167–180. 1990.
[31] P. Phung, D. Sands, and D. Chudnov. Lightweight
self-protecting JavaScript. In ASIACCS, 2009.
[32] J. Politz, S. Eliopoulos, A. Guha, and S. Krish-
namurthi. ADsafety: Type-based veriﬁcation of
JavaScript sandboxing. In USENIX Security, 2011.
[33] F. Pottier. Type inference in the presence of sub-
typing: from theory to practice. Research Report
3483, INRIA, September 1998.
[34] C. Reis, J. Dunagan, H. Wang, O. Dubrovsky, and
S. Esmeir. BrowserShield: Vulnerability-driven ﬁl-
tering of dynamic HTML. ACM Transactions on
the Web, 1(3), 2007.
[35] G. Rydstedt, E. Bursztein, D. Boneh, and C. Jack-
son. Busting frame busting: a study of clickjacking
vulnerabilities at popular sites. In W2SP’10, 2010.
[36] J. Somorovsky, A. Mayer, A. Worth, J. Schwenk,
M. Kampmann, and M. Jensen. On breaking
SAML: Be whoever you want to be.
In WOOT,
2012.
[37] E. Stark, M. Hamburg, and D. Boneh. Symmetric
cryptography in JavaScript. In ACSAC, pages 373–
381, 2009.
[38] B. Sterne and A. Barth. Content Security Policy
1.0. W3C Candidate Recommendation, 2012.
[39] A. Taly, ´U. Erlingsson, J. C. Mitchell, M. Miller,
and J. Nagra. Automated analysis of security-
critical JavaScript APIs. In IEEE S&P, 2011.
[40] Google Caja Team. A source-to-source translator
for securing JavaScript-based web. http://code.
google.com/p/google-caja/.
[41] R. Wang, S. Chen, and X. Wang. Signing me
onto your accounts through facebook and google:
A trafﬁc-guided security study of commercially de-
ployed single-sign-on web services. In IEEE S&P,
pages 365–379. IEEE Computer Society, 2012.
[42] R. Wang, S. Chen, X. Wang, and S. Qadeer. How
to shop for free online - security analysis of cashier-
as-a-service based web stores. In IEEE S&P, pages
465–480, 2011.
[43] M. Zalewski. The Tangled Web. No Starch Press,
November 2011.
[44] L. Zhengqin and T. Rezk. Mashic compiler:
Mashup sandboxing based on inter-frame commu-
nication. 2012.
USENIX Association  
22nd USENIX Security Symposium  669
17