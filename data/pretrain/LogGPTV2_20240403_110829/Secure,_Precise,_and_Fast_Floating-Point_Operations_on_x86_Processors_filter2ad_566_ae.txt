Impact of Floating-Point Library
7.1
This section evaluates the performance impact of Escort
on the SPEC ﬂoating point benchmarks, as well as on a
security-sensitive program SVMlight, a machine-learning
classiﬁer.
Evaluation Using SPEC Benchmarks. We use the C
and C++ ﬂoating-point applications in the SPEC CPU
2006 benchmark suite with reference inputs. We gen-
erate two versions of each program—the ﬁrst version
(SPEC-LIBC) uses the standard C library functions, and
the second version (SPEC-ESCORT) uses functions from
the Escort library10. We compile the SPEC-LIBC pro-
gram using the Clang/LLVM 3.8 compiler with the -O3
ﬂag, and we disable auto-vectorization while compil-
ing the SPEC-ESCORT program. The following results
demonstrate the worst case performance overhead of Es-
cort for these programs, since we transform all ﬂoating-
point operations in SPEC-ESCORT to use the Escort li-
brary. More precisely, we do not reduce the number of
transformations either using taint tracking or using SMT
solvers.
Table 9 shows that Escort’s overhead is substantial,
with a geometric mean of 32.6×. We expect a lower av-
erage overhead for applications that use secret data, since
taint tracking would reduce the number of ﬂoating-point
operations that would need to be transformed.
Evaluation Using SVMlight. To evaluate Escort’s
overhead on a security-sensitive benchmark, we mea-
sure Escort’s performance on SVMlight, an implemen-
10We also ran the same programs using the FTFP library, but the
programs either crashed due to errors or ran for longer than two hours,
after which they were manually terminated.
Test Case Overhead for
#1
#2
#3
#4
GEO
MEAN
Training
8.66×
30.24×
1.41×
12.75×
8.28×
Overhead for
Classiﬁcation
1.34×
0.96×
1.11×
0.92×
1.07×
Table 10: Overhead of Escort on SVMlight program.
tation of Support Vector Machines in C, using the four
example test cases documented on the SVMlight web-
site11. We mark the training data and the classiﬁcation
data as secret. Before replacing ﬂoating-point computa-
tions, Escort’s taint analysis discovers all ﬂoating-point
computations that depend on the secret data, thus re-
ducing the list of replacements. We also instruct Es-
cort to query the Z3 SMT solver to determine whether
candidate ﬂoating-point computations could use subnor-
mal operands. Escort then replaces these computations
with secure operations from its library. We compile the
baseline (non-secure) program using the Clang/LLVM
3.8 compiler with the -O3 ﬂag, and we disable auto-
vectorization while compiling SVMlight with Escort. We
measure the total execution time using the RDTSC instruc-
tion. Table 10 shows that Escort’s overhead on SVMlight.
We observe that Escort’s overhead on SVMlight is sub-
stantially lower than that on SPEC benchmarks. Using
the md5sum program, we verify that the output ﬁles be-
fore and after transformation of SVMlight are identical.
Impact of Control Flow Obfuscation
7.2
To compare the performance impact of Escort’s con-
trol ﬂow obfuscation technique with that of Raccoon,
we use the same benchmarks that were used to eval-
uate Raccoon [28], while compiling the baseline (non-
transformed) application with the -O3 optimization ﬂag.
Although both Escort and Raccoon obfuscate control
ﬂow and data accesses, we compare the cost of control
ﬂow obfuscation only, since both Escort and Raccoon ob-
fuscate data accesses using the identical technique. Ta-
ble 11 shows the results.
We ﬁnd that programs compiled with Escort have a
signiﬁcantly lower overhead than those compiled with
Raccoon. Escort’s geometric mean overhead is 32%,
while that of Raccoon is 5.32×. The worst-case over-
head for Escort is 2.4× (for ip-tree).
The main reason for the vast difference in overhead
is that Raccoon obfuscates branch instructions at execu-
tion time, which requires the copying and restoring of
11http://svmlight.joachims.org/
84  25th USENIX Security Symposium 
USENIX Association
Benchmark
ip-tree
matrix-mul
radix-sort
ﬁndmax
crc32
genetic-algo
heap-add
med-risks
histogram
map
bin-search
heap-pop
classiﬁer
tax
dijkstra
GEO MEAN
Raccoon
Overhead
1.01×
1.01×
1.01×
1.01×
1.02×
1.03×
1.03×
1.76×
1.76×
2.04×
11.85×
45.40×
53.29×
444.36×
859.65×
5.32×
Escort
Overhead
2.40×
1.01×
1.06×
1.27×
1.00×
1.03×
1.27×
1.99×
2.26×
1.01×
1.01×
1.44×
1.24×
1.67×
1.10×
1.32×
Table 11: Performance comparison of benchmarks com-
piled using Raccoon and Escort. We only compare the
control ﬂow obfuscation overhead, since both Raccoon
and Escort use the same technique for data access obfus-
cation.
the stack for each branch instruction. Since the stack
can be arbitrarily large, such copying and restoring adds
substantial overhead to the running time of the program.
On the other hand, Escort’s code rewriting technique ob-
fuscates code at compile time using basic block predi-
cates, which enables signiﬁcant performance boosts on
the above benchmarks.
8 Conclusions
In this paper, we have presented Escort, a compiler-based
tool that closes side channels that stem from ﬂoating-
point operations. Escort prevents an attacker from in-
ferring secret ﬂoating-point operands through the tim-
ing channel, though micro-architectural state, and also
through off-chip digital side channels, such as memory
address trace.
Escort uses native SSE instructions to provide speed
and precision. Escort’s compiler-based approach enables
it to support a signiﬁcantly larger number of ﬂoating-
point operations (112) than FTFP (19).
Escort’s design motivates further research into hard-
ware support for side-channel resistant systems. For ex-
ample, by allowing software to control the timing of in-
teger instruction latencies and their pipelined execution,
Escort’s guarantees could be extended to instructions be-
yond ﬂoating-point instructions.
Acknowledgments. We thank our shepherd Stephen
McCamant and the anonymous reviewers for their help-
ful feedback. We also thank David Kohlbrenner for giv-
ing us the Firefox timing attack code. We are grateful
to Jia Chen for providing us the pointer analysis library,
and to Joshua Eversmann for help with code and discus-
sions. This research was funded in part by NSF Grants
DRL-1441009, CNS-1314709, and CCF-1453806, C-
FAR (one of the six SRC STARnet Centers sponsored
by MARCO and DARPA), and a gift from Qualcomm.
References
[1] ABADI, M., ET AL. Tensorﬂow: Large-scale machine learn-
ing on heterogeneous distributed systems. Computing Research
Repository abs/1603.04467 (2016).
[2] ACIIC¸ MEZ, O., KOC¸ , C¸ . K., AND SEIFERT, J.-P. On the Power
of Simple Branch Prediction Analysis. In Symposium on Informa-
tion, Computer and Communications Security (2007), pp. 312–
320.
[3] ANDRYSCO, M., KOHLBRENNER, D., MOWERY, K., JHALA,
R., LERNER, S., AND SHACHAM, H. On Subnormal Floating
Point and Abnormal Timing. In Symposium on Security and Pri-
vacy (S&P) (2015), pp. 623–639.
[4] BRUMLEY, D., AND BONEH, D. Remote Timing Attacks are
Practical. Computer Networks 48, 5 (2005), 701–716.
[5] CLEEMPUT, J. V., COPPENS, B., AND DE SUTTER, B. Com-
piler Mitigations for Time Attacks on Modern x86 Processors.
Transactions on Architecture and Code Optimization 8, 4 (Jan.
2012), 23:1–23:20.
[6] CRANE, S., HOMESCU, A., BRUNTHALER, S., LARSEN, P.,
Thwarting Cache Side-Channel Attacks
In Network and Dis-
AND FRANZ, M.
Through Dynamic Software Diversity.
tributed System Security Symposium (2015).
[7] DE MOURA, L., AND BJØRNER, N. Z3: An Efﬁcient SMT
Solver. In International Conference on Tools and Algorithms for
the Construction and Analysis of Systems (2008), pp. 337–340.
[8] DEMMEL, J. W. Effects of Underﬂow on Solving Linear Sys-
tems. Tech. Rep. UCB/CSD-83-128, EECS Department, Univer-
sity of California, Berkeley, Aug 1983.
[9] GANDOLFI, K., MOURTEL, C., AND OLIVIER, F. Electromag-
netic Analysis: Concrete Results. In Third International Work-
shop on Cryptographic Hardware and Embedded Systems (2001),
pp. 251–261.
[10] GROSSSCH ¨ADL, J., OSWALD, E., PAGE, D., AND TUNSTALL,
M. Side-Channel Analysis of Cryptographic Software via Early-
terminating Multiplications. In International Conference on In-
formation Security and Cryptology (2010), pp. 176–192.
[11] ISLAM, M. S., KUZU, M., AND KANTARCIOGLU, M. Access
Pattern Disclosure on Searchable Encryption: Ramiﬁcation, At-
tack and Mitigation. In Network and Distributed System Security
Symposium, NDSS (2012).
[12] JANA, S., AND SHMATIKOV, V. Memento: Learning Secrets
from Process Footprints. In Symposium on Security and Privacy
(S&P) (2012), pp. 143–157.
[13] KAHAN, W.
Interval Arithmetic Options in the Proposed
IEEE Floating-Point Arithmetic Standard. Interval Mathematics
(1980), 99–128.
[14] KOCHER, P. C. Timing Attacks on Implementations of Difﬁe-
Hellman, RSA, DSS, and Other Systems. In Advances in Cryp-
tology (1996), pp. 104–113.
USENIX Association  
25th USENIX Security Symposium  85
[33] STEFANOV, E., VAN DIJK, M., SHI, E., FLETCHER, C. W.,
REN, L., YU, X., AND DEVADAS, S. Path ORAM: An Ex-
tremely Simple Oblivious RAM Protocol. In Conference on Com-
puter and Communications Security (2013), pp. 299–310.
[34] TUKEY, J. Exploratory Data Analysis. Pearson, 1977.
[35] WANG, Y., FERRAIUOLO, A., AND SUH, G. E. Timing Chan-
nel Protection for a Shared Memory Controller. In International
Symposium on High Performance Computer Architecture (2014),
pp. 225–236.
[36] WANG, Z., AND LEE, R. B. New Cache Designs for Thwarting
In International
Software Cache-based Side Channel Attacks.
Symposium on Computer Architecture (2007), pp. 494–505.
[37] WANG, Z., AND LEE, R. B. A Novel Cache Architecture with
Enhanced Performance and Security. In International Symposium
on Microarchitecture (2008), pp. 83–93.
[38] ZHANG, D., ASKAROV, A., AND MYERS, A. C. Predictive
Mitigation of Timing Channels in Interactive Systems. In Confer-
ence on Conference on Computer and Communications Security
(2011), pp. 563–574.
[39] ZHANG, Y., AND REITER, M. K. Duppel: Retroﬁtting Com-
modity Operating Systems to Mitigate Cache Side Channels in
the Cloud. In Conference on Computer and Communications Se-
curity (2013), pp. 827–838.
[15] KOCHER, P. C., JAFFE, J., AND JUN, B. Differential Power
Analysis. In 19th Annual International Cryptology Conference
on Advances in Cryptology (1999), pp. 388–397.
[16] KONG, J., ACIIC¸ MEZ, O., SEIFERT, J., AND ZHOU, H.
Hardware-Software Integrated Approaches to Defend Against
Software Cache-Based Side Channel Attacks.
In International
Conference on High-Performance Computer Architecture (2009),
pp. 393–404.
[17] LATTNER, C., AND ADVE, V. S. LLVM: A Compilation Frame-
work for Lifelong Program Analysis & Transformation.
In In-
ternational Symposium on Code Generation and Optimization
(2004), pp. 75–88.
[18] LIU, C., HARRIS, A., MAAS, M., HICKS, M., TIWARI, M.,
AND SHI, E. GhostRider: A Hardware-Software System for
Memory Trace Oblivious Computation. In International Confer-
ence on Architectural Support for Programming Languages and
Operating Systems (2015), pp. 87–101.
[19] LUK, C., ET AL. Pin: Building Customized Program Analysis
Tools with Dynamic Instrumentation. In Conference on Program-
ming Language Design and Implementation (2005), pp. 190–200.
[20] MAAS, M., LOVE, E., STEFANOV, E., TIWARI, M., SHI, E.,
ASANOVIC, K., KUBIATOWICZ, J., AND SONG, D. PHAN-
TOM: Practical Oblivious Computation in a Secure Processor. In
Conference on Computer and Communications Security (2013),
pp. 311–324.
[21] MARTIN, R., DEMME, J., AND SETHUMADHAVAN, S. Time-
Warp: Rethinking Timekeeping and Performance Monitoring
Mechanisms to Mitigate Side-Channel Attacks. In International
Symposium on Computer Architecture (2012), pp. 118–129.
[22] MASTI, R. J., ET AL. Thermal Covert Channels on Multi-core
Platforms. In USENIX Security Symposium (2015), pp. 865–880.
[23] MOLNAR, D., PIOTROWSKI, M., SCHULTZ, D., AND WAG-
NER, D. The Program Counter Security Model: Automatic De-
tection and Removal of Control-Flow Side Channel Attacks. In
International Conference on Information Security and Cryptol-
ogy (2005), pp. 156–168.
[24] MUCHNICK, S. Advanced Compiler Design and Implementation.
Morgan Kaufmann Publishers Inc., 1997.
[25] MULLER, J.-M. On the deﬁnition of ulp(x). Tech. Rep. 2005-
009, ENS Lyon, February 2005.
[26] OSVIK, D. A., SHAMIR, A., AND TROMER, E. Cache Attacks
and Countermeasures: the Case of AES. In RSA Conference on
Topics in Cryptology (2006), pp. 1–20.
[27] PERCIVAL, C. Cache Missing for Fun and Proﬁt. In Proceedings
of the Technical BSD Conference (2005).
[28] RANE, A., LIN, C., AND TIWARI, M. Raccoon: Closing Dig-
In USENIX
ital Side-channels Through Obfuscated Execution.
Conference on Security Symposium (2015), pp. 431–446.
[29] REN, L., YU, X., FLETCHER, C., VAN DIJK, M., AND DE-
VADAS, S. Design Space Exploration and Optimization of Path
Oblivious RAM in Secure Processors. In International Sympo-
sium on Computer Architecture (2013), pp. 571–582.
[30] SAKURAI, K., AND TAKAGI, T. A Reject Timing Attack on an
IND-CCA2 Public-key Cryptosystem. In International Confer-
ence on Information Security and Cryptology (2003), pp. 359–
374.
[31] SCHINDLER, W. A Timing Attack Against RSA with the Chi-
nese Remainder Theorem. In International Workshop on Crypto-
graphic Hardware and Embedded Systems (2000), pp. 109–124.
[32] SHI, E., CHAN, T. H., STEFANOV, E., AND LI, M. Oblivious
RAM with O((logN)3) Worst-Case Cost. In Advances in Cryp-
tology (2011), pp. 197–214.
86  25th USENIX Security Symposium 
USENIX Association