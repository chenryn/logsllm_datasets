14
6
10
4
12
5
9
5
8
3
7
5
5
3
The efﬁciency tables for HoVer3
in the full technical report [9].
4.2. Short write IO costs
2,1 and HoVer3
1,1 are found
The term “short write” indicates a host write to any por-
tion of a data element (bit update).
In our HoVer code
design, every data element touches exactly t parity ele-
ments. Consequently, the short write update cost is exactly
2(t + 1) IO seeks, achieved using a standard read-modify-
write algorithm for the t parity values. This is optimal for
most codes (the exception are (near) symmetric codes with
the same number of parity elements as data elements, such
as the WEAVER codes [10, 11]). This bound matches that
for vertical MDS codes (e.g., X-code [22]) and is better than
that for horizontal MDS codes (e.g., Blaum-Roth [4]) where
some data elements touch more than t = 2 parity elements.
4.3. Reconstruction costs
The HoVer codes show their most signiﬁcant advantage
over most other codes with respect to reconstruction costs.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
Consider the HoVer2
1,1 code (a similar argument applies to
t−1,1 codes for t = 3,4 when less than t strips are lost
HoVert
and a variation applies to HoVer3
1,1 as well). We discuss
two scenarios: (a) reconstruction when one strip is lost, and
(b) reconstruction when two strips are lost. The former is
called a Degraded array, and the latter a Critical array. In
the discussion below, we ignore cases where the h-parity
strip is lost (as that is the easy case).
Degraded: When one data/parity strip is lost, there are
r data elements that are lost. A host read to one of these
strips requires reconstruction of the lost data. RAID4 (or
RAID5) with n data strips requires reading n chunks of data
from n strips (the n− 1 remaining data strips and the parity
strip). An XOR computation with n inputs is then required
to reconstruct the lost data. This same argument applies to
any horizontal code such as EVENODD or RDP. It is easy
to verify that each of the vertical codes (X-code, BCP, or
ZZS) requires reading from n− 2 strips (on an array of size
n) and an XOR computation with n− 2 inputs.
This method of using the h-parity may also be used for
the HoVer codes, since they contain a RAID4 subcode as
well. But the HoVer codes also have the v-parity elements
available for reconstruction. Use of these parity elements
requires reading from only r strips. Since r ≤ n− 2 (for the
HoVer2
1,1 code), we have a net performance advantage of the
HoVer codes over the other known codes.
Furthermore, even for complete reconstruction of all the
data and parity on the lost strip, we see from the proof of
Theorem 3, that only a subportion of the entire (remaining)
stripe need be accessed and every XOR computation has
only r inputs. In contrast for most other codes, the entire
stripe needs to be accessed and most reconstruction formu-
las have order n inputs (or more).
By Theorem 2, we can vary the size of r below the bound
of Theorem 3. A smaller r improves the reconstruction
costs linearly (with a trade-off in efﬁciency, however).
Critical: Suppose two data/parity strips are down in a
HoVer2
1,1 array. The proof of Theorem 3 showed that the re-
covery algorithm involved following reconstruction chains.
For most failure scenarios in the 1-shift code and all sce-
narios in the 2-shift code, there are at least two such chains.
Most scenarios have many (split) chains, and in some in-
stances, these chains are only one element long. (In fact,
as the gap between the lost strips increases (modulo n), the
number of chains of length one increases smoothly.) For
all vertical MDS codes and most horizontal codes, recon-
struction follows such chains as well, but in these cases the
chains are generally quite long and there are at most two
such chains. Longer chains imply more work to reconstruct
the elements near the end of the chains.
In addition, the
maximum length of the chains is proportional to the num-
ber of rows. So, HoVer codes which support constructions
with variable r have more efﬁcient and parameterizable re-
construction chains.
In addition, it is easy to see that if two lost strips are
separated by r + s consecutive strips, then each strip can be
recovered independently, using only the v-parity row. This
follows because no diagonal intersects both strips so that all
recovery chains have length one.
4.4. Extended fault tolerance
The ability to vary the parameter r has an additional ad-
vantage. Suppose r is small compared to n. In this case,
the array can recover from certain instances of more than t
failures. As we saw above for the HoVer2
1,1 case, if the gap
between two lost strips is large enough, each can be recov-
ered as an independent instance of a single failure (this is
a property also shared by WEAVER codes [10, 11]). More
precisely, the HoVer2
1,1 code can recover from any number
of failures so long as in any set of r + s consecutive strips
(with wrap-around), there are no more than two lost strips.
(If r is too large, then there is no room for such combina-
tions.) None of the MDS codes have this property (in a
single code instance); this is a direct consequence of the
MDS property. Similar extended fault tolerance is available
for the other HoVer code constructions we have given, pro-
vided r is sufﬁciently small relative to n.
4.5. Parameter ﬂexibility
In general, most codes that tolerate t ≥ 2 failures have
a very tight restriction on the relationship between the pa-
rameters r and n (e.g., BCP [1] requires r = n/2− 1 with
n even). Other codes have primality restrictions on some
of the parameters. For example, the X-code [22] requires n
prime and r = n− 2. The horizontal codes such as EVEN-
ODD [2], Blaum-Roth [4] and RDP [6] require r = p− 1
for some prime p and n ≤ p (or n ≤ p − 1 for RDP). In
these cases, the number of rows must increase in order to
increase the size of the array. Increasing the number of rows
implies performance penalties. For example, more rows im-
plies more fragmentation of the parity formulas, more for-
mulas and so more computation costs. In addition, as we
saw above, decreasing the number of rows can improve re-
construction costs and add additional fault tolerance.
The HoVer codes are unique in that the number of rows
is bounded above by a function of the array size. All array
sizes are supported in a uniform way (unlike the BCP codes,
the X-code or ZZS [23]). The implementor may choose an
r value that works for the entire range of array sizes sup-
ported by the system.
In this way, the array can support
changes in the array size without signiﬁcant rearrangement
of data or parity elements. In addition, when one disk is
down, the HoVer code’s resource requirements for recon-
struction are uniform across all arrays sizes with a constant
r (this property does not hold for most 2-fault tolerant era-
sure codes). It should be emphasized that ﬁxing r and in-
creasing n (or ﬁxing n and decreasing r) impacts the storage
efﬁciency signiﬁcantly. In short, the HoVer codes provide
a range of constructions allowing an implementor ﬂexibil-
ity in balancing the efﬁciency penalty with the performance
advantages.
5. Open problems
There are many open problems in the context of HoVer
codes. We list a couple of the more important ones here.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE 
HoVer3
This order reﬂects the amount of effort we put into the prob-
lems and our sense of their tractability (easier, more speciﬁc
problems ﬁrst).
• Determine (and prove) the precise conjecture for the
• Prove the lower bounds in Conjecture 2 for HoVer3
• Find a construction for a HoVer3
• Find a reasonable general construction for HoVert
2,1 code when pr(n) = 3.
codes (e.g., when n is prime).
1,2 code (one parity row
and two h-parity strips).
2,1
t−1,1
code for any t.
6. Summary
In this paper we presented the HoVer codes, a new family
of XOR-based erasure codes for disk arrays. They combine
the notions of h-parity (parity stored on separate disks from
the data) and v-parity (parity stored on the same disk with
unrelated data) as a hybrid data/parity layout. We gave a
complete characterization of one construction (and a simple
variant) that tolerates 2 lost disks. In addition we provided
a construction of a 3-fault tolerant code and remarked on
additional constructions for 3 and 4-fault tolerance. These
latter constructions were supported by a mixture of the-
ory, conjecture and experiment, but cover all practical array
sizes. We argued that the HoVer codes’ parameter ﬂexibility
gives implementors and designers the ability to adjust the
performance/efﬁciency trade-off to achieve the best balance
of these two metrics in a speciﬁc environment or system.
7. Acknowledgements
2,1 and HoVer3
The author thanks KK Rao, Tapas Kanungo, and Veera
Deenadhayalan for their contributions to this work. We also
want to thank the Blue Gene/L support team at IBM’s Al-
maden Research Center for the opportunity to run many
of the larger experiments on their system (and their assis-
tance). Testing array sizes in the 300–600 range (as we
did for HoVer3
1,1 codes) required considerable
computing power.
References
[1] S. Baylor, P. Corbett, and C. Park. Efﬁcient method for pro-
viding fault tolerance against double device failures in mul-
tiple device systems, January 1999. U. S. Patent 5,862,158.
[2] M. Blaum, J. Brady, J. Bruck, and J. Menon. EVENODD: an
efﬁcient scheme for tolerating double disk failures in RAID
architectures.
IEEE Transactions on Computers, 44:192–
202, 1995.
[3] M. Blaum, J. Brady, J. Bruck, J. Menon, and A. Vardy. The
EVENODD code and its generalization. In J. Jin, T. Cortest,
and R. Buyya, editors, High Performance Mass Storage and
Parallel I/O: Technologies and Applications, chapter 14,
pages 187–208. IEEE and Wiley Press, New York, 2001.
[4] M. Blaum and R. M. Roth. On lowest density MDS codes.
IEEE Transactions on Information Theory, 45:46–59, 1999.
[5] J. Bloomer, M. Kalfane, M. Karpinski, R. Karp, M. Luby,
and D. Zuckerman. An xor-based erasure-resilient coding
scheme. Technical Report Technical Report TR-95-048, In-
ternational Computer Science Institute, August 1995.
[6] P. Corbett, B. English, A. Goel, T. Grcanac, S. Kleiman,
J. Leong, and S. Sankar. Row-diagonal parity for double
disk failure. In Proceedings of the Third USENIX Confer-
ence on File and Storage Technologies, pages 1–14, 2004.
[7] R. G. Gallager. Low-Density Parity-Check Codes. MIT
Press, Cambridge, MA, 1963.
[8] G. A. Gibson, L. Hellerstein, R. M. Karp, R. H. Katz, and
D. A. Patterson. Failure correction techniques for large disk
arrays. In Proceedings of International Conference on Ar-
chitectural Support for Programming Languages and Oper-
ating Systems, pages 123–132, Boston, MA, 1989.
[9] J. L. Hafner. HoVer erasure codes for disk arrays. Technical
Report RJ 20352, IBM Research, San Jose, CA, 2005.
[10] J. L. Hafner. WEAVER codes: Highly fault tolerant erasure
codes for storage systems. Technical Report RJ 10353, IBM
Research, San Jose, CA, 2005.
[11] J. L. Hafner. WEAVER codes: Highly fault tolerant era-
sure codes for storage systems.
In Proceedings of the
Fourth USENIX Conference on File and Storage Technolo-
gies, pages 211–224, San Francisco, CA USA, December
2005.
[12] J. L. Hafner, V. Deenadhayalan, KK Rao, and J. A. Tomlin.
Matrix methods for lost data reconstruction in erasure codes.
In Proceedings of the Fourth USENIX Conference on File
and Storage Technologies, pages 183–196, San Francisco,
CA USA, December 2005.
[13] T.-D. Han, S.-D. Kim, S.-B. Yang, K.-W. Lee, and S. Chang.
Method for storing parity and rebuilding data contents of
failed disks in an external storage subsystem and apparatus
thereof, December 2000. U. S. Patent 6,158,017.
[14] C. Huang and L. Xu. Star: An efﬁcient coding scheme for
In Proceedings of
corrrecting triple storage node failures.
the Fourth USENIX Conference on File and Storage Tech-
nologies, pages 197–210, December 2005.
[15] M. G. Luby, M. Mitzenmacher, A. Shokrollahi, and D. A.
Spielman. Efﬁcient erasure correcting codes. IEEE Trans-
actions on Information Theory, 47:569–584, 2001.
[16] S. Nanda. Method and system for disk fault tolerance in
a disk array, April 2004. U. S. Patent Application US
2004/0078642 A1.
[17] J. S. Plank, R. L. Collins, A. L. Buchsbaum, and M. G.
Thomason. Small parity-check erasure codes – exploration
and observations.
In Proceedings of the 2005 Interna-
tional Conference on Dependable Systems and Networks
(DSN’05), 2005.
[18] J. S. Plank and M. G. Thomason. A practical analysis of low-
density parity-check erasure codes for wide-area storage ap-
plications. In Proceedings of the 2004 International Confer-
ence on Dependable Systems and Networks (DSN’04), 2004.
[19] I. S. Reed and G. Solomon. Polynomial codes over certain
ﬁnite ﬁelds. Journal of the Society for Industrial and Applied
Mathematics, 8:300–304, 1960.
[20] A. Wilner. Multiple drive failure tolerant raid system, De-
cember 2001. U. S. Patent 6,327,672 B1.
[21] L. Xu, V. Bohossian, J. Bruck, and D. G. Wagner. Low-
IEEE
IT-45:1817–1826,
density mds codes and factors of complete graphs.
Transactions on Information Theory,
1999.
[22] L. Xu and J. Bruck. X-code: MDS array codes with optimal
IEEE Transactions on Information Theory, IT-
encoding.
45:272–276, 1999.
[23] G. V. Zaitsev, V. A. Zinovev, and N. V. Semakov. Minimum-
check-density codes for correcting bytes of errors. Problems
in Information Transmission, 19:29–37, 1983.
Proceedings of the 2006 International Conference on Dependable Systems and Networks (DSN’06) 
0-7695-2607-1/06 $20.00 © 2006 IEEE