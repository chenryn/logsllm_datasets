       $class
        CF$UID
        7
       NS.base
        CF$UID
        0
       NS.relative
        CF$UID
        6
      http://www.google.com
       $classes
        NSURL
        NSObject
       $classname
       NSURL
`NS.base`字段和`NS.relative`字段是将用于构造`NSURL`实例的对象，该`NS.relative`字段引用字符串`http://www.google.com`，它代表了URL位置。下面的字典，带有`$classes`和`$classname`字段，描述了实例的类，它由第一个字典的`$class`字段引用。反序列化此实例时，解码器将调用`[NSURL
initWithCoder:]`，其中包含 **将反序列化`NS.base`和`NS.relative`字段并使用它们初始化`NSURL`**的代码。
`NSKeyedArchiver`可以学序列化或反序列化任何实现`initWithCoder:`的`Object-C`类，但它有一个名为`NSSecureCoding`的安全功能，允许开发人员限制解码的内容。
首先，实现`initWithCoder`的类，还必须实现`requiresSecureCoding`，以便在启用`NSSecureCoding`时启用反序列化。这可以防止开发人员在安全的上下文中意外暴露反序列化代码。其次，`NSSecureCoding`要求所有反序列化调用
**提供可以反序列化的允许类的列表** ，并且不允许其他类。但值得注意的是，允许的类列表并不是
序列化期间可以调用`initWithCoder:`方法的完整列表。例如，具有一些遗漏的`[NSURL initWithCoder:]`的伪代码表示如下：
    [NSURL initWithCoder:](NSURL *u, id decoder){
        NSData* book = [decoder decodeObjectOfClass:[NSData class]       forKey:@"NS.minimalBookmarkData"];
        if(book)
            return [URLByResolvingBookmarkData:data];
        NSString* base = [decoder decodeObjectOfClass:[NSString class] forKey:@"NS.base"];
        NSString* relative = [decoder decodeObjectOfClass:[NSString class] forKey:@"NS.relative"];
        return [NSURL initWithString:base relativeToURL:relative];
    }
对于不是`bookmark`的URL，该方法将需要为`NS.relative`和`NS.base`字段反序列化类`NSString`的实例，并且在该反序列化中将允许`NSString`类。同样，如果序列化数据包含`NS.minimalBookmarkData`字段，它将反序列化`NSData`的实例。因此，虽然限制了
反序列化的类 将返回的类，但它们 **并不将攻击面限制为该类** 。尽管如此，他们仍然会减少攻击面。  
有几种方法可用于创建`NSKeyedUnarchiver`实例或反序列化对象，并且默认情况下并非所有方法都启用`NSSecureCoding`，默认情况下，以下方法启用它：
`initForReadingFromData: unarchivedObjectOfClasses:fromData:error:`
而下面的方法则不能：
`initWithData: unarchiveObjectWithData:error initForReadingWithData:`
这些方法的名字并没有清楚的表明是否启用了`NSSecureCoding`，尤其是名称相同的`initForReadingFromData:`和`initForReadingWithData
:`，我们首次尝试查找漏洞是在iMessage中寻找一个在没有`NSSecureCoding`的情况下执行反序列化的地方。希望能够使用它来反序列化`WebKit`实例，并找到一种方法来加载包含`WebKit`漏洞的网页，因为发现了许多此类漏洞，并且可以它们的可利用性都很好。不幸的是，没有`NSSecureCoding`的地方，我们没有发现任何反序列化。
接下来，我们研究了 **扩展** 。扩展是一个相当新的功能，因此我们希望找到扩展如何处理 **bp**
字段中的序列化数据的错误。有时可以在没有用户交互的情况下执行该处理。扩展程序可以支持预览，在这种情况下，`SpringBoard`将在扩展程序中调用`previewSummary`而无需用户交互。某些版本的iOS还通过调用`initWithPluginPayload`来处理整个输入，没有用户交互，但它在每个版本上是不一致的。这发生在测试版本`12.1.2`时，但不是更高版本。
我们在`Digital
Touch`扩展程序发现了一个漏洞[CVE-2019-8624中](https://bugs.chromium.org/p/project-zero/issues/detail?id=1828)，此扩展允许用户发送包含绘图和其他可视元素的消息。扩展允许使用自定义编码，只要它们发信号通知`SpringBoard`不尝试解码
**bp** 字段，Digital Touch使用`protobuf`解码其有效负载(payload)。它解码了几个字节数组，并且有一种情况是，
**在复制之前错误地检查字节数组的长度** ，从而导致 **越界读取** 。这个问题很可能无法被利用，但是产生bug的路径很有趣。
链接演示文稿扩展(The Link Presentation
extension)显示在消息中发送链接时的链接预览。它的工作原理是在发件人设备上加载`WebKit`中的链接，生成预览文本和图像，然后将其发送到目标设备。我们非常详细地分析了这个扩展，寻找在接收设备上生成`WebKit`实例的方法，但没有找到。`WebKit`处理似乎总是由发件人完成。
然后我们决定在`initWithCoder`中查找bug ，`SpringBoard`在生成消息预览时允许反序列化的类的方法。Ian Beer
发现了这种类型的`几个问题`，允许权限提升。
> issue如下：
>
> 
>
> 
>
> 
`SpringBoard`解码 **bp**
字段时允许的类是：`NSDictionary`，`NSString`，`NSData`，`NSNumber`，`NSURL`，`NSUUID`和`NSValue`。还允许这些类的
**具有任何继承级别的子类** ，`NSKeyedUnarchiver`反序列化的情况也是如此。我们回顾了`initWithCoder:
SpringBoard`导入的这些类及其子类的实现。该分析发现了三个漏洞。
[CVE-2019-8663](https://bugs.chromium.org/p/project-zero/issues/detail?id=1883)是反序列化`SGBigUTF8String`类的漏洞，该类是`NSString`的子类。这个类的`initWithCoder:`实现
反序列化一个字节数组，然后看作以null结尾的UTF-8字符串，即使它可能没有null。这可能导致创建一个包含越界内存的字符串。
[CVE-2019-8661](https://bugs.chromium.org/p/project-zero/issues/detail?id=1856)是`[NSURL initWithCoder:]`
中的漏洞，仅影响Mac。当反序列化URL时，通常会解码类`NSString`的实例，但也可以对`NSData`实例进行反序列化，然后将其视为`bookmark`。仅在Mac上，此书签可能采用`alis`
，[alis格式](https://developer.apple.com/documentation/coreservices/carbon_core/alias_manager)，在2012年已弃用。此格式由名为`CarbonCore`的框架处理，该框架使用许多不安全的字符串处理函数来处理别名文件。该漏洞是由于对`strcat`的不安全调用导致的堆内存破坏引起的。值得注意的是，`iMessage`永远不会合法使用此书签功能。它存在是因为`NSURL`反序列化在整个系统中是通用的，因此`initWithCoder`实现必须支持所有输入可能性，甚至是在特定攻击面上
正常使用时 永远不会遇到的可能性。