## 总结本讲主要讲述了主从 reactor 模式，主从 reactor 模式中，主 reactor只负责连接建立的处理，而把已连接套接字的 I/O 事件分发交给从 reactor线程处理，这大大提高了客户端连接的处理能力。从 Netty的实现上来看，也遵循了这一原则。
## 思考题和往常一样，给大家留两道思考题：第一道，从日志输出中，你还可以看到 main-thread 首先加入了 fd 为 4的套接字，这个是监听套接字，很好理解。可是这里的 main-thread又加入了一个 fd 为 7 的套接字，这个套集字是干什么用的呢？第二道，你可以试着修改一下服务器端的代码，把 decode-compute-encode部分使用线程或者线程池来处理。欢迎你在评论区写下你的思考，或者在 GitHub上上传修改过的代码，我会和你一起交流，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。![](Images/5a282807b2a1ff091b7f803e8cef3429.png){savepage-src="https://static001.geekbang.org/resource/image/bf/25/bfc96ae0d8f839919b9d9866cfb8b025.jpg"}
# 29 \| 渐入佳境：使用epoll和多线程模型你好，我是盛延敏，这里是网络编程实战第 29 讲，欢迎回来。在前面的第 27 讲和第 28 讲中，我介绍了基于 poll 事件分发的 reactor反应堆模式，以及主从反应堆模式。我们知道，和 poll 相比，Linux 提供的epoll 是一种更为高效的事件分发机制。在这一讲里，我们将切换到 epoll实现的主从反应堆模式，并且分析一下为什么 epoll 的性能会强于 poll等传统的事件分发机制。
## 如何切换到 epoll我已经将所有的代码已经放置到[GitHub](https://github.com/froghui/yolanda)上，你可以自行查看或下载。我们的网络编程框架是可以同时支持 poll 和 epoll 机制的，那么如何开启epoll 的支持呢？lib/event_loop.c 文件的 event_loop_init_with_name函数是关键，可以看到，这里是通过宏 EPOLL_ENABLE 来决定是使用 epoll 还是poll 的。    struct event_loop *event_loop_init_with_name(char *thread_name) {  ...#ifdef EPOLL_ENABLE    yolanda_msgx("set epoll as dispatcher, %s", eventLoop->thread_name);    eventLoop->eventDispatcher = &epoll_dispatcher;#else    yolanda_msgx("set poll as dispatcher, %s", eventLoop->thread_name);    eventLoop->eventDispatcher = &poll_dispatcher;#endif    eventLoop->event_dispatcher_data = eventLoop->eventDispatcher->init(eventLoop);    ...}在根目录下的 CMakeLists.txt 文件里，引入 CheckSymbolExists，如果系统里有epoll_create 函数和 sys/epoll.h，就自动开启EPOLL_ENABLE。如果没有，EPOLL_ENABLE 就不会开启，自动使用 poll作为默认的事件分发机制。``{=html}    
# check epoll and add config.h for the macro compilationinclude(CheckSymbolExists)check_symbol_exists(epoll_create "sys/epoll.h" EPOLL_EXISTS)if (EPOLL_EXISTS)    
#    Linux 下设置为 epoll    set(EPOLL_ENABLE 1 CACHE INTERNAL "enable epoll")     
#    Linux 下也设置为 poll    
#    set(EPOLL_ENABLE "" CACHE INTERNAL "not enable epoll")else ()    set(EPOLL_ENABLE "" CACHE INTERNAL "not enable epoll")endif ()但是，为了能让编译器使用到这个宏，需要让 CMake 往 config.h文件里写入这个宏的最终值，configure_file 命令就是起这个作用的。其中config.h.cmake是一个模板文件，已经预先创建在根目录下。同时还需要让编译器 include 这个config.h 文件。include_directories 可以帮我们达成这个目标。    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.h.cmake        ${CMAKE_CURRENT_BINARY_DIR}/include/config.h) include_directories(${CMAKE_CURRENT_BINARY_DIR}/include)这样，在 Linux 下，就会默认使用 epoll 作为事件分发。那么前面的[27 讲](https://time.geekbang.org/column/article/146664)和[28讲](https://time.geekbang.org/column/article/148148)中的程序案例如何改为使用poll 的呢？我们可以修改 CMakeLists.txt 文件，把 Linux 下设置为 poll的那段注释下的命令打开，同时关闭掉原先设置为 1 的命令就可以了。下面就是具体的示例代码。    
# check epoll and add config.h for the macro compilationinclude(CheckSymbolExists)check_symbol_exists(epoll_create "sys/epoll.h" EPOLL_EXISTS)if (EPOLL_EXISTS)    