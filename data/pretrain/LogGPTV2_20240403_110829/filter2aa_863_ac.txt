Figure 8 - Sewio RTLS listening ports.
Figure 9 - Sewio RTLS running processes.
16
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
The dissection starts inside the handleIncomingData() method of SocketReceiver.js (Figure 10).
That method immediately calls the processRawData() method, that, in turn, calls the unpack() function of unpack.js, which is  
567 lines long  (Figure 11).
Figure 10 - handleIncomingData() and processRawData() methods of SocketReceiver.js.
Figure 11 - Lines 350-362 of unpack() function of unpack.js.
17
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
The first lines of the function revealed that the first byte of a 
Sewio UWB packet acts as a delimiter. If the separator is 0x23 
(the enum is defined in DefaultSettings.js), then the packet is 
a NEW_GEN packet; if 0x7c, an OLD_GEN packet. The parsing 
changes on the basis of this value. In this research, we only 
analyzed a NEW_GEN packet, as only packets of this type 
were found in the network traffic generated by the purchased 
solution (Figure 12).
The parsing of a NEW_GEN packet proceeds by extracting the 
second and third bytes from the packet, representing its CRC, 
and the fourth and fifth bytes, the report length. After doing 
so and performing some length checks, the lines of code 
responsible for the packet integrity are executed (Figure 13).
Figure 12 - Lines 363-400 of unpack() function of unpack.js.
Figure 13 - Lines 401-422 of unpack() function of unpack.js.
18
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
The verification of the packet integrity is crucial from a 
security perspective, because it affects the ability of an 
attacker to forge valid synchronization and  positioning 
of packets. As can be noticed on line 402 in Figure 13, 
and specifically on line 402, Sewio RTLS makes use of the 
crc16ccitt() function to verify the integrity of the packet. This 
implies that the solution only limits to verify that no corrupted 
packets are processed by inner code—no security checks are 
done for preventing an unauthorized actor from creating and 
injecting packets in the network traffic.
The dissection continues on the basis of its type (called report 
type) and the included function code, which are extracted in 
advance from the packet (Figure 14).
During our analysis, only traffic of report type “U” was seen, 
thus we only analyzed this type of packet in our research. 
The dissection of this specific type is handled by the 
parseReportUniversal() function, long 276 lines (Figure 15).
The parseReportUniversal() function starts extracting the 
report length, the anchor MAC address, and the report type 
from the packet (Figure 16).
Figure 14 - Lines 423-430 of unpack() function of unpack.js.
Figure 15 - Lines 770-775 of unpack() function of unpack.js.
Figure 16 - Lines 66-76 of parseReportUniversal() function of unpack.js.
19
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
Finally, it dissects the inner body of the packet, on the basis 
of its type. A packet can contain multiple submessages 
(called “options”), that may carry different types of 
information. For the sake of brevity, we only report the 
dissection of the most relevant messages (Figure 17):
 y The “syncEmission” message is sent by the reference 
anchor and contains the synchronization timestamp 
when it generated the sync UWB signal;
 y The “syncArrival” message is sent by the non-reference 
anchors and contains the synchronization timestamps 
when they received the UWB signal generated by the 
reference one;
 y The “blink” message is sent by all anchors and contains 
the positioning timestamps.
In the parsing code, it is possible to spot the lines of code 
that extract the first_path_amp1, first_path_amp2, 
first_path_amp3, max_growth_cir, and rx_pream_
count values, which will be mentioned again in section 2.4.
Figure 17 - Lines 100-166 of  parseReportUniversal() function of unpack.js.
20
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
An analysis on the usage of the extracted data by the 
subsequently executed code was done, to determine if any 
of those fields were processed inside decryption routines. 
The analysis confirmed that all data extracted from the 
network packets are directly used “as-is” (an example can 
be found in Figure 18), including the synchronization and 
positioning timestamps necessary for reconstructing 
the positioning data, and no decryption routines were 
called. Therefore, it is possible to conclude that there is no 
confidentiality in the network communications exchanged 
among anchors and server.
A Wireshark dissector has been written and is being released 
to the public in conjunction with this white paper, together 
with a sample PCAP. Figures 19 and 20 represent the same 
packets shown at the beginning of this chapter, dissected.
Figure 18 - covertRawTimestampToString() and convertTimestampToString() functions of unpack.js.
Figure 19 - Sewio RTLS dissected network packet sample.
21
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
Figure 20 - Sewio RTLS dissected network packet sample (2).
Figure 21 - Avalue RTLS network packet sample.
2.3.2 Avalue RTLS
Similar to Sewio, the Avalue RTLS can be configured 
to use either Ethernet or Wi-Fi as a backhaul for the 
communications among anchors and server. A Wireshark 
capture of the network traffic has been done in various 
conditions, in order to have as many packet samples as 
possible. Some of these samples are reported in Figure 21 
and Figure 22.
22
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
Figure 22 - Avalue RTLS network packet sample (2).
Figure 23 - Avalue RTLS listening ports.
As can be noticed again with Sewio, the Avalue RTLS uses a 
custom, unknown binary network protocol for this specific 
purpose, with no immediately recognizable standard data 
structures. It is thus necessary to reverse engineer the 
server software again.
A quick look at the server revealed that a Tomcat instance is 
listening on port 8080/udp, the destination to which Avalue 
anchors (Ips: 192.168.50.{51,52,53,54}) were noticed sending 
the network traffic (Figure 23).
23
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
Figure 24 - Applications running on Tomcat server.
Figure 25 - handlePacket() method of UwbParserManager.
By accessing the Tomcat manager installed on the server, 
it is possible to determine that the only custom application 
running on the system is “uwb-lib” (Figure 24).
In order to decompile the Java code of the application, we 
decided to use the “Enhanced Class Decompiler” plugin inside 
a local Eclipse installation, which outputs decompiled Java 
code straight into Eclipse and embeds multiple decompilation 
tools (JD, Jad, FernFlower, CFR, Procyon). Notably, during this 
analysis, FernFlower was used, which experimentally proved 
able to produce quality decompiled code.
The dissection starts inside the handlePacket() method of 
UwbParserManager (Figure 25).
24
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
Figure 26 - isUwbPacket() and getPacketType() methods of UwbLibUtils.
Figure 27 - All available packet types in Avalue UWB protocol.
The isUwbPacket() method immediately unveiled that 
the first two bytes of an Avalue UWB packet are fixed to 
the values 0x57 and 0x58. Additionally, a brief analysis of 
the getPacketType() method revealed that the third byte 
identifies the type (Figure 26).
A look at the PacketType class revealed the enum with all 
possible packet types (Figure 27). Notably, although multiple 
types are defined, during normal operations only two types of 
packets can be seen in the network traffic:
 y “CCP” packets, the synchronization packets described in 
the previous chapter;
 y “TDoA” packets, the positioning packets.
25
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
Figure 28 - parse() and processCheckSum() methods of UwbPacketParserTemplate.
Figure 29 - processHeader() method of BaseUwbPacketParser.
An implementation of the parser() method was found in the UwbPacketParserTemplate class (Figure 28).
The processHeader() method was implemented in 
BaseUwbPacketParser. This allowed us to discover that the 
fourth byte is the length of the body (Figure 29).
26
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
Figure 30 - check() method of SimplePacketChecker.
Figure 31 - processBody() method of CCPPacketParser.
Figure 32 - processBody() method of TDoAPacketParser.
Indeed, the processCheckSum() method is interesting 
from a security perspective, as its implementation directly 
impacts the ability to forge accepted UWB packets in 
subsequent injection attacks. A look at the check() 
method in SimplePacketChecker not only revealed that 
the checksum is just 2-byte long (the last two bytes of a 
packet), but also that it is simply the sum of all previous 
bytes (Figure 30). Although this might be enough to 
distinguish and discard accidentally corrupted packets 
from valid ones, it is evident that this mechanism does not 
add any protection against deliberate attacks.
If the processCheckSum() method is passed, the parsing 
continues with the processBody() method, which depends 
on the actual packet type. Following, the processBody() 
methods of CCP and TDoA packets are reported, that are 
the UWB synchronization and positioning packets (Figure 
31 and Figure 32). It is important to notice that, in these 
methods, it is possible to spot the exact location of the 
synchronization timestamps in the CCP packets, and of the 
positioning timestamps in the TDoA packets.
27
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
Figure 33 - parseEvent(), parseBat(), parseSignal(), and parseExtData() methods of BasicGeneralDataPacketParser.
The parseEvent(), parseBat(), parseSignal(), and 
parseExtData() methods in BasicGeneralDataPacketParser 
conclude the parsing procedure. Of these methods, it 
is worth mentioning that the parseSignal() method 
performs the extraction of the FirstPathAmp1, 
FirstPathAmp2, FirstPathAmp3, MaxGrowthCIR, and 
RxPreamCount values, mentioned again in section 2.4 
(Figure 33).
After tracking how all these data are used in the following 
steps of the implemented TDoA algorithm, it was possible 
to conclude that there is no confidentiality in the network 
communications exchanged among anchors and server. 
All data are extracted from the network packets and 
directly used “as-is” into the functions, including the 
synchronization and positioning timestamps necessary 
for reconstructing the positioning data (an example can 
be found in Figure 34). In fact, in the aforementioned 
evidence, a scrupulous reader might have noticed that, 
from the beginning, those data were parsed using specific 
functions such as getDouble(), a strong indication that no 
cryptography was in place.
Figure 34 - isValidTDoATime() method of UwbLibUtils.
28
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
A Wireshark dissector, specifically for the parsing of CCP 
and TDoA packets, has been written and is being released 
to the public in conjunction with this white paper, together 
with a sample PCAP. Figures 35 and 36 represent the same 
packets shown at the beginning of this chapter, dissected.
Figure 35 - Avalue RTLS dissected network packet sample.
Figure 36 - Avalue RTLS dissected network packet sample (2). 
29
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
In the previous section, we concluded that there is 
neither confidentiality nor secure integrity mechanisms 
protecting the communications performed by the analyzed 
UWB RTLS. However, as stated at the end of section 2.2, 
to compute the position of a tag, all coordinates of the 
involved anchors need to be known. This is the most 
challenging requirement for an attacker, and could make a 
difference in the ultimate ability to estimate the position of 
a tag or not. This section is entirely devoted to this specific 
problem. Notably, we present a technique that completely 
remote adversaries (the most limiting situation) can exploit 
to estimate the anchors’ coordinates with enough accuracy 
to mount practical attacks.
Normally, the coordinates of the anchors used in an RTLS 
are manually input as parameters inside the server software 
at the first installation (Figure 37). Afterwards, in the 
solutions we analyzed, this information was never found 
transmitted in the network traffic.
Physical access: If an attacker has physical access to the 
monitored area, this problem can be solved in a variety of ways:
 y If the anchors are mounted in visible positions, obtaining 
their coordinates is a simple task;
 y If the anchors are not mounted in visible positions, an 
attacker may still be able to estimate their coordinates by 
measuring the power levels of their transmitted wireless 
signals (UWB and/or any other wireless technology used 
by the anchors, such as Wi-Fi). The position where the peak 
power level is detected is roughly the anchor location.
2.4 Anchor Coordinates Prerequisite
Figure 37 - Anchor coordinates setup in Sewio RTLS.
30
WHITE PAPER
UWB Real Time Locating Systems: How Secure Radio Communications May Fail in Practice
2. Methodology and Attack Demos
In fact, according to our tests, the anchor coordinates 
do not need to be precise to obtain a good estimation of 
the tag positions. As shown in the following chart, if the 
anchor coordinates are estimated with an error of less than 
10% with respect to the real value, the tag coordinates are 
computed with an average error of less than 20%; about 50 
cm in a 6m x 5m room.
Remote access: If the attacker has no access to the 
monitored area, they must derive the anchor coordinates 
only by looking at the traffic the anchors are sending. This 
is the most challenging condition for an attacker because, 
the anchor coordinates are never transmitted through the 
network traffic.
Although no explicit data are transmitted, to this extent, 
there is important information coming from the anchors 
that can be leveraged to estimate the distance between 
each anchor and the reference one.
Together with the locating data, anchors transmit the 
power level information of the received UWB signal on the 
wire, to allow the locating server to filter out poorly received 
wireless packets (Figure 38). In particular, these data are:
 y First Path Amplitude point 1 (FP1)
 y First Path Amplitude point 2 (FP2)
 y First Path Amplitude point 3 (FP3)
 y Preamble Accumulation Count (PAC)
 y Maximum Growth CIR (MGC)
24%
23%
22%
21%
20%
19%
18%
2.5%
7.5%
10.0%