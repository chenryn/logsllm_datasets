To
NULL
0
0,0
0,1
. . .
49
49,0
49,1
Attacker Master
Slave1
Master
Slave1
Victim
Master
Slave1
. . .
. . .
Slave50
Master
Victim
Slave50
Slave50
Master
Entry function
0x2b6cab44
N/A
transfer(address,uint256)
N/A
. . .
N/A
transfer(address,uint256)
N/A
Payload
Parameters
0x32
N/A
_to: Master, _amount: 1,000,000
N/A
. . .
N/A
_to: Master, _amount: 1,000,000
N/A
Type
Value
Status
call
create
call
suicide
. . .
create
call
suicide
0
0
0
0
. . .
0
0
0
Success
Success
Success (or Failed)
Success
Success
Success (or Failed)
Success
below and explain them.
• Airdrop hunting. Airdrop hunting, as described in our run-
ning example (Section 2.1), leads to token ﬂows from the
victim contract to the master controlled by the adversary.
• Call injection. Call injection, which allows any contract, in-
cluding adversaries, to call a sensitive function in a vulner-
able contract, is often used to make an ownership change
and initiate ether or token transfers.
• Reentrancy. Reentrancy, as mentioned, usually leads to
repeated token or ether transfers from the victim to the
adversary.
• Integer overﬂow. Only some integer overﬂow attacks target
a variable recording the token amount owned by a vic-
tim, followed by an adversary transferring the overﬂowed
amount. Those attacks are in-scope and other integer over-
ﬂows like those causing a denial-of-service are not.
• Honeypot. A honeypot lures a victim to transfer some
ethers or tokens and then participate with bait but no actual
paybacks.
• Call-after-destruct. Call-after-destruct is the invocation of
a function in a destructed contract with ethers, leading to
the loss of these ethers forever. Noted that the call-after-
destruct is different from an out-of-scope suicidal attack, in
which an adversary exploits an unprotected interface and
destroys the victim contract.
3 Methodology
In this section, we describe our measurement methodology.
3.1 Measurement Workﬂow
We now describe the overall workﬂow of our analysis as
shown in Figure 3, which can be roughly divided into four
phases. First, in phase (1), we perform several preparation
works including (i) the construction of action trees and re-
sult graphs, i.e., two special representations, from execution
traces and (ii) the manual generation of adversarial transaction
signatures, containing both action and result clauses, for dif-
ferent vulnerability types. Second, in phase (2), we perform
an attack analysis to detect both conﬁrmed and attempted
adversarial transactions using our adversarial transaction sig-
natures. The action clause is matched against the action tree
to ﬁnd adversarial transactions, and then the result clause is
matched against the result graph to conﬁrm them. Third, in
phase (3), we perform a defense analysis to understand why
certain adversarial transaction fails. We extract the snippet
of code that defends against adversarial transactions and ﬁnd
more contracts that adopt these defenses via code similarity
analysis. Lastly, in phase (4), we look back at these conﬁrmed
adversarial transactions and analyze whether they can pene-
trate contracts with defense code via an evasion analysis.
3.2 Preparation Phase
In the preparation phase, we convert execution traces of trans-
actions to special representations, i.e., action tree and result
graph. At the same time, we generate adversarial transaction
signatures to match with those two special representations in
the attack analysis.
3.2.1 Action Tree and Result Graph
In this subsection, we discuss the construction of two impor-
tant representations, i.e., action tree and result graph. The
purpose of an action tree is to capture the actions that one
contract performs upon another and represent them in a tree-
like structure, and the purpose of a result graph is to capture
the consequences of performed actions and represent them in
a graph-like structure.
Deﬁnitions We now give the deﬁnitions of these two repre-
sentations.
• Action Tree. An action tree is a representation of actions in
an ordered tree-like structure, in which each node is a con-
tract and each edge is an action from the source contract
to the destination. An action, deﬁned as what one contract
performs upon another, has three concrete types: create,
suicide, and call. create means that a contract creates
a new contract in the destination address, suicide rep-
resents that a contract removes all its code and transfers
all the ethers it owns to the destination contract, and call
means that one contract calls another contract’s function,
2796    29th USENIX Security Symposium
USENIX Association
Figure 3: Measurement Workﬂow.
which could be an explicitly speciﬁed function or the de-
fault fallback function. In addition to its type, each action
is annotated with three additional properties: the invoked
function signature (or function deﬁnition if available), func-
tion parameters, and trace address (which is used to order
edges).
• Result Graph. A result graph is a representation of results
in a graph-like structure, in which the nodes are unique
contracts and the edges are sensitive results, i.e., ether trans-
fer, token transfer and ownership change, which happens
from one contract to another. Each edge in a result graph is
annotated with the number of transferred ethers or tokens
if applicable.
Note that these two representations have variations, i.e.
either transaction- or contract-centric: Different variations can
be used in the detection of different adversarial transactions.
We now introduce them separately.
Transaction-centric Construction Transaction-centric
construction is to convert the execution traces of each
transaction into these two representations, i.e., action tree and
result graph. First, we construct a transaction-centric action
tree by following the initiating contract and the sequence
of all the actions under that contract and creating edges
from the initiator to the destinations. We then repeat the
process until all the actions in the traces have been used in
the construction.
Second, we construct a transaction-centric result graph by
following all the actions and ﬁnding out their corresponding
results for annotation. There are two sources, i.e., action raw
traces and function parameters, to annotate the graph. (i) Ether
transfer values are available in the raw trace associated with
the action. (ii) Ownership and token transfer values are ob-
tained from function parameters if the corresponding function
signature matches the one documented by ERC standards as
shown in Appendix B and the function call succeeds.
Now let us look at the construction of action tree and result
graph (Figure 4) of our running example. We start from the
ﬁrst record in the traces, i.e., the row with the address NULL
(a) Action tree.
(b) Result graph.
Figure 4: Two representations of the example traces in Ta-
ble 1.
in Table 1, as the root node to construct action tree. The rows
with the addresses from 0 to 49 are the direct children of the
root node and then nodes with “0,0” and “0,1” are children
of the “0” node. The fully constructed action tree is shown
in Figure 4a. Next, we will extract the function parameter of
each transfer call and construct a result graph annotated with
transferred token values as shown in Figure 4b.
Contract-centric Construction Contract-centric construc-
tion is to convert the execution traces of all the transac-
tions belonging to one contract to our special representations.
Contract-centric representations are useful to capture the
malice of contract-speciﬁc behaviors, such as honeypot. We
construct contract-centric representations from transaction-
centric ones. Here are the details. First, we locate all the
transaction-centric action trees that contain the target con-
tract and merge all these trees together in chronological order
based on the target as the root node and other contracts that
perform an action upon the root as the leaves. Second, we
also merge all the result graphs that contain the target and
construct a bigger result graph by merging duplicate nodes.
3.2.2 Adversarial Transaction Signature
In this subsection, we ﬁrst describe our signature deﬁnition
and then present how to generate signatures.
Deﬁnition An adversarial transaction signature has two
clauses: action and result. The action clause of a signature
USENIX Association
29th USENIX Security Symposium    2797
Transactions(TXs)TracesReplay(1) PreparationAction TreeResult GraphKnown adversarial TXsExtractInvariantSignature 1Signature nSignature libraryAttempted adversarial TXsConﬁrmed adversarial TXsManual(2) Attack AnalysisDefenseContractsSimilarity AnalysisContracts with defenses(3) Defense Analysis(4) Evasion AnalysisHas conﬁrmed adversarial TXs?If yes, then evadedManual reasoning of evasionNULL00,00,14949,049,1MasterVictimMasterAttackerSlave1Slave50VictimMaster...token_transfer:1000000token_transfer:1000000MasterSlave1Slave50(a) Action clause.
(b) Result clause.
Figure 5: Adversarial transaction signatures for airdrop hunt-
ing (a blank cycle represents contracts with no address con-
straints).
is a tree structure that starts from a node C0 and provides
the matching conditions of each level of the tree including
edge properties and contract addresses. Figure 5a shows an
example action clause of our airdrop hunting example: the C0
is the starting node, which has properties like outgoing edges
of create, and then the second-level nodes will eventually call
token transfer function in some of the deeper levels. The three
vertical dots in a level of the tree indicate that there could be
more than one such similar node with a create as incoming
edge, and the three horizontal dots across levels indicate that
there could exist more than one node in between this token
transfer edge and the previous node.
The result clause of a signature is a graph structure in
which node names may be from those in the action clause and
edges provide corresponding matching conditions. Figure 5b
shows an example result clause of our airdrop hunting exam-
ple. Nodes C1 to Cn are from the second level of the action
clause and they all have an outgoing edge to an arbitrary node.
Signature Generation In this part, we describe how to gen-
erate adversarial transaction signatures for attack analysis.
Our generation has two steps: (i) invariant extraction, and
(ii) human reasoning. In the ﬁrst step, we extract common
nodes and edges, called invariants, from action trees and result
graphs of existing, known adversarial transactions. Then, in
the second step, we rely on human experts to reason about
the correctness of extracted invariants and add or remove con-
straints based on the attack semantics. Our signatures are
opportunistic, and that we do not claim completeness because
our purpose is to perform a measurement study of deployed
attacks in the real world rather than detection of all the attacks.
We will have an estimation of false positives and negatives of
our measurement results in Section 4.
Now let us use our airdrop hunting example to describe
the procedure of generating adversarial signatures shown in
Figure 5. First, we extract common sub-trees and sub-graphs
based on the representations of adversarial transactions simi-
lar to those in Figure 4. The common sub-tree is that a contract
creates many contracts and newly-created ones call the token
transfer of a victim and then destroy themselves. The common
sub-graph is that newly-created contracts transfer a certain
amount of tokens to another contract.
Second, we will manually examine the extracted sub-tree
and sub-graph to generate both clauses of an adversarial trans-
action signature. The manually-collected airdrop hunting at-
tacks typically create at least ten slaves, and we set the thresh-
old of slaves in the sub-tree and sub-graph as two to detect
all the slave creation transactions. Then, we delete the de-
stroy action from the sub-tree because this is not a necessary
step of airdrop hunting though performed in all the collected
adversarial transactions. We also change the destination con-
tract from the master to an arbitrary one as an adversary can
transfer tokens to any contract.
3.2.3 Signature Library
In this part, we list all our adversarial transaction signatures
generated in our library based on the attack and signature
type.
Transaction-centric Signatures We ﬁrst describe three at-
tack types that require only transaction-centric signatures in
Figure 6.
• Call injection. The action clause (Figure 6a1) is that a con-
tract calls its own function, which usually authorizes the
contract itself, in an inter-contract way and the called func-
tion further proxies sensitive function calls, e.g., a transfer
or ownership change, which is speciﬁed by a parameter
from injected function call. The proxied function name
can be embedded in a function parameter via two ways: (i)
function signature and (ii) utf-8 encoded function name.
Next, the result clause (Figure 6a2) speciﬁes that the in-
jected function call beneﬁts any of the ancestor nodes, i.e.,
C0, in the action tree in terms of ethers, tokens or owner-
ship.
• Reentrancy. The action clause (Figure 6b1) is that a con-
tract (C0) calls another contract (Ci), which may call some
other contracts but eventually will call C0, and such looped
invocation behavior will involve at least one transfer func-
tion. The result clause (Figure 6b2) is that the result edge
caused by the transfer function in the loop of action tree
may point to another contract of the adversary outside the
loop.
• Integer Overﬂow. The action clause (Figure 6c1) is that a
contract (C0) calls a known sensitive token transfer function
that contains a parameter, i.e., a value bigger than 1072
being close to the maximum range of signed 256-bit integer,
to trigger the vulnerability. Next, the result clause is that
C0 transfers tokens to another contract belonging to an
adversary.
Contract-centric Signatures We now describe another
three attack types that require contract-centric signatures in
Figure 7.
• Honeypot. An action clause (Figure 7a1) is that the hon-
eypot (C0) is created and set up by another contract (C1)
and then accepts function calls from other non-owner con-
tracts (e.g., C2 to Cn). In the end, C0 suicides and transfers
collected ethers to C1. A result clause (Figure 7a2) is that
C1, although ﬁrst makes investment, beneﬁts from C0 and
other contracts that transfer ethers to C0 get no payback.
2798    29th USENIX Security Symposium
USENIX Association
createcreatecall tokentransfer………c1cnc0call tokentransfer…tokentransfertokentransfercnc1(a1) Action clause.
(b1) Action clause.
(c1) Action clause.
(a2) Result clause.
(a) Call injection.
(b2) Result clause.
(b) Reentrancy.
(c2) Result clause.
(c) Integer overﬂow.
Figure 6: Transaction-centric signatures.
(a1) Action clause.
(a2) Result clause.
(b1) Action clause.
(b2) Result clause.
(a) Honeypot.
(b) Call-after-destruct.
Figure 7: Contract-centric signatures.
• Call-after-destruct. An action clause (Figure 7b1) is that
C0 ﬁrst suicides and then another contract, e.g., C1, still
calls with ether transfer of C0. A result clause (Figure 7b2)
is that ethers are transferred from C1 to C0.
3.3 Attack Analysis Phase
Our attack analysis matches adversarial transaction signatures
against action trees and result graphs of transaction execution
traces. The analysis, by its nature, has two stages: action and
result clause matching. The former ﬁnds attempted adver-
sarial transactions, and the latter conﬁrms those adversarial
transactions.
3.3.1 Action Clause Matching
We match action clause by traversing through all the nodes
in the action tree. The ﬁrst step is to match the root node C0
and if the root matches, we will match further levels. Then, if
all levels match, we consider the action tree matches with the
speciﬁc action clause. Let us again use the airdrop hunting
example in Figure 1 to describe the matching. When we
traverse through an action tree, we will ﬁnd that the master
node in Figure 4a matches with C0 in Figure 5a because C0
has many create actions on the outgoing edges. Then, C1 to
Cn also matches with Slave1 to Slave50, because they all call
token transfer function. Since all the nodes and edges in the