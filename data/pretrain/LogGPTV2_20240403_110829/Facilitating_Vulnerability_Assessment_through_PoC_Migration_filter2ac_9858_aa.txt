title:Facilitating Vulnerability Assessment through PoC Migration
author:Jiarun Dai and
Yuan Zhang and
Hailong Xu and
Haiming Lyu and
Zicheng Wu and
Xinyu Xing and
Min Yang
Facilitating Vulnerability Assessment through PoC Migration
Jiarun Dai‚àó
Fudan University
PI:EMAIL
Haiming Lyu
Fudan University
PI:EMAIL
Yuan Zhang‚àó
Fudan University
PI:EMAIL
Zicheng Wu
Fudan University
PI:EMAIL
Min Yang
Fudan University
PI:EMAIL
Hailong Xu
Fudan University
PI:EMAIL
Xinyu Xing
Pennsylvania State University
PI:EMAIL
ABSTRACT
Recent research shows that, even for vulnerability reports archived
by MITRE/NIST, they usually contain incomplete information about
the software‚Äôs vulnerable versions, making users of under-reported
vulnerable versions at risk. In this work, we address this problem
by introducing a fuzzing-based method. Technically, this approach
first collects the crashing trace on the reference version of the
software. Then, it utilizes the trace to guide the mutation of the
PoC input so that the target version could follow the trace similar
to the one observed on the reference version. Under the mutated
input, we argue that the target version‚Äôs execution could have
a higher chance of triggering the bug and demonstrating the
vulnerability‚Äôs existence. We implement this idea as an automated
tool, named VulScope. Using 30 real-world CVEs on 470 versions of
software, VulScope is demonstrated to introduce no false positives
and only 7.9% false negatives while migrating PoC from one
version to another. Besides, we also compare our method with
two representative fuzzing tools AFL and AFLGO. We find VulScope
outperforms both of these existing techniques while taking the
task of PoC migration. Finally, by using VulScope, we identify 330
versions of software that MITRE/NIST fails to report as vulnerable.
CCS CONCEPTS
‚Ä¢ Security and privacy ‚Üí Software and application security.
KEYWORDS
Vulnerability Assessment; Trace Alignment; PoC Adjustment
ACM Reference Format:
Jiarun Dai, Yuan Zhang, Hailong Xu, Haiming Lyu, Zicheng Wu, Xinyu Xing,
and Min Yang. 2021. Facilitating Vulnerability Assessment through PoC
Migration. In Proceedings of the 2021 ACM SIGSAC Conference on Computer
‚àóco-first authors
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior specific permission and/or a
fee. Request permissions from permissions@acm.org.
CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea
¬© 2021 Association for Computing Machinery.
ACM ISBN 978-1-4503-8454-4/21/11...$15.00
https://doi.org/10.1145/3460120.3484594
and Communications Security (CCS ‚Äô21), November 15‚Äì19, 2021, Virtual Event,
Republic of Korea. ACM, New York, NY, USA, 18 pages. https://doi.org/10.1
145/3460120.3484594
1 INTRODUCTION
By leveraging the community efforts, MITRE [3] and NIST [4]
have indexed more than 150K software vulnerabilities and archived
them as the corresponding vulnerability reports. A vulnerability
report usually contains vulnerable software versions, the severity
of the vulnerability, and even the Proof-of-Concept (PoC) input
to reproduce the failure pertaining to the vulnerability. These
pieces of information greatly ease patch development, vulnerability
management, and security measurement.
However, recent research raises the concern for the quality of
vulnerability reports. The works [12, 18, 34, 48] show that incom-
plete and incorrect vulnerable software versions are prevalent in
vulnerability reports. They showcase that incomplete information
could leave specific versions of vulnerable software unpatched and
expose software end-users to a greater security risk.
To solve this problem, Dong et al. [18] replayed PoC inputs ‚Äì
effective for one version ‚Äì on other versions of the same software.
Unfortunately, they discover that, without a further adjustment, a
PoC working for one version can barely be migrated for triggering
the same bug on other versions. Besides, they also observe that
the effort needed for verifying a vulnerability on one version is
usually significant. To reduce the manual effort and improve the
capability of vulnerability verification, intuition suggests that both
code clone detection and patch presence testing could potentially be
applied. In particular, one could quickly determine a vulnerable
code‚Äôs existence with code clone detection [24, 28, 29, 46] and
pinpoint a security patch‚Äôs absence with patch presence testing [16,
25, 52, 55, 57]. Further, he or she could infer whether the version of
the software under his or her inspection is potentially vulnerable.
However, common static analysis tools could potentially generate
high false positives because they cannot confirm the existence
of a vulnerability through a PoC input that triggers the target
vulnerability and forces the program to accidentally terminate.
With a PoC in hand, it can ease patch development, regression
testing, and exploitability assessment of a target vulnerability.
In response to these limitations, another instinctive reaction for
addressing the problem is to utilize directed fuzzing (e.g., [9, 13]). To
be specific, one could first specify the buggy site in the target version
Session 12B: Analyzing Crashes and Incidents CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea3300of the software. He or she could then use the reference PoC input as
an initial seed for consecutive input mutation. Unlike conventional
fuzzing techniques that aim to maximize code coverage (e.g., [1]),
directed fuzzing works by steering the fuzzing process towards the
designated vulnerable code locations and thus potentially explores
paths that can reach out to the specified buggy site. As such,
intuition suggests this practice should produce a good outcome in
terms of PoC migration. However, as we will show in ¬ß5, directed
fuzzing does not provide sufficient benefits in generating a new PoC
for vulnerability verification. The reason is that directed fuzzing is
designed to find a path to the target site quickly but the condition
for triggering a target bug is usually encoded only on a couple of
critical paths, which are usually ignored by directed fuzzing.
In this work, we propose a PoC migration approach. It adjusts the
reference PoC to maximize the similarity between the execution
trace generated by the reference PoC on the reference version
(called reference trace, ùëáùëüùëí ùëì ) and the one generated by the adjusted
PoC on the target version (called target trace, ùëáùë°ùëéùëüùëîùëíùë°). The key
rationale behind our idea is that the execution flows to trigger the
same vulnerability on different versions should be similar. Guided
by the reference trace, our approach could avoid blindly exploring
the huge amount of paths that all head to the buggy sites on the
target version, and focuses more on those paths that have already
shown to be effective on the reference version. Compared with
existing works, our approach has a higher chance and efficiency
in generating a new PoC against the vulnerability on the target
version.
To realize the idea above, as we will elaborate in ¬ß2.1, we tackle
two principal challenges. First, we introduce a cross-version trace
alignment method. Using this method, we correlate the execution
traces generated from two different versions of software. Second,
we propose a trace-guided PoC adjustment approach. With the
facilitation of this approach, we correct execution detours, making
the target trace approach the reference trace more efficiently. In ¬ß3
and ¬ß4, we present the details of each of these technical approaches.
To the best of our knowledge, this is the first work that considers
migrating PoC across different versions of the same software
to perform vulnerability assessment. In practice, confirming a
vulnerability is quite difficult, which requires locating buggy code,
checking the existence of root cause and verifying the vulnerable
conditions for multiple versions of a program. Therefore, it is
still challenging for developers (who are familiar with the source
code) to confirm a vulnerability. As an automated technique,
VulScope can ease the vulnerability assessment for not only
developers but also other users who are not familiar with the
source code, e.g., testers, security administrators. In comparison
with fuzzing techniques for PoC migration, our proposed techniques
can complete the task not only effectively but also efficiently. Used
in the context of CVE management, our techniques demonstrate
significant potential for improving the quality of CVE reports.
In summary, the paper makes the following contributions:
‚Ä¢ We propose a systematic approach, named VulScope, to assess
vulnerable versions for a target vulnerability by migrating PoC
inputs from a reference version to another.
‚Ä¢ We design two key techniques to perform the vulnerability
assessment: cross-version trace alignment and trace-guided PoC
adjustment.
‚Ä¢ We conduct extensive experiments using 30 real-world CVEs on
470 versions of software, and demonstrate VulScope introduces
no false positives and only 7.9% false negatives when performing
PoC migration. We show VulScope significantly outperforms
existing fuzzing techniques in PoC migration tasks.
2 DESIGN OVERVIEW
This section first illustrates our key idea in PoC migration and then
gives an overall workflow of our approach. Our detailed approach
is presented in ¬ß3 and ¬ß4.
2.1 Key Idea
The fundamental challenge in our approach is that we need to use
the reference trace to guide the migration, but at the same time, we
can hardly make the migrated trace (the execution trace generated
by the migrated PoC) identical to the reference one due to cross-
version code changes. Therefore, we should select an appropriate
granularity to leverage the reference trace as guidance, which
should balance the benefits brought by reference guidance and
the ability to tolerate code changes.
Granularity in Leveraging the Reference Trace. For the pur-
pose of code comparison, several granularities have been used, such
as instruction-level [17], basic-block-level [2, 42, 43, 60], function-
level [14, 26, 28] and module-level [7, 59]. The granularity to analyze
the cross-version traces is quite important to our design. If we guide
the migration at a very coarse-grained level, the migration process
would explore a lot of code paths that are useless for triggering the
target vulnerability. On the contrary, if the guidance is performed
at a very fine-grained level, it would limit the exploration ability
of the migration process, making it hard to adapt the necessary
cross-version code changes.
By examining the unique characteristics of our research problem,
we choose function-level as the granularity to leverage the reference
trace as guidance. Our design considerations are based on two
observations. First, we observe that, in our problem context,
the original PoC cannot trigger the same vulnerability on the
target version due to cross-version code changes. Compared with
instruction-level and basic-block-level, function-level gives better
tolerance on the changes across traces which could increase the
probability of generating a useful PoC to trigger the same bug
on the target version. Second, from the perspective of guidance,
we find that module-level is too coarse-grained to provide useful
guidance during PoC migration which may dramatically increase
the exploration space and reduce the success rate. Therefore, we
believe function-level is the most appropriate granularity to guide
the PoC migration process with a reference trace.
Challenges. Guided by the reference trace, the PoC migration
process can be summarized as two key steps: 1) locates the
difference between the reference trace (ùëáùëüùëí ùëì ) and the target trace
(ùëáùë°ùëéùëüùëîùëíùë°); 2) adjusts the PoC accordingly to make the generated new
ùëáùë°ùëéùëüùëîùëíùë° more similar to the ùëáùëüùëí ùëì . However, it is non-trivial to follow
these steps, due to the various cross-version code changes and the
complexity of triggering the same vulnerability. In particular, there
are two major challenges in our approach.
Challenge-I: how to align the function calls between cross-version
execution traces? Different versions of a program contain various
Session 12B: Analyzing Crashes and Incidents CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea3301code changes. Thus, even the same input may generate discrepant
execution traces on the reference version and the target version.
Actually, the trace discrepancies may be diverse, which include
both syntactic differences (i.e., behaviors caused by normal code
refactoring) and semantic differences (i.e., behaviors that are specific
to a version or caused by different inputs). To align traces with a
lot of differences, existing works mainly require either the same
software version [38, 58] (to perform code matching using semantic
equivalence) or the same input [27] (to leverage runtime values for
code alignment). However, with the aim to generate a useful PoC,
we need to modify the original input and then align its execution
trace on the target version with the reference trace. Therefore,
our approach needs to handle the alignment problem between
the execution traces generated with different inputs on different
software versions, making existing works hard to apply.
Challenge-II: how to guide the PoC adjustment to trigger the
same vulnerability? Based on the alignment between ùëáùë°ùëéùëüùëîùëíùë° and
ùëáùëüùëí ùëì , there may be a lot of trace discrepancies. Though we believe
the execution trace to trigger the same vulnerability on different
software versions may be quite similar, they inevitably have some
different function calls that are specific to a version of a program and
cannot be adjusted. Therefore, this kind of trace discrepancy should
be identified first and excluded from the scope of PoC adjustment.
Besides, for those trace discrepancies that can be adjusted, it is hard
to determine which discrepancies need to be adjusted first and how
these discrepancies can be efficiently mitigated. In addition, during
the PoC adjustment process, we need an accurate vulnerability
triage to test whether an input triggers the target vulnerability.
These issues together make the whole PoC migration process quite
challenging.
Key Techniques. Our basic idea to address the above challenges
is to appropriately leverage the reference trace as guidance but
also carefully consider the code changes between two versions.
Specifically, we propose two techniques to address these challenges.
Technique-I: Cross-version Trace Alignment. As mentioned above,
we need to align two traces generated by different inputs on
different versions of a program, which may include both syntactic
differences and semantic differences. For the syntactic differences,
we aim to align them as the same behaviors. For the semantic
differences, we should avoid them being aligned. In short, our
cross-version trace alignment consists of two steps. First, we
perform a function-level code mapping between the two versions
of software. Different from existing works, our code alignment
not only tolerates function renaming behaviors but also captures
function merging/splitting relationships. Second, we propose to
use a tree-based structure to represent execution traces and design
a tree alignment algorithm for trace alignment. The advantage of
tree-based alignment is that it can utilize the context information
(e.g., parents nodes) of a function call to guarantee the accuracy
of function-level trace alignment (e.g., to avoid aligning functions
with semantic differences).
Technique-II: Trace-guided PoC Adjustment. As described in
Challenge-II, to leverage the reference trace to guide the PoC
migration, we need to solve three sub-problems: 1) how to reason
the execution detours according to the trace alignment; 2) how to
efficiently adjust the inputs to mitigate the execution detours; 3)
how to verify the adjusted PoC triggers the same vulnerability?
Figure 1: System Overview for PoC Migration.
Accordingly, we address these problems with three new techniques
respectively. First, we recognize the execution detours that are
specific to a version of software (thus cannot be adjusted) and
exclude them from the correction scope. For the remaining detours
that could be adjusted, we try to locate the variables that cause these
detours in the target trace with program analysis. Second, since the
reasoning of which execution detours should be adjusted first and
how to accurately adjust them is quite hard, we adopt a fuzzing-
based approach here which iteratively mutates the input to keep the
ùëáùë°ùëéùëüùëîùëíùë° approaching the ùëáùëüùëí ùëì , hoping it ultimately trigger the target
vulnerability. Third, to verify whether we have triggered the same
vulnerability on the target version, we make a conservative design.
In particular, we consider crash types, execution trace similarity
and buggy function together in determining crashes triggered by
the same vulnerability. This design helps our tool to keep a low
false positive rate in reporting vulnerable versions.
2.2 Workflow
Following the above key ideas, we design VulScope to facilitate
the assessment of vulnerable versions. The overall architecture of
VulScope is presented in Figure 1, consisting of two main modules
that implement our key techniques respectively. Overall speaking,
VulScope takes a PoC that triggers a vulnerability on the reference
version as input, and tests whether another version of the same
software is also vulnerable to this vulnerability. To confirm the
vulnerability, VulScope should generate a new PoC that can indeed
trigger the same vulnerability on the specified version. Our core
idea is to adopt a trace-aware fuzzing method that continuously
adjusts the given PoC, and makes the target version of the software
ReferenceTraceReferenceTraceTargetTraceTargetTraceSeed/PoCCross-version Trace AlignmentTree-based Trace AlignmentFunction-levelCode MappingCross-version Trace AlignmentTree-based Trace AlignmentFunction-levelCode MappingTrace-guided PoC AdjustmentExecution Detours ReasoningCrash TriageFuzzing-based Detours CorrectionAffected?Trace-guided PoC AdjustmentExecution Detours ReasoningCrash TriageFuzzing-based Detours CorrectionAffected?AlignedDetouredAligned TracesAlignedDetouredAligned TracesSession 12B: Analyzing Crashes and Incidents CCS ‚Äô21, November 15‚Äì19, 2021, Virtual Event, Republic of Korea3302follow a similar path to that observed on the reference version
under the new input. Following this way, intuition suggests that
we have a higher chance to generate a new PoC that triggers the
same vulnerability on the target version.
In particular, VulScope runs in the following steps:
on the reference version and the target version, respectively.
‚Ä¢ Step-1: VulScope collects ùëáùëüùëí ùëì and ùëáùë°ùëéùëüùëîùëíùë° with the given PoC
‚Ä¢ Step-2: VulScope performs cross-version trace alignment on ùëáùëüùëí ùëì
and ùëáùë°ùëéùëüùëîùëíùë° to get the aligned functions between the two traces.
‚Ä¢ Step-3: If a crash is observed on the target version, VulScope
uses crash triage to verify whether this crash is triggered by the