 和一个（组）新的.pat
 文件，得到以下结果：
$ ./sigmake libc_FreeBSD80.pat libc_FreeBSD80.sig  
libc_FreeBSD80.sig: modules/leaves: 1088/1024, COLLISIONS: 10  
See the documentation to learn how to resolve collisions.
这里引用的文档资料为 sigmake.txt ，它描述了 sigmake
 的用法及冲突解决过程。实际上，每次sigmake
 开始执行时，它都会搜索一个对应的排斥文件，以从中了解如何解决在处理指定的模式文件时遇到的任何冲突。如果没有这个排斥文件，在发生冲突时，sigmake
 会生成这样一个排斥文件，而不是签名文件。在上面的例子中，我们发现了一个名为 libc_FreeBSD61.exc 的新建文件。在创建之初，排斥文件是文本文件，它详细说明了 sigmake
 在处理模式文件时遇到的冲突。你必须编辑排斥文件，以指导 sigmake
 应如何解决任何相互冲突的模式。下面我们将讨论编辑排斥文件的一般过程。
sigmake
 生成的所有排斥文件均以下面的代码开头：
;--------- (delete these lines to allow sigmake to read this file)  
; add '+' at the start of a line to select a module  
; add '-' if you are not sure about the selection  
; do nothing if you want to exclude all modules
这些代码的目的是告诉你如何解决冲突，以成功生成签名。你需要做的头件大事是删除4 行以分号开头的代码，否则，sigmake
 将无法在随后的执行过程中解析排斥文件。下一步是告诉sigmake
 你希望如何解决冲突。从 libc_FreeBSD80.exc 中提取出的几行代码如下所示：
_index   00 0000 538B4424088A4C240C908A1838D974074084DB75F531C05BC3..............  
_strchr  00 0000 538B4424088A4C240C908A1838D974074084DB75F531C05BC3..............  
_rindex  00 0000 538B5424088A4C240C31C0908A1A38D9750289D04284DB75F35BC3..........  
_strrchr 00 0000 538B5424088A4C240C31C0908A1A38D9750289D04284DB75F35BC3..........  
_flsl    01 EF04 5531D289E58B450885C0741183F801B201740AD1E883C20183F80175F65D89D0  
_fls     01 EF04 5531D289E58B450885C0741183F801B201740AD1E883C20183F80175F65D89D0
这些代码详细说明了 3 个冲突：index
 函数很难与strchr
 函数区分开，rindex
 的签名与 strchr
 相同，flsl
 与fls
 相互冲突。如果你熟悉其中一些函数，对于上面的结果，你就不会觉得奇怪，因为相互冲突的函数基本上完全相同（例如，index
 与strchr
 执行相同的操作）。
为了让你“掌握自己的命运”，sigmake
 让你仅指定一个函数作为相关签名的匹配函数。任何时候，如果在数据库中发现一个对应的签名，并且你想应用一个函数的名称，那么，你可以在该函数名称前附加一个加号；如果你只想在数据库中添加某个函数的注释，则在该函数名称前附加一个减号；如果在数据库中发现对应的签名时，你不想应用任何名称，那么，你不需要添加任何符号。下面的代码为上面提到的 3 个冲突提供了一种可行的解决方案：
+_index   00 0000 538B4424088A4C240C908A1838D974074084DB75F531C05BC3..............
_strchr  00 0000 538B4424088A4C240C908A1838D974074084DB75F531C05BC3..............  
_rindex  00 0000 538B5424088A4C240C31C0908A1A38D9750289D04284DB75F35BC3..........  
_strrchr 00 0000 538B5424088A4C240C31C0908A1A38D9750289D04284DB75F35BC3..........  
_flsl    01 EF04 5531D289E58B450885C0741183F801B201740AD1E883C20183F80175F65D89D0  
-_fls     01 EF04 5531D289E58B450885C0741183F801B201740AD1E883C20183F80175F65D89D0
在这个代码段中，我们决定在数据库中发现第一个签名时，使用函数名 index
 ；发现第二个签名时，不做任何处理；发现第三个签名时，在数据库中添加一段有关fls
 的注释。在解决冲突时，请记住以下要点。
为最大限度地减少冲突，请删除排斥文件开头的 4 个注释行。
最多只能给冲突函数组中的一个函数附加+/ -。
如果一个冲突函数组仅包含一个函数，不要在该函数前附加+/ -，让它保持原状即可。
sigmake
 连续运行失败会将数据（包括注释行）附加到现有的任何排斥文件后。在再次运行sigmake
 之前，你必须删除这些额外的数据，并更正原始数据（如果这些数据是正确的，sigmake
 将不会再次运行失败）。
更改排斥文件后，你必须保存这个文件，并使用你最初使用的命令行参数重新运行sigmake
 。这一次，sigmake
 应该能够定位和遵照你的排斥文件，并成功生成一个.sig 文件。如果 IDA 没有显示错误消息，且生成一个.sig 文件，如下所示，即表示 sigmake
 操作成功：
$ ./sigmake libc_FreeBSD80.pat libc_FreeBSD80.sig
成功生成签名文件后，你需要将它复制到你的/sig目录中，以便 IDA 使用这个文件。随后，你可以通过 File▶Load File ▶FLIRT Signature File 访问这个新签名。
需要注意的是，我们有意隐藏了所有可应用于模式生成工具和 sigmake
 的选项。有关可选项的完整列表，请参阅 plb.txt 和sigmake.txt 文件。这里我们仅介绍 sigmake
 的-n
 选项，它用于在一个生成的签名文件中植入一个描述性的名称。这个名称将在选择签名的过程中显示（见图12-1 ），并可在对签名排序时提供极大的帮助。下面的命令行将名称字符串“FreeBSD 8.0 C standard library ”植入到生成的签名文件中：
$ ./sigmake -n"FreeBSD 8.0 C standard library" libc_FreeBSD80.pat libc_FreeBSD80.sig
另外，你还可以使用排斥文件中的指令指定库名称。但是，并不是所有生成签名的过程都会需要排斥文件，因此使用命令行的方法更加有用。欲了解更多详情，请参阅 sigmake.txt 文件。
12.3.5 启动签名
IDA 还能够识别一种特殊的签名，即启动签名
 （startup signature ）。在初次将一个二进制文件加载到数据库中，确定用于创建该二进制文件的编译器时，IDA 将应用启动签名。如果 IDA 能够确定用于构建一个二进制文件的编译器，那么，在初步分析这个二进制文件的过程中，IDA 会自动加载与已确定的编译器有关的其他签名文件。
由于初次加载文件时，IDA 并不知道用于创建该文件的编译器类型，这时，IDA 会根据所加载的二进制文件的类型来分类和选择启动签名。例如，如果加载的是一个 Windows PE二进制文件，那么，IDA 会加载与PE二进制文件有关的启动签名，以确定用于构建该 PE二进制文件的编译器。
要生成启动签名，sigmake
 将处理描述各种编译器生成的启动例程7
 的模式，并把得到的签名组合到一个特定于类型的签名文件中。FLAIR 工具的startup
 目录中包含IDA 使用的启动模式，以及用于从这些模式创建对应的启动签名的脚本——startup.bat。请参阅startup.bat 了解使用sigmake
 创建某一特定文件格式的启动签名的示例。
7. 通常，启动例程被视为程序的入口点。在C/C++ 程序中，启动例程用于在将控制权转交给 main函数之前对程序的环境进行初始化。
就PE文件而言，你会在 startup 目录中发现几个 pe_*.pat 文件，这些文件描述的是一些常用的Windows 编译器所使用的启动模式，如描述Visual Studio模式的 pe_vc.pat 文件和描述Cygwin/ gcc 模式的pe_gcc.pat文件。如果你希望添加 PE文件的其他启动模式，必须将它们添加到一个现有的PE模式文件中，或创建一个名称以 pe_
 开头的新模式文件，以方便生成启动签名的脚本找到你的模式，并将它们合并到新生成的 PE签名中。
最后，你还需要注意启动模式的格式，它与为库函数生成的模式的格式稍有不同。其不同在于：启动模式行能够将启动模式与其他签名关联起来，在对启动模式进行匹配时，IDA 还会应用这些签名。除 startup 目录中保存的示例启动模式外，FLAIR 中的任何文本文件都没有记录启动模式的格式。
12.4 小结
库代码自动识别是一个重要的功能，它明显减少了分析静态链接二进制文件所需的时间。利用它的FLIRT 和FLAIR 功能，用户可从现有的静态库创建他们自己的库签名，它不仅使自动代码识别成为可能，而且使它具有了可扩展性。对于任何可能遇到静态链接二进制文件的用户而言，了解如何生成签名是一项基本的技能。
第13章 扩展IDA 的知识
根据前面的讨论可知，一个高质量的反汇编代码清单显然不仅仅是一个由字节序列生成的助记符和操作码组成的。为使反汇编代码清单发挥更大的作用，我们需要用在处理各种与API 有关的数据（如函数原型和标准数据类型）时获得的信息来扩充反汇编代码清单。在第8 章中，我们讨论了 IDA 如何处理数据结构，包括如何访问标准 API 数据结构和如何定制数据结构。本章将通过分析 IDA 的idsutils
 和loadint
 实用工具的用法，继续讨论扩展 IDA 的知识。你可以从 IDA 的产品光盘上获得这些实用工具，或者从 Hex-Rays 的下载站点下载1
 。
1. 参见http://www.hex-rays.com/idapro/idadown.htm
 。下载时需要提供有效的用户名和密码。
13.1 扩充函数信息
IDA 通过两种途径获得与函数有关的信息：类型库（.til）文件和 IDS 实用工具（.ids ）文件。在初始分析阶段，IDA 使用存储在这些文件中的信息来提高反汇编过程的准确性及反汇编代码清单的可读性。它通过合并函数参数名称和类型，以及与各种库函数有关的注释来完成这个任务。
第8 章曾提到过，类型库文件是 IDA 用于存储复杂数据结构布局的机制。同时，IDA 还使用类型库文件记录与函数的调用约定和参数序列有关的信息。IDA 以各种方式使用函数签名信息。首先，当一个二进制文件使用共享库时，IDA 无法知道这些库中的函数使用的是什么调用约定。这时，IDA 会尝试根据一个类型库文件中的相关签名来匹配库函数。如果它发现一个匹配的签名，IDA 就可以知道这个函数使用的调用约定，并对栈指针进行必要的调整（如前所述，stdcall
 函数自己对栈进行清理）。使用函数签名的第二种方式是为传递给函数的参数提供注释。这些注释说明在调用函数之前，到底是哪一个参数被压入到栈上。注释提供的信息量取决于 IDA 能够解析的函数签名所包含的信息量。下面的两个签名都是有效的C 声明，第二个签名提供了更多有关函数的信息，除数据类型以外，它还提供了形式参数名称。
LSTATUS _stdcall RegOpenKey(HKEY, LPCTSTR, PHKEY);  
LSTATUS _stdcall RegOpenKey(HKEY hKey, LPCTSTR lpSubKey, PHKEY phkResult);
IDA 的类型库中保存着大量常用API 函数（包括许多Windows API）的签名信息。调用RegOpenKey
 函数的默认反汇编代码清单如下所示：
.text:00401006   00C      lea     eax, [ebp+➋hKey]  
.text:00401009   00C      push    eax             ➊; phkResult  
.text:0040100A   010      push    offset  ➋SubKey   ; "Software\\Hex-Rays\\IDA"  
.text:0040100F   014      push    80000001h       ➊; hKey  
.text:00401014   018      call    ds:RegOpenKeyA  
.text:0040101A ➌00C      mov     [ebp+var_8], eax
值得注意的是，IDA 已经在右边缘（➊）添加了注释，指出在调用 RegOpenKey
 之前，每个指令压入了什么参数。如果函数签名提供形式参数名称，那么 IDA 会更进一步，自动为与特定的参数对应的变量命名。在前面例子中的➋处，我们看到 IDA 已经根据 RegOpenKey
 原型中对应的形式参数名称，对一个局部变量（hKey
 ）和一个全局变量（SubKey
 ）进行了命名。如果解析后的函数原型中仅包含类型信息，而没有形式参数名称，那么，前面例子中的注释将指出对应参数的数据类型，而非参数名称。至于 IpSubKey
 参数，这个参数名称并不作为注释显示，因为这个参数碰巧指向一个全局字符串变量，而该字符串的内容则通过 IDA 的重复注释机制显示。最后，需要注意的是，IDA 已经将 RegOpenKey
 识别为一个 stdcall
 函数，并自动调整了栈指针（➌），RegOpenKey
 在返回时也会这样做。所有这些信息均源自该函数的签名，同时，IDA 将在反汇编代码清单中适当的导入表位置以注释的形式显示这些信息，如下面的代码段所示：
.idata:0040A000 ; LSTATUS __stdcall RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)  
.idata:0040A000                extrn RegOpenKeyA:dword ; CODE XREF: _main+14p  
.idata:0040A000                                        ; DATA XREF: _main+14r
显示函数原型的注释来自 IDA 的一个.til 文件，该文件提供与Windows API函数有关的信息。
那么，在什么情况下，你希望生成自己的函数类型签名1
 呢？如果你遇到一个链接到（无论是动态还是静态）IDA 并不包含其函数原型的库的二进制文件，你可能希望为这个库中的所有函数生成类型签名信息，以便 IDA 能够为自动为你的反汇编代码清单生成注释。这类库包括常用的图形或加密库，虽然它们不属于标准 Windows 库，但却使用广泛。OpenSSL 加密库就是这样一个库。
1. 这里，我们使用术语“签名”表示一个函数的参数类型、数量和顺序，而不是匹配已编译函数的代码模式。
第8 章提到过，我们可以在一个数据库的本地.til 文件中添加复杂的数据类型信息。同样，我们可以通过 File▶Load File ▶Parse Header File 命令让IDA 解析一个或几个函数原型，在同一个.til 文件中添加函数原型信息。类似地，你可以使用 tilib.exe（参见第8 章）解析头文件和创建独立的.til 文件，通过将这些.til 文件复制到/til 中，这些文件就可以全局使用。
如果你可以访问源代码，然后允许 IDA （或tilibexe ）为你解析源代码，那当然很好。但多数情况下，你都无法访问相关源代码，并且你仍然希望获得高质量的反汇编代码清单。那么，在没有源代码可供参考的情况下，你如何为 IDA 提供信息呢？这正是 IDA 实用工具或 idsutils
 的作用所在。这些 IDA 实用工具包括 3 个用于创建.ids 文件的实用程序。我们首先介绍.ids 文件的定义，然后说明如何创建我们自己的.ids 文件。
手动重写被删除字节
利用 stdcall
 调用约定的库函数可能会给 IDA 的栈指针分析造成不良影响。缺乏任何类型库或.ids 文件信息，IDA 都无法知道导入函数是否使用 stdcall
 约定。了解这一点非常重要，因为IDA 可能无法在函数（IDA 并不了解它们的调用约定信息）调用中正确跟踪栈指针的行为。除了需要知道函数使用了 stdcall
 外，IDA 还必须了解在完成操作时，这个函数到底从栈上删除了多少个字节。缺乏调用约定信息，IDA 将尝试使用一种叫做“单纯方法”（simplex method）2
 的算术分析技巧自动确定一个函数是否使用stdcall。第二种技巧需要 IDA 用户手动干预。图13-1是一个专门用于编辑导入函数的函数编辑对话模式。
2. Ilfak 在他的一篇博客文章中介绍了在IDA 5.1 版中引入的“单纯方法”，地址为http://hexblog.com/2006/06
 。
图13-1 编辑导入函数
导航到函数的导入表条目并选择编辑这个函数（Edit ▶Functions ▶Edit Function ，或ALT+P ），即可打开该对话框。需要注意的是，这个特殊的对话框提供的功能有限（相对于图7-7 所示的“编辑函数”对话框）。因为这是一个导入函数条目，IDA 无法访问该函数的已编译主体，因而也无法获得与该函数的栈帧结构有关的信息，以及它是否使用stdcall
 约定的直接证据。由于缺乏这些信息，IDA 只得将Purged bytes输入框设置为1，表示它不知道该函数在返回时是否从栈中清除了字节。在这种情况下，要重写 IDA ，需要输入已删除字节的正确数量，这样，在相关函数被调用时，IDA 会将获得的信息合并到它的栈指针分析中。如果 IDA 了解该函数的行为，Purged bytes输入框可能已经填有数据（如图 13-1 所示）。注意，使用“单纯方法”分析时，这个输入框绝不可能会填入数据。
13.1.1 IDS 文件
IDA 使用.ids 文件扩展它在库函数方面的知识。.ids 文件通过列举共享库中包含的每一个导出函数，来描述这个库的内容。与函数有关的详细信息包括函数名称、它的相关序号3
 ，还包括该函数是否使用 stdcall
 （如果使用 stdcall
 ，包括返回时该函数从栈上删除了多少字节的代码），另外也包括在反汇编代码清单中引用该函数时显示的可选注释。.ids 文件实际上是压缩后的.idt文件，后者包含每个库函数的文本说明。
3. 序号是与每个导出函数有关的整数索引。使用序号可通过整数查询表迅速定位一个函数。若通过将函数名称与字符串进行比较来定位函数，则很缓慢。
初次在数据库中加载一个可执行文件时，IDA 将确定该文件所依赖的共享库。IDA 会在/ids目录中搜索与每一个共享库对应的.ids 文件，以获得有关该可执行文件可能引用的任何库函数的说明。需要记住的是，.ids 文件中不一定包含函数签名信息。因此，IDA 可能无法仅仅根据.ids 文件中的信息提供函数参数分析。但是，如果.ids 文件能够正确指出函数所使用的调用约定，以及函数从栈中清除的字节数量，IDA 就能够进行准确的栈指针调整。如果一个 DLL导出改编名称，IDA 就能够根据这个改编名称推断出一个函数的参数签名，在加载.ids 文件后，我们就可以利用这些信息。我们将在 13.1.2 节介绍.idt 文件的语法。在这方面，.til 文件包含与反汇编函数调用有关的更多有用信息，不过，要想生成.til 文件，你需要使用源代码。
13.1.2 创建IDS 文件