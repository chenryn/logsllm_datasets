beneﬁt from our framework’s features. Existing apps’ bina-
ries do not need to be modiﬁed to beneﬁt. However, it is
possible for power users with root access to their device to
install our modiﬁcations on their devices without having to
wait for an oﬃcial update or having to make major changes
to their device, such as ﬂashing the device.
A noteworthy feature of our solution is that it does not
break binary compatibility and could in theory be used to
protect existing apps as well. Our modiﬁcations only aﬀect
private ﬁnal methods of the Java Framework and thus do
not break modularity or collide with developer code. This
would instantly ﬁx all the vulnerable apps we discovered in
our studies. However there are some rare pathological cases
which would need to be considered if our system were to be
applied to all apps blindly. We discuss these issues and the
possible trade-oﬀs in Appendix B.1.
7. LIMITATIONS
We contacted 78 developers and asked them to participate
in interviews about the identiﬁed SSL issues in their apps.
Only 14 developers agreed to participate in an interview
while all others either did not respond at all or turned down
our request with reference to company guidelines forbidding
them to talk about conﬁdential information. Despite the
relatively small number of participants, we were still able to
identify a wide range of causes which lead to serious security
issues in the context of app development and SSL. After the
developer study, we conducted a large scale code analysis
and did not ﬁnd any indication that there were further issues
that would warrant more interviews.
8. CONCLUSION
In this paper, we argue for a new way of handling SSL
connections on appiﬁed platforms, since previous work dis-
covered severe problems in this area. To discover the root
causes of these problems, we conducted a study of 1,009
iOS apps to ascertain whether iOS suﬀers from the same
problems as Android. We also surveyed developer forums
and conducted a developer study. Based on our ﬁndings, we
proposed to rethink how developers interact with SSL: in-
stead of requiring developers to work with SSL on the code
level, we designed and implemented a framework that allows
them to protect their network connections via conﬁguration.
Our solution prevents developers from willfully or acciden-
tally breaking SSL, while at the same time giving them easy
access to additional features, such as pinning and the secure
use of self-signed certiﬁcates. We evaluated our proposal
with existing Android apps and showed that all use-cases
we found can be implemented more easily and securely with
our approach. The feedback we gathered from developers
was also very positive.
There are several important areas of future work: Our
framework oﬀers all necessary features to include alternative
certiﬁcate validation strategies such as Certiﬁcate Trans-
parency and AKI just to name two. We are currently work-
ing on plugins for these proposals to implement these promis-
ing solutions. Since currently there is a great amount of
research being conducted on these alternative validation ap-
proaches, we believe our framework can make a valuable
contribution by enabling this research to be deployed with
greater ease and thus not only to be studied better but also
hopefully to help with real world adoption.
Furthermore, while we currently recommend our solution
to be adopted by new or updated apps, it is in theory pos-
sible to apply our changes to all existing apps, thus ﬁxing
all broken apps with one update. In future work, we will
investigate how to discover and avoid possible side-eﬀects
in apps that applied benign code modiﬁcations to the SSL
validation process. For more on this avenue of research, the
reader is referred to Appendix B.
Acknowledgments
We would like to thank all the developers that agreed to sup-
port our research, openly discussed security issues in their
apps and provided us with the background needed to design
our solution.
58References
[1] P. P. F. Chan, L. C. K. Hui, and S. M. Yiu. Droid-
Checker: Analyzing Android Applications for Capabil-
ity Leaks. In WISEC ’12: Proceedings of the Fifth ACM
Conference on Security and Privacy in Wireless and
Mobile Networks. ACM Press, Apr. 2012.
[2] L. Davi, A. Dmitrienko, A. Sadeghi, and M. Winandy.
Privilege Escalation Attacks on Android. In Proceed-
ings of the 13th International Conference on Informa-
tion Security, pages 346–360, 2011.
[3] P. Eckersley. Sovereign Key Cryptography for Internet
Domains. https://git.eff.org/?p=sovereign-keys.
git;a=blob;f=sovereign-key-design.txt;hb=
master.
[4] A. Egners, B. Marschollek, and U. Meyer. Messing
In Proceedings of
with Android’s Permission Model.
the IEEE TrustCom, pages 1–22, Apr. 2012.
[5] S. Fahl, M. Harbach, T. Muders, L. Baumg¨artner,
B. Freisleben, and M. Smith. Why Eve and Mal-
lory Love Android: An Analysis of Android SSL
(In)Security. In Proceedings of the 19th ACM Confer-
ence on Computer and Communications Security. ACM
Press, Oct. 2012.
[6] A. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, and
D. Wagner. Android Permissions: User Attention,
Comprehension, and Behavior.
In Proceedings of the
Eighth Symposium on Usable Privacy and Security.
ACM Press, 2012.
[7] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner.
Android permissions Demystiﬁed. In Proceedings of the
18th ACM Conference on Computer and Communica-
tions Security. ACM Press, Oct. 2011.
[8] M. Georgiev, S.
Iyengar, S. Jana, R. Anubhai,
D. Boneh, and V. Shmatikov. The Most Dangerous
Code in the World: Validating SSL Certiﬁcates in Non-
Browser Software.
In Proceedings of the 2012 ACM
Conference on Computer and Communications secu-
rity. ACM Press, Oct. 2012.
[9] P. Hoﬀman and J. Schlyter. The DNS-Based Authenti-
cation of Named Entities (DANE) Protocol for Trans-
port Layer Security (TLS): TLSA . https://tools.
ietf.org/html/rfc6698, Aug. 2012.
[10] T. Hyun-Jin Kim, L.-S. Huang, A. Perrig, C. Jackson,
and V. Gligor. Accountable Key Infrastructure (AKI):
A Proposal for a Public-Key Validation Infrastructure.
In Proceedings of the 2013 Conference on World Wide
Web, to appear, 2013.
[11] B. Laurie, A. Langley, and E. Kasper. Certiﬁcate
Transparency. Network Working Group Internet-Draft,
v12, work in progress. http://tools.ietf.org/html/
draft-laurie-pki-sunlight-12, Apr. 2013.
[12] M. Marlinspike. TACK: Trust Assertions for Certiﬁcate
Keys. http://tack.io/draft.html.
[13] M. Marlinspike. SSL And The Future Of Authenticity.
In BlackHat USA 2011, 2011.
[14] P. Saint-Andre and J. Hodges. RFC 6125, Mar. 2011.
[15] R. Schlegel, K. Zhang, X. Zhou, M. Intwala, and e. al.
Soundcomber: A Stealthy and Context-aware Sound
Trojan for Smartphones. Proceedings of the Network
and Distributed System Security Symposium, 2011.
[16] J. Sunshine, S. Egelman, H. Almuhimedi, N. Atri,
and L. Cranor. Crying Wolf: An Empirical Study of
SSL Warning Eﬀectiveness. In Proceedings of the 18th
USENIX Security Symposium, pages 399–416, 2009.
[17] T. Vidas, D. Votipka, and N. Christin. All Your Droid
Are Belong To Us: A Survey Of Current Android At-
tacks. In Proceedings of the 5th USENIX Workshop on
Oﬀensive Technologies, pages 10–10, 2011.
[18] D. Wendlandt, D. G. Andersen, and A. Perrig. Per-
spectives: improving ssh-style host authentication with
multi-path probing. In USENIX 2008 Annual Technical
Conference on Annual Technical Conference, ATC’08,
pages 321–334, Berkeley, CA, USA, 2008. USENIX As-
sociation.
[19] Y. Zhou and X. Jiang. Dissecting android malware:
Characterization and evolution.
In Security and Pri-
vacy (SP), 2012 IEEE Symposium on, pages 95–109,
2012.
APPENDIX
A.
IOS SURVEY DETAILS
Several of the vulnerable apps we found were created us-
ing popular programming frameworks. Since any bug intro-
duced by such a framework could potentially aﬀect a large
number of apps, we decided to take a closer look at these
frameworks. During our analysis, we identiﬁed two cross-
platform mobile application SDKs and an iOS networking
wrapper library that all create code that contains vulnera-
ble SSL certiﬁcate validation.
MKNetworkKit.
The MKNetworkKit9 is a networking wrapper library for
iOS with the aim to be easy to use and to simplify the
iOS default networking stack.
In online forums, such as
stackoverflow.com, developers often complain about prob-
lems with iOS’s built-in networking APIs, accounting for
the popularity of libraries such as MKNetworkKit, which
provides lightweight methods for standard networking tasks.
The library can also handle HTTPS requests, but fails when
it comes to SSL server certiﬁcate validation.
Titanium Framework.
The Titanium cross platform mobile application SDK10
is a JavaScript-based platform which enables developers to
write mobile apps in JavaScript and automatically trans-
lates them into native mobile apps. Titanium targets iOS,
Android and HTML5, making it particularly attractive for
web developers who want to create mobile apps. While the
9http://blog.mugunthkumar.com/products/
ios-framework-introducing-mknetworkkit/
10http://www.appcelerator.com/platform/
titanium-sdk/
59Titanium framework generates secure SSL code for Android,
SSL certiﬁcate validation for iOS apps is turned oﬀ. Based
on app creation statistics posted on their website, this could
aﬀect more than 30,000 apps built with the framework.
PhoneGap.
PhoneGap11 is a free open source framework for develop-
ing mobile apps for seven platforms including Android and
iOS, using HTML, CSS and JavaScript.
It contains dedi-
cated classes for data transfer that include customized SSL
veriﬁcation code. For Android and iOS, the framework pro-
duces code that eﬀectively turns SSL certiﬁcate validation
oﬀ. If developers do not manually check the generated code,
they will not see the comment and thus not be aware of the
problem. According to PhoneGap12, more than 23,000 apps
could be aﬀected.
B. TRANSITION PERIOD/COLD-TURKEY
UPDATE
With such a high number of users at risk and such a
slow/non-existent response time by developers when ﬁxing
the vulnerabilities, it might be worth considering activating
our framework not only for new apps but for all existing apps
as well. This would instantly ﬁx all instances of apps with
broken SSL we could ﬁnd. There are two ways in which our
framework could be deployed in such a case. The ﬁrst ap-
proach would simply override custom SSL code. This would
work ﬁne for 98 % of the 13,500 apps we analyzed and ﬁx
all the broken ones. However, the remaining 2 % would lose
important functionality (such as custom pinning) until the
developers update their apps. They would still have stan-
dard certiﬁcate validation but their custom improvements
would be disabled. So while applying our framework for all
apps in this way is simple and helps most apps, it would
be good to avoide this undesirable side-eﬀect. A second ap-
proach could combine our framework’s validation code with
the app’s custom SSL validation code. In this case, the sim-
ple rule would be only if both validation methods accept a
certiﬁcate, then the connection is established. If one of the
two validation processes rejects a certiﬁcate, a warning mes-
sage is shown to the user by our framework.13 The main
issue with this is that users could potentially see two warn-
ing messages for the same connection: In those cases where
validation legitimately fails and the developers of the app
followed best practices and warns the user and the users ac-
cepts the invalid certiﬁcate, our framework would also warn
the user and the user would have to accept again. While
this is not a security threat per se, it is a highly undesirable
characteristic to have in a system. However, our code anal-
ysis has shown that these cases should be very rare when
no MITM attacker is present. Thus this could be consid-
ered an acceptable trade-oﬀ to ﬁx the many vulnerabilities
which otherwise will remain unﬁxed for an unknown amount
of time. It might also be possible to get the developers of
the ”good“ apps to update their apps for the greater good by
11http://phonegap.com/
12http://www.slideshare.net/AndreCharland/
phone-gap-stats-growth
13For the cold-turkey approach, the default warning mecha-
nism would be switched from “drop connection” to “warning”
since we cannot automatically tell in advance if the app has
a legitimate reason to connect to untrusted hosts.
contacting them before the cold-turkey roll-out. Ironically
getting the few ”good“ developers to react is probably eas-
ier than getting all the developers with vulnerable apps to
react. However, evaluating and discussing the ramiﬁcations
of this kind of roll-out is beyond the scope of this paper and
would need to be discussed in the community.
B.1 Pathological Cases
There are some pathological cases that need to be consid-
IP Addresses Instead of Hostnames
ered when activating our framework for existing apps:
B.1.1
The current Android API allows URLs and socket con-
nections to be established with IP addresses instead of host-
names. Using an IP address has the drawback that host-
name veriﬁcation might not work properly. The concept of
virtual hosts for HTTP(S) servers hinders eﬀective hostname
veriﬁcation when an IP address is used to establish a con-
nection instead of a hostname, since common names for SSL
certiﬁcates typically are fully qualiﬁed domain names [14].
Yet, there are certiﬁcate authorities14 that issue certiﬁcates
with IP addresses as the common name. So, while creating
a secure connection using an IP address can cause problems
because hostname veriﬁcation fails, there is also a valid use-
case for this practice. Our SSL API treats IP addresses as
normal hostnames during hostname veriﬁcation.
We analyzed the set of Android 13,500 apps to ﬁnd those
that include URLs using IP addresses instead of hostnames
to estimate the scope of this practice in Android apps. In
all 13,500 apps, we found 163 apps (1.21 %) that include IP
address-based URLs, pointing to 118 diﬀerent hosts. 88 of
these IP addresses did not support SSL. Of the 30 which
supported SSL, only one of the remaining used a certiﬁcate
for which hostname veriﬁcation did not fail. However, this
certiﬁcate was self-signed, so none of the IP address-based
apps used SSL correctly.
B.1.2 Custom Sockets
If an app implements a custom application layer socket
that resolves hostnames by itself, it may rely on the SSLSock-
etFactory to create an SSL-secured socket based on only
an IP, but cater for hostname veriﬁcation itself at a later
stage. Given the modiﬁcations of our framework, this imple-
mentation would break, as our modiﬁed SSLSocketFactory
would attempt to verify the hostname (in this case the IP ad-
dress) during the handshake and fail because the hostname
in the certiﬁcate presented by the server is unknown to the
SSLSocketFactory. While it is uncommon to not delegate
hostname resolution to the operating system, we acknowl-
edge that such implementations would need to be updated
to work with our modiﬁcations.
14e. g. https://www.globalsign.com/
60