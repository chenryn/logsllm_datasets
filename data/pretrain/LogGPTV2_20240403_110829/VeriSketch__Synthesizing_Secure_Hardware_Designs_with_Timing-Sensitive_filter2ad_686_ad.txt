the formal properties. Thus, the properties should effectively elimi-
nate all undesirable programs. This makes property specification a
major challenge. For example, consider the cache example where
IFT properties similar to Example 4.17 are in place to eliminate
side-channel leakage and synthesize the sketch from Fig. 2(a). A
trivial implementation that results from this sketch and satisfies
the IFT properties is a design that skips all cache accesses. While
this satisfies the security properties, it is not what the designer in-
tended to get. However, it is not clear how to formalize the property
being violated in this case. The designer can potentially get around
this issue by providing input/output (I/O) pairs which should be
generated by the synthesized design, extending the formal prop-
erties, or shrinking the sketch such that undesirable programs are
unreachable. However, all these approaches require non-trivial ef-
fort from the designer. Instead, we take an automated approach to
heuristically guide the search algorithm to avoid recommending
undesirable designs. We introduce soft constraints for specifying
properties which may not hold for all cases but it is desirable if
they do. Soft constraints are particularly beneficial for modeling
performance attributes.
Definition 5.3 (Soft Constraint). Soft constraints are logical for-
mulas that model properties which are preferably true. We show
soft constraints for the design being synthesized by T(x, p).
Example 5.4. A soft constraint for synthesizing the secure cache
can be defined by indicating that that having a low value for the
skip signal and a high value for the lru_update signal (from Fig. 2)
are desirable. While this constraint cannot be strictly enforced if one
wants to eliminate timing side channel, we use it to guide CEGIS to
find a design which does not skip cache writes and updates the LRU
if possible. Using the try keyword to model the soft constraints, we
rewrite the properties for synthesizing a secure cache as follows:
if ( pid =i && Preloaded [ addr ]) assume ( index_s == High );
if ( pid(cid:44)i) assert ( rd_proc_t == Low );
try (! skip && lru_update );
In order to enforce soft constraints via synthesis, we extend the
CEGIS algorithm to further explore the input space by searching
for positive examples.
Definition 5.5 (Positive Example). Positive example pe for the
design synthesized with p = pi is any input trace which satisfies
the specification Φ∗(x, pi).
Positive examples represent cases where the design is working
correctly according to the hard constraints. Positive examples are
gathered after each verification round by searching the input space
surrounding the newly found counterexample.
Definition 5.6 (Exploration). The exploration round computes
the set of positive examples PE by searching the design space sur-
rounding each counterexample x. Exploration can be modeled by
the following SAT problem for xm ∈ x:
∗(a, pi) ∧ 
∃a. Φ
(aj = x j)
(6)
x j ∈x∧j(cid:44)m
While the original CEGIS algorithm tries to fix the design by
enforcing hard constraints on the counterexamples, we direct it to
further enforce soft constraints on the collected positive examples.
This is done by modifying the synthesis round to find a design such
that soft constraints are held for the maximum possible number of
collected positive examples while hard constraints are held for all
visited counterexamples. This new synthesis problem is defined by:
Definition 5.7 (Synthesis Target for Soft Constraints T ).

∗(xj , p) ∧ 
Φ
∃p.
xj ∈CE
T
xi ∈P E
∗(xi , p) = n
∗(xi , p) := 
k ≤|xi |
where T
Past(T(xi , p), k)
(7)
The synthesis round iteratively solves Eq.7 and decreases n from
|PE| to zero if unsatisfiable.
Theorem 5.8. If satisfiable, CEGIS with soft constraints finds the
program which enforces soft constraints on the maximum number
of collected positive examples.
Proof Outline. Each synthesis round solves Eq.7 by setting n :=
|PE| initially and decrease n if unsatisfiable. Hence, if satisfiable,
parameter p represents the design where soft constraints are held
for maximum n ≤ |PE|.
□
ALGORITHM 1: Given sketch F(x), hard constraints C(x),
and soft constraints C′(x), VeriSketch generates Fsyn(x).
: F(x), C (x), C′ (x) : VeriSketch
Input
Output: Fsyn(x) s.t. ∀x . C(x) : Verilog
1 F (x, p) ← pre-processing (F(x))
2 FIFT (x, xtaint, p) ← instrumentation (F(x, p), C(x))
3 P ← CEGIS (FIFT (x, xtaint, p), C(x), C′(x))
4 if P (cid:44) unsat then
Fsyn(x) ← post-processing (F(x, p), P)
5
return Fsyn
6
7 else return unsat
Soft constraints are ignored in the verification round since they
do not necessarily hold for all input traces. This means that the
equisatisfiability of the synthesis problem does not change as soft
constraints are added. Hence, one can add soft constraints without
worrying about making the problem unsatisfiable.
Theorem 5.9. Soft constraints do not impact satisfiability of the
synthesis problem.
Proof Outline. The synthesis parameter, the verification equation,
and hence the domain of valid programs remain the same by adding
soft constraints. Furthermore, the synthesis equation in each round
reduces to the original synthesis equation (i.e., Eq.5) in the worst
□
case. Thus, the satisfiability does not change.
Synthesis by soft constraints combines techniques from property-
based and example-based synthesis by automatically searching for
examples which should be generated by the synthesized design.
ALGORITHM 2: Counterexample guided inductive synthe-
sis (CEGIS) for synthesizing sequential circuits with soft con-
straints
: Φ (x, p), T (x, p)
Input
Output:pi s.t. ∀x . Φ(x, pi)
1 Initial Stage:
2 pi ← random assignment
3 CE ← ∅
4 PE ← ∅
5 while 1 do
6
7
8
9
10
11
12
Verification Phase:
ce ← SAT (∃x . ¬Φ(x, pi))
if ce = unsat then return pi
else
CE ← CE ∪ ce
Exploration Phase:
pem ← SAT (∃a.Φ∗(a, pi) ∧
aj = ce j)

ce j ∈ce ∧ j(cid:44)m
k ≤|a| Past(Φ(a, p), k)
Φ∗(a, p) := 
solution ← SAT ∃p. 
sumpe := 
j , p) := 
Φ∗(xj , p) := 
if pem (cid:44) unsat then PE ← PE ∪ pem ;
Synthesis Phase:
for (l = |PE|; l ≥ 0; i = i − 1) do
xj ∈CE
T∗(x
′
j , p)
j | Past(T(x
′
j ∈P E
j , p), k)
k ≤|x′
k ≤|xj | Past(Φ(xj , p), k)
T∗(x
x
′
′
13
14
15
16
17
18
19
20
Φ∗(xj , p) ∧ (sumpe = l)
if solution(cid:44)unsat then pi ← solution; break
else if l=0 then return unsat
21
22
23
24 end
end
Alternatively, one can manually specify the positive examples; how-
ever, defining traces of examples for sequential circuits may be chal-
lenging itself. The overall VeriSketch flow and CEGIS algorithm for
synthesizing sequential circuits with soft constraints are shown in
Algorithm 1 and 2, respectively.
6 EXPERIMENTS
We now demonstrate four examples of security-critical hardware
designs that are successfully synthesized by VeriSketch.
• Constant Time Arithmetic Units We implement fixed
point arithmetic units which run in constant time. We use
IFT specification to model constant time behaviour and non-
synthesizable1 portion of the Verilog language to model
functional properties.
• Leakage-free caches: We add sketch constructs (following
the partition lock methodology [48]) to traditional cache
1Synthesizable in this case refers to the portion of the language that can be mapped to
a gate-level netlist. Complex Verilog operators can only be used in simulation.
Table 3: Summary of synthesized designs in terms of lines
code for the sketch, synthesized code and specifications.
Design
Fixed Point Arithmetic
Direct Mapped Cache
4-way Set Associative Cache
Hardware Thread Scheduler
SoC Arbiter
Sketch LoC
VeriSketch
59
243
303
73
57
Spec. LoC
VeriSketch
33
73
73
92
80
Syn. LoC
Verilog/AST
107/961
379/3809
512/6098
365/2308
487/4262
architectures and synthesize two caches (direct mapped and
4-way set associative) which are resilient against timing side
channel attacks. We model resilience against timing side
channel attacks as IFT properties and add soft constraints to
model performance traits.
• Hardware thread schedulers: We synthesize schedulers
for fine-grained multithreading in mixed criticality systems
by defining properties regarding confidentiality between
threads, guaranteed scheduling frequency, and timing pre-
dictability. We define three sketches of different size and
synthesize each to satisfy different combinations of the prop-
erties along with soft constraints modeling efficiency and
fairness.
• System-on-chip (SoC) arbiters: We synthesize arbiters to