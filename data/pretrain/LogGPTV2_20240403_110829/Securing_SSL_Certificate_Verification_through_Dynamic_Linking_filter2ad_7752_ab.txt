CertShim works under multiple trust models, and we there-
fore consider adversaries of varying strengths. A weak at-
tacker might only possess an untrusted CA certiﬁcate, but
a stronger attacker might possess a valid certiﬁcate from a
trusted CA, or even control parts of the Internet architec-
ture (e.g., network paths, trusted CAs, DNS resolvers). We
discuss the security of various veriﬁcation modules against
these adversaries in Section 3.4. When client-based key pin-
ning is considered, we assume that the Client has had one
opportunity to correctly authenticate the server in the past,
which is necessary for use in Trust on First Use (TOFU)
authentication [5].
We seek to secure client-side non-browser applications that
are benign but potentially defective in their use of SSL. In
particularly, we wish to protect against insecure use of SSL
libraries. Except where otherwise noted, we do not consider
incorrectness within the underlying libraries themselves [7,
20], assuming instead that they are correctly implemented.
This work is motivated by the fact that developers often fail
to ﬁx vulnerable code, so we assume that the applications
will not take active countermeasures to bypass our mecha-
nism. CertShim interposes on popular known SSL libraries;
we do not consider applications that use their own SSL im-
plementations. Doing so would increase the cost and com-
plexity of software development, and in evaluation we found
no evidence that this was a widespread practice. However,
we do anticipate that applications can use many layers of
abstraction/misdirection in calling an SSL API, such as a
cURL wrapper for a scripting language.
3.2 System Goals
We set out to design a mechanism that provided the fol-
lowing system-wide properties:
Override Insecure SSL Usage. Force safe defaults for
certiﬁcate handling (i.e., validation of hostnames and certiﬁ-
cate chains) on all SSL connections, regardless of whether
or not the application makes any attempt to do so. This
encompasses applications that misconﬁgure the SSL API,
applications that use insecure SSL wrappers, and applica-
tions that are broken by design.
Enable SSL Trust Enhancements. In addition to tra-
ditional veriﬁcation, our system should be conﬁgurable to
enable the use of CA alternatives and enhancements. CA
Alternatives are often incapable of correctly authenticating
all Internet domains due to design limitations or incremental
deployment, so we also wish to provide a means of querying
multiple veriﬁcation methods and reconciling their results.
Maximize Compatibility. Due to the great diversity of
SSL usage, existing software will use SSL APIs in ways that
we cannot anticipate, some of which may be perfectly valid
and secure. These constraints could be application-speciﬁc,
such as using a pinned certiﬁcate, or trusting a corporate
CA. Others could be domain-speciﬁc, such as a server on
an unreachable private network, or a server that has not
published a TLSA record [23]. Our mechanism must be able
to coexist with these applications without breaking them.
Maximize Coverage. As applications could conceivably
re-implement SSL from the RFCs, it is impossible to enu-
merate all of the possible SSL libraries. However, we wish to
maximize the coverage of our defensive layer by supporting
the libraries that are most commonly used by SSL applica-
tions in practice.
396// D e t e r m i n e SSL i n i t i a l i z a t i o n type
type = r e s o l v e _ c t x _ t y p e ( ctx )
// Obtain the domain and port
name = l o o k u p _ n a m e ( ctx )
port = l o o k u p _ p o r t ( ctx )
1 int S S L _ g e t _ v e r i f y _ r e s u l t ( SSL * ctx )
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
// Call a v a l i d a t i o n Fu n c ti o n
status = 0
if ( C O N F I G _ C E R T _ P I N N I N G )
// Grab the c e r t i f i c a t e f i n g e r p r i n t
sha = e x t r a c t _ c t x _ f i n g e r p r i n t ( ctx )
status += k e y p i n _ v e r i f y ( name , port , sha )
if ( C O N F I G _ C E R T _ A U T H O R I T Y )
status += c a _ v e r if y ( name , port , sha )
if ( C O N F I G _ C O N V E R G E N C E )
status +=
20
21
22
23
24
25
26
27
c o n v e r g e n c e _ v e r i f y ( name , port , sha )
if ( C O N F I G _ D A N E )
status += d a n e _ v e r i f y ( name , port , sha )
// Check the results
if ( resolve ( status ) == OK )
return X 5 0 9 _ V_ O K
else
return X 5 0 9 _ E R R _ I N V A L I D _ C A
shim.c
Figure 2: Pseudocode for CertShim’s dynamically loaded
SSL_get_verify_result function.
values of the instrumented function are consistent with the
original library API. Pseudocode for CertShim’s version of
ssl_get_verify_result() can be found in Figure 2.
In
lines 2-7, the canonical name and port of the certiﬁcate are
recovered.
In lines 9-10, the certiﬁcate ﬁngerprint (SHA1
hash) is extracted from the SSL context. Certiﬁcate valida-
tion functions are called in lines 12-19. Lines 21-25 return
the standard X509 accept or reject values based on whether
or not the certiﬁcate was approved.
Handshake Functions. Hooking the veriﬁcation functions
alone is insuﬃcient to force proper veriﬁcation in vulnera-
ble applications due to the fact that they often go unused
by developers [19]. Therefore, CertShim also targets the
main connection functions of SSL libraries, which represent a
choke point at which we can force certiﬁcate veriﬁcation. We
instrument OpenSSL’s ssl_connect() and ssl_do_hand-
shake() functions and GnuTLS’s gnutls_do_handshake()
function. CertShim ﬁrst calls the original functions from
each respective library, returning its error code if the con-
nection failed on its own (e.g., due to network connectivity
failure). If the call is successful, however, CertShim calls
the veriﬁcation module as described above.
If veriﬁcation
fails, CertShim generates an error that emulates a connec-
tion failure, essentially short-circuiting the SSL connection
and forcing the application to recover (shown in Figure 3).
This system behavior is likely to cause unexpected behav-
ior in some applications; however, as we show in Section 3.4
the behavior of the veriﬁcation module can be conﬁgured to
prevent application breakage.
CertShim’s inclusion of both handshake and veriﬁcation
functions is to ensure that vulnerable SSL code is hooked.
This is necessary because numerous studies have shown that
Figure 1: CertShim interoperates with various SSL li-
braries, replacing their certiﬁcate veriﬁcation functions with
those from proposed CA alternatives.
Function
connect
do handshake
get verify result
handshake
certiﬁcate verify peers2
certiﬁcate verify peers3
CheckIdentity
CheckIdentity
SetEndpointIdentifAlg
connect
gethostbyname
getaddrinfo
Purpose
Initial SSL handshake
Renegotiate handshake
Check veriﬁcation result
SSL handshake
Verify certiﬁcate (deprec.)
Verify certiﬁcate
Verify hostname
Verify hostname
Verify hostname
Location
libssl1.0.0
libssl1.0.0
libssl1.0.0
libgnutls26
libgnutls26
libgnutls26
JDK6
JDK7
JDK7
System call Track hostname, port
System call Track hostname, port
System call Track hostname, port
Table 1: Functions that CertShim overrides/hooks. Multi-
ple hooks are required because libraries have multiple entry
points that trigger certiﬁcate veriﬁcation.
3.3 CertShim
Our system, CertShim, is a dynamically linked shared ob-
ject that performs binary instrumentation in order to layer
additional security onto popular SSL implementations, Open-
SSL and GnuTLS, and includes an additional mechanism
that instruments JSSE’s SSLSocketFactory. Shown in Fig-
ure 1, CertShim works primarily through use of the Linux
dynamic linker’s LD_PRELOAD environment variable. Under
normal circumstances, a function such as ssl_connect()
would resolve to code in libssl.so. However, when Cert-
Shim is enabled, the linker ﬁrst looks at our shared object
before moving to the standard include paths, allowing us
to redeﬁne the behavior of the library’s veriﬁcation function
without modifying speciﬁc executables, as shown in Figure
3. CertShim performs additional certiﬁcate checks and also
calls the original functions such that the security seman-
tics of the original library workﬂow are preserved. If those
additional checks fail, CertShim triggers a connection fail-
ure and also creates a syslog record that includes both an
explanation and a suggested template policy for ﬁxing the
problem. The speciﬁc form of veriﬁcation is modular, and
is discussed at greater length in Section 3.3.2.
3.3.1 Function Hooks
CertShim targets both veriﬁcation functions and hand-
shake functions in SSL libraries as well as system calls that
allow for the recovery of important network context. A list
of the CertShim’s function hooks is included in Table 1.
Veriﬁcation Functions. CertShim instruments OpenSSL’s
ssl_get_verify_result() and GnuTLS’ gnutls_certifi-
cate_verify_peer() to support modular certiﬁcate veriﬁ-
cation. Regardless of which module is enabled, the return
python-aptnetcatcurlmailutilslibssl1.0.0gnutls26CertShimConvergenceDANEPreloaded Shared ObjectSSL ApplicationsSSL Libraries. . .. . .. . .Key PinningPolicy Engine3973.3.2 Veriﬁcation Modules
Currently, CertShim supports 4 certiﬁcate veriﬁcation
methods:
• Traditional CA Veriﬁcation: The module invokes
the underlying native SSL API calls.
• Convergence[30]: The module communicates with
Convergence Notaries via a REST API. Convergences
local cache is implemented as a sqlite3 database, and
the list of trusted notaries and a veriﬁcation threshold
is set via a conﬁguration ﬁle.
• DANE [23]: The module is a thin wrapper around
Lexis’ SWEDE library for TLSA record veriﬁcation
[35]. This serves to demonstrate that existing proto-
types for SSL trust enhancements can be easily adapted
for use with CertShim. With minor modiﬁcations,
this module could be used to deploy Liang et. al.’s
DANE extension for securing CDN connections in non-
browser software [27].
• Client-Based Key Pinning: Implementations cur-
rently exist as Firefox Plug-Ins [37, 42]. Rather than
adapting these utilities, we developed our own trust-
on-ﬁrst-use key pinning module that stores certiﬁcate
ﬁngerprints in an sqlite3 database.
Not only does CertShim facilitate the use of any one of
these modules, it also oﬀers support for certiﬁcate validation
through ensemble voting strategies. For example, all 4 of
the modules can be enabled simultaneously, with a majority
vote determining whether or not the certiﬁcate is approved.
In the event that a veriﬁcation method fails but overall ver-
iﬁcation passes, CertShim prints a notiﬁcation of the fail-
ure to syslog. Because CertShim uses a single veriﬁcation
module across many implementations of SSL, prototyping
clients for new CA alternatives becomes a one-time cost and
interoperability with a variety of SSL libraries is assured.
3.4 Policy Engine
CertShim includes a policy engine that allows users to
easily express complex certiﬁcate veriﬁcation routines that
can be enforced system-wide or tailored to a speciﬁc appli-
cation or domain. Policies are deﬁned by the user in an
Apache-like conﬁguration ﬁle that is dynamically loaded ev-
ery time an application is invoked, allowing for the user to
alter the SSL behavior of all applications on the system at
any time without having to recompile. Figure 4 is an ex-
ample of such a policy deﬁnition ﬁle. The conﬁguration
subsystem of CertShim uses libconfig [1] for parsing the
conﬁguration ﬁle and extracting data.
The structure of the policy ﬁle is easy to understand and
use. A global_policy entry deﬁnes the system-wide be-
havior of CertShim except for cases where a more speciﬁc
policy is present. The engine ﬁnds relevant policy entries by
pattern matching over the cmd and host keys, with priority
being given to host entries. The methods key in each entry
allows for the enabling and disabling of speciﬁc veriﬁcation
modules. The vote key represents the percent of modules
that must return true before CertShim approves the cer-
tiﬁcate. When a key is not set in a speciﬁc entry, it inherits
the value of the global policy. The ordering of the policies
within the conﬁguration ﬁle is irrelevant.
Figure 3: Interaction between a client application using the
SSL_connect() function and CertShim.
negligent developers often fail to consult SSL veriﬁcation
functions [17, 19]. As a consequence, however, CertShim
will redundantly verify certiﬁcates in well-formed SSL code.
The veriﬁcation function hooks are superseded by the hand-
shake hooks in normal usage, but we felt it important to
hook the veriﬁcation functions so that the libraries’ certiﬁ-
cate handling was consistent across diﬀerent parts of the
API. We show in Section 5 that the performance costs of
using CertShim are minimal, and that this redundancy is
a small price to pay for the added coverage assurances.
Network Context. Some alternate certiﬁcate veriﬁcation
methods, such as network probing, require a canonical host-
name and port in order to validate an X509 certiﬁcate. How-
ever, the structures passed into OpenSSL and GnuTLS func-
tions do not reliably contain this information. This is due
to the great variety of ways in which these routines are in-
voked; in some cases, certiﬁcates are veriﬁed without being
aware of the endpoint with which the SSL session is be-
ing established. To recover this information, we instrument
the getaddrinfo(), gethostbyname(), and connect() sys-
tem calls. By recording the parameters passed and returned
from the original functions, we were able to perform reverse
lookups that translated socket ﬁle descriptors to hostnames,