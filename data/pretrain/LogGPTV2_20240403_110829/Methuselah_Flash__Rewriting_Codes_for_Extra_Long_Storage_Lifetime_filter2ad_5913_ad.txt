implementation  reasons  for  having  reasonably  large  (multi-
kilobyte)  pages.    For  example,  smaller  pages  require  more 
Figure 14. Lifetime gain for different page sizes. 
metadata  to  track  the  mapping  between  data  and  pages  and 
more complex garbage collection mechanisms.  
  Analysis of MFC Objectives 
MFCs  choose  codewords  from  cosets  so  as  to  achieve 
three objectives: avoid writing to saturated cells, minimize the 
number  of  cells  that  increment,  and  balance  the  increments 
across  the  cells.    In  this  section,  we  show  how  well  MFCs 
achieve the latter two objectives; the first objective is always 
required.  The results in this section help to explain the higher 
level results presented earlier. 
1)  Minimize the Number of Cells that Increment 
For each page update, we calculate the fraction of cells that 
increment.  We further distinguish these results based on how 
many updates have already been done to this page since it was 
last erased.  We compare WOM and MFC-1/2-1BPC, so recall 
that the WOM code achieves only 2 updates per page while 
MFC-1/2-1BPC achieves 12 updates. 
188
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:41 UTC from IEEE Xplore.  Restrictions apply. 
Figure 15. Average number of increments. 
We show the results in Figure 15, in which the x-axis is 
the page update number since its last erase, and the y-axis is 
the average fraction of cells that increment.  We also present, 
on the far right, an average over all page update numbers. We 
observe  that  MFC-1/2-1BPC  has  on  average  17%  of  the  v-
cells  incremented  in  each  update,  whereas  WOM  has  an 
average of 75%. We also notice that in the case of MFC-1/2-
1BPC  the  first  two  updates  have  the  fewest  increments 
(~14%). The reason we observe that is because, in the first two 
updates, the majority of the v-cells are in level L0 and thus the 
cost of balancing increments is minimal. In the later updates, 
the  number  of  increments  is  increased  as  MFCs  also  try  to 
balance increments. 
2)  Balance Increments Across Cells 
We calculate the histogram of the levels that the cells reach 
before the page gets erased. We present that result in Figure 
16 for MFC-1/2-1BPC and the WOM code.  
We  observe  that  for  the  case  of  MFC-1/2-1BPC  the 
majority of the cells reach level L2 and, on average, only 0.5% 
of the v-cells stay on level L0. That means that 99.95% of the 
v-cells  are  programmed  at  least  once  while  88.5%  of  them 
Figure 16. Histogram of the v-cell levels before erasure.  
189
reach  level  L2  or  L3.  In  an  ideal  case,  all  cells  would  have 
reached level L3 before erase, but that is not achievable. 
In  the  case  of  the  WOM  code,  only  56%  of  the  v-cells 
reach levels L2 or L3 and 6% of them never get programmed. 
Interestingly  both  implementations  have  about  the  same 
number of v-cells in level L3 (~20%). That result shows that 
saturated cells are a crucial bottleneck for re-writing codes and 
indicates that 20% of the v-cells being saturated is an average 
number  that  causes  the  whole  page  to  be  unable  to  be  re-
programmed. 
IX.  RELATED WORK 
There  are  two  complementary  approaches  for  extending 
lifetime:  postponing  wearout  and  tolerating  wearout.    Our 
MFCs, described in Section V, focus on postponing wearout  
and can be combined with ECC, as shown in Section V.B, to 
also tolerate wearout. 
  Postponing Wearout 
There are two techniques for postponing wearout: coding 
and wear-leveling.  Since we have already discussed coding, 
we focus here on wear-leveling. 
Intuitively,  one  would  prefer  not  to  wear  out  one  or  a 
handful of cells out of the thousands of cells in a page, thus 
rendering  the  entire  page  unusable.    At  a  larger  scale,  one 
would prefer not to wear out one or a handful of pages out of 
the many pages in a block, thus reducing the effective size of 
the block (leading to more frequent erasing of the block). It is 
important that all cells across pages and blocks are wearing 
out uniformly in order to ensure a good lifetime performance. 
Many schemes have been developed for wear-leveling at 
different granularities. The main focus on Flash memories is 
on the block granularity [20, 21, 22]. By adding some extra 
complexity in the FTL algorithm, blocks can have a more even 
number  of  erases.  Problems  arise  with  blocks  containing 
“cold” and “hot” data, meaning data that are either rarely or 
frequently  modified  respectively.  These  algorithms  try  to 
detect such blocks and evenly distribute the erases by using 
various techniques. This may increase the overall number of 
block erasures.  
Flash memory, in its current form, does not require page 
wear leveling mechanisms as every page inside a block is only 
programmed exactly one time before erased. However in the 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:41 UTC from IEEE Xplore.  Restrictions apply. 
case  of  a  coding  scheme,  like  MFCs,  wear  leveling  at  that 
granularity may be beneficial. Research in that area [23] has 
provided  solutions  for  other  memory  types  (i.e.  PCM).  The 
main idea is to select the pages to program in such an order, 
so that you evenly use all pages 
  Tolerating Wearout 
Tolerating  wearout  is  an  important  aspect  in  Flash 
memory  for  multiple  reasons.  The  first  reason  is  that  some 
Flash cells may start wearing out a lot faster than the indicated 
lifetime due to various defects in the cells. Additionally some 
cells may be manufactured with defects and thus be unable to 
retain  information  from  the  start  of  the  life  of  the  product. 
Such failures are commonly observed in Flash memories [13]. 
Flash  memory 
implementations provide some extra capacity that is used for 
ECC  [13].  Different  ECCs  have been proposed [24, 25, 26] 
that explore tradeoffs between complexity, size and correction 
capabilities. 
common 
For 
these 
reasons 
Other ways of tolerating wearout, besides ECC, have been 
also  proposed.  Schechter  et  al.  [19]  use  a  finite  number  of 
redundant  cells  that  are  used  to  replace  the  initial  defective 
cells  as  well  as  the  cells  that  wear  out  faster  than  expected. 
Although their scheme is presented for PCM it can be used for 
any non-volatile memory. 
X.  CONCLUSION 
We  conclude  that  Methuselah  Flash  Codes  can  provide 
several benefits for Flash. We showed that MFCs achieve the 
best aggregate gains in comparison to prior work, as well as 
providing a range of trade-offs between rate and lifetime gain 
for a given aggregate gain. Furthermore, we believe that the 
compatibility  of  MFCs  with  ECC  makes  MFCs  particularly 
attractive.  
We also conclude that, regardless of the coding scheme, 
one  must  carefully  consider  the  interface  provided  by  a 
realistic  Flash.  Rather  than  assuming  idealized  cells,  we 
highlighted the limitations of the current interface and found 
a  way  to  provide  virtual  cells  that  facilitate  coding  on  real 
Flash. 
Another  conclusion  of  this  work  is  that  there  could  be 
benefits to co-designing Flash chips with code designers and 
systems designers. Decisions like the mapping of cell levels 
to bits and the sizes of the pages could be optimized for a given 
purpose  and  maximize  the  benefits  of  re-writing  codes  like 
MFCs.  Eslami  et  al.  [27]  showed  how  such  a  co-design 
process could be beneficial for phase change memory (PCM), 
and  it  is  possible  that  co-design  for  Flash  offers  similar 
opportunities. 
ACKNOWLEDGMENT 
This material is based on work supported by the National 
Science Foundation under grant CCF-142-1177. 
REFERENCES 
[1]   A. Jiang, R. Mateescu, M. Schwartz and J. Bruck, "Rank Modulation 
for  Flash  Memories,"  IEEE  Transactions  on  Information  Theory, 
vol.55, no.6, pp.2659-2673, June 2009.  
[2]   W. Chua, K. Cai and Wang Ling Goh, "Efficient Two-Write WOM-
Codes  for  Non-Volatile  Memories,"  IEEE  Communications  Letters, 
vol.19, no.10, pp.1690-1693, Oct. 2015.  
[3]   A. Bhatia, M. Qin, A. Iyengar, B. Kurkoski and P. Siegel, "Lattice-
Based WOM Codes for Multilevel Flash Memories," IEEE Journal on 
Selected  Areas  in  Communications,  vol.32,  no.5,  pp.933-945,  May 
2014.  
[4]   A.  Jiang,  V.  Bohossian  and  J.  Bruck,  "Floating  Codes  for  Joint 
Information  Storage 
in  Write  Asymmetric  Memories,"  IEEE 
International Symposium on Information Theory, pp.1166-1170, Jun. 
2007.  
[5]   S.  Kayser,  E.  Yaakobi,  P.  Siegel,  A.  Vardy  and  J. Wolf,  "Multiple-
write  WOM-codes,"  in  48th  Annual  Allerton  Conference  on 
Communication, Control, and Computing, pp.1062-1068, Oct. 2010.  
[6]   A.  Jacobvitz,  R.  Calderbank  and  D.  Sorin,  "Writing  Cosets  of  a 
Convolutional  Code  to  Increase  the  Lifetime  of  Flash  Memory,"  in 
50th  Annual  Allerton  Conference  Communication,  Control,  and 
Computing, pp. 308–318, 2012.  
[7]   B.  Kurkoski,  "Rewriting  Flash  Memories  and  Dirty-paper  Coding," 
IEEE  International  Conference  on  Communications,  pp.4353-4357, 
Jun. 2013.  
[8]   G.  J.  Forney,  "Coset  Codes.  I.  Introduction  and  Geometrical 
Classification,"  IEEE  Transactions  on  Information  Theory,  vol.34, 
no.5, pp.1123-1151, Sep. 1988.  
[9]   G. J. Forney, "Coset Codes. II. Binary Lattices and Related Codes," 
IEEE  Transactions  on  Information  Theory,  vol.34,  no.5,  pp.1152-
1187, Sep 1988.  
[10]  R. Hasbun and F. Janecek, “Multiple Writes Per a Single Erase for a 
Nonvolatile Memory,” U.S. Patent No. 5,936,884. 10 Aug. 1999.  
[11]  V.  Mohan,  T.  Siddiqua,  S.  Gurumurthi,  and  M.  R.  Stan,  “How  I 
Learned to Stop Worrying and Love Flash Endurance,” in Proceedings 
of  the  2nd  USENIX  Conference  on  Hot  topics  in  Storage  and  File 
Systems, pp. 3–3, 2010.  
[12]  Y. Cai, O. Multu, E. F. Haratsch, K. Mai, "Program Interference in 
MLC  NAND  Flash  Memory:  Characterization,  Modeling,  and 
Mitigation," IEEE 31st International Conference on Computer Design 
(ICCD), pp.123-130, 2013.  
[13]  L. Grupp, A. Caulfield, J. Coburn, S. Swanson, E. Yaakobi, P. Siegel 
and 
"Characterizing  Flash  Memory:  Anomalies, 
Observations,  and  Applications,"  in  42nd  Annual  IEEE/ACM 
International Symposium on Microarchitecture, pp.24-33, Dec. 2009. 
J.  Wolf, 
[14]  L. A. Lastras-Montaño, M. Franceschini, T. Mittelholzer, J. Karidis, 
and  M.  Wegman,  “On  the  Lifetime  of  Multilevel  Memories,”  in 
Proceedings  of 
the  2009  IEEE  International  Symposium  on 
Information Theory, vol. 2, pp. 1224–1228, 2009.  
[15]  R. L. Rivest and A. Shamir, "How to Reuse a "Write-once" Memory," 
Information and Control, vol.55, no.1, pp.1-19, 1982.  
[16]  E.  Yaakobi,  S.  Kayser,  P.  Siegel,  A.  Vardy  and  J.  Wolf,  "Efficient 
Two-write WOM-codes," in Information Theory Workshop, pp.1-5, 
2010.  
[17]  E. Yaakobi, S. Kayser, P. Siegel, A. Vardy and J. Wolf, "Codes for 
Write-Once  Memories,"  IEEE  Transactions  on  Information  Theory, 
vol.58, no.9, pp.5985-5999, Sept. 2012.  
[18]  S. Lin and D. J. Costello, Jr, Error Control Coding, 2nd ed. Pearson 
Prentice Hall, 2004.  
[19]  S. Schechter, G. H. Loh, K. Straus and D. Burger, "Use ECP, not ECC, 
for Hard Failures in Resistive Memories," in Proceedings of the 37th 
Annual International Symposium on Computer Architecture, pp.141-
152, 2010.  
190
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:41 UTC from IEEE Xplore.  Restrictions apply. 
[20]  L.-P.  Chang,  "On  Efficient  Wear  Leveling  for  Large-scale  Flash-
memory  Storage  Systems,"  in  Proceedings  of  the  2007  ACM 
Symposium on Applied Computing (SAC '07), pp.1126-1130, ACM, 
2007.  
[21]  Y.-H. Chang, J.-W. Hsieh and T.-W. Kuo, "Endurance Enhancement 
of Flash-memory Storage Systems: An Efficient Static Wear Leveling 
Design,"  in  Proceedings  of  the  44th  Annual  Design  Automation 
Conference, pp.212-217, Jun 2007.  
[22]  L.-P.  Chang  and  C.-D.  Du,  "Design  and  Implementation  of  an 
Efficient  Wear-leveling 
Solid-state-disk 
Microcontrollers,"ACM  Transactions  on  Design  Automation  of 
Electronic Systems (TODAES), vol. 15, no. 1, pp.1-36, 2009.  
Algorithm 
for 
[23]  M. K. Qureshi, J. Karidis, M. Franceschini, V. Srinivasan, L. Lastras 
and B. Abali, "Enhancing Lifetime and Security of PCM-based Main 
Memory with Start-gap Wear Leveling," in Proceedings of the 42nd 
Annual  IEEE/ACM  International  Symposium  on  Microarchitecture, 
pp.14-23, 2009.  
[24]  G. Dong, N. Xie and Tong Zhang, "On the Use of Soft-Decision Error-
Correction  Codes  in  NAND  Flash  Memory,"  IEEE  Transactions  on 
Circuits and Systems I: Regular Papers, vol.58, no.2, pp.429-439, Feb. 
2011.  
[25]  B. Chen, X. Zhang and Zhongfeng Wang, "Error Correction for Multi-
level  NAND  Flash  Memory  Using  Reed-Solomon  Codes,"  IEEE 
Workshop on Signal Processing Systems, pp.94-99, Oct. 2008.  
[26]  S.  Gregori,  A.  Cabrini,  O.  Khouri  and  G.  Torelli,  "On-chip  Error 
Correcting  Techniques  for  New-generation  Flash  Memories,"  in 
Proceedings of the IEEE , vol.91, no.4, pp.602-616, April 2003.  
[27]  A. Eslami, A. Velasco, A. Vahid, G. Mappouras, R. Calderbank and 
D. J. Sorin, "Writing without Disturb on Phase Change Memories by 
Integrating Coding and Layout Design," in Proceedings of the 2015 
International  Symposium  on  Memory  Systems,  ACM,  pp.71-77, 
2015.  
191
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 09:41:41 UTC from IEEE Xplore.  Restrictions apply.