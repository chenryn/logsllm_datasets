sists of two phases. In the ﬁrst phase, the initiator rapidly
generates (but does not instantiate) candidate paths con-
sisting of three relays chosen uniformly at random with-
out replacement. The initiator computes the e2e cost of
each generated candidate path. In the second phase, the
initiator sorts the candidate paths by their cost estimates,
and then applies Eq. 1 to select the path.
5.2.3 Hybrid Selection
relay selection.
The following rule selects a path whose minimum
bandwidth is above Thres by a conditional join on nodes
in the table, and then uses the coordinate embedding sys-
tem to select a path with e2e latency less than Limit. In
this example, the table of all nodes node(IP, Coord,
BW) stores the virtual latency coordinate as well as band-
width for each node IP. Interestingly, we need only make
one change to replace c1 (from 5.2.1) with h1:
h1 eCandidatePath(Src, Dst, Limit,
RAND(3)) :-
ePathRequest(Src, Dst, Limit, Thres),
node(IP,Coord,BW),
Src!=IP, Dst!=IP, BW>THRES.
Other hybrid policies using multiple metrics can
be similarly constructed (for example, using the
WEIGHTED policy only on nodes whose bandwidth is
above a threshold).
6 Path Instantiation Policies
A3’s forwarding engine performs path instantiation,
a process that establishes necessary network state at each
selected relay to enable bidirectional data ﬂow over an
anonymous circuit between a given initiator and any des-
tination. Unlike relay selection, which happens locally
at the initiator, path instantiation is an inherently dis-
tributed operation, and thus exercises the distributed ex-
ecution features of A3LOG.
In this section, we demonstrate the use of A3LOG for
path instantiation. Due to space constraints, we primar-
ily emphasize Onion Routing [30] and leave a discussion
of Tor [9] and Crowds [31] to Appendix B. We evaluate
the performance of our Onion Routing path instantiation
implementation in Section 7.2.1.
We begin with a brief overview of the path instanti-
ation scheme used by Onion Routing. After selecting
a path consisting of one or more relays – called onion
routers – the initiator sends a recursively encrypted mes-
sage called an onion to the ﬁrst hop of the selected path.
Each layer of the onion contains the address of the next
desired hop in the path, and seed material to generate
symmetric keys shared with the initiator 3. Public key
cryptography ensures that every node can interpret ex-
actly one layer of the onion. Each node removes its
layer, generates keys from the seed material, and – if
it is not the endpoint – forwards the remainder of the
onion on to the next hop. The endpoint sends a con-
ﬁrmation message to the initiator backward along the
newly-instantiated path.
Although the above rules use a single metric when se-
lecting a path, it is easy to combine multiple factors for
3In practice, each layer also contains information about which
cryptographic algorithm to use in each direction of the circuit, a times-
tamp, and a version identiﬁer.
More precisely, if the relays in the anonymous path
are R1, ..., Rn and M1, ..., Mn are the relays’ corre-
sponding onion layers,
then the onion is encrypted
as ER1(M1, ER2(M2, ..., ERN (MN ))), where EX(W )
denotes the encryption of message W using the public
key belonging to X. In practice, only the key seed ma-
terial is encrypted with the public key. The remaining
data is encrypted using a symmetric key derived from
the key seed material.
Onion routing speciﬁes an additional link-layer pro-
tocol that governs how messages are exchanged between
onion routers. For a discussion of this protocol, see [30].
6.1 Onion Routing in A3LOG
Our A3LOG implementation of Onion Routing re-
quires 12 rules to specify path instantiation. These rules
consist of three recursive computations: building the
onion, relaying the onion along the path to establish state
at each node, and forwarding a conﬁrmation back along
the path. We extended our implementation to support
forwarding data along an instantiated path at a cost of
ﬁve additional rules.
We brieﬂy summarize the schema (data format) of
the facts computed in relations at each node. All facts
are indexed by a locally unique CID (circuit identi-
ﬁer). An initiator stores a circuitPath(CID,Path)
fact that associates a circuit with a path representing
the chosen relay nodes. The Path variable represents
the result of the relay selection phase and is popu-
lated based on the ePathResult tuple.
In addition,
the initiator stores the current state of the circuit in
the circuitStatus(CID,Status) relation. The value
for Status may be either BUILDING or ESTABLISHED.
As the path is being instantiated,
the initiator and
each intermediate relay creates a link-local
identi-
ﬁer (ACI) for the circuit, stored along with the cir-
cuit’s next relay in a circuitForward(CID,ACI,Node)
fact.
the ﬁnal relay and each interme-
diate relay stores the ACI generated by the pre-
vious Node in the circuitReverse(CID,ACI,Node)
symmetric encryption
relation.
keys (shared with the initiator)
forward and
reverse cryptographic operations are stored in the
circuitKeys(CID,ForwardKey,ReverseKey) relation.
For each relay node, the initiator maintains these keys
in the circuitInitiator(CID, Relay, ForwardKeys,
ReverseKeys) relation.
At each relay,
Similarly,
for
It is worth noting that many of the relations used by
the Onion Routing rules can also be used by Tor and
Crowds. For example, all of these systems involve mul-
tiplexing trafﬁc from multiple anonymous circuits over a
single link, necessitating the use of per-circuit link-local
unique identiﬁers. Also, in each system, paths are bidi-
rectional, requiring intermediate nodes to store the next
node in each of the forward and backward directions. To
differentiate between different types of paths, we use a
circuitType(CID, Type) relation.
Below, we highlight the use of A3LOG via the follow-
ing three rules (oc1-oc3) that express the local recursive
computation of generating an Onion at the initiator:
oc1 circuitPath(CID, Path),
circuitStatus(CID, "BUILDING"),
circuitForward(CID, ACIForward, FirstRelay),
eCreateOnion(CID,LastRelay,
RemainingPath,FirstLayer) :-
ePathResult(_,_,Path),
FirstRelay=f_first(Path).IP,
LastRelay=f_last(Path).IP,
ACIForward=f_gen_aci(),
RemainingPath=f_removeLast(Path),
CID=f_gen_cid(), FirstLayer={}.
Rule oc1 is triggered upon insertion of a new path. It
generates state at the initiator for the new circuit, includ-
ing the local CID and link-local ACI. These are respec-
tively used to differentiate between circuits at a given
node and circuits on a given link. In addition, oc1 as-
sociates the new circuit with its path representation, and
a status describing the current stage of the circuit’s life-
cycle – BUILDING in this case indicates that the circuit
is currently being instantiated and is not yet ready for
use. Rule oc1 triggers the recursive rule, oc2, through
the eCreateOnion event:
oc2 eCreateOnion(CID,NextRelay,
RemainingPath,NextLayer) :-
eCreateOnion(CID, CurrentRelay,Path, PrevLayer),
f_size(RemainingPath) != 0,
NextRelay = f_last(Path).IP,
RemainingPath = f_removeLast(Path),
encryptOnion(CID, CurrentRelay,
NextLayer={NextRelay, EncryptedLayer}
PrevLayer, &EncryptedLayer),
The eCreateOnion event represents an intermediate
step of circuit instantiation. Its ﬁrst argument references
the CID of the circuit being created, its second notes the
most recently added relay, and its third contains the in-
termediate representation of the onion. Note that onions
are built outwards from the innermost layer. We denote
the innermost layer as an empty list, as this layer will be
interpreted by the ultimate relay in the circuit, who does
not extend the path any further.
Rule oc2 calls the encryptOnion Composable View
(CView, described in Section 6.2), which encrypts
the previous layer of the onion. Rule oc2 is lin-
early recursive and will continue to trigger itself and
derive new facts as long as RemainingPath is non-
empty. Each invocation of the rule removes a relay
node from RemainingPath as it adds a layer of encryp-
tion. Upon reaching the terminating condition – when
RemainingPath is empty – rule oc3 is triggered:
oc3 eOnionMessage(@FirstRelay, ACI, CompleteOnion) :-
eCreateOnion(CID, CurrentRelay,
RemainingPath, PrevLayer),
f_size(RemainingPath) = 0,
circuitForward(CID, ACI, FirstRelay).
encryptOnion(CID, CurrentRelay,
PrevLayer, &CompleteOnion).
Rule oc3 calls encryptOnion to encrypt the ﬁnal
layer of the onion, and sends the completed onion to the
ﬁrst relay node (via the location speciﬁer @FirstRelay)
read from the circuitForward relation. Upon receiv-
ing the onion, each intermediate relay will peel off and
decrypt a layer of the onion (using the decryptOnion
CView), extract the location of the subsequent hop, and
recursively forward the onion. We omit these rules due
to space constraints.
The observant reader will note that the above rules do
not implement Onion Routing’s link-layer protocol. One
may easily specify this protocol in A3LOG by adding a
layer of indirection to any rule that sends a high-level
anonymous message. We omit the speciﬁcation here, as
it involves relatively mundane serialization, encapsula-
tion, and encryption.
6.2 Composable Virtual View for Onion En-
cryption
In order maximize reusability between different
path instantiation protocols and enable re-conﬁgurable
encryption, we leverage Composable Virtual Views
(CViews) [22] to express high-level cryptographic prim-
itives. A CView is a user-deﬁned function implemented
in A3LOG. A call to a CView may only occur in the body
of a rule, and has the following syntax:
viewName(K1,K2,...,Kn, &R1,&R2,...,&Rm)
Each CView has a set of input attributes – shown
above as K1,K2,...Kn – which must be bound at the be-
ginning of the call to the CView, and a set of return at-
tributes, &R1,&R2,...,&Rm, that are returned by the call.
Note that CViews do not augment the expressive power
of the A3LOG language but rather provide modularity.
In fact, any rule that uses CViews can be rewritten as a
series of regular A3LOG rules using a rewrite [22].
We illustrate the encryptOnion CView used by the
above rule:
def encryptOnion(CID, Node, Data_in, &Data_E) {
eo1 circuitInitiatorKeys(CID, Node,
Key_forw, Key_back)
this.return(Data_E) :-
this.init(CID, Node, Data_in),
KeySeed = f_genKeySeed(),
Key_onion = f_sha1(KeySeed),
Key_forw = f_sha1(Key_Onion),
Key_back = f_sha1(Key_forw),
Payload_E = f_symEncrypt(Key_onion,Data_in),
publickey(Node,PubKey),
KeySeed_E = f_asymEncrypt(PubKey,KeySeed),
Data_E=[KeySeed_E, Payload_E].
}
The built-in predicates this.init and this.return
respectively specify the input values and return values
to/from the CView. Rule eo1 generates key seed mate-
rial and iteratively applies the SHA-1 hash function to
derive three symmetric keys to be shared between the
initiator and a given Node in the circuit: (i) Key onion,
used for encrypting the layer of the onion (except for
KeySeed) destined for Node; (ii) Key forw, used for cryp-
tographic operations on data sent forward from the ini-
tiator; and (iii) Key back, used for cryptographic opera-
tions on data sent backward to the initiator. These keys
are stored at the initiator in the circuitInitiatorKeys
relation4. Rule eo0 then employs Key onion to encrypt
Data in, which consists of the next node in the circuit,
and the previous layer of the onion. The KeySeed is then
encrypted with the public key of Node.
Because CViews can clearly separate the crypto-
graphic operations from the speciﬁcation of the proto-
col, one can easily tune the encryption by customiz-
ing the above encryptOnion (and the corresponding
decryptOnion) CView. Furthermore, CViews can facil-
itate reusability of these high-level cryptographic primi-
tives across different path instantiation protocols.
7 Evaluation
In this section, we describe our implementation of
A3 and present measurement studies that demonstrate its
ability to produce ﬂexible anonymous paths at low per-
formance overhead. To examine the scalability aspects
of our implementation, we evaluate A3 both in simula-
tion using real-world network traces as well as an actual
deployment on the PlanetLab testbed.
7.1
Implementation and Experimental Setup
A3’s Relay Selection and Forwarding Engines has
been implemented as an extension to the P2 [19] declar-
ative networking system, with enhancements to enable
the various new features of A3LOG as described in Sec-
tions 5 and 6. All relay selection policies used our ex-
periments produce paths with three anonymizing relays.
4Note that circuit initiator does not contain Key onion
– this key is only used for cryptographic operations on the onion sent
for path instantiation, and need not be persisted.
We utilize a MySQL database server as our Directory
Service. A3 nodes register with the service and query
for membership by sending SQL queries and updates to
the server. Membership information that has not been
refreshed within 15 minutes is purged from the direc-
tory. Although the MySQL protocol adds a small degree
of unnecessary bandwidth overhead, directory fetches
and updates occur infrequently. To minimize such over-
head, compression is enabled in both A3 clients and
the database server. The Local Directory Cache, which
queries the Directory Service for membership informa-
tion, stores the results in materialize tables that are ac-
cessible to the Relay Selection Engine.
The A3 system executes in simulation mode by tak-
ing as input a network trace consisting of pairwise la-
tency measurements [17] and running several A3 in-
stances on a single machine. Actual implementation
is achieved by running each A3 instance on PlanetLab,
interfacing with the Directory Service and Information
Providers.
Our experiments utilize two Information Providers.
Each relay (whether running in simulation mode or on
PlanetLab) participates in a Vivaldi [6] virtual coordi-
nate embedding system. Relays update the Network
Coordinate Information Provider (here,
the MySQL
database used as our Directory Service) with its new co-
ordinate when the Euclidean distance between coordi-
nate updates exceed 10ms. Additionally, our PlanetLab
experiments utilize the CoMon PlanetLab Monitoring
Infrastructure [27] to retrieve peers’ bandwidth, mem-
ory, and CPU usage information.
7.2 Relay Selection Evaluation
A3 is a ﬂexible anonymity framework that enables the
rapid development and deployment of relay selection al-
gorithms. To demonstrate A3’s ability to parse a diverse
set of relay selection policies, we evaluate the perfor-