– 2D66D7942148DE2D9F08EAB403921C89
• 收集设备信息并上传
– 设备型号
– 运营商信息
– 电话号码
• 通过短信接受远程命令控制
– start_sms_forwarding
– start_call_blocking
– send_sms
• 检测运行环境
– getDeviceId
– getLine1Number
模拟器检测方法-Pincer
• com.security.cert.a.a.c
通过比较DeviceId、Phone Number检测模拟器
模拟器检测方法-Pincer
• com.security.cert.b.b
获取DeviceId、Phone Number以及Network Operator
模拟器检测方法-Pincer
• com.security.cert.b.a.a
Disable相关组件
模拟器检测方法-Wroba
• MD5
– 0BDD5C05FE8B2C5D235CF54CAD21DC48
• 伪装成韩国NH银行应用
• 收集用户短信
• 发送短信
• 查询已安装应用程序
• 与远程服务器通信
• 判断是否为模拟器，核心后台
服务在模拟器环境下不运行
模拟器检测方法-Wroba
• nh.four.MainService
• nh.four.BaseMessage
– 通过android.os.Build获取系统属性
模拟器检测的目的
• 兼容性检查
• 数据收集
• 根据模拟器/真机推送不同数据内容
• 软件崩溃时的日志记录
• 防止自动化行为，如发送垃圾信息
• 隐藏恶意行为
• ...
正常样本与恶意样本检测结果对比
• 正常应用中近50%的样本有反模拟器行为，远高于
恶意样本
• 大量第三方库使用了模拟器检测
• 去除广告库的干扰，正常应用仍然比恶意应用的比
例高
• 通过判断是否有模拟器检测行为，不能作为判定样
本恶意性的主要依据之一
• 反模拟器技术应用普遍，直接影响应用程序在模拟
器上运行时的行为，同时恶意样本会隐藏恶意行为
研究反模拟器对抗技术意义重大！
如何构造更真实的模拟器，欺骗
应用程序其运行在真机环境？
反模拟器对抗的两种基本方法
• 源码修改
– 更改字段值、API行为
– 编译源码生成system.img
– 加载system.img运行模拟器
• Runtime Hook
– 运行时动态修改API调用行为
– Java层Hook 、Linux层Hook
源码修改缺点明显
• 优点
– 可直接修改硬编码字
段、文件内容等
– 修改后的内容在
Android系统最初的启
动阶段就可以生效
– 不需要Root权限
• 缺点
– 下载、编译源码的软
硬件需求高
– Android碎片化严重，
不同的版本都需要进
行源码修改
– 调试不便，编译时间
较长
– 后期修改、维护麻烦
– 无法动态更改API行为
Runtime Hook轻量灵活
• 优点
– 开发成本低，软硬件需求
不高
– 可针对不同的Android版
– 调试方便，类似于普通应
用程序开发
– 轻量级，可以APK、动态
链接库形式存在
– 部署方便
– 高度可定制
– 运行时可动态切换具体行
为
– 后期修改维护方便
• 缺点
– Hook生效时间较晚
– 硬编码字段无法修改
– 需要Root权限
Android Runtime Hook框架
• Rovo89, Xposed
– A framework for modules that can change the behavior of the 
system and apps without touching any APKs
• Saurik, Cydia Substrate
– The powerful code modification platform behind Cydia
• Collin Mulliner, adbi
– The Android Dynamic Binary Instrumentation Toolkit
Xposed基本原理
• 替换app_process
• 将需要Hook的Java函数替换成JNI函数
• 所有需要Hook的函数首先由xposedCallHandler处理
• XposedCallHandler负责调用注册的
beforeHookedMethod和afterHookedMethod
参考: MindMac-Xposed框架Java部分
http://bbs.pediy.com/showthread.php?t=181561
基于Hook的模拟器隐藏
• 主要针对Android系统层、Linux系统层
– 用户层数据和行为：可以通过数据构造，如增加联系人
信息、短信、通话记录解决
– 模拟器体系结构特征：模拟器的本质问题，同时实际应
用中较少
针对Android系统层的Hook
基于TelephonyManager API的模拟器检测
• 对抗方法
– Hook对应的API，在afterHookedMethod函数中设置区别
于模拟器值的返回结果
– 可进一步返回随机且合理值(更不易被探测)
设置返回值
基于电池电量和状态特征的模拟器检测
• 获取当前电池电量和状态的方法
– BatteryManager将电池信息通过Sticky Intent广播
– 调用registerReceiver并传入值为null的广播接收器
– registerReceiver返回的Intent实例中包含电池电量信息
基于电池电量和状态特征的模拟器检测
• 对抗方法
– Hook android.content.Intent的getIntExtra等函数
– 在afterHookedMethod函数中判断Intent的Action是否为
ACTION_BATTERY_CHAGED,若是，则根据参数修改
返回值
获得this对象
获得函数参数
基于电池电量和状态特征的模拟器检测
• 对抗方法(另一种方法)
– telnet localhost 
– power capacity 78
基于wifi、GPS等硬件特征的模拟器检测
• Wifi
– 模拟器上不存在wifi硬件
– 获取到的MAC地址为null
– 真机上即使在wifi未打开情况下仍然可以正确获取MAC
地址
• GPS
– 模拟器上不存在GPS设备
– LocationManager.getLastKnownLocation返回值为null
基于wifi、GPS等硬件特征的模拟器检测
• 对抗方法(wifi)
– Hook android.net.wifi.WifiInfo的getMacAddress函数
– 返回“真实”的MAC地址(可使用随机方法每次返回不同值)
• 对抗方法(GPS)
– Hook LocationManager的getLastKnownLocation函数
– 在afterHookedMethod中实例化Location对象，并设置坐标值
– 返回实例化的Location对象
设置坐标值
基于Build字段的模拟器检测
• Build.Device等属于静态字段，在android.os.
Build类加载时完成赋值
• Xposed等只提供对函数的Hook操作，无法对字段
值进行动态修改
• Xposed等Hook生效时间要晚于Build类的加载
基于Build字段的模拟器检测
• 对抗方法
– 修改Android源码，更改BRAND字段值
– 解压system.img文件；修改build.prop;重新生成
system.img
– andwise, Unpack/repack ext4 Android system images, xda
developers
如何不修改源码达到Hook效果？
基于Build字段的模拟器检测
• 对抗方法(Smali Hook)
– 反编译生成smali code
– 将对Landroid/os/Build的引用修改为自定义的类
– 重新编译、签名生成APK
部分应用会进行自校验，此方法会导致APK无法运行！
基于反射调用获取系统属性的模拟器检测
• SystemProperties提供对系统属性的访问和设置
• SystemProperties类默认没有导出
• 需要通过Java反射机制调用
基于反射调用获取系统属性的模拟器检测
• 对抗方法1
– Hook反射调用的目标函数，如SystemProperties.get函数
– 根据参数情况，修改返回值，注意返回值的合理性(系统
在启动阶段同样会调用该函数，不合理的值会导致系统
无法启动)
• 对抗方法2
– 直接Hook java.lang.reflect.Method类的invoke函数
– 根据反射调用的类名和方法名判断目标函数
– 进一步解析参数值，根据参数修改返回值
基于/system/build.prop检测模拟器
• 读取/system/build.prop文件检测模拟器
– /system/build.prop文件记录了系统属性值
– Android属性系统服务启动时会读取该文件内容并将属性
值存入共享内存
– 普通应用程序具有可读权限
– 可读取该文件内容并判断是否包含特定字符串
基于/system/build.prop检测模拟器
• 对抗方法
– Hook IO相关API，在读取文件时，篡改文件路径
– 需要Hook所有IO类？
– 所有IO操作最终调用libcore.io.IoBridge类中的API
– Hook open函数，在beforeHookedMethod中修改path参数
仅针对普通应用程序进行篡改
修改path参数值
基于Monkey事件模拟检测模拟器
• 大部分自动分析系统会采用Monkey生成随机事件，
用于模拟人机交互，触发应用程序更多行为
• ActivityManager.isUserAMonkey函数可检测当前用
户是否为Monkey，返回值为true表示存在Monkey事
件模拟
基于Monkey事件模拟检测模拟器
• 对抗方法
– Hook ActivityManager.isUserAMonkey函数
– 在afterHookedMethod中将返回值设置为false
针对Linux系统层的Hook
通过驱动信息特征检测模拟器
• /proc/tty/drivers驱动信息文件包含特征字符串
goldfish
• 普通应用程序具有可读权限
• 读取该驱动信息文件检测是否包含goldfish
通过驱动信息特征检测模拟器
• 对抗方法
– 与基于/system/build.prop的模拟器检测对抗方法类似
– Hook IoBridge的open函数后，篡改文件路径，重定向至
伪造的驱动信息文件
通过设备文件特征检测模拟器
• 模拟器上存在/dev/socket/qemud、/dev/qemu_pipe等
表征模拟器的设备文件
• 通过判断这些文件的存在性检测模拟器
通过设备文件特征检测模拟器
• 对抗方法
– Hook java.io.File类的exists函数
– 获取当前文件路径
– 若当前文件路径为/dev/qemu_pipe，设置返回值为false
获取文件路径
检查文件路径，设置返回值
通过执行shell命令检测模拟器
• getprop命令可以获取当前系统的属性信息
• 通过检查某些属性信息判断是否为模拟器，如
ro.product.name
• 调用Runtime.exec函数可以执行shell命令
• 读取shell执行结果判断是否存在特征字符
通过执行shell命令检测模拟器
• 对抗方法1
– Runtime.exec函数调用后返回Process实例
– 执行的shell结果通过Process.getInputStream获取
– Runtime.exec最终会调用ProcessManager.exec，返回
ProcessImpl实例
– Hook ProcessImpl类的getInputStream函数，返回篡改后文
件的inputStream对象
内部类
重定向InputStream
before函数中进行参数修改，防止内存泄露
通过执行shell命令检测模拟器
• 对抗方法2
– 替换Linux系统函数，如替换getprop命令
– /system/core/toolbox/getprop.c
– make toolbox
– /out/target/product/generic/system/bin/toolbox
– 使用重新编译生成的toolbox替换系统toolbox
通过Native Code检测模拟器
• NDK提供了__system_property_get函数获取系统属
性
• 需要包含sys/system_properties.h头文件
通过Native Code检测模拟器
• Xposed仅支持对Java层函数进行Hook，无法对
Linux系统层函数的Hook操作
• adbi支持Native Code的Hook
通过Native Code检测模拟器
• 使用adbi Hook Linux系统函数
– 指定入口点
– 设置hook函数
目标函数所在的库
目标函数名称
ARM指令集下的hook函数
Thumb指令集下的hook函数
通过Native Code检测模拟器
• 使用adbi Hook Linux系统函数
– Hook函数实现
参数与目标函数一致
Demo
• 设计实现了反模拟器行为的检测
• 通过对真实样本的测试，我们发现
– 反模拟器行为在真实世界中应用十分普遍
– 大部分第三方库进行了模拟器环境检测
– 正常样本中模拟器检测行为比例高于恶意样本
• 通过Hook解决针对Android、Linux系统层的模拟器检测
– 开发容易
– 部署方便
– 定制灵活
总结
谢谢！
• MindMac 
• Claud Xiao 
HideAndroidEmulator:
https://github.com/MindMac/HideAndroidEmulator