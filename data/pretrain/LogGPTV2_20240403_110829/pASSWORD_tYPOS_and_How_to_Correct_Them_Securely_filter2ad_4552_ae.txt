### Optimal Attackers and Security Loss

We caution that the absence of security loss for an optimal attacker does not imply that all attackers face no security degradation. In fact, it is relatively straightforward to provide examples of password settings where certain attacks can achieve a speed-up due to tolerance. However, such attacks cannot outperform the optimal one. The challenge of finding analogs to OpChk and the free correction theorem for non-optimal attackers remains an open and intriguing research problem. In the following section, we empirically examine the performance of several non-optimal attacks, demonstrating that these do not achieve any significant speed-up due to typo tolerance.

### Practical Typo-Tolerant Checkers and Their Security

We employ heuristics to avoid balls with high aggregate mass, inspired by the results concerning OpChk. Our experiments show that our checkers can achieve high acceptance utility with minimal security degradation. These heuristics also help reduce security loss even against adversaries with exact knowledge of the probability distribution \( p \). Additionally, we investigate the security of these checkers against more realistic adversaries who must estimate the distribution \( p \). Our findings suggest that typo tolerance offers little advantage to adversaries due to the difficulty in accurately estimating the distribution.

#### Tolerant Checkers

Let \( \tilde{w} \) denote the input to the checker and \( \hat{B}(\tilde{w}) \) the ball of potential passwords as defined by the set of correctors \( C \). The checkers, presented in increasing order of sophistication (and similarity to OpChk), are:

- **Check-always construction (Chk-All):** This checker checks all passwords in \( \hat{B}(\tilde{w}) \). Among the three checkers, it achieves the highest acceptance utility but also the greatest potential security degradation.
  
- **Blacklist construction (Chk-wBL):** This checker uses a blacklist \( L \) of high-probability passwords. It checks \( \tilde{w} \) and every other password \( w \in \hat{B}(\tilde{w}) \) such that \( w \notin L \). Blacklisting aims to prune or eliminate non-singleton balls with high aggregate probability, similar to OpChk. In our experiments, we use the 1,000 most popular passwords from RockYou, though other blacklists like Twitter’s banned password list [4] could be used.

- **Approximately optimal construction (Chk-AOp):** This checker approximates OpChk using heuristics. It estimates the distribution \( p \) of passwords using the empirical distribution from the RockYou password leak and the distribution \( \tau \) of typos using the empirical distribution learned from our MTurk study (see Figure 2). We denote these empirically derived distributions as \( \tilde{p} \) and \( \tilde{\tau} \). Chk-AOp computes \( B(\tilde{w}) \) using the constraints from OpChk but under the empirical distribution pair \( (\tilde{p}, \tilde{\tau}) \) rather than the true distribution pair \( (p, \tau) \). For our experiments, we set \( q = 10^3 \). For the correction set sizes \( c \leq 5 \), solving the optimization problem is fast, as only \( 2^c \) possibilities for \( B(\tilde{w}) \) need to be considered.

In the previous section, we introduced an optimal checker, OpChk, which maximizes acceptance utility without security loss relative to an optimal attacker. However, OpChk is challenging to implement as it requires exact knowledge of the distribution pair \( (p, \tau) \), which is impractical in most settings. Here, we explore checkers that do not rely on exact distribution knowledge and are simple to implement. The first tries all corrections in some checker set, while the latter two incorporate heuristics to improve performance.

We will investigate these checkers for typo correction sets \( C_{\text{top2}} = \{\text{swc-all, swc-first}\} \), \( C_{\text{top3}} = C_{\text{top2}} \cup \{\text{rm-last}\} \), and \( C_{\text{top5}} = C_{\text{top3}} \cup \{\text{rm-first, n2s-last}\} \). In terms of utility, we know from the second Dropbox study (Section IV) the improvements obtained when using Chk-All with \( C_{\text{top3}} \). The other two constructions will have slightly less utility because some corrections will not be checked.

However, our preliminary analysis suggests that this utility reduction will be minor: both strategies prevent corrections only to popular passwords, which are rarely induced by typos (see Section III). For example, simulating acceptance utility for a given checker using the RockYou empirical distribution and the empirical frequencies of typo types observed, we find that the blacklist and approximately optimal strategies reduce utility by only 0.03 and 0.08 percentage points, respectively, for \( C_{\text{top3}} \).

#### Implementation Considerations

The checkers above are easy to implement, but care must be taken to optimize performance and prevent timing attacks. Generally, each checker should first run ExChk(\( \tilde{w} \)) since this must always be computed. If that fails, a constant-time check of the remainder of the ball should be performed, involving running ExChk for the maximum number of checks that could occur for any \( \tilde{w} \), i.e., \( |C| \). If implemented this way, timing and other side-channels will only potentially leak that a user made a typo, but nothing else about their password. Users who correctly input their passwords experience no performance degradation compared to existing systems.

If a constant-time implementation is not used, timing side channels may arise, leaking partial information about a user’s password. For example, checking a singleton ball (induced by some inputs and not others for Chk-wBL and Chk-AOp) would be faster than checking a ball with multiple passwords, revealing whether the user entered a high-probability password.

#### Security Evaluation

In the remainder of this section, we evaluate the security of our schemes against two types of attackers:

- **Exact-knowledge attackers:** We start by evaluating the security of the constructions against attackers who (unrealistically) know the precise distribution from which passwords are drawn. We use a range of simulated password distributions and adversarial query budgets.
  
- **Estimating attackers:** We then consider more realistic attackers who do not have exact knowledge of the password distribution. Our evaluations show that in this context, an attacker attempting to take advantage of tolerant checking, even when they know the precise checker, can be quite error-prone. They may even perform worse than naive approaches that just guess the most probable passwords.

Our approach for these analyses is to use different password leaks to simulate true password selection. We use the RockYou, phpBB, and Myspace leaks, which contain the passwords of more than 32 million, 255,421, and 41,545 users, respectively. When we refer to the RockYou, phpBB, or Myspace distribution, we mean sampling according to the empirical distribution given by the indicated leak. Note that for some analyses, we use RockYou both within the designs of Chk-wBL and Chk-AOp and to test those designs’ security, optimistically modeling that a “best-case” estimate of the distribution is known to the checker.

##### Security Against Exact-Knowledge Attackers

We focus on the greedy success rate increase \( \lambda_{\text{greedy}} - \lambda_q \) for various values of the query budget \( q \). We also report on \( \lambda_q \) to provide context. To compute these values, we use the RockYou, Myspace, and phpBB distributions to simulate a challenge distribution \( p \). Since the optimal attacker is assumed to know the distributions exactly, in the exact checking setting, she will simply guess the most probable \( q \) passwords. Here, \( \lambda_q \) is straightforwardly computable (just sum the probabilities of the top \( q \) passwords in the challenge distribution). In the typo-tolerant settings, the attacker will construct a sequence of queries that achieves \( \lambda_{\text{greedy}} \) using the algorithm given in Appendix E.

We start by comparing security for attackers given \( q = 1,000 \) queries across the various distributions, schemes, and corrector sets. A query budget of 1,000 is very generous, as many websites will lock an account after tens of failed requests. Figure 5 reports the optimal success probability \( \lambda_q \) against an exact checker, as well as the improvements \( \lambda_{\text{greedy}} - \lambda_q \) for each typo-tolerant checker, correction set pair. All numbers are reported as percentages. The worst degradation occurs for correcting all top five errors in the Myspace setting, where the attacker’s success probability increases by 3% (from 9.5% to 12.5%). To put this worst-case in perspective, consider the naive (and incorrect) assumption that underlies the criticism of typo tolerance [2]: it suggests a fivefold increase in attacker success when correcting five errors, resulting in an increase to 47.5% in the Myspace setting.

Elsewhere, the increase is much smaller. For example, with RockYou, one can always correct all top five errors with an increase of only 1.6%: an attacker’s probability of success goes from 11.2% to 12.8%, a small improvement. This means that the adversary’s first 1,000 guesses against a typo-tolerant checker do not benefit much from high-probability balls.

Moving from \( C_{\text{top2}} \) to \( C_{\text{top3}} \) can result in a relatively big jump in security loss. The reason is that the rm-last typo corrector admits many higher-mass balls than only correcting the considered capitalization errors. For example, adding a character to many popular passwords results in another popular password: "password" and "password1", "abc123" and "abc1234". Fewer such pairs exist for capitalization errors since fewer users choose passwords with capital letters. Indeed, in the worst case for \( C_{\text{top2}} \), we see just a 0.5% improvement in adversarial success compared to the 2.42% worst-case jump for \( C_{\text{top3}} \). It is perhaps no coincidence that Facebook’s policy aligns with Chk-All for \( C_{\text{top2}} \). Our measurements are the first reported validation of this policy.

Even though security loss is low for Chk-All, one may want to do better. The blacklist and approximately optimal checkers help. When the challenge distribution is RockYou, the approximately optimal checker Chk-AOp is, in this case, actually optimally secure by construction, hence it suffers no security loss at all. Also note that Chk-wBL may benefit unduly by knowing exactly the top 1,000 passwords from RockYou. Thus, the more important analyses are when tested on independent distributions. Here we see some loss as expected, given that the attacker in these cases has more information about the challenge distribution than the checker. But now the loss is small, and Chk-AOp reduces the security loss compared to Chk-All by 0.53% on average over the Myspace and phpBB settings. Chk-wBL also reduces loss compared to Chk-All by 0.27% on average over Myspace and phpBB, but never improves security more than Chk-AOp.

We now turn to what happens as \( q \) varies. Figure 5 shows the attack success increases for the \( q = 10 \) and \( q = 100 \) cases. The most realistic scenario in practice is \( q = 10 \), as companies often raise alarms after 10 consecutive failed login attempts. Here, we see that attackers benefit little from typo-tolerance, and our Chk-AOp reduces loss to 0.04% or less. Often, it is zero.

It is conceivable that in some settings, an attacker might be able to make more than \( q = 1,000 \) queries, implying that our checker assumed too low of a bound on the query budget.