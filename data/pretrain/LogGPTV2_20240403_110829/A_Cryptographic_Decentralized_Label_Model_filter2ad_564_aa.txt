title:A Cryptographic Decentralized Label Model
author:Jeffrey A. Vaughan and
Steve Zdancewic
A Cryptographic Decentralized Label Model
Jeffrey A. Vaughan
Steve Zdancewic∗
University of Pennsylvania
Abstract
Information-ﬂow security policies are an appealing way
of specifying conﬁdentiality and integrity policies in infor-
mation systems. Most previous work on language-based se-
curity has assumed that programs run in a closed, managed
environment and that they use potentially unsafe constructs,
such as declassiﬁcation, to interface to external communi-
cation channels, perhaps after encrypting data to preserve
its conﬁdentiality. This situation is unsatisfactory for sys-
tems that need to communicate over untrusted channels or
use untrusted persistent storage, since the connection be-
tween the cryptographic mechanisms used in the untrusted
environment and the abstract security labels used in the
trusted language environment is ad hoc and unclear.
This paper addresses this problem in three ways: First,
it presents a simple, security-typed language with a novel
mechanism called packages that provides an abstract means
for creating opaque objects and associating them with se-
curity labels; well-typed programs in this language enforce
noninterference. Second, it shows how to implement these
packages using public-key cryptography. This implementa-
tion strategy uses a variant of Myers and Liskov’s decen-
tralized label model, which supports a rich label structure
in which mutually distrusting data owners can specify inde-
pendent conﬁdentiality and integrity requirements. Third, it
demonstrates that this implementation of packages is sound
with respect to Dolev-Yao style attackers—such an attacker
cannot determine the contents of a package without pos-
sessing the appropriate keys, as determined by the security
label on the package.
1 Introduction
Information-ﬂow security policies are an appealing way
of specifying conﬁdentiality and integrity policies in in-
∗This research was sponsored in part by NSF Grants CNS-0346939,
CNS-0524059 and CCF-0524035. Any opinions, ﬁndings and conclusions
or recommendations expressed in this material are those of the authors and
do not necessarily reﬂect the views of the NSF.
formation systems. Unlike traditional reference monitors
and cryptography, which regulate access to data, mecha-
nisms that enforce information-ﬂow policies regulate how
the data (and information derived from the data) is al-
lowed to propagate throughout the system. Such end-to-
end security properties are important for applications that
require high degrees of conﬁdentiality (such as those found
in SELinux [28]) and integrity (such as those found in criti-
cal embedded systems [9]).
Language-based mechanisms, which rely on static pro-
gram analysis, are one approach to determining whether a
given piece of software obeys an information-ﬂow policy.
The key idea, stemming from the work by Denning [13, 14]
in the 1970’s, is to annotate program values with labels
drawn from a lattice of security levels and then have the
compiler verify that the program follows the standard “no
read up/no write down” noninterference policy [18, 8]. Fol-
lowing the work of Volpano, Smith, and Irvine [33], these
program analyses are usually expressed as a form of type-
checking.
The literature in this area has explored a wide variety of
label models, programming language features, mechanisms
for dealing with declassiﬁcation and other kinds of down-
grading, and appropriate deﬁnitions of security (see the sur-
vey by Sabelfeld and Myers [27]). FlowCaml [25, 29] and
Jif [11] are two full-ﬂedged programming languages that
support information-ﬂow security policies. Jif, for exam-
ple, has been used to implement some simple distributed
games [5, 35] and a secure e-mail system [20].
Despite these promising results, one important open
question in the design of languages for information-ﬂow
security is how to integrate them with other mechanisms
such as cryptography and traditional access controls. Un-
derstanding the relationship between cryptography and
information-ﬂow is particularly important in the case of
“open” systems in which the data to be protected must leave
the managed environment provided by the language run-
time. For example, if the system needs to send protected
data over an untrusted network or write it to persistent stor-
age, encryption and digital signatures are the appropriate
means of providing conﬁdentiality and integrity.
1
Although cryptography is an extremely valuable tool
for security engineering, there has been surprisingly little
work on developing a theory of how it and information-
ﬂow mechanisms can be brought together coherently. The
work in this space includes the KDLM [12], crypto-masked
ﬂows [4], sealing calculi [31], cryptographic types [17], and
computational security analyses of information-ﬂow with
encryption [21, 30]. In this paper, we explore a novel design
for incorporating cryptographic operations with language-
based information-ﬂow security.
We have three main goals for the programming language
presented here. First, we want the programming model
to have abstractions suitable for cryptographically enforc-
ing information-ﬂow policies speciﬁed via security labels.
Second, the design of the new language primitives should
free the programmer from the burden of having to manu-
ally manage keys and their correspondence to information-
ﬂow policy labels. And, third, we should prove that, under
a reasonable model of cryptography, programs written in
the resulting language satisfy the standard noninterference
properties expected in this context.
In this paper, we realize the goals above by making the
following contributions:
• We develop a language, SImp, with primitives for en-
forcing information-ﬂow security policies, including a
restricted form of cryptographic packaging. The novel
language constructs are reminiscent of the pack/un-
pack operations found in languages with existential
or dynamic datatypes. Operationally, the use of these
packaging constructs requires run-time checks that en-
sure the security of program [17].
• We show that packages have a natural implementa-
tion in terms of public-key cryptography by deﬁning
a translation from language values to cryptographic
messages; this translation depends on the structure of
the labels used to deﬁne security policies. A variant of
the decentralized label model [22] provides a pleasant
setting for the translation.
• We prove a noninterference result for SImp, includ-
ing the downgrading implicit in its cryptographic pack-
ages. We also demonstrate the soundness of the cryp-
tographic interpretation of packages by showing that a
Dolev-Yao attacker [16] cannot determine the contents
of a package without possessing the appropriate keys
(as determined by the translation of the security label
on the package).
The rest of this paper is structured as follows. Section 2
introduces our information ﬂow language and proves non-
interference. Section 3 gives a Dolev-Yao system for rea-
soning about cryptography and a translation from language
values to cryptographic messages. Sections 4 and 5 contain
discussion and related work, respectively.
2 The SImp Language
2.1 Background and Example
As with
other
approaches
the locations
language-based
to
information-ﬂow security,
in our pro-
gramming language are annotated with security labels.
This paper uses a decentralized label model (DLM) variant
where labels are lists of security policies with conﬁden-
tiality and integrity components.
These policies refer
to principals, which are characterized by their access to
private keys. A policy has form o : r ! w, where r and w are
sets of principals and o is a single principal. This means
that policy owner o certiﬁes that any principal in r can read
from the associated location, and any principal in w can
write. Sections 2.2 and 3.1 discuss the label model and
private keys respectively.
Although the literature discusses “the” DLM, there are
several subtly different models. When they are handled at
all, integrity constraints sometimes correspond to writers of
data; other times to trusters. Additionally, DLM presen-
tations typically contain an acts-for hierarchy: an explicit
and nominal delegation relation. Here, we do not build an
explicit acts-for hierarchy as it is not germane to our set-
ting. Instead we investigate the orthogonal issues of collu-
sion and cooperation among sets of principals. Section 5.1
discusses the acts-for hierarchy further.
Before examining the formal description of SImp, we
present the sample program shown in Figure 1. In this ex-
ample we imagine a small client that can read and write data
to a database shared by many users.1 The database imple-
ments a ﬁnite map signature, with no provisions for security.
To model this situation, the database is labeled with a single
policy: {db admin : everyone ! everyone}. That is, data
entered in to the database is readable by anyone; data read
from it may have been altered by anyone.
Input and output are performed by reading from and
writing to designated memory locations.
Lines 14
through 20 declare the locations corresponding to input,
and line 23 declares a location corresponding to the ter-
minal. Locations action and position describe the pro-
gram’s mode of operation—whether to read or write and
where. Tagged with security label {p : everyone ! p}, their
contents are readable by everyone and have only been inﬂu-
enced by one principal, p. The label on txt is more restric-
tive; its contents are only readable by p. That is, txt con-
tains a secret. The database is promiscuous; it produces and
1For convenience we have augmented SImp with syntactic sugar,
method calls, strings, and a unit type.
2
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
/∗ The d a t a b a s e a c c e p t s and p r o d u c e s
∗ i n p u t
c o n f i d e n t i a l and
∗ t h a t a n y o n e may h a v e
i n f l u e n c e d . ∗ /
la bel def db_io =
i s n o t
t h a t
{ db_ adm in : eve ryo ne ! eve ryo ne }
i n t e r f a c e ∗ /
r e p r e s e n t i n g
/∗ d a t a b a s e
store : ( int * pkg ){ db_io } -> (){ db_io }
re tri eve : int { db_io } -> pkg { db_io }
/∗ l o c a t i o n s
i n p u t ∗ /
/∗ p u t = t r u e ; g e t = f a l s e ∗ /
action : bool { p : e ver yon e ! p }
/∗ r e c o r d i d ∗ /
po sit ion : int { p : ev ery one ! p }
/∗ a c o n f i d e n t i a l
txt : string { p : p ! p }
/∗ l o c a t i o n
console : string { p : p ! e ver yon e }
/∗ s c r a t c h
reply : pkg { db_io }
r e p r e s e n t i n g o u t p u t ∗ /
l o c a t i o n ∗ /
n o t e ∗ /
case action of
put = >
store ( pos , pack txt at { p : p ! p });
console := " text stored "
| get = >
reply := ret rie ve ( pos );
case ( unpack reply
as string { p : p ! p }) of
inl v = > console := v
| inr _ = > console := " bad package "
Figure 1. An example SImp program
consumes values that, according to db admin, are world-
readable and have no integrity constraints.
The branches of the outer case command store and re-
trieve data from the database. In the “put” case, the client
wishes to enter secret value txt to the database. However
simply calling store(pos, txt) would not be secure. (Ad-
ditionally, the shape of txt is string while store expects
a pkg—an important detail, but only peripherally related to
security.) We can deduce that this call is insecure in two
ways. First, the database semantics are insecure; anyone
could read txt if it were stored directly. Second, the la-
bel of txt speciﬁes that p requires that only p can read,
while store (line 8) requires arguments readable by anyone.
Here a simple syntactic check of security labels identiﬁes a
semantic error; this is the point of static information-ﬂow
3
analysis. The actual invocation of store on line 30 satisﬁes
the label checking and avoids the semantic error. It does
not leak information because pack builds a cryptographic
message which encrypts (and signs) txt. The typing rules
reﬂect this, allowing the result of a pack to be treated as
world-readable data.
In the case of a “get”, unpacking reply—the publicly
readable result of retrieve—yields either a conﬁdential
and trusted string, or an error. As we will see, unpacking
requires static and dynamic checks that work in concert to
prevent undesired information ﬂows.
2.2 Security Lattice Properties
As we saw above, variables in SImp programs are an-
notated with security labels. The language deﬁnition is pa-
rameterized by the algebraic structure of labels and several
basic axioms. This section describes the generic label prop-
erties and deﬁnes a variant of Myers and Liskov’s decen-
tralized label model (DLM) [22], a concrete instantiation of
the structure. In Section 3.2 we examine how to compile
SImp values into cryptographic messages; that discussion
will assume labels are deﬁned by our DLM.
Labels, denoted ‘, are elements of a non-trivial, bounded
lattice with order relation ≤ and join operation t. Upper
bound > is the most restrictive label, and ⊥ is the least re-
strictive. Labels have conﬁdentiality and integrity compo-
nents. A pair of functions, C and I, allow us to consider
separately parts of a label; C(‘) returns a label with ‘’s con-
ﬁdentiality policy and the least restrictive integrity policy.
Function I is the integrity analog. Both functions are idem-
potent. Formally,
‘ = C(‘) t I(‘)
C(I(‘)) = ⊥
I(C(‘)) = ⊥
C(C(‘)) = C(‘)
I(I(‘)) = I(‘).
Additionally, we assume C and I are monotone.
‘ ≤ ‘0 ⇐⇒ C(‘) ≤ C(‘0) ∧ I(‘) ≤ I(‘0)
The purpose of labels is to classify who can read, and
who could have written, data. We assume that there is a
ﬁxed set of principals, P, ranged over by p. We also re-
quire two monotone predicates that indicate whether a set
of principals, p ⊆ P, can read (resp. write) according to
a label’s conﬁdentiality (integrity) component. Formally, if
C(‘) ≤ C(‘0) then p reads ‘0 implies p reads ‘. Integrity
if I(‘) ≤ I(‘0) then p writes ‘ implies
is the opposite:
p writes ‘0. We call a label set and operators over that set a
security lattice when the above proprieties hold.
We instantiate the above with a decentralized label
model that omits the acts-for hierarchy [22] and assumes
that principals can collude to pool their authority. That is,
we intend for p reads ‘ (resp. p writes ‘) to hold when
the members of p can cooperate to read (write) at ‘. Sec-
tion 5.1 compares our presentation of a DLM with several
others, including Myers and Liskov’s original description.
In a DLM, principals typically represent users of a sys-
tem. We call the set of all principals P, and assume it is
ﬁnite. We also assume the existence of a canonical total or-
dering on P; this is not the acts-for hierarchy, but a helpful
condition used for deﬁning functions over labels.
Informally, a label consists of several policies in which
principals called owners make access control statements.
Each policy has form o : r ! w, and consists of an owner