### 优化后的文本

#### 图2：硬件模拟器内存映射示例
图2展示了一系列硬件模拟器的内存映射，呈现了与函数局部变量相关的值。列分别包含受污染状态、AgeStamp、PFT和FTS指示符。硬件模拟器无法明确区分陈旧、新鲜和无关的受污染字节，只能判断某个内存位置是否受污染。为了清晰起见，图中展示了多种模式。

这种方法不仅适用于堆，也适用于栈。图中展示了（a-f）系列硬件模拟器的内存映射，呈现了与函数局部变量相关的值。目前，我们只关注前两列，它们分别包含受污染状态和AgeStamp信息。

假设示例函数在一个AgeStamp为20的时期执行，因此少量AgeStamp为19的受污染字节是陈旧的。请注意，通过使用while和for循环，该函数在没有任何调用的情况下复制网络数据，因此不会增加AgeStamp。尽管我们在步骤2f后正确地触发了警报（当函数返回并准备跳转到受攻击者影响的地址时），但内存转储和年龄戳并不能提供分离相关字节和无关缓冲区buf的方法。原因是vuln_buf和buf具有相同的AgeStamp。

为了解决这个问题，我们引入了两个额外的1位指示符来帮助我们确定缓冲区填充的顺序：PFT（Previous address Freshly Tainted）和FTS（First Tainted Store）。直观上，PFT表示地址a-1是否被分配了新鲜的受污染内容。如果a是受污染的，则PFT表示a-1的内容比a更新鲜。FTS位表示地址a处的受污染存储是在a-1受污染之后的第一个此类存储。这些指示符的确切含义由列表2中的算法定义。

#### 示例解释
我们回到图2中的示例，并检查PFT和FTS的值，即内存映射的最后两列。

- **第5行**：赋值操作将与p关联的内存设置为未受污染，并保持Prospector标记不变（图2b）。
- **第6-7行**：第一次迭代将addrvuln_buf标记为受污染，将其AgeStamp设置为当前AgeStamp，并将PFT(addrvuln_buf + 1)设置为1。我们可以非正式地解释为addrvuln_buf告诉addrvuln_buf + 1：“我有受污染的内容，比你的更新鲜”。对于FTS(addrvuln_buf)，如果我们假设PFT未设置，则addrvuln_buf已经“消费”了来自addrvuln_buf - 1的消息，因此当前存储操作不是自addrvuln_buf - 1受污染以来的第一个。我们将FTS(addrvuln_buf)设置为未设置。
- **第二次迭代**（图2c）：我们将addrvuln_buf + 1标记为受污染，将其AgeStamp设置为当前AgeStamp，并将PFT(addrvuln_buf + 2)设置为1，告知其上方的内存位置addrvuln_buf + 1有新鲜的受污染内容。这次我们知道自addrvuln_buf受污染以来没有进行过受污染存储操作。我们将FTS(addrvuln_buf + 1)设置为1，并将PFT(addrvuln_buf + 1)设置为未设置，因为addrvuln_buf + 1的受污染值比addrvuln_buf更新鲜。
- **while循环结束后**（图2d）：所有参与攻击的受污染字节都有PFT未设置，FTS设置为1。

接下来是第8-9行的for循环，第一次迭代如图2e所示。在存储第一个字节时，我们将PFT(addrbuf + 1)设置为1，并检查当前存储操作是否是自addrbuf - 1受污染以来的第一个。实际上，在while循环的第五次迭代中已经满足了这个条件。因此，我们将FTS(addrbuf)设置为未设置。

最终，图2f展示了整个gap形成的区域。可以看到，gap内部的PFT被否定，FTS被设置，类似于典型的受污染区域。但是，gap上方的字节PFT被设置为1，这是for循环第四次迭代的结果。（addrbuf + 3）通知其上方的内存位置它有新鲜的受污染内容。由于这是无关缓冲区的最后一个字节，没有存储操作“消费”这条消息。同样，gap底部的字节两个指示符都被否定。

现在我们对附加指示符的使用有了直观的理解，可以转向更正式的定义（第4.7节）和分析（第4.8节）。

#### 受污染数据和gap的正式属性
在本节中，我们使用上述定义的指示符来推导受污染内存区域的属性。

**观察1**：设buf是一个大小为n的关键受污染区域。则：
- (a) ∀i = 0 ... (n - 1): buf[i] 是受污染的。
- (b) ∀i = 0 ... (n - 1): AgeStampi ≥ AllocAgeStamp，其中AllocAgeStamp是分配缓冲区的时期。
- (c) ∀i, j = 0 ... (n - 1), i < j: AgeStampi ≤ AgeStampj。
- (d) ∀i = 1 ... (n - 1): PFT(buf[i]) 未设置，FTS(buf[i]) 设置（因为存储操作在buf[i]找到PFT已设置）。

**观察2**：设gap是一个位于关键受污染内存区域buf内的非受污染不连续性区域。由于内存位置变为未受污染时年龄戳和指示符都不会改变，观察1.b-1.d也在gap内成立。

**观察3**：设gap是一个位于关键受污染内存区域buf内的受污染不连续性区域，大小为m。则：
- (a) ∀i = 0 ... (m - 1) gap[i] 是受污染的。
- (b) ∀i = 0 ... (m - 1) AgeStamp(gap[i]) ≥ AgeStamp(gap[m])。
- (c) gap[m] 的两个指示符PFT和FTS都设置为1，gap[0] 的两个指示符都设置为0。
- (d) ∀i = 1 ... (m - 1): PFT(gap[i]) 未设置，FTS(gap[i]) 设置。

一个包含无关受污染字节的gap可能与另一个类似的gap相邻。在这种情况下，它们简单地合并，遵循观察3列出的所有属性。

#### 分析：定位导致溢出的字节
为了找到导致攻击的字节（关键区域），我们从违规地址开始向下遍历内存，并继续遍历符合观察1的字节。在本节中，我们将讨论如何启动这一过程以及如何克服第3节中提到的复杂因素。

**4.8.1 分配时间**
我们首先确定AllocAgeStamp，即包含违规地址的易受攻击缓冲区的分配时间。我们需要它来区分新鲜和陈旧的数据。

- 在堆破坏攻击中，每个内存块显式维护年龄戳。
- 在栈粉碎攻击中（即违规地址不小于栈指针寄存器ESP的值），我们检查与易受攻击进程相关的堆栈帧历史记录，以找到最近的高于违规地址的条目。如果恶意数据溢出到相邻的堆栈帧，我们可能会找到调用者的年龄戳。但这不会阻止正确的分析，因为在稍后查找整个关键区域时，我们会找出最新的正确AgeStamp。

**4.8.2 Gaps**
第3节中提到的一个困难是关键区域受污染数据中的gap。如前所述，这种不连续性可能发生在程序在溢出发生后为关键区域内分配的局部变量分配新值时。它们也可能出现在应用程序重新填充易受攻击缓冲区的部分时。假设不连续性完全包含在关键受污染内存区域内，即gap下方至少有一个字节参与了攻击。

为了找到关键区域，我们继续遍历内存，直到遇到不符合观察1的字节。如果遇到仅不符合观察1.a（即不受污染）的字节，我们得出结论它属于非受污染不连续性区域。我们继续遍历内存，直到遇到受污染的数据。由于我们假设gap不会到达易受攻击缓冲区的开头，我们将找到一个受污染的字节。

我们还可能在内存位置addr1处找到不符合观察1.d的字节。这意味着指示符的值被破坏：PFT(addr1) 不等于0和/或FTS(addr1) 不等于1。如果两个指示符都设置为1，则下方的内存位置具有新鲜的受污染内容。根据定义gap的观察3，这表明我们可能发现了受污染的不连续性区域。我们继续遍历内存，直到遇到两个指示符未设置的内存位置。

如果不符合观察1.d意味着FTS(addr1) 等于0，乍一看，可能会认为新的受污染存储操作导致了指示符的变化，但这样会导致addr1 + 1的PFT设置为1，这也与观察1.d冲突。由于我们没有检测到这种情况，因此这种情况不会发生。

类似地，我们永远不会通过发现AgeStamp比预期更新的字节来发现gap的顶部（即不符合观察1.c）。确实，addr1处的受污染存储操作会改变PFT(addr1 + 1)，而我们首先会遇到这一点。

**4.8.3 过量数据**
我们现在讨论如何确定易受攻击缓冲区buf的起始位置，从而解决无关受污染的问题。为了简化，我们再次假设buf的开头没有不连续性，即在入侵检测时，buf[0]包含导致攻击的字节。

考虑易受攻击缓冲区的可能起点。对于每种情况，我们明确讨论溢出时和检测入侵时重要变量的内容。为了清晰起见，我们将buf[0]的内存位置记为addrB，将buf[0]下方的地址记为addrA。假设按照上述方法遍历内存，我们到达了字节addrB，并检查我们是否可以得出适当的结论来正确识别缓冲区边界。

1. **溢出**：PFT(addrB) 等于0；我们设置FTS(addrB) = 0。**检测**：我们遇到一个FTS设置为0的字节，并且不在不连续性区域。因此，我们刚刚遇到了buf的起始位置。为了使结论清晰，请注意在受污染的易受攻击缓冲区内，只有在gap的开头才有可能出现FTS指示符未设置的情况。
2. **溢出**：PFT(addrB) 等于1，但addrA包含陈旧数据；我们设置FTS(addrB) 并取消设置PFT(addrB)。**检测**：我们遇到一个FTS设置且PFT未设置的字节，它存储了下方地址的年龄戳。请注意，由于addrA的数据是陈旧的，AgeStampaddrA 小于当前年龄戳，并且根据列表2中的步骤i.3，我们将存储年龄戳。