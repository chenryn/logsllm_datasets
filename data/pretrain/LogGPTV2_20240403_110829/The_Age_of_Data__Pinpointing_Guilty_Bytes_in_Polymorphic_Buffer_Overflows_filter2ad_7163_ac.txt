0 
1
1
0 
1
1
0  0 
0 
1
0 
1
0  1
0 
1
0 
1
0 
1
0 
1
0 
1
0 
1
0 
1
0 
1
0  1
19
19
20
20
20
20
19
19
(c) 
19
19
19
19
19
19
(a) 
1
0  1
19
19
19
20
19
19
(b) 
1
Figure 2. A series of the emulator’s memory maps presenting values associated with local variables
of a fun. The columns contain taintedness, AgeStamp, PFT and FTS indicators, respectively. The hard-
ware emulator cannot certainly distinguish between stale, fresh and unrelated tainted bytes. It just
says whether a memory location is tainted or not. The ﬁgure contains various patterns for clarity
reasons.
but the method is used for the heap also. The ﬁg-
ure illustrates a series (a–f) of the emulator’s memory
maps presenting values associated with local variables
of a fun. For now, we limit our interest to the ﬁrst two
columns containing information about taintedness and
AgeStamp, respectively.
We assume that the example function is executed in
an epoch with AgeStamp equal to 20, so that the few
existing tainted bytes with AgeStamp 19 are stale. Note
that by using while and for loops, a fun copies network
data without any calls and thus without incrementing
AgeStamp. Even though we duly raise an alert after
step 2f, when the function returns and is about to jump
to an address inﬂuenced by the attacker, the memory
dump and the age stamps do not provide the means to
separate the relevant bytes from the unrelated buﬀer
buf. The reason is that vuln buf and buf have the same
AgeStamp.
To remedy this situation we introduce two extra
1-bit indicators for each memory location to let us
establish the order in which the buﬀers were ﬁlled:
PFT (Previous address Freshly Tainted) and FTS (First
Tainted Store), respectively. Intuitively, PFT indicates
for address a whether a − 1 was assigned fresh tainted
If a is tainted, then PFT signiﬁes that the
contents.
contents of a − 1 is more recent than that of a. The
FTS bit indicates that the tainted store at address a
was the ﬁrst such store to a after a − 1 was tainted.
However, their exact meanings are deﬁned by the al-
gorithm in Listing 2. As the semantics of these two
additional indicators are complex, we introduce them
by way of a detailed example.
4.6 Example explained
We return to the example in Figure 2 and examine
values of PFT and FTS, i.e., the values in the last two
columns of the memory maps.
The assignment operation in line 5 sets memory as-
sociated with p as untainted, and leaves Prospector’s
markers untouched (Figure 2b).
This brings us to the execution of the while loop in
lines 6-7. The ﬁrst iteration marks addrvuln buf tainted,
sets AgeStamp(addrvuln buf ) to the current value of
AgeStamp, and PFT(addrvuln buf +1) to 1. We informally
interpret it as addrvuln buf telling (addrvuln buf +1): “I
have tainted contents, more fresh than yours”. We still
need to decide about FTS(addrvuln buf ). As we do not
know the value of PFT(addrvuln buf ), let us assume, for
example, that PFT is unset. In this case, addrvuln buf
has already ‘consumed the message’ from (addrvuln buf -
1), and so the current store operation is not the ﬁrst
since (addrvuln buf -1) became tainted. We record this
information by unsetting FTS(addrvuln buf ).
Figure 2c presents the second iteration of the while
loop in lines 6-7. We mark addrvuln buf +1 as tainted,
set AgeStamp(addrvuln buf +1) to the current value of
AgeStamp, and PFT(addrvuln buf +2) to 1, thus inform-
ing the memory location above it that addrvuln buf +1
has freshly tainted contents. This time we know that no
tainted store operation was executed since addrvuln buf
became tainted. We set FTS(addrvuln buf +1) to 1,
and also unset PFT(addrvuln buf +1), since the tainted
value of addrvuln buf +1 is more recent than that of
addrvuln buf .
Figure 2d illustrates the memory map just after the
while loop. Observe that all bytes inside the tainted
492492
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:39:37 UTC from IEEE Xplore.  Restrictions apply. 
i .
f o r a l l
1 . PFT [ addr1 +1] = 1 ;
t a i n t e d s t o r e s
Listing 2. Algorithm for updating the indicators
t o addr1 do :
// E x p l a n a t i o n : a d d r e s s b e l o w addr1 i s
t a i n t e d and more ’ f r e s h ’
than t h e c o n t e n t s o f addr1
2 .
i f
(PFT [ addr1 ] == 1 ) {
FTS [ addr1 ] = 1 ;
PFT [ addr1 ] = 0 ;
} e l s e
FTS [ addr1 ] = 0 ;
i f FTS [ addr1 ]==1,
// E x p l a n a t i o n :
// t h i s a d d r e s s a f t e r t h e a d d r e s s b e l o w i t was t a i n t e d . Also ,
// cannot be more r e c e n t
// F i n a l l y ,
// must be s e t
// f o l l o w i n g t h a t a t addr1 −1.
t o 0 , as addr1 no l o n g e r c o n t a i n s a v a l u e o f
i f addr1 i s updated more than once w i t h o u t change o f addr1 −1,
than t h a t o f addr1 , so we n e g a t e PFT[ addr1 ] .
t h e v a l u e a t addr1 i s
t h e r e s u l t o f 1 s t
t h e f i r s t
t h e t h e c o n t e n t o f addr1−1
t a i n t e d s t o r e t o
t h e n FTS [ addr1 ]
t a i n t e d s t o r e
3 .
i f
( ( FTS [ addr1 ] becomes 1 ) &&
( AgeStamp [ addr1 −1] < AgeStamp [ addr1 ] ) ) {
s t o r e AgeStamp [ addr1 − 1 ] ;
// StoredAgeStamp :
}
// E x p l a n a t i o n :
// c o p i e d by a f u n c t i o n and no t a i n t e d d a t a was s t o r e d h e r e s i n c e t h e a d d r e s s b e l o w i t
// became t a i n t e d . Because i t c o u l d be t h e b e g i n n i n g o f a new b u f f e r a d j a c e n t
// t a i n t e d r e g i o n , we have t o r e c o r d i t . The e x a c t r e a s o n s w i l l be c l a r i f i e d soon .
t h i s happens when addr1 i s
i n t u i t i v e l y ,
t h e f i r s t b y t e o f a b u f f e r t h a t was
t o an e x i s t i n g
f o r
l a t e r use
i i . When an a d d r e s
i s u n t a i n t e d , we do n o t t o u c h t h e v a l u e s o f
t h e PFT and FTS m a r k e r s .
memory region which contributed to the attack have
PFT unset, and FTS set to 1.
This brings us to the for loop in lines 8-9, the ﬁrst
iteration of which can be examined in Figure 2e. While
storing the ﬁrst byte in the gap, we set PFT(addrbuf +1)
to 1, and also check that the current store operation is
not the ﬁrst one since addrbuf -1 became tainted. In-
deed, the assignment in the ﬁfth iteration of the while
loop held this property. So, we unset FTS(addrbuf ).
Finally, Figure 2f presents the whole gap formed by
buf. Observe that the gap internally has PFT negated,
and FTS set, just like a ‘typical’ tainted region. How-
ever, the byte just above the gap has PFT set to 1, as a
result of the store in the fourth iteration of the for loop.
In that iteration, (addrbuf +3) informed the memory lo-
cation above it about its freshly tainted contents. Since
this was the last byte of the unrelated buﬀer, no store
operation has ‘consumed this message’. Similarly, the
bottom byte of the gap has both indicators negated.
Now that we have an intuitive grasp of the use of the
additional indicators, we are ready to turn to more for-
mal deﬁnitions (Section 4.7) and analysis (Section 4.8).
4.7 Formal speciﬁcation of properties of
tainted data and gaps
In this section, we use the indicators deﬁned above
to derive properties of regions of tainted memory.
Observation 1 Let buf be a crucial tainted region of size
n. Then:
(a) ∀i = 0 . . . (n − 1): buf[i] is tainted,
(b) ∀i = 0 . . . (n−1): AgeStampi ≥ AllocAgeStamp,
where AllocAgeStamp is the epoch in which
the buﬀer was allocated,
(c) ∀i, j = 0 . . . (n − 1), i < j: AgeStampi ≤
(d) ∀i = 1 . . . (n − 1): PFT(buf[i]) is unset, and
FTS(buf[i]) is set (as the store at buf[i] ﬁnds
PFT set).
AgeStampj,
Observation 2 Let gap be a non-tainted discontinuity
located inside a crucial tainted memory region buf,
i.e., a region in buf where Observation 1.a does
not hold. Since neither age stamps nor indicators
are changed when a memory location becomes un-
tainted, Observations 1.b–1.d also hold within gap.
Observation 3 Let gap be a tainted discontinuity of
size m inside a crucial tainted memory region buf.
Then:
(a) ∀i = 0 . . . (m − 1) gap[i] is tainted,
(b) ∀i = 0 . . . (m − 1) AgeStamp(gap[i]) ≥
AgeStamp(gap[m]) 1.
(c) gap[m] has both indicators PFT and FTS set
(d) ∀i = 1 . . . (m − 1): PFT(gap[i]) is unset, and
to 1, gap[0] has both indicators set to 0.
FTS(gap[i]) is set.
A gap containing unrelated taints may adjoin a sim-
ilar gap. In that case, they simply merge as follows.
1While gap has only m bytes and gap[m] strictly speaking
does not exist, we use it as a C-like shorthand for ‘the byte above
gap’.
493493
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:39:37 UTC from IEEE Xplore.  Restrictions apply. 
If gap is a tainted discontinuity located inside a crucial
region buf, and the bottom (top) part of gap adjoins an-
other tainted discontinuity gapb (gapt), then both holes
merge together forming a single discontinuity for which
all properties listed in Observation 3 hold.
4.8 Analysis: pinpointing the bytes re-
sponsible for the overﬂow
To ﬁnd the bytes that contributed to the attack (the
crucial region), we traverse the memory downwards
starting at the violation address and continue as long
as the bytes we come across conform to Observation 1.
In this Section we discuss how to start this process and
how to overcome the complicating factors mentioned in
Section 3.
4.8.1 The age of allocation
We start the analysis by ﬁguring out AllocAgeStamp,
the age (or epoch) in which the vulnerable buﬀer con-
taining the violation address was allocated. We need
it to distinguish between fresh and stale data.
In the case of a heap corruption attack, the age
stamp was explicitly maintained for each chunk of
memory.
In a stack smashing attack (i.e., when the
violation address is not smaller than the value of the
stack pointer register ESP), we check the history of
stack frames associated with the vulnerable process for
the most recent entry above the violation address. If
the malicious data was spilled over the adjacent stack
frame as well, we may ﬁnd an age stamp of a caller
function instead. However this does not prevent the
correct analysis, because when we start looking for the
whole crucial region later, we will ﬁgure out the most
recent, and proper AgeStamp.
4.8.2 Gaps
One of the diﬃculties identiﬁed in Section 3 concerned
gaps in the crucial region’s tainted data. As we have
seen, such discontinuities may occur for instance when
the program assigns a new value to a local variable
allocated in the crucial region after the overﬂow took
place. They can also arise if parts of the vulnerable
buﬀer are reﬁlled by the application. Let us assume
for now that the discontinuity is fully included in the
crucial tainted memory region, i.e., below the gap there
is at least one byte which contributed to the attack.
Again, to ﬁnd the crucial region we traverse the
memory as long as the bytes encountered are in ac-
cordance with Observation 1. However, we now come
across a discontinuity before we reach the region’s bot-
tom. To handle such gaps, we look for the end of the
discontinuity to ﬁnd out how many bytes of the crucial
region we are missing. In the following, assume that
addr1 is a memory location at variance with at least
one of the properties of Observation 1.
If we ﬁnd a byte at variance only with Observa-
tion 1.a (i.e., it is not tainted), we conclude that it
belongs to a non-tainted discontinuity. We traverse the
memory further until we encounter tainted data. Since
we assume that the gap does not reach the beginning
of the vulnerable buﬀer, we will ﬁnd a tainted byte.
We can also ﬁnd a byte in memory location addr1
at variance with Observation 1.d. This means that the
values of indicators are corrupted: PFT(addr1) is not
equal to 0 and/or FTS(addr1) is not equal to 1. If both
indicators are set to one, then the memory location be-
low has freshly tainted contents. Observation 3, deﬁn-
ing gaps, says that it is probable that we have just spot-
ted a tainted discontinuity. We now traverse the mem-
ory until we encounter a memory location with the two
indicators not set. Let us now assume that the incon-
sistency with Observation 1.d means that FTS(addr1)
is equal to 0. At ﬁrst sight, one may think that a new
tainted store operation at addr1 caused the change of
the indicator, but then the memory location above it
(addr1 +1) would have PFT set to 1, which would also
have conﬂicted with Observation 1.d. As we did not
detect this, such a case will not occur.
Similar reasoning yields that we will never discover
the top of a gap by coming across a byte with an
AgeStamp more recent than expected (i.e., at variance
with Observation 1.c). Indeed, a tainted store opera-
tion at addr1 changes PFT(addr1 + 1), which we will
encounter ﬁrst.
4.8.3 Excess of data
We now discuss how to determine the beginning of the
vulnerable buﬀer buf, thus we address the problem of
unrelated taints. For the sake of simplicity, we again
assume that there is no discontinuity at the beginning
of buf, i.e., at the point of intrusion detection, buf[0]
contains the byte that contributed to the attack.
Consider the successive possible instances of the be-
ginning of the vulnerable buﬀer. For each of the sce-
narios we explicitly discuss the contents of essential
variables at the time of the overﬂow and at the time of
detecting the intrusion. For the sake of clarity let us
denote the memory location of buf[0] by addrB, and
the address below buf[0] by addrA. We assume that
traversing the memory as discussed above led us to
byte addrB, and we check whether we can draw appro-
priate conclusions enabling to spot correctly the buﬀer
boundary.
494494
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 12:39:37 UTC from IEEE Xplore.  Restrictions apply. 
PFT(addrB)
equals 0; we
set
1. Overﬂow:
FTS(addrB) = 0. Detection: We encounter a byte
with FTS set to 0, and we are not inside a discontinu-
ity. Thus we have just encountered the beginning of
buf. To make the conclusion clear, note that inside a
tainted vulnerable buﬀer there is only one possibility
for a byte to have the FTS indicator unset, namely at
the beginning of a gap.
2. Overﬂow: PFT(addrB) is equal to 1, but addrA
contains stale data; we set FTS(addrB) and unset
PFT(addrB). Detection: We encounter a byte with
FTS set and PFT unset, which has the stored age stamp
of the address beneath it. Observe that since the data
at addrA is stale, AgeStampaddrA is less than the cur-
rent age stamp, and recall from Listing 2, step i.3 that
we will have stored the age stamp in this case. We