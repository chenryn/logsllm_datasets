and mobile software landscape, and many developers may not
fully understand the security implications of combining mul-
tiple layers with very different security models (explained in
Section III). From the security perspective, the key components
of any hybrid framework are the bridges between its Web-
facing JavaScript half and its device-based local half, as shown
in Fig. 2.
At the bottom of the stack is the OS (e.g., Android, iOS,
MacOS, etc.) that manages local device resources such as the
camera, ﬁle system, location, etc. The local half of the hybrid
framework is implemented in Java (Android and BlackBerry),
Objective-C (iOS), or C# (Windows Phone). It is incorporated
into the hybrid app and runs as a local application from
the viewpoint of the OS. When installed on the machine, it
obtains access to device resources using one of the mechanisms
described in Section III-B.
The framework’s local half includes an embedded Web
browser. The browser is platform-speciﬁc, e.g., WebView in
Android, UIWebView in iOS, WebBrowser in Windows Phone,
2https://github.com/phonegap/phonegap-plugins/tree/master/Android
3https://github.com/blackberry/WebWorks-Community-APIs
3
or WebWorks in BlackBerry. The framework executes the
app’s own code within this browser, yet enables this code to
access resources as if it were running as a local process on
the device. To this end, the framework supplies one or more
bridges that bypass the browser sandbox. All bridges include
(1) a local component with access to device resources, and
(2) a mechanism for the JavaScript code in the browser to
invoke the bridge and pass calls and their arguments to the
local component. The technical implementation details vary
from bridge to bridge (see Section IV).
The hybrid app itself is implemented as Web content in
HTML and JavaScript. It executes in the embedded browser
but, unlike conventional Web code, can access local resources
via bridges added by the framework. Our survey in Section VI
shows that hybrid apps often include foreign-origin content,
such as ads fetched over HTTP or, rarely, HTTPS.
III. SECURITY MODELS
The primary focus of this paper is on Web attackers. A
Web attacker controls one or more domains and may host
malicious JavaScript there. He does not, however, control the
network and cannot tamper with or observe the communica-
tions between users and other domains. We assume that the
attacker cannot execute his native code on the user’s device.
Consequently, mobile malware is outside our scope.
Web content served by a hybrid app may include iframes
with ads or other content from third parties. These ads are
supplied by an ad broker and the app’s owner often has no
control over their source or content. Therefore, a Web attacker
may trick a legitimate app into including malicious content via
syndicated advertising. In general, this is not a security hole by
itself since foreign-origin content is conﬁned by the browser’s
same origin policy (see Section III-A).
A stronger threat model is the network attacker who can
act as a man-in-the-middle on the network between the device
and the origins of its Web content. Any content fetched over
HTTP is insecure against the network attacker because it can
inject arbitrary malicious scripts into any HTTP origin.
A. Web security
The Web content of a hybrid app is governed by the same
origin policy (SOP). The origin of Web content is deﬁned by
its protocol (HTTP or HTTPS), domain, and port number [2].
SOP is enforced by all embedded Web browsers used in hybrid
frameworks (see Section II-B). For example, if an app’s Web
content includes an iframe with an ad, SOP prevents scripts
in this ad from reading or modifying any non-trivial DOM
attributes of the app’s own content.
Scripts from ad brokers, analytics services, social networks,
etc. are usually included directly into the app’s Web content
and thus run in the app’s origin. For example, an app may
include a script from an ad syndicator, which creates an
iframe and fetches an ad to display within this iframe. The
syndicator’s script runs in the app’s origin, but the actual ad
runs in its own origin, isolated from the rest of the app’s
content by the SOP. Therefore, in our threat model we consider
malicious advertisers, but not malicious ad brokers. The latter
are trusted by app developers and, critically, their Web code is
indistinguishable from the app’s own code as far as the SOP
is concerned.
B. Local security
The local half of the hybrid app is supplied by the hybrid
framework. Its security model is determined by the OS, which
mediates access to device resources, and is very different from
the Web security model described in Section III-A.
Android uses static permissions (130 as of this writing).4
An app requests them at the time of installation and the user
can either grant all of them, or decline to install the app.
Windows Phone 7.1 has 28 static install-time permissions [30].
BlackBerry OS 5 and 6 have 20 permissions in three cate-
gories: connections (6), interactions (10), and user data (4) [3].
Unlike other mobile OSes, BlackBerry OS lets the user grant
only a subset of permissions requested by an app.
Apple’s iOS uses dynamic run-time access control. When
an app accesses a resource for the ﬁrst time, iOS prompts
the user to grant the permission. Unlike Android, iOS 6 has
only a few permissions. They control access to location, social
networks, address book, calendar, Bluetooth, camera, etc.
Fracking vulnerabilities affect all platforms regardless of
their access-control model, including desktop platforms like
MacOS that do not rely on user-granted permissions. Frack-
ing is more dangerous when permissions are coarse-grained
because a single vulnerability exposes more native resources.
For example, Windows Phone 7.1 has a single permission for
all sensors (ID CAP SENSORS). If a hybrid app requests this
permission and exposes it to untrusted Web content, the latter
will be able to access any sensor on the device.
C. Hybrid security
Security of hybrid apps depends on very subtle trust
relationships. For example, on a permission-based platform
like Android, the app requests access to device resources from
the user. The user grants these permissions to the app—but
obviously not
to the foreign-origin content (such as ads)
included in the app. The app owner trusts the ad broker and
includes the broker’s scripts into its own origin. These scripts
create iframes and display ads in them. Nobody—neither the
user, nor the app, nor the ad broker—trusts the advertisers and
their content, which is why ads, as well as other foreign-origin
content, are isolated in iframes, so that the SOP can block them
from accessing other parties’ resources.
Hybrid frameworks must guarantee the following security
property: Web content from untrusted domains included
into a hybrid app should not be able to access device
resources available to the app. To achieve this, hybrid
frameworks must carefully “glue together” two very different
security policies: the same origin policy governing the app’s
Web content, and the OS access-control policy governing the
framework’s local half. In particular, hybrid frameworks must
correctly propagate the same origin policy to local objects
outside the Web browser when these objects are accessible
from inside the browser via the framework’s bridges.
4http://developer.android.com/reference/android/Manifest.permission.html
4
this property NoBridge), or the app cannot
In practice, hybrid frameworks attempt to enforce one of
the following two properties: Web content from unauthorized
domains cannot access the bridges created by the framework
(we call
load
any content from untrusted domains (we call this property
NoLoad). Both properties prevent undesired access to re-
sources, but NoLoad breaks the business model of many free
apps because it prevents them from displaying foreign-origin
ads. In Section VII, we show that the frameworks’ defenses
are inconsistent and apply different policies in different parts
of the same code, often incorrectly.
IV. BRIDGES
The main purpose of any hybrid framework is to supply
bridges that enable the app’s Web content to access local
device resources. The app, however, does not invoke these
bridges directly. Instead, it uses the framework’s JavaScript
library, which presents a structured, platform-independent API
for resource access. This library invokes the bridges internally,
thus the mechanics of different bridge architectures are trans-
parent to the app and the app’s code does not directly depend
on the speciﬁc bridges used by the framework.
To enable asynchronous resource access, frameworks often
provide separate Web-to-local bridges (for invoking a local
function) and local-to-Web bridges (for receiving the result).
With this separation, JavaScript executing in the embedded
browser does not block while the device is accessing the
resource.
A. Web-to-local bridges
Interfaces. Several embedded browsers allow local code to
expose arbitrary functions to JavaScript running within the
browser. For example, ‘addJavascriptInterface’ in Android’s
WebView makes local Java objects visible to JavaScript.
Other platforms have similar functionalities, for example, ‘win-
dowScriptObject’ in MacOS and ‘ScriptEngine.addExtension’
in BlackBerry WebWorks.
This technique is used, among others, by PhoneGap, Ap-
pCelerator Titanium, and Sencha Touch to enable direct access
to local device resources by Web content.
On Android prior to API level 17, these interfaces are
generically insecure. Malicious JavaScript executing inside
WebView can use the Java reﬂection API to invoke any method
of any Java object exposed via ‘addJavascriptInterface’ and
take control over the local side of the application [1, 18, 23].
Starting from Android API level 17, only the methods explic-
itly annotated with @JavascriptInterface are visible in the Java
objects exposed to WebView via ‘addJavascriptInterface’.
Events. Another common mechanism for the local half of
the framework to receive messages from the Web half is via
various JavaScript events. To use this mechanism, the local
half must override the event handlers in the embedded browser.
JavaScript on the Web side triggers events and encodes mes-
sages in arbitrary strings, the handlers intercept these events
and decode the messages.
For example, WebView, Android’s embedded browser
class, allows local Java code to customize the handling of
‘prompt’,
’alert’, and ’conﬁrm’ events by overriding the
‘onJsPrompt’, ‘onJsAlert’, and ‘onJsConﬁrm’ functions, re-
spectively. This bridge mechanism is used by PhoneGap on
Android 2.3 because of a bug5 that precludes the use of an
interface-based bridge described above. On the local side,
PhoneGap implements a custom ‘onJsPrompt’ handler. On the
Web side, JavaScript makes a ‘prompt’ call to invoke this
handler; the name and the arguments of the local object to
be called are serialized and sent to the local side by encoding
them as prompt messages. MoSync on Android uses a similar
mechanism.
Similarly, WebBrowser, the embedded browser class in
Windows Phone, allows local C# code to install custom
handlers for ‘ScriptNotify’ events. JavaScript on the Web
side uses ‘window.external.Notify’ to trigger these events and
invoke local functions. This technique is used by PhoneGap
on Windows Phone.
Event-based bridges can be synchronous (JavaScript pauses
the call returns) or asynchronous (the call returns a
until
placeholder or null, but the actual data is returned later via
a local-to-Web bridge).
URL loading interposition. Embedded browsers typically al-
low local code to interpose on and handle URL loading within
the browser. This feature is intended to support implementation
of custom protocols, but hybrid frameworks overload it so that
the Web half of the framework can pass arbitrary messages
to the local half by encoding them in the URL,
thereby
constructing a Web-to-local bridge.
URLs intended for interposition cannot be loaded in the
main browser frame lest the entire app blocks. Instead, hybrid
frameworks use one of the following two methods.
JavaScript on the Web side can create an invisible iframe
and set its source to an arbitrary URL. The loading of this
URL is intercepted by a handler supplied by the framework’s
local half, without affecting the execution of the main frame
on the Web side. The handler decodes the URL and passes
the message to the local half. For example, PhoneGap on iOS
creates its own subclass of NSURLProtocol named CDVURL-
Protocol and calls registerClass function to intercept URLs
loaded in the UIWebView embedded browser. PhoneGap’s
JavaScript library creates an iframe whose URL starts with
gap://, PhoneGap’s local half intercepts the loading of this
URL and calls the corresponding local function. In Web Mar-
malade,6 the framework’s JavaScript library creates an iframe
with the src attribute s3ebridge://queued. A shared JavaScript
object, s3e.queue, in this iframe is used for communication
between the Web half and local half.
an
alternative
to
As
iframe-based
communication,
JavaScript on the Web side can make an asynchronous
XMLHttpRequest to a URL which is intercepted and decoded
by the framework’s
this
technique on iOS in addition to the iframe URL interception.
local handler. PhoneGap uses
5http://code.google.com/p/android/issues/detail?id=12987
6https://github.com/marmalade/Web-Marmalade/blob/master/wmClipboard/
data/webassets/wm.js
5
Cookies (obsolete). The framework’s Web half can set cookies
that are readable by the local half, and vice versa. PhoneGap
used this technique on older platforms like BlackBerry 4.x,
B. Local-to-Web bridges
Local-to-Web bridges are used by the framework’s local
half to return data to the framework’s JavaScript library on
the Web side. Some data such as device ID can be returned
synchronously via the function’s return value, but usually the
results of device access (e.g., contact list, local ﬁles, etc.) are
returned asynchronously, to avoid blocking Web code while
access is performed.
Multiplexing a Web-to-local bridge. Messages from the
local half to the Web half can be sent over the same bridge
as the Web-to-local messages. There are two asynchronous
mechanisms for doing this.
Local code can trigger events to notify the JavaScript
library that there is data waiting for it. JavaScript then reads the
data via one of the Web-to-local bridges from Section IV-A.
This mechanism, using online/ofﬂine events,7 is employed by
PhoneGap on Android.
On many platforms, event-based synchronization is not
available if the framework’s JavaScript is running inside an
iframe. Many embedded browsers—including WebView on
Android, UIWebView on iOS, and WebBrowser on Windows
Phone—incorrectly deliver some events to the main frame even
if the handler is registered inside an iframe. This issue is
sometimes referred to as “frame confusion” [17].
The alternative is to have JavaScript poll the Web-to-local
bridge at periodic intervals to check whether data is ready.
PhoneGap on Android supports this technique, too.
let
local code execute arbitrary JavaScript
Interfaces. Many embedded browsers have helper func-
tions that
in-
side the browser. For example, Android’s WebView has a
private reﬂection API, as well as the ‘loadUrl’ function
that allows Java code to load a javascript: URL inside the
browser. PhoneGap on Android uses both. PhoneGap on
iOS, BlackBerry, and Windows Phone uses ‘stringByEvalu-
atingJavaScriptFromString’, ‘ScriptEngine.executeScript’, and
‘WebBrowser.InvokeScript’ functions, respectively, to execute
JavaScript inside the corresponding embedded browsers.
C. Custom cross-origin communication
As mentioned above, many local-to-Web bridges often do
not work if the framework’s JavaScript library is running inside
an iframe. For example, on iOS and Windows Phone 7, bugs in
embedded browsers cause the data to be returned to the main
frame rather than the iframe that invoked the bridge.
This forces app developers to implement “home-brewed”
cross-origin mechanisms to deliver the data from the device
7These events are sent by HTML5 browsers to Web pages when the browser
detects the Internet connection to be enabled/disabled; PhoneGap re-purposes
them for local-to-Web notiﬁcations.
6
to the iframe that needs it.8 9 10 These custom, hand-coded
hacks open holes in the same origin policy and can introduce
serious security vulnerabilities, including cross-site scripting
(e.g., see [25]). While interesting, this class of vulnerabilities
is not speciﬁc to hybrid apps and we leave its detailed analysis
to future work.
V. FRACKING
As explained in Section III-C, the hybrid framework must
guarantee that untrusted foreign-origin content included into
the app—for example, ads—not be able to access local device
resources such as the ﬁle system, contacts, SMS, etc. via
the bridges provided by the framework. Unauthorized access
can be exploited for privacy violations (e.g., steal the user’s
contacts list), security breaches (e.g., use personal data for
targeted phishing), monetary gains (e.g., send SMS to premium
numbers), or denial of service (e.g., cause the phone to vibrate
or beep incessantly).
To prevent unauthorized resource access by foreign-origin