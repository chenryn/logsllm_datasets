**作者：rep_Su@青藤实验室  
原文链接：**
之前我们分享了一篇 [windows
计划任务隐藏新姿势分享](https://mp.weixin.qq.com/s/ktGug1VbSpmzh9CEGKbbdw)，看到留言感兴趣的是计划任务的排查，因此又出了一篇详细的排查教程，希望对大家有所帮助。
## 研究背景
在 server 2012 上使用 schtasks 创建计划任务时，我意外的发现，当分别使用参数 `/mo` 和 `/ri`
时，计划任务创建的方式有所不同，具体如下图：
我在其参数说明中也未见对此现象的具体描述
且在计划任务管理器上发现其区别似乎只在于触发器的不同。抱着一探究竟的想法，我花了一周左右的时间研究并整理了此文，来为 windows
计划任务的相关问题提供些绵薄之力。
本文中所研究的计划任务均由 **schtasks.exe** 创建。
## 探索原因
为了一探究竟，在 server 2012 上，我分别对两种启动流程进行了追踪，在初步的了解之后，我发现随着 windows
系统的变迁，计划任务的相关进程的启动和计划任务的创建有旧版和新版之分，为了更好的理解，结合研究的内容下述依次对新旧版进行大致的说明。
### 旧版的计划任务
#### 进程启动
通过对计划任务的监控，我发现，在 server 2012 上，计划任务进程的启动，主要依赖于计划任务文件的读取和注册表项配置的访问。当使用参数 `/ri`
时，计划任务进程创建的堆栈如下图所示:  
我发现此时其进程创建的关键模块为 schedsvc，通过堆栈可以大致看出此类计划任务进程的创建由 schedsvc 管理， schedsvc 会启动回调
job，从队列中捕获到并启动计划任务的 job，进而创建计划任务进程。
在 schedsvc.dll 中，我可以清晰的看到，计划任务进程创建时，实际上创建的是 taskeng.exe
进程，这也解释了为什么我看到此类计划任务的父进程是 taskeng。  
在这一参数创建的计划任务进程启动时，我发现，schedsvc.dll 与 taskeng 分工明确，schedsvc.dll
主要负责注册表中对应计划任务的读取及更新，其中比较关键的行为是： **schedsvc
会负责从计划任务的job队列中启动计划任务，并且将计划任务进程的执行时间写入注册表项 DynamicInfo中** 。
写入注册表项DynamicInfo的过程如下  
写入注册表的值如下  
写入后注册表中对应项的值如下  
通过分析，我发现，在 DynamicInfo 注册表项中记录的二进制偏移+c处的内容正是其计划任务执行的 UTC 时间信息。  
通过对计划任务进程行为的追踪，我发现，每次计划任务进程被创建时，DynamicInfo 注册表项均会被更新，即通过对注册表中的 DynamicInfo
的监控及其中时间数据的解析，我可以知道某计划任务的进程在某时刻被执行，从而定位到对应的计划任务。 而 **taskeng则主要负责
\Windows\System32\Tasks 目录下的计划任务文件的读取及启动对应的计划任务进程**
Task 文件读取如下  
计划任务进程创建如下  
当将参数更改为 `/mo` 时，我发现此时的进程创建的堆栈完全改变了，如下图
可以看到，之前的 schedsvc 模块已经完全看不到了，取而代之的是 UBPM 和
EventAggregation，UBPM全称是统一后台进程管理器。它是自 Windows 7 和 Windows Server 2008 R2
引入的一种新的调度引擎，关于其更多的介绍，可以参考文末参考链接。而 EventAggregation，其描述为“用户态的 Event Aggregation
库”（Event Aggregation User Mode Library）  
从搜索引擎中，我暂未找到关于其更详细的介绍，只知道其大致为事件聚合相关的用户态库，通过对计划任务进程行为的分析，我可以看到，在计划任务进程启动的过程中，其主要扮演着对计划任务事件的处理、通知以及信号分发的角色。
结合相关堆栈，我初步认为 UBPM 主要负责捕获被称之为 Trigger 的信号，当 Trigger 到达时，便会执行对应的 TriggerActions
启动计划任务进程，这一部分会在后文 **现代的计划任务中** 进行部分说明。
在 winserver
2012，根据UBPM的代码逻辑，计划任务进程启动时会在如下路径生成对应的计划任务ID的服务日志文件，并将计划任务的报告信息写入文件中。  
其中记录的依然是计划任务进程执行的时间信息，依旧为 UTC 时间。  
实际上，这也为我提供了一个找到 **旧版 UBPM 调度引擎** 启动的对应计划任务的方法，我可以直接在
`\Windows\System32\LogFiles\Scm` 文件夹，找到最新的文件，再根据文件名，在注册表中定位到计划任务的ID，从而定位到计划任务。
#### 计划任务的创建
对于上述提到的 `/ri` 和 `/MO` 的这两个参数，计划任务创建的过程大致相同，在 server 2012 上，负责计划任务创建的关键模块为
schedsvc，在计划任务创建的过程中其会执行一系列操作，这里只简要对其中的关键行为进行说明，暂不做进一步挖掘。在后文中的 **现代的计划任务中**
也会做部分补充。  
获取task文件夹的安全描述符进行权限检查
读取对应注册表项的中的关键项信息  
创建计划任务文件  
设置对应计划任务在注册表中各子项的值  
即在计划任务创建的过程中，schedsvc 主要负责获取相关计划任务的安全权限并对其进行检查，随后会对关键的注册表项
`TaskCache\Tasks\{ID}` 进行读取并创建计划任务文件，然后根据对关键注册表项的读取结果，再将注册表的各对应子项写入计划任务的相关内容。
### 现代的计划任务
然而，当我把目光聚焦到较新的操作系统时，我发现变化已然发生。
#### 进程启动
在较新的windows版本中（此测试版本为win10 19042.685），我发现在相关的 schedsvc
模块中旧版中的相关进程启动函数逻辑已经找不到了，之前的 taskeng 的执行逻辑也不复存在了。
取而代之的是，无论采用是 `/MO` 还是 `/RI` 参数创建计划任务，计划任务的执行流程都统一由 UBPM 管理，其执行流程也和 server 2012
上的略有不同，其堆栈情况如下  
我可以看到 UBPM 依然在 Trigger 到达后，会对其进程处理，但是实际上多了一层封装  
经过分析，此处，handle 函数的参数 a3 是一个 UBPM_TRIGGER_CONSUMER_BLOCK 结构体，此结构体随后会被作为参数传递到