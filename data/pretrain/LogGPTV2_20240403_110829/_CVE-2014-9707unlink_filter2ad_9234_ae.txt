紧接着会对两个堆空间进行free操作
wfree(dupPath);
wfree(segments);
经过之前的分析，问题出现在path申请堆空间后的strcpy后，其实看到这里可以很明朗的看出一些东西，我们来看一张对比图。
阅读过堆溢出漏洞的小伙伴肯定对右面图中的代码很熟悉，实际上，CVE-2014-9707这个漏洞，分析完这个漏洞的成因之后，可以还原成一个最常见的unlink漏洞利用的模型！
    ```
    #include 
    #include 
    int main( int argc, char * argv[] )
    {
            char * first, * second;
    /*[1]*/ first = malloc( 660 );
    /*[2]*/ second = malloc( 660 );
            if(argc!=1)
    /*[3]*/         strcpy( second, argv[1] );
    /*[4]*/ free( first );
    /*[5]*/ free( second );
    /*[6]*/ return( 0 );
    }
    ```
接下来，我们来看一下这个漏洞申请堆空间的布局。
我们可以看到，根据malloc的情况，可以将申请的空间做如下布局，top
chunk是未被分配的堆空间，path所处的chunk，是可控的，也就是上面给出模型中的second部分，argv［1］就相当于我们在实战中要拷贝的堆空间。
也就是说，当我们在demo中，找到一个合适的payload，导致返回地址被修改成shellcode地址，或者system地址等等，无论怎么样，都能达到最后的利用。
这里我需要多说几句，如果仔细看过上面的demo和以前unlink的文章比较的话，会发现我拷贝的是第二个缓冲区，也就是说在free（second）的时候，才有可能会出发unlink，而不是free（first），这是因为在实战中，free（segment）的时候才会出发漏洞，所以利用覆盖got表中free地址替换为shellcode或者system函数的方法并不可用。
这里还是要利用覆盖返回地址的方法。关于unlink的触发机制在unlink的各种文档中都有详细描述，简单的描述
理解大致就是空闲块合并操作，释放块的时候，通过欺骗某chunk
header来达到令系统认为A块的前面一块活着后面一块是空闲的，这样就会触发A块脱链，触发unlink宏，当然，这里A块不一定是当前块，也有可能是当前块的下一块。
**  
**
**glibc保护机制与绕过**
在不断的版本更新中，glibc对抗堆溢出漏洞的手法层出不穷，在不断的演变中，我们需要面对不同的防护机制，这里通过对比分析和实战，我总结了glibc在进化过程中的变化和利用方法。很多利用在以前unlink的文章中都有描述，我在文末的参考文章中都已经指出，这里就不再进行赘述。
首先来看一下glibc 2.1.1版本中，关于unlink宏的定义。malloc.c第2344行。
    ```
    #define unlink(P, BK, FD)                                                     
    {                                                                             
      BK = P->bk;                                                                 
      FD = P->fd;                                                                 
      FD->bk = BK;                                                                
      BK->fd = FD;                                                                
    }         
    ```
可以看到，最老版本的glibc中对chunk header的控制并不好，导致那个时候是最好利用的，这里对chunk
header的结构我就不再多做描述，几乎所有关于linux下的堆溢出文章中都会提到，那么这里，如果我们设置unlink块的对象中的bk和fd为某些特殊的值，在这个条件下很容易就能达到利用。
接下来来看一下glibc 2.15版本中，关于unlink宏的定义。malloc.c第1544行。
    ```
    #define unlink(P, BK, FD) {                                            
      FD = P->fd;                                                          
      BK = P->bk;                                                          
      if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                
        malloc_printerr (check_action, "corrupted double-linked list", P); 
      else {                                                               
        FD->bk = BK;                                                       
        BK->fd = FD;                                                       
        if (!in_smallbin_range (P->size)                                          
             && __builtin_expect (P->fd_nextsize != NULL, 0)) {               
          assert (P->fd_nextsize->bk_nextsize == P);                         
          assert (P->bk_nextsize->fd_nextsize == P);                         
          if (FD->fd_nextsize == NULL) {                                        
             if (P->fd_nextsize == P)                                       
               FD->fd_nextsize = FD->bk_nextsize = FD;                   
             else {                                                                        
               FD->fd_nextsize = P->fd_nextsize;                                
               FD->bk_nextsize = P->bk_nextsize;                               
               P->fd_nextsize->bk_nextsize = FD;                               
               P->bk_nextsize->fd_nextsize = FD;                               
             }                                                                       
          }   else {                                                                        
             P->fd_nextsize->bk_nextsize = P->bk_nextsize;                      
             P->bk_nextsize->fd_nextsize = P->fd_nextsize;                       
          }                                                                            
        }                                                                                
      }                                                                    
    }
    ```
可以看到，这里对FD->bk和BK->fd做了严格的判断，如果下一块的fd和前一块的bk不等于当前块，则会打印错误信息。只有当判断条件通过的情况下，才会执行else语句内的后续赋值内容。那么，是不是这样条件下就无法利用了呢？我们可以关注到，在else语句中还有一个嵌套的if语句，其中会执行一个函数in_smallbin_range，传参为当前块的大小，当当前块大小大于512字节的时候，程序会进入if语句中的内容，其中涉及到两个非常关键的指针指向变量fd_nextsize和bk_nextsize，而这个if语句中的else内，会执行一个赋值操作，对这两个变量，没有进行检查，于是在这种情况下，我们需要构造一个大于512字节的块，伪造fd_nextsize和bk_nextsize来完成利用。
在这个漏洞的利用环境下就是利用的这个unlink宏，那么我们注意到在判断完FD->bk后的入口点，有两个assert断言，实际上在release版本下，这两个断言并不能触发。
接下来我们来看较新的glibc 2.21，在这个版本下，malloc.c第1411行
    ```
    #define unlink(P, BK, FD) {                                            
        FD = P->fd;                                                                               
        BK = P->bk;                                                                              
        if (__builtin_expect (FD->bk != P || BK->fd != P, 0))                         
          malloc_printerr (check_action, "corrupted double-linked list", P);      
        else {                                                                                
            FD->bk = BK;                                                                  
            BK->fd = FD;                                                                   
            if (!in_smallbin_range (P->size)                                         
                && __builtin_expect (P->fd_nextsize != NULL, 0)) {                       
                 if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)            
                       || __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    
                   malloc_printerr (check_action,                                     
                                       "corrupted double-linked list (not small)", P);
                if (FD->fd_nextsize == NULL) {                                   
                    if (P->fd_nextsize == P)                                      
                      FD->fd_nextsize = FD->bk_nextsize = FD;                  
                    else {                                                                       
                        FD->fd_nextsize = P->fd_nextsize;                          
                        FD->bk_nextsize = P->bk_nextsize;                                  
                        P->fd_nextsize->bk_nextsize = FD;                          
                        P->bk_nextsize->fd_nextsize = FD;                          
                      }                                                                 
                  } else {                                                                
                    P->fd_nextsize->bk_nextsize = P->bk_nextsize;                     
                    P->bk_nextsize->fd_nextsize = P->fd_nextsize;                      
                  }                                                                           
              }                                                                           
          }                                                                                    
    }
    ```
和上面的代码大同小异，但是可以看到在之前的assert断言中判断的内容，被挪到if语句中进行判断，也就是说利用fd_nextsize和bk_nextsize伪造的方法不能再利用了。
因此在最新版glibc下如何完成堆溢出，是我下一步想研究的内容。
**  
**
**从unlink到漏洞利用**
讲了glibc版本更迭，攻防对抗的升级，下面来讲一下这个漏洞的利用，在之前的内容中我们提到path是可控的，也就是说我们利用path覆盖top
chunk，然后在segment被释放的时候，会去top chunk
header中判断path块是否空闲，如果这时候欺骗linux让它认为path块空闲，则会触发path块unlink操作，从而导致漏洞呗利用。
在最老的版本glibc中，我们只需要将fd和bk分别设置为特定值即可完成利用，但是之前也提到新版glibc中发生的变化，下面我们来看一下linux中对抗堆溢出需要注意哪些情况吧。
首先linux会对堆大小进行检查，也就是说chunk
header中的prev_size会被检查，这是为了对抗堆溢出中，设定prev_size为－4这种负数的情况，用于欺骗，因为为了计算前一个堆的偏移会用某chunk头部地址减去prev_size。
这时候就会产生错误。
来看一下glibc2.15的malloc.c中关于前一块大小检查部分的代码。
    ```
        nextsize = chunksize(nextchunk);
        if (__builtin_expect (nextchunk->size = av->system_mem, 0))
          {
             errstr = "free(): invalid next size (normal)";
    ```
可以看到，在这里会对nextsize进行判断，nextsize是由下一块的chunksize得到，这时我们要记住prev_size，纪录的是前一块的大小，04030201时产生错误。
其次是double
free的检查，不能连续释放两次，也就是说，当堆溢出覆盖下一个块和下下一个块的in_use位为0的时候（空闲状态），会无法通过double free的检查。
可以看到，这时大小变成01020304后，通过了next
size的检查，但是来看IN_USE位，当下一块和下下块IN_USE位都为0时，也就是连续两个块都空闲，则无法通过double free的检查。
来看一下malloc.c中的相关代码。
    ```
        /* Or whether the block is actually not marked used.  */
        if (__builtin_expect (!prev_inuse(nextchunk), 0))
          {
             errstr = "double free or corruption (!prev)";
             goto errout;
          }
    ```
因此不能有连续两个块IN_USE都为0.
于是，我们可以构造这样的利用方法，glibc 2.15版本下，最新版会有新的防护，之前已经提到。
这里，我们构造一个伪造的块处于path块和top
chunk块之间，用这种方法来绕过之前提到的FD->bk=P的检查，最后在前面的章节中，我们介绍到利用fd_nextsize和bk_nextsize的方法来完成最终的代码执行，于是我们将返回地址和shellcode地址分别布置在这两处位置。
最后我们可以完成利用。
在这个研究中，我对linux堆溢出有了更深刻的理解，确实刚开始接触堆溢出的时候感觉很乱，尤其是链表，后来发现自己研究链表的机制，很快就能明白，尤其是配合这个漏洞进行调试，希望大家能够多多交流，共同进步！
**参考链接**
[http://seclists.org/fulldisclosure/2015/Mar/157](http://seclists.org/fulldisclosure/2015/Mar/157)