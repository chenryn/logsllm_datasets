Web Programming Without Tiers. In Formal Methods for Components and
Objects, pages 266–296. Springer, Oct. 2007.
[12] D. Flanagan. JavaScript: The Deﬁnitive Guide. O’Reilly, 4th edition, 2002.
[13] S. Fogie, J. Grossman, R. Hansen, A. Rager, and P. D. Petkov. XSS Attacks:
Cross Site Scripting Exploits and Defense. Syngress, 2007.
[14] Google Gears. http://gears.google.com.
[15] Google Web toolkit. http://code.google.com/webtoolkit.
[16] A. Guha, S. Krishnamurthi, and T. Jim. Using static analysis for Ajax intrusion
detection. In Proceedings of the International Conference on World Wide Web,
pages 561–570, Apr. 2009.
[17] V. Haldar, D. Chandra, and M. Franz. Dynamic taint propagation for Java. In
Proceedings of the Annual Computer Security Applications Conference, pages
303–311, Dec. 2005.
[18] A. Hartman. Exploring Adobe Flash CS4. Delmar Learning, 2009.
[19] B. Hoffman. Ajax security dangers.
http://www.spidynamics.com/assets/documents/AJAXdangers.pdf,
2006.
184[20] B. Hoffman and B. Sullivan. AJAX security. Addison-Wesley Professional,
2007.
[21] G. Hoglund and G. McGraw. Exploiting Online Games: Cheating Massively
Distributed Systems. Addison-Wesley Professional, 2007.
[22] J. Howell, C. Jackson, H. J. Wang, and X. Fan. MashupOS: Operating system
abstractions for client mashups. In Proceedings of the USENIX Workshop on
Hot topics in operating systems, pages 1–7, May 2007.
[23] Y.-W. Huang, F. Yu, C. Hang, C.-H. Tsai, D.-T. Lee, and S.-Y. Kuo. Securing
Web application code by static analysis and runtime protection. In Proceedings
of the International Conference on World Wide Web, pages 40–52, May 2004.
[24] S. Jha, S. Katzenbeisser, and H. Veith. Enforcing semantic integrity on
untrusted clients in networked virtual environments. In Proceedings of the IEEE
Symposium on Security and Privacy, pages 179–186, May 2007.
[25] T. Jim, N. Swamy, and M. Hicks. Defeating script injection attacks with
browser-enforced embedded policies. In Proceedings of the International
Conference on World Wide Web, pages 601–610, May 2007.
[26] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static analysis tool for
detecting Web application vulnerabilities. In Proceedings of the IEEE
Symposium on Security and Privacy, pages 258–263, May 2006.
[27] A. Judson. Tamper data Firefox add-on.
https://addons.mozilla.org/en-US/firefox/addon/966.
[28] R. Kennell and L. H. Jamieson. Establishing the genuinity of remote computer
systems. In Proceedings of the USENIX Security Symposium, pages 21–21,
Aug. 2003.
[29] R. Lerner. At the forge: Firebug. Linux J., 2007(157):8, 2007.
[30] B. Livshits and E. Kiciman. Doloto: Code splitting for network-bound Web 2.0
applications. In Proceedings of the ACM SIGSOFT International Symposium on
Foundations of software engineering, pages 350–360, Sep 2008.
[31] B. Livshits and M. S. Lam. Finding security errors in Java programs with static
analysis. In Proceedings of the USENIX Security Symposium, pages 18–18,
Aug. 2005.
[32] D. Malkhi and M. K. Reiter. Secure and scalable replication in phalanx. In
Proceedings of the The IEEE Symposium on Reliable Distributed Systems,
page 51, Oct. 1998.
[33] D. Manolescu, B. Beckman, and B. Livshits. Volta: Developing distributed
applications by recompiling. IEEE Software, 25(5):53–59, Oct. 2008.
[34] M. Martin, B. Livshits, and M. S. Lam. SecuriFly: Runtime vulnerability
protection for Web applications. Technical report, Stanford University, 2006.
[35] Microsoft Corporation. Microsoft Live Labs Deepﬁsh.
http://labs.live.com/deepfish/, 2006.
[36] Microsoft Corporation. Microsoft Live Labs Volta. http:
//research.microsoft.com/~emeijer/CloudProgrammability.html,
2007.
[37] Microsoft Corporation. Silverlight. http://silverlight.net, 2007.
[38] P. Montesinos, M. Hicks, S. T. King, and J. Torrellas. Capo: a
software-hardware interface for practical deterministic multiprocessor replay. In
Proceeding of International Conference on Architectural Support for
Rrogramming Languages and Operating Systems, pages 73–84, Mar. 2009.
[39] S. Narayanasamy, G. Pokam, and B. Calder. Bugnet: Continuously recording
program execution for deterministic replay debugging. SIGARCH Computer
Architecture News, 33(2):284–295, May 2005.
[40] A. Nguyen-Tuong, S. Guarnieri, D. Greene, J. Shirley, and D. Evans.
Automatically hardening Web applications using precise tainting. In
Proceedings of the IFIP International Information Security Conference, pages
372–382, June 2005.
[41] T. Pietraszek and C. V. Berghe. Defending against injection attacks through
context-sensitive string evaluation. In Proceedings of the Recent Advances in
Intrusion Detection, Sept. 2005.
[42] J. Richter. CLR via C#. Microsoft Press, 2006.
[43] A. Russell. Comet: Low latency data for the browser.
http://alex.dojotoolkit.org/wp-content/LowLatencyData.pdf,
2006.
[44] F. B. Schneider. Implementing fault-tolerant services using the state machine
approach: a tutorial. ACM Compututing Surveys, 22(4):299–319, Dec. 1990.
[45] S. Segan. For Skyﬁre’s mobile Web, the secret’s in the server. http:
//www.pcmag.com/print_article2/0,1217,a%253D223932,00.asp,
Jan. 2008.
[46] M. Serrano, E. Gallesio, and F. Loitsch. Hop: a language for programming the
web 2.0. In Companion to the Conference on Object-oriented Programming
Systems, Languages, and Applications, pages 975–985, Oct. 2006.
[47] S. Smith. Capacity and performance planning. In European Microsoft
SharePoint Conference 2007, Feb. 2007.
[48] C. Stockwell. What’s Coming in IE8. http:
//blogs.msdn.com/ie/archive/2008/08/26/ie8-performance.aspx,
2008.
[49] J. D. Strunk, G. R. Goodson, M. L. Scheinholtz, C. A. N. Soules, and G. R.
Ganger. Self-securing storage: protecting data in compromised system. In
Proceedings of the Conference on Symposium on Operating System Design and
Implementation, pages 12–12, Oct. 2000.
[50] The Samy worm. http://namb.la/popular.
[51] F. Tip. A survey of program slicing techniques. Journal of programming
languages, 3:121–189, 1995.
[52] Y. Xie and A. Aiken. Static detection of security vulnerabilities in scripting
languages. In Proceedings of the USENIX Security Symposium, Aug. 2006.
[53] J. Yan. Security design in online games. In Proceedings of the Annual
Computer Security Applications Conference, page 286, Dec. 2003.
[54] F. Yang, J. Shanmugasundaram, M. Riedewald, and J. Gehrke. Hilda: A
high-level language for data-driven Web applications. In Proceedings of the
International Conference on Data Engineering, pages 32–43, Apr. 2006.
[55] D. Yu, A. Chander, H. Inamura, and I. Serikov. Better abstractions for secure
server-side scripting. In Proceeding of the International Conference on World
Wide Web, pages 507–516, Apr. 2008.
[56] D. Yu, A. Chander, N. Islam, and I. Serikov. JavaScript instrumentation for
browser security. In Proceedings of the Symposium on Principles of
Programming Languages, pages 237–249, Jan. 2007.
[57] S. Zdancewic and A. C. Myers. Secure information ﬂow and CPS. Lecture
Notes in Computer Science, 2028:46–61, 2001.
[58] S. Zdancewic, L. Zheng, N. Nystrom, and A. C. Myers. Untrusted hosts and
conﬁdentiality: Secure program partitioning. In Proceedings of Symposium on
Operating System Principles, pages 1–14, 2001.
[59] L. Zheng, S. Chong, A. C. Myers, and S. Zdancewic. Using replication and
partitioning to build secure distributed systems. In Proceedings of the IEEE
Symposium on Security and Privacy, pages 236–250, May 2003.
APPENDIX
The appendix section is organized as follows: Appendix A provides
a description of our benchmarks. Appendix B outlines a formaliza-
tion approach for RIPLEY guarantees.
A. BENCHMARK APPLICATIONS
In this section we describe the benchmark applications we used
to test RIPLEY. All of these applications have been developed on
top of Volta. A summary of information about these applications
is given in Figure 7.
In our choice of applications, we were in-
spired by previous application benchmarks [7] as well as attacks
presented in books “Exploiting Online Games” [21] and “AJAX Se-
curity” [19]. We particularly wanted to demonstrate how the AJAX
model allows us to migrate virtually the entire computation to the
client, with a minimum of RPCs, and how, when RIPLEY is ap-
plied, this approach does not lead to a reduction in integrity.
A.1 Client-side Shopping Cart
As in a typical shopping cart within an e-commerce application,
one can add and remove items to the cart, update their amounts,
and eventually check-out. There is a provision for using coupons
values where designed coupons C5, C10, and C15 denote 5%, 10%,
and 15% discounts, applied to the cart total.
As described in Section 1, it is typical for such an application
to carry out the total calculation on the server side, which means
that every cart update results in a RPC to the server. Our shopping
cart is implemented entirely on the client, with only one message
containing the cart total sent to the server upon check-out.
Security threats: In many ways, the shopping cart application is
a demonstration of typical client-side security threats described in
Section 2. For example, a malicious user may attempt to manip-
ulate the discount computation by using invalid coupons or using
the same coupon multiple times. Alternatively, the malicious client
can just manually set the resulting total before it is sent over to the
server without even touching the code.
Beneﬁts of RIPLEY: With RIPLEY enabled, we can afford to do
these computations on the client side, thereby preserving the appli-
cation responsiveness. Since the user events are replicated on the
server side, the server also maintains an abstract state of the cart,
which includes values of various form ﬁelds, and can easily verify
the total amount as soon as it is received from the client.
A.2 Game of Sudoku
This online game presents one of ﬁve hard-coded Sudoku puz-
zles for the user to solve. The solution is checked on the client and
185sent over to the server to be recorded for computing user ratings,
etc. As the game progresses, there are two kinds of validation
checks being performed. After a number is typed into a game cell,
the row and the column is checked to look for repetitions; repeated
numbers are ﬂagged in red. When the user is ready to submit a
solution, the entire grid is checked for validity.
Security threats: Both the local and the global validation checks of
the game state can be easily bypassed by a malicious user, leading
them to declare the puzzle as ﬁnished without making an effort.
Beneﬁts of RIPLEY: When the result of the game is submitted to
the server, RIPLEY will check the validity of the ﬁnal solution based
on the event stream that it receives as input. A single RPC may be
used to submit all the relevant client-side events at once without
creating extra network trafﬁc.
A.3 AJAX Blog
This online blog application allows the user to view a blog, and
to post and edit blog entries.
Security threats: Unlike the previous two applications that ad-
dress the issue of a malicious client, the focus here is on protecting
the benign client from the effects of script injection and worm at-
tacks. By default, the blog application does not perform extensive
data sanitization, leaving itself open to cross-site scripting attacks.
Worms can be used to amplify the effects of cross-site scripting. In
the case of a blog, a worm may post a blog entry on behalf of an
unsuspecting user.
Beneﬁts of RIPLEY: In case of a JavaScript worm, when the worm
tries to propagate by uploading executable contents to the server,
it will do so by sending extra RPCs. Because the client replica
runs on the server side in .NET, it is impervious to JavaScript code
injection. As a result, the mismatch in the stream of RPCs will be
detected by RIPLEY. Also, client-side checks can now be reliably
performed on the client.
A.4 Speed Typing Test
In this application, a set of words is randomly chosen from a
dictionary and displayed to the user as a paragraph. The objective
for the user is to type as many words as she can within the time limit
of one minute. The user’s word-per-minute count and accuracy is
calculated once the time limit has passed. As the words are typed
in, their correct spelling is checked and highlighted on the ﬂy. An
interesting property of this application is that events arrive at a very
rapid rate, thereby stressing the performance side of RIPLEY.
Security threats: A malicious user may tamper with per-word
spelling checks and also manipulate the time measurements to fur-
ther rig the test.
Beneﬁts of RIPLEY: Just like in previous applications, RIPLEY
ignores circumvented checks on the client, performing its own
computation within the replica.
A.5 Online Quiz
In this quiz application, trivia questions appear one by one, and
depending on the correctness of the current answer, the next ques-
tion is selected, of a higher or same point value, respectively. After
answering a total of ten questions, the user’s score is calculated
and sent to the server for recording. The answer to each question
consists of a single word.
In an online quiz application such as this, the answer would be
sent to the server for checking after each question and the next
question would be returned. This requires a round trip after every
question, making the application less responsive.
If the quiz is
timed, the round trip overhead needs to be properly taken into ac-
count. In contrast, our design moves the entire database of ques-
tions (62 questions total) to the client. The next question’s selection
is performed on the client, only requiring a single RPC at the end.
Security threats: An interesting twist in the Quiz application com-
pared to the ones above is that the conﬁdentiality of the data on the
client is important. Indeed, if the client can easily learn and en-
ter the proper answers, cheating on the quiz would be trivial. In
general, RIPLEY does not do anything to address conﬁdentiality
concerns, relegating these concerns to the developer.
For this application, we use a simple conﬁdentiality-preserving
approach. We only send hash values of the proper answers instead
of the answers themselves. This allows us to compare hash values
of the provided answers with the correct ones. We chose to allow
for one-word answers to each question instead of multiple-choice.
This way we make dictionary attacks, while not impossible, then
considerably more difﬁcult; they would be trivial if the space of
answers were small, consisting of choices A–E. Additionally, just
as for the applications above, a malicious client can manipulate the
solution checking code and related data.
Beneﬁts of RIPLEY: As the entire application is run on the client
side, integrity issues like bypassing solution checking, etc. can be
handled by Ripley as the checks are replicated on the server side.
RIPLEY cannot address conﬁdentiality concerns in general, though.
B. RIPLEY GUARANTEES
In this section we brieﬂy outline the integrity preservation prop-
erty that we intuitively described in Section 2. A full formalization
is subject for future work and will likely require modeling Volta ap-
plications in a small, well-controlled language that is easy to reason
about. For a given non-distributed program PO, there are three sep-
arate server-based versions of PO to consider:
• PO: Original Web 1.0 program that has not been tier-split;
• PS: Tier-split program C+S with C running within a full-
ﬂedged browser on the server; and
• PR: RIPLEY-replicated program C+S with replica C run-
ning within a RIPLEY emulator.
Let us emphasize that all these three variants of PO are executed
entirely on the server, only relying on input from the user. Let us
further assume that the program is connected to permanent database
store, and this store is the only form of persistent state the applica-
tion maintains. We are interested in ensuring that this store cannot
be affected by malicious client actions. Let us further assume that
the programs above do not have the forms of non-determinism de-
scribed in Section 5. We can then show the following.
Property: For any run of PO and PR given a stream of input
events he1, e2, . . . , eni, the sequence of SQL database calls issued
by PO and PR are exactly the same.
This property protects the integrity of persistent server-side state:
starting with the same database state, we will end up with the same
database state for both PO and PR. This is what we mean when we
say that RIPLEY restores the integrity guarantees to their Web 1.0
state. Given the same set of (untrusted) inputs communicated to the
program as well as assumptions of determinism, both the RIPLEY
and the original application will arrive at the same answer.
Proof of the Property above proceeds by showing that there is
a bi-simulation between PO and PS and another bi-simulation be-
tween PS and PR. This transitively makes PO and PR bi-similar,
which in particular implies the Property.
186