fork, it will come to a similarity much lower than 0.1 if there
are millions of blocks within the execution. In this case, if
the tracer does not correctly guess the destination basic block
of a control transfer, its subsequent guesses are wrong as well
because the branching instructions under analysis are different
from the actual execution, so the subsequent branches are
wrong. It is not the same as guessing a sequence of binary
bits at a ﬁxed juncture of execution. The result in Table V
shows Catcher’s output is actually close to the real execution.
TABLE V
SIMILARITY MEASURES
Target
Spyrix
Blackbox Express
kidlogger
Revealer keylogger
MyDoom
Ratos
HIV
Armadillo
Themida
WinUpack
UPX
Similarity
0.51
0.25
0.74
0.53
0.54
0.44
0.49
0.70
0.16
0.61
0.53
C. Evaluate Heuristics
To evaluate the contributions of each of the ﬁve heuristics
described in Section III-B, we run experiments to measure
the accuracy of Catcher without applying one of them at a
time. According to the results in Figure 7, on average all
the heuristics improve the precision, except Heuristic 5 (Lost
Trace Handling). Heuristic 1 and 3 might cause a slight drop
in recall. All of them effectively lead to a better f-score.
Authorized licensed use limited to: Tsinghua University. Downloaded on October 11,2021 at 09:25:25 UTC from IEEE Xplore.  Restrictions apply. 
335
Fig. 7. Average precisions, recalls and f-scores w/o different heuristics
Fig. 8. Normalized benchmark run times when Catcher is running.
Heuristic 5 is meant to re-synchronize Catcher and the target
execution by leveraging the stack. It is more beneﬁcial to recall
enhancement, meaning that more executed code blocks can be
traced by Catcher. The average recall in Figure 7 shows that,
although Heuristic 5 causes 0.4% drop in precision, the recall
is increased nearly by 20.7%.
D. Performance
TABLE VI
TIME COST OF DIFFERENT OPERATIONS
Operation
CR3 fetching
agent switching
memory reading
block probing
Time (µs)
3.9
6.9/0.7
1.7
0.8
1) Overhead: Table VI lists the tasks performed by the
analyzers and the agents in three phrases of Catcher. In the
prologue phrase, the analyzer fetches target’s CR3 by pid.
It takes around 3.9 µs on average. Reading 512 bytes of
memory costs around 5500 CPU cycles. The key to agent
switching is modifying the CR3 of them. When launching
the agent for the ﬁrst time and switching it to the target’s
memory address space, we need to use the obtained CR3 to
load the corresponding EPT. This takes more than 2,2000 CPU
cycles (6.9 µs in our experiment). We do not need to reload
EPT every time in trace phrase. An agent switching without
reloading EPT cost less than 0.7 µs. One probing on a basic
block costs 0.8 µs.
2) System: We measure the slowdown caused by Catcher
on SPEC2006 benchmarks [5]. We compare the performance
overheads with the baseline. The baseline refers to SPEC
CPU2006 benchmarks with no Catcher running. The nor-
malized performance cost on average is 2.89% as shown in
Figure 8.
We also measure its inﬂuence on memory and cache by
Cachebench [27]. It
incorporates benchmarks for different
cache operations like cache read, cache write, and cache
read/write/modify. It also tests on memset() and memcpy()
from the C library. Figure 9 shows the performance of cache
drops about 8.16% when Catcher is introspecting a process.
Fig. 9. Performance decline in CacheBench
VI. DISCUSSIONS
A. Multithreading
Multithreading enables a process to create several threads
that work in the same memory space. Shared memory address
space and non-sequential execution cause inconsistencies in
cache states. In other words, even with the same code and
same input, the cache states obtained vary from time to time,
so they cannot be utilized to infer the control ﬂow.
Luckily, there is no real multithreading in Linux. Linux
kernel creates Light Weight Process or LWPs to simulate
threads. A process containing multiple LWPs is known as a
multi-threaded process. Each thread is actually an independent
LWP. It has its own process identiﬁer, and can be scheduled by
the kernel like a normal process. To locate a thread, we get its
LWP through PS -Lf pid. Catcher can switch to the CR3
related to this LWP so that this thread can be analyzed.
VII. CONCLUSION
To summarize, we propose a novel out-of-VM introspection
technique called Catcher to trace a target process from scratch.
It utilizes CPU cache to reveal execution situations of the
target without
interrupting its execution. Due to its non-
intrusiveness and transparency, it introduces no side-effects
into the system and thus can be applied to anti-analysis
malware. According to our experiment, although it is not as
accurate as other intrusive analysis tools, Catcher still provides
a practical result. Its passive monitoring mode makes overhead
negligible. Introducing no environmental variability, Catcher
gains an advantage in analyzing malware with anti-debugging
techniques.
Authorized licensed use limited to: Tsinghua University. Downloaded on October 11,2021 at 09:25:25 UTC from IEEE Xplore.  Restrictions apply. 
336
ACKNOWLEDGMENT
We thank all
the reviewers for their valuable sugges-
tions. This article is partially supported by the Singapore
National Research Foundation under NCR Award Number
NRF2018NCR-NSOE004-0001 and National NSF of China
under Grant Nos. 61772266, 61431008.
REFERENCES
[1] Amir Aﬁanian, Salman Niksefat, Babak Sadeghiyan, and David Bap-
tiste. Malware dynamic analysis evasion techniques: A survey. ACM
Computing Surveys (CSUR), 52(6):1–28, 2019.
[2] Billy Bob Brumley and Risto M. Hakala. Cache-timing template attacks.
In International Conference on Advances in Cryptology-asiacrypt, 2009.
[3] Yueqiang Cheng, Zongwei Zhou, Yu Miao, Xuhua Ding, and Huijie
Deng. Robert. ropecker: A generic and practicalapproach for defending
against rop attack.(2014). In Proceedings of the 21th Annual Network
and Distributed System Security Symposium (NDSS’14), February 23-
26, 2014, San Diago, CA. Citeseer, 2014.
64
and
september
optimization
https://software.intel.com/sites/default/ﬁles/managed/9e/bc/64-ia-32-
architectures-optimization-manual.pdf.
Intel
reference manual,
architectures
URL:
Coorporation.
ia-32
2019.
[4] Intel
[5] CORPORATION. SPEC CPU2006 benchmark. https://www.spec.org/
cpu2006/.
[6] Franck De Go¨er, Sanjay Rawat, Dennis Andriesse, Herbert Bos, and
Roland Groz. Now you see me: Real-time dynamic function call
the 34th Annual Computer Security
detection.
Applications Conference, pages 618–628, 2018.
In Proceedings of
[7] Brendan Dolan-Gavitt, Tim Leek, Michael Zhivich, Jonathon Gifﬁn, and
Wenke Lee. Virtuoso: Narrowing the semantic gap in virtual machine
introspection. In 2011 IEEE symposium on security and privacy, pages
297–312. IEEE, 2011.
[8] Agner Fog. Instruction tables. Lists of instruction latencies, throughputs
and microoperation breakdowns for Intel, AMD and VIA CPUs. Last
updated 2011-06-08, 2011.
[9] Yangchun Fu and Zhiqiang Lin. Space traveling across vm: Automat-
ically bridging the semantic gap in virtual machine introspection via
In 2012 IEEE symposium on security
online kernel data redirection.
and privacy, pages 586–600. IEEE, 2012.
[10] Yangchun Fu, Junyuan Zeng, and Zhiqiang Lin. Hypershell: A practical
hypervisor layer guest os shell for automated in-vm management.
In Proceedings of the 2014 USENIX Annual Technical Conference,
Philadephia, PA, June 2014.
[11] Daniel Gruss, Raphael Spreitzer, and Stefan Mangard. Cache template
In 24th
attacks: Automating attacks on inclusive last-level caches.
{USENIX} Security Symposium ({USENIX} Security 15), pages 897–
912, 2015.
[12] David Gullasch, Endre Bangerter, and Stephan Krenn. Cache games–
bringing access-based cache attacks on aes to practice. In 2011 IEEE
Symposium on Security and Privacy, pages 490–505. IEEE, 2011.
[13] Mehmet Sinan Inci, Berk Gulmezoglu, Gorka Irazoqui, Thomas Eisen-
barth, and Berk Sunar. Cache attacks enable bulk key recovery on the
In International Conference on Cryptographic Hardware and
cloud.
Embedded Systems, pages 368–388. Springer, 2016.
[14] Gorka Irazoqui, Thomas Eisenbarth, and Berk Sunar. S $ a: A shared
cache attack that works across cores and deﬁes vm sandboxing and its
application to aes. In 2015 IEEE Symposium on Security and Privacy,
pages 591–604. IEEE, 2015.
[15] Gorka Irazoqui, Mehmet Sinan Inci, Thomas Eisenbarth, and Berk
Sunar. Wait a minute! a fast, cross-vm attack on aes. In International
Workshop on Recent Advances in Intrusion Detection, pages 299–319.
Springer, 2014.
[16] Gorka Irazoqui, Mehmet Sinan Inci, Thomas Eisenbarth, and Berk
the 10th ACM
Sunar. Lucky 13 strikes back.
Symposium on Information, Computer and Communications Security,
pages 85–96, 2015.
In Proceedings of
[17] Kaspersky. Virus.win32.hiv. Retrieved June 2020 from https://threats.
kaspersky.com/en/threat/Virus.Win32.HIV/, 2000.
[18] Mehmet Kayaalp, Nael Abu-Ghazaleh, Dmitry Ponomarev, and Aamer
In
Jaleel. A high-resolution side-channel attack on last-level cache.
Design Automation Conference, pages 1–6, 2016.
[19] Paul Kocher, Jann Horn, Anders Fogh, Daniel Genkin, Daniel Gruss,
Werner Haas, Mike Hamburg, Moritz Lipp, Stefan Mangard, Thomas
Prescher, et al. Spectre attacks: Exploiting speculative execution.
In
2019 IEEE Symposium on Security and Privacy (SP), pages 1–19. IEEE,
2019.
[20] FortiGuard Labs. W32/mydoom.mmm. Retrieved June 2020 from https:
//www.fortiguard.com/encyclopedia/virus/12110/w32-mydoom-m-mm,
2007.
[21] Moritz Lipp, Daniel Gruss, Raphael Spreitzer, Cl´ementine Maurice, and
Stefan Mangard. Armageddon: Cache attacks on mobile devices.
In
25th {USENIX} Security Symposium ({USENIX} Security 16), pages
549–564, 2016.
[22] Moritz Lipp, Michael Schwarz, Daniel Gruss, Thomas Prescher, Werner
Haas, Anders Fogh, Jann Horn, Stefan Mangard, Paul Kocher, Daniel
Genkin, et al. Meltdown: Reading kernel memory from user space. In
27th {USENIX} Security Symposium ({USENIX} Security 18), pages
973–990, 2018.
[23] Yutao Liu, Yubin Xia, Haibing Guan, Binyu Zang, and Haibo Chen.
Concurrent and consistent virtual machine introspection with hardware
In 2014 IEEE 20th International Symposium
transactional memory.
on High Performance Computer Architecture (HPCA), pages 416–427.
IEEE, 2014.
[24] Scott McFarling. Combining branch predictors. Technical report,
Technical Report TN-36, Digital Western Research Laboratory, 1993.
[25] Gary McGraw and Greg Morrisett. Attacking malicious code: A report
to the infosec research council. IEEE software, 17(5):33–41, 2000.
[26] Microsoft.
Acquiring
high-resolution
time
stamps.
https://docs.microsoft.com/en-us/windows/win32/sysinfo/
acquiring-high-resolution-time-stamps, 2018.
September 2020.
Online; accessed 9
[27] Philip John Mucci.
Cachebench.
http://icl.cs.utk.edu/llcbench/
cachebench.html.
[28] Vasilis Pappas. kbouncer: Efﬁcient and transparent rop mitigation. Apr,
http://www.cs.columbia.edu/∼vpappas/papers/kbouncer.
1:1–2, 2012.
pdf.
[29] Vasilis Pappas, Michalis Polychronakis, and Angelos D Keromytis.
Transparent {ROP} exploit mitigation using indirect branch tracing. In
22nd {USENIX} Security Symposium ({USENIX} Security 13), pages
447–462, 2013.
[30] Arun Raj and Janakiram Dharanipragada. Keep the pokerface on!
thwarting cache side channel attacks by memory bus monitoring and
cache obfuscation. Journal of Cloud Computing, 6(1):28, 2017.
[31] Deepa Srinivasan, Zhi Wang, Xuxian Jiang, and Dongyan Xu. Process
out-grafting: an efﬁcient” out-of-vm” approach for ﬁne-grained process
execution monitoring. In Proceedings of the 18th ACM conference on
Computer and communications security, pages 363–374, 2011.
[32] Eran Tromer, Dag Arne Osvik, and Adi Shamir. Efﬁcient cache attacks
on aes, and countermeasures. Journal of Cryptology, 23(1):37–71, 2010.
[33] H Wong. Measuring reorder buffer capacity. http://blog.stuffedcow.net/
2013/05/measuring-rob-capacity/, 2013. Online; accessed 9 September
2020.
[34] Yubin Xia, Yutao Liu, Haibo Chen, and Binyu Zang. Cﬁmon: De-
tecting violation of control ﬂow integrity using performance counters.
In IEEE/IFIP International Conference on Dependable Systems and
Networks (DSN 2012), pages 1–12. IEEE, 2012.
[35] Yuval Yarom and Katrina Falkner. Flush+ reload: a high resolution,
In 23rd {USENIX} Security
low noise, l3 cache side-channel attack.
Symposium ({USENIX} Security 14), pages 719–732, 2014.
[36] Pinghai Yuan, Qingkai Zeng, and Xuhua Ding. Hardware-assisted ﬁne-
In International Symposium on
grained code-reuse attack detection.
Recent Advances in Intrusion Detection, pages 66–85. Springer, 2015.
[37] Junyuan Zeng, Yangchun Fu, and Zhiqiang Lin. Pemu: A pin highly
compatible out-of-vm dynamic binary instrumentation framework.
In
Proceedings of the 11th Annual International Conference on Virtual
Execution Environments, Istanbul, Turkey, March 2015.
[38] Yinqian Zhang, Ari Juels, Michael K Reiter, and Thomas Ristenpart.
In Proceedings of
Cross-tenant side-channel attacks in paas clouds.
the 2014 ACM SIGSAC Conference on Computer and Communications
Security, pages 990–1003, 2014.
[39] Siqi Zhao, Xuhua Ding, Wen Xu, and Dawu Gu. Seeing through the
In 26th
same lens: introspecting guest address space at native speed.
{USENIX} Security Symposium ({USENIX} Security 17), pages 799–
813, 2017.
Authorized licensed use limited to: Tsinghua University. Downloaded on October 11,2021 at 09:25:25 UTC from IEEE Xplore.  Restrictions apply. 
337