## 2.OpenJDK 项目 Code Tools：实用小工具集OpenJDK 的 Code Tools 项目 \[2\] 包含了好几个实用的小工具。在第一篇的实践环节中，我们使用了其中的字节码汇编器反汇编器ASMTools\[3\]，当前 6.0 版本的下载地址位于 \[4\]。ASMTools的反汇编以及汇编操作所对应的命令分别为：    $ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class > Foo.jasm和    $ java -cp /path/to/asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm该反汇编器的输出格式和 javap的不尽相同。一般我只使用它来进行一些简单的字节码修改，以此生成无法直接由Java 编译器生成的类，它在 HotSpot 虚拟机自身的测试中比较常见。在第一篇的实践环节中，我们需要将整数 2 赋值到一个声明为 boolean类型的局部变量中。我采取的做法是将编译生成的 class文件反汇编至一个文本文件中，然后找到 boolean flag = true对应的字节码序列，也就是下面的两个。    iconst_1;istore_1;将这里的 iconst_1 改为 iconst_2\[5\]，保存后再汇编至 class文件即可完成第一篇实践环节的需求。除此之外，你还可以利用这一套工具来验证我之前文章中的一些结论。比如我说过class文件允许出现参数类型相同、而返回类型不同的方法，并且，在作为库文件时Java 编译器将使用先定义的那一个，来决定具体的返回类型。具体的验证方法便是在反汇编之后，利用文本编辑工具复制某一方法，并且更改该方法的描述符，保存后再汇编至class 文件。Code Tools 项目还包含另一个实用的小工具 JOL\[6\]，当前 0.9版本的下载地址位于 \[7\]。JOL 可用于查阅 Java虚拟机中对象的内存分布，具体可通过如下两条指令来实现。    $ java -jar /path/to/jol-cli-0.9-full.jar internals java.util.HashMap$ java -jar /path/to/jol-cli-0.9-full.jar estimates java.util.HashMap
## 3.ASM：Java 字节码框架ASM\[8\] 是一个字节码分析及修改框架。它被广泛应用于许多项目之中，例如Groovy、Kotlin 的编译器，代码覆盖测试工具Cobertura、JaCoCo，以及各式各样通过字节码注入实现的程序行为监控工具。甚至是Java 8 中 Lambda 表达式的适配器类，也是借助 ASM 来动态生成的。ASM 既可以生成新的 class 文件，也可以修改已有的 class文件。前者相对比较简单一些。ASM 甚至还提供了一个辅助类ASMifier，它将接收一个 class 文件并且输出一段生成该 class文件原始字节数组的代码。如果你想快速上手 ASM 的话，那么你可以借助ASMifier 生成的代码来探索各个 API 的用法。下面我将借助ASMifier，来生成第一篇实践环节所用到的类。（你可以通过该地址 \[9\] 下载6.0-beta 版。）    $ echo 'public class Foo { public static void main(String[] args) {  boolean flag = true;  if (flag) System.out.println("Hello, Java!");  if (flag == true) System.out.println("Hello, JVM!"); }}' > Foo.java
# 这里的 javac 我使用的是 Java 8 版本的。ASM 6.0 可能暂不支持新版本的 javac 编译出来的 class 文件$ javac Foo.java$ java -cp /PATH/TO/asm-all-6.0_BETA.jar org.objectweb.asm.util.ASMifier Foo.class | tee FooDump.java...public class FooDump implements Opcodes { public static byte[] dump () throws Exception { ClassWriter cw = new ClassWriter(0);FieldVisitor fv;MethodVisitor mv;AnnotationVisitor av0; cw.visit(V1_8, ACC_PUBLIC + ACC_SUPER, "Foo", null, "java/lang/Object", null); ... {mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, "main", "([Ljava/lang/String;)V", null, null);mv.visitCode();mv.visitInsn(ICONST_1);mv.visitVarInsn(ISTORE, 1);mv.visitVarInsn(ILOAD, 1);...mv.visitInsn(RETURN);mv.visitMaxs(2, 2);mv.visitEnd();}...可以看到，ASMifier 生成的代码中包含一个名为 FooDump的类，其中定义了一个名为 dump 的方法。该方法将返回一个 byte数组，其值为生成类的原始字节。在 dump 方法中，我们新建了功能类 ClassWriter的一个实例，并通过它来访问不同的成员，例如方法、字段等等。每当访问一种成员，我们便会得到另一个访问者。在上面这段代码中，当我们访问方法时（即visitMethod），便会得到一个MethodVisitor。在接下来的代码中，我们会用这个 MethodVisitor来访问（这里等同于生成）具体的指令。这便是 ASM 所使用的访问者模式。当然，这段代码仅包含 ClassWriter这一个访问者，因此看不出具体有什么好处。我们暂且不管这个访问者模式，先来看看如何实现第一篇课后实践的要求。首先，main方法中的 boolean flag = true; 语句对应的代码是：    mv.visitInsn(ICONST_1);mv.visitVarInsn(ISTORE, 1);也就是说，我们只需将这里的 ICONST_1 更改为ICONST_2，便可以满足要求。下面我用另一个类 Wrapper，来调用修改过后的FooDump.dump 方法。    $ echo 'import java.nio.file.*; public class Wrapper {  public static void main(String[] args) throws Exception {    Files.write(Paths.get("Foo.class"), FooDump.dump());  }}' > Wrapper.java$ javac -cp /PATH/TO/asm-all-6.0_BETA.jar FooDump.java Wrapper.java$ java -cp /PATH/TO/asm-all-6.0_BETA.jar:. Wrapper$ java Foo这里的输出结果应和通过 ASMTools 修改的结果一致。通过 ASM 来修改已有 class文件则相对复杂一些。不过我们可以从下面这段简单的代码来开始学起：      public static void main(String[] args) throws Exception {    ClassReader cr = new ClassReader("Foo");    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);    cr.accept(cw, ClassReader.SKIP_FRAMES);    Files.write(Paths.get("Foo.class"), cw.toByteArray());  }这段代码的功能便是读取一个 class 文件，将之转换为 ASM的数据结构，然后再转换为原始字节数组。其中，我使用了两个功能类。除了已经介绍过的ClassWriter 外，还有一个 ClassReader。ClassReader将读取"Foo"类的原始字节，并且翻译成对应的访问请求。也就是说，在上面ASMifier 生成的代码中的各个访问操作，现在都交给 ClassReader.accept这一方法来发出了。那么，如何修改这个 class 文件的字节码呢？原理很简单，就是将 ClassReader的访问请求发给另外一个访问者，再由这个访问者委派给 ClassWriter。这样一来，新增操作可以通过在某一需要转发的请求后面附带新的请求来实现；删除操作可以通过不转发请求来实现；修改操作可以通过忽略原请求，新建并发出另外的请求来实现。![](Images/6776c6e4ce887676b0de70bed99b49de.png){savepage-src="https://static001.geekbang.org/resource/image/2a/ce/2a5d6813e32b8f88abae2b9f7b151fce.png"}    import java.nio.file.*;import org.objectweb.asm.*; public class ASMHelper implements Opcodes {   static class MyMethodVisitor extends MethodVisitor {    private MethodVisitor mv;    public MyMethodVisitor(int api, MethodVisitor mv) {      super(api, null);      this.mv = mv;    }     @Override    public void visitCode() {      mv.visitCode();      mv.visitFieldInsn(GETSTATIC, "java/lang/System", "out", "Ljava/io/PrintStream;");      mv.visitLdcInsn("Hello, World!");      mv.visitMethodInsn(INVOKEVIRTUAL, "java/io/PrintStream", "println", "(Ljava/lang/String;)V", false);      mv.visitInsn(RETURN);      mv.visitMaxs(2, 1);      mv.visitEnd();    }  }   static class MyClassVisitor extends ClassVisitor {     public MyClassVisitor(int api, ClassVisitor cv) {      super(api, cv);    }     @Override    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature,        String[] exceptions) {      MethodVisitor visitor = super.visitMethod(access, name, descriptor, signature, exceptions);      if ("main".equals(name)) {        return new MyMethodVisitor(ASM6, visitor);      }      return visitor;    }  }   public static void main(String[] args) throws Exception {    ClassReader cr = new ClassReader("Foo");    ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);    ClassVisitor cv = new MyClassVisitor(ASM6, cw);    cr.accept(cv, ClassReader.SKIP_FRAMES);    Files.write(Paths.get("Foo.class"), cw.toByteArray());  }}这里我贴了一段代码，在 ClassReader 和 ClassWriter中间插入了一个自定义的访问者 MyClassVisitor。它将截获由 ClassReader发出的对名字为"main"的方法的访问请求，并且替换为另一个自定义的MethodVisitor。这个 MethodVisitor 会忽略由 ClassReader 发出的任何请求，仅在遇到visitCode 请求时，生成一句"System.out.println("Hello World!");"。由于篇幅的限制，我就不继续深入介绍下去了。如果你对 ASM有浓厚的兴趣，可以参考这篇教程 \[10\]。你对这些常用工具还有哪些问题呢？可以给我留言，我们一起讨论。感谢你的收听，我们下期再见。\[1\]\\\[2\]\\\[3\]\\\[4\]\\\[5\]\\\[6\]\\\[7\]\\\[8\]\\\[9\]\\\[10\]\![](Images/a500044f1e4938fb43719f802cba82d8.png){savepage-src="https://static001.geekbang.org/resource/image/2a/d5/2a62e58cbdf56a5dc40748567d346fd5.jpg"}
# 24 \| 字段访问相关优化在上一篇文章中，我介绍了逃逸分析，也介绍了基于逃逸分析的优化方式锁消除、栈上分配以及标量替换等内容。其中的标量替换，可以看成将对象本身拆散为一个个字段，并把原本对对象字段的访问，替换为对一个个局部变量的访问。    class Foo {  int a = 0;} static int bar(int x) {  Foo foo = new Foo();  foo.a = x;  return foo.a;}举个例子，上面这段代码中的`bar`方法，经过逃逸分析以及标量替换后，其优化结果如下所示。（确切地说，是指所生成的IR 图与下述代码所生成的 IR 图类似。之后不再重复解释。）    static int bar(int x) {  int a = x;  return a;}由于 Sea-of-Nodes IR的特性，局部变量不复存在，取而代之的是一个个值。在例子对应的 IR图中，返回节点将直接返回所输入的参数。![](Images/b1b38a29bb3423ff447d3df770010202.png){savepage-src="https://static001.geekbang.org/resource/image/14/5d/14c64d61e81b764253a2fc96795d095d.png"}**经过标量替换的`bar`方法**下面我列举了`bar`方法经由 C2即时编译生成的机器码（这里略去了指令地址的前 48 位）。      
# {method} 'bar' '(I)I' in 'FieldAccessTest'  
# parm0:    rsi       = int             // 参数 x  