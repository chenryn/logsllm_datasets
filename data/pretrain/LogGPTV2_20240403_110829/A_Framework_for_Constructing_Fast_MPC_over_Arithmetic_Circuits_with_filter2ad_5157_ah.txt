protocol (for semi-honest adversaries) always yields correct shares,
even when run in the presence of a malicious adversary. Speci(cid:27)cally,
the result is either a correct sharing of the product or of a di(cid:29)erent
(cid:27)eld element (depending on the adversary), but it is always correct.
Lemma 6.3. If [v1] and [v2] are correct and [v3] was generated by
executing the (semi-honest) multiplication protocol on [v1] and [v2]
in the presence of one malicious party, then [v3] is a correct sharing
of either v1 · v2 or of some element v ∈ F.
Proof. If the corrupted party follows the protocol speci(cid:27)cation
then [v3] is a correct sharing of v1 ·v2. Else, since the multiplication
protocol is symmetric, assume without loss of generality that P1 is
the corrupted party. Then, the only way that P1 can deviate from
the protocol speci(cid:27)cation is by sending an incorrect element ˜t1 to
the honest P2 instead of t1, and in this case P2 will de(cid:27)ne its share
to be (t2, ˜t1). Meanwhile, P3 de(cid:27)nes its share to be (t3, t2), since it
receives t2 from the honest P2. By Claim 6.2 the shares are correct,
since the (cid:27)rst element of P2’s share equals the second element of
P3’s share. Furthermore, the shares that P2 and P3 hold de(cid:27)ne the
secret v = ˜t1 + t2 + t3 ∈ F, as required.
(cid:3)
Using similar arguments as in Lemma 6.3, it can be shown that
the semi-honest multiplication protocol is also secure up to addi-
tive attack. However, we won’t be needing this property in this
instantiation as explained below.
Generating correlated randomness non-interactively. Generating
elements α1, α2, α3 ∈ F under the constraint that α1 + α2 + α3 = 0
can be done in an almost identical way as generating shares of
random values described above. In a set-up step, each party Pi
chooses a key ki and sends it to Pi +1. Then, in order to generate
correlated randomness, each party computes αi = Fki−1(id)−Fki(id)
using the two keys it holds (and after incrementing id); observe
that α1 + α2 + α + 3 = 0, but each party knows nothing beyond its
own α. Using this method, the parties can generate all the correlated
randomness needed at the cost of one exchange of keys.
The open and reconstruct procedures. We use the fact that the
protocols described so far guarantee that correctness of shares
is maintained even in the presence of a malicious adversary, to
construct these procedures in an e(cid:28)cient way.
The open([v]) procedure (the opening of a share to all parties)
works in the following way: Holding the share (ri , ri−1), each party
Pi sends the element ri−1 to party Pi +1. Then, upon receiving ri−2
(i.e., ri +1) from Pi−1, party Pi computes v = ri +1 + ri + ri−1. Note
that this does not guarantee that the parties will hold the same
correct value. However, if the sharing is correct, then we are guar-
anteed that one of the honest parties will hold the correct value,
and thus the parties can compare their views to detect cheating.
Let compareview(vi) be a procedure where each party Pi sends vi
to Pi +1. Then, Pi checks that vi = vi−1 and aborts if not. Adding
this comparison to the open procedure doubles the communica-
tion. However, in the protocol, we can reduce communication by
deferring all view comparisons to the end of the protocol, and then
compare a hash of all of the values to be compared throughout
the execution. This method of deferring comparisons to the end is
similar to the deferred MAC veri(cid:27)cation of the TinyOT and SPDZ
protocols [16, 18, 32]; we use this method throughout. Thus, we
conclude that the procedure requires each party to send 1 (cid:27)eld
element only per multiplication gate.
The reconstruct([v], i) procedure works by having party Pi−1
send ri−2 to Pi and party Pi +1 send ri +1 to Pi. Then, Pi checks that
ri−2 = ri +1. If not, it sends ⊥ and aborts. If yes, it computes v =
ri−2 + ri−1 + ri. This works since, if the corrupted party cheats and
sends the wrong value, then it will be detected by Pi. As before, this
procedure works only when [v] is correct. If this is not guaranteed,
then reconstruction can be carried out by both parties sending Pi
their entire share (at double the communication cost).
The share(v) procedure. We de(cid:27)ne this procedure in a similar
way to [19], relying on the fact that the protocol for generating
random shares provides correct sharings. First, the parties generate
a random sharing [r]. Then, they run reconstruct([r], i). Holding r,
the dealer Pi sends b = v −r to the other parties. Finally, the parties
run compareview(b) to ensure that the dealer sent them the same
value (recall that in the protocol we defer the view comparisons
to the end and then only send a single hash value, so this does not
require communication).If no ⊥ message was received, the parties
de(cid:27)ne their share of v to be [r] + b (as de(cid:27)ned above).
Since we are guaranteed that [r] is correct, then [v] = [r] + b is
also correct, assuming that the honest parties hold the same b as
ensured by running compareview(b).
6.2.3 Optimizing the Protocol - Reducing the Communication.
With the building blocks that we presented in the previous sub
section, the protocol is now completely de(cid:27)ned. However, we can
improve the performance even further, using an optimization that
is unique to the secret sharing scheme used in this instantiation.
Before proceeding, observe that the cost of the opening proce-
dure and the semi-honest multiplication protocol are identical (one
element sent per party). Thus, it is clear that in the three-party case,
Protocol 3.4 (triple veri(cid:27)cation based on opening shares) is cheaper
than Protocol 3.8 (triple veri(cid:27)cation based on multiplication), as
the former requires 3 openings whereas the latter requires 4 multi-
plications per gate. We now present an optimization that reduces
the number of openings in Protocol 3.4 from 3 to 2, reducing the
communication per multiplication gate by 1 (cid:27)eld element. Recall
that in Protocol 3.4 the parties compute a sharing [v], and then
open it and verify that it is a sharing 0. In addition, recall that in
the sharing scheme, each party Pi holds a pair (ri , ri−1). Thus, if
v = 0, then ri−1 + ri + ri +1 = 0 and so ri−1 + ri = −ri +1. Now, since
we are guaranteed that the parties hold a correct sharing of v (the
triples that are input to the multiplication protocol are correct and
all operations during the protocol maintain this property), the only
question that remains is whether [v] is a sharing of 0 or of some
other value in the (cid:27)eld. This can be veri(cid:27)ed by having each pair of
parties Pi and Pi +1 compare the values of ri−1 + ri and −ri +1. Thus,
it is possible to include these values in the view comparison hash
that is veri(cid:27)ed at the end of the entire protocol, instead of running
open([v]) at each multiplication gate. This single comparison can
be done e(cid:28)ciently by comparing the hash values of the strings that
hold the shares from all Protocol 3.4 executions. Speci(cid:27)cally, each
party Pi needs to hold two strings; in the (cid:27)rst string, it stores the
ri−1 + ri from the [v] shares it viewed, whereas in the second, it
stores −ri from these shares. The hash of the (cid:27)rst string is com-
pared with the hash value of party Pi +1, and the hash of the second
string is compared with the hash value of Pi−1. For completeness
we present the resulted veri(cid:27)cation protocol in Appendix C.
6.2.4 Pu(cid:29)ing It All Together.
The protocol. For the three-party setting based on replicated se-
cret sharing, we obtain a single protocol (unlike the Shamir case).
First, observe that using our sharing procedure presented above,
there is no need to run the input correctness-checking step. In addi-
tion, the parties run the optimized veri(cid:27)cation protocol explained
in the previous section. Finally, we add an additional step before
the output reconstruction, where the parties compare their views
by sending each other a hash of their views. This step comes with
constant small communication cost, and thus does not change the
cost per gate. The full protocol is presented in Appendix C.
E(cid:28)ciency. As generation of random shares is essentially free,
the cost of the protocol per multiplication gate involves two semi-
honest multiplications and two openings for veri(cid:27)cation. Thus,
1 + 3δ elements are sent by each party per gate, as both opening
and multiplication involves sending one element per party.
In large (cid:27)elds, where |F| > 2σ and δ = 1, we obtain that each
party needs to send only 4 (cid:27)eld elements per multiplication gate.
This therefore proves Theorem 1.3 from the Introduction.
Protocol version
replicated (3 party)
PRSS_GRR_open
van_GRR_open
van_DN_open
van_DN_mult
3
513
1229
1428
1999
3218
5
-
1890
2104
2661
4521
7
-
3056
3214
3463
5924
9
-
6719
4009
4426
7279
11
-
18024
5187
5694
8570
30
-
-
20855
15954
21437
50
-
-
45902
28978
34832
70
-
-
79655
44599
47379
90
-
-
124353
63522
58966
110
-
-
177621
83815
72096
Table 1: Execution time in milliseconds of the circuit with a 61-bit prime, for di(cid:29)erent numbers of parties. The best time for
each number of parties is highlighted.
7 EXPERIMENTAL RESULTS
We implemented our protocol in C++ and ran our protocols on
Azure in a single region with a ping time of approximately 1ms.
Each machine is a 2.4GHz Intel Xeon E5-2673 v3, with 4 cores and
8GB RAM. Each party was implemented with a single thread and
so each party utilizes only on a single core.
We implemented our protocol versions and ran extensive ex-
periments to analyze the e(cid:28)ciency of the di(cid:29)erent protocols for
di(cid:29)erent numbers of parties. All of our protocols scale linearly in
the size and depth of the circuit, and we therefore ran all of our
experiments on a depth-20 arithmetic circuit with 1,000,000 mul-
tiplication gates. We ran the circuit over two di(cid:29)erent (cid:27)elds, one
de(cid:27)ned by a 31-bit Mersenne prime and the other de(cid:27)ned by a 61-
bit Mersenne prime. Using these two di(cid:29)erent (cid:27)elds is of interest
since our veri(cid:27)cation protocol must be run twice (δ = 2) when
|F|  11), and that
veri(cid:27)cation with multiplication is preferred for a very large number
of parties (n > 70) since it is asymptotically linear.
Figure 1 below shows the comparison of the 4 di(cid:29)erent Shamir-
based protocols for 3 to 90 parties. The graph clearly demonstrates
the linear complexity of the van_DN_mult protocol, and thus it is
less e(cid:28)cient for a small number of parties but far more e(cid:28)cient
as the number of parties grows. In contrast, the PRSS protocol
increases exponentially, and the others quadratically (at di(cid:29)erent
rates). In order to more closely see the behavior of the protocols
for a small number of parties; see Figure 2 below.
Field size. As mentioned above, we ran experiments both for the
31-bit and 61-bit (cid:27)elds. As can be seen in Figure 3, the running
time is very similar when using a 61-bit (cid:27)eld (and taking δ = 1)
versus using a 31-bit (cid:27)eld (and taking δ = 2). This makes sense