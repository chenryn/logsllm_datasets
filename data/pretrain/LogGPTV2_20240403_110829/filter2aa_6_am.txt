Number(value)   (Invoked as a function, not as a constructor)
+value
我更偏向Number()方法，因为更直观。下面是一些例子：
11.2.2 parseFloat()
全局函数parseFloat()提供了另一种将值转换为数字的方法。不过，Number()通常是更好的选择，我们一会儿就能看到这一点。这段代码：
将str转换成字符串，去掉开头的空格，然后解析最长的浮点数字形式的前缀。如果没有这样的前缀（例如，在一个空字符串中），则会返回NaN。
比较parseFloat()和Number()如下。
对非字符使用parseFloat()的效率较低，因为在解析之前它会将参数强制转换成字符串。因此，许多被Number()转换成实际的数字的值被parseFloat()转换成了NaN：
ParseFloat()将空字符串解析成NaN：
parseFloat()会一直解析到最后一个合法的字符，这意味着最后得到的可能不是想要的结果：
parseFloat()会忽略开头的空格，并且在非法的字符（包括空格）前停止：
Number()会忽略开头和结尾的空格（不过其他非法的字符都会导致NaN）。
11.3 特殊的数字值
JavaScript有一些特殊的数字值：
两个错误值，NaN和Infinity。
两个零值，+0和-0。JavaScript有两个零，一个正零和一个负零，因为一个数字的正负号和数值是分开存储的。在这本书的大部分内容中，装作只有一个零，因为几乎不会在JavaScript中看到它们。
11.3.1 NaN
讽刺的是，错误值NaN（“not a number”的缩写）居然是一个数字：
这是由类似如下的错误产生的。
一个不能被解析的数字：
失败的操作：
一个运算数是NaN（这样可以确保，如果在一个较长的运算中发生了错误，可以在最后结果中看到）：
陷阱：检查一个值是否是NaN
NaN是唯一一个和自身不相等的值：
Array.prototype.indexOf也使用了严格相等（===）。因此不能通过该方法在数组中查找NaN：
如果你想要检查一个值是否为NaN，必须使用全局函数isNaN()：
不过，isNaN对非数字不起作用，因为它首先做的就是把这些值转换成数字。转换可能生成NaN，然后函数会错误地返回true：
因此，最好的办法是将isNaN和类型检查组合起来：
或者，你可以检查这个值是否和它本身不相等（因为NaN是唯一有这样特征的值）。不过这种方式较难理解：
IEEE 754指定了上述行为。如其7.11节“比较断言的细节”[2]标注：
NaN和任意值，包括它自身做比较，都是无序的。
11.3.2 Infinity
Infinity是一个错误值，指出了以下两种错误：一个大到无法表示的数字，或者除以了0。
Infinity比其他任意数字都大（除了NaN），类似的，-Infinity比其他任意数字都小（除了NaN）。因此，将它们作为默认值很有用——比如，需要一个最大值或最小值时。
错误：巨大的数字
一个数字的大小是由它的内部表示决定的（正如11.4“数字的内部表示”讨论的内容），即以下算术的乘积：
尾数（一个二进制数字1.f1f2...）
2的指数幂
这个指数必须在−1023到1024之间（开区间）。如果指数太小，数字会变成0。如果指数太大，则会变成Infinity。21023还能被表示出来，但是21024就不能了：
错误：被0除
当一个数被0除的时候会产生一个错误值Infinity：
Infinity的运算
如果尝试用一个Infinity“抵消”另一个Infinity的时候会得到错误的结果NaN：
如果你试图得到大于Infinity的数，得到的仍然会是Infinity：
检查Infinity
严格相等和宽松相等都适用于Infinity：
另外，全局函数isFinite()可以检查一个值是否是实际的值（既不是Infinity也不是NaN）：
11.3.3 两个0
由于JavaScript数字的数值和符号是分开存储的，因此每一个非负数都有一个负值，包括0。
这个现象的基本原理是只要用数字化的方式表示一个数字，它可以变得足够小以至于难以和0区分开，这是因为编码无法精确地将这些差异表示出来。因此一个有符号的0可以使你记录它是“从哪个方向”接近0；即，在一个数字被当作0之前它的符号是什么。维基百科上面很好地总结了有符号0的利弊（http://en.wikipedia.org/wiki/Signed-zero）：
据称在IEEE 754中引入了有符号0可以更容易达到某些重要问题中对数字准确度的要求，特别是在计算复杂的初等函数时。另一方面，有符号0的概念和大部分数学领域（以及大部分数学课程）中的一般假设是相反的，那里的负0和0是同一个值。不过，允许负0也会成为程序错误的一个来源，因为软件开发者没有意识到（或者可能是忘了）这一点，尽管这两个0在数值比较上面行为是一样的，但是它们的二进制是不一样的，并且在某些操作上面有不同的结果。
最佳实践：装作只有一个0
JavaScript在努力隐瞒它有两个0的事实。因为通常情况下这一点无关紧要，建议你就当这里只有一个0。我们来解释这种错觉是如何维持的。
在JavaScript中，你写的0通常指的是+0。但是-0也会简单地显示成0。这正如在浏览器命令行或者Node.js交互环境中所看到的：
这是因为标准的toString()方法将这两种0都转换成了同一个'0'：
等号也不会区分这两个0，即使是===：
Array.prototype.indexOf使用===来查找元素，依然是这个结果：
比较运算符也认为这两个0是一样的：
区分两个0
怎样才能真正地看到这两个0是不同的呢？你可以用0来除一个数（-Infinity和+Infinity可以通过===来区分）：
另一个执行除以0的方法是通过Math.pow()（参见21.2“数值函数”）：
Math.atan2()（参见21.3“三角函数”）也能显示这两个0是不同的：
判断两个0不同的权威方法是除以0。因此，一个用来检测-0的函数大概会是这样的：
该函数的用法如下：
11.4 数字的内部表示
JavaScript的数字是64位精度的，也叫作双精度（某些编程语言中的double类型）。数字的内部描述基于IEEE 754标准。64位按照表11.2所示分布在数字的符号、指数和分数上。
表11.2
符号
指数[-1023, 1024]
分数
占1位
占11位
占52位
第63位
第62～52位
第52～0位
一个数字的值根据如下方程计算得到：
前置的百分号（%）代表中间的数字采用二进制计数法编写：一个1，后面是一个二进制的点，跟着一个二进制的分数——也就是分数（一个自然数）的二进制数字。以下是这种表示法的一些例子：
+0，−0和3的编码可以解释如下。
±0：给定分数的前缀始终是1，不能用于表示0。因此，JavaScript通过分数0和特殊的指数−1023来给0编码。符号可以是正或者负，这代表JavaScript有两个0（参见11.3.3“两个0”）。
3：分数的第51位是最重要的一位。这一位是1。
特殊的指数
前面提到的数字表示法被称为规格化。在这种情况下，指数e的范围是−1023＜e＜1024（不包括上下界）。−1023和1024就是特殊的指数。
1024是给错误值用的，比如NaN和Infinity。
−1023是给这些值用的：
0（如果分数是0，这种情况上文已经解释了）。
接近0的很小的数字（如果分数不是0）。
为了使这两种情况都可用，这里用到了一种不同的，被叫作非规格化的表示方法。
作为比较，用规格化表示的最小（最接近于0）的数是：
可以看到非规格化的数字更小，因为没有开头前一位的数字1。
11.5 处理舍入错误
JavaScript的数字通常是作为十进制的浮点数字输入的，但是在内部它们其实是以二进制的浮点数字来表示的。这就会导致精确度问题。要理解原因，让我们先忘记JavaScript内部的存储格式，然后大体地看看十进制浮点数字和二进制浮点数字可以表示什么样的分数。在十进制系统中，所有的分数是一个尾数被10的幂次相除的结果：
因此，在分母位置上只有10的幂次。这就是为什么1/3不能精确地表示成一个十进制的浮点数字——因为没有办法将一个3放到分母上。二进制的浮点数字在分母位置上只有2的幂次。我们来看看可以表示哪些十进制浮点数字以及哪些二进制浮点数。如果分母上面只有2的幂次，那么这个十进制可以被表示：
0.5dec =  =  = 0.1bin
0.75dec =  =  = 0.11bin
0.125dec =  =  = 0.001bin
其他的分数都不能被精确地表示，因为它们在分母上还有除了2的其他数字（通过初等因子分解）：
0.1dec =  = 
0.2dec=  = 
一般看不出JavaScript内部有没有存储0.1。但是你可以通过乘以一个10的高次幂来查看：
如果你把两个不精确的数相加，有时候结果会不精确到可以直接看到偏差：
另一个例子：
由于舍入错误，最佳实践是不要直接比较非整数。取而代之，将边界错误的上界考虑进来。这个上界叫作机器精度 （http://en.wikipedia.org/wiki/Machine_epsilon）。对于双精度一个标准的精度值是2−53：
epsEqu()能确保常规比较不充分时结果是可靠的：
11.6 JavaScript中的整型
正如前面提到的，JavaScript只有浮点数字。整型在内部有两种表现形式。第一，大多数的JavaScript引擎将一个足够小的没有十进制分数的数字存储成一个整型（比如，31位数字），并将这种表示形式持续尽可能长的时间。如果这个数字的大小增加得太大或者出现了十进制的分数，它们就不得不回到浮点的表示形式。
第二，ECMAScript规范中有整型运算符，即所有的按位运算符。这些运算符将它们的运算数转换成32位的整型，再返回32位整型。根据规范，整型指的是没有十进制分数的数字，32位指的是在一个确定的范围内。对于引擎来说，32位整型指的是通常可以引入或者维持一个实际的整数（没有浮点）表示方式。
11.6.1 整型的范围
在JavaScript中，下面这些整型的范围是十分重要的。
安全整型（参见11.6.3“安全的整型”），JavaScript支持的最长的实用整型范围是：
53位加一个符号，范围（−253, 253）
数组索引（参见18.3“数组索引”）
32位，无符号
最大长度：232−1
索引的范围：[0, 232−1]（不包括最大长度！）
按位运算符（参见11.9“位运算符”）
无符号右移运算符（>>>）：32位，无符号，范围[0, 232]
其他的所有按位运算符：32位，含一个符号，范围[−231, 231]
“字符码”，UTF-16码以数字组成单元：
可以被String.fromCharCode()接受（参见12.8“字符串构造器方法”）
可以被String.prototype.charCodeAt()返回（参见12.10.1“提取子字符串”）
16位，无符号
11.6.2 将整型表示为浮点数字
JavaScript只能处理最大至53位的整型值（52位的分数加一个来自指数的间接位；详见11.4“数字的内部表示”）。
表11.3解释了JavaScript怎样将53位的整型表示成浮点数字。
表11.3
位数
范围
编码
1位
0
（参见11.4“数字的内部表示”）
1位
1
%1×20
2位
2-3
%1.f51 × 21
3位
4−7=22−(23−1)
%1.f51f50 × 22
4位
23− (24−1)
%1.f51f50f49 × 23
...
...
...
53位
252− (253−1)
%1.f51...f0 × 252
没有固定的比特序列来表示整数。取而代之，尾数%1.f在指数前面，因此开头的数字1在正确的位置上。在某种程度上，指数记录了当前使用的分数的位数（剩下的位数是0）。意思是对于2位数，我们用分数的1个数字，对于53位数，我们用到了分数的所有数字。此外，我们可以将253表示成%1.0 × 253，但是对于更高位的数字就有问题了（如表11.4所示）。
表11.4
位数
范围
编码
54位