个Q的初始事件，而不是P的事件，来启动Q，即
为避免一些问题，我们规定αP不能包含√。
的迹，再跟上Q的迹。有
而且P一且中断，就不再继续。故（P^Q）的迹就是P至中断点
合不要求P的终止性。当Q的第一个事件一出现，P就被中断；
个运算对象组合。实施为
否则，由第一个运算对象参予第一个事件，余下的部分再和第二
若第一个运算对象终止，则顺序组合的行为同第二个运算对象；
L1
于它以后的动作则无关紧要。合
5.3.3实施
sequence(P,Q)= if P("SUCCESS)≠"BLEEP thenQ
(x:B→P(x))~Q=Q(x:B→(P(x)^Q))
下面的法则说明，是环境决定Q何时启动；它通过选择一
SKIP可由下述进程来实施，它只接收符号"SUCCESS。至
（P^Q）被R中断同于P被（Q~R）中断，有
在本节中，我们定义另一种顺序组合（P^Q)，这种顺序组
traces(P~Q)={s^t|s∈traces(P)At∈traces(Q))
a(P^Q) =αPUaQ
else Ax.if P(x) = "BLEEP then "BLEEP
U{(s,X)|s∈ divergences(P;Q))
5.4
中
else sequence (P(x),Q)
169
---
## Page 193
-170
在确定性模型中，这个法则就唯一地定义了算子的含义。但在非
5.4.1
论确定性的保持问题，我们扩充原有的选择算子。设B，合
控制，这样就不会引入非确定性，还可简化有关推理。为着重讨
断进程的宇母表。中断现象应该是环境可观察到的，而且可由其
分配，有
是个的单位元，即
STOP 被某个进程中断，则只会出现中断进程的动作。故STOP
L1 (PQ)/(s^<>)=Q
其中的Q是用于从灾难中复元。注意，算子&和事件&是不同的。
在发生灾难前，行为如P，然后如Q的进程，定义为
件；形式地说
的缩写，类似地可定义运算对象更多的情形。
作为
L.5
安全的。表示为
最后，不能中断一个发散进程，由发散进程中断其它进程也是不
L4A
中断算子同时执行其两个运算对象，故它对非确定性选择算子可
L3 PASTOP=P=STOP^P
.4B
CHAOS~P=CHAOS=P△CHAOS
第一个法则是将算子的非形式叙述形式化
命符号&表示一种灾难性中断事件，自然P不应发生这种事
本节的余下部分中，都规定中断进程的初始事件不属于被中
P^(QR)= (PQ)(PR)
(QR)~P=(Q~P)(R~P)
灾难
(x: (BU {c})-→(if x = c then Qelse P(x)))
PQ=P~(-→Q)
(x:B→P(x)[c-→Q)
&∈αP
sEtraces(P)
---
## Page 194
这条法则没能唯一地定义P，例如 RUN 也一样满足这条法则。
L1 P/s^=P 
这个想法是由AlexTeruel 提出的。
的博奕。这样就可以，不考虑重新启动功能，先独立地设计博奕
进展情况，可能要求重新启动。为此，在键盘上应提供-个新的
奕，其对手是人，通过选用键盘上的按键实现双方的交互作用
P也是一个循环进程（见1.8.3节）。
递归式中X都卫以&，故是卫式递归式。即使P不是循环进程，
每次出现后再山P从头执行。这种进程称为可再启动进程，由
5.4.2重新自动
P，然后使用上面定义的算子，将其转换成可重新启动的博奕P。
专用链（&）：在博奕过程中，·一按下此键，就可重新启动一次新
（参见1.4节中的雨数interact）。有时，游戏者不满意于博奕的
简单递归式定义为
程，&∈aP。我们定义户为进程，在&出现前似P动作，而且在
义了这个算子对确定性进程的效用。
这条法则对于确定性进程而言是多余的，第一条法则已唯一地定
L2(x:B→P(x))Q=(x:B-→(P(x)Q)1-→Q)
步动作。它表现为&如何对一自后分配的
确定性范围内，要唯一地定义它，还需陈逃它的严格性和可分配
性。
P的非形式定义可用下列法则表示
使用重新启动算子不光为了从灾难中复元。一个进程用于博
.对灾难的一种可能的反应是重新启动原来的进程。令P是进
第二条法则更清晰地说明这个进程的第-·步动作及其后的各
αp=αPU{}
P=μX.(P2X)
=P(P(P&))
s∈traces(P)
171
---
## Page 195
5.4.4备查点
绝不愿意失去你在编辑程序中已处的位置，反之亦然。
同时玩这两个游戏的进程记作（P③Q），可由下列法则很清楚地
状态可以保存起来，一且另一个博奕被中断后，就可继续前一个。
任意时刻都可中断；但它也不完全象中断，被中断的博奕的当前
导致P和Q的交替进行。这种现象有点象中断，正在进行的博奕
回地和几个弱手对奕。为此，我们再提供一个新按键，用它可
5.4.3交替
P是满足L1的最小的确定性进程
查点：若无备查点，
遇到满意的状态时，就可按下此键。在出现&时，恢复最近的备
可合人满意的。这种状态叫作备查点。我们再提供一个新按键：
据。比较好的办法是返回到系统某个近期状态，而且这个状态叉
可能就从初始状态开始重新执行P，但丢失丁辛苦积累的系统数
使用编辑程序时，你可能要转到help程序，寻求系统帮助，但你
应可交替使用各种系统功能，故需要类似的机制。例如，当你在
L4(x:B--P(x))③Q=(x:B--(P(x)③Q)|③-(Q③P))
画可由上述法则推导出来；它表现为是如何对→反向分配的
我们要的是满足L2和L3的最小进程。这个算子的更构造式的划
L1
描远
人想同时玩这两个游戏，交替地进行博奕，如同象棋大师同时巡
L3
2
172
@E(a(P@Q) -αP -aQ)
设P和Q是逃行博奕的进程。其方式已陈述于5.4.2节中；有
进程P刻画长生存期的数据库系统。一受雷击（&），最坏的
交替算子不光可用于博奕游戏。一个“友善”操作系统中，
(P③0)K@>=(Q③P)
. (P@Q)/s=(P/s)@Q
，则恢复初始状态。设和&不属于P的字母
若 sEtraces(P)
---
## Page 196
5.4.5多重备查点
己。他就按一下键，贮存当前的位置，然后再做试探，若试探
度上依赖于机器和应用的;合人高兴的是所用的数学是如此简单。
的当前状态。从经济上考虑，系统实施者总是设法使当前状态和
将当前状态拷贝作新的备查点；出现，备查点拷贝回去作为新
状态贮存在便宜又耐久的介体上，如磁盘或磁带上。出现，就
赔 Ch2(P,Q) = (x:B-→Ch2(P(x),Q)1 →Ch2(Q,Q)
13
之前，则系统就重新启动，详见T面的法则
程，
由不让定义系统 Meh（P)，使其保存自启动以来的所有备查点。
这就要求系统保留两个或更多个近期备查点。原则上说，没有理
失败，就用&键恢复状态。
备查点状态二者间共享尽可能多的数据。这种优化问题是很大程
况。这时，就会删去最近的备查点，而回阙到前面一个备查点。
时，
表，
若P=（x:B→P(x))
，Q是等待恢复的最近的备查点。若灾难出现在第一个备查点
人们可能想先探究可用的策略，但不愿在探求过程中累及自
法则L4对实际的实施方法很有启发，实际实施时，将备查点
Ch(P) =Ch2(P,P)
定义进程Ch(P)，其行为如P，但对这两个事件以适当的回
在使用可备查的系统Ch（P）时，可能发生备查点出错的情
备查点的想法是由 Ian Hayes 考察和研究的。
备查点算子不仅可用于大规模数据率系统。在做困难的博类
Ch（P）可由两元算子Ch2（P,Q）定义，其中P是当前的进
Ch(P)/(s^)=Ch(P/s)
Gh(P)/(s^)=Ch(P)
Ch（P）的非形式定义可非常简洁地由下列法则形式化
[@→Ch2(P,P))
s∈traces(P)
s∈traces(P)
173
---
## Page 197
L3 Mch(P) =μX,Mch2(P,X)
L2Mch(P)/s<><>=Mch(P){s
出现在②之后的，删去自最近的②以来（包括这个②本身）所
L1Mch(P)/s^<>=Mch(P)
出现在之前的，使进程从头开始
的状态。我们仍要求
每出现，就返回到最近的的前面的那个状态，而不是其后面
替算子为例，出5.4.3节L4，可有实施
5.4.6
备查点是很费钱的。
L4中的递归式很精巧，但当备查点的个数很大时，实际实施多重
则 Meh2(P,Q)=(x:B-→Mch2(P(x),Q)
L4若P=(x:B→P(x))
在出现时，当前状态就压入堆栈，出现&，恢复整个堆栈。有
值是P的无穷多个拷贝
中P是当前进程，Q是存有等待恢复的备查点的堆栈。堆栈的树
发生的一切事情
174
中断的各种实施版本都基干算子对→的自后分配法则。以交
Mch（P）的更清楚的刻画需使用二元算子Mch2（P,Q)，其
实施
alternation(P,Q)=
else if P(x)="BLEEP then "BLEEP
Ax.if x=  then alternation(Q,P)
=Mch2(P,Mch2(P,Mch2(P,--)))
=Moh2(P,Moh(P))
[→Mch2(P,Mch2(P,Q))
aMch(P)-aP={,′}
[→Q)
(s(aP -{O}))~t∈traces(P)
S∈traces(P)
---
## Page 198
实际实施中，一-般都设置约束条件，规定递归深度的界限。设计
后，使--些存储空间获释，但这不能解决根本问题。在递归式的
在执行这个函数时，所用的存储量随备查点的个数成比例地增
其中Mch2(P,Q)=
Mch(5.4.5节L3,L4)的实施更合人惊奇
表
变元的初值不变。赋值本身的含义可定义为
也是一个进程，其行为如P，但×的初值为表达式e的初值。其余
变元，e是表达式，P是进程，则
见的记法。
值、条件和循环。为简化某些法则的形式表示，将定义一些不常
但用递归式来表示这种设计就不很漂亮了。
者世应对保存的备查点的个数作出限制，将早期的备查点删去。
长；存储空间很快用完。尽管可用废料搜集程序，在每次出现
传统计算机程序设计最本质的特征是赋值。若x是一个程序
单个赋值可容易地推广为多重赋值。令x代表不同的变元的
本节中将引入传统的顺序程序设计中最重要的算子，即赋
else if P(x)="BLEEP then"BLEEP
else if x=  then Mch2(P,Mch2(P,Q))
Ax,if x=  then Q
()=(
(x:=e)=(x:=e,SKIP)
x=xo，x1.*,x-1
5.5
(x=P)
else Mch2(P(x),Q)
值
else alternation(P(x),Q)
175
---
## Page 199
将写成
简洁。类似的原因，传统的循环
不同于
赋值，故若y在表达式9中出现，则
将e;的初值赋予x(0≤i≤n-1)。注意，所有的e;的求值先于任意
假设这两个表的长度相同，则
X2行为如CT的进程
X1设计进程，其行为如CT（1.1.4节X2)。合
D1 b*Q=μX.((Q;X)tbSKIP)
如Q。这个记法是新颖的，比传统的记法
是一个进程，当b初值为真时，其行为如P；b初值为假时，行为
e代表表达式的表
变元n记载了计数器的当前值。
可用递归式定义为
176
命b是取值为布尔值（true或false）的表达式，P和Q是进程，
n=0(up→(n:=n+1,X)|down→(n:=n-1;X))
举例 
X1 =μX.(around→X|up→(n:=1;X))
P4bQ
，e=.,…*,n-1
if b then P else Q
while b do Q
y,2=f,9
y=f; z=9
n:=0;X1
x=e
b*Q
· (P if b else Q)
口
---
## Page 200
使用这些法则，可以将一系列的赋值转化为对所有有关变元的表
L4.若x,y，z是长度和e，f,9分别相同的表，