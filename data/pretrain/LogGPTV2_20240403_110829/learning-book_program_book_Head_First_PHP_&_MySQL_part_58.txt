规范你的数据
努力达到规范化
重新设计Mismatch数据库来消除重复数据，并采用一种合理
规范化是指设计数据库
一致的方式分解和连接表，这个过程就称为规范化。规范化
来减少重复数据，并改
（Normalization）是一个相当深奥的数据库设计主题，可能让人心生
恐惧。不过并不一定那么复杂。我们可以根据规范化基础知识了解
进数据之间的关系。
一些足够简单的数据库设计技术，与凭空猜测应当如何建立数据布
局相比，利用这些数据库设计技术可以建立更好的MySQL数据库。
以下是一些非常宽泛的步骤，可以采用这些步骤开始我们的数据库
设计过程，这会很自然地得到一个更“规范”的数据库：
1.选择对象，即希望用表来描述的对象。
你希望表描述的主要对象
是什么？
2.建立使用表时关于对象所需了解的一个信息列表。
<你如何使用这
个表？
3.使用这个列表，将对象的有关信息分解为组织表时可用
的多个部分。
如何最容易地
查询表？
规范化的一个基本概念是原子数据的思想，就是在给定数
据库用途的前提下，分解为最小形式的有意义的数据。例
8
原子数据就是
如，Mismatch数据库中的first_name和last name列从某种
意义上讲就是原子的，因为与一个name列相比，它们能够更进
分解为给定数
一步分解用户的名字。这在Mismatch中很有必要，因为我们希望
据库所需最小
能够单独按用户的名来引用一个用户。
形式的数据。
可能并不一定总是需要应用将全名分解为单独的名和姓列，不
过，在这种情况下，name本身可能已经是原子的。所以将一个
表描述的“对象”分解为多个部分时，应当考虑将如何使用数
据，而不只是它表示什么。
462第8章
---
## Page 499
控制你的数据，世界在你手中
规范化时，要按原子来考虑
为了帮助把你的数据库设计想法付诸实际，可以对你的数据问一些针
让数据具有原
对性问题，这很有帮助。这些问题有助于确定如何将数据放在一个表
子性是创建一
中，以及是否已经分解为适当的原子表示。没有人认为分解原子数据
个规范表的第
很容易，不过以下列出的问题可能对你会有帮助。
一步。
1.表要描述的对象是什么？
你的表要描述看到外星人的记
录，email列表订购，视频游戏高分
还是毫无希望的浓漫敬事？
2.如何使用表来
得到你的对象？
适当设计表以易于
查询！
3.
列是否包含原子数据
确保数据尽可能短小。
以保证查询简短而且切中要点？
thereareno
DumbQuestions
个高效表所需的最小部分，而不是尽可能小的部分。
到外星人的记录有一个街道地址列，你可能希望把这个街
不要矫枉过正而将数据过分分解。如果不需要额外的列，
道地址分解为两列：号码和街道。这样一来，就可以确保
就不要只是为了分解数据而增加列。
号码列中只存储数字。
原子数据还允许更高效地完成查询，因为查询更容易编写，
而且运行时间更短，如果存储的数据量很大，这种时间的
节省累积起来也相当可现。
你现在的位置
463
---
## Page 500
规范化的优点
到底为什么要规范？
也许你的数据库只是中等规模，所以你可能认为这些关于原子数据和
规范化很有好
规范性的讨论有些大材小用，没有必要。如果是这样，那么请你想想
处，具体来说
看，如果你的Web应用飞速发展，成为下一个“热门应用”会发生什
么情况。如果你的数据库规模在非常短的时间内呈跳跃式发展，以至
就是数据库的
于暴露设计中可能存在的弱点，又会怎么样？所以最好为你的Web应用
规模和速度会
配备全新“装备”，而不要试图只是对数据做一些修修补补。如果只
得到改进。
是进行修补，很快你就发现无法控制局面。你肯定会迫切需要规范性。
如果你还是不以为然，或者仍然坚持固步自封，下面再给出两个完成
数据库规范化的强有力的原因：
1.规范表不会有重复数据，远会编小数
据库的规模。
庞大、臃肿的数据库很不好…
规范化数据库往往比
设计不当的数据库规模
小得多。
这就是说：“规模
就是金钱！
.高效的小数据库则很好！
2.要搜索的数据更小，查询也会更快
嗯，请等等，可能这就是
陷入重复数据中的慢查询很不好
说“时间就是金钱！
对于数据库来说，通
度快总是好事。
.高速的查询则很好！
464
第8章
---
## Page 501
控制你的数据，世界在你手中
规范化数据库的3大步骤
你已经对数据有所考虑，现在已经很清楚为什么需要规范化，但是仅
规范化一个数①
仅有这些基本思想还不够。你真正需要的是一组简洁的规则，可以对
据库需要严格
任何数据库应用这些规则来确保规范性这类似于一个逐条检查的
2
清单，可以用来确保一个数据库有足够的规范性。下面我们就开始吧。
地遵循一系列
①确保列具有原子性。
设计步骤。
要让一个列真正做到原子性，该列中就不能有数
据类型相同的多个值。类似地，也不能有多个有：
相同数据类型的列。
saleyTV,
2每个表有自己的主键。
olinyTV,
主键对于确保唯一地访问表中的数据非常重要。
主键是一个列，理想情况下是数值数据类型，这
样可以尽可能高效地完成查询。
多个有相同数据类型的值在同一个列
中，而且这里还有多个列包含相同的数
如果没有主键，就没有
据.…….问题很严重！
办法确保这个表中行的
唯一性。
③确保非键的列不相互依赖。
这是规范化数据库时最有难度的一个需求，这一
条并不总是要求严格遵循。你需要更仔细地查看
一个给定表中的数据列相互之间的关系。基本思
想是修改一个列的值不应要求同时对另一个列
做出修改。
假想的Z列依赖于city和state列.这说明修改一
个列同时还需要修改其他的列。为了解决这个
问题，需要将用户的位重分解到单独的表，以
SC
乙P编码作为主键。
51ld
GA
你现在的位置
465
---
## Page 502
规范化mismatch数据库
Mismatch数据库需要规范化来解决重复类别名的问题。给定现有的数据库结构，简要
ExeRciSe
画出一个能解决重复类别问题的改进设计，以消除数据输入错误的风险。对设计做出
标注，解释它是如何工作的。
mismatch_user
user_idO
username
password
join_date
first_name
last_name
mismatch_response
gender
mismatch_topic
birthdate
response_idO
topic_id
city
response
name
state
user id
category
picture
topicid
466
第8章
---
## Page 503
控制你的数据，世界在你手中
thereareno
DumbQuestions
题？
将mismatch_user表与这个表关联。所以可以创建一个名为mismatch_
location的表，其中有一个名为location_id的主键，另外还有一些列存
储用户的地址信息，比如所在的城市（city）和州（state）。然后将city和
state列从mismatch_user删除，并代之以一个location_id外键。这样
问题就解决了！这个设计之所以能奏效，是因为location_id列实际上使用
了ZIP编码作为主键，从而消除了非键列依赖问题。
多工作。这确实有必要吗？
因为原子数据和主键对于任何好的数据库设计来说都至关重要。第3步则需
要折表考虑，你要面对一个完美数据库设计的诱惑，同时还要正视一个应用
实际所需的现实性，必须在这二者之间做出衡量。对于Mismatch的city/state/
ZIP问题，出于简单性考虑，即使存在这个问题可能也可以接受。这绝对不是
一个能够轻松做出的决定，另外很多对数据库坚持理想主义的人始终认为必
须严格遵循所有这3个规范化步骤。好在ZIP编码列纯粹是假想的，它并不真
正是mismatch_user表的一部分，所以不用对它太过担心。
满足第3个规范化步骤吗？
RT
数据。取出城市和州而没有ZIP编码存在一个问题，你必须以某种方式在这些
表中填充每一个存在的城市和州。否则用户肯定会拼错某些城市而最终得到
有问题的数据。这个例子很好地表明：有些情况下必须对严格规范化的好处
和实际应用的现实性做认真的权衡。
要解决所有这些问题，一种有意义的解决方案是在mismatch_user表中使
用ZIP编码，而不是城市和州，然后根据需要从一个静态表或另外某个web服
务查找城市和州。对于我们目前的要求来说，这过于复杂，所以下面仍使用
city和state列。
你现在的位置
467
---
## Page 504
mismatch数据库-
一现在已经规范化
Mismatch数据库需要规范化来解决重复类别名的问题。给定现有的数据库结构，简要
xeRciSe
画出一个能解决重复类别问题的改进设计，以消除数据输入错误的风险。对设计做出
SoLUtiON
标注，解释它是如何工作的。
新的类别表独立于主题存储
了类别名，从而消除了兄余
mismatch_user
数据。
OP!osn
Mismatch数据库
的其余部分不
username
mismatch_category
受类别/主题改
password
变的影响。
categoty_id
?
join_date
name
first_name
last_name
mismatch_response
gender
mismatch_topic
birthdate
MOP!osuodsou
topic_idO
city
response
name
state
user id
zategory
picture
topic id
catesory_id
并非在每个主题行中存储具体
要记住，mismatch_tesponse表
新类别表中的每一行都与主题
的类别名，现在只存储一个
是一个联接表，将用户与其
表中的主题存在一种一对多的
引用（3D）.指向类别表中
对主题的响应相连接。
的一行。
美系。
thereareno
DumbQuestions
复数据问题？
有5行，每一行对应一个类别？
答：确实是这样：
mismatch_category
独存储。由于类别存储在自己的表中，现在不再需要重复
类别名，对于每个类别只有一行、再由mismatch_topic
same
表中的行引用。这说明，mismatch_category表中的类
1
Appearance
每个类别名只
2
Entertainment
别行与mismatch_topic表中的主题行之间存在一种一对
存能一次！
3
Food
多的关系。
4
People
5
Activities
468
第8章
---
## Page 505
控制你的数据，世界在你手中
修改Mismatch数据库
为了充分利用这个新的模式，Mismatch数据库需要做一些结构修改。具
体来讲，我们需要创建一个新的mismatch_category表，然后把它
连接到mismatch_topic表中的一个新外键。由于mismatch_topic
表中原来包含重复类别数据的类别列已经不再需要，可以将它删除。
创建新的类别表，其中只
包含类别名。
mismatch_category
CREATE TABLE mismatch_category
category_id INT NOT NULL AUTO_INCREMENT,
name
name VARCHAR (48) NOT NULL,
PRIMARY KEY (category_id)
删除原来的类别列，因为
我们将从类别表引用类别。
ALTER TABLE mismatch_topic
mismatch_topic
DROP COLUMN category
topic_id0
name
增加一个新的category_id外键
ALTER TABLE mismatch_topic
category
将各个主题与类别表中的类别
ADD COLUMN category_id INT NOT NULL
相连接。
新的mismatch_category表必须填充类别数据，通过一组
mismatch_topic
INSERT语句完成。
nome
INSERT INTO mismatch_category (name) VALUES ('Appearance′)
8
Horror movies
2
INSERT INTO mismatch_category (name) VALUES ('Entertainment')
9
Eosy listening music
?
The opera
2
INSERT INTO mismatch_category(name)VALUES ('Food')
10
11
Sushi
3
INSERT INTO mismatch_category (name) VALUES ('People′)
12
Spam
3
INSERT INTO mismatch_category (name) VALUES ('Activities′)
13
Spicy food
3
14
Peanut butter&
3
新的category_id列必须填充数据，从而将各个主题的类别
banana sandwiches
15
Martinis
③<
关联到mismatch_category表中相应的类别。
16
Howard Stern
4
17
Bill Gates
4
UPDATE mismatch_topic SET category_id = 3
18
Barbara Streisand
WHERE name = 'Martinis'
这个3D应它与mismatch_category表中
的类别自增D匹配。
你现在的位置
469
---
## Page 506
测试规范化mismatch表
运行测试