2 (2006), 192â€“205.
[59] Pantheon. 2018. Pantheon of congestion control. http://pantheon.
stanford.edu/.
[60] Pantheon. 2018. Test from GCE Tokyo to GCE Sydney after the
advanced round-trip timing is applied. https://pantheon.stanford.
edu/result/4874/.
[61] Pantheon. 2018. Test from GCE Tokyo to GCE Sydney before the
advanced round-trip timing is applied. https://pantheon.stanford.
edu/result/4623/.
[62] Pantheon. 2019. Github repo of schemes tested in the pan-
theon. https://github.com/StanfordSNR/pantheon/tree/master/
third party.
[63] Pantheon. 2019.
Summary of results in Pantheon.
http-
s://pantheon.stanford.edu/summary/.
[64] Jiyong Park, Daedong Park, Seongsoo Hong, and Jungkeun Park.
2011. Preventing TCP performance interference on asymmetric
links using ACKs-first variable-size queuing. Elsevier Computer
Communications 34, 6 (2011), 730â€“742.
[65] Vern Paxson, Mark Allman, H.K. Jerry Chu, and Matt Sargent.
2011. RFC 6298: Computing TCPâ€™s retransmission timer. IETF
(2011).
[66] Vern Paxson, Mark Allman, Scott Dawson, William C. Fenner,
Jim Griner, Ian Heavens, Kevin Lahey, Jeff Semke, and Bernie
Volz. 1999. RFC 2525: Known TCP implementation problems.
IETF (1999).
[67] Kothuri Nageswara Rao, Y. K. Sundara Krishna, and K. Lakshmi-
nadh. 2013. Improving TCP performance with delayed acknowl-
edgments over wireless networks: A receiver side solution. In IET
Communication and Computing.
[68] Luigi Rizzo. 2019. Netmap - The fast packet i/o framework.
http://info.iet.unipi.it/âˆ¼luigi/netmap/.
[69] Lynne Salameh, Astrit Zhushi, Mark Handley, Kyle Jamieson, and
Brad Karp. 2014. HACK: Hierarchical ACKs for efficient wireless
medium utilization. In Proceedings of USENIX ATC. 359â€“370.
[70] Spirent. 2017. Accurate and repeatable network emulation. https:
//www.spirent.com/Products/Attero.
[71] Stephen D. Strowes. 2013. Passively measuring TCP round-trip
times. Commun. ACM 56, 10 (2013), 57â€“64.
[72] Kun. Tan, Jingmin Song, Qian Zhang, and Murari Sridharan. 2006.
A compound TCP approach for high-speed and long distance
networks. In Proceedings of IEEE INFOCOM. 1â€“12.
[73] Google Chrome team. 2019. WebRTC. https://webrtc.org/.
[74] Keith Winstein, Anirudh Sivaraman, and Hari Balakrishnan. 2013.
Stochastic forecasts achieve high throughput and low delay over
cellular networks. In Proceedings of USENIX NSDI. 459â€“472.
[75] Lei Xu, Ke Xu, Yong Jiang, Fengyuan Ren, and Haiyang Wang.
2017. Throughput optimization of TCP incast congestion control
in large-scale datacenter networks. Elsevier Computer Networks
124 (2017), 46â€“60.
[76] Yasir Zaki, Jay Chen, and Lakshminarayanan Subramanian. 2015.
Adaptive congestion control for unpredictable cellular networks.
In Proceedings of ACM SIGCOMM. 509â€“522.
Appendices
Appendices are supporting material that has not been peer
reviewed.
A NECESSITY OF CARRYING MORE
INFORMATION IN TACK
We use IACKs to report the most recent range of lost packets,
with which the sender can retransmit lost packets timely upon
IACK arrivals. Since IACKs might also be lost when there
exist losses on the ACK path, TACKs are adopted to report
the blocks of lost packets with the smallest serial numbers as
the so-called â€œunacked listâ€. We use ğœŒ and ğœŒâ€² to denote the
loss rate on the data path and on the ACK path, respectively.
ğ‘„ denotes the primary number of blocks in the â€œunacked
listâ€ that a TACK has reported. It is easy to see that if
ğœŒâ€² = 0, then we can set ğ‘„ = 0. However, when ğœŒâ€² is large,
the provisioning of ğ‘„ might fail to meet the needs of loss
recovery. In this section, we derive under what ğœŒâ€² it is more
profitable to use a TACK carrying more information.
A.1 When ğ‘ğ‘‘ğ‘ is large
To ensure efficient loss recovery, during the time period of
â–³ğ‘¡, our goal is to employ the TACK to repeat all the blocks
of lost packets that have been reported by the lost IACKs,
that is, the number of lost IACKs should not exceed ğ‘„.
Considering the worst case in which there are no back-
to-back packet losses, that is, each loss forms a â€œholeâ€ in
the receiverâ€™s buffer. According to Equation (3), when ğ‘ğ‘‘ğ‘ â‰¥
ğ›½ Â· ğ¿ Â· ğ‘€ ğ‘†ğ‘†, the receiver sends ğ›½ (ğ›½ â‰¥ 1) TACKs every
RTT. The maximum number of IACKs can be computed as
ğ‘€ ğ‘†ğ‘† , where â–³ğ‘¡ = ğ‘…ğ‘‡ ğ‘‡ , and the number of lost IACKs
ğœŒ Â· ğ‘ğ‘‘ğ‘
is computed as ğœŒ Â· ğœŒâ€² Â·
ğ‘€ ğ‘†ğ‘† under an ACK loss rate of ğœŒâ€².
Since the number of lost IACKs should not exceed ğ‘„, i.e.,
ğœŒ Â· ğœŒâ€² Â· ğ‘ğ‘‘ğ‘
ğ‘€ ğ‘†ğ‘† â‰¤ ğ‘„, we have
ğ‘ğ‘‘ğ‘
â€² â‰¤ ğ‘„ Â· ğ‘€ ğ‘†ğ‘†
ğœŒ Â· ğ‘ğ‘‘ğ‘
In this case, when ğœŒâ€² > ğ‘„Â·ğ‘€ ğ‘†ğ‘†
ğœŒ
(7)
(8)
ğœŒÂ·ğ‘ğ‘‘ğ‘ , it is more profitable to
use a TACK carrying more information. And the additional
number of blocks (â–³ğ‘„) in the â€œunacked listâ€ that the TACK
should report is given by â–³ğ‘„ = ğœŒÂ·ğœŒâ€²Â·ğ‘ğ‘‘ğ‘
ğ‘€ ğ‘†ğ‘† âˆ’ ğ‘„.
A.2 When ğ‘ğ‘‘ğ‘ is small
According to Equation (3), when ğ‘ğ‘‘ğ‘  ğ‘„
ğœŒÂ·ğ¿ , it is more profitable to use a
TACK carrying more information. And the additional number
of blocks (â–³ğ‘„) in the â€œunacked listâ€ that the TACK should
report is given by â–³ğ‘„ = ğ‘„
To summarize, it can be derived that the rich information
should be carried when the loss rate (ğœŒâ€²) on the ACK path
follows:
ğœŒÂ·ğ¿ âˆ’ ğ‘„.
ğ‘ğ‘‘ğ‘ â‰¥ ğ›½ Â· ğ¿ Â· ğ‘€ ğ‘†ğ‘†
ğ‘ğ‘‘ğ‘ 
B TACK FREQUENCY
MINIMIZATION
TACKâ€™s frequency follows Equation (3), where ğ›½ indicates
the number of ACKs per RTT, and ğ¿ indicates the number
of full-sized data packets counted before sending an ACK.
To minimize the ACK frequency, a smaller ğ›½ or a larger ğ¿ is
expected. This section discusses the lower bound of ğ›½ and the
upper bound of ğ¿. We also give the default values suggested
in practical scenarios. Finally, three insights are obtained
through quantitatively analysis of TACK frequency.
B.1 Lower bound of ğ›½
With regard to the sliding-window protocols such as TCP,
sending one ACK per RTT (i.e., ğ›½ = 1) transforms the
protocol into a stop-and-wait mode. That is, the sender stops
after sending a send window of data, and then waits for
one RTT, i.e., the time it takes for an ACK to reach the
sender and the data released by this ACK to propagate to
the receiver.
Since the waiting time wastes opportunities of sending
data, a transport with ğ›½ = 1 suffers from bandwidth under-
utilization. Under these circumstances, two ACKs per RTT
(i.e., ğ›½ = 2) are required. To facilitate the analysis, we
assume that a symmetric network without loss. ğ·ğ‘– denotes
the data packets released by the ğ‘–ğ‘¡â„ ACK (ğ´ğ¶ğ¾ğ‘–) and |ğ·ğ‘–|
denotes the data volume of ğ·ğ‘–. As shown in Figure 16, to
fully utilize the available bandwidth, at time ğ‘¡, the first
byte of ğ·ğ‘– should arrive at the receiver, and meanwhile
ğ´ğ¶ğ¾ğ‘–+2 should acknowledge the last byte of ğ·ğ‘–âˆ’1. Upon
each ACK arrival, the sender will be enabled to send a ğ‘ğ‘‘ğ‘
of data, i.e., |ğ·ğ‘–| = ğ‘ğ‘‘ğ‘. As a result, the send window size
is |ğ·ğ‘–| + |ğ·ğ‘–âˆ’1| = 2ğ‘ğ‘‘ğ‘ and it takes 2 RTTs for the data in
this window to complete. Note that the bottleneck buffer
therefore has to be at least one ğ‘ğ‘‘ğ‘. In summary, the lower
bound of ğ›½ is 2.
(a) ACK frequency vs. ğ‘ğ‘¤ (b) ACK frequency vs. ğ‘…ğ‘‡ ğ‘‡ğ‘šğ‘–ğ‘›
Figure 17: An example of ACK frequency dynamics
(data packets are full-sized, ğ¿ = 1 and ğ‘€ ğ‘†ğ‘† = 1500
bytes).
B.2 Upper bound of ğ¿
According to Equation (8), we have
ğ¿ â‰¤ ğ‘„
ğœŒ Â· ğœŒâ€²
(10)
Hence, the upper bound of ğ¿ is given by ğ¿ = ğ‘„
ğœŒÂ·ğœŒâ€² . For
example, when ğ‘„ = 4, ğœŒ = ğœŒâ€² = 10%, the receiver should
send an ACK at least every ğ¿ = 400 full-sized data packets.
B.3 Robustness consideration in TACK
According to Equation (3), the parameter ğ›½ comes into effect
when the ğ‘ğ‘‘ğ‘ is large, and parameter ğ¿ comes into effect
when the ğ‘ğ‘‘ğ‘ is small.
In terms of a transport with a large ğ‘ğ‘‘ğ‘, ğ›½ = 2 should
be sufficient to ensure utilization, but the large bottleneck
buffer (i.e., one ğ‘ğ‘‘ğ‘) makes it necessary to acknowledge data
more often. In general, the minimum send window ğ‘Šğ‘šğ‘–ğ‘› can
be roughly estimated as given in [50]:
ğ‘Šğ‘šğ‘–ğ‘› =
ğ›½
ğ›½ âˆ’ 1
Â· ğ‘ğ‘‘ğ‘, ğ›½ â‰¥ 2
(11)
Ideally, the bottleneck buffer requirement is decided by the
minimum send window, i.e., ğ‘Šğ‘šğ‘–ğ‘› âˆ’ ğ‘ğ‘‘ğ‘. Since doubling the
ACK frequency reduces the bottleneck buffer requirement
substantially from one ğ‘ğ‘‘ğ‘ to 0.33 ğ‘ğ‘‘ğ‘, this paper suggests
ğ›½ = 4 to provide redundancy, being more robust in practice.
Having a relatively low throughput, latency-sensitive flows
(such as RPCs) and application-limited flows usually suffer
more from ACK reduction as ğ¿ grows. Since the high ACK
frequency is not the main bottleneck in these cases, this paper
suggests a delayed TCP-like provisioning of ğ¿ = 2 to be more
robust in practice. Note that we might also provide an option
similar to TCP QUICKACK, allowing the real-time applications
to set ğ¿ = 1.
B.4 ACK frequency modeling and analysis
In the case that data packets are full-sized, according to
Equations (3), (4) and (5), we get three insights as follows.
First, given an ğ¿, the frequency of TACK is always no
more than that of the legacy TCP ACK, i.e., ğ‘“ğ‘¡ğ‘ğ‘ğ‘˜ â‰¤ ğ‘“ğ‘¡ğ‘ğ‘.
For example as shown in Figure 17 , the frequency of TACK
(cid:54)(cid:72)(cid:81)(cid:71)(cid:72)(cid:85)(cid:53)(cid:72)(cid:70)(cid:72)(cid:76)(cid:89)(cid:72)(cid:85)ACKi+1ACKi+3Di-1Dit RTT/2  2 RTT |Di-1| = |Di| = 1 bdpACKi+2ACKi-1ACKi0.01251050100500100020003000bw (Mbps)100101102103104105ACK Frequency (Hz)Pivot pointftcp(L=1)ftack(RTT=1ms)ftack(RTT=10ms)ftack(RTT=80ms)ftack(RTT=200ms)ftack(RTT=400ms)0.0010.010.11102030405060708090100RTTmin (ms)101102103104105ACK Frequency (Hz)Pivot point5ftcp(bw=1000Mbps)ftcp(bw=100Mbps)ftcp(bw=0.1Mbps)ftack(bw=1000Mbps)ftack(bw=100Mbps)ftack(bw=0.1Mbps)SIGCOMM â€™20, August 10â€“14, 2020, Virtual Event, NY, USA
Tong Li et al.
is only 10% of the per-packet ACK when ğ‘ğ‘¤ = 48 Mbps and
ğ‘…ğ‘‡ ğ‘‡ğ‘šğ‘–ğ‘› = 10 ms, which is a typical scenario in WLAN.
Second, the higher bit rate over wireless links, the more
number of ACKs are reduced by applying TACK. For ex-
ample, the frequency of TACK has dropped two orders of
magnitude (ğ‘“ğ‘¡ğ‘ğ‘ğ‘˜ â‰ˆ 2.4%ğ‘“ğ‘¡ğ‘ğ‘) when ğ‘ğ‘¤ increases from 48
Mbps to 200 Mbps (ğ‘…ğ‘‡ ğ‘‡ğ‘šğ‘–ğ‘› = 10 ms). Also, with higher
ğ‘ğ‘¤, the ğ‘…ğ‘‡ ğ‘‡ğ‘šğ‘–ğ‘› pivot point where the ACK frequency is
reduced, is further lowered (Figure 17(a)).
Meanwhile, the larger latency between endpoints, the more
number of ACKs are reduced by applying TACK. For ex-
ample, the frequency of TACK has dropped three orders of
magnitude (ğ‘“ğ‘¡ğ‘ğ‘ğ‘˜ â‰ˆ 0.3%ğ‘“ğ‘¡ğ‘ğ‘) when ğ‘…ğ‘‡ ğ‘‡ğ‘šğ‘–ğ‘› increases from
10 ms to 80 ms (ğ‘ğ‘¤ = 200 Mbps). And with larger ğ‘…ğ‘‡ ğ‘‡ğ‘šğ‘–ğ‘›,
the ğ‘ğ‘¤ pivot point where the ACK frequency is reduced, is
further lowered (Figure 17(b)).
In summary, TACK significantly reduces the ACK frequen-
cy in most cases. It is also straightforward that the results
remain similar in the case that the data packets are not
full-sized.