publicly computable.
ğ‘›
â€¢ Phase 4: Each player ğ‘ƒğ‘– proves in zero-knowledge that it
ğ‘¥ =ğ‘›
knows ğ‘£ğ‘–, the discrete logarithm of ğ‘‰ğ‘–. Each player sets ğ‘„ =
ğ‘–=1 ğ‘‹ğ‘– to be the public key, otherwise aborts. Note that
ğ‘–=1 ğ‘¢ğ‘– mod ğ‘ be the secret key.
Assuming that ğ‘ƒğ‘– and ğ‘ƒ ğ‘— are the two parties to sign ğ‘š, they could
compute ğ›¬ğ‘–ğ‘£ğ‘–, ğ›¬ğ‘— ğ‘£ ğ‘— respectively (such that ğ‘¥ = ğ›¬ğ‘–ğ‘£ğ‘– + ğ›¬ğ‘— ğ‘£ ğ‘—), where
ğ›¬ğ‘– and ğ›¬ğ‘— are Lagrange coefficients.
ğ‘—=1 ğ‘¥ ( ğ‘—)
ğ‘–
B PROOF OF THE MAIN THEOREM
Here is the proof of Theorem 3.1.
The simulator S could only access to an ideal functionality
FECDSA for computing ECDSA signatures. All S learns in the ideal
world is the public key ğ‘„ generated in the key generation phase
and several signatures for messages of its choice in the signature
phase. In the real world, the adversary, having either corrupted
ğ‘ƒ1 or ğ‘ƒ2 will also see all the interactions with the non-corrupted
party. Thus S must be able to simulate the adversaryâ€™s view of
these interactions, while only knowing the expected output. The
proof proceeds in two cases: the adversary corrupts ğ‘ƒ1, and the
adversary corrupts ğ‘ƒ2.
S simulates ğ‘ƒ2- Corrupted ğ‘ƒ1. We first show that if adversary A
corrupts ğ‘ƒ1, there exists simulator S such that the output distribu-
tion of S is indistinguishable from Aâ€™s view in the real execution
of the protocol.
Simulator S maintains a hash list ğ¿â„ for H. On any query ğ‘¦ to
H, if âˆƒ(ğ‘¦, â„ğ‘¦) âˆˆ ğ¿â„, return â„ğ‘¦, else return â„ğ‘¦ â† {0, 1}ğœ… and add
(ğ‘¦, â„ğ‘¦) to ğ¿ğ‘“ .
Key Generation Phase.
and receives back the public key ğ‘„.
(1) Given input KeygenG, ğ‘ƒ, ğ‘),S sends KeygenG, ğ‘ƒ, ğ‘) to FECDSA
(2) S invokes A upon input KeygenG, ğ‘ƒ, ğ‘) and receives f1.
â€¢ if there exists (ğ‘„1||nizk1, f1) âˆˆ ğ¿â„, check Verifzk(nizk1).
If Verifzk(nizk1) = 1, extract ğ‘¥1 with Ext. If ğ‘„1 = ğ‘¥1 Â· ğ‘ƒ,
compute ğ‘„2 = ğ‘„ âˆ’ ğ‘„1.
â€¢ otherwise, choose random ğ‘„2.
With the help of zero knowledge simulator Sim, S computes
nizk2, the non-interactive proof of knowledge for the discrete
log of ğ‘„2.
(3) S sends ğ‘„2, nizk2 to A.
(4) S receives ğ‘„1, nizk1 from A. If (ğ‘„1||nizk1, f1) âˆ‰ ğ¿â„, abort.
S simulates ğ‘ƒ2 aborting if Verifzk(nizk1) = 0 or ğ‘„1 â‰  ğ‘¥1 Â· ğ‘ƒ.
(5) S sends continue to FECDSA for ğ‘ƒ2 to receive output and
stores (ğ‘„, ğ‘¥1, ğ‘„1, ğ‘„2).
To pass the check of f1 = H(ğ‘„1, nizk1), A must have queried
(ğ‘„1, nizk1) to the random oracle. Thus, the difference between
the real execution and the ideal execution simulated by S is the
generation of ğ‘„2 and nizk2. In the real execution, ğ‘„2 = ğ‘¥2 Â· ğ‘ƒ where
ğ‘¥2 â† Zğ‘, and nizk2 = nizkPoK(ğ‘„2, ğ‘¥2), while in the later ğ‘„2 =
ğ‘„ âˆ’ ğ‘„1 and nizk2 â† Sim(ğ‘„2, ğ‘ƒ) where ğ‘„ is returned by FECDSA.
Ext extracts ğ‘¥1 with knowledge error 1/ğ‘. Since FECDSA samples ğ‘„
uniformly at random from G, conditional on the extraction of ğ‘¥1,
the distribution of ğ‘„2 in both cases is identical. Since Sim perfectly
simulate the proof, the distribution of nizk2 is also identical.
Signing Phase.
â€¢ Given input Sign(sid, ğ‘š), S sends Sign(sid, ğ‘š) to FECDSA
and receives signature (ğ‘Ÿ, ğ‘ ).
â€¢ Using the verification procedure, S recovers ğ‘… from (ğ‘Ÿ, ğ‘ ).
(1) Commitment: S invokes A with input Sign(sid, ğ‘š) and
sends a random string f2 â† {0, 1}ğœ… to A.
(2) MtA and consistency check:
â€¢ S interacts with A on behave of FMtA and in doing so
receives Aâ€™s input ğ‘¥â€²1 and output shares ğ‘¡ğ´.
â€¢ On receiving ğ‘„â€²1, ğ‘Ÿ1, ğ‘ğ‘ from A, S checks the consistency
?
by verifying ğ‘„â€²1
= ğ‘¡ğ´ + ğ‘¥â€²1ğ‘Ÿ1 âˆ’ ğ‘¥1 mod ğ‘,
and simulates ğ‘ƒ2 aborting if these equations do not hold.
â€¢ Upon receiving (ğ‘…1, nizk4) from A, S simulates ğ‘ƒ2 abort-
ing if Verifzk(nizk4) = 0. Else S extracts ğ‘˜1 utilizing Ext
algorithm.
â€¢ S computes ğ‘…2 = ğ‘˜âˆ’1
1 Â· ğ‘…âˆ’ğ‘Ÿ1 Â· ğ‘ƒ, generates nizk3 by query-
ing zero knowledge simulator Sim, and adds (ğ‘…2||nizk3, f2)
to the hash list ğ¿â„.
(4) Online Signature: S computes ğ‘ 2 = ğ‘˜1ğ‘  âˆ’ ğ‘¥â€²1ğ‘Ÿ mod ğ‘ where
ğ‘¥â€²1 and ğ‘˜1 are extracted from nizk1 and nizk4 respectively,
and sends ğ‘…2, nizk3, ğ‘ 2 to A.
?
= ğ‘¥â€²1 Â· ğ‘ƒ and ğ‘ğ‘
(3) Nonce key exchange:
The difference between a real execution and the simulation is
how ğ‘…2 and ğ‘ 2 are computed, and the consistency of ğ‘„â€²1 and ğ‘¥â€²1
is check. In the simulation, ğ‘…2 is ğ‘˜âˆ’1
Â· ğ‘… âˆ’ ğ‘Ÿ1 Â· ğ‘ƒ whereas in the
1
real execution ğ‘…2 = ğ‘˜2 Â· ğ‘ƒ where ğ‘˜2 â† Zğ‘. Since FECDSA samples
ğ‘… uniformly at random from G, the distribution in both cases is
identical. Ext extracts ğ‘˜1 with knowledge error 1/ğ‘. Conditional on
the correctness of ğ‘˜1, in the simulation
ğ‘ 2 = ğ‘˜1ğ‘  âˆ’ ğ‘¥â€²1ğ‘Ÿ = (ğ‘Ÿ1 + ğ‘˜2)âˆ’1(ğ»(ğ‘š) + ğ‘Ÿğ‘¥â€²2) mod ğ‘
which is identical to that in the real execution. Conditions ğ‘„â€²1 = ğ‘¥â€²1Â·ğ‘ƒ
and ğ‘ğ‘ = ğ‘¡ğ´ + ğ‘¥â€²1ğ‘Ÿ1 âˆ’ ğ‘¥1 mod ğ‘ in the simulation are equivalent to
(ğ‘¡ğµ + ğ‘ğ‘) Â· ğ‘ƒ = (ğ‘Ÿ1 + ğ‘˜2) Â· ğ‘„â€²1 âˆ’ ğ‘„1 in the real game.
This implies that the view of a corrupted ğ‘ƒ1 in the real execution
is indistinguishable from that of the simulation, i.e., the advantage of
any PPT adversary who corrupts ğ‘ƒ1 to distinguish the real execution
and simulated execution given by S is negligible.
S simulates ğ‘ƒ1- Corrupted ğ‘ƒ2. We show that if an adversary
A corrupts ğ‘ƒ2, there exists a simulator S such that the output
distribution of S is indistinguishable with Aâ€™s view in the real
execution of the protocol. Simulator S maintains a hash list ğ¿â„ for
Session 2D: Secure Multiparty Computation CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea570H. On any query ğ‘¦ to H, if âˆƒ(ğ‘¦, â„ğ‘¦) âˆˆ ğ¿â„, return â„ğ‘¦, else return
â„ğ‘¦ â† {0, 1}ğœ… and add (ğ‘¦, â„ğ‘¦) to ğ¿â„.
Key Generation Phase.
(1) Given input KeygenG, ğ‘ƒ, ğ‘),S sends KeygenG, ğ‘ƒ, ğ‘) to FECDSA
and receives back the public key ğ‘„.
(2) S invokes A with input KeygenG, ğ‘ƒ, ğ‘) and sends a random
string f1 â† {0, 1}ğœ… to A.
(3) Upon receiving (ğ‘„2, nizk2) from A, S computes ğ‘„1 = ğ‘„ âˆ’
ğ‘„2 and generates nizk1 with the help of zero knowledge
simulator Sim.
(4) S adds (ğ‘„1||nizk1, f1) to the hash list ğ¿â„.
(5) S sends ğ‘„1, nizk1 to A and stores (ğ‘¥2, ğ‘„, ğ‘„1, ğ‘„2).
The difference between real execution and ideal execution simu-
lated by S is the generation of ğ‘„1 and nizk1. In the real execution,
ğ‘„1 = ğ‘¥1 Â· ğ‘ƒ where ğ‘¥1 â† Zğ‘, and nizk1 = nizkPoK(ğ‘„1, ğ‘¥1), while
in the later ğ‘„1 = ğ‘„ âˆ’ ğ‘„2 and nizk1 â† Sim(ğ‘„1, ğ‘ƒ) where ğ‘„ is re-
turned by FECDSA. Ext extracts ğ‘¥2 with knowledge error 1/ğ‘. Since
FECDSA samples ğ‘„ uniformly at random from G, conditional on
the extraction of ğ‘¥2, the distribution of ğ‘„1 in both cases is identical.
Since Sim perfectly simulate the proof, the distribution of nizk1 is
also identical.
Signing Phase.
â€¢ Given input Sign(sid, ğ‘š), S sends Sign(sid, ğ‘š) to FECDSA
and receives signature (ğ‘Ÿ, ğ‘ ).
â€¢ Using the verification procedure, S recovers ğ‘… from (ğ‘Ÿ, ğ‘ ).
(1) Commitment: S invokes A with input Sign(sid, ğ‘š) and re-
ceives f2 from A.
â€¢ if âˆƒ(ğ‘…2||nizk3, f2) âˆˆ ğ¿â„, S extracts ğ‘˜2 such that ğ‘…2 = ğ‘˜2 Â· ğ‘ƒ
with the help of knowledge extractor (if the proof is ac-
cepted). Then S samples a random ğ‘Ÿ1 â† Zğ‘ and computes
ğ‘…1 = (ğ‘Ÿ1 + ğ‘˜2)âˆ’1 Â· ğ‘….
â€¢ otherwise, samples a random ğ‘Ÿ1 â† Zğ‘ and a random point
ğ‘…1 and generates nizk4 with the help of zero knowledge
simulator Sim
(2) MtA and consistency check:
â€¢ S interacts with A on behave of FMtA and in doing so
receives its input ğ‘˜â€²2 and output shares ğ‘¡ğµ.
â€¢ S samples a random ğ‘ğ‘ â† Zğ‘, computes
ğ‘„â€²1 = (ğ‘˜â€²2 + ğ‘Ÿ1)âˆ’1[(ğ‘¡ğµ + ğ‘ğ‘) Â· ğ‘ƒ + ğ‘„1],
and sends (ğ‘„â€²1, ğ‘Ÿ1, ğ‘ğ‘) to A.
(3) Nonce key exchange: S computes ğ‘…1 = (ğ‘Ÿ1 +ğ‘˜2)âˆ’1 Â· ğ‘…, gener-
ates nizk4 by querying zero knowledge simulator Sim, and
sends them to A.
(4) Online signature: Upon receiving ğ‘…2, nizk3, ğ‘ 2 from A, S
checks the proof of nizk3, and whether f2 = H(ğ‘…2, nizk3)
and
ğ‘ 2 Â· (ğ‘Ÿ1 Â· ğ‘ƒ + ğ‘…2)
?
= â„ Â· ğ‘ƒ + ğ‘Ÿ Â· (ğ‘¥2 âˆ’ ğ‘¡ğµ âˆ’ ğ‘ğ‘) Â· ğ‘ƒ .
If the checks pass, S returns (ğ‘Ÿ, ğ‘ ) as the final signature, else
aborts.
The difference between a real execution and the simulation is
how ğ‘…1 and ğ‘„â€²1 are computed, and the condition that (ğ‘Ÿ, ğ‘ ) is output
or not.
Since
In the simulation, ğ‘…1 is ğ‘…1 = (ğ‘Ÿ1 + ğ‘˜2)âˆ’1 Â· ğ‘… whereas in the
real execution ğ‘…1 = ğ‘˜1 Â· ğ‘ƒ where ğ‘˜1 â† Zğ‘. Since FECDSA samples
ğ‘… uniformly at random from G, the distribution in both cases is
identical. In the simulation, ğ‘„â€²1 is (ğ‘˜â€²2 + ğ‘Ÿ1)âˆ’1[(ğ‘¡ğµ + ğ‘ğ‘) Â· ğ‘ƒ + ğ‘„1]
whereas in the real execution ğ‘„â€²1 = ğ‘¥â€²1 Â· ğ‘ƒ for ğ‘¥â€²1 â† Zğ‘. Since ğ‘Ÿ1 and
ğ‘ğ‘ are sampled randomly and the consistency check always passes,
the distribution in both cases is identical.
In the real execution, the Verify algorithm checks that ğ‘  Â· ğ‘…
â„ Â· ğ‘ƒ + ğ‘Ÿ Â· ğ‘„, i.e., implicitly checks
ğ‘ 2(ğ‘Ÿ1 + ğ‘˜2)
?
= â„ + ğ‘Ÿ(ğ‘¥2 âˆ’ ğ‘¡ğµ âˆ’ ğ‘ğ‘) mod ğ‘.
?
=
(4)
(5)
ğ‘ 2 Â· (ğ‘Ÿ1 Â· ğ‘ƒ + ğ‘…2) = â„ Â· ğ‘ƒ + ğ‘Ÿ(ğ‘¥2 âˆ’ ğ‘¡ğµ âˆ’ ğ‘ğ‘) Â· ğ‘ƒ
holds if and only if Equation 4 is correct, the condition to output
(ğ‘Ÿ, ğ‘ ) in both the real and simulated case is identical.
This implies that the view of a corrupted ğ‘ƒ2 in the real execution
is indistinguishable with that of the simulation, i.e., the advantage of
any PPT adversary who corrupts ğ‘ƒ2 to distinguish the real execution
and simulated execution given by S is negligible.
C MTA FROM OBLIVIOUS TRANSFER
We recall the MtA from OT proposed in [15].
Let F â„“
OTe be the Correlated OT-extension functionality that al-
lows arbitrarily many Correlated OT instances to be executed in
batches of size â„“. The input of the receiver is a vector of choice bits
while the senderâ€™s input is a vector of correlated elements. The func-
tionality samples â„“ random pads and sends them to the sender. To
the receiver, it sends the pads if the senderâ€™s corresponding choice
bits were 0, otherwise the sum of the pads and their corresponding
correlations. Please refer to [15, Sec. IV and Appendix A] for the
concrete definition and instantiation.
The OT-based MtA is constructed in the F â„“
OTe hybrid model. It
is parameterized by the statistical security parameter ğ‘ , the curve
order ğ‘, and ğœ… = |ğ‘|. Let g = gG||gR be a coefficient vector where
ğ‘– = 2ğ‘–âˆ’1, and gR is a public random vector. Assume
gG satisfies gG
the input of Alice and Bob is ğ‘, ğ‘ âˆˆ Zğ‘ respectively, they execute
the following protocol to export ğ›¼, ğ›½ such that ğ›¼ + ğ›½ = ğ‘ğ‘.
Encoding:
Multiplication:
â€¢ Bob samples ğ›¾ â† {0, 1}ğœ…+2ğ‘ , and encodes its input as b =
Bits(ğ‘ âˆ’ âŸ¨gR, ğ›¾âŸ©)||ğ›¾.
â€¢ Alice samples Ë†ğ‘ â† Zğ‘ and sets a = {ğ‘|| Ë†ğ‘} ğ‘— âˆˆ[1,2ğœ…+2ğ‘ ].
â€¢ Alice who plays as sender and Bob as receiver, invokes func-
tionality F â„“
OTe with their encoded input where â„“ = 2ğœ… + 2ğ‘ .
They receive as outputs, respectively, {tğ´ğ‘—||Ë†tğ´ğ‘—} ğ‘— âˆˆ[1,2ğœ…+2ğ‘ ]
and {tğµ ğ‘—||Ë†tğµ ğ‘—} ğ‘— âˆˆ[1,2ğœ…+2ğ‘ ]
â€¢ Alice and Bob generate two shared random values by calling
the random oracle, i.e., (ğœ’, Ë†ğœ’) â† RO(transcript).
â€¢ Alice computes and sends r = {ğœ’tğ´ğ‘— + Ë†ğœ’Ë†tğ´ğ‘—} ğ‘— âˆˆ[1,2ğœ…+2ğ‘ ], ğ‘¢ =