title:Vulnerable Implicit Service: A Revisit
author:Lingguang Lei and
Yi He and
Kun Sun and
Jiwu Jing and
Yuewu Wang and
Qi Li and
Jian Weng
Vulnerable Implicit Service: A Revisit
Lingguang Lei¶†‡, Yi He§, Kun Sun‡, Jiwu Jing¶†, Yuewu Wang¶†, Qi Li§, Jian Weng∗
¶Data Assurance and Communication Security Research Center, Chinese Academy of Sciences, China
†State Key Laboratory of Information Security, Institute of Information Engineering, Chinese Academy of Sciences
§Graduate School at Shenzhen, Department of Computer Science, Tsinghua University, China
‡George Mason University, Fairfax, VA, USA
PI:EMAIL,PI:EMAIL,PI:EMAIL,{jingjiwu,wangyuewu}@iie.ac.cn
∗Jinan University, Guangzhou, China
PI:EMAIL,PI:EMAIL
ABSTRACT
(cid:140)e services in Android applications can be invoked either explic-
itly or implicitly before Android 5.0. However, since the implicit
service invocations su(cid:130)er service hijacking a(cid:138)acks and thus lead
to sensitive information leakage, they have been forbidden since
Android 5.0. (cid:140)erea(cid:137)er since the Android system will simply throw
an exception and crash the application that still invokes services
implicitly, it was expected that application developers will be forced
to convert the implicit service invocations to explicit ones by speci-
fying the package name of the service to be called.
In this paper, we revisit the service invocations by analyzing
two sets of the same 1390 applications downloaded from Google
Play Store before and a(cid:137)er the the implicit service forbidden policy
is enforced. We develop a static analysis framework called ISA to
perform our study. Our analysis results show that the forbidden
policy e(cid:130)ectively reduces the number of vulnerable service invo-
cations from 643 to 112, namely, 82.58% reduction. However, a(cid:137)er
a detailed analysis of the remaining 112 vulnerable invocations,
we discover that the forbidden policy fails to resolve the service
hijacking a(cid:138)acks. Among the 1390 applications downloaded in May
2017, we (cid:128)nd 36 popular applications still vulnerable to service hi-
jacking a(cid:138)acks, which can lead to the loss of user bank account and
VPN login credentials, etc. Moreover, we (cid:128)nd that the forbidden
policy introduces a new type of denial of service a(cid:138)acks. Finally, we
discuss the root challenges on resolving service hijacking a(cid:138)acks
and propose countermeasures to help mitigate the service hijacking
a(cid:138)acks.
CCS CONCEPTS
•Security and privacy →Mobile platform security; So(cid:135)ware
security engineering;
KEYWORDS
Implicit Intent; Service Hijacking A(cid:138)acks; Denial of Service A(cid:138)acks
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for pro(cid:128)t or commercial advantage and that copies bear this notice and the full citation
on the (cid:128)rst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permi(cid:138)ed. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speci(cid:128)c permission and/or a
fee. Request permissions from permissions@acm.org.
CCS’17, Oct. 30–Nov. 3, 2017, Dallas, TX, USA.
© 2017 ACM. ISBN 978-1-4503-4946-8/17/10...$15.00
DOI: h(cid:138)p://dx.doi.org/10.1145/3133956.3133975
1 INTRODUCTION
In Android, the applications are divided into components, which can
be conveniently reused by other applications mainly through a mes-
sage passing mechanism called intent in Android Inter-Component
Communication (ICC) model. However, ICC model is becom-
ing the main reason for the explosive component hijacking at-
tacks [4, 6, 16, 31, 33, 34, 41], which cause information leakage or
even (cid:128)nancial loss.
As one type of components, a service can be invoked by us-
ing either an explicit intent or an implicit intent. Explicit intents
specify the component names or package names explicitly. (cid:140)ey
are typically used by developers to start components in their own
applications (i.e., same origin apps) or the well-known third party
services, since the developers already know the component name
or package name of the service to be called. In contrast, implicit
intents only describe the type of action to perform and allow the
system to (cid:128)nd a component on the device to perform the action [17].
For brevity, we call the service invocations through implicit intents
as implicit service invocations and the service invocations through
explicit intents as explicit service invocations. Researchers found
that a(cid:138)ackers can launch a service hijacking a(cid:138)ack by exploiting
the implicit service invocations [10]. By cra(cid:137)ing a malicious ap-
plication that provides a service matching to an implicit intent
requested from a victim application, the a(cid:138)acker may make the
system choose its malicious service from multiple matching ser-
vices to serve the victim application under the condition that the
malicious service has the highest priority in the service list.
To remove the vulnerabilities introduced by the implicit service
invocations, since Android 5.0 (API level 21), Google banned the ser-
vice components from being invoked through implicit intents [19].
When a service is invoked implicitly, the application will simply
crash. By enforcing this forbidden policy, Google expects to resolve
the service hijacking a(cid:138)acks by forcing application developers to
convert their implicit service invocations to explicit ones.
In this paper, we evaluate the impacts of the implicit service
forbidden policy on application developers and its e(cid:130)ectiveness on
removing vulnerable service invocations by analyzing two sets of
the same applications downloaded from Google Play Store before
and a(cid:137)er the forbidden policy is enforced. Our study focuses on
answering two questions. First, how well is the implicit service
forbidden policy being accepted by application developers? A sta-
tistics analysis [28] shows that 78.1% applications invoking the
Session E2:  Securing Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1051service components and in which about 30% services are started
through implicit intents. Second, can the forbidden policy resolve
the service hijacking a(cid:138)acks in Android 5.0 and higher?
To answer these two questions, we develop an analysis frame-
work called ISA 1 to systematically study the vulnerabilities in
service invocations. First, we employ android-apktool [2] as a pre-
processor to convert the APK (cid:128)les into smali (cid:128)les, since smali codes
do not require disassembling Java code and avoid introducing in-
accuracy into the results. Next we develop a static intent analyzer
to discover all intents that are consumed for invoking the service
components in the smali codes. We develop a reachability veri(cid:128)er to
check if the service invocations found by our static intent analyzer
are reachable from certain entry points of the apps. We perform a
depth (cid:128)rst search to traverse the code and check if there is a calling
chain from an entry-point to the service invocation APIs. Since we
do not need to save the edges and nodes of the full call-graph, the
reachability veri(cid:128)er can achieve a good performance. Finally, we
develop an vulnerable service invocation analyzer to identify the
vulnerable service invocations.
Next we apply our analysis framework on two sets of the same
1390 popular applications downloaded from Google Play Store
before and a(cid:137)er the implicit service invocations are forbidden. We
denote the application dataset downloaded between August 2014
and October 2014 as “Old Apps”, since the forbidden policy has
not been enforced. We denote the application dataset downloaded
in May 2017 as “New Apps”, since the forbidden policy has been
enforced for 30 months.
Our experimental results show that the forbidden policy e(cid:130)ec-
tively reduces the number of vulnerable service invocations from
643 to 112, namely, 82.58% reduction. However, the forbidden policy
fails to resolve all service hijacking a(cid:138)acks - 57 among the 112 in-
vocations make 36 applications still vulnerable to hijacking a(cid:138)acks,
which can be misused to steal user bank account or VPN login
credentials. Since the analyzed applications are the most popular
applications from Google Play Store, more than 500,000,000 users
could be impacted by these a(cid:138)acks.
A(cid:137)er a detailed analysis of the remaining 112 vulnerable service
invocations, we discover that the key reasons for the remaining
vulnerable invocations are two-fold. (cid:140)e (cid:128)rst one is the di(cid:129)culty
in determining the package names for certain third party services,
due to the various types of third party services and the di(cid:129)culty on
verifying the trustworthy of the apps. (cid:140)e vulnerable invocation
reduction from 643 to 112 is due to the resolve of the same origin
services or the well-known Google third party services, which
are easy for the developers to determine the package names or
for the Android system to identify the suitable applications (e.g.,
se(cid:138)ing higher priority to the same origin and the Google services).
However, for the other not well-known third party services, the
reduction rate is only 23.46%. We call this type of third party service
as “the other third party service”, which is the main challenge to
resolve the service hijacking a(cid:138)acks.
To avoid explicitly specifying the class or package name for
the other third party service, developers are more frequently call-
ing the queryIntentServices() and resolveService () APIs [20] to
help convert implicit intents into explicit intents. When calling
1ISA stands for Implicit Service Analysis.
queryIntentServices (Intent intent, int flags) API, the
Android system returns a list of services installed on the mo-
bile phone matching the implicit intent in the parameter. (cid:140)e
resolveService (Intent intent, int flags) API returns the
(cid:128)rst service in the service list provided by queryIntentServices
().
Since the matching rules of queryIntentServices() is
the same as the vulnerable ones used by bindService() and
startService(), the service invocations through explicit intents
converted by queryIntentServices() and resolveService()
may still su(cid:130)er service hijacking a(cid:138)acks on Android 5.0 and higher.
Moreover, we (cid:128)nd that a(cid:138)ackers may misuse this ranking rules to
disable a victim service invocation or crash a victim application.
We call the service invocations through explicit intents converted
by these two APIs as “the resolved service invocations”.
(cid:140)e second reason lies in the di(cid:129)culty for all the developers
to correctly update the applications in time, especially when the
services are invoked through outdated SDK or reuse of the out-
dated sample codes. For example, among the 112 vulnerable service
invocations in “New Apps”, 62 are residue implicit invocations, and
more than half are Google or same origin services. 79.03% residue
ones remain implicit since they are invoked through outdated SDKs
or reusing outdated sample codes, in which the services are invoked
implicitly. (cid:140)ere are even some SDKs in which the services are in-
voked implicitly in the latest versions. A(cid:137)er analyzing the Android
source codes, we (cid:128)nd that when an application’s targetSdkVersion
a(cid:138)ribute is set lower than 21 (i.e., API Level of Android 5.0), implicit
service invocations are still allowed even on Android 5.0 and higher
platforms. 61.29% implicit service invocations in “New Apps” are
vulnerable to hijacking a(cid:138)acks rather than app crash.
According to our analysis results, we propose several counter-
measures to further mitigate the service hijacking a(cid:138)acks. We
suggest an optimization in the ranking rules of the implicit or re-
solved service invocations, i.e., giving a higher priority to the same
origin and the Google third party service. (cid:140)is simple optimization
could reduce 44.64% vulnerable service invocations in the “New
Apps”, among which 72% are vulnerable to hijacking a(cid:138)acks. For
the other third party service, we propose a market-based service
ranking algorithm to increase the di(cid:129)culty for a(cid:138)acker to manip-
ulate the ranking of the service list. Several serious unresolved
a(cid:138)acks in “New Apps”, e.g., stealing the VPN login credentials,
could be defeated with this solution. We also discuss two other
countermeasures, namely, signature-based veri(cid:128)cation and SDK
hardening, which are promising to mitigate the service hijacking
a(cid:138)acks.
2 BACKGROUND
2.1 Service Components and Intents
A service is an Android Application component that performs op-
erations in the background without a user interface. Each Service
has a corresponding  declaration in the application Mani-
fest.xml (cid:128)le and includes an a(cid:138)ribute named exported to de(cid:128)ne if
the service can be started in another application. If the exported
a(cid:138)ribute is set to false, the service can only be started by compo-
nents in the same application. In addition, the service may de(cid:128)ne
one or more  to specify the types of intents that
the service can respond to. (cid:140)ere are two ways to allow a service be
Session E2:  Securing Mobile AppsCCS’17, October 30-November 3, 2017, Dallas, TX, USA1052started by other applications. First, its exported a(cid:138)ribute should be
set to true. Second, when the exported a(cid:138)ribute is not set explicitly,
at least one Intent Filter is de(cid:128)ned.
Service components can be started using either startService() or
bindService() API functions. (cid:140)e startService() function performs
a single operation with no return values, and the started service
runs in the background inde(cid:128)nitely even if the caller component is
destroyed. (cid:140)e bindService() function provides an enriched commu-
nication interface for the caller to interact with the service, but the