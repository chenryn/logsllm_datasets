25号包：
服务器：“你可以连接到IP=10.32.106.112，端口号为240×256+217=61657（公式中的256为约定好的常数）。”
29号包：
客户端：“我想下载linpeiman.txt。”
30号包：
服务器：“给你传了。”
上面这些包并没有真正传输文件内容，我们接着看（见图9）。
图9
26、27、28号包是数据连接的三次握手，可见这一次由客户端主动发起（所以对服务器来说是被动的），连接的服务器端口为之前协商好的61557。
31、32、33、34、35号包完成了文件内容的传输，然后关闭数据连接。同样从图9底部可以见到该文件的内容：Life is tough. Wireshark makes it easy.
最后我在FTP命令行中打了个“bye”命令（见图10）。
图10
Goodbye过程的网络包如图11所示。
图11
39号包：
客户端：“我要退出啦。”
40号包：
服务器：“好的，Goodbye!”（FTP是我所知道最讲礼仪的协议。）
 41、42、43、44号包是四次挥手过程，断开控制连接，完成了一次FTP的生命周期。
你也许想问，那如何指定客户端采用主动还是被动模式呢？很多FTP客户端软件都有这个选项。比如图12是WinSCP上的截图，选中Passive mode即表示被动模式。
图12
理论上所有FTP客户端都应该支持这两种模式，但Windows自带的ftp命令似乎只支持主动模式。图13是我试图采用被动模式的命令。
图13
从图13中看，当我输入“quote pasv”命令时，的确显示进入被动模式（Entering Passive Mode）。接下来我们看看图14的网络包。12号和13号包也的
 确显示进入被动模式，但是再接下来的网络包却完全是主动模式的样子。
图14
从结果看，12号和13号包完全没有起作用。这很可能是Windows的一个bug，我在Windows 7和Windows 2003都看到了相同的结果。那微软的测试部门为什么没有发现呢？如果没有用Wireshark来抓包检查，测试人员是很难测出这个问题的，我也是在写这篇文章的时候碰巧看到。从这个不经意的发现，就可以知道Wireshark的价值。
上网的学问——HTTP
2012年7月27日，伦敦奥运会开幕式上，一位长者带着上世纪才能见到的老式电脑出现了。他发布了一条推特—“This is for everyone”，随即显示在体育馆的大屏幕上，传遍世界（见图1）。
图1
他就是57岁的Tim Berners-Lee爵士——万维网的发起者，也是第一位实现HTTP的工程师。英国人不但借此传播了开放和分享的互联网精神，也展示了其在IT历史上的地位—从奠定现代计算机基础的Alan Turing，到发明分组交换的Donald Davies，再到万维网之父Tim Berners-Lee，每一个重大环节都有英国人的参与。假如北京奥运会上也要推出我们的IT界代表人物，我想大家心中已有合适的人选，他也可以在台上尝试发一条推特。
Tim所实现的HTTP便是我们今天浏览网页所用的网络协议。他当年建立的网站至今还能访问，域名为http://info.cern.ch/。虽然这个页面已经更新过，但我们还可以在http://www.w3.org/History/19921103-hypertext/hypertext/WWW/News/9201.html看到当年的内容。
HTTP的工作方式算不上复杂，先由客户端向服务器发起一个请求，再由服
 务器回复一个响应。根据不同需要，客户端发送的请求会用到不同方法，有GET、POST、PUT和HEAD等。比如在网站上登录账号时就可能用到POST方法。
我在打开网页http://www.rfc-editor.org/info/rfc2616时抓了包，我们就以此为例，来看看HTTP是如何工作的（见图2）。
图2
1．由于HTTP协议基于TCP，所以上来就是三次握手。从图2的底部可以看到，服务器的端口号为80。
2．在图3中，4号包是客户端向服务器发送的“GET /info/rfc2616 HTTP1.1”请求，即通过1.1版的HTTP协议，获取/info目录里的rfc2616文件。说白了就是想下载页面内容。
图3
3．7号包是服务器对该请求的响应，即把/info/rfc2616的内容发给客户端。
4．9号包是客户端向服务器请求“GET /style/rfc-editor.css”。该css文件定义了页面的格式。
5．11号包是服务器对该请求的响应，把/style/rfc-editor.css的内容发给客户端。
就这样，客户端通过两个GET方法得到了页面内容和格式，从而打开了网页。如果点开每一个HTTP包前的+号，还能看到其协议头和详细信息。以4号包为例，它的HTTP协议头在Wireshark中如图4所示。其包含的信息大概可以归纳为：我要通过1.1版的HTTP协议，从服务器www.rfc-editor.org的/info目录里得到rfc2616的内容。
图4
HTTP算不上一个复杂的协议，出问题的时候也能在浏览器上看到错误信息，所以我们用到Wireshark的机会并不多。不过随着技术的进步，HTTP越来越多地应用到不需要浏览器的场景中，比如现在如火如荼的云存储技术就有Wireshark的用武之地。
由于海量文件不适合传统的目录结构，所以云存储一般使用对象存储的方式—客户端访问文件时并不使用其路径和文件名，而是使用它的对象ID。身份验证也是通过HTTP协议实现的。工程师们处理此类问题时就能用上Wireshark了。图5是Wireshark解析后的HTTP读文件过程（只要在Wireshark上右键单击其中一个包，在弹出的菜单中选择“Follow TCP Stream”就可以打开这个窗口）。我们可以从中看到该文件的对象ID“59J5T5KV78EP0e7AJIV55UO93DVG4140QGQQ000ED7PR8EJH3OGUV”，还有身份验证时用到的用户名“paddy”和加密后的密码。我们甚至可以看到服务器回复的文件内容“I am Paddy Lin…”在这个过程中一旦发生问题，比如身份验证出错了，都能从Wireshark中看到。
图5
 上面两个例子都用到了GET方法，因为它是最常用的。事实上HTTP协议最早的版本就只支持GET，Tim开发的第一个网页也是如此。这在今天的开发者看来简直是小菜一碟，甚至给人一种“时无英雄”的错觉。但如果放眼整个IT历史，现在看起来很了不起的技术都是从简单发展而来的。以云存储为例，底层用到的技术并不新颖，但组合起来的云概念就是科技前沿了。
用Wireshark来解决HTTP问题是很痛快，因为整个通信过程一览无遗。但仔细一想却叫人直冒冷汗—如果连传输的文件内容都可以清楚地看到，那我上网时的聊天记录，甚至密码是否也会被发现？很不幸，答案是肯定的。如果没有使用加密软件，那么黑客（或者你的领导）就可以从网络包中看到你上班时聊了些什么，在哪些帖子上祝福楼主一生平安，搜索了什么关键词，甚至知道你登录论坛的用户名和密码。
图6是我在Google上搜索时抓的包。从4号包可以看到我用到的关键词“Max is the best boss in the world”（Max是我老板的名字，希望他此时正在监控我的网络）。如果IT部门把这类包收集起来，就能统计出员工们上班时都在搜索什么，再通过IP地址还能查到每一项是谁搜的。
图6
至于更敏感的用户名和密码，这里也有个血淋淋的例子。我在登录www.mshua.net（这是我经常登录的园艺论坛）时抓了包。当客户端用POST方法把用户名和密码传给服务器时，已经在网络上暴露了身份。请看图7底部的用户名“username=wiresharktest”和密码“password=P@ssw0rd”，可以想见这个明文账号和密码随时可能落入坏人手中。事实也是如此，上个月我登录时，就发现几位平时一本正经的网友在发成人图片，显然他们的密码已经被盗了。为了防止好奇的读者用这个账号浏览不健康信息，我已经把密码改掉了。
图7
那要如何保护自己的信息呢？HTTPS就是一个不错的选择。比如用Google搜索时在http后加个s，变成https://www.google.com.hk/，就不用担心老板知道你在搜些什么了。图8就是使用HTTPS搜索时抓的包，注意服务器端口是443，关键词也被加密到了“Encrypted Application Data”里。
图8
大多数人并不需要理解HTTPS的加密算法，所以本文将不在此多费笔墨（其实是因为我自己也不懂）。但因为加密包会给诊断问题带来不少障碍，所以管理员有必要知道如何对它进行解码。图9是4个HTTPS包，我们除了能看到“Application Data Protocol”是HTTP之外，几乎对它们一无所知，因为所有信息都被加密了。
图9
 要对这些加密包进行解码，只需要以下几个步骤（本例所用的网络包和密钥来自http://wiki.wireshark.org/SSL 上的snakeoil2_070531.tgz文件，建议你也下载来试试）。
1．解压snakeoil2_070531.tgz并记住key文件的位置，比如C:\tmp\rsasnakeoil 2.key。
2．用Wireshark打开rsasnakeoil2.cap。
3．单击Wireshark的Edit-->Preferences-->Protocols-->SSL-->RSA keys list。然后按照IP Address,Port,Protocol,Private Key 的格式填好，如图10所示。
图10
4．单击OK，这些包就成功解码了。图11就是这4个包解码后的样子，两个GET方法都可以看到。
图11
既然HTTPS包能被解码，是不是说明它也不安全呢？事实并非如此，因为解码所用到的密钥只能在服务器端导出。不同的服务器操作步骤有所不同，比如IIS服务器就可以参考这一篇文章：http://www.packetech.com/showthread.php?1585-Use-Wireshark-to-Decrypt-HTTPS。
你的老板有可能潜入Google导出密钥吗？我相信我老板做不到。
无懈可击的Kerberos
在古希腊神话中，冥界的大门由一头烈犬看守。此犬长有三个头，兢兢业业地守在冥河边，从没有灵魂能在它醒着的时候逃离。这头烈犬就是Kerberos，安全守卫的象征。古希腊人下葬时要放好蜜饼，就是为了讨好它。现代游戏里也有它的英姿，比如《英雄无敌》里以一敌多的地狱烈犬。