items：数组项目的模式。
例如，字符串数组可以定义为：
{"type"："array"，"items"："string"}
（4）映射（maps）
映射使用类型名称“map”并且支持一个属性。
values：映射值的模式。
映射值默认为字符串，例如，从字符串到长整型的映射可以声明为：
{"type"："map"，"values"："long"}
（5）联合（unions）
联合主要使用JSON数组表示，例如可以用["string"，"null"]声明一个是字符串或者null的模式。除了指定的记录、固定型（fixed）和枚举外，对于相同的类型，联合只能包含一个模式。例如，联合中不允许包含两个数组类型或两个映射类型，但是允许包含不同名称的两种类型。联合中不能直接包含其他的联合。
（6）固定型（fixed）
固定型使用类型名称“fixed”并且支持以下属性。
name：固定型名称的字符串（必须）。
namespace：限定名称的字符串。
aliases：提供替代名称的字符串的JSON数组（可选）。
size：说明每个值的字节数的整型（可选）。
例如，16字节大小的固定型可以声明为：
{"type"："fixed"，"size"：16，"name"："md5"}
记录、枚举和固定型都是指定的类型，其全名由两部分组成：名称和命名空间。全名为由点分开的名字序列，其名称部分和记录字段名字必须：
以字母A～Z或a～z或_开头；
后面应只含有A～Z、a～z、0～9或_。
在记录、枚举和固定型的定义中，全名可以通过以下几种方式定义。
指定名称和命名空间。如使用名称"name"："X"和命名空间"namespace"："org.foo"来表示全名org.foo.X。
指定全名。如果指定的名称中包含点，则可以使用名称作为全名，并且任何指定的命名空间都将被忽略。如使用名称"name"："org.foo.X"来表示全名org.foo.X。
只指定名称，且名称中不包含点。这种情况下命名空间取自外层的模式或协议，比如指定名称"name"："X"，其所在记录定义的字段则为org.foo.Y，即全名为org.foo.X。
总结以上后两种情况可得：如果名称包含点，则是全名；如果不包含点，则命名空间默认为外层定义的命名空间。原始类型没有命名空间并且它们的名称也不能定义为任何命名空间。
命名的类型和字段可以拥有别名。为方便模式的发展和处理不同的数据集，在实现中可以选择使用别名将作者的模式（writer’s schema）映射成读者的模式（reader’s schema）。使用别名可以改变作者的模式，例如，如果作者的模式命名为"Foo"，而读者的模式命名为"bar"且别名为"Foo"，那么在读取时即使"Foo"称作"Bar"也能实现。同理，如果数据曾经写成字段名为"x"的记录，那么即使是字段名为'"y"别名为"x"的记录也能读取，尽管"x"写成了"y"。
 16.1.2 数据序列化
模式声明后就可以根据模式写入数据了。当数据存储或传输时需要对其序列化，需要注意的是，Avro数据和其模式会一起被序列化。基于Avro的RPC系统必须保证远程的数据接收器拥有写入数据的模式副本，因为读取数据时写入数据的模式是知道的，所以Avro数据本身不需要标记类型信息。
通常，序列化和还原序列化过程（见图16-1）可以看成是对模式深度优先、从左到右的遍历过程，并在遍历过程中序列化或还原序列化遇到的原始类型。
Avro指定两种序列化编码：二进制和JSON。在这两种序列化编码中，因为二进制编码速度快且生成的数据量小，所以大多数的应用程序使用二进制编码。但是基于调试和网络的应用程序有时使用JSON编码比较合适。下面先介绍各种类型的二进制编码。
原始类型的二进制编码有如下几种。
null编码成零字节。
boolean编码成单字节，值为0（false）或1（true）。
int和long使用可变长度的ZigZag编码
[1]
 ，如表16-2所示。
float占4字节，使用类似于Java中floatToIntBits的方法可以将浮点数转化成32位的整型，然后编码成低字节序的格式。
double占8字节，使用类似于Java中doubleToLongBits的方法可以将双精度数转化
为64位的整型，然后编码成低字节序的格式。
bytes根据数据的字节编码成长整型。
string根据UTF-8字符集编码成长整型。
如果UTF-8字符集中'f'、'o'、'o'的十六进制分别为66 6f 6f，并且字符串"foo"含有三（编码成十六进制06）个字符，那么"foo"编码为06 66 6f 6f。
复杂类型的二进制编码方法有如下几种。
（1）记录（records）
通过对声明的每个字段值按顺序编码来对记录进行编码。换句话说，记录的编码由每个字段的编码串联而成。例如，记录模式的代码如下：
{
"type"："record"，
"name"："test"，
"fields"：[
{"name"："a"，"type"："long"}，
{"name"："b"，"type"："string"}
]
}
以上代码中，假设a字段的值为27（十六进制为36），b字段的值为"foo"（十六进制为06 66 6f 6f），那么记录的编码仅仅是这些编码的串联，即十六进制序列36 06 66 6f 6f。
（2）枚举（enums）
枚举按整型编码，其中整型代表每个标志在模式中的位置（从0开始）。例如，枚举模式的代码如下：
{"type"："enum"，"name"："Foo"，"symbols"：["A"，"B"，"C"，"D"]}
上面的例子序列化时将被编码成整型0～3，其中0代表"A"，3代表"D"。
（3）数组（arrays）
数组编码成一系列块，每个块包含一个长整型的数值，长整形的数值组成为数组项，其中最后一块为0，表示是数组的结尾，每个数组项的模式都会编码。如果块中的值为负数，则取绝对值，紧跟数值后面的块的大小为长整型，表示块中的字节数。如果只映射记录部分字段，则利用块大小可以跳过部分数据。例如，数组模式为：
{"type"："array"，"items"："long"}
对于包含项3和27的数组，其数组包含两个长整型值，其中数组个数“2”使用ZigZag编码成十六进制为04，而3和27编码成十六进制分别为06和36，最后以0结尾，其数组编码成：04 06 36 00。
这种块表示方法允许读/写大小超过内存缓冲的数组，因为在不知道数组长度的情况下就可以开始写入。
（4）映射（maps）
映射的编码和数组相似，也是编码成一系列块，每个块包含一个长整型值，然后是键值对，值为0的块表示映射的结尾。如果块的值为负数，则取其绝对值。紧跟数值后面的块的大小为长整型，表示块中的字节数。如果只映射记录的部分字段，则利用块大小可以跳过部分数据。
同数组一样，在不知道映射长度的情况下就可以写入，因此这种块的表示方法也允许读/写大小超过内存缓冲的映射。
（5）联合（unions）
联合编码时先写入一个长整型值表示联合中每个模式值的位置（从0开始），再对联合中的值编码。例如，联合模式["string"，"null"]应如此编码：null为整数1（联合中null的索引，使用ZigZag编码成十六进制02）；字符串"a"为整数0（联合中"string"的索引）；随后为序列化的字符串61，所以最后这个联合编码应为00 02 61。
（6）固定型（fixed）
固定型实例编码可使用模式中声明的字节数。对于编码成JSON类型，除了联合之外，还可以参照表16-1中JSON类型与Avro类型的对应关系进行编码。联合的JSON编码如下所示：
如果值为null，那么按照JSON null来编码；
否则，按照带有名称/值的JSON对象进行编码，其中名称为类型名称，值为递归编码值。对于Avro的命名类型（记录、固定性和枚举）将使用用户指定的名称，对于其他类型将使用类型名。
例如，对于联合模式["null"，"string"，"Foo"]，其中Foo是记录名称，应如此编码：null作为null编码；
字符串"a"按照{"string"："a"}编码；
Foo实例按照{"Foo"：{……}}编码，这里{……}表示一个Foo实例的JSON编码。
需要注意的是，正确处理JSON编码数据仍需要模式，因为JSON编码并不区分int和long、float和double、记录（records）和映射（maps）、枚举（enums）和字符串（strings）等。
[1]
 ZigZag编码原使用于Protocol Buffers，是一种将有符号数映射成无符号数的一种编码方式。
16.1.3 数据排列顺序
对象化前最常使用的操作就是排序，在Avro确定了数据标准排列顺序后，就允许系统写入的数据可以被另外的系统高效地排序了，这是个很重要的优化。即使Avro二进制数据还没有反序列化成对象，也可以对其进行高效排序。
要对拥有相同模式的数据项进行比较，可以采用对模式的深度优先、从左到右递归成对的方式。遇到不能匹配的项即按原来顺序，比如boolean类型的数据和int类型的数据不能匹配，那就不用进行排序。具体来说，相同模式的两个项进行比较时须遵从下面的规则。
null数据总是相等的。
boolean类型中false排在true的前面。
int、long、float和double数据按照数值升序排列。
bytes和fixed数据根据8位无符号值按照字典序进行比较。
string数据根据Unicode按字典序进行比较，要注意的是，对字符串而言，既然UTF-8作为二进制编码使用，那么按字节排序和按字符串二进制数据排序是相同的。array数据根据元素按字典序进行比较。
enum数据根据枚举模式中符号的位置进行排序。例如，枚举的符号位["z"，"a"]把"z"排在"a"前面。
union数据先按照联合的分支进行排序，然后按照分支的类型排序。例如，联合["int"，"string"]中，所有整型将排在所有字符型值前，而整型和字符型各自按照上面的规则排序。
record数据根据字段按字典序排序。如果字段指定其顺序为：
·"ascending"，其值排序的顺序不变；
·"descending"，其值排序的顺序反转；
·"ignore"，排序时其值将忽略。
map数据不进行比较。试图比较包含映射的数据是非法的，除非映射是“有序”的，否则“忽略”记录字段。
16.1.4 对象容器文件
序列化后的数据需要存入文件中。Avro包含一个简单的对象容器文件，一个文件拥有一个模式，文件中所有存储的对象必须根据模式使用二进制编码写入。对象存储在可以压缩的块中，块之间使用同步机制为MapReduce处理提供高效的文件分离。文件中可能包含用户随意指定的元数据。那么一个文件包含：
文件头。
一个或多个文件数据块。
其中文件头包含：
4个字节，分别是ASCII码的o、b、j、1。
包含模式的文件元数据。
为此文件随机生成的16字节同步器。
文件的元数据包含：
指示元数据的一个键/值对的长整型。
每个对的字符串键和字节值。
所有以"Avro"开头的元数据属性是保留的，以下文件元属性主要用于：
avro. schema，包含存储在文件中对象的模式，如JSON数据（必须）。
avro. codec，编解码器名称，其编码器用来压缩诸如字符串的数据块。需要实现支持"null"和"deflate"编解码器，如果没有编解码器，那假设为"null"。
"null"编解码器不需要对数据解压缩，而"deflate"编解码器使用文档RFC1951中指定的deflate算法写入数据块并使用zlib库实现，要注意的是这个格式（不像RFC1950中的zlib格式）没有校验和。
一个文件头需要按照如下模式进行描述：
{"type"："record"，"name"："org.apache.avro.file.Header"，
"fields"：[
{"name"："magic"，"type"：{"type"："fixed"，"name"："Magic"，"size"：4}}，
{"name"："meta"，"type"：{"type"："map"，"values"："bytes"}}，
{"name"："sync"，"type"：{"type"："fixed"，"name"："Sync"，"size"：16}}，
]
}
文件数据块包括：
一个长整型，用于指示块中对象数目。
一个长整型，用于表示使用编解码器后，所在块中序列化对象的字节大小。
序列化对象，如果编解码器是指定的，则用它进行压缩。
16字节的文件同步器。
这样，即使不用反序列化，每个块的二进制数据也可以高效获得或跳过。这种块的大小、对象数目和同步器的结合可以检测出坏的块并且帮助保持数据的完整性。
图16-3表示了对象容器文件的具体格式。
图 16-3 对象容器文件的具体格式
16.1.5 协议声明
当Avro用于RPC时，Avro使用协议描述远程过程调用RPC接口。和模式一样，它们是用JSON文本来定义的。协议是带有以下属性的JSON对象：
protocol，协议名称的字符串（必须）。
namespace，限定名称的可选字符串。
doc，描述协议的可选字符串。
types，指定类型（记录、枚举、固定型和错误）定义的可选列表。错误的定义和记录一样，只不过错误使用"error"而记录使用"record"，要注意不允许对指定类型的向前引用。
messages，一个可选的JSON对象，其键是消息名称，值是对象，任意两个消息不能拥有相同的名称。
模式中定义的名称和命名空间规则也同样适用于协议。下面介绍的协议消息可以拥有以下属性：
doc，消息的可选描述。
request，指定的类型化的参数模式列表（这和记录声明中的字段有相同的形式）。
response，响应模式。
error union，所声明的错误模式的联合（可选）。有效的联合会在声明的联合前面加上"string"，允许传递未声明的“系统”错误。例如，如果声明的错误联合是["AccessError"]，那么有效的联合是["string"，"AcessError"]。如果没有错误声明，那么有效的错误联合是["string"]。使用有效联合错误可以序列化，且协议的JSON声明只能包含声明过的联合。
one-way，布尔参数（可选）。
处理请求参数列表相当于处理没有名称的记录。既然读取的记录字段列表和写入的记录字段列表可以不同，那么调用者和响应者的请求参数也可以不同，这种区别的解决方法与记录字段间差异的解决方式相同。只有当回应的类型是“null”并且没有错误列出的时候，one-way参数才为真。
下面来举一个简单的HelloWorld协议的例子，它可以定义为：
{
"namespace"："com.acme"，//名称的限定
"protocol"："HelloWorld"，//协议名称
"doc"："Protocol Greetings"，//协议的说明