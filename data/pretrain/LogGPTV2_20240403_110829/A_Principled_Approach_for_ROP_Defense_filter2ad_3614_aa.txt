title:A Principled Approach for ROP Defense
author:Rui Qiao and
Mingwei Zhang and
R. Sekar
A Principled Approach for ROP Defense
Rui Qiao
Stony Brook University
PI:EMAIL
∗
Mingwei Zhang
Intel Labs
PI:EMAIL
R. Sekar
Stony Brook University
PI:EMAIL
ABSTRACT
Return-Oriented Programming (ROP) is an eﬀective attack
technique that can escape modern defenses such as DEP.
ROP is based on repeated abuse of existing code snippets
ending with return instructions (called gadgets), as com-
pared to using injected code. Several defense mechanisms
have been proposed to counter ROP by enforcing policies
on the targets of return instructions, and/or their frequency.
However, these policies have been repeatedly bypassed by
more advanced ROP attacks. While stricter policies have
the potential to thwart ROP, they lead to incompatibilities
which discourage their deployment.
In this work, we ad-
dress this challenge by presenting a principled approach for
ROP defense on COTS binaries. Our experimental evalu-
ation shows that our approach enforces a stronger policy,
while oﬀering better compatibility and performance as com-
pared to previous research. Our prototype is compatible
with many real-world and low-level programs. On SPEC
2006 benchmark program, it adds just 4% overhead above
the base overhead of 13% imposed by PSI, the platform used
in our implementation.
1.
Introduction
Programs written in C/C++ are not memory safe. Vul-
nerabilities such as buﬀer overﬂow, heap overﬂow and use-
after-free can be exploited by attackers to execute code of
their choice. Traditionally, attackers inject payload (called
shellcode) into the address space of a victim process, and
redirect control to this code. However, with widespread
deployment of Data Execution Prevention (DEP), injected
code is no longer executable, so attackers have come to
rely on code reuse attacks. Return-Oriented Programming
(ROP), which chains together a sequence of “gadgets” (code
sequences ending with return instructions), is the most pow-
erful and versatile among code reuse attacks.
Its power
stems from the pervasiveness of returns in binary code. As
a result, there are suﬃcient gadgets in a reasonably large
binary to perform Turing-complete computation. Although
variants such as Jump-oriented programming have been pro-
posed, ROP remains by far the most dominant code reuse
attack, and the only kind used repeatedly in real-world at-
tacks. For this reason, this paper focuses on ROP attacks,
and develops a principled approach for defeating them.
∗This work was completed when he was at Stony Brook University
†This work was supported in part by grants from NSF (CNS-
0831298 and CNS-1319137) and ONR (N00014-15-1-2378).
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
ACSAC ’15, December 07 - 11, 2015, Los Angeles, CA, USA
c(cid:13) 2015 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-3682-6/15/12. . . $15.00
DOI: http://dx.doi.org/10.1145/2818000.2818021
Code reuse attacks rely on repeated subversion of control-
ﬂows in the victim program. Given the nature of instruction
sets on modern processors, such subversion is possible only
with indirect control ﬂow transfer instructions. Control-ﬂow
integrity (CFI) is a general technique for limiting control-
ﬂow subversions by limiting the targets of such indirect con-
trol transfers. The idea of CFI is to restrict these targets
so that a program’s execution follows a control ﬂow graph
(CFG) that is computed by a static analysis.
CFI defeats most ROP attacks since they tend to violate
the statically computed CFG. However, determined attack-
ers can overcome CFI [17, 14] — speciﬁcally, coarse-grained
CFI that is based on simple static analyses can be defeated.
In fact, researchers have shown that a Turing-complete set
of gadgets is available on suﬃciently large applications even
when coarse-grained CFI is enforced [14].
Recognizing the weakness of coarse-grained CFI against
powerful adversaries, researchers have begun to develop tech-
niques for reﬁning CFI policies. These techniques can be
broadly classiﬁed into those for narrowing down the target
of forward edges, which include indirect calls and indirect
jumps, and those for narrowing down the backward edges,
consisting of returns. Several forward edge techniques have
been developed recently [23, 43, 37, 48], and some of them
are already being deployed in production compilers such as
gcc and llvm [43]. This factor can greatly reduce the threat
of code reuse attacks based on repeated subversion of for-
ward edges, e.g., call-oriented programming [6, 39]. How-
ever, mitigating the subversion of backward edges remains
a challenge. Although techniques for constraining returns
have been known for well over a decade [8, 9], they have not
seen wide deployment due to compatibility and performance
concerns. It is this factor that motivates our work.
The essential characteristic of ROP is the repeated use of
return instructions. Thus, techniques for constraining re-
turns can be very eﬀective in defeating ROP attacks. The
primary approach for conﬁning returns is the shadow stack,
which relies on a second stack that maintains a duplicate
copy of every return address. Each call instruction is modi-
ﬁed so that it stores a second copy of the return address on
the shadow stack. Before each return, the return address on
the top of the stack is compared with that atop the shadow
stack. A mismatch is indicative of an attack, and program
execution can be aborted before a successful control-ﬂow hi-
jack. However, previous shadow stack solutions suﬀer from
one or more of the following drawbacks:
• Incompleteness. Many shadow stack schemes are based
on compilers [8, 12]. They do not protect returns in
hand-written assembly code from low-level libraries such
as glibc and ld.so that are invariably present in every
application. Also left unprotected are third-party libraries
made available only in binary code form. Moreover, un-
intended returns (See Section 2.1) could be used in ROP,
and these won’t be checked against the shadow stack.
• Incompatibility.
In most complex applications, returns
don’t always match calls. If these exceptional cases are
not correctly handled, they lead to false positives that
deter practical deployment of shadow stack approaches.
• Lack of systematic protection from all ROP attacks. None
of the previous approaches provide a systematic analysis
of possible hijacks of returns, and how these attempts are
thwarted. Indeed, most previous approaches incorporate
exceptions to the shadow stack policy in order to achieve
compatibility. A resourceful adversary can exploit these
policy exceptions to carry out successful ROP attacks.
In this paper, we develop a new defense against ROP that
overcomes these drawbacks. We provide an overview of our
approach below, and summarize our key contributions.
1.1 Approach Overview
Our approach is based on the following simple policy:
Return instructions should transfer control to intended
return targets.
With a static interpretation of “intention”, many existing
coarse-grained CFI schemes can be seen as enforcing this
policy. However, as discussed before, a static interpretation
aﬀords far too many choices for return targets, allowing suc-
cessful ROP attacks to be mounted. We therefore take a
dynamic interpretation of intent. Speciﬁcally:
• The ability to return to a location is interpreted as a one-
time use capability. These capabilities are inferred from
and associated with speciﬁc parts of the program text,
e.g., a call instruction, or, a move instruction that stores
a function pointer on the stack, with the intent of using
this pointer as the target of a return. A return capability
is issued each time this program text is executed.
• These return capabilities must be used in a last-in-ﬁrst-
out (LIFO) order. As the term “capability” suggests, not
every intended return needs to be taken. Unexercised re-
turns arise naturally due to exception unwinding, thread
exits, and so on. However, we require that those return
capabilities that are exercised do follow a LIFO order.
The LIFO property of return capabilities means that they
can be maintained on a stack, which we will refer to as the
return capability stack (RCAP-stack).
1.2 Contributions
We make the following contributions in this paper:
• Static analysis to handle non-standard returns: While the
intended returns of call instructions are obvious, nontriv-
ial applications include many non-standard returns that
don’t match any calls. Unlike previous approaches that
relied on manual annotations to handle them, we present
an automated static analysis technique that identiﬁes (a)
non-standard returns, and (b) the intended targets of
these returns. Our analysis has been suﬃcient to han-
dle SPEC 2006 benchmarks as well as several complex
applications studied in our evaluation.
• Support for diverse threading mechanisms:
In addition
to non-standard returns, multi-threaded programs pose
a challenge for shadow stack mechanisms. This is be-
cause shadow stacks have to be created and switched in
sync with thread creation and switching. This challenge
is exacerbated in complex applications because they may
use a variety of threading mechanisms. We present a
uniﬁed, threading-mechanism-independent approach for
maintaining per-thread RCAP-stack, and transparently
switching to the right RCAP-stack at runtime, based on
the value of stack pointer at the point of return.
• Strict enforcement: By discovering and always pushing
the intended target on RCAP-stack, we avoid the need
for “whitelisting” return instructions. By subjecting all
returns to a strict policy, we take away an attacker’s ca-
pability to abuse even a single return instruction in the
protected application.
• In-depth evaluation: Our evaluation demonstrates excel-
lent compatibility as well as protection against attacks.
The overhead of our solution is signiﬁcantly lower than
previous techniques: just 3% over the base 14% overhead
posed by our platform PSI on SPEC 2006 benchmarks.
2. Background and Threat Model
2.1 ROP Attacks
Return-Oriented Programming (ROP) [40] is the most
prevalent form of code-reuse attack. It makes use of “gad-
gets,” i.e., existing code snippets ending with return instruc-
tions. A gadget used in a ROP attack could either be an
intended code sequence, or unaligned code, which refers to
unintended instruction sequence beginning from the middle
of an (intended) instruction. This is possible on variable-
length instruction-set architectures such as the x86.
To carry out a ROP-attack, it is necessary to subvert a
program’s intended control ﬂow. We develop an eﬀective
policy to break this step and hence prevent ROP attacks.
2.2 Control-Flow Integrity (CFI)
Control-ﬂow integrity is an important primitive for secure
static instrumentation [50, 47], as it can limit control ﬂows
so that instrumentation cannot be bypassed. Speciﬁcally,
control ﬂows cannot go to (a) middle of instructions, or (b)
an instruction within (or immediately following) an inserted
instrumentation snippet. For this reason, we build our de-
fense, which is based on static binary instrumentation, on a
platform that already implements CFI, speciﬁcally, the PSI
platform [50].
2.3 Threat Model
We assume a powerful remote attacker that can exploit
memory vulnerabilities to read or write arbitrary memory
locations, subject to OS-level permission settings on mem-
ory pages. We assume the attacker has no local program
execution privilege or physical access to the victim system.
We assume DEP is enabled on the victim system and
therefore ROP is a necessity for payload construction. We
also assume that ASLR is deployed, but attackers can use
memory corruption vulnerabilities to leak the information
needed to bypass it without resorting to brute-force.
3.
Inferring Intended Control Flow
As discussed earlier, we focus exclusively on return in-
structions. We do not attempt to further improve the (coarse-
grained) BinCFI policy [51] enforced on the remaining branch
types by our implementation platform, namely, PSI [50].
The ﬁrst task in enforcing a stronger policy on returns is
to precisely infer program-intended control ﬂow for each of
them. We develop a static analysis for this purpose. Speciﬁ-
cally, our analysis identiﬁes instructions that push addresses
that may later be used as the target for a return instruction.
As a fallback option, static analysis may be augmented with
manual annotations, but we have not had to do this so far.
0x146b4 movl %eax,(%esp)
0x146b7 ...
0x146bb ret $0xc
Figure 1: A non-standard return from ld.so
Based on the results of static analysis and/or annotations,
instrumentation is added to update RCAP-stack to keep
track of the return capabilities acquired by the program by
virtue of executing these instructions.
3.1 Calls
Most call instructions are used for function invocations
and therefore express an intent to return to the next instruc-
tion. However, it is up to the callee to decide whether the
return is actually exercised. For example, a call to exit()
will never return. Moreover, the call instructions themselves
may be used for purposes other than calling functions. For
instance, position-independent code (PIC) on x86 uses call
instructions to get the current program counter, from which
the base of the static data section is computed.
Unintended calls do not lead to compatibility problems
since we do not require all return capabilities to be used.