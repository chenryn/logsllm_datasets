for developers (but critical for system-wide dependence). For
example, while loading the CNN.com main page in ﬁrefox
generates 2583 application log entries, the same operation
leads to 107140 audit log entries, which contain information
not captured by the application log, such as conﬁguration
ﬁle accesses, cache ﬁle accesses, and network trafﬁc not
through the standard ﬁrefox APIs. In our example, the access
to secret.txt by the malicious fcopy is only visible at the syscall
level. Hence, our method is to fuse application log and audit
log so that on one hand, the rich application semantics can be
propagated to the syscall level, and on the other hand the low-
level background information recorded in the audit log can be
properly attributed to high-level application execution units,
precluding bogus dependencies.
ﬁrefoxx.x.x.xcopyfcopyz.z.z.zapachesecret.txtcheck.phpinfo.html……16:30:12 [23104] nsObserverService (TranID=0xf4a1d5b80) UpdateCurrentTopLevelOuterTabId id=200000001(a)21:17:46 [8890] mozStorage ATTACH ‘~/.thunderbird/INBOX’21:17:46 [8890] mozStorage (TranID=0x603c9b80)SELECT * FROM messageAttributes (folderID, messageID) VALUES (2, piMN2BuJQb)192.168.143.130 [05:09:23] "GET /index.html HTTP/1.1" 200 151 "-" "Wget/1.19.2 (linux-gnu)"(b)PATH 21:17:46 name=~/.thunderbird/INBOXSYSCALL 21:17:46 syscall=open exit=130 ppid=8262 pid=8890 exe=thunderbird(c)(d)anonymous.comfcopyﬁrefoxz.z.z.zapachefcopyscript_nx.x.x.xﬁrefox…fcopysecret.txtinfo.htmlSession1check.phpfcopyz.z.z.zsecret.txtinfo.htmlcheck.php(b) ALchemist graph(a) NoDoze graphy.y.y.yapachex.x.x.xTab1Speciﬁcally, as shown by Fig. 6, application logs and the
audit log (on the left) are ﬁrst normalized to a canonical
form using a set of parsers, one for each raw log format.
Building such parsers is an almost one-time effort as raw log
format rarely changes. A number of relations (like relations
in databases) can be directly derived from the normalized log
entries. For example, a relation initU nit(T ab X) means that
the current ﬁrefox tab is switched to a new T ab X. These basic
relations are provided to a Datalog inference engine [38] (in
the center of Fig. 6), which can derive new relations from the
basic ones following a set of pre-deﬁned rules. In particular,
these rules derive correlations and correspondence from both
the application log relations and the audit log relations. The
key is that these two levels of relations often share common
ﬁelds. For instance, Fig. 2(d) shows the thunderbird read of the
INBOX ﬁle in the audit log. Our technique projects it to the
high-level email access (corresponding to the application log
in Fig. 2(b)). Since application logs provide a clear execution
unit structure, by projecting such structure to the low level
audit log, we are able to achieve execution partitioning at the
audit level without any instrumentation. Fig. 3(b) shows the
graph by ALchemist. Observe that it avoids dependence ex-
plosion. That is, only the tab visiting the compromised website
(anonymous.com) is included, compared to the graph in Fig. 1
that includes the execution of all tabs. In addition, it precisely
identiﬁes that fcopy is generated by script n, which downloads
from x.x.x.x, as the execution of the different JS ﬁles (script 0
to script n) is correctly separated by ALchemist. Fig. 3(a)
presents the graph by NoDoze. Although it is also smaller
than that in Fig. 1, it cannot fully prune the false dependencies
of ﬁrefox as they are not frequent dependencies. It does not
contain tab information either. Furthermore, the graph cannot
indicate that fcopy is downloaded by the execution of a JS ﬁle
downloaded from x.x.x.x.
III. STUDY OF POPULAR LINUX APPLICATION
EXECUTION MODELS AND FEASIBILITY OF LOG FUSION
To study the feasibility and generality of our design, we
conduct a manual study of 32 Linux applications, which are
the union of 30 most popular applications listed in [1] and 15
complex applications widely used in the APT attack literature,
such as ﬁrefox, Thunderbird, Chromium, OpenOfﬁce, Libre-
Ofﬁce, and Apache. We aim to study their execution models
and available logs (including both built-in logs and the audit
log) to validate the following: (1) if log fusion can disclose
(implicit) information to identify execution units, including
interleaving/background units, and recover dependences that
are invisible in neither application logs or the audit
log;
(2) how often log format changes. The study focuses on the
applications’ background (asynchronous) activities, which are
the most prominent challenge in dependence analysis due
to their non-deterministic interleavings. The applications and
their execution models are listed in Table X in Appendix B.
We ﬁnd that these models can be divided into ﬁve different
categories, with each application using one or multiple models.
Class I: Handling Tasks Sequentially in A Single Process.
A number of applications are single process such as vim and
wget. They do not have asynchronous behavior, but rather
handle tasks one by one in a main loop. Vim uses the main
loop to execute user commands one by one. As shown in
Fig. 4: (a) Source code and log for vim 7.3 (b) Source code
and log for sshd 7.4
Fig. 4(a), it uses function auto_next_pat() to retrieve
the next command and then executes it. Inside the function,
vim leverages its logging function smsg()(line 5) to record
each executed command. These recorded commands can be
leveraged to identify units. For example, we partition vim’s
execution based on ﬁles, which are denoted by the ﬁle buffer
data structures internally, one buffer for each loaded ﬁle. Every
time the user opens/switches-to a window of some ﬁle, a
command “BufEnter” is executed. Every time the user exits
a window, a command “BufLeave” is executed. Lines 8-10
show a log entry for the command “BufEnter” that opens a
ﬁle “/home/user/Desktop/ file”. Since the execution
is sequential, all the low level audit events (e.g., ﬁle updates)
that happen between this command and the corresponding
“BufLeave” command can be correctly and safely attributed
to the unit of the ﬁle. In fact, we observe that the application
log contains so wealthy information that other partitioning
schemes (e.g., based on folders) can be supported.
Class II: Handling Tasks by Forking Additional Pro-
cesses. Some applications, especially those server applica-
tions that need privilege separation, fork processes for new
tasks. Fig. 4(b) shows a code snippet from sshd (lines 11-
17) for starting a new connection, and the corresponding log
event (line 18). The sshd daemon process invokes function
server_accept_loop() in a while loop to handle a
remote connection request. In the function, the daemon process
forks a child process to handle the request (line 13). The child
process may further spawn other processes for various func-
tionalities (e.g., authentication). The dependences of individual
subtasks can be precisely reﬂected by process creation, which
is captured by the audit log and sometimes by the application
log as well. For example, sshd logs task process creation
(line 14). Line 18 shows the corresponding application log.
Table X (in Appendix B) shows that there are quite a number of
applications in this class. For these applications, a unit consists
of a chain of inter-dependent processes.
Class III: Asynchronous Task Queue. A few applications
such as ﬁrefox, thunderbird, and foxit make use of a more
complex asynchronous execution model, in which the appli-
cation has a main thread and a number of worker threads
dedicated to some special functionalities. The main thread
receives independent tasks (from the user), such as loading
a page and accessing an email. It then dispatches the tasks
to worker threads. The worker threads work in a pipeline, for
example, a socket thread downloads a JS ﬁle and then hands
it over to the JS helper thread to compile and execute. Each
worker thread serves multiple tasks. The communication be-
tween main thread and worker threads, among worker threads
themselves, is through task queues. Such an asynchronous
execution model creates lots of difﬁculties for the low-level
audit logging system [53] as syscalls from different pages,
4
static void server_accept_loop(...) {...if ((pid = fork()) == 0) {    debug("Forked child %ld.", pid);    ...  }}07:25:47 sshd[1054] Forked child 1580(b)1112131415161718static void auto_next_pat(...) {...s = _("%s Auto commands for \"%s\"");sprintf((char *)sourcing_name, s, ...);smsg(("Executing %s"), sourcing_name);...}15:36:49 Executing BufEnter Auto commands for function LocalBrowse('/home/user/Desktop/file') 1 2345678910(a)Fig. 5: (c) Request processing in apache 2.4.20; (d)
Source code firefox 60.0 DOM thread and its app log
tabs, JS blobs, and other background tasks are all interleaving,
without any hints about their origins.
Firefox uses the NSPR logging module [11] which has
been the uniform logging component for all Mozilla appli-
cations for 10 years. NSPR deﬁnes and records a large set
of events that are important for Mozilla products. In the
context of ﬁrefox, it intercepts and records events such as
page loading, tab switches, and opening a page through some
hyper link. More importantly, it is designed particularly for
the asynchronous execution model. It
treats each sub-task
dispatched to some worker thread (e.g., saving a ﬁle) as a
transaction, uniquely identiﬁed by a transaction id. Each sub-
task dispatch is recorded as a transaction initialization event.
The end of a sub-task is recorded by a destruction event of the
transaction. Other events that happen within a transaction are
often recorded with the enclosing transaction id.
By observing the chain of transaction initializations (e.g., a
tab creates a transaction, which creates another transaction, and
so on), we can identify an execution unit. By fusing application
log events with the corresponding audit log events (e.g., the
events that record the same ﬁle access), we could project the
unit structure to the audit log. In addition, dependences with
high level semantics (such as clicking a hyperlink) and hence
invisible in the audit log can be inferred. An detailed example
can be found in Section IV-B.
Class IV: Thread Pool. Many applications adopt a scheme
slightly simpler than asynchronous task queue while providing
a similar level support of asynchrony. Speciﬁcally, they dis-
patch tasks to available threads in a thread pool. Take apache
as an example, in the code snippet in Fig. 5(c), the listener
thread ﬁrst acquires a pointer to the thread pool (line 20). Then
it listens to any requests through a while loop in lines 21-24.
Each time a request is received, it ﬁnds an idle thread from the
pool or waits when such threads are not available. The request
is then served by the thread. After handling a request, it logs
the request at line 23. Note that although it is clear that in this
execution model the handling of a request is a unit, we cannot
simply consider all behaviors in a worker thread belong to the
same unit as worker threads are being recycled. Instead, the
application log entry contains the IP of the remote request,
which can be leveraged to couple the application log entry
and the corresponding audit log entries (of the worker thread),
such as socket creation, read and write. Since a worker thread’s
execution is sequential, all the audit events in the time-span of
coupled audit events belong to the same unit. An example is
presented in Section IV-B.
Class V: Background Activities in Virtual Environment.
Many applications support
in
which (script) code blobs get executed. Such script languages
are often very powerful, capable of conducting activities as
internal virtual environment
Fig. 6: ALchemist’s workﬂow
complex as a full-ﬂedged application. While the execution of
a code blob can be correctly attributed to the proper execution
unit as such execution is usually performed through some
standard interface (e.g., the ﬁrefox-spidermonkey interface),
which is recorded in the application log, the code blob could
be designed in a way that itself induces the execution of other
code blobs. Log fusion can nonetheless handle these cases,
attributing the follow-up executions of other code blobs. In
ﬁrefox, a JS code blob can invoke other code blobs asyn-
chronously by registering them as event handlers. These events
could be as simple as timeouts. Speciﬁcally, a JS code blob can
call a built-in API SetTimeOut() (lines 32-38 in Fig. 5),
to instruct ﬁrefox to execute a speciﬁed code blob when the
timeout event happens. Function RunExpiredTimeouts()
(lines 40-44) handles timeout events. Both functions log the
current transaction id (line 34 and lines 41-42). Observe that
the resulted log entries (lines 27-31) clearly indicate the event
handling code blob and the original code blob share the same
transaction id, allowing correct unit partitioning. Other event
handling has a similar mechanism.
To summarize, our study shows that 30 of the 32 ap-
plications are long running, and 31 have built-in logs (or
some history ﬁles). All
the 31 applications’ built-in logs
record critical events that denote unit boundaries. Besides unit
boundaries, our study also shows that the fusion of built-in
logs and the audit log allows precisely tracking dependences
in complex asynchronous execution models such as worker
threads and thread pools, which can hardly be handled by exist-
ing techniques. For the 2 applications that are not long running,
one of them does not have built-in log. Note that even bash
has a history ﬁle that records all the interactive commands.
Individual commands can hence be considered as different
tasks such that dependence explosion through bash can be
avoided. It does not mean we will miss the inter-dependences
across commands as such dependences are visible at the audit
log level (e.g., through ﬁles accessed). More details about the
study can be found in Appendix B. We believe the reason that
popular and/or long running applications have informative and
well-designed built-in logs is that their developers tend to pay
a lot of attention to ease of maintenance. Our study further
shows that the design of logging component tends to be stable,
much stabler than the application itself. For example, ﬁrefox
has been using the same logging facility for 10 years while it
has 64 different releases in that period. More can be found in
Appendix A.
IV. SYSTEM DESIGN
In this section, we discuss the design details, including
how to normalize various logs to basic relations and how to
fuse them by performing inference and deriving new relations.
5
static void * APR_THREAD_FUNC listener_thread(...) {apr_pool_t *tpool = apr_thread_pool_get(thd);while (1) {    ...    apr_log(plog, s);  }  ...}(c)323334353637383940414243441920212223242526WorkerPrivate::SetTimeout(JSContext* aCx, ...) {  ...  LOG((“(TranID=%p) has new timeout:delay=%f”, ...));  rv = data->mTimer->InitWithCallback(               data->mTimerRunnable, delay,               nsITimer::TYPE_ONE_SHOT);}WorkerPrivate::RunExpiredTimeouts(JSContext* aCx) {  LOG((“(TranID=%p) executing timeout with original       delay %f ms.\n", ...));  ...}20:45:34 [9071] DOM Worker (TranID=0xae3ad5080) has new timeout: delay=5000ms...20:45:39 [9071] DOM Worker (TranID=0xae3ad5080) executing timeout with original delay 5000 ms(d)2728293031(d)LogDatalog EngineRelation QueryProvenance GraphPre-Deﬁned RulesNormalized RecordTarget RelationSymptom EventParsingVisualizingTABLE II: Normalized ﬁrefox log (top) and thunderbird log
(bottom), A1 denotes ﬁrefox and A2 denotes thunderbird, IP1
denotes IP 192.168.143.1
Index Time PID PNAME IP
TranID
UnitID
Action
URI
File
IP1
F1 15:54:252553 A1
F2 15:54:292553 A1
F3 15:54:482553 A1
Index Time PID PNAME IP
File
Action
UnitID
TranID
URI
-
resolve
- main.c request
- main.c createFile
-
0
-
a.com
fc9c51b0
fc9acb80 a.com/main.c
fd9b3380
-
Fig. 7: Examples of raw application logs (top) and the corre-
sponding audit logs (bottom). (a) Firefox saves main.c from
a.com to /tmp and opens it with vim; (b) User opens a
downloaded email from the local email box in Thunderbird
and clicks a hyper link in the email.
TABLE I: Normalized audit records, A1 denotes ﬁrefox and
A2 thunderbird, IP0 denotes 127.0.0.1, IP1 192.168.143.1
Action Return
PID PPID PNAME IP Port
Index
Time
File
S1
S2
S3
S4
S5
S6
S7
S8
15:54:25 2553 2275 A1
15:54:29 2553 2275 A1
15:54:48 2553 2275 A1
15:59:57 2842 2553 A1
18:06:22 8331 8262 A2
21:17:46 8331 8262 A2
21:29:30 8903 8331 A2
21:29:32 8903 8331 A2
IP0
IP1
-
-
-
-
-
-
53
80
-
-
-
-
-
-
-
-
main.c
vim
INBOX
INBOX
handlers.json
ﬁrefox
connect
connect
open
execve