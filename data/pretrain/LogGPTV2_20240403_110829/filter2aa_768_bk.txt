设备引导 
这需要先了解什么是 Option ROM。所谓 Option ROM 就是在位于 PCI 或者 ISA 设备
上的只读存储器，因为这个存储器不是总线标准规定一定要实现的，所以叫 Option ROM
（可选实现的 ROM）。Option ROM 里面通常存放着用于初始化该设备的数据和代码。显
卡和网卡等设备上通常带有 Option ROM。 
PnP BIOS 规约详细定义了 Option ROM 的格式。简单来说，在它的开始处，总是一个
固定结构的头结构，称为 PnP Option ROM Header，为了行文方便，我们将其简称为 PORH。
在 PORH 的偏移 18h 和 1Ah 处可以指向另外两个结构，分别称为 PCI 数据结构和 PnP 扩
展头结构（PnP Expansion Header），我们将其简称为 PEH。PEH 中有一个起到链表作用的
Next 字段（偏移 06h，长度为 WORD）用来描述下一个扩展结构的偏移。 
《软件调试》补编 
- 155 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 4  PnP 设备 Option ROM 中的头结构 
首先，所有的 Option ROM 的头两个字节都是 0xAA55，因此在调试时可以通过这个
签名来搜索或者辨别 Option ROM 的头结构。另外，PC 标准规定，0xC0000 到 0xEFFFF
这段物理内存地址空间是供 Option ROM 使用的。 
在图 4 中，以黄颜色标出的向量字段与引导有着比较密切的关系，下面分别作简单介
绍： 
初始化向量
初始化向量
初始化向量
初始化向量 – 系统固件在引导前会通过远调用执行这个地址所指向的代码，这就是
通常所说的执行 Option ROM。Option ROM 得到执行后，除了做初始化工作外，如果
该设备希望支持引导，那么可以通过改写（Hook）系统的 INT 13h（用于读写磁盘的
软中断）和输入设备来实现，上面提到过的传统 SCSI 硬盘就是这样做的。对于 PnP
设备，应该使用下面的 BCV 或者 BEV 方法。 
引导连接向量
引导连接向量
引导连接向量
引导连接向量（
（
（
（Boot Connect Vector）
）
）
） - 这个向量可以指向 Option ROM 中的一段代
码（通过相对于 Option ROM 起始处的偏移），当这段代码被 BIOS 调用后，它可以根
据需要改写（Hook）INT 13h。 
引导入口向量
引导入口向量
引导入口向量
引导入口向量（
（
（
（Boot Entry Vector）
）
）
） – 用来指向可以加载操作系统的代码的入口，
当系统准备从这个设备引导时，那么会执行这个向量所指向的代码。下面介绍的从网
卡通过 PXE 方式启动就是使用的这种方法。 
图 5 所示的是网卡设备的 Option ROM 内容，第 1 列是内存物理地址，后面四列是这
第一地址起始的 16 字节数据（以 DWORD 格式显示，每 4 字节一组）。图中第一个黄颜
色方框包围起来的 32 字节是 PORH 结构，它的 0x1A 偏移处的值 0x60 代表的是 PEH 结
构的偏移，因此下面的方框包围起来的便是这个扩展结构。 
《软件调试》补编 
- 156 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
图 5 观察 PnP 设备的引导入口向量 
根据图 4，在 PEH 结构的 0x1A 处的两个字节便是 BEV 向量，也就是 0x0c04。因此，
当在 BIOS 中选择从这个网卡引导时，BIOS 在做好引导准备工作后，便会通过远调用来
执行 0xcb00:0c04 处的代码。在调试时，如果对这个地址设置断点，那么便会命中。 
INT 19h 和
和
和
和 INT 18h 
BBS 还定义了两个软中断来支持引导，它们分别是发起引导的 INT 19h 和使用某一设
备引导失败后恢复重新引导的 INT 18h。 
下面列出的是 BBS 中给出的 INT 19h 的伪代码。 
IPLcount = current number of BAIDs and BEV devices at this boot. 
FOR (i = 0; i < IPLcount; ++i) 
currentIPL = IPL Priority[i]. 
Use currentIPL to index the IPL Table entry. 
Do a far call to the entry's boot handler or BEV. 
IF (control returns via RETF, or an INT 18h) 
Clean up the stack if necessary. 
ENDIF 
Execute an INT 18h instruction. 
其中，第 5 行的远调用便是把执行权交给了用于引导当前 IPL 设备的过程，如果这个
调用成功，那么便永远不会返回。 
下面是 INT 18h 的伪代码。 
Reset stack. 
IF (all IPL devices have been attempted) 
Print an error message that no O/S was found. 
Wait for a key stroke. 
Execute the INT 19h instruction. 
ELSE 
Determine which IPL device failed to boot. 
Jump to a label in the INT 19h handler to try the next IPL device. 
ENDIF 
需要说明的是，上面的伪代码完全是示意性的，实际的 BIOS 实现会更复杂而且可能
有所不同。 
《软件调试》补编 
- 157 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
使用
使用
使用
使用 Bochs 调试引导过程
调试引导过程
调试引导过程
调试引导过程 
除了可以使用 ITP 这样的硬件调试器来调试引导过程外，某些情况下，也可以使用虚
拟机来调试。具体来说就是把要调试的固件（BIOS 或者 EFI）文件配置到虚拟机中，然
后利用虚拟机管理软件的调试功能来调试。例如，Bochs 虚拟机便具有这样的功能。Bochs
目前是一个开源的项目，可以从它的网站 http://bochs.sourceforge.net/上下载安装文件和源
代码。 
图 6 中的屏幕截图便是使用 Bochs 调试的场景，大的窗口是虚拟机，重叠在大窗口上
的小窗口是 Bochs 的控制台，在里面可以输入各种调试命令。图中显示的是设置在 INT 19h
入口处（0xf000:e6f2）的断点命中时的状态。 
图 6 使用 Bochs 调试引导过程 
使用 xp 0x19*4 可以显示中断向量表中 INT 19h 所对应的内容，即 0xf000e6f2，其中
高 16 位是段地址，低 16 位是偏移。值得说明的是，大多数 BIOS 中的 INT 19h 的入口地
址都与此相同。知道了地址后，就可以使用 pb 0xfe6f2 来设置断点，其中 0xfe6f2 是
0xf000:e6f2 这个实模式地址对应的物理地址，其换算方法是把 0xf000 左移 4 个二进制位
（相当于在十六进制数的末尾加一个 0），然后加上偏移。 
顺便说一下，在 Bochs 项目中，实现了一个简单的 BIOS，其主要代码都位于 rombios.c
文
件
，
通
过
下
面
的
链
接
可
以
访
问
到
这
个
文
件
：
http://bochs.sourceforge.net/cgi-bin/lxr/source/bios/rombios.c 想学习 BIOS 的读者，可以仔细
读一下这个文件，这是深刻理解 BIOS 的很有效方法。 
0x7c00——
——
——
——新的起点
新的起点
新的起点
新的起点 
对于大多数时候使用从 BAID 设备引导，BIOS 中的支持函数会从设备（磁盘）的约
定位置读取引导扇区，存放到内存中 0x0000:7c00 这个位置，然后把控制权转交过去。转
交时会通过 DL 寄存器传递一个参数，这个参数用来指定磁盘号码，00 代表 A 盘，0x80
《软件调试》补编 
- 158 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
代表 C 盘。接下来的引导代码在通过 INT 13h 来访问磁盘时，应该使用这个参数来指定要
访问的磁盘。 
因为从磁盘引导时，BIOS 一定会把控制权移交到 0x7c00 这个地址，所以在调试时可
以在这个位置设置断点，开始分析和跟踪。表 2 列出了其它一些固定的 BIOS 入口地址。 
表 2  BIOS 兼容入口点 
地址 
用途 
0xf000:e05b  
POST 入口点 
0xf000:e2c3  
不可屏蔽中断（NMI）处理函数入口点 
0xf000:e3fe  
INT 13h 硬盘服务入口点 
0xf000:e401  
硬盘参数表 
0xf000:e6f2  
INT 19h（引导加载服务）入口点 
0xf000:e6f5  
配置数据表 
0xf000:e739  
INT 14h 入口点 
0xf000:e82e  
INT 16h 入口点 
0xf000:e987  
INT 09h 入口点 
0xf000:ec59  
INT 13h 软盘服务入口点 
0xf000:ef57  
INT 0Eh（Diskette Hardware ISR）入口点 
0xf000:efc7  
软盘控制器参数表 
0xf000:efd2  
INT 17h（打印机服务）入口点 
0xf000:f065  
INT 10h（显示服务）入口点 
0xf000:f0a4  
MDA/CGA 显示参数表 (INT 1Dh) 
0xf000:f841  
INT 12h（内存大小服务）入口点 
0xf000:f84d  
INT 11h 入口点 
0xf000:f859  
INT 15h（系统服务）入口点 
0xf000:fa6e  
低 128 个字符的图形模式字体 
0xf000:fe6e  
INT 1Ah（时间服务）入口点 
0xf000:fea5  
INT 08h（System Timer ISR）入口点 
0xf000:fef3  
POST 用这个值来初始化中断向量表 
0xf000:ff53  
只包含 IRET 指令的 dummy 中断处理过程 
0xf000:ff54  
INT 05h（屏幕打印服务）的入口点 
0xf000:fff0  
CPU 复位后的执行起点 
0xf000:fff5  
构建日期，按 MM/DD/YY 格式，共 8 个字符 
0xf000:fffe  
系统型号 
另外，地址 0x0040:0000 开始的 257 个字节是所谓的 BIOS 数据区（BIOS Data Area），
简称 BDA，里面按固定格式存放了 BIOS 向后面的引导程序和操作系统移交的信息。 
下一期的问题： 
一台 PC 系统开机后显示 Windows could not start because of a general computer 
hardware configuration problem.，对于这样的问题有哪些方法来调试和解决？（注：上期的
问题留到下一期给出答案） 
《软件调试》补编 
- 159 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
步步为营——如何调试操作系统加载阶
段的故障 
上一期我们介绍了系统固件（BIOS）寻找不同类型的引导设备的方法，描述了固件
向引导设备移交执行权的过程。对于从硬盘引导，首先接受控制权的是位于硬盘的 0 面 0
道 0 扇区中的主引导记录（Main Boot Record），简称 MBR。MBR 一共有 512 个字节，起
始处为长度不超过 446 字节的代码，然后是 64 个字节长的分区表，最后两个字节固定是
0x55 和 oxAA。MBR 中的代码会在分区表中寻找活动的分区，找到后，它会使用 INT 13h
将活动分区的引导扇区（Boot Sector）加载到内存中，加载成功后，将执行权移交过去。
按照惯例，引导扇区也应该被加载到 0x7C00 这个内存位置，所以 MBR 代码通常会先把
自己复制到 0x600 开始的 512 个字节，以便给引导扇区腾出位置。也正是因为这个原因，
当使用虚拟机或者 ITP 调试时，如果在 0x7C00 处设置断点，那么这个断点通常会命中两
次。引导扇区的内容是和操作系统相关的，在安装操作系统时，操作系统的安装程序会设