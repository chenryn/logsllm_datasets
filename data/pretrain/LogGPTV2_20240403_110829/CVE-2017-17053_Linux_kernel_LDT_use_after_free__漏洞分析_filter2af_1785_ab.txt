        retval = copy_thread_tls(clone_flags, stack_start, stack_size, p, tls);
        if (retval)
            goto bad_fork_cleanup_io;
        if (pid != &init_struct_pid) {
            pid = alloc_pid(p->nsproxy->pid_ns_for_children);
            if (IS_ERR(pid)) {
                retval = PTR_ERR(pid);
                goto bad_fork_cleanup_thread;
            }
        }
    ... snip ...
    }
​ 在`copy_process()`中，涉及到`ldt_struct`对象指针拷贝的点是在`dup_mm()`中，内核函数调用序列是`...snip..
-> copy_process() -> copy_mm() ->
dup_mm()`。其中`dup_mm()`中涉及`ldt_struct`对象的拷贝操作(`struct mm_struct
*`包含`ldt_struct`指针)如下所示。由于使用了`modify_ldt()`系统调用，父进程的`mm_struct`
定然会包含已经分配的`ldt_struct`指针，所以`memcpy()`后，新的`mm_strcut`中会包含父进程的`ldt_struct`对象指针。
    static struct mm_struct *dup_mm(struct task_struct *tsk)
    {
    ... snip ...
        mm = allocate_mm();
        if (!mm)
            goto fail_nomem;
        memcpy(mm, oldmm, sizeof(*mm));    // user_ns))    // user_ns = get_user_ns(user_ns);
        return mm;
    fail_nocontext:
        mm_free_pgd(mm);
    fail_nopgd:
        free_mm(mm);
        return NULL;
    }
###  3) 漏洞代码
​ 接着继续分析
`init_new_context()`，`init_new_context()`中又会调用`init_new_context_ldt()`,如下所示:
    static inline int init_new_context(struct task_struct *tsk,
                       struct mm_struct *mm)
    {
        #ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
        if (cpu_feature_enabled(X86_FEATURE_OSPKE)) {
            /* pkey 0 is the default and always allocated */
            mm->context.pkey_allocation_map = 0x1;
            /* -1 means unallocated or invalid */
            mm->context.execute_only_pkey = -1;
        }
        #endif
        init_new_context_ldt(tsk, mm);    // context.ldt`指针，覆盖掉之前从父进程拷贝来的旧指针。如果`alloc_ldt_struct()`执行失败直接返回，则不会更新`mm->context.ldt`的旧指针。而且由于`init_new_context()`没有对返回值的判断，当作分配成功处理，那么此时子进程中的`mm_struct`仍然包含着父进程残留的`mm->context.ldt`指针。假设该子进程退出（如PoC的`C`处，使用`exit_group`内核会产生fatal
signal），并执行相应内存释放函数，那么`mm->context.ldt`所指向的属于父进程的对象`ldt_struct`也会进行释放,
如下代码片段所示。在之后的过程中该对象指针仍然被父进程所能引用，那么最终就会在`ldt_struct`对象上产生UAF漏洞。
    static __latent_entropy struct task_struct *copy_process(
                        unsigned long clone_flags,
                        unsigned long stack_start,
                        unsigned long stack_size,
                        int __user *child_tidptr,
                        struct pid *pid,
                        int trace,
                        unsigned long tls,
                        int node)
    {
        int retval;
    ... snip ...
        recalc_sigpending();
        if (signal_pending(current)) {    // sighand->siglock);
        write_unlock_irq(&tasklist_lock);
        cgroup_cancel_fork(p);
    bad_fork_free_pid:
        cgroup_threadgroup_change_end(current);
        if (pid != &init_struct_pid)
            free_pid(pid);
    ... snip ...
        delayacct_tsk_free(p);
    bad_fork_cleanup_count:
        atomic_dec(&p->cred->user->processes);
        exit_creds(p);
    bad_fork_free:
        p->state = TASK_DEAD;
        put_task_stack(p);
        free_task(p);
    fork_out:
        return ERR_PTR(retval);
    }
### 4）如何使`alloc_ldt_struct()`失败
​
至此，漏洞原理和触发流程基本分析清楚，但是仍然有一个疑点(也是重点)还悬而未决。那就是在用户态通过何种方式，能使得`alloc_ldt_struct()`
执行失败呢？
​ 先分析下`alloc_ldt_struct()`的代码:
    static struct ldt_struct *alloc_ldt_struct(unsigned int size)
    {
        struct ldt_struct *new_ldt;
        unsigned int alloc_size;
        if (size > LDT_ENTRIES)
            return NULL;
        new_ldt = kmalloc(sizeof(struct ldt_struct), GFP_KERNEL);
        if (!new_ldt)
            return NULL;
        BUILD_BUG_ON(LDT_ENTRY_SIZE != sizeof(struct desc_struct));
        alloc_size = size * LDT_ENTRY_SIZE;
        if (alloc_size > PAGE_SIZE)
            new_ldt->entries = vzalloc(alloc_size);    // entries = (void *)get_zeroed_page(GFP_KERNEL);
        if (!new_ldt->entries) {
            kfree(new_ldt);
            return NULL;
        }
        new_ldt->size = size;
        return new_ldt;
    }
​
代码中会使用`kmalloc`分配`ldt_struct`，但是我们的目的是让`alloc_ldt_struct()`返回失败，也就是返回为NULL。可以很容易发现，当`new_ldt->entries`为NULL时，则最终返回结果为NULL，且影响其结果的有这两句：`new_ldt->entries
= vzalloc(alloc_size);`和`new_ldt->entries = (void
*)get_zeroed_page(GFP_KERNEL);`，后者我们并不可控，而前者是可控的，因为`size`参数可以在用户态指定并传入内核,如PoC的`D`处。并且`PAGE_SIZE
nr_pages; i++) {
            struct page *page;
            if (fatal_signal_pending(current)) {    // nr_pages = i;
                goto fail_no_warn;
            }
            if (node == NUMA_NO_NODE)
                page = alloc_page(alloc_mask|highmem_mask);
            else
                page = alloc_pages_node(node, alloc_mask|highmem_mask, 0);
            if (unlikely(!page)) {
                /* Successfully allocated i pages, free them in __vunmap() */
                area->nr_pages = i;
                goto fail;
            }
            area->pages[i] = page;
            if (gfpflags_allow_blocking(gfp_mask|highmem_mask))
                cond_resched();
        }
    ... snip ...
      fail_no_warn:
        vfree(area->addr);
        return NULL;    // entries array, and after
    commit:
      5d17a73a2ebe ("vmalloc: back off when the current task is killed")
    it is possible for userspace to fail a task's vmalloc() by
    sending a fatal signal, e.g. via exit_group().  It would be more
    difficult to reproduce this bug on kernels without that commit.
​ `5d17a73a2ebe ("vmalloc: back off when the current task is
killed")`,显示在`vmalloc`内核内存分配方式下，如果任务被kill掉，那么vmalloc会提前进行返回。这么做的目的也是为了节约系统内存，以防内存资源滥用。具体`5d17a73a2ebe`commit细节如下:
    root@xxx:~/git_new/linux-stable# git show 5d17a73a2ebe
    commit 5d17a73a2ebeb8d1c6924b91e53ab2650fe86ffb
    Author: Michal Hocko 
    Date:   Fri Feb 24 14:58:53 2017 -0800
        vmalloc: back off when the current task is killed
        __vmalloc_area_node() allocates pages to cover the requested vmalloc
        size.  This can be a lot of memory.  If the current task is killed by
        the OOM killer, and thus has an unlimited access to memory reserves, it
        can consume all the memory theoretically.  Fix this by checking for
        fatal_signal_pending and back off early.
        Link: http://lkml.kernel.org/r/PI:EMAIL
        Signed-off-by: Michal Hocko 
        Reviewed-by: Christoph Hellwig 
        Cc: Tetsuo Handa 
        Cc: Al Viro 
        Signed-off-by: Andrew Morton 
        Signed-off-by: Linus Torvalds 
    diff --git a/mm/vmalloc.c b/mm/vmalloc.c
    index d89034a393f2..011b446f8758 100644
    --- a/mm/vmalloc.c
    +++ b/mm/vmalloc.c
    @@ -1642,6 +1642,11 @@ static void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,
            for (i = 0; i nr_pages; i++) {
                    struct page *page;
    +               if (fatal_signal_pending(current)) {
    +                       area->nr_pages = i;
    +                       goto fail;
    +               }
    +
                    if (node == NUMA_NO_NODE)
                            page = alloc_page(alloc_mask);
                    else
## 6\. 漏洞补丁
    Diffstat
    -rw-r--r--    arch/x86/include/asm/mmu_context.h    4    
    1 files changed, 1 insertions, 3 deletions
    diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h
    index 265c907..7a234be 100644
    --- a/arch/x86/include/asm/mmu_context.h
    +++ b/arch/x86/include/asm/mmu_context.h
    @@ -140,9 +140,7 @@ static inline int init_new_context(struct task_struct *tsk,
             mm->context.execute_only_pkey = -1;
         }
         #endif
    -    init_new_context_ldt(tsk, mm);
    -    -    return 0;
    +    return init_new_context_ldt(tsk, mm);
     }
     static inline void destroy_context(struct mm_struct *mm)
     {
## 7\. 总结
​
虽然漏洞是由于较为低级的编码错误所引入的，且补丁也较为简单，但是其中涉及的细节还是极有意思的，比如:内核中fork进程的细节和`vmalloc`分配时所受外界的影响。另外这种漏洞模型也是值得继续探究的。关于此漏洞的漏洞利用，笔者认为其利用的难度较大。因为fork、exit_group和alloc_ldt_struct三者发生的时机较为紧凑，这就导致利用时refill
object难度提高不少。如果你有该漏洞利用的思路或者发现我的漏洞分析有什么错误，欢迎联系我，对我进行批评斧正。
qq: **3453203911**