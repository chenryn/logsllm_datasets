  interface	
(SPI)	
  used	
  for	
  some	
  of	
  the	
  most	
  important	
  functions	
  such	
  as	
  driving	
  the	
  coil	
  and	
  reading	
  from	
  the	
analogue-­‐digital	
  converters.	
  The	
  FPGA	
  also	
  implements	
  a	
  synchronous	
  serial	
  port	
  (SSP)	
  used	
  for	
communicating	
  data	
  from	
  the	
  FPGA	
  to	
  the	
  ARM	
  in	
  low	
  frequency	
  mode.	
Figure	
  4	
  Annotated	
  Proxmark3	
  (Xiling	
  Spartan-­‐II	
  FPGA)	
5	
  https://github.com/Proxmark/proxmark3	
6	
  http://store.ryscc.com/collections/proxmark-­‐3/products/naked-­‐proxmark-­‐3	
  [$229	
  as	
  of	
  7/17/2015]	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
Proxmark3’s	
  CPU	
An	
  ATMEL	
  32-­‐bit	
  RISC	
  processor	
  (AT91SAM7SXX	
  series)	
  handles	
  all	
  of	
  the	
  high	
  level	
  functions	
  on	
  the	
proxmark3	
  board.	
  The	
  ARM	
  processor	
  also	
  loads	
  configurations	
  into	
  the	
  FPGA	
  for	
  different	
  modes	
  of	
operations	
  such	
  as	
  switching	
  between	
  high	
  frequency	
  and	
  low	
  frequency	
  modes.	
  All	
  USB	
  communication	
from	
  the	
  client	
  application	
  is	
  handled	
  within	
  the	
  ARM	
  processor	
  before	
  deciding	
  what	
  if	
  any	
  action	
  must	
occur	
  with	
  the	
  FPGA.	
Source	
  for	
  the	
  program	
  running	
  on	
  the	
  CPU	
  is	
  found	
  in	
  the	
  armsrc	
  path.7	
  The	
  main	
  logic	
  on	
  the	
  ARM	
processor	
  is	
  in	
  AppMain()	
  within	
  the	
  appmain.c.	
  After	
  initializing	
  the	
  device,	
  the	
  ARM	
  loops	
  checking	
  for	
USB	
  commands	
  or	
  button	
  presses.	
  Commands	
  sent	
  over	
  the	
  USB	
  serial	
  link	
  are	
  represented	
  with	
  opcodes	
defined	
  across	
  header	
  files8	
  and	
  also	
  maintained	
  in	
  a	
  LUA	
  script9.	
  UsbPacketReceived()	
  translates	
  these	
commands	
  into	
  function	
  calls	
  on	
  the	
  ARM.	
Figure	
  5	
  ATMEL	
  32-­‐bit	
  RISK	
  Microcontroller	
Samples	
  from	
  the	
  FPGA	
  are	
  stored	
  in	
  a	
  DMA	
  buffer	
  on	
  the	
  ARM	
  referred	
  to	
  as	
  BigBuf.	
  This	
  data	
  may	
  be	
samples	
  from	
  the	
  ADC	
  or	
  data	
  for	
  the	
  Mifare	
  emulator.	
  In	
  sniffer	
  mode,	
  the	
  ARM	
  can	
  attempt	
  to	
simultaneously	
  decode	
  signals	
  with	
  both	
  Manchester	
  and	
  Modified	
  Miller	
  encoding	
  looking	
  for	
  a	
  valid	
signal.	
  Contents	
  can	
  also	
  naturally	
  be	
  sent	
  to	
  the	
  host	
  for	
  other	
  types	
  of	
  analysis	
  including	
  visual	
inspection.	
  (Refer	
  to	
  BigBuf.c	
  for	
  buffer	
  related	
  functions.)	
7	
  https://github.com/Proxmark/proxmark3/tree/master/armsrc	
8	
  https://github.com/Proxmark/proxmark3/search?q="define+CMD_ACK"&type=Code	
9	
  https://github.com/Proxmark/proxmark3/blob/master/client/lualibs/commands.lua	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
Proxmark3’s	
  ADC	
The	
  Spartan-­‐II	
  FPGA	
  connects	
  to	
  a	
  Texas	
  Instruments	
  TLC5540	
  analogue-­‐to-­‐digital	
  converter	
  (ADC).	
  This	
8-­‐bit	
  ADC	
  sends	
  readings	
  from	
  the	
  coil	
  to	
  the	
  FPGA	
  across	
  an	
  8-­‐pin	
  bus.	
  The	
  FPGA	
  uses	
  the	
  serial	
peripheral	
  interface	
  (SPI)	
  to	
  control	
  the	
  ADC	
  and	
  SSP	
  to	
  share	
  data	
  to	
  the	
  ARM.	
  The	
  TLC5540	
  collects	
  up	
to	
  40	
  million	
  samples	
  per	
  second	
  giving	
  a	
  theoretical	
  maximum	
  of	
  20MHz	
  per	
  the	
  Nyquist	
  rate.	
Figure	
  6	
  TI	
  TLC5540	
  8-­‐bit	
  40MSPS	
  ADC	
Proxmark3’s	
  Connections	
The	
  proxmark3	
  design	
  uses	
  a	
  hirose	
  4-­‐pin	
  connector	
  for	
  the	
  antenna	
  along	
  with	
  mini-­‐USB	
  for	
  both	
  data	
and	
  power.	
  USB	
  support	
  emulates	
  a	
  USB	
  serial	
  connection	
  allowing	
  it	
  to	
  operate	
  without	
  any	
  driver	
installation	
  on	
  most	
  systems.	
  Proxmark3	
  also	
  offers	
  general	
  purpose	
  and	
  JTAG	
  pins	
  outside	
  of	
  the	
  scope	
of	
  this	
  document.	
  For	
  human	
  I/O,	
  there	
  is	
  a	
  single	
  button	
  and	
  a	
  whole	
  lot	
  of	
  lights	
  to	
  provide	
  feedback	
about	
  the	
  proxmark3	
  status	
  while	
  in	
  operation.	
Figure	
  7	
  Proxmark3	
  I/O	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
The	
  NXP	
  PN533	
  NFC	
  Transceiver	
  Chipset	
The	
  PN5333	
  transceiver	
  module	
  is	
  fully	
  compatible	
  with	
  ISO14443a,	
  ISO14443b,	
  and	
  FeliCa	
  tags	
  in	
reader	
  and	
  writer	
  mode10.	
  It	
  is	
  also	
  interoperable	
  with	
  ISO18092,	
  ECMA	
  340	
  peer-­‐to-­‐peer	
communication	
  and	
  comes	
  in	
  a	
  convenient	
  USB	
  enclosure	
  complete	
  with	
  libNFC	
  support.	
  This	
  tool	
benefits	
  from	
  the	
  NXP	
  chipset	
  ensuring	
  better	
  interoperability	
  especially	
  with	
  changeable	
  UID	
  tags.	
  This	
USB	
  dongle	
  also	
  gives	
  the	
  opportunity	
  to	
  experiment	
  a	
  little	
  more	
  freely	
  with	
  Linux	
  RFID	
  tools	
  such	
  as	
  the	
NFC	
  tools	
  included	
  with	
  Kali	
  Linux.	
  The	
  PN533	
  USB	
  package	
  is	
  available	
  from	
  a	
  variety	
  of	
  sources	
generally	
  ranging	
  from	
  $40-­‐$60	
  including	
  test	
  cards.	
Figure	
  8	
  Example	
  PN533	
  USB	
  Dongle	
With	
  support	
  for	
  most	
  popular	
  Linux	
  distributions	
  as	
  well	
  as	
  OS	
  X	
  and	
  Windows,	
  Libnfc	
  is	
  a	
  great	
  tool	
  for	
identifying	
  tags	
  and	
  performing	
  research	
  on	
  target	
  systems.11	
  The	
  PN533	
  is	
  just	
  one	
  of	
  many	
  available	
NFC	
  USB	
  peripherals	
  available	
  with	
  support	
  for	
  libNFC.	
RFIDler	
A	
  product	
  of	
  Aperture	
  Labs,	
  RFIDler,	
  originally	
  was	
  funded	
  via	
  Kickstarter12	
  and	
  was	
  available	
  for	
  sale	
  as	
the	
  ‘v22-­‐beta’	
  revision	
  board	
  and	
  coil	
  at	
  DEF	
  CON	
  22.	
  The	
  goal	
  of	
  RFIDler	
  is	
  to	
  create	
  an	
  extremely	
  simply	
and	
  low	
  cost	
  circuitry	
  for	
  interacting	
  with	
  low	
  frequency	
  RFID.	
  The	
  circuits	
  use	
  outputs	
  from	
  a	
  PIC	
microcontroller	
  along	
  with	
  basic	
  analogue	
  circuitry	
  to	
  form	
  and	
  read	
  125kHz	
  modulated	
  signals.	
  A	
  3d	
case	
  was	
  designed	
  by	
  Aperture	
  Labs	
  and	
  published	
  as	
  a	
  free	
  model	
  on	
  Thingiverse13.	
RFIDler	
  Internals	
A	
  basic	
  LC	
  tank	
  is	
  used	
  for	
  the	
  antenna	
  driven	
  by	
  the	
  PIC32	
  microcontroller	
  and	
  amplified	
  with	
  the	
analogue	
  components.	
  Digital	
  potentiometers	
  are	
  used	
  to	
  control	
  thresholds	
  for	
  determining	
  logic	
  levels	
while	
  interpreting	
  signals.	
  Numerous	
  LED	
  outputs	
  can	
  be	
  used	
  to	
  visually	
  indicate	
  the	
  device	
  status.	
Automatic	
  command	
  execution	
  allows	
  for	
  a	
  basic	
  stand-­‐alone	
  operation.	
10	
  http://www.nxp.com/documents/short_data_sheet/PN533_SDS.pdf	
11	
  http://nfc-­‐tools.org/index.php?title=Libnfc	
12	
  https://www.kickstarter.com/projects/1708444109/rfidler-­‐a-­‐software-­‐defined-­‐rfid-­‐reader-­‐writer-­‐
emul	
13	
  http://www.thingiverse.com/thing:427536	
HOW	
  TO	
  TRAIN	
  YOUR	
  RFID	
  HACKING	
  TOOLS	
Figure	
  9	
  The	
  Annotated	
  RFIDler	
Unfortunately	
  the	
  RFIDler	
  acquired	
  at	
  DEF	
  CON	
  22	
  for	
  this	
  research	
  has	
  problems	
  reading	
  most	
  tag	
formats.	
  With	
  each	
  tag	
  it	
  has	
  been	
  necessary	
  to	
  spend	
  a	
  good	
  bit	
  of	
  time	
  finding	
  the	
  sweet	
  spot	
  and	
adjusting	
  POTSET	
  values.	
  A	
  rectangular	
  multi-­‐layer	
  coil	
  antenna	
  tuned	
  for	
  the	
  RFIDler	
  v22-­‐beta	
  board	
was	
  made	
  but	
  it	
  was	
  still	
  not	
  possible	
  to	
  get	
  consistent	
  tag	
  reads.	
  Furthermore	
  our	
  RFIDler	
  has	
  a	
tendency	
  to	
  actually	
  indicate	