Friday the 13th: JSON Attacks
Alvaro Muñoz (@pwntester)
Oleksandr Mirosh
HPE Security
> whoami
• Alvaro Muñoz
• Security Research with HPE
• Int3pids CTF player
• @pwntester
• Oleksandr Mirosh
• Security Research with HPE
Introduction
• 2016 was the year of Java Deserialization apocalypse
• Known vector since 2011
• Previous lack of good RCE gadgets in common libraries
• Apache Commons-Collections Gadget caught many off-guard.
• Solution?
• Stop using Java serialization
• Use a secureJSON/XML serializer instead
• Do not let history repeat itself
• Raise awareness for .NET deserialization vulnerabilities
• Is JSON/XML/ any better?
Agenda
1. Attacking JSON serializers
• Affected Libraries
• Gadgets
• Demo
2. Attacking .NET serializers
• Affected formatters
• Gadgets
• Demo
3. Generalizing the attack
• Demo
Is JSON any better?
Introduction
• Probably secure when used to transmit data and simple JS objects
• Replacing Java/.NET serialization with JSON requires OOP support.
• How do we serialize a System.lang.Objectfield?
• How do we deal with generics?
• How do we serialize interface fields?
• How do we deal with polymorphism?
Quick recap of Java deser attacks
• Attackers can force the execution of any readObject() / 
readResolve() methods of any class sitting in the classpath
• By controlling the deserialized field values attackers may abuse the 
logic of these methods to run arbitrary code
• JSON libraries do not (normally) invoke deserialization callbacks or 
magic methods
Can we initiate a gadget chain in some other way?
Sure we can
• JSON libraries need to reconstruct objects by either:
• Calling default constructor and using reflection to set field values
• Default constructor is parameterless so useless for attack purposes
• Reflection does not invoke any object methods but deserializer may do
• Calling default constructor and calling setters to set field values
• Can we find setters that would allow us to run arbitrary code?
• Calling “special” constructors, type converters or callbacks
• Can be used to bridge into other formatters or as start-chain gadgets
• Calling common methods such as: 
• hashcode(), toString(), equals(), finalize(), …
• Combinations of the previous ones ☺
Gadgets: .NET Edition
• System.Configuration.Install.AssemblyInstaller
• set_Path
• Execute payload on local assembly load
• System.Activities.Presentation.WorkflowDesigner
• set_PropertyInspectorFontAndColorData
• Arbitrary XAML load
• Requires Single Threaded Apartment (STA) thread
• System.Windows.ResourceDictionary
• set_Source
• Arbitrary XAML load
• Required to be able to work with setters of types derived from IDictionary
• System.Windows.Data.ObjectDataProvider
• set_(MethodName| ObjectInstance| ObjectType)
• Arbitrary Method Invocation
ObjectDataProvider
{"$type": "System.Windows.Data.ObjectDataProvider, PresentationFramework",
"ObjectInstance":{
"$type":"System.Diagnostics.Process, System”},
"MethodParameters":{
"$type":"System.Collections.ArrayList, mscorlib",
"$values":["calc"]},
"MethodName":"Start"
}
•
Non-default constructor with controlled parameters 
•
ObjectType + ConstructorParameters
•
Any public instance method of unmarshaled object without parameters
•
ObjectInstance + MethodName
•
Any public static/instance method with controlled parameters
•
ObjectType + ConstructorParameters + MethodName + MethodParameters
ObjectDataProvider
http://referencesource.microsoft.com/#PresentationFramework/Framework/System/Windows/Data/ObjectDataProvider.cs,d63c16f7bc3251a9
ObjectDataProvider
http://referencesource.microsoft.com/#PresentationFramework/Framework/System/Windows/Data/ObjectDataProvider.cs,d63c16f7bc3251a9
ObjectDataProvider
…
http://referencesource.microsoft.com/#PresentationFramework/Framework/System/Windows/Data/ObjectDataProvider.cs,d63c16f7bc3251a9
ObjectDataProvider
http://referencesource.microsoft.com/#PresentationFramework/Framework/System/Windows/Data/ObjectDataProvider.cs,d63c16f7bc3251a9
Gadgets: Java Edition
• org.hibernate.jmx.StatisticsService
• setSessionFactoryJNDIName
• JNDI lookup 
• Presented during our JNDI attacks talk at BlackHat 2016
• com.atomikos.icatch.jta.RemoteClientUserTransaction
• toString
• JNDI lookup 
• com.sun.rowset.JdbcRowSetImpl
• setAutoCommit
• JNDI lookup
• Available in Java JRE
JdbcRowSetImpl.setAutoCommit
http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/com/sun/rowset/JdbcRowSetImpl.java/
JdbcRowSetImpl.setAutoCommit
http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/com/sun/rowset/JdbcRowSetImpl.java/
Gadgets: non RCE
.NET
• System.Xml.XmlDocument/XmlDataDocument
• set_InnerXml
• XXE on .NET before 4.5.2 
• System.Data.DataViewManager
• set_DataViewSettingCollectionString
• XXE on .NET before 4.5.2 
• System.Windows.Forms.BindingSource
• set_DataMember
• Arbitrary getter call which can be used to chain to other gadgets
Java
• org.antlr.stringtemplate.StringTemplate
• toString
• Arbitrary getter call which can be used to chain to other gadgets such as the infamous 
TemplatesImpl.getOutputProperties()
Analyzed Libraries
• We analyzed different Java/.NET JSON libraries to determine whether 
these libraries could lead to arbitrary code execution upon 
deserialization of untrusted data in their default configuration or 
under special configurations.
• Requirements
• Attacker can control type of reconstructed objects
• Can specify Type
• Library loads Type
• Library/GC will call methods on reconstructed objects
• There are gadget chains starting on method executed upon/after 
reconstruction
Different scenarios
• Format includes type discriminator
1.
Default
2.
Configuration setting
• Type control
1.
Cast after deserialization
2.
Inspection of expected type
(User) JSON.Deserialize(untrusted);
JSON.Deserialize(untrusted);
JSON.Deserialize(untrusted, typeof(User));
{
"$type": "Newtonsoft.Json.Samples.Stockholder, Newtonsoft.Json.Tests",
"FullName": "Steve Stockholder",
"Businesses": {
"$type": "System.Collections.Generic.List`1[[Newtonsoft.Json.Samples.Business, Newtonsoft.Json.Tests]], mscorlib",
"$values": [ {
"$type": "Newtonsoft.Json.Samples.Hotel, Newtonsoft.Json.Tests",
"Stars": 4,
"Name": "Hudson Hotel”
}]}}
Different scenarios
• Inspection of expected type’s object graph to determine nested 
types
• Check assignability from provided type and/or whitelist creation
• Vulnerable if
• Expected type is user-controllable
• Attacker can find injection member in object graph
Name : String
Items : Dict
Message : Message
Body : Object
Exc: Exception
User
Message
Data : IDictionary
Message : String
Source: String
StackTrace: String
InnerException: Exception
…
Exception
…
Value : Object
ValidationException
Name : String
Items : Dict
Message : Message
Props : Hashtable
IUser
Summary
Name
Languag
e
Type 
Discriminator
Type Control
Vector
FastJSON
.NET
Default
Cast
Setter
Json.Net
.NET
Configuration
Expected Object Graph Inspection
Setter
Deser. callbacks
FSPickler
.NET
Default
Expected Object Graph Inspection
Setter
Deser. callbacks
Sweet.Jayson
.NET
Default
Cast
Setter
JavascriptSerializer
.NET
Configuration
Cast
Setter
DataContractJsonSeriali
zer
.NET
Default
Expected Object Graph Inspection
Setter
Deser. callbacks
Jackson
Java
Configuration
Expected Object Graph Inspection
Setter
Genson
Java
Configuration
Expected Object Graph Inspection
Setter
JSON-IO
Java
Default
Cast
toString
FlexSON
Java
Default
Cast
Setter
GSON
Java
Configuration
Expected Object Graph Inspection
-
FastJson
• Always includes Type discriminators
• There is no Type check controls other than a post-deserialization cast
• Invokes
• Setter
• Should never be used with untrusted data
• Example:
• KalikoCMS
• CVE-2017-10712
Var obj = (ExpectedType) JSON.ToObject(untrusted);