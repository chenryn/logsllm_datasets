        print(subnet)
以下是该代码的运行截图：  
每项任务所用的速率都是基于扫描机器能够处理的速率最大化思想。在我的例子中，我的扫描机器最大只能处理250kpps，所以如果我要运行5个并行任务，每个任务可使用50kpps的速率。
> 由于机器的最大速率不是“绝对”的（在本次测试中不完全都是250kpps的速率），你可以设置每个任务的速率，使总速率等于最大速率的80%-90%。
对于本项测试，执行了以下命令。通过split.py来划分成较小的子网，然后使用parallel命令来运行并行任务。
    python3 split.py TARGET_SUBNET 20 | parallel -j JOBS "masscan -p 1-65535 --rate RATE--wait 0 --open {} -oG {//}.gnmap"
以下是执行上述命令时的截图。在这种情况下，20个Masscan任务，每个任务的速率为10kpps，同时运行。  
任务数和速率如下：***
  * 5个任务/每个任务的速率是100kpps (--rate 100000 )
  * 5个任务/每个任务的速率是50kpps (--rate 50000)
  * 20个任务/每个任务的速率是10kpps (--rate 10000)
> **_说明：_**
>
>   *
> 大家可以注意到，我上面说的任务数和速率中第一个（5个任务/每个任务的速率是100kpps），我计算错了。因为它的总速率是500kpps，而我的机器只能处理250kpps。尽管如此，这个的测试结果仍然是有价值的，将可以在下面的图表里看到。
>   * 其他的组合，例如10个任务，每个任务的速率20kpps，这样是可行的。但是由于时间和预算有限，我不能把所有可能的组合都涵盖了。
>
**_图表如下：_**  
**_观察：_**
  * 当前的方案会比常规扫描（测试用例 ＃1）快2-3倍，但是导致开放的端口更少了。
  * 使用扫描机器的最大速率将导致扫描出的开放端口数更少（五个任务/每个任务100k的扫描速率）。
  * 少任务数&高扫描速率（例如5个任务/每个任务的速率50k）比多任务数&低扫描速率（例如20个任务/每个任务的速率10k）的效果好。
##### 测试用例 #3：将1-65535端口范围拆分为多个更小的范围，运行X个Masscan并发任务，每个任务的扫描速率为Y
第三个测试用例是为了解决在扫描大端口范围的时候，上文提到的Masscan的[问题](https://github.com/robertdavidgraham/masscan/issues/365)，特别是整个1-65535这样的范围。我的解决方案是将1-65535的范围拆分为更小的范围。
就像之前的测试用例一样，所使用的任务数&扫描速率组合的总速率是基于机器最大容量的80-90%这样的想法。
以下的命令用于本次的测试用例，PORT_RANGES是包含端口范围列表，然后使用parallel命令来运行并行任务。
    cat PORT_RANGES | parallel -j JOBS "masscan -p {} --rate RATE --wait 0 --open TARGET_SUBNET -oG {}.gnmap"
1-65535端口范围分为四种拆分方式，如下所示，每种拆分方式包含任务和速率的组合/变化。
###### 拆分方式 #1：拆分为5个端口范围
    1-13107
    13108-26214
    26215-39321
    39322-52428
    52429-65535
**_任务数和速率如下：_**
  * 5个扫描任务/每个任务50k的扫描速率 (--rate 50000)
  * 2个扫描任务/每个任务100k的扫描速率 (--rate 100000)
**_图表如下：_**  
###### 拆分方式 #2：拆分为2个端口范围
    1-32767
    32768-65535
**_任务数和速率如下：_**
  * 2个扫描任务/每个任务100k的扫描速率 (--rate 100000)
  * 2个扫描任务/每个任务125k的扫描速率 (--rate 125000)
**_图表如下：_**  
###### 拆分方式 #3： 拆分为8个端口范围
    1-8190
    8191-16382
    16383-24574
    24575-32766
    32767-40958
    40959-49151
    49152-57343
    57344-65535
**_任务数和速率如下：_**
  * 4个扫描任务/每个任务50k的扫描速率 (--rate 50000)
  * 2个扫描任务/每个任务100k的扫描速率 (--rate 100000)
**_图表如下：_**  
###### 拆分方式 #4： 拆分为4个端口范围
    1-16383
    16384-32767
    32768-49151
    49152-65535
**_任务数和速率如下：_**
  * 2个扫描任务/每个任务100k的扫描速率 (--rate 100000)
> 本次测试我之所以只使用了一种任务数&速率的组合，是因为我意识到我已经超过了每个月的带宽限制。这样我不得不多付100+美元。
**_图表如下：_**  
**_观察：_**
> 下面列出的观察结果涵盖了上面提到的所有4个拆分方式的方案。
  * 拆分端口范围会扫描出更多的开放端口（这样解决了Masscan在扫描大范围端口时的[问题](https://github.com/robertdavidgraham/masscan/issues/365)）;
  * 使用更少的并行任务（本次测试中是2个并行任务）会扫描出更多的开放端口；
  * 在所有的拆分方案的测试中，拆分为5个端口范围（拆分方式# 1）的扫描结果最佳。
**_原始数据_**
下表显示了使用上述不同Masscan测试用例进行实验的原始数据：  
##### Masscan结论：
根据使用Masscan进行的所有测试用例的结果，得出以下结论：
  * 以100％的CPU利用率运行扫描任务，会导致端口开放性降低；
  * 使用机器能运行的最大速率容量进行扫描会导致更少的端口开放；
  * 当使用并发任务时，较少的任务数会扫描出更多的开放端口；
  * 拆分端口范围的方式比拆分目标子网的方式要好；
  * 对于端口范围拆分的方式，（拆分方式 #1 和拆分方式 #4）的扫描结果是最佳的。
#### 0x08 Nmap的测试用例和测试结果
在此阶段，只执行版本扫描。Nmap的NSE，OS探测和其他扫描功能都没有涉及。Nmap的线程被限制为T4，等同于如下命令：
    --max-rtt-timeout=1250ms --min-rtt-timeout=100ms --initial-rtt-timeout=500ms --max-retries=6 --max-scan-delay=10ms
以下Nmap选项也用于模拟masscan使用的选项。这些选项应用于所有Nmap测试用例。
使用的Nmap选项如下：
  * SYN扫描方式（`-sS`）
  * 端口服务版本扫描（`-sV`）
  * 线程（`-T4`）
  * 随机选择扫描对象（`--randomize-hosts`）
  * no ping（`-Pn`）
  * no DNS解析（`-n`）
##### 测试用例 #1：定期扫描所有的TCP端口
这个测试用例只是使用Nmap的正常扫描，所以没啥特别之处。使用的命令如下：
    sudo nmap -sSV -p- -v --open -Pn -n --randomize-hosts -T4 TARGET_SUBNET -oA OUTPUT
_观察：_
  * 扫描了四天半以后，扫描任务仍然没有完成。这就是前文提到的缺点之一：扫描大型网络目标的时候，Nmap的速度非常慢；
  * 由于性能太低，我决定取消这个扫描任务。
##### 测试用例 #2：使用X个并发任务扫描所有的TCP端口
在这种情况下，我尝试通过运行并发的Nmap扫描任务来解决Nmap的低性能问题。通过将目标子网划分为较小的子网块来完成，就像上面Masscan测试的那样。同样，下面的代码（split.py）用于拆分目标子网：
    #!/usr/bin/python3
    import ipaddress, sys