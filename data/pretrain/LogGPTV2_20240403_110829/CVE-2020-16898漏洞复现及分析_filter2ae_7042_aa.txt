# CVE-2020-16898漏洞复现及分析
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
作者：prowes5@360GearTeam
## 0x00 漏洞概述
2020年10月13日，微软发布了关于TCP/IP远程代码执行漏洞的通告。漏洞编号危CVE-2020-16898，漏洞等级：严重。漏洞评分：9.8（后更新为8.8）。
这个问题是由于Windows错误的处理了ICMPv6 Router Advertisement包，从而造成了堆栈溢出。攻击者可以构造特定的ICMPv6
Router Advertisement数据包，发送到远程主机，从而达到任意远程代码执行的效果。
## 0x01 漏洞影响版本
Windows 10 Version 1709 for 32-bit Systems
Windows 10 Version 1709 for ARM64-based Systems
Windows 10 Version 1709 for x64-based Systems
Windows 10 Version 1803 for 32-bit Systems
Windows 10 Version 1803 for ARM64-based Systems
Windows 10 Version 1803 for x64-based Systems
Windows 10 Version 1809 for 32-bit Systems
Windows 10 Version 1809 for ARM64-based Systems
Windows 10 Version 1809 for x64-based Systems
Windows 10 Version 1903 for 32-bit Systems
Windows 10 Version 1903 for ARM64-based Systems
Windows 10 Version 1903 for x64-based Systems
Windows 10 Version 1909 for 32-bit Systems
Windows 10 Version 1909 for ARM64-based Systems
Windows 10 Version 1909 for x64-based Systems
Windows 10 Version 2004 for 32-bit Systems
Windows 10 Version 2004 for ARM64-based Systems
Windows 10 Version 2004 for x64-based Systems
Windows Server 2019
Windows Server 2019 (Server Core installation)
Windows Server, version 1903 (Server Core installation)
Windows Server, version 1909 (Server Core installation)
Windows Server, version 2004 (Server Core installation)
## 0x02漏洞复现验证
复现环境：
靶机：
Windows10 1909
攻击机：
系统：Ubuntu 18.04
组件版本：Python3.6.9，scapy2.4.4
网络：攻击机和靶机需在同一内网下且数据包可以到达。
验证结果：
## 0x03 漏洞分析
RDNSS中length字段是以组为单位显示的，默认情况下为奇数。当这个字段为偶数时，会导致tcpip.sys出现解析错误。
[rfc5006](https://tools.ietf.org/html/rfc5006)中定义了RDNSS包的各字段作用、大小和偏移。
     0                   1                   2                   
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     Type      |     Length    |           Reserved            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           Lifetime                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    :            Addresses of IPv6 Recursive DNS Servers            :
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Type:
8-bit，RDNSS类型为25
length：
8-bit无符号整数。主要代表option的长度，一组代表8个字节。RDNSS数据包头部为八字节，而IPv6为16字节。即最小为24字节，8字节一组，Length最小为3。如果有多个IPv6地址，则每次Length加2。所以Length默认情况下是奇数。
Reserved:
16-bit，保留字段。
Lifetime:
32-bit无符号整数。RDNSS地址用于解析的最长时间。当为0xffffffff时，表示无穷大。
先看一下正常的数据包，可以看到相关的一些字段信息，且Length为奇数
之后看一下攻击的数据包，这里wireshark会根据Length的长度解析数据包，Length为4会认为第一个Option包为20byte，而IPv6地址为16字节，而\x01\x02\x03\x04\x05\x06\x07\x08只有八个字节，所以会把下一个Option的前八字节认为是IPv6地址的后八字节，也就是这里的102:304:506:708:1926:4242:4242:4242。而Option是根据Length解析的，是从\x19\x26这里开始，所以这里的数据就会被重复解析。
接下来详细分析下漏洞
漏洞点存在于tcpip!Ipv6pHandleRouterAdvertisement，直接在该函数中下断点。
      while ( 1 )
      {
        v27 = *(v9 + 24);
        v192 = 0;
        if ( v27 = *(*(v9 + 8) + 40i64) )
              {
                NdisAdvanceNetBufferDataStart(v9, 2i64, 0i64, 0i64);
              }
              else
              {
                *(v9 + 40) += 2;
                *(v9 + 24) = v27 - 2;
                *(v9 + 16) = v32;
              }
              length -= 2;
              v21 += 2;
              v190 = NdisGetDataBuffer(v9, length, &v265, 1i64, 0);
            }
            break;
          case 3u:
            memset(&Dst, 0, 0x20ui64);
            if ( length != 32 || *(NdisGetDataBuffer(v9, 32i64, &Dst, 1i64, 0) + 2) > 0x80u )
            {
              *v7 = 23;
              goto LABEL_276;
            }
            break;
          case 5u:
            v206 = 0i64;
            if ( length != 8 )
            {
              *v7 = 22;
              goto LABEL_276;
            }
            v185 = _byteswap_ulong(*(NdisGetDataBuffer(v9, 8i64, &v206, 1i64, 0) + 4));
            break;
          case 0x18u:
            v253 = 0i64;
            v254 = 0i64;
            v255 = 0i64;
            if ( length > 0x18u
              || (v147 = *(NdisGetDataBuffer(v9, length, &v253, 1i64, 0) + 2), v147 > 0x80u)
              || v147 > 0x40u && length < 0x18u
              || v147 && length < 0x10u )
            {
              *v7 = 24;
              goto LABEL_276;
            }
            break;
          case 0x19u:
            if ( *(v11 + 404) & 0x40 && length < 0x18u )// length bytes
              *v7 = 25;
            break;
          default:
            if ( v25 == 0x1F && *(v11 + 404) & 0x40 && length < 0x10u )
            {
              *v7 = 26;