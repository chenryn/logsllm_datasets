59
---
## Page 77
然后每当调用它时，count的值将被加l：
面的表达式所创建的闭包捕捉到一个全局变量里：
闭合的变量的值，还可以对其赋予在闭包被调用时不断变化的新值。例如，可以像下面这样将前
由LET创建的绑定。
LET形式所返回的函数对象的引用即可。这个匿名函数被称为一个闭包，因为它“封闭包装”了
当控制流进人LET形式时所创建的count绑定将被尽可能地保留下来，只要某处保持了一个对
这样会发生什么呢？正如你将看到的那样，当count是一个词法变量时，情况一切正常。本例中，
名函数将被作为LET形式的值返回，并可能会通过FUNCALL被不在LET作用域之内的代码所调用。
之内词法变量的引用时，将会发生什么呢？例如，在下面的表达式中：
于绑定形式之内的代码可以指向一个词法变量。但是当一个匿名函数含有一个对来自封闭作用域
样。变化之处在于将词法作用域和嵌套函数一起使用时，按照词法作用域的规则，只有文本上位
序员们也该对其感到自然才是，因为Algol在20世纪60年代首先引人了词法作用域。
编程的人们应该熟悉词法作用域，因为它们都提供词法作用域的局部变量。如此说来，Algol程
只能由那些在文本上位于绑定形式之内的代码所引用。那些曾经使用Java、C、Perl或者Python来
6.2词法变量和闭包
但不能这样写：
理解闭包的关键在于，被捕捉的是绑定而不是变量的值。因此，
默认情况下，Common Lisp中所有的绑定形式都将引入词法作用域变量。词法作用域的变量
60
(defparameter *fn* (let ((count 0)) #:(lambda () (setf count (1+ count)))))
尽管如此，但Common Lisp的词法变量还是有一些变化的，至少和最初的Algol模型相比是这
CL-USER> (funcall *fn*)
CL-USER> (funcal1 *fn*)
根据词法作用域规则，LAMBDA形式中对count的引用应该是合法的，而这个含有引I用的匿
(let （(count 0)) #(lambda () (setf count (l+ count))))
(let ((x 10))
不过也可以通过嵌套的LET来达到相同的效果：
(let ((x 10)
(let*((x 10)
(let
(list x y})
(list x y))
(list x y)))
第6章变量
(y
y
\+
x 10)))
x 10)))
x 10)))
www.TopSage.com
一个闭包不仅可以访问它所
---
## Page 78
的部件数量不会因为对部件生产的代码做了某些改变而就此作废。?
工厂的应用程序的一部分，那么使用DEFVAR来定义*COunt*变量就比较合适，因为目前已生产
使用到该变量的源码发生改变时也应如此。例如，假设前面定义的两个变量是一个用来控制部件
量未定义时才这样做。DEFVAR形式也可以不带初始值来使用，从而在不给定其值的情况下定义
的示例如下：
始和结尾的名字。你将在本节后面看到所述遵守该命名约定的重要性。DEFVAR和DEFPARAMETER
该名字可用于任何位置来指向全局变量的当前绑定。如前所述，全局变量习惯上被命名为以*开
程语言里。“正如你即将看到的，Lisp的全局变量和动态变量都更为有用并且更易于管理。
毫无节制地使用goto那样，但全局变量确实有其合理的用途，并以某种形式存在于几乎每种编
一种可以从程序的任何位置访问到的变量。尽管随意使用全局变量将使代码变得杂乱无章，就像
就是大多数现代语言将词法作用域用于局部变量的原因。尽管如此，有时的确需要全局变量一
6.3动态变量
一个全局变量。这样的变量称为未绑定的（unbound)。
一个变量名、一个初始值以及一个可选的文档字符串。在被DEFVAR和DEFPARAMETER定义以后，
定。
词法作用域的绑定通过限制作用域（其中给定的名字只具有字面含义）使代码易于理解，这
② 如果你特定想要重设由DEFVAR定义的变量，那要么使用SETP直接设置它，要么使用MAKUNBOUND先将其变成未
从实践上来讲，应该使用DEFVAR来定义某些变量，这些变量所含数据是应持久存在的，即
Common Lisp提供了两种创建全局变量的方式：DEFVAR和DEFPARAMETER。两种形式都接受
。例如，下面的表达式返回由三个闭合所组成的列表，一个可以递增其所闭合的count绑定的
以从任何位置被访问到。
两种形式的区别在于，DEFPARAMETER总是将初始值赋给命名的变量，而DEFVAR只有当变
(defvar *count* 0
另一个可以递减它，还有一个返回它的当前值。
(defparameter *gap-tolerance* 0.001
(let （(count 0))
单一闭包可以简单地通过引用变量来闭合许多变量绑定，或是多个闭合可以捕捉相同的绑
CL-USER> (funcall *fn*)
绑定的，再重新求值DEFVAR形式。
"Tolerance to be allowed in widget gaps."}
"Count of widgets made so far.")
#'(lambda
(list
(lambda
C
(incf count))
count)）}
(decf count))
www.TopSage.com
6.3动态变量
61
---
## Page 79
LET。
是动态变量。
动态绑定可以被任何在绑定形式执行期间所调用到的代码所引用。?显然所有全局变量事实上都
应全局绑定。与词法绑定——只能被绑定形式的词法作用域之内的代码所引用——所不同的是，
时，例如通过一个LET变量或函数形参，在被绑定项上所创建的绑定替换了在绑定形式期间的对
函数以及它们进一步调用的函数，诸如此类，直到最底层的函数全局变量*standard-output*
那么程序中所有用到*standard-output*的其他代码也会将把它们的输出发往该文件。?
底层函数们将把它们的输出发往该文件。
*standard-output*中的流上。现在假设在程序的某个部分里，想要将所有这些函数所生成的
变量的代码，那么试图通过更改变量值来临时改变代码行为的做法就颇为诱人了。
有人需要，就使每个函数都不得不接受并传递含有这些流的参数。
可以定义下面的函数来递增已生产部件的数量。
加载文件时让这一改变产生效果。
定使用一个或紧或松的容差值，并且改变了DEFPARAMETER形式中的值，那么就要在重新编译和
例如，假设正工作的一个程序中含有的某些底层日志函数会将输出打印到位于全局变量
因此，如果想要临时重定义*standard-output*，只需重新绑定它即可，比如说可以使用
真正所需的代码包装方式似乎应如下所述：“在从这里以下的所有代码中——所有它调用的
这样工作得很好，但假如完成工作时忘记将*standard-output*重新设置回最初的流上,
在用DEFVAR和DEFPARAMETER定义了一个变量之后，就可以从任何一个地方引用它。例如，
62
① 这种临时重新赋值*standarel-output*的策略也会在系统使用多线程时失效—如果有多个控制线程同时
这看起来正像是Common Lisp的另一种变量，即动态变量所做的事。当绑定了一个动态变量
不过，一旦像标准输出流这样的值被保存在一个全局变量中，并且已经编写了引用那个全局
另一方面，假定变量*gap-tolerance*对于部件生产代码本身的行为具有影响。如果你决
②
全局变量的优势在于不必到处传递它们。多数语言将标准输入与输出流保存在全局变量里正
(defun increment-widget-count () (incf *count*))
经常被错误地称为动态作用域（dynamic scope）。
意思是它们可以在不定长的间隔里保持存在，这取决于它们被需要多久。动态变量正好相反，它们具有不确定的
密相关的概念一
一个绑定可被引用到的时间间隔，其技术术语称为生存期，这样作用域（scope）和生存期（extent）就是两个紧
作用域，因为它们可从任何位置访问却有动态的生存期。更加引起误会的是，不确定作用域和动态生存期的组合
线程正在输出时，即使它们想要输出到一个不同的流上，它将不得不锁住所有其他线程直到完成。
使用一个锁来控制对一个全局变量的访问，但那样就无法充分获得多重并发线程所带来的好处了。因为无论哪个
试图输出到不同的流上，它们将全都试图设置该全局变量到它们想要使用的流上，完全无视彼此的感受。你可以
第6章 
变量
一作用域关注空间而生存期关注时间。词法变量具有词法作用域和不确定的（indefinite）生存期，
www.TopSage.com
---
## Page 80
的结果如下所示：
因此它打印出10：
态地查找其当前绑定。如果从最上层调用foo，由DEFVAR所创建的全局绑定就是唯一可用的绑定，
们所创建的绑定会被从栈上弹出，从而暴露出前一个绑定。?
到一个用于该变量的绑定栈中，而对该变量的引用总是使用最近的绑定。当绑定形式返回时，它
最近建立的绑定会覆盖所有其他的绑定。从概念上讲，一个给定动态变量的每个新绑定都将被推
将随之消失，接下来对*standard-output*的引l用将看到LEr之前的绑定。在任何给定时刻，
立的绑定，并且当stuff返回并且程序控制离开LET时，这个对*standard-output*的新绑定
①尽管标准并未指定如何在CommonLisp中使用多线程，但所有提供多线程的实践都遵循了由Lisp机所建立的原则，
NIL
CL-USER>(bar)
注意，中间那个对foo的调用被包装在一个将*x*绑定到新值20的LET形式中。运行bar得到
现在定义另一个函数：
CL-USER>(foo)
现在不使用LET再次调用foo，它将再次看到全局绑定：
但也可以用LET创建一个新的绑定来临时覆盖全局绑定，这样foo将打印一个不同的值：
CL-USER>(foo)
上面的DEFVAR为变量*x*创建了一个到数值10的全局绑定。函数foo中，对*x*的引I用将动
一个简单的例子就能揭示其工作原理。
在任何由于调用stuff而运行的代码中，对*standard-output*的引用将使用由LET所建
在每线程的基础上创建动态绑定，一个对全局变量的引用将查找当前线程中最近建立的绑定，或是全局绑定。
(defunbar()
NIL
X:10
NIL
X:10
（defvar*x*10）
(let((*standard-output**some-other-stream*))
10
20
(foo))
（stuff))
C
et（（*x*20））（foo））
www.TopSage.com
6.3
动态变量
多的网
---
## Page 81
的，从而指向该动态绑定。尽管如此，局部特殊变量使用相对较少，所以你不需要担心它们。
那么为该变量所创建的绑定将是动态的而不是词法的。其他代码可以局部地声明一个名字为特殊
绑定。
定。如果总是按照*命名约定来命名全局变量，就不会在打算建立词法绑定时却意外使用了动态
可能在你意想之外改变了绑定的值；另一方面，你可能会覆盖一个由栈的上一级代码所建立的绑
量，以为它是词法变量，而它却刚好是全局特殊的变量，这就很不好。一方面，你所调用的代码
被创建的绑定将成为一个动态绑定。这就是为什么命名约定如此重要——如果你使用了-一个变
一个名字，无论是在LET中，或是作为一个函数形参，亦或是在任何创建新变量绑定的构造中，
所定义的变量其名字都将被自动声明为全局特殊的。这意味着无论何时你在绑定形式中使用这样
绑定呢？这是因为该名字已经被声明为特殊的（Special）。?每一个由DEFVAR和DEFPARAMETER
到了全局绑定，并将其从12递增到13。
将全局绑定递增到12。中间的调用由于LET的关系没有看到全局绑定，然后最后一个调用再次看
对*x*的赋值。
了新的绑定，其值为20。但在LET之后，foo再次看到了全局绑定。
那么它是怎样工作的呢？LET是怎样知道在它绑定*x*时打算创建的是动态绑定而不是词法
和词法绑定一样，赋予新值仅会影响当前绑定。为了理解这点，
64
也有可能将一个名字声明为局部特殊的，如果在一个绑定形式里将一个名字声明为特殊的，
可以看到，第一次对foo的调用看到了全局绑定，其值为10。然而，中间的那个调用却看到
② 如果你一定想知道的话，你可以在HyperSpec上查找DECLARE、SPECIAL和LOCALLY。
①这就是动态变量有时也被称为特殊变量的原因。
注意*x*从11开始-
NIL
After assignment
After assignment
Before assignment
CL-USER> (bar)
这看起来很正常，现在运行bar：
NIL
Before assignment X: 10
CL-USER> (foo)
现在foo打印*x*的值，对其递增，然后再次打印它。如果你只运行foo，将看到这样的结果：
Beforeassignment
After assignment
Before assignment
Afterassignment
(defun foo {)
(format t "After assignment~18tX: ~d~&" *x*))
（setf *x*
format
第6章 变量
"Before assignment~18tx: ~d~%" *x*)
X：