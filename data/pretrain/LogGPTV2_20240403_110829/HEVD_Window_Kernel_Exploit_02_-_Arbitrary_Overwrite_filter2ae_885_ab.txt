### 优化后的文本

```c
typedef struct _TOKEN {
    ULONG *DynamicPart;
    PACL DefaultDacl;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    ULONG TokenFlags;
    UCHAR TokenInUse;
    ULONG IntegrityLevelIndex;
    ULONG MandatoryPolicy;
    PSECURITY_TOKEN_PROXY_DATA ProxyData;
    PSECURITY_TOKEN_AUDIT_DATA AuditData;
    PSEP_LOGON_SESSION_REFERENCES LogonSession;
    LUID OriginatingLogonSession;
    SID_AND_ATTRIBUTES_HASH SidHash;
    SID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    ULONG VariablePart;
} TOKEN, *PTOKEN;
```

这个结构体从Windows 7开始就没有太多变动了。我们重点关注以下几个成员变量：

- `SEP_TOKEN_PRIVILEGES Privileges; // 0x40`

这个结构体变量以位字段的方式记录了当前token中使用的特权（privilege）。Token本质上是一个描述当前安全对象与其他安全对象之间关系的结构体。在Windows系统中，进程也是一种安全对象，因此Token也描述了当前进程对其他进程的权限。

当我们使用类似WinDbg这样的工具调试其他进程时，系统会赋予调试器**调试其他进程的特权**。这种特权允许我们**向更高权限的进程中注入代码**。例如，可以向System进程注入代码，从而实现进程劫持并完成提权。

接下来，我们检查一下运行EXP的进程所使用的`token`：

```plaintext
kd> !token
Thread is not impersonating. Using process token...
_EPROCESS 0xffffffffa25de040, _TOKEN 0x0000000000000000
TS Session ID: 0x1
User: S-1-5-21-3717723882-702046769-3252787667-1000
User Groups:
  00 S-1-5-21-3717723882-702046769-3252787667-513
     Attributes - Mandatory Default Enabled
  01 S-1-1-0
     Attributes - Mandatory Default Enabled
  02 S-1-5-114
     Attributes - Mandatory Default Enabled
  03 S-1-5-32-544
     Attributes - Mandatory Default Enabled Owner
  04 S-1-5-32-545
     Attributes - Mandatory Default Enabled
  05 S-1-5-4
     Attributes - Mandatory Default Enabled
  06 S-1-2-1
     Attributes - Mandatory Default Enabled
  07 S-1-5-11
     Attributes - Mandatory Default Enabled
  08 S-1-5-15
     Attributes - Mandatory Default Enabled
  09 S-1-5-113
     Attributes - Mandatory Default Enabled
  10 S-1-5-5-0-252984
     Attributes - Mandatory Default Enabled LogonId
  11 S-1-2-0
     Attributes - Mandatory Default Enabled
  12 S-1-5-64-10
     Attributes - Mandatory Default Enabled
  13 S-1-16-12288
     Attributes - GroupIntegrity GroupIntegrityEnabled
Primary Group: S-1-5-21-3717723882-702046769-3252787667-513
Privs:
  05 0x000000005 SeIncreaseQuotaPrivilege          Attributes -
  08 0x000000008 SeSecurityPrivilege               Attributes -
  09 0x000000009 SeTakeOwnershipPrivilege          Attributes -
  10 0x00000000a SeLoadDriverPrivilege             Attributes -
  11 0x00000000b SeSystemProfilePrivilege          Attributes -
  12 0x00000000c SeSystemtimePrivilege             Attributes -
  13 0x00000000d SeProfileSingleProcessPrivilege   Attributes -
  14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes -
  15 0x00000000f SeCreatePagefilePrivilege         Attributes -
  17 0x000000011 SeBackupPrivilege                 Attributes -
  18 0x000000012 SeRestorePrivilege                Attributes -
  19 0x000000013 SeShutdownPrivilege               Attributes -
  20 0x000000014 SeDebugPrivilege                  Attributes - Enabled  Directory
5 --> Token
7 --> Process
37 --> File
44 --> Key
```

通过遍历句柄表，我们可以找到`TOKEN`对象的实际地址：

```c
for (size_t i = 0; i < buffer->NumberOfHandles; i++) {
    DWORD objTypeNumber = buffer->Handles[i].ObjectTypeNumber;
    if (buffer->Handles[i].ProcessId == GetCurrentProcessId() && objTypeNumber == type) {
        if (handle == (HANDLE)buffer->Handles[i].Handle) {
            DWORD object = (DWORD)buffer->Handles[i].Object;
            free(buffer);
            return object;
        }
    }
}
```

### 总结

通过对`TOKEN`结构体的分析和调试信息的查看，我们可以了解当前进程的权限和特权，并通过遍历句柄表找到实际的`TOKEN`对象地址。这对于安全研究和漏洞利用非常有用。