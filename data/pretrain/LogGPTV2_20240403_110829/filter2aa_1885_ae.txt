12. 【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获
抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用
ScheduledExecutorService 则没有这个问题。   
13. 【推荐】资金相关的金融敏感信息，使用悲观锁策略。 
说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决
策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用
乐观锁更新。 
14. 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown
方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行
至 await 方法，直到超时才返回结果。 
说明：注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。 
15. 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一
seed 导致的性能下降。 
说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。 
正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线
程持有一个实例。 
16. 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化
问题隐患(可参考 The "Double-Checked Locking is Broken" Declaration)，推荐解决方案中较为
简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。 
反例： 
public class LazyInitDemo {   
private Helper helper = null;  
public Helper getHelper() {  
if (helper == null) synchronized(this) {      
if (helper == null)         
helper = new Helper();    
}      
return helper;  
}  
// other methods and fields...  
}  
Java 开发手册 
  18/44 
17. 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但
是如果多写，同样无法解决线程安全问题。 
说明：如果是 count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); 
count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观
锁的重试次数）。 
18. 【参考】HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在
开发过程中可以使用其它数据结构或加锁来规避此风险。 
19. 【参考】ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。 
说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变
量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义
的)都可以操控这个变量。 
(七) 控制语句 
1. 【强制】在一个 switch 块内，每个 case 要么通过 continue/break/return 等来终止，要么
注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个
default 语句并且放在最后，即使它什么代码也没有。 
说明：注意 break 是退出 switch 语句块，而 return 是退出方法体。 
2. 【强制】当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null
判断。 
反例：猜猜下面的代码输出是什么？ 
public class SwitchString { 
    public static void main(String[] args) { 
        method(null); 
    } 
    public static void method(String param) { 
        switch (param) { 
            // 肯定不是进入这里 
            case "sth": 
                System.out.println("it's sth"); 
                break; 
            // 也不是进入这里 
            case "null": 
                System.out.println("it's null"); 
                break; 
            // 也不是进入这里 
            default: 
                System.out.println("default"); 
        } 
    } 
} 
Java 开发手册 
  19/44 
3. 【强制】在 if/else/for/while/do 语句中必须使用大括号。 
说明：即使只有一行代码，避免采用单行的编码方式：if (condition) statements;   
4. 【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。 
说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件
来代替。 
反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，
这样的话，活动无法终止。 
5. 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成： 
if (condition) {     
          ...    
          return obj;    
}   
// 接着写 else 的业务逻辑代码;  
说明：如果非使用 if()...else if()...else...方式表达逻辑，避免后续代码维护困难，【强制】请勿超过 3 层。  
正例：超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句
即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况，以方法多个出口的方式，解决代码中判断
分支嵌套的问题，这是逆向思维的体现。 
示例如下： 
public void findBoyfriend(Man man) { 
     if (man.isUgly()) { 
                   System.out.println("本姑娘是外貌协会的资深会员"); 
           return; 
     } 
     if (man.isPool()) { 
                   System.out.println("贫贱夫妻百事哀"); 
           return; 
     } 
     if (man.isBadTemper()) { 
                   System.out.println("银河有多远，你就给我滚多远"); 
           return; 
     } 
System.out.println("可以先交往一段时间看看"); 
} 
6. 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复
杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。 
说明：很多 if 语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成
本非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。 
正例： 
// 伪代码如下 
final boolean existed = (file.open(fileName, "w") != null) && (...) || (...); 
Java 开发手册 
  20/44 
if (existed) { 
    ... 
}   
反例： 
public final void acquire(long arg) { 
    if (!tryAcquire(arg) && 
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) { 
            selfInterrupt(); 
        } 
} 
7. 【推荐】不要在其它表达式（尤其是条件表达式）中，插入赋值语句。 
说明：赋值点类似于人体的穴位，对于代码的理解至关重要，所以赋值语句需要清晰地单独成为一行。 
反例： 
public Lock getLock(boolean fair) { 
    // 算术表达式中出现赋值操作，容易忽略 count 值已经被改变 
    threshold = (count = Integer.MAX_VALUE) - 1; 
    // 条件表达式中出现赋值操作，容易误认为是 sync==fair 
    return (sync = fair) ? new FairSync() : new NonfairSync(); 
} 
8. 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变
量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体
外）。 
9. 【推荐】避免采用取反逻辑运算符。 
说明：取反逻辑不利于快速理解，并且取反逻辑写法必然存在对应的正向逻辑写法。 
正例：使用 if (x = 628)) 来表达 x 小于 628。 
10. 【推荐】接口入参保护，这种场景常见的是用作批量操作的接口。 
11. 【参考】下列情形，需要进行参数校验： 
 1） 调用频次低的方法。 
 2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致     
中间执行回退，或者错误，那得不偿失。 
 3） 需要极高稳定性和可用性的方法。 
 4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。 
 5） 敏感权限入口。 
12. 【参考】下列情形，不需要进行参数校验： 
 1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。 
 2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露
问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可
以省略。 
Java 开发手册 
  21/44 
 3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检
查或者肯定不会有问题，此时可以不校验参数。 
(八) 注释规约 
1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用
// xxx 方式。 
说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE
中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 
2. 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、
异常说明外，还必须指出该方法做什么事情，实现什么功能。 
说明：对子类的实现要求，或者调用注意事项，请一并说明。 
3. 【强制】所有的类都必须添加创建者和创建日期。 
4. 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释
使用/* */注释，注意与代码对齐。 
5. 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。 
6. 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保
持英文原文即可。 
反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。 
7. 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻
辑等的修改。 
说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了
导航的意义。 
8. 【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。 
说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信
息，难以知晓注释动机。后者建议直接删掉（代码仓库已然保存了历史代码）。 
9. 【参考】对于注释的要求：第一、能够准确反映设计思想和代码逻辑；第二、能够描述业务
含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者
形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继