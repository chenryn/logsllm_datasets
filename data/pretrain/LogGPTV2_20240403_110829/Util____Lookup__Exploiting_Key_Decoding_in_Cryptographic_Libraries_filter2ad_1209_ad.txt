as a basis to determine evictions in the measurements which repre-
sent actual lookup operations. Prefiltering the measurements using
the page access information significantly reduces the chance for
false positives, meaning measurements will not falsely be identified
as LUT hit if there is noise in non-relevant cache probings. We
identify an access to a cache line containing LUT information by
having an eviction time which differs by two standard deviations.
As stated in Section 3.3.2, OpenSSL looks up each symbol in a
PEM file at least twice. Additionally, it parses the PEM file in blocks
of 64 symbols. The symbols which are at the boundaries of a block
are even parsed three times as they are checked for white space and
end of line characters. Thus, we see a clear access pattern to the
lookup table, which can be used to eliminate remaining irrelevant
elements from the beginning of the trace and match the two passes
for every 64 byte block against each other. The last step also allows
for error correction or filling up gaps.
In order to extract each key parameter, the trace needs to be
partitioned according to the DER format, by identifying parameter
lengths and removing meta data: As mentioned in Section 3.3.3,
OpenSSL leaks the parameter length information in the BN_bin2bn
method, which iterates over every byte in the DER binary, and
converts the data to an internal array representation. It can be
attacked in a similar manner as the lookup operation, except that the
single-stepped Prime+Probe attack must be run against the cache
line holding the instruction which loads the next key byte. Counting
the number of evictions and translating them to the iteration count
determines the length of each parameter easily.
4.2 Experimental Evaluation
In the following, we describe the experimental setup to conduct the
single-stepped cache attack against base64 decoding, and discuss
our observed results. We show that a mitigation against an attack
in the transient domain greatly simplifies the process of leaking
information from the decoding operation.
Setup. For the evaluation of the attack and leakage extrac-
4.2.1
tion we evaluated two different enclaves and took measurements
on three different CPUs. First, we crafted an enclave containing
the relevant code parts for base64 decoding from OpenSSL and
ran experiments on an Intel i5-8259U processor with an 6144 kB
inclusive L3 cache and 4 GB main memory. The cache has 12 ways
and, as assessed in our experiments, 8 slices with 1024 sets each.
Second, we conducted the same measurements on an enclave
which decodes a base64 encoded private key using the intel-sgx-
ssl [42] library in version 1.1.1k, compiled with default settings.
The intel-sgx-ssl project compiles and installs the trusted OpenSSL
libraries with and without mitigation by default. We linked our
enclave against intel-sgx-ssl with MITIGATION-CVE-2020-0551 set
to LOAD, CF and no mitigation and compared the results. The mea-
surements with intel-sgx-ssl were run on an Intel Xeon E-2286M
with 16384 kB inclusive L3 cache and 16 GB main memory and on
an Intel i5-6400 with an 6144 kB inclusive L3 cache and 4 GB main
memory.
All CPUs used the latest stable microcode patches. For compat-
ibility with SGX-Step, we used Intel SGX SDK version 2.11. We
disabled hardware prefetching for the L1 and L2 caches on each
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2462Table 2: Exemplary eviction set measurements during cache set probing from the experiments without LVI mitigations. The
rows show measurements with and without accesses to the LUT, which correspond to accesses to the LUT page. Each time we
observe a page access, we also see an eviction (orange); however, those evictions always occur in both cache sets, not allowing
us to draw any conclusions which set has been accessed. The last row specifies the slice number.
Page Access
No
No
Yes
Yes
848
846
842
842
S1
784
778
784
778
S2
756
750
754
756
S3
Set 1
808
806
2486
2488
S4
842
844
846
844
S5
780
778
782
784
S6
758
756
756
766
S7
852
842
846
850
S8
Set 2
888
888
2478
2940
S1
800
802
802
802
S2
794
782
790
790
S3
760
760
764
766
S4
798
804
802
808
S5
852
848
844
846
S6
760
760
764
760
S7
788
788
788
784
S8
core. Additionally, the CPU frequency was fixed to the processor’s
base frequency on all cores, Intel Speedstep was disabled and the
maximal C-State was set to 0 in order to decrease variability in
the measurements. Finally, we assigned the enclave and its host
application to a specific logical core, which was removed from the
OS scheduler.
4.2.2 Results. The first experiments were run without configur-
ing the make process to apply mitigations against LVI [19], which
are available since the Intel SGX Platform Software (PSW) and
Software Development Kit (SDK) version 2.9.100.2. The results
are very noisy and hardly exploitable, in fact most measurement
runs are not usable at all, as the eviction time measurements of
the Prime+Probe attack are inconclusive: Extracting the sequence
of lookups of base64 symbols is not possible, as both monitored
sets were accessed, even though we performed a single-stepping
attack. Simultaneous accesses are likely caused by speculative or
out-of-order accesses of the lookups, as subsequent lookups are
only few instructions apart. While single-stepped execution en-
sures that only one instruction commits between interrupts, several
are issued in parallel in that time window. We further suspect that
this transient effect is amplified by resetting the page accessed bits,
which increases the out-of-order window. The measurements for
this experiment without the LVI mitigation reveal that most of
the time, evictions are observed for both investigated cache sets,
which renders a distinction infeasible. Table 2 shows a few example
measurements for both cache sets without mitigation.
Next, we repeated the measurements with MITIGATION-CVE-
2020-0551 set to LOAD [40]. This LVI mitigation places load fences
after every instruction which has a load micro-op [19, 43]. Con-
sequently, it prohibits out-of-order execution of instructions after
the traced load instruction, which otherwise might have accessed
further cache lines in the LLC. Figure 3 depicts a comparison of
eviction times for measurements with and without LVI mitigation.
It is observable that with the LVI countermeasure, only one of the
two monitored cache lines is accessed, while both are accessed
when the countermeasure is turned off. We thus conclude that the
LVI countermeasure greatly enhances granularity of cache attacks.
The attack we ran against base64 decoding in Intel SGX requires
only one execution to create a trace, which leaks all information we
can obtain from priming and probing the cache sets holding the
LUT. In order to determine the reliability of the measurements, we
ran the attack 100 times against the same key and tried to extract the
respective cache line access trace. For our experiments, we aligned
the lookup table on a 64 byte boundary, such that the LUT used in
OpenSSL spread over exactly 2 cache lines. The cache access trace
created by the offline analysis is a string with elements from {1, 2,
x}, where x means that no clear distinction can be made and 1 and
2 identify the accessed cache lines.
Finally, each of the extracted traces is checked for the correct
length and compared against the actual key, by checking for each
base64 symbol whether it matches the cache line access. The PEM
file holding the 1024 bit test key has a length of 848 base64 symbols,
thus requiring the same length for the measured cache access trace.
Figure 4 depicts the eviction time measurements for all sets over
all slices possibly holding cache line 2 of the LUT when probing
the corresponding eviction sets. The sets in all slices but slice 8
reveal the same spectrum of eviction times for measurements with
and without observed page accesses. However, for slice 8, a clear
deviation in eviction time measurements can be observed, which
allows the detection of LUT accesses.
Self-Crafted Enclave. The histogram in Figure 5 shows the num-
ber of trace elements which could not be classified (x) or which
received a wrong classification per execution. The measurement
was taken on the Intel i5-8259U with the “self-crafted” enclave and
LVI mitigation level set to LOAD.
The data shows that the attack runs stable in most cases. In
93 of the measurements the automated offline analysis is able to
extract a sequence of correct length, and in 62 the number of cache
line accesses which could not be classified is less than 10, which is
only 1.2% of the full trace. Figure 5 shows that there are only few
measurements with more than 30 ambiguous or wrong cache line
classifications. Additionally, in none of the 93 measurements, for
which extracting the sequence was feasible, a cache line hit was
detected for the wrong cache line. This very reliable classification
can partially be attributed to OpenSSL looking up each symbol
twice.
For the key reconstruction, we are only interested in the lower
half (least significant part) of bits of every parameter, as explained
in Section 5. This reduces the number of relevant missing cache
line classifications to about the half. Moreover, due to a random
distribution of missing information, running the attack twice is
sufficient to obtain a (near) complete trace.
Session 10A: Crypto, Symbols and Obfuscation CCS ’21, November 15–19, 2021, Virtual Event, Republic of Korea2463Figure 3: Eviction set measurements with and without LVI mitigations enabled. The blue and orange lines correspond to
the eviction times of the cache sets holding the LUT. To level both graphs, the respective mean measurement time has been
subtracted, resulting in an expected value of 0 when the corresponding set has not been accessed. In the upper plot, with
enabled LVI mitigations, we see a clear separation of both sets: If the orange graph is positive, the blue one is 0, and vice versa.
Note that the LUT entries are not evenly distributed, leading to a bias towards the orange set. In the lower plot, without LVI
mitigations, we see that most of the time both sets are hit, so a clear separation is impossible.
Figure 4: Eviction times measured after every instruction during the decoding process for all cache sets over all slices possibly
holding cache line 2 of the LUT. Violet boxes and whiskers show the eviction time of all measurements in which the memory
pages of the lookup table and decoding function were not accessed. Green shows the measurements for which the observed
pages were accessed. Since no knowledge of the slice mapping is assumed, the slice numbers cannot be matched to a logical
CPU core and will be assigned differently in every execution. In the depicted case, the victim’s accesses map to slice 8.
Enclave with intel-sgx-ssl. In Figure 6, the measurement results
on the Intel Xeon E-2286M with an enclave using intel-sgx-ssl to
decode the base64 encoded key are depicted. The measurement
was taken with MITIGATION-CVE-2020-0551 set to LOAD, CF and
without mitigation. The results with the mitigation level set to
LOAD show that 14 of 100 traces don’t have any errors and 42% of
the automatically extracted traces have less than 1.2% of errors
(10/848). The attack also works when no mitigations are applied,
but significantly worse: On the Xeon, only about 7% of the observed
traces have less than 10 missing classifications and there is none
without wrong or ambiguous trace elements. As leakage is already
quite low, errors must be avoided at all cost, so many traces are
required to obtain a reliable trace with no mitigations. The CF