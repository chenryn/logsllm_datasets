# CVE-2018-8550分析与复现
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
**这个漏洞属于com组件Unmarshal类型本地权限提升漏洞**
## 复现环境
  1. Windows 10 1709 32位操作系统
  2. 需要安装声卡或操作系统自带虚拟声卡
  3. 编译环境Visual Studio 2013
## Poc 分析
[原poc](https://www.exploit-db.com/exploits/45893 "poc")作者James
Forshaw使用C#实现,我一直未复现成功,不过通过原poc的代码我大致明白了漏洞的成因和触发方法,原poc环境是win10 1803
X64系统.在cve2018-8550更新补丁出来不久,微软就取消了64位ole32.dll和coml2.dll调试符号提供,不过32的仍然可以正常提供.为了方便调试我用vc在32位系统上成功复现了poc.
poc采用的反射从低权限进程(poc进程)向高权限进程(bits服务)Unmarshal方式实现触发bits复制了一个poc进程中的一个句柄至高权限进程从而用来创建进程实现提权,Unmarshal采用的ClassID为CLSID_DfMarshal={
0x0000030B, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
}
,Bits服务器调用了ole32(在win10中被代码迁移到coml2)的DfUnMarshalInterface方法来Unmarshal的数据流中SDfMarshalPacket被poc精心构造的数据包,由于poc使用的是StgCreateDocfile创建IStorage对象,所以最终DfUnMarshalInterface调用了CExposedDocFile::Unmarshal来Unmarshal,下面是逆向的代码:
    int __stdcall CExposedDocFile::Unmarshal(IStream *pstm, void **ppv, unsigned int mshlflags)
    {
      int hrFinal; // esi
      int hrTempNext; // eax
      CPubDocFile *CPubDocFileObj; // eax
      CGlobalContext *CGlobalContextObj; // eax
      const void *v7; // eax
      CGlobalContext *CGlobalContextObjRef; // eax
      CPubDocFile *CBasedPubDocFileObjFirst; // eax
      unsigned int fUnmarshalOriginalConfig; // eax
      CPubDocFile *CBasedPubDocFileObjFirstRef; // ecx
      int fUnmarshalOriginalConfigRef; // ST10_4
      int IsRootConfig; // eax
      void *ReservedForOleRef; // ebx
      unsigned int CMarshalListObj_baseObj; // ecx
      unsigned int pid; // eax
      CMarshalList *CMarshalListObjFirst; // ecx
      CMarshalList *CMarshalListObjFound; // eax
      CExposedDocFile *CExposedDocFile_MarshalList_Final; // esi
      CExposedDocFile *CExposedDocFileObjNext; // eax MAPDST
      CDFBasis *CBasedDFBasisObj; // esi
      CPubDocFile *CBasedPubDocFileObjNext; // edx
      CSmAllocator *CSmAllocator_A; // eax
      CSmAllocator *CSmAllocator_B; // eax
      unsigned int CBasedMarshalListObj; // eax
      CMarshalList *CBasedMarshalListObjNext; // ecx
      CPubDocFile *CPubDocFileObjNext; // eax
      CDFBasis *BasedDFBasisObj; // eax
      CPerContext *CPerContextObjRef; // ecx
      CSmAllocator *CSmAllocator_C; // eax
      CSmAllocator *CSmAllocator_D; // eax
      CPerContext pcSharedMemory; // [esp+Ch] [ebp-8Ch]
      unsigned int cbRead; // [esp+50h] [ebp-48h]
      SDfMarshalPacket SDfMarshalPacketCurrent; // [esp+54h] [ebp-44h]
      IStorage *pstorgeStd; // [esp+88h] [ebp-10h]
      CDfMutex mtx; // [esp+8Ch] [ebp-Ch]
      CPerContext *CPerContextObj; // [esp+94h] [ebp-4h]
      void *pvBaseOld; // [esp+A0h] [ebp+8h]
      // SDfMarshalPacketCurrent初始化里面的字段指针都是nullptr
      mtx._pGlobalPortion = 0;
      mtx._hLockEvent = 0;
      pstorgeStd = 0;
      SDfMarshalPacketCurrent.CBasedPubDocFileObj._SelftobjectPtr = 0;
      SDfMarshalPacketCurrent.CBasedPubStreamObj._SelftobjectPtr = 0;
      SDfMarshalPacketCurrent.CBasedSeekPointerObj._SelftobjectPtr = 0;
      SDfMarshalPacketCurrent.CBasedMarshalListObj._SelftobjectPtr = 0;
      SDfMarshalPacketCurrent.CBasedDFBasisObj._SelftobjectPtr = 0;
      SDfMarshalPacketCurrent.CBasedGlobalContextObj._SelftobjectPtr = 0;
      SDfMarshalPacketCurrent.CBasedGlobalFileStreamObj._SelftobjectPtr = 0;
      SDfMarshalPacketCurrent.CBasedGlobalFileStreamDirty._SelftobjectPtr = 0;
      SDfMarshalPacketCurrent.CBasedGlobalFileStreamOriginal._SelftobjectPtr = 0;
      // 构造pcSharedMemory是一个cpercontext,先构造变量
      CPerContext::CPerContext(&pcSharedMemory, 0);
      // 通用marshal方法先CoUnmarshalInterface
      CoUnmarshalInterface(pstm, &IID_IStorage, (IUnknown *)&pstorgeStd);
      if ( (mshlflags & 0x80000000) != 0 )
      {
        // 这里都读流int就是largeint
        hrFinal = ((int (__stdcall *)(IStream *, signed int, _DWORD, signed int, _DWORD))pstm->_SelfStreamVtbl->Seek)(
                    pstm,
                    96,
                    0,
                    1,
                    0);
        if ( hrFinal >= 0 )
          hrFinal = -2147287039;
        goto EH_std_0;
      }
      // 把SDfMarshalPacketCurrent读出来
      hrFinal = pstm->_SelfStreamVtbl->Read(pstm, &SDfMarshalPacketCurrent, 52u, &cbRead);
      if ( hrFinal >= 0 )
      {
        if ( cbRead != 52 )
        {
          hrFinal = -2147287010;
          goto EH_std_0;
        }
        // pcSharedMemory也是从packet中反序列化出来的,里面需要判断进程id
        UnmarshalSharedMemory(&SDfMarshalPacketCurrent, mshlflags, &pcSharedMemory);
        hrFinal = hrTempNext;
        if ( hrTempNext ReservedForOle;
        // 反序列化出来全局baseDocFile,需要先验证这个是否正确
        if ( SDfMarshalPacketCurrent.CBasedPubDocFileObj._SelftobjectPtr )
          CPubDocFileObj = (CPubDocFile *)(SDfMarshalPacketCurrent.CBasedPubDocFileObj._SelftobjectPtr
                                         + *(_DWORD *)NtCurrentTeb()->ReservedForOle);
        else
          CPubDocFileObj = 0;
        // 验证只是判断里面的sig
        hrFinal = CPubDocFile::Validate(CPubDocFileObj);
        if ( hrFinal ReservedForOle);
        else
          CGlobalContextObj = 0;
        if ( !CGlobalContextObj
          || (!SDfMarshalPacketCurrent.CBasedGlobalContextObj._SelftobjectPtr ? (v7 = 0) : (v7 = (const void *)(SDfMarshalPacketCurrent.CBasedGlobalContextObj._SelftobjectPtr + *(_DWORD *)NtCurrentTeb()->ReservedForOle)),
              !IsValidPtrIn(v7, 0x30u)) )
        {
          hrFinal = -2147287031;
          goto EH_Err_109;
        }
        // 全局环境变量CGlobalContextObjRef也反序列出来
        if ( SDfMarshalPacketCurrent.CBasedGlobalContextObj._SelftobjectPtr )
          CGlobalContextObjRef = (CGlobalContext *)(SDfMarshalPacketCurrent.CBasedGlobalContextObj._SelftobjectPtr
                                                  + *(_DWORD *)NtCurrentTeb()->ReservedForOle);
        else
          CGlobalContextObjRef = 0;
        // 里面是CGlobalContext的初始化它的锁createevent
        hrFinal = CDfMutex::Init(&mtx, CGlobalContextObjRef, 0);
        if ( hrFinal ReservedForOle);
        else
          CBasedPubDocFileObjFirst = 0;
        fUnmarshalOriginalConfig = CBasedPubDocFileObjFirst->PRevertableObj._UnmarshalOriginalConfig;
        if ( SDfMarshalPacketCurrent.CBasedPubDocFileObj._SelftobjectPtr )
          CBasedPubDocFileObjFirstRef = (CPubDocFile *)(SDfMarshalPacketCurrent.CBasedPubDocFileObj._SelftobjectPtr
                                                      + *(_DWORD *)NtCurrentTeb()->ReservedForOle);
        else
          CBasedPubDocFileObjFirstRef = 0;
        // 2个配置做与运算双重判断
        fUnmarshalOriginalConfigRef = fUnmarshalOriginalConfig & 4;
        // 这个配置判断是否是Rootl类型的PubDocFile
        IsRootConfig = CPubDocFile::IsRoot(CBasedPubDocFileObjFirstRef);
        // 这里只是根据读取到的2个配置反序列化出来一个环境变量CPerContextObj
        hrFinal = UnmarshalContext(
                    &SDfMarshalPacketCurrent,
                    &CPerContextObj,
                    mshlflags,
                    // 是否Root配置
                    IsRootConfig,
                    // Unmarshal配置
                    fUnmarshalOriginalConfigRef);
        if ( hrFinal ReservedForOle;
        if ( gs_iSharedHeaps ReservedForOle;
          else
            CMarshalListObj_baseObj = 0;
          if ( CExposedDocFile::Validate((CExposedDocFile *)(CMarshalListObj_baseObj != 0 ? CMarshalListObj_baseObj - 72 : 0)) ReservedForOle);
            else
              CMarshalListObjFirst = 0;
            // 如果是当前进程先从CMarshalList找到最终的CExposedDocFile
            CMarshalListObjFound = CMarshalList::FindMarshal(CMarshalListObjFirst, pid, ReservedForOleRef);
            // 找到CMarshalListObjFound后只是它的指针偏移量减6作为最终结果
            CExposedDocFile_MarshalList_Final = (CExposedDocFile *)(CMarshalListObjFound != 0 ? (unsigned int)&CMarshalListObjFound[-6] : 0);
          }
          if ( CExposedDocFile_MarshalList_Final )
          {
            // 如果找到找到最终的CExposedDocFile的FBasis就从之前的CPerContextObj把里面字段赋值
            if ( SDfMarshalPacketCurrent.CBasedDFBasisObj._SelftobjectPtr )
              // BasedDFBasisObj也是反序列出来之后再执行赋值
              BasedDFBasisObj = (CDFBasis *)(SDfMarshalPacketCurrent.CBasedDFBasisObj._SelftobjectPtr
                                           + *(_DWORD *)NtCurrentTeb()->ReservedForOle);
            else
              BasedDFBasisObj = 0;
            CPerContextObjRef = CPerContextObj;
            // 赋值之后就完成unmarshal
            BasedDFBasisObj->_lockbytesBasePtr = CPerContextObj->_LockBytesBasePtr;
            BasedDFBasisObj->_CFileStreamDirtyPtr = CPerContextObjRef->_CFileStreamDirtyPtr;
            BasedDFBasisObj->_LockBytesOriginalPtr = CPerContextObjRef->_LockBytesOriginalPtr;
            CExposedDocFile_MarshalList_Final->baseIUnkownPtr._SelfMarshalVtbl->AddRef((IUnknown *)CExposedDocFile_MarshalList_Final);
            // 最终结果addref环境局部变量释放release
            CPerContext::Release(CPerContextObj);
          }
          else
          {
            // 如果从MarshalList未找到
            CExposedDocFileObjNext = (CExposedDocFile *)CMallocBased::operator new(0x8Cu, CPerContextObj->_pMalloc);
            // 初始化最终的CExposedDocFileObjNext
            if ( CExposedDocFileObjNext )