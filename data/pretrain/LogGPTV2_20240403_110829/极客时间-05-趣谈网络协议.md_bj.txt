## 小结好了，今天的内容就到这里，我来总结一下。-   基于 NAT 的容器网络模型在微服务架构下有两个问题，一个是 IP    重叠，一个是端口冲突，需要通过 Overlay    网络的机制保持跨节点的连通性。-   Flannel 是跨节点容器网络方案之一，它提供的 Overlay    方案主要有两种方式，一种是 UDP 在用户态封装，一种是 VXLAN    在内核态封装，而 VXLAN 的性能更好一些。最后，给你留两个问题：1.  通过 Flannel    的网络模型可以实现容器与容器直接跨主机的互相访问，那你知道如果容器内部访问外部的服务应该怎么融合到这个网络模型中吗？2.  基于 Overlay    的网络毕竟做了一次网络虚拟化，有没有更加高性能的方案呢？我们的专栏更新到第 30讲，不知你掌握得如何？每节课后我留的思考题，你都有没有认真思考，并在留言区写下答案呢？我会从**已发布的文章中选出一批认真留言的同学**，赠送[学习奖励礼券]{.orange}和我整理的[独家网络协议知识图谱]{.orange}。欢迎你留言和我讨论。趣谈网络协议，我们下期见！![](Images/55417b60e9c8040807daf07e6bd9cb4b.png){savepage-src="https://static001.geekbang.org/resource/image/b5/fb/b5bc14cb81d3630919fee94a512cc3fb.jpg"}
# 第31讲 \| 容器网络之Calico：为高效说出善意的谎言上一节我们讲了 Flannel如何解决容器跨主机互通的问题，这个解决方式其实和虚拟机的网络互通模式是差不多的，都是通过隧道。但是Flannel有一个非常好的模式，就是给不同的物理机设置不同网段，这一点和虚拟机的Overlay 的模式完全不一样。在虚拟机的场景下，整个网段在所有的物理机之间都是可以"飘来飘去"的。网段不同，就给了我们做路由策略的可能。
## Calico 网络模型的设计思路我们看图中的两台物理机。它们的物理网卡是同一个二层网络里面的。由于两台物理机的容器网段不同，我们完全可以将两台物理机配置成为路由器，并按照容器的网段配置路由表。![](Images/0129d04375c9bcab3d83c93ce7fdc260.png){savepage-src="https://static001.geekbang.org/resource/image/1e/50/1e2420928488bdcf66ffd001393c3c50.jpg"}例如，在物理机 A 中，我们可以这样配置：要想访问网段172.17.9.0/24，下一跳是 192.168.100.101，也即到物理机 B 上去。这样在容器 A 中访问容器 B，当包到达物理机 A的时候，就能够匹配到这条路由规则，并将包发给下一跳的路由器，也即发给物理机B。在物理机 B 上也有路由规则，要访问 172.17.9.0/24，从 docker0的网卡进去即可。当容器 B 返回结果的时候，在物理机 B 上，可以做类似的配置：要想访问网段172.17.8.0/24，下一跳是 192.168.100.100，也即到物理机 A 上去。``{=html}当包到达物理机 B的时候，能够匹配到这条路由规则，将包发给下一跳的路由器，也即发给物理机A。在物理机 A 上也有路由规则，要访问 172.17.8.0/24，从 docker0的网卡进去即可。这就是**Calico 网络的大概思路**，**即不走 Overlay网络，不引入另外的网络性能损耗，而是将转发全部用三层网络的路由转发来实现**，只不过具体的实现和上面的过程稍有区别。首先，如果全部走三层的路由规则，没必要每台机器都用一个docker0，从而浪费了一个 IP 地址，而是可以直接用路由转发到 veth pair在物理机这一端的网卡。同样，在容器内，路由规则也可以这样设定：把容器外面的veth pair 网卡算作默认网关，下一跳就是外面的物理机。于是，整个拓扑结构就变成了这个图中的样子。![](Images/544820959c1fc287fc0aca12ca32df2a.png){savepage-src="https://static001.geekbang.org/resource/image/c3/9c/c3e999c033a0417df98c0bcc34c9349c.jpg"}
## Calico 网络的转发细节我们来看其中的一些细节。容器 A1 的 IP 地址为 172.17.8.2/32，这里注意，不是 /24，而是 /32，将容器A1 作为一个单点的局域网了。容器 A1 里面的默认路由，Calico 配置得比较有技巧。    default via 169.254.1.1 dev eth0 169.254.1.1 dev eth0 scope link 这个 IP 地址 169.254.1.1是默认的网关，但是整个拓扑图中没有一张网卡是这个地址。那如何到达这个地址呢？前面我们讲网关的原理的时候说过，当一台机器要访问网关的时候，首先会通过ARP 获得网关的 MAC 地址，然后将目标 MAC 变为网关的 MAC，而网关的 IP地址不会在任何网络包头里面出现，也就是说，没有人在乎这个地址具体是什么，只要能找到对应的MAC，响应 ARP 就可以了。ARP 本地有缓存，通过 ip neigh 命令可以查看。    169.254.1.1 dev eth0 lladdr ee:ee:ee:ee:ee:ee STALE这个 MAC 地址是 Calico 硬塞进去的，但是没有关系，它能响应ARP，于是发出的包的目标 MAC 就是这个 MAC 地址。在物理机 A 上查看所有网卡的 MAC 地址的时候，我们会发现 veth1 就是这个MAC 地址。所以容器 A1 里发出的网络包，第一跳就是这个 veth1这个网卡，也就到达了物理机 A 这个路由器。在物理机 A 上有三条路由规则，分别是去两个本机的容器的路由，以及去172.17.9.0/24，下一跳为物理机 B。    172.17.8.2 dev veth1 scope link 172.17.8.3 dev veth2 scope link 172.17.9.0/24 via 192.168.100.101 dev eth0 proto bird onlink同理，物理机 B 上也有三条路由规则，分别是去两个本机的容器的路由，以及去172.17.8.0/24，下一跳为物理机 A。    172.17.9.2 dev veth1 scope link 172.17.9.3 dev veth2 scope link 172.17.8.0/24 via 192.168.100.100 dev eth0 proto bird onlink如果你觉得这些规则过于复杂，我将刚才的拓扑图转换为这个更加容易理解的图。![](Images/628d197683999314161cdd70bc029e88.png){savepage-src="https://static001.geekbang.org/resource/image/e5/7d/e59559ad7b46b9811553b6b0a85e8e7d.jpg"}在这里，物理机化身为路由器，通过路由器上的路由规则，将包转发到目的地。在这个过程中，没有隧道封装解封装，仅仅是单纯的路由转发，性能会好很多。但是，这种模式也有很多问题。
## Calico 的架构
### 路由配置组件 Felix如果只有两台机器，每台机器只有两个容器，而且保持不变。我手动配置一下，倒也没啥问题。但是如果容器不断地创建、删除，节点不断地加入、退出，情况就会变得非常复杂。![](Images/f26de7e4f911ccb2c27a7a6cb437c896.png){savepage-src="https://static001.geekbang.org/resource/image/f2/31/f29027cca71f3dfbba8c2f1a35c29331.jpg"}就像图中，有三台物理机，两两之间都需要配置路由，每台物理机上对外的路由就有两条。如果有六台物理机，则每台物理机上对外的路由就有五条。新加入一个节点，需要通知每一台物理机添加一条路由。这还是在物理机之间，一台物理机上，每创建一个容器，也需要多配置一条指向这个容器的路由。如此复杂，肯定不能手动配置，需要每台物理机上有一个agent，当创建和删除容器的时候，自动做这件事情。这个 agent 在 Calico中称为 Felix。