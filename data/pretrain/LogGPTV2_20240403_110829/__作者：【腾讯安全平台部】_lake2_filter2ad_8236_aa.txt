**作者：【腾讯安全平台部】 lake2  
公众号：[腾讯安全应急响应中心](https://mp.weixin.qq.com/s/QJeW7K-KThYHggWtJ-Fh3w
"腾讯安全应急响应中心")**
### 前言
两年兴起的大型网络攻防对抗比赛以实战的方式进行，这个举措非常好，以攻促防（“talk is cheap，show me the
shell”），参赛大企业会更加关注实际的安全威胁并且想办法缓解，客观上也繁荣了安全行业，一时间相关的安全服务及安全产品畅销，特别是有实时检测和阻断能力的IDS/IPS大放异彩。
于是，大企业纷纷采购部署IDS、IPS、WAF这些安全防护产品，压缩了攻击面，那就带来两个问题：
  1. 渗透测试这个方向还有没有机会？也有渗透测试人员发的知乎热帖[1]对未来提出困惑；
  2. 部署了IDS/IPS设备，在设备后端被防护着的系统的安全漏洞是否还要修复？不要急着回答，且看后文。
（以下字数约4000字，阅读时长约10分钟）
### 一. IDS/IPS防护原理及绕过思路
> IDS工作在网络层，旁路部署，通过抓取和分析网络流量来发现攻击；
>
>
> IPS一般也是在网络层旁路，可以理解为具备阻断能力的IDS，是IDS的升级版（也有IDS检测到攻击通知阻断设备执行阻断动作的设备联动模式），可以覆盖网络层和应用层；
>
> WAF是在应用层防护Web攻击的程序，一般是跟Web接入层对接，可旁路可串行，仅能覆盖应用层，详细的技术原理和实践可参考TSRC博客的这篇文章[2]。
>
> 本文为阐述方便，统一把网络层的旁路防护设备视为IPS。
安全专家们关于应用层WAF的绕过探讨已经很多了[3]，TSRC博客近期也会推出推出一篇WAF绕过的文章，所以本文就不落窠臼，我们下沉到网络层来玩玩。
现在看来，IPS的旁路防护原理很简单，其经典代表如开源的Snort，就是在网络上分析流量，发现符合规则的流量则冒充服务端回包响应客户端实现阻断或者替换的目的，这是一种典型的链路劫持手法。常见的场景是封禁网站（如非法网站的封禁）、篡改网页内容（运营商插广告）、阻断端口扫描和漏洞攻击（IPS），实施链路劫持的人必须控制某段网络。
用旧作《某电商网站流量劫持案例分析与思考》[4]里面的一幅图来示意，攻击者嗅探到符合特征的流量后即伪造响应，这里是伪造了HTTP响应（为了篡改页面），如果只是阻断的话就是伪造rst包干扰TCP握手过程或者连接。
为什么IPS多是旁路很少串行？超大流量下的串行处理对设备的性能是巨大的挑战，你可以尝试下，相信你会回来同意我的意见的。
因为IPS是旁路部署，所以只能通过发伪造包的方式来达到干扰双方正常通信的目的，正常的包其实还是会到达客户端和服务端，只不过相同序号的包操作系统已经处理过了，这些包会被认为是错误的包从而丢掉。
所以，从原理分析，绕过IPS可以从两个方向着手：
  1. 检测上，如果IPS在流量里检测不到攻击特征，则不会有后续动作；
  2. 阻断上，正常包也会到达服务器，只是来晚了，如果有办法让伪造的包失效，则阻断不会发生。
### 二. IPS绕过实例
常见的IPS阻断场景有四种：
  1. 可以建立TCP连接，检查客户端发出的HTTP请求中的特征，如匹配则发rst阻断或HTTP响应替换，用于域名封禁或Web攻击防护；
  2. 不让建立TCP连接，即客户端发syn包时IPS直接回rst，同时后续如有ack包会双向回rst阻断，用于访问控制或端口封禁；
  3. DNS查询场景，伪造DNS响应，劫持网站域名用于封禁或者钓鱼攻击；
  4. UDP传输场景下，伪造ICMP响应，告知客户端UDP端口不可达。
对于1，可以从两方面入手：在应用层，一般利用IPS和Web
Server对HTTP语法的理解差异；在网络层，一般利用IPS和操作系统协议栈对TCP/IP的处理方式差异，后文会讨论；
对于2，暴露面比较窄，绕过会困难一点，但也不是不可能；
对于3，换个DNS Server就行了，业界对DNS劫持也有很好的方案，这里不再赘述；
对于4，是阻断UDP访问，分析见后文。
下面按技术手法介绍一些常见的网络层绕过手法，均实测过：
#### 1、TCP分片
一些IPS是字节级逐包检查的，并没有实现TCP分片重组能力，那就把关键字拆到两个TCP包里面就可以暗度陈仓。以下是Perl实现的TCP分片HTTP请求，关键字是“www.bad.com”，会拆分到两个TCP包发出。
    use IO::Socket;
    $sock = new IO::Socket::INET (PeerAddr =>  '118.x.x.x',
                                  PeerPort =>  'http(80)');
    die "Couldn't create socket: $@" unless  $sock;
    $sock->autoflush(1);
    # ==========   case1  TCP frag bypass 
    $sock->print("GET / HTTP/1.1\r\nHost: www.b");
    sleep(4);
    $sock->print("ad.com\r\n\r\n");
    $document = join('', $sock->getlines());
    print "\n$document\n";
看图，TCP分片绕过，返回了200（如果不实施TCP分片，会返回302）。
![
](https://images.seebug.org/content/images/2020/04/f0874076-2027-402d-b05a-88256936dc6d.png-w331s)
慢！如果IPS实现了TCP分片重组怎么办？
这个问题问得好，仔细看代码，里面有个sleep，它并非是凑数的：有的IPS虽然有TCP分片重组能力，但是不会无限等待，会有个时间，超过这个时间就不会再检查了，所以设置这个sleep的时间超过IPS的分片重组超时值而又没有达到操作系统和Web
Server的超时值，那就可以绕过。
#### 2、IP分片
IP包也是支持分片的，原理类似，只是要构造IP包就需要用到Python下的组件Scapy，TCP三次握手后用Scapy的fragment函数按600字节一个拆分发送IP分片包（当然也可以把syn包也分片），代码如下：
![
](https://images.seebug.org/content/images/2020/04/f7bb6fd5-8aeb-4053-b6fa-c90bdcc6c89c.png-w331s)
看看效果：
![
](https://images.seebug.org/content/images/2020/04/b22e07cc-5398-497c-9ec4-c16010e84c44.png-w331s)
IP分片重组超时绕过的原理与TCP一样，不多说。需要注意的是，TCP分片更通用，IP分片受到链路上网络设备的影响，有可能中途会被网关重组或者丢弃，达不到预期效果。