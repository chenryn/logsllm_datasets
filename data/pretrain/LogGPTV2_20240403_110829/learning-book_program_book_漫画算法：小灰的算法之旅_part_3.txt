---
## Page 41
在这种情况下，我们就有必要利用一
些中间数据了。
如何利用中间数据呢？
当遍历整个数列时，每遍历一个整数，就把该整数存储起来，就像放到
字典中一样。当遍历下一个整数时，不必再慢慢向前回溯比较，而直接
去"字典"中查找，看看有没有对应的整数即可。
假如已经遍历了数列的前7个整数，那么字典里存储的信息如下。
Key Value
31
31254972
1
5
+
9
“字典"左侧的Key代表整数的值，“字典"右侧的Value代表该整数出现的
次数（也可以只记录Key）。
接下来，当遍历到最后一个整数2时，从“字典"中可以轻松找到2曾经出
现过，问题也就迎刃而解了。
---
## Page 42
3125497
6
71
由于读写“字典"本身的时间复杂度是0(1），所以整个算法的时间复杂度
是0(m)，和最初的双重循环相比，运行效率大大提高了。
而这个所谓的“字典”，是一种特殊的数据结构，叫作散列表。这个数据
结构需要开辟一定的内存空间来存储有用的数据信息。
但是，内存空间是有限的，在时间复杂度相同的情况下，算法占用的内
存空间自然是越小越好。如何描述一个算法占用的内存空间的大小呢？
这就用到了算法的另一个重要指标—空间复杂度（space
complexity）
和时间复杂度类似，空间复杂度是对一个算法在运行过程中临时占用存
储空间大小的量度，它同样使用了大0表示法。
程序占用空间大小的计算公式记作S(n)=O(f(n))，其中n为问题的规模，
f(n)为算法所占存储空间的函数。
1.3.2空间复杂度的计算
基本的概念已经明白了，那么，
我们如何来计算空间复杂度呢？
---
## Page 43
具体情况要具体分析。和时间复杂度
类似，空间复杂度也有几种不同的增长趋势。
常见的空间复杂度有下面几种情形。
1.常量空间
当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂
度记作0(1)。例如下面这段程序：
1.void fun1(int n){
2.
int var = 3;
3.
4.}
2.线性空间
当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入
规模n成正比时，空间复杂度记作0(m)。
例如下面这段程序：
1. void fun2(int n){
2.
int[] array = new int[n];
3.
4.}
---
## Page 44
3.二维空间
当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输
入规模n成正比时，空间复杂度记作0(n²）。
例如下面这段程序：
1. void fun3(int n){
2.
int[][] matrix = new int[n][n];
3.
4.}
4.递归空间
递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或
集合，但是计算机在执行程序时，会专门分配一块内存，用来存储“方
法调用栈”。
“方法调用栈"包括进栈和出栈两个行为。
当进入一个新方法时，执行入栈操作，把调用的方法和参数信息压入栈
中。
当方法返回时，执行出栈操作，把调用的方法和参数信息从栈中弹出。
下面这段程序是一个标准的递归程序：
1. void fun4(int n){
2.
if(nsize){
---
## Page 57
17.
thrownew IndexOutofBoundsException（"超出数组实际元
素范围！")；
18.
19.
//从右向左循环，将元素逐个向右挪1位
20.
for(int i=size-1; i>=index; i--){
21.
array[i+1] = array[i];
22.
23.
//腾出的位置放入新元素
24.
array[index]= element;
25.
size++;
26.}
27.
28.
/ **
29.
输出数组
30.
*/
31.
public void output(){
32.
for(int i=θ; i<size; i++){
33.
System.out.println(array[i]);
34.
35.}
36.
37. public static void main(String[] args) throws Exception {
38.
MyArray myArray = new MyArray(1o);
39.
myArray.insert(3, 0);
---
## Page 58
40.
myArray.insert(7,1);
41.
myArray.insert(9, 2);
42.
myArray.insert(5,3);
43.
myArray.insert(6, 1);
44.
myArray.output();
45.}
代码中的成员变量size是数组实际元素的数量。如果插入元素在数组尾
部，传入的下标参数index等于size：如果插入元素在数组中间或头部，
则index小于size。
如果传入的下标参数index大于size或小于0，则认为是非法输入，会直
接抛出异常。
可是，如果数组不断插入新的元