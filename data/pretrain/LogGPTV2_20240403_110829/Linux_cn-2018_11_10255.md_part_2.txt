> 
> 
> 名字是四个字母的语言。
> 
> 
> 
（LCTT 译注：“四个字母”，参见：[四字神名](https://zh.wikipedia.org/wiki/%E5%9B%9B%E5%AD%97%E7%A5%9E%E5%90%8D)，致谢 [no1xsyzy](https://github.com/LCTT/TranslateProject/issues/11320)）
以下这句话我实在不好在人前说；不过，我还是觉得，这样一种 “Lisp 是奥术魔法”的文化模因实在是有史以来最奇异、最迷人的东西。Lisp 是象牙塔的产物，是人工智能研究的工具；因此，它对于编程界的俗人而言总是陌生的，甚至是带有神秘色彩的。然而，当今的程序员们[开始怂恿彼此，“在你死掉之前至少试一试 Lisp”](https://www.reddit.com/r/ProgrammerHumor/comments/5c14o6/xkcd_lisp/d9szjnc/)，就像这是一种令人恍惚入迷的致幻剂似的。尽管 Lisp 是广泛使用的编程语言中第二古老的（只比 Fortran 年轻一岁）   1  ，程序员们也仍旧在互相怂恿。想象一下，如果你的工作是为某种组织或者团队推广一门新的编程语言的话，忽悠大家让他们相信你的新语言拥有神力难道不是绝佳的策略吗？—— 但你如何能够做到这一点呢？或者，换句话说，一门编程语言究竟是如何变成人们口中“隐晦知识的载体”的呢？
Lisp 究竟是怎么成为这样的？
![Byte 杂志封面,1979年八月。](/data/attachment/album/201811/20/171510jy9911uyu1syvat1.jpg)
*Byte 杂志封面，1979年八月。*
### 理论 A ：公理般的语言
Lisp 的创造者 约翰·麦卡锡   John McCarthy 最初并没有想过把 Lisp 做成优雅、精炼的计算法则结晶。然而，在一两次运气使然的深谋远虑和一系列优化之后，Lisp 的确变成了那样的东西。  保罗·格雷厄姆   Paul Graham （我们一会儿之后才会聊到他）曾经这么写道， 麦卡锡通过 Lisp “为编程作出的贡献就像是欧几里得对几何学所做的贡献一般”    2 。人们可能会在 Lisp 中看出更加隐晦的含义 —— 因为麦卡锡创造 Lisp 时使用的要素实在是过于基础，基础到连弄明白他到底是创造了这门语言、还是发现了这门语言，都是一件难事。
最初， 麦卡锡产生要造一门语言的想法，是在 1956 年的 达特茅斯人工智能夏季研究项目   Darthmouth Summer Research Project on Artificial Intelligence 上。夏季研究项目是个持续数周的学术会议，直到现在也仍旧在举行；它是此类会议之中最早开始举办的会议之一。 麦卡锡当初还是个达特茅斯的数学助教，而“ 人工智能   artificial intelligence （AI）”这个词事实上就是他建议举办该会议时发明的    3 。在整个会议期间大概有十人参加    4 。他们之中包括了 艾伦·纽厄尔   Allen Newell 和 赫伯特·西蒙   Herbert Simon ，两名隶属于 兰德公司   RAND Corporation 和 卡内基梅隆大学   Carnegie Mellon 的学者。这两人不久之前设计了一门语言，叫做 IPL。
当时，纽厄尔和西蒙正试图制作一套能够在命题演算中生成证明的系统。两人意识到，用电脑的原生指令集编写这套系统会非常困难；于是他们决定创造一门语言——他们的原话是“ 伪代码   pseudo-code ”，这样，他们就能更加轻松自然地表达这台“ 逻辑理论机器   Logic Theory Machine ”的底层逻辑了    5 。这门语言叫做 IPL，即“ 信息处理语言   Information Processing Language ”；比起我们现在认知中的编程语言，它更像是一种高层次的汇编语言方言。 纽厄尔和西蒙提到，当时人们开发的其它“伪代码”都抓着标准数学符号不放 —— 也许他们指的是 Fortran    6 ；与此不同的是，他们的语言使用成组的符号方程来表示命题演算中的语句。通常，用 IPL 写出来的程序会调用一系列的汇编语言宏，以此在这些符号方程列表中对表达式进行变换和求值。
麦卡锡认为，一门实用的编程语言应该像 Fortran 那样使用代数表达式；因此，他并不怎么喜欢 IPL    7 。然而，他也认为，在给人工智能领域的一些问题建模时，符号列表会是非常好用的工具 —— 而且在那些涉及演绎的问题上尤其有用。麦卡锡的渴望最终被诉诸行动；他要创造一门代数的列表处理语言 —— 这门语言会像 Fortran 一样使用代数表达式，但拥有和 IPL 一样的符号列表处理能力。
当然，今日的 Lisp 可不像 Fortran。在会议之后的几年中，麦卡锡关于“理想的列表处理语言”的见解似乎在逐渐演化。到 1957 年，他的想法发生了改变。他那时候正在用 Fortran 编写一个能下国际象棋的程序；越是长时间地使用 Fortran ，麦卡锡就越确信其设计中存在不当之处，而最大的问题就是尴尬的 `IF` 声明    8 。为此，他发明了一个替代品，即条件表达式 `true`；这个表达式会在给定的测试通过时返回子表达式 `A` ，而在测试未通过时返回子表达式 `B` ，*而且*，它只会对返回的子表达式进行求值。在 1958 年夏天，当麦卡锡设计一个能够求导的程序时，他意识到，他发明的 `true` 条件表达式让编写递归函数这件事变得更加简单自然了    9 。也是这个求导问题让麦卡锡创造了 `maplist` 函数；这个函数会将其它函数作为参数并将之作用于指定列表的所有元素    10 。在给项数多得叫人抓狂的多项式求导时，它尤其有用。
然而，以上的所有这些，在 Fortran 中都是没有的；因此，在 1958 年的秋天，麦卡锡请来了一群学生来实现 Lisp。因为他那时已经成了一名麻省理工助教，所以，这些学生可都是麻省理工的学生。当麦卡锡和学生们最终将他的主意变为能运行的代码时，这门语言得到了进一步的简化。这之中最大的改变涉及了 Lisp 的语法本身。最初，麦卡锡在设计语言时，曾经试图加入所谓的 “M 表达式”；这是一层语法糖，能让 Lisp 的语法变得类似于 Fortran。虽然 M 表达式可以被翻译为 S 表达式 —— 基础的、“用圆括号括起来的列表”，也就是 Lisp 最著名的特征 —— 但 S 表达式事实上是一种给机器看的低阶表达方法。唯一的问题是，麦卡锡用方括号标记 M 表达式，但他的团队在麻省理工使用的 IBM 026 键盘打孔机的键盘上根本没有方括号    11 。于是 Lisp 团队坚定不移地使用着 S 表达式，不仅用它们表示数据列表，也拿它们来表达函数的应用。麦卡锡和他的学生们还作了另外几样改进，包括将数学符号前置；他们也修改了内存模型，这样 Lisp 实质上就只有一种数据类型了    12 。
到 1960 年，麦卡锡发表了他关于 Lisp 的著名论文，《用符号方程表示的递归函数及它们的机器计算》。那时候，Lisp 已经被极大地精简，而这让麦卡锡意识到，他的作品其实是“一套优雅的数学系统”，而非普通的编程语言    13 。他后来这么写道，对 Lisp 的许多简化使其“成了一种描述可计算函数的方式，而且它比图灵机或者一般情况下用于递归函数理论的递归定义更加简洁”    14 。在他的论文中，他不仅使用 Lisp 作为编程语言，也将它当作一套用于研究递归函数行为方式的表达方法。
通过“从一小撮规则中逐步实现出 Lisp”的方式，麦卡锡将这门语言介绍给了他的读者。后来，保罗·格雷厄姆在短文《   Lisp 之根    The Roots of Lisp 》中用更易读的语言回顾了麦卡锡的步骤。格雷厄姆只用了七种原始运算符、两种函数写法，以及使用原始运算符定义的六个稍微高级一点的函数来解释 Lisp。毫无疑问，Lisp 的这种只需使用极少量的基本规则就能完整说明的特点加深了其神秘色彩。格雷厄姆称麦卡锡的论文为“使计算公理化”的一种尝试    15 。我认为，在思考 Lisp 的魅力从何而来时，这是一个极好的切入点。其它编程语言都有明显的人工构造痕迹，表现为 `While`，`typedef`，`public static void` 这样的关键词；而 Lisp 的设计却简直像是纯粹计算逻辑的鬼斧神工。Lisp 的这一性质，以及它和晦涩难懂的“递归函数理论”的密切关系，使它具备了获得如今声望的充分理由。
### 理论 B：属于未来的机器
Lisp 诞生二十年后，它成了著名的《   黑客词典    Hacker’s Dictionary 》中所说的，人工智能研究的“母语”。Lisp 在此之前传播迅速，多半是托了语法规律的福 —— 不管在怎么样的电脑上，实现 Lisp 都是一件相对简单直白的事。而学者们之后坚持使用它乃是因为 Lisp 在处理符号表达式这方面有巨大的优势；在那个时代，人工智能很大程度上就意味着符号，于是这一点就显得十分重要。在许多重要的人工智能项目中都能见到 Lisp 的身影。这些项目包括了 [SHRDLU 自然语言程序](https://hci.stanford.edu/winograd/shrdlu/)、[Macsyma 代数系统](https://en.wikipedia.org/wiki/Macsyma) 和 [ACL2 逻辑系统](https://en.wikipedia.org/wiki/ACL2)。
然而，在 1970 年代中期，人工智能研究者们的电脑算力开始不够用了。PDP-10 就是一个典型。这个型号在人工智能学界曾经极受欢迎；但面对这些用 Lisp 写的 AI 程序，它的 18 位地址空间一天比一天显得吃紧    16 。许多的 AI 程序在设计上可以与人互动。要让这些既极度要求硬件性能、又有互动功能的程序在分时系统上优秀发挥，是很有挑战性的。麻省理工的 彼得·杜奇   Peter Deutsch 给出了解决方案：那就是针对 Lisp 程序来特别设计电脑。就像是我那[关于 Chaosnet 的上一篇文章](https://twobithistory.org/2018/09/30/chaosnet.html)所说的那样，这些 Lisp 计算机   Lisp machines 会给每个用户都专门分配一个为 Lisp 特别优化的处理器。到后来，考虑到硬核 Lisp 程序员的需求，这些计算机甚至还配备上了完全由 Lisp 编写的开发环境。在当时那样一个小型机时代已至尾声而微型机的繁盛尚未完全到来的尴尬时期，Lisp 计算机就是编程精英们的“高性能个人电脑”。
有那么一会儿，Lisp 计算机被当成是未来趋势。好几家公司雨后春笋般出现，追着赶着要把这项技术商业化。其中最成功的一家叫做 Symbolics，由麻省理工 AI 实验室的前成员创立。上世纪八十年代，这家公司生产了所谓的 3600 系列计算机，它们当时在 AI 领域和需要高性能计算的产业中应用极广。3600 系列配备了大屏幕、位图显示、鼠标接口，以及[强大的图形与动画软件](https://youtu.be/gV5obrYaogU?t=201)。它们都是惊人的机器，能让惊人的程序运行起来。例如，之前在推特上跟我聊过的机器人研究者 Bob Culley，就能用一台 1985 年生产的 Symbolics 3650 写出带有图形演示的寻路算法。他向我解释说，在 1980 年代，位图显示和面向对象编程（能够通过 [Flavors 扩展](https://en.wikipedia.org/wiki/Flavors_(programming_language))在 Lisp 计算机上使用）都刚刚出现。Symbolics 站在时代的最前沿。
![Bob Culley 的寻路程序。](/data/attachment/album/201811/20/171510lw4x5e6sx9usgwj4.jpg)
*Bob Culley 的寻路程序。*
而以上这一切导致 Symbolics 的计算机奇贵无比。在 1983 年，一台 Symbolics 3600 能卖 111,000 美金    16 。所以，绝大部分人只可能远远地赞叹 Lisp 计算机的威力和操作员们用 Lisp 编写程序的奇妙技术。不止他们赞叹，从 1979 年到 1980 年代末，Byte 杂志曾经多次提到过 Lisp 和 Lisp 计算机。在 1979 年八月发行的、关于 Lisp 的一期特别杂志中，杂志编辑激情洋溢地写道，麻省理工正在开发的计算机配备了“大坨大坨的内存”和“先进的操作系统”    17 ；他觉得，这些 Lisp 计算机的前途是如此光明，以至于它们的面世会让 1978 和 1977 年 —— 诞生了 Apple II、Commodore PET 和 TRS-80 的两年 —— 显得黯淡无光。五年之后，在 1985 年，一名 Byte 杂志撰稿人描述了为“复杂精巧、性能强悍的 Symbolics 3670”编写 Lisp 程序的体验，并力劝读者学习 Lisp，称其为“绝大数人工智能工作者的语言选择”，和将来的通用编程语言    18 。
我问过 保罗·麦克琼斯   Paul McJones （他在 山景城   Mountain View   的 计算机历史博物馆   Computer History Museum 做了许多 Lisp 的[保护工作](http://www.softwarepreservation.org/projects/LISP/)），人们是什么时候开始将 Lisp 当作高维生物的赠礼一样谈论的呢？他说，这门语言自有的性质毋庸置疑地促进了这种现象的产生；然而，他也说，Lisp 上世纪六七十年代在人工智能领域得到的广泛应用，很有可能也起到了作用。当 1980 年代到来、Lisp 计算机进入市场时，象牙塔外的某些人由此接触到了 Lisp 的能力，于是传说开始滋生。时至今日，很少有人还记得 Lisp 计算机和 Symbolics 公司；但 Lisp 得以在八十年代一直保持神秘，很大程度上要归功于它们。
### 理论 C：学习编程