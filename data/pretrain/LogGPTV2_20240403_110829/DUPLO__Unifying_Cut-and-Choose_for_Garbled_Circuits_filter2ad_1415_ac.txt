and ğğšğ­(ğ•‚) = ğ„ğ±ğ©(ğ•‚) because only encryption gives raise to
nontrivial patterns.
d) Computational evaluation: Throughout this paper we
let ğœ… be the security parameter for cryptographic primitives in
the computational setting. For simplicity, all keys are assumed
to have length ğœ…. We use ğ—‡ğ–¾ğ—€ğ—…(ğœ…) to denote an arbitrary
negligible function of ğœ…, i.e., ğ—‡ğ–¾ğ—€ğ—…(ğœ…)  0 and suï¬ƒciently large ğœ…. To instantiate our symbolic
framework, we assume the existence of a length-doubling
pseudorandom generator  and an IND-CPA secure symmetric
encryption scheme (, ) with keys of length ğœ….
Deï¬nition 1 (Pseudorandom generator). A deterministic func-
tion  âˆ¶ {0, 1}ğœ… â†’ {0, 1}2ğœ… is a secure length-doubling
pseudorandom generator if it can be computed in polynomial
time and, for any PPT distinguisher  we have
||||| â‰¤ ğ—‡ğ–¾ğ—€ğ—…(ğœ…).
|||||
Pr
{(ğ‘ ) = 1} âˆ’ Pr
ğ‘Ÿâ†{0,1}ğœ…{(ğ–¦(ğ‘Ÿ)) = 1}
ğ‘ â†{0,1}2ğœ…
For any symmetric encryption scheme (, ) and ğ‘ âˆˆ
{0, 1}, the left-right encryption oracle ,ğ‘ ï¬rst samples a
uniformly random key ğ‘˜ â† {0, 1}ğœ…
, and then it answers
any encryption query of the form (ğ‘š0, ğ‘š1) with a ciphertext
(ğ‘˜, ğ‘šğ‘), where ğ‘š0 and ğ‘š1 are of the same length.
Deï¬nition 2 (IND-CPA secure symmetric encryption scheme).
A pair of PPT algorithms (, ) is an IND-CPA secure sym-
metric encryption scheme with key length ğœ… if the followings
hold:
Pr{(ğ‘˜, (ğ‘˜, ğ‘š)) = ğ‘š} = 1;
âˆ™ Correctness: For any ğ‘˜ âˆˆ {0, 1}ğœ… and ğ‘š âˆˆ {0, 1}âˆ—,
âˆ™ Security: For any PPT distinguisher ,
|||Pr{,0(1ğœ…) = 1} âˆ’ Pr{,1(1ğœ…) = 1}
||| â‰¤ ğ—‡ğ–¾ğ—€ğ—…(ğœ…),
where the probability is over the random choices of .
We assume that the size of a cipher-text (ğ‘˜, ğ‘š) is a function
of the size of the input ğ‘š, i.e., if two messages have the same
length, then their encryption also have the same length. We
do not make any special assumption on the encoding of pairs
(ğ‘’0, ğ‘’1), except that ğ‘’0 and ğ‘’1 can be recovered from (ğ‘’0, ğ‘’1),
and that the size of (ğ‘’0, ğ‘’1) depends only on the size of ğ‘’0 and
the size of ğ‘’1. For any ğ‘¥ âˆˆ {0, 1}ğœ…
, let 0(ğ‘¥) and 1(ğ‘¥) be the
ï¬rst and second halves of the bit-string (ğ‘¥), so that (ğ‘¥) =
0(ğ‘¥)1(ğ‘¥). Let ğœ be a function mapping ğ to {0, 1}, and ğŠ
to {0, 1}ğœ…
. We can extend ğœ to map any symbolic expression
to a distribution on bit-strings as follows:
ğœ(1) = 1,
ğœ(Â¬ğ‘) = 1 âˆ’ (ğœ(ğ‘)),
ğœ(â¦ƒğ‘’â¦„ğ‘˜) = (ğœ(ğ‘˜), ğœ(ğ‘’)),
ğœ(0) = 0,
ğœ(ğ–¦0(ğ‘˜)) = 0(ğœ(ğ‘˜)),
ğœ(ğ–¦1(ğ‘˜)) = 1(ğœ(ğ‘˜)),
ğœ((ğ‘’0, ğ‘’1)) = (ğœ(ğ‘’0), ğœ(ğ‘’1)),
{
ğœ(ğœ‹[ğ‘](ğ‘’0, ğ‘’1)) =
(ğœ(ğ‘’0), ğœ(ğ‘’1))
(ğœ(ğ‘’1), ğœ(ğ‘’0))
if ğœ(ğ‘) = 0
if ğœ(ğ‘) = 1
distribution obtained by ï¬rst choosing a uniformly random key
and bit assignment ğœ, and then picking a sample from ğœ(ğ‘’).1
It is easy to check (by induction) that any two expressions of
the same shape evaluate to bit-strings of the same length.
Lemma 1. For any shape ğ‘ , all strings in (cid:2)ğ„ğ±ğ©(ğ‘ )(cid:3) have the
same bit-length.
shape ğ‘  as the bit-length |ğ‘ | of any string in the set (cid:2)ğ„ğ±ğ©(ğ‘ )(cid:3),
Using this property, we can associate a bit-length to any
and extend the evaluation of expressions to evaluation of
patterns by deï¬ning
ğœ(â¦ƒğ‘ â¦„ğ‘˜) = (ğœ(ğ‘˜), 0|ğ‘ |).
e) Independence of pseudorandom keys: The following
deï¬nitions are given in [18] to provide a (computationally
sound) treatment of symbolic pseudorandom generators. For
any two keys ğ‘˜1, ğ‘˜2 âˆˆ ğŠâˆ—, if ğ‘˜2 âˆˆ ğ–¦âˆ—(ğ‘˜1) then we say that ğ‘˜1
yields ğ‘˜2, and denote this as ğ‘˜1 âª¯ ğ‘˜2, meaning that ğ‘˜2 can be
obtained from ğ‘˜1 by repeated application of the pseudorandom
generator. By ğ‘˜1 â‰º ğ‘˜2 we mean that ğ‘˜1 âª¯ ğ‘˜2 and ğ‘˜1 â‰  ğ‘˜2.
We say that ğ‘˜1 and ğ‘˜2 are independent if neither ğ‘˜1 âª¯ ğ‘˜2 nor
ğ‘˜2 âª¯ ğ‘˜1. The keys {ğ‘˜1, â€¦ , ğ‘˜ğ‘›} form an independent set if ğ‘˜ğ‘–
and ğ‘˜ğ‘— are independent for all ğ‘– â‰  ğ‘—. The root of any set of keys
ğ‘† is ğ‘ğ¨ğ¨ğ­ğ¬(ğ‘†) = ğ‘†â§µğ–¦+(ğ‘†). Thus ğ‘† is independent if and only
if ğ‘† = ğ‘ğ¨ğ¨ğ­ğ¬(ğ‘†). We recall the following theorem from [18]
which shows that independent symbolic keys correspond to
(computational) pseudorandom bit-strings.
Theorem 1 ([18, Theorem 1]). Let ğ‘˜1, â€¦ , ğ‘˜ğ‘› âˆˆ ğŠâˆ— be a se-
quence of symbolic keys. Then for any secure length-doubling
pseudorandom generator , the following two conditions are
equivalent:
1) The keys ğ‘˜1, â€¦ , ğ‘˜ğ‘› are symbolically independent (i.e.,
ğ‘˜ğ‘– âª¯ ğ‘˜ğ‘— if and only if ğ‘– = ğ‘—).
2) The probability distribution (cid:2)ğ‘˜1, â€¦ , ğ‘˜ğ‘›(cid:3) is compu-
tationally indistinguishable from (cid:2)ğ‘Ÿ1, â€¦ , ğ‘Ÿğ‘›(cid:3) where
ğ‘Ÿ1, â€¦ , ğ‘Ÿğ‘› âˆˆ ğŠ are distinct atomic key symbols.
f) Equivalence and Renaming of patterns: We consider
patterns up to simple operations that do not change the
probability distributions associated to them. First, let â‰¡ be the
smallest congruence relation on ğğšğ­ such that
Â¬0 â‰¡ 1
Â¬1 â‰¡ 0
Â¬(Â¬ğ‘) â‰¡ ğ‘
ğœ‹[0](ğ‘’0, ğ‘’1) â‰¡ (ğ‘’0, ğ‘’1)
ğœ‹[1](ğ‘’0, ğ‘’1) â‰¡ (ğ‘’1, ğ‘’0)
ğœ‹[Â¬ğ‘](ğ‘’0, ğ‘’1) â‰¡ ğœ‹[ğ‘](ğ‘’1, ğ‘’0)
for all ğ‘’0, ğ‘’1 âˆˆ ğğšğ­(ğ‘ ), and ğ‘ âˆˆ ğğšğ­(ğ”¹). It should be clear
from the computational interpretation of ğœ‹[ğ‘] and Â¬ğ‘ that
for any two equivalent patterns ğ‘’0 â‰¡ ğ‘’1 and any assignment
ğœ, the probability distributions ğœ(ğ‘’0) and ğœ(ğ‘’1) are identical.
Similarly, we deï¬ne a random bit renaming as a function
ğµ âˆ¶ ğ â†’ ğ
ğ›¼ğµ âˆ¶ ğ â†’ {ğ‘, Â¬ğ‘ âˆ£ ğ‘ âˆˆ ğ} such that its projection ğ›¼â€²
(deï¬ned by the condition ğ›¼ğµ(ğ‘) âˆˆ {ğ›¼â€²
ğµ(ğ‘), Â¬ğ›¼â€²
ğµ(ğ‘)}) is a
bijection on ğ. Random bit renamings are extended to patterns
ğ›¼ğµ âˆ¶ ğğšğ­(ğ‘ ) â†’ ğğšğ­(ğ‘ ) in the obvious way, and it is easy to
check that for any pattern ğ‘’ âˆˆ ğğšğ­(ğ‘ ) and assignment ğœ, the
distributions ğœ(ğ‘’) and ğœ(ğ›¼ğµ(ğ‘’)) are identical.
For keys, we consider a form of renaming that may change
the distribution associated to an expression or pattern, but in
a computationally indistinguishable way. Following [18], we
deï¬ne a pseudorandom key renaming as a mapping ğ›¼ğ¾ âˆ¶ ğ‘† â†’
ğŠâˆ— on ğ‘† âŠ† ğŠâˆ— that preserves ğ–¦, i.e.,
ğ–¦ğ‘¤(ğ‘˜1) = ğ‘˜2 âŸº ğ–¦ğ‘¤(ğ›¼ğ¾(ğ‘˜1)) = ğ›¼ğ¾(ğ‘˜2)
for all ğ‘¤ âˆˆ {0, 1}âˆ— and ğ‘˜1, ğ‘˜2 âˆˆ ğ‘†. We restate some useful
properties of key renamings proved in [18]:
1) [18, Lemma 1] Any pseudorandom key renaming
ğ›¼ğ¾ âˆ¶ ğ‘† â†’ ğŠâˆ— is a bijection from ğ‘† to ğ›¼ğ¾(ğ‘†). Moreover,
ğ‘† is independent if and only if ğ›¼ğ¾(ğ‘†) is independent.
2) [18, Lemma 2] Any pseudorandom key renaming ğ›¼ğ¾
with domain ğ‘† can be uniquely extended to a pseu-
dorandom key renaming Ì„ğ›¼ğ¾ with domain ğ–¦âˆ—(ğ‘†). In
particular, any pseudorandom key renaming can be
uniquely speciï¬ed as an extension Ì„ğ›¼ğ¾ of a bijection
ğ›¼ğ¾ âˆ¶ ğ´ â†’ ğµ between independent sets ğ´ = ğ‘ğ¨ğ¨ğ­ğ¬(ğ‘†)
and ğµ = ğ›¼ğ¾(ğ´).
3) [18, Lemma 5] For any pseudorandom key renaming
ğ›¼ğ¾ âˆ¶ ğ‘† â†’ ğŠâˆ— and set of keys ğ´ âŠ† ğ‘†, ğ›¼ğ¾(ğ‘ğ¨ğ¨ğ­ğ¬(ğ´)) =
ğ‘ğ¨ğ¨ğ­ğ¬(ğ›¼ğ¾(ğ´)).
Pseudorandom key renamings ğ›¼ğ¾ can also be extended to
patterns ğ›¼ğ¾ âˆ¶ ğğšğ­(ğ‘ ) â†’ ğğšğ­(ğ‘ ) in the obvious way, and while
the distributions ğœ(ğ‘’) and ğœ(ğ›¼ğ¾(ğ‘’)) may, in general be diï¬€erent,
they are always computationally indistinguishable.
The following lemma is an easy consequence of Theorem 1,
and, despite the fact that we use a larger class of expressions,
the proof is virtually identical to that of [18, Corollary 1].
Lemma 2. For any pattern ğ‘’ and pseudorandom key renaming
ğ›¼ğ¾, the distributions (cid:2)ğ‘’(cid:3) and (cid:2)ğ›¼ğ¾(ğ‘’)(cid:3) are computationally
indistinguishable.
We refer to a pair of mappings ğ›¼ = (ğ›¼ğµ, ğ›¼ğ¾) (consisting of
a random bit renaming ğ›¼ğµ and a pseudorandom key renaming
ğ›¼ğ¾ ) as a pseudorandom renaming, or simply a renaming.
For any pattern ğ‘’ âˆˆ ğğšğ­(ğ‘ ), we write ğ›¼(ğ‘’) = ğ›¼ğ¾(ğ›¼ğµ(ğ‘’)) =
ğ›¼ğµ(ğ›¼ğ¾(ğ‘’)) for the result of applying the renamings to the
pattern ğ‘’.2 Two patterns ğ‘’0 and ğ‘’1 are equivalent up to
renaming, denoted as ğ‘’0 â‰ˆ ğ‘’1, if there exists a renaming
ğ›¼ = (ğ›¼ğµ, ğ›¼ğ¾) such that ğ‘’0 â‰¡ ğ›¼(ğ‘’1). When we want
to
emphasize the renaming ğ›¼, we write ğ‘’0 â‰ˆğ›¼ ğ‘’1. It follows
from the previous statements that patterns that are equivalent
up to renaming evaluate to probability distributions that are
computationally indistinguishable.
g) Pattern computation: Following [12], the mapping
from expressions to patterns is deï¬ned by two functions:
âˆ™ A function ğ©(ğ‘’, ğ‘†) mapping an expression (or pattern) ğ‘’
and set of keys ğ‘† âŠ† ğŠâˆ— to the pattern representing the
1Notice that, even for ï¬xed ğœ and ğ‘’, the image ğœ(ğ‘’) is a probability
distribution because it involves the use of a probabilistic encryption scheme  .
2Notice that the mappings ğ›¼ğµ and ğ›¼ğ¾ commute, so they can be applied in
any order.
151
ğ©(ğ‘, ğ‘†) = ğ‘
ğ©(ğ‘˜, ğ‘†) = ğ‘˜
ğ©(â¦ƒğ‘ â¦„ğ‘˜, ğ‘†) =â¦ƒğ‘ â¦„ğ‘˜ ğ©(â¦ƒğ‘’â¦„ğ‘˜, ğ‘†) =
ğ©((ğ‘’0, ğ‘’1), ğ‘†) = (ğ©(ğ‘’0, ğ‘†), ğ©(ğ‘’1, ğ‘†))
ğ©(ğœ‹[ğ‘](ğ‘’, ğ‘’0), ğ‘†) = ğœ‹[ğ‘](ğ©(ğ‘’, ğ‘†), ğ©(ğ‘’0, ğ‘†))
if ğ‘˜ âˆˆ ğ‘†
if ğ‘˜ âˆ‰ ğ‘†
{ â¦ƒğ©(ğ‘’, ğ‘†)â¦„ğ‘˜
â¦ƒğ‘ â¦„ğ‘˜
Fig. 1. The pattern function ğ© âˆ¶ ğğšğ­ Ã— â„˜(ğğšğ­(ğ•‚)) â†’ ğğšğ­, deï¬ned for all
ğ‘ âˆˆ ğ„ğ±ğ©(ğ”¹), ğ‘˜ âˆˆ ğ„ğ±ğ©(ğ•‚), ğ‘’, ğ‘’0 âˆˆ ğ„ğ±ğ©(ğ‘ ), ğ‘’1 âˆˆ ğ„ğ±ğ©(ğ‘¡)
ğŠğğ²ğ¬(â¦ƒğ‘’â¦„ğ‘˜) = {ğ‘˜} âˆª ğŠğğ²ğ¬(ğ‘’)
ğŠğğ²ğ¬(â¦ƒğ‘ â¦„ğ‘˜) = {ğ‘˜}
ğŠğğ²ğ¬(ğ‘) = âˆ…
ğŠğğ²ğ¬(ğ‘˜) = {ğ‘˜}
ğŠğğ²ğ¬((ğ‘’0, ğ‘’1)) = ğŠğğ²ğ¬(ğ‘’0) âˆª ğŠğğ²ğ¬(ğ‘’1)
ğğšğ«ğ­ğ¬(â¦ƒğ‘’â¦„ğ‘˜) = {â¦ƒğ‘’â¦„ğ‘˜} âˆª ğğšğ«ğ­ğ¬(ğ‘’)
ğŠğğ²ğ¬(ğœ‹[ğ‘](ğ‘’0, ğ‘’1)) = ğŠğğ²ğ¬(ğ‘’0) âˆª ğŠğğ²ğ¬(ğ‘’1)
ğğšğ«ğ­ğ¬(â¦ƒğ‘ â¦„ğ‘˜) = {â¦ƒğ‘ â¦„ğ‘˜}
ğğšğ«ğ­ğ¬(ğ‘) = {ğ‘}
ğğšğ«ğ­ğ¬(ğ‘˜) = {ğ‘˜}
ğğšğ«ğ­ğ¬((ğ‘’0, ğ‘’1)) = {(ğ‘’0, ğ‘’1)} âˆª ğğšğ«ğ­ğ¬(ğ‘’0) âˆª ğğšğ«ğ­ğ¬(ğ‘’1)
ğğšğ«ğ­ğ¬(ğœ‹[ğ‘](ğ‘’0, ğ‘’1)) = {ğœ‹[ğ‘](ğ‘’0, ğ‘’1)} âˆª ğğšğ«ğ­ğ¬((ğ‘’0, ğ‘’1))
Fig. 2. The deï¬nition of the keys and parts of a sub-expression. As usual