provider (see Figure 15-3).
Regardless of the end user’s domain, the client web application only trusts the 
identity provider in its own domain. Internal as well as external users are first redirected 
to the internal (or local) SAML identity provider. The local identity provider should offer 
the user the option to pick whether to authenticate with their username and password 
Chapter 15  patterns and praCtiCes
310
(for internal users) or to pick their corresponding domain. Then the identity provider 
can redirect the user to the corresponding identity provider running in the external 
user’s home domain. Now the external identity provider returns a SAML response to the 
internal identity provider.
The external identity provider signs this SAML token. If the signature is valid, and if 
it’s from a trusted external identity provider, the internal identity provider issues a new 
SAML token signed by itself to the calling application. The flow then continues as shown 
in Figure 15-2.
Note One benefit of this approach is that the internal applications only need to 
trust their own identity provider. the identity provider handles the brokering of trust 
between other identity providers outside its domain. in this scenario, the external 
identity provider also talks saML, but that can’t be expected all the time. there are 
also identity providers that support other protocols. in such scenarios, the internal 
identity provider must be able to transform identity assertions between different 
protocols.
 Delegated Access Control with the JSON Web Token
Suppose a medium-scale enterprise that has a number of APIs. Company employees 
are allowed to access these APIs via web applications while they’re behind the 
company firewall. All user data are stored in Microsoft Active Directory, and all the web 
applications are connected to an OpenID Connect identity provider to authenticate 
users. The web applications need to access back-end APIs on behalf of the logged-in user.
This use case is also an extension of the SSO with the Delegated Access Control pattern. 
The catch here is the statement, “all the web applications are connected to an OpenID 
Connect identity provider to authenticate users.” You need to replace the SAML identity 
provider shown in Figure 15-2 with an OpenID Connect identity provider, as illustrated in 
Figure 15-4. This also suggests the need for an access delegation protocol (OAuth).
In this case, however, users don’t present their credentials directly to the web 
application; rather, they authenticate through an OpenID Connect identity provider. 
Thus, you need to find a way to exchange the ID token received in OpenID Connect 
authentication for an OAuth access token, which is defined in the JWT grant type for 
Chapter 15  patterns and praCtiCes
311
OAuth 2.0 specification (Chapter 12). Once the web application receives the ID token 
in step 3, which is also a JWT, it has to exchange it for an access token by talking to the 
OAuth 2.0 authorization server. The authorization server must trust the OpenID Connect 
identity provider. When the web application gets the access token, it can use it to access 
back-end APIs.
Figure 15-4. Delegated Access Control with the JWT pattern
Note Why would someone exchange the id token obtained in Openid Connect 
for an access token when it directly gets an access token along with the id 
token? this is not required when both the Openid Connect server and the Oauth 
authorization server are the same. if they aren’t, you have to use the JWt Bearer 
grant type for Oauth 2.0 and exchange the id token for an access token. the 
access token issuer must trust the Openid Connect identity provider.
 Nonrepudiation with the JSON Web Signature
Suppose a medium-scale enterprise in the finance industry needs to expose an API to 
its customers through a mobile application, as illustrated in Figure 15-5. One major 
requirement is that all the API calls should support nonrepudiation.
Chapter 15  patterns and praCtiCes
312
The catch here is the statement, “all the API calls should support nonrepudiation.” 
When you do a business transaction via an API by proving your identity, you shouldn’t 
be able to reject it later or repudiate it. The property that ensures the inability to 
repudiate is known as nonrepudiation. Basically, you do it once, and you own it forever 
(see Chapter 2 for details).
Nonrepudiation should provide proof of the origin and the integrity of data in an 
unforgeable manner, which a third party can verify at any time. Once a transaction is 
initiated, none of its content, including the user identity, date, time, and transaction 
details, should be altered while in transit, in order to maintain transaction integrity and 
to allow for future verifications. Nonrepudiation has to ensure that the transaction is 
unaltered and logged after it’s committed and confirmed.
Logs must be archived and properly secured to prevent unauthorized modifications. 
Whenever there is a repudiation dispute, transaction logs, along with other logs or data, 
can be retrieved to verify the initiator, date, time, transaction history, and so on. The way 
to achieve nonrepudiation is via signature. A key known only to the end user should sign 
each message.
In this case, the financial institution must issue a key pair to each of its customers, 
signed by a certificate authority under its control. It should only store the corresponding 
public certificate, not the private key. The customer can install the private key in his 
or her mobile device and make it available to the mobile application. All API calls 
generated from the mobile application must be signed by the private key of the user and 
encrypted by the public key of the financial institution.
To sign the message, the mobile application can use JSON Web Signature (see 
Chapter 7); and for encryption, it can use JSON Web Encryption (see Chapter 8). When 
using both the signature and encryption on the same payload, the message must be 
signed first, and then the signed payload must be encrypted for legal acceptance.
Figure 15-5. Nonrepudiation with the JSON Web Signature pattern
Chapter 15  patterns and praCtiCes
313
 Chained Access Delegation
Suppose a medium-scale enterprise that sells bottled water has an API (Water API) 
that can be used to update the amount of water consumed by a registered user. Any 
registered user can access the API via any client application. It could be an Android app, 
an iOS app, or even a web application.
The company only provides the API—anyone can develop client applications 
to consume it. All the user data of the Water API are stored in Microsoft Active 
Directory. The client applications shouldn’t be able to access the API directly to find 
out information about users. Only the registered users of the Water API can access it. 
These users should only be able to see their own information. At the same time, for 
each update made by a user, the Water API must update the user’s healthcare record 
maintained at MyHealth.org. The user also has a personal record at MyHealth.org, and 
it too exposes an API (MyHealth API). The Water API has to invoke the MyHealth API to 
update the user record on the user’s behalf.
In summary, a mobile application accesses the Water API on behalf of the end user, 
and then the Water API has to access the MyHealth API on behalf of the end user. The 
Water API and the MyHealth API are in two independent domains. This suggests the 
need for an access delegation protocol.
Figure 15-6. Chained Access Delegation pattern
Chapter 15  patterns and praCtiCes
314
Again, the catch here is the statement, “the Water API must also update the user’s 
healthcare record maintained at MyHealth.org.” This has two solutions. In the first 
solution, the end user must get an access token from MyHealth.org for the Water API 
(the Water API acts as the OAuth client), and then the Water API must store the token 
internally against the user’s name. Whenever the user sends an update through a 
mobile application to the Water API, the Water API first updates its own record and then 
finds the MyHealth access token corresponding to the end user and uses it to access 
the MyHealth API. With this approach, the Water API has the overhead of storing the 
MyHealth API access token, and it should refresh the access token whenever needed.
The second solution is explained in Figure 15-6. It’s built around the OAuth 2.0 
Token Delegation profile (see Chapter 9). The mobile application must carry a valid 
access token to access the Water API on behalf of the end user. In step 3, the Water API 
talks to its own authorization server to validate the access token. Then, in step 4, the 
Water API exchanges the access token it got from the mobile application for a JWT access 
token. The JWT access token is a special access token that carries some meaningful 
data, and the authorization server in the Water API’s domain signs it. The JWT includes 
the end user’s local identifier (corresponding to the Water API) as well as its mapped 
identifier in the MyHealth domain. The end user must permit this action at the Water 
API domain.
In step 6, the Water API accesses the MyHealth API using the JWT access token. The 
MyHealth API validates the JWT access token by talking to its own authorization server. 
It verifies the signature; and, if it’s signed by a trusted entity, the access token is treated 
as valid.
Because the JWT includes the mapped username from the MyHealth domain, 
it can identify the corresponding local user record. However, this raises a security 
concern. If you let users update their profiles in the Water API domain with the mapped 
MyHealth identifier, they can map it to any user identifier, and this leads to a security 
hole. To avoid this, the account mapping step must be secured with OpenID Connect 
authentication. When the user wants to add his or her MyHealth account identifier, the 
Water API domain initiates the OpenID Connect authentication flow and receives the 
corresponding ID token. Then the account mapping is done with the user identifier in 
the ID token.
Chapter 15  patterns and praCtiCes
315
 Trusted Master Access Delegation
Suppose a large-scale enterprise that has a number of APIs. The APIs are hosted in 
different departments, and each department runs its own OAuth 2.0 authorization 
server due to vendor incompatibilities in different deployments. Company employees 
are allowed to access these APIs via web applications while they’re behind the company 
firewall, regardless of the department which they belong to.
Figure 15-7. Trusted Master Access Delegation pattern
All user data are stored in a centralized Active Directory, and all the web applications 
are connected to a centralized OAuth 2.0 authorization server (which also supports 
OpenID Connect) to authenticate users. The web applications need to access back- 
end APIs on behalf of the logged-in user. These APIs may come from different 
departments, each of which has its own authorization server. The company also has a 
centralized OAuth 2.0 authorization server, and an employee having an access token 
from the centralized authorization server must be able to access any API hosted in any 
department.
Chapter 15  patterns and praCtiCes
316
Once again, this is an extended version of using SSO with the Delegated Access 
Control pattern. You have a master OAuth 2.0 authorization server and a set of secondary 
authorization servers. An access token issued from the master authorization server 
should be good enough to access any of the APIs under the control of the secondary 
authorization servers. In other words, the access token returned to the web application, 
as shown in step 3 of Figure 15-7, should be good enough to access any of the APIs.
To make this possible, you need to make the access token self-contained. Ideally, 
you should make the access token a JWT with the iss (issuer) field. In step 4, the web 
application accesses the API using the access token; and in step 5, the API talks to its 
own authorization server to validate the token. The authorization server can look at the 
JWT header and find out whether it issued this token or if a different server issued it. If 
the master authorization server issued it, then the secondary authorization server can 
talk to the master authorization server’s OAuth introspection endpoint to find out more 
about the token. The introspection response specifies whether the token is active and 
identifies the scopes associated with the access token. Using the introspection response, 
the secondary authorization server can build an eXtensible Access Control Markup 
Language (XACML) request and call a XACML policy decision point (PDP). If the XACML 
response is evaluated to permit, then the web application can access the API. Then 
again XACML is a little too complex in defining access control policies, irrespective of 
how powerful it is. You can also check the Open Policy Agent (OPA) project, which has 
become quite popular recently in building fine-grained access control policies.
 Resource Security Token Service (STS) 
with the Delegated Access Control
Suppose a global organization has APIs and API clients are distributed across different 
regions. Each region operates independently from the others. Currently, both clients and 
APIs are nonsecured. You need to secure the APIs without making any changes either at 
the API or the client end.
The solution is based on a simple theory in software engineering: introducing a 
layer of indirection can solve any problem. You need to introduce two interceptors. 
One sits in the client region, and all the nonsecured messages generated from the client 
are intercepted. The other interceptor sits in the API region, and all the API requests 
are intercepted. No other component except this interceptor can access the APIs in a 
nonsecured manner.
Chapter 15  patterns and praCtiCes
317
This restriction can be enforced at the network level. Any request generated from 
outside has no path to the API other than through the API interceptor. Probably you 
deploy both API interceptor and the API in the same physical machine. You can also call 
this component a policy enforcement point (PEP) or API gateway. The PEP validates 
the security of all incoming API requests. The interceptor’s responsibility, sitting in the 
client region, is to add the necessary security parameters to the nonsecured messages 
generated from the client and to send it to the API. In this way, you can secure the API 
without making changes at either the client or the API end.
Still, you have a challenge. How do you secure the API at the API gateway? This is 
a cross-domain scenario, and the obvious choice is to use JWT grant type for OAuth 
2.0. Figure 15-8 explains how the solution is implemented. Nonsecured requests from 
the client application are captured by the interceptor component in step 1. Then it has 
to talk to its own security token service (STS). In step 2, the interceptor uses a default 
user account to access the STS using OAuth 2.0 client credentials grant type. The STS 
authenticates the request and issues a self-contained access token (a JWT), having the 
STS in the API region as the audience of the token.
In step 3, the client-side interceptor authenticates to the STS at the API region 
with the JWT token and gets a new JWT token, following OAuth 2.0 Token Delegation 
profile, which we discussed in Chapter 9. The audience of the new JWT is the OAuth 2.0 
Figure 15-8. Resource STS with the Delegated Access Control pattern
Chapter 15  patterns and praCtiCes
318
authorization server running in the API region. Before issuing the new JWT, the STS at the 
API region must validate its signature and check whether a trusted entity has signed it.
To make this scenario happen, the STS in the API region must trust the STS on the 
client side. The OAuth 2.0 authorization server only trusts its own STS. That is why step 
4 is required. Step 4 initiates the JWT grant type for OAuth 2.0, and the client interceptor 
exchanges the JWT issued by the STS of the API region for an access token. Then it uses 
that access token to access the API in step 5.
The PEP in the API region intercepts the request and calls the authorization server to 
validate the access token. If the token is valid, the PEP lets the request hit the API (step 7).
 Delegated Access Control with No Credentials  
over the Wire
Suppose a company wants to expose an API to its employees. However, user 
credentials must never go over the wire. This is a straightforward problem with an 
equally straightforward solution. Both OAuth 2.0 bearer tokens and HTTP Basic 
authentication take user credentials over the wire. Even though both these approaches 
use TLS for protection, still some companies worry about passing user credentials over 
communication channels—or in other words passing bearer tokens over the wire.
You have few options: use either HTTP Digest authentication or OAuth 2.0 MAC 
tokens (Appendix G). Using OAuth 2.0 MAC tokens is the better approach because 
the access token is generated for each API, and the user can also revoke the token if 
needed without changing the password. However, the OAuth 2.0 MAC token profile is 
not matured yet. The other approach is to use OAuth 2.0 with Token Binding, which we 
discussed in Chapter 11. Even though we use bearer tokens there, with Token Binding, 
we bind the token to the underneath TLS channel—so no one can export the token and 
use it somewhere else.
There are few more draft proposals discussed under the IETF OAuth working 
group to address this concern. The OAuth 2.0 Mutual-TLS Client Authentication and 
Certificate-Bound Access Tokens is one of them, available at https://tools.ietf.org/
html/draft-ietf-oauth-mtls-17.
Chapter 15  patterns and praCtiCes
319
 Summary
• 
API security is an ever-evolving subject.
• 
More and more standards and specifications are popping up, and 
most of them are built around the core OAuth 2.0 specification.
• 
Security around JSON is another evolving area, and the IETF JOSE 
working group is currently working on it.
• 
It’s highly recommended that if you wish to continue beyond this 
book, you should keep an eye on the IETF OAuth working group, the 
IETF JOSE working group, the OpenID Foundation, and the Kantara 
Initiative.
Chapter 15  patterns and praCtiCes
321
© Prabath Siriwardena 2020 
P. Siriwardena, Advanced API Security, https://doi.org/10.1007/978-1-4842-2050-4_16
APPENDIX A
The Evolution of Identity 
Delegation
Identity delegation plays a key role in securing APIs. Most of the resources on the Web 
today are exposed over APIs. The Facebook API exposes your Facebook wall, the Twitter 
API exposes your Twitter feed, Flickr API exposes your Flickr photos, Google Calendar 
API exposes your Google Calendar, and so on. You could be the owner of a certain 
resource (Facebook wall, Twitter feed, etc.) but not the direct consumer of an API. There 
may be a third party who wants to access an API on your behalf. For example, a Facebook 
app may want to import your Flickr photos on behalf of you. Sharing credentials with 
a third party who wants to access a resource you own on your behalf is an antipattern. 
Most web-based applications and APIs developed prior to 2006 utilized credential 
sharing to facilitate identity delegation. Post 2006, many vendors started developing 
their own proprietary ways to address this concern without credential sharing. Yahoo! 
BBAuth, Google AuthSub, and Flickr Authentication are some of the implementations 
that became popular.
A typical identity delegation model has three main roles: delegator, delegate, and 
service provider. The delegator owns the resource and is also known as the resource 
owner. The delegate wants to access a service on behalf of the delegator. The delegator 
delegates a limited set of privileges to the delegate to access the service. The service 
provider hosts the protected service and validates the legitimacy of the delegate. The 
service provider is also known as the resource server.
322
 Direct Delegation vs. Brokered Delegation
Let’s take a step back and look at a real-world example (see Figure A-1). Flickr is a 
popular cloud-based service for storing and sharing photos. Photos stored in Flickr are 
the resources, and Flickr is the resource server or the service provider. Say you have a 
Flickr account: you’re the resource owner (or the delegator) of the photos under your 
account. You also have a Snapfish account. Snapfish is a web-based photo-sharing and 
photo-printing service that is owned by Hewlett-Packard. How can you print your Flickr 
photos from Snapfish? To do so, Snapfish has to first import those photos from Flickr and 
should have the privilege to do so, which should be delegated to Snapfish by you. You’re 
the delegator, and Snapfish is the delegate. Other than the privilege to import photos, 
Snapfish won’t be able to do any of the following with your Flickr photos:
• 
Access your Flickr account (including private content)
• 
Upload, edit, and replace photos and videos in the account