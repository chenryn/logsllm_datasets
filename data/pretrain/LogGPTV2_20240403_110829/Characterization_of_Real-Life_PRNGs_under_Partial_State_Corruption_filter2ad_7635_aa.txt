title:Characterization of Real-Life PRNGs under Partial State Corruption
author:Mario Cornejo and
Sylvain Ruhault
Characterization of Real-Life PRNGs under Partial State
Corruption
Mario Cornejo
École Normale Supérieure & INRIA, France
PI:EMAIL
Sylvain Ruhault
École Normale Supérieure & Oppida, France
PI:EMAIL
ABSTRACT
Pseudo-random number generators (PRNGs) are widely used
as a randomness source in cryptographic applications. It is
essential for their security that the internal state, in which
the entropy is accumulated, is kept secret. However, this
assumption is unrealistic for PRNGs that are implemented
in software, as the internal state can be partially corrupted
through memory corruption bugs such as buﬀer overﬂows
or through faults attacks. The recent Heartbleed bug gives
us a concrete illustration of this vulnerability. In this work
we study several widely used PRNGs from diﬀerent popu-
lar providers, including OpenSSL, OpenJDK, Android, IBM
and Bouncy Castle and we characterize how they handle
their internal states. We formalize a framework based on
the most recent and strongest security model called robust-
ness of PRNGs to analyze these PRNGs and their imple-
mentations. With this framework we capture the notion of
how much of the internal state must be corrupted in order
to generate a predictable output. Using this framework, we
determine the number of bits of the internal state that an
attacker needs to corrupt in order to produce a predictable
output. We also show that two of the PRNGs do not re-
quire state compromise to generate a non-random output.
To the best of our knowledge, we present the ﬁrst thorough
characterization of an IBM implementation of a PRNG.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—
Cryptographic controls; G.3 [Mathematics of Comput-
ing]: Probability and Statistics—Random number genera-
tion
Keywords
Randomness; Security models; OpenSSL; Android; Java
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA. 
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11. . . $15.00
http://dx.doi.org/10.1145/2660267.2660377.
1.
INTRODUCTION
In cryptography, randomness plays a important role in
multiple applications.
It is required in fundamental tasks
such as key generation, masking and hiding values, nonces
and initialization vectors generation, etc. The security of
these cryptographic algorithms and protocols relies on a
source of unbiased and uniform distributed random bits.
The unpredictability of these bits is in practice achieved us-
ing a Pseudo-Random Number Generator (PRNG) which is
an algorithm that accumulates entropy from the environ-
ment and produces (pseudo-)random strings indistinguish-
able from the uniform distribution to a computationally-
bounded adversary. PRNGs designers assume that the in-
ternal state S remains secret to the adversary. However, for
software implementations this may be unrealistic as the in-
ternal state can be partially compromised through memory
corruption attacks such as buﬀer overﬂows or fault attacks.
Diﬀerent memory corruption attacks are presented by Er-
lingsson et al. in [20] and by van der Veen et al. in [31] and
faults attacks against cryptographic schemes are presented
by Biham and Shamir in [12] and by Boneh et al. in [13].
Recently, the Heartbleed bug [9] aﬀected the OpenSSL cryp-
tographic library. This bug allows an attacker to get the con-
tent of the memory of the OpenSSL process run by a server
(or a client). Although the attacker can control the size of
the compromised memory, she can not control its location,
therefore she can get total or partial access to sensitive in-
formation as the internal state of the PRNG.
Currently there are numerous implementations from dif-
ferent providers, and most of them rely on internal directives
and parameters that are poorly documented or even undoc-
umented.
In most implementations, a PRNG contains a
dedicated internal state S which is refreshed periodically
with the entropy I collected from its environment (such as
network input/output, keyboard presses, processor clock cy-
cles) and secondly used to compute pseudo-random strings.
The randomness collection task is harder and takes much
more time than the output generation task; this is the rea-
son why PRNGs typically maintains an internal state, which
is the most critical part of the PRNG and therefore needs to
be kept secure during its update. We give a formal deﬁnition
of a PRNG in Section 2.
Using recent theoretical results in the ﬁeld, we provide in
this work a new security model and we present it as a frame-
work in Section 3. We use this framework for the analysis of
widely used PRNGs and in Section 4 we identify new poten-
tial vulnerabilities due to the way they handle their internal
state during its update.
1004Only few concrete implementations have been analyzed
since the ﬁrst work of Gutmann in 1998 [21] and the guide-
lines for developing PRNGs given by Kelsey et al. in [24].
Recently Michaelis et al. in [26] have described and analyzed
several Java implementations; they have also identiﬁed some
weaknesses. There has been little research by theoretical
cryptographers in the area of PRNGs.
In one of the ﬁrst
works in this area, Desai et al. [15] modeled a PRNG as a
pair of algorithms: the Seed Generation algorithm and the
Output Generation algorithm. This model assumes the ex-
istence of an entropy pool, diﬀerent from the internal state,
in which randomness is accumulated, that is used to refresh
the internal state of the PRNG. An elegant and remark-
able work by Barak and Halevi [11] modeled a PRNG as a
pair of algorithms (refresh, next) and deﬁned a new security
property called robustness based on the design guidelines of
Kelsey et al.. This property assesses the behavior of a PRNG
after the compromise of its internal state, but fails to cap-
ture the small and gradual entropy accumulation present in
most real-life implementations. A follow-up paper by Dodis
et al. [16] identiﬁed the problem of this slow (and potentially
malicious) entropy accumulation and reﬁned the robustness
property of a PRNG deﬁned by Barak and Halevi. This new
property, still named robustness, captures the idea of how
the entropy of the input data should be accumulated in the
internal state after a state compromise. To our knowledge,
this last security model is the strongest one as it considers
the most powerful attacker against a PRNG. A recent work
by Dodis et al. in [17] extends the robustness model to ad-
dress the premature next attack where the internal state has
insuﬃcient entropy and an output is generated.
Our work complements the security model of [16] in a
diﬀerent way than [17] does. We propose a new attacker
proﬁle that captures real-life situations where a partial in-
ternal state corruption is possible. We also show an analysis
of real-life PRNGs using this security model and we demon-
strate how it can help to identify new vulnerabilities.
In
particular, we show that a full internal state corruption is
not necessary to compromise a PRNG, instead only a partial
one may be suﬃcient. We characterize how a PRNG can be
attacked in order to produce a predictable and we identify
how many bits of the internal state are required to mount
an attack against the PRNG.
Other Randomness Weaknesses. Several recent attacks
occurred due to an insuﬃcient understanding of PRNG im-
plementations. One striking example is the failure in the
Debian Linux distribution, where commented code in the
OpenSSL PRNG forced the only source of entropy to be
the PID. An analysis of Linux PRNGs dev/random and de-
v/urandom was done in 2006 by Gutterman et al. in [22],
completed by Dodis et al. in [16]. Gutterman et al. pre-
sented an attack for which a ﬁx has been published. Dodis
et al. presented attacks against these PRNG related to their
internal entropy estimator. Heninger et al. in [23] presented
an analysis of the behavior of Linux PRNG that explains
the generation of low entropy keys when these keys are gen-
erated at boot time. The Windows PRNG CryptGenRandom
was analyzed in 2006 by Dorrendorf et al. in [18]; the authors
showed an attack on the forward security of the PRNG im-
plemented in Windows 2000, for which a ﬁx has been pub-
lished. Argyros and Kiayias [10] showed practical attacks
on web applications exploiting randomness vulnerabilities
in PHP applications. More recently, a ﬂaw in the Android
Table 1: Summary of our Results
State Size
Instance
PRNG
OpenSSL
Android
OpenJDK
Bouncycastle
IBM
SHA1PRNG
SHA1PRNG
NativePRNG
SHA1PRNG
SHA1PRNG
8576
3136
352
5472
448
680
λ(∗)
320
0
32
1056
0
32
(*) λ denotes the size of the part of the internal state
an attacker needs to corrupt to attack the PRNG.
PRNG, identiﬁed by Kim et al. in [25], has been actively
exploited against Android-based Bitcoin wallets [27]. This
illustrates the need for precise evaluation of PRNG imple-
mentations based on clear security requirements.
Our Contributions. From a theoretical viewpoint, we
formally extend the security model of [16], to capture the
behavior of a PRNG against an attacker that has partial
access to its internal state. From a practical side, we char-
acterize and give a new security analysis of PRNG imple-
mentations from widely used providers in real-life appli-
cations: OpenSSL, OpenJDK, Android, Bouncycastle and
IBM. To our knowledge, while intensively used in practice,
these PRNGs have not been evaluated w.r.t. recent security
models. Our analysis reveals new vulnerabilities of these
PRNG due to the implementation of their internal state in
several ﬁelds that are not updated securely during PRNG
operations. Our results are summarized in Table 1. In this
table, we give the size in bits of the internal state of the
PRNG and the number of bits (named λ) that an attacker
needs to compromise in order to mount an attack against
the PRNG.
2. PRELIMINARIES
In this section we describe our notation and deﬁnitions
used, adapted from the work of Dodis et al., in [16].
Notation. We denote with [S||I] the concatenation of the
bit string S with the bit string I and we denote with |S|
the length (in bits) of the bit string S. We denote with
S[n] the nth byte of S and S[n,··· , m] (or [S]m
n ) the ex-
tracted bytes of S from the nth to the mth.
Instructions
and code references are denoted with the verbatim style as
in SecureRandom. When X is a discrete distribution, or a
random variable following this distribution, we denote with
x $← X that x is sampled according to X. We denote with
H∞(X) the min-entropy of a distribution X.
Pseudo-Random Number Generator. We recall the
deﬁnition of a PRNG given in [16].
It uses the following
notations: a state S ∈ {0, 1}n, an input I ∈ {0, 1}p, an
output R ∈ {0, 1}(cid:96).
Deﬁnition 1 (PRNG). A PRNG is a triple of algorithms
G = (setup, refresh, next) where:
• setup: A probabilistic algorithm that outputs some pub-
lic parameters seed.
• refresh: A deterministic algorithm that, given seed,
a state S and an input I, outputs a new state S(cid:48) =
refresh(S, I, seed) ∈ {0, 1}n.
• next: A deterministic algorithm that, given seed and
a state S, outputs a pair (S(cid:48), R) = next(S, seed) where
S(cid:48) is the new state and R is the output.
1005The parameter seed is public and common to all the above
algorithms; for clarity, we remove it and we write S(cid:48) =
refresh(S, I) instead of refresh(S, I; seed) and (S(cid:48), R) = next(S)
instead of next(S; seed).
Distribution Sampler As in [16], we divide the adversary
into two parts, the ﬁrst one is the adversary A whose goal is
to distinguish the outputs of the PRNG from random and
the second one is the distribution sampler D which is used
by A to produce (potentially biased) inputs.
Deﬁnition 2 (Distribution Sampler). A distribution sam-
pler D is a stateful and probabilistic algorithm which, given
the current state σ, outputs a tuple (σ(cid:48), I, γ, z) where:
• σ(cid:48) is the new state for D;
• I ∈ {0, 1}p will be the next input for the refresh algo-
• γ is some entropy estimation of I;
• z is the possible leakage about I given to A.
rithm;
We denote q the upper bound on the number of executions of
D. The distribution sampler D is provided by the adversary
A and its goal is to generate the inputs that will be used by
G to improve the quality of its entropy with the refresh al-
gorithm. The adversary has to provide the deﬁnition of the
distribution sampler before its knowledge of the seed. The
distribution sampler models the potentially adversarial en-
vironment of G, with biased inputs. A distribution sampler
is called legitimate if the min-entropy of every input Ij is not
smaller than the entropy estimate γj, even given all the addi-
tional information: H∞(Ij | I1, . . . , Ij−1, Ij+1, . . . , Iq, z1, . . . ,
zq, γ1, . . . , γq) (cid:62) γj, for all j ∈ {1, . . . , q} where (σi, Ii, γi, zi)
= D(σi−1) for σ0 = 0 and i ∈ {1, . . . , q}.
3. PRNG SECURITY
In this section, we present the security model that we use
to analyze PRNG implementations. First we analyze ex-
isting security models and then we identify implementation
details that should be taken into account. Finally, we illus-
trate our analysis on a concrete example and we give the
formalism.
3.1 From Theory to Practice
From Security Models to Implementations. We dis-
cuss brieﬂy some interesting common points in the security
models presented in [15, 11, 16] as well as their potential
use to assess PRNG implementations. Three security mod-
els consider an adversarial environment for the PRNG. The
security model of [15] does not take into account an attack
in which the PRNG is refreshed with adversarial inputs,
whereas this situation is considered in [11] and [16]. In [15],
the internal state of the PRNG is composed of two parts,
named key and initial state; the generation algorithm takes
as input both of them and updates the initial state.