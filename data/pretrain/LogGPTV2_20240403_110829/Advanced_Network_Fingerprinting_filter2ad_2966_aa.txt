title:Advanced Network Fingerprinting
author:Humberto J. Abdelnur and
Radu State and
Olivier Festor
Advanced Network Fingerprinting
Humberto J. Abdelnur, Radu State, and Olivier Festor
Centre de Recherche INRIA Nancy - Grand Est
615, rue du jardin botanique
{Humberto.Abdelnur,Radu.State,Olivier.Festor}@loria.fr
Villers-les-Nancy, France
http://madynes.loria.fr
Abstract. Security assessment tasks and intrusion detection systems do
rely on automated ﬁngerprinting of devices and services. Most current
ﬁngerprinting approaches use a signature matching scheme, where a set
of signatures are compared with traﬃc issued by an unknown entity. The
entity is identiﬁed by ﬁnding the closest match with the stored signatures.
These ﬁngerprinting signatures are found mostly manually, requiring a
laborious activity and needing advanced domain speciﬁc expertise. In
this paper we describe a novel approach to automate this process and
build ﬂexible and eﬃcient ﬁngerprinting systems able to identify the
source entity of messages in the network. We follow a passive approach
without need to interact with the tested device. Application level traf-
ﬁc is captured passively and inherent structural features are used for
the classiﬁcation process. We describe and assess a new technique for
the automated extraction of protocol ﬁngerprints based on arborescent
features extracted from the underlying grammar. We have successfully
applied our technique to the Session Initiation Protocol (SIP) used in
Voice over IP signalling.
Keywords: Passive Fingerprinting, Feature extraction, Structural syn-
tax inference.
1 Introduction
Many security operations rely on the precise identiﬁcation of a remote device
or a subset of it (e.g. network protocol stacks, services). In security assessment
tasks, this ﬁngerprinting step is essential for evaluating the security of a remote
and unknown system; especially network intrusion detection systems might use
this knowledge to detect rogue systems and stealth intruders. Another important
applicability resides in blackbox devices/application testing for potential copy-
right infringements. In the latter case, when no access to source code is provided,
the only hints that might detect a copyright infringement can be obtained by
observing the network level traces and determine if a given copyright protected
software/source code is used unlawfully.
The work described in this paper was motivated by one major challenge that
we had to face when building a Voice over IP (VoIP) speciﬁc intrusion detection
R. Lippmann, E. Kirda, and A. Trachtenberg (Eds.): RAID 2008, LNCS 5230, pp. 372–389, 2008.
c(cid:2) Springer-Verlag Berlin Heidelberg 2008
Advanced Network Fingerprinting
373
system. We had to ﬁngerprint VoIP devices and stacks in order to detect the
presence of a rogue system on the network. Typically, only some vendor spe-
ciﬁc devices should be able to connect, while others and potentially malicious
intended systems had to be detected and blocked. We decided that an auto-
mated system, capable to self-tune and self-deploy was the only viable solution
on the long run. Therefore, we considered that the ideal system has to be able
to process captured and labeled network traﬃc and detect the structural fea-
tures that serve as potential diﬀerentiators. When searching for such potential
features, there are some natural candidates: the type of individual ﬁelds and
their length or the order in which they appear. For instance, the presence of
login headers, the quantities of spaces after commas or the order presented in
the handshake of capabilities. Most existing systems use such features, but in-
dividual signatures are built manually requiring a tedious and time consuming
process.
Our approach consists in an automated solution for this task, assuming a
known syntax speciﬁcation of the protocol data units. We have considered only
the signalling traﬃc - all devices were using Session Initiation Protocol [1] (SIP)
- and our key contribution is to diﬀerentiate stack implementations by looking
at some speciﬁc patterns in how the message processing code has been designed
and developed. This is done in two main steps. In the ﬁrst step, we extract fea-
tures that can serve to diﬀerentiate among several stack implementations. These
features are used in a second phase in order to implement a decisional process.
This approach and the supporting algorithms are presented in this paper.
This paper is organized as follow. Section 2 illustrates the overall architecture
and operational framework of our ﬁngerprinting system. Section 3 shows how
structural inference, comparison and identiﬁcation of diﬀerences can be done
based on the underlying grammar of a given speciﬁed protocol. Section 4 intro-
duces the training, calibration and classiﬁcation process. We provide an overview
of experimental results in Sect.5 using the signalling protocol (SIP) as an appli-
cation case. Section 6 describes the related work in the area of ﬁngerprinting as
well as the more general work on structural similarity. Finally, Sect.7 points out
future works and concludes this paper.
2 Structural Protocol Fingerprinting
Most known application level and network protocols use a syntax speciﬁcation
based on formal grammars. The essential issue is that each individual message
can be represented by a tree like structure. We have observed that stack imple-
menters can be tracked by some speciﬁc subtrees and/or collection of subtrees
appearing in the parse trees. The key idea is that structural diﬀerences between
two devices can be detected by comparing the underlying parse trees gener-
ated for several messages. A structural signature is given by features that are
extracted from these tree structures. Such distinctive features are called ﬁnger-
prints. We will address in the following the automated identiﬁcation of them.
374
H.J. Abdelnur, R. State, and O. Festor
If we focus for the moment one individual productions (in a grammar rule),
the types of signatures might be given by:
– Diﬀerent contents for one ﬁeld. This is in fact a sequence of characters which
can determinate a signature. (e.g. a prompt or an initialization message).
– Diﬀerent lengths for one ﬁeld. The grammar allows the production of a
repetition of items (e.g. quantity of spaces after a symbol, capabilities sup-
ported). In this case, the length of the ﬁeld is a good signature candidate.
– Diﬀerent orders in one ﬁeld. This is possible, when no explicit order is
speciﬁed in a set of items. A typical case is how capabilities are advertised
in current protocols.
We propose a learning method to automatically identify distinctive structural
signatures. This is done by analyzing and comparing captured messages traces
from the diﬀerent devices. The overview of the learning and classiﬁcation process
is illustrated in Fig.1.
Fig. 1. Fingerprinting training and classiﬁcation
The upper boxes in Fig.1 constitute the training period of the system. The
output is a set of signatures for each device presented in the training set. The
lowest box represents the ﬁngerprinting process. The training is divided in two
phases:
Advanced Network Fingerprinting
375
Phase 1 (Device Invariant Features). In this phase, the system automat-
ically classiﬁes each ﬁeld in the grammar. This classiﬁcation is needed to
identify which ﬁelds may change between messages coming from the same
device.
Phase 2 (Inter Device Features Signiﬁcance) identiﬁes among the Invariant
ﬁelds of each implementation, those having diﬀerent values for at least two
group of devices. These ﬁelds will constitute part of the signatures set.
When one message has to be classiﬁed, the values of each invariant ﬁeld are
extracted and compared to the signature values learned in the training phase.
3 Structural Inference
3.1 Formal Grammars and Protocol Fingerprinting
The key assumption made in our approach is that an Augmented BackusNaur
Form (ABNF) grammar [2] speciﬁcation is a priori known for a given protocol.
Such a speciﬁcation is made of some basic elements as shown in Fig.2.
Fig. 2. Basic elements of a grammar
– A Terminal can represent a ﬁxed string or a character to be chosen from a
range of legitimate characters.
– A Non-Terminal is reduced using some rules to either a Terminal or a
Non-Terminal.
– A Choice deﬁnes an arbitrary selection among several items.
– A Sequence involves a ﬁxed number of items, where the order is speciﬁed.
– A Repetition involves a sequence of one item/group of items, where some
additional constraints might be speciﬁed.
A given message is parsed according to the ﬁelds deﬁned in the grammar. Each
element of the grammar is placed in an n-ary tree which obeys the following rules:
376
H.J. Abdelnur, R. State, and O. Festor
– A Terminal becomes a leaf node with a name associated (i.e. the termi-
nal that it represents) which is associated to the encountered value in the
message.
– A Non-Terminal is an internal node associated to a name (i.e. the non-
terminal rule) and it has a unique child which can be any of the types deﬁned
here (e.g. Terminal, non-Terminal, Sequence or Repetition).
– A Sequence is an internal node that has a ﬁxed number of children. This
number is in-line with the rules of the syntax speciﬁcation.
– A Repetition is also an internal node, but having a number of children that
may vary based on the number of items which appear in the message.
– A Choice does not create any node in the tree. However, it just marks the
node that has been elected from a choice item.
It is important to note that even if sequences and repetitions do not have a
deﬁned name in the grammar rules, an implicit name is assigned to them that
uniquely distinguishes each instance of these items at the current rule.
Figure 3 shows a Toy ABNF grammar deﬁned in (a), messages from diﬀer-
ent implementation compliant with the grammar in (b/c) and (d) the inferred
structure representing one of the messages in (d).
With respect to the usage, ﬁelds can be classiﬁed in three categories:
– Cosmetics Fields: these ﬁelds are mandatory and do not really provide a
value added interest for ﬁngerprinting purposes. The associated values do
not change in diﬀerent implementations.
– Static Fields: are the ﬁelds which values never change in a same implemen-
tation. These values do however change between diﬀerent implementations.
Obviously, these are the type of ﬁelds which may represent a signature for
one implementation.
– Dynamic Fields: these ﬁelds are the opposite of static ﬁelds and do change
their values in relation to semantic aspects of the message even in a single
implementation.
An additional sub-classiﬁcation can be deﬁned for Dynamic and Static ﬁelds:
– Value Type relates to the String reduction of the node (i.e. the text infor-
mation of that node),
– Choice Type relates to the selected choice from the grammar,
– Length Type corresponds to the number of items in a Repetition reduction,
– Order Type corresponds to the order in which items of a Repetition re-
duction appear.
Even if one implementation may generate diﬀerent kind of values for the same
ﬁeld, such values could be related by a function and then serve as a feature.
Therefore, a Function Type can be also deﬁned to be used to compute the
value from a node of the tree and return an output useful for the ﬁngerprinting.
Essentially, this type is used for manually tuning the training process.
Advanced Network Fingerprinting
377
Fig. 3. Parsed Structure Grammar
3.2 Node Signatures and Resemblance
Guidelines for designing a set of tree signatures (for a tree or a sub-tree) should
follow some general common sense principles like:
– As more items are shared between trees, the more similar their signatures
must be.
– Nodes that have diﬀerent tags or ancestors must be considered diﬀerent.
– In cases where the parent node is a Sequence, the location order in the
Sequence should be part of the tree signature.
– If the parent node is a repetition, the location order should not be part of the
tree signature, order will be captured later on in the ﬁngerprinting features.
The closest known approach is published by D. Buttler in [3]. This method
starts by encoding the tree in a set. Each element in the set represents a partial
path from the root to any of the nodes in the tree. A resemblance method
deﬁned by A. Broder [4] uses the elements of the set as tokens. This resemblance
378
H.J. Abdelnur, R. State, and O. Festor
is based on shingles, where a shingle is a contiguous sequence of tokens from the
document. Between documents Di and Dj the resemblance is deﬁned as:
r(Di, Dj) =
(1)
|S(Di, w)
|S(Di, w)
(cid:2)
(cid:3)
S(Dj, w)|
S(Dj, w)|
where S(Di, w) creates the shingles of length w for the document Di.
Deﬁnition 1. The Node Signature function is deﬁned to be a Multi-Set of all
partial paths belonging to the sub-branch of the node.
The partial paths start from the current node rather than from the root of the
tree, but still goes through all the nodes of the subtree which has the current
element as root like it was in the original approach. However, partial paths
obtained from ﬁelds classiﬁed as Cosmetics are excluded from this Multi-Set.
The structure used is a Multi-Set rather than a Set in order to store the quantity
of occurrences for speciﬁc nodes in the sub-branch. For instance, the number of
spaces after a speciﬁc ﬁeld can determinate a signature in an implementation.
Siblings nodes in a Sequence items are ﬁxed and representative. Sibling nodes
in a Repetition can be made representative creating the partial paths of the
Multi-Set and using the respective position of a child.
Table 1 shows the Node Signature obtained from the node Header at the tree
of Fig. 3 (d).
Deﬁnition 2. The Ressemblance function used to measure the degree of sim-
ilarity between two nodes is based on the (1). The S(Ni, w) function applies the
Node Signature function over the node Ni.
Using w = 1 allows to compare the number of items these nodes have in common
though ignoring their position for a repetition.
3.3 Structural Diﬀerence Identiﬁcation
Algorithm 1 is used to identify diﬀerences between two nodes which share the
same ancestor path in the two trees,
where the functions Tag, Value, Type return the name, value and respec-
tively the type of the current node. Note that T ag(nodea) = T ag(nodeb) ⇒
T ype(nodea) = T ype(nodeb).
The function Report Diﬀerence takes the type of diﬀerence to report and
the corresponding two nodes. Each time the function is called, it creates one
structure that stores the type of diﬀerence, the partial path from the root of the
tree to the current nodes (which is the same for both nodes) and a corresponding
value. For diﬀerences of type ’Value’ it will store the two terminal values, for
’Choice’ the two diﬀerent Tags names, for ’Length’ the two lengths and for
’Order’ the matches.
The function Identify Children Matches identiﬁes a match between chil-
dren of diﬀerent repetition nodes. The similitude between each child from nodea
and nodeb (with n and m children respectively) is represented as a matrix, M,
of size n x m where:
Advanced Network Fingerprinting
379
Table 1. Partial paths obtained from Fig.3 (d)
Partial Paths
Header.0.’Reply’
Header.0.’Reply’.’Reply’
Header.1.?
Header.1.?.SP
Header.1.?.SP.%x20
Header.1.?.SP.%x20.’ ’
Header.2.Method.?
Header.2.Method.?.ALPHA.
Header.2.Method.?.ALPHA.%x41-5A
Header.2.Method.?.ALPHA.%x41-5A.’U’
Header.2.Method.?.ALPHA.%x41-5A.’S’
Header.2.Method.?.ALPHA.%x41-5A.’E’
Header.2.Method.?.ALPHA.%x41-5A.’R’
Occurrences
1
1
2
2
2
2
4
4
4
1
1
1
1
(strikethrough) Strikethrough paths are the ones considered as cosmetics.
(?) Quotes deﬁne that the current path may be any of the repetition items.
Algorithm 1. Node diﬀerences Location
procedure NODEDIFF(nodea, nodeb)
if T ag(nodea) = T ag(nodeb) then
if T ype(nodea) = T ERM IN AL then
if V alue(nodea) ! = V alue(nodeb) then
Report Dif f erence((cid:2)
V alue
, nodea, nodeb)
(cid:2)
end if
else if T ype(nodea) = N ON − T ERM IN AL then
N ODEDIF F (nodea.child0, nodeb.child0))
else if T ype(nodea) = SEQU EN CE then
for i = 1..#nodea do
N ODEDIF F (nodea.childi, nodeb.childi)
end for