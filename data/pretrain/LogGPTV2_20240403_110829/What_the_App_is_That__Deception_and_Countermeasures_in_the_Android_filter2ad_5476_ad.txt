on the idea of a trusted indicator on the device that reliably and
continuously informs a user about the application with which she is
interacting. We will discuss the details of this solution in Section VI.
B. Results
We ran our tool on the following four sets of apps:
1) A set of 500 apps downloaded randomly from the Google Play
Store (later called benign1).
2) A set of 500 apps downloaded from the “top free” category on
the Google Play Store (later called benign2).
3) A set of 20 apps described as app-lockers in the Google Play
Store (later called app-locker).
4) A set of 1,260 apps from the Android Malware Genome project
[22] (later called malicious).
The top part of Table IV shows the usage of five key permissions
that apps would need to request to carry out various GUI confusion
attacks, for each of the four different data sets we used to evaluate
our tool. From this data, it is clear that three out of five permissions
are frequently used by benign applications. As a result, solely
checking for permissions that are needed to launch attacks cannot
serve as the basis for detection, since they are too common.
The bottom part of Table IV details how frequently apps call
APIs associated with the different techniques. Again, just looking
at API calls is not enough for detection. Consider a simplistic
(grep-style) approach that detects an app as suspicious when it
uses, at least once, an API to get information about the state of the
device and one to perform an attack vector. This would result in
an unacceptable number of incorrect detections. Specifically, this
approach would result in classifying as suspicious 33 apps in the
benign1 (6.6%) set and 95 in the benign2 set (19.0%).
On the benign1 set, our tool flagged two apps as suspicious.
Manual investigation revealed that these applications monitor
the user’s Activity and, under specific conditions, block normal
user interaction with the device. Even though these samples do
6A similar concept has been explored in Whyper [21], a tool to examine whether
app descriptions indicate the reason why specific permissions are required.
938938939
Fig. 3: A screenshot acquired while the sample of the svpeng
malware family, detected by our tool, is attacking the user. The
Activity shown in the picture (asking, in Russian, to insert credit
card information) is spawned by the malware while the user is on
the official Google Play Store. Data entered in this Activity is then
sent to a malicious server.
not perform a GUI confusion attack (since they do not mimic
the appearance of another application), they are both app-lockers.
Hence, we expect our tool to report them.
On the benign2 set, the tool detected 26 applications. When
reviewing these apps, we found that two of them are app-lockers, ten
of them are chat or VOIP apps, which display custom notifications
using a separate mechanism than the status bar (such as stealing
focus on an incoming phone call), four are games with disruptive ads,
and four are “performance enhancers” (which monitor and kill the
background running apps and keep a persistent icon on the screen).
We also detected two anti-virus programs (which jump on top when
a malicious app is detected) and one (annoying) keyboard app that
jumps on top to offer a paid upgrade. We also had three false pos-
itives; two apps that could be used to take pictures, and one browser.
These three apps satisfy the three conditions used to flag an app as
potentially-malicious, but they do not interfere with the device’s GUI.
The difference between results on sets benign2 and benign1 is
due to the fact that popular apps are significantly bigger and more
complex than the randomly-selected ones. In general, they do more
and call a larger variety of APIs. Nonetheless, the total number of
apps that would need to be manually analyzed is small, especially
considering the set of random apps. Hence, an app store could use
our system to perform a pre-filtering to check for apps that can
potentially launch GUI confusion attacks, and then use manual
analysis to confirm (or refute) this hypothesis.
To evaluate the detection capabilities (and false negative rate) of
our tool, we randomly downloaded from the Google Play Store a set
of 20 apps (called app-locker), described as app-lockers on the store.
Since, as previously explained, this category of applications exhibits
a behavior that is very similar to the attacks described in Section III,
we expected our tool to detect them all. Our tool detected 18
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:15 UTC from IEEE Xplore.  Restrictions apply. 
TABLE IV: Number of apps requesting permissions used by GUI confusion attacks and number of apps using each detected technique
in the analyzed data sets
permission name
GET TASKS
READ LOGS
KILL BACKGROUND PROCESSES
SYSTEM ALERT WINDOW
REORDER TASKS
benign1 set
6.4%
32
1.8%
9
3
0.6%
0.2%
1
0
0.0%
benign2 set
80
35
13
34
4
16.0% 217
7.0% 240
2.6%
13
3
6.8%
0.8%
2
malicious set
benign2 set
malicious set
technique
startActivity API
killBackgroundProcesses API
fullscreen
moveToFront API
draw over using addView API
custom toast message
getRunningTasks API
reading from the system log
reading from proc file system
benign1 set
53
1
0
0
0
0
23
8
3
10.6% 135
8
0.2%
22
0.0%
0
0.0%
9
0.0%
0.0%
1
68
4.6%
18
1.6%
0.6%
26
27.0% 751
6
1.6%
0
4.4%
1
0.0%
0
1.8%
0.2%
0
13.6% 147
28
3.6%
5.2%
43
app-locker set
95.0%
65.0%
25.0%
50.0%
10.0%
17.2% 19
19.1% 13
1.0%
5
0.2% 10
0.2%
2
app-locker set
100.0%
20.0%
5.0%
5.0%
15.0%
5.0%
95.0%
40.0%
20.0%
59.6% 20
4
0.5%
1
0.0%
1
0.1%
3
0.0%
0.0%
1
11.7% 19
8
2.2%
3.4%
4
TABLE V: Detection of potential GUI confusion attacks.
Dataset
benign1 set
benign2 set
Total
500
500
Detected
2
26
Correctly Detected
2
23
app-locker set
20
malicious set
1,260
18
25
18
21
Notes
The detected apps are both app-lockers.
10 chat/voip app (jumping on top on an incoming phone call/message), 4 games (with disruptive
ads), 4 enhancers (background apps monitoring and killing, persistent on-screen icon over any app),
2 anti-virus programs (jumping on top when a malicious app is detected), 2 app-lockers, and 1
keyboard (jumping on top to offer a paid upgrade).
Of the two we are not detecting, one is currently inoperable, and the other has a data dependency
between checking the running apps and launching the attack (we only check for dependency in the
control flow).
21 of the detected apps belong to the DroidKungFu malware family, which aggressively displays
an Activity on top of any other.
out of 20 samples. Manual investigation revealed that of the two
undetected samples, one is currently inoperable and the other has a
data dependency between checking the running apps and launching
the attack (we only check for dependency in the control flow).
Finally, we tested our tool on the malicious set of 1,260 apps
from the Android Malware Genome project [22]. Overall, most
current Android malware is trying to surreptitiously steal and
exfiltrate data, trying hard to remain unnoticed. Hence, we would
not expect many samples to trigger our detection. In this set, we
detected 25 apps as suspicious. Upon manual review, we found
that 21 of the detected samples belong to the malware family
DroidKungFu. These samples aggressively display an Activity on
top of any other, asking to the user to either grant them “superuser”
privileges or enable the “USB debugging” functionality (so that the
root exploit they use can work). Due to code obfuscation, we could
not confirm whether the other four samples were correct detections
or not. To be on the safe side, we count them as incorrect detections.
We also ran our tool on a sample of the svpeng [23] malware
family. To the best of our knowledge, this is the only Android
malware family that currently performs GUI confusion attacks.
Specifically, this sample detects when the official Google Play Store
is opened. At this point, as shown in Figure 3, the malicious sample
spawns an Activity, mimicking the original “Enter card details”
Activity. As expected, our tool was able to detect this malicious
sample. Furthermore, we tested our tool on an Android ransomware
sample known to interfere with the GUI (Android.Fakedefender).
As expected, our tool correctly flagged the app as suspicious, since
it uses an enhancing technique (detecting if the user is trying to
uninstall it) and an attack vector (going on top of the uninstall
Activity to prevent users from using it).
Finally, we used our tool to check for the “inescapable”
fullscreen technique. Our tool did not find evidence of its usage in
any of the analyzed sets. This suggests that removing the possibility
of using this very specific functionality (as we will propose in the
next section) will not break compatibility with existing applications.
VI. UI DEFENSE MECHANISM
As mentioned, we complete our defense approach with a system
designed to inform users and leave the final decision to them,
exploiting the fact that the Android system is not being fooled by
GUI attacks: Recall from Section II-A that all user-visible elements
are created and managed via explicit app-OS interactions.
What compromises user security (and we consider the root
cause of our attacks) is that there is simply no way for the user
to know with which application she is actually interacting. To
rectify this situation, we propose a set of simple modifications to
the Android system to establish a trusted path to inform the user
without compromising UI functionality.
939939940
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:09:15 UTC from IEEE Xplore.  Restrictions apply. 
TABLE VI: Examples of deception methods and whether defense systems protect against them.
Keyboard input to the wrong app
Custom input method to the wrong app (i.e., Google
Wallet’s PIN entry), on-screen info from the wrong app
Covert app switch
Faked app switch (through the back or power button)
“Sit and Wait” (passive appearance change)
Similar-looking app icon and name, installed through
the market
Side-loaded app, with the same app icon and name
(possibly, through repackaging)
Confusing GUI elements added by other apps (inter-
cepting or non-intercepting draw-over, toast messages)
Presenting deceptive elements in non-immersive
fullscreen mode
Presenting deceptive elements in immersive fullscreen
mode
Fernandes et al. [9]

Off by default, requires user interaction: The protection is
activated only if the user presses a specific key combination.
Keyboard only
Keyboard only
Keyboard only