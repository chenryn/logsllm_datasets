第3章 基于网络的架构风格 27
请求会更多，只有近期被访问过的数据才能被离线操作使用。另一方面，缓存风格实现起来
要容易得多，不需要复制仓库风格那么多的处理和存储，而且由于只有当数据被请求时才会
传输数据，因此缓存风格更加高效。缓存风格当与客户-无状态-服务器风格（client- stateless-
server style）结合后就成为了一种基于网络的架构风格。
3.4 分层风格（Hierarchical Styles）
表3-3: 评估基于网络的超媒体系统的分层风格
风格 继承 网 用 效 可 简 可 可 可 可 可 可 可 可
络 户 率 伸 单 进 扩 定 配 重 见 移 靠
性 可 缩 性 化 展 制 置 用 性 植 性
能 觉 性 性 性 性 性 性 性
察
性
能
CS + + +
LS - + + + +
LCS CS+LS - ++ + ++ + +
CSS CS - ++ + + + +
C$SS CSS+$ - + + ++ + + + +
LC$SS LCS+C$SS - ± + +++ ++ ++ + + + +
RS CS + - + + -
RDA CS + - - + -
3.4.1 客户-服务器（Client-Server，CS）
客户-服务器风格在基于网络的应用的架构风格中最为常见。服务器组件提供了一组服
务，并监听对这些服务的请求。客户端组件通过一个连接器将请求发送到服务器，希望执行
一个服务。服务器可以拒绝这个请求，也可以执行这个请求并将响应发送回客户端。Sinha
[123]和Umar [131]对多种客户-服务器系统进行了调查。
Andrews [6]是这样描述客户-服务器组件的：一个客户是一个触发进程；一个服务器是
一个反应进程。客户端发送请求触发服务器的反应。这样，客户端可以在它所选择的时间启
动活动；然后它通常等待直到请求的服务完成处理。另一方面，服务器等待接收请求，并对
请求作出反应。服务器通常是一个永不终止的进程，并且常常为多个客户端提供服务。
分离关注点是在客户-服务器约束背后的原则。功能的适当分离会简化服务器组件，从
而提高可伸缩性。这种简化所采用的形式通常是将所有的用户接口（译者注：即用户界面）
功能移到客户端组件中。只要接口不发生改变，这种分离允许两种类型的组件独立地进化。
客户-服务器的基本形式并不限制应用状态如何在客户端组件和服务器组件之间划分。
这常常由连接器实现所使用的机制来负责，例如远程过程调用（remote procedure call）[23]
或者面向消息的中间件（message-oriented middleware）[131]。
第3章 基于网络的架构风格 28
3.4.2 分层系统（Layered System，LS）和分层-客户-服务器（Layered-
Client-Server，LCS）
一个分层系统是按照层次来组织的，每一层为在其之上的层提供服务，并且使用在其之
下的层所提供的服务[53]。尽管分层系统被看作一种“单纯”的风格，但是它在基于网络的
系统中的使用仅限于与客户-服务器风格相结合，形成分层-客户-服务器风格。
分层系统通过对相邻的外部层之外的所有层隐藏内部层，减少了跨越多层的耦合，从而
改善了可进化性和可重用性。分层系统的例子包括分层通信协议的处理，例如 TCP/IP和
OSI协议栈[138]，以及硬件接口库。分层系统的主要缺点是它们增加了处理数据的开销和延
迟，降低了用户可觉察的性能[32]。
分层-客户-服务器风格在客户-服务器风格的基础上添加了代理（proxy）组件和网关
（gateway）组件。一个代理组件作为一个或多个客户端组件的共享服务器（a shared
server），它接收请求并进行可能的转换后将其转发给服务器。一个网关组件在客户端或代
理看起来像是一个正常的服务器，但是事实上它将请求进行可能的转换后转发给了它的“内
部层”（inner- layer）服务器。这些额外的中间组件添加了很多个层，用来为系统添加诸如
负载均衡和安全性检查这样的功能。
基于分层-客户-服务器风格的架构在信息系统文献[131]中常常被称为两层、三层或者多
层架构。
LCS风格也可以作为在大规模分布式系统中管理标识的一种解决方案，在这样的系统
中，了解所有服务器的完整信息是代价高昂的。相反，服务器被组织为多个层次，这样那些
很少被用到的服务可以由中间组件来处理，而不是直接由每个客户端组件来处理[6]。
3.4.3 客户-无状态-服务器（Client-Stateless-Server，CSS）
客户-无状态-服务器风格源自客户-服务器风格，并且添加了额外的约束：在服务器组件
之上不允许有会话状态（session state）。从客户端发到服务器的每个请求必须包含理解请求
所必需的全部信息，不能利用任何保存在服务器上的上下文（context），会话状态全部保存
在客户端。
这些约束改善了可见性、可靠性和可伸缩性3个架构属性。可见性的改善是因为监视系
统再也不必为了确定请求的全部性质而查看多个请求的数据。可靠性的改善是因为这些约束
简化了从部分故障中恢复的任务[133]。可伸缩性的改善是因为不必保存多个请求之间的状
态，允许服务器组件迅速释放资源并进一步简化其实现。
客户-无状态-服务器风格的缺点是：因为我们不能将状态数据保存在服务器上的共享上
下文中，通过增加在一系列请求中发送的重复数据（每次交互的开销），可能会降低网络性
能。
3.4.4 客户-缓存-无状态-服务器（Client-Cache-Stateless-Server，C$SS）
客户-缓存-无状态-服务器风格来源于客户-无状态-服务器风格和缓存风格（通过添加缓
存组件）。一个缓存在客户端和服务器之间扮演一个仲裁者：早先请求的响应能够（如果它
们被认为是可缓存的）被重用，以响应稍后的相同请求，如果将该请求转发到服务器，得到
的响应可能与缓存中已有的响应相同。有效地利用此风格的实例系统是Sun微系统公司的
NFS[115]。
添加缓存组件的好处是，它们有可能部分或全部消除一些交互，从而提高效率和用户可
觉察的性能。
第3章 基于网络的架构风格 29
3.4.5 分层-客户-缓存-无状态-服务器（Layered-Client-Cache-Stateless-
Server，LC$SS）
分层-客户-缓存-无状态-服务器风格通过添加代理和/或网关组件，继承了分层-客户-服
务器风格和客户-缓存-无状态-服务器风格。使用此风格的范例系统是Internet域名系统
（DNS）。
LC$SS风格的优点和缺点是LCS风格和C$SS风格的优点和缺点集合。然而，请注意我
们不能将CS风格的贡献计算两次，因为如果贡献来自相同的祖先的话，那么其优点是不可
叠加的。
3.4.6 远程会话（Remote Session，RS）
远程会话风格是客户-服务器风格的一种变体，它试图使客户端组件（而非服务器组件）
的复杂性最小化或者使得它们的可重用性最大化。每个客户端在服务器上启动一个会话，然
后调用服务器的一系列服务，最后退出会话。应用状态被完全保存在服务器上。这种风格通
常在以下场合中使用：想要使用一个通用的客户端（generic client）（例如TELNET[106]）
或者通过一个模仿通用客户端的接口（例如FTP [107]）来访问远程服务。
远程会话风格的优点是：集中维护在服务器的接口更加容易；当对功能进行扩展时，减
少了已部署的客户端中的不一致问题；如果交互利用了服务器上扩展的会话上下文，它能够
提高效率。它的缺点是：由于要在服务器上保存应用状态，降低了服务器的可伸缩性；因为
监视程序必须要知道服务器的完整状态，降低了交互的可见性。
3.4.7 远程数据访问（Remote Data Access，RDA）
远程数据访问风格[131]是客户-服务器风格的一种变体，它将应用状态分布在客户端和
服务器上。客户端以一种标准的格式发送一个数据库查询（例如SQL）请求到服务器，服务
器分配一个工作空间并执行这个查询，这可能会导致一个巨大的结果集。客户端能够在结果
集上进行进一步操作（例如表连接）或者每次获取结果的一部分。客户端必须了解服务的数
据结构，以便建造依赖于该结构的查询。
远程数据访问风格的优点是：一个巨大的数据集能够在服务器端通过多次迭代的方式逐
渐减少，而不需要通过网络传输完整的数据集，从而改善了效率；通过使用一种标准的查询
语言，从而改善了可见性。这种风格的缺点是：客户端必须像服务器实现那样理解相同的数
据库操作概念（因此缺少简单性）；而且在服务器上保存应用的上下文，降低了可伸缩性。
由于部分故障会导致工作空间处于未知状态 ，可靠性也蒙受了损失。尽管能够使用事务机
制（例如，二次提交）来修正可靠性的问题，但是代价是增加了复杂性和交互的开销。
3.5 移动代码风格（Mobile Code Styles）
移动代码风格使用移动性（mobility）来动态地改变在处理过程与数据源或结果目的地
之间的距离。Fuggetta等人[50]全面地检查过这些风格。为了考虑不同组件的位置，他们在
架构层面引入了一种站点抽象（site abstraction），作为主动配置的一部分。位置
（location）概念的引入，使得在设计的层面对组件之间的交互开销进行建模成为了可能。
特别是，当与包括了网络通信的交互的开销作比较时，共享同一位置的组件之间的交互开销
的成本被认为是可以忽略不计的。通过改变自己的位置，一个组件可以改善接近性
（proximity）和它的交互的质量，减少交互开销从而提高效率和用户可觉察的性能。
在所有的移动代码风格中，一个数据成员被动态地转换为一个组件。为了确定一个特定
的行为是否需要移动性，Fuggetta 等人[50]使用了一种分析方法：将代码尺寸（code's size）
第3章 基于网络的架构风格 30
作为一个数据成员，与在正常的数据转移中所节省的部分作比较。如果软件架构的定义排除
了数据元素，那么从架构的观点来建模将是不可能的。
表3-4：评估基于网络的超媒体系统的移动代码风格
风格 继承 网 用 效 可 简 可 可 可 可 可 可 可 可
络 户 率 伸 单 进 扩 定 配 重 见 移 靠
性 可 缩 性 化 展 制 置 用 性 植 性
能 觉 性 性 性 性 性 性 性
察
性
能
VM ± + - +
REV CS+VM + - ± + + - + -
COD CS+VM + + + ± + + -
LCODC LC$SS+ - ++ ++ +4+ +±+ ++ + + + ± + +
$SS COD