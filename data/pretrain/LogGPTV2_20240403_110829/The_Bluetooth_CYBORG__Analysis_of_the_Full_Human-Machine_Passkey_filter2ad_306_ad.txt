give the adversary the ability to compromise the UtD channel.
ShowUser models the adversary gaining control over a device
and inducing it to send messages to the user, via malware-
induced pop-ups for example. Meanwhile the ControlUser
query gives the adversary the ability to affect messages input to
the device from the user, such as from a Ghost Touch Generator
or social engineering. The ShowUser and ControlUser queries
are also restricted in effect to speciﬁc sessions. This is done to
capture the idea that adversary compromise of the UtD channel
can have a time-sensitive nature.
3) User and Device Freshness.: Typically, freshness has
only been deﬁned with respect to devices. This made sense
when only devices engaged in the action of the protocol, but
with the advent of cyborg protocols it becomes necessary to
deﬁne freshness for device and user session oracles. The un-
compromised setting enables us to test the baseline security of
the protocol, which restricts the adversary’s use of both device
and user-oriented queries. In the compromised user setting,
the adversary gains varying abilities to issue combinations
of ShowUser and ControlUser queries. The freshness types
([iu], [ru], [ui] and [ur] are depicted visually in Figure 2). We
deﬁne a corresponding device freshness that is used to assess
key indistinguishability in the security experiment, wherein the
adversary may not reveal device secrets; the adversary has
much more liberty to reveal device secrets when attempting
to break authentication.
Deﬁnition III.8 (Device Freshness). We say that a device
is fresh in the uncompromised setting
session oracle πA
s
(UncUser-fresh) and fresh under compromised user type [x]
(CompUser[x]-fresh) unless any of the following hold:
s ) query, or
• the adversary issues a StateReveal(πA
• if there exists a session oracle πB
t partnered with πA
s and
the adversary issues a StateReveal(πB
t ) query, or
• the adversary has issued a KeyReveal(πA
• if there exists a session oracle, πB
and the adversary issues a KeyReveal(πB
s ) query, or
t , partnered with πA
s
t ) query.
The freshness conditions whereby we restrict adversarial
reveals on both the target device session and a partnered
device session is in keeping with precedent. The restriction of
adversarial queries on a device partnered with the same user
oracle is analogous to restricting corruption of the intended
8
partner’s long-term keys. Cyborg key exchange protocols rely
on the user to authenticate devices in the same vein as a
Certiﬁcate Authority authenticates devices in typical AKE;
thus, we rely on the user’s authentication of the intended
partner to limit reveals.
Deﬁnition III.9 (User Freshness under No Compromise). We
is fresh in the uncompromised
say that a session oracle πU
j
setting (UncUser-fresh) unless any of the following hold:
• the adversary has issued a ShowUser(πA
s ) query before
the last UtD message is sent and received between πU
j
and πA
is partnered
with πA
s according to the protocol, where πU
j
s , or
• the adversary has issued a ControlUser(πU
j , A) query
before the last UtD message is sent and received between
is
πU
j
partnered with πA
s .
according to the protocol, where πU
j
and πA
s
• the adversary has issued a ShowUser(πA
We now focus on the freshness scenario under user com-
promise, which replaces the traditional view of the user as a
perfect OOB channel (i.e. an uncompromised user).
Deﬁnition III.10 (User Freshness under Compromise Type iu
and ru). We say that a session oracle πU
for U and session
j
j is fresh under compromised user, type iu (resp. type ru),
denoted CompUser[iu]-fresh (resp. CompUser[ru]-fresh) unless
s ) query before
the last UtD message is sent and received between πU
j
is partnered
and πA
with πA
◦ (if CompUser[iu]
◦ (if CompUser[ru]
or
s according to the protocol, where πU
j
s , and
s .role = responder
s .role = initiator
:) πA
:) πA
• the adversary has issued a ControlUser(πU
j , A) query
before the last UtD message is sent and received between
is
πU
j
partnered with πA
s .
according to the protocol, where πU
j
and πA
s
Deﬁnition III.11 (User Freshness under Compromise Type ui
and ur). We say that a session oracle πU
for U and session
j
j is fresh under compromised user, type ui (resp. type ur),
denoted CompUser[ui]-fresh (resp. CompUser[ur]-fresh) unless
s ) query before
the last UtD message is sent and received between πU
j
and πA
is partnered
with πA
s according to the protocol, where πU
j
s , or
• the adversary has issued a ShowUser(πA
• the adversary has issued a ControlUser(πU
according to the protocol, where πU
j
j , A) query
before the last UtD message is sent and received between
is
πU
j
partnered with πA
◦ (if CompUser[ui]
◦ (if CompUser[ur]
We restrict
the adversary from making ShowUser and
ControlUser queries dependent on the role of the device
s .role = responder
s .role = initiator
and πA
s
s , and
:) πA
:) πA
session, such that only one UtD channel may be compromised
in each type (denoted in red/dashes in Figure 2). This decision
allows us to focus on the exact circumstances under which a
protocol breaks.
Deﬁnition III.12 (User Freshness under Compromise Type
Combinations). Let X be a non-empty subset of the set
{iu, ru, ui, ur}; we refer to the set X with the label string
x constructed from the elements of X in sequential order.
We then say that a session oracle πU
for U and session j is
j
termed fresh under compromised user, type x (CompUser[x]-
fresh) unless the adversary issues a single query which breaks
CompUser[xi]-freshness simultaneously for all xi ∈ X.
Note that a session oracle’s freshness must be assessed
per query under CompUser[x]-fresh; said query must break
freshness for the session oracle in all the elements of the set X
individually. This structuring of CompUser[x]-fresh is needed
so we can capture more advanced attacks that an adversary
may mount. Using only select deﬁnitions from among Deﬁni-
tions III.10 to III.11 we would be unable to capture the “Tap
‘n Ghost” attack as it involves the corruption of the communi-
cation channels both from a device to the user and vice versa.
However, we can model this using the CompUser[iu,ui]-fresh.
In a CompUser[iu,ui]-fresh environment, the adversary would
be allowed to issue both a ShowUser and a ControlUser query
so long as both involved the initiating device; and similarly in a
CompUser[ru,ur]-fresh environment for the responding device.
C. CYBORG Security Experiment
In light of all previous deﬁnitions, we now present the
CYBORG security experiment for the reader.
Deﬁnition III.13. We deﬁne the CYBORG-type security ex-
periment for a PPT adversarial algorithm A against a cy-
borg key exchange protocol Π, and interacting with a chal-
lenger via all previously deﬁned adversarial queries in the
EXPCYBORG-type
experiment, where ηp is the maximum num-
ber of device participants and ηs is the maximum number of
sessions for any participant. We say that the adversary A wins
the experiment with the challenger outputting 1 if any of the
following conditions hold for type ∈ {UncUser, CompUser}.
1) Correctness (correct):
Π,A,ηp,ηs
t where:
there exists two type-fresh and partnered device oracles
s and πB
πA
• πA
t are both partnered with the type-fresh user
j , and
s and πB
oracle πU
s .δ (cid:54)= accept, or
t .δ (cid:54)= accept.
• πA
• πB
2) Entity Authentication (auth):
s where:
there exists a type-fresh session oracle πA
• πA
• πA
• if πU
s .δ = accept with intended partner pid = B and
s is partnered with the type-fresh user oracle πU
is also partnered with πB
t ) query while πA
StateReveal(πB
j , and
t , A has not issued a
s .δ (cid:54)= accept, and
j
• there does not exist a unique session oracle at B that
is partnered with πA
s .
3) Key Indistinguishability (key-ind):
s , where
s .δ = accept with intended partner pid = B, and
s is partnered with a type-fresh user oracle πU
at some point in the experiment A issued a Test(πA
s )
query on a type-fresh session oracle πA
• πA
• πA
• if πU
j , and
t , A has not issued a
s .δ (cid:54)= accept, and
• there exists an oracle πB
s , and
• at some subsequent point in the experiment πA
is also partnered with πB
t ) query while πA
re-
sponds with its guess b, where Pr[b = b] ≥ 1/2 where
b is the randomly sampled bit from the associated Test
query.
t(cid:48) partnered with πA
StateReveal(πB
s
j
Else, the challenger outputs 0. We denote the adversary A
winning the experiment and the challenger outputting 1 as:
EXPCYBORG-type
Π,A,ηp,ηs
(λ) = 1 .
We deﬁne the advantage for the PPT adversarial algorithm A
in the above experiment to be:
AdvCYBORG-type
Π,A,ηp,ηs
(λ) := Pr[EXPCYBORG-type
Π,A,ηp,ηs
(λ) = 1] .
Deﬁnition III.14. If there exists a negligible function negl(λ)
such that for all PPT adversaries A interacting according to
the CYBORG-type experiment, it holds that:
(λ) ≤ negl(λ) ,
AdvCYBORG-type
Π,A,ηp,ηs
then we say that the protocol Π is CYBORG-type-secure.
The above deﬁnition presents a change from META in
that we require two partnered oracles to imply acceptance,
as captured by correct. This is a reasonable assumption when
acceptance is not conditioned by a concluding user input.
IV. ANALYSIS OF PASSKEY ENTRY
In this section we present the initial results of our analysis
of Passkey Entry under the CYBORG security model and
show that all versions of Passkey Entry fail to meet any version
of CYBORG security. For Inititiator/Responder-Generated
Passkey Entry, this is because the ﬁrst 19 generated nonces
are not authenticated in Phase 3, which leads to an adversarial
forgery based off a single bit guess and consequently failure of
session matching. Meanwhile, User-Generated Passkey Entry
fails to achieve CYBORG security because role agreement is
not guaranteed through protocol execution.
We deﬁne the session-state information for all versions of
Passkey Entry and a given session oracle πA
s as:
s .state = (SKa, r, Na,1, . . . , Na,20) ,
πA
where all values are as deﬁned in Section II. We capture
all randomly generated information a device considers secret
in the session-state. Although nonces are made public in the
course of the protocol, they are included here as they are used
as secret keys before such disclosure.
9
Since all versions of Passkey Entry are susceptible to
passkey re-use attacks [31], the passkey r must be generated
as an ephemeral secret. This presents a unique modeling
challenge. If generated by a device, the passkey may be derived
from the same source of randomness as other ephemeral keys
or nonces. If generated by a user however, this is not the case.
In this scenario, it becomes necessary to operate under the
assumption that the user has some means of random number
generation either via a keyfob or other source.
Initiating
Device: A
Initiating
Device: B
Phase 0: Init and IOcap Exchange
0. A, B, IOcapA, IOcapB
Phase 1: Public Key Exchange
$← {0, 1}255
1a. SKa
2a. P Ka ← [SKa]P
$← {0, 1}255
1a’. SKb