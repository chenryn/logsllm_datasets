title:Hit-List Worm Detection and Bot Identification in Large Networks Using
Protocol Graphs
author:M. Patrick Collins and
Michael K. Reiter
Hit-List Worm Detection and Bot Identiﬁcation
in Large Networks Using Protocol Graphs
M. Patrick Collins1 and Michael K. Reiter2
1 CERT/Network Situational Awareness, Software Engineering Institute,
Carnegie Mellon University
2 Department of Computer Science, University of North Carolina
PI:EMAIL
at Chapel Hill
PI:EMAIL
Abstract. We present a novel method for detecting hit-list worms using
protocol graphs. In a protocol graph, a vertex represents a single IP ad-
dress, and an edge represents communications between those addresses
using a speciﬁc protocol (e.g., HTTP). We show that the protocol graphs
of four diverse and representative protocols (HTTP, FTP, SMTP, and
Oracle), as constructed from monitoring for ﬁxed durations on a large in-
tercontinental network, exhibit stable graph sizes and largest connected
component sizes. Moreover, we demonstrate that worm propagations,
even of a sophisticated hit-list variety in which the attacker has advance
knowledge of his targets and always connects successfully, perturb these
properties. We demonstrate that these properties can be monitored very
eﬃciently even in very large networks, giving rise to a viable and novel
approach for worm detection. We also demonstrate extensions by which
the attacking hosts (bots) can be identiﬁed with high accuracy.
Keywords: Graph analysis, Anomaly detection, Large networks.
1 Introduction
Large numbers of Internet worms have prompted researchers to develop a variety
of anomaly-based approaches to detect these attacks. Examples include moni-
toring the number of failed connection attempts by a host (e.g., [5,16,27]), or
the connection rate of a host to new targets (e.g., [24,19,17]). These systems are
designed to detect abnormally frequent connections and often rely on evidence
of connection failure, such as half-open TCP connections. To avoid detection by
these systems, an attacker can use a hit list [20] generated previous to the attack
or generated by another party [3]. An attacker using an accurate hit list contacts
only targets known to be running an accessible server, and therefore will not trig-
ger an alarm predicated on connection failure. By constraining the number of
attack connections initiated by each attacker-controlled bot, the attacker could
compromise targets while evading detection by most (if not all) techniques that
monitor the behavior of individual hosts or rely on connection failures.
C. Kruegel, R. Lippmann, and A. Clark (Eds.): RAID 2007, LNCS 4637, pp. 276–295, 2007.
c(cid:2) Springer-Verlag Berlin Heidelberg 2007
Hit-List Worm Detection and Bot Identiﬁcation in Large Networks
277
In this paper, we propose a new detection method, based on monitoring pro-
tocol graphs. A protocol graph is a representation of a traﬃc log for a single
protocol. In this graph, the vertices represent the IP addresses used as clients
or servers for a particular protocol (e.g., FTP), and the edges represent com-
munication between those addresses. We expect that a protocol graph will have
properties that derive from its underlying protocol’s design and use. For exam-
ple, we expect that since Oracle communications require password authentication
and HTTP interactions do not, a protocol graph representing Oracle will have
more connected components than a protocol graph representing HTTP, though
the HTTP graph’s connected components will likely be larger.
Our detection approach focuses on two graph properties: the number of ver-
tices comprising the graph (“graph size”) and the number of vertices in the
largest connected component of the graph (“largest component size”) for traﬃc
logs collected in a ﬁxed duration. We hypothesize that while an attacker may
have a hit list identifying servers within a network, he will not have accurate
information about the activity or audience for those servers. As a consequence,
a hit-list attack will either artiﬁcially inﬂate the number of vertices in a pro-
tocol graph, or it will connect disjoint components, resulting in a greater than
expected largest component size.
To test this, we examine protocol graphs generated from traﬃc of several com-
mon protocols as observed in a large (larger than a /8) network. Speciﬁcally, we
examine HTTP, SMTP, Oracle and FTP. Using this data, we conﬁrm that pro-
tocol graphs for these protocols have predictable graph and largest component
sizes. We then inject synthetic hit-list attacks into the network, launched from
one or more attacker-controlled bots, to determine if these attacks detectably
modify either graph size or largest component size of the observed protocol
graphs. The results of our study indicate that monitoring graph size and partic-
ularly largest component size is an eﬀective means of hit-list worm detection for
a wide range of attack parameters and protocols. For example, if tuned to yield
one false alarm per day, our techniques reliably detect aggressive hit-list attacks
and detect even moderate hit-list attacks with regularity, whether from one or
many attacker-controlled bots.
Once an alarm is raised, an important component of diagnosis is determining
which of the vertices in the graph represent bots. We show how to use protocol
graphs to achieve this by measuring the number of connected components re-
sulting from the removal of high-degree vertices in the graph. We demonstrate
through extensions to our analysis that we can identify bots with a high degree
of accuracy for FTP, SMTP and HTTP, and with somewhat less (though still
useful) accuracy for Oracle. We also show that our bot identiﬁcation accuracy
exceeds what can be achieved by examining vertex degree alone.
While there are many conceivable measures of a protocol graph that might
be useful for detecting worms, any such measure must be eﬃcient to monitor if
detection is to occur in near-real-time. The graph size and largest component
size are very advantageous in this respect, in that they admit very eﬃcient com-
putation via well-known union-ﬁnd algorithms (see [7]). A union-ﬁnd algorithm
278
M.P. Collins and M.K. Reiter
implements a collection of disjoint sets of elements supporting two operations:
two sets in the collection can be merged (union), and the set containing a partic-
ular element can be located (find). In our application, the elements of sets are
IP addresses, and the sets are the connected components of the protocol graph.
As such, when a new communication record is observed, the set containing each
endpoint is located (two find operations) and, if these two sets are distinct,
they can be merged (a union operation). Using well-known techniques, commu-
nication records can be processed in amortized time that is eﬀectively a small
constant per communication record, and in space proportional to the number of
IP addresses observed. By comparison, detection approaches that track connec-
tion rates to new targets (e.g., [24,17]) require space proportional to the number
of unique connections observed, which can far exceed the number of unique IP
addresses observed. While our attacker identiﬁcation that is performed following
an alarm incurs costs similar to these prior techniques, we emphasize that it can
be proceed simultaneously with reactive defenses being deployed and so need
not be as time-critical as detection itself.
To summarize, the contributions of our paper include (i) deﬁning protocol
graphs and detailing their use as a hit-list attack detection technique; (ii) demon-
strating through trace-driven analysis on a large network that this technique is
eﬀective for detecting hit-list attacks; (iii) extending protocol graph analysis to
infer the locations of bots when hit-list worms are detected; and (iv) describing
eﬃcient algorithms by which worm detection and bot identiﬁcation can be per-
formed, in particular with detection being even more eﬃcient than techniques
that focus on localized behavior of hosts.
Our paper proceeds as follows. Section 2 summarizes previous relevant work.
Section 3 describes protocol graphs and the data we use in our analysis. Sec-
tion 4 examines the size of graphs and their largest components under normal
circumstances, and introduces our anomaly detection technique. In Section 5, we
test our technique through simulated hit-list attacks. We extend our approach
to identify attackers in Section 6. Section 7 addresses implementation issues.
Section 8 summarizes our results and discusses ongoing and future research.
2 Previous Work
Several intrusion-detection and protocol-identiﬁcation systems have used graph-
based communication models. Numerous visualization tools (e.g., [12,26,25])
present various attributes of communication graphs for visual inspection. Stan-
iford et al.’s GrIDS system [21] generates graphs describing communications
between IP addresses or more abstract entities within a network, such as the
computers comprising a department. A more recent implementation of this ap-
proach by Ellis et al. [6] has been used for worm detection. Karagiannis at
al. [9] develop a graphical traﬃc proﬁling system called BLINC for identifying
applications from their traﬃc. Stolfo et al.’s [22] Email Mining Toolkit devel-
ops graphical representations of email communications and uses them to detect
email viruses and worms.
Hit-List Worm Detection and Bot Identiﬁcation in Large Networks
279
In all of these cases, the systems detect (or pesent data to a human to detect)
phenomena of interest based primarily on localized (e.g., per-vertex or vertex
neighborhood) properties of the graph. GrIDS generates rules describing how
internal departments or organizations communicate, and can develop thresh-
old rules (e.g., “trigger an alarm if the vertex has degree more than 20”). Ellis’
approach uses combinations of link predicates to identify a host’s behavior. Kara-
giannis’ approach expresses these same communications using subgraph models
called graphlets. Stolfo et al.’s approach identiﬁes cliques per user, to whom the
user has been observed sending the same email, and ﬂags emails that span mul-
tiple cliques as potentially containing a virus or worm. In comparison to these
eﬀorts, our work focuses on aggregate graph behavior (graph size and largest
component size) as opposed to localized properties of the graph or individual
vertices. Moreover, some of these approaches utilize more protocol semantics
(e.g., the event of sending an email to multiple users [22], or the expected com-
munication patters of an application [9]) that we do not consider here in the
interest of both generality and eﬃciency.
Several empirical studies have attempted to map out the structure of ap-
plication networks. Such studies of which we are aware have been conducted
by actively crawling the application network in a depth- or breadth-ﬁrst man-
ner, starting from some seed set of known participants. For example, Broder et
al. [4] studied web interconnectivity by characterizing the links between pages.
Ripeanu et al. [14] and Saroiu et al. [15] similarly conducted such studies of
Gnutella and BitTorrent, respectively. Pouwelse et al. [13] use a similar probe
and crawl approach to identify BitTorrent networks over an 8-month period.
Our work diﬀers from these in that our techniques are purely passive and are
assembled (and evaluated) for the purpose of worm detection.
Our protocol graphs are more closely related to the call graphs studied by
Aiello et al. [2] in the context of the AT&T voice network. In a call graph, each
vertex represents a phone number and each (directed) edge denotes a call placed
from one vertex to another. Aiello et al. observe that the size of the largest
connected component of observed call graphs is Θ(|V |), where V denotes the
vertices of the graph. These call graphs are similar to our protocol graphs, the
primary diﬀerences being that call graphs are directed (the protocol graphs we
study are undirected) and that they are used to characterize a diﬀerent domain
(telephony, versus data networks here). However, Aiello et al. studied call graphs
to understand their basic structure, but not with attention to worm detection
(and in fact we are unaware of worms in that domain).
3 Preliminaries
In this section, we investigate the construction and composition of protocol
graphs. Protocol graphs are generated from traﬃc logs; our analyses use CISCO
Netﬂow, but graphs can also be constructed using tcpdump data or server logs.
280
M.P. Collins and M.K. Reiter
This section is structured as follows. Section 3.1 describes the construction
of protocol graphs and our notation for describing them and their properties.
Section 3.2 describes our source data.
3.1 Protocol Graphs
We consider a log ﬁle (set) Λ = {λ1, . . . , λn} of traﬃc records. Each record λ has
ﬁelds for IP addresses, namely source address λ.sip and destination address λ.dip.
In addition, λ.server denotes the address of the server in the protocol interaction
(λ.server ∈ {λ.sip, λ.dip}), though we emphasize that we require λ.server only
for evaluation purposes; it is not used in our detection or attacker identiﬁcation
mechanisms.
Given Λ, we deﬁne an undirected graph G(Λ) = (cid:3)V (Λ), E(Λ)(cid:4), where
{(λ.sip, λ.dip)}
{λ.sip, λ.dip}
V (Λ) =
(cid:2)
λ∈Λ
E(Λ) =
(cid:2)
λ∈Λ
The largest connected component of a graph G(Λ) is denoted C(Λ) ⊆ V (Λ).
Note that by construction, G(Λ) has no connected component of size one (i.e.,
an isolated vertex); all components are of size two or greater.1
We denote by Λπ a log ﬁle that is recorded during the interval π ⊆ [00:00GMT,
23:59GMT] on some speciﬁed date. We deﬁne V dur
Π to be random vari-
ables of which |V (Λπ)| and |C(Λπ)|, for logs Λπ collected in dur-length time
intervals π ⊆ Π, are observations. For example, in the following sections we
will focus on Π = [00:00GMT, 11:59GMT] (denoted am) and Π = [12:00GMT,
23:59GMT] (denoted pm), and take |V (Λπ)| and |C(Λπ)| with π ⊆ am of length
60 seconds (s) as an observation of V 60s
am , respectively. We denote the
mean and standard deviation of V dur
Π ) and σ(V dur
Π ), respectively, and
similarly for Cdur
Π .
am and C60s
Π by μ(V dur
Π and Cdur
3.2 Data Set
The source data for these analyses are CISCO Netﬂow traﬃc summaries collected
on a large (larger than a /8) ISP network. We use collectors at the border of
the network’s autonomous intranets in order to record the internal and cross
border network activity. Therefore, all protocol participants that communicate
between intranets or with the Internet are observed. Netﬂow reports ﬂow logs,
where a ﬂow is a sequence of packets with the same addressing information that
are closely related in time. Flow data is a compact summary of network traﬃc
and therefore useful for maintaining records of traﬃc across large networks.
Flow data does not include payload information, and as a result we identify
protocol traﬃc by using port numbers. Given a ﬂow record, we convert it to a
log record λ of the type we need by setting λ.server to the IP address that has
the corresponding service port; e.g., in a ﬂow involving ports 80 and 3946, the
1 It is possible for various logging mechanisms, under speciﬁc circumstances, to record
a ﬂow from a host to itself. We eliminate those records for this work.
Hit-List Worm Detection and Bot Identiﬁcation in Large Networks
281
protocol is assumed to be HTTP and the server is the IP address using port 80.
Protocol graphs constructed using log ﬁles with payload could look for banners
within the payload to identify services.
The protocols used for analysis are listed below.
– HTTP: The HTTP dataset consists of traﬃc where the source or destination
port is port 80 and the other port is ephemeral (≥ 1024). HTTP is the most
active protocol on the monitored network, comprising approximately 50% of
the total number of bytes crossing the network during the workday.
– SMTP: SMTP consists of TCP traﬃc where the source or destination port
is port 25 and the other port is ephemeral. After HTTP, SMTP is the most
active protocol on the monitored network, comprising approximately 30% of
the total number of bytes.
– Oracle: The Oracle dataset consists of traﬃc where one port is 1521 and
the other port is ephemeral. While Oracle traﬃc is a fraction of HTTP and
SMTP traﬃc, it is a business-critical application. More importantly, Oracle
connections are password-protected and we expect that as a consequence
any single user will have access to a limited number of Oracle servers.
– FTP: The FTP dataset consists of records where one port is either 20 or
21, and the other port is ephemeral. While FTP provides password-based
authentication, public FTP servers are still available.
We study these protocols due to their diversity in patterns of activity; e.g., we
expect an individual web client to contact multiple web servers, but we expect
an individual Oracle client to contact far fewer Oracle servers. That said, this list
does not include all protocols that we would like to analyze. A notable omission
is peer-to-peer ﬁle sharing protocols; we omit these since the monitored network
blocks all ports commonly associated with peer-to-peer ﬁle-sharing applications
(BitTorrent, eDonkey, Kazaa, etc.).
4 Building a Hit-List Worm Detector
Π and Cdur
In this section we describe the general behavior of protocol graphs over time,
and show that the distributions of V dur
Π can be satisfactorily modeled
as normal for appropriate choices of Π and dur (Section 4.1). The parameters
of these distributions change as a function of the protocol (HTTP, SMTP, FTP,
Oracle), the interval in which logging occurs (Π), and the duration of log col-
lection (dur). Nevertheless, in all cases the graph and largest component sizes
are normally distributed, which enables us to postulate a detection mechanism
for hit-list worms and estimate the false alarm rate for any detection threshold
(Section 4.2).
4.1 Graph Behavior over Time
Figure 1 is a plot of the observed values of |V (Λπ)| and |C(Λπ)| for Oracle traf-
ﬁc on the monitored network for Monday, March 5th, 2007. Each logging interval
282
M.P. Collins and M.K. Reiter
Fig. 1. Oracle traﬃc on March 5, 2007; start time of π is on x-axis; dur = 60s
8
0
0
.
6
0
0
.
2
1
0
0
.
5
0
0
.
4
0
0
.
2
1
0
0
.
8
0
0
0
.
y
t
i
s
n
e
D
4
0
0
0
.
y
t
i
s
n
e
D
4
0
0
.
2
0
0
.
0
0
0
.
10
200
250
30
8
0
0
0
.
y
t
i
s
n
e
D
4
0
0
0
.
30
40
50
0
0
0
0
.
150
200