图10. `Cmdagent.exe`阻止未签名进程通过COM进行交互
这意味着这个`ACCESS_DENIED`并不是由Windows发出，而是Comodo自己做出的决定。
这个决策实际上是基于签名检查，签名检查会验证请求实例的COM客户端是可信的、“经过签名的”程序。观察`Cmdagent.exe`中的签名检查例程，可以看到文件需要由Comodo或者微软签名，这一点也能够理解，因为这样只有`Explorer.exe`或者`Cis.exe`这两个客户端才能调用`CmdAgent.exe`中的COM方法。
图11. `Cmdagent.exe`签名校验类（`HardMicrosoftSigner`/`HardComodoSigner`）
其实这个签名校验过程很容易被绕过，大家能不能发现问题所在？这里`CmdAgent.exe`会解析COM客户端的进程名，以便后续从磁盘上执行签名检查过程：
图12. `Cmdagent.exe`查找COM客户端的完整映像名
大家可能知道一点，[GetModuleFileNameEx](https://docs.microsoft.com/en-us/windows/desktop/api/psapi/nf-psapi-getmodulefilenameexa?source=post_page---------------------------)实际上只会查询目标进程的[PEB-](https://docs.microsoft.com/en-us/windows/desktop/api/winternl/ns-winternl-_peb?source=post_page---------------------------)>Ldr->`InMemoryOrderModuleList`，以便获取完整映像名。然而这个路径我们可以控制，因此我们可以在自己的进程中轻松修改这个特征。
还有另一种解决办法，我们可以将代码注入可信的微软程序或者Comodo程序，从中发起COM请求。然而Comodo会阻止dll注入操作，因此为了绕过这一点，我们需要对可信的Comodo程序执行Process
Hollowing操作。
这个过程比操作我们自己的PEB还麻烦，但能给我们带来更大的优势。通过这种方法，`Cmdguard.sys`驱动就不会注入`Guard64.dll`，因此也不会在我们的进程中设置各种hook。如果目标进程“不可信”，那么`Cmdguard.sys`就会调用`InjectDll`例程，如下图所示。如果我们对`C:\Program
Files\COMODO\COMODO Internet
Security\CmdVirth.exe`执行Hollowing操作，那么就可以绕过`IsProcessUntrusted`检查，因为驱动会根据可执行文件路径来判断该程序为可信程序，因此会成功放行。
图13. 如果目标进程“可信”，`Cmdguard.sys`就不会注入`Guard64.dll`
现在我们添加了一个Process Hollowing例程，用来处理`C:\Program Files\COMODO\COMODO Internet
Security\CmdVirth.exe`实例（该程序由Comodo签名），用我们的代码替换其中的可执行代码。现在注入的代码会执行我们前面设置的COM处理逻辑，并且能够绕过签名检查，不存在任何hook。我们重新运行这段代码，成功通过低权限进程，在设置沙箱标记的情况下触发扫描任务！
图14. 从自定义的未签名的COM客户端成功触发扫描操作
## 0x04 寻找可滥用的COM接口
可以从沙箱进程中执行扫描操作后，我们现在可以寻找`CmdAgent`中是否存在更多有趣的COM接口。观察我们提取到的60多个`CisGate`接口后，我们只找到了1个值得关注的对象，但这些接口都正确使用了[`CoImpersonateClient`](https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient?source=post_page---------------------------)，成功阻止了我想要找到的逻辑错误。当然还有许多方法可以研究，因为我们其实能提取出更多的接口。前面提到过，我们可以使用`CreateInstance`在`CmdAgent.exe`中创建一个CisGate对象。因此我们有可能创建更多的对象，研究更多的方法，让我们回到CmdAgent。
`ICisClassFactory`->`CreateInstance`函数会创建所需的对象，调用`CisGate`->`QueryInterface`返回请求的接口指针。这里提一下，[QueryInterface](https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface\(refiid_void)?source=post_page—————————————-)是`IUnknown`中的一个核心函数，是所有COM类的基类。简而言之，该函数会将[
_riid_](https://docs.microsoft.com/en-us/windows/desktop/learnwin32/asking-an-object-for-an-interface?source=post_page---------------------------)（接口标识符）解析成对象接口，这样客户端（比如我们开发的客户端）就可以调用接口上的方法。了解这一点后，我们可以逆向分析`CmdAgent.exe`的`QueryInterface`函数，观察其中支持哪些接口。
图15. `CmdAgent.exe`支持的接口
我们列出了`QueryInterface`支持的`supported_interfaces`，根据注册表中发现的信息来命名每个GUID。这里`IID_ICisFacade`这个riid用来返回`CisGate`对象，另一个比较有趣的目标是`IID_IServiceProvider`。查看[IID_IServiceProvider](https://msdn.microsoft.com/en-us/ie/cc678965\(v=vs.94)?source=post_page—————————————-)官方文档，貌似该接口可以给我们提供很多信息。在`Cis.exe`（Comodo
GUI Client）中搜索`IID_IServiceProvider`
GUID，发现Comodo的确在使用该接口。逆向分析代码逻辑后，我们可以澄清自己如何使用该接口、Comodo想使用的服务以及想执行的操作。
## 0x05 注册表读取
`Cis.exe`会使用`IServiceProvider`来执行[QueryService](https://docs.microsoft.com/en-us/windows/desktop/winauto/using-queryservice-to-expose-a-native-object-model-interface-for-an-iaccessible-object?source=post_page---------------------------)操作，用来获取Comodo定义的`SvcRegistryAccess`对象，部分代码片段如下图所示：
图16. `Cis.exe`获取`ISvcRegistryAccess`
这表明`Cis.exe`会从`CmdAgent.exe`获取`SvcRegistryAccess`对象，然后调用该对象中的方法读取注册表键值并返回数据。能让具备`SYSTEM`权限的进程帮我们读取注册表，这听起来已经是比较不错的一个攻击路径，但我感觉开发者不会只把这个`SvcRegistryAccess`当成一个“只读”类。让我们回到`CmdAgent`，观察这个COM类的实现机制。
在`CmdAgent`中，我们可以看到被远程调用的`ISvcRegistryAccess`方法会直接读取注册表键值，将数据返回给客户端，整个过程不涉及到`CoImpersinateClient`。这意味着我们可以使用`SYSTEM`权限读取注册表键值，因为这也是`CmdAgent`所具备的权限。
图17. `CmdAgent.exe` `ISvcRegistryAccess`以`SYSTEM`权限读取注册表，没有使用模拟机制
## 0x06 注册表写入
现在来看一下这个COM对象是否支持注册表写入。进一步研究`vtable`后，我们看到其中某个方法会调用`RegSetValueExW`。
图18. `CmdAgent.exe`会调用更加有趣的一些方法（设置注册表键值）
图19. `CmdAgent.exe` `ISvcRegistryAccess`方法以`SYSTEM`权限设置注册表键值
显然，如果我们调用该方法，就能以`SYSTEM`权限执行注册表写入操作，因为我没有在代码中找到对任何身份模拟API的调用。我们修改了自己的COM客户端代码，获取`IServiceProvider`，解析`ISvcRegistryAccess`，然后调用这个“注册表写入”方法。如果我们观察通过调用`GetRegInterface`来获取`regInterface`的过程，就可以看到`CmdAgent.exe`实际上只创建了一个只读的注册表键值句柄，因此尝试调用这个“写注册表”方法就会出现`ACCESS_DENIED`问题。幸运的是，我发现了`ISvcRegKey`
vtable中由另一个方法，通过传递一些额外参数，可以将我们的注册表句柄变成“可写”状态。
在原有代码中调用该方法，同时传入适当参数，这样就能获取“可写的”`ISvcRegistryAccess`。
图20. 修改COM客户端以获取可写的注册表接口
整合在一起，我们最终得到了如下代码，能够以`SYSTEM`权限执行注册表写入操作。
图21. 最终的COM客户端代码
图22. 成功覆盖高权限注册表键值
## 0x07 提升至SYSTEM权限
稍微总结下，我们运行沙箱化应用，对Comodo签名的程序执行Process
Hollowing操作（以便绕过CmdAgent的签名校验机制），然后通过该程序运行我们开发的COM代码，从我们“沙箱化的”进程中以`SYSTEM`权限执行注册表写入操作。如果想通过这种方法实现权限提升，典型的方法就是劫持已有的服务，这里我们可以选择`CmdAgent.exe`。通过替换注册表`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\CmdAgent`对应的`ImagePath`值，我们就可以将`CmdAgent`服务替换成我们自己的程序，然后以`SYSTEM`权限运行。
图23. `CmdAgent.exe`服务
然而，如果我们想要第一时间获得`SYSTEM`权限，我们需要重启`CmdAgent`服务（不然就要等待下次重启）。幸运的是，我们有办法能够完成该任务，我找到了让`CmdAgent`崩溃的方法，这样服务就会自动重启，最终启动我们的程序。想让`CmdAgent`崩溃非常简单，该进程会对外提供结构化数据的一个[Section
Object](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views?source=post_page---------------------------)（内存区对象），而`EVERYONE`具备该对象的写入权限：
图24. `CmdAgent.exe` `Section Object`公开可写的对象数据（`SharedMemoryDictionary`）
`CmdAgent`将这个缓冲区当成一个`SharedMemoryDictionary`，这是共享内存中对外公开的一个类对象。我们可以在对象成员中写入错误的大小值，这样当`CmdAgent`尝试读取这个`SharedMemoryDictionary`时（`CmdAgent`经常会执行该操作），就会出现越界读取问题，最终导致`CmdAgent`崩溃。当服务恢复时，就会执行我们设置的程序，最终让我们提升至`SYSTEM`权限。
图25. 成功提升至`SYSTEM`权限
大家可以观看[此处视频](https://youtu.be/rHKRiSy8FoA)了解攻击过程，点击[此处](https://github.com/tenable/poc/tree/master/Comodo/Comodo%20Antivirus?source=post_page---------------------------)下载源代码。