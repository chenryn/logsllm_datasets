59
0
3
23
0
0
3
0
13
0
88
12
0
0
67
19
0
FN Accuracy Cnt
90.03% 246
35
98.01% 189
6
1
99.57% 168
99.62% 173
1
99.72% 265
1
92.98% 208
23
11
91.97%
83
95.92%
6
86
6
97.45% 186
TP
202
180
149
165
255
155
76
53
171
Binary
TN FP
0
37
0
2
15
0
0
1
0
7
2
45
5
0
2
26
12
0
FN Accuracy
97.15%
7
96.30%
7
4
97.62%
95.95%
7
98.87%
3
96.15%
6
2
97.59%
91.86%
5
3
98.39%
Table 3: Accuracy of patch presence test
settings: -Os and -O2. We also need to account for patch
evolution.
In the end, we compiled a total of 2,488
reference kernels all from Qualcomm repos with 11,093
signatures generated in the end (note one compilation
allows multiple signatures to be generated).
5.2 Accuracy
In this section, we will describe the accuracy of patch
presence test against
targets
presented in §4.
First of all, for kernels that are in the repository form,
since we have conducted both automated and manual
analysis (for the few subtle cases) exhaustively on every
CVE and every branch, we treat the results as ground
truth.
three types of kernel
For kernels that are in source snapshots or binary
ROMs, we sample a number of them to evaluate the
accuracy of the patch presence test at both the source
and binary level. Speciﬁcally, we picked 9 kernels, each
from a different phone model covering 4 different
brands. These 9 kernels are available in both source
snapshot and binary, which allows us to verify the
results of binary patch presence test using the
corresponding source code. The results are summarized
in Table 3. Generally, our solution works well for both
source and binary targets with an average accuracy of
more than 96%. To give more details, we also analyzed
the sources of inaccuracies.
In the case of source snapshot
targets, since we
consider a function patched only when a strict string
match of the full function is found, it leads to no false
positives but some false negatives are observed, which
are due to customization of the patched functions. The
results suggest that Huawei and Samsung have more
customization than others. This is consistent with the
fact that Samsung and Huawei are the top 2 players in
the Android market and have the strongest product
differentiation.
In the case of binary targets, the inaccuracies come
from 1) Customization of the patched function. 2) Even
when source code is the same, the binaries may look
different due to vendor customization of compiler’s
conﬁg options, which we do not have complete access
to (other than those from the periodic source snapshots).
Interestingly, we can see generally comparable and even
lower
false negative rates compared to the source
snapshot targets. This is because the source-level patch
presence test is based on strict string matching of the
whole patched function (and will fail to match any
vendor customized functions). On the other hand,
against
FIBER by design has
customization
only
characterize a small (but key) portion of the patched
function.
signatures
generated
some
resistance
as
the
Besides, the number of CVEs and their corresponding
patches that we can track for binary kernel targets is
smaller. One common reason is that many vulnerable
drivers are included in the source snapshot but are not
compiled into the binaries. Other technical reasons are:
1) FIBER was not able to generate signatures for certain
cases. 2) Generation/Matching of signatures costs too
much time (over a threshold of 2 hours, which is
determined by the distribution of time consuming we
observed). These cases attribute to about 10% of the
CVEs and were excluded from the binary patch
presence test.
Overall, the patch presence test accuracy result gives
us conﬁdence in the measurement study in §5.4. We also
note that patch presence test in upstream source repos is
independently done through patch locator as described in
§4.1.
5.3 Patch
kernels
in Upstream
Propagation
In this section, we focus on analyzing the patch
propagation in the upstream kernel repos using the patch
locator described in §4.1. With the exact time and date
of individual commits, we are able to track the patch
3656    30th USENIX Security Symposium
USENIX Association
Figure 4: Upstream patch delays
(Linux CVEs)
Figure 5: Linux mainline to LTS
(Linux CVEs)
Figure 6: LTS to Android common
(Linux CVEs)
Figure 7: Android to Qualcomm
mainline (Linux CVEs)
Figure 8: Qualcomm mainline to
stable (Linux CVEs)
Figure 9: Qualcomm mainline to
stable (Qualcomm CVEs)
propagation precisely and make a number of interesting
observations
and Qualcomm
vulnerabilities.
both Linux
about
Figure 4 gives an overview of the cumulative patch
delays observed at each layer with respect to Linux
mainline (here all included CVEs affect Linux). As we
can see, Linux internally (mainline ! LTS) already has
a substantial delay, with 20% of the patches being 100
days or longer. On the other hand, Google does a good
job in tracking Linux vulnerabilities, as the line
representing the Android common’s patch delays is
closely aligned with that of Linux LTS. Qualcomm’s
mainline is noticeably slower in picking up patches
from its upstream (note the log-scale nature of the
X-axis).
Finally, we ﬁnd that Qualcomm can be
considered the bottleneck as it is extremely slow in
propagating most of its patches from mainline to stable
branches.
the
Qualcomm-internal propagation delay is at least 2 to 3
months. From the end-to-end point of view, the majority
of patches take over 100 days for them to propagate
from Linux mainline all the way to Qualcomm stable.
About 15% of the patches took 300 or more.
about half of
cases,
For
the
If we break the result down further layer by layer,
Figure 5 shows the delay incurred in Linux internally
(mainline ! LTS) across all four major kernel versions
3.18, 4.4, 4.9 and 4.14. We see 5% to 25% of patches
experience a delay of 100 days or longer (with 3.18
being the worst).
In extreme cases, after patched in
Linux mainline, CVE-2017-15868 is not patched in
Linux LTS 3.18 until 954 days later. Not too long ago, a
critical vulnerability CVE-2019-2215 was not patched
in Linux LTS 4.4 until about 600 days later, ultimately
leaving most downstream OEM kernels such as Pixel2
and Samsung S8/S9 vulnerable [25].
The case for Linux LTS ! Android common
(Figure 6) is different and interesting. The delays are
much smaller where more than half of the CVEs are
patched in Android common the same day as Linux LTS
or earlier. When we look into the reason, we ﬁnd that
the maintainer of Linux LTS, Greg Kroah-Hartman, also
helps maintain the Android common repository (note
the large fraction of 0-day delay cases). After merging
commits from mainline to LTS, he usually merges
commits from LTS to Android common repository right
away. The other thing worth noting is that about 10% –
20% of the patches are applied in Android common ﬁrst
and then appear in LTS, exhibiting negative delays. This
is because Google has been diligently scouting for
important
sometimes
picking up patches from Linux mainline directly and
bypassing the slow Linux LTS. Google is capable of
security patches everywhere,
USENIX Association
30th USENIX Security Symposium    3657
doing this because (1) they hire many engineers who are
also Linux maintainers, and (2) Google offers a bug
bounty program and thus many Linux bugs are reported
to Google ﬁrst who typically tries to get Linux mainline
to patch ﬁrst and then port it immediately (according to
the feedback we received from Google).
The case for Android common ! Qualcomm
mainline (shown in Figure 7) is similar in the sense that
also about 5% – 20% of the patches are observed in
Qualcomm ﬁrst and then Android common. Similar to
Google, Qualcomm also independently ports patches
from Linux mainline. Interestingly, this means that even
after Google picked up patches from Linux mainline
directly, there are additional mainline patches missed by
Google which are picked up by Qualcomm directly.
The last step in the pipeline is about the Qualcomm
mainline branch (e.g., 3.18) to its corresponding stable.
As shown in Figure 8, we pick three representative
stable branches that correspond to the Android devices
and OS versions we will analyze (recall that stable
branches are speciﬁc to chipsets and Android OS
versions). We note that other branches yield similar
results (except those ones with insufﬁcient history). We
excluded all 4.14 stable branches because they are too
new to have sufﬁcient history. Overall, we can see that
the delay is very substantial compared to the earlier
steps. For 4.4, about 80% of the patches are delayed for
100 days or longer and 20% delayed for 200 days or
longer. 4.9 is somewhat better than 4.4 with 80% of the
patches delayed for 60 days or longer. Both are far
worse than the internal delays in Linux (Figure 5).
Interestingly, the 3.18 stable branch shows a comparable
delay to 4.4 (and even slightly better) — a sharp
contrast with the previous step that the Qualcomm 3.18
mainline being the slowest among all other mainlines
(shown in Figure 7). Upon closer inspection, this is due
to an older patching practice for the Qualcomm 3.18
repo which we will discuss in detail in §6.
for vulnerabilities that originate in
the internal propagation delays
Linux, we pinpoint
within Qualcomm and Linux (i.e., mainline
to
stable/LTS) to be clear bottlenecks. In addition, we ﬁnd
that newer kernel versions (from 3.18 to 4.14) generally
correspond to more timely patch propagation across all
these layers. The improvement however appears to have
stabilized since 4.9.
In summary,
Finally, we also inspect vulnerabilities that originate
in Qualcomm — they constitute more than 60% of the
CVEs as shown in Table 2. Surprisingly, as shown in
Figure 9,
the patch delays seem abnormally small
compared to the Linux vulnerabilities (Figure 8). We
suspect this is because Qualcomm is much more aware
of the vulnerabilities speciﬁc to its own code,
i.e.,
triaged and analyzed internally, and thus can react faster.
We will provide more evidence to support this in §6.
5.4 Patch propagation to Android OEM
phones
In this section, we follow the patch propagation pipeline
to OEM vendors using a variety of Android devices as
described in §5.1. We are primarily interested in
measuring the patch delay and understanding generally
whether OEM delays represent the bottleneck in the
end-to-end patch propagation.
these
Android devices are produced and maintained by
different companies, marketed as high-end or low-end
phones, and released in diverse geographic regions. We
therefore also examine how these factors may inﬂuence
the patching behavior. For most phones, we are able to
retrieve a continuous stream of ﬁrmware images (one
image per month according to build dates). Thus we can
pinpoint when a patch is applied.
In addition,
As we can see,
Figure 10 shows the patch propagation delay from
Qualcomm stable to OEM phones (aggregated over all
the phones). For every OEM phone, we pick one or
more corresponding Qualcomm stable branches as
upstream with the matching chipset and Android OS
versions (note a phone may upgrade its Android OS
version during its lifetime).
for
Qualcomm-speciﬁc vulnerabilities (in dotted lines),
OEM phones fall behind Qualcomm stable signiﬁcantly
— the delay is 100 days or more for 70 - 90% of CVEs.
On the other hand, for vulnerabilities that originated in
Linux, we ﬁnd that the delays are noticeably smaller.
This is due to Linux vulnerabilities being patched much
in upstream (Linux and Google’s Android
earlier
common)
not
necessarily need to wait for patches to propagate to
Qualcomm stable. For example, they could be notiﬁed
by Google earlier.
therefore OEM vendors
and
do
Next, we also plot the end-to-end delay in Figure 11
by adding up delays in each propagation layer in the
whole ecosystem. Here the earliest patch is either Linux
mainline or Qualcomm, depending on whether the
vulnerability is originated from Linux or Qualcomm.
Generally, both cases incur signiﬁcant delays with
Linux vulnerabilities being generally worse. This is
understandable because a Linux patch naturally has a
longer propagation chain compared to a Qualcomm
patch. As we can see, more than half of the Linux CVEs
are delayed for 200 days or more, and 10% to 30% of
CVEs are delayed for more than a year. This is an
unacceptably long delay that
experienced
hackers to craft exploits against unpatched OEM
devices. CVE-2019-2215 is one such example [24].
allows
Next, we analyze a number of factors that might inﬂu-
ence the patch delays in OEM phones.
• Vulnerability severity.
Intuitively, more severe
3658    30th USENIX Security Symposium
USENIX Association
Figure 10: Delay between Qualcomm
stable and OEM phones
Figure 11: End-to-end delay between
earliest patch and OEM phones
Figure 12: End-to-end delay between
earliest patch and OEM phones
Figure 13: Different OEM vendor
comparison
Figure 14: High/low-end phone
comparison
Figure 15: Patch delays from Linux
mainline to LTS (by severity)
the result
vulnerabilities should be patched sooner rather than
later by OEM vendors (or upstream). However, as
shown in Figure 12,
is not supportive.
Speciﬁcally, we plot the distribution of end-to-end patch
propagation delays by vulnerability severity levels.
In
§6, we will offer a much more detailed explanation of
the phenomenon (after reaching out to Google). Note
that there are only 33 critical CVEs from the security
bulletin, and 30 of them are very old (originally patched
before 2017) not applicable to many of the new OEM
devices. Thus we combine them with high severity
CVEs.
• Name brand. To do a fair comparison, we sample 8
phones from 8 ﬁrst-tier companies which are all
high-end and released in 2017: Google Pixel2, Samsung
S8, Xiaomi Mi 6, Huawei Mate 10, Oneplus 5, Oppo
R11s, SONY Xperia XZ1 and LG V30.
Their
corresponding kernel versions are also the same —
4.4.y. We only compare the CVEs that affected all target
phones and ignore the CVEs patched beforehand. As
seen in Figure 13, the results show that Google Pixel 2
and SONY clearly did the best.
In contrast, Xiaomi,
Oppo, and LG are the slowest.
• High-end vs. Low-end. This may be an expected
result as companies tend to devote more resources to
their ﬂagship phones. Figure 14 shows the comparison
between high-end phones (Mi 8, Galaxy S9) and
low-end phones (Mi8 Lite, Galaxy A9 star) in Samsung
and Xiaomi.
• Geographic locations and carriers. We did a small
sample analysis of Samsung and Huawei phones, and
the results show that the same kind of phone (only with
minor adjustments, e.g., for local carriers) in different
regions got patched at the same time in most cases, with
about only 10 percent of the cases being slightly
different.
• Time after release. Android devices are known to
have a relatively short support lifetime, e.g., Google
phones now offer mostly 3 years of
security
updates [22].
In practice, most phones (especially
high-end ones) do indeed enjoy at least 2 years of
support. A major exception is Xiaomi’s Redmi 4, a
popular low-end phone popular in China and India.
It
was released in 2017 and still had some updates (i.e.,
new ﬁrmware images) until March 2019. However,
surprisingly
security
vulnerabilities since early 2018 (less than a year).