H和 B，B2，"、B,是字面值，即原子或原子的否定形式。但H不能是否定形式。
H:-B&B2&.…·&Bn
比
口
图12-12使用---
个断言的值
个关系来表示-
994
第12章
pP
命
---
## Page 601
算过程将会和到达定值本身的计算集成在一起。因此，图12-13 中给出的基本块b;是很典型的。
在基本块层次上)考虑问题是有道理的。也就是说，从--个基本块构造它的 gen 和 bull 集合的计
例12.13
有可能的 IDB 事实。
出了一些关于 edge 的事实，比如 edge(1，2），但是所有的 path 事实都是通过规则摧导出来的。
EDB。比如，在例子12.12中，edge是一-个 EDB 断言，path是一个IDB 断言。回忆--下，我们给
的真值事实要么通过一个关系或表给出，要么根据断言的含义给出(比如一个比较断言的情况)。
12.3.3 内涵断言和外延断言 
X=1、Y=2 和Z=4 推出规则头 path(1，4)。也就是说，从结点1到结点4 有一条路径。
个子目标都已经推导出来，已知它们为真，所以可以推出规则头：path(1，3)。然后，使用替换方法
行替换，我们可以得到这个规则的实例 path(1，3）：－path(1，2)&path(2，3）。因为规则体中的两
2)为真，所以可以推导出 path(1，2）。
以使用第一个规则进行三次不同的替换，推断出 path(1,2)、path(2,3)和 path(3，4)。例如，
(α，b)也成立（即有--条从α到b的路径)。第二个规则是说如果有一-条从某个结点X到某个结
把变量Y替换为一个常量b，并且edge（α，b)为真（即有一条从结点α到结点 b 的边），那么 path
路径。定义路径的规则是：
是说，断言 edge(X, Y)表示"有一条从结点 X到 Y的边"；断言 pauth( X， Y)表示从 X到 Y有--条
例12.12
断言被表示成规则，而数据流问题的解决方法就是根据这些规则和给定的EDB 事实中推导出所
个或多个规则头中的断言必然是一个IDB 断言。出现在规则体中的断言可以是IDB，也可以是
断言参数的常量。
“传递封闭性”。请注意，任何路径都可以通过选取路径上的边并不断应用传递封闭性规则得到
根据这三个关于 path 的事实，我们可以多次使用第二个规则。如果按照X=1、Z=2 和Y=3
X=1和Y=2 进行替换可以得到第---个规则的实例 path（1，2）:-edge（1，2）。因为 edge（1
、Z的路径，并且还有一条路径从Z到结点Y，那么存在一条从X到Y的路径。这个规则表示
过程间分析
当 Datalog 程序用于表示数据流算法时，其中的 EDB 断言是根据流图本身计算得到的。IDB
一-个断言要么是IDB，要么是EDB，且只能是其中之-一。这个规定的结果是，任何出现在-
2）IDB 断言，或者说内涵数据库（intensional database）断言，只能通过规则定义。
1）EDB 断言，或者说外延数据库（extensional database）断言，是事先定义的断言。也就是说，它们
比如，假设下列事实(基础原子)为真：edge(1,2）、edge(2,3)和edge(3,4)。那么，我们可
按照Datalog 程序的惯例，我们把断言分成两类：
第-一个规则是说一条边就是一条路径。也就是说，只要我们把变量X替换为一个常量α，
2) path(X, Y) :- path(X, Z) & path(Z, Y)
2）所有的其他元素以小写字符或其他符号（比如数字)开头。这些元素包括断言和用作
1）变量以大写字符开头。
我们将在 Dalalog 程序中使用如下编码规则：
让我们考虑可以如何在 Datalog 中表示到达定值问题。首先，在语句层次上（而不是
--个 Datalog 程序的简单例子是给定--个图的(有向)边，计算这个图的路径。也就
Datalog的编码规则
585
□
进
按
---
## Page 602
而 T可以是任何合法的类型表达式。
真。同样，X可以是具有左值的任意表达式，
式，比如*p。
--个变量，也可以是一个具有左值的简单表达
的第 N个语句的左部为X。请注意，X可以是
断言：
例12.14
EDB 断言，而这些断言本身可以从流图和符号表中获得。
有适当类型的变量中，那么我们可以从符号表中获取类型信息，从而使用一个较小的关系 df。
向任何地方，那么可以从流图中得到 def断言。如果我们希望把一个指针所指向的范围限定在具
并且 B是 D的一个后继。
d
语
则对应于该表示方法中的概念 gen。
(即紧跟在这个语句之后的点）。我们前面给出了到达定值问题的集合理论表示方法，而这个规
M个语
也就是说，控制流可以从 B的点 N到达C的点0。比如，假设b2 是图12-13 中基本块b，的前驱，
可以是任何具有 p所指类型的变量。
Y)对所有可能在这个点上被指针p指向的变量Y都为真。现在我们将假设Y
EDB断言：
n 是0到基本块6内的语句数量之间的--个整数。我们的表示方法需要两个
个定值在第i点上出现，而在0点上没有定值出现。
请注意，如果一个基本块内有n个语句，那么我们用编号1,2，…，n来标记块内的程序点。第
值
一种可选的方法是把 def 变成一个 IDB 断言，并通过规则来定义它。这些规则将使用更基本
例12.13 中的 EDB 断言 succ 显然可以从流图中获得。如果我们保守地估计一个指针可能指
句的对变量X的定值到达基本块B 中的点 N的条件是
-方法是100%肯定地对其中的变量重新定值。详细地说，规则2说明来自基本块C中的第 M个
2） succ(B，N，C)为真当且仅当在流图中基本块C是基本块B的后继，且B具有 N个语句。
。比如，在图 12-13 中，def(b，1,x)为真，def(b，3，x)为真且 def(b，2，
1）assign（B，N，X)为真当且仅当基本块 B
程序中的一个点可以表示为--个二元组(b，n)，其中b是一个基本块，面
586
然后，我们就可以写出 def 的规则，使得 def 成为--个 IDB 断言。图12-15 是对图 12-14 的--
2）如果X 的类型为 T,那么 type(X，T)为
规则2表示除非一个定值被某个语句杀死，否则它可以穿越这个语句。而杀死一个定值的唯
这个 Datalog 程序有一个 IDB 断言 rd(B,N,C，M，X)。这个断言为真当且仅当在基本块C 上的第
最
1）它到达了前---个结点，即B中的点N－1。
规则1 说明，如果基本块 B的第 N个语句对X定值，那么 X 的这个定值到达B 的第 N个点
1） def(B，N，X)为真当且仅当基本块 B 中的第 N个语句可以对变量X定
最后，规则3表示了流图的控制流。它说基本块C 中第 M个语句中对X的定值到达基本块
句中对变量X的定值到达了基本块 B 的点 N。定义断言 rd 的规则在图 12-14 中显示。
假设我们引人两个新的EDB
rd(B,N,C, M, X)
rd(B,0,C, M, X)
rd(B,N, B,N, X)
图12-14 断言rd的规则集合
：
X≠Y
def(B,N, X)
图12-13-个语
句中包含指针
的基本块
第12章
口
---
## Page 603
则2 令我们把两个长度为1的路径连接到一起生成一个长度为2的路径。也就是说，在第二轮之
后，我们知道 path(α，b)成立当且仅当有-条从α到b的边。
没有 path 的事实。但是规则1 使得所有的 edge 事实都变成了 path 事实。也就是说，在第一轮过
存了该图的所有边，而 path 的关系为空。第一轮的时候，规则2 没有产生任何结果，因为此时还
中的算法。
IDB 断言，我们将计算R,。执行图 12-16
果p是一个EDB 断言，那么 R,就是该
令 R,为使该断言为真的事实关系。
EDB
求值。
章中讨论的迭代算法类似。
得到的IDB关系就形成了程序的输出。这个过程将在下面的算法中正式给出。这个算法和第
这些规则，根据这些规则不断推导出新的事实。当推导过程收敛时，就完成了程序的运行。运行
12. 3. 4Datalog 程序的执行
似地，我们可以对其他类型为整数或可转变为整数的变量推导出同样的结果。
允许我们推导出 def(b，1，x)和 def(b，3，x)。
EDB 事实。第二个语句通过p间接赋值，因此
例12.16
算法12.1
第
也对x赋值，因此assign（b;，3，x）也是一个
块
进行推导。让我们重新考虑图12-13 中的基本
指类型的任何变量，那么这个语句也可能对X定值。其他类型的赋值语句需要其他的 def规则。
么这个语句就对X定值。规则5 说明，如果基本块B的第N个语句对*P 赋值，且X是具有P所
个扩展，它增加了两个 def的可能规则。规则4 说明，如果基本块 B的第 N个语句对X赋值，那
医
且x和y都是整数。那么我们可以使用规则5，
数。开始时假设IDB关系为空（即对于所有可能的参数，各个 IDB 断言为假）。然后重复应用
三个EDB 事实是 assign(b，2，*p)。规则4
在第二轮中，规则1 没有生成新的 path 事实，因为 EDB 关系 edge 没有改变。但是，现在规
言给出的所有事实。如果是一个
每一组 Datalog 规则都定义了它的 IDB 断言的关系。这些关系是程序中的 EDB 断言关系表的
推导得到 def(b,,2,x)和def(b,2,y)。类
B=b，N=2，P=p，T=int，且X等于x或
assign(b，1，x）出现在EDB 中。第三个语句
b1。第一个语句把一个值赋给变量x，因此事
现在举例说明如何使用图 12-15 中的规则
过程间分析
方法：对于程序中的每个断言
输出：每个IDB 断言的事实集合
断言的事实集合。
输
假设p的类型是指向整数的指针（*int),
入：
例12.12 中的程序计算—个图中的路径。应用算法 12.15 时，最初 EDB 断言 edge 保
个 Dataiog 程序和各个
Datalog 程序的简单
d
while（改变了任何 Rp的值）{
for（p的每个断言IDB）
（其企键方族得一个为入到民中。
对于每个替换方法，使用当前的 R,来确定EDB 和 IDB断言
考虑所有可能的对各个规则中的变量进行常量
的真假值，确定是否某个规则体的所有子目标都为真；
二
图 12-16Datalog 程序的求值
rd(B,0,C, M, X)
rd(B, N,C, M, X)
rd(B,N, B, N, X)
图 12-15断言 rd和 def 的规则
def(B, N, X)
def(B, N, X)
的规贝
def(B,N.X)
assign(B, N, X)
587
口
口
---
## Page 604
形式。
为对应于断言p的“新"事实的关系。
个 EDB 断言，那么 R,就是该断言对应的事实
示使此断言为真的事实的关系。如果P是
的事实集合。
算法12.18
施，即根据规则连接起来的两条路径中至少有
两个规则合起来保证了上面描述的思想得以实
因此它变成了两个不同的规则。在每个规则中，path 在规则体中的某次出现被替换为 neoPath。这
规则体中没有IDB子目标，因此除了规则头之外没有任何改变。但是规则2中有两个IDB子目标,
该程序的规则的增量形式在图12-17中给出。规则1的
例12.17再次考虑例子 12. 12 中的 Datalog 程序。
前,我们将先给出一个例子。
轮计算。
于所有的规则，我们把规则头的断言h 替换为 newH。得到的这些规则被称为具有增量式形主
集
规则中的每一个都是通过把原来规则体中的某一个 IDB 断言q替换为 newQ 而得到的。最后，1
的p事实成立。每一个在其子目标中包含了-个或多个 IDB 的规则都被替换为-组规则。这组