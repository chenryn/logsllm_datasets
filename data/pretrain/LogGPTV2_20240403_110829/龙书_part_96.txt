时值存放回内存的话，计算该表达式需要多少个寄存器。这些数有时被称为Ershou数（Ershov
8. 10.1 Ershov 数
器来对一个表达式求值的情况下，该方案允许我们为表达式生成最优的代码。
基本块生成代码就已经足够了，那么我们就可以最佳地选择寄存器。在下面的算法中，我们引人
结
T
8. 10
现在我们可以计算对应于t3=é＊t2 的结点的标号。它的子结点的标号是1和2，因此根
点的标号加上1，也就是2。对应于t2=c+α
：了标号。应用规则3，该结点的标号是它的子
一个表达式树(即一个表达式的语法树)的结点添加数字标号的方案。在使用固定个数的寄存
代码生成
假设在我们的机器模型中，所有的运算分量都必须在寄存器中，且寄存器可以同时用于存放
输入：-个带有标号的表达式树，其中的每个运算分量只出现--次(即没有公共子表达式)。
②如果两个子结点的标号相同，那么它的标号就是子结点的标号值加一。
1）所有叶子结点的标号为1。
一开始，我们给一个表达式树的每个结点各赋予一-个数值。该数表示如果我们不把任何临
当--个基本块仅包含单一的表达式求值时，或者我们认为以逐次处理各个表达式的方式为
2）
= t1+t3
从带标号的表达式树生成代码
=c+
如果两个子结点的标号不同，那么选择较大的标号。
具有两个子结点的内部结点的标号按照如下方式确定：
只有一个子结点的内部结点的标号和其子结点的标号相同。
表达式的优化代码的生成
a
根据一个带标号的表达式树生成代码。
一
①1
图8-23
一个用Ershov数标号的树
O. 
?
@
 @1
365
应
回
口
---
## Page 382
算法8.26
载到寄存器中。下面是一个经过修改的代码生成算法，它考虑了寄存器数量的限制。
人一些保存指令，把某些子树的值溢出到内存中，然后在必要的时候生成加载指令把那些值再加
8.10.3寄存器数量不足时的表达式求值
并把结果放在 R2中。图8-24 中显示了生成的全部指令序列。
就完整地生成了根结点的右子结点的代码。算法继续以1为基线生成根结点的左子结点的代码，
现在我们加上指令
是一个标号为e 的叶子结点。因为b=2，正确的指令是
接下来，我们为根结点的右子结点的左子结点生成代码。这
子结点的规则，我们为标号t2的结点生成下列代码：
线生成右子结点的代码。应用针对具有相同标号子结点和叶
子结点，而小子结点是其左子结点。这样，我们首先以2为基
标号相同，我们首先以2为基线生成右子结点的代码。
R中，并且只有寄存器R、R2、R 被使用。根结点的基线是b=1。因为根结点的两个子结点的
例8.25
结点”。使用基线b，通过下列步骤为这个内部结点生成代码：
结点的标号为k，我们称之为“大子结点”；而另一个子结点的标号为某个mr的内部结点，我们要分别处
次（即没有公共子表达式)。
子结点，代码如下：
输出：计算根结点对应的值并将其存放到一个寄存器中的最优的机器指令序列。代码使用
代码生成
因为根结点的大子结点的标号为2，因此寄存器是够用的。我们把算法8.24 应用到这个子
4）按照如下方式为小子结点生成代码。如果小子结点的标号大于或等于r，选取基线=1。
方法：令基线b=1，从根结点开始应用下面的递归算法。对于标号为r或者更小的结点 N,
6）如果大子结点是N的右子结点，生成指令“OP R,，R,，R,-1"。如果大子结点是N的左子
3）生成机器指令“STt，R”"，其中t是一个用于存放中间结果的临时变量。这个变量用于
输入：-个带有标号的表达式树和寄存器的数量r≥2。表达式树的每个运算分量只出现-
ADD R2，R2,R1
LD
ST
5）
2）令基线=1，递归地为大子结点生成代码。这个求值的结果将存放在寄存器R,中。
我们用指
R1，t3
t3，R2
生成指令“LD R,-1，t”。
一
R2，b
令
2
口
图8-25 图8-23中的树的
最优的三寄存器代码
（只使用两个寄存器）
D
6
6
DmM
2
R2，d
R2,R1
3
367
口
---
## Page 384
这里，T 和 T2 分别是 E和 E2的语法树。
E=E oP E2。我们可以通过查看 E的语法树 T来理解这句话的含义。
优程序的子问题也以类似的方式解决。
程序由E,和E2的最优程序以某种顺序组合而成，然后是对+求值的代码。为E,和E2生成最
成最优代码的子问题。作为--个简单的例子，考虑--个形如E+E²的表达式 E。E的一个最优
8.11.1连续求值
-一个成本单位。然而，即使每个指令具有不同的代价值，人们也可以很容易地修改这个算法来处
可以应用基于动态规划的算法为这个机器生成代码。为简单起见，我们假设每个指令的代价是
适合使用这个过程的机器要满足以下假设：所有的计算都在寄存器中完成，而指令中包含的运算
8.11使用动态规划的代码生成
i和x)的运算符。你将如何修改给表达式树添加标号的方案，以便为这种机器模型生成最优的
或更多的子结点的表达式树。
8. 10.48.10节的练习
理这种情况。
个表达式树生成最优代码。动态规划算法可以被应用到具有复杂指令集的多种计算机上。
符要么作用于两个寄存器，要么作用于一个寄存器和一个内存位置。
你将如何修改为表达式树添加标号的方案，使得它可以为这种机器模型生成最优代码？
法的结果需要两个连续的寄存器，而当我们计算α/b时，a的值必须存放在两个连续的寄存器中。
式树添加标号的方案，使得它可以为这种机器模型生成最优代码？
代码？
基于动态规划原理的算法可以应用到更多类型的机器上，使得人们可以在线性时间内为--
8.10 节中的算法8.26 根据--个表达式树生成最优代码所需的时间是树的大小的线性函数。
！练习 8.10.5：类似于 a[i］=×的对数组元素的赋值看起来像--个具有三个运算分量（α、
368
！练习8.10.7：某些机器要求使用两个寄存器来存放某些单精度值。假设单寄存器值的乘
！练习 8.10.6：最初的Ershov 数技术所应用的机器模型和书中的模型有所不同。该模型允
！练习8.10.4：将Ershov 数的计算方法一般化，使之能够处理其中某些内部结点具有三个
练习8.10.3：使用三个寄存器为练习8.10.1中的各个表达式生成最优的代码。
练习8.10.2：使用两个寄存器为练习8.10.1中的各个表达式生成最优的代码。
((1*+∞-)/(b*-q))*(d+D-)(ε
2)α+b*(c*(d+e))
1) a/(b+c) -d *(e+f) 
练习8.10.1：计算下列表达式的Ershov 数。
T
第8章
---
## Page 385
7
的根结点的代价向量中的最小值给出了对T求值所需的最小代价。
正比关系。在每个结点上为各个i值保存用于获得最优代价C[订所使用的指令可以带来方便。
上和模板E 相关的指令的代价。C[订的值就是所有这些可能的顺序所对应的代价值中的最小者
点所代表的运算分量进行求值时所需要的代价。对于E的寄存器运算分量，考虑对T的相应子
处的输人树相匹配的各个模板E。只要检查n的相应后代的代价向量，就可以确定对E的叶子结
虑的情况。
不同组合，就可以生成S的最优程序。这是由连续求值的性质来确保的。这个限制减少了需要未
子树S的值计算出来并保存到内存的最优代价。只需要考虑S的根结点的各子树的最优程序白
存运算，也包括了计算S的根结点处的运算符所需要的代价。代价向量的第0个元素存放的是扎
程中，首先为那些需要把结果值保存到内存的子树生成代码。
个寄存器中的最优代价。
8
甲
表达式树进行最优求值时，没有必要进行这种类型的摆动。
然
这
系结构在乘法和除法中使用寄存器对。对于这样的机器，我们可以给出一些表达式树的例子。
我们都可以找到一个等价的程序 P’，使得
根结点。无论在哪种情况下，作为非连续计算的一个例子，程序P可能先计算T，的一部分并把
的T的子树。然后，它再计算T的其余部分，计算的顺序可以是T，T，根结点，或者T2，T
求值并放到寄存器中的各种可能的顺序。在每个顺序中，第一个对应于某个寄存器运算分量
.11.2动态规划的算法
整棵树T的代价向量可以用自底向上的方式计算。计算所需时间和T中结点的个数呈线忆
规划算法为T生成一个最优程序。