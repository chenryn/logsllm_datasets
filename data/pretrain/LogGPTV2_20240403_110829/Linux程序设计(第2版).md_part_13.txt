esac
echo *Answer yes or no*
done
1
2）下面是它的主程序部分，如下所示：
echo *Original parameters are s**
1$.ou"xose
thef
ecbo *Hi $1, nice name*
else
PUT laaN. 0o
fi
exit 0
加入jaVa编程群：524621833
---
## Page 61
42Linux程序设计
这个脚本程序的典型输出如下所示：
_ /my_name sh Riek Nei1
Is your name Rick ?
$
操作注释：
随着这个脚本程序的执行，函数yes_or_no被定义，但先不会执行。在主程序部分的if语句里，
脚本程序执行到函数yes_or_no，先把S1替换为最初脚本程序的第一个参数Rick，再把那一行上
的剩余内容做为参数传递给这个函数。这些参数被保存在S1、S2等位置参数里，函数使用了它
们并向调用者返回了一个值。if语句结构再根据这个返回值去执行相应的子句：
正如我们已经看到的，shell有着丰富的控制结构和条件语句。我们下面来学习一些内建在
shell中的命令，然后就要在见不着编译器的情况下解决一个实际的程序设计问题了！
2.4.5命令
令和我们前面提到的“内建”命令。“内建”命令是在shell内部实现的，不能做为外部程序被调
用，大部分内部命令都是POSIX技术规范的组成部分，并且经常会提供有独立的对应程序。命
令是内部的还是外部的一般并没有多大的重要性，只是内部命令执行起来效率更高。
既然提到了命令的再实现问题，我想大家可能有兴趣了解UNIX怎样把一个程序用
做几个命令或者不同的文件。用“ls-1”命令查看一下mv、cp和ln命令吧，它们在许多
系统上实际都是同一个文件，只不过用ln（link，链接）命令创建了几个不同的名字而
已：当这个命令被调用的时候，它会先检查自己的第一个参数一在UNIX环境下这将
是该命令本身的名字，然后再决定将要采取什么样的动作。
在这里，我们只对那些会在将要编写的脚本程序里用到的主要命令进行介绍，不分内部外
部，做为一名UNIX使用者，读者肯定还知道许多其他能够用在命令提示符处的合法命令。水远
记住：加上我们在这里介绍的内建命令，你可以在脚本程序里使用其中的任何一个。
1.break命令
我们用这条命令在控制条件尚未满足的情况下从封闭的for、whil或until循环里中途退出。
你可以给break命令额外加上一个数值参数，它表示准备退出的循环嵌套层数。这会增加脚本程
序的阅读难度，因此我们不建议读者使用它。在默认的情况下，它只退出一个循环层。
#!/bin/sh
rm-rf fred
echo>fred
nkdir fred3
echo> fred2
echo > tre64
加入jaVa编程群：524621833
---
## Page 62
第2章shell程序设计
43
for file in fred*
fo
if [-d *sfile* ];then
fi
break;
done
echo first direetory starting fred was Sfile
rm -rf fred*
exit 0
2.“:”冒号命令
胃号命令是一个空命令。它偶尔会被用来简化逻辑条件，相当于true的一个假名。因为它是
内建的，所以它比true运行的要快，但它的可读性要差了不少。
读者可能会在while循环的某个条件里看到它，“while：”表示这是一个无限循环，相当于更
常见的“while true”。
“：”还被用在对变量进行条件化设置的情况下，比如说
: S{var:avalue)
如果没有“：”，shell会尝试把Svar解释为-个命令。
在某些旧的shell脚本程序里，你会看到冒号被用在一行的开始以引起一个注释，但
现代的脚本程序总是用“#”来开始一个注释行，因为这样做的执行效率更高。
#!/bin/sh
if(-f fred 1: then
pax j-a
else
ti
echo file fred did not exist
exit 0
3.continue命令
类似C语言中的同名语句，这个命令让forlwhile或unti循环跳到下一个循环继续执行.循环
变量取循环清单里的下一个值。
1/bin/sh
rm -rf fred*
echo>fred2
mkdir fred3
echo > fred4
for file in fred*
Op
if1-d*sfile*}; then
continue
echo*skipping directory $file*
echo file is $file
fi
done
rm -rf fred*
exit 0
加入jaVa编程群：524621833
---
## Page 63
44
Linux程序设计
continue可以有-个附加参数，它表示继续开始执行前外跳的循环嵌套层数，也就是说，你
可以部分地跳出嵌套着的循环。这个参数很少被使用，因为这会使脚本程序难于理解。请看下
面的例子：
for × 1n 1 2 3
do
echo before Sx
echo after $x
continue 1
done
它的输出是：
betore 1
before 3
before 2
4.“句点命令
句点命令的作用是执行当前shell中的某个命令，如下所示：
../she1l_acript
在一般情况下，当某个脚本程序执行一个外部命令或脚本程序的时候，会创建一个新的执
行环境（子shell），命令就在这个新环境里被执行。子环境会在执行完毕后丢年，只留下退出码
返回给上--级shell。但外部的source命令和句点命令（两个差不多是同义词）在执行某个脚本程
序单列出的命令时使用的是调用该脚本程序的同一个shell
这就意味着在一般情况下，新命令对环境变量做出的任何改变都会丢失，面句点命令则允
许被执行命令对当前环境进行修改。当我们把脚本程序用傲“打包器”为其他后续命令的执行
设置环境时，这就很有用了。举例来说，如果你手里同时有几个不同的项目，就可能会遇到需
要使用不同参数调用命令的情况，比如调用一个老版本编译器来维护一个老程序等。
在shell脚本程序里，句点命令的作用类似于C或C++语言里的“#include”指令。虽然它实
际并不能包括上脚本程序，但它确实是在当前环境里执行命令的，所以你可以通过它在脚本程
序里协调变量和函数定义。
在下面的例子里，我们的句点命令是在命令行上执行的，但我们完全可以把它用在脚本程
序里。
动手试试：句点“”命令
1）假设我们有两个保存着不同开发环境的设置情况的文件。要想为老的旧命令设置环境，
比如说是classic_set，就该采取如下所示的做法：
#!/bin/sh
versionsclassic
PATH=/usr/local/o1d_bin:/usr/bin:/bin:
PS1=*classic>
2）为新命令我们要使用lastest-set，如下所示：
#1/bin/sh
加入jaVa编程群：524621833
---
## Page 64
第2章shell程序设计
45
PArH=/usr/local/new_bin:/usr/bin:/bin: .
version=latest
PS1=* latest version>
把这两个脚本程序和句点命令结合在一起使用就可以对环境进行设置，就像下面的示范
那样：
S../clasnic_set
classic> echo $version
classic>.lateot_set
classic
latest version> echo $veraion
latest
latest version>
5.echo命令
虽然X/Open大力宣传在现代shell里使用printf命令，我们还是依照“常识”使用echo命令来
输出后面带有-一个换行符的字符串。
一个常见的问题是如何去掉那个换行字符。不幸的是不同版本的UNIX采用的是不同的解决
方案。普通办法是使用下面的方法：
echo -n *string to output*
但你也经常会遇到：
echo -e *string to output\c*
第二种办法“echoe”确保对反斜线转义字符的解释能够起作用，比如“r”对应
于制表符，“n”对应于回车换行等它通常是跌认设置的。详细情况请用man命令查
看相应的使用手册页。如果你需要一种移植性好的去掉是级换行符的办法，可以利用外
部的r命令来去掉它，只是它执行得太慢了，在一般情况下，如果你需要去掉部个换行
符并且你的系统上有printf，就坚持使用它好了。
6.eval命令
eval命令对参数进行求值操作。它是内建在shell里的，做为一个独立命令存在的情况并不多
见。我们用x/Open技术规范中的一个小例子来说明它的用法，如下所示：
fo0=10
xs.s,a
xfoo
echo Sy
它的输出是“Sfoo”。而
foo=10
xsfoo
echo Sy
的输出是“I0"。因此，eval命令有点像外部的“S”命令.它给出的是某个变量的值的值
eval命令很有用，使我们能够随时生成和运行代码。它确实给脚本程序的调试工作增加了难
度，但它能够让你完成一些其他方法难于或不可能做到的事情。
加入jaVa编程群：524621833
---
## Page 65
46
Linux程序设计
7.exec命令
exec命令有两种不同的用法。它经常被用来以另一个不同的程序替换掉当前的shell。请看下
面的例子：
这个命令会在脚本程序里用wall命令替换掉当前的shell。exec语句后面的其他代码都不会被
执行了，因为原来执行这个脚本程序的shel不复存在了。
exec的第二个用法是修改当前文件的描述符。
exec 3< afile
这将使文件描述符“3”被打开以便从文件afile里读取数据。这种用法非常少见。
8.“exitn”命令
exit命令的作用是使脚本程序以退出码“n”结束运行。在任何一个交互式shell的命令提示
符处使用这个命令都会让你退出登录。如果你允许自己的脚本程序在退出时不指定退出状态，
脚本程序里最后一个被执行的命令的退出状态就会被用做返回值。自已提供一个退出码永远是
个良好的习惯。
在shell脚本程序设计实践中，退出码“0”表示成功，“1”到“125”之间的数字是留给脚
本程序用的出错代码。其余数字有特定含义，请看表2-7：
表2-7
退出码
说明
126
文件不是可执行的
421
命令来找到
128及以上
引发的一个信号
对许多使用C或C++语言的程序设计人员来说，使用零表示成功有些不同寻常。在脚本程序
里，这种用法的一大优点是允许我们使用多达125个用户定义的出错代码面不需要多用一个全局
性的出错代码变量。
下面是个简单的例子，如果当前子目录里存在一个名为.profile的文件，就返回“0”表示操
作成功。
#1/bin/sh
if  -f-profile 1: then
fi
exit 0
exit 1
如果你习惯精益求精，或者只是想钻研脚本程序，可以组合使用我们前面介绍的AND和OR
命令表重写一下这段代码：
[-f .protile ”&s exit 0 1 1exit 1
9.export命令
export命令把做为它参数的变量名导出到子shell里，使之成为子shell的环境变量。在默
认的情况下，在一个shell里创建的变量在此shell调用的下级（子）shell里是不可用的。
加入jaVa编程群：524621833
---
## Page 66
第2章shell程序设计47
export命令把自己的参数创建为一个环境变量，而这个新的环境变量可以被其他脚本程序和
被当前程序调用的程序看见。用技术语言讲，被导出的变量将构成从该shell衍生出来的任何
子进程的环境变量。我们用下面这个由两个脚本程序exportl和export2组成的示例来说明它的
用法。
动手试试：变量的导出
1）我们先给出export2的内容：
#: /bin/sh
hf