title:What's going on?: learning communication rules in edge networks
author:Srikanth Kandula and
Ranveer Chandra and
Dina Katabi
What’s Going On? Learning Communication Rules In
Edge Networks
Srikanth Kandula
MIT CSAIL
PI:EMAIL
Ranveer Chandra
Microsoft Research
PI:EMAIL
Dina Katabi
MIT CSAIL
PI:EMAIL
ABSTRACT
Existing tra(cid:14)c analysis tools focus on tra(cid:14)c volume. ˆey identify
the heavy-hitters—(cid:8)ows that exchange high volumes of data, yet fail
to identify the structure implicit in network tra(cid:14)c—do certain (cid:8)ows
happen before, a(cid:13)er or along with each other repeatedly over time?
Since most tra(cid:14)c is generated by applications (web browsing, email,
pʅp), network tra(cid:14)c tends to be governed by a set of underlying
rules. Malicious tra(cid:14)c such as network-wide scans for vulnerable
hosts (mySQLbot) also presents distinct patterns.
We present eXpose, a technique to learn the underlying rules that
govern communication over a network. From packet timing infor-
mation, eXpose learns rules for network communication that may
be spread across multiple hosts, protocols or applications. Our key
contribution is a novel statistical rule mining technique to extract
signi(cid:12)cant communication patterns in a packet trace without explic-
itly being told what to look for. Going beyond rules involving (cid:8)ow
pairs, eXpose introduces templates to systematically abstract away
parts of (cid:8)ows thereby capturing rules that are otherwise unidenti(cid:12)-
able. Deployments within our lab and within a large enterprise show
that eXpose discovers rules that help with network monitoring, di-
agnosis, and intrusion detection with few false positives.
Categories and Subject Descriptors
C.ʅ.ʅ [Computer Communication Networks]: Network Protocols;
G.ʆ [Probability and Statistics]: Correlation
General Terms
Algorithms, Design, Management, Measurement, Performance
1.
INTRODUCTION
Perhaps the single de(cid:12)ning aspect of edge networks today is
that they are complex to manage. Today’s enterprise and campus
networks are built from multiple applications, protocols and servers
which interact in unpredictable ways. Once the network is set-up,
there are few tools that let an administrator keep track with what
is going on in the network. Con(cid:12)guration errors seep in, so(cid:13)ware
gets upgraded and servers get phased out leaving the administrator
with the unenviable job of ensuring that tra(cid:14)c in the network
conforms to a plan. Of course, scripting cron jobs and correlating
server logs to (cid:12)gure out what’s going on is a tedious option that
does not scale [ʄ@].
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
SIGCOMM’08, August 17–22, 2008, Seattle, Washington, USA.
Copyright 2008 ACM 978-1-60558-175-0/08/08 ...$5.00.
We advocate an alternative approach to manage the complexity in
edge networks. Suppose we shi(cid:13) focus away from individual servers
and con(cid:12)gurations and focus directly on packets on the wire. Sup-
pose that from a packet trace, we could learn communication rules
that underlie a majority of the user activities present in that trace.
Such a broad picture would provide an administrator with a reality-
check; he can see how tra(cid:14)c for major applications traverses the
network, identify con(cid:12)guration errors or unwarranted communi-
cation, and perhaps detect malicious activity. ˆis paper is a (cid:12)rst
step towards this goal.
Existing trace analysis tools however cannot reveal to an admin-
istrator the communication patterns in his network. ˆey focus on
tra(cid:14)c volume and do not reveal the implicit structure in edge net-
work tra(cid:14)c. Tools like MRTG [ʄʈ] and NetFlow Analyzers focus on
the heavy hitters, i.e., (cid:8)ows that exchange a lot of data. ˆey may
report that ʆʃʂ of the tra(cid:14)c is to the web-server and that @ʃʂ of
the tra(cid:14)c uses TCP. Advanced tools like AutoFocus [ʈ] adapt their
granularity of search. ˆey can reveal IP subnets (e.g, ʄʃ.ʃ.ʃ.ʃ/@) or
port ranges that contribute lots of tra(cid:14)c.
ˆis paper introduces eXpose, a new analysis technique that ex-
tracts signi(cid:12)cant communication rules in a network trace, without
being told what to look for. A communication rule is a predicate
such as F lowi.new ⇒ F lowj .new indicating that whenever a
new F lowi connection happens, a new F lowj connection is likely
to happen. For example, eXpose would deduce rules like a DNS
connection o(cid:13)en precedes new connections, an AFS client talks to
the root-server (port @ʃʃʆ) before picking (cid:12)les up from the appro-
priate volume-servers (port @ʃʃʃ), an End-Point-Mapper RPC call
precedes mail fetch from Microso(cid:13) Exchange Servers, and viruses
such as the mySQLbot probe (cid:8)ood the entire network looking for
vulnerable mySQL servers.
Our key insight is simple–if a group of (cid:8)ows consistently occurs
together, the group is likely dependent. Of course, correlation does
not always imply dependence, but this is the best one can do lacking
knowledge of the applications and the network layout. ˆe chal-
lenge lies in applying this insight to a network trace where millions
of (cid:8)ows show up every few hours. To do this, eXpose selectively bi-
ases the potential rules it evaluates and does not evaluate rule types
that are unlikely to yield useful information. Second, eXpose ab-
stracts away extraneous (cid:8)ow details to make useful patterns more
discernible. ˆird, eXpose uses an appropriate statistical measure
to score the candidate rules and mines e(cid:14)ciently. Finally, eXpose
aggregates the discovered rules into a small number of useful clus-
ters that an administrator can corroborate and use.
Not all dependencies are visible at the granularity of a (cid:8)ow. For
example, suppose whenever a client talks to a sales server, the server
fetches data from a backend database. Yet no individual client ac-
cesses the server o(cid:13)en enough to create a signi(cid:12)cant rule. To cap-
ture such rules that are otherwise unidenti(cid:12)able, eXpose introduces
templates that systematically abstract away parts of (cid:8)ows. For ex-
ample, one of our templates replaces the client’s IP with a wild-card
character creating a generic whenever any client talks to the sales
Internet
Internet
Our Lab Servers
(Web, NFS, AFS, DNS)
Our Lab Network
Conference 
Wireless LANs
(Sigcomm’04, 
OSDI’06)
Enterprise Corporate 
Network
Enterprise Research LAN
(a) Lab’s Access Link
(b) Access Link of Conference LANs
(c) Before Lab’s Enterprise Servers
(d) Within a Major Enterprise
Figure ʄ: We evaluated eXpose on traces collected at each of the locations above (shown by the blue circle). ˆe locations included access links at a large
university and at two di(cid:11)erent conference wireless LANs and, links carrying enterprise tra(cid:14)c towards servers at a university and at a large company.
server. Leveraging these generics, eXpose searches for rules like
∗ : Sales ⇒ Sales : Database, meaning whenever any one of the
clients talks to the Sales server, the Sales server talks to its Database.
We show how to apply templates without any prior knowledge about
the hosts involved in the trace and (cid:12)nd that these templates improve
the expressiveness of our rules considerably.
eXpose has three unique characteristics. First, eXpose extracts
communication rules with zero guidance, i.e., without being told
what to look for. Hence, eXpose can identify communication
rules that are unknown to the administrator, including con(cid:12)gura-
tion errors, anomalies, and exploits. Second, while prior work [ʄ,
ʄʃ] focuses on individual applications, a single source-destination
pair [ʄʃ], or the dependencies for clients accessing a given server [ʄ],
eXpose learns patterns that may involve multiple applications,
servers or protocols. Extracting this broad picture by applying prior
techniques that learn rules one application at a time or one server at
a time does not scale and may miss out on important dependencies
if the admin forgets to point the tool towards the correct servers (or
applications). ˆird, eXpose is in a sense future-proof. By making
minimal assumptions about applications, protocols and servers, eX-
pose’s techniques to learn rules can deal with evolving networks.
We deployed eXpose on the server-facing links of two edge net-
works, in the CSAIL lab at MIT and in the Microso(cid:13) Research net-
work for a couple of months. We also run eXpose on traces collected
on the access-links (i.e., Internet facing links) of our lab at MIT and
two conference hot-spots. We corroborated rules output by eXpose
with the admins at the corresponding locations and aggressively re-
port every rule that we could not explain as a false positive. Our
results show the following:
• eXpose discovered rules for enterprise con(cid:12)gurations and
protocols that are deployed and used in mainstream operat-
ing systems that we did not know existed, such as Nagios [ʄʇ]
monitors and link-level multicast name resolution [ʄʅ].
• eXpose discovered rules for the major applications such as
email, web, (cid:12)le-servers, instant messengers, peer-to-peer and
multimedia distribution in each of the two edge networks.
• eXpose detected con(cid:12)guration errors leading to bug (cid:12)xes.
• eXpose detected malicious tra(cid:14)c, machines infected by tro-
jans, mysql bot scans and ssh scans targeting key routers.
• eXpose mines for rules in time that is much smaller than
the duration of traces (ʃ.ʄʂ – ʅʆ.@ʂ). ˆis means that al-
though our current implementation works o(cid:15)ine by feeding
o(cid:11) packet traces, an online implementation is feasible.
We begin by describing eXpose’s learning algorithm.
2. LEARNING COMMUNICATION RULES
Our goal is the following: Given a packet trace, discover the com-
munication rules inside the corresponding network. We de(cid:12)ne a
communication rule as a dependency between (cid:8)ow activities (see
Table ʄ). A communication rule X ⇒ Y occurs in the trace if (cid:8)ow
activity X implies (cid:8)ow activity Y . For example, X may be a new
http connection from a client to a web-server, which implies Y , a
new connection from the client to the DNS server. ˆe rules them-
selves are probabilistic to mimic the underlying phenomena. For
example, new connections trigger DNS lookups only upon a miss
in the local cache. Some communication rules are at the granu-
larity of (cid:8)ows such as whenever Hostʄ talks to Hostʅ, Hostʅ talks
to Hostʆ; whereas others are more abstract, such as whenever any
client talks to the web-server W, the web-server talks to its backend
B. We call the latter generic rules and de(cid:12)ne simple templates for
such generic rules. Our tool discovers all signi(cid:12)cant instantiations
of these templates in the given packet trace. Some of the rules we
discover describe the normal behavior of the network, while others
identify attacks and mis-con(cid:12)gurations in the network.
2.1 From Dependency to Association
How do we detect (cid:8)ow dependencies in a trace? Lacking knowl-
edge of the applications and the network layout, it is impossible to
say that two activities seen in a trace are dependent. ˆe best one
can do is to (cid:12)nd correlated occurrences in the trace. At a high-level,
our idea is to identify (cid:8)ow groups that co-occur with frequency sig-
ni(cid:12)cantly greater than chance and repeat consistently over time.
But there are simply too many (cid:8)ows in a trace, for e.g., in all of
the links that we collected traces at (see Fig. ʄ), we saw more than
105 (cid:8)ows within a few hours. Examining every pair of (cid:8)ows for
dependence doesn’t scale, let alone examining larger groups of (cid:8)ows.
To design a scalable solution, we make a Markovian assumption.
Whether a (cid:8)ow is absent, present, or new at any point of time is only
in(cid:8)uenced by (cid:8)ows that have recently occurred. Said di(cid:11)erently, we
partition the trace into time windows and look for dependencies
that occur within the same time window (default window size is 1s).
ˆis assumption focuses on identifying dependencies that are sepa-
rated only by a short period of time. We believe that most network
dependencies are machine-generated and are indeed separated by
a short period of time. For example, we learnt the communication
rules for BitTorrent, viruses and, email clients (See §ʇ) by looking
within 1s-wide windows. A systematic evaluation of sensitivity to
window size is in §ʇ.ʈ. We acknowledge, however, that some (cid:8)ow
dependencies occur over longer periods. For example, the gap be-
tween a user reading a web-page and clicking on a link may exceed
ʄs. Extending our technique to look at dependencies over multiple
time windows is possible but is outside the scope of this paper.
Using this Markovian assumption, eXpose converts the input
trace into an activity matrix. ˆe rows of the activity matrix de-
note time windows in the trace, whereas the columns correspond to
(cid:8)ows in the trace. Each entry in the matrix takes one of three values:
new, present or absent denoting the activity of a (cid:8)ow (column) in
Term
Flow
Flow Activity
Rule X ⇒ Y
Activity Matrix
Meaning
A (cid:12)ve-tuple 
A (cid:8)ow is either absent, present or new. Note new ⊂ present.
X, Y are tuples of . X ⇒ Y is a strong rule if whenever (cid:8)ow FX has activity AX , (cid:8)ow FY is more likely to
have activity AY than normal.
Rows denote time windows, columns denote (cid:8)ows in the trace. Each entry holds the activity of a (cid:8)ow (column) in the corresponding
time window (row)
Table ʄ: De(cid:12)nitions used in this paper
Packet
Trace
time1
…
timeR
flow1
present |new
… flowK
Activity Matrix
…
flowi.new →
flowj.present
...
Rules for Related 
Flows
Figure ʅ: Schematic of eXpose’s work-(cid:8)ow.
a time window (row). We observe that this representation (Fig. ʅ)
is typical of a data-mining problem. Hence eXpose (cid:12)nds dependent
(cid:8)ows by mining for association rules [ʇ] in the activity matrix.
Flows and their activities: To be concrete, we identify a (cid:8)ow in
terms of its source and destination IPs, ports, and protocol. A (cid:8)ow
is present in a time-window if it sends non-zero packets during that
period. For connection-oriented (cid:8)ows like TCP that have an explicit
start and end (syn, (cid:12)n), a (cid:8)ow is new in the time window that over-
laps its beginning. For datagram-based (cid:8)ows and also when traces
don’t have detailed headers, a (cid:8)ow is new if it becomes present a(cid:13)er
a period of inactivity. Note that if a (cid:8)ow is new, it is also present in
that time window (new ⊂ present).
2.2 Signiﬁcance of a Communication Rule
How does one tell which dependencies are signi(cid:12)cant? One might
be tempted to say that a communication rule, X ⇒ Y , exists if X
and Y occur together o(cid:13)en, that is if P rob(X ∧ Y ) is high. ˆis
intuition is incorrect, however, and causes both false positives and