title:Semantically Rich Application-Centric Security in Android
author:Machigar Ongtang and
Stephen E. McLaughlin and
William Enck and
Patrick D. McDaniel
2009 Annual Computer Security Applications Conference
Semantically Rich Application-Centric Security in Android
Machigar Ongtang, Stephen McLaughlin, William Enck and Patrick McDaniel
Department of Computer Science and Engineering
The Pennsylvania State University, University Park, PA 16802
Email: {ongtang,smclaugh,enck,mcdaniel}@cse.psu.edu
Abstract—Smartphones are now ubiquitous. However, the
security requirements of these relatively new systems and the
applications they support are still being understood. As a
result, the security infrastructure available in current smart-
phone operating systems is largely underdeveloped. In this
paper, we consider the security requirements of smartphone
applications and augment the existing Android operating
system with a framework to meet them. We present Secure
Application INTeraction (Saint), a modi ed infrastructure
that governs install-time permission assignment and their
run-time use as dictated by application provider policy.
An in-depth description of the semantics of application
policy is presented. The architecture and technical detail
of Saint is given, and areas for extension, optimization,
and improvement explored. As we show through concrete
example, Saint provides necessary utility for applications to
assert and control the security decisions on the platform.
Keywords-mobile phone security; Android; application
interactions; mediation;
I. INTRODUCTION
Smartphones have spurred a renaissance in mobile
computing. The applications running on smartphones sup-
port vast new markets in communication, entertainment,
and commerce. Hardware, access, and software support-
ing such applications are now widely available and often
surprisingly inexpensive, e.g., Apple’s App Store [1],
Android’s Market [2], and BlackBerry App World [3].
As a result, smartphone systems have become pervasive.
Mobile phone applications are shifting from stand-
alone designs to a collaborative (service) model. In this
emerging environment, applications expose selected inter-
nal features to other applications, and use those provided
by others. In the latter case, applications simply search
and use appropriate providers of a service type at run-
time, rather than bind itself to speciﬁc implementations
during development. This allows a rich culture of “use
and extend” development that has led to an explosion
of innovative applications. This culture is possibly best
illustrated in the Android1 operating system community.
The security model of the Android system (and that
of many other phone operating systems) is “system-
centric”. Applications statically identify the permissions
This material is based upon work supported by the National Science
Foundation under Grant No. CNS-0721579 and CNS-0643907. Any
opinions, ﬁndings, and conclusions or recommendations expressed in
this material are those of the author(s) and do not necessarily reﬂect the
views of the National Science Foundation.
1http://www.android.com
that govern the rights to their data and interfaces at
installation time. However, the application/developer has
limited ability thereafter to govern to whom those rights
are given or how they are later exercised. In essence,
permissions are asserted as often vague suggestions on
what kinds of protections the application desires. The ap-
plication must take on faith that the operating system and
user make good choices about which applications to give
those permissions—which in many cases is impossible
because they do not have sufﬁcient context to do so.
Consider a hypothetical PayPal service built on An-
droid. Applications such as browsers, email clients, soft-
ware marketplaces, music players, etc. use the PayPal
service to purchase goods. The PayPal service in this
case is an application that asserts permissions that must
be granted to the other applications that use its inter-
faces. What
is a legitimate application? Only PayPal
the application (really PayPal the corporation) is in a
position to know the answer to that question. This is
more than simply a question of who is making the request
(which in many cases in Android is itself unknowable),
but also where, when, how, and under what conditions
the request is being made. Unfortunately, Android does
not provide any means for answering those questions or
enforcing a security policy based upon them. Simply put,
the Android system protects the phone from malicious
applications, but provides severely limited infrastructure
for applications to protect themselves. Based on extensive
development of Android applications, we observe three
essential application policies not available to applications
in the Android security framework:
1) Permission assignment policy - Applications have
limited ability to control to whom permissions for
accessing their interfaces are granted, e.g., white or
black-list applications.
2) Interface exposure policy - Android provides only
rudimentary facilities for applications to control
how their interfaces are used by other applications.
3) Interface use policy - Applications have limited
means of selecting, at run-time, which application’s
interfaces they use.
This paper introduces the Secure Application INTeraction
(Saint) framework that extends the existing Android secu-
rity architecture with policies that address these key appli-
cation requirements. In the Saint-enhanced infrastructure,
1063-9527/09 $26.00 © 2009 IEEE
DOI 10.1109/ACSAC.2009.39
340
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply. 
Payment Applications
Internet
Payment
Info.
Secure
Payment
Payment
Info.
Trust
Checkout
Personal
Shopper
Order
Info.
Payment
Info.
M-Payer
Password
Vault
Encrypted 
Account 
Password
Location-
based 
Search App
Personal
Ledger
Browser
...
Media
Player
...
Figure 1.
The PersonalShopper application ﬁnds desired items at
the discretion of the user and interacts with vendors and payment
applications to purchase them.
applications provide installation-time policies that regu-
late the assignment of permissions that protect their inter-
faces. At run-time, access of or communication between
applications is subject to security policies asserted by both
the caller and callee applications. Saint policies go far
beyond the static permission checks currently available in
Android by restricting access based on run-time state, e.g.,
location, time, phone or network conﬁguration, etc. We
deﬁne the Saint framework and discuss the complexities
of augmenting Android with extended policy enforcement
features, and develop mechanisms for detecting incompat-
ibilities and dependencies between applications. We begin
our discussion with a motivating example.
II. SMARTPHONE APPLICATION SECURITY
Figure 1 presents the ﬁctitious PersonalShopper smart-
phone shopping application. PersonalShopper tracks the
items a user wishes to buy and interacts with payment
applications to purchase them. A user enters desired items
through the phone’s user interface (potentially by clicking
on items on a browser, media player, etc.), creating a
vender independent “shopping cart”. Users subsequently
acquire items in one of two ways. The user can direct
the application to “ﬁnd” an item by clicking on it. In this
case the application will search known online vendors
or shopping search sites (e.g., Google Product Search) to
ﬁnd the desired item. Where multiple vendors provide the
same item, the user selects their vendor choice through
a menu. The second means for ﬁnding a product is by
geography—a user moving through, for example, a mall
can be alerted to the presence of items available in a
physical store by a location-based search application. In
this case, she will be directed to the brick-and-mortar
vendor to obtain the item.
Regardless of how the item is found, PersonalShopper’s
second objective is to facilitate the purchase process
itself. In this case, it works with our example checkout
applications SecurePayer and TrustCheckout. Personal-
Shopper accesses checkout applications and acts as an
intermediary between the buyer and the merchants to
both improve the efﬁciency of shopping and to protect
customer privacy. The application and the services they
use will interact with password vaults to provide au-
thenticating credentials. Following their completion, the
transactions are recorded in a personal ledger application.
Consider a few (of many) security requirements this
application suggests:
1) PersonalShopper should only use trusted payment
services. In Figure 1, it may trust SecurePayer and
TrustCheckout, but does not trust other unknown
payment providers (e.g., the M-Payer provider).
2) PersonalShopper may only want to restrict the use
of the service to only trusted networks under safe
conditions. For example, it may wish to disable
searches while the phone is roaming or highly
exposed areas (e.g., airports) or while battery is low.
3) PersonalShopper may require certain versions of
service software be used. For example, the pass-
word vault application v. 1.1 may contain a bug that
leaks password information. Thus, the application
would require the password vault be v. 1.2 or higher.
4) PersonalShopper may wish to ensure transaction
information is not leaked by the phone’s ledger
application. Thus, the application wishes to only
use ledgers that don’t have access to the Internet.
5) Security requirements may be placed on Personal-
Shopper by the applications and services it uses. For
example, to preserve location privacy, the location-
based search application may only provide Person-
alShopper location information only where Person-
alShopper holds the permissions to access location
information itself, e.g., the phone’s GPS service.
None of these policies are supported by the current
Android security system. While some of these may be
partially emulated using combinations of complex ap-
plication code, code signing, and permission structures,
they are simply outside the scope of Android’s security
policy. As a consequence (and core to our extensive
experience building systems in Android), applications
must cobble together custom security features on top
of the rudimentary structures currently provided by the
Android system. Where possible at all, this process is ad
hoc, error prone, repetitive, and inexact.
What is needed is for Android to provide applications
a more semantically rich policy infrastructure. We begin
our investigation by outlining the Android system and
security mechanisms. Section IV examines a spectrum of
policies that are potentially needed to fulﬁll the applica-
tions’ security requirements, highlighting those cannot be
satisﬁed by the current Android. We then introduce goals,
design, and implementation of the Saint system.
III. ANDROID
Android is an mobile phone platform developed by the
Google-led Open Handset Alliance (OHA).2 The platform
2http://www.openhandsetalliance.com/
341
Authorized licensed use limited to: Tsinghua University. Downloaded on March 25,2021 at 13:12:28 UTC from IEEE Xplore.  Restrictions apply. 
start
start/stop/bind
call
Activity
Activity
Activity
Service
return
System
Activity
Service
Send
Intent
Broadcast 
Receiver
Activity
callback
Read/Write
Query
return
Content 
Provider
Figure 2. Typical Android application component IPC
quickly became popular amongst the developer commu-
nity for its open source nature and adoption by telecom-
munications providers world-wide. While Android is
based on Linux, the middleware presented to application
developers hides traditional OS abstractions. The platform
itself focuses on applications, and much of the core phone
functionality is implemented as applications in the same
fashion used by third-party developers.
Android applications are primarily written in Java and
compiled into a custom byte-code (DEX). Each applica-
tion executes in a separate Dalvik virtual machine inter-
preter instance running as a unique user identity. From the
perspective of the underlying Linux system, applications
are ostensibly isolated. This design minimizes the effects
of a compromise, e.g., an exploited buffer overﬂow is
restricted to the application and its data [4].
All
inter-application communication passes through
middleware’s binder IPC mechanism (our discussion as-
sumes all IPC is binder IPC). Binder provides base
functionality for application execution. Applications are
comprised of components. Components primarily interact
using the Intent messages. While Intent messages can
explicitly address a component in an application by name,
Intent versatility is more apparent for Intent messages
addressed with implicit action strings, for which the mid-
dleware automatically resolves how to handle the event,
potentially prompting the user. Recipient components
assert their desire to receive Intent messages by deﬁning
Intent ﬁlters specifying one or more action strings.
There are four types of components used to construct
applications; each type has a speciﬁc purpose. Activity
components interface with the user via the touchscreen
and keypad. Typically, each displayed screen within an
application is a different Activity. Only one Activity is
active at a time, and processing is suspended for all
other activities, regardless of the application. Service
components provide background processing for use when
an application’s Activities leave focus. Services can also
export Remote Procedure Call (RPC) interfaces including
support for callbacks. Broadcast Receiver components
provide a generalized mechanism for asynchronous event
notiﬁcations. Traditionally, Broadcast Receivers receive
Intents implicitly addressed with action strings. Standard
event action strings include “boot completed” and “SMS
received.” Finally, Content Provider components are the
preferred method of sharing data between applications.
The Content Provider API implements an SQL-like inter-
face; however, the backend implementation is left to the
application developer. The API includes support to read
and write data streams, e.g., if Content Provider shares
ﬁles. Unlike the other component types, Content Providers
are not addressed via Intents, but rather a content Uniform
Resource Identiﬁer (URI). It is the interaction between
application components for which we are concerned.
Figure 2 depicts common IPC between component types.
Android’s application-level security framework is based