hfsdebug can display details and contents (leaf records) of the Hot Files B-Tree. Note that unlike other HFS+
B-Trees, this B-Tree contains a user data record in its header node. The record holds a HotFilesInfo structure
[bsd/hfs/hfs_hotfiles.h].
$ sudo hfsdebug -b hotfile
# HFS+ Hot File Clustering (HFC) B-Tree
...
# User Data Record
magic = 0XFF28FF26
version = 1
duration = 216000 seconds
...
timeleft = 42710 seconds
threshold = 24
maxfileblks = 2560 blocks
maxfilecnt = 1000
tag = CLUSTERED HOT FILES B-TREE
12.9.3.3. The Working of Hot File Clustering
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 68 of 81
Let us now look at details of some key HFC operations while referring to Figure 1231. A typical starting point
is the HFC_DISABLED stage, which a volume is considered to be in after it is unmounted.
When a volume is mounted, hfs_recording_init() ensures that it is a root volume, disabling HFC
otherwise. Next, if the Hot Files B-Tree already exists, HFC transitions to the idle stage; otherwise,
hfs_recording_init() creates a B-Tree and initiates a scan of the Catalog B-Tree. During this scan, HFC
examines each leaf record in the catalog, performing the following operations for each file record.
It ignores resource forks[24] and empty data forks.
[24] In Mac OS X 10.4, HFC works only on data forks.
It ignores files whose extents are all outside of the Hot File area.
 It skips over the two journal files, /.journal_info_block and /.journal.
It adds a thread record and a Hot File record to the Hot Files B-Tree for the remaining files, all of which
will have at least one block within the Hot File area. The initial data values for the thread and Hot File
records are HFC_MINIMUM_TEMPERATURE and the number 0x3f3f3f3f, respectively.
A volume's current HFC stage is contained in the hfc_stage field of the hfsmount structure, which is initially
zero-filled. The numerical value of HFC_DISABLED is zero as well. Therefore, HFC is implicitly disabled at the
start for every volume.
After the Catalog B-Tree scan is complete, hfs_recording_init() places HFC in the idle stage. The
transition to the next stagethe recording stageoccurs when hfs_hotfilesync() calls hfs_recording_start
().
A sync operation results in a call to hfs_hotfilesync(), which is responsible for calling the appropriate
functions when the current stage is one of HFC_ADOPTION, HFC_EVICTION, HFC_IDLE, or HFC_RECORDING. A
sync operation normally occurs because of the update daemon invoking the sync() system call periodically.
For HFC to record file temperatures on a volume, several conditions must hold.
The volume must not be read-only.
The volume must be journaled.
 The volume's hfsmount structure must indicate that the metadata zone has been established for the
volume.
The number of free allocation blocks on the volume must be at least twice the total number of Hot File
area blocks possible.
Table 123 shows various other constraints that HFC uses.
Table 123. Constraints Used by Hot File Clustering
Name Value Notes
HFC_BLKSPERSYNC 300 The maximum number of allocation blocks
that can be movedwhether for eviction or
adoptionduring a single sync-triggered
HFC operation. Adoption does not move
only parts of a file; therefore, this
effectively limits the size of a hot file to
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 69 of 81
1.2MB for the default allocation block size
of 4KB.
HFC_FILESPERSYNC 50 The maximum number of files that can be
moved during adoption or eviction.
HFC_DEFAULT_DURATION 60 hours The default temperature-recording
duration.
HFC_DEFAULT_FILE_COUNT 1000 The default number of hot files to track.
HFC_MAXIMUM_FILE_COUNT 5000 The upper limit on the number of hot files
to track.
HFC_MAXIMUM_FILESIZE 10MB The upper limit on the size of files to track
during recording. Files larger than this will
not be tracked.
HFC_MINIMUM_TEMPERATURE 24 The threshold temperature for residency in
the Hot File area.
hfs_recording_start() allocates memory for data structures used during recording. In particular, an
instance of the hotfile_data_t structure [bsd/hfs/hfs_hotfiles.c] is used as an anchor for a runtime
recording list of hotfile_entry_t structures [bsd/hfs/hfs_hotfiles.c]. The hfc_recdata field of the
hfsmount structure refers to the hotfile_data_t structure.
typedef struct hotfile_entry {
struct hotfile_entry *left;
struct hotfile_entry *right;
u_int32_t fileid;
u_int32_t temperature;
u_int32_t blocks;
} hotfile_entry_t;
During the recording stage, read operations accumulate the number of bytes read for each file, whereas write
operations reset such a count to zero (specifically, a file whose size is changing is not a desirable Hot File
candidate). Moreover, even during read operations, the bytes-read count for a file will be initialized to the I/O
count of the current read operationrather than being added cumulativelyif the file's access time is older than the
start of the current recording period.
When an active vnode[25] becomes inactive, the HFS+ reclaim operation, hfs_vnop_reclaim(), calls
hfs_addhotfile() to add the fileif appropriateto the runtime recording list. A vnode must satisfy several
criteria to be added to the list, such as the following.
[25] Technically, a catalog node (cnode).
It must be either a regular file or a symbolic link.
It must not be a system file.
It must not be a resource fork.
It must have a nonzero size that is less than the maximum hot file size.
It must have an access time newer than the start of the current recording period.
It must have its temperature above the threshold.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 70 of 81
If a file on the runtime recording list becomes active, it is removed from the list by hfs_getnewvnode()
[bsd/hfs/hfs_cnode.c] through a call to hfs_removehotfile(). Active vnodes are examined separately
once the recording period has ended.
After the recording period ends, the next sync-triggered call to hfs_hotfilesync() will invoke
hfs_recording_stop(), which first calls hotfiles_collect() to add all active hot files to the recording
list. hotfiles_collect() iterates over each active vnode associated with the volume's mount point and calls
hfs_addhotfile_internal()the back-end of hfs_hotfile()to update the recording list.
Once hotfiles_collect() returns, hfs_recording_stop() moves to the evaluation stage, during which it
performs the following operations.
It ages the existing records (only the coldest 50%) in the Hot Files B-Tree by halving their temperatures,
while limiting the lowest possible temperature to 4.
It sorts the runtime recording list entries by temperature.
It identifies the list entries that are already in the Hot Files B-Tree. For each such entry, its B-Tree
information is updated, after which the entry is invalidated in the list. This operation results in a refined
list of hot files eligible for adoption.
At this point, the next HFC stage will be set as either adoption or eviction, depending on whether the free
space available in the Hot File area is more or less, respectively, than the total space required by all hot files
ready for adoption.
If the current stage is HFC_EVICTION, the next sync will trigger the invocation of hotfiles_evict(), which
attempts to reclaim space by moving files out of the Hot File area by calling hfs_relocate(). It begins with
the coldest files but may end up evicting all files depending on the space that must be reclaimed. However, as
listed in Table 123, only up to HFC_BLKSPERSYNC allocation blockscorresponding to no more than
HFC_FILESPERSYNC filescan be moved during a single HFC eviction or adoption. If hotfiles_evict() is
unable to finish its work before hitting these constraints, HFC remains in the eviction stage and will continue
when the next sync occurs. Once eviction finishes, HFC moves to the adoption stage, which is handled by
hotfiles_adopt(). Adoption is similar to evictionit is also performed through hfs_relocate() and is
subject to the same transfer constraints.
After adoption, HFC moves to the idle stage, from where it will enter the next recording period.
12.10. Miscellaneous Features
In this section, we will look at sundry HFS+ features.
12.10.1. Special System Calls
Noteworthy system calls supported by HFS+ include the following.
 exchangedata() is used for exchanging the data and resource forks of two files. File attributes and
extended attributes, including ACLs, are not exchanged, although modification times are exchanged.
The call is atomic in that neither of the two files will be seen in an inconsistent state by any process.
After the exchange is complete, all open file descriptors for the original file will access the new data.
The primary purpose of exchangedata() is to provide applications that do not edit files in place (for
safety) a way to save changes, without modifying the CNID of the original file. This way, CNID-based
references to the original file will not break.
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 71 of 81
 getattrlist() and setattrlist() are used for retrieving and setting, respectively, attributes of file
system objects, including volumes (see Section 12.11).
 geTDirentriesattr() is used for retrieving file system attributes for items in a given directory. This
call is essentially a combination of getdirentries(2) and getattrlist(2). Note that getdirentries
(2) is the system call invoked by readdir(3).
 searchfs() is used for searching the file system based on a variety of criteria.[26]
[26] The searchfs(2) man page provides details of using this system call.
12.10.2. Freezing and Thawing a Volume
HFS+ provides the file control operations F_FREEZE_FS and F_THAW_FS for freezing and thawing, respectively,
a journaled mounted volume. Freezing allows a superuser process to lock down a file system by stopping file
system operations. In processing a freeze request, the kernel performs the following operations on the file
system corresponding to the given file descriptor.
It iterates over all vnodes of the mounted file system and waits for any pending write operations to
finish.[27]
[27] The waiting period uses a timeout of 10 ms.
It flushes the journal.
 It acquires the global volume lock exclusively. This prevents the hfs_start_transaction() function
[bsd/hfs/hfs_vfsutils.c] from acquiring this lock. Therefore, any file system functions that call
hfs_start_transaction()directly or indirectlywill wait for the lock to be released.
It waits for any pending writes to finish on vnodes for the Extents Overflow file, the Catalog file, the
Attributes file, and the volume device.
 It records the identity of the calling process in the hfs_freezing_proc field of the hfsmount structure.
Thawing releases the global volume lock. A frozen volume can be thawed only by the process that froze it.
The fsck_hfs program uses F_FREEZE_FS and F_THAW_FS to support "live" testing (the -l option) of a
mounted file system.
12.10.3. Extending and Shrinking a Volume
HFS+ has built-in support for growing or shrinking a mounted journaled file system. The hfs_extendfs()
and hfs_truncatefs() kernel-internal functions, both of which are implemented in bsd/hfs/hfs_vfsops.c,
provide this functionality. The functionality can be accessed from user space through the HFS_RESIZE_VOLUME
command of fsctl(2) or the HFS_EXTEND_FS operation through sysctl(3), for example:
int ret, options = 0;
u_int64_t newsize; // initialize this to the new size of the file system
...
ret = fsctl(mounted_volume_path, HFS_RESIZE_VOLUME, &newsize, options);
12.10.4. Volume Notifications
HFS+ generates a volume notification through hfs_generate_volume_notifications()
[bsd/hfs/hfs_notifications.c] when free space on a volume falls below a warning limit. Another
notification is generated when the volume's free space rises above a minimal desired limit. Both limits are
stored in the hfsmount structure as the hfs_freespace_notify_warninglimit and
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 72 of 81
hfs_freespace_notify_desiredlevel fields, respectively. The BlockAllocate() and BlockDeallocate
() low-level functions in bsd/hfs/hfscommon/Misc/VolumeAllocation.c call the notification function
every time they are invoked, allowing notifications to be generated if the current allocation or deallocation
operation caused the free space situation to change with respect to the limits.
We can view VFS notifications (including the HFS+ notifications mentioned in this section) by using the
program shown in Figure 1233. The KernelEventAgent program (/usr/sbin/KernelEventAgent) receives
these notifications and logs them to the system log file.
Figure 1233. Viewing VFS event notifications using kqueue/kevent
// kq_vfswatch.c
#include 
#include 
#include 
#include 
#include 
#define PROGNAME "kq_vfswatch"
struct VfsEventDescriptions{
u_int event;
const char *description;
} VfsEventDescriptions[] = {
{ VQ_NOTRESP, "server is down" },
{ VQ_NEEDAUTH, "server needs authentication" },
{ VQ_LOWDISK, "disk space is low" },
{ VQ_MOUNT, "file system mounted" },
{ VQ_UNMOUNT, "file system unmounted" },
{ VQ_DEAD, "file system is dead (needs force unmount)" },
{ VQ_ASSIST, "file system needs assistance from external program" },
{ VQ_NOTRESPLOCK, "server locked down" },
{ VQ_UPDATE, "file system information has changed" },
};
#define NEVENTS sizeof(VfsEventDescriptions)/sizeof(struct VfsEventDescriptions)
int
process_events(struct kevent *kl)
{
int i, ret = 0;
printf("notification received\n");
for (i = 0; i fflags)
printf("\t+ %s\n", VfsEventDescriptions[i].description);
return ret;
}
#define OUT_ON_ERROR(msg, ret) { if (ret  0)
file://C:\Dokumente und Einstellungen\Silvia\Lokale Einstellungen\Temp\~hhC53.htm 20.08.2007
Chapter 12. The HFS Plus File System Page 73 of 81
ret = process_events(&changelist);
}
out:
if (kqfd >= 0)
close(kqfd);
exit(ret);
}
$ gcc -Wall -o kq_vfswatch kq_vfswatch.c
$ ./kq_vfswatch
# another shell
$ hdiutil create -size 32m -fs HFSJ -volname HFSJ /tmp/hfsj.dmg
...
$ open /tmp/hfsj.dmg
notification received
+ file system mounted
$ dd if=/dev/zero of=/Volumes/HFSJ/data bs=4096
dd: /Volumes/HFSJ/data: No space left on device
...
notification received
+ disk space is low
$ mount -u -o,perm /Volumes/HFSJ
notification received
+ file system information has changed
$ umount /Volumes/HFSJ
notification received
+ file system unmounted
hfs_generate_volume_notifications() calls vfs_event_signal() [bsd/vfs/vfs_subr.c] to generate a
kqueue notification. Several HFS+ internal operations also use the kqueue mechanism to generate notifications
when file system objects are modified. This allows interested user-space partiesthe prime example being the
Finderto learn about these changes.
12.10.5. Support for Sparse Devices
HFS+ allows the device underlying a file system to be sparse. Apple's Disk Images framework uses this
feature to support sparse disk imagesit uses the HFS_SETBACKINGSTOREINFO control operation to inform the
kernel of the backing store file system. Sparse disk images can be created using hdiutil, either by specifying
SPARSE as the disk image type or by providing a disk image name that contains the .sparseimage suffix. Let
us look at an example.
$ hdiutil create -size 128m -fs HFSJ -volname HFSSparse /tmp/hfsj.sparseimage
created: /tmp/hfsj.sparseimage
$ ls -lh /tmp/hfsj.sparseimage
-rw-r--r-- 1 amit wheel 12M Oct 13 18:48 /tmp/hfsj.sparseimage
$ open /tmp/hfsj.sparseimage
We see that even though the volume's capacity is 128MB, the sparse disk image currently occupies only
12MB. It will be dynamically grown, up to the volume's capacity, when necessary.
12.11. Comparing Mac OS X File Systems