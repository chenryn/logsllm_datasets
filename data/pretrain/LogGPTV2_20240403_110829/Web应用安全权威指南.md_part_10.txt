> 4.3 节以后将分门别类地详细剖析 Web
> 应用的每个功能容易滋生的安全隐患。其中，一些影响重大的知名隐患，如跨站脚本（XSS）与
> SQL 注入等也都将在此进行讲述。
## **4.1 Web 应用的功能与安全隐患的对应关系** {#text00000.html#nav_point_19}
#### **安全隐患产生于何处**
在逐项细述 Web 应用的安全隐患之前，让我们先对安全隐患有一个整体认识。图
4-1 展示了 Web
应用的各项功能与安全隐患的对应关系。图中使用经典的"输入－处理－输出"模型来表示
Web 应用。从 HTTP 请求的输入开始，经过应用的各种处理，最后由 HTTP
响应进行输出。而除了 HTTP
响应外，此处的"输出"还包括访问数据库、读写文件、收发邮件等"与外界交流"的操作。
![{%}](Image00043.jpg)
**图 4-1 Web 应用的功能与安全隐患的对应关系**
换一个角度来看，图 4-1 中的"输出"也能被理解为向外部媒介输出脚本。Web
应用常见的脚本输出和与其对应的安全隐患如下所示。
-   输出 HTML（跨站脚本）
-   输出 HTTP 消息头（HTTP 消息头注入）
-   调用 SQL 语句（SQL 注入）
-   调用 Shell 命令（OS 命令注入）
-   输出邮件头和正文（邮件头注入）
关于各隐患的详情在后面的章节中会进行细述，而从图 4-1
中，我们可以得出以下结论。
-   处理过程与输出过程会产生安全隐患
-   输入过程不会产生安全隐患 [1]{.注释编号}
-   输出过程产生的安全隐患的名称中多数都带有"注入"
[1]{.注释编号下}
仅限于本书探讨的应用程序的安全性。如果将讨论范围扩大至中间件（Middleware），输入校验时也有可能引入安全隐患。
其实，跨站脚本有时也被称为"HTML 注入"或"JavaScript 注入"，因此，图 4-1
中输出过程产生的安全隐患全部为注入型隐患。
综上所述，安全隐患和 Web
应用的功能息息相关。所以在程序设计或编写代码时，就能够根据此时正在实现的功能而得知应当对哪些安全隐患提高警惕。鉴于这种情况，下一节开始，我们将按照
Web 应用的各项功能分类，来详细阐述与其对应的安全隐患。
由于所有的注入型隐患都是基于一些共同的原理，因此，接下来就让我们首先来看一下注入型隐患产生的原因。
#### **注入型隐患**
Web 应用中传递的信息多数为文本格式。HTML、HTTP 和 SQL 等支撑 Web
应用的技术多数都采用了文本格式的接口。
这些文本格式都由各自的语法构成，其中还混合了命令、运算符和数据等。多数情况下，数据部分会通过使用引号（单引号或双引号）或使用被称为分隔符（Delimiter）的符号（逗号、Tab
或换行符等）隔开的方式来加以区分。Web
应用的普遍形式为，首先确定文本的框架结构，然后再将数据填入其中。例如，以下的
SQL 语句中，`$id` 就是被填入的数据。
    SELECT * FROM users WHERE id='$id
    '
`$id`
以外的部分即事先确定的文本结构。然而，如果应用存在安全隐患，就能够更改此
SQL 语句的结构。
举例来说，假设要将以下字符串作为 `$id` 的值填入 SQL 语句。
``` 代码无行号
';DELETE FROM users --
```
填入数据后的 SQL 语句如下。阴影部分即 `$id` 的值。
    SELECT * FROM users WHERE id='';DELETE FROM users --
    '
外界传入的单引号和分号迫使 SELECT 语句结束后，又被添加了 DELETE FROM
语句，这就是 SQL 注入攻击，详情将在 4.4.1 节讲述。
SQL
注入攻击产生的原因为，在被认定为"数据"的位置插入单引号使得数据部分结束，从而更改了
SQL 语句的构造。
这个原理同样也适用于其他的注入型隐患。通过插入引号或分隔符等用于表示"数据部分边界"的字符，从而改变了文本的结构。
表 4-1
列举了各种注入型攻击采用的恶意手段和表示"数据部分边界"的字符。详情在之后介绍各个隐患时会进行细述，此处首先对注入型隐患的产生有着共同的原理这一事实有一大致印象，将有助于理解后面章节的内容。
**表 4-1 注入型隐患的比较**
  隐患名           接口           恶意手段                 数据部分边界
  ---------------- -------------- ------------------------ ------------------------
  跨站脚本         HTML           注入JavaScript等         \ **格式清单 mb_check_encoding 函数**
``` 代码无行号
bool mb_check_encoding(string $var, string $encoding)
```
第一个参数 `$var` 是检验对象字符串，第二个参数 `$encoding`
是字符编码。`$encoding` 可以省略，省略时函数使用 PHP
的内部字符编码。如果 `$var` 字符串的字符编码正确则函数返回 true。
其他编程语言中检验字符编码的方法请参考第 6 章。
#### **转换字符编码**
转换字符编码的方法因编程语言而异。总体上可分为自动转换字符编码的语言和在脚本中手动转换字符编码的语言。PHP
中通过设置 php.ini 文件，可切换上述两种方式。
**表 4-2 主流 Web 开发语言中提供的转换字符编码的方法**
  语言      自动转换               手动转换
  --------- ---------------------- ---------------------
  PHP       php.ini 等             mb_convert_encoding
  Perl      ×                      Encode::decode
  Java      setCharacterEncoding   String 类
  ASP.NET   Web.config             ×
表 4-2 中归纳了主流 Web
开发语言中提供的转换字符编码的方法。接下来、让我们以手动转换字符编码的方式为例进行说明。
PHP 中使用 `mb_convert_encoding` 函数来手动转换字符编码。
> **格式清单 mb_convert_encoding 函数**
``` 代码无行号
string mb_convert_encoding(string $str, string $to_encoding, string $from_encoding)
```
`mb_convert_encoding` 函数的 3
个参数分别为：转换前的字符串、转换后的字符编码、转换前的字符编码。返回值为转换后的字符串。
#### **检验并转换字符编码的实例**
这里我们来看一个检验并转换字符编码的实例。以下 PHP 脚本表示的是接收
Shift_JIS 编码的文字列 `name` 后将其显示在页面上。脚本的内部编码为
UTF-8，所以需要使用 `mb_convert_encoding` 函数来转换文字编码。
> **代码清单 /42/42-001.php**
``` 代码无行号
名字为  
```
正常情况下执行结果如图 4-3 所示。
![{%}](Image00045.jpg)
**图 4-3 42-001.php 执行结果示例（正常情况）**
下图为使用不符合 Shift_JIS 编码的字符串 %82%21 时的页面显示。由于
Shift_JIS 双字节的第二个字节必须是 0x40 以上的值，而 %20
不符合要求，所以是无效的 Shift_JIS 数据。相关详情可参考第 6 章。
![{%}](Image00046.jpg)
**图 4-4 输入值不符合 Shift_JIS 编码**
> **专栏：字符编码的自动转换与安全性**
>
> 前面提到 PHP 中能通过编辑 php.ini
> 使字符编码自动转换。其实，也有些编程语言，如 Java 与
> .NET，主要使用自动转换字符编码。
>
> 转换字符编码时，不正确的字符会被删除或被替换为其他字符（`?` 或者
> Unicode 的替换字符
> U+FFFD），因此，即便是自动转换字符，也能够防御利用字符编码的攻击手段。
>
> 虽然使用自动转换能让写代码的工程轻松不少，但也存在以下缺点。
>
> -   用户没有注意到程序内部出现了文字乱码而继续操作
>
> -   迁移服务器等导致 php.ini 文件被改变后，会有丢失校验操作的风险
>
> 因此，本书专门介绍了检验字符编码和手动转换字符编码的方法。
>
> 至于如何选择自动转换与手动转换，需要在了解两者各自的优缺点的前提下，在开发团队中达成统一认识，或者在进行各个项目时分别选择。
#### **输入校验**
处理完字符编码的相关操作后，就进入到了输入校验的阶段。下面，让我们首先了解一下
Web 应用中输入校验的概要，并在此基础上探讨输入校验与安全性的关系。
-   **输入校验的目的**
    为了理解输入校验的目的，我们首先来看一下没有对输入值进行校验的 Web
    应用的情况。如果 Web
    应用没有对输入值进行校验的话，或许就会出现以下现象。
    -   用户在只接受数值的项目中填入了字母或标点符号，导致保存至数据库时发生错误