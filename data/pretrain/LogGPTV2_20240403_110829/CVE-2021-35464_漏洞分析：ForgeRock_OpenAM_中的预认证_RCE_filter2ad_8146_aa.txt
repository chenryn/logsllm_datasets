# CVE-2021-35464 漏洞分析：ForgeRock OpenAM 中的预认证 RCE
|
##### 译文声明
本文是翻译文章
译文仅供参考，具体内容表达以及含义原文为准。
## 0x00 前述
2021 年 6 月 29 日，安全研究员 Michael Stepankin 发布了CVE-2021-35464，这是
ForgeRock访问管理器身份和访问管理软件中的预认证远程代码执行 (RCE) 漏洞。ForgeRock 为许多企业提供前端 Web
应用程序和远程访问解决方案。
前几天是在360漏洞通告看到了这个漏洞，心血来潮第一次分析框架漏洞，就从这个开始吧。
## 0x01 前置知识
###  Java反序列化
**序列化** 是将复杂的数据结构（例如对象及其字段）转换为可以作为顺序字节流发送和接收的“更扁平”格式的过程。
序列化数据使得以下操作变得更加简单：
  * 将复杂数据写入进程间内存、文件或数据库
  * 例如，通过网络、应用程序的不同组件之间或在 API 调用中发送复杂数据
我理解他能节约内存，尤其面对大范围请求的时候。
关键是，当序列化一个对象时，它的状态也会被持久化。换句话说，对象的属性及其分配的值都被保留下来。
**反序列化**
是将此字节流恢复为原始对象的完整功能副本的过程，其状态与序列化时的状态完全相同。然后网站的逻辑可以与这个反序列化的对象进行交互，就像与任何其他对象一样。
很多语言都支持反序列化，比如 PHP、Ruby 和 Java 都可以反序列化。
不同于 PHP 的反序列化，Java 的反序列化更难读懂。序列化的 Java 对象总是以相同的字节开始，比如16进制的`ac
ed`或者`rO0`这样的Base64编码。
使用 JDK 中的 `ObjectOutputStream` 这个类，调用
`writeObject`来进行二进制格式写入，`ObjectInputStream` 这个类中使用
`readObject()`方法读取二进制流，转换为对象。这差不多和 PHP 的能对应起来。
以下是一个示例（对于从没有接触过java反序列化而言）：
我们先建立一个项目，建立两个class，一个`Person`，一个`TestObjSerializeAndDeserialize`，确定好反序列化ID和方法。
    public class Person implements Serializable {
        /**
         * 序列化ID
         */
        private static final long serialVersionUID = -5809782578272943999L;
        private int age;
        private String name;
        private String sex;
        public int getAge() {
            return age;
        }
        public String getName() {
            return name;
        }
        public String getSex() {
            return sex;
        }
        public void setAge(int age) {
            this.age = age;
        }
        public void setName(String name) {
            this.name = name;
        }
        public void setSex(String sex) {
            this.sex = sex;
        }
    }
在`TestObjSerializeAndDeserialize`中先序列化一次，保存下来，再反序列化一次。
    public class TestObjSerializeAndDeserialize {
        public static void main(String[] args) throws Exception {
            SerializePerson();//序列化Person对象
            Person p = DeserializePerson();//反序列Perons对象
            System.out.println(MessageFormat.format("name={0},age={1},sex={2}",
                    p.getName(), p.getAge(), p.getSex()));
        }
        /**
         * MethodName: SerializePerson
         * Description: 序列化Person对象
         * @author xudp
         * @throws FileNotFoundException
         * @throws IOException
         */
        private static void SerializePerson() throws FileNotFoundException,
                IOException {
            Person person = new Person();
            person.setName("gacl");
            person.setAge(25);
            person.setSex("男");
            // ObjectOutputStream 对象输出流，将Person对象存储到E盘的Person.txt文件中，完成对Person对象的序列化操作
            ObjectOutputStream oo = new ObjectOutputStream(new FileOutputStream(
                    new File("D:/Person.txt")));
            oo.writeObject(person);
            System.out.println("Person对象序列化成功！");
            oo.close();
        }
        /**
         * MethodName: DeserializePerson
         * Description: 反序列Perons对象
         * @author xudp