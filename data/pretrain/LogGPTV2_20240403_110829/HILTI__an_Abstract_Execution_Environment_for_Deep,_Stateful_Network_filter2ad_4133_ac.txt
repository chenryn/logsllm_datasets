};
extern http_requestline_object*
http_requestline_parse(hlt_bytes *,
hlt_exception **);
(b) C prototypes generated by HILTI compiler. The host
application calls http_requestline_parse to parse a
request line.
[binpac] RequestLine
[binpac]
[binpac]
[binpac]
[binpac]
method = ‘GET’
uri = ‘/index.html’
Version
number = ‘1.1’
(c) Debugging output showing ﬁelds as input is parsed.
Figure 6: BinPAC++ example (slightly simpliﬁed).
Figure 6 (a) shows an excerpt of a BinPAC++ grammar
for parsing an HTTP request line (e.g., GET /index.html
HTTP/1.1).
In Figure 6 (b) we show the C prototype for the
generated parsing function as exposed to the host application, in-
cluding a struct type corresponding to the parsed protocol data unit
(PDU). At runtime, the generated HILTI code allocates instances
of this type and sets the individual ﬁelds as parsing progresses, as
the debugging output in Figure 6 (c) shows for an individual re-
quest. When the parser ﬁnishes with a ﬁeld, it executes any call-
backs (hooks) that the host application speciﬁes for that ﬁeld. If
the grammar does not include hooks, the host application can still
extract the parsed data from the returned struct (as Figure 6 (b) ex-
empliﬁes) after HILTI ﬁnishes processing the type.3
BinPAC++ provides the same functionality as the original im-
plementation, and we converted parsers for HTTP and DNS over
to the new system.
Internally, however, we could structure Bin-
PAC++ quite differently by taking advantage of HILTI’s abstrac-
tions. While the original BinPAC provides its own low-level
runtime library for implementing domain-speciﬁc data types and
buffer management, we now use HILTI’s primitives and idioms,
which results in higher-level code and a more maintainable parser
generator. Leveraging HILTI’s ﬂexible control-ﬂow, we can now
generate fully incremental LL(1)-parsers that postpone parsing
3 An advantage of using hooks is that HILTI could optimize away
the parsing of unused ﬁelds and also avoid further unnecessary data
copying (not implemented yet).
whenever they run out of input and transparently resume once more
becomes available. In contrast, the C++ parsers of the original Bin-
PAC need to manually manage the parsing process and further rely
on an additional PDU-level buffering layer that often requires ad-
ditional hints from the grammar writer to work correctly. Finally,
while the original BinPAC requires the user to write additional C++
code for any logic beyond describing basic syntax layout, Bin-
PAC++ extends the grammar language with semantic constructs for
annotating, controlling, and interfacing to the parsing process, in-
cluding support for keeping arbitrary state, by compiling them to
corresponding HILTI code.
BinPAC++ remains independent of a speciﬁc host application
because HILTI generates external C interfaces for the compiled
parsers. We demonstrate this functionality by extending Bro to both
drive the parsing and use the results, just as it does with its built-in
protocol parsers. As Bro decodes protocols, it executes event han-
dlers written in Bro’s custom scripting language. For example, the
internal TCP parser generates a connection_established
event for any successful three-way handshake, passing along meta-
data about the corresponding connection as the event’s argument.
Similarly, Bro’s HTTP parser generates http_request and
http_reply events for client and server trafﬁc, respectively. To
deﬁne the events that BinPAC++ will generate for Bro, we add
additional “event conﬁguration ﬁles”. Figure 7 showcases the in-
teraction between the two systems: (a) shows a basic BinPAC++
grammar to parse SSH banners; the event conﬁguration ﬁle in (b)
tells Bro to trigger an ssh_banner event whenever the generated
code ﬁnishes parsing an SSH::Banner unit; and (c) shows cor-
responding Bro script code that implements a simple handler for
that event. Finally, (d) demonstrates the usage: Bro loads the event
conﬁguration ﬁle from the command line, pulls in the correspond-
ing BinPAC++ grammar, compiles the grammar into HILTI parsing
code, and generates internal HILTI glue code that at runtime inter-
faces back to Bro’s event engine for triggering the deﬁned events.
Bro Script Compiler.
Our ﬁnal application implements a compiler for Bro scripts [37].
Unlike purely signature-based NIDSs, Bro’s domain-speciﬁc,
Turing-complete scripting language decouples the system from any
speciﬁc analysis model. In addition to detection tasks, Bro uses its
language also for higher-level analysis logic in the form of library
functionality that ships with the distribution. For example, most
protocol-speciﬁc scripts perform per-session state-tracking, such as
the HTTP analysis correlating replies with earlier requests.
To demonstrate that HILTI can indeed support such a complex,
highly stateful language, we developed a Bro plugin that translates
all loaded scripts into corresponding HILTI logic, mapping Bro
constructs and data types to HILTI equivalents as appropriate. The
plugin executes the HILTI toolchain just-in-time, generating native
code at startup. When Bro generates events, it triggers the HILTI
code instead of going through its standard script interpreter.
With HILTI’s rich set of high-level data types we generally found
mapping Bro types to HILTI equivalents straightforward. While
Bro’s syntax is complex, the compiler can generally directly con-
vert its constructs to HILTI’s simpler register-based language. Fig-
ure 8 shows a simple example compiling two event handlers track-
ing the server addresses of all established TCP connections. As the
example shows, the compiler translates Bro’s event handler into
HILTI hooks (which are, roughly, functions with multiple bodies
that all execute upon invocation).
466module SSH;
export type Banner = unit {
magic
: /SSH-/;
version : /[^-]*/;
dash
software: /[^\r\n]*/;
: /-/;
};
global hosts: set[addr];
event connection_established(c: connection) {
add hosts[c$id$resp_h]; # Record responder IP.
}
event bro_done() {
for ( i in hosts ) # Print all recorded IPs.
(a) BinPAC++ grammar for SSH banners in ssh.pac2.
}
print i;
grammar ssh.pac2; # BinPAC++ grammar to compile.
# Define the new parser.
protocol analyzer SSH over TCP:
parse with SSH::Banner, # Top-level unit.
port 22/tcp,
# Port to trigger parser.
# For each SSH::Banner, trigger an ssh_banner() event.
on SSH::Banner
-> event ssh_banner(self.version, self.software);
(b) Event conﬁguration ﬁle in ssh.evt.
event ssh_banner(version: string, software: string) {
print software, version;
}
(c) Bro event handler in ssh.bro.
# bro -r ssh.trace ssh.evt ssh.bro
OpenSSH_3.9p1, 1.99
OpenSSH_3.8.1p1, 2.0
(d) Output with a single SSH session (both sides).
Figure 7: Bro/BinPAC++ interface example.
Our prototype compiler supports most features of the Bro script-
ing language.4 Speciﬁcally, it supports running Bro’s default HTTP
and DNS analysis scripts, which we use as representative case stud-
ies in our evaluation (see §6). The HTTP and DNS scripts generate
extensive logs of the corresponding protocol activity, correlating
state across request and reply pairs, plus (in the case of HTTP) ex-
tracting and identifying message bodies.
5.
IMPLEMENTATION
We now discuss our prototype HILTI implementation, which
consists of a C++-based compiler along with a C runtime library.
In addition, we have implemented the four application scenarios we
discuss in §4 in the form of (i) Python scripts for the two proof-of-
concepts (BPF and Firewall); (ii) a C++ compiler to translate Bin-
PAC++ grammars into HILTI; and (iii) a Bro plugin in C++ that
(a) provides a runtime interface to BinPAC++ parsers and (b) com-
piles Bro script code into HILTI and executes it. HILTI, BinPAC++,
and the Bro plugin come with a total of about 850 unit tests ensur-
ing correctness. Unless indicated otherwise, our implementation
implements all functionality discussed in this paper, and we release
it to the community as open-source software under a BSD-style
license [6]. As a large part of the implementation represents an ap-
plication of well-known compiler techniques, we focus on some of
the more interesting aspects in the following.
4We currently exclude some rarely used constructs as well as a
small set of advanced functionality that does not have direct HILTI
equivalents yet. In particular, the compiler lacks support for Bro’s
when statement, which triggers script code asynchronously once
a speciﬁed global condition becomes true. We plan to add watch-
points to HILTI to support that functionality. Only few scripts make
use of that capability, most commonly for resolving DNS names.
(a) Bro event handlers in track.bro.
global ref> hosts = set()
[... Definitions for "connection" and "conn_id" ...]
hook void connection_established(ref c) {
local addr __t1
local ref __t2
__t2 = struct.get c id
__t1 = struct.get __t2 resp_h
set.insert hosts __t1
}
hook void bro_done() {
for ( i in hosts ) {
call Hilti::print (i)
}
}
(b) Compiled HILTI code (slightly simpliﬁed for readability).
# bro -b -r wikipedia.pcap compile_scripts=T track.bro
208.80.152.118
208.80.152.2
208.80.152.3
(c) Output with a small sample trace containing 3 servers.
Figure 8: Bro compiler example.
Code Generation. The compiler hiltic receives HILTI ma-
chine code for compilation, as illustrated in Figure 2, which it
then compiles into LLVM’s instruction set. LLVM is an industrial-
strength, open-source compiler toolchain that models a low-level
but portable register machine. We also compile HILTI’s runtime li-
brary into LLVM’s representation, using the accompanying C com-
piler clang. We then link all of the parts together, ﬁrst with a custom
linker (see below), followed by LLVM’s linker; and ﬁnally compile
the result into native machine code. Besides generating machine
code, LLVM also implements domain-independent code optimiza-
tions. All parts of the code generation can either take place stati-
cally, producing a native binary to execute; or just-in-time inside a
host application.
Linker. We add a specialized linker to our toolchain to support
the HILTI compiler through custom transformations at the LLVM-
level, enabling HILTI features that require a global view of all com-
pilation units. For example, we maintain thread-local state per vir-
tual thread and hence cannot leverage the corresponding pthread-
style functionality directly because it only separates the underly-
ing hardware threads. HILTI’s runtime associates with each vir-
tual thread a separate array that contains a copy of all thread-local
variables. However, as one compilation unit might access thread-
locals deﬁned in another, only the link stage has the global view
necessary to determine the ﬁnal layout of that array. Accordingly,
our custom linker ﬁrst merges all thread-locals across units into a
single array structure, and then adapts all instructions to that ag-
gregate layout. We use a similar link-time mechanism to support
hooks across compilation units.
467Runtime Model. With each virtual thread HILTI’s runtime as-
sociates a context object that stores all its relevant state, including
the array of thread-locals discussed above, the currently executing
ﬁber (for suspending execution; see §3.2), timers scheduled for ex-
ecution inside the thread, and exception status. Internally, we use
a custom calling convention for compiled functions (as well as the
runtime library) that passes the context object as an additional hid-
den object. HILTI currently propagates exceptions up the stack
with explicit return value checks after each function call, which in-
curs a slight overhead. In the future we might switch to C++-style
DWARF exceptions, which come with zero costs when not raising
any exception.
HILTI garbage-collects dynamically allocated memory via refer-
ence counting—a technique Bro has proven a good match for the
domain. While generally considered less efﬁcient than mark-and-
sweep collectors [26], reference counting is not only less complex
to implement, but its incremental operation and short deallocation
times also ﬁt better with real-time constrains. The HILTI compiler
emits reference count operations transparently during code gener-
ation as necessary. It does so rather freely at the moment, but we
plan to add an optimization pass that removes redundant counter
operations and also applies further optimizations similar to those
that ARC [3] deploys. Our implementation currently lacks a cycle
detector (as does Bro).
When implementing ﬁbers, we considered several alternatives,
including CPS-conversion [10] and manually copying the stack on
demand. We settled on a setcontext-based scheme that proves
both simple and efﬁcient for supporting the large number of context
switches that HILTI relies upon for implementing both incremen-
tal processing and virtual threads. The setcontext primitive
allows a program to temporarily switch its stack over to a self-
allocated memory segment, saving and later restoring processor
registers to continue at the original location. A challenge with that
approach lies in sizing the custom stacks correctly: if they remain
too small, they will overﬂow; if too large, they will waste mem-
ory. While LLVM’s code generator offers “segmented stacks” [12]
as a mechanism to start with a small stack and then grow dynam-
ically, this feature turns out complex, non-portable, and rather in-
efﬁcient. Instead we follow the lead of Rust [8] and leverage the
MMU: we request large worst-case-sized memory segments with
mmap() and rely upon the MMU to not actually allocate physi-
cal memory pages until it sees accesses. That approach performs
well in practice: using libtask’s optimized setcontext imple-
mentation [2] along with a custom free-list for recycling stacks, a
micro-benchmark shows that the HILTI runtime can perform about
18 million context switches per second between existing ﬁbers on
a Xeon 5570 CPU. It furthermore supports about 5 million cycles
per second of creating, starting, ﬁnishing, and deleting a ﬁber. We
also conﬁrmed that the memory usage indeed corresponds to the
space in use, versus the amount allocated. We hence conclude that
our ﬁber implementation provides the necessary performance.
Runtime Library. The runtime library implements the more
complex HILTI data types—such as maps, regular expressions,
and timers—as C functions called out to by the generated LLVM
code. LLVM can inline function calls across link-time units and
thus may eliminate the extra overhead of these invocations. The
runtime library also implements the threading system with a corre-
sponding scheduler, mapping virtual threads to native threads and
scheduling jobs on a ﬁrst-come, ﬁrst-served basis. For functional-
ity that requires serial execution, the runtime provides a command
queue to send operations from arbitrary threads to a single dedi-
cated manager thread. HILTI uses this mechanism, for example,
for ﬁle output occurring from multiple threads concurrently. Gen-
erally, all runtime functionality is fully thread-safe, 64-bit code.
However, we have not yet focused on efﬁciency when implement-
ing runtime functionality. For example, we currently implement
the classifier type as a linked list internally, which does not
scale with larger numbers of rules.
It will be straightforward to
later transparently switch to a better data structure for packet clas-
siﬁcation [22].
Bro Interface. When adding the Bro interface for compiling
BinPAC++ and scripts, we faced two main challenges: (i) we had to
hook the generated code into Bro’s processing at a number of points
across its code base; and (ii) execution needs to translate back and
forth between Bro’s internal representation of data types and those
of HILTI. For the former, we started with a Bro development ver-
sion based on release 2.2 that comes with an early version of a new
plugin interface, which enables us to load additional Bro function-
ality at runtime in the form of shared libraries. We extended that
interface to provide further hooks into the script infrastructure and
then implemented all HILTI-speciﬁc code as a plugin.
The translation between data types turned out to be more dif-
ﬁcult.
Internally, Bro represents all script values as instances
of classes derived from a joint Val base class (e.g., there is an
EnumVal, a TableVal, etc.). Unfortunately these instances are
not only used by the script interpreter itself, but also passed around
to most other parts of Bro’s code base. Therefore, even when we
replace the interpreter with our compiled code, to interface to the
rest of Bro—e.g., for feeding data into the logging system—we still
need to create instances of these value classes. Similarly, we also
need to convert Val’s into the corresponding HILTI representation
when generating events. Consequently, our HILTI plugin needs to
generate a signiﬁcant amount of glue code, which comes with a cor-
responding performance penalty as we discuss in §6. In practice,