title:Fable: A Language for Enforcing User-defined Security Policies
author:Nikhil Swamy and
Brian J. Corcoran and
Michael Hicks
2008 IEEE Symposium on Security and Privacy
FABLE: A Language for Enforcing User-deﬁned Security Policies
Nikhil Swamy
Brian J. Corcoran
Michael Hicks
University of Maryland, College Park
{nswamy, bjc, mwh}@cs.umd.edu
Abstract
This paper presents FABLE, a core formalism for a pro-
gramming language in which programmers may specify se-
curity policies and reason that these policies are properly
enforced. In FABLE, security policies can be expressed by
associating security labels with the data or actions they pro-
tect. Programmers deﬁne the semantics of labels in a sepa-
rate part of the program called the enforcement policy. FA-
BLE prevents a policy from being circumvented by allowing
labeled terms to be manipulated only within the enforce-
ment policy; application code must treat labeled values
abstractly. Together, these features facilitate straightfor-
ward proofs that programs implementing a particular pol-
icy achieve their high-level security goals. FABLE is ﬂexible
enough to implement a wide variety of security policies, in-
cluding access control, information ﬂow, provenance, and
security automata. We have implemented FABLE as part of
the LINKS web programming language; we call the result-
ing language SELINKS. We report on our experience us-
ing SELINKS to build two substantial applications, a wiki
and an on-line store, equipped with a combination of ac-
cess control and provenance policies. To our knowledge, no
existing framework enables the enforcement of such a wide
variety of security policies with an equally high level of as-
surance.
1
Introduction
For 35 years or more, computer security researchers have
explored techniques for ensuring that a software system cor-
rectly enforces its security policy, and that, as a result, the
software exhibits a desirable security property [22]. A no-
table success toward this goal has been work on deﬁning
Prepared through collaborative participation in the Communications and Networks
Consortium sponsored by the U. S. Army Research Laboratory under the Collabo-
rative Technology Alliance Program, Cooperative Agreement DAAD19-01-2-0011.
The U. S. Government is authorized to reproduce and distribute reprints for Govern-
ment purposes notwithstanding any copyright notation thereon. This work was also
supported in part by NSF grant CCF-0524036.
programming language-based techniques for enforcing in-
formation ﬂow security policies [32]. A common form of
information ﬂow policy deﬁnes a set of security levels that
can be ordered as a lattice, where sensitive data within a
program is assigned a label derived from this lattice.Correct
enforcement of this policy implies that a program exhibits
some ﬂavor of noninterference, which states that no infor-
mation visible at level h can be leaked onto a channel visible
to level l < h. By including the notion of a security label in
a programming language’s types, one can show that a cor-
rectly typed program is certain to enforce its security pol-
icy [41]. This approach has been implemented successfully
in the Jif [10] and FlowCaml [30] languages.
While information ﬂow policies are useful and impor-
tant, there are many other styles of policy that are in com-
mon use, including access control, type enforcement [4]
(as in SELinux [26]), tainting [35, 37] (e.g., via Perl’s
taint mode [29]), provenance tracking [7], stack inspec-
tion [17, 14], and forms of security automata [17, 42]. One
approach to verifying the correct enforcement of these poli-
cies is to encode them as information ﬂow policies for pro-
grams written in Jif of FlowCaml. While this will work
in some cases (e.g., access control, type enforcement, and
tainting could be encoded in conjunction with Jif’s declas-
siﬁcation operators [33]) it is not likely to scale. For exam-
ple, Jif’s use of noninterference as a baseline property and
its attendant restrictions on implicit ﬂows via the program’s
control ﬂow, can be cumbersome to work with. Moreover,
Jif and FlowCaml ﬁx the format of security labels, which
complicates the means to interface with external infrastruc-
ture, such as policy management systems, databases, etc.
What we want is a programming language that can en-
force a wide range of policies—including, but not limited
to, information ﬂow—while providing the same assurance
as Jif or FlowCaml that programs enforce their policies cor-
rectly. As a step toward this goal, this paper presents FA-
BLE, a core language for writing programs that enforce a va-
riety of security policies. A key observation is that many se-
curity policies work by associating labels with data, where
the label expresses the security policy for that data. What
varies among policies is the speciﬁcation and interpretation
978-0-7695-3168-7 /08 $25.00 © 2008 IEEE
DOI 10.1109/SP.2008.29
369
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply. 
of labels, in terms of the actions that are permitted or de-
nied.
This observation is embodied in FABLE in two respects.
First, programmers can deﬁne custom security labels and
associate them with the data they protect using dependent
types. For example, a programmer could deﬁne a label
LOW, and an integer value protected by this label would
have type int{LOW}. As another example, the programmer
could deﬁne a label ACL(Alice, Bob) where an integer with
type int{ACL(Alice, Bob)} is meant to be accessed by only
Alice or Bob. Second, programmers deﬁne the interpreta-
tion of labels in special enforcement policy functions sepa-
rated from the rest of the program. For example, the seman-
tics of our access control label could be implemented by the
following enforcement policy function:
policy access simple (acl:lab, x:int{acl}) =
if (member user acl) then {◦}x else −1
This function takes a label like ACL(Alice, Bob) as its ﬁrst
argument, and an integer protected by that ACL as its sec-
ond argument. If the current user (represented by variable
user) is a member of x’s ACL (according to some function
member, not shown), then x is returned with its label re-
moved, expressed by the syntax {◦}x, so that it can be ac-
cessed by the main program. If the membership test fails, it
returns −1 and x’s value is not released.
FABLE does not, in and of itself, guarantee that a security
policy is correctly implemented, but FABLE’s design greatly
simpliﬁes proof of this fact. In particular, FABLE’s type sys-
tem ensures that labeled data (that is, data with a type t{l})
is treated abstractly by the main program, since terms with a
labeled type can only be constructed, examined, or changed
within enforcement policy code. Moreover, FABLE’s type
system ensures that the main program cannot sever or forge
the association between a label and the data it protects. In
effect, FABLE ensures complete mediation of the user’s la-
bel policy in that no data can be accessed without consulting
the correct security policy.
To demonstrate FABLE’s ﬂexibility we have used it to en-
code a range of policies, including access control, static [32]
and dynamic information ﬂow [46] with forms of declas-
siﬁcation [20], provenance tracking [7] and policies based
on security automata [42].
In our experience, the sound-
ness of FABLE makes proofs of security properties no
more difﬁcult—and arguably simpler—than proofs of sim-
ilar properties in specialized languages [30, 40, 41]. To
demonstrate this fact we present proofs of correctness for
our access control, provenance, and static information ﬂow
policies. FABLE opens the possibility of partially automat-
ing such proofs, along the lines of user-deﬁned type sys-
tems [8], though we leave exploration of this issue to future
work. To our knowledge, no existing framework enables the
enforcement of such a wide variety of security policies with
an equally high level of assurance.
To evaluate FABLE’s practicality we have implemented
FABLE as an extension to the LINKS web programming
language [12]. We call the resulting language SELINKS
(for Security-Enhanced LINKS). We have built two sub-
stantial applications using SELINKS: SEWIKI, a 3500-line
secure blog/wiki inspired by Intellipedia [31] that imple-
ments a combined access control and provenance policy,
and SEWINESTORE, a 1000-line e-commerce application
distributed with LINKS extended with an access control pol-
icy.
In general, we have found that FABLE’s label-based
security policies are neither lacking nor burdensome, and
the modular separation of the enforcement policy permitted
some reuse of policy code between the two applications.
In the remainder of the paper we present FABLE, our core
language for deﬁning and enforcing custom, label-based se-
curity policies (Section 2). We show how FABLE can be
used to deﬁne a range of security policies and that FABLE’s
design simpliﬁes proofs that these policies are implemented
correctly (Section 3). In Section 4 we discuss our SELINKS
implementation of FABLE for building web applications
and our experience building SEWIKI and SEWINESTORE.
Section 5 discusses related work, and Section 6 sketches fu-
ture work and concludes.
2 FABLE: System F with Labels
This section presents the syntax, static semantics, and
operational semantics of FABLE. The next section illus-
trates FABLE’s ﬂexibility by presenting example policies
along with proofs of their attendant security properties.
2.1. Syntax
Figure 1 deﬁnes FABLE’s syntax. Throughout, we use
the notation (cid:126)a to stand for a list of elements of the form
a1, . . . ,an; where the context is clear, we will also treat (cid:126)a as
the set of elements {a1, . . . ,an}.
Expressions e extend a standard polymorphic λ -
calculus, System F [16]. Standard forms include integer
values n, variables x, abstractions λ x:t.e, term application
e1 e2, the ﬁxpoint combinator ﬁx x:t.v, type abstraction Λα.e
and type application e[t]. We exclude mutable references
from the language to simplify the presentation. Our tech-
nical report [38] extends the language with references and
considers their effect on various policies, e.g., information
ﬂows through side effects.
The syntactic constructs speciﬁc to FABLE are distin-
guished in Figure 1. The expression C((cid:126)e) is a label, where
C represents an arbitrary constructor and each ei ∈ (cid:126)e must
itself be a label; e.g., in ACL(Alice, Bob), ACL is 2-ary label
constructor and Alice and Bob are 0-ary label constructors.
Labels can be examined by pattern matching. For example,
370
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:10:14 UTC from IEEE Xplore.  Restrictions apply. 
Expressions
(Fable-speciﬁc)
Types
(Fable-speciﬁc)
e
t
::= n | x | λ x:t.e | e1 e2 | ﬁx x:t.v | Λα.e | e[t]
|
::= int | α | ∀α.t2 | (x:t1) → t2
|
C((cid:126)e) | match e with pi ⇒ ei | ([e]) | {◦}e | {e(cid:48)}e
lab | lab∼e | t{e}
Patterns
Pre-values
App. values
Policy values
p
u
vapp
vpol
::= x | C((cid:126)p)
::= n | C((cid:126)u) | λ x:t.e | Λα.e
::= u | ([{e}vpol])
::= u | {e}vpol
Figure 1. Syntax of FABLE
the expression match z with ACL(x,y) ⇒x would evaluate to
Alice if z’s run-time value were ACL(Alice, Bob).
As explained earlier, FABLE introduces the notion of an
enforcement policy that is a separate part of the program
authorized to manipulate the labels on a type. Following
Grossman et al. [18] we use bracketed expressions ([e]) to
delimit policy code e from the main program. In practice,
one could use code signing as in Java [17] to ensure that
untrusted policy code cannot be injected into a program.As
illustrated earlier, the expression {◦}e removes a label from
e’s type, while {e(cid:48)}e adds one. Labeling and unlabeling
operations may only occur within policy code; we discuss
these operations in detail below.
Standard types t include int, type variables α, and univer-
sally quantiﬁed types ∀α.t. Functions have dependent type
(x:t1) → t2 where x names the argument and may be bound
in t2. We illustrate the usage of these types shortly. Labels
can be given either type lab or the singleton type lab∼e,
which describes label expressions equivalent to e. For ex-
ample, the label constructor High can be given the type lab
and the type lab∼High. Singleton types are useful for con-
straining the form of label arguments to enforcement policy
functions. For example, we could write a specialized form
of our previous access simple function:
policy access pub (acl:lab∼ACL(World), x:int{acl}) = {◦}x
The FABLE type checker ensures this function is called only
with expressions that evaluate to the label ACL(World)—
i.e., the call access pub(ACL(Alice,Bob),e) will be rejected.
In effect, the type checker is performing access control at
compile time according to the constraint embodied in the
type. We will show in Section 3.3 that these constraints are
powerful enough to encode an information ﬂow policy that
can be checked entirely at compile time.
The dependent type t{e} describes a term of type t
that is associated with a label e. Such an association is
made using the syntax {e}e(cid:48). For example, {High}1 is
an expression of type int{High}. Conversely, this asso-
ciation can be broken using the syntax {◦}e. For ex-
ample, {◦}({High}1) has type int. Now we can illus-
trate how dependent function types (x:t1) → t2 can be
used. The function access simple can be given the type
(acl:lab) →(x:int{acl}) →int which indicates that the ﬁrst
argument acl serves as the label for the second argument
x. Instead of writing (x:t1) → t2 when x does not appear in
t2, we simply omit it. Thus access simple’s type could be
written (acl:lab) →int{acl} →int.
The operational semantics of Section 2.3 must distin-
guish between application and policy values in order to en-
sure that policy code does not inadvertently grant undue
privilege to application functions. Application values vapp
consist of either “pre-values” u—integers n, labels contain-
ing values, type and term abstractions—or labeled policy
values wrapped with ([·]) brackets. Values within policy code