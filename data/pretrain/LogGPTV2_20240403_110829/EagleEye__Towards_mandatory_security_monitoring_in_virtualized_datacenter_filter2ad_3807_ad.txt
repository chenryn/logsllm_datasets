{hC}
D1
D4
D2
D5
D7
D8
D3
D9
disk
D1
D3
D2
D7
D8
Meta
Meta
Dom U (Guest VM)
High-level events
hA = open(“c:\a.exe”, FILE_WRITE)
….
close(hA)
hB = open(“c:\b.dll”, FILE_WRITE)
write(hB, 2, D7)
write(hB, 5, D8)
write(hB, 6, D9)
hC = open(“c:\c.sys”, FILE_WRITE)
1
2
3
Memory 
Mgmt.
File 
system
Storage
Mgmt.
I/O 
system
cache
D4
D5
Meta
D9
Introspection of high-level states are difficult
Figure 12. State replication for file writes 
EagleEye  maintains  a  per-VM  table  in  the  EagleEye 
daemon at Dom 0 for files that are opened for write access in 
each  guest  system  as  shown  in  Figure  12.  Each  table  entry 
corresponds to one file. The entry contains the path to the file, 
its associated file descriptors, the file’s memory-mapped views 
if any, and most importantly, a buffer holding the data written 
to  the  file  thus  far.  Essentially,  every  file  write  in  the  guest 
system  will  result 
the 
corresponding  table  entry.  File  open  and  file  write  events  are 
captured  through  intercepting  the  respective  system  calls. 
Memory-mapped  file  I/O  are  also  tracked  by  intercepting 
NtUnmapViewOfSection,  NtMapViewOfSection,  ant 
NtCreateSection.  When  a  mapped  view  is  about  to  be 
closed or when the memory mapped file is about to be closed, 
EagleEye will synchronize the data from the mapped memory 
regions  to  the  write  buffer.  The  associated  memory-mapped 
views will then be removed from the write buffer entry. 
in  an  update 
the  buffer 
to 
in 
When  a  security  monitor  wants  to  access  the  content  of  a 
file,  EagleEye  will  by  default  serve  the  content  through  disk 
introspection.  For  those  data  blocks  that  have  just  been 
overwritten,  the  content  will  be  pulled  from  the  write  buffer. 
This ensures that the security monitor always has a consistent 
view  of  the  current  file  content  as  perceived  by  the  guest 
system. If a write buffer entry has associated memory-mapped 
views, EagleEye will first synchronize data from the associated 
memory-mapped  views  to  the  write  buffer  before  serving  the 
write buffer data to the security monitor.   
A write buffer block can be freed when the data hold by the 
block has been flushed to the disk. The current implementation 
relies  on  a  background  garbage  collection  process 
to 
periodically introspect the disk to determine if the current block 
data has been reflected on the disk. A table entry can be safely 
released if all associated descriptors have been closed, and the 
content  in  the  buffer  has  all  been  flushed  to  the  disk.  The 
current implementation may double the space required for disk 
storage in the worst case. If storage space is of a concern, it is 
possible to employ further optimization to reduce the space cost. 
For instance, the virtual disk subsystem (e.g. QEMU-dm) can 
be hooked to detect guest disk flushing events so the garbage 
collection process can be triggered timely.  
E.  Assumption of System Model 
The  implementation  depends  on  knowledge  about  the 
entry/exit  points  of  the  guest  system  call  dispatcher,  the 
semantics of the guest system calls hooked by EagleEye (Table 
2), and the guest application binary interface (ABI) formats.   
The  implementation  does  not  support  SR-IOV  network 
adaptors  [25],  but  the  mandatory  security  monitoring  of 
network  traffic  can  be  transparently  implemented  with  well-
established network intrusion detection appliances. 
is 
in 
the  only  feature 
The quarantine of virus infected files (Step 13 in Figure 10) 
is implemented by hooks in the QEMU block device emulation 
the  current  EagleEye 
layer.  It 
implementation  that  depends  on  the  QEMU  device  emulation 
layer.  Should  the  guest  VM  have  direct  access  to  the  block 
device  controller  and  not  use  the  device  emulation  layer,  the 
quarantine  feature  can  instead  be  implemented  as  stealthy 
hooks in the  guest  kernel (requiring  further  knowledge of the 
guest  system  model)  or  possibly  be  implemented  through 
extensions of the block device controller hardware. 
Table 1. Benchmarks for the experiments 
7-zip compression 
Compression of 13,791 files (the files are collected from the 
folders (Windows\SysWOW64, Windows\System32, and 
Windows\Microsoft.NET) on a freshly installed Windows 
Server 2008) with a total size of 2.55GB. 7-Zip is configured to 
use 4 threads for compression. 
7-zip decompression 
Decompression of the above compressed file. The 
decompression uses only 1 thread. 
Build ClamAV 0.97.5 from source code with Visual studio 2010 
Build ClamAV 
x264 encoding 
Encode a 508mb RMVB file with x264 encoder. The x264 
encoder is configured to use 4 threads. 
V.  EVALUATION 
We  evaluate  EagleEye  through  comparison  with 
the 
baseline system running no security monitor and with systems 
running  conventional 
including 
Kaspersky  Endpoint  Security  8  and  a  home-made  in-VM 
malware  scanner  InVM_AV. 
functionally 
equivalent  to  Kaspersky  from  the  experiment  point  of  view, 
except that it is based on the same ClamAV scan engine as used 
by EagleEye.  
in-VM  security  monitors 
InVM_AV 
is 
For all the experiments, the host machine is equipped with 
two Intel Xeon E5520 processors (a total of 16 logical cores) 
and  16  GB  memory.  The  storage  consists  of  2  SATA  HDDs 
configured  in  JBOD  mode.  The  host  OS  is  Fedora  Core  14 
x86_64. Each guest VM is configured with 4 VCPUs and 4GB 
memory. The guest OS is Windows Server 2008 x86_64 R2. 
A.  Overall Performance 
In  this  experiment,  we  evaluate  the  performance  of 
EagleEye  by  looking  at  the  running  time  of  four  benchmark 
programs  (Table  1)  under  seven  different  security  monitor 
setups:  baseline,  Kaspersky,  Kaspersky*, 
InVM_AV, 
InVM_AV*, EE, and EE*.  
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 07:57:09 UTC from IEEE Xplore.  Restrictions apply. 
7-zip compression
141%
106%
0% 8%
15%
95%
66%
160%
140%
120%
100%
80%
60%
40%
20%
0%
d
a
e
h
r
e
v
O
1200
1000
800
600
400
200
0
i
)
s
c
e
s
(
e
m
T
g
n
n
n
u
R
i
7-zip decompression
684%
1008%
721%
576%
0% 17% 32%
1200%
1000%
800%
600%
400%
200%
0%
d
a
e
h
r
e
v
O
1200
1000
800
600
400
200
0
i
)
s
c
e
s
(
e
m
T
g
n
n
n
u
R
i
i
)
s
c
e
s
(
e
m
T
g
n
n
n
u
R
i
x264 encoding
2%
1%
1%
1%
0%
2400
2000
1600
1200
800
400
0
2%
1%
3%
2%
2%
1%
1%
0%
d
a
e
h
r
e
v
O
Build ClamAV
694%
261%
0% 6% 7%
29%
191%
3000
2500
2000
1500
1000
500
0
i
)
s
c
e
s
(
e
m
T
g
n
n
n
u
R
i
800%
700%
600%
500%
400%
300%
200%
100%
0%
d
a
e
h
r
e
v
O
Figure 13. Benchmark running times for different security monitoring setups. 
The baseline setup is just a clean VM guest system without 
any  security  monitor.  The  Kaspersky  setup  is  a  VM  with  
Kaspersky Endpoint Security 8 installed inside the VM guest. 
The  InVM_AV  setup  is  a  VM  with  the  InVM_AV  scanner 
installed  inside  the  VM  guest.  All  the  above  setups  use  the 
vanilla Xen 4.0.1 hypervisor.  
The  EE setup  uses the EagleEye prototype  system,  which 
includes a modified Xen hypervisor, a modified QEMU device 
model  with  EagleEye  extensions,  and  the  EagleEye  daemon 
with the ClamAV detection engine linked as a shared library. 
The Eagle daemon is configured to use 4 threads.  
InVM_AV,  Kaspersky,  and  EE  only  scan  files  with 
specific extensions such as .COM, .EXE, .DLL, .SYS, and etc. 
(there are a total of 59 extensions in the filter). We also create 
three  additional  setups  that  scan  all  the  files,  which  are 