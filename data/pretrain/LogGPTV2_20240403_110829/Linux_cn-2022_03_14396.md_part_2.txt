解决方案是基于原来的源码提交哈希新建一个分支。我们把这个分支称为**部署分支**。每当一个镜像被推到下游测试或发布环境时，你应该**基于前一个 SDLC 环境的部署分支的最新提交**创建一个新的部署分支。
这样同一个镜像可以重复多次部署到不同的 SDLC 环境，并在后面每个环境中可以感知前面发现的改动或对镜像做的修改。
**注意：** 在某个环境中做的修改是如何影响下一个环境的，是用可以共享数据的工具（如 Helm Charts）还是手动剪切、粘贴到其他目录，都不在本文讨论的范围内。
因此，当一个镜像被从一个 SDLC 环境中推到下一环境时：
1. 创建一个部署分支
	1. 如果镜像是从开发环境中推过来的，那么部署分支就基于构建这个镜像的源码提交哈希创建
	2. 否则，*部署分支基于当前部署分支的最新提交创建*
2. 镜像被部署到下一个 SDLC 环境，使用的部署描述符是该环境中新创建的部署分支的部署描述符
![deployment branching tree](/data/attachment/album/202203/26/111819i57fuypquss4fste.png)
*图 1：部署分支树*
1. 部署分支
2. 下游环境的第一个部署分支，只有一次提交
3. 下游环境的第二个部署分支，只有一次提交
有了部署分支这个解决方案，再回顾下上面的场景 C 和场景 D：
**场景 C** 修改已经部署到下游 SDLC 环境中的镜像的部署描述符
**场景 D** 修复某个 SDLC 环境中部署描述符的错误
两个场景中，工作流如下：
1. 把对部署描述符做的修改提交到 SLDC 环境和镜像对应的部署分支
2. 通过部署分支最新提交对应的部署描述符把镜像重新部署到 SLDC 环境
这样，部署分支彻底解决了（存储着代表一次独一无二的构建的单一的、不可修改的镜像的）镜像仓库与（存储着对应一个或多个 SDLC 环境的可修改的部署描述符的）SCM 仓库之间的阻抗失配。
### 实践中的思考
这看起来像是行得通的解决方案，但同时它也为开发者和运维人员带来了新的实践中的问题，比如：
**A. 为了更好地管理部署分支，部署描述符作为资源应该保存在哪里，是否要与构建镜像的源码保存在同一个 SCM 仓库？**
到目前为止，我们都在避免谈论应该把部署描述符放在哪个仓库里。在还没有太多细节需要处理时，我们推荐把所有 SDLC 环境的部署描述符与镜像源码放在同一个 SCM 仓库。当部署分支创建后，镜像的源码可以作为方便找到部署的容器中运行的镜像的引用来使用。
上面提到过，可以通过镜像的标签来关联镜像与原始的源码提交。在一个单独的仓库中查找某次提交的源码的引用，会给开发者带来更大的困难（即便借助工具），这就是没有必要把所有资源都分开存储的原因。
**B. 应该在部署分支上修改构建镜像的源码吗？**
简答：**不应该**。
详细阐述：不应该，因为永远不要在部署分支上构建镜像，它们是在开发分支上构建的。修改部署分支上定义一个镜像的源码会破坏被部署的镜像的构建记录，而且这些修改并不会对镜像的功能生效。在对比两个部署分支的版本时这也会成为问题。这可能会导致两个版本的功能差异有错误的测试结果（这是使用部署分支的一个很小的额外好处）。
**C. 为什么使用镜像  标签   tag ？ 标记   label  不可以吗？**
通过  标签   tag  可以在仓库中很容易地查找镜像，可读性也很好。在一组镜像中读取和查找  标记   label  的值需要拉取所有镜像的 清单文件   manifest ，而这会增加复杂度、降低性能。而且，考虑到历史记录的追踪和不同版本的查找，对不同版本的镜像添加  标签   tag  也很有必要，因此使用源码提交哈希是保证唯一性，以及保存能即时生效的有用信息的最简单的解决方案。
**D. 创建部署分支的最佳实践是怎样的？**
DevOps 最重要的三个原则：自动化、自动化、自动化。
依赖资源来持续地强迫遵循最佳实践，充其量只是碰运气，因此在实现镜像的升级、回滚等 CI/CD 流水线时，把自动化部署分支写到脚本里。
**E. 对部署分支的命名规范有建议吗？**
--
* **部署分支标识**： 所有部署分支范围内唯一的字符串；如 “deployment” 或 “deploy”
* **环境**： 部署分支适用的 SDLC 环境；如 “qa”（测试环境）、 “stg”（预生产环境）、 或 “prod”（生产环境）
* **源码提交哈希**： 源码提交哈希中包含原来构建被部署的镜像的源码，开发者可以通过它很容易地查找到创建镜像的原始提交，同时也能保证分支名唯一。
例如， `deployment-qa-asdf78s` 表示推到 QA 环境的部署分支， `deployment-stg-asdf78s` 表示推到 STG 环境的部署分支。
**F. 你怎么识别环境中运行的哪个镜像版本？**
我们的建议是把最新的部署分支提交哈希和源码提交哈希添加到 [标记](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) 中。开发者和运维人员可以通过这两个独一无二的标识符查找到部署的所有东西及其来源。在诸如执行回滚或前滚操作时，使用那些不同版本的部署的选择器也能清理资源碎片。
**G. 什么时候应该把部署分支的修改合并回开发分支？**
这完全取决于开发团队。
如果你修改的目的是为了做负载测试，只是想验证什么情况会让程序崩溃，那么这些修改不应该被合并回开发分支。另一方面，如果你发现和修复了一个错误，或者对下游环境的部署做了调整，那么就应该把部署分支的修改合并回开发分支。
**H. 有现成的部署分支示例让我们试水吗？**
[el-CICD](https://github.com/elcicd) 已经在生产上使用这个策略持续一年半应用到超过一百个项目了，覆盖所有的 SDLC 环境，包括管理生产环境的部署。如果你可以访问 [OKD](https://www.okd.io/)、Red Hat OpenShift lab cluster 或 [Red Hat CodeReady Containers](https://cloud.redhat.com/openshift/create/local)，你可以下载[el-CICD 的最新版本](https://github.com/elcicd/el-CICD-RELEASES)，参照 [教程](https://github.com/elcicd/el-CICD-docs/blob/master/tutorial.md) 来学习部署分支是何时以怎样的方式创建和使用的。
### 结语
通过实践上面的例子可以帮助你更好的理解开发过程中阻抗失配相关的问题。对齐镜像和部署描述符是成功管理部署的关键部分。
---
via: 
作者：[Evan "Hippy" Slatis](https://opensource.com/users/hippyod) 选题：[lujun9972](https://github.com/lujun9972) 译者：[lxbwolf](https://github.com/lxbwolf) 校对：[wxy](https://github.com/wxy)
本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原创编译，[Linux中国](https://linux.cn/) 荣誉推出