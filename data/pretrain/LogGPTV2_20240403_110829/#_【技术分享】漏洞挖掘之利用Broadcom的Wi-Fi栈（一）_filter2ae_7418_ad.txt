### 创建一个重叠的块

在TDLS连接断开时，MIC检查只是其中的一个操作。可能通过覆写下一个块的大小字段，导致在释放TDLS会话的数据结构后，该块成为后续分配的最佳选择。这种分配可能导致意外损坏，使堆处于不一致状态，甚至导致固件崩溃。

然而，搜索空间并不大——假设我们只关注不大于RAM本身的块大小（原因显而易见），可以通过枚举覆写“大小”字段并断开连接产生的每个堆状态来实现。这可以通过脚本自动执行，并同时获取设备上RAM的“快照”，以观察其状态（无论是否一致，以及断开后固件能否恢复操作）。

具体来说，如果我们能创建两个空闲块彼此重叠的堆状态，将非常有利。在这种情况下，从一个块获取的分配可以用于损坏另一个空闲块的“下一个”指针，从而控制后续分配的位置。

经过几次尝试，我们发现通过用值72覆写“大小”字段并断开连接，可以达到以下堆状态：
- 断开连接后，留下一个零大小的空闲块，重叠一个较大的空闲块。
- 一旦从大块中切取一个分配，它将损坏较小块的“大小”和“下一个”字段。
- 我们可以尝试将下一个空闲块指向我们希望修改内容的内存地址，只要该地址中的数据符合空闲块的格式，就可以通过随后的分配覆盖该地址的内存。

### 寻找受控分配

为了探索这些可能性，我们需要创建一个受控的分配原语，这意味着我们要么控制分配的大小，要么是内容，或者两者兼有。在固件的正常处理过程中，很难触发分配，因为几乎所有处理都是就地完成的。即使有分配的情况，其寿命也很短，内存不再使用时会立即被回收。

尽管如此，我们已经看到至少有一组数据结构——TDLS连接本身。固件必须保留与TDLS连接相关的所有信息（只要其活跃）。我们可以找到一些与TDLS相关的、适合作为受控分配候选者的数据结构吗？

首先，我们查看处理每个TDLS动作帧的函数`wlc_tdls_rcv_action_frame`。该函数从读取TDLS类别和动作代码开始，然后根据接收到的动作代码将帧路由到适当的处理函数。

我们注意到，除了常规的规范定义的动作代码外，固件还支持超出规范的动作代码127。深入研究该函数后发现，它验证帧内容中的前3个字节是否与Wi-Fi联盟OUI (50:6F:9A)匹配，然后检索帧的第四个字节作为“命令代码”。目前，仅实现了两个供应商特定的命令：命令#4和#5。命令#4用于通过TDLS连接发送隧道式探测请求，命令#5用于向主机发送“事件”通知（指示“特殊”帧已到达）。

命令#4的实现对我们特别有用，因为它不需要存在TDLS连接即可处理。这意味着我们在断开连接后也可以发送帧。通过激活堆踪迹并逆向工程其逻辑，我们发现该函数触发了以下高级事件序列：

太好了，我们获得了一个受控生命周期、大小及内容的分配(A)。

但是，有一个小障碍：修改`wpa_supplicant`发送此专门设计的TDLS帧会导致完全失败。虽然`wpa_supplicant`允许我们完全控制TDLS帧中的许多字段，但它只是一个请求者，而不是MLME实现。因此，相应的MLME层负责编写和发送实际的TDLS帧。

在我的攻击平台上，我使用一台运行Ubuntu 16.04的笔记本电脑和一个TP-Link TL-WN722N适配器。适配器是SoftMAC配置，所以起作用的MLME层是Linux内核中存在的“cfg80211”配置层。

当`wpa_supplicant`希望创建和发送TDLS帧时，它通过Netlink发送特殊请求，然后由`cfg80211`框架处理，再传递给SoftMAC层“mac80211”。不幸的是，`mac80211`无法处理特殊的供应商框架，因此予以拒绝。尽管如此，这只是一个小问题——我为`mac80211`编写了一些补丁（见[这里](https://bugs.chromium.org/p/project-zero/issues/detail?id=1046#c2)），增加了对这些特殊供应商框架的支持。应用这些补丁后，重新编译和引导内核，我们现在可以发送专门设计的帧了。

为了更容易控制供应商框架，我在`wpa_supplicant`的CLI中添加了对新命令“TDLS_VNDR”的支持。该命令可以让我们将带任意数据的TDLS供应商帧发送到任何MAC地址。

### 合二为一

在创建两个重叠块之后，我们可以使用受控分配原语从较大块的尾部分配内存，从而将较小的空闲块指向我们选择的位置。但无论我们选择哪个位置，“大小”和“下一个”字段都必须有有效的值，否则稍后对malloc和free的调用可能失败，导致固件崩溃。

事实上，使用中的块是一个完美的候选者。使用中的块在与空闲块相同的位置指定其大小字段。对于“下一个”指针，在空闲块中未使用但在块分配期间被设置为零。这意味着通过破坏空闲列表来指向使用中的块，我们可以诱使堆认为其只是另一个空闲块，且碰巧是空闲列表中的最后一个块。

现在我们需要做的是找到一个包含我们要覆写的信息的使用中的块。如果我们使该块成为随后的受控分配的空闲列表中的最适合块，我们将使自己的数据分配到该处，而不是使用中的块的数据，从而有效地替换块的内容。这意味着我们可以任意替换任何使用中的块的内容。

为了实现完全的代码执行，定位和覆写堆中的函数指针是有利的。由于定时器可能在固件操作期间创建，其数据结构必须存储在堆上。我们可以通过逆向工程IRQ向量表项并搜索与处理定时器中断相对应的逻辑来定位这些定时器。最终，我们找到了一个与brcmsmac (SoftMAC) 驱动程序中使用的`brcms_timer`结构相符的链接列表。编写一个简短的脚本后，我们可以在给出RAM快照的情况下转储定时器列表：

可以看到，定时器列表按超时值排序，大多数定时器的超时时间相对较短。此外，所有定时器在固件初始化期间被分配，因此存储在恒定地址处。这很重要，因为如果我们想以定时器定位我们的空闲块，就需要知道其在内存中的确切位置。

最后，我们使用两个原语用我们自己的数据替换其中一个定时器的内容，从而将定时器的函数指向我们选择的地址。我们的计划是：
1. 使用上述技术创建两个重叠的空闲块。
2. 使用受控分配原语将较小的空闲块指向上面列表中的其中一个定时器。
3. 创建另一个受控分配（释放旧的分配），大小为0x3C，这对定时器块是最适合的。
4. 覆写定时器的内容。

但是我们将定时器指向哪个函数？我们可以使用同样的技巧征用堆上的另一个使用中的块，并用我们自己的shellcode覆写其内容。经过简单搜索后，我们发现了一个在芯片引导序列期间只包含控制台数据的大块，分配后未被使用。不仅分配相当大（0x400字节），而且其也被放置在一个恒定的地址，非常适合我们的利用代码。

最后，我们如何确定堆的内容可执行？毕竟，ARM Cortex R4有一个内存保护单元（MPU）。通过逆向二进制文件中固件的初始化例程，我们可以看到MPU实际上是在引导过程中被激活。但其使用什么内容配置？我们可以通过编写一个小程序存根来转储出MPU的内容：

当MPU被初始化时，其被设置为将所有内存标记为RWX，这使其无用。这省去了我们的一些麻烦，我们可以方便地从堆中直接执行我们的代码。

最终，我们准备好了利用代码。把它们放在一起后，我们现在可以劫持一个代码块来存储我们的shellcode，然后劫持一个定时器来指向我们存储的shellcode。一旦定时器到期，我们的代码将在固件上执行！

### 总结

我们已经看到，尽管Wi-Fi SoC上的固件实现非常复杂，但在安全性方面仍然滞后。具体来说，其缺乏所有基本的漏洞利用缓解措施——包括栈cookie、安全断开链接及访问权限保护（通过MPU）。

### 传送门
- [【技术分享】漏洞挖掘之利用Broadcom的Wi-Fi栈（二）](http://bobao.360.cn/learning/detail/3792.html)