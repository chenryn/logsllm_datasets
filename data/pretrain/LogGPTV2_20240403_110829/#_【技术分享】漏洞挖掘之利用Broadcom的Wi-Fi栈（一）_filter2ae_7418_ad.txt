**创建一个重叠的块**
回想一下，MIC检查只是TDLS连接断开时发生的许多操作之一。可能通过覆写下一个块的大小就这样发生了，一旦在收集TDLS会话的数据结构期间被释放，其可能成为断开过程中后续分配的最适合的块。这些分配可能会导致额外的无意损坏，这会使堆处于不一致的状态，甚至会使固件崩溃。
然而，可能大小的搜索空间没那么大——假设我们只对不大于RAM本身的块大小感兴趣（原因显而易见），我们就可以枚举通过用给定值覆写下一个块的“大小”字段并断开连接而产生的每一个堆状态。这可以通过在发送（执行枚举）上使用脚本来自动执行，并同时获取设备上RAM的“快照”，及观察其状态（无论其是否一致，以及断开后固件是否能恢复操作）。
具体来说，如果我们能创建一个两个空闲块彼此重叠的堆状态，这将是非常有利的。在这种情况下，从一个块获取的分配可以用于损坏另一个空闲块的“下一个”指针。这也许可以用来控制后续分配的位置。
无论如何，在查看几个块大小、断开TDLS连接并观察堆状态后，我们遇到了相当有趣的结果状态！通过用值72覆写“大小”字段并断开连接，我们实现了以下堆状态：
图31
太棒了！所以在断开连接之后，会留下一个零大小的空闲块，重叠一个不同的（较大的）空闲块！这意味着一旦从大块切取了一个分配，其将损坏较小块的“大小”和“下一个”字段。这可能是非常有用的——我们可以尝试将下一个空闲块指向我们希望修改其内容的内存地址。只要该地址中的数据符合一个空闲块的格式，我们就可以说服堆通过随后的分配覆盖该地址的内存。
**寻找受控分配**
为了开始探索这些可能性，我们首先需要创建一个受控的分配原语，这意味着我们要么控制分配的大小，要么是内容，要么是（理想的）两者。回想一下，正如我们之前看到的，在固件的正常处理过程中实际上很难触发分配——几乎所有的处理都是就地完成。此外，即使是分配数据的情况，其寿命也很短，内存不再使用是会立即被收回。
即使如此，就这样，我们已经看到至少有一组数据结构——其生命周期是可控的，并且包含多个不同的信息片段 –
TDLS连接本身。固件必须保留与TDLS连接（只要其活跃）相关的所有信息。也许我们可以找到一些与TDLS相关的、可以作为受控分配的良好候选者的数据结构？
要搜索一个，我们先看看处理每个TDLS动作帧的函数——wlc_tdls_rcv_action_frame。该函数从读取TDLS类别和动作代码开始。然后，其根据接收到的动作代码将帧路由到适当的处理函数。
图32
我们可以看到，除了常规的规范定义的动作代码之外，固件还支持超出规范的动作代码为127的帧。任何超出规范的东西都是可疑的，所以这可能是寻找我们的原语的好地方。
事实上，深入研究该函数后发现，其执行一个相当有意思的任务。它验证帧内容中的前3个字节是否与Wi-Fi联盟OUI
(50:6F:9A)匹配。然后，其检索帧的第四个字节，并将其用作“命令代码”。目前，仅实现了两个供应商特定的命令，命令＃4和＃5。命令＃4用于通过TDLS连接发送隧道式探测请求，命令＃5用于向主机发送“事件”通知（指示“特殊”帧已到达）。
然而，更有趣的是，我们看到#4命令的实现与我们目前的追求相似。首先，它不需要存在TDLS连接就可被处理。这样我们在断开连接后也可以发送帧。其次，通过在此函数执行期间激活堆踪迹并对其逻辑进行逆向工程，我们发现该函数触发了下列高级事件序列：
图33
太棒了，我们获得了一个受控生命周期、大小及内容的分配(A)。
但是，有一个小小的障碍。修改wpa_supplicant发送此专门设计的TDLS帧会导致完全的失败。虽然wpa_supplicant允许我们完全控制TDLS帧中的许多字段，但它只是一个请求者，而不是MLME实现。这意味着相应的MLME层负责编写和发送实际的TDLS帧。
在我为攻击平台使用的设置上，我有一台运行Ubuntu 16.04的笔记本电脑，和一个TP-Link TL-WN722N适配器。适配器是SoftMAC配置，所以起作用的MLME层是Linux内核中存在的层，即“cfg80211”配置层。
当wpa_supplicant希望创建和发送TDLS帧时，其通过Netlink发送特殊请求，然后由cfg80211框架处理，然后传递给SoftMAC层“mac80211”。然而，令人遗憾的是，mac80211无法处理特殊的供应商框架，因此予以拒绝。尽管如此，这只是一个小小的不便——我给mac80211编写了一些补丁（见https://bugs.chromium.org/p/project-zero/issues/detail?id=1046#c2），增加了对这些特殊供应商框架的支持。应用这些补丁后，重新编译和引导内核，我们现在可以发送我们专门设计的帧了。
为了更容易地控制供应商框架，我还在wpa_supplicant的CLI –
“TDLS_VNDR”中添加了对新命令的支持。该命令可以让我们将带任意数据的TDLS供应商帧发送到任何MAC地址。
**合二为一**
在创建两个重叠块之后，我们现在可以使用我们的受控分配原语从较大块的尾部分配内存，从而将较小的空闲块指向我们选择的位置。但是，无论我们选择哪个位置，“大小”和“下一个”字段都必须有有效的值，否则稍后对malloc和free的调用可能失败，这可能会导致固件崩溃。事实上，我们已经看到了完美的候选者来代替空闲块——使用中的块。
回想一下，使用中的块在与空闲块相同的位置指定其大小字段。对于“下一个”指针，其在空闲块中未使用，但在块分配期间被设置为零。这意味着通过破坏空闲列表来指向使用中的块，我们可以诱使堆认为其只是另一个空闲块，其碰巧也是空闲列表中的最后一个块。
图35
现在我们需要做的是找到一个包含我们要覆写的信息的使用中的块。如果我们使该块称为随后的受控分配的空闲列表中的最适合块，我们将使自己的数据分配到该处，而不是使用中的块的数据，这便有效地替代了块的内容。这意味着我们可以任意替换任何使用中的块的内容。
由于我们希望实现完全的代码执行，所以定位和覆写堆中的函数指针是有利的。但是，我们可以在堆上何处找到这样的值？Wi-Fi标准中有一些必须定期处理的事件。假设固件支持使用通用API来处理这样的定期定时器是有把握的。
由于定时器可能在固件操作期间创建，因此其数据结构必须存储在堆上。为了定位这些定时器，我们可以对IRQ向量表项进行逆向工程，并搜索与处理定时器中断相对应的逻辑。在这样做之后，我们找到一个内容似乎与brcmsmac
(SoftMAC)
驱动程序中使用brcms_timer结构相符的条目的链接列表。编写一个简短的脚本（见https://bugs.chromium.org/p/project-zero/issues/detail?id=1046#c7）后，我们可以在给出RAM快照的情况下转储定时器列表：
图36
可以看到，定时器列表是按超时值排序的，大多数定时器的超时时间相对较短。此外，所有定时器在固件的初始化期间被分配，因此存储在恒定地址处。这很重要，因为如果我们想以定时器定位我们的空闲块，我们就需要知道其在内存中的确切位置。
所以剩下的就是使用我们的两个原语用我们自己的数据来替换上面的其中一个定时器的内容，从而将定时器的函数指向我们选择的地址。
我们的计划是：首先，我们将使用上述技术创建两个重叠的空闲块。现在，我们可以使用受控分配原语将较小的空闲块指向上面列表中的其中一个定时器。接下来，我们创建另一个受控分配（释放旧的分配）。这个大小为0x3C，这对定时器块是最适合的。因此，在这一点上，我们将覆写定时器的内容。
图37
但是我们将定时器指向了哪个函数？那么，我们可以使用同样的技巧来征用堆上的另一个使用中的块，并用我们自己的shellcode覆写其内容。在简单搜索堆之后，我们遇到了一个在芯片引导序列期间只包含控制台数据，然后被分配但未被使用的大块。不仅分配相当大（0x400字节），而且其也被放置在一个恒定的地址——对我们的利用代码是绝佳的。
最后，我们如何确定堆的内容可执行？毕竟，ARM Cortex
R4有一个内存保护单元（MPU）。与MMU不同，其不允许虚拟地址空间的便利化，但其允许对RAM中不同内存范围的访问权限的控制。使用MPU，堆可以（应该）被标记为RW和不可执行。
通过逆向二进制文件中固件的初始化例程，我们可以看到MPU实际上是在引导过程中被激活。但其使用什么内容配置？我们可以通过编写一个小程序存根来转储出MPU的内容：
图38
当MPU被初始化时，其被有效地设置为将所有内存标记为RWX，这使其无用。这省去了我们的一些麻烦，我们可以方便地从堆中直接执行我们的代码。
最终，我们准备好了利用代码。把它们放在一起后，我们现在可以劫持一个代码块来存储我们的shellcode，然后劫持一个定时器来指向我们存储的shellcode。一旦定时器到期，我们的代码将在固件上执行！
图39
最终，我们经历了研究平台的整个过程，发现了一个漏洞并编写了一个完整的利用代码。虽然本文相对较长，但我还是省略了很多较小的细节。完整的利用代码（包括说明）请见： 。
**总结**
我们已经看到，虽然Wi-Fi
SoC上的固件实现非常复杂，但在安全性方面仍然滞后。具体来说，其缺乏所有基本的漏洞利用缓解措施——包括栈cookie、安全断开链接及访问权限保护（通过MPU）。
**传送门**
* * *
[**【技术分享】漏洞挖掘之利用Broadcom的Wi-Fi栈（二）**](http://bobao.360.cn/learning/detail/3792.html)