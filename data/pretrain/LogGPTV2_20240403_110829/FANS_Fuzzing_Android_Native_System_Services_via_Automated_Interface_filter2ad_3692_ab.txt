### 代码库中的 `onTransact` 方法

尽管我们没有直接修改 `onTransact` 方法的代码库，但我们检查了 AOSP 编译命令中作为源文件出现的所有 C/C++ 文件。这样做的目的是收集在编译过程中由 AIDL 工具动态生成的接口，否则这些接口可能会被忽略。

### 接口模型提取器

#### 3.4 有效生成测试用例

为了有效地生成测试用例，FANS 将提取目标服务的接口模型。本节简要介绍接口模型提取的设计原则和设计选择，然后详细说明如何提取接口模型，包括事务代码、输入和输出变量以及类型定义。

##### 3.4.1 提取原则

在设计接口模型提取器时，推荐遵循以下三个原则：

- **完整性**：由于我们希望系统地对 Android 原生系统服务进行模糊测试，因此需要获取完整的接口集及其所有事务。所有接口都已通过接口收集器收集。
- **精确性**：当给定无效的随机输入时，目标接口会回退到异常处理。因此，我们需要一个精确的接口模型来生成能够通过健全性检查的有效输入。我们从以下几个方面处理模型的精确性：变量模式、变量名称和变量类型。变量模式暗示了输入格式（稍后讨论）。另外两个方面有助于生成语义正确的输入。
- **便捷性**：理想情况下，应采用一种便捷的方法进行接口模型提取。此外，最好找到一种统一的方法来处理 C++ 和 AIDL 中定义的接口。

##### 3.4.2 提取器的设计选择

基于上述原则，我们为提取器做出了以下设计选择：

- **从服务器端代码中提取**：在 Android 中，客户端应用程序通过 RPC 接口 `transact` 调用目标事务。服务（即服务器端）使用 `onTransact` 方法处理 RPC。这种关联意味着我们可以从任一侧提取所有可能的事务。我们更倾向于分析服务器端的原因如下：
  1. 我们的目标是模糊测试服务，直接处理服务器端可以更准确地了解服务器端代码期望的输入，以及服务如何使用从数据反序列化的输入和序列化到回复中的输出。
  2. 一个接口有多个事务，其定义和实现通常紧密分布在服务器端代码中。另一方面，客户端代码可能会以分散的方式调用它们，从而给接口模型提取带来麻烦。

- **从 AST 表示中提取**：代码有许多表示形式，我们必须选择一个合适的表示形式来进行分析。首先，由于一些接口是在 AIDL 中定义的，一个候选解决方案是从 AIDL 文件中提取接口模型。然而，这种方法将错过在 Android 源代码中直接用 C++ 实现的大量接口。我们可以通过将文件从一种格式转换为另一种格式来解决这个问题。这里我们选择将 AIDL 文件转换为 C++ 文件，因为：
  1. 现有的 AIDL 工具可以在不丢失信息的情况下生成 AIDL 文件中定义的接口的 C++ 实现。
  2. 将 C++ 实现转换为 AIDL 文件并不简单，并且可能会降低接口模型的精确性。例如，当某个变量在特定路径条件下可用时，可能会丢失一些重要信息。

将 AIDL 文件转换为 C++ 文件后，另一个选择是从中间表示（IR）中提取接口模型，例如 Clang 编译器提供的 LLVM IR。但是，IR 通常会优化掉一些信息，例如类型别名，使得难以提取精确的接口信息。

另一方面，AST 是接口模型提取的良好表示形式。在 AST 中，变量名称和变量类型保持不变。此外，AST 记录了每个类型转换表达式。编译器解析所有头文件依赖关系，并按正确顺序在 AST 中提供类型。因此，我们可以顺序处理 AST 以解析 typedef 类型的原始类型。此外，AST 提供了每个接口在 `onTransact` 分发器中的所有事务代码的清晰视图。最后，每条语句（例如顺序语句和条件语句）在 AST 中都是分开的。这些特性使得从 AST 表示中提取接口模型非常方便。

##### 3.4.3 事务代码识别

如第 2.1 节所述，目标接口中的 `onTransact` 函数根据事务代码分发控制流到目标事务。这个分发过程通常在 C++ 源代码中实现为 switch 语句，并在 AST 中转换为多个 case 节点，每个 case 代表一个要调用的事务。因此，我们可以通过分析 AST 中的 case 节点轻松识别目标接口的所有事务，并识别相关的常量事务代码。

##### 3.4.4 输入和输出变量提取

在识别事务代码后，我们需要从每个事务的数据包中提取反序列化的输入。此外，为了推断事务间的依赖关系，我们还需要提取序列化到回复包中的事务输出。

具体来说，有三种可能的变量类别：

- **顺序变量**：这类变量在没有任何前提条件的情况下存在。
- **条件变量**：这类变量取决于某些条件。如果这些条件不满足，变量可能是 NULL 或不会出现在数据中，甚至在条件满足时具有不同的类型。
- **循环变量**：这类变量在循环中反序列化，甚至在嵌套循环中。

这三种类型的变量对应于程序中的三种类型的语句，即顺序语句、条件语句和循环语句。因此，我们主要会在 AST 中处理这些类型的语句。此外，我们还会考虑返回语句。原因将在相应部分详细说明。此外，由于 `onTransact` 函数处理输入和输出的方式类似，我们仅以输入变量为例进行详细说明。

- **顺序语句**：如清单 1 所示，主要有七种顺序语句：
  1. `checkInterface`：服务器将在每个事务开始时检查客户端提供的接口令牌（每个接口唯一）。如果接口令牌不匹配，它将直接返回，这意味着我们不能在数据包中填充随机字节。
  2. `readXXX`：在第 4 行，`readString16` 从数据包中反序列化一个常见类型，即 `String16`。变量名称也包含一些语义。在这种情况下，`opPackageName` 应该是一个包名。此外，在第 5 行，`readInt32` 读取一个 `int32_t` 变量，而左侧变量类型是 `pid_t`。在这种情况下，我们将始终选择语义更丰富的类型作为变量类型，即 `pid_t`。我们也会将此策略应用于类型转换表达式。
  3. `read(a, sizeof(a) * num)`：在这种情况下，服务器将直接从数据包中复制一个原始结构或数组。在第 8 行，服务器读取一个类型为 `effect_descriptor_t` 的结构。
  4. `read(a)`：在这里，服务器将读取一个 Flattenable 或 Light-Flattenable 结构。在第 11 行，服务器读取一个 Light-Flattenable 结构 `Rect`。
  5. `readFromParcel`：这种顺序语句的特殊之处在于反序列化过程发生在另一个实现了 Parcelable 接口的类或结构中。在第 14 行，服务器读取一个类型为 `aaudio::AAudioStreamRequest` 的类。
  6. `callLocal`：以第 16 行为例，`callLocal` 方法将逐个处理 `createSurface` 的参数。如果变量类型不是指针，则将其视为输入变量；否则，将其视为输出变量。
  7. **杂项函数**：对于那些特殊的输入格式，数据包将传递给一个函数。在第 18 行，数据包传递给 `setShedPolicy` 函数。在这种情况下，我们将标记此输入为函数并递归处理数据。此外，这表明我们还应该收集包含相应函数的文件，例如这里的 `setSchedPolicy`。

- **条件语句**：有几种类型的条件语句，例如 if 语句和 switch 语句。这里我们演示 if 语句的处理方法。如清单 2 所示，是否执行第 4 行取决于 `isFDValid` 变量。在这种情况下，我们将 `fd` 视为条件输入。此外，我们记录 `fd` 的条件以获得更精确的接口模型。

- **循环语句**：有几种形式的循环语句，例如 for 语句和 while 语句。这里我们演示 for 语句的处理方法。如清单 3 所示，我们记录 `key` 被读取的次数，即 `size`。我们将 `key`、`fd` 和 `value` 视为循环变量。此外，可能有一种 for 语句，例如 `for(auto i: vector)`，它没有显式声明循环次数。我们启发式地猜测循环次数是 for 语句之前从数据包中读取的前一个值，例如第 1 行中的 `size`。此外，我们还可以观察到还有一个条件语句，这表明这些类型的语句可以嵌套在一起。

- **返回语句**：返回语句在这些语句中是特殊的。在一个事务中，可能会出现多个返回语句，导致不同的执行路径。如果某条路径返回错误代码，这意味着该路径不太可能存在漏洞。因此，我们将为这条路径分配较低的概率，这意味着生成较少的测试用例会走这条路径。如清单 4 所示，如果 `numBytes` 大于 `MAX_BINDER_TRANSACTION_SIZE`，函数将简单地返回错误代码 `DRM_NO_ERROR`。在这种情况下，我们在生成 `numBytes` 时应尽量避免生成大于 `MAX_BINDER_TRANSACTION_SIZE` 的值。此外，这还将帮助我们生成显式的事务间依赖关系，因为不符合依赖关系的输入通常会回退到错误处理路径。

##### 3.4.5 类型定义提取

除了提取事务中的输入和输出变量外，我们还提取类型定义。这有助于丰富变量的语义，从而生成更好的输入。有三种类型的类型需要分析：

- **结构体类定义**：这类类型包括联合和结构体。我们可以轻松地从 AST 中提取这些对象的成员。
- **枚举定义**：对于枚举类型，我们应该提取所有给定的（常量）枚举值。
- **类型别名**：AOSP 中有许多 typedef 语句。如清单 5 所示，`pid_t` 实际上是 `int` 类型。因此，我们可以用随机整数生成 `pid_t` 类型的变量。此外，清单 1 中的 `effect_descriptor_t` 实际上是 `struct effect_descriptor_s`。如果没有这样的 typedef 知识，我们将无法生成正确的类型。