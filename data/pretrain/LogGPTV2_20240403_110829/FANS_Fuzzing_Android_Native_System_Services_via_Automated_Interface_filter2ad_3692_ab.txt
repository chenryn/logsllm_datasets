codebase for the onTransact method, though. Instead, we
examine every C/C++ ﬁle that appears as a source in AOSP
compilation commands, so that we can collect interfaces that
are dynamically generated by AIDL tools during compilation,
which will be overlooked otherwise.
status_t XXX::onTransact(...)CompileonTransacttx1tx n.........>fetch corpuspush corpuspush fuzzerpull logsstore logsInterface Model Extractor
3.4
To effectively generate test cases, FANS will extract inter-
face models of target services. Here, we brieﬂy introduce
the design principles and design choices of interface model
extraction, then detail how to extract the interface model, in-
cluding transaction code, input and output variables, as well
as type deﬁnitions.
3.4.1 Principles of Extraction
Three principles are recommended when designing the inter-
face model extractor:
Complete: As we want to fuzz Android native system ser-
vices systematically, we need to obtain a complete set of
interfaces, together with all transactions of them. All of the
interfaces have been collected by interface collector.
Precise: Since the target interfaces will fall back on ex-
ception handling when invalid random inputs are given in
the transaction request, we need a precise interface model to
generate valid inputs that pass sanity checks. We handle the
precision of the model from the following aspects: variable
patterns, variable names and variable types. The variable
pattern implies input formats, as will be discussed later. The
other two aspects help generate semantically correct inputs.
Convenient:
Ideally, a convenient method should be
adopted for interface model extraction. Besides, we had better
ﬁnd a uniﬁed approach to handle both the interfaces deﬁned
in C++ and those deﬁned in AIDL.
3.4.2 Design Choices of Extractor
With the above principles in mind, we have made the follow-
ing design choices for the extractor:
Extract from Server Side Code:
In Android, client apps
call target transactions with the RPC interface transact.
The service, i.e., the server side, handles the RPC with the
onTransact method. This correlation means that we can ex-
tract all possible transactions on either side. We prefer to
analyze the server side for the following two reasons: (1) It
is service that we are to fuzz, and directly dealing with the
server side will give us a more accurate view of what inputs
the server-side code expect, as well as how services use in-
puts deserialized from data and outputs serialized into reply.
(2) An interface has multiple transactions, whose deﬁnitions
and implementations are in general closely distributed in the
server-side code. On the other hand, client-side code may
invoke them in a scattered way, causing trouble for interface
model extraction.
Extract from the AST Representation: There are many
representations of the code. We have to choose a proper one to
base the analysis on. First, since some interfaces are deﬁned
in AIDL, a candidate solution is to extract the interface model
from AIDL ﬁles. However, this method will miss a wide range
interfaces directly implemented in C++ in the Android source
code. We can convert ﬁles of one format to another format to
address this issue. Here we choose to convert AIDL ﬁles to
C++ ﬁles because: (1) Existing AIDL tools can generate C++
implementations of interfaces deﬁned in AIDL ﬁles without
losing information. (2) Converting C++ implementations to
AIDL ﬁles is not trivial and might decrease the precision of
the interface model. It may lose some important information,
when, for example, a variable is available under a speciﬁc
path condition.
After converting AIDL ﬁles to C++ ﬁles, another choice
is to extract the interface model from an intermediate rep-
resentation (IR), e.g., the LLVM IR provided by the Clang
compiler. But IRs usually optimize out some information,
e.g., type aliases, making it harder to extract precise interface
information.
On the other hand, the AST is a good representation for
interface model extraction. In the AST, variable names and
variable types are kept intact. Also, every type cast expression
is recorded in AST. In addition, the compiler resolves all
header ﬁle dependencies and provide types in correct order
in the AST. Thus, we can process the AST sequentially to
resolve the original type of a typedef type. Besides, the AST
provides a clear view of all transaction codes of each interface
in the onTransact dispatcher, as shown in Figure 2. Lastly,
each statement (e.g., sequential statement and conditional
statement) is separated in the AST. These characteristics make
it convenient to extract the interface model from the AST
representation.
3.4.3 Transaction Code Identiﬁcation
As described in Section 2.1, the onTransact function in a tar-
get interface dispatches the control ﬂow to target transactions
according to the transaction code. This dispatch process is
usually implemented as a switch statement in the C++ source,
and converted to multiple case nodes in the AST, where each
case represents a transaction to invoke. Therefore, we can
readily identify all transactions of a target interface by ana-
lyzing case nodes in the AST and recognize the associated
constant transaction code.
3.4.4
Input and Output Variable Extraction
After identifying transaction codes, we need to extract inputs
deserialized from the data parcel in each transaction. Besides,
as we would like to infer inter-transaction dependencies, we
also need to extract transactions’ outputs which are serialized
into the reply parcel.
used in a transaction:
Speciﬁcally, there are three possible classes of variables
• Sequential Variables. This type of variables exists with-
out any preconditions.
/ /
c h e c k I n t e r f a c e
1
2 CHECK_INTERFACE( I M e d i a E x t r a c t o r S e r v i c e , d a t a ,
r e p l y ) ;
/ /
readXXX
/ /
r e a d ( a )
r e a d ( a , s i z e o f ( a ) ∗num )
/ /
e f f e c t _ d e s c r i p t o r _ t d e s c = { } ;
s i z e o f ( d e s c ) ) ;
3
4 S t r i n g 1 6 opPackageName= d a t a . r e a d S t r i n g 1 6 ( ) ;
5 p i d _ t p i d = d a t a . r e a d I n t 3 2 ( ) ;
6
7
8 d a t a . r e a d (& desc ,
9
10 Rect
11 d a t a . r e a d ( s o u r c e C r o p ) ;
12
13 a a u d i o : : AAudioStreamRequest
14
15
16 c a l l L o c a l ( d a t a ,
r e q u e s t . r e a d F r o m P a r c e l (& d a t a ) ;
/ /
s o u r c e C r o p ( Rect : : EMPTY_RECT) ;
r e a d F r o m P a r c e l
c a l l L o c a l
r e q u e s t ;
/ /
r e p l y , &I S u r f a c e C o m p o s e r C l i e n t : :
c r e a t e S u r f a c e ) ;
17
18
f u n c t i o n c a l l
/ /
s e t S c h e d P o l i c y ( d a t a ) ;
Listing 1: Sequential Statement Example
• Conditional Variables. This type of variables depends
on some conditions. If these conditions are not satisﬁed,
the variables could be NULL or do not appear in the data,
or even have a different type than when the conditions
are satisﬁed.
• Loop Variables. This type of variables are deserialized
in loops, and even nested loops.
These three types of variables correspond to three types
of statements in the program exactly, i.e., sequential state-
ment, conditional statement and loop statement. As a result,
we will mainly process these kinds of statements in the AST.
Besides, we will also consider the return statement. The rea-
son will be detailed in the corresponding part. Moreover, as
onTransact function processes inputs and outputs similarly,
we only demonstrate the details with input variables.
A. Sequential Statement: As shown in Listing 1, there are
mainly seven kinds of sequential statements:
(1) checkInterface. The server will check the interface to-
ken (unique for every interface) given by the client at
the beginning of each transaction. If the interface token
does not match, it will just return, which suggests that we
cannot ﬁll random bytes into data parcel.
(2) readXXX. In Line 4, readString16 deserializes a com-
mon type, i.e., String16, from the data parcel. The vari-
able name also holds some semantics. In this case, the
opPackageName should be a package name. Besides, in
Line 5, readInt32 reads a int32_t variable, while the
left-hand-side variable type is pid_t. In such a case, we
will always choose the type with richer semantics as the
variable type, i.e., pid_t. We will also apply this strategy
to type cast expressions.
(3) read(a, sizeof(a) * num). In this circumstance, the server
will directly copy a raw structure or an array from the
data parcel. In Line 8, the server reads a structure whose
type is effect_descriptor_t.
(4) read(a). Here, the server will read a Flattenable or Light-
i n t 3 2 _ t
i n t
i f
i s F d V a l i d = d a t a . r e a d I n t 3 2 ( ) ;
f d = −1;
( i s F d V a l i d ) {
f d = d a t a . r e a d F i l e D e s c r i p t o r ( ) ;
1
2
3
4
5 }
Listing 2: Conditional Statement Example
Flattenable structure. In Line 11, the server reads a Light-
Flattenable structure Rect.
(5) readFromParcel. This kind of sequential statement
is special in that the deserializtion process happens
in another class or structure which implements the
Parcelable interface. In Line 14, the server reads a class
whose type is aaudio::AAudioStreamRequest.
(6) callLocal. Taking Line 16 as an example, callLocal
method will process the arguments of createSurface
one by one. If the variable type is not a pointer, it is con-
sidered as an input variable. Otherwise, it is considered
as an output variable.
(7) Misc Function. For those special input formats, the data
parcel will be passed into a function. In Line 18, the data
parcel is passed into the function setShedPolicy. For
such a case, we will mark this input as a function and
recursively handle the data. Moreover, this indicates we
should also collect the ﬁle which includes the correspond-
ing function, e.g., setSchedPolicy in this case.
B. Conditional Statement: There are several kinds of con-
ditional statements, e.g., if statement and switch statement.
Here we demonstrate our approach to the if statement. As
shown in Listing 2, whether Line 4 will be executed or not
is decided by the isFDValid variable. In such a case, we
consider fd as a conditional input. Besides, we record the
condition for fd to get a more precise interface model.
C. Loop Statement: There are several forms of loop state-
ments, e.g., for statement and while statement. Here we
demonstrate our approach to the for statement. As shown
in Listing 3, we record the number of times key is read,
i.e., size. We consider key, fd and value as loop vari-
ables. Moreover, there might be a kind of for statement,
s i z e = d a t a . r e a d I n t 3 2 ( ) ;
i n d e x = 0 ; index MAX_BINDER_TRANSACTION_SIZE) {
2
3
4
5 }
r e p l y −> w r i t e I n t 3 2 (BAD_VALUE) ;
r e t u r n DRM_NO_ERROR;
Listing 4: Return Statement Example
for(auto i: vector), which does not explicitly declare
the cycle count. We heuristically guess that the cycle count is
the previous value read from the parcel before the for state-
ment, e.g., size in Line 1. Furthermore, we can observe that
there is also a conditional statement, which implies that these
types of statements can be nested together.
D. Return Statement: Return statement is special among
these statements. During a transaction, several return state-
ments might appear, which lead to different execution paths.
If a path returns an error code, it implies that this path is
less likely to have vulnerabilities. Thus, we will assign this
path a low probability, which means that fewer test cases
taking this path will be generated. As Listing 4 shows, if
numBytes is larger than MAX_BINDER_TRANSACTION_SIZE,
the function will simply return an error code DRM_NO_ERROR.
In such a case, we should try not to generate a value
larger than MAX_BINDER_TRANSACTION_SIZE when generat-
ing numBytes. Besides, it will also help us generate explicit
inter-transaction dependency, as inputs that do not satisfy the
dependency usually fall back to error handling paths.
3.4.5 Type Deﬁnition Extraction
Apart from extracting input and output variables in trans-
actions, we also extract type deﬁnitions. It helps enrich the
variable semantics so as to generate better inputs. There are
three kinds of types to analyze:
• Structure-like Deﬁnition. This kind of types includes
union and structure. We could easily extract the member
of these kinds of objects from the AST.
• Enumeration Deﬁnition: As for enumeration type, we
should extract all given (constant) enumeration values.
i n t _ _ k e r n e l _ p i d _ t ;
t y p e d e f
t y p e d e f _ _ k e r n e l _ p i d _ t _ _ p i d _ t ;
t y p e d e f _ _ p i d _ t p i d _ t ;
t y p e d e f
e f f e c t _ d e s c r i p t o r _ s {
s t r u c t
1
2
3
4
5
6
7
8
9
10
11
12
13 } e f f e c t _ d e s c r i p t o r _ t ;
e f f e c t _ u u i d _ t
t y p e ;
e f f e c t _ u u i d _ t u u i d ;
a p i V e r s i o n ;
u i n t 3 2 _ t
u i n t 3 2 _ t
f l a g s ;
u i n t 1 6 _ t cpuLoad ;
u i n t 1 6 _ t memoryUsage ;
c h a r
c h a r
name [EFFECT_STRING_LEN_MAX ] ;
i m p l e m e n t o r [EFFECT_STRING_LEN_MAX ] ;
Listing 5: Typedef Statement Example
• Type Alias: There are many typedef statements in
AOSP. As shown in Listing 5, pid_t is actually
an int type. As a result, we could generate vari-
ables of type pid_t with random integers. Besides,
effect_descriptor_t in Listing 1 is actually struct
effect_descriptor_s. Without such typedef knowl-