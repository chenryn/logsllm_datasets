the same IPID counter.
• Browser page read. In this attack [27], the shared
state is a browser page where an attacker runs malicious
Javascript and attempts to inject data into connections to
a benign website (both the benign connection and ma-
licious script run under the same page). The success-
ful guess of the TCP sequence number results in a di-
rect feedback from the browser page load. There are
three main culprits of the attack: (1) older operating sys-
tems follow an earlier standard RFC 793 that consid-
ers half of the ACK number space valid. An off-path
attacker only needs to guess two ACK values with ev-
ery guessed sequence number to inject data successfully.
Therefore, the feedback about when the injection suc-
ceeds is when the malicious payload gets loaded and ren-
dered by the browser. (2) modern browsers are tolerant
of response data: if the HTTP response header is miss-
ing, the browser simply attaches one automatically. This
frees the attacker from having to prepare the header at
an exact sequence number (otherwise the browser con-
siders the response invalid and closes the connection).
(3) HTTP pipeline is required so that a response arrives
ahead of time will be deemed valid.
This attack no longer works because the ﬁrst culprit is
eliminated by most modern operating systems (including
Windows, Linux, Android), which adopted a more strin-
gent check on ACK numbers as deﬁned in RFC 5961
where only a much smaller window is considered valid.
In addition, from our testing, HTTP pipeline is disabled
or not implemented in all modern browsers, eliminating
the third culprit as well.
• Global challenge ACK rate limit. The Linux kernel
ﬁrst implemented all the features suggested in RFC 5961
in version 3.6 and its TCP packet validation logic closely
matches the one shown in Fig. 2. Notably, it implements
the recommended ACK throttling feature by introducing
a global system variable to control the maximum num-
ber of challenge ACKs generated per second. As this
limit is shared across all connections, the shared state
can be exploited as a side channel. For instance, to in-
fer if an ongoing connection exists, an off-path attacker
can initially send a spoofed packet with one guessed port
number and SYN bit set; after the attacker sends another
100 4 non-spoofed in-window RST packets to exhaust
the challenge ACK count, it can then observe the num-
ber of responses to tell whether its initial spoofed packet
matches the four tuples of an ongoing connection and
hence triggers a challenge ACK.
Since the shared rate limit is a simple software artifact,
shortly after the vulnerability was reported, it was elimi-
nated in a patch introduced in Linux 4.6 [8, 42] where a
per-socket rate limit is used instead.
• System-wide packet counter. Packet counters report
aggregated statistics across all connections and are re-
liable side channels demonstrated in recent off-path at-
tacks [40, 39]. These attacks require a piece of unprivi-
leged malware to run on the client machine that can ac-
cess these packet counters and use them as feedback for
spoofed packets sent by the off-path attacker. Due to the
fact that these counters are internal to TCP implementa-
tions, they may leak more diverse and ﬁne-grained infor-
mation (more than what the standard packet validation
logic can leak). In the extreme case, for example, a Lin-
ux/Android TCP packet named DelayedACKLost is in-
cremented only when it receives a packet with a sequence
number smaller than the expected one. This allows an
attacker to conduct a binary search on the expected se-
quence number. Similar dangerous packet counters exist
on macOS as well [40].
These packet counters are being mitigated in a num-
ber of ways. For Linux, it introduced the mechanism
of namespace so that sensitive apps and untrusted apps
can run in separate namespaces with isolated counters.
For macOS, the side channel vulnerability has recently
been assigned CVE-2017-13810 and patches have been
pushed out to zero the sensitive counters [9, 10].
4It’s the default threshold in Linux version 3.6
1584    27th USENIX Security Symposium
USENIX Association
Client
Half
Duplex
Router
Full
Duplex
Attacker
No ACKs
X
Pre-Probe Query
Post-Probe Query
Not Trigger ACK
Server
RTT_1
Triggering ACKs
Gap_1
Pre-Probe Query
Post-Probe Query
Trigger ACK
X
X
RTT_2
No ACK
(a) Timing difference between two cases
Multiple ACKs
X
Pre-Probe Query
Post-Probe Query
Not Trigger ACK
RTT_1
Gap_1
X
Pre-Probe Query
Post-Probe Query
Trigger ACK
X
X
X
RTT_2
Client
Half
Duplex
Router
Full
Duplex
Attacker
Server
Corresponding 
Response
Delayed
Failed 
Transmission
Gap_2
Probe
Corresponding 
Response
Delayed
Failed 
Transmission
Gap_2
Probe
(b) Triggering multiple ACKs
Figure 3: Vulnerability caused by wireless contention
Summary. Overall we listed four different types of
software-based side channels that have been exploited
to launch off-path TCP attacks. We summarize them in
Table 1 for reference. In short, only the packet counter
side channels still exist (validated on Linux and Android
8.0). In any event, this side channel requires a high bar to
launch because of the malware requirement. In the next
section, we describe our newly discovered side channel
in detail.
3 Wi-Fi Timing Channel
Fundamentally, the half-duplex nature of Wi-Fi creates
a “shared resource” among uplink and downlink trafﬁc,
a prerequisite of any side channel. By sharing the same
set of frequency bands with both directions, Wi-Fi relies
on carrier-sense multiple access (i.e., CSMA) to share/-
divide the channel over time. This means that a node
transmits only when the channel is sensed to be idle and
thus it has the exclusive right to transmit. This effectively
creates a timing channel that delays the local transmis-
sion if the opposite direction is transmitting at the same
time.
Even worse, this timing difference becomes more vis-
ible due to retransmissions caused by contention (col-
lision). Speciﬁcally, the protocol starts by listening on
the channel and immediately sends the ﬁrst frame to the
transmit queue if the channel is found to be idle; how-
ever, this leads to waste of transmissions if collision oc-
curs. If the channel is subsequently sensed to be busy,
it waits for a period of time (e.g., usually random or
exponential backoff [17]) attempting to avoid collision.
Although it might beneﬁt the performance when many
nodes are active, it creates a signiﬁcant overhead when
only one is present (plus the AP). In addition to backoffs,
Request to Send/Clear to Send (RTS/CTS) [16] may op-
tionally be used to mediate access to the shared medium
to solve the hidden-terminal problem [46] where multi-
ple stations can see the Access Point but not each other.
Unfortunately, in the same scenario where there is only
one node, it introduces unnecessary trafﬁc to the net-
work, slowing everything down. Finally, it is important
to note the latency is ampliﬁed further when more con-
tention is present (e.g., more frames to be transmitted in
either direction).
Exploiting the timing channel. To demonstrate the tim-
ing channel, we create a probing strategy to measure the
delay effects. As we can see in Fig. 3a, we simulate an
off-path TCP attack where the attacker sends a spoofed
probing packet, along with a pre-probe query and post-
probe query to measure the RTT before and after. If the
spoofed packet does not trigger an ACK on the client,
e.g., because the guessed sequence number is in-window
(left half of the ﬁgure), then the post-probe query arrives
at the client faster and gets back sooner (smaller RTT).
On the other hand, if the spoofed packet triggers an ACK
on the client, e.g., because the guessed sequence number
is out-of-window (right half of the ﬁgure), then the post-
probe query experiences contention with the ACK from
USENIX Association
27th USENIX Security Symposium    1585
In Fig. 3b, we also illustrate the ampliﬁable nature of
the timing channel where the attacker sends two spoofed
probing packets, causing more contention which delays
post-probe query even further.
In summary, this side channel allows an attacker to
determine if the spoofed probing packets have triggered
any response or not, coincidentally achieving the same
purpose as the global IPID counter on Windows (which
is no longer available). In contrast, Wi-Fi contention is
here to stay.
Empirical testing. So far we only conceptually analyzed
the side channel and its effects. We now conduct a con-
trolled local experiment to understand its real-world im-
plications. Following the same topology in Fig. 7, we
created a total of 16 different setups to make sure that the
side channel exists in various generations of technologies
and products. We used 4 different wireless routers (from
Linksys, Huawei, Xiaomi, and Gee): all latest genera-
tions that support 802.11ac and 802.11b/g/n. We used
two different machines as clients: an early-2017 Mac-
book and a mid-2017 Dell Desktop. Finally, we varied
the frequency of the router between 2.4GHz and 5GHz
so that both 802.11n and 802.11ac were tested (802.11ac
is used for 5GHz only).
the client, and therefore prolongs the measured RTT. In
addition to the RTT difference (RT T 2 > RT T 1), we
can also measure the gap between the replies of the ﬁrst
query and the second, which should capture the delay ef-
fects similarly.
The measurements are conducted in a single-family
house where we have relatively little wireless interfer-
ence (with at most 4 potential users at home). Due to
space constraint, we present 6 representative results of
the measurement in Fig. 4. Each plot with a box and
whiskers presents the data measured with 100 runs. On
average, we can see that the timing difference for RTT is
about 1 to 3ms when the number of probing packets is 30
or more. Although differences exist among those setups,
the timing side channel is clear and measurable(see §5.4).
Later in §6, we also evaluate its robustness to noise.
Half-duplex vs. Full-duplex To better understand that
the signiﬁcant part of the RTT difference is due to the
half-duplex nature of wireless rather than the processing
time to generate an ACK response on the client, we also
conducted an experiment with the setup where both the
victim and attacker machine connect to a Huawei router
via ethernet. As depicted in Fig. 5, the timing side chan-
nel is no longer visible and ampliﬁable (note the heavily
overlapped boxes), because of two reasons: (1) Now that
downlink and uplink can transmit at the same time, there
is simply no contention regardless of how many packets
are transmitted. (2) Packets belonging to different sock-
ets can be processed simultaneously on different CPU
(a) RTT measurement of ma-
cOS using 5GHz network of a
Huawei router
(b) RTT measurement of Linux
using 5GHz network of
a
Linksys router
(c) RTT measurement of ma-
cOS using 2.4GHz network of a
Xiaomi router
(d) Gap measurement of ma-
cOS using 5GHz network of a
Huawei router
(e) Gap measurement of Linux
using 5GHz network of
a
Linksys router
(f) Gap measurement of macOS
using 2.4GHz network of a Xi-
aomi router
Figure 4: Selective measurement of wireless connections
in a local setup. X axis is the number of probing pack-
ets that attackers send per test. The box extends from
the lower to upper quartile values of the data. And the
whiskers extend from the box to show the range of the
data at speciﬁc percentiles (i.e.
[0, 90]). Beyond the
whiskers, data are considered outliers, plotted as individ-
ual points.
cores (by OS design), allowing the post-probe query to
be processed in parallel to probes. Even if the probes
trigger ACKs, they still consume resources (CPU, mem-
ory) that are mostly isolated from the post-probe query.
The experiment demonstrates that contention caused by
half-duplex is the root cause of the timing channel.
4 Attack Overview
In this section, we show how such an inherent side chan-
nel can be leveraged in our off-path TCP attack.
1586    27th USENIX Security Symposium
USENIX Association
of generality, we focus on the “web cache poisoning”
attack (which is the most powerful among a few other
web attacks described in [25, 27]). Assuming a puppet-
initiated connection is targeted, the attack can choose to
poison any unencrypted target website at any time.
It
relies on the basic design principle that browsers reuse
TCP connections for requests sent to the same server IP
address. This means that the puppet in the malicious
website can create a single persistent connection to a
target domain by repeatedly including HTML elements
(e.g., images). The off-path attacker can then conduct the
side channel attack to infer the port number and sequence
numbers used in the target connection. Afterwards, the
puppet can embed a target web object in the page, e.g.,
This triggers an HTTP request over the same old TCP
connection; the off-path attacker can now simply inject
a fake HTTP response that will be cached for arbitrar-
ily long, because the HTTP response header can ask the
browser not to re-check the freshness of the object, lead-
ing to a persistent cache poisoning5. If an attacker caches
a commonly used malicious third-party javascript (e.g.,
jQuery), it can impact a large number of websites.
In the remainder of this section we describe the three
different attacks that progressively build on top of each
other, and detail strategies for all three major operating
systems.
• Leveraging the TCP packet validation logic. As
mentioned in §2.2, the latest RFC standards specify the
packet validation behavior, which consists of connec-
tion (four-tuple) identiﬁcation, sequence number check
and ACK number check. In each check, depending on
the validity of the incoming packet, a response will be
generated, or not. This is exactly what the Wi-Fi tim-
ing channel allows an off-path attacker to observe —
whether spoofed packets have triggered responses or
not. Similar to the Windows global IPID side channel
that provides the same feedback (but is now eliminated),
prior attacks also take advantage of the TCP packet val-
idation logic [1, 25]. However, there are two issues to
consider. First, clients connected through Wi-Fi are al-
most always behind NAT and/or ﬁrewall (the wireless
router itself often acts as NAT). Therefore, the packet
validation logic may change slightly. Second, it is un-
clear whether the operating systems will follow the stan-
dard faithfully.
For the ﬁrst problem, NAT and ﬁrewall primarily
change the behavior of connection identiﬁcation. If an
incoming packet does not match any ongoing connec-
5HTTP response header can specify a “max-age”, indicating that
the response is to be considered stale after X seconds where X can be
as large as 231 or 68 years (see RFC7234)
(a) RTT measurement of macOS (b) Gap measurement of macOS
Figure 5: Measurement of wired connections in a local
setup
C
Sandboxed
script
Internet
S
Mallory
Figure 6: Speciﬁc threat model targeting a wireless client
• Threat model. Obviously, since the side channel is
inherent in Wi-Fi, the threat model requires either the
client or server connected through Wi-Fi. As it stands,
we do not consider servers here as most of them do not
use Wi-Fi (see §7 for a special case of IoT devices).