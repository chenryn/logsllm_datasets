入口函数 
Windows 程 序 的 入 口 函 数 地 址 是 登 记 在 可 执 行 文 件 的 头 结 构 中 的 ， 也 就 是
IMAGE_OPTIONAL_HEADER 结构的 AddressOfEntryPoint 字段。内核文件的入口函数也
是如此。通过下面几个步骤就可以使用 WinDBG 观察到内核文件的入口函数。先启动
WinDBG，并开始一个本地内核调试对话，使用 lm nt 命令列出内核文件的基本信息： 
lkd> lm a nt 
start    end      module name 
804d7000 806cdc80 nt (pdb symbols) d:\symbols\ntkrnlpa.pdb\C…\ntkrnlpa.pdb 
其中 804d7000 就是内核模块在内存中的起始地址。起始处是一个所谓的 DOS 头： 
dt nt!_IMAGE_DOS_HEADER 804d7000 
   +0x000 e_magic          : 0x5a4d 
… 
   +0x03c e_lfanew         : 232 
其中 e_lfanew 字段的值代表的是新的 NT 类型可执行文件的头结构的起始偏移地址。 
lkd> dt nt!_IMAGE_NT_HEADERS 804d7000+0n232 
   +0x000 Signature        : 0x4550 
   +0x004 FileHeader       : _IMAGE_FILE_HEADER 
   +0x018 OptionalHeader   : _IMAGE_OPTIONAL_HEADER 
现在可以知道 804d7000+0n232+18 处便是_IMAGE_OPTIONAL_HEADER 结构，于
是可以使用下面的命令来显示出 AddressOfEntryPoint 字段的值： 
lkd> dt _IMAGE_OPTIONAL_HEADER -y Add* 804d7000+0n232+18 
nt!_IMAGE_OPTIONAL_HEADER 
   +0x010 AddressOfEntryPoint : 0x1b6f5c 
上面显示的 AddressOfEntryPoint 字段的值 0x1b6f5c 便代表着内核文件的入口函数在
模块中的偏移，加上模块的基地址便可以得到入口函数的线性地址，使用 ln 命令查找这
个地址对应的符号： 
《软件调试》补编 
- 167 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
lkd> ln 0x1b6f5c+804d7000 
(8068df5c)   nt!KiSystemStartup   |  (8068e244)   nt!KiSetCR0Bits 
Exact matches: 
    nt!KiSystemStartup =  
这表明入口地址处的函数名为 KiSystemStartup，实际上，它就是 NT 系统 Windows
操作系统的内核文件一直使用的入口函数。 
上面我们介绍的是使用类型显示命令一步步观察，当然也可以使用扩展命令!dh 一下
子显示出以上信息： 
lkd> !dh 804d7000 -f 
File Type: EXECUTABLE IMAGE 
… 
  1B6F5C address of entry point 
当 OS Loader（NTLDR 或 WinLoad）调用 KiSystemStartup 时，它会将启动选项以一
个名为 LOADER_PARAMETER_BLOCK 的数据结构传递给 KiSystemStartup 函数。
Windows Vista 的内核符号文件包含了这个结构的符号，因此在对 Windows Vista 做内核调
试时可以观察到这个结构的详细定义。 
内核初始化
内核初始化
内核初始化
内核初始化 
KiSystemStartup 函数开始执行后，它首先会进一步完善基本的执行环境，包括建立和
初始化处理器控制结构（PCR）、建立任务状态段（TSS）、设置用户调用内核服务的 MSR
寄存器等。在这些基本的准备工作完成后，接下来的过程可以分为图 1 所示的左右两个部
分。左侧为发生在初始的启动进程中的过程，这个初始的进程就是启动后的 Idle 进程。右
侧为发生在系统进程（System）中的所谓的执行体阶段 1 初始化过程。 
图 1 Windows 启动过程概览 
首先我们来看 KiSystemStartup 函数的执行过程，它所做的主要工作有： 
一、调用 HalInitializeProcessor()初始化 CPU。 
《软件调试》补编 
- 168 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
二、调用 KdInitSystem 初始化内核调试引擎，我们稍后将详细介绍这个函数。 
三、调用 KiInitializeKernel 开始内核初始化，这个函数会调用 KiInitSystem 来初始化
系 统 的 全 局 数 据 结 构 ， 调 用 KeInitializeProcess 创 建 并 初 始 化 Idle 进 程 ， 调 用
KeInitializeThread 初始化 Idle 线程。 
对于多 CPU 的系统，每个 CPU 都会执行 KiInitializeKernel 函数，但只有第一个 CPU
会执行其中的所有初始化工作，包括全局性的初始化，其它 CPU 会只执行 CPU 相关的部
分。比如只有 0 号 CPU 会调用和执行 KiInitSystem，初始化 Idle 进程的工作也只有 0 号
CPU 执行，因为只需要一个 Idle 进程，但是因为每个 CPU 都需要一个 Idle 线程，所以每
个 CPU 都会执行初始化 Idle 线程的代码。KiInitializeKernel 函数使用参数来了解当前的
CPU 号。全局变量 KeNumberProcessors 标志着系统中的 CPU 个数，其初始值为 0，因此
当 0 号 CPU 执行 KiSystemStartup 函数时，KeNumberProcessors 的值刚好是当前的 CPU 号。
当第二个 CPU 开始运行时，这个全局变量会被递增 1，因此 KiSystemStartup 函数仍然可
以 从 这 个 全 局 变 量 了 解 到 CPU 号 ， 依 此 类 推 ， 直 到 所 有 CPU 都 开 始 运 行 。
ExpInitializeExecutive 函数的第一个参数也是 CPU 号，在这个函数中也有很多代码是根据
CPU 号来决定是否执行的。 
执行体的阶段
执行体的阶段
执行体的阶段
执行体的阶段 0 初始化
初始化
初始化
初始化 
在 KiInitializeKernel 函数结束基本的内核初始化后，它会调用 ExpInitializeExecutive()
开始初始化执行体。如果把操作系统看作是一个国家机器，那么执行体便是这个国家的各
个行政机构。典型的执行体部件有进程管理器、对象管理器、内存管理器、IO 管理器等
等。考虑到各个执行体之间可能有相互依赖关系，所以每个执行体会有两次初始化的机会，
第一次通常是做基本的初始化，第二次做可能依赖其它执行体的动作。通常前者叫阶段 0
初始化，后者叫阶段 1 初始化。 
ExpInitializeExecutive 的主要任务是依次调用各个执行体的阶段 0 初始化函数，包括
调用 MmInitSystem 构建页表和内存管理器的基本数据结构，调用 ObInitSystem 建立名称
空间，调用 SeInitSystem 初始化 token 对象，调用 PsInitSystem 对进程管理器做阶段 0 初
始化（稍后详细说明），调用 PpInitSystem 让即插即用管理器初始化设备链表。 
下面我们仔细看一下进程管理器的阶段 0 初始化，它所做的主要动作有： 
定义进程和线程对象类型。 
建立记录系统中所有进程的链表结构，并使用 PsActiveProcessHead 全局变量指向这个
链表。此后 WinDBG 的!process 命令才能工作。 
为初始的进程创建一个进程对象（PsIdleProcess），并命名为 Idle。 
创建系统进程和线程，并将 Phase1Initialization 函数作为线程的起始地址。 
注意上面的最后一步，因为它衔接着系统启动的下一个阶段，即执行体的阶段 1 初始
化。但是这里并没有直接调用阶段 1 的初始化函数，而是将它作为新创建系统线程的入口
函数。此时由于当前的 IRQL 很高，所以这个线程还得不到执行。在 KiInitializeKernel 函
数 返 回 后 ， KiSystemStartup 函 数 将 当 前 CPU 的 中 断 请 求 级 别 （ IRQL ） 降 低 到
DISPATCH_LEVEL，然后跳转到 KiIdleLoop()，退化为 Idle 进程中的第一个 Idle 线程。当
再有时钟中断发生时，内核调度线程时，便会调度执行刚刚创建的系统线程，于是阶段 1
初始化便可以继续了。 
《软件调试》补编 
- 169 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
执行体的阶段
执行体的阶段
执行体的阶段
执行体的阶段 1 初始化
初始化
初始化
初始化 
阶段 1 初始化占据了系统启动的大多数时间，其主要任务就是调用执行体各机构的阶
段 1 初始化函数。有些执行体部件使用同一个函数作为阶段 0 和阶段 1 初始化函数，使用
参数来区分。图 1 列出了这一阶段所调用的主要函数，简要说明其中几个： 
调用 KeStartAllProcessors()初始化所有 CPU。这个函数会构建并初始化好一个处理器
状态结构，然后调用硬件抽象层的 HalStartNextProcessor 函数将这个结构赋给一个新
的 CPU。新的 CPU 仍然是从 KiSystemStartup 开始执行。 
再次调用 KdInitSystem 函数，并且调用 KdDebuggerInitialize1 来初始化内核调试通信
扩展 DLL（KDCOM.DLL 等）。 
调用 IO 管理器的阶段 1 初始化函数 IoInitSystem 做设备枚举和驱动加载工作，需要花
很长的时间。 
在这一阶段结束前，会创建第一个使用映像文件创建的进程，即会话管理器进程
（SMSS.EXE）。会话管理器进程会初始化 Windows 子系统，创建 Windows 子系统进程和
登录进程（WinLogon.EXE），我们以后再介绍。 
0x7B 蓝屏
蓝屏
蓝屏
蓝屏 
上面介绍的过程不总是一帆风顺的。如果遇到意外，那么系统通常会以蓝屏形式报告
错误。比如图 2 所示的 0x7B 蓝屏就是发生在内核和执行体初始化期间的（我们上一期的
问题）。 
图 2  0x7B 蓝屏 
注意这个蓝屏的下方没有转储有关的信息（稍后你就会明白原因了）。 
那么应该如何寻找这个蓝屏的故障原因呢？ 
首先可以根据蓝屏的停止代码 0x7B 查阅 WinDBG 的帮助文件或者 MSDN 了解它的
含义。于是我们知道，0x7B 是 INACCESSIBLE_BOOT_DEVICE 错误的代码，其含义是
不可访问的引导设备。意思是系统在读或者写引导设备时出错了，进一步来说，也就是在
访问包含有系统文件的磁盘分区时出问题了。 
访问系统分区怎么会出问题呢？操作系统加载程序刚刚不是还读过系统分区来加载
系统文件了的，现在怎么不能访问了呢？磁盘设备在这两个时间点之间损坏的概率很低，
《软件调试》补编 
- 170 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
因此，主要的原因还是因为访问的方式不同了。操作系统加载程序是使用简单的方式来访
问磁盘的，而操作系统内核开始运行后，开始改用更为强大的驱动程序来访问磁盘，而这
里恰恰是常出问题的地方。对于典型的 IDE 硬盘，需要使用 ATAPI.SYS 这个驱动程序来
进行访问。那么 ATAPI 这个驱动是谁来加载的呢？让内核自己来加载，肯定不行，因为
内核是依赖它来访问磁盘的，正所谓“自己的刀刃削不了自己的刀把”。那么应该由谁来
加载呢？OS Loader，也就是 NTLDR 或者 WinLoad。它们怎么知道要加载这个驱动呢？是
根据注册表。图 2 显示了注册表中 ATAPI 驱动程序的各个键值。其中的 Start 键值等于 0
代表是引导类型，Group 键值标志着这个驱动属于 SCSI miniport 这个组。OS Loader 看到
Start 键值为 0 后，就会将这个驱动程序加载到内存中。我们不妨把以这种方式加载的驱动
程序称为第一批加载的驱动程序。 
图 3  ATAPI 驱动程序的注册表键值 
如果按 F8 通过高级选项菜单中的某一项启动，那么 NTLDR 会显示出它加载的第一
批驱动程序的清单（图 4）。 
在上面的清单中，没有 ATAPI.SYS，这正是问题所在。事实上笔者就是将 Start 值改
为 3 来“制造”出这个蓝屏的（读者一定不要草率模仿，以免丢失数据）。 
图 4 第一批加载的驱动程序清单 
除了观察访问磁盘的关键驱动程序是否加载，还可以使用内核调试来做进一步的分
析。如果目标系统事先没有启用内核调试，那么可以在引导初期按 F8 调出高级引导菜单，
《软件调试》补编 
- 171 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
然后选择 Debug。这时系统通常会使用串行口 2（COM2）以波特率 19200 来启用内核调
试引擎（参见《软件调试》18.3.3 P478）。然后使用一根串口通信电缆将目标机器与调试
主机相连接（主机不一定要使用 COM2）。 
成功建立调试会话后，在出现蓝屏前，调试器便会收到通知： 
*** Fatal System Error: 0x0000007b 
                       (0xFC8D3528,0xC0000034,0x00000000,0x00000000) 
此时观察栈回溯，便可以看到发生蓝屏的过程： 
kd> kn 
 # ChildEBP RetAddr   
00 fc8d3090 805378e7 nt!RtlpBreakWithStatusInstruction 
01 fc8d30dc 805383be nt!KiBugCheckDebugBreak+0x19 
02 fc8d34bc 805389ae nt!KeBugCheck2+0x574 
03 fc8d34dc 806bdc94 nt!KeBugCheckEx+0x1b 
04 fc8d3644 806ae093 nt!IopMarkBootPartition+0x113 
05 fc8d3694 806a4714 nt!IopInitializeBootDrivers+0x4ba 
06 fc8d383c 806a5ab0 nt!IoInitSystem+0x712 
07 fc8d3dac 80582fed nt!Phase1Initialization+0x9b5 
08 fc8d3ddc 804ff477 nt!PspSystemThreadStartup+0x34 
09 00000000 00000000 nt!KiThreadStartup+0x16 
这个栈回溯表明这个系统线程正在做执行体的阶段 1 初始化。目前在执行的是 IO 管
理器的 IoInitSystem 函数。后者又调用 IopInitializeBootDrivers 来初始化第一批加载的驱动
程序。IopInitializeBootDrivers 又调用 IopMarkBootPartition 来把引导设备标识上引导标记。
在做标记前，IopMarkBootPartition 需要打开引导设备，获得它的对象指针。但是打开这个
设备时失败了，于是 IopMarkBootPartition 调用 KeBugCheckEx 发起蓝屏，报告错误。 
蓝屏停止码的第一个参数是引导设备的路径，使用 dS 命令可以显示其内容： 
kd> dS fc8d3528 
e13fa810  "\ArcName\multi(0)disk(0)rdisk(0)" 
e13fa850  "partition(1)" 
蓝屏停止码的第二个参数是 IopMarkBootPartition 调用 ZwOpenFile 打开引导设备失败
的返回值。使用!error 命令可以显示其含义： 
kd> !error 0xC0000034 
Error code: (NTSTATUS) 0xc0000034 (3221225524) - Object Name not found. 
也就是没有这样的设备对象存在，无法打开，这是因为没有加载 ATAPI 驱动。 
观察系统中的进程列表，可以看到系统中目前只有 System 进程和 IDLE 进程。 
kd> !process 0 0 
**** NT ACTIVE PROCESS DUMP **** 
PROCESS 812917f8  SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000 
    DirBase: 00039000  ObjectTable: e1000b98  HandleCount:  34. 
    Image: System 
使用 lm 观察模块列表，可以看到与图 4 中一致的结果。也就是说，目前系统中还没
有加载普通的驱动程序，必须等到引导类型的驱动程序初始化结束后，也就是访问磁盘和
文件系统的第一批驱动程序准备好了后，才可能加载其它驱动程序。 
对于上面分析的例子，原因是由于注册表异常而没有加载必要的 ATAPI.SYS。知道了
原因后，对于 Windows Vista 可以使用我们上一期介绍的用安装光盘引导到恢复控制台，
然后将注册表中的 Start 键值改回到 0 系统便恢复正常了。对于 Windows XP，可以借助
ERD Commander 等工具来引导和修复。 
在上一期的读者来信中，天津的黄小非先生给出了很全面的分析，把导致问题的可能
原因归纳为病毒破坏、驱动程序故障和硬件故障三种情况，归纳的很好。关于如何定位原
因，他提到了使用转储文件（DUMP），也是有帮助的。但因为默认的小型转储文件包含
的信息有限，所以我们在上文中重点介绍了利用双机内核调试来跟踪和分析活动的目标。
《软件调试》补编 
- 172 – 
Copyright © 2009 ADVDBG.ORG All Rights Reserved 
因为建立内核调试会话的详细步骤很容易找到，所以我们没有详细描述，感觉有困难的朋
友可以参考 WinDBG 帮助文件中 Kernel-Mode Setup 一节，有《软件调试》一书的朋友可
以看第 18 章的前三节。黄小非在来信中还对我们以后要讨论的内容提出了很好的建议，
我们会认真考虑这些建议，在此深表感谢。 
下一期的问题： 
一台装有 Windows 的系统输入用户名和密码后桌面一闪便自动 Log Off 了，再尝试登
录，现象一样，始终无法进入到正常的桌面状态，哪些原因会导致这样的问题，该如何来
解决？