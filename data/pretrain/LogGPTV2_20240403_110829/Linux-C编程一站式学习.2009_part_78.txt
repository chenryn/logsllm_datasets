波特率 
643
表
---
## Page 644
登录和使用伪终端的过程。
文件名"的实验结果可以看到，
类似，
块，
Slave）组成。主设备在概念上相当于键盘和显示器,
数目也不超过串口的数目。然而网络终端或图形终端窗口的数目却是不受限制的，
虚拟终端或串口终端的数目是有限的，
1.3.网络登录过程 请点评
其它进程也都是如此。
端没变,
注意argy[0]参数的程序名前面加了一个-，
（Pseudo TTY）实现的。
2．telnetd子进程打开一个伪终端设备，然后再经过fork一分为二:
更为灵活。
Super-Server，它监听系统中的多个网络服务端口，
另外一种可能是服务器端由系统服务程序inetd或xineta监听连接请求,
监听其它连接请求。
器监听连接请求是-
用户通过telnet客户端连接服务器。
口
图34.3.伪终端
只不过它的底层驱动程序不是访问硬件而是访问主设备。通过例 34.1“查看终端对应的设备
号一致，
内核
网络设备驱动
协议栈
TCP/IP
则fork/exec
←
+
网络
一套伪终端由一个主设备（PTYMaster）和一个从设备（PTY
，网络终端或图形终端窗口的Shell进程以及它启动的其它进程都会认
内核
用户
网络设备驱动
协议栈
TCP/IP
如果服务器配置为独立（Standalone）模式，
它fork出一个telnetd子进程来服务客户端，
，这样bash就知道自己是作为登录Shell启动的，
再exec到bash，
伪终端主设备
2. exec /bin/login
只不过它不是真正的硬件而是一个内核模
1. fork
，如果连接请求的端口号和telnet服务端
 其实都是同-
read/write等系统调用的实现
：父进程操作伪终端主设备，
stderr
line discipline 
伪终端从设备
bash
ineta称为Internet
一个进程，因此控制终
stdin
这是通过伪终端
，串口终端的
父进程仍
则在服务
执行登
644
---
## Page 645
于SYSV的伪终端。
时就从/dev/pts目录下删除相应的从设备文件。Linux同时支持上述两种伪终端，目前的标准倾向
BSD系列的UNIX在/dev目录下创建很多ptyxx和ttyxx设备文件，
第 34 章终端、作业控制与守护进程
设
真的是这样：
经过伪终端主设备和从设备之后被Shel进程读取，同时回显到伪终端从设备，回显的字符再经过
显到屏幕上。这说明我们每按一
上一页
备，
果telnet客户端和服务器之间的网络延迟较大，
相对应的ttyxx是从设备，
由telnetd服务器发回给telnet客户端，
由telneta服务器代表用户将这些字符输入伪终端。Shell进程并不知道自己连接的是伪终端而
当用户输入命令时，
件，而操作这个伪终端的“用户"就是父进程telnetd。
个Shel进程认为自己的控制终端是伪终端从设备，伪终端主设备可以看作键盘显示器等硬
过伪终端通信，
子进程将伪终端从设备作为它的控制终端，
。Shell仍然解释执行命令，将标准输出和标准错误输出写到终端设备，这些数据最终
每按一
一个键都要在网络上走个来回！
“mx"表示Multiplex，
一个主设备，
一个键telnet客户端都会立刻把该字符发送给服务器，
伪终端的数目取决于内核配置。
全国嵌入式人才培训基地
意思是多个主设备复用同一个设备文件，
，然后显示给用户看。
，提示输入密码，
起始页
上一级
，我们会观察到按下一
 并且将文件描述符0、1、
，而子进程负责用户的登录过程，
，然后调用exec变成Shell进程。这
，而在SYS V系列的UNIX上,
一个键之后要过几秒钟才能
、2指向控制终端,
当终端关闭
，每打开一
然后这个字符
2.作业控制
提示输
下一页
伪终
二者通
---
## Page 646
现在我们从Session和进程组的角度重新来看登录和执行命令的过程。
组的所有进程。各进程、进程组、Session的关系如下图所示。
Control）。例如用以下命令启动5个进程（这个例子出自[APUE2el）：
2.1. Session与进程组 请点评
2.作业控制请点评
控制终端输入特殊的控制键（例如Ctrl-C）时，
程本身属于一个单独的进程组。这些进程组的控制终端相同，
由多个进程组成,
（Job）或者进程组（Process Group）。
在第1节“信号的基本概念"中我说过"Shell可以同时运行一个前台进程和任意多个后台进程"其实是
上一页
程是这个进程组的Process Group Leader，该进程的id也是进程组的id。
个Session中所有进程的控制终端。在创建新Session的同时也创建了一个新的进程组，该进
图 34.4.Session与进程组
process group
L
 proc3
 proc1
1
一
bash
一
，Shell可以同时运行
一
proc4
proc2&
一
一
一
process group
1 proc5
一
一一一
一
proc2
procl
第 34章终端、作业控制与守护进程
一
session
一
一
一个前台作业和任意多个后台作业，这称为作业控制（Job
全国嵌入式人才培训基地
一
L
_proc3、proc4、proc5属于同一个前台进程组，Shell进
一个前台作业可以由多个进程组成，
2.作业控制
，内核会发送相应的信号（例如SIGINT）给前台进程
一
proc3
一
process group
一一
，Shell分前后台来控制的不是进程而是作业 
一
proc5
一
一
proc4
 它们属于同一个Session。当用户在
一
一个后台作业也可以
该进程称
646
下一
贝
---
## Page 647
我们通过实验来理解与作业控制有关的信号。
2.2.与作业控制有关的信号 请点评
分，8835是该作业中某个进程的id。请读者自己分析ps命令的输出结果。
这个作业由ps和cat两个进程组成，
就是两个子进程所在的进程组。
进程都在同一
的Leader,
这个作业由ps和cat两个进程组成，在前台运行。
下面看两个例子。
2．在登录过程中，getty或telneta进程变成1ogin，然后变成Shell，但仍然是同一个进程，仍然
 由Shell进程fork出的子进程本来具有和Shell相同的Session、进程组和控制终端，但
果原来的前台进程组还存在（如果这个子进程还没终止），
在上面的例子中，
是Session Leader。
不
某
进
组
行
[1]+  Stopped
是，这是作业和进程组在概念上的区别。
会调用wait等待它结束。
S
S
下例 30.3“fork"）
个进程又fork出子进程，
程组的Leader,
S
6994
所以ShelI所在的进程组就自动变成后台进程组。
cat
(再次回车)
而两个子进程在id为8762的进程组中
9886
PID
-Session中,
p
6994
6989
6869
 PPID PGRP SESS TPGID COMMAND
8834
8834
6994
6994
proc3、
bash是Session Leader。从rPGID可以看出，前台进程组的id是8762，
，[1]是作业的编号，
6994
6994
6994
6994
6994
换句话说，
 子进程也属于同一进程组，
D
，在后台运行，bash不等作业结束就打印提示信息[1”8835然后
6994
8762
8762
cat
cat
bash
cat
ps
 bash
如果同时运行多个作业可以用这个编号区
。从PPID列可以看出这两个进程的父进程是bash。
 这个id等于bash的进程id，所以它是进程组
一旦作业运行结束，Shell就把自己提到前台，
由于-
Icat &
cat
一旦它们全部运行结束，Shell就调
 但是Shell并不知道子进程的存在，也
|proc5是Shell的作业,
，则它自动变成后台进程组（回顾
一个Session只能有一个前台进程
 其中有一个进程是该
而这个子进程
647
也
如
---
## Page 648
行之前处理，默认动作是终止进程。但如果给一个停止的进程发sIGKILL信号就不同了。
用kill命令给一
而停止。
号。cat进程继续运行，
台进程发SIGTSTP信号
在后台运行则提至前台运行，
jobs命令可以查看当前有哪些作业。fg命令可以将某个作业提至前台运行，
的，
将cat放到后台运行，
，因此内核发SIGTTIN信号给进程，该信号的默认处理动作是使进程停止。
11121
Terminated
[1]+ 
11122
S
S
cat
110
11022
SS
11023
L
S
[1]+ 
S
[1]+ 
hello
[1]+
Z
cat"
6994
11
S
6994
6994
[1]
PID TTY
fg 
kil1 11022
1022
2.8
kill
fg %1
 jobs
024
ID
ID
+
 %1
Killed
.Stopped_
cat 
 pts/0
山山
 Stopped
%1
pts/0
pts/0
一个停止的进程发SIGTERM信号，
pts/0
 pts/0
pts/0
pts/0
pts/0
人山山
 Stopped
 Stopped
-KILL 11121
3
由于cat需要读标准输入（也就是终端输入）
，又要读终端输入，然而它在后台不能读终端输入，所以又收到sIGTTIN信号
 该信号的默认动作是使进程停止。
00:00:00 ps
00:00:00
00:00:05
00:00:00 ps
00:00:00
00:00:05
00:00:00
00:00:00
00:00:05 bash
如果该作业处于停止状态，
TIME CMD
TIME
TIME
 cat
 cat
CMD
CMD
 bash
bash
cat
cat
cat
cat
cat
，然后继续挂起等待输入。如果输入Ctrl-Z则向所有前
这个信号并不会立刻处理，
则给进程组的每个进程发SIGCONT信号使
而后台进程是不能读终端输入
，而要等进程准备继续运
，挂起等待终端输入，
，如果该作业的进程组正
台
---
## Page 649
收到一个sIGTTOU信号，默认处理动作也是停止进程。
首先用stty命令设置终端选项，
终端选项禁止后台进程写。
呢？通常是允许写的。
常时管理员总是有办法杀掉有问题的进程或者暂时停掉怀疑有问题的进程。
处理。与此类似的还有SIGSTOP信号,
SIGKILL信号既不能被阻塞也不能被忽略，
1.终端
上面讲了如果后台进程试图从控制终端读，
cat
[l]+ 
[1] 11428
[1]+, Done.
fg 
cat
stty
hello
cat 
testfile
11426
%1
 Stopped
testfile &
，如果觉得后台进程向控制终端输出信息干扰了用户使用终端，可以设置一个
，禁止后台进程写，然后启动一个后台进程准备往终端写，这时进程
给一
全国嵌入式人才培训基地
一个进程发SIGSTOP信号会使进程停止，这个默认的处理动
，也不能用自定义函数捕捉，
，会收到SIGTTIN信号而停止，
cat testfile
cat testfile
起始页
只能按系统的默认动作立刻
如果试图向控制终端写
3.守护进程
下一页
---
## Page 650
进程中调用setsid就不会有问题了。
程组中，进程组的Leader必然是该组的第一
程组的Leader也很容易，
创建守护进程最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。