**图 9-5 Web 伺服器和影象缩放器透过档案储存和讯息伫列进行通讯，开启竞争条件的可能性。**
如果档案储存服务是线性一致的，那么这个系统应该可以正常工作。如果它不是线性一致的，则存在竞争条件的风险：讯息伫列（[图 9-5](../img/fig9-5.png) 中的步骤 3 和 4）可能比储存服务内部的复制（replication）更快。在这种情况下，当缩放器读取影象（步骤 5）时，可能会看到影象的旧版本，或者什么都没有。如果它处理的是旧版本的影象，则档案储存中的全尺寸图和缩图就产生了永久性的不一致。
出现这个问题是因为 Web 伺服器和缩放器之间存在两个不同的通道：档案储存与讯息伫列。没有线性一致性的新鲜性保证，这两个通道之间的竞争条件是可能的。这种情况类似于 [图 9-1](../img/fig9-1.png)，资料库复制与 Alice 的嘴到 Bob 耳朵之间的真人音讯通道之间也存在竞争条件。
线性一致性并不是避免这种竞争条件的唯一方法，但它是最容易理解的。如果你可以控制额外通道（例如讯息伫列的例子，而不是在 Alice 和 Bob 的例子），则可以使用在 “[读己之写](ch5.md#读己之写)” 讨论过的类似方法，不过会有额外的复杂度代价。
### 实现线性一致的系统
我们已经见到了几个线性一致性有用的例子，让我们思考一下，如何实现一个提供线性一致语义的系统。
由于线性一致性本质上意味著 “表现得好像只有一个数据副本，而且所有的操作都是原子的”，所以最简单的答案就是，真的只用一个数据副本。但是这种方法无法容错：如果持有该副本的节点失效，资料将会丢失，或者至少无法访问，直到节点重新启动。
使系统容错最常用的方法是使用复制。我们再来回顾 [第五章](ch5.md) 中的复制方法，并比较它们是否可以满足线性一致性：
* 单主复制（可能线性一致）
  在具有单主复制功能的系统中（请参阅 “[领导者与追随者](ch5.md#领导者与追随者)”），主库具有用于写入的资料的主副本，而追随者在其他节点上保留资料的备份副本。如果从主库或同步更新的从库读取资料，它们 **可能（potential）** 是线性一致性的 [^iv]。然而，实际上并不是每个单主资料库都是线性一致性的，无论是因为设计的原因（例如，因为使用了快照隔离）还是因为在并发处理上存在错误【10】。
  [^iv]: 对单主资料库进行分割槽（分片），使得每个分割槽有一个单独的领导者，不会影响线性一致性，因为线性一致性只是对单一物件的保证。交叉分割槽事务是一个不同的问题（请参阅 “[分散式事务与共识](#分散式事务与共识)”）。
  从主库读取依赖一个假设，你确切地知道领导者是谁。正如在 “[真相由多数所定义](ch8.md#真相由多数所定义)” 中所讨论的那样，一个节点很可能会认为它是领导者，而事实上并非如此 —— 如果具有错觉的领导者继续为请求提供服务，可能违反线性一致性【20】。使用非同步复制，故障切换时甚至可能会丢失已提交的写入（请参阅 “[处理节点宕机](ch5.md#处理节点宕机)”），这同时违反了永续性和线性一致性。
* 共识演算法（线性一致）
  一些在本章后面讨论的共识演算法，与单主复制类似。然而，共识协议包含防止脑裂和陈旧副本的措施。正是由于这些细节，共识演算法可以安全地实现线性一致性储存。例如，Zookeeper 【21】和 etcd 【22】就是这样工作的。
* 多主复制（非线性一致）
  具有多主程式复制的系统通常不是线性一致的，因为它们同时在多个节点上处理写入，并将其非同步复制到其他节点。因此，它们可能会产生需要被解决的写入冲突（请参阅 “[处理写入冲突](ch5.md#处理写入冲突)”）。这种冲突是因为缺少单一资料副本所导致的。
* 无主复制（也许不是线性一致的）
  对于无主复制的系统（Dynamo 风格；请参阅 “[无主复制](ch5.md#无主复制)”），有时候人们会声称透过要求法定人数读写（ $w + r > n$ ）可以获得 “强一致性”。这取决于法定人数的具体配置，以及强一致性如何定义（通常不完全正确）。
  基于日历时钟（例如，在 Cassandra 中；请参阅 “[依赖同步时钟](ch8.md#依赖同步时钟)”）的 “最后写入胜利” 冲突解决方法几乎可以确定是非线性一致的，由于时钟偏差，不能保证时钟的时间戳与实际事件顺序一致。宽松的法定人数（请参阅 “[宽松的法定人数与提示移交](ch5.md#宽松的法定人数与提示移交)”）也破坏了线性一致的可能性。即使使用严格的法定人数，非线性一致的行为也是可能的，如下节所示。
#### 线性一致性和法定人数
直觉上在 Dynamo 风格的模型中，严格的法定人数读写应该是线性一致性的。但是当我们有可变的网路延迟时，就可能存在竞争条件，如 [图 9-6](../img/fig9-6.png) 所示。
![](../img/fig9-6.png)
**图 9-6 非线性一致的执行，尽管使用了严格的法定人数**
在 [图 9-6](../img/fig9-6.png) 中，$x$ 的初始值为 0，写入客户端透过向所有三个副本（ $n = 3, w = 3$ ）传送写入将 $x$ 更新为 `1`。客户端 A 并发地从两个节点组成的法定人群（ $r = 2$ ）中读取资料，并在其中一个节点上看到新值 `1` 。客户端 B 也并发地从两个不同的节点组成的法定人数中读取，并从两个节点中取回了旧值 `0` 。
法定人数条件满足（ $w + r> n$ ），但是这个执行是非线性一致的：B 的请求在 A 的请求完成后开始，但是 B 返回旧值，而 A 返回新值。（又一次，如同 Alice 和 Bob 的例子 [图 9-1](../img/fig9-1.png)）
有趣的是，透过牺牲效能，可以使 Dynamo 风格的法定人数线性化：读取者必须在将结果返回给应用之前，同步执行读修复（请参阅 “[读修复和反熵](ch5.md#读修复和反熵)”） ，并且写入者必须在传送写入之前，读取法定数量节点的最新状态【24,25】。然而，由于效能损失，Riak 不执行同步读修复【26】。Cassandra 在进行法定人数读取时，**确实** 在等待读修复完成【27】；但是由于使用了最后写入胜利的冲突解决方案，当同一个键有多个并发写入时，将不能保证线性一致性。
而且，这种方式只能实现线性一致的读写；不能实现线性一致的比较和设定（CAS）操作，因为它需要一个共识演算法【28】。
总而言之，最安全的做法是：假设采用 Dynamo 风格无主复制的系统不能提供线性一致性。
### 线性一致性的代价
一些复制方法可以提供线性一致性，另一些复制方法则不能，因此深入地探讨线性一致性的优缺点是很有趣的。
我们已经在 [第五章](ch5.md) 中讨论了不同复制方法的一些用例。例如对多资料中心的复制而言，多主复制通常是理想的选择（请参阅 “[运维多个数据中心](ch5.md#运维多个数据中心)”）。[图 9-7](../img/fig9-7.png) 说明了这种部署的一个例子。