这样就可以作为preg函数的pattem参数了。
如果指定的分隔符是“（’之类对称的字符，那么对应的字符（例如‘”）不会转义，所以
请务必使用非对称的分隔符。
同样，空白字符和“#’也不会转义，所以结果可能不适于用x修饰符。
这样说来，在把任意文本转换为PHP正则表达式的问题上，Dreg_quote并不是完善的解
决办法。它只解决了“文本到正则表达式”的问题，而没有解决“正则表达式到pattem参
数”的问题，任何preg函数都需要这一步。下一节给出了解决办法。
“缺失”的preg函数
“Missing”PregFunctions
PHP内建的preg函数已经提供了繁多的功能，但是有时候我仍然发现它们不够用。一个例
子是我自己开发的preg_match（r454)。
我发现，另一类需要提供自己的支持函数的情形是，正则表达式不是在程序内部通过patterm
参数字符串提供的，而是来自程序外部（例如，从文件读人，或者是在Web表单中提交）。
下一节我们将会看到，把纯粹的正则表达式字符串转换为适合paterm参数使用的形式也很
复杂。
同样，在使用这些正则表达式之前，通常都必须验证他们的语法正确性。我同样会讲解这
些问题。
与本书中的所有程序代码一样，下一页的函数也可以从我的网站下载：http://regex.info/。
制
---
## Page 498
472
第10章：PHP
如果正则表达式包含在字符串中（可能是从配置文件读入，或者通过Web表单提交），在
preg函数中使用时，首先必须在两端加上分隔符，才能生成一个preg函数能用的patterm参
数。
问题所在
许多时候，把正则表达式转换为pattern参数只不过是在两端加上斜线而已。这样，正则表
达式字符串“[a-z]+’就成了‘/[a-z]+/，可以用作preg函数的pattern参数的字符串。
如果正则表达式中包含用作分隔符的字符，情况就很复杂。例如，正则表达式是
^http：//（[~/：]+）”，仅仅在两端添加反斜线得到“/^http：//（[~/：]+）/”，用作pattern
时，结果会是“Unknownmodifier/”。
第448页已经介绍过，这个错误信息是因为字符串中的前两个斜线字符被当作分隔符，之
后的部分（在这里就是第3个斜线之后的部分）被当作修饰符序列了。
解决之道
有两种办法能解决内嵌分隔符的问题。之一是选择正则表达式中没有出现的分隔符，如果
需要手工构造pattern-modifier字符串，那么这当然是推荐的办法了。所以我在第444、449
和450页（还有许多）的例子中使用（）作为分隔符。
要选出正则表达式中没有出现的分隔符可能并不容易（甚至不可能），因为字符串中可能包
含所有分隔符，或者你不能预先知道需要处理的文本。在实际应用正则表达式时这需要特
别关注，所以最简单的办法是使用第二种：选择一个分隔符，然后对正则表达式字符串中
出现的此分隔符进行转义。
问题可能比初看起来要困难许多，因为你必须关注某些重要的细节。例如，在目标字符串
末尾的转义必须进行特殊处理，保证它不会转义紧跟在后面的分隔符。
下面的函数接收正则表达式字符串，以及可能出现的pattern-modifier字符串，返回一个可
以用于preg函数的pattermn字符串。代码中难看的反斜线（正则表达式和PHP子串转义）或
---
## Page 499
“缺失”的preg函数
473
许是你见过的最复杂的表示：这段代码并不容易读懂（如果你希望补习PHP单引号字符申
的语意，请参考第444页）。
/ *
*输入字符串形式的正则表达式（或许是pattern-modifier字持串），返回适合preg函数
*的字符串，此表达式包含在分隔符之内，后面可能还跟有修饰符
* /
function preg_regex_to_pattern($raw_regex, $modifiers = *")
/ *
进行转换需要在Dattern两端添加分隔符（这里使用斜线）并添加修饰符
*必须转义表达式内部的分隔符、表达式结尾的转义必须特殊处理，否则它会转义最后的分隔符
·不能盲目转义表达式内部的分隔符，因为表达式内部可能包括已经转义的分隔符
*例如，如果表达式是\/，盲目转义得到·\\/，最终结果是/\\//、这显然不对
*应当把表达式分为三类：已转义的字符、未转义的斜线（需要处理）和其他宇符。
·还需要注意宇符事结尾的转义
*/
if（！preg_match（*{\\\\(1:/1S））·，$raw_regex)）/*后面是·\·或EOS的·/*/
/不存在已转义的斜线，末尾也没有转义，直接转义其中的斜线即可*/
Scooked =preg_replace('!/!'，'\/',$raw_regex);
else
1
/*用来解析Sraw_regex的pattern
捕获型括号内的两个部分需要转义*/
$pattern='（[\\/]+丨\.1（/\\$）}sx';
/*Sraw-regex中Spattern的每次成功匹配都需要调用回调函数
*如果Smatches[1]不为空，返回转义后的结果
★否则不做修改直接返回*/
$f=create_function（'Smatches'，’/*这个长长的
if (empty($matches[1]))
·/*单引号
return $matches[0];
/*字符串就是
else
/*函数的
return"\\\\”.$matches[1];/*代码
/*将Spattern应用到Sraw_regex，得到scooked*/
$cooked =preg_replace_callback($pattern,$f，$raw_regex);
/*现在可以在Scooked两端添加分隔符了，然后附上修饰符，然后返回*/
return "/Scooked/Smodifiers";
preg套件中的内建函数）。
有兴趣的读者不妨想想函数尾部preg_replace_callback使用的正则表达式：它如何工
---
## Page 500
474
第10章：PHP
作，以及回调函数如何遍历整个pattem字符串，转义每个未转义的斜线，而不修改已转义
的斜线。
对未知的Pattern参数进行语法检查
Syntax-CheckinganUlnknounPatternArgument
在正则表达式两端添加分隔符之后，我们确信它适于用作preg函数的patterm参数了，但是
原来的正则表达式还没有经过语法正确性检验。
举例来说，如果原始的正则表达式是“*.txt，因为某些人希望使用文件群组功能（4）
而不是正则表达式，那么preg_regex_to_pattern返回的就是/*.txt/。这个正则表达式
当然不合法，所以程序会发出警报（如果启用了警报功能）：
Compilation failed:nothing to repeat at offset 0
PHP没有内建检测pattern参数及其正则表达式的语意是否合法的函数，不过我为读者提供
了一个。
preg_pattern_error会对patterm参数进行简单测试，试图使用此正则表达式-在函数
当中有一行调用preg_match。函数的其他部分使用关注PHP的管理功能处理preg_match
可能显示的错误信息。
*
*如果输入的pattern或其中的正则表达式参数语法不正确，输出错误信息
*否则（语法正确）返回false。
*/
function preg_pattern_error($pattern)
/ *
*要判断pattern是否有错，直接尝试使用它。
*检测和捕获此错误却不容易、尤其是希望获得友好提示，而且不修改全局状态
*所以扣果打开了‘track_errors”，则保存Sphp_errormsg，之后恢复它的状态
★如果没有打开，则打开它（因为常要用到），完成之后再关闭
*/
if ($old_track = ini_get("track_errors"))
Sold_message =isset($php_errormsg)? $php_errormsg :false;
else
ini_set('track_errors',1);
/*现在确认track_errors已经打开*/
unset(Sphp_errormsg);
preg_match（$pattern，""）：/*云试使用pattern*/
$return_value=isset(Sphp_errormsg)? $php_errormsg:false;
/*现在捕获了需要的内容，恢复全局状态*/
if ($old_track)
$php_errormsg=isset($old_message)? $old_message:false;
else
ini_set('track_errors',0);
return $return_value;
---
## Page 501
递归的正则表达式
475
对未知正则表达式进行语法检查
Syntax-CheckinganLlrknownRegex
这个函数使用刚刚开发的功能来检查一个纯正则表达式（没有分隔符也没有模式修饰符）
的语法。如果语法不正确，会返回对应的错误信息，如果语法正确，返回false。
/ *
*如果表达式语法错误，返回错误信息，如果语法正确返回false
*/
function preg_regex_error($regex)
return preg_pattern_error(preg_regex_to_pattern($regex));
递归的正则表达式
Recursive Expressions
preg引擎所属的流派的大多数方面都在第3章中有所介绍，但是此流派还提供了某些新的
有意思的功能用于匹配嵌套结构：递归的表达式。
序列（?R）表示“在此处递归应用整个表达式”，而（?num）表示“在此处递归应用num
所对应编号的捕获型括号中的序列”。命名捕获的括号则使用（?P>name）表示法。
下面几节展示了常见的递归。递归在扩展的“taggeddata”例子（481）中占有重要地位。
匹配嵌套括号内的文本
MatchingTextwithNestedParentheses
基本的递归的例子是匹配嵌套的括号内的文本，下面是一种办法：（?：[^（）]++
1\（(？R)\))*1。
这个表达式匹配任意多个双多选分支结构。第1个多选分支[（）】++匹配除括号之外的任
何字符。因为外面有（？：）*，这个多选分支要求使用占有优先的加号，避免“无休止匹
配”(226)。
另一个多选分支（（?R）\）才是问题的关键。它匹配一对括号，其中可以包括任何字符（只
要括号的嵌套是格式正确的）。这里的“之间”的部分是整个正则表达式希望匹配的内容，
也就是我们可以通过（?R）直接递归使用整个正则表达式的原因。
---
## Page 502
476
第10章：PHP
这个表达式本身可以正常工作，但如果要添加任何字符，请务必小心，因为调用（？R）时
添加的任何字符同样会递归。
如果使用这个正则表达式来校验一个括号配对不正确的字符串，你可能希望在两端加上
~Si来确保“整个字符串"。这是不对的，因为添加的行锚点会被递归应用到整个字符串
之中，导致匹配失败。
递归引用一组捕获型括号
（?R）结构会递归引用整个正则表达式，但也可以使用（?num）结构引用到其中的子集。
它递归引用编号为num的捕获型括号内的子表达式（注4)。如果用（?num）来思考，（?0）
就等于（?R）。
我们可以使用这种部分递归因来解决前面那一节中出现的问题：在添加~.S之前，我们用
一个捕获型括号把正则表达式的主体部分围起来，然后在以前使用（?R）的地方使用（？1）。
添加捕获型括号是为了让（?1）能够引用，你或许还记得，这就是上一节匹配嵌套括号的
表达式。^…$：加在这些括号之外，这样我们就不会对它们进行递归调用：
（(？:[（)]++1\（(?1)\))+)$。
正则表达式中下画线的部分是第1组捕获型括号，所以每次遇到（?1）都会重新应用。
下面PHP代码中的正则表达式会报告Stext中的括号能否配对：
if（preg_match（*/^（（?:[^()]++1\（（?1）\））*）$/x'，Stext）)
echo "text is balanced\n";
else
echo“text is unbalanced\n";
通过命名捕获进行递归引用
如果需要递归调用的自表达式处于命名捕获（138）中，就可以使用（?P>name）进行递
归引用，而不是之前的（?num）表示法。使用这个表示法，我们的例子就成了：
{(?P（?：[^(）]++1\((?P>stuff)\）)*)S.”
注4：严格地说，（?num）不算递归引用，这是因为，（?num）结构本身并不必然是编号为numh
的捕获型括号中的子表达式的一部分。此时，引用可以被看作“子程序调用”。
---
## Page 503
递归的正则表达式
477
这个表达式可能看起来很复杂，用模式修饰符x可以看得更清楚一点：
Spattern = '{
#正则表达式从此处开始...
(?P
这一组括号内的所有内容都被命名为"stuff.”
(? :
[~() ] + +
#除括号之外的任何字符
1
\((?P>stuff)\)
#开括号、更多"stuff，"然后是闭括号
*
1
#正则表达式结束
}x'：#‘x'是模式修饰符
if (preg_match($pattern,$text))
echo *text is balanced\n";
else
echo*text is unbalanced\n*;
关于占有优先量词的补充
我会对表达式中的占有优先量词做最后的补充。如果外部的（？：）*是占有优先的，内部
就不必使用[（）]++1。为了阻止这个表达式进入无休止匹配，其中之一（或者是两者）必
须是占有优先的。如果不能使用占有优先量词和固化分组（259），则需要去掉所有的量
词（？：[（）]1（(？R）））*1
这样会降低效率，但是至少不会进入无法终止的匹配。要提高效率，可以使用第6章介绍
的“消除循环”的技巧，得到[~（）]*（？：\（（？R）\）[^（）]*）*]。
不能回溯到递归调用之内
No Backtrncking Into Recursion
preg正则流派的递归语意的重要特性之一是，它会把递归结构匹配的所有内容当作固化分
配的内容来实现全局匹配（而是导致整个匹配失败）。
来交还。但不容许回溯到递归调用之内的某个状态。
---
## Page 504
478
第10章：PHP