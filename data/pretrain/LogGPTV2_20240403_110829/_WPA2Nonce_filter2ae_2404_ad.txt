3。及时它注意到了这个数据包并没有加密，但是Android和Linux例外允许未加密的EAPOL包，因此CPU会执行这个重传Message
3。因为网卡刚刚装载了PTK，因此这个回复会是在Nonce为1的情况下加密的。在这之后，CPU再次让无线网卡装载PTK。同时，无线网卡也会重置与PTK相关的Nonce和重传计数器，这意味着下一个数据帧会重用Nonce
1。
我们现在展示如何攻击OpenBSD，OS
X和macOS。这些设备只接受加密的重传Message3。就像攻击Android设备一样，我们在无线网卡和CPU间进行一个条件竞争。然而，我们现在的目标是四次握手重载密钥的过程。就像2.3解说的，所有的信息在重载密钥的时候都会经过数据保密协议的加密。
图6
图6描述了这种攻击的细节。注意同样的AP并没有被展示在图里，因为从上文我们很清楚AP的反应会是怎么样。一样的，攻击者使用一个基于频段的中间人（MitM）身份。她让受害者和她自己进行一个初始的四次握手，并且在握手成功之后，初始化执行PTK的重载。及时她只能看到加密的数据帧，但是四次握手的信息能通过它们独特的长度和地址来探查。在这时候，攻击就像在Android那里一样，在攻击的第二阶段，攻击者没有立刻转发第一个Message
3，而是等待AP重传Message 3，然后将这两个Message
3按顺序一起发送给受害者。网卡会使用当前的PTK来解密这两个信息，然后将它们转发到CPU的接收序列。在第三阶段，CPU会执行第一个Message
3，让网卡装载新的PTK。在第四阶段，CPU会从接收序列取出第二个Message 3。当PTK被装载的时候，OpenBSD，OS
X和macOS（在这里被称为CPU）会要求这个这个信息是加密的。然而，它们不会检查这个信息是使用哪个PTK密钥来加密的。因此，即使这个信息是通过旧的PTK来加密的，但是CPU依然会执行它。现在Message
4就会通过新的PTK和Nonce
1来加密并发送。在这之后，CPU会让网卡重载PTK，并且重置Nonce和重传计数器。最终，受害者发送的下一个数据帧就会使用新的PTK和Nonce
1来加密。我们确认这个攻击能在OpenBSD 6.1，OS X10.9.5和macOS Sierra 10.12里实现。
OpenBSD仅在无线网卡卸载加密的时候受影响。比如，iwn驱动和相关的设备支持硬件加密，因此他们就会收到攻击的影响。然而，rum驱动在四次握手中使用的是软件加密，那么就不会被影响。
这种攻击技术需要我们等待会话密钥被重载的那一刻。一些AP会在每个小时都重载一次会话密钥。在实践中，Client也会通过发送一个设置了Request和Pairwise位的EAPOL包给AP来请求重载会话密钥。很巧的是，Broadcom的路由器并不会验证这些数据帧的真伪（MIC），这就意味着攻击者可以强制Broadcom的AP开始重载密钥的握手。讲这些结合到一起，我们可以让重载密钥发生，这就意味着攻击者可以实施重载密钥攻击了。
**3.5 攻击PeerKey握手**
PeerKey握手和四次握手相关，被使用在当两个Client需要一个安全的方式来直接通信的时候。这由两个阶段组成。第一个阶段一个STSL和SMK的握手会被执行。它会在两个Client中协商密钥。而第二个阶段，一个新的会话密钥会通过主密钥产生，并且通过STK握手来传输。虽然这个协议没有被广泛的支持，但是它很好的展示了我们的密钥重载攻击良好适应性。
不出所料，SMK握手并不会被我们的攻击所影响。在这之后，主密钥的协商握手并没有被数据保密协议所保护，这就意味着它们没有Nonce和重传计数器来重置。然而，STK握手是基于四次握手的，它装载了用于数据保密协议的密钥。因此，他可以像四次握手那样被攻击。这种攻击在wpa_supplicant上通过了测试。为了实现这个测试，我们修改了一个wpa_supplicant实例，让它发送第二个（重传）Message
3。这个证实了未修改的wpa_supplicant会在STK握手中接收到重传Message
3时重载STK密钥。然而，我们没有发现其他支持PeerKey的设备。因此，我们针对PeerKey握手的攻击的影响范围很小。
**0x04 攻破组密握手**
在这一节，我们会在组密钥握手中，实现我们的重载密钥攻击。我们展示所有的Wi-Fi设备都会被这攻击所影响，让攻击者可以重放广播和组播的数据帧。
表2
**4.1 组密钥握手的细节**
网络会定期更新组密钥来保证只有近期认证的Client拥有这个密钥。在多数防御情况下，组密钥会在Client离开网络的时候进行更新。新的组密钥会通过组密钥握手进行分发，而这个握手过程已经被正式地证明是安全的。就像图2中展示的那样，握手过程由AP发送信息1给所有的Client开始。AP也会在没有收到回复的时候重传这个信息1。注意一下，EAPOL的重传计数器在这些重传信息中总是增加1。在我们的攻击中，我们的目标是收集一个重传的组信息1，阻止它到达Client，然后在一段时间后再转发给Client。这会让Client装载组密钥并重置重传计数器。
我们攻击的第一个条件是Client会在装载一个已经用过的组密钥的时候重置重传计数器。因为Client同样使用MLME-SETKEYS请求安装组密钥，这种情况就会发生。我们确定在实际中所有的Wi-Fi设备都会在装载一个用过的组密钥的时候重置重传计数器（表1列7）。因此，所有的Wi-Fi设备都会被我们随后的攻击所影响。
第二个攻击条件是我们必须能够收集一个仍然能被Client所接受的组信息1，然后这个信息中包含了已经被AP使用过的组密钥。如何去得到这个信息取决于AP何时开始使用新的组密钥。特别的事，AP将会在发送第一个组信息1之后立即使用新的组密钥，或者会延迟装载知道所有的Client都回复了组信息2表明收到了组信息1。表2第3列总结了一些AP的行为。注意根据标准，新的组密钥需要在收到所有Client的组信息2之后才能被装载。例如GTK会被延迟装载。当一个AP会立即装载新的组密钥的时候，我们的密钥重载攻击就很简单了。然而，如果AP延迟装载组密钥，我们的攻击就会更复杂。我们将会在4.2和4.3节中更详细地讨论这两种情况。
就像2.3节中所说，AP会广播和组播通过组密钥加密的数据帧。因为我们的密钥重载攻击目标是Client，这就意味着我们不能在加密的时候强制Client重用Nonce。然而，Client会在重载组密钥之后重置重传计数器，我们就可以重放这些数据帧给Client。
大多数AP每小时都会更新一次组密钥。一些网络会在每次有设备离开网络的时候更新组密钥。而且，Client可以通过发送一个设置了Request和Group位的EAPOL包来触发组密钥的握手。同样，Broadcom路由器并不会验证这些信息是否正确，这就意味着攻击者可以伪造它们来触发组密钥的更新。将这些结合起来，我们就可以假设大多数网络会进行组密钥的更新，然后我们就可以实行接下来所说的攻击。
**4.2 攻击快速装载密钥的AP**
****
图7
图7展示了当一个AP会在发送完给所有的Client的组信息1之后立即装载组密钥的情况下，我们的密钥重载攻击将会如何实现。注意组密钥的握手信息是通过当前PTK进行数据保密协议来加密的。作为组信息1的回复，Client会安装新的PTK然后返回组信息2。攻击者可以阻止AP接收这个组信息2，然后AP就会在攻击的第二阶段重传一个新的组信息1。我们现在等待一个广播数据帧的发送，然后将其转发给受害者。在这之后，我们转发阶段二中的重传组信息1。这样就会导致受害者会重载GTK，从而会重置相关的重传计数器。这就允许我们来重放广播的数据帧（阶段5）。Client会接收这个数据帧，因为它的重传计数器被重置了。
我们必须在一个广播数据帧之后再发送重传组信息1。这是因为组信息1包括了当前使用的组密钥的值以及重传计数器。因此，如果在广播帧之后发送，它就会包含一个更新过的重传计数器，那么我们就不能使受害者的重传计数器重置。
我们确定这种针对快速装载组密钥的AP在实践中是有效的。基于我们的实验，所有的Wi-Fi设备在连接这类AP之后，都会受到影响。
**4.3 攻击延迟装载密钥的AP**
通过组密钥握手来攻击延迟装载密钥的AP是比较复杂的。注意上一个攻击方式会因为图7中的第三阶段里那个广播数据包是由旧的组密钥加密而失败。因为在这种情况下，AP没有接收到从所有Client返回的组信息2，就不会装载新的组密钥，也就不能使旧的组密钥的重传计数器重置。
图8
图8展示了一个能够解决这个问题的方法。这种攻击的前两个阶段和上一个攻击类似。就是AP产生新的组密钥，然后将其传输给受害者，然后攻击者阻止AP接收Client发送的组信息2。这会导致AP重传组信息1，并且EAPOL的重传计数器为r
+ 1。在攻击的阶段三，我们转发旧的组信息2（重置计数器值为r）给AP。有趣的是，AP应该接受这个信息，及时它没有使用最新的重置计数器的值（r + 1）：
在接收组信息2的时候，AP需要验证重传计数器的值为曾经在组密钥握手过程中使用过的值。
这个标准不需要重传计数器的值和AP最新的值相匹配，而是需要和在组密钥握手过程用过的值中的一个相匹配即可，也就是任意的组信息1使用的重传计数器的值。在实践中我们发现，一些实现确实接受了这个旧的还未收到回复的重传计数器的值（表2列2）。因此，这个AP就会装载新的组密钥。在这种情况下，攻击就会想之前那个一样进行。直到第一个广播数据包被传输，我们就可以在攻击阶段5里进行重载组密钥的操作，然后在第6阶段中重放广播数据帧。
同样的，我们必须在一个广播数据帧之后再发送重传组信息1。不然我们的组信息1会包含一个更新过的重传计数器。
我们在一些延迟装载GTK的AP上进行了攻击测试，然后他们接受了先前在和Client发包时的还未收到回复的重传计数器（表2列2）。我们已经知道所有的Wi-Fi客户端会在重载GTK的时候重置重传计数器，因此他们都会被这种攻击所影响。最后，一个OpenBSD的AP并不会被影响，因为它是延迟装载GTK的，并且只接受最新的重传计数器而不是旧的。
**0x05 针对802.11RFT握手的攻击**
在这一节中，我们将介绍Fast BSS Transition（FT）握手并证明它的实现也受我们密钥重载攻击的影响。
**5.1 Fast BSS Transition（FT）握手**
802.11r修正案增加了Fast Basic
ServiceSet（BSS）Transition（FT）握手到802.11[5]。目的是减少客户端从一个AP到另一个相同网络的漫游时间。（例如相同的基本服务集）此外还需要一个握手，包括新的802.1x和四次握手（请看图2）。然而，因为FT握手依赖于网络之前连接中派生的主密钥，所以并不需要一个新的802.1x握手。此外它将四次握手的阶段嵌在了认证和重组框架里。
一个标准的FT握手如图9的阶段1所示。
图9 针对Fast BSS Transiton（FT）的密钥重载攻击， **注意它并不需要中间人，仅仅是能窃听和重放帧**
图中可以观察到FT
握手不像四次握手，它由请求者初始化。前面两个消息是认证请求（AuthReq）和认证响应（AuthResp）。它们的功能相当于四次握手的Message
1和2，产生随机数来作为nonces（新的会话密钥）。在这之后，客户端发送一个重新连接请求（ReassoReq），AP回复一个重新连接响应（ReassoResp）。它们和四次握手的Message