“Using the Deploy plugin”, we saw how to use the Copy Artifacts and Deploy plugins to deploy a WAR
file built by a previous build job to an application server. What we need to do now is to let the user
specify the version to be deployed, rather than just deploying the latest build.
We can do this using the Parameterized Trigger plugin (see Section 10.2, “Parameterized Build Jobs”).
First, we add a parameter to the build job, using the special “Build selector for Copy Artifact” parameter
type (see Figure 12.4, “Adding a “Build selector for Copy Artifact” parameter”).
Figure 12.4. Adding a “Build selector for Copy Artifact” parameter
This adds a new parameter to your build job (see Figure 12.5, “Configuring a build selector parameter”).
Here you need to enter a name and a short description. The name you provide will be used as an
environment variable passed to the subsequent build steps.
Figure 12.5. Configuring a build selector parameter
The build selector parameter type lets you pick a previous build in a number of ways, including the latest
successful build, the upstream build that triggered this build job, or a specific build. All of these options
will be available to the user when he or she triggers a build. The Default Selector lets you specify which
of these options will be proposed by default.
333
When the user selects a particular build job, the build number will also be stored in
the environment variables for use in the build steps. The environment variable is called
COPYARTIFACT_BUILD_NUMBER_MY_BUILD_JOB, where MY_BUILD_JOB is the name of the original
build job (in upper case and with characters other than A–Z converted to underscores). For
example, if we copy an artifact from build number 4 of the gameoflife-default project, the
COPYARTIFACT_BUILD_NUMBER_GAMEOFLIFE_DEFAULT environment variable would be set to 4.
The second part of the configuration is to tell Jenkins what to fetch, and from which build job. In the
Build section of our project configuration, we add a “Copy artifacts from another project” step. Here
you specify the project where the artifact was built and archived (gameoflife-default in our example).
You also need to make Jenkins use the build specified in the parameter we defined earlier. You do this
by choosing “Specified by a build parameter” in the “Which build” option, and providing the variable
name we specified earlier in the build selector name field (see Figure 12.6, “Specify where to find the
artifacts to be deployed”). Then, just configure the artifacts to copy as we did in the previous example.
Figure 12.6. Specify where to find the artifacts to be deployed
Finally, we deploy the copied artifact using the Deploy plugin, as illustrated in Figure 12.3, “Deploying
to Tomcat using the Deploy Plugin”.
So let’s see how this build works in practice. When we kick off a build manually, Jenkins will propose a
list of options letting you select the build to redeploy (see Figure 12.7, “Choosing the build to redeploy”).
Figure 12.7. Choosing the build to redeploy
334
Most of these options are fairly self-explanatory.
The “latest successful build” is the most recent build excluding any failing builds. So this option will
typically just redeploy the latest version again. If you use this option, you will probably want to select
the “Stable builds only” checkbox, which will exclude any unstable builds as well.
If you have opted to discard old builds, you will be able to flag certain build jobs to be kept forever (see
Section 5.3.1, “General Options”). In this case, you can choose to deploy the “Latest saved build”.
A sensible option for an automated build job at the end of a build pipeline is “Upstream build that
triggered this job”. This way, you can be sure that you are deploying the artifact that was generated by
(or promoted through) the previous build job, even if other builds have happened since. It is worth noting
that, although this sort of parameterized build job is often used to manual deploy a specific artifact, it
can also be effectively used as part of an automated build process. If it is not triggered manually, it will
simply use whatever value you define in the “default selector” field.
You can also choose the “Specified by permalink” option (see Figure 12.8, “Using the “Specified by
permalink” option”). This lets you choose from a number of shortcut values, such as the last build, the
last stable build, the last successful build, and so on.
Figure 12.8. Using the “Specified by permalink” option
However if you want to redeploy a particular version of your application, a more useful option is
“Specific build” (see Figure 12.9, “Using a specific build”). This option lets you provide a specific build
number to be deployed. This is the most flexible way to redeploy an application—you will just need to
know the number of the build you need to redeploy, but this usually isn’t too hard to find by looking
at the build history of the original build job.
Figure 12.9. Using a specific build
335
This is a convenient way to deploy or to redeploy artifacts from previous Jenkins build jobs. However, in
some cases you may prefer to use an artifact stored in an enterprise repository like Nexus or Artifactory.
We will look at an example of how to do this in the next section.
12.3.1.4. Deploying a version from a Maven repository
Many organizations use an Enterprise repository manager such as Nexus and Artifactory to store and
share binary artifacts such as JAR files. This strategy is commonly used with Maven, but also with
other build tools such as Ant (with Ivy or the Maven Ant Tasks) and Gradle. Using this approach
in a CI environment, both snapshot and release dependencies are built on your Jenkins server, and
then deployed to your repository manager (see Figure 12.10, “Using a Maven Enterprise Repository”).
Whenever a developer commits source code changes to the version control system, Jenkins will pick
up the changes and build new snapshot versions of the corresponding artifacts. Jenkins then deploys
these snapshot artifacts to the local Enterprise Repository Manager, where they can be made available
to other developers on the team or on other teams within the organization. We discussed how to get
Jenkins to automatically deploy Maven artifacts to an enterprise repository in Figure 12.10, “Using a
Maven Enterprise Repository”. A similar approach can also be done using Gradle or Ivy.
Snapshot
Snapshot
deployments
updates
Maven enterprise
repository
CI build
Developers
server
Source
code changes
Automated
updates and builds
SCM server
Figure 12.10. Using a Maven Enterprise Repository
Maven conventions use a well-defined system of version numbers, distinguishing between SNAPSHOT
and RELEASE versions. SNAPSHOT versions are considered to be potentially unstable builds of the
latest code base, whereas RELEASE versions are official releases having undergone a more formal
release process. Typically, SNAPSHOT artifacts are reserved for use within a development team,
whereas RELEASE versions are considered ready for further testing.
336
A similar approach can be used for deployable artifacts such as WAR or EAR files—they are built
and tested on the CI server, then automatically deployed to the Enterprise Repository, often as part of
a build pipeline involving automated tests and quality checks (see Section 10.7, “Build Pipelines and
Promotions”). SNAPSHOT versions are typically deployed to a test server for automated and/or manual
testing, in order to decide whether a version is ready to be officially released.
The exact strategy used to decide when a release version is to be created, and how it is deployed, varies
greatly from one organization. For example, some teams prefer a formal release at the end of each
iteration or sprint, with a well-defined version number and corresponding set of release notes that is
distributed to QA teams for further testing. When a particular version gets the go-ahead from QA, it
can then be deployed into production. Others, using a more lean approach, prefer to cut a new release
whenever a new feature or bug fix is ready to be deployed. If a team is particularly confident in their
automated tests and code quality checks, it may even be possible to automate this process completely,
generating and releasing a new version either periodically (say every night) or whenever new changes
are committed.
There are many ways to implement this sort of strategy. In the rest of this section, we will see how
to do it using a conventional multimodule Maven project. Our sample project is a web application
called gameoflife, consisting of three modules: gameoflife-core, gameoflife-services and
gameoflife-web. The gameoflife-web module produces a WAR file that includes JAR files from
the other two modules. It is this WAR file that we want to deploy:
tuatara:gameoflife johnsmart$ ls -l
total 32
drwxr-xr-x 16 johnsmart staff 544 16 May 09:58 gameoflife-core
drwxr-xr-x 8 johnsmart staff 272 4 May 18:12 gameoflife-deploy
drwxr-xr-x 8 johnsmart staff 272 16 May 09:58 gameoflife-services
drwxr-xr-x 15 johnsmart staff 510 16 May 09:58 gameoflife-web
-rw-r--r--@ 1 johnsmart staff 12182 4 May 18:07 pom.xml
Earlier on in this chapter we saw how to use the Deploy plugin to deploy a WAR file generated by the
current build job to an application server. What we want to do now is to deploy an arbitrary version of
the WAR file to an application server.
In Section 10.7.1, “Managing Maven Releases with the M2Release Plugin”, we discussed how to
configure Jenkins to invoke the Maven Release Plugin to generate a formal release version of an
application. The first step of the deployment process starts here, so we will assume that this has been
configured and that a few releases have already been deployed to our Enterprise Repository Manager.
The next step involves creating a dedicated project to manage the deployment process. This project will
be a standard Maven project.
The first thing you need to do is to set up a dedicated deployment project. In its simplest form, this
project will simply fetch the requested version of your WAR file from your enterprise repository to
be deployed by Jenkins. In the following pom.xml file, we use the maven-war-plugin to fetch a
specified version of the gameoflife-web WAR file from our enterprise repository. The version we
want is specified in the target.version property:
337
4.0.0
com.wakaleo.gameoflife
gameoflife-deploy-with-jenkins
0.0.1-SNAPSHOT
war
com.wakaleo.gameoflife
gameoflife-web
ward
${target.version}
maven-war-plugin
gameoflife
com.wakaleo.gameoflife
gameoflife-web
RELEASE
Next, we configure a Jenkins build job to invoke this pom.xml file using a property value provided by
the user (see Figure 12.11, “Deploying an artifact from a Maven repository”). Note that we have set
the default value to RELEASE so that, by default, the most recent release version will be deployed.
Otherwise, the user can provide the version number of the version to be deployed or redeployed.
338
Figure 12.11. Deploying an artifact from a Maven repository
The rest of this build job simply checks out the deployment project and invokes the mvn package goal,
and then deploys the WAR file using the Deploy plugin (see Figure 12.12, “Preparing the WAR to be
deployed”). The target.version property will be automatically passed into the build job and used
to deploy the correct version.
Figure 12.12. Preparing the WAR to be deployed
Similar techniques can be used for other project types. If you are deploying to an application server that
is not supported by the Deploy plugin, you also have the option of writing a custom script in whatever
language is most convenient, and getting Jenkins to pass the requested version number as a parameter
as described above.
12.3.2. Deploying Scripting-based Applications Like Ruby and PHP
Deploying projects using scripting languages such as PHP and Ruby is generally simpler than deploying
Java applications, though the issues related to database updates are similar. Indeed, very often these
deployments essentially involve copying files onto a remote server. To obtain the files in the first place,
you have the choice of either copying them from another build job’s workspace using the Copy Artifacts
option, or checking the source code out directly from the source code repository, if necessary using a
339
specific revision or tag as described for Subversion in Section 10.2.4, “Building from a Subversion Tag”
and for Git in Section 10.2.5, “Building from a Git Tag”. Then, once you have the source code in your
Jenkins workspace, you simply need to deploy it onto the target server.
A useful tool for this sort of deployment is the Publish Over series of plugins for Jenkins (Publish Over
FTP, Publish Over SSH, and Publish Over CIFS). These plugins provide a consistent and flexible way
to deploy your application artifacts to other servers over a number of protocols, including CIFS (for
Windows shared drives), FTP, and SSH/SFTP.
The configuration for each of these plugins is similar. Once you have installed the plugins, you need
to set up the host configurations, which are managed centrally in the main configuration screen. You
can create as many host configurations as you like—they will appear in a drop-down list in the job
configuration page.
Configuration of the hosts is fairly self-explanatory (see Figure 12.13, “Configuring a remote host”).
The name is the name that will appear in the drop-down list in the build job configurations. You can
configure authentication using a username and password for FTP, or either an SSH key or a username
and password for SSH. You also need to provide an existing directory on the remote server that will act
at the root directory for this configuration. In the Advanced options, you can also configure the SSH
port and timeout options.
Figure 12.13. Configuring a remote host
340
Once you have configured your hosts, you can set up your build jobs to deploy artifacts to these hosts.
You can do this either as a build step (see Figure 12.14, “Deploying files to a remote host in the build
section”) or as a post-build action (see Figure 12.15, “Deploying files to a remote host in the post-build
actions”). In both cases, the options are similar.
Figure 12.14. Deploying files to a remote host in the build section
First of all, you select the target host from the list of hosts you configured in the previous section. Next,
you configure the files you want to transfer. You do this by defining one or more “Transfer sets.” A
Transfer set is a set of files (defined by an Ant fileset expression) that you deploy to a specified directory
on the remote server. You can also provide a prefix to be removed—this lets you strip off unnecessary
directories that you do not want to appear on the server (such as the target/site directory path in
the example). You can add as many transfer sets as you need to get the files you want onto the remote
server. The plugin also provides options to execute commands on the remote server once the transfer is
complete (“Exec command”) or to exclude certain files or flatten the directories.
341
Figure 12.15. Deploying files to a remote host in the post-build actions
12.4. Conclusion
Automated Deployment, and in its most advanced form, Continuous Deployment or Continuous
Delivery, can be considered the culminating point of a modern Continuous Integration infrastructure.
In this chapter we have reviewed several Automated Deployment techniques, mostly centered around
Java-based deployments. However, the general principles discussed here apply for any technology.
Indeed, the actual deployment process in many other technologies, in particular scripting languages such
as Ruby and PHP, are considerably simpler than when using Java, and essentially involve copying files
onto the production server. Ruby also benefits from tools such as Heroku and Capistrano to facilitate
the task.
There are several important aspects you need to consider when setting up an Automated Deployment.
First of all, Automated Deployment is the end-point of your CI architecture: you need to define a build
pipeline to take your build from the initial compilation and unit tests, though more comprehensive
functional and automated acceptance tests and code quality checks, culminating in deployment to one
or more platforms. The degree of confidence you can have in your build pipeline depends largely on the
degree of confidence you have in your tests. Or, in other terms, the less reliable and comprehensive your
tests, the earlier in the build process you will have to fall back to manual testing and human intervention.
342
Finally, if at all possible, it is important to build your deployable artifact once and once only, and then
reuse it in subsequent steps for functional tests and deployment to different platforms.
343
Chapter 13. Maintaining Jenkins
13.1. Introduction
In this chapter, we will be discussing a few tips and tricks that you might find useful when maintaining
a large Jenkins instance. We will look at things like how to limit, and keep tabs on, disk usage, how to
give Jenkins enough memory and how to archive build jobs or migrate them from one server to another.
Some of these topics are discussed elsewhere in the book, but here we will be looking at things from
the point of view of the system administrator.
13.2. Monitoring Disk Space
Build History takes disk space. In addition, Jenkins analyzes the build records when it loads a project
configuration, so a build job with a thousand archived builds is going to take a lot longer to load than
one with only fifty. If you have a large Jenkins server with tens or hundreds of build jobs, multiply
this accordingly.
Probably the simplest way to keep a cap on disk usage is to limit the number of builds a project maintains