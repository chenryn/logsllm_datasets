#
)*
#
>
#
正则选项：不区分大小写、宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
这个正则式会把id属性的值和包围它的引号-一起捕获到第1个向后引用中。这样就可
以允许你在正则式之外的代码中或者替代字符串中使用这个值。如果不需要重复使用
该值，那么你可以使用一个非捕获分组，或者把整个的s*=s*（[^"]*"[^]*）序列替
换为b>。这个正则式的剩余部分会接下来匹配id属性的值。
包含id属性的标签
要查找一个特定的标签类型，你需要把它的名称添加到正则式的开始，并且再对上
面的正则式做一些较小的修改。在下面的例子中，我们在起始的。（\s）（空白）记号确保不会匹配到名称中以“div”3个学母开头的标签。我
们知道在标签名称之后会有一个空格字符，因为要查找的标签中至少会包含一个属
性（id)。另外，（+?\sid>序列被替换成了
*?\bid\s
"']
#标签和属性名称等
|"["] *"
#
..以及引号引起来的属性值
丨*[']*
#
) *?
#
\bid
#
要查找的目标属性名称，整字匹配
\s*=\s*
#属性名称-值之间的分隔符
（”["]*"
1*1
#把属性值捕获到第1个向后引用中
(？：[^>"]
#任意剩余的字符
1"["]*"
#
..以及被引起来的属性值
1*[~']*
#
) *
事
#
正则选项：不区分大小写、宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
包含id属性且其值为“my-id”的标签
与前面题为“包含id属性的标签（更可靠的版本)”中的正则式相比，这次我们去掉了
在id属性值两边的捕获分组，这是因为已经在之前就知道了它的值。具体来说，子模
式：
(pu,IPu)S\=S\pS\+(•[]，1•[v]1[
#
(？：[^>"]
#标签和属性名称等
1”["] *"
..以及引起来的属性值
1'[]*
#
+(
#
\sid
#
要查找的目标属性名称，整字匹配
\s*=\s*
#属性名称-值之间的分隔符
（？："my-id"
#目标属性值
|'my-id′)
.用单引号或双引号引起来
(？：[^>"]
任意剩余的字符
#
..以及引起来的属性值
标记语言和数据交换
433
www.TopSage.com
---
## Page 450
） *
#
>
#
正则选项：不区分大小写、宽松排列
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
再回来看一下其中的子模式（这样会牺牲-一些效率)。它使用了一个捕获分组和一个向后引
用来确保属性值是以箱同类型的引号开始和结策的。
在其class属性值中包含“my-class”的标签
如果说上一个正则表达式还可以接受，那么下面这一个就已经明显超出了单个正
则表达式的能力极限。把这个过程划分为多个正则式会更容易一些，因此我们会
把这个查找分成3个部分。第-一个正则式会匹配标签，下一个会在其中查找class
属性（并把它的值保存到一个向后引用中），最后一个正则式会在它的值中查找
my-class。
查找标签的正则表达式：
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
提示
实例8.1中专门讲解了如何匹配XML风格的标签。它讲解了上面这个正
：则式的工作原理，并且给出了包含不同程度复杂性和准确性的多个可选
解决方案。
接下来，可以使用在实例3.13中的代码，用下面的正则表达式在上面的每个匹配中查
找class属性：
（.（￥[]），1（[])：）S\=S\sseTS\+（[.]，1▪[]1["]"[^"]*"[^]*)+？>匹配，它会一步
匹配到引起来的值，而不会匹配到另外一个属性值之内的“class”单词。在该模式
的右边，只要我们到达了class属性的值的结尾，匹配就会马上结束。在此之后的所
有内容都和我们的查找无关，因此也就完全没有必要一路匹配到你正在查找的标签
的结尾。
在正则式开始处的脱字符会把它定位到目标字符串的开始。这并不会改变匹配到的内
容，但是一旦使用了它，那么如果正则引擎无法在字符串开始找到匹配，它就不会继
续在随后的每个字符位置进行尝试（这种匹配尝试注定是要失败的）。
434第8童
www.TopSage.com
---
## Page 451
最后，如果前面两个正则式都匹配成功，那么你还需要使用下面的模式来在第二个正
则式匹配到的第1个或第2个向后引用中进行查找：
(? : ^ I \s) my=Class (?:\s I S)
正则选项：无
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
因为类之间是由空格分隔开的，所以my-class的两边必须是空格或者什么都没有。如
果不是因为在类名称中可以包含连字符，你甚至可以使用单词边界记号来替代这里的
两个非捕获分组。然而，连字符会创建单词边界，因此\bmy-class\b>会在not-my-class
中产生匹配。
讨论
本实例中的“解决方案”小节已经讲解了这些正则表达式的详细工作原理，因此我们
在这里就不再重复了。要记住的是正则表达式通常并不是标记查找问题的理想解决方
案，特别是用来解决这个实例中讲解的复杂情况的时候。在使用这些正则表达式之前，
读者需要考虑是否采用其他的解决方案可能会更好，例如XPath、SAZX分析器或者
DOM。在这里我们之所以讲解这些正则式，是因为人们有时候也会试着采用这种形式，
但是这并不意味着我们没有提醒你。我们希望这至少会有助于展示与标记查找有关的
一些问题，并且会帮助读者避免使用甚至更为幼稚的解决方案。
参见
实例8.7从概念上正好和本实例相反，它会查找不包含某个特定属性的标签。
8.7向不包含cellspacing属性的
标签中添加该属性
问题描述
你想要查找-个(X)HTML文件，并且向其中没有包含cellspacing属性的所有表格中都
添加cellspacing="0"。
本实例会作为向XML风格的标签中添加不存在的属性的一个示例。你可以把它替换为
想要的任意标签和属性名称。
解决方案
正则式1：简单的解决方案
你可以使用否定型顺序环视来匹配不包含cellspacing单词的标签，如下
所示：
标记语言和数据交换
435
www.TopSage.com
---
## Page 452
]*?\scellspacing\b)([^>]*)>
正则选项：不区分大小写，
正则流派：.NET、Java、JavaScript、PCRE、Perl、Python、Ruby
下面是同一个正则式的宽松排列版本：
]
匹配除了“>”之外的任意字符..
*?
0次或多次，匹配尽量少次（懒情量词）
\s cellspacing\b
整字匹配"cellspacing"
把下面正则式捕获到第1个向后引用中
[^>]
匹配除了“>”之外的任意字符..·
#
0次或多次，匹配尽量多次（贪心量词）
）
#
>
#匹配一个字面的“>”作为标签的结束
正则选项：不区分大小写
正则流派：.NET、Java、PCRE、Perl、Python、Ruby
正则式2：更可靠的解决方案
下面的正则表达式会把前面最简单解决方案中的否定型字符类{>]的两个实例
都替换为"]"[^"]*"[^]*)。这会从两个方面来提高这个正则表达式的可靠
性。首先，它添加了对引号引起来的，其中包含字面的“>”字符的属性值的支持。
其次，它确保了我们不会排除掉只是在一个属性值中包含了单词“cellspacing”的
标签。
下面是包含了我们所说的这些改动之后的正则式：
(q\buedss\（].1*]1
"]
匹配除了>、”或之外的任意字符
["["] *"
：
或者，一个双引号引起来的值
！*[*]*+