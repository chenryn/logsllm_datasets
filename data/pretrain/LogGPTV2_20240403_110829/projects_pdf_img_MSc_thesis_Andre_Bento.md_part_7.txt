FR-2 The system must be able to retrieve service dependency High
graphs from distributed tracing tools.
FR-3 The system must be able to store service dependency graphs High
in a graph database.
FR-4 Thesystemmustbeabletostoretime-seriesmetricsextracted High
from tracing data in a time-series database.
FR-5 The system must be able to extract the number of calls per Medium
service (total, incoming and outgoing) from tracing data.
FR-6 The system must be able to extract the response time per Medium
service from tracing data.
FR-7 The system must be able to generate request work-flow paths Medium
from tracing data.
FR-8 The system must be able to calculate request ratio of success Medium
and error, for specific services, from tracing data.
FR-9 Thesystemmustbeabletocalculatethedegree(total, inand Medium
out) of services from service dependency graphs.
FR-10 The system must be able to retrieve the difference between Medium
two service dependency graphs.
FR-11 The system must be able to produce a report about spans Low
structure using a defined OpenTracing structural schema.
FR-12 The system must be able to calculate the time coverage of Low
traces in a given time-frame.
FR-13 The system must be able to identify regions of outliers pre- Low
sented in multiple time-series.
Functional requirements defined in Table 4.1 were written based on defined research
questions presented in Section 3.2. These functional requirements can be grouped in three
groups due to their priority levels. The first four (FR-1 to FR-4) are presented with high
level of priority, because they represent the base functionality needed to implement the
remainingrequirements. Thenexteightfunctionalrequirements(FR-5toFR-11),aretime
based metric extraction from tracing. The remaining three (FR-12 to FR-14) are related
with trace testing and anomaly detection based in time-series thus the low priority.
The relationship between these functional requirements and questions presented in
previous chapter, Section 3.2, as well has the verification that these requirements are
fulfilled by the solution, is covered in next chapter, Sections 5.2 and 5.3.
34
Proposed Solution
Next Section 4.2 - Quality Attributes covers the proposed approach non-functional
requirements.
4.2 Quality Attributes
Another important consideration, when designing a software system, is to specify all
the quality attributes (also called non-functional requirements). These type of require-
ments are usually Architecturally Significant Requirements and are the ones that require
more from software architect’s attention, as they reflect directly all architecture decisions.
To specify them, a representation called utility tree is often used. In this tree, the Qual-
ity Attribute (QA) are placed by an order of priority considering their impact for the
architecture and for the business. The priority codification for the QA is:
• H. High
• M. Medium
• L. Low
To describe them properly, six important aspects must be included in QA definition:
stimulus source, stimulus, environment, artefact, response and measure of the response.
Figure 4.2 contains all raised QA for this proposed solution exposed in an utility tree
structure, sorted alphabetically by their general QA name, and after by the architectural
impact pair (Architecture and Business).
QA1: The system, when running, must
be able to retrieve information for
analysis from an external tracing and/or
monitoring tool. (H, M)
Utility Tree Interoperability
QA2: The system, when running, must
be able to work without affecting the
normal work of the external systems.
(L, H)
Figure 4.2: QA utility tree.
Figure 4.2 shows us that only two Interoperability QA were defined. An explanation
for both is provided bellow:
QA1 (Interoperability): Since the proposed solution must ingest tracing data. This infor-
mation is usually found in distributed tracing tools already used by operators. To
gatherthisinformation,accesstoanexternaldistributedtracingtoolisanimportant
feature.As this is considered the starting point to obtain our data, we considered a
Medium level for the architecture and a Low for the business.
QA2 (Interoperability): Since the proposed solution will be accessing an external dis-
tributed tracing system or outputs generated by it, all interactions with these sys-
tems must not cause conflicts. This is very important in the business perspective,
35
Chapter 4
because if our solution is not co-habitable with already used systems, it may be
completely rejected. For the architectural perspective it does not represent a big
impact, and therefore a Low level was assigned.
4.3 Technical Restrictions
In this Section, technical restrictions considered in proposed solution are presented.
In software engineering, after specifying functional and non-functional requirements
for a solution, comes the specification of business restrictions, however, in this project
none were raised due to the fact that this work is focused on exploration and research.
To define the technical restrictions, we used an id and its corresponding description.
Table 4.2 presents the technical restrictions considered for the proposed solution.
Table 4.2: Technical restrictions specification.
ID Description
TR-1 Use OpenTSDB as a Time-Series database.
Table 4.2 shows that we have raised only one technical restriction. This technical
restriction was considered because Professor Jorge Cardoso, acting as a client for this
solution demanded it. OpenTSDB is the database that they are currently using in their
projects at Huawei Research Center. This restriction will ease their work to introduce
changes if needed.
4.4 Architecture
In this Section, the architecture is presented based on all previous topics with resource
to the defined Simon Brown’s C4 Model [59]. This approach of defining an architecture
usesfourdiagrams: 1 - Context Diagram, 2 - Container Diagram, 3 - Component Diagram
and 4 - Code Diagram. To define the architecture for our solution, only the first three
representations were considered. Every representation will be exposed with a explana-
tion of the decisions taken to draw each diagram. After presenting the representations
and the corresponding explanations, we will cycle thought all architectural drivers: QA,
business and technical restrictions, in order to explain where they are reflected and the
considerations taken to produce this architecture.
4.4.1 Context Diagram
In this Subsection the context diagram is presented. This diagram allows us to see
“the big picture” of the overall system as it represents the system as a “big box” and the
corresponding interactions with users and external software systems. Figure 4.3 presents
the context diagram for this solution.
36
Proposed Solution
Context Diagram
Metrics Visualizer
User
[Browser]
[Person] Views metrics from
Allows the user to view
DevOps/SysAdmin
metrics in a more
and Operators.
human readable way.
Uses
Provides metrics to
Graphy (OTP) Target System
[Software System] Analyses data from [Software System]
Extracts and analyses System that holds
metrics from tracing. tracing to be analysed.
Subtitle:
Software External Software
Person
System System
Figure 4.3: Context diagram.
From Figure 4.3, we can see that our solution, named Graphy OpenTracing processor
(OTP), receives interactions from users, as it need someone to start the whole process.
This piece of software analyses data from an external target system that holds the tracing
information and consequently, provides extracted metrics to an external metrics visualizer
component. Users can view extracted metrics from this last component. Also, reports are
produced and stored within our solution, when it performs tracing analysis.
4.4.2 Container Diagram
The container diagram is presented in this Subsection. This type of diagram allows us
to “zoom-in” in the context diagram, and get a new overview of our solution. Therefore,
in this diagram we are able to see a high-level shape of the software architecture and
how responsibilities are distributed across containers. Figure 4.4 presents the container
diagram for our proposed solution.
37
Chapter 4
Container Diagram
User Metrics Visualizer
[Browser]
[Person]
Views metrics from
Allows the user to view
DevOps/SysAdmin metrics in a more human
and Operators. readable way.
Uses
Graphy (OTP)
Access Console
[Container: Console] Provides metrics to
[HTTP/TCP]
Allows user to control system
functionalities.
Perform requests
Graphy API
Target System
[Container: Core App] Analyse data from
[Software System]
[JSONL/HTTPS]
Allows system to receive
System that holds tracing
instructions, and perform
to be analysed.
analysis of tracing data.
Reads from or writes to Reads from or writes to
[ArangoDB Connector] [OpenTSDB Connector - HTTP/TCP]
Database
Database
[Container: Time-Series
[Container: Graph
Database]
Database]
Store time metrics extracted
Store graphs extracted from
from span trees and graphs.
span trees presented in tracing.
Subtitle:
Person Container Database External Software System
Container
Text
Figure 4.4: Container diagram.
38
Proposed Solution
Figure 4.4 contains the main containers involved in our solution. The first one, from
top to bottom, is the Access Console and this container was considered as it is needed for
the user to be able interact with the Graphy Application Programming Interface (API).
This last one controls the entire OpenTracing system, uses a communication protocol to
retrieve tracing information from external target system, and two databases to store the
information resulted from processing tracing data – a Graph Database (GDB) and a Time
Series Database (TSDB). The second database provides metrics to be visualized in an
external metrics visualizer system.
4.4.3 Component Diagram
This Subsection contains the last diagram, the component diagram. This type of
diagram gives a more deeper vision about the system, and therefore, it reveals the main
components. Figure 4.5 presents the component diagram for this solution.
Figure 4.5 provides us with a lower level visualization of Graphy API container com-
posed by eight components. At its core we have Graphy Controller, a component with
the responsibility of receiving requests from the user through Access Console and control
OpenTracing Processor, Tracing Collector and Data Analyser components. The first one
has the objective of mapping tracing data, span trees and service dependency graphs in-
stantiation into memory. The second one collects tracing, the information that feeds this
entire application, from local files or from external systems, e.g., Zipkin. The last one,
Data Analyser, identifies outliers presented in time-series metrics extracted from tracing,
allowingoursolutiontodetectanomalousservicespresentedindistributedsystems. Graph
Processor is the component for graphs handling, thus it has the capability of performing
operations over graphs, e.g., subtract one graph from another, extract node degrees and
count connections between nodes. The remaining components, Graphs Repository and
Metrics Repository, are used to map graphs and time-series metrics, respectively, into and
from their corresponding databases.
Tocheckthearchitectureproduced,wewillnowcyclebetweenbothQAandcheckwere
they are reflected in the architecture presented for this solution, explaining the trade-off
involved and what were our considerations about each one.
QA1 and QA2 are satisfied by the fact that the system is able to collect data from
an external system. Using a communication protocol where data is exchanged thought
Hypertext Transfer Protocol (HTTP) and exposed API, allows to externally request little
chucks of data from target systems without interfering with their normal function.
Finally, for the only technical restriction raised, we can see that it is satisfied by the
usage of OpenTSDB as the main TSDB for our solution.
This solution does not have many architectural drivers: quality attributes, business
constraints and technical restrictions, due to being a prototype. The main objective is to
produce a solution capable of explore tracing data allowing us to conduct a research about
what we can do with tracing, therefore it does not have many architectural constraints.
Nevertheless, with the presentation of these four sections, we conclude that our solution
satisfies all the architectural drivers, and therefore, we may claim that the proposed ar-
chitecture fits our needs as a solution.
Next Chapter, 5 - Implementation Process, covers the implementation of the solution
presented in the current chapter. All implemented algorithms and technical decisions are
discussed and explained in detail.
39
Chapter 4
Component Diagram
Access Console
[Container: Console]
Allows the user to control the
system functionalities.
Graphy API Perform requests
Graphy Controller
Uses [Component: Python] Uses
Core system controller.
Tracing Processor Tracing Collector
Target System
[Component: Streaming API] [Component: Python]