title:The Unexpected Dangers of Dynamic JavaScript
author:Sebastian Lekies and
Ben Stock and
Martin Wentzel and
Martin Johns
The Unexpected Dangers of Dynamic JavaScript
Sebastian Lekies, Ruhr-University Bochum; Ben Stock, Friedrich-Alexander-Universität 
Erlangen-Nürnberg; Martin Wentzel and Martin Johns, SAP SE
https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/lekies
This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-939133-11-3Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXThe Unexpected Dangers of Dynamic JavaScript
Sebastian Lekies
Ruhr-University Bochum
PI:EMAIL
Ben Stock
FAU Erlangen-Nuremberg
PI:EMAIL
Martin Johns
SAP SE
PI:EMAIL
Martin Wentzel
SAP SE
PI:EMAIL
Abstract
Modern Web sites frequently generate JavaScript on-the-
ﬂy via server-side scripting, incorporating personalized
user data in the process. In general, cross-domain access
to such sensitive resources is prevented by the Same-
Origin Policy. The inclusion of remote scripts via the
HTML script tag, however, is exempt from this policy.
This exemption allows an adversary to import and exe-
cute dynamically generated scripts while a user visits an
attacker-controlled Web site. By observing the execution
behavior and the side effects the inclusion of the dynamic
script causes, the attacker is able to leak private user data
leading to severe consequences ranging from privacy vi-
olations up to full compromise of user accounts.
Although this issues has been known for several years
under the term Cross-Site Script Inclusion, it has not
been analyzed in-depth on the Web. Therefore, to sys-
tematically investigate the issue, we conduct a study on
its prevalence in a set of 150 top-ranked domains. We
observe that a third of the surveyed sites utilize dynamic
JavaScript. After evaluating the effectiveness of the de-
ployed countermeasures, we show that more than 80%
of the sites are susceptible to attacks via remote script
inclusion. Given the results of our study, we provide a
secure and functionally equivalent alternative to the use
of dynamic scripts.
1
Introduction
Since its beginning in the early nineties, the Web evolved
from a mechanism to publish and link static documents
into a sophisticated platform for distributed Web applica-
tions. This rapid transformation was driven by two tech-
nical cornerstones:
1. Server-side generation of code: For one, on the
server side, static HTML content was quickly replaced
by scripting to dynamically compose the Web server’s
HTTP responses and the contained HTML/JavaScript on
the ﬂy.
In turn, this enabled the transformation of the
Web’s initial document-centric nature into the versatile
platform that we know today.
2. Browser-driven Web front-ends: Furthermore, the
Web browser has proven to be a highly capable container
for server-provided user interfaces and application logic.
Thanks to the ﬂexible nature of the underlying HTML
model and the power of client-side scripting via Java-
Script, the server can push arbitrary user interfaces to the
browser that rival their counterparts of desktop applica-
tion. In addition, and unlike monolithic desktop appli-
cations, however, browser-based UIs enable easy incor-
poration of content from multiple parties using HTML’s
inherent hypertext capabilities.
Based on this foundation, the recent years have shown
an ongoing shift from Web applications that host the ma-
jority of their application logic on the server side towards
rich client-side applications, which use JavaScript to re-
alize a signiﬁcant portion of their functionality within the
user’s browser.
With the increase of the functionality implemented on
the client side, the necessity for the JavaScript code to
gain access to additional user data rises natrually. In this
paper, we explore a speciﬁc technique that is frequently
used to pull such data from the server to the client-side:
Dynamic JavaScript generation.
Similar to HTML, which is often generated dynam-
ically, JavaScript may also be composed on the ﬂy
through server-side code.
In this composition process,
user-speciﬁc data is often included in the resulting script
code, e.g., within the value of a variable. After deliv-
ering the script to the browser, this data is immediately
available to the client-side logic for further processing
and presentation. This practice is potentially dangerous
as the inclusion of script ﬁles is exempt from the Same-
Origin Policy [23]. Therefore, an attacker-controlled
Web page is able to import such a dynamically gener-
ated script and observe the side effects of the execu-
tion, since all included scripts share the global object
USENIX Association  
24th USENIX Security Symposium  723
of the embedding web document. Thus, if the script
contains user-speciﬁc data, this data might be accessi-
ble to other attacker-controlled JavaScript. Although this
attack, dubbed Cross-Site Script Inclusion (XSSI), has
been mentioned within the literature [31], the prevalence
of ﬂaws which allow for this attack vector has not been
studied on real-world Web sites.
In this paper we therefore present the ﬁrst, systematic
analysis of this vulnerability class and provide empirical
evidence on its severeness. First, we outline the general
attack patterns and vectors that can be used to conduct
such an attack. Furthermore, we present the results of an
empirical study on several high-proﬁle domains, show-
ing how these domains incorporate dynamic scripts into
their applications. Thereby, we ﬁnd evidence that many
of these scripts are not or only inadequately protected
against XSSI attacks. We demonstrate the sever conse-
quences of these data leaks by reporting on real-world
exploitation scenarios ranging from de-anonymization,
to targeted phishing attacks up to complete compromise
of a victim’s account.
To summarize, we make the following contributions:
• We elaborate on different ways an attacker is capa-
ble of leaking sensitive data via dynamically gener-
ated scripts, enabled by the object scoping and dy-
namic nature of JavaScript.
• We report on the results of an empirical study
on several high-ranked domains to investigate the
prevalence of dynamic scripts.
• Using the data collected during our empirical study,
we show that many dynamic scripts are not properly
protected against XSSI attacks. To demonstrate the
severity of the outlined vulnerabilities, we present
different exploitation scenarios ranging from de-
anonymization to complete hijacking of a victim’s
account.
• Based on the observed purposes of the dynamic
scripts encountered in our study, we discuss secure
ways of utilizing such data without the use of dy-
namically generated scripts.
2 Technical Background
In this section, we cover the technical background rele-
vant for this work.
2.1 The Same-Origin Policy
The Same-Origin Policy (SOP) is the principal security
policy in Web browsers. The SOP strongly separates mu-
tually distrusting Web content within the Web browser
through origin-based compartmentalization [23]. More
precisely, the SOP allows a given JavaScript access only
to resources that have the same origin. The origin is de-
ﬁned as the triple consisting of scheme, host, and port
of the involved resources. Thus, for instance, a script
executed under the origin of attacker.org is not able
to access a user’s personal information rendered under
webmail.com.
While JavaScript execution is subject to the SOP, the
same does not hold true for cross-domain inclusion of
Web content using HTML tags. Following the initial hy-
pertext vision of the WWW HTML-tags, such as image,
may reference resources from foreign origins and include
them into the current Web document.
Using this mechanism, the HTML script tag can
point to external script resources, using the tag’s src at-
tribute. When the browser encounters such a tag, it issues
a request to the foreign domain to retrieve the referenced
script. Important to note in this instance is the fact that
the request also carries authentication credentials in the
form of cookies which the browser might have stored for
the remote host. When the response arrives, the script
code inherits the origin of the including document and is
executed in the context of the hosting page. This mecha-
nism is used widely in the Web, for instance to consume
third party JavaScript services, such as trafﬁc analysis or
advertisement reselling [24].
JavaScript Language Features
2.2
In the following, we cover the most important JavaScript
concepts necessary for the rest of the paper.
The remainder of the paper is structured as follows: In
Section 2, we explain the technical foundations needed
for rest of the paper. Section 3 then covers the general at-
tack patterns and techniques to exploit cross-domain data
leakage vulnerabilities. In Section 4, we report on the re-
sults of our empirical study and analyze the underlying
purposes of dynamic scripts. Furthermore, in Section 5,
we provide a scheme that is functionally equivalent, but
is not prone to the attacks described in this paper. Sec-
tion 6 covers related work, Section 7 gives an outlook
and Section 8 concludes the paper.
Scoping
In JavaScript, a scope is “a lexical environ-
ment in which a function object is executed” [6]. From a
developer’s point of view, a scope is the region in which
an identiﬁer is deﬁned. While C++ or Java make use
of block scoping, JavaScript utilizes so-called function
scoping. This means that the JavaScript engine creates
a new scope for each new function it encounters. As a
consequence, an identiﬁer that is locally deﬁned in such
a function is associated with the corresponding scope.
Only code that is deﬁned within the same function is thus
able to access such a variable residing in the local scope,
724  24th USENIX Security Symposium 
USENIX Association
whereas global variables are associated with the global
scope.
Listing 1 shows an example for local and global vari-
ables. A local variable in JavaScript can be created by
utilizing the var keyword. All variables deﬁned out-
side of a function are associated with the global scope,
whereas code within a function can deﬁne variables in
the global scope by either omitting the var keyword or
explicitly assigning to window.varname.
3 Cross-Domain Data Leakages
In this section, we show how an adversary can utilize
an external JavaScript ﬁle, which is dynamically gener-
ated at runtime, to leak security sensitive data. After ﬁrst
covering the different types of these dynamic scripts, we
elaborate on the attacker model and then demonstrate dif-
ferent attack vectors that can be leveraged to leak sensi-
tive data from such a script.
Listing 1 Example for global and local variables
// A global variable
var globalVariable1 = 5;
function globalFunction(){
// A local variable
var localVariable = 2;
// Another global variable
globalVariable2 = 3;
// Yet another global variable
window.globalVariable3 = 4;
}
The Prototype Chain As opposed to classical pro-
gramming languages such as C++ or Java, JavaScript is a
prototype-based language. This means that JavaScript’s
inheritance is not based on classes but directly on other
objects, whereas “each object has a link to another ob-
ject called its prototype” [21]. On creation of an object,
it either automatically inherits from Object.prototype
or if a prototype object is explicitly provided, the proto-
type property will point to this object. On access to an
object’s property, the JavaScript runtime checks whether
the current object contains a so-called own property with
the corresponding name.
If no such property exists, the object’s prototype is
queried for the same property and if lookup fails again,
the process is recursively repeated for the object’s pro-
totypes. Hence, objects in JavaScript form a so-called
prototype chain. Listing 2 gives a commented example
for this behavior.
Listing 2 The prototype chain
var object1 = {a: 1};
// object1 ---> Object.prototype ---> null
var object2 = Object.create(object1);
// object2 ---> object1
//
console.log(object2.a); // 1 (inherited)
---> Object.prototype ---> null
3.1 Dynamic Scripts
As discussed in Section 2.1, Web pages can utilize
script-tags to import further JavaScript resources. For
the remainder of this paper, we deﬁne the term dynamic
script to describe such a JavaScript resource in case it
is generated by the Web server on the ﬂy via server-side
code.
As opposed to static scripts, the contents of dynamic
scripts may vary depending on factors such as input pa-
rameters or session state. In the context of this paper, the
latter type is of special interest: If a dynamic JavaScript
is generated within a user’s authenticated Web session,
the contents of this script may contain privacy or secu-
rity sensitive data that is bound to the user’s session data.
Thus, an execution of the script can potentially lead to
side effects which leak information about this data.
3.2 Attack Method
HTML script tags are not subject to the Same-Origin
Policy (see Section 2.1). Hence, script resources can be
embedded into cross-domain Web pages. Although such
cross-domain Web pages cannot access the source code
of the script directly, this inclusion process causes the
browser to load and execute the script code in the context
of the cross-domain Web page, allowing the importing
page to observe the script’s behavior. If a dynamic script
exposes side effects dependent on sensitive data in the
script code, the execution of such a script may leak the
secret data.
Figure 1 depicts an example attack. A user is au-
thenticated to his mail provider at webmail.com, thus
his browser automatically attaches the corresponding
session cookies to all requests targeting webmail.com,
which utilizes session-state dependent dynamic scripts.
Thus, whenever a user is logged in,
the script at
webmail.com/script.js creates a global variable
containing the current user’s email address.
In the
same browser, the user now navigates to an attacker-
controlled Web site at attacker.org. The attacker in-
cludes the dynamic script in his own Web page and sub-
sequently, the browser requests the script with attached
authentication cookies. Although the script originates
USENIX Association  
24th USENIX Security Symposium  725
h"p://a"acker.org	
Browser	
h"p://a"acker.org	
h"p://webmail.com	
JavaScript	
Figure 1: Attacker Model
from webmail.com, it is now executed in the context
of attacker.org, creating the global variable with the
user’s email in the corresponding context. The global
variable is now accessible to any other script executed
by attacker.org. Hence, the attacker can simply ac-
cess the value of this global variable, effectively leaking
the user’s email address.
3.3 Attack Vectors
As previously explained, an attacker is able to leak sen-
sitive user data by including a script from a different do-
main and observing the results of the execution. In this
section we outline different situations in which sensitive
data is accessible to an attacker after the included script
has been executed.
3.3.1 Global Variables
As noted in the previous section, global variables created
by a dynamic script can be accessed by any other script
executed on the same Web document. Hence, whenever
sensitive user data is assigned to such a global variable
inside a script, an attacker can gain access to the corre-
sponding data. In order to do so, he simply includes the
script and waits for the global variable to be created. As
soon as the value assignment has occurred, the attacker’s
code can read the sensitive data and leak it back to his
backend.
3.3.2 Redeﬁnition of Global APIs
Due to JavaScript’s dynamic nature, (almost) any func-
tion can be overwritten by an attacker, including a num-
ber of globally available APIs. If a dynamic script passes
a security-sensitive value to such a function, the attacker
may overwrite it beforehand and hence retrieve the se-
cret value. Listing 3 demonstrates how an attacker can,