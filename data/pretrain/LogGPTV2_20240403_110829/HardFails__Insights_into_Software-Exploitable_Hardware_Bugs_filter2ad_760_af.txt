### References

1. 10.1007/978-3-319-76953-0_2.
2. F. Nielson, H. R. Nielson, and C. Hankin. *Principles of Program Analysis*. Springer, 1999.
3. NIST. HP: Remote update feature in HP LaserJet printers does not require a password. https://nvd.nist.gov/vuln/detail/CVE-2004-2439, 2004.
4. NIST. Microsoft: Hypervisor in Xbox 360 kernel allows attackers with physical access to force execution of the hypervisor syscall with a certain register set, bypassing intended code protection. https://nvd.nist.gov/vuln/detail/CVE-2007-1221, 2007.
5. NIST. Apple: Multiple heap-based buffer overflows in the AudioCodecs library in the iPhone allow remote attackers to execute arbitrary code or cause a denial of service via a crafted AAC/MP3 file. https://nvd.nist.gov/vuln/detail/CVE-2009-2206, 2009.
6. NIST. Broadcom Wi-Fi chips denial of service. https://nvd.nist.gov/vuln/detail/CVE-2012-2619, 2012.
7. R. Kastner, W. Hu, and A. Althoff. *Quantifying Hardware Security Using Joint Information Flow Analysis*. IEEE Design, Automation & Test in Europe, pages 1523–1528, 2016.
8. NIST. Vulnerabilities in Dell BIOS allow local users to bypass intended BIOS signing requirements and install arbitrary BIOS images. https://nvd.nist.gov/vuln/detail/CVE-2013-3582, 2013.
9. H. Khattri, N. K. V. Mangipudi, and S. Mandujano. *Hsdl: A security development lifecycle for hardware technologies*. IEEE International Symposium on Hardware-Oriented Security and Trust, pages 116–121, 2012.
10. Y. Kim, R. Daly, J. Kim, C. Fallin, J. H. Lee, D. Lee, C. Wilkerson, K. Lai, and O. Mutlu. *Flipping bits in memory without accessing them: An experimental study of DRAM disturbance errors*. ACM SIGARCH Computer Architecture News, 42(3):361–372, 2014.
11. P. Kocher, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom. *Spectre Attacks: Exploiting Speculative Execution*. http://arxiv.org/abs/1801.01203, 2018.
12. NIST. Google: Escalation of privilege vulnerability in MediaTek WiFi driver. https://nvd.nist.gov/vuln/detail/CVE-2016-2453, 2016.
13. NIST. Samsung: Page table walks conducted by MMU during virtual to physical address translation leave traces in LLC. https://nvd.nist.gov/vuln/detail/CVE-2017-5927, 2017.
14. NIST. AMD: Backdoors in security co-processor ASIC. https://nvd.nist.gov/vuln/detail/CVE-2018-8935, 2018.
15. NIST. AMD: EPYC server processors have insufficient access control for protected memory regions. https://nvd.nist.gov/vuln/detail/CVE-2018-8934, 2018.
16. NIST. Buffer overflow in bootrom recovery mode of NVIDIA Tegra mobile processors. https://nvd.nist.gov/vuln/detail/CVE-2018-6242, 2018.
17. Y. Yarom, D. Genkin, and N. Heninger. *CacheBleed: A timing attack on OpenSSL constant-time RSA*. Journal of Cryptographic Engineering, 7(2):99–112, 2017. 10.1007/s13389-017-0152-y.
18. J. Oberg. *Secure Development Lifecycle for Hardware Becomes an Imperative*. https://www.eetimes.com/author.asp?section_id=36&doc_id=1332962, 2018.
19. J. Oberg, W. Hu, A. Irturk, M. Tiwari, T. Sherwood, and R. Kastner. *Theoretical Analysis of Gate Level Information Flow Tracking*. IEEE/ACM Design Automation Conference, pages 244–247, 2010.
20. PULP Platform. Ariane. https://github.com/pulp-platform/ariane, 2018.
21. PULP Platform. Pulpino. https://github.com/pulp-platform/pulpino, 2018.
22. PULP Platform. Pulpissimo. https://github.com/pulp-platform/pulpissimo, 2018.
23. Qualcomm. Qualcomm Announces Launch of Bounty Program. https://www.qualcomm.com/news/releases/2016/11/17/qualcomm-announces-launch-bounty-program-offering-15000-usd-discovery, 2018.
24. Samsung. Rewards Program. https://security.samsungmobile.com/rewardsProgram.smsb, 2018.
25. M. Seaborn and T. Dullien. *Exploiting the DRAM rowhammer bug to gain kernel privileges*. Black Hat, 15, 2015.
26. H. Shacham. *The geometry of innocent flesh on the bone: return-into-libc without function calls (on the x86)*. ACM Symposium on Computer and Communication Security, pages 552–561, 2007.
27. OneSpin Solutions. *OneSpin 360*. https://www.onespin.com/fileadmin/user_upload/pdf/datasheet_dv_web.pdf, 2013.
28. P. Subramanyan, R. Sinha, I. Lebedev, S. Devadas, and S. A. Seshia. *A Formal Foundation for Secure Remote Execution of Enclaves*. ACM SIGSAC Conference on Computer and Communications Security, pages 2435–2450, 2017.
29. Sunny L. He, Natalie H. Roe, Evan C. L. Wood, Noel Nachtigal, and Jovana Helms. *Model of the Product Development Lifecycle*. https://prod.sandia.gov/techlib-noauth/access-control.cgi/2015/159022.pdf, 2015.
30. A. Tang, S. Sethumadhavan, and S. Stolfo. *CLKSCREW: Exposing the perils of security-oblivious energy management*. USENIX Security Symposium, pages 1057–1074, 2017.
31. M. Tiwari, H. M. Wassel, B. Mazloom, S. Mysore, F. T. Chong, and T. Sherwood. *Complete Information Flow Tracking from the Gates Up*. ACM International Conference on Architectural Support for Programming Languages and Operating Systems, pages 109–120, 2009.
32. Tortuga Logic. *Verifying Security at the Hardware/Software Boundary*. http://www.tortugalogic.com/unison-whitepaper/, 2017.
33. J. Van Bulck, F. Piessens, and R. Strackx. *Foreshadow: Extracting the keys to the Intel SGX kingdom with transient out-of-order execution*. USENIX Security Symposium, 2018.
34. A. Waterman, Y. Lee, D. A. Patterson, and K. Asanovic. *The RISC-V Instruction Set Manual. Volume 1: User-Level ISA, Version 2.0*. https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf, 2014.
35. D. Zhang, Y. Wang, G. E. Suh, and A. C. Myers. *A Hardware Design Language for Timing-Sensitive Information-Flow Security*. International Conference on Architectural Support for Programming Languages and Operating Systems, pages 503–516, 2015.
36. T. Zhang and R. B. Lee. *New Models of Cache Architectures Characterizing Information Leakage from Cache Side Channels*. ACSAC, pages 96–105, 2014.

### Appendix

#### A. Ariane Core and RTL Hierarchy

**Figure 4**: High-level architecture of the Ariane core [59].

**Figure 5**: Illustration of the RTL module hierarchy of the Ariane core.

#### B. Recent Microarchitectural Attacks

We reviewed recent microarchitectural attacks with respect to existing hardware verification approaches and their limitations. We observe that the underlying vulnerabilities would be difficult to detect due to the properties they exhibit, rendering them as potential HardFails. We do not have access to their proprietary RTL implementation and cannot inspect the underlying vulnerabilities. Thus, we infer from the published technical descriptions and errata of these attacks the nature of the underlying RTL issues. Table 2 classifies the properties of these vulnerabilities that represent challenges for state-of-the-art hardware security verification.

| Attack          | Privilege Level | Memory Corruption | Information Leakage | Cross-Modular HW/FW Interaction | Cache-State Gap | Timing-Flow Gap | HardFail |
|-----------------|-----------------|-------------------|---------------------|---------------------------------|-----------------|-----------------|----------|
| Cachebleed [74] | unprivileged    |                   |                     |                                 |                 |                 |          |
| TLBleed [23]    | unprivileged    |                   |                     |                                 |                 |                 |          |
| BranchScope [20]| unprivileged    |                   |                     |                                 |                 |                 |          |
| Spectre [37]    | unprivileged    |                   |                     |                                 |                 |                 |          |
| Meltdown [43]   | supervisor      |                   |                     |                                 |                 |                 |          |
| MemJam [45]     | supervisor      |                   |                     |                                 |                 |                 |          |
| CLKScrew [69]   | supervisor      |                   |                     |                                 |                 |                 |          |
| Foreshadow [72] | supervisor      |                   |                     |                                 |                 |                 |          |

#### C. Details on the Pulpissimo Bugs

We present more details on some of the RTL bugs used in our investigation.

**Bugs in Crypto Units and Incorrect Usage**: We extended the SoC with a faulty cryptographic unit with a multiplexer to select between AES, SHA1, MD5, and a temperature sensor. The multiplexer was modified to create a race condition if more than one bit in the status register is enabled, causing unreliable behavior in these security-critical modules. Additionally, both SHA-1 and MD5 are outdated and broken cryptographic hash functions. Such bugs are not detectable by formal verification, as they occur due to a specification/design issue rather than an implementation flaw. The cryptographic key is stored and read from unprotected memory, allowing an attacker access to the key. The temperature sensor register value is incorrectly muxed as output instead of the crypto engine output and vice versa, which are illegal information flows that could compromise cryptographic operations.

**Listing 1**: Incorrect use of crypto RTL: The key input for the AES (g_input) is connected to signal b. This signal is then passed through various modules until it connects directly to a tightly coupled memory in the processor.

```verilog
input logic [127:0] b,
...
aes_1cc aes(
    .clk(0),
    .rst(1),
    .g_input(b),
    .e_input(a),
    .o(aes_out)
);
```

**Bugs in Security Modes**: We replaced the standard `PULP_SECURE` parameter in the `riscv_cs_registers` and `riscv_int_controller` modules with another constant parameter to permanently disable the security/privilege checks for these two modules. Another bug we inserted is switching the write and read protections for the AXI bus interface, causing erroneous checks for read and write accesses.

**Bugs in the JTAG Module**: We implemented a JTAG password-checker and injected multiple bugs, including hardcoding the password in the password checking file. The password checker only checks the first 31 bits, reducing the computational complexity of brute-forcing the password. The password checker does not reset the state of the correctness of the password when an incorrect bit is detected, allowing repeated partial checks to eventually unlock the password checker. The index overflows after the user hits bit 31, allowing infinite cycling of bit checks.

#### D. Exploiting Hardware Bugs From Software

We now explain how one of our hardware bugs can be exploited in real-world software. This RTL vulnerability manifests when an error signal is generated on the memory bus while the underlying logic is still handling an outstanding transaction. The next signal to be handled will be considered operational by the module unconditionally, allowing erroneous memory accesses to slip through hardware checks at runtime. Armed with this knowledge, an adversary can force memory access errors to evade the checks.

**Figure 6**: Our attack exploits a bug in the implementation of the memory bus of the PULPissimo SoC: by spamming the bus with invalid transactions, an adversary can make malicious write requests be set to operational.

1. The attacker generates a user program (Task A) that registers a dummy signal handler for the segmentation fault (SIGSEGV) access violation. Task A then executes a loop with a faulting memory access to an invalid memory address (e.g., `LW x5, 0x0`). This generates an error in the memory subsystem of the processor and issues an invalid memory access interrupt (i.e., 0x0000008C) to the processor.
2. The processor raises this interrupt to the running software (in this case, the OS), using the pre-configured interrupt handler routines in software. The interrupt handler in the OS will then forward this as a signal to the faulting task, which keeps looping and continuously generating invalid accesses.
3. Meanwhile, the attacker launches a separate Task B, which will then issue a single memory access to a privileged memory location (e.g., `LW x6, 0xf77c3000`).
4. In this situation, multiple outstanding memory transactions will be generated on the memory bus, all of which but one will be flagged as faulty by the address decoder. An invalid memory access will always precede the single access of Task B.
5. Due to the bug in the memory bus address decoder, the malicious memory access will become operational instead of triggering an error.
6. The attacker can issue read and write instructions to arbitrary privileged (and unprivileged) memory by forcing the malicious illegal access to be preceded by a faulty access. Using this technique, the attacker can eventually leverage this read-write primitive to escalate privileges by writing the process control block (PCB) for his task to elevate the corresponding process to root. This bug leaves the attacker with access to a root process, gaining control over the entire platform and potentially compromising all the processes running on the system.

**Figure 7**: Userspace, Kernel, Task B, Task A, NULL, Core, Core, Memory Interconnect, DRAM, PCB, MMOS Kernel.

28th USENIX Security Symposium  
USENIX Association