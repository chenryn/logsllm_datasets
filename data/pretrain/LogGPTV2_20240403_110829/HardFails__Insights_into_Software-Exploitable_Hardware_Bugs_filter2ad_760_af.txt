10.1007/978-3-319-76953-0_2.
[46] F. Nielson, H. R. Nielson, and C. Hankin. Principles of program
analysis. Springer, 1999.
[47] NIST. HP: Remote update feature in HP LaserJet printers does not re-
quire password. https://nvd.nist.gov/vuln/detail/CVE-2004-
2439, 2004.
[48] NIST. Microsoft: Hypervisor in Xbox 360 kernel allows attackers
with physical access to force execution of the hypervisor syscall with a
certain register set, which bypasses intended code protection. https:
//nvd.nist.gov/vuln/detail/CVE-2007-1221, 2007.
[49] NIST. Apple: Multiple heap-based buffer overﬂows in the AudioCodecs
library in the iPhone allows remote attackers to execute arbitrary code
or cause DoS via a crafted AAC/MP3 ﬁle. https://nvd.nist.gov/
vuln/detail/CVE-2009-2206, 2009.
[50] NIST. Broadcom Wi-Fi chips denial of service. https://nvd.nist.
gov/vuln/detail/CVE-2012-2619, 2012.
[34] R. Kastner, W. Hu, and A. Althoff. Quantifying Hardware Security
Using Joint Information Flow Analysis. IEEE Design, Automation &
Test in Europe, pages 1523–1528, 2016.
[51] NIST. Vulnerabilities in Dell BIOS allows local users to bypass in-
tended BIOS signing requirements and install arbitrary BIOS images.
https://nvd.nist.gov/vuln/detail/CVE-2013-3582, 2013.
[35] H. Khattri, N. K. V. Mangipudi, and S. Mandujano. Hsdl: A security
development lifecycle for hardware technologies. IEEE International
Symposium on Hardware-Oriented Security and Trust, pages 116–121,
2012.
[36] Y. Kim, R. Daly, J. Kim, C. Fallin, J. H. Lee, D. Lee, C. Wilkerson,
K. Lai, and O. Mutlu. Flipping bits in memory without accessing them:
An experimental study of DRAM disturbance errors. ACM SIGARCH
Computer Architecture News, 42(3):361–372, 2014.
[37] P. Kocher, D. Genkin, D. Gruss, W. Haas, M. Hamburg, M. Lipp,
S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom. Spectre At-
tacks: Exploiting Speculative Execution. http://arxiv.org/abs/
1801.01203, 2018.
[52] NIST. Google: Escalation of Privilege Vulnerability in MediaTek
https://nvd.nist.gov/vuln/detail/CVE-2016-
WiFi driver.
2453, 2016.
[53] NIST. Samsung: Page table walks conducted by MMU during Virtual
to Physical address translation leaves in trace in LLC. https://nvd.
nist.gov/vuln/detail/CVE-2017-5927, 2017.
[54] NIST. AMD: Backdoors in security co-processor ASIC. https://
nvd.nist.gov/vuln/detail/CVE-2018-8935, 2018.
[55] NIST. AMD: EPYC server processors have insufﬁcient access con-
trol for protected memory regions. https://nvd.nist.gov/vuln/
detail/CVE-2018-8934, 2018.
USENIX Association
28th USENIX Security Symposium    227
[56] NIST. Buffer overﬂow in bootrom recovery mode of nvidia tegra mo-
bile processors. https://nvd.nist.gov/vuln/detail/CVE-2018-
6242, 2018.
[74] Y. Yarom, D. Genkin, and N. Heninger. CacheBleed: a timing attack on
OpenSSL constant-time RSA. Journal of Cryptographic Engineering,
7(2):99–112, 2017. 10.1007/s13389-017-0152-y.
[57] J. Oberg. Secure Development Lifecycle for Hardware Becomes an Im-
perative. https://www.eetimes.com/author.asp?section_id=
36&doc_id=1332962, 2018.
[58] J. Oberg, W. Hu, A. Irturk, M. Tiwari, T. Sherwood, and R. Kastner. The-
oretical Analysis of Gate Level Information Flow Tracking. IEEE/ACM
Design Automation Conference, pages 244–247, 2010.
[59] PULP Platform. Ariane. https://github.com/pulp-platform/
ariane, 2018.
[60] PULP Platform. Pulpino. https://github.com/pulp-platform/
pulpino, 2018.
[61] PULP Platform.
Pulpissimo.
platform/pulpissimo, 2018.
https://github.com/pulp-
[62] Qualcomm. Qualcomm Announces Launch of Bounty Program.
https://www.qualcomm.com/news/releases/2016/11/17/
qualcomm-announces-launch-bounty-program-offering-
15000-usd-discovery, 2018.
[63] Samsung. Rewards Program. https://security.samsungmobile.
com/rewardsProgram.smsb, 2018.
[64] M. Seaborn and T. Dullien. Exploiting the DRAM rowhammer bug to
gain kernel privileges. Black Hat, 15, 2015.
[65] H. Shacham. The geometry of innocent ﬂesh on the bone: return-into-
libc without function calls (on the x86). ACM Symposium on Computer
and Communication Security, pages 552–561, 2007.
[66] O. Solutions.
OneSpin 360.
https://www.onespin.com/
fileadmin/user_upload/pdf/datasheet_dv_web.pdf, 2013.
[67] P. Subramanyan, R. Sinha, I. Lebedev, S. Devadas, and S. A. Seshia. A
Formal Foundation for Secure Remote Execution of Enclaves. ACM
SIGSAC Conference on Computer and Communications Security, pages
2435–2450, 2017.
[68] Sunny .L He and Natalie H. Roe and Evan C. L. Wood and Noel
Nachtigal and Jovana Helms. Model of the Product Development
Lifecycle. https://prod.sandia.gov/techlib-noauth/access-
control.cgi/2015/159022.pdf, 2015.
[69] A. Tang, S. Sethumadhavan, and S. Stolfo. CLKSCREW: exposing
the perils of security-oblivious energy managemen. USENIX Security
Symposium, pages 1057–1074, 2017.
[70] M. Tiwari, H. M. Wassel, B. Mazloom, S. Mysore, F. T. Chong, and
T. Sherwood. Complete Information Flow Tracking from the Gates Up.
ACM International Conference on Architectural Support for Program-
ming Languages and Operating Systems, pages 109–120, 2009.
[71] Tortuga Logic. Verifying Security at the Hardware/Software Boundary.
http://www.tortugalogic.com/unison-whitepaper/, 2017.
[72] J. Van Bulck, F. Piessens, and R. Strackx. Foreshadow: Extracting the
Keys to the Intel SGX Kingdom with Transient Out-of-Order Execution.
USENIX Security Symposium, 2018.
[73] A. Waterman, Y. Lee, D. A. Patterson, and K. Asanovic.
The
RISC-V Instruction Set Manual. Volume 1: User-Level ISA, Version
2.0. https://content.riscv.org/wp-content/uploads/2017/
05/riscv-spec-v2.2.pdf, 2014.
[75] D. Zhang, Y. Wang, G. E. Suh, and A. C. Myers. A Hardware De-
sign Language for Timing-Sensitive Information-Flow Security. In-
ternational Conference on Architectural Support for Programming
Languages and Operating Systems, pages 503–516, 2015.
[76] T. Zhang and R. B. Lee. New Models of Cache Architectures Char-
acterizing Information Leakage from Cache Side Channels. ACSAC,
pages 96–105, 2014.
Appendix
A Ariane Core and RTL Hierarchy
Figure 4 shows the high-level microarchitecture of the Ariane
core to visualize its complexity. This RISC-V core is far
less complex than an x86 or ARM processor and their more
sophisticated microarchitectural and optimization features.
Figure 5 illustrates the hierarchy of the RTL components of
the Ariane core. This focuses only on the core and excludes all
uncore components, such as the AXI interconnect, peripherals,
the debug module, boot ROM, and RAM.
B Recent Microarchitectural Attacks
We reviewed recent microarchitectural attacks with respect
to existing hardware veriﬁcation approaches and their limita-
tions. We observe that the underlying vulnerabilities would
be difﬁcult to detect due to the properties that they exhibit,
rendering them as potential HardFails. We do not have access
to their proprietary RTL implementation and cannot inspect
the underlying vulnerabilities. Thus, we only infer from the
published technical descriptions and errata of these attacks
the nature of the underlying RTL issues. We classify in Ta-
ble 2 the properties of these vulnerabilities that represent
challenges for state-of-the-art hardware security veriﬁcation.
C Details on the Pulpissimo Bugs
We present next more detail on some of the RTL bugs used in
our investigation.
Bugs in crypto units and incorrect usage: We extended
the SoC with a faulty cryptographic unit with a multiplexer
to select between AES, SHA1, MD5, and a temperature sen-
sor. The multiplexer was modiﬁed such that a race condition
occurs if more than one bit in the status register is enabled,
causing unreliable behavior in these security critical modules.
Furthermore, both SHA-1 and MD5 are outdated and bro-
ken cryptographic hash functions. Such bugs are not de-
tectable by formal veriﬁcation, since they occur due to a
speciﬁcation/design issue and not an implementation ﬂaw,
therefore they are out of the scope of automated approaches
and formal veriﬁcation methods. The cryptographic key is
228    28th USENIX Security Symposium
USENIX Association
FIGURE 4: High-level architecture of the Ariane core [59].
FIGURE 5: Illustration of the RTL module hierarchy of the Ariane core.
Attack
Privilege Level
Memory
Corruption
Information
Leakage
Cross-
modular
HW/FW-
Interaction
Cache-State
Gap
Timing-Flow
Gap
HardFail
Cachebleed [74]
TLBleed [23]
BranchScope [20]
Spectre [37]
Meltdown [43]
MemJam [45]
CLKScrew [69]
Foreshadow [72]
unprivileged
unprivileged
unprivileged
unprivileged
unprivileged
supervisor
supervisor
supervisor
























































TABLE 2: Classiﬁcation of the underlying vulnerabilities of recent microarchitectural attacks by their HardFail properties.
USENIX Association
28th USENIX Security Symposium    229
Ariane RISC-V Core RTL Module Hierarchyarianefrontendid_stageissue_stageex_stagecommit_stagecsr_regfileperf_counterscontrollerstd_cache_subsystemalubranch_unitlsucsr_buffernbdcachemmuload_unitstore_unitlsu_arbiterlsu_bypassptwdtlbitlbscoreboardre_nameissue_read_operandsariane_regfileicachelfsrdata_sramtag_sramrasbtbbhtfetch_fifoinstr_scanAcronym Legendrasreturn address stackbtbbranch trace bufferbhtbranch history tabledltbdata translation lookaside bufferiltbinstruction translation lookaside buffermmumemory management unitnbdcachenon-blocking data cachelsuload/store unitcsrconfiguration status registerid_stageinstruction decode stagestored and read from unprotected memory, allowing an at-
tacker access to the key. The temperature sensor register value
is incorrectly muxed as output instead of the crypto engine
output and vice versa, which are illegal information ﬂows that
could compromise the cryptographic operations.
LISTING 1: Incorrect use of crypto RTL: The key input for
the AES (g_input) is connected to signal b. This signal is then
passed through various modules until it connects directly to a
tightly coupled memory in the processor.
input logic [127:0] b,
...
aes_1cc aes(
.clk(0),
.rst(1),
.g_input(b),
.e_input(a),
.o(aes_out)
);
Bugs in security modes: We replaced the standard
PULP_SECURE parameter in the riscv_cs_registers and
riscv_int_controller modules with another constant param-
eter to permanently disable the security/privilege checks for
these two modules. Another bug we inserted is switching the
write and read protections for the AXI bus interface, causing
erroneous checks for read and write accesses.
Bugs in the JTAG module: We implemented a JTAG
password-checker and injected multiple bugs in it, includ-
ing the password being hardcoded in the password checking
ﬁle. The password checker also only checks the ﬁrst 31 bits,
which reduces the computational complexity of brute-forcing
the password. The password checker does not reset the state
of the correctness of the password when an incorrect bit is
detected, allowing for repeated partial checks of passwords
to end up unlocking the password checker. This is also facil-
itated by the fact that the index overﬂows after the user hits
bit 31, allowing for an inﬁnite cycling of bit checks.
D Exploiting Hardware Bugs From Software
We now explain how one of our hardware bugs can be ex-
ploited in real-world by software. This RTL vulnerability
manifests in the following way. When an error signal is gen-
erated on the memory bus while the underlining logic is still
handling an outstanding transaction, the next signal to be han-
dled will instead be considered operational by the module
unconditionally. This lets erroneous memory accesses slip
through hardware checks at runtime. Armed with the knowl-
edge about this vulnerability, an adversary can force memory
access errors to evade the checks. As shown in Figure 6, the
memory bus decoder unit (unit of the memory interconnect)
is assumed to have the bug. This causes errors to be ignored
FIGURE 6: Our attack exploits a bug in the implementation
of the memory bus of the PULPissimo SoC: by 1 spamming
the bus with invalid transactions an adversary can make 4
malicious write requests be set to operational.
under certain conditions (see bug number #7 in Table 1). In
the ﬁrst step 1 , the attacker generates a user program (Task
A) that registers a dummy signal handler for the segmenta-
tion fault (SIGSEGV) access violation. Task A then executes a
loop with 2 a faulting memory access to an invalid memory
address (e.g., LW x5, 0x0). This will generate an error in
the memory subsystem of the processor and issue an invalid
memory access interrupt (i.e., 0x0000008C) to the processor.
The processor raises this interrupt to the running software (in
this case the OS), using the pre-conﬁgured interrupt handler
routines in software. The interrupt handler in the OS will then
forward this as a signal to the faulting task 3 , which keeps
looping and continuously generating invalid accesses. Mean-
while, the attacker launches a separate Task B, which will
then issue a single memory access 4 to a privileged memory
location (e.g., LW x6, 0xf77c3000). In this situation, multi-
ple outstanding memory transactions will be generated on the
memory bus, all of which but one will be ﬂagged as faulty by
the address decoder. An invalid memory access will always
proceed the single access of Task B. Due to the bug in the
memory bus address decoder, 5 the malicious memory ac-
cess will become operational instead of triggering an error.
Thus, the attacker can issue read and write instructions to
arbitrary privileged (and unprivileged) memory by forcing the
malicious illegal access to be preceded with a faulty access.
Using this technique the attacker can eventually leverage this
read-write primitive, e.g., 6 to escalate privileges by writing
the process control block (PCBB) for his task to elevate the
corresponding process to root. This bug leaves the attacker
with access to a root process, gaining control over the en-
tire platform and potentially compromising all the processes
running on the system.
230    28th USENIX Security Symposium
USENIX Association
UserspaceKernelTask BTask A NULLCoreCoreMemoryInterconnect DRAM12354PCBB...Task B Task AIVTPCBAPCBBMMOS Kernel6