lbm
mcf
sjeng
soplex
1.33
6.48
536.61
88.62
19.04
2.03
154.94
10897.63
41363.07
47177.45
4262.94
4.61
Table 2: Runtime overhead
Figure 11: Increment in program size (bytes)
watermark into a radix graph, whereas our ROP-based wa-
termarking uses 156 or 188 bytes when the gadgets are for-
matted in integer arrays or in structs/classes, respectively.
Again, our ROP-based watermarking has a clear advantage.
4.5 Our method vs. RopSteg
In this subsection, we give a comparison between our
method and RopSteg when applied to hide software water-
mark. As discussed in Section 2, RopSteg is a general tool
for hiding code portions of a program with ROP. It has a dif-
ferent threat model compared to software watermarking and
is susceptible to simple program transformation attacks. In
this subsection, we, instead, focus on two evaluations. First,
the amount of additional instructions inserted that partic-
ipate dynamically in normal runs of the program (without
watermark generation) and in watermark generation. This
is an important security evaluation of software watermark-
ing because instructions dedicated to watermark generation
(those not participated in normal runs of the program at
all) are suspicious and attract program analysis. Second, we
also evaluate the program size increments. Table 3 shows
the average result for the six benchmark programs we have
tested, since the results are very much constant among them
(shown in the previous subsection for our method and dis-
cussed in [17] for RopSteg).
Our ROP-based watermarking is designed based on an
idea that instructions introduced by watermarking should
be amphibious – they should be executed in regular runs of
the program (without watermark generation). Our evalu-
ation (second column of Table 3 conﬁrms that our design
meets this criteria, as 100% of the newly added instructions
participate in normal runs of the programs. Meanwhile, only
61% of the instructions inserted by RopSteg participated in
normal executions of the programs. In addition, the total
size increment caused by RopSteg is larger than our method.
5. DISCUSSION
5.1 ROP defenses
A number of ROP defenses have been proposed to detect
and stop ROP execution [6,7,13,22,24,33]. One can imagine
that if triggered on a system with ROP defense deployed,
the embedded ROP execution in the program transformed
with our ROP-based watermarking would set oﬀ an alarm,
and that speciﬁc execution where watermark extraction took
place might be terminated.
However, watermark extraction is a special scenario that
only happens when certain concerned party tries to either
prove the software’s ownership or to identify the authorized
users. That’s why a special input is used to trigger the wa-
termark execution. In our ROP-based watermarking, nor-
02505007501,0001,2501,5001,7502,0002,2502,5002,7503,000bzip2hmmerlbmmcfsjengsoplexgraph-based watermarkingROP-based watermarkingMethod
Our work
RopSteg
Newly inserted instructions executed
Normal run (without watermark generation) Watermark generation
Program size increase
100%
61.5%
0%
38.5%
512
650
Table 3: Overhead comparison between our method and RopSteg
mal executions of the watermarked program will show no
characteristics of ROP execution at all, and therefore do
not conﬂict with ROP defenses. Although it is true that
extracting watermark hidden with our design presents ROP
behaviors, we believe that given that watermark extraction
is such a special event, it is reasonable to simply run the
watermarked program in a specialized environment or tem-
porarily turn oﬀ the ROP defense.
5.2 Compatibility
Our design is implemented and evaluated under the x86
instruction architecture. Eﬀectiveness and eﬃciency on other
architectures, such as SPARC or ARM, might vary from our
current results. That said, there have been reports of suc-
cessful ROP on various platforms [4, 14, 16], which suggest
that our proposal could work on these platforms, too.
Nevertheless, our design makes use of gadgets from shared
libraries, suggesting that the watermark extraction depends
on the execution environment, e.g. library versions, to cor-
rectly re-build the ROP execution path. One possible solu-
tion is to source for multiple sets of watermarking payload
strings, each corresponding to a distinct version of the se-
lected libraries, so that the watermarked program can detect
the environment on which it is running and point the water-
marking trigger to the corresponding watermarking payload.
We leave this as future work.
5.3 Library Replacement Attack
At this moment, a potential weakness of our ROP-based
watermarking is the so-called library replacement attack, i.e.
the adversary replaces the original dynamic libraries that
would link to the watermarked program, say L, with its cus-
tom library L(cid:48) that may be bundled in the software package.
So long as there are gadgets locate in L, such replacement
could render errors during ROP and therefore compromise
the watermark recovery process. In the extreme case, the
adversary could replace all dynamic libraries just in case it
does not know where the gadgets reside. We plan to improve
our approach on this aspect in the near future. Possible
ways might include exploiting gadgets inside libraries that
cannot be circumvented (this is possible in some operation
system, e.g. any program runs on windows system must load
Kernel32.dll which provides system API), or introducing
tamper-prooﬁng approaches that at runtime check whether
the loaded libraries are compromised.
6. CONCLUSION
We proposed a novel dynamic software watermarking de-
sign that embeds and exhibits watermark through a memory
error exploiting technique named return-oriented program-
ming. Our ROP-based watermarking is able to transform
important watermarking code into ROP gadgets and build
them in the data region. The watermark can be extracted by
activating ROP execution along these gadgets constructed.
Evaluations show that compared to previous works, our de-
sign achieves better stealth because of its ﬁne-grained code
distribution. Analysis and experiments also suggest that
our design not only presents good resilience against attacks
with code obfuscation and re-packing, but also causes no-
tably lower overhead.
We take our ROP-based watermarking as a successful at-
tempt of turning a malicious approach (return-oriented pro-
gramming in this case) into a benign usage. We also believe
that this work opens a rather diﬀerent view for software
watermarking – instead of hiding messages in special execu-
tions, we could make execution itself invisible.
7. ACKNOWLEDGMENTS
This project is partly supported by the National Key Ba-
sic Research Program of China (Grant No. 2013CB834204),
the National Natural Science Foundation of China (Grant
No. 61272423, 61303213), the Natural Science Foundation of
Tianjin (Grant No. 14JCYBJC15300), and the Open Project
Foundation of Information Security Evaluation Center of
Civil Aviation, Civil Aviation University of China (Grant
No. CAAC-ISECCA-201403).
8. REFERENCES
[1] The llvm compiler infrastructure. http://llvm.org/.
[2] Upx: the ultimate packer for executables.
http://upx.sourceforge.net/.
[3] Xenocode. http://www.xenocode.com.
[4] E. Buchanan, H. Roemer, H. Shacham, and S. Savage.
When good instructions go bad: Generalizing
return-oriented programming to risc. In Proceedings of
the 15th ACM conference on Computer and
communications security (CCS), pages 27–38, 2008.
[5] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi,
H. Shacham, and M. Winandy. Return-oriented
programming without returns. In Proceedings of the
17th ACM conference on Computer and
communications security (CCS), pages 559–572, 2010.
[6] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and
L. Xie. Drop: Detecting return-oriented programming
malicious code. In Proceedings of the 5th International
Conference of Information Systems Security (ICISS),
pages 163–177, 2009.
[7] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng.
Ropecker: A generic and practical approach for
defending against rop attacks. In Symposium on
Network and Distributed System Security (NDSS),
2014.
[8] C. Collberg, E. Carter, S. Debray, A. Huntwork,
J. Kececioglu, C. Linn, and M. Stepp. Dynamic
path-based software watermarking. In Proceedings of
the ACM SIGPLAN 2004 conference on Programming
language design and implementation (PLDI), pages
107–118, 2004.
[9] C. Collberg and J. Nagra. Surreptitious Software —
Obfuscation, Watermarking, and Tamperprooﬁng for
Software Protection. Software Security Series.
Addison-Wesley, 2009.
[10] C. Collberg and C. Thomborson. Software
watermarking: models and dynamic embeddings. In
Proceedings of the 26th ACM SIGPLAN-SIGACT
Symposium on Principles of Programming Languages
(POPL), pages 311–324, 1999.
[11] C. Collberg, C. Thomborson, and G. M. Townsend.
Dynamic graph-based software watermarking.
Technical Report TR04-08, Department of Computer
Science, The University of Arizona, 2004.
[12] P. Cousot and R. Cousot. An abstract
interpretation-based framework for software
watermarking. In Proceedings of the 31th ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages (POPL), pages 173–185,
2004.
[22] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and
E. Kirda. G-free: defeating return-oriented
programming through gadget-less binaries. In
Proceedings of the 26th Annual Computer Security
Applications Conference (ACSAC), pages 49–58, 2010.
[23] J. Palsberg, S. Krishnaswamy, M. Kwon, D. Ma,
Q. Shao, and Y. Zhang. Experience with software
watermarking. In Proceedings of the 16th Annual
Conference of Computer Security Applications
(ACSAC), pages 308–316, 2000.
[24] V. Pappas. kbouncer: Eﬃcient and transparent rop
mitigation. Technical report, Columbia University,
2012.
[25] C. Ren, K. Chen, and P. Liu. Droidmarking: Resilient
software watermarking for impeding android
application repackaging. In Proceedings of the 29th
ACM/IEEE international conference on Automated
software engineering (ASE), pages 635–646, 2014.
[26] R. Roemer, E. Buchanan, H. Shacham, and S. Savage.
Return-oriented programming: Systems, languages,
and applications. ACM Transactions on Information
and System Security (TISSEC), 15(1):2, 2012.
[13] L. Davi, A. Sadeghiy, and M. Winandyz. Ropdefender:
[27] H. Shacham. The geometry of innocent ﬂesh on the
A detection tool to defend against return-oriented
programming attacks. In Proceedings of the 6th ACM
Symposium on Information, Computer and
Communications Security (ASIACCS), pages 40–51,
2011.
[14] A. Francillon and C. Castelluccia. Code injection
attacks on harvard-architecture devices. In Proceedings
of the 15th ACM conference on Computer and
communications security (CCS), pages 15–26, 2008.
[15] T. Holz and F. Freiling. Return-oriented rootkits:
Bypassing kernel code integrity protection
mechanisms. In Proceedings of the 19nd USENIX
conference on Security (USENIX Security), pages
383–398, 2009.
[16] T. Kornau. Return oriented programming for the arm
architecture. Master’s thesis, Ruhr-Universit¨at,
Bochum, 2010.
[17] K. Lu, S. Xiong, and D. Gao. Ropsteg: Program
steganography with return oriented programming. In
Proceedings of the 4th ACM Conference on Data and
Application Security and Privacy (CODASPY), pages
265–272, 2014.
[18] G. Myles and C. Collberg. Software watermarking
through register allocation: Implementation, analysis,
and attacks. In Proceedings of the 6th International
Conference of Information Security and Cryptology
(ICISC), pages 274–293, 2003.
[19] G. Myles and C. Collberg. Software watermarking via
opaque predicates: Implementation, analysis, and
attacks. Electronic Commerce Research, 6(2):155–171,
2006.
[20] G. Myles and H. Jin. Self-validating branch-based
software watermarking. In Proceedings of the 7th
International Workshop of Information Hiding (IH),
pages 342–356, 2005.
[21] J. Nagra and C. Thomborson. Threading software
watermarks. In Proceedings of the 6th International
Workshop of Information Hiding (IH), pages 208–223,
2004.
bone: Return-into-libc without function calls (on the
x86). In Proceedings of the 14th ACM conference on
Computer and communications security (CCS), pages
552–561, 2007.
[28] M. Sharif, A. Lanzi, J. Giﬃn, and W. Lee. Impeding
malware analysis using conditional code obfuscation.
In Proceedings of the 16th Annual Network &
Distributed System Security Symposium (NDSS), 2008.
[29] K. Z. Snow, F. Monrose, L. Davi, A. Dmitrienko,
C. Liebchen, and C. Sadeghi. Just-in-time code reuse:
On the eﬀectiveness of ﬁne-grained address space
layout randomization. In Proceedings of the 34rd IEEE
Symposium on Security and Privacy (S&P), pages
574–588, 2013.
[30] D. Song, D. Brumley, H. Yin, J. Caballero, I. Jager,
M. G. Kang, Z. Liang, J. Newsome, P. Poosankam,
and P. Saxena. Bitblaze: A new approach to computer
security via binary analysis. In Proceedings of the 4th
International Conference on Information Systems
Security (ICISS), pages 1–25, 2008.
[31] R. Venkatesan, V. Vazirani, and S.Sinha. A graph
theoretic approach to software watermarking. In
Proceedings of the 4th International Workshop of
Information Hiding (IH), pages 157–168, 2001.
[32] T. Wang, K. Lu, L. Lu, S. Chung, and W. Lee. Jekyll
on ios: When benign apps become evil. In Proceedings
of the 22nd USENIX conference on Security (USENIX
Security), pages 559–572, 2013.
[33] C. Zhang, T. Wei, Z. Chen, L. Duan, S. McCamant,
L. Szekeres, D. Song, and W. Zou. Practical control
ﬂow integrity & randomization for binary executables.
In Proceedings of the 34rd IEEE Symposium on
Security and Privacy (S&P), pages 559–573, 2013.
[34] W. Zhou, X. Zhang, and X. Jiang. Appink:
Watermarking android apps for repackaging
deterrence. In Proceedings of the 8th ACM Symposium
on InformAtion, Computer and Communications
Security (ASIACCS), pages 1–12, 2013.