## Page 31
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
发送方和接方FSM如图3所示，在此问题中，发送方状态指示发送方是否从B（仅）、从C（仅）或从非C或8接收到ACK。接收方状态指示接收方正在等待哪个序列号。
rrupt(rcvpkt)
sender
start_timer
sdt senad(sndpkt, segrum)
(rcvpkt))
D& n
rcv(rcvpkt)
BorC
aitfo
ACK
pt(revpkt)
is_ack(se
receiverB
waitfor
seqnum
eiep
htutel.Sondof atieforPABlem 3.19(Problem 19)
P20,
31 / 79
---
## Page 32
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
rdt_rev(revpkt)&:&from_B(revpkt)
rd_rev(revpkt)&&from_A(revpk)
d_rev(revpkt)&&(coupe(revpkt)
Wait
[has_seq1(rcvpkt)&&:from_B(revpkt)
[has_seq1(revpkt)&&:
dt_rev(revpkt&&
revpkt)
for 0
_A(revpkt
rom B
uf_send(B,sndpkt)
sndpkt=make_pka(ACK, 1, checksum)
sndpkt=make_pkt(ACK, 1, checkss
udt_send(A,sndpkt)
ndt_rev(revpkt)&&not_comupt(revpkt)&&
deliver_data(data)
xtract(revpkt,data)
has_seq0(revpkt)&&from_B(rcvpkt)
sndpkt=make_pki(ACK, 0, chec
udt_send(A,sndpkt)
mdpkt=s
nd_ssd(B,sdpkt)
&&has_seql(revpkt)&&trom_B(recvpkt)
rd_rev(revpkt)&:&not_corrupe(revpkt)
(epepvdaoa)otxo
_seql(revpkt)&&fbe
_A(revpkt)
revpkt)&&h
sndpkt=make_pkt(ACK,1,checksum)
deliver_data(data)
udt_send(B,sndpkt)
zxtract(revpkt,data)
deliver_data(data)
rdt_rev(rcvpkt)&:&from_B(revpkt)
sndpkt
make_pkn(ACK,1,checksum)
adl_send(A,sndpkt)
rd_rev(revpkt)&:&(cor
rupt(revpkt)
sndpkt=make_pkt(ACK, 0, checkst
_A(revpkt)
[has_seq0(revpkt)&from_A(rovpkt)
rdt_rev(revpkt)&&(corrupt(revpkt)
https://feater.top
sndpkt=make_pki(ACK, 0, checksum)
udt_send(A,sndpkt)
图4:3.18的接收端FSM
发送方FSM完全相同，如图3.15中的文本所示
P21、由于A-to-8信道可能丢失请求消息，A将需要超时并目重新发送其请求消息（能够从丢失中恢复），因为信道延迟是可变的目未知，可能A将发送重复的请求（即
重新发送已经被b）接收到的请求消息。为了能够检测重复请求消息，协议将使用序列号。1位序列数量将足以用于停止和等待类星的请求/响应协议。A（请求者）有4个
状态：
“从上面等待请求0，“在这里，请求者正在等待一个呼可以请求数据单元。当接收到上述请求时，它发送一个请求消息R0，到B，启计时疆，并向等待00"状态过
度，当在“等特来自以上的请求0状态，A忽路从B收到的任何东西
“等D0在这里，请求者正在等待来自8的D0数据消息。定时器总是在这种状态下运行。如果计时器过期，A将发送另一条R0消息，重新启动定时器并保持此状态
如果从时接收到DX消息，A将停止时间并传输到从上面等待请求1“状态，如果A在此状态下接收D1数据消息，则忽路它。
“等待上面的请求1。“在这里，请求者再次等待来自上面的呼叫来请求一个数据单元，当它从上面接收到—个请求时，它向8发送一个请求消息R1，启动一个定时疆
并转换到等特01"状态。当处于“等待上述请求1"状态时，A会忽路从B接收的任何内容。
“等特D1。在这里，请求者正在等待来自8的d1数据消息。定时器总是在这种状态下运行。如果计时器过期，A将发送另一条R1消息，重新启动定时器并保持此状
态。如果从B接收到D1消息，A将停止定时器并传输到“从上面等特请求0°状态，如果A在此状态下接收到D0数据消息，则忽路它。
数据供应商（3)仅有两种状态
·在此状态下的发送D0，“，8题续响应收到的R0消息。发送D0，然后保持在该状态。如果B收到R1消息，则它知道其D0消息已正确接收，因此它丢弃该D0数据（由
于它已在另一侧效到》，然后过渡到发送01"状态，其中它将使用d1来发送下一个请求的数据块。
“发送D1在这种状态下，8题续通过发送D1来响应接收到的R1消息，然后保持这种状态。如果B接收到R1消息，则它知道其D1消息已被正确接收，从而传输到发送
D1*状态
P22.
a这里我们的窗口大小为n=3。假设接收机接收到分组k-1,并且已经将该分组和所有其它之前的分组进行了分组。如果所有这些ACK都已被由发送方接收，则发送方的窗口
为kk+n-1]假设下—个没有在发送方接收到ACK。在第二种情况下,发送方S度口包含k-1和n个分组，并包括k-1。因此发送者的窗口是这样的[K-N,K-1]。通过这些参
数，“发件人"窗口的大小为3，并开始在范围K-NK]的某处。
b)如果接收机正在等待分细k，则它已经接收（和被处理）分细k-1和N-1个分组。如果尚未收到这些N个ACK中的任何一个，发送方，然后可以传捐具有[k-n,k-1]值的ACK
消息由于发送方发送了数据包k-nk-11所以必领是这样的情况发送方已经接收到用于k-n-1的ACK。一且接收机发送了ACK对于k-n-1，它将永远不会发送小于k-n-1的
ACK。因此，飞行中的ACK值的范围可以从k-n-1到k-1,
P23、为了逐免图3.27中的场最，我们形至避免接收方窗口的前缘（即具有“最高“序列号的窗口）在序列号空间中环绕，井与后面的边缘（发送方窗口中具有“最低序列号
的度口）重叠，也就是说，序列号空间必须足够大，以适应整个接收方窗口和整个发送方窗口，而不存在这种重叠条件。因此-我们需要确定接收方和发送方窗口在任何
给定时间都可以覆盖多大的序列号。
32 / 79
---
## Page 33
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
假设接收者等特的最低序列号是包m，在这种情况下，它的度口是（m，m+w-1]，它已经接收到（并加进）包m-1和之前的w-1包，其中w是套口的大小。如果发送方尚末
接收到这些wACK中的任何一个，则值为[m-w，m-1]的ACK消息可能仍在传插。如果发送方没有收到带有这些ACK号的ACK，部么发送方的瘤口将是[m-w，m-1]。
号。也就是说，序列号空间必须至少是套口大小的两倍，k>=2w。
因此，发送方套口的下边缘为m-w，接收者官口的成缘为m+w-1，为了使接收方窗口的前缘不与发送方窗口的后缘重叠，序列号空间必须因此，足够大以客纳2w序列
P24,
收重复并重新确认1、2.3、在T4，发送方接收到在T1发送的接收机并使其前进的ACK。窗口至4、5、6.在t5，发送方接收在T2发送的接收机的ACK1、2、3，这些机屋在
官户外面
b)真，实质上与(a)中相同的情形。
c真
d)真。请注意，具有1、SR，GBN和交替位协议的度口大小功能等间。官口大小1排除了无序分组的可能性(在窗口内)。累积ACK仪仪是普通ACK这种情况，因为它只能据
套口内的单个分组，
P25,
a]考虑在传输协议上发送应用消息。使用TCP，应用程序将数据写入连接发送缓冲区，TCP将抓取字节必获在TCP段中放置一个消息：TCP可能会或多或少地发送消息而不
是在段中的单个消息。另一方面，UDP封装在无论应用程序给出什么，都会分段：因此，如果应用程序提供UDP应用消息，此消息将是UDP段的有效负载。因此对于
UDP，应用程序对数据段中的数据进行了更多控制。
b)由于流量控制和拥塞控制，TCP由于流量控期和辨塞控制，可能会有显著的延退从应用程序向其发送缓冲器写入数据直到数据被暂定给网络层。UDP由于流控制而没有
延迟，拥塞控制
P26、共有2”4294967296个可能的序列。
a]序列号不随每个段增部一个。相反，它会增扣发送的数据字节数。因此，MSS的大小是无关的-从A到B发送的最大大小文件就是可以表示为2”²4.19GBytcs的字节
数。
155Mbps蜡路上传输文件需要249秒。
P27,
a)在从主机A到的第二段中，序列号为207，源端口号为302，日的端口号为80，
b如果所述第一段在所述第二到达段之前到达，则在所述第一到达段的确认中，所述确认号为207，所述源端口号为80，所述目的端口号为302。
c如果第二段到达第一段之前，在第一个到达段的确认中，确认号为127，表示它仍在等特字节127和以后。d)
d)
Host A
Host B
Seq = 127, 80 bytes
Timeout
Seq = 207,40-by4es
Ack = 207
interval
Ack = 247
Seq = 127, 80 bytes
Timeout
Ack247
interval
https://feater.top
P28、由于链路容量只有100 Mbps，所以主机A的发送速率最多可达100Mbps，不过，主机A向接收缓冲区发送数据的速度比主机8从缓冲区中部除数据的速度要快。接收
级冲区的填充速率的为40 Mbps当级冲区已满时，主机8通过设置RcsWindow0向主机A发送停止发送数据的信号。然后主机A停止发送，直到接收到
33 / 79
---
## Page 34
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
RcvWindow>0的TCP段为止。主机A将作为RcvWindow值的通数反复停止并开始发送从主机B接收。平均而言，主机A向主机发送数据的长期速率b作为此连接的一部
分。不超过60Mbps,
P29,
a)服务器使用特定的初始序列号（从源和目的地IP和端口的撤列中获取)亲抵御SYN洪水攻击。
b)不，攻击者不能通过向目标发送和ACK数据包来创健半开故或完全打开的连接，半开连接是不可能的，因为在建立完整连接之前，使用SYNcookie的服务器不会维护任
何连接的连接变量和暖冲区。为了建立完全开放的连接，攻击者应该从攻击者那里知道与（伤造的源IP地址对应的特定初始序列号。这个序列号需要每个服务器使用的秘
密“编号。由于攻击者不知道这个秘密号码，魅无法精测初始序列号。
c不，服务器可以简单地在计算这些初始序列号时加上时间戳，并为这些序列号选择一个存适值，即使攻击者重插，也可以丢弃过期的初始序列号。
P30,
a如果超时值是因定的，则发送方可能会过早超时。因此，一些包即使没有丢失也被重新传输
b如果估计超时值(就像TCP所微的娜样），那么增加暖冲区大小肯定有助于提亮波路由然的吞吐量，但可能有一个潜在的问题，排队延迟可能非常大，类拟于场景1中所
示
P31,
(poufge)ufaql, $s
EstimatedRTT=(1-alpha)EstimatedRTT+α(pheSampleRTT 
DevRTT=(1-beta|DevRT7+beto|SampleRTT-EstimatedRTT] 
Timeoutinterval=EstimatedRTT+4DevRTT
$$[pou6(e(puor)
获取第—个SampkeRTT 106ms后:
(paufigeju6aq $$
EstimatedRTT=0.875100+0. 125106=100.75ms 
DevRTT=0.755+0.25|106-100|=5.25ms \
Timeoutlnterval=100.75+4*5.25=121.75ms
$$[pou6(e(puor)
获取120ms后:
DevRTT=0.755.25+0.25(120100.75]=8.75ms 
(poufge)ufaql, $s
EstimatedRTT=0.875100.75+0. 125120=103.16ms 
$S(poeuf(elpus)
TimeoutlInterval=103.16+4*8.75 =138.16ms
获取140ms后
DevRTT=0.758.75+0.25|140103.16]15.77ms 
(paufigeju6aq $$
Timeoutlnterval=107.76+4*15.77=170.84ms
EstimatedRTT =0.875103.16+0. 725140=107.76ms 
$$[pou6(e)pun
获取90ms后
(poufge)ufaql, $s
DevRTT=0.7515.77+0.25(90107.76]=16.27ms 
EstimatedRTT=0.875107.76+0. 12590=105.54ms 
Timeoutlnterval=105.54+4*16.27=170.62ms
(end[aligned)Ss
获取115ms后
(poufge)ufaql, $s
DevRTT=0.75 16.27+0.25|115105.54|=14.57ms \
Timeoutlnterval=106.72+4*14.57=165ms
EstimatedRTT =0.875105.54+0.725115=106.72ms 
[end[(alignedjSs
P32,
a]stimatedRTT表示第n个样本后估计的RTT值
EstimatedR7T(4)  zSampleRTT) + (1  z)[αSempie RTT + (1  z)[zSampleRTT, + (1  z)SempieRTT4|]  zSampleRTT) + (1  r)αSampleRT
b)EstimetedR77(n)  ±>j=1 (1  z) SempieRTT, + (1  z)1 SampleR7T,
c)EstimatedRTT(×)   =′(1  z)SampleRTT  ; 9′SamleRTT)
赋子过去样本的权重呈指数衰减
34 / 79
---
## Page 35
计算机网络：自顶向下方法课后习题参考答案.md
2020/10/13
P33、让我们亲看看如果TCP为重新传输的段度量SampleRTT会发生什么错误。般设激发送数据包P1，P1的计时圈过期，然后源发送P2，即同一数据包的新副本，此外，
假设源度量P2重发数据包的SampleRTT，最后，假设在发送P2后不久，对P1的确认到达。通将精误地将此确认视为P2的谢认，并计算不正确的SampleRTT值。
让我们看看如果TCP为重新传输的段度量SampleRTT，可能会发生什么蜡误。没源发送数据包P1，P1的计时器过期，然后源发送P2，即同一数据包的新副本。此外，假
说承度量P2重发数据包)的SampleRTT, 最后,数设在发送P2后不久,对P1的确认到达。题将盾误地将武确认视为P2的谢认, 并计算不正确的SampleRTT值,
P34、在任何给定的时间t，sendBas-1是发送方知道的最后一个字节的序列号，发送方知道该字节已在接收方正确地、有序地接收到，如果管道中有确认，则接收方在时
间处实际接农的最后一个字节（正确和有序可能更大。因此
SendBase  1 <= LastByteRcud
P35、当在时间t.发送者接收具有值y的确认时，发送者知道确保接收器接收到所有通过Y-1的所有信息。实际最后一个字节如果是，则在时间处的接收器处接收（正确地和有
序地)可以是更大的。SendBase或在管道中是否有其性确认。因此
y 1 <= LastByteVCD
P36、假设分相N、N+1和N+2被发送。并且分相N被接收和确认。如果分相N+1和N+2沿着端到端路径(御,在顾序N+2,N+1),更分组N_2的接收将为N生成重复ACK,
并且在仅等特第二重复ACK的策略下能发重传用于重传。通过等待三重重复ACK,必须是两个假设分相N、N1和N2被发送的情况，并且分组N被接收和确认。如果分组NT
和N2沿着端望路路轻御，在购序N+2,N+1)。则分期N_2的波收将为N生成重复ACK, 并且在仪等特第二重复ACK的策路下感发重传用于重传。通过等得三重重复ACK
必续在正确接效到分准N之后的TWT的情况。而没有接收到N1。设计者三重重复ACK方案可脂认为等待两个数据感(而非等待1个数据包)是在素获时能发快速重传之间
的正确权衡，但不在分非重新排序的情况下提激重传。
P37,
a]GCBACKN：A总其发送9个段。它们最初核发送段1、2、3、4、5和随后重新发送段2、3、4和5,B发送8个ACK,它们是4个带有序号1和4个ACK的ACK序列号2、3、4和
5.选释性重复：A总其发送6个段。它们最初核发送段1、2、3、4、5和随后重新发送段2。B源5个ACK，它们是序列号1、3、4、5的4个ACK,有—个人序列号为2的
ACK。TCP:A总其发送6个段。它们最初被发送段1、2、3、4、5和随后重新发送段2。B涨5个ACK，它们是具有序列号2的4个ACK。有一个ACK序列号6，请注意，TCP始终
发送带有预期序列的ACK编号。
bJTCP，这是因为TCP使用快速重传而不等待，直到超时。
P38、正确。发送数据总是接近ownd/RTT,
P39、如果到达率超过图3.46(b中的政/2，则到达的总到达速率队列超过队列的容量，导致由于到达速率而导数的损失增加增t加，当到达速率等于R/2时，每3个分组中
的1个商开。队列是重传。随着损失的增加，甚至更大的分组部分离开队列将是重传。很定最大编离率其中一个会活的队列是R/2.并且假定第三或更多个会话将随着到达
速率的增加而传输成功递送数据的吞吐量可以不会增加到外面。在类似的推理之后，如果有一半的数据包离开了队列是重传，每个会话的输出分组的最大速率是R/2测其
最大值为[R/2)/2或K/4,