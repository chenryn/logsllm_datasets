源于INDEX没有版本信息
①
②
查看VM后，发现对应HEAP PAGE有脏数据才需要回表。
index scan
index skip scan
• https://github.com/digoal/blog/blob/master/201803/20180323_03.md
• 从150多毫秒，降低到了0.256毫秒
create table t (
sex int,
name text
);
insert into t select random(),
md5(random()::text) from
generate_series(1,10000000); create
index idx_t on t(sex,name); select * from
t where name='abc';
index skip scan
bitmap scan
1 、 multi-index combine OR internalcombine(GIN)
2、消除离散、重复读HEAP
bitmap index scan
Sort heap block ID
Sorted block id scan
Recheck index
Cond
bitmap scan
• index scan - > sort heap blockid - > scan heap block - > recheck index
Cond.
• 优化器参考指标，相关性
• IO 放大问题消除
• SQL例子
• https://github.com/digoal/blog/blob/master/201804/20180402_01.md
bitmap scan
bitmap scan
• 离散扫描，每个BLOCK几乎都被重复扫描了140次，一个BLOCK刚好存储140条记录，说明这140条记 录
在顺序上完全离散。
• postgres=# explain (analyze,verbose,timing,costs,buffers) select * from corr_test where c2 between 1 and 10000000;
• QUERY PLAN
•
• Index Scan using idx_corr_test_2 on public.corr_test (cost=0.43..36296.14 rows=50000 width=8) (actual
time=0.029..6563.525 rows=9999999loops=1)
• Output: c1,c2
• Index Cond: ((corr_test.c2 >= 1) AND (corr_test.c2 = 1) AND (corr_test.c2  Bitmap Index Scan on idx_corr_test_2 (cost=0.00..2842200.75 rows=10000032 width=0) (actual time=681.488..681.488 rows=9999998loops=1)
• Index Cond: ((corr_test.c2 >= 1) AND (corr_test.c2 <= 10000000))
• Buffers: shared hit=27325
• Planning time: 0.147ms
• Execution time: 2758.621ms
• (10rows)
合并扫描
https://github.com/digoal/blog/blob/master/201702/20170221_02.md
ctid scan
• 根据给定行号，直接扫描HEAP PAGE。
• postgres=# explain (analyze,verbose,timing,costs,buffers) select * from car where ctid='(0,1)';
• QUERY PLAN
•
• Tid Scan on public.car (cost=0.00..1.11 rows=1 width=61) (actual time=0.006..0.007rows=1 loops=1)
• Output: id, pos, sites, rest_sites, mod_time,order_pos
• TID Cond: (car.ctid = '(0,1)'::tid)
• Buffers: shared hit=1
• Planning time: 0.183ms
• Execution time: 0.028ms
• (6 rows)
ctid scan
• 根据给定行号，直接扫描HEAP PAGE。
• postgres=# explain (analyze,verbose,timing,costs,buffers) select * from car where ctid = any( array['(0,1)'::tid, '(0,2)'::tid, '(100,1)'::tid] );
• QUERY PLAN
•
• Tid Scan on public.car (cost=0.00..3.33 rows=3 width=61) (actual time=0.005..0.032 rows=3loops=1)
• Output: id, pos, sites, rest_sites, mod_time, order_pos
• TID Cond: (car.ctid = ANY('{"(0,1)","(0,2)","(100,1)"}'::tid[]))
• Buffers: shared hit=2read=1
• Planning time: 0.182ms
• Execution time: 0.049ms
• (6 rows)
• 应用场景：
• Update|delete limit, parallel bigupdate|delete
• https://github.com/digoal/blog/blob/master/201608/20160827_01.md
目录
• 任意字段组合查询
• 索引结构和原理
• 数据扫描方法
• 应用实践
• 128个字段，任意字段组合搜索 -gin,bitmapscan
• 任意字段组合搜索 -非字典化（ column_prefix） gin\rum倒排搜索
• 任意字段组合搜索 -字典化 gin\rum倒排搜索
• 时空、数组、标量等多维度搜索 (50倍提速 vs ES)
任意字段组合查询设计1
• 每个字段都创建一个索引：
• 等值、范围、排序字段：btree
• 空间、范围字段：gist
• 多值列、全文检索、json、模糊查询字段：gin
• 查询时，数据库会自动选择 bitmap index scan或者 index scan
任意字段组合查询设计2
• 等值查询列：联合 rum/gin (等值、包含、相交 )
• 非等值查询列选择以下索引：
• 范围、排序字段：btree
• 空间、范围字段：gist
• 多值列、全文检索、json、模糊查询字段：gin
任意字段组合查询设计3
• 组合等值、不等值查询列：prefix+value array 化: rum/gin
• 加字段名前缀离散化方法。
任意字段组合查询设计4
• 组合等值、不等值查询列：字典化: rum/gin
• rum - - 目前rds pg 11支持，即将在所有常用版本支持
字典化离散化方法。
例子
• PostgreSQL 任意字段组合查询 - 含128字段，1亿记录，任意组
合查询
• https://github.com/digoal/blog/blob/master/201903/20190320_02.md
例子
• 大宽表任意字段组合查询索引如何选择(btree, gin, rum)
• https://github.com/digoal/blog/blob/master/201808/20180803_01.md
例子
• ADHoc(任意字段组合)查询(rums索引加速) - 非字典化，普通、
数组等组合字段生成新数组
• https://github.com/digoal/blog/blob/master/201805/20180518_02.md
例子
• ADHoc(任意字段组合)查询 与 字典化 (rum索引加速)
• https://github.com/digoal/blog/blob/master/201802/20180228_01.md
例子
• 空间应用 - 高并发空间位置更新、多属性KNN搜索并测（含空间
索引）末端配送、新零售类项目
• https://github.com/digoal/blog/blob/master/201711/20171107_48.md
参考资料
• 多维组合-任意维度组合搜索案例
• https://github.com/digoal/blog/blob/master/201903/20190320_02.md
• https://github.com/digoal/blog/blob/master/201808/20180803_01.md
• https://github.com/digoal/blog/blob/master/201805/20180518_02.md
• https://github.com/digoal/blog/blob/master/201802/20180228_01.md
• https://github.com/digoal/blog/blob/master/201711/20171107_48.md
• MySQL手册
• https://www.mysqltutorial.org/
• https://dev.mysql.com/doc/refman/8.0/en/
• PG 管理、开发规范
• https://github.com/digoal/blog/blob/master/201609/20160926_01.md
• PG手册
• https://www.postgresql.org/docs/current/index.html
• https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-vs-mysql/
• GIS手册
• http://postgis.net/docs/manual-3.0/
一期开课计划(PG+MySQL联合方案)
• - 2019.12.30 19:30 RDS PG产品概览，如何与MySQL结合使用
• - 2019.12.31 19:30 如何连接PG，GUI，CLI的使用
• - 2020.1.3 19:30 如何压测PG数据库、如何瞬间构造海量测试数据
• - 2020.1.6 19:30 MySQL与PG对比学习(面向开发者)
• - 2020.1.7 19:30 如何将MySQL数据同步到PG（DTS）
• - 2020.1.8 19:30 PG外部表妙用 - mysql_fdw, oss_fdw（直接读写MySQL数据、冷热分离）
• - 2020.1.9 19:30 PG应用场景介绍 - 并行计算，实时分析
• - 2020.1.10 19:30 PG应用场景介绍 - GIS
• - 2020.1.13 19:30 PG应用场景介绍 - 用户画像、实时营销系统
• - 2020.1.14 19:30 PG应用场景介绍 - 多维搜索
• - 2020.1.15 19:30 PG应用场景介绍 - 向量计算、图像搜索
• - 2020.1.16 19:30 PG应用场景介绍 - 全文检索、模糊查询
• - 2020.1.17 19:30 PG 数据分析语法介绍
• - 2020.1.18 19:30 PG 更多功能了解：扩展语法、索引、类型、存储过程与函数。如何加入PG技术社群
本课程习题
• PG支持哪几种索引
• PG支持哪几种扫描方法
• 多值列应该使用什么索引
• 多个字段任意组合搜索应该使用什么类型的索引
• 空间包含、相交、距离排序等查询应该使用什么类型的索引
• 多个字段等值组合查询，可以使用哪几种索引加速
技术社群
PG技术交流钉钉群(3600+人)