表达式集合
OUT[B] = fB(IN[B])
OUT[ENTRY] = 0
(anticipated[B]).in U z) - e-kill 
前向
表达式集合
fB(c) =
d)被使用的表达式
b）可用表达式
图9-35例9.31的流图，用
以说明可用表达式的使用
a=
B
B2
415
---
## Page 432
最后位置之一。
中而不是 Ba中会引起路径 Bs→Bg-→B上的冗余计算。我们将看到，B4 是我们能够计算b+c 的
中被使用了。但是我们可以把它从 B;后延到 B4。
这两个基本块上b+c被预期执行但不可用。我们不能把b+c从 Bs后延到 B。，因为b+c在 Bs
Bs。请注意，这两个基本块在图9-33a中都被表示为带有黑色阴影的灰色方块，这表示在且只在
例9.34
+y的使用。
置较前的x+y，并且在最后一个这样的位置到p之间没有对
下：在所有从程序人口结点到达p 的路径中都会碰到一个位
即将从 B4 到达 B， 的时候。
我们可以把表达式6+c的计算推迟到 Bs 的开始以及控制流
成的循环的执行，最后由基本块B，使用。在另一种方法中，
计算结果将在一开始就被保存起来，经过由基本块B2、B3组
候立刻计算它的值，那么我们就要在B，中计算b+c的值。
的开头就被预期执行了。如果我们在表达式被预期执行的时
例9.33
9. 33 说明了这个步骤的重要性。
Bs一B一→B，中被计算两次。表达式b+c甚至在基本块B
执行-一次一
请注意，b+c被认为在B4 的人口处可用，因为在--条路径B→B2一B→Ba中，b+c 至少被预期
B2、B 和 Bs。该表达式的靠前放置的位置使用带有黑色阴影的灰色方块表示，它们是 B, 和 B5。
例932
式+c，因为 B2使得表达式b+c在此处变得可用。
有被预期执行，但是在基本块B4的人口处被预期执行。然而，没有必要在基本块B中计算表达
但是，我们不能把 6+c从 B4 后延到 B。原因是虽然b+c在B4 中没有使用，把它放到 B
析考虑的是某些事情是否对于所有的路径都为真。
算还是交集运算作为交汇运算（可以按照这两个特性的不同取值把各个数据流分析模式分别
一个中。这四个组按照下面的方法进行刻划：它们是前向的还是逆向的，它们是使用并集
两个特点的有用分析技术的例子。几乎我们使用的所有分析技术都可以放到四个分组中的某
到了可用表达式分析(9.2.6节)那样使用交集运算作为交汇运算的框架。这是第--个具有这
的数据流分析。虽然我们已经看到了活跃变量分析(见9.2.5节)这样的逆向框架，且我们看
正式地讲，一个表达式+y可后延到程序点p 的前提如
416
算法的第三步在保持原程序语义并将冗余最小化的情况下把表达式的计算尽量地延后。例
可后延(postponable)表达式
被预期执行的表达式(其他文献中也称之为“很忙的表达式”)是一类我们之前没有看到
让我们再次考虑图 9-33 中的表达式+c。其中可放置b+c的两个最前的点是 B和
在图9-36 所示的流图中，表达式b+c在路径 B,
图9-33a中带有黑色阴影的各个基本块上的表达式6+c不可用，这些基本块是B
--在这个例子里是 B一
一并且从 B 的人口点开始，b和c 都没有被重新计算。
2 ×2方块的补全
以说明后延一个表达式的需求
图9-36例9.33的流图，用
第9章
口
---
## Page 433
算法9.36
格的顶元素——空集。
这些表达式。在程序的出口处没有表达式被使用。因为我们关心的是找出被任何后续路径所使
人口点处被使用的表达式。一-个基本块生成了é_useB 集合中的全部表达式，就是说新近使用了
在基本块B 的出口点被使用的表达式不在B的最后放置（latest)集合中，那么它也是一个在 B 的
说该表达式在点P上被使用。这个分析实质上是活跃性分析（是对表达式而言，而不是对变量而
地方使用。如果从程序点p出发的一条路径在表达式被重新求值之前使用了该表达式，那么我们
+c都被替换为t。
用
言)。
的最后放置位置在基本块 Bα和 Bg的人口处，这是因为
的基本块，而黑色阴影的方块表示了相应可后延集合中包含b+c 的基本块。因此，表达式6+c
例9.35
本块B的前面。
后继入口处的 carliest 集合和可后延集合中。
的 earliest 集合或可后延集合中。另外，当下列条件之一成立时，B在e的后延边界中：
方。更加明确地说，表达式e可以被放置在基本块B的开始处的前提条件是该表达式在B人口处
必须被初始化为相应半格的顶元素-—-全集。
延到这个基本块的人口处。因此，这个数据流分析的交汇运算是交集运算，并且各个内部程序点
一个基本块的所有前驱结点出口处的可后延集合中都包含某个表达式，否则该表达式不能被)
且它可以后延到B的人口处，或者它在 earlies[B］中，那么它就可以被后延到B 的出口处。除非
个表达式“后延"到程序的人口处，因此 OUT[ENTRY］=。如果-个表达式在B 中没有使用
月的表达式，因此这个问题的交汇运算是并集运算。因此，各个内部点必须被初始化为相应的半
被使用的表达式问题的数据流方程组如图 9-34d 所示。这个分析过程是逆向的。如果一
机器无关优化
 2）e不能被后延到B 的某个后继基本块。换句话说，存在一个 B的后继基本块使得e不在该
 粗略地说，--个表达式将被放置在边界上，即一个表达式从可后延转变成为不可后延的地
可后延表达式问题的数据流方程组如图9-34c 所示。这个分析过程是前向的。我们不能把-
2）
1）在每条进人某个具有多个前驱的基本块的边上插入一个空基本块。
方法：
输出：一个经过修改且满足9.5.3 节所描述的懒情代码移动的四个条件的数据流图。
输入：一个流图，其中每个基本块 B的 e_use 和 e_hil 已经计算得到了。
本算法的各个步骤在算法9.36中进行了汇总。
综合全部步骤
最后，用一个逆向分析过程来确定一个被引人的临时变量是否在它所在基本块之外的其他
被使用的(used)表达式
如图所示，该表达式的值在基本块 Ba 和 B;中被存放到临时变量t中，在任何其他地方的
2）Bs 的 earliest 集合包含了b+c，并且它使用了b+c。
1）b+c在B4 的可后延集合中，但是不在B，的可后延集中，并且
因为在算法的预处理阶段引人了新的基本块，所以在上述两种情形中，表达式é可以放在基
按照 9-34a 中的定义，计算出所有基本块 B的 anticipated[B].in 的值。
图9-33b 显示了上述分析的结果。其中的灰色方块表示了相应 earliet 集合中包含.b+c
懒惰代码移动。
417
→
口
---
## Page 434
集合。
9.5.69.5节的练习
它使用并集运算作为交汇运算。
可以被消除。我们通过一个逆向的数据流分析来发现被使用的表达式，
分析技术找到的，这个分析技术使用交集运算作为交汇运算。
表达式在此程序点上可以后延。可后延表达式是通过一个前向的数据流
序点。如果到达一个程序点的所有路径都没有碰到某个表达式，那么该
期执行。
数据流分析技术计算了一个表达式是否在所有路径中都在该点之前被预
表达式是通过一个前向数据流分析找到的，它使用交集运算作为交汇运算。对各个程序点，这个
之后的所有路径中被使用。
分析，并使用交集运算作为交汇运算。因为它确定的是对于各个程序点，一
个数据流问题来寻找最优的表达式位置。
替换
开头。
4）除非一个临时赋值语句被其后的某条路径使用，否则该赋值语句
3）一个表达式的最后放置位置就是该表达式在其上不可再后延的程
1）有关位置的约束由预期执行表达式分析提供。预期执行表达式分析是一个逆向的数据流
③对于所有基本块 B，如果x+y在集合e_use g ∩（－ latest[B]Uused out[B]）中，就用t来
418
5）计算各个基本块的开头和结尾的被使用的(used)表达式集合。
4）计算各个基本块的开头和结尾的可后延(postponable)表达式集合。
2）计算各个基本块的开头和结尾的可用(available)表达式集合。
1）计算各个基本块的开头和结尾的预期执行的（anticipaled)表达式
练习9.5.1：对于图9-37中的流图：
2）一个表达式的最前放置位置就是该表达式在其上被预期执行但又不可用的程序点。可用
3）
部分亢余消除技术用统一的算法归纳出不同类型的冗余计算。这个算法说明了如何使用多
总结
原来的每个+y。
7）按照图 9-34d 中的定义，找到所有基本块 B的 used[B].out 值。
请注意，其中的一表示的是以程序中所计算的全部表达式的集合作为全集的补集运算。
6）计算所有基本块B的最后放置集合：
5）按照图 9-34c 的定义，计算出所有基本块 B的 postponable[B].in 的值。
4）为每个基本块B计算它的最早放置位置；
3）按照9-34b 中的定义，计算出所有基本块B的 auailable[B].in 的值。
①
8）对于程序计算的每个表达式，比如+y，做下列处理：
计算各个基本块的 earliest 集合。
对于所有基本块B，如果+y在 latest[B]∩used[B].out中，就把t=+加人到B的
为x+y创建一个新的临时变量，比如说t。
latest [ B] = ( earliest[B] Upostponable[B]. in) ∩
 earliest[ B] = anticipated[ B]. in - available[ B]. in 
一个表达式是否在该点
9.5.1的流图
图9-37练习
+x=
= x+y
×=
= x+y
ENTRY
第9章
B4
口
---
## Page 435
显示了图 9-38 中流图的支配结点树。
并且每个结点d只支配它在树中的后代结点。比如，图9-39
点树（dominator tree）来表示。在树中，人口结点就是根结点，
配结点7、8、9、10；结点8支配结点8、9、10;9和10只支配
的某一个结点通过，从而绕过另一个结点。最后，结点7支
点。结点4支配除1、2、3之外的所有其他结点，因为所有从
径到达所有其他结点，所以结点3 支配除1、2 之外的所有结
点2 只能支配它自己，因为控制流可以通过以1-+3开头的路
在这个定义下每个结点支配它自己。
点d，我们就说 d 支配（dominate）n，记为 d dom n。请注意
9.6.1支配结点
些概念。
找循环及选代式数据流分析的收敛速度的讨论中需要用到这
排序、回边、图的深度和可归约性。我们在后面进行的对寻
有的结点进行一次访问就可以解决。
行一趟扫描就可以得到数据流问题的答案。比如，一个前向数据问题只需要按照拓扑次序对所
大的影响。因此，识别循环并有针对性地处理它们是很重要的。
什么不同。但是，循环的重要性在于程序花费大部分时间来执行循环，改进循环效率的优化有很
9.6流图中的循环
被使用时才进行求值。
新的定值被放在原来的定值之后。设计--个算法来删除部分死亡代码，使得表达式只在一定会
除部分冗余时，表达式被移动到原来的表达式之前；和消除部分冗余相反，部分死亡代码消除中
dead）。我们可以只在该变量活跃的路径上执行这个定值，从而优化这个程序的执行效率。在消
定值仅仅对于部分路径活跃，但对于其他路径是死亡的，那么这个定值就是部分死亡的（ partialy
α+b、c-a和b*d。
它们自身。
点5和6都只支配它们自身，因为控制流可以选择从它们中
人口结点支配所有结点(这个结论对所有的流图都成立)。
例9.37
开始的路径的开头要么是1-→2→3--+4，要么是1→3-4。结
机器无关优化
一-种有用的表示支配结点信息的方法是用所谓的支配结
如果每一条从流图的人口结点到结点n的路径都经过结
在这一节中，我们将介绍下列概念；支配结点、深度优先
循环也会影响程序分析所需的时间。如果一个程序不包含任何循环，我们只需要对程序进
 在至今为止的讨论中，循环并没有被区别对待，对它们的处理方式和其他类型的控制流没有