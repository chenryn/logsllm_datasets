ifications  grow  more  slowly  than  implementations.  It 
also offers the potential of component reuse: component 
technologies typically  separate  the  notion  of  specifica- 
tion (variously called interface or type) from that of im- 
plementation.  Since reuse occurs more often at thespec- 
LamportME 
t . j   A  {Request C S }  -+ 
REQj  := 1c.j;  h.j:=true; 
Insert(request-queue.j, REQ,); 
(Vk : k # j  : send-request(j , REQ, , k ) ) 
-.e.j  A  { receive-request for “REQk” } --+  .-- true; 
j.REQk  := REQk; Receiued(j.REQk) .- 
Insert(request-queue.j, j.REQk); 
send-reply(j , 1c.j , k ); 
Receiued(j.REQk) :=false 
-1e.j  A  { receive-reply for “1c.k” } -+ 
j.REQk  := 1c.k; 
i f  ( REQj 
j.REQk ) then grant.j.k := true 
(Vk : k # j  : 9rant.j.k) 
h..j  A 
A  REQ, = Head(request-queue.j) -+ 
e . j  := true 
e . j   A  (Release CS } + 
REQ,  := 1c.j;  t.j:=true; 
(Vk : k # j  : grant.j.k :=false); 
(Vk : k # j  : j.REQk  := CO); 
Dequeue( request-queue.j ); 
(Vk : k  # j :  send-release(j , RE&,  , k )) 
-7e.j  A  { receive-release for “REQk” } --+ 
j.REQk  := REQk;  9rant.j.k :=true; 
Dequeue( request-queue.j  ) 
true --+ 
(Vk : k # j  : 9rant.j.k := 
request4ueue.j  := 
j.REQk)  A 
(REQ, 
Sort({REQ,, (Vk : IC  # j  : j . R E Q k ) } )  
j.REQk  # 00); 
Figure 3. Lamport-ME 
ification  level than  the  implementation level, it may  be 
argued that graybox stabilization is more reusable  than 
stabilization that is particular to an implementation. 
The graybox approach has received limited attention 
in  the  previous  work  on  dependability.  In  particular, 
we  can  point  to  [4,6,  191 which  reason  at  a  graybox 
level;  [ 171  addresses  specification-oriented  integration 
of  system  modules  for  designing  dependable systems; 
and [ 151 addresses the role of  automated formal meth- 
ods for specifications  which involve dependability. 
Although we have limited our discussion of the gray- 
box  approach  to  the  property  of  stabilization,  the  ap- 
proach is applicable for the design of other dependabil- 
ity properties, for example, masking fault-tolerance  and 
(A  system  is  masking  fault- 
fail-safe  fault-tolerance. 
tcderant iff its computations in the presence of the faults 
396 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:58:03 UTC from IEEE Xplore.  Restrictions apply. 
implement  the  specification.  A  component is fail-safe 
fault-tolerant  iff  its  computations  in  the  presence  of 
faults  implement  the  “safety”  part  [but not necessarily 
the “liveness” part] of its specification.) Our observation 
that graybox stabilization  is not readily achieved for all 
specifications is likewise true for graybox masking and 
graybox fail-safe.  Moreover, our observation that local 
everywhere specifications are amenable to graybox sta- 
bilization is also true for graybox masking and graybox 
fail-safe. 
Of  course,  local  everywhere(-eventually) specifica- 
tions  are  only  a  sufficient  condition  for  graybox  de- 
sign of dependability properties.  Experience [ 16,201 in 
fact confirms that  there are practical  systems where lo- 
cal  everywhere(-eventually) specifications  are  not nec- 
essary.  So an  interesting  direction for further research 
is to identify other relevant classes of specifications that 
are amenable to graybox design of other dependability 
properties.  Another direction we are pursuing  is auto- 
matic synthesis of graybox dependability. 
Acknowledgments 
We thank Ted Herman and an anonymous referee for 
insightful comments which helped to improve the paper. 
References 
[ I ]   Y. Afek  and  S. Dolev.  Local  stabilizer.  PODC97 Pro- 
ceedings of  the  Si.rteentlz Annual ACM  Symposium  on 
Principles of Distributed  Computing, page 287,  1997. 
[2]  A.  Arora,  M.  Demirbas,  and  S.  S.  Kulkarni.  Gray- 
box  stabilization.  Technical  Report  OSU-CISRC-I/Ol- 
TROl, The Ohio State University, Department  of  Com- 
puter and Information  Science, 200 1,  ftp://ftp.cis.ohio- 
state.edu/pub/tech-report/. 
[3]  A.  Arora,  M.  G. Gouda,  and  G. Varghese.  Constraint 
satisfaction  as  a  basis  for designing nonmasking  fault- 
tolerance.  Journal  of  High Speed  Networks, 5(3):293- 
306,  1996. 
[4]  A. Arora, S. S. Kulkarni,  and M. Demirbas.  Resettable 
vector clocks. Proceedings of the 19th ACM Symposium 
on Principles of Distribirted  Computing (P ODC), pages 
269-278,  August 2000. 
[5]  K. M. Chandy  and J. Misra.  Paral/el Program Design. 
Addison-Wesley Publishing Company,  1988. 
[6]  M. Demirbas.  Resettable  vector clocks:  A case study in 
designing graybox fault-tolerance.  Master’s thesis, Tech- 
nical report OSU-CISRC-4/00-TR11, Ohio State Univer- 
sity, February 2000. 
[7]  E.  W.  Dijkstra  and C. S. Scholten.  Predicate  Calculus 
and Program Semantics. Springer-Verlag,  1990. 
[8]  S. Dolev. Self-Stabilization. hlIT Press, 2000. 
[9]  M. Flatebo, A. K. Datta, and S. Ghosh. Readings in Dis- 
tributed  Computer System, chapter 2:  Self-stabilization 
in  distributed  systems.  IEEE  Computer  Society  Press, 
1994. 
[lo]  M. G. Gouda.  The  triumph  and  tribulation  of  system 
stabilization.  Invited  Lecture,  Proceedings  of  9th Inter- 
national Workshop on Distributed Algorithms, Springer- 
Verfag, 972: 1-1  8, November  1995. 
[ 1 11  T.  Herman. 
Self-stabilization  bibliography:  Access 
guide.  Chicago  Joumal  of  Theoretical Computer  Sci- 
ence, Working Paper WP-I. initiated  November  1996. 
[ 121  S. Katz and K. Perry. Self-stabilizing extensions for mes- 
sage passing  systems.  Distributed Computing, 7: 17-26, 
1993. 
[13]  L. Lamport.  Time,  clocks, and  the ordering of  events 
in  a disributed  system.  Communications  of the ACM, 
21(7):558-565,  July  1978. 
141  G.  Ricart  and A.  Agrawala.  An  optimal  algorithm  for 
mutual  exclusion  in  computer  networks.  Communica- 
tions offhe ACM, 24(1):9-17,  1991. 
151  J. Rushby.  Calculating  with requirements.  Invited paper 
presented  at 3rd  IEEE International Symposium  on Re- 
quirements Engineering, pages  144-146,  January  1997. 
161  A. Singhai, S.-B. Lim, and S.R. Radia. The SunSCALR 
framework for internet  servers.  Proceedings ofthe 28th 
IEEE Symposium on Fault Tolerant Computing Systems 
(FTCS-28), pages  108-1  17, 1998. 
171  N.  Suri, S. Ghosh,  and T.  Marlowe.  A framework  for 
dependability  driven  sw integration.  IEEE DCS, pages 
405-41 6, 1998. 
181  G.  Varghese.  Self-stabilization by  local  checking  and 
correction. PhD thesis, MITILCSITR-583,  1993. 
191  K. P. Vo, Y.  M. Wang, P. E. Chung, and Y.  Huang.  Xept: 
A  software  instrumentation  method  for  exception  han- 
dling. Proc. Int. Symp. on Software Reliabiliy Engineer- 
ing (ISSRE), November  1997. 
201  Y.-M.  Wang, W. Russell,  A. Arora, J. Xu,  and R. Jagan- 
nathan. Towards dependable home networking:  An expe- 
rience  report.  International  Conference on Dependable 
Systems and Networks, 2000. 
Appendix AI 
U 
Lemma4.  Given that A = (n i ::  A t ) ,  and C = (n i ::  Ct), 
(Vi :: [Ci E  A , ] )  3 [C C  A] 
Proof. 
397 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:58:03 UTC from IEEE Xplore.  Restrictions apply. 
=+ 
(Vi  :: [Ci C  A,]) 
{ monotonicity of n w.r.t. [  c  ]  } 
[(n i  ::  Ci) g  (n i ::  A,)] 
=  { premise  } 
[C 5  AI 
0 
Lemma 5.  Given that W = (n i  ::  W z ) ,  W‘ = (n i  ::  W;), 
A = (n i ::  Ai), and C = (n i  ::  Cz), 
((vi :: [c, c  A,])  A 
r/vZl))  =+  [(C U  W ’ )  c  (A  0 Wl 
[W E 
(Vi :: 
Proof. 
=  { Lemma 4, twice } 
((Vi :: [ci  Ai])  A 
([c &  A]  A  [W’ &  W ] )  
[(C 0 rv’) E  ( A  0 Wl 
=  {Lemmal} 
(Vi :: [W: 2  Wi])) 
0 
Theorem  8  (TME-Spec). 
Lspec also implements TMESpec. 
Every  system  that  implements 
(VM :: [hi‘ &  Lspe~]~,,~t =+- [A4 &  T M E - S ~ ~ C ] , , , ~ ~  
) 
Proof.  In order to prove Theorem 8, we identify an invariant, 
I ,  for Lspec. 
( I )  = (Vj, k : j  # k : j.REQk, = REQc 
V  j.REQk  REQk) 
We prove Theorem 8 based on this invariant.  For reasons 
of space we relegate  the proof to [2]. 
0 
Lemma 9 (Interference freedom).  Lspec  0 W  implements 
Lspec. 
[( Lspec  0 W )  &  Lspecltnit 
true 
Proof. 
=$  { (h.j + REQj = REQ:) in W ,  PV, Request Spec } 
=+  { Proposition 0 } 
[W  &  Request Spec]init 
[(Lspec 0 W )  2  (Lspec  0 RequestSpec)]i,it 
[( Lspec  0 W )  E  LspecItnzt 
=  {Request Spec E Lspec} 
0 
Lemma 10.  Lspec  0 W is stabilizing to Lspec. 
Proof. 
+  { Request Spec, W ,  Reply Spec, Release Spec, 
true 
Timestamp Spec, channels flushed, 
Communication Spec, stable(1) in (Lspec  IJ  W )  
(follows from Lemma 9, Theorem 8) } 
[( Lspec  0 W )  
[( Lspec  0 W )  
true  L)  I ]  
A  [( Lspec  0  W )  &  Lspec]i,it 
true  L) I ]  
=  { Lemma9 } 
=  { From proof of Theorem 8, W does not depend on 
history information, definition  of  stabilization } 
(Lspec 0 W )  is stabilizing to Lspec 
cl 
398 
Theorem  12.  RA-ME  everywhere-eventually  implements 
Lspec. 
[ RA-ME  c  C’  Lspec] 
Proof. 
Str~ctitral Spec:  At  any  time state.j  denotes exactly one  of 
h.j, e.j, or t.j. 
Flow Spec:  h.j, e.3,  t . j  are  modified  only by  Request  CS, 
Grant CS, or Release CS. 
CS Spec: Client assumption. 
Tirnestanzp Spec: RA-ME  uses logical clocks. 
Cornmunication Spec: RAME assumes FIFO channels. 
Request Spec: follows from Request CS action and that RE&, 
is riot changed until t . j  holds. 
Reply Spec: receive-request for “REQk” and Release CS ac- 
tion and correction of deferredset.j by the last action. 
CS Entn Spec: Grant CS action. 
CS Release Spec: Release CS action. 
0 
Thleorem  13.  Lamport-ME  everywhere-eventually  imple- 
ments Lspec. 
[ Lamport-ME  2  C’  Lspec] 
Proof.  The proof is the same as that in Theorem  12, except 
that for the proof of CS Entry Spec we use the correction of re- 
qirest-queue.j  and granr.j.k by the last action of Lamport-ME. 
0 
Appendix A2 : Symbols and Operators 
- 
Used as 
Abstract  system, specihcation 
Concrete system 
Wrapper 
I  Explanation 
1  Box operator (cf. 52.1) 
‘Unless’(cf.  53.1) 
stable(p) = p  unless false 
‘Leads to’ (cf. 33.1) 
‘Leads to always’ (cf. 33.1) 
I  Propositional  connectives (in decreasing precedence) 
Negation 
Conjunction, Disjunction 
Implication, Follows from 
Equivalence, Inequivalence 
I) 
- 
First order quantifiers 
V 
3 
Universal (for all) 
Existential  (there exists) 
Authorized licensed use limited to: Tsinghua University. Downloaded on March 19,2021 at 03:58:03 UTC from IEEE Xplore.  Restrictions apply.