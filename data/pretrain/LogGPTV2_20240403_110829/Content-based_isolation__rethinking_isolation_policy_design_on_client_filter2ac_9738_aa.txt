title:Content-based isolation: rethinking isolation policy design on client
systems
author:Alexander Moshchuk and
Helen J. Wang and
Yunxin Liu
Content-Based Isolation: Rethinking Isolation Policy
Design on Client Systems
Alexander Moshchuk
Microsoft Research
Redmond, WA, USA
PI:EMAIL
Helen J. Wang
Microsoft Research
Redmond, WA, USA
PI:EMAIL
Yunxin Liu
PI:EMAIL
Microsoft Research Asia
Beijing, China
ABSTRACT
Modern client platforms, such as iOS, Android, Windows
Phone, and Windows 8, have progressed from a per-user
isolation policy, where users are isolated but a user’s ap-
plications run in the same isolation container, to an appli-
cation isolation policy, where diﬀerent applications are iso-
lated from one another. However, this is not enough because
mutually distrusting content can interfere with one another
inside a single application. For example, an attacker-crafted
image may compromise a photo editor application and steal
other images processed by the editor.
In this paper, we advocate a content-based principal
model in which the OS treats content owners as its prin-
cipals and isolates content of diﬀerent owners from one an-
other. Our key contribution is to generalize the content-
based principal model from web browsers, namely, the same-
origin policy, into an isolation policy that is suitable for all
applications. The key challenge we faced is to support ﬂex-
ible isolation granularities while remaining compatible with
the web. In this paper, we present the design, implemen-
tation, and evaluation of our prototype system that tackles
this challenge.
Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection
Keywords
Web browsers; same-origin policy; isolation
1.
INTRODUCTION
Much research has been devoted to isolation mecha-
nisms [38, 33, 29, 3, 53, 12, 17] to enable robust isolation
containers in operating systems. However, little research
has been done on the dual of the problem, isolation policies,
namely, “what should be put into the isolation containers”;
this is the topic of this paper. Isolation policy design is as
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516722.
Figure 1: The evolution of isolation policies. Content-
based isolation provides two beneﬁts over other policies:
(1) Any remote content’s impact is minimized (2) There
is no need to ask users to determine whether to risk
opening remote content.
critical as that of isolation mechanisms, since even with per-
fect isolation containers, an improper isolation policy can
render the system insecure.
For example, today’s Windows-based or Unix-based desk-
top PCs treat users as principals and protect user accounts
from one another. However, mutually distrusting applica-
tions of one user can interfere with one another. This is
the root cause of the signiﬁcant malware problem on desk-
tops. Learning the lessons from desktops, modern client
platforms, such as iOS and Android, have reﬁned the user-
based isolation policy to treat each application code package
as a separate principal, and diﬀerent applications are run in
separate isolation containers. This isolation policy is still
too coarse because mutually distrusting content can inter-
fere with one another within the same application. Consider
the scenario where Alice opens a PowerPoint presentation
from http://alice.com/talk.ppt, which embeds a mali-
cious video from http://attacker.com/advideo.swf. The
attacker can compromise Alice’s presentation as well as other
documents being rendered by PowerPoint.
Figure 1 illustrates the evolution of isolation policies on
client platforms. In this paper, we further reﬁne the isolate-
by-code-package policy and advocate future client platforms
to embrace a content-based isolation policy which puts ex-
ecution instances of mutually distrusting content into sep-
arate isolation containers. Content-based isolation oﬀers a
fundamentally more secure system because any content’s im-
pact including that of malicious content is minimized to just
the content owner’s isolation container. Consequently, there
is no need to ask users to determine whether to take the risk
of opening any content. Existing applications often prompt
users (e.g., “Are you sure you want to open this document?”)
1167because such ﬁne-grained containment is not available, and
risk handling is unreasonably outsourced to the user.
To some extent, the notion of a content-based prin-
cipal model exists in today’s web. All web browsers
implement the same-origin policy [41], which prevents
web content of diﬀerent origins
(represented by the
triple )
from interfering with
one another. Unfortunately, these principals may un-
desirably share the same isolation container in commer-
cial browsers [49]. Recent research browsers, such as
Gazelle [49], proposed to separate web site principals into
separate isolation containers, fully achieving a content-based
principal model for the browser setting.
As modern client platforms (e.g., iOS, Android, Windows
Phone, Windows 8) and applications embrace cloud-centric
computing where documents and computing logic reside in
the cloud and are cached on client devices, applicability of
a content-based principal model goes beyond the browser
setting. Today, applications often need to process and em-
bed remote content. For example, Microsoft Oﬃce 2010 can
open remote web documents, PowerPoint 2010 allows users
to embed YouTube videos in presentations and the Google
Cloud Connect [16] plug-in allows Oﬃce to sync documents
with the cloud. Such applications are eﬀectively becoming
browsers for their own media types, and they now face many
of the same security challenges that web browsers have faced
over the past decade, namely, isolating mutually distrusting
content from one another.
Today, content isolation is left as a responsibility of each
native application. For example, Microsoft Oﬃce 2010’s new
Protected View [30] feature provides a sandboxed read-only
mode for documents originating from the Internet and users
have to explicitly “enable editing” to remove the sandbox
and its restrictions at their own risk. Adobe Reader re-
cently introduced a similar sandboxing feature [1]. Letting
each application handle content protection has serious draw-
backs. First, security of a user’s cloud data is duplicated
and entrusted to all of the user’s applications. Attackers
need only ﬁnd one badly-written application and target it
to exploit all content (at the web scale) that this applica-
tion renders. Second, security logic in applications is often
mixed with error-prone content processing logic; content iso-
lation vulnerabilities are discovered not only in browsers and
plug-ins [18, 49, 2], but also in desktop applications. For
example, the recent RSA SecurID token compromise [36]
that aﬀected 20,000 RSA’s enterprise customers was caused
by a maliciously crafted Excel email attachment, and from
2008-2011, 88% (224) of Microsoft Oﬃce vulnerabilities are
content parsing ﬂaws exploitable by maliciously crafted doc-
uments [34]. Worse, many desktop applications do not oﬀer
any isolation for certain remote content. For example, Pow-
erPoint 2010 renders embedded remote videos in the same
process and makes no attempt to isolate them, letting po-
tential Flash vulnerabilities endanger the PowerPoint appli-
cation and its documents. Overall, users must endure weak
and inconsistent security of applications that process their
cloud-backed data.
In this work, we let the OS take over the burden of content
isolation from applications. By consolidating content isola-
tion logic in the OS, we reduce the trusted computing base
from trusting many applications’ isolation logic to trusting
just that of the OS. The main contribution of this paper is
a general content-based principal model suitable for all ap-
plications beyond just browsers. Our design goals are: (1)
ﬂexible isolation, from the granularity of a single address-
able document to documents hosted at multiple domains,
(2) compatibility with browsers’ isolation policy so that at-
tackers cannot violate browser security from non-browser
applications and vice versa, and (3) easy adaptation of na-
tive applications.
We present a design that achieves these goals and de-
scribe our prototype system called ServiceOS, implemented
as a reference monitor between the kernel and applications
in Windows. We demonstrate that ServiceOS is practical
by successfully adapting several large applications, such as
Microsoft Word, Outlook, and Internet Explorer, onto Ser-
viceOS with a relatively small amount of eﬀort. Our evalu-
ation shows that ServiceOS eliminates a large percentage of
existing security vulnerabilities by design and has acceptable
overhead. We also demonstrate how ServiceOS contains two
working exploits.
In the rest of this paper, we describe our threat model in
Section 2 and our system model in Section 3. We deﬁne our
system’s principals in Section 4 and show how to enforce
principal deﬁnitions in Section 5. We present ServiceOS’s
implementation in Section 6, and evaluate ServiceOS and
the eﬀort to adapt several native applications in Section 7.
We discuss related work in Section 8 and conclude in Sec-
tion 9.
2. THREAT MODEL
The primary attacker against which our system defends
is the content owner attacker. Like the web attacker [23],
the content owner attacker controls content server(s) serving
malicious data that exploits vulnerabilities. Users may be
enticed to access such malicious content from e-mail spam,
malvertising, or phishing. The goal of ServiceOS is to min-
imize the impact of any malicious content by designing the
right isolation policy and enforcement mechanisms. Our
trusted computing base is the ServiceOS kernel.
We leave it up to content owners to consider network at-
tackers, who may compromise content integrity and conﬁ-
dentiality. A content owner who is worried about network
attackers should employ end-to-end secure channels (such as
TLS) for content transport.
We are also not concerned about attackers that target spe-
ciﬁc content owners, such as cross-site scripting or cross-site
request forgery attacks. These are fundamentally content-
speciﬁc vulnerabilities which only content owners can fun-
damentally ﬁx.
3. SYSTEM MODEL
A principal is the unit of isolation. Program execution
instances with diﬀerent principal labels are isolated in sepa-
rate isolation containers. We refer to an execution instance
with a principal label as a principal instance (PI).
In ServiceOS, each principal has its own local store. A user
may use a certain online storage service, such as Dropbox or
Google Drive. We assume that all user-downloaded content
is stored on such services. This is quickly becoming the
norm with modern OSes, with integrations of ChromeOS
and Google Drive, Windows 8 and SkyDrive, and OS X and
iCloud.
There is no sharing across principals or isolation contain-
ers (i.e., no global ﬁle systems unlike today’s desktop sys-
1168Figure 2: Execution instance as a content processing
stack.
tems) except through explicit cross-principal communication
system APIs, analogous to IPC.
We have adopted user-driven access control [40] to allow
users to share data across isolation boundaries. This is done
through authentic user actions on trusted UIs (e.g., mouse
clicks on a copy button, “save-as” button, or a ﬁle picker UI)
or gestures like drag-and-drop or Ctrl-V. User-driven ac-
cess control enables capability-based, least-privilege access,
driven by users’ natural interactions with applications and
the system. We will not discuss it further in this paper and
refer interested readers to [40].
For example, Microsoft Word would have its own local
store on ServiceOS. A user may launch Word and start
editing a new document. The document is auto-saved into
Word’s own local store. When the user wants to save the
document to her Dropbox store (across the isolation bound-
ary), the user clicks on a trusted “save as” button embed-
ded in Word. The click brings up a trusted ﬁle picker win-
dow. The user then selects Dropbox, speciﬁes the ﬁle name,
and clicks on the “save” button (also part of the trusted ﬁle
picker). The system only allows Word to write to a user-
speciﬁed Dropbox path, but not other parts of Dropbox or
other online stores, achieving least-privilege access.
ServiceOS allows a user to have a local store, such as photo
or music libraries. We label all content in the user’s local
store as the principal “local”, separate from all other princi-
pals. User-driven access control is the means for the user to
get content in or out of the local store.
4. DEFINING PRINCIPALS
An isolation policy design needs to answer two questions:
(1) how execution instances should be labeled, or what deﬁnes
a principal, (2) how remote content is fetched and dispatched
into each principal to comply with the principal deﬁnition.
This section presents our design for the former and the next
section addresses the latter.
4.1 Execution instance as a content
processing stack
Before presenting our design on labeling execution in-
stances, we ﬁrst illustrate what constitutes an execution in-
stance.
An execution instance may involve content from diﬀer-
ent owners. Figure 2 illustrates such an example: a doc-
ument is rendered by a Java editor application which runs
on a Java Virtual Machine (JVM) which in turn is a Win32
program running on Windows. The document, editor, and
JVM may belong to diﬀerent owners: e.g., the document
may belong to alice.com, editor to editor.com, and JVM
to oracle.com. Therefore, we characterize an execution in-
stance as a content-processing stack. Each layer of the stack
consists of content that is owned by some entity and that
needs to be addressable (for example, a web document is
addressable with a URL, but user input data is not address-
able). The content at a layer is consumed and processed
by the next lower layer. We refer to layers below the top
layer as content processors. For example, plug-ins in today’s
browsers are treated as content processors in our system.
We do not treat static data content as safer than active
code content or content processors, because we want to al-
low both type-safe and native applications on our system
(as is the case for most real-world client systems). Since
maliciously-crafted static data can be turned into code by
exploiting memory errors in native applications, we treat
code and data as equally-capable content.
The content-to-processor mapping (e.g., mapping al-
ice.com’s document content to the editor) can be conﬁgured
by the content owner (alice.com) or by the user. Today’s web
servers indicate content’s MIME type using the Content-
Type header in HTTP responses. Desktop applications can
use the same mechanism to convey content types. Addition-
ally, we propose a new Content-Processor HTTP header
to allow content servers to specify desired content proces-
sors by a URL or unique ID. For example, a web server
serving photo.jpg could send: