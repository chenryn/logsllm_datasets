### 2. Full Instrumentation
- **Detection and Filter Creation**: Full instrumentation detects the exploit and creates a VSEF (Vulnerability-Specific Execution Filtering) filter.
- **Hardened Binary**: The exploit fails against the hardened binary.
- **Instrumentation on Each Host**: The VSEF binary is instrumented on each host for execution.

### Figure 2: Deployment Scenario for Vulnerability-Specific Filtering
1. **Exploit Detection**: Upon receiving an exploit of a new vulnerability, the full instrumentation engine detects it and creates an appropriate filter.
2. **Filter Dissemination**: The filter is disseminated to all hosts.
3. **Binary Hardening**: Each host uses the filter to instrument and produce a hardened binary.
4. **Exploit Failure**: The hardened binary cannot be exploited by the original or polymorphic variants of the exploit.

### Application to Other Adversarial Models
Our techniques and architecture can also be applied to other adversarial models, such as host-based privilege escalation attacks. These attacks are a serious threat that previous automatic defense systems have largely ignored. Our scheme can harden known vulnerable programs against such attacks until a proper patch is available. This is especially important for legacy systems where the source code may no longer exist or be accessible, making a permanent patch unfeasible.

### Distributed Architecture for VSEF Filters
We present a distributed architecture for efficiently and securely generating, using, and sharing VSEF filters in [25].

### Related Work

#### Selective Emulation
Sidiroglou et al. proposed selective emulation as part of a reactive approach for handling software failures [33]. Their selective emulation is similar to our work in some aspects. They noted that partial instrumentation can reduce total monitoring overhead. However, their approach for defending against buffer overflow attacks requires source code to instrument the binary, as it is based on a canary like StackGuard [12]. Their instrumentation is at function call granularity, and they use heuristics to determine which function calls need to be instrumented. They leave the problem of determining more precise instrumentation open, which we solve using taint-based analysis.

#### Compiler Extensions
Rinard et al. proposed using compiler extensions to handle writes to unallocated memory, allowing a program to execute even in the presence of buffer overflow attacks [30]. These techniques aim to increase service availability but are not necessarily safe and thus inappropriate as a defense mechanism.

#### Shield
Shield [40] provides generic protection for specific vulnerabilities but uses manually generated signatures.

#### Automatically Generated Input Filters
Costa et al. propose concurrent work to automatically generate host-based input filters [11], which have greater accuracy than network-based input filters and can correctly recognize some semantically equivalent inputs. However, this approach still faces difficulties when the correct classification rule is complex, requires application state, or when the input is encrypted.

#### IntroVirt
IntroVirt [15] uses vulnerability-specific predicates to detect when a vulnerability has been exploited, but these predicates are manually generated.

#### DAKODA
DAKODA [13] provides a quantitative analysis for several exploit vectors. Their results show that network-based filters are not specific enough for many vulnerabilities, and there are vulnerabilities where the attack vector is encrypted, making host-based input filters impractical. The paper also notes that return addresses are not suitable as signatures for polymorphic worms, which are used in several existing automatic signature generation methods [27, 20, 42].

### Benefits from Active Research
We benefit directly from active research aimed at increasing the efficiency of emulation [21, 41, 2]. For example, we use Valgrind and DynamoRIO for taint-based instrumentation on Linux and Windows, respectively. Pin reports emulation speeds 3.3x faster than Valgrind and 2x faster than DynamoRIO [21].

### TaintCheck
We use TaintCheck [27] to initially discover unknown vulnerabilities. Other fine-grained dynamic bug detection tools could be used during initial filter creation, such as program shepherding [17], libsafe [4, 6], or Nethercote-Fitzhardinge bounds checking [23]. We chose TaintCheck because the taint-based approach detects the widest variety of attacks and is easy to augment to produce the taint log needed for taint-based VSEF.

### Slicing Techniques
Slicing techniques [38, 43] can be used to help create or refine VSEF filters, as discussed in Section 3.3. We plan to investigate this approach in the future.

### Conclusion
We propose VSEF, a new type of filter that recognizes and filters out execution patterns of exploits exercising known vulnerabilities. VSEF is more accurate than input filtering and significantly faster than full execution monitoring. We provide two types of VSEF filters: taint-based VSEF and destination-based VSEF. The former is more accurate, while the latter may require less instrumentation. We show how to automatically create both filters using a VSEF Filter Generator. The filters can then be used to automatically harden a binary against the vulnerability via the VSEF Binary Instrumentation Engine. We provide an implementation for both components under Windows and Linux and run experiments that confirm the accuracy, performance, and generation speed. In most cases, the overhead of VSEF binary hardening is only a few percent.

### Acknowledgments
We would like to thank Jad Chamcham for implementing TaintCheck on DynamoRIO [10]; Xeno Kovah for help running experiments; Drew Bernat for feedback and assistance with using Dyninst; Timothy Wong; Emery Berger; and the anonymous reviewers for their insightful feedback.

### References
[References remain unchanged]