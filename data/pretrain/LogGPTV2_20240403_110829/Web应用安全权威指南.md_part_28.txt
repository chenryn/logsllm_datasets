-   伪造响应消息体
而针对 HTTP 消息头注入漏洞实施的攻击就叫作 HTTP 消息头注入攻击。
响应头中的换行符有特殊意义，如果在输出过程中没有对外界指定的换行符进行处理，就会导致
HTTP 消息头注入漏洞产生。
Web 应用中若存在 HTTP 消息头注入漏洞，就会造成如下影响。
-   生成任意 Cookie
-   重定向至任意 URL
-   更改页面显示内容
-   执行任意 JavaScript 而造成与 XSS 同样的损害
为了防范 HTTP 消息头注入漏洞，建议不要手动生成 HTTP
消息头的输出部分，而是利用专门用于输出消息头的程序库或
API。并且还要校验组成响应消息头的字符串中是否包含换行符，如果有换行符就报错并终止处理。
**HTTP 消息头注入漏洞总览**
![{%}](Image00109.jpg)
#### **攻击手段与影响**
接下来就让我们来看一下针对 HTTP
消息头注入漏洞的攻击手段及其影响。这里我们以执行重定向处理的 Perl
脚本为例进行说明。之所以用 Perl，是因为 PHP 实施了一些 HTTP
消息头注入的防范策略，很难用一个简单的例子将漏洞重现。但是，使用 PHP
同样会遭受 HTTP 消息头注入攻击，相关信息及防范策略将在本节的最后介绍。
以下 CGI 脚本的作用为接收查询字符串中 `url` 的值，并重定向至 `url`
所指定的 URL。这里还针对 URL 实施了与前面介绍的"失败例
3"同样的域名校验。
> **代码清单 /47/47-020.cgi**
``` 代码无行号
#!/usr/bin/perl
use utf8;        # 指定 Perl 源码的字符编码为 UTF-8
use strict;      # 指定严格的变量定义方式
use CGI qw/-no_xhtml :standard/;     # 使用 CGI 模块
my $cgi = new CGI;
my $url = $cgi->param('url');   # 取得查询字符串 url
# 通过前方一致校验 URL 来防范自由重定向（不充分的防范策略）
if ($url =~ /^http:\/\/example\.jp\//) {
  print "Location: $url\n\n";
  exit 0;
}
## URL 不正确时的错误消息
print 
Bad URL
END_OF_HTML
```
正常情况下的画面跳转如下图所示。
![{%}](Image00110.jpg)
**图 4-63 示例画面跳转**
-   **重定向至外部域名**
    下面我们使用以下 URL 执行此 CGI 脚本，首先请启动 Fiddler。这个 URL
    很长，不想手动输入的话也可以从
    的菜单中点击"4.47-020:CGI 重定向（跳转至恶意网站）"链接。
        http://example.jp/47/47-020.cgi?url=http://example.jp/%0D%0ALocation:+http://trap.example.com/47/47-900.php
    这样执行之后，浏览器就会跳转到恶意网站。请注意看地址栏。
    ![{%}](Image00111.jpg)
    **图 4-64 恶意网页**
    不可思议的是，明明已经对重定向的 URL
    进行了前方一致的校验，为什么还会出现这种结果呢？为了查明真相，我们来使用
    Fiddler 查看 HTTP 响应内容。
    ![{%}](Image00112.jpg)
    **图 4-65 使用 Fiddler 确认 HTTP 响应**
    如下所示，Location 消息头指向了恶意网站，而原来的 Location
    消息头却不见了。
    ``` 代码无行号
    Location: http://trap.example.com/47/47-900.php
    ```
    其实，造成这个谜题的关键为，CGI 脚本里面指定的查询字符串 `url`
    中包含了换行符（%0D%0A）。该换行符使得 CGI 脚本输出了 2 行 Location
    消息头，如下所示。
        Location: http://example.jp/
        Location: http://trap.example.com/47/47-900.php
    Apache 从 CGI 脚本中接收的消息头中如果有多个 Location 消息头，Apache
    就会只将最后的 Location
    消息头作为响应返回，因此，原来的重定向目标就会作废，而被换行符后面指定的
    URL 取而代之。
    像这样，通过在参数中插入换行符而添加新的 HTTP 响应头的攻击手段就是
    HTTP 消息头注入攻击，而招致 HTTP 消息头注入攻击的漏洞就叫 HTTP
    消息头注入漏洞。有时为了侧重攻击手法或现象，也会将其称为 CrLf
    注入攻击或 HTTP 响应截断攻击。
    > **专栏：HTTP 响应截断攻击**
    >
    > HTTP 响应截断攻击（HTTP Response Splitting
    > Attack）的攻击手段为，通过 HTTP 消息头注入生成多个 HTTP
    > 响应，使缓存服务器（代理服务器）将伪造内容进行缓存。
    >
    > HTTP/1.1
    > 能够在一次连接中发送多个请求，而且响应也会在一个连接中被返回。于是，攻击者就会在执行
    > HTTP 消息头注入攻击所使用的 HTTP 请求（第 1
    > 请求）后面，加上使服务器缓存伪造内容的 URL 所对应的 HTTP 请求（第
    > 2 请求）。
    >
    > 这时，通过对第 1 请求进行 HTTP 消息头注入攻击，在 HTTP
    > 响应消息体中插入伪造内容，缓存服务器就会将这个伪造内容误认为第 2
    > 请求的响应而将其缓存。由于此攻击能够使用伪造物来污染缓存中的内容，因此也被称为缓存污染。
    >
    > 虽然单独使用 HTTP
    > 消息头注入攻击也能达到改变页面的效果，但是那种情况下只有被攻击的用户才会受到短暂的影响。与此相对，污染缓存则可以增加受影响的用户群，并且还能够延长受影响的时间，从而使攻击的威力大增。
    >
    > HTTP 响应截断的产生原因与对策与 HTTP
    > 消息头注入相同，因此这里就不再进行详述。如果有兴趣，可以参考独立行政法人信息处理推进机构发表的《安全的
    > Web 网站构建方法》[43]{.注释编号} 的"1.7 HTTP
    > 消息头注入"中的"缓存服务器的缓存污染"。
-   **生成任意 Cookie**
    这里我们依然使用 47-020.cgi 来看看 HTTP
    消息头注入造成的其他影响。首先，使用以下 URL 启动 CGI
    脚本，或者从菜单（ ）中点击"5. 47-020:CGI
    的重定向（设置 Cookie）"链接。
    http://example.jp/47/47-020.cgi?url=http://example.jp/47/47-003.php%0D%0ASet-Cookie:+SESSID=ABCD123
    此时，HTTP 响应如下图的 Fiddler 界面所示。
    ![{%}](Image00113.jpg)
    **图 4-66 通过 Fiddler 确认 HTTP 响应**
    将图中箭头所指的地方放大，如下所示。
    ``` 代码无行号
    Set-Cookie: SESSID=ABCD123
    Location: http://example.jp/47/47-003.php
    ```
    可以看出 HTTP 消息头注入攻击中添加的 Set-Cookie
    消息头生效了。而随后的 HTTP 请求则如图 4-67 所示。
    ![{%}](Image00114.jpg)
    **图 4-67 通过 Fiddler 确认随后的 HTTP 请求**
    同样将图中箭头所指的地方放大，如下所示。可以看出前面生成的 Cookie
    确实被设置到了浏览器中。
    ``` 代码无行号
    Cookie: SESSID=ABCD123
    ```
    而一旦外界能够随意生成 Cookie 值，就能配合 4.6
    节介绍的会话固定攻击来针对用户发动伪装攻击。
-   **显示伪造页面**
    通过 HTTP
    消息头注入攻击还能够显示伪造页面。由于针对重定向处理页面的攻击不太容易实现
    [44]{.注释编号} ，因此，这里我们选择以生成 Cookie 的 CGI
    脚本为例，来示范如何显示伪造页面。
    > **代码清单 /47/47-021.cgi**
    ``` 代码无行号
    #!/usr/bin/perl
    use utf8;
    use strict;
    use CGI qw/-no_xhtml :standard/;
    use Encode qw(encode decode);
    my $cgi = new CGI;
    my $pageid = $cgi->param('pageid');
    # encode 通过 encode 函数将编码转换为 UTF-8 后输出
    print encode('UTF-8', 
    已设置 Cookie 值
    END_OF_HTML
    ```
    这段脚本中接收了名为 `pageid`
    的查询字符串，并将其原封不动地生成了名为 `PAGEID` 的 Cookie。
    首先，为了确认脚本在正常情况下的执行结果，使用以下 URL 启动脚本。
    ``` 代码无行号
    http://example.jp/47/47-021.cgi?pageid=P123
    ```
    此时 Fiddler 的界面显示如下。
    ![{%}](Image00115.jpg)
    **图 4-68 通过 Fiddler 确认 HTTP 响应**
    能看到这里生成了 PAGEID=P123 的 Cookie 值。
    下面我们就来尝试攻击该 CGI 脚本，以使其显示伪造页面。使用以下 URL
    执行脚本，如果不想手动输入，可以在 中点击"7.
    47-021:CGI 中设置 Cookie（伪造页面）"链接。
        http://example.jp/47/47-021.cgi?pageid=P%0D%0A%0D%0A
        %e2%97%8b%e2%97%8b%e9%8a%80%e8%a1%8c%e3%81%af%e7%a0%b4%e7%94%a3%e3%81%97%e3%81%be%e3%81%97%e3%81%9f
    下图即为执行后的页面显示。
    ![{%}](Image00116.jpg)
    **图 4-69 伪造画面**
    此时，HTTP 消息如下图所示。
    ![{%}](Image00117.jpg)
    **图 4-70 通过 Fiddler 确认 HTTP 响应**
    在 Set-Cookie
    消息头后面连续输出两个换行时，后面的数据就会被视为消息体。
    如果不加修饰，这里就依然能够看到原来的页面，但正如 4.3.1
    节所介绍的那样，通过 CSS 等手段是能将原来的页面隐藏的。
    另外，虽然本例中只是在页面上显示了某银行破产的谣言，但如果更进一步的话，通过制作伪造的表单来窃取个人信息的钓鱼式攻击、或通过执行
    JavaScript 来窃取 Cookie 值等都是能够实现的。换言之，HTTP
    消息头注入造成的页面被篡改，能够造成与 XSS 同样的影响。
[43]{.注释编号下} 原标题为"安全なウェブサイトの作り方"。URL
： 。
[44]{.注释编号下} CGI 脚本中一旦生成 Location 消息头，HTTP
状态码就会被自动设置成 302。而要成功显示伪造页面，就必须在 CGI
脚本中将状态码强制更改为 200，但这在现在的 Apache 中是很难做到的。
#### **安全隐患的产生原因**
HTTP
响应头信息能够以文本格式逐行定义消息头，也就是说消息头之间互相以换行符相隔。而如果攻击者恶意利用该特性，在指定重定向目标