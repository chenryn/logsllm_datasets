或
""              /* 空字符串 */
都是字符串。双引号不是字符串的一部分，它只用于限定字符串。字符常量中使用的转义字 符序列同样也可以用在字符串中。在字符串中使用\"表示双引号字符。编译时可以将多个字 符串常量连接起来，例如，下列形式:
"hello," " world"
等价于
"hello, world"
字符串常量的连接为将较长的字符串分散在若干个源文件行中提供了支持。 从技术角度看，字符串常量就是字符数组。字符串的内部表示使用一个空字符'\0'作为
串的结尾，因此。存储字符串的物理存储单元数比括在双引号中的字符数多一个。这种表示
方法也说明，C 语言对字符串的长度没有限制，但程序必须扫描完整个字符串后才能确定字符 串的长度。标准库函数 strlen(s)可以返回字符串参数 s 的长度，但长度不包括末尾的'\0'。 下面是我们设计的 strlen 函数的一个版本:
/* strlen:              return length of s */ int strlen(char s[])
{
int i;
while (s[i] != '\0')
++i;
return i;
}
标准头文件中声明了 strlen 和其它字符串函数。 我们应该搞清楚字符常量与仅包含一个字符的字符串之间的区别:'x'与"x"是不同的。
前者是一个整数，其值是字母 x 在机器字符集中对应的数值(内部表示值);后者是一个包含
一个字符(即字母 x)以及一个结束符'\0'的字符数组。
枚举常量是另外一种类型的常量。枚举是一个常量整型值的列表，例如:
enum boolean { NO, YES };
在没有显式说明的情况下，enum 类型中第一个枚举名的值为 0，第二个为 1，依此类推。如 果只指定了部分枚举名的值，那么未指定值的枚举名的值将依着最后一个指定值向后递增， 参看下面两个例子中的第二个例子:
enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t', NEWLINE = '\n', VTAB = '\v', RETURN = '\r' };
enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC };
/* FEB 的值为 2，MAR 的值为 3，依此类推 */
不同枚举中的名字必须互不相同。同一枚举中不同的名字可以具有相同的值。 枚举为建立常量值与名字之间的关联提供了一种便利的方式。相对于#define 语句来说，
它的优势在于常量值可以自动生成。尽管可以声明 enum 类型的变量，但编译器不检查这种类
型的变量中存储的值是否为该枚举的有效值。不过，枚举变量提供这种检查，因此枚举比
#define 更具优势。此外，调试程序可以以符号形式打印出枚举变量的值。
2.4 声明
所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地声明。一个声明指 定一种变量类型，后面所带的变量表可以包含一个或多个该类型的变量。例如:
int lower, upper, step; char c, 1ine[1000];
一个声明语句中的多个变量可以拆开在多个声明语句中声明。上面的两个声明语句也可以等 价地写成下列形式:
int lower; int upper; int step; char c;
cbar line[1000];
按照这种形式书写代码需要占用较多的空间，但便于向各声明语句中添加注释，也便于以后 修改。
还可以在声明的同时对变量进行初始化。在声明中，如果变量名的后面紧跟一个等号以 及一个表达式，该表达式就充当对变量进行初始化的初始化表达式。例如:
char esc = '\\'; int i = 0;
int limit = MAXLINE + 1; float eps = 1.0e•5;
如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始 执行之前进行，并且初始化表达式必须为常量表达式。每次进入函数或程序块时，显式初始 化的自动变量都将被初始化一次，其初始化表达式可以是任何表达式。默认情况下，外部变 量与静态变量将被初始化为   0。未经显式初始化的自动变量的值为未定义值(即无效值)。
任何变量的声明都可以使用 const 限定符限定。该限定符指定变量的值不能被修改。对 数组而言，const 限定符指定数组所有元素的值都不能被修改:
const double e = 2.71828182845905; const char msg[] = "warning: ";
const 限定符也可配合数组参数使用，它表明函数不能修改数组元素的值:
int strlen(const char[]);
如果试图修改 const 限定符限定的值，其结果取决于具体的实现。
2.5 算术运算符
二元算术运算符包括:+、•、*、/、%(取模运算符)。整数除法会截断结果中的小数部 分。表达式
x % y
的结果是 x 除以 y 的余数，当 x 能被 y 整除时，其值为 0。例如，如果某一年的年份能被 4 整除但不能被 100 整除，那么这一年就是闰年，此外，能被 400 整除的年份也是闰年。因此， 可以用下列语句判断闰年:
if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) printf("%d is a leap year\n", year);
else
printf("%d is not a leap year\n", year);
取模运算符%不能应用于 float 或 double 类型。在有负操作数的情况下，整数除法截 取的方向以及取模运算结果的符号取决于具体机器的实现，这和处理上溢或下溢的情况是一 样的。
二元运算符+和•具有相同的优先级，它们的优先级比运算符*、/和%的优先级低，而运 算符*、/和%的优先级又比一元运算符+和•的优先级低。算术运算符采用从左到右的结合规 则。
本章末尾的表 2•1 完整总结了所有运算符的优先级和结合律。
2.6 关系运算符与逻辑运算符
关系运算符包括下列几个运算符:
>              >= = '0' && s[i] = 'A' && c 定义了一组与字符集无关的测试和转换函数。例如， tolower(c)函数将 c 转换为小写形式(如果 c 为大写形式的话)，可以使用 tolower 替代 上述 lower 函数。类似地，测试语句
c >= '0' && c 中定义的函数。 将字符类型转换为整型时，我们需要注意一点。C 语言没有指定 char 类型的变量是无符
号变量(signed)还是带符号变量(unsigned)。当把一个 char 类型的值转换为 int 类
型的值时，其结果有没有可能为负整数?对于不同的机器，其结果也不同，这反映了不同机
器结构之间的区别。在某些机器中，如果 char 类型值的最左一位为 1，则转换为负整数(进 行"符号扩展")。而在另一些机器中，把 char 类型值转换为 int 类型时，在 char 类型值 的左边添加 0，这样导致的转换结果值总是正值。
C 语言的定义保证了机器的标准打印字符集中的字符不会是负值，因此，在表达式中这些 字符总是正值。但是，存储在字符变量中的位模式在某些机器中可能是负的，而在另一些机 器上可能是正的。为了保证程序的可移植性，如果要在 char 类型的变量中存储非字符数据， 最好指定 signed 或 unsigned 限定符。
当关系表达式(如    i>j)以及由&&、||连接的逻辑表达式的判定结果为真时，表达式的 值为 1;当判定结果为假时，表达式的值为 0。因此，对于赋值语句
d = c >= '0' && c 中定义的函数)使用双精度类型 的变量。使用 float 类型主要是为了在使用较大的数组时节省存储空间，有时也为了节省机 器执行时间(双精度算术运算特别费时)。
当表达式中包含 unsigned 类型的操作数时，转换规则要复杂一些。主要原因在于，带 符号值与无符号值之间的比较运算是与机器相关的，因为它们取决于机器中不同整数类型的 大小。例如，假定 int 类型占 16 位，long 类型占 32 位，那么，•1L  1UL，这是因为 1L 将被提升为 unslgned long 类型，因而成为一个比较大的正数。
赋值时也要进行类型转换。赋值运算符右边的值需要转换为左边变量的类型，左边变量 的类型即赋值表达式结果的类型。
前面提到过，无论是否进行符号扩展，字符型变量都将被转换为整型变量。 当把较长的整数转换为较短的整数或 char 类型时，超出的高位部分将被丢弃。因此，下
列程序段:
int              i; char c;
i = c; c = i;
执行后，c 的值将保持不变。无论是否进行符号扩展，该结论都成立。但是，如果把两个赋值 语句的次序颠倒一下，则执行后可能会丢失信息。
如果 x 是 float 类型，i 是 int 类型，那么语句 x = i 与 i = x 在执行时都要进行类 型转换。当把 float 类型转换为 int 类型时，小数部分将被截取掉;当把 double 类型转换 为 float 类型时，是进行四舍五入还是截取取决于具体的实现。
由于函数调用的参数是表达式，所以在把参数传递给函数时也可能进行类型转换。在没 有函数原型的情况下，char 与 short 类型都将被转换为 int 类型，float 类型将被转换为 double 类型。因此，即使调用函数的参数为 char 或 float 类型，我们也把函数参数声明 为 int 或 double 类型。
最后，在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类 型转换。在下列语句中，表达式将按照上述转换规则被转换为类型名指定的类型:
(类型名) 表达式 我们可以这样来理解强制类型转换的准确含义:在上述语句中，表达式首先被赋值给类型名
指定的类型的某个变量，然后再用该变量替换上述整条语句。例如，库函数 sqrt 的参数为
double 类型，如果处理不当，结果可能会无意义(sqrt 在中声明)。因此，如果
n 是整数，可以使用
sqrt((double) n)
在把 n 传递给函数 sqrt 之前先将其转换为 double 类型。注意，强制类型转换只是生成一 个指定类型的 n 的值，n 本身的值并没有改变。强制类型转换运算符与其它一元运算符具有相 同的优先级，表 2•1 对运算符优先级进行了总结。