(4) Verify the total liabilities.
(5) Prove individual liabilities.
(6) Verify individual liabilities.
Public protocol parameters. All of the protocol parameters of
ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) are fixed in the protocol, and we donâ€™t need
a trusted setup. First of all, ğ‘ and ğ‘€ğ‘ğ‘¥ğ¿ are public protocol pa-
rameters. And we need to publicly fix the height ğ» of the SMT
in ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿). Note that we only require ğ» â‰¥ âŒˆlog ğ‘âŒ‰.
Although security and privacy of a PoL can be guaranteed as long
as this condition is met, different selections of ğ» reflect different
tradeoffs. We discuss this in section 4.3.
In addition, we have a public group ğº of prime order ğ‘ â‰¥ (ğ» Â·
ğ‘ + 1) Â· ğ‘€ğ‘ğ‘¥ğ¿. Let ğ‘”1 and ğ‘”2 be fixed public generators of ğº, whose
relative discrete logarithm is unknown to anyone, i.e., no entity
has the knowledge of ğ‘¥ such that ğ‘”ğ‘¥
1 = ğ‘”2. Note that ğ‘”1 and ğ‘”2 can
be selected deterministically. In our implementation in section 6.2,
for instance, ğº is the Ristretto group for Curve25519, ğ‘”1 is the base
point in ğº, and ğ‘”2 is a point converted from the hash of ğ‘”1. Note that
although Curve25519 is an elliptic curve, we use the conventional
multiplicative notation throughout this paper for uniformity, i.e.,
ğ‘¥ğ‘”1 is written as ğ‘”ğ‘¥
1 .
Apart from ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿, the SMT height ğ», the group ğº, its two
generators ğ‘”1 and ğ‘”2, we also need to fix two strings as public
identifiers ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘ and ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘  for deterministically constructing SMT
nodes, which weâ€™ll explain in detail later.
Setup. The prover first picks a random secret ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡.
Next, P randomly maps each user to a bottom-layer leaf node
in an SMT of a fixed height ğ» and then generates the whole SMT.
An example of a summation SMT of height 3 containing 2 users is
depicted in fig. 2. There are three types of nodes:
â€¢ Leaf nodes, denoted by green dashed blocks in fig. 2, are
bottom-layer tree nodes mapped to users. Note that this is
different from the conventional definition of leaf nodes that
have no child nodes and can be in any layer of a tree. Each
leaf node contains a Pedersen commitment to Pâ€™s liabilities
to the corresponding user, i.e., ğ‘ğ‘¢ = ğ¶ğ‘œğ‘š(ğ‘™ğ‘¢, ğ‘ğ‘¢) = ğ‘”ğ‘™ğ‘¢1 Â· ğ‘”ğ‘ğ‘¢2
where ğ‘ğ‘¢ is the blinding factor, and a hash of the userâ€™s ID ğ‘–ğ‘‘ğ‘¢
concatenated with a mask ğ‘ ğ‘¢, i.e., â„ğ‘¢ = H(â€œğ‘™ğ‘’ğ‘ğ‘“ â€||ğ‘–ğ‘‘ğ‘¢||ğ‘ ğ‘¢).
Note that the uniqueness of â„ğ‘¢ is guaranteed by the unique-
ness of usersâ€™ IDs (in practice we can use usersâ€™ credential
information such as phone number or email address), which
is also key to a valid data set. Therefore, a malicious prover
cannot map two users with the same ğ‘™ğ‘¢ to the same leaf node
to claim smaller liabilities without being detected.
Both ğ‘ğ‘¢ and ğ‘ ğ‘¢ should be hard to guess for privacy concerns.
If a non-corrupted user ğ‘¢ happens to be mapped to the sibling
node of a corrupted user, A might receive (ğ‘ğ‘¢, â„ğ‘¢) as a part
of the inclusion proof of the corrupted user. In this case, if
ğ‘ğ‘¢ can be easily guessed, A can infer ğ‘™ğ‘¢ from ğ‘ğ‘¢ by looking
1 for all ğ‘¥ âˆˆ [0, ğ‘€ğ‘ğ‘¥ğ¿). Similarly, if ğ‘ ğ‘¢ can
up the table of ğ‘”ğ‘¥
be guessed, A can infer whether the bottom-layer node in
a Merkle proof is a leaf node corresponding to a user or a
padding node by brute forcing all possible IDs due to their
low entropy. This gives the adversary additional information
about the number of users.
We want to extract ğ‘ğ‘¢ and ğ‘ ğ‘¢ deterministically from ğ‘¤ğ‘¢ =
ğ¾ğ·ğ¹(ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡, ğ‘–ğ‘‘ğ‘¢), which is the seed deterministi-
cally extracted by a key derivation function (KDF) taking Pâ€™s
secret ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡ and ğ‘–ğ‘‘ğ‘¢ as inputs. This is to allow P to
reproduce the contents in leaf nodes with minimized stor-
age, i.e., ğ·ğµ together with Pâ€™s ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡. The property
of having a minimized data base can be beneficial in terms
of the data transferred when an external auditor initiates
a full investigation requiring P to send everything to the
auditor. We also want to extract ğ‘ğ‘¢ and ğ‘ ğ‘¢ independently, i.e.,
knowledge of either doesnâ€™t help learn the other, for selective
information disclosure, which we explain in section 4.4.5.
Therefore, we extract them via ğ‘ğ‘¢ = ğ¾ğ·ğ¹(ğ‘¤ğ‘¢, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘) and
ğ‘ ğ‘¢ = ğ¾ğ·ğ¹(ğ‘¤ğ‘¢, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘ ) respectively, where ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘ and ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘ 
are two public identifiers in the protocol.
â€¢ Padding nodes, denoted by gray dotted blocks, are nodes
that have no child nodes in the tree apart from leaf nodes
mapped to users. Padding nodes do not contribute to the
total liabilities but are dummy nodes guaranteeing that each
node in the tree has either two child nodes or none, al-
lowing generation of Merkle proofs for leaf nodes. Each
padding node contains a Pedersen commitment to 0, i.e.,
ğ‘ğ‘– = ğ¶ğ‘œğ‘š(0, ğ‘ğ‘–) = ğ‘”ğ‘ğ‘–2 , and a hash of the node index con-
catenated with a mask ğ‘ ğ‘–, i.e., â„ğ‘– = H(â€œğ‘ğ‘ğ‘‘â€||ğ‘–ğ‘‘ğ‘¥ğ‘–||ğ‘ ğ‘–). The
extraction of ğ‘ğ‘– and ğ‘ ğ‘– is the same as that for leaf nodes, i.e.,
ğ‘ğ‘– = ğ¾ğ·ğ¹(ğ‘¤ğ‘–, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘) and ğ‘ ğ‘– = ğ¾ğ·ğ¹(ğ‘¤ğ‘–, ğ‘ ğ‘ğ‘™ğ‘¡_ğ‘ ), where ğ‘¤ğ‘– is
extracted from Pâ€™s ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡ and the node index ğ‘–ğ‘‘ğ‘¥ğ‘–
by ğ‘¤ğ‘– = ğ¾ğ·ğ¹(ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡, ğ‘–ğ‘‘ğ‘¥ğ‘–). The prefix â€œğ‘ğ‘ğ‘‘â€ of the
preimage of ğ‘¤ğ‘– can be used to prove padding nodes for ran-
dom sampling, which we discuss in section 4.4.5. Note that
the seed ğ‘¤ğ‘– for each padding node should be kept secret to P,
otherwise an adversary can distinguish between a padding
node and a node of another type via the hash, which leaks
information about the number of users.
â€¢ Internal nodes, denoted by yellow solid blocks, are the tree
nodes that have two child nodes. Each internal node contains
the multiplication of the commitments in its child nodes, i.e.,
ğ‘ğ‘– = ğ‘ğ‘™ğ‘â„ğ‘– Â· ğ‘ğ‘Ÿğ‘â„ğ‘–
, and a hash of commitments and hashes in
its child nodes, i.e., â„ğ‘– = H(ğ‘ğ‘™ğ‘â„ğ‘– ||ğ‘ğ‘Ÿğ‘â„ğ‘– ||â„ğ‘™ğ‘â„ğ‘– ||â„ğ‘Ÿğ‘â„ğ‘–), where
ğ‘™ğ‘â„ğ‘– and ğ‘Ÿğ‘â„ğ‘– denote the left and right child nodes of ğ‘– re-
spectively. The Merkle root is an internal node.
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3471The SMT can be generated layer by layer starting from the bot-
tom (at height ğ»). Initially the SMT only contains leaf nodes in its
bottom layer. We insert a padding node whenever the sibling of a
leaf node, i.e., having the same parent as the leaf node, doesnâ€™t exist
in the SMT. Then we insert an internal node as a parent for each
pair of existing sibling nodes in the bottom layer. Next we move
to the layer above, inserting padding nodes as siblings to existing
nodes in this layer and internal nodes as parents in the upper layer.
We repeat the step above until we reach to the root (at height 0).
The complexity of this procedure is linear in the number of nodes
in the SMT, depending on the number of users and the tree height.
In the function (ğ‘ƒğ·, ğ‘†ğ·) $â† Setup(1ğœ…, ğ·ğµ), ğ‘ƒğ· is the commit-
ment and hash pair of the Merkle root, i.e., ğ‘ƒğ· = (ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ , â„ğ‘Ÿğ‘œğ‘œğ‘¡).
In fig. 2, e.g., ğ‘ƒğ· = (ğ‘11, â„11). On the other hand, ğ‘†ğ· includes
ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡ and the mapping from users to bottom-layer leaf
nodes in the SMT. Apart from that, the SMT could also be part of
ğ‘†ğ· but this is not necessary. Although storing the whole SMT al-
lows faster generation of inclusion proofs later in response to usersâ€™
queries, the prover can reproduce the same SMT deterministically
from ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡, ğ·ğµ and the mapping only. We discuss the pos-
sibility of having ğ‘†ğ· = ğ‘šğ‘ğ‘ ğ‘¡ğ‘’ğ‘Ÿ_ğ‘ ğ‘’ğ‘ğ‘Ÿğ‘’ğ‘¡ via deterministic mapping
in section 4.3.
Prove total liabilities. To prove the total liabilities, P simply re-
veals the blinding factor in the Merkle root. By the homomor-
phism of Pedersen commitments, for any ğ‘1 = ğ¶ğ‘œğ‘š(ğ‘™1, ğ‘1) and
ğ‘2 = ğ¶ğ‘œğ‘š(ğ‘™2, ğ‘2), we know ğ‘ = ğ‘1 Â· ğ‘2 = ğ¶ğ‘œğ‘š(ğ‘™1 + ğ‘™2, ğ‘1 + ğ‘2).
In the function (ğ¿, Î ) â† ProveTot(ğ·ğµ, ğ‘†ğ·), ğ¿ is Pâ€™s total liabili-
Therefore, ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ = ğ¶ğ‘œğ‘š(ğ‘¢âˆˆU ğ‘™ğ‘¢,ğ‘¢âˆˆU ğ‘ğ‘¢ +padding node ğ‘– ğ‘ğ‘–).
ties to users, i.e., ğ¿ =ğ‘¢âˆˆU ğ‘™ğ‘¢, and Î  is the sum of blinding factors
in all leaf and padding nodes, i.e., Î  =ğ‘¢âˆˆU ğ‘ğ‘¢ +padding node ğ‘– ğ‘ğ‘–.
Verify total liabilities. To verify the total liabilities, anyone re-
ceiving the proof can act as a verifier and check if ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ committed
on the PBB is a Pedersen commitment to the total liabilities.
1 Â· ğ‘”Î 
In the function {0, 1} â† VerifyTot(ğ‘ƒğ·, ğ¿, Î ), if ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ = ğ‘”ğ¿
2
(note that ğ‘ƒğ· = (ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ , â„ğ‘Ÿğ‘œğ‘œğ‘¡)), the function returns 1. Otherwise it
returns 0.
Prove individual liabilities. To query for the inclusion proof of ğ‘™,
a user can establish a secure communication channel with P and
prove his/her identity with respect to ğ‘–ğ‘‘. The implementation of the
authentication is out of the scope of this paper so we donâ€™t go into
details. P ignores the query when the authentication fails. Thus, a
bounded adversary has no access to proofs of non-corrupted users
but only to corrupted users.
Upon receiving an authenticated query, P locates the leaf node
mapped to the user, and retrieves the Merkle path {(ğ‘ğ‘–, â„ğ‘–)}ğ‘–âˆˆ[1,ğ»],
where (ğ‘ğ‘–, â„ğ‘–) is the commitment and hash pair in the sibling of
the node at height ğ‘– on the path from the userâ€™s leaf node to the
root. The Merkle path proves the inclusion of the leaf node in
the SMT, but when multiplying the commitments along the path,
there might be an overflow, i.e.,the sum of two values exceeds the
group order ğ‘ â‰¥ (ğ» Â· ğ‘ + 1) Â· ğ‘€ğ‘ğ‘¥ğ¿ , so ğ‘ğ‘Ÿğ‘œğ‘œğ‘¡ might commit to
a smaller value. Therefore, we need to prove each ğ‘ğ‘– commits to
a value within the range [0, ğ‘ Â· ğ‘€ğ‘ğ‘¥ğ¿). In particular, we adopt
Bulletproofs [11] which enables aggregation of zero-knowledge
range proofs for multiple values efficiently and succinctly. Addi-
tionally, non-interactive Bulletproofs via the Fiat-Shamir transform
is proved to be secure [17, 35]. Overall, the inclusion proof of in-
dividual liabilities consists of the userâ€™s blinding factor ğ‘, his/her
mask ğ‘ , a Merkle path in the summation tree and aggregated range
proofs for commitments on the path.
In the function ğœ‹ â† Prove(ğ·ğµ, ğ‘†ğ·, ğ‘–ğ‘‘), the prover generates
ğœ‹ = (ğ‘, ğ‘ , {(ğ‘ğ‘–, â„ğ‘–)}ğ‘–âˆˆ[1,ğ»], ğœ‹ğ‘Ÿğ‘ğ‘›ğ‘”ğ‘’), where (ğ‘ğ‘–, â„ğ‘–) is the commit-
ment and hash pair in the node at height ğ‘– on the Merkle path, and
ğœ‹ğ‘Ÿğ‘ğ‘›ğ‘”ğ‘’ is a zero-knowledge proof that each ğ‘ğ‘– on the Merkle path
commits to a value within range [0, ğ‘ Â· ğ‘€ğ‘ğ‘¥ğ¿).
Verify individual liabilities. To verify Pâ€™s individual liabilities
to a user, he/she first verifies the Merkle path, i.e., computing the
internal nodes on the path from the leaf node to the root and
checking if the root matches with ğ‘ƒğ· committed on the PBB. The
user also verifies the range proofs to make sure each commitment
on the Merkle path commits to a value within the proper range.
In the function {0, 1} â† Verify(ğ‘ƒğ·, ğ‘–ğ‘‘, ğ‘™, ğœ‹), the verifier com-
putes (ğ‘â€²
ğ» = H(â€œğ‘™ğ‘’ğ‘ğ‘“ â€||ğ‘–ğ‘‘||ğ‘ )) which is the con-
tent in the leaf node. Then the verifier computes ğ‘â€²
ğ‘–+1 Â· ğ‘ğ‘–+1
with ğ‘– iterating from ğ» âˆ’ 1 to 0, where ğ‘ğ‘– is contained in ğœ‹. And
similarly for â„â€²
0) = ğ‘ƒğ· and the range
proofs in ğœ‹ are valid, the function returns 1. Otherwise it returns 0.
ğ‘– in the internal nodes. If (ğ‘â€²
ğ» = Com(ğ‘™, ğ‘), â„â€²
ğ‘– = ğ‘â€²
0, â„â€²
We claim that the following security and privacy properties hold
for ProtDAPOL+ under the discrete logarithm (DL) assumption in
the random oracle model and the algebraic group model [30]. We
provide detailed proofs in appendix E.
Theorem 4.1. ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) is secure.
Theorem 4.2. ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) is Î¦user-private, where
Î¦user = âˆ….
Theorem 4.3. ProtDAPOL+(ğ‘ , ğ‘€ğ‘ğ‘¥ğ¿) is Î¦auditor-private, where
Î¦auditor = âˆ….
Note that Î¦user/auditor = âˆ… indicates that DAPOL+ provides the
strongest privacy not leaking any additional information.
4.2 Dispute Resolution
When P misbehaves, e.g., fails to respond to a user with a valid
inclusion proof, the user should be able to raise a dispute with
evidence. We divide this into two subtasks: 1. dispute resolution
for PoL assuming agreement on individual liabilities; 2. dispute
resolution for disagreement on individual liabilities. Note that the
former task makes a prerequisite assumption that P agrees with
each user on ğ‘™ğ‘¢ in ğ·ğµ. To achieve this, users may obtain a proof
of the value of ğ‘™ğ‘¢ from P. The form of the proof varies across
applications, e.g., a receipt for each transaction in the solvency case,
or a donation certificate in the charity fund raising case. The proof
could also be Pâ€™s digital signature on ğ‘™ğ‘¢.
For the former task, an invalid proof issued by P can be a con-
crete evidence in a dispute. The only exception is when the proof
is not available. Data availability is a hard task [12] because the
case of P not sending the proof is indistinguishable with the case
when a user raises a false alarm. This is inevitable in any centralized
system. A probabilistic workaround is to have a third party auditor
Session 12D: Decentralized Cryptographic Protocols CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea3472to query proofs on usersâ€™ behalf when there is suspicion, which
however, enables the auditor to lower bound the number of users.
The latter task depends on the specific application where PoL
is used. It remains as an open problem for many applications [22].
We take the solvency case as an example and empirically analyze
all possible scenarios of dispute resolution in appendix F.
4.3 Accumulator Variants
In the main protocol of DAPOL+, we utilize an SMT as an accumu-
lator and randomly map users to a bottom-layer node in the tree.
In this section, we explore four accumulator variants that can be
plugged into DAPOL+. Without sacrificing the security and privacy
of DAPOL+, each variant may provide additional features desired
in some applications, as summarized in table 2.
Table 2: Comparison between accumulator variants.