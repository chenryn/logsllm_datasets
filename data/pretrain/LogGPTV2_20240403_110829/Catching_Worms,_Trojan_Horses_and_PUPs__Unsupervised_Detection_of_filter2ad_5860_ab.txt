ti,j) ≤ ∆t ∀i ∈ U(cid:48)
(1)
(2)
The above equations state that a star contains at least 2 left
hand nodes and the time difference between the addition of
the ﬁrst and the last edge to the star is at most ∆t.
A lockstep [U(cid:48), V (cid:48), ∆t, δt] in G(U, V, E) satisﬁes the fol-
lowing constraints:
| U(cid:48) |> 2
∃V
(cid:48)
i ⊆ V (cid:48) ∀i s.t.
(cid:48)
| V
i |> 2 and | V
(i, j) ∈ E ∀i ∈ U(cid:48), j ∈ V
(cid:48)
i
(cid:48)
i |≥ α | V (cid:48) |
(3)
(4)
(5)
The above equations specify that a lockstep contains more than
2 nodes each from U and V and that the subgraph induced
by these nodes is nearly complete. If α = 1.0, this subgraph
is a complete biclique, while for any value αmin ≤ α  pairs: , , , , . Table I summarizes our data after this ﬁltering
step.
Non-goals. We do not aim to detect all possible malware
delivery vectors, e.g. download instructions hardcoded into
B. Ground Truth Data
4We cannot estimate the false negative rate because we lack ground truth
about malware delivery campaigns. An undetected malicious downloader may
be either a false negative or a dropper not controlled remotely.
While ground truth for malware delivery campaigns is cur-
rently unavailable, we collect ground truth about executables
from multiple sources.
4
MINIBAR- MASTER,EXEBI_RUN ONCE.EXEAt t = [0, ∆t]bigspeedpro.comAt t = [3δt, ∆t + 3δt]At t = [6δt,∆t + 6δt]bispd.comLockstepDetectedBISEHUP 35464.EXE2013-01-062013-01-242013-01-13payloadsTrojan.generic (mal) Smote Ltd. (ppi) YellowSoft Inc (pup) DealPly  Technologies Ltd. (pup) betwikx (pup) …16 PUP / 1 MalwareMINIBAR- MASTER,EXEBI_RUN ONCE.EXEBISEHUP 35464.EXEMINIBAR- MASTER,EXEBI_RUN ONCE.EXEBISEHUP 35464.EXEbigspeedpro.comcloudfront.netbispd.combigspeedpro.comVirusTotal. VirusTotal5 provides ﬁle scan reports for up to
54 anti-virus (AV) products. We query VirusTotal for the hash
of each downloader and payload in our data set to obtain its
ﬁrst-seen timestamp, the number of AV products that ﬂagged
it as malicious, the AV detection names assigned to it, the
total number of AV products utilized for scanning, and the
corresponding ﬁle signatures. We were able to retrieve reports
for about 17% of the binaries from 2013. In line with prior
work [23], [26], we set a threshold rmal ≥30% and we ﬂag
the ﬁles that meet the condition.
This process selects both malware and potentially unwanted
programs (PUPs). To further separate them, we search the
AV labels given to these samples for the following key-
words: “adware”, “not-a-virus”, “not malicious”, “potentially”,
“unwanted”, “pup”, “pua”, “riskware”, “toolbar”, “grayware”,
“unwnt”, and “adload” [23]. We deﬁne rpup to be the percent-
age of AV labels that include one of these keywords. We con-
sider that a binary is malware if rmal ≥30% and rpup ≤10%.
It is treated as PUP if rpup >10% and rmal ≥30%. We identify
1,228 malware samples and 15,350 PUPs through this process.
National Software Reference Library. NSRL6 provides a
reference data set (RDS) of benign software. We collect the
MD5 signatures of the applications and their list of publishers.
The version of the RDS we use is at 2.52, which was released
in April 2015. We consider benign all the executables where
either (1) the hash matches or (2) the publisher matches and
has a valid signature.
Information about publishers. To identify publishers engaged
in the Pay-Per-Install (PPI) business [8], we utilize two lists of
PPI providers from underground forums.78 For other types of
publishers, we query the Reason Labs knowledge base.9 This
service provides details about the publisher, e.g. whether it is
considered safe or if it uses its certiﬁcates to sign PUPs.
IV. DETECTING LOCKSTEP BEHAVIORS IN REAL-TIME
In this section, we describe the design and implementation
of Beewolf, which detects lockstep behavior in real-time.
Beewolf can operate in two modes. In ofﬂine mode, our system
analyzes our entire download events, with the aim of charac-
terizing lockstep behaviors empirically. We utilize this mode in
our experiments from Sections V and VI. In streaming mode,
Beewolf receives data incrementally and prunes the locksteps
detected to focus on suspicious downloaders and domains. We
evaluate this mode in Section VII. We implement Beewolf in
Python, using the NetworkX10 package to manipulate graphs.
As illustrated in Figure 2, Beewolf consists of a data
analysis pipeline with four components: star detection, galaxy
graph construction, frequent pattern (FP) tree construction, and
lockstep detection. We also maintain a database with three
tables: download_events, stars, and locksteps. The
ﬁrst step is to detect new star patterns as new download
5https://www.virustotal.com/
6http://www.nsrl.nist.gov/
7http://ppitalk.com/showthread.php/38-List-of-Pay-Per-Install-Companies
8http://www.blackhatworld.com/seo/list-of-pay-per-install-ppi-networks.
646987/
9https://www.reasoncoresecurity.com/knowledgebase.aspx
10https://networkx.github.io/
events are recorded. In the rest of the paper, we refer to
the bipartite graph as “galaxy graph”. The stars detected are
updated incrementally in the galaxy graph. Further, we traverse
the galaxy graph to build the FP tree which is an in-memory
data structure to detect locksteps. The algorithm pseudocode
of Beewolf is presented in the full version of the paper11.
A. Whitelisting
As discussed in section III-B, we identify benign binaries
using the NSRL data. We maintain a whitelist, which consists
of these benign binaries. Prior to the main data analysis
pipeline, we ﬁlter out the download events generated by the
benign downloaders, which are listed in the whitelist. We do
not expect this whitelist to be exhaustive—NSRL may not in-
clude all the legitimate downloaders—but this simple ﬁltering
step helps us focus on the most suspicious campaigns and
improves Beewolf’s performance. Moreover, while it is likely
unfeasible to whitelist all benign software, only a few programs
have a downloader functionality. Our whitelist contains 6,996
downloaders.
B. Star Detection
Each row of the download_events table consists of
a downloader (dlr), corresponding domain accessed (dom),
the downloaded ﬁle (payload), and the timestamp when the
download event occurred. We assign a unique identiﬁer to each