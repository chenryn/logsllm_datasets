the shares are indeed those ﬁxed in the ﬁrst phase.
Let αi ∈ Z∗
Such a mechanism guarantees that each PKG cannot make
use of others’ shares in order to cheat and has to determine
its shares independently. Furthermore, Step (5(a)ii) guaran-
tees that each ({Ei,j)}n
j=1, Ei) for i ∈ {1, . . . , n} are honestly
generated according to the LSSS (M, ρ), i.e. in Step (2b) Pi
honestly produces ({Ei,j)}n
j=1, Ei) according to the LSSS
(M, ρ). Step (6) guarantees that each Pi honestly executed
Step (4b) and each si,j (1 ≤ i (cid:54)= j ≤ n) has been veriﬁed and
endorsed by Pj such that MKVerify(CMPK, Ei,j, si,j) = 1
holds. 8
p be the secret chosen by Pi such that Ei =
Fp(αi, CMPK). Steps 3 and 6 imply that each Pi has hon-
estly generated and distributed secret share si,j = fs(αi,j,
CMPK) to Pj, for all j ∈ {1, . . . , n}\{i}, where (αi,1, . . . , αi,n)
are the secret shares of αi according to (M, ρ).
At the end of the setup protocol, a system master public key
i=1 αi,
CMPK). While the system master public key mpksys can be
i=1 Ei, the
mpksys := (cid:0)E, CMPK(cid:1) is output, where E = Fp((cid:80)n
obtained by anyone through computing E ←(cid:78)n
corresponding system master secret key msksys =(cid:0)fs((cid:80)n
CMPK)(cid:1) can be obtained only when an authorized set of
of fs((cid:80)n
col, the value of fs((cid:80)n
tion process, the value of fs((cid:80)n
protocol, each PKG Pj (j ∈ {1, . . . , n}) holds (cid:0)mpk(j) :=
(E(j), CMPK), msk(j) := (s(j))(cid:1) as its (master public key,
PKGs cooperate, and no individual PKG knows the value
In fact, during the setup proto-
i=1 αi, CMPK) never appears on any
entity. Furthermore, during the user private key genera-
i=1 αi, CMPK) does not need
In particular, at the end of the setup
i=1 αi, CMPK).
to appear either.
master secret key) pair, and during the user private key gen-
eration process, each Pj (chosen by the user) only needs to
8It
is worth noting that Pj does not endorse that
MKVerify(CMPK, Ej,j, sj,j) = 1 holds, since sj,j was pro-
duced by Pj itself.
i=1 αi,
run the underlying KeyGen algorithm using its(cid:0)mpk(j), msk(j)(cid:1).
While the validity of mpk(j) can be checked at the end of the
setup protocol, the validity of the corresponding msk(j) can
be checked when msk(j) is ‘used’ in the reconstruction of the
system master secret key or in the user private key genera-
tion process. Below we show that the protocol satisﬁes the
following properties.
C1. If a PKG dishonestly provided its secret share in the
reconstruction of the system master secret key, or used
invalid master secret key in the user private key gen-
eration process, it will be detected immediately.
In the reconstruction of the system master secret key,
suppose a PKG Pj provided its share s(j), the validity
can be veriﬁed by checking if MKVerify(CMPK, E(j),
s(j)) = 1 holds. Pj is suspected to be dishonest if the
equation fails to hold.
In the user private key generation process, whether
an involved PKG Pj is using a valid master secret key
msk(j) (generated by honestly executing Step (7b)) can
be checked using SKVerify() algorithm (cf. Step (1c)
of KeyGen).
C2. Any authorized set of PKGs can recover the system
master secret key fs((cid:80)n
i=1 αi, CMPK).
Without loss of generality, suppose that PKGs {P1, . . . ,
Pt} is a minimum authorized set and provide their
shares {s(j)}t
j=1. Note that the validity of s(j) can
be checked using the MKVerify() algorithm, each PKG
will honestly provide its s(j). Let
j=1 ← F indLsssConst(A, (M, ρ),{P1, . . . , Pt}).
{wj}t
Then the system master secret key can be obtained
by computing
t(cid:77)
t(cid:88)
n(cid:88)
αi,j , CMPK)⊕wj
t(cid:88)
αi,j ), CMPK) = fs(
(s(j))⊕wj =
wj αi,j , CMPK)
t(cid:77)
n(cid:88)
n(cid:88)
n(cid:88)
=fs(
wj (
fs(
i=1
j=1
j=1
j=1
i=1
j=1
i=1
=fs(
αi, CMPK).
i=1
In addition, user private keys can be generated success-
fully when any authorized set of PKGs are available
the KeyGen process), and each involved PKG
(cf.
runs independently, without needing to cooperate with
each other, when generating user private keys.
C3. Any unauthorized set of PKGs learn nothing about the
i=1 αi, CMPK), except
system master secret key fs((cid:80)n
what is implied by E = Fp((cid:80)n
the shares(cid:8){si,j}n
say Pt. {P1, . . . , Pt−1} provide their shares(cid:8){si,j}n
If all the n PKGs run the protocol honestly, i.e., α1, . . . ,
αn are independently and randomly chosen from Z∗
p,
are generated independently
as well. Without loss of generality, suppose that PKGs
{P1, . . . , Pt−1} form an unauthorized set, and to form
(cid:9)t−1
an authorized set, they need at least one more PKG,
i=1 αi, CMPK).
(cid:9)n
j=1
i=1
i=1
j=1
and that all these shares are valid. Guaranteed by
the security of the LSSS scheme, the shares {si,j =
j=1, which were computed from {αi,j}t−1
fs(αi,j , CMPK)}t−1
j=1
219i=1
j=1
i=t.
(cid:9)t−1
i=1 αi +(cid:80)n
That is, the shares(cid:8){si,j}n
key fs((cid:80)t−1
respectively, can reveal nothing about the value of αi.
reveal nothing about
the values of {αi}n
i=1. Thus, even if P1, . . . , Pt−1 pro-
vide their values of fs(αi, CMPK) (i = 1, . . . , t − 1),
these reveal nothing about the system master secret
i=t αi, CMPK), except what is im-
plied by E, since nothing about {αi}n
i=t is revealed,
except what is implied by {Fp(αi, CMPK)}n
Consider an adversary which corrupts a set of PKGs,
for example, {P1, . . . , Pt−1}, which is not an autho-
rized set. As discussed before, each PKG has to de-
termine its secret and shares in Step 2, where they
learn nothing about other PKGs’ secrets and shares,
except the ﬁngerprints. Although P1, . . . , Pt−1 could
collude together, they could not control or aﬀect the
i=1 αi, CMPK) by ob-
serving Pt, . . . , Pn’s shares and setting their own se-
crets {αi}t−1
i=1 accordingly. The only way for them to
obtain the system master secret key is to use the shares
, which were sent by Pt, . . . , Pn to {P1,
. . . , Pt−1}, to recover {fs(αi, CMPK)}n
i=t. But due to
the security of the LSSS scheme, this is impossible.
Similarly, for any identity id ∈ {0, 1}∗, any unautho-
rized set of PKGs produce no valid user private keys
system master secret key fs((cid:80)n
(cid:8){si,j}n
(cid:1). For any identity id ∈ {0, 1}∗,
for (cid:0)mpksys, msksys
(cid:9)t−1
from CT = Encrypt(mpksys, M, id), any unauthorized
set of PKGs learn nothing about the message M .
i=t
j=1
C4. α =(cid:80)n
i=1 αi is uniformly random in Z∗
p, as required by
the underlying km-IBE.
Consider an adversary which corrupts a set of PKGs,
for example, {P1, . . . , Pt−1}, which is not an autho-
rized set. As discussed before, each PKG has to deter-
mine its secret and shares in Step 2, where they learn
nothing about others’ secrets and shares, except the
ﬁngerprints. Although P1, . . . , Pt−1 could collude to-
gether to set their values of {αi}t−1
i=1, they do not have
opportunities to observe {Pt, . . . , Pn}’s shares before
setting their {αi}t−1
i=1 will be
independent from that of {αi}n
i=t. On the other side,
at least one of Pt, . . . , Pn honestly runs the protocol,
i=t αi will be uniformly random. As a result, the
i=1, i.e. the values of {αi}t−1
so(cid:80)n
value of(cid:80)n
i=1 αi is uniformly random as well.
4.3 Efﬁciency
To show the computational eﬃciency, we give in Table 2
the number of operations of each PKG involved in our setup
protocol, where ‘Sec. Recons.’ means secret reconstruction.
5. DYNAMIC CHANGES OF PKGS
Due to practical issues, PKGs in the system may change.
New PKGs may join the system, and some PKGs may choose
to leave. Therefore, we should consider how to make our
dealerless distributed PKG IBE scheme to support dynamic
PKG changes. That is, we study how to change the policy
A (in the setup protocol) to a new policy A(cid:48), while keeping
the system master secret/public key unchanged.
Below we consider a general case that transforms a policy
A among {P1, . . . , Pn} to a new policy A(cid:48) among {P (cid:48)
n(cid:48)},
as long as a minimum authorized set of A, w.l.o.g., {P1, . . . , Pt},
are available. Note that we do not require {P1, . . . , Pt} ⊆
{P (cid:48)
n}, and all the PKGs P (cid:48)
n could be new.
1, . . . , P (cid:48)
1, . . . , P (cid:48)
1, . . . , P (cid:48)
that
Before giving the transforming protocol, we ﬁrst recall
• The system master public key is mpksys =(cid:0)Fp(α, CMPK),
CMPK(cid:1) for some α ∈ Z∗
p, and the system master se-
cret key is msksys = (fs(α, CMPK)). No one knows
the value of α or the value of fs(α, CMPK). Let E =
Fp(α, CMPK).
j=1 and {s(j)}n
• For j = 1, . . . , n, E(j) is available on the public bulletin
board, Pj holds secret s(j), and MKVerify( CMPK, E(j),
s(j)) = 1, where {E(j)}n
j=1 are the shares
of E = Fp(α, CMPK) and fs(α, CMPK), respectively,
both “generated” using the LSSS matrix (M, ρ) of pol-
icy A. To simplify the description of the later proto-
col, we let {α(j)}n
j=1 be the shares of α according to
(M, ρ), and for j = 1, . . . , n, E(j) = Fp(α(j), CMPK),
s(j) = fs(α(j), CMPK).
5.1 The Protocol for Transforming Policy A to
Policy A(cid:48)
1. Initialize.
Each P (cid:48)
i(cid:48) (i(cid:48) = 1, . . . , n(cid:48)) publishes its certiﬁed signa-
ture veriﬁcation key V Ki(cid:48) to the public bulletin board.
In addition, it generates a temporary encryption key
pair (T P Ki(cid:48) , T DKi(cid:48) ) ← EnKeyGen(λ), signs T P Ki(cid:48)
using its secret signing key SKi(cid:48) , and publishes T P Ki(cid:48)
and the corresponding signature to the public bulletin
board. Note that below each time we run the ‘deal-
erless distributed PKG setup protocol’ as a sub-route,
e.g., “run the dealerless distributed PKG setup proto-
col (Steps 2-7)”, the dealerless distributed PKG setup
protocol will implicitly use a new pid. Let (M(cid:48), ρ(cid:48)) be
the LSSS matrix of A(cid:48).
2. Generate New PKGs’ Master Public/Secret Keys
with New Policy
Now {P1, . . . , Pt} run the dealerless distributed PKG
setup protocol (Steps 2-7) with the new policy A(cid:48) to
share their {s(i)}t
n(cid:48)}
1, . . . , P (cid:48)
form their master public/secret keys for the new pol-
icy. In particular,
n(cid:48)}, and {P (cid:48)
i=1 to {P (cid:48)
1, . . . , P (cid:48)
• At Step (2a), Pi (i = 1, . . . , t) sets si ← s(i) and
Ei ← E(i), rather than choosing a random αi and
computing the corresponding si and Ei.
• At Step (2b), although Pi (i = 1, . . . , t) may not
know the value of αi corresponding to its (si, Ei)
that it sets at Step (2a), it can compute the shares
{(si,j, Ei,j)}n(cid:48)
j=1 of (si, Ei) for the new policy A(cid:48),
as we discussed previously.
• At Step (3), each ˆPˆj ∈(cid:0){P1, . . . , Pt}(cid:83){P (cid:48)
1, . . . , P (cid:48)
n(cid:48)}(cid:1)
veriﬁes the signatures on the ﬁngerprints pub-
lished by {P1, . . . , Pt} \ { ˆPˆj} at Step (2).
• At Step (4), each Pi (i = 1, . . . , t) publishes the
public shares ({Ei,j}n(cid:48)
j=1, Ei) to the public bulletin
board and distributes the secret share si,j to P (cid:48)
j
(for j = 1, . . . , n(cid:48)).
• At Step (5), each ˆPˆj ∈(cid:0){P1, . . . , Pt}(cid:83){P (cid:48)
1, . . . , P (cid:48)
n(cid:48)}(cid:1)
veriﬁes the public shares ({Ei,j}n(cid:48)
j=1, Ei), which
220Step #
Sign
Verify
Encrypt Decrypt
Sec. Recons. Hash Multiply
1
1
n − 1
n + 1
n − 1
n − 1
n2 − 1
n2 − 1
n2 + n − 2 1
n
1
2
3
4
5
6
7
1 MKVerify() is also counted as ‘Verify’.
1
(n − 1)|A−|
n − 1
n − 1
3n
Table 2: Computational Cost of the Setup Protocol
were published by Pi ∈ {P1, . . . , Pt} \ { ˆPˆj} at
Step (4).
• At Step (5(a)i), for i ∈ {1, . . . , t}, ˆPˆj (∈(cid:0){P1, . . . ,