### Optimized Text

The shares are indeed those fixed in the first phase. Let \(\alpha_i \in \mathbb{Z}_p^*\). This mechanism ensures that each PKG (Private Key Generator) cannot use others' shares to cheat and must determine its shares independently. Additionally, Step (5a)(ii) guarantees that each \(({E_{i,j}})_{j=1}^n, E_i)\) for \(i \in \{1, \ldots, n\}\) is generated honestly according to the LSSS (Linear Secret Sharing Scheme) \((M, \rho)\). In other words, in Step (2b), \(P_i\) honestly produces \(({E_{i,j}})_{j=1}^n, E_i)\) based on the LSSS \((M, \rho)\). Step (6) ensures that each \(P_i\) has honestly executed Step (4b) and that each \(s_{i,j}\) (for \(1 \leq i \neq j \leq n\)) has been verified and endorsed by \(P_j\) such that \(MKVerify(CMPK, E_{i,j}, s_{i,j}) = 1\).

Let \(p\) be the secret chosen by \(P_i\) such that \(E_i = F_p(\alpha_i, CMPK)\). Steps 3 and 6 imply that each \(P_i\) has honestly generated and distributed the secret share \(s_{i,j} = f_s(\alpha_{i,j}, CMPK)\) to \(P_j\) for all \(j \in \{1, \ldots, n\} \setminus \{i\}\), where \((\alpha_{i,1}, \ldots, \alpha_{i,n})\) are the secret shares of \(\alpha_i\) according to \((M, \rho)\).

At the end of the setup protocol, a system master public key \(mpk_{sys} := (E, CMPK)\) is output, where \(E = F_p\left(\sum_{i=1}^n \alpha_i, CMPK\right)\). While the system master public key \(mpk_{sys}\) can be obtained by anyone through computing \(E \leftarrow \prod_{i=1}^n E_i\), the corresponding system master secret key \(msk_{sys} := f_s\left(\sum_{i=1}^n \alpha_i, CMPK\right)\) can only be obtained when an authorized set of PKGs cooperates. No individual PKG knows the value of \(f_s\left(\sum_{i=1}^n \alpha_i, CMPK\right)\).

In fact, during the setup protocol, the value of \(f_s\left(\sum_{i=1}^n \alpha_i, CMPK\right)\) never appears on any entity. Furthermore, during the user private key generation process, the value of \(f_s\left(\sum_{i=1}^n \alpha_i, CMPK\right)\) does not need to appear either.

At the end of the setup protocol, each PKG \(P_j\) (for \(j \in \{1, \ldots, n\}\)) holds \((mpk^{(j)} := (E^{(j)}, CMPK), msk^{(j)} := s^{(j)})\) as its (master public key, master secret key) pair. During the user private key generation process, each \(P_j\) (chosen by the user) only needs to run the underlying KeyGen algorithm using its \((mpk^{(j)}, msk^{(j)})\).

It is worth noting that \(P_j\) does not endorse that \(MKVerify(CMPK, E_{j,j}, s_{j,j}) = 1\) holds, since \(s_{j,j}\) was produced by \(P_j\) itself.

### Properties of the Protocol

**C1. Dishonest PKG Detection:**
- **System Master Secret Key Reconstruction:** If a PKG dishonestly provides its secret share in the reconstruction of the system master secret key, or uses an invalid master secret key in the user private key generation process, it will be detected immediately. For example, if PKG \(P_j\) provides its share \(s^{(j)}\), the validity can be verified by checking if \(MKVerify(CMPK, E^{(j)}, s^{(j)}) = 1\) holds. If the equation fails, \(P_j\) is suspected of being dishonest.
- **User Private Key Generation:** Whether an involved PKG \(P_j\) is using a valid master secret key \(msk^{(j)}\) (generated by honestly executing Step (7b)) can be checked using the \(SKVerify()\) algorithm (cf. Step (1c) of KeyGen).

**C2. Recovery of the System Master Secret Key:**
- Any authorized set of PKGs can recover the system master secret key \(f_s\left(\sum_{i=1}^n \alpha_i, CMPK\right)\). Without loss of generality, suppose that PKGs \(\{P_1, \ldots, P_t\}\) form a minimum authorized set and provide their shares \(\{s^{(j)}\}_{j=1}^t\). The validity of \(s^{(j)}\) can be checked using the \(MKVerify()\) algorithm. Each PKG will honestly provide its \(s^{(j)}\). Let \(\{w_j\}_{j=1}^t \leftarrow FindLsssConst(A, (M, \rho), \{P_1, \ldots, P_t\})\). The system master secret key can be obtained by computing:
  \[
  \bigoplus_{j=1}^t s^{(j)} \oplus w_j = f_s\left(\sum_{i=1}^n \alpha_i, CMPK\right).
  \]
- User private keys can be generated successfully when any authorized set of PKGs is available (cf. the KeyGen process), and each involved PKG runs independently without needing to cooperate with each other.

**C3. Security Against Unauthorized Sets:**
- Any unauthorized set of PKGs learns nothing about the system master secret key \(f_s\left(\sum_{i=1}^n \alpha_i, CMPK\right)\), except what is implied by \(E = F_p\left(\sum_{i=1}^n \alpha_i, CMPK\right)\) and the shares \(\{s_{i,j}\}_{i=1}^n\). If all the \(n\) PKGs run the protocol honestly, i.e., \(\alpha_1, \ldots, \alpha_n\) are independently and randomly chosen from \(\mathbb{Z}_p^*\), then the shares \(\{s_{i,j} = f_s(\alpha_{i,j}, CMPK)\}_{i=1}^n\) are also generated independently. Without loss of generality, suppose that PKGs \(\{P_1, \ldots, P_{t-1}\}\) form an unauthorized set, and to form an authorized set, they need at least one more PKG, say \(P_t\). Even if \(\{P_1, \ldots, P_{t-1}\}\) provide their values of \(f_s(\alpha_i, CMPK)\) (for \(i = 1, \ldots, t-1\)), these reveal nothing about the system master secret key \(f_s\left(\sum_{i=t}^n \alpha_i, CMPK\right)\), except what is implied by \(E\).

**C4. Uniform Randomness of \(\alpha\):**
- \(\alpha = \sum_{i=1}^n \alpha_i\) is uniformly random in \(\mathbb{Z}_p^*\), as required by the underlying km-IBE (Key Management Identity-Based Encryption). Consider an adversary that corrupts a set of PKGs, for example, \(\{P_1, \ldots, P_{t-1}\}\), which is not an authorized set. As discussed before, each PKG has to determine its secret and shares in Step 2, where they learn nothing about others' secrets and shares, except the fingerprints. Although \(\{P_1, \ldots, P_{t-1}\}\) could collude together, they do not have opportunities to observe \(\{P_t, \ldots, P_n\}\)'s shares before setting their \(\{\alpha_i\}_{i=1}^{t-1}\). Therefore, \(\{\alpha_i\}_{i=1}^{t-1}\) will be independent from \(\{\alpha_i\}_{i=t}^n\). On the other side, at least one of \(\{P_t, \ldots, P_n\}\) honestly runs the protocol, so \(\sum_{i=t}^n \alpha_i\) will be uniformly random. As a result, the value of \(\sum_{i=1}^n \alpha_i\) is uniformly random as well.

### Efficiency

To show the computational efficiency, we provide in Table 2 the number of operations of each PKG involved in our setup protocol, where ‘Sec. Recons.’ means secret reconstruction.

| Step # | Sign | Verify | Encrypt | Decrypt | Sec. Recons. | Hash | Multiply |
|--------|------|--------|---------|---------|--------------|------|----------|
| 1      | 1    | n - 1  | n + 1   | n - 1   | n - 1        | n^2 - 1 | n^2 - 1  |
| 2      | 1    | (n - 1)|A-|     | n - 1       | n - 1  | 3n       |
| 3      | 1    | n - 1  | n - 1   | n - 1   | n^2 + n - 2  | 1    | n        |
| 4      | 1    | n - 1  | n - 1   | n - 1   | n^2 + n - 2  | 1    | n        |
| 5      | 1    | n - 1  | n - 1   | n - 1   | n^2 + n - 2  | 1    | n        |
| 6      | 1    | n - 1  | n - 1   | n - 1   | n^2 + n - 2  | 1    | n        |
| 7      | 1    | n - 1  | n - 1   | n - 1   | n^2 + n - 2  | 1    | n        |

### Dynamic Changes of PKGs

Due to practical issues, PKGs in the system may change. New PKGs may join the system, and some PKGs may choose to leave. Therefore, we should consider how to make our dealerless distributed PKG IBE scheme support dynamic PKG changes. Specifically, we study how to change the policy \(A\) (in the setup protocol) to a new policy \(A'\), while keeping the system master secret/public key unchanged.

Below, we consider a general case that transforms a policy \(A\) among \(\{P_1, \ldots, P_n\}\) to a new policy \(A'\) among \(\{P'_1, \ldots, P'_{n'}\}\), as long as a minimum authorized set of \(A\), w.l.o.g., \(\{P_1, \ldots, P_t\}\), are available. Note that we do not require \(\{P_1, \ldots, P_t\} \subseteq \{P'_1, \ldots, P'_{n'}\}\), and all the PKGs \(\{P'_1, \ldots, P'_{n'}\}\) could be new.

#### Transforming Policy \(A\) to Policy \(A'\)

**1. Initialize:**
- Each \(P'_{i'}\) (for \(i' = 1, \ldots, n'\)) publishes its certified signature verification key \(VK_{i'}\) to the public bulletin board. In addition, it generates a temporary encryption key pair \((TPK_{i'}, TDK_{i'}) \leftarrow EnKeyGen(\lambda)\), signs \(TPK_{i'}\) using its secret signing key \(SK_{i'}\), and publishes \(TPK_{i'}\) and the corresponding signature to the public bulletin board. Note that below each time we run the ‘dealerless distributed PKG setup protocol’ as a sub-routine, e.g., “run the dealerless distributed PKG setup protocol (Steps 2-7)”, the dealerless distributed PKG setup protocol will implicitly use a new \(pid\). Let \((M', \rho')\) be the LSSS matrix of \(A'\).

**2. Generate New PKGs’ Master Public/Secret Keys with New Policy:**
- Now \(\{P_1, \ldots, P_t\}\) run the dealerless distributed PKG setup protocol (Steps 2-7) with the new policy \(A'\) to share their \(\{s(i)\}_{i=1}^t\) to \(\{P'_1, \ldots, P'_{n'}\}\) to form their master public/secret keys for the new policy. In particular:
  - At Step (2a), \(P_i\) (for \(i = 1, \ldots, t\)) sets \(s_i \leftarrow s(i)\) and \(E_i \leftarrow E(i)\), rather than choosing a random \(\alpha_i\) and computing the corresponding \(s_i\) and \(E_i\).
  - At Step (2b), although \(P_i\) (for \(i = 1, \ldots, t\)) may not know the value of \(\alpha_i\) corresponding to its \((s_i, E_i)\) that it sets at Step (2a), it can compute the shares \(\{(s_{i,j}, E_{i,j})\}_{j=1}^{n'}\) of \((s_i, E_i)\) for the new policy \(A'\), as we discussed previously.
  - At Step (3), each \(\hat{P}_{\hat{j}} \in \{P_1, \ldots, P_t\} \cup \{P'_1, \ldots, P'_{n'}\}\) verifies the signatures on the fingerprints published by \(\{P_1, \ldots, P_t\} \setminus \{\hat{P}_{\hat{j}}\}\) at Step (2).
  - At Step (4), each \(P_i\) (for \(i = 1, \ldots, t\)) publishes the public shares \(\{E_{i,j}\}_{j=1}^{n'}\) to the public bulletin board and distributes the secret share \(s_{i,j}\) to \(P'_j\) (for \(j = 1, \ldots, n'\)).
  - At Step (5), each \(\hat{P}_{\hat{j}} \in \{P_1, \ldots, P_t\} \cup \{P'_1, \ldots, P'_{n'}\}\) verifies the public shares \(\{E_{i,j}\}_{j=1}^{n'}\), which were published by \(P_i \in \{P_1, \ldots, P_t\} \setminus \{\hat{P}_{\hat{j}}\}\) at Step (4).
  - At Step (5a)(i), for \(i \in \{1, \ldots, t\}\), \(\hat{P}_{\hat{j}}\) (for \(\hat{P}_{\hat{j}} \in \{P_1, \ldots, P_t\} \cup \{P'_1, \ldots, P'_{n'}\}\)) verifies the public shares \(\{E_{i,j}\}_{j=1}^{n'}\), which were published by \(P_i \in \{P_1, \ldots, P_t\} \setminus \{\hat{P}_{\hat{j}}\}\) at Step (4).

This completes the transformation of the policy \(A\) to \(A'\) while maintaining the security and integrity of the system.