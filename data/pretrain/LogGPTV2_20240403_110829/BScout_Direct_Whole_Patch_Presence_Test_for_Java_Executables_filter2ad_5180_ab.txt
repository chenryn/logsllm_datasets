sically, it takes the pre-patch/post-patch reference source
code (not the source code for the target executable) and
target Java executable as input, and generate two line-to-line
maps (which associate raw Java bytecode instructions to Java
source code lines) between them as output. It works by ﬁrst
extracting cross-layer features between Java source code and
Java bytecode (see details in § 3.1) and then leveraging these
features to construct a line-to-line map in the scope of the
whole Java method (see details in § 3.2).
Step 2: Patch-derived Differential Analysis. Based on
two line-to-line maps between pre-patch/post-patch source
code and target Java executable, it analyzes the ﬁne-grained
changes in the patch to guide the patch presence judgment.
Speciﬁcally, it analyzes the patch to recognize not only the
addition/deletion lines but also the modiﬁcation lines (see
details in § 3.3). Then, for each kind of patch-changed lines,
it tests the presence of them in the target by comparing
the match results between the target executable and the pre-
patch/post-patch source code (see details in § 3.4).
3.1 Feature Extractor
Obviously, it is hard to perform equivalence tests between
Java source code lines and Java bytecode instructions using
existing techniques such as theorem proving [24]. Instead,
we approximately test whether a Java source code line is the
same with several Java bytecode instructions by measuring
how many semantic features they share. To support cross-
layer line-level correlative analysis between Java source code
and Java bytecode, it is quite important to ﬁgure out what
features to extract and how to extract.
3.1.1 Feature Set
Many types of features can be extracted from Java source
code and bytecode instructions. However, not every feature is
appropriate. It should meet two properties.
• Language-independent. A selected feature should exist
in both source code and smali code. For example,
temporary variable names only exist in source code.
Thus, it is inappropriate for feature selection.
• Consistently-extracted. An appropriate feature should
be extracted consistently from both source code and
bytecode. For instance, we ﬁnd that array-creation smali
instructions are generated in method invocations with
variable-length arguments, while there are no explicit
array creations in corresponding source code. Therefore,
array-creation is not an appropriate feature.
Ideally, all the features that ﬁt the above two properties
should be utilized. Actually, we only consider a small number
of signiﬁcant features that appear in common cases (as listed
in Table 1). Future work could explore more features to get
better performance. Even so, our prototype achieves quite
good precision and recall through the evaluation (see § 4.1).
In all, we consider ﬁve categories of features: constant values,
method invocations, ﬁeld accesses, object creation and special
instruction types. Several features in Table 1 exclude some
exceptional cases. For example, for method invocation feature,
we do not consider those methods that may be generated by
compilers, because these invocations may only exist in smali
while do not explicitly exist in source code.
3.1.2 Feature Parser
For smali instructions and Java source code, we use separate
parsers.
Parsing smali Instructions. We use dexlib [7] to parse
smali ﬁles. All the information in a smali ﬁle can be accessed
with this library, such as classes, methods, instructions, and
labels. As Table 1 shows, literals are quite important features
1150    29th USENIX Security Symposium
USENIX Association
Figure 2: Architecture of BSCOUT. There are two core techniques: cross-layer line-level correlative analysis and patch-derived
differential analysis. The ﬁrst technique is capable of generating a line-to-line map between a Java source method and a Java
bytecode method by leveraging language-independent features, while the latter technique takes the line-to-line maps between
pre-patch/post-patch reference source code (not the source code for the target executable) and target Java executable as input and
utilizes the characteristics extracted from the patch itself to give a patch presence test result.
Table 1: Selected features from both Java source code and Java bytecode instructions.
Feature Category
Constant Values
Method Invocations
Field Access
Objection Creation
Special Instruction Type
Feature Format
Literals
Method name with argument length
Field name
Class name
Normalized instruction types
Values Selected
String literals, integer/long numeric literals
All methods except compiler-generated methods, such as toString, valueOf, append.
All ﬁelds
All classes except those used in compiler-generated code such as Object, StringBuilder
throw, monitor, switch, instance-of, return
in BSCOUT. In smali, literals are ﬁrst loaded into virtual
registers before they are used in smali instructions. Thus, we
can not directly acquire the literals from operand values. To
extract constant values from smali instructions, we implement
constant propagation analysis. We scan the whole method to
construct a table to keep all the virtual registers that have been
assigned with constant values and never be overwritten by
following instructions. When we want to check whether an
operand register holds a constant value, we can simply look
up its name in the table to get its pre-loaded constant value.
Parsing Java Source Code. Extracting semantic features
from Java source code is more sophisticated than from smali
instructions because Java language has complicated gram-
mar, e.g. anonymous inner classes, nested class deﬁnitions.
Meanwhile, we can neither build the source code project into
executables for feature extraction, because building a project
is not a fully-automated process which may require frequent
manual intervention. Even for projects that use package
dependency management tools such as Maven and Gradle, it
is still non-trivial to set up the building environment for them.
Therefore, we have to parse Java grammars for feature
extraction. After investigating several Java source code ana-
lyzers, we choose to build our feature extractor on Spoon [39]
which is actively maintained and supports new Java features.
It works by generating abstract syntax trees (AST) from
Java source ﬁles, so our feature extraction procedure is
implemented by traversing the ASTs. For a statement that
occupies more than one textual line in the source code (e.g.
line 13 and line 14 in Figure 1), we treat the split lines as a
single logical line.
Literals Normalization. Literals appear as variable names
(such as ﬁnal static ﬁelds) in source code, but occur as constant
values in disassembled smali code. An example is the variable
“UserHandle.USER_OWNER” in Figure 1(a) and its constant
value of “0x0” in line 2238 of Figure 1(b). To support sound
feature comparison, we need to normalize literals extracted
from Java source code. Our solution is to construct a global
constant table by parsing all Java source code ﬁles. When
we come across a variable in Java source code, we can look
up the table to test whether it is a constant variable and use
its constant value to construct features. Besides, we notice
that Java compiler will transform string literal concatenation
statements in Java source code to a concatenated string literal
in smali. To correctly match these literals, we also implement
this optimization during literal extraction from source code.
3.2 Line-to-line Match Engine
To perform line-level correlative analysis, we ﬁrst need an
oracle to test whether a source code line and several smali
instructions are equivalent. Our idea is to test how many
semantic features they share.
USENIX Association
29th USENIX Security Symposium    1151
Patch (.diff)Patch AnalyzerPatch Presence CheckerLine-to-line Map for Pre-patchLine-to-line Map for Post-patchFiltered Patch-changed LinesAddition LinesDeletion LinesModification LinesFeatureExtractorLine-to-line Match EngineTarget Java ExecutablePre-patch ReferenceSource CodePost-patchReferenceSource Code.java.smali.javaEquivalence Oracle. For convenience, we designate s and
b as two feature sets extracted from a source code line and
several bytecode instructions respectively. We use Jaccard
similarity [44] between s and b to deﬁne the equivalence
oracle as following where TLineSimilarity is a predeﬁned
threshold between 0 and 1. We do not use a more complicated
algorithm here because Jaccard similarity works well enough
through evaluation.
IsEquivalent(s,b) : Jaccard_Sim(s,b) >= TLineSimilarity
Notice that if a patch-changed line occurs multiple times in
source code, it is unreliable to simply test its presence in smali
code (see line 5 and line 7 in Figure 1 as an example). Thus,
we perform a line-to-line match in the whole method scope to
utilize code context. According to the presence of line number
information in smali, we adopt different matching algorithms.
3.2.1 When line number information is present
Modern Java compilers such as OpenJDK, Oracle JDK
and Android SDK all annotate line number information for
compiled Java code in .class/.dex ﬁles. This information may
ease the aggregation of raw smali instructions generated from
the same Java source line together. Nonetheless, it is worth
noting that when line number information is not present,
BSCOUT can also perform an effective line-to-line match,
as described in the next section.
Line Aggregation. When line number information is
present in the smali ﬁle, baksmali [15] generates a .line marker
with an integral line number at the ﬁrst smali instruction for a
source code line (see examples in Figure 1) when transform-
ing DEX ﬁles to smali ﬁles. We split raw continuous smali
instructions into blocks according to the .line marker. We
designate a .line marker along with its following instructions
as an aggregated line. In the following steps, BSCOUT will
construct a map between Java source lines and aggregated
Java bytecode lines.
After aggregating raw smali instructions into blocks ac-
cording to .line marker, we ﬁnd some exceptional cases that
need to be further puriﬁed.
• Two identical line blocks with same line number. We
ﬁnd some line blocks duplicated in the smali ﬁle. For
example, baksmali generates an identical ﬁnally block
before each return instruction in the try block. Since
there is only one ﬁnally block in the source code, we
eliminate redundant ﬁnally blocks in the smali code and
only keep one.
• Two different line blocks with same line number. We ﬁnd
that some line blocks are different but share the same
line number. This is because compilers may compile
a single Java statement into several line blocks. For
example, a single Java switch statement is compiled
into two-line blocks: one block starts with a packed-
switch/sparse-switch smali instruction that indicates
switch table address, and the other block starts with
a leading .switch marker to keep the concrete switch
implementation. For these blocks, we can simply merge
them into one block.
Line-to-line Match. With the help of aggregated line
information, precise matching can be achieved. Speciﬁcally,
we sort these aggregated lines by their line numbers to
facilitate the match process, and set three requirements to meet
for the match results: ﬁrst, each source code line should link
to at most one aggregated smali line and vice versa; second, a
source code line should not be matched to an aggregated smali
line which has a bigger line number than previous matched
smali line; third, we want to match as many source code
lines/aggregated smali lines as possible.
In fact, from the above description, we have transformed the
problem of the line-to-line match into the classical problem
of ﬁnding the longest common subsequence. We apply an
existing optimized algorithm in ﬁnding the longest common
sequence, named Myers algorithm [36, 41] (which is also
used by git-diff command) to BSCOUT to ﬁnd an optimal
match between source code lines and aggregated smali lines.
Based on the line-to-line match result, we can judge whether
a source code line is present in a Java executable.
3.2.2 When line number information is absent
When line number information is not present in executables,
it is hard to recognize the exact line boundaries in continuous
smali instructions. A straightforward idea may be searching
smali instructions for every Java source code line in the
whole method space. However, the unrestricted search space
would cause low precision and huge overhead. Fortunately,
we observe that human experts have patterns to group
raw bytecode instructions. With this insight, we ﬁrst use
machine learning to automatically group raw continuous
smali instructions into segments, and then perform matching
between source code lines and smali segments.
Learning-based Instruction Segmentation. In general,
we treat instruction segmentation as a sequence labeling
problem [37]. Speciﬁcally, we want to assign every smali
instruction with one of the four labels: S (a segment with
a single instruction), B (begin of a segment), M (middle
of a segment) and E (end of a segment). Our training
data is constructed from smali ﬁles of 23 Android ROMs
and 2,064 Maven packages. We exclude those smali ﬁles
without line number information, and the remaining can
be automatically labeled with S/B/M/E. In all, we extract
about 1 million labeled smali methods as the training set
and 10 millions of labeled smali methods as the testing
set. Our model is trained with Conditional Random Fields
(CRFs) [30] which is a common context-sensitive algorithm
for sequence labeling. More speciﬁcally, we use CRF++ [5]
1152    29th USENIX Security Symposium
USENIX Association
Figure 3: Different cases compiled to same smali code.
(an open-source implementation of CRFs) and set cost
parameter to 1 and termination criterion to 0.0001 to train the
model. Considering instructions have diverse formats, we also
normalize the smali instructions by removing the instruction
operands. Our trained model accepts raw smali instructions
as input and outputs labels for them. Based on the instruction
labels, we can easily group them into segments. Through
the testing set, our model shows an accuracy of 91.7% in
instruction labeling. As our evaluation shows (see §4), this
accuracy is good enough for our tool, so we do not try other
algorithms for model training.
Two-round Line-to-segment Match. Based on the seg-
mentation results, we ﬁrst perform a one-to-one match
between source code lines and instruction segments using
the algorithm of ﬁnding the longest common subsequence
(the same as in § 3.2.1). However, not all source code lines
can be matched with smali segments in this round due to the
existence of compound statements. We give an example in
Figure 3 to demonstrate this problem. In this ﬁgure, case
B is a compound statement of two statements in case A.
Our instruction segmentation model inclines to group the
compiled smali instructions of case B into two segments.
Therefore, the line-level similarity between the compound
source code line and either smali segment is hard to reach
the TLineSimilarity threshold. As a result, this kind of compound
statement is not matched during the ﬁrst round.
For these unmatched source code lines, we perform a
second round match. Figure 4 presents the overall design. This
round of match starts sequentially from the ﬁrst unmatched
source code line. For this unmatched source code line, we
seek matching candidates in the space of all the unmatched
smali instructions just after the previous matched smali
segment (see the matching candidate scope for the ﬁrst
unmatched line in Figure 4 as an example). Speciﬁcally,
for each source code line, we set up a sliding window (see
Figure 4) with variable-length to enumerate all possible smali
instruction sequences. We calculate the similarity between
all possible sliding windows and the source code line and
select the one that hits the highest similarity. If the similarity
between the smali instructions in the selected sliding window
and the source code line exceeds the predeﬁned threshold
(TLineSimilarity), we mark a line-to-line match for them and
eliminate the instructions in the sliding window from the
following search. Similarly, we search smali instructions for
remaining unmatched source code lines.
Figure 4: Second-round match for unmatched source code
lines with a sliding window, which enumerates all possible
matching pairs between unmatched Java source lines and
smali segments to determine the best matching.
With the techniques above, BSCOUT successfully performs
a line-to-line match based on the features extracted from Java
source code and smali instructions, regardless of the presence
of line number information. The constructed line-to-line maps
will be further utilized by BSCOUT in a patch presence test.
3.3 Patch Analyzer
This module analyzes the whole patch to guide patch presence
judgment. A patch is usually generated by diff command. As
shown in Figure 1(a), a patch usually consists of multiple
change blocks. Each block starts with a block header line,
which indicates the position of following changes occurred in
pre-patch source code and post-patch source code. From the
block header, we can accurately look up each changed line
and locate the affected method/class in the source code.
Not all changed lines in a patch should be considered in a
patch presence test. Speciﬁcally, we perform a difference
check against two kinds of changes: in-method changes
and out-of-method changes. As their names indicate, out-
of-method changes occur outside of method implementations
(e.g. declaring a new ﬁeld in a class), and in-method changes
affect the concrete method implementations. Since most
Java vulnerabilities are logic ﬂaws, they should be ﬁxed by
modifying method logic. Besides, our study on 194 real-
world security patches shows that nearly 80% of patch
changes belong to in-method changes (as presented in
Table 11 of Appendix A). Thus, we believe out-of-method
changes can be ignored in testing patch presence. Under
the assumption above, BSCOUT would fail on extreme
cases where a patch only contains out-of-method changes.