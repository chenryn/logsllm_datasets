ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, ser. POPL â€™09. New York, NY, USA: ACM, 2009, pp.
90â€“101.
[33] G. Barthe, B. GrÃ©goire, S. Heraud, and S. Z. BÃ©guelin, â€œComputer-
aided security proofs for the working cryptographer,â€ in Advances in
Cryptology - CRYPTO 2011 - 31st Annual Cryptology Conference, Santa
Barbara, CA, USA, August 14-18, 2011. Proceedings, 2011, pp. 71â€“90.
[34] J. B. Almeida, M. Barbosa, G. Barthe, F. Dupressoir, B. GrÃ©goire,
V. Laporte, and V. Pereira, â€œA fast and veriï¬ed software stack for
secure function evaluation,â€ in Proceedings of the 2017 ACM SIGSAC
Conference on Computer and Communications Security, CCS 2017,
2017, pp. 1989â€“2006.
[35] B. Li and D. Micciancio, â€œSymbolic security of garbled circuits,â€
Cryptology ePrint Archive, Report 2018/141, 2018, https://eprint.iacr.
org/2018/141.
[36] D. Beaver, S. Micali, and P. Rogaway, â€œThe round complexity
of secure protocols,â€ in Proceedings of
the Twenty-second Annual
ACM Symposium on Theory of Computing, ser. STOC â€™90. New
York, NY, USA: ACM, 1990, pp. 503â€“513.
[Online]. Available:
http://doi.acm.org/10.1145/100216.100287
[37] A. Beimel, â€œSecret-sharing schemes: A survey,â€ in Coding and Cryptol-
ogy - Third International Workshop, IWCC 2011, Qingdao, China, May
30-June 3, 2011. Proceedings, 2011, pp. 11â€“46.
[38] V. Vinod, A. Narayanan, K. Srinathan, C. P. Rangan, and K. Kim, â€œOn
the power of computational secret sharing,â€ in Progress in Cryptology
- INDOCRYPT 2003, 4th International Conference on Cryptology in
India, New Delhi, India, December 8-10, 2003, Proceedings, 2003, pp.
162â€“176.
[39] B. Li and D. Micciancio, â€œEquational security proofs of oblivious
transfer protocols,â€ in Public-Key Cryptography - PKC 2018 - 21st
IACR International Conference on Practice and Theory of Public-Key
Cryptography, Rio de Janeiro, Brazil, March 25-29, 2018, Proceedings,
Part I, 2018, pp. 527â€“553.
APPENDIX
YAOâ€™S SECRET SHARING SCHEME
Here we show how to extend our symbolic framework with
the xor expressions to give a sound symbolic security proof
of Yaoâ€™s secret sharing scheme [37], [38].
Formally, we extend the syntax of ğ„ğ±ğ©(ğ•‚) as:
ğ„ğ±ğ©(ğ•‚) â†’ ğŠğğ² âˆ£ ğ„ğ±ğ©(ğ•‚) âŠ• ğ„ğ±ğ©(ğ•‚) âˆ£ ğ–¢0 âˆ£ ğ–¢1 âˆ£ ğ–¢2 âˆ£ â‹¯
ğŠğğ² â†’ ğ–ªğ‘– âˆ£ ğ–¦0(ğŠğğ²) âˆ£ ğ–¦1(ğŠğğ²)
160
where ğ–ªğ‘– ranges over ğŠ, and ğ–¢0, ğ–¢1, ğ–¢2, â€¦ are new constant
modify the grammar rule of ğ„ğ±ğ©(â¦ƒğ‘ â¦„) as:
symbols representing keys in {0, 1}ğœ…
ğ„ğ±ğ©(â¦ƒğ‘ â¦„) â†’â¦ƒğ„ğ±ğ©(ğ‘ )â¦„ğŠğğ²
. At the same time, we
Note that the encryption expressions remain the same as in
Section II, and ğŠğğ² = ğ–¦âˆ—(ğŠ) = ğŠâˆ— is the set of possible
encryption keys. So symbolic properties on pseudorandom
keys do not change. For all 0 â‰¤ ğ‘– < 2ğœ…
be
the binary representation of ğ‘–. Any computational evaluation
function ğœ can be extended in the obvious way:
, let ğ‘– âˆˆ {0, 1}ğœ…
ğœ(ğ‘˜0 âŠ• ğ‘˜1) = ğœ(ğ‘˜0) âŠ» ğœ(ğ‘˜1),
ğœ(ğ–¢ğ‘–) = ğ‘–,
We extend the congruence relation â‰¡ with the following
, let
where âŠ» is the bitwise xor operation on bitstrings.
rules: For all ğ‘˜, ğ‘˜â€², ğ‘˜â€²â€² âˆˆ ğğšğ­(ğ•‚) and for all 0 â‰¤ ğ‘–, ğ‘— < 2ğœ…
(ğ‘˜ âŠ• ğ‘˜â€²) âŠ• ğ‘˜â€²â€² â‰¡ ğ‘˜ âŠ• (ğ‘˜â€² âŠ• ğ‘˜â€²â€²),
ğ‘˜ âŠ• ğ‘˜ â‰¡ ğ–¢0,
ğ‘˜ âŠ• ğ‘˜â€² â‰¡ ğ‘˜â€² âŠ• ğ‘˜,
ğ‘˜ âŠ• ğ–¢0 â‰¡ ğ‘˜,
ğ–¢ğ‘– âŠ• ğ–¢ğ‘— â‰¡ ğ–¢â„ for some 0 â‰¤ â„ < 2ğœ…
such that ğ‘– âŠ» ğ‘— = â„.
Pseudorandom bit renamings and pseudorandom key renam-
ings remain the same. We consider an additional mapping
ğ›¼âŠ• âˆ¶ ğğšğ­(ğ•‚) â†’ ğğšğ­(ğ•‚) such that it is compatible with â‰¡,
i.e., ğ›¼âŠ•(ğ‘˜ âŠ• ğ‘˜â€²) â‰¡ ğ›¼âŠ•(ğ‘˜) âŠ• ğ›¼âŠ•(ğ‘˜â€²) for all ğ‘˜, ğ‘˜â€² âˆˆ ğğšğ­(ğ•‚).
Moreover, we require that, for all ğ‘˜ âˆˆ ğğšğ­(ğ•‚):
âˆ™
âˆ™
âˆ™
if ğ‘˜ = ğ–¢ğ‘– for some ğ–¢ğ‘–, then ğ›¼âŠ•(ğ‘˜) = ğ‘˜;
if ğ‘˜ âˆˆ ğŠğğ², then ğ›¼âŠ•(ğ‘˜) = ğ‘˜ âŠ• ğ–¢ğ‘— for some ğ–¢ğ‘— ;
if ğ‘˜ = ğ‘˜â€² âŠ• ğ‘˜â€²â€², then ğ›¼âŠ•(ğ‘˜) = ğ›¼âŠ•(ğ‘˜â€²) âŠ• ğ›¼âŠ•(ğ‘˜â€²â€²).
Then for all ğ‘˜, ğ‘˜â€² âˆˆ ğğšğ­(ğ•‚), ğ‘˜ â‰¡ ğ‘˜â€² if and only if ğ›¼âŠ•(ğ‘˜) â‰¡
ğ›¼âŠ•(ğ‘˜â€²). We extend ğ›¼âŠ• to all patterns in the obvious way. It is
easy to check that for any pattern ğ‘’ the distributions (cid:2)ğ‘’(cid:3) and
(cid:2)ğ›¼âŠ•(ğ‘’)(cid:3) are the same. Now, a pseudorandom renaming is a
triple ğ›¼ = (ğ›¼ğµ, ğ›¼ğ¾ , ğ›¼âŠ•), and we write ğ›¼(ğ‘’) = ğ›¼âŠ•(ğ›¼ğ¾(ğ›¼ğµ(ğ‘’)))
To compute the pattern of an expression, we keep the
deï¬nitions of ğ©, ğŠğğ²ğ¬, and ğğšğ«ğ­ğ¬ unchanged. For any set ğ‘†
of keys, let ğ‘†âŠ•
be the closure of ğ‘† under âŠ•. Then we modify
the deï¬nition of ğ« to include keys that can be derived using
the xor operation:
ğ«(ğ‘’) = ğ–¦âˆ—
For any ğ‘’ âˆˆ ğğšğ­, the key recovery operator ğ‘’ âˆ¶ â„˜(ğğšğ­(ğ•‚)) â†’
â„˜(ğğšğ­(ğ•‚)) has the same deï¬nition as in Section II: for any
ğ‘† âŠ† ğğšğ­(ğ•‚), ğ‘’(ğ‘†) = ğ«(ğ©(ğ‘’, ğ‘†)). One can check that the
conditions in Theorem 2 (with ğŠ replaced by ğğšğ­(ğ•‚)) still hold
with these changes, and thus the extended symbolic framework
is sound.
({
ğ‘˜ âˆˆ ğŠğğ²ğ¬(ğ‘’) âˆ£ (ğ‘˜ â‹ ğ‘’ âˆ¨ âˆƒğ‘˜â€² âˆˆ ğŠğğ²ğ¬(ğ‘’).ğ‘˜ â‰º ğ‘˜â€²)
})âŠ• .
A secret sharing scheme Î  for ğ‘› parties ğ‘1, â€¦ , ğ‘ğ‘› consists
of a pair of algorithms (ğšœğš‘ğšŠğš›ğš, ğš›ğšğšŒğš˜ğš—) and an access structure
deï¬ned by a boolean circuit ğ¶ âˆ¶ {0, 1}ğ‘› â†’ {0, 1}. Any
set ğ‘ƒ of parties can be encoded using a boolean vector
ğ‘¥ğ‘ƒ âˆˆ {0, 1}ğ‘›
ğ‘– = 1 if and only of ğ‘ğ‘– âˆˆ ğ‘ƒ . The
probabilistic algorithm ğšœğš‘ğšŠğš›ğš takes a circuit ğ¶ and a secret
ğ‘¦ âˆˆ {0, 1}ğ‘›
ğ‘–=1, one for
, and it produces ğ‘› secret shares { Ìƒğ‘¦ğ‘–}ğ‘›
such that ğ‘¥ğ‘ƒ
ğ‘–=1
ğ‘–=1
each party; the algorithm ğš›ğšğšŒğš˜ğš— takes a set of secret shares,
and it outputs ğ‘¦â€² âˆˆ {0, 1}ğ‘›
. The scheme Î  is correct if for
any set ğ‘ƒ of parties with ğ¶(ğ‘¥ğ‘ƒ ) = 1 and any ğ‘¦ âˆˆ {0, 1}ğ‘›
,
â† ğšœğš‘ğšŠğš›ğš(ğ¶, ğ‘¦), then ğš›ğšğšŒğš˜ğš—({ Ìƒğ‘¦ğ‘—}ğ‘ğ‘—âˆˆğ‘ƒ ) = ğ‘¦. It
if { Ìƒğ‘¦ğ‘–}ğ‘›
is computationally secure if for any ğ‘¦0, ğ‘¦1 âˆˆ {0, 1}ğ‘›
if
â† ğšœğš‘ğšŠğš›ğš(ğ¶, ğ‘¦â„) for â„ âˆˆ {0, 1}, then for any set
{ Ìƒğ‘¦â„,ğ‘–}ğ‘›
ğ‘ƒ of parties such that ğ¶(ğ‘¥ğ‘ƒ ) = 0, the distributions { Ìƒğ‘¦0,ğ‘—}ğ‘ğ‘—âˆˆğ‘ƒ
and { Ìƒğ‘¦1,ğ‘—}ğ‘ğ‘—âˆˆğ‘ƒ are computationally indistinguishable.
Yaoâ€™s secret sharing scheme Î  is a computational secret
sharing scheme for monotone boolean circuits, i.e., circuits
that consist of AND and OR gates and have a single bit output.
To describe such circuits in our inductive circuit notation, we
remove ğğ€ğ§ğ and add ğ€ğ§ğ and ğğ« circuits: both of ğ€ğ§ğ
and ğğ« have two input wires and one output wire, and they
compute the boolean and and or functions, respectively. In the
symbolic settings, we can describe ğšœğš‘ğšŠğš›ğš as follows:
,
ğšœğš‘ğšŠğš›ğš :: Circuit(ğ‘ , â—¦) Ã— {0, 1}ğ‘› â†’ ğ„ğ±ğ©
ğšœğš‘ğšŠğš›ğš(ğ¶, ğ‘¦) = ((ğšŒğš, ğ‘˜1), â€¦ , (ğšŒğš, ğ‘˜ğ‘›)) where
(ğšŒğš, ğ‘£) = ğšœğš‘(ğ¶, ğ–¢ğ‘¦)
(ğ‘˜1, â€¦ , ğ‘˜ğ‘›) = ğ‘£
ğšœğš‘ :: Circuit(ğ‘ , ğ‘¡) Ã— ğ„ğ±ğ© â†’ ğ„ğ±ğ©
ğšœğš‘(ğ€ğ§ğ, ğ‘˜) = (ğœ–, (ğ–ªâ„, ğ‘˜ âŠ• ğ–ªâ„)) where
ğšœğš‘(ğğ«, ğ‘˜) = (ğœ–, (ğ‘˜, ğ‘˜))
ğšœğš‘(ğƒğ®ğ©, (ğ‘˜ğ‘–, ğ‘˜ğ‘—)) = ((â¦ƒğ‘˜ğ‘–â¦„ğ–ªâ„
â„ â† new
,â¦ƒğ‘˜ğ‘—â¦„ğ–ªâ„), ğ–ªâ„) where
â„ â† new
ğšœğš‘(ğ’ğ°ğšğ©, (ğ‘¢, ğ‘£)) = (ğœ–, (ğ‘£, ğ‘¢))
ğšœğš‘(ğ€ğ¬ğ¬ğ¨ğœ, (ğ‘¢, (ğ‘£, ğ‘¤))) = (ğœ–, ((ğ‘¢, ğ‘£), ğ‘¤))
ğšœğš‘(ğ”ğ§ğšğ¬ğ¬ğ¨ğœ, ((ğ‘¢, ğ‘£), ğ‘¤)) = (ğœ–, (ğ‘¢, (ğ‘£, ğ‘¤)))
ğšœğš‘(ğ¶0 â‹™ ğ¶1, ğ‘¤) = ((ğšŒğš0, ğšŒğš1), ğ‘¢) where
(ğšŒğš1, ğ‘£) = ğšœğš‘(ğ¶1, ğ‘¤)
(ğšŒğš0, ğ‘¢) = ğšœğš‘(ğ¶0, ğ‘£)
(ğšŒğš, ğ‘¢) = ğšœğš‘(ğ¶, ğ‘£)
ğšœğš‘(ğ…ğ¢ğ«ğ¬ğ­(ğ¶), (ğ‘£, ğ‘¤)) = (ğšŒğš, (ğ‘¢, ğ‘¤)) where
Due to space constraint, the deï¬nition of ğš›ğšğšŒğš˜ğš— is omitted
here and can be found in the full version [35].
To show that this scheme is secure, let us ï¬x any mono-
tone boolean circuit ğ¶ with ğ‘› input wires and a set ğ‘ƒ =
, â€¦ , ğ‘ğ‘–ğ‘š} of ğ‘š parties such that ğ¶(ğ‘¥ğ‘ƒ ) = 0. One can show
{ğ‘ğ‘–1
that the following lemma holds:
Lemma 9. For any ğ‘¦ âˆˆ {0, 1}ğ‘›, let ((ğšŒğš, ğ‘˜1), â€¦ , (ğšŒğš, ğ‘˜ğ‘›)) =
ğšœğš‘ğšŠğš›ğš(ğ¶, ğ‘¦), and let ğ‘’ = (ğšŒğš, (ğ‘˜ğ‘–1
, â€¦ , ğ‘˜ğ‘–ğ‘š)). If ğ–¢ğ‘¦ âŠ• ğ‘˜ âˆˆ
Fix(ğ‘’) for some ğ‘˜ âˆˆ ğğšğ­(ğ•‚), then ğ‘˜ âˆ‰ Fix(ğ‘’).
)). If ğ–¢ğ‘¦0
. For â„ âˆˆ {0, 1},
Fix any 0 â‰¤ ğ‘¦0, ğ‘¦1 < 2ğ‘›
âŠ• ğ‘˜ â‹ ğ‘’0 then let ğ›¼0
let
ğ‘›)) = ğšœğš‘ğšŠğš›ğš(ğ¶, ğ‘¦â„), and let ğ‘’â„ =
1), â€¦ , (ğšŒğšâ„, ğ‘˜â„
((ğšŒğšâ„, ğ‘˜â„
(ğšŒğšâ„, (ğ‘˜â„
, â€¦ , ğ‘˜â„
âŠ• be such
ğ‘–1
ğ‘–ğ‘š
that ğ›¼0
âŠ•(ğ‘˜) â‰¡ ğ‘˜ âŠ• ğ–¢ğ‘¦0 ; otherwise let ğ›¼0
âŠ• be the identity map
on ğ‘˜. Similarly we can deï¬ne ğ›¼1
âŠ• for ğ‘’1. Let ğ›¼ğµ and ğ›¼ğ¾
âŠ•(ğğšğ­ğ­ğğ«ğ§(ğ‘’0)) â‰¡
be identity maps. One can check that ğ›¼0
âŠ•(ğğšğ­ğ­ğğ«ğ§(ğ‘’1)), and thus ğğšğ­ğ­ğğ«ğ§(ğ‘’0) and ğğšğ­ğ­ğğ«ğ§(ğ‘’1) are
ğ›¼1
equivalent up to the pseudorandom renaming ğ›¼. Therefore Î 
is computationally secure.
161