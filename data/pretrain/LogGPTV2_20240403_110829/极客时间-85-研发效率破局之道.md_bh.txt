## 查看工作区中的修改> git diffdiff --git a/index.js b/index.jsindex 7b82693..eb53f5f 100644--- a/index.js+++ b/index.js@@ -6,5 +6,5 @@ app.get('/', function (req, res) {   res.send('hello world') }) -// Start the server+// Start the server at a predefined port app.listen(port)22:40:10 (master|REBASE-i) PI:EMAIL:~/jksj-repo/git-atomic-demo> git add index.js  
## 对修改添加到提交 A 中去> git commit --amend[detached HEAD f544b12] Change magic port number to variable Date: Mon Oct 14 12:50:36 2019 +0800 1 file changed, 3 insertions(+), 1 deletion(-)22:41:18 (master|REBASE-i) PI:EMAIL:~/jksj-repo/git-atomic-demo  
## 查看修改过后的 A。确认其包含了新修改的内容 "at a predefined port"> git showcommit f544b1247a10e469372797c7dd08a32c0d59b032 (HEAD)Author: Jason Ge Date:   Mon Oct 14 12:50:36 2019     Change magic port number to variable     Summary:    It's not good to have a magic number. This commit changes it to a    varaible.     Test:    Run node index.js and verified the root endpoint still works. diff --git a/index.js b/index.jsindex 63b6300..eb53f5f 100644--- a/index.js+++ b/index.js@@ -1,3 +1,4 @@+var port = 3000 var express = require('express') var app = express() @@ -5,4 +6,5 @@ app.get('/', function (req, res) {   res.send('hello world') }) -app.listen(3000)+// Start the server at a predefined port+app.listen(port)执行完成之后，我就可以运行 git rebase \--continue，完成 git rebase -i的后续操作，也就是在 A 之上再应用提交 B，并把 HEAD 重新指向了B，从而完成了对历史提交 A 的修改。    
## 继续运行 rebase 命令的其他步骤> git rebase --continueSuccessfully rebased and updated refs/heads/master.  
## 查看提交历史> git log --oneline --graph --all* 27cba8c (HEAD -> master) Add a new endpoint to return timestamp* f544b12 Change magic port number to variable| * 7b6ea30 (temp) Add a new endpoint to return timestamp| * b517154 Change magic port number to variable|/* 352cc92 (origin/master) Add gitignore file for node_modules* e2dacbc Added the simple web server endpoint* 2f65a89 Init commit created by installing express module经过 rebase 命令，我重新产生了提交 A 和 B。同样的，A 和 B是新生成的两个提交，原来的 A 和 B 仍然存在。![](Images/4895ca5f89e614e93e2d26ec4696165f.png){savepage-src="https://static001.geekbang.org/resource/image/75/48/75e70f4be9da61fcafdca3b427414748.png"}以上，就是修改历史提交内容的步骤。如果我们需要对历史提交进行拆分的话，步骤也差不多：首先，使用 git rebase-i，在需要拆分的提交处使用 edit 指令；然后，在 git rebase -i暂停的时候，使用基本操作 2 的方法对目标提交进行拆分；拆分完成之后，运行git rebase \--continue 即可。
## 小结今天，我与你介绍了 Git支持代码提交原子性的五种基本操作，包括用工作区改动的一部分产生提交、对当前提交进行拆分、修改当前提交、交换多个提交的先后顺序，以及对非头部提交进行修改。掌握这些基本操作，可以让我们更灵活地对代码提交进行修改、拆分、合并和交换顺序，为使用Git 实现代码原子性的工作流打好基础。其实，这些基本操作非常强大和实用，除了可以用来提高提交的原子性外，还可以帮助我们日常开发。比如，我们可以把还未完成的功能尽快产生提交，确保代码不会丢失，等到后面再修改。又比如，可以产生一些用来帮助自己本地开发的提交，始终放在本地，不推送到远程代码仓。在我看来，Git学习曲线比较陡而且长，帮助手册也可以说是晦涩难懂，但一旦弄懂，它能让你超级灵活地对本地代码仓进行处理，帮助你发现代码仓管理系统的新天地。gitrebase -i命令，就是一个非常典型的例子。一开始，你会觉得它有些难以理解，但搞懂之后就超级有用，可以帮助你高效地解决非常多的问题。所以，在我看来，在Git 上投入一些时间绝对值得！为了方便你学习，我把这篇文章涉及的代码示例放到了[GitHub](https://github.com/jungejason/git-atomic-demo)上，推荐你clone 下来多加练习。
## 思考题1.  对于交换多个提交的先后顺序，除了使用 rebase -i    命令外，你还知道什么其他办法吗？2.  文章中提到，如果一个提交已经推送到了远程代码仓共享分支，那就没有办法对它进行拆分了。这个说法其实有些过于绝对。你知道为什么绝大部分情况下不能拆分，而什么情况下还可以拆分呢？感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎你把这篇文章分享给更多的朋友一起阅读。我们下期再见！![](Images/6476358e731920fbc927e278bae473aa.png){savepage-src="https://static001.geekbang.org/resource/image/ec/d8/ece1747e3a8f96aa76a8e57c94de94d8.jpg"}
# 26 \| Facebook怎样实现代码提交的原子性？你好，我是葛俊。今天，我们继续来聊聊如何通过 Git提高代码提交的原子性吧。在上一篇文章中，我给你详细介绍了 Git助力提高代码提交原子性的五条基础操作，今天我们再来看看 Facebook的开发人员具体是如何使用这些操作来实现提交的原子性的。为了帮助你更直观地理解、学习，在这篇文章里，我会与你详细描述工作场景，并列出具体命令。同时，我还把这些命令的输出也都放到了文章里，供你参考。所以，这篇文章会比较长、比较细。不过不要担心，这些内容都是日常工作中的自然流程，阅读起来也会比较顺畅。在 Facebook，开发人员最常使用两种 Git工作流： 1.  使用一个分支，完成所有需求的开发；        2.  使用多个分支，每个分支支持一个需求的开发。        两种工作流都利用 Git的超强功能来提高代码原子性。这里的"需求"包括功能开发和缺陷修复，用大写字母A、B、C 等表示；每个需求都可能包含有多个提交，每个提交用需求名 +序号表示。比如，A 可能包含 A1、A2 两个提交，B 只包含 B1 这一个提交，而 C包含 C1、C2、C3 三个提交。需要强调的是，这两种工作流中的一个分支和多个分支，都是在开发者本地机器上的分支，不是远程代码仓中的功能分支。我在前面第 7 篇文章中提到过，Facebook的主代码仓是不使用功能分支的。另外，这两种 Git工作流对代码提交原子性的助力作用，跟主代码仓是否使用单分支开发没有关系。也就是说，即使你所在团队的主仓没有使用Facebook那样的单分支开发模式，仍然可以使用这两种工作流来提高代码提交的原子性。接下来，我们就先看看第一种工作流，也就是使用一个分支完成所有需求的开发。工作流一：使用一个分支完成所有需求的开发这种工作流程的最大特点是，**使用一个分支上的提交链，大量使用 git rebase -i来修改提交链上的提交**。这里的提交链，指的是当前分支上，还没有推送到远端主仓共享分支的所有提交。首先，我们需要设置一个本地分支来开发需求，通过这个分支和远端主仓的共享分支进行交互。本地分支通常直接使用master 分支，而远端主仓的共享分支一般是origin/master，也叫作上游分支（upstream）。一般来说，在 git clone 的时候，master 是默认已经产生，并且是已经跟踪origin/master 了的，你不需要做任何设置，可以查看.git/config文件做确认：    > cat .git/config    ...    [remote "origin"      url = PI:EMAIL:jungejason/git-atomic-demo.git      fetch = +refs/heads/*:refs/remotes/origin/*    [branch "master"      remote = origin      merge = refs/heads/master可以看到，branch \"master\"里有一个 remote = origin 选项，表明 master分支在跟踪 origin 这个上游仓库；另外，config 文件里还有一个 remote\"origin\"选项，列举了 origin这个上游仓库的地址。当然，除了直接查看 config 文件外，Git 还提供了命令行工具。你可以使用git branch -vv 查看某个分支是否在跟踪某个远程分支，然后再使用 git remoteshow去查看远程代码仓的细节。    
## 查看远程分支细节    > git branch -vv      master      5055c14 [origin/master: behind 1] Add documentation for getRandom endpoint    