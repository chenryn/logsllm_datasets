False Negatives (FN). We observed that almost half of the
FNs, i.e., 405, occurred because the vulnerability resided in
dynamically loaded code. For 78 and 7 FNs, points-to anal-
ysis for DOM queries were not accurate as the state of the
DOM tree and environment variables were necessary for such
analysis, respectively. The remaining 350 FNs stemmed from
the fact that the JavaScript program used setTimeout and
eval for ﬁring events by generating code at run-time.
5.6.2 HPG Construction
In total, JAW-static generated 498,054,077 nodes and
639,323,601 edges for the 4,836 HPGs, which is 10,756,335
nodes (-2.11%) and 13,338,972 edges (-2.04%) less than JAW
(false negatives). Out of the total missing edges, 1,048,172
are ERDDG edges that are critical for modeling events, and
the remaining 12,290,800 edges are the AST, CFG, PDG and
IPCG edges. Furthermore, JAW-static misses 16,710 edge
properties (set on ERDDG registration edges) that mark if an
event handler has been triggered at run-time, and that has not
been marked with static analysis.
Following additional experiments based on our methodol-
ogy (§5.1), we logged the ﬁred events that JAW cannot map
to their line of code. In total, JAW observed 51,974 events
at run-time across 4,836 HPGs, out of which 34,808 were
already marked by static analysis and ﬁred dynamically. The
remaining 17,166 events trigger at run-time, while not cap-
tured by pure static analysis. Out of the 17,166 events, JAW
fails to ﬁnd the corresponding event handlers of 456 events
in the code (0.88%), an indication of FN nodes and edges
in the HPG. Manual analysis revealed that the reasons for
the majority of cases (387 events) is the use of eval and
setTimeout functions with dynamically constructed strings
for ﬁring events. The remaining 69 events are not mapped due
to the dynamic loading of code and in ways that JAW does
not monitor (e.g., loading code from inside iframes).
Finally, we assess the FP and FN edges introduced by the
usage of the DOM tree snapshots when performing points-to
analysis of DOM queries. In total, JAW encountered 241,428
DOM query selectors in 4,836 HPGs, out of which in 127 se-
lectors (0.05%) JAW imprecisely resolved the DOM element
the query is pointing to. To determine the ERDDG dispatch
edges, JAW compares the pointers for a total of 87,340 pairs
of DOM query selectors against each other (i.e., an event
dispatched on one DOM query selector is linked to its event
handler that uses another query selector for the event registra-
tion). Our evaluation suggests that JAW accurately decides to
connect or not to connect a dispatch edge between the dispatch
and registration sites in 87,212 cases (decision accuracy of
99.85%), with 56,923 true positives and 30,289 true negatives.
In the remaining 128 cases, JAW’s decision to create or not
to create an edge is inaccurate, with 94 FN and 34 FP edges
(decision inaccuracy of 0.15%). Interestingly, we observed
that such FP and FN edges may occur for query selectors
that are interpreted within 53.7 mili-seconds of page load (on
average), and a maximum of 92.5 mili-seconds, which is up to
ca. ten times lower than the average access time of all query
selectors, i.e., 559.2 mili-seconds. In this experiment, we used
run-time program instrumentation to obtain the ground truth
for assessing JAW’s accuracy in HPG construction. However,
such techniques come with performance hits, and are poorly
suitable for large HPGs (e.g., in model construction, and vul-
nerability detection). We believe the impact of JAW’s FP and
FN edges as a result of DOM snapshots is negligible.
6 Discussion
Properties of Client-side Forgeable Requests. In this paper,
we showed that 82% of the web applications have at least one
web page with a client-side forgeable request that can be
exploited to mount CSRF attacks, suggesting that forgeable
requests are prevalent. We also showed that client-side CSRF
can be used to mount other attacks, such as XSS and SQLi,
which cannot be mounted via the traditional attack vectors.
Then, the analysis of forgeable requests suggest that some
client-side CSRF templates are more prevalent than others,
e.g., in 28.7% of vulnerable applications, the attacker can
overwrite a parameter in the request body.
Interesting Properties of Vulnerable Applications. We
found that 39 out of 106 targets in our testbed are single
page applications (SPA), i.e., 36.7%. We manually examined
the 87 vulnerable targets and observed that 44.8% of them are
SPA’s. Also, we found exploits in 17.9% of the tested SPAs
USENIX Association
30th USENIX Security Symposium    2537
( §5.5). We believe this sheds light into the fact that client-side
CSRF instances are more prevalent among SPA applications.
Transfer of Control and Run-time Monitoring. Our evalu-
ation shows that dynamic information increases the transfer
of control path by 0.26%. Despite its negligibility, our eval-
uation shows that dynamic information is fundamental for
the identiﬁcation of the forgeable requests of 14 out of 87
vulnerable applications and three out of seven exploitable
applications (an increase of +19.1% and +75%, respectively).
Vulnerability Originates from the Same Code. The manual
analysis of the 515 forgeable HTTP requests reveals that each
vulnerability originates from different copies of the same code
used across various pages. The templates for vulnerabilities
range between one to four per application, with a majority
of applications (i.e., 78.1%) having only a single template.
These facts suggest that developers tend to repeat the same
mistake across different pages.
False Positives. We observed that using state values together
with traditional static analysis will help to remove spurious
execution traces (§5.6). Nevertheless, our extensive manual
veriﬁcation uncovered that 1/516 requests was a false positive
due to inaccurate pointer analysis of the this statement in
dynamically called functions (see §5.3). We observed that
such a request is using data values originating from the DOM
tree, meaning that 1/83 requests of the DOM-READ forgeable
request category may be a false positive. We plan to address
this shortcoming by incorporating the call-sensitive resolution
of the this keyword into JAW in the future.
Limitations. The vulnerabilities found in this paper are those
captured by our model and traversals. However, it could hap-
pen that a forgeable request in the program is not found be-
cause the construction of the model is bound by the soundness
properties offered by the individual static analysis tools we
use for the construction of the property graph, e.g., CFG,
PDG, etc. Accurately building these models by static anal-
ysis is a challenging task due to the streaming nature of
JavaScript programs [43], and JavaScript dynamic code gen-
eration capabilities. We point out that, similar to prior work
(e.g., see [46]), JAW extracts the code executed by dynamic
constructs, i.e., eval, setTimeout and new Function(), as
long as the string parameter can be reconstructed statically.
As a future work, we plan to replace our extension with a
modiﬁed JavaScript engine (e.g., VisibleV8 [54]), to provide
better support for reﬂection and such dynamic constructs, and
to minimize the potential side effects of function hooking,
especially with respect to event handlers. Furthermore, the
vulnerabilities discovered in this paper affect those pages that
JAW reached with our crawler. However, crawling is a chal-
lenging task (see, e.g., [40, 70]) and JAW may have missed
pages with vulnerable code. To increase coverage, we plan to
provide support for the smooth integration of other crawlers.
Incremental Static Analysis. JAW can reduce by 60% the
effort required to analyze client-side JavaScript programs via
pre-built symbolic models. When looking at the unique ap-
plication code, we observe that a large fraction of code is
also shared between pages. For example, the 4,836 pages con-
tain in total 104,720 application scripts, of which only 4,559
are unique, suggesting that the shared code of different web
pages can be modeled once, and reused through incremental
program analysis, a problem we plan to address in the future.
Vulnerability Disclosure. At the time of writing this paper,
we are in the process of notifying the affected vendors about
our discovery, following the best practices of vulnerability
notiﬁcation (see [85]).
7 Related Work
Request Forgery Vulnerabilities. Request forgery is a
widely exploited web vulnerability (see, e.g., [23, 25, 26, 27,
32, 51, 88]) that we can divide into two families: SSRF [68]
and CSRF [37, 69]. Research in this area has largely focused
on request forgery defenses (e.g., [34, 39, 52, 53, 56, 63, 73,
74]), with very few proposing detection techniques that can
help security testing community to uncover CSRF exploits
(i.e., [37, 69, 77, 86]). Only a fraction of these works, most
notably, Deemon [69], and Mitch [37], went beyond manual
inspection by presenting (semi-)automated approaches. As
opposed to these works, this paper proposes JAW, a frame-
work to study client-side CSRF vulnerabilities at large-scale
based on HPGs and declarative graph traversals.
Property Graphs and Vulnerability Detection. Graph-
based analysis of source code has a long history and has a been
considered by several researchers (e.g., [33, 41, 57, 71, 91]).
Yamaguchi et. al. [91] proposed the notion of CPGs for ﬁnd-
ing software bugs in C/C++ applications (i.e., a non-web-
based execution environment). Backes et. al. [33] later ex-
tended this idea to detect vulnerabilities in the server-side
of PHP web applications. In contrast to these works, our ap-
proach adapts the concept of CPGs to the client-side of web
applications, and extends them with dynamic information, i.e.,
state values (§3.2). Also, existing CPGs are poorly suited for
large-scale analyses which is a needed feature to analyze web
applications (a web application can have hundreds of pages
to analyze, each with thousands of lines of JavaScript code).
Backes et. al. [33] needed up to 5 days and 7 hours for a single
query when analyzing 77M LoC. In comparison, JAW took 3
days (sequential execution) to model and query 228M LoC.
This improvement is largely due to the introduction of the
new notion of symbolic models for shared third-party code
(§5.2). We believe that these contributions are key enablers to
use graph-based analyses on web applications, at scale.
Security Analysis of JavaScript Programs. Over the past
years, we have seen different techniques for analyzing
JavaScript programs (e.g., [38, 42, 44, 46, 61, 62, 67, 82, 83]).
To date, these approaches have been mostly applied to
XSS [60, 64, 75, 84] and validation ﬂaws [66, 76, 79, 89, 92]).
Most notably, Lekies et. al. [60] modiﬁed the JavaScript en-
gine in Chromium to enhance it with taint-tracking capabili-
2538    30th USENIX Security Symposium
USENIX Association
ties, and used a crawler that leverages the modiﬁed Chromium
to detect DOM-based XSS vulnerabilities. Saxena et. al. pro-
posed Kudzu [75], a tool that performs dynamic taint-tracking
to identify sources and sinks in the current execution using
a GUI explorer, and then generates XSS exploits by apply-
ing symbolic analysis to the detected source-sink data ﬂows.
In general, these techniques could be useful to detect client-
side CSRF provided their crawler/GUI-explorer can trigger
the executions that are connecting sources to sinks. How-
ever, crawlers/GUI-explorers often fall short of visiting mod-
ern web UIs, providing low code coverage when compared
with static analysis techniques. As opposed to approaches
like [60, 75], JAW follows a hybrid approach, addressing
shortcomings of JavaScript static analysis such as dynamic
loading of script tags and point-to analysis for DOM ele-
ments.
8 Conclusion
In this paper, we presented JAW, to the best of our knowledge
the ﬁrst framework for the detection and analysis of client-
side CSRF vulnerabilities. At the core of JAW is the new
concept of HPG, a canonical, static-dynamic model for client-
side JavaScript programs. Our evaluation of JAW uncovered
12,701 forgeable client-side requests affecting 87 web ap-
plications. For 203 of them, we created a working exploit
against seven applications that can be used to compromise
the database integrity. We analyzed the forgeable requests
and identiﬁed 25 different request templates. This work has
successfully demonstrated the capabilities of our paradigm
for detecting client-side CSRF. In the near future, we intend
to use our approach toward additional vulnerability classes.
Acknowledgments
We would like to thank our shepherd Stefano Calzavara and
the anonymous reviewers for their valuable feedback.
References
[1] Ast-Flow-Graph library. https://www.npmjs.com/
package/ast-flow-graph.
[2] Bitnami application catalog. https://bitnami.com/
stacks.
js.
[3] Cypher query language. https://neo4j.com/develo
per/cypher-query-language/.
[4] Dujs library. https://github.com/chengfulin/du
[5] Escontrol library. https://www.npmjs.com/packag
[6] Esgraph CFG generator. https://github.com/Swa
e/escontrol.
tinem/esgraph.
[7] Esprima. https://esprima.org/.
[8] Function.prototype.apply(). https://developer.mo
zilla.org/en-US/docs/Web/JavaScript/Refere
nce/Global_Objects/Function/apply.
[9] Function.prototype.call(). https://developer.mozi
lla.org/en-US/docs/Web/JavaScript/Referenc
e/Global_Objects/Function/call.
[10] Headless chromium. https://chromium.googlesou
rce.com/chromium/src/+/lkgr/headless/READM
E.md.
[11] JavaScript language resources. https://developer.
mozilla.org/en-US/docs/Web/JavaScript/Lang
uage_Resources.
[12] JQuery library. https://jquery.com/.
[13] Library Detector for chrome. https://www.npmjs.co
m/package/js-library-detector.
[14] Neo4j graph database. https://neo4j.com.
[15] Selenium browser automation. https://www.seleni
[16] Selenium IDE. https://www.selenium.dev/proje
[17] Selenium-python. https://selenium-python.read
thedocs.io/index.html.
[18] Styx library. https://www.npmjs.com/package/st
um.dev.
cts.
yx.
[19] Usage statistics of content management systems. https:
//w3techs.com/technologies/overview/conten
t_management.
[20] window.name API. https://developer.mozilla.
org/en-US/docs/Web/API/Window/name.
[21] window.open() API. https://developer.mozilla.
org/en-US/docs/Web/API/Window/open.
[22] YUI library. https://yuilibrary.com/.
[23] CSRF: Adding optional two factor mobile number in
slack, 2016. https://hackerone.com/reports/15
5774.
[24] Client-side CSRF, 2018. https://www.facebook.c
om/notes/facebook-bug-bounty/client-side-c
srf/2056804174333798/.
[25] Two factor authentication cross site request forgery
(CSRF) vulnerability in wordpress. cve-2018-20231.,
2018. https://www.privacy-wise.com/two-fac
tor-authentication-cross-site-request-forg
ery-csrf-vulnerability-cve-2018-20231/.
[26] Account take over in US Dept of Defense, 2019. https:
//hackerone.com/reports/410099.
[27] Critical CSRF vulnerability on facebook, 2019. https:
//www.acunetix.com/blog/web-security-zone/
critical-csrf-vulnerability-facebook/.
[28] Intent to implement and ship: cookies with SameSite by
default, 2019. https://groups.google.com/a/ch
romium.org/forum/#!msg/blink-dev/AknSSyQTG
Ys/SSB1rTEkBgAJ.
[29] Intent to implement: Cookie SameSite=lax by default
and SameSite=none only if secure, 2019. https://gr
oups.google.com/forum/#!msg/mozilla.dev.pla
tform/nx2uP0CzA9k/BNVPWDHsAQAJ.
[30] SameSite cookie attribute, chromium, blink, 2020. ht
tps://www.chromestatus.com/feature/4672634
USENIX Association
30th USENIX Security Symposium    2539
709082112.
[31] Usage statistics of JavaScript libraries for websites,
2020. https://w3techs.com/technologies/o
verview/javascript_library.
[32] S. Abdelhaﬁz. SSRF leaking internal google cloud data
through upload function, 2019. https://hackerone.
com/reports/549882.
[33] M. Backes, K. Rieck, M. Skoruppa, B. Stock, and F. Ya-
maguchi. Efﬁcient and Flexible Discovery of PHP Ap-
In Proceedings of the 2nd
plication Vulnerabilities.
IEEE Euro S&P, 2017.
[34] A. Barth, C. Jackson, and J. C. Mitchell. Robust de-
fenses for cross-site request forgery. In CCS, 2008.
[35] A. Barth, J. Weinberger, and D. Song. Cross-Origin
JavaScript Capability Leaks: Detection, Exploitation,
and Defense. In USENIX Security, 2009.
[36] S. Calzavara, M. Bugliesi, S. Crafa, and E. Stefﬁnlongo.
Fine-Grained Detection of Privilege Escalation Attacks
on Browser Extensions. In ESOP, 2015.
[37] S. Calzavara, M. Conti, R. Focardi, A. Rabitti, and
G. Tolomei. Mitch: A machine learning approach to the
black-box detection of csrf vulnerabilities. In Proceed-
ings of the IEEE Euro S&P, 2019.
[38] S. Chandra, C. S. Gordon, J. Jeannin, C. Schlesinger,
M. Sridharan, F. Tip, and Y. Choi. Type Inference for
Static Compilation of Javascript. In ACM SIGPLAN