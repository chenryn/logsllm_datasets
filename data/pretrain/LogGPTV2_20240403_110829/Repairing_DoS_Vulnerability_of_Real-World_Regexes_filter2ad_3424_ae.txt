question, we measure the quality of repaired regexes using the
metrics also used in [22]. For the last question, we compare the
running times of REMEDY and REMEDY with the optimization
described in Section V-C. Henceforth, we refer to REMEDY
with the optimization as REMEDY-o, and use REMEDY-h to
denote the hybrid of REMEDY and REMEDY-o that returns the
regex returned by the faster of the two.
Finally, we present a comparison of our tool REMEDY with
the other state-of-the-art tools in Section VI-E. We compared
REMEDY with three state-of-the-art tools AlphaRegex [20],
RFixer [22], and FlashRegex [24]. AlphaRegex only supports
synthesizing a regex, while RFixer and FlashRegex support
both synthesizing and repairing a regex.
A. Experimental Setup
lookarounds or backreferences). Initially,
We have implemented REMEDY in Java. We use Z3 [38] as
the SMT solver. All experiments were performed on a machine
with Intel(R) Xeon(R) Gold 6254 CPU @ 3.10GHz.
Benchmark. We used Ecosystem ReDoS data set collected
by Davis et al. [7], which contains real-world regexes in
Node.js (JavaScript) and Python core libraries. The data set
contains 13,670 regexes that contain real-world extensions
(i.e.,
the regexes
are not classified whether they are vulnerable or not. Thus,
we contacted the authors of [7] to obtain the subset that
they classified as vulnerable. As a consequence, the data set
contains 13,591 regexes that contain real-world extensions
and are unknown whether they are vulnerable or not, and 79
regexes that contain real-world extensions and are vulnerable.
Due to the size, for the former, we selected 100 of them
randomly. For the latter, we selected all of them. The average
and maximum sizes of the regexes (measured as number of
AST nodes) are 32.1 and 383, respectively.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
92068
We note that there are no known sound-and-complete Re-
DoS vulnerability detection methods for real-world regexes
(in fact, even whether such a detection is possible is an open
question). The 79 regexes that are classified as vulnerable are
manually classified as so by Davis et al. We have chosen this
data set because its regexes represent real use cases and are
also considered to be vulnerable.
Sampling Examples. Since the data set of [7] do not come
with examples, we prepared the examples by ourselves. Many
of them were made manually, but some were generated
automatically, due to the large sizes of the regexes, by the
following input generation technique that is inspired by that
of [39] for pure regexes.
We first convert the given regex to a backreference-free
regex by replacing each capturing group (r)i and backreference
\i by fresh symbols αi and βi, respectively. The resulting
pure regex (lookarounds can be eliminated for backreference-
free regexes [40]) is converted to a DFA. We enumerate the
accepting paths of the DFA so that each edge appears in at
least one path, with the requirement that an edge βi can only
be taken if the corresponding edge αi was taken before in the
path. Each path is turned into a set of positive examples by
replacing each αi and βi by a positive example of the regex
r where (r)i is the capturing group (positive examples of r
are generated by recursively applying this process). Negative
examples are generated similarly by considering the rejecting
paths of the DFA.
Finally, we used at most 5 positive and negative examples
each. We note that, for usability, PBE should only use rela-
tively small numbers of examples.
Consistency with Examples. By construction, REMEDY is
guaranteed to only generate regexes that are consistent with
the given examples. We have also validated that all regexes that
REMEDY generated in the experiment were indeed consistent
with the given examples by running the Java’s regex library
util.regex.
ReDoS Invulnerability. By construction, REMEDY is guaran-
teed to only generate regexes that satisfy RWS1U and hence
ReDoS invulnerable. We have also validated that all regexes
that REMEDY generated in the experiment indeed satisfied
RWS1U. Note that whether a regex satisfies RWS1U can be
easily checked by analyzing the extended NFA translation of
the regex (cf. Section IV-A).
B. RQ1: Efficiency
1) Performance: To evaluate the performance, we ran
REMEDY and the variants with a timeout of 30 seconds. We
chose 30 seconds because the improvement by setting the
timeout to more than 30 seconds was little. The table below
summarizes the results. The columns Solved and Average
show that the number of test cases which were repaired within
the timeout range and the average running time, respectively.
Additionally, Figure 6a and 6b summarize the running times.
(a) Running times of REMEDY (b) Running times of REMEDY-o
Fig. 6: Results of the repairs.
(a) REMEDY
(b) REMEDY-o
Fig. 7: Scalability with respect to edit distances.
132
119
147
1.54
1.08
0.97
Solved(179) Average(s)
REMEDY
REMEDY-o
REMEDY-h
In total, REMEDY,
REMEDY-o,
and
REMEDY-h repaired
73.7%, 66.5%, and
82.1% of
regexes,
respectively. More than 82.3% of
regexes were repaired
within 1 second. On the other hand, we observed that the
tools could not repair 17.9% of regexes within the time
limit. Our inspection showed that
the tools struggled on
repairs that require large changes from the original. Such
repairs may need to explore a large space of possible
regexes. An example of such failure cases is a regex that
contains a concatenation of many vulnerable sub-regexes,
e.g., (·∗[,])∗[,]+[ ]+([’"]?)[ a]∗\2···, where ···
is a further concatenations of vulnerable sub-regexes. The
finding agrees with that of [22] who have reported that their
method also struggled on repairs with large changes, and
whose techniques are adapted to our method (cf. Section V).
In summary, REMEDY can repair vulnerable regexes that
contain real-world extensions efficiently.
2) Scalability: Based on the finding, we plot the running
times of REMEDY over the edit distances from the input
regexes to their repair results. As Figure 7a shows, in the
case of REMEDY, we observed a general correlation between
the running times and the edit distances: large edit distances
require long running times. This observation affirms our initial
findings that the size of edit distance affects the running time.
We also observed that, in some cases, REMEDY finished
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
102069
repairing with a large edit distance and a short running time.
To explain the behavior, we use as example the regex below
that is derived from the actual case.
(?=(·∗)1[ ]([0-9][:]\1[:][:])∗)·∗
The regex contains a lookahead with repetitions and backref-
erences thus violating the condition (2) of RWS1U. REMEDY
immediately detects the violation and replaces the repetitions
and backreferences with holes. As result, REMEDY reaches the
template (?=((cid:50))1[ ](cid:50))·∗ in one step. Note that the template
replaced quite large sub-expressions with holes and is of a
large edit distance. This substantially reduced the search space,
and thus the short running time was achieved even with the
large edit distance.
On the other hand, as shown in Figure 7b, we observed less
correlation between the running times and the edit distances
for REMEDY-o. Note that the scale of the edit distance axis is
significantly wider than that of Figure 7a. The observation also
coincides with our initial findings because REMEDY-o uses the
optimization described in Section V-C that can increase the
edit distance in a small number of steps, namely all sets of
characters violating condition (1) of RWS1U are immediately
replaced by holes.
Additionally,
to un-
derstand how our tool
scales as the size of
a regex increases, we
plot
the running time
of REMEDY-h over the
size of the regex (mea-
sured as number of AST
nodes). Figure 8 shows
the result. The points
on the border (colored
in blue)
indicate that
REMEDY-h could not repair the regex within the time limit.
Note that the figure is truncated to omit redundant space where
no points appear.
Fig. 8: Scalability wrt. regex sizes.
One can observe that, except for the regexes which led
to timeout, REMEDY could repair almost all regexes within
1 second regardless of their size. Additionally, we inspected
some of the regexes which require more than 1 seconds to
repair and confirmed that they require large changes from the
original. That is, the impact of the size of regexes on the
implementation is little, while the size of edit distance affects
the implementation.
In summary, the performance of REMEDY scales with the
size of regexes. Additionally, there is a correlation between
the running times and the edit distances of REMEDY.
C. RQ2: Quality
As mentioned by [22], repairs that are similar to the original
ones are often considered good in PBE because they are
similar to what
to evaluate
the quality of repaired regexes objectively, we measure the
similarity to the original regex. A large change indicates low
the user intended. Therefore,
(a) Edit distances.
(b) Percentages of changes.
Fig. 9: Histograms for repair quality.
quality as such repairs may be far from what the user intended.
Figure 9a shows a histogram plotting the number of regexes
against the edit distances to their repair results by REMEDY-
h. Most of the regexes were repaired within the small edit
distances, with about 81% repaired within edit distance 12.
We also measure the ratio of changes, i.e., the size of the
regex portion changed by its repair divided by the size of the
entire regex. Figure 9b shows a histogram plotting the number
of regexes against their ratios of changes. We observe that most
repairs are close to the original regexes, with the average ratio
of change being 24.3%.
We discuss some typical cases of repairs that we observed
the data set contained
in our experiments. For example,
vulnerable regexes that use positive lookaheads to assert
·∗(?=[ ]∗[;])·∗.
an appearance of some keyword, e.g.,
For this, REMEDY returns the repaired invulnerable regex
[ˆ;]∗[;]·∗, which is semantically equivalent to the original,
with the edit distance of 7. We also refer to the XML example
from Section II as an exemplar repair case that we observed in
our experiments. In summary, REMEDY can produce repaired
regexes that have high-similarity, and therefore of high-quality.
D. RQ3: Effect of the Optimization
We evaluate the effec-
tiveness of the optimization
described in Section V-C.
The comparison of the run-
ning times of REMEDY and
REMEDY-o are shown in
Figure 10. We note that,
in 23 cases, REMEDY-o
solved the instance within
the time limit while REM-
EDY could not, and con-
versely in 19 cases, REM-
EDY solved the instance
within the time limit while REMEDY-o could not.
Fig. 10: Optimization effect.
We have observed that REMEDY-o often outperformed
REMEDY for regexes that violate the RWS1U condition at
many places. For example, for the regex
(?=[ˆ,])·∗,(?=[ˆ,])·∗,(?=[ˆ,])·∗,(?=[ˆ,])·∗,·+
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
112070
the desired template is one in which the first four any
character, i.e., ·, is replaced with a hole. REMEDY reaches
such a template only after trying 24−1 many other templates,
whereas REMEDY-o reaches it immediately. Conversely, in
cases where REMEDY performed better, we have observed
that the repair benefits from templates that replace the non-
RWS1U-violating parts of the regex with holes. Since the
optimization prevents addHoles from replacing such parts
with holes, it can negatively affect the performance in such
cases.
In summary,
the optimization helps REMEDY to repair
regexes that violate the RWS1U condition at many parts,
while it negatively affects cases where non-RWS1U-violating
parts should be repaired. Thus, running both REMEDY and
REMEDY-o, i.e., REMEDY-h, achieves better performance than
running one of them alone.
E. Comparison to Other State-of-the-art Tools
Table I summarizes the characteristics of different PBE tools
for generating regexes, and compare them with our tool REM-
EDY. The Invulnerability Guarantees column shows that
REMEDY is the only one to guarantee the invulnerability.
Indeed, for AlphaRegex and RFixer, AlphaRegex generates
vulnerable regexes, e.g., some regexes shown in Table 3 of
[20] are vulnerable, and RFixer often generates vulnerable
regexes as reported by Li et al. [24]. For FlashRegex, we could
not confirm whether FlashRegex actually generates vulnerable
regexes or not because FlashRegex is not publicly available
(only the dataset is available from the GitHub repository).
Additionally, we have contacted the authors, but the imple-
mentation was not available. However, FlashRegex claims to
generate invulnerable regexes by only generating deterministic
(i.e., 1-unambiguous) regexes, which unfortunately is insuffi-
cient for guaranteeing invulnerability as we have shown in
Section IV-A.
The Real-world Extensions column shows that REMEDY is
the only one to support real-world extensions. The other state-
of-the-art tools, i.e., AlphaRegex, RFixer, and FlashRegex,
only support pure regexes and supporting real-world exten-