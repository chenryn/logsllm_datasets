# 【漏洞分析】EternalBlue工具漏洞利用细节分析
|
##### 译文声明
本文是翻译文章，文章来源：安全客
译文仅供参考，具体内容表达以及含义原文为准。
**前言**
****
EternalBlue（永恒之蓝）据称是方程式组织在其漏洞利用框架中一个针对SMB服务进行攻击的模块，由于其涉及漏洞的影响广泛性及利用稳定性，在被公开以后为破坏性巨大的勒索蠕虫WannaCry所用而名噪一时。360威胁情报中心对于WannaCry的活动持续地进行着监控，我们看到的趋势是
**WannaCry的感染量还在增加，说明作为蠕虫主要传播手段的EternalBlue相应的漏洞还大量存在着。** 但是，对于
**EternalBlue这个攻击利器本身的技术分析在公开渠道上看到的讨论其实并不充分**
，本文尝试通过一个较完全的分析梳理相关的细节，揭示其成因和相应的利用技巧。
**测试环境**
****
对于EternalBlue的分析是在一个相对简单的环境中进行的，执行攻击的系统为一个Win7机器，目标机器也是Win7
32位系统，没有安装EternalBlue相关的补丁，srv.sys文件的版本为 **6.1.7601.17514** ，srvnet.sys的版本为
**6.1.7601.17514** 。本文中所有的调试器中代码截图都对应上述的版本，不同版本的文件在代码本身或偏移可能不同，但整体的执行逻辑应该差不多。
**漏洞**
****
根据我们的分析，EternalBlue达到其攻击目的事实上利用了3个独立的漏洞：第一个也就是 **CVE-2017-0144**
被用于引发越界内存写；第二个漏洞则用于绕过内存写的长度限制；第三个漏洞被用于攻击数据的内存布局。下面重点介绍一下前两个漏洞，第三个漏洞会在内存布局的过程中提到。
**漏洞1**
首先是EternalBlue工具中使用到的主体漏洞，该漏洞也是Eternalblue的核心部分，编号为CVE-2017-0144。漏洞通过SMB协议的SMB_COM_TRANSACTION2命令触发，该命令说明如下所示：
当该数据包中包含对应的FEA LIST时，SMB服务中会将FEA LIST转换为对应的NTFEA
LIST，其对应的数据结构并不公开，如下所示为趋势团队分析出的对应的FEALIST结构。
入口处理函数为SrvSmbOpen2，其中漏洞出现在函数SrvOs2FeaListToNt中：
如下所示为对应的漏洞函数SrvOs2FeaListToNt，用于实现FEA LIST转换为对应的NTFEA
LIST，函数调用SrvOs2FeaListSizeToNt计算FEALIST的长度，但是该函数存在漏洞导致在特定的情况下，攻击者可以伪造超长的size，从而导致在之后的SrvOs2FeaToNt转换中导致pool溢出。
进入导致漏洞的SrvOs2FeaListSizeToNt函数，该函数会计算对应的FEA
LIST的长度并随后对长度进行更新，该长度一开始为DWORD类型的，之后的长度更新代码中计算出的size拷贝回去的时候是按WORD进行的拷贝，此时只要原变量a中的初始值大于FFFF，即为10000+，该函数的计算结果就会增大。
该赋值中如下所示esi变成了si，此时如果eax高位中的数据不为零，则将返回的超长的size。
如下图所示为对应发送的该数据包，可以看到该请求数据包的长度为103d0，其中对应的FEALIST的长度为10000。
如下图所示，eax为链表的开头，其指向了FEA LIST的总长度，即10000，esi为遍历之后的链表尾部，eax-esi=ff5d，为实际对应的长度，但是更新长度的mov指令中esi变成了si，由于eax中的值为10000，原本应该被赋值为ff5d的eax，变成了1ff5d。
之后在紧接着的函数SrvOsFeaToNt中，由于使用了错误的长度进行memmove从而导致溢出。
下图为其中的复制导致越界写，长度为a8，可以看到正常请求应该是在86535000这个srv.sys对象SMB
buffer中，由于长度过长导致对srvnet.sys分配的buffer越界写。
Enternalblue中通过内存布局，将srvnet对象buffer稳定的分配到srv拷贝对象buffer之后，如下图所示为越界写时的内存情况。
Srvnet 对象buffer中包含两个重要的域：
1.一个指向指定结构（srvnet_recv）的指针（即上图中的8834e4c0，被ffdff020覆盖），该指针将会在smb(srnet)连接结束或断开时被用于寻址函数地址。
2.一个用于接收缓冲区的MDL（即上图中的86546160，被ffdfef80覆盖）
因此覆盖并控制MDL将导致之后的tcp
栈实现任意写入伪造对象的操作，覆盖并控制该指针可用于将其指向一个攻击者控制的伪造对象，此时断开smb(srvnet)连接即可导致代码执行。
如下图所示，MDL复写为ffdfef80后，紧接着Eternalblue发送的shellcode就会被写入到ffdfef80+0x80的位置，即ffdff000。
可以看到此时的调用栈：
写入的地址ffdff000是系统预留的用于保存系统信息的地址，并且可执行。
被写入到ffdff000地址的是一个srvnet_recv的结构（该结构不公开）和紧随其后的shellcode，该结构用于smb(srnet)结束或断开连接的时候通过SrvNetWskReceiveComplete调用SrvNetCommonReceiveHandler
。SrvNetCommonReceiveHandler
根据srv_recv中的指针此处为下图中的poi（ffdff190（ffdff020（被覆盖的对应指针）+0x16c）+4）获取到对应的函数并调用，地址即我们伪造的shellcode的地址（ffdff1f1）。
**漏洞2**
如上述漏洞所示可以导致一次越界写，但其前提是FEA LIST的长度必须大于10000，通过分析可以发现FEA
LIST只存在于SMB_COM_TRANSACTION2命令的子命令中，而该命令的数据结构如下：
TotalDataCount（数据包总长度）是USHOER类型的，即最大值只能为FFFF，那在这个地方EternalBlue是如何发送的长度大于FFFF的SMB_COM_TRANSACTION2子命令请求的呢？
通过抓包可以发现此处发送的并不是SMB_COM_TRANSACTION2子命令的请求包，而是SMB_COM_NT_TRANSACT子命令的请求包：
如下图所示SMB_COM_NT_TRANSACT子命令中TotalDataCount的类型为ULONG，支持发送大于FFFF长度的数据包。
但是SMB_COM_NT_TRANSACT本身是不支持FEA LIST的，这里就涉及到EternalBlue中使用到的第二个漏洞。
SMB的子命令中存在一个名为TRANSACTION系列的命令：
SMB_COM_TRANSACTION: 用于和邮槽、命名管道进行通信
SMB_COM_TRANSACTION2: 用于打开或创建一个共享文件或文件夹，设置它们的扩展属性
SMB_COM_NT_TRANSACT: 用于打开或创建一个文件或文件夹，并应用扩展属性EA或安全描述符SD
其中产生漏洞的即为对应的SMB_COM_TRANSACTION2命令。
对于TRANSACTION系列的命令如果发送的长度过大，SMB会将该请求包拆分成**Second的形式进行发送，如下所示为其相应的**Second系列的命令：
SMB_COM_TRANSACTION
SMB_COM_TRANSACTION_SECONDARY
SMB_COM_TRANSACTION2
SMB_COM_TRANSACTION2_SECONDARY
SMB_COM_NT_TRANSACT