increasingly strict about moving all data out of code segments and
into a data segment. As a result, linear disassembly can achieve high
accuracy [3]. Recent works such as RetroWrite [19] and Egalito [58]
4For instance, the starting point of a function f may change from a location 0x1000
to 0x1050 after instrumentation. This requires every constant value 0x1000, if it
represents a pointer to f , to be changed to 0x1050.
5This also means that they are not randomized by ASLR.
6About 99% of binaries on a default Ubuntu 18.04 install are position-independent.
Original code
0xf7(%rip), %rdi
-0xefe(%rip), %rax
1200: lea
1209: mov
// load function pointer from location 30c
120e: call
*%rax
Randomized code
L1200: lea
L1300(%rip), %rdi
L1209: mov L310(%rip), %rax
L120e: call
*%rax
jmp L1211
-0xf18(%rip),%rdi
$0x14, %rax
12ff
%rdi,%rax
(%rax), %rax
%rax,%rdi
*%rdi
1211: lea
1218: cmp
121c: jge
121e: add
1221: mov
1226: add
1229: jmp
// Indirect jump using jump table
122a: · · ·
1270: · · ·
1298: · · ·
12ff: ret
1300: push %rbp
1301: sub
· · ·
$0x20, %rsp
// code for jmp table entry 1
// code for jump table entry 2
// code for jump table entry 3
L300(%rip), %rdi
// Jump table targets...
L122a: ...
L1270: ...
L1298: ...
L1211: lea
L1218: cmp $0x14, %rax
L121c: jge
L121e: add %rdi,%rax
L1221: mov (%rax), %rax
L1226: add %rax,%rdi
L1229: jmp *%rdi
L12ff
L12ff: ret
L1300: push %rbp
L1301: sub
$0x20, %rsp
· · ·
Static data:
// Jump table...
300: 0xf2a
304: 0xf70
308: 0xf98
// Pointer constant marked for relocation
310: 0x1500
Static data:
// Rewritten jump table
L300: .long L122a-L300
L304: .long L1270-L300
L308: .long L1298-L300
L310: .8byte L1500
Figure 2: Intra-function randomization. To highlight corre-
spondence between instructions before and after random-
ization, (a) vertical space has been introduced to align in-
structions, and (b) only one code permutation is shown.
have also shown that complex Linux binaries can be successfully
disassembled using linear disassembly.
Function Identification. Since most of our randomizing transfor-
mations operate on one function at a time, the next step is to divide
the disassembled code into functions. We rely on EH-metadata
to identify function boundaries. Recent work shows [42] that on
Linux/x86_64 (our implementation platform), this technique is more
accurate than many techniques specialized for accurate function
identification [4, 5, 43, 48]. Although EH metadata may not be as
complete on other platforms, this won’t affect SBR’s correctness:
our sole correctness-critical use of function boundaries occurs in
the context of preserving the unwinding blocks that are actually
present in the EH-metadata.
Pointer Identification and Remapping. We illustrate pointer iden-
tification and remapping using the code snippet on the left of Fig. 2.
Its randomized version is shown at the right of this figure.
On Linux/x86_64, there are three ways for PIC to create pointers.
The first is the use of PC-relative addressing to compute the address
of static data or code, e.g., the lea 0xf7(%rip), %rdi instruction
at location 1200. This instruction moves the value 1300 into the
%rdi register. (Note: the PC register %rip points to the next instruc-
tion at 1209, so 0x f 7 + 1209 = 1300.) The second way is by loading
407ACSAC 2020, December 7–11, 2020, Austin, USA
Soumyakant Priyadarshan, Huan Nguyen, and R. Sekar
a pointer that is stored within the static data (or possibly the code),
e.g., the instruction mov -0xefe(%rip),%rax at location 1209. This
instruction moves the contents of location 120e − e f e = 310 into
%rax. We identify the loaded value as a pointer because location 310
is marked for relocation. For both instructions, we ensure that the
references point to the correct location after binary instrumentation
by replacing the constants with labels. We use the style of BinCFI
[64], where the location information produced by a disassembler
(e.g., 1300) is turned into a label (e.g., L1300). These symbolic ref-
erences are resolved by the assembler when we reassemble the
randomized code shown on the right in Fig. 2.
The third way pointers are created is through pointer arithmetic.
There is no need to “fix up” data pointer arithmetic: it involves
adding a value to a base address, and since SBR does not change
the distances within the data segment, there is no need to adjust
this value. However, code layout is altered, so we need to adjust
the new pointer value so that it accesses the same logical target as
the original code. To do this, we need to know the exact value that
is being added, which will be known only at runtime. Fortunately,
code pointer arithmetic tends to occur only in the context of jump
tables, which are typically generated by compilers from C-style
switch statements. We have developed a static analysis to identify
the use of jump tables and fix up the targets. This analysis is able
to handle all of the binaries we have tested in our evaluation. Our
analysis is similar to that of Egalito [58], so we omit a description
of the analysis in order to conserve space. Instead, we illustrate
how jump table accesses are processed using the example of Fig. 2.
Jump table use begins with the instruction at 1211 which loads
the base address of the jump table into %rdi register. The index
value is stored in %rax. This value is bounds-checked at 121c, and if
this fails, the function returns by jumping to the ret instruction at
12f f . Otherwise, this index is added to the base address of the jump
table, and the resulting location dereferenced and loaded into %rax
at 1221. Our analysis determines that the location dereferenced is
one of 300, 304, or 308; that each of them point within the read-only
data segment; and that they contain the values f 2a, f 70, and f 98
respectively. Based on the instructions at 1211 and 1226, our analysis
also determines that (a) these values are added to a base address
300 of the jump table, and (b) the resulting values are 122a, 1270
and 1298 respectively. It can be seen that if the jump table entries
are modified as shown in Fig. 2, then the fixup will be correct. In
this way, SBR is able to statically fixup pointer constants regardless
of the manner in which they are created.
Control Flow Graph (CFG) Construction. The first step in CFG
construction is to identify basic blocks, which are contiguous se-
quences of instructions with a single entry and a single exit. The
body of the function is first broken up into blocks at control-flow
transfer instructions. Since a call is a control-transfer, it terminates
the current basic block, just like jumps.
Next, we break these blocks further at every control flow target.
Since code pointers have been identified by now, we can introduce
breaks at indirect control flow targets as well. If these breaks occur
in the midst of an instruction, a disassembly error is flagged, unless
they immediately follow an x86 instruction prefix, e.g., lock.
As the last step in CFG building, edges are created between basic
blocks to capture control flow transfers. These edges encode the
type of the branch instruction (conditional or unconditional, jump
or call, direct or indirect, etc.) and the target (for direct transfers).
Randomizing Transformations. At this point, SBR has all the
information needed for randomizing transformations: function
boundaries (for FR and LLR(k)), unwinding block boundaries (for
EH-metadata-reducing transformations), and the locations of un-
conditional branches (for ZJR), basic blocks (for BBR), and call
instructions (for PHR and OPHR). Based on this information, code
is broken up at the desired locations and permuted according to the
description of each of these transformations earlier in this paper.
Labels derived from the original locations of instructions are
maintained during code permutation, thereby simplifying the
introduction of jumps between them. For instance, in Fig. 2, a break
was introduced just before the instruction at 1211, so we add a jmp
L1211 after the preceding instruction at 120e. To make it easy to
see the correspondence between the original and randomized in-
structions, we purposely limited ourselves to a single permutation
in this example, and did not reorder functions. (Code reached via
the jump table has also been moved, but this does not require the
introduction of additional jumps since these locations were already
preceded by unconditional jumps.)
Exception handling metadata regeneration. We generate both the
reduced and full unwinding information as described in Sec. 4, and
then encode them into the EH-metadata sections as follows:
• eh_frame_hdr: This section consists of a binary search table
that maps a function to its corresponding frame descriptor
entry (FDE) in the eh_frame section. Each record of this table
is pair of function start and the address of corresponding
FDE. We update this information using the labels of these
instructions, in the same way data values are updated using
labels in Fig 2.
• eh_frame: This section contains the FDEs for each function.
The FDE contains the function start and size which we up-
date using labels. The FDE also contains information about
each unwinding block, and the associated unwinding oper-
ations. We specify the block boundaries using labels, and
have implemented an encoder for recording the unwinding
operations and dependencies on preceding blocks.
• gcc_except_table: This section encodes the address of try
blocks, the corresponding catch blocks, and any destructor
calls needed (to clean up stack-allocated objects) during stack
unwinding. The only change we needed to make here is to
update code locations using our labels.
We used labels and assembler directives (e.g., .byte) to specify EH-
metadata sections. This enables the randomized code with regener-
ated metadata to be reassembled by the system assembler. We have
fully tested exception handling after this transformation.
Reassembly and ELF header update. Since our transformation
produces valid assembly code, as illustrated in Fig. 2, it can be
assembled into an object file by the system assembler. This avoids
the need to implement low-level operations, such as the compu-
tation of instruction or data offsets, in SBR. We then use objcopy
to extract relevant sections of this object file and inject it into the
original binary. Currently, due to some engineering limitations, we
leave the original code section in its place, and add a new section
408Practical Fine-Grained Binary Code Randomization
ACSAC 2020, December 7–11, 2020, Austin, USA
Program Exec.
size
(KB)
43
281
apt-get
enscript
scp
gedit
evince
100
10
442
gimp
6058
Wireshark
perl
vim
vlc
pdflatex
8430
2098
2671
14
826
Python2.7
3642
tar
423
# of
libs
19
3
5
110
70
63
77
5
14
13
25
6
7
Libr.
size
(MB)
9.6
3.7
2.3
59
30
23
156
4
9.6
6.6
13.4
4
2.9
Total Description
size
(MB)
9.7
4.0
Run “apt-get upgrade”
Convert text file of
size > 50MB to pdf
Copy 100MB file
2.4
59 Open, edit and
save a text file
30 Open a PDF file,
view pages
29 Open a JPEG image,
edit(crop, blur, etc)
and save. Create a
drawing and save file
Capture network
packets for 30 mins
Run a perl script to parse
a file using regex
6
164
12.3 Open a text file, edit,
copy, paste, search and
replace and save
Play video from a
network stream
Compile .tex files
having a total
size of 100KB
Run Pystone1.1
benchmark
Compress a directory
of size 3GB
6.6
14.2
7.7
3.3
Aggregate 25MB
Table 3: Functionality testing on common applications
197MB
222MB
202
with the new code. (The original code is zeroed out, so this lim-
itation has no security impact.). We then update the ELF header
to reflect the new entry point for the binary. We also update the
program headers and the dynamic symbol table sections to reflect
the new locations in the modified binary.
7 IMPLEMENTATION
SBR implementation consists of 15.8KLoC of C++. We have de-
veloped our own ELF parsers and EH metadata decoders rather
than employing pre-existing utilities. We use objdump for linear
disassembly, operating on small sections at a time. As noted earlier,
the implementation of signal handler hooking is not complete yet.
For jump table analysis, we first use our architecture-neutral
approach for [24, 25] for lifting assembly. Our system Lisc [35] lifts
assembly to an intermediate representation (IR), specifically, gcc’s
RTL. Jump table analysis is then performed on this IR.
For entropy calculations, SBR generates logs during the random-
ization process that captures detailed information such as the size
and location of functions, unwinding blocks, the partition locations
for ZJR, BBR and PHR, and the locations of any trampolines intro-
duced. This is processed by a C++ program that contains 270 lines
of entropy calculation code based on the formulas from Sec 5, and
another 800 lines for input/output,
6
6
ZJR
BBR
PHR
LLR(k)
PHR +LLR(k)
16
9
9
16
400
300
200
100
)
s
t
i
b
(
y
p
o