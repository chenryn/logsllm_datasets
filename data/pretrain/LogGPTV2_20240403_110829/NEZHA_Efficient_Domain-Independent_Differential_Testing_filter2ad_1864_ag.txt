[33] M. Georgiev, S.
Iyengar, S. Jana, R. Anubhai, D. Boneh, and
V. Shmatikov, “The most dangerous code in the world: validating SSL
certiﬁcates in non-browser software,” in Proceedings of the 2012 ACM
conference on Computer and Communications Security (CCS). ACM,
2012, pp. 38–49.
[34] P. Godefroid, A. Kiezun, and M. Y. Levin, “Grammar-based whitebox
fuzzing,” in Proceedings of the 29th ACM SIGPLAN Conference on
Programming Language Design and Implementation (PLDI), 2008, pp.
206–215.
[35] P. Godefroid, N. Klarlund, and K. Sen, “Dart: directed automated
random testing,” in Proceedings of the 2005 ACM SIGPLAN conference
on Programming Language Design and Implementation (PLDI), vol. 40,
no. 6. ACM, 2005, pp. 213–223.
[36] P. Godefroid, M. Y. Levin, D. A. Molnar et al., “Automated whitebox
the 2008 Network and Distributed
fuzz testing.” in Proceedings of
Systems Symposium (NDSS), vol. 8, 2008, pp. 151–166.
[37] I. Haller, A. Slowinska, M. Neugschwandtner, and H. Bos, “Dowsing for
overﬂows: A guided fuzzer to ﬁnd buffer boundary violations,” in 22nd
USENIX Security Symposium (USENIX Security ’13). Washington,
D.C.: USENIX, 2013, pp. 49–64.
[38] C. Holler, K. Herzig, and A. Zeller, “Fuzzing with code fragments,”
in 21st USENIX Security Symposium (USENIX Security ’12), 2012, pp.
445–458.
[39] A. D. Householder and J. M. Foote, “Probability-based parameter
selection for black-box fuzz testing,” in CMU/SEI Technical Report -
CMU/SEI-2012-TN-019, 2012.
[40] S. Jana, Y. Kang, S. Roth, and B. Ray, “Automatically Detecting Error
Handling Bugs using Error Speciﬁcations,” in 25th USENIX Security
Symposium (USENIX Security), Austin, August 2016.
[41] S. Jana and V. Shmatikov, “Abusing ﬁle processing in malware detectors
for fun and proﬁt,” in Proceedings of the 2012 IEEE Symposium on
Security and Privacy (S&P).
IEEE Computer Society, 2012, pp. 80–
94.
[42] Y. Kang, B. Ray, and S. Jana, “APEx: Automated Inference of Error
Speciﬁcations for C APIs,” in 31st IEEE/ACM International Conference
on Automated Software Engineering (ASE), Singapore, September 2016.
[43] J. C. King, “Symbolic execution and program testing,” Communications
of the ACM, vol. 19, no. 7, pp. 385–394, 1976.
[44] J. C. Knight and N. G. Leveson, “An experimental evaluation of
the assumption of independence in multiversion programming,” IEEE
Transactions on Software Engineering, no. 1, pp. 96–109, 1986.
[45] J. Kornblum, “Identifying almost identical ﬁles using context triggered
piecewise hashing,” Digital Investigation, vol. 3, pp. 91–97, 2006.
[46] P. Laskov et al., “Practical evasion of a learning-based classiﬁer: A case
study,” in 2014 IEEE Symposium on Security and Privacy (S&P). IEEE,
2014, pp. 197–211.
[47] V. Le, C. Sun, and Z. Su, “Finding deep compiler bugs via guided
stochastic program mutation,” in Proceedings of the 2015 ACM SIG-
PLAN International Conference on Object-Oriented Programming, Sys-
tems, Languages, and Applications (OOPSLA), vol. 50, no. 10. ACM,
2015, pp. 386–399.
[48] B. A. Malloy and J. F. Power, “An interpretation of purdom’s algorithm
for automatic generation of test cases,” in International Conference on
Computer and Information Science, 2001.
[49] D. Marinov and S. Khurshid, “Testera: A novel
framework for
automated testing of java programs,” in Proceedings of the 16th IEEE
International Conference on Automated Software Engineering (ASE).
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:19:44 UTC from IEEE Xplore.  Restrictions apply. 
Washington, DC, USA:
[Online]. Available: http://dl.acm.org/citation.cfm?id=872023.872551
IEEE Computer Society, 2001, pp. 22–.
[50] P. M. Maurer, “Generating test data with enhanced context-free gram-
mars,” IEEE Software, vol. 7, no. 4, pp. 50–55, 1990.
[51] W. M. McKeeman, “Differential testing for software,” Digital Technical
Journal, vol. 10, no. 1, pp. 100–107, 1998.
[52] B. P. Miller, L. Fredriksen, and B. So, “An empirical study of the
reliability of unix utilities,” Communications of the ACM, vol. 33, no. 12,
pp. 32–44, 1990.
[53] R. P. Pargas, M. J. Harrold, and R. R. Peck, “Test-data generation using
genetic algorithms,” Software Testing Veriﬁcation and Reliability, vol. 9,
no. 4, pp. 263–282, 1999.
[54] D. A. Ramos and D. R. Engler, “Practical,
low-effort equivalence
veriﬁcation of real code,” in International Conference on Computer
Aided Veriﬁcation. Springer, 2011, pp. 669–685.
[55] S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida, and H. Bos,
“Vuzzer: Application-aware evolutionary fuzzing,” in Proceedings of the
Network and Distributed System Security Symposium (NDSS), 2017.
[56] J. Ruderman, “Introducing jsfunfuzz,” https://www.squarefree.com
/2007/08/02/introducing-jsfunfuzz/.
[57] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, “Ad-
dresssanitizer: a fast address sanity checker,” in 2012 USENIX Annual
Technical Conference (USENIX ATC 2012), 2012, pp. 309–318.
[58] E. G. Sirer and B. N. Bershad, “Using production grammars in software
the 2nd conference on Domain-Speciﬁc
testing,” in Proceedings of
Languages (DSL), vol. 35, no. 1. ACM, 1999, pp. 1–13.
[59] V. Srivastava, M. D. Bond, K. S. McKinley, and V. Shmatikov, “A
security policy oracle: Detecting security holes using multiple api
implementations,” ACM SIGPLAN Notices, vol. 46, no. 6, pp. 343–354,
2011.
[60] E. Stepanov and K. Serebryany, “Memorysanitizer: fast detector of
uninitialized memory use in C++,” in Proceedings of the 13th Annual
IEEE/ACM International Symposium on Code Generation and Optimiza-
tion (CGO).
IEEE Computer Society, 2015, pp. 46–55.
[61] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta,
Y. Shoshitaishvili, C. Kruegel, and G. Vigna, “Driller: Augmenting
fuzzing through selective symbolic execution,” in Proceedings of the
Network and Distributed System Security Symposium (NDSS), 2016.
[62] Tool Interface Standard, “The .xz File Format,” http://tukaani.org/xz/x
z-file-format.txt, August 2009.
[63] Tool
Interface Standard (TIS),
and Linking For-
mat (ELF) speciﬁcation,” https://refspecs.linuxfoundation.org/elf/elf.pdf,
May 1995.
“Executable
[64] W. Xu, Y. Qi, and D. Evans, “Automatically evading classiﬁers a case
study on PDF malware classiﬁers,” in Proceedings of the 2016 Network
and Distributed Systems Symposium (NDSS), 2016.
[65] X. Yang, Y. Chen, E. Eide, and J. Regehr, “Finding and understanding
bugs in c compilers,” in Proceedings of
the 32nd ACM SIGPLAN
Conference on Programming Language Design and Implementation
(PLDI). ACM, 2011, pp. 283–294.
[66] M. Zalewski, “american fuzzy lop,” http://lcamtuf.coredump.cx/afl/.
[67] A. Zeller, “Yesterday, my program worked. Today, it does not. Why?”
in Proceedings of the Joint Meeting on Foundations of Software Engi-
neering (ESEC/FSE). Springer, 1999, pp. 253–267.
XI. APPENDIX
A. Memory Coruption Bugs Reported by NEZHA
1) ClamAV use-after-free: NEZHA disclosed a use-after-
free heap bug in ClamAV, which is invoked when parsing
a malformed XZ archive. As ClamAV parses the multiple
compression blocks in the archive,
it makes a series of
allocation and freeing operations on a single memory buffer.
ClamAV’s memory allocation routine will only do so when the
given memory pointer is NULL. However, the memory freeing
routine fails to nullify the memory pointer after freeing the
buffer. As a result, the bug will be triggered after a series of
allocate-free-allocate operations. An attacker can exploit this
vulnerability by sending a malformed XZ archive that will
crash ClamAV when ClamAV attempts to scan the archive.
631
2) wolfSSL memory errors: NEZHA uncovered four mem-
ory corruption bugs in wolfSSL, all of which were marked as
critical by the wolfSSL developers and patched within six days
after we reported the bugs. Two of the bugs were caused by
missing checks for malformed PEM certiﬁcate headers inside
the PemToDer function, which converts a X.509 certiﬁcate
from PEM to DER format. The missing checks resulted
in out-of-bounds memory reads. The third bug was caused
by a missing check for the return value of a PemToDer
call, inside the wolfSSL_CertManagerVerifyBuffer
routine, causing a segmentation fault. In this case, the structure
holding the DER-converted certiﬁcate is corrupted. Finally the
fourth bug, also occurring inside Pem2Der, resulted in an
out-of-bounds read, due to a missing check on the size of
the PEM certiﬁcate to be converted. This can be triggered
by an intermediate certiﬁcate in a chain that has the correct
PEM header but an empty body: the missing check will cause
Pem2Der to not return any error, which in turn results in an
out-of-bounds memory access during the subsequent steps of
the veriﬁcation process.
3) GnuTLS null pointer dereference: NEZHA found a miss-
ing check inside the gnutls_oid_to_ecc_curve routine
of GnuTLS, where dereferenced pointers were not checked to
be not NULL. This bug resulted in a segmentation fault while
parsing an appropriately crafted certiﬁcate.
B. Coverage and population size for NEZHA’s different guid-
ance engines
In Figures 11 and 12, we present the coverage and popu-
lation increases for the different engines of NEZHA for the
experimental setup of Section V-A.
25000
20000
15000
10000
e
g
a
r
e
v
o
C
e
g
d
E
5000
0
0
21000
20000
19000
18000
0
5000
10000
15000
17000
Global coverage
(modiﬁed libFuzzer)
Path δ-diversity (coarse)
Path δ-diversity (ﬁne)
Output δ-diversity
20000
40000
60000
80000
100000
Generation
Fig. 11: Coverage increase for each of NEZHA’s
engines per generation (average of 100 runs with
a seed corpus of 1000 certiﬁcates).
C. BoringSSL - Incorrect representation of KeyUsage
According to the RFC standards, the KeyUsage extension
deﬁnes the purpose of the certiﬁcate key and it uses a
bitstring to represent the various uses of the key. A valid
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:19:44 UTC from IEEE Xplore.  Restrictions apply. 
i
e
z
S
n
o
i
t
l
a
u
p
o
P
450
400
350
300
250
200
150
100
50
0
0
420
410
400
390
380
370
360
350
Global coverage
(modiﬁed libFuzzer)
Path δ-diversity (coarse)
Path δ-diversity (ﬁne)
Output δ-diversity
0
5000
10000
15000
20000
40000
60000
80000
100000
Generation
exhibit this discrepancy during the parsing of a Certiﬁcate
Signing Request (CSR). This can have critical security impli-
cations. Consider the scenario where a CA using BoringSSL
parses such a CSR presented by an attacker and does not
interpret the extension correctly. The CA misinterprets the key
usages and does not detect certain blacklisted ones. In this
situation, the CA might copy the malformed extension to the
issued certiﬁcate. Subsequently, when the issued certiﬁcate is
parsed by a client using LibreSSL, it will be parsed with a
valid keyUsage extension and thus the attacker can use the
certiﬁcate for purposes that were not intended by the CA.
Fig. 12: Population size increase for each of
NEZHA’s engines per generation (average of 100
runs, each starting from a seed corpus of 1000
certiﬁcates).
Certiﬁcate Authority (CA) certiﬁcate must have this extension
present with the keyCertSign bit set.
BoringSSL and LibreSSL differ in the way they parse the
ASN.1 bitstring, which is used for storing the KeyUsage
extension in the X.509 certiﬁcates. Each bitstring is
encoded with a “padding” byte that indicates the number of
least signiﬁcant unused bits in the bit representation of the
structure. This byte should never be more than 7. But
if
the byte is set to a value greater than 7, BoringSSL fails to
parse the bitstring and throws an error in Listing 7, whereas
LibreSSL masks that byte with 0x07 and continues to parse
the bitstring as-is as shown in Listing 8.
1 ASN1_BIT_STRING *c2i_ASN1_BIT_STRING(..., char **pp) {
2
...
p = *pp;
padding = *(p++);
// returns an error if invalid padding byte
if (padding > 7) {
3
4
5
6
7
8
9
10
11
12
OPENSSL_PUT_ERROR(ASN1,
ASN1_R_INVALID_BIT_STRING_BITS_LEFT);
goto err;
}
ret->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07);
ret->flags |= (ASN1_STRING_FLAG_BITS_LEFT
...
| i);
Listing 7: BoringSSL code for validating bitstrings.
1 ASN1_BIT_STRING *c2i_ASN1_BIT_STRING(..., char **pp) {
2
...
p = *pp;
i = *(p++);
// masks the padding byte, instead of with a check
ret->flags&= ~(ASN1_STRING_FLAG_BITS_LEFT| 0x07);
ret->flags|=(ASN1_STRING_FLAG_BITS_LEFT
...
3
4
5
6
7
8
| (i&0x07));
Listing 8: LibreSSL code for validating bitstrings.
This subtle discrepancy results in two different interpreta-
tions of the same bitstring used in the extension. BoringSSL
fails to parse the bitstring and results in an empty KeyUsage
extension. LibreSSL, by masking the padding byte, success-
fully parses the extension. We also ﬁnd that these libraries
632
Authorized licensed use limited to: IEEE Xplore. Downloaded on March 18,2021 at 12:19:44 UTC from IEEE Xplore.  Restrictions apply.