non incremental version
0
2000
6000
10000
rendering start time (ms)
l
)
s
m
(
y
a
e
D
e
s
n
o
p
s
e
R
18
16
14
12
10
8
0
1
2
3
4
5
Time Delay from Client to Proxy(ms)
(a) Firefox
(b) Chrome
Figure 7. Cumulative Distribution Function of Rendering Start
Time
Figure 9. Communication De(cid:173)
lay with Different Local Laten(cid:173)
cies
n
o
i
t
u
b
i
r
t
s
d
e
v
i
t
i
l
a
u
m
u
c
0
.
1
8
.
0
.
6
0
4
0
.
2
.
0
0
.
0
0
n
o
i
t
u
b
i
r
t
s
d
e
v
i
t
i
direct access
incremental version
non incremental version
l
a
u
m
u
c
2000
4000
6000
8000
rendering finish time (ms)
0
.
1
8
.
0
6
0
.
4
0
.
2
0
.
0
.
0
0
direct access
incremental version
non incremental version
5000
rendering finish time (ms)
10000
15000
(a) Firefox
(b) Chrome
Figure 8. Cumulative Distribution Function of Rendering End
Time
l
)
s
m
(
y
a
e
D
e
s
n
o
p
s
e
R
60
40
20
0
0
20
60
Textarea Size(KB)
40
80
Figure 10. Communication
Delay with Different Msg
Sizes
of the cases the difference is less than 1.083 seconds. For
the rendering ﬁnish times, the median difference is 382 mil-
liseconds and the 90 percentile cutoff comes at 2.459 sec-
onds. For a few rare cases, the difference is larger than ﬁve
seconds; we attribute those rare cases to some implementa-
tion problems in our current prototype.
6.3 Communication Overhead
Communication overhead is calculated as the data trans-
ferred over the network to and from the client. For a web-
page, we captured the network traces when accessing the
webpage with and without our proxy and obtained the sizes
of those traces.
Figure 11 depicts the communication overhead. Web-
Shield does not always have larger communication over-
head comparing with direct access. For some of the web-
pages, we see that the amount of data transferred to the
client when going through WebShield is less than direct
access. On the one hand, Direct access needs to trans-
fer HTML content, JavaScript ﬁles, and CSS style sheets,
whereas WebShield needs to transfer encoded DOM up-
dates related to visual affect, such as a text area, visible ele-
ments, and so on. Our transfer of user-visible components is
not as effective as that of direct access because we transfer
parsed data in JSON, which is less dense than HTML nota-
tion, and during incremental rendering we need to provide
location information and other tokens. On the other hand,
however, we do not need to transfer JavaScripts, which con-
tain application logic, because JavaScripts are executed by
the JavaScript engine of shadow browsers in WebShield and
only the ﬁnal results are sent back to users. This reduce the
transfer overhead. As seen in the Figure 11, there are mixed
results when comparing WebShield with direct access. We
incur more overhead on Youtube as compared to direct ac-
cess because there are few script tags in Youtube, but for
Google Maps, we achieve smaller overhead because there
are many JavaScript scripts.
6.4 Memory Overhead
To evaluate memory overhead, we selected ten complex
webpages. For every webpage, we report the memory over-
head as the difference in memory usage of the browser be-
fore and after the page load. The initial and after the page
load memory usages are gathered using the Windows Task
)
      2
B
M
(
d
a
e
h
r
e
v
O
n
o
  1. 5
      1
With WebShield
Without WebShield
i
t
i
a
c
n
u
m
m
o
C
0. 5
0
)
B
M
(
d
a
e
h
r
e
v
O
y
r
o
m
e
M
40
30
20
10
0
flickr
MSN
amazon
yahoo
igoogle     gm ap
facebook youtube
ebay
weather
Figure 11. Communication Overhead
With WebShield
Without WebShield
flickr
MSN
amazon
yahoo
igoogle     gm ap
facebook youtube
ebay
weather
Figure 12. Memory Overhead
Manager. While this approach is only approximate in the
sense that we do not gather the data exactly before page re-
quest and after page load, but wait for the Task Manager to
show the results, we ﬁnd this approach to be quite reason-
able as we received consistent results over multiple loadings
of a webpage.
In Figure 12, we compare the memory consumption
of the transformed webpage with the corresponding native
webpages. For our system, memory is consumed mostly by
JavaScript and DOM, because we use JavaScript to recon-
struct DOM. For a native webpage, there are many places,
for example the HTML parser, CSS parser, and JavaScript
engine, which consume memory. If a page is very large and
contains many elements, parsing the native web pages can
use a lot of memory. If a page is fairly small, our JavaScript
program itself may take up a fairly large amount of memory
compared to the webpage itself.
Figure 12 shows that our memory overhead is just a lit-
tle higher than those of native webpages, which means the
memory usage of our JavaScript program is nearly the same
as native webpages. We look at some webpages as exam-
ples. We have more memory overhead on Facebook because
the native Facebook page has a few elements for parsing and
our JavaScript render agent on client side will take compar-
atively more memory. But, for Amazon, we have less mem-
ory overhead for the transformed webpage than the native
page. This is because Amazon has many user effect ele-
ments and the browser will consume a lot of memory to
parse the contents.
6.5
Interactive Performance for Dynamic HTML
As shown in Figure 5,
the normal JavaScript event
response time is the time for a browser to execute the
JavaScript event handler bound to the special event. If the
JavaScript event triggers an AJAX call, an AJAX connec-
tion to the remote web server will occur, and thus the net-
work round trip time as well as the server response time
need to be included in the respond time. This cost is in-
evitable in any client-server system. The extra time cost is
the cost introduced by our secure proxy.
In this section, we present interactivity evaluation with
microbenchmarks and a real-world JavaScript game. In the
microbenchmarks, we will investigate the extra time cost.
Regardless whether there is an AJAX connection to the re-
mote server, the extra event response time introduced by
WebShield can be classiﬁed as communication delay and
DOM update delay. Communication delay is the time cost
for transferring the triggered events from the client to the
shadow browser in the secure proxy and transfering back the
result (DOM updates) from the shadow browser to the client
browser. DOM update delay is the time cost for updating
the aforementioned shadow browser DOM updates into the
webpage’s DOM in the client browser. For the JavaScript
game evaluation, from the user’s perspective, we measure
the time delay caused by the user’s actions.
6.5.1 Microbenchmarks
With microbenchmarks, we measure the atomic event trans-
mission delay. We write a test webpage to test the event
response time. In the testing webpage, the user can enter
Start Game Move Mouse Drop a Piece Game Over
Additional Delay
41ms
7ms
10ms
7ms
Table 3. Time Delay in Game Connect 4
texts into a textarea. After the user clicks the button on the
client browser, the text in the textarea will be updated to
a text node inside a  node. With our security proxy,
when the user clicks the button, the changes in textarea node
and the “click” event will be packaged in JSON and trans-
ferred to the shadow browser in the proxy. The shadow
browser updates a textnode with the receiving textarea con-
tent. Then, the changes of the DOM tree will be sent back
to the client browser and the client-side DOM is updated.
Communication delay: The communication delay time
is decided by two factors, the network delay and the data
transfer size. Network delay will inﬂuence the communi-
cation delay. We use the network emulator netem [9] to
emulate different network environments with latencies of 0,
1, 2, 3 and 4ms on the gateway. Here, we change the gate-
way latency, and trigger the click event with a 2 kilobyte
textarea. As seen in Figure 9, the response delay increases
linearly with the growth of local latency. The response de-
lay is within 20ms when local latency is 4ms. So the user
will not perceive this extra delay.
Then, we will test the communication delay with dif-
ferent DOM node sizes. As Figure 10 shows, we change
the length of textarea in a test webpage, and trigger the
click event while measuring the delay time with the Date()
function. We can see that the response delay increases
linearly with the growth of textarea size. Even as the
textarea reaches 64 kilobytes, the communication delay is
still within 50ms.
In an intra-network environment, the latency between the
client browser and proxy is usually small (less than 5ms).
As the above evaluation shows, the event response time is
just tens of milliseconds, which will not affect the user’s
experience.
DOM update delay: In the above evaluation, we update
one node for each event. Here, we evaluate the time cost for
updating one DOM node. In our experiment, we repeatedly
insert a textnode with a length of 2 kilobytes to the ﬁrst
child of body tag 10000 times, and use the Date() function
to get the duration. The average time cost for updating a
single node is 0.04ms. For state-of-the-art web applications,
one event usually incur an update of less than 100 DOM
nodes. Therefore, DOM update delay is negligible in our
implementation.
6.5.2 Test on a Real Game
We chose a real-world high-interactive JavaScript game,
Connect Four, to benchmark WebShield. We downloaded
this game from the front page of the top website when
querying Google for “javascript games”. We measure the
delay on the client side based on different user opera-
tions. Connect Four is a mid-size (about 7K) two-player
JavaScript game we found at a popular JavaScript games
site [4]. Each player can place a piece on a square. When a
player has four connected pieces, he will win. In our exper-
iment, we will measure time delay introduced by our proxy
with various user actions taking effect on the user screen.
In this game, four kinds of activities are measured.