== 搜索命令函数
[options="header" ]
|=====
|函数|描述|示例
|mvsum(X,...)
|此函数接受至少一个数值类型的多值字段或单值字段做为参数，返回所有参数的总和
|以下示例将返回多值字段multiv的值与2的总和
... \| eval v = mvsum(multiv, 2)
|mvavg(X,...)
|此函数接受至少一个数值类型的多值字段或单值字段做为参数，返回所有参数的平均值
|以下示例将返回多值字段multiv的值与2的平均值,多值字段的每个值都会使计算平均值的分母加1
... \| eval v = mvavg(multiv, 2)
|mvappend(X,...)
|该函数为任意个参数，参数可以为字符串，多值字段，或者单值字段等
|... \| eval v=mvappend(initv, "middle")
|mvcount(X)
|该函数只有一个参数X，如果X是多值字段，则返回多值字段的值个数，如果是单值字段，则返回1，其他返回0
|... \| eval c=mvcount(mvfield)
|mvdedup(X)
|该函数接收一个多值参数X，返回字段值消重后的多值类型
|... \| eval v=mvdedup(mvfield)
|mvfilter(X, filterexpr)
|X为类型为多值的参数，filterexpr为过滤条件表达式，其中使用_x描述X中的单个值
对mv多值字段进行过滤，仅保留1a的值
|mvfilter(mv, _x == "1a")
|mvfind(X,V)
|X为多值类型的参数，V表示需要查找的值，如果找到返回对应下表，否则返回-1
|... \| eval n=mvfind(mymvfield, "err")
|mvindex(X,start[, end])
|X为多值类型的参数，如果无end参数，则返回下表为start的元素，如果start不合法则返回null，否则返回从下标start到下标end（不包括）元素组成列表，如果下表范围不合法返回空数组，
NOTE: 数组下表从0开始
|... \| eval v = mvindex(mv, 10, -1)
|mvjoin(X,DELIMITER)
|将多值字段X的值使用分隔符DELEMITER组成一个字符串
|eval v = mvjoin(mv, ", ")
|mvmap(X,mapexpr)
|X为多值类型，mapexpr为转换的表达式，使用_x表示X中的单个值，返回的多值类型为X中的每个元素使用mapexpr转换得到的值组成的多值类型
|... \| eval x = mvmap(X, tolong(_x) + 2)
设X = ["1", "3", "4"]
则x = [3, 5, 6]
|mvdelta(X)
|X为多值类型，该函数按顺序计算当前的值与前一个值的差,写入一个新的多值字段中，返回新的多值字段
|... \| eval x = mvdelta(X)
设X = ["1", "3", "4"]
则x = [2, 1]
|mvrange(X,Y[,Z])
|该函数使用一个数值的区间生成一个多值字段，其中X表示区间起始值，Y表示区间结束值（不包括），Z表示步跳数，默认为1
|下例返回 1, 3, 5, 7.
... \| eval mv=mvrange(1,8,2)
|mvsort(X)
|对多值字段进行排序
|... \| eval s=mvsort(mv)
|mvszip(X,Y[,"Z"])
|X和Y都为多值类型，将X中的第一个元素和Y中的第一个元素都转换为字符串，并以Z为分隔符进行拼接，得到返回结果多值结果的第一个元素，类型为字符串，然后按照同样方法对X的第二个元素和Y中的第二个元素进行拼接，以此类推得到一个多值的结果。如果X和Y的长度不等，则当X或者Y处理完最后一个元素后不再进行拼接。
|X = [1, 3, 4, 7]
Y = [2, 5, 8]
mvszip(X, Y) = ["1,2", "3,5", "4,8"]
|split(S, SEP)
|X为字符串类型，使用字符串SEP分割符对S进行拆分成多值类型，如果SEP为空字符串，则S将被拆分为单字组成的多值类型
|如X = ":abc::edf: "
则split(X, ":") = ["", "abc", "", "edf", " "]
|now()
|函数用于表示当前时间，实际值为搜索请求收到的时间，在一个请求中多次调用返回的是同一个值，值为1970-01-01:00:00:00到当前时间的毫秒数，类型为long
|示例:
...\|eval current_time = now()
|parsedate(X, Y[, Z])
|解析日期时间串为unix时间戳
X为日期的字符串，Y为日期的格式说明，遵循java.text.SimpleDateFormat支持的时间格式，Z为可选参数，指定Locale，默认为en（english）
|示例：
parsedate("28/04/2016:12:01:01""dd/MM/yyyy:HH:mm:ss");parsedate("28/四月/2016", "dd/MMM/yyyy", "zh")其中zh表示中文的Locale;parsedate("2017-January-01", "yyyy-MMMM-dd", "UTC", "en")其中UTC代表时区，en表示英文的Locale
|printf(FORMAT, [X...])
|格式化字符串(格式)
v|示例: printf("%.1fMB", rate)输出速率，rate保留小数点后一位
printf(“%s ⇒ %s", "aa", "bb")输入"aa ⇒ bb"
NOTE: 变量类型和printf中%x需要对应正确，否则可能导致计算失败，⽽输出空值
|relative_time(X, Y)
|字段X必须是时间类型，字段Y必须为一个date math(请参考时间格式一节)的相对时间值，返回基于时间戳X的date math的计算结果
|示例：
... \| eval ts = relative_time(timestamp, "-1d/d")
返回得到timestamp所代表的时间减去1天的毫秒数，并圆整到0点，即timestamp表示的日期的前一天的零点。
|round(X [,Y])
|把数值X近似到小数点后Y位;Y参数默认值为0，即近似为整数(round会把X近似为“最近的值”;当距离相同时，近似为更⼤的值)
v|示例: round(3.14)输出3;
round(3.1415,3)输出3.142;
注:当round(-1.5)输出-1;round(1.5)输出2
|substring(X, Y[, Z])
|此函数接收三个参数，其中X必须为字符串，Y和Z是数字（Y和Z从0开始），返回X的子字符串，返回X的第Y个字符到第Z个（不包括）字符之间的字符 ，如果不指定Z则返回Y位置开始的剩余字符串
|以下示例返回"bce"
... \| eval subs = substring("abcedfg", 1, 4)
|todouble(X)
|该函数接受一个参数，可以是字符串或者数值型，返回对应的双浮点数的值
|以下示例返回123.1
... \| eval value = todouble("123.1")
|tonumber
|tonumber(numStr[, base])
|将数字或字符串转化为数值类型，并可将2-36进制转换为10进制，base默认为10进制
|tolong(X)
|该函数接受一个参数，字符串或者数值类型，返回对应的long值，X为10进制
|以下示例返回123
... \| eval value=tolong("123")
|tostring(X)
|该函数接收一个参数，可以是字符串或者数值类型，返回对应的字符串的值
|以下示例返回”123.1”
... \| eval strv = tostring(123.1)
|tojson(X)
|该函数接收一个任意类型的参数，返回对应的 json 字符串
|假设 a = [1,2,3],那么 "[1,2,3]" 是命令 ...\|eval json_str = tojson(a)的结果
|trim(X)
|该函数接受一个字符串类型的参数，返回X前后去除空白符的字符串值
|以下示例返回" bcd ef"
... \| eval strv = trim("  bcd ef   \t")
|ltrim(X[, Y])
|该函数接受一个字符串类型的参数，返回X去除左边空白符的字符串值。或者接收两个字符串类型的参数,用Y字符串从左侧去除在Y中出现过的字符,直到遇到第一个不在Y中的字符为止。
|以下示例返回"yi"
... \| eval strv = ltrim("rizhiyi", "irhz")
|rtrim(X[, Y])
|该函数接受一个字符串类型的参数，返回X去除右边空白符的字符串值。或者接收两个字符串类型的参数,用Y字符串从右侧去除在Y中出现过的字符,直到遇到第一个不在Y中的字符为止。
|以下示例返回"rizhiy"
... \| eval strv = rtrim("rizhiyi", "irhz")
|replace(,,)
|此函数用replacement字符串替换字符串str中每次出现的regex。
|以下示例会将月份和日期数字调换位置。如果输入为 1/14/2020 ，则返回值为 14/1/2020。
... \| eval n=replace(date, "^(\d{1,2})/(\d{1,2})/", "\2/\1/")
|typeof(X)
|获取字段X的类型
支持类型为: long, double, int, float, short, string, object, array, bool
如果字段为null，则返回null
|示例：
... \| eval a_type = typeof(apache.method)
|upper(X)
|函数接收一个字符串类型的参数，返回X的大写形式
|以下示例返回GET
... \| eval strv = upper("Get")
|urlencode(X)
|对字段X的值执行URL编码，字段X必须为字符串
NOTE: 目前还不支持指定字符编码
|示例:
... \| eval url = urlencode(url)
|urldecode(X)
|对字段X的值执行URL解码，字段X必须为字符串
NOTE: 目前还不支持指定字符编码
|示例:
... \| eval url = urldecode(url)
|base64encode(X)
|对字段X的值执行base64编码，字段X必须为字符串
|示例:
... \| eval base64 = base64encode(base64)
|base64decode(X)
|对字段X的值执行base64解码，字段X必须为字符串
|示例:
... \| eval base64 = base64decode(base64)
|unicodeencode(X)
|对字段X的值执行unicode编码，字段X必须为字符串
|示例:
... \| eval unicode = unicodeencode(unicode)
|unicodedecode(X)
|对字段X的值执行unicode解码，字段X必须为字符串
|示例:
... \| eval unicode = unicodedecode(unicode)
|md5(X)
|对字段进行MD5编码
|示例:
... \| eval a = md5(X)
|sha1(X)
|对字段进行SHA1编码
|示例:
... \| eval a = sha1(X)
|sha256(X)
|对字段进行SHA256编码
|示例:
... \| eval a = sha256(X)
|sha512(X)
|对字段进行SHA512编码
|示例:
... \| eval a = sha512(X) 
|ip2long(X)
|将ip地址转化为long类型的数字
|示例:
... \| eval ipNum = ip2long(X)
|long2ip(X)
|将long类型的数字转化为ip地址
|示例:
... \| eval ip = long2ip(X)
|cidr2long(X)
|将cidr路由转化为两个long类型的ip起止数字
|示例:
... \| eval ip_range = cidr2long(X)
|is_valid_mac(X)
|判断是否为有效的mac地址，目前只支持六组冒号或横杠分隔的地址
|示例:
... \| eval is_valid_mac = is_valid_mac(X)
|is_valid_ip(X)
|判断是否为有效的ip地址
|示例:
... \| eval is_valid_ip = is_valid_ip(X)
|is_valid_mask(X)
|判断是否为有效的子网掩码，在[0, 32]之间
|示例:
... \| eval is_valid_mask = is_valid_mask(X)
|is_valid_cidr(X)
|判断是否为有效的cidr地址
|示例:
... \| eval is_valid_cidr = is_valid_cidr(X)
|expand_ip_range_to_cidr(X, Y [,Z])
|将两个ip起止地址转化为cidr地址，X为ip起始地址，Y为ip终止地址，Z为可选参数cleanSingleIps，如果是true代表mask是32的cidr会去掉mask，否则不去掉，默认为false。
|示例:
... \| eval cidr = expand_ip_range_to_cidr("192.168.1.1", "192.168.1.15")
; 或 ... \| eval cidr = expand_ip_range_to_cidr("192.168.1.1", "192.168.1.15", true)
... \| eval cidr = expand_ip_to_cidr(X)
; 或 ... \| eval cidr = expand_ip_to_cidr(X, true)
|like(X, Y)
|接收两个参数，X为一个字符串，Y是一个表达式。当X与Y匹配时，此函数返回true,否则返回false。表达式Y支持精确文本匹配，以及单字符_和多字符%匹配。
|示例:
... \| eval is_like = like(X, "a%bc")
|isnotnull(X)
|判断是否不为null。当X不为null时，返回true
|示例:
... \| eval is_not_null = isnotnull(X)
|isblank(X)
|判断是否为null或仅包含空白字符
|示例:
... \| eval is_blank = isblank(X)
|islong(X)
|判断是否为long类型字段
|示例:
... \| eval is_long = islong(X)
|isbool(X)
|判断是否为boolean类型字段
|示例:
... \| eval is_bool = isbool(X)
|=====