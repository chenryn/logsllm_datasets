###  2）高层概述
本研究想尽可能合理地推理智能合约。这涉及到包含多个合约交互的EVM的精确模型。但是，就像所有静态分析器一样，必须选择要精确建模的模型和过高近似的模型。决定既不对共识协议以及gas使用量建模，保证无效交易不会被执行，因此不会影响智能合约状态。而且要分析的代码必须在实践中可执行，即它必须具有合理的耗gas量。
将EVM建模为抽象状态机（ASM）Γ，提供了执行上下文，在该上下文中可以推断合约的执行情况。
ASMΓ以字节码数组Σ作为输入，即合约代码，并从第一条指令开始执行。完成执行后，机器将返回所有停止状态σh的集合，即Γ达到非异常停止条件的所有状态的集合，如黄皮书所定义。
另外定义了一个状态σ=（µ，pc，Π），其中µ表示堆栈，pc是指向下一条指令的程序计数器，Π是给定路径的路径约束集。还将µ[0]定义为堆栈的第一个（最顶部）参数，将µ[1]定义为第二个参数，依此类推。
###  3）环境建模
想在执行者中建立一个丰富的环境模型（即世界状态）。因此，将帐户状态定义为元组α=（balance _,_ code _,_
storage）。其中balance是一个符号值，表示帐户余额。
code是属于帐户的（可选）代码，storage是256位至256位键值存储，其中包含持久帐户状态（也是可选的）。
另外，将事务（tx）定义为元组（origin, recipient, callvalue, calldata, calldatasize）。
origin是交易的原始帐户地址，recipient是收件人，callvalue是附加在交易中的值，calldata是附加在交易中的（可选）calldata，并且calldatasize是代表变量大小的符号变量。
calldata数组（还是可选的）。
通过添加一个映射帐户来扩展Γ的定义：address→α映射帐户地址到它们各自的状态，即世界状态。此外，介绍了代表系统中所有已发行交易的设置交易。分析特定合约时，设置了一个攻击者帐户和（可能有多个）受害者帐户计数。然后模拟交易链t1，t2，…，tk。对于每笔交易，执行完整的Γ运算，得出停止状态σh。然后，对于每个σi∈σh，分叉执行并继续下一个tj直到tk。
###  4）内存模型
####  （a）内存图
该图本身用于跟踪对内存的所有修改。它从一个初始节点开始，并在每次对内存的读/写操作时进行更新。更正式地讲，引入存储所有存储节点的内存图∆
=（V，E），并将其添加到状态定义中，即σ=（µ，pc，Π，∆）。为每个节点分配一个唯一的索引。因此，将索引为i的节点表示为ni。此外为每个节点分配一个标签，即初始化标签或内存更改操作（写，复制或设置），以跟踪创建该节点的操作。
目前，仅考虑一个存储区域，例如存储年龄。从初始节点s0开始，每次创建一个连接到其父节点su的新节点st时，每次遇到对内存的写入（例如SSTORE）时都会更新图形。这为在执行期间的任何状态下提供了唯一的内存映像（类似于编译器理论中已知的静态单分配（SSA）形式）。当将内存布局转换为约束时，从最新的节点st开始，以向后遍历图的方式收集所有内存更新，并根据它们的相应标签将它们编码为逻辑公式。这种方法使本文能够推理符号存储操作。
当考虑多个内存区域（例如执行内存和调用数据）时，为每个区域引入一个初始节点，即图以森林开始，并且只要内存操作仅在单个内存区域上运行就保持不变。它可以通过两种不同的方式进行连接。首先，间接地从一个区域加载并存储到另一个区域，并通过约束隐式链接图的两个部分。其次，直接通过内存复制样式操作（例如CALLDATACOPY），通过节点和边明确地链接图形的两个部分。加载和存储会在系统中引入约束，在将内存区域转换为一阶逻辑时链接它们。复制会在目录林的目标树中引入一个新节点（例如，CALLDATACOPY的执行内存）。该节点连接到内存的源区域和目标区域，并显式链接图形的两个部分。
####  （b）常规内存操作
在执行期间，对于每个帐户，都会创建一个新的存储节点nj并将相应的索引存储在其帐户状态α.storage←nj中。同样，每次事务都会创建一个新的呼叫数据并存储其标识符。另外，为ASM分配一个执行内存Γ.m←nk。定义对内存的读写如下：
•∆.write（ni，p，v）→nj：将值v写入以存储节点ni为父节点的地址p，返回新节点nj。
•∆.read（ni，p）7→v：从存储器ni的位置p读取值v。
这使对SSTORE指令的建模变得简单：
)
在此示例中，将值µ[1]写入帐户（α.storage）的当前存储区到地址µ[0]。通过在内存存储区∆中创建一个新的内存节点nj来表示这一点。然后将此新存储节点的索引分配为当前帐户存储α.storage。
由于EVM的字长为256位，因此对其他存储器操作进行建模更加困难。但是，calldata和执行存储器都是可字节寻址的存储器。结果必须在256位和8位多块之间转换。
用µ [i] [0]表示µ [i]的最低字节，用µ [i]
[31]表示最高（最左边）的字节。将MSTORE建模为对执行存储器的32个8位写入序列，从而相应地移动地址和提取的8位大小的块。从执行存储器中读取数据的方法与此类似，在读取索引移位的同时读取8位块，将结果串联起来。
在对CALLDATALOAD建模时，EVM将calldata定义为理论上无界的数组。因此，当存储操作读取超出范围（即，大于calldatasize的位置）时，EVM只是“读取”零。因此，对于每次从calldata读取的操作，将其包装在ite（IF-THEN ELSE）操作中，该操作会限制在提供的地址超出范围时将负载评估为零。
####  （c）支持存储器复制和存储器集样式的指令
EVM提供了多个指令，这些指令的行为类似于内存复制。在∆上定义以下函数：
•∆.set∞（ni，p，v）→v：将存储器ni中的所有值（从位置p开始）设置为值v
•∆.copy（ni，p，nj，q，s）→nk：从节点nj复制一个大小为s的块，从位置q开始直到q + s，复制到节点ni，从位置p开始复制直到位置p +
s
这些函数可实现内存复制式操作并简化内存初始化。存储寿命和执行内存在生命周期开始时均假定为零。利用set∞函数，可以初始化这些区域。
###  5）模拟调用
如前所述，EVM提供合约以相互交互。考虑下图，假设模拟了针对合约A的用户交易。
将首先设置一个ASMA以模拟合约A的执行，从而生成A的执行树。现在假设-在执行期间-遇到了对合约B的消息调用。然后设置ASMB，在整个exe中运行割，然后为每个状态σi∈σh划分执行树。这能够为消息调用模拟每个可能的结果。请注意，该技术可以递归地应用于模拟嵌套消息调用。
同样，在执行DELEGATECALL或CALLCODE指令时，会切换ac计数的代码并按上述概述进行操作。当调用另一个帐户时，EVM使用部分执行内存作为新执行的输入。继续运行示例，当执行从ASMA到ASMB的消息调用时，在∆中创建一个新的calldata节点，然后利用复制函数能复制来自ASMA执行存储器的输入。当ASMB的执行完成时，将部分执行内存从ASMB复制到ASMA，作为返回数据。
###  6）处理Keccak指令
EVM提供了一条特定指令，用于在部分执行存储器上计算keccak-256哈希。然而，过去已经证明这些功能很难进行静态分析。一种常见的技术是使用Ackerman编码，该编码用于编码不可解释的函数。它利用了加密散列函数是绑定函数的事实，即，在相同的输入下，保证该函数产生相同的输出。可以如下利用该属性：
但是，由于EVM在执行内存上计算keccak函数，因此无法直接将这种编码用于本文的目的。遇到keccak计算时，将按以下步骤进行操作：如果所有因变量和内存区域都是常量，则只需计算常量哈希值即可。否则用占位符对象替换结果，该占位符对象存储执行内存的当前映像以及keccak计算的开始和结束地址。当要评估给定执行路径的可行性时，不是直接在输入上编码等式（1），而是为每个内存地址编码。
更正式地说，用三个字段定义元组keccak：（i）keccak.addr，起始内存地址，（ii）keccak.len，要考虑的内存范围的长度，以及（iii）keccak.m，其中是计算时存在的执行内存的索引。使用算法1对所有可能的keccak元组对进行编码。假定要转换为一阶逻辑并添加到路径约束Π的两个不同的元组i和j。首先尝试利用更复杂的编码。但是，在无法争论len参数的情况下（例如，一个参数是不受约束的符号变量），求助于后备编码（第2-3行）。