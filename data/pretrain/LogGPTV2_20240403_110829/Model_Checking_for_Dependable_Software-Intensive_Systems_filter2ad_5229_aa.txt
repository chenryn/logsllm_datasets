title:Model Checking for Dependable Software-Intensive Systems
author:Edmund M. Clarke and
Masahiro Fujita and
David P. Gluch
Developing Dependable Software-Intensive
Systems: AADL vs. EAST-ADL(cid:2)
Andreas Johnsen and Kristina Lundqvist
School of Innovation, Design and Engineering
M¨alardalen University
{andreas.johnsen,kristina.lundqvist}@mdh.se
V¨aster˚as, Sweden
Abstract. Dependable software-intensive systems, such as embedded
systems for avionics and vehicles are often developed under severe qual-
ity, schedule and budget constraints. As the size and complexity of these
systems dramatically increases, the architecture design phase becomes
more and more signiﬁcant in order to meet these constraints. The use of
Architecture Description Languages (ADLs) provides an important basis
for mutual communication, analysis and evaluation activities. Hence, se-
lecting an ADL suitable for such activities is of great importance. In this
paper we compare and investigate the two ADLs – AADL and EAST-
ADL. The level of support provided to developers of dependable software-
intensive systems is compared, and several critical areas of the ADLs are
highlighted. Results of using an extended comparison framework showed
many similarities, but also one clear distinction between the languages
regarding the perspectives and the levels of abstraction in which systems
are modeled.
Keywords: Dependable systems, Software-intensive systems, AADL,
EAST-ADL, Architecture description languages.
1 Introduction
One of the most critical phases in the development process of software-intensive
systems is the architecture design phase. The architecture speciﬁcation repre-
sents a set of design-decisions, which are analyzed and evaluated to ensure con-
formance with the system requirements. The eﬃciency and eﬀectiveness of the
evaluation method is largely dependent on the type of artifact being evaluated.
Hence, the means used to design architectures of dependable software-intensive
systems are critical to ensure quality of the system. Architecture Description
Languages (ADLs) have been developed as means for designing systems’ archi-
tecture.
Software-intensive systems are systems where software interacts with sensors,
actuators, devices, other systems and people [1]. Examples of such systems are
(cid:2) This work was partially supported by the Swedish Research Council (VR), and
M¨alardalen Real-Time Research Centre (MRTC)/M¨alardalen University.
A. Romanovsky and T. Vardanega (Eds.): Ada-Europe 2011, LNCS 6652, pp. 103–117, 2011.
c(cid:2) Springer-Verlag Berlin Heidelberg 2011
104
A. Johnsen and K. Lundqvist
embedded systems for vehicles, medical equipment and avionics. What these sys-
tems have in common is that they often operate in dynamic, time- and safety-
critical environments where the components embedded within the systems are
heterogeneous and have to meet real-time constraints. Two widely used ADLs
within both industry and the research community are the Architecture Analy-
sis and Design Language (AADL) [2], developed by the Society of Automotive
Engineers (SAE), and the Electronics Architecture and Software Technology -
Architecture Description Language (EAST-ADL) [3], initially developed by the
Embedded Architecture and Software Tools - Embedded Electronic Architec-
ture (EAST-EEA) project in the Information Technology for European Advance-
ment (ITEA) programme and further reﬁned by the Advancing Traﬃc Eﬃciency
and Safety through Software Technology (ATESST and ATESST2) projects[4].
EAST-ADL was developed speciﬁcally for automotive systems, and AADL was
initially developed for Avionics but now targets all large-scale software-intensive
embedded systems and systems of systems, such as, aircraft, motorized vehicles,
autonomous systems, and medical devices.
In this paper, we investigate these two ADLs and compare the level of support
they provide developers to ensure correctness of software-intensive systems. An
ADL should support activities – or tools performing activities – such as analysis,
V&V, model checking (formal veriﬁcation), code generation/synthesis, etc., by
providing multiple perspectives with well deﬁned semantics. At the same time,
an ADL should support understandability and communication among stake-
holders, by providing multiple levels of abstraction [5]. Generally, ADLs do not
support both parts [6], which is critical for dependable systems since both parts
contribute to systems’ correctness.
The comparison is performed by applying an extension of Medvidovic and
Taylor’s ”classiﬁcation and comparison framework for software architecture de-
scription languages” [6]. In order to be able to compare AADL and EAST-ADL,
Medvidovic and Taylor’s framework is expanded with aspects of hardware archi-
tectures and typical quality attributes of software-intensive systems, which are
timing and dependability.
The extended framework will be presented in Section 2, before overviews of
the languages under comparison is given in Section 3. The results of applying the
ADLs to the extended framework are presented in Section 4, which is followed
by conclusions in Section 5.
2 The Comparison Framework
Medvidovic and Taylor developed a framework [6] for classiﬁcation and compar-
ison of software ADLs. In this paper, we extend their framework with hardware
architecture aspects and vital quality-attributes of software-intensive systems.
The new framework consists of, as in the original framework, a set of building
blocks and their features (depicted in Table 1) that an ADL should provide. The
main building blocks are components, connectors and conﬁgurations, where
these components, in order to interchange architectural information, must have
Developing Dependable Software-Intensive Systems: AADL vs. EAST-ADL
105
Table 1. ADL Building Blocks (bold), their Features (italic) and vital quality-
attributes
ADL: Building Blocks and Features
Components
Interface, Types, Semantics, Requirements, Evolution, Non-functional properties
Connectors
Interface, Types, Semantics, Requirements, Evolution, Non-functional properties
Conﬁgurations
Understandability, Compositionality, Reﬁnement and traceability, Heterogeneity,
Scalability, Evolution, Requirements, Non-functional properties
ADL: Vital Quality Attributes
Dependability
Timing
interfaces. Connectors are the interactions within the architecture whereas con-
ﬁgurations deﬁne how each building block is combined to form an architecture
description.
Architectures of software-intensive systems can be represented by these build-
ing blocks, which are abstractions of architectural elements. The framework
developed by Medvidovic and Taylor restricts these building blocks to be ab-
stractions of architectural elements of software. The extensions are reﬂected in
the deﬁned restrictions (given in section 2.1, 2.2, 2.3) of what the building blocks
are abstractions of, which are: architectural elements of software, architectural
elements of hardware and architectural elements of software mapped on hard-
ware.
Within following subsections, an overview of each architecture building block,
their features and the vital quality attributes is given.
2.1 Building Block: Component
Components are abstractions of main hardware/execution platform-units,
computational software-units or composition of software and hardware-units.
Computational software units refer to procedures/functions as well as entire ap-
plications. Main hardware/execution platform-units refer to complex hardware
that may be associated with software to complete its functionality. Examples of
such units are: sensors, actuators, processors, memories and communication links
such as buses. Composition of software and hardware units refer to systems where
computational software units are mapped to main hardware/execution platform
units (e.g. ﬂight control system, GPS system, electronic cruise control system,
etc.). Components interact through their interfaces which are logical points of
interactions between a component and its environment. An interface of a com-
ponent describes the services a component provides and requires. The behavior
model of a component, which here is referred to as component semantics, is an
important feature of a component since it describes requirements and provides
information for analysis and V&V activities. Components that are encapsulated
106
A. Johnsen and K. Lundqvist
within a certain subset of semantics and properties are here referred to as a
component type, which can be instantiated several times within an architecture.
Component types facilitates the ability to understand and analyze architectures
since instances of a component type have common properties. Types are most
often created by extensible type systems within ADLs, but built-in component
types should also be provided. Components should be able to be modeled with
external and internal properties specifying unacceptable borders, which we here