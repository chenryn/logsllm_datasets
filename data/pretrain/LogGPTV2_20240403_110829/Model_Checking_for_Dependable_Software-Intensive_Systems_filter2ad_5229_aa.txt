# Title: Model Checking for Dependable Software-Intensive Systems
# Authors: Edmund M. Clarke, Masahiro Fujita, and David P. Gluch

## Abstract
Dependable software-intensive systems, such as those used in avionics and vehicles, are often developed under stringent quality, schedule, and budget constraints. As the size and complexity of these systems increase, the architecture design phase becomes increasingly critical to meet these constraints. Architecture Description Languages (ADLs) provide a vital foundation for communication, analysis, and evaluation activities. Therefore, selecting an appropriate ADL is crucial. In this paper, we compare and investigate two ADLs: AADL and EAST-ADL. We evaluate the level of support they provide for developers of dependable software-intensive systems and highlight several critical areas. Our results, based on an extended comparison framework, reveal many similarities but also a clear distinction between the languages regarding the perspectives and levels of abstraction in which systems are modeled.

**Keywords:** Dependable systems, Software-intensive systems, AADL, EAST-ADL, Architecture description languages.

## 1. Introduction
The architecture design phase is one of the most critical stages in the development of software-intensive systems. The architecture specification represents a set of design decisions that must be analyzed and evaluated to ensure conformance with system requirements. The effectiveness of the evaluation method depends largely on the type of artifact being evaluated. Thus, the tools and methods used to design architectures of dependable software-intensive systems are essential for ensuring system quality. Architecture Description Languages (ADLs) have been developed to facilitate the design of system architectures.

Software-intensive systems are characterized by significant interaction between software and various components, including sensors, actuators, devices, other systems, and people [1]. Examples include embedded systems for vehicles, medical equipment, and avionics. These systems often operate in dynamic, time-critical, and safety-critical environments, where the embedded components are heterogeneous and must meet real-time constraints.

Two widely used ADLs in both industry and academia are the Architecture Analysis and Design Language (AADL) [2], developed by the Society of Automotive Engineers (SAE), and the Electronics Architecture and Software Technology - Architecture Description Language (EAST-ADL) [3], initially developed by the Embedded Architecture and Software Tools - Embedded Electronic Architecture (EAST-EEA) project in the Information Technology for European Advancement (ITEA) program and further refined by the Advancing Traffic Efficiency and Safety through Software Technology (ATESST and ATESST2) projects [4].

EAST-ADL was specifically designed for automotive systems, while AADL, initially developed for avionics, now targets large-scale software-intensive embedded systems and systems of systems, such as aircraft, motorized vehicles, autonomous systems, and medical devices.

In this paper, we investigate and compare these two ADLs, focusing on the level of support they provide to developers to ensure the correctness of software-intensive systems. An ADL should support activities like analysis, verification and validation (V&V), model checking (formal verification), and code generation/synthesis by providing multiple perspectives with well-defined semantics. Additionally, an ADL should support understandability and communication among stakeholders by providing multiple levels of abstraction [5]. Generally, ADLs do not fully support both aspects [6], which is critical for dependable systems since both contribute to system correctness.

We perform the comparison using an extension of Medvidovic and Taylor's "classification and comparison framework for software architecture description languages" [6]. To compare AADL and EAST-ADL, we expand their framework to include aspects of hardware architectures and typical quality attributes of software-intensive systems, such as timing and dependability.

The extended framework is presented in Section 2, followed by overviews of the languages in Section 3. The results of applying the ADLs to the extended framework are presented in Section 4, and conclusions are provided in Section 5.

## 2. The Comparison Framework
Medvidovic and Taylor developed a framework [6] for classifying and comparing software ADLs. In this paper, we extend their framework to include hardware architecture aspects and key quality attributes of software-intensive systems. The new framework consists of building blocks and their features (Table 1) that an ADL should provide. The main building blocks are components, connectors, and configurations, which must have interfaces to exchange architectural information. Connectors represent the interactions within the architecture, while configurations define how each building block is combined to form an architecture description.

Architectures of software-intensive systems can be represented by these building blocks, which are abstractions of architectural elements. The original framework by Medvidovic and Taylor restricts these building blocks to be abstractions of software architectural elements. Our extensions reflect the defined restrictions (Section 2.1, 2.2, 2.3) of what the building blocks are abstractions of, including software, hardware, and software mapped onto hardware.

### 2.1 Building Block: Component
Components are abstractions of main hardware/execution platform units, computational software units, or compositions of software and hardware units. Computational software units refer to procedures/functions and entire applications. Main hardware/execution platform units refer to complex hardware that may be associated with software to complete its functionality, such as sensors, actuators, processors, memories, and communication links. Compositions of software and hardware units refer to systems where computational software units are mapped to main hardware/execution platform units (e.g., flight control systems, GPS systems, electronic cruise control systems).

Components interact through their interfaces, which are logical points of interaction between a component and its environment. An interface describes the services a component provides and requires. The behavior model of a component, referred to as component semantics, is crucial as it describes requirements and provides information for analysis and V&V activities. Components encapsulated within a certain subset of semantics and properties are referred to as component types, which can be instantiated multiple times within an architecture. Component types facilitate understanding and analysis since instances of a component type share common properties. Types are often created by extensible type systems within ADLs, but built-in component types should also be provided. Components should be modeled with external and internal properties specifying unacceptable borders, which we refer to as non-functional properties.