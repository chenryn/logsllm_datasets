technique to monitor user activities such as application in-
stall and removal, web browser history, calendar, call log or
contact lists.
Android Taint Tracking: Dynamic taint tracking and
information ﬂow analysis techniques for Android [31, 25,
65, 62] have been proposed to detect information leak or
privilege escalation attacks. Their approaches ﬁrst assign
tags to provenance sources (e.g., private data objects) and
propagates the tags at each instruction through dependen-
cies captured during the system execution. They can detect
provenance tags that reaches a sink node (e.g., outgoing net-
work socket, SMS message send) that indicate the leakage
of private information. Taint tracking techniques usually re-
quire instruction-level monitoring that causes high run-time
overhead and often requires emulator-based instrumentation
platform such as QEMU [22]. Taint tracking only shows
the ﬂow of the data (what-provenance), but forensic analy-
sis including DroidForensics captures both what- and how-
provenance. Our system is designed for forensic logging, and
comparing with taint tracking techniques, our solution di-
rectly works on real Android devices and has less runtime
overhead.
Other Android Analysis Techniques: Static Analysis
techniques [47, 50, 34, 25, 20] can be used to understand the
behaviors of Android applications. They use APK or Java
code analyzer to detect potentially malicious behaviors from
Android source code. These static techniques are comple-
mentary to DroidForensics. For example, we can use static
analysis as a hint and enhance runtime forensic logging for
potentially malicious code regions.
Android memory forensics techniques [60, 59, 19] recon-
struct the application or device states from a smartphone’s
memory image. Their goal is to recover the current (when
the memory was dumped) state of the device to allow the
user to acquire important evidences such as photo, applica-
tion UIs, or authentication credentials. DroidForensics com-
plements these techniques by logging runtime behaviors of
application to reconstruct the execution. Zhang et al. [67]
proposed a machine learning approach that analyzes net-
work traﬃc on Android devices to detect stealthy Android
malware activities.
Recording-and-replay based attack forensics are very use-
ful because the user can replay the malicious execution as
many time as he wants. Recently, record-and-replay tech-
niques for Android applications have been studied in the
software engineering community to aid in application de-
bugging [36, 39, 40, 55]. RERAN [36] and Mosaic [39]
use Android SDK’s getevent tool to capture low-level event
streams including graphical user interface (GUI) gestures
(e.g., swipe, zoom, pinch, multi-touch) and sensor events.
However, they are not able to replay inputs from other de-
vices such as GPS, microphone or network. Furthermore,
they are not able to record-and-replay sophisticated activ-
ities [33, 58, 23, 26], as they only record stream inputs.
VALERA [40] statically instruments APK ﬁles to capture
Android API calls. It leverages a bytecode rewriting tool to
record and replay API calls. However, VALERA does not
support native code execution [61, 17, 56, 52] and dynamic
code loading [54, 68, 32, 57]. Mobiplay [55] is a client-server
based recording and replay system. Android applications
10
675run on a server that emulates the exact same environment
as the mobile phone, and the server transfers a GUI display
to the mobile device that the user interacts with.
7. CONCLUSION
In this paper, we have presented DroidForensics, a multi-
layer forensic logging technique for Android. DroidForensics
captures important Android events from Android API, Binder
and system calls layers. API logger collects information
about Android API calls that contain high-level semantics of
an application. Binder logger captures inter-process commu-
nications that represent causal relations between processes,
and system call logger eﬃciently monitors low-level system
events. We also develop an easy-to-use interface for An-
droid attack investigation. The user can compose SQL-like
queries to inspect an attack and DroidForensics provides
causal graphs to the user. The user can iteratively reﬁne
queries based on previous results.
Our experiments have shown that DroidForensics has low
runtime overhead (2.9% on avg.) and low space overhead
(up to 168 MByte during 24 hours) on Nexus 6 and Nexus 9
devices. We evaluate DroidForensics with 30 real-world An-
droid malwares and the results show that DroidForensics is
eﬀective in reconstruction of Android attacks. Our compat-
ibility tests present that DroidForensics maintains the same
level of compatibility as original Android.
Acknowledgment
We thank the anonymous reviewers for their insightful com-
ments. This research was, in part, supported by the United
States Air Force and Defense Advanced Research Agency
(DARPA) under Contract No. FA8650-15-C-7562 and funds
from the University of Cincinnati CECH. Any opinions, ﬁnd-
ings, and conclusions or recommendations expressed in this
material are those of the authors and do not necessarily re-
ﬂect the views of our sponsors.
8. REFERENCES
[1] 3dmark. https://www.futuremark.com/benchmarks/
3dmark/android/.
[2] Android compatibility test suite (cts).
https://source.android.com/compatibility/cts/.
[3] Antutu. http://www.antutu.com/en/index.shtml.
[4] Auditdandroid.
https://github.com/nwhusted/AuditdAndroid.
[5] Binder ipc mechanism.
http://www.angryredplanet.com/˜hackbod/
openbinder/docs/html/BinderIPCMechanism.html.
[6] Contagio mobile.
http://contagiominidump.blogspot.com.es/.
[7] Discomakr. https://play.google.com/store/apps/
details?id=ch.ethz.disco.gino.
androidbenchmarkaccessibilityrecorder&hl=en/.
[8] Dtrace. http://dtrace.org/blogs/.
[9] errno - number of last error. http:
//man7.org/linux/man-pages/man3/errno.3.html.
[10] Pcmark for android. https://www.futuremark.com/
benchmarks/pcmark-android/.
[11] Redhat linux audit.
https://people.redhat.com/sgrubb/audit/.
[12] Sysdig. http://www.sysdig.org/.
[13] Tabletmark.
https://bapco.com/products/tabletmark/.
[14] Trojan:android/avpass.c. https://www.f-secure.com/
v-descs/trojan android avpass c.shtml.
[15] Using the linux kernel tracepoints. https://www.
kernel.org/doc/Documentation/trace/tracepoints.txt/.
[16] Y. Aafer, W. Du, and H. Yin. Droidapiminer: Mining
api-level features for robust malware detection in
android. In SecureComm ’13. 2013.
[17] V. Afonso, A. Bianchi, Y. Fratantonio, A. Doupe,
M. Polino, P. d. Geus, C. Kruegel, and G. Vign. Going
native: Using a large-scale analysis of android apps to
create a practical native-code sandboxing policy. In
NDSS ’16.
[18] P. Ammann, S. Jajodia, and P. Liu. Recovery from
malicious transactions. IEEE Trans. on Knowl. and
Data Eng., 2002.
[19] D. Apostolopoulos, G. Marinakis, C. Ntantogian, and
C. Xenakis. Discovering authentication credentials in
volatile memory of android mobile devices. In In
Collaborative, Trusted and Privacy-Aware
e/m-Services, 2015.
[20] D. Arp, M. Spreitzenbarth, H. Malte, H. Gascon, and
K. Rieck. Drebin : Eﬀective and Explainable Detection
of Android Malware in Your Pocket. In NDSS ’14.
[21] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel,
J. Klein, Y. Le Traon, D. Octeau, and P. McDaniel.
Flowdroid: Precise context, ﬂow, ﬁeld, object-sensitive
and lifecycle-aware taint analysis for android apps. In
PLDI ’14.
[22] F. Bellard. Qemu, a fast and portable dynamic
translator. In USENIX ATEC ’05.
[23] A. Bianchi, J. Corbetta, L. Invernizzi, Y. Fratantonio,
C. Kruegel, and G. Vigna. What the app is that?
deception and countermeasures in the android user
interface. In S&P ’15.
[24] K. D. Bowers, C. Hart, A. Juels, and
N. Triandopoulos. PillarBox: Combating
Next-Generation Malware with Fast Forward-Secure
Logging. In RAID ’14.
[25] Y. Cao, Y. Fratantonio, A. Bianchi, M. Egele,
C. Kruegel, G. Vigna, and Y. Chen. EdgeMiner:
Automatically Detecting Implicit Control Flow
Transitions through the Android Framework. In NDSS
’15.
[26] Q. A. Chen, Z. Qian, and Z. M. Mao. Peeking into
your app without actually seeing it: Ui state inference
and novel android attacks. In Usenix Security ’14.
[27] J. Chow, B. Pfaﬀ, T. Garﬁnkel, K. Christopher, and
M. Rosenblum. Understanding data lifetime via whole
system simulation. In SSYM’04.
[28] CVE-2015-3864. https://cve.mitre.org/cgi-bin/
cvename.cgi?name=CVE-2015-3864.
[29] D. Devecsery, M. Chow, X. Dou, J. Flinn, and
P.M. Chen. Eidetic Systems. In OSDI ’14
[30] M. Dietz, A. Shu, and D. S. Wallach. Quire :
Lightweight Provenance for Smart Phone Operating
Systems. In Usenix Security ’11.
[31] W. Enck, P. Gilbert, S. Han, V. Tendulkar, B.-G. . G.
Chun, L. P. Cox, J. Jung, P. McDaniel, and A. N.
Sheth. TaintDroid: an information-ﬂow tracking
system for realtime privacy monitoring on
smartphones. In OSDI’10.
11
676[32] L. Falsina, Y. Fratantonio, S. Zanero, C. Kruegel,
G. Vigna, and F. Maggi. Grab ’n run: Secure and
practical dynamic code loading for android
applications. In ACSAC ’15.
[33] E. Fernandes, Q. Chen, J. Paupore, G. J. Essl,
A. Halderman, Z. M. Mao, and A. Prakash. Android ui
deception revisited: Attacks and defenses. In FC ’16.
[34] Y. Fratantonio, A. Bianchi, W. Robertson, E. Kirda,
C. Kruegel, and G. Vigna. Triggerscope: Towards
detecting logic bombs in android applications. In S&P
’16.
[35] A. Goel, K. Po, K. Farhadi, Z. Li, and E. de Lara.
The taser intrusion recovery system. In SOSP ’05.
[36] L. Gomez, I. Neamtiu, T. Azim, and T. Millstein.
Reran: Timing- and touch-sensitive record and replay
for android. In ICSE ’13.
[37] M. Grace, Y. Zhou, Z. Wang, and X. Jiang.
Systematic detection of capability leaks in stock
android smartphones. In NDSS ’12.
[38] J. Grover. Android forensics: Automated data
collection and reporting from a mobile device. Digit.
Investig., 2013.
[39] M. Halpern, Y. Zhu, R. Peri, and V. J. Reddi. Mosaic:
cross-platform user-interaction record and replay for
the fragmented android ecosystem. In ISPASS ’15.
[40] Y. Hu, T. Azim, and I. Neamtiu. Versatile yet
lightweight record-and-replay for android. In OOPSLA
’15.
[41] X. Jiang, A. Walters, D. Xu, E. H. Spaﬀord,
F. Buchholz, and Y.-M. Wang. Provenance-aware
tracing ofworm break-in and contaminations: A
process coloring approach. In ICDCS ’06.
[42] T. Kim, X. Wang, N. Zeldovich, and M. F. Kaashoek.
Intrusion recovery using selective re-execution. In
OSDI’10.
[43] S. T. King and P. M. Chen. Backtracking intrusions.
In SOSP ’03.
[44] S. T. King, Z. M. Mao, D. G. Lucchetti, and P. M.
Chen. Enriching intrusion alerts through multi-host
causality. In NDSS ’05.
[45] K. H. Lee, X. Zhang, and D. Xu. High accuracy attack
provenance via binary-based execution partition. In
NDSS ’13.
[46] K. H. Lee, X. Zhang, and D. Xu. Loggc: garbage
collecting audit log. In CCS ’13.
[47] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. Chex:
Statically vetting android apps for component
hijacking vulnerabilities. In CCS ’12.
[48] S. Ma, K. H. Lee, C. H. Kim, J. Rhee, X. Zhang, and
D. Xu. Accurate, low cost and instrumentation-free
security audit logging for windows. In ACSAC ’15.
[49] S. Ma, X. Zhang, and D. Xu. Protracer: Towards
practical provenance tracing by alternating between
logging and tainting. In NDSS ’16.
[50] C. Mann and A. Starostin. A framework for static
detection of privacy leaks in android applications. In
SAC ’12.
[51] G. A. Marson and B. Poettering. Practical secure
logging: Seekable sequential key generators. In
ESORICS ’13.
[52] C. Mulliner, W. Robertson, and E. Kirda.
Virtualswindle: An automated attack against in-app
billing on android. In AsiaCCS ’14.
[53] J. Newsome and D. X. Song. Dynamic taint analysis
for automatic detection, analysis, and
signaturegeneration of exploits on commodity
software. In NDSS ’05.
[54] S. Poeplau, Y. Fratantonio, A. Bianchi, C. Kruegel,
and G. Vigna. Execute this! analyzing unsafe and
malicious dynamic code loading in android
applications. In NDSS ’14.
[55] Z. Qin, Y. Tang, E. Novak, and Q. Li. Mobiplay: A
remote execution based record-and-replay tool for
mobile applications. In ICSE ’16.
[56] V. Rastogi, Y. Chen, and X. Jiang. Catch me if you
can: Evaluating android anti-malware against
transformation attacks. Trans. Info. For. Sec., 2014.
[57] V. Rastogi, R. Shao, Y. Chen, X. Pan, S. Zou, and
R. Riley. Are these ads safe: Detecting hidden attacks
through the mobile app-web interfaces. In NDSS ’16.
[58] C. Ren, Y. Zhang, H. Xue, T. Wei, and P. Liu.
Towards discovering and understanding task hijacking
in android. In Usenix Security ’15.
[59] B. Saltaformaggio, R. Bhatia, Z. Gu, X. Zhang, and
D. Xu. Guitar: Piecing together android app guis from
memory images. In CCS ’15.
[60] B. Saltaformaggio, R. Bhatia, X. Zhang, D. Xu, and
G. G. R. III. Screen after previous screens:
Spatial-temporal recreation of android app displays
from memory images. In Usenix Security ’16.
[61] M. Sun and G. Tan. Nativeguard: Protecting android
applications from third-party native libraries. In
WiSec ’14.
[62] M. Sun, T. Wei, and J. C.S.Lui. TaintART: A
Practical Multi-level Information-Flow Tracking
System for Android RunTime. In CCS ’16.
[63] K. Tam, S. J. Khan, A. Fattori, and L. Cavallaro.
CopperDroid: Automatic Reconstruction of Android
Malware Behaviors. In NDSS ’15.
[64] F. Wei, S. Roy, X. Ou, and Robby. Amandroid: A
precise and general inter-component data ﬂow analysis
framework for security vetting of android apps. In
CCS ’14.
[65] M. Xia, L. Gong, Y. Lyu, Z. Qi, and X. Liu. Eﬀective
real-time android application auditing. In S&P ’15.
[66] L. K. Yan and H. Yin. DroidScope : Seamlessly
Reconstructing the OS and Dalvik Semantic Views for
Dynamic Android Malware Analysis. In Usenix
Security ’12.
[67] H. Zhang, D. D. Yao, and N. Ramakrishnan.
Causality-based sensemaking of network traﬃc for
android application security. In AISec ’16.
[68] Y. Zhauniarovich, M. Ahmad, O. Gadyatskaya,
B. Crispo, and F. Massacci. Stadyna: Addressing the
problem of dynamic code updates in the security
analysis of android applications. In CODASPY ’15.
[69] Y. Zhou and X. Jiang. Detecting passive content leaks
and pollution in android applications. In NDSS ’12.
12
677