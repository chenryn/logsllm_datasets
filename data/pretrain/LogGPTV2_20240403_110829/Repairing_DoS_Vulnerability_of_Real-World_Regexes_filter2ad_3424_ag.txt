Technologies, vol. 9, no. 3, pp. 222–232, 2014.
[17] Y. Liu, M. Zhang, and W. Meng, “Revealer: Detecting and exploiting
regular expression denial-of-service vulnerabilities,” in 2021 2021 IEEE
Symposium on Security and Privacy (SP). Los Alamitos, CA, USA:
IEEE Computer Society, may 2021, pp. 1468–1484. [Online]. Available:
https://doi.ieeecomputersociety.org/10.1109/SP40001.2021.00062
[18] J. C. Davis, “The impact of regular expression denial of service
in practice,” 2018, https://infosecwriteups.com/introduction-
(redos)
987fdc4c7b0 [Online; accessed 10-December-2021].
[19] R. Alquezar and A. Sanfeliu, “Incremental grammatical inference from
positive and negative data using unbiased finite state automata,” in
In Proceedings of
the ACL’02 Workshop on Unsupervised Lexical
Acquisition, 1994, pp. 291–300.
[20] M. Lee, S. So, and H. Oh, “Synthesizing regular expressions
introductory automata assignments,” SIGPLAN
[Online]. Available:
from examples for
Not., vol. 52, no. 3, pp. 70–80, Oct. 2016.
https://doi.org/10.1145/3093335.2993244
[21] A. Bartoli, G. Davanzo, A. D. Lorenzo, E. Medvet, and E. Sorio,
“Automatic synthesis of regular expressions from examples,” Computer,
vol. 47, no. 12, pp. 72–80, dec 2014.
[22] R. Pan, Q. Hu, G. Xu, and L. D’Antoni, “Automatic repair of regular
expressions,” Proc. ACM Program. Lang., vol. 3, no. OOPSLA, Oct.
2019. [Online]. Available: https://doi.org/10.1145/3360565
[23] Q. Chen, X. Wang, X. Ye, G. Durrett, and I. Dillig, “Multi-modal
synthesis of regular expressions,” in Proceedings of
the 41st ACM
SIGPLAN International Conference on Programming Language Design
and Implementation, PLDI 2020, London, UK, June 15-20, 2020, A. F.
Donaldson and E. Torlak, Eds. ACM, 2020, pp. 487–502. [Online].
Available: https://doi.org/10.1145/3385412.3385988
[24] Y. Li, Z. Xu,
J. Cao, H. Chen, T. Ge, S.-C. Cheung, and
H. Zhao, “Flashregex: Deducing anti-redos regexes from examples,”
in Proceedings of
the 35th ACM/IEEE International Conference
on Automated Software Engineering, ASE 2020, Virtual Event,
Australia,
2020,
[Online]. Available:
https://doi.org/10.1145/3324884.3416556
September
21-25,
2020.
[25] J. E. F. Friedl, Mastering Regular Expressions: Understand Your Data
and Be More Productive (3th ed.). O’Reilly Media, 2006.
[26] D. D. Freydenberger, “Extended regular expressions: Succinctness and
decidability,” Theory of Computing Systems, vol. 53, no. 2, pp. 159–193,
2013. [Online]. Available: https://doi.org/10.1007/s00224-012-9389-0
[27] C. Koch and S. Scherzinger, “Attribute grammars for scalable query
processing on xml streams,” The VLDB Journal, vol. 16, no. 3, pp.
317–342, Jul. 2007. [Online]. Available: https://doi.org/10.1007/s00778-
005-0169-1
[28] A.
Br¨uggemann-Klein
and
D. Wood,
regular
142,
http://www.sciencedirect.com/science/article/pii/S089054019792695X
Computation,
[Online].
languages,”
pp.
Information
182–206,
and
1998.
no.
2,
“One-unambiguous
vol.
Available:
[29] A. Br¨uggemann-Klein, “Unambiguity of extended regular expressions in
sgml document grammars,” in Algorithms—ESA ’93, T. Lengauer, Ed.
Berlin, Heidelberg: Springer Berlin Heidelberg, 1993, pp. 73–84.
[30] G. Tiwari, “HTML/XML tag parsing using regex in Java,” 2011,
http://blog.gtiwari333.com/2011/12/htmlxml-tag-parsing-using-regex-
in-java.html [Online; accessed 10-December-2021].
[31] L. G. Michael, J. Donohue, J. C. Davis, D. Lee, and F. Servant, “Regexes
are hard: Decision-making, difficulties, and risks in programming regular
expressions,” in 2019 34th IEEE/ACM International Conference on
Automated Software Engineering (ASE), Nov 2019, pp. 415–426.
[32] RegExLib, 2021, https://regexlib.com/.
[33] J. Goyvaerts and S. Levithan, Regular Expressions Cookbook (2nd ed.).
O’Reilly Media, 2012.
[34] S. Medeiros, F. Mascarenhas, and R. Ierusalimschy, “From regexes to
parsing expression grammars,” Sci. Comput. Program., vol. 93, pp. 3–18,
2014. [Online]. Available: https://doi.org/10.1016/j.scico.2012.11.006
[35] K. Thompson, “Programming techniques: Regular expression search
algorithm,” Commun. ACM, vol. 11, no. 6, p. 419–422, Jun. 1968.
[Online]. Available: https://doi.org/10.1145/363347.363387
[36] M. Sipser, Introduction to the theory of computation. PWS Publishing
Company, 1997.
[37] R. M. Karp, Reducibility among Combinatorial Problems. Boston,
[Online]. Available:
Springer US,
MA:
https://doi.org/10.1007/978-1-4684-2001-2 9
85–103.
1972,
pp.
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
142073
[38] L. De Moura and N. Bjørner, “Z3: An efficient smt solver,” in Pro-
ceedings of the Theory and Practice of Software, 14th International
Conference on Tools and Algorithms for the Construction and Analysis
of Systems, ser. TACAS’08/ETAPS’08. Berlin, Heidelberg: Springer-
Verlag, 2008, pp. 337–340.
[39] P. Wang and K. T. Stolee, “How well are regular expressions tested
in the wild?” in Proceedings of the 2018 26th ACM Joint Meeting
on European Software Engineering Conference and Symposium on
the Foundations of Software Engineering, ser. ESEC/FSE 2018. New
York, NY, USA: Association for Computing Machinery, 2018, pp.
668–678. [Online]. Available: https://doi.org/10.1145/3236024.3236072
[40] T. Miyazaki and Y. Minamide, “Derivatives of regular expressions with
lookahead,” J. Inf. Process., vol. 27, pp. 422–430, 2019. [Online].
Available: https://doi.org/10.2197/ipsjjip.27.422
[41] B. van der Merwe, N. Weideman, and M. Berglund, “Turning evil
regexes harmless,” in Proceedings of the South African Institute of
Computer Scientists and Information Technologists, ser. SAICSIT ’17.
New York, NY, USA: Association for Computing Machinery, 2017.
[Online]. Available: https://doi.org/10.1145/3129416.3129440
[42] REMEDY, 2022, https://github.com/NariyoshiChida/SP2022.
[43] J. C. Davis, L. G. Michael IV, C. A. Coghlan, F. Servant, and
D. Lee, “Why aren’t regular expressions a lingua franca? an empirical
study on the re-use and portability of
regular expressions,” in
Proceedings of
the 2019 27th ACM Joint Meeting on European
Software Engineering Conference and Symposium on the Foundations
of Software Engineering, ser. ESEC/FSE 2019. New York, NY, USA:
Association for Computing Machinery, 2019, pp. 443–454. [Online].
Available: https://doi.org/10.1145/3338906.3338909
[44] B. Loring, D. Mitchell, and J. Kinder, “Sound regular expression
semantics for dynamic symbolic execution of javascript,” in Proceedings
of the 40th ACM SIGPLAN Conference on Programming Language
Design and Implementation, ser. PLDI 2019. New York, NY, USA:
Association for Computing Machinery, 2019, pp. 425–438. [Online].
Available: https://doi.org/10.1145/3314221.3314645
[45] M. L. Schmid,
“Characterising
regex
equipped with
languages
Computation, vol. 249, pp. 1 – 17, 2016.
http://www.sciencedirect.com/science/article/pii/S0890540116000109
factor-referencing,”
languages
by
regular
and
[Online]. Available:
Information
[46] B. Cody-Kenny, M. Fenton, A. Ronayne, E. Considine, T. McGuire,
improved performance in regular
and M. O’Neill, “A search for
the Genetic and Evolutionary
in Proceedings of
expressions,”
Computation Conference, ser. GECCO ’17. New York, NY, USA:
Association for Computing Machinery, 2017, pp. 1280–1287. [Online].
Available: https://doi.org/10.1145/3071178.3071196
[47] J. C. Davis, F. Servant, and D. Lee, “Using selective memoization to
defeat regular expression denial of service (redos),” in 2021 2021 IEEE
Symposium on Security and Privacy (SP). Los Alamitos, CA, USA:
IEEE Computer Society, may 2021, pp. 543–559. [Online]. Available:
https://doi.ieeecomputersociety.org/10.1109/SP40001.2021.00032
APPENDIX A
FULL RULES OF THE FORMAL SEMANTICS
The full rules for deriving the matching relation (cid:59) is shown
in Figure 11. We describe the rules for the pure regex features
which were not explained in Section III. In the two rules for a
set of characters, the regex [C] tries to match the string w at the
position p with the function capturing Γ. If the p-th character
w[p] is in the set of character C, then the matching succeeds re-
turning the matching result (p +1,Γ) (SET OF CHARACTERS).
Otherwise, the character w[p] does not match or the position is
at the end of the string, and /0 is returned as the matching result
indicating the match failure (SET OF CHARACTERS FAILURE).
The rules (EMPTY STRING), (CONCATENATION), (UNION)
and (REPETITION) are self explanatory. Note that we avoid
self looping in (REPETITION) by not repeating the match from
the same position.
APPENDIX B
FULL RULES FOR GENERATING
CONSISTENCY-WITH-EXAMPLE CONSTRAINTS
The full rules for generating the consistency-with-examples
constraints is shown in Figure 12. The cases where the
matching fails, that is, (r,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) (/0,{(⊥,⊥,φ )}), are
omitted.
APPENDIX C
THE PROOF OF THEOREM IV.2
We first review EXACTCOVER.
Definition C.1 (Exact Cover). Given a finite set U and S ⊂
P(U ), EXACTCOVER is the problem of deciding if there
exists S ′ ⊆ S such that for every i ∈ U , there is a unique
S ∈ S ′ such that i ∈ S.
Proof. We give a reduction from the exact cover to the repair
problem. Let S = {S1,S2, ...,Sk}. We create the following
(decision version of) RWS1U repair problem:
• The alphabet Σ = U ;
• The set of positive examples P = U ;
• The set of negative examples N = /0;
• The distance bound is 2k; and
• The pre-repair expression r1 = r11r12 where r11 and r12
are as defined below:
r11 = ε(?=[S1])2k(ε)1[S1](ε)2
| ε(?=[S2])2k(ε)3[S2](ε)4
|
...
| ε(?=[Sk])2k(ε)2k−1[Sk](ε)2k
((?!\3)|(?=\3\4))2k...((?!\2k− 1)|(?=\2k− 1\2k))2k.
r12 = ((?!\1)|(?=\1\2))2k
Here, r2k is the expression obtained by concatenating r 2k
times.
It is easy to see that this is a polynomial time reduction
since the construction of r1 can be done in time cubic in
the size of the input EXACTCOVER instance. Also, note that
the above is a valid RWS1U repair problem instance because
P = U ⊆ L(r1) and L(r1)∩ N = /0. We show that reduction
is correct, that is, the input EXACTCOVER instance has a
solution iff there exists r2 satisfying conditions (1)-(3) of
Definition IV.7 and D(r1,r2) ≤ 2k. First, we show the only-
if direction, let S ′ ⊂ S be a solution to the EXACTCOVER
instance. The repaired expression r2 = r21r22 where r22 = r12,
and r21 is r11 but with each i-th head ε in the union replaced
by [/0] iff Si /∈ S ′. Note that D(r1,r2) = 2|S \ S ′| ≤ 2k. Also,
r2 satisfies the RWS1U condition because for every a ∈ U ,
there exists only one Si ∈ S ′ such that a ∈ Si, i.e., on any
input string starting with a, we deterministically move to the
i-th choice in the union (and there are no branches after that
point). Also, r2 correctly classifies the examples. To see this,
consider an arbitrary a ∈ P = U . Then, a is included in some
Si ∈ S ′. Therefore, the matching passes the r21 part with
successful captures at indexes 2i− 1 and 2i, and passes the
r22 part because the negative lookahead (?!\ j) succeeds for
Authorized licensed use limited to: Tsinghua University. Downloaded on August 07,2022 at 12:33:43 UTC from IEEE Xplore.  Restrictions apply. 
152074
p < |w|
w[p] ∈ C
(SET OF CHARACTERS)
([C],w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) ({(p + 1,Γ,φ )}, /0)
(t1,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) (S , F )
∀(pi,Γi,φi) ∈ S . (t2,w, pi,Γi,φi) (cid:57)(cid:57)(cid:75) (Si, Fi)
(t1,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) (S1, F1)
0≤i<|S | Si, F ∪(cid:83)
(t1t2,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) ((cid:83)
0≤i<|S | Fi)
(t1|t2,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) (S1 ∪ S2, F1 ∪ F2)
(t,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) (S , F )
(CONCATENATION)
(t2,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) (S2, F2)
(UNION)
∀(pi,Γi,φi) ∈ (S \{(p,Γ, )}). (t∗,w, pi,Γi,φi) (cid:57)(cid:57)(cid:75) (Si, Fi)
(t∗,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) ({(p,Γ,φ )}∪(cid:83)
((t)i,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) ((cid:83)
(t,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) (S , F )
(pi,Γi,φci)∈S (pi,Γi[i (cid:55)→ w[p..pi)],φci), F )
0≤i<|S | Si, /0)
(REPETITION)
(CAPTURING GROUP)
x = w[p..p +|x|)
Let x = Γ(i)
(\i,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) ({(p +|x|,Γ,φ )}, /0)
(BACKREFERENCE)
(t,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) (S , F )
((?=t),w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) ({(p,Γ′,φ′) | ( ,Γ′,φ′) ∈ S }, F )
(POSITIVE LOOKAHEAD)
(t,w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) (S , F )
((?!t),w, p,Γ,φ ) (cid:57)(cid:57)(cid:75)
({(p,Γ,φ′) | (⊥,⊥,φ′) ∈ F},{(⊥,⊥,φ′) | ( ,
,φ′) ∈ S })
(NEGATIVE LOOKAHEAD)
(x,w[p−|x|, p),0,Γ,φ ) (cid:57)(cid:57)(cid:75) (S , F )
((?<=x),w, p,Γ,φ ) (cid:57)(cid:57)(cid:75) ({(p,Γ,φ′) | (p′,Γ′,φ′) ∈ S }, F )
(POSITIVE LOOKBEHIND)
(x,w[p−|x|, p),0,Γ,φ ) (cid:57)(cid:57)(cid:75) (S , F )
({(p,Γ,φ′) | (⊥,⊥,φ′) ∈ F},{(⊥,⊥,φ′) | ( ,
((?<!x),w, p,Γ,φ ) (cid:57)(cid:57)(cid:75)
,φ′) ∈ S })