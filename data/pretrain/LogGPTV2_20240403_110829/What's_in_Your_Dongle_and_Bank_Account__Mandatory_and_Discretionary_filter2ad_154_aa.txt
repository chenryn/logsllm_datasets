title:What's in Your Dongle and Bank Account? Mandatory and Discretionary
Protection of Android External Resources
author:Soteris Demetriou and
Xiao-yong Zhou and
Muhammad Naveed and
Yeonjoon Lee and
Kan Yuan and
XiaoFeng Wang and
Carl A. Gunter
What’s in Your Dongle and Bank Account?
Mandatory and Discretionary Protection of Android
External Resources
Soteris Demetriou†* , Xiaoyong Zhou‡*,
Muhammad Naveed†, Yeonjoon Lee‡, Kan Yuan‡, XiaoFeng Wang‡, Carl A Gunter†
†Department of Computer Science, University of Illinois at Urbana-Champaign
‡School of Informatics and Computing, Indiana University, Bloomington
{sdemetr2, naveed2, cgunter}@illinois.edu, {zhou, yl52, kanyuan, xw7}@indiana.edu
Abstract—The pervasiveness of security-critical external re-
sources (e.g accessories, online services) poses new challenges to
Android security. In prior research we revealed that given the
BLUETOOTH and BLUETOOTH_ADMIN permissions, a malicious
app on an authorized phone gains unfettered access to any
Bluetooth device (e.g., Blood Glucose meter, etc.). Here we further
show that sensitive text messages from online banking services
and social networks (account balance, password reset links, etc.)
are completely exposed to any app with either the RECEIVE_SMS
or the READ_SMS permission. Similar security risks are present
in other channels (Internet, Audio and NFC) extensively used to
connect the phone to assorted external devices or services. Fun-
damentally, the current permission-based Discretionary Access
Control (DAC) and SEAndroid-based Mandatory Access Control
(MAC) are too coarse-grained to protect those resources: whoever
gets the permission to use a channel is automatically allowed to
access all resources attached to it.
To address this challenge, we present in this paper SEACAT,
a new security system for ﬁne-grained, ﬂexible protection on
external resources. SEACAT supports both MAC and DAC, and
integrates their enforcement mechanisms across the Android
middleware and the Linux kernel. It extends SEAndroid for
specifying policies on external resources, and also hosts a DAC
policy base. Both sets of policies are managed under the same
policy engine and Access Vector Cache that support policy checks
within the security hooks distributed across the framework and
the Linux kernel layers, over different channels. This integrated
security model was carefully designed to ensure that misconﬁg-
ured DAC policies will not affect the enforcement of MAC policies,
which manufacturers and system administrators can leverage to
deﬁne their security rules. In the meantime, a policy management
service is offered to the ordinary Android users for setting policies
that protect the resources provided by the third party. This
service translates simple user selections into SELinux-compatible
policies in the background. Our implementation is capable of
thwarting all known attacks on external resources at a negligible
performance cost.
* The two lead authors are ordered alphabetically.
Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23098
I.
INTRODUCTION
The prosperity of the Android ecosystem brings in a broad
spectrum of external resources (accessories, web services,
etc.), which vastly enrich Android devices’ functionalities.
Nowadays, people use smartphone accessories not only for
convenience and entertainment (e.g., Bluetooth earpieces, USB
travel chargers, etc.), but for performing critical tasks related
with domains such as healthcare and ﬁtness (e.g., diabetes
self-management [34]), ﬁnance (e.g., creditcard payments [8])
and even home security [32]. Furthermore, web resources
are extensively utilized to support Android applications (apps
for short), providing sensitive services like mobile banking,
monetary transactions and investment management [11], [3].
Those external resources carry private user information (health,
ﬁnance, etc.) and are responsible for security-critical operations
(i.e., home security). However, it is not clear whether they are
sufﬁciently protected by mobile operating systems (OS).
External resource protection on Android. In a previous study
we showed that an unauthorized app with the BLUETOOTH
and BLUETOOTH_ADMIN permissions can acquire unfettered
access to Android’s Bluetooth healthcare accessories, and
download sensitive medical data such as a patient’s blood
sugar level from them [28]. Also discovered in prior research is
that network sockets opened by screenshot services are exposed
to any apps with the INTERNET permission, allowing them to
capture the screen of an Android phone at any given point [24].
Note that this lack of control on the network channel can also
have other consequences: for example, given the INTERNET
permission, an untrusted game app might be able to directly
communicate with a corporate internal server, as an authorized
app does. Even popular mobile credit-card payment systems
were known to be vulnerable [26]: it is reported that credit-card
information transmitted by the Square dongle to its mobile app
through the Audio jack was not encrypted and could be easily
picked up by any app with the AUDIO permission.
Although the problem with Square was later ﬁxed with
an AES encryption scheme built
into its dongle (which
increases the cost of the device), such accessory/app side
solutions are rather ad hoc, whose security qualities are hard to
control. Actually, most external resources today are completely
unprotected, for reasons such as the desire to make things easy
for users, limited capabilities of accessories, cost constraints, etc.
Indeed, in our research, we successfully exploited the popular
Jawbone UP wristband [6] (an activity tracker recording a user’s
sleep, eating habits and other daily activities) through the Audio
channel, and downloaded all its data using an unauthorized
app (Section III-B). This lack of protection is also ubiquitous
in apps receiving sensitive information from online resources
through Short Message Service (SMS) and those connected
to external devices using Near-Field Communication (NFC).
More speciﬁcally, we analyzed high-proﬁle online ﬁnancial
services (Bank of America, Chase, PayPal, etc.) and social
networks (Facebook, Twitter, etc.) that deliver messages to
their customers’ devices (which should be received by the
system app com.android.sms or the ofﬁcial apps of those
services), and popular apps that have the NFC capability, and
concluded that they are all vulnerable. Again, we found that
unauthorized apps could get the user’s messages once they are
granted the RECEIVE_SMS or READ_SMS permission, and
read from the NFC devices they are not supposed to touch when
they possess the NFC permission. Of particular concern here are
the short messages from banks, which often contain sensitive
information such as a password for two-factor authentication,
account balances, etc., and therefore should only be seen by
their customers through com.android.sms or other ofﬁcial
apps provided by the vendor. In addition, messages from Twitter
and Facebook even carry links for resetting account passwords.
Such information turns out to be completely unprotected from
unauthorized apps. Demos for the attacks are posted on a private
website [7].
Such threats to external resources are both realistic and
serious, given the fact that indeed a lot of not-so-trustworthy
apps do ask for related permissions (with a good reason for
doing so sometimes) and have already been used by hundreds
of millions of Android users. Take RECEIVE_SMS as an
example. Popular third-party apps like Go Locker (50,000,000
to 100,000,000 installations) use it to receive messages (in
this case, displaying the message on the lock screen). Our
study on 13,500 highly-ranked apps (500 top apps from
each of the 27 Google Play categories) from Google Play
shows that altogether 560 apps require the RECEIVE_SMS
or the READ_SMS permission, gleaning totally over 3 billion
installations (Section III-B). The problem is that once those
apps get the permission, they are also granted the privilege
to read any messages, including those from Chase with one’s
account details, from Facebook with the link for resetting the
password and from Life360 with the information about the
family members’ locations.
Fundamentally, Android is not designed to protect its exter-
nal resources. Speciﬁcally, the Discretionary Access Control
(DAC) mechanism Android provides to its user is based upon
permissions, which are meant for authorizing access to an
Android device’s local resources such as camera, SD card, etc.
When it comes to external resources, all permissions can do is
to merely control individual channels through which the phone
talks to external resources, such as Bluetooth, NFC, Internet,
SMS and Audio. This access control is too coarse-grained to
safeguard external resources of critical importance to the user,
as it cannot differentiate those attached to the same channel,
not to mention implementation of different access policies
to protect them. As a result, whoever gets the permission to
the channel (e.g., BLUETOOTH, AUDIO) is always given full
access to any resources associated with the channel. Even for
the emerging SEAndroid [30] powered kernel, a Mandatory
Access Control (MAC) mechanism incorporated into Android to
enable manufacturers or organizational administrators to specify
and enforce ﬁner-grained security policies, it just covers local
resources (e.g., ﬁles) and cannot even assign a security tag to
an external resource.
Security-enhanced channel control. Given the ongoing trend
of using Android devices to support Internet of Things (IoT) for
security-critical applications (e.g., home security), it becomes
imperative to extend the Android security model to protect
its external resources. This needs to be done on both the
MAC and DAC layers. On one hand, device manufacturers
and organizational administrators should be given the means to
dictate the way their accessories and online resources should
be accessed by apps: for example, only an ofﬁcial Samsung
app is allowed to talk to the Samsung smart watch through
Bluetooth. On the other hand, ﬂexibility needs to be granted to
ordinary users, who utilize third-party accessories (e.g., activity
tracking wristband) and interact with third-party online services
to manage their private information. For example, the user may
hope to install her favorite apps like Go Locker but wants to
ensure that they cannot read her bank’s messages. Development
of such protection mechanisms needs to be well thought-out, to
avoid two separate mechanisms with duplicated functionalities,
which complicates both the implementation and operations of
the security model.
To tackle this prevalent problem, we developed in our
research a suite of new techniques that protect Android external
resources through mediating the channels they use to interact
with the phone. Our approach, called SEACAT (Security-
Enhanced Android Channel Control), integrates both MAC
and DAC in a way that their policy compliance checks and
enforcement go through the same mechanism. This integration
simpliﬁes the design of SEACAT and reduces its operational
overheads. In the meantime, it is warily constructed, to avoid
any interference between these two security models, ensuring
that MAC policies are always followed even when DAC has
been misconﬁgured by the user. More speciﬁcally, we extended
SEAndroid’s implementation on AOSP to describe the external
resources over different channels. This is achieved by deﬁning
new SEAndroid types to represent the resources based upon
their identities observed from their channels, including the MAC
address of the Bluetooth accessory, the serial number of an
NFC device, the IP address of a socket and the ID of an SMS
sender. These types allow a system administrator to specify a
set of mandatory security policies, which are enforced by the
security hooks we placed at system functions related to those
channels within both Android’s framework/library layer and the
Linux kernel. Whenever a call is generated, the hook checks
its policy compliance through an SEAndroid function, and then
determines whether to let the call go through in accordance
with the outcome of the check.
Such operations are always applied to MAC policies ﬁrst.
For the system calls cleared of the MAC policies (that is,
the calling processes are not touching any resources speciﬁed
by the policy administrator), the hook further checks their
compliance with a set of DAC policies, using the same function.
These policies are deﬁned in the same format as their MAC
counterparts. They are maintained by a policy management
service, through which an Android user and app developers can
specify how an external device or an Internet service should be
2
accessed by different apps, when those external resources are
not included in any MAC policy. For example, the ofﬁcial app
of the Chase bank can specify within its manifest ﬁle a DAC
rule that only itself and the system app (com.android.sms)
are allowed to receive text messages from the bank. Once this
rule is approved by the phone user, a malicious app running
on the phone will no longer be able to read messages from
Chase, even when it has either the RECEIVE_SMS or the
READ_SMS permission. Furthermore, this hybrid MAC/DAC
approach enables SEACAT to protect even resources with
no apparent identiﬁers: a user can leverage SEACAT’s DAC
component to restrict access to a channel when that is being
used to communicate sensitive information.
We implemented SEACAT on Android 4.4 with the SEAn-
droid enhanced kernel 3.4.0 (AOSP 4.4.2 r12). Our prototype
was run against all known attacks on different external resources,
including the new ones we discovered in this work and those
reported in prior research [28], [24]. Our study shows that
SEACAT easily defeated all those attacks, at a very low
performance overhead.
Contributions. We outline the paper’s contributions below:
• New understanding. We investigated a set of channels that
have not been systematically studied by prior research [28],
[24], including SMS, Audio and NFC. Our ﬁndings provide
further evidence pertaining Android’s limitations in securing
its external resources and highlight the need for ﬁner-grained
access control techniques to protect them.
• New techniques. We designed the ﬁrst mechanism that
provides a centralized and comprehensive protection of different
kinds of Android external resources over their channels. Our
approach supports both MAC and DAC in an integrated, highly
efﬁcient way, without undermining their security guarantees.
These new techniques allow both system administrators and
ordinary Android users to specify their policies and safeguard
their accessories and other external resources.
• Implementation and evaluation. We implemented our design
and evaluated our system against all known threats and also
measured its performance. Our prototype successfully addresses
all known security risks and can be swiftly extended to protect
new channels.
II. BACKGROUND
Android external resources and channels. Android and other
mobile systems are routinely employed by their owners for
managing their external resources. Particularly, almost every
app running on these systems is supported by a remote service,
which interacts with the app through the Internet or the
telephone network (using short text messages). Such services
are increasingly being utilized to store and process private user
information, particularly the data related to online banking, so-
cial networking, investment, healthcare, etc. Moreover, the trend
of leveraging smartphones to support the Internet of Things,
brings in a whole new set of external devices, which carry
much more sensitive data than conventional accessories (e.g.,
earpieces, game stations). Examples include health and ﬁtness
systems (e.g., blood pressure monitors [31], electrocardiography
sensors [33], glucose meters [23]), remote vehicle controllers
(e.g., Viper SmartStart [10]), home automation and security
systems [32] and others. Those external devices and Internet
resources are connected to smartphones through a variety of
channels, which are essentially a set of hardware and software
through which an app accesses the external resources. The most
popular channels include Bluetooth, NFC, Internet, SMS and
Audio.
Android security model. Android comes with a discretionary
access control system characterized by its application sand-
boxing and permission model. Naturally, all third-party apps
are considered untrusted by the system. Each Android app is
conﬁned within its own sandbox, which is enforced through
the Linux-kernel level protection: every app runs as a separate
Linux user whose data and process are isolated from those of
other apps. To access the resources outside its sandbox, the
app can get permissions from the system if it is signed by
the manufacturers or other authorized parties or directly from
the device owner when the app is installed. Those permissions
enable the app to use sensitive resources such as GPS, camera,
etc. This security model has been implemented across different
Android layers, including the application-framework/library
layer (also called middleware) and the Linux kernel layer.
A problem of this security model is its coarse granularity.
Speciﬁcally, for each channel an app needs to go through to
touch external resources, the permission-based DAC is binary:
the app is either granted unrestricted use of the channel to
communicate with any resources attached to it, or denied
the channel in its entirety. This is the root cause for the
Bluetooth mis-bonding problem we have reported in prior
research [28], in which any app with the BLUETOOTH and
BLUETOOTH_ADMIN permissions becomes entitled to access
sensitive patient data collected by a health-care device.
SEAndroid. Security-Enhanced Android is a mandatory access
control system built on top of Android [30]. It is designed
to mediate all interactions of an app with the Linux kernel
and other system resources. Furthermore, SEAndroid conﬁnes
even system daemons to limit the damage they can cause
once they are compromised. It also provides a centralized
policy conﬁguration for system administrators and device
manufacturers to specify their policies.
More speciﬁcally, SEAndroid [30] associates with each
subject (e.g., process) and object (e.g., ﬁle) a security context
represented as a sequence user: role: domain or
type[: level] and indexed by a Security Identiﬁer
(SID). The most important component here is the type1.
Under a type enforcement (TE) architecture, a security policy
dictates whether a process running within a domain is
allowed to access an object labeled with a certain type.
Following is a policy speciﬁed for all
third-party apps:
allow
shell_data_file:file
rw_file_perms. This policy states that all
the apps
associated with the domain untrusted_app are allowed
to perform “rw_file_perms” operations on the objects
associated with the type shell_data_ file which is of
class2 file.
untrusted_app
The SEAndroid module currently incorporated into the
1role is for role-based access and level for multi-level security.
2A class deﬁnes a set of operations that can be performed on all objects
associated with a type.
3
media_app;
release_app