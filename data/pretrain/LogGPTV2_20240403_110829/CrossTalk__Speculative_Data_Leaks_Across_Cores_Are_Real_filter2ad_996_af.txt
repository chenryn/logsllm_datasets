other chip vendors delegate mitigations of traditional covert/-
side channels entirely to software [56], recommending the
use of constant-time code manually or automatically gener-
ated [57] in security-sensitive applications.
X. CONCLUSION
We have shown that transient execution attacks can reach
beyond individual CPU cores. With CROSSTALK, we used
performance counters to investigate the behavior of microcode
and study the potential attack surface behind complex instruc-
tions whose execution may rely heavily on the operands with
and context in which they are executed. We further investigated
the data these instructions leave behind in microarchitectural
buffers using MDS attacks and uncovered a global ‘staging
buffer’ which can be used to leak data between CPU cores.
The cryptographically-secure RDRAND and RDSEED in-
structions turn out to leak their output to attackers via this
buffer on many Intel CPUs, and we have demonstrated that
this is a realistic attack. We have also seen that, yet again, it
is almost trivial to apply these attacks to break code running
in Intel’s secure SGX enclaves.
Worse, mitigations against existing transient execution at-
tacks are largely ineffective. The majority of current miti-
gations rely on spatial isolation on boundaries which are no
longer applicable due to the cross-core nature of these attacks.
New microcode updates which lock the entire memory bus for
these instructions can mitigate these attacks – but only if there
are no similar problems which have yet to be found.
ACKNOWLEDGMENTS
We thank our shepherd, Frank Piessens, and the anonymous
reviewers for their valuable feedback. We would also like to
thank Marius Muench for his help with the paper and Stephan
van Schaik for his work on RIDL. This work was supported by
the European Union’s Horizon 2020 research and innovation
programme under grant agreements No. 786669 (ReAct) and
No. 825377 (UNICORE), by Intel Corporation through the
Side Channel Vulnerability ISRA, by the United States Ofﬁce
of Naval Research (ONR) under contract N00014-17-1-2782,
and by the Netherlands Organisation for Scientiﬁc Research
through grants NWO 639.021.753 VENI ”PantaRhei”, and
NWO 016.Veni.192.262. This paper reﬂects only the authors’
view. The funding agencies are not responsible for any use
that may be made of the information it contains.
DISCLOSURE
We disclosed an initial PoC of staging buffer leaks to Intel
in September 2018, followed by cross-core RDRAND/RDSEED
leakage in July 2019. Following our reports, Intel rewarded
CROSSTALK with the Intel Bug Bounty (Side Channel) Pro-
gram, and attributed the disclosure to our team with no other
independent ﬁnders. Intel requested an embargo until May
2020 (later extended), due to the difﬁculty of implementing
a ﬁx for the vulnerabilities identiﬁed in this paper.
Intel describes our attack as “Special Register Buffer Data
Sampling” or SRBDS (CVE-2020-0543), classifying it as a
domain-bypass transient execution attack [36]. After disclo-
sure, Intel informed us that the issue had also been found
internally, by Rodrigo Branco, Kekai Hu, Gabriel Negreira
Barbosa and Ke Sun.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:28:49 UTC from IEEE Xplore.  Restrictions apply. 
1865
REFERENCES
[1] M. Lipp, M. Schwarz, D. Gruss, T. Prescher, W. Haas, A. Fogh,
J. Horn, S. Mangard, P. Kocher, D. Genkin, Y. Yarom, and M. Hamburg,
“Meltdown: Reading Kernel Memory from User Space,” in USENIX
Security’18.
[2] P. Kocher, J. Horn, A. Fogh, , D. Genkin, D. Gruss, W. Haas, M. Ham-
burg, M. Lipp, S. Mangard, T. Prescher, M. Schwarz, and Y. Yarom,
“Spectre Attacks: Exploiting Speculative Execution,” in S&P’19.
[3] J. V. Bulck, M. Minkin, O. Weisse, D. Genkin, B. Kasikci, F. Piessens,
M. Silberstein, T. F. Wenisch, Y. Yarom, and R. Strackx, “Foreshadow:
Extracting the Keys to the Intel SGX Kingdom with Transient Out-of-
Order Execution,” in USENIX Security’18.
[4] M. Schwarz, M. Lipp, D. Moghimi, J. Van Bulck, J. Stecklina,
T. Prescher, and D. Gruss, “ZombieLoad: Cross-privilege-boundary data
sampling,” in CCS’19.
[5] S. van Schaik, A. Milburn, S.
¨Osterlund, P. Frigo, G. Maisuradze,
K. Razavi, H. Bos, and C. Giuffrida, “RIDL: Rogue in-ﬂight data load,”
in S&P, May 2019.
[6] B.
Gregg,
“KPTI/KAISER Meltdown
Performance
Regressions,” 2018. [Online]. Available: https://www.linux.com/news/
kptikaiser-meltdown-initial-performance-regressions/
Initial
[7] M. Larabel, “Looking At The Linux Performance Two Years After
Spectre / Meltdown Mitigations,” 2020. [Online]. Available: https:
//www.phoronix.com/scan.php?page=article&item=spectre-meltdown-2
[8] Intel, “Deep Dive: Intel Transactional Synchronization Extensions (Intel
TSX) Asynchronous Abort,” 2019.
[9] Microsoft, “Managing Hyper-V hypervisor scheduler types,” 2019.
[Online]. Available: https://docs.microsoft.com/en-us/windows-server/
virtualization/hyper-v/manage/manage-hyper-v-scheduler-types
[10] J. Corbet, “Many uses for Core scheduling,” 2019. [Online]. Available:
https://lwn.net/Articles/799454/
[11] A. Abel and J. Reineke, “uops.info: Characterizing latency, throughput,
and port usage of instructions on intel microarchitectures,” in ASPLOS,
2019.
[12] E. M. Koruyeh, K. N. Khasawneh, C. Song, and N. Abu-Ghazaleh,
“Spectre Returns! Speculation Attacks using the Return Stack Buffer,”
in USENIX WOOT’18.
[13] C. Canella, D. Genkin, L. Giner, D. Gruss, M. Lipp, M. Minkin,
D. Moghimi, F. Piessens, M. Schwarz, B. Sunar, J. Van Bulck, and
Y. Yarom, “Fallout: Leaking Data on Meltdown-resistant CPUs,” in
CCS’19.
[14] R. Mcilroy, J. Sevcik, T. Tebbi, B. Titzer, and T. Verwaest, “Spectre is
here to stay: An analysis of side-channels and speculative execution,”
arXiv preprint arXiv:1902.05178, 2019.
[15] L. Gwennap, “P6 microcode can be patched,” Microprocessor Report,
[16] V. Costan and S. Devadas, “Intel SGX Explained,” IACR Cryptology
1997.
ePrint Archive, 2016.
[17] J. Mechalas, “Intel®Digital Random Number Generator (DRNG),” 2018.
[18] A. Abel and J. Reineke, “nanoBench: A Low-Overhead Tool for Running
Microbenchmarks on x86 Systems,” arXiv preprint arXiv:1911.03282,
2019.
[19] Intel, “Microarchitectural Data Sampling / CVE-2018-12126,CVE-2018-
12127,CVE-2018-12130,CVE-2019-11091 / INTEL-SA-00233,” 2019.
[20] D. Faggioli, “Core-Scheduling for Virtualization: Where are We? (If We
Want It!),” in KVM Forum, 2019.
[21] S. Weiser, D. Schrammel, L. Bodner, and R. Spreitzer, “Big Numbers–
Big Troubles: Systematically Analyzing Nonce Leakage in (EC) DSA
Implementations,” in USENIX Security’20.
[22] T. Allan, B. B. Brumley, K. Falkner, J. Van de Pol, and Y. Yarom, “Am-
plifying side channels through performance degradation,” in ACSAC,
2016.
[23] Y. Yarom, “Mastik: A micro-architectural side-channel toolkit,” 2016.
[24] J. Van Bulck, F. Piessens, and R. Strackx, “SGX-step: A Practical Attack
Framework for Precise Enclave Execution Control,” in SysTEX’17.
[25] M. Ermolov and M. Goryachy, “How to hack a turned-off computer, or
running unsigned code in intel management engine,” Black Hat Europe,
2017.
[26] Intel, “INTEL-SA-00307: Intel CSME Advisory,” 2020.
[27] ——, “The Intel Converged Security and Management Engine IOMMU
Hardware Issue – CVE-2019-0090,” 2019.
[28] P. Das, L. Eckey, T. Frassetto, D. Gens, K. Host´akov´a, P. Jauernig,
S. Faust, and A.-R. Sadeghi, “Fastkitten: practical smart contracts on
bitcoin,” in USENIX Security’19.
Affected:
Sampling,”
“Processors
Data
[29] A. Ahmad, B. Joe, Y. Xiao, Y. Zhang, I. Shin, and B. Lee, “OBFUS-
CURO: A Commodity Obfuscation Engine on Intel SGX.” in NDSS’19.
Register
Available:
[30] Intel,
Buffer
https://software.intel.com/security-software-guidance/insights/
processors-affected-special-register-buffer-data-sampling
[31] ——, “Changes to rdrand integration in openssl,” 2014.
[32] M.-W. Shih, S. Lee, T. Kim, and M. Peinado, “T-SGX: Eradicating
Controlled-Channel Attacks Against Enclave Programs,” in NDSS, 2017.
[33] S. Chen, X. Zhang, M. K. Reiter, and Y. Zhang, “Detecting privileged
side-channel attacks in shielded execution with D´ej´a Vu,” in AsiaCCS
’17, 2017.
Special
[Online].
2020.
[34] O. Oleksenko, B. Trach, R. Krahn, M. Silberstein, and C. Fetzer,
“Varys: Protecting SGX enclaves from practical side-channel attacks,”
in USENIX ATC 18, 2018.
[35] Intel, “Side Channel Vulnerabilities: Microarchitectural Data Sampling
and Transactional Asynchronous Abort,” 2019.
[36] ——, “Deep Dive: Special Register Buffer Data Sampling,” 2020. [On-
line]. Available: https://software.intel.com/security-software-guidance/
insights/deep-dive-special-register-buffer-data-sampling
[37] M. Larabel, “Benchmarking The Updated Intel CPU Microcode For
SRBDS / CrossTalk Mitigation,” 2020. [Online]. Available: https://www.
phoronix.com/scan.php?page=article&item=srbds-crosstalk-benchmark
[38] A. Gendler, L. Novakovsky, and A. Szapiro, “Communicating via a
mailbox interface of a processor,” Jan 2015, US Patent Appl. 14/609,835.
[39] G. Cox, “Delivering New Platform Technologies,” in SBSeg’12.
[40] S. van Schaik, M. Minkin, A. Kwong, D. Genkin, and Y. Yarom,
“Cacheout: Leaking data on intel cpus via cache evictions.”
[41] C. Canella, J. V. Bulck, M. Schwarz, M. Lipp, B. von Berg, P. Ortner,
F. Piessens, D. Evtyushkin, and D. Gruss, “A systematic evaluation of
transient execution attacks and defenses,” in USENIX Security’19, 2019.
[42] J. Van Bulck, D. Moghimi, M. Schwarz, M. Lipp, M. Minkin, D. Genkin,
Y. Yuval, B. Sunar, D. Gruss, and F. Piessens, “LVI: Hijacking Transient
Execution through Microarchitectural Load Value Injection,” in S&P,
2020.
[43] B. Falk, “CPU Introspection: Intel Load Port Snooping,” 2019.
[44] A. Bhattacharyya, A. Sandulescu, M. Neugschwandtner, A. Sorniotti,
B. Falsaﬁ, M. Payer, and A. Kurmus, “Smotherspectre: exploiting
speculative execution through port contention,” in CCS’19.
[45] A. C. Aldaya, B. B. Brumley, S. ul Hassan, C. P. Garc´ıa, and N. Tuveri,
“Port contention for fun and proﬁt,” in S&P’19.
[46] B. Gras, K. Razavi, H. Bos, and C. Giuffrida, “Translation Leak-aside
Buffer: Defeating Cache Side-channel Protections with TLB Attacks,”
in USENIX Security’18.
[47] Y. Yarom and K. Falkner, “FLUSH + RELOAD: a high resolution, low
noise, L3 cache side-channel attack,” in USENIX Security’14.
[48] Q. Ge, Y. Yarom, D. Cock, and G. Heiser, “A survey of microarchitec-
tural timing attacks and countermeasures on contemporary hardware,”
Journal of Cryptographic Engineering, 2018.
[49] E. De Mulder, M. Hutter, M. E. Marson, and P. Pearson, “Using
Bleichenbacher’s solution to the hidden number problem to attack nonce
leaks in 384-bit ECDSA,” in International Workshop on Cryptographic
Hardware and Embedded Systems, 2013.
[50] Y. Yarom and N. Benger, “Recovering OpenSSL ECDSA Nonces Using
the FLUSH+RELOAD Cache Side-channel Attack.” IACR Cryptology
ePrint Archive, 2014.
[51] Y. Xu, W. Cui, and M. Peinado, “Controlled-channel attacks: Determin-
istic side channels for untrusted operating systems,” in S&P’15.
[52] J. Van Bulck, F. Piessens, and R. Strackx, “Nemesis: Studying microar-
chitectural timing leaks in rudimentary CPU interrupt logic,” in CCS’18.
[53] W. He, W. Zhang, S. Das, and Y. Liu, “Sgxlinger: A new side-channel
attack vector based on interrupt latency against enclave execution,” in
International Conference on Computer Design (ICCD).
IEEE, 2018.
[54] D. Moghimi, J. Van Bulck, N. Heninger, F. Piessens, and B. Sunar,
“Copycat: Controlled instruction-level attacks on enclaves for maximal
key extraction,” arXiv preprint arXiv:2002.08437, 2020.
[55] D. Evtyushkin and D. Ponomarev, “Covert channels through random
number generator: Mechanisms, capacity estimation and mitigations,”
in CCS’16.
[56] Intel, “Guidelines for mitigating timing side channels against crypto-
graphic implementations,” 2019.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:28:49 UTC from IEEE Xplore.  Restrictions apply. 
1866
[57] A. Rane, C. Lin, and M. Tiwari, “Raccoon: Closing digital side-channels
through obfuscated execution,” in USENIX Security’15.
APPENDIX A
EXAMPLE CODE
The code in Listing 4 leaks a byte from the staging buffer
using TAA, without SMT. If SMT is available to the attacker,
the leaking primitive (here, CPUID) can instead be run in a
tight loop on a sibling thread, and the code marked “ﬂush
some cache lines” is no longer required (see Section V).
See https://www.vusec.net/projects/crosstalk for complete
ready-to-run PoCs (proof-of-concepts).
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
/* reloadbuf, flushbuf and leak are just
* mmap()ed buffers */
// Flush the Flush+Reload buffer entries.
for (size_t k = 0; k < 256; ++k) {
size_t x = ((k * 167) + 13) & (0xff);
volatile void *p = reloadbuf + x * 1024;
asm volatile("clflush (%0)\n"::"r"(p));
}
/* Leak primitive; as an example,
* here we use a CPUID leaf. */
asm volatile(
"movabs $0x80000002, %%rax\n"
"cpuid\n"
:::"rax","rbx","rcx","rdx"
);
/* Flush some cache lines
* (until we get the right LFB).*/
for (size_t n = 0; n < 15; ++n)
asm volatile("clflush (%0)\n"
::"r"(reloadbuf + (n + 256)*0x40));
/* Perform a TAA-based leak */
asm volatile(
conflict
// prepare an abort through cache
(cid:44)→
"clflush (%0)\n"
"sfence\n"
"clflush (%2)\n"
// leak inside transaction
"xbegin 1f\n"
"movzbq 0x0(%0), %%rax\n"
"shl $0xa, %%rax\n"
"movzbq (%%rax, %1), %%rax\n"
"xend\n"
"1:\n"
"mfence\n"
:
:"r"(leak+off),
"r"(reloadbuf),
"r"(flushbuf)
:"rax"
);
/* Reload from the flush+reload buffer
* to find the leaked value. */
for (size_t k = 0; k < 256; ++k) {
size_t x = ((k * 167) + 13) & (0xff);
unsigned char *p =
reloadbuf + (1024 * x);
uint64_t t0 = rdtscp();
*(volatile unsigned char *)p;
uint64_t dt = rdtscp() - t0;
if (dt < 160) results[x]++;
}
Listing 4: Leaking a value from the staging buffer.
Authorized licensed use limited to: Tsinghua University. Downloaded on February 25,2022 at 12:28:49 UTC from IEEE Xplore.  Restrictions apply. 
1867