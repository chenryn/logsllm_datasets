exp(ğœ–)+ğ‘¢âˆ’1 and
domain (which returns the input with probability
any other domain value with equal probability). To estimate can-
didate frequency, the server hashes all current prefix candidates,
and matches them to each report. The parameter ğœ‚ provides the
following trade-off: Smaller values lead to more groups but less
(hash) computations, whereas larger values produces fewer groups
but requires more computational resources. Note that more groups
means fewer counts per prefix candidate which can lead to reduced
accuracy. Wang et al. [78] set ğ›¾ = âŒˆlog2 ğ‘˜âŒ‰ and limit the number
of hash computations per report to 220 (i.e., set ğœ‚ to the largest
integer satisfying ğ‘”2ğ›¾+ğœ‚ 
ğ‘›/(ğ‘¡ + 1) below actual frequency ğ‘“ğ‘ (Lemma 1). Thus, ğ‘‡ [ğ‘] >
ğ‘“ğ‘ âˆ’ ğ‘›/(ğ‘¡ + 1) using the fact that Laplace noise is 0 in expectation
and replacing ğ‘“ğ‘ with ğ‘“ğ‘˜-th, we have ğœHH + ğ‘›/(ğ‘¡ + 1) < ğ‘“ğ‘˜-th.
Analogously, PEM does not release candidate ğ‘ if its count is
below the threshold, i.e.,ğ‘‡ [ğ‘]+Laplace(1/ğœ–) â‰¤ ğœPEM+Laplace(1/ğœ–).
Assuming data is distributed uniformly between groups, we have
|C|-th, replacing ğ‘“ğ‘
ğ‘‡ [ğ‘] = ğ‘“ğ‘/ğ‘”. Assuming expected noise and ğ‘§ = ğ‘“
by ğ‘“ğ‘˜-th as before, we arrive at ğ‘“ğ‘˜-th/ğ‘” â‰¤ ğ‘“
|C|-th + ğœPEM, which is
the right side of the inequality when multiplied with ğ‘”.
â–¡
For fixed ğœ‚, larger domain bit-length leads to larger group size ğ‘”
in FPEM. Since FHH is independent of the domain size, it provides
better accuracy in such cases, as the counts per value are not split
among multiple groups. However, we want to keep ğ‘¡ small and
fixed for our MPC protocol, as FHH requires ğ‘¡ operations per datum
in the worst case (decrement step). Fixed ğ‘¡ reduces accuracy for
increasing data sizes (Lemma 1); therefore, FHH is better suited
for small data sets (small ğ‘›). Our empirical analysis in Section 5
confirms these observations.
variable ğ‘‹ âˆ¼ Laplace(ğ‘) can be expressed asğ‘›
3.4 Distributed Noise Generation
Sampling the noise for FHH, FPEM with secure computation [51]
is inefficient, as the parties have to securely evaluate expensive
(floating or fixed point) operations [3]3. It is more efficient to use
distributed noise generation, by letting each party locally com-
pute partial noises, which are securely combined, as often found
in DP literature [2, 35, 47, 49]. Distributed noise generation is pos-
sible for distributions that are infinitely divisible, i.e., noise sam-
ples can be expressed as the sum of independent and identically
distributed random variables. Both distributions used in our pro-
tocols, namely Laplace and Gumbel, are infinitely divisible [2, 21].
Thus, we can efficiently combine partial noise values: A random
ğ‘— ) for
ğ‘— , ğ‘Œ 2
ğ‘Œ 1
ğ‘› , ğ‘), where the Gamma distribution with shape
ğ‘— âˆ¼ Gamma(
ğ‘˜, scale ğ‘ has density Gamma(ğ‘¥; ğ‘˜, ğ‘) =
ğ‘ ) [2].
To avoid floating point numbers, which require secure computa-
tion overhead compared to integers [3], one can use the discrete
Laplace distribution defined over integers. The discrete Laplace
distribution is infinitely divisible and can be expressed as the differ-
ence of two PÃ³lya random variables as noted by Goryczka et al. [47].
Recent works consider alternative Laplace noise representations on
finite machines, e.g., [9, 10, 44], which we can leverage as well. The
3Given a uniform random number ğ‘Ÿ âˆˆ (0, 1] one can sample Laplace(ğ‘) as Â±ğ‘ log(ğ‘Ÿ)
[51, Supplementary Material].
ğ‘— âˆ’ ğ‘Œ 2
Î“(ğ‘˜)ğ‘ğ‘˜ ğ‘¥ğ‘˜âˆ’1 exp(âˆ’ ğ‘¥
ğ‘—=1(ğ‘Œ 1
1
1
Table 1: Basic MPC protocols.
MPC protocol
EQ(âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©)
LE(âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©)
ADD(âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©)
AND(âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©)
NOT(âŸ¨ğ‘âŸ©)
CondSwap(âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©, âŸ¨ğ‘âŸ©)
Rec(âŸ¨ğ‘âŸ©)
Output / Functionality
âŸ¨1âŸ© if ğ‘ = ğ‘, else âŸ¨0âŸ©
âŸ¨1âŸ© if ğ‘ â‰¤ ğ‘, else âŸ¨0âŸ©
âŸ¨ğ‘ + ğ‘âŸ©
âŸ¨ğ‘ Â· ğ‘âŸ©
âŸ¨1 âˆ’ ğ‘âŸ©
âŸ¨ğ‘âŸ© if bit ğ‘ = 1, else âŸ¨ğ‘âŸ©
Reconstruct secret ğ‘
distributed noise representation does not affect our MPC efficiency
as they are based on (integer) addition. Note that ğ›¿ depends on a
security parameter, associated with number representation in MPC,
which we account for in Section 4.4. We discuss distributed noise
generation for Gumbel noise in Appendix C.
4 MPC FOR DP HEAVY HITTERS
We describe details of our MPC protocols HH, PEM which realize
the ideal functionalities FHH, FPEM without a trusted party, and
analyse their running time and security.
We use upper case letters to denote arrays in our protocol, and
ğ´[ ğ‘—] denotes the ğ‘—-th element in array ğ´. We indicate Boolean
values (in the form of a bit) with ğ‘state (e.g., ğ‘match = 1 indicates a
match). The MPC subprotocols used in our protocol are listed in
Table 1. While most of our computation can be represented with
integers, our protocol uses fixed point numbers (scaled, truncated
floats) to handle DP noise. Limited machine precision of floating
point numbers can lead to privacy violations in the implementation
of the Laplace mechanism [62], i.e., possible outcomes can differ
between neighboring data sets due to irregularities in representing
reals). These violations can be mitigated by careful truncation and
rounding. We do not release noisy counts and do not use floating
point numbers, nonetheless, similar attacks might exist without
careful selection of fixed-point numbers.
4.1 HH: MPC of FHH
Instead of a map ğ‘‡ , as in FHH, we use two arrays ğ‘‰ , ğ¶, that store
a value and its corresponding count at the same index. HH imple-
ments the different if-else branches of FHH by using (secret) bits:
ğ‘found indicates if a value is already in ğ‘‰ ; ğ‘empty,ğ‘— indicates if we
had no match (NOT(ğ‘found)) but index ğ‘— is empty; and ğ‘decrement
is true if we did not find a match and have no empty spots left. We
employ the following optimizations to reduce the number of MPC
protocols: Instead of using OR to combine bit ğ‘match into ğ‘found we
add each bit ğ‘match (which can be 1 at most once) to form ğ‘found
(which is 1 only if any match occurred) in line 7. This is beneficial,
since ADD can be evaluated locally in secret sharing, i.e., without
interaction, whereas arithmetic expression of OR is ğ‘+ğ‘ âˆ’ ğ‘ Â·ğ‘, and
multiplications requires interaction between the parties (see also
Appendix E). Similarly, we reduce the number of conditional swaps
by directly using ğ‘decrement as a decrement value. Furthermore, we
do not need to remove values associated with empty counts, saving
additional swaps: We only use counts to check if a value is empty
and if the value is matched (even with empty count), we set the new
count to 1 (line 16), i.e., same as if we had not matched and found
Session 7D: Privacy for Distributed Data and Federated Learning CCS â€™21, November 15â€“19, 2021, Virtual Event, Republic of Korea 2366Initialize âŸ¨ğ‘foundâŸ© â† âŸ¨0âŸ© and âŸ¨ğ‘–emptyâŸ© â† âŸ¨âˆ’1âŸ©
for index ğ‘— â† 1 to ğ‘¡ do
âŸ¨ğ‘matchâŸ© â† EQ(âŸ¨ğ‘‘âŸ©, âŸ¨ğ‘‰ [ ğ‘—]âŸ©)
âŸ¨ğ‘emptyâŸ© â† LE(âŸ¨ğ¶[ ğ‘—]âŸ©, âŸ¨0âŸ©)
âŸ¨ğ‘foundâŸ© â† ADD(âŸ¨ğ‘foundâŸ©, âŸ¨ğ‘matchâŸ©)
âŸ¨ğ‘–emptyâŸ© â† CondSwap(âŸ¨ğ‘—âŸ©, âŸ¨ğ‘–emptyâŸ©, âŸ¨ğ‘emptyâŸ©)
âŸ¨ğ¶[ ğ‘—]âŸ© â† ADD(âŸ¨ğ¶[ ğ‘—]âŸ©, âŸ¨ğ‘matchâŸ©)
end for
Â¬emptyâŸ© â† EQ(âŸ¨ğ‘–emptyâŸ©, âŸ¨âˆ’1âŸ©)
âŸ¨ğ‘
âŸ¨ğ‘decrementâŸ© â† AND(âŸ¨ğ‘
Â¬emptyâŸ©, NOT(âŸ¨ğ‘foundâŸ©))
for index ğ‘— â† 1 to ğ‘¡ do //Conditional decrement
âŸ¨ğ‘empty,ğ‘— âŸ© â† AND(NOT(âŸ¨ğ‘matchâŸ©), EQ(âŸ¨ğ‘–emptyâŸ©, âŸ¨ğ‘—âŸ©))
âŸ¨ğ‘âŸ© â† ADD(âŸ¨ğ¶[ ğ‘—]âŸ©, âŸ¨âˆ’ğ‘decrementâŸ©)
âŸ¨ğ¶[ ğ‘—]âŸ© â† CondSwap(âŸ¨1âŸ©, âŸ¨ğ‘âŸ©, âŸ¨ğ‘empty,ğ‘— âŸ©)
âŸ¨ğ‘‰ [ ğ‘—]âŸ© â† CondSwap(âŸ¨ğ‘‘âŸ©, âŸ¨ğ‘‰ [ ğ‘—]âŸ©, âŸ¨ğ‘empty,ğ‘— âŸ©)
end for
Algorithm 1 Algorithm HH.
Input: User data ğ·, distributed noises ğœŒğ‘ per party ğ‘ âˆˆ P, output size ğ‘˜,
map size ğ‘¡, and DP threshold ğœHH.
Output: DP top-ğ‘˜.
1: Initialize arrays âŸ¨ğ‘‰ âŸ©, âŸ¨ğ¶âŸ© of size ğ‘¡ with âŸ¨âŠ¥âŸ©, âŸ¨0âŸ©, resp.
2: for user datum ğ‘‘ âˆˆ ğ· do //Update counts ğ¶ for values ğ‘‰
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19: end for
20: for index ğ‘— â† 1 to ğ‘¡ do //DP thresholding on noisy ğ¶
21:
22: